<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-05-11T14:54:32.869Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>千里之行，始于足下。不积跬步，无以至千里。</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[Git - 分支管理]]></title>
        <id>https://lixin-scut.github.io//post/git-fen-zhi-guan-li</id>
        <link href="https://lixin-scut.github.io//post/git-fen-zhi-guan-li">
        </link>
        <updated>2020-05-11T13:27:55.000Z</updated>
        <content type="html"><![CDATA[<p>分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p>
<p>现在有了分支，就不用怕了。你<strong>创建了一个属于你自己的分支</strong>，别人看不到，还<strong>继续在原来的分支上正常工作</strong>，而你在自己的分支上干活，想提交就提交，直到<strong>开发完毕后，再一次性合并到原来的分支上</strong>，这样，既安全，又不影响别人工作。</p>
<p>其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支慢，结果分支功能成了摆设，大家都不去用。</p>
<p>但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。</p>
<h2 id="创建与合并分支">创建与合并分支</h2>
<h3 id="分支概念">分支概念</h3>
<p>在版本回退里，每次提交Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫<strong>主分支，即master分支</strong>。<strong>HEAD严格来说不是指向提交，而是指向master</strong>，master才是指向提交的，所以，HEAD指向的就是当前分支。</p>
<p>一开始的时候，<strong>master分支是一条线</strong>，Git<strong>用master指向最新的提交</strong>，<strong>再用HEAD指向master</strong>，就能确定当前分支，以及当前分支的提交点：<br>
<img src="https://lixin-scut.github.io//post-images/1589204783529.png" alt=""></p>
<p><strong>每次提交，master分支都会向前移动一步</strong>，这样，随着你不断提交，master分支的线也越来越长。</p>
<p>当我们<strong>创建新的分支，例如dev时</strong>，Git<strong>新建了一个指针叫dev</strong>，指向master相同的提交，<strong>再把HEAD指向dev</strong>，就表示当前分支在dev上：<br>
<img src="https://lixin-scut.github.io//post-images/1589204824262.png" alt=""></p>
<p>你看，Git创建一个分支很快，因为<strong>除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化</strong>！</p>
<p>不过，<strong>从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变</strong>：</p>
<p><img src="https://lixin-scut.github.io//post-images/1589204958791.png" alt=""></p>
<p>假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：<br>
<img src="https://lixin-scut.github.io//post-images/1589204995130.png" alt=""></p>
<p><strong>所以Git合并分支也很快！就改改指针，工作区内容也不变！</strong></p>
<p>合并完分支后，甚至可以删除dev分支。<strong>删除dev分支就是把dev指针给删掉</strong>，删掉后，我们就剩下了一条master分支：</p>
<p><img src="https://lixin-scut.github.io//post-images/1589205086707.png" alt=""></p>
<h3 id="创建分支">创建分支</h3>
<p>首先，我们创建dev分支，然后切换到dev分支：</p>
<pre><code>$ git checkout -b dev

Switched to a new branch 'dev'
</code></pre>
<p><strong>git checkout命令加上-b参数表示创建并切换</strong>，相当于以下两条命令：</p>
<pre><code>$ git branch dev
$ git checkout dev
Switched to branch 'dev'
</code></pre>
<p>然后，用git branch命令查看当前分支：</p>
<pre><code>$ git branch
* dev
  master
</code></pre>
<p>git branch命令会列出所有分支，当前分支前面会标一个*号。</p>
<p>然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行：</p>
<pre><code>Creating a new branch is quick.
</code></pre>
<p>然后提交：</p>
<pre><code>$ git add readme.txt 
$ git commit -m &quot;branch test&quot;
[dev b17d20e] branch test
 1 file changed, 1 insertion(+)
</code></pre>
<p>现在，dev分支的工作完成，我们就可以切换回master分支：</p>
<pre><code>$ git checkout master
Switched to branch 'master'
</code></pre>
<p><strong>切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了</strong>！因为那个提交是在dev分支上，而<strong>master分支此刻的提交点并没有变</strong>：<br>
<img src="https://lixin-scut.github.io//post-images/1589205993805.png" alt=""></p>
<h3 id="合并分支">合并分支</h3>
<p>现在，我们把dev分支的工作成果合并到master分支上：</p>
<pre><code>$ git merge dev
Updating d46f35e..b17d20e
Fast-forward
 readme.txt | 1 +
 1 file changed, 1 insertion(+)
</code></pre>
<p><strong>git merge命令用于合并指定分支到当前分支</strong>。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。</p>
<p>注意到上面的<strong>Fast-forward信息</strong>，Git告诉我们，这次<strong>合并是“快进模式”</strong>，也就是<strong>直接把master指向dev的当前提交，所以合并速度非常快</strong>。</p>
<p>当然，<strong>也不是每次合并都能Fast-forward</strong>，我们后面会讲其他方式的合并。</p>
<h3 id="删除分支">删除分支</h3>
<p>合并完成后，就可以放心地<strong>删除dev分支</strong>了：</p>
<pre><code>$ git branch -d dev
Deleted branch dev (was b17d20e).
</code></pre>
<p>删除后，查看branch，就只剩下master分支了：</p>
<pre><code>$ git branch
* master
</code></pre>
<p>因为<strong>创建、合并和删除分支非常快</strong>，所以Git<strong>鼓励你使用分支完成某个任务，合并后再删掉分支</strong>，这和直接在master分支上工作效果是一样的，但<strong>过程更安全</strong>。</p>
<h3 id="switch">switch</h3>
<p>我们注意到切换分支使用<code>git checkout &lt;branch&gt;</code>，而前面讲过的撤销修改则是<code>git checkout -- &lt;file&gt;</code>，同一个命令，有两种作用，确实有点令人迷惑。</p>
<p>实际上，<strong>切换分支这个动作，用switch更科学</strong>。因此，最新版本的Git提供了新的git switch命令来切换分支：</p>
<p>创建并切换到新的dev分支，可以使用：</p>
<pre><code>$ git switch -c dev
</code></pre>
<p>直接切换到已有的master分支，可以使用：</p>
<pre><code>$ git switch master
</code></pre>
<p>使用新的git switch命令，比git checkout要更容易理解。</p>
<h3 id="小结">小结</h3>
<p>Git鼓励大量使用分支：</p>
<p>查看分支：<code>git branch</code></p>
<p>创建分支：<code>git branch &lt;name&gt;</code></p>
<p>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code></p>
<p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code></p>
<p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p>
<p>删除分支：<code>git branch -d &lt;name&gt;</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git - 远程仓库]]></title>
        <id>https://lixin-scut.github.io//post/git-yuan-cheng-cang-ku</id>
        <link href="https://lixin-scut.github.io//post/git-yuan-cheng-cang-ku">
        </link>
        <updated>2020-05-11T09:30:24.000Z</updated>
        <content type="html"><![CDATA[<h2 id="远程仓库">远程仓库</h2>
<p>到目前为止，我们已经掌握了如何在Git仓库里对一个文件进行版本更换，你再也不用担心文件备份或者丢失的问题了。</p>
<p>但对于集中式版本控制系统SVN来说，这些功能在SVN里早就有了，没看出Git有什么特别的地方。</p>
<p>如果只是在一个仓库里管理文件历史，Git和SVN真没啥区别。本章开始介绍Git的杀手级功能之一：远程仓库。</p>
<p>Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且<strong>每台机器的版本库其实都是一样的，并没有主次之分</strong>。</p>
<p>同时同一台电脑上也是可以克隆多个版本库的，只要不在同一个目录下。不过，现实生活中是不会有人在一台电脑上搞几个远程库，因为一台电脑上搞几个远程库完全没有意义，而且硬盘挂了会导致所有库都挂掉。</p>
<p>实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。</p>
<p>完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫<strong>GitHub</strong>的神奇的网站，从名字就可以看出，这个网站就是<strong>提供Git仓库托管服务</strong>的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。</p>
<p>在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：</p>
<p>第1步：<strong>创建SSH Key</strong>。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p>
<pre><code>$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;
</code></pre>
<p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于特殊目的，所以也无需设置密码。</p>
<p>如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p>
<p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：</p>
<p>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容：</p>
<p>点“Add Key”，你就应该看到已经添加的Key：</p>
<p><strong>为什么GitHub需要SSH Key</strong>呢？因为<strong>GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议</strong>，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p>
<p>当然，<strong>GitHub允许你添加多个Key</strong>。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p>
<p>最后友情提示，<strong>在GitHub上免费托管的Git仓库，任何人都可以看到喔</strong>（但只有你自己才能改）。所以，不要把敏感信息放进去。</p>
<p>如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。<strong>另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。</strong> 这个方法我们后面会讲到的，相当简单，公司内部开发必备。</p>
<h2 id="添加远程库">添加远程库</h2>
<p>经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。</p>
<ol>
<li>
<p>首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库</p>
</li>
<li>
<p>在Repository name填入本地电脑上相应的文件夹名，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库</p>
</li>
<li>
<p>目前，在GitHub上的这个仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p>
</li>
</ol>
<p>根据GitHub的提示，在本地的仓库下运行命令：</p>
<pre><code>$ git remote add origin git@server-name:path/repo-name.git
</code></pre>
<p>请千万注意，把上面的user_name替换成自己的GitHub账户名，否则，你在本地关联的就是其他人的远程库，关联没有问题，但是以后推送是推不上去的，因为SSH Key公钥不在他人的账户列表中。</p>
<p>添加后，<strong>远程库的名字就是origin，这是Git默认的叫法</strong>，也可以改成别的，但是origin这个名字一看就知道是远程库。</p>
<p>下一步，就可以<strong>把本地库的所有内容推送到远程库上</strong>：</p>
<pre><code>$ git push -u origin master

Counting objects: 20, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (15/15), done.
Writing objects: 100% (20/20), 1.64 KiB | 560.00 KiB/s, done.
Total 20 (delta 5), reused 0 (delta 0)
remote: Resolving deltas: 100% (5/5), done.
To github.com:michaelliao/learngit.git
 * [new branch]      master -&gt; master
Branch 'master' set up to track remote branch 'master' from 'origin'.
</code></pre>
<pre><code>$ git push -u origin master
</code></pre>
<p>把本地库的内容推送到远程，用<strong>git push命令</strong>，实际上是把<strong>当前分支master</strong>推送到<strong>远程</strong>。</p>
<p>由于远程库是空的，我们第一次推送master分支时，<strong>加上了-u参数</strong>，Git不但会把本地的master分支内容推送的远程新的master分支，还会把<strong>本地的master分支和远程的master分支关联起来</strong>，<strong>在以后的推送或者拉取时就可以简化命令</strong>。</p>
<p>从现在起，只要本地作了提交，就可以通过命令：</p>
<pre><code>$ git push origin master
</code></pre>
<p>把本地master分支的最新修改推送至GitHub，现在就拥有了真正的分布式版本库</p>
<p>SSH警告</p>
<p>当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告：</p>
<pre><code>The authenticity of host 'github.com (xx.xx.xx.xx)' can't be established.
RSA key fingerprint is xx.xx.xx.xx.xx.
Are you sure you want to continue connecting (yes/no)?
</code></pre>
<p>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。</p>
<p>Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：</p>
<pre><code>Warning: Permanently added 'github.com' (RSA) to the list of known hosts.
</code></pre>
<p>这个警告只会出现一次，后面的操作就不会有任何警告了。</p>
<p>如果你实在担心有人冒充GitHub服务器，<strong>输入yes前可以对照GitHub的RSA Key的指纹信息是否与SSH连接给出的一致</strong>。</p>
<h3 id="小结">小结</h3>
<p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code></p>
<p>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p>
<p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p>
<p>分布式版本系统的最大好处之一是<strong>在本地工作完全不需要考虑远程库的存在</strong>，也就是有<strong>没有联网都可以正常工作</strong>，而<strong>SVN在没有联网的时候是拒绝干活的</strong>！当有网络的时候，再把本地提交推送一下就完成了同步</p>
<h2 id="从远程库克隆">从远程库克隆</h2>
<p>现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。</p>
<p>首先，登陆GitHub，创建一个新的仓库，名字叫gitskills</p>
<p>勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件</p>
<p>现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库：</p>
<pre><code>$ git clone git@github.com:server-name:path/gitskills.git

Cloning into 'gitskills'...
remote: Counting objects: 3, done.
remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3
Receiving objects: 100% (3/3), done.
</code></pre>
<p>注意把Git库的地址server-name:path换成你自己的用户名，然后进入gitskills目录看看，已经有README.md文件了：</p>
<pre><code>$ cd gitskills
$ ls
README.md
</code></pre>
<p>如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。</p>
<p>你也许还注意到，<strong>GitHub给出的地址不止一个</strong>，还可以用https://github.com/server-name:path/gitskills.git 这样的地址。实际上，<strong>Git支持多种协议，默认的git:// 使用ssh，但也可以使用https等其他协议。</strong></p>
<p><strong>使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令</strong>，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。</p>
<h3 id="小结-2">小结</h3>
<p>要克隆一个仓库，<strong>首先必须知道仓库的地址，然后使用git clone命令克隆</strong>。</p>
<p><strong>Git支持多种协议</strong>，包括https，但ssh协议速度最快。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git - 版本管理]]></title>
        <id>https://lixin-scut.github.io//post/git-ban-ben-guan-li</id>
        <link href="https://lixin-scut.github.io//post/git-ban-ben-guan-li">
        </link>
        <updated>2020-05-11T06:52:38.000Z</updated>
        <content type="html"><![CDATA[<h2 id="版本管理">版本管理</h2>
<p>我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件，改成如下内容：</p>
<pre><code>Git is a distributed version control system.
Git is free software.
</code></pre>
<h3 id="git-status">git status</h3>
<p>现在，运行git status命令看看结果：</p>
<pre><code>$ git status
On branch master
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

	modified:   readme.txt

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre>
<p><strong>git status命令</strong>可以让我们<strong>时刻掌握仓库当前的状态</strong></p>
<p>上面的命令输出告诉我们，<strong>readme.txt的字体是红色的！</strong> 被修改过了，但还没有准备提交的修改。</p>
<p>虽然<strong>Git告诉我们readme.txt被修改了，但并不能看看具体修改了什么内容</strong>。<br>
比如你休假回来上班时，已经记不清上次怎么修改的readme.txt，所以，需要用git diff这个命令看看：</p>
<h3 id="git-diff">git diff</h3>
<pre><code>$ git diff readme.txt 
diff --git a/readme.txt b/readme.txt
index 46d49bf..9247db6 100644
--- a/readme.txt
+++ b/readme.txt
@@ -1,2 +1,2 @@
-Git is a version control system.
+Git is a distributed version control system.
 Git is free software.
</code></pre>
<p>git diff顾名思义就是<strong>查看difference</strong>，显示的格式正是<strong>Unix通用的diff格式</strong>，可以从上面的命令输出看到，我们在第一行添加了一个distributed单词。</p>
<h3 id="再次提交">再次提交</h3>
<p>知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是git add</p>
<pre><code>$ git add readme.txt
</code></pre>
<p>同样没有任何输出。在执行第二步git commit之前，我们再运行git status看看当前仓库的状态：</p>
<pre><code>$ git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

	modified:   readme.txt
</code></pre>
<p>git status告诉我们，将要被提交的修改包括readme.txt，<strong>readme.txt的字体变为了绿色的！</strong> ，下一步，就可以放心地提交了：</p>
<pre><code>$ git commit -m &quot;add distributed&quot;
[master e475afc] add distributed
 1 file changed, 1 insertion(+), 1 deletion(-)
</code></pre>
<p>提交后，我们再用git status命令看看仓库的当前状态：</p>
<pre><code>$ git status
On branch master
nothing to commit, working tree clean
</code></pre>
<p>Git告诉我们当前没有需要提交的修改，而且，<strong>工作目录是干净（working tree clean）的</strong>。</p>
<h3 id="小结">小结</h3>
<p>要随时掌握工作区的状态，使用git status命令。</p>
<p>如果git status告诉你有文件被修改过，用git diff可以查看修改内容。</p>
<h2 id="版本回退">版本回退</h2>
<p>现在已经学会了修改文件，然后把修改提交到Git版本库，现在，再一次修改readme.txt文件如下：</p>
<pre><code>Git is a distributed version control system.
Git is free software distributed under the GPL.
</code></pre>
<p>然后尝试提交：</p>
<pre><code>$ git add readme.txt
$ git commit -m &quot;append GPL&quot;
[master 1094adb] append GPL
 1 file changed, 1 insertion(+), 1 deletion(-)
</code></pre>
<p>像这样，可以不断对文件进行修改，然后不断提交修改到版本库里。<br>
每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，<strong>这个快照在Git中被称为commit</strong>。<br>
一旦你把文件改乱了，或者误删了文件，还可以<strong>从最近的一个commit恢复</strong>，然后继续工作，而不是把几个月的工作成果全部丢失。</p>
<h3 id="git-log">git log</h3>
<p>现在，我们回顾一下readme.txt文件一共有几个版本被提交到Git仓库里了：</p>
<p>版本1：wrote a readme file</p>
<pre><code>Git is a version control system.
Git is free software.
</code></pre>
<p>版本2：add distributed</p>
<pre><code>Git is a distributed version control system.
Git is free software.
</code></pre>
<p>版本3：append GPL</p>
<pre><code>Git is a distributed version control system.
Git is free software distributed under the GPL.
</code></pre>
<p>当然了，在实际工作中版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看：</p>
<pre><code>$ git log
commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Fri May 18 21:06:15 2018 +0800

    append GPL

commit e475afc93c209a690c39c13a46716e8fa000c366
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Fri May 18 21:03:36 2018 +0800

    add distributed

commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Fri May 18 20:59:18 2018 +0800

    wrote a readme file
</code></pre>
<p>git log命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是append GPL，上一次是add distributed，最早的一次是wrote a readme file。</p>
<p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数：</p>
<pre><code>$ git log --pretty=oneline
1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPL
e475afc93c209a690c39c13a46716e8fa000c366 add distributed
eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file
</code></pre>
<p>提示：看到的一大串类似1094adb...的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p>
<p>每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线</p>
<h3 id="git-reset">git reset</h3>
<h4 id="回退到上一个版本">回退到上一个版本</h4>
<p>现在准备把readme.txt回退到上一个版本，也就是add distributed的那个版本</p>
<p>首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交，<strong>上一个版本就是HEAD<sup>**，**上上一个版本就是HEAD</sup><sup>**，当然往上100个版本写100个</sup>比较容易数不过来，所以写成</strong>HEAD~100**。</p>
<p>要把当前版本append GPL回退到上一个版本add distributed，就可以使用git reset命令：</p>
<pre><code>$ git reset --hard HEAD^
HEAD is now at e475afc add distributed
</code></pre>
<p>还可以继续回退到上一个版本wrote a readme file，<br>
不过我们先用git log再看看现在版本库的状态：</p>
<pre><code>$ git log
commit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -&gt; master)
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Fri May 18 21:03:36 2018 +0800

    add distributed

commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Fri May 18 20:59:18 2018 +0800

    wrote a readme file
</code></pre>
<p>最新的那个版本append GPL已经看不到了</p>
<h4 id="回退到后一个版本">回退到后一个版本</h4>
<p>如果git reset是误操作，如何向后复原呢？</p>
<p>只要上面的命令行窗口还没有被关掉，可以找到那个append GPL的commit id1094adb...，于是就可以根据commit id来指定回到未来的某个版本：</p>
<pre><code>$ git reset --hard 1094a
HEAD is now at 83b0afe append GPL
</code></pre>
<p><strong>版本号没必要写全，前几位就可以了，Git会自动去找</strong>。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p>
<p>再查看readme.txt的内容：</p>
<pre><code>$ cat readme.txt
Git is a distributed version control system.
Git is free software distributed under the GPL.
</code></pre>
<p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你<strong>回退版本的时候，Git仅仅是把HEAD从指向append GPL</strong>：</p>
<pre><code>
┌────┐
│HEAD│
└────┘
   │
   └──&gt; ○ append GPL
        │
        ○ add distributed
        │
        ○ wrote a readme file
</code></pre>
<p>改为指向add distributed：</p>
<pre><code>
┌────┐
│HEAD│
└────┘
   │
   │    ○ append GPL
   │    │
   └──&gt; ○ add distributed
        │
        ○ wrote a readme file
</code></pre>
<p>然后顺便把<strong>工作区</strong>的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。</p>
<h3 id="git-reflog-命令记录">git reflog-命令记录</h3>
<p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？</p>
<p>在Git中，总是有后悔药可以吃的。当你用$ git reset --hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令：</p>
<pre><code>$ git reflog
e475afc HEAD@{1}: reset: moving to HEAD^
1094adb (HEAD -&gt; master) HEAD@{2}: commit: append GPL
e475afc HEAD@{3}: commit: add distributed
eaadf4e HEAD@{4}: commit (initial): wrote a readme file
</code></pre>
<p>从输出可知，append GPL的commit id是1094adb。</p>
<h3 id="小结-2">小结</h3>
<p>现在总结一下：</p>
<ol>
<li>
<p>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。</p>
</li>
<li>
<p>穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。</p>
</li>
<li>
<p>要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</p>
</li>
</ol>
<h2 id="工作区和暂存区">工作区和暂存区</h2>
<p>Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。</p>
<p><strong>工作区（Working Directory）</strong>：就是你在电脑里能看到的目录，比如git init的文件夹就是一个工作区：</p>
<p><strong>版本库（Repository）</strong></p>
<p>工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。</p>
<p>Git的版本库里存了很多东西</p>
<ol>
<li>其中最重要的就是称为<strong>stage（或者叫index）的暂存区</strong></li>
<li>还有Git为我们<strong>自动创建的第一个分支master</strong></li>
<li>以及<strong>指向master的一个指针叫HEAD</strong>。<br>
<img src="https://lixin-scut.github.io//post-images/1589181011272.png" alt=""></li>
</ol>
<p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p>
<p>第一步是用<strong>git add</strong>把文件添加进去，实际上就是把<strong>文件修改添加到暂存区</strong>；</p>
<p>第二步是用<strong>git commit</strong>提交更改，实际上就是把<strong>暂存区的所有内容提交到当前分支</strong>。</p>
<p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。</p>
<p>你可以简单理解为，需<strong>要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改</strong>。</p>
<p>俗话说，实践出真知。现在，我们再练习一遍，先对readme.txt做个修改，比如加上一行内容：</p>
<pre><code>Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
</code></pre>
<p>然后，在工作区新增一个LICENSE文本文件（内容随便写）。</p>
<p>先用git status查看一下状态：</p>
<pre><code>$ git status
On branch master
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

	modified:   readme.txt

Untracked files:
  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)

	LICENSE

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre>
<p>Git非常清楚地告诉我们，readme.txt被修改了，而LICENSE还从来没有被添加过，所以它的状态是Untracked，<strong>两者都是红色字体</strong>。</p>
<p>现在，使用两次命令git add，把readme.txt和LICENSE都添加后，用git status再查看一下：</p>
<pre><code>$ git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

	new file:   LICENSE
	modified:   readme.txt
</code></pre>
<p>可以看到两者被成功添加，两者都变为绿色字体<br>
现在，暂存区的状态就变成这样了：<br>
<img src="https://lixin-scut.github.io//post-images/1589181355793.png" alt=""></p>
<p>所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。</p>
<pre><code>$ git commit -m &quot;understand how stage works&quot;
[master e43a48b] understand how stage works
 2 files changed, 2 insertions(+)
 create mode 100644 LICENSE
</code></pre>
<p>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：</p>
<pre><code>$ git status
On branch master
nothing to commit, working tree clean
</code></pre>
<p><img src="https://lixin-scut.github.io//post-images/1589181551641.png" alt=""></p>
<h2 id="管理修改">管理修改</h2>
<p><strong>Git跟踪并管理的是修改，而非文件。</strong></p>
<p>什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。</p>
<p>为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容：</p>
<pre><code>$ cat readme.txt
Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes.
</code></pre>
<p>然后，添加：</p>
<pre><code>$ git add readme.txt
$ git status
# On branch master
# Changes to be committed:
#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
#
#       modified:   readme.txt
#
</code></pre>
<p>然后，再修改readme.txt：</p>
<pre><code>$ cat readme.txt 
Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
</code></pre>
<p>提交：</p>
<pre><code>$ git commit -m &quot;git tracks changes&quot;
[master 519219b] git tracks changes
 1 file changed, 1 insertion(+)
</code></pre>
<p>提交后，再看看状态：</p>
<pre><code>$ git status
On branch master
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

	modified:   readme.txt

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre>
<p>可以看到，<strong>第二次的修改并没有被提交！</strong></p>
<p>回顾一下操作过程：</p>
<p>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit</p>
<p>前面讲了Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的<strong>第二次修改并没有放入暂存区</strong>，所以，git commit<strong>只负责把暂存区的修改提交了</strong>，也就是<strong>第一次的修改被提交了，第二次的修改不会被提交</strong>。</p>
<p>提交后，用<code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别：</p>
<pre><code>$ git diff HEAD -- readme.txt 
diff --git a/readme.txt b/readme.txt
index 76d770f..a9c5755 100644
--- a/readme.txt
+++ b/readme.txt
@@ -1,4 +1,4 @@
 Git is a distributed version control system.
 Git is free software distributed under the GPL.
 Git has a mutable index called stage.
-Git tracks changes.
+Git tracks changes of files.
</code></pre>
<p>可见，第二次修改确实没有被提交。</p>
<p>那怎么提交第二次修改呢？可以继续git add再git commit，也<strong>可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了</strong>：</p>
<p>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit</p>
<h2 id="撤销修改">撤销修改</h2>
<h3 id="撤销git-add-之前的修改">撤销git add 之前的修改</h3>
<p>如果错误发现得很及时，可以在<strong>提交(git add)</strong> 之前修正，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用git status查看一下：</p>
<pre><code>$ git status
On branch master
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

	modified:   readme.txt

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre>
<p>同时也可以<strong>使用git checkout -- file丢弃工作区的修改</strong>：</p>
<pre><code>$ git checkout -- readme.txt
</code></pre>
<p>命令git checkout -- readme.txt意思就是，把readme.txt文件在<strong>工作区的修改全部撤销</strong>，这里有两种情况：</p>
<ol>
<li>
<p>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
</li>
<li>
<p>一种是readme.txt已经添加到暂存区后，又作了修改，现在，<strong>撤销修改就回到添加到暂存区后的状态</strong>。</p>
</li>
</ol>
<p>总之，就是让这个文件回到<strong>最近一次git commit或git add</strong>时的状态。</p>
<p><strong>git checkout -- file命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令</strong>，我们在后面的分支管理中会再次遇到git checkout命令。</p>
<h3 id="撤销git-add-之后的修改">撤销git add 之后的修改</h3>
<p>如果git add到暂存区了，在commit之前，你发现了这个问题。用git status查看一下，修改只是添加到了暂存区，还没有提交：</p>
<p>Git同样告诉我们，用命令<code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），<strong>重新放回工作区</strong>：</p>
<pre><code>$ git reset HEAD readme.txt
Unstaged changes after reset:
M	readme.txt
</code></pre>
<p><strong>注意！！此时修改还在！！！只是回到了工作区的修改！！！并不是说回到上一次最近一次git commit或git add时的状态，如果想要彻底回到修改前的状态，还需要调用git checkout</strong></p>
<p>git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们<strong>用HEAD时，表示最新的版本</strong>。</p>
<p>再用git status查看一下，<strong>现在暂存区是干净的，工作区有修改</strong>：</p>
<pre><code>$ git status
On branch master
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

	modified:   readme.txt
</code></pre>
<p>进一步丢弃工作区的修改：git checkout</p>
<pre><code>$ git checkout -- readme.txt

$ git status
On branch master
nothing to commit, working tree clean
</code></pre>
<h3 id="小结-3">小结</h3>
<p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p>
<p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了<strong>暂存区</strong>时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p>
<p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p>
<p>现在，假设不但改错了东西，还从暂存区提交到了版本库，此时就必须使用版本回退回退到上一个版本。不过，这是有条件的，就是还没有把自己的本地版本库推送到远程。因为Git是分布式版本控制系统，具有相关的远程版本库</p>
<h2 id="删除文件">删除文件</h2>
<p>在Git中，删除也是一个修改操作，先添加一个新文件test.txt到Git并且提交：</p>
<pre><code>$ git add test.txt

$ git commit -m &quot;add test.txt&quot;
[master b84166e] add test.txt
 1 file changed, 1 insertion(+)
 create mode 100644 test.txt
</code></pre>
<p>一般情况下，可以直接在文件管理器中把没用的文件删了，或者用rm命令删了：</p>
<pre><code>$ rm test.txt
</code></pre>
<p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了：</p>
<pre><code>$ git status
On branch master
Changes not staged for commit:
  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

	deleted:    test.txt

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre>
<p>现在你有两个选择，一是确实要从版本库中删除该文件，那就<strong>用命令git rm删掉</strong>，并且<strong>git commit</strong>：</p>
<pre><code>$ git rm test.txt
rm 'test.txt'

$ git commit -m &quot;remove test.txt&quot;
[master d46f35e] remove test.txt
 1 file changed, 1 deletion(-)
 delete mode 100644 test.txt
</code></pre>
<p>现在，文件就从版本库中被删除了。</p>
<p>小提示：先手动删除文件，然后使用<code>git rm &lt;file&gt;</code>和<code>git add&lt;file&gt;</code>效果是一样的。</p>
<h3 id="恢复删除文件">恢复删除文件</h3>
<p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p>
<p>注意此处是只是add，而没有commit！</p>
<pre><code>$ git checkout -- test.txt
</code></pre>
<p>git checkout其实是<strong>用版本库里的版本替换工作区的版本</strong>，无论工作区是修改还是删除，都可以“一键还原”。</p>
<p>注意：<strong>从来没有被添加到版本库就被删除的文件，是无法恢复的</strong>！</p>
<h3 id="小结-4">小结</h3>
<p>命令git rm用于删除一个文件。<strong>如果一个文件已经被提交到版本库，那么你永远不用担心误删</strong>，但是要小心，你只能恢复文件到最新版本，你<strong>会丢失最近一次提交后你修改的内容</strong>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git - 简介]]></title>
        <id>https://lixin-scut.github.io//post/git-jian-jie</id>
        <link href="https://lixin-scut.github.io//post/git-jian-jie">
        </link>
        <updated>2020-05-11T06:26:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="集中式vs分布式">集中式vs分布式</h2>
<p>CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统</p>
<h3 id="集中式版本控制系统">集中式版本控制系统</h3>
<p>集中式版本控制系统的版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。</p>
<p>集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟</p>
<h3 id="分布式版本控制系统">分布式版本控制系统</h3>
<p>首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。</p>
<p>既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p>
<p>和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。</p>
<p>在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，<strong>分布式版本控制系统通常也有一台充当“中央服务器”的电脑</strong>，但这个服务器的作用<strong>仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已</strong>。</p>
<h2 id="安装git">安装Git</h2>
<p><strong>在Linux上安装Git</strong></p>
<p>首先，你可以试着输入git，看看系统有没有安装Git：</p>
<pre><code>$ git
The program 'git' is currently not installed. You can install it by typing:
sudo apt-get install git
</code></pre>
<p>像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。</p>
<p>如果你碰巧用Debian或Ubuntu Linux，通过一条sudo apt-get install git就可以直接完成Git的安装，非常简单。</p>
<p><strong>在Mac OS X上安装Git</strong></p>
<p>如果你正在使用Mac做开发，有两种安装Git的方法。</p>
<p>一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：http://brew.sh/。</p>
<p>第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。</p>
<p><strong>在Windows上安装Git</strong></p>
<p>在Windows上使用Git，可以从Git官网直接下载安装程序，然后按默认选项安装即可。</p>
<p>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</p>
<p>安装完成后，还需要最后一步设置，在命令行输入：</p>
<pre><code>$ git config --global user.name &quot;Your Name&quot;
$ git config --global user.email &quot;email@example.com&quot;
</code></pre>
<p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。</p>
<p>注意git config命令的--global参数，用了这个参数，<strong>表示你这台机器上所有的Git仓库都会使用这个配置</strong>，当然也可以对某个仓库指定不同的用户名和Email地址。</p>
<h2 id="创建版本库">创建版本库</h2>
<p>版本库又名仓库，英文名repository，你可以<strong>简单理解成一个目录</strong>，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>
<p>创建一个版本库：</p>
<ol>
<li>首先，选择一个合适的地方，创建一个空目录：</li>
</ol>
<pre><code>$ mkdir learngit
$ cd learngit
$ pwd
/Users/michael/learngit
</code></pre>
<p>pwd命令用于显示当前目录。</p>
<ol start="2">
<li>第二步，通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：</li>
</ol>
<pre><code>$ git init
Initialized empty Git repository in /Users/michael/learngit/.git/
</code></pre>
<p>瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository）<br>
可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，<strong>没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</strong></p>
<p>如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用<code>ls -ah</code>命令就可以看见。</p>
<h3 id="把文件添加到版本库">把文件添加到版本库</h3>
<p>首先这里再明确一下，所有的版本控制系统，其实<strong>只能跟踪文本文件的改动</strong>，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统<strong>可以告诉你每次的改动</strong>，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，<strong>虽然也能由版本控制系统管理，但没法跟踪文件的变化</strong>，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p>
<p>不幸的是，Microsoft的Word格式是<strong>二进制格式</strong>，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示<br>
<strong>如果要真正使用版本控制系统，就要以纯文本方式编写文件</strong>。</p>
<p>因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用<strong>标准的UTF-8编码</strong>，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</p>
<p><strong>使用Windows要特别注意：</strong></p>
<p>千万不要使用Windows自带的记事本编辑任何文本文件。原因是Microsoft开发记事本的团队在每个文件开头添加了0xefbbbf（十六进制）的字符来保存UTF-8编码的文件，会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，建议下载Notepad++代替记事本，并把Notepad++的默认编码设置为UTF-8 without BOM</p>
<p>现在编写一个readme.txt文件，放到learngit目录下（子目录也行），因为这是一个Git仓库。</p>
<p><strong>把一个文件放到Git仓库只需要两步</strong></p>
<ol>
<li>第一步，用<strong>命令git add</strong>告诉Git，把文件添加到仓库：</li>
</ol>
<pre><code>$ git add readme.txt
</code></pre>
<p>执行上面的命令，没有任何显示，这就对了，<strong>Unix的哲学是“没有消息就是好消息”</strong>，说明添加成功。</p>
<ol start="2">
<li>第二步，用<strong>命令git commit</strong>告诉Git，把文件提交到仓库：</li>
</ol>
<pre><code>$ git commit -m &quot;wrote a readme file&quot;
[master (root-commit) eaadf4e] wrote a readme file
 1 file changed, 2 insertions(+)
 create mode 100644 readme.txt
</code></pre>
<p>简单解释一下git commit命令，<strong>-m后面输入的是本次提交的说明</strong>，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p>
<p>嫌麻烦不想输入-m &quot;xxx&quot;行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。</p>
<p>git commit命令执行成功后会告诉你，<br>
<code>1 file changed</code>：1个文件被改动（我们新添加的readme.txt文件）；<br>
<code>2 insertions</code>：插入了两行内容（readme.txt有两行内容）。</p>
<p>为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：</p>
<pre><code>$ git add file1.txt
$ git add file2.txt file3.txt
$ git commit -m &quot;add 3 files.&quot;
</code></pre>
<h3 id="小结">小结</h3>
<p>初始化一个Git仓库，使用git init命令。</p>
<p>添加文件到Git仓库，分两步：</p>
<ol>
<li>使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；</li>
<li>使用命令<code>git commit -m &lt;message&gt;</code>，完成。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Python - 面向对象高级编程]]></title>
        <id>https://lixin-scut.github.io//post/python-mian-xiang-dui-xiang-gao-ji-bian-cheng</id>
        <link href="https://lixin-scut.github.io//post/python-mian-xiang-dui-xiang-gao-ji-bian-cheng">
        </link>
        <updated>2020-05-10T12:48:52.000Z</updated>
        <content type="html"><![CDATA[<h2 id="__slots__"><code>__slots__</code></h2>
<p>正常情况下，当我们定义了一个class，创建了一个class的实例后，我们可以给该实例绑定任何属性和方法，这就是动态语言的灵活性。先定义class：</p>
<pre><code>class Student(object):
    pass
</code></pre>
<p>然后，尝试<strong>给实例绑定一个属性</strong>：</p>
<pre><code>&gt;&gt;&gt; s = Student()
&gt;&gt;&gt; s.name = 'Michael' # 动态给实例绑定一个属性
&gt;&gt;&gt; print(s.name)
Michael
</code></pre>
<p>还可以尝试<strong>给实例绑定一个方法</strong>：</p>
<pre><code>&gt;&gt;&gt; def set_age(self, age): # 定义一个函数作为实例方法
...     self.age = age
...
&gt;&gt;&gt; from types import MethodType
&gt;&gt;&gt; s.set_age = MethodType(set_age, s) # 给实例绑定一个方法
&gt;&gt;&gt; s.set_age(25) # 调用实例方法
&gt;&gt;&gt; s.age # 测试结果
25
</code></pre>
<p>但是明显地，<strong>给一个实例绑定的方法，对另一个实例是不起作用的</strong>：</p>
<pre><code>&gt;&gt;&gt; s2 = Student() # 创建新的实例
&gt;&gt;&gt; s2.set_age(25) # 尝试调用方法
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'Student' object has no attribute 'set_age'
</code></pre>
<p><strong>为了给所有实例都绑定方法，可以给class绑定方法</strong>：</p>
<pre><code>&gt;&gt;&gt; def set_score(self, score):
...     self.score = score
...
&gt;&gt;&gt; Student.set_score = set_score
</code></pre>
<p><strong>给class绑定方法后，所有实例均可调用</strong>：</p>
<pre><code>&gt;&gt;&gt; s.set_score(100)
&gt;&gt;&gt; s.score
100
&gt;&gt;&gt; s2.set_score(99)
&gt;&gt;&gt; s2.score
99
</code></pre>
<p>通常情况下，上面的set_score方法可以直接定义在class中，但<strong>动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言中很难实现</strong>。</p>
<h3 id="使用__slots__">使用__slots__</h3>
<p>但是，如果我们想要限制实例的属性，比如只允许对Student实例添加name和age属性。</p>
<p>为了达到限制的目的，Python允许在定义class的时候，<strong>定义一个特殊的slots变量，来限制该class实例能添加的属性</strong>：</p>
<pre><code>class Student(object):
    __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称
</code></pre>
<p>用tuple定义允许绑定的属性名称<br>
然后，我们试试：</p>
<pre><code>&gt;&gt;&gt; s = Student() # 创建新的实例
&gt;&gt;&gt; s.name = 'Michael' # 绑定属性'name'
&gt;&gt;&gt; s.age = 25 # 绑定属性'age'
&gt;&gt;&gt; s.score = 99 # 绑定属性'score'
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'Student' object has no attribute 'score'
</code></pre>
<p><strong>由于'score'没有被放到slots中，所以不能绑定score属性，试图绑定score将得到AttributeError的错误。</strong></p>
<p>使用__slots__要注意，<code>__slots__</code>定义的属性<strong>仅对当前类的实例起作用</strong>，<strong>对继承的子类是不起作用的</strong>：</p>
<pre><code>&gt;&gt;&gt; class GraduateStudent(Student):
...     pass
...
&gt;&gt;&gt; g = GraduateStudent()
&gt;&gt;&gt; g.score = 9999
</code></pre>
<p><strong>除非在子类中也定义__slots__</strong>，这样，子类实例允许定义的属性就是<strong>自身的__slots__加上父类的__slots__</strong>。</p>
<h2 id="使用property">使用@property</h2>
<p>在绑定属性时，如果直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数，导致可以把成绩随便改：</p>
<pre><code>s = Student()
s.score = 9999
</code></pre>
<p>这显然不合逻辑。为了限制score的范围，可以通过一个set_score()方法来设置成绩，再通过一个get_score()来获取成绩，这样，在set_score()方法里，就可以检查参数：</p>
<pre><code>class Student(object):

    def get_score(self):
         return self._score

    def set_score(self, value):
        if not isinstance(value, int):
            raise ValueError('score must be an integer!')
        if value &lt; 0 or value &gt; 100:
            raise ValueError('score must between 0 ~ 100!')
        self._score = value
</code></pre>
<p>现在，对任意的Student实例进行操作，就不能随心所欲地设置score了：</p>
<pre><code>&gt;&gt;&gt; s = Student()
&gt;&gt;&gt; s.set_score(60) # ok!
&gt;&gt;&gt; s.get_score()
60
&gt;&gt;&gt; s.set_score(9999)
Traceback (most recent call last):
  ...
ValueError: score must between 0 ~ 100!
</code></pre>
<p>但是，上面的调用方法又略显复杂，没有直接用属性这么直接简单。</p>
<p>有没有既能检查参数，又可以用类似属性这样简单的方式来访问类的变量？</p>
<p>还记得装饰器（decorator）可以给函数动态加上功能吗？<strong>对于类的方法，装饰器一样起作用</strong>。Python内置的**@property装饰器<strong>就是</strong>负责把一个方法变成属性调用**的：</p>
<pre><code>class Student(object):

    @property
    def score(self):
        return self._score

    @score.setter
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError('score must be an integer!')
        if value &lt; 0 or value &gt; 100:
            raise ValueError('score must between 0 ~ 100!')
        self._score = value
</code></pre>
<p>@property的实现比较复杂，我们先考察如何使用。<strong>把一个getter方法变成属性，只需要加上@property就可以了</strong>，此时，<strong>@property本身又创建了另一个装饰器@score.setter</strong>，负责把一个<strong>setter方法变成属性赋值</strong>，于是，我们就拥有一个可控的属性操作：</p>
<pre><code>&gt;&gt;&gt; s = Student()
&gt;&gt;&gt; s.score = 60 # OK，实际转化为s.set_score(60)
&gt;&gt;&gt; s.score # OK，实际转化为s.get_score()
60
&gt;&gt;&gt; s.score = 9999
Traceback (most recent call last):
  ...
ValueError: score must between 0 ~ 100!
</code></pre>
<p>注意到这个神奇的@property，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过getter和setter方法来实现的。</p>
<p>还可以定义<strong>只读属性，只定义getter方法，不定义setter方法就是一个只读属性</strong>：</p>
<pre><code>class Student(object):

    @property
    def birth(self):
        return self._birth

    @birth.setter
    def birth(self, value):
        self._birth = value

    @property
    def age(self):
        return 2015 - self._birth
</code></pre>
<p>上面的birth是可读写属性，而<strong>age就是一个只读属性，因为age可以根据birth和当前时间计算出来</strong>。</p>
<h3 id="小结">小结</h3>
<p>@property广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性。</p>
<h2 id="多重继承">多重继承</h2>
<p>继承是面向对象编程的一个重要的方式，因为通过继承，子类就可以扩展父类的功能。</p>
<p>回忆一下Animal类层次的设计，假设我们要实现以下4种动物：</p>
<p>Dog - 狗狗；<br>
Bat - 蝙蝠；<br>
Parrot - 鹦鹉；<br>
Ostrich - 鸵鸟。<br>
如果按照哺乳动物和鸟类归类，我们可以设计出这样的类的层次：</p>
<pre><code>
                ┌───────────────┐
                │    Animal     │
                └───────────────┘
                        │
           ┌────────────┴────────────┐
           │                         │
           ▼                         ▼
    ┌─────────────┐           ┌─────────────┐
    │   Mammal    │           │    Bird     │
    └─────────────┘           └─────────────┘
           │                         │
     ┌─────┴──────┐            ┌─────┴──────┐
     │            │            │            │
     ▼            ▼            ▼            ▼
┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
│   Dog   │  │   Bat   │  │ Parrot  │  │ Ostrich │
└─────────┘  └─────────┘  └─────────┘  └─────────┘
</code></pre>
<p>但是如果按照“能跑”和“能飞”来归类，我们就应该设计出这样的类的层次：</p>
<pre><code>
                ┌───────────────┐
                │    Animal     │
                └───────────────┘
                        │
           ┌────────────┴────────────┐
           │                         │
           ▼                         ▼
    ┌─────────────┐           ┌─────────────┐
    │  Runnable   │           │   Flyable   │
    └─────────────┘           └─────────────┘
           │                         │
     ┌─────┴──────┐            ┌─────┴──────┐
     │            │            │            │
     ▼            ▼            ▼            ▼
┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
│   Dog   │  │ Ostrich │  │ Parrot  │  │   Bat   │
└─────────┘  └─────────┘  └─────────┘  └─────────┘
</code></pre>
<p>如果要把上面的两种分类都包含进来，我们就得设计更多的层次：</p>
<p>哺乳类：能跑的哺乳类，能飞的哺乳类；<br>
鸟类：能跑的鸟类，能飞的鸟类。<br>
这么一来，类的层次就复杂了：</p>
<pre><code>
                ┌───────────────┐
                │    Animal     │
                └───────────────┘
                        │
           ┌────────────┴────────────┐
           │                         │
           ▼                         ▼
    ┌─────────────┐           ┌─────────────┐
    │   Mammal    │           │    Bird     │
    └─────────────┘           └─────────────┘
           │                         │
     ┌─────┴──────┐            ┌─────┴──────┐
     │            │            │            │
     ▼            ▼            ▼            ▼
┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
│  MRun   │  │  MFly   │  │  BRun   │  │  BFly   │
└─────────┘  └─────────┘  └─────────┘  └─────────┘
     │            │            │            │
     │            │            │            │
     ▼            ▼            ▼            ▼
┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
│   Dog   │  │   Bat   │  │ Ostrich │  │ Parrot  │
└─────────┘  └─────────┘  └─────────┘  └─────────┘

</code></pre>
<p>如果要再增加“宠物类”和“非宠物类”，这么搞下去，类的数量会呈指数增长，很明显这样设计是不行的。</p>
<p>正确的做法是采用多重继承。首先，主要的类层次仍按照哺乳类和鸟类设计：</p>
<pre><code>class Animal(object):
    pass

# 大类:
class Mammal(Animal):
    pass

class Bird(Animal):
    pass

# 各种动物:
class Dog(Mammal):
    pass

class Bat(Mammal):
    pass

class Parrot(Bird):
    pass

class Ostrich(Bird):
    pass
</code></pre>
<p>现在，我们要给动物再加上Runnable和Flyable的功能，只需要先定义好Runnable和Flyable的类：</p>
<pre><code>class Runnable(object):
    def run(self):
        print('Running...')

class Flyable(object):
    def fly(self):
        print('Flying...')
</code></pre>
<p>对于需要Runnable功能的动物，就多继承一个Runnable，例如Dog：</p>
<pre><code>class Dog(Mammal, Runnable):
    pass
</code></pre>
<p>对于需要Flyable功能的动物，就多继承一个Flyable，例如Bat：</p>
<pre><code>class Bat(Mammal, Flyable):
    pass
</code></pre>
<p><strong>通过多重继承，一个子类就可以同时获得多个父类的所有功能</strong>。</p>
<h3 id="mixin">MixIn</h3>
<p>自己的理解：</p>
<ol>
<li><strong>多继承是多继承，MixIn 是 MixIn，为啥要放一块比较，MixIn 是基于多继承实现的一种设计模式，一般是将复杂类的一些功能拆分出来，不用__init__初始化方法，不让其单独工作，只用作混入其他类使用</strong></li>
<li><strong>最后得出的结论继承和MixIn之间的关系就像，一颗大树，继承就好比树干一直到最粗的那一根树枝的末梢，然后MixIn就像那些小的枝丫，给这根最粗的树枝和树干做装饰用的，觉得少了什么东西就可以写一个mixin，然后让子类“继承”它，不过这个后写的东西它里面装的始终是装饰（比如写一个常用的函数，然后一旦需要调用这个函数了就直接在子类里面把它加上就好啦），主要继承的父类还和单继承没啥区别</strong></li>
</ol>
<p>在设计类的继承关系时，通常，主线都是单一继承下来的，例如，Ostrich继承自Bird。但是，<strong>如果需要“混入”额外的功能，通过多重继承就可以实现</strong>，比如，让Ostrich除了继承自Bird外，再同时继承Runnable。<strong>这种设计通常称之为MixIn</strong>。</p>
<p>为了更好地看出继承关系，我们把Runnable和Flyable改为RunnableMixIn和FlyableMixIn。类似的，你还可以定义出肉食动物CarnivorousMixIn和植食动物HerbivoresMixIn，让某个动物同时拥有好几个MixIn：</p>
<pre><code>class Dog(Mammal, RunnableMixIn, CarnivorousMixIn):
    pass
</code></pre>
<p><strong>MixIn的目的就是给一个类增加多个功能</strong>，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。</p>
<p>Python自带的很多库也使用了MixIn。举个例子，Python自带了TCPServer和UDPServer这两类网络服务，而要同时服务多个用户就必须使用多进程或多线程模型，这两种模型由ForkingMixIn和ThreadingMixIn提供。通过组合，我们就可以创造出合适的服务来。</p>
<p>比如，编写一个多进程模式的TCP服务，定义如下：</p>
<pre><code>class MyTCPServer(TCPServer, ForkingMixIn):
    pass
</code></pre>
<p>编写一个多线程模式的UDP服务，定义如下：</p>
<pre><code>class MyUDPServer(UDPServer, ThreadingMixIn):
    pass
</code></pre>
<p>如果你打算搞一个更先进的协程模型，可以编写一个CoroutineMixIn：</p>
<pre><code>class MyTCPServer(TCPServer, CoroutineMixIn):
    pass
</code></pre>
<p>这样一来，我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类。</p>
<h3 id="小结-2">小结</h3>
<p>由于Python允许使用多重继承，因此，MixIn就是一种常见的设计。</p>
<p><strong>只允许单一继承的语言（如Java）不能使用MixIn的设计</strong>。</p>
<p>C++也允许单一继承，但是存在菱形继承的问题</p>
<h2 id="定制类">定制类</h2>
<p>看到<strong>类似__slots__这种形如__xxx__的变量或者函数名</strong>就要注意，这些在Python中是有<strong>特殊用途</strong>的。</p>
<p><code>__slots__</code>我们已经知道怎么用了，<code>__len__()</code>方法我们也知道是为了能让class作用于len()函数。</p>
<p>除此之外，Python的class中还有许多这样有特殊用途的函数，可以帮助我们定制类。</p>
<h3 id="__str__"><code>__str__</code></h3>
<p>我们先定义一个Student类，打印一个实例：</p>
<pre><code>&gt;&gt;&gt; class Student(object):
...     def __init__(self, name):
...         self.name = name
...
&gt;&gt;&gt; print(Student('Michael'))
&lt;__main__.Student object at 0x109afb190&gt;
</code></pre>
<p>打印出一堆<code>&lt;__main__.Student object at 0x109afb190&gt;</code>，不好看。</p>
<p>怎么才能打印得好看呢？只需要定义好__str__()方法，返回一个好看的字符串就可以了：</p>
<pre><code>&gt;&gt;&gt; class Student(object):
...     def __init__(self, name):
...         self.name = name
...     def __str__(self):
...         return 'Student object (name: %s)' % self.name
...
&gt;&gt;&gt; print(Student('Michael'))
Student object (name: Michael)
</code></pre>
<p>这样打印出来的实例，不但好看，而且容易看出实例内部重要的数据。</p>
<p>但如果直接输出变量而不用print，打印出来的实例还是不好看：</p>
<pre><code>&gt;&gt;&gt; s = Student('Michael')
&gt;&gt;&gt; s
&lt;__main__.Student object at 0x109afb310&gt;
</code></pre>
<p>这是因为直接显示变量调用的不是<code>__str__()</code>，而是<code>__repr__()</code>，两者的区别是<code>__str__()</code>返回<strong>用户</strong>看到的字符串，而<code>__repr__()</code>返回<strong>程序开发者</strong>看到的字符串，也就是说，<code>__repr__()</code>是为<strong>调试服务的</strong>。</p>
<p>解决办法是再定义一个__repr__()。但是通常__str__()和__repr__()代码都是一样的，所以，有个偷懒的写法：</p>
<pre><code>class Student(object):
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return 'Student object (name=%s)' % self.name
    __repr__ = __str__
</code></pre>
<h3 id="__iter__"><code>__iter__</code></h3>
<p>如果<strong>一个类想被用于for ... in循环</strong>，类似list或tuple那样，就必须实现一个__iter__()方法<br>
<code>__iter__()</code>方法返回一个迭代对象，然后，Python的for循环就会<strong>不断调用该迭代对象的__next__()方法</strong>拿到循环的下一个值，直到遇到StopIteration错误时退出循环。</p>
<p>我们以斐波那契数列为例，写一个Fib类，可以作用于for循环：</p>
<pre><code>class Fib(object):
    def __init__(self):
        self.a, self.b = 0, 1 # 初始化两个计数器a，b

    def __iter__(self):
        return self # 实例本身就是迭代对象，故返回自己

    def __next__(self):
        self.a, self.b = self.b, self.a + self.b # 计算下一个值
        if self.a &gt; 100000: # 退出循环的条件
            raise StopIteration()
        return self.a # 返回下一个值
</code></pre>
<p>现在，试试把Fib实例作用于for循环：</p>
<pre><code>&gt;&gt;&gt; for n in Fib():
...     print(n)
...
1
1
2
3
5
...
46368
75025
</code></pre>
<h3 id="__getitem__"><code>__getitem__</code></h3>
<p>Fib实例虽然能作用于for循环，看起来和list有点像，但是，把它当成list来使用还是不行，比如，取第5个元素：</p>
<pre><code>&gt;&gt;&gt; Fib()[5]
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: 'Fib' object does not support indexing
</code></pre>
<p>要表现得像list那样按照下标取出元素，需要实现__getitem__()方法：</p>
<pre><code>class Fib(object):
    def __getitem__(self, n):
        a, b = 1, 1
        for x in range(n):
            a, b = b, a + b
        return a
</code></pre>
<p>现在，就可以按下标访问数列的任意一项了：</p>
<pre><code>&gt;&gt;&gt; f = Fib()
&gt;&gt;&gt; f[0]
1
&gt;&gt;&gt; f[1]
1
&gt;&gt;&gt; f[2]
2
&gt;&gt;&gt; f[3]
3
&gt;&gt;&gt; f[10]
89
&gt;&gt;&gt; f[100]
573147844013817084101
</code></pre>
<p>但是list有个神奇的切片方法：</p>
<pre><code>&gt;&gt;&gt; list(range(100))[5:10]
[5, 6, 7, 8, 9]
</code></pre>
<p>对于Fib却报错。原因是__getitem__()传入的参数可能是一个int，也可能是一个切片对象slice，所以要做判断：</p>
<pre><code>class Fib(object):
    def __getitem__(self, n):
        if isinstance(n, int): # n是索引
            a, b = 1, 1
            for x in range(n):
                a, b = b, a + b
            return a
        if isinstance(n, slice): # n是切片
            start = n.start
            stop = n.stop
						# 如果start为空，则默认为0
            if start is None:
                start = 0
            a, b = 1, 1
            L = []
            for x in range(stop):
                if x &gt;= start:
                    L.append(a)
                a, b = b, a + b
            return L
</code></pre>
<p>现在试试Fib的切片：</p>
<pre><code>&gt;&gt;&gt; f = Fib()
&gt;&gt;&gt; f[0:5]
[1, 1, 2, 3, 5]
&gt;&gt;&gt; f[:10]
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
</code></pre>
<p>但是没有对step参数作处理：</p>
<pre><code>&gt;&gt;&gt; f[:10:2]
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
</code></pre>
<p>也没有对负数作处理，所以，要正确实现一个<code>__getitem__()</code>还是有很多工作要做的。</p>
<p>此外，如果把对象看成dict，<code>__getitem__()</code>的参数也可能是一个可以作key的object，例如str。</p>
<p>与之对应的是<code>__setitem__()</code>方法，把对象视作list或dict来对集合赋值。最后，还有一个<code>__delitem__()</code>方法，用于删除某个元素。</p>
<p>总之，<strong>通过上面的方法，我们自己定义的类表现得和Python自带的list、tuple、dict没什么区别</strong>，这完全归功于<strong>动态语言的“鸭子类型”</strong>，不需要强制继承某个接口。</p>
<h3 id="__getattr__"><code>__getattr__</code></h3>
<p>正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。比如定义Student类：</p>
<pre><code>class Student(object):
    
    def __init__(self):
        self.name = 'Michael'
</code></pre>
<p>调用name属性正常，但是，调用不存在的score属性，就有问题了：</p>
<pre><code>&gt;&gt;&gt; s = Student()
&gt;&gt;&gt; print(s.name)
Michael
&gt;&gt;&gt; print(s.score)
Traceback (most recent call last):
  ...
AttributeError: 'Student' object has no attribute 'score'
</code></pre>
<p>错误信息很清楚地告诉我们，没有找到score这个attribute。</p>
<p>要避免这个错误，除了可以加上一个score属性外，Python还有另一个机制，那就是<strong>写一个<code>__getattr__()</code>方法，动态返回一个属性</strong>。修改如下：</p>
<pre><code>class Student(object):

    def __init__(self):
        self.name = 'Michael'

    def __getattr__(self, attr):
        if attr=='score':
            return 99
</code></pre>
<p>当调用不存在的属性时，比如score，Python解释器会试图调用__getattr__(self, 'score')来尝试获得属性，这样，我们就有机会返回score的值：</p>
<pre><code>&gt;&gt;&gt; s = Student()
&gt;&gt;&gt; s.name
'Michael'
&gt;&gt;&gt; s.score
99
</code></pre>
<p>返回函数也是完全可以的：</p>
<pre><code>class Student(object):

    def __getattr__(self, attr):
        if attr=='age':
            return lambda: 25
</code></pre>
<p>只是调用方式要变为：</p>
<pre><code>&gt;&gt;&gt; s.age()
25
</code></pre>
<p>注意，<strong>只有在没有找到属性的情况下，才调用__getattr__，已有的属性，比如name，不会在__getattr__中查找</strong>。</p>
<p>此外，<strong>如果定义了__getattr__，那么如果调用没有在__getattr__中找到相应的属性</strong>，如s.abc都会返回None，这是<strong>因为我们定义的__getattr__默认返回就是None</strong>。要让class只响应特定的几个属性，我们就要按照约定，抛出AttributeError的错误：</p>
<pre><code>class Student(object):

    def __getattr__(self, attr):
        if attr=='age':
            return lambda: 25
        raise AttributeError('\'Student\' object has no attribute \'%s\'' % attr)
</code></pre>
<p>这实际上可以<strong>把一个类的所有属性和方法调用全部动态化处理</strong>了，不需要任何特殊手段。</p>
<p>这种完全动态调用的特性有什么实际作用呢？作用就是，可以针对完全动态的情况作调用。</p>
<p>举个例子：</p>
<p>现在很多网站都搞REST API，比如新浪微博、豆瓣啥的，调用API的URL类似：</p>
<p>http://api.server/user/friends<br>
http://api.server/user/timeline/list<br>
如果要写SDK，给每个URL对应的API都写一个方法，那得累死，而且，API一旦改动，SDK也要改。</p>
<p><strong>利用完全动态的__getattr__，我们可以写出一个链式调用</strong>：</p>
<pre><code>class Chain(object):

    def __init__(self, path=''):
        self._path = path

    def __getattr__(self, path):
        return Chain('%s/%s' % (self._path, path))

    def __str__(self):
        return self._path

    __repr__ = __str__

&gt;&gt;&gt; Chain().status.user.timeline.list
'/status/user/timeline/list'
</code></pre>
<p>这样，无论API怎么变，SDK都可以根据URL实现完全动态的调用，而且，不随API的增加而改变！</p>
<p>还有些REST API会把参数放到URL中，比如GitHub的API：</p>
<pre><code>GET /users/:user/repos
</code></pre>
<p>调用时，需要把:user替换为实际用户名。如果我们能写出这样的链式调用：</p>
<pre><code>Chain().users('michael').repos
</code></pre>
<pre><code># 实现代码
class Chain(object):
    def __init__(self, path=''):
       self.__path = path

   def __getattr__(self, path):
       return Chain('%s/%s' % (self.__path, path))

   def __call__(self, path):
       return Chain('%s/%s' % (self.__path, path))

   def __str__(self):
       return self.__path

   __repr__ = __str__

print(Chain().users('michael').repos)
/users/michael/repos
</code></pre>
<p>就可以非常方便地调用API了。</p>
<h3 id="__call__"><code>__call__</code></h3>
<p>一个对象实例可以有自己的属性和方法，当我们调用实例方法时，我们用instance.method()来调用。但同时也能直接在实例本身上调用</p>
<p><strong>任何类，只需要定义一个__call__()方法，就可以直接对实例进行调用</strong>。请看示例：</p>
<pre><code>class Student(object):
    def __init__(self, name):
        self.name = name

    def __call__(self):
        print('My name is %s.' % self.name)
</code></pre>
<p>调用方式如下：</p>
<pre><code>&gt;&gt;&gt; s = Student('Michael')
&gt;&gt;&gt; s() # self参数不要传入
My name is Michael.
</code></pre>
<p><code>__call__()</code><strong>还可以定义参数</strong>。对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。</p>
<p>如果你把<strong>对象看成函数</strong>，那么函数本身其实也可以<strong>在运行期动态创建出来</strong>，因为类的实例都是运行期创建出来的，这么一来，我们就模糊了对象和函数的界限。</p>
<p>那么，<strong>怎么判断一个变量是对象还是函数</strong>呢？其实，更多的时候，我们需要判断一个对象是否能被调用，<strong>能被调用的对象就是一个Callable对象</strong>，比如函数和我们上面定义的带有__call__()的类实例：</p>
<pre><code>&gt;&gt;&gt; callable(Student())
True
&gt;&gt;&gt; callable(max)
True
&gt;&gt;&gt; callable([1, 2, 3])
False
&gt;&gt;&gt; callable(None)
False
&gt;&gt;&gt; callable('str')
False
</code></pre>
<p><strong>通过callable()函数，我们就可以判断一个对象是否是“可调用”对象。</strong></p>
<h2 id="枚举类">枚举类</h2>
<p>当我们<strong>需要定义常量时，一个办法是用大写变量通过整数来定义</strong>，例如月份：</p>
<pre><code>JAN = 1
FEB = 2
MAR = 3
...
NOV = 11
DEC = 12
</code></pre>
<p>好处是简单，缺点是类型是int，并且仍然是变量。</p>
<p>更好的方法是为这样的<strong>枚举类型定义一个class类型</strong>，然后，每个常量都是class的一个唯一实例。Python提供了<strong>Enum类</strong>来实现这个功能：</p>
<pre><code>from enum import Enum

Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))
</code></pre>
<p>这样我们就获得了Month类型的枚举类，可以直接使用Month.Jan来引用一个常量，或者枚举它的所有成员：</p>
<pre><code>for name, member in Month.__members__.items():
    print(name, '=&gt;', member, ',', member.value)
</code></pre>
<p>特殊属性<code>__members__</code>是一个将名称映射到成员的有序字典，也可以通过它来完成遍历</p>
<p>value属性则是自动赋给成员的int常量，<strong>默认从1开始计数</strong>。<br>
<strong>注意不是从0开始！！！</strong></p>
<p>如果需要<strong>更精确地控制枚举类型</strong>，可以<strong>从Enum派生出自定义类</strong>：</p>
<pre><code>from enum import Enum, unique

@unique
class Weekday(Enum):
    Sun = 0 # Sun的value被设定为0
    Mon = 1
    Tue = 2
    Wed = 3
    Thu = 4
    Fri = 5
    Sat = 6
</code></pre>
<p>@unique装饰器可以帮助我们检查保证没有重复值。</p>
<p>访问这些枚举类型可以有若干种方法：</p>
<pre><code>
&gt;&gt;&gt; day1 = Weekday.Mon
&gt;&gt;&gt; print(day1)
Weekday.Mon
&gt;&gt;&gt; print(Weekday.Tue)
Weekday.Tue
&gt;&gt;&gt; print(Weekday['Tue'])
Weekday.Tue

&gt;&gt;&gt; print(Weekday.Tue.value)
2

&gt;&gt;&gt; print(day1 == Weekday.Mon)
True
&gt;&gt;&gt; print(day1 == Weekday.Tue)
False

&gt;&gt;&gt; print(Weekday(1))
Weekday.Mon
&gt;&gt;&gt; print(day1 == Weekday(1))
True

&gt;&gt;&gt; Weekday(7)
Traceback (most recent call last):
  ...
ValueError: 7 is not a valid Weekday

&gt;&gt;&gt; for name, member in Weekday.__members__.items():
...     print(name, '=&gt;', member)
...
Sun =&gt; Weekday.Sun
Mon =&gt; Weekday.Mon
Tue =&gt; Weekday.Tue
Wed =&gt; Weekday.Wed
Thu =&gt; Weekday.Thu
Fri =&gt; Weekday.Fri
Sat =&gt; Weekday.Sat
</code></pre>
<p>可见，既可以<strong>用成员名称引用枚举常量</strong>，又可以<strong>直接根据value的值获得枚举常量</strong>。</p>
<p>网友评论：推荐直接看这个讲解枚举的链接https://segmentfault.com/a/1190000017327003</p>
<h3 id="使用-enum">使用 Enum</h3>
<p>更好的方式是使用标准库提供的 Enum 类型，官方库值得信赖。3.4 之前的版本也可以通过 pip install enum 下载支持的库。简单的示例：</p>
<pre><code>from enum import Enum
class Color(Enum):
    red = 1
    green = 2
    blue = 3
</code></pre>
<p>枚举成员有值（默认可重复），枚举成员具有友好的字符串表示：</p>
<pre><code>&gt;&gt;&gt; print(Color.red)
Color.red
&gt;&gt;&gt; print(repr(Color.red))
&lt;Color.red: 1&gt;
&gt;&gt;&gt; type(Color.red)
&lt;Enum 'Color'&gt;
&gt;&gt;&gt; isinstance(Color.green, Color)
True
</code></pre>
<p><strong>枚举类型不可实例化，不可更改</strong>。</p>
<h3 id="定义枚举">定义枚举</h3>
<p><strong>定义枚举时，成员名不允许重复</strong></p>
<pre><code>class Color(Enum):
    red = 1
    green = 2
    red = 3    # TypeError: Attempted to reuse key: 'red'
</code></pre>
<p><strong>成员值允许相同</strong>，<strong>第二个成员的名称被视作第一个成员的别名</strong></p>
<pre><code>class Color(Enum):
    red   = 1
    green = 2
    blue  = 1

print(Color.red)              # Color.red
print(Color.blue)             # Color.red
print(Color.red is Color.blue)# True
print(Color(1))               # Color.red  在通过值获取枚举成员时，只能获取到第一个成员
</code></pre>
<p><strong>若要不能定义相同的成员值，可以通过 unique 装饰</strong></p>
<pre><code>from enum import Enum, unique
@unique
class Color(Enum):
    red   = 1
    green = 2
    blue  = 1  # ValueError: duplicate values found in &lt;enum 'Color'&gt;: blue -&gt; red
</code></pre>
<h3 id="枚举取值">枚举取值</h3>
<p>可以通过成员名来获取成员也可以通过成员值来获取成员:</p>
<pre><code>print(Color['red'])  # Color.red  通过成员名来获取成员

print(Color(1))      # Color.red  通过成员值来获取成员
</code></pre>
<p>每个成员都有<strong>名称属性和值属性</strong>：</p>
<pre><code>member = Color.red
print(member.name)   # red
print(member.value)  # 1
</code></pre>
<p>支持迭代的方式遍历成员，按定义的顺序，如果有值重复的成员，只获取重复的第一个成员：</p>
<pre><code>for color in Color:
    print(color)
</code></pre>
<p>特殊属性<code>__members__</code>是一个<strong>将名称映射到成员的有序字典</strong>，也可以通过它来完成遍历：</p>
<pre><code>for color in Color.__members__.items():
    print(color)          # ('red', &lt;Color.red: 1&gt;)
</code></pre>
<h3 id="枚举比较">枚举比较</h3>
<p>枚举的成员可以通过<strong>is 同一性</strong>比较或<strong>通过 == 等值</strong>比较：</p>
<pre><code>Color.red is Color.red
Color.red is not Color.blue

Color.blue == Color.red
Color.blue != Color.red
</code></pre>
<p>枚举成员<strong>不能进行大小比较</strong>：</p>
<pre><code>
Color.red &lt; Color.blue 
# TypeError: unorderable types: Color() &lt; Color()
</code></pre>
<h3 id="扩展枚举-intenum">扩展枚举 IntEnum</h3>
<p>IntEnum 是 Enum 的扩展，<strong>不同类型的整数枚举也可以相互比较</strong>：</p>
<pre><code>from enum import IntEnum
class Shape(IntEnum):
    circle = 1
    square = 2

class Request(IntEnum):
    post = 1
    get = 2

print(Shape.circle == 1)            # True
print(Shape.circle &lt; 3)             # True
print(Shape.circle == Request.post) # True
print(Shape.circle &gt;= Request.post) # True
</code></pre>
<h2 id="使用元类">使用元类</h2>
<h3 id="type">type()</h3>
<p>动态语言和静态语言最大的不同，就是<strong>函数和类的定义</strong>，<strong>不是编译时定义的，而是运行时动态创建的</strong>。</p>
<p>比方说我们要定义一个Hello的class，就写一个hello.py模块：</p>
<pre><code>class Hello(object):
    def hello(self, name='world'):
        print('Hello, %s.' % name)
</code></pre>
<p>当Python解释器载入hello模块时，就会<strong>依次执行该模块的所有语句</strong>，执行结果就是<strong>动态创建出一个Hello的class对象</strong>，测试如下：</p>
<pre><code>&gt;&gt;&gt; from hello import Hello
&gt;&gt;&gt; h = Hello()
&gt;&gt;&gt; h.hello()
Hello, world.
&gt;&gt;&gt; print(type(Hello))
&lt;class 'type'&gt;
&gt;&gt;&gt; print(type(h))
&lt;class 'hello.Hello'&gt;
</code></pre>
<p>type()函数可以<strong>查看一个类型或变量的类型</strong>，Hello是一个<strong>class，它的类型就是type</strong>，而h是一个<strong>实例，它的类型就是class Hello</strong>。</p>
<p>我们说class的定义是运行时动态创建的，而<strong>创建class的方法就是使用type()函数</strong>。</p>
<p>type()函数既可以<strong>返回一个对象的类型</strong>，又可以<strong>创建出新的类型</strong>，比如，我们可以通过type()函数创建出Hello类，而<strong>无需通过class Hello(object)...的定义</strong>：</p>
<pre><code>&gt;&gt;&gt; def fn(self, name='world'): # 先定义函数
...     print('Hello, %s.' % name)
...
&gt;&gt;&gt; Hello = type('Hello', (object,), dict(hello=fn)) # 创建Hello class
&gt;&gt;&gt; h = Hello()
&gt;&gt;&gt; h.hello()
Hello, world.
&gt;&gt;&gt; print(type(Hello))
&lt;class 'type'&gt;
&gt;&gt;&gt; print(type(h))
&lt;class '__main__.Hello'&gt;
</code></pre>
<p>要创建一个class对象，type()函数依次传入3个参数：</p>
<ol>
<li>class的名称；</li>
<li>继承的父类集合，注意Python支持多重继承，如果<strong>只有一个父类，别忘了tuple的单元素写法</strong>；</li>
<li><strong>class的方法名称与函数绑定</strong>，这里我们把函数fn绑定到方法名hello上。</li>
</ol>
<p>通过type()函数创建的类和直接写class是完全一样的，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用type()函数创建出class。</p>
<p>正常情况下，我们都用class Xxx...来定义类，但是，<strong>type()函数也允许我们动态创建出类来</strong>，也就是说，<strong>动态语言本身支持运行期动态创建类</strong>，这和静态语言有非常大的不同，要在静态语言运行期创建类，必须构造源代码字符串再调用编译器，或者借助一些工具生成字节码实现，本质上都是动态编译，会非常复杂。</p>
<h3 id="metaclass">metaclass</h3>
<p>除了使用type()动态创建类以外，要<strong>控制类的创建行为</strong>，还可以使用metaclass。</p>
<p>metaclass，直译为元类，简单的解释就是：</p>
<p>当我们定义了类以后，就可以根据这个类创建出实例，所以：先定义类，然后创建实例。</p>
<p>但是如果我们<strong>想创建出类</strong>，那就必须根据metaclass创建出类，所以：<strong>先定义metaclass，然后创建类</strong>。</p>
<p>连接起来就是：先定义metaclass，就可以创建类，最后创建实例。</p>
<p>所以，metaclass允许你创建类或者修改类。换句话说，你<strong>可以把类看成是metaclass创建出来的“实例”</strong>。</p>
<p>metaclass是Python面向对象里最难理解，也是最难使用的魔术代码。正常情况下，你不会碰到需要使用metaclass的情况，所以，以下内容看不懂也没关系，因为基本上你不会用到。</p>
<p>我们先看一个简单的例子，这个metaclass可以给我们自定义的MyList增加一个add方法：</p>
<p>定义ListMetaclass，按照默认习惯，metaclass的类名总是以Metaclass结尾，以便清楚地表示这是一个metaclass：</p>
<pre><code>#metaclass是类的模板，所以必须从`type`类型派生：
class ListMetaclass(type):
    def __new__(cls, name, bases, attrs):
        attrs['add'] = lambda self, value: self.append(value)
        return type.__new__(cls, name, bases, attrs)
</code></pre>
<p>有了ListMetaclass，我们<strong>在定义类的时候还要指示使用ListMetaclass来定制类，传入关键字参数metaclass</strong>：</p>
<pre><code>class MyList(list, metaclass=ListMetaclass):
    pass
</code></pre>
<p>当我们传入关键字参数metaclass时，魔术就生效了，它指示Python解释器在<strong>创建MyList时，要通过<code>ListMetaclass. __new__()</code>来创建</strong><br>
在此之上，我们可以修改类的定义，比如，加上新的方法，然后，返回修改后的定义。</p>
<p><code>__new__()</code>方法接收到的参数依次是：</p>
<ol>
<li>
<p>当前准备创建的类的对象；</p>
</li>
<li>
<p>类的名字；</p>
</li>
<li>
<p>类继承的父类集合；</p>
</li>
<li>
<p>类的方法集合。</p>
</li>
</ol>
<p>测试一下MyList是否可以调用add()方法：</p>
<pre><code>&gt;&gt;&gt; L = MyList()
&gt;&gt;&gt; L.add(1)
&gt;&gt; L
[1]
</code></pre>
<p>而普通的list没有add()方法：</p>
<pre><code>&gt;&gt;&gt; L2 = list()
&gt;&gt;&gt; L2.add(1)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
	AttributeError: 'list' object has no attribute 'add'
</code></pre>
<p><strong>动态修改</strong>有什么意义？直接在MyList定义中写上add()方法不是更简单吗？正常情况下，确实应该直接写，通过metaclass修改纯属变态。</p>
<p>但是，<strong>总会遇到需要通过metaclass修改类定义的。ORM就是一个典型的例子</strong>。</p>
<p>ORM全称“Object Relational Mapping”，即<strong>对象-关系映射，就是把关系数据库的一行映射为一个对象，也就是一个类对应一个表</strong>，这样，写代码更简单，<strong>不用直接操作SQL语句</strong>。</p>
<p>要编写一个ORM框架，<strong>所有的类都只能动态定义，因为只有使用者才能根据表的结构定义出对应的类来</strong>。</p>
<p>让我们来尝试编写一个ORM框架。</p>
<p>编写底层模块的第一步，就是先把调用接口写出来。比如，使用者如果使用这个ORM框架，想定义一个User类来操作对应的数据库表User，我们期待他写出这样的代码：</p>
<pre><code>class User(Model):
    # 定义类的属性到列的映射：
    id = IntegerField('id')
    name = StringField('username')
    email = StringField('email')
    password = StringField('password')


# 创建一个实例：
u = User(id=12345, name='Michael', email='test@orm.org', password='my-pwd')
# 保存到数据库：
u.save()
</code></pre>
<p>其中，父类Model和属性类型StringField、IntegerField是由ORM框架提供的，剩下的魔术方法比如save()全部由metaclass自动完成。虽然metaclass的编写会比较复杂，但ORM的使用者用起来却异常简单。</p>
<p>现在，我们就按上面的接口来实现该ORM。</p>
<p>首先来定义Field类，它负责保存数据库表的字段名和字段类型：</p>
<pre><code>class Field(object):

    def __init__(self, name, column_type):
        self.name = name
        self.column_type = column_type

    def __str__(self):
        return '&lt;%s:%s&gt;' % (self.__class__.__name__, self.name)
</code></pre>
<p>在Field的基础上，进一步定义各种类型的Field，比如StringField，IntegerField等等：</p>
<pre><code>class StringField(Field):

    def __init__(self, name):
        super(StringField, self).__init__(name, 'varchar(100)')

class IntegerField(Field):

    def __init__(self, name):
        super(IntegerField, self).__init__(name, 'bigint')
</code></pre>
<p>下一步，就是编写最复杂的ModelMetaclass了：</p>
<pre><code>class ModelMetaclass(type):

    def __new__(cls, name, bases, attrs):
        if name=='Model':
            return type.__new__(cls, name, bases, attrs)
        print('Found model: %s' % name)
        mappings = dict()
        for k, v in attrs.items():
            if isinstance(v, Field):
                print('Found mapping: %s ==&gt; %s' % (k, v))
                mappings[k] = v
        for k in mappings.keys():
            attrs.pop(k)
        attrs['__mappings__'] = mappings # 保存属性和列的映射关系
        attrs['__table__'] = name # 假设表名和类名一致
        return type.__new__(cls, name, bases, attrs)
</code></pre>
<p>以及基类Model：</p>
<pre><code>class Model(dict, metaclass=ModelMetaclass):

    def __init__(self, **kw):
        super(Model, self).__init__(**kw)

    def __getattr__(self, key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(r&quot;'Model' object has no attribute '%s'&quot; % key)

    def __setattr__(self, key, value):
        self[key] = value

    def save(self):
        fields = []
        params = []
        args = []
        for k, v in self.__mappings__.items():
            fields.append(v.name)
            params.append('?')
            args.append(getattr(self, k, None))
        sql = 'insert into %s (%s) values (%s)' % (self.__table__, ','.join(fields), ','.join(params))
        print('SQL: %s' % sql)
        print('ARGS: %s' % str(args))
</code></pre>
<p>当用户定义一个class User(Model)时，Python解释器首先在当前类User的定义中查找metaclass，如果没有找到，就继续在父类Model中查找metaclass，找到了，就使用Model中定义的metaclass的ModelMetaclass来创建User类，也就是说，<strong>metaclass可以隐式地继承到子类，但子类自己却感觉不到</strong>。</p>
<p>在ModelMetaclass中，一共做了几件事情：</p>
<ol>
<li>
<p>排除掉对Model类的修改；</p>
</li>
<li>
<p>在当前类（比如User）中查找定义的类的所有属性，如果找到一个Field属性，就把它保存到一个__mappings__的dict中，同时从类属性中删除该Field属性，否则，容易造成运行时错误（实例的属性会遮盖类的同名属性）；</p>
</li>
<li>
<p>把表名保存到__table__中，这里简化为表名默认为类名。</p>
</li>
</ol>
<p>在Model类中，就可以定义各种操作数据库的方法，比如save()，delete()，find()，update等等。</p>
<p>我们实现了save()方法，把一个实例保存到数据库中。因为有表名，属性到字段的映射和属性值的集合，就可以构造出INSERT语句。</p>
<p>编写代码试试：</p>
<pre><code>u = User(id=12345, name='Michael', email='test@orm.org', password='my-pwd')
u.save()
输出如下：

Found model: User
Found mapping: email ==&gt; &lt;StringField:email&gt;
Found mapping: password ==&gt; &lt;StringField:password&gt;
Found mapping: id ==&gt; &lt;IntegerField:uid&gt;
Found mapping: name ==&gt; &lt;StringField:username&gt;
SQL: insert into User (password,email,username,id) values (?,?,?,?)
ARGS: ['my-pwd', 'test@orm.org', 'Michael', 12345]
</code></pre>
<p>可以看到，save()方法已经打印出了可执行的SQL语句，以及参数列表，只需要真正连接到数据库，执行该SQL语句，就可以完成真正的功能。</p>
<p>不到100行代码，我们就通过metaclass实现了一个精简的ORM框架</p>
<h3 id="小结-3">小结</h3>
<p>metaclass是Python中非常具有魔术性的对象，它可以改变类创建时的行为。这种强大的功能使用起来务必小心。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Python - 面向对象编程]]></title>
        <id>https://lixin-scut.github.io//post/python-mian-xiang-dui-xiang-bian-cheng</id>
        <link href="https://lixin-scut.github.io//post/python-mian-xiang-dui-xiang-bian-cheng">
        </link>
        <updated>2020-05-10T08:51:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="面向对象编程">面向对象编程</h2>
<p>Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。</p>
<p><strong>面向过程</strong>的程序设计把计算机程序视为<strong>一系列的命令集合</strong>，即一组函数的<strong>顺序执行</strong>。为了简化程序设计，面向过程把函数继续<strong>切分为子函数</strong>，即把大块函数通过切割成小块函数来降低系统的复杂度。</p>
<p>而<strong>面向对象</strong>的程序设计把计算机程序视为<strong>一组对象的集合</strong>，而每个对象都可以<strong>接收其他对象发过来的消息，并处理这些消息</strong>，计算机程序的执行就是<strong>一系列消息在各个对象之间传递</strong>。</p>
<p>在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。<strong>自定义的对象数据类型</strong>就是<strong>面向对象中的类（Class）</strong> 的概念。</p>
<p>面向对象的设计思想是抽象出Class，根据Class创建Instance。</p>
<p>面向对象的抽象程度又比函数要高，因为一个Class既包含数据，又包含操作数据的方法。</p>
<h2 id="类和实例">类和实例</h2>
<p>面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。</p>
<p>仍以Student类为例，在Python中，<strong>定义类</strong>是通过<strong>class关键字</strong>：</p>
<pre><code>class Student(object):
    pass
</code></pre>
<p>class后面紧接着是类名，即Student，<strong>类名通常是大写开头的单词</strong>，<strong>紧接着是(object)，表示该类是从哪个类继承下来的</strong><br>
通常，<strong>如果没有合适的继承类，就使用object类</strong>，这是所有类最终都会继承的类。</p>
<p>定义好了Student类，就可以根据Student类创建出Student的实例，<strong>创建实例是通过类名+()实现的</strong>：</p>
<pre><code>&gt;&gt;&gt; bart = Student()
&gt;&gt;&gt; bart
&lt;__main__.Student object at 0x10a67a590&gt;
&gt;&gt;&gt; Student
&lt;class '__main__.Student'&gt;
</code></pre>
<p>可以看到，<strong>变量bart</strong>指向的就是一个Student的实例，后面的0x10a67a590是内存地址，<strong>每个object的地址都不一样</strong>，而<strong>Student本身则是一个类</strong>。</p>
<p>可以自由地给一个实例变量绑定属性，比如，给实例bart绑定一个name属性：</p>
<pre><code>&gt;&gt;&gt; bart.name = 'Bart Simpson'
&gt;&gt;&gt; bart.name
'Bart Simpson'
</code></pre>
<p>由于类可以起到模板的作用，因此，可以<strong>在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去</strong>。通过<strong>定义一个特殊的init方法</strong>，在创建实例的时候，就把name，score等属性绑上去：</p>
<pre><code>class Student(object):

    def __init__(self, name, score):
        self.name = name
        self.score = score
</code></pre>
<p><strong>注意：特殊方法“<code>init</code>”前后分别有两个下划线！！！</strong></p>
<p><strong>注意到init方法的第一个参数永远是self，表示创建的实例本身</strong>，因此，在<code>__init__</code>方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。</p>
<p>有了<code>__init__</code>方法，在创建实例的时候，就不能传入空的参数了，<strong>必须传入与<code>init</code>方法匹配的参数</strong>，<strong>但self不需要传，Python解释器自己会把实例变量传进去：</strong></p>
<pre><code>&gt;&gt;&gt; bart = Student('Bart Simpson', 59)
&gt;&gt;&gt; bart.name
'Bart Simpson'
&gt;&gt;&gt; bart.score
59
</code></pre>
<p>和普通的函数相比，在类中定义的函数只有一点不同，<strong>就是第一个参数永远是实例变量self</strong>，并且调用时不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你<strong>仍然可以用默认参数、可变参数、关键字参数和命名关键字参数</strong>。</p>
<h3 id="数据封装">数据封装</h3>
<p>面向对象编程的一个重要特点就是<strong>数据封装</strong>。在上面的Student类中，每个实例就拥有各自的name和score这些数据。我们<strong>可以通过函数来访问这些数据</strong>，比如打印一个学生的成绩：</p>
<pre><code>&gt;&gt;&gt; def print_score(std):
...     print('%s: %s' % (std.name, std.score))
...
&gt;&gt;&gt; print_score(bart)
Bart Simpson: 59
</code></pre>
<p>但是，既然Student实例本身就拥有这些数据，要访问这些数据，就没有必要从外面的函数去访问，可以<strong>直接在Student类的内部定义访问数据的函数</strong>，这样，就把“数据”给封装起来了。这些封装数据的函数是和Student类本身是关联起来的，我们称之为类的方法：</p>
<pre><code>class Student(object):

    def __init__(self, name, score):
        self.name = name
        self.score = score

    def print_score(self):
        print('%s: %s' % (self.name, self.score))
</code></pre>
<p>要定义一个方法，除了<strong>第一个参数是self</strong>外，其他和普通函数一样。要调用一个方法，<strong>只需要在实例变量上直接调用</strong>，除了self不用传递，其他参数正常传入：</p>
<pre><code>&gt;&gt;&gt; bart.print_score()
Bart Simpson: 59
</code></pre>
<p>这样一来，我们从外部看Student类，就只需要知道，创建实例需要给出name和score，而如何打印，都是在Student类的内部定义的，这些数据和逻辑被“封装”起来了，调用很容易，但却不用知道内部实现的细节。</p>
<p>封装的另一个好处是可以给Student类增加新的方法，比如get_grade：</p>
<pre><code>class Student(object):
    ...

    def get_grade(self):
        if self.score &gt;= 90:
            return 'A'
        elif self.score &gt;= 60:
            return 'B'
        else:
            return 'C'
</code></pre>
<h2 id="访问限制">访问限制</h2>
<p>在Class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样，就隐藏了内部的复杂逻辑。</p>
<p>但是，从前面Student类的定义来看，外部代码还是可以自由地修改一个实例的name、score属性：</p>
<pre><code>&gt;&gt;&gt; bart = Student('Bart Simpson', 59)
&gt;&gt;&gt; bart.score
59
&gt;&gt;&gt; bart.score = 99
&gt;&gt;&gt; bart.score
99
</code></pre>
<p><strong>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<code>__</code><br>
在Python中，实例的变量名如果以<code>__</code>开头，就变成了一个私有变量（private） 只有内部可以访问，外部不能访问</strong><br>
所以，我们把Student类改一改：</p>
<pre><code>class Student(object):

    def __init__(self, name, score):
        self.__name = name
        self.__score = score

    def print_score(self):
        print('%s: %s' % (self.__name, self.__score))
</code></pre>
<p>改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问实例变量<code>.__name</code>和实例变量<code>.__score</code>了：</p>
<pre><code>&gt;&gt;&gt; bart = Student('Bart Simpson', 59)
&gt;&gt;&gt; bart.__name
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'Student' object has no attribute '__name'
</code></pre>
<p>这样就确保了外部代码不能随意修改对象内部的状态，这样通过访问限制的保护，代码更加健壮。</p>
<p>但是如果外部代码要获取name和score，可以给Student类增加get_name和get_score这样的方法：</p>
<pre><code>class Student(object):
    ...

    def get_name(self):
        return self.__name

    def get_score(self):
        return self.__score
</code></pre>
<p>如果又要允许外部代码修改score,可以再给Student类增加set_score方法：</p>
<pre><code>class Student(object):
    ...

    def set_score(self, score):
        self.__score = score
</code></pre>
<p>在方法中，可以对参数做检查，避免传入无效的参数：</p>
<pre><code>class Student(object):
    ...

    def set_score(self, score):
        if 0 &lt;= score &lt;= 100:
            self.__score = score
        else:
            raise ValueError('bad score')
</code></pre>
<p>需要注意的是，在Python中，<strong>变量名类似xxx的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量</strong>，所以，<strong>不能用</strong><code>__name__</code>、<code>__score__</code>这样的变量名。</p>
<p>有些时候会看到以<strong>一个下划线</strong>开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，<strong>“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”</strong>。</p>
<p>双下划线开头的实例变量<strong>是不是一定不能从外部访问呢</strong>？其实也不是。不能直接访问__name是因为Python解释器对外把<code>__name</code>变量<strong>改成了_Studentname</strong>，所以，<strong>仍然可以通过_Studentname来访问</strong><code>__name</code>变量：</p>
<pre><code>&gt;&gt;&gt; bart._Student__name
'Bart Simpson'
</code></pre>
<p>但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把__name改成不同的变量名。</p>
<p>总的来说就是，<strong>Python本身没有任何机制阻止你干坏事，一切全靠自觉</strong>。</p>
<p>最后注意下面的这种错误写法：</p>
<pre><code>&gt;&gt;&gt; bart = Student('Bart Simpson', 59)
&gt;&gt;&gt; bart.get_name()
'Bart Simpson'
&gt;&gt;&gt; bart.__name = 'New Name' # 设置__name变量！
&gt;&gt;&gt; bart.__name
'New Name'
</code></pre>
<p>表面上看，外部代码“成功”地设置了__name变量，但实际上这个__name变量和class内部的__name变量<strong>不是一个变量！</strong> 内部的__name变量已经被Python解释器<strong>自动改成了_Student__name</strong>，而<strong>外部代码给bart新增了一个__name变量</strong>。不信试试：</p>
<pre><code>&gt;&gt;&gt; bart.get_name() # get_name()内部返回self.__name
'Bart Simpson'
</code></pre>
<h2 id="继承和多态">继承和多态</h2>
<p>在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。</p>
<p>比如，我们已经编写了一个名为Animal的class，有一个run()方法可以直接打印：</p>
<pre><code>class Animal(object):
    def run(self):
        print('Animal is running...')
</code></pre>
<p>当我们需要编写Dog和Cat类时，就可以直接从Animal类继承：</p>
<pre><code>class Dog(Animal):
    pass

class Cat(Animal):
    pass
</code></pre>
<p>对于Dog来说，Animal就是它的父类，对于Animal来说，Dog就是它的子类。Cat和Dog类似。</p>
<p>继承有什么好处？<strong>最大的好处是子类获得了父类的全部功能</strong>。由于Animial实现了run()方法，因此，Dog和Cat作为它的子类，什么事也没干，就自动拥有了run()方法：</p>
<pre><code>dog = Dog()
dog.run()

cat = Cat()
cat.run()
</code></pre>
<p>运行结果如下：</p>
<pre><code>Animal is running...
Animal is running...
</code></pre>
<p>当然，也可以对子类增加一些方法，比如Dog类：</p>
<pre><code>class Dog(Animal):

    def run(self):
        print('Dog is running...')

    def eat(self):
        print('Eating meat...')
</code></pre>
<p>继承的第二个好处需要我们对代码做一点改进。你看到了，无论是Dog还是Cat，它们run()的时候，显示的都是Animal is running...，符合逻辑的做法是分别显示Dog is running...和Cat is running...，因此，对Dog和Cat类改进如下：</p>
<pre><code>class Dog(Animal):

    def run(self):
        print('Dog is running...')

class Cat(Animal):

    def run(self):
        print('Cat is running...')
				
</code></pre>
<p>再次运行，结果如下：</p>
<pre><code>Dog is running...
Cat is running...
</code></pre>
<p><strong>当子类和父类都存在相同的run()方法时，我们说，子类的run()覆盖了父类的run()</strong>，在代码运行的时候，总是会调用子类的run()。这样，我们就获得了继承的<strong>另一个好处：多态</strong>。</p>
<p>要理解什么是多态，我们首先要对数据类型再作一点说明。当我们定义一个class的时候，我们实际上就定义了一种数据类型。我们定义的数据类型和Python自带的数据类型，比如str、list、dict没什么两样：</p>
<pre><code>a = list() # a是list类型
b = Animal() # b是Animal类型
c = Dog() # c是Dog类型
</code></pre>
<p>判断一个变量是否是某个类型可以用isinstance()判断：</p>
<pre><code>&gt;&gt;&gt; isinstance(a, list)
True
&gt;&gt;&gt; isinstance(b, Animal)
True
&gt;&gt;&gt; isinstance(c, Dog)
True
</code></pre>
<p>看来a、b、c确实对应着list、Animal、Dog这3种类型。</p>
<p>但是等等，试试：</p>
<pre><code>&gt;&gt;&gt; isinstance(c, Animal)
True
</code></pre>
<p>看来c不仅仅是Dog，c还是Animal！</p>
<p>不过仔细想想，这是有道理的，因为Dog是从Animal继承下来的，当我们创建了一个Dog的实例c时，我们认为c的数据类型是Dog没错，但c同时也是Animal也没错，Dog本来就是Animal的一种！</p>
<p>所以，在继承关系中，<strong>如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类</strong>。但是，反过来就不行：</p>
<pre><code>&gt;&gt;&gt; b = Animal()
&gt;&gt;&gt; isinstance(b, Dog)
False
</code></pre>
<p>Dog可以看成Animal，但Animal不可以看成Dog。</p>
<p>要理解多态的好处，我们还需要再编写一个函数，<strong>这个函数接受一个Animal类型的变量</strong>：</p>
<pre><code>def run_twice(animal):
    animal.run()
    animal.run()
</code></pre>
<p>当我们传入Animal的实例时，run_twice()就打印出：</p>
<pre><code>&gt;&gt;&gt; run_twice(Animal())
Animal is running...
Animal is running...
</code></pre>
<p>当我们传入Dog的实例时，run_twice()就打印出：</p>
<pre><code>&gt;&gt;&gt; run_twice(Dog())
Dog is running...
Dog is running...
</code></pre>
<p>当我们传入Cat的实例时，run_twice()就打印出：</p>
<pre><code>&gt;&gt;&gt; run_twice(Cat())
Cat is running...
Cat is running...
</code></pre>
<p>看上去没啥意思，但是仔细想想，现在，如果我们再定义一个Tortoise类型，也从Animal派生：</p>
<pre><code>class Tortoise(Animal):
    def run(self):
        print('Tortoise is running slowly...')
</code></pre>
<p>当我们调用run_twice()时，传入Tortoise的实例：</p>
<pre><code>&gt;&gt;&gt; run_twice(Tortoise())
Tortoise is running slowly...
Tortoise is running slowly...
</code></pre>
<p>你会发现，<strong>新增一个Animal的子类，不必对run_twice()做任何修改</strong>，实际上，<strong>任何依赖Animal作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态</strong>。</p>
<p>多态的好处就是，当我们需要传入Dog、Cat、Tortoise……时，我们只需要接收Animal类型就可以了，因为Dog、Cat、Tortoise……都是Animal类型，然后，按照Animal类型进行操作即可。由于Animal类型有run()方法，因此，传入的任意类型，<strong>只要是Animal类或者子类，就会自动调用实际类型的run()方法，这就是多态的意思</strong>：</p>
<p>对于一个变量，我们<strong>只需要知道它是Animal类型，无需确切地知道它的子类型，就可以放心地调用run()方法</strong>，而具体调用的run()方法是作用在Animal、Dog、Cat还是Tortoise对象上，<strong>由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节</strong>，而当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：</p>
<p><strong>对扩展开放：允许新增Animal子类；</strong></p>
<p><strong>对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。</strong></p>
<p><strong>继承还可以一级一级地继承下来</strong>，就好比从爷爷到爸爸、再到儿子这样的关系。而任何类，最终都可以追溯到根类object，这些继承关系看上去就像一颗倒着的树。比如如下的继承树：</p>
<pre><code>
                ┌───────────────┐
                │    object     │
                └───────────────┘
                        │
           ┌────────────┴────────────┐
           │                         │
           ▼                         ▼
    ┌─────────────┐           ┌─────────────┐
    │   Animal    │           │    Plant    │
    └─────────────┘           └─────────────┘
           │                         │
     ┌─────┴──────┐            ┌─────┴──────┐
     │            │            │            │
     ▼            ▼            ▼            ▼
┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
│   Dog   │  │   Cat   │  │  Tree   │  │ Flower  │
└─────────┘  └─────────┘  └─────────┘  └─────────┘

</code></pre>
<h3 id="静态语言-vs-动态语言">静态语言 vs 动态语言</h3>
<p>对于<strong>静态语言</strong>（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。</p>
<p><strong>但是注意！！！</strong> 对于Python这样的<strong>动态语言</strong>来说，<strong>则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了</strong>：</p>
<p><strong>这就是动态语言的特征，变量只有在赋值的是后才有“类型-type”。而java静态语言在定义函数的时候，参数的类型已经通过显式声明确定了。所以后面就不能随便传入一个类。</strong></p>
<pre><code>class Timer(object):
    def run(self):
        print('Start...')
</code></pre>
<p>这就是<strong>动态语言的“鸭子类型”，它并不要求严格的继承体系</strong>，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</p>
<p><strong>Python的“file-like object“就是一种鸭子类型</strong>。对真正的文件对象，它有一个read()方法，返回其内容。但是，许多对象，只要有read()方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了read()方法的对象。</p>
<h3 id="小结">小结</h3>
<p>继承可以把父类的所有功能都直接拿过来，这样就不必重零做起，子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写。</p>
<p>动态语言的鸭子类型特点决定了继承不像静态语言那样是必须的。</p>
<h2 id="获取对象信息">获取对象信息</h2>
<p>当我们拿到一个对象的引用时，如何知道这个对象是什么类型、有哪些方法呢？</p>
<h3 id="使用type">使用type()</h3>
<p>使用type()函数来判断对象类型，：</p>
<ol>
<li><strong>基本类型</strong></li>
</ol>
<pre><code>&gt;&gt;&gt; type(123)
&lt;class 'int'&gt;
&gt;&gt;&gt; type('str')
&lt;class 'str'&gt;
&gt;&gt;&gt; type(None)
&lt;type(None) 'NoneType'&gt;
</code></pre>
<ol start="2">
<li>函数或者类<br>
如果一个变量指向<strong>函数或者类</strong>，也可以用type()判断：</li>
</ol>
<pre><code>&gt;&gt;&gt; type(abs)
&lt;class 'builtin_function_or_method'&gt;
&gt;&gt;&gt; type(a)
&lt;class '__main__.Animal'&gt;
</code></pre>
<p>但是对于类，type()函数返回对应的Class类型，而不是仅仅Class。</p>
<p>所以如果我们要在if语句中判断，就需要比较两个变量的type类型是否相同：</p>
<pre><code>&gt;&gt;&gt; type(123)==type(456)
True
&gt;&gt;&gt; type(123)==int
True
&gt;&gt;&gt; type('abc')==type('123')
True
&gt;&gt;&gt; type('abc')==str
True
&gt;&gt;&gt; type('abc')==type(123)
False
</code></pre>
<p>对于函数同样地，判断基本数据类型可以直接写int，str等，但如果要判断一个对象是否是函数怎么办？可以<strong>使用types模块中定义的常量</strong>：</p>
<pre><code>&gt;&gt;&gt; import types
&gt;&gt;&gt; def fn():
...     pass
...
&gt;&gt;&gt; type(fn)==types.FunctionType
True
&gt;&gt;&gt; type(abs)==types.BuiltinFunctionType
True
&gt;&gt;&gt; type(lambda x: x)==types.LambdaType
True
&gt;&gt;&gt; type((x for x in range(10)))==types.GeneratorType
True
</code></pre>
<h3 id="使用isinstance">使用isinstance()</h3>
<p>对于class的继承关系来说，使用type()就很不方便。我们要判断class的类型，可以使用isinstance()函数。</p>
<p>我们回顾上次的例子，如果继承关系是：</p>
<pre><code>object -&gt; Animal -&gt; Dog -&gt; Husky
</code></pre>
<p>那么，isinstance()就可以告诉我们，一个对象是否是某种类型。先创建3种类型的对象：</p>
<pre><code>&gt;&gt;&gt; a = Animal()
&gt;&gt;&gt; d = Dog()
&gt;&gt;&gt; h = Husky()
</code></pre>
<p>然后，判断：</p>
<pre><code>&gt;&gt;&gt; isinstance(h, Husky)
True
</code></pre>
<p>没有问题，因为h变量指向的就是Husky对象。</p>
<p>再判断：</p>
<pre><code>&gt;&gt;&gt; isinstance(h, Dog)
True
</code></pre>
<p><strong>h虽然自身是Husky类型，但由于Husky是从Dog继承下来的，所以，h也还是Dog类型</strong>。<br>
换句话说，isinstance()判断的是一个对象是否是该类型本身，<strong>或者位于该类型的父继承链上</strong>。</p>
<p>因此，我们可以确信，<strong>h还是Animal类型</strong>：</p>
<pre><code>&gt;&gt;&gt; isinstance(h, Animal)
True
</code></pre>
<p>同理，实际类型是Dog的d也是Animal类型：</p>
<pre><code>&gt;&gt;&gt; isinstance(d, Dog) and isinstance(d, Animal)
True
</code></pre>
<p>但是，d不是Husky类型：</p>
<pre><code>&gt;&gt;&gt; isinstance(d, Husky)
False
</code></pre>
<p><strong>能用type()判断的基本类型也可以用isinstance()判断</strong>：</p>
<pre><code>&gt;&gt;&gt; isinstance('a', str)
True
&gt;&gt;&gt; isinstance(123, int)
True
&gt;&gt;&gt; isinstance(b'a', bytes)
True
</code></pre>
<p><strong>并且还可以判断一个变量是否是某些类型中的一种</strong>，比如下面的代码就可以判断是否是list或者tuple：</p>
<pre><code>&gt;&gt;&gt; isinstance([1, 2, 3], (list, tuple))
True
&gt;&gt;&gt; isinstance((1, 2, 3), (list, tuple))
True
</code></pre>
<p><strong>总是优先使用isinstance()判断类型</strong>，<strong>因为可以将指定类型及其子类同时进行判断</strong>。</p>
<h2 id="使用dir">使用dir()</h2>
<p>如果要<strong>获得一个对象的所有属性和方法</strong>，可以使用dir()函数，它返回一个包<strong>含字符串的list</strong>，比如，获得一个str对象的所有属性和方法：</p>
<pre><code>&gt;&gt;&gt; dir('ABC')
['__add__', '__class__',..., '__subclasshook__', 'capitalize', 'casefold',..., 'zfill']
</code></pre>
<p><strong>类似__xxx__的属性和方法在Python中都是有特殊用途的</strong><br>
比如__len__方法返回长度。<strong>在Python中，如果你调用len()函数试图获取一个对象的长度，实际上，在len()函数内部，它自动去调用该对象的__len__()方法</strong>，所以，下面的代码是等价的：</p>
<pre><code>&gt;&gt;&gt; len('ABC')
3
&gt;&gt;&gt; 'ABC'.__len__()
3
</code></pre>
<p>我们自己写的类，如果也想用len(myObj)的话，就自己写一个__len__()方法：</p>
<pre><code>&gt;&gt;&gt; class MyDog(object):
...     def __len__(self):
...         return 100
...
&gt;&gt;&gt; dog = MyDog()
&gt;&gt;&gt; len(dog)
100
</code></pre>
<p>剩下的都是<strong>普通属性或方法</strong>，比如lower()返回小写的字符串：</p>
<pre><code>&gt;&gt;&gt; 'ABC'.lower()
'abc'
</code></pre>
<p>仅仅把属性和方法列出来是不够的，<strong>配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态</strong>：</p>
<pre><code>&gt;&gt;&gt; class MyObject(object):
...     def __init__(self):
...         self.x = 9
...     def power(self):
...         return self.x * self.x
...
&gt;&gt;&gt; obj = MyObject()
</code></pre>
<p>紧接着，可以测试该对象的属性：</p>
<pre><code>&gt;&gt;&gt; hasattr(obj, 'x') # 有属性'x'吗？
True
&gt;&gt;&gt; obj.x
9
&gt;&gt;&gt; hasattr(obj, 'y') # 有属性'y'吗？
False
&gt;&gt;&gt; setattr(obj, 'y', 19) # 设置一个属性'y'
&gt;&gt;&gt; hasattr(obj, 'y') # 有属性'y'吗？
True
&gt;&gt;&gt; getattr(obj, 'y') # 获取属性'y'
19
&gt;&gt;&gt; obj.y # 获取属性'y'
19
</code></pre>
<p><strong>如果试图获取不存在的属性，会抛出AttributeError的错误</strong>：</p>
<pre><code>&gt;&gt;&gt; getattr(obj, 'z') # 获取属性'z'
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'MyObject' object has no attribute 'z'
</code></pre>
<p>可以传入一个default参数，如果属性不存在，就返回默认值：</p>
<pre><code>&gt;&gt;&gt; getattr(obj, 'z', 404) # 获取属性'z'，如果不存在，返回默认值404
404
</code></pre>
<p>也可以获得对象的方法：</p>
<pre><code>&gt;&gt;&gt; hasattr(obj, 'power') # 有属性'power'吗？
True
&gt;&gt;&gt; getattr(obj, 'power') # 获取属性'power'
&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;
&gt;&gt;&gt; fn = getattr(obj, 'power') # 获取属性'power'并赋值到变量fn
&gt;&gt;&gt; fn # fn指向obj.power
&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;
&gt;&gt;&gt; fn() # 调用fn()与调用obj.power()是一样的
81
</code></pre>
<h3 id="小结-2">小结</h3>
<p>通过内置的一系列函数，我们可以对任意一个Python对象进行剖析，拿到其内部的数据。要注意的是，<strong>只有在不知道对象信息的时候，我们才会去获取对象信息</strong>。如果可以直接写：</p>
<pre><code>sum = obj.x + obj.y
</code></pre>
<p>就不要写：</p>
<pre><code>sum = getattr(obj, 'x') + getattr(obj, 'y')
</code></pre>
<p>一个正确的用法的例子如下：</p>
<pre><code>def readImage(fp):
    if hasattr(fp, 'read'):
        return readData(fp)
    return None
</code></pre>
<p>假设我们希望从文件流fp中读取图像，我们首先要判断该fp对象是否存在read方法，如果存在，则该对象是一个流，如果不存在，则无法读取。hasattr()就派上了用场。</p>
<p>请注意，<strong>在Python这类动态语言中，根据鸭子类型，有read()方法，不代表该fp对象就是一个文件流，它也可能是网络流，也可能是内存中的一个字节流，但只要read()方法返回的是有效的图像数据，就不影响读取图像的功能</strong>。</p>
<h2 id="实例属性和类属性">实例属性和类属性</h2>
<p>由于Python是<strong>动态语言，根据类创建的实例可以任意绑定属性</strong>。</p>
<p>给实例绑定属性的方法是<strong>通过实例变量，或者通过self变量</strong>：</p>
<pre><code>class Student(object):
    def __init__(self, name):
        self.name = name

s = Student('Bob')
s.score = 90
</code></pre>
<p>但是如果Student<strong>类本身需要绑定一个属性</strong>,可以<strong>直接在class中定义属性</strong>，这种属性是<strong>类属性，归Student类所有</strong>：</p>
<pre><code>class Student(object):
    name = 'Student'
</code></pre>
<p>当我们<strong>定义了一个类属性后</strong>，这个属性虽然归类所有，但<strong>类的所有实例都可以访问到</strong>。来测试一下：</p>
<pre><code>&gt;&gt;&gt; class Student(object):
...     name = 'Student'
...
&gt;&gt;&gt; s = Student() # 创建实例s
&gt;&gt;&gt; print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性
Student
&gt;&gt;&gt; print(Student.name) # 打印类的name属性
Student
&gt;&gt;&gt; s.name = 'Michael' # 给实例绑定name属性
&gt;&gt;&gt; print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性
Michael
&gt;&gt;&gt; print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问
Student
&gt;&gt;&gt; del s.name # 如果删除实例的name属性
&gt;&gt;&gt; print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了
Student
</code></pre>
<p><strong>实例属性优先级比类属性高</strong></p>
<p>从上面的例子可以看出，在编写程序的时候，千万不要对实例属性和类属性使用相同的名字，因为<strong>相同名称的实例属性将屏蔽掉类属性</strong>，但是当你<strong>删除实例属性后，再使用相同的名称，访问到的将是类属性</strong>。</p>
<h3 id="小结-3">小结</h3>
<p><strong>实例属性属于各个实例所有，互不干扰</strong>；</p>
<p>类属性属于类所有，所有实例共享一个属性；(类似于C++的static)</p>
<p>不要对实例属性和类属性使用相同的名字，否则将产生难以发现的错误。</p>
<h3 id="个人练习代码">个人练习代码</h3>
<p>练习</p>
<p>为了统计学生人数，可以给Student类增加一个类属性，每创建一个实例，该属性自动增加：</p>
<pre><code># -*- coding: utf-8 -*-
class Student(object):
    count = 0

    def __init__(self, name):
        self.name = name
        Student.count += 1
				
# 测试:
if Student.count != 0:
    print('测试失败!')
else:
    bart = Student('Bart')
    if Student.count != 1:
        print('测试失败!')
    else:
        lisa = Student('Bart')
        if Student.count != 2:
            print('测试失败!')
        else:
            print('Students:', Student.count)
            print('测试通过!')
</code></pre>
<p>注意：</p>
<ol>
<li>前面说过了类的属性类似于static变量，所以要用Student.count访问，而不能用count或者self.count</li>
<li>测试用例中可以看到就算没有实例也可以用 Student.count 访问初始值</li>
<li>python的类实例并没有限定类的数据成员。。。可以任意添加。。。</li>
</ol>
<p>网友的另外一种实现方法，主要是利用__class__这个特殊变量</p>
<pre><code>class Student(object):
    count = 0
    def __init__(self, name):
        self.name = name
        self.__class__.count += 1
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python - 模块]]></title>
        <id>https://lixin-scut.github.io//post/python-mo-kuai</id>
        <link href="https://lixin-scut.github.io//post/python-mo-kuai">
        </link>
        <updated>2020-05-10T04:24:27.000Z</updated>
        <content type="html"><![CDATA[<h2 id="模块">模块</h2>
<p>为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Python中，<strong>一个.py文件就称之为一个模块（Module）</strong>。</p>
<p>使用模块最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Python内置的模块和来自第三方的模块。</p>
<p>使用模块还可以<strong>避免函数名和变量名冲突</strong>。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在<strong>编写模块时，不必考虑名字会与其他模块冲突</strong>。但是也要注意，<strong>尽量不要与内置函数名字冲突</strong>。</p>
<p>但不同的人编写的模块名可能相同，为了<strong>避免模块名冲突</strong>，Python又引入了<strong>按目录来组织模块</strong>的方法，称为<strong>包（Package）</strong>。</p>
<p>举个例子，一个abc.py的文件就是一个名字叫abc的模块，一个xyz.py的文件就是一个名字叫xyz的模块。</p>
<p>现在，假设我们的abc和xyz这两个模块名字与其他模块冲突了，于是我们可以<strong>通过包来组织模块</strong>，避免冲突。方法是<strong>选择一个顶层包名，比如mycompany</strong>，按照如下目录存放：</p>
<pre><code>mycompany
├─ __init__.py
├─ abc.py
└─ xyz.py
</code></pre>
<p>引入了包以后，<strong>只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突</strong>。现在，abc.py模块的名字就变成了mycompany.abc，类似的，xyz.py的模块名变成了mycompany.xyz。</p>
<p>请注意，<strong>每一个包目录下面都会有一个<code>__init__.py</code>的文件</strong>，这个文件是<strong>必须存在的</strong>，否则，Python就把这个目录<strong>当成普通目录，而不是一个包</strong>。<code>__init__.py</code>可以是<strong>空文件</strong>，也可以<strong>有Python代码</strong>，因为__init__.py<strong>本身就是一个模块</strong>，而它的模块名就是mycompany。</p>
<p>类似的，可以有多级目录，组成多级层次的包结构。比如如下的目录结构：</p>
<pre><code>mycompany
 ├─ web
 │  ├─ __init__.py
 │  ├─ utils.py
 │  └─ www.py
 ├─ __init__.py
 ├─ abc.py
 └─ utils.py
</code></pre>
<p>文件<code>www.py</code>的模块名就是<code>mycompany.web.www</code>，两个文件<code>utils.py</code>的模块名分别是<code>mycompany.utils</code>和<code>mycompany.web.utils</code>。</p>
<p>自己创建模块时要注意命名，<strong>不能和Python自带的模块名称冲突</strong>。例如，系统自带了sys模块，自己的模块就不可命名为sys.py，否则将无法导入系统自带的sys模块。<br>
<code>mycompany.web</code>也是一个模块，请指出该模块对应的.py文件。</p>
<h3 id="总结">总结</h3>
<p>模块是一组Python代码的集合，可以使用其他模块，也可以被其他模块使用。</p>
<p>创建自己的模块时，要注意：</p>
<ol>
<li>模块名要<strong>遵循Python变量命名规范</strong>，不要使用中文、特殊字符；</li>
<li>模块名<strong>不要和系统模块名冲突</strong>，最好先查看系统是否已存在该模块，检查方法是在Python交互环境执行import abc，若成功则说明系统存在此模块。</li>
</ol>
<h2 id="使用模块">使用模块</h2>
<p>Python本身就内置了很多非常有用的模块，只要安装完毕，这些模块就可以立刻使用。</p>
<p>我们以内建的sys模块为例，编写一个hello的模块：</p>
<pre><code>#!/usr/bin/env python3
# -*- coding: utf-8 -*-

' a test module '

__author__ = 'Michael Liao'

import sys

def test():
    args = sys.argv
    if len(args)==1:
        print('Hello, world!')
    elif len(args)==2:
        print('Hello, %s!' % args[1])
    else:
        print('Too many arguments!')

if __name__=='__main__':
    test()
</code></pre>
<pre><code>#!/usr/bin/env python3
# -*- coding: utf-8 -*-
</code></pre>
<p>第1行和第2行是标准注释，第1行注释可以让这个hello.py文件直接在Unix/Linux/Mac上运行，第2行注释表示.py文件本身使用标准UTF-8编码；</p>
<pre><code>' a test module '
</code></pre>
<p>第4行是一个字符串，表示模块的文档注释，<strong>任何模块代码的第一个字符串都被视为模块的文档注释</strong>；</p>
<pre><code>__author__ = 'Michael Liao'
</code></pre>
<p>第6行使用__author__变量把作者写进去</p>
<p>以上就是Python模块的标准文件模板，当然也可以全部删掉不写，但是，按标准办事肯定没错。</p>
<p>后面开始就是真正的代码部分。</p>
<p>使用sys模块的第一步，就是导入该模块：</p>
<pre><code>import sys
</code></pre>
<p>导入sys模块后，我们就有了<strong>变量sys</strong>指向该模块，<strong>利用sys这个变量</strong>，就可以访问sys模块的所有功能。</p>
<p>sys模块有一个argv变量，用list存储了命令行的所有参数。argv至少有一个元素，因为第一个参数永远是该.py文件的名称，例如：</p>
<p>运行python3 hello.py获得的sys.argv就是<code>['hello.py']</code>；</p>
<p>运行python3 hello.py Michael获得的sys.argv就是<code>['hello.py', 'Michael]</code>。</p>
<p>最后，注意到这两行代码：</p>
<pre><code>if __name__=='__main__':
    test()
</code></pre>
<p>当我们在命令行运行hello模块文件时，Python解释器把一个<strong>特殊变量name</strong>置为__main__，而如果在其他地方导入该hello模块时，if判断将失败，因此，<strong>这种if测试可以让一个模块通过命令行运行时执行一些额外的代码</strong>，最常见的就是运行测试。</p>
<p>用命令行运行hello.py看看效果：</p>
<pre><code>$ python3 hello.py
Hello, world!
$ python hello.py Michael
Hello, Michael!
</code></pre>
<p>如果启动Python交互环境，再导入hello模块：</p>
<pre><code>$ python3
Python 3.4.3 (v3.4.3:9b73f1c3e601, Feb 23 2015, 02:52:03) 
[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import hello
&gt;&gt;&gt;
</code></pre>
<p>导入时，没有打印Hello, word!，因为没有执行test()函数。</p>
<p>调用hello.test()时，才能打印出Hello, word!：</p>
<pre><code>&gt;&gt;&gt; hello.test()
Hello, world!
</code></pre>
<h2 id="作用域">作用域</h2>
<p>在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，<strong>有的函数和变量我们希望仅仅在模块内部使用</strong>。在Python中，是<strong>通过_前缀</strong>来实现的。</p>
<p>正常的函数和变量名是<strong>公开的（public），可以被直接引用</strong>，比如：abc，x123，PI等；</p>
<p>类似<code>__xxx__</code>这样的变量是<strong>特殊变量，可以被直接引用，但是有特殊用途</strong>，比如上面的<code>__author__</code>，<code>__name__</code>就是特殊变量，hello模块定义的文档注释也可以用特殊变量<code>__doc__</code>访问，自定义的变量<strong>一般不要用这种变量名</strong>；</p>
<p>类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是<strong>非公开的（private)</strong>，<strong>不应该被直接引用</strong>，比如<code>_abc</code>，<code>__abc</code>等；</p>
<p>之所以我们说，<strong>private函数和变量“不应该”被直接引用 ，而不是“不能”被直接引用</strong>，是因为<strong>Python并没有一种方法可以完全限制访问private函数或变量</strong>，但是，从编程习惯上<strong>不应该引用private函数或变量</strong>。</p>
<p>private函数或变量不应该被别人引用</p>
<p>使用例子：</p>
<pre><code>def _private_1(name):
    return 'Hello, %s' % name

def _private_2(name):
    return 'Hi, %s' % name

def greeting(name):
    if len(name) &gt; 3:
        return _private_1(name)
    else:
        return _private_2(name)
</code></pre>
<p>我们在模块里<strong>公开greeting()函数</strong>，而把<strong>内部逻辑用private函数隐藏起来</strong>了，这样，<strong>调用greeting()函数不用关心内部的private函数细节</strong>，这也是一种非常有用的代<strong>码封装和抽象的方法</strong>，即：</p>
<p><strong>外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。</strong></p>
<h2 id="安装第三方模块">安装第三方模块</h2>
<p>在Python中，安装第三方模块，是通过<strong>包管理工具pip</strong>完成的。</p>
<p>如果正在使用Mac或Linux，安装pip本身这个步骤就可以跳过了。</p>
<p>如果正在使用Windows，请参考安装Python一节的内容，确保安装时勾选了pip和Add python.exe to Path。</p>
<p>在命令提示符窗口下尝试运行pip，如果Windows提示未找到命令，可以重新运行安装程序添加pip。</p>
<p>注意：Mac或Linux上有可能并存Python 3.x和Python 2.x，<strong>因此对应的pip命令是pip3</strong>。</p>
<p>例如，我们要安装一个第三方库——Python Imaging Library，这是Python下非常强大的处理图像的工具库。不过，PIL目前只支持到Python 2.7，并且有年头没有更新了，因此，基于PIL的Pillow项目开发非常活跃，并且支持最新的Python 3。</p>
<p>一般来说，第三方库都会在Python官方的pypi.python.org网站注册，要安装一个第三方库，必须先知道该库的名称，可以在官网或者pypi上搜索，比如Pillow的名称叫Pillow，因此，安装Pillow的命令就是：</p>
<pre><code>pip install Pillow
</code></pre>
<p>耐心等待下载并安装后，就可以使用Pillow了。</p>
<h2 id="安装常用模块">安装常用模块</h2>
<p>在使用Python时，我们经常需要用到很多第三方库，例如，上面提到的Pillow，以及MySQL驱动程序，Web框架Flask，科学计算Numpy等。用pip一个一个安装费时费力，还需要考虑兼容性。我们推荐直接使用Anaconda，这是一个基于Python的<strong>数据处理和科学计算平台</strong>，它<strong>已经内置了许多非常有用的第三方库</strong>，我们装上Anaconda，就相当于把数十个第三方模块自动安装好了，非常简单易用。</p>
<p>可以从Anaconda官网下载GUI安装包，安装包有500~600M，所以需要耐心等待下载。下载后直接安装，Anaconda会把系统Path中的python指向自己自带的Python，并且，Anaconda安装的第三方模块会安装在Anaconda自己的路径下，不影响系统已安装的Python目录。</p>
<p>安装好Anaconda后，重新打开命令行窗口，输入python，可以看到Anaconda的信息：</p>
<pre><code>│Python 3.6.3 |Anaconda, Inc.| ... on win32              │
│Type &quot;help&quot;, ... for more information.                  │
│&gt;&gt;&gt; import numpy                                        │
│&gt;&gt;&gt; _ 
</code></pre>
<p>可以尝试直接import numpy等已安装的第三方模块。</p>
<h2 id="模块搜索路径">模块搜索路径</h2>
<p>当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错：</p>
<pre><code>&gt;&gt;&gt; import mymodule
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
ImportError: No module named mymodule
</code></pre>
<p>默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，<strong>搜索路径存放在sys模块的path变量中</strong>：</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path
['', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python36.zip', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6', ..., '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages']
</code></pre>
<p>如果我们要添加自己的搜索目录，有两种方法：</p>
<ol>
<li><strong>直接修改sys.path</strong>，添加要搜索的目录：</li>
</ol>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path.append('/Users/michael/my_py_scripts')
</code></pre>
<p>这种方法是<strong>在运行时修改，运行结束后失效</strong>。</p>
<ol start="2">
<li>设置环境变量PYTHONPATH，该环境变量的内容会被<strong>自动添加到模块搜索路径中</strong>。设置方式与设置Path环境变量类似。注意只需要添加你自己的搜索路径，<strong>Python自己本身的搜索路径不受影响</strong>。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python - 函数式编程]]></title>
        <id>https://lixin-scut.github.io//post/python-han-shu-shi-bian-cheng</id>
        <link href="https://lixin-scut.github.io//post/python-han-shu-shi-bian-cheng">
        </link>
        <updated>2020-05-09T01:50:11.000Z</updated>
        <content type="html"><![CDATA[<h2 id="函数式编程">函数式编程</h2>
<p>函数是Python内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。</p>
<p>而函数式编程Functional Programming，虽然也可以归结到<strong>面向过程</strong>的程序设计，但其思想<strong>更接近数学计算</strong>。</p>
<p>对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。</p>
<p>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。</p>
<p>函数式编程的一个特点就是，<strong>允许把函数本身作为参数传入另一个函数</strong>，还<strong>允许返回一个函数</strong>！</p>
<p>Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。</p>
<h2 id="高阶函数">高阶函数</h2>
<h3 id="变量可以指向函数">变量可以指向函数</h3>
<p>函数本身也可以赋值给变量，即：变量可以指向函数。<br>
变量f现在已经指向了abs函数本身。直接调用abs()函数和调用变量f()完全相同。</p>
<pre><code>&gt;&gt;&gt; f = abs
&gt;&gt;&gt; f
&lt;built-in function abs&gt;

&gt;&gt;&gt; f(-10)
10
</code></pre>
<h3 id="函数名也是变量">函数名也是变量</h3>
<p>函数名其实就是指向函数的变量！对于abs()这个函数，完全可以把函数名abs看成变量，它指向一个可以计算绝对值的函数！</p>
<p>如果把abs指向其他对象，会有什么情况发生？</p>
<pre><code>&gt;&gt;&gt; abs = 10
&gt;&gt;&gt; abs(-10)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: 'int' object is not callable
</code></pre>
<p>把abs指向10后，就无法通过abs(-10)调用该函数了！因为abs这个变量已经不指向求绝对值函数而是指向一个整数10！</p>
<p>当然实际代码绝对不能这么写，这里是为了说明函数名也是变量。要恢复abs函数，请重启Python交互环境。</p>
<p>注：由于abs函数实际上是定义在import builtins模块中的，所以要让修改abs变量的指向在其它模块也生效，要用import builtins; builtins.abs = 10。</p>
<h3 id="传入函数">传入函数</h3>
<p>既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。</p>
<p>编写高阶函数，就是让<strong>函数的参数能够接收别的函数</strong>。</p>
<p>一个最简单的高阶函数：</p>
<pre><code>def add(x, y, f):
    return f(x) + f(y)
</code></pre>
<p>当我们调用add(-5, 6, abs)时，参数x，y和f分别接收-5，6和abs，根据函数定义，我们可以推导计算过程为：</p>
<pre><code>x = -5
y = 6
f = abs
f(x) + f(y) ==&gt; abs(-5) + abs(6) ==&gt; 11
return 11
</code></pre>
<h2 id="mapreduce">map/reduce</h2>
<h3 id="map">map</h3>
<p>map()函数接收两个参数，一个是函数，一个是<strong>Iterable</strong>，map将传入的函数依次作用到序列的每个元素，并把结果作为<strong>新的Iterator</strong>返回。</p>
<p>举例说明，比如我们有一个函数f(x)=x^2，要把这个函数作用在一个list [1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map()实现如下：</p>
<pre><code>&gt;&gt;&gt; def f(x):
...     return x * x
...
&gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
# 注意list(r) 操作，把一个Iterator直接变为list
&gt;&gt;&gt; list(r) 
[1, 4, 9, 16, 25, 36, 49, 64, 81]
</code></pre>
<p>map()传入的第一个参数是f，即函数对象本身。由于结果r是一个Iterator，Iterator是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list。</p>
<p>对比循环操作，map()作为高阶函数，事实上它<strong>把运算规则抽象了</strong>，因此，我们不但可以计算简单的f(x)=x2，还可以<strong>计算任意复杂的函数</strong></p>
<h3 id="reduce">reduce</h3>
<p>reduce把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上，这个函数必须接收两个参数，reduce把<strong>结果继续和序列的下一个元素做累积计算</strong>，其效果就是：</p>
<pre><code>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
</code></pre>
<p>比方说对一个序列求和，就可以用reduce实现：</p>
<pre><code>&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; def add(x, y):
...     return x + y
...
&gt;&gt;&gt; reduce(add, [1, 3, 5, 7, 9])
25
# 当然求和运算可以直接用Python内建函数sum()，没必要动用reduce
</code></pre>
<p>再比如要把序列[1, 3, 5, 7, 9]变换成整数13579，reduce就可以派上用场：</p>
<pre><code>&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; def fn(x, y):
...     return x * 10 + y
...
&gt;&gt;&gt; reduce(fn, [1, 3, 5, 7, 9])
13579
</code></pre>
<p>如果考虑到字符串str也是一个序列，对上面的例子稍加改动，配合map()，我们就可以写出把str转换为int的函数：</p>
<pre><code>&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; def fn(x, y):
...     return x * 10 + y
...
&gt;&gt;&gt; def char2num(s):
...     digits = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}
...     return digits[s]
...
&gt;&gt;&gt; reduce(fn, map(char2num, '13579'))
13579
</code></pre>
<p>整理成一个str2int的函数就是：</p>
<pre><code>from functools import reduce

DIGITS = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}

def str2int(s):
    def fn(x, y):
        return x * 10 + y
    def char2num(s):
        return DIGITS[s]
    return reduce(fn, map(char2num, s))
</code></pre>
<p>还可以用lambda函数进一步简化成：</p>
<pre><code>from functools import reduce

DIGITS = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}

def char2num(s):
    return DIGITS[s]

def str2int(s):
    return reduce(lambda x, y: x * 10 + y, map(char2num, s))
</code></pre>
<p><strong>个人代码练习</strong><br>
利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：['adam', 'LISA', 'barT']，输出：['Adam', 'Lisa', 'Bart']：</p>
<pre><code>def normalize(name):
    name = name.lower()
    return name[0].upper() + name[1:]
		
# 测试:
L1 = ['adam', 'LISA', 'barT']
L2 = list(map(normalize, L1))
print(L2)
# ['Adam', 'Lisa', 'Bart'] 
</code></pre>
<p>注意：</p>
<ol>
<li>不可以name[i] = name[i].lower() 的操作，因为string（区别于list）是一种不可变的数据类型，必须对name整体进行赋值，使用下标操作返回的是类似于右值</li>
<li>name = name.lower()中不能缺少前面的name</li>
</ol>
<p>编写一个prod()函数，可以接受一个list并利用reduce()求积：</p>
<pre><code># -*- coding: utf-8 -*-
from functools import reduce

def sums(lhs, rhs):
    return lhs * rhs

def prod(L):
    return reduce(sums, L)
</code></pre>
<p>注意：</p>
<ol>
<li>一定要记得return 否则赋值就会变为none</li>
</ol>
<h2 id="filter">filter</h2>
<p>Python内建的filter()函数用于过滤序列。</p>
<p>和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数<strong>依次作用于每个元素</strong>，然后根据<strong>返回值是True还是False</strong>决定<strong>保留还是丢弃该元素</strong>。</p>
<p>filter()的作用是从一个序列中筛出符合条件的元素。由于filter()使用了惰性计算，所以只有在取filter()结果的时候，才会真正筛选并每次返回下一个筛出的元素。</p>
<p>例如，在一个list中，<strong>删掉偶数，只保留奇数</strong>，可以这么写：</p>
<pre><code>def is_odd(n):
    return n % 2 == 1

list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))
#结果: [1, 5, 9, 15]
</code></pre>
<p>把一个序列中的空字符串删掉，可以这么写：</p>
<pre><code>def not_empty(s):
    return s and s.strip()

list(filter(not_empty, ['A', '', 'B', None, 'C', '  ']))
#结果: ['A', 'B', 'C']
</code></pre>
<p>可见用filter()这个高阶函数，关键在于<strong>正确实现一个“筛选”函数</strong>。</p>
<p>注意到filter()函数返回的是一个<strong>Iterator</strong>，也就是一个<strong>惰性序列</strong>，所以要强迫filter()完成计算结果，需要用<strong>list()函数获得所有结果并返回list</strong>。</p>
<p><strong>个人代码练习</strong><br>
回数是指从左向右读和从右向左读都是一样的数，例如12321，909。请利用filter()筛选出回数：</p>
<pre><code>def is_palindrome(x):
    if(x &lt; 0 or (x % 10 == 0 and x != 0)) :
        return False
    temp = 0
    while(temp &lt; x):
        temp = temp * 10 + x % 10
        x //= 10
    return temp == x or temp // 10 == x
		
		# 测试:
output = filter(is_palindrome, range(1, 1000))
print('1~1000:', list(output))
if list(filter(is_palindrome, range(1, 200))) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191]:
    print('测试成功!')
else:
    print('测试失败!')
</code></pre>
<p>注意</p>
<ol>
<li>注意除法的区别！！！单个除号是精确除，返回的是浮点数，必须用双除号</li>
</ol>
<h2 id="sorted">sorted</h2>
<p>排序算法</p>
<p>排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是<strong>比较两个元素的大小</strong>。<br>
如果是数字，我们可以直接比较，但如果是<strong>字符串或者两个dict</strong>直接比较数学上的大小是没有意义的，因此，比较的过程<strong>必须通过函数抽象出来</strong>。</p>
<p>Python内置的sorted()函数就可以对list进行排序：</p>
<pre><code>&gt;&gt;&gt; sorted([36, 5, -12, 9, -21])
[-21, -12, 5, 9, 36]
</code></pre>
<p>此外，sorted()函数也是一个高阶函数，它还可以<strong>接收一个key函数</strong>来实现<strong>自定义的排序</strong>，例如按绝对值大小排序：</p>
<pre><code>&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs)
[5, 9, -12, -21, 36]
</code></pre>
<p>key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。对比原始的list和经过key=abs处理过的list：</p>
<pre><code>list = [36, 5, -12, 9, -21]

keys = [36, 5,  12, 9,  21]
</code></pre>
<p>然后sorted()函数<strong>按照keys进行排序</strong>，并<strong>按照对应关系返回list相应的元素</strong>：</p>
<pre><code>keys排序结果 =&gt; [5, 9,  12,  21, 36]
                |  |    |    |   |
最终结果     =&gt; [5, 9, -12, -21, 36]
</code></pre>
<p>我们再看一个字符串排序的例子：</p>
<pre><code>&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'])
['Credit', 'Zoo', 'about', 'bob']
</code></pre>
<p>默认情况下，对字符串排序，是按照<strong>ASCII的大小</strong>比较的，<strong>由于'Z' &lt; 'a'，结果，大写字母Z会排在小写字母a的前面。</strong></p>
<p>现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能用一个key函数把字符串映射为忽略大小写排序即可。忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。</p>
<p>这样，我们给sorted传入key函数，即可实现忽略大小写的排序：</p>
<pre><code>&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower)
['about', 'bob', 'Credit', 'Zoo']
</code></pre>
<p>要进行反向排序，不必改动key函数，可以传入第三个参数reverse=True：</p>
<pre><code>&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)
['Zoo', 'Credit', 'bob', 'about']
</code></pre>
<p>从上述例子可以看出，高阶函数的抽象能力是非常强大的，而且，核心代码可以保持得非常简洁。</p>
<h3 id="小结">小结</h3>
<p>sorted()也是一个高阶函数。用sorted()排序的关键在于实现一个映射函数。</p>
<p><strong>个人代码联系</strong><br>
假设我们用一组tuple表示学生名字和成绩：</p>
<p>L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]<br>
请用sorted()对上述列表分别按名字排序：</p>
<pre><code>#-*- coding: utf-8 -*-

L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]

def by_name(t):
    return t[0]
		
L2 = sorted(L, key=by_name)
print(L2)

# [('Adam', 92), ('Bart', 66), ('Bob', 75), ('Lisa', 88)] 
</code></pre>
<p>再按成绩从高到低排序：</p>
<pre><code>#-*- coding: utf-8 -*-

L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]

def by_score(t):
    return -t[1]
    
L2 = sorted(L, key=by_score)
print(L2)

# [('Adam', 92), ('Lisa', 88), ('Bob', 75), ('Bart', 66)] 
</code></pre>
<h2 id="返回函数">返回函数</h2>
<h3 id="函数作为返回值">函数作为返回值</h3>
<p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</p>
<p>我们来实现一个可变参数的求和。通常情况下，求和的函数是这样定义的：</p>
<pre><code>def calc_sum(*args):
    ax = 0
    for n in args:
        ax = ax + n
    return ax
</code></pre>
<p>但是，如果<strong>不需要立刻求和</strong>，而是在<strong>后面的代码中，根据需要再计算</strong>，可以不返回求和的结果，而是<strong>返回求和的函数</strong>：</p>
<pre><code>def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax
    return sum
</code></pre>
<p>当我们调用lazy_sum()时，<strong>返回的并不是求和结果，而是求和函数</strong>：</p>
<pre><code>&gt;&gt;&gt; f = lazy_sum(1, 3, 5, 7, 9)
&gt;&gt;&gt; f
&lt;function lazy_sum.&lt;locals&gt;.sum at 0x101c6ed90&gt;
</code></pre>
<p><strong>调用函数f时，才真正计算求和的结果</strong>：</p>
<pre><code>&gt;&gt;&gt; f()
25
</code></pre>
<p>在函数lazy_sum中又定义了函数sum，并且，内部函数sum<strong>可以引用外部函数lazy_sum的参数和局部变量</strong>，当lazy_sum返回函数sum时，<strong>相关参数和变量都保存在返回的函数</strong>中，这种称为“<strong>闭包（Closure）</strong>”的程序结构拥有极大的威力。</p>
<p>注意，调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数：</p>
<pre><code>&gt;&gt;&gt; f1 = lazy_sum(1, 3, 5, 7, 9)
&gt;&gt;&gt; f2 = lazy_sum(1, 3, 5, 7, 9)
&gt;&gt;&gt; f1==f2
False
</code></pre>
<p>f1()和f2()的调用结果互不影响。</p>
<h3 id="闭包">闭包</h3>
<p>注意到返回的函数在其定义内部引用了局部变量args，所以，当一个函数返回了一个函数后，<strong>其内部的局部变量还被新函数引用</strong>。</p>
<p>另一个需要注意的问题是，返回的函数<strong>并没有立刻执行</strong>，而是<strong>直到调用了f()才执行</strong>。</p>
<p>例子如下：</p>
<pre><code>def count():
    fs = []
    for i in range(1, 4):
        def f():
             return i*i
        fs.append(f)
    return fs

f1, f2, f3 = count()
</code></pre>
<p>在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都返回了。</p>
<p>可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是：</p>
<pre><code>&gt;&gt;&gt; f1()
9
&gt;&gt;&gt; f2()
9
&gt;&gt;&gt; f3()
9
</code></pre>
<p>结果全部都是9，原因在于返回的函数引用了变量i，但它<strong>并非立刻执行</strong>。<strong>等到3个函数都返回时，它们所引用的变量i已经变成了3</strong>，因此最终结果为9。</p>
<p><strong>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</strong></p>
<p>如果一定要引用循环变量，需要再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p>
<pre><code> def count():
    def f(j):
        def g():
            return j*j
        return g
    fs = []
    for i in range(1, 4):
        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()
    return fs

&gt;&gt;&gt; f1, f2, f3 = count()
&gt;&gt;&gt; f1()
1
&gt;&gt;&gt; f2()
4
&gt;&gt;&gt; f3()
9
</code></pre>
<p><strong>个人代码练习</strong><br>
利用闭包返回一个计数器函数，每次调用它返回递增整数：</p>
<pre><code>def createCounter():
    i = 0
    def counter():
        nonlocal i
        i = i + 1
        return i
    return counter
		
# 测试:
counterA = createCounter()
print(counterA(), counterA(), counterA(), counterA(), counterA()) # 1 2 3 4 5
counterB = createCounter()
if [counterB(), counterB(), counterB(), counterB()] == [1, 2, 3, 4]:
    print('测试通过!')
else:
    print('测试失败!')
</code></pre>
<p>注意！遇到了今天说到的问题，但是很奇葩，前面其实也有提及</p>
<blockquote>
<p>在函数lazy_sum中又定义了函数sum，并且，内部函数sum<strong>可以引用外部函数lazy_sum的参数和局部变量</strong>，当lazy_sum返回函数sum时，<strong>相关参数和变量都保存在返回的函数</strong>中，这种称为“<strong>闭包（Closure）</strong>”的程序结构拥有极大的威力。</p>
</blockquote>
<p>wtf？难道i不算外部函数的局部变量吗？<br>
我自己的解决方法：必须在内部函数加上 nonlocal i 才能正常运行，否则就会报错说i这个局部变量在定义前就被使用了</p>
<p>解决方法总结：<br>
&quot;&quot;&quot; 实现计数器统计函数调用次数 &quot;&quot;&quot;</p>
<pre><code>def createCounter():
    &quot;&quot;&quot; 方法1：list的原理类似C语言的数组和指针，不受作用域影响
    直接改变值对应的地址。也就是说不是改变值的引用，而是永久改变值本身 &quot;&quot;&quot;
    L=[0]
    def counter():
        L[0]+=1
        return L[0]
    return counter

def createCounter():
    &quot;&quot;&quot; 方法2：使用global扩大变量作用域 &quot;&quot;&quot;
    global n
    n=0
    def counter():
        global n
        n+=1
        return n
    return counter

def createCounter():
    &quot;&quot;&quot; 方法3：使用nonlocal声明内层函数变量，使其能修改外层函数的变量 &quot;&quot;&quot;
    n=0
    def counter():
        nonlocal n
        n+=1
        return n
    return counter

def createCounter():
    &quot;&quot;&quot; 方法4：使用生成器在外层函数创建生成器对象，在内层函数调用next() &quot;&quot;&quot;
    def count_generator():
        n=0
        while True:
            n+=1
            yield n
    # 调用生成器函数创建生成器对象一定要在外层函数进行
    temp=count_generator()

    def get_num():
        return next(temp)
    return get_num
</code></pre>
<p>网友解释一：</p>
<blockquote>
<p>声明变量i<strong>非内部函数的局部变量</strong>，否则内部函数只能引用，一旦修改会视其为局部变量，报错“局部变量在赋值之前被引用”。</p>
</blockquote>
<p>网友解释二：</p>
<blockquote>
<p>因为python中一切皆是对象，我们平时使用的a=1，s=‘adada’这些‘赋值’语句实际上是在内存中开辟了一块空间存储了1和‘adada’这两个对象（包括其属性和方法）后将内存空间的地址赋值给了a和s（为了方便，我们称呼它们为引用）。而在之后使用a和s时其实就是根据内存空间找到对应对象，调用其中存储的内容<br>
既然如此，一个方法也可以单独存放在内存空间内作为一个对象被引用。而这就是高阶函数和返回函数讨论的问题。<br>
高阶函数是<strong>将方法作为参数传入其他方法中去使用</strong>，比如sorted中的key参数，map、reduce中的函数参数<br>
而返回函数则是将方法（为了方便称呼，我们叫它内函数）作为一个方法（外函数）的返回值<br>
根据C语言基础我们可以知道当一个方法调用return时，会释放掉其内存（准确的说是函数栈）空间，则该函数的局部变量（包括函数体内定义和传入的参数）都会被释放而无法正常访问。但是假如我们的内函数需要使用外函数的局部变量，那就<strong>需要把内函数使用的局部变量‘绑定’给内函数</strong>，从而在外函数被释放的前提下内函数的使用也不会受到影响。楼下有一层总结了四种方法，其中方法四就是利用了这一点，因为生成器被内函数使用绑定，所以外函数释放后也无所谓。<br>
但是，生成器占据的资源相较于1个数据肯定要大，而我们又想节约资源实现计数该怎么办？---我们需要修改外函数的局部变量<br>
重点来了！！！！！！<br>
试想外部有语句 a = 0<br>
内部有语句 a = a +1<br>
python不像c语言有定义语句，我<strong>怎么知道内部的语句究竟是赋值外部变量还是定义内部变量</strong>？？？？？？<br>
（ps：c语言的情况下，外部int a=0，内部若是int a =1则覆盖外部，若是修改外部则直接赋值语句a=a+1.所以不存在歧义）<br>
为了解决这个问题，<strong>存在nonlocal关键字，nonlocal标记的赋值语句代表我这是赋值外部（第一层外部），没有标记的代表定义内部变量（这是方法3）</strong><br>
而假如我们定义了多层，func1包含func2，fun2包含func3，func 3想修改 func1的变量，（<strong>nonlocal标记的赋值语句指的是func2中的变量修改，因此没用</strong>）。所以我们想出了一个办法，创建一个<strong>全局标记global</strong>，凡是被<strong>global声明的变量就是指在内存空间内有独立空间的变量</strong>，<strong>没有被声明的就是局部的</strong>，从而解决跨层修改变量的问题（这是方法2）<br>
最后谈谈方法一（使用列表），列表的实现是可变长度的数组（详见https://www.jb51.net/article/164319.htm）<br>
我觉得能用这种方法应该是因为列表的定义L=[0]和列表的赋值L[x]=y语句不同，所以不存在歧义的才可以如此使用。感觉和所谓的列表实现类似C语言数组（指针）所以能够无视作用域没有关系（在python面向对象来看，所有的引用其实都是指向内存区域的指针，但不是所有类型的引用都可以无视作用域）</p>
</blockquote>
<p>网友解释三：</p>
<blockquote>
<p>个人感觉评论区的各位大手子都很强，总结得都很好，但是都忽略了一个底层问题，为什么L[0]可以作为一个全局变量，而L不行会报错。<br>
以下分析灵感来源于这篇文章：https://zhuanlan.zhihu.com/p/34395671，只是自己一点理解，可能有很多不对的地方，给大家提供一点方向。<br>
L[0]作为一个<strong>可变类型list对象</strong>，对这个对象执行操作后，比如 L[0] = L[0] + 1，它的内存地址是不变的，这个操作的实质是更改了在这个内存地址的这个list的第一个值，使其加一。<br>
而L作为一个<strong>不可变类型int对象</strong>，当对其赋值时，实际是把这个对象指向这个int值的内存地址。例如先赋初值 L = 0，然后使 L = L + 1，这个操作的整个过程实质是：将L指向int值0的内存地址；运算L + 1为int值1，将L指向int值1的内存地址。<br>
可变类型的实质就是引用的地址不变，该地址上存储的值可变。<br>
不可变类型的实质就是引用的地址可以变，但任意引用地址存储的值不可改变。<br>
这样设定的用意我大胆猜测是为了合理分配内存的存储和读写资源，设定一部分可以复用的固定数据让其存储在一个且每个固定数据一一对应只有一个的地址，这样不管有多少变量的值需要等于这个数据，其最终都指向这个地址，只占用一个存储单元，这就是不可变类型会指向的地址。而另一部分则满足变量所引用的地址不变，但是值需要随时更新的需求，这样不管这个变量的值需要存在多少种情况或者如何改变，其地址永远保持不变，这就是可变类型会指向的地址。<br>
看着可能会很混乱，实质上，<br>
可变类型就是<strong>一个变量只能对应一个地址</strong>，但<strong>这个地址可以对应多个值</strong>。而不可变类型就是<strong>一个变量可以对应多个地址</strong>，但<strong>每个地址只能对应一个值</strong>。<br>
再举一个帮助理解的例子，<br>
a = 1 #没有发现已经存在的存储int值1的地址，创建存储int值1的地址A，将a指向A<br>
b = 1 #发现int值1存在于地址A，将b指向A<br>
x = [1,2,3] #在地址X创建list [1,2,3] ，将x指向X<br>
y = [1,2,3] #在地址Y创建list [1,2,3] ，将y指向Y<br>
print(id(a),id(b),id(a)==id(b)) # True<br>
print(id(x),id(y),id(x)==id(y)) # False<br>
结果是a和b的地址一致，而x和y的地址是不一致的，可以看出虽然x和y的值是一样的，但由于都是list类型，可变类型，那么 x = [1,2,3] 和 y = [1,2,3] 这两个操作都属于创建一个新的list，不管他们的值是否一样。list的赋值都是一个创建然后指向的过程。而 a = 1 和 b = 1的情况，如注释中所述，是一个先寻找是否存在存储该int值的地址，有则指向该地址，没有的话，则创建一个存储该int值的地址，然后指向该地址。两者的赋值语句的逻辑是截然不同的，这是最本质上的差别。<br>
接下来，重点来了，<br>
python中向函数传递参数只能是<strong>引用传递，表示把它的地址都传进去了</strong>，而非值传递。<br>
意思很直观，在调用函数传递参数时，传递的是引用，直白的就是传递对象的内存地址。<br>
那么，在上面描述的情况中，每次调用主函数返回子函数时，由于return命令的执行，该主函数使用的临时变量的内存都要释放，然而由于返回的子函数使用了主函数的临时变量，这个变量会和子函数绑定，存入该子函数的内存空间。<br>
当使用L作为这个临时变量或者说传递对象的时候，return子函数这个操作执行后，返回的子函数中的内存空间中存储的L实质上是L指向的内存地址，当进行 <strong>L = L + 1</strong>这个操作时，由于L现在代表的是一个引用，是一个内存地址，那么实质上的操作就是提取L指向的内存地址中的值；运算该值 + 1的结果；将L指向该结果的内存地址，这个操作需要一个随程序运行更新的起点地址，不然就是一个无法确定运行环境的闭包，而这是与闭包本身的定义相违背的。由于没有设定L为全局变量，所以python就会将这个L视为子函数的局部变量，在子函数内部寻找起点地址，然而又由于未提前在子函数内赋初值，进而报错“局部变量在赋值之前被引用”。<br>
这里大胆猜测，在使用global命令后，python将其置入一个包含所有global变量的总list或者其他可变类型的变量中，然后通过这个变量的变量加上位置实现其调用，原理与L[0]相同。<br>
而当L[0]作为一个临时变量或者说传递对象的时候，由于上文已经讲过的list对象操作的实质，在传进去的这个L[0]所引用的地址是可以直接进行值的改变的，那么则识别为全局变量，return执行后，子函数内存空间保存的是一个确定的指令，对L[0]所在内存地址进行加一。<br>
这个角度的理解方法总结来说，就是可变对象和不可变对象的实质，以及python中函数参数传递和临时变量存储在子函数内存空间中的实质。<br>
或者也有另一个角度的理解方法。<br>
当使用L作为这个临时变量或者说传递对象的时候，return子函数这个操作执行后，在子函数内部，由于并没有声明L是一个全局变量，L所进行的操作也不代表其是一个可变类型的全局变量。<br>
此处又有另外一个知识点，关于<strong>根据操作判断变量类型的逻辑</strong>，参考<br>
https://blog.csdn.net/zsdxqsjxlomer/article/details/78381626?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3<br>
https://blog.csdn.net/bigxuyang/article/details/77877935<br>
这两篇文章，会得到一个比较清晰的认知。<br>
<strong>关键点在于  L = [1,2,3]  这个操作在子函数内没有提前声明L是一个全局变量，纵然L的操作代表其是一个可变类型的变量，但该操作并没有触发python认定其为一个全局变量，则  L = [1,2,3]  这个操作相当于创建一个list类型的名为L的局部变量，而并没有调用之前创建的全局变量L。而  L.append 或者  L[0] = L[0] + 1 这类的list类型专属操作（实质是list这个class的method或者attribute），由于子函数内部在此操作前并没有创建L这个变量，那么触发python认定其为一个可变类型的全局变量，就会往外部寻找，则寻找到之前创建的全局变量L。</strong><br>
接上文，那么L就会被认定为一个<strong>局部变量</strong>，然而L并没有被赋初值，此时报错“局部变量在赋值之前被引用”。<br>
而当L[0]作为一个临时变量或者说传递对象的时候，当执行 L[0] = L[0] + 1这个操作，由于子函数内部在此操作前并没有创建L这个变量，那么触发python认定其为一个可变类型的全局变量，就会往外部寻找，则寻找到之前创建的全局变量L。<br>
这个角度的理解方法总结来说，就是python在闭包函数返回子函数时，判定临时变量是否为全局变量的逻辑。当没有声明变量为全局变量时，只有进行了触发python判定其为<strong>可变类型的全局变量</strong>的操作，才会去外部寻找该变量。所以，当执行 L = L + 1这个操作时，在没有声明L为全局变量的情况下，python是不会去外部寻找的，那么，又因为L并没有在子函数内的开头部分创建，必定会报错“局部变量在赋值之前被引用”。<br>
虽然说了这么多，但自我感觉也有很多地方有问题，发出来抛砖引玉，与大家共同讨论进步，欢迎大家指正。<br>
更新：值小的int会一直保持固定的地址。<br>
有几篇文章解释了相关问题，贴出来供大家参考一下。<br>
https://blog.csdn.net/WSBruce/article/details/79234389?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1<br>
https://blog.csdn.net/fragmentalice/article/details/81363494?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2<br>
https://blog.csdn.net/as480133937/article/details/87305247?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3</p>
</blockquote>
<h2 id="匿名函数">匿名函数</h2>
<p>在传入函数时，可以不需要显式地定义函数，直接传入匿名函数更方便。</p>
<p>在Python中，对匿名函数提供了有限支持。还是以map()函数为例，计算f(x)=x2时，除了定义一个f(x)的函数外，还可以直接传入匿名函数：</p>
<pre><code>&gt;&gt;&gt; list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
[1, 4, 9, 16, 25, 36, 49, 64, 81]
</code></pre>
<p>通过对比可以看出，匿名函数lambda x: x * x实际上就是：</p>
<pre><code>def f(x):
    return x * x
</code></pre>
<p>关键字lambda表示匿名函数，冒号前面的x表示函数参数。</p>
<p>匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。</p>
<p>用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数：</p>
<pre><code>&gt;&gt;&gt; f = lambda x: x * x
&gt;&gt;&gt; f
&lt;function &lt;lambda&gt; at 0x101c6ef28&gt;
&gt;&gt;&gt; f(5)
25
</code></pre>
<p>同样，也可以把匿名函数作为返回值返回，比如：</p>
<pre><code>def build(x, y):
    return lambda: x * x + y * y
</code></pre>
<p>注意不用在：前写参数的情况</p>
<ol>
<li>lambda本身不需要传入参数（也就是：后面的表达式里用不到：前的参数）</li>
<li>只使用def中已经定义的形参</li>
</ol>
<h2 id="装饰器">装饰器</h2>
<p>由于函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数</p>
<pre><code>&gt;&gt;&gt; def now():
...     print('2015-3-25')
...
&gt;&gt;&gt; f = now
&gt;&gt;&gt; f()
2015-3-25
</code></pre>
<p>函数对象有一个__name__属性，可以拿到函数的名字：</p>
<pre><code>&gt;&gt;&gt; now.__name__
'now'
&gt;&gt;&gt; f.__name__
'now'
</code></pre>
<p>如锅要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now()函数的定义，这种<strong>在代码运行期间动态增加功能</strong>的方式，称之为“装饰器”（Decorator）。</p>
<p>本质上，decorator就是一个<strong>返回函数的高阶函数</strong>。所以，我们要定义一个能打印日志的decorator，可以定义如下：</p>
<pre><code>def log(func):
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
</code></pre>
<p>观察上面的log，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。我们要<strong>借助Python的@语法</strong>，<strong>把decorator置于函数的定义处</strong>：</p>
<pre><code>@log
def now():
    print('2015-3-25')
</code></pre>
<p>调用now()函数，不仅会运行now()函数本身，还会在运行now()函数前打印一行日志：</p>
<pre><code>&gt;&gt;&gt; now()
call now():
2015-3-25
</code></pre>
<p>把@log放到now()函数的定义处，相当于执行了语句：</p>
<pre><code>now = log(now)
</code></pre>
<p>由于log()是一个decorator，返回一个函数，所以，原来的now()函数仍然存在，只是现在同名的now变量指向了新的函数，于是调用now()将执行新函数，即在log()函数中返回的<strong>wrapper()函数</strong>。</p>
<p>wrapper()函数的参数定义是<code>(*args, **kw)</code>，因此，wrapper()函数可以<strong>接受任意参数的调用</strong>。在wrapper()函数内，首先打印日志，再紧接着调用原始函数。</p>
<p>如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本：</p>
<pre><code>def log(text):
    def decorator(func):
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
</code></pre>
<p>这个3层嵌套的decorator用法如下：</p>
<pre><code>@log('execute')
def now():
    print('2015-3-25')
</code></pre>
<p>执行结果如下：</p>
<pre><code>&gt;&gt;&gt; now()
execute now():
2015-3-25
</code></pre>
<p>和两层嵌套的decorator相比，3层嵌套的效果是这样的：</p>
<pre><code>&gt;&gt;&gt; now = log('execute')(now)
</code></pre>
<p>我们来剖析上面的语句</p>
<ol>
<li>首先<strong>执行log('execute')</strong></li>
<li><strong>返回的是decorator函数</strong>，再调用返回的函数，参数是now函数</li>
<li>返回值<strong>最终是wrapper函数</strong>。</li>
</ol>
<p>以上两种decorator的定义都没有问题，但还差最后一步。因为函数也是对象，它有__name__等属性，但经过decorator装饰之后的函数，<strong>它们的name已经从原来的'now'变成了'wrapper'</strong>：</p>
<pre><code>&gt;&gt;&gt; now.__name__
'wrapper'
</code></pre>
<p>因为返回的那个wrapper()函数名字就是'wrapper'，所以，<strong>需要把原始函数的name等属性复制到wrapper()函数中</strong>，<strong>否则，有些依赖函数签名的代码执行就会出错</strong>。</p>
<p>不需要编写<code>wrapper.__name__ = func.__name__</code>这样的代码，Python内置的<strong>functools.wraps</strong>就是干这个事的，所以，一个完整的decorator的写法如下：</p>
<pre><code>import functools

def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
</code></pre>
<p>或者针对带参数的decorator：</p>
<pre><code>import functools

def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
</code></pre>
<p>import functools是导入functools模块，在定义wrapper()的前面加上@functools.wraps(func)即可。</p>
<h2 id="小结-2">小结</h2>
<p>在面向对象（OOP）的设计模式中，decorator被称为装饰模式。OOP的装饰模式需要通过继承和组合来实现，而Python除了能支持OOP的decorator外，<strong>直接从语法层次支持decorator</strong>。Python的decorator<strong>可以用函数实现，也可以用类实现</strong>。</p>
<p>decorator可以增强函数的功能，定义起来虽然有点复杂，但使用起来非常灵活和方便。</p>
<h2 id="偏函数">偏函数</h2>
<p>Python的functools模块提供了很多有用的功能，其中一个就是偏函数（Partial function）。要注意，这里的偏函数和数学意义上的偏函数不一样。</p>
<p>在介绍函数参数的时候，通过设定参数的默认值，可以降低函数调用的难度。而偏函数也可以做到这一点。举例如下：</p>
<p>int()函数可以把字符串转换为整数，当仅传入字符串时，int()函数默认按十进制转换：</p>
<pre><code>&gt;&gt;&gt; int('12345')
12345
</code></pre>
<p>但<strong>int()函数还提供额外的base参数，默认值为10</strong>。如果<strong>传入base参数，就可以做N进制的转换</strong>：</p>
<pre><code>&gt;&gt;&gt; int('12345', base=8)
5349
&gt;&gt;&gt; int('12345', 16)
74565
</code></pre>
<p>假设要转换大量的二进制字符串，每次都传入int(x, base=2)非常麻烦，于是，我们想到，可以定义一个int2()的函数，默认把base=2传进去：</p>
<pre><code>def int2(x, base=2):
    return int(x, base)
</code></pre>
<p>这样，我们转换二进制就非常方便了：</p>
<pre><code>&gt;&gt;&gt; int2('1000000')
64
&gt;&gt;&gt; int2('1010101')
85
</code></pre>
<p>functools.partial就是帮助我们<strong>创建一个偏函数的，不需要我们自己定义int2()</strong>，可以直接使用下面的代码创建一个新的函数int2：</p>
<pre><code>&gt;&gt;&gt; import functools
&gt;&gt;&gt; int2 = functools.partial(int, base=2)
&gt;&gt;&gt; int2('1000000')
64
&gt;&gt;&gt; int2('1010101')
85
</code></pre>
<p>所以，简单总结functools.partial的作用就是，<strong>把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数</strong>，调用这个新函数会更简单。</p>
<p>注意到上面的新的int2函数，<strong>仅仅是把base参数重新设定默认值为2，但也可以在函数调用时传入其他值</strong>：</p>
<pre><code>&gt;&gt;&gt; int2('1000000', base=10)
1000000
</code></pre>
<p>最后，创建偏函数时，实际上<strong>可以接收函数对象、<code>*args</code>和<code>kw</code>这3个参数</strong>，当传入：</p>
<pre><code>int2 = functools.partial(int, base=2)
</code></pre>
<p>实际上固定了int()函数的关键字参数base，也就是：</p>
<pre><code>int2('10010')
</code></pre>
<p>相当于：</p>
<pre><code>kw = { 'base': 2 }
int('10010', **kw)
</code></pre>
<p>当传入：</p>
<pre><code>max2 = functools.partial(max, 10)
</code></pre>
<p>实际上会把10作为<code>*args</code>的一部分<strong>自动加到左边</strong>，也就是：</p>
<pre><code>max2(5, 6, 7)
</code></pre>
<p>相当于：</p>
<pre><code>args = (10, 5, 6, 7)
max(*args)
</code></pre>
<p>结果为10。</p>
<h2 id="小结-3">小结</h2>
<p>当函数的参<strong>数个数太多，需要简化时</strong>，使用functools.partial可以创建一个新的函数，这个新函数可以<strong>固定住原函数的部分参数</strong>，从而在调用时更简单。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python - 高级特性]]></title>
        <id>https://lixin-scut.github.io//post/python-gao-ji-te-xing</id>
        <link href="https://lixin-scut.github.io//post/python-gao-ji-te-xing">
        </link>
        <updated>2020-05-08T11:33:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="提取容器的部分元素">提取容器的部分元素</h2>
<h3 id="list">list</h3>
<p>取一个list部分元素是非常常见的操作，Python提供了切片（Slice）操作符<br>
取前3个元素，用一行代码就可以完成切片：</p>
<pre><code>&gt;&gt;&gt; L[0:3]
['Michael', 'Sarah', 'Tracy']
</code></pre>
<p>L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。</p>
<p>注意区间是左闭右开，提取的元素数量刚好是右区间减去左区间</p>
<p>如果第一个索引是0，还可以省略：</p>
<pre><code>&gt;&gt;&gt; L[:3]
['Michael', 'Sarah', 'Tracy']
</code></pre>
<p>注意Python支持L[-1]取倒数第一个元素，那么同样支持<strong>倒数切</strong>片，试试：</p>
<pre><code>&gt;&gt;&gt; L[-2:]
['Bob', 'Jack']
&gt;&gt;&gt; L[-2:-1]
['Bob']
</code></pre>
<p><strong>注意倒数第一个元素的索引是-1。</strong></p>
<p>例子：</p>
<p><strong>提取连续元素</strong></p>
<p>前10个数：</p>
<pre><code>&gt;&gt;&gt; L[:10]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>后10个数：</p>
<pre><code>&gt;&gt;&gt; L[-10:]
[90, 91, 92, 93, 94, 95, 96, 97, 98, 99]
</code></pre>
<p>前11-20个数：</p>
<pre><code>&gt;&gt;&gt; L[10:20]
[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
</code></pre>
<p>规律间隔取值</p>
<p>前10个数，每两个取一个：</p>
<pre><code>&gt;&gt;&gt; L[:10:2]
[0, 2, 4, 6, 8]
</code></pre>
<p>所有数，每5个取一个：</p>
<pre><code>&gt;&gt;&gt; L[::5]
[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]
</code></pre>
<p>甚至什么都不写，只写[:]就可以原样复制一个list：</p>
<pre><code>&gt;&gt;&gt; L[:]
[0, 1, 2, 3, ..., 99]
</code></pre>
<h3 id="tuple">tuple</h3>
<p>tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是<strong>操作的结果仍是tuple</strong>：</p>
<pre><code>&gt;&gt;&gt; (0, 1, 2, 3, 4, 5)[:3]
(0, 1, 2)
</code></pre>
<h3 id="字符串">字符串</h3>
<p>字符串'xxx'也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是<strong>操作结果仍是字符串</strong>：</p>
<pre><code>&gt;&gt;&gt; 'ABCDEFG'[:3]
'ABC'
&gt;&gt;&gt; 'ABCDEFG'[::2]
'ACEG'
</code></pre>
<p>在很多编程语言中，针对字符串提供了很多各种截取函数（例如，substring），其实目的就是对字符串切片。Python没有针对字符串的截取函数，只需要切片一个操作就可以完成。</p>
<p><strong>个人练习代码</strong><br>
实现一个trim()函数去除字符串首尾的空格，</p>
<pre><code>def trim(s):
if len(s) == 0:
		return s
left = 0
while left &lt; len(s) and s[left] == ' ':
		left = left + 1
right = len(s) - 1
while right &gt;= 0 and s[right] == ' ':
		right = right - 1
if left &lt; right:
	 return s[left : right+1]
else:
	 return ''
</code></pre>
<h2 id="迭代">迭代</h2>
<p>给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。</p>
<p>在Python中，迭代是通过for ... in来完成的</p>
<p>Python的for循环抽象程度要高于C的for循环，因为Python的for循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上。</p>
<h3 id="无下标迭代-dict迭代">无下标迭代-dict迭代</h3>
<p>list这种数据类型虽然有下标，但很多其他数据类型是没有下标的，但是，只要是可迭代对象，无论有无下标，都可以迭代，比如dict就可以迭代：</p>
<pre><code>&gt;&gt;&gt; d = {'a': 1, 'b': 2, 'c': 3}
&gt;&gt;&gt; for key in d:
...     print(key)
</code></pre>
<p>注意，由于哈希函数的特性，dict的存储不是按照list的方式顺序排列，所以，<strong>迭代出的结果顺序很可能不一样</strong>。</p>
<p>默认情况下，<strong>dict迭代的是key</strong>。如果要<strong>迭代value</strong>，可以用<code>for value in d.values()</code>，如果要<strong>同时迭代key和value</strong>，可以用<code>for k, v in d.items()</code>。</p>
<p>判断一个对象是可迭代对象：通过collections模块的Iterable类型判断：</p>
<pre><code>&gt;&gt;&gt; from collections import Iterable
&gt;&gt;&gt; isinstance('abc', Iterable) # str是否可迭代
True
&gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代
True
&gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代
False
</code></pre>
<h3 id="下标循环">下标循环</h3>
<p>如果要对list实现类似Java那样的下标循环，可以使用Python内置的<strong>enumerate函数</strong>，可以<strong>把一个list变成索引-元素对</strong>，这样就可以在for循环中<strong>同时迭代索引和元素</strong>本身：</p>
<pre><code>&gt;&gt;&gt; for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)
...
0 A
1 B
2 C
</code></pre>
<p>上面的for循环里，同时引用了两个变量，在Python里是很常见的，比如下面的代码：</p>
<pre><code>&gt;&gt;&gt; for x, y in [(1, 1), (2, 4), (3, 9)]:
...     print(x, y)
...
1 1
2 4
3 9
</code></pre>
<p><strong>个人练习代码</strong><br>
使用迭代查找一个list中最小和最大值，并返回一个tuple：</p>
<pre><code>def findMinAndMax(L):
    if len(L) == 0:    
        return (None, None)
    max_num = L[0]
    min_num = L[0]
    for num in L:
        max_num = max(max_num, num)
        min_num = min(min_num, num)
    return (min_num, max_num)
</code></pre>
<h2 id="列表生成式">列表生成式</h2>
<p>列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来<strong>创建list的生成式</strong>。</p>
<p>例如要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))：</p>
<pre><code>&gt;&gt;&gt; list(range(1, 11))
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
</code></pre>
<p>要生成[1x1, 2x2, 3x3, ..., 10x10]<br>
列表生成式则可以用一行语句代替循环生成：</p>
<pre><code>&gt;&gt;&gt; [x * x for x in range(1, 11)]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
</code></pre>
<p>把要生成的元素x * x放到前面，后面跟for循环，就可以把list创建出来</p>
<p>for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：</p>
<pre><code>&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0]
[4, 16, 36, 64, 100]
</code></pre>
<p>还可以使用两层循环，可以生成全排列：</p>
<pre><code>&gt;&gt;&gt; [m + n for m in 'ABC' for n in 'XYZ']
['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']
</code></pre>
<ol>
<li>字符串可以<strong>直接相加</strong></li>
<li>循环<strong>可以并列</strong></li>
</ol>
<p>运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：</p>
<pre><code>&gt;&gt;&gt; import os # 导入os模块，模块的概念后面讲到
&gt;&gt;&gt; [d for d in os.listdir('.')] # os.listdir可以列出文件和目录
['.emacs.d', '.ssh', '.Trash', 'Adlm', 'Applications', 'Desktop', 'Documents', 'Downloads', 'Library', 'Movies', 'Music', 'Pictures', 'Public', 'VirtualBox VMs', 'Workspace', 'XCode']
</code></pre>
<p>for循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value：</p>
<pre><code>&gt;&gt;&gt; d = {'x': 'A', 'y': 'B', 'z': 'C' }
&gt;&gt;&gt; for k, v in d.items():
...     print(k, '=', v)
...
y = B
x = A
z = C
</code></pre>
<p>最后把一个list中所有的字符串变成小写：</p>
<pre><code>&gt;&gt;&gt; L = ['Hello', 'World', 'IBM', 'Apple']
&gt;&gt;&gt; [s.lower() for s in L]
['hello', 'world', 'ibm', 'apple']
</code></pre>
<h3 id="if-else">if ... else</h3>
<p>使用列表生成式的时候，不能在<strong>最后的if</strong>加上else：</p>
<pre><code>&gt;&gt;&gt; [x for x in range(1, 11) if x % 2 == 0]
[2, 4, 6, 8, 10]

&gt;&gt;&gt; [x for x in range(1, 11) if x % 2 == 0 else 0]
  File &quot;&lt;stdin&gt;&quot;, line 1
    [x for x in range(1, 11) if x % 2 == 0 else 0]
                                              ^
SyntaxError: invalid syntax
</code></pre>
<p>这是因为<strong>跟在for后面的if</strong>是一个筛选条件，不能带else，否则无法进行筛选</p>
<p>而把if写在for前面必须加else，否则报错：</p>
<pre><code>&gt;&gt;&gt; [x if x % 2 == 0 for x in range(1, 11)]
  File &quot;&lt;stdin&gt;&quot;, line 1
    [x if x % 2 == 0 for x in range(1, 11)]
                       ^
SyntaxError: invalid syntax
</code></pre>
<p>这是因为for前面的部分是一个表达式，它必须根据x计算出一个结果。因此，考察表达式：x if x % 2 == 0，它无法根据x计算出结果，因为缺少else，必须加上else：</p>
<pre><code>&gt;&gt;&gt; [x if x % 2 == 0 else -x for x in range(1, 11)]
[-1, 2, -3, 4, -5, 6, -7, 8, -9, 10]
上述for前面的表达式x if x % 2 == 0 else -x才能根据x计算出确定的结果。
</code></pre>
<p>可见，在一个列表生成式中，for前面的if ... else是表达式，而for后面的if是过滤条件，不能带else。</p>
<p><strong>个人代码练习</strong><br>
如果list中既包含字符串，又包含整数，由于非字符串类型没有lower()方法，需要使用内建的isinstance函数可以判断一个变量是不是字符串：</p>
<pre><code>L1 = ['Hello', 'World', 18, 'Apple', None]
L2 = [x.lower() for x in L1 if isinstance(x, str)]
</code></pre>
<p>注意没法使用lower(x) ，必须用x.lower()</p>
<h2 id="生成器">生成器</h2>
<p>受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p>
<p>所以，如果<strong>列表元素可以按照某种算法推算出来</strong>，那我们是否可以在循环的过程中<strong>不断推算出后续的元素</strong>呢？这样就<strong>不必创建完整的list</strong>，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。</p>
<h3 id="创建generator">创建generator</h3>
<p>把一个列表生成式的[]改成()，就创建了一个generator：</p>
<pre><code>&gt;&gt;&gt; L = [x * x for x in range(10)]
&gt;&gt;&gt; L
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
&gt;&gt;&gt; g = (x * x for x in range(10))
&gt;&gt;&gt; g
&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;
</code></pre>
<p>创建L和g的区别仅在于最外层的[]和()，L是一个list，而g是一个generator。</p>
<p><strong>打印generator的每一个元素</strong></p>
<p>如果要一个一个打印出来，可以通过next()函数获得generator的下一个返回值：</p>
<pre><code>&gt;&gt;&gt; next(g)
0
&gt;&gt;&gt; next(g)
1
&gt;&gt;&gt; next(g)
4
&gt;&gt;&gt; next(g)
9
&gt;&gt;&gt; next(g)
16
&gt;&gt;&gt; next(g)
25
&gt;&gt;&gt; next(g)
36
&gt;&gt;&gt; next(g)
49
&gt;&gt;&gt; next(g)
64
&gt;&gt;&gt; next(g)
81
&gt;&gt;&gt; next(g)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
StopIteration
</code></pre>
<p>generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值<br>
直到计算到最后一个元素，<strong>没有更多的元素时，抛出StopIteration的错误</strong>。</p>
<p>更便捷的方法是使用for循环，因为generator也是可迭代对象：</p>
<pre><code>&gt;&gt;&gt; g = (x * x for x in range(10))
&gt;&gt;&gt; for n in g:
...     print(n)
... 
0
1
4
9
16
25
36
49
64
81
</code></pre>
<p>由于StopIteration的错误的存在，创建了一个generator后，基本上永远不会调用next()，而是通过for循环来迭代它，不需要关心StopIteration的错误。</p>
<p><strong>定义generator的另一种方法</strong></p>
<p>如果一个<strong>函数定义</strong>中包含<strong>yield关键字</strong>（注意这里涉及协程），那么这个函数就不再是一个普通函数，而是一个generator</p>
<p>例子：斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到：</p>
<pre><code>def fib(max):
    n, a, b = 0, 0, 1
    while n &lt; max:
        yield b
        a, b = b, a + b
        n = n + 1
    return 'done'
		
&gt;&gt;&gt; f = fib(6)
&gt;&gt;&gt; f
&lt;generator object fib at 0x104feaaa0&gt;
</code></pre>
<p>generator和函数的执行流程不一样。</p>
<ol>
<li>函数是顺序执行，遇到return语句或者最后一行函数语句就返回。</li>
<li>而变成generator的函数，在每次<strong>调用next()的时候执行</strong>，<strong>遇到yield语句返回</strong>，再次执行时<strong>从上次返回的yield语句处继续执行</strong>。</li>
</ol>
<p>举个简单的例子，定义一个generator，依次返回数字1，3，5：</p>
<pre><code>def odd():
    print('step 1')
    yield 1
    print('step 2')
    yield(3)
    print('step 3')
    yield(5)
</code></pre>
<p>调用该generator时，首先要生成一个generator对象，然后用next()函数不断获得下一个返回值：</p>
<pre><code>&gt;&gt;&gt; o = odd()
&gt;&gt;&gt; next(o)
step 1
1
&gt;&gt;&gt; next(o)
step 2
3
&gt;&gt;&gt; next(o)
step 3
5
&gt;&gt;&gt; next(o)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
StopIteration

# 在执行过程中，遇到yield就中断，下次又继续执行。执行3次yield后，已经没有yield可以执行了，所以，第4次调用next(o)就报错。
</code></pre>
<p>由于错误的存在，同样地把函数改成generator后，我们基本上从来不会用next()来获取下一个返回值，而是直接使用for循环来迭代：</p>
<pre><code>&gt;&gt;&gt; for n in fib(6):
...     print(n)
</code></pre>
<p>但在循环过程中不断调用yield，可能会导致不断中断。要给循环设置一个条件来退出循环，不然就会产生一个无限数列出来。</p>
<p>但是用for循环调用generator时，<strong>拿不到generator的return语句的返回值</strong>。如果想要拿到返回值，<strong>必须捕获StopIteration错误</strong>，<strong>返回值包含在StopIteration的value中</strong></p>
<pre><code>&gt;&gt;&gt; g = fib(6)
&gt;&gt;&gt; while True:
...     try:
...         x = next(g)
...         print('g:', x)
...     except StopIteration as e:
...         print('Generator return value:', e.value)
...         break
...
g: 1
g: 1
g: 2
g: 3
g: 5
g: 8
Generator return value: done
</code></pre>
<p><strong>个人代码练习</strong><br>
杨辉三角把<br>
每一行看做一个list，试写一个generator，不断输出下一行的list：</p>
<pre><code># -*- coding: utf-8 -*-

def triangles():
    n, list_pre, list_cur  = 0, [1], [1, 1]
    while True:
        if n == 0:
            n = n + 1
            yield list_pre
        if n == 1:
            n = n + 1
            yield list_cur
        list_pre = list_cur
        list_cur = [1, 1]
        for i in range(1, len(list_pre)):
            list_cur.insert(i, list_pre[i] + list_pre[i - 1])
        n = n + 1
        yield list_cur
				
				
# 期待输出:
# [1]
# [1, 1]
# [1, 2, 1]
# [1, 3, 3, 1]
# [1, 4, 6, 4, 1]
# [1, 5, 10, 10, 5, 1]
# [1, 6, 15, 20, 15, 6, 1]
# [1, 7, 21, 35, 35, 21, 7, 1]
# [1, 8, 28, 56, 70, 56, 28, 8, 1]
# [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]
n = 0
results = []
for t in triangles():
    results.append(t)
    n = n + 1
    if n == 10:
        break

for t in results:
    print(t)

if results == [
    [1],
    [1, 1],
    [1, 2, 1],
    [1, 3, 3, 1],
    [1, 4, 6, 4, 1],
    [1, 5, 10, 10, 5, 1],
    [1, 6, 15, 20, 15, 6, 1],
    [1, 7, 21, 35, 35, 21, 7, 1],
    [1, 8, 28, 56, 70, 56, 28, 8, 1],
    [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]
]:
    print('测试通过!')
else:
    print('测试失败!')
</code></pre>
<h2 id="迭代器">迭代器</h2>
<h3 id="可迭代对象iterable">可迭代对象：Iterable</h3>
<p>可以直接作用于for循环的数据类型有以下几种：</p>
<p>一类是<strong>集合数据类型</strong>，如list、tuple、dict、set、str等；</p>
<p>一类是<strong>generator</strong>，包括<strong>生成器</strong>和<strong>带yield的generator function</strong>。</p>
<p>这些可以直接作用于for循环的对象统称为<strong>可迭代对象：Iterable。</strong></p>
<p><strong>可以使用isinstance()判断一个对象是否是Iterable对象：</strong></p>
<pre><code>&gt;&gt;&gt; from collections.abc import Iterable
&gt;&gt;&gt; isinstance([], Iterable)
True
&gt;&gt;&gt; isinstance({}, Iterable)
True
&gt;&gt;&gt; isinstance('abc', Iterable)
True
&gt;&gt;&gt; isinstance((x for x in range(10)), Iterable)
True
&gt;&gt;&gt; isinstance(100, Iterable)
False
</code></pre>
<h3 id="迭代器iterator">迭代器：Iterator</h3>
<p>而生成器不但可以作用于for循环，还<strong>可以被next()函数不断调用并返回下一个值</strong>，直到最<strong>后抛出StopIteration错误</strong>表示无法继续返回下一个值了。</p>
<p>可以被next()函数调用并不断返回下一个值的对象称为<strong>迭代器：Iterator</strong>。</p>
<p>可以使用isinstance()判断一个对象是否是Iterator对象：</p>
<pre><code>&gt;&gt;&gt; from collections.abc import Iterator
&gt;&gt;&gt; isinstance((x for x in range(10)), Iterator)
True
&gt;&gt;&gt; isinstance([], Iterator)
False
&gt;&gt;&gt; isinstance({}, Iterator)
False
&gt;&gt;&gt; isinstance('abc', Iterator)
False
</code></pre>
<p><strong>生成器都是Iterator对象</strong>，但<strong>list、dict、str虽然是Iterable，却不是Iterator。</strong></p>
<p>把list、dict、str等Iterable变成Iterator可以使用<strong>iter()函数</strong>：</p>
<pre><code>&gt;&gt;&gt; isinstance(iter([]), Iterator)
True
&gt;&gt;&gt; isinstance(iter('abc'), Iterator)
True
</code></pre>
<p><strong>为什么list、dict、str等数据类型不是Iterator？</strong></p>
<p>这是因为Python的<strong>Iterator对象表示的是一个数据流</strong>，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却<strong>不能提前知道序列的长度</strong>，只能不断通过next()函数实现按需计算下一个数据，所以<strong>Iterator的计算是惰性的</strong>，只有在需要返回下一个数据时它才会计算。</p>
<p>Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而<strong>使用list是永远不可能存储全体自然数的</strong>。</p>
<h3 id="小结">小结</h3>
<p>凡是可作用于for循环的对象都是<strong>Iterable类型</strong>；</p>
<p>凡是可作用于next()函数的对象都是<strong>Iterator类型</strong>，它们表示一个惰性计算的序列；</p>
<p>集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。</p>
<p>Python的for循环本质上就是通过不断调用next()函数实现的，例如：</p>
<pre><code>for x in [1, 2, 3, 4, 5]:
    pass
</code></pre>
<p>实际上完全等价于：</p>
<pre><code># 首先获得Iterator对象:
it = iter([1, 2, 3, 4, 5])
# 循环:
while True:
    try:
        # 获得下一个值:
        x = next(it)
    except StopIteration:
        # 遇到StopIteration就退出循环
        break
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python - 函数]]></title>
        <id>https://lixin-scut.github.io//post/python-han-shu</id>
        <link href="https://lixin-scut.github.io//post/python-han-shu">
        </link>
        <updated>2020-05-08T07:20:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="调用函数">调用函数</h2>
<p>要调用一个函数，需要知道函数的名称和参数，比如求绝对值的函数abs，只有一个参数。可以直接从Python的官方网站查看文档：</p>
<p>http://docs.python.org/3/library/functions.html#abs</p>
<p>也可以在交互式命令行通过help(abs)查看abs函数的帮助信息。help将会进入新界面，按q返回</p>
<p>调用函数的时候，如果传入的参数数量不对，会报TypeError的错误，并且Python会明确地告诉你：abs()有且仅有1个参数，但给出了两个：</p>
<pre><code>&gt;&gt;&gt; abs(1, 2)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: abs() takes exactly one argument (2 given)
</code></pre>
<p>如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报TypeError的错误，并且给出错误信息：str是错误的参数类型：</p>
<pre><code>&gt;&gt;&gt; abs('a')
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: bad operand type for abs(): 'str'
</code></pre>
<p>而max函数max()可以接收任意多个参数，并返回最大的那个：</p>
<pre><code>&gt;&gt;&gt; max(1, 2)
2
&gt;&gt;&gt; max(2, 3, 1, -5)
3
</code></pre>
<h3 id="数据类型转换">数据类型转换</h3>
<p>Python内置的常用函数还包括数据类型转换函数，比如int()函数可以把其他数据类型转换为整数：</p>
<pre><code>&gt;&gt;&gt; int('123')
123
&gt;&gt;&gt; int(12.34)
12
&gt;&gt;&gt; float('12.34')
12.34
&gt;&gt;&gt; str(1.23)
'1.23'
&gt;&gt;&gt; str(100)
'100'
&gt;&gt;&gt; bool(1)
True
&gt;&gt;&gt; bool('')
False
</code></pre>
<p>函数名其实就是<strong>指向一个函数对象的引用</strong>，完全可以<strong>把函数名赋给一个变量</strong>，相当于给这个函数起了一个“别名”：</p>
<pre><code>&gt;&gt;&gt; a = abs # 变量a指向abs函数
&gt;&gt;&gt; a(-1) # 所以也可以通过a调用abs函数
1
</code></pre>
<h2 id="定义函数">定义函数</h2>
<p>在Python中，定义一个函数要使用def语句，依次写出<strong>函数名、括号、括号中的参数和冒号:</strong>，然后，在缩进块中编写函数体，函数的返回值用return语句返回。</p>
<pre><code>def my_abs(param):
    if(param &lt; 0):
         param = - param
    return param
</code></pre>
<p>函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。</p>
<p>如果没有return语句，函数执行完毕后也会返回结果，只是<strong>结果为None</strong>。return None可以简写为return。</p>
<p>在Python交互环境中定义函数时，注意Python会出现...的提示。函数定义结束后需要按两次回车重新回到&gt;&gt;&gt;提示符下</p>
<p>如果你已经把my_abs()的函数定义<strong>保存为abstest.py文件</strong>了，那么，可以在该文件的当前目录下启动Python解释器，<strong>用from abstest import my_abs来导入my_abs()函数</strong>，注意abstest是文件名（<strong>不含.py扩展名</strong>）</p>
<h3 id="空函数">空函数</h3>
<p>如果想定义一个什么事也不做的空函数，可以用pass语句：</p>
<pre><code>def nop():
    pass
</code></pre>
<p>pass语句什么都不做，那有什么用？实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。</p>
<p>pass还可以用在其他语句里，比如：</p>
<pre><code>if age &gt;= 18:
    pass
</code></pre>
<p><strong>缺少了pass，代码运行就会有语法错误。</strong></p>
<h3 id="参数检查">参数检查</h3>
<p>调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出TypeError：</p>
<pre><code>&gt;&gt;&gt; my_abs(1, 2)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: my_abs() takes 1 positional argument but 2 were given
</code></pre>
<p><strong>但是如果参数类型不对，Python解释器就无法帮我们检查</strong>。</p>
<p>试试my_abs和内置函数abs的差别：</p>
<pre><code>&gt;&gt;&gt; my_abs('A')
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;&lt;stdin&gt;&quot;, line 2, in my_abs
TypeError: unorderable types: str() &gt;= int()
&gt;&gt;&gt; abs('A')
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: bad operand type for abs(): 'str'
</code></pre>
<p>当传入了不恰当的参数时，内置函数abs会检查出参数错误，而自己定义的my_abs没有参数检查，会导致if语句出错，出错信息和abs不一样。所以，这个函数定义不够完善。</p>
<p>需要修改一下my_abs的定义，对参数类型做检查，只允许整数和浮点数类型的参数。<br>
<strong>数据类型检查可以用内置函数isinstance()实现</strong>：</p>
<pre><code>def my_abs(x):
    if not isinstance(x, (int, float)):
        raise TypeError('bad operand type')
    if x &gt;= 0:
        return x
    else:
        return -x
</code></pre>
<p>添加了参数检查后，如果传入错误的参数类型，函数就可以抛出一个错误：</p>
<pre><code>&gt;&gt;&gt; my_abs('A')
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;&lt;stdin&gt;&quot;, line 3, in my_abs
TypeError: bad operand type
</code></pre>
<h3 id="返回多个值">返回多个值</h3>
<p>函数可以返回多个值</p>
<pre><code>import math

def move(x, y, step, angle=0):
    nx = x + step * math.cos(angle)
    ny = y - step * math.sin(angle)
    return nx, ny
</code></pre>
<p>import math语句表示导入math包，并允许后续代码引用math包里的sin、cos等函数。</p>
<p>然后，我们就可以同时获得返回值：</p>
<pre><code>&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)
&gt;&gt;&gt; print(x, y)
151.96152422706632 70.0
</code></pre>
<p>但其实这只是一种假象，<strong>Python函数返回的仍然是单一值</strong>：</p>
<pre><code>&gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6)
&gt;&gt;&gt; print(r)
(151.96152422706632, 70.0)
</code></pre>
<p>返回值<strong>实际上是一个tuple</strong>，但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，<strong>按位置赋给对应的值</strong><br>
所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。</p>
<h2 id="函数的参数">函数的参数</h2>
<p>定义函数的时候，我们把参数的名字和位置确定下来，函数的接口定义就完成了。对于函数的调用者来说，只需要知道如何传递正确的参数，以及函数将返回什么样的值就够了，函数内部的复杂逻辑被封装起来，调用者无需了解。</p>
<p>Python的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用<strong>默认参数、可变参数和关键字参数</strong>，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。</p>
<h3 id="位置参数">位置参数</h3>
<p>对于func(x)函数，参数x就是一个位置参数。<br>
当我们调用func函数时，必须传入有且仅有的一个参数x<br>
调用函数时，传入的值按照位置顺序依次赋给参数x，所以叫做位置参数</p>
<h3 id="默认参数">默认参数</h3>
<p>如果希望定义新的函数定义，但是希望避免因为缺少一个参数而无法正常调用旧的调用代码，可以增加了一个默认参数</p>
<pre><code>def power(x, n=2):
    s = 1
    while n &gt; 0:
        n = n - 1
        s = s * x
    return s
</code></pre>
<p>设置默认参数时，有几点要注意：</p>
<ol>
<li>
<p><strong>必选参数在前，默认参数在后</strong>，否则Python的解释器会报错</p>
</li>
<li>
<p>如何设置默认参数。<br>
当函数有多个参数时，把<strong>变化大的参数放前面</strong>，<strong>变化小的参数放后面</strong>。变化小的参数就可以作为默认参数。<br>
使用默认参数最大的好处是能<strong>降低调用函数的难度</strong>。</p>
</li>
</ol>
<p>有多个默认参数时，调用的时候，既可以按顺序提供默认参数，比如调用<code>enroll('Bob', 'M', 7)</code><br>
也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。比如调用<code>enroll('Adam', 'M', city='Tianjin')</code></p>
<p>默认参数很有用，但使用不当，也会掉坑里。默认参数有个最大的坑，</p>
<p>先定义一个函数，传入一个list，添加一个END再返回：</p>
<pre><code>def add_end(L=[]):
    L.append('END')
    return L
</code></pre>
<p>当你使用默认参数调用时，一开始结果也是对的：</p>
<pre><code>&gt;&gt;&gt; add_end()
['END']
</code></pre>
<p>但是，再次调用add_end()时，结果就不对了：</p>
<pre><code>&gt;&gt;&gt; add_end()
['END', 'END']
&gt;&gt;&gt; add_end()
['END', 'END', 'END']
</code></pre>
<p>默认参数虽然是[]，但是函数似乎每次都“记住了”上次添加了'END'后的list。</p>
<p>原因解释如下：</p>
<p>Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为<strong>默认参数L也是一个变量，它指向对象[]</strong>，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。</p>
<p><strong>定义默认参数要牢记一点：默认参数必须指向不变对象！</strong></p>
<p>要修改上面的例子，我们可以用None这个不变对象来实现：</p>
<pre><code>def add_end(L=None):
    if L is None:
        L = []
    L.append('END')
    return L
</code></pre>
<p>现在，无论调用多少次，都不会有问题：</p>
<pre><code>&gt;&gt;&gt; add_end()
['END']
&gt;&gt;&gt; add_end()
['END']
</code></pre>
<p>这就是设计str、None这样的不变对象的原因，因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。<br>
此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。</p>
<h3 id="可变参数">可变参数</h3>
<p>在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。</p>
<pre><code>def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum
</code></pre>
<p>定义可变参数和定义一个list或tuple参数相比，<strong>仅仅在参数前面加了一个*号</strong>。在函数内部，<strong>参数numbers接收到的是一个tuple</strong>，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，<strong>包括0个参</strong>数：</p>
<pre><code>&gt;&gt;&gt; calc(1, 2)
5
&gt;&gt;&gt; calc()
0
</code></pre>
<p>如果已经有一个list或者tuple，要调用一个可变参数，可以在list或tuple前面加一个<code>*</code>号，把list或tuple的元素变成可变参数传进去：</p>
<pre><code>&gt;&gt;&gt; nums = [1, 2, 3]
&gt;&gt;&gt; calc(*nums)
14
</code></pre>
<p><code>*nums</code>表示把nums这个list的所有元素作为可变参数传进去。</p>
<h3 id="关键字参数">关键字参数</h3>
<p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时<strong>自动组装为一个tuple</strong>。<br>
而关键字参数允许你传入<strong>0个或任意个</strong>含参数名的参数，这些关键字参数在函数内部<strong>自动组装为一个dict</strong>。</p>
<pre><code>def person(name, age, **kw):
    print('name:', name, 'age:', age, 'other:', kw)
</code></pre>
<p>函数person除了必选参数name和age外，还接受关键字参数kw。在调用该函数时，可以只传入必选参数：</p>
<pre><code>&gt;&gt;&gt; person('Michael', 30)
name: Michael age: 30 other: {}
</code></pre>
<p>也可以传入任意个数的关键字参数：</p>
<pre><code>&gt;&gt;&gt; person('Bob', 35, city='Beijing')
name: Bob age: 35 other: {'city': 'Beijing'}
&gt;&gt;&gt; person('Adam', 45, gender='M', job='Engineer')
name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}
</code></pre>
<p><strong>关键字参数可以扩展函数的功能</strong>。<br>
比如，在person函数里，我们保证能接收到name和age这两个参数，但是，<strong>如果调用者愿意提供更多的参数，我们也能收到</strong>。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。</p>
<p>和可变参数类似，<strong>也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去</strong></p>
<pre><code>&gt;&gt;&gt; extra = {'city': 'Beijing', 'job': 'Engineer'}
&gt;&gt;&gt; person('Jack', 24, city=extra['city'], job=extra['job'])
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
</code></pre>
<p>当然，上面复杂的调用可以用简化的写法：</p>
<pre><code>&gt;&gt;&gt; extra = {'city': 'Beijing', 'job': 'Engineer'}
&gt;&gt;&gt; person('Jack', 24, **extra)
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
</code></pre>
<p><code>**extra</code>表示把extra这个dict的所有key-value用关键字参数传入到函数的<code>**kw</code>参数，kw将获得一个dict，<strong>注意kw获得的dict是extra的一份拷贝</strong>，<strong>对kw的改动不会影响到函数外的extra</strong>。</p>
<h3 id="命名关键字参数">命名关键字参数</h3>
<p>对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过kw检查。</p>
<p>如果<strong>要限制关键字参数的名</strong>字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：</p>
<pre><code>def person(name, age, *, city, job):
    print(name, age, city, job)
</code></pre>
<p>和关键字参数<code>**kw</code>不同，命名关键字参数需要一个特殊分隔符<code>*</code>，<code>*</code>后面的参数被视为<strong>命名关键字参数</strong>。</p>
<p>如果函数定义中<strong>已经有了一个可变参数</strong>，<strong>后面跟着的命名关键字参数就不再需要一个特殊分隔符<code>*</code>了</strong>：</p>
<pre><code>def person(name, age, *args, city, job):
    print(name, age, args, city, job)
</code></pre>
<p><strong>命名关键字参数必须传入参数名</strong>，这和位置参数不同。<strong>如果没有传入参数名，调用将报错</strong>：</p>
<pre><code>&gt;&gt;&gt; person('Jack', 24, 'Beijing', 'Engineer')
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: person() takes 2 positional arguments but 4 were given
</code></pre>
<p>由于调用时缺少参数名city和job，Python解释器把这4个参数均视为位置参数，但person()函数仅接受2个位置参数。</p>
<p><strong>命名关键字参数可以有缺省值</strong>，从而简化调用：</p>
<pre><code>def person(name, age, *, city='Beijing', job):
    print(name, age, city, job)
</code></pre>
<p>由于<strong>命名关键字参数city具有默认值，调用时，可不传入city参数</strong>：</p>
<pre><code>&gt;&gt;&gt; person('Jack', 24, job='Engineer')
Jack 24 Beijing Engineer
</code></pre>
<p>使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个<code>*</code>作为特殊分隔符。如果缺少<code>*</code>，Python解释器将<strong>无法识别位置参数和命名关键字参数</strong>：</p>
<pre><code>def person(name, age, city, job):
    # 缺少 *，city和job被视为位置参数
    pass
</code></pre>
<h3 id="参数组合">参数组合</h3>
<p>在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，<strong>参数定义的顺序</strong>必须是：</p>
<ol>
<li>必选参数</li>
<li>默认参数</li>
<li>可变参数</li>
<li>命名关键字参数</li>
<li>关键字参数</li>
</ol>
<p>比如定义一个函数，包含上述若干种参数：</p>
<pre><code>def f1(a, b, c=0, *args, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)

def f2(a, b, c=0, *, d, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw)
</code></pre>
<p>在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。</p>
<pre><code>&gt;&gt;&gt; f1(1, 2)
a = 1 b = 2 c = 0 args = () kw = {}
&gt;&gt;&gt; f1(1, 2, c=3)
a = 1 b = 2 c = 3 args = () kw = {}
&gt;&gt;&gt; f1(1, 2, 3, 'a', 'b')
a = 1 b = 2 c = 3 args = ('a', 'b') kw = {}
&gt;&gt;&gt; f1(1, 2, 3, 'a', 'b', x=99)
a = 1 b = 2 c = 3 args = ('a', 'b') kw = {'x': 99}
&gt;&gt;&gt; f2(1, 2, d=99, ext=None)
a = 1 b = 2 c = 0 d = 99 kw = {'ext': None}
</code></pre>
<p><strong>最神奇的是通过一个tuple和dict，也可以调用上述函数</strong>：</p>
<pre><code>&gt;&gt;&gt; args = (1, 2, 3, 4)
&gt;&gt;&gt; kw = {'d': 99, 'x': '#'}
&gt;&gt;&gt; f1(*args, **kw)
a = 1 b = 2 c = 3 args = (4,) kw = {'d': 99, 'x': '#'}
&gt;&gt;&gt; args = (1, 2, 3)
&gt;&gt;&gt; kw = {'d': 88, 'x': '#'}
&gt;&gt;&gt; f2(*args, **kw)
a = 1 b = 2 c = 3 d = 88 kw = {'x': '#'}
</code></pre>
<p>所以，<strong>对于任意函数，都可以通过类似<code>func(*args, **kw)</code>的形式调用它，无论它的参数是如何定义的。</strong></p>
<p>虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。</p>
<h3 id="小结">小结</h3>
<p>Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。</p>
<p>默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！</p>
<p>要注意定义可变参数和关键字参数的语法：</p>
<p><code>*args</code>是可变参数，args接收的是一个tuple；</p>
<p><code>**kw</code>是关键字参数，kw接收的是一个dict。</p>
<p>以及调用函数时如何传入可变参数和关键字参数的语法：</p>
<p>可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过<code>*args</code>传入：<code>func(*(1, 2, 3))</code>；</p>
<p>关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过<code>**kw</code>传入：<code>func(**{'a': 1, 'b': 2})</code>。</p>
<p>使用<code>*args</code>和<code>**kw</code>是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。</p>
<p>命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。</p>
<p>定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。</p>
<h2 id="递归函数">递归函数</h2>
<p>在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。</p>
<p>来计算阶乘n! = 1 x 2 x 3 x ... x n，用函数fact(n)表示，可以看出：</p>
<p>fact(n) = n! = 1 x 2 x 3 x ... x (n-1) x n = (n-1)! x n = fact(n-1) x n</p>
<p>所以，fact(n)可以表示为n x fact(n-1)，只有n=1时需要特殊处理。</p>
<p>于是，fact(n)用递归的方式写出来就是：</p>
<pre><code>def fact(n):
    if n==1:
        return 1
    return n * fact(n - 1)
</code></pre>
<p>递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。</p>
<p>使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。</p>
<p><strong>解决递归调用栈溢出的方法是通过尾递归优化</strong>，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。</p>
<p>尾递归是指，<strong>在函数返回的时候，调用自身本身</strong>，并且，r<strong>eturn语句不能包含表达式</strong>。这样，<strong>编译器或者解释器就可以把尾递归做优化</strong>，使递归本身无论调用多少次，<strong>都只占用一个栈帧</strong>，不会出现栈溢出的情况。</p>
<p>上面的fact(n)函数由于return n * fact(n - 1)引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：</p>
<pre><code>def fact(n):
    return fact_iter(n, 1)

def fact_iter(num, product):
    if num == 1:
        return product
    return fact_iter(num - 1, num * product)
</code></pre>
<p><code>return fact_iter(num - 1, num * product)</code>仅返回递归函数本身，<code>num - 1</code>和<code>num * product</code>在函数调用前就会被计算，不影响函数调用。</p>
<p>尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。</p>
<p>遗憾的是，大多数编程语言没有针对尾递归做优化，Python标准的解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。</p>
]]></content>
    </entry>
</feed>