<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-02-27T11:45:40.792Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>In the darkest night,Rising like a spire.</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[TCP 与 UDP]]></title>
        <id>https://lixin-scut.github.io//post/tcp-yu-udp</id>
        <link href="https://lixin-scut.github.io//post/tcp-yu-udp">
        </link>
        <updated>2020-02-27T10:02:40.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接</li>
<li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</li>
<li>UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</li>
<li>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</li>
<li>TCP对系统资源要求较多，UDP对系统资源要求较少。</li>
<li>若通信数据完整性需让位与通信实时性，则应该选用 TCP 协议（如文件传输、重要状态的更新等）；反之，则使用 UDP 协议（如视频传输、实时通信等）。</li>
<li>UDP:DNS   SNMP</li>
<li>TCP面向字节流，UTP面向数据包；</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TIME_WAIT 状态]]></title>
        <id>https://lixin-scut.github.io//post/time_wait-zhuang-tai</id>
        <link href="https://lixin-scut.github.io//post/time_wait-zhuang-tai">
        </link>
        <updated>2020-02-27T09:19:44.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://lixin-scut.github.io//post-images/1582795214575.png" alt=""><br>
其实一开始我就对这个状态十分疑惑，本来我以为仅仅是为了避免最后一个ACK丢失，但是看完《TCP/IP详解》之后才发现这其中有很多细节</p>
<ol>
<li>
<p>首先调用close()发起主动关闭的一方，在发送最后一个ACK之后会进入time_wait的状态，也就说该发送方会保持2MSL时间之后才会回到初始状态。MSL指的是数据包在网络中的最大生存时间。产生这种结果使得这个TCP连接在2MSL连接等待期间，定义这个连接的四元组（客户端IP地址和端口，服务端IP地址和端口号）不能被使用。</p>
</li>
<li>
<p>为什么存在time_wait<br>
①	TCP协议在关闭连接的四次握手过程中，最终的ACK是由主动关闭连接的一端（后面统称A端）发出的，如果这个ACK丢失，对方（后面统称B端）将重发出最终的FIN，因此A端必须维护状态信息（TIME_WAIT）允许它重发最终的ACK。如果A端不维持TIME_WAIT状态，而是处于CLOSED 状态，那么A端将响应RST分节，B端收到后将此分节解释成一个错误。因而，要实现TCP全双工连接的正常终止，必须处理终止过程中四个分节任何一个分节的丢失情况，主动关闭连接的A端必须维持TIME_WAIT状态 。</p>
</li>
</ol>
<p>为实现TCP全双工连接的可靠释放<br>
由TCP状态变迁图可知，假设发起主动关闭的一方（client）最后发送的ACK在网络中丢失，由于TCP协议的重传机制，执行被动关闭的一方（server）将会重发其FIN，在该FIN到达client之前，client必须维护这条连接状态，也就说这条TCP连接所对应的资源（client方的local_ip,local_port）不能被立即释放或重新分配，直到另一方重发的FIN达到之后，client重发ACK后，经过2MSL时间周期没有再收到另一方的FIN之后，该TCP连接才能恢复初始的CLOSED状态。如果主动关闭一方不维护这样一个TIME_WAIT状态，那么当被动关闭一方重发的FIN到达时，主动关闭一方的TCP传输层会用RST包响应对方，这会被对方认为是有错误发生，然而这事实上只是正常的关闭连接过程，并非异常。</p>
<p>②	TCP segment 可能由于路由器异常而“迷途”，在迷途期间，TCP发送端可能因确认超时而重发这个segment，迷途的segment在路由器修复后也会被送到最终目的地，这个迟到的迷途segment到达时可能会引起问题。在关闭“前一个连接”之后，马上又重新建立起一个相同的IP和端口之间的“新连接”，“前一个连接”的迷途重复分组在“前一个连接”终止后到达，而被“新连接”收到了。为了避免这个情况，TCP协议不允许处于TIME_WAIT状态的连接启动一个新的可用连接，因为TIME_WAIT状态持续2MSL，就可以保证当成功建立一个新TCP连接的时候，来自旧连接重复分组已经在网络中消逝。</p>
<p>为使旧的数据包在网络因过期而消失<br>
为说明这个问题，我们先假设TCP协议中不存在TIME_WAIT状态的限制，再假设当前有一条TCP连接：(local_ip, local_port, remote_ip,remote_port)，因某些原因，我们先关闭，接着很快以相同的四元组建立一条新连接。本文前面介绍过，TCP连接由四元组唯一标识，因此，在我们假设的情况中，TCP协议栈是无法区分前后两条TCP连接的不同的，在它看来，这根本就是同一条连接，中间先释放再建立的过程对其来说是“感知”不到的。这样就可能发生这样的情况：前一条TCP连接由local peer发送的数据到达remote peer后，会被该remot peer的TCP传输层当做当前TCP连接的正常数据接收并向上传递至应用层（而事实上，在我们假设的场景下，这些旧数据到达remote peer前，旧连接已断开且一条由相同四元组构成的新TCP连接已建立，因此，这些旧数据是不应该被向上传递至应用层的），从而引起数据错乱进而导致各种无法预知的诡异现象。作为一种可靠的传输协议，TCP必须在协议层面考虑并避免这种情况的发生，这正是TIME_WAIT状态存在的第2个原因。</p>
<ol start="3">
<li>time_wait状态如何避免<br>
首先服务器可以设置SO_REUSEADDR套接字选项来通知内核，如果端口忙，但TCP连接位于TIME_WAIT状态时可以重用端口。在一个非常有用的场景就是，如果你的服务器程序停止后想立即重启，而新的套接字依旧希望使用同一端口，此时SO_REUSEADDR选项就可以避免TIME_WAIT状态。</li>
</ol>
<p>先总结一下：</p>
<ol>
<li>确保最后一个确认报文段能够到达。如果 B 没收到 A 发送来的确认报文段，那么就会重新发送连接释放请求报文段，A 等待一段时间就是为了处理这种情况的发生。</li>
<li>可能存在“已失效的连接请求报文段”，为了防止这种报文段出现在本次连接之外，需要等待一段时间。防止串话。</li>
</ol>
<p>详细资料以及参考资料<br>
《UNIX网络编程》<br>
<img src="https://lixin-scut.github.io//post-images/1582797482348.png" alt=""></p>
<p>《TCP/IP详解》：<br>
13.5.1	TIME_WAIT 状态<br>
　　TIME_WAIT状态也称为2MSL等待状态。在该状态中，TCP将会等待两倍于最大段生存期（Maximum Segment Lifetime, MSL）的时间，有时也被称作加倍等待。每个实现都必须为最大段生存期选择一个数值。它代表任何报文段在被丢弃前在网络中被允许存在的最长 时间。：</p>
<p>假设已设定MSL的数值，按照规则：当TCP执行一个主动关闭并发送最终的ACK时, 连接必须处于TIME_WAIT状态并持续两倍于最大生存期的时间。这样就能够让TCP重新 发送最终的ACK以避免出现丢失的情况。重新发送最终的ACK并不是因为TCP重传了ACK （它们并不消耗序列号，也不会被TCP重传），而是因为通信另一方重传了它的FIN （它消耗-个序列号）。事实上，TCP总是重传FIN,直到它收到一个最终的ACK。<br>
　　<strong>另一个影响2MSL等待状态的因素是当TCP处于等待状态时，通信双方将该连接（客 户端IP地址、客户端端口号、服务器IP地址、服务器端口号）定义为不可重新使用。</strong> 只有当2MSL等待结束时，或一条新连接使用的初始序列号超过了连接之前的实例所使用的最高 序列号时[RFC1122],或者允许使用时间戳选项来区分之前连接实例的报文段以避免混淆时 [RFC6191],这条连接才能被再次使用。不幸的是，一些实现施加了更加严格的约束。在这 些系统中，如果一个端口号被处于2MSL等待状态的任何通信端所用，那么该端口号将不能 被再次使用。<br>
　　当一个连接处于2MSL等待状态时，任何延迟到达的报文段都将被丢弃。 因为一条连接是通过地址和端口号的4元组定义的。如果该连接处于2MSL等待状态，那么 它在这段时间内将不能被重新使用。当这条正确的连接最终被建立起来后，这条连接之前的 实例所传输的延迟报文段是不能被当作新连接的一部分来解读的。<br>
　　<strong>对于交互式应用程序而言，客户端通常执行主动关闭操作并进入TIME_WAIT状态，服 务器通常执行被动关闭操作并且不会直接进入TIME_WAIT状态。其中的含义是，如果我们 终止一个客户端后立刻重新启动同一客户端，那么新的客户端也不能重新使用相同的本地端 口号。通常来说，这并不成问题。因为客户端通常使用的是由操作系统分配的临时端口号， 而且它们也并不关心被分配的端口号究竟是什么</strong>(回忆一下，实际上出于安全考虑有一种推 荐的随机方法[RFC6056]o值得注意的是，由于一个客户端能够快速产生大量的连接(尤其 是针对同一个服务器)，因此它不得不在临时端口号供应紧张时延迟一会儿来等待其他连接 的终止。<br>
　　<strong>对于服务器而言，情况则大不相同。它们通常使用一些知名的端口。如果我们终止一个 已经建立了一条连接的服务器进程，然后立即尝试重新启动它，服务器不能为该程序的通信 端分配对应的端口号(它将会收到一个“地址已占用”的绑定错误)。这是因为当连接进入 2MSL等待状态时，端口号仍然是连接的一部分。</strong> 根据系统对MSL数值的不同设定，服务 器可能需要花费1 ~ 4分钟才能重新启动。我们可以利用sock程序观察这一场景。在清单 13-3中，我们启动服务器，从客户端连接该服务器，然后终止服务器。</p>
<p>当重新启动服务器时，程序会输出一条错误信息，显示由于地址已经被占用而导致它的 端口号不能被绑定。实际上这也意味着该地址与端口号的组合已经被使用。这是由于前一个 连接处于2MSL的等待状态而造成的。</p>
<p>13.5.3静默时间的概念<br>
在本地与外地的IP地址、端口号都相同的情况下，2MSL状态能够防止新的连接将前一 个连接的延迟报文段解释成自身数据的状况。然而，上述方法只有在与处于2MSL等待状态 的连接相关的主机未关闭的条件下才具有意义。<br>
如果一台与处于TIME_WAIT状态下的连接相关联的主机崩溃，然后在MSL内重新启 动，并且使用与主机崩溃之前处于TIME_WAIT状态的连接相同的IP地址与端口号，那么 将会怎样处理呢？在上述情况下，该连接在主机崩溃之前产生的延迟报文段会被认为属于主 机重启后创建的新连接。这种处理方式将不会考虑在主机重启之后新连接是如何选择初始序 列号的。<br>
为了防止上述情况的发生，［RFC0793］指出在崩溃或者重启后TCP协议应当在创建新 的连接之前等待相当于一个MSL的时间。该段时间被称作静默时间。然而只有极少数实现 遵循了这一点。因为绝大多数的主机在崩溃之后都需要超过一个MSL的时间才能重新启动。 此外，如果上层应用程序自身已采用了校验和或者加密手段，那么此类错误会很容易检测 ［624］出来。</p>
<p>为了方便阅读，再加上图片版<br>
<img src="https://lixin-scut.github.io//post-images/1582796710043.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582796746517.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582796806414.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582796831796.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582796849898.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TCP 连接相关]]></title>
        <id>https://lixin-scut.github.io//post/tcp-lian-jie</id>
        <link href="https://lixin-scut.github.io//post/tcp-lian-jie">
        </link>
        <updated>2020-02-27T08:05:30.000Z</updated>
        <content type="html"><![CDATA[<p>TCP连接的整体图：<br>
<img src="https://lixin-scut.github.io//post-images/1582790915595.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582798546017.png" alt=""></p>
<h3 id="三次握手">三次握手</h3>
<p>三次握手：客户首先发送一个特殊的TCP报文段.服务器用另一个特殊的TCP报文段来响应，最后，客户再用第三个特殊报文段作为响应。前两个报文段不承载“有效载荷”，也就是不包含应用层数据；而第三个报文段可以承载有效载荷。<br>
　　三次握手的目的不仅在于让通信双方了解一个连接正在建立，还在于利用数据包的选项来承载特殊信息，交换初始序列号（ISN）。<br>
步骤：<br>
　　第一步：客户端的TCP首先向服务器端的TCP发送一个特殊的TCP报文段,，该报文段中不包含应用层数据。但是在报文段的首部中的一个标志位(即SYN比特）被置为1因此，这个特殊报文段被称为<strong>SYN报文段</strong>，另外客户会随机地选择一个初始序号,并将此编号放置于该起始的TCPSYN报文段的序号字段中。该报文段会被封装在一个IP数据报中，并发送给服务器<br>
　　第二步：一旦包含TCPSYN报文段的IP数据报到达服务器主机,服务器会从该数据报中提取出TCPSYN报文段，为该TCP连接分配TCP缓存和变量，并向该客户TCP发送允许连接的报文段这个允许连接的报文段也不包含应用层数据。但是.在报文段的首部却包含3个重要的信息。首先，SYN比特被置为1。其次，该TCP报文段首部的确认号字段被置为client_isn+1,最后，服务器选择自己的初始序号,并将其放置到TCP报文段首部的序号字段中。该允许连接的报文段有时被称为<strong>SYNACK报文段</strong><br>
　　第三步：在收到SYNACK报文段后，客户也要给该连接分配缓存和变量，客户主机则向服务器发送另外一个报文段；这最后一个报文段<strong>对服务器的允许连接的报文段进行了确认，该SYN比特被置为0</strong>:该三次握手的第三个阶段可以在报文段负载中携带客户到服务器的数据<br>
<img src="https://lixin-scut.github.io//post-images/1582791159940.png" alt=""></p>
<h3 id="四次挥手">四次挥手</h3>
<p>1.TCP向服务器进程发送一个特殊的TCP报文段.标志位即<strong>FIN比特被设置为1</strong><br>
2.服务器向发送方回送一个<strong>确认报文段</strong><br>
3.服务器发送它自己的终止报文段，其<strong>FIN比特被置为1</strong><br>
4.最后，该客户对这个服务器的<strong>终止报文段进行确认</strong><br>
要点：在TIME_WAIT状态，假定ACK丢失，服务器将会重发FIN，TIME_WAIT状态使TCP客户重传最后的确认报文<br>
<img src="https://lixin-scut.github.io//post-images/1582791168775.png" alt=""></p>
<h3 id="为什么要三次握手两次和四次呢">为什么要三次握手，两次和四次呢？</h3>
<p>网络上这个问题有很多回答，可惜很多回答（的类比）都是错的<br>
正解为：TCP 的可靠连接是靠 seq（ sequence numbers 序列号）来达成的，三次握手是为了保证通信双方数据原点的序列号正确传输</p>
<p>当客户端向服务器端发送一个连接请求时，由于某种原因长时间驻留在网络节点中，无法达到服务器端，由于TCP的超时重传机制，当客户端在特定的时间内没有收到服务器端的确认应答信息，则会重新向服务器端发送连接请求（使用另外一个短款），且该连接请求得到服务器端的响应并正常建立连接，进而传输数据，当数据传输完毕，并释放了此次TCP连接。若此时第一次发送的连接请求报文段延迟了一段时间后，到达了服务器端，本来这是一个早已失效的报文段，但是服务器端收到该连接请求后误以为客户端又发出了一次新的连接请求，于是服务器端向客户端发出确认应答报文段，并同意建立连接。如果没有采用三次握手建立连接，由于服务器端发送了确认应答信息，则表示新的连接已成功建立 <strong>（注意比三次握手缺少了对服务器端的序列号的确认）</strong> ，但是客户端此时并没有向服务器端发出任何连接请求，因此客户端忽略服务器端的确认应答报文，更不会向服务器端传输数据。而服务器端却认为新的连接已经建立了，并在一直等待客户端发送数据，这样服务器端一直处于等待接收数据，直到超出计数器的设定值，则认为服务器端出现异常，并且关闭这个连接。在这个等待的过程中，浪费服务器的资源。如果采用三次握手，客户端就不会向服务器发出确认应答消息，服务器端由于没有收到客户端的确认应答信息，从而判定客户端并没有请求建立连接，从而不建立该连接。</p>
<p>详细解释：</p>
<p>TCP 设计中一个基本设定就是，通过TCP 连接发送的每一个包，都有一个sequence number。而因为每个包都是有序列号的，所以都能被确认收到这些包。确认机制是累计的，所以一个对sequence number X 的确认，意味着 X 序列号之前(不包括 X) 包都是被确认接收到的。</p>
<p>TCP 协议是不限制一个特定的连接（两端 socket 一样）被重复使用的。<br>
所以这样就有一个问题：这条连接突然断开重连后，TCP 怎么样识别之前旧链接重发的包？——这就需要独一无二的 ISN（初始序列号）机制。<br>
当一个新连接建立时，初始序列号（ initial sequence number ISN）生成器会生成一个新的32位的 ISN。</p>
<p>三次握手（A three way handshake）是必须的， 因为 sequence numbers（序列号）没有绑定到整个网络的全局时钟（全部统一使用一个时钟，就可以确定这个包是不是延迟到的）以及 TCPs 可能有不同的机制来选择 ISN（初始序列号）。接收方接收到第一个 SYN 时，没有办法知道这个 SYN 是否延迟了很久了，除非他有办法记住在这条连接中，最后接收到的那个sequence numbers（然而这不总是可行的）。</p>
<p>（假设为两次握手）一个 seq 过来了，跟现在记住的 seq 不一样，我怎么知道他是上条延迟的，还是上上条延迟的呢？所以，接收方一定需要跟发送方确认 SYN。</p>
<p>TCP作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上两方面的需求！</p>
<p>TCP可靠传输的精髓：TCP连接的一方A，由操作系统动态随机选取一个32位长的序列号（Initial Sequence Number），假设A的初始序列号为1000，以该序列号为原点，对自己将要发送的每个字节的数据进行编号，1001，1002，1003…，并把自己的初始序列号ISN告诉B，让B有一个思想准备，什么样编号的数据是合法的，什么编号是非法的，比如编号900就是非法的，同时B还可以对A每一个编号的字节数据进行确认。如果A收到B确认编号为2001，则意味着字节编号为1001-2000，共1000个字节已经安全到达。</p>
<p>同理B也是类似的操作，假设B的初始序列号ISN为2000，以该序列号为原点，对自己将要发送的每个字节的数据进行编号，2001，2002，2003…，并把自己的初始序列号ISN告诉A，以便A可以确认B发送的每一个字节。如果B收到A确认编号为4001，则意味着字节编号为2001-4000，共2000个字节已经安全到达。</p>
<p>四次握手的过程：<br>
1.1 A 发送同步信号SYN + A's Initial sequence number<br>
1.2 B 确认收到A的同步信号，并记录 A's ISN 到本地，命名 B's ACK sequence number<br>
1.3 B发送同步信号SYN + B's Initial sequence number<br>
1.4 A确认收到B的同步信号，并记录 B's ISN 到本地，命名 A's ACK sequence number<br>
很显然1.2和1.3 这两个步骤可以合并，只需要三次握手，可以提高连接的速度与效率。</p>
<p>二次握手的过程：<br>
2.1 A 发送同步信号SYN + A's Initial sequence number<br>
2.2 B发送同步信号SYN + B's Initial sequence number + B's ACK sequence number<br>
这里有一个问题，A与B就A的初始序列号达成了一致，这里是1000。但是B无法知道A是否已经接收到自己的同步信号，如果这个同步信号丢失了，A和B就B的初始序列号将无法达成一致。</p>
<p>于是TCP的设计者将SYN这个同步标志位SYN设计成占用一个字节的编号（FIN标志位也是），既然是一个字节的数据，按照TCP对有数据的TCP segment 必须确认的原则，所以在这里A必须给B一个确认，以确认A已经接收到B的同步信号。<br>
有童鞋会说，如果A发给B的确认丢了，该如何？<br>
A会超时重传这个ACK吗？不会！TCP不会为没有数据的ACK超时重传。<br>
那该如何是好？B如果没有收到A的ACK，会超时重传自己的SYN同步信号，一直到收到A的ACK为止。</p>
<h3 id="为什么需要四次挥手">为什么需要四次挥手</h3>
<p>这里就是涉及一个半关闭问题<br>
（1）第一次挥手     因此当主动方发送断开连接的请求（即FIN报文）给被动方时，仅仅代表主动方不会再发送数据报文了，但主动方仍可以接收数据报文。    （2）第二次挥手     被动方此时有可能还有相应的数据报文需要发送，因此需要先发送ACK报文，告知主动方“我知道你想断开连接的请求了”。这样主动方便不会因为没有收到应答而继续发送断开连接的请求（即FIN报文）。<br>
（3）第三次挥手    被动方在处理完数据报文后，便发送给主动方FIN报文；这样可以保证数据通信正常可靠地完成。发送完FIN报文后，被动方进入LAST_ACK阶段（超时等待）。<br>
（4）第四挥手    如果主动方及时发送ACK报文进行连接中断的确认，这时被动方就直接释放连接，进入可用状态。</p>
<h3 id="syn洪泛攻击">SYN洪泛攻击</h3>
<p>经典的DoS攻击即SYN洪泛攻击：攻击者发送大量的TCPSYN报文段，而不完成第三次握手的步骤，按照三次握手的要求，包含TCPSYN报文段的IP数据报到达服务器主机,服务器会从该数据报中提取出TCPSYN报文段，为该半开的TCP连接分配TCP缓存和变量，最终导致服务器的资源被耗尽<br>
<img src="https://lixin-scut.github.io//post-images/1582798266226.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[STL sort()底层实现]]></title>
        <id>https://lixin-scut.github.io//post/stl-sortdi-ceng-shi-xian</id>
        <link href="https://lixin-scut.github.io//post/stl-sortdi-ceng-shi-xian">
        </link>
        <updated>2020-02-27T04:05:40.000Z</updated>
        <content type="html"><![CDATA[<p>关于STL<br>
对于配置器来说，肯定是二级配置器用得多<br>
对于迭代器来说，肯定是随机迭代器用得多<br>
对于容器来说，肯定是vector用得多<br>
那对于泛型算法来说，就肯定是sort()用得最多了<br>
所以现在来看一下sort()的底层实现</p>
<p>总结部分：<br>
sort涉及到三种排序方法：快速排序、插入排序和堆排序<br>
首先主体排序是快速排序，快速排序是目前已知最快的排序法，平均复杂度为O(NlogN),最坏情况下将达O(N^2)。<br>
但是快速排序对数量比较少的序列还是需要一定数量的递归，所以针对数量比较少的序列或者子序列（STL源码剖析中的源码设置阈值为16），sort改为使用插入排序，因为插入排序在大致有序的短序列中表现更好。<br>
然后就是针对快速排序的最坏情况，STL采用改用Insertion Sort。如果递归层次过深，还会改用Heap Sort，防止深层递归对栈内存造成太大负担</p>
<p>资料参考：<br>
《STL源码剖析》<br>
STL所提供的各式各样算法中，sort是最复杂最庞大的一个。<br>
这个算法接受两个RandomAccessIterotors （随机存取迭代器），然后将区间内的所有元素以 渐增方式由小到大重新排列。第二个版本则允许用户指定一个仿函数（functor）, 作为排序标准。<br>
STL的所有关系型容器（associative containers）都拥有自动排序功能（底层结构采用RB-tree），所以不需要用到这个算法。至于序列式容器（sequence containers）中的 stack、queue 和 priori ty-queue 都有特别的出入口，不允许用户对元素排序。<br>
剩下vector、deque和list,前两者的迭 代器属于RandomAccessIterators,适合使用sort算法，list的迭代器则属于 Bidirectioinaltterators ,不在STL标准之列的slist ,其迭代器更属于 Forwardlterators,都不适合使用sort算法。如果要对list或slist排序，应该使用它们自己提供的member functions sort()</p>
<p>STL的sort算法，数据量大时采用Quicksort，分段递归排序。一旦分段后的数据量小于某个门槛，为避免Quick Sort的递归调用带来过大的额外负荷 (overhead),就改用Insertion Sort。如果递归层次过深，还会改用Heap Sort。</p>
<p>Insertion Sort以双层循环的形式进行。外循环遍历整个序列，每次迭代决定出一个子区间；内循环遍历子区间，将子区间内的每一个“逆转对(inversion) ” 倒转过来。所谓“逆转对”是指任何两个迭代器i,j，而i &gt; j。一旦不存在“逆转对”，序列即排序完毕。这个算法的复杂度为O(N^2),说起来并不理想，但是当数据量很少时，却有不错的效果，原因是实现上有一些技巧(提前结束循环和减少边界判断)，而且不像其它较为复杂的排序算法有着诸如递归调用等操作带来的额外负荷。图6-12是Insertion Sort的详细步骤示意。</p>
<p>Quick Sort<br>
如果我们拿Insertion Sort来处理大量数据，其O(N^2)的复杂度就令人摇头了。 大数据量的情况下有许多更好的排序算法可供选择。正如其名称所昭示，Quick Sort 是目前已知最快的排序法，平均复杂度为O(NlogN),最坏情况下将达O(N^2)。不过 IntroSort (极类似median-of-three Quicksort的一种排序算法)可将最坏情况推 进到O(NlogN)。早期的STL sort 算法都采用Quick Sort, SGI STL已改用 IntroSort<br>
Quick Sort算法可以叙述如下。假设S代表将被处理的序列:</p>
<ol>
<li>如果S的元素个数为0或1,结束。</li>
<li>取S中的任何一个元素，当作枢轴(pivot)</li>
<li>将S分割为L, R两段，使L内的每一个元素都小于或等于v, R内的每一个 元素都大于或等于V。</li>
<li>对L, R递归执行Quicksort。</li>
</ol>
<p>Quick Sort的精神在于将大区间分割为小区间，分段排序。每一个小区间排序完成后，串接起来的大区间也就完成了排序。最坏的情况发生在分割时产生出一个空的子区间，完全没有达到分割的预期效果。。</p>
<p>Median-of-Three （三点中值）<br>
注意，任何一个元素都可以被选来当作枢轴（pivot)，但是其合适与否却会影响QuickSort的效率。为了避免“元素当初输入时不够随机”所带来的恶化效应,<br>
最理想最稳当的方式就是取整个序列的头、尾、中央三个位置的元素，以其中值 （median）作为枢轴。这种做法称为 median-of-three partitioning ,或称为 mediun-of-three-QuickSort为了能够快速取出中央位置的兀素，显然迭代器必须能够随机定位，亦即必须是个RandomAccessIteratorso</p>
<p>Partitioining (分割)<br>
分割方法不只一种,以下叙述既简单又有良好成效的做法。令头端迭代器first 向尾部移动，尾端迭代器 last 向头部移动。<br>
当 *first 大于或等于枢轴时就停下来 ）当*last小于或等于枢轴时也停下来，然后检验两个迭代器是否交错。<br>
如果first仍然在左而last仍然在右，就将两者元素互换，然后各自调整一个位置（向中央逼近），再继续进行相同的行为。<br>
如果发现两个迭代器交错了（亦即!(first &lt; last)）,表示整个序列已经调整完毕，以此时的first为轴，将序列分为左右两半，左半部所有元素值都小于或等于枢轴，右半部所有元素值都大于或等于枢轴。</p>
<p>threshold （阈值）<br>
面对一个只有十来个元素的小型序列，使用像Quick Sort这样复杂而（可能） 需要大量运算的排序法，是否划算？不，不划算，在小数据量的情况下，甚至简单如Insertion Sort者也可能快过Quick Sort	因为Quick Sort会为了极小的子序<br>
列而产生许多的函数递归调用。<br>
鉴于这种情况，适度评估序列的大小,然后决定采用Quick Sort或Insertion Sort, 是值得采纳的一种优化措施。然而究竟多小的序列才应该断然改用Insertion Sort 呢？唔，并无定论，5〜20都可能导致差不多的结果，实际的最佳值因设备而异。</p>
<p>final insertion sort<br>
优化措施永不嫌多，只要我们不是贸然行事（Donald Knuth说过一件名言： 贸然实施优化，是所有恶果的根源，premature optimization is the root of all evil）。 如果我们令某个大小以下的序列滞留在“几近排序但尚未完成”的状态，最后再以一次Insertion Sort将所有这些“几近排序但尚未竟全功”的子序列做一次完整 的排序，其效率一般认为会比“将所有子序列彻底排序”更好。这是因为Insertion Sort在面对“几近排序”的序列时，有很好的表现。</p>
<p>introsort<br>
不当的枢轴选择，导致不当的分割，导致Quick Sort恶化为O(N^2）。David R.<br>
Musser （此君于STL领域大大有名）于1996年提出一种混合式排序算法：<br>
Introspective Sorting （内省式排序）,简称IntroSort,其行为在大部分情况下几 乎与median-of-3 Quick Sort完全相同（当然也就一样快）。但是当分割行为<br>
（partitioning）有恶化为二次行为的倾向时，能够自我侦测，转而改用Heap Sort, 使效率维持在Heap Sort的O(NlogN）,又比一开始就使用Heap Sort来得好。稍后便可看到SGI STL源代码中对IntroSort的实现。<br>
<img src="https://lixin-scut.github.io//post-images/1582788128159.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582788145255.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582788159528.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++函数参数入栈]]></title>
        <id>https://lixin-scut.github.io//post/chan-shu-can-shu-ru-zhan</id>
        <link href="https://lixin-scut.github.io//post/chan-shu-can-shu-ru-zhan">
        </link>
        <updated>2020-02-27T03:36:52.000Z</updated>
        <content type="html"><![CDATA[<p>参数入栈顺序<br>
c++提供了5种参数传递标准，除了main函数传递必须用_cdecl模式，其他函数可以自己在编译器设置，默认的是_cdecl模式，即从右到左入栈</p>
<p><img src="https://lixin-scut.github.io//post-images/1582774670953.png" alt=""></p>
<p>为什么采用从右到左的参数方式,而不使用从左到右的传参方式呢?<br>
　　主要原因就在于<strong>变长参数</strong><br>
　　一般我们命名一个变长函数时都类似于int display(int i, ...);这种格式,注意参数都是用压栈方式实现的,<br>
　　假如使用从左到右的传参方式：栈顶看到的是最后一个参数,那么怎样知道首参数是哪一个呢?因此要想知道首参数的值,则必须要知道参数的长度.而栈里并不知道这个长度,那么就无法通过指针偏移的方式找到首参数.<br>
　　而如果使用从右到左的传参方式,栈顶看到的就是左边输入的首参数,因此,无论怎样的变长,都可以通过指针偏移的方式找到值.</p>
<p>需要注意的是</p>
<ol>
<li>在将参数入栈前，编译器会先把参数的的表达式都处理掉，哪怕这些运算会改变其中某些参数的值</li>
<li>对于后置++操作，编译器会开辟一个缓冲区来保存当前的值，然后再对参数操作，取值时是从缓冲区取，而不是直接从参数的内存地址里取。</li>
</ol>
<p>例子</p>
<pre><code> int a = 10;
 printf(&quot;%d %d %d %d\n&quot;, a++, ++a, a, a++);
 // 输出为10 12 12 12
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[强制类型转换]]></title>
        <id>https://lixin-scut.github.io//post/qiang-zhi-lei-xing-zhuan-huan</id>
        <link href="https://lixin-scut.github.io//post/qiang-zhi-lei-xing-zhuan-huan">
        </link>
        <updated>2020-02-27T02:27:10.000Z</updated>
        <content type="html"><![CDATA[<p>dynamic_cast：<br>
　　① 转换类型必须是一个指针、引用或者void*，用于将基类的指针或引用安全地转换成派生类的指针或引用；<br>
　　② dynamic_cast在运行期间强制转换，运行时进行类型转换检查；<br>
　　③ 对指针进行转换，失败返回null，成功返回type类型的对象指针，对于引用的转换，失败抛出一个bad_cast ，成功返回type类型的引用；<br>
　　④ dynamic_cast不能用于内置类型的转换；<br>
　　⑤ 用于类的转换，基类中一定要有virtual定义的虚函数（保证多态性），不然会编译错误。<br>
　　dynamic_cast和传统的(type)(expression)强制转换的最大区别在于提供了运行时的类型检查，保证了类型安全，使用强制转换，会跳过编译器的类型检查，但可能会造成运行时异常，导致程序直接崩溃</p>
<p>static_cast：<br>
　　用于非多态类型的转换（静态转换），对应于C中的隐式类型转换，但他不能用于两个不相关类型的转换，不能在没有派生关系的两个类类型之间转换，不能去除掉原有类型的类型修饰符，转换对象时由于没有动态类型检查，所以由基类对象转换成派生类对象的时候存在安全隐患<br>
　　① 用于类层次结构中基类和派生类之间指针或引用的转换，其中——向上转换是安全的，向下转换是不安全的，但两者均可以通过编译，也就是说开发者要负责强转的运行时安全性，这一点，不如dynamic_cast安全；与dynamic_cast作用类似，将expression转换为type类型，区别在于，static发生于编译时，dynamic发生于运行时。<br>
　　② 可以用于内置类型的转换。<br>
　　转换的精度损失一般由开发者负责，但使用了static_cast运算符之后，等于告诉编译器，“我知道这里发生了类型转换，我会为转换的安全性负责，你不用管了”，编译器不会发出编译警告，除非你类型转换完全非法（比如 int a = static_cast(“Hello world!”); ），static_cast才会报编译错误；<br>
　　③ 把void* 转换成目标类型的指针；<br>
　　④ 把任意类型转换成void类型；<br>
　　⑤ static_cast无法转换<code>expression的const/volitale/__unaligned</code>属性（会报编译时错误）。</p>
<p>const_cast：<br>
　　弥补了static_cast无法转换底层const/volitale的不足，将expression的const/volitale属性移除，仅限于底层const属性.<br>
　　① 顶层const：表示指针变量是const的，比如int* const pointer； 底层const： 表示指针所指向的变量是const的，比如const int* pointer;。理解记忆：所谓底层const就是指我这个变量“底子”就是const，。反之，则是顶层const。<br>
　　② 目标类型只能是指针或者引用，const_cast不能执行其他任何类型转换，只能用于同类型之间不同const/ volitale属性的移除。否则会报编译时错误。<br>
　　③ 需要注意的是，const_cast通常对指针和引用进行转换，而无法直接移除内置类型的const/volitale属性，换言之，这种语法直接提供了一个具有写权限的指针或引用，可以通过间接访问的方式，修改常量。</p>
<p>注意：顶层const不需要转换，因为转换后也是用于赋值等用途，顶层const本身<br>
就不影响，所以无需转换。	<br>
reinterpret_cast：<br>
　　reinterpret_cast 允许将任何指针转换为任何其他指针类型。 也允许将任何整数类型转换为任何指针类型以及反向转换。<br>
　　① reinterpret_cast 运算符可用于 char* 到 int* 或 One_class* 到 Unrelated_class* 之类的转换，这本身并不安全，但可以通过编译；<br>
　　② reinterpret_cast 的本质作用是重新定义内存数据的解释方式，而不进行任何二进制转换。</p>
<p>C语言的旧式类型转换不能进行类型的检查和错误检查，转化不明确，尽量不要使用</p>
<p>参考资料<br>
《C++ primer》<br>
4.11.3显式转换<br>
　　显式转换本质上非常危险<br>
　　强制类型转换 <code>cast-name&lt;type&gt;(expression);</code><br>
　　注意不要漏掉express的括号<br>
　　cast-name指定执行哪种变换，可以为static_cast 、dynamic_cast、 const_cast和 reinterpret_cast</p>
<ol>
<li>static_cast<br>
　　只要不包含底层const都能用<br>
　　例如把void*指针的值找回来<br>
<code>double slope = static_cast&lt;double&gt;(j) /i; //强制类型转换进行浮点数除法</code><br>
<code>void *p = &amp;d; double *dp = static_cast&lt;double*&gt;(p); //把void*指针的值找回来</code></li>
<li>const_cast<br>
　　只能改变运算对象底层的const<br>
　　比如把const char*变为char* 而不能变成string</li>
<li>reinterpret_cast 尽量不要使用<br>
　　reinterpret_cast为对象的位模式提供较低层次上的重新解释（对位模式的数据重新进行解释，非常危险）</li>
<li>dynamic_cast运算符<br>
用于将基类的指针或引用安全地转换成派生类的指针或引用。<br>
注意，如果想要从派生的指针或引用转换为类的指针或引用，需要用static_cast，dynamic_cast无法执行这个操作</li>
</ol>
<p>函数形式的强制类型转换 type(expr) 	C语言风格的强制类型转换(type) expr</p>
<p>dynamic_cast运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用。<br>
dynamic_cast运算符<br>
<img src="https://lixin-scut.github.io//post-images/1582771211814.png" alt=""><br>
其中，type必须是一个类类型，并且通常情况下该类型应该含有虚函数。在第一种形式中，e必须是一个有效的指针（参见2.3.2节，第47页）；在第二种形式中，e必须是一个左值；在第三种形式中，e不能是左值。<br>
在上面的所有形式中，e的类型必须符合以下三个条件中的任意一个：<br>
1.e的类型是目标type的公有派生类、<br>
2.e的类型是目标化type的公有基类或者<br>
3.e的类型就是目标type的类型。<br>
如果符合，则类型转换可以成功。否则，转换失败。如果一条dynamic_cast语句的转换目标是指针类型并且失败了，则结果为0。如果转换目标是引用类型并且失败了，则dynamic_cast运算符将抛出一个bad_cast异常。（公有是什么意思）<br>
注意！符合上面三个条件不等于就能转换成功，程序不会报错但是会转换失败</p>
<p>指针类型的dynamic_cast<br>
<img src="https://lixin-scut.github.io//post-images/1582771215858.png" alt=""><br>
我们可以对一个空针执行dynamic_cast,结果是所需类型的空指针。<br>
值得注意的一点是，我们在条件部分定义了dp,这样做的好处是可以在一个操作中同时完成类型转换和条件检查两项任务。而且，指针dp在if语句外部是不可访问的。一旦转换失败，即使后续的代码忘了做相应判断，也不会接触到逐个未绑定的指针，从而确保程序是安全的。（if条件部分定义的变量只能在fi内部使用，外部不可访问！）<br>
在条件部分执行dynamic_cast操作可以确保类型转换和结果检查在同一条表达式中完成。</p>
<p>引用类型的dynamic_cast<br>
引用类型的dynamic_cast与指针类型的dynamic_cast在表示错误发生的方式上略有不同。因为不存在所谓的空引用，所以对于引用类型来说无法使用与指针类型完全相同的错误报告策略。当对引用的类型转换失败时，程序抛出一个名为std::bad_cast的异常，该异常定义在typeinfo标准库头文件中。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[构造函数]]></title>
        <id>https://lixin-scut.github.io//post/gou-zao-han-shu</id>
        <link href="https://lixin-scut.github.io//post/gou-zao-han-shu">
        </link>
        <updated>2020-02-27T01:59:04.000Z</updated>
        <content type="html"><![CDATA[<p>按照参数进行分类</p>
<ol>
<li>无参构造函数（默认构造函数）</li>
<li>有参构造函数</li>
</ol>
<p>按照类型进行分类</p>
<ol>
<li>普通构造函数</li>
<li>拷贝构造函数</li>
</ol>
<p>这两种分类组合起来又可以有多种类型</p>
<p>使用场景和方法</p>
<ol>
<li>直接使用<br>
Base b；</li>
<li>空括号调用<br>
Base b();</li>
<li>带参调用<br>
Base b(anob);</li>
<li>=号调用<br>
Base b = anob;</li>
</ol>
<p>例子：</p>
<pre><code>class TestChild
{
public:
    TestChild()
    {
        x=0;
        y=0;
        printf(&quot;TestChild: Constructor be called!\n&quot;);
    }
    ~TestChild(){}
    TestChild(const TestChild&amp; tc)
    {
        x=tc.x;
        y=tc.y;
        printf(&quot;TestChild: Copy Constructor called!//因为写在了Test(拷贝)构造函数的初始化列表里\n&quot;);
    }
    
    const TestChild&amp; operator=(const TestChild&amp; right)
    {
        x=right.x;
        y=right.y;
        printf(&quot;TestChild: Operator = be called! //因为写在了Test(拷贝)构造函数的函数体里\n&quot;);
        return *this;
    }

    int x,y;
};

class Test
{
public:

    Test(){printf(&quot;Test:      Constructor be called!\n&quot;);}
    explicit Test(const TestChild&amp; tcc)
    {
        tc=tcc;
    }
    ~Test(){}
    Test(const Test&amp; test):tc(test.tc)
    {
        tc=test.tc;
        printf(&quot;Test:      Copy Constructor be called!\n&quot;);
    }

    const Test &amp; operator=(const Test&amp; right)
    {
        tc=right.tc;
        printf(&quot;Test:      Operator= be called!\n&quot;);
        return *this;
    }

    TestChild tc;
};

int main()
{
    printf(&quot;1、Test中包含一个TestChild，这两个类分别具有构造函数、\n   拷贝构造函数、重载operator=。\n\n&quot;);
    printf(&quot;2、在调用Test的构造函数和拷贝构造函数之前，会根据跟在\n   这些函数后的初始化列表去初始化其\n   TestChild变量（调用TestChild的拷贝构造函数去初始化）\n\n&quot;);
    printf(&quot;3、一旦进入Test的构造函数体或拷贝构造函数体，则说明其成员变量TestChild已\n   经通过TestChild的构造函数或TestChild的拷贝构造函数构造出了对象\n&quot;);
    printf(&quot;   所以，在Test的构造函数体或拷贝构造函数体中，再去使用=号\n   给TestChild的时候，调用的就是TestChild的operator=，\n   而不是TestChild的拷贝构造函数了\n&quot;);
    printf(&quot;   这就是Test构造函数后面 “:” 初始化列表的存在意义！（\n   为了调用成员变量的构造函数或者拷贝构造函数）\n\n&quot;);
    printf(&quot;4、最后！揪出让人困惑的原因\n   Test test2=test1和Test test2(test1)这两种是一模一样的\n   （都调用拷贝构造函数）除了这点儿之外，其他地方都是该是什么是什么（\&quot;()\&quot;调用构造函数，\&quot;=\&quot;调用赋值操作符）！！！\n\n&quot;);
    printf(&quot;5、一个对象初始化完毕后，所有对这个对象的赋值都调用operator=\n\n输出如下：&quot;);

    printf(&quot;Test test1; DO:\n&quot;);
    Test test1;
    printf(&quot;\n&quot;);
    printf(&quot;Test test2=test1; DO:\n&quot;);
    Test test2=test1;
    printf(&quot;\n&quot;);
    printf(&quot;Test test3(test2); DO:\n&quot;);
    Test test3(test2);
    printf(&quot;\n&quot;);
    printf(&quot;test3=test1; DO:\n&quot;);
    test3=test1;

     return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++三大特性：封装、继承和多态性]]></title>
        <id>https://lixin-scut.github.io//post/csan-da-te-xing-feng-zhuang-ji-cheng-he-duo-tai-xing</id>
        <link href="https://lixin-scut.github.io//post/csan-da-te-xing-feng-zhuang-ji-cheng-he-duo-tai-xing">
        </link>
        <updated>2020-02-27T01:37:54.000Z</updated>
        <content type="html"><![CDATA[<p>封装：<br>
　　所谓封装就是将封装实现了类的接口和实现的分离，隐藏了类的实现细节，只能通过某些特定的方式才能访问。封装的目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只是通过外部接口以及特定的访问权限来使用类的成员。<br>
　　封装性实际上是由编译器去识别关键字public、private和protected来实现的，体现在类的成员可以有公有成员(public)，私有成员(private)，保护成员(protected)。私有成员是在封装体内被隐藏的部分，只有类体内说明的函数(类的成员函数)才可以访问私有成员，而在类体外的函数时不能访问的，公有成员是封装体与外界的一个接口，类体外的函数可以访问公有成员，保护成员是只有该类的成员函数和该类的派生类才可以访问的。<br>
　　优点：隔离变化；便于使用；提高重用性；提高安全性</p>
<p>多态：<br>
　　OOP的核心思想是多态性（polymorphism)。我们把具有继承关系的多个类型称为多态类型.<br>
　　多态可以使我们以相同的方式处理不同类型的对象，我们可以使用一段代码处理不同类型的对象，只要他们继承/实现了相同的类型。这样我们没有必要为每一种类型的对象编写相同的逻辑，极大的提高了代码的重用。其实，用简单的一句话来形容就是：多态性，允许将子类类型的指针赋值给父类类型的指针，多态性在C++中是通过虚函数实现的。虚函数就是允许被其子类重新定义的成员函数。而子类重新定义父类虚函数的做法，称为“覆盖”，或者称为“重写”。子类重写父类中虚函数时，即使不用virtual声明，该重载函数也是虚函数。<br>
　　C++有两种多态，称为动多态（运行期多态）和静多态（编译器多态），静多态主要是通过函数重载和模板来实现，而动多态是通过虚函数来实现的。即在基类中存在虚函数（一般为纯虚函数）子类通过重载这些接口，使用基类的指针或者引用指向子类的对象，就可以调用子类对应的函数，动多态的函数调用机制是执行器期才能确定的，所以他是动态的。</p>
<p>继承<br>
　　继承是指一个对象直接使用另一个对象的属性和方法。继承是面向对象的一个重要概念，如果一个类B继承自另一个类A，就把这个类B称为“A的子类”，而把A称为“B的父类”。继承可以使得子类具有父类的各种属性和方法，而不需要再次编写相同的代码，在令子类继承父类的同时，可以重新定义某些属性，并重新某些方法，即覆盖父类的原有属性和方法，使其获得与父类不同的功能。<br>
　　继承方式有公有继承、私有继承，保护继承，默认是私有继承。</p>
<ul>
<li>公有继承中父类的公有和保护成员在子类中不变，私有的在子类中不可访问。</li>
<li>私有继承中父类的公有和保护成员在子类中变为私有，但私有的在子类中不可访问。</li>
<li>保护继承中父类的公有和保护成员在子类中变为保护，但私有的在子类中不可访问。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[栈 题30:包含min函数的栈]]></title>
        <id>https://lixin-scut.github.io//post/zhan-ti-30bao-han-min-han-shu-de-zhan</id>
        <link href="https://lixin-scut.github.io//post/zhan-ti-30bao-han-min-han-shu-de-zhan">
        </link>
        <updated>2020-02-26T15:58:57.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。<br>
注意：保证测试中不会当栈为空的时候，对栈调用pop()或者min()或者top()方法。</p>
</blockquote>
<pre><code>class Solution {
public:
    void push(int value) {
        norm_stack.push(value);
        if(min_stack.empty()||value&lt;=min_stack.top())
            min_stack.push(value);
        else if(value&gt;min_stack.top())
            min_stack.push(min_stack.top());
    }
    void pop() {
        if(norm_stack.empty())
            return;
        norm_stack.pop();
        min_stack.pop();
    }
    int top() {
        if(norm_stack.empty())
            return -1;
        return norm_stack.top();
    }
    int min() {
        if(min_stack.empty())
            return -1;
        return min_stack.top();
    }

private:
    stack&lt;int&gt; norm_stack;
    stack&lt;int&gt; min_stack;
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>看到这个问题，我们的第一反应可能是每次压入一个新元素进栈时，将栈里的所有元素排序，让最小的元素位于栈顶，这样就能在0(1)时间内得到 小元素了。但这种思路不能保证最后压入栈的元素能够最先出栈，因此这个数据结构已经不是栈了。<br>
我们接着想到在栈里添加一个成员变量存放最小的元素。每次压入一个新元素进栈的时候，如果该元素比当前最小的元素还要小，则更新最小元素。但如果当前最小的元素被弹出栈了，那么如何得到下一个最小的元素呢？<br>
分析到这里我们发现，仅仅添加一个成员变量存放最小元素是不够的， 也就是说当最小元素被弹出栈的时候，我们希望能够得到次小元素。因此, 在压入这个最小元素之前，我们要把次小元素保存起来。<br>
所以可以把每次的最小元素（之前的最小元素和新压入栈的元素两者的较小值）都保存起来放到另外一个辅助栈里</p>
</blockquote>
<pre><code>template &lt;typename T&gt; class StackWithMin
{
public:
    StackWithMin() {}
    virtual ~StackWithMin() {}

    T&amp; top();
    const T&amp; top() const;

    void push(const T&amp; value);
    void pop();

    const T&amp; min() const;

    bool empty() const;
    size_t size() const;

private:
    std::stack&lt;T&gt;   m_data;     // 数据栈，存放栈的所有元素
    std::stack&lt;T&gt;   m_min;      // 辅助栈，存放栈的最小元素
};

template &lt;typename T&gt; void StackWithMin&lt;T&gt;::push(const T&amp; value)
{
    // 把新元素添加到辅助栈
    m_data.push(value);

    // 当新元素比之前的最小元素小时，把新元素插入辅助栈里；
    // 否则把之前的最小元素重复插入辅助栈里
    if(m_min.size() == 0 || value &lt; m_min.top())
        m_min.push(value);
    else
        m_min.push(m_min.top());
}

template &lt;typename T&gt; void StackWithMin&lt;T&gt;::pop()
{
    assert(m_data.size() &gt; 0 &amp;&amp; m_min.size() &gt; 0);

    m_data.pop();
    m_min.pop();
}


template &lt;typename T&gt; const T&amp; StackWithMin&lt;T&gt;::min() const
{
    assert(m_data.size() &gt; 0 &amp;&amp; m_min.size() &gt; 0);

    return m_min.top();
}

template &lt;typename T&gt; T&amp; StackWithMin&lt;T&gt;::top()
{
    return m_data.top();
}

template &lt;typename T&gt; const T&amp; StackWithMin&lt;T&gt;::top() const
{
    return m_data.top();
}

template &lt;typename T&gt; bool StackWithMin&lt;T&gt;::empty() const
{
    return m_data.empty();
}

template &lt;typename T&gt; size_t StackWithMin&lt;T&gt;::size() const
{
    return m_data.size();
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 题29:顺时针打印矩阵]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-ti-29shun-shi-zhen-da-yin-ju-zhen</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-ti-29shun-shi-zhen-da-yin-ju-zhen">
        </link>
        <updated>2020-02-25T15:11:48.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述<br>
输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<p>注意要在循环条件中加上范围是否超标的判断</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt; matrix) {
        vector&lt;int&gt; res;
        if(matrix.empty())
               return res;
        int top,bottom,left,right,i;
        top=0,left=0;
        bottom=matrix.size()-1,right=matrix[0].size()-1;
        while(top&lt;=bottom&amp;&amp;left&lt;=right){

                for(i=left;i&lt;=right&amp;&amp;top&lt;=bottom;++i)
                    res.push_back(matrix[top][i]);
                ++top;


                for(i=top;i&lt;=bottom&amp;&amp;left&lt;=right;++i)
                    res.push_back(matrix[i][right]);
                --right;

                for(i=right;i&gt;=left&amp;&amp;top&lt;=bottom;--i)
                    res.push_back(matrix[bottom][i]);
                --bottom;

                for(i=bottom;i&gt;=top&amp;&amp;left&lt;=right;--i)
                    res.push_back(matrix[i][left]);
                ++left;
        }
        return res;
    }
};
</code></pre>
<p>书本题解：<br>
这道题完全没有涉及复杂的数据结构或者高级的算法，看起来是一个 很简单的问题。但实际上解决这个问题时会在代码中包含多个循环，并且 需要判断多个边界条件。<br>
假设这个矩阵的行数是rows,列数是 columns。我们注意到，左上角的坐标中行标和列标总是相同的，于是可 以在矩阵中选取左上角为(start, start)的一圈作为我们分析的目标。<br>
值得注意的是，最后一圈有可能退化成只有一行、只有一列，甚至只有一个数字。<br>
因此，我们要仔细分析打印时每一步的前提条件。第一步总是需要的， 因为打印一圈至少有一步。如果只有一行，那就不用第二步了。也就是需 要第二步的前提条件是终止行号大于起始行号。需要第三步打印的前提条 件是圈内至少有两行两列，也就是说，除了要求终止行号大于起始行号， 还要求终止列号大于起始列号。同理，需要打印第四步的前提条件是至少 有三行两列，因此要求终止行号比起始行号至少大2,同时终止列号大于起始列号。</p>
<pre><code>void PrintMatrixClockwisely(int** numbers, int columns, int rows)
{
    if(numbers == nullptr || columns &lt;= 0 || rows &lt;= 0)
        return;

    int start = 0;

    while(columns &gt; start * 2 &amp;&amp; rows &gt; start * 2)
    {
        PrintMatrixInCircle(numbers, columns, rows, start);

        ++start;
    }
}

void PrintMatrixInCircle(int** numbers, int columns, int rows, int start)
{
    int endX = columns - 1 - start;
    int endY = rows - 1 - start;

    // 从左到右打印一行
    for(int i = start; i &lt;= endX; ++i)
    {
        int number = numbers[start][i];
        printNumber(number);
    }

    // 从上到下打印一列
    if(start &lt; endY)
    {
        for(int i = start + 1; i &lt;= endY; ++i)
        {
            int number = numbers[i][endX];
            printNumber(number);
        }
    }

    // 从右到左打印一行
    if(start &lt; endX &amp;&amp; start &lt; endY)
    {
        for(int i = endX - 1; i &gt;= start; --i)
        {
            int number = numbers[endY][i];
            printNumber(number);
        }
    }

    // 从下到上打印一行
    if(start &lt; endX &amp;&amp; start &lt; endY - 1)
    {
        for(int i = endY - 1; i &gt;= start + 1; --i)
        {
            int number = numbers[i][start];
            printNumber(number);
        }
    }
}

void printNumber(int number)
{
    printf(&quot;%d\t&quot;, number);
}
</code></pre>
<p>对比书本的，我觉得还是我的方法更加简便，所以不能只以书为准，要多看看别人的做法</p>
]]></content>
    </entry>
</feed>