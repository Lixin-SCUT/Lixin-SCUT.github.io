<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-11-23T15:41:02.427Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[树 199.二叉树右视图[中等]]]></title>
        <id>https://lixin-ee.github.io//post/shu-199er-cha-shu-you-shi-tu-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/shu-199er-cha-shu-you-shi-tu-zhong-deng">
        </link>
        <updated>2019-11-23T15:22:12.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。<br>
示例:<br>
输入: [1,2,3,null,5,null,4]<br>
输出: [1, 3, 4]<br>
解释:<br>
1            &lt;---<br>
/   <br>
2     3         &lt;---<br>
\     <br>
5     4       &lt;---<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/binary-tree-right-side-view<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>我的想法很简单，直接是从层次遍历的想法，但是主要的点在于先遍历根节点-右节点-左节点，同时使用i来记录层数，并且只记录第一个出现的值。<br>
还有一个优化点是传vector的引用而不是建立一个全局的vector<br>
代码如下</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; rightSideView(TreeNode* root) {
        vector&lt;int&gt; res;
        preorder(root,0,res);
        return res;
    }
    
    void preorder(TreeNode *cur,int i,vector&lt;int&gt; &amp;res){
        if(cur==NULL)
            return;
        if(res.size()==i)
            res.push_back(cur-&gt;val);
        preorder(cur-&gt;right,i+1,res);
        preorder(cur-&gt;left,i+1,res);
        return;
    }
};
</code></pre>
<p>首先是网友题解</p>
<blockquote>
<p>这道题有递归和非递归两种方法，首先来看递归方法。<br>
递归方法是分别遍历一个节点的右节点和左节点，因为是从右边看过来，所以我们需要首先遍历右节点。这里有个疑问，当遍历左节点时候，怎么判定它右边没有其他节点了呢？这里我们用到一个变量level，对于同一层的节点，如果res数组的大小已经等于level了，说明右边已经有节点存入数组了，该节点就不用再保存。一直递归下去就可以得到结果。<br>
代码一：</p>
</blockquote>
<pre><code>C++
class Solution {
public:
    vector&lt;int&gt; rightSideView(TreeNode* root) {
        vector&lt;int&gt; res;
        helper(root,0,res);
        return res;        
    }
    void helper(TreeNode* root,int level,vector&lt;int&gt;&amp; res){
        if(!root) return;
        if(res.size()==level) res.push_back(root-&gt;val);
        helper(root-&gt;right,level+1,res);
        helper(root-&gt;left,level+1,res);
    }
};
</code></pre>
<blockquote>
<p>下面看一下非递归的方法。这道题要求我们打印出二叉树每一行最右边的一个数字，实际上是求二叉树层序遍历的一种变形，我们只需要保存每一层最右边的数字即可，还是需要用到数据结构队列queue，遍历每层的节点时，把下一层的节点都存入到queue中，每当开始新一层节点的遍历之前，先把新一层最后一个节点值存到结果中，代码如下：<br>
C++</p>
</blockquote>
<pre><code>class Solution {
public:
    vector&lt;int&gt; rightSideView(TreeNode* root) {
        vector&lt;int&gt; res;
        if(!root) return res;
        queue&lt;TreeNode*&gt; q;
        q.push(root);
        while(!q.empty()){
            res.push_back(q.back()-&gt;val);
            int size=q.size();
            for(int i=0;i&lt;size;++i){
                TreeNode* t=q.front(); q.pop();
                if(t-&gt;left) q.push(t-&gt;left);
                if(t-&gt;right) q.push(t-&gt;right);
            }           
        }
        return res;
    }
};
</code></pre>
<p>官方题解我感觉一般般，而且用的java差异较大，但是涉及广度优先遍历，有兴趣的话可以看看</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 103.二叉树的锯齿形层次遍历 [中等]]]></title>
        <id>https://lixin-ee.github.io//post/shu-103er-cha-shu-de-ju-chi-xing-ceng-ci-bian-li-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/shu-103er-cha-shu-de-ju-chi-xing-ceng-ci-bian-li-zhong-deng">
        </link>
        <updated>2019-11-22T12:48:54.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。<br>
例如：<br>
给定二叉树 [3,9,20,null,null,15,7],<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7<br>
返回锯齿形层次遍历如下：<br>
[<br>
[3],<br>
[20,9],<br>
[15,7]<br>
]<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题我是直接看的网友题解，倒不是不会做，只是没有比较好的想法<br>
因为这个和前一题不同，前一题我还可以用deque来处理，这一题着实是比较麻烦了（其实也可以用deque，只是相对比较笨的处理方法）<br>
然后网友题解中有个不错的，利用栈来存储，可以选择不同层的时候的入栈顺序，从而实现交替左右（怎么说着说着感觉又蛮麻烦了hhh<br>
所以直接来看网友题解吧</p>
<blockquote>
<p>大家的做法大都是list或者queue反转，但是这是耗时操作，特别是queue自身并不支持反转（list在c++是双向链表，可以相当于有反转功能），用reverse我觉得可能是耗时的，我的解法是两个stack各自保存一层数据，然后先进后出的特性加上左右节点先后入栈的顺序细节（具体谁先谁后可以看代码）即可恰好对应zigZag的Z字形访问顺序：</p>
<p>我的提交执行用时<br>
已经战胜 96.52 % 的 cpp 提交记录</p>
</blockquote>
<pre><code>vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode *root) {
		//右往左时右先入栈，左往右时，左先入栈。然后要两个栈分别保存每一层级的。
		//这里借鉴了树的层次遍历的思想，不过那是用队列
		vector&lt;vector&lt;int&gt;&gt; r;
		if (!root) return r;
		stack&lt;TreeNode *&gt; d1, d2;
		d1.push(root);
		TreeNode *curr = nullptr;
		vector&lt;int&gt; tmp;
		while (true) {
				while (!d1.empty()) {
						curr = d1.top();
						d1.pop();
						tmp.push_back(curr-&gt;val);
						if (curr-&gt;left) d2.push(curr-&gt;left);
						if (curr-&gt;right) d2.push(curr-&gt;right);
				}
				if (!tmp.empty()) {
						r.push_back(tmp);
						tmp.clear();
				} else break;

				while (!d2.empty()) {
						curr = d2.top();
						d2.pop();
						tmp.push_back(curr-&gt;val);
						if (curr-&gt;right) d1.push(curr-&gt;right);
						if (curr-&gt;left) d1.push(curr-&gt;left);
				}
				if (!tmp.empty()) {
						r.push_back(tmp)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第十六章 笔记+习题 16.2]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-liu-zhang-bi-ji-xi-ti-162</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-liu-zhang-bi-ji-xi-ti-162">
        </link>
        <updated>2019-11-21T13:17:11.000Z</updated>
        <content type="html"><![CDATA[<p>16.2模板实参推断<br>
从函数实参来确定模板实参的过程被称为模板实参推断</p>
<p>16.2.1类型转换与模板类型参数<br>
<strong>(注意，这里是实参推断，显式指定实参可以正常转换)</strong> 与往常一样，<strong>顶层 const</strong>( ( 参见2.4.3 节，第57 页）无论是在形参中还是在实参中，<strong>都会被忽略</strong>。在其他类型转换中，能在调用中应用于函数模板的包括如下两项。<br>
• const 转换：可以将一个非 const 对象的引用（或指针）传递给一个 const 的引用（或指针）形参（参见4.11.2 节，第144 页）。<br>
• 数组或函数指针转换：如果函数形参<strong>不是引用类型</strong>，则可以<strong>对数组或函数类型的实参应用正常的指针转换</strong>。一个数组实参可以转换为一个指向其首元素的指针。类似的，一个函数实参可以转换为一个该函数类型的指针（参见4. U .2 节，第143 页）。<br>
<strong>其他类型转换</strong>，如算术转换（参见4.11.1 节，第142 页）、派生类向基类的转换（参见15.2.2节，第530 页）以及用户定义的转换（参见7.5.4 节，第263 页和14.9 节，第514 页），<strong>都不能应用于函数模板</strong>。</p>
<p>注意并不是f(int[ ],int[ ]);<br>
<strong>两个数组大小不同，因此是不同类型</strong>。但是， fref 调用是不合法的。如果<strong>形参是一个引用</strong>，则<strong>数组不会转换为指针</strong>(参见6.2.4节，第195页）。 a 和 b 的类型是不匹配的，因此调用是错误的。</p>
<p>一个模板类型参数可以用作多个函数形参的类型。由于只允许有限的几种类型转换，因此传递给这些形参的实参必须具有相同的类型。如果推断出的类型不匹配，则调用就是错误的。</p>
<p>如果希望允许对函数实参进行正常的类型转换，我们可以将函数模板定义为两个类型<br>
参数：</p>
<p>函数模板可以有用普通类型定义的参数，即，不涉及模板类型参数的类型。这种函数<br>
实参不进行特殊处理；它们正常转换为对应形参的类型 <strong>并非必须用模板参数，只是必须有，模板类型参数不能为空</strong><br>
如果函数参数类型不是模板参数，则对实参进行正常的类型转换。<br>
<code>template &lt;typename T&gt; int add(int a,T b)</code></p>
<p>习题16.32<br>
使用实参的类型来初始化函数的模板实参类型<br>
在模版推断的过程中，编译器根据函数调用的实参类型来寻找模版实参，用这些模版实参生成的函数版本与给定的函数调用匹配<br>
习题16.33<br>
• const 转换：可以将一个非 const 对象的引用（或指针）传递给一个 const 的引用（或指针）形参（参见4.11.2 节，第144 页）。<br>
• 数组或函数指针转换：如果函数形参<strong>不是引用类型</strong>，则可以<strong>对数组或函数类型的实参应用正常的指针转换</strong>。一个数组实参可以转换为一个指向其首元素的指针。类似的，一个函数实参可以转换为一个该函数类型的指针（参见4. U .2 节，第143 页）。</p>
<p>习题16.34<br>
（a）不合法 因为两个字符串数组长度不一致，是不同类型<br>
（b）合法，T为<code>char[4]</code><br>
习题16.35<br>
（a）合法 T类型是char<br>
（b）合法 T类型是double<br>
（c）合法，两者都是char！！！<br>
（d）不合法，无法进行算术类型转换<br>
注意 单引号的'a'就是char类型<br>
习题16.36<br>
（a）T为 int&amp;<br>
（b）T1 T2分别为int&amp;<br>
（c）T为 int* 顶层const被忽略<br>
（d）分别为int *<br>
（e）不合法，首先需要判断实参的类型是否相同，再判断类型是否可转换，两参数一个为const一个非const<br>
（f）T1和T2都为int*<br>
注意：虽然会忽视顶层const，但是首先需要判断实参的类型是否相同，再判断类型是否可转换，如果两参数一个为const一个非const，不能同用一个T</p>
<p>16.2.2函数模板显式实参<br>
在某些情况，编译器<strong>无法推断</strong>出模板实参的类型。其他一些情况下，我们希望<strong>允许用户控制模板实例化</strong>。当函数返回类型与参数列表中任何类型都不相同时，这两种情况最常出现。</p>
<p>没有任何函数实参的类型可用来推断 T 1的类型。毎次调用 sum 时调用者都必须为T1提供一个<strong>显式模板实参</strong> （explicittemplateargument )。<br>
我们提供显式模板实参的方式与定义类模板实例的方式相同。显式模板实参在<strong>尖括号</strong>中给出，位于<strong>函数名之后，实参列表之前</strong>：<br>
//long long 是一个类型<br>
// T1 是显式指定的， T2 和 T3 是从函数实参类型推断而来的<br>
<code>auto val3 = sum&lt;long long&gt;(i,Ing);		//long long sum(int,long)</code><br>
显式模板实参按<strong>由左至右的顺序</strong>与对应的模板参数匹配；第一个模板实参与第一个模板参数匹配，第二个实参与第二个参数匹配，依此类推。<strong>只有尾部（最右）参数</strong>的显式模板实参<strong>才可以忽略</strong>，而且<strong>前提是</strong>它们可以从函数参数<strong>推断出來</strong>。如果我们的 sum 函数按照如下形式编写：</p>
<p><strong>对于模板类型参数已经显式指定了的函数实参，也进行正常的类型转换</strong></p>
<p>习题16.37<br>
<code>compare&lt;int,double&gt;(i,d); compare&lt;int&gt;(i,d); compare&lt;double&gt;(i,d)</code><br>
习题16.38<br>
make_shared接受的参数是一个模板参数包，返回类型是<code>shared_ptr&lt;_Ty&gt;</code>，<code>_Ty</code>是模板参数，由于无法推断返回类型，所以需要显式模板实参。<br>
习题16.39<br>
<code>compare&lt;string&gt;(&quot;123&quot;，&quot;1234&quot;）;</code><br>
<code>char[]</code>会被转换为string</p>
<p>16.2.3尾置返回类型与类型转换<br>
在编译器遇到函数的参数列表之前， 模板参数列表等同于不存在的。为了定义函数的返回类型，我们必须使用尾置返回类型（参见6.3.3节，第206页）。由于<strong>尾置返回出现在参数列表之后</strong>，它可以使用函数的参数：</p>
<p>注意解引用运算符<strong>首先检查curr是否仍在作用范围内</strong>，如果是，则<strong>返回curr所指元素的一个引用</strong>。 所以return *beg;的返回类型是引用而不是int</p>
<p><strong>如果仅仅有迭代器的话，迭代器的所有操作（比如解引用符）只能返回元素的引用，不能得到元素本身的类型</strong>为了获得元素类型，我们可以使用标准库的类型转换（type transformation )模板。这些模板定义在头文件 type_traits 中。<br>
remove_reference模板有一个模板类型参数和一个名为 type 的（public )类型成员。如果我们用一个引用类型实例化remove _ reference ，则 type 将表示被引用的类型。<br>
<code>decltype(*beg)</code>返回元素类型的引用类型。remove_reference::type脱去引用，剩下元素类型本身。<br>
注意， type 是一个类的成员，而该类依赖于一个模板参数。因此，我们必须在返回类型的声明中使用 typename 来告知编译器， type 表示一个类型<br>
<code>auto fcn(It beg,It end)-&gt;typename remove_reference&lt;decltype(*beg)&gt;::type</code></p>
<p>每个类型转换模板的工作方式都与remove_reference类似。每个模板都有一个名为type的public成员，表示一个类型。此类型与模板自身的模板类型参数相关，其关系如模板名所示。<strong>如果不可能（或者不必要）转换模板参数，则type成员就是模板参数类型本身</strong>。<br>
例如，如果T是一个指针类型，则<code>remove_pointer&lt;T&gt;::type</code>是T指向的类型。如果T不是一个指针，则无须进行任何转换，从而<strong>type具有与T相同的类型</strong>。</p>
<p>习题16.40<br>
是合法的<br>
此时返回类型变为int（亦即取决于容器本身的元素类型）<br>
逆向思维的测试代码</p>
<pre><code>template &lt;typename It&gt;
auto fcn(It beg, It end)-&gt;decltype(*beg) { return (*beg+0); }
</code></pre>
<p>显示 error C2440: “return”: 无法从“int”转换为“int &amp;”<br>
<strong>同时要求容器本身的元素（迭代器解引用后）必须能够做+0的操作</strong></p>
<p>习题16.41<br>
这题不会，但是网友的思路很秒，decltype会自动判断a+b需要什么类型才能容纳</p>
<pre><code>template &lt;typename T&gt; auto sum(const T&amp;a,const T&amp;b) -&gt;decltype(a+b)//将函数的返回类型指定为a+b的类型
{
	return a+b;
}
</code></pre>
<p>16.2.4 函数指针和实参判断<br>
当我们用一个<strong>函数模板</strong>初始化一个<strong>函数指针</strong>或为一个<strong>函数指针赋值</strong>时，编译器使用<strong>指针的类型来推断模板实参</strong><br>
pf1中参数的类型决定了T的模板实参的类型。在本例中，T的模板实参类型为int。指针pf1指向compare的int版本实例。如果不能从函数指针类型确定模板实参，则产生错误<br>
这段代码的问题在于，通过func的参数类型<strong>无法确定模板实参的唯一类型</strong>。对func的调用既可以实例化接受int的compare版本，也可以实例化接受string的版本。由于不能确定func的实参的唯一实例化版本，此调用将编译失败。<br>
我们可以通过使用<strong>显式模板实参来消除func调用的歧义</strong><br>
当参数是一个函数模板实例的指针时，程序上下文必须满足：对于每个模板参数，能唯一确定其类型或值。</p>
<p>16.2.5 模板实参推断和引用<br>
编译器会应用正常的引用绑定规则；<strong>const是底层</strong>的，<strong>不是顶层</strong>的 <strong>（因为引用的本质就是指针，准确的说是一个常量指针，它本身不可能修改指向的对象，自带顶层）</strong><br>
<strong>注意const int&amp; 中的const是底层const 指int是const，而不是指引用</strong><br>
当一个函数参数是模板类型参数的一个<strong>普通（左值）引用</strong>时（即，形如T&amp;），绑定规则告诉我们，<strong>只能传递</strong>给它一个<strong>左值</strong>（如，一个变量或者一个返回引用类型的表达式）。实参可以是const类型，也可以不是，如果<strong>实参是const</strong>的，则<strong>T将会被推断为const类型</strong></p>
<p><strong>通常</strong>我们<strong>不能将一个右值引用</strong>绑定到一个<strong>左值</strong>上，但是，c++语言在正常绑定规则之外定义了<strong>两个例外规则</strong>，允许这种绑定，这两个例外规则是move这种标准库设施正确工作的基础<br>
当我们将一个<strong>左值</strong>（如i）传递给函数的<strong>右值引用参数</strong>，且此右值引用指向模板类型参数（如T&amp;&amp;）时，编译器<strong>推断模板类型参数</strong>为实参的<strong>左值引用</strong>类型。因此，当我们调用f3（i）时，编译器推断<strong>T</strong>的类型为<strong>int&amp;，而非int</strong><br>
通常我们<strong>不能（直接）定义</strong>一个<strong>引用的引用</strong>，但是，通过<strong>类型别名</strong>或通过<strong>模板类型参数间接定义</strong>是可以的<br>
在这种情况下，我们可以使用第二个例外绑定规则：如果我们间接创建一个<strong>引用的引用</strong>，则这些<strong>引用</strong>形成了 <strong>“折叠”</strong>。在所有情况下（除了一个例外），引用会<strong>折叠成</strong>一个<strong>普通的左值引用类型</strong>。在新标准中，折叠规则扩展到右值引用。<strong>只在一种特殊情况下</strong>引用会<strong>折叠成右值引用：右值引用的右值引用</strong>。即，对于一个给定类型X：<br>
1.X&amp;、&amp;、X&amp; &amp;&amp;和X&amp;&amp; &amp;都折叠成类型X&amp;<br>
2.<strong>类型X&amp;&amp; &amp;&amp;折叠成X&amp;&amp;</strong><br>
引用折叠<strong>只能</strong>应用于<strong>间接创建的引用的引用</strong>，如类型别名或模板参数</p>
<p>即使f3的函数参数形式是一个右值引用（即，T&amp;&amp;），此调用也会用一个左值引用类型（即，int&amp;）实例化f3<br>
这两个规则导致了两个重要结果：<br>
1.如果一个函数参数是一个指向模板类型参数的右值引用（如，T&amp;&amp;），则它可以被绑定到一个左值；且<br>
2.如果实参是一个左值，则推断出的模板实参类型将是一个左值引用，且函数参数将会被实例化为一个（普通）左值引用参数（T&amp;）</p>
<p>T&amp;&amp; 等于拷贝 T&amp; 等于绑定引用<br>
当代码涉及的类型可能是普通（非引用）类型，也可能是引用类型时，编写正确的代码就变得异常困难（虽然remove_reference这样的类型转换类可能会有帮助）<br>
在实际中，<strong>右值引用</strong>通常用于两种情况：<strong>模板转发其实参（16.2.7）</strong> 或<strong>模板被重载（16.3）</strong><br>
目前应该注意的是，使用右值引用的函数模板通常使用我们在13.6.3节中看到的方式来进行重载（函数后添加引用限定符）<br>
与非模板函数一样，第一个版本将绑定到可修改的右值，而第二个版本将绑定到左值或const右值。</p>
<p>习题16.42<br>
（a）T为int &amp;<br>
（b）T为const int&amp;(注意这里是底层const不是顶层const)<br>
（c）T为int<br>
习题16.43<br>
operator=返回一个左值引用 所以T为int &amp;<br>
习题16.44<br>
声明为T<br>
（a）int<br>
（b）int<br>
（c）int<br>
声明为const T&amp;<br>
（a）int<br>
（b）int<br>
（c）int<br>
注意，折叠是先观察实参的类型和形参的类型再决定T需要什么类型，而不是根据实参的类型直接决定T的类型<br>
习题16.45<br>
T解释为int 因为42是一个右值<br>
如果是int 则T解释为int&amp; 因为变量是一个左值，此时内部的vector&lt;int &amp;&gt;引发错误，容器不能容纳引用</p>
<p>16.2.6理解std::move<br>
用途：移动操作 绑定到将要销毁的对象 1.转换的表达式<code>i*42</code> 2.字面值 42 3.返回右值的表达式<br>
标准库 move 函数（参见13.6.1节，第472页）是使用右值引用的模板的一个很好的<br>
例子。<br>
虽然不能直接将一个右值引用绑定到一个左值上，但可用 <strong>move 获得一个绑定到左值上的右值引用</strong>。由于 move 本质上可以<strong>接受任何类型的实参</strong>，因此我们不会惊讶于它是一个<strong>函数模板</strong>。</p>
<p>这正是我们所寻求的——我们希望将一个右值引用绑定到一个左值。这个实例的函数体返回 static cast &lt; string &amp;&amp;&gt;( t )。在此情况下，t的类型为 string&amp; , cast将其转换为string &amp;&amp;。</p>
<p>static _ cast 只能用于其他合法的类型转换（参见4.11.3节，第145页）。但是，这里又有一条针对右值引用的特许规则：虽然不能隐式地将一个左值转换为右值引用，但我们可以用 <strong>static _ cast 显式地将一个左值转换为一个右值引用</strong>。</p>
<p>习题16.46<br>
将elem指向的元素转化为右值引用并在新的指针位置构造新的元素，相当于移动元素</p>
<p>16.2.7转发<br>
某些函数需要将其一个或多个实参连同类型不变地<strong>转发给其他函数（即在函数内部调用其他函数或自身）</strong>。在此情况下，我们需要<strong>保持</strong>被转发实参的<strong>所有性质</strong>，包括实参类型<strong>是否是 const</strong> 的以及实参是<strong>左值还是右值</strong>。</p>
<p>F，T1不相互影响，但T1可用于F（int可以作为int&amp;的参数）<br>
f和j并不相互影响<br>
<strong>j的值被拷贝到t1中，f中的引用参数被绑定到t1，而非j，从而其改变不会影响j</strong>使其参数能保持给定实参的&quot;左值性&quot;。更进一步，可以想到我们也希望保持参数的 const 属性。<br>
通过将一个函数参数定义为一个<strong>指向模板类型参数的右值引用</strong>，我们可以保持其对应实参的所有类型信息。而使用<strong>引用参数</strong>（无论是左值还是右值）使得我们可以<strong>保持 const属性</strong>，因为在<strong>引用类型中的 const 是底层的</strong>。<br>
如果一个函数参数是指向模板类型参数的<strong>右值引用(如T&amp;&amp;)</strong>，它对应的实参的<strong>const属性和左值/右值属性将得到保持</strong><br>
可使用一个名为<strong>forward</strong>的新标准库设施来传递flip2的参数，它能保持原始实参的类型。类似move,forward定义在<strong>头文件utility</strong>中。与move不同，forward<strong>必须通过显式模板实参來调用</strong>（参见16.2.2节，第603页）。forward<strong>返回该显式实参类型的右值引用</strong>。即，<strong><code>forward&lt;T&gt;</code></strong> 的返回类型是<strong>T&amp;&amp;</strong>。<br>
通常情况下.我们使用forward传递那些定义为模板类型参数的右值引用的函数参数。通过其返回类型上的<strong>引用折叠</strong>，forward可以<strong>保持</strong>给定实参的<strong>左值/右值属性</strong>：<br>
如果实参是一个右值，则 Type 是一个普通（非引用）类型，<code>forward &lt; Type &gt;</code>将返回Types&amp;&amp;。如果实参是一个左值，则通过引用折叠， Type 本身是一个左值引用类型。在此情况下，返回类型是一个指向左值引用类型的右值引用。再次对 <code>forward &lt; Type &gt;</code>的返回类型进行引用折叠，将返同一个左值引用类型。<br>
当用于一个指向模板参数类型的右值引用函数参数（T &amp;&amp;)时， forward 会保持实参类型的所有细节。<br>
<code>f（std::forward&lt;T2&gt;（t2）,std::forward&lt;T1&gt;(t1)）;</code></p>
<p>习题16.47</p>
<pre><code>template&lt;typename F,typename T1,typename T2&gt;
void flip(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2) {
	f(forward&lt;T2&gt;(t2), forward&lt;T1&gt;(t1));
}

void f(int&amp; a, int &amp;&amp;b)
{
	cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; ++b &lt;&lt; endl;
}
</code></pre>
<p>习题感悟<br>
注意：虽然会忽视顶层const，但是首先需要判断实参的类型是否相同，再判断类型是否可转换，如果两参数一个为const一个非const，不能同用一个T<br>
解引用运算符首先检查curr是否仍在作用范围内，如果是，则返回curr所指元素的一个引用。<br>
注意 单引号的'a'就是char类型<br>
将sum返回的类型自动改为保证足够容纳其计算结果的类型，decltype会自动判断a+b需要什么类型才能容纳</p>
<pre><code>template &lt;typename T&gt; auto sum(const T&amp;a,const T&amp;b) -&gt;decltype(a+b)//将函数的返回类型指定为a+b的类型
{
	return a+b;
}
</code></pre>
<p>注意，折叠是先观察实参的类型和形参的类型再决定T需要什么类型，而不是根据实参的类型直接决定T的类型</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 107. 二叉树的层次遍历 II[简单]]]></title>
        <id>https://lixin-ee.github.io//post/shu-107-er-cha-shu-de-ceng-ci-bian-li-iijian-dan</id>
        <link href="https://lixin-ee.github.io//post/shu-107-er-cha-shu-de-ceng-ci-bian-li-iijian-dan">
        </link>
        <updated>2019-11-21T01:22:33.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）<br>
例如：<br>
给定二叉树 [3,9,20,null,null,15,7],<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7<br>
返回其自底向上的层次遍历为：<br>
[<br>
[15,7],<br>
[9,20],<br>
[3]<br>
]<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>本题的难点在于平常的层次遍历从上往下的话可以直接用vector的push_back，从下往上遍历看起来很简单，但是vector没有push_front，并且在头部插入需要整体复制移动，代价非常大<br>
所以思考了一下，决定用双边容器的deque来代替vector，最后再用迭代器范围来初始化vector<br>
<code>vector&lt;vector&lt;int&gt;&gt; res(dvi.begin(),dvi.end());</code><br>
最终代码如下：</p>
<pre><code>class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) {
        deque&lt;vector&lt;int&gt;&gt; dvi;
        preorder(root,0,dvi);
        vector&lt;vector&lt;int&gt;&gt; res(dvi.begin(),dvi.end());
        return res;
    }
    
    void preorder(TreeNode* cur,int i,deque&lt;vector&lt;int&gt;&gt; &amp;res){
        if(cur==NULL)
            return;
        if(res.size()==i)
            res.push_front(vector&lt;int&gt;());
        res[res.size()-i-1].push_back(cur-&gt;val);
        preorder(cur-&gt;left,i+1,res);
        preorder(cur-&gt;right,i+1,res);
        return;
    }
};
</code></pre>
<p>做题中出现的问题有：<br>
一开始傻了，忘了是在头部插入，继续用了<code>res[i].push_back(cur-&gt;val);</code>，结果导致输出<code>[[],[],[3,9,20,15,7]]</code><br>
然后是<code>res[res.size()-i-1]</code>，而不是<code>res[res.size()-i]</code>，因为此时size增加了1</p>
<p>结果毫无疑问地牺牲了空间复杂度来换了时间复杂度</p>
<p>然后来看一下网友题解吧<br>
大部分都是reverse，这就很没意思了<br>
所以贴个最高赞的队列迭代吧，和递归相对应</p>
<pre><code>class Solution:
    def levelOrderBottom(self, root):
        queue = []                                                  # 结果列表
        cur = [root]                                                # 接下来要循环的当前层节点，存的是节点
        while cur:                                                  # 当前层存在结点时
            cur_layer_val = []                                      # 初始化当前层结果列表为空，存的是val
            next_layer_node = []                                    # 初始化下一层结点列表为空
            for node in cur:                                        # 遍历当前层的每一个结点
                if node:                                            # 如果该结点不为空，则进行记录
                    cur_layer_val.append(node.val)                  # 将该结点的值加入当前层结果列表的末尾
                    next_layer_node.extend([node.left, node.right]) # 将该结点的左右孩子结点加入到下一层结点列表
            if cur_layer_val:                                       # 只要当前层结果列表不为空
                queue.insert(0, cur_layer_val)                      # 则把当前层结果列表插入到队列首端
            cur = next_layer_node                                   # 下一层的结点变成当前层，接着循环
        return queue      
</code></pre>
<p>这个妹纸本来的注释还挺好看的，到了这里全乱了。。。建议直接看原题<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/solution/python3-dui-lie-shi-xian-by-yi-xi-4/">妹纸的队列迭代题解</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[需要复习的点]]></title>
        <id>https://lixin-ee.github.io//post/xu-yao-fu-xi-de-dian</id>
        <link href="https://lixin-ee.github.io//post/xu-yao-fu-xi-de-dian">
        </link>
        <updated>2019-11-20T11:26:03.000Z</updated>
        <content type="html"><![CDATA[<p>LeetCode<br>
树的题目的迭代解法</p>
<p>C++PRIMER<br>
15.9章 类的设计思路代码</p>
<p>16.1.5 27题 类模板的实例化问题</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 337. 打家劫舍 III[中等]]]></title>
        <id>https://lixin-ee.github.io//post/shu-337-da-jia-jie-she-iiizhong-deng</id>
        <link href="https://lixin-ee.github.io//post/shu-337-da-jia-jie-she-iiizhong-deng">
        </link>
        <updated>2019-11-20T02:04:50.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。<br>
计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。<br>
示例 1:<br>
输入: [3,2,3,null,3,null,1]<br>
3<br>
/ <br>
2   3<br>
\   \<br>
3   1<br>
输出: 7<br>
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.<br>
示例 2:<br>
输入: [3,4,5,1,3,null,1]<br>
     3<br>
/ <br>
4   5<br>
/ \   \<br>
1   3   1<br>
输出: 9<br>
解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/house-robber-iii<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>最终代码：</p>
<pre><code>class Solution {
public:
    int rob(TreeNode* root) {
        auto res=preorder(root);
        return max(res[0],res[1]);
    }
    
    vector&lt;int&gt; preorder(TreeNode* cur){
        vector&lt;int&gt; vi;
        if(cur==NULL){
            vi.push_back(0);
            vi.push_back(0);
            return vi;}
        auto vl=preorder(cur-&gt;left);
        auto vr=preorder(cur-&gt;right);
        vi.push_back(max(vl[0]+vr[0],max(vl[1]+vr[1],max(vl[1]+vr[0],vl[0]+vr[1]))));
        vi.push_back(cur-&gt;val+vl[0]+vr[0]);
        return vi;     
    } 
};
</code></pre>
<p>这道题还是蛮波折的，一开始我希望用普通的方法解决，比如说层次遍历后只取间隔层的所有节点的和，但是后来想想是不行的<br>
比如<code>[[1],[10,1],[1,1,1,10]]</code>这种情况，很明显应该牺牲头节点各取第二层和第三层的10<br>
所以动态规划在所难免了，这道题似乎和之前的股票问题比较像，0代表不偷，1 代表偷，但是只有冻结期限制而没有买入卖出等<br>
一开始想着从根节点出发，但是发现问题是同一层里值无法共享，所以必须从叶节点出发<br>
对于普通的具有两个子节点的节点来说，它取0的情况比较多，主要有<code>[（左0，右0）（左1，右0）（左0，右1）（左1，右1）]</code>，而我们只需要取这四者的最大值就好，取1的话就比较简单了，两个子树都不能偷，必须左1右1，然后再加上当前val返回就好<br>
我在取0的时候一开始不小心忘了左0右0，结果导致测试用例结果只差了1，差点百思不得其解<br>
然后看了题解后发现取0的情况完全可以简化为<code>max（（左0，左1），（右0，右1））</code><br>
哈哈哈不过第一次独立做出动态规划题还是非常高兴的啊！（虽然拖了两天hhhh</p>
<p>然后来看一下网友题解（当时非常激动，发现和网友题解思路一致）</p>
<blockquote>
<p>用一个int[]分别记录包含根节点和不包含根节点时的最大值</p>
</blockquote>
<pre><code>class Solution {
    public int rob(TreeNode root) {
        int[] res = doRob(root);
        return Math.max(res[0],res[1]);
    }
    //res[0]为不包括根节点的最大值，res[1]为包括根节点的最大值
    private int[] doRob(TreeNode root){
        int[] res = new int[2];
        if(root == null)
            return res;
        int[] left = doRob(root.left);
        int[] right = doRob(root.right);
        //不包含根节点，最大值为两个子树的最大值之和
        res[0] = Math.max(left[0],left[1])+Math.max(right[0],right[1]);
        //包含根节点，最大值为两个子树不包含根节点的最大值加上根节点的值
        res[1] = left[0] + right[0] + root.val;
        return res;
    }
}
</code></pre>
<p>另外一个说得比较详细的</p>
<blockquote>
<p>可以回顾一下初级版的LeetCode198：打家劫舍，这是一道一维dp，状态转移方程也很简单：<br>
dp[i] = Math.max(dp[i - 2] + nums[cur], dp[i - 1]);<br>
当前偷窃的最大金额可能有两种来源情况，要么偷了这家，上一家没偷；要么偷了上一家，这家没偷。因此每一个结点的dp值和前两个结点的dp值有关。<br>
这道升级版的树状动态规划问题也可以由一维的dp延伸来，只是情况稍微复杂一些，每一个节点的dp值与三层二叉树的结点dp值相关。对于下图所示的一棵三层满二叉树来说：</p>
<pre><code>  1
/   \
</code></pre>
<p>2     3<br>
/ \   / \<br>
4   5 6   7<br>
在每个结点的金额非负的情况下，且要保证取值结点不相邻，只可能有四种最大的取值方式：</p>
<ol>
<li>结点2 + 结点3</li>
<li>结点1 + 结点4 + 结点5 + 结点6 + 结点7</li>
<li>结点2 + 结点6 + 结点7</li>
<li>结点3 + 结点4 + 结点5<br>
那么我们可以自底向上递归进行这个dp运算，令dp[i]代表以i结点为根节点的子树的最大偷窃金额值，计算结束后将dp值直接保存在i结点的val值当中返回。可以推出状态转移方程为：</li>
</ol>
<p>dp[root] = Max(dp[l]+dp[r], root.val+dp[ll]+dp[lr]+dp[rr]+dp[rl], dp[l]+dp[rl]+dp[rr], dp[r]+dp[lr]+dp[ll]);<br>
分别对应上述四种情况。而观察发现，在dp[l]和dp[r]的计算中实际已经包含了dp[ll]、dp[lr]、dp[rr]、dp[rl]的取舍情况，因此可以简化为前两种情况。状态转移方程简化为：</p>
<p>dp[root] = Max(dp[l]+dp[r], root.val+dp[ll]+dp[lr]+dp[rr]+dp[rl]);<br>
为了方便运算，我们一般会为dp数组赋予初值。在树状dp中同样，我们需要将每一个非叶结点作为根节点的子树构造成一棵三层满二叉树方便运算。</p>
<p>对于叶子结点，我们给其添加值为0的左右子结点。</p>
<p>对于左/右子树为空的非叶节点，我们在其左/右添加一棵两层值为0的满二叉树。</p>
</blockquote>
<pre><code>class Solution {
    public int rob(TreeNode root) {
        return Solution(root).val;
    }

    public TreeNode Solution(TreeNode root){
        if(root == null){
            TreeNode newNode = new TreeNode(0);
            return Solution(newNode);
        }
        if(root.left == null &amp;&amp; root.right == null){
            root.left = new TreeNode(0);
            root.right = new TreeNode(0);
            return root;
        }

        root.left = Solution(root.left);
        root.right = Solution(root.right);
        root.val = Math.max(root.left.val + root.right.val, root.val + root.left.left.val + root.left.right.val + root.right.left.val + root.right.right.val);

        return root;
    }
}
</code></pre>
<p>hhh第一次自己完成动态规划问题还是挺激动的</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 124. 二叉树中的最大路径和[困难]]]></title>
        <id>https://lixin-ee.github.io//post/shu-124-er-cha-shu-zhong-de-zui-da-lu-jing-he</id>
        <link href="https://lixin-ee.github.io//post/shu-124-er-cha-shu-zhong-de-zui-da-lu-jing-he">
        </link>
        <updated>2019-11-19T01:37:25.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个非空二叉树，返回其最大路径和。<br>
本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。<br>
示例 1:<br>
输入: [1,2,3]<br>
1<br>
/ <br>
2   3<br>
输出: 6<br>
示例 2:<br>
输入: [-10,9,20,null,null,15,7]<br>
   -10<br>
   / <br>
  9  20<br>
    /  <br>
   15   7<br>
输出: 42<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/binary-tree-maximum-path-sum<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题的难点在于可以从树中的任意节点出发<br>
所以从根节点出发是不太可能的了<br>
我思考了一下，发现可以从叶节点出发。可以先记录一个全局int，然后对于一个普通节点来说，无非四种结果，首先获得左右子节点返回的节点，然后将自身节点相加，然后最最重要的就是【左+右+自身】和【自身】，前者等于将左右节点和自身连接起来形成一条路径，后者等于防止某个节点值特别大的情况，取这四种情况的最大值更新res（只需要res不需要记录特定路径，同时取最大值保证只有一条路径），然后为什么不用将左右子树算入呢，因为递归过程中他们本身也会进行这个判断。<br>
然后记得把res设置为INT_MAX<br>
最终代码如下：</p>
<pre><code>class Solution {
    int res=INT_MIN;
public:
    int maxPathSum(TreeNode* root) {
        preorder(root);
        return res;
    }
    
    int preorder(TreeNode* cur){
        if(cur==NULL)
            return 0;
        int left=preorder(cur-&gt;left);
        int right=preorder(cur-&gt;right);
        res= res&gt;(cur-&gt;val+left+right)?res:(cur-&gt;val+left+right);
        left=left+cur-&gt;val;
        right=right+cur-&gt;val;
        int ret= max(left,right);
        ret= max(ret,cur-&gt;val);
        res= res&gt;ret?res:ret;
        return ret;
        
    }
};
</code></pre>
<p>然后来看一下网友题解：</p>
<blockquote>
<p>解题思路：<br>
二叉树 abc，a 是根结点（递归中的 root），bc 是左右子结点（代表其递归后的最优解）。<br>
最大的路径，可能的路径情况：</p>
<pre><code>a
</code></pre>
<p>/ <br>
b   c<br>
b + a + c。<br>
b + a + a 的父结点。<br>
a + c + a 的父结点。<br>
其中情况 1，表示如果不联络父结点的情况，或本身是根结点的情况。<br>
这种情况是没法递归的，但是结果有可能是全局最大路径和。<br>
情况 2 和 3，递归时计算 a+b 和 a+c，选择一个更优的方案返回，也就是上面说的递归后的最优解啦。</p>
<p>另外结点有可能是负值，最大和肯定就要想办法舍弃负值（max(0, x)）（max(0,x)）。<br>
但是上面 3 种情况，无论哪种，a 作为联络点，都不能够舍弃。</p>
<p>代码中使用 val 来记录全局最大路径和。<br>
ret 是情况 2 和 3。<br>
lmr 是情况 1。</p>
<p>所要做的就是递归，递归时记录好全局最大和，返回联络最大和。</p>
<p>代码：<br>
C++</p>
</blockquote>
<pre><code>int maxPathSum(TreeNode* root, int &amp;val)
{
	if (root == nullptr) return 0;
	int left = maxPathSum(root-&gt;left, val);
	int right = maxPathSum(root-&gt;right, val);
	int lmr = root-&gt;val + max(0, left) + max(0, right);
	int ret = root-&gt;val + max(0, max(left, right));
	val = max(val, max(lmr, ret));
	return ret;
}

int maxPathSum(TreeNode* root) 
{
	int val = INT_MIN;
	maxPathSum(root, val);
	return val;
}
</code></pre>
<p>网友的思路比我更清晰一点，利用max(0, left) + max(0, right)其实就包含了判断自身的情况。然后评论中指出可以改进的点是lmr肯定是大于ret的</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 110. 平衡二叉树[简单]]]></title>
        <id>https://lixin-ee.github.io//post/shu-110-ping-heng-er-cha-shu-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/shu-110-ping-heng-er-cha-shu-jian-dan">
        </link>
        <updated>2019-11-18T00:21:03.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个二叉树，判断它是否是高度平衡的二叉树。<br>
本题中，一棵高度平衡二叉树定义为：<br>
一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。<br>
示例 1:<br>
给定二叉树 [3,9,20,null,null,15,7]<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7<br>
返回 true 。<br>
示例 2:<br>
给定二叉树 [1,2,2,3,3,null,null,4,4]</p>
<pre><code>   1
  / \
 2   2
/ \
</code></pre>
<p>3   3<br>
/ <br>
4   4<br>
返回 false 。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/balanced-binary-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题的难点在于不平衡出现的点是不确定的，有可能在叶子节点的父母节点开始出现不平衡，也有可能在根节点才开始出现不平衡<br>
所以这一次的迭代我打算使用先走到叶节点，然后再逐步返回，返回值为当前节点到最远叶节点的距离，然后返回到上一节点就可以利用左右节点返回的值进行比较<br>
为了方便就设置一个全局bool值。</p>
<pre><code>class Solution {
bool res=true;
public:
    bool isBalanced(TreeNode* root) {
        preorder(root,0);
        return res;
    }
    
    int preorder(TreeNode* cur,int i){
        if(cur==NULL)
            return i;
        int left=preorder(cur-&gt;left,i+1);
        int right=preorder(cur-&gt;right,i+1);
        if(abs(left-right)&gt;1)
            res=false;
        return left&gt;right?left+1:right+1;
    }
};
</code></pre>
<p>然后来看一下网友题解：</p>
<blockquote>
<p>从底至顶（提前阻断法）<br>
对二叉树做深度优先遍历DFS，递归过程中：<br>
终止条件：当DFS越过叶子节点时，返回高度0；<br>
返回值：<br>
从底至顶，返回以每个节点root为根节点的子树最大高度(左右子树中最大的高度值加1max(left,right) + 1)；<br>
当我们发现有一例 左/右子树高度差 ＞ 1 的情况时，代表此树不是平衡树，返回-1；<br>
当发现不是平衡树时，后面的高度计算都没有意义了，因此一路返回-1，避免后续多余计算。<br>
最差情况是对树做一遍完整DFS，时间复杂度为 O(N)。</p>
</blockquote>
<pre><code>class Solution {
    public boolean isBalanced(TreeNode root) {
        return depth(root) != -1;
    }

    private int depth(TreeNode root) {
        if (root == null) return 0;
        int left = depth(root.left);
        if(left == -1) return -1;
        int right = depth(root.right);
        if(right == -1) return -1;
        return Math.abs(left - right) &lt; 2 ? Math.max(left, right) + 1 : -1;
    }
}
</code></pre>
<blockquote>
<p>从顶至底（暴力法）<br>
构造一个获取当前节点最大深度的方法 depth() ，通过比较左右子树最大高度差abs(self.depth(root.left) - self.depth(root.right))，来判断以此节点为根节点下是否是二叉平衡树；<br>
从顶至底DFS，以每个节点为根节点，递归判断是否是平衡二叉树：<br>
若所有根节点都满足平衡二叉树性质，则返回 True ；<br>
若其中任何一个节点作为根节点时，不满足平衡二叉树性质，则返回False。<br>
本方法产生大量重复的节点访问和计算，最差情况下时间复杂度 O(N^2)。</p>
</blockquote>
<pre><code>class Solution {
    public boolean isBalanced(TreeNode root) {
        if (root == null) return true;
        return Math.abs(depth(root.left) - depth(root.right)) &lt;= 1 &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);
    }

    private int depth(TreeNode root) {
        if (root == null) return 0;
        return Math.max(depth(root.left), depth(root.right)) + 1;
    }
}
</code></pre>
<p>网友的想法比较好，其实可以利用res的值提前终止判断，然后的话我发现我忘了在返回值+1了hhh，不过是不影响了，因为是否是平衡树是在叶节点就可以判断的了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第十六章 笔记+习题 16.1]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-liu-zhang-bi-ji-xi-ti-161</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-liu-zhang-bi-ji-xi-ti-161">
        </link>
        <updated>2019-11-17T12:24:32.000Z</updated>
        <content type="html"><![CDATA[<p>16 模板与泛型编程<br>
16.1定义模型<br>
16.1.1 函数模板<br>
一个<strong>函数模板</strong>就是一个<strong>公式</strong>，可用来<strong>生成针对特定类型的函数版本</strong> 。compare的模板版本可能像下面这样 ；</p>
<p>模板定义以<strong>关键字 template <strong>开始，后跟一个</strong>模板参数列表</strong> （template parameter list ),这是一个逗号分隔的一个或多个模板参数( templateparameter )的列表，用小于号（&lt;）和大于号（&gt;）包围起来<br>
在模板定义中，<strong>模板参数列表不能为空</strong>。<br>
模板参数表示在类或函数定义中用到的<strong>类型或值</strong>。当使用模板时，我们（隐式地或显式地）指定<strong>模板实参 （template argument )</strong> 将其绑定到模板参数上。<br>
当我们调用一个函数模板时，编译器（通常）用<strong>函数实参</strong>来为我们<strong>推断模板实参</strong>。<br>
编译器用推断出的模板参数来为我们<strong>实例化( instantiate)</strong> 一个特定版本的函数。当编译器实例化一个模板时，它使用实际的模板实参代替对应的模板参数来创建出模板的一个新&quot;实例&quot;。例如，给定下面的调用：</p>
<p>这些编译器生成的版本通常被称为<strong>模板的实例</strong><br>
我们的 compare 函数有一个<strong>模板类型参数（type parameter )</strong>。一般来说，我们可以将<br>
类型参数看作<strong>类型说明符</strong>.就像内置类型或类类型说明符一样使用。特别是，类型参数可以用来<strong>指定返回类型</strong>或<strong>函数的参数类型</strong>，以及在<strong>函数体内</strong>用于<strong>变量声明</strong>或<strong>类型转换</strong>：<br>
类型参数前必须使用<strong>关键字 class 或 typename</strong> ：<br>
// 错误： U 之前必须加上 class 或 typename<br>
template&lt;typename T,U&gt; T calc(const T&amp;,const U&amp;);<br>
看起來用关键字 typename 来指定模板类型参数比用 class 更为直观。</p>
<p>除了定义类型参数，还可以在模板中定义<strong>非类型参数( nontypeparameter )<strong>一个非类型参数表示</strong>一个值</strong>而<strong>非一个类型</strong>。我们<strong>通过一个特定的类型名</strong>而非关键字 class 或typename 来<strong>指定非类型参数</strong>。<br>
当一个模板被实例化时，非类型参数被一个<strong>用户提供</strong>的或<strong>编译器推断出</strong>的值所代替。这些值<strong>必须是常量表达式</strong>（参见2.4.4节，第58页），从而允许编译器在编译时实例化模板。</p>
<p>在template&lt;unsigned N,unsigned M&gt;中 N和M只是一个值，unsigned是一个类型，但重点在于N M这两个值<br>
一个<strong>非类型参数</strong>可以是一个<strong>整型</strong>，或者是一个指向对象或函数类型的<strong>指针或（左值）引用</strong>。绑定到<strong>非类型整型参数</strong>的实参<strong>必须是一个常量表达式</strong>。绑定到<strong>指针或引用非类型参数</strong>的实参必须具有<strong>静态的生存期</strong>（static对象或者）（参见第12章，第400页）。我们不能用一个普通（非static )局部变量或动态对象作为指针或引用非类型模板参数的实参。指针参数也可以用 <strong>nullptr 或一个值为0的常量表达式</strong>来实例化。<br>
在模板定义内，模板非类型参数是一个常量值。在需要常量表达式的地方，可以使用非类型参数，例如，指定数组大小。<br>
函数模板可声明为** inline 或 constexpr** 的，如同非模板函数一样。 inline 或constexpr 说明符放在<strong>模板参数列表之后，返回类型之前</strong>：</p>
<p>•模板中的函数参数是 const 的引用。<br>
•函数体中的条件判断仅使用&lt;比较运算。</p>
<p>通过将函数参数设定为 const 的引用，我们保证了函数可以用于不能拷贝的类型。大多数类型，包括内置类型和我们已经用过的标准库类型（除 unique _ ptr 和IO类型之外 ）都是允许拷贝的。</p>
<p>模板程序应该尽量<strong>减少对实参类型的要求</strong>。</p>
<p>当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。当我们使用（而不是定义）模板时，编译器才生成代码，这一特性影响了我们如何组织代码以及<strong>错误何时被检测到</strong>。<br>
通常，当我们<strong>调用一个函数</strong>时，编详器<strong>只需要</strong>掌握函数的<strong>声明</strong>。类似的，当我们<strong>使用一个类类型的对象</strong>时，<strong>类定义必须是可用的</strong>，但<strong>成员函数的定义不必已经出现</strong>。因此，我们将<strong>类定义</strong>和<strong>函数声明</strong>放在<strong>头文件中</strong>，而<strong>普通函数</strong>和<strong>类的成员函数的定义</strong>放在<strong>源文件</strong>中。<br>
<strong>模板则不同</strong>：为了生成一个<strong>实例化版本</strong>，编译器需要掌握函数模板或类模板成员函数的<strong>定义</strong>。因此，与非模板代码不同，<strong>模板的头文件</strong>通常既<strong>包括声明也包括定定义。</strong><br>
<strong>函数模板</strong>和<strong>类模板成员函数</strong>的定义通常放在<strong>头文件中</strong>。<br>
当使用模板时，所有不依赖于模板参数的名字都必须是可见的，这是由模板的提供者保证的<br>
用来实例化模板的所有函数、类型以及与类型关联的运算符的声明都必须是可见的，这是由模板的用户来保证的。</p>
<p>通常，编译器会在三个阶段报告错误。<br>
第一个阶段是<strong>编译模板本身</strong>时。在这个阶段，编译器通常不会发现很多错误。编译器可以检查语法错误，例如忘记分号或者变量名拼错等，但也就这么多了。<br>
第二个阶段是编译器遇到<strong>模板使用</strong>时。在此阶段，编译器仍然没有很多可检查的。对于函数模板调用，编译器通常会检查实参数目是否正确。还能检查参数类型是否匹配。对于类模板，编译器可以检查用户是否提供了正确数目的模板实参，但也仅限于此了。<br>
第三个阶段是<strong>模板实例化</strong>时，只有这个阶段才能发现类型相关的错误。依赖于编译器如何管理实例化，这类错误可能在链接时才报告。<br>
当我们编写模板时，代码不能是针对特定类型的，但模板代码通常对其所使用的类型有一些假设。例如，我们最初的 compare 函数中的代码就假定实参类型定义了&lt;运算符。<br>
保证传递给模板的<strong>实参支持模板所要求的操作</strong>，以及这些操作在模板中<strong>能正确工作</strong>，是<strong>调用者的责任</strong>。</p>
<p>习题16.1<br>
编译器用推断出的模板参数来为我们<strong>实例化( instantiate)</strong> 一个特定版本的函数。当编译器实例化一个模板时，它使用实际的模板实参代替对应的模板参数来创建出模板的一个新&quot;实例&quot;<br>
习题16.2</p>
<pre><code>template &lt;typename T&gt; int compare(const T &amp;v1, const T &amp;v2) {
	if (less&lt;T&gt;()(v1, v2)) return -1;
	if (less&lt;T&gt;()(v2, v1))return 1;
	return 0;
}
</code></pre>
<p>注意<code>less&lt;type&gt;</code>本身也是一个模板，需要创建一个临时对象才能使用，所以中间有个空括号<br>
习题16.3<br>
error C2678: 二进制“&lt;”: 没有找到接受“const Sales_Data”类型的左操作数的运算符(或没有可接受的转换)<br>
习题16.4</p>
<pre><code>template&lt;typename T, typename B&gt; T Find(const T beg, const T end, B value) {
	for (T i = beg; i != end; ++i)
		if (*i == value)
			return i;
	return end;
}
int main() {
	vector&lt;int&gt; vi{ 1,2,3,4,5,6,7 };
	list&lt;string&gt; ls{ &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot; };
	string s = &quot;4&quot;;
	cout &lt;&lt; *Find(ls.begin(), ls.end(), s) &lt;&lt; endl;
}
</code></pre>
<p>需要注意的点：<br>
1.库函数find的返回值为迭代器（虽然是输入迭代器），这里我还是直接用T吧<br>
2.注意循环判断条件不能用<code>i&lt;end</code>，因为只有随机迭代器才支持关系运算符，题目中的list使用双向迭代器就没法用小于号<br>
习题16.5</p>
<pre><code>template&lt;typename T, unsigned N&gt; void print(T(&amp;arr)[N]) {
	for (auto elem : arr)
		cout &lt;&lt; elem &lt;&lt; endl;
}
int main() {
	int arri[5]{ 1,2,3,4,5 };
	char arrc[6] = &quot;12345&quot;;
	cout &lt;&lt; strlen(arrc)&lt;&lt;endl;
	print(arri);
}
</code></pre>
<p>需要注意的点：<br>
1<code>.T(&amp;arr)[N]</code>的括号不可少，否则就是引用的数组了。然后N也不可少，N也属于形参类型的一部分<br>
2.strlen计算长度的时候会忽视空字符，但是实际char数组中还是得老老实实加上一位存空字符，否则会报错（昨天的面试题中就有一道考strlen细节的）<br>
习题16.6</p>
<pre><code>template&lt;typename T, unsigned N&gt; T* begin(const T(&amp;arr)[N])
{// error C2234: “arr”: 引用数组是非法的,(&amp;arr即可)
	return arr;
}

template&lt;typename T, unsigned N&gt; T* end(const T(&amp;arr)[N])
{
	return arr + N;
}

int main() {
	int arri[5]{ 1,2,3,4,5 };
	char arrc[6] = &quot;12345&quot;;
	cout &lt;&lt; *begin(arrc) &lt;&lt;&quot; &quot;&lt;&lt;*(end(arrc)-2)&lt;&lt; endl;
}
</code></pre>
<p>此题主要针对的是数组的调用，例如begin(arr)，而不是vi.begin()<br>
习题16.7</p>
<pre><code>template&lt;typename T&gt; unsigned length(T(&amp;arr)) {
	unsigned len = 0;
	for (auto i : arr)
		++len;
	return len;
}

template&lt;typename T,unsigned N&gt; unsigned lengthN(T(&amp;arr)[N]) {
	return N;
}
int main() {
	int arri[5]{ 1,2,3,4,5 };
	char arrc[6] = &quot;12345&quot;;
	cout &lt;&lt; length(arrc)&lt;&lt; endl;
	cout &lt;&lt; lengthN(arrc) &lt;&lt; endl;
}
</code></pre>
<p>两种形式，第二种未免太暴力了一点。。。<br>
习题16.8<br>
因为大多数自定义类型，比如类都是有定义<mark>而没有定义&lt;，！=可以直接利用</mark>的定义来工作，比如迭代器中，所以==保证了较高的通用性</p>
<p>16.1.2类模板<br>
<strong>类模板 (class template)</strong> 是用来生成<strong>类的蓝图</strong>的。与函数模板的不同之处是，编译器<strong>不能</strong>为类模板<strong>推断模板参数类型</strong>。如我们己经多次看到的，为了使用类模板，我们必须在模板名后的尖括号中提供额外信息（参见3.3节，第87页）——用来代替模板参数的模板实参列表。<br>
类似函数模板，类模板以<strong>关键字 template</strong> 开始，后跟模板参数列表。在类模板（及其成员）的<strong>定义中</strong>，我们将模板参数当作<strong>替身</strong>，代替使用模板时用户<strong>需要提供的类型或值</strong>：</p>
<p>当编译器从我们的 Blob 模板<strong>实例化</strong>出一个类时，它会<strong>重写 Blob 模板</strong>，将模板参数T的每个实例替换为给定的<strong>模板实参</strong>，在本例中是 int 。</p>
<p>一个类模板的每个实例都形成一个<strong>独立的类类型</strong>。类型 Blob &lt; string &gt;与任何其他 Blob 类型都<strong>没有关联</strong>.也不会对任何其他 Blob 类型的成员有特殊访问权限。</p>
<p>为了阅读模板类代码，应该记住类模板的名字<strong>不是一个类型名</strong>（参见3.3节，第87页）。类模板用来实例化类型，而一个实例化的类型总是包含模板参数的。<br>
可能令人迷惑的是，一个类模板中的代码如果<strong>使用了另外一个模板</strong>.通常不将一个实际类型（或值）的名字用作其模板实参。相反的，我们通常将<strong>模板自己的参数</strong>当作<strong>被使用模板的实参</strong>。比如</p>
<pre><code>template&lt;typename T&gt;calss Blob{
	friend bool operator==&lt;T&gt;(const Blob&lt;T&gt;&amp;,const Blob&lt;T&gt;&amp;);
}
</code></pre>
<p>与其他任何类相同，我们既可以在<strong>类模板内部</strong>，也可以在<strong>类模板外部</strong>为其定义成员函数，且<strong>定义在类模板内的成员函数被隐式声明为内联函数</strong>。<br>
类模板的成员函数本身是一个普通函数。但是，类模板的每个实例都有其自己版本的成员函数。因此，类模板的<strong>成员函数</strong>具有和<strong>模板相同的模板参数</strong>。因而，<strong>定义在类模板之外的成员函数就必须以关键字 template 开始，后接类模板参数列表</strong>。<br>
与往常一样，当我们在<strong>类外定义</strong>一个成员时，<strong>必须说明成员属于哪个类</strong>。而且，<strong>从一个模板生成的类的名字中必须包含其模板实参</strong>。当我们定义一个成员函数时，模板实参与模板形参相同。<br>
对于 StrBlob 的一个给定的成员函数<br>
<code>ret-type StrBlob：：member-name(parm-list)</code><br>
对应的 Blob 的成员应该是这样的;<br>
<code>template &lt;typename T&gt;</code><br>
<code>ret-type Blob&lt;T&gt;: member-na,e(parm-list)</code></p>
<p>除了类名中的不同之处以及使用了模板参数列表外，此函数与原 StrBlob 类的 check 成员完全一样。<br>
与其他任何定义在类模板外的成员一样，<strong>构造函数的定义要以模板参数开始</strong></p>
<p>默认情况下，一个类模板的成员函数<strong>只有当程序用到它时才进行实例化</strong>。<strong>(和显式实例化声明不同)</strong><br>
如果一个<strong>成员函数没有被使用</strong>，则它<strong>不会被实例化</strong>。<strong>成员函数</strong>只有在<strong>被用到时才进行实例化</strong>，这一特性使得即使某种类型不能完全符合模板操作的要求（参见9.2节，第294页）我们仍然能用该类型实例化类。<br>
默认情况下，对于一个实例化了的类模板，<strong>其成员只有在使用时才被实例化</strong><br>
当我们使用一个类模板类型时必须提供模板实参，但这一规则有一个例外。<strong>在类模板自己的作用域中</strong>，我们可以<strong>直接使用模板名而不提供实参</strong>：</p>
<p>当我们处于一个类模板的作用域中时，编译器处理模板自身引用好像我们已经提供了与模板参数匹配的实参一样。</p>
<p>当我们在<strong>类模板外定义其成员</strong>时，必须记住，我们<strong>并不在类的作用域中</strong>，<strong>直到遇到类名才表示进入类的作用域</strong>（参见7.4节，第253页）：</p>
<p>手写笔记：<strong>返回类型中不能仅用BlobPtr</strong><br>
由于<strong>返回类型</strong>位于类的<strong>作用域之外</strong>，我们<strong>必须指出返回类型是一个实例化的BlobPtr</strong>，它所用类型与类实例化所用类型一致。在<strong>函数体内</strong>，我们<strong>已经进入类的作用域</strong>，因此在<strong>定义 ret 时无须重复模板实参</strong>。如果不提供模板实参，则编译器将假定我们使用的类型与成员实例化所用类型一致。</p>
<p>当一个类包含一个友元声明（参见7.2.1节，第241页）时，类与友元各自是否是模板是相互无关的。如果一个类模板<strong>包含一个非模板友元</strong>，则友元被授权<strong>可以访问所有模板实例</strong>。如果<strong>友元自身是模板</strong>，类<strong>可以授权给所有</strong>友元模板实例，也<strong>可以只授权给特定</strong>实例。<br>
类模板与另一个（类或函数）模板间友好关系的最常见的形式是<strong>建立对应实例及其友元间的友好关系</strong>。<br>
为了<strong>引用</strong>（类或函数）模板的一个<strong>特定实例</strong>，我们必须<strong>首先声明模板自身</strong>。一个模板声明包括模板参数列表：<br>
<strong>注意：声明中不必指定参数名，只要有参数个数和类型即可，比如void func(int,int,double);所以模板声明中typename等同于typename T</strong></p>
<p>一个类也可以将另一个模板的<strong>每个实例</strong>都声明为自己的友元，或者<strong>限定特定的实例</strong>为友元：</p>
<pre><code> template &lt;typename T&gt; class C2{
	friend class Pal&lt;T&gt;; //相同类型的都是友元
	template &lt;typename X&gt; friend class Pal2; //所有实例都是c2的友元｝
</code></pre>
<p>为了让<strong>所有实例成为友元</strong>，友元声明中必须使用与<strong>类模板</strong>本身<strong>不同</strong>的模板参数。</p>
<p>在新标准中，我们可以将<strong>模板类型参数</strong>声明为<strong>友元</strong></p>
<p>值得注意的是，虽然友元<strong>通常来说</strong>应该是一个<strong>类</strong>或是一个<strong>函数</strong>，但我们完全可以用一个<strong>内置类型来实例化Bar</strong>。这种与内置类型的友好关系是允许的，以便我们能用内置类型来实例化 Bar 这样的类。</p>
<p>类模板的一个实例定义了一个类类型，与任何其他类类型一样，我们可以定义一个<strong>typedef</strong> (参见2.5.1节，第60页）来<strong>引用实例化的类</strong>：<br>
<code>typedef Blob&lt;string&gt; StrBlob;</code><br>
由于模板不是一个类型，我们<strong>不能定义</strong>一个<strong>typedef 引用</strong>一个<strong>模板</strong>。即无法定义一个 typedef 引用 Blob &lt; T &gt;。<br>
但是，新标准允许我们为<strong>类模板</strong>定义一个<strong>类型别名</strong>：</p>
<p>当我们定义一个模板类型别名时，可以固定一个或多个模板参数</p>
<p>与任何其他类相同，<strong>类模板</strong>可以<strong>声明 static 成员</strong>（参见7.6节，第269页）</p>
<p>与非模板类的静态成员相同，我们可以通过类类型对象来访问一个类模板的 static成员，也可以使用作用域运算符直接访问成员。当然，<strong>为了通过类来直接访问 static 成员，我们必须引用一个特定的实例（必须带有模板参数列表）</strong>：</p>
<p>模板所有实例类型都共享相同的static成员（包括数据成员和函数乘以）<br>
类似任何其他成员函数，一个 <strong>static 成员函数只有在使用时才会实例化</strong>。</p>
<p>习题16.9<br>
一个<strong>函数模板</strong>就是一个<strong>公式</strong>，可用来<strong>生成针对特定类型的函数版本</strong><br>
<strong>类模板 (class template)</strong> 是用来生成<strong>类的蓝图</strong>的<br>
习题16.10<br>
当编译器从我们的 Blob 模板<strong>实例化</strong>出一个类时，它会<strong>重写 Blob 模板</strong>，将模板参数T的每个实例替换为给定的<strong>模板实参</strong>，一个类模板的每个实例都形成一个<strong>独立的类类型</strong><br>
习题16.11<br>
在类内使用的ListItem必须显式定义其使用的模板类型是啥<br>
习题16.12<br>
如书中所示<br>
习题16.13<br>
应该选择一对一友好关系，只能在相同类型之间使用关系运算符<br>
习题16.14<br>
其实主要是</p>
<pre><code>template&lt;unsigned N,unsigned M&gt; 
class Screen{
unsigned  width = N, height = M
	}
</code></pre>
<p>习题16.15<br>
需要所有的非类型参数实例作为友元<br>
习题16.16<br>
太长了直接托管到github啦</p>
<p>16.1.3模板参数<br>
模板参数遵循普通的作用域规则。一个<strong>模板参数名</strong>的<strong>可用范围</strong>是在其<strong>声明之后</strong>，至模板<strong>声明或定义结束之前</strong>。与任何其他名字一样，模板参数会<strong>隐藏外层作用域中声明的相同名字</strong>。但是，与大多数其他上下文不同，在<strong>模板内不能重用模板参数名</strong>：</p>
<p>由于参数名不能重用，所以一个模板参数名在一个特定模板参数列表中<strong>只能出现一次</strong>:</p>
<p>模板声明必须包含模板参数<br>
与函数参数相同，<strong>声明中的模板参数的名字不必与定义中相同（甚至可以不给出参数名）</strong>：<br>
当然，<strong>一个给定模板的每个声明和定义必须有相同数量和种类（即，类型或非类型）的参数</strong>。</p>
<p>—个特定文件所需要的<strong>所有模板的声明</strong>通常<strong>一起放置在文件开始位置</strong>，出现于<strong>任何使用</strong>这些模板的<strong>代码之前</strong>，原因我们将在16.3常（第617页）中解释</p>
<p>我们用作用<strong>域运算符（：：）<strong>来访问</strong> static 成员</strong>和<strong>类型成员</strong>（参见7.4节，第253页和7.6节，第269页）。在普通（非模板）代码中，编译器掌握类的定义。因此，它知道通过作用域运算符访问的名字是类型还是 static 成员。<br>
但对于模板代码就存在困难。例如，假定 T 是一个模板类型参数，当编译器遇到类似T :: mem 这样的代码时，它不会知道 mem 是一个类型成员还是一个 static 数据成员，直至实例化时才会知道。但是，为了处理模板，编译器必须知道名字是否表示一个类型。<br>
默认情况下， C ++语言<strong>假定</strong>通过作用域运算符访问的名字<strong>不是类型</strong>。因此，如果我们希望使用一个模板类型参数的类型成员，就<strong>必须显式告诉编译器该名字是一个类型</strong>。</p>
<p>typename是为了说明T::访问的是类型<br>
当我们希望通知编译器一个名字表示类型时，<strong>必须使用关键字 typename</strong>，而**不能使用 class **。</p>
<p>我们也可以提供<strong>默认模板实参</strong>（default template argument )。<br>
与函数默认实参一样，对于一个模板参数，只有当它<strong>右侧的所有参数都有</strong>默认实参时，它才可以有默认实参。</p>
<p>如果一个类模板为其<strong>所有模板参数都提供了默认实参</strong>，且我们<strong>希望使用这些默认实参</strong>，就<strong>必须在模板名之后跟一个空括号对</strong>：<br>
Numbers&lt; &gt; average_precision; 	//<strong>空&lt; &gt;<strong>表示我们希望</strong>使用默认类型</strong></p>
<p>习题16.17<br>
平时没有区别，只有在指明访问运算符指向的是类型的时候必须用typename</p>
<p>习题16.18<br>
(a)U前面必须得有typename，不能省略<br>
(b)形参中不能重用模板参数名T<br>
(c)inline位置错误<br>
(d)缺少返回类型<br>
(e)正确，会隐藏外层的ctype<br>
知识点：函数模板可声明为 inline 或 constexpr 的，如同非模板函数一样。 inline 或constexpr 说明符放在模板参数列表之后，返回类型之前：</p>
<p>习题16.19</p>
<pre><code>template&lt;typename T&gt; void print(T &amp;cot) {
	for (typename T::size_type i = 0; i &lt; cot.size(); ++i)
		cout &lt;&lt; cot[i] &lt;&lt; endl;
	return;
}
int main() {
	vector&lt;int&gt; vi{ 1,2,3,4,5 };
	print(vi);
}
</code></pre>
<p>习题16.20</p>
<pre><code>template&lt;typename T&gt; void print(T &amp;cot) {
	for (typename T::iterator i = cot.begin(); i !=cot.end(); ++i)
		cout &lt;&lt; *i &lt;&lt; endl;
	return;
}
</code></pre>
<p>16.1.4成员模板<br>
一个类（无论是普通类还是类模板）可以<strong>包含本身是模板</strong>的<strong>成员函数</strong>。这种成员被称为成员模板 (member template )。成员模板<strong>不能是虚函数</strong>。</p>
<p>对于<strong>类模板</strong>，我们<strong>也可以</strong>为其定义<strong>成员模板</strong>。在此情况下，类和成员各自有自己的、独立的模板参数。<br>
与类模板的普通函数成员不同，成员模板是函数模板。当我们在<strong>类模板外定义一个成员模板时</strong>，<strong>必须同时为类模板和成员模板提供模板参数列表</strong>。<strong>类模板的参数列表在前</strong>，<strong>后跟成员自己的模板参数列表</strong>：</p>
<p>为了实例化一个类模板的成员模板，我们必须同时提供类和函数模板的实参。与往常一样，我们在<strong>哪个对象上调用成员模板</strong>，编译器就根据<strong>该对象的类型</strong>来推断<strong>类模板参数的实参</strong>。与普通函数模板相同，编译器通常根据传递给成员模板的函数实参来推断它的模板实参（参见16.1.1节，第579页）：<br>
（编译器不能为类模板推断模板参数类型。）？？？</p>
<p>习题16.21</p>
<pre><code>
class DebugDelete {
public:
	DebugDelete(std::ostream &amp;s=std::cerr): os(s){}
	template &lt;typename T&gt; void operator()(T *p)const {
		os &lt;&lt; &quot;deleting unique_ptr&quot; &lt;&lt; std::endl;
		delete p;
	}
private:
	std::ostream &amp;os;
};
</code></pre>
<p>习题16.22<br>
注意，这里说的删除器不是指free()或者delete()这两个函数,而是在定义的时候将内置的删除类型改为自定义的<br>
比如<br>
<code>unique_ptr&lt;int,DebugDelete&gt;p(new int,DebugDelete());</code><br>
习题16.23<br>
不是很明白意思<br>
习题16.24</p>
<pre><code>template &lt;typename T&gt;
Blob&lt;T&gt;::Blob(vector&lt;T&gt;::iterator beg, vector&lt;T&gt;::iterator end):data(std::make_shared&lt;vector&lt;T&gt;&gt;(beg,end));
</code></pre>
<p>我这个其实不太好，因为限定了必须是<code>vector&lt;T&gt;</code>的迭代器，完全可以用deque的迭代器范围来初始化一个vector<br>
网友的题解不错：<br>
T表示一个类型，IT表示一个类型，IT可以是迭代器类型，实例化时传入迭代器即可</p>
<pre><code>template&lt;typename T&gt; class Blob
{
public:
	template&lt;typename IT&gt; Blob(IT &amp;, IT &amp;);//声明
}; 
//类外定义,首先需要声明类模版参数列表，还要加上成员自己的模版参数列表，还有类作用域Blob&lt;T&gt;
template&lt;typename T&gt;
template&lt;typename IT&gt; Blob&lt;T&gt;:: Blob(IT &amp;a, IT &amp;b):data(make_shared&lt;vector&lt;T&gt;&gt;(a.b)){}
</code></pre>
<p>16.1.5 控制实例化<br>
当模板被使用时才会进行实例化（参见16.1.1 节，第582页）这一特性意味着，<strong>相同的实例</strong>可能出现在<strong>多个对象文件</strong>中。当两个或多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件中就都会有该模板的一个实例。<br>
在大系统中，在多个文件中实例化相同模板的额外开销可能非常严重。在新标准中，我们可以通过<strong>显式实例化来避免这种开销</strong>。</p>
<p>declaration是一个类或函数声明，其中所有模板参数已被替换为模板实参。例如</p>
<p><strong>区分模板声明与实例化声明</strong>当编译器遇到 <strong>extern 模板声明</strong>时，它<strong>不会</strong>在本文件中<strong>生成实例化代码</strong>。将一个实例化声明为 extern 就表示<strong>承诺</strong>在程序<strong>其他位置有该实例化的一个非 extern 声明（定义）</strong>。对于一个给定的实例化版本，<strong>可能有多个 extern 声明，但必须只有一个定义</strong>。<br>
由编译器在使用一个模板时自动对其实例化，因此** extern 声明必须出现<strong>在任何使用此实例化版本的代码</strong>之前**：</p>
<p>对每个实例化声明，在程序中<strong>某个位置必须有其显式的实例化定义</strong>。</p>
<p>一个类模板的实例化定义会实例化该模板的所有成员，包括<strong>内联的成员函数（和默认实例化不同）</strong>。当编译器遇到一个实例化定义时，它不了解程序使用哪些成员函数。因此，<strong>与处理类模板的普通实例化不同</strong>，编译器会<strong>实例化该类的所有成员</strong>。<strong>即使我们不使用某个成员</strong>，它也会被实例化。因此，我们用来<strong>显式实例化</strong>一个类模板的类型，<strong>必须能用于模板的所有成员</strong>。（普通实例化亦即默认实例化不一定所有成员都能用）</p>
<p>习题16.25<br>
第一个是string类型的vector的实例化声明<br>
第二个是Sales_Data类型的vector的实例化定义<br>
习题16.26<br>
不能，因为必须实例化每个成员，包括Nodefault构造函数<br>
习题16.27<br>
bc未被实例化，其他的都被实例化了//我这个想法显然是搞混了类模板和使用了类模板的类两个概念<br>
先贴一个网友的结论</p>
<blockquote>
<p>27 题留下点儿不同意见，如有不对请指正：abcf 需要实例化，其它都不需要。理由：当需要某个模板类的定义时，对模板进行实例化——检查类型是否匹配时需要定义——分配空间用来创建元素时需要定义。(a) 这是对 f1 的声明，f1 的参数是 <code>Stack&lt;char&gt;</code>。需要在这里检查实参和形参的类型是否匹配(然后调用拷贝构造函数)，编译时就需要 <code>Stack&lt;char&gt;</code> 的定义，所以需要实例化，注意，这里就算是引用传参而不是值传参，也一样是需要实例化的，因为需要检查引用的类型与绑定的对象的类型是否一致；(b) 引用需要在初始化时绑定到一个相同类型的对象上，在调用这句话时，一定是想把它绑定到一个对象上，例如在构造函数中为 rsd 赋初值(必须赋初值，不然会报错)。由于在编译阶段需要检查引用类型和绑定的对象的类型是否一致，因此需要知道<code>Stack&lt;double&gt;</code> 的定义，所以需要实例化；(c) 编译时需要知道创建 si 成员需要多大空间，需要<code>Stack&lt;int&gt;</code> 的定义，因此需要实例化；(d) 指针与引用不同，它不是一定要初始化，这里 sc 没有初始化，它就是一个未定义的地址。它不需要<code>Stack&lt;char&gt;</code>的定义，所以不需要实例化。如果初始化了，那么才需要检查指针类型与初始化的对象类型是否一致，这样才需要 <code>Stack&lt;char&gt;</code> 的定义，才需要对 Stack 实例化。(e) 传个参而已，不需要实例化；(f) 需要实例化，因为需要知道 <code>Stack&lt;string&gt;</code> 的定义，才能知道 <code>sizeof(Stack&lt;string&gt;)</code>。</p>
</blockquote>
<p>16.1.6效率与灵活性<br>
shared _ ptr和unique _ ptr之间的明显不同是它们管理所保存的指针的策略 ---<br>
前者给予我们共享指针所有权的能力；后者则独占指针。这一差异对两个类的功能来说是至关重要的。<br>
这两个类的<strong>另一个差异</strong>是它们允许用户<strong>重载默认删除器</strong>的方式。我们可以很容易地重<br>
载一个 shared _ ptr 的删除器，只要在创建或 reset 指针时传递给它一个可调用对象即可。与之相反，删除器的类型是一个 unique _ ptr 对象的类型的一部分。用户必须在<strong>定义</strong> unique _ ptr 时以<strong>显式模板实参</strong>的形式<strong>提供删除器的类型</strong>。因此，对于 unique_ptr的用户来说，提供自己的删除器就更为复杂。</p>
<p><strong>而unique_ptr需要 unique_ptr&lt;T,D&gt; up(t,d) //删除器类型为D</strong><br>
<strong>shared _ ptr</strong> 必须能<strong>直接访问其删除器</strong>。即，删除器必须保存为一个<strong>指针</strong>或一个<strong>封装指针的类</strong>(如 function ,参见14.8.3节，第512页）。<br>
我们可以确定 shared _ ptr <strong>不是</strong>将删除器<strong>直接保存为一个成员</strong>，因为删除器的类型直到<strong>运行时才会知道</strong>。实际上，在一个 shared _ ptr 的生存期中，我们可以<strong>随时改变</strong>其删除器的<strong>类型</strong>。<br>
通常，<strong>类成员的类型</strong>在<strong>运行时是不能改变</strong>的。因此，<strong>不能直接保存删除器</strong>。</p>
<p>在unique_ptr类中，删除器的类型是<strong>类类型的一部分</strong>。即，** unique _ ptr 有两个模板参数unique_ptr&lt;T,D&gt;<strong>，一个表示它所管理的指针，另一个表示删除器的类型。由于删除器的类型是 unique _ ptr 类型的一部分，因此删除器成员的类型在编译时是知道的，从而</strong>删除器可以直接保存在 unique _ ptr 对象中**。<br>
通过在<strong>编译时绑定</strong>删除器， unique _ ptr <strong>避免了</strong>间接调用删除器的<strong>运行时开销</strong>。通过在<strong>运行时绑定</strong>删除器， shared _ ptr 使用户<strong>重载删除器</strong>更为方便。</p>
<p>习题16.28-31<br>
我感jio需要去找源码来学习一下</p>
<p>习题感悟：<br>
需要注意的点：<br>
1.库函数find的返回值为迭代器（虽然是输入迭代器），这里我还是直接用T吧<br>
2.注意循环判断条件不能用<code>i&lt;end</code>，因为只有随机迭代器才支持关系运算符，题目中的list使用双向迭代器就没法用小于号<br>
1<code>.T(&amp;arr)[N]</code>的括号不可少，否则就是引用的数组了。然后N也不可少，N也属于形参类型的一部分<br>
2.strlen计算长度的时候会忽视空字符，但是实际char数组中还是得老老实实加上一位存空字符，否则会报错（昨天的面试题中就有一道考strlen细节的）<br>
知识点：函数模板可声明为 inline 或 constexpr 的，如同非模板函数一样。 inline 或constexpr 说明符放在模板参数列表之后，返回类型之前：</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 104. 二叉树的最大深度[简单]]]></title>
        <id>https://lixin-ee.github.io//post/shu-104-er-cha-shu-de-zui-da-shen-du-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/shu-104-er-cha-shu-de-zui-da-shen-du-jian-dan">
        </link>
        <updated>2019-11-17T00:53:18.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个二叉树，找出其最大深度。<br>
二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>
说明: 叶子节点是指没有子节点的节点。<br>
示例：<br>
给定二叉树 [3,9,20,null,null,15,7]，<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7<br>
返回它的最大深度 3 。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>其实那个题号顺序还是有那么一点问题，我感觉这道题理应放在111前面<br>
寻找最小深度的时候可着实是麻烦了一把，这一次求最大深度，就没那么麻烦了，直接大力出奇迹，连叶节点的判断都不用了，反正i最大的那个肯定就是叶节点（非叶节点的深度不可能超过叶节点的）<br>
代码也非常简洁：</p>
<pre><code>class Solution {
public:
    int maxDepth(TreeNode* root) {
        return preorder(root,0);
    }
    
    int preorder(TreeNode* cur,int i){
        if(cur==NULL)
            return i;
        return max(preorder(cur-&gt;left,i+1),preorder(cur-&gt;right,i+1));
    }
};
</code></pre>
<p>官方题解如下：</p>
<blockquote>
<p>方法一：递归<br>
算法<br>
直观的方法是通过递归来解决问题。在这里，我们演示了 DFS（深度优先搜索）策略的示例。</p>
</blockquote>
<pre><code>Java
class Solution {
  public int maxDepth(TreeNode root) {
    if (root == null) {
      return 0;
    } else {
      int left_height = maxDepth(root.left);
      int right_height = maxDepth(root.right);
      return java.lang.Math.max(left_height, right_height) + 1;
    }
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：我们每个结点只访问一次，因此时间复杂度为 O(N)，<br>
其中 N 是结点的数量。<br>
空间复杂度：在最糟糕的情况下，树是完全不平衡的，例如每个结点只剩下左子结点，递归将会被调用 N 次（树的高度），因此保持调用栈的存储将是 O(N)。但在最好的情况下（树是完全平衡的），树的高度将是log(N)。因此，在这种情况下的空间复杂度将是O(log(N))。</p>
</blockquote>
<blockquote>
<p>方法二：迭代<br>
我们还可以在栈的帮助下将上面的递归转换为迭代。<br>
我们的想法是使用 DFS 策略访问每个结点，同时在每次访问时更新最大深度。<br>
所以我们从包含根结点且相应深度为 1 的栈开始。然后我们继续迭代：将当前结点弹出栈并推入子结点。每一步都会更新深度。</p>
</blockquote>
<pre><code>Java
import javafx.util.Pair;
import java.lang.Math;

class Solution {
  public int maxDepth(TreeNode root) {
    Queue&lt;Pair&lt;TreeNode, Integer&gt;&gt; stack = new LinkedList&lt;&gt;();
    if (root != null) {
      stack.add(new Pair(root, 1));
    }

    int depth = 0;
    while (!stack.isEmpty()) {
      Pair&lt;TreeNode, Integer&gt; current = stack.poll();
      root = current.getKey();
      int current_depth = current.getValue();
      if (root != null) {
        depth = Math.max(depth, current_depth);
        stack.add(new Pair(root.left, current_depth + 1));
        stack.add(new Pair(root.right, current_depth + 1));
      }
    }
    return depth;
  }
};
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(N)。<br>
空间复杂度：O(N)。</p>
</blockquote>
<p>官方的解法一致，这道题还是比较简单的。</p>
]]></content>
    </entry>
</feed>