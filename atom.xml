<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-12-12T01:59:00.098Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[二分查找 33. 搜索旋转排序数组[中等][未做出]]]></title>
        <id>https://lixin-ee.github.io//post/er-fen-cha-zhao-33-sou-suo-xuan-zhuan-pai-xu-shu-zu-zhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/er-fen-cha-zhao-33-sou-suo-xuan-zhuan-pai-xu-shu-zu-zhong-deng-wei-zuo-chu">
        </link>
        <updated>2019-12-12T01:34:20.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br>
( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。<br>
搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。<br>
你可以假设数组中不存在重复的元素。<br>
你的算法时间复杂度必须是 O(log n) 级别。<br>
示例 1:<br>
输入: nums = [4,5,6,7,0,1,2], target = 0<br>
输出: 4<br>
示例 2:<br>
输入: nums = [4,5,6,7,0,1,2], target = 3<br>
输出: -1<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/search-in-rotated-sorted-array<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>//这道题的话我一开始的想法是；将mid和first和last比较，如果<br>
//没如果完呢，发现自己看错题目了，是进行旋转后再进行查找，而不是查找旋转点<br>
//旋转之后必定中间值大于最右值 小于最左值<br>
//所以需要对边界条件进行分情况监测<br>
//弃疗了，边界条件太复杂了，情况太多了</p>
<p>错误代码如下：</p>
<pre><code>class Solution {
public:
    int search(vector&lt;int&gt;&amp; nums, int target) {
        if(nums.empty())
            return -1;
        int first=0,last=nums.size()-1,mid;
        while(first&lt;last){
            mid=first+(last-first)/2;
            if(target==nums[mid])
                return mid;
            if(nums[first]&gt;nums[last]){
               if(target&gt;nums[last]&amp;&amp;target&lt;nums[first])
                   return -1;
                
                if(nums[mid]&gt;=nums[first])
                    if(target&gt;nums[mid]||target&lt;nums[first]) first=mid+1;
                    else last=mid;
                
                if(nums[mid]&lt;=nums[first])
                    if(target&gt;nums[mid]||target&lt;nums[first]) last=mid;
                    else first=mid+1;
            }else{
                if(target&lt;nums[mid]) last=mid;
                else first=mid+1;
            }   
					}
        if(nums[first]==target) return first; 
        return -1; 
    }
};
</code></pre>
<p>补充<br>
//最后看了题解，这个异或太6了，实在是太6了</p>
<pre><code>class Solution {
public:
    int search(vector&lt;int&gt;&amp; nums, int target) {
        if(nums.empty()) return -1;
        int first=0,last=nums.size()-1,mid;
        while(first&lt;last){
            mid=first+(last-first)/2;
            if(nums[mid]&lt;nums[first]^target&lt;=nums[mid]^target&gt;=nums[first])
                first=mid+1;
            else
                last=mid;
        }
        if(nums[first]==target)
            return first;
        return -1;
    }
};
</code></pre>
<p>然后是网友原题解</p>
<pre><code>class Solution {
public:
    int search(vector&lt;int&gt;&amp; nums, int target) {
        int lo = 0, hi = nums.size() - 1;
        while (lo &lt; hi) {
            int mid = (lo + hi) / 2;
            if ((nums[0] &gt; target) ^ (nums[0] &gt; nums[mid]) ^ (target &gt; nums[mid]))
                lo = mid + 1;
            else
                hi = mid;
        }
        return lo == hi &amp;&amp; nums[lo] == target ? lo : -1;
    }
};
</code></pre>
<blockquote>
<p>以二分搜索为基本思路</p>
</blockquote>
<blockquote>
<p>简要来说：<br>
nums[0] &lt;= nums[mid]（0 - mid不包含旋转）且nums[0] &lt;= target &lt;= nums[mid] 时 high 向前规约；<br>
nums[mid] &lt; nums[0]（0 - mid包含旋转），target &lt;= nums[mid] &lt; nums[0] 时向前规约（target 在旋转位置到 mid 之间）<br>
nums[mid] &lt; nums[0]，nums[mid] &lt; nums[0] &lt;= target 时向前规约（target 在 0 到旋转位置之间）<br>
其他情况向后规约<br>
也就是说nums[mid] &lt; nums[0]，nums[0] &gt; target，target &gt; nums[mid] 三项均为真或者只有一项为真时向后规约。</p>
</blockquote>
<blockquote>
<p>原文的分析是：<br>
注意到原数组为有限制的有序数组（除了在某个点会突然下降外均为升序数组）<br>
if nums[0] &lt;= nums[I] 那么 nums[0] 到 nums[i] 为有序数组,那么当 nums[0] &lt;= target &lt;= nums[i] 时我们应该在 0-i0−i 范围内查找；<br>
if nums[i] &lt; nums[0] 那么在 0-i0−i 区间的某个点处发生了下降（旋转），那么 I+1I+1 到最后一个数字的区间为有序数组，并且所有的数字都是小于 nums[0] 且大于 nums[i]，当target不属于 nums[0] 到 nums[i] 时（target &lt;= nums[i] &lt; nums[0] or nums[i] &lt; nums[0] &lt;= target），我们应该在 0-i0−i 区间内查找。<br>
上述三种情况可以总结如下：<br>
nums[0] &lt;= target &lt;= nums[i]<br>
target &lt;= nums[i] &lt; nums[0]<br>
nums[i] &lt; nums[0] &lt;= target<br>
所以我们进行三项判断：<br>
(nums[0] &lt;= target)， (target &lt;= nums[i]) ，(nums[i] &lt; nums[0])，现在我们想知道这三项中有哪两项为真（明显这三项不可能均为真或均为假（因为这三项可能已经包含了所有情况））<br>
所以我们现在只需要区别出这三项中有两项为真还是只有一项为真。<br>
使用 “异或” 操作可以轻松的得到上述结果（两项为真时异或结果为假，一项为真时异或结果为真，可以画真值表进行验证）<br>
之后我们通过二分查找不断做小 target 可能位于的区间直到 low==high，此时如果 nums[low]==target 则找到了，如果不等则说明该数组里没有此项。</p>
</blockquote>
<p>剩下的网友题解就和这个大同小异了</p>
<p>然后是官方的通用题解，虽然复杂一点，但是寻找旋转点的方法通用性更高</p>
<blockquote>
<p>方法：二分查找<br>
题目要找到一种 O(logN)时间内的搜索方法，这提示我们可以用二分查找的方法。<br>
算法非常直接：<br>
找到旋转的下标 rotation_index ，也就是数组中最小的元素。二分查找在这里可以派上用场。<br>
在选中的数组区域中再次使用二分查找。</p>
</blockquote>
<pre><code>class Solution {
  int [] nums;
  int target;

  public int find_rotate_index(int left, int right) {
    if (nums[left] &lt; nums[right])
      return 0;

    while (left &lt;= right) {
      int pivot = (left + right) / 2;
      if (nums[pivot] &gt; nums[pivot + 1])
        return pivot + 1;
      else {
        if (nums[pivot] &lt; nums[left])
          right = pivot - 1;
        else
          left = pivot + 1;
      }
    }
    return 0;
  }

  public int search(int left, int right) {
    /*
    Binary search
    */
    while (left &lt;= right) {
      int pivot = (left + right) / 2;
      if (nums[pivot] == target)
        return pivot;
      else {
        if (target &lt; nums[pivot])
          right = pivot - 1;
        else
          left = pivot + 1;
      }
    }
    return -1;
  }

  public int search(int[] nums, int target) {
    this.nums = nums;
    this.target = target;

    int n = nums.length;

    if (n == 0)
      return -1;
    if (n == 1)
      return this.nums[0] == target ? 0 : -1;

    int rotate_index = find_rotate_index(0, n - 1);

    // if target is the smallest element
    if (nums[rotate_index] == target)
      return rotate_index;
    // if array is not rotated, search in the entire array
    if (rotate_index == 0)
      return search(0, n - 1);
    if (target &lt; nums[0])
      // search in the right side
      return search(rotate_index, n - 1);
    // search in the left side
    return search(0, rotate_index);
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度： O(logN)。<br>
空间复杂度： O(1) 。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二分查找法模板]]></title>
        <id>https://lixin-ee.github.io//post/er-fen-cha-zhao-fa-mo-ban</id>
        <link href="https://lixin-ee.github.io//post/er-fen-cha-zhao-fa-mo-ban">
        </link>
        <updated>2019-12-11T01:13:28.000Z</updated>
        <content type="html"><![CDATA[<p>原文转自<a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/">二分查找法模板-liweiwei1419</a></p>
<p>其实二分查找法主要就是边界问题比较麻烦，我个人的理解是mid的左倾和右倾的问题，但是我个人也表述得不是很好，所以转发一下网友的优秀题解，以供日后使用<br>
下面开始是原文：</p>
<p>1、导读<br>
本文介绍了我这半年以来，在刷题过程中使用“二分查找法”刷题的一个模板，包括这个模板的优点、使用技巧、注意事项、调试方法等。虽说是模板，但我不打算一开始就贴出代码，因为这个模板根本没有必要记忆，只要你能够理解文中叙述的知识点和注意事项，并加以应用（刷题），相信你会和我一样喜欢这个模板，并且认为使用它是自然而然的事情。</p>
<p>这个模板应该能够帮助你解决 LeetCode 带“二分查找”标签的常见问题（简单、中等难度）。只要你能够理解文中叙述的知识点和注意事项，并加以应用（其实就是多刷题），相信你会和我一样喜欢这个模板，并且认为使用它是自然而然的事情。</p>
<p>3、“传统的”二分查找法模板的问题<br>
（1）取中位数索引的代码有问题<br>
<code>int mid = (left + right) / 2</code><br>
这行代码是有问题的，在 left 和 right 都比较大的时候，left + right 很有可能超过 int 类型能表示的最大值，即整型溢出，为了避免这个问题，应该写成：<br>
<code>int mid = left + (right - left) / 2 ;</code><br>
事实上，int mid = left + (right - left) / 2 在 right 很大、 left 是负数且很小的时候， right - left 也有可能超过 int 类型能表示的最大值，只不过一般情况下 left 和 right 表示的是数组索引值，left 是非负数，因此 right - left 溢出的可能性很小。</p>
<p>更好的写法是：<br>
<code>int mid = (left + right) &gt;&gt;&gt; 1 ;</code><br>
原因在后文介绍，请读者留意：</p>
<p>使用“左边界索引 + 右边界索引”，然后“无符号右移 1 位”是推荐的写法。</p>
<p>（2）循环可以进行的条件写成 while (left &lt;= right) 时，在退出循环的时候，需要考虑返回 left 还是 right，稍不注意，就容易出错<br>
以本题（LeetCode 第 35 题：搜索插入位置）为例。<br>
分析：根据题意并结合题目给出的 4 个示例，不难分析出这个问题的等价表述如下：<br>
1、如果目标值（严格）大于排序数组的最后一个数，返回这个排序数组的长度，否则进入第 2 点。<br>
2、返回排序数组从左到右，大于或者等于目标值的第 1 个数的索引。</p>
<p>事实上，当给出数组中有很多数和目标值相等的时候，我们返回任意一个与之相等的数的索引值都可以，不过为了简单起见，也为了方便后面的说明，我们返回第 1 个符合题意的数的索引。</p>
<p>题目告诉你“排序数组”，其实就是在疯狂暗示你用二分查找法。 二分查找法的思想并不难，但写好一个二分法并不简单，下面就借着这道题为大家做一个总结。</p>
<p>刚接触二分查找法的时候，我们可能会像下面这样写代码，我把这种写法容易出错的地方写在了注释里：<br>
参考代码：针对本题（LeetCode 第 35 题）</p>
<pre><code>public class Solution3 {

    public int searchInsert(int[] nums, int target) {
        int len = nums.length;
        if (nums[len - 1] &lt; target) {
            return len;
        }

        int left = 0;
        int right = len - 1;

        while (left &lt;= right) {
            int mid = (left + right) / 2;
            // 等于的情况最简单，我们应该放在第 1 个分支进行判断
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] &lt; target) {
                // 题目要我们返回大于或者等于目标值的第 1 个数的索引
                // 此时 mid 一定不是所求的左边界，
                // 此时左边界更新为 mid + 1
                left = mid + 1;
            } else {
                // 既然不会等于，此时 nums[mid] &gt; target
                // mid 也一定不是所求的右边界
                // 此时右边界更新为 mid - 1
                right = mid - 1;
            }
        }
        // 注意：一定得返回左边界 left，
        // 如果返回右边界 right 提交代码不会通过
        // 【注意】下面我尝试说明一下理由，如果你不太理解下面我说的，那是我表达的问题
        // 但我建议你不要纠结这个问题，因为我将要介绍的二分查找法模板，可以避免对返回 left 和 right 的讨论

        // 理由是对于 [1,3,5,6]，target = 2，返回大于等于 target 的第 1 个数的索引，此时应该返回 1
        // 在上面的 while (left &lt;= right) 退出循环以后，right &lt; left，right = 0 ，left = 1
        // 根据题意应该返回 left，
        // 如果题目要求你返回小于等于 target 的所有数里最大的那个索引值，应该返回 right
				
        return left;
    }
}
</code></pre>
<p>说明：<br>
1、当把二分查找法的循环可以进行的条件写成 while (left &lt;= right) 时，在写最后一句 return 的时候，如果不假思索，把左边界 left 返回回去，虽然写对了，但可以思考一下为什么不返回右边界 right 呢？<br>
2、但是事实上，返回 left 是有一定道理的，如果题目换一种问法，你可能就要返回右边界 right，这句话不太理解没有关系，我也不打算讲得很清楚（在上面代码的注释中我已经解释了原因），因为实在太绕了，这不是我要说的重点。</p>
<p>由此，我认为“传统二分查找法模板”使用的痛点在于：<br>
传统二分查找法模板，当退出 while 循环的时候，在返回左边界还是右边界这个问题上，比较容易出错。<br>
那么，是不是可以回避这个问题呢？答案是肯定的，答案就在下面我要介绍的“神奇的”二分查找法模板里。</p>
<p>4、“神奇的”二分查找法模板的基本思想<br>
（1）首先把循环可以进行的条件写成 while(left &lt; right)，在退出循环的时候，一定有 left == right 成立，此时返回 left 或者 right 都可以<br>
或许你会问：退出循环的时候还有一个数没有看啊（退出循环之前索引 left 或 索引 right 上的值）？<br>
没有关系，我们就等到退出循环以后来看，甚至经过分析，有时都不用看，就能确定它是目标数值。<br>
（什么时候需要看最后剩下的那个数，什么时候不需要，会在第 5 点介绍。）<br>
更深层次的思想是“夹逼法”或者称为“排除法”。</p>
<p>（2）“神奇的”二分查找法模板的基本思想（特别重要）<br>
“排除法”即：在每一轮循环中排除一半以上的元素，于是在对数级别的时间复杂度内，就可以把区间“夹逼” 只剩下 1 个数，而这个数是不是我们要找的数，单独做一次判断就可以了。<br>
“夹逼法”或者“排除法”是二分查找算法的基本思想，“二分”是手段，在目标元素不确定的情况下，“二分” 也是“最大熵原理”告诉我们的选择。<br>
还是 LeetCode 第 35 题，下面给出使用 while (left &lt; right) 模板写法的 2 段参考代码，以下代码的细节部分在后文中会讲到，因此一些地方不太明白没有关系，暂时跳过即可。</p>
<pre><code>public class Solution {

    public int searchInsert(int[] nums, int target) {
        int len = nums.length;

        if (len == 0) {
            return 0;
        }

        int left = 0;
        int right = len;

        while (left &lt; right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] &lt; target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }
}
</code></pre>
<p>参考代码 2：对于是否接在原有序数组后面单独判断，不满足的时候，再在候选区间的索引范围 [0, size - 1] 内使用二分查找法进行搜索。</p>
<pre><code>public class Solution {

    // 只会把比自己大的覆盖成小的
    // 二分法
    // 如果有一连串数跟 target 相同，则返回索引最靠前的

    // 特例： 3 5 5 5 5 5 5 5 5 5
    // 特例： 3 6 7 8

    // System.out.println(&quot;尝试过的值：&quot; + mid);
    // 1 2 3 5 5 5 5 5 5 6 ，target = 5
    // 1 2 3 3 5 5 5 6 target = 4


    public int searchInsert(int[] nums, int target) {
        int len = nums.length;
        if (len == 0) {
            return -1;
        }
        if (nums[len - 1] &lt; target) {
            return len;
        }
        int left = 0;
        int right = len - 1;
        while (left &lt; right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] &lt; target) {
                // nums[mid] 的值可以舍弃
                left = mid + 1;
            } else {
                // nums[mid] 不能舍弃
                right = mid;
            }
        }
        return right;
    }

    public static void main(String[] args) {
        int[] nums = {1, 2, 3, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6};
        int target = 4;
        Solution2 solution2 = new Solution2();
        int searchInsert = solution2.searchInsert(nums, target);
        System.out.println(searchInsert);
    }
}
</code></pre>
<p>5、细节、注意事项、调试方法<br>
（1）前提：思考左、右边界，如果左、右边界不包括目标数值，会导致错误结果<br>
例：LeetCode 第 69 题：x 的平方根</p>
<p>实现 int sqrt(int x) 函数。</p>
<p>计算并返回 x 的平方根，其中 x 是非负整数。</p>
<p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<p>分析：一个非负整数的平方根最小可能是 0 ，最大可能是它自己。<br>
因此左边界可以取 0 ，右边界可以取 x。<br>
可以分析得再细一点，但这道题没有必要，因为二分查找法会帮你排除掉不符合的区间元素。</p>
<p>例：LeetCode 第 287 题：寻找重复数</p>
<p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p>
<p>分析：题目告诉我们“其数字都在 1 到 n 之间（包括 1 和 n）”。因此左边界可以取 1 ，右边界可以取 n。</p>
<p>要注意 2 点：</p>
<p>如果 left 和 right 表示的是数组的索引，就要考虑“索引是否有效” ，即“索引是否越界” 是重要的定界依据；</p>
<p>左右边界一定要包括目标元素，例如 LeetCode 第 35 题：“搜索插入位置” ，当 target 比数组中的最后一个数字还要大（不能等于）的时候，插入元素的位置就是数组的最后一个位置 + 1，即 (len - 1 + 1 =) len，如果忽略掉这一点，把右边界定为 len - 1 ，代码就不能通过在线测评。</p>
<p>（2）中位数先写 int mid = (left + right) &gt;&gt;&gt; 1 ; 根据循环里分支的编写情况，再做调整<br>
理解这一点，首先要知道：当数组的元素个数是偶数的时候，中位数有左中位数和右中位数之分。</p>
<p>当数组的元素个数是偶数的时候：<br>
使用 int mid = left + (right - left) / 2 ; 得到左中位数的索引；</p>
<p>使用 int mid = left + (right - left + 1) / 2 ; 得到右中位数的索引。</p>
<p>当数组的元素个数是奇数的时候，以上二者都能选到最中间的那个中位数。<br>
其次，</p>
<p>int mid = left + (right - left) / 2 ; 等价于 int mid = (left + right) &gt;&gt;&gt; 1；</p>
<p>int mid = left + (right - left + 1) / 2 ; 等价于 int mid = (left + right + 1) &gt;&gt;&gt; 1 。</p>
<p>我们使用一个具体的例子来验证：当左边界索引 left = 3，右边界索引 right = 4 的时候，</p>
<p>mid1 = left + (right - left) // 2 = 3 + (4 - 3) // 2 = 3 + 0 = 3，</p>
<p>mid2 = left + (right - left + 1) // 2 = 3 + (4 - 3 + 1) // 2 = 3 + 1 = 4。</p>
<p>左中位数 mid1 是索引 left，右中位数 mid2 是索引 right。</p>
<p>记忆方法：</p>
<p>(right - left) 不加 11 选左中位数，加 11 选右中位数。</p>
<p>那么，什么时候使用左中位数，什么时候使用右中位数呢？选中位数的依据是为了避免死循环，得根据分支的逻辑来选择中位数，而分支逻辑的编写也有技巧，下面具体说。</p>
<p>（3）先写逻辑上容易想到的分支逻辑，这个分支逻辑通常是排除中位数的逻辑；<br>
在逻辑上，“可能是也有可能不是”让我们感到犹豫不定，但**“一定不是”是我们非常坚决的，通常考虑的因素特别单一，因此“好想” **。在生活中，我们经常听到这样的话：找对象时，“有车、有房，可以考虑，但没有一定不要”；找工作时，“事儿少、离家近可以考虑，但是钱少一定不去”，就是这种思想的体现。</p>
<p>例：LeetCode 第 69 题：x 的平方根</p>
<p>实现 int sqrt(int x) 函数。</p>
<p>计算并返回 x 的平方根，其中 x 是非负整数。</p>
<p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<p>分析：因为题目中说“返回类型是整数，结果只保留整数的部分，小数部分将被舍去”。例如 55 的平方根约等于 2.2362.236，在这道题应该返回 22。因此如果一个数的平方小于或者等于 x，那么这个数有可能是也有可能不是 x 的平方根，但是能很肯定的是，如果一个数的平方大于 x ，这个数肯定不是 x 的平方根。</p>
<p>注意：先写“好想”的分支，排除了中位数之后，通常另一个分支就不排除中位数，而不必具体考虑另一个分支的逻辑的具体意义，且代码几乎是固定的。</p>
<p>（4）循环内只写两个分支，一个分支排除中位数，另一个分支不排除中位数，循环中不单独对中位数作判断<br>
既然是“夹逼”法，没有必要在每一轮循环开始前单独判断当前中位数是否是目标元素，因此分支数少了一支，代码执行效率更高。</p>
<p>以下是“排除中位数的逻辑”思考清楚以后，可能出现的两个模板代码。<br>
<img src="https://lixin-ee.github.io//post-images/1576028651703.png" alt=""><br>
可以排除“中位数”的逻辑，通常比较好想，但并不绝对，这一点视情况而定。</p>
<p>分支条数变成 2 条，比原来 3 个分支要考虑的情况少，好处是：</p>
<p>不用在每次循环开始单独考虑中位数是否是目标元素，节约了时间，我们只要在退出循环的时候，即左右区间压缩成一个数（索引）的时候，去判断这个索引表示的数是否是目标元素，而不必在二分的逻辑中单独做判断。</p>
<p>这一点很重要，希望读者结合具体练习仔细体会，每次循环开始的时候都单独做一次判断，在统计意义上看，二分时候的中位数恰好是目标元素的概率并不高，并且即使要这么做，也不是普适性的，不能解决绝大部分的问题。</p>
<p>还以 LeetCode 第 35 题为例，通过之前的分析，我们需要找到“大于或者等于目标值的第 1 个数的索引”。对于这道题而言：</p>
<p>（1）如果中位数小于目标值，它就应该被排除，左边界 left 就至少是 mid + 1；</p>
<p>（2）如果中位数大于等于目标值，还不能够肯定它就是我们要找的数，因为要找的是等于目标值的第 11 个数的索引，中位数以及中位数的左边都有可能是符合题意的数，因此右边界就不能把 mid 排除，因此右边界 right 至多是 mid，此时右边界不向左边收缩。</p>
<p>下一点就更关键了。</p>
<p>（5）根据分支逻辑选择中位数的类型，可能是左中位数，也可能是右位数，选择的标准是避免死循环<br>
<img src="https://lixin-ee.github.io//post-images/1576028680066.png" alt=""><br>
死循环容易发生在区间只有 22 个元素时候，此时中位数的选择尤为关键。选择中位数的依据是：避免出现死循环。我们需要确保：</p>
<p>（下面的这两条规则说起来很绕，可以暂时跳过）。</p>
<p>1、如果分支的逻辑，在选择左边界的时候，不能排除中位数，那么中位数就选“右中位数”，只有这样区间才会收缩，否则进入死循环；</p>
<p>2、同理，如果分支的逻辑，在选择右边界的时候，不能排除中位数，那么中位数就选“左中位数”，只有这样区间才会收缩，否则进入死循环。</p>
<p>理解上面的这个规则可以通过具体的例子。针对以上规则的第 1 点：如果分支的逻辑，在选择左边界的时候不能排除中位数，例如：</p>
<pre><code>while left &lt; right:
      # 不妨先写左中位数，看看你的分支会不会让你代码出现死循环，从而调整
    mid = left + (right - left) // 2
    # 业务逻辑代码
    if (check(mid)):
        # 选择右边界的时候，可以排除中位数
        right = mid - 1
    else:
        # 选择左边界的时候，不能排除中位数
        left = mid
</code></pre>
<p>在区间中的元素只剩下 22 个时候，例如：left = 3，right = 4。此时左中位数就是左边界，如果你的逻辑执行到 left = mid 这个分支，且你选择的中位数是左中位数，此时左边界就不会得到更新，区间就不会再收缩（理解这句话是关键），从而进入死循环；<br>
为了避免出现死循环，你需要选择中位数是右中位数，当逻辑执行到 left = mid 这个分支的时候，因为你选择了右中位数，让逻辑可以转而执行到 right = mid - 1 让区间收缩，最终成为 1 个数，退出 while 循环。<br>
上面这段话不理解没有关系，因为我还没有举例子，你有个印象就好，类似地，理解选择中位数的依据的第 2 点。</p>
<p>（6）退出循环的时候，可能需要对“夹逼”剩下的那个数单独做一次判断，这一步称之为“后处理”。<br>
二分查找法之所以高效，是因为它利用了数组有序的特点，在每一次的搜索过程中，都可以排除将近一半的数，使得搜索区间越来越小，直到区间成为一个数。回到这一节最开始的疑问：“区间左右边界相等（即收缩成 1 个数）时，这个数是否会漏掉”，解释如下：</p>
<p>1、如果你的业务逻辑保证了你要找的数一定在左边界和右边界所表示的区间里出现，那么可以放心地返回 left 或者 right，无需再做判断；</p>
<p>2、如果你的业务逻辑不能保证你要找的数一定在左边界和右边界所表示的区间里出现，那么只要在退出循环以后，再针对 nums[left] 或者 nums[right] （此时 nums[left] == nums[right]）单独作一次判断，看它是不是你要找的数即可，这一步操作常常叫做“后处理”。</p>
<p>如果你能确定候选区间里目标元素一定存在，则不必做“后处理”。<br>
例：LeetCode 第 69 题：x 的平方根</p>
<p>实现 int sqrt(int x) 函数。</p>
<p>计算并返回 x 的平方根，其中 x 是非负整数。</p>
<p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<p>分析：非负实数 x 的平方根在 [0, x] 内一定存在，故退出 while (left &lt; right) 循环以后，不必单独判断 left 或者 right 是否符合题意。</p>
<p>如果你不能确定候选区间里目标元素一定存在，需要单独做一次判断。<br>
例：LeetCode 第 704 题：二分查找</p>
<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<p>分析：因为目标数有可能不在数组中，当候选区间夹逼成一个数的时候，要单独判断一下这个数是不是目标数，如果不是，返回 -1。</p>
<p>（7）取中位数的时候，要避免在计算上出现整型溢出；<br>
int mid = (left + right) / 2; 的问题：在 left 和 right 很大的时候，left + right 会发生整型溢出，变成负数，这是一个 bug ，得改！</p>
<p>int mid = left + (right - left) / 2; 在 right 很大、 left 是负数且很小的时候， right - left 也有可能超过 int 类型能表示的最大值，只不过一般情况下 left 和 right 表示的是数组索引值，left 是非负数，因此 right - left 溢出的可能性很小。因此，它是正确的写法。下面介绍推荐的写法。</p>
<p>int mid = (left + right) &gt;&gt;&gt; 1; 如果这样写， left + right 在发生整型溢出以后，会变成负数，此时如果除以 22 ，mid 是一个负数，但是经过无符号右移，可以得到在不溢出的情况下正确的结果。</p>
<p>解释“无符号右移”：在 Java 中，无符号右移运算符 &gt;&gt;&gt; 和右移运算符 &gt;&gt; 的区别如下：</p>
<p>右移运算符 &gt;&gt; 在右移时，丢弃右边指定位数，左边补上符号位；<br>
无符号右移运算符 &gt;&gt;&gt; 在右移时，丢弃右边指定位数，左边补上 00，也就是说，对于正数来说，二者一样，而负数通过 &gt;&gt;&gt; 后能变成正数。<br>
下面解释上面的模板中，取中位数的时候使用先用“＋”，然后“无符号右移”。</p>
<p>1、int mid = (left + right) / 2 与 int mid = left + (right - left) / 2 两种写法都有整型溢出的风险，没有哪一个是绝对安全的，注意：这里我们取平均值用的是除以 2，并且是整除：</p>
<p>int mid = (left + right) / 2 在 left 和 right 都很大的时候会溢出；<br>
int mid = left + (right - left) / 2 在 right 很大，且 left 是负数且很小的时候会溢出；<br>
2、写算法题的话，一般是让你在数组中做二分查找，因此 left 和 right 一般都表示数组的索引，因此 left 在绝大多数情况下不会是负数并且很小，因此使用 int mid = left + (right - left) // 2 相对 int mid = (left + right) // 2 更安全一些，并且也能向别人展示我们注意到了整型溢出这种情况，但事实上，还有更好的方式；</p>
<p>3、建议使用 int mid = (left + right) &gt;&gt;&gt; 1 这种写法，其实是大有含义的：</p>
<p>JDK8 中采用 int mid = (left + right) &gt;&gt;&gt; 1 ，重点不在 + ，而在 &gt;&gt;&gt; 。</p>
<p>我们看极端的情况，left 和 high 都是整型最大值的时候，注意，此时 3232 位整型最大值它的二进制表示的最高位是 00，它们相加以后，最高位是 11 ，变成负数，但是再经过无符号右移 &gt;&gt;&gt;（重点是忽略了符号位，空位都以 00 补齐），就能保证使用 + 在整型溢出了以后结果还是正确的。</p>
<p>Java 中 Collections 和 Arrays 提供的 binarySearch 方法，我们点进去看 left 和 right 都表示索引，使用无符号右移又不怕整型溢出，那就用 int mid = (left + right) &gt;&gt;&gt; 1 好啦。位运算本来就比使用除法快，这样看来使用 + 和 &lt;&lt;&lt; 真的是又快又好了。</p>
<p>我想这一点可能是 JDK8 的编写者们更层次的考量。</p>
<p>看来以后写算法题，就用 int mid = (left + right) &gt;&gt;&gt; 1 吧，反正更多的时候 left 和 right 表示索引。</p>
<p>（8）编码一旦出现死循环，输出必要的变量值、分支逻辑是调试的重要方法。<br>
当出现死循环的时候的调试方法：打印输出左右边界、中位数的值和目标值、分支逻辑等必要的信息。</p>
<p>按照我的经验，一开始编码的时候，稍不注意就很容易出现死循环，不过没有关系，你可以你的代码中写上一些输出语句，就容易理解“在区间元素只有 2 个的时候容易出现死循环”。具体编码调试的细节，可以参考我在「力扣」第 69 题：x 的平方根的题解《二分查找 + 牛顿法（Python 代码、Java 代码）》 。</p>
<p>6、总结<br>
总结一下，我爱用这个模板的原因、技巧、优点和注意事项：</p>
<p>（1）原因：<br>
无脑地写 while left &lt; right: ，这样你就不用判断，在退出循环的时候你应该返回 left 还是 right，因为返回 left 或者 right 都对；</p>
<p>（2）技巧：<br>
先写分支逻辑，并且先写排除中位数的逻辑分支（因为更多时候排除中位数的逻辑容易想，但是前面我也提到过，这并不绝对），另一个分支的逻辑你就不用想了，写出第 1 个分支的反面代码即可（下面的说明中有介绍），再根据分支的情况选择使用左中位数还是右中位数；</p>
<p>说明：这里再多说一句。如果从代码可读性角度来说，只要是你认为好想的逻辑分支，就把它写在前面，并且加上你的注释，这样方便别人理解，而另一个分支，你就不必考虑它的逻辑了。有的时候另一个分支的逻辑并不太好想，容易把自己绕进去。如果你练习做得多了，会形成条件反射。</p>
<p>我简单总结了一下，左右分支的规律就如下两点：</p>
<p>如果第 1 个分支的逻辑是“左边界排除中位数”（left = mid + 1），那么第 2 个分支的逻辑就一定是“右边界不排除中位数”（right = mid），反过来也成立；</p>
<p>如果第 2 个分支的逻辑是“右边界排除中位数”（right = mid - 1），那么第 2 个分支的逻辑就一定是“左边界不排除中位数”（left = mid），反之也成立。</p>
<p>“反过来也成立”的意思是：如果在你的逻辑中，“边界不能排除中位数”的逻辑好想，你就把它写在第 1 个分支，另一个分支是它的反面，你可以不用管逻辑是什么，按照上面的规律直接给出代码就可以了。能这么做的理论依据就是“排除法”。</p>
<p>在「力扣」第 287 题：寻找重复数的题解《二分法（Python 代码、Java 代码）》和这篇题解的评论区中，有我和用户<br>
@fighterhit 给出的代码，在一些情况下，我们先写了不排除中位数的逻辑分支，更合适的标准就是“哪个逻辑分支好想，就先写哪一个”，欢迎大家参与讨论。</p>
<p>（3）优点：<br>
分支条数只有 2 条，代码执行效率更高，不用在每一轮循环中单独判断中位数是否符合题目要求，写分支的逻辑的目的是尽量排除更多的候选元素，而判断中位数是否符合题目要求我们放在最后进行，这就是第 5 点；</p>
<p>说明：每一轮循环开始都单独判断中位数是否符合要求，这个操作不是很有普适性，因为从统计意义上说，中位数直接就是你想找的数的概率并不大，有的时候还要看看左边，还要看看右边。不妨就把它放在最后来看，把候选区间“夹逼”到只剩 1 个元素的时候，视情况单独再做判断即可。</p>
<p>（4）注意事项 1：<br>
左中位数还是右中位数选择的标准根据分支的逻辑而来，标准是每一次循环都应该让区间收缩，当候选区间只剩下 2 个元素的时候，为了避免死循环发生，选择正确的中位数类型。如果你实在很晕，不防就使用有 2 个元素的测试用例，就能明白其中的原因，另外在代码出现死循环的时候，建议你可以将左边界、右边界、你选择的中位数的值，还有分支逻辑都打印输出一下，出现死循环的原因就一目了然了；</p>
<p>（5）注意事项 2：<br>
如果能确定要找的数就在候选区间里，那么退出循环的时候，区间最后收缩成为 1 个数后，直接把这个数返回即可；如果你要找的数有可能不在候选区间里，区间最后收缩成为 1 个数后，还要单独判断一下这个数是否符合题意。</p>
<p>最后给出两个模板，大家看的时候看注释，不必也无需记忆它们。<br>
<img src="https://lixin-ee.github.io//post-images/1576028920322.png" alt=""><br>
<img src="https://lixin-ee.github.io//post-images/1576028931626.png" alt=""><br>
说明：我写的时候，一般是先默认将中位数写成左中位数，再根据分支的情况，看看是否有必要调整成右中位数，即是不是要在 (right - left) 这个括号里面加 11 。</p>
<p>虽说是两个模板，区别在于选中位数，中位数根据分支逻辑来选，原则是区间要收缩，且不出现死循环，退出循环的时候，视情况，有可能需要对最后剩下的数单独做判断。</p>
<p>我想我应该是成功地把你绕晕了，如果您觉得啰嗦的地方，就当我是“重要的事情说了三遍”吧，确实是重点的地方我才会重复说。当然，最好的理解这个模板的方法还是应用它。在此建议您不妨多做几道使用“二分查找法”解决的问题，用一下我说的这个模板，在发现问题的过程中，体会这个模板好用的地方，相信你一定会和我一样爱上这个模板的。</p>
<p>在「力扣」的探索版块中，给出了二分查找法的 3 个模板，我这篇文章着重介绍了第 2 个模板，但是我介绍的角度和这个版块中给出的角度并不一样，第 1 个模板被我“嫌弃”了，第 3 个模板我看过了，里面给出的例题也可以用第 2 个模板来完成，如果大家有什么使用心得，欢迎与我交流。</p>
<p>在这里补充一个小细节：除以 2 这件事情，还可以用右移 1 位来代替，位移运算的效率更高些。具体来说是这样：</p>
<p>1、Python 代码</p>
<p>mid = left + (right - left) // 2<br>
可以替换成：</p>
<p>mid = (left + right) &gt;&gt; 1<br>
2、Java 代码</p>
<p>int mid = l + (r - l) / 2;<br>
可以替换成：</p>
<p>int mid = (left + right) &gt;&gt;&gt; 1;<br>
注意：Java 中要使用 &gt;&gt;&gt; 表示无符号右移，有符号位移是不行的。</p>
<p>你没有看错，请注意，我现在又告诉你取 (left + right) 的一半，但不是除以 2 ，而是无符号右移一位，理由如下：</p>
<p>1、left 和 right 一般表示数组或列表的索引，它们都是正数；</p>
<p>2、即使 left 和 right 都很大，对于 Java 语言来说，(left + right) 可能发生整型溢出，但是无符号右移一位仍然能够得到正确的结果，而 Python 整型溢出了以后，类型自动升为 long 类型。</p>
<p>所以，在理解的基础上记住这个结论：取中位数用“+” 和“无符号右移”更优，事实上，Java 的 JDK 就是这么做的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二分查找 35. 搜索插入位置]]></title>
        <id>https://lixin-ee.github.io//post/er-fen-cha-zhao-35-sou-suo-cha-ru-wei-zhi</id>
        <link href="https://lixin-ee.github.io//post/er-fen-cha-zhao-35-sou-suo-cha-ru-wei-zhi">
        </link>
        <updated>2019-12-11T00:49:52.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br>
你可以假设数组中无重复元素。<br>
示例 1:<br>
输入: [1,3,5,6], 5<br>
输出: 2<br>
示例 2:<br>
输入: [1,3,5,6], 2<br>
输出: 1<br>
示例 3:<br>
输入: [1,3,5,6], 7<br>
输出: 4<br>
示例 4:<br>
输入: [1,3,5,6], 0<br>
输出: 0<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/search-insert-position<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>//本来以为挺简单的，但是边界条件略麻烦啊<br>
//这道题难点就在于会出现边界问题，这两个点我单独提取出来判断<br>
//然后就是插入点的问题，是从0开始算的下标，所以必须取右半边<br>
//注意即使取右半边也不会出现大于size()-1的情况，所以两个边界条件最好还是单独判断</p>
<pre><code>class Solution {
public:
    int searchInsert(vector&lt;int&gt;&amp; nums, int target) {
        int first=0,last=nums.size()-1,mid;
        if(target&gt;nums.back())
            return nums.size();
        if(target&lt;nums.front())
            return 0;
        while(first&lt;last){
            mid=first+(last-first)/2;
            if(target==nums[mid])
                return mid;
            if(target&gt;nums[mid])
                first=mid+1;
            else
                last=mid;
        }
        return first;
    }
};
</code></pre>
<p>先来看看网友题解<br>
一个是dalao给出的二分查找法模板，我会新开一篇文章转发<br>
二是针对这道题的解法，我写得代码其实通用性高了一点，因为题目保证没有重复的元素，所有可以在边界条件上更宽松一点，主要的难点也是头和尾两个点之一了</p>
<pre><code>解法1：循环搜索
class Solution {
public:
    int searchInsert(vector&lt;int&gt;&amp; nums, int target) {
        int len=nums.size();
        if(len==0) return 0;
        for(int i=0;i&lt;len;i++)
        {
            if(nums[i]&gt;=target) return i;
        }
        return len;
    }
};
解法2：二分查找
class Solution {
public:
    int searchInsert(vector&lt;int&gt;&amp; nums, int target) {
        int mid=0;
        int head=0;
        int last=nums.size()-1;
        while(head&lt;last)
        {
            mid=(last-head)/2+head;
            if(target&gt;nums[mid])
            {
                head=mid+1;
            }
            else if(target&lt;nums[mid])
            {
                last=mid-1;
            }
            else return mid;
        }
        if(target&lt;=nums[head])//插入位置在开头的情况
            return head;
        return head+1;//插入位置在结尾的情况
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[快速排序法实现[未完成]]]></title>
        <id>https://lixin-ee.github.io//post/kuai-su-pai-xu-fa-shi-xian</id>
        <link href="https://lixin-ee.github.io//post/kuai-su-pai-xu-fa-shi-xian">
        </link>
        <updated>2019-12-10T12:59:38.000Z</updated>
        <content type="html"><![CDATA[<p>9.9快速排序<br>
希尔排序相当于直接插入排序的升级，它们同属于插入排序类，堆排序相当于简单选择排序的升级，它们同属于选择排序类。而快速排序其实就是我们前面认为最慢的冒泡排序的升级，它们都属于交换排序类。它也是通过不断比较和移动交换来实现排序的，只不过它的实现，增大了记录的比较和移动的距离</p>
<p>9.9.1快速排序算法<br>
快速排序（QuickSort）的基本思想是：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序</p>
<p>9.9.2快速排序复杂度分析<br>
快速排序的时间性能取决于快速排序递归的深度<br>
在最优情况下，Partition每次都划分得很均匀，如果排序n个关键字，其递归树的深度就为floor(logn)+1<br>
在最优的情况下，快速排序算法的时间复杂度为O(nlogn)<br>
在最坏的情况下，待排序的序列为正序或者逆序，每次划分只得到一个比上一次划分少一个记录的子序列，注意另一个为空, 时间复杂度为O(nlogn)<br>
空间复杂度来说，主要是递归造成的栈空间的使用，最好情况，递归树的深度为logn，其空间复杂度也就为O(logn)，最坏情况需要进行n-1次递归调用，其空间复杂度为〇(n),<br>
平均情况，空间复杂度也为〇(logn)。<br>
由于关键字的比较和交换是跳跃进行的，因此，快速排序是一种不稳定的排序方法。</p>
<p>第一份实现是我在<a href="https://lixin-ee.github.io/post/shu-zu-287-xun-zhao-chong-fu-shu/">数组 287. 寻找重复数 </a>中实现的，主要是基于迭代器的版本<br>
为了提高算法的泛型能力我用了迭代器（bidiretional iterator，支持++和--）而不是数组下标。书里的方法对于middle的两分法是分为 [low,middle-1]、 [middle+1,high] 对于数组下标来说这是小菜一碟，但是对于迭代器来说就不一样了，比如{1，0}这种情况当middle去到了边缘处，如果middle是迭代器，middle+1是没问题的，毕竟还有尾后迭代器，但是middle-1就8行了，所以只能用[low,middle]、 [middle+1,high]算是为了通用性牺牲了一点计算量吧。<br>
然后注意不要把vi.end()传给high了，必须是vi.end()-1。</p>
<pre><code>void QuickSort(vector&lt;int&gt; &amp;vi, vector&lt;int&gt;::iterator low, vector&lt;int&gt;::iterator high) {
	vector&lt;int&gt;::iterator middle;
	if (low &lt; high) {
		middle = partition(vi,low,high);
		QuickSort(vi, low, middle);
		QuickSort(vi, ++middle, high);
	}
}

vector&lt;int&gt;::iterator partition(vector&lt;int&gt; &amp;vi, vector&lt;int&gt;::iterator low, vector&lt;int&gt;::iterator high) {
	int pivotkey;
	if (low &lt; high)
		pivotkey = *low;
	while (low &lt; high) {
	while (low &lt; high&amp;&amp;pivotkey &lt;= *high) 
			--high;
	iter_swap(low, high);
		while (low &lt; high&amp;&amp;*low &lt;= pivotkey) 
			++low;
		iter_swap(low, high);	
	}
	return low;
}
</code></pre>
<p>第二个版本是我在354题中实现的数组下标版本，这个就和大话数据结构中的没啥区别了，和迭代器主要的区别也是在于mid-1</p>
<pre><code>void quicksort(vector&lt;int&gt; &amp;vi,int beg,int end){
        if(beg&lt;end){
            int mid=partition(vi,beg,end);
            quicksort(vi,beg,mid-1);
            quicksort(vi,mid+1,end);
        }
    }
    
    int partition(vector&lt;int&gt; &amp;vi,int low,int high){
        int pivotkey=vi[low];
        while(low&lt;high){
            while(low&lt;high&amp;&amp;pivotkey&lt;=vi[high])
                --high;
            swap(vi[low],vi[high]);
            while(low&lt;high&amp;&amp;vi[low]&lt;pivotkey)
                ++low;
            swap(vi[low],vi[high])；
        }
        return low;
    }
};
</code></pre>
<p>需要注意的点：<br>
1.忘了定义pivotkey，定义后又忘了用来比较pivotkey&lt;=vi[high]<br>
2.先--high再到++low，不小心弄反了<br>
3.下标版可以直接mid-1，因为int等于-1没事，迭代器则不能指向begin之前<br>
4.记得return low;<br>
5.每个while都必须判断low&lt;high，特别是循环中的两个while</p>
<p>9.9.3快速排序优化<br>
1.优化选取枢轴<br>
三数取中（median-of-three)法。即取三个关键字先进行排序，将中间数作为枢轴，一般是取左端、右端和中间三个数，也可以随机选取。这样至少这个中间数一定不会是最小或者最大的数<br>
九数取中,它先从数组中分三次取样，每次取三个数，三个样品各取出中数，然后从这三个中数当中再取出一个中数作为枢轴。</p>
<p>2.优化不必要的交换<br>
观察图9-9-1至图9-9-6,我们发现，50这个关键字，其位置变化是1—9—3—6—S,可 其实它的最终目标就是S,当中的交换其实是不需要的。因此我们对Partition函数的代码再进行 优化。</p>
<p>3.优化小数组时的排序方案<br>
如果数组非常小，其实快速排序反而不如直接插入排序来得更好（直接插入是简单排序中性能最好的）。其原因在于快速排序用到了递归操作</p>
<p>4 优化递归操作<br>
QSort函数在其尾部有两次递归操作。如果 待排序的序列划分极端不平衡，递归深度将趋近于n,而不是平衡时的logn，<br>
栈的大小是很有限的，每次递归调用都会耗费—定的栈空间，函数的 参数越多，每次递归耗费的空间也越多。因此如果能减少递归，将会大大提高性能。<br>
相当于处理好了1/2再对剩下的1/2进行处理<br>
当我们将if改成while后（见加粗代码部分），因为第一次递归以后，变量low就没有用 处了，所以可以将pivot+1赋值给low，再循环后，来一次Partition(L,low,high),其效果等同于QSort(L，pivot+1,high);结果相同，但因采用迭代而不是递归的方法可以缩减堆栈深 度，从而提高了整体性能。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二分查找 278. 第一个错误的版本[简单]]]></title>
        <id>https://lixin-ee.github.io//post/er-fen-cha-zhao-278-di-yi-ge-cuo-wu-de-ban-ben-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/er-fen-cha-zhao-278-di-yi-ge-cuo-wu-de-ban-ben-jian-dan">
        </link>
        <updated>2019-12-10T02:14:22.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。<br>
假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。<br>
你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。<br>
示例:<br>
给定 n = 5，并且 version = 4 是第一个错误的版本。<br>
调用 isBadVersion(3) -&gt; false<br>
调用 isBadVersion(5) -&gt; true<br>
调用 isBadVersion(4) -&gt; true<br>
所以，4 是第一个错误的版本。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/first-bad-version<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>//这题应该是最简单的二分法了吧，然后可以试试插值查找之类的<br>
//最值得注意的还是mid的计算,注意这个是int不是double啊，会自动向0取整的<br>
//突然发现问题没那么简单啊，因为需要找到第一个出错的<br>
//重点还是在于判断后first和last的赋值是mid还是mid+1<br>
//最后才发现读错题目了，我的想法是true到false的转换找出第一个false，题目的意思是false到true的转换找出最后一个false，尴尬，幸好改一下flag就完成了<br>
//然后发现flag是多余的(what!去除flag之后空间复杂度还变高了！)</p>
<pre><code>// Forward declaration of isBadVersion API.
bool isBadVersion(int version);

class Solution {
public:
    int firstBadVersion(int n) {
      int first=1,last=n,mid;
        while(first&lt;last){
            mid=first+(last-first)/2;
            if(!isBadVersion(mid))
                first=mid+1;
            else
                last=mid;
        }
        return first;
    }

};
</code></pre>
<blockquote>
<p>来看一下官方题解<br>
这是一道较为简单的题目，但是有一个小陷阱。除此之外，这道题的算法是比较显然的。<br>
方法一：线性扫描 [超出时间限制]<br>
最直接的方法是进行一次线性扫描，即对 [1..n][1..n] 都调用一次isBadVersion。</p>
</blockquote>
<pre><code>Java
public int firstBadVersion(int n) {
    for (int i = 1; i &lt; n; i++) {
        if (isBadVersion(i)) {
            return i;
        }
    }
    return n;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)。在最坏的情况下，最多可能会调用 isBadVersion n-1n−1 次，因此总的时间复杂度为 O(n)。<br>
空间复杂度：O(1)。</p>
</blockquote>
<blockquote>
<p>方法二：二分查找 [通过]<br>
不难看出，这道题可以用经典的二分查找算法求解。我们通过一个例子，来说明二分查找如何在每次操作中减少一半的搜索空间，以此减少时间复杂度。<br>
场景一：isBadVersion(mid) =&gt; false<br>
1  2 3  4 5  6 7 8 9<br>
G G G G G G B B B       G = 正确版本，B = 错误版本<br>
|             |           |<br>
left       mid      right<br>
场景一中，isBadVersion(mid) 返回 false，因此我们知道 mid 左侧（包括自身）的所有版本都是正确的。所以我们令 left=mid+1，把下一次的搜索空间变为 [mid+1,right]。<br>
场景二：isBadVersion(mid) =&gt; true<br>
1 2  3 4  5 6 7 8 9<br>
G G G B B B B B B       G = 正确版本，B = 错误版本<br>
|            |           |<br>
left       mid     right<br>
场景二中，isBadVersion(mid) 返回 true，因此我们知道mid 右侧（不包括自身）的所有版本的不可能是第一个错误的版本。所以我们令 right=mid，把下一次的搜索空间变为 [left,mid]。<br>
在二分查找的每次操作中，我们都用left 和right 表示搜索空间的左右边界，因此在初始化时，需要将left 的值设置为 1，并将 right 的值设置为 n。当某一次操作后，left 和 right 的值相等，此时它们就表示了第一个错误版本的位置。可以用数学归纳法 证明 二分查找算法的正确性。<br>
在二分查找中，选取mid 的方法一般为mid=⌊(right+left)/2⌋。如果使用的编程语言会有整数溢出的情况（例如 C++，Java），那么可以用 mid=left+⌊<br>
(right−left)/2⌋代替前者。</p>
</blockquote>
<pre><code>Java
public int firstBadVersion(int n) {
    int left = 1;
    int right = n;
    while (left &lt; right) {
        int mid = left + (right - left) / 2;
        if (isBadVersion(mid)) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return left;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(logn)。搜索空间每次减少一半，因此时间复杂度为 O(logn)。<br>
空间复杂度：O(1)。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图 310. 最小高度树[中等][未做出][待阅读]]]></title>
        <id>https://lixin-ee.github.io//post/tu-310-zui-xiao-gao-du-shu-zhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/tu-310-zui-xiao-gao-du-shu-zhong-deng-wei-zuo-chu">
        </link>
        <updated>2019-12-08T23:56:58.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>对于一个具有树特征的无向图，我们可选择任何一个节点作为根。图因此可以成为树，在所有可能的树中，具有最小高度的树被称为最小高度树。给出这样的一个图，写出一个函数找到所有的最小高度树并返回他们的根节点。</p>
<p>格式<br>
该图包含 n 个节点，标记为 0 到 n - 1。给定数字 n 和一个无向边 edges 列表（每一个边都是一对标签）。<br>
你可以假设没有重复的边会出现在 edges 中。由于所有的边都是无向边， [0, 1]和 [1, 0] 是相同的，因此不会同时出现在 edges 里。</p>
<p>示例 1:<br>
输入: n = 4, edges = [[1, 0], [1, 2], [1, 3]]<br>
0<br>
|<br>
1<br>
/ <br>
2   3<br>
输出: [1]<br>
示例 2:</p>
<p>输入: n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]<br>
0  1  2<br>
\ | /<br>
3<br>
|<br>
4<br>
|<br>
5<br>
输出: [3, 4]</p>
<p>说明:<br>
 根据树的定义，树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。<br>
树的高度是指根节点和叶子节点之间最长向下路径上边的数量。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/minimum-height-trees<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>本来想着说建立一个图的邻接矩阵，然后通过判断矩阵每一行的最大值来得到结果<br>
但是比较麻烦的是如何去判断非邻接节点的距离<br>
发现完全可以化为最短路径的问题去完成 使用floyd构建邻接矩阵来完成<br>
结果floyd超时了？？？</p>
<p>然后来看一下网友题解吧</p>
<blockquote>
<p>广度优先搜索<br>
解题思路 :题目给定的是一个无向简单图，要求找出最高树的节点，首先通过分析可以知道，最后的根节点只可能为1个或者2个。<br>
要求最小高度的根节点，我们反过来想，怎样才能求得最小高度呢，很容易想到从叶子节点开始往根找，<br>
于是就是采用分层剥削的方法，每次去除一层叶子节点，这样保证最后的节点就是我们所要的。</p>
</blockquote>
<pre><code>class Solution {
public:
    vector&lt;int&gt; findMinHeightTrees(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) 
    {
        vector&lt;int&gt; ans;[[[]()]()]()
        vector&lt;int&gt; degree; //各个节点的度
        vector&lt; vector&lt;int&gt; &gt; Graph(n,vector&lt;int&gt;());  //重新定义图的结构
        queue&lt;int&gt; Q; //叶子节点队列
        
        //初始化度队列
        for(int i=0;i&lt;n;i++)
            degree.push_back(0); 
        
        //把边里面的数组转化为邻接表
        for(auto e : edges)
        {
            Graph[e[0]].push_back(e[1]);
            Graph[e[1]].push_back(e[0]);
            degree[e[0]]++;
            degree[e[1]]++;
        }
        
        //一度节点入队列
        for(int i=0;i&lt;n;i++)
            if(degree[i] == 1)
                Q.push(i);
        
        int rst = n;
        //一个节点时要单独拿出来考虑
        if(rst == 1)
            ans.push_back(0);
</code></pre>
<p>另外一个比较厉害的网友的题解，思路是一致的，就是越靠近中间的1~2个节点才是我们需要的节点，也可以转化为计算出入度（这里不是有向图，所以节点的度不需要区分出度入度）</p>
<blockquote>
<p>贪心法：根据拓扑排序的思路（Java 代码）<br>
思路分析：<br>
这道题一开始给我的感觉特别像拓扑排序，做下来，感觉它们的本质是一样的，更深层次的思想是贪心算法。<br>
直觉上，一棵树越靠“外面”的结点，我们越不可能把它作为根结点，如果这样做的话，可能树的高度是很高的<br>
因此，我们使用“剔除边缘结点”的策略，这里的边缘结点就是指连接其它结点最少的结点，用专业的名词来说，就是指向它的结点最少的结点，“入度”最少的结点<br>
我们能归纳出，结点最后只会剩下 1 个或者 2 个。<br>
综上所述，总结一下我们的算法：每次总是删除“入度”个数最少的结点，因为树是无向无环图，删除了它们以后，与之相连的结点的入度也相应地减少 1，直到最后剩下 1 个结点或者 2 个结点。<br>
在编码的时候，我借鉴了“拓扑排序”的代码，使用了“邻接表”表示图，使用了“入度数组”，还使用了队列保存了下一轮要“剔除”的结点编号。关于拓扑排序的知识和代码实现，可以参考「力扣」第 207 题：课程表 和「力扣」第 210 题：课程表 II。</p>
</blockquote>
<pre><code>public class Solution {
    public List&lt;Integer&gt; findMinHeightTrees(int n, int[][] edges) {
        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
        // 特判
        if (n &lt;= 2) {
            for (int i = 0; i &lt; n; i++) {
                res.add(i);
            }
            return res;
        }

        // 入度数组，每一次要把入度为 1 的结点剔除
        int[] inDegrees = new int[n];

        // 默认为 False，如果剔除，设置为 True
        boolean[] result = new boolean[n];

        // 因为是无向图，所以邻接表拿出一条边，两个结点都要存一下
        // 注意：右边就不要写具体的实现类了，等到实例化的时候再写具体的实现类
        Set&lt;Integer&gt;[] adjs = new Set[n];
        // 初始化
        for (int i = 0; i &lt; n; i++) {
            adjs[i] = new HashSet&lt;&gt;();
        }

        for (int[] edge : edges) {
            int start = edge[0];
            int end = edge[1];
            adjs[start].add(end);
            adjs[end].add(start);
            inDegrees[start] += 1;
            inDegrees[end] += 1;
        }
        LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;();

        // 入度为 1 的结点入队
        for (int i = 0; i &lt; n; i++) {
            if (inDegrees[i] == 1) {
                queue.addLast(i);
            }
        }

        // 注意边界条件 n == 2 和 n == 1 是如何分析出来的
        while (n &gt; 2) {
            int size = queue.size();
            System.out.println(queue);
            // 一次减去这么多
            n -= size;
            for (int i = 0; i &lt; size; i++) {
                int top = queue.removeFirst();
                result[top] = true;
                inDegrees[top] -= 1;
                // 把它和它的邻接结点的入度全部减 1
                Set&lt;Integer&gt; successors = adjs[top];
                for (Integer successor : successors) {
                    inDegrees[successor] -= 1;
                    if (inDegrees[successor] == 1) {
                        queue.addLast(successor);
                    }
                }
            }
        }
        n = result.length;
        for (int i = 0; i &lt; n; i++) {
            if (!result[i]) {
                res.add(i);
            }
        }
        return res;
    }
		
    public static void main(String[] args) {
        int[][] edges = new int[][]{{1, 0}, {1, 2}, {1, 3}};
        int n = 4;
        Solution solution = new Solution();
        List&lt;Integer&gt; res = solution.findMinHeightTrees(n, edges);
        System.out.println(res);
    }
}
</code></pre>
<p>看完题解发现其实我是知道BFS和DFS或者最小生成树的，只是没有想深一步去到刨除叶子节点这一步，最近做题经常是面向测试用例编程，很少去挖掘通用规律了，这一点还是有待改进的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图 399. 除法求值[中等][未做出][待阅读]]]></title>
        <id>https://lixin-ee.github.io//post/tu-399-chu-fa-qiu-zhi-zhong-deng-wei-zuo-chu-dai-yue-du</id>
        <link href="https://lixin-ee.github.io//post/tu-399-chu-fa-qiu-zhi-zhong-deng-wei-zuo-chu-dai-yue-du">
        </link>
        <updated>2019-12-08T02:16:18.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给出方程式 A / B = k, 其中 A 和 B 均为代表字符串的变量， k 是一个浮点型数字。根据已知方程式求解问题，并返回计算结果。如果结果不存在，则返回 -1.0。<br>
示例 :<br>
给定 a / b = 2.0, b / c = 3.0<br>
问题: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? <br>
返回 [6.0, 0.5, -1.0, 1.0, -1.0 ]<br>
输入为: vector&lt;pair&lt;string, string&gt;&gt; equations, vector&lt; double&gt;&amp; values,vector&lt;pair&lt;string, string&gt;&gt; queries(方程式，方程式结果，问题方程式)， 其中 equations.size() == values.size()，即方程式的长度与方程式结果长度相等（程式与结果一一对应），并且结果值均为正数。以上为方程式的描述。 返回vector&lt; double&gt;类型。<br>
基于上述例子，输入如下：<br>
equations(方程式) = [ [&quot;a&quot;, &quot;b&quot;], [&quot;b&quot;, &quot;c&quot;] ],<br>
values(方程式结果) = [2.0, 3.0],<br>
queries(问题方程式) = [ [&quot;a&quot;, &quot;c&quot;], [&quot;b&quot;, &quot;a&quot;], [&quot;a&quot;, &quot;e&quot;], [&quot;a&quot;, &quot;a&quot;], [&quot;x&quot;, &quot;x&quot;] ].<br>
输入总是有效的。你可以假设除法运算中不会出现除数为0的情况，且不存在任何矛盾的结果。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/evaluate-division<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>//在310用floyd翻车了就回来这边用了<br>
//本题目可以视为 建立图-搜索两点之间的最短路径 的问题<br>
//在大话数据结构的两种方法里面，最适合这道题的无疑是floyd<br>
//另一种算法：迪杰斯特拉（Dijkstra)算法：按路径长度递增的次序产生最短路径的算法，基于已经求出的最短路径的基础上一步步求出它们之间顶点的最短路径，适用于某个源点到其余各顶点的最 短路径问题<br>
//floyd就等于动态规划，一共有三层规划 k代表中转顶点的下标 v是起始顶点 w代表结束顶点，等于对于每两个点之间都以某个点来做中转，然后只取最短点（其实就是（Dijkstra)算法的循环版）<br>
//对于本题目来说，需要注意的点有：1.需要用map建立string和int下标的映射<br>
//2.对对称点使用倒数来初始化<br>
//3.循环计算时的判断式<code>if(graph[v][w]==-1.0&amp;&amp;graph[v][k]!=-1.0&amp;&amp;graph[k][w]!=-1.0)</code><br>
//4.最后利用map进行判断节点是否存在<code>if(trans.count(queries[i][0])&amp;&amp;trans.count(queries[i][1]))</code></p>
<pre><code>class Solution {
public:
    vector&lt;double&gt; calcEquation(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;double&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries) {
        map&lt;string,int&gt; trans;
        int n=0;
        for(int i=0;i&lt;equations.size();++i){
            if(!trans.count(equations[i][0]))
               trans.insert({equations[i][0],n++});
             if(!trans.count(equations[i][1]))
               trans.insert({equations[i][1],n++});
        }
        vector&lt;vector&lt;double&gt;&gt; graph(n,vector(n,-1.0));
        for(int i=0;i&lt;n;++i)
            graph[i][i]=1.0;
       for(int i=0;i&lt;equations.size();++i){
           int row=trans[equations[i][0]];
           int col=trans[equations[i][1]];
           graph[row][col]=values[i];
           graph[col][row]=1/values[i];               
       } 
     build(graph);  
     vector&lt;double&gt; res;
    for(int i=0;i&lt;queries.size();++i){
        if(trans.count(queries[i][0])&amp;&amp;trans.count(queries[i][1])){
            int row=trans[queries[i][0]];
            int col=trans[queries[i][1]];
            res.push_back(graph[row][col]);
        }
        else
            res.push_back(-1.0);
                 }
                return res;
    }
    
    void build(vector&lt;vector&lt;double&gt;&gt;&amp; graph){       
        int n=graph.size();
        for(int k=0;k&lt;n;++k)
            for(int v=0;v&lt;n;++v)
                for(int w=0;w&lt;n;++w)
                    if(graph[v][w]==-1.0&amp;&amp;graph[v][k]!=-1.0&amp;&amp;graph[k][w]!=-1.0)
                        graph[v][w]=graph[v][k]*graph[k][w],graph[w][v]=1/graph[v][w];
    }
};
</code></pre>
<p>然后惯例来看一下网友题解，有一位网友总结了三种解法，而且用的是C++，感动<br>
方法一：Floyd</p>
<pre><code>struct Value {
    int status;
    double val;
    Value(): status(0), val(0) {}
    Value(int s, double v) : status(s), val(v) {}
};

class Solution {
public:
    vector&lt;double&gt; calcEquation(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;double&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries) {      
        unordered_map&lt;string, int&gt; store;
        int n = 0;
        for (auto e : equations) {
            if (store.find(e[0]) == store.end())
                store[e[0]] = n++;
            if (store.find(e[1]) == store.end())
                store[e[1]] = n++;
        }

        vector&lt;vector&lt;Value&gt;&gt; graph(n, vector&lt;Value&gt;(n, Value()));
        for (int i = 0; i &lt; equations.size(); ++i) {
            int ia = store[equations[i][0]];
            int ib = store[equations[i][1]];
            graph[ia][ib] = Value(1, values[i]);
            graph[ib][ia] = Value(1, 1/values[i]);
        }
        
        for (int k = 0; k &lt; n; ++k) {
            for (int i = 0; i &lt; n; ++i) {
                for (int j = 0; j &lt; n; ++j) {
                    if (graph[i][j].status == 0 &amp;&amp; graph[i][k].status == 1 &amp;&amp; graph[k][j].status == 1) {
                        graph[i][j] = Value(1, graph[i][k].val * graph[k][j].val);
                    }
                }
            }
        }
        
        vector&lt;double&gt; res;
        for (auto q : queries) {
            if (store.find(q[0]) == store.end() || store.find(q[1]) == store.end()) {
                res.push_back(-1);
                continue;
            } 
            int ia = store[q[0]];
            int ib = store[q[1]];
            double r = graph[ia][ib].status == 1 ? graph[ia][ib].val : -1;
            res. push_back(r);
        }
        return res;
    }
};
</code></pre>
<p>方法二：dfs 和 bfs<br>
主要分为两步：<br>
1.build 构造初始化图<br>
2.dfs 或者 bfs 进行遍历</p>
<pre><code>class Solution {
public:
    vector&lt;double&gt; calcEquation(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;double&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries) {
        auto graph = build(equations, values);
           
        vector&lt;double&gt; res;  
        for (auto q : queries) {
            set&lt;string&gt; visited;
            bool found = false;
            //double r = bfs(graph, visited, q[0], q[1], found);
            double r = dfs(graph, visited, q[0], q[1], found);
            if (found) {
                res.push_back(r);
                graph[q[0]][q[1]] = r;
                graph[q[1]][q[0]] = 1 / r;
            } else {
                res.push_back(-1);
            }
        }
      
        return res;
    }

    unordered_map&lt;string, unordered_map&lt;string, double&gt;&gt; build(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;double&gt;&amp; values) {
        unordered_map&lt;string, unordered_map&lt;string, double&gt;&gt; m;
        for (int i = 0; i &lt; equations.size(); ++i) {
            vector&lt;string&gt; eqa = equations[i];
            string a = eqa[0];
            string b = eqa[1];
            double v = values[i];
            if (m.find(a) == m.end()) {
                m[a] = unordered_map&lt;string, double&gt;{{b, v}};
            } else {
                m[a][b] = v;
            }
            if (m.find(b) == m.end()) {
                m[b] = unordered_map&lt;string, double&gt;{{a, 1 /v}};
            } else {
                m[b][a] = 1 / v;
            }
        }
        return m;
    }

    double bfs(unordered_map&lt;string, unordered_map&lt;string, double&gt;&gt;&amp; g, set&lt;string&gt; visited, string begin, string end, bool&amp; found) {
        if (g.find(begin) == g.end() || g.find(end) == g.end()) {
            found = false;
            return -1;
        }
        queue&lt;pair&lt;string, double&gt;&gt; q;
        q.push(make_pair(begin, 1));
        while (!q.empty()) {
            auto cur = q.front();
            q.pop();
            if (visited.find(cur.first) != visited.end()) {
                continue;
            }
            if (cur.first == end) {
                found = true;
                return cur.second;
            }
            visited.insert(cur.first);
            for (auto it : g[cur.first]) {
                q.push(make_pair(it.first, cur.second * it.second));
            }
        }
        found = false;
        return -1;
    }
  
    double dfs(unordered_map&lt;string, unordered_map&lt;string, double&gt;&gt;&amp; g, set&lt;string&gt; visited, string begin, string end, bool&amp; found) {
        if (g.find(begin) == g.end() || g.find(end) == g.end()) {
            found = false;
            return -1;
        }
        if (visited.find(begin) != visited.end()) {
            found = false;
            return -1;
        }
        if (g[begin].find(end) != g[begin].end()) {
            found = true;
            return g[begin][end];
        }
        visited.insert(begin);
        for (auto it : g[begin]) {
            double r = dfs(g, visited, it.first, end, found);
            if (found) {
                double res = r * it.second;
                return res;
            }
        }
        visited.erase(begin);
        found = false;
        return -1;
    }
};
</code></pre>
<p>方法三：并查集</p>
<pre><code>struct Node {
    double value;
    Node* parent;
    Node() : parent(this) {}
    Node(double v) : value(v), parent(this) {}
};

class Solution {
    unordered_map&lt;string, Node*&gt; m;

    Node* find(Node* n) {
        if (n-&gt;parent != n) {
            n-&gt;parent = find(n-&gt;parent);
        }
        return n-&gt;parent;
    }
   
    void merge(Node* n1, Node* n2, double val) {
        Node* p1 = find(n1);
        Node* p2 = find(n2);
        double ratio = n2-&gt;value * val / n1-&gt;value;
        for (auto it : m) {
            if (find(it.second) == p1) {
                it.second-&gt;value *= ratio;
            }
        } 
        p1-&gt;parent = p2;
    }
public:
    vector&lt;double&gt; calcEquation(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;double&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries) {
        for (int i = 0; i &lt; equations.size(); ++i) {
            string a = equations[i][0];
            string b = equations[i][1];
            if (m.find(a) == m.end()) m[a] = new Node(values[i]);
            if (m.find(b) == m.end()) m[b] = new Node(1.0);
            merge(m[a], m[b], values[i]);
        }
        vector&lt;double&gt; res;
        for (auto q : queries) {
            if (m.find(q[0]) == m.end() || m.find(q[1]) == m.end() || find(m[q[0]]) != find(m[q[1]])) {
                res.push_back(-1);
            } else {
                res.push_back(m[q[0]]-&gt;value / m[q[1]]-&gt;value);
            }
        }
        return res;
    }
};
</code></pre>
<p>DFS和BFS 以及并查集值得好好阅读一下。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图 133. 克隆图[中等]]]></title>
        <id>https://lixin-ee.github.io//post/tu-133-ke-long-tu-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/tu-133-ke-long-tu-zhong-deng">
        </link>
        <updated>2019-12-07T00:47:09.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定无向连通图中一个节点的引用，返回该图的深拷贝（克隆）。图中的每个节点都包含它的值 val（Int） 和其邻居的列表（list[Node]）。<br>
示例：</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1575679961753.png" alt=""></p>
<blockquote>
<p>输入：<br>
{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: …&quot;neighbors&quot;:[{&quot;'>id&quot;:&quot;1&quot;,&quot;neighbors&quot;:[{&quot;</span>id&quot;:&quot;2&quot;,&quot;neighbors&quot;:[{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 9: ref&quot;:&quot;1&quot;}̲,{&quot;'>ref&quot;:&quot;1&quot;},{&quot;</span>id&quot;:&quot;3&quot;,&quot;neighbors&quot;:[{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 9: ref&quot;:&quot;2&quot;}̲,{&quot;'>ref&quot;:&quot;2&quot;},{&quot;</span>id&quot;:&quot;4&quot;,&quot;neighbors&quot;:[{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 9: ref&quot;:&quot;3&quot;}̲,{&quot;'>ref&quot;:&quot;3&quot;},{&quot;</span>ref&quot;:&quot;1&quot;}],&quot;val&quot;:4}],&quot;val&quot;:3}],&quot;val&quot;:2},{&quot;$ref&quot;:&quot;4&quot;}],&quot;val&quot;:1}<br>
解释：<br>
节点 1 的值是 1，它有两个邻居：节点 2 和 4 。<br>
节点 2 的值是 2，它有两个邻居：节点 1 和 3 。<br>
节点 3 的值是 3，它有两个邻居：节点 2 和 4 。<br>
节点 4 的值是 4，它有两个邻居：节点 1 和 3 。<br>
提示：<br>
节点数介于 1 到 100 之间。<br>
无向图是一个简单图，这意味着图中没有重复的边，也没有自环。<br>
由于图是无向的，如果节点 p 是节点 q 的邻居，那么节点 q 也必须是节点 p 的邻居。<br>
必须将给定节点的拷贝作为对克隆图的引用返回。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/clone-graph<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>//一开始就感觉这个其实是一个遍历题，主要是保证每个节点仅被遍历一次否则会new出重复的节点，看了大话数据结构的源代码后，发现缺少一个记录已访问节点的结构，就使用map代替了<br>
//map就保存一对结点，一个旧结点对应一个新节点<br>
//然后主要流程就是构造新节点-利用map判断是否已存在-存在则连接-不存在则递归调用<br>
//最后空间复杂度爆炸，但是时间复杂度还可以<br>
//时间复杂度O(n^2) 假设每个点都相连，则需要两层n循环</p>
<pre><code>/*
// Definition for a Node.
class Node {
public:
    int val;
    vector&lt;Node*&gt; neighbors;

    Node() {}

    Node(int _val, vector&lt;Node*&gt; _neighbors) {
        val = _val;
        neighbors = _neighbors;
    }
};
*/
class Solution {
public:
    map&lt;Node*,Node*&gt; mnn;
    Node* cloneGraph(Node* node) {
        Node *cur=new Node(node-&gt;val,vector&lt;Node*&gt;());
        mnn.insert({node,cur});
        for(auto i:node-&gt;neighbors){
            if(mnn.count(i))
                cur-&gt;neighbors.push_back(mnn[i]);
            else{       
               auto next=cloneGraph(i); 
                cur-&gt;neighbors.push_back(next);
            }
        }
        return cur;
    }
};
</code></pre>
<p>然后来看看网友题解：</p>
<blockquote>
<p>解题思路:<br>
这道题就是遍历整个图，所以遍历时候要记录已经访问点，我们用一个字典记录。<br>
所以，遍历方法就有两种。<br>
思路一:DFS (深度遍历)<br>
思路二:BFS (广度遍历)<br>
大家重点掌握，后面图遍历都和这个有关系！<br>
代码:<br>
思路一:</p>
</blockquote>
<pre><code>Java
class Solution {
    public Node cloneGraph(Node node) {
        Map&lt;Node, Node&gt; lookup = new HashMap&lt;&gt;();
        return dfs(node, lookup);
    }

    private Node dfs(Node node, Map&lt;Node,Node&gt; lookup) {
        if (node == null) return null;
        if (lookup.containsKey(node)) return lookup.get(node);
        Node clone = new Node(node.val, new ArrayList&lt;&gt;());
        lookup.put(node, clone);
        for (Node n : node.neighbors)clone.neighbors.add(dfs(n,lookup));
        return clone;
    }
}
</code></pre>
<blockquote>
<p>思路二:</p>
</blockquote>
<pre><code>Java
class Solution {
    public Node cloneGraph(Node node) {
        if (node == null) return null;
        Map&lt;Node, Node&gt; lookup = new HashMap&lt;&gt;();
        Node clone = new Node(node.val, new ArrayList&lt;&gt;());
        lookup.put(node, clone);
        Deque&lt;Node&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(node);
        while (!queue.isEmpty()) {
            Node tmp = queue.poll();
            for (Node n : tmp.neighbors) {
                if (!lookup.containsKey(n)) {
                    lookup.put(n, new Node(n.val, new ArrayList&lt;&gt;()));
                    queue.offer(n);
                }
                lookup.get(tmp).neighbors.add(lookup.get(n));
            }
        }
        return clone;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 96. 不同的二叉搜索树[中等]]]></title>
        <id>https://lixin-ee.github.io//post/shu-96-bu-tong-de-er-cha-sou-suo-shu-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/shu-96-bu-tong-de-er-cha-sou-suo-shu-zhong-deng">
        </link>
        <updated>2019-12-06T01:27:17.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？<br>
示例:<br>
输入: 3<br>
输出: 5<br>
解释:<br>
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:<br>
1         3     3      2      1<br>
\       /     /      / \      <br>
3     2     1      1   3      2<br>
/     /       \                 <br>
2     1         2                 3</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/unique-binary-search-trees<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<pre><code> class Solution {
public:
    
    int numTrees(int n) {
        vector&lt;int&gt; vi(n+1,0);
        vi[0]=1;
        for(int i=1;i&lt;=n;++i){
            int res=0;
            for(int j=1;j&lt;=i;++j){
               res+=vi[j-1]*vi[i-j]; 
            }
            vi[i]=res;
        }
        return vi[n];
    }
};
</code></pre>
<p>//一开始想单纯地找n和树的可能性之间的关系，结果发现不靠谱，因为单纯地在n-1的可能里加上1个值的话会有重复的情况<br>
//然后就想到以根为参考点的方法，就是 1，2，3中，分别考虑根节点为1，2，3的可能，此时就把问题化为两边子树的可能性了<br>
//最后看了题解发现这就是动态规划嘛，从n=1的情况开始推到n=n的情况<br>
//需要注意的是 当子树节点树为0的时候也是视为一种可能性。然后就是vi的长度是n+1，需要额外保存0的情况<br>
//然后就是不能把根结底算进去<br>
非常操蛋的是8ms只击败了12%，题解里面肯定是有很简单的数学方法<br>
//果然是，其实就是把第二个循环变成了通用公式</p>
<p>然后来看一下网友题解：</p>
<blockquote>
<p>思路<br>
标签：动态规划<br>
假设n个节点存在二叉排序树的个数是G(n)，令f(i)为以i为根的二叉搜索树的个数，则<br>
G(n) = f(1) + f(2) + f(3) + f(4) + ... + f(n)<br>
当i为根节点时，其左子树节点个数为i-1个，右子树节点为n-i，则<br>
f(i) = G(i-1)*G(n-i)<br>
综合两个公式可以得到 卡特兰数 公式<br>
G(n) = G(0)<em>G(n-1)+G(1)</em>(n-2)+...+G(n-1)*G(0)<br>
代码</p>
</blockquote>
<pre><code>Java
class Solution {
    public int numTrees(int n) {
        int[] dp = new int[n+1];
        dp[0] = 1;
        dp[1] = 1;
        
        for(int i = 2; i &lt; n + 1; i++)
            for(int j = 1; j &lt; i + 1; j++) 
                dp[i] += dp[j-1] * dp[i-j];
        
        return dp[n];
    }
}
</code></pre>
<p>官方题解：<br>
<img src="https://lixin-ee.github.io//post-images/1575596257408.png" alt=""><br>
复杂度分析<br>
时间复杂度 : O(N)，只有一层循环。<br>
空间复杂度 : O(1)，只需要一个变量来存储中间与最终结果。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 117. 填充每个节点的下一个右侧节点指针 II[中等] ]]></title>
        <id>https://lixin-ee.github.io//post/shu-117-tian-chong-mei-ge-jie-dian-de-xia-yi-ge-you-ce-jie-dian-zhi-zhen-iizhong-deng</id>
        <link href="https://lixin-ee.github.io//post/shu-117-tian-chong-mei-ge-jie-dian-de-xia-yi-ge-you-ce-jie-dian-zhi-zhen-iizhong-deng">
        </link>
        <updated>2019-12-05T01:41:49.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个二叉树<br>
struct Node {<br>
int val;<br>
Node *left;<br>
Node *right;<br>
Node *next;<br>
}<br>
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。<br>
初始状态下，所有 next 指针都被设置为 NULL。<br>
进阶：<br>
你只能使用常量级额外空间。<br>
使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1575510214544.png" alt=""></p>
<blockquote>
<p>输入：root = [1,2,3,4,5,null,7]<br>
输出：[1,#,2,3,#,4,5,7,#]<br>
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。<br>
提示：<br>
树中的节点数小于 6000<br>
-100 &lt;= node.val &lt;= 100<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>因为前一题我用了通用性较高的方法，所以这一题居然直接完成了hhh，然后优雅的用法是没法用了，但是我的方法事件复杂度比较高（603ms还击败50%什么鬼），还是老老实实看一下题解吧<br>
同样地我的解法的问题在于不是常量的空间复杂度</p>
<p>然后来看网友题解：</p>
<blockquote>
<p>队列是为了维护先后关系<br>
但是先后关系本来就存在了next里<br>
所以可以不使用队列<br>
队列做法</p>
</blockquote>
<pre><code>Node* connect(Node* root) {
        if(root == NULL)return root;
        queueq;
        q.push(root);
        while(!q.empty()){
            Node*cur = NULL;
            int size = q.size();
            for(int i = size;i&gt;=0;i--){
                Node *tmp = q.front();q.pop();
                if(cur != NULL){
                    cur-&gt;next = tmp;
                }
                cur = tmp;
                if(tmp-&gt;left)q.push(tmp-&gt;left);
                if(tmp-&gt;right)q.push(tmp-&gt;right);
            }
        }
        return root;
</code></pre>
<blockquote>
<p>使用next来代替队列</p>
</blockquote>
<pre><code>Node* connect(Node* root) {
        Node *last = root;
        while(last != NULL){
            // 获得队首元素
            while(last &amp;&amp; last-&gt;left == NULL &amp;&amp; last-&gt;right == NULL)last = last-&gt;next;
            if(last == NULL)break;
            Node *cur = NULL;
            // 遍历队列
            for(Node *i = last;i != NULL;i = i-&gt;next){
                // 进行push和pop操作
                if(i -&gt; left){
                    if(cur != NULL){
                        cur-&gt;next = i-&gt;left;
                    }
                    cur = i-&gt;left;
                }
                if(i -&gt; right){
                    if(cur != NULL){
                        cur-&gt;next = i-&gt;right;
                    }
                    cur = i-&gt;right;
                }
            }
            // 更新队首
            last = last-&gt;left ? last-&gt;left : last-&gt;right;
        }
        return root;
    }
</code></pre>
<p>比较详细的做法：</p>
<blockquote>
<p>解法一 BFS<br>
直接把 116 题 题的代码复制过来就好，一句也不用改。<br>
利用一个栈将下一层的节点保存。通过pre指针把栈里的元素一个一个接起来。</p>
</blockquote>
<pre><code>public Node connect(Node root) {
    if (root == null) {
        return root;
    }
    Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;();
    queue.offer(root);
    while (!queue.isEmpty()) {
        int size = queue.size();
        Node pre = null;
        for (int i = 0; i &lt; size; i++) {
            Node cur = queue.poll();
            if (i &gt; 0) {
                pre.next = cur;
            }
            pre = cur;
            if (cur.left != null) {
                queue.offer(cur.left);
            }
            if (cur.right != null) {
                queue.offer(cur.right);
            }

        }
    }
    return root;
}
</code></pre>
<blockquote>
<p>解法二<br>
当然题目要求了空间复杂度，可以先到 116 题 看一下思路，这里在上边的基础上改一下。<br>
我们用第二种简洁的代码，相对会好改一些。</p>
</blockquote>
<pre><code>Node connect(Node root) {
    if (root == null)
        return root;
    Node pre = root;
    Node cur = null;
    while (pre.left != null) {
        cur = pre;
        while (cur != null) {
            cur.left.next = cur.right;
            if (cur.next != null) {
                cur.right.next = cur.next.left;
            }
            cur = cur.next;
        }
        pre = pre.left;
    }

    return root;
}
</code></pre>
<blockquote>
<p>需要解决的问题还是挺多的。<br>
cur.left.next = cur.right;<br>
cur.right.next = cur.next.left;<br>
之前的关键代码就是上边两句，但是在这道题中我们无法保证cur.left 或者 cur.right 或者 cur.next.left或者cur.next.right 是否为null。所以我们需要用一个while循环来保证当前节点至少有一个孩子。<br>
while (cur.left == null &amp;&amp; cur.right == null) {<br>
cur = cur.next;<br>
}<br>
这样的话保证了当前节点至少有一个孩子，然后如果一个孩子为 null，那么就可以保证另一个一定不为 null 了。<br>
整体的话，就用了上边介绍的技巧，代码比较长，可以结合的看一下。</p>
</blockquote>
<pre><code>Node connect(Node root) {
    if (root == null)
        return root;
    Node pre = root;
    Node cur = null;
    while (true) {
        cur = pre;
        while (cur != null) {
            //找到至少有一个孩子的节点
            if (cur.left == null &amp;&amp; cur.right == null) {
                cur = cur.next;
                continue;
            }
            //找到当前节点的下一个至少有一个孩子的节点
            Node next = cur.next;
            while (next != null &amp;&amp; next.left == null &amp;&amp; next.right == null) {
                next = next.next;
                if (next == null) {
                    break;
                }
            }
            //当前节点的左右孩子都不为空，就将 left.next 指向 right
            if (cur.left != null &amp;&amp; cur.right != null) {
                cur.left.next = cur.right;
            }
            //要接上 next 的节点的孩子，所以用 temp 处理当前节点 right 为 null 的情况
            Node temp = cur.right == null ? cur.left : cur.right;

            if (next != null) {
                //next 左孩子不为 null，就接上左孩子。
                if (next.left != null) {
                    temp.next = next.left;
                //next 左孩子为 null，就接上右孩子。
                } else {
                    temp.next = next.right;
                }
            }
            
            cur = cur.next;
        }
        //找到拥有孩子的节点
        while (pre.left == null &amp;&amp; pre.right == null) {
            pre = pre.next;
            //都没有孩子说明已经是最后一层了
            if (pre == null) {
                return root;
            }
        }
        //进入下一层
        pre = pre.left != null ? pre.left : pre.right;
    } 
}
</code></pre>
<p>解法三</p>
<blockquote>
<p>利用解法一的思想，我们利用 pre 指针，然后一个一个取节点，把它连起来。解法一为什么没有像解法二那样考虑当前节点为 null 呢？因为我们没有添加为 null 的节点，就是下边的代码的作用。<br>
if (cur.left != null) {<br>
queue.offer(cur.left);<br>
}<br>
if (cur.right != null) {<br>
queue.offer(cur.right);<br>
}<br>
所以这里是一样的，如果当前节点为null不处理就可以了。</p>
</blockquote>
<blockquote>
<p>第二个问题，怎么得到每次的开头的节点呢？我们用一个dummy指针，当连接第一个节点的时候，就将dummy指针指向他。此外，之前用的pre指针，把它当成tail指针可能会更好理解。如下图所示：</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1575511034936.png" alt=""></p>
<blockquote>
<p>cur 指针利用 next 不停的遍历当前层。<br>
如果 cur 的孩子不为 null 就将它接到 tail 后边，然后更新tail。<br>
当 cur 为 null 的时候，再利用 dummy 指针得到新的一层的开始节点。<br>
dummy 指针在链表中经常用到，他只是为了处理头结点的情况，它并不属于当前链表。<br>
代码就异常的简单了。</p>
</blockquote>
<pre><code>Node connect(Node root) {
    Node cur = root;
    while (cur != null) {
        Node dummy = new Node();
        Node tail = dummy;
        //遍历 cur 的当前层
        while (cur != null) {
            if (cur.left != null) {
                tail.next = cur.left;
                tail = tail.next;
            }
            if (cur.right != null) {
                tail.next = cur.right;
                tail = tail.next;
            }
            cur = cur.next;
        }
        //更新 cur 到下一层
        cur = dummy.next;
    }
    return root;
}
</code></pre>
<blockquote>
<p>总<br>
本来为了图方便，在 116 题 的基础上把解法二改了出来，还搞了蛮久，因为为 null 的情况太多了，不停的报空指针异常，最后终于理清了思路。但和解法三比起来实在是相形见绌了，解法三太优雅了，但其实这才是正常的思路，从解法一的做法产生灵感，利用 tail 指针将它们连起来。</p>
</blockquote>
]]></content>
    </entry>
</feed>