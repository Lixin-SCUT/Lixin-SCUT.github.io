<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-09-12T11:44:18.129Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[数组 55. 跳跃游戏]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-55-tiao-yue-you-xi</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-55-tiao-yue-you-xi">
        </link>
        <updated>2019-09-12T11:43:10.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>官方题目：<br>
给定一个非负整数数组，你最初位于数组的第一个位置。<br>
数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>
判断你是否能够到达最后一个位置。</p>
<p>示例 1:<br>
输入: [2,3,1,1,4]<br>
输出: true<br>
解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。<br>
示例 2:<br>
输入: [3,2,1,0,4]<br>
输出: false<br>
解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/jump-game<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<pre><code>class Solution {
public:
    bool canJump(vector&lt;int&gt;&amp; nums) {
       int len=nums.size();
        if(len==0||len==1)
            return true;
        int reach=0;
        for(int i=0;i&lt;len-1;++i){
            int temp=reach;
            reach=i+nums[i];
            if(temp&gt;reach)
                swap(temp,reach);
            if(reach==i)
                return false;
        }
        if(reach&gt;=len-1)
         return true;
        else
        return false;    
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第六章 笔记+习题 6.1-6.2]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-liu-zhang-bi-ji-xi-ti-61-63</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-liu-zhang-bi-ji-xi-ti-61-63">
        </link>
        <updated>2019-09-12T01:09:34.000Z</updated>
        <content type="html"><![CDATA[<p>6.1函数基础<br>
一个函数定义包括：返回类型，函数名字，由0个或多个形参组成的列表以及函数体<br>
通过调用运算符来<strong>执行函数，调用运算符的形式是一对圆括号</strong>，作用于一个表达式，表达式是函数或者指向函数的指针，圆括号内为实参，实参初始化形参，调用表达式的类型就是函数的类型<br>
函数第一步是隐式地定义并初始化形参<br>
实参的类型和数量都必须与形参匹配，所以形参一定会被初始化<br>
空形参可以是隐式或者<strong>显式（void）</strong><br>
每个形参的类型都必须单独声明，不可以因为类型相同而忽略<br>
形参可以<strong>空名</strong>，但不可以同名，<strong>通常以空名代表不被使用，但也必须用实参初始化</strong><br>
函数的返回类型不可以是<strong>数组或者函数</strong>，但可以是指向数组的<strong>指针或引用</strong></p>
<p>习题6.1<br>
实参是形参的初始值，实参用于初始化对应位置的形参<br>
习题6.2<br>
（a）返回类型为int<br>
（b）没有定义返回类型<br>
（c）形参名字不可以相同<br>
（d）函数体不管语句数量多少，必须使用花括号<br>
习题6.3+6.4</p>
<pre><code>int factorial(int fact);
int main() {
	int i;
	while (cin) {
		cout &lt;&lt; &quot;please input one number:&quot;;
		cin &gt;&gt; i;
		cout &lt;&lt; factorial(i) &lt;&lt; endl;
	}
};

int factorial(int fact) {
	int sum=1;
	while (fact)
		sum *= fact--;
	return sum;
}
</code></pre>
<p>知识点：不要忽略了函数的声明！<br>
习题6.5</p>
<pre><code>int num_abs(int num);

int main() {
	int i;
	while (cin) {
		cout &lt;&lt; &quot;please input one number:&quot;;
		cin &gt;&gt; i;
		cout &lt;&lt; num_abs(i) &lt;&lt; endl;
	}
};

int num_abs(int num) {
	return num&gt;0?num:-num;
}
</code></pre>
<p>6.1.1局部对象<br>
名字有作用域，对象有生命周期<br>
形参和函数体内部定义的变量统称为局部变量<br>
自动对象 只存在于块执行期间的对象 块执行结束后，自动对象的值变为未定义<br>
形参是一种自动对象，内置类型的未初始化局部变量将产生未定义的值<br>
局部静态对象 static 直到程序终止时才被销毁，在此期间就算函数执行结束也不会对她产生影响（可以用来计算函数调用次数）<br>
内置类型的局部静态变量默认初始化为0，而不是未定义</p>
<p>习题6.6<br>
形参和局部静态变量都属于局部变量，只存在于块执行期间，但是局部静态变量的存在周期为整个程序执行期间，形参在块执行后的值变为未定义。代码见2.7<br>
习题6.7</p>
<pre><code>int formal_param(int f);

int main() {
	int i = 10;
	while(i)
		formal_param(i),--i;
};

int formal_param(int f) {
	int i=0;
	static int s_i=0;
	cout &lt;&lt; f&lt;&lt;' '&lt;&lt;++i &lt;&lt; ' ' &lt;&lt; ++s_i&lt;&lt;endl;
	return 0;
}
</code></pre>
<p>6.1.2<br>
函数只能定义一次，但可以声明多次。函数声明无须函数体，可以忽略形参的名字，用一个分号代替 例如 int add(int ,int);<br>
函数声明也称作函数原型<br>
建议函数和变量在<strong>头文件中声明，在源文件中定义,</strong><br>
含有函数声明的头文件应该被包含到定义函数的源文件中，<br>
<strong>通过以上的配合，其实就是将所有用到该函数的cpp文件中的声明移动到头文件中，编译器会自动在包含了头文件的cpp文件中搜索函数定义，从而以后可以很方便地修改函数的声明（比如修改形参数量），不需要一个一个地在使用了该函数的cpp文件中修改。</strong></p>
<p>习题6.8<br>
chapter6.h</p>
<pre><code>#pragma once
#ifndef CHAPTER6_H
#define CHAPTER6_H
int factorial(int fact);
#endif // !CHAPTER6_H
</code></pre>
<p>homework6.8.cpp</p>
<pre><code>#include &quot;chapter6.h&quot;

int factorial(int fact) {
	int sum = 1;
	while (fact)
		sum *= fact--;
	return sum;
}
</code></pre>
<p>6.1.3<br>
分离式编译允许我们把程序分割到几个文件中去，每个文件相互独立<br>
如果我们修改了某个源文件，只需要单独编译改动了的文件生成对象代码文件<br>
分离式编译会产生对象代码文件<br>
最后再把对象文件链接到一起形成可执行文件</p>
<p>习题6.9<br>
其实6.8中已经完成了这个任务，homework6.8对应于fact.cc 。</p>
<p>6.2参数传递<br>
如果形参是引用类型，实参被引用传递（传引用调用）。当形参非引用类型，实参的值拷贝给形参，实参被值传递（传值调用）<br>
6.2.1<br>
拷贝传递不会影响实参的值，但指针形参可以修改所指向的对象的值<br>
在c++语言中建议使用引用类型的形参</p>
<p>习题6.10</p>
<pre><code>int swap_p(int *p1, int *p2);

int main() {
	int i1 = 0, i2 = 1;
	cout &lt;&lt; i1 &lt;&lt; ' ' &lt;&lt; i2 &lt;&lt; endl;
	int *i1p = &amp;i1, *i2p = &amp;i2;
	swap_p(i1p, i2p);
	cout &lt;&lt; i1 &lt;&lt; ' ' &lt;&lt; i2 &lt;&lt; endl;
	return 0;
};

int swap_p(int *p1,int *p2) {
	 *p1 = *p1 + *p2;
	 *p2 = *p1 - *p2;
	 *p1 = *p1 - *p2;
	 return 1;
}
</code></pre>
<p>6.2.2<br>
<strong>使用引用可以避免对大的类或者容器对象进行拷贝</strong><br>
如果无需改变形参的值，<strong>最好将其声明为常量引用</strong><br>
可以使用引用类型的形参返回额外信息</p>
<p>习题6.11</p>
<pre><code>int main() {
	int i = 1;
	cout &lt;&lt; i &lt;&lt; endl;
	reset(i);
	cout &lt;&lt; i &lt;&lt; endl;
	return 0;
};

void reset(int &amp;p) {
	p = 0;
}
</code></pre>
<p>习题6.12</p>
<pre><code>int main() {
	int i1 = 0, i2 = 1;
	cout &lt;&lt; i1 &lt;&lt; ' ' &lt;&lt; i2 &lt;&lt; endl;
	int &amp;i1p = i1, &amp;i2p = i2;
	swap_p(i1p, i2p);
	cout &lt;&lt; i1 &lt;&lt; ' ' &lt;&lt; i2 &lt;&lt; endl;
	return 0;
};

int swap_p(int &amp;p1, int &amp;p2) {
	p1 = p1 + p2;
	p2 = p1 - p2;
	p1 = p1 - p2;
	return 1;
}
</code></pre>
<p>非常明显 引用更加好用。免去了*字符和&amp;字符的繁杂<br>
习题6.13<br>
一个是传值调用，一个是传引用调用，前者只是拷贝副本，后者可以通过引用更改原值<br>
习题6.14<br>
比如对两个矩阵进行比较，矩阵值特别大时再进行传值会导致内存不足，同时iostream等输入输出流是不可以拷贝的。如果不想修改原变量的值，就不应该使用引用。<br>
习题6.15<br>
我们不希望s被拷贝，也不希望s被修改，所以使用const &amp;，occur会被修改，所以用普通引用，我们不希望函数通过c的值来修改原值，所以不使用引用。否则s会被修改，occur无法递增</p>
<p>6.2.3<br>
指向常量的指针也可以指向非常量，只是不能解引用赋值，<strong>也不能赋值给普通指针</strong>。常量指针不能改变指针的值，<strong>但是可以解引用赋值</strong><br>
当实参初始化形参时会忽略顶层const，所以当形参有顶层const时，传给它常量对象或者非常量对象都可以（但实参的顶层const不会被忽略）<br>
在函数定义或者声明的过程中，因为顶层const被忽略了，所以形参中的const int和  int没有区别，编译器会认为重复了（<strong>但是在函数体中仍然不能改变const形参的值</strong>）<br>
非常量引用形参的<strong>两个问题</strong>：<br>
1.形参为<strong>int引用</strong>时，只能传入int类型的对象，不能用字面值、求值结果为int的表达式、需要转换的对象或者<strong>const int类型</strong>的对象，但** 常量引用可以使用字面值**，所以建议使用常量引用<br>
2.在函数内部使用形参作为另外一个函数的形参时，需要注意引用类型是否一致，例如：</p>
<pre><code>void fun1(const int &amp;param){
	fun2(param);//void fun2(int &amp; param)时错误，**int&amp;只接受普通引用 **
}
</code></pre>
<p>所以尽可能使用常量引用</p>
<p>习题6.18<br>
（a）<code>bool compare(matrix &amp;m1,matrix&amp;m2);</code><br>
（b）<code>vector&lt;int&gt;::iterator change_val(int i,vector&lt;int&gt;::iterator i_v);</code><br>
习题6.19<br>
（a）不合法，形参数目不对<br>
（b）合法<br>
（c）合法，有隐式转换<br>
（d）合法，有隐式转换<br>
习题6.20<br>
常量引用：不希望拷贝传值和被改动。普通引用的话原值可能会被改动。</p>
<p>6.2.4<br>
数组两个特殊性质，1.<strong>不允许拷贝数组</strong>2.使用数组名时通常会将其转换成指针<br>
所以函数传递数组时实际上传递的是指向数组首元素的指针<br>
1.Int* a   2.int a[]     3.int a[10]   这三个形参实际上是一样的，都等同于第一个<br>
管理指针形参<br>
1.使用结束标记间接指定数组长度，比如c风格字符串结尾的空字符 例如while(<em>cp)指向结尾空字符就会结束<br>
2.使用标准库规范 传递指向数组首尾元素的指针 int a[10];begin(a),end(a);<br>
3.显式传递一个表示数组大小的形参 end(a)-begin(a);<em><em>sizeof(a)/sizeof(<em>a)</em></em><br>
数组引用形参定义过程中，</em><em>&amp;arr两端的括号不可以少</em></em>，但数组引用形参一开始就需要确定数组大小 (&amp;arr)[10]；数组的引用 &amp;arr[10]；错误，没有数组的引用</p>
<p>习题6.21</p>
<pre><code>int compare(int p1, int *p2);

int main() {
	int i1,i2;
	cout &lt;&lt; &quot;please input two number:&quot;;
	cin &gt;&gt; i1 &gt;&gt; i2;
	cout &lt;&lt; &quot;the larger one is &quot;;
	int *i1p = &amp;i1, *i2p = &amp;i2;
	cout &lt;&lt; compare(i1, i2p) &lt;&lt; endl;
	return 0;
};

int compare(int p1, int *p2) {
	return p1&gt;*p2?p1:*p2;
}
</code></pre>
<p>习题6.22</p>
<pre><code>int main() {
	int i1,i2;
	cout &lt;&lt; &quot;please input two number:&quot;;
	cin &gt;&gt; i1 &gt;&gt; i2;
	int *i1p = &amp;i1, *i2p = &amp;i2;
	cout &lt;&lt; *i1p &lt;&lt; ' ' &lt;&lt; *i2p &lt;&lt; endl;
	swap_p(i1p, i2p);
	cout &lt;&lt; *i1p &lt;&lt; ' ' &lt;&lt; *i2p &lt;&lt; endl;
	return 0;
};

void swap_p(int *&amp;p1, int *&amp;p2) {
	int *temp = p1;
	p1 = p2;
	p2 = temp;
}
</code></pre>
<p>习题6.23</p>
<pre><code>int main() {
	int j[2] = { 0,1 };
	int i = 0;
	auto j_b = begin(j);
	auto j_e = end(j);
	print(i);
	print(j_b, j_e);
	return 0;
};

void print(const int&amp; i) {
	cout &lt;&lt; i &lt;&lt; endl;
}
void print(int *beg,int *end) {
	while (beg != end)
		cout &lt;&lt; *beg++ &lt;&lt; endl;

}
</code></pre>
<p>习题6.24<br>
程序希望逐个输出数组ia的元素，但是形参没有使用引用或指针，数组是无法直接拷贝给形参的！！！所以传递的仅仅是头指针</p>
<p>6.2.5<br>
int main(int argc,char *argv[]){….}<br>
main处理命令行选项，argc表示变量的数量，argv[0]保存程序的名字，可选实参从argv[1]开始</p>
<p>习题6.25&amp;.26</p>
<pre><code>int main(int argc,char* argv[]) {
	string s;
	for (int i = 1; i &lt; argc; ++i)
		s = s + argv[i];
	cout &lt;&lt; s &lt;&lt; endl;
};
</code></pre>
<p>知识点：string的向量可以用 string+=char，特别是string为空的时候，不能直接string=char+char，第一个必须是string。</p>
<p>6.2.6<br>
<strong>函数的实参数量未知但类型相同</strong>，可以使用initializer_list类型的形参，这是一种标准库类型，用于表示某种特定类型的值的数组，<strong>和vector一样也是一种模版类型，但其对象中的元素永远是常量值，无法改变元素的值</strong>（元素值是const）<br>
向initializer_list形参传递一个值的序列的时候，必须把序列放在<strong>一对花括号内</strong></p>
<p>习题6.27</p>
<pre><code>int add_list(initializer_list&lt;int&gt; i);

int main(int argc,char* argv[]) {
	initializer_list&lt;int&gt; i{ 1,2,3,4,5,6,7 };
	cout &lt;&lt; add_list(i) &lt;&lt; endl;
};

int add_list(initializer_list&lt;int&gt; i) {
	int sum = 0;
	for (auto num : i)
		sum += num;
	return sum;
}
</code></pre>
<p>习题6.28<br>
elem的类型为const string&amp;<br>
习题6.29<br>
应该，因为initailizer_list的对象都是const值，使用引用可以避免拷贝和修改，但是要注意配合auto使用（实测加了auto &amp;，会自动加上const）</p>
<p>习题感悟：<br>
不要忽略了函数的声明！<br>
数组是无法直接拷贝给形参的！！！<br>
string的向量可以用 string+=char，特别是string为空的时候，不能直接string=char+char，第一个必须是string。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组217. 存在重复元素]]></title>
        <id>https://lixin-ee.github.io//post/217-cun-zai-chong-fu-yuan-su</id>
        <link href="https://lixin-ee.github.io//post/217-cun-zai-chong-fu-yuan-su">
        </link>
        <updated>2019-09-11T15:30:24.000Z</updated>
        <content type="html"><![CDATA[<p>题目：</p>
<blockquote>
<p>给定一个整数数组，判断是否存在重复元素。<br>
如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</p>
<p>示例 1:<br>
输入: [1,2,3,1]<br>
输出: true<br>
示例 2:<br>
输入: [1,2,3,4]<br>
输出: false<br>
示例 3:<br>
输入: [1,1,1,3,3,4,3,2,4,2]<br>
输出: true<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/contains-duplicate<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>今天看了一天STL的hashtable，看得有点愣愣的，不过确实是牛逼，没想到这道题就用上了hhhh，非常适合用哈希map，把每个值作为key，再把出现次数作为mapped_value进行递增，第一次给出的代码如下：</p>
<pre><code>class Solution {
public:
    bool containsDuplicate(vector&lt;int&gt;&amp; nums) {
        int len = nums.size();
        if(len==0||len==1)
            return false;
        map&lt;int,int&gt; nums_map;
        for(auto i:nums)
            if(nums_map.find(i)==nums_map.end())
                nums_map.insert({i,1});
            else
                ++nums_map[i];
        for(auto i=nums_map.begin();i!=nums_map.end();++i)
            if(i-&gt;second&gt;1)
                return true;
        return false;
        
    }
};
</code></pre>
<p>依赖于STL的强大，毫无疑问地一次过啦hhh，但是花的时间比较长，所以打算看一下官方题解中hashmap的解答：</p>
<blockquote>
<p>方法三：哈希表 【通过】<br>
直觉<br>
利用支持快速搜索和插入操作的动态数据结构。<br>
算法<br>
从方法一中我们知道，对无序数组的查找操作的时间复杂度为 O(n)，而我们会重复调用查找操作。因此，使用搜索时间更快的数据结构将加快整个算法的速度。<br>
有许多数据结构常用作动态集合,如二进制搜索树和哈希表。这里我们需要的操作是 search 和 insert。对于平衡二叉搜索树（Java 中的 TreeSet 或 TreeMap），search 和 insert 的时间复杂度均为 O(logn)。对于哈希表（Java 中的 HashSet 或 HashMap），search 和 insert 的平均时间复杂度为 O(1)。因此，通过使用哈希表，我们可以达到在线性时间复杂度解决问题。</p>
</blockquote>
<pre><code>Java
public boolean containsDuplicate(int[] nums) {
    Set&lt;Integer&gt; set = new HashSet&lt;&gt;(nums.length);
    for (int x: nums) {
        if (set.contains(x)) return true;
        set.add(x);
    }
    return false;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 : O(n)。<br>
search() 和 insert() 各自使用 nn 次，每个操作耗费常数时间。<br>
空间复杂度 : O(n)。哈希表占用的空间与元素数量是线性关系。<br>
注意<br>
对于一些特定的 n 不太大的测试样例，本方法的运行速度可能会比方法二更慢。这是因为哈希表在维护其属性时有一些开销。要注意，程序的实际运行表现和 Big-O 符号表示可能有所不同。Big-O 只是告诉我们在 充分 大的输入下，算法的相对快慢。因此，在 nn 不够大的情况下， O(n) 的算法也可以比 O(nlogn)的更慢。</p>
</blockquote>
<p>看官方题解还是开卷有益的，我的源代码问题在于需要遍历两次，但是经过官方题解的指点获得了很好的灵感，c++的hashmap会返回一对pair，前者是迭代器，后者则是bool值，正好用于返回，所以在插入阶段只要出现插入失败（重复）就可以直接返回pair的second值作为结果了，非常简单暴力，结果也是一次通过，节省了很多时间。下面为修改后的最后代码：</p>
<pre><code>class Solution {
public:
    bool containsDuplicate(vector&lt;int&gt;&amp; nums) {
        int len = nums.size();
        if(len==0||len==1)
            return false;
        map&lt;int,int&gt; nums_map;
        for(auto i:nums)
            if(!nums_map.insert({i,1}).second)
                return true;
        return false;
        
    }
};
</code></pre>
<p>然后来看看剩下的两个官方题解吧，毕竟hashmap属于STL的拿来即用，属于前人栽树后人乘凉，面试的时候直接写个hashmap不知道会不会被打死，同时在前面我也说到过其实不太喜欢用hashmap，毕竟做算法就是要理解背后的原理，一个好算法应该是通用性高的泛型算法。</p>
<blockquote>
<p>方法一：朴素线性查找 【超时】<br>
直觉<br>
对于一个有 nn 个整数的数组，一共有n(n+1)/2 对整数。因此，我们可以对所有的<br>
对进行检测，看它们是否相同。<br>
算法<br>
为了实现这个思路，我们使用线性查找算法，这是最简单的查找算法。线性查找是一种检查特定值是否在列表中的算法，做法是依次逐个检查列表中的元素，直到找到满足的元素。<br>
对于本问题，我们循环遍历全部 n 个数。对于第 i 个整数 nums[i]，我们对前 i-1 个整数查找 nums[i] 的重复值。若找到，则返回 True; 否则继续。在程序最后，返回 False。<br>
为了证明算法的正确性，我们定义了循环不变式。循环不变式是指在每次迭代前和后均保持不变的性质。了解循环不变式对理解循环的意义十分重要。下面就是循环不变式:<br>
在下一次搜索之前,搜索过的整数中没有重复的整数。<br>
循环不变式在循环之前为真，因为还没有搜索过的整数。每次循环，我们查找当前元素的任何可能重复。如果发现重复项,则函数返回 True 退出；如果没有发现，则不变式仍然成立。<br>
因此，如果循环结束，循环不变式说明全部 nn 个整数中不存在重复元素。</p>
</blockquote>
<pre><code>Java
public boolean containsDuplicate(int[] nums) {
    for (int i = 0; i &lt; nums.length; ++i) {
        for (int j = 0; j &lt; i; ++j) {
            if (nums[j] == nums[i]) return true;  
        }
    }
    return false;
}
// Time Limit Exceeded
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 : O(n<sup>2)。最坏的情况下，需要检查n(n+1)/2对整数。因此，时间复杂度为O(n</sup>2 )。<br>
空间复杂度 : O(1)。只使用了常数额外空间。<br>
注意<br>
本方法在 Leetcode 上会超时。一般而言，如果一个算法的时间复杂度为 O(n<br>
^2 )，它最多能处理 n 大约为 10^4 的数据。当 n 接近 10^5时就会超时。</p>
<p>方法二：排序 【通过】<br>
直觉<br>
如果存在重复元素，排序后它们应该相邻。<br>
算法<br>
本方法使用排序算法。由于比较排序算法，如堆排序，可以在最坏情况下具有O(nlogn) 的时间复杂度。因此，排序经常是很好的预处理方法。排序之后，我们可以扫描已排序的数组,以查找是否有任何连续的重复元素。</p>
</blockquote>
<pre><code>Java
public boolean containsDuplicate(int[] nums) {
    Arrays.sort(nums);
    for (int i = 0; i &lt; nums.length - 1; ++i) {
        if (nums[i] == nums[i + 1]) return true;
    }
    return false;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 : O(nlogn)。<br>
排序的复杂度是 O(nlogn)，扫描的复杂度是 O(n)。整个算法主要由排序过程决定，因此是 O(nlogn)。<br>
空间复杂度 : O(1)。<br>
这取决于具体的排序算法实现，通常而言，使用 堆排序 的话，是 O(1)O(1)。<br>
注意<br>
此处的算法实现对原始数组进行排序，修改了原始数组。通常，除非调用方清楚输入数据将被修改，否则不应该随意修改输入数据。可以先复制 nums，然后对副本进行操作。</p>
</blockquote>
<p>嗯....这两个官方题解都只能说是差强人意呀，第一个直接是比较了，太暴力了吧...不过循环不变式的思想还是挺有趣的，第二个也仅仅是使用了快速排序、堆排序等时间复杂度下限的排序函数，代码也有点敷衍了，直接上了Java的函数，所以这一次就当做是hashmap的小试牛刀吧，hhh还真的是牛刀。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 275. H指数 II]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-275-h-zhi-shu-ii</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-275-h-zhi-shu-ii">
        </link>
        <updated>2019-09-11T11:13:27.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目如下：<br>
给定一位研究者论文被引用次数的数组（被引用次数是非负整数），数组已经按照升序排列。编写一个方法，计算出研究者的 h 指数。<br>
h 指数的定义: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）至多有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数不多于 h 次。）&quot;</p>
<p>示例:<br>
输入: citations = [0,1,3,5,6]<br>
输出: 3<br>
解释: 给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 0, 1, 3, 5, 6 次。<br>
     由于研究者有 3 篇论文每篇至少被引用了 3 次，其余两篇论文每篇被引用不多于 3 次，所以她的 h 指数是 3。<br>
说明:<br>
如果 h 有多有种可能的值 ，h 指数是其中最大的那个。<br>
进阶：<br>
这是 H指数 的延伸题目，本题中的 citations 数组是保证有序的。<br>
你可以优化你的算法到对数时间复杂度吗？<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/h-index-ii<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>其实这道题和昨天的一毛一样，重点在于给出的数组已经是有序数组，而且在题目中很明显暗示我们达到对数时间复杂度，所以需要在时间复杂度上下功夫，昨天的答案是不能用的了。<br>
一开始我的想法就是既然排好序了，数组的序号和数组的数值之间就有了相对应的关系，只需要比较（数组长度-序号)和数值就可以了，而且从示例中可以看出，答案一般都处于中段，或者是某部分的中段，同时对数时间复杂度，和二叉树的深度可以对应起来，所以第一时间就想到了二分法，下面是一开始的代码（注意，本次是未通过的代码！）</p>
<pre><code>class Solution {
public:
    int hIndex(vector&lt;int&gt;&amp; citations) {
        if(!citations.size())
            return 0;
        int sum=0;
        int h=0;
        bool flag=true;
        int beg=0,end=citations.size()-1;
        if (!end){
            return citations[0]?1:0;
        }
        do{
        int midd = (beg+end)/2;
        if(citations.size()-midd&gt;citations[midd]){
            beg = midd;
            h = midd+1;
        }
        else if(citations.size()-midd==citations[midd]){
            h = midd+1;
            flag=false;
        }else
            flag=false;            
        }while(flag); 
        return h;
    }
};
</code></pre>
<p>代码中有很多问题，不过主要的问题还是取中值和左半边的问题，取中值的时候一直在纠结是取右中值还是左中指，最后选择左中指后还需要对结果进行+1。然后就是对数组的判断，只考虑了左半边（长度大于数值）的问题，没有考虑到右半边的问题，所以导致结果一直错误（还有一开始的空数组、{0}零数组的问题没有考虑好）<br>
最后直接看了网友题解，为什么呢，因为一开始以为二分法错了...结果打开题解发现大家都是用的二分法啊...所以还是基础不够扎实，还是得老老实实做题，下面是网友题解：</p>
<blockquote>
<p>方法：二分查找<br>
思路分析：<br>
题目中说到：<br>
本题中的 citations 数组是保证有序的。<br>
并且还暗示<br>
你可以优化你的算法到对数时间复杂度吗？<br>
因此，可以使用二分查找法。二分查找这种非对即错的问题，我也经常栽跟头，我个人觉得根据示例分析应该是一个不错的方法。<br>
不知道大家有没有这种感觉，就是代码有的时候稀里糊涂就写对了，我想应该是方法对了，可能出错的地方就是一些边界条件吧。<br>
就根据示例 citations = [0, 1, 3, 5, 6]。<br>
中位数是 3 ，citations[3] 恰好也等于 3，这个 3 正好是边界，不太好分析 ，我把中位数改成了 2。<br>
即：citations = [0, 1, 2, 5, 6]。此时根据题目意思，此时索引为 2 的那篇论文就不能被记入 h 指数（因为，如果算进去，则有 3 篇论文，但是这篇最少被引用的文章才被引用 2 次）。<br>
因此，我们分析出 h 指数和以下两个指标有关：<br>
1、某个索引 i 的 citations 的数值；<br>
2、某个索引 i 到 citations 的末尾索引的长度，即区间 [i, len - 1] 的长度，即 len - 1 - i + 1 = len - i。<br>
根据被我把中位数改成 2 的示例，如果 nums[i] &lt; len - i ，索引 i 必须后移一位，因此候选区间为 [i + 1, len - 1]，根据“二分搜索模板”可知 left = i + 1，那 nums[i] &lt; len - i 的反面一定是 mid = right，看到 left = i + 1 可知分支排除了中位数，因此默认选择左中位数是对的（不会死循环）。<br>
提交以后，发现测试用例 [0] 不能通过，想想的确有可能出现这种情况，万一这一位学者的诸多文章还没有被人引用过，h 指数就为 0 了，所以单独判断一下即可。<br>
最后，返回的是区间的长度，根据刚才的分析，这个值是 len - i。因此，本题使用二分查找法，找到 i 即可。<br>
来自用户 @coder_hezi 的总结：<br>
要返回选取的区间的长度，而选取的区间要满足区间中的数大于等于所在区间的长度。<br>
参考代码：</p>
</blockquote>
<pre><code>Java
public class Solution {
    // 思路：看 nums[mid] 和区间 [mid, len - 1] 的长度，即 len - mid - 1 + 1 = len - mid
    // 要返回的是 nums 中的值
    // [0,1,2,5,6]，
    // 以下的代码注释是 coder_hezi 帮助添加的，在此表示感谢
    public int hIndex(int[] citations) {
        int len = citations.length;
        // 特判
        if (len == 0 || citations[len - 1] == 0) {
            return 0;
        }
        int left = 0;
        int right = len - 1;
        while (left &lt; right) {
            int mid = (left + right) &gt;&gt;&gt; 1;
            // 比长度小，就得去掉该值
            if (citations[mid] &lt; len - mid) {
                left = mid + 1;
            } else {
                // 比长度大是满足的，我们应该继续让 mid 往左走去尝试看有没有更小的 mid 值
                // 可以满足 mid 对应的值大于等于从 [mid, length - 1] 的长度
                right = mid;
            }
        }
        return len - left;
    }
    public static void main(String[] args) {
        int[] citations = {0, 1, 2, 5, 6};
        Solution solution = new Solution();
        int hIndex = solution.hIndex(citations);
        System.out.println(hIndex);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(logN)，这里 N是数组的长度。<br>
空间复杂度：O(1)，使用到的变量都只有常数个。</p>
</blockquote>
<p>解题思路还是很清晰的，最重要的还是在于中值的选择和mid的处理，本题目中中值选择左中指，mid赋予给right或者把mid+1赋予给left，从而使得特殊情况比如{0，1}能够得到正确答案，同时特殊情况的判断很重要，例如{0，0}这种极端情况， citations[len - 1] == 0能够很好地消除这种情况</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++避坑]]></title>
        <id>https://lixin-ee.github.io//post/cbi-keng</id>
        <link href="https://lixin-ee.github.io//post/cbi-keng">
        </link>
        <updated>2019-09-11T04:07:17.000Z</updated>
        <content type="html"><![CDATA[<p>cout不明确：<br>
将using namespace std; 删除后保存cpp文件，<br>
再加上using namespace std;保存cpp文件。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ C++ primer 第五章 笔记+习题]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-wu-zhang-bi-ji-xi-ti</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-wu-zhang-bi-ji-xi-ti">
        </link>
        <updated>2019-09-11T01:06:33.000Z</updated>
        <content type="html"><![CDATA[<p>5.1-5.3.1<br>
空语句 用在需要语法上需要的地方， 比如while ，空语句最好加上注释<br>
复合语句 也称作块，一个块就是一个作用域。<br>
复合语句用在语法上只能一条语句但是逻辑上需要多条语句的地方，比如while和for<br>
注意while和for本来只能容纳一条语句，所以要用 { }</p>
<p>习题5.1<br>
空语句就是只有一个单独的分号的语句，什么也不执行。主要是用于语法上需要一条语句但是逻辑上不需要的地方，比如while和for循环头完成了所有操作的话，循环体就需要一个空语句<br>
习题5.2<br>
块也就是复合语句，是指用花括号括起来的语句和声明的序列。如果在语法上只能容纳一条语句但是逻辑上需要多条语句的话，就应该使用块，例如while和for的循环体<br>
习题5.3<br>
while（val&lt;=10） sum+=val,++val;<br>
可读性提高了<br>
知识点：可以用逗号运算符使得比较简短的循环体变成一句话<br>
习题5.4<br>
（a）while循环头可以进行定义，但是不应该进行定义，否则每次循环都会定义一次，如果没有显式的break就会形成死循环<br>
（b）在while循环头进行定义的变量作用域只在while循环块内，if是无法使用status的<br>
习题5.5</p>
<pre><code>int main() {
	int grade;
	const vector&lt;string&gt; level{ &quot;A+&quot;,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot; };
	cin &gt;&gt; grade;
	if (grade == 100)
		cout &lt;&lt; level[0];
	else if (grade &gt;= 90)
		cout &lt;&lt; level[1];
	else if (grade &gt;= 80)
		cout &lt;&lt; level[2];
	else if (grade &gt;= 70)
		cout &lt;&lt; level[3];
	else if (grade &gt;= 60)
		cout &lt;&lt; level[4];
	else
		cout &lt;&lt; level[5];
};
</code></pre>
<p>习题5.6</p>
<pre><code>int main() {
	int grade;
	const vector&lt;string&gt; level{ &quot;A+&quot;,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot; };
	cin &gt;&gt; grade;
	cout &lt;&lt; ((grade &lt; 60) ? level[5] : (grade &lt; 70) ? level[4] : (grade &lt; 80) ? level[3] : (grade &lt; 90) ? level[2] : (grade &lt;100) ? level[1] : level[0]);
};
</code></pre>
<p>知识点:条件运算符的优先级实在是太低了。。。连&lt;&lt;都不如，一定要加括号<br>
习题5.7<br>
（a）没有加分号<br>
（b）没有加花括号，没法形成块<br>
（c）ival定义在while循环头，作用域只在while内部<br>
（d）==号和=号的差别特别大， 虽然合法，但是循环达不到预期效果。<br>
习题5.8<br>
悬垂else是指if的数量大于else的数量，容易造成二义性，从而规定else与离它最近的尚未匹配的if进行匹配。</p>
<p>5.3.2<br>
switch语句中case标签必须是<strong>整形</strong>常量表达式（3 或者 ‘a’） 3.14或者 int 型都不行，除了default<br>
任何两个<strong>case标签不能相同</strong><br>
两个case标签之间要有break语句，<strong>否则会连续执行</strong>接下来的case<br>
无break语句应该备注注释<br>
default语句就算为空也应该定义<br>
每个标签都应该跟上一条语句、空语句或者空块<br>
在case语句中 <strong>不能进行变量的初始化，但可以进行变量的定义</strong>。<br>
最好在case内定义一个块，再定义并初始化变量，保证其他case都在作用域外</p>
<p>习题5.9</p>
<pre><code>int main() {
	string s;
	while (cin &gt;&gt; s) {
		int num = 0;
		for (auto letter : s)
			switch (letter)
			{
			case 'a': {++num; break; }
			case 'i': {++num; break; }
			case 'o': {++num; break; }
			case 'u': {++num; break; }
			case 'e': {++num; break; }
			default:break;
			}
		cout &lt;&lt; &quot;num is &quot; &lt;&lt; num&lt;&lt;endl;
	}
};
</code></pre>
<p>习题5.10</p>
<pre><code>int main() {
	string s;
	while (cin &gt;&gt; s) {
		int num = 0;
		for (auto letter : s)
			switch (letter)
			{
			case'A': case 'a': {++num; break; }
			case'I': case 'i': {++num; break; }
			case'O': case 'o': {++num; break; }
			case'U': case 'u': {++num; break; }
			case'E': case 'e': {++num; break; }
			default:break;
			}
		cout &lt;&lt; &quot;num is &quot; &lt;&lt; num&lt;&lt;endl;
	}
};
</code></pre>
<p>习题5.11</p>
<pre><code>int main() {
	char s;
	int num = 0;
	int space = 0, tab = 0, enter = 0;
	while (cin&gt;&gt;noskipws&gt;&gt;s) {	
			switch (s)
			{
			case'A': case 'a': {++num; break; }
			case'I': case 'i': {++num; break; }
			case'O': case 'o': {++num; break; }
			case'U': case 'u': {++num; break; }
			case'E': case 'e': {++num; break; }
			case' ': {++space; break; }
			case'\t': {++tab; break; }
			case'\n': {++enter; break; }
			default:break;
			}
	}
	cout &lt;&lt; &quot;num is &quot; &lt;&lt; num &lt;&lt; endl;
	cout &lt;&lt; &quot;space is &quot; &lt;&lt; space &lt;&lt; endl;
	cout &lt;&lt; &quot;tab is &quot; &lt;&lt; tab &lt;&lt; endl;
	cout &lt;&lt; &quot;enter is &quot; &lt;&lt; enter &lt;&lt; endl;
};
</code></pre>
<p>知识点：注意此处不能再用string了 string的逐个字母判断遇到空格等字符就会停止。。。只能用char一个一个读入。<br>
习题5.12</p>
<pre><code>int main() {
	string s;
	int ff = 0, fl = 0, fi = 0;
	while (cin &gt;&gt; s) {
		for (int i = 0; i &lt; s.size() - 1; ++i) {
			auto letter = s[i];
			switch (letter)
			{
			case 'f': {
				switch (s[i + 1])
				{
				case 'f': {++ff; break; }
				case 'l': {++fl; break; }
				case 'i': {++fi; break; }
				default:
					break;
				}
			}
			default:break;
			}
		}
	}
	cout &lt;&lt; &quot;ff is &quot; &lt;&lt; ff &lt;&lt; endl;
	cout &lt;&lt; &quot;fl is &quot; &lt;&lt; fl &lt;&lt; endl;
	cout &lt;&lt; &quot;fi is &quot; &lt;&lt; fi &lt;&lt; endl;
};
</code></pre>
<p>习题5.13<br>
（a）case直接没有break，会连续执行<br>
（b）在case语句中 不能进行变量的初始化<br>
（c）不能在同一语句中定义多个case标签<br>
（d）case后面的ival、jval等并非常量</p>
<p>5.4.1<br>
while的条件语句中可以是表达式或者带初始化的变量声明<br>
while 内部的变量（条件部分或循环体内）<strong>每次迭代都会经历创建到销毁</strong><br>
while循环使用1.迭代次数<strong>不确定</strong> 2. <strong>需要在循环结束后访问循环控制变量</strong></p>
<p>习题5.14</p>
<pre><code>int main() {
	string s;
	string s_b;
	int num=0;
	int lab=0;
	cin &gt;&gt; s;
	s_b = s;
	while (cin &gt;&gt; s) {
		if (s_b == s)
			++num, ++lab;
		else if (num)
			cout &lt;&lt; s_b &lt;&lt; &quot; occur &quot; &lt;&lt; num+1 &lt;&lt; &quot; time &quot; &lt;&lt; endl, s_b = s, num = 0;
		else
			s_b = s, num = 0;
	}
	if (!lab)
		cout &lt;&lt; &quot;no same words occur&quot; &lt;&lt; endl;
};
</code></pre>
<p>5.4.2<br>
for语句中init-statement必须是声明语句、表达式语句或者空语句<br>
for语句开始循环时init-statement执行后i<strong>立即判断一次condition</strong><br>
<strong>init-statement中定义的对象只在for循环体内可见 **<br>
init-statemen 可以定义多个对象，但是只能有一条声明语句，所以</strong>所有变量的基础类型必须相同**<br>
for 语句头中的内容都能省略</p>
<p>习题5.15<br>
（a）循环头定义的变量的作用域只在循环体，if无法调用ix<br>
（b）循环判断可以省略，但是分号；不可以省略<br>
（c）两者同时在增长，除非循环体内部有其他控制，否则陷入死循环<br>
习题5.16<br>
其实前面用得很多，就得根据情况而定，甚至有时候使用do while都更加方便<br>
习题5.17</p>
<pre><code>int main() {
	vector&lt;int&gt; v1;
	vector&lt;int&gt; v2;
	int len = (v1.size() &lt; v2.size() ? v1.size() : v2.size());
	int i = 0;
	for (; i &lt; len; ++i)
		if (v1[i] != v2[i])
			return -1;
	return 1;	
};
</code></pre>
<p>5.4.3<br>
范围For 语句<br>
Expression 表示的必须是一个<strong>序列</strong><br>
比如花括号括起来的初始值列表、数组、vector 、string ，这些类型的共同特点是<strong>拥有能返回迭代器的begin和end成员</strong><br>
5.4.4<br>
do while语句 至少执行一次循环<br>
<strong>不允许在条件部分定义变量，否则变量使用出现在定义之前</strong><br>
do while在<strong>循环体内定义的变量也无法在条件部分使用</strong><br>
do while 的while<strong>条件部分后应该有；号</strong></p>
<p>习题5.18<br>
（a）do后面需要使用块语句<br>
（b）do while在循环判断中定义的变量是没有意义的<br>
（c）do while 在循环体中定义的变量也没法给循环判断使用<br>
习题5.19</p>
<pre><code>int main() {
	string s1, s2;
	do {
		cin &gt;&gt; s1 &gt;&gt; s2;
		string output = s1.size() &lt; s2.size() ? s1 : s2;
		cout &lt;&lt; &quot;the shorter is &quot; &lt;&lt; output &lt;&lt; endl;
	}
	while (cin);
};
</code></pre>
<p>5.5.1 break语句<br>
终止离它<strong>最近</strong>的while，do while，for，switch语句</p>
<p>习题5.20</p>
<pre><code>int main() {
	string s, s_b;
	int flag=0;
	cin &gt;&gt; s;
	s_b = s;
	do {
		cin &gt;&gt; s;
		if (s_b == s) {
			++flag; 
			break;
		}
		s_b = s;
	}
	while (cin);
	if (!flag)
		cout &lt;&lt; &quot;no same word&quot; &lt;&lt; endl;
	else
		cout &lt;&lt; s_b &lt;&lt; &quot; is the same word&quot;&lt;&lt;endl;
};
</code></pre>
<p>5.5.2 continue语句<br>
不能用于switch</p>
<p>习题5.21</p>
<pre><code>int main() {
	string s, s_b;
	int flag=0;
	cin &gt;&gt; s;
	s_b = s;
	do {
		cin &gt;&gt; s;
		if (s_b == s) 
			if(s[0]&gt;='A'&amp;&amp;s[0] &lt;= 'Z'){
			++flag; 
			break;
			}
			else
				continue;
		s_b = s;
	}
	while (cin);
	if (!flag)
		cout &lt;&lt; &quot;no same word&quot; &lt;&lt; endl;
	else
		cout &lt;&lt; s_b &lt;&lt; &quot; is the same word&quot;&lt;&lt;endl;
};

</code></pre>
<p>5.5.3goto语句<br>
不建议使用<br>
带标签语句<br>
标签标示符 独立于变量和其他标示符名字 可以和其他标示符使用同一个名字</p>
<p>习题5.22</p>
<pre><code>for（int sz =get_size()；sz&lt;=0；）
	sz =get_size()；
</code></pre>
<p>5.6<br>
throw表达式 表示异常检测部分遇到了无法处理的问题<br>
try语句块 用于处理异常 以一个或多个catch语句结束<br>
catch语句 异常处理代码<br>
异常类 用于在throw和catch语句之间传递异常的具体信息<br>
5.6.1<br>
标准库异常类型定义在stdexcept头文件中 需要添加std：：前缀<br>
throw表达式 throw errorstyle（）；<br>
例子 throw std::runtime_error(“错误信息”) //例如(“data must refer to same ISBN”)<br>
runtime_error对象需要使用string对象或者c风格字符串进行初始化<br>
5.6.2<br>
Try{ 正常逻辑<br>
}catch (异常声明){异常处理<br>
}<br>
每个标准库异常类都定义了名为what的成员函数，没有参数，返回值是c风格字符串, const char*,使用例子：</p>
<pre><code>try {
		if (j == 0)
			throw runtime_error(&quot;j cannot be zero&quot;);
		cout &lt;&lt; &quot;result is &quot; &lt;&lt; i / j &lt;&lt; endl;
	}
	catch (runtime_error error) {
		cout &lt;&lt; error.what() &lt;&lt; endl;
</code></pre>
<p>发生异常时,可能有多个try-catch语句的嵌套，Try语句从外到内执行，catch语句从内到外搜索，如果最终都没找到匹配的catch，程序转到terminate标准库函数<br>
5.6.3<br>
exception，bad_alloc，bad_cast异常类型的对象只能默认初始化不能提供初始值，其他的需要用string或c风格字符串初始化，不允许用默认初始化<br>
异常类型只定义了一个what成员函数，提供关于异常的文本信息</p>
<p>习题5.23</p>
<pre><code>int main() {
	int i, j;
	cin &gt;&gt; i &gt;&gt; j;
	if (j == 0)
		throw runtime_error(&quot;j cannot be zero&quot;);
	else
		cout &lt;&lt; &quot;result is &quot; &lt;&lt; i / j &lt;&lt; endl;
};
</code></pre>
<p>习题5.24<br>
vs 显示abort() has been called<br>
习题5.25</p>
<pre><code>int main() {
	int i, j;
	while(cin &gt;&gt; i &gt;&gt; j)
	try {
		if (j == 0)
			throw runtime_error(&quot;j cannot be zero&quot;);
		cout &lt;&lt; &quot;result is &quot; &lt;&lt; i / j &lt;&lt; endl;
	}
	catch (runtime_error error) {
		cout &lt;&lt; error.what() &lt;&lt; endl;
		cout &lt;&lt; &quot;whether you want to continue?[y/n]&quot;;
		string s;
		cin &gt;&gt; s;
		if (s[0] == 'y')
			continue;
		else
			break;
	}	
};
</code></pre>
<p>知识点：如果try-catch语句在循环体内，在catch 语句中也可以使用continue和break；</p>
<p>习题感悟<br>
可以用逗号运算符使得比较简短的循环体变成一句话<br>
cout &lt;&lt; ((grade &lt; 60) ? level[5] level[0]);条件运算符的优先级实在是太低了。。。连&lt;&lt;都不如，一定要加括号<br>
string的逐个字母判断遇到空格等字符就会停止。。。只能用char一个一个读入。<br>
do while 的while条件部分后应该有；号</p>
<pre><code>do
		cin &gt;&gt; v1 &gt;&gt; v2;
	while (cin);
</code></pre>
<p>是正确的<br>
do while在<strong>循环体内定义的变量也无法在条件部分使用</strong><br>
continue语句 不能用于switch<br>
what（）的使用方法：其中runtime_error等是一个类型，可以对其定义变量</p>
<pre><code>try {
		if (j == 0)
			throw runtime_error(&quot;j cannot be zero&quot;);
		cout &lt;&lt; &quot;result is &quot; &lt;&lt; i / j &lt;&lt; endl;
	}
	catch (runtime_error error) {
		cout &lt;&lt; error.what() &lt;&lt; endl;
</code></pre>
<p>如果try-catch语句在循环体内，在catch 语句中也可以使用continue和break；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 274. H指数]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-274-h-zhi-shu</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-274-h-zhi-shu">
        </link>
        <updated>2019-09-10T03:28:18.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目如下：<br>
给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。<br>
h 指数的定义: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）至多有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数不多于 h 次。）”</p>
<p>示例:<br>
输入: citations = [3,0,6,1,5]<br>
输出: 3<br>
解释: 给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。<br>
     由于研究者有 3 篇论文每篇至少被引用了 3 次，其余两篇论文每篇被引用不多于 3 次，所以她的 h 指数是 3。<br>
说明: 如果 h 有多种可能的值，h 指数是其中最大的那个<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/h-index<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>题目还是很拗口啊，评论里很多人吐槽，但是这个看了例子还是比较好理解的，就是有两个数，一个是被引用数reference，一个是符合被引用数的文章数量number，两者是此消彼长的，而且最后只会有一个解。<br>
一开始的想法是没一个reference都遍历一次数组，根据reference的值和number的值的差异来判断是否达到了临界值或者超过了临界值，这个临界值就是所求。<br>
最后的代码如下：</p>
<pre><code>class Solution {
public:
    int hIndex(vector&lt;int&gt;&amp; citations) {
        
        if(!citations.size())
            return 0;
        int h=0;
        int h_refer=0,h_num=0;
        do{
            h_refer++;
            h_num=0;
            for(auto i:citations)
                 if (i&gt;=h_refer)
                    h_num++;
            if(h_refer&lt;=h_num)
                ++h;
        }while(h_refer&lt;h_num);
            return h;
    }
};
</code></pre>
<p>一次通过啦！！！愉快的一天！！！<br>
但是其实中途还是有点波折的，因为感觉do while语句比较适合这个情况（很难一开始就判断循环条件），然后就是h递增的判断，因为很容易越过临界点，但是经过一定的考虑和修改后顺利地一次过了。<br>
然后还有一些缺陷就是运行时间太长，时间复杂度为o（h*n）<br>
然后看一下官方题解：</p>
<blockquote>
<p>方法一：排序<br>
分析<br>
我们想象一个直方图，其中 xx 轴表示文章，yy 轴表示每篇文章的引用次数。如果将这些文章按照引用次数降序排序并在直方图上进行表示，那么直方图上的最大的正方形的边长 hh 就是我们所要求的 hh。<br>
算法<br>
首先我们将引用次数降序排序，在排完序的数组citations 中，如果icitations[i]&gt;i，那么说明第 0 到 i 篇论文都有至少 i+1 次引用。因此我们只要找到最大的 ii满足citations[i]&gt;i，那么 h 指数即为i+1。<br>
找到最大的 ii的方法有很多，可以对数组进行线性扫描，也可以使用二分查找。由于排序的时间复杂度已经为 O(nlogn)，因此无论是线性扫描O(n) 还是二分查找O(logn)，都不会改变算法的总复杂度。<br>
复杂度分析<br>
时间复杂度：O(nlogn)，即为排序的时间复杂度。<br>
空间复杂度：O(1)O(1)。大部分语言的内置 sort 函数使用堆排序，它只需要 O(1)O(1) 的额外空间。</p>
</blockquote>
<p>方法一是比较简单暴力的排序，时间复杂度下限O(nlogn)，所以来看一下方法二：</p>
<blockquote>
<p>方法二：计数<br>
分析<br>
基于比较的排序算法存在时间复杂度下界 O(n\log n)O(nlogn)，如果要得到时间复杂度更低的算法，就必须考虑不基于比较的排序。<br>
算法<br>
方法一中，我们通过降序排序得到了 h 指数，然而，所有基于比较的排序算法，例如堆排序，合并排序和快速排序，都存在时间复杂度下界O(nlogn)。要得到时间复杂度更低的算法. 可以考虑最常用的不基于比较的排序，计数排序。<br>
然而，论文的引用次数可能会非常多，这个数值很可能会超过论文的总数 n，因此使用计数排序是非常不合算的（会超出空间限制）。在这道题中，我们可以通过一个不难发现的结论来让计数排序变得有用，即：<br>
如果一篇文章的引用次数超过论文的总数 nn，那么将它的引用次数降低为 n 也不会改变 h 指数的值。<br>
由于 h指数一定小于等于 n，因此这样做是正确的。在直方图中，将所有超过 y 轴值大于 n 的变为n  等价于去掉 y&gt;n 的整个区域。<br>
从直方图中可以更明显地看出结论的正确性，将 y&gt;n 的区域去除，并不会影响到最大的正方形，也就不会影响到 h 指数。<br>
我们用一个例子来说明如何使用计数排序得到 h 指数。首先，引用次数如下所示：<br>
citations=[1,3,2,3,100]<br>
将所有大于 n=5n=5 的引用次数变为 nn，得到：<br>
citations=[1,3,2,3,5]<br>
计数排序得到的结果如下：<br>
k 	     0	1	2	3	4	5<br>
count	0	1	1	2	0	1<br>
sk   	5	5	4	3	1	1<br>
其中 s_k	表示至少有 k 次引用的论文数量，在表中即为在它之后的列（包括本身）的 count 一行的和。根据定义，最大的满足k≤s 的 k 即为所求的 h。在表中，这个 k 为 3，因此 h 指数为 3。</p>
</blockquote>
<pre><code>Java
public class Solution {
    public int hIndex(int[] citations) {
        int n = citations.length;
        int[] papers = new int[n + 1];
        // 计数
        for (int c: citations)
            papers[Math.min(n, c)]++;
        // 找出最大的 k
        int k = n;
        for (int s = papers[n]; k &gt; s; s += papers[k])
            k--;
        return k;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)。在计数时，我们仅需要遍历citations 数组一次，因此时间复杂度为 O(n)。在找出最大的 k 时，我们最多需要遍历计数的数组一次，而计数的数组的长度为O(n)，因此这一步的时间复杂度为O(n)，即总的时间复杂度为 O(n)。<br>
空间复杂度：O(n)。我们需要使用 O(n) 的空间来存放计数的结果。</p>
</blockquote>
<p>方法而是利用空间换取时间，主要是（1）把大于数组范围的值置为和数组一致（2）记录大于某个引用次数的文章数（3）从大到小搜索临界值<br>
最后的代码</p>
<pre><code>class Solution {
public:
    int hIndex(vector&lt;int&gt;&amp; citations) {
        if(!citations.size())
            return 0;
        int len = citations.size();
        vector&lt;int&gt; num(len,0);
        for(auto i:citations)
            if(i)
                if(i&gt;len)
                    ++num[len-1];
                else
                    ++num[i-1];
        for(int i=num.size()-1,sum=0;i&gt;=0;--i){
            sum+=num[i];
            if(i&lt;=sum-1)
                return i+1;
        }
        return 0;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第四章 笔记+习题 4.6-4.11]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-si-zhang-bi-ji-xi-ti-46-411</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-si-zhang-bi-ji-xi-ti-46-411">
        </link>
        <updated>2019-09-09T23:51:59.000Z</updated>
        <content type="html"><![CDATA[<p>4.6<br>
ptr-&gt;mem 等价于(*ptr).mem 注意*的使用<br>
解引用符*的优先级低于点运算符. 所以必须加上括号 （*p）.size（）<br>
箭头运算符作用于一个指针类型的运算对象，结果为<strong>左值</strong>，点运算符分为两种情况，如果成员所属对象为左值，那么结果是左值，反之成员所属对象为右值，结果也为右值</p>
<p>习题4.20<br>
（a）先把指针后移一位然后解引用<br>
（b）先解引用然后把指针指向的值+1 不合法<br>
（c）先对指针调用empty（）再解引用 不合法<br>
（d）解引用指针再调用指向对象的empty（）<br>
（e）先解引用指针再把指针指向的值+1 不合法<br>
（f）解引用指针调用指向对象的empty（），再把指针+1</p>
<p>4.7<br>
条件运算符 cond?:expr1:expr2 其中expr1和expr2需类型相同或可转换为公共类型，cond为真返回expr1 否则返回expr2<br>
当条件运算符的两个表达式都是左值或者能转换成同一左值类型时结果为左值，否则为右值<br>
条件运算符可以嵌套<br>
条件运算符满足右结合律，意味着运算对象一般按照从右向左的顺序组合<br>
A=B? C:D? E:F; // 等同于A=B? C(D? E:F);<br>
条件运算符的优先级非常低 所以要加括号 而且问号应在括号外面 (a&gt;1)?b:c;</p>
<p>习题4.21</p>
<pre><code>int main() {
	vector&lt;int&gt; v{ 1,3,5 };
	for (auto &amp;i : v) 
		i = (i % 2) ? 2 * i : i;
};
</code></pre>
<p>习题4.22</p>
<pre><code>int main() {
	int grade;
	string level;
	level = (grade &lt; 60) ? &quot;fail&quot; : (grade &lt; 75) ? &quot;low pass&quot; : (grade &lt; 90) ? &quot;pass&quot; : &quot;high pass&quot;;
	
	if (grade &lt; 60)
		level = &quot;fail&quot;;
	else if(grade &lt; 75)
		level = &quot;low pass&quot;;
	else if(grade &lt; 90)
		level = &quot;pass&quot;;
	else
		level = &quot;high pass&quot;;
};
</code></pre>
<p>条件运算符比较简洁，但if运算符可读性更高<br>
习题4.23<br>
==符号和+号的优先级大于条件运算符，应对整个条件运算符语句加括号<br>
习题4.24<br>
左结合律就必须修改条件判断的位置，否则会出错</p>
<p>4.8位运算符<br>
位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合<br>
左移操作会改变符号位的值 所以最好将位运算符用于处理无符号类型<br>
移位运算符满足左结合律 （左结合律相当于满足从左到右）</p>
<p>习题4.25<br>
左移6位，变成01011100<br>
习题4.26<br>
能够表示的学生数量变少<br>
习题4.27<br>
（a）等于4（b）等于7（c）等于true（d）等于true</p>
<p>4.9sizeof运算符<br>
sizeof运算符返回所占字节数，满足右结合律，所得的值是size_t类型的<strong>常量表达式</strong>（与数组下标的类型相同）<br>
sizeof运算符返回的是占用空间的大小，而不是对象的值，因此sizeof可以使用空指针<br>
对于数组，sizeof不会把数组名转化为指针来处理；对于vector和string，只返回该类型的固定部分大小，而不会计算元素共占用了多少空间<br>
注意sizeof返回值是一个常量表达式 可以用于声明数组维度</p>
<p>习题4.28</p>
<pre><code>cout&lt;&lt;sizeof(int)&lt;&lt;endl;
cout&lt;&lt;sizeof(char)&lt;&lt;endl;
cout&lt;&lt;sizeof(double)&lt;&lt;endl;
cout&lt;&lt;sizeof(float)&lt;&lt;endl;
....
</code></pre>
<p>习题4.29<br>
第一个是数组元素的个数，第二个未定义，需要看不同机器中指针所占的空间大小和int类型所占大小的比值<br>
习题4.30<br>
（a）sizeof(x)+y（注意此处并非右结合律<br>
（b）sizeof(p-&gt;mem[i])<br>
（c） (sizeof a) &lt; b<br>
（d）无需改变。</p>
<p>4.10 逗号运算符<br>
逗号运算符的优先级是最低的，主要作用是将几个算式并列并<strong>返回最右边的算式的结果</strong><br>
逗号运算符含有两个运算对象，按照从左到右的顺序依次求值，逗号运算符的<strong>真正结果是右侧表达式的值</strong>。<br>
someValue？++x，++y：--x,--y;的结果为(someValue？++x，++y：--x),--y;</p>
<p>习题4.31<br>
前置版本更加方便，更加节省空间。不需要作改动也能生效。<br>
习题4.32<br>
对数组ia进行循环<br>
习题4.33<br>
对somevalue进行判断，然后执行相应操作，最后才进行y的前置递减，等同于someValue？++x，++y：--x,--y;的结果为(someValue？++x，++y：--x),--y;</p>
<p>4.11类型转换<br>
如果两种对象可以相互转换，就是有关联的。如果两种类型有关联，那么当程序需要其中一种类型的运算对象时可以用另一种关联类型的对象或值来替代<br>
<strong>隐式转换会尽可以避免损失进度</strong> 3+3.1415会把3转化为3.1415的double类型<br>
4.11.1算术转换<br>
注意整型提升（char、short转化为int或long）<br>
如果运算对象中有一个无符号类型且无符号类型不小于带符号类型，则带符号转化为无符号，如果带符号类型对象为负数，则带来负面影响（比如-1转化为256范围的类型会变成255）。否则的话取决于无符号类型的所有值能否存在该带符号类型中</p>
<p>习题4.34<br>
（a）fval转化为bool类型<br>
（b）ival转化为float 然后两者之和转化为double<br>
（c）char转化为int，结果再转化为double<br>
习题4.35<br>
（a）'a'从char整型提升为int 然后int结果再转化为char<br>
（b）int转化为double，然后转化为unsigned（假设ui大于ival），然后转化为float<br>
（c）取决于ui的大小<br>
（d）int转化为float，float转化为double</p>
<p>4.11.2其他隐式类型转换<br>
数组名在以下情况不会转换成指针：1.decltype 2.取地址符&amp; 3.sizeof 4.typeid 5.用一个引用来初始化数组（此处貌似有误，应该是定义数组的引用(&amp;a)[10]<br>
4.11.3显式转换<br>
显式转换本质上非常危险<br>
强制类型转换 cast-name<type>(expression);注意不要漏掉express的括号<br>
cast-name指定执行哪种变换<br>
static_cast 只要不包含底层const都能用 例如把void<em>指针的值找回来<br>
double slope = static_cast<double>(j) /i; //强制类型转换进行浮点数除法<br>
void <em>p = &amp;d; double <em>dp = static_cast&lt;double</em>&gt;(p); //把void</em>指针的值找回来<br>
const_cast 只能改变运算对象底层的const 比如把const char</em>变为char* 而不能变成string<br>
reinterpret_cast 尽量不要使用<br>
函数形式的强制类型转换 type(expr) 	C语言风格的强制类型转换(type) expr</p>
<p>习题4.36<br>
i*=int(d)<br>
习题4.37<br>
（a）void <em>pv = static_cast&lt;void</em>&gt;(const_cast&lt;string*&gt;(ps))<br>
（b）int i = static_cast<int>(*pc)<br>
（c）void <em>pv = static_cast&lt;void</em>&gt;(&amp;d)<br>
（d）char <em>pc = static_cast&lt;char</em>&gt;(&amp;pv)<br>
习题4.38<br>
将j/i的值强制转换为double 如果想保留小数部分，应该对i、j分别进行类型转换</p>
<p>习题感悟<br>
注意sizeof右结合律的意义，并是指sizeof x + y等于sizeof（x+y），而是指一个式子中出现多个sizeof时如何定义运算顺序，参考条件运算符？：<br>
someValue？++x，++y：--x,--y;的结果为(someValue？++x，++y：--x),--y;</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 134.加油站]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-134jia-you-zhan</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-134jia-you-zhan">
        </link>
        <updated>2019-09-09T14:50:55.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。<br>
你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。<br>
如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p>
<p>说明: <br>
如果题目有解，该答案即为唯一答案。<br>
输入数组均为非空数组，且长度相同。<br>
输入数组中的元素均为非负数。<br>
示例 1:<br>
输入:<br>
gas  = [1,2,3,4,5]<br>
cost = [3,4,5,1,2]<br>
输出: 3<br>
解释:<br>
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油<br>
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油<br>
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油<br>
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油<br>
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油<br>
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。<br>
因此，3 可为起始索引。<br>
示例 2:</p>
<p>输入:<br>
gas  = [2,3,4]<br>
cost = [3,4,3]<br>
输出: -1<br>
解释:<br>
你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。<br>
我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油<br>
开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油<br>
开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油<br>
你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。<br>
因此，无论怎样，你都不可能绕环路行驶一周。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/gas-station<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>一开始的思路是将两个数组相减得到差值diff，等于负数的地方是不可以作为出发点的，然后将第一个正数作为出发点（因为说只有唯一解），然后以出发点为轴翻转diff（参考之前的数组向右移位k位）然后对diff求和看最后一位是否为0。<br>
代码如下：</p>
<pre><code>class Solution {
public:
    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) {
        vector&lt;int&gt; diff;    
        for(int i = 0;i&lt;gas.size();++i)
            diff.push_back(gas[i]-cost[i]);
        int first = 0;
        for(int i = 1;i&lt;diff.size()+1;++i)
            if(diff[i-1]&gt;0){
                first=i;
                break;
            }
        if(first==0)
            return -1;
        swap_diff(diff,0,diff.size()-1);
        swap_diff(diff,0,first-1);
        swap_diff(diff,first,diff.size()-1);
        for(int i = 1;i&lt;diff.size();++i){
            diff[i]+=diff[i-1];
            if(i!=(diff.size()-1)&amp;&amp;diff[i]&lt;=0)
                return -1;
            }
        if(diff[diff.size()-1]&gt;=0)
            return first-1;
        else
            return -1;
    }
    void swap_diff(vector&lt;int&gt;&amp; diff,int beg,int last){
        for(int i=beg;i&lt;last;++i){
            int temp = diff[i];
            diff[i]=diff[last];
            diff[last]=temp;
            if(--last == i)
                break;
        }
    }
};
</code></pre>
<p>这段代码是很有问题的，diff中的正数可能有多个，只考虑第一个的话，万一是{1，-10，11，...}的情况肯定白给了。如果对diff中的正数进行逐个参考，那么时间复杂度直接变成n^2，得不偿失，所以我的算法是有本质的问题的，所以打算直接看题解，官方题解如下：</p>
<blockquote>
<p>1.如果 sum(gas) &lt; sum(cost) ，那么不可能环行一圈，这种情况下答案是 -1 。<br>
我们可以用这个式子计算环行过程中邮箱里剩下的油：total_tank = sum(gas) - sum(cost) ，如果 total_tank &lt; 0 则返回 -1 。<br>
2.对于加油站 i ，如果 gas[i] - cost[i] &lt; 0 ，则不可能从这个加油站出发，因为在前往 i + 1 的过程中，汽油就不够了。<br>
第二个规则可以被一般化，我们引入变量 curr_tank ，记录当前油箱里剩余的总油量。如果在某一个加油站 curr_tank比 0 小，意味着我们无法到达这个加油站。<br>
下一步我们把这个加油站当做新的起点，并将 curr_tank 重置为 0 ，因为重新出发，油箱中的油为 0 。（从上一次重置的加油站到当前加油站的任意一个加油站出发，到达当前加油站之前， curr_tank 也一定会比 0 小）</p>
<p>整体算法：<br>
那么现在算法是很直接明了的：<br>
初始化 total_tank 和 curr_tank 为 0 ，并且选择 0 号加油站为起点。<br>
遍历所有的加油站：<br>
每一步中，都通过加上 gas[i] 和减去 cost[i] 来更新 total_tank 和 curr_tank 。<br>
如果在 i + 1 号加油站， curr_tank &lt; 0 ，将 i + 1 号加油站作为新的起点，同时重置 curr_tank = 0 ，让油箱也清空。<br>
如果 total_tank &lt; 0 ，返回 -1 ，否则返回 starting station。</p>
</blockquote>
<pre><code>class Solution:
    def canCompleteCircuit(self, gas, cost):
        &quot;&quot;&quot;
        :type gas: List[int]
        :type cost: List[int]
        :rtype: int
        &quot;&quot;&quot;
        n = len(gas)
        
        total_tank, curr_tank = 0, 0
        starting_station = 0
        for i in range(n):
            total_tank += gas[i] - cost[i]
            curr_tank += gas[i] - cost[i]
            # If one couldn't get here,
            if curr_tank &lt; 0:
                # Pick up the next station as the starting one.
                starting_station = i + 1
                # Start with an empty tank.
                curr_tank = 0
        
        return starting_station if total_tank &gt;= 0 else -1
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(N) ， 这是因为只有一个遍历了所有加油站一次的循环。<br>
空间复杂度： O(1) ，因为此算法只使用了常数个变量。</p>
</blockquote>
<p>关于算法原理可以看官方题解和高赞题解的详细解答。<br>
这是最后代码：</p>
<pre><code>class Solution {
public:
    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) {
        int sum=0;
        int curr=0;
        int first=0;
        for(int i=0;i&lt;gas.size();++i){
            sum+=gas[i]-cost[i];
            curr+=gas[i]-cost[i];
            if(curr&lt;0)
            {
                first=i+1;
                curr=0;
            }
        }
        return sum&gt;=0?first:-1;
    }
};
</code></pre>
<p>感想：还是得打好数学基础啊！这题没有理解这个数学概念（如果一个数组的总和非负，那么一定可以找到其中找到一个点开始，累加和一直都是非负的）的话就直接白给了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ C++ primer 第四章 笔记+习题 4.1-4.5]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-si-zhang-bi-ji-xi-ti-41-45</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-si-zhang-bi-ji-xi-ti-41-45">
        </link>
        <updated>2019-09-09T11:50:55.000Z</updated>
        <content type="html"><![CDATA[<p>4.1.1<br>
字面值和变量是最简单的表达式<br>
函数调用也是一种特殊的运算符<br>
小整数类型（bool、char、short）一般会被提升为较大的整数类型，主要是int<br>
左值可以位于赋值语句的左侧，右值则不能 另一种解释：左值指的是既能够出现在等号左边也能出现在等号右边的变量(或表达式)，右值指的则是只能出现在等号右边的变量(或表达式).<br>
当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）<br>
在需要右值的地方可以用左值来代替，但是不能把右值当成左值（也就是位置）来使用</p>
<ol>
<li>赋值运算符 需要一个非常量的左值作为其左侧运算对象，得到的结果也仍然是一个左值。</li>
<li>取地址符 作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值。</li>
<li>内置解引用运算符、下标运算符、迭代器解引用运算符、string和vector的下标运算符的求值结果都是左值</li>
<li>内置类型和迭代器的递增递减运算符作用于左值运算对象，其前置版本所得结果也是左值（后置版本则将对象原始值的副本作为右值返回。）</li>
<li>decltype中，如果表达式的求值结果是一个左值，则得到一个引用类型。例如 p的类型是int*，解引用符生成左值，所以 decltype（*p）的结果是int&amp;。另一方面，取地址运算符生成右值，<strong>所以decltype（&amp;p）的结果为int，指向整形指针的指针。</strong><br>
4.1.2<br>
括号无视优先级和结合律<br>
结合律对表达式产生影响的一个典型示例是输入输出运算 cin&gt;&gt;v1&gt;&gt;v2;//<strong>左结合律，先读入v1，再读入v2</strong></li>
</ol>
<p>习题4.1<br>
105，和平常的运算顺序一致<br>
习题4.2<br>
（a）*(vec.begin) （b）*(vec.begin)+1<br>
知识点：调用运算符的优先级高于解引用运算符</p>
<p>4.1.3<br>
表达式中的求值顺序是不确定的，尽量不要在表达式中进行求值 比如 cout&lt;&lt;i&lt;&lt;++i;<br>
有四种运算符明确规定了运算对象的求值顺序（<strong>先左后右</strong>） 1.逻辑与&amp;&amp; 2.逻辑或 3.条件运算符 ?:   4.逗号运算符</p>
<p>习题4.3<br>
可以，程序员可以灵活使用括号符，应当承担保证代码正确的责任，进一步提高效率。</p>
<p>4.2<br>
左结合律：优先级相同时从左到右进行组合<br>
算术运算符的运算对象和求值对象都是右值<br>
在表达式求值前，小整数类型（bool、char、short）一般会被提升为较大的整数类型<br>
一元运算符可以作用于一个指针 或 算术值 得到一个提升后的副本 比如 bool b=true；  -b为true 运算过程为  负号使得b变为int类型并等于1 取负后得到-1 -1再变为布尔类型得到真。<br>
除法运算中商无论正负，一律向0取整，即直接切除小数部分<br>
<strong>取模运算中 结果的符号与被除数相同。</strong></p>
<p>习题4.4<br>
(12/3*4)+(5*15)+(24%4/2) = 91<br>
习题4.5<br>
（a）-86（b）-18（c）0（d）-2<br>
习题4.6</p>
<pre><code>if（a%2） 
	cout&lt;&lt;&quot;奇数&quot;&lt;&lt;endl; 
else
	cout&lt;&lt;&quot;偶数&quot;&lt;&lt;endl; 
</code></pre>
<p>习题4.7<br>
当前值大于变量类型所能容纳的范围<br>
int i = 2^16+1;double d=2^64+1 ;int i = -2^16-1</p>
<p>4.3<br>
关系运算符用于算术类型或指针类型，逻辑运算符作用于任意能转换成布尔值的类型 两者的返回值都是布尔类型，都是右值<br>
将更重要的条件放在逻辑运算符的<strong>左边</strong><br>
在if（val == true）语句中，<strong>会先将true转换为val的类型，而不是将val转换为布尔类型，</strong> 等同于if（val == 1）所以一般使用if（val）<br>
进行比较运算时除非比较的对象是布尔类型，否则不要用true和false来作为运算对象<br>
习题4.8<br>
先左后右<br>
习题4.9<br>
先判断cp的值是否为零，如果不为0再判断*p的值是否为0<br>
习题4.10</p>
<pre><code>int i；
while（cin&gt;&gt;i）
	if(i==42)
		break;
</code></pre>
<p>习题4.12<br>
先判断j&lt;k是否成立，得到bool值转化为0或1，再与i比较是否相等！等同于  if(i!=(j&lt;k) )<br>
知识点：右结合律，并且使用类型转换</p>
<p>4.4<br>
赋值运算符的左侧运算对象必须是一个可修改的左值<br>
赋值运算符的结果是它的左侧运算对象，并且是一个左值<br>
使用花括号进行初始值列表初始化的时候<strong>不允许出现窄化转换</strong>，即精确度损失 int i; i = {3.14}是错误的<br>
初始值列表可以为空，无论左侧运算对象的类型是什么，此时编译器创建一个<strong>值初始化的临时量赋给左侧运算对象，比如int为0 ，string为空</strong><br>
赋值运算符满足<strong>右结合律</strong>，<strong>因此 ival = jval = 0；的运算是正确的</strong><br>
多重赋值语句需要类型相同或者是可以相互转换的类型<br>
<strong>不能把指针的值赋给int</strong>，因为int*无法转换成 int<br>
赋值运算符等级较低，最好多用括号<br>
a += b与 a = a + b的区别在于<strong>复合运算符只求值一次，普通运算符求值两次</strong><br>
（题目 4.13）</p>
<p>习题4.13<br>
（a）d=i=3（注意右结合律导致精度损失 ）（b）i=3 d=3.5<br>
知识点：赋值语句右结合律，精度损失<br>
习题4.14<br>
第一个报错，第二个永远等于true<br>
习题4.15<br>
不能把int*赋给int，就算当中的值可以视为一个整数<br>
习题4.16<br>
右结合律<br>
（a） (p=getPtr())!=0（b）i==1024</p>
<p>4.5递增和递减运算符<br>
前置++和后置++都必须作用于左值运算对象，前置版本将对象本身作为左值返回，<strong>后置版本则将对象原始值的副本作为右值返回。</strong><br>
后置递增运算符比较消耗性能，降低了可读性，除非能够使程序更简洁，否则不建议使用<br>
如果想在一条复合表达式中既将变量+1或-1又能使用它原来的值，就应当使用后置递增递减符<br>
*ptr++ 等同于*(ptr++)** 递增运算符的优先级高于解引用运算符**<br>
<strong>注意这样子仍可以正常输出，因为把ptr++后仍然返回副本，注意！！和惯性思维不同，返回副本不等于输出后再递增</strong><br>
<strong>运算对象可按任意顺序求值</strong>，所以*ptr = func(*ptr++);的最终结果是<strong>未定义的</strong>，最终结果取决于编译器自身执行的顺序</p>
<p>习题4.17<br>
前置递增运算符在使用变量前递增，后置递增符则在使用后递增<br>
习题4.18<br>
先向前移动再解引用，容易导致访问未知地址的值<br>
习题4.19<br>
（a）不正确，前者判断是否为空指针，后者则先递增指针再判断值是否为0，容易读取到未知值<br>
（b）判断ival和ival+1两个值是否都非0<br>
（c）未定义值，不知道++在何时运行（注意和&amp;&amp;的区别，&amp;&amp;是必需先完成右边再算左边）</p>
<p>习题感悟<br>
if（i！=j&lt;k）等同于  if(i!=(j&lt;k) ) 右结合律<br>
int i;double d; d=i=3.5;//d=i=3（注意右结合律导致精度损失 ）<br>
不能把int*赋给int，就算当中的值可以视为一个整数<br>
ival++&amp;&amp;ival 判断ival和ival+1两个值是否都非0，注意先判断ival再递增，再判断右边值</p>
]]></content>
    </entry>
</feed>