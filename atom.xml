<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-12-08T02:44:04.184Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[图 399. 除法求值[中等][未做出][待阅读]]]></title>
        <id>https://lixin-ee.github.io//post/tu-399-chu-fa-qiu-zhi-zhong-deng-wei-zuo-chu-dai-yue-du</id>
        <link href="https://lixin-ee.github.io//post/tu-399-chu-fa-qiu-zhi-zhong-deng-wei-zuo-chu-dai-yue-du">
        </link>
        <updated>2019-12-08T02:16:18.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给出方程式 A / B = k, 其中 A 和 B 均为代表字符串的变量， k 是一个浮点型数字。根据已知方程式求解问题，并返回计算结果。如果结果不存在，则返回 -1.0。<br>
示例 :<br>
给定 a / b = 2.0, b / c = 3.0<br>
问题: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? <br>
返回 [6.0, 0.5, -1.0, 1.0, -1.0 ]<br>
输入为: vector&lt;pair&lt;string, string&gt;&gt; equations, vector&lt; double&gt;&amp; values,vector&lt;pair&lt;string, string&gt;&gt; queries(方程式，方程式结果，问题方程式)， 其中 equations.size() == values.size()，即方程式的长度与方程式结果长度相等（程式与结果一一对应），并且结果值均为正数。以上为方程式的描述。 返回vector&lt; double&gt;类型。<br>
基于上述例子，输入如下：<br>
equations(方程式) = [ [&quot;a&quot;, &quot;b&quot;], [&quot;b&quot;, &quot;c&quot;] ],<br>
values(方程式结果) = [2.0, 3.0],<br>
queries(问题方程式) = [ [&quot;a&quot;, &quot;c&quot;], [&quot;b&quot;, &quot;a&quot;], [&quot;a&quot;, &quot;e&quot;], [&quot;a&quot;, &quot;a&quot;], [&quot;x&quot;, &quot;x&quot;] ].<br>
输入总是有效的。你可以假设除法运算中不会出现除数为0的情况，且不存在任何矛盾的结果。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/evaluate-division<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>//在310用floyd翻车了就回来这边用了<br>
//本题目可以视为 建立图-搜索两点之间的最短路径 的问题<br>
//在大话数据结构的两种方法里面，最适合这道题的无疑是floyd<br>
//另一种算法：迪杰斯特拉（Dijkstra)算法：按路径长度递增的次序产生最短路径的算法，基于已经求出的最短路径的基础上一步步求出它们之间顶点的最短路径，适用于某个源点到其余各顶点的最 短路径问题<br>
//floyd就等于动态规划，一共有三层规划 k代表中转顶点的下标 v是起始顶点 w代表结束顶点，等于对于每两个点之间都以某个点来做中转，然后只取最短点（其实就是（Dijkstra)算法的循环版）<br>
//对于本题目来说，需要注意的点有：1.需要用map建立string和int下标的映射<br>
//2.对对称点使用倒数来初始化<br>
//3.循环计算时的判断式<code>if(graph[v][w]==-1.0&amp;&amp;graph[v][k]!=-1.0&amp;&amp;graph[k][w]!=-1.0)</code><br>
//4.最后利用map进行判断节点是否存在<code>if(trans.count(queries[i][0])&amp;&amp;trans.count(queries[i][1]))</code></p>
<pre><code>class Solution {
public:
    vector&lt;double&gt; calcEquation(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;double&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries) {
        map&lt;string,int&gt; trans;
        int n=0;
        for(int i=0;i&lt;equations.size();++i){
            if(!trans.count(equations[i][0]))
               trans.insert({equations[i][0],n++});
             if(!trans.count(equations[i][1]))
               trans.insert({equations[i][1],n++});
        }
        vector&lt;vector&lt;double&gt;&gt; graph(n,vector(n,-1.0));
        for(int i=0;i&lt;n;++i)
            graph[i][i]=1.0;
       for(int i=0;i&lt;equations.size();++i){
           int row=trans[equations[i][0]];
           int col=trans[equations[i][1]];
           graph[row][col]=values[i];
           graph[col][row]=1/values[i];               
       } 
     build(graph);  
     vector&lt;double&gt; res;
    for(int i=0;i&lt;queries.size();++i){
        if(trans.count(queries[i][0])&amp;&amp;trans.count(queries[i][1])){
            int row=trans[queries[i][0]];
            int col=trans[queries[i][1]];
            res.push_back(graph[row][col]);
        }
        else
            res.push_back(-1.0);
                 }
                return res;
    }
    
    void build(vector&lt;vector&lt;double&gt;&gt;&amp; graph){       
        int n=graph.size();
        for(int k=0;k&lt;n;++k)
            for(int v=0;v&lt;n;++v)
                for(int w=0;w&lt;n;++w)
                    if(graph[v][w]==-1.0&amp;&amp;graph[v][k]!=-1.0&amp;&amp;graph[k][w]!=-1.0)
                        graph[v][w]=graph[v][k]*graph[k][w],graph[w][v]=1/graph[v][w];
    }
};
</code></pre>
<p>然后惯例来看一下网友题解，有一位网友总结了三种解法，而且用的是C++，感动<br>
方法一：Floyd</p>
<pre><code>struct Value {
    int status;
    double val;
    Value(): status(0), val(0) {}
    Value(int s, double v) : status(s), val(v) {}
};

class Solution {
public:
    vector&lt;double&gt; calcEquation(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;double&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries) {      
        unordered_map&lt;string, int&gt; store;
        int n = 0;
        for (auto e : equations) {
            if (store.find(e[0]) == store.end())
                store[e[0]] = n++;
            if (store.find(e[1]) == store.end())
                store[e[1]] = n++;
        }

        vector&lt;vector&lt;Value&gt;&gt; graph(n, vector&lt;Value&gt;(n, Value()));
        for (int i = 0; i &lt; equations.size(); ++i) {
            int ia = store[equations[i][0]];
            int ib = store[equations[i][1]];
            graph[ia][ib] = Value(1, values[i]);
            graph[ib][ia] = Value(1, 1/values[i]);
        }
        
        for (int k = 0; k &lt; n; ++k) {
            for (int i = 0; i &lt; n; ++i) {
                for (int j = 0; j &lt; n; ++j) {
                    if (graph[i][j].status == 0 &amp;&amp; graph[i][k].status == 1 &amp;&amp; graph[k][j].status == 1) {
                        graph[i][j] = Value(1, graph[i][k].val * graph[k][j].val);
                    }
                }
            }
        }
        
        vector&lt;double&gt; res;
        for (auto q : queries) {
            if (store.find(q[0]) == store.end() || store.find(q[1]) == store.end()) {
                res.push_back(-1);
                continue;
            } 
            int ia = store[q[0]];
            int ib = store[q[1]];
            double r = graph[ia][ib].status == 1 ? graph[ia][ib].val : -1;
            res. push_back(r);
        }
        return res;
    }
};
</code></pre>
<p>方法二：dfs 和 bfs<br>
主要分为两步：<br>
1.build 构造初始化图<br>
2.dfs 或者 bfs 进行遍历</p>
<pre><code>class Solution {
public:
    vector&lt;double&gt; calcEquation(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;double&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries) {
        auto graph = build(equations, values);
           
        vector&lt;double&gt; res;  
        for (auto q : queries) {
            set&lt;string&gt; visited;
            bool found = false;
            //double r = bfs(graph, visited, q[0], q[1], found);
            double r = dfs(graph, visited, q[0], q[1], found);
            if (found) {
                res.push_back(r);
                graph[q[0]][q[1]] = r;
                graph[q[1]][q[0]] = 1 / r;
            } else {
                res.push_back(-1);
            }
        }
      
        return res;
    }

    unordered_map&lt;string, unordered_map&lt;string, double&gt;&gt; build(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;double&gt;&amp; values) {
        unordered_map&lt;string, unordered_map&lt;string, double&gt;&gt; m;
        for (int i = 0; i &lt; equations.size(); ++i) {
            vector&lt;string&gt; eqa = equations[i];
            string a = eqa[0];
            string b = eqa[1];
            double v = values[i];
            if (m.find(a) == m.end()) {
                m[a] = unordered_map&lt;string, double&gt;{{b, v}};
            } else {
                m[a][b] = v;
            }
            if (m.find(b) == m.end()) {
                m[b] = unordered_map&lt;string, double&gt;{{a, 1 /v}};
            } else {
                m[b][a] = 1 / v;
            }
        }
        return m;
    }

    double bfs(unordered_map&lt;string, unordered_map&lt;string, double&gt;&gt;&amp; g, set&lt;string&gt; visited, string begin, string end, bool&amp; found) {
        if (g.find(begin) == g.end() || g.find(end) == g.end()) {
            found = false;
            return -1;
        }
        queue&lt;pair&lt;string, double&gt;&gt; q;
        q.push(make_pair(begin, 1));
        while (!q.empty()) {
            auto cur = q.front();
            q.pop();
            if (visited.find(cur.first) != visited.end()) {
                continue;
            }
            if (cur.first == end) {
                found = true;
                return cur.second;
            }
            visited.insert(cur.first);
            for (auto it : g[cur.first]) {
                q.push(make_pair(it.first, cur.second * it.second));
            }
        }
        found = false;
        return -1;
    }
  
    double dfs(unordered_map&lt;string, unordered_map&lt;string, double&gt;&gt;&amp; g, set&lt;string&gt; visited, string begin, string end, bool&amp; found) {
        if (g.find(begin) == g.end() || g.find(end) == g.end()) {
            found = false;
            return -1;
        }
        if (visited.find(begin) != visited.end()) {
            found = false;
            return -1;
        }
        if (g[begin].find(end) != g[begin].end()) {
            found = true;
            return g[begin][end];
        }
        visited.insert(begin);
        for (auto it : g[begin]) {
            double r = dfs(g, visited, it.first, end, found);
            if (found) {
                double res = r * it.second;
                return res;
            }
        }
        visited.erase(begin);
        found = false;
        return -1;
    }
};
</code></pre>
<p>方法三：并查集</p>
<pre><code>struct Node {
    double value;
    Node* parent;
    Node() : parent(this) {}
    Node(double v) : value(v), parent(this) {}
};

class Solution {
    unordered_map&lt;string, Node*&gt; m;

    Node* find(Node* n) {
        if (n-&gt;parent != n) {
            n-&gt;parent = find(n-&gt;parent);
        }
        return n-&gt;parent;
    }
   
    void merge(Node* n1, Node* n2, double val) {
        Node* p1 = find(n1);
        Node* p2 = find(n2);
        double ratio = n2-&gt;value * val / n1-&gt;value;
        for (auto it : m) {
            if (find(it.second) == p1) {
                it.second-&gt;value *= ratio;
            }
        } 
        p1-&gt;parent = p2;
    }
public:
    vector&lt;double&gt; calcEquation(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;double&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries) {
        for (int i = 0; i &lt; equations.size(); ++i) {
            string a = equations[i][0];
            string b = equations[i][1];
            if (m.find(a) == m.end()) m[a] = new Node(values[i]);
            if (m.find(b) == m.end()) m[b] = new Node(1.0);
            merge(m[a], m[b], values[i]);
        }
        vector&lt;double&gt; res;
        for (auto q : queries) {
            if (m.find(q[0]) == m.end() || m.find(q[1]) == m.end() || find(m[q[0]]) != find(m[q[1]])) {
                res.push_back(-1);
            } else {
                res.push_back(m[q[0]]-&gt;value / m[q[1]]-&gt;value);
            }
        }
        return res;
    }
};
</code></pre>
<p>DFS和BFS 以及并查集值得好好阅读一下。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图 133. 克隆图[中等]]]></title>
        <id>https://lixin-ee.github.io//post/tu-133-ke-long-tu-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/tu-133-ke-long-tu-zhong-deng">
        </link>
        <updated>2019-12-07T00:47:09.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定无向连通图中一个节点的引用，返回该图的深拷贝（克隆）。图中的每个节点都包含它的值 val（Int） 和其邻居的列表（list[Node]）。<br>
示例：</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1575679961753.png" alt=""></p>
<blockquote>
<p>输入：<br>
{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: …&quot;neighbors&quot;:[{&quot;'>id&quot;:&quot;1&quot;,&quot;neighbors&quot;:[{&quot;</span>id&quot;:&quot;2&quot;,&quot;neighbors&quot;:[{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 9: ref&quot;:&quot;1&quot;}̲,{&quot;'>ref&quot;:&quot;1&quot;},{&quot;</span>id&quot;:&quot;3&quot;,&quot;neighbors&quot;:[{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 9: ref&quot;:&quot;2&quot;}̲,{&quot;'>ref&quot;:&quot;2&quot;},{&quot;</span>id&quot;:&quot;4&quot;,&quot;neighbors&quot;:[{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 9: ref&quot;:&quot;3&quot;}̲,{&quot;'>ref&quot;:&quot;3&quot;},{&quot;</span>ref&quot;:&quot;1&quot;}],&quot;val&quot;:4}],&quot;val&quot;:3}],&quot;val&quot;:2},{&quot;$ref&quot;:&quot;4&quot;}],&quot;val&quot;:1}<br>
解释：<br>
节点 1 的值是 1，它有两个邻居：节点 2 和 4 。<br>
节点 2 的值是 2，它有两个邻居：节点 1 和 3 。<br>
节点 3 的值是 3，它有两个邻居：节点 2 和 4 。<br>
节点 4 的值是 4，它有两个邻居：节点 1 和 3 。<br>
提示：<br>
节点数介于 1 到 100 之间。<br>
无向图是一个简单图，这意味着图中没有重复的边，也没有自环。<br>
由于图是无向的，如果节点 p 是节点 q 的邻居，那么节点 q 也必须是节点 p 的邻居。<br>
必须将给定节点的拷贝作为对克隆图的引用返回。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/clone-graph<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>//一开始就感觉这个其实是一个遍历题，主要是保证每个节点仅被遍历一次否则会new出重复的节点，看了大话数据结构的源代码后，发现缺少一个记录已访问节点的结构，就使用map代替了<br>
//map就保存一对结点，一个旧结点对应一个新节点<br>
//然后主要流程就是构造新节点-利用map判断是否已存在-存在则连接-不存在则递归调用<br>
//最后空间复杂度爆炸，但是时间复杂度还可以<br>
//时间复杂度O(n^2) 假设每个点都相连，则需要两层n循环</p>
<pre><code>/*
// Definition for a Node.
class Node {
public:
    int val;
    vector&lt;Node*&gt; neighbors;

    Node() {}

    Node(int _val, vector&lt;Node*&gt; _neighbors) {
        val = _val;
        neighbors = _neighbors;
    }
};
*/
class Solution {
public:
    map&lt;Node*,Node*&gt; mnn;
    Node* cloneGraph(Node* node) {
        Node *cur=new Node(node-&gt;val,vector&lt;Node*&gt;());
        mnn.insert({node,cur});
        for(auto i:node-&gt;neighbors){
            if(mnn.count(i))
                cur-&gt;neighbors.push_back(mnn[i]);
            else{       
               auto next=cloneGraph(i); 
                cur-&gt;neighbors.push_back(next);
            }
        }
        return cur;
    }
};
</code></pre>
<p>然后来看看网友题解：</p>
<blockquote>
<p>解题思路:<br>
这道题就是遍历整个图，所以遍历时候要记录已经访问点，我们用一个字典记录。<br>
所以，遍历方法就有两种。<br>
思路一:DFS (深度遍历)<br>
思路二:BFS (广度遍历)<br>
大家重点掌握，后面图遍历都和这个有关系！<br>
代码:<br>
思路一:</p>
</blockquote>
<pre><code>Java
class Solution {
    public Node cloneGraph(Node node) {
        Map&lt;Node, Node&gt; lookup = new HashMap&lt;&gt;();
        return dfs(node, lookup);
    }

    private Node dfs(Node node, Map&lt;Node,Node&gt; lookup) {
        if (node == null) return null;
        if (lookup.containsKey(node)) return lookup.get(node);
        Node clone = new Node(node.val, new ArrayList&lt;&gt;());
        lookup.put(node, clone);
        for (Node n : node.neighbors)clone.neighbors.add(dfs(n,lookup));
        return clone;
    }
}
</code></pre>
<blockquote>
<p>思路二:</p>
</blockquote>
<pre><code>Java
class Solution {
    public Node cloneGraph(Node node) {
        if (node == null) return null;
        Map&lt;Node, Node&gt; lookup = new HashMap&lt;&gt;();
        Node clone = new Node(node.val, new ArrayList&lt;&gt;());
        lookup.put(node, clone);
        Deque&lt;Node&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(node);
        while (!queue.isEmpty()) {
            Node tmp = queue.poll();
            for (Node n : tmp.neighbors) {
                if (!lookup.containsKey(n)) {
                    lookup.put(n, new Node(n.val, new ArrayList&lt;&gt;()));
                    queue.offer(n);
                }
                lookup.get(tmp).neighbors.add(lookup.get(n));
            }
        }
        return clone;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 96. 不同的二叉搜索树[中等]]]></title>
        <id>https://lixin-ee.github.io//post/shu-96-bu-tong-de-er-cha-sou-suo-shu-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/shu-96-bu-tong-de-er-cha-sou-suo-shu-zhong-deng">
        </link>
        <updated>2019-12-06T01:27:17.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？<br>
示例:<br>
输入: 3<br>
输出: 5<br>
解释:<br>
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:<br>
1         3     3      2      1<br>
\       /     /      / \      <br>
3     2     1      1   3      2<br>
/     /       \                 <br>
2     1         2                 3</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/unique-binary-search-trees<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<pre><code> class Solution {
public:
    
    int numTrees(int n) {
        vector&lt;int&gt; vi(n+1,0);
        vi[0]=1;
        for(int i=1;i&lt;=n;++i){
            int res=0;
            for(int j=1;j&lt;=i;++j){
               res+=vi[j-1]*vi[i-j]; 
            }
            vi[i]=res;
        }
        return vi[n];
    }
};
</code></pre>
<p>//一开始想单纯地找n和树的可能性之间的关系，结果发现不靠谱，因为单纯地在n-1的可能里加上1个值的话会有重复的情况<br>
//然后就想到以根为参考点的方法，就是 1，2，3中，分别考虑根节点为1，2，3的可能，此时就把问题化为两边子树的可能性了<br>
//最后看了题解发现这就是动态规划嘛，从n=1的情况开始推到n=n的情况<br>
//需要注意的是 当子树节点树为0的时候也是视为一种可能性。然后就是vi的长度是n+1，需要额外保存0的情况<br>
//然后就是不能把根结底算进去<br>
非常操蛋的是8ms只击败了12%，题解里面肯定是有很简单的数学方法<br>
//果然是，其实就是把第二个循环变成了通用公式</p>
<p>然后来看一下网友题解：</p>
<blockquote>
<p>思路<br>
标签：动态规划<br>
假设n个节点存在二叉排序树的个数是G(n)，令f(i)为以i为根的二叉搜索树的个数，则<br>
G(n) = f(1) + f(2) + f(3) + f(4) + ... + f(n)<br>
当i为根节点时，其左子树节点个数为i-1个，右子树节点为n-i，则<br>
f(i) = G(i-1)*G(n-i)<br>
综合两个公式可以得到 卡特兰数 公式<br>
G(n) = G(0)<em>G(n-1)+G(1)</em>(n-2)+...+G(n-1)*G(0)<br>
代码</p>
</blockquote>
<pre><code>Java
class Solution {
    public int numTrees(int n) {
        int[] dp = new int[n+1];
        dp[0] = 1;
        dp[1] = 1;
        
        for(int i = 2; i &lt; n + 1; i++)
            for(int j = 1; j &lt; i + 1; j++) 
                dp[i] += dp[j-1] * dp[i-j];
        
        return dp[n];
    }
}
</code></pre>
<p>官方题解：<br>
<img src="https://lixin-ee.github.io//post-images/1575596257408.png" alt=""><br>
复杂度分析<br>
时间复杂度 : O(N)，只有一层循环。<br>
空间复杂度 : O(1)，只需要一个变量来存储中间与最终结果。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 117. 填充每个节点的下一个右侧节点指针 II[中等] ]]></title>
        <id>https://lixin-ee.github.io//post/shu-117-tian-chong-mei-ge-jie-dian-de-xia-yi-ge-you-ce-jie-dian-zhi-zhen-iizhong-deng</id>
        <link href="https://lixin-ee.github.io//post/shu-117-tian-chong-mei-ge-jie-dian-de-xia-yi-ge-you-ce-jie-dian-zhi-zhen-iizhong-deng">
        </link>
        <updated>2019-12-05T01:41:49.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个二叉树<br>
struct Node {<br>
int val;<br>
Node *left;<br>
Node *right;<br>
Node *next;<br>
}<br>
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。<br>
初始状态下，所有 next 指针都被设置为 NULL。<br>
进阶：<br>
你只能使用常量级额外空间。<br>
使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1575510214544.png" alt=""></p>
<blockquote>
<p>输入：root = [1,2,3,4,5,null,7]<br>
输出：[1,#,2,3,#,4,5,7,#]<br>
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。<br>
提示：<br>
树中的节点数小于 6000<br>
-100 &lt;= node.val &lt;= 100<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>因为前一题我用了通用性较高的方法，所以这一题居然直接完成了hhh，然后优雅的用法是没法用了，但是我的方法事件复杂度比较高（603ms还击败50%什么鬼），还是老老实实看一下题解吧<br>
同样地我的解法的问题在于不是常量的空间复杂度</p>
<p>然后来看网友题解：</p>
<blockquote>
<p>队列是为了维护先后关系<br>
但是先后关系本来就存在了next里<br>
所以可以不使用队列<br>
队列做法</p>
</blockquote>
<pre><code>Node* connect(Node* root) {
        if(root == NULL)return root;
        queueq;
        q.push(root);
        while(!q.empty()){
            Node*cur = NULL;
            int size = q.size();
            for(int i = size;i&gt;=0;i--){
                Node *tmp = q.front();q.pop();
                if(cur != NULL){
                    cur-&gt;next = tmp;
                }
                cur = tmp;
                if(tmp-&gt;left)q.push(tmp-&gt;left);
                if(tmp-&gt;right)q.push(tmp-&gt;right);
            }
        }
        return root;
</code></pre>
<blockquote>
<p>使用next来代替队列</p>
</blockquote>
<pre><code>Node* connect(Node* root) {
        Node *last = root;
        while(last != NULL){
            // 获得队首元素
            while(last &amp;&amp; last-&gt;left == NULL &amp;&amp; last-&gt;right == NULL)last = last-&gt;next;
            if(last == NULL)break;
            Node *cur = NULL;
            // 遍历队列
            for(Node *i = last;i != NULL;i = i-&gt;next){
                // 进行push和pop操作
                if(i -&gt; left){
                    if(cur != NULL){
                        cur-&gt;next = i-&gt;left;
                    }
                    cur = i-&gt;left;
                }
                if(i -&gt; right){
                    if(cur != NULL){
                        cur-&gt;next = i-&gt;right;
                    }
                    cur = i-&gt;right;
                }
            }
            // 更新队首
            last = last-&gt;left ? last-&gt;left : last-&gt;right;
        }
        return root;
    }
</code></pre>
<p>比较详细的做法：</p>
<blockquote>
<p>解法一 BFS<br>
直接把 116 题 题的代码复制过来就好，一句也不用改。<br>
利用一个栈将下一层的节点保存。通过pre指针把栈里的元素一个一个接起来。</p>
</blockquote>
<pre><code>public Node connect(Node root) {
    if (root == null) {
        return root;
    }
    Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;();
    queue.offer(root);
    while (!queue.isEmpty()) {
        int size = queue.size();
        Node pre = null;
        for (int i = 0; i &lt; size; i++) {
            Node cur = queue.poll();
            if (i &gt; 0) {
                pre.next = cur;
            }
            pre = cur;
            if (cur.left != null) {
                queue.offer(cur.left);
            }
            if (cur.right != null) {
                queue.offer(cur.right);
            }

        }
    }
    return root;
}
</code></pre>
<blockquote>
<p>解法二<br>
当然题目要求了空间复杂度，可以先到 116 题 看一下思路，这里在上边的基础上改一下。<br>
我们用第二种简洁的代码，相对会好改一些。</p>
</blockquote>
<pre><code>Node connect(Node root) {
    if (root == null)
        return root;
    Node pre = root;
    Node cur = null;
    while (pre.left != null) {
        cur = pre;
        while (cur != null) {
            cur.left.next = cur.right;
            if (cur.next != null) {
                cur.right.next = cur.next.left;
            }
            cur = cur.next;
        }
        pre = pre.left;
    }

    return root;
}
</code></pre>
<blockquote>
<p>需要解决的问题还是挺多的。<br>
cur.left.next = cur.right;<br>
cur.right.next = cur.next.left;<br>
之前的关键代码就是上边两句，但是在这道题中我们无法保证cur.left 或者 cur.right 或者 cur.next.left或者cur.next.right 是否为null。所以我们需要用一个while循环来保证当前节点至少有一个孩子。<br>
while (cur.left == null &amp;&amp; cur.right == null) {<br>
cur = cur.next;<br>
}<br>
这样的话保证了当前节点至少有一个孩子，然后如果一个孩子为 null，那么就可以保证另一个一定不为 null 了。<br>
整体的话，就用了上边介绍的技巧，代码比较长，可以结合的看一下。</p>
</blockquote>
<pre><code>Node connect(Node root) {
    if (root == null)
        return root;
    Node pre = root;
    Node cur = null;
    while (true) {
        cur = pre;
        while (cur != null) {
            //找到至少有一个孩子的节点
            if (cur.left == null &amp;&amp; cur.right == null) {
                cur = cur.next;
                continue;
            }
            //找到当前节点的下一个至少有一个孩子的节点
            Node next = cur.next;
            while (next != null &amp;&amp; next.left == null &amp;&amp; next.right == null) {
                next = next.next;
                if (next == null) {
                    break;
                }
            }
            //当前节点的左右孩子都不为空，就将 left.next 指向 right
            if (cur.left != null &amp;&amp; cur.right != null) {
                cur.left.next = cur.right;
            }
            //要接上 next 的节点的孩子，所以用 temp 处理当前节点 right 为 null 的情况
            Node temp = cur.right == null ? cur.left : cur.right;

            if (next != null) {
                //next 左孩子不为 null，就接上左孩子。
                if (next.left != null) {
                    temp.next = next.left;
                //next 左孩子为 null，就接上右孩子。
                } else {
                    temp.next = next.right;
                }
            }
            
            cur = cur.next;
        }
        //找到拥有孩子的节点
        while (pre.left == null &amp;&amp; pre.right == null) {
            pre = pre.next;
            //都没有孩子说明已经是最后一层了
            if (pre == null) {
                return root;
            }
        }
        //进入下一层
        pre = pre.left != null ? pre.left : pre.right;
    } 
}
</code></pre>
<p>解法三</p>
<blockquote>
<p>利用解法一的思想，我们利用 pre 指针，然后一个一个取节点，把它连起来。解法一为什么没有像解法二那样考虑当前节点为 null 呢？因为我们没有添加为 null 的节点，就是下边的代码的作用。<br>
if (cur.left != null) {<br>
queue.offer(cur.left);<br>
}<br>
if (cur.right != null) {<br>
queue.offer(cur.right);<br>
}<br>
所以这里是一样的，如果当前节点为null不处理就可以了。</p>
</blockquote>
<blockquote>
<p>第二个问题，怎么得到每次的开头的节点呢？我们用一个dummy指针，当连接第一个节点的时候，就将dummy指针指向他。此外，之前用的pre指针，把它当成tail指针可能会更好理解。如下图所示：</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1575511034936.png" alt=""></p>
<blockquote>
<p>cur 指针利用 next 不停的遍历当前层。<br>
如果 cur 的孩子不为 null 就将它接到 tail 后边，然后更新tail。<br>
当 cur 为 null 的时候，再利用 dummy 指针得到新的一层的开始节点。<br>
dummy 指针在链表中经常用到，他只是为了处理头结点的情况，它并不属于当前链表。<br>
代码就异常的简单了。</p>
</blockquote>
<pre><code>Node connect(Node root) {
    Node cur = root;
    while (cur != null) {
        Node dummy = new Node();
        Node tail = dummy;
        //遍历 cur 的当前层
        while (cur != null) {
            if (cur.left != null) {
                tail.next = cur.left;
                tail = tail.next;
            }
            if (cur.right != null) {
                tail.next = cur.right;
                tail = tail.next;
            }
            cur = cur.next;
        }
        //更新 cur 到下一层
        cur = dummy.next;
    }
    return root;
}
</code></pre>
<blockquote>
<p>总<br>
本来为了图方便，在 116 题 的基础上把解法二改了出来，还搞了蛮久，因为为 null 的情况太多了，不停的报空指针异常，最后终于理清了思路。但和解法三比起来实在是相形见绌了，解法三太优雅了，但其实这才是正常的思路，从解法一的做法产生灵感，利用 tail 指针将它们连起来。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 116. 填充每个节点的下一个右侧节点指针[中等]]]></title>
        <id>https://lixin-ee.github.io//post/shu-116-tian-chong-mei-ge-jie-dian-de-xia-yi-ge-you-ce-jie-dian-zhi-zhen-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/shu-116-tian-chong-mei-ge-jie-dian-de-xia-yi-ge-you-ce-jie-dian-zhi-zhen-zhong-deng">
        </link>
        <updated>2019-12-04T01:54:29.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：<br>
struct Node {<br>
int val;<br>
Node *left;<br>
Node *right;<br>
Node *next;<br>
}<br>
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。<br>
初始状态下，所有 next 指针都被设置为 NULL。<br>
示例：</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1575424563194.png" alt=""></p>
<blockquote>
<p>输入：{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: …&quot;:&quot;1&quot;,&quot;left&quot;:{&quot;'>id&quot;:&quot;1&quot;,&quot;left&quot;:{&quot;</span>id&quot;:&quot;2&quot;,&quot;left&quot;:{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 53: …t&quot;:null,&quot;val&quot;:4}̲,&quot;next&quot;:null,&quot;r…'>id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:4},&quot;next&quot;:null,&quot;right&quot;:{&quot;</span>id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:5},&quot;val&quot;:2},&quot;next&quot;:null,&quot;right&quot;:{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: …&quot;:&quot;5&quot;,&quot;left&quot;:{&quot;'>id&quot;:&quot;5&quot;,&quot;left&quot;:{&quot;</span>id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:6},&quot;next&quot;:null,&quot;right&quot;:{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 53: …t&quot;:null,&quot;val&quot;:7}̲,&quot;val&quot;:3},&quot;val&quot;…'>id&quot;:&quot;7&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7},&quot;val&quot;:3},&quot;val&quot;:1}
输出：{&quot;</span>id&quot;:&quot;1&quot;,&quot;left&quot;:{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: …&quot;:&quot;2&quot;,&quot;left&quot;:{&quot;'>id&quot;:&quot;2&quot;,&quot;left&quot;:{&quot;</span>id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: …:null,&quot;next&quot;:{&quot;'>id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:{&quot;</span>id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 53: …t&quot;:null,&quot;val&quot;:7}̲,&quot;right&quot;:null,&quot;…'>id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7},&quot;right&quot;:null,&quot;val&quot;:6},&quot;right&quot;:null,&quot;val&quot;:5},&quot;right&quot;:null,&quot;val&quot;:4},&quot;next&quot;:{&quot;</span>id&quot;:&quot;7&quot;,&quot;left&quot;:{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 9: ref&quot;:&quot;5&quot;}̲,&quot;next&quot;:null,&quot;r…'>ref&quot;:&quot;5&quot;},&quot;next&quot;:null,&quot;right&quot;:{&quot;</span>ref&quot;:&quot;6&quot;},&quot;val&quot;:3},&quot;right&quot;:{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 9: ref&quot;:&quot;4&quot;}̲,&quot;val&quot;:2},&quot;next…'>ref&quot;:&quot;4&quot;},&quot;val&quot;:2},&quot;next&quot;:null,&quot;right&quot;:{&quot;</span>ref&quot;:&quot;7&quot;},&quot;val&quot;:1}<br>
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。 <br>
提示：<br>
你只能使用常量级额外空间。<br>
使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<pre><code>class Solution {
public:
    vector&lt;Node*&gt; vn;
    Node* connect(Node* root) {
        preorder(root,0);
        return root;
    }
    
    void preorder(Node *cur,int i){
        if(cur==NULL)
            return;
        if(vn.size()==i)
            vn.push_back(cur);
        else{
            vn[i]-&gt;next=cur;
            vn[i]=cur;
        }
        preorder(cur-&gt;left,i+1);
        preorder(cur-&gt;right,i+1);
        return;
    }
};
</code></pre>
<p>我一开始只想到了层次遍历，参考层次遍历，利用先序遍历和vector的话可以按照从左到右的顺序来保存层次遍历的结果，由于我们只需要和前一个节点链接，所以这一次只需要一层vector&lt;Node*&gt;就好<br>
然后重点主要是push_back的判断和每个节点和前一个节点链接并更新vector<br>
唯一的缺点就是我这个vector不是常量空间<br>
看了题解，非常优雅啊！直接处理子树的链接和相邻子树的链接，值得学习</p>
<p>看看网友题解</p>
<pre><code>    Node* connect(Node* root) {
        if (!root) return root;
        Node * left = root-&gt;left;
        Node * right = root-&gt;right;
        while(left) {
            left-&gt;next = right;
            left = left-&gt;right;
            right = right-&gt;left;
        }
        connect(root-&gt;left);
        connect(root-&gt;right);
        return root;
    }
</code></pre>
<p>主要就是把完美二叉树劈成两半，先处理大的两半二叉树中间的左右连接，然后递归处理小的连接</p>
<p>非递归方法</p>
<pre><code>Node* connect(Node* root) {
    if (root == nullptr)return nullptr;
	if (root-&gt;left == nullptr) return root; 
    else 
    {
        root-&gt;left-&gt;next = root-&gt;right;
    }
	Node* cur = root-&gt;left-&gt;left;
	Node* pre = root-&gt;left;
	while (cur!=nullptr)
	{
		while (pre!=nullptr)
		{
			pre-&gt;left-&gt;next = pre-&gt;right;
			if (pre-&gt;next != nullptr)pre-&gt;right-&gt;next = pre-&gt;next-&gt;left;
			else pre-&gt;right-&gt;next = nullptr;
			pre = pre-&gt;next;
		}
		pre = cur;
		cur = cur-&gt;left;
	}
	return root;
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 99. 恢复二叉搜索树[困难]]]></title>
        <id>https://lixin-ee.github.io//post/shu-99-hui-fu-er-cha-sou-suo-shu-kun-nan</id>
        <link href="https://lixin-ee.github.io//post/shu-99-hui-fu-er-cha-sou-suo-shu-kun-nan">
        </link>
        <updated>2019-12-03T01:30:05.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>二叉搜索树中的两个节点被错误地交换。<br>
请在不改变其结构的情况下，恢复这棵树。<br>
示例 1:<br>
输入: [1,3,null,null,2]<br>
   1<br>
  /<br>
 3<br>
  <br>
   2<br>
输出: [3,1,null,null,2]<br>
   3<br>
  /<br>
 1<br>
  <br>
   2<br>
示例 2:<br>
输入: [3,1,4,null,null,2]<br>
3<br>
/ <br>
1   4<br>
   /<br>
  2<br>
输出: [2,1,4,null,null,3]<br>
2<br>
/ <br>
1   4<br>
   /<br>
 3<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/recover-binary-search-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<pre><code>class Solution {
public:
    TreeNode *tempnode,*tempnode1,*tempnode2;
    void recoverTree(TreeNode* root){
        inorder(root);
        swap(tempnode1-&gt;val,tempnode2-&gt;val);
        return;
    }
    
    void inorder(TreeNode* cur)    
    {
        if(cur==NULL)
            return;
        inorder(cur-&gt;left);
        if(tempnode&amp;&amp;cur-&gt;val&lt;tempnode-&gt;val){
            if(tempnode1==NULL)
                tempnode1=tempnode;
            tempnode2=cur;
        }
        tempnode=cur;
        inorder(cur-&gt;right);
        return;
    }
};
</code></pre>
<p>1.一开始想着使用中序遍历的vector来交换两个点，但是思路不太对，我的想法是找到后一个值比前一个值小的时候就互换，但是是不对的。比如序列 3，2，1应该交换3和1，但是我的思路会交换3和2，所以应该找到最后一个矛盾点<br>
2.通过草稿纸演算，我发现一般来说会出现一到两个点的矛盾点（亦即前一个值大于后一个值），我打算保存两个指针值然后交换值<br>
3.这下又被坏习惯坑了，比如 TreeNode* temp1,temp2; 其实*号的位置很重要，这样子的话temp2被定义为TreeNode而是相应的指针<br>
4.终于通过了，主要注意的点是需要保存两个异常值，同时更新异常值的方式很重要，因为可能出现相邻互换的情况，所以第一个异常值指针只需要赋值一次，第二个异常指针值就需要赋值两次<br>
5.看了题解之后发现值得优化的点是因为必须保存前一个指针用于保存第一个异常值，所以完全可以用这个指针来得到pre-&gt;val，而不需要一个全局int<br>
6.更改后，直接 99.67%和100%，吓到我了</p>
<p>然后看一下网友题解</p>
<blockquote>
<p>思路:<br>
这道题难点,是找到那两个交换节点,把它交换过来就行了.<br>
这里我们二叉树搜索树的中序遍历(中序遍历遍历元素是递增的)<br>
如下图所示, 中序遍历顺序是 4,2,3,1,我们只要找到节点4和节点1交换顺序即可!<br>
这里我们有个规律发现这两个节点:<br>
第一个节点,是第一个按照中序遍历时候前一个节点大于后一个节点,我们选取前一个节点,这里指节点4;<br>
第二个节点,是在第一个节点找到之后, 后面出现前一个节点大于后一个节点,我们选择后一个节点,这里指节点1;<br>
对于中序遍历,我们有两种方法.<br>
方法一: 迭代<br>
java</p>
</blockquote>
<pre><code>class Solution {
    public void recoverTree(TreeNode root) {
        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();
        TreeNode firstNode = null;
        TreeNode secondNode = null;
        TreeNode pre = new TreeNode(Integer.MIN_VALUE);
        TreeNode p = root;
        while (p != null || !stack.isEmpty()) {
            while (p != null) {
                stack.push(p);
                p = p.left;
            }
            p = stack.pop();
            if (firstNode == null &amp;&amp; pre.val &gt; p.val) firstNode = pre;
            if (firstNode != null &amp;&amp; pre.val &gt; p.val) secondNode = p;
            pre = p;
            p = p.right;
        }
        int tmp = firstNode.val;
        firstNode.val = secondNode.val;
        secondNode.val = tmp;
    }
}
</code></pre>
<blockquote>
<p>方法二: 递归</p>
</blockquote>
<pre><code>java
class Solution {
    TreeNode firstNode = null;
    TreeNode secondNode = null;
    TreeNode preNode = new TreeNode(Integer.MIN_VALUE);

    public void recoverTree(TreeNode root) {

        in_order(root);
        int tmp = firstNode.val;
        firstNode.val = secondNode.val;
        secondNode.val = tmp;
    }

    private void in_order(TreeNode root) {
        if (root == null) return;
        in_order(root.left);
        if (firstNode == null &amp;&amp; preNode.val &gt; root.val) firstNode = preNode;
        if (firstNode != null &amp;&amp; preNode.val &gt; root.val) secondNode = root;
        preNode = root;
        in_order(root.right);
    }
}
</code></pre>
<p>这位网友的思路和我的一致</p>
<blockquote>
<p>然后来看看其他解法：<br>
解法一 递归<br>
和 98 题有些像。这里的思路如下：<br>
让我们来考虑交换的位置的可能：<br>
根节点和左子树的某个数字交换 -&gt; 由于根节点大于左子树中的所有数，所以交换后我们只要找左子树中最大的那个数，就是所交换的那个数<br>
根节点和右子树的某个数字交换 -&gt; 由于根节点小于右子树中的所有数，所以交换后我们只要在右子树中最小的那个数，就是所交换的那个数<br>
左子树和右子树的两个数字交换 -&gt; 找左子树中最大的数，右子树中最小的数，即对应两个交换的数<br>
左子树中的两个数字交换<br>
右子树中的两个数字交换<br>
思想有了，代码很好写了。</p>
</blockquote>
<pre><code>public void recoverTree2(TreeNode root) {
    if (root == null) {
        return;
    }
    //寻找左子树中最大的节点
    TreeNode maxLeft = getMaxOfBST(root.left);
    //寻找右子树中最小的节点
    TreeNode minRight = getMinOfBST(root.right);
    
    if (minRight != null &amp;&amp; maxLeft != null) {
        //左边的大于根节点，右边的小于根节点，对应情况 3，左右子树中的两个数字交换
        if ( maxLeft.val &gt; root.val &amp;&amp; minRight.val &lt; root.val) {
            int temp = minRight.val;
            minRight.val = maxLeft.val;
            maxLeft.val = temp;
        }
    }

    if (maxLeft != null) {
        //左边最大的大于根节点，对应情况 1，根节点和左子树的某个数做了交换
        if (maxLeft.val &gt; root.val) {
            int temp = maxLeft.val;
            maxLeft.val = root.val;
            root.val = temp;
        }
    }

    if (minRight != null) {
        //右边最小的小于根节点，对应情况 2，根节点和右子树的某个数做了交换
        if (minRight.val &lt; root.val) {
            int temp = minRight.val;
						minRight.val = root.val;
            root.val = temp;
        }
    }
    //对应情况 4，左子树中的两个数进行了交换
    recoverTree(root.left);
    //对应情况 5，右子树中的两个数进行了交换
    recoverTree(root.right);

}
//寻找树中最小的节点
private TreeNode getMinOfBST(TreeNode root) {
    if (root == null) {
        return null;
    }
    TreeNode minLeft = getMinOfBST(root.left);
    TreeNode minRight = getMinOfBST(root.right);
    TreeNode min = root;
    if (minLeft != null &amp;&amp; min.val &gt; minLeft.val) {
        min = minLeft;
    }
    if (minRight != null &amp;&amp; min.val &gt; minRight.val) {
        min = minRight;
    }
    return min;
}

//寻找树中最大的节点
private TreeNode getMaxOfBST(TreeNode root) {
    if (root == null) {
        return null;
    }
    TreeNode maxLeft = getMaxOfBST(root.left);
    TreeNode maxRight = getMaxOfBST(root.right);
    TreeNode max = root;
    if (maxLeft != null &amp;&amp; max.val &lt; maxLeft.val) {
        max = maxLeft;
    }
    if (maxRight != null &amp;&amp; max.val &lt; maxRight.val) {
        max = maxRight;
    }
    return max;
}
</code></pre>
<p>然后是空间复杂度为O（1）的莫里斯遍历</p>
<blockquote>
<p>Morris 版中序遍历<br>
因为之前这个方法中用了 pre 变量，为了方便，这里也需要 pre 变量，我们用 pre_new 代替。具体 Morris 遍历算法参见 94 题 。利用 Morris 的话，我们的空间复杂度终于达到了 O（1）。</p>
</blockquote>
<pre><code>public void recoverTree(TreeNode root) {
    TreeNode first = null;
    TreeNode second = null;
    TreeNode cur = root;
    TreeNode pre_new = null;
    while (cur != null) {
        // 情况 1
        if (cur.left == null) {
            /*******************************************************/
            if (pre_new != null &amp;&amp; cur.val &lt; pre_new.val) {
                if (first == null) {
                    first = pre_new;
                    second = cur;
                } else {
                    second = cur;
                }
            }
            pre_new = cur;
            /*******************************************************/
            cur = cur.right;
        } else {
            // 找左子树最右边的节点
            TreeNode pre = cur.left;
            while (pre.right != null &amp;&amp; pre.right != cur) {
                pre = pre.right;
            }
            // 情况 2.1
            if (pre.right == null) {
                pre.right = cur;
                cur = cur.left;
            }
           // 情况 2.2
            if (pre.right == cur) {
                pre.right = null; // 这里可以恢复为 null
                /*******************************************************/
                if (pre_new != null &amp;&amp; cur.val &lt; pre_new.val) {
                    if (first == null) {
                        first = pre_new;
                        second = cur;
                    } else {
                        second = cur;
                    }
                }
                pre_new = cur;
                /*******************************************************/
                cur = cur.right;
            }
        }
    }
    
    int temp = first.val;
    first.val = second.val;
    second.val = temp;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 297. 二叉树的序列化与反序列化[困难][未做出]]]></title>
        <id>https://lixin-ee.github.io//post/shu-297-er-cha-shu-de-xu-lie-hua-yu-fan-xu-lie-hua-kun-nan</id>
        <link href="https://lixin-ee.github.io//post/shu-297-er-cha-shu-de-xu-lie-hua-yu-fan-xu-lie-hua-kun-nan">
        </link>
        <updated>2019-12-02T07:21:48.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。<br>
请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。<br>
示例: <br>
你可以将以下二叉树：<br>
1<br>
/ <br>
2   3<br>
/ <br>
4   5<br>
序列化为 &quot;[1,2,3,null,null,4,5]&quot;<br>
提示: 这与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。<br>
说明: 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题可以说是很曲折了<br>
1.一开始以为层次遍历比较好，但是看了一下题解发现还是先序遍历比较方便，因为可以按照string至今进行链接，而层次遍历需要一个队列来保存<br>
2.题解中的大佬用了ostringstream和istringstream，很方便，很值得学习。<br>
3.然后我就在上述两个stream中翻了车，一开始是哈皮了，忘了string的push_back要求的是单引号的字符变量‘#’而不是直接string，所以“#”和to_string都是没法用pushback的，只能用加号或者单引号。另一个就是ostringstream是有格式的，所以必须用空格隔开将连续的数字隔开，否则会连起来stoi会输出一个超级大的数字（但是似乎允许123#123这种形式，并输出 “123” “#” “123”三者）<br>
4.剩下的就是stream的使用了吧，dalao的思维还是很厉害的。<br>
5.还有的话就是理解一下先序遍历为何可以重建二叉树（等等！大话数据结构里面不是说建树和遍历只需要改一下相应的就好嘛hhh，确认了！！快回去复习大话数据结构！！！就在6.9节）</p>
<p>代码如下：</p>
<pre><code>class Codec {
public:
   /*string serialize(TreeNode* root) {
        ostringstream out;
        serialize(root,out);
        return out.str();
    }*/

    /*void serialize(TreeNode* root,ostringstream&amp; out){
        if(root){
            out&lt;&lt;root-&gt;val&lt;&lt;' ';
            serialize(root-&gt;left,out);
            serialize(root-&gt;right,out);
        }else{
            out&lt;&lt;&quot;# &quot;;
        }
        
    }*/
    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        string s;
        serialize(root,s);
        return s;
    }

    void serialize(TreeNode *cur,string &amp;s){
        s.push_back(' ');
        if(cur==NULL){
            s.push_back('#');
            return;
        }
        s+=to_string(cur-&gt;val);
        serialize(cur-&gt;left,s);
        serialize(cur-&gt;right,s);
    } 

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        istringstream is(data);
        return deserialize(is);
    }

    TreeNode* deserialize(istringstream &amp;is){
        string val;
        is&gt;&gt;val;
        if(val==&quot;#&quot;)
         return NULL;
        
        TreeNode* cur=new TreeNode(stoi(val));
       cur-&gt;left=deserialize(is);
        cur-&gt;right=deserialize(is);
        return cur;
    }

    /*TreeNode* deserialize(istringstream&amp; in){
        string val;
        in&gt;&gt;val;
        if(val==&quot;#&quot;){
            return nullptr;
        }
        TreeNode* root=new TreeNode(stoi(val));
        root-&gt;left=deserialize(in);
        root-&gt;right=deserialize(in);
        return root;
    }*/

};

// Your Codec object will be instantiated and called as such:
// Codec codec;
// codec.deserialize(codec.serialize(root));
</code></pre>
<p>然后来看大佬的题解吧</p>
<blockquote>
<p>解法一 先序遍历法<br>
先序遍历二叉树时，将节点输出。<br>
重点是碰到NULL时，也要将其用#标识并输出。NULL节点虽然不是数字，但是能决定二叉树的结构。没有NULL节点，单靠先序序列是无法恢复成树的。<br>
节点与节点之间用空格隔开。<br>
例如：<br>
1<br>
/ <br>
2   3<br>
/ <br>
4   5<br>
其序列化后为， 1 2 # # 3 4 # # 5 # #<br>
可以发现，#标识的NULL节点，紧跟在其父节点的后面。</p>
</blockquote>
<pre><code>    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        if(!root) return string();
        stringstream ss;
        dfs(root,ss);
        return ss.str();
    }
    
    void dfs(TreeNode* rt,stringstream&amp; ss){
        if(!rt){
            ss &lt;&lt; &quot;# &quot;;
            return ;
        }
        ss &lt;&lt; to_string(rt-&gt;val) &lt;&lt;&quot; &quot;;
        dfs(rt-&gt;left,ss);
        dfs(rt-&gt;right,ss);
    }
</code></pre>
<blockquote>
<p>重建时，思路很清晰。<br>
先重建根节点，如果是NULL节点，返回。如果是数字节点，递归重建左子树。之后，再重建右子树。</p>
</blockquote>
<pre><code>void rebuild(TreeNode* &amp; rt,stringstream&amp; ss){
		string t;
		ss &gt;&gt; t;
		if(t[0] == '#'){
				rt = NULL;
				return;
		}
		int v = stoi(t);
		rt = new TreeNode(v);
		rebuild(rt-&gt;left,ss);
		rebuild(rt-&gt;right,ss);
}

// Decodes your encoded data to tree.
TreeNode* deserialize(string data) {
		if(data.empty()) return NULL;
		TreeNode* rt = NULL;
		stringstream ss(data);
		rebuild(rt,ss);
		return rt;
}
</code></pre>
<blockquote>
<p>解法二 层次遍历法<br>
层次遍历也能序列化。在序列化时，遇到NULL节点时，也要输出为#。<br>
用队列设计层次遍历。</p>
</blockquote>
<pre><code>	string serialize(TreeNode* root) {
			if(!root) return &quot;&quot;;
			stringstream ss;
			queue&lt;TreeNode*&gt; Q;
			Q.push(root);
			while(Q.size()){
					TreeNode* p = Q.front();Q.pop();
					if(!p) ss &lt;&lt;&quot;# &quot;;
					else{
							ss &lt;&lt; p-&gt;val &lt;&lt;&quot; &quot;;
							Q.push(p-&gt;left);
							Q.push(p-&gt;right);
					}
			}
			return ss.str();
	}
</code></pre>
<blockquote>
<p>难点在于层次遍历的反序列化。不容易想清楚重建的顺序应该是怎么样的。<br>
1<br>
/ <br>
2   3<br>
/ <br>
4   5<br>
序列化后， 1 2 3 # # 4 5 # # # # 。<br>
第一个节点是1，是根节点。但是还未完成，其还有两个子节点。<br>
此时，只能将存入队列。<br>
接着是2，其是1的左子节点。<br>
接着是3，其是1的右子节点。<br>
可以看出，除了根节点，后面的节点必须成对出现，且第一个是某节点的左子节点，第二个是其右子节点。<br>
同样，2和3的子节点也还没有出现，同样要先入队列。</p>
</blockquote>
<pre><code>TreeNode* deserialize(string data) {
		if(data.empty()) return NULL;
		stringstream ss(data);
		string t;
		ss &gt;&gt; t;
		TreeNode* rt = new TreeNode(stoi(t));
		queue&lt;TreeNode*&gt; Q;
		Q.push(rt);
		while(Q.size()){
				TreeNode* p = Q.front();Q.pop();
				ss &gt;&gt; t;
				if(t[0] == '#'){
						p-&gt;left = NULL;
				}else{
						p-&gt;left = new TreeNode(stoi(t));
						Q.push(p-&gt;left);
				}
				ss &gt;&gt; t;
				if(t[0] == '#'){
						p-&gt;right = NULL;
				}else{
						p-&gt;right = new TreeNode(stoi(t));
						Q.push(p-&gt;right);
				}
		}
		return rt;
}
</code></pre>
<p>另一位C++大佬的题解，没有解析</p>
<pre><code>class Codec {
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        ostringstream out;
        serialize(root,out);
        return out.str();
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        istringstream in(data);
        return deserialize(in);
    }
private:
    void serialize(TreeNode* root,ostringstream&amp; out){
        if(root){
            out&lt;&lt;root-&gt;val&lt;&lt;' ';
            serialize(root-&gt;left,out);
            serialize(root-&gt;right,out);
        }else{
            out&lt;&lt;&quot;# &quot;;
        }
        
    }
    TreeNode* deserialize(istringstream&amp; in){
        string val;
        in&gt;&gt;val;
        if(val==&quot;#&quot;){
            return nullptr;
        }
        TreeNode* root=new TreeNode(stoi(val));
        root-&gt;left=deserialize(in);
        root-&gt;right=deserialize(in);
        return root;
    }
};
</code></pre>
<p>官方题解的解析：<br>
<img src="https://lixin-ee.github.io//post-images/1575272094124.png" alt=""><br>
其中机翻错误加泰罗尼亚语的数字==卡特兰数</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++primer 目录与链接]]></title>
        <id>https://lixin-ee.github.io//post/cprimer-mu-lu-yu-lian-jie</id>
        <link href="https://lixin-ee.github.io//post/cprimer-mu-lu-yu-lian-jie">
        </link>
        <updated>2019-11-30T13:43:48.000Z</updated>
        <content type="html"><![CDATA[<p>今晚在做算法题的时候想看一下pair的性质，结果发现按照章节不好找啊！，打算按照文字化目录来完成这篇文章</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ C++ primer 第十八章 笔记+习题 19.7-19.8]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-ba-zhang-bi-ji-xi-ti-197-198</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-ba-zhang-bi-ji-xi-ti-197-198">
        </link>
        <updated>2019-11-30T13:18:03.000Z</updated>
        <content type="html"><![CDATA[<p>19.7局部类<br>
<strong>类</strong>可以<strong>定义在某个函数的内部</strong>，我们称这样的类为<strong>局部类(local class)</strong>。局部类定义的类型<strong>只在定义它的作用域内可见</strong>。和嵌套类不同，局部类的成员受到严格限制。<br>
局部类的<strong>所有成员</strong>（<strong>包括函数</strong>在内）都<strong>必须完整定义在类的内部</strong>。因此，局部类的作用与嵌套类相比相差很远。<br>
复杂性不可能太高。局部类的成员函数一般只有几行代码，否则我们就很难读懂它了。<br>
类似的，在局部类中<strong>也不允许声明静态数据成员</strong>，因为我们<strong>没法定义</strong>这样的成员。<br>
<strong>静态成员必须定义在外部</strong><br>
局部类不能使用函数作用域中的变量<br>
局部类<strong>对其外层作用域中名字</strong>的<strong>访问权限受到很多限制</strong>，局部类只<strong>能访问外层作用域</strong>定义的<strong>类型名</strong>、<strong>静态变量</strong>（参见6.1.1节，第185页）以及<strong>枚举成员</strong>。如果局部类定义在某个函数内部，则该函数的<strong>普通局部变量不能被该局部类使用</strong>：</p>
<p><strong>常规的访问保护规则对局部类同样适用</strong><br>
外层函数对局部类的私有成员没有任何访问特权。当然，局部类可以将外层函数声明为友元；或者更常见的情况是局部类将其成员声明成公有的。在程序中有权访问局部类的代码非常有限。局部类已经封装在函数作用域中，通过信息隐藏进一步封装就显得没什么必要了。<br>
局部类中的名字查找<br>
局部类内部的名字查找次序与其他类相似。在<strong>声明类的成员</strong>时，<strong>必须先确保</strong>用到的名<br>
字<strong>位于作用域中</strong>，然后再使用该名字。<strong>定义成员时</strong>用到的名字可以出现在<strong>类的任意位置</strong>。<br>
如果<strong>某个名字不是局部类的成员</strong>，则<strong>继续在外层函数作用域中查找</strong>；如果<strong>还没有找到</strong>，则在<strong>在外层函数所在的作用域中查找</strong>。</p>
<p>嵌套的局部类<br>
可以在<strong>局部类的内部再嵌套一个类</strong>。此时，<strong>嵌套类的定义</strong>可以<strong>出现在局部类之外</strong>。不过，嵌套类<strong>必须定义</strong>在与局部类<strong>相同的作用域</strong>中。</p>
<p><strong>局部类内的嵌套类</strong>也是一个<strong>局部类</strong>，必须遵循局部类的各种规定。<strong>嵌套类的所有成员都必须定义在嵌套类内部</strong>。</p>
<p>19.8 固有的不可移植的特性<br>
为了<strong>支持低层编程</strong>，C++定义了一些<strong>固有的不可移植</strong>（nonportable)的<strong>特性</strong>。所谓不可移植的特性是<strong>指因机器而异的特性</strong>，当我们将含有不可移植特性的程序从一台机器转移到另一台机器上时，通常需要重新编写该程序。算术类型的大小在不同机器上不一样（参见2.1.1节，第30页），这是我们使用过的不可移植特性的一个典型示例。<br>
本节将介绍C++从C语言继承而来的另外两种不可移植的特性：位域和volatile限定符。此外，我们还将介绍链接指示，它是C++新増的一种不可移植的特性。</p>
<p>19.8.1 位域<br>
<strong>类</strong>可以将其（非静态）<strong>数据成员定义成位域</strong>（bit-field),在一个位域中<strong>含有一定数量的二进制位</strong>。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。<br>
位域在内存中的布局是与机器相关的。<br>
<strong>位域的类型</strong>必须是<strong>整型或枚举类型</strong>（参见19.3节，第736页）。因为带符号位域的行为是由具体实现确定的，所以在通常情况下我们使用<strong>无符号类型保存一个位域</strong>。位域的<strong>声明形式</strong>是在<strong>成员名字之后</strong>紧跟<strong>一个冒号</strong>以及<strong>一个常量表达式</strong>，该<strong>表达式用于指定</strong>成员<strong>所占的二进制位数</strong>：</p>
<p><strong>取地址运算符（&amp;）不能作用于位域</strong>，因此<strong>任何指针都无法指向类的位域</strong>。<br>
通常情况下最好将位域设为无符号类型，存储在带符号类型中的位域的行为将因具体实现而定。</p>
<p>19.8.2 volatile限定符<br>
<strong>volatile的确切含义与机器有关</strong>，只能通过阅读编译器文档来理解。要想让使用了volatile的程序在移植到新机器或新编译器后仍然有效，通常需要对该程序进行某些改变<br>
直接处理硬件的程序常常包含这样的数据元素，它们的值由程序直接控制之外的过程 控制。例如，程序可能包含一个由系统时钟定时更新的变量。当<strong>对象的值可能在程序的控制或检测之外被改变时，应该将该对象声明为volatile关键字</strong>。<strong>volatile告诉编译器不应对这样的对象进行优化</strong>。<br>
volatile限定符的用法和const很相似，它起到<strong>对类型额外修饰</strong>的作用:</p>
<p>在volatile限定符和指针之间也存在类似的关系。</p>
<p>合成的拷贝对volatile对象无效<br>
const和volatile的一个重要区别是我们<strong>不能使用合成的拷贝/移动构造函数及赋值运算符初始化volatile对象或从volatile对象赋值</strong>。<strong>合成的成员接受的形参类型是（非volatile)常量引用</strong>，显然我们不能把一个非volatile引用绑定到一个volatile对象上。<br>
<strong>如果一个类希望拷贝、移动或赋值</strong>它的volatile对象，则该<strong>类必须自定义拷贝或移动操作</strong>。</p>
<p>19.8.3链接指示：extern&quot;C&quot;<br>
C++使用链接指示（linkage directive)指出<strong>任意非C++函数所用的语言</strong>。<br>
要想把<strong>C++代码和其他语言</strong>（包括C语言）编写的代码放在一起使用，要求我们<strong>必须有权访问该语言的编译器</strong>，并且这个编译器与当前的C++编译器是兼容的</p>
<p>声明一个非C++的函数<br>
<strong>链接指示</strong>可以有两种形式：<strong>单个的或复合的</strong>。链接指示<strong>不能出现在类定义或函数定义的内部</strong>。同样的链接指示<strong>必须在函数的每个声明中都出现</strong>。<br>
链接指示的第一种形式包含一个<strong>关键字extern</strong>.后面是一个<strong>字符串字面值常量</strong>以及一个 <strong>&quot;普通的&quot;函数声明</strong>。<br>
其中的<strong>字符串字面值常量指出了编写函数所用的语言</strong>。编译器应该支持对C语言的链 接指示。此外，编译器也可能会支持其他语言的链接指示，如extern&quot;Ada&quot;、extern &quot;FORTRAN&quot;等。</p>
<p>链接指示与头文件<br>
我们可以令链接指示后面跟上<strong>花括号括起来的若干函数的声明</strong>，从而<strong>一次性建立多个 链接</strong>。花括号的作用是将适用于该链接指示的多个声明聚合在一起，否则花括号就会被忽 略，花括号中声明的函数名字就是可见的，就好像在花括号之外声明的一样。</p>
<p>当一个**#include指示<strong>被放置在复合链接指示的</strong>花括号<strong>中时，<strong>头文件中的所有普通函数声明</strong>都被认为是</strong>由链接指示的语言编写的**。<strong>链接指示可以嵌套</strong>，因此如果头文件包含带自带链接指示的函数，则该函数的链接不受影响。<br>
C++从C语言继承的标准库函数可定义成C函数，但并非必须：决定使用还是C++实现C标准库，是毎个C++实现的事情。</p>
<p>指向extern&quot;C&quot;函数的指针<br>
<strong>编写函数所用的语言是函数类型的一部分</strong>。因此，对于使用链接指示定义的函数来说，<strong>它的每个声明都必须使用相同的链接指示</strong>。而且，<strong>指向</strong>其他语言编写的<strong>函数的指针</strong>必须与函数本身<strong>使用相同的链接指示</strong>：<br>
//pf指向一个C函数，该函数接受一个int返回void<br>
<code>extern&quot;C&quot;void(*pf)(int);</code><br>
当我们使用pf调用函数时，编详器认定当前调用的是一个c函数。<br>
<strong>指向C函数的指针</strong>与指向C++函数的指针是<strong>不一样的类型</strong>。一个指向C函数的指针<strong>不能用在执行初始化或赋值操作后指向C++函数</strong>，反之亦然。就像其他类型不匹配的问题一样，如果我们试图在两个链接指示不同的指针之间进行赋值操作，则程序将发生错误：</p>
<p>链接指示对整个声明都有效<br>
当我们使用链接指示时，它不仅对函数有效，而且对作为<strong>返回类型</strong>或<strong>形参类型</strong>的<strong>函数指针也有效</strong>：</p>
<p>因为链接指示同时作用于声明语句中的所有函数，所以如果我们<strong>希望给C++函数传入</strong>一个<strong>指向C函数的指针</strong>，则<strong>必须使用类型别名</strong><br>
导出C++函数到其他语言<br>
通过使用链接指示对函数进行定义，我们可以令一个C++函数在其他语言编写的程序 中可用：<br>
//calc函数可以被C程序调用<br>
extern &quot;C&quot; double calc(double dparm){/<em>...</em>/}<br>
编译器将为该函数生成适合于指定语言的代码。<br>
值得注意的是，<strong>可被多种语言共享</strong>的函数的<strong>返回类型或形参类型</strong>受到<strong>很多限制</strong>。</p>
<p>重载函数与链接指示<br>
<strong>链接指示与重载函数</strong>的相互作用<strong>依赖于目标语言</strong>。<strong>如果目标语言支持重载函数</strong>，则为 该语言实现链接指示的编编译<strong>很可能也支持重载</strong>这些C++的函数。<br>
C语言不支持函数重载，因此也就不难理解为什么一个C链接指示只能用于说明一组重载函数中的某一个了：</p>
<p>习题19.26<br>
不合法，两函数名字相同，但c语言不支持函数重载<br>
答案肯定是不合法，在这里我想给出我找到的原因： 主要原因是两种语言对函数的编译结果有差异。 比如一个函数的声明如下： void function(int x,int y)； 在c语言中，编译器在编译后在库中的名字_function 在c++中，编译器在编译后在库中的名字_function_int_int 如果还有一个函数的声明如下： void function（float x,float y)； 在c语言中，编译器在编译后在库中的名字为_function。而在c++中，编译器在编译后在库中的名字为_function_float_float。在链接时，都是找名字进行链接的,就比如以上两个函数，在C语言中两个的名字一样，就会在链接中报错。C++中它们的名字不一样，所以就不会报错。C语言这种编译的机制，导致了它不支持函数重载。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ C++ primer 第十八章 笔记+习题 19.5-19.6]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-ba-zhang-bi-ji-xi-ti-193-194</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-ba-zhang-bi-ji-xi-ti-193-194">
        </link>
        <updated>2019-11-30T03:03:27.000Z</updated>
        <content type="html"><![CDATA[<p>19.5 嵌套类<br>
<strong>一个类</strong>可以<strong>定义</strong>在<strong>另一个类的内部</strong>，前者称为嵌套类（nested class)或嵌套类型（nested type)。<strong>嵌套类</strong>常用于<strong>定义作为实现部分的类</strong>，<br>
嵌套类是一个<strong>独立的类</strong>，<strong>与外层类基本没什么关系</strong>。特别是，外层类的对象和嵌套类的<strong>对象是相互独立的</strong>。在嵌套类的对象中不包含任何外层类定义的成员，类似的，在外层类的对象中也不包含任何嵌套类定义的成员。<br>
<strong>嵌套类的名字在外层类作用域中是可见的</strong>，在<strong>外层类作用域之外不可见</strong>。和其他嵌套的名字一样，嵌査类的名字不会和别的作用域中的同一个名字冲突。</p>
<p>声明一个嵌套类</p>
<p>在外层类之外定义一个嵌套类<br>
我们在TextQuery内声明了Query Result,但是没有给出它的定义。和成员函数一样，嵌套类必须<strong>声明在类的内部</strong>，但是可<strong>定义在类的内部或者外部</strong>。</p>
<p>定义嵌套类的成员<br>
在这个版本的QueryResult类中，我们并没有在类的内部<strong>定义其构造函数</strong>。要想为其定义构造函数，必须指明如QueryResult是嵌套在TextQuery的作用域之内的。具体做法是使<strong>用外层类的名字限定嵌套类的名字</strong>；</p>
<p>嵌套类的静态成员定义<br>
<strong>静态成员的定义必须为于类之外，因为静态成语属于类，而不属于某个对象，如果在类内定义，则每个对象定义时也会重新定义一次，不符合静态成员的要求</strong><br>
如果QueryResult<strong>声明了一个静态成员</strong>，则该成员的<strong>定义</strong>将位于TextQuery的<strong>作用域之外</strong></p>
<p>嵌套类作用域中的名字查找<br>
名字查找的一般规则（参见7.4.1节，第254页）在嵌套类中同样适用。当然，因为嵌套类本身是一个嵌套作用域，所以<strong>还必须查找嵌套类的外层作用域</strong>。这种作用域嵌套的性质正好可以说明为什么我们不在QueryResult的嵌套版本中定义line_no.<br>
如我们所知，嵌套类是其外层类的一个类型成员，因此<strong>外层类的成员</strong>可以像<strong>使用任何其他类型成员一样使用嵌套类的名字</strong>。</p>
<p>和过去一样，<strong>返回类型不在类的作用域中</strong>（参见7.4节，第253页）因此我们<strong>必须指明函数的返回值是TextQuery::QueryResult类型</strong>。不过在函数体内部我们可以直接访问QueryResult，比如上面的return语句就是这样。</p>
<p>嵌套类和外层类是相互独立的<br>
尽管嵌套类定义在其外层类的作用域中，但是读者必须谨记<strong>外层类的对象和嵌套类的对象没有任何关系</strong>。嵌套类的<strong>对象只包含嵌套类定义的成员</strong>：同样，外层类的<strong>对象只包含外层类定义的成员</strong>，在外层类对象中不会有任何嵌套类的成员。</p>
<p>习题19.20<br>
嵌套之后记得要在QueryResult的定义中加上TextQuery::</p>
<p>19.6 union:<strong>一种节省空间的类</strong><br>
联合（union)是一种特殊的类。一个union可以有多个数据成员，但是<strong>在任意时刻只有一个数据成员可以有值</strong>。当我们<strong>给union的某个成员赋值</strong>之后，该union的<strong>其他成员就变成未定义的状态</strong>了。分配给一个union对象的<strong>存储空间</strong>至少要<strong>能容纳它的最大的数据成员</strong>。和<strong>其他类一样</strong>，<strong>一个union定义了一种新类型</strong>。<br>
union<strong>不能含有引用类型的成员</strong><br>
<strong>含有构造函数 或析构函数的类类型</strong>也可以作为union的<strong>成员类型</strong>。union可以为其成员<strong>指定public、 protected和private等保护标记</strong>。默认情况下，<strong>union的成员都是公有的</strong>，这一点<strong>与struct相同</strong>。<br>
<strong>union可以定义</strong>包括构造函数和析构函数在内的<strong>成员函数</strong>。但是由于union<strong>既不能继承自其他类</strong>，<strong>也不能作为基类使用</strong>，所以<strong>在union中不能含有虚函数</strong>。</p>
<p>定义union<br>
union提供了一种有效的途径使得我们可以<strong>方便地表示一组类型不同的互斥值</strong>。</p>
<p>使用union类型<br>
union的名字是一个<strong>类型名</strong>。和其他内置类型一样，<strong>默认情况下union是未初始化的</strong>。我们可以像显式地初始化聚合类（参见7.5.5节，第266页）一样使用一对<strong>花括号</strong>内的<strong>初始值</strong>显式地<strong>初始化一个union</strong>：</p>
<p>我们使用通用的<strong>成员访问运算符（. 或者 -&gt;）</strong> 访问一个union对象的成员：<br>
last_token.cval = ‘z’;<br>
pt-&gt;ival = 42;<br>
为union的<strong>一个数据成员赋值</strong>会令<strong>其他数据成员变成未定义</strong>的状态。因此，当我们使用 union时，<strong>必须淸楚地知道当前存储在union中的值到底是什么类型</strong></p>
<p>匿名union<br>
<strong>匿名union</strong>(anonymous union)是一个<strong>未命名的union</strong>,并且在<strong>右花括号和分号之间没有任何声明</strong>（参见2.6.1节，第65页）。一旦我们<strong>定义了一个匿名union</strong>，编译器就<strong>自动地为该union创建一个未命名的对象</strong><br>
在匿名union的定义<strong>所在的作用域</strong>内该union的<strong>成员都是可以直接访问的</strong>。<br>
匿名union不<strong>能包含受保护的成员</strong>或<strong>私有成员</strong>，<strong>也不能定义成员函数</strong>。</p>
<p>含有类类型的union<br>
如果union的成员类型<strong>定义了自己</strong>的<strong>构造函数</strong>和/或<strong>拷贝控制成员</strong>，则该union的用法要比只含有内置类型成员的union<strong>复杂得多</strong>。</p>
<p><strong>例如string</strong><br>
使用类管理union成员<br>
对于union来说，要想构造或销毁类类型的成员必须执行非常复杂的操作，因此我们通常把<strong>含有类类型成员的union内嵌在另一个类当中</strong>。<strong>这个类</strong>可以<strong>管理并控制</strong>与<strong>union的类类型成员有关的状态转换</strong>。<br>
为了<strong>追踪union中</strong>到底<strong>存储了什么类型</strong>的值，我们通常会<strong>定义一个独立的对象</strong>，该对象称为<strong>union的判别式</strong>（discriminant)。我们可以使用判别式辨认union存储的值。为了保持union-与其判别式同步，我们将判别式也作为Token的成员。我们的类将定义一个<strong>枚举类型</strong>（参见19.3节，第736页）的成员来追踪其union成员的状态。<br>
<strong>string不是内置类型，所以要有自己的析构函数</strong></p>
<p>管理判别式并销毁string</p>
<p>管理需要拷贝控制的联合成员<br>
和依赖于类型的赋值运算符一样，<strong>拷贝构造函数</strong>和<strong>赋值运算符</strong>也需要<strong>先检验判别式</strong>以 <strong>明确拷贝所采用的方式</strong></p>
<p>赋值运算符必须处理string成员的三种可能情况：左侧运算对象和右侧运算对象都是string、两个运算对象都不是string、只有一个运算对象是string：</p>
<p>习题19.21+22+23</p>
<pre><code>class Token {
public:
	Token() :tok(INT), ival(0) {}
	Token(const Token &amp;t) :tok(t.tok) { copyUnion(t); }
	Token(Token &amp;&amp;t) :tok(std::move(t.tok)) { moveUnion(std::move(t)); }
	Token &amp;operator=(const Token&amp;);
	Token &amp;operator=(Token&amp;&amp;) noexcept;
	~Token() { if (tok == STR) sval.~string(); }
	~Token() { if (tok == SALES) sales.~Sales_Data(); }
	Token &amp;operator=(const std::string&amp;);
	Token &amp;operator=(char);
	Token &amp;operator=(int);
	Token &amp;operator=(double);
	Token &amp;operator=(Sales_Data&amp;);

private:
	enum {INT,CHAR,DBL,STR,SALES} tok;
	union {
		char cval;
		int ival;
		double dval;
		std::string sval;
		Sales_Data sales;
	};
	void copyUnion(const Token&amp;);
	void moveUnion(Token &amp;&amp;);
	void free() {
		if (tok == STR)
			sval.std::string::~string();
		if (tok == SALES)
			sales.~Sales_Data();
	}
};

Token &amp;Token::operator=(int i) {
	if (tok == STR)
		sval.~string();
	if (tok == SALES) 
		sales.~Sales_Data();
	ival = i;
	tok = INT;
	return *this;
}

Token &amp;Token::operator=(const std::string &amp;s) {
	if (tok == STR) 
		sval=s;
	else 
		new(&amp;sval) std::string(s);
	tok = STR;
	return *this;
}

Token &amp;Token::operator=(Sales_Data&amp; sd) {
	if (tok == SALES)
		sales=sd;
	else
		new(&amp;sales) Sales_Data(sd);
	tok = SALES;
	return *this;
}

void Token::copyUnion(const Token &amp;t) {
	switch (t.tok)
	{
	case Token::INT: ival = t.ival; break;
	case Token::CHAR: cval = t.ival; break;
	case Token::DBL: dval = t.ival; break;
	case Token::STR: new(&amp;sval) std::string(t.sval); break;
	case Token::SALES:new(&amp;sales) Sales_Data(t.sales); break;
	default:
		break;
	}
}

Token &amp;Token::operator=(const Token &amp;t) {
	if (tok == STR&amp;&amp;t.tok != STR) sval.~string();
	if (tok == SALES&amp;&amp;t.tok != SALES) sales.~Sales_Data();
	if (tok == STR&amp;&amp;t.tok == STR)
		sval = t.sval;
	else if (tok == SALES&amp;&amp;t.tok == SALES) 
		sales=t.sales;
	else
		copyUnion(t);
	tok = t.tok;
	return *this;
}

void Token::moveUnion(Token &amp;&amp;t) {
	switch (t.tok) {
	case INT:
		ival = std::move(t.ival);
		break;
	case CHAR:
		cval = std::move(t.cval);
		break;
	case DBL:
		dval = std::move(t.dval);
		break;
	case STR:
		new(&amp;sval) std::string(std::move(t.sval));
		break;
	case SALES:
		new(&amp;sales) Sales_Data(std::move(t.sales));
		break;
	}
}
Token &amp;Token::operator=(Token&amp;&amp; t) {
	if (this != &amp;t) {
		free();
		moveUnion(std::move(t));
		tok = std::move(t.tok);
	}
	return *this;
}

Token &amp;Token::operator=(char c) {
	free();
	cval = c;
	tok = CHAR;
	return *this;
}
Token &amp;Token::operator=(int i) {
	free();
	ival = i;
	tok = INT;
	return *this;
}
Token &amp;Token::operator=(double d) {
	free();
	dval = d;
	tok = DBL;
	return *this;
}
</code></pre>
<p>注意：移动构造函数和移动拷贝函数其实主要针对的是指针、引用和能够移动的类类型数据成员（比如），而不是内置类型的成员，像string就有自己的移动成员，就值得去移动，像int、double都是无法移动的，所以使用move与否都一样</p>
<p>19.24<br>
先看形参类型，触发拷贝构造函数或移动构造函数，然后再触发每个成员的拷贝成员或构造函数</p>
]]></content>
    </entry>
</feed>