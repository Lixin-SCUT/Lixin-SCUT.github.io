<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-03-15T09:04:23.983Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>In the darkest night,rising like a spire.</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[CountDownLatch]]></title>
        <id>https://lixin-scut.github.io//post/countdownlatch</id>
        <link href="https://lixin-scut.github.io//post/countdownlatch">
        </link>
        <updated>2020-03-15T08:42:30.000Z</updated>
        <content type="html"><![CDATA[<p>这个是在今天做题的时候想起来的，在网络库中也实现了，主要用于线程池的生成</p>
<p>原理<br>
CountDownLatch,本质上来说,类似于信号量，但是又有所不同，具体可看实现，是一个thread safe的计数器,用于主线程和工作线程的同步.<br>
用法主要有有两种:<br>
第一种:在初始化时,需要指定主线程需要等待的任务的个数(count),当工作线程完成 Task Callback后对计数器减1，而主线程通过wait()调用阻塞等待技术器减到0为止.<br>
第二种:初始化计数器值为1,在程序结尾将创建一个线程执行countDown操作并wait()当程序执行到最后会阻塞直到计数器减为0,这可以保证线程池中的线程都start了线程池对象才完成构造,这是一个坑,我在实现ThreadPool的过程中遇到过。</p>
<p>实现<br>
CountDownLatch的底层是mutex和condition<br>
CountDownLatch是一个Thread Safe的Couter,它支持的方法主要是两个countDown()和wait()<br>
countDown就是对counter原子的执行减1操作<br>
wait就使用条件变量等待counter减到0然后notify.</p>
<pre><code>// CountDownLatch.h
// Created by Lixin on 2020.03.07

#pragma once

#include &quot;Condition.h&quot;
#include &quot;MutexLock.h&quot;
#include &quot;noncopyable.h&quot;

// CountDownLatch的主要作用是确保Thread中传进去的func真的启动了以后
// 外层的start才返回
class CountDownLatch : noncopyable 
{
public:
	explicit CountDownLatch(int count);
	void wait();
	void countDown();

private:
	mutable MutexLock mutex_;
	Condition condition_;
	int count_;
};

// CountDownLatch.cc
// Created by Lixin on 2020.03.07

#include &quot;CountDownLatch.h&quot;

CountDownLatch::CountDownLatch(int count)
	: mutex_(), 
	  condition_(mutex_), 
	  count_(count) 
{ }

void CountDownLatch::wait() 
{
	MutexLockGuard lock(mutex_);
	while (count_ &gt; 0) condition_.wait();
}

void CountDownLatch::countDown() 
{
	MutexLockGuard lock(mutex_);
	--count_;
	if (count_ == 0) 
	{
		condition_.notifyAll();
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[多线程 题1114:按序打印]]></title>
        <id>https://lixin-scut.github.io//post/duo-xian-cheng-ti-1114an-xu-da-yin</id>
        <link href="https://lixin-scut.github.io//post/duo-xian-cheng-ti-1114an-xu-da-yin">
        </link>
        <updated>2020-03-15T07:23:21.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>我们提供了一个类：<br>
public class Foo {<br>
  public void one() { print(&quot;one&quot;); }<br>
  public void two() { print(&quot;two&quot;); }<br>
  public void three() { print(&quot;three&quot;); }<br>
}<br>
三个不同的线程将会共用一个 Foo 实例。<br>
线程 A 将会调用 one() 方法<br>
线程 B 将会调用 two() 方法<br>
线程 C 将会调用 three() 方法<br>
请设计修改程序，以确保 two() 方法在 one() 方法之后被执行，three() 方法在 two() 方法之后被执行。<br>
示例 1:<br>
输入: [1,2,3]<br>
输出: &quot;onetwothree&quot;<br>
解释:<br>
有三个线程会被异步启动。<br>
输入 [1,2,3] 表示线程 A 将会调用 one() 方法，线程 B 将会调用 two() 方法，线程 C 将会调用 three() 方法。<br>
正确的输出是 &quot;onetwothree&quot;。<br>
示例 2:<br>
输入: [1,3,2]<br>
输出: &quot;onetwothree&quot;<br>
解释:<br>
输入 [1,3,2] 表示线程 A 将会调用 one() 方法，线程 B 将会调用 three() 方法，线程 C 将会调用 two() 方法。<br>
正确的输出是 &quot;onetwothree&quot;。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/print-in-order<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>首先读懂题目，线程启动的顺序可能是不一致的，所以我们必须让它们就算在不一致的情况下也能按序输出<br>
这一次我依旧使用了mutex+condtion<br>
然后引发了以下问题：</p>
<ol>
<li>一开始我用的是signal，通知其他线程，我本以为signal会不断通知直至有一个线程运行成功，其实不是的，signal只会通知等待condition中多个线程中的一个，而后面的线程继续保持wait（我在测试过程中一直是唤醒线程3，所以一致超时），必须用broadcast</li>
<li>我在ubuntu下测试的时候发现无法打印，后来发现是主线程的main函数会默认执行exit函数，导致所有程序被退出，此时主线程必须用pthread_exit，避免进入exit</li>
<li>经过以上分析，可以发现其实用两个condition可以更好地避免使用broadcast导致惊群效应，可以直接用signal。</li>
</ol>
<p>最后代码：</p>
<pre><code>class Foo {
public:
    Foo() {
        pthread_mutex_init(&amp;mutex,nullptr);
        pthread_cond_init(&amp;cond,nullptr);
        printOne = true;
        printTwo = false;
        printThree = false;
    }

    void first(function&lt;void()&gt; printFirst) {
        pthread_mutex_lock(&amp;mutex);
        while(!printOne)
        {
            pthread_cond_wait(&amp;cond, &amp;mutex);
        }
        // printFirst() outputs &quot;first&quot;. Do not change or remove this line.
        printFirst();
        printOne = false;
        printTwo = true;
        pthread_cond_broadcast(&amp;cond);
        pthread_mutex_unlock(&amp;mutex);
    }

    void second(function&lt;void()&gt; printSecond) {
        pthread_mutex_lock(&amp;mutex);
        while(!printTwo)
        {
            pthread_cond_wait(&amp;cond, &amp;mutex);
        }
        // printSecond() outputs &quot;second&quot;. Do not change or remove this line.
        printSecond();
        printTwo = false;
        printThree = true;
        pthread_cond_broadcast(&amp;cond);
        pthread_mutex_unlock(&amp;mutex);
    }

    void third(function&lt;void()&gt; printThird) {
        pthread_mutex_lock(&amp;mutex);
        while(!printThree)
        {
            pthread_cond_wait(&amp;cond, &amp;mutex);
        }
        // printThird() outputs &quot;third&quot;. Do not change or remove this line.
        printThird();
        printThree = false;
        printOne = true;
        pthread_cond_broadcast(&amp;cond);
        pthread_mutex_unlock(&amp;mutex);
    }
    
private:
    pthread_mutex_t mutex;
    pthread_cond_t cond;
    bool printOne,printTwo,printThree;
};
</code></pre>
<p>网友题解：<br>
双互斥锁</p>
<blockquote>
<p>由于需要two()在one()之前执行，所以two()必须等待one()执行后的某个条件达成，使用锁来实现同步。</p>
</blockquote>
<pre><code>class Foo {
public:
    mutex smx;
    mutex tmx;
    Foo() {
     smx.lock();
     tmx.lock();
    }

    void first(function&lt;void()&gt; printFirst) {
        // printFirst() outputs &quot;first&quot;. Do not change or remove this line.
        printFirst();
        smx.unlock();
    }

    void second(function&lt;void()&gt; printSecond) {
        lock_guard&lt;mutex&gt; lg(smx);
        // printSecond() outputs &quot;second&quot;. Do not change or remove this line.
        printSecond();
        tmx.unlock();
    }

    void third(function&lt;void()&gt; printThird) {
        lock_guard&lt;mutex&gt; lg(tmx);
        // printThird() outputs &quot;third&quot;. Do not change or remove this line.
        printThird();
    }
};
</code></pre>
<blockquote>
<p>可以这么理解，每个线程相当于一个人，执行代码相当于需要进到房间，执行one()这个人A房间对他不设防，可以直接进去，而执行two()的这个人B需要打开smx这个锁才能进去，而执行three()的这个人C需要打开两把锁才能进入。一开始门上是有两把锁的，所以一开始只有A能进入，出来之后想让B可以进入C不能进去，怎么办呢？可以让A出来之前把smx锁打开，然后B就可以进去了，C不能进去，然后B出来之前把smx和tmx都打开，然后C才能进去。<br>
要注意的是，C尝试获得锁的时候顺序一定要是先获得tmx这个锁再获得smx这个锁，因为smx这个锁同时被B和C需要，否则A在打开了smx锁后立刻被C获得了后，由于没有B给C打开tmx这个锁，C会挂在lock(tmx)上，而后到来的B因为不能获得smx锁，会挂在lock(smx)上，于是就发生了死锁。</p>
</blockquote>
<blockquote>
<p>成员变量<br>
用一个全局变量flag，标示当前是什么状态，状态1只能执行one()，状态2只能执行two()，状态3执行three()，然后到每个函数下改变状态即可。</p>
</blockquote>
<pre><code>class Foo {
public:
    volatile int flag;
    Foo() {
     flag = 1;
    }

    void first(function&lt;void()&gt; printFirst) {
        while (flag != 1);
        // printFirst() outputs &quot;first&quot;. Do not change or remove this line.
        printFirst();
        flag = 2;
    }

    void second(function&lt;void()&gt; printSecond) {
        while (flag != 2);
        // printSecond() outputs &quot;second&quot;. Do not change or remove this line.
        printSecond();
        flag = 3;
    }

    void third(function&lt;void()&gt; printThird) {
        while(flag != 3);
        // printThird() outputs &quot;third&quot;. Do not change or remove this line.
        printThird();
    }
};
</code></pre>
<blockquote>
<p>成员变量-处理非期望输入<br>
由于上面的使用成员变量作为状态标记的方法只适用于输入是[1,2,3]的全排列的情况，一旦输入出现重复数字的情况（如[1,2,1,3]），那么就会死循环。<br>
和使用mutex的方法对比我们可以找出原因，使用mutex时，A出去之后“门”允许A和B都能进入，因为“门”不会因为A进去之后而改变A的访问权限，；而使用状态表示时，A进入之后就不能再进去了，因为状态变成了只能B才能进入，而根据题意显然进入过“门”的“人”可以再次进入。造成如此的原因是!=符号只能确定一个状态，而不能确定一个集合的状态，我们需要记录的状态是此时“哪些人”可以进入“门”而不是此时“哪个人”可以进入“门”。<br>
我们可以使用set&lt; int &gt;记录谁被允许访问，通过在每个函数返回前加入下一个被允许进入的“人”。当然这个题直接用&lt;作为set.count()的简化版本，使用++替代set.add(next_id)。<br>
要注意的是，thrid(...)函数最后是否复原状态（就是set.clear()或flag = 0）决定了在A、B、C每个人都经过一次之后是重新开始按1、2、3的顺序打印还是按线程调度的先后顺序打印。</p>
</blockquote>
<pre><code>class Foo {
public:
    volatile int flag;
    Foo() {
     flag = 1;
    }

    void first(function&lt;void()&gt; printFirst) {
        while (flag &lt; 1);
        // printFirst() outputs &quot;first&quot;. Do not change or remove this line.
        printFirst();
        flag = 2;
    }

    void second(function&lt;void()&gt; printSecond) {
        while (flag &lt; 2);
        // printSecond() outputs &quot;second&quot;. Do not change or remove this line.
        printSecond();
        flag = 3;
    }

    void third(function&lt;void()&gt; printThird) {
        while(flag &lt; 3);
        // printThird() outputs &quot;third&quot;. Do not change or remove this line.
        printThird();
    }
};
</code></pre>
<p>注意这里其实flag必须声明为volatile，否则在其他题目下如果多线程修改flag就会出现问题<br>
注意这里直接while会陷入自旋直到时间片用光再线程调度，比较空耗cpu<br>
但是多线程不一定能提高执行的速度，需要考虑线程的创建消耗，以及同步数据的消耗</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[condition中的signal与broadcast整理]]></title>
        <id>https://lixin-scut.github.io//post/condition-zhong-de-signal-yu-broadcast-zheng-li-cao-gao</id>
        <link href="https://lixin-scut.github.io//post/condition-zhong-de-signal-yu-broadcast-zheng-li-cao-gao">
        </link>
        <updated>2020-03-15T05:37:37.000Z</updated>
        <content type="html"><![CDATA[<p>问题起源于我今天早上做的线程题：<br>
在线程1执行完成后，我使用了pthread_cond_signal来通知线程2，我本以为signal会不断通知直至有一个线程运行成功，其实不是的，signal只会通知等待condition中多个线程中的一个，而后面的线程继续保持wait（我在测试过程中一直是唤醒线程3，所以一致超时），必须用broadcast</p>
<p>结合以前的博文：<br>
可以得出以下结论</p>
<ol>
<li>pthread_cond_broadcast会通知所有订阅了同一condition并wait的线程，如果他们想要不同的mutex的话就能继续执行，争抢同一mutex则只有一个线程最后能执行下去，间接导致惊群效应</li>
<li>pthread_cond_signal可以说是为了解决这个惊群效应而生，内核会随机选择符合条件的线程，使得最终只有一个线程被唤醒，其他线程就算符合条件也必须保持wait</li>
<li>但是pthread_cond_signal可能会导致虚假唤醒，所以必须使用while来判断条件，而不能是if</li>
</ol>
<p>参考资料：<br>
pthread_cond_broadcast的man page<br>
条件信号的多次唤醒<br>
在多处理器上，pthread_cond_signal的实现可能无法避免解除对一个条件变量阻塞的多个线程的阻塞。例如，考虑以下pthread_cond_wait和pthread_cond_signal的部分实现，该实现由两个线程按给定的顺序执行。一个线程正在尝试等待条件变量，另一个线程正在同时执行pthread_cond_signal，而第三线程已经在等待。<br>
结果一个调用pthread_cond_signal的结果是多个线程可以从其调用pthread_cond_wait或pthread_cond_timedwait返回。这种效应称为虚假唤醒。请注意，这种情况是自我纠正的，因为唤醒的线程数是有限的。例如，在块上方的事件序列之后，下一个调用pthread_cond_wait的线程。<br>
尽管可以解决此问题，但是对于仅很少发生的边缘条件造成的效率损失是不可接受的，尤其是考虑到无论如何必须检查与条件变量关联的谓词。对于所有更高级别的同步操作，更正此问题将不必要地降低此基本构建块中的并发程度。<br>
允许虚假唤醒的另一个好处是，应用程序被迫围绕条件等待编写谓词测试循环。这也使应用程序可以在应用程序的某些其他部分中编码的相同条件变量上容忍多余的条件广播或信号。因此，所得的应用程序更加健壮。因此，POSIX.1-2008明确记录了可能会发生虚假唤醒。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[多线程中的线程关系]]></title>
        <id>https://lixin-scut.github.io//post/duo-xian-cheng-zhong-de-xian-cheng-guan-xi</id>
        <link href="https://lixin-scut.github.io//post/duo-xian-cheng-zhong-de-xian-cheng-guan-xi">
        </link>
        <updated>2020-03-15T05:35:45.000Z</updated>
        <content type="html"><![CDATA[<p><strong>进程中线程之间的关系</strong><br>
线程不像进程，一个进程中的线程之间是没有父子之分的，都是平级关系。即线程都是一样的, 退出了一个不会影响另外一个。<br>
但是主线程main,其入口代码是类似这样的方式调用main的：exit(main(…))。<br>
main执行完之后, 会调用exit()。<br>
而exit() 会让整个进程over终止，那所有线程自然都会退出。</p>
<p><strong>主线程先退出，子线程继续运行的方法</strong><br>
在进程主函数（main()）中调用pthread_exit()，只会使主函数所在的线程（可以说是进程的主线程）退出；<br>
而如果是return，编译器将使其调用进程退出的代码（如_exit()），从而导致进程及其所有线程结束运行。<br>
理论上说，pthread_exit()和线程函数退出的功能是相同的，函数结束时会在内部自动调用pthread_exit()来清理线程相关的资源。但实际上二者由于编译器的处理有很大的不同。<br>
按照POSIX标准定义，当主线程在子线程终止之前调用pthread_exit()时，子线程是不会退出的。<br>
main()中调用了pthread_exit后，导致主线程提前退出，其后的exit()无法执行了，所以要到其他线程全部执行完了，整个进程才会退出。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 题68:树中两个节点的最低公共祖先]]></title>
        <id>https://lixin-scut.github.io//post/shu-ti-68shu-zhong-liang-ge-jie-dian-de-zui-di-gong-gong-zu-xian</id>
        <link href="https://lixin-scut.github.io//post/shu-ti-68shu-zhong-liang-ge-jie-dian-de-zui-di-gong-gong-zu-xian">
        </link>
        <updated>2020-03-14T16:22:06.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目：输入两个树结点，求它们的最低公共祖先。</p>
</blockquote>
<p>1.确认树的节点中有没有指向父节点的指针（迭代版），如果树中的每个节点(除根节点之外)都有一个指向父节点的指针，那么这个问题可以转换成求两个链表的第一个公共节点<br>
2.两个节点的公共祖先，指的是这两个节点都出现在某个节点的子树中我们可以从根节点开始遍历一棵树，每遍历到一个节点时，判断两个输入节点是不是在它的子树中:如果在子树中，则分别遍历它的所有子节点，并判断两个输入节点是不是在它们的子树中这样从上到下一直找到的第一个节点，它自己的子树中同时包含两个输入的节点而它的子节点却没有，那么该节点就是最低的公共祖先<br>
3.更快的算法，用辅助内存，用两个链表分别保存从根节点到输入的两个节点的路径，然后把问题转换成两个链表的最后公共节点，首先得到一条从根节点到树中某一节点的路径，这就要求在遍历的时候有一个辅助内存来保存路径，然后也可以得到从根节点开始到达另一节点必须经过的路径，最后可以求出这两条路径的最后一个公共节点。为了得到从根节点开始到输入的两个节点的两条路径，需要遍历两次树，每遍历一次的时间复杂度是O(n)得到的两条路径的长度在最差情况时是O(n),通常情况下两条路径的长度是0(logn)</p>
<pre><code>bool GetNodePath(const TreeNode* pRoot, const TreeNode* pNode, list&lt;const TreeNode*&gt;&amp; path)
{
    if(pRoot == pNode)
        return true;
 
    path.push_back(pRoot);
 
    bool found = false;

    vector&lt;TreeNode*&gt;::const_iterator i = pRoot-&gt;m_vChildren.begin();
    while(!found &amp;&amp; i &lt; pRoot-&gt;m_vChildren.end())
    {
        found = GetNodePath(*i, pNode, path);
        ++i;
    }
 
    if(!found)
        path.pop_back();
 
    return found;
}

const TreeNode* GetLastCommonNode
(
    const list&lt;const TreeNode*&gt;&amp; path1, 
    const list&lt;const TreeNode*&gt;&amp; path2
)
{
    list&lt;const TreeNode*&gt;::const_iterator iterator1 = path1.begin();
    list&lt;const TreeNode*&gt;::const_iterator iterator2 = path2.begin();
    
    const TreeNode* pLast = nullptr;
 
    while(iterator1 != path1.end() &amp;&amp; iterator2 != path2.end())
    {
        if(*iterator1 == *iterator2)
            pLast = *iterator1;
 
        iterator1++;
        iterator2++;
    }
 
    return pLast;
}

const TreeNode* GetLastCommonParent(const TreeNode* pRoot, const TreeNode* pNode1, const TreeNode* pNode2)
{
    if(pRoot == nullptr || pNode1 == nullptr || pNode2 == nullptr)
        return nullptr;
 
    list&lt;const TreeNode*&gt; path1;
    GetNodePath(pRoot, pNode1, path1);
 
    list&lt;const TreeNode*&gt; path2;
    GetNodePath(pRoot, pNode2, path2);
 
    return GetLastCommonNode(path1, path2);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 题67:把字符串转换成整数]]></title>
        <id>https://lixin-scut.github.io//post/math-ti-67ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu</id>
        <link href="https://lixin-scut.github.io//post/math-ti-67ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu">
        </link>
        <updated>2020-03-14T15:06:58.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0<br>
输入描述:<br>
输入一个字符串,包括数字字母符号,可以为空<br>
输出描述:<br>
如果是合法的数值表达则返回该数字，否则返回0</p>
</blockquote>
<p>实际的原理比较简单，就是细节比较重要<br>
1.需要判断-号和+号，但是更重要的是判断完后需要注意是不是仅仅只有加减号<br>
2.由于INT的表达范围，负数能比正数表达多一位，所以我选择先用负数表达res，然后用减法探测溢出（注意不要漏掉*10）<br>
3.最后需要转化结果，不要忘了-res</p>
<pre><code>class Solution {
public:
    int StrToInt(string str) {
        if(str.empty())
        { return 0; }
        int negative = false;
        int locate = 0;
        int res = 0;
        
        if(str[0] == '-' )
        { negative = true; ++locate; }
        else if(str[0] == '+' )
        { ++locate; }
        //判断完后需要注意是不是仅仅只有加减号
        if(locate &gt;= str.size())
            return 0;
        
        for(; locate &lt; str.size(); ++locate)
        {
            if(str[locate] &gt;='0' &amp;&amp; str[locate] &lt;= '9')
            {
                if(INT_MIN + (str[locate] - '0') &gt; res*10 ) //通过减法避免溢出，注意不要漏掉*10
                    return 0;
                res = res*10 - (str[locate] - '0');
            }
            else
            { return 0; }
        }
        
        //这里本来可以用两个条件运算符，但是可读性比较差
        return negative ? res : ( res == INT_MIN ? 0 : -res );
        /*
        if(negative)
            return res;
        return res == INT_MIN ? 0 : -res;
        */
    }
};
</code></pre>
<p>书本题解：<br>
面试中需要注意的点</p>
<ol>
<li>检查字符串是否是空指针</li>
<li>当字符串为空的时候，确认返回值（通过一个全局变量来区分的 如果是非法输入，则返回 0并 把这个全局变量设为一个特殊标记 如果输入是&quot;0”，则返回 0,不会设 置全局变 量。这样，当 atoi 的调用者得到返回值 0 的时候，可以通过检查 全局变量得知 输入究竟是非法输入还是字符串&quot;0&quot;）</li>
<li>数字前的加号和减号应该也是合法的输入字符</li>
</ol>
<pre><code>enum Status {kValid = 0, kInvalid};
int g_nStatus = kValid;

int StrToInt(const char* str)
{
    g_nStatus = kInvalid;
    long long num = 0;

    if(str != nullptr &amp;&amp; *str != '\0') 
    {
        bool minus = false;
        if(*str == '+')
            str ++;
        else if(*str == '-') 
        {
            str ++;
            minus = true;
        }

        if(*str != '\0')  // 防止只有加减号
            num = StrToIntCore(str, minus);
    }

    return (int)num;
}

long long StrToIntCore(const char* digit, bool minus)
{
    long long num = 0;

    while(*digit != '\0') 
    {
        if(*digit &gt;= '0' &amp;&amp; *digit &lt;= '9') 
        {
            int flag = minus ? -1 : 1;
            num = num * 10 + flag * (*digit - '0');

            if((!minus &amp;&amp; num &gt; 0x7FFFFFFF) 
                || (minus &amp;&amp; num &lt; (signed int)0x80000000))
            {
                num = 0;
                break;
            }

            digit++;
        }
        else 
        {
            num = 0;
            break;
        }
    }

    if(*digit == '\0') 
        g_nStatus = kValid;

    return num;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[目标文件-ELF文件]]></title>
        <id>https://lixin-scut.github.io//post/bian-yi-lian-jie-yu-elf-wen-jian-cao-gao</id>
        <link href="https://lixin-scut.github.io//post/bian-yi-lian-jie-yu-elf-wen-jian-cao-gao">
        </link>
        <updated>2020-03-14T07:34:40.000Z</updated>
        <content type="html"><![CDATA[<h3 id="elf文件">ELF文件</h3>
<p>ELF文件中把带有相同属性(比方都是只读并可加载的)的 section 都合并成所谓 segments(段)。 segments 是被加载器所使用的。加载器会将所需要的 segment 加载到内存空间中运行。</p>
<ol>
<li>可重定位的对象文件(Relocatable file)(没有segments)<br>
这是由汇编器汇编生成的 .o 文件。后面的链接器(link editor)拿一个或一些 Relocatable object files 作为输入，经链接处理后，生成一个可执行的对象文件 (Executable file) 或者一个可被共享的对象文件(Shared object file)。我们可以使用 ar 工具将众多的 .o Relocatable object files 归档(archive)成 .a 静态库文件。</li>
<li>可执行的对象文件(Executable file)<br>
在Linux系统里面，存在两种可执行的文件，除了这里说的可执行的目标文件，另外一种就是可执行的脚本（如shell脚本）文件。</li>
<li>可被共享的对象文件(Shared object file)<br>
这些就是所谓的动态库文件，也即 .so 文件。</li>
</ol>
<p>在ELF文件里面，每一个 sections 内都装载了性质属性都一样的内容，比方：</p>
<ol>
<li>.text section 里装载了可执行代码；</li>
<li>.data section 里面装载了被初始化的数据；</li>
<li>.bss section 里面装载了未被初始化的数据；</li>
<li>以 .rec 打头的 sections 里面装载了重定位条目；</li>
<li>.symtab 或者 .dynsym section 里面装载了符号信息；</li>
<li>.strtab 或者 .dynstr section 里面装载了字符串信息；</li>
<li>其他还有为满足不同目的所设置的section，比方满足调试的目的、满足动态链接与加载的目的等等。</li>
</ol>
<h3 id="参考资料">参考资料：</h3>
<p><strong>《后台开发 核心技术与应用实践》</strong><br>
ELF是一种用于二进制文件、可执行文件、目标代码、共享库和核心转储的标准文件格式。ELF标准的目的是为软件开发人员提供一组二进制接口定义，这些接口可以延伸到多种操作环境中，从而减少重新编码、编译程序的需要。<br>
ELF文件主要优点是在目标文件里面引入了 “段”的机制，不同的目标文件可以拥有不同数量及不同类型的“段”。</p>
<h3 id="elf的文件类型">ELF的文件类型</h3>
<p>目标文件有3种类型，如下所述。<br>
(1)可重定位的目标文件<br>
由汇编器汇编生成的.o文件，链接器拿一个或一些可重定位的目标文件作为输入,经链接处理后，生成一个可执行的目标文件或者一个可被共享的对象文件（.so文件）。也可以使用ar工具将众多的.o文件归档（archive）成.a静态库文件。<br>
(2)可执行的目标文件<br>
在Linux系统里面，存在两种可执行的文件，除了这里说的可执行的目标文件，另外一种就是可执行的脚本（如shell脚本）文件。注意这些脚本不是可执行的目标文件，它们只是文本文件，执行这些脚本所用的解释器才是可执行的，比如bash shell程序。此类文件规 定了如何利用exec()创建一个程序的进程映像。<br>
(3)	可被共享的目标文件<br>
这些就是所谓的动态库文件，也即.so文件。动态库在发挥作用的过程中，必须经过两个步骤：<br>
①链接器拿它和其他可重定位的文件（.o文件）以及其他.so文 件作为输入，经链接处理后，生成另外的可共享的目标文件（.so文件）或者可执行的目标文 件；<br>
②在运行时，动态链接器拿它和一个可执行的目标文件以及另外一些可共享的目标文件（.so）来一起处理，在Linux系统里面创建一个进程映像。<br>
如果拿前面的静态库来生成可执行程序， 那每个生成的可执行程序中都会有一份库代码的拷贝。如果在磁盘中存储这些可执行程序, 那就会占用额外的磁盘空间；另外如果把它们放到Linux系统上一起运行，也会浪费掉宝贵 的物理内存。如果将静态库换成动态库，那么这些问题都不会出现。</p>
<h3 id="链接视图下的elf内容">链接视图下的ELF内容</h3>
<p>ELF格式需要使用在两种场合：<br>
① 组成不同的可重定位文件，以参与可执行文件或者可被共享的对象文件的链接构建<br>
②组成可执行文件或者可被共享的对象文件，以在运行时内存中进程 映像的构建。</p>
<p>图中左边的部分表示的是可重 定位文件的格式；而右边部分表示的则是可执行文 件以及可被共享的对象文件的格式。可以用file命令来查看文件属于哪种ELF文件。</p>
<p><strong>ELF头部</strong><br>
ELF里面的内容，除了 file命令所显示出来的内容，更重要的是包含另外一些数据，用于描述ELF文件中ELF文件头之外的内容。可以使用readelf工具来读出整个 ELF文件头的内容，<br>
（1） readelf -h add.o 命令是显示 add.o 的 ELF Header的文件头信息<br>
<code>Entry point address:	0x0</code><br>
可重定位文件（.o文件）的进入点是0x0(e_entry)，这表明可重定位文件（.o文件）不会有程序进入点。<br>
所谓程序进入点是指当程序真正执行起来的时候，其第一条要运行的指令的地址。因为可重定位文件只是供再链接而已，所以它不存在进入点；而可执行文件test和动态库.so都存在所谓的进入点。</p>
<p>这个add.o文件包含有11个section （节区），但program headers的数量为0.而可执行文件main和可被共享文件libmymath.so里的program headers则不为0。<br>
（2）那什么是所谓section呢？可以说，section是在ELF文件里头，用以装载内容数据的最小容器。在ELF文件里面，每一个section内都装载了性质属性都一样的内容，比如以下几种情况。<br>
1	） text section里装载了可执行代码。<br>
2	） data section里面装载了被初始化的数据。<br>
3	） bss section里面装载了未被初始化的数据。<br>
4	）以.rec打头的sections里面装载了重定位条目。<br>
5	） symtab或者dynsym section里面装载了符号信息。<br>
6	）strtab或者dynstr section里面装载了字符串信息。<br>
7	）其他还有为满足不同目的所设置的section，比如满足调试的目的、满足动态链接与加载的目的等。</p>
<p><strong>ELF section表的总体预览</strong><br>
可以利用readelf工具来查看可重定位对象文件add.o的section表内容，<br>
执行readelf -S add.o命令得到结果如图所示。<br>
图4-19显示了 add.o中包含的所有11个section的内容。因为add.o仅仅是参与链接的 可重定位文件，而不参与最后进程映像的构建，所以Address的值为0。</p>
<p>后面会看到可执行 文件以及动态库文件中大部分sections的这一字段都是有某些特殊取值的。<br>
Offset表示了该 section离开文件头部位置的距离；<br>
Size表示section的字节大小；<br>
EntSize只对某些形式的 sections有意义。如符号表.symtab section,其内部包含了一个表格，表格的每一个条目都是 特定长度的，此时就表示条目的长度为10。Align是地址对齐要求；<br>
另外剩下的两列Link和 Info,它们中记录的是section head table中的条目索引，这就意味着，从这两个字段出发，可以找到对应的另外两个section,其具体的含义解释依据不同种类的section而不同，</p>
<p>注意上面结果中的Flags,表示的是对应section的相关标志。比如,text section里面 存储的是代码，所以就是可执行的（用X表示）;</p>
<p>.data和.bss里面存放的都是可写的（用 W表示）数据（非在堆栈中定义的数据），只不过前者存的是初始化过的数据，如程序中定 义的赋过初值的全局变量等；而后者里面存储的是未经过初始化的数据。因为未经过初始 化就意味着不确定这些数据刚开始的时候会有些什么样的值，所以针对对象文件来说，它 就没必要为了存储这些数据而在文件内多留出一块空间，因此.bss section的大小总是为 0<br>
后面会看到，当可执行程序被执行的时候，动态连接器会在内存中开辟一定大小的空 间来存放这些未初始化的数据，里面的内存单元都被初始化成0。<br>
可执行程序文件中虽然没有长度非0的.bss section,但却记录着在程序运行时需要开辟多大的空间来容纳这些未 初始化的数据。</p>
<p>另外一个标志A说明对应的section是Allocable （可分配的）的。所谓可分配的section, 是指在运行时，进程（process）需要使用它们，所以它们被加载器加载到内存中去。<br>
而与此相反，存在一些non-Allocable的sections,它们只是被链接器、调试器或者其他类似工具所使用的，而并非参与进程的运行中去。如后面要介绍的字符串表section .strtab, 符号表.symtab section等。当运行最后的可执行程序时，加载器会加载那些Allocable的部分，而non-Allocable的部分则会被继续留在可执行文件内。所以实际上，这些non-Allocable 的section都可以被stip工具从最后的可执行文件中删除掉，删除掉这些sections的 可执行文件依然能够运行，只不过没办法来进行调试之类的操作。</p>
<p><strong>ELF 的.text section</strong><br>
可以使用readelf -x SecNum来打印出不同section中的内容。但是其输出结果都是机器码，对人来说不具备可读性。所以可以换用另外一个工具objdump来看看这些 sections中到底具有哪些内容。<br>
objdump的选项-d表示要对由-j选择项指定的section内容进行反汇编，也就是由机器码出发，推导出相应的<strong>汇编指令</strong>。</p>
<p><strong>ELF 的.data section</strong><br>
add.o中,data section包含了变量，并按照系统的字节序存放，并相应影响.bss section的offset位置</p>
<p><strong>ELF 的.strtab section</strong><br>
.strtab section中存储着的都是以字符为分隔符的字符串，这些字符串所表示的内容，通常是程序中定义的函数名称、所定义过的变量名称等。当对象文件中其他地方需要和一个这样的字符串相关联的时候，往往会在对应的地方先存储.strtab section中的索引值。</p>
<p><strong>ELF 的.symtab section</strong><br>
字符串表在真正链接和生成进程映像过程中是不需要使用的，但是其对我们调试程序来说就特别有帮助，因为从人的角度看起来最舒服的还是自然形式的字符串，而非天书一样的数字符号。前面使用objdump来反汇编.text section的时候，之所以能看到定义了函数add, 那也是因为存在这个字符串表的原因。当然起关键作用的,还是符号表.symtab section在其 中作为中介<br>
在符号表内针对每一个符号，都会相应的设置一个条目。比如变量result的类型就是OBJECT；而函数add (编译后得到的函数名为_Z3addii)的类型是FUNCO</p>
<h3 id="执行视图下的elf内容">执行视图下的ELF内容</h3>
<p>在可执行文件main中，总共有8个segments (program headers)。同时该结果也很明白显示出了哪些section映射到哪一个segment当中去。比方在索引为2的那个 segment中，总共有16个sections映射进来，其中包括在前面提到过的.text sectiono注意这 个segment有两个标志：R和E。这个表示该segment是可读的、可执行的。如果看到标志中有W,那表示该segment是可写的。<br>
类型为INTERP的segment只包含一个section,那就是.interpo在这个section中，包含了动态链接过程中所使用的解释器路径和名称<br>
INTERP segment 的存在这是因为我们写的应用程序通常都需要使用动态链接 库.so,就像test程序中所使用的libsub.so 一样。程序在Linux里面运行时，当在shell中键入一个命令要执行时，内核会创建一个新的进程，在往这个新进程的进程空间里面加载进可执行程序的代码段和数据段后，也会加载进动态连接器（在Linux里面通常就是/lib/ld-linux.so 符号链接所指向的那个程序，它本身就是一个动态库）的代码段和数据。在这之后，内核将控制传递给动态链接库里面的代码。动态连接器接下来负责加载该命令应用程序所需要使用的各种动态库。加载完毕，动态连接器才将控制传递给应用程序的main函数。如此操作后相应的应用程序才得以运行。</p>
<h3 id="阅读elf文件的工具readelf">阅读ELF文件的工具——readelf</h3>
<p>readelf和objdump提供的功能类似，但是它显示的信息更为具体，并且它不依赖BFD 库（BFD库是一个GNU项目，它的目标就是希望通过一种统一的接口来处理不同的目标文 件），所以即使BFD库有什么bug存在的话也不会影响到readelf程序。运行readelf的时候, 除了-v和-H之外，其他的选项必须至少有一个被指定。</p>
<h3 id="获得二进制文件里符号的工具nm">获得二进制文件里符号的工具——nm</h3>
<p>nm是用来查看指定程序中的符号表相关内容的工具。<br>
内容的格式：<br>
①第一列是当前符号的地址；<br>
②第二列是当前符号的类型；<br>
③第三列是当前符号的名称。<br>
nm输出结果可能会出现像_ZN4Test5HelloEv这样的符号，在执行nm命令的时候，加上-C选项，就可以把这些难以识别的 符号，转换成便于阅读的符号TestHello()，这个主要是C++中的mangle机制所导致的，加上-C就是指定列出的符号是demangle了的。说了这么多，其实nm命令对程序的帮助，主要有以下几个方面。<br>
1	）判断指定程序中有没有定义指定的符号（比较常用的方式：nm -C proc | grep symbol）<br>
2	）解决程序编译时undefined reference的错误，以及mutiple definition的错误。<br>
3）查看某个符号的地址，以及在进程空间的大概位置（bss、data、text区，具体可以通过第二列的类型来判断）</p>
<h3 id="减少目标文件大小的工具trip">减少目标文件大小的工具——trip</h3>
<p>UNIX 下文件压缩命令有compress和tar,结合使用来做数据备份是最合适不过了。但 compress压缩也有缺点，就是<strong>被压缩后的文件需要用命令uncompress解压后才能正常使用; 而用strip命令就没有这个问题，它能清除执行文件中不必要的标示符及调试信息，可减小文 件大小而不影响正常使用。但与compress不同的是，文件一旦进行strip操作后就不能恢复原样了</strong>，所以strip可以认为是一个“减肥”工具而不是压缩工具。而且，被strip后的文件不包含调试信息。<br>
strip 命令能从ELF文件中有选择地除<strong>去行号信息、重定位信息、调试段、typchk段、注释段、文件头以及所有或部分符号表。</strong><br>
<strong>但一旦使用该命令，则很难调试文件的符号；因此，通常只在已经调试和测试过的生成模块上使用strip命令，来减少对象文件所需的存储量开销。</strong><br>
其他常用选项如下所述。<br>
（1）-l (小写L)：从对象文件中除去行号信息。<br>
（2）-r：除了外部符号和静态符号条目，将全部符号表信息除去。不除去重定位信息。 同时除去调试段和typchk段。这个选项产生一个对象文件，该对象文件仍可以用作输入到链 接编辑器中。<br>
（3）-t：除去大多数符号表信息，但并不除去函数符号或行号信息<br>
(4)	 -V：打印strip命令的版本号。<br>
(5)  -x ：除去符号表信息，但并不除去静态或外部符号信息。-x标志同时除去重定位信 息，因此将不可能链接到该文件。</p>
<p><strong>《深入了解计算机系统》</strong><br>
<strong>可重定位目标文件</strong><br>
ELF 头(ELF header)以一个16 字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。ELF 头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。<br>
不同节的位 置和大小是由 节头部表描述的，其中目标文件中每个节都 有一个固 定大小的条目(entry)。<br>
<img src="https://lixin-scut.github.io//post-images/1584190695161.png" alt=""></p>
<p>夹在 ELF 头和节头部表之间的都是节。一个典型的 ELF 可重定位目标文件包含下面几个节:<br>
.text:已编译程序的机器代码。<br>
.rodata:只读数据，比如 printf 语句中的格式串和开关语句的跳转表。<br>
.data:已初始化的全局和静态 C 变量。局部 C 变量在运行时被保存在栈中，既不出 现在.data 节中，也不出现在.bss 节中。<br>
.bss:未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分已初始化 和未初始化变量是 为了空间效率:在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中 分配这些变量，初始值为 0。<br>
.symtab: 一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。一些程序员错误地认为必须通过-g 选项来编译一个程序，才能得到符号表信息。实际上，每个可重定位目标文件 在.symtab 中都有一张符号表(除非程序员特意用 STRIP 命令去掉它)。然而，和编译器中的符号表 不同，.symtab 符号表不包含局部变量的条目。<br>
.rel.text: 一个.text 节中位置的列表，当链接器把这个目标文件和其他文件组合 时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非用户显式地指示链接器包含这些信息。<br>
.rel.data:被模块引用或定义的所有全局变量的重定位信息。一般而言，任何已初 始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改。<br>
.debug: 一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定 义和引用的全局变量，以及原始的 C 源文件。只有以-g 选项调用编译器驱动程序时，才会得到这张表。<br>
.line:原始 C 源程序中的行号和.text节中机器指令之间的映射。只有以-g选项调 用编译器驱动程序时，才会得到这张表。<br>
.strtab: 一个字符串表，其内容包括.symtab 和.debug 节中的符号表，以及节头 部中的节名字。字符串表就是以 null 结尾的字符串的序列。</p>
<p>为什么未初始化的数据称为.bss<br>
用术语.bss 来表示未初始化的数据是很普遍的。它起始于 IBM 704 汇编语言(大约在1957 年)中&quot;块存储开始(Block Storage Start)w 指令的首字母缩写，并沿用至今。 一种记住.data 和.bss 节之间区别的简单方法是把“bss&quot;看成是“更好地节省空间 (Better Save Space)的缩写</p>
<p>符号和符号表<br>
每个可重定位目标模块都有一个符号表，它包含 m 定义和引用的符号的信息。在 链接器的上下文中，有三种不同的符号:</p>
<ul>
<li>由模块(7)定义并能被其他模块引用的全局符号。全局链接器符号对应于非静态的 C 函数和全 局变量。</li>
<li>由其他模块定义并被模块四引用的全局符号。这些符号称为外部符号，对应于在其 他模块中 定义的非静态 C 函数和全局变量。</li>
<li>只被模块 m 定义和引用的局部符号。它们对应于带 static 属性的 C 函数和全局变 量。这些符 号在模块(7)中任何位置都可见，但是不能被其他模块引用。<br>
认识到本地链接器符号和本地程序变量不同是很重要的 o. symtab 中的符号表不包含 对应于本 地非静态程序变量的任何符号。这些符号在运行时在栈中被管理，链接器对此类 符号不感兴趣。<br>
有趣的是，定义为带有 C static 属性的本地过程变量是不在栈中管理的。相反，编 译器在.data 或.bss 中为每个定义分配空间，并在符号表中创建一个有唯一名字的本地 链接器符号。<br>
利用 static 属性隐藏变量和函数名字<br>
C 程序员使用 static 属性隐藏模块内部的变量和函数声明，就像你在 Java 和 C++中使用 public 和 private 声明一样。在 C 中，源文件扮演模块的角色。任何带有 static 属性声明的全局 变量或者函数都是模块私有的。类似地，任何不带 static 属 性声明的全局变量和函数都是公共的，可以被其他模块访问。尽可能用 static 属性来 保护你的变量和函数是很好的编程习惯。</li>
</ul>
<p>链接器如何解析多重定义的全局符号<br>
在编译时，编译器向汇编器输出每个全局符号，或者是强(strong)或者是弱(weak) , 而汇编器把这 个信息隐含地编码在可重定位目标文件的符号表里。函数和已初始化的全局 变量是强符号，未初始化 的全局变量是弱符号。<br>
根据强弱符号的定义，Linux 链接器使用下面的规则来处理多重定义的符号名:<br>
•规则 1:不允许有多个同名的强符号。<br>
•规则 2:如果有一个强符号和多个弱符号同名，那么选择强符号。<br>
•规则 3:如果有多个弱符号同名，那么从这些弱符号中任意选择一个。<br>
如果定义多个main函数，链接器将生成一条错误信息，因为强符号 main 被定义了多次<br>
如果定义了多个全局变量也会如此，但是如果如果在一个模块里 同名全局变量未被初始化，那么链接器将安静地选择在另一个模块中定义的强符号<br>
注意，链接器通常不会表明它检测到多个同名全局变量的定义:<br>
规则 2 和规则 3 的应用会造成一些不易察觉的运行时错误，尤其是如果重复的符号定义还有不同的类型时。<br>
当编译器在翻 译某个模块时，遇到一个弱全局符号，比如说 x,它并不知道其他模块是否也定义了 X,如果是，它无法预测链接器该使用 x 的多重定义中的哪一个。所以编译器把 x 分配成 COMMON,把决定权留给链接器。另一方面，如果 x 初始化为 0,那么它是一个强符号(因此根据规则 2 必须是唯一的)，所以编译 器可以很自信地将它分配成.bss。类似地， 静态符号的构造就必须是唯一的，所以编译器可以自信地 把它们分配成.data 或.bss。</p>
<p>与静态库链接<br>
迄今为止我们都是假设链接器读取一组可重定位目标文件，并把它们链接起来，形 成一个输 出的可执行文件。实际上，所有的编译系统都提供一种机制，将所有相关的目标 模块打包成为一个 单独的文件，称为静态库(static library),它可以用做链接器的输入。 当链接器构造一个输出的可执 行文件时，它只复制静态库里被应用程序引用的目标模块。</p>
<p>静态库：相关的函数可以被编译为独立的目标模块，然后封装成一个单独的静态库文件。然后，应用程序可以通过在命令行上指定 单独的文件名字 来使用这些在库中定义的函数。</p>
<p>使用 C 标准库和数学库中函数的程 序可以用形式如下的命令 行来编译和链接:<br>
linux&gt; gcc main.c /usr/lib/libm.a /usr/lib/libc.a<br>
在链接时，链接器将只复制被程序引用的目标模块，这就减少了可执行文件在磁盘和内 存中的 大小。另一方面，应用程序员只需要包含较少的库文件的名字(实际上，C 编译器驱 动程序总是传 送 libc.a 给链接器，所以前面提到的对 libc.a 的引用是不必要的)。</p>
<p>在Linux系统中，静态库以一种称为存档(archive)的特殊文件格式存放在磁盘中。存 档文件是 一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文 件的大小和位置。存 档文件名由后缀.a 标识。</p>
<p>链接器如何使用静态库来解析引用<br>
虽然静态库很有用，但是它们同时也是一个程序员迷惑的源头，原因在于 Linux 链接 器使用它们 解析外部引用的方式。在符号解析阶段，链接器从左到右按照它们在编译器驱 动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件。(驱动程序自动将命令 行中所有的.c 文件翻译为.o文件。)在这次扫描中，链接器维护一个可重定位目标文件的 集合 E(这个集合中的文件会被合并起来形成可执行文件)，一个未解析的符号(即引用了 但是尚未定义的符号)集合U,以及一个在前面输入文件中已定义的符号集合D。初始时E、U 和。均为空。<br>
•对于命令行上的每个输入文件儿 链接器会判断y是一个目标文件还是一个存档文 件。如果是一<br>
个目标文件，那么链接器把了添加到 E,修改 U 和 D 来反映中 的符号定义和引用，并继续下一个<br>
输入文件。<br>
•如果 f 是一个存档文件，那么链接器就尝试匹配 U 中未解析的符号和由存档文件成员定 义的符号。如果某个存档文件成员%,定义了一个符号来解析U中的一个引用，那么就 将m加到E中， 并且链接器修改 U 和。来反映〃中的符号定义和引用。对存档文件中 所有的成员目标文件都依 次进行这个过程，直到U和。都不再发生变化。此时，任何不 包含在E中的成员目标文件都简 单地被丢弃，而链接器将继续处理下一个输入文件。<br>
•如果当链接器完成对命令行上输入文件的扫描后，U 是非空的，那么链接器就会输出一 个错误 并终止玄否则，它会合并和重定位 E 中的目标文件，构建输出的可执行文件。<br>
不幸的是，这种算法会导致一些令人困扰的链接时错误，因为命令行上的库和目标文 件的顺序非 常重要。在命令行中，如果定义一个符号的库出现在引用这个符号的目标文件 之前，那么引用就不能 被解析，链接会失败。<br>
关于库的一般准则是将它们放在命令行的结尾。如果各个库的成员是相互独立的(也 就是说没有 成员引用另一个成员定义的符号)，那么这些库就可以以任何顺序放置在命令 行的结尾处。另一方面， 如果库不是相互独立的，那么必须对它们排序，使得对于每个被 存档文件的成员外部引用的符号 S,在 命令行中至少有一个 S 的定义是在对 S 的引用之后 的。比如，假设 foo.c 调用 libx.a 和 libz.a 中的函 数，而这两个库又调用 liby.a 中 的函数。那么，在命令行中 libx.a 和 libz.a 必须处在 liby.a 之前:<br>
linux&gt; gcc foo.c libx.a libz.a liby.a<br>
如果需要满足依赖需求，可以在命令行上重复库。比如，假设 foo.c 调用 libx.a 中 的函数，该库 又调用 liby.a 中的函数，而 liby.a 又调用 libx.a 中的函数。那么 libx. a 必须在命令行上重复出现:<br>
linux&gt; gcc foo.c libx.a liby.a libx.a<br>
另一种方法是，我们可以将 libx.a 和 liby.a 合并成一个单独的存档文件。</p>
<p>重定位<br>
一旦链接器完成了符号解析这一步，就把代码中的每个符号引用和正好一个符号定义 (即它的一 个输入目标模块中的一个符号表条目)关联起来。此时，链接器就知道它的输入 目标模块中的代码节 和数据节的确切大小。现在就可以开始重定位步骤了，在这个步骤 中，将合并输入模块，并为每个符 号分配运行时地址。重定位由两步组成:<br>
•重定位节和符号定义。在这一步中，链接器将所有相同类型的节合并为同一类型的 新的聚合节。 例如，来自所有输入模块的.data 节被全部合并成一个节，这个节成 为输出的可执行目标文件 的.data 节。然后，链接器将运行时内存地址赋给新的聚 合节，赋给输入模块定义的每个节，以 及赋给输入模块定义的每个符号。当这一步 完成时，程序中的每条指令和全局变量都有唯一的 运行时内存地址了。<br>
•重定位节中的符号引用。在这一步中，链接器修改代码节和数据节中对每个符号的 引用，使得 它们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目 标模块中称为重定位条 目(relocation entry)的数据结构，我们接下来将会描述这种 数据结构。</p>
<p>重定位条目<br>
当汇编器生成一个目标模块时，它并不知道数据和代码最终将放在内存中的什么位 置。它也不知 道这个模块引用的任何外部定义的函数或者全局变量的位置。所以，无论何 时汇编器遇到对最终位置 未知的目标引用，它就会生成一个重定位条目，告诉链接器在将 目标文件合并成可执行文件时如何修 改这个引用。代码的重定位条目放在.rel.text中。 已初始化数据的重定位条目放在.rel.data中。</p>
<p>可执行目标文件<br>
<img src="https://lixin-scut.github.io//post-images/1584193261586.png" alt=""><br>
可执行目标文件的格式类似于可重定位目标文件的格式。ELF 头描述文件的总体格式。它还包括程序的入口点(entry point),也就是当程序运行时要执行的第一条指令的地 址。.text, .rodata 和.data 节 与可重定位目标文件中的节是相似的，除了这些节已经被 重定位到它们最终的运行时内存地址以外 o.init 节定义了一个小函数，叫做_init,程序 的初始化代码会调用它。因为可执行文件是完全链接的(已 被重定位)，所以它不再需要. rel 节。ELF可执行文件被设计得很容易加载到内存，可执行文件的连续的片(chunk)被映射 到连续的 内存段。程序头部表(program header table)描述了这种映射关系。<br>
图 7-14 展示 了可执行文件 prog 的程序头部表，是由 OBJDUMP 显示的。<br>
<img src="https://lixin-scut.github.io//post-images/1584193334840.png" alt=""><br>
对于任何段 s,链接器必须选择一个起始地址 vaddr,使得 vaddr mod align = off mod align<br>
这里，Off 是目标文件中段的第一个节的偏移量，align 是程序头部中指定的对齐</p>
<p>加载可执行目标文件<br>
要运行可执行目标文件 prog,我们可以在 Linux shell 的命令行中输入它的名字: linux&gt; ./prog<br>
因为 prog 不是一个内置的 shell 命令，所以 shell 会认为 prog 是一个可执行目标文 件，通过调用 某个驻留在存储器中称为加载器(loader)的操作系统代码来运行它。任何 Linux程序都可以通过调用 execve 函数来调用加载器，我们将在 8. 4.6 节中详细描述这 个函数。加载器将可执行目标文件中的代 码和数据从磁盘复制到内存中，然后通过跳转到程 序的第一条指令或入口点来运行该程序。这个将程 序复制到内存并运行的过程叫做加载。</p>
<p>每个 Linux 程序都有一个运行时内存映像，类似于图 7-15 中所示。在 Lmux x86-64 系统中，代码 段总是从地址 0x400000 处开始，后面是数据段。运行时堆在数据段之后， 通过调用 malloc 库往上增 长。(我们将在 9. 9 节中详细描述 mallow 和堆。)堆后面的区域 是为共享模块保留的。用户栈总是从 最大的合法用户地址(248 - 1 )开始，向较小内存地址 增长。栈上的区域，从地址 2&quot;开始，是为内核 (kernel)中的代码和数据保留的，所谓内核 就是操作系统驻留在内存的部分。</p>
<p>为了简洁，我们把堆、数据和代码段画得彼此相邻，并且把栈顶放在了最大的合法用 户地址处。 实际上，由于.data段有对齐要求(见7.8节)，所以代码段和数据段之间是有 间隙的。同时，在分配 栈、共享库和堆段运行时地址的时候，链接器还会使用地址空间布 局随机化(ASLR,参见 3. 10.4 节)。 虽然每次程序运行时这些区域的地址都会改变，它们 的相对位置是不变的。<br>
当加载器运行时，它创建类似于图 7-15 所示的内存映像。在程序头部表的引导下， 加载器将可 执行文件的片(chunk)复制到代码段和数据段。接下来，加载器跳转到程序的入口点,也就是_start 函数的地址。这个函数是在系统目标文件 ctrl.o 中定义的，对所 有的 C 程序都是 一样的。.—start函数调用系统启动函数 libc_start_main,该函数定 义在libc.so中。它初始化执行环境， 调用用户层的 main 函数，处理 main 函数的返回 值，并且在需要的时候把控制返回给内核。<br>
<img src="https://lixin-scut.github.io//post-images/1584193435763.png" alt=""></p>
<p>动态链接共享库</p>
<p>动态链接共享库<br>
  静态库仍然有一些明显的缺点。静态库和所有的软件一样，需要定期维护 和更新。<br>
  共享库(shared library)是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接 起来。这个过程称为动态链接(dynamic linking),是由一个叫做动态链接器(dynamic linker) 的程序来执行的。共享库也称为共享目标(shared object),在Linux系统中通常用.s后缀<br>
  共享库是以两种不同的方式来“共享&quot;的。首先，在任何给定的文件系统 中，对于一个库只有一个.s文件。所 有引用该库的可执行目标文件共享这个. s文件中的代码和数据，而不是像静态库的内容那样被复制和嵌入到引用它们的可执行的文件中。其次，在内存中一个共享库的.text节的一个副本可以 被不同的正在运行的进程共享。<br>
<img src="https://lixin-scut.github.io//post-images/1584195434210.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[多线程 1115:交替打印FooBar]]></title>
        <id>https://lixin-scut.github.io//post/duo-xian-cheng-1115jiao-ti-da-yin-foobar</id>
        <link href="https://lixin-scut.github.io//post/duo-xian-cheng-1115jiao-ti-da-yin-foobar">
        </link>
        <updated>2020-03-14T04:04:07.000Z</updated>
        <content type="html"><![CDATA[<pre><code>class FooBar {
  public void foo() {
    for (int i = 0; i &lt; n; i++) {
      print(&quot;foo&quot;);
    }
  }
  public void bar() {
    for (int i = 0; i &lt; n; i++) {
      print(&quot;bar&quot;);
    }
  }
}
</code></pre>
<blockquote>
<p>我们提供一个类：<br>
两个不同的线程将会共用一个 FooBar 实例。其中一个线程将会调用 foo() 方法，另一个线程将会调用 bar() 方法。<br>
请设计修改程序，以确保 &quot;foobar&quot; 被输出 n 次。<br>
示例 1:<br>
输入: n = 1<br>
输出: &quot;foobar&quot;<br>
解释: 这里有两个线程被异步启动。其中一个调用 foo() 方法, 另一个调用 bar() 方法，&quot;foobar&quot; 将被输出一次。<br>
示例 2:<br>
输入: n = 2<br>
输出: &quot;foobarfoobar&quot;<br>
解释: &quot;foobar&quot; 将被输出两次。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/print-foobar-alternately<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这一题是我针对多线程特地找的<br>
这里只涉及了两个线程，所以只需一个条件<br>
然后使用互斥锁和条件变量相互配合<br>
需要注意的点：</p>
<ol>
<li>初始化使用的是指针</li>
<li>信号量的形参什么时候需要用到锁</li>
<li>不传入指针的地方要用nullptr而不是null</li>
<li>修改变量、通知条件变量和解锁的时机</li>
</ol>
<pre><code>class FooBar {
private:
    int n;
    pthread_mutex_t mutex;
    pthread_cond_t cond;
    bool printFooBool = true;
    
public:
    FooBar(int n) 
    {
        this-&gt;n = n;
        pthread_mutex_init(&amp;mutex, nullptr);
        pthread_cond_init(&amp;cond, nullptr);        
    }
    
    void foo(function&lt;void()&gt; printFoo) 
    {
        for (int i = 0; i &lt; n; i++) 
        {
            pthread_mutex_lock(&amp;mutex);
            while(!printFooBool)
            {
                pthread_cond_wait(&amp;cond,&amp;mutex);
            }
        	// printFoo() outputs &quot;foo&quot;. Do not change or remove this line.
        	printFoo();
             printFooBool = false;
            pthread_cond_signal(&amp;cond);
            pthread_mutex_unlock(&amp;mutex);
        }       
    }

    void bar(function&lt;void()&gt; printBar) 
    {  
        for (int i = 0; i &lt; n; i++) 
        {
            pthread_mutex_lock(&amp;mutex);
            while(printFooBool)
            {
                    pthread_cond_wait(&amp;cond,&amp;mutex);
            }
        	// printBar() outputs &quot;bar&quot;. Do not change or remove this line.
        	printBar();
            printFooBool = true;
            pthread_cond_signal(&amp;cond);
            pthread_mutex_unlock(&amp;mutex);
        }
    }    
};
</code></pre>
<p>然后网友题解，其实题解有很多种，我只是为了复习互斥量和条件变量特地用得这两个配合，其实完全可以两个互斥量和信号量等，甚至可以考虑无锁</p>
<p>网友题解：<br>
首先贴个参考链接：<a href="https://zhuanlan.zhihu.com/p/81626432">玩转Leetcode多线程——JAVA线程协助工具类实战</a><br>
方案一：Semaphore<br>
在该场景下有点类似红绿灯交替变换的情境，因此信号量成了首选思路：</p>
<pre><code>java
class FooBar {
    private int n;

    public FooBar(int n) {
        this.n = n;
    }

    Semaphore foo = new Semaphore(1);
    Semaphore bar = new Semaphore(0);

    public void foo(Runnable printFoo) throws InterruptedException {
        for (int i = 0; i &lt; n; i++) {
            foo.acquire();
            printFoo.run();
            bar.release();
        }
    }

    public void bar(Runnable printBar) throws InterruptedException {
        for (int i = 0; i &lt; n; i++) {
            bar.acquire();
            printBar.run();
            foo.release();
        }
    }
}
</code></pre>
<p>方案二：Lock（公平锁）<br>
公平锁也是实现交替执行一个不错的选择：</p>
<pre><code>class FooBar {
    private int n;

    public FooBar(int n) {
        this.n = n;
    }

    Lock lock = new ReentrantLock(true);
    volatile boolean permitFoo = true;

    public void foo(Runnable printFoo) throws InterruptedException {
        
        for (int i = 0; i &lt; n; ) {
            lock.lock();
            try {
            	if(permitFoo) {
            	    printFoo.run();
                    i++;
                    permitFoo = false;
            	}
            }finally {
            	lock.unlock();
            }
        }
    }

    public void bar(Runnable printBar) throws InterruptedException {
        for (int i = 0; i &lt; n; ) {
            lock.lock();
            try {
            	if(!permitFoo) {
            	    printBar.run();
            	    i++;
            	    permitFoo = true;
            	}
            }finally {
            	lock.unlock();
            }
        }
    }
}
</code></pre>
<p>方案三：无锁<br>
以上的公平锁方案完全可以改造成无锁方案：</p>
<pre><code>class FooBar {
    private int n;

    public FooBar(int n) {
        this.n = n;
    }

    volatile boolean permitFoo = true;

    public void foo(Runnable printFoo) throws InterruptedException {     
        for (int i = 0; i &lt; n; ) {
            if(permitFoo) {
        	printFoo.run();
            	i++;
            	permitFoo = false;
            }
        }
    }

    public void bar(Runnable printBar) throws InterruptedException {       
        for (int i = 0; i &lt; n; ) {
            if(!permitFoo) {
        	printBar.run();
        	i++;
        	permitFoo = true;
            }
        }
    }
}
</code></pre>
<p>方案四：CyclicBarrier<br>
在场景一中提过，CyclicBarrier更适合用在循环场景中，那么我们来试一下：</p>
<pre><code>class FooBar {
    private int n;

    public FooBar(int n) {
        this.n = n;
    }

    CyclicBarrier cb = new CyclicBarrier(2);
    volatile boolean fin = true;

    public void foo(Runnable printFoo) throws InterruptedException {
        for (int i = 0; i &lt; n; i++) {
            while(!fin);
            printFoo.run();
            fin = false;
            try {
		cb.await();
	    } catch (BrokenBarrierException e) {
	    }
        }
    }

    public void bar(Runnable printBar) throws InterruptedException {
        for (int i = 0; i &lt; n; i++) {
            try {
		cb.await();
	    } catch (BrokenBarrierException e) {
	    }
            printBar.run();
            fin = true;
        }
    }
}
</code></pre>
<p>然后是双mutex交替加锁</p>
<pre><code>代码
class FooBar {
private:
    int n;
    std::mutex m1, m2;

public:
    FooBar(int n) {
        this-&gt;n = n;
        m2.lock();
    }

    void foo(function&lt;void()&gt; printFoo) {
        
        for (int i = 0; i &lt; n; i++) {
            m1.lock();
        	printFoo();
            m2.unlock();
        }
    }

    void bar(function&lt;void()&gt; printBar) {
        
        for (int i = 0; i &lt; n; i++) {
            m2.lock();
        	printBar();
            m1.unlock(); 
        }
    }

};

</code></pre>
<p>无锁实现：<br>
解题思路<br>
题目相当于两个线程同步运行 可以把锁定互斥元看做一个release,释放互斥元看做一个acquire,用内存序来确保同步,最重要的是自旋的时候一定在条件不满足时让出时间片,即yield操作,否则时间消耗极高,也很好理解,cpu一直在无休止的空转,至此完成.</p>
<pre><code>class FooBar{
private:
	int n;
	std::atomic&lt;bool&gt; flag;
public:
	FooBar(int n): flag(true) {
	this-&gt;n = n;
}

void foo(function&lt;void()&gt; printFoo) {
    for (int i = 0; i &lt; n; i++) {
        while(!flag.load(std::memory_order_acquire))
            std::this_thread::yield();
    	// printFoo() outputs &quot;foo&quot;. Do not change or remove this line.
    	printFoo();
        flag.store(false, std::memory_order_release);
    }
}

void bar(function&lt;void()&gt; printBar) {  
    for (int i = 0; i &lt; n; i++) {
        while(flag.load(std::memory_order_acquire))
            std::this_thread::yield();
    	// printBar() outputs &quot;bar&quot;. Do not change or remove this line.
    	printBar();
        flag.store(true, std::memory_order_release);
    }
	}
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 题 66:构建乘积数组]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-ti-66gou-jian-cheng-ji-shu-zu</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-ti-66gou-jian-cheng-ji-shu-zu">
        </link>
        <updated>2020-03-14T02:48:26.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>...*A[i-1]<em>A[i+1]</em>...*A[n-1]。不能使用除法。（注意：规定B[0] = A[1] * A[2] * ... * A[n-1]，B[n-1] = A[0] * A[1] * ... * A[n-2];）</p>
</blockquote>
<p>这道题也在leetcode遇到过，其实就是利用两次不同方向的遍历来完成就好<br>
需要注意的是细节问题</p>
<ol>
<li>res数组和累乘积初始化为1</li>
<li>当前位置和上一位置的乘积和累乘的处理。</li>
</ol>
<pre><code>class Solution {
public:
    vector&lt;int&gt; multiply(const vector&lt;int&gt;&amp; A) {
        if(A.empty())
            return vector&lt;int&gt;();
        int len = A.size();
        vector&lt;int&gt; res(len,1);
        int product;
        product = 1;
        for(int i = 0; i &lt; len; ++i)
        {
            res[i] *= product;
            product *= A[i];
        }
        product = 1;
        for(int i = len-1; i &gt;= 0; --i)
        {
            res[i] *= product;
            product *= A[i];
        }
        return res;
    }
};
</code></pre>
<p>书本题解：<br>
<img src="https://lixin-scut.github.io//post-images/1584154330868.png" alt=""></p>
<pre><code>void BuildProductionArray(const vector&lt;double&gt;&amp; input, vector&lt;double&gt;&amp; output)
{
    int length1 = input.size();
    int length2 = output.size();

    if(length1 == length2 &amp;&amp; length2 &gt; 1)
    {
        output[0] = 1;
        for(int i = 1; i &lt; length1; ++i)
        {
            output[i] = output[i - 1] * input[i - 1];
        }

        double temp = 1;
        for(int i = length1 - 2; i &gt;= 0; --i)
        {
            temp *= input[i + 1];
            output[i] *= temp;
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math 题65:不用加减乘除做加法[未做出]]]></title>
        <id>https://lixin-scut.github.io//post/math-ti-65bu-yong-jia-jian-cheng-chu-zuo-jia-fa-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/math-ti-65bu-yong-jia-jian-cheng-chu-zuo-jia-fa-wei-zuo-chu">
        </link>
        <updated>2020-03-14T02:41:30.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p>
</blockquote>
<p>【未做出】<br>
第一个想法是模仿计算机底层的相加操作，亦即异或和进位。<br>
但是在进位的时候遇到困难了<br>
其实求进位本身不难，就是如何和普通的单位相加融合<br>
最终我的想法和书本的一致，不可能在一次循环内完成异或和进位的，必须分开计算，一次一次地计算；<br>
这样子就比较简单了，将异或和进位分开保存，然后再不断循环得到两个结果的异或和进位，直到没有进位<br>
记得进位一定要左移</p>
<pre><code>class Solution {
public:
    int Add(int num1, int num2)
    {
        int flag;
        int temp;
        //int bit;
        //res = 0;
        //bit = 1;
        while(num2)
        {
            temp = num1 ^ num2;
            flag = num1 &amp; num2;
            num1 = temp;
            num2 = flag &lt;&lt; 1; // 不要忘了移位
        }
        return num1;
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>把二进制的加法用位运算来替代。第一步不考虑进位对每一位相 加。0 加 0、1 加 1 的结果都是 0，0 加 1、1 加 0 的结果都是 1。 我们注意到，这和异或的结果是一样的。对异或而言，0 和 0、1和 1 的异或结果是 0,而 0 和 1、1 和 0 的异或 结果是 1。接着考虑第二步进位，对 0 加 0、0 加 1、1 加 0 而言，都不会产生进位，只 有 1 加 1 时，会向前产生一个进位。此时我们可以想象成两个数先做位与运算，然后再向左移动一位。 只有两个数都是 1 的时候，位与得到的结果是 1，其余都是 0。第三步把前两个步骤的结果相加。第三步相加的过程依然是重复前面两步，直到不产生进位为止。</p>
</blockquote>
<pre><code>int Add(int num1, int num2)
{
    int sum, carry;
    do
    {
        sum = num1 ^ num2;
        carry = (num1 &amp; num2) &lt;&lt; 1;

        num1 = sum;
        num2 = carry;
    }
    while(num2 != 0);

    return num1;
}
</code></pre>
]]></content>
    </entry>
</feed>