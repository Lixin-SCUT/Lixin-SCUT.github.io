<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-12-20T01:39:11.666Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[二分查找 350. 两个数组的交集 II[简单]]]></title>
        <id>https://lixin-ee.github.io//post/er-fen-cha-zhao-350-liang-ge-shu-zu-de-jiao-ji-iijian-dan</id>
        <link href="https://lixin-ee.github.io//post/er-fen-cha-zhao-350-liang-ge-shu-zu-de-jiao-ji-iijian-dan">
        </link>
        <updated>2019-12-20T00:54:06.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定两个数组，编写一个函数来计算它们的交集。<br>
示例 1:<br>
输入: nums1 = [1,2,2,1], nums2 = [2,2]<br>
输出: [2,2]<br>
示例 2:<br>
输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br>
输出: [4,9]<br>
说明：<br>
输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。<br>
我们可以不考虑输出结果的顺序。<br>
进阶:<br>
如果给定的数组已经排好序呢？你将如何优化你的算法？<br>
如果 nums1 的大小比 nums2 小很多，哪种方法更优？<br>
如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题其实就是349的进化版，我把插入的判断条件去掉了，<br>
然后其实还是没有符合进阶条件的要求<br>
一是如果两数组相差较大的时候怎么处理<br>
如果大小相差很大，我就想特别是如果num2无法全部插入内存的情况，好好看看题解</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        int len1=nums1.size(),len2=nums2.size();
        vector&lt;int&gt; res;
        if(len1==0||len2==0) return res;
        quicksort(nums1,nums1.begin(),nums1.end()-1);
        quicksort(nums2,nums2.begin(),nums2.end()-1);
        for(int i=0,j=0;i&lt;len1&amp;&amp;j&lt;len2;){
            if(nums1[i]==nums2[j]){
                //if(res.empty()||res.back()!=nums1[i])
                    res.push_back(nums1[i]);
                ++i,++j;
            }
            else if(nums1[i]&lt;nums2[j])
                ++i;
            else
                ++j;
        }
        return res;
    }
		
		    void quicksort(vector&lt;int&gt; &amp;vi,vector&lt;int&gt;::iterator low,vector&lt;int&gt;::iterator high){
        vector&lt;int&gt;::iterator middle;
        if(low&lt;high){
            middle=partition(vi,low,high);
            quicksort(vi,low,middle);
            quicksort(vi,++middle,high);
        }
    }
    
    vector&lt;int&gt;::iterator partition(vector&lt;int&gt; &amp;vi, vector&lt;int&gt;::iterator low, vector&lt;int&gt;::iterator high){
        int pivotkey;
        if(low&lt;high){
            pivotkey=*low;
            while(low&lt;high){
                while(low&lt;high&amp;&amp;pivotkey&lt;=*high)
                    --high;
                iter_swap(low,high);
                while(low&lt;high&amp;&amp;*low&lt;=pivotkey)
                    ++low;
                iter_swap(low,high);
            }
        }
        return low;
    }
};
</code></pre>
<p>然后来看看网友题解：<br>
第一个就是我想到的349的set演化为map，主要是用于存储某个数的出现次数，我觉得可以用这个方法来优化2和3，就是把长度更短的存进map或者set，这样子就不需要较长的序列进行排序或者一次性读取到内存了。</p>
<blockquote>
<p>解法一：哈希表<br>
时间复杂度O(n)<br>
先用Hashmap记录第一个数组中的元素【放在key】，和出现的次数【放在value】。<br>
然后再遍历第二个数组，如果找到对应元素，则添加这个元素到返回数组里。<br>
如果value值大于1，HashMap中的value值减 1，表示已经找到一个相同的了。<br>
如果value值等于1，则删除该元素。</p>
</blockquote>
<pre><code>//代码我换成另一位作者的C++代码了
class Solution {
public:
    vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        vector&lt;int&gt;rec;
        unordered_map&lt;int,int&gt;map;
        for(int i =0;i&lt;nums1.size();i++)
            map[nums1[i]]+=1;
        for(int i =0;i&lt;nums2.size();i++)
           if(map[nums2[i]]&gt;0)
           {
               rec.push_back(nums2[i]);
               map[nums2[i]]-=1;
           }
               
        return rec;

    }
};
</code></pre>
<p>我自己的复现：</p>
<pre><code>class Solution {
public:
    //优化条件2 3 的hashmap方法
    vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        int len1=nums1.size(),len2=nums2.size();
        unordered_map&lt;int,int&gt; elem;
        vector&lt;int&gt; res;
        if(len1&lt;len2){
            add_elem(elem,nums1);
            find_intersect(elem,nums2,res);
        }else{
            add_elem(elem,nums2);
            find_intersect(elem,nums1,res);
        }
        return res;  
    }
    
    void add_elem(unordered_map&lt;int,int&gt; &amp;elem,vector&lt;int&gt; &amp;nums){
        for(auto i:nums)
            if(elem.count(i))
                ++elem[i];
            else
                elem.insert({i,1});
        
    }
    
    void find_intersect(unordered_map&lt;int,int&gt; &amp;elem,vector&lt;int&gt; &amp;nums,vector&lt;int&gt; &amp;res){
        for(auto i:nums)
            if(elem.count(i)&amp;&amp;elem[i]&gt;0){
                res.push_back(i);
                --elem[i];
            }
        
    }
};

</code></pre>
<p>昨天看面经说大公司很注重变量的命名和代码的面向过程性，所以特地查了一下字典并特地写了两个函数</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二分查找 349. 两个数组的交集[简单]]]></title>
        <id>https://lixin-ee.github.io//post/er-fen-cha-zhao-349-liang-ge-shu-zu-de-jiao-ji-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/er-fen-cha-zhao-349-liang-ge-shu-zu-de-jiao-ji-jian-dan">
        </link>
        <updated>2019-12-19T01:59:57.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定两个数组，编写一个函数来计算它们的交集。<br>
示例 1:<br>
输入: nums1 = [1,2,2,1], nums2 = [2,2]<br>
输出: [2]<br>
示例 2:<br>
输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br>
输出: [9,4]<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/intersection-of-two-arrays<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>我的第一想法居然是暴力法hhh 比如哈希表，虽然看起来代码量少了很多，但是其实只是把工作留给哈希表做了<br>
第二想法是对两者进行排序，然后用双指针进行提取相同元素<br>
但这道题归属于二分查找分类，我能想到的只有对长序列进行排序，然后利用较短序列中的元素去逐个二分查找是否存在于长序列中 但是此时又需要考虑短序列中重复元素的问题 只能看看题解中有没有好的基于二分法思想的题解吧</p>
<p>最后打算直接用第二想法，差点又栽在if else上，记得不能拆分单独if<br>
然后！！！居然被自己的写的代码坑了！！！我跑回去找了快速排序的迭代器版实现，照着抄都抄错就不说了，居然！！！把end()迭代器传进去了！！！然后疯狂地溢出报错，一开始还以为是双指针那边错了，后来才发现必须是end()-1 而不是end()</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        int len1=nums1.size(),len2=nums2.size();
        vector&lt;int&gt; res;
        if(len1==0||len2==0) return res;
        quicksort(nums1,nums1.begin(),nums1.end()-1);
        quicksort(nums2,nums2.begin(),nums2.end()-1);
        for(int i=0,j=0;i&lt;len1&amp;&amp;j&lt;len2;){
            if(nums1[i]==nums2[j]){
                if(res.empty()||res.back()!=nums1[i])
                    res.push_back(nums1[i]);
                ++i,++j;
            }
            else if(nums1[i]&lt;nums2[j])
                ++i;
            else
                ++j;
        }
        return res;
    }
		    
    void quicksort(vector&lt;int&gt; &amp;vi,vector&lt;int&gt;::iterator low,vector&lt;int&gt;::iterator high){
        vector&lt;int&gt;::iterator middle;
        if(low&lt;high){
            middle=partition(vi,low,high);
            quicksort(vi,low,middle);
            quicksort(vi,++middle,high);
        }
    }
    
    vector&lt;int&gt;::iterator partition(vector&lt;int&gt; &amp;vi, vector&lt;int&gt;::iterator low, vector&lt;int&gt;::iterator high){
        int pivotkey;
        if(low&lt;high){
            pivotkey=*low;
            while(low&lt;high){
                while(low&lt;high&amp;&amp;pivotkey&lt;=*high)
                    --high;
                iter_swap(low,high);
                while(low&lt;high&amp;&amp;*low&lt;=pivotkey)
                    ++low;
                iter_swap(low,high);
            }
        }
        return low;
    }
};
</code></pre>
<p>然后来看看官方题解的set解法吧<br>
<strong>注意：C++中的set是基于红黑树的有序容器，unordered_set才是基于哈希函数的无序容器，前者维护元素顺序的代价很高，只有后者在理想情况下才能做到常数时间的增删查改</strong><br>
方法一：两个 set<br>
幼稚的方法是根据第一个数组 nums1 迭代并检查每个值是否存在在 nums2 内。如果存在将值添加到输出。这样的方法会导致O(n×m) 的时间复杂性，其中 n 和 m 是数组的长度。<br>
为了在线性时间内解决这个问题，我们使用集合 set，在 O(1) 时间复杂度实现操作。<br>
其思想是将两个数组转换为集合 set，然后迭代较小的集合检查是否存在在较大集合中。平均情况下，这种方法的时间复杂度为 O(n+m)。</p>
<p>这里我改贴网友的C++代码而不是官网的JAVA，以映射前面的注意事项</p>
<p>本解法所用时仅次于使用C++内置的sort和set_intersection（使用STL基本可以肯定会是最快的，但面试等情况未必可用）。<br>
优点：<br>
1、使用无序集合而非一般集合或无序图，节约了时空<br>
2、在检索无序集合时，将检索到的元素删去，而不是遍历answer数组，面对越大规模的问题，该方法效率越优。</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        unordered_set&lt;int&gt; u;
        vector&lt;int&gt; answer;
        for(int i:nums1)
            u.insert(i);
        for(int i:nums2){
            auto a = u.find(i);
            if(a!=u.end()){
                answer.push_back(i);
                u.erase(a);
            }
        }
        return answer;
    }
};
</code></pre>
<p>时间复杂度：O(m+n)，其中 n 和 m 是数组的长度。O(n) 的时间用于转换 nums1 在集合中，O(m) 的时间用于遍历nums，平均情况下集合的操作为 O(1)。<br>
空间复杂度：O(m+n)，最坏的情况是数组中的所有元素都不同。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[堆排序实现]]></title>
        <id>https://lixin-ee.github.io//post/dui-pai-xu-shi-xian</id>
        <link href="https://lixin-ee.github.io//post/dui-pai-xu-shi-xian">
        </link>
        <updated>2019-12-18T09:50:09.000Z</updated>
        <content type="html"><![CDATA[<p>堆排序（Heap Sort)就是利用堆（假设利用大顶堆）进行排序的方法。它的基本思想是， 将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根结点。将它移走 （其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），然后将剩余的n-1个 序列重新构造成一个堆，这样就会得到n个元素中的次小值。如此反复执行，便能得到一个有序序列了。<br>
整个排序过程分为两个for循环。<strong>第一个循环要完成的就是将现在的待排序序列构建成一个大顶堆</strong>。第二个循环要完成的就是逐步将每个最大值的根结点与末尾元素交换，并且再调整其成为大顶堆。<br>
所以注意！！！第一个循环后并非是有序顺序，大顶堆和二叉树不同，并非左子树的节点都小于右子树<br>
循环从(length-1)/2开始是因为从1到(length-1)/2都是有孩子的节点<br>
我们所谓的将待排序的序列构建成为一个大顶堆，其实就是从下往上、从右到左，将每个非终端结点（非叶结点）当作根结点，将其和其子树调整成大顶堆<br>
堆排序复杂度分析<br>
运行时间主要是消耗在初始构建堆和在重建堆时的反复筛选上。<br>
在构建堆的过程中，因为我们是完全二叉树从最下层最右边的非终端结点开始构 建，将它与其孩子迸行比较和若有必要的互换，对于每个非终端结点来说，其实最多进行两次比较和互换操作（和左右孩子进行比较？），因此整个构建堆的时间复杂度为o(n)。<br>
在正式排序时，第i次取堆顶记录重建堆需要用O(logi)的时间（完全二叉树的某个结点到根结点的距离为floor(logi)+1,并且需要取n-1次堆顶记录，因此，重建堆的时间复杂度为〇(nlogn)<br>
所以总体来说，堆排序的时间复杂度为〇(nlogn)。由于堆排序对原始记录的排序状态并 不敏感，因此它无论是最好、最坏和平均时间复杂度均为〇(nlogn)。<br>
空间复杂度上，它只有一个用来交换的暂存单元，也非常的不错。不过由于记录的比较与 交换是跳跃式进行，因此堆排序也是一种不稳定的排序方法。<br>
不过由于记录的比较与交换是跳跃式进行，因此堆排序也是一种<strong>不稳定的排序</strong>方法。</p>
<pre><code>    int main(vector&lt;int&gt;&amp; nums) {
        int len=nums.size();
        for(int i=(len-1)/2;i&gt;=0;--i)
            HeapAdjust(nums,i,len);
        
        for(int i=len-1;i&gt;0;--i){
            swap(nums[0],nums[i]);
            HeapAdjust(nums,0,i);
        }
    }
    
    void HeapAdjust(vector&lt;int&gt; &amp;nums,int s,int len){
            int temp=nums[s];
            for(int j=2*s+1;j&lt;len;j=2*j+1){
                if(j&lt;len-1&amp;&amp;nums[j+1]&gt;nums[j])
                    ++j;
                if(temp&gt;nums[j])
                    break;
                nums[s]=nums[j];
                s=j;
            }
            nums[s]=temp;
    }
</code></pre>
<p>实现需要注意的点就是理解每次循环的意义<br>
亦即调整过程中s和j的关系变化</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二分查找 34. 在排序数组中查找元素的第一个和最后一个位置[中等]]]></title>
        <id>https://lixin-ee.github.io//post/er-fen-cha-zhao-34-zai-pai-xu-shu-zu-zhong-cha-zhao-yuan-su-de-di-yi-ge-he-zui-hou-yi-ge-wei-zhi-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/er-fen-cha-zhao-34-zai-pai-xu-shu-zu-zhong-cha-zhao-yuan-su-de-di-yi-ge-he-zui-hou-yi-ge-wei-zhi-zhong-deng">
        </link>
        <updated>2019-12-18T02:19:12.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。<br>
你的算法时间复杂度必须是 O(log n) 级别。<br>
如果数组中不存在目标值，返回 [-1, -1]。<br>
示例 1:<br>
输入: nums = [5,7,7,8,8,10], target = 8<br>
输出: [3,4]<br>
示例 2:<br>
输入: nums = [5,7,7,8,8,10], target = 6<br>
输出: [-1,-1]<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>一开始感觉的难点是 1.判断target是否存在于数组中 2.target的范围可能跨越了mid<br>
是否可以化为寻找第一个大于target的数 和最后小于target的数？<br>
需要分开两次寻找，然后需要判断mid的左右值来移动<br>
但是又会遇到边界条件。。。<br>
似乎只需要判断其中一边<br>
这道题似乎利用到了mid 的左倾和右倾</p>
<p>但是有问题，比如9 9 9 9 9中找1，那第一个最小值是找不到的（似乎可以在开头加上判断条件）</p>
<p>同时希望修改思路为寻找最左边符合条件的数和最右边符合条件的数</p>
<p>完全可以通过判断条件和左倾右倾来达到寻找最左边符合条件的数和最右边符合条件的数</p>
<p>然后发现完全可以第一次寻找的时候就发现数组中是否有target，可以立即返回{-1,-1}</p>
<p>然后需要判断是否为空empty。。。</p>
<p>最后的话就看看可不可以合并两次查找，虽然时间复杂度符合了但是不够优雅</p>
<p>原思路代码</p>
<pre><code> /*
        原思路
        while(first&lt;last){
            mid=first+(last-first)/2;
            if(nums[mid+1]&gt;=target)
                last=mid;
            else first=mid+1;
        }
        left=first;
        first=0,last=nums.size()-1;
        while(first&lt;last){
            mid=first+(last-first+1)/2;
            if(nums[mid-1]&lt;=target)
                first=mid;
            else  last=mid-1;
        }
        right=first;
        */
</code></pre>
<p>正确代码：</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) {
        if(nums.empty()||nums[0]&gt;target||nums[nums.size()-1]&lt;target) return vector&lt;int&gt;({-1,-1});
        int first=0,last=nums.size()-1,mid,left,right;
        while(first&lt;last){
            mid=first+(last-first)/2;
            if(nums[mid]&gt;=target)
                last=mid;
            else first=mid+1;
        }
        left=first;
        
        if(nums[left]!=target)
            return vector&lt;int&gt;({-1,-1});
        first=0,last=nums.size()-1;
         while(first&lt;last){
            mid=first+(last-first+1)/2;
            if(nums[mid]&lt;=target)
                first=mid;
            else  last=mid-1;
        }
        right=first;
        
        return vector&lt;int&gt;({left,right});
            }
};
</code></pre>
<p>题解的话思路一致，还是得使用左倾右倾各自循环一次<br>
然后就建议反复看<a href="https://lixin-ee.github.io/post/er-fen-cha-zhao-fa-mo-ban/">二分查找模板</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二分查找 374. 猜数字大小[简单]]]></title>
        <id>https://lixin-ee.github.io//post/er-fen-cha-zhao-374-cai-shu-zi-da-xiao</id>
        <link href="https://lixin-ee.github.io//post/er-fen-cha-zhao-374-cai-shu-zi-da-xiao">
        </link>
        <updated>2019-12-17T01:27:26.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>我们正在玩一个猜数字游戏。 游戏规则如下：<br>
我从 1 到 n 选择一个数字。 你需要猜我选择了哪个数字。<br>
每次你猜错了，我会告诉你这个数字是大了还是小了。<br>
你调用一个预先定义好的接口 guess(int num)，它会返回 3 个可能的结果（-1，1 或 0）：<br>
-1 : 我的数字比较小<br>
1 : 我的数字比较大<br>
0 : 恭喜！你猜对了！<br>
示例 :<br>
输入: n = 10, pick = 6<br>
输出: 6<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/guess-number-higher-or-lower<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题其实才应该放到第一题吧。。。那个刷题顺序说实话不算特别严谨<br>
然后其实没啥难的，就是把二分法复现了一下，主要就是mid=first+(last-first)/2;是左倾还是右倾，从而影响后面是first=mid+1还是last=mid-1;<br>
然后吐槽一下题目的语文水平，题目中的我的数字是指要猜的数字而不是mid</p>
<pre><code>// Forward declaration of guess API.
// @param num, your guess
// @return -1 if my number is lower, 1 if my number is higher, otherwise return 0
int guess(int num);

class Solution {
public:
    int guessNumber(int n) {
       int first=1,last=n, mid;
        while(first&lt;last){
            //mid=first+(last-first)/2;
            mid=first+(last-first+1)/2;
            int res=guess(mid);
            if(res==0)
                return mid;
            else if(res==-1)
                //last=mid;
                last=mid-1;
            else
                //first=mid+1;  
                first=mid;
        }
        return first;
    }
};
</code></pre>
<p>这道题就没太多值得讨论的地方了，二分查找基本题<br>
建议看一下<a href="https://lixin-ee.github.io/post/er-fen-cha-zhao-fa-mo-ban/">二分查找法模板</a></p>
<p>然后就是官方题解中的三分查找法<br>
方法 3：三分查找<br>
算法<br>
在二分查找中，我们选择中间元素作为分隔点。而在三分查找中，我们选择两个分隔点（比方记作 m1 和 m2），那么给定范围会被分成 3 个相等长度的部分。如果答案 num 比 m1 小，那么我们对 m1 左边的区间做三分查找。如果 num 在 m1 和 m2 中间，我们对中间区域进行三分查找。否则我们对 m2 右边的区域进行三分查找。</p>
<pre><code>public class Solution extends GuessGame {
    public int guessNumber(int n) {
        int low = 1;
        int high = n;
        while (low &lt;= high) {
            int mid1 = low + (high - low) / 3;
            int mid2 = high - (high - low) / 3;
            int res1 = guess(mid1);
            int res2 = guess(mid2);
            if (res1 == 0)
                return mid1;
            if (res2 == 0)
                return mid2;
            else if (res1 &lt; 0)
                high = mid1 - 1;
            else if (res2 &gt; 0)
                low = mid2 + 1;
            else {
                low = mid1 + 1;
                high = mid2 - 1;
            }
        }
        return -1;
    }
}
</code></pre>
<p>复杂度分析</p>
<p>时间复杂度： O(log_3 n)为三分查找所需的时间复杂度。<br>
空间复杂度： O(1) 。没有使用额外的空间。</p>
<p>看起来三分查找会比二分查找更快，但是为什么二分查找使用得更广泛？<br>
二分查找和三分查找的比较<br>
<img src="https://lixin-ee.github.io//post-images/1576546844828.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二分查找 162. 寻找峰值[中等]]]></title>
        <id>https://lixin-ee.github.io//post/er-fen-cha-zhao-162-xun-zhao-feng-zhi-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/er-fen-cha-zhao-162-xun-zhao-feng-zhi-zhong-deng">
        </link>
        <updated>2019-12-16T03:16:16.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>峰值元素是指其值大于左右相邻值的元素。<br>
给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。<br>
数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。<br>
你可以假设 nums[-1] = nums[n] = -∞。<br>
示例 1:<br>
输入: nums = [1,2,3,1]<br>
输出: 2<br>
解释: 3 是峰值元素，你的函数应该返回其索引 2。<br>
示例 2:<br>
输入: nums = [1,2,1,3,5,6,4]<br>
输出: 1 或 5<br>
解释: 你的函数可以返回索引 1，其峰值元素为 2；<br>
     或者返回索引 5， 其峰值元素为 6。<br>
说明:<br>
你的解法应该是 O(logN) 时间复杂度的。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/find-peak-element<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题又和普通的二分查找有区别<br>
我一开始的想法是递归调用二分查找，因为数组是无序的，所以需要两边都继续查找下去，相当于树的每个节点都要搜索到。</p>
<p>突然发现又读错题了，因为示例2中说明其实返回其中一个峰值就好，不需要返回最大的峰值</p>
<p>不过我还是没想到比较好的方法，还是继续老方法</p>
<p>似乎在序列的右边一定会出现峰值（错误 3 7 6 5 0 就不符合）</p>
<p>尝试向递增那一边移动（最后证明这个是正确的，因为相邻两节点不相同，而且两边有负无穷，所以只要一直向递增的方向移动一定会到达峰值，可以把3 7 6 5 0化为连续函数就清楚了）</p>
<p>边界条件着实是麻烦啊，注意(mid!=0&amp;&amp;nums[mid-1]&gt;nums[mid])中的mid!=0不可缺少<br>
幸好边界比较明显，所以最后边界判断也不算特别复杂</p>
<p>主要是：<br>
一开始不小心把三个if分开了，导致一直mid[0-1]错误<br>
然后用else连起来后发现自己在if else和&amp;&amp;的组合判断上犯了一个很严重的错误<br>
if(mid<mark>0&amp;&amp;nums[mid]&gt;nums[mid+1])<br>
return mid;<br>
else if(mid</mark>nums.size()-1&amp;&amp;nums[mid]&gt;nums[mid-1])<br>
return mid;<br>
else if(nums[mid]&gt;nums[mid-1]&amp;&amp;nums[mid]&gt;nums[mid+1])<br>
在这里如果mid==0但是不符合nums[mid]&gt;nums[mid+1]的话！是会继续判断下一个if而不是跳出判断的！！！</p>
<pre><code>class Solution {
public:
    int max=-1;
    int findPeakElement(vector&lt;int&gt;&amp; nums) {
        int first=0,last=nums.size()-1,mid;
        while(first&lt;last){
            mid=first+(last-first)/2;
            if(mid==0){
                if(nums[mid]&gt;nums[mid+1])
                return mid;
            }
            else if(mid==nums.size()-1){
                if(nums[mid]&gt;nums[mid-1])
                return mid;
            }
            else if(nums[mid]&gt;nums[mid-1]&amp;&amp;nums[mid]&gt;nums[mid+1])
                return mid;
             if(mid!=0&amp;&amp;nums[mid-1]&gt;nums[mid])
                 last=mid;
            else
                first=mid+1;
        }
        return first;
    }
};
</code></pre>
<p>然后来看一下题解</p>
<blockquote>
<p>思路<br>
标签：二分查找<br>
过程：<br>
首先要注意题目条件，在题目描述中出现了 nums[-1] = nums[n] = -∞，这就代表着 只要数组中存在一个元素比相邻元素大，那么沿着它一定可以找到一个峰值<br>
根据上述结论，我们就可以使用二分查找找到峰值<br>
查找时，左指针 l，右指针 r，以其保持左右顺序为循环条件<br>
根据左右指针计算中间位置 m，并比较 m 与 m+1 的值，如果 m 较大，则左侧存在峰值，r = m，如果 m + 1 较大，则右侧存在峰值，l = m + 1<br>
时间复杂度：O(logN)<br>
代码</p>
</blockquote>
<pre><code>Java
class Solution {
    public int findPeakElement(int[] nums) {
        int left = 0, right = nums.length - 1;
        for (; left &lt; right; ) {
            int mid = left + (right - left) / 2;
            if (nums[mid] &gt; nums[mid + 1]) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
}
</code></pre>
<p>看完这个题解才发现自己搞复杂了 我的主判断是nums[mid-1]&gt;nums[mid]，但是我的mid计算是左倾的，明显用nums[mid]&gt;nums[mid+1]更加方便，就不会出现超出下标范围的情况了，果然还是欠缺考虑啊<br>
修改代码如下：</p>
<pre><code>class Solution {
public:
    int max=-1;
    int findPeakElement(vector&lt;int&gt;&amp; nums) {
        int first=0,last=nums.size()-1,mid;
        while(first&lt;last){
            mid=first+(last-first)/2;
             if(nums[mid]&gt;nums[mid+1])
                 last=mid;
            else
                first=mid+1;
        }
        return first;
    }
};
</code></pre>
<p>代码简洁了超级多，时间复杂度和空间复杂度也下降了</p>
<p>然后是官方题解解释：<br>
<a href="https://leetcode-cn.com/problems/find-peak-element/solution/xun-zhao-feng-zhi-by-leetcode/">寻找峰值</a><br>
其实方法一致，而且比较难复制，我就不贴了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二分查找 154. 寻找旋转排序数组中的最小值 II[困难]]]></title>
        <id>https://lixin-ee.github.io//post/154-xun-zhao-xuan-zhuan-pai-xu-shu-zu-zhong-de-zui-xiao-zhi-iikun-nan</id>
        <link href="https://lixin-ee.github.io//post/154-xun-zhao-xuan-zhuan-pai-xu-shu-zu-zhong-de-zui-xiao-zhi-iikun-nan">
        </link>
        <updated>2019-12-15T02:33:05.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br>
( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。<br>
请找出其中最小的元素。<br>
注意数组中可能存在重复的元素。<br>
示例 1：<br>
输入: [1,3,5]<br>
输出: 1<br>
示例 2：<br>
输入: [2,2,2,0,1]<br>
输出: 0<br>
说明：<br>
这道题是 寻找旋转排序数组中的最小值 的延伸题目。<br>
允许重复会影响算法的时间复杂度吗？会如何影响，为什么？<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题我也只想到如果边界和mid一样的话就往中间靠拢直至只有一边是异常的<br>
然后处理过程中有点小问题，因为上一题81题的判断条件是(nums[mid]==nums[first]&amp;&amp;nums[mid]==nums[last])<br>
这里有个与逻辑保证了避开mid和first或者mid和last相等时把自身去掉的情况<br>
然后一开始我忽略了这点导致失败了，比如[1,3]会导致1把自己去掉<br>
所以需要加上判断mid!=first和mid!=last才行<br>
时间复杂度和空间复杂度都不堪入目啊，好好看看题解用了啥方法吧</p>
<pre><code>class Solution {
public:
    int findMin(vector&lt;int&gt;&amp; nums) {
        if(nums.empty()) return -1;
        int first=0,last=nums.size()-1,mid;
        while(first&lt;last){
            mid=first+(last-first)/2;
            if(mid!=first&amp;&amp;nums[mid]==nums[first])
                ++first;
            else if(mid!=last&amp;&amp;nums[mid]==nums[last])
                --last;
            else if(nums[mid]&lt;nums[first])
                last=mid;
            else if(nums[mid]&gt;nums[last])
                first=mid+1;
            else
                return nums[first];
        }
        return nums[first];
    }
};
</code></pre>
<p>来看看网友题解吧<br>
<img src="https://lixin-ee.github.io//post-images/1576377717081.png" alt=""></p>
<pre><code>class Solution {
    public int findMin(int[] nums) {
        int left = 0, right = nums.length - 1;
        while (left &lt; right) {
            int mid = (left + right) / 2;
            if (nums[mid] &gt; nums[right]) left = mid + 1;
            else if (nums[mid] &lt; nums[right]) right = mid;
            else right = right - 1;
        }
        return nums[left];
    }
}
</code></pre>
<p>其实思路还是一样的，只能通过缩减边界来处理，最坏情况就等同于顺序搜索了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二分查找 153. 寻找旋转排序数组中的最小值[中等]]]></title>
        <id>https://lixin-ee.github.io//post/er-fen-cha-zhao-153-xun-zhao-xuan-zhuan-pai-xu-shu-zu-zhong-de-zui-xiao-zhi-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/er-fen-cha-zhao-153-xun-zhao-xuan-zhuan-pai-xu-shu-zu-zhong-de-zui-xiao-zhi-zhong-deng">
        </link>
        <updated>2019-12-14T02:47:05.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br>
( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。<br>
请找出其中最小的元素。<br>
你可以假设数组中不存在重复元素。<br>
示例 1:<br>
输入: [3,4,5,1,2]<br>
输出: 1<br>
示例 2:<br>
输入: [4,5,6,7,0,1,2]<br>
输出: 0<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>我一开始的想法是把mid和first last做比较，如果有异常的话说明当前序列有问题，最小值应该处于有异常的一端<br>
没有异常的话就照常处理<br>
判断条件是重点<br>
异常判断分为两个 if(nums[mid]&lt;nums[first])和else if(nums[mid]&gt;nums[last])<br>
最后如果没有异常的话，可以直接返回nums[first]<br>
遇到的小坑就是习惯性返回了first，其实应该是nums[first]</p>
<pre><code>class Solution {
public:
    int findMin(vector&lt;int&gt;&amp; nums) {
        if(nums.empty()) return -1;
        int first=0,last=nums.size()-1,mid;
        while(first&lt;last){
            mid=first+(last-first)/2;
            if(nums[mid]&lt;nums[first])
                last=mid;
            else if(nums[mid]&gt;nums[last])
                first=mid+1;
            else
                return nums[first];
        }
        return nums[first];
    }
};
</code></pre>
<p>然后来看看官方题解：</p>
<blockquote>
<p>方法 1：二分搜索<br>
想法<br>
一种暴力的解法是搜索整个数组，找到其中的最小元素，这样的时间复杂度是 O(N)其中 N 是给定数组的大小。<br>
一个非常棒的解决该问题的办法是使用二分搜索。在二分搜索中，我们找到区间的中间点并根据某些条件决定去区间左半部分还是右半部分搜索。<br>
由于给定的数组是有序的，我们就可以使用二分搜索。然而，数组被旋转了，所以简单的使用二分搜索并不可行。<br>
在这个问题中，我们使用一种改进的二分搜索，判断条件与标准的二分搜索有些不同。<br>
我们希望找到旋转排序数组的最小值，如果数组没有被旋转呢？如何检验这一点呢？<br>
如果数组没有被旋转，是升序排列，就满足 last element &gt; first element。</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1576292058115.png" alt=""></p>
<blockquote>
<p>在这个改进版本的二分搜索算法中，我们需要找到这个点。下面是关于变化点的特点：<br>
所有变化点左侧元素 &gt; 数组第一个元素<br>
所有变化点右侧元素 &lt; 数组第一个元素<br>
算法<br>
找到数组的中间元素 mid。<br>
如果中间元素 &gt; 数组第一个元素，我们需要在 mid 右边搜索变化点。<br>
如果中间元素 &lt; 数组第一个元素，我们需要在 mid 做边搜索变化点。</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1576292147178.png" alt=""></p>
<pre><code>class Solution {
  public int findMin(int[] nums) {
    // If the list has just one element then return that element.
    if (nums.length == 1) {
      return nums[0];
    }

    // initializing left and right pointers.
    int left = 0, right = nums.length - 1;

    // if the last element is greater than the first element then there is no rotation.
    // e.g. 1 &lt; 2 &lt; 3 &lt; 4 &lt; 5 &lt; 7. Already sorted array.
    // Hence the smallest element is first element. A[0]
    if (nums[right] &gt; nums[0]) {
      return nums[0];
    }
    
    // Binary search way
    while (right &gt;= left) {
      // Find the mid element
      int mid = left + (right - left) / 2;

      // if the mid element is greater than its next element then mid+1 element is the smallest
      // This point would be the point of change. From higher to lower value.
      if (nums[mid] &gt; nums[mid + 1]) {
        return nums[mid + 1];
      }

      // if the mid element is lesser than its previous element then mid element is the smallest
      if (nums[mid - 1] &gt; nums[mid]) {
        return nums[mid];
      }

      // if the mid elements value is greater than the 0th element this means
      // the least value is still somewhere to the right as we are still dealing with elements
      // greater than nums[0]
      if (nums[mid] &gt; nums[0]) {
        left = mid + 1;
      } else {
        // if nums[0] is greater than the mid value then this means the smallest value is somewhere to
        // the left
        right = mid - 1;
      }
    }
    return -1;
  }
｝
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：和二分搜索一样O(logN)<br>
空间复杂度：O(1)</p>
</blockquote>
<p>其实官网的思路和我的一致，不过官网的更加优雅，把正常情况和左边异常情况合为一起了，我判断的条件更多，也能早那么一点结束循环。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于信号与信号处理程序（SIGCHLD和waitpid）]]></title>
        <id>https://lixin-ee.github.io//post/guan-yu-xin-hao-yu-xin-hao-chu-li-cheng-xu-sigchld-he-waitpid</id>
        <link href="https://lixin-ee.github.io//post/guan-yu-xin-hao-yu-xin-hao-chu-li-cheng-xu-sigchld-he-waitpid">
        </link>
        <updated>2019-12-14T01:54:58.000Z</updated>
        <content type="html"><![CDATA[<p>在阅读UNP第五章的子进程处理僵死进程的时候出了点小问题<br>
主要就是在子进程结束后会发送SIGCHLD信号给父进程<br>
然后父进程需要处理这个已经变成僵死进程的子进程，否则就会占用内核空间，如果是巨型web服务器这样会耗尽进程资源直接木大。<br>
但是注意僵死进程本身并非一个bug或者副产物，因为设置僵死状态的目的是维护子进程的信息，以便父进程可以在以后某个时候获取子进程的进程id、终止状态以及资源利用信息，正确处理好僵死进程能让它变成纯正效应的。</p>
<p>然后5.7-5.10主要就是讲述了大型服务器上多个子进程同时结束会怎么样</p>
<p>首先明确一个概念是信号不排队<br>
这句话其实有点歧义，正解应该是实时信号会排队，但是队列中多个相同信号只能排一个位置<br>
man 7 signal原文：</p>
<blockquote>
<ol>
<li>Multiple instances of real-time signals can be queued. By contrast, if multiple instances of a standard signal are delivered while that signal is currently blocked, then only one instance is queued.</li>
</ol>
</blockquote>
<p>所以如果多个子进程结束返送SIGCHLD会导致只有一个SIGCHLD在排队</p>
<p>进入处理程序后，由于wait只执行一次，所以只能处理第一个僵死进程</p>
<p>所以达不到我们所希望的  每个SIGCHLD处理一次，因为SIGCHLD只有一个</p>
<p>那我们在一个SIGCHLD内循环调用wait不就行了吗？也不行，因为wait这家伙会阻塞父进程的，你就一直在那while那就不用干活了</p>
<p>这个时候waitpid就出场了，好家伙有个option，可以指定WNOHANG，让内核在没有已终止子进程时不要阻塞，所以可以疯狂while</p>
<p>现在进入主题了<br>
我一开始的问题是把SIGCHLD和waitpid这两者的关系弄错了<br>
虽然这两者的很紧密，一般是一起出现<br>
但是！！！没有因果关系先后关系和依附关系，wait只是信号处理函数中调用的一个函数<br>
而不是说必须有信号才能调用wait，你喜欢的话随时可以调用wait</p>
<p>摘录知乎匿名用户的回答：</p>
<blockquote>
<p>wait函数或者waitpid函数回收子进程又不是依据信号来的，发送SIGCHLD信号只是异步通知父进程一下而已，你排不排队和信号递交不递交与wait/waitpid又不相干，主进程循环调用wait/waitpid函数，函数去检查有没有死掉的子进程，并做相应处理，并不涉及到信号排队。</p>
</blockquote>
<p>也就是说就算SIGCHLD只能有一个在排队，只要合理利用waitpid就能处理好所有僵死进程，因为它会处理当前所有僵死进程<br>
无论是多少个SIGCHLD合为一个，waitpid都能处理好，并且！！！waitpid并不知道是多少个SIGCHLD合为一个，无法去直接了解到多少个，也不需要知道，它只需要利用while处理好所有能处理到的僵尸进程就好（注意waitpid的pid参数必须设置为-1）</p>
<p>就如同知乎用户payall4u的回答：</p>
<blockquote>
<p>假设,产生了四个子线程abcd,时间顺序大概是<br>
a.............b..c.d(假设bcd发生的时间间隔很短)<br>
a死亡触发handler,wait函数回收掉a,sleep,这时候父进程sleep,子进程b死亡,向主进程发送信号,父进程收到b发出的信号,处理b发生的信号.假设处理的同时,收到了c的信号,c信号进入等待队列,接下来收到d发出的信号,发现等待队列里存在SIGCHLD信号,父线程会毫不留情的丢弃(就是不接受,不是接受然后抛弃)d发出的信号.然后回收进程b,接下来通过两次for循环回收c,d,所以这里并不是父进程把d的信号列入队列,而是通过三次wait函数和把bcd都回收掉</p>
</blockquote>
<p>所以这个问题的核心在于，这两者是无关的<br>
我们需要做的只是在信号不重复排队的情况下运用wait等函数处理好就行，并非两者有依附关系。</p>
<p>最后附上waitpid的性质<br>
waitpid（等待子进程的中断和结束）</p>
<p>所需头文件<br>
#include &lt;sys/types.h&gt;<br>
#include &lt;sys/wait.h&gt;</p>
<p>函数说明<br>
waitpid()会暂时停止目前进程的执行，直到有信号来到或子进程结束。如果在调用waitpid()子进程已经结束，则waitpid()会立即返回子进程结束状态值。子进程的结束状态值会由参数status返回，而子进程的进程识别码也会一起返回。如果不在意结束状态值，则参数status可以设成NULL。参数pid为欲等待的子进程识别码</p>
<p>函数原型<br>
pid_t waitpid(pid_t pid,int * status,int options)<br>
函数传入值<br>
pid<br>
&lt;-1：等待进程组识别码为pid绝对值的任何子进程<br>
-1: 等待任何子进程，相当于wait()<br>
0：等待进程组识别码与目前进程相同的任何子进程<br>
&gt;0：等待任何子进程识别码为pid的子进程</p>
<p>options<br>
参数options可以为0 或下面的OR 组合<br>
WNOHANG：如果没有任何已经结束的子进程则马上返回，不予以等待。此时返回值为0<br>
WUNTRACED：如果子进程进入暂停执行情况则马上返回，但结束状态不予以理会</p>
<p>参考资料：<a href="https://www.zhihu.com/question/50613096">unp中说Linux信号不排队，如何解释下面的情况？</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二分查找 81. 搜索旋转排序数组 II[中等]]]></title>
        <id>https://lixin-ee.github.io//post/81-sou-suo-xuan-zhuan-pai-xu-shu-zu-ii</id>
        <link href="https://lixin-ee.github.io//post/81-sou-suo-xuan-zhuan-pai-xu-shu-zu-ii">
        </link>
        <updated>2019-12-13T03:36:20.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br>
( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。<br>
编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br>
示例 1:<br>
输入: nums = [2,5,6,0,0,1,2], target = 0<br>
输出: true<br>
示例 2:<br>
输入: nums = [2,5,6,0,0,1,2], target = 3<br>
输出: false<br>
进阶:<br>
这是 搜索旋转排序数组 的延伸题目，本题中的 nums  可能包含重复元素。<br>
这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>//本来想着说将33题的代码稍微改一下就上马，结果8太行，比如这种例子[1,3,1,1,1]里面找3这种例子<br>
//本来想着说优先判断if(nums[mid]==nums[first]&amp;&amp;nums[mid]==nums[last])这个来处理特殊情况，但是始终没法处理[1,3,1,1,1]和[1,1,1,3,1]这两种相互矛盾的情况啊<br>
//扛不住了看了一下题解，没果然没那么简单啊，高赞回答还是用++first,--last;逐步解决的，但是时间复杂度只击败了30.63%，莫非有更好的解法？</p>
<pre><code>class Solution {
public:
    int search(vector&lt;int&gt;&amp; nums, int target) {
        if(nums.empty()) return 0;
        int first=0,last=nums.size()-1,mid;
        while(first&lt;last){
            mid=first+(last-first)/2;
            if(nums[mid]==nums[first]&amp;&amp;nums[mid]==nums[last]) ++first,--last;
            else if(nums[mid]&lt;nums[first]^target&lt;=nums[mid]^target&gt;=nums[first])
                first=mid+1;
            else
                last=mid;
        }
        if(nums[first]==target)
            return 1;
        return 0;
    }
};
</code></pre>
<p>来看一下网友题解：</p>
<blockquote>
<p>解题思路：<br>
本题是需要使用二分查找，怎么分是关键，举个例子：<br>
第一类<br>
10111 和 11101 这种。此种情况下 nums[start] == nums[mid]，分不清到底是前面有序还是后面有序，此时 start++ 即可。相当于去掉一个重复的干扰项。<br>
第二类<br>
2 3 4 5 6 7 1 这种，也就是 nums[start] &lt; nums[mid]。此例子中就是 2 &lt; 5；<br>
这种情况下，前半部分有序。因此如果 nums[start] &lt;=target&lt;nums[mid]，则在前半部分找，否则去后半部分找。<br>
第三类<br>
6 7 1 2 3 4 5 这种，也就是 nums[start] &gt; nums[mid]。此例子中就是 6 &gt; 2；<br>
这种情况下，后半部分有序。因此如果 nums[mid] &lt;target&lt;=nums[end]。则在后半部分找，否则去前半部分找。</p>
</blockquote>
<pre><code>public boolean search(int[] nums, int target) {
        if (nums == null || nums.length == 0) {
            return false;
        }
        int start = 0;
        int end = nums.length - 1;
        int mid;
        while (start &lt;= end) {
            mid = start + (end - start) / 2;
            if (nums[mid] == target) {
                return true;
            }
            if (nums[start] == nums[mid]) {
                start++;
                continue;
            }
            //前半部分有序
            if (nums[start] &lt; nums[mid]) {
                //target在前半部分
                if (nums[mid] &gt; target &amp;&amp; nums[start] &lt;= target) {
                    end = mid - 1;
                } else {  //否则，去后半部分找
                    start = mid + 1;
                }
            } else {
                //后半部分有序
                //target在后半部分
                if (nums[mid] &lt; target &amp;&amp; nums[end] &gt;= target) {
                    start = mid + 1;
                } else {  //否则，去后半部分找
                    end = mid - 1;

                }
            }
        }
        //一直没找到，返回false
        return false;

    }
</code></pre>
<p>最后还是发现无法优雅地处理重复元素的情况，只能一点一点夹逼，在最坏的情况下 比如111...1112111...111的情况下直接退化成时间复杂度为O（n）的顺序查找<br>
然后评论里顺序查找直接击败了100%hhh</p>
]]></content>
    </entry>
</feed>