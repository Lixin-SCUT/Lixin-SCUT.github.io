<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-11-21T01:51:01.151Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[树 107. 二叉树的层次遍历 II[简单]]]></title>
        <id>https://lixin-ee.github.io//post/shu-107-er-cha-shu-de-ceng-ci-bian-li-iijian-dan</id>
        <link href="https://lixin-ee.github.io//post/shu-107-er-cha-shu-de-ceng-ci-bian-li-iijian-dan">
        </link>
        <updated>2019-11-21T01:22:33.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）<br>
例如：<br>
给定二叉树 [3,9,20,null,null,15,7],<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7<br>
返回其自底向上的层次遍历为：<br>
[<br>
[15,7],<br>
[9,20],<br>
[3]<br>
]<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>本题的难点在于平常的层次遍历从上往下的话可以直接用vector的push_back，从下往上遍历看起来很简单，但是vector没有push_front，并且在头部插入需要整体复制移动，代价非常大<br>
所以思考了一下，决定用双边容器的deque来代替vector，最后再用迭代器范围来初始化vector<br>
<code>vector&lt;vector&lt;int&gt;&gt; res(dvi.begin(),dvi.end());</code><br>
最终代码如下：</p>
<pre><code>class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) {
        deque&lt;vector&lt;int&gt;&gt; dvi;
        preorder(root,0,dvi);
        vector&lt;vector&lt;int&gt;&gt; res(dvi.begin(),dvi.end());
        return res;
    }
    
    void preorder(TreeNode* cur,int i,deque&lt;vector&lt;int&gt;&gt; &amp;res){
        if(cur==NULL)
            return;
        if(res.size()==i)
            res.push_front(vector&lt;int&gt;());
        res[res.size()-i-1].push_back(cur-&gt;val);
        preorder(cur-&gt;left,i+1,res);
        preorder(cur-&gt;right,i+1,res);
        return;
    }
};
</code></pre>
<p>做题中出现的问题有：<br>
一开始傻了，忘了是在头部插入，继续用了<code>res[i].push_back(cur-&gt;val);</code>，结果导致输出<code>[[],[],[3,9,20,15,7]]</code><br>
然后是<code>res[res.size()-i-1]</code>，而不是<code>res[res.size()-i]</code>，因为此时size增加了1</p>
<p>结果毫无疑问地牺牲了空间复杂度来换了时间复杂度</p>
<p>然后来看一下网友题解吧<br>
大部分都是reverse，这就很没意思了<br>
所以贴个最高赞的队列迭代吧，和递归相对应</p>
<pre><code>class Solution:
    def levelOrderBottom(self, root):
        queue = []                                                  # 结果列表
        cur = [root]                                                # 接下来要循环的当前层节点，存的是节点
        while cur:                                                  # 当前层存在结点时
            cur_layer_val = []                                      # 初始化当前层结果列表为空，存的是val
            next_layer_node = []                                    # 初始化下一层结点列表为空
            for node in cur:                                        # 遍历当前层的每一个结点
                if node:                                            # 如果该结点不为空，则进行记录
                    cur_layer_val.append(node.val)                  # 将该结点的值加入当前层结果列表的末尾
                    next_layer_node.extend([node.left, node.right]) # 将该结点的左右孩子结点加入到下一层结点列表
            if cur_layer_val:                                       # 只要当前层结果列表不为空
                queue.insert(0, cur_layer_val)                      # 则把当前层结果列表插入到队列首端
            cur = next_layer_node                                   # 下一层的结点变成当前层，接着循环
        return queue      
</code></pre>
<p>这个妹纸本来的注释还挺好看的，到了这里全乱了。。。建议直接看原题<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/solution/python3-dui-lie-shi-xian-by-yi-xi-4/">妹纸的队列迭代题解</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[需要复习的点]]></title>
        <id>https://lixin-ee.github.io//post/xu-yao-fu-xi-de-dian</id>
        <link href="https://lixin-ee.github.io//post/xu-yao-fu-xi-de-dian">
        </link>
        <updated>2019-11-20T11:26:03.000Z</updated>
        <content type="html"><![CDATA[<p>LeetCode<br>
树的题目的迭代解法</p>
<p>C++PRIMER<br>
15.9章 类的设计思路代码</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 337. 打家劫舍 III[中等]]]></title>
        <id>https://lixin-ee.github.io//post/shu-337-da-jia-jie-she-iiizhong-deng</id>
        <link href="https://lixin-ee.github.io//post/shu-337-da-jia-jie-she-iiizhong-deng">
        </link>
        <updated>2019-11-20T02:04:50.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。<br>
计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。<br>
示例 1:<br>
输入: [3,2,3,null,3,null,1]<br>
3<br>
/ <br>
2   3<br>
\   \<br>
3   1<br>
输出: 7<br>
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.<br>
示例 2:<br>
输入: [3,4,5,1,3,null,1]<br>
     3<br>
/ <br>
4   5<br>
/ \   \<br>
1   3   1<br>
输出: 9<br>
解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/house-robber-iii<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>最终代码：</p>
<pre><code>class Solution {
public:
    int rob(TreeNode* root) {
        auto res=preorder(root);
        return max(res[0],res[1]);
    }
    
    vector&lt;int&gt; preorder(TreeNode* cur){
        vector&lt;int&gt; vi;
        if(cur==NULL){
            vi.push_back(0);
            vi.push_back(0);
            return vi;}
        auto vl=preorder(cur-&gt;left);
        auto vr=preorder(cur-&gt;right);
        vi.push_back(max(vl[0]+vr[0],max(vl[1]+vr[1],max(vl[1]+vr[0],vl[0]+vr[1]))));
        vi.push_back(cur-&gt;val+vl[0]+vr[0]);
        return vi;     
    } 
};
</code></pre>
<p>这道题还是蛮波折的，一开始我希望用普通的方法解决，比如说层次遍历后只取间隔层的所有节点的和，但是后来想想是不行的<br>
比如<code>[[1],[10,1],[1,1,1,10]]</code>这种情况，很明显应该牺牲头节点各取第二层和第三层的10<br>
所以动态规划在所难免了，这道题似乎和之前的股票问题比较像，0代表不偷，1 代表偷，但是只有冻结期限制而没有买入卖出等<br>
一开始想着从根节点出发，但是发现问题是同一层里值无法共享，所以必须从叶节点出发<br>
对于普通的具有两个子节点的节点来说，它取0的情况比较多，主要有<code>[（左0，右0）（左1，右0）（左0，右1）（左1，右1）]</code>，而我们只需要取这四者的最大值就好，取1的话就比较简单了，两个子树都不能偷，必须左1右1，然后再加上当前val返回就好<br>
我在取0的时候一开始不小心忘了左0右0，结果导致测试用例结果只差了1，差点百思不得其解<br>
然后看了题解后发现取0的情况完全可以简化为<code>max（（左0，左1），（右0，右1））</code><br>
哈哈哈不过第一次独立做出动态规划题还是非常高兴的啊！（虽然拖了两天hhhh</p>
<p>然后来看一下网友题解（当时非常激动，发现和网友题解思路一致）</p>
<blockquote>
<p>用一个int[]分别记录包含根节点和不包含根节点时的最大值</p>
</blockquote>
<pre><code>class Solution {
    public int rob(TreeNode root) {
        int[] res = doRob(root);
        return Math.max(res[0],res[1]);
    }
    //res[0]为不包括根节点的最大值，res[1]为包括根节点的最大值
    private int[] doRob(TreeNode root){
        int[] res = new int[2];
        if(root == null)
            return res;
        int[] left = doRob(root.left);
        int[] right = doRob(root.right);
        //不包含根节点，最大值为两个子树的最大值之和
        res[0] = Math.max(left[0],left[1])+Math.max(right[0],right[1]);
        //包含根节点，最大值为两个子树不包含根节点的最大值加上根节点的值
        res[1] = left[0] + right[0] + root.val;
        return res;
    }
}
</code></pre>
<p>另外一个说得比较详细的</p>
<blockquote>
<p>可以回顾一下初级版的LeetCode198：打家劫舍，这是一道一维dp，状态转移方程也很简单：<br>
dp[i] = Math.max(dp[i - 2] + nums[cur], dp[i - 1]);<br>
当前偷窃的最大金额可能有两种来源情况，要么偷了这家，上一家没偷；要么偷了上一家，这家没偷。因此每一个结点的dp值和前两个结点的dp值有关。<br>
这道升级版的树状动态规划问题也可以由一维的dp延伸来，只是情况稍微复杂一些，每一个节点的dp值与三层二叉树的结点dp值相关。对于下图所示的一棵三层满二叉树来说：</p>
<pre><code>  1
/   \
</code></pre>
<p>2     3<br>
/ \   / \<br>
4   5 6   7<br>
在每个结点的金额非负的情况下，且要保证取值结点不相邻，只可能有四种最大的取值方式：</p>
<ol>
<li>结点2 + 结点3</li>
<li>结点1 + 结点4 + 结点5 + 结点6 + 结点7</li>
<li>结点2 + 结点6 + 结点7</li>
<li>结点3 + 结点4 + 结点5<br>
那么我们可以自底向上递归进行这个dp运算，令dp[i]代表以i结点为根节点的子树的最大偷窃金额值，计算结束后将dp值直接保存在i结点的val值当中返回。可以推出状态转移方程为：</li>
</ol>
<p>dp[root] = Max(dp[l]+dp[r], root.val+dp[ll]+dp[lr]+dp[rr]+dp[rl], dp[l]+dp[rl]+dp[rr], dp[r]+dp[lr]+dp[ll]);<br>
分别对应上述四种情况。而观察发现，在dp[l]和dp[r]的计算中实际已经包含了dp[ll]、dp[lr]、dp[rr]、dp[rl]的取舍情况，因此可以简化为前两种情况。状态转移方程简化为：</p>
<p>dp[root] = Max(dp[l]+dp[r], root.val+dp[ll]+dp[lr]+dp[rr]+dp[rl]);<br>
为了方便运算，我们一般会为dp数组赋予初值。在树状dp中同样，我们需要将每一个非叶结点作为根节点的子树构造成一棵三层满二叉树方便运算。</p>
<p>对于叶子结点，我们给其添加值为0的左右子结点。</p>
<p>对于左/右子树为空的非叶节点，我们在其左/右添加一棵两层值为0的满二叉树。</p>
</blockquote>
<pre><code>class Solution {
    public int rob(TreeNode root) {
        return Solution(root).val;
    }

    public TreeNode Solution(TreeNode root){
        if(root == null){
            TreeNode newNode = new TreeNode(0);
            return Solution(newNode);
        }
        if(root.left == null &amp;&amp; root.right == null){
            root.left = new TreeNode(0);
            root.right = new TreeNode(0);
            return root;
        }

        root.left = Solution(root.left);
        root.right = Solution(root.right);
        root.val = Math.max(root.left.val + root.right.val, root.val + root.left.left.val + root.left.right.val + root.right.left.val + root.right.right.val);

        return root;
    }
}
</code></pre>
<p>hhh第一次自己完成动态规划问题还是挺激动的</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 124. 二叉树中的最大路径和[困难]]]></title>
        <id>https://lixin-ee.github.io//post/shu-124-er-cha-shu-zhong-de-zui-da-lu-jing-he</id>
        <link href="https://lixin-ee.github.io//post/shu-124-er-cha-shu-zhong-de-zui-da-lu-jing-he">
        </link>
        <updated>2019-11-19T01:37:25.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个非空二叉树，返回其最大路径和。<br>
本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。<br>
示例 1:<br>
输入: [1,2,3]<br>
1<br>
/ <br>
2   3<br>
输出: 6<br>
示例 2:<br>
输入: [-10,9,20,null,null,15,7]<br>
   -10<br>
   / <br>
  9  20<br>
    /  <br>
   15   7<br>
输出: 42<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/binary-tree-maximum-path-sum<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题的难点在于可以从树中的任意节点出发<br>
所以从根节点出发是不太可能的了<br>
我思考了一下，发现可以从叶节点出发。可以先记录一个全局int，然后对于一个普通节点来说，无非四种结果，首先获得左右子节点返回的节点，然后将自身节点相加，然后最最重要的就是【左+右+自身】和【自身】，前者等于将左右节点和自身连接起来形成一条路径，后者等于防止某个节点值特别大的情况，取这四种情况的最大值更新res（只需要res不需要记录特定路径，同时取最大值保证只有一条路径），然后为什么不用将左右子树算入呢，因为递归过程中他们本身也会进行这个判断。<br>
然后记得把res设置为INT_MAX<br>
最终代码如下：</p>
<pre><code>class Solution {
    int res=INT_MIN;
public:
    int maxPathSum(TreeNode* root) {
        preorder(root);
        return res;
    }
    
    int preorder(TreeNode* cur){
        if(cur==NULL)
            return 0;
        int left=preorder(cur-&gt;left);
        int right=preorder(cur-&gt;right);
        res= res&gt;(cur-&gt;val+left+right)?res:(cur-&gt;val+left+right);
        left=left+cur-&gt;val;
        right=right+cur-&gt;val;
        int ret= max(left,right);
        ret= max(ret,cur-&gt;val);
        res= res&gt;ret?res:ret;
        return ret;
        
    }
};
</code></pre>
<p>然后来看一下网友题解：</p>
<blockquote>
<p>解题思路：<br>
二叉树 abc，a 是根结点（递归中的 root），bc 是左右子结点（代表其递归后的最优解）。<br>
最大的路径，可能的路径情况：</p>
<pre><code>a
</code></pre>
<p>/ <br>
b   c<br>
b + a + c。<br>
b + a + a 的父结点。<br>
a + c + a 的父结点。<br>
其中情况 1，表示如果不联络父结点的情况，或本身是根结点的情况。<br>
这种情况是没法递归的，但是结果有可能是全局最大路径和。<br>
情况 2 和 3，递归时计算 a+b 和 a+c，选择一个更优的方案返回，也就是上面说的递归后的最优解啦。</p>
<p>另外结点有可能是负值，最大和肯定就要想办法舍弃负值（max(0, x)）（max(0,x)）。<br>
但是上面 3 种情况，无论哪种，a 作为联络点，都不能够舍弃。</p>
<p>代码中使用 val 来记录全局最大路径和。<br>
ret 是情况 2 和 3。<br>
lmr 是情况 1。</p>
<p>所要做的就是递归，递归时记录好全局最大和，返回联络最大和。</p>
<p>代码：<br>
C++</p>
</blockquote>
<pre><code>int maxPathSum(TreeNode* root, int &amp;val)
{
	if (root == nullptr) return 0;
	int left = maxPathSum(root-&gt;left, val);
	int right = maxPathSum(root-&gt;right, val);
	int lmr = root-&gt;val + max(0, left) + max(0, right);
	int ret = root-&gt;val + max(0, max(left, right));
	val = max(val, max(lmr, ret));
	return ret;
}

int maxPathSum(TreeNode* root) 
{
	int val = INT_MIN;
	maxPathSum(root, val);
	return val;
}
</code></pre>
<p>网友的思路比我更清晰一点，利用max(0, left) + max(0, right)其实就包含了判断自身的情况。然后评论中指出可以改进的点是lmr肯定是大于ret的</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 110. 平衡二叉树[简单]]]></title>
        <id>https://lixin-ee.github.io//post/shu-110-ping-heng-er-cha-shu-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/shu-110-ping-heng-er-cha-shu-jian-dan">
        </link>
        <updated>2019-11-18T00:21:03.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个二叉树，判断它是否是高度平衡的二叉树。<br>
本题中，一棵高度平衡二叉树定义为：<br>
一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。<br>
示例 1:<br>
给定二叉树 [3,9,20,null,null,15,7]<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7<br>
返回 true 。<br>
示例 2:<br>
给定二叉树 [1,2,2,3,3,null,null,4,4]</p>
<pre><code>   1
  / \
 2   2
/ \
</code></pre>
<p>3   3<br>
/ <br>
4   4<br>
返回 false 。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/balanced-binary-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题的难点在于不平衡出现的点是不确定的，有可能在叶子节点的父母节点开始出现不平衡，也有可能在根节点才开始出现不平衡<br>
所以这一次的迭代我打算使用先走到叶节点，然后再逐步返回，返回值为当前节点到最远叶节点的距离，然后返回到上一节点就可以利用左右节点返回的值进行比较<br>
为了方便就设置一个全局bool值。</p>
<pre><code>class Solution {
bool res=true;
public:
    bool isBalanced(TreeNode* root) {
        preorder(root,0);
        return res;
    }
    
    int preorder(TreeNode* cur,int i){
        if(cur==NULL)
            return i;
        int left=preorder(cur-&gt;left,i+1);
        int right=preorder(cur-&gt;right,i+1);
        if(abs(left-right)&gt;1)
            res=false;
        return left&gt;right?left+1:right+1;
    }
};
</code></pre>
<p>然后来看一下网友题解：</p>
<blockquote>
<p>从底至顶（提前阻断法）<br>
对二叉树做深度优先遍历DFS，递归过程中：<br>
终止条件：当DFS越过叶子节点时，返回高度0；<br>
返回值：<br>
从底至顶，返回以每个节点root为根节点的子树最大高度(左右子树中最大的高度值加1max(left,right) + 1)；<br>
当我们发现有一例 左/右子树高度差 ＞ 1 的情况时，代表此树不是平衡树，返回-1；<br>
当发现不是平衡树时，后面的高度计算都没有意义了，因此一路返回-1，避免后续多余计算。<br>
最差情况是对树做一遍完整DFS，时间复杂度为 O(N)。</p>
</blockquote>
<pre><code>class Solution {
    public boolean isBalanced(TreeNode root) {
        return depth(root) != -1;
    }

    private int depth(TreeNode root) {
        if (root == null) return 0;
        int left = depth(root.left);
        if(left == -1) return -1;
        int right = depth(root.right);
        if(right == -1) return -1;
        return Math.abs(left - right) &lt; 2 ? Math.max(left, right) + 1 : -1;
    }
}
</code></pre>
<blockquote>
<p>从顶至底（暴力法）<br>
构造一个获取当前节点最大深度的方法 depth() ，通过比较左右子树最大高度差abs(self.depth(root.left) - self.depth(root.right))，来判断以此节点为根节点下是否是二叉平衡树；<br>
从顶至底DFS，以每个节点为根节点，递归判断是否是平衡二叉树：<br>
若所有根节点都满足平衡二叉树性质，则返回 True ；<br>
若其中任何一个节点作为根节点时，不满足平衡二叉树性质，则返回False。<br>
本方法产生大量重复的节点访问和计算，最差情况下时间复杂度 O(N^2)。</p>
</blockquote>
<pre><code>class Solution {
    public boolean isBalanced(TreeNode root) {
        if (root == null) return true;
        return Math.abs(depth(root.left) - depth(root.right)) &lt;= 1 &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);
    }

    private int depth(TreeNode root) {
        if (root == null) return 0;
        return Math.max(depth(root.left), depth(root.right)) + 1;
    }
}
</code></pre>
<p>网友的想法比较好，其实可以利用res的值提前终止判断，然后的话我发现我忘了在返回值+1了hhh，不过是不影响了，因为是否是平衡树是在叶节点就可以判断的了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第十六章 笔记+习题 16.1]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-liu-zhang-bi-ji-xi-ti-161</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-liu-zhang-bi-ji-xi-ti-161">
        </link>
        <updated>2019-11-17T12:24:32.000Z</updated>
        <content type="html"><![CDATA[<p>16 模板与泛型编程<br>
16.1定义模型<br>
16.1.1 函数模板<br>
一个<strong>函数模板</strong>就是一个<strong>公式</strong>，可用来<strong>生成针对特定类型的函数版本</strong> 。compare的模板版本可能像下面这样 ；</p>
<p>模板定义以<strong>关键字 template <strong>开始，后跟一个</strong>模板参数列表</strong> （template parameter list ),这是一个逗号分隔的一个或多个模板参数( templateparameter )的列表，用小于号（&lt;）和大于号（&gt;）包围起来<br>
在模板定义中，<strong>模板参数列表不能为空</strong>。<br>
模板参数表示在类或函数定义中用到的<strong>类型或值</strong>。当使用模板时，我们（隐式地或显式地）指定<strong>模板实参 （template argument )</strong> 将其绑定到模板参数上。<br>
当我们调用一个函数模板时，编译器（通常）用<strong>函数实参</strong>来为我们<strong>推断模板实参</strong>。<br>
编译器用推断出的模板参数来为我们<strong>实例化( instantiate)</strong> 一个特定版本的函数。当编译器实例化一个模板时，它使用实际的模板实参代替对应的模板参数来创建出模板的一个新&quot;实例&quot;。例如，给定下面的调用：</p>
<p>这些编译器生成的版本通常被称为<strong>模板的实例</strong><br>
我们的 compare 函数有一个<strong>模板类型参数（type parameter )</strong>。一般来说，我们可以将<br>
类型参数看作<strong>类型说明符</strong>.就像内置类型或类类型说明符一样使用。特别是，类型参数可以用来<strong>指定返回类型</strong>或<strong>函数的参数类型</strong>，以及在<strong>函数体内</strong>用于<strong>变量声明</strong>或<strong>类型转换</strong>：<br>
类型参数前必须使用<strong>关键字 class 或 typename</strong> ：<br>
// 错误： U 之前必须加上 class 或 typename<br>
template&lt;typename T,U&gt; T calc(const T&amp;,const U&amp;);<br>
看起來用关键字 typename 来指定模板类型参数比用 class 更为直观。</p>
<p>除了定义类型参数，还可以在模板中定义<strong>非类型参数( nontypeparameter )<strong>一个非类型参数表示</strong>一个值</strong>而<strong>非一个类型</strong>。我们<strong>通过一个特定的类型名</strong>而非关键字 class 或typename 来<strong>指定非类型参数</strong>。<br>
当一个模板被实例化时，非类型参数被一个<strong>用户提供</strong>的或<strong>编译器推断出</strong>的值所代替。这些值<strong>必须是常量表达式</strong>（参见2.4.4节，第58页），从而允许编译器在编译时实例化模板。</p>
<p>在template&lt;unsigned N,unsigned M&gt;中 N和M只是一个值，unsigned是一个类型，但重点在于N M这两个值<br>
一个<strong>非类型参数</strong>可以是一个<strong>整型</strong>，或者是一个指向对象或函数类型的<strong>指针或（左值）引用</strong>。绑定到<strong>非类型整型参数</strong>的实参<strong>必须是一个常量表达式</strong>。绑定到<strong>指针或引用非类型参数</strong>的实参必须具有<strong>静态的生存期</strong>（static对象或者）（参见第12章，第400页）。我们不能用一个普通（非static )局部变量或动态对象作为指针或引用非类型模板参数的实参。指针参数也可以用 <strong>nullptr 或一个值为0的常量表达式</strong>来实例化。<br>
在模板定义内，模板非类型参数是一个常量值。在需要常量表达式的地方，可以使用非类型参数，例如，指定数组大小。<br>
函数模板可声明为** inline 或 constexpr** 的，如同非模板函数一样。 inline 或constexpr 说明符放在<strong>模板参数列表之后，返回类型之前</strong>：</p>
<p>•模板中的函数参数是 const 的引用。<br>
•函数体中的条件判断仅使用&lt;比较运算。</p>
<p>通过将函数参数设定为 const 的引用，我们保证了函数可以用于不能拷贝的类型。大多数类型，包括内置类型和我们已经用过的标准库类型（除 unique _ ptr 和IO类型之外 ）都是允许拷贝的。</p>
<p>模板程序应该尽量<strong>减少对实参类型的要求</strong>。</p>
<p>当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。当我们使用（而不是定义）模板时，编译器才生成代码，这一特性影响了我们如何组织代码以及<strong>错误何时被检测到</strong>。<br>
通常，当我们<strong>调用一个函数</strong>时，编详器<strong>只需要</strong>掌握函数的<strong>声明</strong>。类似的，当我们<strong>使用一个类类型的对象</strong>时，<strong>类定义必须是可用的</strong>，但<strong>成员函数的定义不必已经出现</strong>。因此，我们将<strong>类定义</strong>和<strong>函数声明</strong>放在<strong>头文件中</strong>，而<strong>普通函数</strong>和<strong>类的成员函数的定义</strong>放在<strong>源文件</strong>中。<br>
<strong>模板则不同</strong>：为了生成一个<strong>实例化版本</strong>，编译器需要掌握函数模板或类模板成员函数的<strong>定义</strong>。因此，与非模板代码不同，<strong>模板的头文件</strong>通常既<strong>包括声明也包括定定义。</strong><br>
<strong>函数模板</strong>和<strong>类模板成员函数</strong>的定义通常放在<strong>头文件中</strong>。<br>
当使用模板时，所有不依赖于模板参数的名字都必须是可见的，这是由模板的提供者保证的<br>
用来实例化模板的所有函数、类型以及与类型关联的运算符的声明都必须是可见的，这是由模板的用户来保证的。</p>
<p>通常，编译器会在三个阶段报告错误。<br>
第一个阶段是<strong>编译模板本身</strong>时。在这个阶段，编译器通常不会发现很多错误。编译器可以检查语法错误，例如忘记分号或者变量名拼错等，但也就这么多了。<br>
第二个阶段是编译器遇到<strong>模板使用</strong>时。在此阶段，编译器仍然没有很多可检查的。对于函数模板调用，编译器通常会检查实参数目是否正确。还能检查参数类型是否匹配。对于类模板，编译器可以检查用户是否提供了正确数目的模板实参，但也仅限于此了。<br>
第三个阶段是<strong>模板实例化</strong>时，只有这个阶段才能发现类型相关的错误。依赖于编译器如何管理实例化，这类错误可能在链接时才报告。<br>
当我们编写模板时，代码不能是针对特定类型的，但模板代码通常对其所使用的类型有一些假设。例如，我们最初的 compare 函数中的代码就假定实参类型定义了&lt;运算符。<br>
保证传递给模板的<strong>实参支持模板所要求的操作</strong>，以及这些操作在模板中<strong>能正确工作</strong>，是<strong>调用者的责任</strong>。</p>
<p>习题16.1<br>
编译器用推断出的模板参数来为我们<strong>实例化( instantiate)</strong> 一个特定版本的函数。当编译器实例化一个模板时，它使用实际的模板实参代替对应的模板参数来创建出模板的一个新&quot;实例&quot;<br>
习题16.2</p>
<pre><code>template &lt;typename T&gt; int compare(const T &amp;v1, const T &amp;v2) {
	if (less&lt;T&gt;()(v1, v2)) return -1;
	if (less&lt;T&gt;()(v2, v1))return 1;
	return 0;
}
</code></pre>
<p>注意<code>less&lt;type&gt;</code>本身也是一个模板，需要创建一个临时对象才能使用，所以中间有个空括号<br>
习题16.3<br>
error C2678: 二进制“&lt;”: 没有找到接受“const Sales_Data”类型的左操作数的运算符(或没有可接受的转换)<br>
习题16.4</p>
<pre><code>template&lt;typename T, typename B&gt; T Find(const T beg, const T end, B value) {
	for (T i = beg; i != end; ++i)
		if (*i == value)
			return i;
	return end;
}
int main() {
	vector&lt;int&gt; vi{ 1,2,3,4,5,6,7 };
	list&lt;string&gt; ls{ &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot; };
	string s = &quot;4&quot;;
	cout &lt;&lt; *Find(ls.begin(), ls.end(), s) &lt;&lt; endl;
}
</code></pre>
<p>需要注意的点：<br>
1.库函数find的返回值为迭代器（虽然是输入迭代器），这里我还是直接用T吧<br>
2.注意循环判断条件不能用<code>i&lt;end</code>，因为只有随机迭代器才支持关系运算符，题目中的list使用双向迭代器就没法用小于号<br>
习题16.5</p>
<pre><code>template&lt;typename T, unsigned N&gt; void print(T(&amp;arr)[N]) {
	for (auto elem : arr)
		cout &lt;&lt; elem &lt;&lt; endl;
}
int main() {
	int arri[5]{ 1,2,3,4,5 };
	char arrc[6] = &quot;12345&quot;;
	cout &lt;&lt; strlen(arrc)&lt;&lt;endl;
	print(arri);
}
</code></pre>
<p>需要注意的点：<br>
1<code>.T(&amp;arr)[N]</code>的括号不可少，否则就是引用的数组了。然后N也不可少，N也属于形参类型的一部分<br>
2.strlen计算长度的时候会忽视空字符，但是实际char数组中还是得老老实实加上一位存空字符，否则会报错（昨天的面试题中就有一道考strlen细节的）<br>
习题16.6</p>
<pre><code>template&lt;typename T, unsigned N&gt; T* begin(const T(&amp;arr)[N])
{// error C2234: “arr”: 引用数组是非法的,(&amp;arr即可)
	return arr;
}

template&lt;typename T, unsigned N&gt; T* end(const T(&amp;arr)[N])
{
	return arr + N;
}

int main() {
	int arri[5]{ 1,2,3,4,5 };
	char arrc[6] = &quot;12345&quot;;
	cout &lt;&lt; *begin(arrc) &lt;&lt;&quot; &quot;&lt;&lt;*(end(arrc)-2)&lt;&lt; endl;
}
</code></pre>
<p>此题主要针对的是数组的调用，例如begin(arr)，而不是vi.begin()<br>
习题16.7</p>
<pre><code>template&lt;typename T&gt; unsigned length(T(&amp;arr)) {
	unsigned len = 0;
	for (auto i : arr)
		++len;
	return len;
}

template&lt;typename T,unsigned N&gt; unsigned lengthN(T(&amp;arr)[N]) {
	return N;
}
int main() {
	int arri[5]{ 1,2,3,4,5 };
	char arrc[6] = &quot;12345&quot;;
	cout &lt;&lt; length(arrc)&lt;&lt; endl;
	cout &lt;&lt; lengthN(arrc) &lt;&lt; endl;
}
</code></pre>
<p>两种形式，第二种未免太暴力了一点。。。<br>
习题16.8<br>
因为大多数自定义类型，比如类都是有定义<mark>而没有定义&lt;，！=可以直接利用</mark>的定义来工作，比如迭代器中，所以==保证了较高的通用性</p>
<p>16.1.2类模板<br>
<strong>类模板 (class template)</strong> 是用来生成<strong>类的蓝图</strong>的。与函数模板的不同之处是，编译器<strong>不能</strong>为类模板<strong>推断模板参数类型</strong>。如我们己经多次看到的，为了使用类模板，我们必须在模板名后的尖括号中提供额外信息（参见3.3节，第87页）——用来代替模板参数的模板实参列表。<br>
类似函数模板，类模板以<strong>关键字 template</strong> 开始，后跟模板参数列表。在类模板（及其成员）的<strong>定义中</strong>，我们将模板参数当作<strong>替身</strong>，代替使用模板时用户<strong>需要提供的类型或值</strong>：</p>
<p>当编译器从我们的 Blob 模板<strong>实例化</strong>出一个类时，它会<strong>重写 Blob 模板</strong>，将模板参数T的每个实例替换为给定的<strong>模板实参</strong>，在本例中是 int 。</p>
<p>一个类模板的每个实例都形成一个<strong>独立的类类型</strong>。类型 Blob &lt; string &gt;与任何其他 Blob 类型都<strong>没有关联</strong>.也不会对任何其他 Blob 类型的成员有特殊访问权限。</p>
<p>为了阅读模板类代码，应该记住类模板的名字<strong>不是一个类型名</strong>（参见3.3节，第87页）。类模板用来实例化类型，而一个实例化的类型总是包含模板参数的。<br>
可能令人迷惑的是，一个类模板中的代码如果<strong>使用了另外一个模板</strong>.通常不将一个实际类型（或值）的名字用作其模板实参。相反的，我们通常将<strong>模板自己的参数</strong>当作<strong>被使用模板的实参</strong>。比如</p>
<pre><code>template&lt;typename T&gt;calss Blob{
	friend bool operator==&lt;T&gt;(const Blob&lt;T&gt;&amp;,const Blob&lt;T&gt;&amp;);
}
</code></pre>
<p>与其他任何类相同，我们既可以在<strong>类模板内部</strong>，也可以在<strong>类模板外部</strong>为其定义成员函数，且<strong>定义在类模板内的成员函数被隐式声明为内联函数</strong>。<br>
类模板的成员函数本身是一个普通函数。但是，类模板的每个实例都有其自己版本的成员函数。因此，类模板的<strong>成员函数</strong>具有和<strong>模板相同的模板参数</strong>。因而，<strong>定义在类模板之外的成员函数就必须以关键字 template 开始，后接类模板参数列表</strong>。<br>
与往常一样，当我们在<strong>类外定义</strong>一个成员时，<strong>必须说明成员属于哪个类</strong>。而且，<strong>从一个模板生成的类的名字中必须包含其模板实参</strong>。当我们定义一个成员函数时，模板实参与模板形参相同。<br>
对于 StrBlob 的一个给定的成员函数<br>
<code>ret-type StrBlob：：member-name(parm-list)</code><br>
对应的 Blob 的成员应该是这样的;<br>
<code>template &lt;typename T&gt;</code><br>
<code>ret-type Blob&lt;T&gt;: member-na,e(parm-list)</code></p>
<p>除了类名中的不同之处以及使用了模板参数列表外，此函数与原 StrBlob 类的 check 成员完全一样。<br>
与其他任何定义在类模板外的成员一样，<strong>构造函数的定义要以模板参数开始</strong></p>
<p>默认情况下，一个类模板的成员函数<strong>只有当程序用到它时才进行实例化</strong>。<strong>(和显式实例化声明不同)</strong><br>
如果一个<strong>成员函数没有被使用</strong>，则它<strong>不会被实例化</strong>。<strong>成员函数</strong>只有在<strong>被用到时才进行实例化</strong>，这一特性使得即使某种类型不能完全符合模板操作的要求（参见9.2节，第294页）我们仍然能用该类型实例化类。<br>
默认情况下，对于一个实例化了的类模板，<strong>其成员只有在使用时才被实例化</strong><br>
当我们使用一个类模板类型时必须提供模板实参，但这一规则有一个例外。<strong>在类模板自己的作用域中</strong>，我们可以<strong>直接使用模板名而不提供实参</strong>：</p>
<p>当我们处于一个类模板的作用域中时，编译器处理模板自身引用好像我们已经提供了与模板参数匹配的实参一样。</p>
<p>当我们在<strong>类模板外定义其成员</strong>时，必须记住，我们<strong>并不在类的作用域中</strong>，<strong>直到遇到类名才表示进入类的作用域</strong>（参见7.4节，第253页）：</p>
<p>手写笔记：<strong>返回类型中不能仅用BlobPtr</strong><br>
由于<strong>返回类型</strong>位于类的<strong>作用域之外</strong>，我们<strong>必须指出返回类型是一个实例化的BlobPtr</strong>，它所用类型与类实例化所用类型一致。在<strong>函数体内</strong>，我们<strong>已经进入类的作用域</strong>，因此在<strong>定义 ret 时无须重复模板实参</strong>。如果不提供模板实参，则编译器将假定我们使用的类型与成员实例化所用类型一致。</p>
<p>当一个类包含一个友元声明（参见7.2.1节，第241页）时，类与友元各自是否是模板是相互无关的。如果一个类模板<strong>包含一个非模板友元</strong>，则友元被授权<strong>可以访问所有模板实例</strong>。如果<strong>友元自身是模板</strong>，类<strong>可以授权给所有</strong>友元模板实例，也<strong>可以只授权给特定</strong>实例。<br>
类模板与另一个（类或函数）模板间友好关系的最常见的形式是<strong>建立对应实例及其友元间的友好关系</strong>。<br>
为了<strong>引用</strong>（类或函数）模板的一个<strong>特定实例</strong>，我们必须<strong>首先声明模板自身</strong>。一个模板声明包括模板参数列表：<br>
<strong>注意：声明中不必指定参数名，只要有参数个数和类型即可，比如void func(int,int,double);所以模板声明中typename等同于typename T</strong></p>
<p>一个类也可以将另一个模板的<strong>每个实例</strong>都声明为自己的友元，或者<strong>限定特定的实例</strong>为友元：</p>
<pre><code> template &lt;typename T&gt; class C2{
	friend class Pal&lt;T&gt;; //相同类型的都是友元
	template &lt;typename X&gt; friend class Pal2; //所有实例都是c2的友元｝
</code></pre>
<p>为了让<strong>所有实例成为友元</strong>，友元声明中必须使用与<strong>类模板</strong>本身<strong>不同</strong>的模板参数。</p>
<p>在新标准中，我们可以将<strong>模板类型参数</strong>声明为<strong>友元</strong></p>
<p>值得注意的是，虽然友元<strong>通常来说</strong>应该是一个<strong>类</strong>或是一个<strong>函数</strong>，但我们完全可以用一个<strong>内置类型来实例化Bar</strong>。这种与内置类型的友好关系是允许的，以便我们能用内置类型来实例化 Bar 这样的类。</p>
<p>类模板的一个实例定义了一个类类型，与任何其他类类型一样，我们可以定义一个<strong>typedef</strong> (参见2.5.1节，第60页）来<strong>引用实例化的类</strong>：<br>
<code>typedef Blob&lt;string&gt; StrBlob;</code><br>
由于模板不是一个类型，我们<strong>不能定义</strong>一个<strong>typedef 引用</strong>一个<strong>模板</strong>。即无法定义一个 typedef 引用 Blob &lt; T &gt;。<br>
但是，新标准允许我们为<strong>类模板</strong>定义一个<strong>类型别名</strong>：</p>
<p>当我们定义一个模板类型别名时，可以固定一个或多个模板参数</p>
<p>与任何其他类相同，<strong>类模板</strong>可以<strong>声明 static 成员</strong>（参见7.6节，第269页）</p>
<p>与非模板类的静态成员相同，我们可以通过类类型对象来访问一个类模板的 static成员，也可以使用作用域运算符直接访问成员。当然，<strong>为了通过类来直接访问 static 成员，我们必须引用一个特定的实例（必须带有模板参数列表）</strong>：</p>
<p>模板所有实例类型都共享相同的static成员（包括数据成员和函数乘以）<br>
类似任何其他成员函数，一个 <strong>static 成员函数只有在使用时才会实例化</strong>。</p>
<p>习题16.9<br>
一个<strong>函数模板</strong>就是一个<strong>公式</strong>，可用来<strong>生成针对特定类型的函数版本</strong><br>
<strong>类模板 (class template)</strong> 是用来生成<strong>类的蓝图</strong>的<br>
习题16.10<br>
当编译器从我们的 Blob 模板<strong>实例化</strong>出一个类时，它会<strong>重写 Blob 模板</strong>，将模板参数T的每个实例替换为给定的<strong>模板实参</strong>，一个类模板的每个实例都形成一个<strong>独立的类类型</strong><br>
习题16.11<br>
在类内使用的ListItem必须显式定义其使用的模板类型是啥<br>
习题16.12<br>
如书中所示<br>
习题16.13<br>
应该选择一对一友好关系，只能在相同类型之间使用关系运算符<br>
习题16.14<br>
其实主要是</p>
<pre><code>template&lt;unsigned N,unsigned M&gt; 
class Screen{
unsigned  width = N, height = M
	}
</code></pre>
<p>习题16.15<br>
需要所有的非类型参数实例作为友元<br>
习题16.16<br>
太长了直接托管到github啦</p>
<p>16.1.3模板参数<br>
模板参数遵循普通的作用域规则。一个<strong>模板参数名</strong>的<strong>可用范围</strong>是在其<strong>声明之后</strong>，至模板<strong>声明或定义结束之前</strong>。与任何其他名字一样，模板参数会<strong>隐藏外层作用域中声明的相同名字</strong>。但是，与大多数其他上下文不同，在<strong>模板内不能重用模板参数名</strong>：</p>
<p>由于参数名不能重用，所以一个模板参数名在一个特定模板参数列表中<strong>只能出现一次</strong>:</p>
<p>模板声明必须包含模板参数<br>
与函数参数相同，<strong>声明中的模板参数的名字不必与定义中相同（甚至可以不给出参数名）</strong>：<br>
当然，<strong>一个给定模板的每个声明和定义必须有相同数量和种类（即，类型或非类型）的参数</strong>。</p>
<p>—个特定文件所需要的<strong>所有模板的声明</strong>通常<strong>一起放置在文件开始位置</strong>，出现于<strong>任何使用</strong>这些模板的<strong>代码之前</strong>，原因我们将在16.3常（第617页）中解释</p>
<p>我们用作用<strong>域运算符（：：）<strong>来访问</strong> static 成员</strong>和<strong>类型成员</strong>（参见7.4节，第253页和7.6节，第269页）。在普通（非模板）代码中，编译器掌握类的定义。因此，它知道通过作用域运算符访问的名字是类型还是 static 成员。<br>
但对于模板代码就存在困难。例如，假定 T 是一个模板类型参数，当编译器遇到类似T :: mem 这样的代码时，它不会知道 mem 是一个类型成员还是一个 static 数据成员，直至实例化时才会知道。但是，为了处理模板，编译器必须知道名字是否表示一个类型。<br>
默认情况下， C ++语言<strong>假定</strong>通过作用域运算符访问的名字<strong>不是类型</strong>。因此，如果我们希望使用一个模板类型参数的类型成员，就<strong>必须显式告诉编译器该名字是一个类型</strong>。</p>
<p>typename是为了说明T::访问的是类型<br>
当我们希望通知编译器一个名字表示类型时，<strong>必须使用关键字 typename</strong>，而**不能使用 class **。</p>
<p>我们也可以提供<strong>默认模板实参</strong>（default template argument )。<br>
与函数默认实参一样，对于一个模板参数，只有当它<strong>右侧的所有参数都有</strong>默认实参时，它才可以有默认实参。</p>
<p>如果一个类模板为其<strong>所有模板参数都提供了默认实参</strong>，且我们<strong>希望使用这些默认实参</strong>，就<strong>必须在模板名之后跟一个空括号对</strong>：<br>
Numbers&lt; &gt; average_precision; 	//<strong>空&lt; &gt;<strong>表示我们希望</strong>使用默认类型</strong></p>
<p>习题16.17<br>
平时没有区别，只有在指明访问运算符指向的是类型的时候必须用typename</p>
<p>习题16.18<br>
(a)U前面必须得有typename，不能省略<br>
(b)形参中不能重用模板参数名T<br>
(c)inline位置错误<br>
(d)缺少返回类型<br>
(e)正确，会隐藏外层的ctype<br>
知识点：函数模板可声明为 inline 或 constexpr 的，如同非模板函数一样。 inline 或constexpr 说明符放在模板参数列表之后，返回类型之前：</p>
<p>习题16.19</p>
<pre><code>template&lt;typename T&gt; void print(T &amp;cot) {
	for (typename T::size_type i = 0; i &lt; cot.size(); ++i)
		cout &lt;&lt; cot[i] &lt;&lt; endl;
	return;
}
int main() {
	vector&lt;int&gt; vi{ 1,2,3,4,5 };
	print(vi);
}
</code></pre>
<p>习题16.20</p>
<pre><code>template&lt;typename T&gt; void print(T &amp;cot) {
	for (typename T::iterator i = cot.begin(); i !=cot.end(); ++i)
		cout &lt;&lt; *i &lt;&lt; endl;
	return;
}
</code></pre>
<p>16.1.4成员模板<br>
一个类（无论是普通类还是类模板）可以<strong>包含本身是模板</strong>的<strong>成员函数</strong>。这种成员被称为成员模板 (member template )。成员模板<strong>不能是虚函数</strong>。</p>
<p>对于<strong>类模板</strong>，我们<strong>也可以</strong>为其定义<strong>成员模板</strong>。在此情况下，类和成员各自有自己的、独立的模板参数。<br>
与类模板的普通函数成员不同，成员模板是函数模板。当我们在<strong>类模板外定义一个成员模板时</strong>，<strong>必须同时为类模板和成员模板提供模板参数列表</strong>。<strong>类模板的参数列表在前</strong>，<strong>后跟成员自己的模板参数列表</strong>：</p>
<p>为了实例化一个类模板的成员模板，我们必须同时提供类和函数模板的实参。与往常一样，我们在<strong>哪个对象上调用成员模板</strong>，编译器就根据<strong>该对象的类型</strong>来推断<strong>类模板参数的实参</strong>。与普通函数模板相同，编译器通常根据传递给成员模板的函数实参来推断它的模板实参（参见16.1.1节，第579页）：<br>
（编译器不能为类模板推断模板参数类型。）？？？</p>
<p>习题16.21</p>
<pre><code>
class DebugDelete {
public:
	DebugDelete(std::ostream &amp;s=std::cerr): os(s){}
	template &lt;typename T&gt; void operator()(T *p)const {
		os &lt;&lt; &quot;deleting unique_ptr&quot; &lt;&lt; std::endl;
		delete p;
	}
private:
	std::ostream &amp;os;
};
</code></pre>
<p>习题16.22</p>
<p>习题感悟：<br>
需要注意的点：<br>
1.库函数find的返回值为迭代器（虽然是输入迭代器），这里我还是直接用T吧<br>
2.注意循环判断条件不能用<code>i&lt;end</code>，因为只有随机迭代器才支持关系运算符，题目中的list使用双向迭代器就没法用小于号<br>
1<code>.T(&amp;arr)[N]</code>的括号不可少，否则就是引用的数组了。然后N也不可少，N也属于形参类型的一部分<br>
2.strlen计算长度的时候会忽视空字符，但是实际char数组中还是得老老实实加上一位存空字符，否则会报错（昨天的面试题中就有一道考strlen细节的）<br>
知识点：函数模板可声明为 inline 或 constexpr 的，如同非模板函数一样。 inline 或constexpr 说明符放在模板参数列表之后，返回类型之前：</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 104. 二叉树的最大深度[简单]]]></title>
        <id>https://lixin-ee.github.io//post/shu-104-er-cha-shu-de-zui-da-shen-du-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/shu-104-er-cha-shu-de-zui-da-shen-du-jian-dan">
        </link>
        <updated>2019-11-17T00:53:18.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个二叉树，找出其最大深度。<br>
二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>
说明: 叶子节点是指没有子节点的节点。<br>
示例：<br>
给定二叉树 [3,9,20,null,null,15,7]，<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7<br>
返回它的最大深度 3 。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>其实那个题号顺序还是有那么一点问题，我感觉这道题理应放在111前面<br>
寻找最小深度的时候可着实是麻烦了一把，这一次求最大深度，就没那么麻烦了，直接大力出奇迹，连叶节点的判断都不用了，反正i最大的那个肯定就是叶节点（非叶节点的深度不可能超过叶节点的）<br>
代码也非常简洁：</p>
<pre><code>class Solution {
public:
    int maxDepth(TreeNode* root) {
        return preorder(root,0);
    }
    
    int preorder(TreeNode* cur,int i){
        if(cur==NULL)
            return i;
        return max(preorder(cur-&gt;left,i+1),preorder(cur-&gt;right,i+1));
    }
};
</code></pre>
<p>官方题解如下：</p>
<blockquote>
<p>方法一：递归<br>
算法<br>
直观的方法是通过递归来解决问题。在这里，我们演示了 DFS（深度优先搜索）策略的示例。</p>
</blockquote>
<pre><code>Java
class Solution {
  public int maxDepth(TreeNode root) {
    if (root == null) {
      return 0;
    } else {
      int left_height = maxDepth(root.left);
      int right_height = maxDepth(root.right);
      return java.lang.Math.max(left_height, right_height) + 1;
    }
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：我们每个结点只访问一次，因此时间复杂度为 O(N)，<br>
其中 N 是结点的数量。<br>
空间复杂度：在最糟糕的情况下，树是完全不平衡的，例如每个结点只剩下左子结点，递归将会被调用 N 次（树的高度），因此保持调用栈的存储将是 O(N)。但在最好的情况下（树是完全平衡的），树的高度将是log(N)。因此，在这种情况下的空间复杂度将是O(log(N))。</p>
</blockquote>
<blockquote>
<p>方法二：迭代<br>
我们还可以在栈的帮助下将上面的递归转换为迭代。<br>
我们的想法是使用 DFS 策略访问每个结点，同时在每次访问时更新最大深度。<br>
所以我们从包含根结点且相应深度为 1 的栈开始。然后我们继续迭代：将当前结点弹出栈并推入子结点。每一步都会更新深度。</p>
</blockquote>
<pre><code>Java
import javafx.util.Pair;
import java.lang.Math;

class Solution {
  public int maxDepth(TreeNode root) {
    Queue&lt;Pair&lt;TreeNode, Integer&gt;&gt; stack = new LinkedList&lt;&gt;();
    if (root != null) {
      stack.add(new Pair(root, 1));
    }

    int depth = 0;
    while (!stack.isEmpty()) {
      Pair&lt;TreeNode, Integer&gt; current = stack.poll();
      root = current.getKey();
      int current_depth = current.getValue();
      if (root != null) {
        depth = Math.max(depth, current_depth);
        stack.add(new Pair(root.left, current_depth + 1));
        stack.add(new Pair(root.right, current_depth + 1));
      }
    }
    return depth;
  }
};
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(N)。<br>
空间复杂度：O(N)。</p>
</blockquote>
<p>官方的解法一致，这道题还是比较简单的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 111. 二叉树的最小深度[简单]]]></title>
        <id>https://lixin-ee.github.io//post/shu-111-er-cha-shu-de-zui-xiao-shen-du-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/shu-111-er-cha-shu-de-zui-xiao-shen-du-jian-dan">
        </link>
        <updated>2019-11-16T07:51:43.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个二叉树，找出其最小深度。<br>
最小深度是从根节点到最近叶子节点的最短路径上的节点数量。<br>
说明: 叶子节点是指没有子节点的节点。<br>
示例:<br>
给定二叉树 [3,9,20,null,null,15,7],<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7<br>
返回它的最小深度  2.<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/minimum-depth-of-binary-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题的要点在于累计当前节点到根节点的距离并检测是否是根节点<br>
和前面的题目还是非常相似的<br>
说实话这一题真的是蛮波折的，一开始不想用全局值了，以为利用min直接返回局部i值就好，结果遇到了++i这个小插曲，然后遇到了严重问题，遇到非叶节点的NULL节点时返回的值是无效的<br>
然后还是得老老实实学习前几题那样先放弃null节点，然后再判断叶子节点进行返回，<br>
同时全局值一开始必须设为int_max，然后必须判断root值是否为null（因为没法把res值设为0）<br>
代码如下：</p>
<pre><code>class Solution {
int res=INT_MAX;
public:
    int minDepth(TreeNode* root) {
        if(root==NULL)
            return 0;
        preorder(root,1);
        return res;
    }
    
    void preorder(TreeNode* cur,int i){
        if(cur==NULL)
            return; 
        if(cur-&gt;left==NULL&amp;&amp;cur-&gt;right==NULL) //这里又傻逼了，直接用了cur==null判断，明显会导致非叶节点的返回
        {
            res=res&lt;i?res:i;
            return;
        } 
        preorder(cur-&gt;left,i+1);
        preorder(cur-&gt;right,i+1);//这里傻逼了，用++i，导致第二个i疯狂增长
        return;
    }
};
</code></pre>
<p>然后来看一下网友题解：<br>
思路：</p>
<blockquote>
<p>很多人写出的代码都不符合 1,2 这个测试用例，是因为没搞清楚题意<br>
题目中说明:叶子节点是指没有子节点的节点，这句话的意思是 1 不是叶子节点<br>
题目问的是到叶子节点的最短距离，所以所有返回结果为 1 当然不是这个结果<br>
另外这道题的关键是搞清楚递归结束条件<br>
叶子节点的定义是左孩子和右孩子都为 null 时叫做叶子节点<br>
当 root 节点左右孩子都为空时，返回 1<br>
当 root 节点左右孩子有一个为空时，返回不为空的孩子节点的深度<br>
当 root 节点左右孩子都不为空时，返回左右孩子较小深度的节点值<br>
第一版代码:</p>
</blockquote>
<pre><code>class Solution {
public int minDepth(TreeNode root) {
if(root == null) return 0;
//这道题递归条件里分为三种情况
//1.左孩子和有孩子都为空的情况，说明到达了叶子节点，直接返回1即可
if(root.left == null &amp;&amp; root.right == null) return 1;
//2.如果左孩子和由孩子其中一个为空，那么需要返回比较大的那个孩子的深度        
int m1 = minDepth(root.left);
int m2 = minDepth(root.right);
//这里其中一个节点为空，说明m1和m2有一个必然为0，所以可以返回m1 + m2 + 1;
if(root.left == null || root.right == null) return m1 + m2 + 1;

//3.最后一种情况，也就是左右孩子都不为空，返回最小深度+1即可
return Math.min(m1,m2) + 1; 
}
}
</code></pre>
<blockquote>
<p>代码可以进行简化，当左右孩子为空时 m1 和 m2都为 0<br>
可以和情况 2 进行合并，即返回 m1+m2+1<br>
简化后代码如下:</p>
</blockquote>
<pre><code>class Solution {
    public int minDepth(TreeNode root) {
        if(root == null) return 0;
        int m1 = minDepth(root.left);
        int m2 = minDepth(root.right);
        //1.如果左孩子和右孩子有为空的情况，直接返回m1+m2+1
        //2.如果都不为空，返回较小深度+1
        return root.left == null || root.right == null ? m1 + m2 + 1 : Math.min(m1,m2) + 1;
    }
}
</code></pre>
<p>666呀比起我的代码简化了许多，我是一直累计下去，而他是利用递归从尾部到根结点不断地累计。</p>
<p>然后来看一下官方题解：</p>
<blockquote>
<p>方法 1：递归<br>
算法<br>
最直接的思路就是递归。<br>
我们用深度优先搜索来解决这个问题。</p>
</blockquote>
<pre><code>class Solution {
  public int minDepth(TreeNode root) {
    if (root == null) {
      return 0;
    }

    if ((root.left == null) &amp;&amp; (root.right == null)) {
      return 1;
    }

    int min_depth = Integer.MAX_VALUE;
    if (root.left != null) {
      min_depth = Math.min(minDepth(root.left), min_depth);
    }
    if (root.right != null) {
      min_depth = Math.min(minDepth(root.right), min_depth);
    }

    return min_depth + 1;
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：我们访问每个节点一次，时间复杂度为O(N) ，其中 NN 是节点个数。<br>
空间复杂度：最坏情况下，整棵树是非平衡的，例如每个节点都只有一个孩子，递归会调用 N （树的高度）次，因此栈的空间开销是O(N) 。但在最好情况下，树是完全平衡的，高度只有 log(N)，因此在这种情况下空间复杂度只有 O(log(N)) 。</p>
</blockquote>
<blockquote>
<p>方法 2：深度优先搜索迭代<br>
我们可以利用栈将上述解法中的递归变成迭代。<br>
想法是对于每个节点，按照深度优先搜索的策略访问，同时在访问到叶子节点时更新最小深度。<br>
我们从一个包含根节点的栈开始，当前深度为 1 。<br>
然后开始迭代：弹出当前栈顶元素，将它的孩子节点压入栈中。当遇到叶子节点时更新最小深度。</p>
</blockquote>
<pre><code>import javafx.util.Pair;
class Solution {
  public int minDepth(TreeNode root) {
    LinkedList&lt;Pair&lt;TreeNode, Integer&gt;&gt; stack = new LinkedList&lt;&gt;();
    if (root == null) {
      return 0;
    }
    else {
      stack.add(new Pair(root, 1));
    }

    int min_depth = Integer.MAX_VALUE;
    while (!stack.isEmpty()) {
      Pair&lt;TreeNode, Integer&gt; current = stack.pollLast();
      root = current.getKey();
      int current_depth = current.getValue();
      if ((root.left == null) &amp;&amp; (root.right == null)) {
        min_depth = Math.min(min_depth, current_depth);
      }
      if (root.left != null) {
        stack.add(new Pair(root.left, current_depth + 1));
      }
      if (root.right != null) {
        stack.add(new Pair(root.right, current_depth + 1));
      }
    }
    return min_depth;
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：每个节点恰好被访问一遍，复杂度为 O(N)。<br>
空间复杂度：最坏情况下我们会在栈中保存整棵树，此时空间复杂度为 O(N)。</p>
</blockquote>
<blockquote>
<p>方法 3：宽度优先搜索迭代<br>
深度优先搜索方法的缺陷是所有节点都必须访问到，以保证能够找到最小深度。因此复杂度是 O(N)。<br>
一个优化的方法是利用宽度优先搜索，我们按照树的层次去迭代，第一个访问到的叶子就是最小深度的节点，这样就不要遍历所有的节点了。</p>
</blockquote>
<pre><code>import javafx.util.Pair;
class Solution {
  public int minDepth(TreeNode root) {
    LinkedList&lt;Pair&lt;TreeNode, Integer&gt;&gt; stack = new LinkedList&lt;&gt;();
    if (root == null) {
      return 0;
    }
    else {
      stack.add(new Pair(root, 1));
    }

    int current_depth = 0;
    while (!stack.isEmpty()) {
      Pair&lt;TreeNode, Integer&gt; current = stack.poll();
      root = current.getKey();
      current_depth = current.getValue();
      if ((root.left == null) &amp;&amp; (root.right == null)) {
        break;
      }
      if (root.left != null) {
        stack.add(new Pair(root.left, current_depth + 1));
      }
      if (root.right != null) {
        stack.add(new Pair(root.right, current_depth + 1));
      }
    }
    return current_depth;
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：最坏情况下，这是一棵平衡树，我们需要按照树的层次一层一层的访问完所有节点，除去最后一层的节点。这样访问了 N/2 个节点，因此复杂度是 O(N)。<br>
空间复杂度：和时间复杂度相同，也是 O(N)。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于虚函数和纯虚函数]]></title>
        <id>https://lixin-ee.github.io//post/guan-yu-xu-han-shu-he-chun-xu-han-shu</id>
        <link href="https://lixin-ee.github.io//post/guan-yu-xu-han-shu-he-chun-xu-han-shu">
        </link>
        <updated>2019-11-15T08:16:03.000Z</updated>
        <content type="html"><![CDATA[<p>今天在做15.8的题的时候产生了一点疑问，如果隔代继承的话如果我不去覆盖虚函数会怎么样？还是使用基类的虚函数吗<br>
首先来看一下虚函数的定义</p>
<blockquote>
<p>对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成虚函数 (virtualfunction)</p>
</blockquote>
<p>但是同时</p>
<blockquote>
<p>如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接维承其在基类中的版本<br>
当我们在派生类中覆盖了某个虚函数时，可以再一次使用virtual 关键字指出该函数的性质。然而这么做并非必须，因为一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数。</p>
</blockquote>
<p>所以虚函数的覆盖定义仅仅是一种“希望”，最终的决定权还是在派生类上，不覆盖的话还是继续原封不动继承。而且覆盖的时候就算不加上virtual，都会继续有虚函数这个性质，所以后面的派生类照样可以选择覆盖或者不覆盖</p>
<p>而对于纯虚函数：</p>
<blockquote>
<p>可以将 net_price 定义成纯虚 (pure virtual )函数从而令程序实现我们的设计意图，这样做可以清晰明了地告诉用户当前这个 net_price 函数是没有实际意义的。<br>
含有（或者未经覆盖直接继承）纯虚函数的类是抽象基类 （abstractbaseclass )。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。我们不能（直接）创建一个抽象基类的对象。<br>
Disc_quote的派生类必须给出自己的net _ price定义，否则它们仍将是抽象基类</p>
</blockquote>
<p>所以纯虚函数是必须覆盖的。</p>
<p>所以一开始的问题的答案当然是肯定的<br>
测试代码如下：</p>
<pre><code>class B {
public:
	virtual void fcn1() { cout &lt;&lt; &quot;B-fcn1&quot; &lt;&lt; endl; };
	virtual void fcn2() { cout &lt;&lt; &quot;B-fcn1&quot; &lt;&lt; endl; };
};

class D1 :public B {
public:
	void fcn1() { cout &lt;&lt; &quot;D1-fcn1&quot; &lt;&lt; endl; }
};

class D2 :public D1 {
public:
	void fcn2() { cout &lt;&lt; &quot;D2-fcn2&quot; &lt;&lt; endl; }
};

int main()
{
	B b;
	D1 d1;
	D2 d2;
	b.fcn1();
	b.fcn2();
	d1.fcn1();
	d1.fcn2();
	d2.fcn1();
	d2.fcn2();
}
</code></pre>
<p>得到的答案如预料之中<br>
<img src="https://lixin-ee.github.io//post-images/1573806400737.png" alt=""></p>
<p>然后来测试一下纯虚函数</p>
<pre><code>class B {
public:
	virtual void fcn1() { cout &lt;&lt; &quot;B-fcn1&quot; &lt;&lt; endl; };
	virtual void fcn2() { cout &lt;&lt; &quot;B-fcn2&quot; &lt;&lt; endl; };
};

class V :public B{
public:
	virtual void fcn1() =0;
	virtual void fcn2() =0;
};

class D1 :public V {
public:
	void fcn1() { cout &lt;&lt; &quot;D1-fcn1&quot; &lt;&lt; endl; }
	void fcn2() { cout &lt;&lt; &quot;D1-fcn2&quot; &lt;&lt; endl; }
};

class D2 :public D1 {
public:
	void fcn1() { cout &lt;&lt; &quot;D2-fcn1&quot; &lt;&lt; endl; }
};

int main()
{
	B b;
	D1 d1;
	D2 d2;
	b.fcn1();
	b.fcn2();
	d1.fcn1();
	d1.fcn2();
	d2.fcn1();
	d2.fcn2();
}
</code></pre>
<p>结果如下：<br>
<img src="https://lixin-ee.github.io//post-images/1573806696185.png" alt=""></p>
<p>可以得出的结论有<br>
1.V中的纯虚函数=0直接覆盖了B中的定义，如果D1中不覆盖直接继承纯虚函数会被视为抽象基类，而覆盖后仍然保持虚函数性质，同时对于D2来说就是两个普通的虚函数了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 129. 求根到叶子节点数字之和[中等]]]></title>
        <id>https://lixin-ee.github.io//post/shu-129-qiu-gen-dao-xie-zi-jie-dian-shu-zi-zhi-he-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/shu-129-qiu-gen-dao-xie-zi-jie-dian-shu-zi-zhi-he-zhong-deng">
        </link>
        <updated>2019-11-15T01:37:13.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。<br>
例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。<br>
计算从根到叶子节点生成的所有数字之和。<br>
说明: 叶子节点是指没有子节点的节点。</p>
<p>示例 1:<br>
输入: [1,2,3]<br>
1<br>
/ <br>
2   3<br>
输出: 25<br>
解释:<br>
从根到叶子节点路径 1-&gt;2 代表数字 12.<br>
从根到叶子节点路径 1-&gt;3 代表数字 13.<br>
因此，数字总和 = 12 + 13 = 25.<br>
示例 2:<br>
输入: [4,9,0,5,1]<br>
4<br>
/ <br>
9   0<br>
 / <br>
5   1<br>
输出: 1026<br>
解释:<br>
从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495.<br>
从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491.<br>
从根到叶子节点路径 4-&gt;0 代表数字 40.<br>
因此，数字总和 = 495 + 491 + 40 = 1026.</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/sum-root-to-leaf-numbers<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题和之前的差别不大，主要是传递值并且传递一个vector引用进行存储</p>
<pre><code>class Solution {
public:
    int sumNumbers(TreeNode* root) {
        vector&lt;int&gt; vi;
        int res=0;
        preorder(root,res,vi);
        for(auto i:vi)
            res+=i;
        return res;
    }
    
    void preorder(TreeNode* cur,int res,vector&lt;int&gt; &amp;vi){
        if(cur==NULL)
            return;
        res=res*10+cur-&gt;val;
        if(cur-&gt;left==NULL&amp;&amp;cur-&gt;right==NULL){
            vi.push_back(res);
            return;
        }
        preorder(cur-&gt;left,res,vi);
        preorder(cur-&gt;right,res,vi);
        return;
    }
};
</code></pre>
<p>看下网友题解</p>
<blockquote>
<p>思路一:<br>
二叉树的题目我们首先想到的就是递归求解。递归的方式很简单，用先序遍历的变形。<br>
先遍历根节点；<br>
遍历左子树，遍历左子树的时候，把走当前路径的数字带到左子树的求解中；<br>
遍历右子树，遍历右子树的时候，把走当前路径的数字带到右子树的求解中；<br>
更新总的和。<br>
代码一:</p>
</blockquote>
<pre><code>Java
class Solution {
    private int sum = 0;
    private void helper(TreeNode node, int father) {
        if (node == null) return ;
        int current = father * 10 + node.val;
        if (node.left == null &amp;&amp; node.right == null) {
            sum += current;
            return;
        }
        helper(node.left, current);
        helper(node.right, current);
    }

    public int sumNumbers(TreeNode root) {
        if (root == null) return sum;
        helper(root, 0);
        return sum;
    }
}
</code></pre>
<blockquote>
<p>思路二:<br>
通常还可以用 stack 的思路来解递归的题目。先序非递归的代码我们知道是用 stack 来保存遍历过的元素。而因为本题要记录到叶节点的数字，所以需要一个额外的 stack 来记录数字。每次出 stack 之后，如果是叶子节点，那么加和；如果不是，那么就看左右子树，入 stack。<br>
代码二:</p>
</blockquote>
<pre><code>Java
class Solution {
    public int sumNumbers(TreeNode root) {
        int sum = 0;
        if (root == null) return sum;
        Stack&lt;TreeNode&gt; nodeStack = new Stack&lt;&gt;();
        Stack&lt;Integer&gt; numStack = new Stack&lt;&gt;();
        nodeStack.add(root);
        numStack.add(0);
        while (!nodeStack.isEmpty()) {
            TreeNode current = nodeStack.pop();
            Integer currentNum = numStack.pop() * 10 + current.val;
            if (current.left == null &amp;&amp; current.right == null) {
                sum += currentNum;
            }
            if (current.left != null) {
                nodeStack.add(current.left);
                numStack.add(currentNum);
            }
            if (current.right != null) {
                nodeStack.add(current.right);
                numStack.add(currentNum);
            }
        } 
        return sum;
    }
}
</code></pre>
<blockquote>
<p>思路三:<br>
其实，我们可以看到，最关键的是找到叶子节点，然后加和这个操作。叶子节点我们同样可以用层序遍历的方式来解这道题目。层序遍历用队列来解。<br>
代码三:</p>
</blockquote>
<pre><code>Java
public class Solution {
    public int sumNumbers(TreeNode root) {
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();
        Queue&lt;Integer&gt; numQueue = new LinkedList&lt;Integer&gt;();
        if(root == null) return 0;
        int res = 0;
        queue.add(root);
        numQueue.add(0);
        while(!queue.isEmpty()) {
            int size = queue.size();
            // 把该层的都入队，同时如果遇到叶节点，计算更新
            while(size-- &gt; 0) {
                root = queue.poll();
                int val = numQueue.poll() * 10 + root.val;
                if(root.left == null &amp;&amp; root.right == null)
                    res += val;
                if(root.left != null) {
                    queue.add(root.left);
                    numQueue.add(val);
                }
                if (root.right != null) {
                    queue.add(root.right);
                    numQueue.add(val);
                }
            }
        }
        return res;
    }
}
</code></pre>
<blockquote>
<p>总结，二叉树的题目，大多数都是遍历的变形，面试时候看用 bfs，还是 dfs，一般来说很快就能得出答案。写非递归代码的时候，注意判断一下非空，不要把 null 节点入队或者入栈。</p>
</blockquote>
<p>看了一下第一个递归的解答，发现用全局sum确实方便很多，毕竟也没要求返回每个值，用vector有点大材小用了。</p>
]]></content>
    </entry>
</feed>