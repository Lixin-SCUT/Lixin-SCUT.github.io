<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-09-11T08:45:31.146Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[C++避坑]]></title>
        <id>https://lixin-ee.github.io//post/cbi-keng</id>
        <link href="https://lixin-ee.github.io//post/cbi-keng">
        </link>
        <updated>2019-09-11T04:07:17.000Z</updated>
        <content type="html"><![CDATA[<p>cout不明确：<br>
将using namespace std; 删除后保存cpp文件，<br>
再加上using namespace std;保存cpp文件。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ C++ primer 第五章 笔记+习题]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-wu-zhang-bi-ji-xi-ti</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-wu-zhang-bi-ji-xi-ti">
        </link>
        <updated>2019-09-11T01:06:33.000Z</updated>
        <content type="html"><![CDATA[<p>5.1-5.3.1<br>
空语句 用在需要语法上需要的地方， 比如while ，空语句最好加上注释<br>
复合语句 也称作块，一个块就是一个作用域。<br>
复合语句用在语法上只能一条语句但是逻辑上需要多条语句的地方，比如while和for<br>
注意while和for本来只能容纳一条语句，所以要用 { }</p>
<p>习题5.1<br>
空语句就是只有一个单独的分号的语句，什么也不执行。主要是用于语法上需要一条语句但是逻辑上不需要的地方，比如while和for循环头完成了所有操作的话，循环体就需要一个空语句<br>
习题5.2<br>
块也就是复合语句，是指用花括号括起来的语句和声明的序列。如果在语法上只能容纳一条语句但是逻辑上需要多条语句的话，就应该使用块，例如while和for的循环体<br>
习题5.3<br>
while（val&lt;=10） sum+=val,++val;<br>
可读性提高了<br>
知识点：可以用逗号运算符使得比较简短的循环体变成一句话<br>
习题5.4<br>
（a）while循环头可以进行定义，但是不应该进行定义，否则每次循环都会定义一次，如果没有显式的break就会形成死循环<br>
（b）在while循环头进行定义的变量作用域只在while循环块内，if是无法使用status的<br>
习题5.5</p>
<pre><code>int main() {
	int grade;
	const vector&lt;string&gt; level{ &quot;A+&quot;,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot; };
	cin &gt;&gt; grade;
	if (grade == 100)
		cout &lt;&lt; level[0];
	else if (grade &gt;= 90)
		cout &lt;&lt; level[1];
	else if (grade &gt;= 80)
		cout &lt;&lt; level[2];
	else if (grade &gt;= 70)
		cout &lt;&lt; level[3];
	else if (grade &gt;= 60)
		cout &lt;&lt; level[4];
	else
		cout &lt;&lt; level[5];
};
</code></pre>
<p>习题5.6</p>
<pre><code>int main() {
	int grade;
	const vector&lt;string&gt; level{ &quot;A+&quot;,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot; };
	cin &gt;&gt; grade;
	cout &lt;&lt; ((grade &lt; 60) ? level[5] : (grade &lt; 70) ? level[4] : (grade &lt; 80) ? level[3] : (grade &lt; 90) ? level[2] : (grade &lt;100) ? level[1] : level[0]);
};
</code></pre>
<p>知识点:条件运算符的优先级实在是太低了。。。连&lt;&lt;都不如，一定要加括号<br>
习题5.7<br>
（a）没有加分号<br>
（b）没有加花括号，没法形成块<br>
（c）ival定义在while循环头，作用域只在while内部<br>
（d）==号和=号的差别特别大， 虽然合法，但是循环达不到预期效果。<br>
习题5.8<br>
悬垂else是指if的数量大于else的数量，容易造成二义性，从而规定else与离它最近的尚未匹配的if进行匹配。</p>
<p>5.3.2<br>
switch语句中case标签必须是<strong>整形</strong>常量表达式（3 或者 ‘a’） 3.14或者 int 型都不行，除了default<br>
任何两个<strong>case标签不能相同</strong><br>
两个case标签之间要有break语句，<strong>否则会连续执行</strong>接下来的case<br>
无break语句应该备注注释<br>
default语句就算为空也应该定义<br>
每个标签都应该跟上一条语句、空语句或者空块<br>
在case语句中 <strong>不能进行变量的初始化，但可以进行变量的定义</strong>。<br>
最好在case内定义一个块，再定义并初始化变量，保证其他case都在作用域外</p>
<p>习题5.9</p>
<pre><code>int main() {
	string s;
	while (cin &gt;&gt; s) {
		int num = 0;
		for (auto letter : s)
			switch (letter)
			{
			case 'a': {++num; break; }
			case 'i': {++num; break; }
			case 'o': {++num; break; }
			case 'u': {++num; break; }
			case 'e': {++num; break; }
			default:break;
			}
		cout &lt;&lt; &quot;num is &quot; &lt;&lt; num&lt;&lt;endl;
	}
};
</code></pre>
<p>习题5.10</p>
<pre><code>int main() {
	string s;
	while (cin &gt;&gt; s) {
		int num = 0;
		for (auto letter : s)
			switch (letter)
			{
			case'A': case 'a': {++num; break; }
			case'I': case 'i': {++num; break; }
			case'O': case 'o': {++num; break; }
			case'U': case 'u': {++num; break; }
			case'E': case 'e': {++num; break; }
			default:break;
			}
		cout &lt;&lt; &quot;num is &quot; &lt;&lt; num&lt;&lt;endl;
	}
};
</code></pre>
<p>习题5.11</p>
<pre><code>int main() {
	char s;
	int num = 0;
	int space = 0, tab = 0, enter = 0;
	while (cin&gt;&gt;noskipws&gt;&gt;s) {	
			switch (s)
			{
			case'A': case 'a': {++num; break; }
			case'I': case 'i': {++num; break; }
			case'O': case 'o': {++num; break; }
			case'U': case 'u': {++num; break; }
			case'E': case 'e': {++num; break; }
			case' ': {++space; break; }
			case'\t': {++tab; break; }
			case'\n': {++enter; break; }
			default:break;
			}
	}
	cout &lt;&lt; &quot;num is &quot; &lt;&lt; num &lt;&lt; endl;
	cout &lt;&lt; &quot;space is &quot; &lt;&lt; space &lt;&lt; endl;
	cout &lt;&lt; &quot;tab is &quot; &lt;&lt; tab &lt;&lt; endl;
	cout &lt;&lt; &quot;enter is &quot; &lt;&lt; enter &lt;&lt; endl;
};
</code></pre>
<p>知识点：注意此处不能再用string了 string的逐个字母判断遇到空格等字符就会停止。。。只能用char一个一个读入。<br>
习题5.12</p>
<pre><code>int main() {
	string s;
	int ff = 0, fl = 0, fi = 0;
	while (cin &gt;&gt; s) {
		for (int i = 0; i &lt; s.size() - 1; ++i) {
			auto letter = s[i];
			switch (letter)
			{
			case 'f': {
				switch (s[i + 1])
				{
				case 'f': {++ff; break; }
				case 'l': {++fl; break; }
				case 'i': {++fi; break; }
				default:
					break;
				}
			}
			default:break;
			}
		}
	}
	cout &lt;&lt; &quot;ff is &quot; &lt;&lt; ff &lt;&lt; endl;
	cout &lt;&lt; &quot;fl is &quot; &lt;&lt; fl &lt;&lt; endl;
	cout &lt;&lt; &quot;fi is &quot; &lt;&lt; fi &lt;&lt; endl;
};
</code></pre>
<p>习题5.13<br>
（a）case直接没有break，会连续执行<br>
（b）在case语句中 不能进行变量的初始化<br>
（c）不能在同一语句中定义多个case标签<br>
（d）case后面的ival、jval等并非常量</p>
<p>5.4.1<br>
while的条件语句中可以是表达式或者带初始化的变量声明<br>
while 内部的变量（条件部分或循环体内）<strong>每次迭代都会经历创建到销毁</strong><br>
while循环使用1.迭代次数<strong>不确定</strong> 2. <strong>需要在循环结束后访问循环控制变量</strong></p>
<p>习题5.14</p>
<pre><code>int main() {
	string s;
	string s_b;
	int num=0;
	int lab=0;
	cin &gt;&gt; s;
	s_b = s;
	while (cin &gt;&gt; s) {
		if (s_b == s)
			++num, ++lab;
		else if (num)
			cout &lt;&lt; s_b &lt;&lt; &quot; occur &quot; &lt;&lt; num+1 &lt;&lt; &quot; time &quot; &lt;&lt; endl, s_b = s, num = 0;
		else
			s_b = s, num = 0;
	}
	if (!lab)
		cout &lt;&lt; &quot;no same words occur&quot; &lt;&lt; endl;
};
</code></pre>
<p>5.4.2<br>
for语句中init-statement必须是声明语句、表达式语句或者空语句<br>
for语句开始循环时init-statement执行后i<strong>立即判断一次condition</strong><br>
<strong>init-statement中定义的对象只在for循环体内可见 **<br>
init-statemen 可以定义多个对象，但是只能有一条声明语句，所以</strong>所有变量的基础类型必须相同**<br>
for 语句头中的内容都能省略</p>
<p>习题5.15<br>
（a）循环头定义的变量的作用域只在循环体，if无法调用ix<br>
（b）循环判断可以省略，但是分号；不可以省略<br>
（c）两者同时在增长，除非循环体内部有其他控制，否则陷入死循环<br>
习题5.16<br>
其实前面用得很多，就得根据情况而定，甚至有时候使用do while都更加方便<br>
习题5.17</p>
<pre><code>int main() {
	vector&lt;int&gt; v1;
	vector&lt;int&gt; v2;
	int len = (v1.size() &lt; v2.size() ? v1.size() : v2.size());
	int i = 0;
	for (; i &lt; len; ++i)
		if (v1[i] != v2[i])
			return -1;
	return 1;	
};
</code></pre>
<p>5.4.3<br>
范围For 语句<br>
Expression 表示的必须是一个<strong>序列</strong><br>
比如花括号括起来的初始值列表、数组、vector 、string ，这些类型的共同特点是<strong>拥有能返回迭代器的begin和end成员</strong><br>
5.4.4<br>
do while语句 至少执行一次循环<br>
<strong>不允许在条件部分定义变量，否则变量使用出现在定义之前</strong><br>
do while在<strong>循环体内定义的变量也无法在条件部分使用</strong><br>
do while 的while<strong>条件部分后应该有；号</strong></p>
<p>习题5.18<br>
（a）do后面需要使用块语句<br>
（b）do while在循环判断中定义的变量是没有意义的<br>
（c）do while 在循环体中定义的变量也没法给循环判断使用<br>
习题5.19</p>
<pre><code>int main() {
	string s1, s2;
	do {
		cin &gt;&gt; s1 &gt;&gt; s2;
		string output = s1.size() &lt; s2.size() ? s1 : s2;
		cout &lt;&lt; &quot;the shorter is &quot; &lt;&lt; output &lt;&lt; endl;
	}
	while (cin);
};
</code></pre>
<p>5.5.1 break语句<br>
终止离它<strong>最近</strong>的while，do while，for，switch语句</p>
<p>习题5.20</p>
<pre><code>int main() {
	string s, s_b;
	int flag=0;
	cin &gt;&gt; s;
	s_b = s;
	do {
		cin &gt;&gt; s;
		if (s_b == s) {
			++flag; 
			break;
		}
		s_b = s;
	}
	while (cin);
	if (!flag)
		cout &lt;&lt; &quot;no same word&quot; &lt;&lt; endl;
	else
		cout &lt;&lt; s_b &lt;&lt; &quot; is the same word&quot;&lt;&lt;endl;
};
</code></pre>
<p>5.5.2 continue语句<br>
不能用于switch</p>
<p>习题5.21</p>
<pre><code>int main() {
	string s, s_b;
	int flag=0;
	cin &gt;&gt; s;
	s_b = s;
	do {
		cin &gt;&gt; s;
		if (s_b == s) 
			if(s[0]&gt;='A'&amp;&amp;s[0] &lt;= 'Z'){
			++flag; 
			break;
			}
			else
				continue;
		s_b = s;
	}
	while (cin);
	if (!flag)
		cout &lt;&lt; &quot;no same word&quot; &lt;&lt; endl;
	else
		cout &lt;&lt; s_b &lt;&lt; &quot; is the same word&quot;&lt;&lt;endl;
};

</code></pre>
<p>5.5.3goto语句<br>
不建议使用<br>
带标签语句<br>
标签标示符 独立于变量和其他标示符名字 可以和其他标示符使用同一个名字</p>
<p>习题5.22</p>
<pre><code>for（int sz =get_size()；sz&lt;=0；）
	sz =get_size()；
</code></pre>
<p>5.6<br>
throw表达式 表示异常检测部分遇到了无法处理的问题<br>
try语句块 用于处理异常 以一个或多个catch语句结束<br>
catch语句 异常处理代码<br>
异常类 用于在throw和catch语句之间传递异常的具体信息<br>
5.6.1<br>
标准库异常类型定义在stdexcept头文件中 需要添加std：：前缀<br>
throw表达式 throw errorstyle（）；<br>
例子 throw std::runtime_error(“错误信息”) //例如(“data must refer to same ISBN”)<br>
runtime_error对象需要使用string对象或者c风格字符串进行初始化<br>
5.6.2<br>
Try{ 正常逻辑<br>
}catch (异常声明){异常处理<br>
}<br>
每个标准库异常类都定义了名为what的成员函数，没有参数，返回值是c风格字符串, const char*,使用例子：</p>
<pre><code>try {
		if (j == 0)
			throw runtime_error(&quot;j cannot be zero&quot;);
		cout &lt;&lt; &quot;result is &quot; &lt;&lt; i / j &lt;&lt; endl;
	}
	catch (runtime_error error) {
		cout &lt;&lt; error.what() &lt;&lt; endl;
</code></pre>
<p>发生异常时,可能有多个try-catch语句的嵌套，Try语句从外到内执行，catch语句从内到外搜索，如果最终都没找到匹配的catch，程序转到terminate标准库函数<br>
5.6.3<br>
exception，bad_alloc，bad_cast异常类型的对象只能默认初始化不能提供初始值，其他的需要用string或c风格字符串初始化，不允许用默认初始化<br>
异常类型只定义了一个what成员函数，提供关于异常的文本信息</p>
<p>习题5.23</p>
<pre><code>int main() {
	int i, j;
	cin &gt;&gt; i &gt;&gt; j;
	if (j == 0)
		throw runtime_error(&quot;j cannot be zero&quot;);
	else
		cout &lt;&lt; &quot;result is &quot; &lt;&lt; i / j &lt;&lt; endl;
};
</code></pre>
<p>习题5.24<br>
vs 显示abort() has been called<br>
习题5.25</p>
<pre><code>int main() {
	int i, j;
	while(cin &gt;&gt; i &gt;&gt; j)
	try {
		if (j == 0)
			throw runtime_error(&quot;j cannot be zero&quot;);
		cout &lt;&lt; &quot;result is &quot; &lt;&lt; i / j &lt;&lt; endl;
	}
	catch (runtime_error error) {
		cout &lt;&lt; error.what() &lt;&lt; endl;
		cout &lt;&lt; &quot;whether you want to continue?[y/n]&quot;;
		string s;
		cin &gt;&gt; s;
		if (s[0] == 'y')
			continue;
		else
			break;
	}	
};
</code></pre>
<p>知识点：如果try-catch语句在循环体内，在catch 语句中也可以使用continue和break；</p>
<p>习题感悟<br>
可以用逗号运算符使得比较简短的循环体变成一句话<br>
cout &lt;&lt; ((grade &lt; 60) ? level[5] level[0]);条件运算符的优先级实在是太低了。。。连&lt;&lt;都不如，一定要加括号<br>
string的逐个字母判断遇到空格等字符就会停止。。。只能用char一个一个读入。<br>
do while 的while条件部分后应该有；号</p>
<pre><code>do
		cin &gt;&gt; v1 &gt;&gt; v2;
	while (cin);
</code></pre>
<p>是正确的<br>
do while在<strong>循环体内定义的变量也无法在条件部分使用</strong><br>
continue语句 不能用于switch<br>
what（）的使用方法：其中runtime_error等是一个类型，可以对其定义变量</p>
<pre><code>try {
		if (j == 0)
			throw runtime_error(&quot;j cannot be zero&quot;);
		cout &lt;&lt; &quot;result is &quot; &lt;&lt; i / j &lt;&lt; endl;
	}
	catch (runtime_error error) {
		cout &lt;&lt; error.what() &lt;&lt; endl;
</code></pre>
<p>如果try-catch语句在循环体内，在catch 语句中也可以使用continue和break；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 274. H指数]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-274-h-zhi-shu</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-274-h-zhi-shu">
        </link>
        <updated>2019-09-10T03:28:18.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目如下：<br>
给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。<br>
h 指数的定义: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）至多有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数不多于 h 次。）”</p>
<p>示例:<br>
输入: citations = [3,0,6,1,5]<br>
输出: 3<br>
解释: 给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。<br>
     由于研究者有 3 篇论文每篇至少被引用了 3 次，其余两篇论文每篇被引用不多于 3 次，所以她的 h 指数是 3。<br>
说明: 如果 h 有多种可能的值，h 指数是其中最大的那个<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/h-index<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>题目还是很拗口啊，评论里很多人吐槽，但是这个看了例子还是比较好理解的，就是有两个数，一个是被引用数reference，一个是符合被引用数的文章数量number，两者是此消彼长的，而且最后只会有一个解。<br>
一开始的想法是没一个reference都遍历一次数组，根据reference的值和number的值的差异来判断是否达到了临界值或者超过了临界值，这个临界值就是所求。<br>
最后的代码如下：</p>
<pre><code>class Solution {
public:
    int hIndex(vector&lt;int&gt;&amp; citations) {
        
        if(!citations.size())
            return 0;
        int h=0;
        int h_refer=0,h_num=0;
        do{
            h_refer++;
            h_num=0;
            for(auto i:citations)
                 if (i&gt;=h_refer)
                    h_num++;
            if(h_refer&lt;=h_num)
                ++h;
        }while(h_refer&lt;h_num);
            return h;
    }
};
</code></pre>
<p>一次通过啦！！！愉快的一天！！！<br>
但是其实中途还是有点波折的，因为感觉do while语句比较适合这个情况（很难一开始就判断循环条件），然后就是h递增的判断，因为很容易越过临界点，但是经过一定的考虑和修改后顺利地一次过了。<br>
然后还有一些缺陷就是运行时间太长，时间复杂度为o（h*n）<br>
然后看一下官方题解：</p>
<blockquote>
<p>方法一：排序<br>
分析<br>
我们想象一个直方图，其中 xx 轴表示文章，yy 轴表示每篇文章的引用次数。如果将这些文章按照引用次数降序排序并在直方图上进行表示，那么直方图上的最大的正方形的边长 hh 就是我们所要求的 hh。<br>
算法<br>
首先我们将引用次数降序排序，在排完序的数组citations 中，如果icitations[i]&gt;i，那么说明第 0 到 i 篇论文都有至少 i+1 次引用。因此我们只要找到最大的 ii满足citations[i]&gt;i，那么 h 指数即为i+1。<br>
找到最大的 ii的方法有很多，可以对数组进行线性扫描，也可以使用二分查找。由于排序的时间复杂度已经为 O(nlogn)，因此无论是线性扫描O(n) 还是二分查找O(logn)，都不会改变算法的总复杂度。<br>
复杂度分析<br>
时间复杂度：O(nlogn)，即为排序的时间复杂度。<br>
空间复杂度：O(1)O(1)。大部分语言的内置 sort 函数使用堆排序，它只需要 O(1)O(1) 的额外空间。</p>
</blockquote>
<p>方法一是比较简单暴力的排序，时间复杂度下限O(nlogn)，所以来看一下方法二：</p>
<blockquote>
<p>方法二：计数<br>
分析<br>
基于比较的排序算法存在时间复杂度下界 O(n\log n)O(nlogn)，如果要得到时间复杂度更低的算法，就必须考虑不基于比较的排序。<br>
算法<br>
方法一中，我们通过降序排序得到了 h 指数，然而，所有基于比较的排序算法，例如堆排序，合并排序和快速排序，都存在时间复杂度下界O(nlogn)。要得到时间复杂度更低的算法. 可以考虑最常用的不基于比较的排序，计数排序。<br>
然而，论文的引用次数可能会非常多，这个数值很可能会超过论文的总数 n，因此使用计数排序是非常不合算的（会超出空间限制）。在这道题中，我们可以通过一个不难发现的结论来让计数排序变得有用，即：<br>
如果一篇文章的引用次数超过论文的总数 nn，那么将它的引用次数降低为 n 也不会改变 h 指数的值。<br>
由于 h指数一定小于等于 n，因此这样做是正确的。在直方图中，将所有超过 y 轴值大于 n 的变为n  等价于去掉 y&gt;n 的整个区域。<br>
从直方图中可以更明显地看出结论的正确性，将 y&gt;n 的区域去除，并不会影响到最大的正方形，也就不会影响到 h 指数。<br>
我们用一个例子来说明如何使用计数排序得到 h 指数。首先，引用次数如下所示：<br>
citations=[1,3,2,3,100]<br>
将所有大于 n=5n=5 的引用次数变为 nn，得到：<br>
citations=[1,3,2,3,5]<br>
计数排序得到的结果如下：<br>
k 	     0	1	2	3	4	5<br>
count	0	1	1	2	0	1<br>
sk   	5	5	4	3	1	1<br>
其中 s_k	表示至少有 k 次引用的论文数量，在表中即为在它之后的列（包括本身）的 count 一行的和。根据定义，最大的满足k≤s 的 k 即为所求的 h。在表中，这个 k 为 3，因此 h 指数为 3。</p>
</blockquote>
<pre><code>Java
public class Solution {
    public int hIndex(int[] citations) {
        int n = citations.length;
        int[] papers = new int[n + 1];
        // 计数
        for (int c: citations)
            papers[Math.min(n, c)]++;
        // 找出最大的 k
        int k = n;
        for (int s = papers[n]; k &gt; s; s += papers[k])
            k--;
        return k;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)。在计数时，我们仅需要遍历citations 数组一次，因此时间复杂度为 O(n)。在找出最大的 k 时，我们最多需要遍历计数的数组一次，而计数的数组的长度为O(n)，因此这一步的时间复杂度为O(n)，即总的时间复杂度为 O(n)。<br>
空间复杂度：O(n)。我们需要使用 O(n) 的空间来存放计数的结果。</p>
</blockquote>
<p>方法而是利用空间换取时间，主要是（1）把大于数组范围的值置为和数组一致（2）记录大于某个引用次数的文章数（3）从大到小搜索临界值<br>
最后的代码</p>
<pre><code>class Solution {
public:
    int hIndex(vector&lt;int&gt;&amp; citations) {
        if(!citations.size())
            return 0;
        int len = citations.size();
        vector&lt;int&gt; num(len,0);
        for(auto i:citations)
            if(i)
                if(i&gt;len)
                    ++num[len-1];
                else
                    ++num[i-1];
        for(int i=num.size()-1,sum=0;i&gt;=0;--i){
            sum+=num[i];
            if(i&lt;=sum-1)
                return i+1;
        }
        return 0;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第四章 笔记+习题 4.6-4.11]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-si-zhang-bi-ji-xi-ti-46-411</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-si-zhang-bi-ji-xi-ti-46-411">
        </link>
        <updated>2019-09-09T23:51:59.000Z</updated>
        <content type="html"><![CDATA[<p>4.6<br>
ptr-&gt;mem 等价于(*ptr).mem 注意*的使用<br>
解引用符*的优先级低于点运算符. 所以必须加上括号 （*p）.size（）<br>
箭头运算符作用于一个指针类型的运算对象，结果为<strong>左值</strong>，点运算符分为两种情况，如果成员所属对象为左值，那么结果是左值，反之成员所属对象为右值，结果也为右值</p>
<p>习题4.20<br>
（a）先把指针后移一位然后解引用<br>
（b）先解引用然后把指针指向的值+1 不合法<br>
（c）先对指针调用empty（）再解引用 不合法<br>
（d）解引用指针再调用指向对象的empty（）<br>
（e）先解引用指针再把指针指向的值+1 不合法<br>
（f）解引用指针调用指向对象的empty（），再把指针+1</p>
<p>4.7<br>
条件运算符 cond?:expr1:expr2 其中expr1和expr2需类型相同或可转换为公共类型，cond为真返回expr1 否则返回expr2<br>
当条件运算符的两个表达式都是左值或者能转换成同一左值类型时结果为左值，否则为右值<br>
条件运算符可以嵌套<br>
条件运算符满足右结合律，意味着运算对象一般按照从右向左的顺序组合<br>
A=B? C:D? E:F; // 等同于A=B? C(D? E:F);<br>
条件运算符的优先级非常低 所以要加括号 而且问号应在括号外面 (a&gt;1)?b:c;</p>
<p>习题4.21</p>
<pre><code>int main() {
	vector&lt;int&gt; v{ 1,3,5 };
	for (auto &amp;i : v) 
		i = (i % 2) ? 2 * i : i;
};
</code></pre>
<p>习题4.22</p>
<pre><code>int main() {
	int grade;
	string level;
	level = (grade &lt; 60) ? &quot;fail&quot; : (grade &lt; 75) ? &quot;low pass&quot; : (grade &lt; 90) ? &quot;pass&quot; : &quot;high pass&quot;;
	
	if (grade &lt; 60)
		level = &quot;fail&quot;;
	else if(grade &lt; 75)
		level = &quot;low pass&quot;;
	else if(grade &lt; 90)
		level = &quot;pass&quot;;
	else
		level = &quot;high pass&quot;;
};
</code></pre>
<p>条件运算符比较简洁，但if运算符可读性更高<br>
习题4.23<br>
==符号和+号的优先级大于条件运算符，应对整个条件运算符语句加括号<br>
习题4.24<br>
左结合律就必须修改条件判断的位置，否则会出错</p>
<p>4.8位运算符<br>
位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合<br>
左移操作会改变符号位的值 所以最好将位运算符用于处理无符号类型<br>
移位运算符满足左结合律 （左结合律相当于满足从左到右）</p>
<p>习题4.25<br>
左移6位，变成01011100<br>
习题4.26<br>
能够表示的学生数量变少<br>
习题4.27<br>
（a）等于4（b）等于7（c）等于true（d）等于true</p>
<p>4.9sizeof运算符<br>
sizeof运算符返回所占字节数，满足右结合律，所得的值是size_t类型的<strong>常量表达式</strong>（与数组下标的类型相同）<br>
sizeof运算符返回的是占用空间的大小，而不是对象的值，因此sizeof可以使用空指针<br>
对于数组，sizeof不会把数组名转化为指针来处理；对于vector和string，只返回该类型的固定部分大小，而不会计算元素共占用了多少空间<br>
注意sizeof返回值是一个常量表达式 可以用于声明数组维度</p>
<p>习题4.28</p>
<pre><code>cout&lt;&lt;sizeof(int)&lt;&lt;endl;
cout&lt;&lt;sizeof(char)&lt;&lt;endl;
cout&lt;&lt;sizeof(double)&lt;&lt;endl;
cout&lt;&lt;sizeof(float)&lt;&lt;endl;
....
</code></pre>
<p>习题4.29<br>
第一个是数组元素的个数，第二个未定义，需要看不同机器中指针所占的空间大小和int类型所占大小的比值<br>
习题4.30<br>
（a）sizeof(x)+y（注意此处并非右结合律<br>
（b）sizeof(p-&gt;mem[i])<br>
（c） (sizeof a) &lt; b<br>
（d）无需改变。</p>
<p>4.10 逗号运算符<br>
逗号运算符的优先级是最低的，主要作用是将几个算式并列并<strong>返回最右边的算式的结果</strong><br>
逗号运算符含有两个运算对象，按照从左到右的顺序依次求值，逗号运算符的<strong>真正结果是右侧表达式的值</strong>。<br>
someValue？++x，++y：--x,--y;的结果为(someValue？++x，++y：--x),--y;</p>
<p>习题4.31<br>
前置版本更加方便，更加节省空间。不需要作改动也能生效。<br>
习题4.32<br>
对数组ia进行循环<br>
习题4.33<br>
对somevalue进行判断，然后执行相应操作，最后才进行y的前置递减，等同于someValue？++x，++y：--x,--y;的结果为(someValue？++x，++y：--x),--y;</p>
<p>4.11类型转换<br>
如果两种对象可以相互转换，就是有关联的。如果两种类型有关联，那么当程序需要其中一种类型的运算对象时可以用另一种关联类型的对象或值来替代<br>
<strong>隐式转换会尽可以避免损失进度</strong> 3+3.1415会把3转化为3.1415的double类型<br>
4.11.1算术转换<br>
注意整型提升（char、short转化为int或long）<br>
如果运算对象中有一个无符号类型且无符号类型不小于带符号类型，则带符号转化为无符号，如果带符号类型对象为负数，则带来负面影响（比如-1转化为256范围的类型会变成255）。否则的话取决于无符号类型的所有值能否存在该带符号类型中</p>
<p>习题4.34<br>
（a）fval转化为bool类型<br>
（b）ival转化为float 然后两者之和转化为double<br>
（c）char转化为int，结果再转化为double<br>
习题4.35<br>
（a）'a'从char整型提升为int 然后int结果再转化为char<br>
（b）int转化为double，然后转化为unsigned（假设ui大于ival），然后转化为float<br>
（c）取决于ui的大小<br>
（d）int转化为float，float转化为double</p>
<p>4.11.2其他隐式类型转换<br>
数组名在以下情况不会转换成指针：1.decltype 2.取地址符&amp; 3.sizeof 4.typeid 5.用一个引用来初始化数组（此处貌似有误，应该是定义数组的引用(&amp;a)[10]<br>
4.11.3显式转换<br>
显式转换本质上非常危险<br>
强制类型转换 cast-name<type>(expression);注意不要漏掉express的括号<br>
cast-name指定执行哪种变换<br>
static_cast 只要不包含底层const都能用 例如把void<em>指针的值找回来<br>
double slope = static_cast<double>(j) /i; //强制类型转换进行浮点数除法<br>
void <em>p = &amp;d; double <em>dp = static_cast&lt;double</em>&gt;(p); //把void</em>指针的值找回来<br>
const_cast 只能改变运算对象底层的const 比如把const char</em>变为char* 而不能变成string<br>
reinterpret_cast 尽量不要使用<br>
函数形式的强制类型转换 type(expr) 	C语言风格的强制类型转换(type) expr</p>
<p>习题4.36<br>
i*=int(d)<br>
习题4.37<br>
（a）void <em>pv = static_cast&lt;void</em>&gt;(const_cast&lt;string*&gt;(ps))<br>
（b）int i = static_cast<int>(*pc)<br>
（c）void <em>pv = static_cast&lt;void</em>&gt;(&amp;d)<br>
（d）char <em>pc = static_cast&lt;char</em>&gt;(&amp;pv)<br>
习题4.38<br>
将j/i的值强制转换为double 如果想保留小数部分，应该对i、j分别进行类型转换</p>
<p>习题感悟<br>
注意sizeof右结合律的意义，并是指sizeof x + y等于sizeof（x+y），而是指一个式子中出现多个sizeof时如何定义运算顺序，参考条件运算符？：<br>
someValue？++x，++y：--x,--y;的结果为(someValue？++x，++y：--x),--y;</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 134.加油站]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-134jia-you-zhan</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-134jia-you-zhan">
        </link>
        <updated>2019-09-09T14:50:55.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。<br>
你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。<br>
如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p>
<p>说明: <br>
如果题目有解，该答案即为唯一答案。<br>
输入数组均为非空数组，且长度相同。<br>
输入数组中的元素均为非负数。<br>
示例 1:<br>
输入:<br>
gas  = [1,2,3,4,5]<br>
cost = [3,4,5,1,2]<br>
输出: 3<br>
解释:<br>
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油<br>
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油<br>
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油<br>
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油<br>
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油<br>
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。<br>
因此，3 可为起始索引。<br>
示例 2:</p>
<p>输入:<br>
gas  = [2,3,4]<br>
cost = [3,4,3]<br>
输出: -1<br>
解释:<br>
你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。<br>
我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油<br>
开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油<br>
开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油<br>
你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。<br>
因此，无论怎样，你都不可能绕环路行驶一周。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/gas-station<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>一开始的思路是将两个数组相减得到差值diff，等于负数的地方是不可以作为出发点的，然后将第一个正数作为出发点（因为说只有唯一解），然后以出发点为轴翻转diff（参考之前的数组向右移位k位）然后对diff求和看最后一位是否为0。<br>
代码如下：</p>
<pre><code>class Solution {
public:
    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) {
        vector&lt;int&gt; diff;    
        for(int i = 0;i&lt;gas.size();++i)
            diff.push_back(gas[i]-cost[i]);
        int first = 0;
        for(int i = 1;i&lt;diff.size()+1;++i)
            if(diff[i-1]&gt;0){
                first=i;
                break;
            }
        if(first==0)
            return -1;
        swap_diff(diff,0,diff.size()-1);
        swap_diff(diff,0,first-1);
        swap_diff(diff,first,diff.size()-1);
        for(int i = 1;i&lt;diff.size();++i){
            diff[i]+=diff[i-1];
            if(i!=(diff.size()-1)&amp;&amp;diff[i]&lt;=0)
                return -1;
            }
        if(diff[diff.size()-1]&gt;=0)
            return first-1;
        else
            return -1;
    }
    void swap_diff(vector&lt;int&gt;&amp; diff,int beg,int last){
        for(int i=beg;i&lt;last;++i){
            int temp = diff[i];
            diff[i]=diff[last];
            diff[last]=temp;
            if(--last == i)
                break;
        }
    }
};
</code></pre>
<p>这段代码是很有问题的，diff中的正数可能有多个，只考虑第一个的话，万一是{1，-10，11，...}的情况肯定白给了。如果对diff中的正数进行逐个参考，那么时间复杂度直接变成n^2，得不偿失，所以我的算法是有本质的问题的，所以打算直接看题解，官方题解如下：</p>
<blockquote>
<p>1.如果 sum(gas) &lt; sum(cost) ，那么不可能环行一圈，这种情况下答案是 -1 。<br>
我们可以用这个式子计算环行过程中邮箱里剩下的油：total_tank = sum(gas) - sum(cost) ，如果 total_tank &lt; 0 则返回 -1 。<br>
2.对于加油站 i ，如果 gas[i] - cost[i] &lt; 0 ，则不可能从这个加油站出发，因为在前往 i + 1 的过程中，汽油就不够了。<br>
第二个规则可以被一般化，我们引入变量 curr_tank ，记录当前油箱里剩余的总油量。如果在某一个加油站 curr_tank比 0 小，意味着我们无法到达这个加油站。<br>
下一步我们把这个加油站当做新的起点，并将 curr_tank 重置为 0 ，因为重新出发，油箱中的油为 0 。（从上一次重置的加油站到当前加油站的任意一个加油站出发，到达当前加油站之前， curr_tank 也一定会比 0 小）</p>
<p>整体算法：<br>
那么现在算法是很直接明了的：<br>
初始化 total_tank 和 curr_tank 为 0 ，并且选择 0 号加油站为起点。<br>
遍历所有的加油站：<br>
每一步中，都通过加上 gas[i] 和减去 cost[i] 来更新 total_tank 和 curr_tank 。<br>
如果在 i + 1 号加油站， curr_tank &lt; 0 ，将 i + 1 号加油站作为新的起点，同时重置 curr_tank = 0 ，让油箱也清空。<br>
如果 total_tank &lt; 0 ，返回 -1 ，否则返回 starting station。</p>
</blockquote>
<pre><code>class Solution:
    def canCompleteCircuit(self, gas, cost):
        &quot;&quot;&quot;
        :type gas: List[int]
        :type cost: List[int]
        :rtype: int
        &quot;&quot;&quot;
        n = len(gas)
        
        total_tank, curr_tank = 0, 0
        starting_station = 0
        for i in range(n):
            total_tank += gas[i] - cost[i]
            curr_tank += gas[i] - cost[i]
            # If one couldn't get here,
            if curr_tank &lt; 0:
                # Pick up the next station as the starting one.
                starting_station = i + 1
                # Start with an empty tank.
                curr_tank = 0
        
        return starting_station if total_tank &gt;= 0 else -1
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(N) ， 这是因为只有一个遍历了所有加油站一次的循环。<br>
空间复杂度： O(1) ，因为此算法只使用了常数个变量。</p>
</blockquote>
<p>关于算法原理可以看官方题解和高赞题解的详细解答。<br>
这是最后代码：</p>
<pre><code>class Solution {
public:
    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) {
        int sum=0;
        int curr=0;
        int first=0;
        for(int i=0;i&lt;gas.size();++i){
            sum+=gas[i]-cost[i];
            curr+=gas[i]-cost[i];
            if(curr&lt;0)
            {
                first=i+1;
                curr=0;
            }
        }
        return sum&gt;=0?first:-1;
    }
};
</code></pre>
<p>感想：还是得打好数学基础啊！这题没有理解这个数学概念（如果一个数组的总和非负，那么一定可以找到其中找到一个点开始，累加和一直都是非负的）的话就直接白给了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ C++ primer 第四章 笔记+习题 4.1-4.5]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-si-zhang-bi-ji-xi-ti-41-45</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-si-zhang-bi-ji-xi-ti-41-45">
        </link>
        <updated>2019-09-09T11:50:55.000Z</updated>
        <content type="html"><![CDATA[<p>4.1.1<br>
字面值和变量是最简单的表达式<br>
函数调用也是一种特殊的运算符<br>
小整数类型（bool、char、short）一般会被提升为较大的整数类型，主要是int<br>
左值可以位于赋值语句的左侧，右值则不能 另一种解释：左值指的是既能够出现在等号左边也能出现在等号右边的变量(或表达式)，右值指的则是只能出现在等号右边的变量(或表达式).<br>
当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）<br>
在需要右值的地方可以用左值来代替，但是不能把右值当成左值（也就是位置）来使用</p>
<ol>
<li>赋值运算符 需要一个非常量的左值作为其左侧运算对象，得到的结果也仍然是一个左值。</li>
<li>取地址符 作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值。</li>
<li>内置解引用运算符、下标运算符、迭代器解引用运算符、string和vector的下标运算符的求值结果都是左值</li>
<li>内置类型和迭代器的递增递减运算符作用于左值运算对象，其前置版本所得结果也是左值（后置版本则将对象原始值的副本作为右值返回。）</li>
<li>decltype中，如果表达式的求值结果是一个左值，则得到一个引用类型。例如 p的类型是int*，解引用符生成左值，所以 decltype（*p）的结果是int&amp;。另一方面，取地址运算符生成右值，<strong>所以decltype（&amp;p）的结果为int，指向整形指针的指针。</strong><br>
4.1.2<br>
括号无视优先级和结合律<br>
结合律对表达式产生影响的一个典型示例是输入输出运算 cin&gt;&gt;v1&gt;&gt;v2;//<strong>左结合律，先读入v1，再读入v2</strong></li>
</ol>
<p>习题4.1<br>
105，和平常的运算顺序一致<br>
习题4.2<br>
（a）*(vec.begin) （b）*(vec.begin)+1<br>
知识点：调用运算符的优先级高于解引用运算符</p>
<p>4.1.3<br>
表达式中的求值顺序是不确定的，尽量不要在表达式中进行求值 比如 cout&lt;&lt;i&lt;&lt;++i;<br>
有四种运算符明确规定了运算对象的求值顺序（<strong>先左后右</strong>） 1.逻辑与&amp;&amp; 2.逻辑或 3.条件运算符 ?:   4.逗号运算符</p>
<p>习题4.3<br>
可以，程序员可以灵活使用括号符，应当承担保证代码正确的责任，进一步提高效率。</p>
<p>4.2<br>
左结合律：优先级相同时从左到右进行组合<br>
算术运算符的运算对象和求值对象都是右值<br>
在表达式求值前，小整数类型（bool、char、short）一般会被提升为较大的整数类型<br>
一元运算符可以作用于一个指针 或 算术值 得到一个提升后的副本 比如 bool b=true；  -b为true 运算过程为  负号使得b变为int类型并等于1 取负后得到-1 -1再变为布尔类型得到真。<br>
除法运算中商无论正负，一律向0取整，即直接切除小数部分<br>
<strong>取模运算中 结果的符号与被除数相同。</strong></p>
<p>习题4.4<br>
(12/3*4)+(5*15)+(24%4/2) = 91<br>
习题4.5<br>
（a）-86（b）-18（c）0（d）-2<br>
习题4.6</p>
<pre><code>if（a%2） 
	cout&lt;&lt;&quot;奇数&quot;&lt;&lt;endl; 
else
	cout&lt;&lt;&quot;偶数&quot;&lt;&lt;endl; 
</code></pre>
<p>习题4.7<br>
当前值大于变量类型所能容纳的范围<br>
int i = 2^16+1;double d=2^64+1 ;int i = -2^16-1</p>
<p>4.3<br>
关系运算符用于算术类型或指针类型，逻辑运算符作用于任意能转换成布尔值的类型 两者的返回值都是布尔类型，都是右值<br>
将更重要的条件放在逻辑运算符的<strong>左边</strong><br>
在if（val == true）语句中，<strong>会先将true转换为val的类型，而不是将val转换为布尔类型，</strong> 等同于if（val == 1）所以一般使用if（val）<br>
进行比较运算时除非比较的对象是布尔类型，否则不要用true和false来作为运算对象<br>
习题4.8<br>
先左后右<br>
习题4.9<br>
先判断cp的值是否为零，如果不为0再判断*p的值是否为0<br>
习题4.10</p>
<pre><code>int i；
while（cin&gt;&gt;i）
	if(i==42)
		break;
</code></pre>
<p>习题4.12<br>
先判断j&lt;k是否成立，得到bool值转化为0或1，再与i比较是否相等！等同于  if(i!=(j&lt;k) )<br>
知识点：右结合律，并且使用类型转换</p>
<p>4.4<br>
赋值运算符的左侧运算对象必须是一个可修改的左值<br>
赋值运算符的结果是它的左侧运算对象，并且是一个左值<br>
使用花括号进行初始值列表初始化的时候<strong>不允许出现窄化转换</strong>，即精确度损失 int i; i = {3.14}是错误的<br>
初始值列表可以为空，无论左侧运算对象的类型是什么，此时编译器创建一个<strong>值初始化的临时量赋给左侧运算对象，比如int为0 ，string为空</strong><br>
赋值运算符满足<strong>右结合律</strong>，<strong>因此 ival = jval = 0；的运算是正确的</strong><br>
多重赋值语句需要类型相同或者是可以相互转换的类型<br>
<strong>不能把指针的值赋给int</strong>，因为int*无法转换成 int<br>
赋值运算符等级较低，最好多用括号<br>
a += b与 a = a + b的区别在于<strong>复合运算符只求值一次，普通运算符求值两次</strong><br>
（题目 4.13）</p>
<p>习题4.13<br>
（a）d=i=3（注意右结合律导致精度损失 ）（b）i=3 d=3.5<br>
知识点：赋值语句右结合律，精度损失<br>
习题4.14<br>
第一个报错，第二个永远等于true<br>
习题4.15<br>
不能把int*赋给int，就算当中的值可以视为一个整数<br>
习题4.16<br>
右结合律<br>
（a） (p=getPtr())!=0（b）i==1024</p>
<p>4.5递增和递减运算符<br>
前置++和后置++都必须作用于左值运算对象，前置版本将对象本身作为左值返回，<strong>后置版本则将对象原始值的副本作为右值返回。</strong><br>
后置递增运算符比较消耗性能，降低了可读性，除非能够使程序更简洁，否则不建议使用<br>
如果想在一条复合表达式中既将变量+1或-1又能使用它原来的值，就应当使用后置递增递减符<br>
*ptr++ 等同于*(ptr++)** 递增运算符的优先级高于解引用运算符**<br>
<strong>运算对象可按任意顺序求值</strong>，所以*ptr = func(*ptr++);的最终结果是<strong>未定义的</strong>，最终结果取决于编译器自身执行的顺序</p>
<p>习题4.17<br>
前置递增运算符在使用变量前递增，后置递增符则在使用后递增<br>
习题4.18<br>
先向前移动再解引用，容易导致访问未知地址的值<br>
习题4.19<br>
（a）不正确，前者判断是否为空指针，后者则先递增指针再判断值是否为0，容易读取到未知值<br>
（b）判断ival和ival+1两个值是否都非0<br>
（c）未定义值，不知道++在何时运行（注意和&amp;&amp;的区别，&amp;&amp;是必需先完成右边再算左边）</p>
<p>习题感悟<br>
if（i！=j&lt;k）等同于  if(i!=(j&lt;k) ) 右结合律<br>
int i;double d; d=i=3.5;//d=i=3（注意右结合律导致精度损失 ）<br>
不能把int*赋给int，就算当中的值可以视为一个整数<br>
ival++&amp;&amp;ival 判断ival和ival+1两个值是否都非0，注意先判断ival再递增，再判断右边值</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 299 猜数字游戏]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-299-cai-shu-zi-you-xi</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-299-cai-shu-zi-you-xi">
        </link>
        <updated>2019-09-09T03:17:52.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目如下：<br>
你正在和你的朋友玩 猜数字（Bulls and Cows）游戏：你写下一个数字让你的朋友猜。每次他猜测后，你给他一个提示，告诉他有多少位数字和确切位置都猜对了（称为“Bulls”, 公牛），有多少位数字猜对了但是位置不对（称为“Cows”, 奶牛）。你的朋友将会根据提示继续猜，直到猜出秘密数字。<br>
请写出一个根据秘密数字和朋友的猜测数返回提示的函数，用 A 表示公牛，用 B 表示奶牛。<br>
请注意秘密数字和朋友的猜测数都可能含有重复数字。</p>
<p>示例 1:<br>
输入: secret = &quot;1807&quot;, guess = &quot;7810&quot;<br>
输出: &quot;1A3B&quot;<br>
解释: 1 公牛和 3 奶牛。公牛是 8，奶牛是 0, 1 和 7。<br>
示例 2:<br>
输入: secret = &quot;1123&quot;, guess = &quot;0111&quot;<br>
输出: &quot;1A1B&quot;<br>
解释: 朋友猜测数中的第一个 1 是公牛，第二个或第三个 1 可被视为奶牛。<br>
说明: 你可以假设秘密数字和朋友的猜测数都只包含数字，并且它们的长度永远相等。</p>
</blockquote>
<p>题目非常拗口....完全就是美式风格，一种为了出题而强行出题的感觉，而且本土化做得不够，公牛奶牛bullscows完全和题目对应不上，这是要扣钱的啊！<br>
还是先说一下思路吧<br>
我一开始其实并没有太好的想法，然后遍历对比相等的数量，最后再遍历对比，时间复杂度为o(n^2),空间复杂度为o(1),比较笨的方法，先把时间复杂度降下来，又发现空间复杂度上去了，所以还是老老实实看题解吧</p>
<p>这一次没有官方题解，依旧是网友题解：</p>
<blockquote>
<p>方法一：我的思路很简单，先遍历一次字符串，如果两个字符串当前索引字符相同，则将&quot;公牛数&quot;加一；否则，将秘密字符串的字符放入HashMap中，进行次数统计，将猜的字符放入一个Array中。<br>
第一次遍历完毕后进行第二次遍历，此时的array中是猜的字符串中没有对上号的字符，依次获取array中的字符，看HashMap中是否有该字符，如果有，则让&quot;母牛数&quot;加一，然后将该字符的次数减一，如果该字符在Map中的次数为零则清除。<br>
方法一代码如下：</p>
<pre><code>/*
    Time complexity: O(n)
    Space complexity: O(n)
 */
public String getHint(String secret, String guess) {
    int aCount = 0;
    int bCount = 0;
    ArrayList&lt;Character&gt; list = new ArrayList&lt;&gt;();
    HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();
    for (int i = 0; i &lt; secret.length(); i++) {
        char temp = secret.charAt(i);
        if (temp == guess.charAt(i))
            aCount++;
        else {
            list.add(guess.charAt(i));
            if (map.containsKey(temp))
                map.put(temp, map.get(temp) + 1);
            else
                map.put(temp, 1);
        }
    }
    for (Character c : list) {
        if (map.containsKey(c)) {
            bCount++;
            map.put(c, map.get(c) - 1);
            if (map.get(c) == 0)
                map.remove(c);
        }
    }
    return aCount + &quot;A&quot; + bCount + &quot;B&quot;;
}
</code></pre>
<p>方法二：由于猜的数字只包括0~9这九位数字，因此我们可以定义两个10位数组来存储某个数出现的次数，索引代表数值，索引处的值代表次数。<br>
思路如下：先遍历一次字符串，如果字符相等，公牛数加一，否则，将它们对应的数组中的次数加一。<br>
第一次遍历完毕后可以得到两个数组，分别对应了两个字符串中某一个数出现的次数(匹配的字符不算)，然后我们可以再进行一次遍历，两个数组每一个索引处的最小值相加即可得到母牛数。<br>
代码如下：</p>
<pre><code>/*
    Time complexity: O(n)
    Space complexity: O(n)
 */
public String getHint(String secret, String guess) {
    int aCount = 0;     // 公牛数
    int bCount = 0;     // 母牛数
    //int mapS[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    //int mapG[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    int[] mapS[] = new int[10];
    int[] mapG[] = new int[10];

    for (int i = 0; i &lt; secret.length(); i++) {
        char temp = secret.charAt(i);
        if (temp == guess.charAt(i))
            aCount++;
        else {
            mapS[temp - '0']++;
            mapG[guess.charAt(i) - '0']++;
        }
    }
    for (int i = 0; i &lt; 10; i++) {
        bCount += Math.min(mapG[i], mapS[i]);
    }
    return aCount + &quot;A&quot; + bCount + &quot;B&quot;;
}
</code></pre>
<p>作者：janvysun<br>
链接：https://leetcode-cn.com/problems/bulls-and-cows/solution/javaliang-chong-fang-fa-by-janvysun/<br>
来源：力扣（LeetCode）<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>&quot;Bulls&quot;：遍历两个字符串，相同位置相同字符的个数</p>
<p>&quot;Cows&quot;：排出完全猜对的数字，统计secret中剩余数字和出现的次数，再比对guess中出现相同数的次数</p>
<p>public String getHint(String secret, String guess) {<br>
int bulls = 0, cows = 0;<br>
int[] dict = new int[10];<br>
//计数<br>
for (int i = 0; i &lt; secret.length(); i++) {<br>
dict[secret.charAt(i) - '0']++;<br>
}</p>
<pre><code>for (int i = 0; i &lt; guess.length(); i++) {
    if (guess.charAt(i) == secret.charAt(i)) {
        bulls++;
        dict[secret.charAt(i) - '0']--;
        if (dict[secret.charAt(i) - '0'] &lt; 0) cows--;
    } else if (dict[guess.charAt(i) - '0'] &gt; 0) {
        cows++;
        dict[guess.charAt(i) - '0']--;
    }
}

return bulls + &quot;A&quot; + cows + &quot;B&quot;;
</code></pre>
<p>}</p>
<p>作者：zxy0917<br>
链接：https://leetcode-cn.com/problems/bulls-and-cows/solution/java-shi-yong-zi-dian-shu-zu-by-zxy0917/<br>
来源：力扣（LeetCode）<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<p>上面两种方法其实我都不是特别满意，首先是不太希望用hash-map，用了确实方便很多，但是还是希望用基础的数组知识解决。上面的方法还是给我很多启发的，首先是空间复杂度可以压低到长度为10的数组，反正就是个数字（0-9），然后是string的数字转化为阿拉伯数字（secret.charAt(i) - '0'），对bulls和cows的处理：</p>
<p>下面是最终代码：</p>
<pre><code>class Solution {
public:
    string getHint(string secret, string guess) {
	int Bulls = 0, Cows = 0;
	vector&lt;int&gt; v(10, 0);
	for (auto i : secret)
			++v[i - '0'];
	for (int i = 0; i&lt;guess.size(); ++i)
		if (guess[i] == secret[i]) {
			++Bulls;
			--v[guess[i] - '0'];
			guess[i] = 'a';
		}
	for (int i = 0; i&lt;guess.size(); ++i)
		if (guess[i] != 'a')
			if(v[guess[i] - '0'] &gt; 0) {
			--v[guess[i] - '0'];
			++Cows;
		}
        string b = to_string(Bulls)+'A'+to_string(Cows)+'B';
        return b;
    }
};
</code></pre>
<p>中间遇到一些坑：<br>
1.string的数字（实际上是ASCII编码）怎么转化为阿拉伯数字呢？上面的题解给我的思路就是guess[i] - '0'，挺不错的，查了很多方法都比较复杂，这个挺好的。<br>
2.相等值的干扰，本来以为相等值最好处理，结果是最难处理的干扰因素，前面的提交错误都是Bulls造成Cows值错误，题解中的处理比较复杂，我是直接暴力地把它变成'a'然后再加判断条件，最后通过了。</p>
<p>感想：其实这一次做题有点特殊，六点多起床到实验室做题，下午得作报告，本来想着八点多做完吃个早餐就开始忙活报告的事，结果这道题一直提交错误，各种特例出错，心态有点爆炸，不止一次出现放弃然后贴代码的念头，自己心烦意乱也没法好好分析，幸好最后还是咬咬牙坚持了下来能够一步一步地改过来，下午的会议也出奇地顺利，所以还是努力吧，未来的自己一定会感激现在努力的自己。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 41. 缺失的第一个正数[困难]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-41-que-shi-de-di-yi-ge-zheng-shu-kun-nan</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-41-que-shi-de-di-yi-ge-zheng-shu-kun-nan">
        </link>
        <updated>2019-09-08T13:24:52.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个未排序的整数数组，找出其中没有出现的最小的正整数。<br>
示例 1:<br>
输入: [1,2,0]<br>
输出: 3<br>
示例 2:<br>
输入: [3,4,-1,1]<br>
输出: 2<br>
示例 3:<br>
输入: [7,8,9,11,12]<br>
输出: 1<br>
说明:<br>
你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/first-missing-positive<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>第一次做困难的题，还是比较紧张的<br>
下意识想到的办法是建立另外一个数组，利用这个数组的下标来存储已经有的数值（此时其实已经犯了一个错误，常数级别的空间就意味着必须原地操作）<br>
然后考虑需要处理的情况有<br>
1.把负值全部变为0；<br>
2.取最大值作为另外一个数组的大小值；<br>
因为昨天回家了，所以是在平板上做题的，没有保存好代码，只保存了最后的代码</p>
<pre><code>public:
    int firstMissingPositive(vector&lt;int&gt;&amp; nums) {
        if(nums.size()==0)
            return 1;
        for (int i=0;i&lt;nums.size();++i)
            if(nums[i]&gt;nums.size())
                nums[i] = 0; 
        vector&lt;int&gt; norm(nums.size(),0);
        for(auto i : nums)
            if(i&gt;0){
                norm[i-1]=1;
            }
        for(int i = 0;i&lt;nums.size();++i)
            if(norm[i]!=1)
                return i+1;
        return nums.size()+1;     
    }

</code></pre>
<p>最后提交还是毫无疑问地出错了。。。系统给我安排一个过亿的数值能不出错嘛。。。<br>
这个时候不小心瞄到一眼答案，发现必须把大于数组长度的值置为0，hhh修改后就通过啦！（当然此时已经不符合常数级别空间的要求）</p>
<p>官方题解如下（图比较多，比较麻烦）</p>
<blockquote>
<p>方法 1：索引作为哈希表。<br>
数据预处理</p>
<p>首先我们可以不考虑负数和零，因为不需要考虑。同样可以不考虑大于 n 的数字，<br>
因为首次缺失的正数一定小于或等于 n + 1 。<br>
缺失的正数为 n + 1 的情况会单独考虑。<br>
为了不考虑这些数，又要保证时间复杂度为O(N) ，因此<br>
不能将这些元素弹出。我们可以将这些数用 1 替换。<br>
为了确保缺失的第一个正数不是 1，先要在这步操作前确定 1 是否存在。</p>
<p>如何实现就地算法<br>
现在我们有一个只包含正数的数组，范围为 1 到 n，<br>
现在的问题是在 \mathcal{O}(N)O(N) 的时间和常数空间内找出首次缺失的正数。<br>
如果可以使用哈希表，且哈希表的映射是 正数 -&gt; 是否存在 的话，这其实很简单。<br>
&quot;脏工作环境&quot; 的解决方法是将一个字符串 hash_str 分配 n 个 0，并且用类似于哈希表的方法，如果在数组中出现数字 i 则将字符串中 hash_str[i] 修改为 1 。</p>
<p>我们不使用这种方法，但是借鉴这种 使用索引作为哈希键值 的想法。<br>
最终的想法是 使用索引作为哈希键 以及 元素的符号作为哈希值 来实现是否存在的检测。<br>
例如，nums[2] 元素的负号意味着数字 2 出现在 nums 中。nums[3]元素的正号表示 3 没有出现在 nums 中。<br>
为了完成此操作，我们遍历一遍数组（该操作在数据预处理使得数组中只有正数的操作后），检查每个元素值 elem 以及将nums[elem] 元素的符号变为符号来表示数字 elem 出现在 nums 中。注意，当数字出现多次时需要保证符号只会变化 1 次。<br>
算法</p>
<p>现在可以开始写算法了。</p>
<p>检查 1 是否存在于数组中。如果没有，则已经完成，1 即为答案。<br>
如果 nums = [1]，答案即为 2 。<br>
将负数，零，和大于 n 的数替换为 1 。<br>
遍历数组。当读到数字 a 时，替换第 a 个元素的符号。<br>
注意重复元素：只能改变一次符号。由于没有下标 n ，使用下标 0 的元素保存是否存在数字 n。<br>
再次遍历数组。返回第一个正数元素的下标。<br>
如果 nums[0] &gt; 0，则返回 n 。<br>
如果之前的步骤中没有发现 nums 中有正数元素，则返回n + 1。<br>
代码</p>
<p>JavaPython<br>
class Solution {<br>
public int firstMissingPositive(int[] nums) {<br>
int n = nums.length;</p>
<pre><code>// 基本情况
int contains = 0;
for (int i = 0; i &lt; n; i++)
  if (nums[i] == 1) {
    contains++;
    break;
  }

if (contains == 0)
  return 1;

// nums = [1]
if (n == 1)
  return 2;

// 用 1 替换负数，0，
// 和大于 n 的数
// 在转换以后，nums 只会包含
// 正数
for (int i = 0; i &lt; n; i++)
  if ((nums[i] &lt;= 0) || (nums[i] &gt; n))
    nums[i] = 1;

// 使用索引和数字符号作为检查器
// 例如，如果 nums[1] 是负数表示在数组中出现了数字 `1`
// 如果 nums[2] 是正数 表示数字 2 没有出现
for (int i = 0; i &lt; n; i++) {
  int a = Math.abs(nums[i]);
  // 如果发现了一个数字 a - 改变第 a 个元素的符号
  // 注意重复元素只需操作一次
  if (a == n)
    nums[0] = - Math.abs(nums[0]);
  else
    nums[a] = - Math.abs(nums[a]);
}

// 现在第一个正数的下标
// 就是第一个缺失的数
for (int i = 1; i &lt; n; i++) {
  if (nums[i] &gt; 0)
    return i;
}

if (nums[0] &gt; 0)
  return n;

return n + 1;
</code></pre>
<p>}<br>
}<br>
复杂性分析<br>
时间复杂度： O(N) 由于所有的操作一共只会遍历长度为 N 的数组 4 次。<br>
空间复杂度： O(1) 由于只使用了常数的空间。</p>
</blockquote>
<p>最后还是很精妙的，当然前期处理非常重要，然后还有一点很重要，只有当当前下标的值处理好后，才会进行下标递增！（可以参考题解中的桶排序，其中精妙的思想还有如下：</p>
<blockquote>
<p>补充内容：<br>
交换两个整数，有两种比较 tricky 的做法。下面给出结论。<br>
“基于异或运算”是因为利用了“异或运算”是不进位的二进制加法。它有如下性质：<br>
如果 a ^ b = c ，那么 a ^ c = b 与 b ^ c = a 同时成立，利用这一条，可以用于交换两个变量的值。<br>
于是，交换两个变量的值，例如 a 和 b，不使用第三个变量，有两种不同的方法：<br>
基于异或运算	<br>
a = a ^ b<br>
b = a ^ b<br>
a = a ^ b<br>
基于加减法<br>
a = a + b<br>
b = a - b<br>
a = a - b<br>
我理解的方式就是自己在纸上写几个例子，并且记住这个结论。个人觉得“基于异或运算”交换两个变量的值好记一些，因为右边都一样，左边依次是 a、b、a。</p>
<p>在这里特别感谢用户 @davidlaid 给出的意见：<br>
对于异或运算实现的交换方法，如果调用 swap(nums, i, i)，那么最终的结果会变为 0。<br>
对于加减法实现的交换方法，有可能发生溢出。<br>
调用 swap(nums, i, i)，那么最终的结果会变为 0 这是因为，如果是在数组中，自己和自己交换，只有 1 个空间，这个数会在异或运算的过程中变为 0，因此单独判断一下就好了。我个人还是比价少用这个技巧的，如果题目中限制了不能使用额外的存储空间，才用“基于异或运算实现的交换方法”。</p>
<p>参考代码 2：基于异或运算交换两个变量的值。<br>
PythonPythonJava<br>
from typing import List<br>
class Solution:<br>
def firstMissingPositive(self, nums: List[int]) -&gt; int:<br>
size = len(nums)<br>
for i in range(size):<br>
while 1 &lt;= nums[i] &lt;= size and nums[i] != nums[nums[i] - 1]:<br>
self.__swap(nums, i, nums[i] - 1)<br>
for i in range(size):<br>
if i + 1 != nums[i]:<br>
return i + 1<br>
return size + 1</p>
<pre><code>def __swap(self, nums, index1, index2):
    if index1 == index2:
        return
    nums[index1] = nums[index1] ^ nums[index2]
    nums[index2] = nums[index1] ^ nums[index2]
    nums[index1] = nums[index1] ^ nums[index2]
</code></pre>
<p>作者：liweiwei1419<br>
链接：https://leetcode-cn.com/problems/first-missing-positive/solution/tong-pai-xu-python-dai-ma-by-liweiwei1419/<br>
来源：力扣（LeetCode）<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<p>异或互换和加法互换都很神奇，实现了两个对象之间的互换而不需要额外的参数！所以从别人身上学到了很多有趣的东西啊，也同时验证了我之前的随心感想，在leetcode还是可以学到很多知识的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 189.旋转数组]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-189xuan-zhuan-shu-zu</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-189xuan-zhuan-shu-zu">
        </link>
        <updated>2019-09-06T13:27:51.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p>
<p>示例 1:</p>
<p>输入: [1,2,3,4,5,6,7] 和 k = 3<br>
输出: [5,6,7,1,2,3,4]<br>
解释:<br>
向右旋转 1 步: [7,1,2,3,4,5,6]<br>
向右旋转 2 步: [6,7,1,2,3,4,5]<br>
向右旋转 3 步: [5,6,7,1,2,3,4]</p>
<p>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。<br>
要求使用空间复杂度为 O(1) 的 原地 算法。</p>
</blockquote>
<blockquote>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/rotate-array<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>按照昨天学习到的思想，对题目进行分解：<br>
首先是特殊情况：k == 0 || nums.size() == 0 || nums.size() == 1 || nums.size() == k，直接白给return<br>
然后是两种情况<br>
第一种 k大于size 第二种k小于size<br>
其实第一种可以通过k%size转化为第二种（发现自己居然忘了c++的取余数为%）<br>
但是最后被旋转原地移动难住了，最后只能暴力出奇迹，一位一位地移动了：</p>
<pre><code>class Solution {
	public:
		void rotate(vector&lt;int&gt;&amp; nums, int k) {
			if (k == 0 || nums.size() == 0 || nums.size() == 1 || nums.size() == k)
				return;
			else if (nums.size()&lt;k)
				k = k%nums.size();
			while (k&gt;0) {
				int temp = nums[nums.size() - 1];
				for (int j = nums.size() - 1; j&gt;0; --j)
					nums[j] = nums[j - 1];
				nums[0] = temp;
				--k;
			}
			return;
		}
	};
</code></pre>
<p>最后提交居然超过了时间限制？<br>
一看题解，what？第一个就是暴力解啊？？？我的还是做了情况优化的，把Java代码转化为C++，还是白给了。。。C++无人权啊！！！<br>
题解明天再看吧，剩下的时间处理一下c++，星期一还得报告呢<br>
今天很无语，遇到很奇葩的事情了，详情看随心感想吧，<br>
第一次无法按时完成任务...好无力啊</p>
<p>9.8补充：<br>
官方题解<br>
第一个就是暴力题解了，只是c++铁定会超时，就算进行情况优化和把官方java题解照搬过来也是全部木大，后来才发现leetcode会对c++严格很多</p>
<blockquote>
<p>题解二：<br>
方法 2：使用额外的数组<br>
算法<br>
我们可以用一个额外的数组来将每个元素放到正确的位置上，也就是原本数组里下标为 ii 的我们把它放到 (i+k)%数组长度(i+k)%数组长度 的位置。然后把新的数组拷贝到原数组中。<br>
Java<br>
public class Solution {<br>
public void rotate(int[] nums, int k) {<br>
int[] a = new int[nums.length];<br>
for (int i = 0; i &lt; nums.length; i++) {<br>
a[(i + k) % nums.length] = nums[i];<br>
}<br>
for (int i = 0; i &lt; nums.length; i++) {<br>
nums[i] = a[i];<br>
}<br>
}<br>
}<br>
复杂度分析<br>
时间复杂度： O(n) 。将数字放到新的数组中需要一遍遍历，另一边来把新数组的元素拷贝回原数组。<br>
空间复杂度： O(n)。另一个数组需要原数组长度的空间。</p>
</blockquote>
<p>题解二比较简单，但是空间复杂度比较高，在常数空间复杂度的情况下并不适用</p>
<blockquote>
<p>题解三：<br>
方法 3：使用环状替换<br>
算法<br>
如果我们直接把每一个数字放到它最后的位置，但这样的后果是遗失原来的元素。因此，我们需要把被替换的数字保存在变量 temp 里面。然后，我们将被替换数字（temp）放到它正确的位置，并继续这个过程 n 次， n 是数组的长度。这是因为我们需要将数组里所有的元素都移动。但是，这种方法可能会有个问题，如果 n%k==0，其中 k=k%n （因为如果 k 大于 n ，移动 k 次实际上相当于移动 k%n 次）。这种情况下，我们会发现在没有遍历所有数字的情况下回到出发数字。此时，我们应该从下一个数字开始再重复相同的过程。</p>
<p>现在，我们看看上面方法的证明。假设，数组里我们有 n 个元素并且 k 是要求移动的次数。更进一步，假设 n%k=0 。第一轮中，所有移动数字的下标 i满足 i%k<mark>0。这是因为我们每跳 k 步，我们只会到达相距为 k 个位置下标的数。每一轮，我们都会移动n/k个元素。下一轮中，我们会移动满足 i%k</mark>1的位置的数。这样的轮次会一直持续到我们再次遇到i%k==0 的地方为止，此时 i=k 。此时在正确位置上的数字共有k*n/k 	 =n 个。因此所有数字都在正确位置上。<br>
让我们看一下接下来的例子，以更好地说明这个过程：<br>
nums: [1, 2, 3, 4, 5, 6]<br>
k: 2<br>
Java<br>
public class Solution {<br>
public void rotate(int[] nums, int k) {<br>
k = k % nums.length;<br>
int count = 0;<br>
for (int start = 0; count &lt; nums.length; start++) {<br>
int current = start;<br>
int prev = nums[start];<br>
do {<br>
int next = (current + k) % nums.length;<br>
int temp = nums[next];<br>
nums[next] = prev;<br>
prev = temp;<br>
current = next;<br>
count++;<br>
} while (start != current);<br>
}<br>
}<br>
}<br>
复杂度分析</p>
<p>时间复杂度：O(n) 。只遍历了每个元素一次。<br>
空间复杂度：O(1) 。使用了常数个额外空间。</p>
</blockquote>
<p>第三个就是我一开始想到的操作了，但是还是算是比较复杂，我更喜欢第四个：</p>
<blockquote>
<p>方法 4：使用反转<br>
算法<br>
这个方法基于这个事实：当我们旋转数组 k 次， k%n 个尾部元素会被移动到头部，剩下的元素会被向后移动。<br>
在这个方法中，我们首先将所有元素反转。然后反转前 k 个元素，再反转后面 n-k 个元素，就能得到想要的结果。<br>
假设 n=7 且k=3 。</p>
<p>原始数组                  : 1 2 3 4 5 6 7<br>
反转所有数字后             : 7 6 5 4 3 2 1<br>
反转前 k 个数字后          : 5 6 7 4 3 2 1<br>
反转后 n-k 个数字后        : 5 6 7 1 2 3 4 --&gt; 结果<br>
Java<br>
public class Solution {<br>
public void rotate(int[] nums, int k) {<br>
k %= nums.length;<br>
reverse(nums, 0, nums.length - 1);<br>
reverse(nums, 0, k - 1);<br>
reverse(nums, k, nums.length - 1);<br>
}<br>
public void reverse(int[] nums, int start, int end) {<br>
while (start &lt; end) {<br>
int temp = nums[start];<br>
nums[start] = nums[end];<br>
nums[end] = temp;<br>
start++;<br>
end--;<br>
}<br>
}<br>
}<br>
复杂度分析</p>
<p>时间复杂度：O(n)。 nn 个元素被反转了总共 3 次。<br>
空间复杂度：O(1) 。 没有使用额外的空间。</p>
</blockquote>
<p>哈哈哈可以说是非常优雅了，一开始我也想到翻转，但是却没想到可以翻转两次！666！<br>
后面是我的代码：</p>
<pre><code>class Solution {
public:
    void rotate(vector&lt;int&gt;&amp; nums, int k) {
        if (k == 0 || nums.size() == 0 || nums.size() == 1 || nums.size() == k)
			return;
		else if (nums.size()&lt;k)
			k = k%nums.size();
        swap_num(nums,0,nums.size()-1);
        swap_num(nums,0,k-1);
        swap_num(nums,k,nums.size()-1);
        
    }
    void swap_num(vector&lt;int&gt;&amp; nums,int first,int last){
        while(first&lt;last){
            int temp = nums[first];
            nums[first] = nums[last];
            nums[last] = temp;
            ++first;--last;
        }
    }
};
</code></pre>
<p>总体来说这一次还是有不小的进步的，开始学会思考情况了，但是解决问题的能力还是有待提高啊！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第三章 笔记+习题 3.5-3.6]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-san-zhang-bi-ji-xi-ti-35-36</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-san-zhang-bi-ji-xi-ti-35-36">
        </link>
        <updated>2019-09-06T07:17:15.000Z</updated>
        <content type="html"><![CDATA[<p>3.5<br>
数组大小固定 如果元素个数不确定，就是用vector<br>
数组声明 a[d] 其中d必须是一个常量字面值或者是一个<strong>常量表达式</strong><br>
非内置的数据类型默认初始化为空<br>
函数内部定义的数组 默认初始化会含有未定义的值<br>
数组定义时必须指定数组的类型，<strong>不允许用auto关键字</strong><br>
引用无法组成数组<br>
<strong>列表初始化可以缺省数组的维度</strong><br>
使用字符串字面值初始化字符数组时，需要保留空间给结尾的<strong>空字符‘\0’</strong><br>
数组<strong>不允许拷贝初始化和赋值</strong> 但vector可以进行拷贝<br>
数组声明阅读由内向外<br>
指向数组的指针 int (*Parray)[10] = &amp;arr;  数组的应用 int (&amp;Rarra)[10] = arr; 注意不能漏掉括号 去掉括号就成了 指针数组和非法定义<br>
int *(&amp;Rarra) [10] = arr; 一个含有10个int指针的数组的引用<br>
<strong>int *ptrs[10];//指针的数组  int (*ptrs)[10];//数组的指针</strong></p>
<p>习题3.27<br>
a c 非法 不是一个常量值啊 d 非法 还有结尾空字符放不进去<br>
习题3.28<br>
string[] 为空 外部int[]为0 内部int[]为空未定值<br>
知识点：不同作用域的定义的默认值<br>
习题3.29<br>
缺点：固定大小，初始化的方式不同</p>
<p>3.5.2<br>
数组下标类型为 size_t<br>
数组元素可以通过范围for语句以及下标运算符访问<br>
注意数组可以使用范围for语句，但是！调用的形式是：<br>
int a[10]; for(auto i : <strong>a</strong> ) i++;</p>
<p>习题3.30<br>
ix最后会等于size，ia[10]是不存在的，强行调用会导致内存出错<br>
习题3.31</p>
<pre><code>int main() {
	int a[10];
	for (int i = 0; i &lt; 10; ++i) {
		a[i] = i;
		cout &lt;&lt; a[i] &lt;&lt; ' ';
	}
};
</code></pre>
<p>知识点：数组的初始化<br>
习题3.31</p>
<pre><code>int main() {
	int a[10];
	for (int i = 0; i &lt; 10; ++i) {
		a[i] = i;
		cout &lt;&lt; a[i] &lt;&lt; ' ';
	}
	int b[10] ;
	for (int i = 0; i &lt; 10; ++i) 
		b[i] = a[i];	
	vector&lt;int&gt; v1(10, 10);
	vector&lt;int&gt; v2 = v1;
	for (auto i : v2)
		cout &lt;&lt; i &lt;&lt; ' ';
}
</code></pre>
<p>知识点：数组和vector的差异，初始化、拷贝等<br>
习题3.33<br>
将会强行调用未定义的值，出现难以预料的结果。<br>
知识点：数组默认初始化</p>
<p>3.5.3<br>
数组的每个元素都有地址，可以对特定元素使用取地址符<br>
<strong>数组名字本身就是一个指向数组首元素的指针</strong> int *b = arr;<br>
使用数组的时候实质上真正使用的是指向数组某元素的指针<br>
所以涉及数组<strong>的auto会定义为指针 而非数组  但decltype 返回的类型是同等维度的数组</strong><br>
<strong>指向数组的指针就等于一个迭代器</strong> 支持++等运算符<br>
标准库函数begin和end 将数组作为参数 int *beg = begin(ia); int *last = end(ia); 定义在iterator头文件内<br>
<strong>指针支持所有迭代器运算</strong><br>
两个指针相减得到的值类型为ptrdiff_t 带符号类型 定义在cstddef头文件中<br>
如果含有点运算符和解引用符 最好在必要的地方加上括号<br>
<strong>指针也可以进行下标运算</strong><br>
对数组执行下标运算其实就是对指向数组元素的指针执行下标运算<br>
int *p = &amp;ia[2]; int j =p[1]; //等价于*p(1)<br>
标准库类型的下标必须是无符号类型 例如string和vector  内置的下标无此要求 比如指针和数组<br>
<strong>下标[-1]就是指最后一个值</strong></p>
<p>习题3.34<br>
将p1指针移动到p2<br>
习题3.35</p>
<pre><code>int main() {
	int a[10];
	for (int i = 0; i &lt; 10; ++i) {
		a[i] = i;
		cout &lt;&lt; a[i] &lt;&lt; ' ';
	}
	for (int *i = begin(a); i != end(a); ++i) {
		*i = 0;
		cout &lt;&lt; *i &lt;&lt; ' ';
	}
};
</code></pre>
<p>知识点：数组指针的定义与调用<br>
习题3.36</p>
<pre><code>int main() {
	int a[3] = {1,2,3};
	int b[3] = {1,2,3};
	if (sizeof(a) == sizeof(b)) {
		int i = 0;
		int length = sizeof(a) / sizeof(a[0]);
		while (i&lt;length&amp;&amp;a[i] == b[i])
			++i;
		if (i == length)
			cout &lt;&lt; &quot;they are equal!&quot; &lt;&lt; endl;
		else 
			cout &lt;&lt; &quot;they are difference!&quot; &lt;&lt; endl;
	}
	else
		cout &lt;&lt; &quot;they are difference!&quot; &lt;&lt; endl;
	vector&lt;int&gt; i = { 1,2,3 };
	vector&lt;int&gt; j = { 1,2,3 };
	if (i == j)
		cout &lt;&lt; &quot;they are equal!&quot; &lt;&lt; endl;
	else
		cout &lt;&lt; &quot;they are difference!&quot; &lt;&lt; endl;
};
</code></pre>
<p>知识点：数组的比较、<strong>数组的长度</strong>，vector的比较</p>
<p>3.5.4<br>
c风格字符串必须以空字符结束 char ca[ ]<br>
上述函数皆以空字符为监测点<br>
c风格字符串实际上是一个数组直接 使用时等于使用指针<br>
c风格字符串函数使用时需要不断判断空间问题，所以string比其安全高效<br>
strcmp（参数1，参数2）比较参数1和参数（1、若参数1&gt;参数2，返回正数；2、若参数1&lt;参数2，返回负数；3、若参数1=参数2，返回0；）</p>
<p>习题3.37<br>
输出hello'\0'注意空字符<br>
习题3.38<br>
两个指针相加的值最后是未知的，使用一个未知地址值的指针是非常危险的事。<br>
习题3.39</p>
<pre><code>int main() {
	char a[6] = &quot;hallo&quot;;
	char b[6] = &quot;abcde&quot;;
	if (!strcmp(a,b))
		cout &lt;&lt; &quot;they are equal!&quot; &lt;&lt; endl;
	else
		cout &lt;&lt; &quot;they are difference!&quot; &lt;&lt; endl;

	string i = { &quot;hello&quot; };
	string j = { &quot;hallo&quot; };
	if (i == j)
		cout &lt;&lt; &quot;they are equal!&quot; &lt;&lt; endl;
	else
		cout &lt;&lt; &quot;they are difference!&quot; &lt;&lt; endl;
};
</code></pre>
<p>知识点：string比较、C风格字符串比较<br>
习题3.40</p>
<pre><code>int main() {
	char a[6] = &quot;hallo&quot;;
	char b[6] = &quot;abcde&quot;;
	char c[12];
	strcat(a, b);
	strcpy(c, a);
};
</code></pre>
<p>知识点：C风格字符串函数的运用</p>
<p>3.5.5<br>
为了兼容旧代码</p>
<ol>
<li>任何出现字符串字面值都可以用以空字符结束的字符数组来代替 比如用来初始化string对象</li>
<li>string中有c_str成员函数用于处理c风格字符串</li>
<li>可以用数组初始化vector对象<br>
习题3.41</li>
</ol>
<pre><code>int main() {
	int a[10] = { 1,2,3,4,5,6,7,8,9,10 };
	vector&lt;int&gt; i (begin(a),end(a));
	for (auto x : i)
		cout &lt;&lt; x &lt;&lt; ' ';
};
</code></pre>
<p>知识点：用整形数组初始化vector<br>
习题3.42</p>
<pre><code>int main() {
	int a[10] ;
	vector&lt;int&gt; i = { 1,2,3,4,5,6,7,8,9,10 };
	int e = 0;
	for (auto x : i)
		a[e++] = x;
	for (auto x : a)
		cout &lt;&lt; x &lt;&lt; ' ';
};
</code></pre>
<p>知识点：整型数组的循环与初始化</p>
<p>3.6<br>
严格来说c++并没有多维数组 而是<strong>数组的数组</strong> 所以<strong>对数组名是指针的指针</strong>，对数组名ia的<strong>第一次解引用*ia得到还是指针</strong>，第二次解引用**ia才获得数组第一个元素<br>
当表达式提供的下标运算符数量和数组维度相同时 访问的是特定元素。如果下标运算符数量比数组维度小，则结是给定索引处的一个内层数组<br>
用范围for语句处理多维数组，除了<strong>最内层的循环外，其他所有循环的控制变量都应该是引用类型</strong><br>
在声明指向数组的指针时必须要注意括号，建议使用auto 或者类型别名（using、typedef）<br>
（题目3.43）</p>
<p>习题3.43</p>
<pre><code>int main() {
	int ia[3][3] = { {1,2,3},{ 4,5,6 } ,{ 7,8,9 } };
	for (int (&amp;x)[3] : ia)
		for (int y : x)
			cout &lt;&lt; y &lt;&lt; ' ';
	for (int x = 0; x &lt; 3; ++x)
		for (int y = 0; y &lt; 3; ++y)
			cout &lt;&lt; ia[x][y] &lt;&lt; ' ';
	for (int (*x)[3] = begin(ia); x != end(ia); ++x)
		for (int * y = *x;y != *x+3; ++y)
			cout &lt;&lt; *y &lt;&lt; ' ';	
};
</code></pre>
<p>知识点：多维数组中范围for语句、指针和下标的运用<br>
习题3.44</p>
<pre><code>//typedef int a[3];
using a = int[3];
int main() {
	
	int ia[3][3] = { {1,2,3},{ 4,5,6 } ,{ 7,8,9 } };
	for (auto &amp;x : ia)
		for (auto y : x)
			cout &lt;&lt; y &lt;&lt; ' ';
	for (int x = 0; x &lt; 3; ++x)
		for (int y = 0; y &lt; 3; ++y)
			cout &lt;&lt; ia[x][y] &lt;&lt; ' ';
	for (a *x = begin(ia); x != end(ia); ++x)
		for (int*  y = *x;y != *x+3; ++y)
			cout &lt;&lt; *y &lt;&lt; ' ';	
};
</code></pre>
<p>知识点：typedef的运用<br>
习题3.55</p>
<pre><code>int main() {
	int ia[3][3] = { {1,2,3},{ 4,5,6 } ,{ 7,8,9 } };
	for (auto &amp;x : ia)
		for (auto y : x)
			cout &lt;&lt; y &lt;&lt; ' ';
	for (int x = 0; x &lt; 3; ++x)
		for (int y = 0; y &lt; 3; ++y)
			cout &lt;&lt; ia[x][y] &lt;&lt; ' ';
	for (auto x = begin(ia); x != end(ia); ++x)
		for (auto  y = *x;y != *x+3; ++y)
			cout &lt;&lt; *y &lt;&lt; ' ';	
};
</code></pre>
<p>知识点：auto的应用</p>
<p>习题感悟、<br>
数组在不同作用域的定义的默认值受类型影响<br>
数组指针可以使用begin（ia）和end（ia）<br>
数组的长度计算得用	int length = sizeof(a) / sizeof(a[0]);<br>
c风格字符数组有很多自定义函数<br>
可以用整形数组初始化vector<br>
注意！！！！！！<br>
typedef 定义数组是这样子的 typedef int a[4] 把a定义为int[4]的类型别名！</p>
]]></content>
    </entry>
</feed>