<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-12-26T03:26:27.907Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[哈希表/位运算 136. 只出现一次的数字 ]]></title>
        <id>https://lixin-ee.github.io//post/ha-xi-biao-wei-yun-suan-136-zhi-chu-xian-yi-ci-de-shu-zi</id>
        <link href="https://lixin-ee.github.io//post/ha-xi-biao-wei-yun-suan-136-zhi-chu-xian-yi-ci-de-shu-zi">
        </link>
        <updated>2019-12-26T03:05:05.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。<br>
说明：<br>
你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？<br>
示例 1:<br>
输入: [2,2,1]<br>
输出: 1<br>
示例 2:<br>
输入: [4,1,2,1,2]<br>
输出: 4<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/single-number<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>最简单的肯定就是无序哈希表的增删了 注意无序是unordered而不是unorder<br>
然后就是思考如何不使用额外的空间<br>
想过双指针的解答，但是似乎不是很行<br>
艹，题解就是数学法</p>
<pre><code>class Solution {
public:
    int singleNumber(vector&lt;int&gt;&amp; nums) {
        unordered_set&lt;int&gt; res;
        for(auto i:nums){
            if(res.count(i))
                res.erase(i);
            else
                res.insert(i);
        }
        return *res.begin();
    }
};
</code></pre>
<p>然后来看看官方题解</p>
<blockquote>
<p>方法 1：列表操作<br>
算法<br>
遍历 nums 中的每一个元素<br>
如果某个nums 中的数字是新出现的，则将它添加到列表中<br>
如果某个数字已经在列表中，删除它</p>
</blockquote>
<pre><code>Python
class Solution(object):
    def singleNumber(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        no_duplicate_list = []
        for i in nums:
            if i not in no_duplicate_list:
                no_duplicate_list.append(i)
            else:
                no_duplicate_list.remove(i)
        return no_duplicate_list.pop()
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n^2) 。我们遍历nums 花费 O(n) 的时间。我们还要在列表中遍历判断是否存在这个数字，花费 O(n) 的时间，所以总循环时间为 O(n^2) 。<br>
空间复杂度：O(n) 。我们需要一个大小为 n 的列表保存所有的 nums 中元素。</p>
</blockquote>
<blockquote>
<p>方法 2：哈希表<br>
算法<br>
我们用哈希表避免每次查找元素是否存在需要的 O(n) 时间。<br>
遍历 nums 中的每一个元素<br>
查找 hash_table 中是否有当前元素的键<br>
如果没有，将当前元素作为键插入 hash_table<br>
最后， hash_table 中仅有一个元素，用 popitem 获得它</p>
</blockquote>
<pre><code>Python
class Solution(object):
    def singleNumber(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        hash_table = {}
        for i in nums:
            try:
                hash_table.pop(i)
            except:
                hash_table[i] = 1
        return hash_table.popitem()[0]
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度： =O(n) 。for 循环的时间复杂度是 O(n) 的。Python 中哈希表的 pop 操作时间复杂度为O(1) 。<br>
空间复杂度： O(n) 。hash_table 需要的空间与nums 中元素个数相等。</p>
</blockquote>
<p>方法 3：数学<br>
概念<br>
2 * (a + b + c) - (a + a + b + b + c) = c2∗(a+b+c)−(a+a+b+b+c)=c</p>
<pre><code>Python
class Solution(object):
    def singleNumber(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        return 2 * sum(set(nums)) - sum(nums)
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n+n)=O(n) 。sum 会调用 next 将nums 中的元素遍历一遍。我们可以把上述代码看成 sum(list(i, for i in nums)) ，这意味着时间复杂度为 O(n) ，因为nums 中的元素个数是 nn 个。<br>
空间复杂度：O(n+n)=O(n) 。 set 需要的空间跟 nums 中元素个数相等。</p>
</blockquote>
<blockquote>
<p>方法 4：位操作<br>
概念<br>
如果我们对 0 和二进制位做 XOR 运算，得到的仍然是这个二进制位<br>
a⊕0=a<br>
如果我们对相同的二进制位做 XOR 运算，返回的结果是 0<br>
a⊕a=0<br>
XOR 满足交换律和结合律<br>
a⊕b⊕a=(a⊕a)⊕b=0⊕b=b<br>
所以我们只需要将所有的数进行 XOR 操作，得到那个唯一的数字。</p>
</blockquote>
<pre><code>Python
class Solution(object):
    def singleNumber(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        a = 0
        for i in nums:
            a ^= i
        return a
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度： O(n) 。我们只需要将nums 中的元素遍历一遍，所以时间复杂度就是nums 中的元素个数。<br>
空间复杂度：O(1) 。</p>
</blockquote>
<p>我对异或的复现</p>
<pre><code>    int singleNumber(vector&lt;int&gt;&amp; nums){
        int res=0;
        for(auto i:nums)
            res^=i;
        return res;
    }      
</code></pre>
<p>对比方法三，异或还是很6的，都不需要考虑溢出的问题</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于非阻塞IO、Reactor和one thread one loop]]></title>
        <id>https://lixin-ee.github.io//post/guan-yu-fei-zu-sai-ioreactor-he-one-thread-one-loop</id>
        <link href="https://lixin-ee.github.io//post/guan-yu-fei-zu-sai-ioreactor-he-one-thread-one-loop">
        </link>
        <updated>2019-12-26T02:11:42.000Z</updated>
        <content type="html"><![CDATA[<p>今天早上在阅读陈硕的高性能多线程服务器第三章时产生了很大的疑惑<br>
那就是Reactor和one thread one loop之间的区别<br>
书中说后者其实就是把前者复制实现了，也就是把reactor在每个线程中复现了并且加上了线程池以处理那些纯计算不IO的工作</p>
<p>然后我就疑惑在于reactor本身或者说非阻塞IO本身不是多线程或者多进程的吗</p>
<p>答案还真不是<br>
先放一篇比较好的博客<br>
<a href="http://gao-xiao-long.github.io/2017/04/20/network-io/">Linux下多线程服务器Reactor模式总结</a><br>
然后结合UNP<br>
我才发现原来非阻塞IO并非是select/poll响应之后不断地fork或者thread的<br>
而是在【单线程里面不断执行】</p>
<p>那为何不会阻塞在执行函数里面呢？比如read和write？<br>
这就是UNP 16章一开始介绍缓冲区的原因<br>
非阻塞IO中必须用缓冲区缓存IO内容，也就是说我管你发不发得出去（阻塞IO一般也是阻塞在不够长度发送或者接收的问题上），发不出去就存起来下次再发，赶紧给我返回到select（接收同理），只能阻塞在select上</p>
<p>这也就是reactor的event loop和select/poll分离、以及其缺点的由来</p>
<p>缺点就是非抢占：由于只有一个线程，因此事件是顺序处理的，一个线程同时只能做一件事情，事件的优先级得不到保证。因为”从select/poll返回后” 到”下一次调用select/poll进入等待之前”这段时间内，线程不会被其他连接上的数据或者事件抢占。所以在使用这种模式时，需要避免业务逻辑阻塞当前IO线程。比如事件a的优先级高于事件b，但是只要事件b早到那么一点，后到的事件a只能等待事件b完成返回到select/poll（注意不是阻塞）</p>
<p>当然Reactor其实有很多版本的，并非必须是单线程的，只是陈硕作者在第三章中引出来所需，Reactor可以有单进程多线程的版本</p>
<p>最后Reactor和基于它的lighttpd、Niginx都是值得阅读的源码</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于读书笔记]]></title>
        <id>https://lixin-ee.github.io//post/guan-yu-du-shu-bi-ji</id>
        <link href="https://lixin-ee.github.io//post/guan-yu-du-shu-bi-ji">
        </link>
        <updated>2019-12-25T12:40:41.000Z</updated>
        <content type="html"><![CDATA[<p>谁能想到这是我为数不多的随心感想之一<br>
起源是某天打开自己的博客和github，发现空空如也<br>
hhh也没有啦 但十一月底之前的博文里除了leetcode和C++ primer之外好像就没有其他的了，看起来我好像什么都没做一样<br>
但是真相是什么呢，其实一直在看书<br>
除去C++ primer，我整理了一下如下<br>
C++：《STL源码剖析》《深度探索C++对象模型》<br>
算法：《大话数据结构》<br>
计算机网络：《计算机网络：自顶向下方法》《TCP/IP详解 卷1》<br>
操作系统：《深入理解计算机系统》<br>
Linux：《鸟哥的 Linux 私房菜 基础篇》《APUE-UNIX 环境高级编程》《UNP-UNIX网络编程》<br>
还算不少吧hhh<br>
然而虽然开了博客，但是自己多多少少还是不太习惯用吧，笔记基本都在iPad里面，然后自己习惯转化成成word笔记方便查阅。<br>
但是一周前看了一位中大师兄的博客，看到他一路以来做的笔记，才发现自己还是不够啊<br>
然后又开始陷入无限懊悔。。。<br>
但是看了一下同时期师兄的博客，其实也是差不多的起点吧<br>
所以种一棵树最好的时机，一个是三年前，一个是今天<br>
毕竟我也用了太多时间来后悔了</p>
<p>所以从今天起尽量写一下读书笔记<br>
对于已经读过的书，除了转化为word，更添加和面试题相关的解答和思考<br>
对于正在读的树，肯定有读不懂的地方，那就把笔记和感想结合起来，感想为主吧。</p>
<p>然后发现一个小技巧，博客上有很多人会手工搬运书中的内容，这样我说不定可以省下很多工作呢hhh</p>
<p>一眨眼已经19.12.25了，学期初完成的计划显然是太难达成了（一个月两本书），未来的路也还很远，刚刚拿到地图（面经），做好了晚点回家的准备，但今天有点懈怠了，还是得继续努力啊！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树的前中后序遍历+层次遍历 [迭代版]]]></title>
        <id>https://lixin-ee.github.io//post/er-cha-shu-de-qian-zhong-hou-xu-bian-li-ceng-ci-bian-li-die-dai-ban</id>
        <link href="https://lixin-ee.github.io//post/er-cha-shu-de-qian-zhong-hou-xu-bian-li-ceng-ci-bian-li-die-dai-ban">
        </link>
        <updated>2019-12-25T08:00:54.000Z</updated>
        <content type="html"><![CDATA[<p>前序</p>
<pre><code>class Solution {
public:
    //迭代版
    vector&lt;int&gt; preorderTraversal(TreeNode* root) {
        stack&lt;TreeNode*&gt; rNode;
        vector&lt;int&gt; res;
        TreeNode* cur;
        rNode.push(root);
        while(rNode.size()){
            cur=rNode.top();
            rNode.pop();
            if(cur==NULL)
                continue;
            res.push_back(cur-&gt;val);
            rNode.push(cur-&gt;right);
            rNode.push(cur-&gt;left);
        }
        return res;
    }
｝
</code></pre>
<p>需要注意的点<br>
1.先压入root结点<br>
2.对cur进行NULL判断<br>
3.因为栈是先进后出，所以一定要先压入右子树再压入左子树</p>
<p>中序</p>
<pre><code>class Solution {
public:   
    vector&lt;int&gt; inorderTraversal(TreeNode* root){
        stack&lt;TreeNode*&gt; NodeStack;
        TreeNode *cur=root;
        vector&lt;int&gt; res;
        while(cur||NodeStack.size()){
            while(cur){
                NodeStack.push(cur);
                cur=cur-&gt;left;
            }
            cur=NodeStack.top();
            NodeStack.pop();
            res.push_back(cur-&gt;val);
            cur=cur-&gt;right;
            
        }
        return res;
    }
   ｝;
</code></pre>
<pre><code>注意点
1.判断条件和处理和前序遍历不同，先压入所有左子树再返回再压入右子树
</code></pre>
<p>二叉树的后序遍历</p>
<pre><code>class Solution {   
public:
    vector&lt;int&gt; postorderTraversal(TreeNode* root) {
        deque&lt;int&gt; res;
        stack&lt;TreeNode*&gt; nodestack;
        TreeNode *cur;
        nodestack.push(root);
        while(nodestack.size()){
            cur=nodestack.top();
            nodestack.pop();
            if(!cur)
                continue;
            res.push_front(cur-&gt;val);
            nodestack.push(cur-&gt;left);
            nodestack.push(cur-&gt;right);
        }
        return vector&lt;int&gt;(res.begin(),res.end());
    }
	};
</code></pre>
<p>注意点：<br>
1.这个题解时逆序输出，先输出靠后的元素，比如12345的输出顺序是5-45-345-2345-12345，因此我使用了deque，因为需要push_front，用vector的话很费时（当然用deque的话很费空间）<br>
2.注意必须先压入left再压入righjt，原因是因为逆序输出，所以配合stack先进后出的话需要右子树后入栈</p>
<p>层次遍历</p>
<pre><code>class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {
        vector&lt;vector&lt;int&gt;&gt; res;
        vector&lt;TreeNode*&gt; cur,next;
        if(!root) return res;
        cur.push_back(root);
        while(cur.size()||next.size()){
            res.push_back(vector&lt;int&gt;({}));
            for(auto i:cur){
                res.back().push_back(i-&gt;val);
                if(i-&gt;left)
                    next.push_back(i-&gt;left);
                if(i-&gt;right)
                    next.push_back(i-&gt;right);               
            }
            cur=next;
            next.clear();
        }
        return res;
    }
		};
</code></pre>
<p>需要注意的点：<br>
1.其实可以在空间和记录层次之间选择，我选择了前者，因为比较省工<br>
2.res需要先push_back一个空数组<br>
3.注意back()返回的是引用，这也解释了为啥很多函数习惯返回引用，否则的话连续调用就全部木大了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树的前中后序遍历 [迭代版]]]></title>
        <id>https://lixin-ee.github.io//post/er-cha-shu-de-qian-zhong-hou-xu-bian-li-die-dai-ban</id>
        <link href="https://lixin-ee.github.io//post/er-cha-shu-de-qian-zhong-hou-xu-bian-li-die-dai-ban">
        </link>
        <updated>2019-12-25T08:00:54.000Z</updated>
        <content type="html"><![CDATA[<p>前序</p>
<pre><code>class Solution {
public:
    //迭代版
    vector&lt;int&gt; preorderTraversal(TreeNode* root) {
        stack&lt;TreeNode*&gt; rNode;
        vector&lt;int&gt; res;
        TreeNode* cur;
        rNode.push(root);
        while(rNode.size()){
            cur=rNode.top();
            rNode.pop();
            if(cur==NULL)
                continue;
            res.push_back(cur-&gt;val);
            rNode.push(cur-&gt;right);
            rNode.push(cur-&gt;left);
        }
        return res;
    }
｝
</code></pre>
<p>需要注意的点<br>
1.先压入root结点<br>
2.对cur进行NULL判断<br>
3.因为栈是先进后出，所以一定要先压入右子树再压入左子树</p>
<p>中序</p>
<pre><code>class Solution {
public:   
    vector&lt;int&gt; inorderTraversal(TreeNode* root){
        stack&lt;TreeNode*&gt; NodeStack;
        TreeNode *cur=root;
        vector&lt;int&gt; res;
        while(cur||NodeStack.size()){
            while(cur){
                NodeStack.push(cur);
                cur=cur-&gt;left;
            }
            cur=NodeStack.top();
            NodeStack.pop();
            res.push_back(cur-&gt;val);
            cur=cur-&gt;right;
            
        }
        return res;
    }
   ｝;
</code></pre>
<pre><code>注意点
1.判断条件和处理和前序遍历不同，先压入所有左子树再返回再压入右子树
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 557. 反转字符串中的单词 III[简单]]]></title>
        <id>https://lixin-ee.github.io//post/zi-fu-chuan-557-fan-zhuan-zi-fu-chuan-zhong-de-dan-ci-iiijian-dan</id>
        <link href="https://lixin-ee.github.io//post/zi-fu-chuan-557-fan-zhuan-zi-fu-chuan-zhong-de-dan-ci-iiijian-dan">
        </link>
        <updated>2019-12-25T01:41:14.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。<br>
示例 1:<br>
输入: &quot;Let's take LeetCode contest&quot;<br>
输出: &quot;s'teL ekat edoCteeL tsetnoc&quot; <br>
注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/reverse-words-in-a-string-iii<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>一开始傻逼了看错题目了以为是翻转整个字符串，原来是翻转单个单词<br>
考虑利用stringstream来试试<br>
注意ostringstream不能直接输出给string的 只能用os.str()返回ostringstream所保存的string的拷贝<br>
然后我为了解决最后一个空格的问题用了eof()这个判断函数<br>
然后实现了自己的reverse，然后看一下stl的reverse，比较有趣，主要是++和--的时机和判断<br>
stl会在一个无限循环中先判断if(first<mark>last||first</mark> --last) return; else iter_swap(first++,last);</p>
<pre><code>class Solution {
public:
    string reverseWords(string s) {
        //string res;
        istringstream is(s);
        ostringstream os;
        if(!s.empty()){
            string temp;
            while(is&gt;&gt;temp){
                swapstring(temp);
                os&lt;&lt;temp;
                if(!is.eof())
                    os&lt;&lt;&quot; &quot;;
            }
        }
        return os.str();
    }
    
    void swapstring(string &amp;s){
        int left=0,right=s.size()-1;
        while(left&lt;right)
            swap(s[left++],s[right--]);
    }
};
</code></pre>
<p>热门题解居然没有用stringstream，就跟别说eof了，而且题解大多数都是java和python的split，意义不大呀<br>
看看官方题解造轮子吧</p>
<blockquote>
<p>方法 1：简单的解法 [Accepted]<br>
第一种方法非常简单，我们将输入字符串中按照空白字符串分开，然后把所有单词放到一个字符串列表中，然后我们逐一遍历每一个字符串并把反转结果连接起来。最后，我们将删除了额外空白字符的字符串返回。</p>
</blockquote>
<pre><code>Java
public class Solution {
    public String reverseWords(String s) {
        String words[] = s.split(&quot; &quot;);
        StringBuilder res=new StringBuilder();
        for (String word: words)
            res.append(new StringBuffer(word).reverse().toString() + &quot; &quot;);
        return res.toString().trim();
    }
}
</code></pre>
<blockquote>
<p>时间复杂度<br>
时间复杂度： O(n) 。其中n 是字符串的长度。<br>
空间复杂度： O(n) 。使用了大小为 n 的 res 。</p>
</blockquote>
<blockquote>
<p>方法 2：不使用自带的 split 和 reverse 函数 [Accepted]<br>
算法<br>
我们可以自己写一个 split 和 reverse 函数。 split 函数将字符串按照 &quot; &quot; （空格）为分隔符将字符串分开并返回单词列表。 reverse 函数返回每个字符串反转后的字符串。</p>
</blockquote>
<pre><code>Java
public class Solution {
    public String reverseWords(String s) {
        String words[] = split(s);
        StringBuilder res=new StringBuilder();
        for (String word: words)
            res.append(reverse(word) + &quot; &quot;);
        return res.toString().trim();
    }
    public String[] split(String s) {
        ArrayList &lt; String &gt; words = new ArrayList &lt; &gt; ();
        StringBuilder word = new StringBuilder();
        for (int i = 0; i &lt; s.length(); i++) {
            if (s.charAt(i) == ' ') {
                words.add(word.toString());
                word = new StringBuilder();
            } else
                word.append( s.charAt(i));
        }
        words.add(word.toString());
        return words.toArray(new String[words.size()]);
    }
    public String reverse(String s) {
      StringBuilder res=new StringBuilder();
        for (int i = 0; i &lt; s.length(); i++)
            res.insert(0,s.charAt(i));
        return res.toString();
    }
}
</code></pre>
<blockquote>
<p>时间复杂度<br>
时间复杂度： O(n) 。其中 nn 是字符串的长度。<br>
空间复杂度： O(n) 。使用了大小为 n 的 res 。</p>
</blockquote>
<blockquote>
<p>方法 3：使用 StringBuilder 和 reverse 方法 [Accepted]<br>
算法<br>
这一方法中，我们不使用 split 方法，我们创建临时字符串 wordword 保存单词，我们在遍历过程中将字符逐一连接在 wordword 后面，直到我们遇到 ' '（空格） 字符。当我们遇到 ' ' 字符时，我们将 wordword 反转后连接在结果字符串 resultresult 后面。在遍历完成以后，我们返回结果字符串 resultresult 。</p>
</blockquote>
<pre><code>Java
public class Solution {
    public String reverseWords(String input) {
        final StringBuilder result = new StringBuilder();
        final StringBuilder word = new StringBuilder();
        for (int i = 0; i &lt; input.length(); i++) {
            if (input.charAt(i) != ' ') {
                word.append(input.charAt(i));
            } else {
                result.append(word.reverse());
                result.append(&quot; &quot;);
                word.setLength(0);
            }
        }
        result.append(word.reverse());
        return result.toString();
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度： O(n) 。单遍循环的上限是 n ，其中 n 是字符串的长度。<br>
空间复杂度： O(n) 。 result 和 word 最多为 n 。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[脑筋急转弯 292. Nim 游戏[简单]]]></title>
        <id>https://lixin-ee.github.io//post/nao-jin-ji-zhuan-wan-292-nim-you-xi-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/nao-jin-ji-zhuan-wan-292-nim-you-xi-jian-dan">
        </link>
        <updated>2019-12-24T02:40:22.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。<br>
你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。<br>
示例:<br>
输入: 4<br>
输出: false<br>
解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛；<br>
     因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/nim-game<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>通过一波穷举我发现问题所在就是4这个数，如果谁能使得自己拿走石头后剩下的数量为4那对方必输无疑<br>
那么剩下的问题就很简单了，如果我当前的数不为4的倍数，我就拿走1-3个，使得对方成为4的倍数，如此往复最后对方肯定要面对4的情况。<br>
所以这道题之所以简单就是因为直接看是不是4的倍数就完事了。。。</p>
<pre><code>class Solution {
public:
    bool canWinNim(int n) {
     if(n&lt;=0)
         return false;
     if(n%4==0)
         return false;
        else
            return true;
    }
};
</code></pre>
<p>然后来看看网友题解吧，这道题最重要的还是如何推导出这个规律而不是简单地得出结果</p>
<blockquote>
<p>把4看成一个整体，我们都知道4的情况下，后手拿的会赢。那么就是以下这个样子：<br>
1～3--a肯定会拿走，a赢<br>
4--无论a怎么拿，顺序都是ab，都是b赢<br>
5--看作1+[4]，那么拿的顺序就是aba，a赢<br>
6--看作2+[4]，那么拿的顺序就是aba，a赢<br>
7--看作3+[4]，那么拿的顺序就是aba，a赢<br>
8--看作[4]+[4]，无论a怎么拿顺序都是abab，b赢<br>
以此类推<br>
由此我们可以看出，当n被4整除时，后手赢（b），不被整除时，先手赢（a）</p>
</blockquote>
<blockquote>
<p>最开始从递归入手，写出下面代码</p>
</blockquote>
<pre><code>class Solution {
public:
    bool canWinNim(int n) {
        if(n &lt;= 0) {
            return false;
        }
        if(n &lt;= 3) {
            return true;
        }
        return !canWinNim(n-1) || !canWinNim(n-2) || !canWinNim(n-3);
    }
};
</code></pre>
<blockquote>
<p>遇到大n堆栈就溢出了。<br>
然后考虑dp，写出下面代码</p>
</blockquote>
<pre><code>class Solution {
public:
    bool canWinNim(int n) {
        vector&lt;bool&gt; dp(n, true);
        for(int i = 4; i &lt;= n; ++i) {
            dp[i-1] = !dp[i-2] || !dp[i-3] || !dp[i-4];
        }
        return dp[n-1];
    }
};
</code></pre>
<blockquote>
<p>遇到大n时间太长，还是过不了。<br>
观察了以下dp数组里的值的变化规律，发现只要n不是4的倍数，就是true，反之false。原来就是一行代码的事：</p>
</blockquote>
<pre><code>class Solution {
public:
    bool canWinNim(int n) {
        return n%4 != 0;
    }
};
</code></pre>
<blockquote>
<p>提交上去结果居然是速度只打败50%，内存打败30%。<br>
于是，再改进：</p>
</blockquote>
<pre><code>class Solution {
public:
    bool canWinNim(int n) {
        return n &amp; 3;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二分查找 354. 俄罗斯套娃信封问题[困难]]]></title>
        <id>https://lixin-ee.github.io//post/er-fen-cha-zhao-354-e-luo-si-tao-wa-xin-feng-wen-ti-kun-nan</id>
        <link href="https://lixin-ee.github.io//post/er-fen-cha-zhao-354-e-luo-si-tao-wa-xin-feng-wen-ti-kun-nan">
        </link>
        <updated>2019-12-23T02:18:21.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 (w, h) 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。<br>
请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。<br>
说明:<br>
不允许旋转信封。<br>
示例:<br>
输入: envelopes = [[5,4],[6,4],[6,7],[2,3]]<br>
输出: 3<br>
解释: 最多信封的个数为 3, 组合为: [2,3] =&gt; [5,4] =&gt; [6,7]。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/russian-doll-envelopes<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>感觉这道题就可以使用上一次的贪心数组+动态规划方法<br>
但是这道题不要求顺序，比如2，3不需要替换5，4而是可以放在它前面<br>
但是替换还是需要的，比如假设有6，5和6，7 那么6，5明显比6，7更合适<br>
只是这个二维判断条件比较麻烦<br>
首先二分法判断w的位置，然后再判断h是否介于两者之间？发现是不行的，因为h和w本质上没有先后之分，你也可以先比较h再比较w<br>
我也想过比较面积的方法，但是比如 2 1、3 4、4 3、4 5，这种情况怎么去判断4 3 和 3 4 呢？这种情况里面肯定是3 4好于4 3，但是稍微修改一下顺序，怎么去保证贪心算法一定用3 4去替换4 3呢<br>
所以改用动态规划法，将所有元素按面积大小排序，然后就是转化为了300题中的问题，逐个寻找比自己小的信封中可包含的最大值，只不过还需要比较长和宽。<br>
比如1 2 6 4 5 10 ，10会必须把前面的全部找一遍，直至确认6是最大的（值为3）<br>
实现快速排序法下标版发现的问题<br>
1.忘了定义pivotkey，定义后又忘了用来比较pivotkey&lt;=vi[high]<br>
2.先--high再到++low，不小心弄反了<br>
3.下标版可以直接mid-1，因为int等于-1没事，迭代器则不能指向begin之前<br>
4.记得return low;<br>
5.每个while都必须判断low&lt;high，特别是循环中的两个while<br>
最后发现可以修改快速排序法，用面积进行比较排序，而不用额外缔造一个需要映射到原数组的面积vector&lt; int&gt;，因为面积只在比较排序时有用，而在后面的查找中其实是无用的，只需要对比h和w就好<br>
执行用时 :848 ms, 在所有 cpp 提交中击败了36.91%的用户<br>
内存消耗 :15 MB, 在所有 cpp 提交中击败了5.40%的用户<br>
hhh虽然惨不忍睹，不过一次过还是很开心啊，到时候记得看题解</p>
<pre><code>class Solution {
public:
    int maxEnvelopes(vector&lt;vector&lt;int&gt;&gt;&amp; envelopes) {
        if(envelopes.empty()) return 0;
        quicksort(envelopes,0,envelopes.size()-1);
        vector&lt;int&gt; count(envelopes.size(),1);
        int res=1;
        for(int i=0;i&lt;envelopes.size();++i){
            int max_count=1;
            for(int j=0;j&lt;i;++j){
                if(envelopes[i][0]&gt;envelopes[j][0]&amp;&amp;envelopes[i][1]&gt;envelopes[j][1])
                    max_count=max(max_count,count[j]+1);
            }
            count[i]=max_count;
            res=max(res,max_count);
        }

        return res;
    }
    
    void quicksort(vector&lt;vector&lt;int&gt;&gt;&amp;vi,int beg,int end){
        if(beg&lt;end){
            int mid=partition(vi,beg,end);
            quicksort(vi,beg,mid-1);
            quicksort(vi,mid+1,end);
        }
    }
    
    int partition(vector&lt;vector&lt;int&gt;&gt;&amp;vi,int low,int high){
        int pivotkey=vi[low][0]*vi[low][1];
        while(low&lt;high){
            while(low&lt;high&amp;&amp;pivotkey&lt;=vi[high][0]*vi[high][1])
                --high;
            swap(vi[low][0],vi[high][0]);
            swap(vi[low][1],vi[high][1]);
            while(low&lt;high&amp;&amp;vi[low][0]*vi[low][1]&lt;pivotkey)
                ++low;
            swap(vi[low][0],vi[high][0]);
            swap(vi[low][1],vi[high][1]);
        }
        return low;
    }
};
</code></pre>
<p>网友题解中的贪心算法实现非常不错，解决了我当时提出的 4,3、3,4和4,5之间的问题</p>
<blockquote>
<p>先来看一下详解<br>
这道题的解法是比较巧妙的：<br>
先对宽度 w 进行升序排序，如果遇到 w 相同的情况，则按照高度 h 降序排序。之后把所有的 h 作为一个数组，在这个数组上计算 LIS 的长度就是答案。</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1577068494381.png" alt=""></p>
<blockquote>
<p>这个子序列就是最优的嵌套方案。<br>
这个解法的关键在于，对于宽度 w 相同的数对，要对其高度 h 进行降序排序。因为两个宽度相同的信封不能相互包含的，逆序排序保证在 w 相同的数对中最多只选取一个。<br>
此算法的时间复杂度为 O(NlogN)，因为排序和计算 LIS 各需要 O(NlogN) 的时间。<br>
空间复杂度为O(N)，因为计算 LIS 的函数中需要一个 top 数组。</p>
</blockquote>
<pre><code>import java.util.Arrays;
import java.util.Comparator;

public class Solution {

    public int maxEnvelopes(int[][] envelopes) {

        int len = envelopes.length;
        if (len &lt; 2) {
            return len;
        }

        Arrays.sort(envelopes, new Comparator&lt;int[]&gt;() {
            @Override
            public int compare(int[] envelope1, int[] envelope2) {
                if (envelope1[0] != envelope2[0]) {
                    return envelope1[0] - envelope2[0];
                }
                return envelope2[1] - envelope1[1];
            }
        });


        int[] tail = new int[len];
        tail[0] = envelopes[0][1];

        // end 表示有序数组 tail 的最后一个已经赋值元素的索引
        int end = 0;

        for (int i = 1; i &lt; len; i++) {
            int target = envelopes[i][1];

            if (target &gt; tail[end]) {
                end++;
                tail[end] = target;
            } else {
                int left = 0;
                int right = end;

                while (left &lt; right) {
                    int mid = (left + right) &gt;&gt;&gt; 1;
                    if (tail[mid] &lt; target) {
                        left = mid + 1;
                    } else {
                        right = mid;
                    }
                }
                tail[left] = target;
            }
        }
        return end + 1;
    }

}

</code></pre>
<p>主要核心就是在宽度相等的时候，让高度不能出现“上升的子序列”。即首先按照宽度“升序排序”，在宽度相等的时候，按照高度“降序排序”，然后最后<strong>宽度排好序</strong>了，只需要对<strong>高度</strong>进行最小递增子序列的计算</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二分查找 300.最长上升子序列「中等」「未做出」]]></title>
        <id>https://lixin-ee.github.io//post/er-fen-cha-zhao-300zui-chang-shang-sheng-zi-xu-lie-zhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/er-fen-cha-zhao-300zui-chang-shang-sheng-zi-xu-lie-zhong-deng-wei-zuo-chu">
        </link>
        <updated>2019-12-22T04:18:26.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个无序的整数数组，找到其中最长上升子序列的长度。<br>
示例:<br>
输入: [10,9,2,5,3,7,101,18]<br>
输出: 4<br>
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。<br>
说明:<br>
可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。<br>
你算法的时间复杂度应该为 O(n2) 。<br>
进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/longest-increasing-subsequence<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>我一开始的想法是从后往前，每个数向后寻找【第一个大于】自己的数，找到了就将这个数背负的长度+1，然后我发现可以单独存储一个当前最大数<br>
后来发现这个思路8太行，比如[1,10,9,2,5,3,7,101,18]，第一个1就非得遇到2才行，所以还是必须用额外的数组来存储已经计算了的数组，然后对于一个新数就利用二分法在数组中查找第一个比它大的数，在其基础上将长度+1<br>
在[1,3,6,7,9,4,10,5,6]这个用例错误了，问题出在第一个6中，第一个6的值是1，但是7是3，所以导致第二个6变成了2而不是4，考虑更新已有数字的次数而不是插入新元素，亦即temp中的数字不会重复出现<br>
本来想着是直接temp[first+1].second+1，但是需要解决如果是尾元素的问题，比如[4,5,6]插入6<br>
才发现问题不仅在于6，而是在于3啊，3应该去找6而不是去找5<br>
会不会从前往后更好？或者两个方向各一次？<br>
弃疗弃疗！，两个方向的也不行，明显是方法有问题<br>
幹，看了题解才发现是动态规划+二分查找</p>
<p>错误代码：</p>
<pre><code>class Solution {
public:
     int lengthOfLIS(vector&lt;int&gt;&amp; nums) {
        int res=0,len=nums.size();     
        vector&lt;pair&lt;int,int&gt;&gt; temp;
        for(int i=0;i&lt;len;++i){
            res=max(res,binarysearch_front(temp,nums[i]));
        }
        temp.clear();
        for(int i=len-1;i&gt;=0;--i){
            res=max(res,binarysearch_back(temp,nums[i]));
        }
        return res;
    }
    
    int binarysearch_back(vector&lt;pair&lt;int,int&gt;&gt; &amp;temp,int target){
        if(temp.empty()){
            temp.push_back(make_pair(target,1));
            return 1;
        }
        
        int first=0,last=temp.size()-1,mid;
        
        if(target&gt;temp[last].first){            
            temp.push_back(make_pair(target,1));
            return 1;}
        
        if(target==temp[last].first)
            return temp[last].second;
        
        while(first&lt;last){
            mid=first+(last-first)/2;
            if(temp[mid].first&gt;=target)
                last=mid;
            else
                first=mid+1;
        }
        if(temp[first].first==target)
            //temp.insert(temp.begin()+first,make_pair(target,temp[first].second));
            temp[first].second=temp[first+1].second+1;
        else
            temp.insert(temp.begin()+first,make_pair(target,temp[first].second+1));
        return temp[first].second;
        
    }
    
    int binarysearch_front(vector&lt;pair&lt;int,int&gt;&gt; &amp;temp,int target){
        if(temp.empty()){
            temp.push_back(make_pair(target,1));
            return 1;
        }
        
        int first=0,last=temp.size()-1,mid;
        
        if(target&lt;temp[first].first){            
            temp.insert(temp.begin(),make_pair(target,1));
            return 1;}
        
        if(target==temp[first].first)
            return temp[first].second;
        
        while(first&lt;last){
            mid=first+(last-first+1)/2;
            if(temp[mid].first&lt;target)
                first=mid;
            else
                last=mid-1;
        }
        if(temp[last].first==target)
            //temp.insert(temp.begin()+first,make_pair(target,temp[first].second));
        {temp[last].second=temp[last-1].second+1;
         return temp[last].second;
        }
        else
            temp.insert(temp.begin()+last+1,make_pair(target,temp[last].second+1));
        return temp[last+1].second;
        
    }
};
</code></pre>
<p>12.22笔记：<br>
这道题我复习的时候只想起了贪心算法+二分查找，动态规划更加方便倒是没想起来，所以还是得多看一下<br>
然后这道题的题解还是看图比较方便一点，所以直接贴题解链接了<br>
<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/">动态规划 贪心算法+二分查找</a></p>
<p>复现：<br>
动态规划</p>
<pre><code>class Solution {
public:
     int lengthOfLIS(vector&lt;int&gt;&amp; nums) {
        int len=nums.size(),res=0;
        vector&lt;int&gt; count(len,1);
         for(int i=0;i&lt;len;++i){
             for(int j=0;j&lt;i;++j)
                 if(nums[j]&lt;nums[i])
                     count[i]=count[j]+1&gt;count[i]?count[j]+1:count[i];
             res=count[i]&gt;res?count[i]:res;
         }
         return res;
    }
};
</code></pre>
<p>贪心算法+二分查找</p>
<pre><code>class Solution {
public:
     int lengthOfLIS(vector&lt;int&gt;&amp; nums) {
        int len=nums.size();
        vector&lt;int&gt; count;
        for(int i=0;i&lt;len;++i){
            if(count.empty()||nums[i]&gt;count.back())
                count.push_back(nums[i]);
            else
                binarysearch(count,nums[i]);
        }
         return count.size();
    }
    
    void binarysearch(vector&lt;int&gt; &amp;temp,int target){
        int len=temp.size(),first=0,last=len-1,mid;
        while(first&lt;last){
            mid=first+(last-first)/2;
            if(target&lt;=temp[mid])
                last=mid;
            else
                first=mid+1;
            
        }
        if(target&lt;temp[first])
            temp[first]=target;
        return;
    }
};
</code></pre>
<p>需要注意点是二分判断if(target&lt;=temp[mid])必须是&lt;=而不能是&lt;，忽略=号会出现错误，比如4，10中查找4</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二分查找 315.计算右侧小雨当前元素的个数「困难」「待阅读」]]></title>
        <id>https://lixin-ee.github.io//post/er-fen-cha-zhao-315ji-suan-you-ce-xiao-yu-dang-qian-yuan-su-de-ge-shu-kun-nan</id>
        <link href="https://lixin-ee.github.io//post/er-fen-cha-zhao-315ji-suan-you-ce-xiao-yu-dang-qian-yuan-su-de-ge-shu-kun-nan">
        </link>
        <updated>2019-12-21T14:54:44.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。<br>
示例:<br>
输入: [5,2,6,1]<br>
输出: [2,1,1,0]<br>
解释:<br>
5 的右侧有 2 个更小的元素 (2 和 1).<br>
2 的右侧仅有 1 个更小的元素 (1).<br>
6 的右侧有 1 个更小的元素 (1).<br>
1 的右侧有 0 个更小的元素.<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>对于这道题，最简单的可能就是暴力法了，直接搜索 时间复杂度就是n^2 优化就得看怎么优化了<br>
我一开始的想法是对原数组进行排序<br>
但是同时需要记录原数组的位置，比如5对应0，然后对比排序后数组的位置，比如5对应2，但是这个关系怎么对应起来呢？？？其实不太对劲，比如1排序后是0，但是它在原数组中无论何处都是0<br>
第二个想法就是排序后记录每个数组当前的最右最小元素值，但是需要更新很多位，比如遇到1需要更新1 2 5 6，遇到2需要更新2 5 6<br>
还是先实现暴力法吧，幹，暴力法超出时间限制了。。。说明肯定是用了排序法来压低到nlogn了<br>
只能实现 新增一个空间然后不断二分查找+插入了（但是插入不会超时吗。。。）<br>
结果是通过了但是时间复杂度确实很高，676ms只击败了5.59%的小伙伴，好好看看题解吧</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) {
        vector&lt;int&gt; res;
        vector&lt;int&gt; temp;
        int len=nums.size();
        for(int i=len-1;i&gt;=0;--i)
        {
            if(temp.empty()){
                temp.push_back(nums[i]);
                res.push_back(0);
                continue;
            }
            int loc=binarysearch(temp,nums[i]);
            res.insert(res.begin(),loc);
            temp.insert(temp.begin()+loc,nums[i]);            
        }
        return res;
    }
    
    int binarysearch(vector&lt;int&gt;&amp; nums,int target){
        int first=0,last=nums.size()-1,mid;
        if(target&lt;nums[0]) return 0;
        if(target&gt;nums[nums.size()-1]) return nums.size();
        while(first&lt;last){
            mid=first+(last-first)/2;
            if(nums[mid]&gt;=target)
                last=mid;
            else
                first=mid+1;
        }
        return first;
    }
};

</code></pre>
<p>我实现的方法排在暴力法之后，网友题解中的归并排序法和整理的6种方法都不错，值得阅读，今天实在是太累了，24小时内都没怎么睡好，所以先休息了</p>
]]></content>
    </entry>
</feed>