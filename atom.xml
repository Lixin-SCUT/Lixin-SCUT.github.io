<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-03-13T00:32:55.440Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>In the darkest night,rising like a spire.</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[数组 题63:股票的最大利润]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-ti-63gu-piao-de-zui-da-li-run</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-ti-63gu-piao-de-zui-da-li-run">
        </link>
        <updated>2020-03-13T00:27:57.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖交易该股票可能获得的利润是多少？例如一只股票在某些时间节点的价格为{9, 11, 8, 5,7, 12, 16, 14}。如果我们能在价格为5的时候买入并在价格为16时卖出，则能收获最大的利润11。</p>
</blockquote>
<p>解题思路：<br>
  蛮力法：找出数组中所有的数对，并逐一求出它们的差值。由于长度为n的数组中存在O(n)个数对，因此该算法的时间复杂度是O(n^2)。<br>
  换一种思路。先定义函数 diff(i)为当卖出价为数组中第i个数字 时可能获得的最大利润。显然，在卖出价固定时，买入价越低获得的利润越大。也就是说，如果在扫描到数组中的第i个数字时，只要我们能 够记住之前的i-1个数字中的最小值，就能算出在当前价位卖出时可能得到的最大利润<br>
  由于我们只需要扫描数组一次，因此该算法的时间复杂度是O(n)</p>
<pre><code>#include &lt;cstdio&gt;

int MaxDiff(const int* numbers, unsigned length)
{
    if(numbers == nullptr &amp;&amp; length &lt; 2)
        return 0;

    int min = numbers[0];
    int maxDiff = numbers[1] - min;

    for(int i = 2; i &lt; length; ++i)
    {
        if(numbers[i - 1] &lt; min)
            min = numbers[i - 1];

        int currentDiff = numbers[i] - min;
        if(currentDiff &gt; maxDiff)
            maxDiff = currentDiff;
    }

    return maxDiff;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math 题62:圆圈中最后剩下的数字]]></title>
        <id>https://lixin-scut.github.io//post/math-ti-62yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi</id>
        <link href="https://lixin-scut.github.io//post/math-ti-62yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi">
        </link>
        <updated>2020-03-12T23:56:44.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>0, 1, …, n-1这n个数字排成一个圆圈，从数字0开始每次从这个圆圈里<br>
删除第m个数字。求出这个圆圈里剩下的最后一个数字。<br>
（注意：删除后从下一个数字开始计算第m个数）</p>
</blockquote>
<p>  第一个想法就是环型链表。建立一个环形链表，然后不断地在里面循环直到只剩下一个节点的next指向自己<br>
遇到的问题：</p>
<ol>
<li>把n和m的意义搞混了</li>
<li>一开始建立树的时候想返回头节点，但是后来发现需要前一个节点，所以先返回尾节点</li>
<li>一定要理解为啥count是m-1而不是m，最好的例子就是m=1的时候，是不需要进入while(count &gt; 0)循环的，就是要删除当前节点</li>
</ol>
<p>  然后就是数学解法了<br>
其实就是变量替代法和公式带入替换，比较简单但是很考验逻辑，很值得看一下</p>
<pre><code>class Solution {
public:
    int LastRemaining_Solution(int n, int m)
    {
        if(n &lt;= 0 || m &lt;= 0)
            return -1;
        if(n == 1)
            return 0; 
        else
            return (LastRemaining_Solution(n-1,m) + m) % n;
    }
    /*
    struct TreeNode
    {
        int value;
        TreeNode *next;
    };
    
    int LastRemaining_Solution(int n, int m)
    {
        if(n &lt;= 0 || m &lt;= 0)
            return -1;
        TreeNode *preNode = buildTree(n); //别搞混n和m的意义了
        TreeNode *curNode = preNode-&gt;next;
        while(curNode-&gt;next != curNode)
        {
            int count = m - 1; //这里有点奇葩，注意理解
            while(count &gt; 0)
            {
                preNode = curNode;
                curNode = curNode-&gt;next;
                --count;
            }
            preNode-&gt;next = curNode-&gt;next;
            delete(curNode);
            curNode = preNode-&gt;next;
        }
        int value = curNode-&gt;value;
        delete(curNode);
        return value;
    }
    
    TreeNode* buildTree(int n)
    {
        int num = 0;
        TreeNode *headNode = new TreeNode;
        headNode-&gt;value = num;
        ++num;
        TreeNode *preNode = headNode;
        TreeNode *curNode;
        while(num &lt; n)
        {
            curNode = new TreeNode;
            curNode-&gt;value = num;
            preNode-&gt;next = curNode;
            preNode = curNode;
            ++num;
        }
        preNode-&gt;next = headNode;
        return preNode;
    }
    */
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>题就是有名的约瑟夫(Josephuse)环问题。我们介绍两种解题方法: 一种方法 是用环形链表模拟圆圈的经典解法;第二种方法是分析每次被删除的数字的规律并直接计算出圆圈中最后剩下的数字。</p>
</blockquote>
<blockquote>
<p>经典的解法，用环形链表模拟圆圈<br>
既然题目中有一个数字圆圈，很自然的想法就是用一个数据结构来模 拟这个圆 圈。在常用的数据结构中，我们很容易想到环形链表。我们可以创 建一个共有 n 个节点 的环形链表，然后每次在这个链表中删除第 m 个节点。<br>
可以用模板库中的std::list 来模拟一个环形链表。由于std::list本身并不是一个环形结构，因此每当迭代器 (Iterator)扫描到链表末尾的时候，我们要记得把迭代器移到链表的头部，这样就相当于按照顺序在一个圆圈里遍历了。</p>
</blockquote>
<pre><code>int LastRemaining_Solution1(unsigned int n, unsigned int m)

{
    if(n &lt; 1 || m &lt; 1)
        return -1;

    unsigned int i = 0;

    list&lt;int&gt; numbers;
    for(i = 0; i &lt; n; ++ i)
        numbers.push_back(i);

    list&lt;int&gt;::iterator current = numbers.begin();
    while(numbers.size() &gt; 1)
    {
        for(int i = 1; i &lt; m; ++ i)
        {
            current ++;
            if(current == numbers.end())
                current = numbers.begin();
        }

        list&lt;int&gt;::iterator next = ++ current;
        if(next == numbers.end())
            next = numbers.begin();

        -- current;
        numbers.erase(current);
        current = next;
    }

    return *(current);
}
</code></pre>
<blockquote>
<p>实际上需要在环形链表里重复遍历很多遍。重复的遍历当然对时间效率有负面的影响。这种方法每删除一个数字需要也步运算，共有n个数字，因此总的时间复杂度是O(n)。 同时这种思路还需要一个辅助链表来模拟圆圈，其空间复杂度是O(n)。</p>
</blockquote>
<p><img src="https://lixin-scut.github.io//post-images/1584058194761.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1584058211696.png" alt=""></p>
<pre><code>// ====================方法2====================
int LastRemaining_Solution2(unsigned int n, unsigned int m)
{
    if(n &lt; 1 || m &lt; 1)
        return -1;

    int last = 0;
    for (int i = 2; i &lt;= n; i ++) 
        last = (last + m) % i;

    return last;
}
</code></pre>
<blockquote>
<p>这种算法的时间复杂度是O(n)， 空间复杂度是O(1),因此，无论是在时间效率还是在空间效率上都优于第一种方法。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math 题61:扑克牌的顺子]]></title>
        <id>https://lixin-scut.github.io//post/math-ti-61bu-ke-pai-de-shun-zi</id>
        <link href="https://lixin-scut.github.io//post/math-ti-61bu-ke-pai-de-shun-zi">
        </link>
        <updated>2020-03-12T23:50:27.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。<br>
2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王可以看成任意数字。</p>
</blockquote>
<p>  第一个想法是利用大顶堆或者小顶堆，按顺序输出，最后看看间隔数和0的数目之差，时间复杂度 O(nlogn) 空间复杂度O(n)<br>
  第二个想法是利用排序法，思想一样，时间复杂度 O(nlogn)<br>
  书中的题解就是第二个想法，进一步改进时间复杂度的话，因为牌的种类是有限的，并且同样的牌不分顺序，就可以用size固定为14的容器来存储。</p>
<pre><code>class Solution {
public:
    bool IsContinuous( vector&lt;int&gt; numbers )
    {
        if(numbers.size() != 5)
            return false;
        vector&lt;int&gt; numCount(14,0);
        for(auto num : numbers)
        {
            ++numCount[num];
        }
        int numZero;
        int needZero;
        int numPre;
        numZero = numCount[0];
        needZero = 0;
        numPre = 0;
        for(int i=1;i &lt; 14;++i)
        {
            if(numCount[i] &gt; 1)
                return false;
            else if(numCount[i] == 1)
            {
                if(numPre == 0)
                    numPre = i;
                else
                {
                    needZero += (i - numPre - 1);
                    numPre = i;
                }
            }
        }
        return numZero &gt;= needZero;
    }
    /*
    //排序法
    bool IsContinuous( vector&lt;int&gt; numbers ) {
        if(numbers.size() != 5)
            return false;
        QuickSort(numbers,0,numbers.size()-1);
        int numZero;
        int preNum;
        int needZero;
        numZero = 0;
        preNum = 0;
        needZero = 0;
        for(auto num : numbers)
        {
            if(num == 0)
                ++numZero;
            else if(num == preNum)
                return false;
            else if(preNum != 0) //必须加上这个判断条件
            {
                needZero += (num - preNum - 1);
                preNum = num;
            }
            else    //也不能漏掉设置第一个preNum
                preNum = num;
        }
        return numZero &gt;= needZero;
    }
    
    void QuickSort(vector&lt;int&gt; &amp;numbers,int beg,int end)
    {
        if(beg &lt; end) //这里不小心写成了while ，debug 才发现
        {
            int mid; 
            mid = SortMid(numbers,beg,end);
            QuickSort(numbers,beg,mid-1);
            QuickSort(numbers,mid+1,end);
        }
    }
    
    int SortMid(vector&lt;int&gt; &amp;numbers,int beg,int end)
    {
        int pivotkey = numbers[beg];
        while(beg &lt; end)
        {
            while(beg &lt; end &amp;&amp; numbers[end] &gt;= pivotkey)
                --end;
            numbers[beg] = numbers[end];
            while(beg &lt; end &amp;&amp; numbers[beg] &lt;= pivotkey)
                ++beg;
            numbers[end] = numbers[beg];
        }
        numbers[beg] = pivotkey;
        return beg;
    }
    */
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>最直观的方法是把数组排序。值得注意的是，由于0可以当成任意数字，我们可以用0去补满数组中的空缺。如果排序之后的数组不是连续的，即相邻的两个数字相 隔若干个数字，那么只要我们有足够的0可以补满这两个数字的空缺，这个数组实际上还是连续的。<br>
首先把数组排序;其次统计数组中0的个数;最 后统计排序之后的数组中相邻数字之间的空缺总数。如果空缺的总数小于或者等于0的个数，那么这个数组就是连续的;反之则不连续。<br>
注意一点:如果数组中的非 0 数字重复出现，则该数组不是连续的。<br>
由于扑克牌的值出现在 0〜13 之间，我们可 以定义一个长度为 14 的哈希表，这样在 O(n)时间内就能完成排序</p>
</blockquote>
<pre><code>bool IsContinuous(int* numbers, int length)
{
    if(numbers == nullptr || length &lt; 1)
        return false;

    qsort(numbers, length, sizeof(int), Compare);

    int numberOfZero = 0;
    int numberOfGap = 0;

    // 统计数组中0的个数
    for(int i = 0; i &lt; length &amp;&amp; numbers[i] == 0; ++i)
        ++numberOfZero;

    // 统计数组中的间隔数目
    int small = numberOfZero;
    int big = small + 1;
    while(big &lt; length)
    {
        // 两个数相等，有对子，不可能是顺子
        if(numbers[small] == numbers[big])
            return false;

        numberOfGap += numbers[big] - numbers[small] - 1;
        small = big;
        ++big;
    }

    return (numberOfGap &gt; numberOfZero) ? false : true;
}

int Compare(const void *arg1, const void *arg2)
{
    return *(int*) arg1 - *(int*) arg2;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[strcpy()与memcopy()、memmove()]]></title>
        <id>https://lixin-scut.github.io//post/strcpyyu-memcopymemmove</id>
        <link href="https://lixin-scut.github.io//post/strcpyyu-memcopymemmove">
        </link>
        <updated>2020-03-12T11:32:09.000Z</updated>
        <content type="html"><![CDATA[<h3 id="strcpy">strcpy()</h3>
<p>strcpy函数的原型是：<br>
char * strcpy(char * strDest,const char * strSrc);<br>
注意strcpy是个危险的函数，隐藏着错位自赋值和溢出的危险，不建议使用。</p>
<pre><code>   strcpy的实现代码 
         char * strcpy(char * strDest,const char * strSrc)
        {
               if ((strDest == nullptr)||(strSrc == mullptr)) // [1]
                        return nullptr; 
                char * strDestCopy=strDest;  // [2]
                while (*strSrc != '\0')
								{
									*strDest = *strSrc;
									++strDest;
									++strSrc;
								}
								*strDest = '\0';
                return strDestCopy; // [3]
        }
</code></pre>
<p>[1]<br>
检查指针的有效性<br>
检查指针的有效性时不能使用((!strDest)||(!strSrc))或(!(strDest&amp;&amp;strSrc))，C语言中将char *转换为bool即是类型隐式转换<br>
[2]<br>
忘记保存原始的strDest值，说明答题者逻辑思维不严密。<br>
[3]<br>
返回 char *  而不是 const char * 保证链式调用正确执行。</p>
<h3 id="memcopy-memmove">memcopy()、memmove()</h3>
<p>1.与字符串函数strcpy区别：<br>
memcpy与memmove都是对内存进行拷贝可以拷贝任何内容，而strcpy仅是对字符串进行操作。<br>
memcpy与memmove拷贝多少是通过其第三个参数进行控制而strcpy是当拷贝至'\0'停止。</p>
<p>2.函数说明：<br>
memcpy函数的功能是从源src所指的内存地址的起始位置开始拷贝N个字节到目标dst所指的内存地址的起始位置中。<br>
memmove函数的功能同memcpy基本一致，但是当src区域和dst内存区域重叠时，memcpy可能会出现错误，而memmove能正确进行拷贝。</p>
<p>3.拷贝情况：<br>
拷贝的具体过程根据dst内存区域和src内存区域可分为三种情况：<br>
1.当src内存区域和dst内存区域完全不重叠<br>
2.当src内存区域和dest内存区域重叠时且dst所在区域在src所在区域<br>
3.当src内存区域和dst内存区域重叠时且src所在区域在dst所在区域前<br>
上述三种情况，memcpy可以成功对前两种进行拷贝，对第三种情况进行拷贝时，由于拷贝dst前两个字节时覆盖了src原来的内容，所以接下来的拷贝会出现错误。而memmove对第三种情况进行拷贝时会从src的最后向前拷贝N个字节，避免了覆盖原来内容的过程。</p>
<p><strong>memcpy：</strong></p>
<pre><code>void* _memcpy(void* dest, const void* src, size_t count)
{
	if(src != nullptr&amp;&amp;dest != nullptr)
		return nullptr;
	//判断dest指针和src指针是否为空，若为空抛出异常
	char* tmp_dest = static_cast&lt;char*&gt; dest;
	const char* tmp_src = static_cast&lt;const char*&gt; src;
	//将指针dest和指针src由void强转为char，
	//使得每次均是对内存中的一个字节进行拷贝
	while (count--)
	{
		*tmp_dest = *tmp_src;
		++tmp_dest ;
		++tmp_src;
	}
	
	return dest;
}
</code></pre>
<p><strong>memmove:</strong></p>
<pre><code>void* _memmove(void* dest, const void* src, size_t count)
{
	assert(src != nullptr&amp;&amp;dest != nullptr);
	//判断dest指针和src指针是否为空，若为空抛出异常
	char* tmp_dest = (char*)dest;
	const char* tmp_src = (const char*)src;

	if (tmp_src &lt; tmp_dest)//当src地址小于dest地址时，从头进行拷贝
		while (count--)
		{
			*tmp_dest = *tmp_src;
			++tmp_dest ;
			++tmp_src;
	 }
	else if (tmp_src &gt; tmp_dest)//当src地址大于dest地址时，从后进行拷贝
	{
		tmp_src += count - 1;
		tmp_dest += count - 1;
		while (count--)
		{
			*tmp_dest = *tmp_src;
			--tmp_dest ;
			--tmp_src;
		}		
	}
	//else(tmp_src==tmp_dest) 此时不进行任何操作
	return dest;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux下的错误码]]></title>
        <id>https://lixin-scut.github.io//post/linux-xia-de-cuo-wu-ma</id>
        <link href="https://lixin-scut.github.io//post/linux-xia-de-cuo-wu-ma">
        </link>
        <updated>2020-03-12T09:25:21.000Z</updated>
        <content type="html"><![CDATA[<h3 id="eintr">EINTR</h3>
<p>错误产生的原因-阻塞的系统调用、或者非阻塞的系统调用<br>
  如果进程在一个慢系统调用(slow system call)中阻塞时，当捕获到某个信号且相应信号处理函数返回时，这个系统调用不再阻塞而是被中断，就会调用返回错误（一般为-1），并且设置errno为EINTR（相应的错误描述为“Interrupted system call”）。</p>
<ul>
<li>解决方法1：重启被中断的系统调用<br>
  当碰到EINTR错误的时候，有一些可以重启的系统调用要进行重启，而对于有一些系统调用是不能够重启的。<br>
  例如：accept、read、write、select、和open之类的函数来说，是可以进行重启的。不过对于套接字编程中的connect函数是不能重启的，若connect函数返回一个EINTR错误的时候，我们不能再次调用它，否则将立即返回一个错误。针对connect不能重启的处理方法是，必须调用select来等待连接完成。</li>
<li>解决方法2：安装信号时设置 SA_RESTART属性（该方法对有的系统调用无效）</li>
<li>解决方法3： 忽略信号（让系统不产生信号中断）</li>
</ul>
<h3 id="eagain">EAGAIN</h3>
<p>一般用于非阻塞的系统调用<br>
  非阻塞的系统调用，由于资源限制/不满足条件，导致返回值为EAGAIN<br>
  在Linux环境下开发经常会碰到很多错误(设置errno)，其中EAGAIN是其中比较常见的一个错误(比如用在非阻塞操作中)。<br>
  如：首先是把套接字设置为非阻塞的了，然后在使用write发送数据时采取的方式是循环发送大量的数据；由于是异步的，write\send将要发送的数据提交到发送缓冲区后是立即返回的，并不需要对端确认数据已接收。在这种情况下是很有可能出现发送缓冲区被填满，导致write\send无法再向缓冲区提交要发送的数据。因此就产生了Resource temporarily unavailable的错误（资源暂时不可用），EAGAIN 的意思也很明显，就是要你再次尝试。<br>
  从字面上来看，是提示再试一次。这个错误经常出现在当应用程序进行一些非阻塞(non-blocking)操作(对文件或socket)的时候。<br>
  如：以 O_NONBLOCK的标志打开文件/socket/FIFO，如果连续做read操作而没有数据可读。此时程序不会阻塞起来等待数据准备就绪返回，read函数会返回一个错误EAGAIN，提示你的应用程序现在没有数据可读请稍后再试。<br>
又例如，当一个系统调用(比如fork)因为没有足够的资源(比如虚拟内存)而执行失败，返回EAGAIN提示其再调用一次(也许下次就能成功)。<br>
  解决办法：EAGAIN表明在非阻塞模式下调用了阻塞操作，在该操作没有完成就返回这个错误，这个错误不会破坏socket的同步，不用管它，下次循环接着读写就可以。<br>
  备注：对非阻塞socket而言，EAGAIN不是一种错误。在VxWorks和Windows上，EAGAIN的名字叫做EWOULDBLOCK。</p>
<h3 id="读书笔记中出现错误码的情况">读书笔记中出现错误码的情况</h3>
<p>《UNP》 第十六章 非阻塞I/O<br>
非阻塞connect<br>
如果对一个非阻塞的TCP套接字调用connect,并且连接不能立即建立，那么连接的建立 能照样发起（譬如送出TCP三路握手的第一个分组），不过会返回一个<strong>EINPROGRESS错误</strong>。注意 这个错误不同于上述三个情形中返回的错误。另请注意有些连接可以立即建立，通常发生在服 务器和客户处于同一个主机的情况下。因此即使对于一个非阻塞的connect,我们也得预备 connect成功返回的情况发生。</p>
<p>被中断的connect<br>
对于一个正常的阻塞式套接字，如果其上的connect调用在TCP三路握手完成前被中断（譬如说捕获了某个信号），将会发生什么呢？假设被中断的connect调用不由内核自动重启，那么 它将返回EINTR.我们不能再次调用connect等待未完成的连接继续完成。这样做将导致返回 EADDRINUSE 错误。<br>
这种情形下我们只能调用select，就像本节对于非阻塞connect所做的那样。连接建立成 功时select返回套接字可写条件，连接建立失败时select返回套接字既可读又可写条件。</p>
<p>非阻塞 accept</p>
<p>当有一个己完成的连接准备好被accept时，select将作为可读描述符返回该连接的监听套接字。因此，如果我们使用select在某个监听套接字上等待一个外来连接，理论上没有必要把该监听套接字设置为非阻塞，这是因为如果select告诉我们该套接字上已有连接就绪，那么随后的accept调用不应该阻塞。<br>
但实际中，这里存在一个可能让我们掉入陷阱的定时问题，如果服务器非常繁忙，它无法在select返回监听套接字的可读条件后就马上调用accpet（实际上这就是要维护一个已完成连接队列的原因），但是结合上连接建立之后到达的来自客户的RST,问题就出现了：<br>
・客户建立一个连接并随后中止它（close）。<br>
・select向服务器进程返回可读条件，不过服务器要过…小段时间才调用accept。<br>
・在服务器从select返回到调用accept期间，服务器TCP（注意不是应用层，应用层什么都不知道）收到来自客户的RST。<br>
・这个已完成的连接被服务器TCP驱除出队列，我们假设队列中没有其他已完成的连接。<br>
・服务器调用accept，但是由于没有任何己完成的连接，服务器于是阻塞。<br>
服务器会一直阻塞在accept调用上，直到其他某个客户建立一个连接为止，但是在此期间，服务器单纯阻塞在accept调用上，无法处理任何其他己就绪 的描述符。</p>
<p>本问题的解决办法如下。<br>
（1）	当使用select获悉某个监听套接字上何时有已完成连接准备好被accept时，总是把这个监听套接字设置为非阻塞。<br>
（2）	在后续的accept调用中忽略以下错误：<strong>EWOULDBLOCK （源自Berkeley的实现，客户中止连接时）、ECONNABORTED （POSIX实现，客户中止连接时）、EPROTO （SVR4实现，客户中止连接时）和EINTR （如果有信号被捕获）。</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[几种常见的设计模式]]></title>
        <id>https://lixin-scut.github.io//post/ji-chong-chang-jian-de-she-ji-mo-shi</id>
        <link href="https://lixin-scut.github.io//post/ji-chong-chang-jian-de-she-ji-mo-shi">
        </link>
        <updated>2020-03-12T07:14:27.000Z</updated>
        <content type="html"><![CDATA[<p>首先设计模式都是基于面向对象的三大特性：</p>
<p>三大特性是设计模式的基石。</p>
<h3 id="原则">原则</h3>
<p>下面是每个设计模式必须遵守的原则。</p>
<p><strong>单一职责原则</strong><br>
  单一职责原则：就一个类而言，应该仅有一个引起它变化的原因。<br>
  如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。<br>
  判断方法：如果我们能想到多于一个的动机去改变一个类，那这个类就是具有多于一个的职责</p>
<p><strong>开放—封闭原则</strong><br>
  开放——封闭原则：软件实体（类、模块、函数等等）应该可以扩展，但是不可修改。<br>
  这个原则其实有两个特征，一个是说“对于扩展是开放的（Open for extension）”，另一个是说“对于更改是封闭的（Closed for modification）”。<br>
  在我们最初编写代码时，假设变化不会发生。当变化发生时，我们就创建抽象来隔离以后发生的同类变化。<br>
  面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。<br>
  开放——封闭原则是面相对象设计的核心所在。遵循这个原则可以带来面相对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分作出抽象，然而，对于应用程序中的每个部分都进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。</p>
<p><strong>依赖倒转原则</strong>。</p>
<ol>
<li>高层模块不应该依赖低层模块。两个都应该依赖抽象。</li>
<li>抽象不应该依赖细节。细节应该依赖抽象。<br>
  不管高层模块还是低层模块，它们都依赖于抽象，具体一点就是接口或抽象类，只要接口是稳定的，那么任何一个的更改都不用担心其他收到影响，这就使得无论高层模块还是低层模块都可以很容易地被复用。</li>
</ol>
<p><strong>里氏代换原则</strong><br>
  里氏代换原则（LSP）：子类型必须能够替换掉它们的父类型。<br>
  一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化，简单的说，子类型必须能够替换掉它们的父类型。<br>
  只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。<br>
  由于子类型的可替换性才使得使用父类类型的模块在无需求改的情况下就可以扩展。<br>
  依赖倒转其实可以说是面相对象设计的标志，用哪种语言来编写程序并不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口，那就是面相对象的设计，反之那就是过程化的设计了。</p>
<p><strong>迪米特法则</strong><br>
  迪米特法则（LoD，也叫最少知识原则）：如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法对话，可以通过第三者转发这个调用。<br>
  迪米特法则首先强调对前提是在类对结构设计上，每一个类都应当尽量降低成员对访问权限，也就是说，一个类包装好自己对private状态，不需要让别的类知道的字段或行为就不要公开。<br>
  迪米特法则其根本思想，是强调了类之间的松耦合。<br>
  类之间的耦合越弱，越有利于复用，一个处在若耦合的类被修改，不会对有关系对类造成波及。</p>
<h3 id="单例模式">单例模式</h3>
<p>  这个是在项目中有用到的，日志类就应该只有一个实例，不应该同时有多份日志输出。</p>
<p>  单例模式（Singleton）：保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br>
  通常我们可以让一个全局变量使得一个对象被访问，但它不能防止你实例化多个对象。一个最好的办法就是，让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建，并且它可以提供一个访问该实例的方法。<br>
  单例模式因为Singleton类封装它的唯一实例，这样它可以严格地控制客户怎样访问它以及何时访问它。简单地说就是对唯一实例的受控访问。<br>
<img src="https://lixin-scut.github.io//post-images/1583999870201.png" alt=""></p>
<p>1.单例模式VS实用类的静态方法<br>
  实用类不保存状态，仅提供一些静态方法或静态属性让你使用，而单例类是有状态的。实用类不能用于继承多态，而单例虽然实例唯一，却是可以有子类来继承。实用类只不过是一些方法属性的集合，而单例却是有着唯一的对象实例。<br>
2.多线程时的单例<br>
  多线程中，调用GetInstance()方法，会有可能造成多个实例。<br>
  可以使用互斥量mutex和条件变量condition控制防止有多个线程同时要求生成实例</p>
<p>定义单例模式的方法：<br>
  首先将构造函数声明private的，然后定义static函数getInstance和static变量，根据static变量决定时候要new出一个实例。或者定义一个static对象。<br>
  定义单例模式实例的时机：<br>
  在程序一开始加载时就将自己实例化，称为饿汉式单例类。<br>
  在第一次被引用时才会将自己实例化，称为懒汉式单例类。<br>
  饿汉式，即静态初始化的方式，它是类一加载就实例化的对象，所以要提前占用系统资源。而懒汉式又会面临着多线程访问的安全性问题，需要做双重锁定这样的处理才可以保证安全。</p>
<h3 id="工厂模式">工厂模式</h3>
<p><strong>简单工厂模式</strong><br>
对于容易变化的部分，应该考虑用一个单独的类来做这个创造实例的过程<br>
方法和功能不用改变，只是生成的方式需要变动。<br>
<img src="https://lixin-scut.github.io//post-images/1584003925360.png" alt=""></p>
<p><strong>工厂方法模式</strong><br>
  工厂方法模式（Factory Method）：定义了一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类<br>
<img src="https://lixin-scut.github.io//post-images/1584004100951.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1584004036384.png" alt=""><br>
  简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除类与具体产品的依赖。对于前面的例子来说，我们将操作符如'+'传给工厂，工厂返回响应的实例，但这样违背了开放——封闭原则。<br>
  工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现运算类，选择判断的问题还是存在的，也就是说，工厂方法把简单工厂的内部逻辑判断转移到了客户端代码来进行，如果想要添加功能，本来是需要修改工厂类的，现在则需要修改客户端<br>
  工厂方法克服了简单工厂违背开发-封闭原则的缺点，又保持了封装对象创建过程的优点。<br>
  工厂方法模式是简单工厂模式的进一步抽象和推广，由于使用了多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。但缺点是每增加一个产品，就需要加一个产品工厂的类，增加了额外的开发量。</p>
<p><strong>抽象工厂模式</strong><br>
  抽象工厂模式（Abstract Factory）：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类<br>
涉及到多个产品系列的问题，都可以专门使用抽象工厂模式<br>
<img src="https://lixin-scut.github.io//post-images/1584004742730.png" alt=""><br>
  AbstractProductA和AbstractProductB是两个抽象产品，有两种不同的实现，而ProductA1、ProductA2和ProductB1、ProductB2就是对两个抽象产品的具体分类实现，<br>
  IFactory是一个抽象工厂接口，它里面应该包含所有产品的创建的抽象方法，ConcreteFactory1和ConcreteFactory2就是具体的工厂了。<br>
  通常在运行时刻再创建一个ConcreteFactory类的实例，这个具体的工厂再创建一个具有特定实现的产品对象<br>
  所以，为了创建不同的产品对象，客户端应当是用不同的具体工厂</p>
<p>好处：</p>
<ol>
<li>易于交换产品系列，由于具体工厂类，在一个应用中只需要在初始化的时候出现一次，这就使得改变一个应用的具体工厂变得非常容易，他只需要改变具体工厂即可使用不同的产品配置。</li>
<li>它让具体的创建实例过程与客户端分离，客户端是通过它们的抽象接口操作实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户代码中。<br>
缺点：</li>
<li>新增功能要增加的类太多</li>
</ol>
<p>附录：<br>
代码<br>
简答工厂模式：<br>
<img src="https://lixin-scut.github.io//post-images/1584004206206.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1584004216211.png" alt=""><br>
工厂方法模式：<br>
<img src="https://lixin-scut.github.io//post-images/1584004161995.png" alt=""><br>
抽象工厂模式<br>
<img src="https://lixin-scut.github.io//post-images/1584004782442.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1584004793519.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1584004804625.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1584004818382.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis数据库]]></title>
        <id>https://lixin-scut.github.io//post/redis-shu-ju-ku</id>
        <link href="https://lixin-scut.github.io//post/redis-shu-ju-ku">
        </link>
        <updated>2020-03-10T15:24:27.000Z</updated>
        <content type="html"><![CDATA[<h2 id="跳跃表">跳跃表</h2>
<p>跳跃表(skiplist)是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的 指针，从而达到快速访问节点的目的。<br>
跳跃表支持平均O(logN)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。<br>
在大部分情况下，跳跃表的效率可以和平衡树相媲美，并且因为跳跃表的实现比平衡树 要来得更为简单，所以有不少程序都使用跳跃表来代替平衡树。<br>
Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量 比较多，又或者有序集合中元素的成员(member)是比较长的字符串时，Redis就会使用跳 跃表来作为有序集合键的底层实现。</p>
<p><strong>跳跃表的实现</strong><br>
Redis 的跳跃表由 redis.h/zskiplistNode 和 redis.h/zskiplist 两个结构定义，其中zskiplistNode结构用于表示跳跃表节点，而zskiplist结构则用于保存跳跃表节点的相关信息，比如节点的数量，以及指向表头节点和表尾节点的指针等等。<br>
<img src="https://lixin-scut.github.io//post-images/1583856682528.png" alt=""><br>
跳跃表示例，位于图片最左边的是zskiplist结构，该结构包含以 下属性：</p>
<ul>
<li>header：指向跳跃表的表头节点。</li>
<li>tail：指向跳跃表的表尾节点。<br>
通过这两个指针，程序定位表头节点和表尾节点的复杂度为O(1)。</li>
<li>level：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内），用于在O(1)复杂度内获取跳跃表中层高最大的那个节点的层数量</li>
<li>length：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计 算在内），程序可以在O(1)复杂度内返回跳跃表的长度<br>
位于zskiplist结构右方的是四个zskiplistNode结构，该结构包含以下属性：<br>
层（level ）:节点中用LI、L2、L3等字样标记节点的各个层，L1代表第一层，L2 代表第二层，以此类推。每个层都带有两个属性：前进指针和跨度<br>
后退（backward）指针：节点中用BW字样标记节点的后退指针，它指向位于当前节 点的前一个节点。<br>
分值（score）：各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中， 节点按各自所保存的分值从小到大排列。<br>
成员对象（obj）：各个节点中的o1、o2和o3是节点所保存的成员对象。</li>
</ul>
<p>注意表头节点和其他节点的构造是一样的：表头节点也有后退指针、分值和成员对象，不 过表头节点的这些属性都不会被用到</p>
<p><strong>层</strong><br>
跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指 针，程序可以通过这些层来加快访问其他节点的速度，一般来说，层的数量越多，访问其他 节点的速度就越快。<br>
每次创建一个新跳跃表节点的时候，程序都根据幂次定律（power law,越大的数出现 的概率越小）随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的“高度”。</p>
<p><strong>前进指针</strong><br>
每个层都有一个指向表尾方向的前进指针（level[i] .forward属性），用于从表头 向表尾方向访问节点。</p>
<p><strong>跨度</strong><br>
层的跨度（level [i] .span属性）用于记录两个节点之间的距离：<br>
□两个节点之间的跨度越大，它们相距得就越远。<br>
□指向NULL的所有前进指针的跨度都为0,因为它们没有连向任何节点。<br>
初看上去，很容易以为跨度和遍历操作有关，但实际上并不是这样，遍历操作只使用前 进指针就可以完成了，跨度实际上是用来计算排位（rank）的：在查找某个节点的过程中， 将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。</p>
<p><strong>后退指针</strong><br>
节点的后退指针（backward属性）用于从表尾向表头方向访问节点：跟可以一次跳过 多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次只能后退至前一个节点。</p>
<p><strong>分值和成员</strong><br>
节点的分值（score属性）是一个doubl e类型的浮点数，跳跃表中的所有节点都按 分值从小到大来排序。<br>
节点的成员对象（obj属性）是一个指针，它指向一个字符串对象，而字符串对象则保 存着一个SDS值。<br>
在同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值 却可以是相同的：分值相同的节点将按照成员对象在字典序中的大小来进行排序，成员对象</p>
<p><strong>跳跃表的原理</strong><br>
跳跃表在redis中主要是有序表的一种底层实现。对于普通链表的查找，即使有序，我们也不能使用二分法，需要从头开始，一个一个找，时间复杂度为O(n)。而对于跳跃表，从名字可以看出跳跃表的优势就在于可以跳跃。如何做到呢？在于其特殊的层设计。比如我们查找46，普通链表只能从头开始查找，比对-3,2,17...直到46，要比对7次。但是对于跳跃表，我们可以从最高层开始查找：<br>
第一步：在L4层直接与55比对，发现大了，退回到第3层<br>
第二步：在L3层与21比对，发现小了，继续往前比对55，发现大了，退回到第二层<br>
第三步：在L2层与37比对，发现小了，往前，与55比对，发现大了，退回到第一层<br>
第四步：在第1层，与46比对，查找成功。<br>
共比对了6次，比普通链表只节省了一次，似乎没什么优势。但如果细想，当链表比较长的时候，在高层查找时，跳过的元素数量将相当可观，提速的效果将非常明显。比如如果元素在55之后，在L4层，我们直接就跳过了7个元素，这是非常大的进步。<br>
<img src="https://lixin-scut.github.io//post-images/1583858207217.png" alt=""><br>
<a href="https://blog.csdn.net/qq_34412579/article/details/101731935">跳表的各种时间复杂度、适用场景以及实现原理</a></p>
<h2 id="redis持久化">Redis持久化</h2>
<h3 id="rdb持久化">RDB持久化</h3>
<p>将服务器中的非空数据库以及它 们的键值对统称为数据库状态。<br>
Redis是内存数据库，它将自己的数据库状态储存在内存里面，必须将储存在内存中的数据库状态保存到磁盘 里面<br>
Redis提供了 RDB持久化功能，这个功能可以将Redis在内存中的数据库状态保存到磁盘里面，避免数据意外丢失。<br>
RDB持久化既可以手动执行，也可以根据服务器配置选项定期执行，该功能可以将某 个时间点上的数据库状态保存到一个RDB文件中<br>
RDB持久化功能所生成的RDB文件是一个经过压缩的二进制文件，通过该文件可以还 原生成RDB文件时的数据库状态</p>
<p><strong>RDB文件的创建与载入</strong><br>
有两个Redis命令可以用于生成RDB文件，一个是SAVE,另一个是BGSAVE<br>
SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞 期间，服务器不能处理任何命令请求：<br>
BGSAVE命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程(父进程)继续处理命令请求：<br>
创建RDB文件的实际工作由rdb.c/rdbSave函数完成<br>
RDB文件的载入工作是在服 务器启动时自动执行的，所以Redis并没有专门用于载入RDB文件的命令，只要Redis服 务器在启动时检测到RDB文件存在，它就会自动载入RDB文件。</p>
<p>因为AOF文件的更新频率通常比RDB文件的更新频率高，所以：</p>
<ul>
<li>如果服务器开启了 AOF持久化功能，那么服务器会优先使用AOF文件来还原数据 库状态。</li>
<li>只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。</li>
</ul>
<h3 id="aof持久化">AOF持久化</h3>
<p>除了 RDB持久化功能之外，Redis还提供了 AOF ( Append Only File )持久化功能。与 RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是通过保存 Redis服务器所执行的写命令来记录数据库状态的<br>
RDB持久化保存数据库状态的方法是将键值对保存到RDB文件中，而AOF持久化保存数据库状态的方法则是将服务器执行的SET、SADD、 RPUSH等命令保存到AOF文件中。<br>
服务器在启动时，可以通过载入和执行AOF文件中保存的命令来还原服务器关闭之前 的数据库状态</p>
<p><strong>AOF持久化的实现</strong><br>
AOF持久化功能的实现可以分为命令追加(append)、文件写入、文件同步(sync)三个步骤。</p>
<p><strong>命令追加</strong><br>
当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式 将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾<br>
注意写命令亦即修改数据库的命令，删除也是写命令，写命令不仅是添加命令</p>
<p><strong>AOF文件的写入与同步</strong><br>
Redis的服务器进程就是一个事件循环(loop),这个循环中的文件事件负责接收客户端 的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像serverCron函数这样需要定时运行的函数。<br>
因为服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到aof_buf缓冲 区里面，所以在服务器每次结束一个事件循环之前，它都会调用flushAppendOnlyFile函数，考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里面<br>
<img src="https://lixin-scut.github.io//post-images/1583855911517.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1583855930254.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1583855956684.png" alt=""></p>
<p><strong>AOF文件的载入与数据还原</strong><br>
因为AOF文件里面包含了重建数据库状态所需的所有写命令，所以服务器只要读入并 重新执行一遍AOF文件里面保存的写命令，就可以还原服务器关闭之前的数据库状态。</p>
<p><strong>AOF 重写</strong><br>
因为AOF持久化是通过保存被执行的写命令来记录数据库状态的，所以随着服务器运 行时间的流逝，AOF文件中的内容会越来越多，文件的体积也会越来越大，如果不加以控 制的话，体积过大的AOF文件很可能对Redis服务器、甚至整个宿主计算机造成影响，并 且AOF文件的体积越大，使用AOF文件来进行数据还原所需的时间就越多。<br>
为了解决AOF文件体积膨胀的问题，Redis提供了 AOF文件重写（rewrite）功能。通 过该功能，Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件，新旧两个 AOF文件所保存的数据库状态相同，但新AOF文件不会包含任何浪费空间的冗余命令，所 以新AOF文件的体积通常会比旧AOF文件的体积要小得多。</p>
<p><strong>AOF文件重写的实现</strong><br>
虽然Redis将生成新AOF文件替换旧AOF文件的功能命名为“AOF文件重写”，但实 际上，AOF文件重写并不需要对现有的AOF文件进行任何读取、分析或者写入操作，这个 功能是通过读取服务器当前的数据库状态来实现的。<br>
从数据库中读取键现在的值，然后用一条命令去记录键值对， 代替之前记录这个键值对的多条命令，这就是AOF重写功能的实现原理。<br>
aof_rewrite函数生成的新AOF文件只包含还原当前数据库状态所必须的命令, 所以新AOF文件不会浪费任何硬盘空间。</p>
<p><strong>AOF后台重写</strong><br>
上面介绍的AOF重写程序aof_rewrite函数可以很好地完成创建一个新AOF文件的 任务，但是，因为这个函数会进行大量的写入操作，所以调用这个函数的线程将被长时间阻塞, 因为Redis服务器使用单个线程来处理命令请求，所以如果由服务器直接调用aof_rewrite函数的话，那么在重写AOF文件期间，服务期将无法处理客户端发来的命令请求。<br>
所以Redis决定将AOF重写程序放到子进程里执行，这样做可以同时达到两个 目的：</p>
<ul>
<li>子进程进行AOF重写期间，服务器进程（父进程）可以继续处理命令请求。</li>
<li>子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的 情况下，保证数据的安全性。<br>
不过，使用子进程也有一个问题需要解决，因为子进程在进行AOF重写期间，服务器 进程还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，从而使得 服务器当前的数据库状态和重写后的AOF文件所保存的数据库状态不一致。</li>
</ul>
<p>为了解决这种数据不一致问题，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区 在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令之后，它会同时将这 个写命令发送给AOF缓冲区和AOF重写缓冲区，</p>
<p>这样一来可以保证：</p>
<ul>
<li>AOF缓冲区的内容会定期被写入和同步到AOF文件，对现有AOF文件的处理工作 会如常进行。</li>
<li>从创建子进程开始，服务器执行的所有写命令都会被记录到AOF重写缓冲区里面。<br>
当子进程完成AOF重写工作之后，它会向父进程发送一个信号，父进程在接到该信号 之后，会调用一个信号处理函数，并执行以下工作：<br>
1 ）将AOF重写缓冲区中的所有内容写入到新AOF文件中，这时新AOF文件所保存的 数据库状态将和服务器当前的数据库状态一致。<br>
2）对新的AOF文件进行改名，原子地（atomic）覆盖现有的AOF文件，完成新旧两 个AOF文件的替换。</li>
</ul>
<h2 id="慢查询日志">慢查询日志</h2>
<p>Redis的慢查询日志功能用于记录执行时间超过给定时长的命令请求，用户可以通过这 个功能产生的日志来监视和优化查询速度。<br>
服务器配置有两个和慢查询日志相关的选项：</p>
<ul>
<li>slowlog-log-slower-than选项指定执行时间超过多少微秒（1秒等于1 000 000 微秒）的命令请求会被记录到日志上。</li>
<li>slowlog-max-len选项指定服务器最多保存多少条慢查询日志。<br>
服务器使用先进先出的方式保存多条慢查询日志，当服务器存储的慢查询日志数量等于 slowlog-max-len选项的值时，服务器在添加一条新的慢查询日志之前，会先将最旧的 一条慢查询日志删除。</li>
</ul>
<p>使用SLOWLOG GET命令查看服务器所保存的慢查询日志:</p>
<p><strong>添加新日志</strong><br>
在每次执行命令的之前和之后，程序都会记录微秒格式的当前UNIX时间戳，这两个时间戳之间的差就是服务器执行命令所耗费的时长，服务器会将这个时长作为参数之一传给 slowlogPushEntryIfNeeded 函数，而 slowlogPushEntryIfNeeded 函数贝则负责检查是否需要为这次执行的命令创建慢查询日志</p>
<h2 id="线程">线程</h2>
<p>redis是单线程，线程安全<br>
redis可以能够快速执行的原因：<br>
(1) 绝大部分请求是纯粹的内存操作（非常快速）<br>
(2) 采用单线程,避免了不必要的上下文切换和竞争条件<br>
(3) 非阻塞IO - IO多路复用<br>
IO多路复用中有三种方式：select,poll,epoll。需要注意的是，select,poll是线程不安全的，epoll是线程安全的<br>
redis内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间 这3个条件不是相互独立的，特别是第一条，如果请求都是耗时的，采用单线程吞吐量及性能可想而知了。应该说redis为特殊的场景选择了合适的技术方案。</p>
<p>redis是单线程运行，所以多个redis命令是一个一个执行，所以是线程安全的 ， 但是分开的两个redis命令，对于【应用】不是线程安全的，因为这两个redis命令之间会有其他命令，就像不安全的i++操作，这个两个redis命令没有事务管理<br>
可以用RPOPLPUSH, 或者lua脚本，实现多个redis操作合为一个命令，这样就对【应用】线程安全了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[索引]]></title>
        <id>https://lixin-scut.github.io//post/suo-yin</id>
        <link href="https://lixin-scut.github.io//post/suo-yin">
        </link>
        <updated>2020-03-10T15:13:24.000Z</updated>
        <content type="html"><![CDATA[<p>为了快速随机访问文件中的记录，可以使用索引结构。每个索引结构与一个特定的搜索码相关联。<br>
索引中的词是按顺序排列的，数据库系统首先会查找索引，找到相应记录所在的磁盘块，然后取出该磁盘块,得到所需的记录。</p>
<p>有两种基本的索引类型：</p>
<ul>
<li>顺序索引。基于值的顺序排序。</li>
<li>散列索引。基于将值平均分布到若干散列桶中。一个值所属的散列桶是由一个函数决定的，该函数称为散列函数(hash function)。</li>
</ul>
<p><strong>顺序索引</strong><br>
顺序索引按顺序存储搜索码的值，并将每个搜索码与包含该搜 索码的记录关联起来。</p>
<ol>
<li>一个文件可以有多个索引，分别基于不同的搜索码。如果包含记录的文件按照某个搜索码指定的顺序排序，那么该搜索码对应的索引称为聚集索引。聚集索引称为主索引。聚集索引的搜索码常常是主码。</li>
<li>搜索码指定的顺序与文件中记录的物理顺序不同的索引成为非聚集索引或者辅助索引<br>
假定所有文件都按照某些搜索码顺序排列。这种在搜索码上有聚集索引的文件称为索引顺序文件</li>
</ol>
<p><strong>稠密索引和稀疏索引</strong><br>
索引项(index entry)或索引记录(index record)由一个搜索码值和指向具有该搜索码值的一条或者多条记录的指针构成，指向记录的指针包括磁盘块的标识和标识磁盘块内记录的块内偏移量<br>
我们可以使用的顺序索引有两类</p>
<ul>
<li>稠密索引：在稠密索引中，文件中的每个搜索码值都有一个索引项。在稠密聚集索引中，索引项包括搜索码值以及指向具有该搜索码值的第一条数据记录的指针。具有相同搜索码值的其余记录顺序地存储在第一条数据记录之后，由于该索引是聚集索引，因此记录根据相同的搜索码值排序。<br>
在稠密非聚集索引中，索引必须存储指向所有具有相同搜索曲旺衅翊也</li>
<li>稀疏索引：在稀疏索引中，只为搜索码的某些值建立索引项。只有当关系按搜索码排列顺序存储时才能使用稀疏索引，换句话说，只有索引是聚集索引时才能使用稀疏索引。 和稠密索引一样，每个索引项也包括一个搜索码值和指向具有该搜索码值的第一条数据记录的 指针。为了定位一条记录，我们找到其最大搜索码值小.坚等于所查找记录的搜索码值的索引，然后从该索引项指向的记录开始，沿着文件中的指针查找，直到找到所需的记录为止（字典中 每页顶部的单词共同构成了字典页内容的稀疏索引）。</li>
</ul>
<p>具有两级或两级以上的索引称为多级索引，利用多级索引搜索记录与用二分法搜索记录相比需要的I/O操作要少得多°。</p>
<p><strong>辅助索引</strong><br>
辅助索引必须是稠密索引，对每个搜索码值都有一个索引项，而且对文件中的每条记录都有一个指针。<br>
候选码上的辅助索引看起来和稠密聚集索引没有太大的区别，只不过索引中一系列的连续值指向 的记录不是连续存放的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[事务性隔离性级别]]></title>
        <id>https://lixin-scut.github.io//post/shi-wu-xing-ge-chi-xing-ji-bie</id>
        <link href="https://lixin-scut.github.io//post/shi-wu-xing-ge-chi-xing-ji-bie">
        </link>
        <updated>2020-03-10T14:33:26.000Z</updated>
        <content type="html"><![CDATA[<h3 id="事务性隔离性级别">事务性隔离性级别</h3>
<ul>
<li>可串行化(serializable)：通常保证可串行化调度。<br>
最高的隔离级别，它通过强制事务串行执行（注意是串行），避免了幻读情况，由于他大量加上锁，导致大量的请求超时，因此性能会比较底下，再特别需要数据一致性且并发量不需要那么大的时候才可能考虑这个隔离级别。</li>
<li>可重复读(repeatable read)：只允许读取已提交数据，而且在一个事务两次读取一个数据项期间，其他事务不得更新该数据。<br>
解决了脏读的问题，该级别保证了每行的记录的结果是一致的，也就是上面说的读了旧数据的问题，但是却无法解决另一个问题，幻读，指的就是某个事务在读取某个范围的数据，但是另一个事务又向这个范围的数据去插入数据，导致多次读取的时候，数据的行数不一致。虽然读取同一条数据可以保证一致性，但是却不能保证没有插入新的数据。</li>
<li>已提交读(read committed)：只允许读取已提交数据，但不要求可重复读。<br>
大多数数据库系统的默认隔离级别是READ COMMITTED，这种隔离级别就是一个事务的开始，只能看到已经完成的事务的结果，正在执行的，是无法被其他事务看到的。这种级别会出现读取旧数据的现象</li>
<li>未提交读(read uncommitted):允许读取未提交数据。<br>
事务中的修改，即使没有提交，其他事务也可以看得到，这种现象就叫做脏读，这种隔离级别会引起很多问题，如无必要，不要随便使用；这就是事务还没提交，而别的事务可以看到他其中修改的数据的后果，也就是脏读；</li>
</ul>
<p>以上所有隔离性级别都不允许脏写(dirty write),即如果一个数据项已经被另外一个尚未提交或中止的事务写入，则不允许对该数据项执行写操作。</p>
<p>隔离级别高的数据库的可靠性高，但并发量低，而隔离级别低的数据库可靠性低，但并发量高，系统开销小。</p>
<h3 id="幻读">幻读</h3>
<p>事务在插入已经检查过不存在的记录时，惊奇的发现这些数据已经存在了，之前的检测获取到的数据如同鬼影一般。<br>
MySql默认的隔离级别为Repeatable Read，因此只会出现幻读的情况。<br>
例子：<br>
在事务1中，查询User表id为1的是用户否存在，如果不存在则插入一条id为1的数据。<br>
<code>select * from User where id = 1;</code><br>
在事务1查询结束后，事务2往User表中插入了一条id为1的数据。<br>
<code>insert into</code>User<code>(</code>id<code>,</code>name<code>) values (1, 'Joonwhee');</code><br>
此时，由于事务1查询到id为1的用户不存在，因此插入1条id为1的数据。<br>
<code>insert into</code> User<code>(</code>id<code>,</code>name<code>) values (1, 'Chillax');</code><br>
但是由于事务2已经插入了1条id为1的数据，因此此时会报主键冲突，对于事务1 的业务来说是执行失败的，这里事务1就是发生了幻读，因为事务1读取的数据状态并不能支持他的下一步的业务，见鬼了一样。这里要灵活的理解读取的意思，第一次select是读取，第二次的insert其实也属于隐式的读取，只不过是在mysql的机制中读取的，插入数据也是要先读取一下有没有主键冲突才能决定是否执行插入。</p>
<h3 id="如何解决幻读">如何解决幻读</h3>
<p>将两行记录间的空隙加上锁，阻止新记录的插入；这个锁称为间隙锁。<br>
间隙锁与间隙锁之间没有冲突关系。跟间隙锁存在冲突关系的，是往这个间隙中插入一个记录这个操作。</p>
<h3 id="数据的锁的种类加锁的方式">数据的锁的种类，加锁的方式</h3>
<ol>
<li>锁是网络数据库中的一个非常重要的概念，当多个用户同时对数据库并发操作时，会带来数据不一致的问题，所以，锁主要用于多用户环境下保证数据库完整性和一致性。</li>
<li>数据库锁出现的目的：处理并发问题；</li>
<li>并发控制的主要采用的技术手段：乐观锁、悲观锁和时间戳。</li>
<li>从数据库系统角度分为三种：排他锁、共享锁、更新锁。从程序员角度分为两种：一种是悲观锁，一种乐观锁。</li>
</ol>
<h3 id="乐观锁与悲观锁">乐观锁与悲观锁</h3>
<p>注意乐观锁和悲观锁不是一种特定锁，而是指检查冲突手段的差异</p>
<p><strong>乐观锁</strong><br>
乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。乐观锁不会刻意使用数据库本身的锁机制，而是依据数据本身来保证数据的正确性。<br>
<img src="https://lixin-scut.github.io//post-images/1583851830110.png" alt=""><br>
在有效性检查机制中，由于事务乐观地执行，假定它们能够完成执行并且最终有效，因此也称为乐观的并发控制(optimistic concurrency control)机制。<br>
乐观锁的概念中其实已经阐述了它的具体实现细节。主要就是两个步骤：冲突检测和数据更新。其实现方式有一种比较典型的就是CAS(Compare and Swap)。</p>
<p>CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。<br>
我们在更新之前，先查询一下库存表中当前库存数（quantity），然后在做update的时候，以库存数作为一个修改条件。当我们提交更新的时候，判断数据库表对应记录的当前库存数与第一次取出来的库存数进行比对，如果数据库表当前库存数与第一次取出来的库存数相等，则予以更新，否则认为是过期数据。</p>
<p><strong>悲观锁：</strong><br>
悲观锁的实现往往依靠数据库提供的锁机制。在数据库中，悲观锁的流程如下：</p>
<ol>
<li>在对记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。</li>
<li>如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。具体响应方式由开发者根据实际需要决定。</li>
<li>如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。</li>
<li>期间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。</li>
<li>例如在对id = 1的记录修改前，先通过select…for update的方式进行加锁，然后再进行修改。这就是比较典型的悲观锁策略。<br>
封锁和时间戳排序是悲观的，因为当它们检测 到一个冲突时，它们强迫事务等待或回滚，即使该调度有可能是冲突可串行化的。</li>
</ol>
<p><strong>如何选择</strong></p>
<ol>
<li>在乐观锁与悲观锁的选择上面，主要看下两者的区别以及适用场景就可以了。<br>
乐观锁并未真正加锁，效率高。一旦锁的粒度掌握不好，更新失败的概率就会比较高，容易发生业务失败。</li>
<li>悲观锁依赖数据库锁，效率低。更新失败的概率比较低。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[放松系列！智力题]]></title>
        <id>https://lixin-scut.github.io//post/fang-song-xi-lie-zhi-li-ti</id>
        <link href="https://lixin-scut.github.io//post/fang-song-xi-lie-zhi-li-ti">
        </link>
        <updated>2020-03-10T12:21:03.000Z</updated>
        <content type="html"><![CDATA[<p>投完简历很紧张很紧张，但是也不想做那种无意义的放纵行为<br>
发现个很有趣的放松方法，就是看看那些智力题，答案都特别意料之外hhh，但是又是巧妙地将学到的算法和数据结构运用起来了。</p>
<h3 id="摔鸡蛋">摔鸡蛋：</h3>
<p>两个鸡蛋一样，只有在达到某个楼层高度时，才会摔碎。问100层楼至少需要试多少次？<br>
<strong>假设法</strong><br>
假设最多允许尝试X次，问能尝试到的最高的楼层。</p>
<ul>
<li>第1次从X楼扔下来。因为即使摔坏了，也可以用另一个鸡蛋遍历X-1次找到该楼层</li>
<li>第2次（还剩X-1次尝试次数）可以从X+(X-1)层扔下来。因为即使摔碎了，也可以用另一个鸡蛋遍历X-1-1次找到该楼层。</li>
<li>同理，第3次，可以从X+(X-1)+(X-2)层扔下来。</li>
<li>第X次。可以从第X+(X-1)+(X-2)+...+(X-(X-2))+1层扔下来，这就是最高可能尝试到的楼层X*(X+1)/2，下面所有的楼层都可以在X次尝试中到达。</li>
<li>当最高楼层为100时，可列出不等式：最高可能尝试到的楼层X*(X+1)/2 &gt; 100，解出X=14次。这就是最稳定的最快寻找到该楼层的扔鸡蛋次数。也就是说第一次扔鸡蛋要从14楼开始扔。14+13+12+11+...+2+1 = 105层，也就是14次尝试一定可以在1-105层中找到那个第N层。推出了公式X*(X+1)/2后，要想编程求任意总楼层条件下，就都很方便了。</li>
</ul>
]]></content>
    </entry>
</feed>