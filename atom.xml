<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-03-09T00:30:25.953Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>In the darkest night,Rising like a spire.</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[数组 题57:和为s的两个数字]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-ti-57he-wei-s-de-liang-ge-shu-zi</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-ti-57he-wei-s-de-liang-ge-shu-zi">
        </link>
        <updated>2020-03-09T00:20:50.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题目一">题目一</h3>
<p>题目描述</p>
<blockquote>
<p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p>
</blockquote>
<p>【未做出】<br>
因为数组是排序的，我的想法是从数组中间出发，用双指针不断往两边移动<br>
从中间出发的原因是因为数组中间的数的乘积肯定大于两边的数的乘积<br>
每当找到符合条件的数的时候，就先用一个变量存储下来，然后先移动左边的指针使得当前的和值缩小</p>
<p>突然发现一个问题 比如{1,1,1,1,10,90}<br>
那么符合答案100的就是10+90，从中间开始往两边移动肯定就不行了</p>
<p>然后就是leetcode上面的解法了<br>
每个元素都遍历后面的元素 但是我感觉似乎找到第一个就可以结束了，毕竟后面的乘积肯定比前面的大<br>
等等！！！负数呢？！！！如果是 {-2,-1,1,2}的话，-2 和 2 是不是比 -1 和 1 小呢,确认还是第一个遇到的符合结果的就可以直接返回了</p>
<p>看完书才发现我之前的思想是正确的。。。只是必须从两边到中间而已。。。。就是没多思考一步</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum)
    {
        vector&lt;int&gt; res;
        int length = array.size();
        if(length&lt;2)
            return res;
        int left = 0;
        int right = length - 1;
        while(left &lt; right)
        {
            if(array[left] + array[right] == sum)
            {
                res.push_back(array[left]);
                res.push_back(array[right]);
                return res;
            }
            if(array[left] + array[right] &gt; sum)
                --right;
            else
                ++left;
        }
        return res;
    }
    
    /*时间复杂度O(n^2)
    vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum) 
    {
        vector&lt;int&gt; res;
        int length = array.size();
        if(length&lt;2)
            return res;
        for(int i = 0;i &lt; length;++i)
            for(int j = i + 1;j &lt; length;++j)
            {
                if(array[i]+array[j] == sum)
                {
                    res.push_back(array[i]);
                    res.push_back(array[j]);
                    return res;
                }
                if(array[i]+array[j] &gt; sum)
                    break;
            }
        return res;
    }
    */
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>首先定义两个指针，第一个指针指向数组的第一个(最小的)数字 , 第二个指针 指向数组的最后一个(最大的)数字 ，当前和大于给出值的时候右指针向前移，当前和小于给出值的时候左指针向后移，从两端向中间 扫描数组，因此这种算法的时间复杂度是 O(n)。</p>
</blockquote>
<pre><code>bool FindNumbersWithSum(int data[], int length, int sum, 
                        int* num1, int* num2)
{
    bool found = false;
    if(length &lt; 1 || num1 == nullptr || num2 == nullptr)
        return found;

    int ahead = length - 1;
    int behind = 0;

    while(ahead &gt; behind)
    {
        long long curSum = data[ahead] + data[behind];

        if(curSum == sum)
        {
            *num1 = data[behind];
            *num2 = data[ahead];
            found = true;
            break;
        }
        else if(curSum &gt; sum)
            ahead --;
        else
            behind ++;
    }

    return found;
}
</code></pre>
<h3 id="题目二">题目二</h3>
<p>题目描述：</p>
<blockquote>
<p>输入一个正数s，打印出所有和为s的连续正数序列（至少含有两个数）。</p>
</blockquote>
<p>【未做出】<br>
连续序列的和可以靠等差数列的求和公式解决<br>
然后就是注意题目中并没有说明序列的个数（只是至少包含两个数，而不是固定数目）<br>
然后就是双指针法了,两个指针不断前进<br>
需要注意的点<br>
1.beg和end分别初始化为1和2，所以初始判断条件为&lt;3<br>
2.等差数列求和公式<br>
3.插入完成后一定要递增beg<br>
4.beg和end的递增条件和时机</p>
<pre><code>class Solution {
public:
    vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) {
        vector&lt;vector&lt;int&gt;&gt; res;
        if(sum &lt; 3)
            return res;
        int beg;
        int end;
        int curSum;
        beg = 1;
        end = 2;
        while(beg &lt; end)
        {
            curSum = (beg + end)*(end - beg + 1)/2;
            if(curSum == sum){
                insertRes(res,beg,end);
                ++beg;
            }
            else if(curSum &lt;= sum)
                ++end;
            else
                ++beg;
        }
        return res;
    }
    
    void insertRes(vector&lt;vector&lt;int&gt;&gt; &amp;res,int beg,int end)
    {
        res.push_back(vector&lt;int&gt;());
        for(int i = beg;i &lt;= end; ++i)
            res.back().push_back(i);
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>用两个数 small 和 big 分别表示 序列 的最小值和最大值。首先把 small 初始化为 1, big 初始化为 2。如果从 small 到 big 的序列的和大于 s,则可以从序列中去掉较小的值，也就是增大 small 的值。如果 从 small 到 big 的序列的和小于 s,则可以增大 big,让这 个序列包含更多的数字。 因为这个序列至少要有两个数字，我们一直增加 small到(1+s)/2 为止。</p>
</blockquote>
<pre><code>void FindContinuousSequence(int sum)
{
    if(sum &lt; 3)
        return;

    int small = 1; 
    int big = 2;
    int middle = (1 + sum) / 2;
    int curSum = small + big;

    while(small &lt; middle)
    {
        if(curSum == sum)
            PrintContinuousSequence(small, big);

        while(curSum &gt; sum &amp;&amp; small &lt; middle)
        {
            curSum -= small;
            small ++;

            if(curSum == sum)
                PrintContinuousSequence(small, big);
        }

        big ++;
        curSum += big;
    }
}

void PrintContinuousSequence(int small, int big)
{
    for(int i = small; i &lt;= big; ++ i)
        printf(&quot;%d &quot;, i);

    printf(&quot;\n&quot;);
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 题56:数组中数字出现的次数[未做出]]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-ti-56shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-ti-56shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-wei-zuo-chu">
        </link>
        <updated>2020-03-08T23:53:24.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题目一">题目一</h3>
<p>题目描述</p>
<blockquote>
<p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
</blockquote>
<p>【未做出】<br>
一开始看错题目了，以为是只有一个数，结果发现是两个数<br>
书本的题解很巧妙，全部的数相与后，按照某一位是否为1把数组分为两个部分，因为对于那两个数来说，这一位肯定是不同的<br>
而对剩下的数来说，肯定会被分到不同的数组中。<br>
实现的时候只需要两次遍历，第二次遍历中检查相应的位数，然后执行相与就行，不用真的分成两个数组再相与<br>
代码中出现了两个很细节的问题<br>
1.位运算符&lt;&lt;返回的是右值，和加减乘除没有什么区别，所以必须要赋值带上赋值操作 bit=bit&lt;&lt;1<br>
2.==运算符的优先级高于位运算符，所以与操作&amp;必须加上括号</p>
<pre><code>class Solution {
public:
    void FindNumsAppearOnce(vector&lt;int&gt; data,int* num1,int *num2) {
        int res = 0;
        for(int i:data)
            res ^= i;
        int bit = diffBit(res);
        *num1 = 0;
        *num2 = 0;
        for(int i:data)
            if(bit &amp; i)
                *num1 ^= i;
            else
                *num2 ^= i;
    }
    
    int diffBit(int res){
        int bit = 1;
        while((bit &amp; res) == 0)
            bit = bit &lt;&lt; 1;
        return bit;
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>数组中只有一个数字只出现了一次，其他数字都出现了两次，我们想到异或运算的一个性质:任何一个数字异 或它自己都等于0。试着把原数组分成两个子数组，使得每个子数组包含一个只出现一次的数字，而其他数字都成对出现两次。<br>
我们还是从头到尾依次异或数组中的每个数字，那么最终得到的结果就是两个只出现一次的数字的异或结果，因为其他数字都出现了两次，在异或中全部抵消了。由于这两个数字肯定不一样，那么异或的结果肯定不为 0,也就是说，在这个结果数字的二进制表示中至少有一位为1。我们在结果数字中找到第一个为1的位的位置，记为第n位。现在我们以第位是不是1为标准把原数组中的数字分成两个子数组，第-个子数组中每个 数字的第n位都是1,而第二个子数组中每个数字的第n位都是0。由于我们分组的标准是数字中的某一位是1还是0, 那么出现了两次的数字肯定被分配到同一个子数组。</p>
</blockquote>
<pre><code>void FindNumsAppearOnce(int data[], int length, int* num1, int* num2)
{
    if(data == nullptr || length &lt; 2)
        return;

    int resultExclusiveOR = 0;
    for(int i = 0; i &lt; length; ++i)
        resultExclusiveOR ^= data[i];

    unsigned int indexOf1 = FindFirstBitIs1(resultExclusiveOR);

    *num1 = *num2 = 0;
    for(int j = 0; j &lt; length; ++j)
    {
        if(IsBit1(data[j], indexOf1))
            *num1 ^= data[j];
        else
            *num2 ^= data[j];
    }
}

// 找到num从右边数起第一个是1的位
unsigned int FindFirstBitIs1(int num)
{
    int indexBit = 0;
    while(((num &amp; 1) == 0) &amp;&amp; (indexBit &lt; 8 * sizeof(int)))
    {
        num = num &gt;&gt; 1;
        ++indexBit;
    }

    return indexBit;
}

// 判断数字num的第indexBit位是不是1
bool IsBit1(int num, unsigned int indexBit)
{
    num = num &gt;&gt; indexBit;
    return (num &amp; 1);
}
</code></pre>
<h3 id="题目二">题目二</h3>
<p>题目描述</p>
<blockquote>
<p>在一个数组中除了一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p>
</blockquote>
<p>书本题解：</p>
<blockquote>
<p>为三个相同的数字的异或结果还是该数字。尽管我们这里不能应用异或运算，我们还是可以沿用位运算的思路。 如果一个数字出现三次，那么它的二进制表示的每一位(0 或者 1) 也出现三次。如果把所有出现三次的数字的二进制表示的每一位都分别加起来，那么每一位的和都能被3整除。<br>
我们把数组中所有数字的二进制表示的每一位都加起来。如果某一位的和能被 3 整除，那么那个只出现一次的数字二进制表示中对应的那一位是 0;否则就是1。</p>
</blockquote>
<pre><code>int FindNumberAppearingOnce(int numbers[], int length)
{
    if(numbers == nullptr || length &lt;= 0)
        throw new std::exception(&quot;Invalid input.&quot;);

    int bitSum[32] = {0};
    for(int i = 0; i &lt; length; ++i)
    {
        int bitMask = 1;
        for(int j = 31; j &gt;= 0; --j)
        {
            int bit = numbers[i] &amp; bitMask;
            if(bit != 0)
                bitSum[j] += 1;

            bitMask = bitMask &lt;&lt; 1;
        }
    }

    int result = 0;
    for(int i = 0; i &lt; 32; ++i)
    {
        result = result &lt;&lt; 1;
        result += bitSum[i] % 3;
    }

    return result;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 题55:二叉树的深度[未做出]]]></title>
        <id>https://lixin-scut.github.io//post/shu-ti-55er-cha-shu-de-shen-du-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/shu-ti-55er-cha-shu-de-shen-du-wei-zuo-chu">
        </link>
        <updated>2020-03-08T23:33:33.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题目一">题目一</h3>
<p>题目描述</p>
<blockquote>
<p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
</blockquote>
<p>我一开始想到的就是递归的先序遍历和迭代的层次遍历<br>
但是书本的题解明显更加简洁</p>
<pre><code>class Solution {
public:
    int TreeDepth(TreeNode* pRoot)
    {
        if(pRoot == nullptr)
            return 0;
        
        int left = TreeDepth(pRoot-&gt;left);
        int right = TreeDepth(pRoot-&gt;right);
        
        return left &gt; right ? left+1 : right+1;
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>我们还可以从另外一个角度来理解树的深度。如果一棵树只有一个节点，那么它的深度为1。如果根节点只有左子树而没有右子树，那么树的深度应该是其 左子树的深度加 1;同样，如果根节点只有右子树而没有左子 树，那么树的深度应该是其右子树的深度加1。如果既有右子树又有左子树, 那么该树的深度就是其左、右子树深度的较大值再加1。<br>
这种思路用递归的方法很容易实现</p>
</blockquote>
<pre><code>int TreeDepth(const BinaryTreeNode* pRoot)
{
    if(pRoot == nullptr)
        return 0;

    int nLeft = TreeDepth(pRoot-&gt;m_pLeft);
    int nRight = TreeDepth(pRoot-&gt;m_pRight);

    return (nLeft &gt; nRight) ? (nLeft + 1) : (nRight + 1);
}
</code></pre>
<h3 id="题目二">题目二</h3>
<p>题目描述</p>
<blockquote>
<p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
</blockquote>
<p>这一题利用了二叉树深度返回int的思想，但是因为主函数必须返回bool，所以重载了函数<br>
然后传引用一个bool记录，顺带可以根据bool的取值提前结束函数。</p>
<pre><code>class Solution {
public:
    bool IsBalanced_Solution(TreeNode* pRoot) {
        if(pRoot == nullptr)
            return true;
        bool flag;
        flag = false;
        IsBalanced_Solution(pRoot,flag);
        return !flag;
    }
    
    int IsBalanced_Solution(TreeNode* curNode,bool&amp; flag){
        if(flag)
            return 0;
        if(curNode == nullptr)
            return 0;
        int nleft = IsBalanced_Solution(curNode-&gt;left,flag);
        int nright = IsBalanced_Solution(curNode-&gt;right,flag);
        flag = (nleft - nright &gt; 1) || (nright - nleft &gt; 1);
        return nleft &gt; nright ? nleft+1 : nright+1 ;
    }
};
</code></pre>
<p>书本题解：<br>
每个节点只遍历一次的解法：如果我们用后序遍历的方式遍历二叉树的每个节点，那么在遍历到一个节点之前我们就已经遍历了它的左、右子树。只要在遍历每个节点的时候记录它的深度(某一节点的深度等于它到叶节点的路径的长度)，我们就可以一边遍历一边判断每个节点是不是平衡的。</p>
<pre><code>bool IsBalanced_Solution2(const BinaryTreeNode* pRoot)
{
    int depth = 0;
    return IsBalanced(pRoot, &amp;depth);
}

bool IsBalanced(const BinaryTreeNode* pRoot, int* pDepth)
{
    if(pRoot == nullptr)
    {
        *pDepth = 0;
        return true;
    }

    int left, right;
    if(IsBalanced(pRoot-&gt;m_pLeft, &amp;left) 
        &amp;&amp; IsBalanced(pRoot-&gt;m_pRight, &amp;right))
    {
        int diff = left - right;
        if(diff &lt;= 1 &amp;&amp; diff &gt;= -1)
        {
            *pDepth = 1 + (left &gt; right ? left : right);
            return true;
        }
    }

    return false;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[学习技巧-分阶段思考与抽象解决方案]]></title>
        <id>https://lixin-scut.github.io//post/xue-xi-ji-qiao-fen-jie-duan-si-kao-yu-chou-xiang-jie-jue-fang-an</id>
        <link href="https://lixin-scut.github.io//post/xue-xi-ji-qiao-fen-jie-duan-si-kao-yu-chou-xiang-jie-jue-fang-an">
        </link>
        <updated>2020-03-08T03:31:53.000Z</updated>
        <content type="html"><![CDATA[<h3 id="分阶段思考">分阶段思考</h3>
<p>  今天在leetcode上做题的时候，我突然想起以前高中时和大学做家教的时候总结了辅导别人的经验：就是不要一下子给出他们答案，而是要一步一步给出答案，引导他们利用已有的条件思考下一步。<br>
  然鹅现在倒发现自己忘了应用这个经验和方法hhh，果然还是得多总结经验。<br>
举个例子：<br>
  做题的时候如果遇到了完全不懂的题，在看leetcode题解的时候也适合这样<br>
  首先一段一段地看，利用当前给到的已用提示，看看能不能自己思考出下一步<br>
  不要急于看完整个题解，不断地让自己去思考不同的解决方法，不断地活络思路，这样子才能理解得更深，记得更牢。</p>
<h3 id="抽象解决方案">抽象解决方案</h3>
<p>另外一个感想就是对算法的总结<br>
  现在做的题不多也不少，昨天和大神们讨论题目的时候发现别人很善于总结题目，并且寻找这个题目解法后面的算法思想<br>
  比如找出数组中出现次数超过一半的数字，我知道是利用count不断地加减，但是却不知道抽象出来的算法是投票算法，相当于每个数字有投票权，那么一次循环就等于让大家投票，票数最多的就是结果。<br>
  这个投票算法适用于数字数目有明显差别的时候。<br>
  所以抽象出这个算法思想后就能灵活应用到其他题目中<br>
我永远不可能做完所有题目，掌握思想才是最重要的</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GDB调试]]></title>
        <id>https://lixin-scut.github.io//post/gdb-diao-shi</id>
        <link href="https://lixin-scut.github.io//post/gdb-diao-shi">
        </link>
        <updated>2020-03-08T03:10:16.000Z</updated>
        <content type="html"><![CDATA[<p>  今天在做题的时候发现测试用例的输出和结果对不上<br>
  为了节省电脑资源，我没有在Clion上debug（已经开了很多pdf了），而是特地到ubuntu中去学习了GDB的调试方法<br>
  上一次使用GDB是<a href="https://lixin-scut.github.io/post/coredump-yu-gdb-diao-shi/">coreDump 与GDB调试</a>，专门针对coreDump的情况。<br>
但是这次不同，程序能够正确运行，只是因为逻辑不对造成输出不对，并不会产生coreDump这种极端情况，也不需要强行产生coreDump</p>
<p>一般来说，GDB主要帮忙你完成下面四个方面的功能：</p>
<ol>
<li>启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。</li>
<li>可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）</li>
<li>当程序被停住时，可以检查此时你的程序中的变量值、函数栈和所发生的事。</li>
<li>动态的改变你程序的执行环境。</li>
</ol>
<p>下面就是GDB调试的过程</p>
<p>准备工作：</p>
<ol>
<li>
<p>编译<br>
首先源代码不需要任何改动，只是编译时必须带上-g选项<br>
<code>g++ gdbTest.cc -g -o test</code></p>
</li>
<li>
<p>用GDB打开可运行文件<br>
<code>gdb test</code></p>
</li>
<li>
<p>显示源码<br>
  不知道为什么直接list(l)出来的结果不对，必须在list后面加上行数，然后可以直接list，GDB会自动显示后续的行<br>
同时如果直接在命令行回车的话会自动重复上次的命令</p>
</li>
</ol>
<pre><code>(gdb) list  &lt;-------------------- l命令相当于list，但是我的ubuntu并不能得到想要的结果。 
40			for(int i : nums)
41			{	cout &lt;&lt; i &lt;&lt; &quot; &quot;; }
42			cout &lt;&lt; &quot;\n&quot; ;
43		}
44	};
45	
46	void Test1()
47	{
48		vector&lt;int&gt; data{ 0, 1 };
49		Solution solution;
(gdb) list 1 &lt;-------------------- 从第一行开始例出原码。 
1	// gdbTest.cc
2	// Created by Lixin on 2020.03.08
3	
4	#include &lt;bits/stdc++.h&gt;
5	using namespace std;
6	
7	class Solution {
8	public:
9	    void sortColors(vector&lt;int&gt;&amp; nums) {
10	        print(nums);
(gdb) l &lt;-------------------- l命令相当于list的简写
11			size_t length = nums.size();
12	        if(length &lt; 1)
13	            return;
14	        int left;
15	        int right;
16	        int curNum;
17	        left = 0;
18	        right = length - 1;
19	        curNum = 1;
20	        for(; curNum &lt; right; ++curNum)
(gdb)  &lt;-------------------- 直接回车表示，重复上一次命令 
21	        {
22	            if(nums[curNum] &lt; nums[left])
23	            {
24	                swap(nums[curNum], nums[left]);
25	                if(nums[left] == 0)
26	                {   ++left; }
27	            }
28	            if(nums[curNum] &gt; nums[right])
29	            {
30	                swap(nums[curNum], nums[right]);
(gdb)  &lt;-------------------- 直接回车表示，重复上一次命令 
31	                if(nums[right] == 2)
32	                {   --right; }
33	            }
34	        }
35			print(nums);
36	    }
37	private:
38		void print(vector&lt;int&gt; &amp;nums) const
39		{
40			for(int i : nums)
</code></pre>
<ol start="4">
<li>设置断点<br>
断点就和Clion中debug的一样，会在此处执行前停下。</li>
</ol>
<pre><code>(gdb) break 22 &lt;-------------------- 设置第22行断点 break简写为b
Breakpoint 1 at 0xc87: file gdbTest.cc, line 22.
(gdb) break 26
Breakpoint 2 at 0xd16: file gdbTest.cc, line 26.
(gdb) break 28
Breakpoint 3 at 0xd1a: file gdbTest.cc, line 28.
(gdb) break 32
Breakpoint 4 at 0xdaa: file gdbTest.cc, line 32.
(gdb) info break &lt;-------------------- 查看断点信息
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x0000000000000c87 in Solution::sortColors(std::vector&lt;int, std::allocator&lt;int&gt; &gt;&amp;) at gdbTest.cc:22
2       breakpoint     keep y   0x0000000000000d16 in Solution::sortColors(std::vector&lt;int, std::allocator&lt;int&gt; &gt;&amp;) at gdbTest.cc:26
3       breakpoint     keep y   0x0000000000000d1a in Solution::sortColors(std::vector&lt;int, std::allocator&lt;int&gt; &gt;&amp;) at gdbTest.cc:28
4       breakpoint     keep y   0x0000000000000daa in Solution::sortColors(std::vector&lt;int, std::allocator&lt;int&gt; &gt;&amp;) at gdbTest.cc:32
(gdb) delete 4 &lt;-------------------- 删除断点，注意，delete后面跟的是断点序号而不是行数
</code></pre>
<ol start="5">
<li>运行程序中的命令</li>
</ol>
<pre><code>(gdb) run &lt;--------------------- 运行程序，run命令简写为r 
(gdb) next &lt;--------------------- 单条语句执行，next命令简写n。
(gdb) continue &lt;--------------------- 继续运行程序，continue命令简写c。 
(gdb) print nums &lt;--------------------- 打印变量nums的值，print命令简写p，注意可以打印数组
(gdb) bt &lt;--------------------- 查看函数堆栈。
0 0 2 1 1 2 &lt;----------程序输出。 
[Inferior 1 (process 9168) exited normally]  &lt;--------程序退出，调试结束。
(gdb) q &lt;--------------------- 退出gdb
</code></pre>
<p>参考博客<a href="https://www.cnblogs.com/mfryf/p/5390442.html">比较全面的gdb调试命令</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[快速排序 partition ]]></title>
        <id>https://lixin-scut.github.io//post/kuai-su-pai-xu-partition</id>
        <link href="https://lixin-scut.github.io//post/kuai-su-pai-xu-partition">
        </link>
        <updated>2020-03-08T03:03:39.000Z</updated>
        <content type="html"><![CDATA[<p>做对这道题<a href="https://lixin-scut.github.io/post/shu-zu-75yan-se-fen-lei-zhong-deng-wei-zuo-chu/">数组 75:颜色分类</a>需要熟悉快速排序的 partition 过程。</p>
<p>partition 过程经过一次扫描把整个数组分成三个部分，正好符合这个问题的场景</p>
<p>循环不变量是这样定义的：</p>
<blockquote>
<p>所有在子区间 [0, zero) 的元素都等于 0；<br>
所有在子区间 [zero, i) 的元素都等于 1；<br>
所有在子区间 [two, len - 1] 的元素都等于 2。<br>
说明：设计循环不变量的原则是“不重不漏”。</p>
</blockquote>
<p>1、len 是数组的长度；<br>
2、变量 zero 是前两个子区间的分界点，一个是闭区间，另一个就必须是开区间；<br>
3、变量 i 是循环变量，一般设置为开区间，表示 i 之前的元素是遍历过的；<br>
4、two 是另一个分界线，设计成闭区间。</p>
<p>于是代码要解决以下三个问题：</p>
<ol>
<li>变量初始化应该如何定义。</li>
<li>在遍历的时候，是先加减还是先交换。</li>
<li>什么时候循环终止。</li>
</ol>
<p>处理这三个问题，完全看循环不变量的定义。</p>
<p>编程的时候，zero 和 two 初始化的值就应该保证上面的三个子区间全为空。<br>
在遍历的过程中，“索引先加减再交换”、还是“先交换再加减”就看初始化的时候变量在哪里。<br>
退出循环的条件也看上面定义的循环不变量，在 i == two 成立的时候，上面的三个子区间就正好“不重不漏”地覆盖了整个数组，并且给出的性质成立，题目的任务也就完成了。</p>
<p>体会是：<br>
编码者应该在代码中使用注释表达这段代码编写的算法思想，提醒自己也方便他人。<br>
但是源代码中类似 ++k &lt;= great 和 a[++left] &gt;= a[left - 1] 这样的代码建议不要写，会给阅读者带来理解上的障碍，变量的值发生变化是一个很重要的逻辑，应该单独成为一行，否则不利于调试和以后定位问题。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 75:颜色分类[中等][未做出]]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-75yan-se-fen-lei-zhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-75yan-se-fen-lei-zhong-deng-wei-zuo-chu">
        </link>
        <updated>2020-03-08T02:52:32.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。<br>
此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。<br>
注意:<br>
不能使用代码库中的排序函数来解决这道题。<br>
示例:<br>
输入: [2,0,2,1,1,0]<br>
输出: [0,0,1,1,2,2]<br>
进阶：<br>
一个直观的解决方案是使用计数排序的两趟扫描算法。<br>
首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。<br>
你能想出一个仅使用常数空间的一趟扫描算法吗？<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/sort-colors<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题是腾讯的面试题之一<br>
然后我一开始的想法也是三指针partition，left和right分别管理0的区域和2的区域，然后curNum管理当前值。<br>
但是一开始我使用的是比较法，没有充分利用数字取值范围的特点（只有0，1，2），所以导致漏掉了很多情况，并且必须无限循环保证从交换回来的数字需要多次swap的情况能够正常运行。<br>
最后还是参考了官网题解，发现确实是三分法，但是需要利用好数值这个特性，并且重点是什么时候需要++curNum什么时候不需要！</p>
<p>最后我的代码：</p>
<pre><code>class Solution {
public:
    void sortColors(vector&lt;int&gt;&amp; nums) {
        size_t length = nums.size();
        if(length &lt; 1)
            return;
        int left;
        int right;
        int curNum;
        left = 0;
        right = length - 1;
        curNum = 0;
        while(curNum &lt;= right)
        {
            switch(nums[curNum])
            {
                case 0:
                    swap(nums[left], nums[curNum]);
                    ++left;
                    ++curNum;
                    break;
                case 1:
                    ++curNum;
                    break;
                case 2:
                    swap(nums[right], nums[curNum]);
                    --right;
                    break;
            }
        }
    }
};
</code></pre>
<p>官网题解：</p>
<blockquote>
<p>方法一: 一次遍历<br>
我们用三个指针（p0, p2 和curr）来分别追踪0的最右边界，2的最左边界和当前考虑的元素。<br>
<img src="https://lixin-scut.github.io//post-images/1583636318887.png" alt=""><br>
本解法的思路是沿着数组移动 curr 指针，若nums[curr] = 0，则将其与 nums[p0]互换；若 nums[curr] = 2 ，则与 nums[p2]互换。<br>
算法<br>
初始化0的最右边界：p0 = 0。在整个算法执行过程中 nums[idx &lt; p0] = 0.<br>
初始化2的最左边界 ：p2 = n - 1。在整个算法执行过程中 nums[idx &gt; p2] = 2.<br>
初始化当前考虑的元素序号 ：curr = 0.<br>
While curr &lt;= p2 :<br>
若 nums[curr] = 0 ：交换第 curr个 和 第p0个 元素，并将指针都向右移。<br>
若 nums[curr] = 2 ：交换第 curr个和第 p2个元素，并将 p2指针左移 。<br>
若 nums[curr] = 1 ：将指针curr右移。</p>
</blockquote>
<pre><code>class Solution {
  public:
  /*
  荷兰三色旗问题解
  */
  void sortColors(vector&lt;int&gt;&amp; nums) {
    // 对于所有 idx &lt; p0 : nums[idx &lt; p0] = 0
    // curr 是当前考虑元素的下标
    int p0 = 0, curr = 0;
    // 对于所有 idx &gt; p2 : nums[idx &gt; p2] = 2
    int p2 = nums.size() - 1;

    while (curr &lt;= p2) {
      if (nums[curr] == 0) {
        swap(nums[curr++], nums[p0++]);
      }
      else if (nums[curr] == 2) {
        swap(nums[curr], nums[p2--]);
      }
      else curr++;
    }
  }
};

作者：LeetCode
链接：https://leetcode-cn.com/problems/sort-colors/solution/yan-se-fen-lei-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<p>另外一个介绍partition的题解<a href="https://leetcode-cn.com/problems/sort-colors/solution/kuai-su-pai-xu-partition-guo-cheng-she-ji-xun-huan/">快速排序 partition 过程</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 题54:二叉搜索树的第k个结点]]></title>
        <id>https://lixin-scut.github.io//post/shu-ti-54er-cha-sou-suo-shu-de-di-k-ge-jie-dian</id>
        <link href="https://lixin-scut.github.io//post/shu-ti-54er-cha-sou-suo-shu-de-di-k-ge-jie-dian">
        </link>
        <updated>2020-03-08T00:42:30.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。</p>
</blockquote>
<pre><code>/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};
*/
</code></pre>
<p>【未做出】<br>
没什么特别的，就是复习一下迭代中序遍历吧<br>
尴尬，还是没做出，主要是就是卡在右子树的进栈那里了，通过右子树和进出栈配合从而保证左子树不会重复入栈</p>
<pre><code>class Solution {
public:
    TreeNode* KthNode(TreeNode* pRoot, int k)
    {
        if(k&lt;=0 || pRoot == NULL)
            return NULL;
        stack&lt;TreeNode*&gt; nodeStack;
        TreeNode* curNode;
        curNode = pRoot;
        while(curNode||nodeStack.size())
        {
            while(curNode){
                nodeStack.push(curNode);
                curNode = curNode-&gt;left;
            }
            curNode = nodeStack.top();
            nodeStack.pop();
            --k;
            if(k==0)
                return curNode;
            curNode = curNode-&gt;right;
        }
        return NULL;
    }
};
</code></pre>
<p>书本题解：<br>
如果按照中序遍历的顺序遍历一棵二叉搜索树，则遍历序列的数值是递增排序的。</p>
<pre><code>const BinaryTreeNode* KthNode(const BinaryTreeNode* pRoot, unsigned int k)
{
    if(pRoot == nullptr || k == 0)
        return nullptr;

    return KthNodeCore(pRoot, k);
}

const BinaryTreeNode* KthNodeCore(const BinaryTreeNode* pRoot, unsigned int&amp; k)
{
    const BinaryTreeNode* target = nullptr;

    if(pRoot-&gt;m_pLeft != nullptr)
        target = KthNodeCore(pRoot-&gt;m_pLeft, k);

    if(target == nullptr)
    {
        if(k == 1)
            target = pRoot;

        k--;
    }

    if(target == nullptr &amp;&amp; pRoot-&gt;m_pRight != nullptr)
        target = KthNodeCore(pRoot-&gt;m_pRight, k);

    return target;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 题53:在排序数组中查找数字]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-ti-53zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-ti-53zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi">
        </link>
        <updated>2020-03-08T00:19:27.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题目一">题目一</h3>
<p>描述</p>
<blockquote>
<p>统计一个数字在排序数组中出现的次数。</p>
</blockquote>
<p>暴力法就是循环，时间复杂度是O(n),空间复杂度O(1)，所以优化方向自然是O(logn)了<br>
那自然也就二分法啦hhh，第一想法就是第一次二分找到最右的n，第二次二分找到最左的n，两者的位置相减就得到结果<br>
难点：当第一个元素或者最后一个元素是K时，必须正确返回位置，当数组不存在K时，返回的位置应该一致<br>
所以一定要注意两个函数的mid取值</p>
<p>然后发现（当数组不存在K时，返回的位置应该一致）是错误的，比如[3,4,6,7]中找5，就会返回4和6的位置，这时必须加上判断是否等于k才行，<br>
边缘情况同理，不能简单地right-left+1，否则会返回1</p>
<pre><code>class Solution {
public:
    int GetNumberOfK(vector&lt;int&gt; data ,int k) {
        if(data.empty())
            return 0;
        int left=GetLeftK(data ,k,0,data.size()-1);
        int right=GetRightK(data ,k,0,data.size()-1);
        if(data[left]!=k)
            return 0;
        return right-left+1;
    }
    
    int GetRightK(vector&lt;int&gt; &amp;data ,int k,int beg,int end){
        if(beg==end)
            return beg;
        int mid=beg+(end-beg+1)/2;
        if(data[mid]&lt;=k)
            return GetRightK(data,k,mid,end);
        else if(data[mid]&gt;k)
            return GetRightK(data,k,beg,mid-1);
    }
    int GetLeftK(vector&lt;int&gt; &amp;data ,int k,int beg,int end){
        if(beg==end)
            return beg;
        int mid=beg+(end-beg)/2;
        if(data[mid]&gt;=k)
            return GetLeftK(data,k,beg,mid);
        else if(data[mid]&lt;k)
            return GetLeftK(data,k,mid+1,end);
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>  先分析如何用二分查找算法在数组中找到第一个k，二分查找算法总是先拿数组中间的数字和k作比较。如果中间的数字比k大，那么k只有可能出现在数组的前半段，下一轮我们只在数组的前半段查找就可以 了。如果中间的数字比左小，那么比 只有可能出现在数组的后半段，下一 轮我们只在数组的后半段查找就可以了。如果中间的数字和 k 相等呢?我 们先判断这个数字是不是第一个 k，如果中间数字的前面一个 数字不是 k,，那么此时中间的数字刚好就是第一个 k。如果中间数字的前面一个数字也是 k,那么第一个k肯定在数组的前半段，下一轮我们仍然需要在数组的前半段查找。<br>
  我们可以用同样的思路在排序数组中找到最后一个k，如果中间数字比 k大，那 么k只能出现在数组的前半段。如果中间数字比 k 小，那么k只能出现在数组的后半段。如果中间数字等于 k 呢?我们需要判断这个 k 是不是最后一个k，也就是中间数字的下一个数字是不是也等于k，如果下一个数字不是则中间数字就是最后一个k，否则下一轮我们还是要在数组的后 段中去查找。</p>
</blockquote>
<pre><code>int GetNumberOfK(const int* data, int length, int k)
{
    int number = 0;

    if(data != nullptr &amp;&amp; length &gt; 0)
    {
        int first = GetFirstK(data, length, k, 0, length - 1);
        int last = GetLastK(data, length, k, 0, length - 1);
        
        if(first &gt; -1 &amp;&amp; last &gt; -1)
            number = last - first + 1;
    }

    return number;
}

// 找到数组中第一个k的下标。如果数组中不存在k，返回-1
int GetFirstK(const int* data, int length, int k, int start, int end)
{
    if(start &gt; end)
        return -1;

    int middleIndex = (start + end) / 2;
    int middleData = data[middleIndex];

    if(middleData == k)
    {
        if((middleIndex &gt; 0 &amp;&amp; data[middleIndex - 1] != k) 
            || middleIndex == 0)
            return middleIndex;
        else
            end  = middleIndex - 1;
    }
    else if(middleData &gt; k)
        end = middleIndex - 1;
    else
        start = middleIndex + 1;

    return GetFirstK(data, length, k, start, end);
}

// 找到数组中最后一个k的下标。如果数组中不存在k，返回-1
int GetLastK(const int* data, int length, int k, int start, int end)
{
    if(start &gt; end)
        return -1;

    int middleIndex = (start + end) / 2;
    int middleData = data[middleIndex];

    if(middleData == k)
    {
        if((middleIndex &lt; length - 1 &amp;&amp; data[middleIndex + 1] != k) 
            || middleIndex == length - 1)
            return middleIndex;
        else
            start  = middleIndex + 1;
    }
    else if(middleData &lt; k)
        start = middleIndex + 1;
    else
        end = middleIndex - 1;

    return GetLastK(data, length, k, start, end);
}

</code></pre>
<blockquote>
<p>  在上述代码中，GetFirstK和GetLastK都是用二分查找算法在数组中查找一个合 乎要求的数字的，它们的时间复杂度都是 O(logn),因此 GetNuniberOfK的总的时间复杂度也只有O(logn)</p>
</blockquote>
<h3 id="题目二">题目二</h3>
<p>描述</p>
<blockquote>
<p>题目：一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0到n-1之内。在范围0到n-1的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
</blockquote>
<p>书本题解：<br>
  这个问题有一个直观的解决方案。我们可以先用公式n(n-1)/2求出数字0〜n-1的 所有数字之和，记为 s1。接着求出数组中所有数字的和，记为S2。那个不在数组中 的数字就是s1-s2的差。这种解法需要O(n)的时间求数组中所有数字的和。显然， 该解法没有有效利用数组是递增排序的这一特点。<br>
因为 0〜n-1 这些数字在数组中是排序的，因此数组中开始的一些数字与它们的下标相同。<br>
  由于m不在数组中，那么 m+1 处在下标为 m 的位置，m+2 处在下标为 m+1 的位置，以此类推。我们发现也正好是数组中第一个数值和下标不相等的下标，因此这 个问题转换成在排序数组中找出第一个值和下标不相等的元素。<br>
  我们可以基于二分查找的算法用如下过程查找:如果中间元素的值和 标相等， 那么下一轮查找只需要查找右半边;如果中间元素的值和下标不相等，并且它前面 一个元素和它的下标相等，这意味着这个中间的数字正好是第一个值和下标不相等的元素，它的下标就是在数组中不存在的数字;如果中间元素的值和下标不相等， 并且它前面一个元素和它的下标不相等，这意味着下一轮查找我们只需要在左半边查找即可。</p>
<pre><code>int GetMissingNumber(const int* numbers, int length)
{
    if(numbers == nullptr || length &lt;= 0)
        return -1;

    int left = 0;
    int right = length - 1;
    while(left &lt;= right)
    {
        int middle = (right + left) &gt;&gt; 1;
        if(numbers[middle] != middle)
        {
            if(middle == 0 || numbers[middle - 1] == middle - 1)
                return middle;
            right = middle - 1;
        }
        else
            left = middle + 1;
    }

    if(left == length)
        return length;

    // 无效的输入，比如数组不是按要求排序的，
    // 或者有数字不在0到n-1范围之内
    return -1;
}
</code></pre>
<h3 id="题目三">题目三</h3>
<p>描述</p>
<blockquote>
<p>假设一个单调递增的数组里的每个元素都是整数并且是唯一的。请编程实现一个函数找出数组中任意一个数值等于其下标的元素。例如，在数组{-3, -1,1, 3, 5}中，数字3和它的下标相等。</p>
</blockquote>
<p>题目描述<br>
从头到尾依次扫描数组中的数字， 并逐一检验数字是不是和下标相等。显然，这种算法的时间复杂度是O(n)。<br>
由于数组是单调递增排序的，因此我们可以尝试用二分查找算法来进行优化。<br>
假设数字的值为m。我们先考虑m大于i的情形，即数字的值大于它的下标。由于数组中的所有数字都唯一并且单调递增，那么对于任意大于0的如位于下标i+k的数字的值大于或等于m+k. 另外，因为 m&gt;i,所以,m+k &gt; i+k因此，位于下标 i+k 的数字的值一定大于它的下标。这意味着如果第 i 个数字的值大于i,那么它右边的数字都大于对应的下标，我们都可以忽略。下一轮查找我们只需要从它左边的数字中查找即可。<br>
数字的值小于它的下标 i 的情形和上面类似。</p>
<pre><code>int GetNumberSameAsIndex(const int* numbers, int length)
{
    if(numbers == nullptr || length &lt;= 0)
        return -1;

    int left = 0;
    int right = length - 1;
    while(left &lt;= right)
    {
        int middle = left + ((right - left) &gt;&gt; 1);
        if(numbers[middle] == middle)
            return middle;

        if(numbers[middle] &gt; middle)
            right = middle - 1;
        else
            left = middle + 1;
    }

    return -1;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[洗牌shuffle 384. 打乱数组]]></title>
        <id>https://lixin-scut.github.io//post/xi-pai-shuffle-384-da-luan-shu-zu</id>
        <link href="https://lixin-scut.github.io//post/xi-pai-shuffle-384-da-luan-shu-zu">
        </link>
        <updated>2020-03-07T03:01:12.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>打乱一个没有重复元素的数组。<br>
示例:<br>
// 以数字集合 1, 2 和 3 初始化数组。<br>
int[] nums = {1,2,3};<br>
Solution solution = new Solution(nums);<br>
// 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。<br>
solution.shuffle();<br>
// 重设数组到它的初始状态[1,2,3]。<br>
solution.reset();<br>
// 随机返回数组[1,2,3]打乱后的结果。<br>
solution.shuffle();<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/shuffle-an-array<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题其实就是针对洗牌算法而设，但是注意虽然主要功能是随机函数，但是我们的重点是实现随机函数，而是通过随机函数生成的随机数的实现打乱效果。<br>
这次的重点就是 学习C++自带的随机数生成 和 shuffle打乱洗牌算法</p>
<pre><code>class Solution {
public:
    Solution(vector&lt;int&gt;&amp; nums) {
        origNums = nums;
    }
    
    /** Resets the array to its original configuration and return it. */
    vector&lt;int&gt; reset() {
        return origNums;
    }
    
    
    /** Returns a random shuffling of the array. */
    /*
		// 取余法
    vector&lt;int&gt; shuffle() 
    {
        randNums = reset();
        int length = origNums.size();

        for(int cur = 0 ; cur &lt; length ; ++cur)
        {
            int randNum = rand() % (length - cur) + cur;
            swap(randNums[cur], randNums[randNum]);
        }
        
        return randNums;
    }
    */
    
		// 划定随机数范围 
    vector&lt;int&gt; shuffle() {
        randNums = reset();
        int length = origNums.size();
        // default_random_engine num;  //是不能放在这里的，否则每次调用都会重新定义
        for(int cur = 0; cur &lt; length; ++cur)
        {
            uniform_int_distribution&lt;unsigned&gt; num(cur,length-1);
            swap(randNums[cur], randNums[num(rand)]);
        }
        return randNums;
    }
    

private:
    default_random_engine rand; // 重点 得把随机引擎放在外面
    vector&lt;int&gt; randNums;
    vector&lt;int&gt; origNums;
};

/**
 * Your Solution object will be instantiated and called as such:
 * Solution* obj = new Solution(nums);
 * vector&lt;int&gt; param_1 = obj-&gt;reset();
 * vector&lt;int&gt; param_2 = obj-&gt;shuffle();
 */
</code></pre>
<p>可以看到实现还是很简单的，主要还是将排列组合的概率论思想转化为循环<br>
然后细节就是C++的随机数生成<br>
1.注意随机引擎不能每次都初始化，除非额外确定随机种子，否则必须保持只有一个随机引擎<br>
2.注意取余的除数选择，以及随机数范围的选择</p>
<p>网友题解：<br>
同样是比较长的网友题解，我就不画蛇添足了<br>
<a href="https://leetcode-cn.com/problems/shuffle-an-array/solution/xi-pai-suan-fa-shen-du-xiang-jie-by-labuladong/">洗牌算法深度详解</a></p>
<p>洗牌算法</p>
<p>此类算法都是靠随机选取元素交换来获取随机性，直接看代码（伪码），该算法有 4 种形式，都是正确的：</p>
<pre><code>// 得到一个在闭区间 [min, max] 内的随机整数
int randInt(int min, int max);

// 第一种写法
void shuffle(int[] arr) {
    int n = arr.length();
    /******** 区别只有这两行 ********/
    for (int i = 0 ; i &lt; n; i++) {
        // 从 i 到最后随机选一个元素
        int rand = randInt(i, n - 1);
        /*************************/
        swap(arr[i], arr[rand]);
    }
}

// 第二种写法
    for (int i = 0 ; i &lt; n - 1; i++)
        int rand = randInt(i, n - 1);

// 第三种写法
    for (int i = n - 1 ; i &gt;= 0; i--)
        int rand = randInt(0, i);

// 第四种写法
    for (int i = n - 1 ; i &gt; 0; i--)
        int rand = randInt(0, i);
</code></pre>
<blockquote>
<p>假设数组有五个元素，我们先用这个准则分析一下第一种写法的正确性：<br>
for 循环第一轮迭代时，i = 0，rand 的取值范围是 [0, 4]，有 5 个可能的取值。<br>
for 循环第二轮迭代时，i = 1，rand 的取值范围是 [1, 4]，有 4 个可能的取值。<br>
后面以此类推，直到最后一次迭代，i = 4，rand 的取值范围是 [4, 4]，只有 1 个可能的取值。<br>
可以看到，整个过程产生的所有可能结果有<code>n! = 5! = 5*4*3*2*1</code>种，所以这个算法是正确的。<br>
分析第二种写法，前面的迭代都是一样的，少了一次迭代而已。所以最后一次迭代时 i = 3，rand 的取值范围是 [3, 4]，有 2 个可能的取值。<br>
所以整个过程产生的所有可能结果仍然有<code>5*4*3*2 = 5! = n!</code>种，因为乘以 1 可有可无嘛。所以这种写法也是正确的。<br>
如果以上内容你都能理解，那么你就能发现第三种写法就是第一种写法，只是将数组从后往前迭代而已；第四种写法是第二种写法从后往前来。所以它们都是正确的。</p>
</blockquote>
]]></content>
    </entry>
</feed>