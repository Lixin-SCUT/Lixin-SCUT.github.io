<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-11-11T15:05:46.183Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[ C++ primer 第十五章 笔记+习题 15.1-15.5]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-wu-zhang-bi-ji-xi-ti-151-155</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-wu-zhang-bi-ji-xi-ti-151-155">
        </link>
        <updated>2019-11-11T02:43:17.000Z</updated>
        <content type="html"><![CDATA[<p>15.1 oop：概述<br>
面向对象程序设计（object-orientedprogramming )的<strong>核心思想</strong>是<strong>数据抽象</strong><br>
通过<strong>继承( inheritance )</strong> 联系在一起的类构成一种层次关系。通常在层次关系的根部有一个基类 （baseclass ),其他类则直接或间接地从基类继承而来，这些继承得到的类称为派生类 （derivedclass )。<strong>基类</strong>负责定义在层次关系中所有类<strong>共同拥有的成员</strong>，而每个<strong>派生类</strong>定义各自<strong>特有的成员</strong>。<br>
对于某些函数，<strong>基类</strong>希望它的<strong>派生类各自定义</strong>适合自身的版本，此时基类就将这些函数声明成<strong>虚函数 (virtualfunction)</strong></p>
<p>派生类必须通过使用<strong>类派生列表</strong>（classderivationlist )明确指出它是<strong>从哪个（哪些）基类继承而来的。</strong><br>
类派生列表的形式是：首先是一个冒号，后面紧跟<strong>以逗号分隔</strong>的基类列表，其中每个基类前面可以有访问说明符：</p>
<p>因为 Bulk_quote 在它的派生列表中使用了 <strong>public 关键字</strong>，因此我们完全可以把Bulk _ quote 的对象<strong>当成 Quote 的对象</strong>来使用</p>
<p>派生类必须在其内部对所有重新定义的<strong>虚函数进行声明</strong>。派生类可以在这样的函数之前加上 virtual 关键字.但是并不是非得这么做。<br>
出于15.3节（第538页）将要解释的原因， C ++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，具体措施是在该函数的<strong>形参列表</strong>之后增加一个<strong>override 关键字</strong>。<br>
通过使用<strong>动态绑定（dynamicbinding )</strong> , 我们能用<strong>同一段代码</strong>分别处理 Quote 和Bulkjuote 的对象<br>
上述过程中函数的<strong>运行版本</strong>由<strong>实参</strong>决定，即在<strong>运行时选择函数的版本</strong>，所以动态绑定有时又被称为<strong>运行时绑定（ run-timebinding )</strong>。<br>
在C++语言中，当我们<strong>使用基类的引用（或指针）调用一个虚函数时将发生动态绑定</strong>。</p>
<p>15.2 定义基类和派生类<br>
15.2.1定义基类<br>
作为继承关系中<strong>根节点</strong>的<strong>类</strong>通常都会定义一个<strong>虚析构函数</strong>。<br>
<strong>基类</strong>通常都应该定义一个<strong>虚析构函数</strong>，即使该函数不执行任何实际操作也是如此。<br>
遇到<strong>与类型相关的操作</strong>时，派生类必须对其重新定义。换句话说，派生类需要对这些操作提供自己的新定义以覆盖( override )从基类继承而来的旧定义。<br>
<strong>基类</strong>必须将它的<strong>两种成员函数</strong>区分开来：一种是基类<strong>希望其派生类进行覆盖</strong>的函数；另一种是基类希望派生类<strong>直接维承而不要改变</strong>的函数。对于<strong>前者</strong>，基类通常将其定义为<strong>虚函数</strong>（ virtual )。<br>
基类通过在其成员函数的声明语句之前加上<strong>关键字virtual</strong>使得该函数执行<strong>动态绑定</strong>。任何<strong>构造函数之外</strong>的<strong>非静态函数</strong>都可以是<strong>虚函数</strong>。<strong>关键字virtual</strong>只能出现在<strong>类内部的声明语句</strong>之前而<strong>不能用于类外部的函数定义</strong>。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。<br>
成员函数如果没被声明为虚函数，则其解析过程发生在编译时而非运行时。</p>
<p><strong>派生类</strong>无法访问<strong>基类的私有成员</strong><br>
派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类<br>
继承而来的成员。和其他使用基类的代码一样.派生类能访问公有成员，而不能访问私有成员。<br>
不过在某些时候基类中还有这样一种成员，<strong>基类</strong>希望它的<strong>派生类有权访问</strong>该成员，同时<strong>禁止其他用户访问</strong>。我們用<strong>受保护的（protected )访问运算符</strong>说明这样的成员。</p>
<pre><code>class Quote {
public:
	Quote() = default;
	Quote(const string &amp;book,double sales_price):bookNo(book),price(sales_price){}
	string isbn() const { return bookNo;}
	virtual double net_price(size_t n)const { return n*price; }
	virtual ~Quote()=default;
private:
	string bookNo;
protected:
	double price = 0.0;
};

double print_total(ostream &amp;os, const Quote &amp;item, size_t n)
{
	double ret = item.net_price(n);
	os &lt;&lt; &quot;ISBN:&quot; &lt;&lt; item.isbn() &lt;&lt; &quot;#sold:&quot; &lt;&lt; n &lt;&lt; &quot;total due:&quot; &lt;&lt; ret &lt;&lt; endl;
	return ret;
}
</code></pre>
<p>习题15.1<br>
也就是虚函数，基类<strong>希望其派生类进行覆盖</strong>的函数，。任何<strong>构造函数之外</strong>的<strong>非静态函数</strong>都可以是<strong>虚函数</strong>。<br>
习题15.2<br>
基类的private成员不能被派生类和其他用户访问，protected成员不能被其他用户访问，但可以被派生类访问<br>
习题15.3</p>
<p>15.2.2 定义派生类<br>
派生类必须通过使用<strong>类派生列表（class derivation list )</strong> 明确指出它是从哪个（哪些）基类继承而来的。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中<strong>每个基类前面</strong>可以有以下三种访问说明符中的一个；<strong>public 、protected 或者private</strong>。<br>
访问说明符的作用是<strong>控制派生类从基类维承而来的成员是否对派生类的用户可见</strong>。<br>
如果一个<strong>派生是公有</strong>的，则<strong>基类的公有成员</strong>也是<strong>派生类接口的组成部分</strong>。此外，我们能将<strong>公有派生类型的对象绑定到基类的引用或指针上</strong>。<br>
大多数类都只继承自一个类，这种形式的维承被称作&quot;单继承&quot;，</p>
<p>如果派生类<strong>没有覆盖</strong>其基类中的某个<strong>虚函数</strong>，则该虚函数的行为类似于其他的普通成员，派生类会<strong>直接维承其在基类中的版本</strong>。<br>
派生类可以在它覆盖的函数前使用 virtual 关键字，单不是非得这么做。<br>
C ++11新标准允许派生类<strong>显式地注明</strong>它使用某个成员函数<strong>覆盖了它维承的虚函数</strong>。具体做法是在形参列表后面、或者在 const 成员函数（参见7。1.2节，第231页）的 <strong>const 关键字</strong>后面、或者在引用成员函数（参见13.6.3节，第483页）的<strong>引用限定符后面</strong>添加一个关键字 <strong>override</strong> 。<br>
因为在<strong>派生类对象中</strong>含有与其<strong>基类对应的组成部分</strong>，所以我们能把<strong>派生类的对象</strong>当成<strong>基类对象</strong>来使用，而且我们也能将<strong>基类的指针或引用</strong>绑定到<strong>派生类对象中的基类部分</strong>上</p>
<p>这种转换通常称为<strong>派生类到基类的（ derived - to - base )类型转换</strong>。和其他类型转换一样，编译器会<strong>隐式地执行</strong>派生类到基类的转换（参见4.11节，第141页）。<br>
这种隐式特性意味着我们可以把<strong>派生类对象或者派生类对象的引用</strong>用在<strong>需要基类引用的地方</strong>；同样的，我们也可以把派生类对象的<strong>指针</strong>用在需要基类指针的地方。<br>
尽管在派生类对象中含有从基类继承而来的成员，但是派生类并<strong>不能直接初始化</strong>这些成员。和其他创建了基类对象的代码一样，<strong>派生类也必须使用基类的构造函数</strong>来初始化它的基类部分。<br>
每个类控制<strong>它自己的成员初始化</strong>过程。</p>
<p>该函数将它的<strong>前两个参数</strong>（分别表示ISBN和价格）<strong>传递给Quote的构造函数</strong>，<strong>由Quote的构造函数</strong>负责初始化Bulk_quote的<strong>基类部分</strong>（即bookNo成员和price成员）。当(空的）Quote构造函数体结束后，我们构建的对象的基类部分也就完成初始化了。接下来初始化由派生类直接定义的min_qty成员和discount成员。最后运行Bulk_quote构造函数的（空的）函数体。<br>
首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。<br>
派生类可以访问<strong>基类</strong>的<strong>公有成员和受保护成员（protected），不能访问private</strong><br>
<strong>派生类的作用域</strong>嵌套在基类的作用域之内每个类负责定义各自的接口。要想与类的对象交互必须使用该类的接口，即使这个对象是派生类的基类部分也是如此。<br>
因此，派生类对象不能直接初始化基类的成员<br>
如果基类定义了一个<strong>静态成员</strong>（参见 7.6 节，第 268 页），则在<strong>整个继承体系中</strong>只存在该成员的<strong>唯一定义</strong>。不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在<strong>唯一的实例</strong>。<br>
静态成员遵循通用的访问控制规则，如果基类中的成员是 private 的，则派生类无权访问它。假设某<strong>静态成员是可访问的</strong>，则我们既<strong>能通过基类</strong>使用它<strong>也能通过派生类</strong>使用它：</p>
<p>派生类的<strong>声明</strong>与其他类差别不大（参见7.3.3节，第250页），声明中包含类名但是<strong>不包含它的派生列表</strong>：<br>
class Bulk_quote : public Quote;//** 错误：派生列表不能出现在这里<br>
class Bulk_quote;  // 正确：声明派生类的正确方式<br>
一条<strong>声明语句的目的</strong>是令<strong>程序</strong>知晓<strong>某个名字的存在</strong>以及<strong>该名字表示一个什么样的实体</strong>，如一个类、一个函数或一个变量等。派生列表以及与定义有关的<strong>其他细节</strong>必须与<strong>类的主体一起出现</strong>。</p>
<p>如果我们想将<strong>某个类用作基类</strong>，则该类<strong>必须己经定义</strong>而<strong>非仅仅声明</strong>该规定还有一层隐含的意思，即<strong>一个类不能派生它本身</strong>。<br>
一个类是<strong>基类</strong>，同时它<strong>也可以是一个派生类</strong>：</p>
<p>在这个继承关系中，Base是D 1的直接基类 (directbase ),同时是D 2的<strong>间接基类</strong>（indirect base )。直接基类出现在派生列表中，而间接基类由派生类通过其直接基类继承而来。<br>
最终的派生类将包含它的直接基类的子对象以及每个间接基类的子对象。</p>
<p>有时我们会定义这样一种类，我们<strong>不希望其他类继承它</strong>，或者不想考虑它是否适合作为一个基类。为了实现这一目的， C ++11新标准提供了一种防止继承发生的方法，即在类名后跟一个<strong>关键字 final</strong> ：<code>class NoDerived final { /* */} //NoDerive不能作为基类</code></p>
<p>习题15.4<br>
（a）错误，不能继承自身（或者说继承的基类不能只声明而未定义）<br>
（b）正确，但是是private定义，但从基类维承而来的成员对派生类的用户不可见<br>
（c）错误，类的声明中不可以带有派生列表<br>
习题15.5</p>
<pre><code>class Bulk_quote :public Quote {
public:
	Bulk_quote() = default;
	Bulk_quote(const string&amp; book, double p, size_t qty, double disc) :Quote(book, p), min_qty(qty), discount(disc) {};
	double net_price(size_t)const override;
private:
	size_t min_qty = 0;
	double discount = 0.0;
};

double Bulk_quote::net_price(size_t cnt)const {
	if (cnt &gt;= min_qty)
		return cnt*(1 - discount)*price;
	else
		return cnt*price;
}
</code></pre>
<p>习题15.6</p>
<pre><code>int main()
{
	Quote q(&quot;123&quot;,123);
	Bulk_quote bq(&quot;123&quot;, 123,5,0.5);
	print_total(cout, q, 10);
	print_total(cout, bq, 2);
	print_total(cout, bq, 10);
}
</code></pre>
<p>习题15.7<br>
其实可以直接利用Bulk_quote类，然后就是修改一下net_price函数</p>
<pre><code>double Bulk_quote::net_price(size_t cnt)const {
	if (cnt &lt;= min_qty)
		return cnt*(1 - discount)*price;
	else
		return  min_qty*(1 - discount)*price +(cnt-min_qty)*price;
}
</code></pre>
<p>15.2.3类型转换与继承<br>
我们可以将<strong>基类</strong>的<strong>指针或引用</strong>绑定到<strong>派生类对象</strong>上。<br>
当使用<strong>基类的引用（或指针）<strong>时，实际上我们</strong>并不清楚</strong>该引用（或指针）所绑定对象的<strong>真实类型</strong>。该对象<strong>可能是基类的对象，也可能是派生类的对象</strong>。<br>
和内置指针一样，<strong>智能指针类</strong>（参见12.1节，第400页）也<strong>支持派生类向基类</strong>的类型转换，这意味着我们可以将一个派生类对象的指针存储在一个基类的智能指针内:<br>
表达式的<strong>静态类型</strong>在<strong>编译时总是已知</strong>的，它是变量声明时的类型或表达式生成的类型：动态类型则是变量或表达式表示的内存中的对象的类型。<strong>动态类型直到运行时才可知</strong>。<br>
<strong>如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致</strong>。例如，Quote 类型的变量永远是一个 Quote 对象，我们无论如何都不能改变该变量对应的对象的类型。<br>
基类的<strong>指针和引用的静态类型可能与其动态类型不一致</strong>，读者一定要理解其中的原因<br>
之所以存在派生类向基类的类型转换<strong>是因为每个派生类对象都包含一个基类部分</strong>，而基类的引用或指针可以<strong>绑定到该基类部分上</strong>。<br>
因为一个基类的对象可能是派生类对象的一部分，<strong>也可能不是</strong>，所以<strong>不存在从基类向派生类</strong>的自动类型转换<br>
即使一个基类指针或引用绑定在一个派生类对象上，我们也不能执行从基类向派生类的转换：<br>
派生类向基类的自动类型转换<strong>只对指针或引用类型有效</strong>，在派生类类型和基类类型之间不存在这样的转换。<br>
请注意，当我们<strong>初始化或赋值</strong>一个类类型的对象时，实际上是在<strong>调用某个函数</strong>。当执行初始化时，我们调用构造函数（参见13.1.1节，第440页和13.6.2节，第473页）；而当执行赋值操作时，我们调用赋值运算符（参见13.1.2节，第443页和13.6.2节，第474页）。这些成员通常都包含一个参数，<strong>该参数的类型是类类型的 const 版本的引用（思考为什么是引用）</strong>。<br>
因为这些成员<strong>接受引用作为参数</strong>，所以派生类向基类的转换允许我们<strong>给基类的拷贝移动操作</strong>传递一个<strong>派生类的对象</strong>。这些操作不是虚函数。当我们给基类的构造函数传递一个派生类对象时，<strong>实际运行的构造函数是基类中定义的那个</strong>，显然该构造函数只能处理基类自己的成员。类似的，如果我们将一个<strong>派生类对象</strong>赋值给一个<strong>基类对象</strong>，则实际运行的赋值运算符也是<strong>基类中定义的那个</strong>，该运算符同样只<strong>能处理基类自己的成员<br>
**<br>
因为在上述过程中会</strong>忽略掉 bulk _ quote 部分**，所以我们可以说 bulk 的 Bulk_quot分<strong>被切掉 （sliced down )了</strong>。<br>
当我们用一个派生类对象为一个基类对象初始化或赋值时，<strong>只有该派生类对象的基类部分会被拷贝、移动或赋値，它的派生类部分将被忽略掉</strong><br>
关键概念：存在继承关系的类型之间的转换规则: :<br>
要想理解在具有继承关系的类之间发生的类型转换，有三点非常重要：<br>
•从派生类向基类的类型转换<strong>只对指针或引用类型</strong>有效。<br>
•<strong>基类向派生类不存在</strong>隐式类型转换。<br>
•和任何其他成员一样，派生类向基类的类型转换也<strong>可能会由于访问受限而变得不可行</strong>。我们将在15.5节（第544页）详细介绍可访问性的问题。<br>
尽管自动类型转换只对指针或引用类型有效，但是继承体系中的大多数类仍然（显式或隐式地）定义了拷贝控制成员（参见第13章）。因此，我们<strong>通常能够</strong>将一个<strong>派生类</strong>对象<strong>拷贝、移动或赋值</strong>给一个<strong>基类对象</strong>。不过需要注意的是，这种操作只<strong>处理派生类对象的基类部分</strong>。</p>
<p>习题15.8<br>
表达式的<strong>静态类型</strong>在<strong>编译时总是已知</strong>的，它是变量声明时的类型或表达式生成的类型：动态类型则是变量或表达式表示的内存中的对象的类型。<strong>动态类型直到运行时才可知</strong>。<br>
习题15.9<br>
基类的<strong>指针和引用的静态类型可能与其动态类型不一致</strong><br>
习题15.10<br>
read的形参参数为 istream的引用，所以可以将派生类ifstream的引用作为形参传给read</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 226. 翻转二叉树[简单]]]></title>
        <id>https://lixin-ee.github.io//post/shu-226-fan-zhuan-er-cha-shu-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/shu-226-fan-zhuan-er-cha-shu-jian-dan">
        </link>
        <updated>2019-11-11T02:24:55.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>翻转一棵二叉树。<br>
示例：<br>
输入：<br>
4<br>
/   <br>
2     7<br>
/ \   / <br>
1   3 6   9<br>
输出：<br>
4<br>
/   <br>
7     2<br>
/ \   / <br>
9   6 3   1<br>
备注:<br>
这个问题是受到 Max Howell 的 原问题 启发的 ：</p>
<p>谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/invert-binary-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br>
（皮一下：太糟糕了==fuck off，hhh）</p>
</blockquote>
<p>这道题一开始倒是让我想起了昨天的镜像题，就是同时遍历两个方向然后交换val，但是想了一下这样是不可行的，只有满二叉树的情况能这么干，比如1-2-3如果全是右子树，那就没法用val和一堆NULL互换了<br>
然后想了一下肯定得从当前结点进行处理，因为不能直接用val的话就必须交换指针值，交换指针值必须在当前结点操作。然后顺势就想到了直接交换左右子树，然后发现可以直接使用先序遍历来交换就好。<br>
代码如下</p>
<pre><code>class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root==NULL)
            return NULL;
        swap(root-&gt;left,root-&gt;right);
        invertTree(root-&gt;left);
        invertTree(root-&gt;right);
        return root;
    }
};
</code></pre>
<p>其实就是前序遍历加了个swaphhh</p>
<blockquote>
<p>然后来看官方题解：<br>
方法一 （递归） 【通过】<br>
这是一个非常经典的树的问题，这个问题很适合用递归方法来解决。<br>
算法<br>
反转一颗空树结果还是一颗空树。对于一颗根为 r，左子树为 left， 右子树为 right的树来说，它的反转树是一颗根为 r，左子树为 right的反转树，右子树为 left 的反转树的树。<br>
Java</p>
</blockquote>
<pre><code>public TreeNode invertTree(TreeNode root) {
    if (root == null) {
        return null;
    }
    TreeNode right = invertTree(root.right);
    TreeNode left = invertTree(root.left);
    root.left = right;
    root.right = left;
    return root;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
既然树中的每个节点都只被访问一次，那么时间复杂度就是 O(n)，其中 n 是树中节点的个数。在反转之前，不论怎样我们至少都得访问每个节点至少一次，因此这个问题无法做地比 O(n) 更好了。<br>
本方法使用了递归，在最坏情况下栈内需要存放 O(h) 个方法调用，其中 h 是树的高度。由于h∈O(n)，可得出空间复杂度为 O(n)。</p>
<p>方法二 （迭代） 【通过】<br>
我们也可以用迭代方法来解决这个问题，这种做法和深度优先搜索（Breadth-fist Search, BFS）很接近。<br>
算法<br>
这个方法的思路就是，我们需要交换树中所有节点的左孩子和右孩子。因此可以创一个队列来存储所有左孩子和右孩子还没有被交换过的节点。开始的时候，只有根节点在这个队列里面。只要这个队列不空，就一直从队列中出队节点，然后互换这个节点的左右孩子节点，接着再把孩子节点入队到队列，对于其中的空节点不需要加入队列。最终队列一定会空，这时候所有节点的孩子节点都被互换过了，直接返回最初的根节点就可以了。<br>
Java</p>
</blockquote>
<pre><code>public TreeNode invertTree(TreeNode root) {
    if (root == null) return null;
    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();
    queue.add(root);
    while (!queue.isEmpty()) {
        TreeNode current = queue.poll();
        TreeNode temp = current.left;
        current.left = current.right;
        current.right = temp;
        if (current.left != null) queue.add(current.left);
        if (current.right != null) queue.add(current.right);
    }
    return root;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
既然树中的每个节点都只被访问/入队一次，时间复杂度就是 O(n)，其中 n 是树中节点的个数。<br>
空间复杂度是O(n)，即使在最坏的情况下，也就是队列里包含了树中所有的节点。对于一颗完整二叉树来说，叶子节点那一层拥有ceil(n/2) =O(n) 个节点。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 101. 对称二叉树[简单]]]></title>
        <id>https://lixin-ee.github.io//post/shu-101-dui-cheng-er-cha-shu-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/shu-101-dui-cheng-er-cha-shu-jian-dan">
        </link>
        <updated>2019-11-10T14:59:58.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<pre><code>1
</code></pre>
<p>/ <br>
2   2<br>
/ \ / <br>
3  4 4  3<br>
但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<pre><code>1
</code></pre>
<p>/ <br>
2   2<br>
\   <br>
3    3</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/symmetric-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>我的思路是1.先进行层次遍历 2.对层次遍历得到的vector中的vector进行对称性检验<br>
主要需要注意的地方是必须把null也算进去，等于强行构造一棵满二叉树，我的处理方法是null插入值-1，其实这是不严谨的，如果被知道了很容易就被攻破了<br>
代码如下：</p>
<pre><code>class Solution {
    vector&lt;vector&lt;int&gt;&gt; ol;
public:
    bool isSymmetric(TreeNode* root) {
        if(root==NULL)
            return true;
        orderlevel(root,0);
        for(auto vi:ol){
            for(auto beg=vi.begin(),end=vi.end()-1;beg&lt;end;++beg,--end){
                if(beg==end)
                    return false;
                if(*beg!=*end)
                    return false;
            }
        }
        return true;
    }
    
    void orderlevel(TreeNode* cur,int level){
        if(ol.size()==level)
            ol.push_back(vector&lt;int&gt;());
        if(cur==NULL){
            ol[level].push_back(-1);
            return;
        }
        ol[level].push_back(cur-&gt;val);
        orderlevel(cur-&gt;left,level+1);
        orderlevel(cur-&gt;right,level+1);
        return;
    }   
};
</code></pre>
<p>然后来看一下官方算法吧</p>
<blockquote>
<p>方法：递归<br>
如果一个树的左子树与右子树镜像对称，那么这个树是对称的。</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1573402185238.png" alt=""></p>
<blockquote>
<p>因此，该问题可以转化为：两个树在什么情况下互为镜像？</p>
<p>如果同时满足下面的条件，两个树互为镜像：</p>
<p>它们的两个根结点具有相同的值。<br>
每个树的右子树都与另一个树的左子树镜像对称。</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1573402200685.png" alt=""></p>
<blockquote>
<p>就像人站在镜子前审视自己那样。镜中的反射与现实中的人具有相同的头部，但反射的右臂对应于人的左臂，反之亦然。<br>
上面的解释可以很自然地转换为一个递归函数，如下所示：</p>
</blockquote>
<pre><code>Java
public boolean isSymmetric(TreeNode root) {
    return isMirror(root, root);
}

public boolean isMirror(TreeNode t1, TreeNode t2) {
    if (t1 == null &amp;&amp; t2 == null) return true;
    if (t1 == null || t2 == null) return false;
    return (t1.val == t2.val)
        &amp;&amp; isMirror(t1.right, t2.left)
        &amp;&amp; isMirror(t1.left, t2.right);
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)，因为我们遍历整个输入树一次，所以总的运行时间为 O(n)，其中 n 是树中结点的总数。<br>
空间复杂度：递归调用的次数受树的高度限制。在最糟糕情况下，树是线性的，其高度为 O(n)。因此，在最糟糕的情况下，由栈上的递归调用造成的空间复杂度为 O(n)。</p>
<p>方法二：迭代<br>
除了递归的方法外，我们也可以利用队列进行迭代。队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像。最初，队列中包含的是 root 以及 root。该算法的工作原理类似于 BFS，但存在一些关键差异。每次提取两个结点并比较它们的值。然后，将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。</p>
</blockquote>
<p>Java</p>
<pre><code>public boolean isSymmetric(TreeNode root) {
    Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();
    q.add(root);
    q.add(root);
    while (!q.isEmpty()) {
        TreeNode t1 = q.poll();
        TreeNode t2 = q.poll();
        if (t1 == null &amp;&amp; t2 == null) continue;
        if (t1 == null || t2 == null) return false;
        if (t1.val != t2.val) return false;
        q.add(t1.left);
        q.add(t2.right);
        q.add(t1.right);
        q.add(t2.left);
    }
    return true;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)，因为我们遍历整个输入树一次，所以总的运行时间为 O(n)，其中 n是树中结点的总数。<br>
空间复杂度：搜索队列需要额外的空间。在最糟糕情况下，我们不得不向队列中插入 O(n) 个结点。因此，空间复杂度为 O(n)。</p>
</blockquote>
<p>第一个迭代法太秀啦，直接对同一棵树本身进行镜像方向的遍历，确实很快很强。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第十四章 笔记]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-si-zhang-bi-ji</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-si-zhang-bi-ji">
        </link>
        <updated>2019-11-10T01:58:42.000Z</updated>
        <content type="html"><![CDATA[<p>14.重载运算与类型转换<br>
当运算符作用于类类型的运算对象时，可以通过运算符重载重新定义该运算符的含义，明智地使用运算符重载能令我们的成语更易于编写和阅读<br>
14.1基本概念<br>
重载的运算符是具有特殊名字的<strong>函数</strong>，它们的名字由关键字operator和其后要定义的运算符共同组成，重载运算符也包含返回类型、参数列表以及函数体<br>
重载运算符函数参数的数量与该运算符作用的运算对象数量一样多（一元一个，二元两个）<br>
除了重载的<strong>函数调用运算符operator（）之外</strong>，其他重载运算符<strong>不能含有默认实参</strong><br>
如果一个运算符函数是<strong>成员函数</strong>，则它的<strong>第一个（左侧）运算对象绑定到隐式的this指针</strong>上，因此，成员运算符函数的（显式）参数数量比运算对象总数少一个<br>
对于一个运算符函数来说，它必须自身是类的成员，或者必须运算对象中至少含有一个类类型的参数。这意味着当运算符只作用于内置类型的运算对象时，我们无法改变该运算符的含义</p>
<p>我们只能<strong>重载已有的运算符</strong>，而无权定义声明新的运算符号<br>
有四个符号既是一元运算符也是二元运算符：+ - * &amp;，从参数的数量我们可以推断到底定义的是哪种运算符<br>
对于一个重载的运算符来说，其<strong>优先级和结合律与对应的内置运算符一致</strong></p>
<p>对于<strong>非成员函数</strong>的<strong>重载运算符</strong>1.既可以讲运算符作用于类型正确（相同类型或可转换类型）的实参从而间接调用重载的运算符函数2.也能直接调用运算符函数<br>
对于<strong>成员函数</strong>的重载运算符，我们像<strong>调用其他成员函数一样显式地调用</strong>成员运算符函数</p>
<p><strong>部分运算符不应该被重载</strong>，因为重载运算符本质上是函数调用，所以运算对象<strong>求值顺序的规则无法应用</strong>到重载的运算符上，例如（<strong>逻辑与&amp;&amp;、逻辑或||、逗号运算符，</strong>）的运算对象求值顺序规则无法保留下来。除此以外，<strong>&amp;&amp;和||运算符</strong>的重载版本也无法保留内置运算符的<strong>短路求值</strong>属性（<strong>先求左边值再求右边值</strong>），<strong>总是会两边都被求值</strong><br>
一般不重载逗号运算符和取地址运算符，因为c++语言已经定义了这两种运算符用于类类型对象时的特殊含义<br>
通常情况下不应该重载逗号、取地址、逻辑与和逻辑或运算符<br>
当你开始设计一个类时，首先应该考虑类提供的操作，再根据操作考虑哪些操作需要重载的运算符</p>
<p><strong>赋值运算符</strong>返回它<strong>左侧运算对象的一个引用</strong><br>
如果类含有算数运算符或者位运算符，则最好也提供相应的复合赋值运算符+=等，<br>
当我们定义重载的运算符时，必须<strong>首先决定</strong>是将其声明为类的<strong>成员函数</strong>还是声明为一个普通的<strong>非成员函数</strong></p>
<p>在含有<strong>混合类型</strong>的表达式中应当使用<strong>对称性</strong>的运算符（例如加法是具有对称型的，求int和double的和时<strong>两者的位置可以是任意的</strong>），此时重载运算符<strong>必须定义成非成员函数</strong><br>
当我们把运算符重载为<strong>成员函数</strong>时，它的<strong>左侧运算对象</strong>必须是运算符<strong>所属类</strong>的一个对象<br>
3.2.2中string的+相连之所以必须有一个是string形参就是因为string重载了+运算符，并且将其定义为非成员函数。</p>
<p>14.3算术和关系运算符<br>
通常情况下，我们把算术和关系运算符定义成<strong>非成员函数</strong>以允许对左侧或右侧的运算对象<strong>进行转换</strong>。因为这些运算符一般不需要改变运算对象的状态，所以<strong>形参都是常量的引用</strong><br>
算术运算符完成<strong>计算后得到的新值</strong>有别于任何一个运算对象，常常<strong>位于一个局部变量之内</strong>，操作完成后<strong>返回该局部变量的副本</strong>作为其结果。如果类定义了算术运算符，则它一般也会定义一个对应的<strong>复合赋值运算符</strong>。此时，最有效的方式是<strong>使用复合赋值来定义算术运算符</strong><br>
如果类<strong>同时定义</strong>了算术运算符和相关的复合赋值运算符，则通常情况下<strong>应该使用复合赋值来实现算术运算符</strong><br>
14.3.1 相等运算符<br>
c++中的类通过定义相等运算符来检验两个对象是否相等。他们<strong>会比较对象的每一个数据成员</strong>，只有当所有对应的成员<strong>都相等时</strong>才认为两个对象相等</p>
<p>14.3.2关系运算符<br>
定义了相等运算符的类通常（但不总是）包含关系运算符。特别是，因为关联容器和一些算法要用到小于运算符，所以定义<strong>operator&lt;会比较有用</strong></p>
<p>如果存在唯一一种逻辑可靠的&lt;定义，则应该考虑为这个类定义&lt;运算符。如果类同时还包含==，则<strong>当且仅当&lt;的定义和==产生的结果一致时才定义&lt;运算符。</strong><br>
14.4赋值运算符<br>
类还可以定义其他赋值运算符以使用别的类型作为右侧运算对象。<br>
标准库vector还定义了第三种赋值运算符，该运算符接受花括号内的元素列表作为参数。我们能使用如下形式使用该运算符：</p>
<p><strong>花括号的本质</strong></p>
<p>为了与内置类型的赋值运算符保持一致（也与我们已经定义的拷贝赋值和移动赋值运算一致），这个新的赋值运算符将<strong>返回其左侧运算对象的引用</strong></p>
<p>和拷贝赋值及移动赋值运算符一样，其他重载的赋值运算符也<strong>必须先释放当前内存空间，再创建一片新空间</strong>不同之处是，这个运算符无须检查对象向自身的赋值，这是因为它的形参<code>initializer_list&lt;string&gt;</code> 确保il和this所指向的不是同一个对象<br>
我们可以重载赋值运算符，不论形参的类型是什么，<strong>赋值运算符都必须定义为成员函数</strong>。<br>
复合赋值运算符<strong>不非得</strong>是类的成员，不过我们还是倾向于把包括复合赋值在内的所有赋值运算符都定义在类的内部。为了与内置类型的复合赋值保持一致，类中的复合赋值运算符也要返回其左侧运算对象的引用。<br>
赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这么做，这两类运算符都应该返回左侧运算对象的引用</p>
<p>14.5下标运算符<br>
下标运算符<strong>必须是成员函数</strong><br>
为了与下标的原始定义兼容，下标运算符通常以<strong>所访问元素的引用作为返回值</strong>，这样做的好处是下标可以<strong>出现在赋值运算符的任意一端</strong>。我们最好<strong>同时定义</strong>下标运算符的<strong>常量版本和非常量版本</strong>。当作用于一个常量对象时，下标运算符返回常量引用以确保我们不会给返回的对象赋值<br>
如果一个类包含下标运算符，则它通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并且返回常量引用。<br>
14.6 递增和递减运算符<br>
c++语言并不要求递增和递减运算符必须是类的成员，但是因为它们改变的正好是所操作对象的状态，所以<strong>建议将其设定为成员函数</strong><br>
定义递增和递减运算符<strong>应该同时定义其前置版本和后置版本</strong>。这些运算符通常应该被定义为类的成员<br>
为了与内置版本一致，前置运算符应该返回递增或递减后<strong>对象的引用</strong></p>
<p>区分前置和后置运算符：<strong>后置版本接受一个额外的（不被使用）int类型的形参</strong>。当我们使用后置运算符时，<strong>编译器为这个形参提供一个值为0的实参</strong>。这个形参的唯一作用就是区分前置版本和后置版本的函数，而不是真的要在实现后置版本时参与运算</p>
<p>为了与内置版本保持一致，<strong>后置运算符应该返回对象的原值（递增或递减之前的值），返回的形式是一个值而非引用</strong><br>
对于后置版本来说，<strong>在递增对象之前需要首先记录对象的状态</strong></p>
<p>我们的<strong>后置运算符调用各自的前置版本来完成实际的工作</strong>，例如后置递增运算符执行<br>
<code>++*this</code><br>
后置函数返回事先存好的ret副本。因此最终的结果是，<strong>对象本身向前移动了一个元素，而返回的结果仍然反映对象在未递增之前原始的值</strong>。<br>
因为我们<strong>不会用到int形参，所以无需为其命名</strong><br>
如果我们<strong>想通过函数调用的方式调用后置版本，则必须为它的整形参数传递一个值</strong></p>
<p>尽管<strong>传入的值通常会被运算符函数忽略，但却必不可少</strong>，因为编译器只有通过它才能知道应该使用后置版本。<br>
14.7成员访问运算符<br>
解引用运算符<strong>首先检查curr是否仍在作用范围内</strong>，如果是，则<strong>返回curr所指元素的一个引用</strong>。箭头运算符<strong>不执行任何自己的操作</strong>，而是<strong>调用解引用运算符并返回解引用结果元素的地址</strong>。<br>
<strong>箭头运算符必须是类的成员。解引用运算符通常也是类的成员</strong>，尽管并非必须如此。<br>
值得注意的是，我们将这两个运算符定义成了** const成员**，这是因为与递增和递减<br>
运算符不一样，获取一个元素并不会改变StrBlobPtr对象的状态。同时，<strong>它们的返回值分别是非常量string的引用或指针，因为一个StrBlobPtr只能绑定到非常量的StrBlob对象</strong><br>
和大多数其他运算符一样（尽管这么做不太好)，我们能令<code>operator *</code>完成任何我们<br>
指定的操作。<br>
箭头运算符则不是这样，它永远不能丢掉成员访问这个最基本的含义<br>
point -&gt; mem 的执行过程如下所示:</p>
<ol>
<li>如果 point 是指针，则我们应用内置的箭头运算符，表达式等价（*point ) .memo<br>
首先解引用该指针，然后从所得的对象中获取指定的成员。如果 point 所指的类型没有名为 mem 的成员，程序会发生错误。</li>
<li>如果 point 是定义了 operator –&gt;的类的一个对象，则我们使用 point . operator-&gt; ()<br>
的结果来获取 mem 。其中，如果该结果是一个指针，则执行第1步：如果该结果本身含有重载的 operator -&gt;()，则重复调用当前步驟。最终，当这一过程结束时程序或者返回了所需的内容，或者返回一些表示程序错误的信息<br>
重载的箭头运算符<strong>必须返回类的指针</strong>或者自定义了箭头运算符的某个类的对象</li>
</ol>
<p>14.8函数调用运算符 也就是（）括号<br>
如果<strong>类重载了</strong>函数调用运算符，则我们可以像<strong>使用函数一样使用该类的对象</strong>。因为这样的类<strong>同时也能存储状态</strong>，与普通函数相比它们更加灵活</p>
<p>调用对象实际上是在<strong>运行重载的调用运算符。</strong><br>
函数调用运算符<strong>必须是成员函教</strong>。一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所匹别。<br>
如果类定义了调用运算符，则<strong>该类的对象称作函数对象（function object）</strong>。因为可以调用这种对象，所以我们说这些对象的&quot;行为像函数一样&quot;。<br>
14.8.1 lambda是<strong>函数对象</strong><br>
当我们编写了一个 lambda 后，编译器将该表达式<strong>翻译成一个未命名类的未命名对象</strong>（参见10.3.3节，第349页）。在<strong>lambda 表达式产生的类</strong>中<strong>含有一个重载的函数调用运算符</strong><br>
默认情况下 lambda <strong>不能改变它捕获的变量</strong>。因此在默认情况下，<strong>由 lambda 产生的类当中的函数调用运算符是一个 const 成员函数</strong>。如果 lambda 被声明为可变的，则调用运算符就不是 const 的了。<br>
如我们所知，当一个 lambda 表达式通过<strong>引用捕获</strong>变量时，将由程序负责确保lambda执行时引用所引的对象确实存在（参见10.3.3节，第350页）。因此，<strong>编译器可以直接使用该引用而无须在 lambda 产生的类中将其存储为数据成员。</strong><br>
相反，通过<strong>值捕获</strong>的变量被拷贝到 lambda 中（参见10.3.3节，第350页）。因此，这种 lambda 产生的类<strong>必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数，令其使用捕获的变量的值来初始化数据成员。</strong></p>
<p>lambda 表达式产生的类不含<strong>默认构造函数</strong>、赋值运算符及<strong>默认析构函数</strong>；它是否含有默认的拷贝/移动构造函数则通常要视捕获的数据成员类型而定<br>
14.8.2标准库定义的函数对象<br>
标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，<strong>每个类分别定义了一个执行命名操作的调用运算符。</strong><br>
这些类都被定义成模板的形式，我们可为其指定具体的应用类型，这里的类型即调用运算符的形参类型</p>
<p>表14.2所列的类型定文在 functional 头文件中。</p>
<p><strong>表示运算符的函数对象类常用来替换算法中的默认运算符（比如for_each等等的泛型算法）</strong><br>
需要特别注意的是，标准库规定其<strong>函数对象对于指针同样适用</strong>。我们之前曾经介绍过<strong>比较两个无关指针将产生未定义的行为</strong>（参见3.5.3节，第107页），然而我们可能会希望通过比较指针的内存地址来 sort 指针的 vector 。直接这么做将产生未定义的行为，因此我们<strong>可以使用一个标准库函数对象来实现该目的</strong>：</p>
<p><strong>关联容器使用 less &lt; key _ type &gt;对元素排序</strong>，因此我们可以定义一个<strong>指针的 set 或者在map 中使用指针作为关键值而无须直接声明 less 。</strong><br>
14.8.3可调用对象与function<br>
C ++语言中有几种可调用的对象：函数、函数指针、 lambda 表达式（参见10.3.2节，第346页)、 bind 创建的对象（参见10.3.4节，第354页）以及重载了函数调用运算符类。<br>
和其他对象一样，<strong>可调用的对象也有类型</strong>。<br>
然而，两个<strong>不同类型</strong>的可调用对象却可能<strong>共享同一种调用形式</strong>（call signature ),调用形式<strong>指明了调用返回的类型以及传递给调用的实参类型</strong>，<strong>一种调用形式对应一个函数类型</strong>，<br>
例如 int（int，int）<br>
对于<strong>几个可调用对象共享同一种调用形式</strong>的情况，有时我们会希望把它们<strong>看成具有相同的类型。</strong><br>
<strong>函数表（functiontable)</strong> <strong>用于存储指向这些可调用对象的&quot;指针&quot;</strong>。当程序需要执行某个特定的操作时，从表中查找该调用的函数。<br>
在 C++语言中，函数表很容易通过<strong>map</strong>来实现</p>
<p>// 构建从<strong>运算符到函数指针的映射关系</strong>，其中函数接受两个 int 、运回一个 int<br>
<code>map&lt;string, int (*) (int,int)&gt; binops;</code><br>
我们可以按照下面的形式将 add 的指针添加到 binops 中：<br>
// 正确； add 是一个指向正确类型函数的指针<br>
binops.insert({&quot; + &quot;, add}) ;  //  {“+”，add} 是一个 pair  (参见 11.2.3 节， 379 巧）<br>
但是我们不能将 mod 或者 divide 存入 binops<br>
binops . insert ({“%”, mod}) ;  //  错误： mod  不是一个函数指针<br>
问题在于<strong>mod是个 lambda 表达式，而每个 lambda 有它自己的类类型，该类型与存储在binops 中的值的类型不匹配</strong>。<br>
我们可以使用一个名为<strong>function 的新的标准库类型</strong>解决上述问题， function 定义在<strong>functional 头文件</strong>中，表14.3列举出了  function 定义的操作</p>
<p>function是一个<strong>模板</strong>，和我们使用过的其他模板一样，当创建一个具体的function类型时我们必须提供额外的信息。在此例中，所谓额外的信息是指该function类型能够表示的<strong>对象的调用形式</strong>。参考其他模板，我们在一对尖括号内指定类型：</p>
<p>我们<strong>不能（直接）将重载函数的名字存入</strong>function 类型的对象中：</p>
<p>解决上述二义性问题的一条途径是<strong>存储函数指针</strong></p>
<p>同样，我们也能使用 lambda 来消除二义性：</p>
<p>新版本标准库中的function类与旧版本中的<strong>unary_function和binary_function没有关联，后两个类已经被更通用的bind函数替代了</strong>（参见10.3.4节，第357页）。</p>
<p>14.9 重载、类型转换与运算符<br>
我们同样能定义对于<strong>类类型的类型转换</strong>，通过<strong>定义类型转换运算符</strong>可以做到这一点。<strong>转换构造函数和类型转换运算符</strong>共同定义了类类型转换( class-type conversions ),这样的转换有时也被称作用户自定义的类型转换。<br>
类型转换运算符 (conversion operator )是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。<br>
operator type ()const;<br>
其中type表示某种类型。类型转换运算符<strong>可以面向任意类型</strong>（除了 void 之外）进行定义，只要该类型<strong>能作为函数的返回类型</strong>（参见6.1节，第184页）。因此，我们不允许转换成<strong>数组或者函数类型</strong>，但<strong>允许转换成指针（包括数组指针及函数指针）或者引用类型。</strong><br>
类型转换运算符既<strong>没有显式的返回类型</strong>，<strong>也没有形参</strong>，而且<strong>必须定义成类的成员函数</strong>。<br>
类型转换运算符通常<strong>不应该改变待转换对象的内容</strong>，因此，类型转换运算符一般被定义成**const 成员<br>
**—个类型转换函数必须是类的成员函数；它不能声明返回类型，形参列表也必须为空。类型转换函数通常应该是 const 。</p>
<p><strong>构造函数</strong>将算术类型的值转换成 Smallint对象，而<strong>类型转换运算符</strong>将Smallint对象转换成 int</p>
<p>尽管编译器<strong>一次只能执行一个</strong>用户定义的类型转换（参见4.11.2节，44页），但是<strong>隐式的用户定义类型转换</strong>可以置于一个标准（内置）类型转换之前或之后（参化4.11.1节，第141页），我们也能使用类型转换运算符将一个Smallint对象转换成 int ,然后再将所得的 int 转换成任何其他算术类型：</p>
<p>因为<strong>类型转换运算符</strong>是<strong>隐式执行</strong>的，所以<strong>无法</strong>给这些函数<strong>传递实参</strong>，当然<strong>也就不能</strong>在类型转换运算符的定义中<strong>使用任何形参</strong>。同时，尽管类型转换函数不负责指定返回类型，但<strong>实际上每个类型转换函数都会返回一个对应类型的值</strong>：</p>
<p>在实践中，<strong>类很少提供类型转换运算符<br>
<strong>然而这条经验法则存在一种</strong>例外情况</strong>：对于类来说，<strong>定义向bool的类型转换还是比较普遍的现象</strong>。<br>
因为bool是一种算术类型，所以类类型的对象转换成bool之后就能被用在任何需要算术类型的上下文中。这样的类型转换可能引发意想不到的结果。</p>
<p>这段程序试图将输出运算符作用于输入流。因为 istream 本身并没有定义&lt;&lt;，所以本来代码应该产生错误。然而，该代码能使用 istream 的 bool 类型转换运算符将 cin 转换成 bool ,而这个 bool 值接着会被提升成 int 并用作内置的左移运算符的左侧运算对象。这样一来，提升后的 bool 值（1或0)最终会被左移42个位置。这一结果显然与我们的预期大相径庭。<br>
为了防止这样的异常情况发生， C ++11新标准引入了显式的类型转换运算符</p>
<p>和显式的构造函数（参见7.5.4节，第265页）一样，编译器（通常）也不会将一个显式的类型转换运算符用于隐式类型转换：</p>
<p>当类型转换运算符是<strong>显式</strong>的时，我们也能执行类型转换，不过<strong>必须通过显式的强制类型转换</strong>才可以。<br>
该规定存在<strong>一个例外</strong>，即如果表达式<strong>被用作条件</strong>，则编译器会将显式的类型转换自动应用于它。换句话说，当表达式出现在下列位置时，显式的类型转换将被隐式地执行：<br>
• if 、 while 及 do 语句的条件部分<br>
• for 语句头的条件表达式<br>
•逻辑非运算符（！）、；逻辑或运算符（ II ）、逻辑与运算符(&amp;&amp;)的运算对象<br>
•条件运算符（?:）的条件表达式</p>
<p>在标准库的早期版本中， IO 类型定义了向<code>void *</code>的转换规则，以求避免上面提到的问题。在 C++11新标准下，IO标准库通过定义一个向 bool 的显式类型转换实现同样的目的。<br>
无论我们什么时候<strong>在条件中使用流对象</strong>，都会使用为<strong>IO类型定义</strong>的<strong>operator bool</strong>。例如：<br>
while(std:cin&gt;&gt;value)<br>
while 语句的条件执行输入运算符，它负责将数据读入到 value <strong>并返回 cin</strong> 。为了对条<br>
件求值，cin 被 istream operator bool 类型转换函数隐式地执行了转换。如果 cin的**条件状态是 good **(参见8.1.2节，第280页)，<strong>则该函数返回为真</strong>；否则该函数返回为假。<br>
向 bool 的类型转换通常用在条件部分，因此 <strong>operator bool 一般定义成explicit</strong> 的。</p>
<p>14.9.2避免有二义性的类型转换<br>
如果类中包含<strong>一个或多个类型转换</strong>，则必须确保在类类型和目标类型之间<strong>只存在唯一一种转换方式</strong>。否则的话，我们编写的代码将很可能会具有二义性。<br>
在两种情况下可能产生多重转换路径。第一种情况是<strong>两个类提供相同的类型转换</strong>：例<br>
如，当 A 类定义了一个接受 B 类对象的<strong>转换构造函数</strong>，同时 B 类定义了一个转换目标是<br>
A 类的<strong>类型转换运算符</strong>时，我们就说它们提供了相同的类型转换。<br>
第二种情况是类<strong>定义了多个转换规则</strong>，而这些转换涉及的类型本身可以通过其他类型 转换联系在一起。最典型的例子是算术运算符，对某个给定的类来说，最好<strong>只定义最多一个与算术类型有关的转换规则</strong>。<br>
通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及两个以上<strong>转换源或转换目标</strong>是<strong>算术类型</strong>的转换。</p>
<p>因为同时存在两种由 B 获得 A 的方法，所以造成编译器无法判断应该运行哪个类型转换，<br>
如果我们<strong>确实想执行上述的调用，就不得不显式地调用</strong>类型转换运算符或者转换构造函数：</p>
<p>值得注意的是，我们<strong>无法使用强制类型转换来解决二义性问题</strong>，因为强制类型转换本身也面临二义性。</p>
<p>另外如果类定义了一组类型转换，它们的转换源（或者转换目标）类型本身可通过其他类型转换联系在一起，则同样会产生二义性的问题。最简单也是最困扰我们的例子就是类当中定义了多个参数都是算术类型的构造函数，或者转换问标都是算术类型的类型转换运算符。</p>
<p>在对 f 2的调用中，哪个类型转换都无法精确匹配 long double 。然而这两个类型转换都可以使用，只要后面再执行一次生成 long double 的标准类型转换即可。因此，在上面的两个类型转换中哪个都不比另一个更好，调用将产生二义性。<br>
当我们试图用 long 初始化a 2时也遇到了同样问题，哪个构造函数都无法精确匹配long 类型。它们在使用构造函数前都要求先将实参进行类型转换：<br>
•先执行 long 到 double 的标准类型转换，再执行 A ( double )<br>
•先执行 long 到 int 的标准类型转换，再执行 A ( int )<br>
调用f 2及初始化 a 2的过程之所以会产生二义性，<strong>根本原因</strong>是它们<strong>所需的标准类型转换级别一致</strong><br>
在此例中，把<strong>short 提升成 int</strong>的操作要优于 <strong>short 转换成double</strong> 的操作，因此编译器将使用 A :: A ( int )构造函数构造 a 3,其中实参是 s (提升后）的值。<br>
当我们使用两个用户定义的类型转换时，如果转换函数之前或之后存在标准类型转换，则标准类型转换将决定最佳匹配到底是哪个。</p>
<p>当我们调用<strong>重载的函数</strong>时，从<strong>多个类型转换中进行选择</strong>将变得更加复杂。如果两个或多个类型转换都提供了<strong>同一种可行匹配</strong>，则<strong>这些类型转换一样好</strong>。<br>
当几个重载函数的参数分属不同的类类型时，如果这些类恰好定义了同样的转换构造函数，则二义性问题将进一步提升：</p>
<pre><code>调用者可以显式地构造正确的类型从而消除二义性：
manip(C(10));  // 正确；调用 manip(const C&amp;)
当调用重载函数时，如果两个（或多个）用户定义的类型转换都提供了可行匹配，则我们认为这些类型转换一样好。在这个过程中，我们不会考虚任何可能出现的标准类型转换的级别。只有当重载函数能通过同一个类型转换函数得到匹配时，我们才会考虑其中出现的标准类型转换。
</code></pre>
<p>即使其中一个调用<strong>需要额外的标准类型转换</strong>而<strong>另一个调用能精确匹配</strong>，编译器<strong>也会将该调用标示为错误</strong>。<br>
在调用重载函数时，如果需要额外的标准类型转换，则该转换的级别只有当所有可行函数都请求同一个用户定义的类型转换时才有用。如果所需的用户定义的类型转换不止一个，则该调用具有二义性。</p>
<p>14.9.3函数匹配与重载运算符<br>
<strong>重载的运算符</strong>也是<strong>重载的函数</strong>。因此，<strong>通用的函数匹配规则</strong>（参见6.4节，第208页）<br>
同样适用于判断在给定的表达式中到底应该使用<strong>内置运算符</strong>还是<strong>重载的运算符</strong>。不过当运<br>
算符函数出现在表达式中时，候选函数集的规模要比我们使用调用运算符调用函数时更大。<br>
和普通函数调用不同，我们<strong>不能通过调用的形式来区分</strong>当前调用的是<strong>成员函数</strong>还是<strong>非成员函数</strong>。<br>
当我们使用重载运算符<strong>作用于类类型的运算对象</strong>时，候选函数中包含该运算符的<strong>普通 非成员版本</strong>和<strong>内置版本</strong>。除此以外，如果<strong>左侧运算对象是类类型</strong>，则<strong>定义在该类中的运算符的重载版本</strong>也包含在候选函数内。<br>
当我们调用一个命名的函数时，具有该名字的成员函数和非成员函数不会彼此重载，这是因为我们用来调用命名函数的语法形式对于成员函数和非成员函数来说是不相同的。当我们通过类类型的对象（或者该对象的指针及引用）进行函数调用时，只考虑该类的成员函数。而当我们在表达式中使用重载的运算符时，无法判断正在使用的是成员函数还是非成员函数，因此二者都应该在考虑的范围内。</p>
<p>表达式中运算符的候选函数集既应该包括成员函数，也应该包括非成员函数。<br>
因为我们可以把0转换成 Smallint . 然后使用Smallint的 + ; 或 者 把 s 3 转换成 int ，然后对于两个 int 执行内置的加法运算。<br>
如果我们对同一个类既提供了<strong>转换目标是算术类型的类型转换</strong>，也提供了<strong>重载的运算符</strong>，则将会遇到<strong>重载运算符与内置运算符的二义性问题</strong>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[写树算法的套路框架]]></title>
        <id>https://lixin-ee.github.io//post/xie-shu-suan-fa-de-tao-lu-kuang-jia</id>
        <link href="https://lixin-ee.github.io//post/xie-shu-suan-fa-de-tao-lu-kuang-jia">
        </link>
        <updated>2019-11-09T12:36:19.000Z</updated>
        <content type="html"><![CDATA[<p>解题思路：<br>
二叉树算法 设计的总路线：明确一个节点要做的事情，然后剩下的事抛给框架。</p>
<pre><code>void traverse(TreeNode root) {
    // root 需要做什么？在这做。
    // 其他的不用 root 操心，抛给框架
    traverse(root.left);
    traverse(root.right);
}
</code></pre>
<p>举两个简单的例子体会一下这个思路，热热身。</p>
<ol>
<li>如何把二叉树所有的节点中的值加一？</li>
</ol>
<pre><code>void plusOne(TreeNode root) {
    if (root == null) return;
    root.val += 1;

    plusOne(root.left);
    plusOne(root.right);
}
</code></pre>
<ol start="2">
<li>如何判断两棵二叉树是否完全相同？</li>
</ol>
<pre><code>boolean isSameTree(TreeNode root1, TreeNode root2) {
    // 都为空的话，显然相同
    if (root1 == null &amp;&amp; root2 == null) return true;
    // 一个为空，一个非空，显然不同
    if (root1 == null || root2 == null) return false;
    // 两个都非空，但 val 不一样也不行
    if (root1.val != root2.val) return false;

    // root1 和 root2 该比的都比完了
    return isSameTree(root1.left, root2.left)
        &amp;&amp; isSameTree(root1.right, root2.right);
}
</code></pre>
<p>借助框架，上面这两个例子不难理解吧？如果可以理解，那么所有二叉树算法你都能解决。</p>
<p>二叉搜索树（Binary Search Tree，简称 BST）是一种很常用的的二叉树。它的定义是：一个二叉树中，任意节点的值要大于等于左子树所有节点的值，且要小于等于右边子树的所有节点的值。</p>
<p>如下就是一个符合定义的 BST：<br>
<img src="https://lixin-ee.github.io//post-images/1573303241790.png" alt=""><br>
下面实现 BST 的基础操作：判断 BST 的合法性、增、删、查。其中“删”和“判断合法性”略微复杂。</p>
<p>零、判断 BST 的合法性</p>
<p>这里是有坑的哦，我们按照刚才的思路，每个节点自己要做的事不就是比较自己和左右孩子吗？看起来应该这样写代码：</p>
<pre><code>boolean isValidBST(TreeNode root) {
    if (root == null) return true;
    if (root.left != null &amp;&amp; root.val &lt;= root.left.val) return false;
    if (root.right != null &amp;&amp; root.val &gt;= root.right.val) return false;

    return isValidBST(root.left)
        &amp;&amp; isValidBST(root.right);
}
</code></pre>
<p>但是这个算法出现了错误，BST 的每个节点应该要小于右边子树的所有节点，下面这个二叉树显然不是 BST，但是我们的算法会把它判定为 BST。<br>
<img src="https://lixin-ee.github.io//post-images/1573303293742.png" alt=""><br>
出现错误，不要慌张，框架没有错，一定是某个细节问题没注意到。我们重新看一下 BST 的定义，root 需要做的不只是和左右子节点比较，而是要整个左子树和右子树所有节点比较。怎么办，鞭长莫及啊！</p>
<p>这种情况，我们可以使用辅助函数，增加函数参数列表，在参数中携带额外信息，请看正确的代码：</p>
<pre><code>boolean isValidBST(TreeNode root) {
    return isValidBST(root, null, null);
}

boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) {
    if (root == null) return true;
    if (min != null &amp;&amp; root.val &lt;= min.val) return false;
    if (max != null &amp;&amp; root.val &gt;= max.val) return false;
    return isValidBST(root.left, min, root) 
        &amp;&amp; isValidBST(root.right, root, max);
}
</code></pre>
<p>一、在 BST 中查找一个数是否存在<br>
根据我们的指导思想，可以这样写代码：</p>
<pre><code>boolean isInBST(TreeNode root, int target) {
    if (root == null) return false;
    if (root.val == target) return true;

    return isInBST(root.left, target)
        || isInBST(root.right, target);
}
</code></pre>
<p>这样写完全正确，充分证明了你的框架性思维已经养成。现在你可以考虑一点细节问题了：如何充分利用信息，把 BST 这个“左小右大”的特性用上？<br>
很简单，其实不需要递归地搜索两边，类似二分查找思想，根据 target 和 root.val 的大小比较，就能排除一边。我们把上面的思路稍稍改动：</p>
<pre><code>boolean isInBST(TreeNode root, int target) {
    if (root == null) return false;
    if (root.val == target)
        return true;
    if (root.val &lt; target) 
        return isInBST(root.right, target);
    if (root.val &gt; target)
        return isInBST(root.left, target);
    // root 该做的事做完了，顺带把框架也完成了，妙
}
</code></pre>
<p>于是，我们对原始框架进行改造，抽象出一套针对 BST 的遍历框架：<br>
void BST(TreeNode root, int target) {<br>
if (root.val == target)<br>
// 找到目标，做点什么<br>
if (root.val &lt; target)<br>
BST(root.right, target);<br>
if (root.val &gt; target)<br>
BST(root.left, target);<br>
}<br>
二、在 BST 中插入一个数</p>
<p>对数据结构的操作无非遍历 + 访问，遍历就是“找”，访问就是“改”。具体到这个问题，插入一个数，就是先找到插入位置，然后进行插入操作。</p>
<p>上一个问题，我们总结了 BST 中的遍历框架，就是“找”的问题。直接套框架，加上“改”的操作即可。一旦涉及“改”，函数就要返回 TreeNode 类型，并且对递归调用的返回值进行接收。</p>
<pre><code>TreeNode insertIntoBST(TreeNode root, int val) {
    // 找到空位置插入新节点
    if (root == null) return new TreeNode(val);
    // if (root.val == val)
    //     BST 中一般不会插入已存在元素
    if (root.val &lt; val) 
        root.right = insertIntoBST(root.right, val);
    if (root.val &gt; val) 
        root.left = insertIntoBST(root.left, val);
    return root;
}
</code></pre>
<p>三、在 BST 中删除一个数</p>
<p>这个问题稍微复杂，不过你有框架指导，难不住你。跟插入操作类似，先“找”再“改”，先把框架写出来再说：</p>
<p>Java<br>
TreeNode deleteNode(TreeNode root, int key) {<br>
if (root.val == key) {<br>
// 找到啦，进行删除<br>
} else if (root.val &gt; key) {<br>
root.left = deleteNode(root.left, key);<br>
} else if (root.val &lt; key) {<br>
root.right = deleteNode(root.right, key);<br>
}<br>
return root;<br>
}<br>
找到目标节点了，比方说是节点 A，如何删除这个节点，这是难点。因为删除节点的同时不能破坏 BST 的性质。有三种情况，用图片来说明。</p>
<p>情况 1：A 恰好是末端节点，两个子节点都为空，那么它可以当场去世了。<br>
<img src="https://lixin-ee.github.io//post-images/1573303391897.png" alt=""></p>
<pre><code>if (root.left == null &amp;&amp; root.right == null)
    return null;
</code></pre>
<p>情况 2：A 只有一个非空子节点，那么它要让这个孩子接替自己的位置。<br>
<img src="https://lixin-ee.github.io//post-images/1573303420844.png" alt=""></p>
<pre><code>// 排除了情况 1 之后
if (root.left == null) return root.right;
if (root.right == null) return root.left;
</code></pre>
<p>情况 3：A 有两个子节点，麻烦了，为了不破坏 BST 的性质，A 必须找到左子树中最大的那个节点，或者右子树中最小的那个节点来接替自己。我们以第二种方式讲解。<br>
<img src="https://lixin-ee.github.io//post-images/1573303458702.png" alt=""></p>
<pre><code>if (root.left != null &amp;&amp; root.right != null) {
    // 找到右子树的最小节点
    TreeNode minNode = getMin(root.right);
    // 把 root 改成 minNode
    root.val = minNode.val;
    // 转而去删除 minNode
    root.right = deleteNode(root.right, minNode.val);
}
</code></pre>
<p>三种情况分析完毕，填入框架，简化一下代码：</p>
<pre><code>TreeNode deleteNode(TreeNode root, int key) {
    if (root == null) return null;
    if (root.val == key) {
        // 这两个 if 把情况 1 和 2 都正确处理了
        if (root.left == null) return root.right;
        if (root.right == null) return root.left;
        // 处理情况 3
        TreeNode minNode = getMin(root.right);
        root.val = minNode.val;
        root.right = deleteNode(root.right, minNode.val);
    } else if (root.val &gt; key) {
        root.left = deleteNode(root.left, key);
    } else if (root.val &lt; key) {
        root.right = deleteNode(root.right, key);
    }
    return root;
}

TreeNode getMin(TreeNode node) {
    // BST 最左边的就是最小的
    while (node.left != null) node = node.left;
    return node;
} 
</code></pre>
<p>删除操作就完成了。注意一下，这个删除操作并不完美，因为我们一般不会通过 root.val = minNode.val 修改节点内部的值来交换节点，而是通过一系列略微复杂的链表操作交换 root 和 minNode 两个节点。因为具体应用中，val 域可能会很大，修改起来很耗时，而链表操作无非改一改指针，而不会去碰内部数据。</p>
<p>但这里忽略这个细节，旨在突出 BST 基本操作的共性，以及借助框架逐层细化问题的思维方式。<br>
四、最后总结</p>
<p>通过这篇文章，你学会了如下几个技巧：<br>
1.二叉树算法设计的总路线：把当前节点要做的事做好，其他的交给递归框架，不用当前节点操心。<br>
2.如果当前节点会对下面的子节点有整体影响，可以通过辅助函数增长参数列表，借助参数传递信息。<br>
3.在二叉树框架之上，扩展出一套 BST 遍历框架：</p>
<pre><code>void BST(TreeNode root, int target) {
    if (root.val == target)
        // 找到目标，做点什么
    if (root.val &lt; target) 
        BST(root.right, target);
    if (root.val &gt; target)
        BST(root.left, target);
}
</code></pre>
<p>掌握了 BST 的基本操作。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 100. 相同的树[简单]]]></title>
        <id>https://lixin-ee.github.io//post/shu-100-xiang-tong-de-shu-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/shu-100-xiang-tong-de-shu-jian-dan">
        </link>
        <updated>2019-11-09T11:58:46.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定两个二叉树，编写一个函数来检验它们是否相同。<br>
如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。<br>
示例 1:<br>
输入:   1         1<br>
/ \       / <br>
2   3     2   3<br>
[1,2,3],   [1,2,3]<br>
输出: true<br>
示例 2:<br>
输入:   1          1<br>
/           <br>
2             2<br>
[1,2],     [1,null,2]<br>
输出: false<br>
示例 3:<br>
输入:    1         1<br>
/ \       / <br>
2   1     1   2<br>
[1,2,1],   [1,1,2]<br>
输出: false<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/same-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题的难点在于如果单纯地分开判断前中后序的遍历顺序的话是无法得到结果的，只有<br>
1、同时遍历前序<br>
2、利用前序+中序或者中序+后序可以唯一确定一棵二叉树（注意，前序+后序无法唯一确定一棵二叉树）</p>
<p>我还是使用了第一种方法，并且使用递归，会方便很多，主要的难点就在于应付三种情况<br>
1.两者同时为NULL<br>
2.两者其一为NULL<br>
同时因为使用迭代法，所以需要使用一个函数外的bool变量作为返回值</p>
<p>最后代码为：</p>
<pre><code>class Solution {
bool res=true;
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(p==NULL&amp;&amp;q==NULL)
            return res;
        if(p==NULL||q==NULL&amp;&amp;!(p==NULL&amp;&amp;q==NULL)){
            res=false;
            return res;
        }
        if(p-&gt;val!=q-&gt;val){
            res=false;
            return res;
        } 
        isSameTree(p-&gt;left, q-&gt;left);
        isSameTree(p-&gt;right, q-&gt;right);
        return res;
    }
};
</code></pre>
<p>然后来看一下官方题解</p>
<blockquote>
<p>方法一：递归<br>
直觉<br>
最简单的策略是使用递归。首先判断 p 和 q 是不是 None，然后判断它们的值是否相等。<br>
若以上判断通过，则递归对子结点做同样操作。</p>
</blockquote>
<pre><code>class Solution {
  public boolean isSameTree(TreeNode p, TreeNode q) {
    // p and q are both null
    if (p == null &amp;&amp; q == null) return true;
    // one of p and q is null
    if (q == null || p == null) return false;
    if (p.val != q.val) return false;
    return isSameTree(p.right, q.right) &amp;&amp;
            isSameTree(p.left, q.left);
  }
}
</code></pre>
<p>官网题解这里比我好很多，特别是返回值的处理，我用了一个全局变量，但是官方题解直接返回</p>
<blockquote>
<p>方法二：迭代<br>
直觉<br>
从根开始，每次迭代将当前结点从双向队列中弹出。然后，进行方法一中的判断：<br>
p 和 q 不是 None,<br>
p.val 等于 q.val,<br>
若以上均满足，则压入子结点。</p>
</blockquote>
<pre><code>class Solution {
 public boolean check(TreeNode p, TreeNode q) {
   // p and q are null
   if (p == null &amp;&amp; q == null) return true;
   // one of p and q is null
   if (q == null || p == null) return false;
   if (p.val != q.val) return false;
   return true;
 }

 public boolean isSameTree(TreeNode p, TreeNode q) {
   if (p == null &amp;&amp; q == null) return true;
   if (!check(p, q)) return false;

   // init deques
   ArrayDeque&lt;TreeNode&gt; deqP = new ArrayDeque&lt;TreeNode&gt;();
   ArrayDeque&lt;TreeNode&gt; deqQ = new ArrayDeque&lt;TreeNode&gt;();
   deqP.addLast(p);
   deqQ.addLast(q);

   while (!deqP.isEmpty()) {
     p = deqP.removeFirst();
     q = deqQ.removeFirst();

     if (!check(p, q)) return false;
     if (p != null) {
       // in Java nulls are not allowed in Deque
       if (!check(p.left, q.left)) return false;
       if (p.left != null) {
         deqP.addLast(p.left);
         deqQ.addLast(q.left);
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 : O(N)，其中 N 是树的结点数，因为每个结点都访问一次。<br>
空间复杂度 : 最优情况（完全平衡二叉树）时为 O(log(N))，最坏情况下（完全不平衡二叉树）时为 O(N)，用于维护双向队列。</p>
</blockquote>
<p>网友解析：第二种方法是层次遍历的非递归算法</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 102. 二叉树的层次遍历[中等]]]></title>
        <id>https://lixin-ee.github.io//post/shu-102-er-cha-shu-de-ceng-ci-bian-li-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/shu-102-er-cha-shu-de-ceng-ci-bian-li-zhong-deng">
        </link>
        <updated>2019-11-08T11:53:23.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。<br>
例如:<br>
给定二叉树: [3,9,20,null,null,15,7],<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7<br>
返回其层次遍历结果：</p>
</blockquote>
<pre><code>[
  [3],
  [9,20],
  [15,7]
]
</code></pre>
<blockquote>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这里我想复杂了，老是想着如何去把指针移动到同层，其实官方题解就特别简单<br>
如何遍历一棵树<br>
有两种通用的遍历树的策略：<br>
深度优先搜索（DFS）<br>
在这个策略中，我们采用深度作为优先级，以便从跟开始一直到达某个确定的叶子，然后再返回根到达另一个分支。<br>
深度优先搜索策略又可以根据根节点、左孩子和右孩子的相对顺序被细分为先序遍历，中序遍历和后序遍历。<br>
宽度优先搜索（BFS）<br>
我们按照高度顺序一层一层的访问整棵树，高层次的节点将会比低层次的节点先被访问到。<br>
下图中的顶点按照访问的顺序编号，按照 1-2-3-4-5 的顺序来比较不同的策略。<br>
<img src="https://lixin-ee.github.io//post-images/1573214236442.png" alt=""><br>
本问题就是用宽度优先搜索遍历来划分层次：[[1], [2, 3], [4, 5]]。</p>
<p>方法 1：递归<br>
算法<br>
最简单的解法就是递归，首先确认树非空，然后调用递归函数 helper(node, level)，参数是当前节点和节点的层次。程序过程如下：</p>
<p>输出列表称为 levels，当前最高层数就是列表的长度 len(levels)。比较访问节点所在的层次 level 和当前最高层次 len(levels) 的大小，如果前者更大就向 levels 添加一个空列表。<br>
将当前节点插入到对应层的列表 levels[level] 中。<br>
递归非空的孩子节点：helper(node.left / node.right, level + 1)。</p>
<pre><code>class Solution {
    List&lt;List&lt;Integer&gt;&gt; levels = new ArrayList&lt;List&lt;Integer&gt;&gt;();

    public void helper(TreeNode node, int level) {
        // start the current level
        if (levels.size() == level)
            levels.add(new ArrayList&lt;Integer&gt;());

         // fulfil the current level
         levels.get(level).add(node.val);

         // process child nodes for the next level
         if (node.left != null)
            helper(node.left, level + 1);
         if (node.right != null)
            helper(node.right, level + 1);
    }
    
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
        if (root == null) return levels;
        helper(root, 0);
        return levels;
    }
}
</code></pre>
<p>复杂度分析<br>
时间复杂度：O(N)，因为每个节点恰好会被运算一次。<br>
空间复杂度：O(N)，保存输出结果的数组包含 N 个节点的值。</p>
<p>方法 2：迭代<br>
算法<br>
上面的递归方法也可以写成迭代的形式。<br>
我们将树上顶点按照层次依次放入队列结构中，队列中元素满足 FIFO（先进先出）的原则。在 Java 中可以使用 Queue 接口中的 LinkedList实现。在 Python 中如果使用 Queue 结构，但因为它是为多线程之间安全交换而设计的，所以使用了锁，会导致性能不佳。因此在 Python 中可以使用 deque 的 append() 和 popleft() 函数来快速实现队列的功能。<br>
第 0 层只包含根节点 root ，算法实现如下：<br>
初始化队列只包含一个节点 root 和层次编号 0 ： level = 0。<br>
当队列非空的时候：<br>
在输出结果 levels 中插入一个空列表，开始当前层的算法。<br>
计算当前层有多少个元素：等于队列的长度。<br>
将这些元素从队列中弹出，并加入 levels 当前层的空列表中。<br>
将他们的孩子节点作为下一层压入队列中。<br>
进入下一层 level++。<br>
实现</p>
<pre><code>class Solution {
  public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
    List&lt;List&lt;Integer&gt;&gt; levels = new ArrayList&lt;List&lt;Integer&gt;&gt;();
    if (root == null) return levels;

    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();
    queue.add(root);
    int level = 0;
    while ( !queue.isEmpty() ) {
      // start the current level
      levels.add(new ArrayList&lt;Integer&gt;());

      // number of elements in the current level
      int level_length = queue.size();
      for(int i = 0; i &lt; level_length; ++i) {
        TreeNode node = queue.remove();

        // fulfill the current level
        levels.get(level).add(node.val);

        // add child nodes of the current level
        // in the queue for the next level
        if (node.left != null) queue.add(node.left);
        if (node.right != null) queue.add(node.right);
      }
      // go to next level
      level++;
    }
    return levels;
  }
}
</code></pre>
<p>复杂度分析<br>
时间复杂度：O(N)，因为每个节点恰好会被运算一次。<br>
空间复杂度：O(N)，保存输出结果的数组包含 N 个节点的值。</p>
<p>我的第一个实现：</p>
<pre><code>class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; vi;
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {
        leveladd(root,0);
        return vi;
    }
    void leveladd(TreeNode* cur,int level){
        if(cur==NULL)
            return;
        if(level==vi.size())
            vi.push_back(vector&lt;int&gt;());
        vi[level].push_back(cur-&gt;val);
        leveladd(cur-&gt;left,level+1);
        leveladd(cur-&gt;right,level+1);
        return;
    }  
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树 前中后遍历（144、94、145）]]></title>
        <id>https://lixin-ee.github.io//post/er-cha-shu-qian-zhong-hou-bian-li-14494145</id>
        <link href="https://lixin-ee.github.io//post/er-cha-shu-qian-zhong-hou-bian-li-14494145">
        </link>
        <updated>2019-11-08T07:59:03.000Z</updated>
        <content type="html"><![CDATA[<p>这三道题都是大话数据结构里面有的，所以复习一遍大话然后将代码用c++仿真一遍。<br>
<strong>先序遍历</strong></p>
<blockquote>
<p>144 二叉树的前序遍历<br>
给定一个二叉树，返回它的 前序 遍历。</p>
<p>示例:<br>
输入: [1,null,2,3]<br>
1<br>
<br>
2<br>
/<br>
3</p>
<p>输出: [1,2,3]<br>
进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/binary-tree-preorder-traversal<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>递归</p>
<pre><code>class Solution {
vector&lt;int&gt; res;
public:
    vector&lt;int&gt; preorderTraversal(TreeNode* root) {
        if(root==NULL){
            return res;
        }else
            res.push_back(root-&gt;val);
        preorderTraversal(root-&gt;left);
        preorderTraversal(root-&gt;right);
        return res;
    }
};
</code></pre>
<p>算法复杂度<br>
时间复杂度：访问每个节点恰好一次，时间复杂度为 O(N) ，其中 N 是节点的个数，也就是树的大小。<br>
空间复杂度：取决于树的结构，最坏情况存储整棵树，因此空间复杂度是 O(N)。</p>
<p>官方题解：<br>
方法 2：莫里斯遍历<br>
方法基于 莫里斯的文章，可以优化空间复杂度。算法不会使用额外空间，只需要保存最终的输出结果。如果实时输出结果，那么空间复杂度是 O(1)O(1)。</p>
<p>算法<br>
算法的思路是从当前节点向下访问先序遍历的前驱节点，每个前驱节点都恰好被访问两次。<br>
首先从当前节点开始，向左孩子走一步然后沿着右孩子一直向下访问，直到到达一个叶子节点（当前节点的中序遍历前驱节点），所以我们更新输出并建立一条伪边 predecessor.right = root 更新这个前驱的下一个点。如果我们第二次访问到前驱节点，由于已经指向了当前节点，我们移除伪边并移动到下一个顶点。<br>
如果第一步向左的移动不存在，就直接更新输出并向右移动。</p>
<pre><code>class Solution {
  public List&lt;Integer&gt; preorderTraversal(TreeNode root) {
    LinkedList&lt;Integer&gt; output = new LinkedList&lt;&gt;();

    TreeNode node = root;
    while (node != null) {
      if (node.left == null) {
        output.add(node.val);
        node = node.right;
      }
      else {
        TreeNode predecessor = node.left;
        while ((predecessor.right != null) &amp;&amp; (predecessor.right != node)) {
          predecessor = predecessor.right;
        }

        if (predecessor.right == null) {
          output.add(node.val);
          predecessor.right = node;
          node = node.left;
        }
        else{
          predecessor.right = null;
          node = node.right;
        }
      }
    }
    return output;
  }
}
</code></pre>
<p>时间复杂度：每个前驱恰好访问两次，因此复杂度是 O(N)O(N)，其中 NN 是顶点的个数，也就是树的大小。<br>
空间复杂度：我们在计算中不需要额外空间，但是输出需要包含 NN 个元素，因此空间复杂度为 O(N)O(N)</p>
<p><strong>中序遍历</strong></p>
<blockquote>
<p>给定一个二叉树，返回它的中序 遍历。<br>
示例:<br>
输入: [1,null,2,3]<br>
1<br>
<br>
2<br>
/<br>
3<br>
输出: [1,3,2]<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/binary-tree-inorder-traversal<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<pre><code>class Solution {
vector&lt;int&gt; res;
public:
    vector&lt;int&gt; inorderTraversal(TreeNode* root) {
        if(root==NULL)
            return res;
        inorderTraversal(root-&gt;left);
        res.push_back(root-&gt;val);
        inorderTraversal(root-&gt;right);
        return res;   
    }
};
</code></pre>
<p>复杂度分析<br>
时间复杂度：O(n)。递归函数 T(n)=2⋅T(n/2)+1。<br>
空间复杂度：最坏情况下需要空间O(n)，平均情况为O(logn)。</p>
<p>下面是官方题解：<br>
方法二：基于栈的遍历<br>
本方法的策略与上衣方法很相似，区别是使用了栈。</p>
<pre><code>public class Solution {
    public List &lt; Integer &gt; inorderTraversal(TreeNode root) {
        List &lt; Integer &gt; res = new ArrayList &lt; &gt; ();
        Stack &lt; TreeNode &gt; stack = new Stack &lt; &gt; ();
        TreeNode curr = root;
        while (curr != null || !stack.isEmpty()) {
            while (curr != null) {
                stack.push(curr);
                curr = curr.left;
            }
            curr = stack.pop();
            res.add(curr.val);
            curr = curr.right;
        }
        return res;
    }
}
</code></pre>
<p>复杂度分析<br>
时间复杂度：O(n)。<br>
空间复杂度：O(n)。</p>
<p>方法三：莫里斯遍历<br>
本方法中，我们使用一种新的数据结构：线索二叉树。方法如下：<br>
Step 1: 将当前节点current初始化为根节点<br>
Step 2: While current不为空，<br>
若current没有左子节点<br>
a. 将current添加到输出<br>
b. 进入右子树，亦即, current = current.right<br>
否则<br>
a. 在current的左子树中，令current成为最右侧节点的右子节点<br>
b. 进入左子树，亦即，current = current.left<br>
举例而言:<br>
1<br>
/   <br>
2     3<br>
/ \   /<br>
4   5 6</p>
<p>首先，1 是根节点，所以将 current 初始化为 1。1 有左子节点 2，current 的左子树是</p>
<pre><code>     2
    / \
   4   5
</code></pre>
<p>在此左子树中最右侧的节点是 5，于是将 current(1) 作为 5 的右子节点。令 current = cuurent.left (current = 2)。<br>
现在二叉树的形状为:</p>
<pre><code>     2
    / \
   4   5
        \
         1
          \
           3
          /
         6
</code></pre>
<p>对于 current(2)，其左子节点为4，我们可以继续上述过程</p>
<pre><code>    4
     \
      2
       \
        5
         \
          1
           \
            3
           /
          6
</code></pre>
<p>由于 4 没有左子节点，添加 4 为输出，接着依次添加 2, 5, 1, 3 。节点 3 有左子节点 6，故重复以上过程。<br>
最终的结果是 [4,2,5,1,6,3]。</p>
<pre><code>class Solution {
    public List &lt; Integer &gt; inorderTraversal(TreeNode root) {
        List &lt; Integer &gt; res = new ArrayList &lt; &gt; ();
        TreeNode curr = root;
        TreeNode pre;
        while (curr != null) {
            if (curr.left == null) {
                res.add(curr.val);
                curr = curr.right; // move to next right node
            } else { // has a left subtree
                pre = curr.left;
                while (pre.right != null) { // find rightmost
                    pre = pre.right;
                }
                pre.right = curr; // put cur after the pre node
                TreeNode temp = curr; // store cur node
                curr = curr.left; // move cur to the top of the new tree
                temp.left = null; // original cur left be null, avoid infinite loops
            }
        }
        return res;
    }
}
</code></pre>
<p>复杂度分析<br>
时间复杂度：O(n)。 想要证明时间复杂度是O(n)，最大的问题是找到每个节点的前驱节点的时间复杂度。乍一想，找到每个节点的前驱节点的时间复杂度应该是 O(nlogn)，因为找到一个节点的前驱节点和树的高度有关。<br>
但事实上，找到所有节点的前驱节点只需要O(n) 时间。一棵 n 个节点的二叉树只有 n−1 条边，每条边只可能使用2次，一次是定位节点，一次是找前驱节点。<br>
故复杂度为O(n)。<br>
空间复杂度：O(n)。使用了长度为 n 的数组。</p>
<p><strong>后序遍历</strong><br>
给定一个二叉树，返回它的 后序 遍历。<br>
示例:<br>
输入: [1,null,2,3]<br>
1<br>
<br>
2<br>
/<br>
3</p>
<p>输出: [3,2,1]<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/binary-tree-postorder-traversal<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<pre><code>class Solution {
    vector&lt;int&gt; res;
public:
    vector&lt;int&gt; postorderTraversal(TreeNode* root) {
        if(root==NULL) 
            return res; 
        postorderTraversal(root-&gt;left);        
        postorderTraversal(root-&gt;right); 
        res.push_back(root-&gt;val); 
        return res; 
    }
};
</code></pre>
<p>官方迭代题解：<br>
方法 1：迭代<br>
算法<br>
从根节点开始依次迭代，弹出栈顶元素输出到输出列表中，然后依次压入它的所有孩子节点，按照从上到下、从左至右的顺序依次压入栈中。<br>
因为深度优先搜索后序遍历的顺序是从下到上、从左至右，所以需要将输出列表逆序输出。</p>
<pre><code>class Solution {
  public List&lt;Integer&gt; postorderTraversal(TreeNode root) {
    LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();
    LinkedList&lt;Integer&gt; output = new LinkedList&lt;&gt;();
    if (root == null) {
      return output;
    }

    stack.add(root);
    while (!stack.isEmpty()) {
      TreeNode node = stack.pollLast();
      output.addFirst(node.val);
      if (node.left != null) {
        stack.add(node.left);
      }
      if (node.right != null) {
        stack.add(node.right);
      }
    }
    return output;
  }
}
</code></pre>
<p>复杂度分析<br>
时间复杂度：访问每个节点恰好一次，因此时间复杂度为 O(N)，其中 N 是节点的个数，也就是树的大小。<br>
空间复杂度：取决于树的结构，最坏情况需要保存整棵树，因此空间复杂度为 O(N)。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于 无法解析的外部符号 的问题]]></title>
        <id>https://lixin-ee.github.io//post/guan-yu-wu-fa-jie-xi-de-wai-bu-fu-hao-de-wen-ti</id>
        <link href="https://lixin-ee.github.io//post/guan-yu-wu-fa-jie-xi-de-wai-bu-fu-hao-de-wen-ti">
        </link>
        <updated>2019-11-07T09:34:58.000Z</updated>
        <content type="html"><![CDATA[<p>在做课后题13.48的时候定义了自己的String，在编译的时候遇到上述问题<br>
报错分别为<code>error LNK2001: 无法解析的外部符号 &quot;private: static class std::allocator&lt;char&gt; String::alloc&quot;</code><br>
以及</p>
<pre><code>error C4996: 'std::uninitialized_copy::_Unchecked_iterators::_Deprecate': Call to 'std::uninitialized_copy' with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'
1&gt;  c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory(102): note: 参见“std::uninitialized_copy::_Unchecked_iterators::_Deprecate”的声明
</code></pre>
<p>网上找到的解决方案为<br>
首先，C4996这个问题，解决方案：<br>
1、打开project的属性<br>
2、打开c/c++目录<br>
3、点击预处理器<br>
4、在右侧表单中编辑第一条“预处理器定义”<br>
5、将报错提示中的问题填入，我的时_SCL_SECURE_NO_WARNINGS<br>
6、应用确认<br>
或者在头文件前加上：#pragma warning(disable:4996)</p>
<p>接着LNK2001 无法解析的外部符号 &quot;private: static class std::allocator：<br>
原因在于第26行<code>static allocator&lt;char&gt; alloc;</code>，类内静态变量未初始化，删去static或者在类外定义</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 21. 合并两个有序链表[简单]]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-21-he-bing-liang-ge-you-xu-lian-biao-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-21-he-bing-liang-ge-you-xu-lian-biao-jian-dan">
        </link>
        <updated>2019-11-07T01:50:31.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<p>示例：<br>
输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>
输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/merge-two-sorted-lists<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>其实这个在STL源码里面有说过，就是6.5.1 set_union，主要是判断两个链表当前值的大小，先把小的值放到新链表里，如果有一个链表走到尾端了立即停止循环并将另一链表直接接到新链表后面。</p>
<pre><code>class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if(l1==NULL)
            return l2;
        if(l2==NULL)
            return l1;
        ListNode* ehead=new ListNode(-1);
        ListNode* cur=ehead;
        while(l1!=NULL||l2!=NULL){
            if(l1-&gt;val&lt;=l2-&gt;val){
                cur-&gt;next=l1;
                l1=l1-&gt;next;
            }else{
                cur-&gt;next=l2;
                l2=l2-&gt;next;
            }
            cur=cur-&gt;next;
            if(l1==NULL){
                cur-&gt;next=l2;break;}
            if(l2==NULL){
                cur-&gt;next=l1;break;}
        }
        return ehead-&gt;next;
    }
};
</code></pre>
<p>当时做这道题的时候是在家里，没法对照着STL源码来写，对比了一下，主要的差异点在于<br>
1.最后接上链表的操作，其实可以直接两个都接上，因为肯定有一个为空，不需要判断两次<br>
2.set需要判断相等的情况，而链表不需要</p>
<p>然后看一下题解吧<br>
首先是递归的：<br>
思路<br>
标签：链表、递归<br>
这道题可以使用递归实现，新链表也不需要构造新节点，我们下面列举递归三个要素<br>
终止条件：两条链表分别名为 l1 和 l2，当 l1 为空或 l2 为空时结束<br>
返回值：每一层调用都返回排序好的链表头<br>
本级递归内容：如果 l1 的 val 值更小，则将 l1.next 与排序好的链表头相接，l2 同理O(m+n)，m 为 l1的长度，n 为 l2 的长度</p>
<pre><code>class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if(l1 == null) {
            return l2;
        }
        if(l2 == null) {
            return l1;
        }

        if(l1.val &lt; l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        } else {
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }
    }
}
</code></pre>
<p>复杂度分析</p>
<p>时间复杂度：O(n+m)。 因为每次调用递归都会去掉 l1 或者 l2 的头元素（直到至少有一个链表为空），函数 mergeTwoList 中只会遍历每个元素一次。所以，时间复杂度与合并后的链表长度为线性关系。</p>
<p>空间复杂度：O(n+m)。调用 mergeTwoLists 退出时 l1 和 l2 中每个元素都一定已经被遍历过了，所以n+m 个栈帧会消耗 O(n+m) 的空间。</p>
<p>方法 2：迭代<br>
想法<br>
我们可以用迭代的方法来实现上述算法。我们假设 l1 元素严格比 l2元素少，我们可以将 l2 中的元素逐一插入 l1 中正确的位置。</p>
<p>算法<br>
首先，我们设定一个哨兵节点 &quot;prehead&quot; ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 prev 指针，我们需要做的是调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：如果 l1 当前位置的值小于等于 l2 ，我们就把 l1 的值接在 prev 节点的后面同时将 l1 指针往后移一个。否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都把 prev 向后移一个元素。</p>
<p>在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表。</p>
<pre><code>class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode* prehead = new ListNode(-1);
        ListNode* prev = prehead;
        while(l1 != NULL &amp;&amp; l2 != NULL) {
            if(l1-&gt;val &lt;= l2-&gt;val) {
                prev-&gt;next = l1;
                l1 = l1-&gt;next;
            } else {
                prev-&gt;next = l2;
                l2 = l2-&gt;next;
            }
            prev = prev-&gt;next;
        }
        prev-&gt;next = l1 != NULL ? l1 : l2;

        return prehead-&gt;next;
    }
};
</code></pre>
<p>时间复杂度：O(n+m) 。因为每次循环迭代中，l1 和 l2 只有一个元素会被放进合并链表中， while 循环的次数等于两个链表的总长度。所有其他工作都是常数级别的，所以总的时间复杂度是线性的。<br>
空间复杂度：O(1) 。迭代的过程只会产生几个指针，所以它所需要的空间是常数级别的。</p>
<p>果然还是递归优雅一点hhh</p>
]]></content>
    </entry>
</feed>