<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-09-18T02:56:00.881Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[C++ primer 第七章 笔记+习题 7.4-7.6]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-qi-zhang-bi-ji-xi-ti-74-76</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-qi-zhang-bi-ji-xi-ti-74-76">
        </link>
        <updated>2019-09-17T11:33:12.000Z</updated>
        <content type="html"><![CDATA[<p>7.4<br>
一个类就是一个作用域<br>
一旦遇到类名，定义的剩余部分就在类的作用域之内了，包括<strong>参数列表和函数体</strong>，所以参数列表内的参数不需要再声明类<br>
但返回类型出现在类名之前，所以要想把类成员作为返回类型，<strong>必须在返回类型前加上类名</strong></p>
<p>习题7.33<br>
pos的作用域并不在类里面，需要改成Screen::pos</p>
<p>7.4.1名字查找与类的作用域<br>
编译器处理完类中的<strong>全部声明后才会处理成员函数的定义</strong>，所以成员函数体中可以使用类中定义的任何名字，<strong>但是类型名不同，必须定义在一开始，否则会找不到</strong><br>
如果某个成员的声明使用了类中尚未出现的名字，编译器将会在定义该类的作用域中继续查找<br>
如果成员使用了外层作用域中的某个名字，<strong>则该名字代表一种类型</strong>，类不可以在之后重新定义该名字，合法但不应该在类内重新定义<br>
typedef int type_out;  class C{ type_out i; typedef double type_out;//<strong>合法但不应该</strong>在类内重新定义}<br>
类型名的定义通常出现在类的开始处（using typedef）<br>
可以通过作用域运算符来访问不同作用域中的同名运算符</p>
<p>习题7.34<br>
有问题！！类型名和类数据成员名字不同，必须定义在一开始，否则会找不到<br>
习题7.35<br>
类内不应该再定义Type 但合法，所以内部的都是 double，但 外部定义的函数返回类型用的是string的Type</p>
<p>7.5.1构造函数初始值列表<br>
我们定义变量时习惯于立即对其进行初始化，而非先定义再赋值<br>
如果没有在构造函数的初始值列表中显式地初始化成员，则该成员将在构造函数体之前执行<strong>默认初始化</strong><br>
如果成员是<strong>const、引用，或者属于某种未提供默认构造函数的类类型</strong>，我们必须通过构造函数初始值列表为这些成员提供初值初始化，不能通过后续赋值<br>
在初始值列表中初始值的前后位置关系不会影响实际的初始化顺序<br>
最好令构造函数初始值列表中初始值的顺序与成员声明的顺序保持一致，而且尽量避免使用某些成员初始化其他成员，最好用构造函数的参数作为成员的初始值<br>
默认构造函数和提供了默认实参的构造函数功能相同<br>
如果一个构造函数为<strong>所有参数提供了默认实参，则它实际上也定义了默认构造函数</strong><br>
并非所有的参数都应该有一个默认值</p>
<p>习题7.36<br>
其实是合法的，只是不应该使用base，因为在初始值列表中初始值的前后位置关系不会影响实际的初始化顺序，所以base%J是未知的<br>
习题7.37<br>
第一种调用了第三个 next调用了第一个默认函数  last调用了第一个为&quot;9-999-99999-9&quot;<br>
知识点：如果一个构造函数为<strong>所有参数提供了默认实参，则它实际上也定义了默认构造函数</strong><br>
习题7.38<br>
Sales_data(std::istream &amp;is){ read(is,*this);}<br>
习题7.39<br>
不合法，这样子它就定义了两个默认构造函数，有二义性<br>
知识点：如果一个构造函数为<strong>所有参数提供了默认实参，则它实际上也定义了默认构造函数</strong><br>
习题7.40</p>
<pre><code> class Employee
{   
string EmployeeID;//员工号
string name;//员工姓名
int age;//员工年龄
char sex;//员工性别
string CompanyName;//所属公司
}
</code></pre>
<p>7.5.2委托构造函数<br>
委托构造函数，使用其所在类中的其他构造函数来执行它想要的初始化过程<br>
委托构造函数参数列表必须与类中的另外一个构造函数匹配<br>
当一个构造函数委托给另一个构造函数时，<strong>受委托的构造函数的初始值列表和函数体中的内容依次执行，然后控制权才会交还给委托着的函数体</strong>（例子中的{read(is,*this);}）</p>
<p>习题7.41</p>
<pre><code>Sales_Data(string &amp;s,int &amp;i,double &amp;p,double &amp;a):ISBN(s),units_sold(i),price(p),ave(a){ cout &lt;&lt; &quot;three parameters construction&quot; &lt;&lt; endl; }
		Sales_Data(string &amp;s) :Sales_Data(s, 0, 0) { cout &lt;&lt; &quot;string construction&quot; &lt;&lt; endl; }
		Sales_Data(istream &amp;is) :Sales_Data() { read(is, *this); cout &lt;&lt; &quot;istream construction&quot; &lt;&lt; endl;
		}
		Sales_Data() :Sales_Data(&quot; &quot;, 0, 0) { cout &lt;&lt; &quot;default construction&quot; &lt;&lt; endl; }
</code></pre>
<p>习题7.42<br>
其实就和7.41差不多啦！</p>
<p>7.5.3默认构造函数的作用<br>
value initialization<br>
那么如果在list initialization形式中，没有任何args，也就是<br>
[new] T [object] {};<br>
这时就称为值初始化。这个初始化类型的名字其实有点不明确，按我的理解，实质应该叫做“广义默认初始化”。因为值初始化一般是三种处理方式：<br>
如果T有用户定义的默认构造函数，直接调用；<br>
如果T有编译器生成的默认构造函数，先0值初始化再调用；<br>
如果T根本不是类，直接0值初始化。<br>
而以上三种其实都可以看作默认初始化。<br>
default initialization<br>
[new] T object;<br>
默认初始化除了在值初始化过程中可能进行之外，也可以以上面形式单独进行。这种初始化的独特地方在于，如果T是非class类型，则给出非确定值（不赋值），比如：<br>
int i; double d; bool b;<br>
其实这也就是兼容最早的C行为。<br>
zero initialization<br>
0值初始化除了在值初始化过程中可能进行之外，也可以单独作用于静态（或者线程局部）变量：<br>
static T object;</p>
<p>小结<br>
所有其他初始化形式都是list initialization的特殊表现形式或者与其相关。理解的要点在于，list中的参数要么按构造函数的参数声明顺序，要么按aggregate类型成员声明顺序，逐个赋值。当某些成员没有被这样显示给定值时，进行广义默认初始化（value initialization）：或调用默认构造函数，或赋0值。这么看来，这一堆初始化其实挺符合我们的一贯认知。<br>
习题 7.43</p>
<pre><code>class C{
	NoDefault D;
	C():D(0){}
}
</code></pre>
<p>习题7.44<br>
不合法，NoDefault是一个类，仅仅定义了有十个NoDefault类型的对象，而NoDefault没有默认构造函数，必须初始化<br>
习题7.45<br>
合法，有默认构造函数，可以进行值初始化<br>
习题7.46<br>
（a）错误 系统会自动合成（b）错误 所有形参都有默认实参的也是默认构造函数 （c）不对，应该提供 （d）错误，数据成员类型为类类型时，无法生成默认构造函数</p>
<p>7.5.4隐式的类类型转换<br>
如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，并把这种构造函数称作转换构造函数。比如Sales_data类中，接受string的构造函数实际上定义了string向Sales_data隐式转换的规则，在需要使用Sales_data的地方可以使用string来代替。 比如 string s=”9-999-99999-9”; item.combine(s);//combine为Sales_data的成员<strong>可以给常量引用传递一个临时量！普通引用的话这里会报错</strong><br>
编译器只会自动地执行一步类型转换，而不能进行连续两次隐式类型转换,比如：item.combine(”9-999-99999-9”);//先转为string，再转为类类型。<strong>(注意此处是指需要类类型的地方，而不是指构造函数，Sales_data item(“9-999-99999-9”)还是正确的)</strong> 可以Sales_data item（string（“9-999-99999-9”））<br>
<strong>explicit</strong>抑制构造函数定义的隐式转换，只对一个实参的构造函数有效<br>
需要多个实参的构造函数不能用于执行隐式转换，所以无须将这些构造函数指定为explicit<br>
explicit只能在类内声明构造函数时使用，在类外部定义时不应该重复<br>
使用explicit关键字声明构造函数时只能以直接初始化的形式（括号）使用，而且编译器不会在自动转换过程中使用该构造函数<br>
仍可以对explicit声明的构造函数进行显式地强制转换 item.combine(Sales_data(s));</p>
<p>习题7.47<br>
优点：防止用户用了错误的类型进行初始化从而得到不符合初衷的值，保证了程序的严谨性，缺点就是可能要进行显式转换。<br>
习题7.48<br>
（a）const char* 到string的转换<br>
（b）string 到类类型的转换<br>
（c）正确，<br>
习题7.49<br>
（b）错误，无法从string向引用进行转换（a）和（c）都是正确的<br>
知识点：<strong>可以给常量引用传递一个临时量！</strong><br>
习题7.50<br>
单个参数的构造函数都可以设置为explicit<br>
习题7.51<br>
string需要向下兼容c语言，而vector不需要</p>
<p>7.5.5聚合类<br>
聚合类使得用户可以直接访问其成员，并且具有特殊的初始化语法<br>
聚合类的特性：1.所有成员都是public的2.没有定义任何构造函数3，<strong>没有类内初始值</strong>4.没有基类，也没有virtual函数<br>
对聚合类进行初始化的初始值的顺序<strong>必须与声明的顺序一致</strong>，且初始值列表的元素个数不能超过类的成员数量 例如 struct Data{int ival; string s}   Data val={0,”Anna”};//这里的顺序不可以反过来<br>
如果初始值列表中的元素个数<strong>少于</strong>类的成员数量，<strong>则靠后的成员被值初始化</strong></p>
<p>习题7.52<br>
下面的初始化希望将Sales_data 视为一个聚合类，但是Sales_data的数据成员具有初始值，所以无法当做聚合类进行初始化，并且没有合适的构造函数，两个解决办法 1.去掉初始值，变为聚合类 2.增加接受三个参数的构造函数</p>
<p>7.5.6字面值常量类<br>
构造函数<strong>不可以是const</strong>的，但<strong>字面值常量类的构造函数可以是constexpr函数</strong>，并且必须至少提供一个constexpr构造函数<br>
constexpr构造函数必须符合<strong>构造函数的要求（不能包含返回语句）</strong>，又要<strong>符合constexpr函数的要求（只能执行返回语句）</strong>，所以constexpr构造函数体<strong>一般为空</strong><br>
constexpr构造函数<strong>必须初始化所有数据成员</strong></p>
<p>习题7.53</p>
<pre><code>class Debug
{
public:
	constexpr Debug(bool b=true):hw(b),io(b),other(b){}
	constexpr Debug(bool h ,bool i,bool o) : hw(h),io(i), other(o) {}
	void set_hw(bool h = true) { hw = h; }
	void set_io(bool i = true) { io = i; }
	void set_other(bool o = true) { other = o; }
private:
	bool hw;
	bool io;
	bool other;

};
</code></pre>
<p>习题7.54<br>
不应该，set需要执行相应的赋值操作。同时constexpr函数必须有返回值和返回语句<br>
习题7.55<br>
不是。字面值常量类至少必须含有一个constexpr构造函数，同时string不是字面值类型</p>
<p>7.6 类的静态成员<br>
static 静态成员<strong>与类关联，而与特定的对象无关（等于每个对象都可以通用的成员）所以静态成员应该在类外定义，否则每创建一个对象就会被定义一次</strong><br>
静态成员可以是private或者public，静态数据成员的类型可以是常量、引用、指针、类类型等等。<br>
类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据，同时静态成员函数<strong>也不与任何对象绑定在一起，不包含this 指针，不能被声明为const</strong><br>
使用作用域运算符来直接访问静态成员，也可以使用类的对象、引用或者指针来访问<br>
成员函数不用通过作用域运算符就能直接使用静态成员<br>
静态成员函数也可以在类外部进行定义，<strong>但不能重复static关键字</strong>，static只出现在类内部的声明语句<br>
<strong>静态成员不是由类的构造函数初始化的</strong>，不能在类的内部初始化静态成员，<strong>必须在类的外部定义和初始化每个静态成员</strong><br>
一个静态数据成员只能定义一次<br>
静态数据成员定义在任何函数之外，因此存在于程序的整个生命周期中<br>
把静态数据成员的定义和其他非内联函数的定义放在同一个文件中，确保对象只定义一次<br>
例外：可以在类内部初始化constexpr的静态成员，但必须提供const整数类型的类内初始值（常量表达式） 例如 static constexpr int i =10;//<strong>必须是constexpr，不能是const</strong><br>
如果仅仅用于类内，则在类内已经初始化的const或者constexpr static不需要分别定义，否则必须有一条定义语句<br>
特别地，<strong>静态数据成员的类型可以是它所属的类类型</strong>（等于不完全类型），而<strong>非静态数据成员只能声明成它所属的类的指针或引用</strong><br>
静态成员<strong>可以作为默认实参</strong>，非静态数据成员则不能</p>
<p>习题7.56<br>
类的静态成员只与类相关联，而与特定的对象无关，优点在于可以独立于特定的对象 ，其作用域存在与整个程序运行期间。<br>
习题7.57</p>
<pre><code>class Account
{
	static constexpr int period = 30;
	double daily_tbl[period];
	std::string owner;
	double amount;
	static double interestRate;
	static double initRate();
public:
	static double rate() { return interestRate; }
	static void rate(double);
};
</code></pre>
<p>习题7.58<br>
rate显示定义错误，必须为常量成员。需要加上const或者constexpr<br>
vec在类内的定义被误认为是要定义一个函数了，它的直接初始化和函数定义的括号是冲突的，从而显示从vecsize不是类型名，应该在外部声明时才使用example::vec(example::vecsize)<br>
vec显示声明不兼容，两个声明冲突了；</p>
<p>习题感悟<br>
类型名和类数据成员名字不同，必须定义在一开始，否则会找不到<br>
如果成员使用了外层作用域中的某个名字，<strong>则该名字代表一种类型</strong>，类不可以在之后重新定义该名字，合法但不应该<strong>在类内重新定义</strong><br>
在初始值列表中初始值的前后位置关系不会影响实际的初始化顺序，所以用一个成员来初始化另一个成员，结果是未知的<br>
如果一个构造函数为<strong>所有参数提供了默认实参，则它实际上也定义了默认构造函数</strong><br>
可以给常量引用传递一个临时量！<br>
可以在类内部初始化constexpr的静态成员，但必须提供const整数类型的类内初始值（常量表达式） 例如 static constexpr int i =10;//<strong>必须是constexpr，不能是const</strong><br>
<code>static constexpr int vecsize = 20; vector&lt;double&gt; vec(vecsize);</code><br>
vec在类内的定义被误认为是要定义一个函数了，它的直接初始化和函数定义的括号是冲突的，从而显示从vecsize不是类型名，应该在外部声明时才使用</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 123. 买卖股票的最佳时机 III]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-123-mai-mai-gu-piao-de-zui-jia-shi-ji-iii</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-123-mai-mai-gu-piao-de-zui-jia-shi-ji-iii">
        </link>
        <updated>2019-09-17T07:04:48.000Z</updated>
        <content type="html"><![CDATA[<p>原题如下：</p>
<blockquote>
<p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。<br>
设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。<br>
注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:<br>
输入: [3,3,5,0,0,3,1,4]<br>
输出: 6<br>
解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。<br>
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。<br>
示例 2:<br>
输入: [1,2,3,4,5]<br>
输出: 4<br>
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。  <br>
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。  <br>
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。<br>
示例 3:<br>
输入: [7,6,4,3,1]<br>
输出: 0<br>
解释: 在这个情况下, 没有交易完成, 所以最大利润为 0。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题的难度远远大于前面两道的难度，我尝试了从前面累加和后面累加都无效，主要是受到最大交易次数2的影响，以及存在着特殊例子如{ 1,2,4,2,5,7,2,4,9,0 }这种需要把两次购买合并成一次购买的情况，很明显感觉到自己的思路有缺陷，一开始给出的未能通过的代码如下：</p>
<pre><code>class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        int len=prices.size();
        if(len==0||len==1){
            return 0;
        }
        int profit=0 ;
        int profit1=0,profit2=0;
        for(int i=0;i&lt;len-1;++i){
            if(prices[i+1]-prices[i]&gt;=0)
                profit +=prices[i+1]-prices[i];
            if(prices[i+1]-prices[i]&lt;0||i==len-2){
                if(profit&gt;profit1)
                    profit2=profit1,profit1=profit;
                else if(profit&gt;profit2)
                    profit2=profit;
                profit=0;
            }
        }
        return profit1+profit2;
    }
};
</code></pre>
<p>这一次没有官方题解，不过有一个比较精彩的个人题解，关于动态规划的，总结了所有的股票买卖问题的统一解题思路，我感觉还不错，不过篇幅过长，而且涉及后面多道题目，所以单独给出一篇文章吧<br>
符合动态规划的代码如下（注意，非最终代码，仍有很大的优化空间）：</p>
<pre><code>class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        const int n = prices.size();
        if(n==0||n==1)
            return 0;
	const int max_k = 2;
	vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(n, vector&lt;vector&lt;int&gt;&gt;(max_k+1, vector&lt;int&gt;(2,0)));
	for (int i = 0; i &lt; n; i++) {
		for (int k = 1; k &lt;=2 ; k++) {
			if (i - 1 == -1) { 
				dp[0][k][0] = 0 ;
				dp[0][k][1] = - prices[0];
			}
			else {
				dp[i][k][0] = dp[i - 1][k][0]&gt;dp[i - 1][k][1] + prices[i] ? dp[i - 1][k][0] : dp[i - 1][k][1] + prices[i];
				dp[i][k][1] = dp[i - 1][k][1]&gt;dp[i - 1][k - 1][0] - prices[i] ? dp[i - 1][k][1] : dp[i - 1][k - 1][0] - prices[i];
			}
		}
	}
	return dp[n - 1][max_k][0];
    }
};
</code></pre>
<p>优化版本，因为k比较小，完全可以直接穷举出来</p>
<pre><code>	vector&lt;int&gt; prices{ 1,2,4,2,5,7,2,4,9,0 };
	const int n = prices.size();
	const int max_k = 2;
	int dp_i10 = 0, dp_i11 = -9999999;
	int dp_i20 = 0, dp_i21 = -9999999;

	for (int i = 0; i &lt; n; i++) {
		
			dp_i20 = dp_i20&gt;dp_i21 + prices[i] ? dp_i20:dp_i21 + prices[i];
			dp_i21 = dp_i21&gt;dp_i10 - prices[i] ? dp_i21:dp_i10 - prices[i];
			dp_i10 = dp_i10&gt;dp_i11 + prices[i] ? dp_i10:dp_i11 + prices[i];
			dp_i11 = dp_i11&gt;-prices[i] ? dp_i11:-prices[i];
			
		}
	

	return  dp_i20;
</code></pre>
<p>感想：这道题可是足足搞了我两天，期间也算是有不少的事吧，特别是被原题解中有些不太恰当的地方误导了，足足花了一个上午的手写仿真和代码验证才纠正过来，同时这个误导也使得我中途好几次怀疑自我，没有坚持看下来，但是所幸最后还是坚持了下来了，还是继续加油吧。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第七章 笔记+习题 7.1-7.3]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-qi-zhang-bi-ji-xi-ti-71-73</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-qi-zhang-bi-ji-xi-ti-71-73">
        </link>
        <updated>2019-09-16T00:49:30.000Z</updated>
        <content type="html"><![CDATA[<p>7类<br>
类的基本思想是数据抽象和封装，数据抽象是一种依赖于接口和实现分离的编程技术。类的接口包括用户所能执行的操作，类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数<br>
封装实现了类的接口和实现的分离，隐藏了类的实现细节<br>
类要想实现数据抽象和封装，需要首先定义一个抽象数据类型</p>
<p>习题7.1<br>
Sale_data.h</p>
<pre><code>#ifndef SALES_DATA_H
#define SALES_DATA_H

#include &lt;iostream&gt;
#include &lt;string&gt;

using std::string;
using std::cin;
using std::cout;
using std::istream;
using std::ostream;

struct Sales_Data {
	public:
		string ISBN;
		int units_sold = 0;
		double price = 0.00;
		double ave = 0.00;

		string isbn() {
			return ISBN;
		}

		bool equal_isbn(Sales_Data exam)const {
			return ((*this).ISBN == exam.ISBN);
		}

		Sales_Data&amp; combine(Sales_Data&amp; data) {
			if ((*this).equal_isbn(data)) {
				Sales_Data sum;
				sum.units_sold = (*this).units_sold + data.units_sold;
				sum.ave = ((*this).units_sold*(*this).price + data.units_sold*data.price) / sum.units_sold;
				sum.price = sum.ave;
				return sum;
			}
			else
			{
				std::cerr &lt;&lt; &quot;Data must have same ISBN&quot; &lt;&lt; std::endl;
			}
		}
};

bool read(istream &amp;in, Sales_Data&amp; data) {
	if (in &gt;&gt; data.ISBN &gt;&gt; data.units_sold &gt;&gt; data.price) {
		data.ave = data.price*data.units_sold / data.units_sold;
		return true;
	}
	return false;
}

Sales_Data&amp; add(Sales_Data&amp; data1, Sales_Data&amp; data2) {
	if (data1.equal_isbn(data2)) {
		Sales_Data sum;
		sum.units_sold = data1.units_sold + data2.units_sold;
		sum.ave = (data1.units_sold*data1.price + data2.units_sold*data2.price) / sum.units_sold;
		sum.price = sum.ave;
		return sum;
	}
	else
	{
		std::cerr &lt;&lt; &quot;Data must have same ISBN&quot; &lt;&lt; std::endl;
	}
}

void print(ostream &amp;os, Sales_Data&amp; data) {
	os &lt;&lt; data.ISBN &lt;&lt; ' ' &lt;&lt; data.price &lt;&lt; ' ' &lt;&lt; data.units_sold &lt;&lt; ' ' &lt;&lt; data.ave &lt;&lt; ' ';
}


#endif // !SALES_DATA_H
#pragma once
</code></pre>
<p>homework7.1.cpp</p>
<pre><code>#include &quot;Sales_data.h&quot;

using namespace std;

int main() {
	Sales_Data total;
	if (read(cin, total)) {
		Sales_Data trans;
		while (read(cin, trans)) {
			if (total.equal_isbn(trans))
				total.combine(trans);
			else {
				print(cout, total);
				total = trans;
			}
		}
		print(cout, total);
	}
	else {
		cerr &lt;&lt; &quot;No data?!&quot; &lt;&lt; endl;
		return -1;
	}
	return 0;
}
</code></pre>
<p>注意 total = trans；这里未处理好，应该重载符号=或者定义拷贝赋值函数。<br>
知识点：注意成员函数和非成员函数的选择和安排</p>
<p>7.1.2定义改进的Sales_data类<br>
成员函数的声明必须在类的内部，定义则既可以类内部也可以在类外部<br>
<strong>非成员函数定义和声明都在类的外部</strong><br>
定义在类内部的函数是隐式的<strong>inline函数</strong><br>
成员函数通过this这个额外的隐式参数来访问调用它的那个对象<br>
在成员函数内部，可以直接调用该函数的对象的成员，而无须通过成员访问运算符<br>
this是一个<strong>常量指针</strong>，不允许改变其保存的地址<br>
Type func() const { }紧跟在参数列表后的<strong>const表示this是一个指向常量的指针</strong>，这样使用const的成员函数被称为<strong>常量成员函数</strong>，用于表示常量成员函数不能改变调用它的对象的内容<br>
<strong>非成员函数不能使用const限定符</strong><br>
this不能够显式地定义<br>
常量对象及其引用或指针都只能调用常量成员函数<br>
类本身就是一个作用域<br>
成员函数可以调用<strong>后面才定义的数据成员</strong>，因为类编译首先编译成员声明，然后才轮到成员函数<br>
类外部定义的成员的名字必须包含它所属的类名</p>
<p>习题7.2<br>
如习题7.1所示，isbn和combine我都先设置为成员函数<br>
习题7.3<br>
如习题7.1所示，就是=号拷贝赋值函数还未重载<br>
习题7.4</p>
<pre><code>#ifndef PERSON_H
#define PERSON_H
#include &lt;string&gt;
#include &lt;iostream&gt;

using std::string;

class Person
{
public:

	string name;
	string adress;
#endif // !PERSON_H
#pragma once
</code></pre>
<p>知识点：别忘了头文件保护符（预处理变量），有效避免重复定义<br>
习题7.5<br>
应该是const的，因为这些返回操作不应该有修改数据的权限</p>
<p>7.1.3定义类相关的非成员函数<br>
非成员函数在操作上从概念上属于类的接口的组成部分，但是他们<strong>实际并不属于类的本身</strong>，定义的时候也不需要作用域符 class：：<br>
如果非成员函数是类接口的组成部分，则这些函数的声明应该与类（的声明）在同一个头文件内<br>
在形参列表中IO类属于不能被拷贝的类型，<strong>只能通过引用来传递</strong>它们，同时读取写入都会改变流的内容，<strong>所以不能用常量引用</strong><br>
输出输入的非成员函数应该<strong>返回输出输入流的引用</strong> 例如 istream&amp; func(){}</p>
<p>习题7.6</p>
<pre><code>istream&amp; read(istream &amp;is, Sales_Data&amp; data) {
	is &gt;&gt; data.ISBN &gt;&gt; data.units_sold &gt;&gt; data.price;
	data.ave = data.price*data.units_sold / data.units_sold;
	return is;
}

ostream&amp; print(ostream &amp;os, const Sales_Data&amp; data) {
	os &lt;&lt; data.ISBN &lt;&lt; ' ' &lt;&lt; data.price &lt;&lt; ' ' &lt;&lt; data.units_sold &lt;&lt; ' ' &lt;&lt; data.ave &lt;&lt; ' ';
	return os;
}


Sales_Data&amp; add(Sales_Data&amp; data1, Sales_Data&amp; data2) {
	if (data1.equal_isbn(data2)) {
		Sales_Data sum;
		sum.units_sold = data1.units_sold + data2.units_sold;
		sum.ave = (data1.units_sold*data1.price + data2.units_sold*data2.price) / sum.units_sold;
		sum.price = sum.ave;
		return sum;
	}
	else
	{
		std::cerr &lt;&lt; &quot;Data must have same ISBN&quot; &lt;&lt; std::endl;
	}
}
</code></pre>
<p>知识点：输出输入的非成员函数应该<strong>返回输出输入流的引用</strong><br>
习题7.7<br>
上面已经用到了（有点疑惑习题的安排）<br>
习题7.8<br>
read 需要改动类数据成员，而print不应该对类进行改动<br>
知识点：非成员函数不能使用const限定符<br>
习题7.9<br>
上面已经用到了<br>
习题7.10<br>
对data1 和data2的输入操作进行判断</p>
<p>7.1.4 构造函数<br>
构造函数 属于<strong>成员函数</strong>，用于初始化类对象的<strong>数据成员</strong><br>
只要类的对象被<strong>创建</strong>，就会执行构造函数<br>
构造函数 <strong>没有返回类型</strong><br>
类可以包含多个构造函数<br>
构造函数<strong>不能被声明成const</strong>，但是构造函数可以在构造过程中<strong>对const对象写值</strong>，因为直到构造函数<strong>完成初始化过程后对象才能真正获得const属性</strong><br>
如果没有定义构造函数，就会使用默认构造函数<br>
编译器创建的构造函数又被称为合成的默认构造函数，如果存在类内初始值，用来初始化成员，否则默认初始化<br>
1.只有当类没有声明任何构造函数时，编译器才会自动生成默认构造函数<br>
2.内置类型或复合类型（数组或指针）默认初始化为<strong>未定义</strong>，只有当这些成员全都被赋予了类内的初始值时，这个类才适合于使用合成的默认构造函数（否则使用默认构造函数时这些类型很危险）<br>
3.编译器不能为某些类合成默认的构造函数，比如类中包含其他类类型的成员并且这个成员的类型没有默认构造函数，<br>
= default 要求编译器生成构造函数 既可以和声明一起出现在类的内部，也可以作为定义出现在类的外部 例子 Sales_data() = default;<br>
如果 = default 在类的内部，则默认构造函数是内联函数，可以直接展开，在类的外部则默认情况下不是内联的<br>
如果编译器不支持类内初始值，那么默认构造函数应该使用构造函数初始值列表<br>
构造函数初始值列表<br>
<code>Sales_data(const std::string &amp;s,unsigned n,double p): bookNo(s),units_sold(n),revenue(p\*n) { }</code><br>
没有包含在构造函数初始值列表中的数据成员将会使用与<strong>合成默认构造函数相同的方式</strong>被隐式初始化<br>
只要定义了其他构造函数，都必须使用 = default;，<strong>保证所有成员都被初始化</strong></p>
<p>习题7.11</p>
<pre><code>Sales_Data() = default;
		Sales_Data(string &amp;s,int &amp;i,double &amp;p,double &amp;a):ISBN(s),units_sold(i),price(p),ave(a){}
		Sales_Data(string &amp;s) :ISBN(s) {}
</code></pre>
<p>习题7.12</p>
<pre><code>Sales_Data(istream &amp;is) { read(is, *this); }
</code></pre>
<p>习题7.13<br>
<code>Sales_Data total(cin);</code><br>
习题7.14<br>
<code>Sales_Data():units_sold(0), price(0.00), ave(0.00) {}</code><br>
知识点：显式默认初始化是不需要形参列表的<br>
习题7.15</p>
<pre><code>	Person()=default;
	Person(string&amp; n, string&amp;a) :name(n),address(a){};
</code></pre>
<p>7.1.5 拷贝、赋值和析构<br>
拷贝、赋值、销毁对象时发生的行为也需要定义，如果不主动定义，编译器会替我们合成它们</p>
<p>7.2 访问控制与封装<br>
使用<strong>访问说明符</strong>来加强类的封装性<br>
public：在整个程序内都可被访问，用于<strong>定义类的接口</strong><br>
private：可以被类的成员函数访问，但是不能被使用该类的代码访问，封装了类的实现细节<br>
访问说明符可以只用一次声明一堆对象，因为其有效范围直到出现下一个访问说明符或者到达类的结尾处，也可以在每个对象前添加<br>
public可用于构造函数和部分成员函数，private一般用于数据成员和显示部分的函数<br>
class和struct都可以用于定义类，唯一区别是定义对象的默认访问权限不同，在class中，无访问说明符的成员定义默认为private，<strong>struct中则默认为public</strong><br>
<strong>构造函数也可以设置为private</strong>，但是一旦设置为private，只有本类内部可以调用构造函数，就只能通过public的成员函数来构造这个类了</p>
<p>习题7.16<br>
没有限定，类的接口应该定义在public后，具体的实现应该封装在private内部<br>
习题7.17<br>
如果没有定义访问说明符的话，class的默认访问说明符为private，struct则为public<br>
习题7.18<br>
封装实现了类的接口和实现的分离，封装后的类隐藏了它的实现细节，累的用户只能使用接口而无法访问实现部分<br>
习题7.19<br>
暂时所有都是public，因为这些操作都属于接口，用户对其进行访问是对类无害的</p>
<p>7.2.1友元<br>
友元 允许其他类或者函数访问它的非公有成员<br>
在类内增加一条以friend关键字开头的函数声明<br>
友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限（可以最前可以最后，一般在最前），友元不是类的成员，也不受所在区域访问控制级别的约束<br>
友元的声明仅仅指定了访问的权限，并非一个通常意义上的函数声明，所以如果希望类的用户能够调用某个友元的函数，那么就必须在友元声明之外专门对函数进行一次声明，通常会把友元的声明和类本身放置在同一个头文件中（类的外部）<br>
友元会破坏封装性</p>
<p>习题7.20<br>
主要给非成员函数使用，利在于增强了非成员函数的功能和便利性，弊处在于破坏了类的封装性<br>
习题7.21<br>
Sales_data的实现都是可以公开的，所以可以全部设置为public，但是注意，构造函数也可以设置为private，但是一旦设置为private，只有本类内部可以调用构造函数，就只能通过public的成员函数来构造这个类了<br>
习题7.22<br>
如题7.19</p>
<p>7.3 类的其他特性<br>
7.3.1类成员再谈<br>
类型成员：自定义某种类型在类中的别名引用 using typedef也可以设置访问限制<br>
使用类型别名可以隐藏类实现的细节，增加封装性<br>
类型别名必须先定义后使用，类型成员通常出现在类开始的地方<br>
成员函数也可以重载<br>
mutable 可变数据成员 永远不会是const，即使它是const对象的成员<br>
mutable int acess_num; void func() const{ ++acess_num;} //记录函数调用次数<br>
const成员函数也可以改变一个可变成员的值<br>
类内初始值必须用=或者花括号来初始化</p>
<p>习题7.23</p>
<pre><code>class Screen
{
private:
	typedef string::size_type pos;
	typedef string str;

public:
	pos cursor = 0;
	pos height = 0, width = 0;
	string contents;
};
</code></pre>
<p>习题7.24</p>
<pre><code>Screen()=default;
	Screen(pos ht, pos wd) :height(ht), width(wd), contents(ht*wd, ' ') {}
	Screen(pos ht, pos wd, char c) :height(ht), width(wd), contents(ht*wd, c) {}
</code></pre>
<p>习题7.25<br>
可以，数据成员主要是int和string，其都定义了相应的拷贝和赋值操作，如果是类就不行了。<br>
习题7.26<br>
内联成员函数直接在函数前面加上inline就好，声明定义、内部外部都可以</p>
<p>7.3.2返回*this的成员函数<br>
返回当前对象 *this的引用可以使程序连续执行，比如myScreen.move().set()<br>
当返回的类型<strong>不是引用</strong>时，将会返回其<strong>拷贝的副本</strong>, 比如move直接返回Screen 而非&amp;Screen的话，set()只能改变一个临时副本的值，而不能改变myScrenn的值，<strong>但是注意副本的值也会进行set</strong>，只是本身没有改变<br>
<strong>const成员函数只能返回const 引用</strong>，比如如果move()改为常量成员函数，则返回常量引用，set()将引发错误<br>
<strong>注意！引用没有顶层const和底层const之分，引用可以说是天生有顶层const（引用必须初始化，初始化后不能更改绑定的对象）</strong><br>
当一个成员函数内部调用另一个成员函数时，this指针在其中隐式地传递，<br>
如果类内重载函数中含有完全相同的操作，最好把相同的操作定义为一个内联私有函数</p>
<p>习题7.27</p>
<pre><code>Screen &amp;move(pos r, pos c) {
		pos row = r*width;
		cursor = row + c;
		return *this;
	}

	inline Screen &amp;set(char c) {
		contents[cursor]=c;
		return *this;
	}

	ostream &amp;display(ostream &amp;os) const {
		os &lt;&lt; contents;
		return os;
	}
	ostream &amp;display(ostream &amp;os)  {
		os &lt;&lt; contents;
		return os;
	}
</code></pre>
<p>知识点：注意要记得return *this;<br>
习题7.28<br>
move和set完全不起作用，因为返回的是一个拷贝的副本，所以后续的函数都只是对整个副本进行操作，对原对象本身不会有变动，所以第一个输出有#号，第二个没有！！！<br>
习题7.29<br>
正确<br>
习题7.30<br>
1使用this可以返回对调用该函数的对象的引用。<br>
2：可以非常明确地指出访问的是调用该函数的对象的成员，且可以在成员函数中使用与数据成员同名的形参。<br>
缺点：不必要使用，代码多余。（参考CSDN MISAYAONE）</p>
<p>7.3.3类类型<br>
即使两个类内部完全一样，也是<strong>不同的类型，不可以互相拷贝赋值</strong><br>
类可以先声明再定义，先声明未定义的时候称为<strong>前向声明</strong>，此时是一个<strong>不完全类型</strong>，只能用于1.<strong>定义</strong>指向这种类型的<strong>指针或者引用</strong>2.<strong>声明（不能定义）</strong> 以不完全类型作为<strong>参数或者返回类型的函数</strong><br>
类必须先定义才能创建对象<br>
只有当类全部完成后类才算被定义，所以<strong>类的成员类型不可以是该类自己</strong>，但是声明后的类允许包含指向它自身类型的<strong>引用或指针</strong>。</p>
<p>习题7.31</p>
<pre><code>class X
{
public:
	Y *y;
};

class Y
{
public:
	X x;
};
</code></pre>
<p>7.3.4再探友元<br>
可以将非成员函数、其他类、其他类的成员函数定义为友元<br>
将其他类的成员函数定义为友元的步骤：1.首先定义类a的，其中声明函数a1，但不能定义它2.定义类b，包括对于函数a1的友元声明3.最后定义a1，才能使用类b的成员<br>
重载函数等同于<strong>不同的多个函数</strong>，需要对每一个函数<strong>单独进行声明</strong><br>
就算是在类内部定义使用的友元函数，也必须在类的外部提供声明从而使得函数可见，因为<strong>友元声明并非普通意义上的声明</strong>，作用只是影响访问权限</p>
<p>习题7.32</p>
<pre><code>class Window_mgr
{
public:
	void clear();
};

class Screen
{
public:
	friend void Window_mgr::clear();
};

void Window_mgr::clear() {
}
</code></pre>
<p>习题感悟：知识点：注意成员函数和非成员函数的选择和安排<br>
知识点：别忘了头文件保护符（预处理变量），有效避免重复定义<br>
输出输入的非成员函数应该<strong>返回输出输入流的引用</strong><br>
知识点：非成员函数不能使用const限定符<br>
<strong>显式</strong>默认初始化是不需要形参列表的：<br>
<code>Sales_Data():units_sold(0), price(0.00), ave(0.00) {}</code><br>
构造函数也可以设置为private，但是一旦设置为private，只有本类内部可以调用构造函数，就只能通过public的成员函数来构造这个类了<br>
内联成员函数直接在函数前面加上inline就好，声明定义、内部外部都可以<br>
注意要记得return *this;<br>
当连续函数返回的是一个拷贝的副本，后续的函数都仍会对整个副本进行操作，只是对原对象本身不会有变动，所以第一个输出可以有#号，第二个没有！！！myScreen.move(4, 0).set('#').display(cout);//副本输出仍会有#号的改动</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 122. 买卖股票的最佳时机 II]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-122-mai-mai-gu-piao-de-zui-jia-shi-ji-ii</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-122-mai-mai-gu-piao-de-zui-jia-shi-ji-ii">
        </link>
        <updated>2019-09-15T13:15:44.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>官方题目：<br>
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。<br>
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:<br>
输入: [7,1,5,3,6,4]<br>
输出: 7<br>
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。<br>
示例 2:<br>
输入: [1,2,3,4,5]<br>
输出: 4<br>
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。<br>
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题一开始还是有有点难倒我的，老是想着怎么找最大差值，但是转念一想，既然可以参加多次交易，那岂不是可以穿越到第二天发现升值了就马上回到前一天买下来？那就是非常简单的正差值相加了，代码如下：</p>
<pre><code>class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        int len=prices.size();
        int max=0;
        vector&lt;int&gt; profit(len,0);
        for(int i=1;i&lt;len;++i)
            profit[i]=prices[i]-prices[i-1];
        for(int i=0;i&lt;len;++i)
            if(profit[i]&gt;0)
                max +=profit[i];
        return max;
    }
};
</code></pre>
<p>这一题也是一次过，不过其实看了官方题解发现还是可以有很多可以提升的地方的，比如profit这个数组提高了空间复杂度，完全可以将差值作为判断条件。以下是官方题解：<br>
摘要<br>
我们必须确定通过交易能够获得的最大利润（对于交易次数没有限制）。为此，我们需要找出那些共同使得利润最大化的买入及卖出价格。</p>
<blockquote>
<p>解决方案<br>
方法一：暴力法<br>
这种情况下，我们只需要计算与所有可能的交易组合相对应的利润，并找出它们中的最大利润。</p>
</blockquote>
<pre><code>Java
class Solution {
    public int maxProfit(int[] prices) {
        return calculate(prices, 0);
    }

    public int calculate(int prices[], int s) {
        if (s &gt;= prices.length)
            return 0;
        int max = 0;
        for (int start = s; start &lt; prices.length; start++) {
            int maxprofit = 0;
            for (int i = start + 1; i &lt; prices.length; i++) {
                if (prices[start] &lt; prices[i]) {
                    int profit = calculate(prices, i + 1) + prices[i] - prices[start];
                    if (profit &gt; maxprofit)
                        maxprofit = profit;
                }
            }
            if (maxprofit &gt; max)
                max = maxprofit;
        }
        return max;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n^n)，调用递归函数 n^n次。<br>
空间复杂度：O(n)，递归的深度为 n。</p>
<p>方法二：峰谷法<br>
算法<br>
假设给定的数组为：<br>
[7, 1, 5, 3, 6, 4]<br>
如果我们在图表上绘制给定数组中的数字，我们将会得到<br>
如果我们分析图表，那么我们的兴趣点是连续的峰和谷。<br>
用数学语言描述为：<br>
TotalProfit= ∑ (height(peaki)−height(valleyi))<br>
关键是我们需要考虑到紧跟谷的每一个峰值以最大化利润。如果我们试图跳过其中一个峰值来获取更多利润，那么我们最终将失去其中一笔交易中获得的利润，从而导致总利润的降低。<br>
例如，在上述情况下，如果我们跳过 peak_i	 和 valley_j<br>
试图通过考虑差异较大的点以获取更多的利润，获得的净利润总是会小与包含它们而获得的静利润，因为 C 总是小于 A+B。</p>
</blockquote>
<pre><code>Java
class Solution {
    public int maxProfit(int[] prices) {
        int i = 0;
        int valley = prices[0];
        int peak = prices[0];
        int maxprofit = 0;
        while (i &lt; prices.length - 1) {
            while (i &lt; prices.length - 1 &amp;&amp; prices[i] &gt;= prices[i + 1])
                i++;
            valley = prices[i];
            while (i &lt; prices.length - 1 &amp;&amp; prices[i] &lt;= prices[i + 1])
                i++;
            peak = prices[i];
            maxprofit += peak - valley;
        }
        return maxprofit;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)。遍历一次。<br>
空间复杂度：O(1)。需要常量的空间。</p>
<p>方法三：简单的一次遍历<br>
算法<br>
该解决方案遵循 方法二 的本身使用的逻辑，但有一些轻微的变化。在这种情况下，我们可以简单地继续在斜坡上爬升并持续增加从连续交易中获得的利润，而不是在谷之后寻找每个峰值。最后，我们将有效地使用峰值和谷值，但我们不需要跟踪峰值和谷值对应的成本以及最大利润，但我们可以直接继续增加加数组的连续数字之间的差值，如果第二个数字大于第一个数字，我们获得的总和将是最大利润。这种方法将简化解决方案。<br>
这个例子可以更清楚地展现上述情况：<br>
[1, 7, 2, 3, 6, 7, 6, 7]<br>
与此数组对应的图形是：<br>
从上图中，我们可以观察到 A+B+C 的和等于差值 D 所对应的连续峰和谷的高度之差。</p>
</blockquote>
<pre><code>Java
class Solution {
    public int maxProfit(int[] prices) {
        int maxprofit = 0;
        for (int i = 1; i &lt; prices.length; i++) {
            if (prices[i] &gt; prices[i - 1])
                maxprofit += prices[i] - prices[i - 1];
        }
        return maxprofit;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)，遍历一次。<br>
空间复杂度：O(1)，需要常量的空间。</p>
</blockquote>
<p>暴力解就没啥好说的了，太暴力啦！，题解三就是和我给出的解一致，同时也给了我提示可以直接直接对差值进行判断，而不用再声明一个新的数组。然后题解二虽然过程比题解三复杂，但是它可以定位到最后取值的峰值和谷值所在，也算是一种取舍吧</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 121. 买卖股票的最佳时机]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-121-mai-mai-gu-piao-de-zui-jia-shi-ji</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-121-mai-mai-gu-piao-de-zui-jia-shi-ji">
        </link>
        <updated>2019-09-15T13:01:40.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目如下：<br>
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>
如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。<br>
注意你不能在买入股票前卖出股票。</p>
<p>示例 1:<br>
输入: [7,1,5,3,6,4]<br>
输出: 5<br>
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>
注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。<br>
示例 2:<br>
输入: [7,6,4,3,1]<br>
输出: 0<br>
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这一题还是相对简单很多的，一开始我的想法比较钻牛角尖，总是想着找出最小值再找相应的最大值，然后如果差值不是最大的话再找次小值，还得考虑先后blabla~然后突然发现其实值得大小其实和下标关系不大，完全可以记录一个最大值，然后不断地更新当前最小值和当前值的差，甚至于不管最小值是啥时候出现，反正你要是出现的时候能够推翻当前最大值，那之前出现的次小值也肯定比不上你呀，所以给出了如下题解，一次过！棒棒哒！：</p>
<pre><code>class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        int len=prices.size();
        if(len==0||len==1)
            return 0;
        int min=prices[0];
        int max=0;
        for(int i=0;i&lt;len;++i){
            min=prices[i]&lt;min?prices[i]:min;
            max=prices[i]-min&gt;max?prices[i]-min:max;
        }
        return max; 
    }
};
</code></pre>
<p>官方题解如下:</p>
<blockquote>
<p>解决方案<br>
我们需要找出给定数组中两个数字之间的最大差值（即，最大利润）。此外，第二个数字（卖出价格）必须大于第一个数字（买入价格）。<br>
形式上，对于每组 i 和 j（其中 j &gt; i）我们需要找出max(prices[j]−prices[i])。<br>
方法一：暴力法</p>
</blockquote>
<pre><code>Java
public class Solution {
    public int maxProfit(int prices[]) {
        int maxprofit = 0;
        for (int i = 0; i &lt; prices.length - 1; i++) {
            for (int j = i + 1; j &lt; prices.length; j++) {
                int profit = prices[j] - prices[i];
                if (profit &gt; maxprofit)
                    maxprofit = profit;
            }
        }
        return maxprofit;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n^2)。循环运行n(n−1)/2 次。<br>
空间复杂度：O(1)O(1)。只使用了两个变量 —— maxprofit 和profit。<br>
方法二：一次遍历<br>
算法<br>
假设给定的数组为：<br>
[7, 1, 5, 3, 6, 4]</p>
<p>如果我们在图表上绘制给定数组中的数字，我们将会得到：<br>
使我们感兴趣的点是上图中的峰和谷。我们需要找到最小的谷之后的最大的峰。<br>
我们可以维持两个变量——minprice 和 maxprofit，它们分别对应迄今为止所得到的最小的谷值和最大的利润（卖出价格与最低价格之间的最大差值）。</p>
</blockquote>
<pre><code>Java
public class Solution {
    public int maxProfit(int prices[]) {
        int minprice = Integer.MAX_VALUE;
        int maxprofit = 0;
        for (int i = 0; i &lt; prices.length; i++) {
            if (prices[i] &lt; minprice)
                minprice = prices[i];
            else if (prices[i] - minprice &gt; maxprofit)
                maxprofit = prices[i] - minprice;
        }
        return maxprofit;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)，只需要遍历一次。<br>
空间复杂度：O(1)，只使用了两个变量。</p>
</blockquote>
<p>暴力法就没啥好讲的了，我的方法和官方题解二吻合，然后比较有趣的是有个精选题解，从数学的角度分析了题解二的可行性，非常有趣，就是牛顿莱布尼茨公式666，有时间的话复习的时候应该看一下！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 45. 跳跃游戏 II]]></title>
        <id>https://lixin-ee.github.io//post/45-tiao-yue-you-xi-ii</id>
        <link href="https://lixin-ee.github.io//post/45-tiao-yue-you-xi-ii">
        </link>
        <updated>2019-09-15T12:44:57.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个非负整数数组，你最初位于数组的第一个位置。<br>
数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>
你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<p>示例:<br>
输入: [2,3,1,1,4]<br>
输出: 2<br>
解释: 跳到最后一个位置的最小跳跃数是 2。<br>
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。<br>
说明:<br>
假设你总是可以到达数组的最后一个位置。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/jump-game-ii<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>其实本来这道题应该蛮简单的，难点主要在于最小跳跃数这个限制，一开始我总想着从后往前推，但是一直无法把握好跳跃点增加的时机，所以一直是解答出错，加上一直被奇葩的特殊情况干扰，最终确定想法有比较大的缺陷，决定观看官方题解，首先给出最后的错解：</p>
<pre><code>int len = nums.size();
        int jump=0;
        if(len==0||nums[0]==0||len==1)
            return 0;
        for(int i=len-2;i&gt;0;--i){
            while(i&gt;=0&amp;&amp;nums[i]&gt;=len-i-1)
                --i;
            ++jump;
        }
        return jump;
</code></pre>
<p>我觉得我做题比较严重的一个问题就是老是从某些比较简单的解出发，所以总是会被例外的情况所击倒，现在回头看来代码还是很有问题的，更应该去寻找能够达到当前位置的最小值，而不是遇到不可达值就停下来。下面是官方题解：</p>
<blockquote>
<p>解题思路：<br>
从数组的第 0 个位置开始跳，跳的距离小于等于数组上对应的数。求出跳到最后个位置需要的最短步数。比如上图中的第 0 个位置是 2，那么可以跳 1 个距离，或者 2 个距离，我们选择跳 1 个距离，就跳到了第 1 个位置，也就是 3 上。然后我们可以跳 1，2，3 个距离，我们选择跳 3 个距离，就直接到最后了。所以总共需要 2 步。</p>
<p>解法一 ：顺藤摸瓜<br>
LeetCode 讨论里，大部分都是这个思路，贪婪算法，我们每次在可跳范围内选择可以使得跳的更远的位置。<br>
如下图，开始的位置是 2，可跳的范围是橙色的。然后因为 3 可以跳的更远，所以跳到 3 的位置。<br>
如下图，然后现在的位置就是 3 了，能跳的范围是橙色的，然后因为 4 可以跳的更远，所以下次跳到 4 的位置。<br>
写代码的话，我们用 end 表示当前能跳的边界，对于上边第一个图的橙色 1，第二个图中就是橙色的 4，遍历数组的时候，到了边界，我们就重新更新新的边界。</p>
</blockquote>
<pre><code>Java
public int jump(int[] nums) {
    int end = 0;
    int maxPosition = 0; 
    int steps = 0;
    for(int i = 0; i &lt; nums.length - 1; i++){
        //找能跳的最远的
        maxPosition = Math.max(maxPosition, nums[i] + i); 
        if( i == end){ //遇到边界，就更新边界，并且步数加一
            end = maxPosition;
            steps++;
        }
    }
    return steps;
}
</code></pre>
<blockquote>
<p>时间复杂度：O(n)。<br>
空间复杂度：O(1)。<br>
这里要注意一个细节，就是 for 循环中，i &lt; nums.length - 1，少了末尾。因为开始的时候边界是第 0 个位置，steps 已经加 1 了。如下图，如果最后一步刚好跳到了末尾，此时 steps 其实不用加 1 了。如果是 i &lt; nums.length，i 遍历到最后的时候，会进入 if 语句中，steps 会多加 1。</p>
<p>解法二：顺瓜摸藤<br>
我们知道最终要到达最后一个位置，然后我们找前一个位置，遍历数组，找到能到达它的位置，离它最远的就是要找的位置。然后继续找上上个位置，最后到了第 0 个位置就结束了。<br>
至于离它最远的位置，其实我们从左到右遍历数组，第一个满足的位置就是我们要找的。</p>
</blockquote>
<pre><code>Java
public int jump(int[] nums) {
    int position = nums.length - 1; //要找的位置
    int steps = 0;
    while (position != 0) { //是否到了第 0 个位置
        for (int i = 0; i &lt; position; i++) {
            if (nums[i] &gt;= position - i) {
                position = i; //更新要找的位置
                steps++;
                break;
            }
        }
    }
    return steps;
}
</code></pre>
<blockquote>
<p>时间复杂度：O(n²)，因为最坏的情况比如 1 1 1 1 1 ，position 会从 5 更新到 0，并且每次更新都会经历一个 for 循环。<br>
空间复杂度：O(1)。</p>
<p>这种想法看起来更简单了，为什么奏效呢？我们可以这样想。<br>
从左到右跳的话，2 -&gt; 3 -&gt; 4 -&gt; 1。<br>
从右到左的话，我们找能跳到 11 的最左边的位置，我们找的只能是 44 或者是 44 左边的。<br>
找到 4 的话，不用说，刚好完美。<br>
如果是中间范围 3 和 4 之间的第 2 个 1 变成了 3，那么这个位置也可以跳到末尾的 1，按我们的算法我们就找到了这个 3，也就是 4 左边的位置。但其实并不影响我们的 steps，因为这个数字是 3 到 4 中间范围的数，左边界 3 也可以到这个数，所以下次找的话，会找到边界 3，或者边界 3 左边的数。 会不会直接找到上个边界 2 呢？不会的，如果找到了上一个边界 2，那么意味着从 2 直接跳到 3 和 4 之间的那个数，再从这个数跳到末尾就只需 2 步了，但是其实是需要 3 步的。</p>
</blockquote>
<p>官方题解一这个最大范围end非常奇妙，其实和1中的非常相似，用end来作为标志递增steps刚刚好能够得到最小的steps，妙啊！（其实如果我能好好运用上一题<br>
的知识也能得到这个解，一种醍醐灌顶的感觉），题解二就是我一直在挣扎的倒推解题法了，还是那句话，找到最左边的能到达当前点的位置才是正解。最后给出解答：</p>
<pre><code>class Solution {
public:
    int jump(vector&lt;int&gt;&amp; nums) {
       int len = nums.size();
        if(len==0||nums[0]==0||len==1)
            return 0;
        int jump=0;
        int max_reach=0;
        int end=0;
        for(int i=0;i&lt;len-1;++i){
            max_reach= max_reach&gt;nums[i]+i?max_reach:nums[i]+i;
            if(i==end){
                ++jump;
                end=max_reach;
            }
        }
        return jump;
            
    }
};
</code></pre>
<p>最后感想还是得好好整理复习前面的题，这样后面的题才能把知识灵活应用起来！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第六章 笔记+习题 6.3-6.7]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-liu-zhang-bi-ji-xi-ti-63-67</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-liu-zhang-bi-ji-xi-ti-63-67">
        </link>
        <updated>2019-09-12T11:48:50.000Z</updated>
        <content type="html"><![CDATA[<p>6.3.1无返回值函数<br>
return语句终止当前正在执行的函数并将控制权返回到调用函数的地方<br>
void函数会在最后隐式执行return语句，<br>
void函数可以return另一个返回值为void的函数，不能返回其他类型的表达式<br>
6.3.2有返回值函数<br>
编译器不一定能发现漏掉return语句的错误<br>
返回值用于初始化调用点的一个临时量<br>
最好返回的是对象的引用，否则会返回返回值的拷贝副本<br>
不要返回局部对象的引用或指针<br>
如果返回类型是引用，不能返回局部对象的引用或者局部临时量如“abc”但可以直接返回对象（区分局部对象）而不是必须是引用（因为原则上引用就是一个别名）<br>
调用返回引用的函数得到左值，其他返回类型得到右值<br>
函数可以返回花括号包围的值的类型，比如vector，如果是内置类型则花括号包围的列表最多包含一个值，如果是类类型，由类本身定义。<br>
主函数main可以没有return语句，会在结尾隐式插入return 0；<br>
返回非0值的具体含义由机器决定，所以cstdlib 头文件中定义了两个通用的预处理变量 EXIT_FAILURE和EXIT_SUCCESS，其与机器无关，两者皆为预处理变量既不能加上std::，也不能用using声明<br>
递归 函数自己调用自己<br>
main函数不能调用自己</p>
<p>习题6.30<br>
error C2561: “str_subrange”: 函数必须返回值<br>
习题6.31<br>
返回的引用指向了函数中定义的局部变量或者局部常量<br>
习题6.32<br>
合法，将ia的每个元素赋值为相应的下标值<br>
习题6.33</p>
<pre><code>void print(vector&lt;int&gt; v, int index);

int main() {
	vector&lt;int&gt; ia = { 1,2,3,4,5,6,7,8,9,0 };
	print(ia, 0);
};
void print(vector&lt;int&gt; v,int index){
	if (index &lt; v.size())
		cout &lt;&lt; v[index] &lt;&lt; endl,print(v,++index);
}
</code></pre>
<p>习题6.34<br>
如果输入一个负数，将陷入死循环直至内存崩溃。<br>
习题6.35<br>
val--是对val递减后传入val原本值的副本，会造成无限循环</p>
<p>6.3.3 返回数组指针<br>
无法返回数组，但可以返回指向大小确定的数组的引用或指针<br>
返回数组指针的函数声明为 type （*函数名（形参列表））[数组维度]<br>
所以建议使用类型别名，decltype 或尾置返回类型<br>
<code>int array[10]; decltype(array) *func(int); auto func(int) -&gt;int(*)[10]；</code></p>
<p>习题6.36<br>
<code>string(&amp;func())[10]</code><br>
习题6.37</p>
<pre><code>typedef string re[10]; using re=string[10];re &amp;func();
decltype(string [10]) &amp;func();
auto func()-&gt;string(&amp;)[10]
</code></pre>
<p>声明时尾置返回最好，定义时类型别名和decltype最好，这样可读性高<br>
知识点：注意尾置返回中指针和引用必须加括号string(&amp;)[10] string(*)[10]<br>
习题6.38<br>
其实就是把*号换成&amp;号 函数体内的&amp;去除</p>
<p>6.4函数重载<br>
函数重载 名字相同形参列表不同（<strong>返回类型可以不同，但不能只有返回类型的不同</strong>）<br>
main函数不能重载<br>
不允许两个函数除了返回类型外其他要素都相同，如果其他要素都相同只有返回类型不同则后一个函数声明是错误的<br>
<strong>形参有无名字不影响判断，形参的名字不同类型相同的话，仍视为同一函数</strong><br>
如果仅仅是函数名不同，则视为类型别名，也视为与原名相同<br>
<strong>形参无视顶层const</strong> 所以有顶层const形参和没有顶层const的形参是<strong>等价的</strong><br>
所以func(int *param) 和func(int * const param) 是相同的，注意const的位置<br>
func(const int * param) 则是新函数<br>
指向常量的指针只能传递给底层const形参，<strong>不能传给普通指针形参</strong><br>
使用const_cast在重载中对变量进行强制转换，去除底层const</p>
<p>习题6.39<br>
（a）形参是顶层const 然而形参会无视const，所以等于重复声明<br>
（b）返回值改为double 但是仅仅有返回类型不同，所以等于重复声明<br>
（c）形参类型和返回类型改变了，是合法的</p>
<p>6.4.1重载与作用域<br>
在内层作用域中无法进行重载，只会隐藏外层作用域中声明的同名实体<br>
c++中 名字查找发生在类型检查之前，一旦在当前作用域找到了所需的名字，编译器就会忽略掉外层作用域的同名实体，再进行类型检测确认函数调用是否有效</p>
<p>6.5.1默认实参<br>
默认实参 就是缺省值<br>
通常应该在函数声明中指定默认实参，并将该声明放在合适的头文件中,例如：<br>
<code>void func(int param1=1,int param2=10,char param3 = 'p');</code><br>
注意一旦某个形参被赋予默认值，<strong>后面的所有形参都必须有默认值</strong><br>
如果想覆盖右侧的默认值，必须也覆盖前面的默认值<br>
在给定的作用域中一个形参<strong>只能被赋予一次</strong>默认实参，函数的后续声明只能为之前那些没有默认值的形参添加默认实参<br>
默认实参的<strong>初始化</strong>可以是表达式，不能是局部变量，变量的声明必须出现在函数之外<br>
用作默认实参的名字在函数声明的作用域内解析，<strong>可以通过实参名改变默认实参值，但是新定义的同名变量无法隐藏外层的默认实参变量</strong>，例如在另外一个函数中用于默认实参值的变量值a变化了，同时会改变默认实参的a，但是如果在内层作用域定义一个新的a，并不会影响外层声明中的a<br>
<strong>经常使用默认实参的变量放在后面，不常使用的放在前面</strong></p>
<p>习题6.40<br>
b是错误的，默认实参应该在后面，否则只要有实参就不能使用默认实参<br>
习题6.41<br>
a错误，至少需要一个参数，c合法但初衷不符，wd会被赋予'*'的ASCII码，不能越过某个默认实参改变后面的默认实参。<br>
习题6.42</p>
<pre><code>string make_plural(size_t ctr, const string &amp;word, const string &amp;ending = &quot;s&quot;);

int main() {
	cout &lt;&lt; &quot;两单词的单数形式：&quot; &lt;&lt; make_plural(1, &quot;success&quot;, &quot;es&quot;) &lt;&lt; &quot;  &quot; &lt;&lt; make_plural(1, &quot;failure&quot;) &lt;&lt; endl;
	cout &lt;&lt; &quot;两单词的复数形式：&quot; &lt;&lt; make_plural(2, &quot;success&quot;, &quot;es&quot;) &lt;&lt; &quot;  &quot; &lt;&lt; make_plural(2, &quot;failure&quot;) &lt;&lt; endl;
};

string make_plural(size_t ctr, const string &amp;word, const string &amp;ending) {
	return (ctr &gt; 1) ? word + ending : word;
}
</code></pre>
<p>知识点：默认实参定义在函数的声明，不需要定义在函数的定义！！！</p>
<p>6.5.2内联函数和constexpr函数<br>
内联函数 在调用点上召开为一段程序 避免函数调用的开销<br>
内联函数关键字inline 适用于规模小频繁调用的函数<br>
Constexpr函数<strong>返回类型和形参类型都是字面值类型</strong>（引用 指针 算术类型）（自定义类、IO库、string类等就不是字面值类型），函数体内有且只有一条return语句，被隐式地指定为内联函数<br>
比如 constexpr int func() { return 42; }<br>
Constexpr函数<strong>允许返回值并非一个常量</strong>，所以不一定返回常量表达式(传入常量表达式，返回常量表达式，反之则返回非常量表达式)<br>
与其他函数不同，内联函数和Constexpr函数 <strong>可以多次定义，但需要保持一致</strong>，所以通常定义在头文件中</p>
<p>习题6.43<br>
（a）声明和定义都在头文件<br>
（b）声明在头文件，定义在源文件<br>
知识点：因为内联函数可以定义多次，万一以后错手定义会很麻烦，为了保证一致最好定义在头文件，普通函数则只能定义一次，所以只需要放在源文件。<br>
习题6.44<br>
直接在返回类型前面加上inline就vans了<br>
习题6.45<br>
简短而且常用的函数可以定义为内联函数<br>
习题6.46<br>
不可以，string不是字面值类型</p>
<p>6.5.3调试帮助<br>
arrest 预处理宏 一个预处理变量，arrest宏定义在carrest头文件中<br>
arrest（expr），判断为假则输出信息终止程序，输出为真则什么都不做，用于检查不能发生的条件，例如<br>
assert(word.size() &gt; threshold)；<br>
宏名字在程序内必须唯一，所以不能定义与宏名字相同的变量、函数等<br>
NDEBUG决定了 arrest是否执行检查，是否开启调试状态，如果定义了就等于关闭，未定义就等于开启。<br>
详细例子可看笔记</p>
<p>习题6.47</p>
<pre><code>void print(vector&lt;int&gt; v, int index);

int main() {
	vector&lt;int&gt; ia = { 1,2,3,4,5,6,7,8,9,0 };
	print(ia, 0);
};
void print(vector&lt;int&gt; v, int index) {
	if (index &lt; v.size()) {
#ifndef NDEBUG
		cout &lt;&lt; v.size() &lt;&lt; endl;
#endif // !NDEBUG
		cout &lt;&lt; v[index] &lt;&lt; endl, print(v, ++index);
	}	
}
</code></pre>
<p>习题6.48<br>
不合理，while已经对cin进行判断了，并且只要cin有输入就为真，并非不能发生的条件</p>
<p>6.6 函数匹配<br>
第一步 候选函数（一与被调用函数同名，二其声明在调用点可见）<br>
第二步 考察本次调用提供的实参，选出能被实参调用的可行函数（一是形参与本次调用提供的实参数量相等，二是实参类型与对应的形参类型相同，或者能转换成形参的类型）<br>
第三步 最佳匹配<br>
实参类型和形参类型越接近匹配得越好<br>
该函数每个实参的匹配都不劣于其他可行函数需要的匹配<br>
至少有一个实参的匹配优于其他可行函数提供的匹配</p>
<p>习题6.49<br>
候选函数：本次调用对应的重载函数集 1.与被调用函数同名 2.其声明在调用点可见。<br>
可行函数，从候选函数中选出的能被实参调用的函数 1.实参形参数量匹配 2.类型匹配或可转换<br>
习题6.50<br>
（a）二义性了，可以选择转化为double或者int<br>
（b）f（int）<br>
（c）f（int，int）<br>
（d）f（double，double）<br>
习题6.51</p>
<pre><code>void f();
void f(int);
void f(int, int);
void f(double, double = 3.14);
int main() {
	//f(2.56, 42);//有多个重载函数示例与实参列表匹配
	f(42);
	f(42, 0);
	f(2.56, 3.14);
};
void f(){
	cout &lt;&lt; &quot;f()&quot; &lt;&lt; endl;
}
void f(int){
	cout &lt;&lt; &quot;f(int)&quot; &lt;&lt; endl;
}
void f(int, int){
	cout &lt;&lt; &quot;f(int, int)&quot; &lt;&lt; endl;
}
void f(double, double ){
	cout &lt;&lt; &quot;f(double,double = 3.14)&quot; &lt;&lt; endl;
}
</code></pre>
<p>6.6.1实参类型转换<br>
const转换:可以将指向类型T的指针或引用转换成指向const T的指针或引用，例如 int i; const int &amp;j=i;<br>
类型提升：也就是short、char等提升为int等<br>
算术类型转换：运算过程中 小对象的类型转化为另外一个大的对象的类型<br>
指针转换：0和nullptr能够转换成任意指针类型，指向任意非常量的指针可以转换成void*，指向任意常量的指针可以转换成const void*，派生继承关系中的派生类和基类的指针转换<br>
小整型short一般会提升到int类型，使用short类型的函数反而会导致类型转换<br>
所有算数类型转换的级别一样</p>
<p>习题6.52<br>
（a）3.类型提升匹配 （b）4.算术类型转换<br>
习题6.53<br>
（a）重载<br>
（b）重载<br>
（c）忽略顶层const，和第一句其实一样，不合法</p>
<p>6.7函数指针<br>
声明一个指向函数的指针，<strong>只需要用指针替换函数名即可（不要漏掉括号）</strong><br>
<code>void (*pointer)(int ,int);</code><br>
使用函数名时<strong>会自动转换成指针</strong><br>
可以直接使用指向函数的指针调用，<strong>无须提前解引用指针</strong><br>
函数指针可以赋<strong>nullptr或者值为0的常量表达式</strong><br>
函数指针之间不存在转换规则<br>
指针类型<strong>必须</strong>与重载函数中的某一个精确匹配<br>
形参<strong>不能是函数类型</strong>，但<strong>可以是指向函数的指针</strong>，此时形参看起来是函数类型，实际上是被当作指针来使用<br>
函数作为实参时会自动转换成指针<br>
Decltype 返回<strong>函数类型</strong>，而不是自动转换成指针类型<br>
返回指向函数的指针<code>int (*f1(int))(int*,int); 或者 using PF = int(*)(int*,int);PF</code> f1(int)或者用尾置返回 <code>auto f1(int)-&gt;int(*)(int*,int)</code><br>
明确知道返回函数时用decltype<br>
<code>decltype(func1) *func2();</code>//注意，func1为函数名</p>
<p>习题6.54</p>
<pre><code>int func(int, int);
int main() {
	vector&lt;int (*)(int,int)&gt; v;
};
int func(int, int) {
	return 1;
}
</code></pre>
<p>知识点：函数类型与函数名无任何关系，int func(int, int)的函数指针类型是int (*)(int,int)，换个名字也一样<br>
习题6.55</p>
<pre><code>int func(int, int);
int add(int a, int b);
int minuss(int a, int b);
int multi(int a, int b);
int divide(int a, int b);
int main() {
	vector&lt;int(*)(int, int)&gt; v{add,minuss,multi,divide};
};
int func(int, int) {
	return 1;
}
int add(int a, int b) {
	return a+b;
}
int minuss(int a, int b) {
	return a - b;
}
int multi(int a, int b) {
	return a * b;
}
int divide(int a, int b) {
	return a / b;
}
</code></pre>
<p>知识点：貌似minus不能用<br>
习题6.56</p>
<pre><code>int func(int, int);
int add(int a, int b);
int minuss(int a, int b);
int multi(int a, int b);
int divide(int a, int b);
int main() {
	vector&lt;int(*)(int, int)&gt; v{add,minuss,multi,divide};
	cout &lt;&lt; v[0](10, 2) &lt;&lt; endl;
	cout &lt;&lt; v[1](10, 2) &lt;&lt; endl;
	cout &lt;&lt; v[2](10, 2) &lt;&lt; endl;
	cout &lt;&lt; v[3](10, 2) &lt;&lt; endl;
};
int func(int, int) {
	return 1;
}
int add(int a, int b) {
	return a+b;
}
int minuss(int a, int b) {
	return a - b;
}
int multi(int a, int b) {
	return a * b;
}
int divide(int a, int b) {
	return a / b;
}
</code></pre>
<p>知识点:可以直接调用函数的指针 pointer（int，int）</p>
<p>习题感悟<br>
注意尾置返回中 指针和引用必须加括号string(&amp;)[10] string(*)[10]<br>
默认实参定义只能在函数的声明，不需要定义在函数的定义！！！<br>
因为内联函数可以定义多次，万一以后错手定义会很麻烦，为了保证一致最好定义在头文件，普通函数则只能定义一次，所以只需要放在源文件。<br>
返回类型和形参中包含字面值类型的函数不可以定义为constexpr<br>
实参类型转换是有等级差异的<br>
函数类型与函数名无任何关系，int func(int, int)的函数指针类型是int (*)(int,int)，换个名字也一样<br>
貌似minus不能用<br>
可以直接调用函数的指针 pointer（int，int）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 55. 跳跃游戏]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-55-tiao-yue-you-xi</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-55-tiao-yue-you-xi">
        </link>
        <updated>2019-09-12T11:43:10.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>官方题目：<br>
给定一个非负整数数组，你最初位于数组的第一个位置。<br>
数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>
判断你是否能够到达最后一个位置。</p>
<p>示例 1:<br>
输入: [2,3,1,1,4]<br>
输出: true<br>
解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。<br>
示例 2:<br>
输入: [3,2,1,0,4]<br>
输出: false<br>
解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/jump-game<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>对题目一开始的思考就是能够按某种顺序进行运算从而得出结果，一开始是想用逆推法，但是后来发现从前开始也是阔以的，具体思路就是判断每个点可以前进的值，并且维护一个最远可以达到的值reach，如果当前点大于reach就将reach的值改为当前点的值，最后能够去到的最大值和数组长度之间是否相等的判断值就是答案，代码如下：</p>
<pre><code>class Solution {
public:
    bool canJump(vector&lt;int&gt;&amp; nums) {
       int len=nums.size();
        if(len==0||len==1)
            return true;
        int reach=0;
        for(int i=0;i&lt;len-1;++i){
            int temp=reach;
            reach=i+nums[i];
            if(temp&gt;reach)
                swap(temp,reach);
            if(reach==i)
                return false;
        }
        if(reach&gt;=len-1)
         return true;
        else
        return false;    
    }
};
</code></pre>
<p>这一次由于找准了思路，所以一次通过，鼓掌！！hhh<br>
然后来看一下官方题解吧：</p>
<blockquote>
<p>定义<br>
如果我们可以从数组中的某个位置跳到最后的位置，就称这个位置是“好坐标”，否则称为“坏坐标”。问题可以简化为第 0 个位置是不是“好坐标”。<br>
题解<br>
这是一个动态规划问题，通常解决并理解一个动态规划问题需要以下 4 个步骤：<br>
利用递归回溯解决问题<br>
利用记忆表优化（自顶向下的动态规划）<br>
移除递归的部分（自底向上的动态规划）<br>
使用技巧减少时间和空间复杂度<br>
下面的所有解法都是正确的，但在时间和空间复杂度上有区别。</p>
<p>方法 1：回溯<br>
这是一个低效的解决方法。我们模拟从第一个位置跳到最后位置的所有方案。从第一个位置开始，模拟所有可以跳到的位置，然后从当前位置重复上述操作，当没有办法继续跳的时候，就回溯。</p>
</blockquote>
<pre><code>public class Solution {
    public boolean canJumpFromPosition(int position, int[] nums) {
        if (position == nums.length - 1) {
            return true;
        }

        int furthestJump = Math.min(position + nums[position], nums.length - 1);
        for (int nextPosition = position + 1; nextPosition &lt;= furthestJump; nextPosition++) {
            if (canJumpFromPosition(nextPosition, nums)) {
                return true;
            }
        }

        return false;
    }

    public boolean canJump(int[] nums) {
        return canJumpFromPosition(0, nums);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(2^n) ，最多有 2^n种从第一个位置到最后一个位置的跳跃方式，其中 n 是数组 nums 的元素个数，完整的证明见附录 A。<br>
空间复杂度：O(n)，回溯法只需要栈的额外空间。</p>
</blockquote>
<blockquote>
<p>方法 2：自顶向下的动态规划<br>
自顶向下的动态规划可以理解成回溯法的一种优化。我们发现当一个坐标已经被确定为好 / 坏之后，结果就不会改变了，这意味着我们可以记录这个结果，每次不用重新计算。<br>
因此，对于数组中的每个位置，我们记录当前坐标是好 / 坏，记录在数组 memo 中，定义元素取值为 GOOD ，BAD，UNKNOWN。这种方法被称为记忆化。<br>
例如，对于输入数组 nums = [2, 4, 2, 1, 0, 2, 0] 的记忆表如下，G 代表 GOOD，B 代表 BAD。我们发现不能从下标 2，3，4 到达最终坐标 6，但可以从 0，1，5 和 6 到达最终坐标 6。<br>
步骤<br>
初始化 memo 的所有元素为 UNKNOWN，除了最后一个显然是 GOOD （自己一定可以跳到自己）<br>
优化递归算法，每步回溯前先检查这个位置是否计算过（当前值为：GOOD / BAD）<br>
如果已知直接返回结果 True / False<br>
否则按照之前的回溯步骤计算<br>
计算完毕后，将结果存入memo表中</p>
</blockquote>
<pre><code>Java
enum Index {
    GOOD, BAD, UNKNOWN
}

public class Solution {
    Index[] memo;

    public boolean canJumpFromPosition(int position, int[] nums) {
        if (memo[position] != Index.UNKNOWN) {
            return memo[position] == Index.GOOD ? true : false;
        }

        int furthestJump = Math.min(position + nums[position], nums.length - 1);
        for (int nextPosition = position + 1; nextPosition &lt;= furthestJump; nextPosition++) {
            if (canJumpFromPosition(nextPosition, nums)) {
                memo[position] = Index.GOOD;
                return true;
            }
        }

        memo[position] = Index.BAD;
        return false;
    }

    public boolean canJump(int[] nums) {
        memo = new Index[nums.length];
        for (int i = 0; i &lt; memo.length; i++) {
            memo[i] = Index.UNKNOWN;
        }
        memo[memo.length - 1] = Index.GOOD;
        return canJumpFromPosition(0, nums);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n^2))，数组中的每个元素，假设为 i，需要搜索右边相邻的 nums[i] 个元素查找是否有 GOOD 的坐标。 nums[i] 最多为 n，n 是 nums 数组的大小。<br>
空间复杂度：O(2n)=O(n)，第一个 n 是栈空间的开销，第二个 n 是记忆表的开销。</p>
</blockquote>
<blockquote>
<p>方法 3：自底向上的动态规划<br>
底向上和自顶向下动态规划的区别就是消除了回溯，在实际使用中，自底向下的方法有更好的时间效率因为我们不再需要栈空间，可以节省很多缓存开销。更重要的事，这可以让之后更有优化的空间。回溯通常是通过反转动态规划的步骤来实现的。<br>
这是由于我们每次只会向右跳动，意味着如果我们从右边开始动态规划，每次查询右边节点的信息，都是已经计算过了的，不再需要额外的递归开销，因为我们每次在 memo 表中都可以找到结果。</p>
</blockquote>
<pre><code>Java
enum Index {
    GOOD, BAD, UNKNOWN
}

public class Solution {
    public boolean canJump(int[] nums) {
        Index[] memo = new Index[nums.length];
        for (int i = 0; i &lt; memo.length; i++) {
            memo[i] = Index.UNKNOWN;
        }
        memo[memo.length - 1] = Index.GOOD;

        for (int i = nums.length - 2; i &gt;= 0; i--) {
            int furthestJump = Math.min(i + nums[i], nums.length - 1);
            for (int j = i + 1; j &lt;= furthestJump; j++) {
                if (memo[j] == Index.GOOD) {
                    memo[i] = Index.GOOD;
                    break;
                }
            }
        }

        return memo[0] == Index.GOOD;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n^2)，数组中的每个元素，假设为 i，需要搜索右边相邻的 nums[i] 个元素查找是否有 GOOD 的坐标。 nums[i] 最多为 n，n 是 nums 数组的大小。<br>
空间复杂度：O(n)，记忆表的存储开销。</p>
</blockquote>
<blockquote>
<p>方法 4：贪心<br>
当我们把代码改成自底向上的模式，我们会有一个重要的发现，从某个位置出发，我们只需要找到第一个标记为 GOOD 的坐标（由跳出循环的条件可得），也就是说找到最左边的那个坐标。如果我们用一个单独的变量来记录最左边的 GOOD 位置，我们就可以避免搜索整个数组，进而可以省略整个 memo 数组。<br>
从右向左迭代，对于每个节点我们检查是否存在一步跳跃可以到达 GOOD 的位置（currPosition + nums[currPosition] &gt;= leftmostGoodIndex）。如果可以到达，当前位置也标记为 GOOD ，同时，这个位置将成为新的最左边的 GOOD 位置，一直重复到数组的开头，如果第一个坐标标记为 GOOD 意味着可以从第一个位置跳到最后的位置。<br>
模拟一下这个操作，对于输入数组 nums = [9, 4, 2, 1, 0, 2, 0]，我们用 G 表示 GOOD，用 B 表示 BAD 和 U 表示 UNKNOWN。我们需要考虑所有从 0 出发的情况并判断坐标 0 是否是好坐标。由于坐标 1 是 GOOD，我们可以从 0 跳到 1 并且 1 最终可以跳到坐标 6，所以尽管 nums[0] 可以直接跳到最后的位置，我们只需要一种方案就可以知道结果。</p>
</blockquote>
<pre><code>Index	0	1	2	3	4	5	6
nums	9	4	2	1	0	2	0
memo	U	G	B	B	B	G	G
Java
public class Solution {
    public boolean canJump(int[] nums) {
        int lastPos = nums.length - 1;
        for (int i = nums.length - 1; i &gt;= 0; i--) {
            if (i + nums[i] &gt;= lastPos) {
                lastPos = i;
            }
        }
        return lastPos == 0;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)，只需要访问 nums 数组一遍，共 n 个位置，n 是 nums 数组的长度。<br>
空间复杂度：O(1)，不需要额外的空间开销。</p>
</blockquote>
<blockquote>
<p>总结<br>
最后一个问题是，如何在面试场景中想到这个做法。我的建议是“酌情考虑”。最好的解法当然和别的解法相比更简单也更短，但是不那么容易直接想到。<br>
递归回溯的版本最容易想到，所以在思考更复杂解法的时候可以顺带提及一下这个解法，你的面试官实际上可能会想要看到这个解法。但如果没有，请提及可以使用动态规划的解法，并试想一下如何用记忆表来实现。如果你发现面试官希望你回答自顶向下的方法，那么就不太需要思考自底向上的版本，但我推荐在面试中提及一下自底向下的优点。</p>
</blockquote>
<p>其实官方解主要还是集中注意力在动态规划上，算是对动态规划的一个学习加深吧，特别是最后一个自底向上倒推的的方法，挺不错的，就是一开始我想解决的方向，当然我感觉我的方法也不错hhh（在题解中也是第一高赞题解hhh），所以就保留答案最为最理想答案吧，当然官方题解的总结很到位，以后复习的时候还是得好好看看动态规划的方法，毕竟动态规划才是更通用的做法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第六章 笔记+习题 6.1-6.2]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-liu-zhang-bi-ji-xi-ti-61-63</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-liu-zhang-bi-ji-xi-ti-61-63">
        </link>
        <updated>2019-09-12T01:09:34.000Z</updated>
        <content type="html"><![CDATA[<p>6.1函数基础<br>
一个函数定义包括：返回类型，函数名字，由0个或多个形参组成的列表以及函数体<br>
通过调用运算符来<strong>执行函数，调用运算符的形式是一对圆括号</strong>，作用于一个表达式，表达式是函数或者指向函数的指针，圆括号内为实参，实参初始化形参，调用表达式的类型就是函数的类型<br>
函数第一步是隐式地定义并初始化形参<br>
实参的类型和数量都必须与形参匹配，所以形参一定会被初始化<br>
空形参可以是隐式或者<strong>显式（void）</strong><br>
每个形参的类型都必须单独声明，不可以因为类型相同而忽略<br>
形参可以<strong>空名</strong>，但不可以同名，<strong>通常以空名代表不被使用，但也必须用实参初始化</strong><br>
函数的返回类型不可以是<strong>数组或者函数</strong>，但可以是指向数组的<strong>指针或引用</strong></p>
<p>习题6.1<br>
实参是形参的初始值，实参用于初始化对应位置的形参<br>
习题6.2<br>
（a）返回类型为int<br>
（b）没有定义返回类型<br>
（c）形参名字不可以相同<br>
（d）函数体不管语句数量多少，必须使用花括号<br>
习题6.3+6.4</p>
<pre><code>int factorial(int fact);
int main() {
	int i;
	while (cin) {
		cout &lt;&lt; &quot;please input one number:&quot;;
		cin &gt;&gt; i;
		cout &lt;&lt; factorial(i) &lt;&lt; endl;
	}
};

int factorial(int fact) {
	int sum=1;
	while (fact)
		sum *= fact--;
	return sum;
}
</code></pre>
<p>知识点：不要忽略了函数的声明！<br>
习题6.5</p>
<pre><code>int num_abs(int num);

int main() {
	int i;
	while (cin) {
		cout &lt;&lt; &quot;please input one number:&quot;;
		cin &gt;&gt; i;
		cout &lt;&lt; num_abs(i) &lt;&lt; endl;
	}
};

int num_abs(int num) {
	return num&gt;0?num:-num;
}
</code></pre>
<p>6.1.1局部对象<br>
名字有作用域，对象有生命周期<br>
形参和函数体内部定义的变量统称为局部变量<br>
自动对象 只存在于块执行期间的对象 块执行结束后，自动对象的值变为未定义<br>
形参是一种自动对象，内置类型的未初始化局部变量将产生未定义的值<br>
局部静态对象 static 直到程序终止时才被销毁，在此期间就算函数执行结束也不会对她产生影响（可以用来计算函数调用次数）<br>
内置类型的局部静态变量默认初始化为0，而不是未定义</p>
<p>习题6.6<br>
形参和局部静态变量都属于局部变量，只存在于块执行期间，但是局部静态变量的存在周期为整个程序执行期间，形参在块执行后的值变为未定义。代码见2.7<br>
习题6.7</p>
<pre><code>int formal_param(int f);

int main() {
	int i = 10;
	while(i)
		formal_param(i),--i;
};

int formal_param(int f) {
	int i=0;
	static int s_i=0;
	cout &lt;&lt; f&lt;&lt;' '&lt;&lt;++i &lt;&lt; ' ' &lt;&lt; ++s_i&lt;&lt;endl;
	return 0;
}
</code></pre>
<p>6.1.2<br>
函数只能定义一次，但可以声明多次。函数声明无须函数体，可以忽略形参的名字，用一个分号代替 例如 int add(int ,int);<br>
函数声明也称作函数原型<br>
建议函数和变量在<strong>头文件中声明，在源文件中定义,</strong><br>
含有函数声明的头文件应该被包含到定义函数的源文件中，<br>
<strong>通过以上的配合，其实就是将所有用到该函数的cpp文件中的声明移动到头文件中，编译器会自动在包含了头文件的cpp文件中搜索函数定义，从而以后可以很方便地修改函数的声明（比如修改形参数量），不需要一个一个地在使用了该函数的cpp文件中修改。</strong></p>
<p>习题6.8<br>
chapter6.h</p>
<pre><code>#pragma once
#ifndef CHAPTER6_H
#define CHAPTER6_H
int factorial(int fact);
#endif // !CHAPTER6_H
</code></pre>
<p>homework6.8.cpp</p>
<pre><code>#include &quot;chapter6.h&quot;

int factorial(int fact) {
	int sum = 1;
	while (fact)
		sum *= fact--;
	return sum;
}
</code></pre>
<p>6.1.3<br>
分离式编译允许我们把程序分割到几个文件中去，每个文件相互独立<br>
如果我们修改了某个源文件，只需要单独编译改动了的文件生成对象代码文件<br>
分离式编译会产生对象代码文件<br>
最后再把对象文件链接到一起形成可执行文件</p>
<p>习题6.9<br>
其实6.8中已经完成了这个任务，homework6.8对应于fact.cc 。</p>
<p>6.2参数传递<br>
如果形参是引用类型，实参被引用传递（传引用调用）。当形参非引用类型，实参的值拷贝给形参，实参被值传递（传值调用）<br>
6.2.1<br>
拷贝传递不会影响实参的值，但指针形参可以修改所指向的对象的值<br>
在c++语言中建议使用引用类型的形参</p>
<p>习题6.10</p>
<pre><code>int swap_p(int *p1, int *p2);

int main() {
	int i1 = 0, i2 = 1;
	cout &lt;&lt; i1 &lt;&lt; ' ' &lt;&lt; i2 &lt;&lt; endl;
	int *i1p = &amp;i1, *i2p = &amp;i2;
	swap_p(i1p, i2p);
	cout &lt;&lt; i1 &lt;&lt; ' ' &lt;&lt; i2 &lt;&lt; endl;
	return 0;
};

int swap_p(int *p1,int *p2) {
	 *p1 = *p1 + *p2;
	 *p2 = *p1 - *p2;
	 *p1 = *p1 - *p2;
	 return 1;
}
</code></pre>
<p>6.2.2<br>
<strong>使用引用可以避免对大的类或者容器对象进行拷贝</strong><br>
如果无需改变形参的值，<strong>最好将其声明为常量引用</strong><br>
可以使用引用类型的形参返回额外信息</p>
<p>习题6.11</p>
<pre><code>int main() {
	int i = 1;
	cout &lt;&lt; i &lt;&lt; endl;
	reset(i);
	cout &lt;&lt; i &lt;&lt; endl;
	return 0;
};

void reset(int &amp;p) {
	p = 0;
}
</code></pre>
<p>习题6.12</p>
<pre><code>int main() {
	int i1 = 0, i2 = 1;
	cout &lt;&lt; i1 &lt;&lt; ' ' &lt;&lt; i2 &lt;&lt; endl;
	int &amp;i1p = i1, &amp;i2p = i2;
	swap_p(i1p, i2p);
	cout &lt;&lt; i1 &lt;&lt; ' ' &lt;&lt; i2 &lt;&lt; endl;
	return 0;
};

int swap_p(int &amp;p1, int &amp;p2) {
	p1 = p1 + p2;
	p2 = p1 - p2;
	p1 = p1 - p2;
	return 1;
}
</code></pre>
<p>非常明显 引用更加好用。免去了*字符和&amp;字符的繁杂<br>
习题6.13<br>
一个是传值调用，一个是传引用调用，前者只是拷贝副本，后者可以通过引用更改原值<br>
习题6.14<br>
比如对两个矩阵进行比较，矩阵值特别大时再进行传值会导致内存不足，同时iostream等输入输出流是不可以拷贝的。如果不想修改原变量的值，就不应该使用引用。<br>
习题6.15<br>
我们不希望s被拷贝，也不希望s被修改，所以使用const &amp;，occur会被修改，所以用普通引用，我们不希望函数通过c的值来修改原值，所以不使用引用。否则s会被修改，occur无法递增</p>
<p>6.2.3<br>
指向常量的指针也可以指向非常量，只是不能解引用赋值，<strong>也不能赋值给普通指针</strong>。常量指针不能改变指针的值，<strong>但是可以解引用赋值</strong><br>
当实参初始化形参时会忽略顶层const，所以当形参有顶层const时，传给它常量对象或者非常量对象都可以（但实参的顶层const不会被忽略）<br>
在函数定义或者声明的过程中，因为顶层const被忽略了，所以形参中的const int和  int没有区别，编译器会认为重复了（<strong>但是在函数体中仍然不能改变const形参的值</strong>）<br>
非常量引用形参的<strong>两个问题</strong>：<br>
1.形参为<strong>int引用</strong>时，只能传入int类型的对象，不能用字面值、求值结果为int的表达式、需要转换的对象或者<strong>const int类型</strong>的对象，但** 常量引用可以使用字面值**，所以建议使用常量引用<br>
2.在函数内部使用形参作为另外一个函数的形参时，需要注意引用类型是否一致，例如：</p>
<pre><code>void fun1(const int &amp;param){
	fun2(param);//void fun2(int &amp; param)时错误，**int&amp;只接受普通引用 **
}
</code></pre>
<p>所以尽可能使用常量引用</p>
<p>习题6.18<br>
（a）<code>bool compare(matrix &amp;m1,matrix&amp;m2);</code><br>
（b）<code>vector&lt;int&gt;::iterator change_val(int i,vector&lt;int&gt;::iterator i_v);</code><br>
习题6.19<br>
（a）不合法，形参数目不对<br>
（b）合法<br>
（c）合法，有隐式转换<br>
（d）合法，有隐式转换<br>
习题6.20<br>
常量引用：不希望拷贝传值和被改动。普通引用的话原值可能会被改动。</p>
<p>6.2.4<br>
数组两个特殊性质，1.<strong>不允许拷贝数组</strong>2.使用数组名时通常会将其转换成指针<br>
所以函数传递数组时实际上传递的是指向数组首元素的指针<br>
1.Int* a   2.int a[]     3.int a[10]   这三个形参实际上是一样的，都等同于第一个<br>
管理指针形参<br>
1.使用结束标记间接指定数组长度，比如c风格字符串结尾的空字符 例如while(<em>cp)指向结尾空字符就会结束<br>
2.使用标准库规范 传递指向数组首尾元素的指针 int a[10];begin(a),end(a);<br>
3.显式传递一个表示数组大小的形参 end(a)-begin(a);<em><em>sizeof(a)/sizeof(<em>a)</em></em><br>
数组引用形参定义过程中，</em><em>&amp;arr两端的括号不可以少</em></em>，但数组引用形参一开始就需要确定数组大小 (&amp;arr)[10]；数组的引用 &amp;arr[10]；错误，没有数组的引用</p>
<p>习题6.21</p>
<pre><code>int compare(int p1, int *p2);

int main() {
	int i1,i2;
	cout &lt;&lt; &quot;please input two number:&quot;;
	cin &gt;&gt; i1 &gt;&gt; i2;
	cout &lt;&lt; &quot;the larger one is &quot;;
	int *i1p = &amp;i1, *i2p = &amp;i2;
	cout &lt;&lt; compare(i1, i2p) &lt;&lt; endl;
	return 0;
};

int compare(int p1, int *p2) {
	return p1&gt;*p2?p1:*p2;
}
</code></pre>
<p>习题6.22</p>
<pre><code>int main() {
	int i1,i2;
	cout &lt;&lt; &quot;please input two number:&quot;;
	cin &gt;&gt; i1 &gt;&gt; i2;
	int *i1p = &amp;i1, *i2p = &amp;i2;
	cout &lt;&lt; *i1p &lt;&lt; ' ' &lt;&lt; *i2p &lt;&lt; endl;
	swap_p(i1p, i2p);
	cout &lt;&lt; *i1p &lt;&lt; ' ' &lt;&lt; *i2p &lt;&lt; endl;
	return 0;
};

void swap_p(int *&amp;p1, int *&amp;p2) {
	int *temp = p1;
	p1 = p2;
	p2 = temp;
}
</code></pre>
<p>习题6.23</p>
<pre><code>int main() {
	int j[2] = { 0,1 };
	int i = 0;
	auto j_b = begin(j);
	auto j_e = end(j);
	print(i);
	print(j_b, j_e);
	return 0;
};

void print(const int&amp; i) {
	cout &lt;&lt; i &lt;&lt; endl;
}
void print(int *beg,int *end) {
	while (beg != end)
		cout &lt;&lt; *beg++ &lt;&lt; endl;

}
</code></pre>
<p>习题6.24<br>
程序希望逐个输出数组ia的元素，但是形参没有使用引用或指针，数组是无法直接拷贝给形参的！！！所以传递的仅仅是头指针</p>
<p>6.2.5<br>
int main(int argc,char *argv[]){….}<br>
main处理命令行选项，argc表示变量的数量，argv[0]保存程序的名字，可选实参从argv[1]开始</p>
<p>习题6.25&amp;.26</p>
<pre><code>int main(int argc,char* argv[]) {
	string s;
	for (int i = 1; i &lt; argc; ++i)
		s = s + argv[i];
	cout &lt;&lt; s &lt;&lt; endl;
};
</code></pre>
<p>知识点：string的向量可以用 string+=char，特别是string为空的时候，不能直接string=char+char，第一个必须是string。</p>
<p>6.2.6<br>
<strong>函数的实参数量未知但类型相同</strong>，可以使用initializer_list类型的形参，这是一种标准库类型，用于表示某种特定类型的值的数组，<strong>和vector一样也是一种模版类型，但其对象中的元素永远是常量值，无法改变元素的值</strong>（元素值是const）<br>
向initializer_list形参传递一个值的序列的时候，必须把序列放在<strong>一对花括号内</strong></p>
<p>习题6.27</p>
<pre><code>int add_list(initializer_list&lt;int&gt; i);

int main(int argc,char* argv[]) {
	initializer_list&lt;int&gt; i{ 1,2,3,4,5,6,7 };
	cout &lt;&lt; add_list(i) &lt;&lt; endl;
};

int add_list(initializer_list&lt;int&gt; i) {
	int sum = 0;
	for (auto num : i)
		sum += num;
	return sum;
}
</code></pre>
<p>习题6.28<br>
elem的类型为const string&amp;<br>
习题6.29<br>
应该，因为initailizer_list的对象都是const值，使用引用可以避免拷贝和修改，但是要注意配合auto使用（实测加了auto &amp;，会自动加上const）</p>
<p>习题感悟：<br>
不要忽略了函数的声明！<br>
数组是无法直接拷贝给形参的！！！<br>
string的向量可以用 string+=char，特别是string为空的时候，不能直接string=char+char，第一个必须是string。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组217. 存在重复元素]]></title>
        <id>https://lixin-ee.github.io//post/217-cun-zai-chong-fu-yuan-su</id>
        <link href="https://lixin-ee.github.io//post/217-cun-zai-chong-fu-yuan-su">
        </link>
        <updated>2019-09-11T15:30:24.000Z</updated>
        <content type="html"><![CDATA[<p>题目：</p>
<blockquote>
<p>给定一个整数数组，判断是否存在重复元素。<br>
如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</p>
<p>示例 1:<br>
输入: [1,2,3,1]<br>
输出: true<br>
示例 2:<br>
输入: [1,2,3,4]<br>
输出: false<br>
示例 3:<br>
输入: [1,1,1,3,3,4,3,2,4,2]<br>
输出: true<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/contains-duplicate<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>今天看了一天STL的hashtable，看得有点愣愣的，不过确实是牛逼，没想到这道题就用上了hhhh，非常适合用哈希map，把每个值作为key，再把出现次数作为mapped_value进行递增，第一次给出的代码如下：</p>
<pre><code>class Solution {
public:
    bool containsDuplicate(vector&lt;int&gt;&amp; nums) {
        int len = nums.size();
        if(len==0||len==1)
            return false;
        map&lt;int,int&gt; nums_map;
        for(auto i:nums)
            if(nums_map.find(i)==nums_map.end())
                nums_map.insert({i,1});
            else
                ++nums_map[i];
        for(auto i=nums_map.begin();i!=nums_map.end();++i)
            if(i-&gt;second&gt;1)
                return true;
        return false;
        
    }
};
</code></pre>
<p>依赖于STL的强大，毫无疑问地一次过啦hhh，但是花的时间比较长，所以打算看一下官方题解中hashmap的解答：</p>
<blockquote>
<p>方法三：哈希表 【通过】<br>
直觉<br>
利用支持快速搜索和插入操作的动态数据结构。<br>
算法<br>
从方法一中我们知道，对无序数组的查找操作的时间复杂度为 O(n)，而我们会重复调用查找操作。因此，使用搜索时间更快的数据结构将加快整个算法的速度。<br>
有许多数据结构常用作动态集合,如二进制搜索树和哈希表。这里我们需要的操作是 search 和 insert。对于平衡二叉搜索树（Java 中的 TreeSet 或 TreeMap），search 和 insert 的时间复杂度均为 O(logn)。对于哈希表（Java 中的 HashSet 或 HashMap），search 和 insert 的平均时间复杂度为 O(1)。因此，通过使用哈希表，我们可以达到在线性时间复杂度解决问题。</p>
</blockquote>
<pre><code>Java
public boolean containsDuplicate(int[] nums) {
    Set&lt;Integer&gt; set = new HashSet&lt;&gt;(nums.length);
    for (int x: nums) {
        if (set.contains(x)) return true;
        set.add(x);
    }
    return false;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 : O(n)。<br>
search() 和 insert() 各自使用 nn 次，每个操作耗费常数时间。<br>
空间复杂度 : O(n)。哈希表占用的空间与元素数量是线性关系。<br>
注意<br>
对于一些特定的 n 不太大的测试样例，本方法的运行速度可能会比方法二更慢。这是因为哈希表在维护其属性时有一些开销。要注意，程序的实际运行表现和 Big-O 符号表示可能有所不同。Big-O 只是告诉我们在 充分 大的输入下，算法的相对快慢。因此，在 nn 不够大的情况下， O(n) 的算法也可以比 O(nlogn)的更慢。</p>
</blockquote>
<p>看官方题解还是开卷有益的，我的源代码问题在于需要遍历两次，但是经过官方题解的指点获得了很好的灵感，c++的hashmap会返回一对pair，前者是迭代器，后者则是bool值，正好用于返回，所以在插入阶段只要出现插入失败（重复）就可以直接返回pair的second值作为结果了，非常简单暴力，结果也是一次通过，节省了很多时间。下面为修改后的最后代码：</p>
<pre><code>class Solution {
public:
    bool containsDuplicate(vector&lt;int&gt;&amp; nums) {
        int len = nums.size();
        if(len==0||len==1)
            return false;
        map&lt;int,int&gt; nums_map;
        for(auto i:nums)
            if(!nums_map.insert({i,1}).second)
                return true;
        return false;
        
    }
};
</code></pre>
<p>然后来看看剩下的两个官方题解吧，毕竟hashmap属于STL的拿来即用，属于前人栽树后人乘凉，面试的时候直接写个hashmap不知道会不会被打死，同时在前面我也说到过其实不太喜欢用hashmap，毕竟做算法就是要理解背后的原理，一个好算法应该是通用性高的泛型算法。</p>
<blockquote>
<p>方法一：朴素线性查找 【超时】<br>
直觉<br>
对于一个有 nn 个整数的数组，一共有n(n+1)/2 对整数。因此，我们可以对所有的<br>
对进行检测，看它们是否相同。<br>
算法<br>
为了实现这个思路，我们使用线性查找算法，这是最简单的查找算法。线性查找是一种检查特定值是否在列表中的算法，做法是依次逐个检查列表中的元素，直到找到满足的元素。<br>
对于本问题，我们循环遍历全部 n 个数。对于第 i 个整数 nums[i]，我们对前 i-1 个整数查找 nums[i] 的重复值。若找到，则返回 True; 否则继续。在程序最后，返回 False。<br>
为了证明算法的正确性，我们定义了循环不变式。循环不变式是指在每次迭代前和后均保持不变的性质。了解循环不变式对理解循环的意义十分重要。下面就是循环不变式:<br>
在下一次搜索之前,搜索过的整数中没有重复的整数。<br>
循环不变式在循环之前为真，因为还没有搜索过的整数。每次循环，我们查找当前元素的任何可能重复。如果发现重复项,则函数返回 True 退出；如果没有发现，则不变式仍然成立。<br>
因此，如果循环结束，循环不变式说明全部 nn 个整数中不存在重复元素。</p>
</blockquote>
<pre><code>Java
public boolean containsDuplicate(int[] nums) {
    for (int i = 0; i &lt; nums.length; ++i) {
        for (int j = 0; j &lt; i; ++j) {
            if (nums[j] == nums[i]) return true;  
        }
    }
    return false;
}
// Time Limit Exceeded
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 : O(n<sup>2)。最坏的情况下，需要检查n(n+1)/2对整数。因此，时间复杂度为O(n</sup>2 )。<br>
空间复杂度 : O(1)。只使用了常数额外空间。<br>
注意<br>
本方法在 Leetcode 上会超时。一般而言，如果一个算法的时间复杂度为 O(n<br>
^2 )，它最多能处理 n 大约为 10^4 的数据。当 n 接近 10^5时就会超时。</p>
<p>方法二：排序 【通过】<br>
直觉<br>
如果存在重复元素，排序后它们应该相邻。<br>
算法<br>
本方法使用排序算法。由于比较排序算法，如堆排序，可以在最坏情况下具有O(nlogn) 的时间复杂度。因此，排序经常是很好的预处理方法。排序之后，我们可以扫描已排序的数组,以查找是否有任何连续的重复元素。</p>
</blockquote>
<pre><code>Java
public boolean containsDuplicate(int[] nums) {
    Arrays.sort(nums);
    for (int i = 0; i &lt; nums.length - 1; ++i) {
        if (nums[i] == nums[i + 1]) return true;
    }
    return false;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 : O(nlogn)。<br>
排序的复杂度是 O(nlogn)，扫描的复杂度是 O(n)。整个算法主要由排序过程决定，因此是 O(nlogn)。<br>
空间复杂度 : O(1)。<br>
这取决于具体的排序算法实现，通常而言，使用 堆排序 的话，是 O(1)O(1)。<br>
注意<br>
此处的算法实现对原始数组进行排序，修改了原始数组。通常，除非调用方清楚输入数据将被修改，否则不应该随意修改输入数据。可以先复制 nums，然后对副本进行操作。</p>
</blockquote>
<p>嗯....这两个官方题解都只能说是差强人意呀，第一个直接是比较了，太暴力了吧...不过循环不变式的思想还是挺有趣的，第二个也仅仅是使用了快速排序、堆排序等时间复杂度下限的排序函数，代码也有点敷衍了，直接上了Java的函数，所以这一次就当做是hashmap的小试牛刀吧，hhh还真的是牛刀。</p>
]]></content>
    </entry>
</feed>