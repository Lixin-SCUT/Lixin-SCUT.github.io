<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-10-20T03:09:55.520Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[Math 43. 字符串相乘]]></title>
        <id>https://lixin-ee.github.io//post/math-43-zi-fu-chuan-xiang-cheng</id>
        <link href="https://lixin-ee.github.io//post/math-43-zi-fu-chuan-xiang-cheng">
        </link>
        <updated>2019-10-20T02:43:23.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p>
<p>示例 1:<br>
输入: num1 = &quot;2&quot;, num2 = &quot;3&quot;<br>
输出: &quot;6&quot;<br>
示例 2:<br>
输入: num1 = &quot;123&quot;, num2 = &quot;456&quot;<br>
输出: &quot;56088&quot;<br>
说明：</p>
<p>num1 和 num2 的长度小于110。<br>
num1 和 num2 只包含数字 0-9。<br>
num1 和 num2 均不以零开头，除非是数字 0 本身。<br>
不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/multiply-strings<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>昨天在医院看了一下没什么思路<br>
主要的难点在于<br>
1.溢出问题，110位，单纯地转化为整数肯定不行的<br>
2.以一个数为标准，对另一个数进行逐位计算的话比较麻烦，也容易有溢出的风险</p>
<p>然后来看一下网友题解</p>
<blockquote>
<p>转载借鉴自 https://leetcode.com/problems/multiply-strings/discuss/17605/Easiest-JAVA-Solution-with-Graph-Explanation<br>
<img src="https://lixin-ee.github.io//post-images/1571540288082.png" alt=""></p>
</blockquote>
<p>这个思路应该是最好的解答了，将两个数都进行逐位计算，然后将影响到的两位进行处理（一开始我想不明白为什么不用考虑res[i+j]的进位，后来才发现主要是后一位有进位，前一位是不用担心进位问题的。）<br>
按照思路实现如下:</p>
<pre><code>class Solution {
public:
    string multiply(string num1, string num2) {
        int len1=num1.size();
        int len2=num2.size();
        string res(len1+len2,'0');
        for(int i=len1-1;i&gt;=0;--i)
            for(int j=len2-1;j&gt;=0;--j){
                int temp=(res[i+j+1]-'0')+(num1[i]-'0')*(num2[j]-'0');
                res[i+j+1]=temp%10+'0';
                res[i+j]+=temp/10;
            }
        int i=0;
        while(i!=len1+len2-1&amp;&amp;res[i]=='0')
            ++i;
        res=res.substr(i,len1+len2-i);
        return res;
    }
};
</code></pre>
<p>剩下的就来看一下普通竖式版的题解吧<br>
方法：普通竖式<br>
<img src="https://lixin-ee.github.io//post-images/1571540602407.png" alt=""><br>
遍历 num2 每一位与 num1 进行相乘，将每一步的结果进行累加。</p>
<p>注意：<br>
num2 除了第一位的其他位与 num1 运算的结果需要补0<br>
计算字符串数字累加其实就是415. 字符串相加</p>
<pre><code>class Solution {
    /**
    * 计算形式
    *    num1
    *  x num2
    *  ------
    *  result
    */
    public String multiply(String num1, String num2) {
        if (num1.equals(&quot;0&quot;) || num2.equals(&quot;0&quot;)) {
            return &quot;0&quot;;
        }
        // 保存计算结果
        String res = &quot;0&quot;;
        
        // num2 逐位与 num1 相乘
        for (int i = num2.length() - 1; i &gt;= 0; i--) {
            int carry = 0;
            // 保存 num2 第i位数字与 num1 相乘的结果
            StringBuilder temp = new StringBuilder();
            // 补 0 
            for (int j = 0; j &lt; num2.length() - 1 - i; j++) {
                temp.append(0);
            }
            int n2 = num2.charAt(i) - '0';
            
            // num2 的第 i 位数字 n2 与 num1 相乘
            for (int j = num1.length() - 1; j &gt;= 0 || carry != 0; j--) {
                int n1 = j &lt; 0 ? 0 : num1.charAt(j) - '0';
                int product = (n1 * n2 + carry) % 10;
                temp.append(product);
                carry = (n1 * n2 + carry) / 10;
            }
            // 将当前结果与新计算的结果求和作为新的结果
            res = addStrings(res, temp.reverse().toString());
        }
        return res;
    }

    /**
     * 对两个字符串数字进行相加，返回字符串形式的和
     */
    public String addStrings(String num1, String num2) {
        StringBuilder builder = new StringBuilder();
        int carry = 0;
        for (int i = num1.length() - 1, j = num2.length() - 1;
             i &gt;= 0 || j &gt;= 0 || carry != 0;
             i--, j--) {
            int x = i &lt; 0 ? 0 : num1.charAt(i) - '0';
            int y = j &lt; 0 ? 0 : num2.charAt(j) - '0';
            int sum = (x + y + carry) % 10;
            builder.append(sum);
            carry = (x + y + carry) / 10;
        }
        return builder.reverse().toString();
    }
}
</code></pre>
<p>复杂度分析<br>
时间复杂度：O(M N)。 M,N分别为 num1 和 num2的长度<br>
空间复杂度：O(M+N)。用于存储计算结果。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math 67. 二进制求和]]></title>
        <id>https://lixin-ee.github.io//post/math-67-er-jin-zhi-qiu-he</id>
        <link href="https://lixin-ee.github.io//post/math-67-er-jin-zhi-qiu-he">
        </link>
        <updated>2019-10-19T09:26:29.000Z</updated>
        <content type="html"><![CDATA[<p>难度：简单</p>
<blockquote>
<p>给定两个二进制字符串，返回他们的和（用二进制表示）。<br>
输入为非空字符串且只包含数字 1 和 0。</p>
<p>示例 1:<br>
输入: a = &quot;11&quot;, b = &quot;1&quot;<br>
输出: &quot;100&quot;<br>
示例 2:<br>
输入: a = &quot;1010&quot;, b = &quot;1011&quot;<br>
输出: &quot;10101&quot;</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/add-binary<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>本题的难点在于<br>
1.字符串不等长<br>
2.进位问题，可能会导致两次进位和头部进位<br>
我的解题思路<br>
1.对于难点1我没啥好的思路，只能是判断位数差异在前面补0（后来发现网友题解也没有比较好的解决方法）<br>
2.对于进位问题我本来是想用istringstream来解决的，但是stringstream只能从左到右处理，所以并不适合本次题目的要求。所以最后用了bool变量来标记进位问题<br>
3.对于计算问题有两种，一种是利用ASCII码可加特性，另外一种就是异或了，为了可读性我用判断条件完成伪异或。<br>
最终代码：</p>
<pre><code>class Solution {
public:
    string addBinary(string a, string b) {
        bool flag=false;
        int lendiff=a.size()-b.size();
        if(lendiff&gt;0)
            while(lendiff)
                b=&quot;0&quot;+b,--lendiff;
        else
            while(lendiff)
                a=&quot;0&quot;+a,++lendiff;
        for(int i=a.size()-1;i&gt;=0;--i){
            if(a[i]!=b[i])
                a[i]='1';
            else
                a[i]='0';
            if(flag){
                a[i]=('1'-a[i])+'0';
                if(b[i]=='0'&amp;&amp;a[i]=='1')
                    flag=false;
            }else if(b[i]=='1'&amp;&amp;a[i]=='0')
                    flag=true;     
        }
        if(flag)
            a=&quot;1&quot;+a;
        return a;
    }
};
</code></pre>
<p>比较值得注意的主要是进位判断这一段</p>
<pre><code>            if(flag){
                a[i]=('1'-a[i])+'0';
                if(b[i]=='0'&amp;&amp;a[i]=='1')
                    flag=false;
            }else if(b[i]=='1'&amp;&amp;a[i]=='0')
                    flag=true;     
        }
</code></pre>
<p>首先判断上一次的进位<br>
1.如果上一次有进位，那么a就必须先翻转，然后此时只有一种情况不需要继续进位，那就是一开始两者都为0（注意此时a已经变为1了）<br>
2.如果上一次没有进位，此时只有一种情况需要进位，两者同时为1（同样地此时a已经变为0了）</p>
<p>最后看看网友题解：</p>
<p>解题思路：<br>
二进制求和，满二进一</p>
<blockquote>
<p>首先让两个字符串等长，若不等长，在短的字符串前补零，否则之后的操作会超出索引。<br>
然后从后到前遍历所有的位数，同位相加，这里有一个点，用的是字符相加，利用 ASCII 码，字符在内部都用数字表示，我们不需要知道具体数值，但可知 ‘0’-‘0’ = 0， ‘0’+1=‘1’，以此类推 。字符的加减，大小比较，实际上都是内部数字的加减，大小比较<br>
判断相加后的字符，若大于等于字符 ‘2’，下一位需要进一<br>
第 0 位数的相加在这里是单独处理的，因为它可能涉及到字符的插入（即是否需要在最前面加一位数 ‘1’</p>
</blockquote>
<pre><code>class Solution {
public:
    string addBinary(string a, string b) {
        int al = a.size();
        int bl = b.size();
        while(al &lt; bl) //让两个字符串等长，若不等长，在短的字符串前补零，否则之后的操作会超出索引
        {
            a = '0' + a;
            ++ al;
        }
        while(al &gt; bl)
        {
            b = '0' + b;
            ++ bl;
        }
        for(int j = a.size() - 1; j &gt; 0; -- j) //从后到前遍历所有的位数，同位相加
        {
            a[j] = a[j] - '0' + b[j];
            if(a[j] &gt;=  '2') //若大于等于字符‘2’，需要进一
            {
                a[j] = (a[j] - '0') % 2 + '0';
                a[j-1] = a[j-1] + 1;
            }
        }
        a[0] = a[0] - '0' + b[0]; //将ab的第0位相加
        if(a[0] &gt;= '2') //若大于等于2，需要进一
        {
            a[0] = (a[0] - '0') % 2 + '0';
            a = '1' + a;
        }
        return a;
    }
};

</code></pre>
<p>比较巧妙的是利用了ascii码的加法特性，然后将进位融入到判断中，需要注意的是必须把第一位提取出来进行处理。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math 258. 各位相加]]></title>
        <id>https://lixin-ee.github.io//post/math-258-ge-wei-xiang-jia</id>
        <link href="https://lixin-ee.github.io//post/math-258-ge-wei-xiang-jia">
        </link>
        <updated>2019-10-18T02:06:15.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。</p>
<p>示例:<br>
输入: 38<br>
输出: 2<br>
解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。<br>
进阶:<br>
你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/add-digits<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>难点：如何在常数时间复杂度完成<br>
思路：最后还是只想出了暴力法，其实就是判断当前值是否为个位数，如果不是的话就进入循环，循环内依次把10的余数和放到临时变量内，再把临时变量赋给当前值。</p>
<pre><code>class Solution {
public:
    int addDigits(int num) {
        while(num&gt;=10){
            int temp=0;
            while(num&gt;0){
                temp+=num%10;
                num=num/10;
            }
            num=temp;
        }
        return num;
    }
};
</code></pre>
<p>提前预知到常数时间肯定是用了数学思路的了，下面是网友题解<br>
1.</p>
<blockquote>
<p>O(1) 数学推理：设某个数字的字符串表示为'abc'，则这个数字代表a<em>100 + b</em>10 + c，转换后成为a + b + c，可见每次转换相当于把原数字减去a<em>99 + b</em>9 = 9 * (a*11 + b)，可以推出只要高于个位的位置上有数字，算法就会减去一个小于原数字的9的倍数，这就相当于数字 % 9。但9 % 9 = 0，而 9 本身就没有十位，因此需要考虑原数字是 0 或 9 的倍数的特殊情况<br>
首先计算num % 9，若结果为 0 则考虑num本身是否为 0，若不为 0 返回 9</p>
</blockquote>
<ol start="2">
<li></li>
</ol>
<blockquote>
<p>假设一个三位数整数n=100<em>a+10</em>b+c,变化后addn=a+b+c；<br>
两者的差值n-addn=99a+9b，差值可以被9整除，说明每次缩小9的倍数<br>
那么我们可以对res=num%9，若不为0则返回res，为0则返回9</p>
</blockquote>
<blockquote>
<p>class Solution {<br>
public:<br>
int addDigits(int num) {<br>
if(num&gt;9)<br>
{<br>
num=num%9;<br>
if(num==0)<br>
return 9;<br>
}<br>
return num;<br>
}<br>
};</p>
</blockquote>
<p>嗯...我是来码代码的别人是来学数学的hhh</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math 8. 字符串转换整数 (atoi)]]></title>
        <id>https://lixin-ee.github.io//post/math-8-zi-fu-chuan-zhuan-huan-zheng-shu-atoi</id>
        <link href="https://lixin-ee.github.io//post/math-8-zi-fu-chuan-zhuan-huan-zheng-shu-atoi">
        </link>
        <updated>2019-10-17T11:58:20.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。<br>
首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。<br>
当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。<br>
该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。<br>
注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。<br>
在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p>说明：<br>
假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p>
<p>示例 1:<br>
输入: &quot;42&quot;<br>
输出: 42<br>
示例 2:<br>
输入: &quot;   -42&quot;<br>
输出: -42<br>
解释: 第一个非空白字符为 '-', 它是一个负号。<br>
     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。<br>
示例 3:<br>
输入: &quot;4193 with words&quot;<br>
输出: 4193<br>
解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。<br>
示例 4:<br>
输入: &quot;words and 987&quot;<br>
输出: 0<br>
解释: 第一个非空字符是 'w', 但它不是数字或正、负号。<br>
因此无法执行有效的转换。<br>
示例 5:<br>
输入: &quot;-91283472332&quot;<br>
输出: -2147483648<br>
解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。<br>
     因此返回 INT_MIN (−2^31) 。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/string-to-integer-atoi<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题其实也蛮奇葩的，主要的要点或者说难点在于<br>
1.去除前面的所有空格<br>
2.判断第一个非空格字符，如果是加号或者符号的话视为符号，如果是数字的话就开始读入，如果是其他字符的话直接全部木大<br>
3.读取数字进行判断，主要是两个判断 一个是溢出判断 一个是非数字字符的判断<br>
我的思路如下：<br>
1.利用string的find搜索语句，先用.find_fisrt_of，再用.find_fisrt_not_of，但是这种方法耗时比较厉害，而且判断条件特别多，需要对返回值进行判断。<br>
2.使用范围for语句，这个比较理想，但是最后发现会导致for内部的判断条件特别多<br>
3.普通for循环语句，使用一个变量i记录，把空格检测-正负号检测-数字检测分离开来。<br>
最终代码</p>
<pre><code>class Solution {
public:
    int myAtoi(string str) {
        int res=0;
        bool neg=false;
        int i=0;
        for(;i&lt;str.size();++i)
            if(str[i]!=' ')
                break;    
        if(str[i]!='-'&amp;&amp;str[i]!='+'&amp;&amp;((str[i]-'0'&gt;9)||('0'-str[i]&gt;0)))
            return 0;
        if(str[i]=='-'){
            neg=true;
            ++i;
        }else if(str[i]=='+')
            ++i;
        for(;i&lt;str.size();++i){
            if((str[i]-'0'&gt;9)||('0'-str[i]&gt;0))
                break;
            if(neg){
                if(res&gt;INT_MAX/10||(res==INT_MAX/10&amp;&amp;(str[i]-'0')&gt;=8))
                    return -2147483648;
            }else if(res&gt;INT_MAX/10||(res==INT_MAX/10&amp;&amp;(str[i]-'0')&gt;=7))
                  return 2147483647;
            res=res*10+(str[i]-'0');
        }
        if(neg)
            return -res;
        return res;
    }
};
</code></pre>
<p>然后想疯狂吐槽leetcode的用例，比如 +-2 这种情况是不能通过的，所以必须修改一下判断条件<br>
然后看一下题解<br>
正则表达式就没啥好说的了，意义不大<br>
然后就是stringstream，说实话虽然很巧妙，但是其实背后是很多库函数的结果，我觉得有点背离题目的原意了，不过还是贴上来吧</p>
<pre><code>class Solution {
public:
    int myAtoi(string str) {
        while(*str.begin() == ' ') str.erase(str.begin());
        if(str == &quot;&quot;) return 0;
        stringstream ss;
        ss&lt;&lt;str;
        int n;
        ss&gt;&gt;n;
        return n;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ C++ primer 第十二章 笔记+习题 12.2-12.3]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-er-zhang-bi-ji-xi-ti-122-123</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-er-zhang-bi-ji-xi-ti-122-123">
        </link>
        <updated>2019-10-17T03:19:19.000Z</updated>
        <content type="html"><![CDATA[<p>12.2动态数组<br>
当容器需要重新分配内存时，需要一次性为很多元素分配内存，C++语言和标准库为此提供了两种一次分配一个对象数组的方法<br>
1.C++语言定义了另一种new表达式语法，可以分配并初始化一个对象数组<br>
2.标准库中包含一个名为allocator的类，允许我们将<strong>分配和初始化分离</strong>，使用allocator有更好的性能和更灵活的内存管理能力<br>
大多数应用应该使用标准库容器而不是动态分配的数组，使用容器更为简单、更不容易出现内存管理错误并且可能有更好的性能<br>
分配动态数组的类则必须定义自己版本的操作，在拷贝、复制以及销毁对象时管理所关联的内存<br>
12.2.1 new和数组<br>
为了让new分配一个对象数组，我们要在类型名之后跟一对方括号，在其中指明要分配的对象的数目</p>
<p>方括号中的大小必须是整型，<strong>但不必是常量</strong><br>
也可以用一个表示数组类型的类型别名typedef、using来分配一个数组 这样new表达式中就不需要方括号了</p>
<p>当用new分配一个数组的时，我们并未得到一个数组类型的对象，而是得到一个<strong>数组元素类型的指针</strong>，即使我们使用类型别名定义了一个数组类型，new也不会分配一个数组类型的对象。new返回的是一个元素类型的指针<br>
由于分配的内存并不是一个数组类型，因此<strong>不能对动态数组调用begin或end</strong>，处于相同的原因，<strong>也不能用范围for语句</strong>来处理（所谓的）动态数组中的元素<br>
！！！要记住我们所说的动态数组<strong>实质上并不是数组类型</strong><br>
默认情况下new分配的对象不管是单个分配的还是数组中的都是<strong>默认初始化</strong>的，可以对数组中元素进行<strong>值初始化，方法是在大小之后跟一对空括号</strong></p>
<p>在新标准中，我们还可以提供一个<strong>元素初始化器的花括号列表</strong></p>
<p>如果初始化器数目大于元素数目，则new表达式失败，不会分配任何内存，在上例中new会抛出一个类型为bad_array_new_length的异常，类似bad_alloc，此类型定义在头文件new中<br>
但我们<strong>不能在括号中给出初始化器，这意味着不能使用auto分配数组，但是可以使用花括号</strong>（意思是括号中不能用变量等让auto自动判断 例如<code>auto S = new string[10]{S1,S2}</code>合法，但是<code>auto S = new string[10](S1)</code>不合法）<br>
虽然我们不能创建一个大小为0的静态数组对象，但是当n等于0时，调用<code>new[n]</code>是合法的<br>
当我们用new分配一个大小为0的数组时，new返回一个<strong>合法的非空指针</strong>。此指针保证与new返回的其他任何指针都不相同。我们可以像<strong>使用尾后迭代器一样</strong>使用这个指针，但此指针<strong>不能解引用</strong>，因为它不指向任何元素<br>
为了释放动态数组，我们使用一种特殊形式的delete——<strong>在指针前加上一个方括号对</strong></p>
<p>数组中的元素会按<strong>逆序被销毁</strong>，即最后一个元素首先被销毁<br>
空方括号对是必需的，它指示编译器此指针指向一个对象数组的第一个元素，如果在delete一个指向数组的指针时忽略了方括号，其行为是未定义的<br>
即使当我们使用一个类型别名来定义一个数组类型时，也必需在delete数组时使用方括号对，因为指针永远指向一个对象数组的首元素<br>
如果用一个unique_ptr来管理动态数组，我们必须在unique_ptr的对象类型后面跟一对方括号</p>
<p>当unique_ptr（up）销毁它管理的指针时，会自动使用<strong>delete[ ]</strong><br>
当一个unique_ptr指向一个数组时，我们<strong>不能使用点和箭头成员运算符</strong>。毕竟unique_ptr指向的是<strong>一个数组而不是单个对象，但我们可以使用下标运算符</strong>来访问数组中的元素</p>
<p>与unique_ptr不同，<strong>shared_ptr不直接支持管理动态数组</strong>，如果希望使用shared则<strong>必须提供自己定义的删除器</strong><br>
<strong>shared_ptr未定义下标运算符</strong>，而且智能指针类型<strong>不支持指针算术运算</strong>，因为为了访问数组中的元素必须用get获取一个内置指针，然后用它来访问数组元素</p>
<p>习题12.23</p>
<pre><code>int main()
{
	char *c1{ &quot;123&quot; };
	char *c2{ &quot;456&quot; };
	char *c = new char[strlen(c1)+ strlen(c2)+1];
	strcpy(c, c1);//复制
	strcat(c, c2);//接上
	delete[]c;
}
</code></pre>
<p>习题12.24</p>
<pre><code>int main()
{
	string s;
	cin &gt;&gt; s;
	char *c = new char[s.size()+1];
	strcpy(c, s.c_str());//复制
	delete[]c;
}
</code></pre>
<p>其实我不是很明白这道题的意思，特别是字符串和超出长度的行为？不是可以动态分配么？<br>
习题10.25<br>
直接<code>delete[]pa;</code>或者<code>delete[10]pa;</code></p>
<p>12.2.2allocator类<br>
new有一些灵活性上的局限，其中一方面表现为它将<strong>内存分配和对象构造</strong>结合在一起，无法将分配和构造分开操作，所以会导致创建一些永远也用不到的冗余对象，同时可能导致需要使用的对象被赋值了两次（分配构造时一次，使用时一次）<br>
同时使用new时没有默认构造函数的类就不能动态分配数组了<br>
标准库allocator类定义在头文件memory中，它帮助我们将内存分配和对象构造分离开来<br>
类似于vector，<strong>allocator是一个模板</strong>，定义allocator对象时需要<strong>指明分配的对象类型</strong>，当其分配内存时，它就会自动根据类型来确定内存大小和对齐位置</p>
<p>allocator分配的内存是未构造的，我们按需要在此内存中构造对象<br>
construct成员函数接受一个指针和零个或多个额外参数。在给定位置构造一个元素，这些额外参数必须是与构造对象的类型相匹配的合法的初始化器<br>
还未构造的情况就使用原始内存是错误的，为了使用allocate返回的内存，我们必须使用construct构造对象，使用未构造的内存是未定义的<br>
当我们用完对象后，必须对每个构造的元素调用destroy来销毁他们，函数destroy接受一个指针，对指向的对象执行析构函数<br>
<code>allocator&lt;T&gt; -&gt; allocate -&gt; construct -&gt; destroy -&gt; deallocate</code></p>
<p><strong>只能对真正构造了的元素进行destroy操作</strong><br>
我们<strong>传递给deallocate的指针不能为空</strong>。它必须指向allocate分配的内存，而且传递给deallocate的大小参数必须与调用allocated分配内存时提供的<strong>大小参数具有一样的值(但是delete不需要，可以为空指针，也不需要指定大小)</strong><br>
标准库还为allocator类定义了两个伴随算法，可以在未初始化内存（<strong>亦即allocate了仍未construct的内存</strong>）中创建对象，它们都定义在memory中</p>
<p>uninitialized_copy返回递增后的目的位置迭代器，指向最后一个构造的元素之后的位置</p>
<p>习题12.26</p>
<pre><code>int main()
{
	int n = 10;
	allocator&lt;string&gt; alloc;
	string *const p = alloc.allocate(n);
	string s;
	string *q = p;
	while (cin &gt;&gt; s&amp;&amp;q != p + n)
		alloc.construct(q++, s);
	const size_t size = q - p;
	alloc.deallocate(p,size);
}
</code></pre>
<p>12.3<br>
开始一个程序的设计的一种好方法是列出程序的操作，了解需要哪些操作会帮助我们分析出需要什么样的数据结构<br>
当两个类需要共享数据，可以使用shared_ptr来反映数据结构中这种共享关系<br>
当我们设计一个类时，在真正实现成员之前先编写程序使用这个类，可以看到类是否具有我们所需要的操作</p>
<p>习题12.27</p>
<pre><code>int main()
{
	string file_name = &quot;text.txt&quot;;
	ifstream fs(file_name);
	TextQuery tq(fs);
	while (true) {
		cout &lt;&lt; &quot;enter word to look for,or q to quit&quot;;
		string s;
		if (!(cin &gt;&gt; s || s == &quot;q&quot;)) break;
		print(cout, tq.query(s))&lt;&lt;endl;
	}
}
using line_no = vector&lt;string&gt;::size_type;

class QueryResult;
class TextQuery {
public:
	TextQuery(ifstream&amp;);
	QueryResult query(const string&amp;)const;
private:
	shared_ptr &lt;vector&lt;string&gt;&gt; file;
	map&lt;string, shared_ptr&lt;set&lt;line_no&gt;&gt;&gt; wm;
};

TextQuery::TextQuery(ifstream &amp;is): file(new vector&lt;string&gt;)
{
	string text;
	while (getline(is, text)) {
		file-&gt;push_back(text);
		int n = file-&gt;size() - 1;
		istringstream line(text);
		string word;
		while (line &gt;&gt; word) {
			auto &amp;lines = wm[word];
			if (!lines)
				lines.reset(new set&lt;line_no&gt;);
			lines-&gt;insert(n);
		}
	}
}

class QueryResult {
	friend ostream&amp; print(ostream&amp;, const QueryResult&amp;);
public:
	QueryResult(string s,shared_ptr&lt;set&lt;line_no&gt;&gt;p,shared_ptr&lt;vector&lt;string&gt;&gt;f):sought(s),lines(p),file(f){}
private:
	string sought;
	shared_ptr&lt;set&lt;line_no&gt;&gt; lines;
	shared_ptr&lt;vector&lt;string&gt;&gt; file;
};

QueryResult TextQuery::query(const string &amp;sought)const
{
	static shared_ptr&lt;set&lt;line_no&gt;&gt; nodata(new set&lt;line_no&gt;);
	auto loc = wm.find(sought);
	if (loc == wm.end())
		return QueryResult(sought, nodata, file);
	else
		return QueryResult(sought, loc-&gt;second, file);
}

string make_plural(size_t ctr, const string &amp;word, const string &amp;ending) {
	return (ctr &gt; 1) ? word + ending : word;
}

ostream&amp; print(ostream &amp;os, const QueryResult &amp;qr)
{
	os &lt;&lt; qr.sought &lt;&lt; &quot; occurs &quot; &lt;&lt; qr.lines-&gt;size() &lt;&lt; &quot; &quot; &lt;&lt; make_plural(qr.lines-&gt;size(), &quot;time&quot;, &quot;s&quot;) &lt;&lt; endl;
	for (auto num : *qr.lines)
		os &lt;&lt; &quot;\t(line&quot; &lt;&lt; num + 1 &lt;&lt; &quot;)&quot; &lt;&lt; *(qr.file-&gt;begin() + num) &lt;&lt; endl;
	return os;
}
</code></pre>
<p>习题12.28<br>
习题12.29</p>
<p>习题12.30<br>
习题12.31<br>
vector会保存所有出现的行号，甚至是重复的，比如一行中单词出现了三次，vector就会保存三次当前行号，看需求，如果是需要查找单词每次出现的地方，可以用vector，并在打印时相应加粗单词<br>
习题12.32<br>
习题12.33</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 22. 括号生成 [unfinished]]]></title>
        <id>https://lixin-ee.github.io//post/zi-fu-chuan-22-gua-hao-sheng-cheng-unfinished</id>
        <link href="https://lixin-ee.github.io//post/zi-fu-chuan-22-gua-hao-sheng-cheng-unfinished">
        </link>
        <updated>2019-10-16T11:26:54.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p>
<p>例如，给出 n = 3，生成结果为：<br>
[<br>
&quot;((()))&quot;,<br>
&quot;(()())&quot;,<br>
&quot;(())()&quot;,<br>
&quot;()(())&quot;,<br>
&quot;()()()&quot;<br>
]</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/generate-parentheses<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题是忆君小朋友问我的，果断没啥思路hhh但是猜到七七八八得是动态规划了<br>
下面是高赞的动态题解，还是比较好懂得，主要的要点在于理解为何是<br>
&quot;(&quot; + 【i=p时所有括号的排列组合】 + &quot;)&quot; + 【i=q时所有括号的排列组合】<br>
因为其实有种对称的情况，所有的可能其实是【】+&quot;(&quot; + 【】 + &quot;)&quot; + 【】，但是所有元素都是左右括号，所以第一位置+第二位置其实是和第二位置+第三位置重复的了。<br>
下面是完整题解：</p>
<blockquote>
<p>反思：<br>
首先，面向小白：什么是动态规划？在此题中，动态规划的思想类似于数学归纳法，当知道所有 i&lt;n 的情况时，我们可以通过某种算法算出 i=n 的情况。<br>
本题最核心的思想是，考虑 i=n 时相比 n-1 组括号增加的那一组括号的位置。</p>
<p>思路：<br>
当我们清楚所有 i&lt;n 时括号的可能生成排列后，对与 i=n 的情况，我们考虑整个括号排列中最左边的括号。<br>
它一定是一个左括号，那么它可以和它对应的右括号组成一组完整的括号 &quot;( )&quot;，我们认为这一组是相比 n-1 增加进来的括号。<br>
那么，剩下 n-1 组括号有可能在哪呢？<br>
【这里是重点，请着重理解】<br>
剩下的括号要么在这一组新增的括号内部，要么在这一组新增括号的外部（右侧）。<br>
既然知道了 i&lt;n 的情况，那我们就可以对所有情况进行遍历：<br>
&quot;(&quot; + 【i=p时所有括号的排列组合】 + &quot;)&quot; + 【i=q时所有括号的排列组合】<br>
其中 p + q = n-1，且 p q 均为非负整数。<br>
事实上，当上述 p 从 0 取到 n-1，q 从 n-1 取到 0 后，所有情况就遍历完了。<br>
注：上述遍历是没有重复情况出现的，即当 (p1,q1)≠(p2,q2) 时，按上述方式取的括号组合一定不同。<br>
代码：<br>
具体代码如下：（时间击败百分之 95，内存击败百分之 99.65）</p>
</blockquote>
<pre><code>class Solution:
    def generateParenthesis(self, n: int) -&gt; List[str]:
        if n == 0:
            return []
        total_l = []
        total_l.append([None])    # 0组括号时记为None
        total_l.append([&quot;()&quot;])    # 1组括号只有一种情况
        for i in range(2,n+1):    # 开始计算i组括号时的括号组合
            l = []        
            for j in range(i):    # 开始遍历 p q ，其中p+q=i-1 , j 作为索引
                now_list1 = total_l[j]    # p = j 时的括号组合情况
                now_list2 = total_l[i-1-j]    # q = (i-1) - j 时的括号组合情况
                for k1 in now_list1:  
                    for k2 in now_list2:
                        if k1 == None:
                            k1 = &quot;&quot;
                        if k2 == None:
                            k2 = &quot;&quot;
                        el = &quot;(&quot; + k1 + &quot;)&quot; + k2
                        l.append(el)    # 把所有可能的情况添加到 l 中
            total_l.append(l)    # l这个list就是i组括号的所有情况，添加到total_l中，继续求解i=i+1的情况
        return total_l[n]
</code></pre>
<p>然后是我的复现，复现过程很哈批，把第二个循环的循环判断i写成n了，疯狂溢出，还是得好好思考啊</p>
<pre><code>class Solution {
public:
    vector&lt;string&gt; generateParenthesis(int n) {
        vector&lt;vector&lt;string&gt;&gt; Paren;
        Paren.push_back({&quot;&quot;});
        Paren.push_back({&quot;()&quot;});
        for(int i=2;i&lt;n+1;++i){
            vector&lt;string&gt; temp;
            for(int j=0;j&lt;i;++j){
                vector&lt;string&gt; left=Paren[j];
                vector&lt;string&gt; right=Paren[i-j-1];
                for(int x=0;x&lt;left.size();++x)
                    for(int y=0;y&lt;right.size();++y){
                        string s;
                        s=&quot;(&quot;+left[x] +&quot;)&quot;+right[y];
                        temp.push_back(s);
                    } 
            }
            Paren.push_back(temp);
        } 
        return Paren[n];
    }
};
</code></pre>
<p>然后就是优化问题，看了题解的C++实现发现其实我这样非常不优雅，因为平时不常用的for范围语句在这道题中反而大放异彩，同时可以在定义时确定ve<code>ctor&lt;vector&lt;string&gt;&gt;</code>的参数数量，省去push_back</p>
<pre><code>class Solution {
public:
    vector&lt;string&gt; generateParenthesis(int n) {
        vector&lt;vector&lt;string&gt;&gt; Paren(n+1);
        Paren.push_back({&quot;&quot;});
        Paren.push_back({&quot;()&quot;});
        for(int i=2;i&lt;n+1;++i){
            vector&lt;string&gt; temp;
            for(int j=0;j&lt;i;++j)
                for(auto left:Paren[j])
                    for(auto right:Paren[i-j-1]){
                        string s=&quot;(&quot;+left +&quot;)&quot;+right;
                        Paren[i].push_back(s);
                    } 
        } 
        return Paren[n];
    }
};
</code></pre>
<blockquote>
<p>下面是官方题解，以后有空可以回头看看<br>
方法一：暴力法<br>
思路<br>
我们可以生成所有 2^{2n}  个 '(' 和 ')' 字符构成的序列。然后，我们将检查每一个是否有效。</p>
<p>算法<br>
为了生成所有序列，我们使用递归。长度为 n 的序列就是 '(' 加上所有长度为 n-1 的序列，以及 ')' 加上所有长度为 n-1 的序列。<br>
为了检查序列是否为有效的，我们会跟踪 平衡，也就是左括号的数量减去右括号的数量的净值。如果这个值始终小于零或者不以零结束，该序列就是无效的，否则它是有效的。</p>
</blockquote>
<pre><code>Java
class Solution {
    public List&lt;String&gt; generateParenthesis(int n) {
        List&lt;String&gt; combinations = new ArrayList();
        generateAll(new char[2 * n], 0, combinations);
        return combinations;
    }

    public void generateAll(char[] current, int pos, List&lt;String&gt; result) {
        if (pos == current.length) {
            if (valid(current))
                result.add(new String(current));
        } else {
            current[pos] = '(';
            generateAll(current, pos+1, result);
            current[pos] = ')';
            generateAll(current, pos+1, result);
        }
    }

    public boolean valid(char[] current) {
        int balance = 0;
        for (char c: current) {
            if (c == '(') balance++;
            else balance--;
            if (balance &lt; 0) return false;
        }
        return (balance == 0);
    }
}

def generateParenthesis(self, N):
    if N == 0: return ['']
    ans = []
    for c in xrange(N):
        for left in self.generateParenthesis(c):
            for right in self.generateParenthesis(N-1-c):
                ans.append('({}){}'.format(left, right))
    return ans
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(2^{2n}n)，对于 2^{2n}个序列中的每一个，我们用于建立和验证该序列的复杂度为 O(n)。</p>
<p>空间复杂度：O(2^{2n}n)，简单地，每个序列都视作是有效的。请参见 方法三 以获得更严格的渐近界限。</p>
<p>方法二：回溯法<br>
思路和算法<br>
只有在我们知道序列仍然保持有效时才添加 '(' or ')'，而不是像 方法一 那样每次添加。我们可以通过跟踪到目前为止放置的左括号和右括号的数目来做到这一点，<br>
如果我们还剩一个位置，我们可以开始放一个左括号。 如果它不超过左括号的数量，我们可以放一个右括号。</p>
</blockquote>
<pre><code>class Solution {
    public List&lt;String&gt; generateParenthesis(int n) {
        List&lt;String&gt; ans = new ArrayList();
        backtrack(ans, &quot;&quot;, 0, 0, n);
        return ans;
    }

    public void backtrack(List&lt;String&gt; ans, String cur, int open, int close, int max){
        if (cur.length() == max * 2) {
            ans.add(cur);
            return;
        }

        if (open &lt; max)
            backtrack(ans, cur+&quot;(&quot;, open+1, close, max);
        if (close &lt; open)
            backtrack(ans, cur+&quot;)&quot;, open, close+1, max);
    }
}
</code></pre>
<p><img src="https://lixin-ee.github.io//post-images/1571226174878.png" alt=""></p>
<p>方法三：闭合数<br>
思路</p>
<p>为了枚举某些内容，我们通常希望将其表示为更容易计算的不相交子集的总和。</p>
<p>考虑有效括号序列 S 的 闭包数：至少存在 index &gt;= 0，使得 <code>S[0], S[1], ..., S[2*index+1]</code>是有效的。 显然，每个括号序列都有一个唯一的闭包号。 我们可以尝试单独列举它们。</p>
<p>算法</p>
<p>对于每个闭合数 c，我们知道起始和结束括号必定位于索引 0 和<code>2*c + 1</code>。然后两者间的 <code>2*c</code> 个元素一定是有效序列，其余元素一定是有效序列。</p>
<pre><code>class Solution {
    public List&lt;String&gt; generateParenthesis(int n) {
        List&lt;String&gt; ans = new ArrayList();
        if (n == 0) {
            ans.add(&quot;&quot;);
        } else {
            for (int c = 0; c &lt; n; ++c)
                for (String left: generateParenthesis(c))
                    for (String right: generateParenthesis(n-1-c))
                        ans.add(&quot;(&quot; + left + &quot;)&quot; + right);
        }
        return ans;
    }
}
</code></pre>
<blockquote>
<p>时间空间复杂度与题解二相同</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[反向迭代器的insert与erase （insert不能直接使用反向迭代器）]]></title>
        <id>https://lixin-ee.github.io//post/fan-xiang-die-dai-qi-shi-wu-fa-jin-xing-insert-cha-ru-cao-zuo</id>
        <link href="https://lixin-ee.github.io//post/fan-xiang-die-dai-qi-shi-wu-fa-jin-xing-insert-cha-ru-cao-zuo">
        </link>
        <updated>2019-10-16T02:06:24.000Z</updated>
        <content type="html"><![CDATA[<p>问题：<br>
做题时对容器进行逆序对比，再进行插入操作然后报错了。</p>
<pre><code>if
(i==digits.rend())  
                digits.insert(digits.rend(),1); 
</code></pre>
<p>原因：<br>
反向迭代器是无法进行insert插入操作的， digits.insert(digits.rend(),1);是无法通过编译的，reverse iterator并不属于五种迭代器类型之一<br>
有些容器的成员函数只接受iterator类型的参数，所以如果你想要在ri所指的位置插入一个新元素，你不能直接这么做，因为vector的insert函数不接受reverse_iterator。如果你想要删除ri 所指位置上的元素也会有同样的问题。erase成员函数会拒绝reverse_iterator，坚持要求iterator。为了完成删除和一些形式的插入操作，你必须先通过base函数将reverse_iterator转换成iterator，然后用iterator来完成工作。</p>
<p>然后展开说一下吧<br>
ri<br>
1 2 3 4<br>
i<br>
如上简图所示，如果ri指向2，那么ri.base()也就是i会指向3（同理如果ri指向4，那么i应该是end()）<br>
所以对于insert操作的话，使用ri.base()是正确的的<br>
但是对于erase来说，是删除当前迭代器指向的元素，那就不对劲了，需要将--i，也就是--ri.base()</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math 66. 加一]]></title>
        <id>https://lixin-ee.github.io//post/math-66-jia-yi</id>
        <link href="https://lixin-ee.github.io//post/math-66-jia-yi">
        </link>
        <updated>2019-10-16T01:52:22.000Z</updated>
        <content type="html"><![CDATA[<p>难度：简单</p>
<pre><code>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。
最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。
你可以假设除了整数 0 之外，这个整数不会以零开头。

示例 1:
输入: [1,2,3]
输出: [1,2,4]
解释: 输入数组表示数字 123。
示例 2:
输入: [4,3,2,1]
输出: [4,3,2,2]
解释: 输入数组表示数字 4321。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/plus-one
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
</code></pre>
<p>这道题的难点在于：如果遇到个位为9的情况，需要置为0并向前进位，同时如果遇到全部位数为9的情况，则需要全部位数置为0，并在vector前面新增一位1。<br>
解决思路：单独判断特殊情况，以个位为9作为判断条件，不断向前递推直到遇到不为9的数，如果全部为9，则插入1并返回，其他情况可直接返回<br>
代码如下</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; plusOne(vector&lt;int&gt; digits) {
        bool flag=false;
        int len=digits.size();
        if(digits[len-1]==9){
            auto i=digits.rbegin();
            while(i&lt;digits.rend()&amp;&amp;*i==9){
                *i=0;
                ++i;
            }
            if(i==digits.rend())  
                digits.insert(digits.begin(),1); 
            else
                ++*i;
            return digits;
        }
        digits[len-1]+=1;
        return digits;
    }
};
</code></pre>
<p>其中遇到的难点和注意点：<br>
1.反向迭代器是无法进行insert插入操作的， digits.insert(digits.rend(),1);是无法通过编译的，reverse iterator并不属于五种迭代器类型之一<br>
2.<code>(i&lt;digits.rend()&amp;&amp;*i==9)</code>判断条件的先后顺序很重要，如果反过来的话就会造成解引用未知指针的危险操作。<br>
3.临时对象的创建 是在类型后面加上括号，括号内再加入初始值调用构造函数，<code>plusOne(vector&lt;int&gt; ( {1,2,3,4} ))</code></p>
<p>最后是网友题解：</p>
<blockquote>
<p>根据题意加一，没错就是加一这很重要，因为它是只加一的所以有可能的情况就只有两种：<br>
1.除 9 之外的数字加一；<br>
2.数字 9<br>
加一得十进一位个位数为 0 加法运算如不出现进位就运算结束了且进位只会是一。</p>
<p>所以只需要判断有没有进位并模拟出它的进位方式，如十位数加 11 个位数置为 00，如此循环直到判断没有再进位就退出循环返回结果。</p>
<p>然后还有一些特殊情况就是当出现 9999、999999 之类的数字时，循环到最后也需要进位，出现这种情况时需要手动将它进一位。</p>
</blockquote>
<pre><code>Java
class Solution {
    public int[] plusOne(int[] digits) {
        for (int i = digits.length - 1; i &gt;= 0; i--) {
            digits[i]++;
            digits[i] = digits[i] % 10;
            if (digits[i] != 0) return digits;
        }
        digits = new int[digits.length + 1];
        digits[0] = 1;
        return digits;
    }
}
</code></pre>
<p>优雅很多hhh，值得学习</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ C++ primer 第十二章 笔记+习题 12.1]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-er-zhang-bi-ji-xi-ti-121</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-er-zhang-bi-ji-xi-ti-121">
        </link>
        <updated>2019-10-16T01:25:19.000Z</updated>
        <content type="html"><![CDATA[<p>12动态内存<br>
<strong>静态内存</strong>用于保存局部static对象、类static数据成员以及定义在任何函数之外的变量<br>
<strong>栈内存</strong>用于保存定义在函数内的非static对象<br>
分配在静态内存和栈内存中的对象由<strong>编译器自动创建和销毁</strong>，栈对象在程序运行时才存在，static对象在使用前分配，程序结束时销毁<br>
除了静态内存和栈内存，每个程序还有一个<strong>内存池，称为自由空间或堆</strong>，程序用堆来存储动态分配的对象</p>
<p>12.1动态内存和智能指针<br>
动态内存的管理，new：在动态内存中为对象分配空间并返回一个指向该对象的指针，可以对其进行初始化；delete：接受一个动态对象的指针，销毁该对象，并释放与之关联的内存<br>
新的标准库为了使用动态内存提供了两种智能指针，与常规指针相比重要的区别在于它负责<strong>自动释放</strong>所指对象，<br>
shared_ptr：允许多个指针指向同一个对象；unique_ptr独占所指向的对象 weak_ptr 弱引用，指向shared_ptr管理的对象 。这三种都定义在memory头文件中</p>
<p>12.1.1shared_ptr<br>
智能指针也是模板，创建时必须提供指针指向的类型<br>
默认初始化的智能指针保存一个空指针<br>
智能指针并不支持指针算术操作</p>
<p>！！使用get时，若智能指针释放了其对象，返回的指针所指向的对象也就消失了<br>
最安全的分配和使用动态内存的方法是调用一个名为make_shared的标准库函数，此函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr，make_shared定义在头文件memory中<br>
make_shared用其参数来构造给定类型的对象，比如调用<code>make_shared&lt;string&gt;</code>必须传递与string某个构造函数相匹配的参数。如果不传递任何参数，对象就会进行值初始化<br>
当进行拷贝赋值操作时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象<br>
我们可以认为每个shared_ptr都有一个关联计数器，通常称其为引用计数。无论何时我们拷贝一个shared_ptr都会递增计数器<br>
递增计数器的情况1.用一个shared_ptr初始化另外一个shared_ptr2.将shared_ptr作为参数传递给一个函数3. shared_ptr作为函数的返回值<br>
递减计数器 1.给shared_ptr赋一个新值2. shared_ptr被销毁3. 局部的shared_ptr离开其作用域（在函数中定义的shared_ptr都是局部变量，在函数执行结束后都会被销毁）<br>
一旦shared_ptr的计数器变为0，就会自动释放所管理的对象，可以确保分配的对象在恰当的时刻被释放<br>
每个类都有一个析构函数，控制此类型的对象销毁时会做什么操作<br>
将shared_ptr放在容器中容易因重新排序等因素忘记进行销毁，导致内存浪费，所以要记得用erase删除容器中不需要的shared_ptr元素<br>
使用动态内存的原因：1.不知道需要使用多少对象2.不知道所需对象的准确类型3.！！程序需要在多个对象间共享数据</p>
<p>当两个对象共享底层的数据时，当某个对象被销毁，不能单方面地销毁底层数据<br>
使用动态内存的一个常见原因就是允许多个对象共享相同的状态<br>
<code>initializer_list&lt;string&gt;</code>类型参数接受一个初始化器的花括号列表</p>
<p>习题12.1<br>
一共有4个<br>
习题12.2<br>
直接复现一遍书中代码吧</p>
<pre><code>class StrBlob {
public:
	typedef vector&lt;string&gt;::size_type size_type;
	StrBlob() :data(make_shared&lt;vector&lt;string&gt;&gt;()) {};
	StrBlob(initializer_list&lt;string&gt; i1):data(make_shared&lt;vector&lt;string&gt;&gt;(i1)) {};
	size_type size() const { return data-&gt;size(); }
	bool empty() const { return data-&gt;empty(); }
	void push_back(const string &amp;t) { data-&gt;push_back(t); }
	void pop_back() {
		check(0, &quot;pop_back on empty StrBlob&quot;);
		data-&gt;pop_back();
	};;
	string&amp; front() {
		check(0, &quot;front on empty StrBlob&quot;);
		return data-&gt;front();
	};
	string&amp; back() {
		check(0, &quot;back on empty StrBlob&quot;);
		return data-&gt;back();
	};
private:
	shared_ptr&lt;vector&lt;string&gt;&gt; data;
	void check(size_type i, const string &amp;msg)const {
		if (i &gt;= data-&gt;size())
			throw out_of_range(msg);
	};
};
</code></pre>
<p>习题12.3<br>
不需要<br>
跟在参数列表后的const表示this是一个指向常量的指针，这样使用const的成员函数被称为常量成员函数，用于表示常量成员函数不能改变调用它的对象的内容<br>
这两者都会改变调用对象的内容，所以不需要加const<br>
习题12.4<br>
因为是私有函数，只能被程序编写者调用，所以不用担心向无符号数传入负值<br>
私有函数private相比于public公有函数的好处在于某些时候可以不用考虑判断条件，比如不用担心会向size_type传入负数<br>
习题12.5<br>
explicit的作用就是抑制构造函数的隐式转换<br>
优点：不会自动的进行类型转换，必须准确地输入相应的类型，防止出现输入错误的情况。<br>
缺点：必须用构造函数显示创建一个对象，或者显式地进行转换，不够方便简单</p>
<p>12.1.2直接管理内存<br>
运算符new分配内存，delete释放new分配的内存<br>
相对于智能指针，使用这两个运算符管理内存非常容易出错，它们不能依赖类对象拷贝、赋值和销毁操作的任何默认定义<br>
使用智能指针的程序更容易编写和调试<br>
在自由空间分配的内存时无名的，所以new无法为其分配的对象命名，而是返回一个指向该对象的指针<br>
<code>int *pi = new int;	//pi指向一个动态分配的，未初始化的无名对象；</code><br>
默认情况下动态分配的对象是默认初始化的，所以内置类型或组合类型（类中包含的类）的对象的值将是未定义的，而类类型对象将用默认构造函数进行初始化<br>
我们可以用直接初始化的方式来初始化一个动态分配的对象，新标准下也可以用花括号</p>
<p>（注意第二个为拷贝初始化而非直接初始化）<br>
也可以对动态分配的对象进行值初始化，只需在类型名后面加上一对空括号<br>
对于类类型来说，由于有构造函数所以值初始化意义不大，但是对于内置类型，两种类型的差别很大，值初始化的内置类型有着良好定义的值，而默认初始化的值则是未定义的<br>
最好对动态分配的对象进行初始化，原因与初始化变量相同，防止调用未定义值的对象<br>
如果我们提供了一个括号包围的初始化器就可以auto，从此初始化器来推断我们想要分配的对象的类型，但是只有当括号中仅有单一初始化器时才可以使用auto</p>
<p>用new 分配const 对象时合法的，但是必须对const对象进行初始化，然后new返回的指针是一个指向const 的指针<br>
一旦内存耗尽，new表达式就会失败，默认情况下会抛出一个类型为bad_alloc的异常，<br>
使用定位new 的方式阻止它抛出异常：<code>int *p2 = new (nothrow) int;</code>如果分配失败，返回一个空指针<br>
定位new表达式允许我们向new传递额外的参数，例子中我们传递给它一个由标准库定义的名为nothrow的对象，如果将nothrow传递给new，就是告诉他不能抛出异常</p>
<p>delete也是销毁给定指针指向的对象，释放相应的内存<br>
传递给delete的指针必须指向动态分配的内存，或者是一个空指针，释放一块并非new分配的内存，或者将相同的指针值释放多次，其行为都是未定义的<br>
释放一个空指针总是没有错误的<br>
通常情况下编译器不能分辨一个指针指向静态还是动态分配的对象，同样也不能分辨指针指向的内存是否已被释放，所以错误的delete表达式都会被通过<br>
const对象的值不能被改变，但是它本身是可以被销毁的<br>
对于一个由内置指针管理的动态对象，直到被delete显式释放之前它都是存在的<br>
所以调用者必须记得释放内存<br>
与类类型不同，内置类型的对象被销毁时什么也不会发生，特别是一个指针离开其作用域时其指向的对象什么也不会发生，如果这个指针指向的是动态内存，那么内存将不会被自动释放，所以由内置指针管理的动态内存在被显式释放之前一直都会存在<br>
忘记delete释放动态内存就会导致内存泄漏问题<br>
当我们delete一个指针后指针值就变为无效，虽然指针已经无效，但是该指针仍然保存着（已经释放后）动态内存的地址，在delete后指针变成空悬指针<br>
避免空悬指针需要在指针离开其作用域之前释放掉它所关联的内存 重制指针值为nullptr<br>
但上述方法对于指向同一内存的多个指针无效，只能作用于单一指针</p>
<p>习题12.6</p>
<pre><code>void readvi(vector&lt;int&gt; &amp;vi) {
	while (cin) {
		int i;
		cin &gt;&gt; i;
		vi.push_back(i);
	}
}

void writevi(vector&lt;int&gt; &amp;vi) {
	cout &lt;&lt; vi.size() &lt;&lt; endl;
	for (auto i : vi)
		cout &lt;&lt; i &lt;&lt; endl;
}

int main()
{
	vector&lt;int&gt; *vi = new vector&lt;int&gt;;
	readvi(*vi);
	writevi(*vi);
	delete vi;
}
</code></pre>
<p>差点又忘了delete。。。new出来的对象都是在堆内存/动态内存里面的，所以必须delete<br>
习题12.7</p>
<pre><code>int main()
{
	shared_ptr&lt;vector&lt;int&gt;&gt; vi =make_shared&lt;vector&lt;int&gt;&gt;();
	//shared_ptr&lt;vector&lt;int&gt;&gt; vi(new vector&lt;int&gt;);
	readvi(*vi);
	writevi(*vi);
}
</code></pre>
<p>习题12.8<br>
没有对p进行删除，导致p在程序结束之前都会存在于动态内存中<br>
习题12.9<br>
q把指针值赋给r，但是r原指针值并没有delete，所以没法销毁了，同时还可能存在空悬指针问题。q指针赋给r,如果释放了q，则此时的r指针为空悬指针。<br>
r2因为是动态指针所以会自动减去引用计数器，等于0时自动销毁</p>
<p>12.1.3 shared_ptr和new结合使用<br>
我们可以用new返回的指针来初始化智能指针<br>
单接受指针参数的智能指针构造函数explicit的，所以我们不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化的形式来初始化一个智能指针<br>
一个返回shared_ptr的函数不能在其返回语句中隐式转换一个普通指针</p>
<p>默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，但我们可以将智能指针绑定到一个指向其他类型的资源（例如类类型）的指针上，但是这样做必须提供自己的操作来代替默认delete<br>
shared_ptr可以协调对象的析构，但这仅限于自身的拷贝（也就是shared_ptr之间）<br>
当临时shared_ptr对象被销毁时，它所指向的内存会被释放<br>
当将一个shared_ptr绑定到一个普通指针时，我们就将内存的管理责任交给了这个shared_ptr，一旦这样做了，我们就不应该再使用内置指针来访问shared_ptr所指向的内存了<br>
使用内置指针来访问智能指针所负责的对象是很危险的，因为我们<strong>无法知道对象何时会被销毁。</strong><br>
智能指针类型定义了一个名为get的函数，它返回一个内置指针，指向智能指针管理的对象，get函数主要是为了向不能使用智能指针的代码传递一个内置指针。<strong>使用get返回的指针的代码不能delete此指针</strong><br>
只有在确定代码不会delete指针的情况下才能使用get，永远不要用get初始化另一个智能指针或者为另一个智能指针赋值（因为不知道对象何时会被销毁）</p>
<p>我们可以用reset来将一个指向相同值的新的指针（一个新的对象的指针）赋予一个shared_ptr（相当于复制其值然后创建一个新的指针）</p>
<p>习题12.10<br>
正确，其实就是将p的指针值进行拷贝，注意会引发指针计数值+1<br>
习题12.11<br>
编译器不会报错，但是get返回的指针是普通指针，此时不会引发计数值+1，导致可能get返回指针指向的对象可能被销毁而process继续调用。<br>
习题11.12<br>
(a)合法，首先复制sp，将sp的引用计数+1，然后程序结束再-1<br>
(b)不合法，智能指针的构造函数是explicit的，不能进行隐式的转换<br>
(c)错误，同上<br>
(d)合法！但是程序结束后会释放内存，p变成空悬指针。<br>
注意<code>process(shared_ptr&lt;int&gt;(p))</code>虽然是复制，但是指向的对象相同，智能指针照样会计数+1然后计数-1销毁内存，而因为两者指向相同的对象，导致原来的普通指针p变成空悬指针。<br>
相同12.13<br>
删除p之后，会导致p指向的内存被释放，此时sp就会变成空悬指针，在sp指针被销毁时，该块内存会被二次delete，执行后产生错误：double free</p>
<p>12.1.4智能指针和异常<br>
当发生异常时，内置指针直接管理的内存是不会自动释放（但是智能指针的会检查引用计数并销毁）<br>
类需要用户显式地释放所使用的任何资源<br>
可以使用shared_ptr来管理其他对象（比如类），但是需要定义一个对应的函数来代替delete<br>
<img src="https://lixin-ee.github.io//post-images/1571232741628.png" alt=""></p>
<p>习题12.14</p>
<pre><code>struct destination;
struct connection;
connection connect(destination*);
void disconnect(connection);
void f(destination &amp;d) {
	connection c = connect(&amp;d);
	shared_ptr&lt;connection&gt; p(&amp;c, end_connection);
}
void end_connection(connection *p) { disconnect(*p); }
</code></pre>
<p>习题12.15</p>
<pre><code>void f(destination &amp;d) {
	connection c = connect(&amp;d);
	shared_ptr&lt;connection&gt; p(&amp;c, [](connection *p) {disconnect(*p); });
}
</code></pre>
<p>12.1.5unique_ptr<br>
一个unique_ptr拥有它所指向的对象，与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时，它所指向的对象也会被销毁<br>
unique_ptr与shared_ptr不同，没有类似make_shared的标准库函数，当我们定义一个unique_ptr时，需要将其绑定到一个new返回的指针上，初始化unique_ptr必须采用直接初始化的形式<br>
unique_ptr不支持普通的拷贝或赋值操作<br>
1.unique_ptr不允许拷贝是指不能用一个unique_ptr拷贝到另一个unique_ptr，但是如果使用new出来的普通指针初始化unique_ptr是可以的，<br>
例如</p>
<pre><code>int *pi =new int(42);
unique_ptr&lt;int&gt; p1(pi);
</code></pre>
<p>2.并非是new出来的指针，在栈内存而不是动态内存，所以不应使用智能指针（通过编译，但是编译器会自动delete栈内存，智能指针又delete一次，所以造成二次delete）<br>
虽然我们不能拷贝或赋值unique_ptr,但可以通过调用release或reset将指针的所有权从一个（非const）unique_ptr转移给另一个unique_ptr<br>
release成员返回unique_ptr当前保存的指针并将其置为空<br>
reset成员接受一个可选的指针参数，令unique_ptr重新指向给定的指针。如果unique_ptr不为空，它原来指向的对象就会被释放<br>
调用release会切断unique_ptr和它原来管理的对象间的联系，release返回的指针通常被用来初始化另一个智能指针或给另一个智能指针赋值。如果我们不用另一个智能指针来保存release返回的指针，我们的程序就要负责资源的释放（注意此时对象还没被销毁）<br>
不能拷贝unique_ptr的规则有一个例外，我们可以拷贝或赋值一个将要被销毁的unique_ptr<br>
unique_ptr默认情况下使用delete释放它指向的对象，但同时我们可以重载unique_ptr中默认的删除器<br>
我们必须在尖括号中unique_ptr指向类型之后提供删除器类型</p>
<p>由于decltype(end_connection)返回一个函数类型，所以我们必须添加一个*来指出我们正在使用该类型的一个指针</p>
<p>习题12.16<br>
vs2015会报错 其拷贝赋值函数已经被定义为删除的函数<br>
<code>error C2280: “std::unique_ptr&lt;std::string,std::default_delete&lt;_Ty&gt;&gt; &amp;std::unique_ptr&lt;_Ty,std::default_delete&lt;_Ty&gt;&gt;::operator =(const std::unique_ptr&lt;_Ty,std::default_delete&lt;_Ty&gt;&gt; &amp;)”: 尝试引用已删除的函数</code><br>
习题12.17<br>
（a）不合法，int并非指针<br>
（b）合法，但这并非是new出来的指针，在栈内存而不是动态内存，所以不应使用智能指针（通过编译，但是编译器会自动delete栈内存，智能指针又delete一次，所以造成二次delete）<br>
（c）合法，都是会造成空悬指针p2的危险<br>
（d）和b一致<br>
（e）合法<br>
（f）合法，但会造成空悬指针或二次删除<br>
注意：<br>
1.unique_ptr不允许拷贝是指不能用一个unique_ptr拷贝到另一个unique_ptr，但是如果使用new出来的普通指针初始化unique_ptr是可以的，<br>
例如</p>
<pre><code>int *pi =new int(42);
unique_ptr&lt;int&gt; p1(pi);
</code></pre>
<p>2.并非是new出来的指针，在栈内存而不是动态内存，所以不应使用智能指针（通过编译，但是编译器会自动delete栈内存，智能指针又delete一次，所以造成二次delete）<br>
习题12.18<br>
因为shared_ptr是可以共享的，没法保证当前的引用数一定为0或1，release的话会导致出现大量的空悬指针</p>
<p>12.1.6weak_ptr<br>
weak_ptr是一种不控制所指向对象生存期的智能指针，它指向由一个shared_str管理的对象。将一个weak_ptr绑定到一个shared_ptr，<strong>不会改变shared_ptr的引用计数</strong><br>
当shared_ptr引用计数为0时，即使有weak_ptr指向对象，对象也还是会被释放</p>
<p>当我们创建一个weak_ptr时，<strong>要用一个shared_ptr来初始化它</strong><br>
由于对象可能不存在，我们<strong>不能使用weak_ptr直接访问对象，而必须调用lock</strong>，此函数检查weak_ptr指向的对象是否仍存在<br>
通过weak_ptr，<strong>不会影响</strong>一个给定的StrBlob所指向的vector的<strong>生存期</strong>，但是可以阻止用户访问一个不再存在的vector的企图。<strong>（强制使用lock返回shared_ptr）</strong></p>
<p>习题12.19<br>
注意对于友元的声明，等于声明加上一个friend，类的声明必须带上class或者struct，但是友元声明不等同于普通声明<br>
习题12.20</p>
<pre><code>class StrBlob {
	friend class StrBlobPtr;
public:
	typedef vector&lt;string&gt;::size_type size_type;
	StrBlob() :data(make_shared&lt;vector&lt;string&gt;&gt;()) {};
	StrBlob(initializer_list&lt;string&gt; i1) :data(make_shared&lt;vector&lt;string&gt;&gt;(i1)) {};
	size_type size() const { return data-&gt;size(); }
	bool empty() const { return data-&gt;empty(); }
	void push_back(const string &amp;t) { data-&gt;push_back(t); }
	void pop_back() {
		check(0, &quot;pop_back on empty StrBlob&quot;);
		data-&gt;pop_back();
	};;
	string&amp; front() {
		check(0, &quot;front on empty StrBlob&quot;);
		return data-&gt;front();
	};
	string&amp; back() {
		check(0, &quot;back on empty StrBlob&quot;);
		return data-&gt;back();
	};
	StrBlobPtr begin();
	StrBlobPtr end();
private:
	shared_ptr&lt;vector&lt;string&gt;&gt; data;
	void check(size_type i, const string &amp;msg)const {
		if (i &gt;= data-&gt;size())
			throw out_of_range(msg);
	};
};

class StrBlobPtr {
public:
	StrBlobPtr() :curr(0) {}
	StrBlobPtr(StrBlob &amp;a, size_t sz = 0) :wptr(a.data), curr(sz) {}
	string&amp; deref() const;
	StrBlobPtr&amp; incr();
private:
	shared_ptr&lt;vector&lt;string&gt;&gt; check(size_t, const string&amp;) const;
	weak_ptr&lt;vector&lt;string&gt;&gt; wptr;
	size_t curr;
};

StrBlobPtr StrBlob::begin() { return StrBlobPtr(*this); }
StrBlobPtr StrBlob::end() { auto ret = StrBlobPtr(*this, data-&gt;size()); return ret; }

shared_ptr&lt;vector&lt;string&gt;&gt; StrBlobPtr::check(size_t i, const string &amp;msg) const {
	auto ret = wptr.lock();
	if (!ret)
		throw runtime_error(&quot;8xing&quot;);
	if (i &gt;= ret-&gt;size())
		throw out_of_range(msg);
	return ret;
}

string&amp; StrBlobPtr::deref() const {
	auto p = check(curr, &quot;8xing&quot;);
	return (*p)[curr];
}

StrBlobPtr&amp; StrBlobPtr::incr() {
	check(curr, &quot;8xing&quot;);
	++curr;
	return *this;
}
int main()
{
	StrBlob sb;
	string s;
	while (cin &gt;&gt; s) {
		sb.push_back(s);
	}
	StrBlobPtr sbp(sb, 0);
	int i = sb.size();
	while (i) {
		cout &lt;&lt; sbp.deref();
		sbp.incr();
		--i;
	}
}
</code></pre>
<p>涉及了两个class相互引用的问题<br>
一：2个类需要在一个文件中 二：这2个函数必须先声明不定义 三: 函数的定义必须放到StrBlobPtr定义的后面 希望能帮到层主<br>
习题12.21<br>
如果为了性能，就选择题目中的版本，但是为了可读性，还是原版比较好<br>
习题12.22<br>
添加接受const StrBlob&amp;的构造函数就好</p>
<pre><code>	StrBlobPtr(const StrBlob &amp;a, size_t sz = 0) :wptr(a.data), curr(sz) {}
</code></pre>
<p>习题感悟<br>
私有函数private相比于public公有函数的好处在于某些时候可以不用考虑判断条件，比如不用担心会向size_type传入负数<br>
q指针赋给r,如果释放了q，则此时的r指针为空悬指针。<br>
注意<code>process(shared_ptr&lt;int&gt;(p))</code>虽然是复制，但是指向的对象相同，智能指针照样会计数+1然后计数-1销毁内存，而因为两者指向相同的对象，导致原来的普通指针p变成空悬指针。<br>
删除p之后，会导致p指向的内存被释放，此时sp就会变成空悬指针，在sp指针被销毁时，该块内存会被二次delete，执行后产生错误：double free<br>
1.unique_ptr不允许拷贝是指不能用一个unique_ptr拷贝到另一个unique_ptr，但是如果使用new出来的普通指针初始化unique_ptr是可以的，<br>
例如</p>
<pre><code>int *pi =new int(42);
unique_ptr&lt;int&gt; p1(pi);
</code></pre>
<p>2.并非是new出来的指针，在栈内存而不是动态内存，所以不应使用智能指针（通过编译，但是编译器会自动delete栈内存，智能指针又delete一次，所以造成二次delete）<br>
注意对于友元的声明，等于声明加上一个friend，类的声明必须带上class或者struct，但是友元声明不等同于普通声明<br>
涉及了两个class相互引用的问题<br>
一：2个类需要在一个文件中 二：这2个函数必须先声明不定义 三: 函数的定义必须放到StrBlobPtr定义的后面 希望能帮到层主</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vptr指针[unfinished]]]></title>
        <id>https://lixin-ee.github.io//post/vptr-zhi-zhen-wei-yue-du</id>
        <link href="https://lixin-ee.github.io//post/vptr-zhi-zhen-wei-yue-du">
        </link>
        <updated>2019-10-15T12:19:55.000Z</updated>
        <content type="html"><![CDATA[<p>原文<a href="https://www.cnblogs.com/yangguang-it/p/6547314.html">c++多态之——vptr指针</a><br>
之前做过一个测试，在一个类中定义一个virtual修饰的函数时，sizeof这个类，发现类的大小多了恰好一个指针的字节大小，当初不明白，只是记住有这么一个特性。后来，发现它就是c++编译器给我们添加的vptr指针。</p>
<p>当类中声明虚函数时，编译器会在类中生成一个虚函数表；</p>
<p>虚函数表是一个存储成员函数指针的数据结构；</p>
<p>虚函数表是由编译器自动生成与维护的；</p>
<p>virtual成员函数会被编译器放入虚函数表中；</p>
<p>存在虚函数时，每个对象都有一个指向虚函数的指针（vptr指针）</p>
<p>在实现多态的过程中，父类和派生类都有vptr指针。</p>
<p>对象中的vptr指针什么时候被初始化：</p>
<p>对象在创建时，由编译器对vptr指针进行初始化；</p>
<p>只有当对象的构造完全结束后vptr的指向才最终决定下来；</p>
<p>父类对象的vptr指向父类的虚函数表，子类对象的vptr指向子类的虚函数表。</p>
<p>定义子类对象时，vptr先指向父类的虚函数表，在父类构造完成之后，子类的vptr才指向自己的虚函数表。（这也就是在父类或者子类的构造函数中调用虚成员函数不会实现多态的原因，这是一道面试题）</p>
]]></content>
    </entry>
</feed>