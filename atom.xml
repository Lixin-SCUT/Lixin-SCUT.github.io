<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-05-10T15:43:42.501Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>千里之行，始于足下。不积跬步，无以至千里。</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[ Python - 面向对象高级编程]]></title>
        <id>https://lixin-scut.github.io//post/python-mian-xiang-dui-xiang-gao-ji-bian-cheng</id>
        <link href="https://lixin-scut.github.io//post/python-mian-xiang-dui-xiang-gao-ji-bian-cheng">
        </link>
        <updated>2020-05-10T12:48:52.000Z</updated>
        <content type="html"><![CDATA[<h2 id="__slots__"><code>__slots__</code></h2>
<p>正常情况下，当我们定义了一个class，创建了一个class的实例后，我们可以给该实例绑定任何属性和方法，这就是动态语言的灵活性。先定义class：</p>
<pre><code>class Student(object):
    pass
</code></pre>
<p>然后，尝试<strong>给实例绑定一个属性</strong>：</p>
<pre><code>&gt;&gt;&gt; s = Student()
&gt;&gt;&gt; s.name = 'Michael' # 动态给实例绑定一个属性
&gt;&gt;&gt; print(s.name)
Michael
</code></pre>
<p>还可以尝试<strong>给实例绑定一个方法</strong>：</p>
<pre><code>&gt;&gt;&gt; def set_age(self, age): # 定义一个函数作为实例方法
...     self.age = age
...
&gt;&gt;&gt; from types import MethodType
&gt;&gt;&gt; s.set_age = MethodType(set_age, s) # 给实例绑定一个方法
&gt;&gt;&gt; s.set_age(25) # 调用实例方法
&gt;&gt;&gt; s.age # 测试结果
25
</code></pre>
<p>但是明显地，<strong>给一个实例绑定的方法，对另一个实例是不起作用的</strong>：</p>
<pre><code>&gt;&gt;&gt; s2 = Student() # 创建新的实例
&gt;&gt;&gt; s2.set_age(25) # 尝试调用方法
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'Student' object has no attribute 'set_age'
</code></pre>
<p><strong>为了给所有实例都绑定方法，可以给class绑定方法</strong>：</p>
<pre><code>&gt;&gt;&gt; def set_score(self, score):
...     self.score = score
...
&gt;&gt;&gt; Student.set_score = set_score
</code></pre>
<p><strong>给class绑定方法后，所有实例均可调用</strong>：</p>
<pre><code>&gt;&gt;&gt; s.set_score(100)
&gt;&gt;&gt; s.score
100
&gt;&gt;&gt; s2.set_score(99)
&gt;&gt;&gt; s2.score
99
</code></pre>
<p>通常情况下，上面的set_score方法可以直接定义在class中，但<strong>动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言中很难实现</strong>。</p>
<h3 id="使用__slots__">使用__slots__</h3>
<p>但是，如果我们想要限制实例的属性，比如只允许对Student实例添加name和age属性。</p>
<p>为了达到限制的目的，Python允许在定义class的时候，<strong>定义一个特殊的slots变量，来限制该class实例能添加的属性</strong>：</p>
<pre><code>class Student(object):
    __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称
</code></pre>
<p>用tuple定义允许绑定的属性名称<br>
然后，我们试试：</p>
<pre><code>&gt;&gt;&gt; s = Student() # 创建新的实例
&gt;&gt;&gt; s.name = 'Michael' # 绑定属性'name'
&gt;&gt;&gt; s.age = 25 # 绑定属性'age'
&gt;&gt;&gt; s.score = 99 # 绑定属性'score'
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'Student' object has no attribute 'score'
</code></pre>
<p><strong>由于'score'没有被放到slots中，所以不能绑定score属性，试图绑定score将得到AttributeError的错误。</strong></p>
<p>使用__slots__要注意，<code>__slots__</code>定义的属性<strong>仅对当前类的实例起作用</strong>，<strong>对继承的子类是不起作用的</strong>：</p>
<pre><code>&gt;&gt;&gt; class GraduateStudent(Student):
...     pass
...
&gt;&gt;&gt; g = GraduateStudent()
&gt;&gt;&gt; g.score = 9999
</code></pre>
<p><strong>除非在子类中也定义__slots__</strong>，这样，子类实例允许定义的属性就是<strong>自身的__slots__加上父类的__slots__</strong>。</p>
<h2 id="使用property">使用@property</h2>
<p>在绑定属性时，如果直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数，导致可以把成绩随便改：</p>
<pre><code>s = Student()
s.score = 9999
</code></pre>
<p>这显然不合逻辑。为了限制score的范围，可以通过一个set_score()方法来设置成绩，再通过一个get_score()来获取成绩，这样，在set_score()方法里，就可以检查参数：</p>
<pre><code>class Student(object):

    def get_score(self):
         return self._score

    def set_score(self, value):
        if not isinstance(value, int):
            raise ValueError('score must be an integer!')
        if value &lt; 0 or value &gt; 100:
            raise ValueError('score must between 0 ~ 100!')
        self._score = value
</code></pre>
<p>现在，对任意的Student实例进行操作，就不能随心所欲地设置score了：</p>
<pre><code>&gt;&gt;&gt; s = Student()
&gt;&gt;&gt; s.set_score(60) # ok!
&gt;&gt;&gt; s.get_score()
60
&gt;&gt;&gt; s.set_score(9999)
Traceback (most recent call last):
  ...
ValueError: score must between 0 ~ 100!
</code></pre>
<p>但是，上面的调用方法又略显复杂，没有直接用属性这么直接简单。</p>
<p>有没有既能检查参数，又可以用类似属性这样简单的方式来访问类的变量？</p>
<p>还记得装饰器（decorator）可以给函数动态加上功能吗？<strong>对于类的方法，装饰器一样起作用</strong>。Python内置的**@property装饰器<strong>就是</strong>负责把一个方法变成属性调用**的：</p>
<pre><code>class Student(object):

    @property
    def score(self):
        return self._score

    @score.setter
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError('score must be an integer!')
        if value &lt; 0 or value &gt; 100:
            raise ValueError('score must between 0 ~ 100!')
        self._score = value
</code></pre>
<p>@property的实现比较复杂，我们先考察如何使用。<strong>把一个getter方法变成属性，只需要加上@property就可以了</strong>，此时，<strong>@property本身又创建了另一个装饰器@score.setter</strong>，负责把一个<strong>setter方法变成属性赋值</strong>，于是，我们就拥有一个可控的属性操作：</p>
<pre><code>&gt;&gt;&gt; s = Student()
&gt;&gt;&gt; s.score = 60 # OK，实际转化为s.set_score(60)
&gt;&gt;&gt; s.score # OK，实际转化为s.get_score()
60
&gt;&gt;&gt; s.score = 9999
Traceback (most recent call last):
  ...
ValueError: score must between 0 ~ 100!
</code></pre>
<p>注意到这个神奇的@property，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过getter和setter方法来实现的。</p>
<p>还可以定义<strong>只读属性，只定义getter方法，不定义setter方法就是一个只读属性</strong>：</p>
<pre><code>class Student(object):

    @property
    def birth(self):
        return self._birth

    @birth.setter
    def birth(self, value):
        self._birth = value

    @property
    def age(self):
        return 2015 - self._birth
</code></pre>
<p>上面的birth是可读写属性，而<strong>age就是一个只读属性，因为age可以根据birth和当前时间计算出来</strong>。</p>
<h3 id="小结">小结</h3>
<p>@property广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性。</p>
<h2 id="多重继承">多重继承</h2>
<p>继承是面向对象编程的一个重要的方式，因为通过继承，子类就可以扩展父类的功能。</p>
<p>回忆一下Animal类层次的设计，假设我们要实现以下4种动物：</p>
<p>Dog - 狗狗；<br>
Bat - 蝙蝠；<br>
Parrot - 鹦鹉；<br>
Ostrich - 鸵鸟。<br>
如果按照哺乳动物和鸟类归类，我们可以设计出这样的类的层次：</p>
<pre><code>
                ┌───────────────┐
                │    Animal     │
                └───────────────┘
                        │
           ┌────────────┴────────────┐
           │                         │
           ▼                         ▼
    ┌─────────────┐           ┌─────────────┐
    │   Mammal    │           │    Bird     │
    └─────────────┘           └─────────────┘
           │                         │
     ┌─────┴──────┐            ┌─────┴──────┐
     │            │            │            │
     ▼            ▼            ▼            ▼
┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
│   Dog   │  │   Bat   │  │ Parrot  │  │ Ostrich │
└─────────┘  └─────────┘  └─────────┘  └─────────┘
</code></pre>
<p>但是如果按照“能跑”和“能飞”来归类，我们就应该设计出这样的类的层次：</p>
<pre><code>
                ┌───────────────┐
                │    Animal     │
                └───────────────┘
                        │
           ┌────────────┴────────────┐
           │                         │
           ▼                         ▼
    ┌─────────────┐           ┌─────────────┐
    │  Runnable   │           │   Flyable   │
    └─────────────┘           └─────────────┘
           │                         │
     ┌─────┴──────┐            ┌─────┴──────┐
     │            │            │            │
     ▼            ▼            ▼            ▼
┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
│   Dog   │  │ Ostrich │  │ Parrot  │  │   Bat   │
└─────────┘  └─────────┘  └─────────┘  └─────────┘
</code></pre>
<p>如果要把上面的两种分类都包含进来，我们就得设计更多的层次：</p>
<p>哺乳类：能跑的哺乳类，能飞的哺乳类；<br>
鸟类：能跑的鸟类，能飞的鸟类。<br>
这么一来，类的层次就复杂了：</p>
<pre><code>
                ┌───────────────┐
                │    Animal     │
                └───────────────┘
                        │
           ┌────────────┴────────────┐
           │                         │
           ▼                         ▼
    ┌─────────────┐           ┌─────────────┐
    │   Mammal    │           │    Bird     │
    └─────────────┘           └─────────────┘
           │                         │
     ┌─────┴──────┐            ┌─────┴──────┐
     │            │            │            │
     ▼            ▼            ▼            ▼
┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
│  MRun   │  │  MFly   │  │  BRun   │  │  BFly   │
└─────────┘  └─────────┘  └─────────┘  └─────────┘
     │            │            │            │
     │            │            │            │
     ▼            ▼            ▼            ▼
┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
│   Dog   │  │   Bat   │  │ Ostrich │  │ Parrot  │
└─────────┘  └─────────┘  └─────────┘  └─────────┘

</code></pre>
<p>如果要再增加“宠物类”和“非宠物类”，这么搞下去，类的数量会呈指数增长，很明显这样设计是不行的。</p>
<p>正确的做法是采用多重继承。首先，主要的类层次仍按照哺乳类和鸟类设计：</p>
<pre><code>class Animal(object):
    pass

# 大类:
class Mammal(Animal):
    pass

class Bird(Animal):
    pass

# 各种动物:
class Dog(Mammal):
    pass

class Bat(Mammal):
    pass

class Parrot(Bird):
    pass

class Ostrich(Bird):
    pass
</code></pre>
<p>现在，我们要给动物再加上Runnable和Flyable的功能，只需要先定义好Runnable和Flyable的类：</p>
<pre><code>class Runnable(object):
    def run(self):
        print('Running...')

class Flyable(object):
    def fly(self):
        print('Flying...')
</code></pre>
<p>对于需要Runnable功能的动物，就多继承一个Runnable，例如Dog：</p>
<pre><code>class Dog(Mammal, Runnable):
    pass
</code></pre>
<p>对于需要Flyable功能的动物，就多继承一个Flyable，例如Bat：</p>
<pre><code>class Bat(Mammal, Flyable):
    pass
</code></pre>
<p><strong>通过多重继承，一个子类就可以同时获得多个父类的所有功能</strong>。</p>
<h3 id="mixin">MixIn</h3>
<p>自己的理解：</p>
<ol>
<li><strong>多继承是多继承，MixIn 是 MixIn，为啥要放一块比较，MixIn 是基于多继承实现的一种设计模式，一般是将复杂类的一些功能拆分出来，不用__init__初始化方法，不让其单独工作，只用作混入其他类使用</strong></li>
<li><strong>最后得出的结论继承和MixIn之间的关系就像，一颗大树，继承就好比树干一直到最粗的那一根树枝的末梢，然后MixIn就像那些小的枝丫，给这根最粗的树枝和树干做装饰用的，觉得少了什么东西就可以写一个mixin，然后让子类“继承”它，不过这个后写的东西它里面装的始终是装饰（比如写一个常用的函数，然后一旦需要调用这个函数了就直接在子类里面把它加上就好啦），主要继承的父类还和单继承没啥区别</strong></li>
</ol>
<p>在设计类的继承关系时，通常，主线都是单一继承下来的，例如，Ostrich继承自Bird。但是，<strong>如果需要“混入”额外的功能，通过多重继承就可以实现</strong>，比如，让Ostrich除了继承自Bird外，再同时继承Runnable。<strong>这种设计通常称之为MixIn</strong>。</p>
<p>为了更好地看出继承关系，我们把Runnable和Flyable改为RunnableMixIn和FlyableMixIn。类似的，你还可以定义出肉食动物CarnivorousMixIn和植食动物HerbivoresMixIn，让某个动物同时拥有好几个MixIn：</p>
<pre><code>class Dog(Mammal, RunnableMixIn, CarnivorousMixIn):
    pass
</code></pre>
<p><strong>MixIn的目的就是给一个类增加多个功能</strong>，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。</p>
<p>Python自带的很多库也使用了MixIn。举个例子，Python自带了TCPServer和UDPServer这两类网络服务，而要同时服务多个用户就必须使用多进程或多线程模型，这两种模型由ForkingMixIn和ThreadingMixIn提供。通过组合，我们就可以创造出合适的服务来。</p>
<p>比如，编写一个多进程模式的TCP服务，定义如下：</p>
<pre><code>class MyTCPServer(TCPServer, ForkingMixIn):
    pass
</code></pre>
<p>编写一个多线程模式的UDP服务，定义如下：</p>
<pre><code>class MyUDPServer(UDPServer, ThreadingMixIn):
    pass
</code></pre>
<p>如果你打算搞一个更先进的协程模型，可以编写一个CoroutineMixIn：</p>
<pre><code>class MyTCPServer(TCPServer, CoroutineMixIn):
    pass
</code></pre>
<p>这样一来，我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类。</p>
<h3 id="小结-2">小结</h3>
<p>由于Python允许使用多重继承，因此，MixIn就是一种常见的设计。</p>
<p><strong>只允许单一继承的语言（如Java）不能使用MixIn的设计</strong>。</p>
<p>C++也允许单一继承，但是存在菱形继承的问题</p>
<h2 id="定制类">定制类</h2>
<p>看到<strong>类似__slots__这种形如__xxx__的变量或者函数名</strong>就要注意，这些在Python中是有<strong>特殊用途</strong>的。</p>
<p><code>__slots__</code>我们已经知道怎么用了，<code>__len__()</code>方法我们也知道是为了能让class作用于len()函数。</p>
<p>除此之外，Python的class中还有许多这样有特殊用途的函数，可以帮助我们定制类。</p>
<h3 id="__str__"><code>__str__</code></h3>
<p>我们先定义一个Student类，打印一个实例：</p>
<pre><code>&gt;&gt;&gt; class Student(object):
...     def __init__(self, name):
...         self.name = name
...
&gt;&gt;&gt; print(Student('Michael'))
&lt;__main__.Student object at 0x109afb190&gt;
</code></pre>
<p>打印出一堆<code>&lt;__main__.Student object at 0x109afb190&gt;</code>，不好看。</p>
<p>怎么才能打印得好看呢？只需要定义好__str__()方法，返回一个好看的字符串就可以了：</p>
<pre><code>&gt;&gt;&gt; class Student(object):
...     def __init__(self, name):
...         self.name = name
...     def __str__(self):
...         return 'Student object (name: %s)' % self.name
...
&gt;&gt;&gt; print(Student('Michael'))
Student object (name: Michael)
</code></pre>
<p>这样打印出来的实例，不但好看，而且容易看出实例内部重要的数据。</p>
<p>但如果直接输出变量而不用print，打印出来的实例还是不好看：</p>
<pre><code>&gt;&gt;&gt; s = Student('Michael')
&gt;&gt;&gt; s
&lt;__main__.Student object at 0x109afb310&gt;
</code></pre>
<p>这是因为直接显示变量调用的不是<code>__str__()</code>，而是<code>__repr__()</code>，两者的区别是<code>__str__()</code>返回<strong>用户</strong>看到的字符串，而<code>__repr__()</code>返回<strong>程序开发者</strong>看到的字符串，也就是说，<code>__repr__()</code>是为<strong>调试服务的</strong>。</p>
<p>解决办法是再定义一个__repr__()。但是通常__str__()和__repr__()代码都是一样的，所以，有个偷懒的写法：</p>
<pre><code>class Student(object):
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return 'Student object (name=%s)' % self.name
    __repr__ = __str__
</code></pre>
<h3 id="__iter__"><code>__iter__</code></h3>
<p>如果<strong>一个类想被用于for ... in循环</strong>，类似list或tuple那样，就必须实现一个__iter__()方法<br>
<code>__iter__()</code>方法返回一个迭代对象，然后，Python的for循环就会<strong>不断调用该迭代对象的__next__()方法</strong>拿到循环的下一个值，直到遇到StopIteration错误时退出循环。</p>
<p>我们以斐波那契数列为例，写一个Fib类，可以作用于for循环：</p>
<pre><code>class Fib(object):
    def __init__(self):
        self.a, self.b = 0, 1 # 初始化两个计数器a，b

    def __iter__(self):
        return self # 实例本身就是迭代对象，故返回自己

    def __next__(self):
        self.a, self.b = self.b, self.a + self.b # 计算下一个值
        if self.a &gt; 100000: # 退出循环的条件
            raise StopIteration()
        return self.a # 返回下一个值
</code></pre>
<p>现在，试试把Fib实例作用于for循环：</p>
<pre><code>&gt;&gt;&gt; for n in Fib():
...     print(n)
...
1
1
2
3
5
...
46368
75025
</code></pre>
<h3 id="__getitem__"><code>__getitem__</code></h3>
<p>Fib实例虽然能作用于for循环，看起来和list有点像，但是，把它当成list来使用还是不行，比如，取第5个元素：</p>
<pre><code>&gt;&gt;&gt; Fib()[5]
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: 'Fib' object does not support indexing
</code></pre>
<p>要表现得像list那样按照下标取出元素，需要实现__getitem__()方法：</p>
<pre><code>class Fib(object):
    def __getitem__(self, n):
        a, b = 1, 1
        for x in range(n):
            a, b = b, a + b
        return a
</code></pre>
<p>现在，就可以按下标访问数列的任意一项了：</p>
<pre><code>&gt;&gt;&gt; f = Fib()
&gt;&gt;&gt; f[0]
1
&gt;&gt;&gt; f[1]
1
&gt;&gt;&gt; f[2]
2
&gt;&gt;&gt; f[3]
3
&gt;&gt;&gt; f[10]
89
&gt;&gt;&gt; f[100]
573147844013817084101
</code></pre>
<p>但是list有个神奇的切片方法：</p>
<pre><code>&gt;&gt;&gt; list(range(100))[5:10]
[5, 6, 7, 8, 9]
</code></pre>
<p>对于Fib却报错。原因是__getitem__()传入的参数可能是一个int，也可能是一个切片对象slice，所以要做判断：</p>
<pre><code>class Fib(object):
    def __getitem__(self, n):
        if isinstance(n, int): # n是索引
            a, b = 1, 1
            for x in range(n):
                a, b = b, a + b
            return a
        if isinstance(n, slice): # n是切片
            start = n.start
            stop = n.stop
						# 如果start为空，则默认为0
            if start is None:
                start = 0
            a, b = 1, 1
            L = []
            for x in range(stop):
                if x &gt;= start:
                    L.append(a)
                a, b = b, a + b
            return L
</code></pre>
<p>现在试试Fib的切片：</p>
<pre><code>&gt;&gt;&gt; f = Fib()
&gt;&gt;&gt; f[0:5]
[1, 1, 2, 3, 5]
&gt;&gt;&gt; f[:10]
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
</code></pre>
<p>但是没有对step参数作处理：</p>
<pre><code>&gt;&gt;&gt; f[:10:2]
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
</code></pre>
<p>也没有对负数作处理，所以，要正确实现一个<code>__getitem__()</code>还是有很多工作要做的。</p>
<p>此外，如果把对象看成dict，<code>__getitem__()</code>的参数也可能是一个可以作key的object，例如str。</p>
<p>与之对应的是<code>__setitem__()</code>方法，把对象视作list或dict来对集合赋值。最后，还有一个<code>__delitem__()</code>方法，用于删除某个元素。</p>
<p>总之，<strong>通过上面的方法，我们自己定义的类表现得和Python自带的list、tuple、dict没什么区别</strong>，这完全归功于<strong>动态语言的“鸭子类型”</strong>，不需要强制继承某个接口。</p>
<h3 id="__getattr__"><code>__getattr__</code></h3>
<p>正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。比如定义Student类：</p>
<pre><code>class Student(object):
    
    def __init__(self):
        self.name = 'Michael'
</code></pre>
<p>调用name属性正常，但是，调用不存在的score属性，就有问题了：</p>
<pre><code>&gt;&gt;&gt; s = Student()
&gt;&gt;&gt; print(s.name)
Michael
&gt;&gt;&gt; print(s.score)
Traceback (most recent call last):
  ...
AttributeError: 'Student' object has no attribute 'score'
</code></pre>
<p>错误信息很清楚地告诉我们，没有找到score这个attribute。</p>
<p>要避免这个错误，除了可以加上一个score属性外，Python还有另一个机制，那就是<strong>写一个<code>__getattr__()</code>方法，动态返回一个属性</strong>。修改如下：</p>
<pre><code>class Student(object):

    def __init__(self):
        self.name = 'Michael'

    def __getattr__(self, attr):
        if attr=='score':
            return 99
</code></pre>
<p>当调用不存在的属性时，比如score，Python解释器会试图调用__getattr__(self, 'score')来尝试获得属性，这样，我们就有机会返回score的值：</p>
<pre><code>&gt;&gt;&gt; s = Student()
&gt;&gt;&gt; s.name
'Michael'
&gt;&gt;&gt; s.score
99
</code></pre>
<p>返回函数也是完全可以的：</p>
<pre><code>class Student(object):

    def __getattr__(self, attr):
        if attr=='age':
            return lambda: 25
</code></pre>
<p>只是调用方式要变为：</p>
<pre><code>&gt;&gt;&gt; s.age()
25
</code></pre>
<p>注意，<strong>只有在没有找到属性的情况下，才调用__getattr__，已有的属性，比如name，不会在__getattr__中查找</strong>。</p>
<p>此外，<strong>如果定义了__getattr__，那么如果调用没有在__getattr__中找到相应的属性</strong>，如s.abc都会返回None，这是<strong>因为我们定义的__getattr__默认返回就是None</strong>。要让class只响应特定的几个属性，我们就要按照约定，抛出AttributeError的错误：</p>
<pre><code>class Student(object):

    def __getattr__(self, attr):
        if attr=='age':
            return lambda: 25
        raise AttributeError('\'Student\' object has no attribute \'%s\'' % attr)
</code></pre>
<p>这实际上可以<strong>把一个类的所有属性和方法调用全部动态化处理</strong>了，不需要任何特殊手段。</p>
<p>这种完全动态调用的特性有什么实际作用呢？作用就是，可以针对完全动态的情况作调用。</p>
<p>举个例子：</p>
<p>现在很多网站都搞REST API，比如新浪微博、豆瓣啥的，调用API的URL类似：</p>
<p>http://api.server/user/friends<br>
http://api.server/user/timeline/list<br>
如果要写SDK，给每个URL对应的API都写一个方法，那得累死，而且，API一旦改动，SDK也要改。</p>
<p><strong>利用完全动态的__getattr__，我们可以写出一个链式调用</strong>：</p>
<pre><code>class Chain(object):

    def __init__(self, path=''):
        self._path = path

    def __getattr__(self, path):
        return Chain('%s/%s' % (self._path, path))

    def __str__(self):
        return self._path

    __repr__ = __str__

&gt;&gt;&gt; Chain().status.user.timeline.list
'/status/user/timeline/list'
</code></pre>
<p>这样，无论API怎么变，SDK都可以根据URL实现完全动态的调用，而且，不随API的增加而改变！</p>
<p>还有些REST API会把参数放到URL中，比如GitHub的API：</p>
<pre><code>GET /users/:user/repos
</code></pre>
<p>调用时，需要把:user替换为实际用户名。如果我们能写出这样的链式调用：</p>
<pre><code>Chain().users('michael').repos
</code></pre>
<pre><code># 实现代码
class Chain(object):
    def __init__(self, path=''):
       self.__path = path

   def __getattr__(self, path):
       return Chain('%s/%s' % (self.__path, path))

   def __call__(self, path):
       return Chain('%s/%s' % (self.__path, path))

   def __str__(self):
       return self.__path

   __repr__ = __str__

print(Chain().users('michael').repos)
/users/michael/repos
</code></pre>
<p>就可以非常方便地调用API了。</p>
<h3 id="__call__"><code>__call__</code></h3>
<p>一个对象实例可以有自己的属性和方法，当我们调用实例方法时，我们用instance.method()来调用。但同时也能直接在实例本身上调用</p>
<p><strong>任何类，只需要定义一个__call__()方法，就可以直接对实例进行调用</strong>。请看示例：</p>
<pre><code>class Student(object):
    def __init__(self, name):
        self.name = name

    def __call__(self):
        print('My name is %s.' % self.name)
</code></pre>
<p>调用方式如下：</p>
<pre><code>&gt;&gt;&gt; s = Student('Michael')
&gt;&gt;&gt; s() # self参数不要传入
My name is Michael.
</code></pre>
<p><code>__call__()</code><strong>还可以定义参数</strong>。对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。</p>
<p>如果你把<strong>对象看成函数</strong>，那么函数本身其实也可以<strong>在运行期动态创建出来</strong>，因为类的实例都是运行期创建出来的，这么一来，我们就模糊了对象和函数的界限。</p>
<p>那么，<strong>怎么判断一个变量是对象还是函数</strong>呢？其实，更多的时候，我们需要判断一个对象是否能被调用，<strong>能被调用的对象就是一个Callable对象</strong>，比如函数和我们上面定义的带有__call__()的类实例：</p>
<pre><code>&gt;&gt;&gt; callable(Student())
True
&gt;&gt;&gt; callable(max)
True
&gt;&gt;&gt; callable([1, 2, 3])
False
&gt;&gt;&gt; callable(None)
False
&gt;&gt;&gt; callable('str')
False
</code></pre>
<p><strong>通过callable()函数，我们就可以判断一个对象是否是“可调用”对象。</strong></p>
<h2 id="枚举类">枚举类</h2>
<p>当我们<strong>需要定义常量时，一个办法是用大写变量通过整数来定义</strong>，例如月份：</p>
<pre><code>JAN = 1
FEB = 2
MAR = 3
...
NOV = 11
DEC = 12
</code></pre>
<p>好处是简单，缺点是类型是int，并且仍然是变量。</p>
<p>更好的方法是为这样的<strong>枚举类型定义一个class类型</strong>，然后，每个常量都是class的一个唯一实例。Python提供了<strong>Enum类</strong>来实现这个功能：</p>
<pre><code>from enum import Enum

Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))
</code></pre>
<p>这样我们就获得了Month类型的枚举类，可以直接使用Month.Jan来引用一个常量，或者枚举它的所有成员：</p>
<pre><code>for name, member in Month.__members__.items():
    print(name, '=&gt;', member, ',', member.value)
</code></pre>
<p>特殊属性<code>__members__</code>是一个将名称映射到成员的有序字典，也可以通过它来完成遍历</p>
<p>value属性则是自动赋给成员的int常量，<strong>默认从1开始计数</strong>。<br>
<strong>注意不是从0开始！！！</strong></p>
<p>如果需要<strong>更精确地控制枚举类型</strong>，可以<strong>从Enum派生出自定义类</strong>：</p>
<pre><code>from enum import Enum, unique

@unique
class Weekday(Enum):
    Sun = 0 # Sun的value被设定为0
    Mon = 1
    Tue = 2
    Wed = 3
    Thu = 4
    Fri = 5
    Sat = 6
</code></pre>
<p>@unique装饰器可以帮助我们检查保证没有重复值。</p>
<p>访问这些枚举类型可以有若干种方法：</p>
<pre><code>
&gt;&gt;&gt; day1 = Weekday.Mon
&gt;&gt;&gt; print(day1)
Weekday.Mon
&gt;&gt;&gt; print(Weekday.Tue)
Weekday.Tue
&gt;&gt;&gt; print(Weekday['Tue'])
Weekday.Tue

&gt;&gt;&gt; print(Weekday.Tue.value)
2

&gt;&gt;&gt; print(day1 == Weekday.Mon)
True
&gt;&gt;&gt; print(day1 == Weekday.Tue)
False

&gt;&gt;&gt; print(Weekday(1))
Weekday.Mon
&gt;&gt;&gt; print(day1 == Weekday(1))
True

&gt;&gt;&gt; Weekday(7)
Traceback (most recent call last):
  ...
ValueError: 7 is not a valid Weekday

&gt;&gt;&gt; for name, member in Weekday.__members__.items():
...     print(name, '=&gt;', member)
...
Sun =&gt; Weekday.Sun
Mon =&gt; Weekday.Mon
Tue =&gt; Weekday.Tue
Wed =&gt; Weekday.Wed
Thu =&gt; Weekday.Thu
Fri =&gt; Weekday.Fri
Sat =&gt; Weekday.Sat
</code></pre>
<p>可见，既可以<strong>用成员名称引用枚举常量</strong>，又可以<strong>直接根据value的值获得枚举常量</strong>。</p>
<p>网友评论：推荐直接看这个讲解枚举的链接https://segmentfault.com/a/1190000017327003</p>
<h3 id="使用-enum">使用 Enum</h3>
<p>更好的方式是使用标准库提供的 Enum 类型，官方库值得信赖。3.4 之前的版本也可以通过 pip install enum 下载支持的库。简单的示例：</p>
<pre><code>from enum import Enum
class Color(Enum):
    red = 1
    green = 2
    blue = 3
</code></pre>
<p>枚举成员有值（默认可重复），枚举成员具有友好的字符串表示：</p>
<pre><code>&gt;&gt;&gt; print(Color.red)
Color.red
&gt;&gt;&gt; print(repr(Color.red))
&lt;Color.red: 1&gt;
&gt;&gt;&gt; type(Color.red)
&lt;Enum 'Color'&gt;
&gt;&gt;&gt; isinstance(Color.green, Color)
True
</code></pre>
<p><strong>枚举类型不可实例化，不可更改</strong>。</p>
<h3 id="定义枚举">定义枚举</h3>
<p><strong>定义枚举时，成员名不允许重复</strong></p>
<pre><code>class Color(Enum):
    red = 1
    green = 2
    red = 3    # TypeError: Attempted to reuse key: 'red'
</code></pre>
<p><strong>成员值允许相同</strong>，<strong>第二个成员的名称被视作第一个成员的别名</strong></p>
<pre><code>class Color(Enum):
    red   = 1
    green = 2
    blue  = 1

print(Color.red)              # Color.red
print(Color.blue)             # Color.red
print(Color.red is Color.blue)# True
print(Color(1))               # Color.red  在通过值获取枚举成员时，只能获取到第一个成员
</code></pre>
<p><strong>若要不能定义相同的成员值，可以通过 unique 装饰</strong></p>
<pre><code>from enum import Enum, unique
@unique
class Color(Enum):
    red   = 1
    green = 2
    blue  = 1  # ValueError: duplicate values found in &lt;enum 'Color'&gt;: blue -&gt; red
</code></pre>
<h3 id="枚举取值">枚举取值</h3>
<p>可以通过成员名来获取成员也可以通过成员值来获取成员:</p>
<pre><code>print(Color['red'])  # Color.red  通过成员名来获取成员

print(Color(1))      # Color.red  通过成员值来获取成员
</code></pre>
<p>每个成员都有<strong>名称属性和值属性</strong>：</p>
<pre><code>member = Color.red
print(member.name)   # red
print(member.value)  # 1
</code></pre>
<p>支持迭代的方式遍历成员，按定义的顺序，如果有值重复的成员，只获取重复的第一个成员：</p>
<pre><code>for color in Color:
    print(color)
</code></pre>
<p>特殊属性<code>__members__</code>是一个<strong>将名称映射到成员的有序字典</strong>，也可以通过它来完成遍历：</p>
<pre><code>for color in Color.__members__.items():
    print(color)          # ('red', &lt;Color.red: 1&gt;)
</code></pre>
<h3 id="枚举比较">枚举比较</h3>
<p>枚举的成员可以通过<strong>is 同一性</strong>比较或<strong>通过 == 等值</strong>比较：</p>
<pre><code>Color.red is Color.red
Color.red is not Color.blue

Color.blue == Color.red
Color.blue != Color.red
</code></pre>
<p>枚举成员<strong>不能进行大小比较</strong>：</p>
<pre><code>
Color.red &lt; Color.blue 
# TypeError: unorderable types: Color() &lt; Color()
</code></pre>
<h3 id="扩展枚举-intenum">扩展枚举 IntEnum</h3>
<p>IntEnum 是 Enum 的扩展，<strong>不同类型的整数枚举也可以相互比较</strong>：</p>
<pre><code>from enum import IntEnum
class Shape(IntEnum):
    circle = 1
    square = 2

class Request(IntEnum):
    post = 1
    get = 2

print(Shape.circle == 1)            # True
print(Shape.circle &lt; 3)             # True
print(Shape.circle == Request.post) # True
print(Shape.circle &gt;= Request.post) # True
</code></pre>
<h2 id="使用元类">使用元类</h2>
<h3 id="type">type()</h3>
<p>动态语言和静态语言最大的不同，就是<strong>函数和类的定义</strong>，<strong>不是编译时定义的，而是运行时动态创建的</strong>。</p>
<p>比方说我们要定义一个Hello的class，就写一个hello.py模块：</p>
<pre><code>class Hello(object):
    def hello(self, name='world'):
        print('Hello, %s.' % name)
</code></pre>
<p>当Python解释器载入hello模块时，就会<strong>依次执行该模块的所有语句</strong>，执行结果就是<strong>动态创建出一个Hello的class对象</strong>，测试如下：</p>
<pre><code>&gt;&gt;&gt; from hello import Hello
&gt;&gt;&gt; h = Hello()
&gt;&gt;&gt; h.hello()
Hello, world.
&gt;&gt;&gt; print(type(Hello))
&lt;class 'type'&gt;
&gt;&gt;&gt; print(type(h))
&lt;class 'hello.Hello'&gt;
</code></pre>
<p>type()函数可以<strong>查看一个类型或变量的类型</strong>，Hello是一个<strong>class，它的类型就是type</strong>，而h是一个<strong>实例，它的类型就是class Hello</strong>。</p>
<p>我们说class的定义是运行时动态创建的，而<strong>创建class的方法就是使用type()函数</strong>。</p>
<p>type()函数既可以<strong>返回一个对象的类型</strong>，又可以<strong>创建出新的类型</strong>，比如，我们可以通过type()函数创建出Hello类，而<strong>无需通过class Hello(object)...的定义</strong>：</p>
<pre><code>&gt;&gt;&gt; def fn(self, name='world'): # 先定义函数
...     print('Hello, %s.' % name)
...
&gt;&gt;&gt; Hello = type('Hello', (object,), dict(hello=fn)) # 创建Hello class
&gt;&gt;&gt; h = Hello()
&gt;&gt;&gt; h.hello()
Hello, world.
&gt;&gt;&gt; print(type(Hello))
&lt;class 'type'&gt;
&gt;&gt;&gt; print(type(h))
&lt;class '__main__.Hello'&gt;
</code></pre>
<p>要创建一个class对象，type()函数依次传入3个参数：</p>
<ol>
<li>class的名称；</li>
<li>继承的父类集合，注意Python支持多重继承，如果<strong>只有一个父类，别忘了tuple的单元素写法</strong>；</li>
<li><strong>class的方法名称与函数绑定</strong>，这里我们把函数fn绑定到方法名hello上。</li>
</ol>
<p>通过type()函数创建的类和直接写class是完全一样的，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用type()函数创建出class。</p>
<p>正常情况下，我们都用class Xxx...来定义类，但是，<strong>type()函数也允许我们动态创建出类来</strong>，也就是说，<strong>动态语言本身支持运行期动态创建类</strong>，这和静态语言有非常大的不同，要在静态语言运行期创建类，必须构造源代码字符串再调用编译器，或者借助一些工具生成字节码实现，本质上都是动态编译，会非常复杂。</p>
<h3 id="metaclass">metaclass</h3>
<p>除了使用type()动态创建类以外，要<strong>控制类的创建行为</strong>，还可以使用metaclass。</p>
<p>metaclass，直译为元类，简单的解释就是：</p>
<p>当我们定义了类以后，就可以根据这个类创建出实例，所以：先定义类，然后创建实例。</p>
<p>但是如果我们<strong>想创建出类</strong>，那就必须根据metaclass创建出类，所以：<strong>先定义metaclass，然后创建类</strong>。</p>
<p>连接起来就是：先定义metaclass，就可以创建类，最后创建实例。</p>
<p>所以，metaclass允许你创建类或者修改类。换句话说，你<strong>可以把类看成是metaclass创建出来的“实例”</strong>。</p>
<p>metaclass是Python面向对象里最难理解，也是最难使用的魔术代码。正常情况下，你不会碰到需要使用metaclass的情况，所以，以下内容看不懂也没关系，因为基本上你不会用到。</p>
<p>我们先看一个简单的例子，这个metaclass可以给我们自定义的MyList增加一个add方法：</p>
<p>定义ListMetaclass，按照默认习惯，metaclass的类名总是以Metaclass结尾，以便清楚地表示这是一个metaclass：</p>
<pre><code>#metaclass是类的模板，所以必须从`type`类型派生：
class ListMetaclass(type):
    def __new__(cls, name, bases, attrs):
        attrs['add'] = lambda self, value: self.append(value)
        return type.__new__(cls, name, bases, attrs)
</code></pre>
<p>有了ListMetaclass，我们<strong>在定义类的时候还要指示使用ListMetaclass来定制类，传入关键字参数metaclass</strong>：</p>
<pre><code>class MyList(list, metaclass=ListMetaclass):
    pass
</code></pre>
<p>当我们传入关键字参数metaclass时，魔术就生效了，它指示Python解释器在<strong>创建MyList时，要通过<code>ListMetaclass. __new__()</code>来创建</strong><br>
在此之上，我们可以修改类的定义，比如，加上新的方法，然后，返回修改后的定义。</p>
<p><code>__new__()</code>方法接收到的参数依次是：</p>
<ol>
<li>
<p>当前准备创建的类的对象；</p>
</li>
<li>
<p>类的名字；</p>
</li>
<li>
<p>类继承的父类集合；</p>
</li>
<li>
<p>类的方法集合。</p>
</li>
</ol>
<p>测试一下MyList是否可以调用add()方法：</p>
<pre><code>&gt;&gt;&gt; L = MyList()
&gt;&gt;&gt; L.add(1)
&gt;&gt; L
[1]
</code></pre>
<p>而普通的list没有add()方法：</p>
<pre><code>&gt;&gt;&gt; L2 = list()
&gt;&gt;&gt; L2.add(1)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
	AttributeError: 'list' object has no attribute 'add'
</code></pre>
<p><strong>动态修改</strong>有什么意义？直接在MyList定义中写上add()方法不是更简单吗？正常情况下，确实应该直接写，通过metaclass修改纯属变态。</p>
<p>但是，<strong>总会遇到需要通过metaclass修改类定义的。ORM就是一个典型的例子</strong>。</p>
<p>ORM全称“Object Relational Mapping”，即<strong>对象-关系映射，就是把关系数据库的一行映射为一个对象，也就是一个类对应一个表</strong>，这样，写代码更简单，<strong>不用直接操作SQL语句</strong>。</p>
<p>要编写一个ORM框架，<strong>所有的类都只能动态定义，因为只有使用者才能根据表的结构定义出对应的类来</strong>。</p>
<p>让我们来尝试编写一个ORM框架。</p>
<p>编写底层模块的第一步，就是先把调用接口写出来。比如，使用者如果使用这个ORM框架，想定义一个User类来操作对应的数据库表User，我们期待他写出这样的代码：</p>
<pre><code>class User(Model):
    # 定义类的属性到列的映射：
    id = IntegerField('id')
    name = StringField('username')
    email = StringField('email')
    password = StringField('password')


# 创建一个实例：
u = User(id=12345, name='Michael', email='test@orm.org', password='my-pwd')
# 保存到数据库：
u.save()
</code></pre>
<p>其中，父类Model和属性类型StringField、IntegerField是由ORM框架提供的，剩下的魔术方法比如save()全部由metaclass自动完成。虽然metaclass的编写会比较复杂，但ORM的使用者用起来却异常简单。</p>
<p>现在，我们就按上面的接口来实现该ORM。</p>
<p>首先来定义Field类，它负责保存数据库表的字段名和字段类型：</p>
<pre><code>class Field(object):

    def __init__(self, name, column_type):
        self.name = name
        self.column_type = column_type

    def __str__(self):
        return '&lt;%s:%s&gt;' % (self.__class__.__name__, self.name)
</code></pre>
<p>在Field的基础上，进一步定义各种类型的Field，比如StringField，IntegerField等等：</p>
<pre><code>class StringField(Field):

    def __init__(self, name):
        super(StringField, self).__init__(name, 'varchar(100)')

class IntegerField(Field):

    def __init__(self, name):
        super(IntegerField, self).__init__(name, 'bigint')
</code></pre>
<p>下一步，就是编写最复杂的ModelMetaclass了：</p>
<pre><code>class ModelMetaclass(type):

    def __new__(cls, name, bases, attrs):
        if name=='Model':
            return type.__new__(cls, name, bases, attrs)
        print('Found model: %s' % name)
        mappings = dict()
        for k, v in attrs.items():
            if isinstance(v, Field):
                print('Found mapping: %s ==&gt; %s' % (k, v))
                mappings[k] = v
        for k in mappings.keys():
            attrs.pop(k)
        attrs['__mappings__'] = mappings # 保存属性和列的映射关系
        attrs['__table__'] = name # 假设表名和类名一致
        return type.__new__(cls, name, bases, attrs)
</code></pre>
<p>以及基类Model：</p>
<pre><code>class Model(dict, metaclass=ModelMetaclass):

    def __init__(self, **kw):
        super(Model, self).__init__(**kw)

    def __getattr__(self, key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(r&quot;'Model' object has no attribute '%s'&quot; % key)

    def __setattr__(self, key, value):
        self[key] = value

    def save(self):
        fields = []
        params = []
        args = []
        for k, v in self.__mappings__.items():
            fields.append(v.name)
            params.append('?')
            args.append(getattr(self, k, None))
        sql = 'insert into %s (%s) values (%s)' % (self.__table__, ','.join(fields), ','.join(params))
        print('SQL: %s' % sql)
        print('ARGS: %s' % str(args))
</code></pre>
<p>当用户定义一个class User(Model)时，Python解释器首先在当前类User的定义中查找metaclass，如果没有找到，就继续在父类Model中查找metaclass，找到了，就使用Model中定义的metaclass的ModelMetaclass来创建User类，也就是说，<strong>metaclass可以隐式地继承到子类，但子类自己却感觉不到</strong>。</p>
<p>在ModelMetaclass中，一共做了几件事情：</p>
<ol>
<li>
<p>排除掉对Model类的修改；</p>
</li>
<li>
<p>在当前类（比如User）中查找定义的类的所有属性，如果找到一个Field属性，就把它保存到一个__mappings__的dict中，同时从类属性中删除该Field属性，否则，容易造成运行时错误（实例的属性会遮盖类的同名属性）；</p>
</li>
<li>
<p>把表名保存到__table__中，这里简化为表名默认为类名。</p>
</li>
</ol>
<p>在Model类中，就可以定义各种操作数据库的方法，比如save()，delete()，find()，update等等。</p>
<p>我们实现了save()方法，把一个实例保存到数据库中。因为有表名，属性到字段的映射和属性值的集合，就可以构造出INSERT语句。</p>
<p>编写代码试试：</p>
<pre><code>u = User(id=12345, name='Michael', email='test@orm.org', password='my-pwd')
u.save()
输出如下：

Found model: User
Found mapping: email ==&gt; &lt;StringField:email&gt;
Found mapping: password ==&gt; &lt;StringField:password&gt;
Found mapping: id ==&gt; &lt;IntegerField:uid&gt;
Found mapping: name ==&gt; &lt;StringField:username&gt;
SQL: insert into User (password,email,username,id) values (?,?,?,?)
ARGS: ['my-pwd', 'test@orm.org', 'Michael', 12345]
</code></pre>
<p>可以看到，save()方法已经打印出了可执行的SQL语句，以及参数列表，只需要真正连接到数据库，执行该SQL语句，就可以完成真正的功能。</p>
<p>不到100行代码，我们就通过metaclass实现了一个精简的ORM框架</p>
<h3 id="小结-3">小结</h3>
<p>metaclass是Python中非常具有魔术性的对象，它可以改变类创建时的行为。这种强大的功能使用起来务必小心。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Python - 面向对象编程]]></title>
        <id>https://lixin-scut.github.io//post/python-mian-xiang-dui-xiang-bian-cheng</id>
        <link href="https://lixin-scut.github.io//post/python-mian-xiang-dui-xiang-bian-cheng">
        </link>
        <updated>2020-05-10T08:51:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="面向对象编程">面向对象编程</h2>
<p>Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。</p>
<p><strong>面向过程</strong>的程序设计把计算机程序视为<strong>一系列的命令集合</strong>，即一组函数的<strong>顺序执行</strong>。为了简化程序设计，面向过程把函数继续<strong>切分为子函数</strong>，即把大块函数通过切割成小块函数来降低系统的复杂度。</p>
<p>而<strong>面向对象</strong>的程序设计把计算机程序视为<strong>一组对象的集合</strong>，而每个对象都可以<strong>接收其他对象发过来的消息，并处理这些消息</strong>，计算机程序的执行就是<strong>一系列消息在各个对象之间传递</strong>。</p>
<p>在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。<strong>自定义的对象数据类型</strong>就是<strong>面向对象中的类（Class）</strong> 的概念。</p>
<p>面向对象的设计思想是抽象出Class，根据Class创建Instance。</p>
<p>面向对象的抽象程度又比函数要高，因为一个Class既包含数据，又包含操作数据的方法。</p>
<h2 id="类和实例">类和实例</h2>
<p>面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。</p>
<p>仍以Student类为例，在Python中，<strong>定义类</strong>是通过<strong>class关键字</strong>：</p>
<pre><code>class Student(object):
    pass
</code></pre>
<p>class后面紧接着是类名，即Student，<strong>类名通常是大写开头的单词</strong>，<strong>紧接着是(object)，表示该类是从哪个类继承下来的</strong><br>
通常，<strong>如果没有合适的继承类，就使用object类</strong>，这是所有类最终都会继承的类。</p>
<p>定义好了Student类，就可以根据Student类创建出Student的实例，<strong>创建实例是通过类名+()实现的</strong>：</p>
<pre><code>&gt;&gt;&gt; bart = Student()
&gt;&gt;&gt; bart
&lt;__main__.Student object at 0x10a67a590&gt;
&gt;&gt;&gt; Student
&lt;class '__main__.Student'&gt;
</code></pre>
<p>可以看到，<strong>变量bart</strong>指向的就是一个Student的实例，后面的0x10a67a590是内存地址，<strong>每个object的地址都不一样</strong>，而<strong>Student本身则是一个类</strong>。</p>
<p>可以自由地给一个实例变量绑定属性，比如，给实例bart绑定一个name属性：</p>
<pre><code>&gt;&gt;&gt; bart.name = 'Bart Simpson'
&gt;&gt;&gt; bart.name
'Bart Simpson'
</code></pre>
<p>由于类可以起到模板的作用，因此，可以<strong>在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去</strong>。通过<strong>定义一个特殊的init方法</strong>，在创建实例的时候，就把name，score等属性绑上去：</p>
<pre><code>class Student(object):

    def __init__(self, name, score):
        self.name = name
        self.score = score
</code></pre>
<p><strong>注意：特殊方法“<code>init</code>”前后分别有两个下划线！！！</strong></p>
<p><strong>注意到init方法的第一个参数永远是self，表示创建的实例本身</strong>，因此，在<code>__init__</code>方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。</p>
<p>有了<code>__init__</code>方法，在创建实例的时候，就不能传入空的参数了，<strong>必须传入与<code>init</code>方法匹配的参数</strong>，<strong>但self不需要传，Python解释器自己会把实例变量传进去：</strong></p>
<pre><code>&gt;&gt;&gt; bart = Student('Bart Simpson', 59)
&gt;&gt;&gt; bart.name
'Bart Simpson'
&gt;&gt;&gt; bart.score
59
</code></pre>
<p>和普通的函数相比，在类中定义的函数只有一点不同，<strong>就是第一个参数永远是实例变量self</strong>，并且调用时不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你<strong>仍然可以用默认参数、可变参数、关键字参数和命名关键字参数</strong>。</p>
<h3 id="数据封装">数据封装</h3>
<p>面向对象编程的一个重要特点就是<strong>数据封装</strong>。在上面的Student类中，每个实例就拥有各自的name和score这些数据。我们<strong>可以通过函数来访问这些数据</strong>，比如打印一个学生的成绩：</p>
<pre><code>&gt;&gt;&gt; def print_score(std):
...     print('%s: %s' % (std.name, std.score))
...
&gt;&gt;&gt; print_score(bart)
Bart Simpson: 59
</code></pre>
<p>但是，既然Student实例本身就拥有这些数据，要访问这些数据，就没有必要从外面的函数去访问，可以<strong>直接在Student类的内部定义访问数据的函数</strong>，这样，就把“数据”给封装起来了。这些封装数据的函数是和Student类本身是关联起来的，我们称之为类的方法：</p>
<pre><code>class Student(object):

    def __init__(self, name, score):
        self.name = name
        self.score = score

    def print_score(self):
        print('%s: %s' % (self.name, self.score))
</code></pre>
<p>要定义一个方法，除了<strong>第一个参数是self</strong>外，其他和普通函数一样。要调用一个方法，<strong>只需要在实例变量上直接调用</strong>，除了self不用传递，其他参数正常传入：</p>
<pre><code>&gt;&gt;&gt; bart.print_score()
Bart Simpson: 59
</code></pre>
<p>这样一来，我们从外部看Student类，就只需要知道，创建实例需要给出name和score，而如何打印，都是在Student类的内部定义的，这些数据和逻辑被“封装”起来了，调用很容易，但却不用知道内部实现的细节。</p>
<p>封装的另一个好处是可以给Student类增加新的方法，比如get_grade：</p>
<pre><code>class Student(object):
    ...

    def get_grade(self):
        if self.score &gt;= 90:
            return 'A'
        elif self.score &gt;= 60:
            return 'B'
        else:
            return 'C'
</code></pre>
<h2 id="访问限制">访问限制</h2>
<p>在Class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样，就隐藏了内部的复杂逻辑。</p>
<p>但是，从前面Student类的定义来看，外部代码还是可以自由地修改一个实例的name、score属性：</p>
<pre><code>&gt;&gt;&gt; bart = Student('Bart Simpson', 59)
&gt;&gt;&gt; bart.score
59
&gt;&gt;&gt; bart.score = 99
&gt;&gt;&gt; bart.score
99
</code></pre>
<p><strong>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<code>__</code><br>
在Python中，实例的变量名如果以<code>__</code>开头，就变成了一个私有变量（private） 只有内部可以访问，外部不能访问</strong><br>
所以，我们把Student类改一改：</p>
<pre><code>class Student(object):

    def __init__(self, name, score):
        self.__name = name
        self.__score = score

    def print_score(self):
        print('%s: %s' % (self.__name, self.__score))
</code></pre>
<p>改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问实例变量<code>.__name</code>和实例变量<code>.__score</code>了：</p>
<pre><code>&gt;&gt;&gt; bart = Student('Bart Simpson', 59)
&gt;&gt;&gt; bart.__name
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'Student' object has no attribute '__name'
</code></pre>
<p>这样就确保了外部代码不能随意修改对象内部的状态，这样通过访问限制的保护，代码更加健壮。</p>
<p>但是如果外部代码要获取name和score，可以给Student类增加get_name和get_score这样的方法：</p>
<pre><code>class Student(object):
    ...

    def get_name(self):
        return self.__name

    def get_score(self):
        return self.__score
</code></pre>
<p>如果又要允许外部代码修改score,可以再给Student类增加set_score方法：</p>
<pre><code>class Student(object):
    ...

    def set_score(self, score):
        self.__score = score
</code></pre>
<p>在方法中，可以对参数做检查，避免传入无效的参数：</p>
<pre><code>class Student(object):
    ...

    def set_score(self, score):
        if 0 &lt;= score &lt;= 100:
            self.__score = score
        else:
            raise ValueError('bad score')
</code></pre>
<p>需要注意的是，在Python中，<strong>变量名类似xxx的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量</strong>，所以，<strong>不能用</strong><code>__name__</code>、<code>__score__</code>这样的变量名。</p>
<p>有些时候会看到以<strong>一个下划线</strong>开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，<strong>“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”</strong>。</p>
<p>双下划线开头的实例变量<strong>是不是一定不能从外部访问呢</strong>？其实也不是。不能直接访问__name是因为Python解释器对外把<code>__name</code>变量<strong>改成了_Studentname</strong>，所以，<strong>仍然可以通过_Studentname来访问</strong><code>__name</code>变量：</p>
<pre><code>&gt;&gt;&gt; bart._Student__name
'Bart Simpson'
</code></pre>
<p>但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把__name改成不同的变量名。</p>
<p>总的来说就是，<strong>Python本身没有任何机制阻止你干坏事，一切全靠自觉</strong>。</p>
<p>最后注意下面的这种错误写法：</p>
<pre><code>&gt;&gt;&gt; bart = Student('Bart Simpson', 59)
&gt;&gt;&gt; bart.get_name()
'Bart Simpson'
&gt;&gt;&gt; bart.__name = 'New Name' # 设置__name变量！
&gt;&gt;&gt; bart.__name
'New Name'
</code></pre>
<p>表面上看，外部代码“成功”地设置了__name变量，但实际上这个__name变量和class内部的__name变量<strong>不是一个变量！</strong> 内部的__name变量已经被Python解释器<strong>自动改成了_Student__name</strong>，而<strong>外部代码给bart新增了一个__name变量</strong>。不信试试：</p>
<pre><code>&gt;&gt;&gt; bart.get_name() # get_name()内部返回self.__name
'Bart Simpson'
</code></pre>
<h2 id="继承和多态">继承和多态</h2>
<p>在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。</p>
<p>比如，我们已经编写了一个名为Animal的class，有一个run()方法可以直接打印：</p>
<pre><code>class Animal(object):
    def run(self):
        print('Animal is running...')
</code></pre>
<p>当我们需要编写Dog和Cat类时，就可以直接从Animal类继承：</p>
<pre><code>class Dog(Animal):
    pass

class Cat(Animal):
    pass
</code></pre>
<p>对于Dog来说，Animal就是它的父类，对于Animal来说，Dog就是它的子类。Cat和Dog类似。</p>
<p>继承有什么好处？<strong>最大的好处是子类获得了父类的全部功能</strong>。由于Animial实现了run()方法，因此，Dog和Cat作为它的子类，什么事也没干，就自动拥有了run()方法：</p>
<pre><code>dog = Dog()
dog.run()

cat = Cat()
cat.run()
</code></pre>
<p>运行结果如下：</p>
<pre><code>Animal is running...
Animal is running...
</code></pre>
<p>当然，也可以对子类增加一些方法，比如Dog类：</p>
<pre><code>class Dog(Animal):

    def run(self):
        print('Dog is running...')

    def eat(self):
        print('Eating meat...')
</code></pre>
<p>继承的第二个好处需要我们对代码做一点改进。你看到了，无论是Dog还是Cat，它们run()的时候，显示的都是Animal is running...，符合逻辑的做法是分别显示Dog is running...和Cat is running...，因此，对Dog和Cat类改进如下：</p>
<pre><code>class Dog(Animal):

    def run(self):
        print('Dog is running...')

class Cat(Animal):

    def run(self):
        print('Cat is running...')
				
</code></pre>
<p>再次运行，结果如下：</p>
<pre><code>Dog is running...
Cat is running...
</code></pre>
<p><strong>当子类和父类都存在相同的run()方法时，我们说，子类的run()覆盖了父类的run()</strong>，在代码运行的时候，总是会调用子类的run()。这样，我们就获得了继承的<strong>另一个好处：多态</strong>。</p>
<p>要理解什么是多态，我们首先要对数据类型再作一点说明。当我们定义一个class的时候，我们实际上就定义了一种数据类型。我们定义的数据类型和Python自带的数据类型，比如str、list、dict没什么两样：</p>
<pre><code>a = list() # a是list类型
b = Animal() # b是Animal类型
c = Dog() # c是Dog类型
</code></pre>
<p>判断一个变量是否是某个类型可以用isinstance()判断：</p>
<pre><code>&gt;&gt;&gt; isinstance(a, list)
True
&gt;&gt;&gt; isinstance(b, Animal)
True
&gt;&gt;&gt; isinstance(c, Dog)
True
</code></pre>
<p>看来a、b、c确实对应着list、Animal、Dog这3种类型。</p>
<p>但是等等，试试：</p>
<pre><code>&gt;&gt;&gt; isinstance(c, Animal)
True
</code></pre>
<p>看来c不仅仅是Dog，c还是Animal！</p>
<p>不过仔细想想，这是有道理的，因为Dog是从Animal继承下来的，当我们创建了一个Dog的实例c时，我们认为c的数据类型是Dog没错，但c同时也是Animal也没错，Dog本来就是Animal的一种！</p>
<p>所以，在继承关系中，<strong>如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类</strong>。但是，反过来就不行：</p>
<pre><code>&gt;&gt;&gt; b = Animal()
&gt;&gt;&gt; isinstance(b, Dog)
False
</code></pre>
<p>Dog可以看成Animal，但Animal不可以看成Dog。</p>
<p>要理解多态的好处，我们还需要再编写一个函数，<strong>这个函数接受一个Animal类型的变量</strong>：</p>
<pre><code>def run_twice(animal):
    animal.run()
    animal.run()
</code></pre>
<p>当我们传入Animal的实例时，run_twice()就打印出：</p>
<pre><code>&gt;&gt;&gt; run_twice(Animal())
Animal is running...
Animal is running...
</code></pre>
<p>当我们传入Dog的实例时，run_twice()就打印出：</p>
<pre><code>&gt;&gt;&gt; run_twice(Dog())
Dog is running...
Dog is running...
</code></pre>
<p>当我们传入Cat的实例时，run_twice()就打印出：</p>
<pre><code>&gt;&gt;&gt; run_twice(Cat())
Cat is running...
Cat is running...
</code></pre>
<p>看上去没啥意思，但是仔细想想，现在，如果我们再定义一个Tortoise类型，也从Animal派生：</p>
<pre><code>class Tortoise(Animal):
    def run(self):
        print('Tortoise is running slowly...')
</code></pre>
<p>当我们调用run_twice()时，传入Tortoise的实例：</p>
<pre><code>&gt;&gt;&gt; run_twice(Tortoise())
Tortoise is running slowly...
Tortoise is running slowly...
</code></pre>
<p>你会发现，<strong>新增一个Animal的子类，不必对run_twice()做任何修改</strong>，实际上，<strong>任何依赖Animal作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态</strong>。</p>
<p>多态的好处就是，当我们需要传入Dog、Cat、Tortoise……时，我们只需要接收Animal类型就可以了，因为Dog、Cat、Tortoise……都是Animal类型，然后，按照Animal类型进行操作即可。由于Animal类型有run()方法，因此，传入的任意类型，<strong>只要是Animal类或者子类，就会自动调用实际类型的run()方法，这就是多态的意思</strong>：</p>
<p>对于一个变量，我们<strong>只需要知道它是Animal类型，无需确切地知道它的子类型，就可以放心地调用run()方法</strong>，而具体调用的run()方法是作用在Animal、Dog、Cat还是Tortoise对象上，<strong>由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节</strong>，而当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：</p>
<p><strong>对扩展开放：允许新增Animal子类；</strong></p>
<p><strong>对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。</strong></p>
<p><strong>继承还可以一级一级地继承下来</strong>，就好比从爷爷到爸爸、再到儿子这样的关系。而任何类，最终都可以追溯到根类object，这些继承关系看上去就像一颗倒着的树。比如如下的继承树：</p>
<pre><code>
                ┌───────────────┐
                │    object     │
                └───────────────┘
                        │
           ┌────────────┴────────────┐
           │                         │
           ▼                         ▼
    ┌─────────────┐           ┌─────────────┐
    │   Animal    │           │    Plant    │
    └─────────────┘           └─────────────┘
           │                         │
     ┌─────┴──────┐            ┌─────┴──────┐
     │            │            │            │
     ▼            ▼            ▼            ▼
┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
│   Dog   │  │   Cat   │  │  Tree   │  │ Flower  │
└─────────┘  └─────────┘  └─────────┘  └─────────┘

</code></pre>
<h3 id="静态语言-vs-动态语言">静态语言 vs 动态语言</h3>
<p>对于<strong>静态语言</strong>（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。</p>
<p><strong>但是注意！！！</strong> 对于Python这样的<strong>动态语言</strong>来说，<strong>则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了</strong>：</p>
<p><strong>这就是动态语言的特征，变量只有在赋值的是后才有“类型-type”。而java静态语言在定义函数的时候，参数的类型已经通过显式声明确定了。所以后面就不能随便传入一个类。</strong></p>
<pre><code>class Timer(object):
    def run(self):
        print('Start...')
</code></pre>
<p>这就是<strong>动态语言的“鸭子类型”，它并不要求严格的继承体系</strong>，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</p>
<p><strong>Python的“file-like object“就是一种鸭子类型</strong>。对真正的文件对象，它有一个read()方法，返回其内容。但是，许多对象，只要有read()方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了read()方法的对象。</p>
<h3 id="小结">小结</h3>
<p>继承可以把父类的所有功能都直接拿过来，这样就不必重零做起，子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写。</p>
<p>动态语言的鸭子类型特点决定了继承不像静态语言那样是必须的。</p>
<h2 id="获取对象信息">获取对象信息</h2>
<p>当我们拿到一个对象的引用时，如何知道这个对象是什么类型、有哪些方法呢？</p>
<h3 id="使用type">使用type()</h3>
<p>使用type()函数来判断对象类型，：</p>
<ol>
<li><strong>基本类型</strong></li>
</ol>
<pre><code>&gt;&gt;&gt; type(123)
&lt;class 'int'&gt;
&gt;&gt;&gt; type('str')
&lt;class 'str'&gt;
&gt;&gt;&gt; type(None)
&lt;type(None) 'NoneType'&gt;
</code></pre>
<ol start="2">
<li>函数或者类<br>
如果一个变量指向<strong>函数或者类</strong>，也可以用type()判断：</li>
</ol>
<pre><code>&gt;&gt;&gt; type(abs)
&lt;class 'builtin_function_or_method'&gt;
&gt;&gt;&gt; type(a)
&lt;class '__main__.Animal'&gt;
</code></pre>
<p>但是对于类，type()函数返回对应的Class类型，而不是仅仅Class。</p>
<p>所以如果我们要在if语句中判断，就需要比较两个变量的type类型是否相同：</p>
<pre><code>&gt;&gt;&gt; type(123)==type(456)
True
&gt;&gt;&gt; type(123)==int
True
&gt;&gt;&gt; type('abc')==type('123')
True
&gt;&gt;&gt; type('abc')==str
True
&gt;&gt;&gt; type('abc')==type(123)
False
</code></pre>
<p>对于函数同样地，判断基本数据类型可以直接写int，str等，但如果要判断一个对象是否是函数怎么办？可以<strong>使用types模块中定义的常量</strong>：</p>
<pre><code>&gt;&gt;&gt; import types
&gt;&gt;&gt; def fn():
...     pass
...
&gt;&gt;&gt; type(fn)==types.FunctionType
True
&gt;&gt;&gt; type(abs)==types.BuiltinFunctionType
True
&gt;&gt;&gt; type(lambda x: x)==types.LambdaType
True
&gt;&gt;&gt; type((x for x in range(10)))==types.GeneratorType
True
</code></pre>
<h3 id="使用isinstance">使用isinstance()</h3>
<p>对于class的继承关系来说，使用type()就很不方便。我们要判断class的类型，可以使用isinstance()函数。</p>
<p>我们回顾上次的例子，如果继承关系是：</p>
<pre><code>object -&gt; Animal -&gt; Dog -&gt; Husky
</code></pre>
<p>那么，isinstance()就可以告诉我们，一个对象是否是某种类型。先创建3种类型的对象：</p>
<pre><code>&gt;&gt;&gt; a = Animal()
&gt;&gt;&gt; d = Dog()
&gt;&gt;&gt; h = Husky()
</code></pre>
<p>然后，判断：</p>
<pre><code>&gt;&gt;&gt; isinstance(h, Husky)
True
</code></pre>
<p>没有问题，因为h变量指向的就是Husky对象。</p>
<p>再判断：</p>
<pre><code>&gt;&gt;&gt; isinstance(h, Dog)
True
</code></pre>
<p><strong>h虽然自身是Husky类型，但由于Husky是从Dog继承下来的，所以，h也还是Dog类型</strong>。<br>
换句话说，isinstance()判断的是一个对象是否是该类型本身，<strong>或者位于该类型的父继承链上</strong>。</p>
<p>因此，我们可以确信，<strong>h还是Animal类型</strong>：</p>
<pre><code>&gt;&gt;&gt; isinstance(h, Animal)
True
</code></pre>
<p>同理，实际类型是Dog的d也是Animal类型：</p>
<pre><code>&gt;&gt;&gt; isinstance(d, Dog) and isinstance(d, Animal)
True
</code></pre>
<p>但是，d不是Husky类型：</p>
<pre><code>&gt;&gt;&gt; isinstance(d, Husky)
False
</code></pre>
<p><strong>能用type()判断的基本类型也可以用isinstance()判断</strong>：</p>
<pre><code>&gt;&gt;&gt; isinstance('a', str)
True
&gt;&gt;&gt; isinstance(123, int)
True
&gt;&gt;&gt; isinstance(b'a', bytes)
True
</code></pre>
<p><strong>并且还可以判断一个变量是否是某些类型中的一种</strong>，比如下面的代码就可以判断是否是list或者tuple：</p>
<pre><code>&gt;&gt;&gt; isinstance([1, 2, 3], (list, tuple))
True
&gt;&gt;&gt; isinstance((1, 2, 3), (list, tuple))
True
</code></pre>
<p><strong>总是优先使用isinstance()判断类型</strong>，<strong>因为可以将指定类型及其子类同时进行判断</strong>。</p>
<h2 id="使用dir">使用dir()</h2>
<p>如果要<strong>获得一个对象的所有属性和方法</strong>，可以使用dir()函数，它返回一个包<strong>含字符串的list</strong>，比如，获得一个str对象的所有属性和方法：</p>
<pre><code>&gt;&gt;&gt; dir('ABC')
['__add__', '__class__',..., '__subclasshook__', 'capitalize', 'casefold',..., 'zfill']
</code></pre>
<p><strong>类似__xxx__的属性和方法在Python中都是有特殊用途的</strong><br>
比如__len__方法返回长度。<strong>在Python中，如果你调用len()函数试图获取一个对象的长度，实际上，在len()函数内部，它自动去调用该对象的__len__()方法</strong>，所以，下面的代码是等价的：</p>
<pre><code>&gt;&gt;&gt; len('ABC')
3
&gt;&gt;&gt; 'ABC'.__len__()
3
</code></pre>
<p>我们自己写的类，如果也想用len(myObj)的话，就自己写一个__len__()方法：</p>
<pre><code>&gt;&gt;&gt; class MyDog(object):
...     def __len__(self):
...         return 100
...
&gt;&gt;&gt; dog = MyDog()
&gt;&gt;&gt; len(dog)
100
</code></pre>
<p>剩下的都是<strong>普通属性或方法</strong>，比如lower()返回小写的字符串：</p>
<pre><code>&gt;&gt;&gt; 'ABC'.lower()
'abc'
</code></pre>
<p>仅仅把属性和方法列出来是不够的，<strong>配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态</strong>：</p>
<pre><code>&gt;&gt;&gt; class MyObject(object):
...     def __init__(self):
...         self.x = 9
...     def power(self):
...         return self.x * self.x
...
&gt;&gt;&gt; obj = MyObject()
</code></pre>
<p>紧接着，可以测试该对象的属性：</p>
<pre><code>&gt;&gt;&gt; hasattr(obj, 'x') # 有属性'x'吗？
True
&gt;&gt;&gt; obj.x
9
&gt;&gt;&gt; hasattr(obj, 'y') # 有属性'y'吗？
False
&gt;&gt;&gt; setattr(obj, 'y', 19) # 设置一个属性'y'
&gt;&gt;&gt; hasattr(obj, 'y') # 有属性'y'吗？
True
&gt;&gt;&gt; getattr(obj, 'y') # 获取属性'y'
19
&gt;&gt;&gt; obj.y # 获取属性'y'
19
</code></pre>
<p><strong>如果试图获取不存在的属性，会抛出AttributeError的错误</strong>：</p>
<pre><code>&gt;&gt;&gt; getattr(obj, 'z') # 获取属性'z'
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'MyObject' object has no attribute 'z'
</code></pre>
<p>可以传入一个default参数，如果属性不存在，就返回默认值：</p>
<pre><code>&gt;&gt;&gt; getattr(obj, 'z', 404) # 获取属性'z'，如果不存在，返回默认值404
404
</code></pre>
<p>也可以获得对象的方法：</p>
<pre><code>&gt;&gt;&gt; hasattr(obj, 'power') # 有属性'power'吗？
True
&gt;&gt;&gt; getattr(obj, 'power') # 获取属性'power'
&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;
&gt;&gt;&gt; fn = getattr(obj, 'power') # 获取属性'power'并赋值到变量fn
&gt;&gt;&gt; fn # fn指向obj.power
&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;
&gt;&gt;&gt; fn() # 调用fn()与调用obj.power()是一样的
81
</code></pre>
<h3 id="小结-2">小结</h3>
<p>通过内置的一系列函数，我们可以对任意一个Python对象进行剖析，拿到其内部的数据。要注意的是，<strong>只有在不知道对象信息的时候，我们才会去获取对象信息</strong>。如果可以直接写：</p>
<pre><code>sum = obj.x + obj.y
</code></pre>
<p>就不要写：</p>
<pre><code>sum = getattr(obj, 'x') + getattr(obj, 'y')
</code></pre>
<p>一个正确的用法的例子如下：</p>
<pre><code>def readImage(fp):
    if hasattr(fp, 'read'):
        return readData(fp)
    return None
</code></pre>
<p>假设我们希望从文件流fp中读取图像，我们首先要判断该fp对象是否存在read方法，如果存在，则该对象是一个流，如果不存在，则无法读取。hasattr()就派上了用场。</p>
<p>请注意，<strong>在Python这类动态语言中，根据鸭子类型，有read()方法，不代表该fp对象就是一个文件流，它也可能是网络流，也可能是内存中的一个字节流，但只要read()方法返回的是有效的图像数据，就不影响读取图像的功能</strong>。</p>
<h2 id="实例属性和类属性">实例属性和类属性</h2>
<p>由于Python是<strong>动态语言，根据类创建的实例可以任意绑定属性</strong>。</p>
<p>给实例绑定属性的方法是<strong>通过实例变量，或者通过self变量</strong>：</p>
<pre><code>class Student(object):
    def __init__(self, name):
        self.name = name

s = Student('Bob')
s.score = 90
</code></pre>
<p>但是如果Student<strong>类本身需要绑定一个属性</strong>,可以<strong>直接在class中定义属性</strong>，这种属性是<strong>类属性，归Student类所有</strong>：</p>
<pre><code>class Student(object):
    name = 'Student'
</code></pre>
<p>当我们<strong>定义了一个类属性后</strong>，这个属性虽然归类所有，但<strong>类的所有实例都可以访问到</strong>。来测试一下：</p>
<pre><code>&gt;&gt;&gt; class Student(object):
...     name = 'Student'
...
&gt;&gt;&gt; s = Student() # 创建实例s
&gt;&gt;&gt; print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性
Student
&gt;&gt;&gt; print(Student.name) # 打印类的name属性
Student
&gt;&gt;&gt; s.name = 'Michael' # 给实例绑定name属性
&gt;&gt;&gt; print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性
Michael
&gt;&gt;&gt; print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问
Student
&gt;&gt;&gt; del s.name # 如果删除实例的name属性
&gt;&gt;&gt; print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了
Student
</code></pre>
<p><strong>实例属性优先级比类属性高</strong></p>
<p>从上面的例子可以看出，在编写程序的时候，千万不要对实例属性和类属性使用相同的名字，因为<strong>相同名称的实例属性将屏蔽掉类属性</strong>，但是当你<strong>删除实例属性后，再使用相同的名称，访问到的将是类属性</strong>。</p>
<h3 id="小结-3">小结</h3>
<p><strong>实例属性属于各个实例所有，互不干扰</strong>；</p>
<p>类属性属于类所有，所有实例共享一个属性；(类似于C++的static)</p>
<p>不要对实例属性和类属性使用相同的名字，否则将产生难以发现的错误。</p>
<h3 id="个人练习代码">个人练习代码</h3>
<p>练习</p>
<p>为了统计学生人数，可以给Student类增加一个类属性，每创建一个实例，该属性自动增加：</p>
<pre><code># -*- coding: utf-8 -*-
class Student(object):
    count = 0

    def __init__(self, name):
        self.name = name
        Student.count += 1
				
# 测试:
if Student.count != 0:
    print('测试失败!')
else:
    bart = Student('Bart')
    if Student.count != 1:
        print('测试失败!')
    else:
        lisa = Student('Bart')
        if Student.count != 2:
            print('测试失败!')
        else:
            print('Students:', Student.count)
            print('测试通过!')
</code></pre>
<p>注意：</p>
<ol>
<li>前面说过了类的属性类似于static变量，所以要用Student.count访问，而不能用count或者self.count</li>
<li>测试用例中可以看到就算没有实例也可以用 Student.count 访问初始值</li>
<li>python的类实例并没有限定类的数据成员。。。可以任意添加。。。</li>
</ol>
<p>网友的另外一种实现方法，主要是利用__class__这个特殊变量</p>
<pre><code>class Student(object):
    count = 0
    def __init__(self, name):
        self.name = name
        self.__class__.count += 1
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python - 模块]]></title>
        <id>https://lixin-scut.github.io//post/python-mo-kuai</id>
        <link href="https://lixin-scut.github.io//post/python-mo-kuai">
        </link>
        <updated>2020-05-10T04:24:27.000Z</updated>
        <content type="html"><![CDATA[<h2 id="模块">模块</h2>
<p>为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Python中，<strong>一个.py文件就称之为一个模块（Module）</strong>。</p>
<p>使用模块最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Python内置的模块和来自第三方的模块。</p>
<p>使用模块还可以<strong>避免函数名和变量名冲突</strong>。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在<strong>编写模块时，不必考虑名字会与其他模块冲突</strong>。但是也要注意，<strong>尽量不要与内置函数名字冲突</strong>。</p>
<p>但不同的人编写的模块名可能相同，为了<strong>避免模块名冲突</strong>，Python又引入了<strong>按目录来组织模块</strong>的方法，称为<strong>包（Package）</strong>。</p>
<p>举个例子，一个abc.py的文件就是一个名字叫abc的模块，一个xyz.py的文件就是一个名字叫xyz的模块。</p>
<p>现在，假设我们的abc和xyz这两个模块名字与其他模块冲突了，于是我们可以<strong>通过包来组织模块</strong>，避免冲突。方法是<strong>选择一个顶层包名，比如mycompany</strong>，按照如下目录存放：</p>
<pre><code>mycompany
├─ __init__.py
├─ abc.py
└─ xyz.py
</code></pre>
<p>引入了包以后，<strong>只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突</strong>。现在，abc.py模块的名字就变成了mycompany.abc，类似的，xyz.py的模块名变成了mycompany.xyz。</p>
<p>请注意，<strong>每一个包目录下面都会有一个<code>__init__.py</code>的文件</strong>，这个文件是<strong>必须存在的</strong>，否则，Python就把这个目录<strong>当成普通目录，而不是一个包</strong>。<code>__init__.py</code>可以是<strong>空文件</strong>，也可以<strong>有Python代码</strong>，因为__init__.py<strong>本身就是一个模块</strong>，而它的模块名就是mycompany。</p>
<p>类似的，可以有多级目录，组成多级层次的包结构。比如如下的目录结构：</p>
<pre><code>mycompany
 ├─ web
 │  ├─ __init__.py
 │  ├─ utils.py
 │  └─ www.py
 ├─ __init__.py
 ├─ abc.py
 └─ utils.py
</code></pre>
<p>文件<code>www.py</code>的模块名就是<code>mycompany.web.www</code>，两个文件<code>utils.py</code>的模块名分别是<code>mycompany.utils</code>和<code>mycompany.web.utils</code>。</p>
<p>自己创建模块时要注意命名，<strong>不能和Python自带的模块名称冲突</strong>。例如，系统自带了sys模块，自己的模块就不可命名为sys.py，否则将无法导入系统自带的sys模块。<br>
<code>mycompany.web</code>也是一个模块，请指出该模块对应的.py文件。</p>
<h3 id="总结">总结</h3>
<p>模块是一组Python代码的集合，可以使用其他模块，也可以被其他模块使用。</p>
<p>创建自己的模块时，要注意：</p>
<ol>
<li>模块名要<strong>遵循Python变量命名规范</strong>，不要使用中文、特殊字符；</li>
<li>模块名<strong>不要和系统模块名冲突</strong>，最好先查看系统是否已存在该模块，检查方法是在Python交互环境执行import abc，若成功则说明系统存在此模块。</li>
</ol>
<h2 id="使用模块">使用模块</h2>
<p>Python本身就内置了很多非常有用的模块，只要安装完毕，这些模块就可以立刻使用。</p>
<p>我们以内建的sys模块为例，编写一个hello的模块：</p>
<pre><code>#!/usr/bin/env python3
# -*- coding: utf-8 -*-

' a test module '

__author__ = 'Michael Liao'

import sys

def test():
    args = sys.argv
    if len(args)==1:
        print('Hello, world!')
    elif len(args)==2:
        print('Hello, %s!' % args[1])
    else:
        print('Too many arguments!')

if __name__=='__main__':
    test()
</code></pre>
<pre><code>#!/usr/bin/env python3
# -*- coding: utf-8 -*-
</code></pre>
<p>第1行和第2行是标准注释，第1行注释可以让这个hello.py文件直接在Unix/Linux/Mac上运行，第2行注释表示.py文件本身使用标准UTF-8编码；</p>
<pre><code>' a test module '
</code></pre>
<p>第4行是一个字符串，表示模块的文档注释，<strong>任何模块代码的第一个字符串都被视为模块的文档注释</strong>；</p>
<pre><code>__author__ = 'Michael Liao'
</code></pre>
<p>第6行使用__author__变量把作者写进去</p>
<p>以上就是Python模块的标准文件模板，当然也可以全部删掉不写，但是，按标准办事肯定没错。</p>
<p>后面开始就是真正的代码部分。</p>
<p>使用sys模块的第一步，就是导入该模块：</p>
<pre><code>import sys
</code></pre>
<p>导入sys模块后，我们就有了<strong>变量sys</strong>指向该模块，<strong>利用sys这个变量</strong>，就可以访问sys模块的所有功能。</p>
<p>sys模块有一个argv变量，用list存储了命令行的所有参数。argv至少有一个元素，因为第一个参数永远是该.py文件的名称，例如：</p>
<p>运行python3 hello.py获得的sys.argv就是<code>['hello.py']</code>；</p>
<p>运行python3 hello.py Michael获得的sys.argv就是<code>['hello.py', 'Michael]</code>。</p>
<p>最后，注意到这两行代码：</p>
<pre><code>if __name__=='__main__':
    test()
</code></pre>
<p>当我们在命令行运行hello模块文件时，Python解释器把一个<strong>特殊变量name</strong>置为__main__，而如果在其他地方导入该hello模块时，if判断将失败，因此，<strong>这种if测试可以让一个模块通过命令行运行时执行一些额外的代码</strong>，最常见的就是运行测试。</p>
<p>用命令行运行hello.py看看效果：</p>
<pre><code>$ python3 hello.py
Hello, world!
$ python hello.py Michael
Hello, Michael!
</code></pre>
<p>如果启动Python交互环境，再导入hello模块：</p>
<pre><code>$ python3
Python 3.4.3 (v3.4.3:9b73f1c3e601, Feb 23 2015, 02:52:03) 
[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import hello
&gt;&gt;&gt;
</code></pre>
<p>导入时，没有打印Hello, word!，因为没有执行test()函数。</p>
<p>调用hello.test()时，才能打印出Hello, word!：</p>
<pre><code>&gt;&gt;&gt; hello.test()
Hello, world!
</code></pre>
<h2 id="作用域">作用域</h2>
<p>在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，<strong>有的函数和变量我们希望仅仅在模块内部使用</strong>。在Python中，是<strong>通过_前缀</strong>来实现的。</p>
<p>正常的函数和变量名是<strong>公开的（public），可以被直接引用</strong>，比如：abc，x123，PI等；</p>
<p>类似<code>__xxx__</code>这样的变量是<strong>特殊变量，可以被直接引用，但是有特殊用途</strong>，比如上面的<code>__author__</code>，<code>__name__</code>就是特殊变量，hello模块定义的文档注释也可以用特殊变量<code>__doc__</code>访问，自定义的变量<strong>一般不要用这种变量名</strong>；</p>
<p>类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是<strong>非公开的（private)</strong>，<strong>不应该被直接引用</strong>，比如<code>_abc</code>，<code>__abc</code>等；</p>
<p>之所以我们说，<strong>private函数和变量“不应该”被直接引用 ，而不是“不能”被直接引用</strong>，是因为<strong>Python并没有一种方法可以完全限制访问private函数或变量</strong>，但是，从编程习惯上<strong>不应该引用private函数或变量</strong>。</p>
<p>private函数或变量不应该被别人引用</p>
<p>使用例子：</p>
<pre><code>def _private_1(name):
    return 'Hello, %s' % name

def _private_2(name):
    return 'Hi, %s' % name

def greeting(name):
    if len(name) &gt; 3:
        return _private_1(name)
    else:
        return _private_2(name)
</code></pre>
<p>我们在模块里<strong>公开greeting()函数</strong>，而把<strong>内部逻辑用private函数隐藏起来</strong>了，这样，<strong>调用greeting()函数不用关心内部的private函数细节</strong>，这也是一种非常有用的代<strong>码封装和抽象的方法</strong>，即：</p>
<p><strong>外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。</strong></p>
<h2 id="安装第三方模块">安装第三方模块</h2>
<p>在Python中，安装第三方模块，是通过<strong>包管理工具pip</strong>完成的。</p>
<p>如果正在使用Mac或Linux，安装pip本身这个步骤就可以跳过了。</p>
<p>如果正在使用Windows，请参考安装Python一节的内容，确保安装时勾选了pip和Add python.exe to Path。</p>
<p>在命令提示符窗口下尝试运行pip，如果Windows提示未找到命令，可以重新运行安装程序添加pip。</p>
<p>注意：Mac或Linux上有可能并存Python 3.x和Python 2.x，<strong>因此对应的pip命令是pip3</strong>。</p>
<p>例如，我们要安装一个第三方库——Python Imaging Library，这是Python下非常强大的处理图像的工具库。不过，PIL目前只支持到Python 2.7，并且有年头没有更新了，因此，基于PIL的Pillow项目开发非常活跃，并且支持最新的Python 3。</p>
<p>一般来说，第三方库都会在Python官方的pypi.python.org网站注册，要安装一个第三方库，必须先知道该库的名称，可以在官网或者pypi上搜索，比如Pillow的名称叫Pillow，因此，安装Pillow的命令就是：</p>
<pre><code>pip install Pillow
</code></pre>
<p>耐心等待下载并安装后，就可以使用Pillow了。</p>
<h2 id="安装常用模块">安装常用模块</h2>
<p>在使用Python时，我们经常需要用到很多第三方库，例如，上面提到的Pillow，以及MySQL驱动程序，Web框架Flask，科学计算Numpy等。用pip一个一个安装费时费力，还需要考虑兼容性。我们推荐直接使用Anaconda，这是一个基于Python的<strong>数据处理和科学计算平台</strong>，它<strong>已经内置了许多非常有用的第三方库</strong>，我们装上Anaconda，就相当于把数十个第三方模块自动安装好了，非常简单易用。</p>
<p>可以从Anaconda官网下载GUI安装包，安装包有500~600M，所以需要耐心等待下载。下载后直接安装，Anaconda会把系统Path中的python指向自己自带的Python，并且，Anaconda安装的第三方模块会安装在Anaconda自己的路径下，不影响系统已安装的Python目录。</p>
<p>安装好Anaconda后，重新打开命令行窗口，输入python，可以看到Anaconda的信息：</p>
<pre><code>│Python 3.6.3 |Anaconda, Inc.| ... on win32              │
│Type &quot;help&quot;, ... for more information.                  │
│&gt;&gt;&gt; import numpy                                        │
│&gt;&gt;&gt; _ 
</code></pre>
<p>可以尝试直接import numpy等已安装的第三方模块。</p>
<h2 id="模块搜索路径">模块搜索路径</h2>
<p>当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错：</p>
<pre><code>&gt;&gt;&gt; import mymodule
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
ImportError: No module named mymodule
</code></pre>
<p>默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，<strong>搜索路径存放在sys模块的path变量中</strong>：</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path
['', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python36.zip', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6', ..., '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages']
</code></pre>
<p>如果我们要添加自己的搜索目录，有两种方法：</p>
<ol>
<li><strong>直接修改sys.path</strong>，添加要搜索的目录：</li>
</ol>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path.append('/Users/michael/my_py_scripts')
</code></pre>
<p>这种方法是<strong>在运行时修改，运行结束后失效</strong>。</p>
<ol start="2">
<li>设置环境变量PYTHONPATH，该环境变量的内容会被<strong>自动添加到模块搜索路径中</strong>。设置方式与设置Path环境变量类似。注意只需要添加你自己的搜索路径，<strong>Python自己本身的搜索路径不受影响</strong>。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python - 函数式编程]]></title>
        <id>https://lixin-scut.github.io//post/python-han-shu-shi-bian-cheng</id>
        <link href="https://lixin-scut.github.io//post/python-han-shu-shi-bian-cheng">
        </link>
        <updated>2020-05-09T01:50:11.000Z</updated>
        <content type="html"><![CDATA[<h2 id="函数式编程">函数式编程</h2>
<p>函数是Python内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。</p>
<p>而函数式编程Functional Programming，虽然也可以归结到<strong>面向过程</strong>的程序设计，但其思想<strong>更接近数学计算</strong>。</p>
<p>对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。</p>
<p>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。</p>
<p>函数式编程的一个特点就是，<strong>允许把函数本身作为参数传入另一个函数</strong>，还<strong>允许返回一个函数</strong>！</p>
<p>Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。</p>
<h2 id="高阶函数">高阶函数</h2>
<h3 id="变量可以指向函数">变量可以指向函数</h3>
<p>函数本身也可以赋值给变量，即：变量可以指向函数。<br>
变量f现在已经指向了abs函数本身。直接调用abs()函数和调用变量f()完全相同。</p>
<pre><code>&gt;&gt;&gt; f = abs
&gt;&gt;&gt; f
&lt;built-in function abs&gt;

&gt;&gt;&gt; f(-10)
10
</code></pre>
<h3 id="函数名也是变量">函数名也是变量</h3>
<p>函数名其实就是指向函数的变量！对于abs()这个函数，完全可以把函数名abs看成变量，它指向一个可以计算绝对值的函数！</p>
<p>如果把abs指向其他对象，会有什么情况发生？</p>
<pre><code>&gt;&gt;&gt; abs = 10
&gt;&gt;&gt; abs(-10)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: 'int' object is not callable
</code></pre>
<p>把abs指向10后，就无法通过abs(-10)调用该函数了！因为abs这个变量已经不指向求绝对值函数而是指向一个整数10！</p>
<p>当然实际代码绝对不能这么写，这里是为了说明函数名也是变量。要恢复abs函数，请重启Python交互环境。</p>
<p>注：由于abs函数实际上是定义在import builtins模块中的，所以要让修改abs变量的指向在其它模块也生效，要用import builtins; builtins.abs = 10。</p>
<h3 id="传入函数">传入函数</h3>
<p>既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。</p>
<p>编写高阶函数，就是让<strong>函数的参数能够接收别的函数</strong>。</p>
<p>一个最简单的高阶函数：</p>
<pre><code>def add(x, y, f):
    return f(x) + f(y)
</code></pre>
<p>当我们调用add(-5, 6, abs)时，参数x，y和f分别接收-5，6和abs，根据函数定义，我们可以推导计算过程为：</p>
<pre><code>x = -5
y = 6
f = abs
f(x) + f(y) ==&gt; abs(-5) + abs(6) ==&gt; 11
return 11
</code></pre>
<h2 id="mapreduce">map/reduce</h2>
<h3 id="map">map</h3>
<p>map()函数接收两个参数，一个是函数，一个是<strong>Iterable</strong>，map将传入的函数依次作用到序列的每个元素，并把结果作为<strong>新的Iterator</strong>返回。</p>
<p>举例说明，比如我们有一个函数f(x)=x^2，要把这个函数作用在一个list [1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map()实现如下：</p>
<pre><code>&gt;&gt;&gt; def f(x):
...     return x * x
...
&gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
# 注意list(r) 操作，把一个Iterator直接变为list
&gt;&gt;&gt; list(r) 
[1, 4, 9, 16, 25, 36, 49, 64, 81]
</code></pre>
<p>map()传入的第一个参数是f，即函数对象本身。由于结果r是一个Iterator，Iterator是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list。</p>
<p>对比循环操作，map()作为高阶函数，事实上它<strong>把运算规则抽象了</strong>，因此，我们不但可以计算简单的f(x)=x2，还可以<strong>计算任意复杂的函数</strong></p>
<h3 id="reduce">reduce</h3>
<p>reduce把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上，这个函数必须接收两个参数，reduce把<strong>结果继续和序列的下一个元素做累积计算</strong>，其效果就是：</p>
<pre><code>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
</code></pre>
<p>比方说对一个序列求和，就可以用reduce实现：</p>
<pre><code>&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; def add(x, y):
...     return x + y
...
&gt;&gt;&gt; reduce(add, [1, 3, 5, 7, 9])
25
# 当然求和运算可以直接用Python内建函数sum()，没必要动用reduce
</code></pre>
<p>再比如要把序列[1, 3, 5, 7, 9]变换成整数13579，reduce就可以派上用场：</p>
<pre><code>&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; def fn(x, y):
...     return x * 10 + y
...
&gt;&gt;&gt; reduce(fn, [1, 3, 5, 7, 9])
13579
</code></pre>
<p>如果考虑到字符串str也是一个序列，对上面的例子稍加改动，配合map()，我们就可以写出把str转换为int的函数：</p>
<pre><code>&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; def fn(x, y):
...     return x * 10 + y
...
&gt;&gt;&gt; def char2num(s):
...     digits = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}
...     return digits[s]
...
&gt;&gt;&gt; reduce(fn, map(char2num, '13579'))
13579
</code></pre>
<p>整理成一个str2int的函数就是：</p>
<pre><code>from functools import reduce

DIGITS = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}

def str2int(s):
    def fn(x, y):
        return x * 10 + y
    def char2num(s):
        return DIGITS[s]
    return reduce(fn, map(char2num, s))
</code></pre>
<p>还可以用lambda函数进一步简化成：</p>
<pre><code>from functools import reduce

DIGITS = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}

def char2num(s):
    return DIGITS[s]

def str2int(s):
    return reduce(lambda x, y: x * 10 + y, map(char2num, s))
</code></pre>
<p><strong>个人代码练习</strong><br>
利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：['adam', 'LISA', 'barT']，输出：['Adam', 'Lisa', 'Bart']：</p>
<pre><code>def normalize(name):
    name = name.lower()
    return name[0].upper() + name[1:]
		
# 测试:
L1 = ['adam', 'LISA', 'barT']
L2 = list(map(normalize, L1))
print(L2)
# ['Adam', 'Lisa', 'Bart'] 
</code></pre>
<p>注意：</p>
<ol>
<li>不可以name[i] = name[i].lower() 的操作，因为string（区别于list）是一种不可变的数据类型，必须对name整体进行赋值，使用下标操作返回的是类似于右值</li>
<li>name = name.lower()中不能缺少前面的name</li>
</ol>
<p>编写一个prod()函数，可以接受一个list并利用reduce()求积：</p>
<pre><code># -*- coding: utf-8 -*-
from functools import reduce

def sums(lhs, rhs):
    return lhs * rhs

def prod(L):
    return reduce(sums, L)
</code></pre>
<p>注意：</p>
<ol>
<li>一定要记得return 否则赋值就会变为none</li>
</ol>
<h2 id="filter">filter</h2>
<p>Python内建的filter()函数用于过滤序列。</p>
<p>和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数<strong>依次作用于每个元素</strong>，然后根据<strong>返回值是True还是False</strong>决定<strong>保留还是丢弃该元素</strong>。</p>
<p>filter()的作用是从一个序列中筛出符合条件的元素。由于filter()使用了惰性计算，所以只有在取filter()结果的时候，才会真正筛选并每次返回下一个筛出的元素。</p>
<p>例如，在一个list中，<strong>删掉偶数，只保留奇数</strong>，可以这么写：</p>
<pre><code>def is_odd(n):
    return n % 2 == 1

list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))
#结果: [1, 5, 9, 15]
</code></pre>
<p>把一个序列中的空字符串删掉，可以这么写：</p>
<pre><code>def not_empty(s):
    return s and s.strip()

list(filter(not_empty, ['A', '', 'B', None, 'C', '  ']))
#结果: ['A', 'B', 'C']
</code></pre>
<p>可见用filter()这个高阶函数，关键在于<strong>正确实现一个“筛选”函数</strong>。</p>
<p>注意到filter()函数返回的是一个<strong>Iterator</strong>，也就是一个<strong>惰性序列</strong>，所以要强迫filter()完成计算结果，需要用<strong>list()函数获得所有结果并返回list</strong>。</p>
<p><strong>个人代码练习</strong><br>
回数是指从左向右读和从右向左读都是一样的数，例如12321，909。请利用filter()筛选出回数：</p>
<pre><code>def is_palindrome(x):
    if(x &lt; 0 or (x % 10 == 0 and x != 0)) :
        return False
    temp = 0
    while(temp &lt; x):
        temp = temp * 10 + x % 10
        x //= 10
    return temp == x or temp // 10 == x
		
		# 测试:
output = filter(is_palindrome, range(1, 1000))
print('1~1000:', list(output))
if list(filter(is_palindrome, range(1, 200))) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191]:
    print('测试成功!')
else:
    print('测试失败!')
</code></pre>
<p>注意</p>
<ol>
<li>注意除法的区别！！！单个除号是精确除，返回的是浮点数，必须用双除号</li>
</ol>
<h2 id="sorted">sorted</h2>
<p>排序算法</p>
<p>排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是<strong>比较两个元素的大小</strong>。<br>
如果是数字，我们可以直接比较，但如果是<strong>字符串或者两个dict</strong>直接比较数学上的大小是没有意义的，因此，比较的过程<strong>必须通过函数抽象出来</strong>。</p>
<p>Python内置的sorted()函数就可以对list进行排序：</p>
<pre><code>&gt;&gt;&gt; sorted([36, 5, -12, 9, -21])
[-21, -12, 5, 9, 36]
</code></pre>
<p>此外，sorted()函数也是一个高阶函数，它还可以<strong>接收一个key函数</strong>来实现<strong>自定义的排序</strong>，例如按绝对值大小排序：</p>
<pre><code>&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs)
[5, 9, -12, -21, 36]
</code></pre>
<p>key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。对比原始的list和经过key=abs处理过的list：</p>
<pre><code>list = [36, 5, -12, 9, -21]

keys = [36, 5,  12, 9,  21]
</code></pre>
<p>然后sorted()函数<strong>按照keys进行排序</strong>，并<strong>按照对应关系返回list相应的元素</strong>：</p>
<pre><code>keys排序结果 =&gt; [5, 9,  12,  21, 36]
                |  |    |    |   |
最终结果     =&gt; [5, 9, -12, -21, 36]
</code></pre>
<p>我们再看一个字符串排序的例子：</p>
<pre><code>&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'])
['Credit', 'Zoo', 'about', 'bob']
</code></pre>
<p>默认情况下，对字符串排序，是按照<strong>ASCII的大小</strong>比较的，<strong>由于'Z' &lt; 'a'，结果，大写字母Z会排在小写字母a的前面。</strong></p>
<p>现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能用一个key函数把字符串映射为忽略大小写排序即可。忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。</p>
<p>这样，我们给sorted传入key函数，即可实现忽略大小写的排序：</p>
<pre><code>&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower)
['about', 'bob', 'Credit', 'Zoo']
</code></pre>
<p>要进行反向排序，不必改动key函数，可以传入第三个参数reverse=True：</p>
<pre><code>&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)
['Zoo', 'Credit', 'bob', 'about']
</code></pre>
<p>从上述例子可以看出，高阶函数的抽象能力是非常强大的，而且，核心代码可以保持得非常简洁。</p>
<h3 id="小结">小结</h3>
<p>sorted()也是一个高阶函数。用sorted()排序的关键在于实现一个映射函数。</p>
<p><strong>个人代码联系</strong><br>
假设我们用一组tuple表示学生名字和成绩：</p>
<p>L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]<br>
请用sorted()对上述列表分别按名字排序：</p>
<pre><code>#-*- coding: utf-8 -*-

L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]

def by_name(t):
    return t[0]
		
L2 = sorted(L, key=by_name)
print(L2)

# [('Adam', 92), ('Bart', 66), ('Bob', 75), ('Lisa', 88)] 
</code></pre>
<p>再按成绩从高到低排序：</p>
<pre><code>#-*- coding: utf-8 -*-

L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]

def by_score(t):
    return -t[1]
    
L2 = sorted(L, key=by_score)
print(L2)

# [('Adam', 92), ('Lisa', 88), ('Bob', 75), ('Bart', 66)] 
</code></pre>
<h2 id="返回函数">返回函数</h2>
<h3 id="函数作为返回值">函数作为返回值</h3>
<p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</p>
<p>我们来实现一个可变参数的求和。通常情况下，求和的函数是这样定义的：</p>
<pre><code>def calc_sum(*args):
    ax = 0
    for n in args:
        ax = ax + n
    return ax
</code></pre>
<p>但是，如果<strong>不需要立刻求和</strong>，而是在<strong>后面的代码中，根据需要再计算</strong>，可以不返回求和的结果，而是<strong>返回求和的函数</strong>：</p>
<pre><code>def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax
    return sum
</code></pre>
<p>当我们调用lazy_sum()时，<strong>返回的并不是求和结果，而是求和函数</strong>：</p>
<pre><code>&gt;&gt;&gt; f = lazy_sum(1, 3, 5, 7, 9)
&gt;&gt;&gt; f
&lt;function lazy_sum.&lt;locals&gt;.sum at 0x101c6ed90&gt;
</code></pre>
<p><strong>调用函数f时，才真正计算求和的结果</strong>：</p>
<pre><code>&gt;&gt;&gt; f()
25
</code></pre>
<p>在函数lazy_sum中又定义了函数sum，并且，内部函数sum<strong>可以引用外部函数lazy_sum的参数和局部变量</strong>，当lazy_sum返回函数sum时，<strong>相关参数和变量都保存在返回的函数</strong>中，这种称为“<strong>闭包（Closure）</strong>”的程序结构拥有极大的威力。</p>
<p>注意，调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数：</p>
<pre><code>&gt;&gt;&gt; f1 = lazy_sum(1, 3, 5, 7, 9)
&gt;&gt;&gt; f2 = lazy_sum(1, 3, 5, 7, 9)
&gt;&gt;&gt; f1==f2
False
</code></pre>
<p>f1()和f2()的调用结果互不影响。</p>
<h3 id="闭包">闭包</h3>
<p>注意到返回的函数在其定义内部引用了局部变量args，所以，当一个函数返回了一个函数后，<strong>其内部的局部变量还被新函数引用</strong>。</p>
<p>另一个需要注意的问题是，返回的函数<strong>并没有立刻执行</strong>，而是<strong>直到调用了f()才执行</strong>。</p>
<p>例子如下：</p>
<pre><code>def count():
    fs = []
    for i in range(1, 4):
        def f():
             return i*i
        fs.append(f)
    return fs

f1, f2, f3 = count()
</code></pre>
<p>在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都返回了。</p>
<p>可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是：</p>
<pre><code>&gt;&gt;&gt; f1()
9
&gt;&gt;&gt; f2()
9
&gt;&gt;&gt; f3()
9
</code></pre>
<p>结果全部都是9，原因在于返回的函数引用了变量i，但它<strong>并非立刻执行</strong>。<strong>等到3个函数都返回时，它们所引用的变量i已经变成了3</strong>，因此最终结果为9。</p>
<p><strong>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</strong></p>
<p>如果一定要引用循环变量，需要再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p>
<pre><code> def count():
    def f(j):
        def g():
            return j*j
        return g
    fs = []
    for i in range(1, 4):
        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()
    return fs

&gt;&gt;&gt; f1, f2, f3 = count()
&gt;&gt;&gt; f1()
1
&gt;&gt;&gt; f2()
4
&gt;&gt;&gt; f3()
9
</code></pre>
<p><strong>个人代码练习</strong><br>
利用闭包返回一个计数器函数，每次调用它返回递增整数：</p>
<pre><code>def createCounter():
    i = 0
    def counter():
        nonlocal i
        i = i + 1
        return i
    return counter
		
# 测试:
counterA = createCounter()
print(counterA(), counterA(), counterA(), counterA(), counterA()) # 1 2 3 4 5
counterB = createCounter()
if [counterB(), counterB(), counterB(), counterB()] == [1, 2, 3, 4]:
    print('测试通过!')
else:
    print('测试失败!')
</code></pre>
<p>注意！遇到了今天说到的问题，但是很奇葩，前面其实也有提及</p>
<blockquote>
<p>在函数lazy_sum中又定义了函数sum，并且，内部函数sum<strong>可以引用外部函数lazy_sum的参数和局部变量</strong>，当lazy_sum返回函数sum时，<strong>相关参数和变量都保存在返回的函数</strong>中，这种称为“<strong>闭包（Closure）</strong>”的程序结构拥有极大的威力。</p>
</blockquote>
<p>wtf？难道i不算外部函数的局部变量吗？<br>
我自己的解决方法：必须在内部函数加上 nonlocal i 才能正常运行，否则就会报错说i这个局部变量在定义前就被使用了</p>
<p>解决方法总结：<br>
&quot;&quot;&quot; 实现计数器统计函数调用次数 &quot;&quot;&quot;</p>
<pre><code>def createCounter():
    &quot;&quot;&quot; 方法1：list的原理类似C语言的数组和指针，不受作用域影响
    直接改变值对应的地址。也就是说不是改变值的引用，而是永久改变值本身 &quot;&quot;&quot;
    L=[0]
    def counter():
        L[0]+=1
        return L[0]
    return counter

def createCounter():
    &quot;&quot;&quot; 方法2：使用global扩大变量作用域 &quot;&quot;&quot;
    global n
    n=0
    def counter():
        global n
        n+=1
        return n
    return counter

def createCounter():
    &quot;&quot;&quot; 方法3：使用nonlocal声明内层函数变量，使其能修改外层函数的变量 &quot;&quot;&quot;
    n=0
    def counter():
        nonlocal n
        n+=1
        return n
    return counter

def createCounter():
    &quot;&quot;&quot; 方法4：使用生成器在外层函数创建生成器对象，在内层函数调用next() &quot;&quot;&quot;
    def count_generator():
        n=0
        while True:
            n+=1
            yield n
    # 调用生成器函数创建生成器对象一定要在外层函数进行
    temp=count_generator()

    def get_num():
        return next(temp)
    return get_num
</code></pre>
<p>网友解释一：</p>
<blockquote>
<p>声明变量i<strong>非内部函数的局部变量</strong>，否则内部函数只能引用，一旦修改会视其为局部变量，报错“局部变量在赋值之前被引用”。</p>
</blockquote>
<p>网友解释二：</p>
<blockquote>
<p>因为python中一切皆是对象，我们平时使用的a=1，s=‘adada’这些‘赋值’语句实际上是在内存中开辟了一块空间存储了1和‘adada’这两个对象（包括其属性和方法）后将内存空间的地址赋值给了a和s（为了方便，我们称呼它们为引用）。而在之后使用a和s时其实就是根据内存空间找到对应对象，调用其中存储的内容<br>
既然如此，一个方法也可以单独存放在内存空间内作为一个对象被引用。而这就是高阶函数和返回函数讨论的问题。<br>
高阶函数是<strong>将方法作为参数传入其他方法中去使用</strong>，比如sorted中的key参数，map、reduce中的函数参数<br>
而返回函数则是将方法（为了方便称呼，我们叫它内函数）作为一个方法（外函数）的返回值<br>
根据C语言基础我们可以知道当一个方法调用return时，会释放掉其内存（准确的说是函数栈）空间，则该函数的局部变量（包括函数体内定义和传入的参数）都会被释放而无法正常访问。但是假如我们的内函数需要使用外函数的局部变量，那就<strong>需要把内函数使用的局部变量‘绑定’给内函数</strong>，从而在外函数被释放的前提下内函数的使用也不会受到影响。楼下有一层总结了四种方法，其中方法四就是利用了这一点，因为生成器被内函数使用绑定，所以外函数释放后也无所谓。<br>
但是，生成器占据的资源相较于1个数据肯定要大，而我们又想节约资源实现计数该怎么办？---我们需要修改外函数的局部变量<br>
重点来了！！！！！！<br>
试想外部有语句 a = 0<br>
内部有语句 a = a +1<br>
python不像c语言有定义语句，我<strong>怎么知道内部的语句究竟是赋值外部变量还是定义内部变量</strong>？？？？？？<br>
（ps：c语言的情况下，外部int a=0，内部若是int a =1则覆盖外部，若是修改外部则直接赋值语句a=a+1.所以不存在歧义）<br>
为了解决这个问题，<strong>存在nonlocal关键字，nonlocal标记的赋值语句代表我这是赋值外部（第一层外部），没有标记的代表定义内部变量（这是方法3）</strong><br>
而假如我们定义了多层，func1包含func2，fun2包含func3，func 3想修改 func1的变量，（<strong>nonlocal标记的赋值语句指的是func2中的变量修改，因此没用</strong>）。所以我们想出了一个办法，创建一个<strong>全局标记global</strong>，凡是被<strong>global声明的变量就是指在内存空间内有独立空间的变量</strong>，<strong>没有被声明的就是局部的</strong>，从而解决跨层修改变量的问题（这是方法2）<br>
最后谈谈方法一（使用列表），列表的实现是可变长度的数组（详见https://www.jb51.net/article/164319.htm）<br>
我觉得能用这种方法应该是因为列表的定义L=[0]和列表的赋值L[x]=y语句不同，所以不存在歧义的才可以如此使用。感觉和所谓的列表实现类似C语言数组（指针）所以能够无视作用域没有关系（在python面向对象来看，所有的引用其实都是指向内存区域的指针，但不是所有类型的引用都可以无视作用域）</p>
</blockquote>
<p>网友解释三：</p>
<blockquote>
<p>个人感觉评论区的各位大手子都很强，总结得都很好，但是都忽略了一个底层问题，为什么L[0]可以作为一个全局变量，而L不行会报错。<br>
以下分析灵感来源于这篇文章：https://zhuanlan.zhihu.com/p/34395671，只是自己一点理解，可能有很多不对的地方，给大家提供一点方向。<br>
L[0]作为一个<strong>可变类型list对象</strong>，对这个对象执行操作后，比如 L[0] = L[0] + 1，它的内存地址是不变的，这个操作的实质是更改了在这个内存地址的这个list的第一个值，使其加一。<br>
而L作为一个<strong>不可变类型int对象</strong>，当对其赋值时，实际是把这个对象指向这个int值的内存地址。例如先赋初值 L = 0，然后使 L = L + 1，这个操作的整个过程实质是：将L指向int值0的内存地址；运算L + 1为int值1，将L指向int值1的内存地址。<br>
可变类型的实质就是引用的地址不变，该地址上存储的值可变。<br>
不可变类型的实质就是引用的地址可以变，但任意引用地址存储的值不可改变。<br>
这样设定的用意我大胆猜测是为了合理分配内存的存储和读写资源，设定一部分可以复用的固定数据让其存储在一个且每个固定数据一一对应只有一个的地址，这样不管有多少变量的值需要等于这个数据，其最终都指向这个地址，只占用一个存储单元，这就是不可变类型会指向的地址。而另一部分则满足变量所引用的地址不变，但是值需要随时更新的需求，这样不管这个变量的值需要存在多少种情况或者如何改变，其地址永远保持不变，这就是可变类型会指向的地址。<br>
看着可能会很混乱，实质上，<br>
可变类型就是<strong>一个变量只能对应一个地址</strong>，但<strong>这个地址可以对应多个值</strong>。而不可变类型就是<strong>一个变量可以对应多个地址</strong>，但<strong>每个地址只能对应一个值</strong>。<br>
再举一个帮助理解的例子，<br>
a = 1 #没有发现已经存在的存储int值1的地址，创建存储int值1的地址A，将a指向A<br>
b = 1 #发现int值1存在于地址A，将b指向A<br>
x = [1,2,3] #在地址X创建list [1,2,3] ，将x指向X<br>
y = [1,2,3] #在地址Y创建list [1,2,3] ，将y指向Y<br>
print(id(a),id(b),id(a)==id(b)) # True<br>
print(id(x),id(y),id(x)==id(y)) # False<br>
结果是a和b的地址一致，而x和y的地址是不一致的，可以看出虽然x和y的值是一样的，但由于都是list类型，可变类型，那么 x = [1,2,3] 和 y = [1,2,3] 这两个操作都属于创建一个新的list，不管他们的值是否一样。list的赋值都是一个创建然后指向的过程。而 a = 1 和 b = 1的情况，如注释中所述，是一个先寻找是否存在存储该int值的地址，有则指向该地址，没有的话，则创建一个存储该int值的地址，然后指向该地址。两者的赋值语句的逻辑是截然不同的，这是最本质上的差别。<br>
接下来，重点来了，<br>
python中向函数传递参数只能是<strong>引用传递，表示把它的地址都传进去了</strong>，而非值传递。<br>
意思很直观，在调用函数传递参数时，传递的是引用，直白的就是传递对象的内存地址。<br>
那么，在上面描述的情况中，每次调用主函数返回子函数时，由于return命令的执行，该主函数使用的临时变量的内存都要释放，然而由于返回的子函数使用了主函数的临时变量，这个变量会和子函数绑定，存入该子函数的内存空间。<br>
当使用L作为这个临时变量或者说传递对象的时候，return子函数这个操作执行后，返回的子函数中的内存空间中存储的L实质上是L指向的内存地址，当进行 <strong>L = L + 1</strong>这个操作时，由于L现在代表的是一个引用，是一个内存地址，那么实质上的操作就是提取L指向的内存地址中的值；运算该值 + 1的结果；将L指向该结果的内存地址，这个操作需要一个随程序运行更新的起点地址，不然就是一个无法确定运行环境的闭包，而这是与闭包本身的定义相违背的。由于没有设定L为全局变量，所以python就会将这个L视为子函数的局部变量，在子函数内部寻找起点地址，然而又由于未提前在子函数内赋初值，进而报错“局部变量在赋值之前被引用”。<br>
这里大胆猜测，在使用global命令后，python将其置入一个包含所有global变量的总list或者其他可变类型的变量中，然后通过这个变量的变量加上位置实现其调用，原理与L[0]相同。<br>
而当L[0]作为一个临时变量或者说传递对象的时候，由于上文已经讲过的list对象操作的实质，在传进去的这个L[0]所引用的地址是可以直接进行值的改变的，那么则识别为全局变量，return执行后，子函数内存空间保存的是一个确定的指令，对L[0]所在内存地址进行加一。<br>
这个角度的理解方法总结来说，就是可变对象和不可变对象的实质，以及python中函数参数传递和临时变量存储在子函数内存空间中的实质。<br>
或者也有另一个角度的理解方法。<br>
当使用L作为这个临时变量或者说传递对象的时候，return子函数这个操作执行后，在子函数内部，由于并没有声明L是一个全局变量，L所进行的操作也不代表其是一个可变类型的全局变量。<br>
此处又有另外一个知识点，关于<strong>根据操作判断变量类型的逻辑</strong>，参考<br>
https://blog.csdn.net/zsdxqsjxlomer/article/details/78381626?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3<br>
https://blog.csdn.net/bigxuyang/article/details/77877935<br>
这两篇文章，会得到一个比较清晰的认知。<br>
<strong>关键点在于  L = [1,2,3]  这个操作在子函数内没有提前声明L是一个全局变量，纵然L的操作代表其是一个可变类型的变量，但该操作并没有触发python认定其为一个全局变量，则  L = [1,2,3]  这个操作相当于创建一个list类型的名为L的局部变量，而并没有调用之前创建的全局变量L。而  L.append 或者  L[0] = L[0] + 1 这类的list类型专属操作（实质是list这个class的method或者attribute），由于子函数内部在此操作前并没有创建L这个变量，那么触发python认定其为一个可变类型的全局变量，就会往外部寻找，则寻找到之前创建的全局变量L。</strong><br>
接上文，那么L就会被认定为一个<strong>局部变量</strong>，然而L并没有被赋初值，此时报错“局部变量在赋值之前被引用”。<br>
而当L[0]作为一个临时变量或者说传递对象的时候，当执行 L[0] = L[0] + 1这个操作，由于子函数内部在此操作前并没有创建L这个变量，那么触发python认定其为一个可变类型的全局变量，就会往外部寻找，则寻找到之前创建的全局变量L。<br>
这个角度的理解方法总结来说，就是python在闭包函数返回子函数时，判定临时变量是否为全局变量的逻辑。当没有声明变量为全局变量时，只有进行了触发python判定其为<strong>可变类型的全局变量</strong>的操作，才会去外部寻找该变量。所以，当执行 L = L + 1这个操作时，在没有声明L为全局变量的情况下，python是不会去外部寻找的，那么，又因为L并没有在子函数内的开头部分创建，必定会报错“局部变量在赋值之前被引用”。<br>
虽然说了这么多，但自我感觉也有很多地方有问题，发出来抛砖引玉，与大家共同讨论进步，欢迎大家指正。<br>
更新：值小的int会一直保持固定的地址。<br>
有几篇文章解释了相关问题，贴出来供大家参考一下。<br>
https://blog.csdn.net/WSBruce/article/details/79234389?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1<br>
https://blog.csdn.net/fragmentalice/article/details/81363494?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2<br>
https://blog.csdn.net/as480133937/article/details/87305247?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3</p>
</blockquote>
<h2 id="匿名函数">匿名函数</h2>
<p>在传入函数时，可以不需要显式地定义函数，直接传入匿名函数更方便。</p>
<p>在Python中，对匿名函数提供了有限支持。还是以map()函数为例，计算f(x)=x2时，除了定义一个f(x)的函数外，还可以直接传入匿名函数：</p>
<pre><code>&gt;&gt;&gt; list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
[1, 4, 9, 16, 25, 36, 49, 64, 81]
</code></pre>
<p>通过对比可以看出，匿名函数lambda x: x * x实际上就是：</p>
<pre><code>def f(x):
    return x * x
</code></pre>
<p>关键字lambda表示匿名函数，冒号前面的x表示函数参数。</p>
<p>匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。</p>
<p>用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数：</p>
<pre><code>&gt;&gt;&gt; f = lambda x: x * x
&gt;&gt;&gt; f
&lt;function &lt;lambda&gt; at 0x101c6ef28&gt;
&gt;&gt;&gt; f(5)
25
</code></pre>
<p>同样，也可以把匿名函数作为返回值返回，比如：</p>
<pre><code>def build(x, y):
    return lambda: x * x + y * y
</code></pre>
<p>注意不用在：前写参数的情况</p>
<ol>
<li>lambda本身不需要传入参数（也就是：后面的表达式里用不到：前的参数）</li>
<li>只使用def中已经定义的形参</li>
</ol>
<h2 id="装饰器">装饰器</h2>
<p>由于函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数</p>
<pre><code>&gt;&gt;&gt; def now():
...     print('2015-3-25')
...
&gt;&gt;&gt; f = now
&gt;&gt;&gt; f()
2015-3-25
</code></pre>
<p>函数对象有一个__name__属性，可以拿到函数的名字：</p>
<pre><code>&gt;&gt;&gt; now.__name__
'now'
&gt;&gt;&gt; f.__name__
'now'
</code></pre>
<p>如锅要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now()函数的定义，这种<strong>在代码运行期间动态增加功能</strong>的方式，称之为“装饰器”（Decorator）。</p>
<p>本质上，decorator就是一个<strong>返回函数的高阶函数</strong>。所以，我们要定义一个能打印日志的decorator，可以定义如下：</p>
<pre><code>def log(func):
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
</code></pre>
<p>观察上面的log，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。我们要<strong>借助Python的@语法</strong>，<strong>把decorator置于函数的定义处</strong>：</p>
<pre><code>@log
def now():
    print('2015-3-25')
</code></pre>
<p>调用now()函数，不仅会运行now()函数本身，还会在运行now()函数前打印一行日志：</p>
<pre><code>&gt;&gt;&gt; now()
call now():
2015-3-25
</code></pre>
<p>把@log放到now()函数的定义处，相当于执行了语句：</p>
<pre><code>now = log(now)
</code></pre>
<p>由于log()是一个decorator，返回一个函数，所以，原来的now()函数仍然存在，只是现在同名的now变量指向了新的函数，于是调用now()将执行新函数，即在log()函数中返回的<strong>wrapper()函数</strong>。</p>
<p>wrapper()函数的参数定义是<code>(*args, **kw)</code>，因此，wrapper()函数可以<strong>接受任意参数的调用</strong>。在wrapper()函数内，首先打印日志，再紧接着调用原始函数。</p>
<p>如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本：</p>
<pre><code>def log(text):
    def decorator(func):
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
</code></pre>
<p>这个3层嵌套的decorator用法如下：</p>
<pre><code>@log('execute')
def now():
    print('2015-3-25')
</code></pre>
<p>执行结果如下：</p>
<pre><code>&gt;&gt;&gt; now()
execute now():
2015-3-25
</code></pre>
<p>和两层嵌套的decorator相比，3层嵌套的效果是这样的：</p>
<pre><code>&gt;&gt;&gt; now = log('execute')(now)
</code></pre>
<p>我们来剖析上面的语句</p>
<ol>
<li>首先<strong>执行log('execute')</strong></li>
<li><strong>返回的是decorator函数</strong>，再调用返回的函数，参数是now函数</li>
<li>返回值<strong>最终是wrapper函数</strong>。</li>
</ol>
<p>以上两种decorator的定义都没有问题，但还差最后一步。因为函数也是对象，它有__name__等属性，但经过decorator装饰之后的函数，<strong>它们的name已经从原来的'now'变成了'wrapper'</strong>：</p>
<pre><code>&gt;&gt;&gt; now.__name__
'wrapper'
</code></pre>
<p>因为返回的那个wrapper()函数名字就是'wrapper'，所以，<strong>需要把原始函数的name等属性复制到wrapper()函数中</strong>，<strong>否则，有些依赖函数签名的代码执行就会出错</strong>。</p>
<p>不需要编写<code>wrapper.__name__ = func.__name__</code>这样的代码，Python内置的<strong>functools.wraps</strong>就是干这个事的，所以，一个完整的decorator的写法如下：</p>
<pre><code>import functools

def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
</code></pre>
<p>或者针对带参数的decorator：</p>
<pre><code>import functools

def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
</code></pre>
<p>import functools是导入functools模块，在定义wrapper()的前面加上@functools.wraps(func)即可。</p>
<h2 id="小结-2">小结</h2>
<p>在面向对象（OOP）的设计模式中，decorator被称为装饰模式。OOP的装饰模式需要通过继承和组合来实现，而Python除了能支持OOP的decorator外，<strong>直接从语法层次支持decorator</strong>。Python的decorator<strong>可以用函数实现，也可以用类实现</strong>。</p>
<p>decorator可以增强函数的功能，定义起来虽然有点复杂，但使用起来非常灵活和方便。</p>
<h2 id="偏函数">偏函数</h2>
<p>Python的functools模块提供了很多有用的功能，其中一个就是偏函数（Partial function）。要注意，这里的偏函数和数学意义上的偏函数不一样。</p>
<p>在介绍函数参数的时候，通过设定参数的默认值，可以降低函数调用的难度。而偏函数也可以做到这一点。举例如下：</p>
<p>int()函数可以把字符串转换为整数，当仅传入字符串时，int()函数默认按十进制转换：</p>
<pre><code>&gt;&gt;&gt; int('12345')
12345
</code></pre>
<p>但<strong>int()函数还提供额外的base参数，默认值为10</strong>。如果<strong>传入base参数，就可以做N进制的转换</strong>：</p>
<pre><code>&gt;&gt;&gt; int('12345', base=8)
5349
&gt;&gt;&gt; int('12345', 16)
74565
</code></pre>
<p>假设要转换大量的二进制字符串，每次都传入int(x, base=2)非常麻烦，于是，我们想到，可以定义一个int2()的函数，默认把base=2传进去：</p>
<pre><code>def int2(x, base=2):
    return int(x, base)
</code></pre>
<p>这样，我们转换二进制就非常方便了：</p>
<pre><code>&gt;&gt;&gt; int2('1000000')
64
&gt;&gt;&gt; int2('1010101')
85
</code></pre>
<p>functools.partial就是帮助我们<strong>创建一个偏函数的，不需要我们自己定义int2()</strong>，可以直接使用下面的代码创建一个新的函数int2：</p>
<pre><code>&gt;&gt;&gt; import functools
&gt;&gt;&gt; int2 = functools.partial(int, base=2)
&gt;&gt;&gt; int2('1000000')
64
&gt;&gt;&gt; int2('1010101')
85
</code></pre>
<p>所以，简单总结functools.partial的作用就是，<strong>把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数</strong>，调用这个新函数会更简单。</p>
<p>注意到上面的新的int2函数，<strong>仅仅是把base参数重新设定默认值为2，但也可以在函数调用时传入其他值</strong>：</p>
<pre><code>&gt;&gt;&gt; int2('1000000', base=10)
1000000
</code></pre>
<p>最后，创建偏函数时，实际上<strong>可以接收函数对象、<code>*args</code>和<code>kw</code>这3个参数</strong>，当传入：</p>
<pre><code>int2 = functools.partial(int, base=2)
</code></pre>
<p>实际上固定了int()函数的关键字参数base，也就是：</p>
<pre><code>int2('10010')
</code></pre>
<p>相当于：</p>
<pre><code>kw = { 'base': 2 }
int('10010', **kw)
</code></pre>
<p>当传入：</p>
<pre><code>max2 = functools.partial(max, 10)
</code></pre>
<p>实际上会把10作为<code>*args</code>的一部分<strong>自动加到左边</strong>，也就是：</p>
<pre><code>max2(5, 6, 7)
</code></pre>
<p>相当于：</p>
<pre><code>args = (10, 5, 6, 7)
max(*args)
</code></pre>
<p>结果为10。</p>
<h2 id="小结-3">小结</h2>
<p>当函数的参<strong>数个数太多，需要简化时</strong>，使用functools.partial可以创建一个新的函数，这个新函数可以<strong>固定住原函数的部分参数</strong>，从而在调用时更简单。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python - 高级特性]]></title>
        <id>https://lixin-scut.github.io//post/python-gao-ji-te-xing</id>
        <link href="https://lixin-scut.github.io//post/python-gao-ji-te-xing">
        </link>
        <updated>2020-05-08T11:33:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="提取容器的部分元素">提取容器的部分元素</h2>
<h3 id="list">list</h3>
<p>取一个list部分元素是非常常见的操作，Python提供了切片（Slice）操作符<br>
取前3个元素，用一行代码就可以完成切片：</p>
<pre><code>&gt;&gt;&gt; L[0:3]
['Michael', 'Sarah', 'Tracy']
</code></pre>
<p>L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。</p>
<p>注意区间是左闭右开，提取的元素数量刚好是右区间减去左区间</p>
<p>如果第一个索引是0，还可以省略：</p>
<pre><code>&gt;&gt;&gt; L[:3]
['Michael', 'Sarah', 'Tracy']
</code></pre>
<p>注意Python支持L[-1]取倒数第一个元素，那么同样支持<strong>倒数切</strong>片，试试：</p>
<pre><code>&gt;&gt;&gt; L[-2:]
['Bob', 'Jack']
&gt;&gt;&gt; L[-2:-1]
['Bob']
</code></pre>
<p><strong>注意倒数第一个元素的索引是-1。</strong></p>
<p>例子：</p>
<p><strong>提取连续元素</strong></p>
<p>前10个数：</p>
<pre><code>&gt;&gt;&gt; L[:10]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>后10个数：</p>
<pre><code>&gt;&gt;&gt; L[-10:]
[90, 91, 92, 93, 94, 95, 96, 97, 98, 99]
</code></pre>
<p>前11-20个数：</p>
<pre><code>&gt;&gt;&gt; L[10:20]
[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
</code></pre>
<p>规律间隔取值</p>
<p>前10个数，每两个取一个：</p>
<pre><code>&gt;&gt;&gt; L[:10:2]
[0, 2, 4, 6, 8]
</code></pre>
<p>所有数，每5个取一个：</p>
<pre><code>&gt;&gt;&gt; L[::5]
[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]
</code></pre>
<p>甚至什么都不写，只写[:]就可以原样复制一个list：</p>
<pre><code>&gt;&gt;&gt; L[:]
[0, 1, 2, 3, ..., 99]
</code></pre>
<h3 id="tuple">tuple</h3>
<p>tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是<strong>操作的结果仍是tuple</strong>：</p>
<pre><code>&gt;&gt;&gt; (0, 1, 2, 3, 4, 5)[:3]
(0, 1, 2)
</code></pre>
<h3 id="字符串">字符串</h3>
<p>字符串'xxx'也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是<strong>操作结果仍是字符串</strong>：</p>
<pre><code>&gt;&gt;&gt; 'ABCDEFG'[:3]
'ABC'
&gt;&gt;&gt; 'ABCDEFG'[::2]
'ACEG'
</code></pre>
<p>在很多编程语言中，针对字符串提供了很多各种截取函数（例如，substring），其实目的就是对字符串切片。Python没有针对字符串的截取函数，只需要切片一个操作就可以完成。</p>
<p><strong>个人练习代码</strong><br>
实现一个trim()函数去除字符串首尾的空格，</p>
<pre><code>def trim(s):
if len(s) == 0:
		return s
left = 0
while left &lt; len(s) and s[left] == ' ':
		left = left + 1
right = len(s) - 1
while right &gt;= 0 and s[right] == ' ':
		right = right - 1
if left &lt; right:
	 return s[left : right+1]
else:
	 return ''
</code></pre>
<h2 id="迭代">迭代</h2>
<p>给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。</p>
<p>在Python中，迭代是通过for ... in来完成的</p>
<p>Python的for循环抽象程度要高于C的for循环，因为Python的for循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上。</p>
<h3 id="无下标迭代-dict迭代">无下标迭代-dict迭代</h3>
<p>list这种数据类型虽然有下标，但很多其他数据类型是没有下标的，但是，只要是可迭代对象，无论有无下标，都可以迭代，比如dict就可以迭代：</p>
<pre><code>&gt;&gt;&gt; d = {'a': 1, 'b': 2, 'c': 3}
&gt;&gt;&gt; for key in d:
...     print(key)
</code></pre>
<p>注意，由于哈希函数的特性，dict的存储不是按照list的方式顺序排列，所以，<strong>迭代出的结果顺序很可能不一样</strong>。</p>
<p>默认情况下，<strong>dict迭代的是key</strong>。如果要<strong>迭代value</strong>，可以用<code>for value in d.values()</code>，如果要<strong>同时迭代key和value</strong>，可以用<code>for k, v in d.items()</code>。</p>
<p>判断一个对象是可迭代对象：通过collections模块的Iterable类型判断：</p>
<pre><code>&gt;&gt;&gt; from collections import Iterable
&gt;&gt;&gt; isinstance('abc', Iterable) # str是否可迭代
True
&gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代
True
&gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代
False
</code></pre>
<h3 id="下标循环">下标循环</h3>
<p>如果要对list实现类似Java那样的下标循环，可以使用Python内置的<strong>enumerate函数</strong>，可以<strong>把一个list变成索引-元素对</strong>，这样就可以在for循环中<strong>同时迭代索引和元素</strong>本身：</p>
<pre><code>&gt;&gt;&gt; for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)
...
0 A
1 B
2 C
</code></pre>
<p>上面的for循环里，同时引用了两个变量，在Python里是很常见的，比如下面的代码：</p>
<pre><code>&gt;&gt;&gt; for x, y in [(1, 1), (2, 4), (3, 9)]:
...     print(x, y)
...
1 1
2 4
3 9
</code></pre>
<p><strong>个人练习代码</strong><br>
使用迭代查找一个list中最小和最大值，并返回一个tuple：</p>
<pre><code>def findMinAndMax(L):
    if len(L) == 0:    
        return (None, None)
    max_num = L[0]
    min_num = L[0]
    for num in L:
        max_num = max(max_num, num)
        min_num = min(min_num, num)
    return (min_num, max_num)
</code></pre>
<h2 id="列表生成式">列表生成式</h2>
<p>列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来<strong>创建list的生成式</strong>。</p>
<p>例如要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))：</p>
<pre><code>&gt;&gt;&gt; list(range(1, 11))
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
</code></pre>
<p>要生成[1x1, 2x2, 3x3, ..., 10x10]<br>
列表生成式则可以用一行语句代替循环生成：</p>
<pre><code>&gt;&gt;&gt; [x * x for x in range(1, 11)]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
</code></pre>
<p>把要生成的元素x * x放到前面，后面跟for循环，就可以把list创建出来</p>
<p>for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：</p>
<pre><code>&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0]
[4, 16, 36, 64, 100]
</code></pre>
<p>还可以使用两层循环，可以生成全排列：</p>
<pre><code>&gt;&gt;&gt; [m + n for m in 'ABC' for n in 'XYZ']
['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']
</code></pre>
<ol>
<li>字符串可以<strong>直接相加</strong></li>
<li>循环<strong>可以并列</strong></li>
</ol>
<p>运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：</p>
<pre><code>&gt;&gt;&gt; import os # 导入os模块，模块的概念后面讲到
&gt;&gt;&gt; [d for d in os.listdir('.')] # os.listdir可以列出文件和目录
['.emacs.d', '.ssh', '.Trash', 'Adlm', 'Applications', 'Desktop', 'Documents', 'Downloads', 'Library', 'Movies', 'Music', 'Pictures', 'Public', 'VirtualBox VMs', 'Workspace', 'XCode']
</code></pre>
<p>for循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value：</p>
<pre><code>&gt;&gt;&gt; d = {'x': 'A', 'y': 'B', 'z': 'C' }
&gt;&gt;&gt; for k, v in d.items():
...     print(k, '=', v)
...
y = B
x = A
z = C
</code></pre>
<p>最后把一个list中所有的字符串变成小写：</p>
<pre><code>&gt;&gt;&gt; L = ['Hello', 'World', 'IBM', 'Apple']
&gt;&gt;&gt; [s.lower() for s in L]
['hello', 'world', 'ibm', 'apple']
</code></pre>
<h3 id="if-else">if ... else</h3>
<p>使用列表生成式的时候，不能在<strong>最后的if</strong>加上else：</p>
<pre><code>&gt;&gt;&gt; [x for x in range(1, 11) if x % 2 == 0]
[2, 4, 6, 8, 10]

&gt;&gt;&gt; [x for x in range(1, 11) if x % 2 == 0 else 0]
  File &quot;&lt;stdin&gt;&quot;, line 1
    [x for x in range(1, 11) if x % 2 == 0 else 0]
                                              ^
SyntaxError: invalid syntax
</code></pre>
<p>这是因为<strong>跟在for后面的if</strong>是一个筛选条件，不能带else，否则无法进行筛选</p>
<p>而把if写在for前面必须加else，否则报错：</p>
<pre><code>&gt;&gt;&gt; [x if x % 2 == 0 for x in range(1, 11)]
  File &quot;&lt;stdin&gt;&quot;, line 1
    [x if x % 2 == 0 for x in range(1, 11)]
                       ^
SyntaxError: invalid syntax
</code></pre>
<p>这是因为for前面的部分是一个表达式，它必须根据x计算出一个结果。因此，考察表达式：x if x % 2 == 0，它无法根据x计算出结果，因为缺少else，必须加上else：</p>
<pre><code>&gt;&gt;&gt; [x if x % 2 == 0 else -x for x in range(1, 11)]
[-1, 2, -3, 4, -5, 6, -7, 8, -9, 10]
上述for前面的表达式x if x % 2 == 0 else -x才能根据x计算出确定的结果。
</code></pre>
<p>可见，在一个列表生成式中，for前面的if ... else是表达式，而for后面的if是过滤条件，不能带else。</p>
<p><strong>个人代码练习</strong><br>
如果list中既包含字符串，又包含整数，由于非字符串类型没有lower()方法，需要使用内建的isinstance函数可以判断一个变量是不是字符串：</p>
<pre><code>L1 = ['Hello', 'World', 18, 'Apple', None]
L2 = [x.lower() for x in L1 if isinstance(x, str)]
</code></pre>
<p>注意没法使用lower(x) ，必须用x.lower()</p>
<h2 id="生成器">生成器</h2>
<p>受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p>
<p>所以，如果<strong>列表元素可以按照某种算法推算出来</strong>，那我们是否可以在循环的过程中<strong>不断推算出后续的元素</strong>呢？这样就<strong>不必创建完整的list</strong>，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。</p>
<h3 id="创建generator">创建generator</h3>
<p>把一个列表生成式的[]改成()，就创建了一个generator：</p>
<pre><code>&gt;&gt;&gt; L = [x * x for x in range(10)]
&gt;&gt;&gt; L
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
&gt;&gt;&gt; g = (x * x for x in range(10))
&gt;&gt;&gt; g
&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;
</code></pre>
<p>创建L和g的区别仅在于最外层的[]和()，L是一个list，而g是一个generator。</p>
<p><strong>打印generator的每一个元素</strong></p>
<p>如果要一个一个打印出来，可以通过next()函数获得generator的下一个返回值：</p>
<pre><code>&gt;&gt;&gt; next(g)
0
&gt;&gt;&gt; next(g)
1
&gt;&gt;&gt; next(g)
4
&gt;&gt;&gt; next(g)
9
&gt;&gt;&gt; next(g)
16
&gt;&gt;&gt; next(g)
25
&gt;&gt;&gt; next(g)
36
&gt;&gt;&gt; next(g)
49
&gt;&gt;&gt; next(g)
64
&gt;&gt;&gt; next(g)
81
&gt;&gt;&gt; next(g)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
StopIteration
</code></pre>
<p>generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值<br>
直到计算到最后一个元素，<strong>没有更多的元素时，抛出StopIteration的错误</strong>。</p>
<p>更便捷的方法是使用for循环，因为generator也是可迭代对象：</p>
<pre><code>&gt;&gt;&gt; g = (x * x for x in range(10))
&gt;&gt;&gt; for n in g:
...     print(n)
... 
0
1
4
9
16
25
36
49
64
81
</code></pre>
<p>由于StopIteration的错误的存在，创建了一个generator后，基本上永远不会调用next()，而是通过for循环来迭代它，不需要关心StopIteration的错误。</p>
<p><strong>定义generator的另一种方法</strong></p>
<p>如果一个<strong>函数定义</strong>中包含<strong>yield关键字</strong>（注意这里涉及协程），那么这个函数就不再是一个普通函数，而是一个generator</p>
<p>例子：斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到：</p>
<pre><code>def fib(max):
    n, a, b = 0, 0, 1
    while n &lt; max:
        yield b
        a, b = b, a + b
        n = n + 1
    return 'done'
		
&gt;&gt;&gt; f = fib(6)
&gt;&gt;&gt; f
&lt;generator object fib at 0x104feaaa0&gt;
</code></pre>
<p>generator和函数的执行流程不一样。</p>
<ol>
<li>函数是顺序执行，遇到return语句或者最后一行函数语句就返回。</li>
<li>而变成generator的函数，在每次<strong>调用next()的时候执行</strong>，<strong>遇到yield语句返回</strong>，再次执行时<strong>从上次返回的yield语句处继续执行</strong>。</li>
</ol>
<p>举个简单的例子，定义一个generator，依次返回数字1，3，5：</p>
<pre><code>def odd():
    print('step 1')
    yield 1
    print('step 2')
    yield(3)
    print('step 3')
    yield(5)
</code></pre>
<p>调用该generator时，首先要生成一个generator对象，然后用next()函数不断获得下一个返回值：</p>
<pre><code>&gt;&gt;&gt; o = odd()
&gt;&gt;&gt; next(o)
step 1
1
&gt;&gt;&gt; next(o)
step 2
3
&gt;&gt;&gt; next(o)
step 3
5
&gt;&gt;&gt; next(o)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
StopIteration

# 在执行过程中，遇到yield就中断，下次又继续执行。执行3次yield后，已经没有yield可以执行了，所以，第4次调用next(o)就报错。
</code></pre>
<p>由于错误的存在，同样地把函数改成generator后，我们基本上从来不会用next()来获取下一个返回值，而是直接使用for循环来迭代：</p>
<pre><code>&gt;&gt;&gt; for n in fib(6):
...     print(n)
</code></pre>
<p>但在循环过程中不断调用yield，可能会导致不断中断。要给循环设置一个条件来退出循环，不然就会产生一个无限数列出来。</p>
<p>但是用for循环调用generator时，<strong>拿不到generator的return语句的返回值</strong>。如果想要拿到返回值，<strong>必须捕获StopIteration错误</strong>，<strong>返回值包含在StopIteration的value中</strong></p>
<pre><code>&gt;&gt;&gt; g = fib(6)
&gt;&gt;&gt; while True:
...     try:
...         x = next(g)
...         print('g:', x)
...     except StopIteration as e:
...         print('Generator return value:', e.value)
...         break
...
g: 1
g: 1
g: 2
g: 3
g: 5
g: 8
Generator return value: done
</code></pre>
<p><strong>个人代码练习</strong><br>
杨辉三角把<br>
每一行看做一个list，试写一个generator，不断输出下一行的list：</p>
<pre><code># -*- coding: utf-8 -*-

def triangles():
    n, list_pre, list_cur  = 0, [1], [1, 1]
    while True:
        if n == 0:
            n = n + 1
            yield list_pre
        if n == 1:
            n = n + 1
            yield list_cur
        list_pre = list_cur
        list_cur = [1, 1]
        for i in range(1, len(list_pre)):
            list_cur.insert(i, list_pre[i] + list_pre[i - 1])
        n = n + 1
        yield list_cur
				
				
# 期待输出:
# [1]
# [1, 1]
# [1, 2, 1]
# [1, 3, 3, 1]
# [1, 4, 6, 4, 1]
# [1, 5, 10, 10, 5, 1]
# [1, 6, 15, 20, 15, 6, 1]
# [1, 7, 21, 35, 35, 21, 7, 1]
# [1, 8, 28, 56, 70, 56, 28, 8, 1]
# [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]
n = 0
results = []
for t in triangles():
    results.append(t)
    n = n + 1
    if n == 10:
        break

for t in results:
    print(t)

if results == [
    [1],
    [1, 1],
    [1, 2, 1],
    [1, 3, 3, 1],
    [1, 4, 6, 4, 1],
    [1, 5, 10, 10, 5, 1],
    [1, 6, 15, 20, 15, 6, 1],
    [1, 7, 21, 35, 35, 21, 7, 1],
    [1, 8, 28, 56, 70, 56, 28, 8, 1],
    [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]
]:
    print('测试通过!')
else:
    print('测试失败!')
</code></pre>
<h2 id="迭代器">迭代器</h2>
<h3 id="可迭代对象iterable">可迭代对象：Iterable</h3>
<p>可以直接作用于for循环的数据类型有以下几种：</p>
<p>一类是<strong>集合数据类型</strong>，如list、tuple、dict、set、str等；</p>
<p>一类是<strong>generator</strong>，包括<strong>生成器</strong>和<strong>带yield的generator function</strong>。</p>
<p>这些可以直接作用于for循环的对象统称为<strong>可迭代对象：Iterable。</strong></p>
<p><strong>可以使用isinstance()判断一个对象是否是Iterable对象：</strong></p>
<pre><code>&gt;&gt;&gt; from collections.abc import Iterable
&gt;&gt;&gt; isinstance([], Iterable)
True
&gt;&gt;&gt; isinstance({}, Iterable)
True
&gt;&gt;&gt; isinstance('abc', Iterable)
True
&gt;&gt;&gt; isinstance((x for x in range(10)), Iterable)
True
&gt;&gt;&gt; isinstance(100, Iterable)
False
</code></pre>
<h3 id="迭代器iterator">迭代器：Iterator</h3>
<p>而生成器不但可以作用于for循环，还<strong>可以被next()函数不断调用并返回下一个值</strong>，直到最<strong>后抛出StopIteration错误</strong>表示无法继续返回下一个值了。</p>
<p>可以被next()函数调用并不断返回下一个值的对象称为<strong>迭代器：Iterator</strong>。</p>
<p>可以使用isinstance()判断一个对象是否是Iterator对象：</p>
<pre><code>&gt;&gt;&gt; from collections.abc import Iterator
&gt;&gt;&gt; isinstance((x for x in range(10)), Iterator)
True
&gt;&gt;&gt; isinstance([], Iterator)
False
&gt;&gt;&gt; isinstance({}, Iterator)
False
&gt;&gt;&gt; isinstance('abc', Iterator)
False
</code></pre>
<p><strong>生成器都是Iterator对象</strong>，但<strong>list、dict、str虽然是Iterable，却不是Iterator。</strong></p>
<p>把list、dict、str等Iterable变成Iterator可以使用<strong>iter()函数</strong>：</p>
<pre><code>&gt;&gt;&gt; isinstance(iter([]), Iterator)
True
&gt;&gt;&gt; isinstance(iter('abc'), Iterator)
True
</code></pre>
<p><strong>为什么list、dict、str等数据类型不是Iterator？</strong></p>
<p>这是因为Python的<strong>Iterator对象表示的是一个数据流</strong>，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却<strong>不能提前知道序列的长度</strong>，只能不断通过next()函数实现按需计算下一个数据，所以<strong>Iterator的计算是惰性的</strong>，只有在需要返回下一个数据时它才会计算。</p>
<p>Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而<strong>使用list是永远不可能存储全体自然数的</strong>。</p>
<h3 id="小结">小结</h3>
<p>凡是可作用于for循环的对象都是<strong>Iterable类型</strong>；</p>
<p>凡是可作用于next()函数的对象都是<strong>Iterator类型</strong>，它们表示一个惰性计算的序列；</p>
<p>集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。</p>
<p>Python的for循环本质上就是通过不断调用next()函数实现的，例如：</p>
<pre><code>for x in [1, 2, 3, 4, 5]:
    pass
</code></pre>
<p>实际上完全等价于：</p>
<pre><code># 首先获得Iterator对象:
it = iter([1, 2, 3, 4, 5])
# 循环:
while True:
    try:
        # 获得下一个值:
        x = next(it)
    except StopIteration:
        # 遇到StopIteration就退出循环
        break
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python - 函数]]></title>
        <id>https://lixin-scut.github.io//post/python-han-shu</id>
        <link href="https://lixin-scut.github.io//post/python-han-shu">
        </link>
        <updated>2020-05-08T07:20:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="调用函数">调用函数</h2>
<p>要调用一个函数，需要知道函数的名称和参数，比如求绝对值的函数abs，只有一个参数。可以直接从Python的官方网站查看文档：</p>
<p>http://docs.python.org/3/library/functions.html#abs</p>
<p>也可以在交互式命令行通过help(abs)查看abs函数的帮助信息。help将会进入新界面，按q返回</p>
<p>调用函数的时候，如果传入的参数数量不对，会报TypeError的错误，并且Python会明确地告诉你：abs()有且仅有1个参数，但给出了两个：</p>
<pre><code>&gt;&gt;&gt; abs(1, 2)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: abs() takes exactly one argument (2 given)
</code></pre>
<p>如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报TypeError的错误，并且给出错误信息：str是错误的参数类型：</p>
<pre><code>&gt;&gt;&gt; abs('a')
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: bad operand type for abs(): 'str'
</code></pre>
<p>而max函数max()可以接收任意多个参数，并返回最大的那个：</p>
<pre><code>&gt;&gt;&gt; max(1, 2)
2
&gt;&gt;&gt; max(2, 3, 1, -5)
3
</code></pre>
<h3 id="数据类型转换">数据类型转换</h3>
<p>Python内置的常用函数还包括数据类型转换函数，比如int()函数可以把其他数据类型转换为整数：</p>
<pre><code>&gt;&gt;&gt; int('123')
123
&gt;&gt;&gt; int(12.34)
12
&gt;&gt;&gt; float('12.34')
12.34
&gt;&gt;&gt; str(1.23)
'1.23'
&gt;&gt;&gt; str(100)
'100'
&gt;&gt;&gt; bool(1)
True
&gt;&gt;&gt; bool('')
False
</code></pre>
<p>函数名其实就是<strong>指向一个函数对象的引用</strong>，完全可以<strong>把函数名赋给一个变量</strong>，相当于给这个函数起了一个“别名”：</p>
<pre><code>&gt;&gt;&gt; a = abs # 变量a指向abs函数
&gt;&gt;&gt; a(-1) # 所以也可以通过a调用abs函数
1
</code></pre>
<h2 id="定义函数">定义函数</h2>
<p>在Python中，定义一个函数要使用def语句，依次写出<strong>函数名、括号、括号中的参数和冒号:</strong>，然后，在缩进块中编写函数体，函数的返回值用return语句返回。</p>
<pre><code>def my_abs(param):
    if(param &lt; 0):
         param = - param
    return param
</code></pre>
<p>函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。</p>
<p>如果没有return语句，函数执行完毕后也会返回结果，只是<strong>结果为None</strong>。return None可以简写为return。</p>
<p>在Python交互环境中定义函数时，注意Python会出现...的提示。函数定义结束后需要按两次回车重新回到&gt;&gt;&gt;提示符下</p>
<p>如果你已经把my_abs()的函数定义<strong>保存为abstest.py文件</strong>了，那么，可以在该文件的当前目录下启动Python解释器，<strong>用from abstest import my_abs来导入my_abs()函数</strong>，注意abstest是文件名（<strong>不含.py扩展名</strong>）</p>
<h3 id="空函数">空函数</h3>
<p>如果想定义一个什么事也不做的空函数，可以用pass语句：</p>
<pre><code>def nop():
    pass
</code></pre>
<p>pass语句什么都不做，那有什么用？实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。</p>
<p>pass还可以用在其他语句里，比如：</p>
<pre><code>if age &gt;= 18:
    pass
</code></pre>
<p><strong>缺少了pass，代码运行就会有语法错误。</strong></p>
<h3 id="参数检查">参数检查</h3>
<p>调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出TypeError：</p>
<pre><code>&gt;&gt;&gt; my_abs(1, 2)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: my_abs() takes 1 positional argument but 2 were given
</code></pre>
<p><strong>但是如果参数类型不对，Python解释器就无法帮我们检查</strong>。</p>
<p>试试my_abs和内置函数abs的差别：</p>
<pre><code>&gt;&gt;&gt; my_abs('A')
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;&lt;stdin&gt;&quot;, line 2, in my_abs
TypeError: unorderable types: str() &gt;= int()
&gt;&gt;&gt; abs('A')
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: bad operand type for abs(): 'str'
</code></pre>
<p>当传入了不恰当的参数时，内置函数abs会检查出参数错误，而自己定义的my_abs没有参数检查，会导致if语句出错，出错信息和abs不一样。所以，这个函数定义不够完善。</p>
<p>需要修改一下my_abs的定义，对参数类型做检查，只允许整数和浮点数类型的参数。<br>
<strong>数据类型检查可以用内置函数isinstance()实现</strong>：</p>
<pre><code>def my_abs(x):
    if not isinstance(x, (int, float)):
        raise TypeError('bad operand type')
    if x &gt;= 0:
        return x
    else:
        return -x
</code></pre>
<p>添加了参数检查后，如果传入错误的参数类型，函数就可以抛出一个错误：</p>
<pre><code>&gt;&gt;&gt; my_abs('A')
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;&lt;stdin&gt;&quot;, line 3, in my_abs
TypeError: bad operand type
</code></pre>
<h3 id="返回多个值">返回多个值</h3>
<p>函数可以返回多个值</p>
<pre><code>import math

def move(x, y, step, angle=0):
    nx = x + step * math.cos(angle)
    ny = y - step * math.sin(angle)
    return nx, ny
</code></pre>
<p>import math语句表示导入math包，并允许后续代码引用math包里的sin、cos等函数。</p>
<p>然后，我们就可以同时获得返回值：</p>
<pre><code>&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)
&gt;&gt;&gt; print(x, y)
151.96152422706632 70.0
</code></pre>
<p>但其实这只是一种假象，<strong>Python函数返回的仍然是单一值</strong>：</p>
<pre><code>&gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6)
&gt;&gt;&gt; print(r)
(151.96152422706632, 70.0)
</code></pre>
<p>返回值<strong>实际上是一个tuple</strong>，但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，<strong>按位置赋给对应的值</strong><br>
所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。</p>
<h2 id="函数的参数">函数的参数</h2>
<p>定义函数的时候，我们把参数的名字和位置确定下来，函数的接口定义就完成了。对于函数的调用者来说，只需要知道如何传递正确的参数，以及函数将返回什么样的值就够了，函数内部的复杂逻辑被封装起来，调用者无需了解。</p>
<p>Python的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用<strong>默认参数、可变参数和关键字参数</strong>，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。</p>
<h3 id="位置参数">位置参数</h3>
<p>对于func(x)函数，参数x就是一个位置参数。<br>
当我们调用func函数时，必须传入有且仅有的一个参数x<br>
调用函数时，传入的值按照位置顺序依次赋给参数x，所以叫做位置参数</p>
<h3 id="默认参数">默认参数</h3>
<p>如果希望定义新的函数定义，但是希望避免因为缺少一个参数而无法正常调用旧的调用代码，可以增加了一个默认参数</p>
<pre><code>def power(x, n=2):
    s = 1
    while n &gt; 0:
        n = n - 1
        s = s * x
    return s
</code></pre>
<p>设置默认参数时，有几点要注意：</p>
<ol>
<li>
<p><strong>必选参数在前，默认参数在后</strong>，否则Python的解释器会报错</p>
</li>
<li>
<p>如何设置默认参数。<br>
当函数有多个参数时，把<strong>变化大的参数放前面</strong>，<strong>变化小的参数放后面</strong>。变化小的参数就可以作为默认参数。<br>
使用默认参数最大的好处是能<strong>降低调用函数的难度</strong>。</p>
</li>
</ol>
<p>有多个默认参数时，调用的时候，既可以按顺序提供默认参数，比如调用<code>enroll('Bob', 'M', 7)</code><br>
也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。比如调用<code>enroll('Adam', 'M', city='Tianjin')</code></p>
<p>默认参数很有用，但使用不当，也会掉坑里。默认参数有个最大的坑，</p>
<p>先定义一个函数，传入一个list，添加一个END再返回：</p>
<pre><code>def add_end(L=[]):
    L.append('END')
    return L
</code></pre>
<p>当你使用默认参数调用时，一开始结果也是对的：</p>
<pre><code>&gt;&gt;&gt; add_end()
['END']
</code></pre>
<p>但是，再次调用add_end()时，结果就不对了：</p>
<pre><code>&gt;&gt;&gt; add_end()
['END', 'END']
&gt;&gt;&gt; add_end()
['END', 'END', 'END']
</code></pre>
<p>默认参数虽然是[]，但是函数似乎每次都“记住了”上次添加了'END'后的list。</p>
<p>原因解释如下：</p>
<p>Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为<strong>默认参数L也是一个变量，它指向对象[]</strong>，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。</p>
<p><strong>定义默认参数要牢记一点：默认参数必须指向不变对象！</strong></p>
<p>要修改上面的例子，我们可以用None这个不变对象来实现：</p>
<pre><code>def add_end(L=None):
    if L is None:
        L = []
    L.append('END')
    return L
</code></pre>
<p>现在，无论调用多少次，都不会有问题：</p>
<pre><code>&gt;&gt;&gt; add_end()
['END']
&gt;&gt;&gt; add_end()
['END']
</code></pre>
<p>这就是设计str、None这样的不变对象的原因，因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。<br>
此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。</p>
<h3 id="可变参数">可变参数</h3>
<p>在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。</p>
<pre><code>def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum
</code></pre>
<p>定义可变参数和定义一个list或tuple参数相比，<strong>仅仅在参数前面加了一个*号</strong>。在函数内部，<strong>参数numbers接收到的是一个tuple</strong>，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，<strong>包括0个参</strong>数：</p>
<pre><code>&gt;&gt;&gt; calc(1, 2)
5
&gt;&gt;&gt; calc()
0
</code></pre>
<p>如果已经有一个list或者tuple，要调用一个可变参数，可以在list或tuple前面加一个<code>*</code>号，把list或tuple的元素变成可变参数传进去：</p>
<pre><code>&gt;&gt;&gt; nums = [1, 2, 3]
&gt;&gt;&gt; calc(*nums)
14
</code></pre>
<p><code>*nums</code>表示把nums这个list的所有元素作为可变参数传进去。</p>
<h3 id="关键字参数">关键字参数</h3>
<p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时<strong>自动组装为一个tuple</strong>。<br>
而关键字参数允许你传入<strong>0个或任意个</strong>含参数名的参数，这些关键字参数在函数内部<strong>自动组装为一个dict</strong>。</p>
<pre><code>def person(name, age, **kw):
    print('name:', name, 'age:', age, 'other:', kw)
</code></pre>
<p>函数person除了必选参数name和age外，还接受关键字参数kw。在调用该函数时，可以只传入必选参数：</p>
<pre><code>&gt;&gt;&gt; person('Michael', 30)
name: Michael age: 30 other: {}
</code></pre>
<p>也可以传入任意个数的关键字参数：</p>
<pre><code>&gt;&gt;&gt; person('Bob', 35, city='Beijing')
name: Bob age: 35 other: {'city': 'Beijing'}
&gt;&gt;&gt; person('Adam', 45, gender='M', job='Engineer')
name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}
</code></pre>
<p><strong>关键字参数可以扩展函数的功能</strong>。<br>
比如，在person函数里，我们保证能接收到name和age这两个参数，但是，<strong>如果调用者愿意提供更多的参数，我们也能收到</strong>。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。</p>
<p>和可变参数类似，<strong>也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去</strong></p>
<pre><code>&gt;&gt;&gt; extra = {'city': 'Beijing', 'job': 'Engineer'}
&gt;&gt;&gt; person('Jack', 24, city=extra['city'], job=extra['job'])
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
</code></pre>
<p>当然，上面复杂的调用可以用简化的写法：</p>
<pre><code>&gt;&gt;&gt; extra = {'city': 'Beijing', 'job': 'Engineer'}
&gt;&gt;&gt; person('Jack', 24, **extra)
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
</code></pre>
<p><code>**extra</code>表示把extra这个dict的所有key-value用关键字参数传入到函数的<code>**kw</code>参数，kw将获得一个dict，<strong>注意kw获得的dict是extra的一份拷贝</strong>，<strong>对kw的改动不会影响到函数外的extra</strong>。</p>
<h3 id="命名关键字参数">命名关键字参数</h3>
<p>对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过kw检查。</p>
<p>如果<strong>要限制关键字参数的名</strong>字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：</p>
<pre><code>def person(name, age, *, city, job):
    print(name, age, city, job)
</code></pre>
<p>和关键字参数<code>**kw</code>不同，命名关键字参数需要一个特殊分隔符<code>*</code>，<code>*</code>后面的参数被视为<strong>命名关键字参数</strong>。</p>
<p>如果函数定义中<strong>已经有了一个可变参数</strong>，<strong>后面跟着的命名关键字参数就不再需要一个特殊分隔符<code>*</code>了</strong>：</p>
<pre><code>def person(name, age, *args, city, job):
    print(name, age, args, city, job)
</code></pre>
<p><strong>命名关键字参数必须传入参数名</strong>，这和位置参数不同。<strong>如果没有传入参数名，调用将报错</strong>：</p>
<pre><code>&gt;&gt;&gt; person('Jack', 24, 'Beijing', 'Engineer')
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: person() takes 2 positional arguments but 4 were given
</code></pre>
<p>由于调用时缺少参数名city和job，Python解释器把这4个参数均视为位置参数，但person()函数仅接受2个位置参数。</p>
<p><strong>命名关键字参数可以有缺省值</strong>，从而简化调用：</p>
<pre><code>def person(name, age, *, city='Beijing', job):
    print(name, age, city, job)
</code></pre>
<p>由于<strong>命名关键字参数city具有默认值，调用时，可不传入city参数</strong>：</p>
<pre><code>&gt;&gt;&gt; person('Jack', 24, job='Engineer')
Jack 24 Beijing Engineer
</code></pre>
<p>使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个<code>*</code>作为特殊分隔符。如果缺少<code>*</code>，Python解释器将<strong>无法识别位置参数和命名关键字参数</strong>：</p>
<pre><code>def person(name, age, city, job):
    # 缺少 *，city和job被视为位置参数
    pass
</code></pre>
<h3 id="参数组合">参数组合</h3>
<p>在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，<strong>参数定义的顺序</strong>必须是：</p>
<ol>
<li>必选参数</li>
<li>默认参数</li>
<li>可变参数</li>
<li>命名关键字参数</li>
<li>关键字参数</li>
</ol>
<p>比如定义一个函数，包含上述若干种参数：</p>
<pre><code>def f1(a, b, c=0, *args, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)

def f2(a, b, c=0, *, d, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw)
</code></pre>
<p>在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。</p>
<pre><code>&gt;&gt;&gt; f1(1, 2)
a = 1 b = 2 c = 0 args = () kw = {}
&gt;&gt;&gt; f1(1, 2, c=3)
a = 1 b = 2 c = 3 args = () kw = {}
&gt;&gt;&gt; f1(1, 2, 3, 'a', 'b')
a = 1 b = 2 c = 3 args = ('a', 'b') kw = {}
&gt;&gt;&gt; f1(1, 2, 3, 'a', 'b', x=99)
a = 1 b = 2 c = 3 args = ('a', 'b') kw = {'x': 99}
&gt;&gt;&gt; f2(1, 2, d=99, ext=None)
a = 1 b = 2 c = 0 d = 99 kw = {'ext': None}
</code></pre>
<p><strong>最神奇的是通过一个tuple和dict，也可以调用上述函数</strong>：</p>
<pre><code>&gt;&gt;&gt; args = (1, 2, 3, 4)
&gt;&gt;&gt; kw = {'d': 99, 'x': '#'}
&gt;&gt;&gt; f1(*args, **kw)
a = 1 b = 2 c = 3 args = (4,) kw = {'d': 99, 'x': '#'}
&gt;&gt;&gt; args = (1, 2, 3)
&gt;&gt;&gt; kw = {'d': 88, 'x': '#'}
&gt;&gt;&gt; f2(*args, **kw)
a = 1 b = 2 c = 3 d = 88 kw = {'x': '#'}
</code></pre>
<p>所以，<strong>对于任意函数，都可以通过类似<code>func(*args, **kw)</code>的形式调用它，无论它的参数是如何定义的。</strong></p>
<p>虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。</p>
<h3 id="小结">小结</h3>
<p>Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。</p>
<p>默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！</p>
<p>要注意定义可变参数和关键字参数的语法：</p>
<p><code>*args</code>是可变参数，args接收的是一个tuple；</p>
<p><code>**kw</code>是关键字参数，kw接收的是一个dict。</p>
<p>以及调用函数时如何传入可变参数和关键字参数的语法：</p>
<p>可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过<code>*args</code>传入：<code>func(*(1, 2, 3))</code>；</p>
<p>关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过<code>**kw</code>传入：<code>func(**{'a': 1, 'b': 2})</code>。</p>
<p>使用<code>*args</code>和<code>**kw</code>是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。</p>
<p>命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。</p>
<p>定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。</p>
<h2 id="递归函数">递归函数</h2>
<p>在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。</p>
<p>来计算阶乘n! = 1 x 2 x 3 x ... x n，用函数fact(n)表示，可以看出：</p>
<p>fact(n) = n! = 1 x 2 x 3 x ... x (n-1) x n = (n-1)! x n = fact(n-1) x n</p>
<p>所以，fact(n)可以表示为n x fact(n-1)，只有n=1时需要特殊处理。</p>
<p>于是，fact(n)用递归的方式写出来就是：</p>
<pre><code>def fact(n):
    if n==1:
        return 1
    return n * fact(n - 1)
</code></pre>
<p>递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。</p>
<p>使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。</p>
<p><strong>解决递归调用栈溢出的方法是通过尾递归优化</strong>，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。</p>
<p>尾递归是指，<strong>在函数返回的时候，调用自身本身</strong>，并且，r<strong>eturn语句不能包含表达式</strong>。这样，<strong>编译器或者解释器就可以把尾递归做优化</strong>，使递归本身无论调用多少次，<strong>都只占用一个栈帧</strong>，不会出现栈溢出的情况。</p>
<p>上面的fact(n)函数由于return n * fact(n - 1)引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：</p>
<pre><code>def fact(n):
    return fact_iter(n, 1)

def fact_iter(num, product):
    if num == 1:
        return product
    return fact_iter(num - 1, num * product)
</code></pre>
<p><code>return fact_iter(num - 1, num * product)</code>仅返回递归函数本身，<code>num - 1</code>和<code>num * product</code>在函数调用前就会被计算，不影响函数调用。</p>
<p>尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。</p>
<p>遗憾的是，大多数编程语言没有针对尾递归做优化，Python标准的解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Python-哈希容器dict和set]]></title>
        <id>https://lixin-scut.github.io//post/python-ha-xi-rong-qi-dict-he-set</id>
        <link href="https://lixin-scut.github.io//post/python-ha-xi-rong-qi-dict-he-set">
        </link>
        <updated>2020-05-08T06:54:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="dict">dict</h2>
<p>Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。</p>
<p><strong>dict使用大括号初始化</strong></p>
<p>“名字”-“成绩”的对照表：</p>
<pre><code>&gt;&gt;&gt; d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}
&gt;&gt;&gt; d['Michael']
95
</code></pre>
<p>key-value存储方式，在放进去的时候，必须根据key算出value的存放位置，这样，取的时候才能根据key直接拿到value。</p>
<h3 id="元素操作">元素操作</h3>
<p>把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：</p>
<pre><code>&gt;&gt;&gt; d['Adam'] = 67
&gt;&gt;&gt; d['Adam']
67
</code></pre>
<p>由于一个key只能对应一个value，所以，<strong>多次对一个key放入value，后面的值会把前面的值冲掉</strong>：</p>
<pre><code>&gt;&gt;&gt; d['Jack'] = 90
&gt;&gt;&gt; d['Jack']
90
&gt;&gt;&gt; d['Jack'] = 88
&gt;&gt;&gt; d['Jack']
88
</code></pre>
<p><strong>如果key不存在，dict就会报错</strong>：</p>
<pre><code>&gt;&gt;&gt; d['Thomas']
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
KeyError: 'Thomas'
</code></pre>
<p>要避免key不存在的错误，有两种办法，一是<strong>通过in判断key是否存在</strong>：</p>
<blockquote>
<blockquote>
<blockquote>
<p>'Thomas' in d<br>
False<br>
二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的value：</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>d.get('Thomas')<br>
d.get('Thomas', -1)<br>
-1</p>
</blockquote>
</blockquote>
</blockquote>
<pre><code>注意：返回None的时候Python的交互环境不显示结果。
</code></pre>
<p>要删除一个key，用pop(key)方法，对应的value也会从dict中删除：</p>
<blockquote>
<blockquote>
<blockquote>
<p>d.pop('Bob')<br>
75</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>d<br>
{'Michael': 95, 'Tracy': 85}<br>
请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。</p>
</blockquote>
</blockquote>
</blockquote>
<p>和list比较，dict有以下几个特点：</p>
<ol>
<li>查找和插入的速度极快，不会随着key的增加而变慢；</li>
<li>需要<strong>占用大量的内存，内存浪费多</strong>。</li>
</ol>
<p>而list相反：</p>
<ol>
<li>查找和插入的时间随着元素的增加而增加；</li>
<li>占用空间小，浪费内存很少。<br>
所以，dict是用空间来换取时间的一种方法。</li>
</ol>
<p>dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是<strong>dict的key必须是不可变对象</strong>。</p>
<p>这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。</p>
<p>要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而<strong>list是可变的，就不能作为key</strong>：</p>
<pre><code>&gt;&gt;&gt; key = [1, 2, 3]
&gt;&gt;&gt; d[key] = 'a list'
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: unhashable type: 'list'
</code></pre>
<h2 id="set">set</h2>
<p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。</p>
<p>要创建一个set，需要提供一个list作为输入集合：</p>
<p><strong>set的初始化需要注明set()</strong></p>
<pre><code>&gt;&gt;&gt; s = set([1, 2, 3])
&gt;&gt;&gt; s
{1, 2, 3}
</code></pre>
<p>注意，<strong>传入的参数[1, 2, 3]是一个list</strong></p>
<p>由于哈希函数的原因，而显示的{1, 2, 3}只是告诉你这个set内部有1，2，3这3个元素，<strong>显示的顺序也不表示set是有序的</strong>。</p>
<p><strong>重复元素在set中自动被过滤</strong>：</p>
<pre><code>&gt;&gt;&gt; s = set([1, 1, 2, 2, 3, 3])
&gt;&gt;&gt; s
{1, 2, 3}
</code></pre>
<p><strong>添加元素add(key)</strong><br>
通过add(key)方法可以添加元素到set中，<strong>可以重复添加，但不会有效果</strong>：</p>
<pre><code>&gt;&gt;&gt; s.add(4)
&gt;&gt;&gt; s
{1, 2, 3, 4}
&gt;&gt;&gt; s.add(4)
&gt;&gt;&gt; s
{1, 2, 3, 4}
</code></pre>
<p><strong>删除元素remove(key)</strong><br>
通过remove(key)方法可以删除元素：</p>
<pre><code>&gt;&gt;&gt; s.remove(4)
&gt;&gt;&gt; s
{1, 2, 3}
</code></pre>
<p>set可以看成数学意义上的<strong>无序和无重复元素的集合</strong>，因此，两个set可以做<strong>数学意义上的交集、并集</strong>等操作：</p>
<pre><code>&gt;&gt;&gt; s1 = set([1, 2, 3])
&gt;&gt;&gt; s2 = set([2, 3, 4])
&gt;&gt;&gt; s1 &amp; s2
{2, 3}
&gt;&gt;&gt; s1 | s2
{1, 2, 3, 4}
</code></pre>
<p>set和dict的唯一区别仅在于没有存储对应的value，</p>
<p>但是，set的原理和dict一样，所以，<strong>同样不可以放入可变对象，因为无法判断两个可变对象是否相等</strong>，也就<strong>无法保证set内部“不会有重复元素”</strong>。</p>
<h2 id="不可变对象">不可变对象</h2>
<p>str是不变对象，而list是可变对象。</p>
<p>对于可变对象，比如list，对list进行操作，list内部的内容是会变化的，比如：</p>
<pre><code>&gt;&gt;&gt; a = ['c', 'b', 'a']
&gt;&gt;&gt; a.sort()
&gt;&gt;&gt; a
['a', 'b', 'c']
</code></pre>
<p>而对于不可变对象，比如str，对str进行操作呢：</p>
<pre><code>&gt;&gt;&gt; a = 'abc'
&gt;&gt;&gt; a.replace('a', 'A')
'Abc'
&gt;&gt;&gt; a
'abc'
</code></pre>
<p>虽然字符串有个replace()方法，也确实变出了<code>'Abc'</code>，但变量a最后仍是<code>'abc'</code></p>
<p>要始终牢记的是，<strong>a是变量，而'abc'才是字符串对象</strong>！<br>
有些时候，我们经常说，对象a的内容是'abc'，但其实是指，a本身是一个变量，它指向的对象的内容才是'abc'</p>
<p>当我们调用<code>a.replace('a', 'A')</code>时，实际上调用方法replace是<strong>作用在字符串对象'abc'上的</strong>，而这个方法虽然名字叫replace，但却没有改变字符串'abc'的内容。相反，replace方法<strong>创建了一个新字符串'Abc'并返回</strong>，如果我们用变量b指向该新字符串，就容易理解了，变量a仍指向原有的字符串'abc'，但变量b却指向新字符串'Abc'了：</p>
<p>所以，对于不变对象来说，<strong>调用对象自身的任意方法，也不会改变该对象自身的内容</strong>。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python-条件语句与循环语句]]></title>
        <id>https://lixin-scut.github.io//post/python-tiao-jian-yu-ju-yu-xun-huan-yu-ju</id>
        <link href="https://lixin-scut.github.io//post/python-tiao-jian-yu-ju-yu-xun-huan-yu-ju">
        </link>
        <updated>2020-05-08T03:12:44.000Z</updated>
        <content type="html"><![CDATA[<h3 id="条件判断">条件判断</h3>
<p>做条件判断在Python程序中，用if语句实现</p>
<p><strong>if语句的完整形式</strong>就是：</p>
<pre><code>if &lt;条件判断1&gt;:
    &lt;执行1&gt;
elif &lt;条件判断2&gt;:
    &lt;执行2&gt;
elif &lt;条件判断3&gt;:
    &lt;执行3&gt;
else:
    &lt;执行4&gt;
</code></pre>
<p>例子：</p>
<pre><code>age = 20
if age &gt;= 18:
    print('your age is', age)
    print('adult')
</code></pre>
<p>根据Python的缩进规则，如果if语句判断是True，就把缩进的两行print语句执行了，否则，什么也不做。</p>
<p>也可以给if添加一个<strong>else语句</strong>，意思是，如果if判断是False，不要执行if的内容，去把else执行了：</p>
<pre><code>age = 3
if age &gt;= 18:
    print('your age is', age)
    print('adult')
else:
    print('your age is', age)
    print('teenager')
</code></pre>
<p>注意<strong>不要少写了冒号:</strong>。</p>
<p>当然上面的判断是很粗略的，完全可以<strong>用elif做更细致的判断</strong>：</p>
<pre><code>age = 3
if age &gt;= 18:
    print('adult')
elif age &gt;= 6:
    print('teenager')
else:
    print('kid')
</code></pre>
<p>elif是else if的缩写，完全可以有多个elif</p>
<p>if判断条件还可以简写，比如写：</p>
<pre><code>if x:
    print('True')
</code></pre>
<p>只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False。</p>
<h3 id="if中的input与类型转换">if中的input与类型转换</h3>
<p>当我们希望用input()读取用户的输入，再进行判断时，容易出现类型问题：</p>
<pre><code>birth = input('birth: ')
if birth &lt; 2000:
    print('00前')
else:
    print('00后')
</code></pre>
<p>输入1982，结果报错：</p>
<pre><code>Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: unorderable types: str() &gt; int()
</code></pre>
<p>这是<strong>因为input()返回的数据类型是str</strong>，<strong>str不能直接和整数比较</strong></p>
<p>必须先把str转换成整数。Python提供了<strong>int()函数</strong>来完成这件事情：</p>
<pre><code>s = input('birth: ')
birth = int(s)
if birth &lt; 2000:
    print('00前')
else:
    print('00后')
</code></pre>
<p>再次运行，就可以得到正确地结果。但是，如果输入abc呢？又会得到一个错误信息：</p>
<pre><code>Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
ValueError: invalid literal for int() with base 10: 'abc'
</code></pre>
<p>int()函数发现一个字符串并不是合法的数字时就会报错，程序就退出了。</p>
<h2 id="循环">循环</h2>
<h3 id="for-x-in">for x in ...</h3>
<p>for x in ...循环就是把每个元素代入变量x，然后执行缩进块的语句。</p>
<pre><code>比如我们想计算1-100的整数之和，可以用一个sum变量做累加，Python提供一个range()函数，可以生成一个整数序列，：
</code></pre>
<pre><code>sum = 0
# for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ..., 100]:
for x in range(100):
    sum = sum + x
print(sum)
</code></pre>
<p>range()函数再通过list()函数可以转换为list。比如range(5)生成的序列是从0开始小于5的整数</p>
<pre><code>&gt;&gt;&gt; list(range(5))
[0, 1, 2, 3, 4]
</code></pre>
<h3 id="while循环">while循环</h3>
<p>只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：</p>
<pre><code>sum = 0
n = 99
while n &gt; 0:
    sum = sum + n
    n = n - 2
print(sum)
</code></pre>
<p>在循环内部变量n不断自减，直到变为-1时，不再满足while条件，循环退出。</p>
<h3 id="break">break</h3>
<p>在循环中，break语句可以提前退出循环。</p>
<pre><code>n = 1
while n &lt;= 100:
    if n &gt; 10: # 当n = 11时，条件满足，执行break语句
        break # break语句会结束当前循环
    print(n)
    n = n + 1
print('END')
</code></pre>
<h3 id="continue">continue</h3>
<p>在循环过程中，也可以通过continue语句，跳过当前的这次循环，直接开始下一次循环。</p>
<pre><code>n = 0
while n &lt; 10:
    n = n + 1
    if n % 2 == 0: # 如果n是偶数，执行continue语句
        continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行
    print(n)
</code></pre>
<h3 id="小结">小结</h3>
<p>循环是让计算机做重复任务的有效的方法。</p>
<p>break语句可以在循环过程中直接退出循环，而continue语句可以提前结束本轮循环，并直接开始下一轮循环。这两个语句通常都必须配合if语句使用。</p>
<p>要特别注意，<strong>不要滥用break和continue语句</strong>。break和continue会造成代码执行逻辑分叉过多，容易出错。<strong>大多数循环并不需要用到break和continue语句</strong>，上面的两个例子，都可以<strong>通过改写循环条件或者修改循环逻辑，去掉break和continue语句</strong>。</p>
<p>有些时候，如果代码写得有问题，会让程序陷入“死循环”，也就是永远循环下去。这时可以用Ctrl+C退出程序，或者强制结束Python进程。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Python-使用list和tuple]]></title>
        <id>https://lixin-scut.github.io//post/python-shi-yong-list-he-tuple</id>
        <link href="https://lixin-scut.github.io//post/python-shi-yong-list-he-tuple">
        </link>
        <updated>2020-05-08T02:32:29.000Z</updated>
        <content type="html"><![CDATA[<h2 id="list">list</h2>
<p>Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。</p>
<h3 id="list初始化与赋值"><strong>list初始化与赋值</strong></h3>
<p>比如，列出班里所有同学的名字，就可以用一个list表示：</p>
<pre><code>&gt;&gt;&gt; classmates = ['Michael', 'Bob', 'Tracy']
&gt;&gt;&gt; classmates
['Michael', 'Bob', 'Tracy']
</code></pre>
<h3 id="list长度len"><strong>list长度：len()</strong></h3>
<p>变量classmates就是一个list。<strong>用len()函数可以获得list元素的个数</strong>：</p>
<pre><code>&gt;&gt;&gt; len(classmates)
3
</code></pre>
<h3 id="元素增删查改">元素增删查改</h3>
<p><strong>list的索引访问</strong><br>
用索引来访问list中每一个位置的元素，记得索引是从0开始的：</p>
<pre><code>&gt;&gt;&gt; classmates[0]
'Michael'
&gt;&gt;&gt; classmates[1]
'Bob'
&gt;&gt;&gt; classmates[2]
'Tracy'
&gt;&gt;&gt; classmates[3]
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
IndexError: list index out of range
</code></pre>
<p>当索引超出了范围时，Python会报一个IndexError错误，所以，要确保索引不要越界，<br>
最后一个元素的索引是len(classmates) - 1。</p>
<h3 id="负数索引"><strong>负数索引</strong></h3>
<p>如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素：</p>
<pre><code>&gt;&gt;&gt; classmates[-1]
'Tracy'
</code></pre>
<p>以此类推，可以获取倒数第2个、倒数第3个：</p>
<pre><code>&gt;&gt;&gt; classmates[-2]
'Bob'
&gt;&gt;&gt; classmates[-3]
'Michael'
&gt;&gt;&gt; classmates[-4]
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
IndexError: list index out of range
</code></pre>
<p>注意倒数索引也会越界</p>
<p><strong>append()</strong>:list是一个可变的有序表，所以，可以往list中追加元素到末尾：</p>
<pre><code>&gt;&gt;&gt; classmates.append('Adam')
&gt;&gt;&gt; classmates
['Michael', 'Bob', 'Tracy', 'Adam']
</code></pre>
<p><strong>insert()</strong>:也可以把元素插入到指定的位置，比如索引号为1的位置：</p>
<pre><code>&gt;&gt;&gt; classmates.insert(1, 'Jack')
&gt;&gt;&gt; classmates
['Michael', 'Jack', 'Bob', 'Tracy', 'Adam']
</code></pre>
<p><strong>pop()</strong>:要删除list末尾的元素，用pop()方法：</p>
<pre><code>&gt;&gt;&gt; classmates.pop()
'Adam'
&gt;&gt;&gt; classmates
['Michael', 'Jack', 'Bob', 'Tracy']
</code></pre>
<p><strong>pop(i)</strong>:要删除指定位置的元素，用pop(i)方法，其中i是索引位置：</p>
<pre><code>&gt;&gt;&gt; classmates.pop(1)
'Jack'
&gt;&gt;&gt; classmates
['Michael', 'Bob', 'Tracy']
</code></pre>
<p><strong>赋值</strong>：要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：</p>
<pre><code>&gt;&gt;&gt; classmates[1] = 'Sarah'
&gt;&gt;&gt; classmates
['Michael', 'Sarah', 'Tracy']
</code></pre>
<p>list里面的<strong>元素的数据类型也可以不同</strong>，比如：</p>
<pre><code>&gt;&gt;&gt; L = ['Apple', 123, True]
</code></pre>
<h3 id="list嵌套">list嵌套</h3>
<p>ist元素中可以嵌套另一个list，比如：</p>
<pre><code>&gt;&gt;&gt; s = ['python', 'java', ['asp', 'php'], 'scheme']
&gt;&gt;&gt; len(s)
4
</code></pre>
<p>要注意s只有4个元素，其中s[2]又是一个list</p>
<p><strong>同时注意可以直接用list名进行list嵌套</strong></p>
<pre><code>&gt;&gt;&gt; p = ['asp', 'php']
&gt;&gt;&gt; s = ['python', 'java', p, 'scheme'] 
</code></pre>
<p><strong>多维索引</strong><br>
要拿到'php'可以写p[1]或者s[2][1]，因此s可以看成是一个二维数组，类似的还有三维、四维……数组。</p>
<h3 id="空list"><strong>空list</strong></h3>
<p>如果一个list中一个元素也没有，就是一个空的list，它的长度为0：</p>
<pre><code>&gt;&gt;&gt; L = []
&gt;&gt;&gt; len(L)
0
</code></pre>
<h2 id="tuple">tuple</h2>
<p>另一种有序列表叫元组：tuple。tuple和list非常类似，<strong>但是tuple一旦初始化就不能修改</strong></p>
<p><strong>tuple使用小括号定义，list使用中括号定义</strong></p>
<p>tuple没有<strong>append()，insert()</strong> 这样的方法，但也不能赋值成另外的元素。<br>
其他获取元素的方法和list是一样的，可以正常地使用classmates[0]，classmates[-1]，但</p>
<p>不可变的tuple的意义：因为<strong>tuple不可变，所以代码更安全</strong>。<br>
<strong>如果可能，能用tuple代替list就尽量用tuple。</strong></p>
<p><strong>定义tuple</strong><br>
tuple的陷阱：当你定义一个tuple时，<strong>在定义的时候，tuple的元素就必须被确定下来，</strong> 比如：</p>
<pre><code>&gt;&gt;&gt; t = (1, 2)
&gt;&gt;&gt; t
(1, 2)
</code></pre>
<p><strong>定义一个空的tuple</strong><br>
如果要定义一个空的tuple，可以写成()：</p>
<pre><code>&gt;&gt;&gt; t = ()
&gt;&gt;&gt; t
()
</code></pre>
<p><strong>定义一个只有1个元素的tuple</strong><br>
但是，要定义一个只有1个元素的tuple，如果你这么定义：</p>
<pre><code>&gt;&gt;&gt; t = (1)
&gt;&gt;&gt; t
1
</code></pre>
<p><strong>定义的不是tuple，是1这个数！</strong><br>
<strong>注意，变成了一个整数！</strong></p>
<p>这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，<strong>Python规定，这种情况下，按小括号进行计算，计算结果自然是1</strong>。</p>
<p>所以，<strong>只有1个元素的tuple定义时必须加一个逗号<code>,</code>，来消除歧义</strong>：</p>
<pre><code>&gt;&gt;&gt; t = (1,)
&gt;&gt;&gt; t
(1,)
</code></pre>
<p>Python在显示只有1个元素的tuple时，也会加一个逗号,，以免你误解成数学计算意义上的括号。</p>
<p><strong>“可变的”tuple</strong></p>
<pre><code>&gt;&gt;&gt; t = ('a', 'b', ['A', 'B'])
&gt;&gt;&gt; t[2][0] = 'X'
&gt;&gt;&gt; t[2][1] = 'Y'
&gt;&gt;&gt; t
('a', 'b', ['X', 'Y'])
</code></pre>
<p>这个tuple定义的时候有3个元素，分别是'a'，'b'和一个list。</p>
<p>表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。tuple一开始指向的list并没有改成别的list<br>
<strong>所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变</strong>。即指向'a'，就不能改成指向'b'，指向一个list，就不能改成指向其他对象，<strong>但指向的这个list本身是可变的</strong>！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python-字符串和编码]]></title>
        <id>https://lixin-scut.github.io//post/python-zi-fu-chuan-he-bian-ma</id>
        <link href="https://lixin-scut.github.io//post/python-zi-fu-chuan-he-bian-ma">
        </link>
        <updated>2020-05-08T02:04:56.000Z</updated>
        <content type="html"><![CDATA[<h3 id="字符编码">字符编码</h3>
<p>字符串也是一种数据类型，但是，字符串比较特殊的是还有一个编码问题。</p>
<p>因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是65535，4个字节可以表示的最大整数是4294967295。</p>
<p>由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。</p>
<p>但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。</p>
<p>全世界有上百种语言，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。</p>
<p>因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。</p>
<h3 id="unicode">Unicode</h3>
<p>Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。</p>
<p>ASCII编码和Unicode编码的区别：<strong>ASCII编码是1个字节</strong>，而<strong>Unicode编码通常是2个字节</strong>。</p>
<p>新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。</p>
<p>所以又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。<strong>UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节</strong>，常用的<strong>英文字母被编码成1个字节</strong>，<strong>汉字通常是3个字节</strong>，只有<strong>很生僻的字符才会被编码成4-6个字节</strong>。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间</p>
<p>UTF-8编码有一个额外的好处，就是兼容性，<strong>ASCII编码实际上可以被看成是UTF-8编码的一部分</strong>，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作</p>
<p>现在计算机系统通用的字符编码工作方式：</p>
<ol>
<li>
<p>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。</p>
</li>
<li>
<p>用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件</p>
</li>
</ol>
<h3 id="python的字符串">Python的字符串</h3>
<p>在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言，可以直接print中文</p>
<p>对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符：</p>
<pre><code>&gt;&gt;&gt; ord('A')
65
&gt;&gt;&gt; ord('中')
20013
&gt;&gt;&gt; chr(66)
'B'
&gt;&gt;&gt; chr(25991)
'文'
</code></pre>
<p>如果知道字符的整数编码，还可以用十六进制这么写str：</p>
<pre><code>&gt;&gt;&gt; '\u4e2d\u6587'
'中文'
两种写法完全是等价的。
</code></pre>
<p>由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。</p>
<p>Python对bytes类型的数据用带b前缀的单引号或双引号表示：</p>
<pre><code>x = b'ABC'
</code></pre>
<p>要注意区分'ABC'和b'ABC'，前者是str，后者虽然内容显示得和前者一样，但<strong>bytes的每个字符都只占用一个字节</strong>。</p>
<p>以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如：</p>
<pre><code>&gt;&gt;&gt; 'ABC'.encode('ascii')
b'ABC'
&gt;&gt;&gt; '中文'.encode('utf-8')
b'\xe4\xb8\xad\xe6\x96\x87'
&gt;&gt;&gt; '中文'.encode('ascii')
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)
</code></pre>
<p>纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。</p>
<pre><code>&gt;&gt;&gt; b'ABC'.decode('ascii')
'ABC'
&gt;&gt;&gt; b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8')
'中文'
</code></pre>
<p>如果bytes中包含无法解码的字节，decode()方法会报错<br>
如果bytes中只有一小部分无效的字节，可以传入errors='ignore'忽略错误的字节</p>
<p>要计算<strong>str包含多少个字符</strong>，可以用<strong>len()函数</strong>：</p>
<pre><code>&gt;&gt;&gt; len('ABC')
3
&gt;&gt;&gt; len('中文')
2
</code></pre>
<p>len()函数计算的是str的字符数，如果<strong>换成bytes，len()函数就计算字节数</strong>：</p>
<pre><code>&gt;&gt;&gt; len(b'ABC')
3
&gt;&gt;&gt; len(b'\xe4\xb8\xad\xe6\x96\x87')
6
&gt;&gt;&gt; len('中文'.encode('utf-8'))
6
</code></pre>
<p>可见，1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。</p>
<p>在操作字符串时，我们经常遇到str和bytes的互相转换。为了避免乱码问题，应当<strong>始终坚持使用UTF-8编码对str和bytes进行转换</strong>。</p>
<p>由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，<strong>在保存源代码时，就需要务必指定保存为UTF-8编码</strong>。</p>
<p>当Python解释器读取源代码时，<strong>为了让它按UTF-8编码读取，我们通常在文件开头写上这两行</strong>：</p>
<pre><code>#!/usr/bin/env python3
# -*- coding: utf-8 -*-
</code></pre>
<p>第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；</p>
<p>第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。</p>
<p>申明了UTF-8编码<strong>并不意味着你的.py文件就是UTF-8编码的</strong>，必须并且<strong>要确保文本编辑器正在使用UTF-8 without BOM编码</strong></p>
<h3 id="字符串格式化">字符串格式化</h3>
<p>在Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下：</p>
<pre><code>&gt;&gt;&gt; 'Hello, %s' % 'world'
'Hello, world'
&gt;&gt;&gt; 'Hi, %s, you have $%d.' % ('Michael', 1000000)
'Hi, Michael, you have $1000000.'
</code></pre>
<p>在字符串内部，%s表示用字符串替换，%d表示用整数替换<br>
<strong>有几个%?占位符，后面就跟几个变量或者值</strong>，顺序要对应好。<br>
<strong>如果只有一个%?，括号可以省略</strong>。</p>
<p>常见的占位符有：</p>
<table>
<thead>
<tr>
<th style="text-align:center">占位符</th>
<th style="text-align:center">替换内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">%d</td>
<td style="text-align:center">整数</td>
</tr>
<tr>
<td style="text-align:center">%f</td>
<td style="text-align:center">浮点数</td>
</tr>
<tr>
<td style="text-align:center">%s</td>
<td style="text-align:center">字符串</td>
</tr>
<tr>
<td style="text-align:center">%x</td>
<td style="text-align:center">十六进制整数</td>
</tr>
</tbody>
</table>
<p>其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数</p>
<pre><code>&gt;&gt;&gt; print('%2d-%02d' % (3, 1))
3-01 
&gt;&gt;&gt; print('%.2f' % 3.1415926)
3.14 
</code></pre>
<p>%s永远起作用，它会把<strong>任何数据类型转换为字符串</strong>：</p>
<pre><code>&gt;&gt;&gt; 'Age: %s. Gender: %s' % (25, True)
'Age: 25. Gender: True'
</code></pre>
<p>如果字符串里面的%是一个普通字符就需要转义，<strong>用%%来表示一个%</strong>：</p>
<pre><code>&gt;&gt;&gt; 'growth rate: %d %%' % 7
'growth rate: 7 %'
</code></pre>
<p><strong>format()</strong></p>
<p>另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……，不过这种方式写起来比%要麻烦得多：</p>
<blockquote>
<blockquote>
<blockquote>
<p>'Hello, {0}, 成绩提升了 {1:.1f}%'.format('小明', 17.125)<br>
'Hello, 小明, 成绩提升了 17.1%'</p>
</blockquote>
</blockquote>
</blockquote>
]]></content>
    </entry>
</feed>