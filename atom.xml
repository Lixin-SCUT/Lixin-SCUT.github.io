<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-03-30T15:20:02.246Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>千里之行，始于足下。不积跬步，无以至千里。</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[C++中各种类型表示范围测试代码（最大最小值）]]></title>
        <id>https://lixin-scut.github.io//post/czhong-ge-chong-lei-xing-biao-shi-fan-wei-ce-shi-dai-ma-zui-da-zui-xiao-zhi</id>
        <link href="https://lixin-scut.github.io//post/czhong-ge-chong-lei-xing-biao-shi-fan-wei-ce-shi-dai-ma-zui-da-zui-xiao-zhi">
        </link>
        <updated>2020-03-29T03:00:43.000Z</updated>
        <content type="html"><![CDATA[<p>不同的机器上可以所占的字节数和可以表示的范围不尽相同<br>
特别是32位和64位之差。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include &lt;limits&gt;
using namespace std;

int main()
{
    cout &lt;&lt; &quot;type: \t\t&quot; &lt;&lt; &quot;************size**************&quot;&lt;&lt; endl;
    cout &lt;&lt; &quot;bool: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(bool);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;bool&gt;::max)();
    cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;bool&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;char: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(char);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;char&gt;::max)();
    cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;char&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;signed char: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(signed char);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;signed char&gt;::max)();
    cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;signed char&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;unsigned char: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(unsigned char);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;unsigned char&gt;::max)();
    cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;unsigned char&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;wchar_t: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(wchar_t);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;wchar_t&gt;::max)();
    cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;wchar_t&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;short: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(short);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;short&gt;::max)();
    cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;short&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;int: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(int);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;int&gt;::max)();
    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;int&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;unsigned: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(unsigned);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;unsigned&gt;::max)();
    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;unsigned&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;long: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(long);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;long&gt;::max)();
    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;long&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;unsigned long: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(unsigned long);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;unsigned long&gt;::max)();
    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;unsigned long&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;double: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(double);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;double&gt;::max)();
    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;double&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;long double: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(long double);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;long double&gt;::max)();
    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;long double&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;float: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(float);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;float&gt;::max)();
    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;float&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;size_t: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(size_t);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;size_t&gt;::max)();
    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;size_t&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;string: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(string) &lt;&lt; endl;
    // &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;string&gt;::max)() &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;string&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;type: \t\t&quot; &lt;&lt; &quot;************size**************&quot;&lt;&lt; endl;
    return 0;
}
</code></pre>
<p>64位macOS下Clion输出结果</p>
<pre><code>type: 		************size**************
bool: 		所占字节数：1	最大值：1		最小值：0
char: 		所占字节数：1	最大值：		最小值：�
signed char: 	所占字节数：1	最大值：		最小值：�
unsigned char: 	所占字节数：1	最大值：�		最小值：�
wchar_t: 	所占字节数：4	最大值：2147483647		最小值：-2147483648
short: 		所占字节数：2	最大值：32767		最小值：-32768
int: 		所占字节数：4	最大值：2147483647	最小值：-2147483648
unsigned: 	所占字节数：4	最大值：4294967295	最小值：0
long: 		所占字节数：8	最大值：9223372036854775807	最小值：-9223372036854775808
unsigned long: 	所占字节数：8	最大值：18446744073709551615	最小值：0
double: 	所占字节数：8	最大值：1.79769e+308	最小值：2.22507e-308
long double: 	所占字节数：16	最大值：1.18973e+4932	最小值：3.3621e-4932
float: 		所占字节数：4	最大值：3.40282e+38	最小值：1.17549e-38
size_t: 	所占字节数：8	最大值：18446744073709551615	最小值：0
string: 	所占字节数：32
type: 		************size**************

Process finished with exit code 0

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 377. 组合总和 Ⅳ[中等]]]></title>
        <id>https://lixin-scut.github.io//post/dong-tai-gui-hua-377-zu-he-zong-he-ivzhong-deng</id>
        <link href="https://lixin-scut.github.io//post/dong-tai-gui-hua-377-zu-he-zong-he-ivzhong-deng">
        </link>
        <updated>2020-03-29T02:46:17.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。<br>
示例:<br>
nums = [1, 2, 3]<br>
target = 4<br>
所有可能的组合为：<br>
(1, 1, 1, 1)<br>
(1, 1, 2)<br>
(1, 2, 1)<br>
(1, 3)<br>
(2, 1, 1)<br>
(2, 2)<br>
(3, 1)<br>
请注意，顺序不同的序列被视作不同的组合。<br>
因此输出为 7。<br>
进阶：<br>
如果给定的数组中含有负数会怎么样？<br>
问题会产生什么变化？<br>
我们需要在题目中添加什么限制来允许负数的出现？</p>
</blockquote>
<p>这道题也好像斐波那契<br>
就是把每个数存在的情况加起来<br>
重点就在于顺序不同的序列被当成不同的组合<br>
它的类似题目是<br>
<a href="https://lixin-scut.github.io/post/dong-tai-gui-hua-322-ling-qian-dui-huan-zhong-deng/">动态规划 322. 零钱兑换[中等]</a><br>
这里的区别是计算可以凑成目标值所需的最少的数字个数<br>
<a href="https://lixin-scut.github.io/post/dong-tai-gui-hua-518-ling-qian-dui-huan-iizhong-deng-wei-zuo-chu/">动态规划 518. 零钱兑换 II[中等][未做出]</a><br>
这里的区别是只考虑组合不考虑排列，顺序不同的序列被当成相同的组合</p>
<p>尴尬，超时了。。。<br>
有一个问题是有些情况根本达不到的，但是却会导致超级大的数。<br>
然后必须用unsigned int来定义容器类型<br>
但是我用long就还是会爆炸。。。以后得找一下原因</p>
<pre><code>class Solution {
public:
    int combinationSum4(vector&lt;int&gt;&amp; nums, int target) {
        if(0 == target)
        {   return 1;}
        if(nums.empty())
        {   return 0;}
        
        vector&lt;unsigned int&gt; counts(target + 1, 0);
        counts[0] = 1;
        for(int i = 1; i &lt; target + 1; ++i)
        {
            for(auto num : nums)
            {
                if(num &lt;= i)
                {
                     counts[i] +=  counts[i - num]; 
                    //counts[i] = (counts[i] &gt;= INT_MAX - counts[i - num])? 
                    //    INT_MAX : counts[i] + counts[i - num];
                }
            }
        }
        return counts.back();
    }
};
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>题意分析：<br>
输入数组的每个元素可以使用多次，这一点和「完全背包」问题有点像；<br>
顺序不同的序列被视作不同的组合，这一点和所有的「背包问题」都不同，与 518. 零钱兑换 II 问题不同的地方就在这一点。<br>
思路分析：<br>
遇到这一类问题，做一件事情有很多种做法，每一种做法有若干个步骤，脑子里能想到的常规思路大概有「回溯搜索」、「动态规划」；<br>
由于不用得到具体的组合表示，因此考虑使用「动态规划」来解。<br>
https://pic.leetcode-cn.com/fa278029267fedeb06686b784bd322f16b2abf6b61987dc3b5257630570cd38f-377-1.png<br>
很容易发现「重复问题」，因此，我们可以使用「动态规划」来做，如果题目问具体的解，那么用「回溯搜索」做（「力扣」第 39 题：组合之和）。<br>
递归求解：由于有大量「重复子问题」，因此必须使用缓存，以避免相同问题重复求解，这个方法叫「记忆化搜索」，在《算法导论》这本书上也把它归入到「动态规划」的定义中。这种思考问题的方式是「从上到下」的，直接面对问题求解，遇到什么问题，就解决什么问题，同时记住结果；<br>
「动态规划」告诉了我们另一种思考问题的方式：「从底向上」，可以不直接面对问题求解，从这个问题最小的样子开始，通过逐步递推，至到得到所求的问题的答案。<br>
虽然这个问题没有明显的「最优子结构」，但这种「从底向上」递推的思路是很深刻的，我们也把它归纳到「动态规划」的解法中。</p>
</blockquote>
<blockquote>
<p>方法：动态规划<br>
“动态规划”的两个步骤是思考“状态”以及“状态转移方程”。<br>
1、状态<br>
对于“状态”，我们首先思考能不能就用问题当中问的方式定义状态，上面递归树都画出来了。当然就用问题问的方式。<br>
dp[i] ：对于给定的由正整数组成且不存在重复数字的数组，和为 i 的组合的个数。<br>
思考输出什么？因为状态就是问题当中问的方式而定义的，因此输出就是最后一个状态 dp[n]。<br>
2、状态转移方程<br>
由上面的树形图，可以很容易地写出状态转移方程：<br>
dp[i] = sum{dp[i - num] for num in nums and if i &gt;= num}<br>
注意：在 0 这一点，我们定义 dp[0] = 1 的，它表示如果 nums 里有一个数恰好等于 target，它单独成为 1 种可能。<br>
参考代码：</p>
</blockquote>
<pre><code>Java
public class Solution {

    /**
     * 这里状态定义就是题目要求的，并不难，状态转移方程要动点脑子，也不难：
     * 状态转移方程：dp[i]= dp[i - nums[0]] + dp[i - nums[1]] + dp[i - nums[2]] + ... （当 [] 里面的数 &gt;= 0）
     * 特别注意：dp[0] = 1，表示，如果那个硬币的面值刚刚好等于需要凑出的价值，这个就成为 1 种组合方案
     * 再举一个具体的例子：nums=[1, 3, 4], target=7;
     * dp[7] = dp[6] + dp[4] + dp[3]
     * 即：7 的组合数可以由三部分组成，1 和 dp[6]，3 和 dp[4], 4 和dp[3];
     *
     * @param nums
     * @param target
     * @return
     */
    public int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target + 1];
        // 这个值被其它状态参考，设置为 1 是合理的
        dp[0] = 1;

        for (int i = 1; i &lt;= target; i++) {
            for (int num : nums) {
                if (num &lt;= i) {
                    dp[i] += dp[i - num];
                }
            }
        }
        return dp[target];
    }
}
</code></pre>
<blockquote>
<p>对于进阶问题的思考<br>
1、如果给定的数组中含有负数会怎么样？问题会产生什么变化？<br>
如果有负数，相当于给定数组中的元素有了更多的组合，特别是出现了一对相反数的时候，例如题目中的示例 [-4, 1, 2, 3, 4]，target = 4 的时候，-4 和 4 可以无限次地、成对添加到题目中的示例中，成为新的组合，那么这道问题就没有什么意义了。<br>
仔细思考，负数我只要不选它就行了。但由于这道问题的问法是“组合”，因此我们要保证有负数参与进来，不能够与已有的正数的组合之和为 0 即可。<br>
2、我们需要在题目中添加什么限制来允许负数的出现？<br>
如果有负数参与进来，不能够与已有的正数的组合之和为 0 ；<br>
或者限制负数的使用次数，设计成类似 0-1 背包问题的样子。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 139. 单词拆分[中等][未做出]]]></title>
        <id>https://lixin-scut.github.io//post/dong-tai-gui-hua-139-dan-ci-chai-fen-zhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/dong-tai-gui-hua-139-dan-ci-chai-fen-zhong-deng-wei-zuo-chu">
        </link>
        <updated>2020-03-28T05:18:36.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。<br>
说明：<br>
拆分时可以重复使用字典中的单词。<br>
你可以假设字典中没有重复的单词。<br>
示例 1：<br>
输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]<br>
输出: true<br>
解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。<br>
示例 2：<br>
输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]<br>
输出: true<br>
解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。<br>
     注意你可以重复使用字典中的单词。<br>
示例 3：<br>
输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]<br>
输出: false</p>
</blockquote>
<p>一开始是想到了暴力法和回溯法的，但是一直纠结于动态规划法，所以最后还是先看了题解<br>
官方题解中的动态其实更像回溯法的迭代版，网友的更像动态规划法，利用boolean数组保存了状态，减少了一个循环</p>
<pre><code>class Solution {
public:
    // 动态规划法
    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict)
{
    int len = s.size();
    vector&lt;bool&gt; wordInclude(len + 1, false);
    wordInclude[0] = true;
    
    for(int i = 1; i &lt;= len; ++i)
    {
        for(string str : wordDict)
        {
            if(i &gt;= str.size() &amp;&amp; str == s.substr(i-str.size(), str.size()))
            {
                wordInclude[i] = wordInclude[i] || wordInclude[i - str.size()];
            } 
        }
    }
    
    return wordInclude.back();
}
 
    /*
    // 回溯法
    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict)
    {
        vector&lt;int&gt; wordInclude(s.size(), -1);
        unordered_set&lt;string&gt; dictSet;
        for(string str : wordDict)
        {
            dictSet.insert(str);
        }
        return wordBreak(s, dictSet, 0, wordInclude);
    }
    
    bool wordBreak(string s, unordered_set&lt;string&gt;&amp; dictSet, int beg, vector&lt;int&gt;&amp; wordInclude)
    {
        if(beg == s.size())
        {
            return true;
        }
        if(wordInclude[beg] != -1)
        {
            return wordInclude[beg];
        }
        for(int end = beg + 1; end &lt;= s.size(); ++end)
        {
            if(dictSet.count(s.substr(beg, end - beg)) &amp;&amp; wordBreak(s, dictSet, end, wordInclude));
            {
                wordInclude[beg] = 1;
                return true;
            }
        }
        wordInclude[beg] = 0;
        return false;
    }
    
    
    // 回溯法（迭代版）
    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict)
    {
        unordered_set&lt;string&gt; dictSet;
        for(string str : wordDict)
        {
            dictSet.insert(str);
        }
        int len = s.size();
        vector&lt;bool&gt; wordInclude(len + 1, false);
        wordInclude[0] = true;
        for(int end = 1; end &lt;= len; ++end)
        {
            for(int beg = 0; beg &lt; end; ++beg)
            {
                if(wordInclude[beg] &amp;&amp; dictSet.count(s.substr(beg, end - beg)))
                {
                    wordInclude[end] = true;
                    break;
                }
            }
        }
        return wordInclude.back();
    }
    */
};
</code></pre>
<p>网友题解：</p>
<pre><code>    
    class Solution {
    public boolean wordBreak(String s, List&lt;String&gt; wordDict) {
        int n = s.length();
        boolean [] dp = new boolean [n+1];
        dp[0]=true;

             for(int i=1;i&lt;=n;i++){
              for(String word:wordDict){//求解顺序完全背包问题对物品的迭代应该放在里层
                     int w = word.length();
                 if(i&gt;=w&amp;&amp;word.equals(s.substring(i-w,i))){
                     dp[i]=dp[i]||dp[i-w];
                 }
             }
         }
        return dp[n];
    }
}

</code></pre>
<p>官方题解：<br>
方法 1：暴力</p>
<blockquote>
<p>算法<br>
最简单的实现方法是用递归和回溯。为了找到解，我们可以检查字典单词中每一个单词的可能前缀，如果在字典中出现过，那么去掉这个前缀后剩余部分回归调用。同时，如果某次函数调用中发现整个字符串都已经被拆分且在字典中出现过了，函数就返回 true 。</p>
</blockquote>
<pre><code>Java
public class Solution {
    public boolean wordBreak(String s, List&lt;String&gt; wordDict) {
        return word_Break(s, new HashSet(wordDict), 0);
    }
    public boolean word_Break(String s, Set&lt;String&gt; wordDict, int start) {
        if (start == s.length()) {
            return true;
        }
        for (int end = start + 1; end &lt;= s.length(); end++) {
            if (wordDict.contains(s.substring(start, end)) &amp;&amp; word_Break(s, wordDict, end)) {
                return true;
            }
        }
        return false;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n^n) 考虑最坏情况 s = aaaaaaa。每一个前缀都在字典中，此时回溯树的复杂度会达到 n^n。<br>
空间复杂度：O(n) 。回溯树的深度最深达到 n 。</p>
</blockquote>
<p>方法 2：记忆化回溯</p>
<blockquote>
<p>算法<br>
在先前的方法中，我们看到许多函数调用都是冗余的，也就是我们会对相同的字符串调用多次回溯函数。为了避免这种情况，我们可以使用记忆化的方法，其中一个 memo 数组会被用来保存子问题的结果。每当访问到已经访问过的后缀串，直接用 memo 数组中的值返回而不需要继续调用函数。<br>
通过记忆化，许多冗余的子问题可以极大被优化，回溯树得到了剪枝，因此极大减小了时间复杂度。</p>
</blockquote>
<pre><code>Java
public class Solution {
    public boolean wordBreak(String s, List&lt;String&gt; wordDict) {
        return word_Break(s, new HashSet(wordDict), 0, new Boolean[s.length()]);
    }
    public boolean word_Break(String s, Set&lt;String&gt; wordDict, int start, Boolean[] memo) {
        if (start == s.length()) {
            return true;
        }
        if (memo[start] != null) {
            return memo[start];
        }
        for (int end = start + 1; end &lt;= s.length(); end++) {
            if (wordDict.contains(s.substring(start, end)) &amp;&amp; word_Break(s, wordDict, end, memo)) {
                return memo[start] = true;
            }
        }
        return memo[start] = false;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n^2) 。回溯树的大小最多达到 n^2<br>
空间复杂度：O(n) 。 回溯树的深度可以达到 n 级别。</p>
</blockquote>
<blockquote>
<p>方法 3：使用宽度优先搜索<br>
算法<br>
另一个方法是使用宽度优先搜索。将字符串可视化成一棵树，每一个节点是用 end 为结尾的前缀字符串。当两个节点之间的所有节点都对应了字典中一个有效字符串时，两个节点可以被连接。<br>
为了形成这样的一棵树，我们从给定字符串的第一个字符开始（比方说 s ），将它作为树的根部，开始找所有可行的以该字符为首字符的可行子串。进一步的，将每一个子字符串的结束字符的下标（比方说 i）放在队列的尾部供宽搜后续使用。<br>
每次我们从队列最前面弹出一个元素，并考虑字符串 s(i+1,end) 作为原始字符串，并将当前节点作为树的根。这个过程会一直重复，直到队列中没有元素。如果字符串最后的元素可以作为树的一个节点，这意味着初始字符串可以被拆分成多个给定字典中的子字符串。<br>
树的生成过程可以参考这个例子：</p>
</blockquote>
<pre><code>Java
public class Solution {
    public boolean wordBreak(String s, List&lt;String&gt; wordDict) {
        Set&lt;String&gt; wordDictSet=new HashSet(wordDict);
        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
        int[] visited = new int[s.length()];
        queue.add(0);
        while (!queue.isEmpty()) {
            int start = queue.remove();
            if (visited[start] == 0) {
                for (int end = start + 1; end &lt;= s.length(); end++) {
                    if (wordDictSet.contains(s.substring(start, end))) {
                        queue.add(end);
                        if (end == s.length()) {
                            return true;
                        }
                    }
                }
                visited[start] = 1;
            }
        }
        return false;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n^2) 。对于每个开始的位置，搜索会直到给定字符串的尾部结束。<br>
空间复杂度：O(n) 。队列的大小最多 n</p>
</blockquote>
<p>方法 4：使用动态规划</p>
<blockquote>
<p>算法<br>
这个方法的想法是对于给定的字符串（s）可以被拆分成子问题 s1 和 s2 。如果这些子问题都可以独立地被拆分成符合要求的子问题，那么整个问题 s 也可以满足。也就是，如果 &quot;catsanddog&quot; 可以拆分成两个子字符串 &quot;catsand&quot; 和 &quot;dog&quot; 。子问题 &quot;catsand&quot; 可以进一步拆分成 &quot;cats&quot; 和 &quot;and&quot; ，这两个独立的部分都是字典的一部分，所以 &quot;catsand&quot; 满足题意条件，再往前， &quot;catsand&quot; 和 &quot;dog&quot; 也分别满足条件，所以整个字符串 &quot;catsanddog&quot; 也满足条件。<br>
现在，我们考虑 dp 数组求解的过程。我们使用 n+1 大小数组的dp ，其中 n 是给定字符串的长度。我们也使用 2 个下标指针 i 和 j ，其中 i 是当前字符串从头开始的子字符串（s′ ）的长度， j 是当前子字符串（s ′ ）的拆分位置，拆分成s ′ (0,j) 和s′ (j+1,i) 。<br>
为了求出 dp 数组，我们初始化dp[0] 为 true ，这是因为空字符串总是字典的一部分。 dp 数组剩余的元素都初始化为 false 。<br>
我们用下标 i 来考虑所有从当前字符串开始的可能的子字符串。对于每一个子字符串，我们通过下标 j 将它拆分成s1 ′ 和 s2 ′（注意 i现在指向 s2 ′的结尾）。为了将 dp[i] 数组求出来，我们依次检查每个dp[j] 是否为 true ，也就是子字符串 s1 ′ 是否满足题目要求。如果满足，我们接下来检查 s2 ′ 是否在字典中。如果包含，我们接下来检查 s2 ′ 是否在字典中，如果两个字符串都满足要求，我们让 dp[i] 为true ，否则令其为 false 。</p>
</blockquote>
<pre><code>Java
public class Solution {
    public boolean wordBreak(String s, List&lt;String&gt; wordDict) {
        Set&lt;String&gt; wordDictSet=new HashSet(wordDict);
        boolean[] dp = new boolean[s.length() + 1];
        dp[0] = true;
        for (int i = 1; i &lt;= s.length(); i++) {
            for (int j = 0; j &lt; i; j++) {
                if (dp[j] &amp;&amp; wordDictSet.contains(s.substring(j, i))) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[s.length()];
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n^2) 。求出 dp 数组需要两重循环。<br>
空间复杂度：O(n) 。<br>
dp 数组的长度是n+1 。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DFS 695. 岛屿的最大面积[中等]]]></title>
        <id>https://lixin-scut.github.io//post/dfs-695-dao-yu-de-zui-da-mian-ji-zhong-deng</id>
        <link href="https://lixin-scut.github.io//post/dfs-695-dao-yu-de-zui-da-mian-ji-zhong-deng">
        </link>
        <updated>2020-03-27T14:06:36.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>给定一个包含了一些 0 和 1 的非空二维数组 grid 。<br>
一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。<br>
找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)<br>
示例 1:<br>
[[0,0,1,0,0,0,0,1,0,0,0,0,0],<br>
[0,0,0,0,0,0,0,1,1,1,0,0,0],<br>
[0,1,1,0,1,0,0,0,0,0,0,0,0],<br>
[0,1,0,0,1,1,0,0,1,0,1,0,0],<br>
[0,1,0,0,1,1,0,0,1,1,1,0,0],<br>
[0,0,0,0,0,0,0,0,0,0,1,0,0],<br>
[0,0,0,0,0,0,0,1,1,1,0,0,0],<br>
[0,0,0,0,0,0,0,1,1,0,0,0,0]]<br>
对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。<br>
示例 2:<br>
[[0,0,0,0,0,0,0,0]]<br>
对于上面这个给定的矩阵, 返回 0。<br>
注意: 给定的矩阵grid 的长度和宽度都不超过 50。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/max-area-of-island<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>一开始感觉比较像是动态规划的累积问题<br>
但是有个问题是 示例1中，如果只考虑当前格的左边和上边的话，会导致重复考虑</p>
<p>所以我第二个想法是直接DFS并用visited数组保存已探测的格子<br>
注意怎么样通过修改函数返回值从而不断缩减函数的参数</p>
<pre><code>class Solution {
public:
    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        if(grid.empty())
        {   return 0; }
        int rowSize = grid.size();
        int colSize = grid[0].size();
        
        vector&lt;vector&lt;bool&gt;&gt; visited(rowSize, vector&lt;bool&gt;(colSize, false));
        int ans = 0;

        for(int row = 0; row &lt; rowSize; ++row)
        {
            for(int col = 0; col &lt; colSize; ++col)
            {
                int temp = maxAreaOfIsland(grid, visited, row, col);
                ans = temp &gt; ans ? temp : ans;
            }
        }
        
        return ans;
    }
    
    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid,
                         vector&lt;vector&lt;bool&gt;&gt;&amp; visited,
                         int row,
                         int col)
    {
        
        if(row &gt;= grid.size() || col &gt;= grid[0].size() 
           || visited[row][col])
        {   return 0; }
        
        visited[row][col] = true;
        
        if(grid[row][col] == 0)
        {   return 0;}
        
        return 1 + maxAreaOfIsland(grid,visited,row-1,col)
                + maxAreaOfIsland(grid,visited,row,col-1)
                + maxAreaOfIsland(grid,visited,row+1,col)
                + maxAreaOfIsland(grid,visited,row,col+1);
    }
    
};
</code></pre>
<p>官方题解：<br>
官方题解有个很妙的地方，就是因为数组不需要追溯过往状态，所以访问过的位置可以直接修改置0，从而避免了使用额外的visited数组记录访问状态。</p>
<blockquote>
<p>方法一：深度优先搜索<br>
算法<br>
我们想知道网格中每个连通形状的面积，然后取最大值。<br>
如果我们在一个土地上，以 4 个方向探索与之相连的每一个土地（以及与这些土地相连的土地），那么探索过的土地总数将是该连通形状的面积。<br>
为了确保每个土地访问不超过一次，我们每次经过一块土地时，将这块土地的值置为 0。这样我们就不会多次访问同一土地。</p>
</blockquote>
<pre><code>class Solution {
    int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int cur_i, int cur_j) {
        if (cur_i &lt; 0 || cur_j &lt; 0 || cur_i == grid.size() || cur_j == grid[0].size() || grid[cur_i][cur_j] != 1)
            return 0;
        grid[cur_i][cur_j] = 0;
        int di[4] = {0, 0, 1, -1};
        int dj[4] = {1, -1, 0, 0};
        int ans = 1;
        for (int index = 0; index != 4; ++index) {
            int next_i = cur_i + di[index], next_j = cur_j + dj[index];
            ans += dfs(grid, next_i, next_j);
        }
        return ans;
    }
public:
    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int ans = 0;
        for (int i = 0; i != grid.size(); ++i)
            for (int j = 0; j != grid[0].size(); ++j)
                ans = max(ans, dfs(grid, i, j));
        return ans;
    }
};
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(R∗C)。其中R 是给定网格中的行数，C 是列数。我们访问每个网格最多一次。<br>
空间复杂度：O(R∗C)，递归的深度最大可能是整个网格的大小，因此最大可能使用 O(R∗C) 的栈空间。</p>
</blockquote>
<blockquote>
<p>方法二：深度优先搜索 + 栈<br>
算法<br>
我们可以用栈来实现深度优先搜索算法。这种方法本质与方法一相同，唯一的区别是：<br>
方法一通过函数的调用来表示接下来想要遍历哪些土地，让下一层函数来访问这些土地。而方法二把接下来想要遍历的土地放在栈里，然后在取出这些土地的时候访问它们。<br>
访问每一片土地时，我们将对围绕它四个方向进行探索，找到还未访问的土地，加入到栈 stack 中；<br>
另外，只要栈 stack 不为空，就说明我们还有土地待访问，那么就从栈中取出一个元素并访问。</p>
</blockquote>
<pre><code>class Solution {
public:
    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int ans = 0;
        for (int i = 0; i != grid.size(); ++i)
            for (int j = 0; j != grid[0].size(); ++j) {
                int cur = 0;
                stack&lt;int&gt; stacki;
                stack&lt;int&gt; stackj;
                stacki.push(i);
                stackj.push(j);
                while (!stacki.empty()) {
                    int cur_i = stacki.top(), cur_j = stackj.top();
                    stacki.pop();
                    stackj.pop();
                    if (cur_i &lt; 0 || cur_j &lt; 0 || cur_i == grid.size() || cur_j == grid[0].size() || grid[cur_i][cur_j] != 1)
                        continue;
                    ++cur;
                    grid[cur_i][cur_j] = 0;
                    int di[4] = {0, 0, 1, -1};
                    int dj[4] = {1, -1, 0, 0};
                    for (int index = 0; index != 4; ++index) {
                        int next_i = cur_i + di[index], next_j = cur_j + dj[index];
                        stacki.push(next_i);
                        stackj.push(next_j);
                    }
                }
                ans = max(ans, cur);
            }
        return ans;
    }
};
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(R∗C)。其中R 是给定网格中的行数，C 是列数。我们访问每个网格最多一次。<br>
空间复杂度：O(R∗C)，栈中最多会存放所有的土地，土地的数量最多为R∗C 块，因此使用的空间为 O(R∗C)。</p>
</blockquote>
<blockquote>
<p>方法三：广度优先搜索<br>
算法<br>
我们把方法二中的栈改为队列，每次从队首取出土地，并将接下来想要遍历的土地放在队尾，就实现了广度优先搜索算法。</p>
</blockquote>
<pre><code>class Solution {
public:
    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int ans = 0;
        for (int i = 0; i != grid.size(); ++i)
            for (int j = 0; j != grid[0].size(); ++j) {
                int cur = 0;
                queue&lt;int&gt; queuei;
                queue&lt;int&gt; queuej;
                queuei.push(i);
                queuej.push(j);
                while (!queuei.empty()) {
                    int cur_i = queuei.front(), cur_j = queuej.front();
                    queuei.pop();
                    queuej.pop();
                    if (cur_i &lt; 0 || cur_j &lt; 0 || cur_i == grid.size() || cur_j == grid[0].size() || grid[cur_i][cur_j] != 1)
                        continue;
                    ++cur;
                    grid[cur_i][cur_j] = 0;
                    int di[4] = {0, 0, 1, -1};
                    int dj[4] = {1, -1, 0, 0};
                    for (int index = 0; index != 4; ++index) {
                        int next_i = cur_i + di[index], next_j = cur_j + dj[index];
                        queuei.push(next_i);
                        queuej.push(next_j);
                    }
                }
                ans = max(ans, cur);
            }
        return ans;
    }
};
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(R∗C)。其中 R 是给定网格中的行数，C 是列数。我们访问每个网格最多一次。<br>
空间复杂度：O(R∗C)，队列中最多会存放所有的土地，土地的数量最多为 R∗C 块，因此使用的空间为 O(R∗C)。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机网络体系分层层次]]></title>
        <id>https://lixin-scut.github.io//post/ji-suan-ji-wang-luo-ti-xi-fen-ceng</id>
        <link href="https://lixin-scut.github.io//post/ji-suan-ji-wang-luo-ti-xi-fen-ceng">
        </link>
        <updated>2020-03-26T09:15:15.000Z</updated>
        <content type="html"><![CDATA[<h3 id="分层概念">分层概念</h3>
<p>  每层通过在该层中执行某些动作或使用直接下层的服务来提供服务，例如由第n层提供的服务可能包括报文从网络的一边到另一边的可靠传送，这可能是通过使用第n-1层的边缘到边缘的不可靠报文传送服务，加上第n层的检测和重传丢失报文的功能来实现的。<br>
  一个协议层能够用软件、硬件或两者的结合来实现。诸如HTTP和SMTP这样的应用层协议几乎总是在端系统中用软件实现的，运输层协议也是如此，因为物理层和数据链路层负责处理跨越特定链路的通信，它们通常是实现在与给定链路相联系的网络接口卡（例如以太网或WiFi接口卡）中，网络层经常是硬件和软件实现的混合体</p>
<h3 id="优缺点">优缺点</h3>
<p><strong>优点：</strong><br>
  协议分层具有概念化和结构化的优点<br>
  采用多层是有益的,通过分层, 每层只负责通信的一个方面。互联网络的目标之一是对应用隐藏所有关于物理布局( 拓扑) 和低层协议的异构性的细 节，分层设计允许开发人员分别实现系统的不同部分, 它们通常由在不同领域的专业人员完成。<br>
  分层体系结构的另一个主要优点是具有协议复用的能力。这种复用形式允许多种协议共存于同一基础设施中。它也允许相同协议对象( 例如连接) 的多个实例同时存在, 并且不会被混淆。</p>
<p><strong>缺点：</strong><br>
  分层的一个潜在缺点是一层可能冗余较低层的功能<br>
  第二种潜在的缺点是某层的功能可能需要仅在其他某层才出现的信息</p>
<p>  因特网的协议栈由5个层次组成：<strong>物理层、链路层、网络层、运输层和应用层</strong><br>
  OSI参考模型的7层是：<strong>应用层、表示层、会话层</strong>，运输层，网络层，数据链路层和物理层<br>
<img src="https://lixin-scut.github.io//post-images/1585214284826.png" alt=""></p>
<p>(1)应用层<br>
  应用层是网络应用程序及它们的应用层协议存留的地方，因特网的用层包括许多协议，例如HTTP，SMTP(它提供了电子邮件报文的传输）和FTP(它提供两个端系统之间的文件传送）。我们将看到某些网络功能，如将像www这样对人友好的端系统名字转换为32比特网络地址<br>
  应用层的信息分组称为<strong>报文（message)</strong><br>
(2)运输层<br>
  因特网的运输层在应用程序端点之间传送应用层报文在因特网中，有两个运输协议.<br>
即TCP和UDP<br>
  TCP向它的应用程序提供了面向连接的服务，包括了应用层报文向目的地的确保传递和流量控制（即发送方/接收方速率匹配），TCP也将长报文划分为短报文.并提供拥塞控制机制，因此当网络拥塞时，源抑制其传输速率.<br>
  UDP协议向它的应用程序提供无连接服务，这是一种不提供不必要服务的服务，没有可靠性.没有流量控制.也没有拥塞控制在本书中.<br>
  我们把运输层分组称为<strong>报文段（segment)。</strong><br>
(3)网络层<br>
  因特网的网络层负责将称为<strong>数据报（datagnim)</strong><br>
  网络层分组从一台主机移动到另一台主机.在一台源主机中的因特网运输层协议（TCP或UDP)向网络层递交运输层报文段和目的地址，就像你通过邮政服务寄信件时提供一个目的地址一样<br>
  因特网的网络层包括著名的IP协议，该协议定义了在数据报中的各个字段以及端系统和路由器如何作用于这些字段<br>
  网络层包括了IP协议和一些路由选择协议，但通常把它简单地称为IP层.这反映IP是将因特网连接在一起的粘合剂这样的事实<br>
(4)链路层<br>
  因特网的网络层通过源和目的地之间的一系列路由器路由数据报，为了将分组从一个结点（主机或路由器）移动到路径上的下一个结点，网络层必须依靠该链路层的服务，特別是在每个结点.网络层将数据报下传给链路层.链路层沿着路径将数据报传递给下一个结点。在下个结点，链路层将数据报上传给网络层，<br>
  我们把链路层分组称为<strong>帧(frame)</strong><br>
(5)物理层<br>
  虽然链路层的任务是将整个帧从一个网络元素移动到邻近的网络元素.而物理层的任务是将该帧中的一个一个比特从一个结点移动到下一个结点，</p>
<h3 id="各层次包含的协议">各层次包含的协议：</h3>
<p>应用层：<br>
HTTP DNS</p>
<p>运输层：<br>
TCP UDP ICMP</p>
<p>网络层：<br>
IP<br>
路由选择算法</p>
<p>链路层：</p>
<p>物理层：</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 494. 目标和[中等][未做出]]]></title>
        <id>https://lixin-scut.github.io//post/dong-tai-gui-hua-494-mu-biao-he-zhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/dong-tai-gui-hua-494-mu-biao-he-zhong-deng-wei-zuo-chu">
        </link>
        <updated>2020-03-26T04:44:24.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。<br>
返回可以使最终数组和为目标数 S 的所有添加符号的方法数。<br>
示例 1:<br>
输入: nums: [1, 1, 1, 1, 1], S: 3<br>
输出: 5<br>
解释:<br>
-1+1+1+1+1 = 3<br>
+1-1+1+1+1 = 3<br>
+1+1-1+1+1 = 3<br>
+1+1+1-1+1 = 3<br>
+1+1+1+1-1 = 3<br>
一共有5种方法让最终目标和为3。<br>
注意:<br>
数组非空，且长度不会超过20。<br>
初始的数组的和不会超过1000。<br>
保证返回的最终结果能被32位整数存下。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/target-sum<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>我本来想用动态规划，但是可能的情况似乎不断增加<br>
看了题解的动态规划法，原来是需要先转化为背包问题的<br>
时间复杂度：O(N∗sum)，其中 N 是数组 nums 的长度。<br>
空间复杂度：O(sum)</p>
<p>然后想到了回溯递归法<br>
出现的问题<br>
1.if(0 == S)必须判断<br>
2.溢出问题。。。这个我没啥特别好的办法。。。只能先把int 改成 long了<br>
复杂度分析<br>
时间复杂度：O(2^N)，其中 N 是数组 nums 的长度。<br>
空间复杂度：O(N)，为递归使用的栈空间大小。</p>
<p>还有位运算法<br>
尴尬，位运算法超时了。。。因为必须逐位循环，时间复杂度在O(2^N)再套一个length</p>
<pre><code>class Solution {
public:
    // 动态规划
    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S)
    {
        int sum = 0;
        for(auto num : nums)
        {
            sum += num;
        }
        // 这里的判断很重要，排除极端情况和无法整除的情况
        if((sum &gt; 0 &amp;&amp; S &gt; sum) || (sum &lt; 0 &amp;&amp; S &lt; sum) || (sum + S) % 2 == 1) 
        {   return 0; }
        int target = (sum + S) / 2; 
        
        // 我直接优化了空间，注意必须从后往前更新，否则会不断叠加，然后原始是需要加上nums的一维
        vector&lt;int&gt; sumDP(target + 1, 0);
        sumDP[0] = 1;
        for(auto num : nums)
        {
            for(int i = target; i &gt;= 0; --i)
            {
                if(i - num &gt;=0)
                {
                    sumDP[i] += sumDP[i - num];
                }
            }
        }
        return sumDP.back();
    }
    /*
    // 超时
    // 位运算法
    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S)
    {
        int ways = 0;
        long res;
        int len = nums.size();
        int ans = 0;
        while(ways &lt; pow(2, len))
        {
            int bit = 1;
            res = 0;
            for(int i = 0; i &lt; len ; ++i)
            {
                if(ways &amp; (bit &lt;&lt; i))
                {
                    res += static_cast&lt;long&gt;(nums[i]);
                }
                else
                {
                    res -= static_cast&lt;long&gt;(nums[i]);
                }
            }
            if(static_cast&lt;int&gt;(res) == S)
            { ++ans; }
            ++ways;
        }
        return ans;
    }
    
    // 回溯递归法
    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) {
        int ans = 0;
        findTargetSumWays(nums, S, 0, ans);
        return ans;
    }
    
    void findTargetSumWays(vector&lt;int&gt;&amp; nums, long S, int num, int&amp; ans)
    {
        if(num == nums.size() )
        {   
            // 必须单独判断
            if(0 == S)
            {    
                ++ans;
            }
            return;
        }
        
        // 不要用++num
        findTargetSumWays(nums, S+nums[num], num + 1, ans);
        findTargetSumWays(nums, S-nums[num], num + 1, ans);
    }
    */
};
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>暴力解法<br>
暴力解法就是dfs了，这道题而言，暴力解法是完全可以的，而且不会超时，因为题目中说了数组长度不会超过20，20个数字的序列，组合方式撑死了2^20种，算下来才1024×1024<br>
也就是说，可以把数组中每个数字前面都用负号和正号，然后进行组合的求和，并判断这个和是否会等于S，然后就标记，最后统计出等于S的组合个数就好了。<br>
具体使用dfs，就是一个前序遍历二叉树的实现，递归地+或-每个元素，到所有元素都遍历完成的时候，最后那个判断target是否等于零。</p>
</blockquote>
<pre><code>class Solution {
public:
    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) {
        return dfs(nums, S, 0);
    }

    int dfs(vector&lt;int&gt; &amp;nums, uint target, int left) {
        if (target == 0 &amp;&amp; left == nums.size()) return 1;
        if (left &gt;= nums.size()) return 0;
        int ans = 0;
        ans += dfs(nums, target - nums[left], left + 1);
        ans += dfs(nums, target + nums[left], left + 1);
        return ans;
    }
};
</code></pre>
<blockquote>
<p>01背包<br>
本题解参考热评解法<br>
01背包其实不是这种解法的重点，重点是怎么把题目转化成求解01背包的形式。<br>
如果只是单纯的求解和为某个S的组合个数，那就是01背包。。。<br>
但是这题目中不仅有加，还有减，就得进行一个转化了。<br>
思路就是把整个集合看成两个子集，Q表示整个集合，P表示正数子集，N表示负数子集， T表示目标和，用S(X)表示集合的求和函数，集合中均为非负数，N集合是指选中这部分元素作为负数子集。</p>
</blockquote>
<pre><code>S(P)−S(N)=T
S(P)+S(N)+S(P)−S(N)=T+S(P)+S(N)
2S(P)=S(Q)+T
</code></pre>
<blockquote>
<p>也就是：正数集的和的两倍 == 等于目标和 + 序列总和<br>
所以问题就转换成了，找到一个正数集P，其和的两倍等于目标和+序列总和。。。<br>
简单吧，完全就是01背包了嘛！！！<br>
对于01背包，其实我都差不多背下来了，你会发现背了以后，写着写着，就理解了。<br>
需要注意的是，虽然序列总和不超过1000，但是S可是会接近int的上界。。。很容易出现超过整型范围的操作。</p>
</blockquote>
<pre><code>class Solution {
public:
    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) {
        long sum = 0;
        for (const int &amp;it : nums) sum += it;
        if ((S + sum) % 2 == 1 || S &gt; sum) return 0;
        S = (S + sum) / 2;
        int *dp = new int[S + 1];
        memset(dp, 0, (S + 1) * sizeof(int));
        dp[0] = 1;
        for (const int &amp;it : nums) {
            for (int j = S; j &gt;= it; j--)
                dp[j] += dp[j - it];
        }
        int ans = dp[S];
        delete[] dp;
        return ans;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 416. 分割等和子集[中等][未做出]]]></title>
        <id>https://lixin-scut.github.io//post/dong-tai-gui-hua-416-fen-ge-deng-he-zi-ji</id>
        <link href="https://lixin-scut.github.io//post/dong-tai-gui-hua-416-fen-ge-deng-he-zi-ji">
        </link>
        <updated>2020-03-25T00:24:36.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。<br>
注意:<br>
每个数组中的元素不会超过 100<br>
数组的大小不会超过 200<br>
示例 1:<br>
输入: [1, 5, 11, 5]<br>
输出: true<br>
解释: 数组可以分割成 [1, 5, 5] 和 [11].<br>
示例 2:<br>
输入: [1, 2, 3, 5]<br>
输出: false<br>
解释: 数组不能分割成两个元素和相等的子集.<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/partition-equal-subset-sum<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>【未做出】<br>
这道题可以视为有两个背包<br>
一个数只有两种状态，放在第一个背包或者放在第二个背包，用0和1表示<br>
然后用两者的差值<br>
重点在于状态转移方程</p>
<p>最后还是看了题解，把能否达到某个sum的boolean值作为第二维<br>
然后不断地从已有的sum加上当前num，更新可以达到的sum<br>
最终检测是否能够达到target</p>
<p>需要注意的点：</p>
<ol>
<li>当前num是否大于target</li>
<li>等于时可以直接返回</li>
<li>一开始可以检查总的sum是否为奇数，奇数不可能对分</li>
<li><code>sumDP[0][0]</code>需要初始化为true</li>
</ol>
<pre><code>class Solution {
public:
    // 动态规划：空间压缩
    bool canPartition(vector&lt;int&gt;&amp; nums) 
    {
        int sum = 0;
        for(auto num : nums)
        {
            sum += num;
        }
        if(sum % 2 == 1)
        {   return false; }
        
        int target = sum / 2;
        int length = nums.size();
        vector&lt;bool&gt; sumDP(target + 1, false);
        
        sumDP[0] = true;
        if(nums[0] &lt;= target)
        {   
            sumDP[nums[0]] = true;
        }
        
        for(int num = 1; num &lt; length; ++num)
        {
            for(int sum = target; sum &gt;= 0; --sum)
            {
                if(nums[num] == target)
                {
                        return true;
                }
                if(sum &gt; nums[num] )
                {
                    sumDP[sum] = sumDP[sum] || sumDP[sum - nums[num]];
                }
            }
        }
        
        return sumDP[target];
    }
    
    /*
    // 动态规划
    bool canPartition(vector&lt;int&gt;&amp; nums) 
    {
        int sum = 0;
        for(auto num : nums)
        {
            sum += num;
        }
        if(sum % 2 == 1)
        {   return false; }
        
        int target = sum / 2;
        int length = nums.size();
        vector&lt;vector&lt;bool&gt;&gt; sumDP(length, vector&lt;int&gt;(target + 1, false));
        
        
        sumDP[0][0] = true;
        if(nums[0] &lt;= target)
        {   sumDP[0][nums[0]] = true;}
        
        for(int num = 1; num &lt; length; ++num)
        {
            for(int sum = 0; sum &lt; target + 1; ++sum)
            {
                sumDP[num][sum] = sumDP[num-1][sum];
                if(nums[num] == target)
                {
                    return true;
                }
                if(sum &gt; nums[num] )
                {
                    sumDP[num][sum] = sumDP[num - 1][sum] || sumDP[num - 1][sum - nums[num]];
                }
            }
        }
        return sumDP[length - 1][target];
    }
    */
};
</code></pre>
<p>网友题解</p>
<blockquote>
<p>事实上，这是一个典型的“动态规划”问题，并且它的“原形”是“0-1 背包问题”。使用“动态规划”解决问题的思路是“以空间换时间”，“规划”这个词在英文中就是“填表格”的意思，代码执行的过程，也可以称之为“填表格”。<br>
“动态规划”的方法可以认为是为我们提供了一个思考问题的方向，我们不是直接面对问题求解，而是去找原始问题（或者说和原始问题相关的问题）的最开始的样子，通过“状态转移方程”（这里没法再解释了，可以结合下文理解）记录下每一步求解的结果，直到最终问题解决。<br>
而直接面对问题求解，就是我们熟悉的“递归”方法，由于有大量重复子问题，我们就需要加缓存，这叫“记忆化递归”，这里就不给参考代码了，感兴趣的朋友可以自己写一下，比较一下它们两种思考方式的不同之处和优缺点。<br>
做这道题需要做这样一个等价转换：是否可以从这个数组中挑选出一些正整数，使得这些数的和等于整个数组元素的和的一半。前提条件是：数组的和一定得是偶数，即数组的和一定得被 2 整除，这一点是特判。</p>
</blockquote>
<blockquote>
<p>本题与 0-1 背包问题有一个很大的不同，即：<br>
0-1 背包问题选取的物品的容积总量不能超过规定的总量；<br>
本题选取的数字之和需要恰恰好等于规定的和的一半。<br>
这一点区别，决定了在初始化的时候，所有的值应该初始化为 false。 （《背包九讲》的作者在介绍 0-1 背包问题的时候，有强调过这点区别，我在这里也只是再重复一下。）<br>
作为“0-1 背包问题”，它的特点是：“每个数只能用一次”。思路是：物品一个一个选，容量也一点一点放大考虑（这一点是“动态规划”的思想，特别重要）。<br>
如果在实际生活中，其实我们也是这样做的，一个一个尝试把候选物品放入“背包”，看什么时候能容纳的价值最大。<br>
具体做法是：画一个 len 行，target + 1 列的表格。这里 len 是物品的个数，target 是背包的容量。len 行表示一个一个物品考虑，target + 1多出来的那 1 列，表示背包容量从 0 开始，很多时候，我们需要考虑这个容量为 0 的数值。<br>
状态定义：dp[i][j]表示从数组的 [0, i] 这个子区间内挑选一些正整数，每个数只能用一次，使得这些数的和恰好等于 j。<br>
状态转移方程：很多时候，状态转移方程思考的角度是“分类讨论”，对于“0-1 背包问题”而言就是“当前考虑到的数字选与不选”。<br>
1、不选择 nums[i]，如果在 [0, i - 1] 这个子区间内已经有一部分元素，使得它们的和为 j ，那么 dp[i][j] = true；<br>
2、选择 nums[i]，如果在 [0, i - 1] 这个子区间内就得找到一部分元素，使得它们的和为 j - nums[i]。<br>
状态转移方程是：<br>
dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i]]<br>
一般写出状态转移方程以后，就需要考虑边界条件（一般而言也是初始化条件）。<br>
1、j - nums[i] 作为数组的下标，一定得保证大于等于 0 ，因此 nums[i] &lt;= j；<br>
2、注意到一种非常特殊的情况：j 恰好等于 nums[i]，即单独 nums[j] 这个数恰好等于此时“背包的容积” j，这也是符合题意的。<br>
因此完整的状态转移方程是：<br>
dp[i][j]=<br>
dp[i−1][j],   至少是这个答案，如果 dp[i−1][j] 为真，直接计算下一个状态<br>
true,  nums[i] = j<br>
dp[i−1][j−nums[i]],  nums[i] &lt; j<br>
说明：虽然写成花括号，但是它们的关系是或者。<br>
初始化：dp[0][0] = false，因为是正整数，当然凑不出和为 0。<br>
输出：dp[len - 1][target]，这里 len 表示数组的长度，target 是数组的元素之和（必须是偶数）的一半。</p>
</blockquote>
<pre><code>public class Solution {

    public boolean canPartition(int[] nums) {
        int len = nums.length;
        if (len == 0) {
            return false;
        }

        int sum = 0;
        for (int num : nums) {
            sum += num;
        }

        // 特判：如果是奇数，就不符合要求
        if ((sum &amp; 1) == 1) {
            return false;
        }

        int target = sum / 2;

        // 创建二维状态数组，行：物品索引，列：容量（包括 0）
        boolean[][] dp = new boolean[len][target + 1];

        // 先填表格第 0 行，第 1 个数只能让容积为它自己的背包恰好装满
        if (nums[0] &lt;= target) {
            dp[0][nums[0]] = true;
        }

        // 再填表格后面几行
        for (int i = 1; i &lt; len; i++) {
            for (int j = 0; j &lt;= target; j++) {
                // 直接从上一行先把结果抄下来，然后再修正
                dp[i][j] = dp[i - 1][j];

                if (nums[i] == j) {
                    dp[i][j] = true;
                    continue;
                }
                if (nums[i] &lt; j) {
                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]];
                }
            }
        }
        return dp[len - 1][target];
    }
}

</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(NC)：这里 N 是数组元素的个数，C 是数组元素的和的一半。<br>
空间复杂度：O(NC)。</p>
</blockquote>
<blockquote>
<p>下面是几点说明：<br>
1、修改状态数组初始化的定义：dp[0][0] = true。<br>
注意到：容量为 0 的时候，即 dp[i][0] 按照本意来说，应该设置为 false ，但是注意到状态转移方程（代码中）：<br>
dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]];<br>
j - nums[i] == 0 成立的时候，根据上面分析，就说明单独的 nums[i] 这个数就恰好能够在被分割为单独的一组，其余的数分割成为另外一组，因此，我们把初始化的 dp[i][0] 设置成为 true 在代码运行层面是完全没有问题的。<br>
2、观察状态转移方程的特点，or 的结果只要为真，表格下面所有的值都为真，因此在填表的时候，只要表格的最后一列是 true，代码就可以结束，直接返回 true 即可。<br>
参考代码 2：</p>
</blockquote>
<pre><code>public class Solution {

    public boolean canPartition(int[] nums) {
        int len = nums.length;
        if (len == 0) {
            return false;
        }

        int sum = 0;
        for (int num : nums) {
            sum += num;
        }

        if ((sum &amp; 1) == 1) {
            return false;
        }

        int target = sum / 2;

        boolean[][] dp = new boolean[len][target + 1];
        // 初始化成为 true 虽然不符合状态定义，但是从状态转移来说是完全可以的
        dp[0][0] = true;

        if (nums[0] &lt;= target) {
            dp[0][nums[0]] = true;
        }

        for (int i = 1; i &lt; len; i++) {
            for (int j = 0; j &lt;= target; j++) {

                dp[i][j] = dp[i - 1][j];

                if (nums[i] &lt;= j) {
                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]];
                }
            }

            // 由于状态转移方程的特殊性，提前结束，可以认为是剪枝操作
            if (dp[i][target]) {
                return true;
            }
        }
        return dp[len - 1][target];
    }
}
</code></pre>
<blockquote>
<p>3、“0-1 背包问题”常规优化：“状态数组”从二维降到一维，减少空间复杂度。<br>
在“填表格”的时候，当前行只参考了上一行的值，因此状态数组可以只设置 2 行，使用“滚动数组”的技巧“填表格”即可；<br>
实际上连“滚动数组”都不必，在“填表格”的时候，当前行总是参考了它上面一行 “头顶上” 那个位置和“左上角”某个位置的值。因此，我们可以只开一个一维数组，从后向前依次填表即可。<br>
这一点第 1 次接触的时候，可能会觉得很奇怪，理解的办法是，就拿题目中的示例，画一个表格，自己模拟一遍程序是如何“填表”的行为，就很清楚为什么状态数组压缩到 1 行的时候，需要“从后前向”填表。<br>
“从后向前” 写的过程中，一旦 nums[i] &lt;= j 不满足，可以马上退出当前循环，因为后面的 j 的值肯定越来越小，没有必要继续做判断，直接进入外层循环的下一层。相当于也是一个剪枝，这一点是“从前向后”填表所不具备的。<br>
参考代码 3：只展示了状态数组压缩到一维，并且“从后向前”填表格的代码。</p>
</blockquote>
<pre><code>public class Solution {

    public boolean canPartition(int[] nums) {
        int len = nums.length;
        if (len == 0) {
            return false;
        }

        int sum = 0;
        for (int num : nums) {
            sum += num;
        }

        if ((sum &amp; 1) == 1) {
            return false;
        }

        int target = sum / 2;

        boolean[] dp = new boolean[target + 1];
        dp[0] = true;

        if (nums[0] &lt;= target) {
            dp[nums[0]] = true;
        }

        for (int i = 1; i &lt; len; i++) {
            for (int j = target; nums[i] &lt;= j; j--) {
                if (dp[target]) {
                    return true;
                }

                dp[j] = dp[j] || dp[j - nums[i]];
            }
        }
        return dp[target];
    }
}

</code></pre>
<blockquote>
<p>最后思考为什么题目说是正整数，有 0 是否可以，有实数可以吗，有负数可以吗？<br>
0 的存在意义不大，放在哪个子集都是可以的；<br>
实数有可能是无理数，也可能是无限不循环小数，在计算整个数组元素的和的一半，要除法，然后在比较两个子集元素的和是否相等的时候，就会遇到精度的问题；<br>
再说负数，负数其实也是可以存在的，但要用到“回溯搜索”解决。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ARP地址解析协议]]></title>
        <id>https://lixin-scut.github.io//post/arp-di-zhi-jie-xi-xie-yi</id>
        <link href="https://lixin-scut.github.io//post/arp-di-zhi-jie-xi-xie-yi">
        </link>
        <updated>2020-03-24T08:04:32.000Z</updated>
        <content type="html"><![CDATA[<h3 id="交换局域网">交换局域网</h3>
<p>  交换机运行在链路层，所以它们交换链路层帧（而不是网络层数据报），它们使用链路层地址而不是IP地址来转发链路层帧通过交换机网络。</p>
<h3 id="链路层寻址和arp">链路层寻址和ARP</h3>
<p>  在网络层和链路层都需要地址<br>
  地址解析协议（ARP)：将IP地址转换为链路层地址的机制</p>
<h3 id="mac地址">MAC地址</h3>
<p>  适配器（即网络接口） 具 有链路层地址，而不是主机或路由器<br>
  具有多个网络接口的主机或路由器将具有与之相关联的多个链路层 地址<br>
  链路 层交换 机并不具有与它们的接口 (这些接口是与主机和路由器相连的）相关联的链路 层地址<br>
  链路层交换机的任务是在主机与路由器之间承载数据报，交换机透 明地执行该项任 务<br>
  链路层地址有各种不同的称呼：LAN地址（LAN address)、物理 地址（physical address）或MAC地址（MAC address)<br>
  MAC地址长度为6字节，每个字节被表示为一对十六进制数，MAC地址被设计为永久的<br>
  没有两块适 配器 具有相同的地址<br>
  适配器的MAC地址具有扁平结构（这与层次结构相反），IP地址具有层次结构（即一个网 络部分和一个主机部分）<br>
  发送适配器将目的适配器的MAC地址插入到该帧中，适配器接收到一个帧将会与其自身的MAC地址进行MAC地址匹配，不匹配的话丢弃该帧<br>
  MAC广 播地址：广播地址是48个连续的1组成的字符串（即以十六进制 表示法表示的FF-FF-FF-FF- FF-FF）<br>
  主机和路由器接口除了网络层地址之外还有MAC地址，这有如下几个原因首先，</p>
<ol>
<li>局域网是为任 意网络层协议而设计的.而不只是用于IP和因特网</li>
<li>为了使网络体系结构中各层次成为 极 为独立的构建模块.不同的层次需要有它们自己的寻址方案</li>
<li>我们现在已经看到3种 类型的地 址：应用层的主机名、网络层的IP地址以及链路层的MAC地址</li>
</ol>
<h3 id="地址解析协议">地址解析协议</h3>
<p>  地址解析协议(address resolution protocol, ARP)<br>
  发送主机中的ARP 模 块将取在相同局域网上的任何IP地址作为输人，然后返回相应的MAC地址<br>
  DNS为在因特网中任何地方的主机解析主机名，而ARP只为在同一个子网上的主机和路由器接口解析IP地址<br>
  每台主机或路由器在 其内存中具有一个ARP表（ARP table).这张表包含IP地址到MAC地址的映射关系，ARP表也包含 —个 寿命（TTL)值.它指示了从表中删除每个映射的时间<br>
  如果ARP表中当前没有该目的主机的表项，首先，发送方构造一 个称为ARP分组（ARP packet)的特殊分组，包括 发送和接 收IP地址及MAC地址<br>
一个ARP分组 具 有包含链路层地址的字段，因而可认为是链路层协议，但它也包含网络层地址，因而也 可 认为是为网络层协议，最好把ARP看成是跨越链路层和网络层边界两边的 协议</p>
<h3 id="发送数据报到子网以外">发送数据报到子网以外</h3>
<p><img src="https://lixin-scut.github.io//post-images/1585037105955.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1585037110271.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 518. 零钱兑换 II[中等][未做出]]]></title>
        <id>https://lixin-scut.github.io//post/dong-tai-gui-hua-518-ling-qian-dui-huan-iizhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/dong-tai-gui-hua-518-ling-qian-dui-huan-iizhong-deng-wei-zuo-chu">
        </link>
        <updated>2020-03-23T01:37:07.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 <br>
示例 1:<br>
输入: amount = 5, coins = [1, 2, 5]<br>
输出: 4<br>
解释: 有四种方式可以凑成总金额:<br>
5=5<br>
5=2+2+1<br>
5=2+1+1+1<br>
5=1+1+1+1+1<br>
示例 2:<br>
输入: amount = 3, coins = [2]<br>
输出: 0<br>
解释: 只用面额2的硬币不能凑成总金额3。<br>
示例 3:<br>
输入: amount = 10, coins = [10]<br>
输出: 1<br>
注意:<br>
你可以假设：<br>
0 &lt;= amount (总金额) &lt;= 5000<br>
1 &lt;= coin (硬币面额) &lt;= 5000<br>
硬币种类不超过 500 种<br>
结果符合 32 位符号整数<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/coin-change-2<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这个就和爬阶梯和斐波那契基本完全一致了<br>
这里我犯了个错误，其实不完全一致，因为阶梯是等于排序，1+2和2+1是不同的，而硬币是组合，此时是相同的。<br>
看了题解发现是首先选取某一种硬币的面值，再确定要用多少颗这种硬币（组合）<br>
在后面的循环中基于前面已有的情况继续计算。</p>
<pre><code>class Solution {
public:
    int change(int amount, vector&lt;int&gt;&amp; coins) {
        if(0 == amount)
        {   return 1; }
        if(coins.empty())
        {   
            return 0; 
        }
        
        
        vector&lt;vector&lt;int&gt;&gt; counts(coins.size() + 1, vector&lt;int&gt;(amount + 1, 0));
        counts[0][0] = 1;

        for(int i = 1; i &lt;= coins.size(); ++i)
        {
            for(int j = 0; j &lt;= amount; ++j)
            {
                for(int k = 0; j - k*coins[i-1] &gt;= 0; ++k)
                {
                    counts[i][j] += counts[i-1][j - k*coins[i-1]] ;
                }
            }
        }
        return counts[coins.size()][amount];
    }
};
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>方法：动态规划<br>
这道题是典型的“完全背包问题”。“完全背包问题”的特点是：背包里的物品可以无限次选取。<br>
本题特殊的地方在于：从背包里选取的物品必须刚刚好装满需要考虑的容量，而不是小于等于就好，注意这点细微的区别。<br>
完全背包问题是基于 0-1 背包问题的扩展。它们的不同之处在于：<br>
0-1 背包问题：当前考虑的物品用或者不用；<br>
完全背包问题：当前考虑的物品用或者不用，如果用，用几个。<br>
思路依然是：一个一个物品考虑，容量一点一点扩大，整个过程是一个尝试和比较的过程。</p>
</blockquote>
<blockquote>
<p>第 1 步：定义状态<br>
dp[i][j]：硬币列表的前缀子区间 [0, i] 能够凑成总金额 j 的组合数。<br>
说明：背包问题有一个特点，顺序无关，在最开始，我们强调过这道问题的这个性质，因此可以一个一个硬币去看。</p>
</blockquote>
<blockquote>
<p>第 2 步：思考状态转移方程<br>
对于遍历到的每一种面值的硬币，逐个考虑添加到 “总金额” 中。由于硬币的个数可以无限选取，因此对于一种新的面值的硬币 coins[i - 1]（注意这里有一个位移偏差），依次考虑选取 0 枚、1 枚、2 枚，以此类推，直到选取这种面值的硬币的总金额超过需要的总金额 j，dp[i][j] 是它们的值的和。<br>
状态转移方程是：</p>
</blockquote>
<pre><code>Java
dp[i][j] = dp[i - 1][j - 0 * coins[i]] + 
           dp[i - 1][j - 1 * coins[i]] +
           dp[i - 1][j - 2 * coins[i]] + 
           ... + 
           dp[i - 1][j - k * coins[i]]
</code></pre>
<blockquote>
<p>这里状态转移要成立，需要满足：<code>j - k * coins[i] &gt;= 0</code>。<code>dp[i][j]</code> 相对于 <code>dp[i - 1][j]</code> 而言，多考虑的一枚硬币，是“正在考虑的那枚硬币的面值”，<code>coins[i]</code>，而这枚硬币选取的个数（从 0 开始）就是<code>dp[i][j]</code> 这个问题可以分解的各个子问题的分类标准。<br>
事实上，这个状态转移方程有优化的空间，因为做了很多重复的工作，读者可以试着自己优化一下状态转移方程。</p>
</blockquote>
<blockquote>
<p>第 3 步：思考初始化<br>
<code>dp[0][0]</code> 的值应该设置为 1，它虽然没有意义，但是是一个被参考的值，原因是：当 <code>dp[i - 1][j - k * coins[i]]</code> 的第 2 个坐标 <code>j - k * coins[i] == 0</code> 成立的时候，k 个硬币 <code>coin[i]</code> 就恰好成为了一种组合，因此，<code>dp[0][0] = 1</code>。<br>
填写第 1 行，也是初始化的时候需要考虑的内容，第 1 行即考虑第 1 个数，能够组合出的容量就只有 <code>coins[0]</code> 的整数倍数。<br>
事实上，可以考虑多设置一行，把第 1 行除了 <code>dp[0][0]</code> 全部设置为 0，这样可以避免这种复杂的初始化讨论，这一步留给读者完成。</p>
</blockquote>
<blockquote>
<p>第 4 步：思考输出<br>
输出就是表格的最后一格的数值，即 <code>dp[len - 1][amount]</code>。</p>
</blockquote>
<blockquote>
<p>第 5 步：考虑状态压缩<br>
当前状态行的值，只和上一行的状态值相关，因此可以考虑状态压缩，使用滚动数组技巧即可，这里暂不展示代码。<br>
参考代码 1：</p>
</blockquote>
<pre><code>Java
public class Solution {

    public int change(int amount, int[] coins) {
        int len = coins.length;
        if (len == 0) {
            if (amount == 0) {
                return 1;
            }
            return 0;
        }

        int[][] dp = new int[len][amount + 1];
        // 这个值语义不正确，但是是一个被其它状态参考的值，这样设置是正确的
        dp[0][0] = 1;

        // 填第 1 行
        for (int i = coins[0]; i &lt;= amount; i += coins[0]) {
            dp[0][i] = 1;
        }

        for (int i = 1; i &lt; len; i++) {
            for (int j = 0; j &lt;= amount; j++) {
                for (int k = 0; j - k * coins[i] &gt;= 0; k++) {
                    dp[i][j] += dp[i - 1][j - k * coins[i]];
                }
            }
        }
        return dp[len - 1][amount];
    }
}
</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(NM^2 )，这里金额为 M，硬币数为 N。第 1 层循环与硬币总数同规模，第 2 层循环与要求的总金额同规模，第 3 层循环在“最坏情况下”，硬币的面值为 1 时，与要求的总金额同规模。<br>
空间复杂度：O(NM)，表格有 N 行，M 列。</p>
</blockquote>
<blockquote>
<p>方法二：优化状态转移方程<br>
根据状态转移方程其实可以得到递推公式。状态转移方程的表达形式“看起来”像是一个“无穷级数”，可以通过如下方式得到一个 “递推公式”</p>
</blockquote>
<pre><code>dp[i][j] = dp[i - 1][j - 0 * coins[i - 1]] + 
           dp[i - 1][j - 1 * coins[i - 1]] +
           dp[i - 1][j - 2 * coins[i - 1]] + 
           ... + 
           dp[i - 1][j - k * coins[i - 1]]
</code></pre>
<blockquote>
<p>这里 <code>j - k * coins[i] &gt;= 0</code>。我们将这个等式记为“等式（1）。<br>
将 j 用 <code>coins[i]</code> 替换，得：</p>
</blockquote>
<pre><code>dp[i][j - coins[i]] = dp[i - 1][j - coins[i] - 0 * coins[i]] + 
                      dp[i - 1][j - coins[i] - 1 * coins[i]] +
                      dp[i - 1][j - coins[i] - 2 * coins[i]] + 
                      ... + 
                      dp[i - 1][j - coins[i] - k * coins[i]]
</code></pre>
<blockquote>
<p>这里 <code>j - coins[i] - k * coins[i] &gt;= 0</code>。<br>
整理一下：</p>
</blockquote>
<pre><code>dp[i][j - coins[i]] = dp[i - 1][j - 1 * coins[i]] + 
                      dp[i - 1][j - 2 * coins[i]] +
                      dp[i - 1][j - 3 * coins[i]] + 
                      ... + 
                      dp[i - 1][j - k * coins[i]]
</code></pre>
<blockquote>
<p>这里 <code>j - k * coins[i] &gt;= 0</code>。我们将这个等式记为“等式（2）”。<br>
将 等式（1）- 等式（2），得：<br>
<code>dp[i][j] - dp[i][j - coins[i]] = dp[i - 1][j]</code><br>
整理得：<br>
<code>dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i]]</code><br>
所以其实每一行单元的值的填写我们只要看它的左边就好了，如果没有左边，它至少是上一行单元格的值。<br>
请读者比较这里状态压缩和 0-1 背包问题的不同之处。<br>
参考代码 2：</p>
</blockquote>
<pre><code>Java
public class Solution {

    public int change(int amount, int[] coins) {
        int len = coins.length;
        if (len == 0) {
            if (amount == 0) {
                return 1;
            }
            return 0;
        }

        int[][] dp = new int[len][amount + 1];
        dp[0][0] = 1;

        for (int i = coins[0]; i &lt;= amount; i += coins[0]) {
            dp[0][i] = 1;
        }

        for (int i = 1; i &lt; len; i++) {
            for (int j = 0; j &lt;= amount; j++) {
                dp[i][j] = dp[i - 1][j];
                if (j - coins[i] &gt;= 0) {
                    dp[i][j] += dp[i][j - coins[i]];
                }
            }
        }
        return dp[len - 1][amount];
    }
}
</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(NM)，这里金额为 M，硬币数为 N。与参考代码 1 相比缩减了最内层的循环，时间复杂度降低了一级。<br>
空间复杂度：O(NM)，表格有 N 行，M 列。</p>
</blockquote>
<blockquote>
<p>第 5 步：考虑状态压缩<br>
这个方法只是优化了状态转移方程，因此，我们直接跳到第 5 步，考虑状态压缩。<br>
参考代码 3：</p>
</blockquote>
<pre><code>Java
public class Solution {

    public int change(int amount, int[] coins) {
        int len = coins.length;
        if (len == 0) {
            if (amount == 0) {
                return 1;
            }
            return 0;
        }

        int[] dp = new int[amount + 1];
        dp[0] = 1;

        for (int i = coins[0]; i &lt;= amount; i += coins[0]) {
            dp[i] = 1;
        }

        for (int i = 1; i &lt; len; i++) {
            
            // 从 coins[i] 开始即可
            for (int j = coins[i] ; j &lt;= amount; j++) {
                dp[j] += dp[j - coins[i]];
            }
        }
        return dp[amount];
    }
}
</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(NM)，这里金额为 M，硬币数为 N。<br>
空间复杂度：O(M)，表格只有 1 行，M 列。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[类型萃取type-traits]]></title>
        <id>https://lixin-scut.github.io//post/lei-xing-cui-qu-type-traits</id>
        <link href="https://lixin-scut.github.io//post/lei-xing-cui-qu-type-traits">
        </link>
        <updated>2020-03-22T11:45:00.000Z</updated>
        <content type="html"><![CDATA[<h3 id="类型萃取的作用">类型萃取的作用</h3>
<p>  类型萃取使用模板技术来萃取类型(包含自定义类型和内置类型)的某些特性，用以判断该类型是否含有某些特性，从而在泛型算法中来对该类型进行特殊的处理用来提高效率或者其他。<br>
  例如:在STL中的destory算法根据函数的参数类型的特性:是否有trivial destructor来选择对应的策略来进行destory，如果为内置类型，则不调用该类型的destructor，否则对迭代器范围内的对象调用destructor来进行destory。</p>
<h3 id="sgi-stl中type-traits可以萃取的类型属性">SGI-STL中type traits可以萃取的类型属性</h3>
<p>在SGI-STL中，可以萃取的类型属性如下:<br>
1: has_trivial_default_constructor<br>
2: has_trivial_copy_constructor<br>
3: has_trivial_assignment_operator<br>
4: has_trivial_destructor<br>
5: is_POD_type</p>
<h3 id="stl源码剖析">《STL源码剖析》</h3>
<p>  迭代器所指对象的型别，称为该迭代器的value type。模板template的参数型别推导技巧虽然可用于value type,却非全面可用：万一 value type必须用于函数的传回值，就束手无策了，毕竟函数的&quot;template参数推导机制”推而导之的只是参数，无法推导函数的回返值型别。<br>
<img src="https://lixin-scut.github.io//post-images/1584878499604.png" alt=""><br>
  但是上述方法有个隐晦的陷阱：并不是所有迭代器都是class type<br>
原生指针就不是，如果不是class type,就无法为它定义内嵌型别。但STL (以及整个泛 型思维)绝对必须接受原生指针作为一种迭代器，所以上面这样还不够。</p>
<p>  template partial specialization 可以让上述的一般化概念针对特定情况(例如针对原生指针)做特殊化处理</p>
<p><strong>Partial Specialization (偏特化)的意义</strong><br>
  如果class template拥有一个以上的 template参数，我们可以针对其中某个(或数个，但非全部)template参数进行特化工作。<br>
  我们可以在泛化设计中提供一个特化版本（也就是将泛化版本中的某些template参数赋予明确的指定）。<br>
  partial specialization的字面意义容易误导我们以为，所谓“偏特化版” 一定 是对template参数u或v或T（或某种组合）指定某个参数值。其实不然,对于 partial specialization 的意义说得十分得体：“所谓 partial specialization 的 意思是提供另一份template定义式，而其本身仍为templatized<br>
  对partial specialization的定义是：“针对（任何）template参数<strong>更进一步的条件限制</strong>所设计出来的一个特化版本”。<br>
<img src="https://lixin-scut.github.io//post-images/1584878670205.png" alt=""><br>
  有了偏特化，我们便可以解决前述“内嵌型别”未能解决的问题。<br>
  先前的问题是原生指针并非class，因此无法为它们定义内嵌型别。现在我们可以针对“迭代器之template参数为指针”者，设计特化版的迭代器。<br>
下面这个class template专门用来“萃取” 迭代器的特性，而value type正是迭代器的特性之一：</p>
<pre><code>template &lt;class I&gt;
struct iterator_traits   / / traits 意为 &quot;特性”
{	
typedef typename I::value_type value_type； 
};
</code></pre>
<p>  这个所谓的traits,其意义是，如果I定义有自己的value type,那么通过这个traits的作用，萃取出来的value_type就是 I::value_type。 换句话说， 如果I定义有自己的value type,先前那个 func() 可以改写成这样：</p>
<pre><code>template &lt;class I&gt;
typename iterator_traits&lt;I&gt;::value_type // 这一整行是函数回返型别
func(I ite)
{  return *ite; }
</code></pre>
<p>  除了多一层间接性,好处是traits可以拥有特化版本。<br>
令 iterator_traites 拥有一个 partial specializations 如下：</p>
<pre><code>template &lt;class T&gt;
struct iterator_traits&lt;T*&gt;  //偏特化版	迭代器是个原生指针
{
typedef T value_type;
);
</code></pre>
<p>于是，原生指针int*虽然不是一种class type,亦可通过traits取其value type.这就解决了先前的问题。</p>
<p>注意，针对“指向常数对象的指针(pointer-to-const) ”，下面这个式子<br>
<code>iterator_traits&lt;const int*&gt;::value_type</code><br>
获得的是const int而非int，这是我们期望的吗？我们希望利用这种机制来声明一个暂时变量，使其型别与迭代器的value type相同，而现在，声明一个无法赋值 (因 const 之故)的暂时变量没什么用,因此如果迭代器是个pointer_to_const, 我们应该设法令其value type为一个non-const型别。没问题, 只要另外设计一个特化版本，就能解决这个问题：</p>
<pre><code>template &lt;class T&gt;
struct iterator_traits&lt;const T*&gt; //偏特化版	当迭代器是个 pointe_to_const 时,
{ 
 typedef T value_type ；	//萃取出来的型别应该是T而非const T
};
</code></pre>
<p>  现在，不论面对的是迭代器My iter,或是原生指针<code>int*</code>或<code>const int*</code>, 都可以通过traits取出正确的(我们所期望的)value type</p>
<p>  图3-1说明了 traits所扮演的“特性萃取机”角色，萃取各个迭代器的特性。 这里所谓的迭代器特性，指的是迭代器的相应型别(associated types)。当然，若要这个特性萃取机ntraits能够有效运作，每一个迭代器必须遵循约定，自行以内嵌型别定义(nested typedef)的方式定义出相应型别(associated types)。<br>
<img src="https://lixin-scut.github.io//post-images/1584879350263.png" alt=""><br>
最常用到的迭代器相应型别有五种：value type, difference type,pointer,reference, iterator catagoly。如果你希望你所开发的容器能与STL相容，一定要为你的容器的迭代器定义这五种相应型别</p>
<pre><code>template &lt;class I&gt;
struct iterator_trattb {
typedef typename I::iterator_category   iterator_category;
typedef typename I::value_type          value_type；
typedef typename I::difference_type     difference_type;
typedef typename I::pointer             pointer;
typedef typename I::reference           reference
};
</code></pre>
<p>  iterator_traits 必须针对传入之型别为 pointer 及 pointer-to-const 者, 设计特化版本</p>
<h3 id="value-type">value type</h3>
<p>  所谓value type,是指迭代器所指对象的型别，任何一个打算与STL算法有完美搭配的class,都应该定义自己的value type内嵌型别。</p>
<h3 id="difference-type">difference type</h3>
<p>  difference type用来表示两个迭代器之间的距离，因此它也可以用来表示一个容器的最大容量，因为对于连续空间的容器而言，头尾之间的距离就是其最大容量。 如果一个泛型算法提供计数功能，例如STL的count(),其传回值就必须使用迭代器的 difference type：</p>
<pre><code>template &lt;class I, class T&gt;
typename iterator_traits&lt;I&gt;::difference_type // 这一整行是函数回返型别 
count(I first, I last, const T&amp; value) 
{
	for ( ; first != last ; ++first)
		if (*first == value)
			++n;
	return n;
}
</code></pre>
<p>  针对相应型别difference type, traits的如下两个(针对原生指针而写的)特化版本，以C++内建的ptrdiff_t (定义于<code>&lt;cstddef&gt;</code>头文件)作为原生指针的 difference type：</p>
<pre><code>template &lt;class I&gt;
struct iterator_traits 
{
	...
	typedef typename I::difference_type difference_type；
	};
	
// 针对原生指针而设计的偏特化(partial specialization)版
template &lt;class T&gt; 
struct iterator_traits&lt;T*&gt; 
{
	...
	typedef ptrdiff_t	difference_type;
};
// 针对原声的pointer-to-const而设计的偏特化(partial specialization)版
template &lt;class T&gt; 
struct iterator_traits&lt;const T*&gt; 
{
	...
	typedef ptrdiff_t	difference_type;
};
</code></pre>
<p>现在，任何时候当我们需要任何迭代器I的difference type ,可以这么写:<br>
<code>typename iterator_traits&lt;I&gt;::difference_type</code></p>
<h3 id="reference-type">reference type</h3>
<p>  从“迭代器所指之物的内容是否允许改变”的角度观之，迭代器分为两种：<br>
不允许改变“所指对象之内容”者，称为constant iterators,例如 const int* pic；<br>
允许改变&quot;所指对象之内容”者，称为mutable iterators,例如int* pi<br>
  当我们对一个mutable iterators进行提领操作时，获得的不应该是一个右值(rvalue),应该是一个左值(lvalue),因为右值不允许赋值操作(assignment),左值才允许.<br>
  在C++中，函数如果要传回左值，都是以by reference的方式进行，所以当 p是个mutable iterators时,如果其value type是T,那么*p的型别不应该是T, 应该是t&amp;°将此道理扩充，如果p是一个constant iterators,其value type是t, 那么*p的型别不应该是 const T, 而应该是 const T&amp;。 这里所讨论的*P的型 别，即所谓的reference type 。</p>
<h3 id="pointer-type">pointer type</h3>
<p>  pointers和references在C++中有非常密切的关联。如果“传回一个左值，令它代表P所指之物”是可能的，那么“传回一个左值，令它代表P所指之物的地址”也一定可以。也就是说，我们能够传回一个pointer,指向迭代器所指之物</p>
<pre><code>Item&amp; operator*() const { return *ptr; }
Item* operator-&gt;() const { return ptr; }
</code></pre>
<p>item&amp; 便是 Listlter 的 reference type,而 item* 便是其 pointer type<br>
<img src="https://lixin-scut.github.io//post-images/1584880412269.png" alt=""></p>
<h3 id="iterator_category">iterator_category</h3>
<p>根据移动特性与施行操作，迭代器被分为五类:<br>
  •	Input Iterator：这种迭代器所指的对象，不允许外界改变。只读（readonly）。<br>
  •	Output Iterator：唯写（write only）。<br>
  •	Forward Iterator：允许“写入型”算法，在此种迭代器所形成的区间上进行读写操作。<br>
  •	Bidirectional Iterator：可双向移动。某些算法需要逆向走访某个迭代器区间，可以使用Bidirectional Iterators。<br>
  •	Random Access Iterator：前四种迭代器都只供应一部分指针算术能力（前三种支持 operator++, 第四种再加上 operator--）, 第五种则涵盖所有指针 算术能力，包括 <code>p+n, p-n, p[n], p1-p2, p1&lt;p2</code><br>
<img src="https://lixin-scut.github.io//post-images/1584880509062.png" alt=""></p>
]]></content>
    </entry>
</feed>