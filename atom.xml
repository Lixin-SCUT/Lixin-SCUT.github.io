<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-11-26T23:41:18.759Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[C++ primer 第十七章 笔记+习题 17.5]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-qi-zhang-bi-ji-xi-ti-175</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-qi-zhang-bi-ji-xi-ti-175">
        </link>
        <updated>2019-11-26T12:45:18.000Z</updated>
        <content type="html"><![CDATA[<p>17.5 IO库再探<br>
17.5.1 格式化输入和输出<br>
除了条件状态外（参见8.1.2节，第279页），每个 iostream 对象还维护一个<strong>格式状态</strong>来控制 IO 如何格式化的细节。格式状态控制格式化的某些方面，如整型值是几进制、浮点值的精度、一个输出元素的宽度等。<br>
标准库定义了<strong>一组操纵符</strong>( manipulator )(参见1.2节，第6页）来<strong>修改流的格式状态</strong>，如表17.7和表17.8所示。一个操纵符是<strong>一个函数</strong>或是<strong>一个对象</strong>，会影响流的状态，并能用作输入或输出运算符的运算对象。类似输入和输出运算符，操纵符也<strong>返回它所处理的流对象</strong>，因此我们可以在一条语句中组合操纵符和数据。</p>
<p>操纵符用于<strong>两大类输出控制</strong>：控制<strong>数值的输出形式</strong>以及控制<strong>补白的数量和位置</strong>。大多数改变格式状态的操纵符都是<strong>设置/复原成对</strong>的;一个操纵符用来将格式状态设置为一个新值，而另一个用来将其复原，恢复为正常的默认格式。<br>
当操纵符改变流的格式化态时，通常改变后的状态对所有<strong>后续 IO 都生效。</strong></p>
<p>默认情况下，整型值的输入输出使用十进制。我们可以使用<strong>操纵符 hex 、 oct 和 dec</strong>将其改为<strong>十六进制、八进制或是改回十进制</strong>：<br>
注意，类似 boolalpha ,这些操纵符也会改变格式状态。它们会<strong>影响下一个和随后所有的整型输出</strong>，直至另一个操纵符又改变了格式为止。<br>
操纵符 hex 、 oct 和 dec 只影响整型运算对象，<strong>浮点值的表示形式不受影响</strong>。</p>
<p>如果需要打印八进制值或十六进制值，应该使用** showbase 操纵符**。当对流应用 showbase 操纵符时，<strong>会在输出结果中显示进制</strong>，它遵循与整型常量中指定进制相同的规范：<br>
•前导0x表示十六进制。<br>
•前导0表示八进制。<br>
•无前导字符串表示十进制。</p>
<p>操纵符 noshowbase 恢复 cout 的状态，从而不再显示整型值的进制。<br>
默认情况下，十六进制值会以小写打印，前导字符也是小写的 X 。 我们可以通过使用uppercase 操纵符来输出大写的 X 并将十六进制数字 a-f以大写输出：<br>
使用操纵符 nouppercase 、 noshowbase 和 dec 来重置流的状态。</p>
<p>•以多高精度（多少个数字）打印浮点值<br>
•数值是打印为十六进制、定点十进制还是科学记数法形式<br>
•对于没有小数部分的浮点值是否打印小数点<br>
<strong>默认情况下</strong>，<strong>浮点值</strong>按<strong>六位数字精度</strong>打印；如果浮点值<strong>没有小数部分，则不打印小数点</strong>：根据浮点数的<strong>值</strong>选择打印成<strong>定点十进制</strong>或<strong>科学记数法</strong>形式。标准库会选择一种可读性更好的格式：<strong>非常大和非常小</strong>的值打印<strong>为科学记数法</strong>形式，<strong>其他值</strong>打印为定点<strong>十进制</strong>形式。<br>
<strong>默认情况下</strong>，精度会<strong>控制打印的数字的总数</strong>。当打印时，浮点值按当前<strong>精度舍入</strong>而<strong>非截断</strong>。因此，如果当前精度为四位数字，则 3.14159将打印为3.142;如果精度为三位数字，则打印为3.14。</p>
<p>除非你需要控制浮点数的表示形式（如，按列打印数据或打印表示金额或百分比的数据），否则<strong>由标准库选择记数法是最好的方式</strong>。</p>
<p>默认情况下，当一个浮点值的小数部分为0时，不显示小数点。 showpoint 操纵符强制打印小数点：</p>
<p>当按列打印数据时，我们常常需要非常精细地控制数据格式。标准库提供了一些操纵符帮助我们完成所需的控制：</p>
<p>默认情况下，输入运算符会忽略空白符（空格符、制表符、换行符、换纸符和回车符)。<br>
操纵符 noskipws 会令输入运算符读取空白符，而不是跳过它们。为了恢复默认行为， 我们可以使用 skipws 操纵符</p>
<p>习题17.34</p>
<pre><code>int main() {
	cout &lt;&lt; noboolalpha &lt;&lt; true &lt;&lt; &quot; &quot; &lt;&lt; boolalpha &lt;&lt; true &lt;&lt; endl;
	cout &lt;&lt; hex &lt;&lt; 20 &lt;&lt;&quot; &quot;&lt;&lt; showbase &lt;&lt; 20 &lt;&lt; endl&lt;&lt;dec;
	cout &lt;&lt; 1.000000000000000 &lt;&lt;&quot; &quot;&lt;&lt; showpoint &lt;&lt; 1.00000000000000 &lt;&lt; endl;
	cout &lt;&lt; 1 &lt;&lt; &quot; &quot; &lt;&lt; showpos &lt;&lt;1 &lt;&lt; endl;

	cout &lt;&lt; setfill('#') &lt;&lt; &quot;i:&quot; &lt;&lt; setw(12) &lt;&lt; 16  &lt;&lt; endl ;
}
</code></pre>
<p>习题17.35</p>
<pre><code>int main() {
	cout &lt;&lt; hexfloat &lt;&lt;uppercase&lt;&lt; sqrt(2.0) &lt;&lt; endl;
}
</code></pre>
<p>习题17.36</p>
<pre><code>int main() {
	cout &lt;&lt; hexfloat &lt;&lt;uppercase&lt;&lt;internal&lt;&lt; sqrt(2.0) &lt;&lt; endl;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ C++ primer 第十六章 笔记+习题 16.5]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-liu-zhang-bi-ji-xi-ti-165</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-liu-zhang-bi-ji-xi-ti-165">
        </link>
        <updated>2019-11-26T08:45:31.000Z</updated>
        <content type="html"><![CDATA[<p>16.5 模板特例化<br>
<strong>当我们不能使用模板或者想制定特定的函数时就特例化，但其本质还是实例化</strong> 一个<strong>特例化版本</strong>就是模板的一个<strong>独立的定义</strong>，在<strong>其中一个或多个模板参数</strong>被指定为<strong>特定的类型</strong>。<br>
当我们特例化一个函数模板时，必须为原模板中的<strong>每个模板参数都提供实参</strong>。为了指出我们正在实例化一个模板，应使用<strong>关键字 template 后</strong>跟一个<strong>空尖括号对（&lt;&gt;）</strong>。空尖括号指出我们将为原模板的所有模板参数提供实参：</p>
<p>理解此特例化版本的困难之处是函数参数类型。当我们定义一个特例化版本时，函数参数类型必须与一个<strong>先前声明的模板中对应的类型匹配</strong>。本例中我们特例化：</p>
<p>当定义函数模板的特例化版本时，我们本质上接管了编译器的工作。即，我们为原模板的一个特殊实例提供了定义。重要的是要弄清：一个特例化版本本质上是一个实例，而非函数名的一个重载版本。<br>
特例化的<strong>本质是实例化一个模板</strong>，<strong>而非重载它</strong>。因此，特例化<strong>不影响函数匹配</strong><br>
我们将一个特殊的函数定义为一个<strong>特例化版本</strong>还是一个<strong>独立的非模板函数</strong>，会<strong>影响到函数匹配</strong>。</p>
<p>为了特例化一个模板，原模板的<strong>声明必须在作用域</strong>中。而且，在任何使用模板实例替代码之前，特例化版本的声明也必须在作用域中。<br>
对于普通类和函数，<strong>丢失声明的情况（通常）很容易发现</strong>——编译器将不能继续处理我们的代码。但是，如果丢失了一个特例化版本的声明，编译器通常可以用原模板生成代码。由于在丢失特例化版本时编译器通常会实例化原模板，很容易产生模板及其特例化版本声明顺序导致的错误，而这种错误又很难查找。<br>
如果一个程序使用一个特例化版本，而同时原模板的一个实例具有相同的模板实参集合，就会产生错误。但是，这种错误编译器又无法发现。<br>
<strong>模板</strong>及其<strong>特例化版本</strong>应该<strong>声明在同一个头文件中</strong>。所有<strong>同名模板的声明</strong>应该放在<strong>前面</strong>，<strong>然后是这些模板的特例化版本。</strong><br>
除了特例化函数模板，我们还可以<strong>特例化类模板</strong>。</p>
<p>在定义此特例化版本的 hash 时，唯一复杂的地方是：必须在<strong>原模板定义所在的命名空间中特例化它</strong>。</p>
<p>类似其他任何类，我们可以在<strong>类内或类外定义特例化版本的成员</strong>，本例中就是在类外定义的。重载的调用运算符必须为给定类型的值定义一个哈希函数。对于一个给定值，任何时候调用此函数都应该返回相同的结果。一个好的哈希函数对不相等的对象（几乎总是）应该产生不同的结果。<br>
假定我们的特例化版本在作用域中，当将 Sales _ data 作为容器的关键字类型时，<strong>编译器就会自动使用此特例化版本</strong>：<br>
为了使Sales_data 的用户能够使用hash 的特例化版本，我们应该在Sales_data 的<strong>头文件中定义该特例化版本</strong>。</p>
<p>与函数模板<strong>不同</strong>，<strong>类模板的特例化不必为所有模板参数提供实参</strong>。我们可以<strong>只指定一部分</strong>而非所有模板参数，或是参数的一部分而非全部特性。一个<strong>类模板</strong>的<strong>部分特例化</strong>(partial specialization )<strong>本身是一个模板</strong>，使用它时用户还必须为那些在特例化版本中未指定的模板参数提供实参<br>
我们<strong>只能部分特例化类模板，而不能部分特例化函数模板</strong>。</p>
<p>由于一个<strong>部分特例化版本本质是一个模板</strong>，与往常一样，我们首先定义模板参数。类似任何其他特例化版本，部分特例化版本的名字与原模板的名字相同。对每个未完全确定类型的模板参数，在特例化版本的模板参数列表中都有一项与之对应。在类名之后，我们为要特例化的模板参数指定实参，这些实参列于模板名之后的尖括号中。这些实参与原始模板中的参数按位置对应。<br>
部分特例化版本的模板参数列表是原始模板的参数列表的<strong>一个子集</strong>或者是<strong>一个特例化版本</strong>。<br>
我们<strong>可以只特例化特定成员函数</strong>而不是特例化整个模板。</p>
<p>习题16.62</p>
<pre><code>namespace std {
	template&lt;&gt;
	struct hash&lt;Sales_Data&gt;
	{
		typedef size_t result_type;
		typedef Sales_Data argument_type;
		size_t operator()(const Sales_Data &amp;s)const;
	};
	size_t hash&lt;Sales_Data&gt;::operator()(const Sales_Data &amp;s)const {
		return hash&lt;string&gt;()(s.ISBN) ^ hash&lt;unsigned&gt;()(s.units_sold) ^ hash&lt;double&gt;()(s.ave);

	}
}
</code></pre>
<p>习题16.63+16.64</p>
<pre><code>template &lt;typename T&gt;
int countv(vector&lt;T&gt; &amp;vt,T t) {
	int count=0;
	for (auto i : vt)
		if (i == t)
			++count;
	return count;
}
template&lt;&gt;
int countv(vector&lt;const char*&gt;&amp;vt, const char *t) {
	int count = 0;
	for (auto i : vt)
		if (i == t)
			++count;
	return count;
};
int main() {
	vector&lt;string&gt; vs{ &quot;123&quot;,&quot;456&quot;,&quot;789&quot;,&quot;123&quot; };
	vector&lt;int&gt; vi{ 1,2,3,4,5,1,2,3,1,2 };
	vector&lt;double&gt; vd{ 1.0,2.0,3.0,1.0 };
	cout &lt;&lt; countv(vs, string(&quot;123&quot;)) &lt;&lt; endl;
	cout &lt;&lt; countv(vi, 1) &lt;&lt; endl;
	cout &lt;&lt; countv(vd, 1.0) &lt;&lt; endl;
	vector&lt;const char*&gt; vc{ &quot;123&quot;,&quot;456&quot;,&quot;789&quot;,&quot;123&quot; };
	cout &lt;&lt; countv(vc, &quot;123&quot;) &lt;&lt; endl;
}
</code></pre>
<p>注意 	cout &lt;&lt; countv(vs, string(&quot;123&quot;)) &lt;&lt; endl;中 &quot;123&quot;属于<code>const char[]</code>，所以是无法直接和vs的string匹配的，必须用string来构造临时变量</p>
<p>习题16.65</p>
<pre><code>template&lt;&gt; string debug_rep(const char *p) {
	ostringstream ret;
	ret &lt;&lt; &quot;const char *p&quot;&lt;&lt;&quot; &quot;;
	ret &lt;&lt; &quot;pointer:&quot; &lt;&lt; p;
	if (p)
		ret &lt;&lt; &quot; &quot; &lt;&lt; *p;
	else
		ret &lt;&lt; &quot;null pointer&quot;;
	return ret.str();
}

template&lt;&gt; string debug_rep(char *p) {
	ostringstream ret;
	ret &lt;&lt; &quot;char *p&quot; &lt;&lt; &quot; &quot;;
	ret &lt;&lt; &quot;pointer:&quot; &lt;&lt; p;
	if (p)
		ret &lt;&lt; &quot; &quot; &lt;&lt; *p;
	else
		ret &lt;&lt; &quot;null pointer&quot;;
	return ret.str();
}
int main() {
	auto c = &quot;123&quot;;
	cout&lt;&lt;debug_rep(c)&lt;&lt;endl;
	char *cc = &quot;123&quot;;
	cout &lt;&lt; debug_rep(cc) &lt;&lt; endl;
}
</code></pre>
<p>注意：特例化的话本质上是模板的实例化，所以只需要模板的声明，而不需要模板的定义（注意区分模板的定义和实例化之间的区别）</p>
<p>习题16.66+16.67<br>
特例化能够保留原来的模板，保证较高的通用性，但是同时容易因为声明顺序或者代码错误出现调用了非目标的实例化函数。<br>
<strong>重载会改变匹配优先度，而特例化则不会</strong><br>
特例化的<strong>本质是实例化一个模板</strong>，<strong>而非重载它</strong>。因此，特例化<strong>不影响函数匹配</strong></p>
<p>习题感悟<br>
注意 	cout &lt;&lt; countv(vs, string(&quot;123&quot;)) &lt;&lt; endl;中 &quot;123&quot;属于<code>const char[]</code>，所以是无法直接和vs的string匹配的，必须用string来构造临时变量<br>
注意：特例化的话本质上是模板的实例化，所以只需要模板的声明，而不需要模板的定义（注意区分模板的定义和实例化之间的区别）<br>
特例化的<strong>本质是实例化一个模板</strong>，<strong>而非重载它</strong>。因此，特例化<strong>不影响函数匹配</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ C++ primer 第十六章 笔记+习题 16.4]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-liu-zhang-bi-ji-xi-ti-164</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-liu-zhang-bi-ji-xi-ti-164">
        </link>
        <updated>2019-11-26T01:39:00.000Z</updated>
        <content type="html"><![CDATA[<p>16.4可变参数模板<br>
一个可变参数模板(variadic template)就是一个<strong>接受可变数目参数</strong>的模板函数或模板类。可变数目的参数被称为<strong>参数包</strong>（parameterpacket)。存在两种参数包：模板参数包(template parameter packet),表示零个或多个模板参数；函数参数包（functionparameterpacket)，表示零个或多个函数参数。<br>
我们用一个<strong>省略号（一定必须是三个点，注意细节如何输入）</strong> 来指出一个模板参数或函数参数表示一个包，在一个模板参数列表中， <strong>class ...或 typename ...</strong> 指出接下来的参数表示零个或多个类型的列表：<br>
1.一个<strong>类型名后面跟一个省略号</strong>表示<strong>零个</strong>或多个给定类型的非类型参数的列表。<br>
2.在函数参数列表中，如果一个<strong>参数的类型</strong>是一个<strong>模板参数包</strong>，则此<strong>参数</strong>也是一个<strong>函数参数包</strong>。</p>
<p>声明了 foo 是一个可变参数函数模板，它有一个名为 T 的类型参数，和一个名为 Args的模板参数包。这个包表示零个或多个额外的类型参数。foo 的函数参数列表包含一个const &amp;类型的参数，指向 T 的类型，还包含一个名为 rest 的函数参数包，此包表示零个或多个函数参数。</p>
<p>当我们<strong>需要知道包中有多少元素</strong>时，可以使用** sizeof ...运算符**，sizeof ...也返回一个常量表达式<br>
cout&lt;&lt;sizeof…(Args)<br>
<strong>注意必须是在模板内部调用，而不是在函数外部调用</strong></p>
<p>习题16.51+52</p>
<pre><code>template&lt;typename T,typename... Args&gt;
void foo(const T &amp;t, const Args&amp;...rest) {
	cout&lt;&lt;sizeof...(Args)&lt;&lt;endl;
	cout &lt;&lt; sizeof...(rest) &lt;&lt; endl;
}
int main() {
	foo(123, &quot;123&quot;, 123, 123);
	foo(&quot;123&quot;, 123, &quot;12&quot;);
	foo(123,&quot;123&quot;);
	foo(&quot;12&quot;);
}
</code></pre>
<p>16.4.1 编写可变参数函数模板<br>
我们可以使用一个 <strong>initializer _ list</strong> 来定义一个可接受<strong>可变数目实参的函数</strong>。但是，所有实参<strong>必须具有相同的类型</strong>（或它们的类型可以转换为同一个公共类型）。当我们既不知道想要处理的实参的数目也不知道它们的类型时，可变参数函数是很有用的。<br>
可变参数函数<strong>通常是递归的</strong>（参见6.3.2节，第204页）。<strong>第一步调用处理</strong>包中的<strong>第一个实参</strong>，然后用<strong>剩余实参调用自身</strong>。我们的 <strong>print</strong>函数也是这样的模式，每次递归调用将<strong>第二个实参打印</strong>到<strong>第一个实参</strong>表示的<strong>流中</strong>。为了<strong>终止递归</strong>.我们还需要<strong>定义一个非可变参数</strong>的 print 函数，它接受一个流和一个对象</p>
<p>当定义可变参数版本的print时，<strong>非可变参数版本的声明必须在作用域中</strong>，否则，可变参数版本会<strong>无限递归</strong></p>
<p>习题16.53</p>
<pre><code>template &lt;typename T&gt; 
ostream &amp;print(ostream &amp;os, const T &amp;t) {
	return os &lt;&lt; t;
}
template&lt;typename T,typename...Args&gt;
ostream&amp; print(ostream &amp;os,T &amp;t, Args&amp;...rest) {
	os &lt;&lt; t&lt;&lt;&quot;,&quot;;
	return print(os, rest...);
}
</code></pre>
<p>注意 递归调用时需要用rest...来扩展可变参数列表作为实参<br>
习题16.54<br>
显示缺少&lt;&lt;定义<br>
习题16.55<br>
在可变参数版本眼中是看不到非可变参数版本的声明的，导致陷入无限调用自身递归，最后内存耗尽</p>
<p>16.4.2 包扩展<br>
对于一个参数包，<strong>除了获取其大小</strong>外，我们能对它做的<strong>唯一</strong>的事情就是<strong>扩展 （expand)<strong>它。当扩展一个包时，我们还要提供用于每个扩展元素的模式 （pattern )。 扩展一个包就是将它</strong>分解为构成的元素</strong>，对每个元素应用模式，获得扩展后的列表。我们通过<strong>在模式右边放一个省略号（...）来触发扩展操作。</strong></p>
<p>对 Args 的扩展中，编译器将模式 constArg &amp;应用到模板参数包 Args 中的每个元素。此，此模式的扩展结果是一个逗号分隔的零个或多个类型的列表，每个类型都形如const type&amp;<br>
第二个扩展发生在对 print 的（递归）调用中。在此情况下，模式是函数参数包的名字（即 rest )。此模式扩展出一个由包中元素组成的、逗号分隔的列表。</p>
<p>print 中的函数包扩展仅仅将包扩展为其构成元素， C ++语言还允许更复杂的扩展模式。例如，我们可以编写第二个可变参数函数，<strong>对其每个实参调用 debug_rep</strong> (参见16.3节，第615页），然后调用 print 打印结果 string</p>
<p><strong>注意符号的位置 是debug_rep(rest)…而不是debug_rep(rest…)，后者等于在debug_rep的形参中扩展了rest<br>
<strong>此模式表示我们希望对函数参数包 rest 中的</strong>每个元素</strong>调用 debug_rep</p>
<p>扩展中的模式会独立地应用于包中的每个元素。</p>
<p>习题16.56</p>
<pre><code>ostream &amp;errorMsg(ostream &amp;os, const Args&amp;...rest) {
	return print(os, debug_rep(rest)...);
}
</code></pre>
<p>习题16.57<br>
参数列表版本的只能定义同一类型的形参，可变参数列表的可以多种类型<br>
使用参数初始化列表initializer list也可以定义一个可接受可变参数数目的函数，但是所有的实参都必须具有相同的类型（或者可转变为相同的类型）</p>
<p>16.4.3 转发参数包<br>
<strong>保持类型信息</strong>是一个<strong>两阶段</strong>的过程。<strong>首先</strong>，为了保持实参中的类型信息，必须将 emplace_back 的函数参数<strong>定义为</strong>模板类型参数的<strong>右值引用</strong>（參见16.2.7节，第613页）：</p>
<p><strong>其次</strong>，当 emplace _ back 将这些实参传递给 construct 时，我们<strong>必须使用 forward</strong>来保持<strong>实参的原始类型</strong>（参见16.2.7节，第614页）；</p>
<p>习题16.58</p>
<pre><code>template&lt;class...Args&gt;
inline void StrVec::emplace_back(Args&amp;&amp;... args) {
	chk_n_alloc();
	alloc.construct(first_free++, std::forward&lt;Args&gt;args...);
}
</code></pre>
<p>习题16.59<br>
s作为参数被转发<br>
习题16.60<br>
接受可变参数模板，转发其参数初始化一个内存于内存空间，返回一个shared_ptr<br>
习题16.61<br>
其实和emplace比较像啦，接受可变参数目标然后new新的对象返回shared_ptr</p>
<p>习题感悟：<br>
注意 递归调用时需要用rest...来扩展可变参数列表作为实参</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 236. 二叉树的最近公共祖先[中等]]]></title>
        <id>https://lixin-ee.github.io//post/shu-236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/shu-236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-zhong-deng">
        </link>
        <updated>2019-11-26T01:06:37.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。<br>
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”<br>
例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]<br>
示例 1:<br>
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>
输出: 3<br>
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。<br>
示例 2:<br>
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br>
输出: 5<br>
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。<br>
说明:<br>
所有节点的值都是唯一的。<br>
p、q 为不同节点且均存在于给定的二叉树中。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>谁能想到我刚在235题惋惜自己把简单的问题复杂化了，欣慰自己写了个通用模板的时候，下一题马上就用上了这个通用模板<br>
世事无常啊hhh</p>
<pre><code>class Solution {
public:
    bool get=false;
    TreeNode *res=NULL;
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        preorder(root,p,q);
        return res;
    }
    
    bool preorder(TreeNode* cur,TreeNode* p, TreeNode* q){
        if(cur==NULL)
            return false;
        if(get)
            return false;
        bool l=preorder(cur-&gt;left,p,q);
        bool r=preorder(cur-&gt;right,p,q);
        if(!get&amp;&amp;l&amp;&amp;r){
            get=true;
            res=cur;
            return false;
        }
        if(!get&amp;&amp;(l||r)&amp;&amp;(cur==p||cur==q)){
            get=true;
            res=cur;
            return false;
        }
        return (cur==p||cur==q)||l||r;  
    }
};
</code></pre>
<p>先看网友题解：</p>
<blockquote>
<p>在左、右子树中分别查找是否包含p或q：<br>
如果以下两种情况（左子树包含p，右子树包含q/左子树包含q，右子树包含p），那么此时的根节点就是最近公共祖先<br>
如果左子树包含p和q，那么到root-&gt;left中继续查找，最近公共祖先在左子树里面<br>
如果右子树包含p和q，那么到root-&gt;right中继续查找，最近公共祖先在右子树里面</p>
</blockquote>
<pre><code>TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == nullptr || root == p || root == q){return root; }
        TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);
        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);
        return left == nullptr? right : (right == nullptr? left : root); 
   }
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>解决方法：<br>
首先在二叉树中搜索给定的节点 p 和 q，然后找到它们的最近共同祖先。我们可以使用普通的树遍历来搜索这两个节点。一旦我们达到所需的节点 p 和 q，我们就可以回溯并找到最近的共同祖先。<br>
方法一：递归<br>
这种方法非常直观。先深度遍历改树。当你遇到节点 p 或 q 时，返回一些布尔标记。该标志有助于确定是否在任何路径中找到了所需的节点。最不常见的祖先将是两个子树递归都返回真标志的节点。它也可以是一个节点，它本身是p或q中的一个，对于这个节点,子树递归返回一个真标志<br>
让我们看看基于这个想法的形式算法。<br>
算法：<br>
从根节点开始遍历树。<br>
如果当前节点本身是 p 或 q 中的一个，我们会将变量 mid 标记为 true，并继续搜索左右分支中的另一个节点。<br>
如果左分支或右分支中的任何一个返回 true，则表示在下面找到了两个节点中的一个。<br>
如果在遍历的任何点上，左、右或中三个标志中的任意两个变为 true，这意味着我们找到了节点 p 和 q 的最近公共祖先。<br>
让我们看一个示例，然后搜索树中两个节点 9 和 11 的最近公共祖先。<br>
以下是递归中遵循的节点序列：<br>
1 --&gt; 2 --&gt; 4 --&gt; 8<br>
回溯 8 --&gt; 4<br>
4 --&gt; 9 (找到一个节点，返回true)<br>
回溯 9 --&gt; 4 --&gt; 2<br>
2 --&gt; 5 --&gt; 10<br>
回溯 10 --&gt; 5<br>
5 --&gt; 11 (找到另一个节点，返回true)<br>
回溯 --&gt; 5 --&gt; 2<br>
在2节点这里我们有左边=true，右边=true，因此 2 节点是它们的最近公共祖先</p>
</blockquote>
<pre><code>class Solution {

    private TreeNode ans;

    public Solution() {
        // Variable to store LCA node.
        this.ans = null;
    }

    private boolean recurseTree(TreeNode currentNode, TreeNode p, TreeNode q) {

        // If reached the end of a branch, return false.
        if (currentNode == null) {
            return false;
        }

        // Left Recursion. If left recursion returns true, set left = 1 else 0
        int left = this.recurseTree(currentNode.left, p, q) ? 1 : 0;

        // Right Recursion
        int right = this.recurseTree(currentNode.right, p, q) ? 1 : 0;

        // If the current node is one of p or q
        int mid = (currentNode == p || currentNode == q) ? 1 : 0;


        // If any two of the flags left, right or mid become True
        if (mid + left + right &gt;= 2) {
            this.ans = currentNode;
        }

        // Return true if any one of the three bool values is True.
        return (mid + left + right &gt; 0);
    }

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // Traverse the tree
        this.recurseTree(root, p, q);
        return this.ans;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(N)，N 是二叉树中的节点数，最坏情况下，我们需要访问二叉树的所有节点。<br>
空间复杂度：O(N)，这是因为递归堆栈使用的最大空间位 N,斜二叉树的高度可以是 N。</p>
</blockquote>
<blockquote>
<p>方法二：使用父指针迭代<br>
如果每个节点都有父指针，那么我们可以从 p 和 q 返回以获取它们的祖先。在这个遍历过程中，我们得到的第一个公共节点是 LCA 节点。我们可以在遍历树时将父指针保存在字典中。<br>
算法：<br>
从根节点开始遍历树。<br>
在找到 p 和 q 之前，将父指针存储在字典中。<br>
一旦我们找到了 p 和 q，我们就可以使用父亲字典获得 p 的所有祖先，并添加到一个称为祖先的集合中。<br>
同样，我们遍历节点 q 的祖先。如果祖先存在于为 p 设置的祖先中，这意味着这是 p 和 q 之间的第一个共同祖先（同时向上遍历），因此这是 LCA 节点。</p>
</blockquote>
<pre><code>class Solution {

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {

        // Stack for tree traversal
        Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;();

        // HashMap for parent pointers
        Map&lt;TreeNode, TreeNode&gt; parent = new HashMap&lt;&gt;();

        parent.put(root, null);
        stack.push(root);

        // Iterate until we find both the nodes p and q
        while (!parent.containsKey(p) || !parent.containsKey(q)) {

            TreeNode node = stack.pop();

            // While traversing the tree, keep saving the parent pointers.
            if (node.left != null) {
                parent.put(node.left, node);
                stack.push(node.left);
            }
            if (node.right != null) {
                parent.put(node.right, node);
                stack.push(node.right);
            }
        }

        // Ancestors set() for node p.
        Set&lt;TreeNode&gt; ancestors = new HashSet&lt;&gt;();

        // Process all ancestors for node p using parent pointers.
        while (p != null) {
            ancestors.add(p);
            p = parent.get(p);
        }

        // The first ancestor of q which appears in
        // p's ancestor set() is their lowest common ancestor.
        while (!ancestors.contains(q))
            q = parent.get(q);
        return q;
    }

}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(N),其中 NN 是二进制树中的节点数。在最坏的情况下，我们可能会访问二叉树的所有节点。<br>
空间复杂度：O(N),在堆栈使用的最坏情况下，每个节点的父指针字典和祖先集的空间为 N，斜二叉树的高度可能为 N。<br>
方法三：无父指针的迭代<br>
在前面的方法中，我们在回溯过程中遇到 LCA。我们可以摆脱回溯过程本身。在这种方法中，我们总是有一个指向可能 LCA 的指针，当我们找到两个节点时，我们返回指针作为答案。<br>
算法：<br>
从根节点开始。<br>
将 (root, root_state) 放在堆栈上。root_state 定义要遍历该节点的一个子节点还是两个子节点。<br>
当堆栈不为空时，查看堆栈的顶部元素，该元素表示为 (parent_node, parent_state)。<br>
在遍历 parent_node 的任何子节点之前，我们检查 parent_node 本身是否是 p 或 q 中的一个。<br>
当我们第一次找到 p 或 q 的时候，设置一个布尔标记，名为 one_node_found 为 true 。还可以通过在变量 LCA_index 中记录堆栈的顶部索引来跟踪最近的公共祖先。因为堆栈的所有当前元素都是我们刚刚发现的节点的祖先。<br>
第二次 parent_node == p or parent_node == q 意味着我们找到了两个节点，我们可以返回 LCA node。<br>
每当我们访问 parent_node 的子节点时，我们将 (parent_node, updated_parent_state) 推到堆栈上。我们更新父级的状态为子级/分支已被访问/处理，并且相应地更改状态。<br>
当状态变为 BOTH_DONE 时，最终会从堆栈中弹出一个节点，这意味着左、右子树都被推到堆栈上并进行处理。如果 one_node_found 是 true 的，那么我们需要检查被弹出的顶部节点是否可能是找到的节点的祖先之一。在这种情况下，我们需要将LCA_index减少一个。因为其中一位祖先被弹出了。<br>
当同时找到 p 和 q 时，LCA_index 将指向堆栈中包含 p 和 q 之间所有公共祖先的索引。并且 LCA_index 元素具有p和q之间的最近公共祖先。<br>
上面的动画演示了如何使用堆栈遍历二叉树并跟踪节点 p 和 q 之间的公共祖先。</p>
</blockquote>
<pre><code>import javafx.util.*;

class Solution {

    // Three static flags to keep track of post-order traversal.

    // Both left and right traversal pending for a node.
    // Indicates the nodes children are yet to be traversed.
    private static int BOTH_PENDING = 2;

    // Left traversal done.
    private static int LEFT_DONE = 1;

    // Both left and right traversal done for a node.
    // Indicates the node can be popped off the stack.
    private static int BOTH_DONE = 0;

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {

        Stack&lt;Pair&lt;TreeNode, Integer&gt;&gt; stack = new Stack&lt;Pair&lt;TreeNode, Integer&gt;&gt;();

        // Initialize the stack with the root node.
        stack.push(new Pair&lt;TreeNode, Integer&gt;(root, Solution.BOTH_PENDING));

        // This flag is set when either one of p or q is found.
        boolean one_node_found = false;

        // This is used to keep track of the LCA.
        TreeNode LCA = null;

        // Child node
        TreeNode child_node = null;

        // We do a post order traversal of the binary tree using stack
        while (!stack.isEmpty()) {

            Pair&lt;TreeNode, Integer&gt; top = stack.peek();
            TreeNode parent_node = top.getKey();
            int parent_state = top.getValue();

            // If the parent_state is not equal to BOTH_DONE,
            // this means the parent_node can't be popped off yet.
            if (parent_state != Solution.BOTH_DONE) {

                // If both child traversals are pending
                if (parent_state == Solution.BOTH_PENDING) {

                    // Check if the current parent_node is either p or q.
                    if (parent_node == p || parent_node == q) {

                        // If one_node_found was set already, this means we have found
                        // both the nodes.
                        if (one_node_found) {
                            return LCA;
                        } else {
                            // Otherwise, set one_node_found to True,
                            // to mark one of p and q is found.
                            one_node_found = true;

                            // Save the current top element of stack as the LCA.
                            LCA = stack.peek().getKey();
                        }
                    }

                    // If both pending, traverse the left child first
                    child_node = parent_node.left;
                } else {
                    // traverse right child
                    child_node = parent_node.right;
                }

                // Update the node state at the top of the stack
                // Since we have visited one more child.
                stack.pop();
                stack.push(new Pair&lt;TreeNode, Integer&gt;(parent_node, parent_state - 1));

                // Add the child node to the stack for traversal.
                if (child_node != null) {
                    stack.push(new Pair&lt;TreeNode, Integer&gt;(child_node, Solution.BOTH_PENDING));
                }
            } else {

                // If the parent_state of the node is both done,
                // the top node could be popped off the stack.
                // Update the LCA node to be the next top node.
                if (LCA == stack.pop().getKey() &amp;&amp; one_node_found) {
                    LCA = stack.peek().getKey();
                }

            }
        }

        return null;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(N)，其中 N 是二叉树中的节点数。在最坏的情况下，我们可能会访问二叉树的所有节点。这种方法的优点是可以减少回溯。只要找到两个节点，我们就返回。<br>
空间复杂度：O(N)，在最坏的情况下，堆栈使用的空间是 N 且斜二叉树的高度可能是 N。</p>
</blockquote>
<p>注意复习一下迭代法啊！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第十六章 笔记+习题 16.3]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-liu-zhang-bi-ji-xi-ti-163</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-liu-zhang-bi-ji-xi-ti-163">
        </link>
        <updated>2019-11-25T12:32:21.000Z</updated>
        <content type="html"><![CDATA[<p>16.3重载与模板<br>
函数模板可以被<strong>另一个模板</strong>或一个<strong>普通非模板函数</strong>重载。与往常一样，名字相同的函数必须具有<strong>不同数量或类型</strong>的<strong>参数</strong>。<br>
•对于一个调用，其候选函数包括所有模板实参推断（参见16.2节，第600页）成功的函数模板实例。<br>
•候选的函数模板<strong>总是可行的</strong>，因为模板实参推断会排除任何不可行的模板。<br>
•与往常一样，可行函数（模板与非模板）按<strong>类型转换</strong>（如果对此调用需要的话）来排序。当然，可以用于函数模板调用的类型转换是非常有限的（参见16.2.1节，第601页）。（1.顶层const转换 2.数组指针和函数指针）<br>
•与往常一样，如果恰有一个函数提供比任何其他函数都更好的匹配，则选择此函数。但是.如果有多个函数提供<strong>同样好的匹配</strong>，则：<br>
—如果同样好的函数中<strong>只有一个</strong>是<strong>非模板函数</strong>，则选择此函数。<br>
—如果同样好的函数中<strong>没有非模板函数</strong>，而有多个函数模板，且其中一个模板比其他模板更有<strong>特例化</strong>，则选择此模板。<br>
—否则，此调用有歧义。<br>
特例化：指更不通用</p>
<p>第一个版本的debug_rep：debug_rep(const T&amp;) 第二个版本的<code>debug_rep(T *)</code><br>
当有多个重载模板对一个调用提供同样好的匹配时，应选择<strong>最特例化（最特殊）的版本</strong>。<br>
对于一个调用，如果一个<strong>非函数模板</strong>与一个<strong>函数模板</strong>提供<strong>同样好的匹配</strong>，则<strong>选择非模板化本</strong><br>
注意<code>const char*</code>和<code>const char[10]</code>的区别<br>
非模板版本是可行的，但需要进行一次<strong>用户定义</strong>的类型转换，因此它<strong>没有精确匹配</strong>那么好，所以两个模板成为可能调用的函数。与之前一样， T *版本更加特例化，编译器会选择它。</p>
<p><strong>通常</strong>，如果<strong>使用</strong>了一个<strong>忘记声明的函数</strong>，代码将<strong>编译失败</strong>。<strong>但对于重载函数模板</strong>的函数而言，则<strong>不是这样</strong>。如果编译器可以<strong>从模板实例化出与调用匹配的版本（实例化一个并非你所需的版本）</strong>，则缺少的声明就不重要了。<br>
在<strong>定义任何函数之前</strong>，<strong>记得声明所有重载的函数版本</strong>。这样就不必担心编译器.由于未遇到你希望调用的函数而<strong>实例化一个并非你所需的版本</strong>。</p>
<p>习题16.48</p>
<pre><code>template &lt;typename T&gt; string debug_rep(T *p) {
	ostringstream ret;
	ret &lt;&lt; &quot;pointer:&quot; &lt;&lt; p;
	if (p)
		ret &lt;&lt; &quot; &quot; &lt;&lt; debug_rep(*p);
	else
		ret &lt;&lt; &quot;null pointer&quot;;
	return ret.str();		 
}

template &lt;typename T&gt; string debug(const T &amp;t) {
	ostringstream ret;
	ret &lt;&lt; t;
	return ret.str();
}
</code></pre>
<p>习题16.49<br>
(a)第一个T变成int 第二个T无法匹配 选择第一个<br>
(b)第一个T变成int * 第二个T变成int 第二个更特例化 选择第二个<br>
(c)第一个T变为int，第二个无法匹配，选择第一个<br>
(d)第一个T变成const int* 第二个变成const int，第二个更特例化 选择第二个<br>
(e)第一个T变成int 第二个T无法匹配 选择第一个<br>
(f)第一个变成int* 第二个变成int 第一个更准确 选择第一个<br>
(g)第一个T变成int，第二个无法匹配 选第一个<br>
(h)第一个T变成const int* 第二个变成int 第二个更特例化 选第二个<br>
习题16.50<br>
结果为1 2 1 2 1 1 1 2 （居然全对了hhh）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 235. 二叉搜索树的最近公共祖先[简单]]]></title>
        <id>https://lixin-ee.github.io//post/shu-235-er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/shu-235-er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-jian-dan">
        </link>
        <updated>2019-11-25T07:52:47.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。<br>
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”<br>
例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]<br>
示例 1:<br>
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br>
输出: 6<br>
解释: 节点 2 和节点 8 的最近公共祖先是 6。<br>
示例 2:<br>
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4<br>
输出: 2<br>
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。<br>
说明:<br>
所有节点的值都是唯一的。<br>
p、q 为不同节点且均存在于给定的二叉搜索树中。<br>
在真实的面试中遇到过这道题？<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>一开始的思路是从叶节点出发，依靠标识往上找<br>
一开始比较哈皮，想着从叶节点出发，检验当前节点和目标节点是否相等，相等的话就使用全局bool来表明找到了值，其实这样子无法对付示例2的情况<br>
然后发现其实可以依靠返回值来进行判断，主要的点在于判断示例2的那种情况（亦即当前节点既为目标节点也是公共祖先节点<br>
好不容易通过了才发现自己其实没用上二叉搜索树的最重要的性质，怪不得是道简单题啊！！！完全可以利用p、q两个的值和当前节点比较介于中间的值才可能是公共祖先节点。<br>
哇好难受，把简单问题复杂化了，不过我写的这个可以当作一个通用模板，算是一<br>
点小欣慰吧</p>
<pre><code>class Solution {
public:
    bool get=false;
    TreeNode *res=NULL;
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        preorder(root,p,q);
        return res;
    }
    
    bool preorder(TreeNode* cur,TreeNode* p, TreeNode* q){
        if(cur==NULL)
            return false;
        if(get)
            return false;
        bool l=preorder(cur-&gt;left,p,q);
        bool r=preorder(cur-&gt;right,p,q);
        if(!get&amp;&amp;l&amp;&amp;r){
            get=true;
            res=cur;
            return false;
        }
        if(!get&amp;&amp;(l||r)&amp;&amp;(cur==p||cur==q)){
            get=true;
            res=cur;
            return false;
        }
        return (cur==p||cur==q)||l||r;  
    }
};
</code></pre>
<p>然后来看一下官方题解吧</p>
<blockquote>
<p>方法一 （递归）<br>
思路<br>
节点 p，q 的最近公共祖先（LCA）是距离这两个节点最近的公共祖先节点。在这里 最近 考虑的是节点的深度。下面这张图能帮助你更好的理解 最近 这个词的含义。<br>
笔记：p 和 q 其中的一个在 LCA 节点的左子树上，另一个在 LCA 节点的右子树上。<br>
也有可能是下面这种情况：<br>
算法<br>
从根节点开始遍历树<br>
如果节点 p 和节点 q 都在右子树上，那么以右孩子为根节点继续 1 的操作<br>
如果节点 p 和节点 q 都在左子树上，那么以左孩子为根节点继续 1 的操作<br>
如果条件 2 和条件 3 都不成立，这就意味着我们已经找到节 p 和节点 q 的 LCA 了</p>
</blockquote>
<pre><code>class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {

        // Value of current node or parent node.
        int parentVal = root.val;

        // Value of p
        int pVal = p.val;

        // Value of q;
        int qVal = q.val;

        if (pVal &gt; parentVal &amp;&amp; qVal &gt; parentVal) {
            // If both p and q are greater than parent
            return lowestCommonAncestor(root.right, p, q);
        } else if (pVal &lt; parentVal &amp;&amp; qVal &lt; parentVal) {
            // If both p and q are lesser than parent
            return lowestCommonAncestor(root.left, p, q);
        } else {
            // We have found the split point, i.e. the LCA node.
            return root;
        }
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(N)<br>
其中 N 为 BST 中节点的个数，在最坏的情况下我们可能需要访问 BST 中所有的节点。<br>
空间复杂度：O(N)<br>
所需开辟的额外空间主要是递归栈产生的，之所以是 N 是因为 BST 的高度为 N。</p>
</blockquote>
<blockquote>
<p>方法二 （迭代）<br>
算法<br>
这个方法跟方法一很接近。唯一的不同是，我们用迭代的方式替代了递归来遍历整棵树。由于我们不需要回溯来找到 LCA 节点，所以我们是完全可以不利用栈或者是递归的。实际上这个问题本身就是可以迭代的，我们只需要找到分割点就可以了。这个分割点就是能让节点 p 和节点 q 不能在同一颗子树上的那个节点，或者是节点 p 和节点 q 中的一个，这种情况下其中一个节点是另一个节点的父亲节点。</p>
</blockquote>
<pre><code>class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {

        // Value of p
        int pVal = p.val;

        // Value of q;
        int qVal = q.val;

        // Start from the root node of the tree
        TreeNode node = root;

        // Traverse the tree
        while (node != null) {

            // Value of ancestor/parent node.
            int parentVal = node.val;

            if (pVal &gt; parentVal &amp;&amp; qVal &gt; parentVal) {
                // If both p and q are greater than parent
                node = node.right;
            } else if (pVal &lt; parentVal &amp;&amp; qVal &lt; parentVal) {
                // If both p and q are lesser than parent
                node = node.left;
            } else {
                // We have found the split point, i.e. the LCA node.
                return node;
            }
        }
        return null;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(N)<br>
其中 N 为 BST 中节点的个数，在最坏的情况下我们可能需要遍历 BST 中所有的节点。<br>
空间复杂度：O(1)</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 98. 验证二叉搜索树[中等]]]></title>
        <id>https://lixin-ee.github.io//post/shu-98-yan-zheng-er-cha-sou-suo-shu-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/shu-98-yan-zheng-er-cha-sou-suo-shu-zhong-deng">
        </link>
        <updated>2019-11-24T01:21:30.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。<br>
假设一个二叉搜索树具有如下特征：<br>
节点的左子树只包含小于当前节点的数。<br>
节点的右子树只包含大于当前节点的数。<br>
所有左子树和右子树自身必须也是二叉搜索树。<br>
示例 1:<br>
输入:<br>
2<br>
/ <br>
1   3<br>
输出: true<br>
示例 2:<br>
输入:<br>
5<br>
/ <br>
1   4<br>
     / <br>
    3   6<br>
输出: false<br>
解释: 输入为: [5,1,4,null,null,3,6]。<br>
     根节点的值为 5 ，但是其右子节点值为 4 。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/validate-binary-search-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<pre><code>class Solution {
    int i=INT_MIN;
    bool beg=true;
    bool res=true;
public:
    bool isValidBST(TreeNode* root) {
      inorder(root);
        return res;
    }
    
    void inorder(TreeNode *cur){
       if(cur==NULL)
           return ;
        if(!res)
            return;
        inorder(cur-&gt;left);
        if(!beg){
         if(cur-&gt;val&lt;=i){
            res=false;
            return;
         }
        }else
            beg=false;    
        i=cur-&gt;val;

        inorder(cur-&gt;right);
        return;
    }
};
</code></pre>
<p>一开始我直接将父母节点的值和子节点进行比较，结果翻车了，忽视了示例2中节点3那种情况然后考虑利用中序遍历是不是能够直接得到结果<br>
一开始想偷懒，先看看能不能直接利用一个int返回值来比较，然后发现这样子还是必须判断左子树还是右子树比较麻烦<br>
然后还是老老实实用vector来存吧。然后遇到一个坑，二叉搜索树是必须小于或者大于，不能等于。通过了，当然内存也是爆炸了<br>
后来想起可以用int代替vector，然后发现int的初值是个问题，用INT_MAX被教育了一番，于是还是老老实实新增了一个bool来设置，确实降低了部分内存消耗</p>
<p>然后来看一下官方题解</p>
<blockquote>
<p>乍一看，这是一个平凡的问题。只需要遍历整棵树，检查 node.right.val &gt; node.val 和<br>
node.left.val &lt; node.val 对每个结点是否成立。<br>
问题是，这种方法并不总是正确。不仅右子结点要大于该节点，整个右子树的元素都应该大于该节点。例如:<br>
这意味着我们需要在遍历树的同时保留结点的上界与下界，在比较时不仅比较子结点的值，也要与上下界比较</p>
</blockquote>
<p>这里说到的特例就是例子2的情况</p>
<blockquote>
<p>方法一: 递归<br>
上述思路可以用递归法实现。首先将结点的值与上界和下界（如果有）比较。然后，对左子树和右子树递归进行该过程。</p>
</blockquote>
<pre><code>class Solution {
  public boolean helper(TreeNode node, Integer lower, Integer upper) {
    if (node == null) return true;

    int val = node.val;
    if (lower != null &amp;&amp; val &lt;= lower) return false;
    if (upper != null &amp;&amp; val &gt;= upper) return false;

    if (! helper(node.right, val, upper)) return false;
    if (! helper(node.left, lower, val)) return false;
    return true;
  }

  public boolean isValidBST(TreeNode root) {
    return helper(root, null, null);
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 : O(N)。每个结点访问一次。<br>
空间复杂度 : O(N)。我们跟进了整棵树</p>
</blockquote>
<blockquote>
<p>方法二: 迭代<br>
通过使用栈，上面的递归法可以转化为迭代法。这里使用深度优先搜索，比广度优先搜索要快一些。</p>
</blockquote>
<pre><code>class Solution {
  LinkedList&lt;TreeNode&gt; stack = new LinkedList();
  LinkedList&lt;Integer&gt; uppers = new LinkedList(),
          lowers = new LinkedList();

  public void update(TreeNode root, Integer lower, Integer upper) {
    stack.add(root);
    lowers.add(lower);
    uppers.add(upper);
  }

  public boolean isValidBST(TreeNode root) {
    Integer lower = null, upper = null, val;
    update(root, lower, upper);

    while (!stack.isEmpty()) {
      root = stack.poll();
      lower = lowers.poll();
      upper = uppers.poll();

      if (root == null) continue;
      val = root.val;
      if (lower != null &amp;&amp; val &lt;= lower) return false;
      if (upper != null &amp;&amp; val &gt;= upper) return false;
      update(root.right, val, upper);
      update(root.left, lower, val);
    }
    return true;
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 : O(N)。每个结点访问一次。<br>
空间复杂度 : O(N)。我们跟进了整棵树。</p>
</blockquote>
<blockquote>
<p>方法三：中序遍历<br>
算法<br>
我们使用<br>
中序遍历<br>
左子树 -&gt; 结点 -&gt; 右子树的顺序<br>
上面的结点按照访问的顺序标号，你可以按照 1-2-3-4-5 的顺序来比较不同的策略。<br>
左子树 -&gt; 结点 -&gt; 右子树 意味着对于二叉搜索树而言，每个元素都应该比下一个元素小。</p>
</blockquote>
<blockquote>
<p>因此，具有 O(N) 时间复杂度与 O(N) 空间复杂度的算法十分简单:<br>
计算中序遍历列表 inorder.<br>
检查 inorder中的每个元素是否小于下一个。<br>
我们需要保留整个inorder列表吗？<br>
事实上不需要。每一步最后一个添加的元素就足以保证树是（或不是）二叉搜索树。<br>
因此，我们可以将步骤整合并复用空间。<br>
实现</p>
</blockquote>
<pre><code>class Solution {
  public boolean isValidBST(TreeNode root) {
    Stack&lt;TreeNode&gt; stack = new Stack();
    double inorder = - Double.MAX_VALUE;

    while (!stack.isEmpty() || root != null) {
      while (root != null) {
        stack.push(root);
        root = root.left;
      }
      root = stack.pop();
      // If next element in inorder traversal
      // is smaller than the previous one
      // that's not BST.
      if (root.val &lt;= inorder) return false;
      inorder = root.val;
      root = root.right;
    }
    return true;
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 : 最坏情况下（树为二叉搜索树或破坏条件的元素是最右叶结点）为 O(N)。<br>
空间复杂度 : O(N) 用于存储 stack。</p>
</blockquote>
<p>从题解中我发现了自己程序值得改进的地方，就是把in换成结点指针，这样子的话也可以省去一个bool值，也可以省去首次赋值的判断</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 199.二叉树右视图[中等]]]></title>
        <id>https://lixin-ee.github.io//post/shu-199er-cha-shu-you-shi-tu-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/shu-199er-cha-shu-you-shi-tu-zhong-deng">
        </link>
        <updated>2019-11-23T15:22:12.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。<br>
示例:<br>
输入: [1,2,3,null,5,null,4]<br>
输出: [1, 3, 4]<br>
解释:<br>
1            &lt;---<br>
/   <br>
2     3         &lt;---<br>
\     <br>
5     4       &lt;---<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/binary-tree-right-side-view<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>我的想法很简单，直接是从层次遍历的想法，但是主要的点在于先遍历根节点-右节点-左节点，同时使用i来记录层数，并且只记录第一个出现的值。<br>
还有一个优化点是传vector的引用而不是建立一个全局的vector<br>
代码如下</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; rightSideView(TreeNode* root) {
        vector&lt;int&gt; res;
        preorder(root,0,res);
        return res;
    }
    
    void preorder(TreeNode *cur,int i,vector&lt;int&gt; &amp;res){
        if(cur==NULL)
            return;
        if(res.size()==i)
            res.push_back(cur-&gt;val);
        preorder(cur-&gt;right,i+1,res);
        preorder(cur-&gt;left,i+1,res);
        return;
    }
};
</code></pre>
<p>首先是网友题解</p>
<blockquote>
<p>这道题有递归和非递归两种方法，首先来看递归方法。<br>
递归方法是分别遍历一个节点的右节点和左节点，因为是从右边看过来，所以我们需要首先遍历右节点。这里有个疑问，当遍历左节点时候，怎么判定它右边没有其他节点了呢？这里我们用到一个变量level，对于同一层的节点，如果res数组的大小已经等于level了，说明右边已经有节点存入数组了，该节点就不用再保存。一直递归下去就可以得到结果。<br>
代码一：</p>
</blockquote>
<pre><code>C++
class Solution {
public:
    vector&lt;int&gt; rightSideView(TreeNode* root) {
        vector&lt;int&gt; res;
        helper(root,0,res);
        return res;        
    }
    void helper(TreeNode* root,int level,vector&lt;int&gt;&amp; res){
        if(!root) return;
        if(res.size()==level) res.push_back(root-&gt;val);
        helper(root-&gt;right,level+1,res);
        helper(root-&gt;left,level+1,res);
    }
};
</code></pre>
<blockquote>
<p>下面看一下非递归的方法。这道题要求我们打印出二叉树每一行最右边的一个数字，实际上是求二叉树层序遍历的一种变形，我们只需要保存每一层最右边的数字即可，还是需要用到数据结构队列queue，遍历每层的节点时，把下一层的节点都存入到queue中，每当开始新一层节点的遍历之前，先把新一层最后一个节点值存到结果中，代码如下：<br>
C++</p>
</blockquote>
<pre><code>class Solution {
public:
    vector&lt;int&gt; rightSideView(TreeNode* root) {
        vector&lt;int&gt; res;
        if(!root) return res;
        queue&lt;TreeNode*&gt; q;
        q.push(root);
        while(!q.empty()){
            res.push_back(q.back()-&gt;val);
            int size=q.size();
            for(int i=0;i&lt;size;++i){
                TreeNode* t=q.front(); q.pop();
                if(t-&gt;left) q.push(t-&gt;left);
                if(t-&gt;right) q.push(t-&gt;right);
            }           
        }
        return res;
    }
};
</code></pre>
<p>官方题解我感觉一般般，而且用的java差异较大，但是涉及广度优先遍历，有兴趣的话可以看看</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 103.二叉树的锯齿形层次遍历 [中等]]]></title>
        <id>https://lixin-ee.github.io//post/shu-103er-cha-shu-de-ju-chi-xing-ceng-ci-bian-li-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/shu-103er-cha-shu-de-ju-chi-xing-ceng-ci-bian-li-zhong-deng">
        </link>
        <updated>2019-11-22T12:48:54.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。<br>
例如：<br>
给定二叉树 [3,9,20,null,null,15,7],<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7<br>
返回锯齿形层次遍历如下：<br>
[<br>
[3],<br>
[20,9],<br>
[15,7]<br>
]<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题我是直接看的网友题解，倒不是不会做，只是没有比较好的想法<br>
因为这个和前一题不同，前一题我还可以用deque来处理，这一题着实是比较麻烦了（其实也可以用deque，只是相对比较笨的处理方法）<br>
然后网友题解中有个不错的，利用栈来存储，可以选择不同层的时候的入栈顺序，从而实现交替左右（怎么说着说着感觉又蛮麻烦了hhh<br>
所以直接来看网友题解吧</p>
<blockquote>
<p>大家的做法大都是list或者queue反转，但是这是耗时操作，特别是queue自身并不支持反转（list在c++是双向链表，可以相当于有反转功能），用reverse我觉得可能是耗时的，我的解法是两个stack各自保存一层数据，然后先进后出的特性加上左右节点先后入栈的顺序细节（具体谁先谁后可以看代码）即可恰好对应zigZag的Z字形访问顺序：</p>
<p>我的提交执行用时<br>
已经战胜 96.52 % 的 cpp 提交记录</p>
</blockquote>
<pre><code>vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode *root) {
		//右往左时右先入栈，左往右时，左先入栈。然后要两个栈分别保存每一层级的。
		//这里借鉴了树的层次遍历的思想，不过那是用队列
		vector&lt;vector&lt;int&gt;&gt; r;
		if (!root) return r;
		stack&lt;TreeNode *&gt; d1, d2;
		d1.push(root);
		TreeNode *curr = nullptr;
		vector&lt;int&gt; tmp;
		while (true) {
				while (!d1.empty()) {
						curr = d1.top();
						d1.pop();
						tmp.push_back(curr-&gt;val);
						if (curr-&gt;left) d2.push(curr-&gt;left);
						if (curr-&gt;right) d2.push(curr-&gt;right);
				}
				if (!tmp.empty()) {
						r.push_back(tmp);
						tmp.clear();
				} else break;

				while (!d2.empty()) {
						curr = d2.top();
						d2.pop();
						tmp.push_back(curr-&gt;val);
						if (curr-&gt;right) d1.push(curr-&gt;right);
						if (curr-&gt;left) d1.push(curr-&gt;left);
				}
				if (!tmp.empty()) {
						r.push_back(tmp)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第十六章 笔记+习题 16.2]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-liu-zhang-bi-ji-xi-ti-162</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-liu-zhang-bi-ji-xi-ti-162">
        </link>
        <updated>2019-11-21T13:17:11.000Z</updated>
        <content type="html"><![CDATA[<p>16.2模板实参推断<br>
从函数实参来确定模板实参的过程被称为模板实参推断</p>
<p>16.2.1类型转换与模板类型参数<br>
<strong>(注意，这里是实参推断，显式指定实参可以正常转换)</strong> 与往常一样，<strong>顶层 const</strong>( ( 参见2.4.3 节，第57 页）无论是在形参中还是在实参中，<strong>都会被忽略</strong>。在其他类型转换中，能在调用中应用于函数模板的包括如下两项。<br>
• const 转换：可以将一个非 const 对象的引用（或指针）传递给一个 const 的引用（或指针）形参（参见4.11.2 节，第144 页）。<br>
• 数组或函数指针转换：如果函数形参<strong>不是引用类型</strong>，则可以<strong>对数组或函数类型的实参应用正常的指针转换</strong>。一个数组实参可以转换为一个指向其首元素的指针。类似的，一个函数实参可以转换为一个该函数类型的指针（参见4. U .2 节，第143 页）。<br>
<strong>其他类型转换</strong>，如算术转换（参见4.11.1 节，第142 页）、派生类向基类的转换（参见15.2.2节，第530 页）以及用户定义的转换（参见7.5.4 节，第263 页和14.9 节，第514 页），<strong>都不能应用于函数模板</strong>。</p>
<p>注意并不是f(int[ ],int[ ]);<br>
<strong>两个数组大小不同，因此是不同类型</strong>。但是， fref 调用是不合法的。如果<strong>形参是一个引用</strong>，则<strong>数组不会转换为指针</strong>(参见6.2.4节，第195页）。 a 和 b 的类型是不匹配的，因此调用是错误的。</p>
<p>一个模板类型参数可以用作多个函数形参的类型。由于只允许有限的几种类型转换，因此传递给这些形参的实参必须具有相同的类型。如果推断出的类型不匹配，则调用就是错误的。</p>
<p>如果希望允许对函数实参进行正常的类型转换，我们可以将函数模板定义为两个类型<br>
参数：</p>
<p>函数模板可以有用普通类型定义的参数，即，不涉及模板类型参数的类型。这种函数<br>
实参不进行特殊处理；它们正常转换为对应形参的类型 <strong>并非必须用模板参数，只是必须有，模板类型参数不能为空</strong><br>
如果函数参数类型不是模板参数，则对实参进行正常的类型转换。<br>
<code>template &lt;typename T&gt; int add(int a,T b)</code></p>
<p>习题16.32<br>
使用实参的类型来初始化函数的模板实参类型<br>
在模版推断的过程中，编译器根据函数调用的实参类型来寻找模版实参，用这些模版实参生成的函数版本与给定的函数调用匹配<br>
习题16.33<br>
• const 转换：可以将一个非 const 对象的引用（或指针）传递给一个 const 的引用（或指针）形参（参见4.11.2 节，第144 页）。<br>
• 数组或函数指针转换：如果函数形参<strong>不是引用类型</strong>，则可以<strong>对数组或函数类型的实参应用正常的指针转换</strong>。一个数组实参可以转换为一个指向其首元素的指针。类似的，一个函数实参可以转换为一个该函数类型的指针（参见4. U .2 节，第143 页）。</p>
<p>习题16.34<br>
（a）不合法 因为两个字符串数组长度不一致，是不同类型<br>
（b）合法，T为<code>char[4]</code><br>
习题16.35<br>
（a）合法 T类型是char<br>
（b）合法 T类型是double<br>
（c）合法，两者都是char！！！<br>
（d）不合法，无法进行算术类型转换<br>
注意 单引号的'a'就是char类型<br>
习题16.36<br>
（a）T为 int&amp;<br>
（b）T1 T2分别为int&amp;<br>
（c）T为 int* 顶层const被忽略<br>
（d）分别为int *<br>
（e）不合法，首先需要判断实参的类型是否相同，再判断类型是否可转换，两参数一个为const一个非const<br>
（f）T1和T2都为int*<br>
注意：虽然会忽视顶层const，但是首先需要判断实参的类型是否相同，再判断类型是否可转换，如果两参数一个为const一个非const，不能同用一个T</p>
<p>16.2.2函数模板显式实参<br>
在某些情况，编译器<strong>无法推断</strong>出模板实参的类型。其他一些情况下，我们希望<strong>允许用户控制模板实例化</strong>。当函数返回类型与参数列表中任何类型都不相同时，这两种情况最常出现。</p>
<p>没有任何函数实参的类型可用来推断 T 1的类型。毎次调用 sum 时调用者都必须为T1提供一个<strong>显式模板实参</strong> （explicittemplateargument )。<br>
我们提供显式模板实参的方式与定义类模板实例的方式相同。显式模板实参在<strong>尖括号</strong>中给出，位于<strong>函数名之后，实参列表之前</strong>：<br>
//long long 是一个类型<br>
// T1 是显式指定的， T2 和 T3 是从函数实参类型推断而来的<br>
<code>auto val3 = sum&lt;long long&gt;(i,Ing);		//long long sum(int,long)</code><br>
显式模板实参按<strong>由左至右的顺序</strong>与对应的模板参数匹配；第一个模板实参与第一个模板参数匹配，第二个实参与第二个参数匹配，依此类推。<strong>只有尾部（最右）参数</strong>的显式模板实参<strong>才可以忽略</strong>，而且<strong>前提是</strong>它们可以从函数参数<strong>推断出來</strong>。如果我们的 sum 函数按照如下形式编写：</p>
<p><strong>对于模板类型参数已经显式指定了的函数实参，也进行正常的类型转换</strong></p>
<p>习题16.37<br>
<code>compare&lt;int,double&gt;(i,d); compare&lt;int&gt;(i,d); compare&lt;double&gt;(i,d)</code><br>
习题16.38<br>
make_shared接受的参数是一个模板参数包，返回类型是<code>shared_ptr&lt;_Ty&gt;</code>，<code>_Ty</code>是模板参数，由于无法推断返回类型，所以需要显式模板实参。<br>
习题16.39<br>
<code>compare&lt;string&gt;(&quot;123&quot;，&quot;1234&quot;）;</code><br>
<code>char[]</code>会被转换为string</p>
<p>16.2.3尾置返回类型与类型转换<br>
在编译器遇到函数的参数列表之前， 模板参数列表等同于不存在的。为了定义函数的返回类型，我们必须使用尾置返回类型（参见6.3.3节，第206页）。由于<strong>尾置返回出现在参数列表之后</strong>，它可以使用函数的参数：</p>
<p>注意解引用运算符<strong>首先检查curr是否仍在作用范围内</strong>，如果是，则<strong>返回curr所指元素的一个引用</strong>。 所以return *beg;的返回类型是引用而不是int</p>
<p><strong>如果仅仅有迭代器的话，迭代器的所有操作（比如解引用符）只能返回元素的引用，不能得到元素本身的类型</strong>为了获得元素类型，我们可以使用标准库的类型转换（type transformation )模板。这些模板定义在头文件 type_traits 中。<br>
remove_reference模板有一个模板类型参数和一个名为 type 的（public )类型成员。如果我们用一个引用类型实例化remove _ reference ，则 type 将表示被引用的类型。<br>
<code>decltype(*beg)</code>返回元素类型的引用类型。remove_reference::type脱去引用，剩下元素类型本身。<br>
注意， type 是一个类的成员，而该类依赖于一个模板参数。因此，我们必须在返回类型的声明中使用 typename 来告知编译器， type 表示一个类型<br>
<code>auto fcn(It beg,It end)-&gt;typename remove_reference&lt;decltype(*beg)&gt;::type</code></p>
<p>每个类型转换模板的工作方式都与remove_reference类似。每个模板都有一个名为type的public成员，表示一个类型。此类型与模板自身的模板类型参数相关，其关系如模板名所示。<strong>如果不可能（或者不必要）转换模板参数，则type成员就是模板参数类型本身</strong>。<br>
例如，如果T是一个指针类型，则<code>remove_pointer&lt;T&gt;::type</code>是T指向的类型。如果T不是一个指针，则无须进行任何转换，从而<strong>type具有与T相同的类型</strong>。</p>
<p>习题16.40<br>
是合法的<br>
此时返回类型变为int（亦即取决于容器本身的元素类型）<br>
逆向思维的测试代码</p>
<pre><code>template &lt;typename It&gt;
auto fcn(It beg, It end)-&gt;decltype(*beg) { return (*beg+0); }
</code></pre>
<p>显示 error C2440: “return”: 无法从“int”转换为“int &amp;”<br>
<strong>同时要求容器本身的元素（迭代器解引用后）必须能够做+0的操作</strong></p>
<p>习题16.41<br>
这题不会，但是网友的思路很秒，decltype会自动判断a+b需要什么类型才能容纳</p>
<pre><code>template &lt;typename T&gt; auto sum(const T&amp;a,const T&amp;b) -&gt;decltype(a+b)//将函数的返回类型指定为a+b的类型
{
	return a+b;
}
</code></pre>
<p>16.2.4 函数指针和实参判断<br>
当我们用一个<strong>函数模板</strong>初始化一个<strong>函数指针</strong>或为一个<strong>函数指针赋值</strong>时，编译器使用<strong>指针的类型来推断模板实参</strong><br>
pf1中参数的类型决定了T的模板实参的类型。在本例中，T的模板实参类型为int。指针pf1指向compare的int版本实例。如果不能从函数指针类型确定模板实参，则产生错误<br>
这段代码的问题在于，通过func的参数类型<strong>无法确定模板实参的唯一类型</strong>。对func的调用既可以实例化接受int的compare版本，也可以实例化接受string的版本。由于不能确定func的实参的唯一实例化版本，此调用将编译失败。<br>
我们可以通过使用<strong>显式模板实参来消除func调用的歧义</strong><br>
当参数是一个函数模板实例的指针时，程序上下文必须满足：对于每个模板参数，能唯一确定其类型或值。</p>
<p>16.2.5 模板实参推断和引用<br>
编译器会应用正常的引用绑定规则；<strong>const是底层</strong>的，<strong>不是顶层</strong>的 <strong>（因为引用的本质就是指针，准确的说是一个常量指针，它本身不可能修改指向的对象，自带顶层）</strong><br>
<strong>注意const int&amp; 中的const是底层const 指int是const，而不是指引用</strong><br>
当一个函数参数是模板类型参数的一个<strong>普通（左值）引用</strong>时（即，形如T&amp;），绑定规则告诉我们，<strong>只能传递</strong>给它一个<strong>左值</strong>（如，一个变量或者一个返回引用类型的表达式）。实参可以是const类型，也可以不是，如果<strong>实参是const</strong>的，则<strong>T将会被推断为const类型</strong></p>
<p><strong>通常</strong>我们<strong>不能将一个右值引用</strong>绑定到一个<strong>左值</strong>上，但是，c++语言在正常绑定规则之外定义了<strong>两个例外规则</strong>，允许这种绑定，这两个例外规则是move这种标准库设施正确工作的基础<br>
当我们将一个<strong>左值</strong>（如i）传递给函数的<strong>右值引用参数</strong>，且此右值引用指向模板类型参数（如T&amp;&amp;）时，编译器<strong>推断模板类型参数</strong>为实参的<strong>左值引用</strong>类型。因此，当我们调用f3（i）时，编译器推断<strong>T</strong>的类型为<strong>int&amp;，而非int</strong><br>
通常我们<strong>不能（直接）定义</strong>一个<strong>引用的引用</strong>，但是，通过<strong>类型别名</strong>或通过<strong>模板类型参数间接定义</strong>是可以的<br>
在这种情况下，我们可以使用第二个例外绑定规则：如果我们间接创建一个<strong>引用的引用</strong>，则这些<strong>引用</strong>形成了 <strong>“折叠”</strong>。在所有情况下（除了一个例外），引用会<strong>折叠成</strong>一个<strong>普通的左值引用类型</strong>。在新标准中，折叠规则扩展到右值引用。<strong>只在一种特殊情况下</strong>引用会<strong>折叠成右值引用：右值引用的右值引用</strong>。即，对于一个给定类型X：<br>
1.X&amp;、&amp;、X&amp; &amp;&amp;和X&amp;&amp; &amp;都折叠成类型X&amp;<br>
2.<strong>类型X&amp;&amp; &amp;&amp;折叠成X&amp;&amp;</strong><br>
引用折叠<strong>只能</strong>应用于<strong>间接创建的引用的引用</strong>，如类型别名或模板参数</p>
<p>即使f3的函数参数形式是一个右值引用（即，T&amp;&amp;），此调用也会用一个左值引用类型（即，int&amp;）实例化f3<br>
这两个规则导致了两个重要结果：<br>
1.如果一个函数参数是一个指向模板类型参数的右值引用（如，T&amp;&amp;），则它可以被绑定到一个左值；且<br>
2.如果实参是一个左值，则推断出的模板实参类型将是一个左值引用，且函数参数将会被实例化为一个（普通）左值引用参数（T&amp;）</p>
<p>T&amp;&amp; 等于拷贝 T&amp; 等于绑定引用<br>
当代码涉及的类型可能是普通（非引用）类型，也可能是引用类型时，编写正确的代码就变得异常困难（虽然remove_reference这样的类型转换类可能会有帮助）<br>
在实际中，<strong>右值引用</strong>通常用于两种情况：<strong>模板转发其实参（16.2.7）</strong> 或<strong>模板被重载（16.3）</strong><br>
目前应该注意的是，使用右值引用的函数模板通常使用我们在13.6.3节中看到的方式来进行重载（函数后添加引用限定符）<br>
与非模板函数一样，第一个版本将绑定到可修改的右值，而第二个版本将绑定到左值或const右值。</p>
<p>习题16.42<br>
（a）T为int &amp;<br>
（b）T为const int&amp;(注意这里是底层const不是顶层const)<br>
（c）T为int<br>
习题16.43<br>
operator=返回一个左值引用 所以T为int &amp;<br>
习题16.44<br>
声明为T<br>
（a）int<br>
（b）int<br>
（c）int<br>
声明为const T&amp;<br>
（a）int<br>
（b）int<br>
（c）int<br>
注意，折叠是先观察实参的类型和形参的类型再决定T需要什么类型，而不是根据实参的类型直接决定T的类型<br>
习题16.45<br>
T解释为int 因为42是一个右值<br>
如果是int 则T解释为int&amp; 因为变量是一个左值，此时内部的vector&lt;int &amp;&gt;引发错误，容器不能容纳引用</p>
<p>16.2.6理解std::move<br>
用途：移动操作 绑定到将要销毁的对象 1.转换的表达式<code>i*42</code> 2.字面值 42 3.返回右值的表达式<br>
标准库 move 函数（参见13.6.1节，第472页）是使用右值引用的模板的一个很好的<br>
例子。<br>
虽然不能直接将一个右值引用绑定到一个左值上，但可用 <strong>move 获得一个绑定到左值上的右值引用</strong>。由于 move 本质上可以<strong>接受任何类型的实参</strong>，因此我们不会惊讶于它是一个<strong>函数模板</strong>。</p>
<p>这正是我们所寻求的——我们希望将一个右值引用绑定到一个左值。这个实例的函数体返回 static cast &lt; string &amp;&amp;&gt;( t )。在此情况下，t的类型为 string&amp; , cast将其转换为string &amp;&amp;。</p>
<p>static _ cast 只能用于其他合法的类型转换（参见4.11.3节，第145页）。但是，这里又有一条针对右值引用的特许规则：虽然不能隐式地将一个左值转换为右值引用，但我们可以用 <strong>static _ cast 显式地将一个左值转换为一个右值引用</strong>。</p>
<p>习题16.46<br>
将elem指向的元素转化为右值引用并在新的指针位置构造新的元素，相当于移动元素</p>
<p>16.2.7转发<br>
某些函数需要将其一个或多个实参连同类型不变地<strong>转发给其他函数（即在函数内部调用其他函数或自身）</strong>。在此情况下，我们需要<strong>保持</strong>被转发实参的<strong>所有性质</strong>，包括实参类型<strong>是否是 const</strong> 的以及实参是<strong>左值还是右值</strong>。</p>
<p>F，T1不相互影响，但T1可用于F（int可以作为int&amp;的参数）<br>
f和j并不相互影响<br>
<strong>j的值被拷贝到t1中，f中的引用参数被绑定到t1，而非j，从而其改变不会影响j</strong>使其参数能保持给定实参的&quot;左值性&quot;。更进一步，可以想到我们也希望保持参数的 const 属性。<br>
通过将一个函数参数定义为一个<strong>指向模板类型参数的右值引用</strong>，我们可以保持其对应实参的所有类型信息。而使用<strong>引用参数</strong>（无论是左值还是右值）使得我们可以<strong>保持 const属性</strong>，因为在<strong>引用类型中的 const 是底层的</strong>。<br>
如果一个函数参数是指向模板类型参数的<strong>右值引用(如T&amp;&amp;)</strong>，它对应的实参的<strong>const属性和左值/右值属性将得到保持</strong><br>
可使用一个名为<strong>forward</strong>的新标准库设施来传递flip2的参数，它能保持原始实参的类型。类似move,forward定义在<strong>头文件utility</strong>中。与move不同，forward<strong>必须通过显式模板实参來调用</strong>（参见16.2.2节，第603页）。forward<strong>返回该显式实参类型的右值引用</strong>。即，<strong><code>forward&lt;T&gt;</code></strong> 的返回类型是<strong>T&amp;&amp;</strong>。<br>
通常情况下.我们使用forward传递那些定义为模板类型参数的右值引用的函数参数。通过其返回类型上的<strong>引用折叠</strong>，forward可以<strong>保持</strong>给定实参的<strong>左值/右值属性</strong>：<br>
如果实参是一个右值，则 Type 是一个普通（非引用）类型，<code>forward &lt; Type &gt;</code>将返回Types&amp;&amp;。如果实参是一个左值，则通过引用折叠， Type 本身是一个左值引用类型。在此情况下，返回类型是一个指向左值引用类型的右值引用。再次对 <code>forward &lt; Type &gt;</code>的返回类型进行引用折叠，将返同一个左值引用类型。<br>
当用于一个指向模板参数类型的右值引用函数参数（T &amp;&amp;)时， forward 会保持实参类型的所有细节。<br>
<code>f（std::forward&lt;T2&gt;（t2）,std::forward&lt;T1&gt;(t1)）;</code></p>
<p>习题16.47</p>
<pre><code>template&lt;typename F,typename T1,typename T2&gt;
void flip(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2) {
	f(forward&lt;T2&gt;(t2), forward&lt;T1&gt;(t1));
}

void f(int&amp; a, int &amp;&amp;b)
{
	cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; ++b &lt;&lt; endl;
}
</code></pre>
<p>习题感悟<br>
注意：虽然会忽视顶层const，但是首先需要判断实参的类型是否相同，再判断类型是否可转换，如果两参数一个为const一个非const，不能同用一个T<br>
解引用运算符首先检查curr是否仍在作用范围内，如果是，则返回curr所指元素的一个引用。<br>
注意 单引号的'a'就是char类型<br>
将sum返回的类型自动改为保证足够容纳其计算结果的类型，decltype会自动判断a+b需要什么类型才能容纳</p>
<pre><code>template &lt;typename T&gt; auto sum(const T&amp;a,const T&amp;b) -&gt;decltype(a+b)//将函数的返回类型指定为a+b的类型
{
	return a+b;
}
</code></pre>
<p>注意，折叠是先观察实参的类型和形参的类型再决定T需要什么类型，而不是根据实参的类型直接决定T的类型</p>
]]></content>
    </entry>
</feed>