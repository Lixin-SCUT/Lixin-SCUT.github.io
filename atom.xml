<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2020-02-10T09:48:19.777Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[数组 题12:矩阵中的路径]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-ti-12ju-zhen-zhong-de-lu-jing</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-ti-12ju-zhen-zhong-de-lu-jing">
        </link>
        <updated>2020-02-10T02:43:05.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串&quot;bcced&quot;的路径，但是矩阵中不包含&quot;abcb&quot;路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
</blockquote>
<p>这道题在牛客网上挺恶心的，char *是一位数组，它把矩阵首尾相连了。。。我强行化为了二维vector</p>
<pre><code>class Solution {
public:
    bool hasPath(char* matrix, int rows, int cols, char* str){
        vector&lt;vector&lt;char&gt;&gt; matrixv(rows,vector&lt;char&gt;(cols,' '));
        for(int i=0;i&lt;rows;++i)
            for(int j=0;j&lt;cols;++j)
                matrixv[i][j]=matrix[i*cols+j];
        vector&lt;vector&lt;bool&gt;&gt; bool_matrix(rows,vector&lt;bool&gt;(cols,true));
        for(int i=0;i&lt;rows;++i)
            for(int j=0;j&lt;cols;++j)
                if(FindPath(matrixv,i,j,str,0,bool_matrix))
                   return true;
        return false;
    }

    bool FindPath(vector&lt;vector&lt;char&gt;&gt; &amp;matrix,int rows,int cols,char *str,int count,vector&lt;vector&lt;bool&gt;&gt; &amp;bool_matrix){
        if(matrix[rows][cols]!=str[count])
            return false;
        if(count==strlen(str)-1)
            return true;
        bool_matrix[rows][cols]=false;
        if(rows&gt;0&amp;&amp;bool_matrix[rows-1][cols]&amp;&amp;FindPath(matrix,rows-1,cols,str,count+1,bool_matrix))
           return true;
        if(cols&gt;0&amp;&amp;bool_matrix[rows][cols-1]&amp;&amp;FindPath(matrix,rows,cols-1,str,count+1,bool_matrix))
           return true;
        if(rows&lt;matrix.size()-1&amp;&amp;bool_matrix[rows+1][cols]&amp;&amp;FindPath(matrix,rows+1,cols,str,count+1,bool_matrix))
           return true;
        if(cols&lt;matrix[0].size()-1&amp;&amp;bool_matrix[rows][cols+1]&amp;&amp;FindPath(matrix,rows,cols+1,str,count+1,bool_matrix))
           return true;
        bool_matrix[rows][cols]=true;
        return false;
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>由于回溯法的递归特性，路径可以被看成一个栈。当在矩阵中定位了路径中前n个字符的位置之后，在与第n个字符对应的格子的周围都没有 找到第n+1个字符，这时候只好在路径上回到第n-1个字符，重新定位第n个字符。<br>
由于路径不能重复进入矩阵的格子，所以还需要定义和字符矩阵大小一样的布尔值矩阵，用来标识路径是否己经进入了每个格子。</p>
</blockquote>
<pre><code>bool hasPathCore(const char* matrix, int rows, int cols, int row, int col, const char* str, int&amp; pathLength, bool* visited);

bool hasPath(const char* matrix, int rows, int cols, const char* str)
{
    if(matrix == nullptr || rows &lt; 1 || cols &lt; 1 || str == nullptr)
        return false;

    bool *visited = new bool[rows * cols];
    memset(visited, 0, rows * cols);

    int pathLength = 0;
    for(int row = 0; row &lt; rows; ++row)
    {
        for(int col = 0; col &lt; cols; ++col)
        {
            if(hasPathCore(matrix, rows, cols, row, col, str,
                pathLength, visited))
            {
                return true;
            }
        }
    }

    delete[] visited;

    return false;
}

bool hasPathCore(const char* matrix, int rows, int cols, int row,
    int col, const char* str, int&amp; pathLength, bool* visited)
{
    if(str[pathLength] == '\0')
        return true;

    bool hasPath = false;
    if(row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; cols
        &amp;&amp; matrix[row * cols + col] == str[pathLength]
        &amp;&amp; !visited[row * cols + col])
    {
        ++pathLength;
        visited[row * cols + col] = true;

        hasPath = hasPathCore(matrix, rows, cols, row, col - 1,
            str, pathLength, visited)
            || hasPathCore(matrix, rows, cols, row - 1, col,
                str, pathLength, visited)
            || hasPathCore(matrix, rows, cols, row, col + 1,
                str, pathLength, visited)
            || hasPathCore(matrix, rows, cols, row + 1, col,
                str, pathLength, visited);

        if(!hasPath)
        {
            --pathLength;
            visited[row * cols + col] = false;
        }
    }

    return hasPath;
}
</code></pre>
<blockquote>
<p>当矩阵中坐标为(row, col)的格子和路径字符串中下标为pathLength的 字符一样时，从 4 个相邻的格子(row, col-1)、(row-1, col)、 (row, col+1)和 (row+1, col)中去定位路径字符串中下标为pathLength+1的字符。<br>
如果4个相邻的格子都没有匹配字符串中下标为pathLength+1的字符， 则表明当前路径字符串中下标为pathLength的字符在矩阵中的定位不正确， 我们需要回到前一个字符(pathLength-1),然后重新定位。<br>
一直重复这个过程，直到路径字符串上的所有字符都在矩阵中找到合 适的位置(此时 str[pathLength]=='\0')。</p>
</blockquote>
<p>书中的代码比我简介很多，特别是把递归结果利用或逻辑运算符||来组合，不像我分成了很多判断语句，但是相应地就必须把判断条件放在前面了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[阅读总结-《Linux多线程服务端编程：使用muduo C++网络库》]]></title>
        <id>https://lixin-scut.github.io//post/yue-du-zong-jie-lesslesslinux-duo-xian-cheng-fu-wu-duan-bian-cheng-shi-yong-muduo-cwang-luo-ku-greatergreater</id>
        <link href="https://lixin-scut.github.io//post/yue-du-zong-jie-lesslesslinux-duo-xian-cheng-fu-wu-duan-bian-cheng-shi-yong-muduo-cwang-luo-ku-greatergreater">
        </link>
        <updated>2020-02-09T12:13:48.000Z</updated>
        <content type="html"><![CDATA[<p>第一部分<br>
1.在多线程的环境中，使用RAII handle机制来管理可能出现竞态条件（race condition）的对象，并且能够通过handle对象的构造函数和析构函数避免出现内存泄漏的情况<br>
具体就是使用shared_ptr和weak_ptr来管理对象，并且通过定制析构函数来保证不会出现任何内存泄漏的情况<br>
调用时尝试提升weak_ptr 为shared_ptr,如果失败则说明对象已经被析构。</p>
<p>2.线程同步方法及其对象<br>
只是用互斥锁mutex和条件变量condition variable<br>
使用RAII机制封装mutex，防止出现遇到异常而无法解锁的情况<br>
只是用TCP socket进行进程间通信</p>
<p>3.多线程服务器模型及适用场合<br>
基于事件驱动的编程模型<br>
Reactor模式 no-blocking IO+IO multiplexing<br>
one loop one thread（Reactor）<br>
线程池 TaskQueue<br>
总结：one loop one thread+thread pool<br>
这正是muduo网络可以提供的服务器程序服务，亦即不用用户去操心底层系统调用，而是提供调用的接口<br>
进程间通信只使用TCP</p>
<p>4.多线程系统编程<br>
多个线程安全的函数组合起来就容易丧失线程安全性<br>
尽量不要用共享变量，用的话最好保证是只读read-only<br>
不要用pthread_self的pthread_t 而用gettid,并使用__thread变量来缓存，不要每次都执行系统调用<br>
线程的创建与销毁-安全地退出一个多线程的程序并不是一件容易的事情，需要精心设计共享对象的析构顺序，防止各个线程在退出时访问已失效对象，可以不必追求安全地推出，而是让进程进入拒绝服务状态，然后直接杀掉<br>
exit不是线程安全的<br>
善用__thread关键字<br>
每个文件描述符只由一个线程操作，亦即一个线程可以操作多个文件描述符，但是不可以操作其他线程的操作描述符<br>
用socket对象通过RAII机制管理文件描述符<br>
为了防止访问失效对象和网络串话，使用shared_ptr来管理tcpconnection的生命期，这是唯一采用引用计数方式来管理生命期的对象<br>
fork可能会导致RAII失效，使用多线程时尽量不要用fork了，唯一安全的方法就是fork后立即调用exec<br>
多线程中不要使用signal<br>
不主动处理各种异常信号，直接默认结束进程<br>
linux新增了部分系统调用 比如文件描述符的非阻塞IO、exec后强制关闭文件描述符</p>
<p>5.多线程日志<br>
故障诊断和追踪<br>
日志库是单例模式<br>
muduo日志库是C++ stream风格，但没用iostream，而是自己写了logstream class<br>
日志需要有设置级别的功能<br>
日志的目的地只有本地，不要往网络传日志<br>
日志应该有rolling功能，主要由文件大小和时间来区分<br>
日志文件名：进程名+时间+机器名+进程id+后缀.log<br>
防止程序崩溃1.定期flush 2.在内存中的日志消息都有cookie，值为某个函数地址<br>
日志消息格式是固定的，不需要通过运行时配置<br>
要点 1.每条日志只占1行 2.时间戳精确到微妙 gettimeofday 3.保证同一时区 4.打印线程id 5.打印日志级别 6.打印源文件名和行号<br>
每行日志的前四个字段的宽度是固定的 以空格分隔 便于分析，避免出现正则表达式的元字符<br>
优化：1.日期和时间都是缓存的 2.前四个字段是定长的，避免运行时求长度<br>
3.线程id预先格式化为字符串 4.源文件名部分采用编译器计算<br>
多线程异步日志：使用一个背景线程来收集日志信息，其他业务线程往这个线程发送日志消息<br>
双缓冲技术 使用两个buffer 分为前段接收和后端写入<br>
实际上有四个缓冲区</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[虚函数与纯虚函数]]></title>
        <id>https://lixin-scut.github.io//post/xu-han-shu-yu-chun-xu-han-shu</id>
        <link href="https://lixin-scut.github.io//post/xu-han-shu-yu-chun-xu-han-shu">
        </link>
        <updated>2020-02-09T08:31:07.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://lixin-scut.github.io/post/guan-yu-xu-han-shu-he-chun-xu-han-shu/">关于虚函数和纯虚函数</a></p>
<p>书中概念：</p>
<h2 id="虚函数">虚函数</h2>
<p>对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成虚函数 (virtual function)<br>
派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以在这样的函数之前加上 virtual 关键字.但是并不是非得这么做。<br>
C ++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，具体措施是在该函数的形参列表之后增加一个 override 关键字。<br>
当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。<br>
基类必须将它的两种成员函数区分开来：一种是基类希望其派生类进行覆盖的函数；另一种是基类希望派生类直接维承而不要改变的函数。对于前者，基类通常将其定义为虚函数（ virtual )。<br>
基类通过在其成员函数的声明语句之前加上关键字virtual使得该函数执行动态绑定。任何构造函数之外的非静态函数都可以是虚函数。关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。<br>
成员函数如果没被声明为虚函数，则其解析过程发生在编译时而非运行时。<br>
如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接维承其在基类中的版本。<br>
C ++11新标准允许派生类显式地注明它使用某个成员函数覆盖了它维承的虚函数。具体做法是在形参列表后面、或者在 const 成员函数（参见7。1.2节，第231页）的 const 关键字后面、或者在引用成员函数（参见13.6.3节，第483页）的引用限定符后面添加一个关键字 override 。</p>
<p>因为我们直到运行时才能知道到底调用了哪个版本的虚函数，所以所有虚函数都必须有定义<br>
因为连编译器也无法确定到底会使用哪个虚函数。<br>
动态绑定只有当我们通过指针或引用调用虚函数时才会发生。<br>
当通过一个具有普通类型（非引用非指针）的表达式调用虚函数时，在编译时就会将调 用的版本确定下来。<br>
OOP的核心思想是多态性（polymorphism)。我们把具有继承关系的多个类型称为多态类型.<br>
当我们在派生类中覆盖了某个虚函数时，可以再一次使用virtual 关键字指出该函数的性质。然而这么做并非必须，因为一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数。<br>
一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致。<br>
同样，派生类中虚函数的返回类型也必须与基类函数匹配。该规则存在一个例外，当类的虚函数返回类型是类本身的指针或引用时，上述规则无效。<br>
派生类如果定义了一个函数与基类中虚函数的名字相同但是形参列表不同，这仍然是合法的行为。编译器将认为新定义的这个函数与基类中原有的函数是相互独立的。这时，派生类的函数并没有覆盖掉基类中的版本。就实际的编程习惯而言，这种声明往往意味着发生了错误，因为我们可能原本希望派生类能覆盖掉基类中的虚函数，但是一不小心把形参列表弄错了。要想调试并发现这样的错误显然非常团难。在 C ++11新标准中我们可以使用override 关键字来说明派生类中的虚函数。<br>
如果我们使用override 标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器将报错：<br>
我们还能把某个函数指定为 final ,如果我们已经把函数定义成 final 了，则之后任何尝试覆盖该函数的操作都将引发错误<br>
final 和 override 说明符出现在形参列表（包括任何 const 或引用修饰符）以及尾置<br>
返回类型（参见6.3.3节，第206页）之后<br>
虚函数也可以拥有默认实参（参见6.5.1节，第211页）。如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定。<br>
如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。此时，传入派生类函数的将是基类函数定义的默认实参。<br>
如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致<br>
在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。使用作用域运算符可以实现这一目的，例如下面的代码：</p>
<p>通常情况下，只有成员函数（或友元）中的代码才需要使用作用域运算符来回避虚函数机制<br>
通常是—个派生类的虚函数调用它覆盖的基类的虚函数版本时。在此情况下，基类的版本通常完成继承层次中所有类型都要做的共同任务，而派生类中定义的版本需要执行一些与派生类本身密切相关的操作。<br>
如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本自身的调用，从而导致无限递归</p>
<p>除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字</p>
<p>为什么基类与派生类中的虚函数必须有相同的形参列表了（参见15.3节，第537页）。假如基类与派生类的虚函数接受的实参不同.则我们就无法通过基类的引用或指针调用派生类的虚函数了。</p>
<p>如果基类的析构函数不是虚函数，则 delete —个指向派生类对象的基类指针将产生未定义的行为。<br>
之前我们曾介绍过一条经验准则，即如果一个类需要析构函数，那么它也同样需要拷贝和赋值操作（参见13.1.4节，第447页）。基类的析构函数并不遵循上述准则，它是一个重要的例外。一个基类总是需要析构函数，而且它能将析构函数设定为虚函数。此时，该析构函数为了成为虚函数而令内容为空，我们显然无法由此推断该基类还需要赋值运算或拷贝构造函数。</p>
<p>当我们构建一个对象时，需要把对象的类和构造函数的类看作是同一个；对虚函数的调用绑定正好符合这种把对象的类和构造函数的类看成同一个的要求；对于析构函数也是同样的道理。<br>
如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。</p>
<p>一个类（无论是普通类还是类模板）可以包含本身是模板的成员函数。这种成员被称为成员模板 (member template )。成员模板不能是虚函数。</p>
<p>如果一个虚函数承诺了它不会抛出异常，则后续派生出来的虚函数也必须做出同样的承诺；与之相反，如果基类的虚函数允许抛出异常，则派生类的对应函数既可以允许抛出异常，也可以不允许抛出异常</p>
<p>运行时类型识别（run-time type identification,RTTI)的功能由两个运算符实现：<br>
• typeid运算符，用于返回表达式的类型。<br>
• dynamic_cast运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用。<br>
这两个运算符特别适用于以下情况：我们想使用基类对象的指针或引用执行某个派生 类操作并且该操作不是虚函数。一般来说，只要有可能我们应该尽量使用虚函数。当操作被定义成虚函数时，编译器将根据对象的动态类型自动地选择正确的函数版本。<br>
然而，并非任何时候都能定义一个虚函数。假设我们无法使用虚函数，则可以使用一个RTTI运算符。另一方面，与虚成员函数相比，使用RTTI运算符蕴含着更多潜在的风险：程序员必须清楚地知道转换的目标类型并且必须检查类型转换是否被成功执行。<br>
使用RTTI必须要加倍小心。在可能的情况下，最好定义虚函数而非直接接管类型管理的重任。<br>
当运算对象不属于类类型或者是一个不包含任何虚函数的类时，typeid运算符指示的是运算对象的静态类型。而当运算对象是定义了至少一个虚函数的类的左值时，typeid的结果直到运行时才会求得。<br>
typeid是否需要运行时检查决定了表达式是否会被求值。只有当类型含有虚函数时，编译器才会对表达式求值。反之，如果类型不含有虚函数，则typeid返回表达式的静态类型；编译器无须对表达式求值也能知道表达式的静态类型。</p>
<p>union可以定义包括构造函数和析构函数在内的成员函数。但是由于union既不能继承自其他类，也不能作为基类使用，所以在union中不能含有虚函数。</p>
<h2 id="纯虚函数">纯虚函数</h2>
<p>和普通的虚函数不一样，一个纯虚函数无须定义。我们通过在函数体的位置（即在声明语句的分号之前）书写=0就可以将一个虚函数说明为纯虚函数。其中，=0只能出现在类内部的虚函数声明语句处：<br>
值得注意的是，我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。 也就是说，我们不能在类的内部为一个=0的函数提供函数体。</p>
<p>含有（或者未经覆盖直接继承）纯虚函数的类是抽象基类 （abstractbaseclass )。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。我们不能（直接）创建一个抽象基类的对象。</p>
<p>我们竟然可以为纯虚函数提供定义，但调用它的唯一途径是调用时明确指出其class的名称。（effective c++ ）</p>
<p>网上博客：<br>
纯虚函数更多地希望声明有一个这样的统一接口，具体的实现留到子类里去实现</p>
<p>虚函数和纯虚函数都不能有static表示服，被static修饰的函数在编译时候要求前期bind，然而虚函数却是动态绑定，而且被两者修饰的函数生命周期也不一样。</p>
<p>假设Bulk_quote的直接基类是Disc_quote,间接基类是Quote。每个Bulk_quote对象包含三个子对象：一个（空的）Bulk_quote部分、一个Disc_quote子对象和一个Quote子对象。如果Disc_quote中对Quote的纯虚函数提供了实现，则纯虚函数变为虚函数，Bulk_quote中可以选择直接继承或者override<br>
（注意这里的分部分思想，对于理解多层派生很有用）</p>
<p>虚函数是实现多态的机制，核心理念就是通过基类的指针或引用来访问派生类定义的函数</p>
<p>多态：<br>
编译多态：通过重载函数实现<br>
运行多态：通过虚函数实现</p>
<p>虚函数和纯虚函数有以下所示方面的区别。</p>
<p>类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖，这样的话，这样编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。<br>
虚函数在子类里面也可以不重载的；但纯虚函数必须在子类去实现，这就像 Java 的接口一样。通常把很多函数加上 virtual，是一个好的习惯，虽然牺牲了一些性能，但是增加了面向对象的多态性，因为很难预料到父类里面的这个函数不在子类里面不去修改它的实现。<br>
虚函数的类用于“实作继承”，继承接口的同时也继承了父类的实现。当然大家也可以完成自己的实现。纯虚函数关注的是接口的统一性，实现由子类完成。<br>
带纯虚函数的类叫虚基类，这种基类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。这样的类也叫抽象类。抽象类和大家口头常说的虚基类还是有区别的，在 C# 中用 abstract 定义抽象类，而在 C++ 中有抽象类的概念，但是没有这个关键字。抽象类被继承后，子类可以继续是抽象类，也可以是普通类，而虚基类，是含有纯虚函数的类，它如果被继承，那么子类就必须实现虚基类里面的所有纯虚函数，其子类不能是抽象类。<br>
纯虚函数</p>
<p>声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。</p>
<p>纯虚函数最显著的特征是：它们必须在继承类中重新声明函数（不要后面的＝0，否则该派生类也不能实例化），而且它们在抽象类中往往没有定义。</p>
<p>定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。</p>
<p>纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。</p>
<p>顺便说一句，为一个纯虚函数提供定义也是可能的。也就是说，你可以为纯虚函数提供实现，C++ 编译器也不会阻拦（DEV_CPP 中 G++(gcc 3.4.2) 编译器并不支持为纯虚函数定义缺省行为；在 VC6.0 支持为纯虚函数定义缺省的实现，派生类的虚函数 override 基类的纯虚函数），但调用它的唯一方式是通过类名完整地指明是哪个调用（如：pb-&gt;Base:: pureVirtual()）。</p>
<p>有时，声明一个除纯虚函数外什么也不包含的类很有用。这样的类叫协议类（Protocol class），它为派生类仅提供函数接口，完全没有实现。</p>
<p>虚函数（在此指的是非纯虚函数）</p>
<p>虚函数的情况和纯虚函数有点不一样。照例，派生类继承了函数的接口，但简单虚函数一般还提供了实现，派生类可以选择改写（override）它们或不改写它们。</p>
<p>声明虚函数的目的在于，使派生类继承函数的接口和缺省实现。</p>
<p>虚函数的意义，每个类必须提供一个可以被调用的虚函数，但每个类可以按它们认为合适的任何方式处理。如果某个类不想做什么特别的事，可以借助于基类中提供的缺省处理函数。也就是说，虚函数的声明是在告诉子类的设计者，”你必须支持虚函数，但如果你不想写自己的版本，可以借助基类中的缺省版本。”</p>
<p>实际上，为虚函数同时提供函数声明和缺省实现是很危险的。(当你增加一个派生类继承基类时,必须小心使用虚函数,满足派生类特有的需求，否则就是调用基类的虚函数，可能引起错误)</p>
<p>非虚函数</p>
<p>最后，来谈谈类的非虚函数，当一个成员函数为非虚函数时，它在派生类中的行为就不应该不同。实际上，非虚成员函数表明了一种特殊性上的不变性，因为它表示的是不会改变的行为――不管一个派生类有多特殊。</p>
<p>声明非虚函数的目的在于，使派生类继承函数的接口和强制性实现。（所有的派生类都应该完成的使用该函数完成某一个功能）</p>
<p>建议</p>
<p>结合前面的学过的，再次强调一下，如果你没有为类设计虚函数（纯虚函数），该类一般来说应该不具有继承特性（除非确实的存在 IS-A 关系，即便存在，派生类也没有了特殊性，这种情况一般是设计中抽象的不合理）。当然除了 Protocol class 也不应该把类的成员函数全部设计成虚函数（纯虚函数），这也说明了类设计的不合理（不能正确的抽象出基类、派生类之间不变的部分）。</p>
<p>c++ 中没有接口的概念，与之对应的是纯虚类，即只含有纯虚函数的类，c++ 抽象类的概念是含有纯虚函数成员的类。这是因为 c++ 提供多继承，而像 java、c# 这些只提供单继承（避免多继承的复杂性和低效性）的语言为了模拟多继承功能就提供了接口概念，接口可以继承多个。</p>
<p>abstract class 是抽象类，至少包含一个纯虚函数的类就叫做抽象类。</p>
<p>但是如果一个类，所有的成员都是纯虚函数，那么它和一般的抽象类在用法上是有区别的。至少 Microsoft 给的 COM 接口定义全部都是仅由纯虚函数构成的类。因此把这样的类定义叫做纯虚类也不算错。</p>
<p>纯虚函数和虚函数的区别在于前者不包含定义，而后者包含函数体。</p>
<p>那么纯虚类就是不包含任何实现（包括成员函数定义和成员变量定义。前者代表算法，后者代表结构）。不包含任何算法和结构的类叫做纯虚类，应该没有问题。</p>
<p>在 Java 里面的确没有纯虚类的概念，因为 Java 里没有纯虚函数这个概念。Java 管虚函数叫做 abstract function，管抽象类叫做 abstract class，直接说来，Java 根本没有 virtual 这个关键字，都用 abstract 代替，因此 Java 里面根本就没有 Pure 这个概念。有那就是 interface。在 interface 里面定义的函数都不能有函数体，这个在 Java 里面叫做接口。那么 C++ 里面与 interface 等同的概念就是纯虚类了，C++ 用纯虚类来模拟 interface 这个抽象概念，因此这里说的“纯虚类”与 Java 的 abstract class 不同，与 C++ 的一般抽象类也不同。“纯虚类”与 C++ 一般抽象类的区别就好比 Java 里面 interface 和 abstract class 的区别。</p>
<p>抽象类：</p>
<p>抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的，它处于继承层次结构的较上层。</p>
<p>抽象类的定义：</p>
<p>称带有纯虚函数的类为抽象类。称带有纯虚函数的类为抽象类。</p>
<p>抽象类的作用：</p>
<p>抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。所 以派生类实际上刻画了一组子类的操作接口的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。</p>
<p>使用抽象类时注意：</p>
<p>• 抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。</p>
<p>• 抽象类是不能定义对象的。</p>
<h3 id="虚函数的实现">虚函数的实现</h3>
<p>《深度探索c++模型》<br>
1.声明的类导入一个virtual table，存放它所声明的每一个虚函数地址，再加上一个或两个slots（用以支持runtime type identification）<br>
2.类每个对象都导入一个vptr，提供执行期的链接<br>
3.加强constructor，使他能够为vptr提供初值<br>
4.加强deconstructor 能够抹消vptr</p>
<p>为了兼容c语言，早期vptr放在class尾端<br>
现在一般把vptr放在前端，对于在多重继承之下，通过指向class members的指针调用 virtual function有帮助</p>
<p>多重继承：派生类继承了多个基类，基类又各自有自己的虚函数<br>
如果基类没有虚函数而派生类有，则把一个派生类对象转化为基类对象就需要编译器介入以调整地址<br>
对于第一个基类情况和单一继承时相同，之后的基类则需要修改地址，加上（活着减去）介于中间的基类大小（编译器一半按照声明的次序来排列它们）<br>
此时会有多个vptr</p>
<p>虚拟继承：适用于菱形继承<br>
如果class内包含一个或多个虚继承的基类，将分为两个部分：一个不变局部和共享局部<br>
共享局部就是虚继承的基类所在，其位置会因为每次的派生操作而有变化，所以它们只能被间接存取</p>
<p>博客：<br>
<a href="https://blog.csdn.net/weixin_40237626/article/details/82313339">虚函数实现原理</a><br>
带有虚函数的类，编译器会为其额外分配一个虚函数表，里面记录的使虚函数的地址，当此类被继承时，子类如果也写了虚函数就在子类的虚函数表中将父类的函数地址覆盖，否则继承父类的虚函数地址。</p>
<p>实例化之后，对象有一个虚函数指针，虚函数指针指向虚函数表，这样程序运行的时候，通过虚函数指针找到的虚函数表就是根据对象的类型来指向的了。</p>
<h3 id="虚函数和内联">虚函数和内联：</h3>
<p>如果函数已经被声明为inline, 内联函数已经在编译期间它的调用点上就被展开，内联不是强制性的，你只是向编译器提出这个建议，允许它在可以内联的时候采取内联形式;<br>
虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。<br>
内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。<br>
inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</p>
<pre><code>	#include &lt;iostream&gt;
	using namespace std;
	// 基类
	class Base{
		public:
			inline virtual void who(){
				cout &lt;&lt; &quot;I am Base\n&quot;;
			}
			virtual ~Base(){}
	};
	// 派生类
	class Derived:public Base{
		public:
			inline void who(){   // 不写inline时隐式内联
				cout &lt;&lt; &quot;I am Derived\n&quot;;
			}
	};
int  main(){
	// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。
	Base b;
	b.who();
	// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。
	Base *bptr = new Derived();
	bptr-&gt;who();
	// 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。
</code></pre>
<h3 id="构造函数与虚函数">构造函数与虚函数</h3>
<p>1.虚函数对应一个虚指针，虚指针其实是存储在对象的内存空间的。如果构造函数是虚的，就需要通过 虚指针执行那个虚函数表（编译期间生成属于类）来调用，可是对象还没有实例化，也就是内存空间还没有，就没有虚指针，所以构造函数不能是虚函数。</p>
<p>2.虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 题11:旋转数组的最小数字]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-ti-11xuan-zhuan-shu-zu-de-zui-xiao-shu-zi</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-ti-11xuan-zhuan-shu-zu-de-zui-xiao-shu-zi">
        </link>
        <updated>2020-02-08T16:01:59.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>
输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>
例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
</blockquote>
<p>一定要注意right=mid和left=mid，不能用mid+1或者mid-1，因为有可能临界点两个数字在mid那里，然后注意题目那里没说明数字会重复，所以需要判断是否三者相等再相应缩减范围</p>
<pre><code>class Solution {
public:
    int minNumberInRotateArray(vector&lt;int&gt; rotateArray) {
        if(rotateArray.empty())
            return 0;
        int left=0;
        int right=rotateArray.size()-1;
        while(left&lt;right-1){
            int mid=left+(right-left)/2;
            while(rotateArray[mid]==rotateArray[right]&amp;&amp;
                 rotateArray[mid]==rotateArray[left])
                ++left,--right;
            if(rotateArray[left]&gt;rotateArray[mid])
                right=mid;
            else if(rotateArray[mid]&gt;rotateArray[right])
                left=mid;
            else
                return rotateArray[left];
        }
        return rotateArray[right];
    }
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>这道题最直观的解法并不难，从头到尾遍历数组一次，我们就能找出 最小的元素。这种思路的时间复杂度显然是O(n)。但是这种思路没有利用输入的旋转数组的特性<br>
和二分查找法一样，我们用两个指针分别指向数组的第一个元素和最 后一个元素。按照题目中旋转的规则，第一个元素应该是大于或者等于最 后一个元素的(这其实不完全对，还有特例，后面再加以讨论)。<br>
如果中间元素位于后面的递增子数组，那么它应该小于或者等 于第二个指针指向的元素。此时该数组中最小的元素应该位于该中间元素 的前面。<br>
不管是移动第一个指针还是第二个指针，查找范围都会缩小到原来的 一半。接下来我们再用更新之后的两个指针重复做新一轮的查找。<br>
按照上述思路，第一个指针总是指向前面递增数组的元素，而第二个 指针总是指向后面递增数组的元素。最终第一个指针将指向前面子数组的 最后一个元素，而第二个指针会指向后面子数组的第一个元素。也就是它 们最终会指向两个相邻的元素，而第二个指针指向的刚好是最小的元素。 这就是循环结束的条件。<br>
最后两个指针的距离是1,表明第一个指针已经指向第一个递增子数组 的末尾，而第二个指针指向第二个递增子数组的开头。第二个子数组的 第一个数字就是最小的数字，因此第二个指针指向的数字就是我们查找 的结果。<br>
当然需要再仔细分析下标为indexI和index2 （index 1和index2分别与图2.13中 Pi和P2相对应）的两个数相同的情况。当两个指针指向的数字及它们中间的数字三者相同 的时候，我们无法判断中间的数字是位于前面的子数组还是后面的子数组, 也就无法移动两个指针来缩小查找的范围。此时，我们不得不采用顺序查 找的方法。</p>
</blockquote>
<pre><code>int Min(int* numbers, int length)
{
    if(numbers == nullptr || length &lt;= 0)
        throw new std::exception(&quot;Invalid parameters&quot;);
 
    int index1 = 0;
    int index2 = length - 1;
    int indexMid = index1;
    while(numbers[index1] &gt;= numbers[index2])
    {
        // 如果index1和index2指向相邻的两个数，
        // 则index1指向第一个递增子数组的最后一个数字，
        // index2指向第二个子数组的第一个数字，也就是数组中的最小数字
        if(index2 - index1 == 1)
        {
            indexMid = index2;
            break;
        }
 
        // 如果下标为index1、index2和indexMid指向的三个数字相等，
        // 则只能顺序查找
        indexMid = (index1 + index2) / 2;
        if(numbers[index1] == numbers[index2] &amp;&amp; numbers[indexMid] == numbers[index1])
            return MinInOrder(numbers, index1, index2);

        // 缩小查找范围
        if(numbers[indexMid] &gt;= numbers[index1])
            index1 = indexMid;
        else if(numbers[indexMid] &lt;= numbers[index2])
            index2 = indexMid;
    }
 
    return numbers[indexMid];
}

int MinInOrder(int* numbers, int index1, int index2)
{
    int result = numbers[index1];
    for(int i = index1 + 1; i &lt;= index2; ++i)
    {
        if(result &gt; numbers[i])
            result = numbers[i];
    }

    return result;
}
</code></pre>
<p>注意如果第一个就是最小数字的话不如进入while循环<br>
然后两指针相同的情况是leetcode处理得更好</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 题10:斐波那契数列-台阶-变态跳台阶]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-ti-10fei-bo-na-qi-shu-lie</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-ti-10fei-bo-na-qi-shu-lie">
        </link>
        <updated>2020-02-08T00:49:45.000Z</updated>
        <content type="html"><![CDATA[<h2 id="斐波那契数列">斐波那契数列</h2>
<blockquote>
<p>题目描述<br>
大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。<br>
n&lt;=39</p>
</blockquote>
<p>没什么特别的，主要就是暂时变量的选择有两种，一定要把握好</p>
<pre><code>class Solution {
public:
    /*
    //动态规划
    int Fibonacci(int n){
        if(n&lt;=0)
            return 0;
        vector&lt;int&gt; res(n,1);
        for(int i=2;i&lt;n;++i)
            res[i]=res[i-1]+res[i-2];
        return res.back();
    }
    */
    /*
    //暂时变量版
    int Fibonacci(int n) {
        if(n&lt;=0)
            return 0;
        if(n==1||n==2)
            return 1;
        int cur,pre,i;
        cur=1;
        pre=1;
        i=3;
        while(i&lt;=n)
        {
            int temp=cur;
            cur+=pre;
            pre=temp;
            ++i;
        }
        return cur;
        
    }
    */
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>我们的教科书上反复用这个问题来讲解递归函数，并不能说明递归的 解法最适合这道题目。我们不难发现，在递归过程中有很多节点是重复的，而且重复的节点数会随着n的增大而急剧增加，这意味着计算量会随着n的增大而急剧增大。<br>
想办法避免重复计算就行了.比如我们可以把己经得到 的数列中间项保存起来，在下次需要计算的时候我们先杳找一下，如果前 面已经计算过就不用再重复计算了。<br>
更简单的办法是从下往上计算，首先根据f(0)和f(1)算出f(2),再根据 f(1)和f(2)算出f(3)……以此类推就可以算出第n项了。很容易理解，这种思路的时间复杂度是O(n)。<br>
用不同的方法求解斐波那契数列的时间效率大不相同。第一种基于递归的解法虽然直观但时间效率很低，在实际软件开发中不会用这种方法， 也不可能得到面试官的青睐。第二种方法把递归的算法用循环实现，极大地提高了时间效率。第三种方法把求斐波那契数列转换成求矩阵的乘方， 是一种很有创意的算法。虽然我们可以用O(logn)求得矩阵的n次方，但由于隐含的时间常数较大，很少会有软件采用这种算法。另外，实现这种解法的代码也很复杂，不太适合面试。因此第三种方法不是一种实用的算法, 不过应聘者可以用它来展示自己的知识面。</p>
</blockquote>
<pre><code>// ====================方法1：递归====================
long long Fibonacci_Solution1(unsigned int n)
{
    if(n &lt;= 0)
        return 0;

    if(n == 1)
        return 1;

    return Fibonacci_Solution1(n - 1) + Fibonacci_Solution1(n - 2);
}

// ====================方法2：循环====================
long long Fibonacci_Solution2(unsigned n)
{
    int result[2] = {0, 1};
    if(n &lt; 2)
        return result[n];

    long long  fibNMinusOne = 1;
    long long  fibNMinusTwo = 0;
    long long  fibN = 0;
    for(unsigned int i = 2; i &lt;= n; ++ i)
    {
        fibN = fibNMinusOne + fibNMinusTwo;

        fibNMinusTwo = fibNMinusOne;
        fibNMinusOne = fibN;
    }

     return fibN;
}

// ====================方法3：基于矩阵乘法====================
#include &lt;cassert&gt;

struct Matrix2By2
{
    Matrix2By2
    (
        long long m00 = 0, 
        long long m01 = 0, 
        long long m10 = 0, 
        long long m11 = 0
    )
    :m_00(m00), m_01(m01), m_10(m10), m_11(m11) 
    {
    }

    long long m_00;
    long long m_01;
    long long m_10;
    long long m_11;
};

Matrix2By2 MatrixMultiply
(
    const Matrix2By2&amp; matrix1, 
    const Matrix2By2&amp; matrix2
)
{
    return Matrix2By2(
        matrix1.m_00 * matrix2.m_00 + matrix1.m_01 * matrix2.m_10,
        matrix1.m_00 * matrix2.m_01 + matrix1.m_01 * matrix2.m_11,
        matrix1.m_10 * matrix2.m_00 + matrix1.m_11 * matrix2.m_10,
        matrix1.m_10 * matrix2.m_01 + matrix1.m_11 * matrix2.m_11);
}

Matrix2By2 MatrixPower(unsigned int n)
{
    assert(n &gt; 0);

    Matrix2By2 matrix;
    if(n == 1)
    {
        matrix = Matrix2By2(1, 1, 1, 0);
    }
    else if(n % 2 == 0)
    {
        matrix = MatrixPower(n / 2);
        matrix = MatrixMultiply(matrix, matrix);
    }
    else if(n % 2 == 1)
    {
        matrix = MatrixPower((n - 1) / 2);
        matrix = MatrixMultiply(matrix, matrix);
        matrix = MatrixMultiply(matrix, Matrix2By2(1, 1, 1, 0));
    }

    return matrix;
}

long long Fibonacci_Solution3(unsigned int n)
{
    int result[2] = {0, 1};
    if(n &lt; 2)
        return result[n];

    Matrix2By2 PowerNMinus2 = MatrixPower(n - 1);
    return PowerNMinus2.m_00;
}

</code></pre>
<h2 id="跳台阶">跳台阶</h2>
<blockquote>
<p>题目描述<br>
一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
</blockquote>
<p>其实就是斐波那契数列的变形，分为数组法和空间优化法</p>
<pre><code>class Solution {
public:
    int jumpFloor(int number) {
        //动态规划法：空间复杂度优化
        if(number&lt;=0) return 0;
        if(number==1) return 1;
        int level_1=1,level_2=1,res;
        for(;number&gt;1;--number){
            res=level_1+level_2;
            level_2=level_1;
            level_1=res;
        }
        return res;
            
        /*
        //动态规划法
        vector&lt;int&gt; count(number+1,1);
        for(int i=2;i&lt;=number;++i)
            count[i]=count[i-2]+count[i-1];
        return count.back();
        */
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>首先我们考虑最简单的情况。如果只有1级台阶，那显然只有一种跳 法。如果有2级台阶，那就有两种跳法：一种是分两次跳，每次跳1级； 另一种就是一次跳2级。<br>
接着我们再来讨论一般情况。我们把n级台阶时的跳法看成n的函数， 记为f(n)。当n&gt;2时，第一次跳的时候就有两种不同的选择：一是第一次只 跳1级，此时跳法数目等于后面剩下的n-1级台阶的跳法数目，即为f(n-1）； 二是第一次跳2级，此时跳法数目等于后面剩下的n-2级台阶的跳法数目， 即为f(n-2）。因此，n级台阶的不同跳法的总数f(n)=f(n-1)+f(n-2)。</p>
</blockquote>
<h2 id="变态跳台阶">变态跳台阶</h2>
<blockquote>
<p>题目描述<br>
一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
</blockquote>
<pre><code>class Solution {
public:
    int jumpFloorII(int number) {
        //就是把前面所有情况加到一起，然后加上自身的一次
        //可以发现规律是比例为2的等比数列求和
        //其实就是 1，2，4，8，16，...
        return pow(2,number-1);
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我的网络库项目-Network Library]]></title>
        <id>https://lixin-scut.github.io//post/wo-de-wang-luo-ku-xiang-mu-network-library</id>
        <link href="https://lixin-scut.github.io//post/wo-de-wang-luo-ku-xiang-mu-network-library">
        </link>
        <updated>2020-02-07T13:05:00.000Z</updated>
        <content type="html"><![CDATA[<p>这里专门存放我的网络库项目大纲<br>
目标是实现一个网络库，能够实现one thread one loop模式的网络服务功能<br>
主要参考的对象为陈硕的muduo。<br>
在这个过程中将之前学习的C++、算法与数据结构、计算机网络、操作系统、UNIX网络编程等知识运用到项目中。</p>
<p>1.准备工作</p>
<p>2.阅读《Linux高性能》和muduo源码、编译和例子测试</p>
<p>3.项目的架构和特点等实现<br>
整理muduo列出的所有重点，通过自己逐点实现代码，并与muduo源码进行比较，分析其中的差异并进行进一步的思考与学习。</p>
<p>1.one thread one loop<br>
线程<br>
一般而言，多线程服务器中的线程可分为以下几类：<br>
IO线程(负责网络IO)<br>
计算线程(负责复杂计算)<br>
第三方库所用线程<br>
本程序中的Log线程属于第三种，其它线程属于IO线程，因为Web静态服务器计算量较小，所以没有分配计算线程，减少跨线程分配的开销，让IO线程兼顾计算任务。除Log线程外，每个线程一个事件循环，遵循One loop per thread。</p>
<p>Reactor并发模型<br>
程序使用Reactor模型，并使用多线程提高并发度。为避免线程频繁创建和销毁带来的开销，使用线程池，在程序的开始创建固定数量的线程。使用epoll作为IO多路复用的实现方式。</p>
<p>MainReactor只有一个，负责响应client的连接请求，并建立连接，它使用一个NIO Selector。在建立连接后用Round Robin的方式分配给某个SubReactor,因为涉及到跨线程任务分配，需要加锁，这里的锁由某个特定线程中的loop创建，只会被该线程和主线程竞争。</p>
<p>SubReactor可以有一个或者多个，每个subReactor都会在一个独立线程中运行，并且维护一个独立的NIO Selector。</p>
<p>当主线程把新连接分配给了某个SubReactor，该线程此时可能正阻塞在多路选择器(epoll)的等待中，怎么得知新连接的到来呢？这里使用了eventfd进行异步唤醒，线程会从epoll_wait中醒来，得到活跃事件，进行处理。</p>
<p>学习muduo库中的runInLoop和queueInLoop的设计方法，这两个方法主要用来执行用户的某个回调函数，queueInLoop是跨进程调用的精髓所在，具有极大的灵活性，我们只需要绑定好回调函数就可以了。</p>
<p>2.RAII机制</p>
<p>智能指针</p>
<p>3.EPOLL<br>
epoll的触发模式在这里我选择了ET模式，muduo使用的是LT，这两者IO处理上有很大的不同。ET模式要比LE复杂许多，它对用户提出了更高的要求，即每次读，必须读到不能再读(出现EAGAIN)，每次写，写到不能再写(出现EAGAIN)。而LT则简单的多，可以选择也这样做，也可以为编程方便，比如每次只read一次(muduo就是这样做的，这样可以减少系统调用次数)。</p>
<p>4.定时器<br>
每个SubReactor持有一个定时器，用于处理超时请求和长时间不活跃的连接。muduo中介绍了时间轮的实现和用stl里set的实现，这里我的实现直接使用了stl里的priority_queue，底层是小根堆，并采用惰性删除的方式，时间的到来不会唤醒线程，而是每次循环的最后进行检查，如果超时了再删，因为这里对超时的要求并不会很高，如果此时线程忙，那么检查时间队列的间隔也会短，如果不忙，也给了超时请求更长的等待时间。</p>
<p>5.缓冲区设置<br>
6.如何优雅地关闭连接<br>
7.round robin<br>
8.reactor</p>
<p>10.log日志<br>
Log的实现了学习了muduo，Log的实现分为前端和后端，前端往后端写，后端往磁盘写。为什么要这样区分前端和后端呢？因为只要涉及到IO，无论是网络IO还是磁盘IO，肯定是慢的，慢就会影响其它操作，必须让它快才行。</p>
<p>这里的Log前端是前面所述的IO线程，负责产生log，后端是Log线程，设计了多个缓冲区，负责收集前端产生的log，集中往磁盘写。这样，Log写到后端是没有障碍的，把慢的动作交给后端去做好了。</p>
<p>后端主要是由多个缓冲区构成的，集满了或者时间到了就向文件写一次。采用了muduo介绍了“双缓冲区”的思想，实际采用4个多的缓冲区(为什么说多呢？为什么4个可能不够用啊，要有备无患)。4个缓冲区分两组，每组的两个一个主要的，另一个防止第一个写满了没地方写，写满或者时间到了就和另外两个交换指针，然后把满的往文件里写。</p>
<p>与Log相关的类包括FileUtil、LogFile、AsyncLogging、LogStream、Logging。 其中前4个类每一个类都含有一个append函数，Log的设计也是主要围绕这个append函数展开的。</p>
<p>FileUtil是最底层的文件类，封装了Log文件的打开、写入并在类析构的时候关闭文件，底层使用了标准IO，该append函数直接向文件写。<br>
LogFile进一步封装了FileUtil，并设置了一个循环次数，每过这么多次就flush一次。<br>
AsyncLogging是核心，它负责启动一个log线程，专门用来将log写入LogFile，应用了“双缓冲技术”，其实有4个以上的缓冲区，但思想是一样的。AsyncLogging负责(定时到或被填满时)将缓冲区中的数据写入LogFile中。<br>
LogStream主要用来格式化输出，重载了&lt;&lt;运算符，同时也有自己的一块缓冲区，这里缓冲区的存在是为了缓存一行，把多个&lt;&lt;的结果连成一块。<br>
Logging是对外接口，Logging类内涵一个LogStream对象，主要是为了每次打log的时候在log之前和之后加上固定的格式化的信息，比如打log的行、文件名等信息。</p>
<p>11.核心结构<br>
程序中的每一个类和结构体当然都必不可少，其中能体现并发模型和整体架构的，我认为是有两个：</p>
<p>Channel类：Channel是Reactor结构中的“事件”，它自始至终都属于一个EventLoop，负责一个文件描述符的IO事件，在Channel类中保存这IO事件的类型以及对应的回调函数，当IO事件发生时，最终会调用到Channel类中的回调函数。因此，程序中所有带有读写时间的对象都会和一个Channel关联，包括loop中的eventfd，listenfd，HttpData等。<br>
EventLoop：One loop per thread意味着每个线程只能有一个EventLoop对象，EventLoop即是时间循环，每次从poller里拿活跃事件，并给到Channel里分发处理。EventLoop中的loop函数会在最底层(Thread)中被真正调用，开始无限的循环，直到某一轮的检查到退出状态后从底层一层一层的退出。</p>
<p>思考问题：<br>
网络库的io模型是怎么样的，为什么这个io模型是高性能的？<br>
muduo的多线程体现在什么地方？<br>
muduo的主线程accepte的fd如何分发给其他线程？<br>
muduo的定时器如何实现？<br>
muduo如何限制连接的数量？<br>
muduo如何设计buffer？<br>
muduo的定时器是如何设计的？<br>
如何安全的关闭tcp连接，能不能直接close，如何直接close会发生什么？<br>
muduo是如何 线程安全的对 对象的声明周期进行管理？</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[队列 题9:用两个栈实现队列]]></title>
        <id>https://lixin-scut.github.io//post/dui-lie-ti-9yong-liang-ge-zhan-shi-xian-dui-lie</id>
        <link href="https://lixin-scut.github.io//post/dui-lie-ti-9yong-liang-ge-zhan-shi-xian-dui-lie">
        </link>
        <updated>2020-02-07T03:33:50.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
</blockquote>
<pre><code>class Solution
{
public:
    void push(int node) {
        stack1.push(node);
    }

    int pop() {
        if(stack2.empty()){
            while(stack1.size()){
                stack2.push(stack1.top());
                stack1.pop();
            }
        }
				//补充
				 if(stack2.empty())
					 throw new exception(&quot;queue is empty&quot;);
					 
        int res=stack2.top();
        stack2.pop();
        return res;
    }

private:
    stack&lt;int&gt; stack1;
    stack&lt;int&gt; stack2;
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>1插入一个元素,先把它插入stack<br>
2删除一个元素的步骤：当stack2不为空时，在stack2中的栈顶元素是最先进入队列的元素，可以弹出。当stack2 为空时，我们把stack1中的元素逐个弹出并压入stack2。由于先进入队列的元素被压到stackl的底端，经过弹出和压入操作之后就处于stack2的顶端, 又可以直接弹出。</p>
</blockquote>
<pre><code>template &lt;typename T&gt; class CQueue
{
public:
    CQueue(void);
    ~CQueue(void);
    
    // 在队列末尾添加一个结点
    void appendTail(const T&amp; node);

    // 删除队列的头结点
    T deleteHead();

private:
    stack&lt;T&gt; stack1;
    stack&lt;T&gt; stack2;
};

template &lt;typename T&gt; CQueue&lt;T&gt;::CQueue(void)
{
}

template &lt;typename T&gt; CQueue&lt;T&gt;::~CQueue(void)
{
}

template&lt;typename T&gt; void CQueue&lt;T&gt;::appendTail(const T&amp; element)
{
    stack1.push(element);
} 

template&lt;typename T&gt; T CQueue&lt;T&gt;::deleteHead()
{
    if(stack2.size()&lt;= 0)
    {
        while(stack1.size()&gt;0)
        {
            T&amp; data = stack1.top();
            stack1.pop();
            stack2.push(data);
        }
    }

    if(stack2.size() == 0)
        throw new exception(&quot;queue is empty&quot;);

    T head = stack2.top();
    stack2.pop();

    return head;
}
</code></pre>
<p>注意我的代码中存在鲁棒性不强的问题，在判断stack2为空之后可能stack1还是可能为空，所以需要再次检查一次stack2是否为空</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 题8:二叉树的下一个节点]]></title>
        <id>https://lixin-scut.github.io//post/shu-ti-8er-cha-shu-de-xia-yi-ge-jie-dian</id>
        <link href="https://lixin-scut.github.io//post/shu-ti-8er-cha-shu-de-xia-yi-ge-jie-dian">
        </link>
        <updated>2020-02-05T10:36:13.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
</blockquote>
<p>主要是要注意我把两种情况合在一起计算了，一是 目标节点是其父节点的左子节点，二是 目标是其父节点的右子节点。循环的条件很重要，本来我用的是判断当前节点和父节点的关系，但是后来发现要先判断父节点是否为空，就改了，最后的判断也相应地需要修改</p>
<pre><code>class Solution {
public:
    TreeLinkNode* GetNext(TreeLinkNode* pNode)
    {
        TreeLinkNode *cur;
        if(pNode-&gt;right!=NULL){
            cur=pNode-&gt;right;
            while(cur-&gt;left!=NULL)
                cur=cur-&gt;left;
            return cur;
        }
        cur=pNode;
        while(cur-&gt;next!=NULL)
            if(cur!=cur-&gt;next-&gt;left)
                cur=cur-&gt;next;
            else
                break;
        if(cur-&gt;next!=NULL)
            return cur-&gt;next;
        return NULL;
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>1.如果一个节点有右了树，那么它的下一个节点就是它的右子树中的最 左子节点。<br>
2.一个节点没有右子树的情形：<br>
a.如果节点是它父节点的左子节点，那么它的下一个节点就是它的父节点。<br>
b.如果一个节点既没有右子树，并且它还是它父节点的右子节点，那么 这种情形就比较复杂。我们可以沿着指向父节点的指针一直向上遍历，直 到找到一个是它父节点的左子节点的节点。如果这样的节点存在，那么这 个节点的父节点就是我们要找的下一个节点。</p>
</blockquote>
<pre><code>struct BinaryTreeNode
{
    int                    m_nValue;
    BinaryTreeNode*        m_pLeft;
    BinaryTreeNode*        m_pRight;
    BinaryTreeNode*        m_pParent;
};

BinaryTreeNode* GetNext(BinaryTreeNode* pNode)
{
    if(pNode == nullptr)
        return nullptr;

    BinaryTreeNode* pNext = nullptr;
    if(pNode-&gt;m_pRight != nullptr)
    {
        BinaryTreeNode* pRight = pNode-&gt;m_pRight;
        while(pRight-&gt;m_pLeft != nullptr)
            pRight = pRight-&gt;m_pLeft;

        pNext = pRight;
    }
    else if(pNode-&gt;m_pParent != nullptr)
    {
        BinaryTreeNode* pCurrent = pNode;
        BinaryTreeNode* pParent = pNode-&gt;m_pParent;
        while(pParent != nullptr &amp;&amp; pCurrent == pParent-&gt;m_pRight)
        {
            pCurrent = pParent;
            pParent = pParent-&gt;m_pParent;
        }

        pNext = pParent;
    }

    return pNext;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 题7:重建二叉树[未做出][待阅读]]]></title>
        <id>https://lixin-scut.github.io//post/shu-ti-7chong-jian-er-cha-shu-wei-zuo-chu-dai-yue-du</id>
        <link href="https://lixin-scut.github.io//post/shu-ti-7chong-jian-er-cha-shu-wei-zuo-chu-dai-yue-du">
        </link>
        <updated>2020-02-05T01:13:45.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回</p>
</blockquote>
<p>这道题的要点主要在于前序遍历和中序遍历的要点关联，难点在于两个数组的范围是不一致的，所以必须要两对下标（或者两对迭代器）来处理<br>
然后在迭代的时候需要中间变量来处理好在两个数组中左右子树的节点范围变化</p>
<pre><code>class Solution {
public:
    //TreeNode* buildTree(vector&lt;int&gt; &amp;pre,int pre_beg,int pre_end,vector&lt;int&gt; &amp;vin,int vin_beg,int vin_end);
    TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) {
        if(pre.empty()||vin.empty())
            return NULL;
        return buildTree(pre,0,pre.size()-1,vin,0,vin.size()-1);
    }
    
    TreeNode* buildTree(vector&lt;int&gt; &amp;pre,int pre_beg,int pre_end,vector&lt;int&gt; &amp;vin,int vin_beg,int vin_end)
    {
        int rootValue=pre[pre_beg];
        TreeNode *cur=new TreeNode(rootValue);
        
        if(pre_beg==pre_end){
            if(vin_beg==vin_end&amp;&amp;pre[pre_beg]==vin[vin_beg])
                return cur;
        }
        int vin_cur;
        for(int i=vin_beg;i&lt;=vin_end;++i)
            if(vin[i]==rootValue){
                vin_cur=i;
                break;
            }
        
        int leftLength=vin_cur-vin_beg;
        int left_pre_end=pre_beg+leftLength;
        if(leftLength&gt;0){
            cur-&gt;left=buildTree(pre,pre_beg+1,left_pre_end,vin,vin_beg,vin_cur-1);
        }
        if(leftLength&lt;pre_end-pre_beg)
            cur-&gt;right=buildTree(pre,left_pre_end+1,pre_end,vin,vin_cur+1,vin_end);
        return cur;
    }
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>在二叉树的前序遍历序列中，第一个数字总是树的根节点的值。但在 中序遍历序列中，根节点的值在序列的中间，左子树的节点的值位于根节 点的值的左边，而右子树的节点的值位于根节点的值的右边。因此我们需 要扫描中序遍历序列，才能找到根节点的值。<br>
我们已经分别找到了左、右子树的前序遍历序列和中序遍历序列, 我们可以用同样的方法分别构建左、右子树。也就是说，接下来的事情可以用递归的方法去完成。</p>
</blockquote>
<pre><code>BinaryTreeNode* Construct(int* preorder, int* inorder, int length)
{
    if(preorder == nullptr || inorder == nullptr || length &lt;= 0)
        return nullptr;

    return ConstructCore(preorder, preorder + length - 1,
        inorder, inorder + length - 1);
}

BinaryTreeNode* ConstructCore
(
    int* startPreorder, int* endPreorder, 
    int* startInorder, int* endInorder
)
{
    // 前序遍历序列的第一个数字是根结点的值
    int rootValue = startPreorder[0];
    BinaryTreeNode* root = new BinaryTreeNode();
    root-&gt;m_nValue = rootValue;
    root-&gt;m_pLeft = root-&gt;m_pRight = nullptr;

    if(startPreorder == endPreorder)
    {
        if(startInorder == endInorder &amp;&amp; *startPreorder == *startInorder)
            return root;
        else
            throw std::exception(&quot;Invalid input.&quot;);
    }

    // 在中序遍历中找到根结点的值
    int* rootInorder = startInorder;
    while(rootInorder &lt;= endInorder &amp;&amp; *rootInorder != rootValue)
        ++ rootInorder;

    if(rootInorder == endInorder &amp;&amp; *rootInorder != rootValue)
        throw std::exception(&quot;Invalid input.&quot;);

    int leftLength = rootInorder - startInorder;
    int* leftPreorderEnd = startPreorder + leftLength;
    if(leftLength &gt; 0)
    {
        // 构建左子树
        root-&gt;m_pLeft = ConstructCore(startPreorder + 1, leftPreorderEnd, 
            startInorder, rootInorder - 1);
    }
    if(leftLength &lt; endPreorder - startPreorder)
    {
        // 构建右子树
        root-&gt;m_pRight = ConstructCore(leftPreorderEnd + 1, endPreorder,
            rootInorder + 1, endInorder);
    }

    return root;
}

</code></pre>
<blockquote>
<p>在函数ConstructCore中，我们先根据前序遍历序列的第一个数字创建 根节点，接卜来在中序遍历序列中找到根节点的位置，这样就能确定左、 右子树节点的数量。在前序遍历和中序遍历序列中划分了左、右子树节点 的值之后，我们就可以递归地调用函数ConstructCore去分别构建它的左、 右子树</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 题6:从尾到头打印链表[未做出]]]></title>
        <id>https://lixin-scut.github.io//post/lian-biao-ti-6cong-wei-dao-tou-da-yin-lian-biao-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/lian-biao-ti-6cong-wei-dao-tou-da-yin-lian-biao-wei-zuo-chu">
        </link>
        <updated>2020-02-04T00:43:41.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p>
</blockquote>
<p>这道题一开始我只想到了deque的push_front和vector强行插入头节点 以及 将链表翻转<br>
但是这三种方式都不是很好，翻转链表还会改变链表的结构，需要和面试官商量<br>
然后看了书之后才发现书的方法是特别简洁而巧妙，所以但看书还是不够的，得老老实实动手</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; printListFromTailToHead(ListNode* head) {
        //【未做出】
        /*
        //首先就是可以用栈存储
        stack&lt;int&gt; node_val;
        ListNode *cur=head;
        vector&lt;int&gt; res;
        while(cur!=NULL){
            node_val.push(cur-&gt;val);
            cur=cur-&gt;next;
        }
        while(node_val.size()){
            res.push_back(node_val.top());
            node_val.pop();
        }
        return res;
        */
        //然后通过栈联想到递归（这个思维很重要，不要仅仅限制于递归到栈）
        vector&lt;int&gt; res;
        if(head==NULL)
            return res;
        add_value(head,res);
        return res;
    }
    
    void add_value(ListNode* cur,vector&lt;int&gt; &amp;res){
        if(cur-&gt;next!=NULL)
            add_value(cur-&gt;next,res);
        res.push_back(cur-&gt;val);
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>解决这个问题肯定是要遍历链表<br>
遍历的顺序是从头到尾，可输出的顺序却是从尾到头。第一个遍历的节点最后一个输出，而最后一个遍历到的节点第一个输出。这就是典型的“后进先出”，我们可以用栈实现这种顺序。</p>
</blockquote>
<pre><code>void PrintListReversingly_Iteratively(ListNode* pHead)
{
    std::stack&lt;ListNode*&gt; nodes;

    ListNode* pNode = pHead;
    while(pNode != nullptr)
    {
        nodes.push(pNode);
        pNode = pNode-&gt;m_pNext;
    }

    while(!nodes.empty())
    {
        pNode = nodes.top();
        printf(&quot;%d\t&quot;, pNode-&gt;m_nValue);
        nodes.pop();
    }
}
</code></pre>
<blockquote>
<p>既然想到了用栈来实现这个函数，而递归在本质上就是一个栈结构， 于是很自然地又想到了用递归来实现。要实现反过来输出链表，我们每访 问到一个节点的时候，先递归输出它后面的节点，再输出该节点自身，这 样链表的输出结果就反过来了。</p>
</blockquote>
<pre><code>void PrintListReversingly_Recursively(ListNode* pHead)
{
    if(pHead != nullptr)
    {
        if (pHead-&gt;m_pNext != nullptr)
        {
            PrintListReversingly_Recursively(pHead-&gt;m_pNext);
        }
 
        printf(&quot;%d\t&quot;, pHead-&gt;m_nValue);
    }
}
</code></pre>
<blockquote>
<p>上面的基于递归的代码看起来很简洁，但有一个问题：当链表非常长的时候，就会导致函数调用的层级很深，从而有可能导致函数调用栈溢出。显然用栈基于循环实现的代码的鲁棒性要好一点。</p>
</blockquote>
]]></content>
    </entry>
</feed>