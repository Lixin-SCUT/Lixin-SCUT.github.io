<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-10-16T11:45:18.062Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[字符串 22. 括号生成 [unfinished]]]></title>
        <id>https://lixin-ee.github.io//post/zi-fu-chuan-22-gua-hao-sheng-cheng-unfinished</id>
        <link href="https://lixin-ee.github.io//post/zi-fu-chuan-22-gua-hao-sheng-cheng-unfinished">
        </link>
        <updated>2019-10-16T11:26:54.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p>
<p>例如，给出 n = 3，生成结果为：<br>
[<br>
&quot;((()))&quot;,<br>
&quot;(()())&quot;,<br>
&quot;(())()&quot;,<br>
&quot;()(())&quot;,<br>
&quot;()()()&quot;<br>
]</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/generate-parentheses<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题是忆君小朋友问我的，果断没啥思路hhh但是猜到七七八八得是动态规划了<br>
下面是高赞的动态题解，还是比较好懂得，主要的要点在于理解为何是<br>
&quot;(&quot; + 【i=p时所有括号的排列组合】 + &quot;)&quot; + 【i=q时所有括号的排列组合】<br>
因为其实有种对称的情况，所有的可能其实是【】+&quot;(&quot; + 【】 + &quot;)&quot; + 【】，但是所有元素都是左右括号，所以第一位置+第二位置其实是和第二位置+第三位置重复的了。<br>
下面是完整题解：</p>
<blockquote>
<p>反思：<br>
首先，面向小白：什么是动态规划？在此题中，动态规划的思想类似于数学归纳法，当知道所有 i&lt;n 的情况时，我们可以通过某种算法算出 i=n 的情况。<br>
本题最核心的思想是，考虑 i=n 时相比 n-1 组括号增加的那一组括号的位置。</p>
<p>思路：<br>
当我们清楚所有 i&lt;n 时括号的可能生成排列后，对与 i=n 的情况，我们考虑整个括号排列中最左边的括号。<br>
它一定是一个左括号，那么它可以和它对应的右括号组成一组完整的括号 &quot;( )&quot;，我们认为这一组是相比 n-1 增加进来的括号。<br>
那么，剩下 n-1 组括号有可能在哪呢？<br>
【这里是重点，请着重理解】<br>
剩下的括号要么在这一组新增的括号内部，要么在这一组新增括号的外部（右侧）。<br>
既然知道了 i&lt;n 的情况，那我们就可以对所有情况进行遍历：<br>
&quot;(&quot; + 【i=p时所有括号的排列组合】 + &quot;)&quot; + 【i=q时所有括号的排列组合】<br>
其中 p + q = n-1，且 p q 均为非负整数。<br>
事实上，当上述 p 从 0 取到 n-1，q 从 n-1 取到 0 后，所有情况就遍历完了。<br>
注：上述遍历是没有重复情况出现的，即当 (p1,q1)≠(p2,q2) 时，按上述方式取的括号组合一定不同。<br>
代码：<br>
具体代码如下：（时间击败百分之 95，内存击败百分之 99.65）</p>
</blockquote>
<pre><code>class Solution:
    def generateParenthesis(self, n: int) -&gt; List[str]:
        if n == 0:
            return []
        total_l = []
        total_l.append([None])    # 0组括号时记为None
        total_l.append([&quot;()&quot;])    # 1组括号只有一种情况
        for i in range(2,n+1):    # 开始计算i组括号时的括号组合
            l = []        
            for j in range(i):    # 开始遍历 p q ，其中p+q=i-1 , j 作为索引
                now_list1 = total_l[j]    # p = j 时的括号组合情况
                now_list2 = total_l[i-1-j]    # q = (i-1) - j 时的括号组合情况
                for k1 in now_list1:  
                    for k2 in now_list2:
                        if k1 == None:
                            k1 = &quot;&quot;
                        if k2 == None:
                            k2 = &quot;&quot;
                        el = &quot;(&quot; + k1 + &quot;)&quot; + k2
                        l.append(el)    # 把所有可能的情况添加到 l 中
            total_l.append(l)    # l这个list就是i组括号的所有情况，添加到total_l中，继续求解i=i+1的情况
        return total_l[n]
</code></pre>
<p>然后是我的复现，复现过程很哈批，把第二个循环的循环判断i写成n了，疯狂溢出，还是得好好思考啊</p>
<pre><code>class Solution {
public:
    vector&lt;string&gt; generateParenthesis(int n) {
        vector&lt;vector&lt;string&gt;&gt; Paren;
        Paren.push_back({&quot;&quot;});
        Paren.push_back({&quot;()&quot;});
        for(int i=2;i&lt;n+1;++i){
            vector&lt;string&gt; temp;
            for(int j=0;j&lt;i;++j){
                vector&lt;string&gt; left=Paren[j];
                vector&lt;string&gt; right=Paren[i-j-1];
                for(int x=0;x&lt;left.size();++x)
                    for(int y=0;y&lt;right.size();++y){
                        string s;
                        s=&quot;(&quot;+left[x] +&quot;)&quot;+right[y];
                        temp.push_back(s);
                    } 
            }
            Paren.push_back(temp);
        } 
        return Paren[n];
    }
};
</code></pre>
<p>然后就是优化问题，看了题解的C++实现发现其实我这样非常不优雅，因为平时不常用的for范围语句在这道题中反而大放异彩，同时可以在定义时确定ve<code>ctor&lt;vector&lt;string&gt;&gt;</code>的参数数量，省去push_back</p>
<pre><code>class Solution {
public:
    vector&lt;string&gt; generateParenthesis(int n) {
        vector&lt;vector&lt;string&gt;&gt; Paren(n+1);
        Paren.push_back({&quot;&quot;});
        Paren.push_back({&quot;()&quot;});
        for(int i=2;i&lt;n+1;++i){
            vector&lt;string&gt; temp;
            for(int j=0;j&lt;i;++j)
                for(auto left:Paren[j])
                    for(auto right:Paren[i-j-1]){
                        string s=&quot;(&quot;+left +&quot;)&quot;+right;
                        Paren[i].push_back(s);
                    } 
        } 
        return Paren[n];
    }
};
</code></pre>
<blockquote>
<p>下面是官方题解，以后有空可以回头看看<br>
方法一：暴力法<br>
思路<br>
我们可以生成所有 2^{2n}  个 '(' 和 ')' 字符构成的序列。然后，我们将检查每一个是否有效。</p>
<p>算法<br>
为了生成所有序列，我们使用递归。长度为 n 的序列就是 '(' 加上所有长度为 n-1 的序列，以及 ')' 加上所有长度为 n-1 的序列。<br>
为了检查序列是否为有效的，我们会跟踪 平衡，也就是左括号的数量减去右括号的数量的净值。如果这个值始终小于零或者不以零结束，该序列就是无效的，否则它是有效的。</p>
</blockquote>
<pre><code>Java
class Solution {
    public List&lt;String&gt; generateParenthesis(int n) {
        List&lt;String&gt; combinations = new ArrayList();
        generateAll(new char[2 * n], 0, combinations);
        return combinations;
    }

    public void generateAll(char[] current, int pos, List&lt;String&gt; result) {
        if (pos == current.length) {
            if (valid(current))
                result.add(new String(current));
        } else {
            current[pos] = '(';
            generateAll(current, pos+1, result);
            current[pos] = ')';
            generateAll(current, pos+1, result);
        }
    }

    public boolean valid(char[] current) {
        int balance = 0;
        for (char c: current) {
            if (c == '(') balance++;
            else balance--;
            if (balance &lt; 0) return false;
        }
        return (balance == 0);
    }
}

def generateParenthesis(self, N):
    if N == 0: return ['']
    ans = []
    for c in xrange(N):
        for left in self.generateParenthesis(c):
            for right in self.generateParenthesis(N-1-c):
                ans.append('({}){}'.format(left, right))
    return ans
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(2^{2n}n)，对于 2^{2n}个序列中的每一个，我们用于建立和验证该序列的复杂度为 O(n)。</p>
<p>空间复杂度：O(2^{2n}n)，简单地，每个序列都视作是有效的。请参见 方法三 以获得更严格的渐近界限。</p>
<p>方法二：回溯法<br>
思路和算法<br>
只有在我们知道序列仍然保持有效时才添加 '(' or ')'，而不是像 方法一 那样每次添加。我们可以通过跟踪到目前为止放置的左括号和右括号的数目来做到这一点，<br>
如果我们还剩一个位置，我们可以开始放一个左括号。 如果它不超过左括号的数量，我们可以放一个右括号。</p>
</blockquote>
<pre><code>class Solution {
    public List&lt;String&gt; generateParenthesis(int n) {
        List&lt;String&gt; ans = new ArrayList();
        backtrack(ans, &quot;&quot;, 0, 0, n);
        return ans;
    }

    public void backtrack(List&lt;String&gt; ans, String cur, int open, int close, int max){
        if (cur.length() == max * 2) {
            ans.add(cur);
            return;
        }

        if (open &lt; max)
            backtrack(ans, cur+&quot;(&quot;, open+1, close, max);
        if (close &lt; open)
            backtrack(ans, cur+&quot;)&quot;, open, close+1, max);
    }
}
</code></pre>
<p><img src="https://lixin-ee.github.io//post-images/1571226174878.png" alt=""></p>
<p>方法三：闭合数<br>
思路</p>
<p>为了枚举某些内容，我们通常希望将其表示为更容易计算的不相交子集的总和。</p>
<p>考虑有效括号序列 S 的 闭包数：至少存在 index &gt;= 0，使得 <code>S[0], S[1], ..., S[2*index+1]</code>是有效的。 显然，每个括号序列都有一个唯一的闭包号。 我们可以尝试单独列举它们。</p>
<p>算法</p>
<p>对于每个闭合数 c，我们知道起始和结束括号必定位于索引 0 和<code>2*c + 1</code>。然后两者间的 <code>2*c</code> 个元素一定是有效序列，其余元素一定是有效序列。</p>
<pre><code>class Solution {
    public List&lt;String&gt; generateParenthesis(int n) {
        List&lt;String&gt; ans = new ArrayList();
        if (n == 0) {
            ans.add(&quot;&quot;);
        } else {
            for (int c = 0; c &lt; n; ++c)
                for (String left: generateParenthesis(c))
                    for (String right: generateParenthesis(n-1-c))
                        ans.add(&quot;(&quot; + left + &quot;)&quot; + right);
        }
        return ans;
    }
}
</code></pre>
<blockquote>
<p>时间空间复杂度与题解二相同</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[反向迭代器的insert与erase （insert不能直接使用反向迭代器）]]></title>
        <id>https://lixin-ee.github.io//post/fan-xiang-die-dai-qi-shi-wu-fa-jin-xing-insert-cha-ru-cao-zuo</id>
        <link href="https://lixin-ee.github.io//post/fan-xiang-die-dai-qi-shi-wu-fa-jin-xing-insert-cha-ru-cao-zuo">
        </link>
        <updated>2019-10-16T02:06:24.000Z</updated>
        <content type="html"><![CDATA[<p>问题：<br>
做题时对容器进行逆序对比，再进行插入操作然后报错了。</p>
<pre><code>if
(i==digits.rend())  
                digits.insert(digits.rend(),1); 
</code></pre>
<p>原因：<br>
反向迭代器是无法进行insert插入操作的， digits.insert(digits.rend(),1);是无法通过编译的，reverse iterator并不属于五种迭代器类型之一<br>
有些容器的成员函数只接受iterator类型的参数，所以如果你想要在ri所指的位置插入一个新元素，你不能直接这么做，因为vector的insert函数不接受reverse_iterator。如果你想要删除ri 所指位置上的元素也会有同样的问题。erase成员函数会拒绝reverse_iterator，坚持要求iterator。为了完成删除和一些形式的插入操作，你必须先通过base函数将reverse_iterator转换成iterator，然后用iterator来完成工作。</p>
<p>然后展开说一下吧<br>
ri<br>
1 2 3 4<br>
i<br>
如上简图所示，如果ri指向2，那么ri.base()也就是i会指向3（同理如果ri指向4，那么i应该是end()）<br>
所以对于insert操作的话，使用ri.base()是正确的的<br>
但是对于erase来说，是删除当前迭代器指向的元素，那就不对劲了，需要将--i，也就是--ri.base()</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math 66. 加一]]></title>
        <id>https://lixin-ee.github.io//post/math-66-jia-yi</id>
        <link href="https://lixin-ee.github.io//post/math-66-jia-yi">
        </link>
        <updated>2019-10-16T01:52:22.000Z</updated>
        <content type="html"><![CDATA[<p>难度：简单</p>
<pre><code>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。
最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。
你可以假设除了整数 0 之外，这个整数不会以零开头。

示例 1:
输入: [1,2,3]
输出: [1,2,4]
解释: 输入数组表示数字 123。
示例 2:
输入: [4,3,2,1]
输出: [4,3,2,2]
解释: 输入数组表示数字 4321。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/plus-one
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
</code></pre>
<p>这道题的难点在于：如果遇到个位为9的情况，需要置为0并向前进位，同时如果遇到全部位数为9的情况，则需要全部位数置为0，并在vector前面新增一位1。<br>
解决思路：单独判断特殊情况，以个位为9作为判断条件，不断向前递推直到遇到不为9的数，如果全部为9，则插入1并返回，其他情况可直接返回<br>
代码如下</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; plusOne(vector&lt;int&gt; digits) {
        bool flag=false;
        int len=digits.size();
        if(digits[len-1]==9){
            auto i=digits.rbegin();
            while(i&lt;digits.rend()&amp;&amp;*i==9){
                *i=0;
                ++i;
            }
            if(i==digits.rend())  
                digits.insert(digits.begin(),1); 
            else
                ++*i;
            return digits;
        }
        digits[len-1]+=1;
        return digits;
    }
};
</code></pre>
<p>其中遇到的难点和注意点：<br>
1.反向迭代器是无法进行insert插入操作的， digits.insert(digits.rend(),1);是无法通过编译的，reverse iterator并不属于五种迭代器类型之一<br>
2.<code>(i&lt;digits.rend()&amp;&amp;*i==9)</code>判断条件的先后顺序很重要，如果反过来的话就会造成解引用未知指针的危险操作。<br>
3.临时对象的创建 是在类型后面加上括号，括号内再加入初始值调用构造函数，<code>plusOne(vector&lt;int&gt; ( {1,2,3,4} ))</code></p>
<p>最后是网友题解：</p>
<blockquote>
<p>根据题意加一，没错就是加一这很重要，因为它是只加一的所以有可能的情况就只有两种：<br>
1.除 9 之外的数字加一；<br>
2.数字 9<br>
加一得十进一位个位数为 0 加法运算如不出现进位就运算结束了且进位只会是一。</p>
<p>所以只需要判断有没有进位并模拟出它的进位方式，如十位数加 11 个位数置为 00，如此循环直到判断没有再进位就退出循环返回结果。</p>
<p>然后还有一些特殊情况就是当出现 9999、999999 之类的数字时，循环到最后也需要进位，出现这种情况时需要手动将它进一位。</p>
</blockquote>
<pre><code>Java
class Solution {
    public int[] plusOne(int[] digits) {
        for (int i = digits.length - 1; i &gt;= 0; i--) {
            digits[i]++;
            digits[i] = digits[i] % 10;
            if (digits[i] != 0) return digits;
        }
        digits = new int[digits.length + 1];
        digits[0] = 1;
        return digits;
    }
}
</code></pre>
<p>优雅很多hhh，值得学习</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ C++ primer 第十二章 笔记+习题 12.1]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-er-zhang-bi-ji-xi-ti-121</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-er-zhang-bi-ji-xi-ti-121">
        </link>
        <updated>2019-10-16T01:25:19.000Z</updated>
        <content type="html"><![CDATA[<p>12动态内存<br>
<strong>静态内存</strong>用于保存局部static对象、类static数据成员以及定义在任何函数之外的变量<br>
<strong>栈内存</strong>用于保存定义在函数内的非static对象<br>
分配在静态内存和栈内存中的对象由<strong>编译器自动创建和销毁</strong>，栈对象在程序运行时才存在，static对象在使用前分配，程序结束时销毁<br>
除了静态内存和栈内存，每个程序还有一个<strong>内存池，称为自由空间或堆</strong>，程序用堆来存储动态分配的对象</p>
<p>12.1动态内存和智能指针<br>
动态内存的管理，new：在动态内存中为对象分配空间并返回一个指向该对象的指针，可以对其进行初始化；delete：接受一个动态对象的指针，销毁该对象，并释放与之关联的内存<br>
新的标准库为了使用动态内存提供了两种智能指针，与常规指针相比重要的区别在于它负责<strong>自动释放</strong>所指对象，<br>
shared_ptr：允许多个指针指向同一个对象；unique_ptr独占所指向的对象 weak_ptr 弱引用，指向shared_ptr管理的对象 。这三种都定义在memory头文件中</p>
<p>12.1.1shared_ptr<br>
智能指针也是模板，创建时必须提供指针指向的类型<br>
默认初始化的智能指针保存一个空指针<br>
智能指针并不支持指针算术操作</p>
<p>！！使用get时，若智能指针释放了其对象，返回的指针所指向的对象也就消失了<br>
最安全的分配和使用动态内存的方法是调用一个名为make_shared的标准库函数，此函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr，make_shared定义在头文件memory中<br>
make_shared用其参数来构造给定类型的对象，比如调用<code>make_shared&lt;string&gt;</code>必须传递与string某个构造函数相匹配的参数。如果不传递任何参数，对象就会进行值初始化<br>
当进行拷贝赋值操作时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象<br>
我们可以认为每个shared_ptr都有一个关联计数器，通常称其为引用计数。无论何时我们拷贝一个shared_ptr都会递增计数器<br>
递增计数器的情况1.用一个shared_ptr初始化另外一个shared_ptr2.将shared_ptr作为参数传递给一个函数3. shared_ptr作为函数的返回值<br>
递减计数器 1.给shared_ptr赋一个新值2. shared_ptr被销毁3. 局部的shared_ptr离开其作用域（在函数中定义的shared_ptr都是局部变量，在函数执行结束后都会被销毁）<br>
一旦shared_ptr的计数器变为0，就会自动释放所管理的对象，可以确保分配的对象在恰当的时刻被释放<br>
每个类都有一个析构函数，控制此类型的对象销毁时会做什么操作<br>
将shared_ptr放在容器中容易因重新排序等因素忘记进行销毁，导致内存浪费，所以要记得用erase删除容器中不需要的shared_ptr元素<br>
使用动态内存的原因：1.不知道需要使用多少对象2.不知道所需对象的准确类型3.！！程序需要在多个对象间共享数据</p>
<p>当两个对象共享底层的数据时，当某个对象被销毁，不能单方面地销毁底层数据<br>
使用动态内存的一个常见原因就是允许多个对象共享相同的状态<br>
<code>initializer_list&lt;string&gt;</code>类型参数接受一个初始化器的花括号列表</p>
<p>习题12.1<br>
一共有4个<br>
习题12.2<br>
直接复现一遍书中代码吧</p>
<pre><code>class StrBlob {
public:
	typedef vector&lt;string&gt;::size_type size_type;
	StrBlob() :data(make_shared&lt;vector&lt;string&gt;&gt;()) {};
	StrBlob(initializer_list&lt;string&gt; i1):data(make_shared&lt;vector&lt;string&gt;&gt;(i1)) {};
	size_type size() const { return data-&gt;size(); }
	bool empty() const { return data-&gt;empty(); }
	void push_back(const string &amp;t) { data-&gt;push_back(t); }
	void pop_back() {
		check(0, &quot;pop_back on empty StrBlob&quot;);
		data-&gt;pop_back();
	};;
	string&amp; front() {
		check(0, &quot;front on empty StrBlob&quot;);
		return data-&gt;front();
	};
	string&amp; back() {
		check(0, &quot;back on empty StrBlob&quot;);
		return data-&gt;back();
	};
private:
	shared_ptr&lt;vector&lt;string&gt;&gt; data;
	void check(size_type i, const string &amp;msg)const {
		if (i &gt;= data-&gt;size())
			throw out_of_range(msg);
	};
};
</code></pre>
<p>习题12.3<br>
不需要<br>
跟在参数列表后的const表示this是一个指向常量的指针，这样使用const的成员函数被称为常量成员函数，用于表示常量成员函数不能改变调用它的对象的内容<br>
这两者都会改变调用对象的内容，所以不需要加const<br>
习题12.4<br>
因为是私有函数，只能被程序编写者调用，所以不用担心向无符号数传入负值<br>
私有函数private相比于public公有函数的好处在于某些时候可以不用考虑判断条件，比如不用担心会向size_type传入负数<br>
习题12.5<br>
explicit的作用就是抑制构造函数的隐式转换<br>
优点：不会自动的进行类型转换，必须准确地输入相应的类型，防止出现输入错误的情况。<br>
缺点：必须用构造函数显示创建一个对象，或者显式地进行转换，不够方便简单</p>
<p>习题感悟<br>
私有函数private相比于public公有函数的好处在于某些时候可以不用考虑判断条件，比如不用担心会向size_type传入负数</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vptr指针[unfinished]]]></title>
        <id>https://lixin-ee.github.io//post/vptr-zhi-zhen-wei-yue-du</id>
        <link href="https://lixin-ee.github.io//post/vptr-zhi-zhen-wei-yue-du">
        </link>
        <updated>2019-10-15T12:19:55.000Z</updated>
        <content type="html"><![CDATA[<p>原文<a href="https://www.cnblogs.com/yangguang-it/p/6547314.html">c++多态之——vptr指针</a><br>
之前做过一个测试，在一个类中定义一个virtual修饰的函数时，sizeof这个类，发现类的大小多了恰好一个指针的字节大小，当初不明白，只是记住有这么一个特性。后来，发现它就是c++编译器给我们添加的vptr指针。</p>
<p>当类中声明虚函数时，编译器会在类中生成一个虚函数表；</p>
<p>虚函数表是一个存储成员函数指针的数据结构；</p>
<p>虚函数表是由编译器自动生成与维护的；</p>
<p>virtual成员函数会被编译器放入虚函数表中；</p>
<p>存在虚函数时，每个对象都有一个指向虚函数的指针（vptr指针）</p>
<p>在实现多态的过程中，父类和派生类都有vptr指针。</p>
<p>对象中的vptr指针什么时候被初始化：</p>
<p>对象在创建时，由编译器对vptr指针进行初始化；</p>
<p>只有当对象的构造完全结束后vptr的指向才最终决定下来；</p>
<p>父类对象的vptr指向父类的虚函数表，子类对象的vptr指向子类的虚函数表。</p>
<p>定义子类对象时，vptr先指向父类的虚函数表，在父类构造完成之后，子类的vptr才指向自己的虚函数表。（这也就是在父类或者子类的构造函数中调用虚成员函数不会实现多态的原因，这是一道面试题）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[const函数或const对象只能调用const函数 错误：对象包含与成员函数不兼容的类型限定符]]></title>
        <id>https://lixin-ee.github.io//post/const-han-shu-zhong-zhi-neng-diao-yong-const-han-shu-cuo-wu-dui-xiang-bao-han-yu-cheng-yuan-han-shu-bu-jian-rong-de-lei-xing-xian-ding-fu</id>
        <link href="https://lixin-ee.github.io//post/const-han-shu-zhong-zhi-neng-diao-yong-const-han-shu-cuo-wu-dui-xiang-bao-han-yu-cheng-yuan-han-shu-bu-jian-rong-de-lei-xing-xian-ding-fu">
        </link>
        <updated>2019-10-15T12:12:35.000Z</updated>
        <content type="html"><![CDATA[<p>情况：<br>
在bool compareIsbn(const Sales_data &amp;lhs,const Sales_data &amp;rhs)中调用bool compareISBN(Sales_Data &amp;lhs, Sales_Data &amp;rhs)<br>
错误：对象包含与成员函数不兼容的类型限定符<br>
原因：<br>
1）const对象只能调用const函数；<br>
2）如果const函数中不小心修改了类成员或者调用了非常量函数，编译器会找出这类错误。<br>
解决方法<br>
将compareISBN改成<br>
bool compareISBN(const Sales_Data &amp;lhs, const Sales_Data &amp;rhs)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[类成员函数的调用 错误invalid use of non-static member function ]]></title>
        <id>https://lixin-ee.github.io//post/lei-cheng-yuan-han-shu-de-diao-yong-cuo-wu-invalid-use-of-non-static-member-function</id>
        <link href="https://lixin-ee.github.io//post/lei-cheng-yuan-han-shu-de-diao-yong-cuo-wu-invalid-use-of-non-static-member-function">
        </link>
        <updated>2019-10-15T12:01:40.000Z</updated>
        <content type="html"><![CDATA[<p>原文链接<a href="https://www.cnblogs.com/scoyer/p/6533685.html">记一次C++的纠错过程</a><br>
经历和我一模一样，甚至于可能连题号都一致，我就不画蛇添足了，<br>
情况：向泛型函数提交自定义的比较大小函数，例如sort(begin(),end,compareIsbn)<br>
主要问题：报错 invalid use of non-static member function<br>
原因：不能直接使用指针来调用类成员函数，特别是在定义其他类成员函数的时候。因为代码中定义了类但<strong>并没有初始化这个类的成员函数</strong>。当你声明了具体的实例之后，一个<strong>实例调用构造函数才被初始化了</strong>，所以<strong>函数指针才能指向具体的类的成员函数</strong>。<br>
解决办法<br>
1.创建对象或临时对象<br>
2.那如果在定义中想要传一个成员函数指针给其他函数调用，这就要利用static对象的特性了，因为static的生存周期是从被构造出来到程序结束，也就是程序编译之后就被初始化好了。</p>
<p>下面为原文</p>
<p>事出的起因是我在leetcode刷着一道题，需要排序，于是我就自定义了一个比较函数，代码如下：</p>
<p>复制代码</p>
<pre><code>class Solution {
public:
  inline int digit(int x) {
    if (!x) return 10;
    int ret = 1;
    while (x) ret *= 10, x /= 10;
    return ret;
  }
  inline int cmp(int a, int b) {
    long long ab = 1LL * a * digit(b) + b, ba = 1LL * b * digit(a) + a;
    return ab &gt; ba;
  }
  string largestNumber(vector&lt;int&gt; nums) {
    sort(nums.begin(), nums.end(), Solution::cmp);
    string ret;
    char t[100];
    for (int i = 0; i &lt; nums.size(); i++) {
      if (ret == &quot;0&quot; &amp;&amp; !nums[i]) continue;
      sprintf(t, &quot;%d&quot;, nums[i]);
      ret = ret + t;
    }
    return ret;
  }
};
</code></pre>
<p>结果这个函数死活通过不了编译，乱改乱改还出现了invalid use of non-static member function 问题。看来成员函数不让这么弄，翻阅C++大师Stanley Lippman的Essential C++找一下成员函数的相关用法，还参考了一些技术博客，原来是C++的语法不过关啊！！/哭</p>
<p>下面回顾一下我纠错的过程，先看下面一段代码熟悉一下怎么调用普通的函数指针：</p>
<pre><code>/*zhen hao*/
#include &lt;bits/stdc++.h&gt;
using namespace std;

int F(double x) { return int(x); }

int G(double x) { return int(x) + 1; }

int main() {
  int (*p1)(double) = &amp;F;
  int (*p2)(double) = &amp;G;
  cout &lt;&lt; (*p1)(1) &lt;&lt; endl;
  cout &lt;&lt; (*p2)(1) &lt;&lt; endl;
  return 0;
}
</code></pre>
<p>如果用指针指向类的成员函数的时候就稍有不同，试着根据自己的想法改一下，主要是加上类的scope运算符限定一下函数的范围：</p>
<pre><code>/*zhen hao*/
#include &lt;bits/stdc++.h&gt;
using namespace std;

class C {
public:
  C() {}
  int F(double x) { return int(x); }
  int G(double x) { return int(x) + 1; }
};

int main() {
  int (C::*p1)(double) = &amp;C::F; //编译通过
  int (C::*p2)(double) = &amp;C::G; //编译通过
  cout &lt;&lt; (C::*p1)(1) &lt;&lt; endl; //error: expected unqualified-id before '*' token
  cout &lt;&lt; (C::*p2)(1) &lt;&lt; endl; //error: expected unqualified-id before '*' token
  return 0;
}
</code></pre>
<p>想当然以为简单改一下可以，然而编译不通过问题出在哪里呢？编译器报的错误是什么意思？</p>
<p>（1）先简单解释一下这个qualified是什么意思？</p>
<p>单词的意思是有限制的，也就是一些有范围的变量，例如下面的代码：</p>
<pre><code>1 #include &lt;iostream&gt;
2 int main()  {
3    std::cout&lt;&lt;&quot;Hello world!&quot;&lt;&lt;std::endl; //cout和endl都是qualified name，因为他们都限定在std这个明明空间上。
4    return 0;
5 }
</code></pre>
<p>值得注意的是，如果我们之间在代码上指定命名空间的话，例如using namespace std，那么cout和endl就是unqualified name了。</p>
<p>（2）另外id的全称是identifier，即标识符。</p>
<p>所以上述编译器希望这是一个qualified-id，也就是希望p1，p2是一个不需要用C::限定的变量，去掉之后仍然报错，报的错误是<code>invalid use of 'unary *' on pointer to member</code>，不能够用指针指着成员直接使用。</p>
<p>书上指出，pointer to member function和pointer to function的不同点是，前者必须通过同一类对象加以调用，而该对象便是此member function内的this指针所指之物。</p>
<p>所以以下用法才是正确的：</p>
<pre><code>/*zhen hao*/
#include &lt;bits/stdc++.h&gt;
using namespace std;

class C {
public:
  C() {}
  int F(double x) { return int(x); }
  int G(double x) { return int(x) + 1; }
};

int main() {
  int (C::*p1)(double) = &amp;C::F;
  int (C::*p2)(double) = &amp;C::G;
  C *c = new C();
  cout &lt;&lt; (c-&gt;*p1)(1) &lt;&lt; endl;
  cout &lt;&lt; (c-&gt;*p2)(1) &lt;&lt; endl;
  return 0;
}
</code></pre>
<p>原来我们需要的是一个实例来调用成员函数指针。</p>
<p>到这里就要问为什么呢？</p>
<p>因为代码中定义了C类并没有初始化这个类的成员函数。当你声明了具体的实例之后，一个实例调用构造函数被初始化了，所以函数指针才能指向具体的类的成员函数。那如果想要传一个成员函数指针给其他函数调用该怎么做？这就要利用static对象的特性了，因为static的生存周期是从被构造出来到程序结束，也就是程序编译之后就被初始化好了。</p>
<p>所以我们将上述代码改一下就能改正错误的代码了：</p>
<pre><code>/*zhen hao*/
#include &lt;bits/stdc++.h&gt;
using namespace std;

class C {
public:
  C() {}
  static int F(double x) { return int(x); }
  static int G(double x) { return int(x) + 1; }
};

int main() {
  int (*p1)(double) = &amp;C::F;
  int (*p2)(double) = &amp;C::G;
  cout &lt;&lt; (*p1)(1) &lt;&lt; endl;
  cout &lt;&lt; (*p2)(1) &lt;&lt; endl;
  return 0;
}
</code></pre>
<p>用static关键字修饰之后的成员函数就像普通函数一样可以传给别的函数做参数，使用也像普通函数一样。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于istringstream等输入流]]></title>
        <id>https://lixin-ee.github.io//post/guan-yu-istringstream-deng-shu-ru-liu</id>
        <link href="https://lixin-ee.github.io//post/guan-yu-istringstream-deng-shu-ru-liu">
        </link>
        <updated>2019-10-15T11:32:18.000Z</updated>
        <content type="html"><![CDATA[<p>今天做题时<a href="https://lixin-ee.github.io/post/math-165-bi-jiao-ban-ben-hao/">版本号比较</a>遇到一个题解</p>
<pre><code>class Solution {
public:
    int compareVersion(string version1, string version2) {
        char c;
        int v1,v2;
        istringstream its1(version1);
        istringstream its2(version2);
        
        while(bool(its1&gt;&gt;v1) + bool(its2&gt;&gt;v2)){
            if(v1&gt;v2) return 1;
            if(v1&lt;v2) return -1;
            
            v1=0;
            v2=0;
            its1&gt;&gt;c;
            its2&gt;&gt;c;
            
        }
        
        return 0;
    }
};
</code></pre>
<p>输入是 输入: version1 = &quot;7.5.2.4&quot;, version2 = &quot;7.5.3&quot;<br>
一开始百思不得其解，为何会自动以点号为分割？同时为何会自动去掉前置0？<br>
受到评论指引，才发现原来v1和v2可是int类型！<br>
所以在这里可以看出，isrtringstream或者说输入流，都会按照赋值的类型来读取分割，比如如果是赋值给float，则会读入第一个点号，而忽略第二个点号。<br>
而istringstream的string意为将一个string作为读入字符串（类似于cin的缓冲区），而不是说istringstream只能赋值给string。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MATH 165. 比较版本号]]></title>
        <id>https://lixin-ee.github.io//post/math-165-bi-jiao-ban-ben-hao</id>
        <link href="https://lixin-ee.github.io//post/math-165-bi-jiao-ban-ben-hao">
        </link>
        <updated>2019-10-15T10:49:02.000Z</updated>
        <content type="html"><![CDATA[<p>难度：中等</p>
<blockquote>
<p>比较两个版本号 version1 和 version2。<br>
如果 version1 &gt; version2 返回 1，如果 version1 &lt; version2 返回 -1， 除此之外返回 0。<br>
你可以假设版本字符串非空，并且只包含数字和 . 字符。<br>
 &gt; . 字符不代表小数点，而是用于分隔数字序列。<br>
例如，2.5 不是“两个半”，也不是“差一半到三”，而是第二版中的第五个小版本。<br>
你可以假设版本号的每一级的默认修订版号为 0。例如，版本号 3.4 的第一级（大版本）和第二级（小版本）修订号分别为 3 和 4。其第三级和第四级修订号均为 0。</p>
<p>示例 1:<br>
输入: version1 = &quot;0.1&quot;, version2 = &quot;1.1&quot;<br>
输出: -1<br>
示例 2:<br>
输入: version1 = &quot;1.0.1&quot;, version2 = &quot;1&quot;<br>
输出: 1<br>
示例 3:<br>
输入: version1 = &quot;7.5.2.4&quot;, version2 = &quot;7.5.3&quot;<br>
输出: -1<br>
示例 4：<br>
输入：version1 = &quot;1.01&quot;, version2 = &quot;1.001&quot;<br>
输出：0<br>
解释：忽略前导零，“01” 和 “001” 表示相同的数字 “1”。<br>
示例 5：<br>
输入：version1 = &quot;1.0&quot;, version2 = &quot;1.0.0&quot;<br>
输出：0<br>
解释：version1 没有第三级修订号，这意味着它的第三级修订号默认为 “0”。<br>
 <br>
提示：<br>
版本字符串由以点 （.） 分隔的数字字符串组成。这个数字字符串可能有前导零。<br>
版本字符串不以点开始或结束，并且其中不会有两个连续的点。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/compare-version-numbers<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>一开始的想法是先分析一下难点<br>
1.靠点号分割的话，位数不同<br>
2.会有前导0<br>
然后思考一下处理方式<br>
1.利用find函数进行点号分割，分割之后可以当场进行对比，或者存进容器里面进行对比。前者需要对首先对长度进行对比，后者的话可以通过push_back来补充位数<br>
2.前导0的处理方法 一个是find函数检测并去掉多余的0，一个是转化为int自动去掉，最后一个则是在对应的数前面补0，比如02和1对比，就向1补0，使得02和01对比。<br>
最后为了代码的可读性，我选择了vector补位+补0</p>
<pre><code>class Solution {
public:
    int compareVersion(string version1, string version2) {
        vector&lt;string&gt; v1,v2;
        split(version1,v1);
        split(version2,v2);
        int len=0;
        if(v1.size()&gt;v2.size()){
            len=v1.size()-v2.size();
            while(len)
                --len,v2.push_back(&quot;0&quot;);
        }
        else{
            len=v2.size()-v1.size();
            while(len)
                --len,v1.push_back(&quot;0&quot;);
        }
        for(int i=0;i&lt;v1.size();++i ){
            if(v1[i].size()&gt;v2[i].size()){
                 len=v1[i].size()-v2[i].size();;
                 while(len)
                    --len,v2[i]=&quot;0&quot;+v2[i];
             }
              else{
                 len=v2[i].size()-v1[i].size();
                 while(len)
                    --len,v1[i]=&quot;0&quot;+v1[i];
             }
            if(v1[i]&gt;v2[i])
                return 1;
            else if (v1[i]&lt;v2[i])
                return -1;
        }
            
          return 0;        
    }
    
    void split(string &amp;version,vector&lt;string&gt; &amp;v){
        char comma='.';
        for(int i=0;i&lt;version.size();){
            int j=version.find(comma,i);
            if(j==string::npos){
                v.push_back(version.substr(i,version.size()-i));
                break;
            }              
            v.push_back(version.substr(i,j-i));
            i=j+1;
        }
    }   
};
</code></pre>
<p>这道题有个很明显的问题是代码比较臃肿，重复代码太多，所以我把分割操作合成一个函数了，可读性明显高了很多<br>
然后高赞网友题解都类似，都是点号分解<br>
最后是有个比较秀的操作：</p>
<pre><code>class Solution {
public:
    int compareVersion(string version1, string version2) {
        char c;
        int v1,v2;
        istringstream its1(version1);
        istringstream its2(version2);
        
        while(bool(its1&gt;&gt;v1) + bool(its2&gt;&gt;v2)){
            if(v1&gt;v2) return 1;
            if(v1&lt;v2) return -1;
            
            v1=0;
            v2=0;
            its1&gt;&gt;c;
            its2&gt;&gt;c;
            
        }
        
        return 0;
    }
};
</code></pre>
<p>注意是把 istringstream 强行输入赋值给int，此时输入流会强制读取一个符合int格式的string值，所以输入流会以点号为结束符，并且将其自动转化为int类型，也就同时完成了分割和去掉前置0两个任务，所以代码非常简单，只是需要仔细研究一下才好。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第十一章 笔记+习题 11.3-11.4]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-yi-zhang-bi-ji-xi-ti-113-114</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-yi-zhang-bi-ji-xi-ti-113-114">
        </link>
        <updated>2019-10-14T03:06:22.000Z</updated>
        <content type="html"><![CDATA[<p>11.3关联容器操作<br>
map的value_type为<code>pair&lt;const key_type,mapped_type&gt;</code><br>
我们不能改变pair中的关键字，因此这些pair的关键字部分是const的（set中的关键字也是const的）<br>
只有map类型才能定义mapped_type</p>
<p>11.3.1关联容器迭代器<br>
一个map 的value_type是一个pair，我们可以改变pair的值，但是不能改变关键字成员的值<br>
虽然map和set类型同时定义了iterator和const_iterator两种类型，但两种类型都只允许只读访问set中的元素，<strong>set的关键字是const的，set的迭代器也是const的</strong>。<br>
map和set类型都支持表9.2（p295）中的begin和end操作<br>
当时用一个迭代器遍历一个map、multimap、set或multiset时，迭代器按关键字升序遍历元素<br>
我们通常<strong>不对关联容器使用泛型算法</strong>，因为关键字是const，不能将关联容器传递给修改或重排容器元素的算法<br>
关联容器中的元素不<strong>能通过它们的关键字进行快速查找</strong>，所以使用关联容器定义的专用的find成员会比调用泛型find快得多<br>
在实际编程中，如果我们真要对一个关联容器使用算法，要么将它当做一个<strong>源序列</strong>，要么当做一个<strong>目的位置</strong><br>
迭代器的类型需要在iterator或者const_iterator加上类类型，比如map&lt;const string, size_t&gt;::const_iterator<br>
map和set中的 key_type其实都会自动加上const但是在声明类型时不需要加上，比如Sales_Data，除非是像map_it那样显式声明。只需要注意使用auto或者decltype时会自动加上const<br>
关联容器的迭代器时双向迭代器（由红黑树决定），只能进行相等不等的比较，无法进行小于的比较！！！</p>
<p>习题11.15<br>
value_type为 pair<code>&lt;int,vector&lt;int&gt;&gt;</code> key_type为int mapped_type为vector<br>
习题11.16</p>
<pre><code>	map&lt;string, int&gt; map_si{ {&quot;123&quot;,123} };
	(*map_si.begin()).second = 321;
</code></pre>
<p>注意的点：map的迭代器不能直接解引用就赋值，还是需要.second，然后第二个调用前的括号必不可少，第一个调用则不需要括号<br>
习题11.17<br>
（1）不合法，显示error type，因为关联容器的迭代器时const的，不能进行写操作<br>
（2）同上<br>
（3）（4）合法<br>
习题11.18<br>
注意不是<code>const_iterator&lt;map&lt;const string ,size_t&gt;&gt;</code>！<br>
而是<code>map&lt;const string, size_t&gt;::const_iterator</code><br>
需要在iterator或者const_iterator加上类类型， 比如string、map、vector等等<br>
习题11.19<br>
<code>multiset&lt;Sales_Data, bool(*)(const Sales_Data &amp;lhs, const Sales_Data &amp;rhs)&gt;::iterator mi=bookstore.begin();</code><br>
注意 map和set中的 key_type其实都会自动加上const但是在声明类型时不需要加上，比如Sales_Data，除非是像map_it那样显式声明。只需要注意使用decltype时会自动加上const，但是auto不会（auto忽略顶层const）</p>
<p>11.3.2添加元素<br>
向map和set插入一个已存在的元素没有任何影响<br>
insert有两个版本，分别接受一对迭代器，或是一个初始化器列表，对于一个给定的关键字，只有第一个带此关键字的元素才会被插入到容器中（<strong>对于map很重要</strong>，比如{{1,a}{1,b}}两者之间谁能插入）<br>
insert和emplace的返回值依赖于容器的类型和参数，对于不包含重复关键字的容器返回一个pair，告诉我们插入操作是否成功。返回的pair的first成员是一个迭代器，指向具有给定关键字（插入值）的元素，second成员是一个bool值，指出元素是插入成功还是已经存在于容器中。如果关键字插入失败，返回值为false，否则返回为true<br>
对于允许重复关键字的容器，接受单个元素的insert操作返回一个指向新元素的迭代器，这里无须返回一个bool值</p>
<p>习题11.20</p>
<pre><code>int main()
{
	map&lt;string, size_t&gt; word_count;
	string word;
	while (cin &gt;&gt; word)
		if (!word_count.insert(make_pair(word, 1)).second)
			++word_count[word];
}
</code></pre>
<p>insert更加容易编写阅读，因为下标运算符会强行将元素添加进去<br>
习题11.21<br>
将单词插入到map中，并在键值中记录单词出现的次数<br>
习题11.22<br>
参数类型<code>pair&lt;const string,vector&lt;int&gt;&gt;</code><br>
返回类型<code>pair&lt;map&lt;string,vector&lt;int&gt;&gt;::iterator,bool&gt;</code><br>
习题11.23</p>
<pre><code>int main()
{
	multimap&lt;string, vector&lt;string&gt;&gt; map_name;
	string first_name, last_name;
	while (cin) {
		cin &gt;&gt; first_name &gt;&gt; last_name;	
		map_name.insert({ first_name,{ last_name } });
	}
}
</code></pre>
<p>11.3.3删除新元素<br>
关联容器定义有三个版本的erase<br>
注意c.erase(b,e)不包括e 是左闭右开区间 insert中也是<br>
erase可以接受一个key_type参数，此版本删除所有匹配给定关键字的元素，返回实际删除的元素的数量</p>
<p>11.3.4map的下标操作<br>
map和unordered_map提供下标运算符和对应的at函数，返回的是second值<br>
set类型不支持下标和at()（或者说不需要）<br>
multimap和unordered_map不支持下标操作，因为有多个值与一个关键字相关联<br>
map下标运算符接受一个索引，获取与此关键字相关联的值，但是注意！！！如果关键字并不在map，会为它创建一个元素插入map中，并对关联值进行值初始化<br>
对关键字会强行加上顶层const<br>
由于下标运算符可能插入一个新元素，所以只可以对非const的map使用下标操作<br>
与vector和string不同，map下标运算符返回的类型与解引用map迭代器返回的类型不同，下标操作得到mapped_type对象，解引用迭代器得到一个value_type对象</p>
<p>习题11.24<br>
如果m中有关键字0，则将second改成1，否则向m插入{0，1}<br>
习题11.25<br>
vector的下标必须先构造，否则就是非法访问<br>
习题11.26<br>
map&lt;string,int&gt;中，下标操作的类型必须是string，返回类型是int，亦即key_type对其执行下标操作，mapped_type为其返回类型</p>
<p>11.3.5访问元素<br>
使用下标操作有一个严重的副作用，如果关键字还未在map中，下标操作会插入一个具有给定关键字的元素<br>
find bound都是返回迭代器<br>
使用find就可以值检查给定关键字是否在map中<br>
multimap和multiset中具有相同关键字的元素在容器中会相邻存储，需要配合cout和find使用（find一次只能找到一个！！！）<br>
lower_bound和upper_bound这两个操作都接受一个关键字，返回一个迭代器。lower_bound返回指向第一个给定关键字的迭代器，upper_bound返回指向最后一个匹配给定关键字的元素之后的位置的迭代器。如果寻找不到，则返回相同迭代器，指向不影响排序的关键字插入位置<br>
equal_range接受一个关键字，返回一个迭代器pair，若关键字存在，则第一个迭代器指向第一个匹配的元素，第二个迭代器指向最后一个匹配元素之后的位置。如果不存在，则指向相同位置（亦即返回左闭右开区间）</p>
<p>习题11.27<br>
需要计算相同元素的数量时使用count，需要判断元素是否存在时使用find<br>
习题11.28<br>
<code>map&lt;string,vector&lt;int&gt;&gt;::iterator ite;</code><br>
习题 11.29<br>
upper和lower返回同一个值，指向不影响排序的关键字插入位置<br>
equal_range如果不存在，则返回一对指向相同位置迭代器的pair<br>
习题11.30<br>
pos是一个pair 里面是一对迭代器，first是左边迭代器，second则是这个迭代器的值<br>
习题11.31</p>
<pre><code>int main()
{
	multimap&lt;string, string&gt; multim{ {&quot;123&quot;,&quot;456&quot;} ,{ &quot;123&quot;,&quot;456&quot; } ,{ &quot;123&quot;,&quot;456&quot; } ,{ &quot;123&quot;,&quot;456&quot; } };
	string name=&quot;123&quot;, product;
	if (multim.find(name) != multim.end())
		multim.erase(name);
	cout &lt;&lt; multim.empty();
}
</code></pre>
<p>习题11.32</p>
<pre><code>int main()
{
	multimap&lt;string, string&gt; multim{ {&quot;123&quot;,&quot;1&quot;} ,{ &quot;123&quot;,&quot;2&quot; } ,{ &quot;456&quot;,&quot;1&quot; } ,{ &quot;123&quot;,&quot;1&quot; } };
	string name=&quot;123&quot;, product;
	for (auto left = multim.begin(); left != multim.end();) {
		auto right = multim.upper_bound((*left).first);
		cout &lt;&lt; (*left).first &lt;&lt; &quot; &quot;;
		while (left != right) {
			cout &lt;&lt; (*left).second &lt;&lt; &quot; &quot;;
			++left;
		}
		cout &lt;&lt; endl;
	}
}
</code></pre>
<p>习题感悟：关联容器的迭代器时双向迭代器（由红黑树决定），只能进行相等不等的比较，无法进行小于的比较！！！</p>
<p>11.3.6一个单词转换map<br>
习题11.33<br>
直接仿真了书中代码hhh<br>
习题11.34<br>
如果没找到的话反而会将当前关键值插入map，并且值为空<br>
习题11.35<br>
如果有重复关键值，则只保存最早的一个，否则就不断更新，无重复关键值的话无差别<br>
习题11.36<br>
不影响，因为对value.size()进行了判断，如果只要空格的话是会报错的</p>
<p>11.4无序容器<br>
注意<strong>顺序容器对应无序容器，关联容器不等同于无序容器</strong><br>
新标准定义了4个无序关联容器，无序容器不是使用比较运算符来组织元素，而是使用一个哈希函数，和关键字类型的==运算符<br>
如果关键字类型固有就是无序的，或者性能测试发现问题可以用哈希技术解决，就可以使用无序容器<br>
无序容器提供了与有序容器相同的操作（find、insert等），所以unordered_map和unordered_set也可以使用这些操作<br>
无序容器也有允许重复关键字的版本<br>
<strong>通常可以用一个无序容器替换对相应的有序容器，反之亦然</strong><br>
无序容器在存储组织上为<strong>一组桶</strong>，每个桶保存零个或多个元素，无序容器使用一个哈希函数将元素映射到桶，容器首先计算元素的哈希值，并将<strong>具有一个特定哈希值的所有元素都保存在相同的桶中</strong>，所有具有相同关键字的元素都会在同一个桶中，因此无序容器的性能依赖于<strong>哈希函数的质量和桶的数量和大小</strong><br>
对于相同的参数，哈希函数总是产生相同的结果<br>
将不同关键字映射到相同的桶也是允许的，当一个桶保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个</p>
<p>默认情况下无序容器使用关键字类型的==运算符来比较元素，还是用一个hash&lt;key_type&gt;类型来生成每个元素的哈希值，标准库为内置类型包括指针提供了hash模板</p>
<p>习题11.37<br>
无序版本优势：当容器中key没有明显的顺序关系时更有用,且不需要耗费多余的时间来维护容器中的key序列<br>
有序版本优势：当容器中key有明显的顺序关系时更有用,且我们不需要考虑排序问题,容器自动维护序列(字典序)<br>
习题11.38</p>
<pre><code>int main()
{
	unordered_map&lt;string, size_t&gt; word_count;
	string word;
	while (cin &gt;&gt; word)
		if (!word_count.insert(make_pair(word, 1)).second)
			++word_count[word];
	for (const auto &amp;w : word_count)
		cout &lt;&lt; w.first &lt;&lt; &quot; &quot; &lt;&lt; w.second &lt;&lt; endl;
}
</code></pre>
<p>通常可以用一个无序容器替换对相应的有序容器，反之亦然，内部的处理方式不同，外部的操作还是大同小异</p>
<p>习题感悟<br>
迭代器的类型需要在iterator或者const_iterator加上类类型， 比如string、map、vector等等<br>
map和set中的 key_type其实都会自动加上const但是在声明类型时不需要加上，比如Sales_Data，除非是像map_it那样显式声明。只需要注意使用decltype时会自动加上const，但是auto不会（auto忽略顶层const）<br>
关联容器的迭代器时双向迭代器（由红黑树决定），只能进行相等不等的比较，无法进行小于的比较！！！</p>
]]></content>
    </entry>
</feed>