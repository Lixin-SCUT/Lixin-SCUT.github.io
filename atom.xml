<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2020-01-29T08:06:20.049Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[数组 1.两数之和[简单][未做出]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-1liang-shu-zhi-he-jian-dan-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-1liang-shu-zhi-he-jian-dan-wei-zuo-chu">
        </link>
        <updated>2020-01-29T07:47:55.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<br>
你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。<br>
示例:<br>
给定 nums = [2, 7, 11, 15], target = 9<br>
因为 nums[0] + nums[1] = 2 + 7 = 9<br>
所以返回 [0, 1]<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/two-sum<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>手贱去翻评论看到用map，然后想到一个不错的方法，就是用哈希表存储一对值，key是target-nums[i]或者nums[i]，value则是i，那么如果在后面遇到适合的key时就可以直接返回了<br>
hhh还真就是最佳题解</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        unordered_map&lt;int,int&gt; res_val;
        int len=nums.size();
        for(int i=0;i&lt;len;++i){
            int res= target-nums[i];
            if(res_val.count(res))
                return vector&lt;int&gt;({res_val[res],i});
            res_val.insert({nums[i],i});   
        }
        return vector&lt;int&gt;();
    }
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>方法一：暴力法<br>
暴力法很简单，遍历每个元素 x，并查找是否存在一个值与target−x 相等的目标元素。</p>
</blockquote>
<pre><code>Java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        for (int i = 0; i &lt; nums.length; i++) {
            for (int j = i + 1; j &lt; nums.length; j++) {
                if (nums[j] == target - nums[i]) {
                    return new int[] { i, j };
                }
            }
        }
        throw new IllegalArgumentException(&quot;No two sum solution&quot;);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(n^2)<br>
对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费O(n) 的时间。因此时间复杂度为 O(n^2)。<br>
空间复杂度：O(1)。</p>
</blockquote>
<blockquote>
<p>方法二：两遍哈希表<br>
为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。<br>
通过以空间换取速度的方式，我们可以将查找时间从 O(n) 降低到 O(1)。哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)。<br>
一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i] 本身！</p>
</blockquote>
<pre><code>Java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; nums.length; i++) {
            map.put(nums[i], i);
        }
        for (int i = 0; i &lt; nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) {
                return new int[] { i, map.get(complement) };
            }
        }
        throw new IllegalArgumentException(&quot;No two sum solution&quot;);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(n)，<br>
我们把包含有 n 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1) ，所以时间复杂度为 O(n)。<br>
空间复杂度：O(n)，<br>
所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 nn 个元素。</p>
</blockquote>
<blockquote>
<p>方法三：一遍哈希表<br>
事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。</p>
</blockquote>
<pre><code>Java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement)) {
                return new int[] { map.get(complement), i };
            }
            map.put(nums[i], i);
        }
        throw new IllegalArgumentException(&quot;No two sum solution&quot;);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(n)，<br>
我们只遍历了包含有 nn 个元素的列表一次。在表中进行的每次查找只花费 O(1) 的时间。<br>
空间复杂度：O(n)，<br>
所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 n 个元素。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 86. 分隔链表[中等]]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-86-fen-ge-lian-biao-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-86-fen-ge-lian-biao-zhong-deng">
        </link>
        <updated>2020-01-28T02:35:39.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。<br>
你应当保留两个分区中每个节点的初始相对位置。<br>
示例:<br>
输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3<br>
输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/partition-list<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题描述的意思还是挺有趣的<br>
我想到的方法是类似于归并排序，不过反过来把一个链表分成两个链表</p>
<p>实现过程中不断地超时，但是我用了断点也没发现问题<br>
后来发现是return的问题，似乎打印节点时超时了，才发现原来是larger链表没有收尾，导致形成了一个环，5-&gt;2-&gt;4-&gt;3-&gt;5、<br>
所以链表题一定要注意收尾！！！</p>
<pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        ListNode *smaller=new ListNode(0);
        ListNode *larger=new ListNode(0);
        ListNode *cur=head,*cur_s=smaller,*cur_l=larger;
        while(cur){
            if(cur-&gt;val&lt;x){
                cur_s-&gt;next=cur;
                cur=cur-&gt;next;
                cur_s=cur_s-&gt;next;
            }else{
                cur_l-&gt;next=cur;
                cur=cur-&gt;next;
                cur_l=cur_l-&gt;next;
            }
        }
        cur_l-&gt;next=NULL;//链表题一定要注意收尾！！
        cur_s-&gt;next=larger-&gt;next;
        return smaller-&gt;next;
    }
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>本题要求我们改变链表结构，使得值小于 x的元素，位于值大于等于x元素的前面。这实质上意味着在改变后的链表中有某个点，在该点之前的元素全部小于x ，该点之后的元素全部 大于等于x。<br>
我们将这个点记为JOINT。<br>
对该问题的逆向工程告诉我们，如果我们在JOINT将改后链表拆分，我们会得到两个更小的链表，其中一个包括全部值小于x的元素，另一个包括全部值大于x的元素。在解法中，我们的主要目的是创建这两个链表，并将它们连接。</p>
</blockquote>
<blockquote>
<p>双指针法：<br>
直觉<br>
我们可以用两个指针before 和 after 来追踪上述的两个链表。两个指针可以用于分别创建两个链表，然后将这两个链表连接即可获得所需的链表。<br>
算法<br>
1.初始化两个指针 before 和 after。在实现中，我们将两个指针初始化为哑 ListNode。这有助于减少条件判断。<br>
2.利用head指针遍历原链表。<br>
3.若head 指针指向的元素值小于 x，该节点应当是 before 链表的一部分。因此我们将其移到 before 中。<br>
4.否则，该节点应当是after 链表的一部分。因此我们将其移到 after 中<br>
5.遍历完原有链表的全部元素之后，我们得到了两个链表 before 和 after。原有链表的元素或者在before 中或者在 after 中，这取决于它们的值。<br>
<em><code>注意:</code> 由于我们从左到右遍历了原有链表，故两个链表中元素的相对顺序不会发生变化。另外值得注意的是，在图中我们完好地保留了原有链表。事实上，在算法实现中，我们将节点从原有链表中移除，并将它们添加到别的链表中。我们没有使用任何额外的空间，只是将原有的链表元素进行移动。</em><br>
6.现在，可以将 before 和 after 连接，组成所求的链表。<br>
为了算法实现更容易，我们使用了哑结点初始化。不能让哑结点成为返回链表中的一部分，因此在组合两个链表时需要向前移动一个节点。</p>
</blockquote>
<pre><code>class Solution {
    public ListNode partition(ListNode head, int x) {

        // before and after are the two pointers used to create the two list
        // before_head and after_head are used to save the heads of the two lists.
        // All of these are initialized with the dummy nodes created.
        ListNode before_head = new ListNode(0);
        ListNode before = before_head;
        ListNode after_head = new ListNode(0);
        ListNode after = after_head;

        while (head != null) {

            // If the original list node is lesser than the given x,
            // assign it to the before list.
            if (head.val &lt; x) {
                before.next = head;
                before = before.next;
            } else {
                // If the original list node is greater or equal to the given x,
                // assign it to the after list.
                after.next = head;
                after = after.next;
            }

            // move ahead in the original list
            head = head.next;
        }

        // Last node of &quot;after&quot; list would also be ending node of the reformed list
        after.next = null;

        // Once all the nodes are correctly assigned to the two lists,
        // combine them to form a single list which would be returned.
        before.next = after_head.next;

        return before_head.next;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度: O(N)，其中NN是原链表的长度，我们对该链表进行了遍历。<br>
空间复杂度: O(1)，我们没有申请任何新空间。值得注意的是，我们只移动了原有的结点，因此没有使用任何额外空间。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 221. 最大正方形[中等][未做出]]]></title>
        <id>https://lixin-ee.github.io//post/dong-tai-gui-hua-221-zui-da-zheng-fang-xing-zhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/dong-tai-gui-hua-221-zui-da-zheng-fang-xing-zhong-deng-wei-zuo-chu">
        </link>
        <updated>2020-01-27T03:27:38.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。<br>
示例:<br>
输入:<br>
1 0 1 0 0<br>
1 0 1 1 1<br>
1 1 1 1 1<br>
1 0 0 1 0<br>
输出: 4<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/maximal-square<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>【未做出】<br>
偷看标签是动态规划hhh 实在是太累了</p>
<p>实现的过程中一开始我想着用matrix直接初始化squares，结果！才发现matrix是char不是int，太6了吧<br>
然后记得是必须取三者最小值（本来想用&amp;&amp;的，发现必须累加。。。）</p>
<p>然后优化一下空间，因为只用到了上一列和当前列的元素<br>
实现过程中犯了一些小错误 1.忘了判断matrix[i][j]<mark>'1'和</mark>'0'来更新值，前者导致完全错误，后者导致cur残留错误 2。pre_squares=cur_squares;的更新差点放在j的内循环了，必须放在外循环！！！</p>
<pre><code>class Solution {
public:
    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) {
        if(matrix.empty()) return 0;
        int len=matrix.size(),wid=matrix[0].size();
        vector&lt;int&gt; cur_squares(wid,0),pre_squares(wid,0);
        int max_square=0;
        for(int i=0;i&lt;len;++i){
            for(int j=0;j&lt;wid;++j){
                if(i==0||j==0)
                    cur_squares[j]=matrix[i][j]-'0';
                else if(matrix[i][j]=='1')//别漏了判断是否等于1
                    cur_squares[j]=min(min(pre_squares[j],pre_squares[j-1]),cur_squares[j-1])+1;
                else
                    cur_squares[j]=0;
                max_square=max(max_square,cur_squares[j]); 
                
            }
            pre_squares=cur_squares;//这个的位置很重要，别放在内循环里面了
            //cur_squares=vector&lt;int&gt;(wid,0);//没有判断matrix[i][j]=='0'的情况来更新cur_squares[j]=0;的话必须更新cur，否则残留的cur=1会影响结果
        }
        return max_square*max_square;
    }    
    /*
    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) {
        if(matrix.size()==0) return 0;
        int len=matrix.size(),wid=matrix[0].size();
        vector&lt;vector&lt;int&gt;&gt; squares(len,vector&lt;int&gt;(wid,0));
        int max_square=0;
        for(int i=0;i&lt;len;++i)
            for(int j=0;j&lt;wid;++j){
                if(i==0||j==0)
                    squares[i][j]=matrix[i][j]-'0';
                else if(matrix[i][j]=='1')
                    squares[i][j]=min(min(squares[i-1][j],squares[i][j-1]),squares[i-1][j-1])+1;
                max_square=max(max_square,squares[i][j]);       
            }
        return max_square*max_square;     
    }
    */
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>概要<br>
在给定m×n 的矩阵中，我们需要找到在矩阵中由 1 组成的最大正方形。<br>
换句话说，我们需要在矩阵中找到由 1 组成最大连通的正方形，并返回其面积。<br>
解决方法<br>
方法一：暴力法<br>
最简单的方法是找出矩阵中所有可以形成的 1 正方形。现在的问题是如何做到这一点？<br>
我们用一个变量去来记录迄今为止发现的最大正方形的边长，以及用一个变量记录当前正方形的大小，两个变量都初始化为 0；<br>
从矩阵的左上角开始搜索 1，找到 0 不需要做任何操作，只要找到 1 我们就试图找到由 1 组成的最大正方形；<br>
为此我们向右和向下移动，临时增加列索引和行索引，然后用标志标记该行列是否全都为 1；<br>
如果全都为 1，则继续检索行列，如果找到 0，便停止移动，更新最大正方形的边长。然后从最初发现 1 的元素旁边遍历矩阵，直到矩阵的所有元素都被遍历。<br>
Java</p>
</blockquote>
<pre><code>public class Solution {
    public int maximalSquare(char[][] matrix) {
        int rows = matrix.length, cols = rows &gt; 0 ? matrix[0].length : 0;
        int maxsqlen = 0;
        for (int i = 0; i &lt; rows; i++) {
            for (int j = 0; j &lt; cols; j++) {
                if (matrix[i][j] == '1') {
                    int sqlen = 1;
                    boolean flag = true;
                    while (sqlen + i &lt; rows &amp;&amp; sqlen + j &lt; cols &amp;&amp; flag) {
                        for (int k = j; k &lt;= sqlen + j; k++) {
                            if (matrix[i + sqlen][k] == '0') {
                                flag = false;
                                break;
                            }
                        }
                        for (int k = i; k &lt;= sqlen + i; k++) {
                            if (matrix[k][j + sqlen] == '0') {
                                flag = false;
                                break;
                            }
                        }
                        if (flag)
                            sqlen++;
                    }
                    if (maxsqlen &lt; sqlen) {
                        maxsqlen = sqlen;
                    }
                }
            }
        }
        return maxsqlen * maxsqlen;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O((mn) ^2)，最坏情况下，我们需要遍历整个矩阵寻找每个 1。<br>
空间复杂度：O(1)，没有使用额外的空间。</p>
</blockquote>
<blockquote>
<p>方法二：动态规划<br>
我们用一个例子来解释这个方法：<br>
0 1 1 1 0<br>
1 1 1 1 1<br>
0 1 1 1 1<br>
0 1 1 1 1<br>
0 0 1 1 1<br>
我们用 0 初始化另一个矩阵 dp，维数和原始矩阵维数相同；<br>
dp(i,j) 表示的是由 1 组成的最大正方形的边长；<br>
从 (0,0) 开始，对原始矩阵中的每一个 1，我们将当前元素的值更新为<br>
dp(i, j)=min(dp(i−1, j), dp(i−1, j−1), dp(i, j−1))+1<br>
我们还用一个变量记录当前出现的最大边长，这样遍历一次，找到最大的正方形边长maxsqlen，那么结果就是 maxsqlen^2 。</p>
</blockquote>
<pre><code>public class Solution {
    public int maximalSquare(char[][] matrix) {
        int rows = matrix.length, cols = rows &gt; 0 ? matrix[0].length : 0;
        int[][] dp = new int[rows + 1][cols + 1];
        int maxsqlen = 0;
        for (int i = 1; i &lt;= rows; i++) {
            for (int j = 1; j &lt;= cols; j++) {
                if (matrix[i-1][j-1] == '1'){
                    dp[i][j] = Math.min(Math.min(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1]) + 1;
                    maxsqlen = Math.max(maxsqlen, dp[i][j]);
                }
            }
        }
        return maxsqlen * maxsqlen;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(mn)。<br>
空间复杂度：O(mn)，用了一个大小相同的矩阵 dp。</p>
</blockquote>
<blockquote>
<p>方法三：动态规划优化<br>
在前面的动态规划解法中，计算第i行（row）的 dp 方法中，我们只使用了上一个元素和第 (i-1) 行，因此我们不需要二维 dp 矩阵，因为一维 dp 足以满足此要求。<br>
我们扫描一行原始矩阵元素时，我们根据公式：dp[j]=min(dp[j-1],dp[j],prev) 更新数组 dp，其中 prev 指的是 dp[j-1]，对于每一行，我们重复相同过程并在 dp 矩阵中更新元素。</p>
</blockquote>
<pre><code>public class Solution {
    public int maximalSquare(char[][] matrix) {
        int rows = matrix.length, cols = rows &gt; 0 ? matrix[0].length : 0;
        int[] dp = new int[cols + 1];
        int maxsqlen = 0, prev = 0;
        for (int i = 1; i &lt;= rows; i++) {
            for (int j = 1; j &lt;= cols; j++) {
                int temp = dp[j];
                if (matrix[i - 1][j - 1] == '1') {
                    dp[j] = Math.min(Math.min(dp[j - 1], prev), dp[j]) + 1;
                    maxsqlen = Math.max(maxsqlen, dp[j]);
                } else {
                    dp[j] = 0;
                }
                prev = temp;
            }
        }
        return maxsqlen * maxsqlen;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(mn)。<br>
空间复杂度：O(n)，使用了一个一维数组 dp。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 968. 监控二叉树 [困难][未做出]]]></title>
        <id>https://lixin-ee.github.io//post/shu-968-jian-kong-er-cha-shu-kun-nan-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/shu-968-jian-kong-er-cha-shu-kun-nan-wei-zuo-chu">
        </link>
        <updated>2020-01-26T01:43:07.000Z</updated>
        <content type="html"><![CDATA[<p>示例 1：<br>
<img src="https://lixin-ee.github.io//post-images/1580003119532.png" alt=""><br>
示例 2：<br>
<img src="https://lixin-ee.github.io//post-images/1580003651384.png" alt=""></p>
<blockquote>
<p>给定一个二叉树，我们在树的节点上安装摄像头。<br>
节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。<br>
计算监控树的所有节点所需的最小摄像头数量。<br>
示例 1：<br>
输入：[0,0,null,0,0]<br>
输出：1<br>
解释：如图所示，一台摄像头足以监控所有节点。<br>
示例 2：<br>
输入：[0,0,null,0,null,0,null,null,0]<br>
输出：2<br>
解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。<br>
提示：<br>
给定树的节点数的范围是 [1, 1000]。<br>
每个节点的值都是 0。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/binary-tree-cameras<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>一开始用的是迭代的奇偶层次法，提交了才发现挺笨的，因为如果是6层，每层1个节点的话，其实只需要在2和5层装就行了，不需要136或者245<br>
思考了一下 还是得靠动态规划</p>
<p>一开始以为是类似入室盗窃那道题的两种状态，看了题解发现三种状态更加好，然后注意这种父节点的值依赖于子节点的题是无法使用迭代法的</p>
<p>实现过程中发现头节点需要单独处理，因为它没有父节点可以监控他，看了题解 发现可以装载一个虚拟头节点（注意 我们所需要的只是监控的数量而不是节点，所以ehead的监控可以算到root的头上，比如root是0，需要ehead是1，此时虽然root是被监控，但是实际上ehead的监控算到cur头上，所以最终返回的数量是一致的）</p>
<p>我的实现用了三种状态 1-监控态 0-未被监控态 -1-被监控态 其中NULL节点为-1态，意味着不需要处理 叶子节点为0，因为我们总是希望叶子节点的父节点来监控以取得最大收益（父节点至少可以监控两个，叶子节点只能监控一个），当然这也是导致root需要ehead的原因 否则root自身就是叶节点返回0的话就木大了</p>
<p>递归逻辑中，必须优先处理的就是子节点为0的情况，此时必须监控。然后就是如果叶节点都不为0而且有个监控的话，当前节点就可以返回-1了，其他情况统统返回0（比如叶子节点都是被监控的，此时自己加监控收益低，还是给父节点去考虑），注意此处不能判断叶子节点都为-1，否则会因为情况判断不完全而产生不返回的错误</p>
<p>然后在实现的时候遇到一个啼笑皆非的问题，int right=preorder(cur-&gt;right,res);这行代码中cur-&gt;right写成了cur-right，本来应该报错符号的，但是恰好定义了int的right，导致识别为减号，报错内存溢出。。。</p>
<pre><code>class Solution {
public:
    int minCameraCover(TreeNode* root) {
        if(root==NULL) return 0;
        int res=0;
        TreeNode* ehead=new TreeNode(0);
        ehead-&gt;left=root;
        preorder(ehead,res);
        return res;
    }
    
    int preorder(TreeNode *cur,int &amp;res){
        if(cur==NULL)
            return -1;
        if(cur-&gt;left==NULL&amp;&amp;cur-&gt;right==NULL){
            return 0;
        }
        int left=preorder(cur-&gt;left,res);
        int right=preorder(cur-&gt;right,res);
        if(left==0||right==0){
            ++res;
            return 1;
        }
        if(left==1||right==1)
            return -1;
        //if(left==-1&amp;&amp;right==-1)
            return 0;    
    }
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>当遍历到一个节点时，我们可以定义三种状态：<br>
0 ： 初始状态，如果节点为null可以返回，也就是不影响其他节点，当两个节点都是0时，我们直接设置当前节点为未监控状态<br>
1： 未监控状态，如果子节点含有该状态，则此节点必须添加摄像头，同时返回当前状态为监控态<br>
2： 监控态，表明此节点已经被监控，当子节点为此状态时，父节点不需要添加摄像头，可以返回初始态</p>
</blockquote>
<pre><code>private int dfs(TreeNode node){
        if (node == null) return 0;

        int l = dfs(node.left);
        int r = dfs(node.right);

        if (l + r == 0)  
            return 1;
        else if (l == 1 || r == 1) {
            cameras ++; return 2;
        } else  
            return 0;
    }
</code></pre>
<blockquote>
<p>当调用时，有一个小技巧，我们需要为传入的根节点添加一个虚拟的头，因为向上遍历时，根节点的监控状态我们无法保证，所以添加一个虚拟头可以简化编程。</p>
</blockquote>
<pre><code>public int minCameraCover(TreeNode root) {
        TreeNode dummyHead = new TreeNode(0);
        dummyHead.left = root;
        dfs(dummyHead);
        return cameras;
    }
</code></pre>
<blockquote>
<p>时间复杂度O(N)<br>
空间复杂度如果不算递归的隐式调用栈，为O(1),否则为O(h),h为树的高度。</p>
</blockquote>
<p>网友题解里面的判断条件用了加法，虽然不太直观，但是非常巧妙</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 628. 三个数的最大乘积[简单]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-628-san-ge-shu-de-zui-da-cheng-ji-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-628-san-ge-shu-de-zui-da-cheng-ji-jian-dan">
        </link>
        <updated>2020-01-25T03:02:35.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。<br>
示例 1:<br>
输入: [1,2,3]<br>
输出: 6<br>
示例 2:<br>
输入: [1,2,3,4]<br>
输出: 24<br>
注意:<br>
给定的整型数组长度范围是[3,104]，数组中所有的元素范围是[-1000, 1000]。<br>
输入的数组中任意三个数的乘积不会超出32位有符号整数的范围。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/maximum-product-of-three-numbers<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>比较棘手的就是负数了，如果负数纳入考虑的话，就必须是两个负数。。。<br>
比较智障的方法就是保存五个数，用贪心法来更新hhh<br>
突然发现不太对劲，因为每次更新都要去除一个最小值，那么就得不断排序更新</p>
<p>我一开始还是实现比较笨的方法<br>
另外一个问题就是如何确定有没有被初始化，如果是数组全是负数的话结果还是负数，但是我一开始返回的结果是0，因为值都初始化为0了<br>
于是打算改成用set来管理 让set自动排序<br>
算了直接用sort吧</p>
<p>看了题解后发现第一个方法还是最优解，只是赋值不能是0，必须是最大最小值，然后判断起来比较麻烦 而且不能像我那样区分开负数和正数，比如1，2，3中，1应该也付给min_1</p>
<pre><code>class Solution {
public:
    int maximumProduct(vector&lt;int&gt;&amp; nums){
        int max_1=INT_MIN,max_2=INT_MIN,max_3=INT_MIN;
        int min_1=INT_MAX,min_2=INT_MAX;
        for(auto i:nums){
            if(i&gt;max_1)
                swap(max_3,max_2),swap(max_2,max_1),max_1=i;
            else if(i&gt;max_2)
                swap(max_3,max_2),max_2=i;
            else if(i&gt;max_3)
                max_3=i;
            if(i&lt;min_1)
                swap(min_2,min_1),min_1=i;
            else if(i&lt;min_2)
                min_2=i;
        }
        return max_1*max_2*max_3&gt;max_1*min_1*min_2?max_1*max_2*max_3:max_1*min_1*min_2;
    }
		/*//排序法
    int maximumProduct(vector&lt;int&gt;&amp; nums) {
        int len=nums.size();
        sort(nums.begin(),nums.end());
        return nums[len-1]*nums[len-2]*nums[len-3]&gt;nums[len-1]*nums[0]*nums[1]?nums[len-1]*nums[len-2]*nums[len-3]:nums[len-1]*nums[0]*nums[1];

    }
    */
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>方法一：排序<br>
我们将数组进行升序排序，如果数组中所有的元素都是非负数，那么答案即为最后三个元素的乘积。<br>
如果数组中出现了负数，那么我们还需要考虑乘积中包含负数的情况，显然选择最小的两个负数和最大的一个正数是最优的，即为前两个元素与最后一个元素的乘积。<br>
上述两个结果中的较大值就是答案。注意我们可以不用判断数组中到底有没有正数，0 或者负数，因为上述两个结果实际上已经包含了所有情况，最大值一定在其中。</p>
</blockquote>
<pre><code>Java
public class Solution {
    public int maximumProduct(int[] nums) {
        Arrays.sort(nums);
        return Math.max(nums[0] * nums[1] * nums[nums.length - 1], nums[nums.length - 1] * nums[nums.length - 2] * nums[nums.length - 3]);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(NlogN)，其中 N 是数组的长度。<br>
空间复杂度：O(logN)，为排序使用的空间。</p>
</blockquote>
<blockquote>
<p>方法二：线性扫描<br>
在方法一中，我们实际上只要求出数组中最大的三个数以及最小的两个数，因此我们可以不用排序，用线性扫描直接得出这五个数。</p>
</blockquote>
<pre><code>Java
public class Solution {
    public int maximumProduct(int[] nums) {
        int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;
        int max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE, max3 = Integer.MIN_VALUE;
        for (int n: nums) {
            if (n &lt;= min1) {
                min2 = min1;
                min1 = n;
            } else if (n &lt;= min2) {     // n lies between min1 and min2
                min2 = n;
            }
            if (n &gt;= max1) {            // n is greater than max1, max2 and max3
                max3 = max2;
                max2 = max1;
                max1 = n;
            } else if (n &gt;= max2) {     // n lies betweeen max1 and max2
                max3 = max2;
                max2 = n;
            } else if (n &gt;= max3) {     // n lies betwen max2 and max3
                max3 = n;
            }
        }
        return Math.max(min1 * min2 * max1, max1 * max2 * max3);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(N)。<br>
空间复杂度：O(1)。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 543. 二叉树的直径[简单]]]></title>
        <id>https://lixin-ee.github.io//post/shu-543-er-cha-shu-de-zhi-jing-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/shu-543-er-cha-shu-de-zhi-jing-jian-dan">
        </link>
        <updated>2020-01-24T02:37:32.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。<br>
示例 :<br>
给定二叉树<br>
1<br>
/ <br>
2   3<br>
/ \<br>
4   5<br>
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。<br>
注意：两结点之间的路径长度是以它们之间边的数目表示。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/diameter-of-binary-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这个问题可以转化为找某个节点的左右子树的深度之和（注意不一定就是根节点，有可能没有左右子树之一）<br>
递归倒是很简单，直接从叶子节点的1开始算起，每个非叶节点就计算左子树和右子树之和，再取两者的较大者+1返回<br>
迭代比较难，我想到的是先存入父节点、右子树和左子树，但是不知道怎么把层数回传给父节点<br>
后来想到用map来存,还是没法从叶节点开始回溯啊。。。</p>
<pre><code>class Solution {
public:        
    // 递归版
    int diameterOfBinaryTree(TreeNode* root) {
        if(root==NULL) return 0;
        int max_res=0;
        tree_deep(root,max_res);
        return max_res;
    }
    
    int tree_deep(TreeNode *cur,int &amp;max_res){
        int deep=0;
        if(cur-&gt;left==NULL&amp;&amp;cur-&gt;right==NULL)
            return 1;
        int left_deep,right_deep;
        if(cur-&gt;left)
            left_deep=tree_deep(cur-&gt;left,max_res);
        else
            left_deep=0;
        if(cur-&gt;right)
            right_deep=tree_deep(cur-&gt;right,max_res);
        else
            right_deep=0;
        max_res=max_res&gt;left_deep+right_deep?max_res:left_deep+right_deep;
        return left_deep&gt;right_deep?left_deep+1:right_deep+1;
    }
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>方法 1：深度优先搜索<br>
想法<br>
任意一条路径可以被写成两个 箭头（不同方向），每个箭头代表一条从某些点向下遍历到孩子节点的路径。<br>
假设我们知道对于每个节点最长箭头距离分别为 L, R，那么最优路径经过 L + R + 1 个节点。<br>
算法<br>
按照常用方法计算一个节点的深度：max(depth of node.left, depth of node.right) + 1。在计算的同时，经过这个节点的路径长度为 1 + (depth of node.left) + (depth of node.right) 。搜索每个节点并记录这些路径经过的点数最大值，期望长度是结果 - 1。</p>
</blockquote>
<pre><code>java
class Solution {
    int ans;
    public int diameterOfBinaryTree(TreeNode root) {
        ans = 1;
        depth(root);
        return ans - 1;
    }
    public int depth(TreeNode node) {
        if (node == null) return 0;
        int L = depth(node.left);
        int R = depth(node.right);
        ans = Math.max(ans, L+R+1);
        return Math.max(L, R) + 1;
    }
}
</code></pre>
<p>复杂度分析<br>
时间复杂度：O(N)，每个节点只访问一次。<br>
空间复杂度：O(N)，深度优先搜索的栈开销。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[队列 232. 用栈实现队列[简单]]]></title>
        <id>https://lixin-ee.github.io//post/dui-lie-232-yong-zhan-shi-xian-dui-lie-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/dui-lie-232-yong-zhan-shi-xian-dui-lie-jian-dan">
        </link>
        <updated>2020-01-23T01:25:01.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>使用栈实现队列的下列操作：<br>
push(x) -- 将一个元素放入队列的尾部。<br>
pop() -- 从队列首部移除元素。<br>
peek() -- 返回队列首部的元素。<br>
empty() -- 返回队列是否为空。<br>
示例:<br>
MyQueue queue = new MyQueue();<br>
queue.push(1);<br>
queue.push(2);<br>
queue.peek();  // 返回 1<br>
queue.pop();   // 返回 1<br>
queue.empty(); // 返回 false<br>
说明:<br>
你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。<br>
你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。<br>
假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/implement-queue-using-stacks<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>和队列模拟栈一样，我利用两个stack，因为每次插入需要在后面插入，所以需要一个temp来存储cur的已有值，插入后再将temp值返回到cur中</p>
<p>题解中显示无法用一个栈来实现，但是官方题解有一个比较巧妙的双栈，一个用来push，一个用来pop，摊还分析复杂度是常数分析<br>
这里可以单独详细看看摊还分析</p>
<pre><code>class MyQueue {
public:
    /** Initialize your data structure here. */
    MyQueue() {
        
    }
    stack&lt;int&gt; cur,temp;
    /** Push element x to the back of queue. */
    void push(int x) {
        temp.push(x);
   /*
        if(cur.size())
            while(cur.size())
                temp.push(cur.top()),cur.pop();
        cur.push(x);
        while(temp.size())
            cur.push(temp.top()),temp.pop();
  */
    }
    
    /** Removes the element from in front of queue and returns that element. */
    int pop() {
        if(cur.empty())
          while(temp.size())
              cur.push(temp.top()),temp.pop();
        int temp_i=cur.top();
        cur.pop();
        return temp_i;
        /*
        int temp_i=cur.top();
        cur.pop();
        return temp_i;
        */
    }
    
    /** Get the front element. */
    int peek() {
        if(cur.empty())
          while(temp.size())
              cur.push(temp.top()),temp.pop();
        return cur.top();
    }
    
    /** Returns whether the queue is empty. */
    bool empty() {
        return !(cur.size()||temp.size());
    }
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>题解<br>
队列是一种 先进先出（first in - first out， FIFO）的数据结构，队列中的元素都从后端（rear）入队（push），从前端（front）出队（pop）。<br>
实现队列最直观的方法是用链表，但在这篇文章里我会介绍另一个方法 - 使用栈。<br>
栈是一种 后进先出（last in - first out， LIFO）的数据结构，栈中元素从栈顶（top）压入（push)，也从栈顶弹出（pop）。<br>
为了满足队列的 FIFO 的特性，我们需要用到两个栈，用它们其中一个来反转元素的入队顺序，用另一个来存储元素的最终顺序。</p>
</blockquote>
<blockquote>
<p>方法一（使用两个栈 入队 - O(n)， 出队 - O(1)）<br>
算法<br>
入队（push）<br>
一个队列是 FIFO 的，但一个栈是 LIFO 的。这就意味着最新压入的元素必须得放在栈底。为了实现这个目的，我们首先需要把 s1 中所有的元素移到 s2 中，接着把新元素压入 s2。最后把 s2 中所有的元素弹出，再把弹出的元素压入 s1。</p>
</blockquote>
<pre><code>private int front;

public void push(int x) {
    if (s1.empty())
        front = x;
    while (!s1.isEmpty())
        s2.push(s1.pop());
    s2.push(x);
    while (!s2.isEmpty())
        s1.push(s2.pop());
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)<br>
对于除了新元素之外的所有元素，它们都会被压入两次，弹出两次。新元素只被压入一次，弹出一次。这个过程产生了 4n+2 次操作，其中 n 是队列的大小。由于 压入 操作和 弹出 操作的时间复杂度为O(1)， 所以时间复杂度为O(n)。<br>
空间复杂度：O(n)<br>
需要额外的内存来存储队列中的元素。</p>
</blockquote>
<blockquote>
<p>出队（pop）<br>
直接从 s1 弹出就可以了，因为 s1 的栈顶元素就是队列的队首元素。同时我们把弹出之后 s1 的栈顶元素赋值给代表队首元素的 front 变量。</p>
</blockquote>
<pre><code>// Removes the element from the front of queue.
public void pop() {
    s1.pop();
    if (!s1.empty())
        front = s1.peek();
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(1)<br>
空间复杂度：O(1)<br>
判断空（empty）<br>
s1 存储了队列所有的元素，所以只需要检查 s1 的是否为空就可以了。</p>
</blockquote>
<pre><code>Java
// Return whether the queue is empty.
public boolean empty() {
    return s1.isEmpty();
}
</code></pre>
<blockquote>
<p>时间复杂度：O(1)<br>
空间复杂度：O(1)<br>
取队首元素（peek）<br>
在我们的算法中，用了 front 变量来存储队首元素，在每次 入队 操作或者 出队 操作之后这个变量都会随之更新。</p>
</blockquote>
<pre><code>Java
// Get the front element.
public int peek() {
  return front;
}
</code></pre>
<blockquote>
<p>时间复杂度：O(1)<br>
队首元素（front）已经被提前计算出来了，同时也只有 peek 操作可以得到它的值。<br>
空间复杂度：O(1)</p>
</blockquote>
<blockquote>
<p>方法二（使用两个栈 入队 - O(1)，出队 - 摊还复杂度 O(1)）<br>
算法<br>
入队（push）<br>
新元素总是压入 s1 的栈顶，同时我们会把 s1 中压入的第一个元素赋值给作为队首元素的 front 变量。</p>
</blockquote>
<pre><code>private Stack&lt;Integer&gt; s1 = new Stack&lt;&gt;();
private Stack&lt;Integer&gt; s2 = new Stack&lt;&gt;();

// Push element x to the back of queue.
public void push(int x) {
    if (s1.empty())
        front = x;
    s1.push(x);
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(1)<br>
向栈压入元素的时间复杂度为O(1)<br>
空间复杂度：O(n)<br>
需要额外的内存来存储队列元素</p>
</blockquote>
<blockquote>
<p>出队（pop）<br>
根据栈 LIFO 的特性，s1 中第一个压入的元素在栈底。为了弹出 s1 的栈底元素，我们得把 s1 中所有的元素全部弹出，再把它们压入到另一个栈 s2 中，这个操作会让元素的入栈顺序反转过来。通过这样的方式，s1 中栈底元素就变成了 s2 的栈顶元素，这样就可以直接从 s2 将它弹出了。一旦 s2 变空了，我们只需把 s1 中的元素再一次转移到 s2 就可以了。</p>
</blockquote>
<pre><code>// Removes the element from in front of queue.
public void pop() {
    if (s2.isEmpty()) {
        while (!s1.isEmpty())
            s2.push(s1.pop());
    }
    s2.pop();    
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度： 摊还复杂度 O(1)，最坏情况下的时间复杂度 O(n)<br>
在最坏情况下，s2 为空，算法需要从 s1 中弹出 n 个元素，然后再把这 n 个元素压入 s2，在这里n代表队列的大小。这个过程产生了 2n 步操作，时间复杂度为 O(n)。但当 s2 非空时，算法就只有 O(1) 的时间复杂度。所以为什么叫做摊还复杂度 O(1) 呢？ 读了下一章你就知道了。<br>
空间复杂度 ：O(1)</p>
</blockquote>
<blockquote>
<p>摊还分析<br>
摊还分析给出了所有操作的平均性能。摊还分析的核心在于，最坏情况下的操作一旦发生了一次，那么在未来很长一段时间都不会再次发生，这样就会均摊每次操作的代价。<br>
来看下面这个例子，从一个空队列开始，依次执行下面这些操作：<br>
push 1 ,push 2 ,…,push n ,pop 1 ,pop 2	 …,pop n<br>
单次 出队 操作最坏情况下的时间复杂度为 O(n)。考虑到我们要做 n 次出队操作，如果我们用最坏情况下的时间复杂度来计算的话，那么所有操作的时间复杂度为 O(n^2)。<br>
然而，在一系列的操作中，最坏情况不可能每次都发生，可能一些操作代价很小，另一些代价很高。因此，如果用传统的最坏情况分析，那么给出的时间复杂度是远远大于实际的复杂度的。例如，在一个动态数组里面只有一些插入操作需要花费线性的时间，而其余的一些插入操作只需花费常量的时间。<br>
在上面的例子中，出队 操作最多可以执行的次数跟它之前执行过 入队 操作的次数有关。虽然一次 出队 操作代价可能很大，但是每 n 次 入队 才能产生这么一次代价为 n 的 出队 操作。因此所有操作的总时间复杂度为：n(所有的入队操作产生） + 2 * n(第一次出队操作产生） + n - 1(剩下的出队操作产生）， 所以实际时间复杂度为 O(2*n)。于是我们可以得到每次操作的平均时间复杂度为 O(2n/2n)=O(1)。</p>
</blockquote>
<blockquote>
<p>判断空（empty）<br>
s1 和 s2 都存有队列的元素，所以只需要检查 s1 和 s2 是否都为空就可以了。</p>
</blockquote>
<pre><code>Java
// Return whether the queue is empty.
public boolean empty() {
    return s1.isEmpty() &amp;&amp; s2.isEmpty();
}
</code></pre>
<blockquote>
<p>时间复杂度：O(1)<br>
空间复杂度：O(1)</p>
</blockquote>
<blockquote>
<p>取队首元素（peek)<br>
我们定义了 front 变量来保存队首元素，每次 入队 操作我们都会随之更新这个变量。当 s2 为空，front 变量就是对首元素，当 s2 非空，s2 的栈顶元素就是队首元素。</p>
</blockquote>
<pre><code>Java
// Get the front element.
public int peek() {
    if (!s2.isEmpty()) {
        return s2.peek();
    }
    return front;
}
</code></pre>
<blockquote>
<p>时间复杂度：O(1)<br>
队首元素要么是之前就被计算出来的，要么就是 s2 栈顶元素。因此时间复杂度为 O(1)。<br>
空间复杂度：O(1)</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[栈 225. 用队列实现栈[简单]]]></title>
        <id>https://lixin-ee.github.io//post/zhan-225-yong-dui-lie-shi-xian-zhan-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/zhan-225-yong-dui-lie-shi-xian-zhan-jian-dan">
        </link>
        <updated>2020-01-21T12:08:13.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>使用队列实现栈的下列操作：<br>
push(x) -- 元素 x 入栈<br>
pop() -- 移除栈顶元素<br>
top() -- 获取栈顶元素<br>
empty() -- 返回栈是否为空<br>
注意:<br>
你只能使用队列的基本操作-- 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。<br>
你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。<br>
你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/implement-stack-using-queues<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>我一开始只想到比较笨的方法，就是用两个队列来实现，每次push只放入cur中，并且保持cur只有一个元素，亦即栈顶元素，多余的元素push进另一个队列storage中<br>
然后就是pop的问题，如果pop使得cur为空，就需要把storage的元素push进cur里面，使得storage只剩一个栈顶元素，此时再将两者交换<br>
然后题目给的模板好坑，和c++的类似乎不相同，我在MyStack()里面定义队列是会报错的</p>
<p>题解中给的一个队列的题解不错，还是c++实现的</p>
<p>为了防止两者强行拷贝赋值，我使用了指针，然后在这一题我想探讨一下swap、move和移动赋值的问题<br>
很可惜leetcode似乎对内存的判断并不准确，又或者是queue自动触发了移动赋值，在这里的测试的内存一直不变</p>
<pre><code>class MyStack {
public:
    /** Initialize your data structure here. */

    //MyStack() {
        queue&lt;int&gt; cur,storage;

    //}

    /** Push element x onto stack. */
    void push(int x) {
        if((cur).size()){
            (storage).push((cur).front());
            (cur).pop();
        }
         (cur).push(x);     
    }
    
    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        int temp=(cur).front();
        (cur).pop();
        while((storage).size()&gt;1){
            (cur).push((storage).front());
            (storage).pop();
        }
        /*
        auto tempqueue=cur;
        cur=storage;
        storage=tempqueue;
        */
        swap(cur,storage);
        return temp;
    }
    
    /** Get the top element. */
    int top() {
        return (cur).front();
    }
    
    /** Returns whether the stack is empty. */
    bool empty() {
        if((cur).size())
            return false;
        else
            return true;
    }
};
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>因为原始的queue是先进先出，所以要通过queue实现栈，在每一次push进新元素x时，需将前面的元素移到x的后面，可以巧妙地使用q.push(q.front()); q.pop(); 代码实现如下：</p>
</blockquote>
<pre><code>class MyStack {
    queue&lt;int&gt; nums;
public:
    /** Initialize your data structure here. */
    MyStack() {
        //nothing to do
    }
    
    /** Push element x onto stack. */
    void push(int x) {
        nums.push(x);
        //将前面的size-1个元素放到后面去
        for(int i = 0; i &lt; nums.size() - 1; i++){
            nums.push(nums.front());
            nums.pop();
        }
    }
    
    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        int num = nums.front();
        nums.pop();
        return num;
    }
    
    /** Get the top element. */
    int top() {
        return nums.front();
    }
    
    /** Returns whether the stack is empty. */
    bool empty() {
        return nums.empty();
    }
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>绪论<br>
这篇文章是为初级读者准备的，文章中介绍栈和队列这两种数据结构。<br>
方法一 （两个队列，压入 -O(1)， 弹出 -O(n)）<br>
思路<br>
栈是一种 后进先出（last in - first out， LIFO）的数据结构，栈内元素从顶端压入（push），从顶端弹出（pop）。一般我们用数组或者链表来实现栈，但是这篇文章会来介绍如何用队列来实现栈。队列是一种与栈相反的 先进先出（first in - first out， FIFO）的数据结构，队列中元素只能从 后端（rear）入队（push），然后从 前端（front）端出队（pop）。为了满足栈的特性，我们需要维护两个队列 q1 和 q2。同时，我们用一个额外的变量来保存栈顶元素。<br>
算法<br>
压入（push）<br>
新元素永远从 q1 的后端入队，同时 q1 的后端也是栈的 栈顶（top）元素。</p>
</blockquote>
<pre><code>private Queue&lt;Integer&gt; q1 = new LinkedList&lt;&gt;();
private Queue&lt;Integer&gt; q2 = new LinkedList&lt;&gt;();
private int top;

// Push element x onto stack.
public void push(int x) {
    q1.add(x);
    top = x;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(1)<br>
队列是通过链表来实现的，入队（add）操作的时间复杂度为 O(1)。<br>
空间复杂度：O(1)</p>
</blockquote>
<blockquote>
<p>弹出（pop）<br>
我们需要把栈顶元素弹出，就是 q1 中最后入队的元素。<br>
考虑到队列是一种 FIFO 的数据结构，最后入队的元素应该在最后被出队。因此我们需要维护另外一个队列 q2，这个队列用作临时存储 q1 中出队的元素。q2 中最后入队的元素将作为新的栈顶元素。接着将 q1 中最后剩下的元素出队。我们通过把 q1 和 q2 互相交换的方式来避免把 q2 中的元素往 q1 中拷贝。</p>
</blockquote>
<pre><code>// Removes the element on top of the stack.
public void pop() {
    while (q1.size() &gt; 1) {
        top = q1.remove();
        q2.add(top);
    }
    q1.remove();
    Queue&lt;Integer&gt; temp = q1;
    q1 = q2;
    q2 = temp;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)<br>
算法让 q1 中的 n 个元素出队，让 nn−1 个元素从 q2 入队，在这里 n 是栈的大小。这个过程总共产生了2n−1 次操作，时间复杂度为 O(n)。</p>
</blockquote>
<blockquote>
<p>方法二 （两个队列， 压入 - O(n)， 弹出 - O(1)）<br>
算法<br>
压入（push)<br>
接下来介绍的算法让每一个新元素从 q2 入队，同时把这个元素作为栈顶元素保存。当 q1 非空（也就是栈非空），我们让 q1 中所有的元素全部出队，再将出队的元素从 q2 入队。通过这样的方式，新元素（栈中的栈顶元素）将会在 q2 的前端。我们通过将 q1， q2 互相交换的方式来避免把 q2 中的元素往 q1 中拷贝。</p>
</blockquote>
<pre><code>public void push(int x) {
    q2.add(x);
    top = x;
    while (!q1.isEmpty()) {                
        q2.add(q1.remove());
    }
    Queue&lt;Integer&gt; temp = q1;
    q1 = q2;
    q2 = temp;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)<br>
算法会让 q1 出队 n 个元素，同时入队 n+1 个元素到 q2。这个过程会产生2n+1 步操作，同时链表中 插入 操作和 移除 操作的时间复杂度为 O(1)，因此时间复杂度为 O(n)。<br>
空间复杂度：O(1)</p>
</blockquote>
<blockquote>
<p>弹出（pop）<br>
直接让 q1 中元素出队，同时将出队后的 q1 中的队首元素作为栈顶元素保存。</p>
</blockquote>
<pre><code>// Removes the element on top of the stack.
public void pop() {
    q1.remove();
    if (!q1.isEmpty()) {
    	top = q1.peek();
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(1)<br>
空间复杂度：O(1)</p>
</blockquote>
<blockquote>
<p>判断空（empty）和 取栈顶元素（top）是同样的实现方式。<br>
判断空（empty）<br>
q1 里包含了栈中所有的元素，所以只需要检查 q1 是否为空就可以了。</p>
</blockquote>
<pre><code>Java
// Removes the element on top of the stack.
public void pop() {
    q1.remove();
    if (!q1.isEmpty()) {
    	top = q1.peek();
    }
}
</code></pre>
<blockquote>
<p>时间复杂度：O(1)<br>
空间复杂度：O(1)</p>
</blockquote>
<blockquote>
<p>取栈顶元素（top）<br>
栈顶元素被保存在 top 变量里，每次我们 压入 或者 弹出 一个元素的时候都会随之更新这个变量。</p>
</blockquote>
<pre><code>Java
// Get the top element.
public int top() {
    return top;
}
</code></pre>
<blockquote>
<p>时间复杂度：O(1)<br>
栈顶元素每次都是被提前计算出来的，同时只有 top 操作可以得到它的值。<br>
空间复杂度：O(1)</p>
</blockquote>
<blockquote>
<p>方法三 （一个队列， 压入-O(n)， 弹出-O(1)）<br>
上面介绍的两个方法都有一个缺点，它们都用到了两个队列。下面介绍的方法只需要使用一个队列。<br>
算法<br>
压入（push）<br>
当我们将一个元素从队列入队的时候，根据队列的性质这个元素会存在队列的后端。<br>
但当我们实现一个栈的时候，最后入队的元素应该在前端，而不是在后端。为了实现这个目的，每当入队一个新元素的时候，我们可以把队列的顺序反转过来。</p>
</blockquote>
<pre><code>private LinkedList&lt;Integer&gt; q1 = new LinkedList&lt;&gt;();

// Push element x onto stack.
public void push(int x) {
    q1.add(x);
    int sz = q1.size();
    while (sz &gt; 1) {
        q1.add(q1.remove());
        sz--;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)<br>
这个算法需要从 q1 中出队 n 个元素，同时还需要入队 n 个元素到 q1，其中 n 是栈的大小。这个过程总共产生了2n+1 步操作。链表中 插入 操作和 移除 操作的时间复杂度为 O(1)，因此时间复杂度为 O(n)。<br>
空间复杂度：O(1)</p>
</blockquote>
<blockquote>
<p>弹出（pop）<br>
最后一个压入的元素永远在 q1 的前端，这样的话我们就能在常数时间内让它 出队。</p>
</blockquote>
<pre><code>Java
// Removes the element on top of the stack.
public void pop() {
    q1.remove();
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(1)<br>
空间复杂度：O(1)</p>
</blockquote>
<blockquote>
<p>判断空（empty）<br>
q1 中包含了栈中所有的元素，所以只需要检查 q1 是否为空就可以了。</p>
</blockquote>
<pre><code>Java
// Return whether the stack is empty.
public boolean empty() {
    return q1.isEmpty();
}
</code></pre>
<blockquote>
<p>时间复杂度：O(1)<br>
空间复杂度：O(1)</p>
</blockquote>
<blockquote>
<p>取栈顶（top）<br>
栈顶元素永远在 q1 的前端，直接返回就可以了。<br>
时间复杂度：O(1)<br>
空间复杂度：O(1)</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 347. 前 K 个高频元素[中等][未做出][堆]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-347-qian-k-ge-gao-pin-yuan-su-zhong-deng-wei-zuo-chu-dui</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-347-qian-k-ge-gao-pin-yuan-su-zhong-deng-wei-zuo-chu-dui">
        </link>
        <updated>2020-01-21T00:49:12.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。<br>
示例 1:<br>
输入: nums = [1,1,1,2,2,3], k = 2<br>
输出: [1,2]<br>
示例 2:<br>
输入: nums = [1], k = 1<br>
输出: [1]<br>
说明：<br>
你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。<br>
你的算法的时间复杂度必须优于 O(nlogn) , n 是数组的大小。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/top-k-frequent-elements<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题是我从面经题里面选出来的，已经提前知道使用堆排序或者快速排序的了。</p>
<p>看了题解发现是hashmap+最小堆 然后注意C++的优先队列priority_queue已经默认实现了大顶堆，改为great实现小顶堆<br>
但是我想实现以下暴力法的排序是怎么做到的。。。<br>
暴力法的实现：<br>
1.主要是想验证哈希表向vector的转化，之前我已经是写错了vector的模板类型，vector&lt;pair&lt;int,int&gt;&gt; freqvec(freqmap.begin(),freqmap.end());<br>
2.快速排序中如何利用pair的second进行排序</p>
<p>然后就是小顶堆的实现，题解中将hashmap得到的pair反转再存入priority还是挺有趣的<br>
实现过程中发现了个问题 如果用小顶堆的priority queue的话最后输出的结果反而频率最高的排在后面的<br>
然后在判断长度的时候不小心把push和pop的顺序搞反了，应该先push超出长度，再pop修正长度</p>
<p>我在做题的过程中发现了一个很严重的认知错误<br>
就是堆内部并非是有序的！！！！（大顶）堆仅仅保证每个结点的值都大于或等于其左右孩子结点的值！！！不能保证最后一个节点就是最小值！！！<br>
我在复现的过程中使用了大顶堆，却错误地希望headadjust(freqheap,0,k-1);   k-1来去掉最后一个数来维持数组大小<br>
其实只能通过小顶堆来去除最小值！！！</p>
<p>最后还是没法通过，还不清楚具体原因，似乎是因为我强行在头部插入再重新构建堆，而大话数据结构中是构建堆再不断地把头节点和尾节点互换（而不是新增节点）</p>
<p>所以必须使用STL源码剖析那种从叶节点到头节点的heap调整方法。。。。</p>
<p>题解实现：</p>
<pre><code>    //priority_queue实现
     vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k){
        unordered_map&lt;int,int&gt; freqmap;
        for(auto i:nums)
            if(freqmap.count(i))
                ++freqmap[i];
            else
                freqmap[i]=1;
         priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;,greater&lt;pair&lt;int,int&gt;&gt;&gt; freqque;
         for(auto i:freqmap)
             if(freqque.size()==k){
                 freqque.push({i.second,i.first});
                 freqque.pop();     
             }else
                 freqque.push({i.second,i.first});
         vector&lt;int&gt; res;
         while(k){
             res.push_back(freqque.top().second);
             freqque.pop();
             --k;
         }
         reverse(res.begin(),res.end());
         return res;
     }   
</code></pre>
<pre><code>//暴力排序法
    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) {
        unordered_map&lt;int,int&gt; freqmap;
        for(auto i:nums)
            if(freqmap.count(i))
                ++freqmap[i];
            else
                freqmap[i]=1;
        vector&lt;pair&lt;int,int&gt;&gt; freqvec(freqmap.begin(),freqmap.end());
        quicksort(freqvec,0,freqvec.size()-1);
        vector&lt;int&gt;res;
        for(int i=0;i&lt;k;++i)
            res.push_back(freqvec[i].first);
        return res;
    }
    
    void quicksort(vector&lt;pair&lt;int,int&gt;&gt; &amp;vi,int beg,int end){
        if(beg&lt;end){
            int mid=partition(vi,beg,end);
            quicksort(vi,beg,mid-1);
            quicksort(vi,mid+1,end);
        }
    }
    
    int partition(vector&lt;pair&lt;int,int&gt;&gt; &amp;vi,int low,int high){
        int pivotkey=vi[low].second;
        while(low&lt;high){
            while(low&lt;high&amp;&amp;pivotkey&gt;=vi[high].second)
                --high;
            swap(vi[low],vi[high]);
            while(low&lt;high&amp;&amp;vi[low].second&gt;=pivotkey)
                ++low;
            swap(vi[low],vi[high]);
        }
        return low;
    }
</code></pre>
<p>下面是我打算自己实现一个大顶堆，但是失败了hhh</p>
<pre><code>//错误代码
     vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k){
        unordered_map&lt;int,int&gt; freqmap;
        for(auto i:nums)
            if(freqmap.count(i))
                ++freqmap[i];
            else
                freqmap[i]=1;
         deque&lt;pair&lt;int,int&gt;&gt; freqheap;
         for(auto i:freqmap){
             if(freqheap.size()==k){
                 if(i.second&lt;freqheap.front().first)
                     continue;
                 else
                     freqheap.front()=i;
             }else
                freqheap.push_front({i.second,i.first});
             headadjust(freqheap,0,freqheap.size());         
         }
         vector&lt;int&gt; res;
         for(int i=k-1;i&gt;=0;--i)
             res.push_back(freqheap[i].second);
         return res;
     }
    
    void headadjust(deque&lt;pair&lt;int,int&gt;&gt; &amp;freqheap,int s,int len){
        auto temp=freqheap[s];
        for(int i=2*s+1;i&lt;len;i=i*2+1){
            if(i&lt;len-1&amp;&amp;freqheap[i+1].first&lt;freqheap[i].first)
                i=i+1;
            if(temp.first&lt;freqheap[i].first)
                break;
            freqheap[s]=freqheap[i];
            s=i;
        }
        freqheap[s]=temp;
    }
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>解法一：粗暴排序法<br>
最简单粗暴的思路就是 使用排序算法对元素按照频率由高到低进行排序，然后再取前 k 个元素。<br>
以下十种排序算法</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1579569348173.png" alt=""></p>
<blockquote>
<p>可以发现，使用常规的诸如 冒泡、选择、甚至快速排序都是不满足题目要求，它们的时间复杂度都是大于或者等于 O(nlog⁡n)，而题目要求算法的时间复杂度必须优于 O(nlogn)。<br>
复杂度分析<br>
时间复杂度：O(nlogn)，n 表示数组长度。首先，遍历一遍数组统计元素的频率，这一系列操作的时间复杂度是 O(n)；接着，排序算法时间复杂度为 O(nlogn)；因此整体时间复杂度为 O(nlogn)。<br>
空间复杂度：O(n)，最极端的情况下（每个元素都不同），用于存储元素及其频率的 Map 需要存储 n 个键值对。</p>
</blockquote>
<blockquote>
<p>解法二：最小堆<br>
题目最终需要返回的是前 k个频率最大的元素，可以想到借助堆这种数据结构，对于 k 频率之后的元素不用再去处理，进一步优化时间复杂度。<br>
具体操作为：<br>
借助 哈希表 来建立数字和其出现次数的映射，遍历一遍数组统计元素的频率<br>
维护一个元素数目为 k 的最小堆<br>
每次都将新的元素与堆顶元素（堆中频率最小的元素）进行比较<br>
如果新的元素的频率比堆顶端的元素大，则弹出堆顶端的元素，将新的元素添加进堆中<br>
最终，堆中的 k 个元素即为前 k 个高频元素</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1579569394711.png" alt=""></p>
<pre><code>class Solution {
    public List&lt;Integer&gt; topKFrequent(int[] nums, int k) {
        // 使用字典，统计每个元素出现的次数，元素为键，元素出现的次数为值
        HashMap&lt;Integer,Integer&gt; map = new HashMap();
        for(int num : nums){
            if (map.containsKey(num)) {
               map.put(num, map.get(num) + 1);
             } else {
                map.put(num, 1);
             }
        }
        // 遍历map，用最小堆保存频率最大的k个元素
        PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(new Comparator&lt;Integer&gt;() {
            @Override
            public int compare(Integer a, Integer b) {
                return map.get(a) - map.get(b);
            }
        });
        for (Integer key : map.keySet()) {
            if (pq.size() &lt; k) {
                pq.add(key);
            } else if (map.get(key) &gt; map.get(pq.peek())) {
                pq.remove();
                pq.add(key);
            }
        }
        // 取出最小堆中的元素
        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
        while (!pq.isEmpty()) {
            res.add(pq.remove());
        }
        return res;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(nlogk)，n 表示数组的长度。首先，遍历一遍数组统计元素的频率，这一系列操作的时间复杂度是 O(n)；接着，遍历用于存储元素频率的 map，如果元素的频率大于最小堆中顶部的元素，则将顶部的元素删除并将该元素加入堆中，这里维护堆的数目是 k，所以这一系列操作的时间复杂度是O(nlogk) 的；因此，总的时间复杂度是 O(nlog⁡k)。<br>
空间复杂度：O(n)，最坏情况下（每个元素都不同），map 需要存储 n 个键值对，优先队列需要存储 k 个元素，因此，空间复杂度是 O(n)。</p>
</blockquote>
<blockquote>
<p>解法三：桶排序法<br>
首先依旧使用哈希表统计频率，统计完成后，创建一个数组，将频率作为数组下标，对于出现频率不同的数字集合，存入对应的数组下标即可。</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1579569614556.png" alt=""></p>
<pre><code>//基于桶排序求解「前 K 个高频元素」
class Solution {
    public List&lt;Integer&gt; topKFrequent(int[] nums, int k) {
        List&lt;Integer&gt; res = new ArrayList();
        // 使用字典，统计每个元素出现的次数，元素为键，元素出现的次数为值
        HashMap&lt;Integer,Integer&gt; map = new HashMap();
        for(int num : nums){
            if (map.containsKey(num)) {
               map.put(num, map.get(num) + 1);
             } else {
                map.put(num, 1);
             }
        }
        
        //桶排序
        //将频率作为数组下标，对于出现频率不同的数字集合，存入对应的数组下标
        List&lt;Integer&gt;[] list = new List[nums.length+1];
        for(int key : map.keySet()){
            // 获取出现的次数作为下标
            int i = map.get(key);
            if(list[i] == null){
               list[i] = new ArrayList();
            } 
            list[i].add(key);
        }
        
        // 倒序遍历数组获取出现顺序从大到小的排列
        for(int i = list.length - 1;i &gt;= 0 &amp;&amp; res.size() &lt; k;i--){
            if(list[i] == null) continue;
            res.addAll(list[i]);
        }
        return res;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)，nn 表示数组的长度。首先，遍历一遍数组统计元素的频率，这一系列操作的时间复杂度是 O(n)；桶的数量为 n+1，所以桶排序的时间复杂度为 O(n)；因此，总的时间复杂度是 O(n)。<br>
空间复杂度：很明显为 O(n)</p>
</blockquote>
<blockquote>
<p>官方题解：<br>
方法 1：堆<br>
想法<br>
k = 1 时问题很简单，线性时间内就可以解决。只需要用哈希表维护元素出现频率，每一步更新最高频元素即可。<br>
当 k &gt; 1 就需要一个能够根据出现频率快速获取元素的数据结构，这就是优先队列。<br>
首先建立一个元素值对应出现频率的哈希表。在 Java 中使用 HashMap，但需要手工填值。在 Python 中提供一个字典结构用作哈希表和在 collections 库中的 Counter 方法去构建我们需要的哈希表。<br>
这个步骤需要 O(N) 时间其中 N 是列表中元素个数。<br>
第二步建立堆，堆中添加一个元素的复杂度是O(log(k))，要进行 N 次复杂度是 O(N)。<br>
最后一步是输出结果，复杂度为 O(klog(k))。<br>
在 Python 中可以使用 heapq 库中的 nlargest 方法，可以在相同时间内完成，但只需要一行代码解决。</p>
</blockquote>
<pre><code>class Solution {
  public List&lt;Integer&gt; topKFrequent(int[] nums, int k) {
    // build hash map : character and how often it appears
    HashMap&lt;Integer, Integer&gt; count = new HashMap();
    for (int n: nums) {
      count.put(n, count.getOrDefault(n, 0) + 1);
    }

    // init heap 'the less frequent element first'
    PriorityQueue&lt;Integer&gt; heap =
            new PriorityQueue&lt;Integer&gt;((n1, n2) -&gt; count.get(n1) - count.get(n2));

    // keep k top frequent elements in the heap
    for (int n: count.keySet()) {
      heap.add(n);
      if (heap.size() &gt; k)
        heap.poll();
    }

    // build output list
    List&lt;Integer&gt; top_k = new LinkedList();
    while (!heap.isEmpty())
      top_k.add(heap.poll());
    Collections.reverse(top_k);
    return top_k;
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(Nlog(k))。Counter 方法的复杂度是 O(N)，建堆和输出的复杂度是 O(Nlog(k))。因此总复杂度为O(N+Nlog(k))=O(Nlog(k))。<br>
空间复杂度：O(N)，存储哈希表的开销。<br>
注释<br>
根据复杂度分析，方法对于小 k 的情况是很优的。但是如果 k 值很大，我们可以将算法改成删除频率最低的若干个元素。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UNP 第三十章 客户/服务器程序设计范式]]></title>
        <id>https://lixin-ee.github.io//post/unp-di-san-shi-zhang-ke-hu-fu-wu-qi-cheng-xu-she-ji-fan-shi</id>
        <link href="https://lixin-ee.github.io//post/unp-di-san-shi-zhang-ke-hu-fu-wu-qi-cheng-xu-she-ji-fan-shi">
        </link>
        <updated>2020-01-21T00:35:03.000Z</updated>
        <content type="html"><![CDATA[<p>当开发一个Unix服务器程序时，我们有如下类型的进程控制可供选择。<br>
・本书第一个服务器程序即图1-9是一个迭代服务器(iterative server)程序，不过这种类型 的适用情形极为有限，因为这样的服务器在完成对当前客户的服务之前无法处理已等待 服务的新客户。<br>
・图5-2是本书第一个并发服务器(concurrent server)程序，它为每个客户调用fork派生一 个子进程。传统上大多数Unix服务器程序属于这种类型。<br>
・在6.8节，我们开发的另一个版本的TCP服务器程序由使用select处理任意多个客户的单 个进程构成。<br>
・在图26-3中我们的并发服务器程序被改为服务器为每个客户创建一个线程，以取代派生 一个进程。</p>
<p>我们将在本章探究并发服务器程序设计的另两类变体。<br>
・预先派生子进程(prefbrking)是让服务器在启动阶段调用fork创建一个子进程池。每个 客户请求由当前可用子进程池中的某个(闲置)子进程处理。<br>
・预先创建线程(prethreading)是让服务器在启动阶段创建一个线程池，每个客户由当前可用线程池中的某个(闲置)线程处理。</p>
<p>从其他服务器的实际CPU时间中减去迭代服务器的实际GPU 时间就得到相应服务器用于进程控制所需的CPU时间，因为迭代服务器没有进程控制开销。</p>
<h3 id="tcp客户程序设计范式">TCP客户程序设计范式</h3>
<p>我们已经探究了客户程序的各种设计范式，这里有必要汇总它们各自的优缺点。<br>
・图5-5是基本的TCP客户程序。该程序存在两个问题。首先，进程在被阻塞以等待用户输入期间，看不到诸如对端关闭连接等网络事件。其次，它以停-等模式运作，批处理效率极低。<br>
・图6-9是下一个迭代客户程序，它通过调用select使得进程能够在等待用户输入期间得 到网络事件通知。然而该程序存在不能正确地处理批量输入的问题。图6-13通过使用 shutdown函数解决了这个问题。<br>
・从图16-3开始给出的是使用非阻塞式I/O实现的客户程序。<br>
・第一个超越单进程单线程设计范畴的客户程序是图16-10,它使用fork派生一个子进程， 并由父进程（或子进程）处理从客户到服务器的数据，由子进程（或父进程）处理从服 务器到客户的数据。<br>
・图26-2使用两个线程取代两个进程。<br>
非阻塞式I/O版本尽管是最快的，其代码却比较复杂；使用两个进程或两个线程的版本相比之下代码简化得多，而运行速度只是稍逊而已。</p>
<h3 id="tcp迭代服务器程序">TCP迭代服务器程序</h3>
<p>迭代服务器没有执行任何进程控制。这就让我们测量出服务器处理如此数目客户所需CPU时间的一个<strong>基准值</strong>，从其他服务器的实测CPU时间中减去该值就能得到它们的进程控制时间。从<strong>进程控制角度</strong>看迭代服务器是最快的，因为它不执行进程控制。有了基准值之后，我们在图30-1 中比较各个实测CPU时间与基准值的差值。<br>
<img src="https://lixin-ee.github.io//post-images/1579572365941.png" alt=""></p>
<h3 id="tcp并发服务器程序每个客户一个子进程">TCP并发服务器程序，每个客户一个子进程</h3>
<p>传统上并发服务器调用fork派生一个子进程来处理每个客户。这使得服务器能够同时为多 个客户服务，每个进程-个客户。客户数目的唯一限制是操作系统对以其名义运行服务器的用 户ID能够同时拥有多少子进程的限制。图5-12就是一个并发服务器程序的例子，绝大多数TCP服务器程序也按照这个范式编写。<br>
并发服务器的问题在于为每个客户现场fork一个子进程比较耗费CPU时间。</p>
<p><strong>code 30-4~7</strong></p>
<h3 id="tcp预先派生子进程服务器程序accept无上锁保护">TCP预先派生子进程服务器程序：accept无上锁保护</h3>
<p>预先派生子进程(prefdrking)：启动阶段预先派生一定数量的子进程，当各个客户连接到达时，这些子进程立即就能为它们服务。<br>
这种技术的优点在于无须引入父进程执行fork的开销就能处理新到的客户。缺点则是父进 程必须在服务器启动阶段猜测需要预先派生多少子进程。如果某个时刻客户数恰好等于子进程 总数，那么新到的客户将被忽略，直到至少有一个子进程重新可用。<br>
然而这些客户并未被完全忽略。内核将为每个新到的客户完成三路握手，直到达到相应套接字上listen调用的backlog数为止，然后在服务器调用accept时把这些已完成的连接传递给它。这么一来客户就能觉察到服务器在响应时间上的恶化，因为尽管它的connect调用可能立即返回 <strong>（注意这里也要区分好TCP返回和应用层返回的区别）</strong>，但是它的第一个请求可能是在一段时间之后才被服务器处理。<br>
<img src="https://lixin-ee.github.io//post-images/1579573503597.png" alt=""><br>
通过增加一些代码，服务器总能应对客户负载的变动。父进程必须做的就是持续监视可用 (即闲置)子进程数，一旦该值降到低于某个阈值就派生额外的子进程。同样，一旦该值超过另 一个阈值就终止一些过剩的子进程，过多的可用子进程也会导致性能退化。<br>
<strong>code 30-9~12</strong><br>
既然getrusage汇报的是已终止子进程的资源利用统计，在调用pr_cpu_time之前就必须终止所有子进程。我们通过给每个子进程发送SIGTERM信号终止它们，并通过调用 wait汇集所有子进程的资源利用统计。<br>
调用fork派生子进程后只有父进程返回。子进程调用图30-12给出的child_main函数， 它是个无限循环。<br>
每个子进程调用accept返回一个已连接套接字，然后调用web.child处理客户请求，最后关闭连接。<strong>子进程一直在这个循环中反复，直到被父进程终止</strong>。</p>
<p><strong>多个进程在同一个监听描述符上调用accept</strong><br>
<img src="https://lixin-ee.github.io//post-images/1579573862224.png" alt=""><br>
描述符只是本进程引用file结构的proc结构中一个数组中某个元素的下标而已。fork调用 执行期间为子进程复制描述符的特性之一是：子进程中一个给定描述符引用的file结构正是父进程中同一个描述符引用的file结构。<br>
每个file结构都有一个引用计数。当打开一个文件或套 接字时，内核将为之构造一个file结构，并由作为打开操作返回值的描述符引用，它的引用计 数初值自然为1;以后每当调用fork以派生子进程或对打开操作返回的描述符（或其复制品） 调用dup以复制描述符时，该file结构的引用计数就递增（每次增1）。在我们的N个子进程的例 子中，file结构的引用计数为N+1 （别忘了父进程仍然保持该监听描述符打开着，不过它从不调用 accept）<br>
服务器进程在程序启动阶段派生N个子进程，它们各自调用accept并因而均被内核投入睡 眠。当第一个客户连接到达时，所有N个子进程均被唤醒。这是因为所有N个子进程所用的监听描述符（它们有相同的值）指向同一个socket结构，致使它们在同一个等待通道（wait channel）即这个socket结构的so_timeo成员上进入睡眠。<br>
尽管所有N个子进程均被唤醒，其中只有最先运行的子进程获得那个客户连接，其余N-1个子进程继续回复唾眠， 因为当它们将发现队列长度为0 （因为最先运行的连接早已取走了本就只有一个的连接）。<br>
这就是有时候称为<strong>惊群（thundering herd）</strong> 的问题，因为尽管只有一个子进程将获得连接， 所有N个子进程却都被唤醒了<br>
当可用子进程阻塞在accept调用上时，内核调度算法把各个连接均匀地散布到各个子进程。</p>
<p><strong>select 冲突</strong><br>
select函数的冲突(collision)现象以及内核如何处理<br>
当<strong>多个进程</strong>在引用<strong>同一个套接字的描述符上</strong>调用select时就会发生冲突，因为在socket结构中为存放本套接字就绪之时应该唤醒哪些进程而<strong>分配的仅仅是一个进程ID的空间</strong>。如果有多个进程在等待同一个套接字，那么内核必须唤醒的是阻塞在select调用中的所有进程，因为它不知道哪些进程受刚变得就绪的这个套接字影响。（注意，这里指的是多个进程同时调用select，亦即多个select，而不是一个select中可以存放多个同一套接字）<br>
可以迫使本服务器程序发生select冲突，办法是在调用accept之前加上一个select调用，等待监听套接字变为可读。各个子进程将阻塞在select调用而不是accept调用之中。<br>
<img src="https://lixin-ee.github.io//post-images/1579574743412.png" alt=""><br>
如果有<strong>多个进程阻塞在引用同一个实体</strong>(例如套接字或普通文件，由file结构直接或间接描述)的描述符上，那么最好直接阻塞在诸如accept之类的函数<strong>而不是select之中</strong>。</p>
<h3 id="tcp预先派生子进程服务器程序accept使用文件上锁保护">TCP预先派生子进程服务器程序,accept使用文件上锁保护</h3>
<p>允许多个进程在引用同一个监听套接字的描述符上调用accept的做法也仅仅适用于在内核中实现accept的内核，作为一个库函数实现accept的内核可能不允许这么做，某个子进程的accept就会返回EPROTO错误(表示协议有错)，原因在于库函数版本的accept并非一个原子操作</p>
<p>解决办法是让应用进程在<strong>调用accept前后安置某种形式的锁(lock)</strong>,这样任意时刻<strong>只有一个子进程阻塞在accept调用中</strong>，<strong>其他子进程则阻塞在试图获取</strong>用于保护accept的锁上。<br>
<img src="https://lixin-ee.github.io//post-images/1579575352861.png" alt=""><br>
<img src="https://lixin-ee.github.io//post-images/1579575446659.png" alt=""><br>
<img src="https://lixin-ee.github.io//post-images/1579575460814.png" alt=""></p>
<h3 id="tcp预先派生子进程服务器程序accept使用线程上锁保护">TCP预先派生子进程服务器程序，accept使用线程上锁保护</h3>
<p>上一节使用的POSEX文件上锁方法可移植到所有POSIX兼容系统，不过它涉及文件系统操作，可能比较耗时。<br>
本节我们改用线程上锁保护 accept,因为这种方法不仅适用于同一进程内各线程之间的上锁，而且适用于不同进程之间的上锁。<br>
（为了使用线程上锁，我们的main、child_make和child_main函数都保持不变，唯一需要改动的是那3个上锁函数。）<br>
在不同进程之间使用线程上锁要求：(1)<strong>互斥锁变量</strong>必须存放在由<strong>所有进程共享的内存区中</strong>；(2)必须<strong>告知线程函数库</strong>这是在<strong>不同进程之间共享</strong>的互斥锁。<br>
<img src="https://lixin-ee.github.io//post-images/1579576163684.png" alt=""><br>
<img src="https://lixin-ee.github.io//post-images/1579576201447.png" alt=""></p>
<h3 id="tcp预先派生子进程服务器程序传递描述符">TCP预先派生子进程服务器程序，传递描述符</h3>
<p>派生子进程的最后一个版本：只让父进程调用accept,然后把所接 受的己连接套接字&quot;传递”给某个子进程。<br>
这么做绕过了为所有子进程的accept调用提供上锁 保护的可能需求，不过需要从父进程到子进程的某种形式的描述符传递。这种技术会使代码多少有点复杂，因为父进程必须跟踪子进程的忙闲状态，以便给空闲子进程传递新的套接字。<br>
<img src="https://lixin-ee.github.io//post-images/1579576278446.png" alt=""><br>
结构中存放相应子进程的进程ID、父进程中连接到该子进程的字节流管道描述 符、子进程状态以及该子进程已处理客户的计数。<br>
在调用fork之前先创建一个<strong>字节流管道</strong>， 它是一对<strong>Unix域字节流套接字</strong>。派生出子进程之后，父进程关闭其中一个描述符 (sockfd[1]),子进程关闭另一个描述符(sockfd[0] )子进程还把流管道的自身拥有端 (sockfd[1])复制到标准错误输出，这样每个子进程就通过读写标准错误输出和父进程通信。<br>
<strong>code 30-21</strong><br>
<img src="https://lixin-ee.github.io//post-images/1579576602577.png" alt=""><br>
<strong>code 30-24~25</strong><br>
计数器navail用于跟踪当前可用的子进程数。如果其值为0,那就从select的读描述符 集中关掉与监听套接字对应的位。这么做防止父进程在无可用子进程的情况下accept 新连接。<br>
write_fd函数把就绪的已连接套接字传递给该子 进程<br>
child_main函数在调用子进程<strong>处理完一个客户</strong>之后，通过该子进程的<strong>字节流管道拥有端</strong>向父进程<strong>写回单个字节</strong>。这使得该字节流管道的父进程拥有端变为可读。<br>
父进程读入这个单字节（忽略其值），把该子进程标为可用，并递增navail计数器。要 是该子进程意外终止，它的字节流管道拥有端将被关闭，因而read将返回0。父进程察觉到之后就终止近行，不过更好的做法是登记这个错误，并重新派生一个子进程取代意外终止的那个子进程。<br>
子进程不再调用accept,而是阻塞在 read_fd调用中，等待父进程传递过来一个巳连接套接字描述符</p>
<h3 id="tcp并发服务器程序每个客户一个线程">TCP并发服务器程序:每个客户一个线程</h3>
<p>如果服务器主机支持线程，我们就可以改用线程以取代子进程。<br>
为每个客户创建一个线程，以取代为每个客户派生一个子进程。<br>
<strong>code 30-26</strong><br>
doit函数先让自己脱离，使得主线程不必等待它</p>
<h3 id="tcp预先创建线程服务器程序每个线程各自accept">TCP预先创建线程服务器程序，每个线程各自accept</h3>
<p>在支持线程的系统上，我们有理由预期在服务器启动阶段预先创建一个线程池以取代为每 个客户现场创建一个线程的做法有类似的性能加速。<br>
本服务器的基本设计是预先创建一个线程 池，并让每个线程各自调用accept„取代让每个线程都阻塞在accept调用之中的做法，我们改用互斥锁以保证任何时刻只有一个线程在调用accept<br>
这里没有理由使用文件上锁保护各个线程中的accept调用，因为对于单个进程中的多个线程，我们总可以使用互斥锁达到同样目的。<br>
<img src="https://lixin-ee.github.io//post-images/1579577167043.png" alt=""><br>
我们还声明了一些全局变量，譬如监听套接字描述符和一个需由所有线程共享的互斥锁变量等。<br>
<strong>code 30-28~29</strong></p>
<h3 id="tcp预先创建线程服务器程序主线程统一accept">TCP预先创建线程服务器程序，主线程统一accept</h3>
<p>最后一个使用线程的服务器程序设计范式是在程序启动阶段创建一个线程池之后只让主线程调用accept并把每个客户连接传递给池中某个可用线程<br>
本设计范式的问题在于主线程如何把一个已连接套接字传递给线程池中某个可用线程。<br>
既然所有线程和所有描述符都在<strong>同一个进程</strong>之内，我们<strong>没有必要</strong>把一个描述符从一个线程传递到另一个线程。接收线程只需知道这个己连接套接字描述符的值，而描述符传递实际传递的并非这个值，而是<strong>对这个套接字的一个引用</strong>，因而将<strong>返回一个不同于原值的描述符</strong>（该套接字的引用计数也被递增）。<br>
<img src="https://lixin-ee.github.io//post-images/1579577365769.png" alt=""><br>
还定义一个clifd数组，由<strong>主线程</strong>往中存入<strong>已接受的已连接套接字描述符</strong>，并由<strong>线程池</strong>中的<strong>可用线程</strong>从中<strong>取出一个以服务相应的客户</strong>。iput是主线程将往该数组中存入 的下一个元素的下标，iget是线程池中某个线程将从该数组中取出的下一个元素的下 标。这个由<strong>所有线程共享的数据结构</strong>自然<strong>必须得到保护</strong>，我们使用互斥锁和条件变量做到这一点。</p>
<p><strong>code 30-31~32</strong><br>
主线程大部分时间阻塞在accept调用中，等待各个客户连接的到达。一旦某个客户连 接到达，主线程就把它的已连接套接字描述符存入clifd数组的下—个元素，不过需事 先获取保护该数组的互斥锁。<br>
主线 程接受一个连接后将调用pthread_cond_signal向条件变量发送信号，以唤醒睡眠在 其上的线程。<br>
当主线程调用pthread_cond_signal引起线程函数库基于条件变量执行唤醒 工作时，该函数库在所有可用线程中轮循唤醒其中一个。</p>
<p>小结：<br>
<img src="https://lixin-ee.github.io//post-images/1579577535464.png" alt=""></p>
]]></content>
    </entry>
</feed>