<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-11-25T13:48:31.659Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[C++ primer 第十六章 笔记+习题 16.3]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-liu-zhang-bi-ji-xi-ti-163</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-liu-zhang-bi-ji-xi-ti-163">
        </link>
        <updated>2019-11-25T12:32:21.000Z</updated>
        <content type="html"><![CDATA[<p>16.3重载与模板<br>
函数模板可以被<strong>另一个模板</strong>或一个<strong>普通非模板函数</strong>重载。与往常一样，名字相同的函数必须具有<strong>不同数量或类型</strong>的<strong>参数</strong>。<br>
•对于一个调用，其候选函数包括所有模板实参推断（参见16.2节，第600页）成功的函数模板实例。<br>
•候选的函数模板<strong>总是可行的</strong>，因为模板实参推断会排除任何不可行的模板。<br>
•与往常一样，可行函数（模板与非模板）按<strong>类型转换</strong>（如果对此调用需要的话）来排序。当然，可以用于函数模板调用的类型转换是非常有限的（参见16.2.1节，第601页）。（1.顶层const转换 2.数组指针和函数指针）<br>
•与往常一样，如果恰有一个函数提供比任何其他函数都更好的匹配，则选择此函数。但是.如果有多个函数提供<strong>同样好的匹配</strong>，则：<br>
—如果同样好的函数中<strong>只有一个</strong>是<strong>非模板函数</strong>，则选择此函数。<br>
—如果同样好的函数中<strong>没有非模板函数</strong>，而有多个函数模板，且其中一个模板比其他模板更有<strong>特例化</strong>，则选择此模板。<br>
—否则，此调用有歧义。<br>
特例化：指更不通用</p>
<p>第一个版本的debug_rep：debug_rep(const T&amp;) 第二个版本的<code>debug_rep(T *)</code><br>
当有多个重载模板对一个调用提供同样好的匹配时，应选择<strong>最特例化（最特殊）的版本</strong>。<br>
对于一个调用，如果一个<strong>非函数模板</strong>与一个<strong>函数模板</strong>提供<strong>同样好的匹配</strong>，则<strong>选择非模板化本</strong><br>
注意<code>const char*</code>和<code>const char[10]</code>的区别<br>
非模板版本是可行的，但需要进行一次<strong>用户定义</strong>的类型转换，因此它<strong>没有精确匹配</strong>那么好，所以两个模板成为可能调用的函数。与之前一样， T *版本更加特例化，编译器会选择它。</p>
<p><strong>通常</strong>，如果<strong>使用</strong>了一个<strong>忘记声明的函数</strong>，代码将<strong>编译失败</strong>。<strong>但对于重载函数模板</strong>的函数而言，则<strong>不是这样</strong>。如果编译器可以<strong>从模板实例化出与调用匹配的版本（实例化一个并非你所需的版本）</strong>，则缺少的声明就不重要了。<br>
在<strong>定义任何函数之前</strong>，<strong>记得声明所有重载的函数版本</strong>。这样就不必担心编译器.由于未遇到你希望调用的函数而<strong>实例化一个并非你所需的版本</strong>。</p>
<p>习题16.48</p>
<pre><code>template &lt;typename T&gt; string debug_rep(T *p) {
	ostringstream ret;
	ret &lt;&lt; &quot;pointer:&quot; &lt;&lt; p;
	if (p)
		ret &lt;&lt; &quot; &quot; &lt;&lt; debug_rep(*p);
	else
		ret &lt;&lt; &quot;null pointer&quot;;
	return ret.str();		 
}

template &lt;typename T&gt; string debug(const T &amp;t) {
	ostringstream ret;
	ret &lt;&lt; t;
	return ret.str();
}
</code></pre>
<p>习题16.49<br>
(a)第一个T变成int 第二个T无法匹配 选择第一个<br>
(b)第一个T变成int * 第二个T变成int 第二个更特例化 选择第二个<br>
(c)第一个T变为int，第二个无法匹配，选择第一个<br>
(d)第一个T变成const int* 第二个变成const int，第二个更特例化 选择第二个<br>
(e)第一个T变成int 第二个T无法匹配 选择第一个<br>
(f)第一个变成int* 第二个变成int 第一个更准确 选择第一个<br>
(g)第一个T变成int，第二个无法匹配 选第一个<br>
(h)第一个T变成const int* 第二个变成int 第二个更特例化 选第二个<br>
习题16.50<br>
结果为1 2 1 2 1 1 1 2 （居然全对了hhh）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 235. 二叉搜索树的最近公共祖先[简单]]]></title>
        <id>https://lixin-ee.github.io//post/shu-235-er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/shu-235-er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-jian-dan">
        </link>
        <updated>2019-11-25T07:52:47.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。<br>
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”<br>
例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]<br>
示例 1:<br>
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br>
输出: 6<br>
解释: 节点 2 和节点 8 的最近公共祖先是 6。<br>
示例 2:<br>
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4<br>
输出: 2<br>
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。<br>
说明:<br>
所有节点的值都是唯一的。<br>
p、q 为不同节点且均存在于给定的二叉搜索树中。<br>
在真实的面试中遇到过这道题？<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>一开始的思路是从叶节点出发，依靠标识往上找<br>
一开始比较哈皮，想着从叶节点出发，检验当前节点和目标节点是否相等，相等的话就使用全局bool来表明找到了值，其实这样子无法对付示例2的情况<br>
然后发现其实可以依靠返回值来进行判断，主要的点在于判断示例2的那种情况（亦即当前节点既为目标节点也是公共祖先节点<br>
好不容易通过了才发现自己其实没用上二叉搜索树的最重要的性质，怪不得是道简单题啊！！！完全可以利用p、q两个的值和当前节点比较介于中间的值才可能是公共祖先节点。<br>
哇好难受，把简单问题复杂化了，不过我写的这个可以当作一个通用模板，算是一<br>
点小欣慰吧</p>
<pre><code>class Solution {
public:
    bool get=false;
    TreeNode *res=NULL;
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        preorder(root,p,q);
        return res;
    }
    
    bool preorder(TreeNode* cur,TreeNode* p, TreeNode* q){
        if(cur==NULL)
            return false;
        if(get)
            return false;
        bool l=preorder(cur-&gt;left,p,q);
        bool r=preorder(cur-&gt;right,p,q);
        if(!get&amp;&amp;l&amp;&amp;r){
            get=true;
            res=cur;
            return false;
        }
        if(!get&amp;&amp;(l||r)&amp;&amp;(cur==p||cur==q)){
            get=true;
            res=cur;
            return false;
        }
        return (cur==p||cur==q)||l||r;  
    }
};
</code></pre>
<p>然后来看一下官方题解吧</p>
<blockquote>
<p>方法一 （递归）<br>
思路<br>
节点 p，q 的最近公共祖先（LCA）是距离这两个节点最近的公共祖先节点。在这里 最近 考虑的是节点的深度。下面这张图能帮助你更好的理解 最近 这个词的含义。<br>
笔记：p 和 q 其中的一个在 LCA 节点的左子树上，另一个在 LCA 节点的右子树上。<br>
也有可能是下面这种情况：<br>
算法<br>
从根节点开始遍历树<br>
如果节点 p 和节点 q 都在右子树上，那么以右孩子为根节点继续 1 的操作<br>
如果节点 p 和节点 q 都在左子树上，那么以左孩子为根节点继续 1 的操作<br>
如果条件 2 和条件 3 都不成立，这就意味着我们已经找到节 p 和节点 q 的 LCA 了</p>
</blockquote>
<pre><code>class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {

        // Value of current node or parent node.
        int parentVal = root.val;

        // Value of p
        int pVal = p.val;

        // Value of q;
        int qVal = q.val;

        if (pVal &gt; parentVal &amp;&amp; qVal &gt; parentVal) {
            // If both p and q are greater than parent
            return lowestCommonAncestor(root.right, p, q);
        } else if (pVal &lt; parentVal &amp;&amp; qVal &lt; parentVal) {
            // If both p and q are lesser than parent
            return lowestCommonAncestor(root.left, p, q);
        } else {
            // We have found the split point, i.e. the LCA node.
            return root;
        }
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(N)<br>
其中 N 为 BST 中节点的个数，在最坏的情况下我们可能需要访问 BST 中所有的节点。<br>
空间复杂度：O(N)<br>
所需开辟的额外空间主要是递归栈产生的，之所以是 N 是因为 BST 的高度为 N。</p>
</blockquote>
<blockquote>
<p>方法二 （迭代）<br>
算法<br>
这个方法跟方法一很接近。唯一的不同是，我们用迭代的方式替代了递归来遍历整棵树。由于我们不需要回溯来找到 LCA 节点，所以我们是完全可以不利用栈或者是递归的。实际上这个问题本身就是可以迭代的，我们只需要找到分割点就可以了。这个分割点就是能让节点 p 和节点 q 不能在同一颗子树上的那个节点，或者是节点 p 和节点 q 中的一个，这种情况下其中一个节点是另一个节点的父亲节点。</p>
</blockquote>
<pre><code>class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {

        // Value of p
        int pVal = p.val;

        // Value of q;
        int qVal = q.val;

        // Start from the root node of the tree
        TreeNode node = root;

        // Traverse the tree
        while (node != null) {

            // Value of ancestor/parent node.
            int parentVal = node.val;

            if (pVal &gt; parentVal &amp;&amp; qVal &gt; parentVal) {
                // If both p and q are greater than parent
                node = node.right;
            } else if (pVal &lt; parentVal &amp;&amp; qVal &lt; parentVal) {
                // If both p and q are lesser than parent
                node = node.left;
            } else {
                // We have found the split point, i.e. the LCA node.
                return node;
            }
        }
        return null;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(N)<br>
其中 N 为 BST 中节点的个数，在最坏的情况下我们可能需要遍历 BST 中所有的节点。<br>
空间复杂度：O(1)</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 98. 验证二叉搜索树[中等]]]></title>
        <id>https://lixin-ee.github.io//post/shu-98-yan-zheng-er-cha-sou-suo-shu-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/shu-98-yan-zheng-er-cha-sou-suo-shu-zhong-deng">
        </link>
        <updated>2019-11-24T01:21:30.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。<br>
假设一个二叉搜索树具有如下特征：<br>
节点的左子树只包含小于当前节点的数。<br>
节点的右子树只包含大于当前节点的数。<br>
所有左子树和右子树自身必须也是二叉搜索树。<br>
示例 1:<br>
输入:<br>
2<br>
/ <br>
1   3<br>
输出: true<br>
示例 2:<br>
输入:<br>
5<br>
/ <br>
1   4<br>
     / <br>
    3   6<br>
输出: false<br>
解释: 输入为: [5,1,4,null,null,3,6]。<br>
     根节点的值为 5 ，但是其右子节点值为 4 。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/validate-binary-search-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<pre><code>class Solution {
    int i=INT_MIN;
    bool beg=true;
    bool res=true;
public:
    bool isValidBST(TreeNode* root) {
      inorder(root);
        return res;
    }
    
    void inorder(TreeNode *cur){
       if(cur==NULL)
           return ;
        if(!res)
            return;
        inorder(cur-&gt;left);
        if(!beg){
         if(cur-&gt;val&lt;=i){
            res=false;
            return;
         }
        }else
            beg=false;    
        i=cur-&gt;val;

        inorder(cur-&gt;right);
        return;
    }
};
</code></pre>
<p>一开始我直接将父母节点的值和子节点进行比较，结果翻车了，忽视了示例2中节点3那种情况然后考虑利用中序遍历是不是能够直接得到结果<br>
一开始想偷懒，先看看能不能直接利用一个int返回值来比较，然后发现这样子还是必须判断左子树还是右子树比较麻烦<br>
然后还是老老实实用vector来存吧。然后遇到一个坑，二叉搜索树是必须小于或者大于，不能等于。通过了，当然内存也是爆炸了<br>
后来想起可以用int代替vector，然后发现int的初值是个问题，用INT_MAX被教育了一番，于是还是老老实实新增了一个bool来设置，确实降低了部分内存消耗</p>
<p>然后来看一下官方题解</p>
<blockquote>
<p>乍一看，这是一个平凡的问题。只需要遍历整棵树，检查 node.right.val &gt; node.val 和<br>
node.left.val &lt; node.val 对每个结点是否成立。<br>
问题是，这种方法并不总是正确。不仅右子结点要大于该节点，整个右子树的元素都应该大于该节点。例如:<br>
这意味着我们需要在遍历树的同时保留结点的上界与下界，在比较时不仅比较子结点的值，也要与上下界比较</p>
</blockquote>
<p>这里说到的特例就是例子2的情况</p>
<blockquote>
<p>方法一: 递归<br>
上述思路可以用递归法实现。首先将结点的值与上界和下界（如果有）比较。然后，对左子树和右子树递归进行该过程。</p>
</blockquote>
<pre><code>class Solution {
  public boolean helper(TreeNode node, Integer lower, Integer upper) {
    if (node == null) return true;

    int val = node.val;
    if (lower != null &amp;&amp; val &lt;= lower) return false;
    if (upper != null &amp;&amp; val &gt;= upper) return false;

    if (! helper(node.right, val, upper)) return false;
    if (! helper(node.left, lower, val)) return false;
    return true;
  }

  public boolean isValidBST(TreeNode root) {
    return helper(root, null, null);
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 : O(N)。每个结点访问一次。<br>
空间复杂度 : O(N)。我们跟进了整棵树</p>
</blockquote>
<blockquote>
<p>方法二: 迭代<br>
通过使用栈，上面的递归法可以转化为迭代法。这里使用深度优先搜索，比广度优先搜索要快一些。</p>
</blockquote>
<pre><code>class Solution {
  LinkedList&lt;TreeNode&gt; stack = new LinkedList();
  LinkedList&lt;Integer&gt; uppers = new LinkedList(),
          lowers = new LinkedList();

  public void update(TreeNode root, Integer lower, Integer upper) {
    stack.add(root);
    lowers.add(lower);
    uppers.add(upper);
  }

  public boolean isValidBST(TreeNode root) {
    Integer lower = null, upper = null, val;
    update(root, lower, upper);

    while (!stack.isEmpty()) {
      root = stack.poll();
      lower = lowers.poll();
      upper = uppers.poll();

      if (root == null) continue;
      val = root.val;
      if (lower != null &amp;&amp; val &lt;= lower) return false;
      if (upper != null &amp;&amp; val &gt;= upper) return false;
      update(root.right, val, upper);
      update(root.left, lower, val);
    }
    return true;
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 : O(N)。每个结点访问一次。<br>
空间复杂度 : O(N)。我们跟进了整棵树。</p>
</blockquote>
<blockquote>
<p>方法三：中序遍历<br>
算法<br>
我们使用<br>
中序遍历<br>
左子树 -&gt; 结点 -&gt; 右子树的顺序<br>
上面的结点按照访问的顺序标号，你可以按照 1-2-3-4-5 的顺序来比较不同的策略。<br>
左子树 -&gt; 结点 -&gt; 右子树 意味着对于二叉搜索树而言，每个元素都应该比下一个元素小。</p>
</blockquote>
<blockquote>
<p>因此，具有 O(N) 时间复杂度与 O(N) 空间复杂度的算法十分简单:<br>
计算中序遍历列表 inorder.<br>
检查 inorder中的每个元素是否小于下一个。<br>
我们需要保留整个inorder列表吗？<br>
事实上不需要。每一步最后一个添加的元素就足以保证树是（或不是）二叉搜索树。<br>
因此，我们可以将步骤整合并复用空间。<br>
实现</p>
</blockquote>
<pre><code>class Solution {
  public boolean isValidBST(TreeNode root) {
    Stack&lt;TreeNode&gt; stack = new Stack();
    double inorder = - Double.MAX_VALUE;

    while (!stack.isEmpty() || root != null) {
      while (root != null) {
        stack.push(root);
        root = root.left;
      }
      root = stack.pop();
      // If next element in inorder traversal
      // is smaller than the previous one
      // that's not BST.
      if (root.val &lt;= inorder) return false;
      inorder = root.val;
      root = root.right;
    }
    return true;
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 : 最坏情况下（树为二叉搜索树或破坏条件的元素是最右叶结点）为 O(N)。<br>
空间复杂度 : O(N) 用于存储 stack。</p>
</blockquote>
<p>从题解中我发现了自己程序值得改进的地方，就是把in换成结点指针，这样子的话也可以省去一个bool值，也可以省去首次赋值的判断</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 199.二叉树右视图[中等]]]></title>
        <id>https://lixin-ee.github.io//post/shu-199er-cha-shu-you-shi-tu-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/shu-199er-cha-shu-you-shi-tu-zhong-deng">
        </link>
        <updated>2019-11-23T15:22:12.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。<br>
示例:<br>
输入: [1,2,3,null,5,null,4]<br>
输出: [1, 3, 4]<br>
解释:<br>
1            &lt;---<br>
/   <br>
2     3         &lt;---<br>
\     <br>
5     4       &lt;---<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/binary-tree-right-side-view<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>我的想法很简单，直接是从层次遍历的想法，但是主要的点在于先遍历根节点-右节点-左节点，同时使用i来记录层数，并且只记录第一个出现的值。<br>
还有一个优化点是传vector的引用而不是建立一个全局的vector<br>
代码如下</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; rightSideView(TreeNode* root) {
        vector&lt;int&gt; res;
        preorder(root,0,res);
        return res;
    }
    
    void preorder(TreeNode *cur,int i,vector&lt;int&gt; &amp;res){
        if(cur==NULL)
            return;
        if(res.size()==i)
            res.push_back(cur-&gt;val);
        preorder(cur-&gt;right,i+1,res);
        preorder(cur-&gt;left,i+1,res);
        return;
    }
};
</code></pre>
<p>首先是网友题解</p>
<blockquote>
<p>这道题有递归和非递归两种方法，首先来看递归方法。<br>
递归方法是分别遍历一个节点的右节点和左节点，因为是从右边看过来，所以我们需要首先遍历右节点。这里有个疑问，当遍历左节点时候，怎么判定它右边没有其他节点了呢？这里我们用到一个变量level，对于同一层的节点，如果res数组的大小已经等于level了，说明右边已经有节点存入数组了，该节点就不用再保存。一直递归下去就可以得到结果。<br>
代码一：</p>
</blockquote>
<pre><code>C++
class Solution {
public:
    vector&lt;int&gt; rightSideView(TreeNode* root) {
        vector&lt;int&gt; res;
        helper(root,0,res);
        return res;        
    }
    void helper(TreeNode* root,int level,vector&lt;int&gt;&amp; res){
        if(!root) return;
        if(res.size()==level) res.push_back(root-&gt;val);
        helper(root-&gt;right,level+1,res);
        helper(root-&gt;left,level+1,res);
    }
};
</code></pre>
<blockquote>
<p>下面看一下非递归的方法。这道题要求我们打印出二叉树每一行最右边的一个数字，实际上是求二叉树层序遍历的一种变形，我们只需要保存每一层最右边的数字即可，还是需要用到数据结构队列queue，遍历每层的节点时，把下一层的节点都存入到queue中，每当开始新一层节点的遍历之前，先把新一层最后一个节点值存到结果中，代码如下：<br>
C++</p>
</blockquote>
<pre><code>class Solution {
public:
    vector&lt;int&gt; rightSideView(TreeNode* root) {
        vector&lt;int&gt; res;
        if(!root) return res;
        queue&lt;TreeNode*&gt; q;
        q.push(root);
        while(!q.empty()){
            res.push_back(q.back()-&gt;val);
            int size=q.size();
            for(int i=0;i&lt;size;++i){
                TreeNode* t=q.front(); q.pop();
                if(t-&gt;left) q.push(t-&gt;left);
                if(t-&gt;right) q.push(t-&gt;right);
            }           
        }
        return res;
    }
};
</code></pre>
<p>官方题解我感觉一般般，而且用的java差异较大，但是涉及广度优先遍历，有兴趣的话可以看看</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 103.二叉树的锯齿形层次遍历 [中等]]]></title>
        <id>https://lixin-ee.github.io//post/shu-103er-cha-shu-de-ju-chi-xing-ceng-ci-bian-li-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/shu-103er-cha-shu-de-ju-chi-xing-ceng-ci-bian-li-zhong-deng">
        </link>
        <updated>2019-11-22T12:48:54.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。<br>
例如：<br>
给定二叉树 [3,9,20,null,null,15,7],<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7<br>
返回锯齿形层次遍历如下：<br>
[<br>
[3],<br>
[20,9],<br>
[15,7]<br>
]<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题我是直接看的网友题解，倒不是不会做，只是没有比较好的想法<br>
因为这个和前一题不同，前一题我还可以用deque来处理，这一题着实是比较麻烦了（其实也可以用deque，只是相对比较笨的处理方法）<br>
然后网友题解中有个不错的，利用栈来存储，可以选择不同层的时候的入栈顺序，从而实现交替左右（怎么说着说着感觉又蛮麻烦了hhh<br>
所以直接来看网友题解吧</p>
<blockquote>
<p>大家的做法大都是list或者queue反转，但是这是耗时操作，特别是queue自身并不支持反转（list在c++是双向链表，可以相当于有反转功能），用reverse我觉得可能是耗时的，我的解法是两个stack各自保存一层数据，然后先进后出的特性加上左右节点先后入栈的顺序细节（具体谁先谁后可以看代码）即可恰好对应zigZag的Z字形访问顺序：</p>
<p>我的提交执行用时<br>
已经战胜 96.52 % 的 cpp 提交记录</p>
</blockquote>
<pre><code>vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode *root) {
		//右往左时右先入栈，左往右时，左先入栈。然后要两个栈分别保存每一层级的。
		//这里借鉴了树的层次遍历的思想，不过那是用队列
		vector&lt;vector&lt;int&gt;&gt; r;
		if (!root) return r;
		stack&lt;TreeNode *&gt; d1, d2;
		d1.push(root);
		TreeNode *curr = nullptr;
		vector&lt;int&gt; tmp;
		while (true) {
				while (!d1.empty()) {
						curr = d1.top();
						d1.pop();
						tmp.push_back(curr-&gt;val);
						if (curr-&gt;left) d2.push(curr-&gt;left);
						if (curr-&gt;right) d2.push(curr-&gt;right);
				}
				if (!tmp.empty()) {
						r.push_back(tmp);
						tmp.clear();
				} else break;

				while (!d2.empty()) {
						curr = d2.top();
						d2.pop();
						tmp.push_back(curr-&gt;val);
						if (curr-&gt;right) d1.push(curr-&gt;right);
						if (curr-&gt;left) d1.push(curr-&gt;left);
				}
				if (!tmp.empty()) {
						r.push_back(tmp)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第十六章 笔记+习题 16.2]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-liu-zhang-bi-ji-xi-ti-162</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-liu-zhang-bi-ji-xi-ti-162">
        </link>
        <updated>2019-11-21T13:17:11.000Z</updated>
        <content type="html"><![CDATA[<p>16.2模板实参推断<br>
从函数实参来确定模板实参的过程被称为模板实参推断</p>
<p>16.2.1类型转换与模板类型参数<br>
<strong>(注意，这里是实参推断，显式指定实参可以正常转换)</strong> 与往常一样，<strong>顶层 const</strong>( ( 参见2.4.3 节，第57 页）无论是在形参中还是在实参中，<strong>都会被忽略</strong>。在其他类型转换中，能在调用中应用于函数模板的包括如下两项。<br>
• const 转换：可以将一个非 const 对象的引用（或指针）传递给一个 const 的引用（或指针）形参（参见4.11.2 节，第144 页）。<br>
• 数组或函数指针转换：如果函数形参<strong>不是引用类型</strong>，则可以<strong>对数组或函数类型的实参应用正常的指针转换</strong>。一个数组实参可以转换为一个指向其首元素的指针。类似的，一个函数实参可以转换为一个该函数类型的指针（参见4. U .2 节，第143 页）。<br>
<strong>其他类型转换</strong>，如算术转换（参见4.11.1 节，第142 页）、派生类向基类的转换（参见15.2.2节，第530 页）以及用户定义的转换（参见7.5.4 节，第263 页和14.9 节，第514 页），<strong>都不能应用于函数模板</strong>。</p>
<p>注意并不是f(int[ ],int[ ]);<br>
<strong>两个数组大小不同，因此是不同类型</strong>。但是， fref 调用是不合法的。如果<strong>形参是一个引用</strong>，则<strong>数组不会转换为指针</strong>(参见6.2.4节，第195页）。 a 和 b 的类型是不匹配的，因此调用是错误的。</p>
<p>一个模板类型参数可以用作多个函数形参的类型。由于只允许有限的几种类型转换，因此传递给这些形参的实参必须具有相同的类型。如果推断出的类型不匹配，则调用就是错误的。</p>
<p>如果希望允许对函数实参进行正常的类型转换，我们可以将函数模板定义为两个类型<br>
参数：</p>
<p>函数模板可以有用普通类型定义的参数，即，不涉及模板类型参数的类型。这种函数<br>
实参不进行特殊处理；它们正常转换为对应形参的类型 <strong>并非必须用模板参数，只是必须有，模板类型参数不能为空</strong><br>
如果函数参数类型不是模板参数，则对实参进行正常的类型转换。<br>
<code>template &lt;typename T&gt; int add(int a,T b)</code></p>
<p>习题16.32<br>
使用实参的类型来初始化函数的模板实参类型<br>
在模版推断的过程中，编译器根据函数调用的实参类型来寻找模版实参，用这些模版实参生成的函数版本与给定的函数调用匹配<br>
习题16.33<br>
• const 转换：可以将一个非 const 对象的引用（或指针）传递给一个 const 的引用（或指针）形参（参见4.11.2 节，第144 页）。<br>
• 数组或函数指针转换：如果函数形参<strong>不是引用类型</strong>，则可以<strong>对数组或函数类型的实参应用正常的指针转换</strong>。一个数组实参可以转换为一个指向其首元素的指针。类似的，一个函数实参可以转换为一个该函数类型的指针（参见4. U .2 节，第143 页）。</p>
<p>习题16.34<br>
（a）不合法 因为两个字符串数组长度不一致，是不同类型<br>
（b）合法，T为<code>char[4]</code><br>
习题16.35<br>
（a）合法 T类型是char<br>
（b）合法 T类型是double<br>
（c）合法，两者都是char！！！<br>
（d）不合法，无法进行算术类型转换<br>
注意 单引号的'a'就是char类型<br>
习题16.36<br>
（a）T为 int&amp;<br>
（b）T1 T2分别为int&amp;<br>
（c）T为 int* 顶层const被忽略<br>
（d）分别为int *<br>
（e）不合法，首先需要判断实参的类型是否相同，再判断类型是否可转换，两参数一个为const一个非const<br>
（f）T1和T2都为int*<br>
注意：虽然会忽视顶层const，但是首先需要判断实参的类型是否相同，再判断类型是否可转换，如果两参数一个为const一个非const，不能同用一个T</p>
<p>16.2.2函数模板显式实参<br>
在某些情况，编译器<strong>无法推断</strong>出模板实参的类型。其他一些情况下，我们希望<strong>允许用户控制模板实例化</strong>。当函数返回类型与参数列表中任何类型都不相同时，这两种情况最常出现。</p>
<p>没有任何函数实参的类型可用来推断 T 1的类型。毎次调用 sum 时调用者都必须为T1提供一个<strong>显式模板实参</strong> （explicittemplateargument )。<br>
我们提供显式模板实参的方式与定义类模板实例的方式相同。显式模板实参在<strong>尖括号</strong>中给出，位于<strong>函数名之后，实参列表之前</strong>：<br>
//long long 是一个类型<br>
// T1 是显式指定的， T2 和 T3 是从函数实参类型推断而来的<br>
<code>auto val3 = sum&lt;long long&gt;(i,Ing);		//long long sum(int,long)</code><br>
显式模板实参按<strong>由左至右的顺序</strong>与对应的模板参数匹配；第一个模板实参与第一个模板参数匹配，第二个实参与第二个参数匹配，依此类推。<strong>只有尾部（最右）参数</strong>的显式模板实参<strong>才可以忽略</strong>，而且<strong>前提是</strong>它们可以从函数参数<strong>推断出來</strong>。如果我们的 sum 函数按照如下形式编写：</p>
<p><strong>对于模板类型参数已经显式指定了的函数实参，也进行正常的类型转换</strong></p>
<p>习题16.37<br>
<code>compare&lt;int,double&gt;(i,d); compare&lt;int&gt;(i,d); compare&lt;double&gt;(i,d)</code><br>
习题16.38<br>
make_shared接受的参数是一个模板参数包，返回类型是<code>shared_ptr&lt;_Ty&gt;</code>，<code>_Ty</code>是模板参数，由于无法推断返回类型，所以需要显式模板实参。<br>
习题16.39<br>
<code>compare&lt;string&gt;(&quot;123&quot;，&quot;1234&quot;）;</code><br>
<code>char[]</code>会被转换为string</p>
<p>16.2.3尾置返回类型与类型转换<br>
在编译器遇到函数的参数列表之前， 模板参数列表等同于不存在的。为了定义函数的返回类型，我们必须使用尾置返回类型（参见6.3.3节，第206页）。由于<strong>尾置返回出现在参数列表之后</strong>，它可以使用函数的参数：</p>
<p>注意解引用运算符<strong>首先检查curr是否仍在作用范围内</strong>，如果是，则<strong>返回curr所指元素的一个引用</strong>。 所以return *beg;的返回类型是引用而不是int</p>
<p><strong>如果仅仅有迭代器的话，迭代器的所有操作（比如解引用符）只能返回元素的引用，不能得到元素本身的类型</strong>为了获得元素类型，我们可以使用标准库的类型转换（type transformation )模板。这些模板定义在头文件 type_traits 中。<br>
remove_reference模板有一个模板类型参数和一个名为 type 的（public )类型成员。如果我们用一个引用类型实例化remove _ reference ，则 type 将表示被引用的类型。<br>
<code>decltype(*beg)</code>返回元素类型的引用类型。remove_reference::type脱去引用，剩下元素类型本身。<br>
注意， type 是一个类的成员，而该类依赖于一个模板参数。因此，我们必须在返回类型的声明中使用 typename 来告知编译器， type 表示一个类型<br>
<code>auto fcn(It beg,It end)-&gt;typename remove_reference&lt;decltype(*beg)&gt;::type</code></p>
<p>每个类型转换模板的工作方式都与remove_reference类似。每个模板都有一个名为type的public成员，表示一个类型。此类型与模板自身的模板类型参数相关，其关系如模板名所示。<strong>如果不可能（或者不必要）转换模板参数，则type成员就是模板参数类型本身</strong>。<br>
例如，如果T是一个指针类型，则<code>remove_pointer&lt;T&gt;::type</code>是T指向的类型。如果T不是一个指针，则无须进行任何转换，从而<strong>type具有与T相同的类型</strong>。</p>
<p>习题16.40<br>
是合法的<br>
此时返回类型变为int（亦即取决于容器本身的元素类型）<br>
逆向思维的测试代码</p>
<pre><code>template &lt;typename It&gt;
auto fcn(It beg, It end)-&gt;decltype(*beg) { return (*beg+0); }
</code></pre>
<p>显示 error C2440: “return”: 无法从“int”转换为“int &amp;”<br>
<strong>同时要求容器本身的元素（迭代器解引用后）必须能够做+0的操作</strong></p>
<p>习题16.41<br>
这题不会，但是网友的思路很秒，decltype会自动判断a+b需要什么类型才能容纳</p>
<pre><code>template &lt;typename T&gt; auto sum(const T&amp;a,const T&amp;b) -&gt;decltype(a+b)//将函数的返回类型指定为a+b的类型
{
	return a+b;
}
</code></pre>
<p>16.2.4 函数指针和实参判断<br>
当我们用一个<strong>函数模板</strong>初始化一个<strong>函数指针</strong>或为一个<strong>函数指针赋值</strong>时，编译器使用<strong>指针的类型来推断模板实参</strong><br>
pf1中参数的类型决定了T的模板实参的类型。在本例中，T的模板实参类型为int。指针pf1指向compare的int版本实例。如果不能从函数指针类型确定模板实参，则产生错误<br>
这段代码的问题在于，通过func的参数类型<strong>无法确定模板实参的唯一类型</strong>。对func的调用既可以实例化接受int的compare版本，也可以实例化接受string的版本。由于不能确定func的实参的唯一实例化版本，此调用将编译失败。<br>
我们可以通过使用<strong>显式模板实参来消除func调用的歧义</strong><br>
当参数是一个函数模板实例的指针时，程序上下文必须满足：对于每个模板参数，能唯一确定其类型或值。</p>
<p>16.2.5 模板实参推断和引用<br>
编译器会应用正常的引用绑定规则；<strong>const是底层</strong>的，<strong>不是顶层</strong>的 <strong>（因为引用的本质就是指针，准确的说是一个常量指针，它本身不可能修改指向的对象，自带顶层）</strong><br>
<strong>注意const int&amp; 中的const是底层const 指int是const，而不是指引用</strong><br>
当一个函数参数是模板类型参数的一个<strong>普通（左值）引用</strong>时（即，形如T&amp;），绑定规则告诉我们，<strong>只能传递</strong>给它一个<strong>左值</strong>（如，一个变量或者一个返回引用类型的表达式）。实参可以是const类型，也可以不是，如果<strong>实参是const</strong>的，则<strong>T将会被推断为const类型</strong></p>
<p><strong>通常</strong>我们<strong>不能将一个右值引用</strong>绑定到一个<strong>左值</strong>上，但是，c++语言在正常绑定规则之外定义了<strong>两个例外规则</strong>，允许这种绑定，这两个例外规则是move这种标准库设施正确工作的基础<br>
当我们将一个<strong>左值</strong>（如i）传递给函数的<strong>右值引用参数</strong>，且此右值引用指向模板类型参数（如T&amp;&amp;）时，编译器<strong>推断模板类型参数</strong>为实参的<strong>左值引用</strong>类型。因此，当我们调用f3（i）时，编译器推断<strong>T</strong>的类型为<strong>int&amp;，而非int</strong><br>
通常我们<strong>不能（直接）定义</strong>一个<strong>引用的引用</strong>，但是，通过<strong>类型别名</strong>或通过<strong>模板类型参数间接定义</strong>是可以的<br>
在这种情况下，我们可以使用第二个例外绑定规则：如果我们间接创建一个<strong>引用的引用</strong>，则这些<strong>引用</strong>形成了 <strong>“折叠”</strong>。在所有情况下（除了一个例外），引用会<strong>折叠成</strong>一个<strong>普通的左值引用类型</strong>。在新标准中，折叠规则扩展到右值引用。<strong>只在一种特殊情况下</strong>引用会<strong>折叠成右值引用：右值引用的右值引用</strong>。即，对于一个给定类型X：<br>
1.X&amp;、&amp;、X&amp; &amp;&amp;和X&amp;&amp; &amp;都折叠成类型X&amp;<br>
2.<strong>类型X&amp;&amp; &amp;&amp;折叠成X&amp;&amp;</strong><br>
引用折叠<strong>只能</strong>应用于<strong>间接创建的引用的引用</strong>，如类型别名或模板参数</p>
<p>即使f3的函数参数形式是一个右值引用（即，T&amp;&amp;），此调用也会用一个左值引用类型（即，int&amp;）实例化f3<br>
这两个规则导致了两个重要结果：<br>
1.如果一个函数参数是一个指向模板类型参数的右值引用（如，T&amp;&amp;），则它可以被绑定到一个左值；且<br>
2.如果实参是一个左值，则推断出的模板实参类型将是一个左值引用，且函数参数将会被实例化为一个（普通）左值引用参数（T&amp;）</p>
<p>T&amp;&amp; 等于拷贝 T&amp; 等于绑定引用<br>
当代码涉及的类型可能是普通（非引用）类型，也可能是引用类型时，编写正确的代码就变得异常困难（虽然remove_reference这样的类型转换类可能会有帮助）<br>
在实际中，<strong>右值引用</strong>通常用于两种情况：<strong>模板转发其实参（16.2.7）</strong> 或<strong>模板被重载（16.3）</strong><br>
目前应该注意的是，使用右值引用的函数模板通常使用我们在13.6.3节中看到的方式来进行重载（函数后添加引用限定符）<br>
与非模板函数一样，第一个版本将绑定到可修改的右值，而第二个版本将绑定到左值或const右值。</p>
<p>习题16.42<br>
（a）T为int &amp;<br>
（b）T为const int&amp;(注意这里是底层const不是顶层const)<br>
（c）T为int<br>
习题16.43<br>
operator=返回一个左值引用 所以T为int &amp;<br>
习题16.44<br>
声明为T<br>
（a）int<br>
（b）int<br>
（c）int<br>
声明为const T&amp;<br>
（a）int<br>
（b）int<br>
（c）int<br>
注意，折叠是先观察实参的类型和形参的类型再决定T需要什么类型，而不是根据实参的类型直接决定T的类型<br>
习题16.45<br>
T解释为int 因为42是一个右值<br>
如果是int 则T解释为int&amp; 因为变量是一个左值，此时内部的vector&lt;int &amp;&gt;引发错误，容器不能容纳引用</p>
<p>16.2.6理解std::move<br>
用途：移动操作 绑定到将要销毁的对象 1.转换的表达式<code>i*42</code> 2.字面值 42 3.返回右值的表达式<br>
标准库 move 函数（参见13.6.1节，第472页）是使用右值引用的模板的一个很好的<br>
例子。<br>
虽然不能直接将一个右值引用绑定到一个左值上，但可用 <strong>move 获得一个绑定到左值上的右值引用</strong>。由于 move 本质上可以<strong>接受任何类型的实参</strong>，因此我们不会惊讶于它是一个<strong>函数模板</strong>。</p>
<p>这正是我们所寻求的——我们希望将一个右值引用绑定到一个左值。这个实例的函数体返回 static cast &lt; string &amp;&amp;&gt;( t )。在此情况下，t的类型为 string&amp; , cast将其转换为string &amp;&amp;。</p>
<p>static _ cast 只能用于其他合法的类型转换（参见4.11.3节，第145页）。但是，这里又有一条针对右值引用的特许规则：虽然不能隐式地将一个左值转换为右值引用，但我们可以用 <strong>static _ cast 显式地将一个左值转换为一个右值引用</strong>。</p>
<p>习题16.46<br>
将elem指向的元素转化为右值引用并在新的指针位置构造新的元素，相当于移动元素</p>
<p>16.2.7转发<br>
某些函数需要将其一个或多个实参连同类型不变地<strong>转发给其他函数（即在函数内部调用其他函数或自身）</strong>。在此情况下，我们需要<strong>保持</strong>被转发实参的<strong>所有性质</strong>，包括实参类型<strong>是否是 const</strong> 的以及实参是<strong>左值还是右值</strong>。</p>
<p>F，T1不相互影响，但T1可用于F（int可以作为int&amp;的参数）<br>
f和j并不相互影响<br>
<strong>j的值被拷贝到t1中，f中的引用参数被绑定到t1，而非j，从而其改变不会影响j</strong>使其参数能保持给定实参的&quot;左值性&quot;。更进一步，可以想到我们也希望保持参数的 const 属性。<br>
通过将一个函数参数定义为一个<strong>指向模板类型参数的右值引用</strong>，我们可以保持其对应实参的所有类型信息。而使用<strong>引用参数</strong>（无论是左值还是右值）使得我们可以<strong>保持 const属性</strong>，因为在<strong>引用类型中的 const 是底层的</strong>。<br>
如果一个函数参数是指向模板类型参数的<strong>右值引用(如T&amp;&amp;)</strong>，它对应的实参的<strong>const属性和左值/右值属性将得到保持</strong><br>
可使用一个名为<strong>forward</strong>的新标准库设施来传递flip2的参数，它能保持原始实参的类型。类似move,forward定义在<strong>头文件utility</strong>中。与move不同，forward<strong>必须通过显式模板实参來调用</strong>（参见16.2.2节，第603页）。forward<strong>返回该显式实参类型的右值引用</strong>。即，<strong><code>forward&lt;T&gt;</code></strong> 的返回类型是<strong>T&amp;&amp;</strong>。<br>
通常情况下.我们使用forward传递那些定义为模板类型参数的右值引用的函数参数。通过其返回类型上的<strong>引用折叠</strong>，forward可以<strong>保持</strong>给定实参的<strong>左值/右值属性</strong>：<br>
如果实参是一个右值，则 Type 是一个普通（非引用）类型，<code>forward &lt; Type &gt;</code>将返回Types&amp;&amp;。如果实参是一个左值，则通过引用折叠， Type 本身是一个左值引用类型。在此情况下，返回类型是一个指向左值引用类型的右值引用。再次对 <code>forward &lt; Type &gt;</code>的返回类型进行引用折叠，将返同一个左值引用类型。<br>
当用于一个指向模板参数类型的右值引用函数参数（T &amp;&amp;)时， forward 会保持实参类型的所有细节。<br>
<code>f（std::forward&lt;T2&gt;（t2）,std::forward&lt;T1&gt;(t1)）;</code></p>
<p>习题16.47</p>
<pre><code>template&lt;typename F,typename T1,typename T2&gt;
void flip(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2) {
	f(forward&lt;T2&gt;(t2), forward&lt;T1&gt;(t1));
}

void f(int&amp; a, int &amp;&amp;b)
{
	cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; ++b &lt;&lt; endl;
}
</code></pre>
<p>习题感悟<br>
注意：虽然会忽视顶层const，但是首先需要判断实参的类型是否相同，再判断类型是否可转换，如果两参数一个为const一个非const，不能同用一个T<br>
解引用运算符首先检查curr是否仍在作用范围内，如果是，则返回curr所指元素的一个引用。<br>
注意 单引号的'a'就是char类型<br>
将sum返回的类型自动改为保证足够容纳其计算结果的类型，decltype会自动判断a+b需要什么类型才能容纳</p>
<pre><code>template &lt;typename T&gt; auto sum(const T&amp;a,const T&amp;b) -&gt;decltype(a+b)//将函数的返回类型指定为a+b的类型
{
	return a+b;
}
</code></pre>
<p>注意，折叠是先观察实参的类型和形参的类型再决定T需要什么类型，而不是根据实参的类型直接决定T的类型</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 107. 二叉树的层次遍历 II[简单]]]></title>
        <id>https://lixin-ee.github.io//post/shu-107-er-cha-shu-de-ceng-ci-bian-li-iijian-dan</id>
        <link href="https://lixin-ee.github.io//post/shu-107-er-cha-shu-de-ceng-ci-bian-li-iijian-dan">
        </link>
        <updated>2019-11-21T01:22:33.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）<br>
例如：<br>
给定二叉树 [3,9,20,null,null,15,7],<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7<br>
返回其自底向上的层次遍历为：<br>
[<br>
[15,7],<br>
[9,20],<br>
[3]<br>
]<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>本题的难点在于平常的层次遍历从上往下的话可以直接用vector的push_back，从下往上遍历看起来很简单，但是vector没有push_front，并且在头部插入需要整体复制移动，代价非常大<br>
所以思考了一下，决定用双边容器的deque来代替vector，最后再用迭代器范围来初始化vector<br>
<code>vector&lt;vector&lt;int&gt;&gt; res(dvi.begin(),dvi.end());</code><br>
最终代码如下：</p>
<pre><code>class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) {
        deque&lt;vector&lt;int&gt;&gt; dvi;
        preorder(root,0,dvi);
        vector&lt;vector&lt;int&gt;&gt; res(dvi.begin(),dvi.end());
        return res;
    }
    
    void preorder(TreeNode* cur,int i,deque&lt;vector&lt;int&gt;&gt; &amp;res){
        if(cur==NULL)
            return;
        if(res.size()==i)
            res.push_front(vector&lt;int&gt;());
        res[res.size()-i-1].push_back(cur-&gt;val);
        preorder(cur-&gt;left,i+1,res);
        preorder(cur-&gt;right,i+1,res);
        return;
    }
};
</code></pre>
<p>做题中出现的问题有：<br>
一开始傻了，忘了是在头部插入，继续用了<code>res[i].push_back(cur-&gt;val);</code>，结果导致输出<code>[[],[],[3,9,20,15,7]]</code><br>
然后是<code>res[res.size()-i-1]</code>，而不是<code>res[res.size()-i]</code>，因为此时size增加了1</p>
<p>结果毫无疑问地牺牲了空间复杂度来换了时间复杂度</p>
<p>然后来看一下网友题解吧<br>
大部分都是reverse，这就很没意思了<br>
所以贴个最高赞的队列迭代吧，和递归相对应</p>
<pre><code>class Solution:
    def levelOrderBottom(self, root):
        queue = []                                                  # 结果列表
        cur = [root]                                                # 接下来要循环的当前层节点，存的是节点
        while cur:                                                  # 当前层存在结点时
            cur_layer_val = []                                      # 初始化当前层结果列表为空，存的是val
            next_layer_node = []                                    # 初始化下一层结点列表为空
            for node in cur:                                        # 遍历当前层的每一个结点
                if node:                                            # 如果该结点不为空，则进行记录
                    cur_layer_val.append(node.val)                  # 将该结点的值加入当前层结果列表的末尾
                    next_layer_node.extend([node.left, node.right]) # 将该结点的左右孩子结点加入到下一层结点列表
            if cur_layer_val:                                       # 只要当前层结果列表不为空
                queue.insert(0, cur_layer_val)                      # 则把当前层结果列表插入到队列首端
            cur = next_layer_node                                   # 下一层的结点变成当前层，接着循环
        return queue      
</code></pre>
<p>这个妹纸本来的注释还挺好看的，到了这里全乱了。。。建议直接看原题<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/solution/python3-dui-lie-shi-xian-by-yi-xi-4/">妹纸的队列迭代题解</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[需要复习的点]]></title>
        <id>https://lixin-ee.github.io//post/xu-yao-fu-xi-de-dian</id>
        <link href="https://lixin-ee.github.io//post/xu-yao-fu-xi-de-dian">
        </link>
        <updated>2019-11-20T11:26:03.000Z</updated>
        <content type="html"><![CDATA[<p>LeetCode<br>
树的题目的迭代解法</p>
<p>C++PRIMER<br>
15.9章 类的设计思路代码</p>
<p>16.1.5 27题 类模板的实例化问题</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 337. 打家劫舍 III[中等]]]></title>
        <id>https://lixin-ee.github.io//post/shu-337-da-jia-jie-she-iiizhong-deng</id>
        <link href="https://lixin-ee.github.io//post/shu-337-da-jia-jie-she-iiizhong-deng">
        </link>
        <updated>2019-11-20T02:04:50.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。<br>
计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。<br>
示例 1:<br>
输入: [3,2,3,null,3,null,1]<br>
3<br>
/ <br>
2   3<br>
\   \<br>
3   1<br>
输出: 7<br>
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.<br>
示例 2:<br>
输入: [3,4,5,1,3,null,1]<br>
     3<br>
/ <br>
4   5<br>
/ \   \<br>
1   3   1<br>
输出: 9<br>
解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/house-robber-iii<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>最终代码：</p>
<pre><code>class Solution {
public:
    int rob(TreeNode* root) {
        auto res=preorder(root);
        return max(res[0],res[1]);
    }
    
    vector&lt;int&gt; preorder(TreeNode* cur){
        vector&lt;int&gt; vi;
        if(cur==NULL){
            vi.push_back(0);
            vi.push_back(0);
            return vi;}
        auto vl=preorder(cur-&gt;left);
        auto vr=preorder(cur-&gt;right);
        vi.push_back(max(vl[0]+vr[0],max(vl[1]+vr[1],max(vl[1]+vr[0],vl[0]+vr[1]))));
        vi.push_back(cur-&gt;val+vl[0]+vr[0]);
        return vi;     
    } 
};
</code></pre>
<p>这道题还是蛮波折的，一开始我希望用普通的方法解决，比如说层次遍历后只取间隔层的所有节点的和，但是后来想想是不行的<br>
比如<code>[[1],[10,1],[1,1,1,10]]</code>这种情况，很明显应该牺牲头节点各取第二层和第三层的10<br>
所以动态规划在所难免了，这道题似乎和之前的股票问题比较像，0代表不偷，1 代表偷，但是只有冻结期限制而没有买入卖出等<br>
一开始想着从根节点出发，但是发现问题是同一层里值无法共享，所以必须从叶节点出发<br>
对于普通的具有两个子节点的节点来说，它取0的情况比较多，主要有<code>[（左0，右0）（左1，右0）（左0，右1）（左1，右1）]</code>，而我们只需要取这四者的最大值就好，取1的话就比较简单了，两个子树都不能偷，必须左1右1，然后再加上当前val返回就好<br>
我在取0的时候一开始不小心忘了左0右0，结果导致测试用例结果只差了1，差点百思不得其解<br>
然后看了题解后发现取0的情况完全可以简化为<code>max（（左0，左1），（右0，右1））</code><br>
哈哈哈不过第一次独立做出动态规划题还是非常高兴的啊！（虽然拖了两天hhhh</p>
<p>然后来看一下网友题解（当时非常激动，发现和网友题解思路一致）</p>
<blockquote>
<p>用一个int[]分别记录包含根节点和不包含根节点时的最大值</p>
</blockquote>
<pre><code>class Solution {
    public int rob(TreeNode root) {
        int[] res = doRob(root);
        return Math.max(res[0],res[1]);
    }
    //res[0]为不包括根节点的最大值，res[1]为包括根节点的最大值
    private int[] doRob(TreeNode root){
        int[] res = new int[2];
        if(root == null)
            return res;
        int[] left = doRob(root.left);
        int[] right = doRob(root.right);
        //不包含根节点，最大值为两个子树的最大值之和
        res[0] = Math.max(left[0],left[1])+Math.max(right[0],right[1]);
        //包含根节点，最大值为两个子树不包含根节点的最大值加上根节点的值
        res[1] = left[0] + right[0] + root.val;
        return res;
    }
}
</code></pre>
<p>另外一个说得比较详细的</p>
<blockquote>
<p>可以回顾一下初级版的LeetCode198：打家劫舍，这是一道一维dp，状态转移方程也很简单：<br>
dp[i] = Math.max(dp[i - 2] + nums[cur], dp[i - 1]);<br>
当前偷窃的最大金额可能有两种来源情况，要么偷了这家，上一家没偷；要么偷了上一家，这家没偷。因此每一个结点的dp值和前两个结点的dp值有关。<br>
这道升级版的树状动态规划问题也可以由一维的dp延伸来，只是情况稍微复杂一些，每一个节点的dp值与三层二叉树的结点dp值相关。对于下图所示的一棵三层满二叉树来说：</p>
<pre><code>  1
/   \
</code></pre>
<p>2     3<br>
/ \   / \<br>
4   5 6   7<br>
在每个结点的金额非负的情况下，且要保证取值结点不相邻，只可能有四种最大的取值方式：</p>
<ol>
<li>结点2 + 结点3</li>
<li>结点1 + 结点4 + 结点5 + 结点6 + 结点7</li>
<li>结点2 + 结点6 + 结点7</li>
<li>结点3 + 结点4 + 结点5<br>
那么我们可以自底向上递归进行这个dp运算，令dp[i]代表以i结点为根节点的子树的最大偷窃金额值，计算结束后将dp值直接保存在i结点的val值当中返回。可以推出状态转移方程为：</li>
</ol>
<p>dp[root] = Max(dp[l]+dp[r], root.val+dp[ll]+dp[lr]+dp[rr]+dp[rl], dp[l]+dp[rl]+dp[rr], dp[r]+dp[lr]+dp[ll]);<br>
分别对应上述四种情况。而观察发现，在dp[l]和dp[r]的计算中实际已经包含了dp[ll]、dp[lr]、dp[rr]、dp[rl]的取舍情况，因此可以简化为前两种情况。状态转移方程简化为：</p>
<p>dp[root] = Max(dp[l]+dp[r], root.val+dp[ll]+dp[lr]+dp[rr]+dp[rl]);<br>
为了方便运算，我们一般会为dp数组赋予初值。在树状dp中同样，我们需要将每一个非叶结点作为根节点的子树构造成一棵三层满二叉树方便运算。</p>
<p>对于叶子结点，我们给其添加值为0的左右子结点。</p>
<p>对于左/右子树为空的非叶节点，我们在其左/右添加一棵两层值为0的满二叉树。</p>
</blockquote>
<pre><code>class Solution {
    public int rob(TreeNode root) {
        return Solution(root).val;
    }

    public TreeNode Solution(TreeNode root){
        if(root == null){
            TreeNode newNode = new TreeNode(0);
            return Solution(newNode);
        }
        if(root.left == null &amp;&amp; root.right == null){
            root.left = new TreeNode(0);
            root.right = new TreeNode(0);
            return root;
        }

        root.left = Solution(root.left);
        root.right = Solution(root.right);
        root.val = Math.max(root.left.val + root.right.val, root.val + root.left.left.val + root.left.right.val + root.right.left.val + root.right.right.val);

        return root;
    }
}
</code></pre>
<p>hhh第一次自己完成动态规划问题还是挺激动的</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 124. 二叉树中的最大路径和[困难]]]></title>
        <id>https://lixin-ee.github.io//post/shu-124-er-cha-shu-zhong-de-zui-da-lu-jing-he</id>
        <link href="https://lixin-ee.github.io//post/shu-124-er-cha-shu-zhong-de-zui-da-lu-jing-he">
        </link>
        <updated>2019-11-19T01:37:25.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个非空二叉树，返回其最大路径和。<br>
本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。<br>
示例 1:<br>
输入: [1,2,3]<br>
1<br>
/ <br>
2   3<br>
输出: 6<br>
示例 2:<br>
输入: [-10,9,20,null,null,15,7]<br>
   -10<br>
   / <br>
  9  20<br>
    /  <br>
   15   7<br>
输出: 42<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/binary-tree-maximum-path-sum<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题的难点在于可以从树中的任意节点出发<br>
所以从根节点出发是不太可能的了<br>
我思考了一下，发现可以从叶节点出发。可以先记录一个全局int，然后对于一个普通节点来说，无非四种结果，首先获得左右子节点返回的节点，然后将自身节点相加，然后最最重要的就是【左+右+自身】和【自身】，前者等于将左右节点和自身连接起来形成一条路径，后者等于防止某个节点值特别大的情况，取这四种情况的最大值更新res（只需要res不需要记录特定路径，同时取最大值保证只有一条路径），然后为什么不用将左右子树算入呢，因为递归过程中他们本身也会进行这个判断。<br>
然后记得把res设置为INT_MAX<br>
最终代码如下：</p>
<pre><code>class Solution {
    int res=INT_MIN;
public:
    int maxPathSum(TreeNode* root) {
        preorder(root);
        return res;
    }
    
    int preorder(TreeNode* cur){
        if(cur==NULL)
            return 0;
        int left=preorder(cur-&gt;left);
        int right=preorder(cur-&gt;right);
        res= res&gt;(cur-&gt;val+left+right)?res:(cur-&gt;val+left+right);
        left=left+cur-&gt;val;
        right=right+cur-&gt;val;
        int ret= max(left,right);
        ret= max(ret,cur-&gt;val);
        res= res&gt;ret?res:ret;
        return ret;
        
    }
};
</code></pre>
<p>然后来看一下网友题解：</p>
<blockquote>
<p>解题思路：<br>
二叉树 abc，a 是根结点（递归中的 root），bc 是左右子结点（代表其递归后的最优解）。<br>
最大的路径，可能的路径情况：</p>
<pre><code>a
</code></pre>
<p>/ <br>
b   c<br>
b + a + c。<br>
b + a + a 的父结点。<br>
a + c + a 的父结点。<br>
其中情况 1，表示如果不联络父结点的情况，或本身是根结点的情况。<br>
这种情况是没法递归的，但是结果有可能是全局最大路径和。<br>
情况 2 和 3，递归时计算 a+b 和 a+c，选择一个更优的方案返回，也就是上面说的递归后的最优解啦。</p>
<p>另外结点有可能是负值，最大和肯定就要想办法舍弃负值（max(0, x)）（max(0,x)）。<br>
但是上面 3 种情况，无论哪种，a 作为联络点，都不能够舍弃。</p>
<p>代码中使用 val 来记录全局最大路径和。<br>
ret 是情况 2 和 3。<br>
lmr 是情况 1。</p>
<p>所要做的就是递归，递归时记录好全局最大和，返回联络最大和。</p>
<p>代码：<br>
C++</p>
</blockquote>
<pre><code>int maxPathSum(TreeNode* root, int &amp;val)
{
	if (root == nullptr) return 0;
	int left = maxPathSum(root-&gt;left, val);
	int right = maxPathSum(root-&gt;right, val);
	int lmr = root-&gt;val + max(0, left) + max(0, right);
	int ret = root-&gt;val + max(0, max(left, right));
	val = max(val, max(lmr, ret));
	return ret;
}

int maxPathSum(TreeNode* root) 
{
	int val = INT_MIN;
	maxPathSum(root, val);
	return val;
}
</code></pre>
<p>网友的思路比我更清晰一点，利用max(0, left) + max(0, right)其实就包含了判断自身的情况。然后评论中指出可以改进的点是lmr肯定是大于ret的</p>
]]></content>
    </entry>
</feed>