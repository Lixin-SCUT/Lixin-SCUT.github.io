<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-12-09T00:41:22.434Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[图 310. 最小高度树[中等][未做出][待阅读]]]></title>
        <id>https://lixin-ee.github.io//post/tu-310-zui-xiao-gao-du-shu-zhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/tu-310-zui-xiao-gao-du-shu-zhong-deng-wei-zuo-chu">
        </link>
        <updated>2019-12-08T23:56:58.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>对于一个具有树特征的无向图，我们可选择任何一个节点作为根。图因此可以成为树，在所有可能的树中，具有最小高度的树被称为最小高度树。给出这样的一个图，写出一个函数找到所有的最小高度树并返回他们的根节点。</p>
<p>格式<br>
该图包含 n 个节点，标记为 0 到 n - 1。给定数字 n 和一个无向边 edges 列表（每一个边都是一对标签）。<br>
你可以假设没有重复的边会出现在 edges 中。由于所有的边都是无向边， [0, 1]和 [1, 0] 是相同的，因此不会同时出现在 edges 里。</p>
<p>示例 1:<br>
输入: n = 4, edges = [[1, 0], [1, 2], [1, 3]]<br>
0<br>
|<br>
1<br>
/ <br>
2   3<br>
输出: [1]<br>
示例 2:</p>
<p>输入: n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]<br>
0  1  2<br>
\ | /<br>
3<br>
|<br>
4<br>
|<br>
5<br>
输出: [3, 4]</p>
<p>说明:<br>
 根据树的定义，树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。<br>
树的高度是指根节点和叶子节点之间最长向下路径上边的数量。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/minimum-height-trees<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>本来想着说建立一个图的邻接矩阵，然后通过判断矩阵每一行的最大值来得到结果<br>
但是比较麻烦的是如何去判断非邻接节点的距离<br>
发现完全可以化为最短路径的问题去完成 使用floyd构建邻接矩阵来完成<br>
结果floyd超时了？？？</p>
<p>然后来看一下网友题解吧</p>
<blockquote>
<p>广度优先搜索<br>
解题思路 :题目给定的是一个无向简单图，要求找出最高树的节点，首先通过分析可以知道，最后的根节点只可能为1个或者2个。<br>
要求最小高度的根节点，我们反过来想，怎样才能求得最小高度呢，很容易想到从叶子节点开始往根找，<br>
于是就是采用分层剥削的方法，每次去除一层叶子节点，这样保证最后的节点就是我们所要的。</p>
</blockquote>
<pre><code>class Solution {
public:
    vector&lt;int&gt; findMinHeightTrees(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) 
    {
        vector&lt;int&gt; ans;[[[]()]()]()
        vector&lt;int&gt; degree; //各个节点的度
        vector&lt; vector&lt;int&gt; &gt; Graph(n,vector&lt;int&gt;());  //重新定义图的结构
        queue&lt;int&gt; Q; //叶子节点队列
        
        //初始化度队列
        for(int i=0;i&lt;n;i++)
            degree.push_back(0); 
        
        //把边里面的数组转化为邻接表
        for(auto e : edges)
        {
            Graph[e[0]].push_back(e[1]);
            Graph[e[1]].push_back(e[0]);
            degree[e[0]]++;
            degree[e[1]]++;
        }
        
        //一度节点入队列
        for(int i=0;i&lt;n;i++)
            if(degree[i] == 1)
                Q.push(i);
        
        int rst = n;
        //一个节点时要单独拿出来考虑
        if(rst == 1)
            ans.push_back(0);
</code></pre>
<p>另外一个比较厉害的网友的题解，思路是一致的，就是越靠近中间的1~2个节点才是我们需要的节点，也可以转化为计算出入度（这里不是有向图，所以节点的度不需要区分出度入度）</p>
<blockquote>
<p>贪心法：根据拓扑排序的思路（Java 代码）<br>
思路分析：<br>
这道题一开始给我的感觉特别像拓扑排序，做下来，感觉它们的本质是一样的，更深层次的思想是贪心算法。<br>
直觉上，一棵树越靠“外面”的结点，我们越不可能把它作为根结点，如果这样做的话，可能树的高度是很高的<br>
因此，我们使用“剔除边缘结点”的策略，这里的边缘结点就是指连接其它结点最少的结点，用专业的名词来说，就是指向它的结点最少的结点，“入度”最少的结点<br>
我们能归纳出，结点最后只会剩下 1 个或者 2 个。<br>
综上所述，总结一下我们的算法：每次总是删除“入度”个数最少的结点，因为树是无向无环图，删除了它们以后，与之相连的结点的入度也相应地减少 1，直到最后剩下 1 个结点或者 2 个结点。<br>
在编码的时候，我借鉴了“拓扑排序”的代码，使用了“邻接表”表示图，使用了“入度数组”，还使用了队列保存了下一轮要“剔除”的结点编号。关于拓扑排序的知识和代码实现，可以参考「力扣」第 207 题：课程表 和「力扣」第 210 题：课程表 II。</p>
</blockquote>
<pre><code>public class Solution {
    public List&lt;Integer&gt; findMinHeightTrees(int n, int[][] edges) {
        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
        // 特判
        if (n &lt;= 2) {
            for (int i = 0; i &lt; n; i++) {
                res.add(i);
            }
            return res;
        }

        // 入度数组，每一次要把入度为 1 的结点剔除
        int[] inDegrees = new int[n];

        // 默认为 False，如果剔除，设置为 True
        boolean[] result = new boolean[n];

        // 因为是无向图，所以邻接表拿出一条边，两个结点都要存一下
        // 注意：右边就不要写具体的实现类了，等到实例化的时候再写具体的实现类
        Set&lt;Integer&gt;[] adjs = new Set[n];
        // 初始化
        for (int i = 0; i &lt; n; i++) {
            adjs[i] = new HashSet&lt;&gt;();
        }

        for (int[] edge : edges) {
            int start = edge[0];
            int end = edge[1];
            adjs[start].add(end);
            adjs[end].add(start);
            inDegrees[start] += 1;
            inDegrees[end] += 1;
        }
        LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;();

        // 入度为 1 的结点入队
        for (int i = 0; i &lt; n; i++) {
            if (inDegrees[i] == 1) {
                queue.addLast(i);
            }
        }

        // 注意边界条件 n == 2 和 n == 1 是如何分析出来的
        while (n &gt; 2) {
            int size = queue.size();
            System.out.println(queue);
            // 一次减去这么多
            n -= size;
            for (int i = 0; i &lt; size; i++) {
                int top = queue.removeFirst();
                result[top] = true;
                inDegrees[top] -= 1;
                // 把它和它的邻接结点的入度全部减 1
                Set&lt;Integer&gt; successors = adjs[top];
                for (Integer successor : successors) {
                    inDegrees[successor] -= 1;
                    if (inDegrees[successor] == 1) {
                        queue.addLast(successor);
                    }
                }
            }
        }
        n = result.length;
        for (int i = 0; i &lt; n; i++) {
            if (!result[i]) {
                res.add(i);
            }
        }
        return res;
    }
		
    public static void main(String[] args) {
        int[][] edges = new int[][]{{1, 0}, {1, 2}, {1, 3}};
        int n = 4;
        Solution solution = new Solution();
        List&lt;Integer&gt; res = solution.findMinHeightTrees(n, edges);
        System.out.println(res);
    }
}
</code></pre>
<p>看完题解发现其实我是知道BFS和DFS或者最小生成树的，只是没有想深一步去到刨除叶子节点这一步，最近做题经常是面向测试用例编程，很少去挖掘通用规律了，这一点还是有待改进的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图 399. 除法求值[中等][未做出][待阅读]]]></title>
        <id>https://lixin-ee.github.io//post/tu-399-chu-fa-qiu-zhi-zhong-deng-wei-zuo-chu-dai-yue-du</id>
        <link href="https://lixin-ee.github.io//post/tu-399-chu-fa-qiu-zhi-zhong-deng-wei-zuo-chu-dai-yue-du">
        </link>
        <updated>2019-12-08T02:16:18.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给出方程式 A / B = k, 其中 A 和 B 均为代表字符串的变量， k 是一个浮点型数字。根据已知方程式求解问题，并返回计算结果。如果结果不存在，则返回 -1.0。<br>
示例 :<br>
给定 a / b = 2.0, b / c = 3.0<br>
问题: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? <br>
返回 [6.0, 0.5, -1.0, 1.0, -1.0 ]<br>
输入为: vector&lt;pair&lt;string, string&gt;&gt; equations, vector&lt; double&gt;&amp; values,vector&lt;pair&lt;string, string&gt;&gt; queries(方程式，方程式结果，问题方程式)， 其中 equations.size() == values.size()，即方程式的长度与方程式结果长度相等（程式与结果一一对应），并且结果值均为正数。以上为方程式的描述。 返回vector&lt; double&gt;类型。<br>
基于上述例子，输入如下：<br>
equations(方程式) = [ [&quot;a&quot;, &quot;b&quot;], [&quot;b&quot;, &quot;c&quot;] ],<br>
values(方程式结果) = [2.0, 3.0],<br>
queries(问题方程式) = [ [&quot;a&quot;, &quot;c&quot;], [&quot;b&quot;, &quot;a&quot;], [&quot;a&quot;, &quot;e&quot;], [&quot;a&quot;, &quot;a&quot;], [&quot;x&quot;, &quot;x&quot;] ].<br>
输入总是有效的。你可以假设除法运算中不会出现除数为0的情况，且不存在任何矛盾的结果。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/evaluate-division<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>//在310用floyd翻车了就回来这边用了<br>
//本题目可以视为 建立图-搜索两点之间的最短路径 的问题<br>
//在大话数据结构的两种方法里面，最适合这道题的无疑是floyd<br>
//另一种算法：迪杰斯特拉（Dijkstra)算法：按路径长度递增的次序产生最短路径的算法，基于已经求出的最短路径的基础上一步步求出它们之间顶点的最短路径，适用于某个源点到其余各顶点的最 短路径问题<br>
//floyd就等于动态规划，一共有三层规划 k代表中转顶点的下标 v是起始顶点 w代表结束顶点，等于对于每两个点之间都以某个点来做中转，然后只取最短点（其实就是（Dijkstra)算法的循环版）<br>
//对于本题目来说，需要注意的点有：1.需要用map建立string和int下标的映射<br>
//2.对对称点使用倒数来初始化<br>
//3.循环计算时的判断式<code>if(graph[v][w]==-1.0&amp;&amp;graph[v][k]!=-1.0&amp;&amp;graph[k][w]!=-1.0)</code><br>
//4.最后利用map进行判断节点是否存在<code>if(trans.count(queries[i][0])&amp;&amp;trans.count(queries[i][1]))</code></p>
<pre><code>class Solution {
public:
    vector&lt;double&gt; calcEquation(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;double&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries) {
        map&lt;string,int&gt; trans;
        int n=0;
        for(int i=0;i&lt;equations.size();++i){
            if(!trans.count(equations[i][0]))
               trans.insert({equations[i][0],n++});
             if(!trans.count(equations[i][1]))
               trans.insert({equations[i][1],n++});
        }
        vector&lt;vector&lt;double&gt;&gt; graph(n,vector(n,-1.0));
        for(int i=0;i&lt;n;++i)
            graph[i][i]=1.0;
       for(int i=0;i&lt;equations.size();++i){
           int row=trans[equations[i][0]];
           int col=trans[equations[i][1]];
           graph[row][col]=values[i];
           graph[col][row]=1/values[i];               
       } 
     build(graph);  
     vector&lt;double&gt; res;
    for(int i=0;i&lt;queries.size();++i){
        if(trans.count(queries[i][0])&amp;&amp;trans.count(queries[i][1])){
            int row=trans[queries[i][0]];
            int col=trans[queries[i][1]];
            res.push_back(graph[row][col]);
        }
        else
            res.push_back(-1.0);
                 }
                return res;
    }
    
    void build(vector&lt;vector&lt;double&gt;&gt;&amp; graph){       
        int n=graph.size();
        for(int k=0;k&lt;n;++k)
            for(int v=0;v&lt;n;++v)
                for(int w=0;w&lt;n;++w)
                    if(graph[v][w]==-1.0&amp;&amp;graph[v][k]!=-1.0&amp;&amp;graph[k][w]!=-1.0)
                        graph[v][w]=graph[v][k]*graph[k][w],graph[w][v]=1/graph[v][w];
    }
};
</code></pre>
<p>然后惯例来看一下网友题解，有一位网友总结了三种解法，而且用的是C++，感动<br>
方法一：Floyd</p>
<pre><code>struct Value {
    int status;
    double val;
    Value(): status(0), val(0) {}
    Value(int s, double v) : status(s), val(v) {}
};

class Solution {
public:
    vector&lt;double&gt; calcEquation(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;double&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries) {      
        unordered_map&lt;string, int&gt; store;
        int n = 0;
        for (auto e : equations) {
            if (store.find(e[0]) == store.end())
                store[e[0]] = n++;
            if (store.find(e[1]) == store.end())
                store[e[1]] = n++;
        }

        vector&lt;vector&lt;Value&gt;&gt; graph(n, vector&lt;Value&gt;(n, Value()));
        for (int i = 0; i &lt; equations.size(); ++i) {
            int ia = store[equations[i][0]];
            int ib = store[equations[i][1]];
            graph[ia][ib] = Value(1, values[i]);
            graph[ib][ia] = Value(1, 1/values[i]);
        }
        
        for (int k = 0; k &lt; n; ++k) {
            for (int i = 0; i &lt; n; ++i) {
                for (int j = 0; j &lt; n; ++j) {
                    if (graph[i][j].status == 0 &amp;&amp; graph[i][k].status == 1 &amp;&amp; graph[k][j].status == 1) {
                        graph[i][j] = Value(1, graph[i][k].val * graph[k][j].val);
                    }
                }
            }
        }
        
        vector&lt;double&gt; res;
        for (auto q : queries) {
            if (store.find(q[0]) == store.end() || store.find(q[1]) == store.end()) {
                res.push_back(-1);
                continue;
            } 
            int ia = store[q[0]];
            int ib = store[q[1]];
            double r = graph[ia][ib].status == 1 ? graph[ia][ib].val : -1;
            res. push_back(r);
        }
        return res;
    }
};
</code></pre>
<p>方法二：dfs 和 bfs<br>
主要分为两步：<br>
1.build 构造初始化图<br>
2.dfs 或者 bfs 进行遍历</p>
<pre><code>class Solution {
public:
    vector&lt;double&gt; calcEquation(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;double&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries) {
        auto graph = build(equations, values);
           
        vector&lt;double&gt; res;  
        for (auto q : queries) {
            set&lt;string&gt; visited;
            bool found = false;
            //double r = bfs(graph, visited, q[0], q[1], found);
            double r = dfs(graph, visited, q[0], q[1], found);
            if (found) {
                res.push_back(r);
                graph[q[0]][q[1]] = r;
                graph[q[1]][q[0]] = 1 / r;
            } else {
                res.push_back(-1);
            }
        }
      
        return res;
    }

    unordered_map&lt;string, unordered_map&lt;string, double&gt;&gt; build(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;double&gt;&amp; values) {
        unordered_map&lt;string, unordered_map&lt;string, double&gt;&gt; m;
        for (int i = 0; i &lt; equations.size(); ++i) {
            vector&lt;string&gt; eqa = equations[i];
            string a = eqa[0];
            string b = eqa[1];
            double v = values[i];
            if (m.find(a) == m.end()) {
                m[a] = unordered_map&lt;string, double&gt;{{b, v}};
            } else {
                m[a][b] = v;
            }
            if (m.find(b) == m.end()) {
                m[b] = unordered_map&lt;string, double&gt;{{a, 1 /v}};
            } else {
                m[b][a] = 1 / v;
            }
        }
        return m;
    }

    double bfs(unordered_map&lt;string, unordered_map&lt;string, double&gt;&gt;&amp; g, set&lt;string&gt; visited, string begin, string end, bool&amp; found) {
        if (g.find(begin) == g.end() || g.find(end) == g.end()) {
            found = false;
            return -1;
        }
        queue&lt;pair&lt;string, double&gt;&gt; q;
        q.push(make_pair(begin, 1));
        while (!q.empty()) {
            auto cur = q.front();
            q.pop();
            if (visited.find(cur.first) != visited.end()) {
                continue;
            }
            if (cur.first == end) {
                found = true;
                return cur.second;
            }
            visited.insert(cur.first);
            for (auto it : g[cur.first]) {
                q.push(make_pair(it.first, cur.second * it.second));
            }
        }
        found = false;
        return -1;
    }
  
    double dfs(unordered_map&lt;string, unordered_map&lt;string, double&gt;&gt;&amp; g, set&lt;string&gt; visited, string begin, string end, bool&amp; found) {
        if (g.find(begin) == g.end() || g.find(end) == g.end()) {
            found = false;
            return -1;
        }
        if (visited.find(begin) != visited.end()) {
            found = false;
            return -1;
        }
        if (g[begin].find(end) != g[begin].end()) {
            found = true;
            return g[begin][end];
        }
        visited.insert(begin);
        for (auto it : g[begin]) {
            double r = dfs(g, visited, it.first, end, found);
            if (found) {
                double res = r * it.second;
                return res;
            }
        }
        visited.erase(begin);
        found = false;
        return -1;
    }
};
</code></pre>
<p>方法三：并查集</p>
<pre><code>struct Node {
    double value;
    Node* parent;
    Node() : parent(this) {}
    Node(double v) : value(v), parent(this) {}
};

class Solution {
    unordered_map&lt;string, Node*&gt; m;

    Node* find(Node* n) {
        if (n-&gt;parent != n) {
            n-&gt;parent = find(n-&gt;parent);
        }
        return n-&gt;parent;
    }
   
    void merge(Node* n1, Node* n2, double val) {
        Node* p1 = find(n1);
        Node* p2 = find(n2);
        double ratio = n2-&gt;value * val / n1-&gt;value;
        for (auto it : m) {
            if (find(it.second) == p1) {
                it.second-&gt;value *= ratio;
            }
        } 
        p1-&gt;parent = p2;
    }
public:
    vector&lt;double&gt; calcEquation(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;double&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries) {
        for (int i = 0; i &lt; equations.size(); ++i) {
            string a = equations[i][0];
            string b = equations[i][1];
            if (m.find(a) == m.end()) m[a] = new Node(values[i]);
            if (m.find(b) == m.end()) m[b] = new Node(1.0);
            merge(m[a], m[b], values[i]);
        }
        vector&lt;double&gt; res;
        for (auto q : queries) {
            if (m.find(q[0]) == m.end() || m.find(q[1]) == m.end() || find(m[q[0]]) != find(m[q[1]])) {
                res.push_back(-1);
            } else {
                res.push_back(m[q[0]]-&gt;value / m[q[1]]-&gt;value);
            }
        }
        return res;
    }
};
</code></pre>
<p>DFS和BFS 以及并查集值得好好阅读一下。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图 133. 克隆图[中等]]]></title>
        <id>https://lixin-ee.github.io//post/tu-133-ke-long-tu-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/tu-133-ke-long-tu-zhong-deng">
        </link>
        <updated>2019-12-07T00:47:09.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定无向连通图中一个节点的引用，返回该图的深拷贝（克隆）。图中的每个节点都包含它的值 val（Int） 和其邻居的列表（list[Node]）。<br>
示例：</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1575679961753.png" alt=""></p>
<blockquote>
<p>输入：<br>
{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: …&quot;neighbors&quot;:[{&quot;'>id&quot;:&quot;1&quot;,&quot;neighbors&quot;:[{&quot;</span>id&quot;:&quot;2&quot;,&quot;neighbors&quot;:[{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 9: ref&quot;:&quot;1&quot;}̲,{&quot;'>ref&quot;:&quot;1&quot;},{&quot;</span>id&quot;:&quot;3&quot;,&quot;neighbors&quot;:[{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 9: ref&quot;:&quot;2&quot;}̲,{&quot;'>ref&quot;:&quot;2&quot;},{&quot;</span>id&quot;:&quot;4&quot;,&quot;neighbors&quot;:[{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 9: ref&quot;:&quot;3&quot;}̲,{&quot;'>ref&quot;:&quot;3&quot;},{&quot;</span>ref&quot;:&quot;1&quot;}],&quot;val&quot;:4}],&quot;val&quot;:3}],&quot;val&quot;:2},{&quot;$ref&quot;:&quot;4&quot;}],&quot;val&quot;:1}<br>
解释：<br>
节点 1 的值是 1，它有两个邻居：节点 2 和 4 。<br>
节点 2 的值是 2，它有两个邻居：节点 1 和 3 。<br>
节点 3 的值是 3，它有两个邻居：节点 2 和 4 。<br>
节点 4 的值是 4，它有两个邻居：节点 1 和 3 。<br>
提示：<br>
节点数介于 1 到 100 之间。<br>
无向图是一个简单图，这意味着图中没有重复的边，也没有自环。<br>
由于图是无向的，如果节点 p 是节点 q 的邻居，那么节点 q 也必须是节点 p 的邻居。<br>
必须将给定节点的拷贝作为对克隆图的引用返回。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/clone-graph<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>//一开始就感觉这个其实是一个遍历题，主要是保证每个节点仅被遍历一次否则会new出重复的节点，看了大话数据结构的源代码后，发现缺少一个记录已访问节点的结构，就使用map代替了<br>
//map就保存一对结点，一个旧结点对应一个新节点<br>
//然后主要流程就是构造新节点-利用map判断是否已存在-存在则连接-不存在则递归调用<br>
//最后空间复杂度爆炸，但是时间复杂度还可以<br>
//时间复杂度O(n^2) 假设每个点都相连，则需要两层n循环</p>
<pre><code>/*
// Definition for a Node.
class Node {
public:
    int val;
    vector&lt;Node*&gt; neighbors;

    Node() {}

    Node(int _val, vector&lt;Node*&gt; _neighbors) {
        val = _val;
        neighbors = _neighbors;
    }
};
*/
class Solution {
public:
    map&lt;Node*,Node*&gt; mnn;
    Node* cloneGraph(Node* node) {
        Node *cur=new Node(node-&gt;val,vector&lt;Node*&gt;());
        mnn.insert({node,cur});
        for(auto i:node-&gt;neighbors){
            if(mnn.count(i))
                cur-&gt;neighbors.push_back(mnn[i]);
            else{       
               auto next=cloneGraph(i); 
                cur-&gt;neighbors.push_back(next);
            }
        }
        return cur;
    }
};
</code></pre>
<p>然后来看看网友题解：</p>
<blockquote>
<p>解题思路:<br>
这道题就是遍历整个图，所以遍历时候要记录已经访问点，我们用一个字典记录。<br>
所以，遍历方法就有两种。<br>
思路一:DFS (深度遍历)<br>
思路二:BFS (广度遍历)<br>
大家重点掌握，后面图遍历都和这个有关系！<br>
代码:<br>
思路一:</p>
</blockquote>
<pre><code>Java
class Solution {
    public Node cloneGraph(Node node) {
        Map&lt;Node, Node&gt; lookup = new HashMap&lt;&gt;();
        return dfs(node, lookup);
    }

    private Node dfs(Node node, Map&lt;Node,Node&gt; lookup) {
        if (node == null) return null;
        if (lookup.containsKey(node)) return lookup.get(node);
        Node clone = new Node(node.val, new ArrayList&lt;&gt;());
        lookup.put(node, clone);
        for (Node n : node.neighbors)clone.neighbors.add(dfs(n,lookup));
        return clone;
    }
}
</code></pre>
<blockquote>
<p>思路二:</p>
</blockquote>
<pre><code>Java
class Solution {
    public Node cloneGraph(Node node) {
        if (node == null) return null;
        Map&lt;Node, Node&gt; lookup = new HashMap&lt;&gt;();
        Node clone = new Node(node.val, new ArrayList&lt;&gt;());
        lookup.put(node, clone);
        Deque&lt;Node&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(node);
        while (!queue.isEmpty()) {
            Node tmp = queue.poll();
            for (Node n : tmp.neighbors) {
                if (!lookup.containsKey(n)) {
                    lookup.put(n, new Node(n.val, new ArrayList&lt;&gt;()));
                    queue.offer(n);
                }
                lookup.get(tmp).neighbors.add(lookup.get(n));
            }
        }
        return clone;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 96. 不同的二叉搜索树[中等]]]></title>
        <id>https://lixin-ee.github.io//post/shu-96-bu-tong-de-er-cha-sou-suo-shu-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/shu-96-bu-tong-de-er-cha-sou-suo-shu-zhong-deng">
        </link>
        <updated>2019-12-06T01:27:17.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？<br>
示例:<br>
输入: 3<br>
输出: 5<br>
解释:<br>
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:<br>
1         3     3      2      1<br>
\       /     /      / \      <br>
3     2     1      1   3      2<br>
/     /       \                 <br>
2     1         2                 3</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/unique-binary-search-trees<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<pre><code> class Solution {
public:
    
    int numTrees(int n) {
        vector&lt;int&gt; vi(n+1,0);
        vi[0]=1;
        for(int i=1;i&lt;=n;++i){
            int res=0;
            for(int j=1;j&lt;=i;++j){
               res+=vi[j-1]*vi[i-j]; 
            }
            vi[i]=res;
        }
        return vi[n];
    }
};
</code></pre>
<p>//一开始想单纯地找n和树的可能性之间的关系，结果发现不靠谱，因为单纯地在n-1的可能里加上1个值的话会有重复的情况<br>
//然后就想到以根为参考点的方法，就是 1，2，3中，分别考虑根节点为1，2，3的可能，此时就把问题化为两边子树的可能性了<br>
//最后看了题解发现这就是动态规划嘛，从n=1的情况开始推到n=n的情况<br>
//需要注意的是 当子树节点树为0的时候也是视为一种可能性。然后就是vi的长度是n+1，需要额外保存0的情况<br>
//然后就是不能把根结底算进去<br>
非常操蛋的是8ms只击败了12%，题解里面肯定是有很简单的数学方法<br>
//果然是，其实就是把第二个循环变成了通用公式</p>
<p>然后来看一下网友题解：</p>
<blockquote>
<p>思路<br>
标签：动态规划<br>
假设n个节点存在二叉排序树的个数是G(n)，令f(i)为以i为根的二叉搜索树的个数，则<br>
G(n) = f(1) + f(2) + f(3) + f(4) + ... + f(n)<br>
当i为根节点时，其左子树节点个数为i-1个，右子树节点为n-i，则<br>
f(i) = G(i-1)*G(n-i)<br>
综合两个公式可以得到 卡特兰数 公式<br>
G(n) = G(0)<em>G(n-1)+G(1)</em>(n-2)+...+G(n-1)*G(0)<br>
代码</p>
</blockquote>
<pre><code>Java
class Solution {
    public int numTrees(int n) {
        int[] dp = new int[n+1];
        dp[0] = 1;
        dp[1] = 1;
        
        for(int i = 2; i &lt; n + 1; i++)
            for(int j = 1; j &lt; i + 1; j++) 
                dp[i] += dp[j-1] * dp[i-j];
        
        return dp[n];
    }
}
</code></pre>
<p>官方题解：<br>
<img src="https://lixin-ee.github.io//post-images/1575596257408.png" alt=""><br>
复杂度分析<br>
时间复杂度 : O(N)，只有一层循环。<br>
空间复杂度 : O(1)，只需要一个变量来存储中间与最终结果。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 117. 填充每个节点的下一个右侧节点指针 II[中等] ]]></title>
        <id>https://lixin-ee.github.io//post/shu-117-tian-chong-mei-ge-jie-dian-de-xia-yi-ge-you-ce-jie-dian-zhi-zhen-iizhong-deng</id>
        <link href="https://lixin-ee.github.io//post/shu-117-tian-chong-mei-ge-jie-dian-de-xia-yi-ge-you-ce-jie-dian-zhi-zhen-iizhong-deng">
        </link>
        <updated>2019-12-05T01:41:49.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个二叉树<br>
struct Node {<br>
int val;<br>
Node *left;<br>
Node *right;<br>
Node *next;<br>
}<br>
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。<br>
初始状态下，所有 next 指针都被设置为 NULL。<br>
进阶：<br>
你只能使用常量级额外空间。<br>
使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1575510214544.png" alt=""></p>
<blockquote>
<p>输入：root = [1,2,3,4,5,null,7]<br>
输出：[1,#,2,3,#,4,5,7,#]<br>
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。<br>
提示：<br>
树中的节点数小于 6000<br>
-100 &lt;= node.val &lt;= 100<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>因为前一题我用了通用性较高的方法，所以这一题居然直接完成了hhh，然后优雅的用法是没法用了，但是我的方法事件复杂度比较高（603ms还击败50%什么鬼），还是老老实实看一下题解吧<br>
同样地我的解法的问题在于不是常量的空间复杂度</p>
<p>然后来看网友题解：</p>
<blockquote>
<p>队列是为了维护先后关系<br>
但是先后关系本来就存在了next里<br>
所以可以不使用队列<br>
队列做法</p>
</blockquote>
<pre><code>Node* connect(Node* root) {
        if(root == NULL)return root;
        queueq;
        q.push(root);
        while(!q.empty()){
            Node*cur = NULL;
            int size = q.size();
            for(int i = size;i&gt;=0;i--){
                Node *tmp = q.front();q.pop();
                if(cur != NULL){
                    cur-&gt;next = tmp;
                }
                cur = tmp;
                if(tmp-&gt;left)q.push(tmp-&gt;left);
                if(tmp-&gt;right)q.push(tmp-&gt;right);
            }
        }
        return root;
</code></pre>
<blockquote>
<p>使用next来代替队列</p>
</blockquote>
<pre><code>Node* connect(Node* root) {
        Node *last = root;
        while(last != NULL){
            // 获得队首元素
            while(last &amp;&amp; last-&gt;left == NULL &amp;&amp; last-&gt;right == NULL)last = last-&gt;next;
            if(last == NULL)break;
            Node *cur = NULL;
            // 遍历队列
            for(Node *i = last;i != NULL;i = i-&gt;next){
                // 进行push和pop操作
                if(i -&gt; left){
                    if(cur != NULL){
                        cur-&gt;next = i-&gt;left;
                    }
                    cur = i-&gt;left;
                }
                if(i -&gt; right){
                    if(cur != NULL){
                        cur-&gt;next = i-&gt;right;
                    }
                    cur = i-&gt;right;
                }
            }
            // 更新队首
            last = last-&gt;left ? last-&gt;left : last-&gt;right;
        }
        return root;
    }
</code></pre>
<p>比较详细的做法：</p>
<blockquote>
<p>解法一 BFS<br>
直接把 116 题 题的代码复制过来就好，一句也不用改。<br>
利用一个栈将下一层的节点保存。通过pre指针把栈里的元素一个一个接起来。</p>
</blockquote>
<pre><code>public Node connect(Node root) {
    if (root == null) {
        return root;
    }
    Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;();
    queue.offer(root);
    while (!queue.isEmpty()) {
        int size = queue.size();
        Node pre = null;
        for (int i = 0; i &lt; size; i++) {
            Node cur = queue.poll();
            if (i &gt; 0) {
                pre.next = cur;
            }
            pre = cur;
            if (cur.left != null) {
                queue.offer(cur.left);
            }
            if (cur.right != null) {
                queue.offer(cur.right);
            }

        }
    }
    return root;
}
</code></pre>
<blockquote>
<p>解法二<br>
当然题目要求了空间复杂度，可以先到 116 题 看一下思路，这里在上边的基础上改一下。<br>
我们用第二种简洁的代码，相对会好改一些。</p>
</blockquote>
<pre><code>Node connect(Node root) {
    if (root == null)
        return root;
    Node pre = root;
    Node cur = null;
    while (pre.left != null) {
        cur = pre;
        while (cur != null) {
            cur.left.next = cur.right;
            if (cur.next != null) {
                cur.right.next = cur.next.left;
            }
            cur = cur.next;
        }
        pre = pre.left;
    }

    return root;
}
</code></pre>
<blockquote>
<p>需要解决的问题还是挺多的。<br>
cur.left.next = cur.right;<br>
cur.right.next = cur.next.left;<br>
之前的关键代码就是上边两句，但是在这道题中我们无法保证cur.left 或者 cur.right 或者 cur.next.left或者cur.next.right 是否为null。所以我们需要用一个while循环来保证当前节点至少有一个孩子。<br>
while (cur.left == null &amp;&amp; cur.right == null) {<br>
cur = cur.next;<br>
}<br>
这样的话保证了当前节点至少有一个孩子，然后如果一个孩子为 null，那么就可以保证另一个一定不为 null 了。<br>
整体的话，就用了上边介绍的技巧，代码比较长，可以结合的看一下。</p>
</blockquote>
<pre><code>Node connect(Node root) {
    if (root == null)
        return root;
    Node pre = root;
    Node cur = null;
    while (true) {
        cur = pre;
        while (cur != null) {
            //找到至少有一个孩子的节点
            if (cur.left == null &amp;&amp; cur.right == null) {
                cur = cur.next;
                continue;
            }
            //找到当前节点的下一个至少有一个孩子的节点
            Node next = cur.next;
            while (next != null &amp;&amp; next.left == null &amp;&amp; next.right == null) {
                next = next.next;
                if (next == null) {
                    break;
                }
            }
            //当前节点的左右孩子都不为空，就将 left.next 指向 right
            if (cur.left != null &amp;&amp; cur.right != null) {
                cur.left.next = cur.right;
            }
            //要接上 next 的节点的孩子，所以用 temp 处理当前节点 right 为 null 的情况
            Node temp = cur.right == null ? cur.left : cur.right;

            if (next != null) {
                //next 左孩子不为 null，就接上左孩子。
                if (next.left != null) {
                    temp.next = next.left;
                //next 左孩子为 null，就接上右孩子。
                } else {
                    temp.next = next.right;
                }
            }
            
            cur = cur.next;
        }
        //找到拥有孩子的节点
        while (pre.left == null &amp;&amp; pre.right == null) {
            pre = pre.next;
            //都没有孩子说明已经是最后一层了
            if (pre == null) {
                return root;
            }
        }
        //进入下一层
        pre = pre.left != null ? pre.left : pre.right;
    } 
}
</code></pre>
<p>解法三</p>
<blockquote>
<p>利用解法一的思想，我们利用 pre 指针，然后一个一个取节点，把它连起来。解法一为什么没有像解法二那样考虑当前节点为 null 呢？因为我们没有添加为 null 的节点，就是下边的代码的作用。<br>
if (cur.left != null) {<br>
queue.offer(cur.left);<br>
}<br>
if (cur.right != null) {<br>
queue.offer(cur.right);<br>
}<br>
所以这里是一样的，如果当前节点为null不处理就可以了。</p>
</blockquote>
<blockquote>
<p>第二个问题，怎么得到每次的开头的节点呢？我们用一个dummy指针，当连接第一个节点的时候，就将dummy指针指向他。此外，之前用的pre指针，把它当成tail指针可能会更好理解。如下图所示：</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1575511034936.png" alt=""></p>
<blockquote>
<p>cur 指针利用 next 不停的遍历当前层。<br>
如果 cur 的孩子不为 null 就将它接到 tail 后边，然后更新tail。<br>
当 cur 为 null 的时候，再利用 dummy 指针得到新的一层的开始节点。<br>
dummy 指针在链表中经常用到，他只是为了处理头结点的情况，它并不属于当前链表。<br>
代码就异常的简单了。</p>
</blockquote>
<pre><code>Node connect(Node root) {
    Node cur = root;
    while (cur != null) {
        Node dummy = new Node();
        Node tail = dummy;
        //遍历 cur 的当前层
        while (cur != null) {
            if (cur.left != null) {
                tail.next = cur.left;
                tail = tail.next;
            }
            if (cur.right != null) {
                tail.next = cur.right;
                tail = tail.next;
            }
            cur = cur.next;
        }
        //更新 cur 到下一层
        cur = dummy.next;
    }
    return root;
}
</code></pre>
<blockquote>
<p>总<br>
本来为了图方便，在 116 题 的基础上把解法二改了出来，还搞了蛮久，因为为 null 的情况太多了，不停的报空指针异常，最后终于理清了思路。但和解法三比起来实在是相形见绌了，解法三太优雅了，但其实这才是正常的思路，从解法一的做法产生灵感，利用 tail 指针将它们连起来。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 116. 填充每个节点的下一个右侧节点指针[中等]]]></title>
        <id>https://lixin-ee.github.io//post/shu-116-tian-chong-mei-ge-jie-dian-de-xia-yi-ge-you-ce-jie-dian-zhi-zhen-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/shu-116-tian-chong-mei-ge-jie-dian-de-xia-yi-ge-you-ce-jie-dian-zhi-zhen-zhong-deng">
        </link>
        <updated>2019-12-04T01:54:29.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：<br>
struct Node {<br>
int val;<br>
Node *left;<br>
Node *right;<br>
Node *next;<br>
}<br>
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。<br>
初始状态下，所有 next 指针都被设置为 NULL。<br>
示例：</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1575424563194.png" alt=""></p>
<blockquote>
<p>输入：{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: …&quot;:&quot;1&quot;,&quot;left&quot;:{&quot;'>id&quot;:&quot;1&quot;,&quot;left&quot;:{&quot;</span>id&quot;:&quot;2&quot;,&quot;left&quot;:{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 53: …t&quot;:null,&quot;val&quot;:4}̲,&quot;next&quot;:null,&quot;r…'>id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:4},&quot;next&quot;:null,&quot;right&quot;:{&quot;</span>id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:5},&quot;val&quot;:2},&quot;next&quot;:null,&quot;right&quot;:{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: …&quot;:&quot;5&quot;,&quot;left&quot;:{&quot;'>id&quot;:&quot;5&quot;,&quot;left&quot;:{&quot;</span>id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:6},&quot;next&quot;:null,&quot;right&quot;:{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 53: …t&quot;:null,&quot;val&quot;:7}̲,&quot;val&quot;:3},&quot;val&quot;…'>id&quot;:&quot;7&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7},&quot;val&quot;:3},&quot;val&quot;:1}
输出：{&quot;</span>id&quot;:&quot;1&quot;,&quot;left&quot;:{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: …&quot;:&quot;2&quot;,&quot;left&quot;:{&quot;'>id&quot;:&quot;2&quot;,&quot;left&quot;:{&quot;</span>id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: …:null,&quot;next&quot;:{&quot;'>id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:{&quot;</span>id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 53: …t&quot;:null,&quot;val&quot;:7}̲,&quot;right&quot;:null,&quot;…'>id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7},&quot;right&quot;:null,&quot;val&quot;:6},&quot;right&quot;:null,&quot;val&quot;:5},&quot;right&quot;:null,&quot;val&quot;:4},&quot;next&quot;:{&quot;</span>id&quot;:&quot;7&quot;,&quot;left&quot;:{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 9: ref&quot;:&quot;5&quot;}̲,&quot;next&quot;:null,&quot;r…'>ref&quot;:&quot;5&quot;},&quot;next&quot;:null,&quot;right&quot;:{&quot;</span>ref&quot;:&quot;6&quot;},&quot;val&quot;:3},&quot;right&quot;:{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 9: ref&quot;:&quot;4&quot;}̲,&quot;val&quot;:2},&quot;next…'>ref&quot;:&quot;4&quot;},&quot;val&quot;:2},&quot;next&quot;:null,&quot;right&quot;:{&quot;</span>ref&quot;:&quot;7&quot;},&quot;val&quot;:1}<br>
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。 <br>
提示：<br>
你只能使用常量级额外空间。<br>
使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<pre><code>class Solution {
public:
    vector&lt;Node*&gt; vn;
    Node* connect(Node* root) {
        preorder(root,0);
        return root;
    }
    
    void preorder(Node *cur,int i){
        if(cur==NULL)
            return;
        if(vn.size()==i)
            vn.push_back(cur);
        else{
            vn[i]-&gt;next=cur;
            vn[i]=cur;
        }
        preorder(cur-&gt;left,i+1);
        preorder(cur-&gt;right,i+1);
        return;
    }
};
</code></pre>
<p>我一开始只想到了层次遍历，参考层次遍历，利用先序遍历和vector的话可以按照从左到右的顺序来保存层次遍历的结果，由于我们只需要和前一个节点链接，所以这一次只需要一层vector&lt;Node*&gt;就好<br>
然后重点主要是push_back的判断和每个节点和前一个节点链接并更新vector<br>
唯一的缺点就是我这个vector不是常量空间<br>
看了题解，非常优雅啊！直接处理子树的链接和相邻子树的链接，值得学习</p>
<p>看看网友题解</p>
<pre><code>    Node* connect(Node* root) {
        if (!root) return root;
        Node * left = root-&gt;left;
        Node * right = root-&gt;right;
        while(left) {
            left-&gt;next = right;
            left = left-&gt;right;
            right = right-&gt;left;
        }
        connect(root-&gt;left);
        connect(root-&gt;right);
        return root;
    }
</code></pre>
<p>主要就是把完美二叉树劈成两半，先处理大的两半二叉树中间的左右连接，然后递归处理小的连接</p>
<p>非递归方法</p>
<pre><code>Node* connect(Node* root) {
    if (root == nullptr)return nullptr;
	if (root-&gt;left == nullptr) return root; 
    else 
    {
        root-&gt;left-&gt;next = root-&gt;right;
    }
	Node* cur = root-&gt;left-&gt;left;
	Node* pre = root-&gt;left;
	while (cur!=nullptr)
	{
		while (pre!=nullptr)
		{
			pre-&gt;left-&gt;next = pre-&gt;right;
			if (pre-&gt;next != nullptr)pre-&gt;right-&gt;next = pre-&gt;next-&gt;left;
			else pre-&gt;right-&gt;next = nullptr;
			pre = pre-&gt;next;
		}
		pre = cur;
		cur = cur-&gt;left;
	}
	return root;
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 99. 恢复二叉搜索树[困难]]]></title>
        <id>https://lixin-ee.github.io//post/shu-99-hui-fu-er-cha-sou-suo-shu-kun-nan</id>
        <link href="https://lixin-ee.github.io//post/shu-99-hui-fu-er-cha-sou-suo-shu-kun-nan">
        </link>
        <updated>2019-12-03T01:30:05.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>二叉搜索树中的两个节点被错误地交换。<br>
请在不改变其结构的情况下，恢复这棵树。<br>
示例 1:<br>
输入: [1,3,null,null,2]<br>
   1<br>
  /<br>
 3<br>
  <br>
   2<br>
输出: [3,1,null,null,2]<br>
   3<br>
  /<br>
 1<br>
  <br>
   2<br>
示例 2:<br>
输入: [3,1,4,null,null,2]<br>
3<br>
/ <br>
1   4<br>
   /<br>
  2<br>
输出: [2,1,4,null,null,3]<br>
2<br>
/ <br>
1   4<br>
   /<br>
 3<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/recover-binary-search-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<pre><code>class Solution {
public:
    TreeNode *tempnode,*tempnode1,*tempnode2;
    void recoverTree(TreeNode* root){
        inorder(root);
        swap(tempnode1-&gt;val,tempnode2-&gt;val);
        return;
    }
    
    void inorder(TreeNode* cur)    
    {
        if(cur==NULL)
            return;
        inorder(cur-&gt;left);
        if(tempnode&amp;&amp;cur-&gt;val&lt;tempnode-&gt;val){
            if(tempnode1==NULL)
                tempnode1=tempnode;
            tempnode2=cur;
        }
        tempnode=cur;
        inorder(cur-&gt;right);
        return;
    }
};
</code></pre>
<p>1.一开始想着使用中序遍历的vector来交换两个点，但是思路不太对，我的想法是找到后一个值比前一个值小的时候就互换，但是是不对的。比如序列 3，2，1应该交换3和1，但是我的思路会交换3和2，所以应该找到最后一个矛盾点<br>
2.通过草稿纸演算，我发现一般来说会出现一到两个点的矛盾点（亦即前一个值大于后一个值），我打算保存两个指针值然后交换值<br>
3.这下又被坏习惯坑了，比如 TreeNode* temp1,temp2; 其实*号的位置很重要，这样子的话temp2被定义为TreeNode而是相应的指针<br>
4.终于通过了，主要注意的点是需要保存两个异常值，同时更新异常值的方式很重要，因为可能出现相邻互换的情况，所以第一个异常值指针只需要赋值一次，第二个异常指针值就需要赋值两次<br>
5.看了题解之后发现值得优化的点是因为必须保存前一个指针用于保存第一个异常值，所以完全可以用这个指针来得到pre-&gt;val，而不需要一个全局int<br>
6.更改后，直接 99.67%和100%，吓到我了</p>
<p>然后看一下网友题解</p>
<blockquote>
<p>思路:<br>
这道题难点,是找到那两个交换节点,把它交换过来就行了.<br>
这里我们二叉树搜索树的中序遍历(中序遍历遍历元素是递增的)<br>
如下图所示, 中序遍历顺序是 4,2,3,1,我们只要找到节点4和节点1交换顺序即可!<br>
这里我们有个规律发现这两个节点:<br>
第一个节点,是第一个按照中序遍历时候前一个节点大于后一个节点,我们选取前一个节点,这里指节点4;<br>
第二个节点,是在第一个节点找到之后, 后面出现前一个节点大于后一个节点,我们选择后一个节点,这里指节点1;<br>
对于中序遍历,我们有两种方法.<br>
方法一: 迭代<br>
java</p>
</blockquote>
<pre><code>class Solution {
    public void recoverTree(TreeNode root) {
        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();
        TreeNode firstNode = null;
        TreeNode secondNode = null;
        TreeNode pre = new TreeNode(Integer.MIN_VALUE);
        TreeNode p = root;
        while (p != null || !stack.isEmpty()) {
            while (p != null) {
                stack.push(p);
                p = p.left;
            }
            p = stack.pop();
            if (firstNode == null &amp;&amp; pre.val &gt; p.val) firstNode = pre;
            if (firstNode != null &amp;&amp; pre.val &gt; p.val) secondNode = p;
            pre = p;
            p = p.right;
        }
        int tmp = firstNode.val;
        firstNode.val = secondNode.val;
        secondNode.val = tmp;
    }
}
</code></pre>
<blockquote>
<p>方法二: 递归</p>
</blockquote>
<pre><code>java
class Solution {
    TreeNode firstNode = null;
    TreeNode secondNode = null;
    TreeNode preNode = new TreeNode(Integer.MIN_VALUE);

    public void recoverTree(TreeNode root) {

        in_order(root);
        int tmp = firstNode.val;
        firstNode.val = secondNode.val;
        secondNode.val = tmp;
    }

    private void in_order(TreeNode root) {
        if (root == null) return;
        in_order(root.left);
        if (firstNode == null &amp;&amp; preNode.val &gt; root.val) firstNode = preNode;
        if (firstNode != null &amp;&amp; preNode.val &gt; root.val) secondNode = root;
        preNode = root;
        in_order(root.right);
    }
}
</code></pre>
<p>这位网友的思路和我的一致</p>
<blockquote>
<p>然后来看看其他解法：<br>
解法一 递归<br>
和 98 题有些像。这里的思路如下：<br>
让我们来考虑交换的位置的可能：<br>
根节点和左子树的某个数字交换 -&gt; 由于根节点大于左子树中的所有数，所以交换后我们只要找左子树中最大的那个数，就是所交换的那个数<br>
根节点和右子树的某个数字交换 -&gt; 由于根节点小于右子树中的所有数，所以交换后我们只要在右子树中最小的那个数，就是所交换的那个数<br>
左子树和右子树的两个数字交换 -&gt; 找左子树中最大的数，右子树中最小的数，即对应两个交换的数<br>
左子树中的两个数字交换<br>
右子树中的两个数字交换<br>
思想有了，代码很好写了。</p>
</blockquote>
<pre><code>public void recoverTree2(TreeNode root) {
    if (root == null) {
        return;
    }
    //寻找左子树中最大的节点
    TreeNode maxLeft = getMaxOfBST(root.left);
    //寻找右子树中最小的节点
    TreeNode minRight = getMinOfBST(root.right);
    
    if (minRight != null &amp;&amp; maxLeft != null) {
        //左边的大于根节点，右边的小于根节点，对应情况 3，左右子树中的两个数字交换
        if ( maxLeft.val &gt; root.val &amp;&amp; minRight.val &lt; root.val) {
            int temp = minRight.val;
            minRight.val = maxLeft.val;
            maxLeft.val = temp;
        }
    }

    if (maxLeft != null) {
        //左边最大的大于根节点，对应情况 1，根节点和左子树的某个数做了交换
        if (maxLeft.val &gt; root.val) {
            int temp = maxLeft.val;
            maxLeft.val = root.val;
            root.val = temp;
        }
    }

    if (minRight != null) {
        //右边最小的小于根节点，对应情况 2，根节点和右子树的某个数做了交换
        if (minRight.val &lt; root.val) {
            int temp = minRight.val;
						minRight.val = root.val;
            root.val = temp;
        }
    }
    //对应情况 4，左子树中的两个数进行了交换
    recoverTree(root.left);
    //对应情况 5，右子树中的两个数进行了交换
    recoverTree(root.right);

}
//寻找树中最小的节点
private TreeNode getMinOfBST(TreeNode root) {
    if (root == null) {
        return null;
    }
    TreeNode minLeft = getMinOfBST(root.left);
    TreeNode minRight = getMinOfBST(root.right);
    TreeNode min = root;
    if (minLeft != null &amp;&amp; min.val &gt; minLeft.val) {
        min = minLeft;
    }
    if (minRight != null &amp;&amp; min.val &gt; minRight.val) {
        min = minRight;
    }
    return min;
}

//寻找树中最大的节点
private TreeNode getMaxOfBST(TreeNode root) {
    if (root == null) {
        return null;
    }
    TreeNode maxLeft = getMaxOfBST(root.left);
    TreeNode maxRight = getMaxOfBST(root.right);
    TreeNode max = root;
    if (maxLeft != null &amp;&amp; max.val &lt; maxLeft.val) {
        max = maxLeft;
    }
    if (maxRight != null &amp;&amp; max.val &lt; maxRight.val) {
        max = maxRight;
    }
    return max;
}
</code></pre>
<p>然后是空间复杂度为O（1）的莫里斯遍历</p>
<blockquote>
<p>Morris 版中序遍历<br>
因为之前这个方法中用了 pre 变量，为了方便，这里也需要 pre 变量，我们用 pre_new 代替。具体 Morris 遍历算法参见 94 题 。利用 Morris 的话，我们的空间复杂度终于达到了 O（1）。</p>
</blockquote>
<pre><code>public void recoverTree(TreeNode root) {
    TreeNode first = null;
    TreeNode second = null;
    TreeNode cur = root;
    TreeNode pre_new = null;
    while (cur != null) {
        // 情况 1
        if (cur.left == null) {
            /*******************************************************/
            if (pre_new != null &amp;&amp; cur.val &lt; pre_new.val) {
                if (first == null) {
                    first = pre_new;
                    second = cur;
                } else {
                    second = cur;
                }
            }
            pre_new = cur;
            /*******************************************************/
            cur = cur.right;
        } else {
            // 找左子树最右边的节点
            TreeNode pre = cur.left;
            while (pre.right != null &amp;&amp; pre.right != cur) {
                pre = pre.right;
            }
            // 情况 2.1
            if (pre.right == null) {
                pre.right = cur;
                cur = cur.left;
            }
           // 情况 2.2
            if (pre.right == cur) {
                pre.right = null; // 这里可以恢复为 null
                /*******************************************************/
                if (pre_new != null &amp;&amp; cur.val &lt; pre_new.val) {
                    if (first == null) {
                        first = pre_new;
                        second = cur;
                    } else {
                        second = cur;
                    }
                }
                pre_new = cur;
                /*******************************************************/
                cur = cur.right;
            }
        }
    }
    
    int temp = first.val;
    first.val = second.val;
    second.val = temp;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 297. 二叉树的序列化与反序列化[困难][未做出]]]></title>
        <id>https://lixin-ee.github.io//post/shu-297-er-cha-shu-de-xu-lie-hua-yu-fan-xu-lie-hua-kun-nan</id>
        <link href="https://lixin-ee.github.io//post/shu-297-er-cha-shu-de-xu-lie-hua-yu-fan-xu-lie-hua-kun-nan">
        </link>
        <updated>2019-12-02T07:21:48.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。<br>
请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。<br>
示例: <br>
你可以将以下二叉树：<br>
1<br>
/ <br>
2   3<br>
/ <br>
4   5<br>
序列化为 &quot;[1,2,3,null,null,4,5]&quot;<br>
提示: 这与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。<br>
说明: 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题可以说是很曲折了<br>
1.一开始以为层次遍历比较好，但是看了一下题解发现还是先序遍历比较方便，因为可以按照string至今进行链接，而层次遍历需要一个队列来保存<br>
2.题解中的大佬用了ostringstream和istringstream，很方便，很值得学习。<br>
3.然后我就在上述两个stream中翻了车，一开始是哈皮了，忘了string的push_back要求的是单引号的字符变量‘#’而不是直接string，所以“#”和to_string都是没法用pushback的，只能用加号或者单引号。另一个就是ostringstream是有格式的，所以必须用空格隔开将连续的数字隔开，否则会连起来stoi会输出一个超级大的数字（但是似乎允许123#123这种形式，并输出 “123” “#” “123”三者）<br>
4.剩下的就是stream的使用了吧，dalao的思维还是很厉害的。<br>
5.还有的话就是理解一下先序遍历为何可以重建二叉树（等等！大话数据结构里面不是说建树和遍历只需要改一下相应的就好嘛hhh，确认了！！快回去复习大话数据结构！！！就在6.9节）</p>
<p>代码如下：</p>
<pre><code>class Codec {
public:
   /*string serialize(TreeNode* root) {
        ostringstream out;
        serialize(root,out);
        return out.str();
    }*/

    /*void serialize(TreeNode* root,ostringstream&amp; out){
        if(root){
            out&lt;&lt;root-&gt;val&lt;&lt;' ';
            serialize(root-&gt;left,out);
            serialize(root-&gt;right,out);
        }else{
            out&lt;&lt;&quot;# &quot;;
        }
        
    }*/
    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        string s;
        serialize(root,s);
        return s;
    }

    void serialize(TreeNode *cur,string &amp;s){
        s.push_back(' ');
        if(cur==NULL){
            s.push_back('#');
            return;
        }
        s+=to_string(cur-&gt;val);
        serialize(cur-&gt;left,s);
        serialize(cur-&gt;right,s);
    } 

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        istringstream is(data);
        return deserialize(is);
    }

    TreeNode* deserialize(istringstream &amp;is){
        string val;
        is&gt;&gt;val;
        if(val==&quot;#&quot;)
         return NULL;
        
        TreeNode* cur=new TreeNode(stoi(val));
       cur-&gt;left=deserialize(is);
        cur-&gt;right=deserialize(is);
        return cur;
    }

    /*TreeNode* deserialize(istringstream&amp; in){
        string val;
        in&gt;&gt;val;
        if(val==&quot;#&quot;){
            return nullptr;
        }
        TreeNode* root=new TreeNode(stoi(val));
        root-&gt;left=deserialize(in);
        root-&gt;right=deserialize(in);
        return root;
    }*/

};

// Your Codec object will be instantiated and called as such:
// Codec codec;
// codec.deserialize(codec.serialize(root));
</code></pre>
<p>然后来看大佬的题解吧</p>
<blockquote>
<p>解法一 先序遍历法<br>
先序遍历二叉树时，将节点输出。<br>
重点是碰到NULL时，也要将其用#标识并输出。NULL节点虽然不是数字，但是能决定二叉树的结构。没有NULL节点，单靠先序序列是无法恢复成树的。<br>
节点与节点之间用空格隔开。<br>
例如：<br>
1<br>
/ <br>
2   3<br>
/ <br>
4   5<br>
其序列化后为， 1 2 # # 3 4 # # 5 # #<br>
可以发现，#标识的NULL节点，紧跟在其父节点的后面。</p>
</blockquote>
<pre><code>    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        if(!root) return string();
        stringstream ss;
        dfs(root,ss);
        return ss.str();
    }
    
    void dfs(TreeNode* rt,stringstream&amp; ss){
        if(!rt){
            ss &lt;&lt; &quot;# &quot;;
            return ;
        }
        ss &lt;&lt; to_string(rt-&gt;val) &lt;&lt;&quot; &quot;;
        dfs(rt-&gt;left,ss);
        dfs(rt-&gt;right,ss);
    }
</code></pre>
<blockquote>
<p>重建时，思路很清晰。<br>
先重建根节点，如果是NULL节点，返回。如果是数字节点，递归重建左子树。之后，再重建右子树。</p>
</blockquote>
<pre><code>void rebuild(TreeNode* &amp; rt,stringstream&amp; ss){
		string t;
		ss &gt;&gt; t;
		if(t[0] == '#'){
				rt = NULL;
				return;
		}
		int v = stoi(t);
		rt = new TreeNode(v);
		rebuild(rt-&gt;left,ss);
		rebuild(rt-&gt;right,ss);
}

// Decodes your encoded data to tree.
TreeNode* deserialize(string data) {
		if(data.empty()) return NULL;
		TreeNode* rt = NULL;
		stringstream ss(data);
		rebuild(rt,ss);
		return rt;
}
</code></pre>
<blockquote>
<p>解法二 层次遍历法<br>
层次遍历也能序列化。在序列化时，遇到NULL节点时，也要输出为#。<br>
用队列设计层次遍历。</p>
</blockquote>
<pre><code>	string serialize(TreeNode* root) {
			if(!root) return &quot;&quot;;
			stringstream ss;
			queue&lt;TreeNode*&gt; Q;
			Q.push(root);
			while(Q.size()){
					TreeNode* p = Q.front();Q.pop();
					if(!p) ss &lt;&lt;&quot;# &quot;;
					else{
							ss &lt;&lt; p-&gt;val &lt;&lt;&quot; &quot;;
							Q.push(p-&gt;left);
							Q.push(p-&gt;right);
					}
			}
			return ss.str();
	}
</code></pre>
<blockquote>
<p>难点在于层次遍历的反序列化。不容易想清楚重建的顺序应该是怎么样的。<br>
1<br>
/ <br>
2   3<br>
/ <br>
4   5<br>
序列化后， 1 2 3 # # 4 5 # # # # 。<br>
第一个节点是1，是根节点。但是还未完成，其还有两个子节点。<br>
此时，只能将存入队列。<br>
接着是2，其是1的左子节点。<br>
接着是3，其是1的右子节点。<br>
可以看出，除了根节点，后面的节点必须成对出现，且第一个是某节点的左子节点，第二个是其右子节点。<br>
同样，2和3的子节点也还没有出现，同样要先入队列。</p>
</blockquote>
<pre><code>TreeNode* deserialize(string data) {
		if(data.empty()) return NULL;
		stringstream ss(data);
		string t;
		ss &gt;&gt; t;
		TreeNode* rt = new TreeNode(stoi(t));
		queue&lt;TreeNode*&gt; Q;
		Q.push(rt);
		while(Q.size()){
				TreeNode* p = Q.front();Q.pop();
				ss &gt;&gt; t;
				if(t[0] == '#'){
						p-&gt;left = NULL;
				}else{
						p-&gt;left = new TreeNode(stoi(t));
						Q.push(p-&gt;left);
				}
				ss &gt;&gt; t;
				if(t[0] == '#'){
						p-&gt;right = NULL;
				}else{
						p-&gt;right = new TreeNode(stoi(t));
						Q.push(p-&gt;right);
				}
		}
		return rt;
}
</code></pre>
<p>另一位C++大佬的题解，没有解析</p>
<pre><code>class Codec {
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        ostringstream out;
        serialize(root,out);
        return out.str();
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        istringstream in(data);
        return deserialize(in);
    }
private:
    void serialize(TreeNode* root,ostringstream&amp; out){
        if(root){
            out&lt;&lt;root-&gt;val&lt;&lt;' ';
            serialize(root-&gt;left,out);
            serialize(root-&gt;right,out);
        }else{
            out&lt;&lt;&quot;# &quot;;
        }
        
    }
    TreeNode* deserialize(istringstream&amp; in){
        string val;
        in&gt;&gt;val;
        if(val==&quot;#&quot;){
            return nullptr;
        }
        TreeNode* root=new TreeNode(stoi(val));
        root-&gt;left=deserialize(in);
        root-&gt;right=deserialize(in);
        return root;
    }
};
</code></pre>
<p>官方题解的解析：<br>
<img src="https://lixin-ee.github.io//post-images/1575272094124.png" alt=""><br>
其中机翻错误加泰罗尼亚语的数字==卡特兰数</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++primer 目录与链接]]></title>
        <id>https://lixin-ee.github.io//post/cprimer-mu-lu-yu-lian-jie</id>
        <link href="https://lixin-ee.github.io//post/cprimer-mu-lu-yu-lian-jie">
        </link>
        <updated>2019-11-30T13:43:48.000Z</updated>
        <content type="html"><![CDATA[<p>今晚在做算法题的时候想看一下pair的性质，结果发现按照章节不好找啊！，打算按照文字化目录来完成这篇文章</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ C++ primer 第十八章 笔记+习题 19.7-19.8]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-ba-zhang-bi-ji-xi-ti-197-198</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-ba-zhang-bi-ji-xi-ti-197-198">
        </link>
        <updated>2019-11-30T13:18:03.000Z</updated>
        <content type="html"><![CDATA[<p>19.7局部类<br>
<strong>类</strong>可以<strong>定义在某个函数的内部</strong>，我们称这样的类为<strong>局部类(local class)</strong>。局部类定义的类型<strong>只在定义它的作用域内可见</strong>。和嵌套类不同，局部类的成员受到严格限制。<br>
局部类的<strong>所有成员</strong>（<strong>包括函数</strong>在内）都<strong>必须完整定义在类的内部</strong>。因此，局部类的作用与嵌套类相比相差很远。<br>
复杂性不可能太高。局部类的成员函数一般只有几行代码，否则我们就很难读懂它了。<br>
类似的，在局部类中<strong>也不允许声明静态数据成员</strong>，因为我们<strong>没法定义</strong>这样的成员。<br>
<strong>静态成员必须定义在外部</strong><br>
局部类不能使用函数作用域中的变量<br>
局部类<strong>对其外层作用域中名字</strong>的<strong>访问权限受到很多限制</strong>，局部类只<strong>能访问外层作用域</strong>定义的<strong>类型名</strong>、<strong>静态变量</strong>（参见6.1.1节，第185页）以及<strong>枚举成员</strong>。如果局部类定义在某个函数内部，则该函数的<strong>普通局部变量不能被该局部类使用</strong>：</p>
<p><strong>常规的访问保护规则对局部类同样适用</strong><br>
外层函数对局部类的私有成员没有任何访问特权。当然，局部类可以将外层函数声明为友元；或者更常见的情况是局部类将其成员声明成公有的。在程序中有权访问局部类的代码非常有限。局部类已经封装在函数作用域中，通过信息隐藏进一步封装就显得没什么必要了。<br>
局部类中的名字查找<br>
局部类内部的名字查找次序与其他类相似。在<strong>声明类的成员</strong>时，<strong>必须先确保</strong>用到的名<br>
字<strong>位于作用域中</strong>，然后再使用该名字。<strong>定义成员时</strong>用到的名字可以出现在<strong>类的任意位置</strong>。<br>
如果<strong>某个名字不是局部类的成员</strong>，则<strong>继续在外层函数作用域中查找</strong>；如果<strong>还没有找到</strong>，则在<strong>在外层函数所在的作用域中查找</strong>。</p>
<p>嵌套的局部类<br>
可以在<strong>局部类的内部再嵌套一个类</strong>。此时，<strong>嵌套类的定义</strong>可以<strong>出现在局部类之外</strong>。不过，嵌套类<strong>必须定义</strong>在与局部类<strong>相同的作用域</strong>中。</p>
<p><strong>局部类内的嵌套类</strong>也是一个<strong>局部类</strong>，必须遵循局部类的各种规定。<strong>嵌套类的所有成员都必须定义在嵌套类内部</strong>。</p>
<p>19.8 固有的不可移植的特性<br>
为了<strong>支持低层编程</strong>，C++定义了一些<strong>固有的不可移植</strong>（nonportable)的<strong>特性</strong>。所谓不可移植的特性是<strong>指因机器而异的特性</strong>，当我们将含有不可移植特性的程序从一台机器转移到另一台机器上时，通常需要重新编写该程序。算术类型的大小在不同机器上不一样（参见2.1.1节，第30页），这是我们使用过的不可移植特性的一个典型示例。<br>
本节将介绍C++从C语言继承而来的另外两种不可移植的特性：位域和volatile限定符。此外，我们还将介绍链接指示，它是C++新増的一种不可移植的特性。</p>
<p>19.8.1 位域<br>
<strong>类</strong>可以将其（非静态）<strong>数据成员定义成位域</strong>（bit-field),在一个位域中<strong>含有一定数量的二进制位</strong>。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。<br>
位域在内存中的布局是与机器相关的。<br>
<strong>位域的类型</strong>必须是<strong>整型或枚举类型</strong>（参见19.3节，第736页）。因为带符号位域的行为是由具体实现确定的，所以在通常情况下我们使用<strong>无符号类型保存一个位域</strong>。位域的<strong>声明形式</strong>是在<strong>成员名字之后</strong>紧跟<strong>一个冒号</strong>以及<strong>一个常量表达式</strong>，该<strong>表达式用于指定</strong>成员<strong>所占的二进制位数</strong>：</p>
<p><strong>取地址运算符（&amp;）不能作用于位域</strong>，因此<strong>任何指针都无法指向类的位域</strong>。<br>
通常情况下最好将位域设为无符号类型，存储在带符号类型中的位域的行为将因具体实现而定。</p>
<p>19.8.2 volatile限定符<br>
<strong>volatile的确切含义与机器有关</strong>，只能通过阅读编译器文档来理解。要想让使用了volatile的程序在移植到新机器或新编译器后仍然有效，通常需要对该程序进行某些改变<br>
直接处理硬件的程序常常包含这样的数据元素，它们的值由程序直接控制之外的过程 控制。例如，程序可能包含一个由系统时钟定时更新的变量。当<strong>对象的值可能在程序的控制或检测之外被改变时，应该将该对象声明为volatile关键字</strong>。<strong>volatile告诉编译器不应对这样的对象进行优化</strong>。<br>
volatile限定符的用法和const很相似，它起到<strong>对类型额外修饰</strong>的作用:</p>
<p>在volatile限定符和指针之间也存在类似的关系。</p>
<p>合成的拷贝对volatile对象无效<br>
const和volatile的一个重要区别是我们<strong>不能使用合成的拷贝/移动构造函数及赋值运算符初始化volatile对象或从volatile对象赋值</strong>。<strong>合成的成员接受的形参类型是（非volatile)常量引用</strong>，显然我们不能把一个非volatile引用绑定到一个volatile对象上。<br>
<strong>如果一个类希望拷贝、移动或赋值</strong>它的volatile对象，则该<strong>类必须自定义拷贝或移动操作</strong>。</p>
<p>19.8.3链接指示：extern&quot;C&quot;<br>
C++使用链接指示（linkage directive)指出<strong>任意非C++函数所用的语言</strong>。<br>
要想把<strong>C++代码和其他语言</strong>（包括C语言）编写的代码放在一起使用，要求我们<strong>必须有权访问该语言的编译器</strong>，并且这个编译器与当前的C++编译器是兼容的</p>
<p>声明一个非C++的函数<br>
<strong>链接指示</strong>可以有两种形式：<strong>单个的或复合的</strong>。链接指示<strong>不能出现在类定义或函数定义的内部</strong>。同样的链接指示<strong>必须在函数的每个声明中都出现</strong>。<br>
链接指示的第一种形式包含一个<strong>关键字extern</strong>.后面是一个<strong>字符串字面值常量</strong>以及一个 <strong>&quot;普通的&quot;函数声明</strong>。<br>
其中的<strong>字符串字面值常量指出了编写函数所用的语言</strong>。编译器应该支持对C语言的链 接指示。此外，编译器也可能会支持其他语言的链接指示，如extern&quot;Ada&quot;、extern &quot;FORTRAN&quot;等。</p>
<p>链接指示与头文件<br>
我们可以令链接指示后面跟上<strong>花括号括起来的若干函数的声明</strong>，从而<strong>一次性建立多个 链接</strong>。花括号的作用是将适用于该链接指示的多个声明聚合在一起，否则花括号就会被忽 略，花括号中声明的函数名字就是可见的，就好像在花括号之外声明的一样。</p>
<p>当一个**#include指示<strong>被放置在复合链接指示的</strong>花括号<strong>中时，<strong>头文件中的所有普通函数声明</strong>都被认为是</strong>由链接指示的语言编写的**。<strong>链接指示可以嵌套</strong>，因此如果头文件包含带自带链接指示的函数，则该函数的链接不受影响。<br>
C++从C语言继承的标准库函数可定义成C函数，但并非必须：决定使用还是C++实现C标准库，是毎个C++实现的事情。</p>
<p>指向extern&quot;C&quot;函数的指针<br>
<strong>编写函数所用的语言是函数类型的一部分</strong>。因此，对于使用链接指示定义的函数来说，<strong>它的每个声明都必须使用相同的链接指示</strong>。而且，<strong>指向</strong>其他语言编写的<strong>函数的指针</strong>必须与函数本身<strong>使用相同的链接指示</strong>：<br>
//pf指向一个C函数，该函数接受一个int返回void<br>
<code>extern&quot;C&quot;void(*pf)(int);</code><br>
当我们使用pf调用函数时，编详器认定当前调用的是一个c函数。<br>
<strong>指向C函数的指针</strong>与指向C++函数的指针是<strong>不一样的类型</strong>。一个指向C函数的指针<strong>不能用在执行初始化或赋值操作后指向C++函数</strong>，反之亦然。就像其他类型不匹配的问题一样，如果我们试图在两个链接指示不同的指针之间进行赋值操作，则程序将发生错误：</p>
<p>链接指示对整个声明都有效<br>
当我们使用链接指示时，它不仅对函数有效，而且对作为<strong>返回类型</strong>或<strong>形参类型</strong>的<strong>函数指针也有效</strong>：</p>
<p>因为链接指示同时作用于声明语句中的所有函数，所以如果我们<strong>希望给C++函数传入</strong>一个<strong>指向C函数的指针</strong>，则<strong>必须使用类型别名</strong><br>
导出C++函数到其他语言<br>
通过使用链接指示对函数进行定义，我们可以令一个C++函数在其他语言编写的程序 中可用：<br>
//calc函数可以被C程序调用<br>
extern &quot;C&quot; double calc(double dparm){/<em>...</em>/}<br>
编译器将为该函数生成适合于指定语言的代码。<br>
值得注意的是，<strong>可被多种语言共享</strong>的函数的<strong>返回类型或形参类型</strong>受到<strong>很多限制</strong>。</p>
<p>重载函数与链接指示<br>
<strong>链接指示与重载函数</strong>的相互作用<strong>依赖于目标语言</strong>。<strong>如果目标语言支持重载函数</strong>，则为 该语言实现链接指示的编编译<strong>很可能也支持重载</strong>这些C++的函数。<br>
C语言不支持函数重载，因此也就不难理解为什么一个C链接指示只能用于说明一组重载函数中的某一个了：</p>
<p>习题19.26<br>
不合法，两函数名字相同，但c语言不支持函数重载<br>
答案肯定是不合法，在这里我想给出我找到的原因： 主要原因是两种语言对函数的编译结果有差异。 比如一个函数的声明如下： void function(int x,int y)； 在c语言中，编译器在编译后在库中的名字_function 在c++中，编译器在编译后在库中的名字_function_int_int 如果还有一个函数的声明如下： void function（float x,float y)； 在c语言中，编译器在编译后在库中的名字为_function。而在c++中，编译器在编译后在库中的名字为_function_float_float。在链接时，都是找名字进行链接的,就比如以上两个函数，在C语言中两个的名字一样，就会在链接中报错。C++中它们的名字不一样，所以就不会报错。C语言这种编译的机制，导致了它不支持函数重载。</p>
]]></content>
    </entry>
</feed>