<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-11-07T02:38:38.184Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[链表 21. 合并两个有序链表[简单]]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-21-he-bing-liang-ge-you-xu-lian-biao-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-21-he-bing-liang-ge-you-xu-lian-biao-jian-dan">
        </link>
        <updated>2019-11-07T01:50:31.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<p>示例：<br>
输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>
输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/merge-two-sorted-lists<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>其实这个在STL源码里面有说过，就是6.5.1 set_union，主要是判断两个链表当前值的大小，先把小的值放到新链表里，如果有一个链表走到尾端了立即停止循环并将另一链表直接接到新链表后面。</p>
<pre><code>class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if(l1==NULL)
            return l2;
        if(l2==NULL)
            return l1;
        ListNode* ehead=new ListNode(-1);
        ListNode* cur=ehead;
        while(l1!=NULL||l2!=NULL){
            if(l1-&gt;val&lt;=l2-&gt;val){
                cur-&gt;next=l1;
                l1=l1-&gt;next;
            }else{
                cur-&gt;next=l2;
                l2=l2-&gt;next;
            }
            cur=cur-&gt;next;
            if(l1==NULL){
                cur-&gt;next=l2;break;}
            if(l2==NULL){
                cur-&gt;next=l1;break;}
        }
        return ehead-&gt;next;
    }
};
</code></pre>
<p>当时做这道题的时候是在家里，没法对照着STL源码来写，对比了一下，主要的差异点在于<br>
1.最后接上链表的操作，其实可以直接两个都接上，因为肯定有一个为空，不需要判断两次<br>
2.set需要判断相等的情况，而链表不需要</p>
<p>然后看一下题解吧<br>
首先是递归的：<br>
思路<br>
标签：链表、递归<br>
这道题可以使用递归实现，新链表也不需要构造新节点，我们下面列举递归三个要素<br>
终止条件：两条链表分别名为 l1 和 l2，当 l1 为空或 l2 为空时结束<br>
返回值：每一层调用都返回排序好的链表头<br>
本级递归内容：如果 l1 的 val 值更小，则将 l1.next 与排序好的链表头相接，l2 同理O(m+n)，m 为 l1的长度，n 为 l2 的长度</p>
<pre><code>class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if(l1 == null) {
            return l2;
        }
        if(l2 == null) {
            return l1;
        }

        if(l1.val &lt; l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        } else {
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }
    }
}
</code></pre>
<p>复杂度分析</p>
<p>时间复杂度：O(n+m)。 因为每次调用递归都会去掉 l1 或者 l2 的头元素（直到至少有一个链表为空），函数 mergeTwoList 中只会遍历每个元素一次。所以，时间复杂度与合并后的链表长度为线性关系。</p>
<p>空间复杂度：O(n+m)。调用 mergeTwoLists 退出时 l1 和 l2 中每个元素都一定已经被遍历过了，所以n+m 个栈帧会消耗 O(n+m) 的空间。</p>
<p>方法 2：迭代<br>
想法<br>
我们可以用迭代的方法来实现上述算法。我们假设 l1 元素严格比 l2元素少，我们可以将 l2 中的元素逐一插入 l1 中正确的位置。</p>
<p>算法<br>
首先，我们设定一个哨兵节点 &quot;prehead&quot; ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 prev 指针，我们需要做的是调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：如果 l1 当前位置的值小于等于 l2 ，我们就把 l1 的值接在 prev 节点的后面同时将 l1 指针往后移一个。否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都把 prev 向后移一个元素。</p>
<p>在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表。</p>
<pre><code>class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode* prehead = new ListNode(-1);
        ListNode* prev = prehead;
        while(l1 != NULL &amp;&amp; l2 != NULL) {
            if(l1-&gt;val &lt;= l2-&gt;val) {
                prev-&gt;next = l1;
                l1 = l1-&gt;next;
            } else {
                prev-&gt;next = l2;
                l2 = l2-&gt;next;
            }
            prev = prev-&gt;next;
        }
        prev-&gt;next = l1 != NULL ? l1 : l2;

        return prehead-&gt;next;
    }
};
</code></pre>
<p>时间复杂度：O(n+m) 。因为每次循环迭代中，l1 和 l2 只有一个元素会被放进合并链表中， while 循环的次数等于两个链表的总长度。所有其他工作都是常数级别的，所以总的时间复杂度是线性的。<br>
空间复杂度：O(1) 。迭代的过程只会产生几个指针，所以它所需要的空间是常数级别的。</p>
<p>果然还是递归优雅一点hhh</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第十三章 笔记+习题 13.6]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-san-zhang-bi-ji-xi-ti-136</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-san-zhang-bi-ji-xi-ti-136">
        </link>
        <updated>2019-11-06T12:48:42.000Z</updated>
        <content type="html"><![CDATA[<p>13.6对象移动<br>
使用移动而不是拷贝的另一个原因源于<strong>IO类或unique_ptr等类不应该被拷贝</strong>，包含不能被共享的资源<br>
在旧标准中，没有直接的方法移动对象，在新标准中，我们可以<strong>用容器保存不可以拷贝</strong>的类型，只要它们能被<strong>移动</strong>即可<br>
标准库容器、string和shared_ptr类既支持移动也支持拷贝，<strong>IO类和unique_ptr类可以移动但不可以拷贝</strong></p>
<p>13.6.1右值引用<br>
为了<strong>支持移动操作</strong>，新标准引入了一种新的引用类型—<strong>右值引用</strong>，其有一个重要的性质，<strong>只能绑定到一个将要销毁的对象</strong>，因此我们可以自由地将一个<strong>右值引用的资源移动到另一个对象中</strong><br>
一般而言，一个<strong>左值表达式</strong>表示的是一个<strong>对象的身份</strong>，一个<strong>右值表达式</strong>表示的是<strong>对象的值</strong><br>
对于常规引用（即左值引用），我们<strong>不能</strong>将其绑定到要求<strong>转换的表达式、字面常量或是返回右值的表达式</strong>。而右值引用完全相反，我们可以将一个右值引用绑定到这类表达式上，但<strong>不能将一个右值引用直接绑定到一个左值上</strong>。</p>
<p>左值引用可用的表达式：返回左值引用的函数，赋值、下标、解引用和<strong>前置递增/递减运算符</strong><br>
右值引用可用的表达式：返回非引用类型的函数，算术、关系、位以及<strong>后置递增/递减运算符</strong><br>
但是我们可以将一个const的左值引用绑定到右值表达式中。<br>
左值表达式与右值表达式的区别：左值有持久的状态，右值要么是字面常量，要么是在表达式求值过程中创建的临时对象<br>
由于右值引用只能绑定到临时对象，所以<strong>1.所引用的对象将要被销毁2.该对象没有其他用户</strong>。这两个特性意味着使用右值引用的代码可以自由接管所引用的对象的资源<br>
右值引用指向将要被销毁的对象，因此，我们可以从绑定到右值引用的对象窃取状态<br>
<strong>变量</strong>可以看作<strong>只有一个运算对象而没有运算符的表达式</strong>，所以变量表达式都是左值 <strong>（导致右值引用本身是一个左值！）</strong></p>
<p>原因：变量是持久的，直至离开作用域才被销毁<br>
虽然不能将一个右值引用<strong>直接绑定</strong>到一个左值上，但可以<strong>显式</strong>地将一个<strong>左值</strong>转换为对应的<strong>右值引用</strong>类型，我们还可以用过调用一个名为move的新标准库函数来获得绑定到左值上的右值引用，move调用告诉编译器：我们有一个左值，但是我们希望像一个右值一样处理它，但<strong>对某个左值调用move后</strong>就意味着承诺除了对该左值进行<strong>赋值或销毁外不再使用它</strong><br>
int &amp;&amp;rr3 = std::move(rr1); //完成转移后，rr1为移后源对象，相当于一次移动<br>
调用move后，我们不<strong>能再对移后源对象</strong>rr1的值<strong>做任何假设</strong>，<strong>只能对其进行销毁或赋予新值</strong>，不能使用一个移后源对象的值<br>
对move不提供using声明，直接调用std::move而不是move，<strong>避免潜在的名字冲突</strong></p>
<p>习题13.45<br>
右值引用只能绑定到一个将要销毁的对象，表示的是对象的值，可以将其绑定到要求转换的表达式、字面常量或是返回右值的表达式。右值短暂，要么是字面常量，要么是在表达式求值过程中创建的临时对象<br>
习题13.46<br>
r1 f()返回一个非引用类型的int临时变量，只能用右值引用&amp;&amp;<br>
r2 下标符号返回的是左值， 只能用左值引用&amp;<br>
r3 r1是右值引用，但是本质上是一个变量，也就是一个左值，所以得用左值引用&amp;<br>
r4 两者习题相乘等于算术符号，只能用 右值引用<br>
习题13.47 13.48</p>
<pre><code>String::String(const String &amp;s) {
	auto newdata = alloc_n_copy(s.begin(), s.end());
	elements = newdata.first;
	first_free = cap = newdata.second;
	cout &lt;&lt; &quot;拷贝构造函数&quot; &lt;&lt; endl;
}

String&amp; String::operator=(const String &amp;rhs) {
	auto data = alloc_n_copy(rhs.begin(), rhs.end());
	free();
	elements = data.first;
	first_free = cap = data.second;
	cout &lt;&lt; &quot;拷贝赋值函数&quot; &lt;&lt; endl;
	return *this;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 160. 相交链表[简单]]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-160-xiang-jiao-lian-biao-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-160-xiang-jiao-lian-biao-jian-dan">
        </link>
        <updated>2019-11-06T01:26:08.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>编写一个程序，找到两个单链表相交的起始节点。</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1573004036742.png" alt=""><br>
<img src="https://lixin-ee.github.io//post-images/1573004040961.png" alt=""></p>
<blockquote>
<p>注意：<br>
如果两个链表没有交点，返回 null.<br>
在返回结果后，两个链表仍须保持原有的结构。<br>
可假定整个链表结构中没有循环。<br>
程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/intersection-of-two-linked-lists<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题如果用哈希表的话是没啥难度的，所以重点在于如何满足O(n) 时间复杂度，且仅用 O(1) 内存。<br>
我最后想到的办法是制造一个环，从两个链表的头部同时出发，然后谁先达到尾部就直接把链表接到另一个的尾部<br>
但是在复习完有环链表的判断后才发现最后的相遇点不是一定在交点那里的，GG</p>
<p>纠结了太久了，直接看官方解答吧：</p>
<blockquote>
<p>方法一: 暴力法<br>
对链表A中的每一个结点 a_i	 ，遍历整个链表 B 并检查链表 B 中是否存在结点和 a_i  相同。<br>
复杂度分析<br>
时间复杂度 : (mn)。<br>
空间复杂度 : O(1)。</p>
<p>方法二: 哈希表法<br>
遍历链表 A 并将每个结点的地址/引用存储在哈希表中。然后检查链表 B 中的每一个结点 b_i 是否在哈希表中。若在，则 b_i为相交结点。<br>
复杂度分析<br>
时间复杂度 : O(m+n)。<br>
空间复杂度 : O(m) 或 O(n)。</p>
<p>方法三：双指针法<br>
创建两个指针 pA 和 pB，分别初始化为链表 A 和 B 的头结点。然后让它们向后逐结点遍历。<br>
当 pA 到达链表的尾部时，将它重定位到链表 B 的头结点 (你没看错，就是链表 B); 类似的，当 pB 到达链表的尾部时，将它重定位到链表 A 的头结点。<br>
若在某一时刻 pA 和 pB 相遇，则 pA/pB 为相交结点。<br>
想弄清楚为什么这样可行, 可以考虑以下两个链表: A={1,3,5,7,9,11} 和 B={2,4,9,11}，相交于结点 9。 由于 B.length (=4) &lt; A.length (=6)，pB 比 pA 少经过 2 个结点，会先到达尾部。将 pB 重定向到 A 的头结点，pA 重定向到 B 的头结点后，pB 要比 pA 多走 2 个结点。因此，它们会同时到达交点。<br>
如果两个链表存在相交，它们末尾的结点必然相同。因此当 pA/pB 到达链表结尾时，记录下链表 A/B 对应的元素。若最后元素不相同，则两个链表不相交。</p>
<p>复杂度分析<br>
时间复杂度 : O(m+n)。<br>
空间复杂度 : O(1)。</p>
</blockquote>
<p>妙啊！确实是简单题hhh，我只猜到了开头没猜到结局hhh，两者无论如何走过的路程都是一样的，所以当两者相等时退出循环判断，只需要判断最后的结点是否是NULL就好（甚至于都不用判断，直接返回就好）<br>
自己复现的代码如下：</p>
<pre><code>ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if(headA==NULL||headB==NULL)
            return NULL;
        ListNode *cur1=headA,*cur2=headB;
        while(cur1!=cur2){
            cur1=cur1==NULL?headB:cur1-&gt;next;
            cur2=cur2==NULL?headA:cur2-&gt;next;
        }
        return cur1;
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 2. 两数相加[中等]]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-2-liang-shu-xiang-jia-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-2-liang-shu-xiang-jia-zhong-deng">
        </link>
        <updated>2019-11-05T07:27:17.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。<br>
如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。<br>
您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>示例：<br>
输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>
输出：7 -&gt; 0 -&gt; 8<br>
原因：342 + 465 = 807</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/add-two-numbers<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>本题目其实相对不算特别难（因为链表按个位算起的），主要的难点在于<br>
1.如果两链表长度不等的话，存储起来比较麻烦，我本来想原地操作，但是这样子反而比较难操作（因为必须对两个链表同时操作直至其中一个到结尾，同时需要返回正确的那个链表的头结点）<br>
2.当一个链表去到尾部后的处理，以及如何判断两个链表达到结尾退出循环的判断<br>
2.进位其实还是比较好处理的，直接一个int就好<br>
最终代码如下</p>
<pre><code>class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        int flag=0;
        ListNode* ehead=new ListNode(0);
        ListNode* cur=ehead;
        int res,i1,i2;        
        while(l1!=NULL||l2!=NULL){
            i1=l1!=NULL?l1-&gt;val:0;
            i2=l2!=NULL?l2-&gt;val:0;
            res=(i1+i2+flag)%10;
            flag=(i1+i2+flag)/10;
            ListNode* newnode=new ListNode(res);
            cur-&gt;next=newnode;
            cur=newnode;
            if(l1!=NULL)
                l1=l1-&gt;next;
            if(l2!=NULL)
                l2=l2-&gt;next;
        }
        if(flag){
            ListNode* newnode=new ListNode(1);
            cur-&gt;next=newnode;
            cur=newnode;
        }
        cur-&gt;next=NULL;
        return ehead-&gt;next;
    }
};
</code></pre>
<p>比较重要的点就是<br>
1 <code>while(l1!=NULL||l2!=NULL)</code> 必须是或判断<br>
2 <code>i1=l1!=NULL?l1-&gt;val:0;</code> 这里使用条件语句能够节省很多代码</p>
<p>然后先来看一下网友的题解吧</p>
<pre><code>class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* head=new ListNode(-1);//存放结果的链表
        ListNode* h=head;//移动指针
        int sum=0;//每个位的加和结果
        bool carry=false;//进位标志
        while(l1!=NULL||l2!=NULL)
        {
            sum=0;
            if(l1!=NULL)
            {
                sum+=l1-&gt;val;
                l1=l1-&gt;next;
            }
            if(l2!=NULL)
            {
                sum+=l2-&gt;val;
                l2=l2-&gt;next;
            }
            if(carry)
                sum++;
            h-&gt;next=new ListNode(sum%10);
            h=h-&gt;next;
            carry=sum&gt;=10?true:false;
        }
        if(carry)
        {
            h-&gt;next=new ListNode(1);
        }
        return head-&gt;next;
    }
};
</code></pre>
<p>这里我没贴上补位的题解，因为补位需要先循环确定长度。主要是第二种做法比较巧妙的是利用一个sum来计算和。</p>
<p>官方题解和我的一毛一样hhh</p>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(max(m,n))，假设 m 和 n 分别表示 l1 和 l2 的长度，上面的算法最多重复max(m,n) 次。<br>
空间复杂度：O(max(m,n))， 新列表的长度最多为 max(m,n)+1。</p>
</blockquote>
<p>拓展</p>
<p>如果链表中的数字不是按逆序存储的呢？例如：<br>
(3→4→2)+(4→6→5)=8→0→7</p>
<p>最后这个拓展比较有趣，网友们的想法是利用递归或者栈，这个想法还是比较有趣的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[递归套路解决链表问题]]></title>
        <id>https://lixin-ee.github.io//post/di-gui-tao-lu-jie-jue-lian-biao-wen-ti</id>
        <link href="https://lixin-ee.github.io//post/di-gui-tao-lu-jie-jue-lian-biao-wen-ti">
        </link>
        <updated>2019-11-04T08:16:32.000Z</updated>
        <content type="html"><![CDATA[<p>递归套路解决链表问题：<br>
1.找终止条件：当head指向链表只剩一个元素的时候，自然是不可能重复的，因此return<br>
2.想想应该返回什么值：应该返回的自然是已经去重的链表的头节点<br>
3.每一步要做什么：宏观上考虑，此时head.next已经指向一个去重的链表了，而根据第二步，我应该返回一个去重的链表的头节点。因此这一步应该做的是判断当前的head和head.next是否相等，如果相等则说明重了，返回head.next，否则返回head</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 82. 删除排序链表中的重复元素 II [中等]]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-82-shan-chu-pai-xu-lian-biao-zhong-de-chong-fu-yuan-su-ii-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-82-shan-chu-pai-xu-lian-biao-zhong-de-chong-fu-yuan-su-ii-zhong-deng">
        </link>
        <updated>2019-11-04T07:50:19.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字</p>
<p>示例 1:<br>
输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5<br>
输出: 1-&gt;2-&gt;5<br>
示例 2:<br>
输入: 1-&gt;1-&gt;1-&gt;2-&gt;3<br>
输出: 2-&gt;3</p>
</blockquote>
<p>这道题是上一题<a href="https://lixin-ee.github.io/post/lian-biao-83-shan-chu-pai-xu-lian-biao-zhong-de-chong-fu-yuan-su-jian-dan/">83题</a>的进化版（为啥82题是83题的进化版？？？）<br>
主要难点在于1.判断重复点和2.删除重复点 这两个点的结合，如果使用重复点的前一个点进行删除，那么需要对重复点进行连续的判断比如示例1中的3-3-4-4，就需要在2的结点就进行连续的删除了。<br>
我的思路也是用while不断地判断，然后针对多个重复值（特别是奇数的情况）先保留一个val值，让cur能够直接指向第一个不同于val 的结点<br>
最终代码如下：</p>
<pre><code>class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        while(head==NULL||head-&gt;next==NULL)
            return head;
        ListNode* ehead=new ListNode(-1);
        ehead-&gt;next=head;
        int val=-1;
        ListNode* cur=ehead;
        while(cur!=NULL){
            while(cur-&gt;next!=NULL&amp;&amp;cur-&gt;next-&gt;next!=NULL&amp;&amp;cur-&gt;next-&gt;val==cur-&gt;next-&gt;next-&gt;val){
                val=cur-&gt;next-&gt;val;
                while(cur-&gt;next!=NULL&amp;&amp;cur-&gt;next-&gt;val==val)
                    cur-&gt;next=cur-&gt;next-&gt;next;
            }
            cur=cur-&gt;next;
        }
        return ehead-&gt;next;
    }
};
</code></pre>
<p>注意各种NULL的判断都是不可少的，链表的第一注意点就是结点是否为null<br>
然后是网友题解：<br>
思路:<br>
思路一: 迭代 快慢指针,用快指针跳过那些有重复数组,慢指针负责和快指针拼接!</p>
<pre><code>class Solution:
    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:
        if head == None or head.next == None:
            return head
        dummy = ListNode(-1000)
        dummy.next = head
        slow = dummy
        fast = dummy.next
        while fast:
            if  fast.next and fast.next.val == fast.val:
                tmp = fast.val
                while fast and tmp == fast.val:
                    fast = fast.next
            else:
                slow.next = fast
                slow = fast
                fast = fast.next
        slow.next = fast
        return dummy.next
</code></pre>
<p>思路一(另一个版本):</p>
<pre><code>class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null) return head;
        ListNode dummy = new ListNode(-1000);
        dummy.next = head;
        ListNode slow = dummy;
        ListNode fast = dummy.next;
        while (fast != null) {
            while (fast.next != null &amp;&amp; fast.val == fast.next.val) fast = fast.next;
            if (slow.next == fast) slow = slow.next;
            else slow.next = fast.next;
            fast = fast.next;
        }
        return dummy.next; 
    }
}
</code></pre>
<p>思路二:递归</p>
<pre><code>class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null)  return head;
        if (head.next != null &amp;&amp; head.val == head.next.val) {
            while (head.next != null &amp;&amp; head.val == head.next.val) {
                head = head.next;
            }
            return deleteDuplicates(head.next);
        }
        else head.next = deleteDuplicates(head.next);
        return head;    
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 203.移除链表元素[简单]]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-203yi-chu-lian-biao-yuan-su-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-203yi-chu-lian-biao-yuan-su-jian-dan">
        </link>
        <updated>2019-11-03T01:45:21.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>删除链表中等于给定值 val 的所有节点。</p>
<p>示例:<br>
输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6<br>
输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</p>
</blockquote>
<p>思路：<br>
1.这道主要是不能单纯地检测当前指针的val，而是应该检查next的val。<br>
2.这道题需要先检查头节点以及头节点之后的结点是否和val相等，如果相等的话需要先删除前面的结点。</p>
<pre><code>class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        if(head==NULL)
            return head;
        while(head-&gt;val==val){
            if(head-&gt;next==NULL)
                return NULL;
            head=head-&gt;next;
        }
        ListNode* cur=head;
        while(cur!=NULL){
            while(cur-&gt;next!=NULL&amp;&amp;cur-&gt;next-&gt;val==val){
                cur-&gt;next=cur-&gt;next-&gt;next;
            }
            cur=cur-&gt;next;
        }
        return head;
    }
};
</code></pre>
<p>然后看一下网友题解删除结点的步骤</p>
<blockquote>
<p>找到该结点的前一个结点<br>
进行删除操作<br>
三种方法：</p>
<p>删除头结点时另做考虑（由于头结点没有前一个结点）<br>
添加一个虚拟头结点，删除头结点就不用另做考虑<br>
递归</p>
<p>方法一（删除头结点时另做考虑）</p>
</blockquote>
<pre><code>class Solution {
    public ListNode removeElements(ListNode head, int val) {
        //删除值相同的头结点后，可能新的头结点也值相等，用循环解决
        while(head!=null&amp;&amp;head.val==val){
            head=head.next;
        }
        if(head==null)
            return head;
        ListNode prev=head;
        //确保当前结点后还有结点
        while(prev.next!=null){
            if(prev.next.val==val){
                prev.next=prev.next.next;
            }else{
                prev=prev.next;
            }
        }
        return head;
    }
}
</code></pre>
<p>方法二（添加一个虚拟头结点）</p>
<pre><code>class Solution {
    public ListNode removeElements(ListNode head, int val) {
        //创建一个虚拟头结点
        ListNode dummyNode=new ListNode(val-1);
        dummyNode.next=head;
        ListNode prev=dummyNode;
        //确保当前结点后还有结点
        while(prev.next!=null){
            if(prev.next.val==val){
                prev.next=prev.next.next;
            }else{
                prev=prev.next;
            }
        }
        return dummyNode.next;
    }
}
</code></pre>
<p>方法三（递归）</p>
<pre><code>class Solution {
    public ListNode removeElements(ListNode head, int val) {
       if(head==null)
           return null;
        head.next=removeElements(head.next,val);
        if(head.val==val){
            return head.next;
        }else{
            return head;
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 83. 删除排序链表中的重复元素[简单]]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-83-shan-chu-pai-xu-lian-biao-zhong-de-chong-fu-yuan-su-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-83-shan-chu-pai-xu-lian-biao-zhong-de-chong-fu-yuan-su-jian-dan">
        </link>
        <updated>2019-11-02T01:43:41.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p>
<p>示例 1:<br>
输入: 1-&gt;1-&gt;2<br>
输出: 1-&gt;2<br>
示例 2:<br>
输入: 1-&gt;1-&gt;2-&gt;3-&gt;3<br>
输出: 1-&gt;2-&gt;3</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>想法<br>
(之前)hhh因为之前做数组的时候用过很6的快慢指针，所以也是用的快慢指针</p>
<pre><code>class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(head==NULL||head-&gt;next==NULL)
            return head;
        ListNode* fast=head;
        ListNode* slow=head;
        while(fast!=NULL&amp;&amp;fast-&gt;next!=NULL){
            while(fast!=NULL&amp;&amp;fast-&gt;val==slow-&gt;val)
                fast=fast-&gt;next;
            slow-&gt;next=fast;
            slow=fast;
        }
        return head;     
    }
};
</code></pre>
<p>（11.2）发现自己想复杂了，可以直接使用一个cur指针，判断下一个值是否和当前相等，相等的话就修改next指向的值。</p>
<p>然后来看下网友题解：<br>
解法1：双指针法</p>
<pre><code>class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(head==NULL||head-&gt;next==NULL)
            return head;
        ListNode* p=head;//慢指针
        ListNode* q=head-&gt;next;//快指针
        while(p-&gt;next!=NULL)
        {
            if(p-&gt;val==q-&gt;val)//找到重复元素
            {
                if(q-&gt;next==NULL)//快指针后面若没有元素直接剔除
                    p-&gt;next=NULL;
                else//快指针后有元素
                {
                    p-&gt;next=q-&gt;next;
                    q=q-&gt;next;
                }
            }
            else //元素不相等
            {
                p=p-&gt;next;
                q=q-&gt;next;
            }
        }
        return head;
    }
};
</code></pre>
<p>解法2：直接法（一个指针操作）</p>
<pre><code>class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(!head||!head-&gt;next)
            return head;
        ListNode* p=head;
        while(p-&gt;next!=NULL&amp;&amp;p!=NULL)
        {
            if(p-&gt;val == p-&gt;next-&gt;val)
            {
                p-&gt;next=p-&gt;next-&gt;next;
            }
            else 
                p=p-&gt;next;
        }
        return head;
    }
};
</code></pre>
<p>解法3：递归法</p>
<pre><code>class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(!head||!head-&gt;next)
            return head;
        head-&gt;next=deleteDuplicates(head-&gt;next);
        if(head-&gt;val==head-&gt;next-&gt;val) head=head-&gt;next;
        return head;
    }
};
</code></pre>
<blockquote>
<p>递归套路解决链表问题：<br>
找终止条件：当head指向链表只剩一个元素的时候，自然是不可能重复的，因此return<br>
想想应该返回什么值：应该返回的自然是已经去重的链表的头节点<br>
每一步要做什么：宏观上考虑，此时head.next已经指向一个去重的链表了，而根据第二步，我应该返回一个去重的链表的头节点。因此这一步应该做的是判断当前的head和head.next是否相等，如果相等则说明重了，返回head.next，否则返回head</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode链表测试代码]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-ce-shi</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-ce-shi">
        </link>
        <updated>2019-11-01T14:35:47.000Z</updated>
        <content type="html"><![CDATA[<p>注意在C++里面ListNode已经是定义好的类了，不需要重复定义了。<br>
本代码主要是建立一个链表方便在playground中进行测试，但是注意输出其返回值的话不会像测试用例那样会输出整个链表。</p>
<pre><code>int main() {
    ListNode n5(5);
    ListNode n4(4);
    ListNode n3(3);
    ListNode n2(2);
    ListNode n1(1);
    ListNode *head=&amp;n1;
    n1.next=&amp;n2;
    n2.next=&amp;n3;
    n3.next=&amp;n4;
    n4.next=&amp;n5;
    cout&lt;&lt;swapPairs(head)-&gt;val&lt;&lt;endl;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 19. 删除链表的倒数第N个节点[中等]]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-19-shan-chu-lian-biao-de-dao-shu-di-n-ge-jie-dian-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-19-shan-chu-lian-biao-de-dao-shu-di-n-ge-jie-dian-zhong-deng">
        </link>
        <updated>2019-11-01T00:21:02.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
<p>示例：<br>
给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.<br>
当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.<br>
说明：<br>
给定的 n 保证是有效的。<br>
进阶：<br>
你能尝试使用一趟扫描实现吗？</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>思路<br>
如果需要一趟扫描的话，因为链表的长度是未知的，除非牺牲空间复杂度，否则是做不到一趟扫描的，所以必须使用递归，在递归函数中附上n和变量的引用用来记录逆向的计数<br>
最终代码如下</p>
<pre><code>class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        int loc=0;
        ListNode* ehead=new ListNode(0);
        ehead-&gt;next=head;
        delNth(ehead,loc,n);
        return ehead-&gt;next;
    }
    
    ListNode* delNth(ListNode* lb,int &amp;loc,int n){
        ListNode* pre;
        if(lb-&gt;next!=NULL)
            pre=delNth(lb-&gt;next,loc,n);
        
        if(loc==n){
            lb-&gt;next=pre-&gt;next;
        }
        ++loc;
        return lb;
        
    }
};
</code></pre>
<p>需要注意的就是传入loc的必须是引用，传入n最好设置为const</p>
<p>然后来看一下官方题解：</p>
<blockquote>
<p>摘要<br>
本文适用于初学者。它介绍了以下内容：链表的遍历和删除其末尾的第 n 个元素。<br>
方法一：两次遍历算法<br>
思路<br>
我们注意到这个问题可以容易地简化成另一个问题：删除从列表开头数起的第 (L - n + 1)个结点，其中 L 是列表的长度。只要我们找到列表的长度 L，这个问题就很容易解决。<br>
算法<br>
首先我们将添加一个哑结点作为辅助，该结点位于列表头部。哑结点用来简化某些极端情况，例如列表中只含有一个结点，或需要删除列表的头部。在第一次遍历中，我们找出列表的长度 L。然后设置一个指向哑结点的指针，并移动它遍历列表，直至它到达第 (L - n)个结点那里。我们把第 (L - n) 个结点的 next 指针重新链接至第 (L - n + 2)个结点，完成这个算法。</p>
</blockquote>
<pre><code>public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    int length  = 0;
    ListNode first = head;
    while (first != null) {
        length++;
        first = first.next;
    }
    length -= n;
    first = dummy;
    while (length &gt; 0) {
        length--;
        first = first.next;
    }
    first.next = first.next.next;
    return dummy.next;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(L)，该算法对列表进行了两次遍历，首先计算了列表的长度 L 其次找到第 (L - n) 个结点。 操作执行了 2L−n 步，时间复杂度为 O(L)。<br>
空间复杂度：O(1)，我们只用了常量级的额外空间。</p>
<p>方法二：一次遍历算法<br>
算法<br>
上述算法可以优化为只使用一次遍历。我们可以使用两个指针而不是一个指针。第一个指针从列表的开头向前移动 n+1 步，而第二个指针将从列表的开头出发。现在，这两个指针被 n 个结点分开。我们通过同时移动两个指针向前来保持这个恒定的间隔，直到第一个指针到达最后一个结点。此时第二个指针将指向从最后一个结点数起的第 n 个结点。我们重新链接第二个指针所引用的结点的 next 指针指向该结点的下下个结点。</p>
</blockquote>
<pre><code>public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode first = dummy;
    ListNode second = dummy;
    // Advances first pointer so that the gap between first and second is n nodes apart
    for (int i = 1; i &lt;= n + 1; i++) {
        first = first.next;
    }
    // Move first to the end, maintaining the gap
    while (first != null) {
        first = first.next;
        second = second.next;
    }
    second.next = second.next.next;
    return dummy.next;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(L)，该算法对含有 L 个结点的列表进行了一次遍历。因此时间复杂度为 O(L)。<br>
空间复杂度：O(1)，我们只用了常量级的额外空间。</p>
</blockquote>
<p>解法一的哑结点就是我设置的ehead（不愧是我！hhh），然而解法二很妙啊，巧妙地利用两个指针的距离，比我的递归更简洁。</p>
]]></content>
    </entry>
</feed>