<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2020-01-26T02:05:29.746Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[树 968. 监控二叉树 [困难][未做出]]]></title>
        <id>https://lixin-ee.github.io//post/shu-968-jian-kong-er-cha-shu-kun-nan-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/shu-968-jian-kong-er-cha-shu-kun-nan-wei-zuo-chu">
        </link>
        <updated>2020-01-26T01:43:07.000Z</updated>
        <content type="html"><![CDATA[<p>示例 1：<br>
<img src="https://lixin-ee.github.io//post-images/1580003119532.png" alt=""><br>
示例 2：<br>
<img src="https://lixin-ee.github.io//post-images/1580003651384.png" alt=""></p>
<blockquote>
<p>给定一个二叉树，我们在树的节点上安装摄像头。<br>
节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。<br>
计算监控树的所有节点所需的最小摄像头数量。<br>
示例 1：<br>
输入：[0,0,null,0,0]<br>
输出：1<br>
解释：如图所示，一台摄像头足以监控所有节点。<br>
示例 2：<br>
输入：[0,0,null,0,null,0,null,null,0]<br>
输出：2<br>
解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。<br>
提示：<br>
给定树的节点数的范围是 [1, 1000]。<br>
每个节点的值都是 0。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/binary-tree-cameras<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>一开始用的是迭代的奇偶层次法，提交了才发现挺笨的，因为如果是6层，每层1个节点的话，其实只需要在2和5层装就行了，不需要136或者245<br>
思考了一下 还是得靠动态规划</p>
<p>一开始以为是类似入室盗窃那道题的两种状态，看了题解发现三种状态更加好，然后注意这种父节点的值依赖于子节点的题是无法使用迭代法的</p>
<p>实现过程中发现头节点需要单独处理，因为它没有父节点可以监控他，看了题解 发现可以装载一个虚拟头节点（注意 我们所需要的只是监控的数量而不是节点，所以ehead的监控可以算到root的头上，比如root是0，需要ehead是1，此时虽然root是被监控，但是实际上ehead的监控算到cur头上，所以最终返回的数量是一致的）</p>
<p>我的实现用了三种状态 1-监控态 0-未被监控态 -1-被监控态 其中NULL节点为-1态，意味着不需要处理 叶子节点为0，因为我们总是希望叶子节点的父节点来监控以取得最大收益（父节点至少可以监控两个，叶子节点只能监控一个），当然这也是导致root需要ehead的原因 否则root自身就是叶节点返回0的话就木大了</p>
<p>递归逻辑中，必须优先处理的就是子节点为0的情况，此时必须监控。然后就是如果叶节点都不为0而且有个监控的话，当前节点就可以返回-1了，其他情况统统返回0（比如叶子节点都是被监控的，此时自己加监控收益低，还是给父节点去考虑），注意此处不能判断叶子节点都为-1，否则会因为情况判断不完全而产生不返回的错误</p>
<p>然后在实现的时候遇到一个啼笑皆非的问题，int right=preorder(cur-&gt;right,res);这行代码中cur-&gt;right写成了cur-right，本来应该报错符号的，但是恰好定义了int的right，导致识别为减号，报错内存溢出。。。</p>
<pre><code>class Solution {
public:
    int minCameraCover(TreeNode* root) {
        if(root==NULL) return 0;
        int res=0;
        TreeNode* ehead=new TreeNode(0);
        ehead-&gt;left=root;
        preorder(ehead,res);
        return res;
    }
    
    int preorder(TreeNode *cur,int &amp;res){
        if(cur==NULL)
            return -1;
        if(cur-&gt;left==NULL&amp;&amp;cur-&gt;right==NULL){
            return 0;
        }
        int left=preorder(cur-&gt;left,res);
        int right=preorder(cur-&gt;right,res);
        if(left==0||right==0){
            ++res;
            return 1;
        }
        if(left==1||right==1)
            return -1;
        //if(left==-1&amp;&amp;right==-1)
            return 0;    
    }
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>当遍历到一个节点时，我们可以定义三种状态：<br>
0 ： 初始状态，如果节点为null可以返回，也就是不影响其他节点，当两个节点都是0时，我们直接设置当前节点为未监控状态<br>
1： 未监控状态，如果子节点含有该状态，则此节点必须添加摄像头，同时返回当前状态为监控态<br>
2： 监控态，表明此节点已经被监控，当子节点为此状态时，父节点不需要添加摄像头，可以返回初始态</p>
</blockquote>
<pre><code>private int dfs(TreeNode node){
        if (node == null) return 0;

        int l = dfs(node.left);
        int r = dfs(node.right);

        if (l + r == 0)  
            return 1;
        else if (l == 1 || r == 1) {
            cameras ++; return 2;
        } else  
            return 0;
    }
</code></pre>
<blockquote>
<p>当调用时，有一个小技巧，我们需要为传入的根节点添加一个虚拟的头，因为向上遍历时，根节点的监控状态我们无法保证，所以添加一个虚拟头可以简化编程。</p>
</blockquote>
<pre><code>public int minCameraCover(TreeNode root) {
        TreeNode dummyHead = new TreeNode(0);
        dummyHead.left = root;
        dfs(dummyHead);
        return cameras;
    }
</code></pre>
<blockquote>
<p>时间复杂度O(N)<br>
空间复杂度如果不算递归的隐式调用栈，为O(1),否则为O(h),h为树的高度。</p>
</blockquote>
<p>网友题解里面的判断条件用了加法，虽然不太直观，但是非常巧妙</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 628. 三个数的最大乘积[简单]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-628-san-ge-shu-de-zui-da-cheng-ji-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-628-san-ge-shu-de-zui-da-cheng-ji-jian-dan">
        </link>
        <updated>2020-01-25T03:02:35.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。<br>
示例 1:<br>
输入: [1,2,3]<br>
输出: 6<br>
示例 2:<br>
输入: [1,2,3,4]<br>
输出: 24<br>
注意:<br>
给定的整型数组长度范围是[3,104]，数组中所有的元素范围是[-1000, 1000]。<br>
输入的数组中任意三个数的乘积不会超出32位有符号整数的范围。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/maximum-product-of-three-numbers<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>比较棘手的就是负数了，如果负数纳入考虑的话，就必须是两个负数。。。<br>
比较智障的方法就是保存五个数，用贪心法来更新hhh<br>
突然发现不太对劲，因为每次更新都要去除一个最小值，那么就得不断排序更新</p>
<p>我一开始还是实现比较笨的方法<br>
另外一个问题就是如何确定有没有被初始化，如果是数组全是负数的话结果还是负数，但是我一开始返回的结果是0，因为值都初始化为0了<br>
于是打算改成用set来管理 让set自动排序<br>
算了直接用sort吧</p>
<p>看了题解后发现第一个方法还是最优解，只是赋值不能是0，必须是最大最小值，然后判断起来比较麻烦 而且不能像我那样区分开负数和正数，比如1，2，3中，1应该也付给min_1</p>
<pre><code>class Solution {
public:
    int maximumProduct(vector&lt;int&gt;&amp; nums){
        int max_1=INT_MIN,max_2=INT_MIN,max_3=INT_MIN;
        int min_1=INT_MAX,min_2=INT_MAX;
        for(auto i:nums){
            if(i&gt;max_1)
                swap(max_3,max_2),swap(max_2,max_1),max_1=i;
            else if(i&gt;max_2)
                swap(max_3,max_2),max_2=i;
            else if(i&gt;max_3)
                max_3=i;
            if(i&lt;min_1)
                swap(min_2,min_1),min_1=i;
            else if(i&lt;min_2)
                min_2=i;
        }
        return max_1*max_2*max_3&gt;max_1*min_1*min_2?max_1*max_2*max_3:max_1*min_1*min_2;
    }
		/*//排序法
    int maximumProduct(vector&lt;int&gt;&amp; nums) {
        int len=nums.size();
        sort(nums.begin(),nums.end());
        return nums[len-1]*nums[len-2]*nums[len-3]&gt;nums[len-1]*nums[0]*nums[1]?nums[len-1]*nums[len-2]*nums[len-3]:nums[len-1]*nums[0]*nums[1];

    }
    */
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>方法一：排序<br>
我们将数组进行升序排序，如果数组中所有的元素都是非负数，那么答案即为最后三个元素的乘积。<br>
如果数组中出现了负数，那么我们还需要考虑乘积中包含负数的情况，显然选择最小的两个负数和最大的一个正数是最优的，即为前两个元素与最后一个元素的乘积。<br>
上述两个结果中的较大值就是答案。注意我们可以不用判断数组中到底有没有正数，0 或者负数，因为上述两个结果实际上已经包含了所有情况，最大值一定在其中。</p>
</blockquote>
<pre><code>Java
public class Solution {
    public int maximumProduct(int[] nums) {
        Arrays.sort(nums);
        return Math.max(nums[0] * nums[1] * nums[nums.length - 1], nums[nums.length - 1] * nums[nums.length - 2] * nums[nums.length - 3]);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(NlogN)，其中 N 是数组的长度。<br>
空间复杂度：O(logN)，为排序使用的空间。</p>
</blockquote>
<blockquote>
<p>方法二：线性扫描<br>
在方法一中，我们实际上只要求出数组中最大的三个数以及最小的两个数，因此我们可以不用排序，用线性扫描直接得出这五个数。</p>
</blockquote>
<pre><code>Java
public class Solution {
    public int maximumProduct(int[] nums) {
        int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;
        int max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE, max3 = Integer.MIN_VALUE;
        for (int n: nums) {
            if (n &lt;= min1) {
                min2 = min1;
                min1 = n;
            } else if (n &lt;= min2) {     // n lies between min1 and min2
                min2 = n;
            }
            if (n &gt;= max1) {            // n is greater than max1, max2 and max3
                max3 = max2;
                max2 = max1;
                max1 = n;
            } else if (n &gt;= max2) {     // n lies betweeen max1 and max2
                max3 = max2;
                max2 = n;
            } else if (n &gt;= max3) {     // n lies betwen max2 and max3
                max3 = n;
            }
        }
        return Math.max(min1 * min2 * max1, max1 * max2 * max3);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(N)。<br>
空间复杂度：O(1)。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 543. 二叉树的直径[简单]]]></title>
        <id>https://lixin-ee.github.io//post/shu-543-er-cha-shu-de-zhi-jing-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/shu-543-er-cha-shu-de-zhi-jing-jian-dan">
        </link>
        <updated>2020-01-24T02:37:32.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。<br>
示例 :<br>
给定二叉树<br>
1<br>
/ <br>
2   3<br>
/ \<br>
4   5<br>
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。<br>
注意：两结点之间的路径长度是以它们之间边的数目表示。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/diameter-of-binary-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这个问题可以转化为找某个节点的左右子树的深度之和（注意不一定就是根节点，有可能没有左右子树之一）<br>
递归倒是很简单，直接从叶子节点的1开始算起，每个非叶节点就计算左子树和右子树之和，再取两者的较大者+1返回<br>
迭代比较难，我想到的是先存入父节点、右子树和左子树，但是不知道怎么把层数回传给父节点<br>
后来想到用map来存,还是没法从叶节点开始回溯啊。。。</p>
<pre><code>class Solution {
public:        
    // 递归版
    int diameterOfBinaryTree(TreeNode* root) {
        if(root==NULL) return 0;
        int max_res=0;
        tree_deep(root,max_res);
        return max_res;
    }
    
    int tree_deep(TreeNode *cur,int &amp;max_res){
        int deep=0;
        if(cur-&gt;left==NULL&amp;&amp;cur-&gt;right==NULL)
            return 1;
        int left_deep,right_deep;
        if(cur-&gt;left)
            left_deep=tree_deep(cur-&gt;left,max_res);
        else
            left_deep=0;
        if(cur-&gt;right)
            right_deep=tree_deep(cur-&gt;right,max_res);
        else
            right_deep=0;
        max_res=max_res&gt;left_deep+right_deep?max_res:left_deep+right_deep;
        return left_deep&gt;right_deep?left_deep+1:right_deep+1;
    }
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>方法 1：深度优先搜索<br>
想法<br>
任意一条路径可以被写成两个 箭头（不同方向），每个箭头代表一条从某些点向下遍历到孩子节点的路径。<br>
假设我们知道对于每个节点最长箭头距离分别为 L, R，那么最优路径经过 L + R + 1 个节点。<br>
算法<br>
按照常用方法计算一个节点的深度：max(depth of node.left, depth of node.right) + 1。在计算的同时，经过这个节点的路径长度为 1 + (depth of node.left) + (depth of node.right) 。搜索每个节点并记录这些路径经过的点数最大值，期望长度是结果 - 1。</p>
</blockquote>
<pre><code>java
class Solution {
    int ans;
    public int diameterOfBinaryTree(TreeNode root) {
        ans = 1;
        depth(root);
        return ans - 1;
    }
    public int depth(TreeNode node) {
        if (node == null) return 0;
        int L = depth(node.left);
        int R = depth(node.right);
        ans = Math.max(ans, L+R+1);
        return Math.max(L, R) + 1;
    }
}
</code></pre>
<p>复杂度分析<br>
时间复杂度：O(N)，每个节点只访问一次。<br>
空间复杂度：O(N)，深度优先搜索的栈开销。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[队列 232. 用栈实现队列[简单]]]></title>
        <id>https://lixin-ee.github.io//post/dui-lie-232-yong-zhan-shi-xian-dui-lie-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/dui-lie-232-yong-zhan-shi-xian-dui-lie-jian-dan">
        </link>
        <updated>2020-01-23T01:25:01.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>使用栈实现队列的下列操作：<br>
push(x) -- 将一个元素放入队列的尾部。<br>
pop() -- 从队列首部移除元素。<br>
peek() -- 返回队列首部的元素。<br>
empty() -- 返回队列是否为空。<br>
示例:<br>
MyQueue queue = new MyQueue();<br>
queue.push(1);<br>
queue.push(2);<br>
queue.peek();  // 返回 1<br>
queue.pop();   // 返回 1<br>
queue.empty(); // 返回 false<br>
说明:<br>
你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。<br>
你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。<br>
假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/implement-queue-using-stacks<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>和队列模拟栈一样，我利用两个stack，因为每次插入需要在后面插入，所以需要一个temp来存储cur的已有值，插入后再将temp值返回到cur中</p>
<p>题解中显示无法用一个栈来实现，但是官方题解有一个比较巧妙的双栈，一个用来push，一个用来pop，摊还分析复杂度是常数分析<br>
这里可以单独详细看看摊还分析</p>
<pre><code>class MyQueue {
public:
    /** Initialize your data structure here. */
    MyQueue() {
        
    }
    stack&lt;int&gt; cur,temp;
    /** Push element x to the back of queue. */
    void push(int x) {
        temp.push(x);
   /*
        if(cur.size())
            while(cur.size())
                temp.push(cur.top()),cur.pop();
        cur.push(x);
        while(temp.size())
            cur.push(temp.top()),temp.pop();
  */
    }
    
    /** Removes the element from in front of queue and returns that element. */
    int pop() {
        if(cur.empty())
          while(temp.size())
              cur.push(temp.top()),temp.pop();
        int temp_i=cur.top();
        cur.pop();
        return temp_i;
        /*
        int temp_i=cur.top();
        cur.pop();
        return temp_i;
        */
    }
    
    /** Get the front element. */
    int peek() {
        if(cur.empty())
          while(temp.size())
              cur.push(temp.top()),temp.pop();
        return cur.top();
    }
    
    /** Returns whether the queue is empty. */
    bool empty() {
        return !(cur.size()||temp.size());
    }
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>题解<br>
队列是一种 先进先出（first in - first out， FIFO）的数据结构，队列中的元素都从后端（rear）入队（push），从前端（front）出队（pop）。<br>
实现队列最直观的方法是用链表，但在这篇文章里我会介绍另一个方法 - 使用栈。<br>
栈是一种 后进先出（last in - first out， LIFO）的数据结构，栈中元素从栈顶（top）压入（push)，也从栈顶弹出（pop）。<br>
为了满足队列的 FIFO 的特性，我们需要用到两个栈，用它们其中一个来反转元素的入队顺序，用另一个来存储元素的最终顺序。</p>
</blockquote>
<blockquote>
<p>方法一（使用两个栈 入队 - O(n)， 出队 - O(1)）<br>
算法<br>
入队（push）<br>
一个队列是 FIFO 的，但一个栈是 LIFO 的。这就意味着最新压入的元素必须得放在栈底。为了实现这个目的，我们首先需要把 s1 中所有的元素移到 s2 中，接着把新元素压入 s2。最后把 s2 中所有的元素弹出，再把弹出的元素压入 s1。</p>
</blockquote>
<pre><code>private int front;

public void push(int x) {
    if (s1.empty())
        front = x;
    while (!s1.isEmpty())
        s2.push(s1.pop());
    s2.push(x);
    while (!s2.isEmpty())
        s1.push(s2.pop());
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)<br>
对于除了新元素之外的所有元素，它们都会被压入两次，弹出两次。新元素只被压入一次，弹出一次。这个过程产生了 4n+2 次操作，其中 n 是队列的大小。由于 压入 操作和 弹出 操作的时间复杂度为O(1)， 所以时间复杂度为O(n)。<br>
空间复杂度：O(n)<br>
需要额外的内存来存储队列中的元素。</p>
</blockquote>
<blockquote>
<p>出队（pop）<br>
直接从 s1 弹出就可以了，因为 s1 的栈顶元素就是队列的队首元素。同时我们把弹出之后 s1 的栈顶元素赋值给代表队首元素的 front 变量。</p>
</blockquote>
<pre><code>// Removes the element from the front of queue.
public void pop() {
    s1.pop();
    if (!s1.empty())
        front = s1.peek();
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(1)<br>
空间复杂度：O(1)<br>
判断空（empty）<br>
s1 存储了队列所有的元素，所以只需要检查 s1 的是否为空就可以了。</p>
</blockquote>
<pre><code>Java
// Return whether the queue is empty.
public boolean empty() {
    return s1.isEmpty();
}
</code></pre>
<blockquote>
<p>时间复杂度：O(1)<br>
空间复杂度：O(1)<br>
取队首元素（peek）<br>
在我们的算法中，用了 front 变量来存储队首元素，在每次 入队 操作或者 出队 操作之后这个变量都会随之更新。</p>
</blockquote>
<pre><code>Java
// Get the front element.
public int peek() {
  return front;
}
</code></pre>
<blockquote>
<p>时间复杂度：O(1)<br>
队首元素（front）已经被提前计算出来了，同时也只有 peek 操作可以得到它的值。<br>
空间复杂度：O(1)</p>
</blockquote>
<blockquote>
<p>方法二（使用两个栈 入队 - O(1)，出队 - 摊还复杂度 O(1)）<br>
算法<br>
入队（push）<br>
新元素总是压入 s1 的栈顶，同时我们会把 s1 中压入的第一个元素赋值给作为队首元素的 front 变量。</p>
</blockquote>
<pre><code>private Stack&lt;Integer&gt; s1 = new Stack&lt;&gt;();
private Stack&lt;Integer&gt; s2 = new Stack&lt;&gt;();

// Push element x to the back of queue.
public void push(int x) {
    if (s1.empty())
        front = x;
    s1.push(x);
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(1)<br>
向栈压入元素的时间复杂度为O(1)<br>
空间复杂度：O(n)<br>
需要额外的内存来存储队列元素</p>
</blockquote>
<blockquote>
<p>出队（pop）<br>
根据栈 LIFO 的特性，s1 中第一个压入的元素在栈底。为了弹出 s1 的栈底元素，我们得把 s1 中所有的元素全部弹出，再把它们压入到另一个栈 s2 中，这个操作会让元素的入栈顺序反转过来。通过这样的方式，s1 中栈底元素就变成了 s2 的栈顶元素，这样就可以直接从 s2 将它弹出了。一旦 s2 变空了，我们只需把 s1 中的元素再一次转移到 s2 就可以了。</p>
</blockquote>
<pre><code>// Removes the element from in front of queue.
public void pop() {
    if (s2.isEmpty()) {
        while (!s1.isEmpty())
            s2.push(s1.pop());
    }
    s2.pop();    
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度： 摊还复杂度 O(1)，最坏情况下的时间复杂度 O(n)<br>
在最坏情况下，s2 为空，算法需要从 s1 中弹出 n 个元素，然后再把这 n 个元素压入 s2，在这里n代表队列的大小。这个过程产生了 2n 步操作，时间复杂度为 O(n)。但当 s2 非空时，算法就只有 O(1) 的时间复杂度。所以为什么叫做摊还复杂度 O(1) 呢？ 读了下一章你就知道了。<br>
空间复杂度 ：O(1)</p>
</blockquote>
<blockquote>
<p>摊还分析<br>
摊还分析给出了所有操作的平均性能。摊还分析的核心在于，最坏情况下的操作一旦发生了一次，那么在未来很长一段时间都不会再次发生，这样就会均摊每次操作的代价。<br>
来看下面这个例子，从一个空队列开始，依次执行下面这些操作：<br>
push 1 ,push 2 ,…,push n ,pop 1 ,pop 2	 …,pop n<br>
单次 出队 操作最坏情况下的时间复杂度为 O(n)。考虑到我们要做 n 次出队操作，如果我们用最坏情况下的时间复杂度来计算的话，那么所有操作的时间复杂度为 O(n^2)。<br>
然而，在一系列的操作中，最坏情况不可能每次都发生，可能一些操作代价很小，另一些代价很高。因此，如果用传统的最坏情况分析，那么给出的时间复杂度是远远大于实际的复杂度的。例如，在一个动态数组里面只有一些插入操作需要花费线性的时间，而其余的一些插入操作只需花费常量的时间。<br>
在上面的例子中，出队 操作最多可以执行的次数跟它之前执行过 入队 操作的次数有关。虽然一次 出队 操作代价可能很大，但是每 n 次 入队 才能产生这么一次代价为 n 的 出队 操作。因此所有操作的总时间复杂度为：n(所有的入队操作产生） + 2 * n(第一次出队操作产生） + n - 1(剩下的出队操作产生）， 所以实际时间复杂度为 O(2*n)。于是我们可以得到每次操作的平均时间复杂度为 O(2n/2n)=O(1)。</p>
</blockquote>
<blockquote>
<p>判断空（empty）<br>
s1 和 s2 都存有队列的元素，所以只需要检查 s1 和 s2 是否都为空就可以了。</p>
</blockquote>
<pre><code>Java
// Return whether the queue is empty.
public boolean empty() {
    return s1.isEmpty() &amp;&amp; s2.isEmpty();
}
</code></pre>
<blockquote>
<p>时间复杂度：O(1)<br>
空间复杂度：O(1)</p>
</blockquote>
<blockquote>
<p>取队首元素（peek)<br>
我们定义了 front 变量来保存队首元素，每次 入队 操作我们都会随之更新这个变量。当 s2 为空，front 变量就是对首元素，当 s2 非空，s2 的栈顶元素就是队首元素。</p>
</blockquote>
<pre><code>Java
// Get the front element.
public int peek() {
    if (!s2.isEmpty()) {
        return s2.peek();
    }
    return front;
}
</code></pre>
<blockquote>
<p>时间复杂度：O(1)<br>
队首元素要么是之前就被计算出来的，要么就是 s2 栈顶元素。因此时间复杂度为 O(1)。<br>
空间复杂度：O(1)</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[栈 225. 用队列实现栈[简单]]]></title>
        <id>https://lixin-ee.github.io//post/zhan-225-yong-dui-lie-shi-xian-zhan-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/zhan-225-yong-dui-lie-shi-xian-zhan-jian-dan">
        </link>
        <updated>2020-01-21T12:08:13.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>使用队列实现栈的下列操作：<br>
push(x) -- 元素 x 入栈<br>
pop() -- 移除栈顶元素<br>
top() -- 获取栈顶元素<br>
empty() -- 返回栈是否为空<br>
注意:<br>
你只能使用队列的基本操作-- 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。<br>
你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。<br>
你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/implement-stack-using-queues<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>我一开始只想到比较笨的方法，就是用两个队列来实现，每次push只放入cur中，并且保持cur只有一个元素，亦即栈顶元素，多余的元素push进另一个队列storage中<br>
然后就是pop的问题，如果pop使得cur为空，就需要把storage的元素push进cur里面，使得storage只剩一个栈顶元素，此时再将两者交换<br>
然后题目给的模板好坑，和c++的类似乎不相同，我在MyStack()里面定义队列是会报错的</p>
<p>题解中给的一个队列的题解不错，还是c++实现的</p>
<p>为了防止两者强行拷贝赋值，我使用了指针，然后在这一题我想探讨一下swap、move和移动赋值的问题<br>
很可惜leetcode似乎对内存的判断并不准确，又或者是queue自动触发了移动赋值，在这里的测试的内存一直不变</p>
<pre><code>class MyStack {
public:
    /** Initialize your data structure here. */

    //MyStack() {
        queue&lt;int&gt; cur,storage;

    //}

    /** Push element x onto stack. */
    void push(int x) {
        if((cur).size()){
            (storage).push((cur).front());
            (cur).pop();
        }
         (cur).push(x);     
    }
    
    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        int temp=(cur).front();
        (cur).pop();
        while((storage).size()&gt;1){
            (cur).push((storage).front());
            (storage).pop();
        }
        /*
        auto tempqueue=cur;
        cur=storage;
        storage=tempqueue;
        */
        swap(cur,storage);
        return temp;
    }
    
    /** Get the top element. */
    int top() {
        return (cur).front();
    }
    
    /** Returns whether the stack is empty. */
    bool empty() {
        if((cur).size())
            return false;
        else
            return true;
    }
};
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>因为原始的queue是先进先出，所以要通过queue实现栈，在每一次push进新元素x时，需将前面的元素移到x的后面，可以巧妙地使用q.push(q.front()); q.pop(); 代码实现如下：</p>
</blockquote>
<pre><code>class MyStack {
    queue&lt;int&gt; nums;
public:
    /** Initialize your data structure here. */
    MyStack() {
        //nothing to do
    }
    
    /** Push element x onto stack. */
    void push(int x) {
        nums.push(x);
        //将前面的size-1个元素放到后面去
        for(int i = 0; i &lt; nums.size() - 1; i++){
            nums.push(nums.front());
            nums.pop();
        }
    }
    
    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        int num = nums.front();
        nums.pop();
        return num;
    }
    
    /** Get the top element. */
    int top() {
        return nums.front();
    }
    
    /** Returns whether the stack is empty. */
    bool empty() {
        return nums.empty();
    }
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>绪论<br>
这篇文章是为初级读者准备的，文章中介绍栈和队列这两种数据结构。<br>
方法一 （两个队列，压入 -O(1)， 弹出 -O(n)）<br>
思路<br>
栈是一种 后进先出（last in - first out， LIFO）的数据结构，栈内元素从顶端压入（push），从顶端弹出（pop）。一般我们用数组或者链表来实现栈，但是这篇文章会来介绍如何用队列来实现栈。队列是一种与栈相反的 先进先出（first in - first out， FIFO）的数据结构，队列中元素只能从 后端（rear）入队（push），然后从 前端（front）端出队（pop）。为了满足栈的特性，我们需要维护两个队列 q1 和 q2。同时，我们用一个额外的变量来保存栈顶元素。<br>
算法<br>
压入（push）<br>
新元素永远从 q1 的后端入队，同时 q1 的后端也是栈的 栈顶（top）元素。</p>
</blockquote>
<pre><code>private Queue&lt;Integer&gt; q1 = new LinkedList&lt;&gt;();
private Queue&lt;Integer&gt; q2 = new LinkedList&lt;&gt;();
private int top;

// Push element x onto stack.
public void push(int x) {
    q1.add(x);
    top = x;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(1)<br>
队列是通过链表来实现的，入队（add）操作的时间复杂度为 O(1)。<br>
空间复杂度：O(1)</p>
</blockquote>
<blockquote>
<p>弹出（pop）<br>
我们需要把栈顶元素弹出，就是 q1 中最后入队的元素。<br>
考虑到队列是一种 FIFO 的数据结构，最后入队的元素应该在最后被出队。因此我们需要维护另外一个队列 q2，这个队列用作临时存储 q1 中出队的元素。q2 中最后入队的元素将作为新的栈顶元素。接着将 q1 中最后剩下的元素出队。我们通过把 q1 和 q2 互相交换的方式来避免把 q2 中的元素往 q1 中拷贝。</p>
</blockquote>
<pre><code>// Removes the element on top of the stack.
public void pop() {
    while (q1.size() &gt; 1) {
        top = q1.remove();
        q2.add(top);
    }
    q1.remove();
    Queue&lt;Integer&gt; temp = q1;
    q1 = q2;
    q2 = temp;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)<br>
算法让 q1 中的 n 个元素出队，让 nn−1 个元素从 q2 入队，在这里 n 是栈的大小。这个过程总共产生了2n−1 次操作，时间复杂度为 O(n)。</p>
</blockquote>
<blockquote>
<p>方法二 （两个队列， 压入 - O(n)， 弹出 - O(1)）<br>
算法<br>
压入（push)<br>
接下来介绍的算法让每一个新元素从 q2 入队，同时把这个元素作为栈顶元素保存。当 q1 非空（也就是栈非空），我们让 q1 中所有的元素全部出队，再将出队的元素从 q2 入队。通过这样的方式，新元素（栈中的栈顶元素）将会在 q2 的前端。我们通过将 q1， q2 互相交换的方式来避免把 q2 中的元素往 q1 中拷贝。</p>
</blockquote>
<pre><code>public void push(int x) {
    q2.add(x);
    top = x;
    while (!q1.isEmpty()) {                
        q2.add(q1.remove());
    }
    Queue&lt;Integer&gt; temp = q1;
    q1 = q2;
    q2 = temp;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)<br>
算法会让 q1 出队 n 个元素，同时入队 n+1 个元素到 q2。这个过程会产生2n+1 步操作，同时链表中 插入 操作和 移除 操作的时间复杂度为 O(1)，因此时间复杂度为 O(n)。<br>
空间复杂度：O(1)</p>
</blockquote>
<blockquote>
<p>弹出（pop）<br>
直接让 q1 中元素出队，同时将出队后的 q1 中的队首元素作为栈顶元素保存。</p>
</blockquote>
<pre><code>// Removes the element on top of the stack.
public void pop() {
    q1.remove();
    if (!q1.isEmpty()) {
    	top = q1.peek();
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(1)<br>
空间复杂度：O(1)</p>
</blockquote>
<blockquote>
<p>判断空（empty）和 取栈顶元素（top）是同样的实现方式。<br>
判断空（empty）<br>
q1 里包含了栈中所有的元素，所以只需要检查 q1 是否为空就可以了。</p>
</blockquote>
<pre><code>Java
// Removes the element on top of the stack.
public void pop() {
    q1.remove();
    if (!q1.isEmpty()) {
    	top = q1.peek();
    }
}
</code></pre>
<blockquote>
<p>时间复杂度：O(1)<br>
空间复杂度：O(1)</p>
</blockquote>
<blockquote>
<p>取栈顶元素（top）<br>
栈顶元素被保存在 top 变量里，每次我们 压入 或者 弹出 一个元素的时候都会随之更新这个变量。</p>
</blockquote>
<pre><code>Java
// Get the top element.
public int top() {
    return top;
}
</code></pre>
<blockquote>
<p>时间复杂度：O(1)<br>
栈顶元素每次都是被提前计算出来的，同时只有 top 操作可以得到它的值。<br>
空间复杂度：O(1)</p>
</blockquote>
<blockquote>
<p>方法三 （一个队列， 压入-O(n)， 弹出-O(1)）<br>
上面介绍的两个方法都有一个缺点，它们都用到了两个队列。下面介绍的方法只需要使用一个队列。<br>
算法<br>
压入（push）<br>
当我们将一个元素从队列入队的时候，根据队列的性质这个元素会存在队列的后端。<br>
但当我们实现一个栈的时候，最后入队的元素应该在前端，而不是在后端。为了实现这个目的，每当入队一个新元素的时候，我们可以把队列的顺序反转过来。</p>
</blockquote>
<pre><code>private LinkedList&lt;Integer&gt; q1 = new LinkedList&lt;&gt;();

// Push element x onto stack.
public void push(int x) {
    q1.add(x);
    int sz = q1.size();
    while (sz &gt; 1) {
        q1.add(q1.remove());
        sz--;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)<br>
这个算法需要从 q1 中出队 n 个元素，同时还需要入队 n 个元素到 q1，其中 n 是栈的大小。这个过程总共产生了2n+1 步操作。链表中 插入 操作和 移除 操作的时间复杂度为 O(1)，因此时间复杂度为 O(n)。<br>
空间复杂度：O(1)</p>
</blockquote>
<blockquote>
<p>弹出（pop）<br>
最后一个压入的元素永远在 q1 的前端，这样的话我们就能在常数时间内让它 出队。</p>
</blockquote>
<pre><code>Java
// Removes the element on top of the stack.
public void pop() {
    q1.remove();
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(1)<br>
空间复杂度：O(1)</p>
</blockquote>
<blockquote>
<p>判断空（empty）<br>
q1 中包含了栈中所有的元素，所以只需要检查 q1 是否为空就可以了。</p>
</blockquote>
<pre><code>Java
// Return whether the stack is empty.
public boolean empty() {
    return q1.isEmpty();
}
</code></pre>
<blockquote>
<p>时间复杂度：O(1)<br>
空间复杂度：O(1)</p>
</blockquote>
<blockquote>
<p>取栈顶（top）<br>
栈顶元素永远在 q1 的前端，直接返回就可以了。<br>
时间复杂度：O(1)<br>
空间复杂度：O(1)</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 347. 前 K 个高频元素[中等][未做出][堆]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-347-qian-k-ge-gao-pin-yuan-su-zhong-deng-wei-zuo-chu-dui</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-347-qian-k-ge-gao-pin-yuan-su-zhong-deng-wei-zuo-chu-dui">
        </link>
        <updated>2020-01-21T00:49:12.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。<br>
示例 1:<br>
输入: nums = [1,1,1,2,2,3], k = 2<br>
输出: [1,2]<br>
示例 2:<br>
输入: nums = [1], k = 1<br>
输出: [1]<br>
说明：<br>
你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。<br>
你的算法的时间复杂度必须优于 O(nlogn) , n 是数组的大小。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/top-k-frequent-elements<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题是我从面经题里面选出来的，已经提前知道使用堆排序或者快速排序的了。</p>
<p>看了题解发现是hashmap+最小堆 然后注意C++的优先队列priority_queue已经默认实现了大顶堆，改为great实现小顶堆<br>
但是我想实现以下暴力法的排序是怎么做到的。。。<br>
暴力法的实现：<br>
1.主要是想验证哈希表向vector的转化，之前我已经是写错了vector的模板类型，vector&lt;pair&lt;int,int&gt;&gt; freqvec(freqmap.begin(),freqmap.end());<br>
2.快速排序中如何利用pair的second进行排序</p>
<p>然后就是小顶堆的实现，题解中将hashmap得到的pair反转再存入priority还是挺有趣的<br>
实现过程中发现了个问题 如果用小顶堆的priority queue的话最后输出的结果反而频率最高的排在后面的<br>
然后在判断长度的时候不小心把push和pop的顺序搞反了，应该先push超出长度，再pop修正长度</p>
<p>我在做题的过程中发现了一个很严重的认知错误<br>
就是堆内部并非是有序的！！！！（大顶）堆仅仅保证每个结点的值都大于或等于其左右孩子结点的值！！！不能保证最后一个节点就是最小值！！！<br>
我在复现的过程中使用了大顶堆，却错误地希望headadjust(freqheap,0,k-1);   k-1来去掉最后一个数来维持数组大小<br>
其实只能通过小顶堆来去除最小值！！！</p>
<p>最后还是没法通过，还不清楚具体原因，似乎是因为我强行在头部插入再重新构建堆，而大话数据结构中是构建堆再不断地把头节点和尾节点互换（而不是新增节点）</p>
<p>所以必须使用STL源码剖析那种从叶节点到头节点的heap调整方法。。。。</p>
<p>题解实现：</p>
<pre><code>    //priority_queue实现
     vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k){
        unordered_map&lt;int,int&gt; freqmap;
        for(auto i:nums)
            if(freqmap.count(i))
                ++freqmap[i];
            else
                freqmap[i]=1;
         priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;,greater&lt;pair&lt;int,int&gt;&gt;&gt; freqque;
         for(auto i:freqmap)
             if(freqque.size()==k){
                 freqque.push({i.second,i.first});
                 freqque.pop();     
             }else
                 freqque.push({i.second,i.first});
         vector&lt;int&gt; res;
         while(k){
             res.push_back(freqque.top().second);
             freqque.pop();
             --k;
         }
         reverse(res.begin(),res.end());
         return res;
     }   
</code></pre>
<pre><code>//暴力排序法
    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) {
        unordered_map&lt;int,int&gt; freqmap;
        for(auto i:nums)
            if(freqmap.count(i))
                ++freqmap[i];
            else
                freqmap[i]=1;
        vector&lt;pair&lt;int,int&gt;&gt; freqvec(freqmap.begin(),freqmap.end());
        quicksort(freqvec,0,freqvec.size()-1);
        vector&lt;int&gt;res;
        for(int i=0;i&lt;k;++i)
            res.push_back(freqvec[i].first);
        return res;
    }
    
    void quicksort(vector&lt;pair&lt;int,int&gt;&gt; &amp;vi,int beg,int end){
        if(beg&lt;end){
            int mid=partition(vi,beg,end);
            quicksort(vi,beg,mid-1);
            quicksort(vi,mid+1,end);
        }
    }
    
    int partition(vector&lt;pair&lt;int,int&gt;&gt; &amp;vi,int low,int high){
        int pivotkey=vi[low].second;
        while(low&lt;high){
            while(low&lt;high&amp;&amp;pivotkey&gt;=vi[high].second)
                --high;
            swap(vi[low],vi[high]);
            while(low&lt;high&amp;&amp;vi[low].second&gt;=pivotkey)
                ++low;
            swap(vi[low],vi[high]);
        }
        return low;
    }
</code></pre>
<p>下面是我打算自己实现一个大顶堆，但是失败了hhh</p>
<pre><code>//错误代码
     vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k){
        unordered_map&lt;int,int&gt; freqmap;
        for(auto i:nums)
            if(freqmap.count(i))
                ++freqmap[i];
            else
                freqmap[i]=1;
         deque&lt;pair&lt;int,int&gt;&gt; freqheap;
         for(auto i:freqmap){
             if(freqheap.size()==k){
                 if(i.second&lt;freqheap.front().first)
                     continue;
                 else
                     freqheap.front()=i;
             }else
                freqheap.push_front({i.second,i.first});
             headadjust(freqheap,0,freqheap.size());         
         }
         vector&lt;int&gt; res;
         for(int i=k-1;i&gt;=0;--i)
             res.push_back(freqheap[i].second);
         return res;
     }
    
    void headadjust(deque&lt;pair&lt;int,int&gt;&gt; &amp;freqheap,int s,int len){
        auto temp=freqheap[s];
        for(int i=2*s+1;i&lt;len;i=i*2+1){
            if(i&lt;len-1&amp;&amp;freqheap[i+1].first&lt;freqheap[i].first)
                i=i+1;
            if(temp.first&lt;freqheap[i].first)
                break;
            freqheap[s]=freqheap[i];
            s=i;
        }
        freqheap[s]=temp;
    }
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>解法一：粗暴排序法<br>
最简单粗暴的思路就是 使用排序算法对元素按照频率由高到低进行排序，然后再取前 k 个元素。<br>
以下十种排序算法</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1579569348173.png" alt=""></p>
<blockquote>
<p>可以发现，使用常规的诸如 冒泡、选择、甚至快速排序都是不满足题目要求，它们的时间复杂度都是大于或者等于 O(nlog⁡n)，而题目要求算法的时间复杂度必须优于 O(nlogn)。<br>
复杂度分析<br>
时间复杂度：O(nlogn)，n 表示数组长度。首先，遍历一遍数组统计元素的频率，这一系列操作的时间复杂度是 O(n)；接着，排序算法时间复杂度为 O(nlogn)；因此整体时间复杂度为 O(nlogn)。<br>
空间复杂度：O(n)，最极端的情况下（每个元素都不同），用于存储元素及其频率的 Map 需要存储 n 个键值对。</p>
</blockquote>
<blockquote>
<p>解法二：最小堆<br>
题目最终需要返回的是前 k个频率最大的元素，可以想到借助堆这种数据结构，对于 k 频率之后的元素不用再去处理，进一步优化时间复杂度。<br>
具体操作为：<br>
借助 哈希表 来建立数字和其出现次数的映射，遍历一遍数组统计元素的频率<br>
维护一个元素数目为 k 的最小堆<br>
每次都将新的元素与堆顶元素（堆中频率最小的元素）进行比较<br>
如果新的元素的频率比堆顶端的元素大，则弹出堆顶端的元素，将新的元素添加进堆中<br>
最终，堆中的 k 个元素即为前 k 个高频元素</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1579569394711.png" alt=""></p>
<pre><code>class Solution {
    public List&lt;Integer&gt; topKFrequent(int[] nums, int k) {
        // 使用字典，统计每个元素出现的次数，元素为键，元素出现的次数为值
        HashMap&lt;Integer,Integer&gt; map = new HashMap();
        for(int num : nums){
            if (map.containsKey(num)) {
               map.put(num, map.get(num) + 1);
             } else {
                map.put(num, 1);
             }
        }
        // 遍历map，用最小堆保存频率最大的k个元素
        PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(new Comparator&lt;Integer&gt;() {
            @Override
            public int compare(Integer a, Integer b) {
                return map.get(a) - map.get(b);
            }
        });
        for (Integer key : map.keySet()) {
            if (pq.size() &lt; k) {
                pq.add(key);
            } else if (map.get(key) &gt; map.get(pq.peek())) {
                pq.remove();
                pq.add(key);
            }
        }
        // 取出最小堆中的元素
        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
        while (!pq.isEmpty()) {
            res.add(pq.remove());
        }
        return res;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(nlogk)，n 表示数组的长度。首先，遍历一遍数组统计元素的频率，这一系列操作的时间复杂度是 O(n)；接着，遍历用于存储元素频率的 map，如果元素的频率大于最小堆中顶部的元素，则将顶部的元素删除并将该元素加入堆中，这里维护堆的数目是 k，所以这一系列操作的时间复杂度是O(nlogk) 的；因此，总的时间复杂度是 O(nlog⁡k)。<br>
空间复杂度：O(n)，最坏情况下（每个元素都不同），map 需要存储 n 个键值对，优先队列需要存储 k 个元素，因此，空间复杂度是 O(n)。</p>
</blockquote>
<blockquote>
<p>解法三：桶排序法<br>
首先依旧使用哈希表统计频率，统计完成后，创建一个数组，将频率作为数组下标，对于出现频率不同的数字集合，存入对应的数组下标即可。</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1579569614556.png" alt=""></p>
<pre><code>//基于桶排序求解「前 K 个高频元素」
class Solution {
    public List&lt;Integer&gt; topKFrequent(int[] nums, int k) {
        List&lt;Integer&gt; res = new ArrayList();
        // 使用字典，统计每个元素出现的次数，元素为键，元素出现的次数为值
        HashMap&lt;Integer,Integer&gt; map = new HashMap();
        for(int num : nums){
            if (map.containsKey(num)) {
               map.put(num, map.get(num) + 1);
             } else {
                map.put(num, 1);
             }
        }
        
        //桶排序
        //将频率作为数组下标，对于出现频率不同的数字集合，存入对应的数组下标
        List&lt;Integer&gt;[] list = new List[nums.length+1];
        for(int key : map.keySet()){
            // 获取出现的次数作为下标
            int i = map.get(key);
            if(list[i] == null){
               list[i] = new ArrayList();
            } 
            list[i].add(key);
        }
        
        // 倒序遍历数组获取出现顺序从大到小的排列
        for(int i = list.length - 1;i &gt;= 0 &amp;&amp; res.size() &lt; k;i--){
            if(list[i] == null) continue;
            res.addAll(list[i]);
        }
        return res;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)，nn 表示数组的长度。首先，遍历一遍数组统计元素的频率，这一系列操作的时间复杂度是 O(n)；桶的数量为 n+1，所以桶排序的时间复杂度为 O(n)；因此，总的时间复杂度是 O(n)。<br>
空间复杂度：很明显为 O(n)</p>
</blockquote>
<blockquote>
<p>官方题解：<br>
方法 1：堆<br>
想法<br>
k = 1 时问题很简单，线性时间内就可以解决。只需要用哈希表维护元素出现频率，每一步更新最高频元素即可。<br>
当 k &gt; 1 就需要一个能够根据出现频率快速获取元素的数据结构，这就是优先队列。<br>
首先建立一个元素值对应出现频率的哈希表。在 Java 中使用 HashMap，但需要手工填值。在 Python 中提供一个字典结构用作哈希表和在 collections 库中的 Counter 方法去构建我们需要的哈希表。<br>
这个步骤需要 O(N) 时间其中 N 是列表中元素个数。<br>
第二步建立堆，堆中添加一个元素的复杂度是O(log(k))，要进行 N 次复杂度是 O(N)。<br>
最后一步是输出结果，复杂度为 O(klog(k))。<br>
在 Python 中可以使用 heapq 库中的 nlargest 方法，可以在相同时间内完成，但只需要一行代码解决。</p>
</blockquote>
<pre><code>class Solution {
  public List&lt;Integer&gt; topKFrequent(int[] nums, int k) {
    // build hash map : character and how often it appears
    HashMap&lt;Integer, Integer&gt; count = new HashMap();
    for (int n: nums) {
      count.put(n, count.getOrDefault(n, 0) + 1);
    }

    // init heap 'the less frequent element first'
    PriorityQueue&lt;Integer&gt; heap =
            new PriorityQueue&lt;Integer&gt;((n1, n2) -&gt; count.get(n1) - count.get(n2));

    // keep k top frequent elements in the heap
    for (int n: count.keySet()) {
      heap.add(n);
      if (heap.size() &gt; k)
        heap.poll();
    }

    // build output list
    List&lt;Integer&gt; top_k = new LinkedList();
    while (!heap.isEmpty())
      top_k.add(heap.poll());
    Collections.reverse(top_k);
    return top_k;
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(Nlog(k))。Counter 方法的复杂度是 O(N)，建堆和输出的复杂度是 O(Nlog(k))。因此总复杂度为O(N+Nlog(k))=O(Nlog(k))。<br>
空间复杂度：O(N)，存储哈希表的开销。<br>
注释<br>
根据复杂度分析，方法对于小 k 的情况是很优的。但是如果 k 值很大，我们可以将算法改成删除频率最低的若干个元素。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UNP 第三十章 客户/服务器程序设计范式]]></title>
        <id>https://lixin-ee.github.io//post/unp-di-san-shi-zhang-ke-hu-fu-wu-qi-cheng-xu-she-ji-fan-shi</id>
        <link href="https://lixin-ee.github.io//post/unp-di-san-shi-zhang-ke-hu-fu-wu-qi-cheng-xu-she-ji-fan-shi">
        </link>
        <updated>2020-01-21T00:35:03.000Z</updated>
        <content type="html"><![CDATA[<p>当开发一个Unix服务器程序时，我们有如下类型的进程控制可供选择。<br>
・本书第一个服务器程序即图1-9是一个迭代服务器(iterative server)程序，不过这种类型 的适用情形极为有限，因为这样的服务器在完成对当前客户的服务之前无法处理已等待 服务的新客户。<br>
・图5-2是本书第一个并发服务器(concurrent server)程序，它为每个客户调用fork派生一 个子进程。传统上大多数Unix服务器程序属于这种类型。<br>
・在6.8节，我们开发的另一个版本的TCP服务器程序由使用select处理任意多个客户的单 个进程构成。<br>
・在图26-3中我们的并发服务器程序被改为服务器为每个客户创建一个线程，以取代派生 一个进程。</p>
<p>我们将在本章探究并发服务器程序设计的另两类变体。<br>
・预先派生子进程(prefbrking)是让服务器在启动阶段调用fork创建一个子进程池。每个 客户请求由当前可用子进程池中的某个(闲置)子进程处理。<br>
・预先创建线程(prethreading)是让服务器在启动阶段创建一个线程池，每个客户由当前可用线程池中的某个(闲置)线程处理。</p>
<p>从其他服务器的实际CPU时间中减去迭代服务器的实际GPU 时间就得到相应服务器用于进程控制所需的CPU时间，因为迭代服务器没有进程控制开销。</p>
<h3 id="tcp客户程序设计范式">TCP客户程序设计范式</h3>
<p>我们已经探究了客户程序的各种设计范式，这里有必要汇总它们各自的优缺点。<br>
・图5-5是基本的TCP客户程序。该程序存在两个问题。首先，进程在被阻塞以等待用户输入期间，看不到诸如对端关闭连接等网络事件。其次，它以停-等模式运作，批处理效率极低。<br>
・图6-9是下一个迭代客户程序，它通过调用select使得进程能够在等待用户输入期间得 到网络事件通知。然而该程序存在不能正确地处理批量输入的问题。图6-13通过使用 shutdown函数解决了这个问题。<br>
・从图16-3开始给出的是使用非阻塞式I/O实现的客户程序。<br>
・第一个超越单进程单线程设计范畴的客户程序是图16-10,它使用fork派生一个子进程， 并由父进程（或子进程）处理从客户到服务器的数据，由子进程（或父进程）处理从服 务器到客户的数据。<br>
・图26-2使用两个线程取代两个进程。<br>
非阻塞式I/O版本尽管是最快的，其代码却比较复杂；使用两个进程或两个线程的版本相比之下代码简化得多，而运行速度只是稍逊而已。</p>
<h3 id="tcp迭代服务器程序">TCP迭代服务器程序</h3>
<p>迭代服务器没有执行任何进程控制。这就让我们测量出服务器处理如此数目客户所需CPU时间的一个<strong>基准值</strong>，从其他服务器的实测CPU时间中减去该值就能得到它们的进程控制时间。从<strong>进程控制角度</strong>看迭代服务器是最快的，因为它不执行进程控制。有了基准值之后，我们在图30-1 中比较各个实测CPU时间与基准值的差值。<br>
<img src="https://lixin-ee.github.io//post-images/1579572365941.png" alt=""></p>
<h3 id="tcp并发服务器程序每个客户一个子进程">TCP并发服务器程序，每个客户一个子进程</h3>
<p>传统上并发服务器调用fork派生一个子进程来处理每个客户。这使得服务器能够同时为多 个客户服务，每个进程-个客户。客户数目的唯一限制是操作系统对以其名义运行服务器的用 户ID能够同时拥有多少子进程的限制。图5-12就是一个并发服务器程序的例子，绝大多数TCP服务器程序也按照这个范式编写。<br>
并发服务器的问题在于为每个客户现场fork一个子进程比较耗费CPU时间。</p>
<p><strong>code 30-4~7</strong></p>
<h3 id="tcp预先派生子进程服务器程序accept无上锁保护">TCP预先派生子进程服务器程序：accept无上锁保护</h3>
<p>预先派生子进程(prefdrking)：启动阶段预先派生一定数量的子进程，当各个客户连接到达时，这些子进程立即就能为它们服务。<br>
这种技术的优点在于无须引入父进程执行fork的开销就能处理新到的客户。缺点则是父进 程必须在服务器启动阶段猜测需要预先派生多少子进程。如果某个时刻客户数恰好等于子进程 总数，那么新到的客户将被忽略，直到至少有一个子进程重新可用。<br>
然而这些客户并未被完全忽略。内核将为每个新到的客户完成三路握手，直到达到相应套接字上listen调用的backlog数为止，然后在服务器调用accept时把这些已完成的连接传递给它。这么一来客户就能觉察到服务器在响应时间上的恶化，因为尽管它的connect调用可能立即返回 <strong>（注意这里也要区分好TCP返回和应用层返回的区别）</strong>，但是它的第一个请求可能是在一段时间之后才被服务器处理。<br>
<img src="https://lixin-ee.github.io//post-images/1579573503597.png" alt=""><br>
通过增加一些代码，服务器总能应对客户负载的变动。父进程必须做的就是持续监视可用 (即闲置)子进程数，一旦该值降到低于某个阈值就派生额外的子进程。同样，一旦该值超过另 一个阈值就终止一些过剩的子进程，过多的可用子进程也会导致性能退化。<br>
<strong>code 30-9~12</strong><br>
既然getrusage汇报的是已终止子进程的资源利用统计，在调用pr_cpu_time之前就必须终止所有子进程。我们通过给每个子进程发送SIGTERM信号终止它们，并通过调用 wait汇集所有子进程的资源利用统计。<br>
调用fork派生子进程后只有父进程返回。子进程调用图30-12给出的child_main函数， 它是个无限循环。<br>
每个子进程调用accept返回一个已连接套接字，然后调用web.child处理客户请求，最后关闭连接。<strong>子进程一直在这个循环中反复，直到被父进程终止</strong>。</p>
<p><strong>多个进程在同一个监听描述符上调用accept</strong><br>
<img src="https://lixin-ee.github.io//post-images/1579573862224.png" alt=""><br>
描述符只是本进程引用file结构的proc结构中一个数组中某个元素的下标而已。fork调用 执行期间为子进程复制描述符的特性之一是：子进程中一个给定描述符引用的file结构正是父进程中同一个描述符引用的file结构。<br>
每个file结构都有一个引用计数。当打开一个文件或套 接字时，内核将为之构造一个file结构，并由作为打开操作返回值的描述符引用，它的引用计 数初值自然为1;以后每当调用fork以派生子进程或对打开操作返回的描述符（或其复制品） 调用dup以复制描述符时，该file结构的引用计数就递增（每次增1）。在我们的N个子进程的例 子中，file结构的引用计数为N+1 （别忘了父进程仍然保持该监听描述符打开着，不过它从不调用 accept）<br>
服务器进程在程序启动阶段派生N个子进程，它们各自调用accept并因而均被内核投入睡 眠。当第一个客户连接到达时，所有N个子进程均被唤醒。这是因为所有N个子进程所用的监听描述符（它们有相同的值）指向同一个socket结构，致使它们在同一个等待通道（wait channel）即这个socket结构的so_timeo成员上进入睡眠。<br>
尽管所有N个子进程均被唤醒，其中只有最先运行的子进程获得那个客户连接，其余N-1个子进程继续回复唾眠， 因为当它们将发现队列长度为0 （因为最先运行的连接早已取走了本就只有一个的连接）。<br>
这就是有时候称为<strong>惊群（thundering herd）</strong> 的问题，因为尽管只有一个子进程将获得连接， 所有N个子进程却都被唤醒了<br>
当可用子进程阻塞在accept调用上时，内核调度算法把各个连接均匀地散布到各个子进程。</p>
<p><strong>select 冲突</strong><br>
select函数的冲突(collision)现象以及内核如何处理<br>
当<strong>多个进程</strong>在引用<strong>同一个套接字的描述符上</strong>调用select时就会发生冲突，因为在socket结构中为存放本套接字就绪之时应该唤醒哪些进程而<strong>分配的仅仅是一个进程ID的空间</strong>。如果有多个进程在等待同一个套接字，那么内核必须唤醒的是阻塞在select调用中的所有进程，因为它不知道哪些进程受刚变得就绪的这个套接字影响。（注意，这里指的是多个进程同时调用select，亦即多个select，而不是一个select中可以存放多个同一套接字）<br>
可以迫使本服务器程序发生select冲突，办法是在调用accept之前加上一个select调用，等待监听套接字变为可读。各个子进程将阻塞在select调用而不是accept调用之中。<br>
<img src="https://lixin-ee.github.io//post-images/1579574743412.png" alt=""><br>
如果有<strong>多个进程阻塞在引用同一个实体</strong>(例如套接字或普通文件，由file结构直接或间接描述)的描述符上，那么最好直接阻塞在诸如accept之类的函数<strong>而不是select之中</strong>。</p>
<h3 id="tcp预先派生子进程服务器程序accept使用文件上锁保护">TCP预先派生子进程服务器程序,accept使用文件上锁保护</h3>
<p>允许多个进程在引用同一个监听套接字的描述符上调用accept的做法也仅仅适用于在内核中实现accept的内核，作为一个库函数实现accept的内核可能不允许这么做，某个子进程的accept就会返回EPROTO错误(表示协议有错)，原因在于库函数版本的accept并非一个原子操作</p>
<p>解决办法是让应用进程在<strong>调用accept前后安置某种形式的锁(lock)</strong>,这样任意时刻<strong>只有一个子进程阻塞在accept调用中</strong>，<strong>其他子进程则阻塞在试图获取</strong>用于保护accept的锁上。<br>
<img src="https://lixin-ee.github.io//post-images/1579575352861.png" alt=""><br>
<img src="https://lixin-ee.github.io//post-images/1579575446659.png" alt=""><br>
<img src="https://lixin-ee.github.io//post-images/1579575460814.png" alt=""></p>
<h3 id="tcp预先派生子进程服务器程序accept使用线程上锁保护">TCP预先派生子进程服务器程序，accept使用线程上锁保护</h3>
<p>上一节使用的POSEX文件上锁方法可移植到所有POSIX兼容系统，不过它涉及文件系统操作，可能比较耗时。<br>
本节我们改用线程上锁保护 accept,因为这种方法不仅适用于同一进程内各线程之间的上锁，而且适用于不同进程之间的上锁。<br>
（为了使用线程上锁，我们的main、child_make和child_main函数都保持不变，唯一需要改动的是那3个上锁函数。）<br>
在不同进程之间使用线程上锁要求：(1)<strong>互斥锁变量</strong>必须存放在由<strong>所有进程共享的内存区中</strong>；(2)必须<strong>告知线程函数库</strong>这是在<strong>不同进程之间共享</strong>的互斥锁。<br>
<img src="https://lixin-ee.github.io//post-images/1579576163684.png" alt=""><br>
<img src="https://lixin-ee.github.io//post-images/1579576201447.png" alt=""></p>
<h3 id="tcp预先派生子进程服务器程序传递描述符">TCP预先派生子进程服务器程序，传递描述符</h3>
<p>派生子进程的最后一个版本：只让父进程调用accept,然后把所接 受的己连接套接字&quot;传递”给某个子进程。<br>
这么做绕过了为所有子进程的accept调用提供上锁 保护的可能需求，不过需要从父进程到子进程的某种形式的描述符传递。这种技术会使代码多少有点复杂，因为父进程必须跟踪子进程的忙闲状态，以便给空闲子进程传递新的套接字。<br>
<img src="https://lixin-ee.github.io//post-images/1579576278446.png" alt=""><br>
结构中存放相应子进程的进程ID、父进程中连接到该子进程的字节流管道描述 符、子进程状态以及该子进程已处理客户的计数。<br>
在调用fork之前先创建一个<strong>字节流管道</strong>， 它是一对<strong>Unix域字节流套接字</strong>。派生出子进程之后，父进程关闭其中一个描述符 (sockfd[1]),子进程关闭另一个描述符(sockfd[0] )子进程还把流管道的自身拥有端 (sockfd[1])复制到标准错误输出，这样每个子进程就通过读写标准错误输出和父进程通信。<br>
<strong>code 30-21</strong><br>
<img src="https://lixin-ee.github.io//post-images/1579576602577.png" alt=""><br>
<strong>code 30-24~25</strong><br>
计数器navail用于跟踪当前可用的子进程数。如果其值为0,那就从select的读描述符 集中关掉与监听套接字对应的位。这么做防止父进程在无可用子进程的情况下accept 新连接。<br>
write_fd函数把就绪的已连接套接字传递给该子 进程<br>
child_main函数在调用子进程<strong>处理完一个客户</strong>之后，通过该子进程的<strong>字节流管道拥有端</strong>向父进程<strong>写回单个字节</strong>。这使得该字节流管道的父进程拥有端变为可读。<br>
父进程读入这个单字节（忽略其值），把该子进程标为可用，并递增navail计数器。要 是该子进程意外终止，它的字节流管道拥有端将被关闭，因而read将返回0。父进程察觉到之后就终止近行，不过更好的做法是登记这个错误，并重新派生一个子进程取代意外终止的那个子进程。<br>
子进程不再调用accept,而是阻塞在 read_fd调用中，等待父进程传递过来一个巳连接套接字描述符</p>
<h3 id="tcp并发服务器程序每个客户一个线程">TCP并发服务器程序:每个客户一个线程</h3>
<p>如果服务器主机支持线程，我们就可以改用线程以取代子进程。<br>
为每个客户创建一个线程，以取代为每个客户派生一个子进程。<br>
<strong>code 30-26</strong><br>
doit函数先让自己脱离，使得主线程不必等待它</p>
<h3 id="tcp预先创建线程服务器程序每个线程各自accept">TCP预先创建线程服务器程序，每个线程各自accept</h3>
<p>在支持线程的系统上，我们有理由预期在服务器启动阶段预先创建一个线程池以取代为每 个客户现场创建一个线程的做法有类似的性能加速。<br>
本服务器的基本设计是预先创建一个线程 池，并让每个线程各自调用accept„取代让每个线程都阻塞在accept调用之中的做法，我们改用互斥锁以保证任何时刻只有一个线程在调用accept<br>
这里没有理由使用文件上锁保护各个线程中的accept调用，因为对于单个进程中的多个线程，我们总可以使用互斥锁达到同样目的。<br>
<img src="https://lixin-ee.github.io//post-images/1579577167043.png" alt=""><br>
我们还声明了一些全局变量，譬如监听套接字描述符和一个需由所有线程共享的互斥锁变量等。<br>
<strong>code 30-28~29</strong></p>
<h3 id="tcp预先创建线程服务器程序主线程统一accept">TCP预先创建线程服务器程序，主线程统一accept</h3>
<p>最后一个使用线程的服务器程序设计范式是在程序启动阶段创建一个线程池之后只让主线程调用accept并把每个客户连接传递给池中某个可用线程<br>
本设计范式的问题在于主线程如何把一个已连接套接字传递给线程池中某个可用线程。<br>
既然所有线程和所有描述符都在<strong>同一个进程</strong>之内，我们<strong>没有必要</strong>把一个描述符从一个线程传递到另一个线程。接收线程只需知道这个己连接套接字描述符的值，而描述符传递实际传递的并非这个值，而是<strong>对这个套接字的一个引用</strong>，因而将<strong>返回一个不同于原值的描述符</strong>（该套接字的引用计数也被递增）。<br>
<img src="https://lixin-ee.github.io//post-images/1579577365769.png" alt=""><br>
还定义一个clifd数组，由<strong>主线程</strong>往中存入<strong>已接受的已连接套接字描述符</strong>，并由<strong>线程池</strong>中的<strong>可用线程</strong>从中<strong>取出一个以服务相应的客户</strong>。iput是主线程将往该数组中存入 的下一个元素的下标，iget是线程池中某个线程将从该数组中取出的下一个元素的下 标。这个由<strong>所有线程共享的数据结构</strong>自然<strong>必须得到保护</strong>，我们使用互斥锁和条件变量做到这一点。</p>
<p><strong>code 30-31~32</strong><br>
主线程大部分时间阻塞在accept调用中，等待各个客户连接的到达。一旦某个客户连 接到达，主线程就把它的已连接套接字描述符存入clifd数组的下—个元素，不过需事 先获取保护该数组的互斥锁。<br>
主线 程接受一个连接后将调用pthread_cond_signal向条件变量发送信号，以唤醒睡眠在 其上的线程。<br>
当主线程调用pthread_cond_signal引起线程函数库基于条件变量执行唤醒 工作时，该函数库在所有可用线程中轮循唤醒其中一个。</p>
<p>小结：<br>
<img src="https://lixin-ee.github.io//post-images/1579577535464.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ UNP 第二十六章 线程]]></title>
        <id>https://lixin-ee.github.io//post/unp-di-er-shi-liu-zhang-xian-cheng</id>
        <link href="https://lixin-ee.github.io//post/unp-di-er-shi-liu-zhang-xian-cheng">
        </link>
        <updated>2020-01-20T12:45:07.000Z</updated>
        <content type="html"><![CDATA[<p>在传统的UNIX模型中，当一个进程需要另一个实体来完成某事时，它就fork—个子进程 并让子进程去执行处理。<br>
fork调用却存在一些问题。<br>
•	fork是昂贵的，forkg把父进程的内存映像复制到子进程，并在子进程中复制所有描述符等等。<br>
当今的实现使用称为写时复制(copy-on-write)的技术，用以避免在子进程切实需要自己的副本之前把父进程的数据空间复制到子进程。然而即便有这样的优化措施，fork仍然是昂贵的。<br>
•	fork返回之后父子进程之间信息的传递需要进程间通信(IPC)机制。<br>
调用fork之前父进程向尚未存在的子进程传递信息相当容易，因为子进程将从父进程数据空间及所有描述符的一个副本开始运行。然而从子进程往父进程返回信息却比较费力。</p>
<p>线程有助于解决这两个问题。<br>
1.线程有时称为轻权进程(lightweight process),因为线程比进程“权重轻些”。也就是说，线程的创建可能比进程的创建快10-100倍。<br>
2.同一进程内的所有线程共享相同的全局内存。这使得线程之间易于共享信息，然而伴随这种简易性而来的却是同步(synchronization)问题。</p>
<p>同一进程内的所有线程除了共享全局变量外还共享：<br>
• 进程指令；<br>
• 大多数数据；<br>
• 打开的文件(即描述符)；<br>
• 信号处理函数和信号处置；<br>
• 当前工作目录；<br>
• 用户ID和组ID。</p>
<p>每个线程有各自的：<br>
• 线程ID<br>
• 寄存器集合，包括程序计数器和栈指针；<br>
• 栈(用于存放局部变量和返回地址)；<br>
•	errno<br>
• 信号掩码</p>
<h3 id="基本线程函数创建和终止">基本线程函数：创建和终止</h3>
<p><strong>pthread_create 函数</strong><br>
当一个程序由exec启动执行时，称为初始线程（initial thread）或主线程（main thread）的单个线程就创建了。其余线程则由pthread create函数创建。</p>
<pre><code>#include &lt;ptbread.h&gt;
 int pthreacLcreate （pthread_t *tid, const pthread_attr_t *attr, 
  void *(*func)(void *) , void *arg）;
	返回：若成功则为0,若出错则为正的Exxx值
</code></pre>
<p>一个进程内的每个线程都由一个线程ID （thread ID）标识，其数据类型为pthread_t （unsigned int），如果新的线程成功创建，其ID就通过指针返回。<br>
每个线程都有许多属性（attribute）：优先级、初始栈大小、是否应该成为一个守护线程， 等等。<br>
我们可以在创建线程时通过初始化一个取代默认设置的pthread_attr_t变量指定这些属性。通常情况我们采纳默认设置，这时我们把attr参数指定为空指针。<br>
func和args是由该线程执行的函数的指针及其参数。该线程通过调用这个函数开始执行，然后或者显式地终止（通过调用pthread_exit）,或者隐式地终止（通过让该函数返回）。该函数的地址由func参数指定，该函数的唯一调用参数是指针arg。如果我们需要给该函数传递<strong>多个参数</strong>，我们就得把它们<strong>打包成一个结构</strong>，然后把这个结构的地址作为单个参数传递给这个起始函数。<br>
通常情况下Pthread函数的返回值成功时为0,出错时为某个非0值。与套接字函数及大多数 系统调用出错时返回-1并置errno为某个正值的做法不同的是，Pthread函数出错时作为函数返回值返回<strong>正值错误指示</strong>。<br>
Pthread函数不设置errno.成功为0出错为非。因为&lt;sys/errno.h&gt;头文件中所有的Exxr值都是正值。0值从来不被赋予任何 Exxc名字。</p>
<p><strong>pthread_join 函数</strong><br>
调用pthread_join等待一个给定线程终止。</p>
<pre><code>#include &lt;pthread.h&gt;
int pthread_join(pthread_t *tid, void **status)；
返回：若成功则为0,若出错则为正的Exxx值
</code></pre>
<p>对比线程和UNIX进程， pthread_join 类似于fork，pthread_join,类似waitpid<br>
我们必须指定要等待线程的tid<br>
因此，Pthread没有办法等待任意一个线程(比如指定进程ID参数为-1，调用waitpid)<br>
如果status指针非空，来自所等待线程的返回值(一个指向某个对象的指针)将存入由status指向的位置。</p>
<p><strong>pthread_self 函数</strong><br>
每个线程都有一个在所属进程内标识自身的ID。线程ID由pthread_create返回，而且我们已经看到pthread_join使用它。每个线程使用pthread_self获取自身的线程ID。</p>
<pre><code>#include &lt;pthread.h&gt;
pthread_t pthread_self(void)；
	返回：调用线程的线程ID
</code></pre>
<p>对比线程和UNIX进程，pthread_self类似于getpid</p>
<p><strong>pthread_detach 函数</strong><br>
一个线程或者是可汇合的(joinable,默认值)，或者是脱离的(detached)。<br>
当一个可汇合的线程终止时，它的线程ID和退出状态将留存到另一个线程对它调用pthread_join<br>
脱离的线程却像守护进程，当它们终止时，所有相关资源都被释放，我们无法等待它们终止。<br>
如果一个线程需要知道另一个线程什么时候终止，那就最好保持第二个线程的可汇合状态。<br>
pthread_detach函数把指定的线程转变为脱离状态。</p>
<pre><code>#include &lt;pthread.h&gt;
int pthrea(l_decach (pthread_t tid);
	返回：若成功则为0,若出错则为正的Exxx值
</code></pre>
<p>本函数通常由想让自己脱离的线程调用，就如以下语句：<br>
pthread_detach(pthread_self())；</p>
<p><strong>pthread_exit 函数</strong><br>
让一个线程终止的方法之一是调用pthread_exit</p>
<pre><code>#include &lt;pthread.h&gt;
void pthread_exit (void *status)；
不返回
</code></pre>
<p>如果本线程未曾脱离，它的线程ID和退出状态将一直留存到调用进程内的某个其他线程对它调用 pthread_join<br>
指针status不能指向局部于调用线程的对象，因为线程终止时这样的对象也消失。<br>
让一个线程终止的另外两个方法是<br>
・启动线程的函数（即pthread_create的第三个参数）可以返回。既然<strong>该函数</strong>必须声明成<strong>返回一个void指针</strong>，它的<strong>返回值就是相应线程的终止状态</strong>。<br>
・如果<strong>进程的main函数返回</strong>或者<strong>任何线程调用了exit</strong>,整个进程就终止，其中<strong>包括它的任何线程</strong>。</p>
<h3 id="使用线程的str_cli函数">使用线程的str_cli函数</h3>
<p><img src="https://lixin-ee.github.io//post-images/1579525849006.png" alt=""><br>
<strong>code 26-2</strong><br>
将要创建的线程需要str_cli的2个参数：fp （输入文件的标准I/O库FILE指针） 和sockfd （连接到服务器的TCP套接字描述符）。需要把这2个参数值保存到外部变量中，或者把这两个值放到一个结构中，然后把指向这个结构的一个指针作为参数传递给我们将要创建的线程。<br>
程序中由启动该线程的函数return来终止该线程。</p>
<p>使用线程的TCP回射服务器程序<br>
<strong>code 26-3</strong><br>
accept返回之后，改为调用pthread_create取代调用fork。我们传递给doit函数的 唯一参数是已连接套接字描述符connfd（把整数描述符connfd类型强制转换成void指针）<br>
线程首先让自身脱离，因为主线程没有理由等待它创建的每个线程。然后调用str_echo函数。该函数返回之后，我们必须close己连接套接字，因为本线程和主线程共享所有的描述符。（对于使用fork的情形，子进程就不必close已连接套接字，因为子进程旋即终止，而所有打开的描述符在进程终止时都 将被关闭）<br>
主线程不关闭己连接套接字这是因为同一进程内的所有线程共享全部描述符，要是主线程调用close,它就会终止相应的连接。创建新线程并不影响己打开描述符的引用计数（这一点不同于fork，fork中主进程需要关闭己连接套接字）</p>
<p><strong>给新线程传递参数</strong><br>
把整数变量connfd类型强制转换成void指针并不保证在所有系统上 都能起作用。要正确地处理这一点需要做额外的工作。<br>
首先注意我们不能简单地把connfd的地址传递给新线程。<br>
主线程中只有一个整数变量connfd，每次调用accept该变量都会被覆写以一个新值（已连接描述符）。因此可能发生下述情况。<br>
・ accept返回，主线程把返回值（譬如说新的描述符是5）存入connfd后调用pthread_ create。pthread_create的最后—参数arg是指向connfd的指针而不是connfd的内容。<br>
・Pthread函数库创建一个线程，并准备调度doit函数启动执行。<br>
・另一个连接就绪且主线程在新创建的线程开始运行之前再次运行。accept返回，主线程把返回值（譬如说新的描述符现在是6）存入connfd后调pthread_create。<br>
・尽管主线程共创建了两个线程，但是它们操作的都是存放在connfd中的最终值（按照假设最终值为6）<br>
问题出在<strong>多个线程不是同步地访问一个共享变量</strong>（以取得存放在connfd中的整数值）。<br>
我们通过把<strong>包含connfd的值的动态分配指针（而不是指向该变量的一个指针）</strong> 传递给pthread_create 来解决本问题。<br>
<strong>code 26-4</strong><br>
每当调用accept时，我们首先调用malloc分配-个整数变量的内存空间，用于存放有待accept返回的己连接描述符。这使得每个线程都有各自的已连接描述符副本。<br>
线程获取已连接描述符的值，然后调用free释放内存空间</p>
<p>但是也引入了新问题 ，malloc和free这两个函数历来是不可重入的。在主线程<strong>正处于这两个函数之一的内部处理期间</strong>，从某个信号处理函数中<strong>再调用这两个函数之一</strong>有可能导致灾难性的后果<br>
所以如果要求线程安全，则只能使用其他线程安全的函数，或者在函数内部执行某种形式的同步达到。</p>
<h3 id="线程安全函数">线程安全函数</h3>
<p><img src="https://lixin-ee.github.io//post-images/1579526550163.png" alt=""><br>
让一个函数线程安全的共通技巧是定义一个名字以_r结尾的新函数。 其中两个函数（ctermid和tmpnam）的线程安全条件是：调用者为返回结果预先分配空间，并 把指向该空间的指针作为参数传递给函数。</p>
<h3 id="线程特定数据">线程特定数据</h3>
<p>把一个未线程化的程序转换成使用线程的版本时，有时会碰到因其中有函数使用静态变量 而引起的一个常见编程错误。当然这个错误造成的故障也不是一定会发生的的。在无需考虑重入的环境下编写使用静态变量的函数无可非议<br>
然而当<strong>同一进程内的不同线程</strong>（<strong>信号处理函数也视为线程</strong>）<strong>几乎同时调用</strong>这样的函数时就可能会有问题发生，因为这些函数使用的<strong>静态变量无法为不同的线程保存各自的值</strong>。</p>
<p>解决办法：<br>
1.使用线程特定数据。这个办法并不简单，而且转换成了只能在支持线程的系统上工作的函数。本办法的优点是调用顺序无需变动<br>
2.改变调用顺序，由调用者把函数的所有调用参数封装在一个结构中，并在该结构中存入静态变量。<br>
3.改变接口的结构，避免使用静态变量，这样函数就可以是线程安全的</p>
<p>每个系统支持有限数量的线程特定数据元素。POSIX要求这个限制不小于128 <strong>（每个进程）</strong><br>
系统（可能是线程函数库）为<strong>每个进程</strong>（说实话我觉得是每个线程）维护一个我们称之为Key结构的结构数组<br>
<img src="https://lixin-ee.github.io//post-images/1579526868766.png" alt=""><br>
<strong>Key结构中的标志指示这个数组元素是否正在使用</strong><br>
所有的标志初始化为“不在使用”。<br>
当一个<strong>线程</strong>调用Pthread_key_create<strong>创建一个新的线程特定数据元素</strong>时，系统搜索其Key结构数组<strong>找出第一个不在使用的元素</strong>。该<strong>元素的索引</strong>(0-127)称为<strong>键(key)</strong>,返回给调用线程的正是这个索引。<br>
除了进程范围的Key结构数组外，系统还在<strong>进程内</strong>维护关于<strong>每个线程</strong>的多条信息。这些<strong>特定于线程的信息</strong>我们称之为Pthread结构，其部分内容是我们称之为pkey数组的一个128个元素的指针数组。<br>
<img src="https://lixin-ee.github.io//post-images/1579527035347.png" alt=""><br>
pkey数组的所有元素都被初始化为空指针。这些128个指针是和进程内的128个可能的“键” 逐一关联的值。<br>
当我们调用pthread_key_create创建一个键时，系统告诉我们这个键(索引)。每个线程可以随后为该键存储一个值(指针)，而这个指针通常又是每个线程通过调用malloc获得的。<br>
线程特定数据中易于混淆的地方之一是：该<strong>指针</strong>是键-值对中的<strong>值</strong>，但是<strong>真正的线程特定数据</strong>却是该<strong>指针指向的任何内容</strong>。</p>
<p>一个如何使用线程特定数据的例子<br>
<img src="https://lixin-ee.github.io//post-images/1579527336394.png" alt=""><br>
<img src="https://lixin-ee.github.io//post-images/1579527385249.png" alt=""><br>
线程”继续在readline中执行，使用和修改它自己的线程特定数据。</p>
<p>当一个线程终止时，如果该线程调用过我们的 readline函数，那么该函数已经分配了一个需要释放掉的内存区。这正是图26-7中的“析构函数指针”的用武之地。一个线程调用pthread_key_create创建某个线程特定数据元素时，所指定的函数参数之一是指向某个析构函数(destructor)的一个指针。当一个线程终止时，系统将扫描该线程的<strong>pkey数组</strong>，为每个非空的pkey指针调用相应的析构函数。&quot;相应的析构函数”指的是存放在图26-7的<strong>Key数组</strong>中的函数指针。</p>
<p>处理线程特定数据时通常首先调用pthread_once和pthread_key_create两个函数。</p>
<pre><code>#include &lt;pthread.h&gt;
int pthread_once(pthread_once_t *onceptr, void (*intit)(void));
int pthread_key_create (pthread_key_t *keyptr, void (*destructor) (void * value))；
均返回：若成功则为0,若出错则为正的Exxx值
</code></pre>
<p>每当一个使用线程特定数据的函数被调用时，pthread_once通常转而被该函数调用，不过 pthread_once使用由onceptr参数指向的变量中的值，确保init参数所指的函数在进程范围内只被 调用一次。<br>
在<strong>进程范围</strong>内对于一个给定键，<strong>pthread_key_create只能被调用一次</strong>。所创建的键通过 *keyptr指针参数返回，如果destructor指针参数不为空指针，它所指的函数将由为该键存放过某个值的每个线程在终止时调用.<br>
<img src="https://lixin-ee.github.io//post-images/1579528741145.png" alt=""></p>
<p>每次readline被调用时，它都调用pthread_once。pthread_once使用由其onceptr参数指 向的值(变量rl_once的内容)确保由其init参数指向的函数只被调用一次。初始化函数 readline_once创建一个线程特定数据键存放在rl_key中，readline随后在pthread_ getspecific 和 pthread_set specific 调用中使用这个键。</p>
<p>pthread_ getspecific 和 pthread_set specific这两个函数分别用于获取和存放与某个键关联的值。该值就是“指针”的东西。该指针的具体指向取决于应用 程序，不过通常情况下它指向一个动态分配的内存区。</p>
<pre><code>#include &lt;pthread.h&gt;
void *pthread_getspecific(pthread_key_t key)；
返回：指向线程特定数据的指针(有可能是一个空指针)
int pthread_setspecific (pthread_key_t key, const void * value);
	返回：若成功则为0,若出错则为正的Exxx值
</code></pre>
<p>注意，phread_key_create的参数是一个指向某个键的<strong>指针</strong>(因为该函数需要在其中存放 ±1系统赋予该键的值)<br>
而那两个get和set函数的<strong>参数则是键本身</strong>(可能如早先讨论的那样是一个小整数索引)。</p>
<p><strong>code 26-11 26-12</strong></p>
<h3 id="web客户与同时连接">Web客户与同时连接</h3>
<p>把Web客户程序重新编写成用线程代替非阻塞 connecto改用线程之后，我们可以让套接字停留在默认的阻塞模式，改而为每个连接创建一个线程。每个线程可以阻塞在它的connect调用中，因为内核（也可能是线程函数库）会转而 运行另外某个就绪的线程。</p>
<p><strong>code 26-13~15</strong></p>
<p>指定第一个参数为0调用Solaris线程函数thr_join,等待任何一个线程终止。不幸的是，Pthreads没有提供等待任一线程终止的手段，pthread_join函数。要求我们显式 指定想要等待的线程。</p>
<h3 id="互斥锁">互斥锁</h3>
<p><img src="https://lixin-ee.github.io//post-images/1579532195376.png" alt=""><br>
线程编程又称并发编程(concurrent programming)或并行编程(parallel programming), 因为多个线程可以并发地(或并行地)运行且访问相同的变量<br>
对于通常的Unix编程，我们不会碰到这些并发编程问题，因为调用fork 之后，父子进程之间除了描述符外不共享任何东西。然而当我们讨论在进程之间的共享内存区 时，仍然会碰到同类问题。<br>
多个线程更改一个共享变量的问题的解决办法是用一个<strong>互斥锁（mutex,代表mutual exclusion）保护这个共享变量</strong>；访问该变量的前提条件是持有该 互斥锁。按照Pthread，互斥锁是类型为pthread_mutex_t的变量</p>
<pre><code>#include &lt;pthread.h&gt;
int pthread_mutex_lock （pthread_mutex_t *mptr）；
int pthread_mutex_unlock（pthread_mutex_t *mptr）；
均返回：若成功则为0,若出错则为正的值
</code></pre>
<p>如果试图上锁己被另外某个线程锁住的一个互斥锁，本线程将被阻塞，直到该互斥锁被解锁为止。<br>
如果某个互斥锁变量是静态分配的，我们就必须把它初始化为常值PTHREAD_MUTEX_ INITIALIZER<br>
如果我们在共享内存区中分配一个互斥锁，那么必须通过调用pthread_mutex_init函数在运行时把它初始化。</p>
<p><strong>code 26-18</strong></p>
<h3 id="条件变量">条件变量</h3>
<p>互斥锁适合于防止同时访问某个共享变量，但是我们需要另外某种在等待某个条件发生期间能让我们进入睡眠的东西。<br>
我们需要一个让主循环进入睡眠，直到某个线程通知它有事可做才醒来的方法。<br>
条件变量 (condition variable)结合互斥锁能够提供这个功能。互斥锁提供互斥机制，条件变量提供信号机制。</p>
<pre><code>#include &lt;pthread.h&gt;
int pthread_cond_wait (pthrea_cond_t *cptr, pthread_mutex_t *mptr):
int pthread_cond_signal (pthread_cond_t *cptr)；
	均返回：若成功则为0,若出错则为正的Exxx值
</code></pre>
<p>第二个函数的名字中&quot;signal&quot; 一词并不指称Unix的SIGxxx信号。<br>
同时关联一个条件变量和一个互斥锁。</p>
<p>注意，主循环仍然只是在持有互斥锁期间检查相关的循环判断变量。然后，如果发现无事可做，那就调用<strong>pthrea_cond_wait。该函数把调用线程投入睡眠并释放调用线程持有的互斥锁。</strong> 此外， 当调用线程后来从pthread_cond_wait返回时，该线程再次持有该互斥锁。</p>
<p>为什么<strong>每个条件变量都要关联一个互斥锁</strong>呢？因为<strong>条件</strong>通常是<strong>线程之间共享</strong>的某个变量的值。<br>
<img src="https://lixin-ee.github.io//post-images/1579533159435.png" alt=""></p>
<p>同样的理由要求<strong>pthread_cond_wait被调用时</strong>其所关联的<strong>互斥锁必须是上锁</strong>的，该函数作<strong>单个原子操作解锁该互斥锁并把调用线程投入睡眠</strong>也是出于这个理由。要是该函数不先解锁该互斥锁，到返回时再给它上锁，调用线程就不得不事先解锁事后上锁该互斥锁<br>
<img src="https://lixin-ee.github.io//post-images/1579533243987.png" alt=""></p>
<p>pthread_cond_signal通常唤醒等在相应条件变量上的单个线程。有时候一个线程知道自己应该唤醒多个线程，这种情况下它可以调用pthrea_cond_broadcast唤醒等在相应条件变 量上的所有线程。</p>
<pre><code>#include &lt;pthread.h&gt;
int pthread_cond_broadcast (pthread_cond_t *cptr)；
int pthread_cond_t imedwait (pthread_cond_t *cptr, pthread_mutex_t *mptr, const struct timespec *abstime)；
均返回：若成功则为0,若出错则为正的Exxx值
</code></pre>
<p>pthread_cond_timedwait允许线程设置一个阻塞时间的限制。abstime是—个timespec 结构，指定该函数必须返回时刻的系统时间，即 使到时候相成条件变量尚未收到信号。如果发生这样的超时，那就返回ETIME错误。<br>
这个时间值是一个绝对时间(absolute time),而不是一个时间增量(time delta)<br>
<img src="https://lixin-ee.github.io//post-images/1579533388509.png" alt=""></p>
<h3 id="web客户与同时连接等待任意线程">Web客户与同时连接（等待任意线程）</h3>
<p>重新编写26.6节的Web客户程序，把其中对于Solaris之thr_join函数的调用替换 成调用pthread_join.正如那节所述，这么一来必须明确指定等待哪一个线程。为了做到 这一点，我们就像26.8节讲解的那样使用条件变量。<br>
全局变量(图26-13)的唯一变动是增加一个新标志和一个条件变量。</p>
<p><strong>code 26-19</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UNP 第二十二章 高级UDP套接字编程]]></title>
        <id>https://lixin-ee.github.io//post/unp-di-er-shi-er-zhang-gao-ji-udp-tao-jie-zi-bian-cheng</id>
        <link href="https://lixin-ee.github.io//post/unp-di-er-shi-er-zhang-gao-ji-udp-tao-jie-zi-bian-cheng">
        </link>
        <updated>2020-01-20T12:14:10.000Z</updated>
        <content type="html"><![CDATA[<h3 id="数据报截断">数据报截断</h3>
<p>当到达的一个UDP数据报超过应用进程提供的缓冲区容量时， recvmsg在其msghdr结构的msg_flags成员上设置MSG_TRUNC标志。<br>
不幸的是，不同的实现都以不同的方式处理超过预期长度的UDP数据报<br>
不同的实现在处理超过应用进程接收缓冲区大小的数据报时存在上述差异，检测本问 题的一个有效方法就是：总是分配比应用进程预期接收的最大数据报还多~个字节的应用进程 缓冲区。如果收到长度等于该缓冲区的数据报，那就认定它是一个过长数据报。</p>
<h3 id="何时用udp代替tcp">何时用UDP代替TCP</h3>
<p>UDP的独特特性（亦即TCP没有的）<br>
•UDP支持广播和多播，那就必须使用UDP<br>
•UDP没有连接建立和拆除<br>
单个UDP请求-应答交换而言的最小事务处理时间(transactiontime)为RTT+SPT<br>
其中RTT表示客户与服务器之间的往返时间(round-triptime), SPT则表示客户请求的服务器处理时间(server processing time)。<br>
然而就TCP而言，如果同样的请求-应答交换用到一个新的TCP连接，那么最小事务处理时间将是2X RTT+SPT,比UDP时间多一个RTT。</p>
<p>UDP无法提供的TCP特性,其应用程序必须自行提供它们:<br>
・正面确认，丢失分组重传，重复分组检测，给被网络打乱次序的分组排序。<br>
・窗口式流量控制。<br>
・慢启动和拥塞避免。</p>
<p>总结推荐：<br>
・对于广播或多播应用程序必须使用UDP。<br>
・对于简单的请求-应答应用程序可以使用UDP,不过错误检测功能必须加到应用程序内部。错误检测至少涉及确认、超时和重传。<br>
・对于海量数据传输（例如文件传输）不应该使用UDP<br>
因为这么做除了上一点要求的特性外，还要求把窗口式流量控制、拥塞避免和慢启动这些特性也加到应用程序中，意味着我们是在应用程序中再造TCP。</p>
<h3 id="给udp应用增加可靠性">给UDP应用增加可靠性</h3>
<p>数据报是不可靠的，如果实在需要UDP又需要可靠性，则需要在不可靠的数据报服务（UDP）之上加入可靠性的一个应用程序。</p>
<p>想要让<strong>请求-应答式</strong>应用程序使用UDP,那么必须在客户程序中增加以下两个特性。<br>
（1）	超时和重传；用于处理丢失的数据报。<br>
（2）	序列号：供客户验证一个应答是否匹配相应的请求。</p>
<h3 id="并发udp服务器">并发UDP服务器</h3>
<p>对于TCP服务器，并发处理只是简单地fork 一个新的子进程（或者创建一个新的线程），并让子进程处理新的客户。当使用TCP时，服务器的并发处理得以简化的根源在于每个客户连接都是唯一的：标识每个客户连接的是唯一的TCP套接字对。<br>
而对于UDP,我们必 须应对两种不同类型的服务器。<br>
（1）	第一种UDP服务器比较简单，读入一个客户请求并发送一个应答后，与这个客户就不再相关了。<br>
这种情形下，读入客户请求的服务器可以fork一个子进程并让子进程去处理该请求。 该&quot;请求”（即请求数据报的内容以及含有客户协议地址的套接字地址结构）通过由fork复制的内存映像传递给子进程。然后于进程把它的应答直接发送给客户。<br>
（2）	第二种UDP服务器与客户交换多个数据报。<br>
问题是客户知道的服务器端口号只有服务器的一个众所周知端口。一个客户发送其请求的第一个数据报到这个端口，但是服务器如何区分 这是来自该客户同一个请求的后续数据报还是来自其他客户请求的数据报呢？<br>
这个问题典型的解决办法是让服务器为每个客户创建一个新的套接字，在其上bind一个临时端口，然后使用该套接字发送对该客户的所有应答。这个办法要求客户查看服务器第一个应答中的源端口号，并把本请求的后续数据报发送到该端口。</p>
<p>第二种类型UDP服务器的一个例子是TFTP。使用TFTP传送一个文件通常需要许多数据报 （成百上千，取决于文件长度），因为该协议发送的每个数据报只有512字节的数据。客户往服务器的众所周知端口 （69）发送一个数据报，指定要发送或接收的文件。服务器读入该请求，但是从另外一个由它创建并绑定<strong>某个临时端口</strong>的套接字发送它的应答。客户和服务器之间传送该文件的所有后续数据报都使用这个新的套接字。这么做允许主TFTP服务器在文件传送发生的同时（可能持续数秒钟甚至数分钟）继续处理到达端口69的其他客户请求。</p>
<p>对于由inetd激活的TFTP服务器，其情形涉及另外一个步骤。,我们知道大多数UDP服务器把inetd配置文本行中的wait-flag字段指定为wait。该值导致inetd停止在相应套接字上选择可访问条件，直到相应子进程终止为止，从而允许该子进程读入到达该套接字的数据报。图22-20展示了本情形涉及的步骤。<br>
自成inetd子进程的TFTP服务器调用recvfrom读入客户请求，然后fork—个自己的子进程，并<strong>由该子进程处理该客户请求</strong>。TFTP服务器随后调用exit,以便给inetd发送SIGCHLD信号，告知inetd重新在绑定UDP端口69的套接字上select可访问条件。</p>
<p><img src="https://lixin-ee.github.io//post-images/1579524150551.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UNP 第十六章 非阻塞式I/O]]></title>
        <id>https://lixin-ee.github.io//post/unp-di-shi-liu-zhang-fei-zu-sai-shi-io</id>
        <link href="https://lixin-ee.github.io//post/unp-di-shi-liu-zhang-fei-zu-sai-shi-io">
        </link>
        <updated>2020-01-20T08:21:20.000Z</updated>
        <content type="html"><![CDATA[<p>套接字的默认状态是阻塞的。这就意味着当发出一个不能立即完成的套接字调用时，其进 程将被投入睡眠，等待相应操作完成。可能阻塞的套接字调用可分为以下四类:<br>
（1）	输入操作，包括read、readv、recv, recvfrom和recvmsg共5个函数。<br>
如果某个进程对一个阻塞的TCP套接字（默认设置）调用这些输入函数之一，而且该套接字的接收缓冲区中 没有数据可读，该进程将被投入睡眠，直到有一些数据到达。既然TCP是字节流协议，该进程 的唤醒就是只要有一些数据到达，这些数据既可能是单个字节，也可以是一个完整的TCP分节 中的数据。如果想等到某个固定数目的数据可读为止,那么,可以指定MSG_WAITALL标志<br>
既然UDP是数据报协议，如果一个阻塞的UDP套接字的接收缓冲区为空，对它调用输入函数的进程将被投入睡眠，直到有UDP数据报到达。<br>
对于非阻塞的套接字，如果输入操作不能被满足（对于TCP套接字即至少有一个字节的数据可读，对于UDP套接字即有一个完整的数据报可读），相应调用将立即返回一个EWOULDBLOCK 错误。<br>
（2）	输出操作，包括write、writev、send、sendto和sendmsg共5个函数。<br>
对于一个TCP 套接字，内核将从应用进程的缓冲区到该套接字的发送缓冲区复制数据。<br>
对于阻塞的套接字，如果其发送缓冲区中没有空间，进程将被投入睡眠，直到有空间为止。<br>
对于一个非阻塞的TCP套接字，如果其发送缓冲区中根本没有空间，输出函数调用将立即 返回一个EWOULDBLOCK错误。如果其发送缓冲区中有一些空间，返回值将是内核能够复制到该 缓冲区中的字节数。这个字节数也称为不足计数（shortcount）.<br>
UDP套接字不存在真正的发送缓冲区。内核只是复制应用进程数据 并把它沿协议栈向下传送，渐次冠以UDP首部和IP首部。因此对一个阻塞的UDP套接字（默认设置），输出函数调用将不会因与TCP套接字一样的原因而阻塞，不过有可能会因其他的原因而 阻塞。<br>
（3）	接受外来连接，即accept函数。如果对一个阻塞的套接字调用accept函数，并且尚无 新的连接到达，调用进程将被投入睡眠。<br>
如果对一个非阻塞的套接字调用accept函数，并且尚无新的连接到达，accept调用将立即 返回一个EWOULDBLOCK错误。<br>
（4）	发起外出连接，即用于TCP的connect函数。<br>
TCP连接的建立涉及一个三路握手过程，而且connect函数一直要等到 客户收到对于自己的SYN的ACK为止才返回。这意味着TCP的每个connect总会阻塞其调用进<br>
程至少一个到服务器的RTT时间<br>
如果对一个非阻塞的TCP套接字调用connect,并且连接不能立即建立，那么连接的建立 能照样发起（譬如送出TCP三路握手的第一个分组），不过会返回一个EINPROGRESS错误。注意 这个错误不同于上述三个情形中返回的错误。另请注意有些连接可以立即建立，通常发生在服 务器和客户处于同一个主机的情况下。因此即使对于一个非阻塞的connect,我们也得预备 connect成功返回的情况发生。</p>
<h3 id="str_cli函数非阻塞版">str_cli函数（非阻塞版）</h3>
<p>6.4节讲过的使用了select的版本仍使用阻塞式I/O。<br>
本节的目标是开发这个函数的一个使用非阻塞式I/O的版本。这样可以防止进程在可做任 何有效工作期间发生阻塞。<br>
非阻塞式I/O的加入让本函数的缓冲区管理显著地复杂化了，在套接字上使用标准I/O的潜在问题和困难，它们在非阻塞式I/O操作中显得尤为突出。</p>
<p>程序维护着两个缓冲区：to容纳从标准输入到服务器去的数据，fr容纳自服务器到标准输 出来的数据。<br>
<img src="https://lixin-ee.github.io//post-images/1579510050285.png" alt=""><br>
其中toiptr指针指向从标准输入读入的数据可以存放的下一个字节，tooptr指向下一个必 须写到套接字的字节。有(toiptr-tooptr)个字节需写到套接字。可从标准输入读入的字节 数是(&amp;to [MAXLINE] - toiptr)。一旦tooptr移动到toiptr,这两个指针就一起恢复到缓冲 区开始处。<br>
<img src="https://lixin-ee.github.io//post-images/1579510142420.png" alt=""></p>
<p><strong>code 16-3</strong></p>
<p>使用fcntl把所用3个描述符都设置为非阻塞<br>
细节：当read返回数据时，我们相应地增加toiptr。我们还打开写描述符集中与套接字对应的位，使得以后在本循环内对该位的测试为真，从而导致调用write写到套接字。<br>
原因：因为对于书中的该服务器逻辑来说，有终端的stdin就说明下一步紧接着需要write到套接字了，那就自己主动设置套接字对应位，而不用等select检测<br>
然后下面的讨论就是最好设置相应位就好了，不要把输出代码一股脑复制过来</p>
<p><strong>code 16-4</strong></p>
<p>对应前面的：如果read返回些数据，我们就相应地增加friptr,并把写描述符集中与标准输出对应的位打开, 以尝试在本函数第三部分中将这些数据写出到标准输出。</p>
<pre><code>因为对于该服务器逻辑来说，有 read 就说明需要 stdout 了
那就自己设置套接字对应位，而不用等select检测
</code></pre>
<p><strong>code 16-5</strong><br>
<strong>code 16-6</strong></p>
<p>str_cli函数中的所有 fprintf调用都写到标准错误输出，使得我们能够区分标准输出(内容为由服务器回射的文本 行)和诊断输出。<br>
使用非阻塞式I/O使程序能发挥动态性的优势，只要I/O操作有可能发生，就执行合适的读操作或写操作。通过使用select函数，我们让内核可以告诉我们何时某个I/O操作可以发生。<br>
<img src="https://lixin-ee.github.io//post-images/1579510693202.png" alt=""></p>
<h3 id="str_cli的较简单版本">str_cli的较简单版本</h3>
<p>把应用 程序编写成使用非阻塞式I/O的努力是否照样值得呢？回答是否定的。<br>
<strong>每当我们发现需要使用非阻塞式I/O时，更简单的办法通常是把应用程序任务划分到多个进程（使用fork）或多个线程（pthread）</strong><br>
<img src="https://lixin-ee.github.io//post-images/1579510790188.png" alt=""></p>
<p><strong>code 16-10</strong></p>
<p>图中明确地指出所用TCP连接是全双工的，而且<strong>父子进程共享同一个套接字</strong>：<strong>父进程往该套接字中写，子进程从该套接字中读。尽管套接字只有一个，其接收缓冲区和发送缓冲区也分别只有一个</strong>，然而<strong>这个套接字却有两个描述符在引用它：一个在父进程中，另一个在子进程中。</strong><br>
我们同样需要考虑进程终止序列。正常的终止序列从在标准输入上遇到EOF之时开始发生。父进程读入来自标准输入的EOF后调用shutdown发送FIN。（父进程不能调用close.） 但当这发生之后，子进程需继续从服务器到标准输出执行数据复制，直到在套接字上读到EOF。<br>
服务器进程过早终止也有可能发生。要是发生这种情况，子进程将在套接字上读 到EOF。这样的子进程必须告知父进程停止从标准输入到套接字复制数据。在程序中，子进程向父进程发送一个SIGTERM信号，以防父进程仍在运行。如此处理的另一个手段是子进程无为地终止，使得父进程（如果仍在运行的话）捕获一个SIGCHLD信号。<br>
父进程完成数据复制后调用pause让自己进入睡眠状态，直到捕获一个信号（子进程来的 SIGTERM信号），尽管它不主动捕获任何信号。SIGTERM信号的默认行为是终止进程，这对于本例子是合适的。</p>
<h3 id="非阻塞-connect">非阻塞 connect</h3>
<p>当在一个非阻塞的TCP套接字上调用connect时，connect将立即返回一个EINPROGRESS 错误，不过己经发起的TCP三路握手继续进行。</p>
<p>非阻塞的connect有三个用途：<br>
（1）	我们可以把三路握手叠加在其他处理上。完成一个connect要花一个RTT时间<br>
（2）	我们可以使用这个技术同时建立多个连接。<br>
（3）	既然使用select等待连接的建立，我们可以给select指定一个时间限制，使得我们能够缩短connect的超时。</p>
<p>非阻塞connnct虽然听似简单，却有一些我们必须处理的细节。<br>
・尽管套接字是非阻塞的，如果连接到的服务器在同一个主机上，那么当我们调用connect 时，连接通常立刻建立。我们必须处理这种情形。<br>
・有关于select和非阻塞connect的以下两个规则：（1） 当连接成功建立时，描述符变为可写；（2）当连接建立遇到错误时， 描述符变为既可读又可写</p>
<h3 id="非阻塞connect时间获取客户程序">非阻塞connect：时间获取客户程序</h3>
<p><strong>code 16-11</strong><br>
<strong>解析</strong></p>
<p>套接字的各种实现以及非阻塞connect会带来移植性问题。<br>
首先，调用 select之前有可能连接己经建立并有来自对端的数据到达。这种情况下即使套接字上不发生错 误，套接字也是既可读又可写，这和连接建立失败情况下套接字的读写条件一样。（程序通过调用getsockopt并检查套接字上是否存在待处理错误来处理这种情形。）<br>
其次，既然我们不能假设套接字的可写（而不可读）条件是select返回套接字操作成功条 件的唯一方法，下一个移植性问题就是怎样判断连接建立是否成功。<br>
下面方法可以取代程序中的getsockopt调用。<br>
（1）	调用getpeernante代替getsockopt。如果getpeername以ENOTCONN错误失败返回，那 么连接建立已经失败，我们必须接着以SO_ERROR调用getsockopt取得套接字上待处理的错误。<br>
（2）	以值为0的长度参数调用read。如果read失败，那么connect己经失败，read返回的 errno给出了连接失败的原因。如果连接建立成功，那么read应该返回0。<br>
（3）	再调用connect一次。它应该失败，如果错误是EISCONN,那么套接字已经连接，也就 是说第一次连接已经成功。<br>
不幸的是，非阻塞connect是网络编程中最不易移植的部分。</p>
<p><strong>被中断的connect</strong><br>
对于一个正常的阻塞式套接字，如果其上的connect调用在TCP三路握手完成前被中断（譬如说捕获了某个信号），将会发生什么呢？假设被中断的connect调用不由内核自动重启，那么 它将返回EINTR.我们不能再次调用connect等待未完成的连接继续完成。这样做将导致返回 EADDRINUSE 错误。<br>
这种情形下我们只能调用select，就像本节对于非阻塞connect所做的那样。连接建立成 功时select返回套接字可写条件，连接建立失败时select返回套接字既可读又可写条件。</p>
<h3 id="非阻塞connect-web客户程序">非阻塞connect: Web客户程序</h3>
<p>非阻塞connect的web客户程序先建立一个与某个Web服务器的HTTP连接，再获取一个主页（homepage）。该主页往往含有多个对于其他网页（Webpage）的引用。客户可以使用非阻塞connect同时获取多个网页，以此取代每次只获取一个网页的串行获取手段。<br>
既然准备同时处理多个非阻塞connect,我们就不能使用上面代码中的connect_nonb函数， 因为它直到连接已经建立才返回。我们必须自行管理这些（可能尚未成功建立的）连接。</p>
<p><strong>code 14-19</strong></p>
<h3 id="非阻塞-accept">非阻塞 accept</h3>
<p>当有一个己完成的连接准备好被accept时，select将作为可读描述符返回该连接的监听套接字。因此，如果我们使用select在某个监听套接字上等待一个外来连接，理论上没有必要把该监听套接字设置为非阻塞，这是因为如果select告诉我们该套接字上已有连接就绪，那么随后的accept调用不应该阻塞。<br>
但实际中，这里存在一个可能让我们掉入陷阱的定时问题，如果服务器非常繁忙，它无法在select返回监听套接字的可读条件后就马上调用accpet（实际上这就是要维护一个已完成连接队列的原因），但是结合上连接建立之后到达的<strong>来自客户的RST</strong>,问题就出现了：<br>
・客户建立一个连接并随后中止它（close）。<br>
・select向服务器进程返回可读条件，不过服务器要过…小段时间才调用accept。<br>
・在服务器从select返回到调用accept期间，<strong>服务器TCP</strong>（注意不是应用层，应用层什么都不知道）收到来自客户的RST。<br>
・这个已完成的连接<strong>被服务器TCP</strong>驱除出队列，我们假设队列中没有其他已完成的连接。<br>
・服务器调用accept，但是由于没有任何己完成的连接，服务器于是阻塞。<br>
服务器会一直阻塞在accept调用上，直到其他某个客户建立一个连接为止，但是在此期间，服务器单纯阻塞在accept调用上，无法处理任何其他己就绪 的描述符。</p>
<p>本问题的解决办法如下。<br>
（1）	当使用select获悉某个监听套接字上何时有已完成连接准备好被accept时，总是把这个监听套接字设置为非阻塞。<br>
（2）	在后续的accept调用中忽略以下错误：EWOULDBLOCK （源自Berkeley的实现，客户中止连接时）、ECONNABORTED （POSIX实现，客户中止连接时）、EPROTO （SVR4实现，客户中止连接时）和EINTR （如果有信号被捕获）。</p>
<p><strong>小结：</strong><br>
select通常结合非阻塞式I/O—起使用， 以便判断描述符何时可读或可写。<br>
非阻塞connect使我们能够在TCP三路握手发生期间做其他处理，而不是光阻塞在connect 上。不幸的是，非阻塞connect不可移植，</p>
]]></content>
    </entry>
</feed>