<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-02-22T11:57:58.504Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>In the darkest night,Rising like a spire.</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[空指针、野指针与空悬指针]]></title>
        <id>https://lixin-scut.github.io//post/kong-zhi-zhen-ye-zhi-zhen-yu-kong-xuan-zhi-zhen</id>
        <link href="https://lixin-scut.github.io//post/kong-zhi-zhen-ye-zhi-zhen-yu-kong-xuan-zhi-zhen">
        </link>
        <updated>2020-02-22T10:09:54.000Z</updated>
        <content type="html"><![CDATA[<h3 id="空指针">空指针</h3>
<p>被初始化或赋值为nullptr、NULL或者0的指针</p>
<h3 id="野指针">野指针</h3>
<p>就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）指针变量在定义时如果未初始化，其值是随机的，指针变量的值是别的变量的地址，意味着指针指向了一个地址是不确定的变量，此时去解引用就是去访问了一个不确定的地址，所以结果是不可知的。</p>
<h3 id="空悬指针">空悬指针</h3>
<p>当指针所指向的对象已经被销毁或者被析构之后，指针对象本身还是存在的，但是已经成为了空悬指针。</p>
<pre><code>int * func ( void )
{
    int num = 123;
    /* ... */
    return &amp;num; //返回一个空悬指针
}
</code></pre>
<p>实验：</p>
<pre><code>int main() {
    int* nullPtr = nullptr;
    int* unknowPtr ;
    int* emptyPtr = new int(100);
    delete emptyPtr;
    cout &lt;&lt; nullPtr &lt;&lt; &quot; &quot; &lt;&lt; unknowPtr &lt;&lt; &quot; &quot; &lt;&lt; emptyPtr &lt;&lt; endl;
    cout&lt;&lt; *emptyPtr &lt;&lt; endl; //cannot *nullPtr,*unknowPtr,*emptyPtr
}
</code></pre>
<p>环境：Clion<br>
编译器：clang-902.0.39.2</p>
<p>结果</p>
<pre><code>0x0 0x0 0x7fcfe4400370
100
</code></pre>
<p>可以看到这个编译器下，空指针和野指针都是指向了同一个地址，所以都不能解引用，而emptyPtr还有趣，解引用后还是同一个值，查阅之后发现原来delete也不是立马把内存中的对象清除，而是先保留，等到有对象需要堆内存的时候可以直接清除。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ C++ 11 智能指针]]></title>
        <id>https://lixin-scut.github.io//post/c-11-zhi-neng-zhi-zhen</id>
        <link href="https://lixin-scut.github.io//post/c-11-zhi-neng-zhi-zhen">
        </link>
        <updated>2020-02-22T08:02:42.000Z</updated>
        <content type="html"><![CDATA[<p>需要注意的点：</p>
<ol>
<li>shared_ptr：允许多个指针指向同一个对象；</li>
<li>unique_ptr独占所指向的对象</li>
<li>weak_ptr 弱引用，指向shared_ptr管理的对象 。</li>
<li>这三种都定义在memory头文件</li>
<li>智能指针也是模板，创建时必须提供指针指向的类型</li>
<li>默认初始化的智能指针保存一个空指针</li>
<li>智能指针并不支持指针算术操作</li>
<li>使用get时，若智能指针释放了其对象，返回的指针所指向的对象也就消失了</li>
<li>将shared_ptr放在容器中容易因重新排序等因素忘记进行销毁</li>
<li>使用动态内存的原因：1.不知道需要使用多少对象2.不知道所需对象的准确类型3.！！程序需要在多个对象间共享数据，使用动态内存的一个常见原因就是允许多个对象共享相同的状态（亦即如果进行拷贝操作，实际上还是只有一个对象在内存中，而不是真的复制多个对象）</li>
<li>默认情况下动态分配的对象是默认初始化的，所以内置类型或组合类型（类中包含的类）的对象的值将是未定义的，而类类型对象将用默认构造函数进行初始化（值初始化的内置类型有着良好定义的值，而默认初始化的值则是未定义的）</li>
<li>传递给delete的指针必须指向动态分配的内存，或者是一个空指针，释放一块并非new分配的内存，或者将相同的指针值释放多次，其行为都是未定义的（能通过编译，但是编译器会自动delete栈内存，智能指针又delete一次，所以造成二次delete）。</li>
<li>通常情况下编译器不能分辨一个指针指向静态还是动态分配的对象，同样也不能分辨指针指向的内存是否已被释放，所以错误的delete表达式都会被通过</li>
<li>单接受指针参数的智能指针构造函数explicit的，所以我们不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化的形式来初始化一个智能指针，同样地一个返回shared_ptr的函数不能在其返回语句中隐式转换一个普通指针<br>
使用get返回的指针的代码不能delete此指针</li>
<li>永远不要用get初始化另一个智能指针或者为另一个智能指针赋值（因为不知道对象何时会被销毁）</li>
<li>当发生异常时，内置指针直接管理的内存是不会自动释放（但是智能指针的会检查引用计数并销毁）</li>
<li>不能拷贝unique_ptr的规则有一个例外，我们可以拷贝或赋值一个将要被销毁的unique_ptr</li>
<li>当我们创建一个weak_ptr时，要用一个shared_ptr来初始化它</li>
<li>由于对象可能不存在，我们不能使用weak_ptr直接访问对象，而必须调用lock，此函数检查weak_ptr指向的对象是否仍存在并返回相应的shared_ptr。</li>
<li>小心造成shared_ptr循环引用的问题：循环引用就是：两个对象互相使用一个shared_ptr成员变量指向对方。</li>
<li>弱指针用于专门解决shared_ptr循环引用的问题，weak_ptr不会修改引用计数，即其存在与否并不影响对象的引用计数器。</li>
</ol>
<p>参考资料：<br>
《C++primer》<br>
12动态内存<br>
<strong>静态内存</strong>用于保存局部static对象、类static数据成员以及定义在任何函数之外的变量<br>
<strong>栈内存</strong>用于保存定义在函数内的非static对象<br>
分配在静态内存和栈内存中的对象由<strong>编译器自动创建和销毁</strong>，栈对象在程序运行时才存在，static对象在使用前分配，程序结束时销毁<br>
除了静态内存和栈内存，每个程序还有一个<strong>内存池，称为自由空间或堆</strong>，程序用堆来存储动态分配的对象</p>
<p>12.1动态内存和智能指针<br>
动态内存的管理，new：在动态内存中为对象分配空间并返回一个指向该对象的指针，可以对其进行初始化；delete：接受一个动态对象的指针，销毁该对象，并释放与之关联的内存<br>
新的标准库为了使用动态内存提供了两种智能指针，与常规指针相比重要的区别在于它负责<strong>自动释放</strong>所指对象，<br>
shared_ptr：允许多个指针指向同一个对象；unique_ptr独占所指向的对象 weak_ptr 弱引用，指向shared_ptr管理的对象 。这三种都定义在memory头文件中</p>
<p>12.1.1shared_ptr<br>
智能指针也是模板，创建时必须提供指针指向的类型<br>
默认初始化的智能指针保存一个空指针<br>
智能指针并不支持指针算术操作<br>
<img src="https://lixin-scut.github.io//post-images/1582359705706.png" alt=""></p>
<p>！！使用get时，若智能指针释放了其对象，返回的指针所指向的对象也就消失了<br>
最安全的分配和使用动态内存的方法是调用一个名为make_shared的标准库函数，此函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr，make_shared定义在头文件memory中<br>
make_shared用其参数来构造给定类型的对象，比如调用<code>make_shared&lt;string&gt;</code>必须传递与string某个构造函数相匹配的参数。如果不传递任何参数，对象就会进行值初始化<br>
当进行拷贝赋值操作时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象<br>
我们可以认为每个shared_ptr都有一个关联计数器，通常称其为引用计数。无论何时我们拷贝一个shared_ptr都会递增计数器<br>
递增计数器的情况1.用一个shared_ptr初始化另外一个shared_ptr2.将shared_ptr作为参数传递给一个函数3. shared_ptr作为函数的返回值<br>
递减计数器 1.给shared_ptr赋一个新值2. shared_ptr被销毁3. 局部的shared_ptr离开其作用域（在函数中定义的shared_ptr都是局部变量，在函数执行结束后都会被销毁）<br>
一旦shared_ptr的计数器变为0，就会自动释放所管理的对象，可以确保分配的对象在恰当的时刻被释放<br>
每个类都有一个析构函数，控制此类型的对象销毁时会做什么操作<br>
将shared_ptr放在容器中容易因重新排序等因素忘记进行销毁，导致内存浪费，所以要记得用erase删除容器中不需要的shared_ptr元素<br>
使用动态内存的原因：1.不知道需要使用多少对象2.不知道所需对象的准确类型3.！！程序需要在多个对象间共享数据</p>
<p>当两个对象共享底层的数据时，当某个对象被销毁，不能单方面地销毁底层数据<br>
使用动态内存的一个常见原因就是允许多个对象共享相同的状态<br>
<code>initializer_list&lt;string&gt;</code>类型参数接受一个初始化器的花括号列表</p>
<p>12.1.2直接管理内存<br>
运算符new分配内存，delete释放new分配的内存<br>
相对于智能指针，使用这两个运算符管理内存非常容易出错，它们不能依赖类对象拷贝、赋值和销毁操作的任何默认定义<br>
使用智能指针的程序更容易编写和调试<br>
在自由空间分配的内存时无名的，所以new无法为其分配的对象命名，而是返回一个指向该对象的指针<br>
<code>int *pi = new int;	//pi指向一个动态分配的，未初始化的无名对象；</code><br>
默认情况下动态分配的对象是默认初始化的，所以内置类型或组合类型（类中包含的类）的对象的值将是未定义的，而类类型对象将用默认构造函数进行初始化<br>
我们可以用直接初始化的方式来初始化一个动态分配的对象，新标准下也可以用花括号</p>
<p>（注意第二个为拷贝初始化而非直接初始化）<br>
也可以对动态分配的对象进行值初始化，只需在类型名后面加上一对空括号<br>
对于类类型来说，由于有构造函数所以值初始化意义不大，但是对于内置类型，两种类型的差别很大，值初始化的内置类型有着良好定义的值，而默认初始化的值则是未定义的<br>
最好对动态分配的对象进行初始化，原因与初始化变量相同，防止调用未定义值的对象<br>
如果我们提供了一个括号包围的初始化器就可以auto，从此初始化器来推断我们想要分配的对象的类型，但是只有当括号中仅有单一初始化器时才可以使用auto</p>
<p>用new 分配const 对象时合法的，但是必须对const对象进行初始化，然后new返回的指针是一个指向const 的指针<br>
一旦内存耗尽，new表达式就会失败，默认情况下会抛出一个类型为bad_alloc的异常，<br>
使用定位new 的方式阻止它抛出异常：<code>int *p2 = new (nothrow) int;</code>如果分配失败，返回一个空指针<br>
定位new表达式允许我们向new传递额外的参数，例子中我们传递给它一个由标准库定义的名为nothrow的对象，如果将nothrow传递给new，就是告诉他不能抛出异常</p>
<p>delete也是销毁给定指针指向的对象，释放相应的内存<br>
传递给delete的指针必须指向动态分配的内存，或者是一个空指针，释放一块并非new分配的内存，或者将相同的指针值释放多次，其行为都是未定义的<br>
释放一个空指针总是没有错误的<br>
通常情况下编译器不能分辨一个指针指向静态还是动态分配的对象，同样也不能分辨指针指向的内存是否已被释放，所以错误的delete表达式都会被通过<br>
const对象的值不能被改变，但是它本身是可以被销毁的<br>
对于一个由内置指针管理的动态对象，直到被delete显式释放之前它都是存在的<br>
所以调用者必须记得释放内存<br>
与类类型不同，内置类型的对象被销毁时什么也不会发生，特别是一个指针离开其作用域时其指向的对象什么也不会发生，如果这个指针指向的是动态内存，那么内存将不会被自动释放，所以由内置指针管理的动态内存在被显式释放之前一直都会存在<br>
忘记delete释放动态内存就会导致内存泄漏问题<br>
当我们delete一个指针后指针值就变为无效，虽然指针已经无效，但是该指针仍然保存着（已经释放后）动态内存的地址，在delete后指针变成空悬指针<br>
避免空悬指针需要在指针离开其作用域之前释放掉它所关联的内存 重制指针值为nullptr<br>
但上述方法对于指向同一内存的多个指针无效，只能作用于单一指针</p>
<p>12.1.3 shared_ptr和new结合使用<br>
我们可以用new返回的指针来初始化智能指针<br>
单接受指针参数的智能指针构造函数explicit的，所以我们不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化的形式来初始化一个智能指针<br>
一个返回shared_ptr的函数不能在其返回语句中隐式转换一个普通指针</p>
<p>默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，但我们可以将智能指针绑定到一个指向其他类型的资源（例如类类型）的指针上，但是这样做必须提供自己的操作来代替默认delete<br>
shared_ptr可以协调对象的析构，但这仅限于自身的拷贝（也就是shared_ptr之间）<br>
当临时shared_ptr对象被销毁时，它所指向的内存会被释放<br>
当将一个shared_ptr绑定到一个普通指针时，我们就将内存的管理责任交给了这个shared_ptr，一旦这样做了，我们就不应该再使用内置指针来访问shared_ptr所指向的内存了<br>
使用内置指针来访问智能指针所负责的对象是很危险的，因为我们<strong>无法知道对象何时会被销毁。</strong><br>
智能指针类型定义了一个名为get的函数，它返回一个内置指针，指向智能指针管理的对象，get函数主要是为了向不能使用智能指针的代码传递一个内置指针。<strong>使用get返回的指针的代码不能delete此指针</strong><br>
只有在确定代码不会delete指针的情况下才能使用get，永远不要用get初始化另一个智能指针或者为另一个智能指针赋值（因为不知道对象何时会被销毁）</p>
<p>我们可以用reset来将一个指向相同值的新的指针（一个新的对象的指针）赋予一个shared_ptr（相当于复制其值然后创建一个新的指针）</p>
<p>习题12.10<br>
正确，其实就是将p的指针值进行拷贝，注意会引发指针计数值+1<br>
习题12.11<br>
编译器不会报错，但是get返回的指针是普通指针，此时不会引发计数值+1，导致可能get返回指针指向的对象可能被销毁而process继续调用。<br>
习题11.12<br>
(a)合法，首先复制sp，将sp的引用计数+1，然后程序结束再-1<br>
(b)不合法，智能指针的构造函数是explicit的，不能进行隐式的转换<br>
(c)错误，同上<br>
(d)合法！但是程序结束后会释放内存，p变成空悬指针。<br>
注意<code>process(shared_ptr&lt;int&gt;(p))</code>虽然是复制，但是指向的对象相同，智能指针照样会计数+1然后计数-1销毁内存，而因为两者指向相同的对象，导致原来的普通指针p变成空悬指针。<br>
相同12.13<br>
删除p之后，会导致p指向的内存被释放，此时sp就会变成空悬指针，在sp指针被销毁时，该块内存会被二次delete，执行后产生错误：double free</p>
<p>12.1.4智能指针和异常<br>
当发生异常时，内置指针直接管理的内存是不会自动释放（但是智能指针的会检查引用计数并销毁）<br>
类需要用户显式地释放所使用的任何资源<br>
可以使用shared_ptr来管理其他对象（比如类），但是需要定义一个对应的函数来代替delete<br>
<img src="https://lixin-scut.github.io//post-images/1571232741628.png" alt=""></p>
<p>12.1.5unique_ptr<br>
一个unique_ptr拥有它所指向的对象，与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时，它所指向的对象也会被销毁<br>
unique_ptr与shared_ptr不同，没有类似make_shared的标准库函数，当我们定义一个unique_ptr时，需要将其绑定到一个new返回的指针上，初始化unique_ptr必须采用直接初始化的形式<br>
unique_ptr不支持普通的拷贝或赋值操作<br>
1.unique_ptr不允许拷贝是指不能用一个unique_ptr拷贝到另一个unique_ptr，但是如果使用new出来的普通指针初始化unique_ptr是可以的，<br>
例如</p>
<pre><code>int *pi =new int(42);
unique_ptr&lt;int&gt; p1(pi);
</code></pre>
<p>2.并非是new出来的指针，在栈内存而不是动态内存，所以不应使用智能指针（通过编译，但是编译器会自动delete栈内存，智能指针又delete一次，所以造成二次delete）<br>
虽然我们不能拷贝或赋值unique_ptr,但可以通过调用release或reset将指针的所有权从一个（非const）unique_ptr转移给另一个unique_ptr<br>
release成员返回unique_ptr当前保存的指针并将其置为空<br>
reset成员接受一个可选的指针参数，令unique_ptr重新指向给定的指针。如果unique_ptr不为空，它原来指向的对象就会被释放<br>
调用release会切断unique_ptr和它原来管理的对象间的联系，release返回的指针通常被用来初始化另一个智能指针或给另一个智能指针赋值。如果我们不用另一个智能指针来保存release返回的指针，我们的程序就要负责资源的释放（注意此时对象还没被销毁）<br>
不能拷贝unique_ptr的规则有一个例外，我们可以拷贝或赋值一个将要被销毁的unique_ptr<br>
unique_ptr默认情况下使用delete释放它指向的对象，但同时我们可以重载unique_ptr中默认的删除器<br>
我们必须在尖括号中unique_ptr指向类型之后提供删除器类型</p>
<p>由于decltype(end_connection)返回一个函数类型，所以我们必须添加一个*来指出我们正在使用该类型的一个指针</p>
<p>12.1.6weak_ptr<br>
weak_ptr是一种不控制所指向对象生存期的智能指针，它指向由一个shared_str管理的对象。将一个weak_ptr绑定到一个shared_ptr，<strong>不会改变shared_ptr的引用计数</strong><br>
当shared_ptr引用计数为0时，即使有weak_ptr指向对象，对象也还是会被释放</p>
<p>当我们创建一个weak_ptr时，<strong>要用一个shared_ptr来初始化它</strong><br>
由于对象可能不存在，我们<strong>不能使用weak_ptr直接访问对象，而必须调用lock</strong>，此函数检查weak_ptr指向的对象是否仍存在<br>
通过weak_ptr，<strong>不会影响</strong>一个给定的StrBlob所指向的vector的<strong>生存期</strong>，但是可以阻止用户访问一个不再存在的vector的企图。<strong>（强制使用lock返回shared_ptr）</strong></p>
<p>习题感悟<br>
私有函数private相比于public公有函数的好处在于某些时候可以不用考虑判断条件，比如不用担心会向size_type传入负数<br>
q指针赋给r,如果释放了q，则此时的r指针为空悬指针。<br>
注意<code>process(shared_ptr&lt;int&gt;(p))</code>虽然是复制，但是指向的对象相同，智能指针照样会计数+1然后计数-1销毁内存，而因为两者指向相同的对象，导致原来的普通指针p变成空悬指针。<br>
删除p之后，会导致p指向的内存被释放，此时sp就会变成空悬指针，在sp指针被销毁时，该块内存会被二次delete，执行后产生错误：double free<br>
1.unique_ptr不允许拷贝是指不能用一个unique_ptr拷贝到另一个unique_ptr，但是如果使用new出来的普通指针初始化unique_ptr是可以的，<br>
例如</p>
<pre><code>int *pi =new int(42);
unique_ptr&lt;int&gt; p1(pi);
</code></pre>
<p>2.并非是new出来的指针，在栈内存而不是动态内存，所以不应使用智能指针（通过编译，但是编译器会自动delete栈内存，智能指针又delete一次，所以造成二次delete）<br>
注意对于友元的声明，等于声明加上一个friend，类的声明必须带上class或者struct，但是友元声明不等同于普通声明<br>
涉及了两个class相互引用的问题<br>
一：2个类需要在一个文件中 二：这2个函数必须先声明不定义 三: 函数的定义必须放到StrBlobPtr定义的后面</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[内存泄漏]]></title>
        <id>https://lixin-scut.github.io//post/nei-cun-xie-lou</id>
        <link href="https://lixin-scut.github.io//post/nei-cun-xie-lou">
        </link>
        <updated>2020-02-22T07:39:45.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>内存泄漏的定义<br>
内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制；</li>
<li>内存泄露的原因和后果</li>
</ol>
<p>总结下来，内存泄露常见的有几个原因：</p>
<p>1、编码错误：malloc、realloc、new申请的内存在堆上，需要手动显示释放，调用free或delete。申请和释放必须成对出现malloc/realloc对应free，new对应delete。前者不会运行构造/析构函数，后者会。对于C++内置数据类型可能没差别，但是对于自己构造的类，可能在析构函数中释放系统资源或释放内存，所以要对应使用。</p>
<p>2、“无主”内存：申请内存后，指针指向内存的起始地址，若丢失或修改这个指针，那么申请的内存将丢失且没有释放。</p>
<p>3、异常分支导致资源未释放：程序正常执行没有问题，但是如果遇到异常，正常执行的顺序或分支会被打断，得不到执行。所以在异常处理的代码中，要确保系统资源的释放。</p>
<p>4、隐式内存泄露：程序运行中不断申请内存，但是直到程序结束才释放。有些服务器会申请大量内存作为缓存，或申请大量资源作为线程池，这些资源一直占用直到程序退出。服务器运行起来一般持续几个月，不及时释放可能会导致内存耗尽。</p>
<p>5、类的析构函数为非虚函数：析构函数必须为虚函数才能利用多态来调用指针指向对象的析构函数，而不是基类的析构函数。</p>
<p>只发生一次小的内存泄漏可能不被注意，但泄漏大量内存的程序将会性能下降到内存逐渐用完，导致程序崩溃；</p>
<ol start="3">
<li>如何排除<br>
使用工具软件BoundsChecker，BoundsChecker是一个运行时错误检测工具，它主要定位程序运行时期发生的各种错误；<br>
调试运行DEBUG版程序，运用以下技术：CRT(C run-time libraries)、运行时函数调用堆栈、内存泄漏时提示的内存分配序号(集成开发环境OUTPUT窗口)，综合分析内存泄漏的原因，排除内存泄漏。</li>
</ol>
<p>检测内存泄漏的办法：<br>
一、<br>
在Linux平台上 有valgrind可以非常方便的帮助我们定位内存泄漏，因为Linux在开发领域的使用场景大多是跑服务器，再加上它的开源属性，相对而言，处理问题容 易形成“统一”的标准。而在Windows平台，服务器和客户端开发人员惯用的调试方法有很大不同。下面结合我的实际经验，整理下常见定位内存泄漏的方 法。<br>
注意：我们的分析前提是Release版本，因为在Debug环境下，通过VLD这个库或者CRT库本身的内存泄漏检测函数能够分析出内存泄漏，相对而言比较简单。而服务器有很多问题需要在线上并发压力情况下才出现，因此讨论Debug版调试方法意义不大。</p>
<p>二、对象计数<br>
方法：在对象构造时计数++，析构时–，每隔一段时间打印对象的数量<br>
优点：没有性能开销，几乎不占用额外内存。定位结果精确。<br>
缺点：侵入式方法，需修改现有代码，而且对于第三方库、STL容器、脚本泄漏等因无法修改代码而无法定位。</p>
<p>三、重载new和delete<br>
方法：重载new/delete，记录分配点（甚至是调用堆栈），定期打印。<br>
优点：没有看出<br>
缺点：侵入式方法，需将头文件加入到大量源文件的头部，以确保重载的宏能够覆盖所有的new/delete。记录分配点需要加锁（如果你的程序是多线程），而且记录分配要占用大量内存（也是占用的程序内存）。</p>
<p>四、Hook Windows系统API<br>
方法：使用微软的detours库，hook分配内存的系统Api：HeapAlloc/HeapRealloc/HeapFree（new/malloc的底层调用）,记录分配点，定期打印。<br>
优点：非侵入式方法，无需修改现有文件（hook api后，分配和释放走到自己的钩子函数中），检查全面，对第三方库、脚本库等等都能统计到。<br>
缺点：记录内存需要占用大量内存，而且多线程环境需要加锁。</p>
<p>五、使用DiagLeak检测<br>
微软出品的内存泄漏分析工具，原理同hookapi方式。配合LDGraph可视化展示内存分配数据，更方便查找泄漏。<br>
1.在IDE工程选项里面配置Release版本也生成调试信息，发布时，将pdb文件和exe文件一起发布。<br>
2.程序运行后，打开LeakDiag，设置Symbol path<br>
3.定期Log下目标进程的内存分配情况，通过LDGraph打印分配增长情况，来发现内存泄漏。<br>
优点：同hookapi方法，非侵入式修改，无需做任何代码改动。跟踪全面。可视化分析堆栈一览无余！<br>
缺点：对性能有影响，hook分配加锁，遍历堆栈。但是不会占用目标进程的自身内存。</p>
<ol start="4">
<li>
<p>解决方法<br>
少用堆内存多用栈内存，RAII与智能指针（正好对应两种检测方法）<br>
a)	RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”，也就是说在构造函数中申请分配资源，在析构函数中释放资源。因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。<br>
b)	智能指针（std::shared_ptr和std::unique_ptr）即RAII最具代表的实现，使用智能指针，可以实现自动的内存管理，再也不需要担心忘记delete造成的内存泄漏。毫不夸张的来讲，有了智能指针，代码中几乎不需要再出现delete了。</p>
</li>
<li>
<p>检查、定位内存泄漏<br>
在Debug环境下，通过VLD这个库或者CRT库本身的内存泄漏检测函数能够分析出内存泄漏，相对而言比较简单。<br>
内存泄露的关键就是记录分配的内存和释放内存的操作，看看能不能匹配。跟踪每一块内存的声明周期，例如：每当申请一块内存后，把指向它的指针加入到List中，当释放时，再把对应的指针从List中删除，到程序最后检查List就可以知道有没有内存泄露了。Window平台下的Visual Studio调试器和C运行时（CRT）就是用这个原理来检测内存泄露。</p>
</li>
</ol>
<p>在VS中使用时，需加上</p>
<pre><code>#define _CRTDBG_MAP_ALLOC
#include &lt;crtdbg.h&gt;
</code></pre>
<p>crtdbg.h的作用是将malloc和free函数映射到它们的调试版本_malloc_dbg和_free_dbg，这两个函数将跟踪内存分配和释放（在Debug版本中有效）<br>
<code>_CrtDumpMemoryLeaks();</code><br>
函数将显示当前内存泄露，也就是说程序运行到此行代码时的内存泄露，所有未销毁的对象都会报出内存泄露，因此要让这个函数尽量放到最后。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 题25:合并两个排序的链表]]></title>
        <id>https://lixin-scut.github.io//post/lian-biao-ti-25he-bing-liang-ge-pai-xu-de-lian-biao</id>
        <link href="https://lixin-scut.github.io//post/lian-biao-ti-25he-bing-liang-ge-pai-xu-de-lian-biao">
        </link>
        <updated>2020-02-21T16:07:34.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
</blockquote>
<pre><code>class Solution {
public:
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2)
    {
        ListNode *virHead=new ListNode(-1);
        ListNode *cur=virHead;
        while(pHead1&amp;&amp;pHead2){
            if(pHead1-&gt;val&lt;=pHead2-&gt;val)
                cur-&gt;next=pHead1,pHead1=pHead1-&gt;next;
            else
                cur-&gt;next=pHead2,pHead2=pHead2-&gt;next;
            cur=cur-&gt;next;
        }
        cur-&gt;next=pHead1?pHead1:pHead2;//这里很重要，配合判断条件能够避免输入NULL指针的情况
        return virHead-&gt;next;
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>最容易犯两种错误：一是在写代码之前没有想清楚合并的过程，最终合并出来的链表要么中间断开了、要么并没有做到递增排序；二是代码在鲁棒性方面存在问题，程序一旦有特殊的输入（如空链表）就会崩溃。<br>
首先分析合并两个链表的过程。我们的分析从合并两个链表的头节点 开始。链表1的头节点的值小于链表2的头节点的值，因此链表1的头节点将是合并后链表的头节点<br>
我们继续合并两个链表中剩余的节点。在 两个链表中剩下的节点依然是排序的，因此合并这两个链表的步骤和前面 的步骤是一样的。我们还是比较两个头节点的值。此时链表2的头节点的 值小于链表1的头节点的值，因此链表2的头节点的值将是合并剩余节点 得到的链表的头节点。我们把这个节点和前面合并链表时得到的链表的尾节点<br>
当我们得到两个链表中值较小的头节点并把它链接到已经合并的链表 之后，两个链表剩余的节点依然是排序的，因此合并的步骤和之前的步骤是一样的。这就是典型的递归过程，我们可以定义递归函数完成这一合并过程<br>
每当代码试图访问空指针指向的内 存时程序就会崩溃，从而导致鲁棒性问题。在本题中一旦输入空的链表就 会引入空的指针，因此我们要对空链表单独处理。当第一个链表是空链表, 也就是它的头节点是一个空指针时，那么把它和第二个链表合并，显然合 并的结果就是第二个链表。同样，当输入的第二个链表的头节点是空指针 的时候，我们把它和第一个链表合并得到的结果就是第一个链表。如果两个链表都是空链表，则合并的结果是得到一个空链表。</p>
</blockquote>
<pre><code>ListNode* Merge(ListNode* pHead1, ListNode* pHead2)
{
    if(pHead1 == nullptr)
        return pHead2;
    else if(pHead2 == nullptr)
        return pHead1;

    ListNode* pMergedHead = nullptr;

    if(pHead1-&gt;m_nValue &lt; pHead2-&gt;m_nValue)
    {
        pMergedHead = pHead1;
        pMergedHead-&gt;m_pNext = Merge(pHead1-&gt;m_pNext, pHead2);
    }
    else
    {
        pMergedHead = pHead2;
        pMergedHead-&gt;m_pNext = Merge(pHead1, pHead2-&gt;m_pNext);
    }

    return pMergedHead;
}
</code></pre>
<p>我感觉我的程序更加精简，同时兼顾了鲁棒性，然后书本的题解使用了递归思想，非常巧妙，但是需要额外的判断条件。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 题24:反转链表]]></title>
        <id>https://lixin-scut.github.io//post/lian-biao-ti-24fan-zhuan-lian-biao</id>
        <link href="https://lixin-scut.github.io//post/lian-biao-ti-24fan-zhuan-lian-biao">
        </link>
        <updated>2020-02-21T02:24:11.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
输入一个链表，反转链表后，输出新链表的表头。链表节点定义如下：<br>
/*<br>
struct ListNode {<br>
int val;<br>
struct ListNode <em>next;<br>
ListNode(int x) :<br>
val(x), next(NULL) {<br>
}<br>
};</em>/</p>
</blockquote>
<p>同样地需要三个指针，注意一定要记得<code>ListNode *pre,*cur,*cur_next;</code>是每个变量都需要*号，否则的话就等于ListNode了<br>
然后其实这一题不需要虚拟头节点，完全可以pre声明为NULL，配合while(cur!=NULL)甚至可以省略掉判断头节点是否为NULL</p>
<pre><code>class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
        ListNode *pre,*cur,*cur_next;
        pre=NULL;
        cur=pHead;
        while(cur!=NULL){
            cur_next=cur-&gt;next;
            cur-&gt;next=pre;
            pre=cur;
            cur=cur_next;
        }
        return pre;
    }
};
</code></pre>
<p>书本题解：<br>
由于节点i的m_pNext指向了它的前一个节点，导致我们无法在链表中遍历到节点j。为了避免链表在节点i处断开，我们需要在调整节点i的m_pNext之前，把节点j保存下来。<br>
也就是说，我们在调整节点i的m_pNext指针时，除了需要知道节点i 本身，还需要知道i的前一个节点h,因为我们需要把节点i的m_pNext指向节点h。同时，我们还需要事先保存i的一个节点j，以防止链表断开。 因此，相应地我们需要定义3个指针，分别指向当前遍历到的节点、它的 前一个节点及后一个节点。<br>
最后我们试着找到反转后链表的头节点。不难分析出反转后链表的头节点是原始链表的尾节点。什么节点是尾节点？自然是m_pNext为nullptr 的节点。<br>
需要避免的问题：<br>
•	输入的链表头指针为nullptr或者整个链表只有一个节点时，程序立即崩溃。<br>
•	反转后的链表出现断裂。<br>
•	返回的反转之后的头节点不是原始链表的尾节点。<br>
至少应该想到以下几类测试用例对代码进行功能测试：<br>
•	输入的链表头指针是nullptr。<br>
•	输入的链表只有一个节点。<br>
•	输入的链表有多个节点。</p>
<pre><code>ListNode* ReverseList(ListNode* pHead)
{
    ListNode* pReversedHead = nullptr;
    ListNode* pNode = pHead;
    ListNode* pPrev = nullptr;
    while(pNode != nullptr)
    {
        ListNode* pNext = pNode-&gt;m_pNext;

        if(pNext == nullptr)
            pReversedHead = pNode;

        pNode-&gt;m_pNext = pPrev;

        pPrev = pNode;
        pNode = pNext;
    }

    return pReversedHead;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Buffer类]]></title>
        <id>https://lixin-scut.github.io//post/buffer-lei</id>
        <link href="https://lixin-scut.github.io//post/buffer-lei">
        </link>
        <updated>2020-02-20T11:34:36.000Z</updated>
        <content type="html"><![CDATA[<p>Buffer是非阻塞TCP网络编程必不可少的东西，需要用Buffer来处理数据输入和数据输出。<br>
Buffer和Timestamp是唯独两个具有值语义的对象。<br>
其中Timestamp是poll(2)返回的时刻，即消息到达的时刻，这个时刻早于读到 数据的时刻(read(2)调用或返回)。因此如果要比较准确地测量程序处理消息的内 部延迟，应该以此时刻为起点，否则测出来的结果偏小，特别是处理并发连接时效果 更明显。</p>
<p>Buffer类的设计与使用<br>
非阻塞IO总是与IO复用函数（select/poll/epoll）一起使用，所以应用层的buffer是必需的。non-blocking IO的核心思想是避免阻塞在read或write或其他IO系统调 用上，这样可以最大限度地复用thread-of-control,让一个线程能服务于多个socket 连接。IO线程只能阻塞在IO multiplexing函数上，select/poll/epoll_wait。同时应用层的缓冲是必需的，每个TCP socket都要有input buffer和 output buffer</p>
<p>对于应用程序而言，它只管生成数据，它不应该关心到底数据是一次性发送还是 分成几次发送，这些应该由网络库来操心，程序只要调用TcpConnection::send()就 行了，网络库会负责到底。网络库应该接管这剩余数据，把它保存在该TCP connection的output buffer里，然后注册ROLLOUT事件，一旦socket变得可写就立 刻发送数据。如果还有剩余，网络库应该继续关注ROLLOUT事件；如果写完了数据,网络库应该停止关注ROLLOUT, 以免造成 busy loopo</p>
<p>TcpConnection必须要有output buffer，并且当输出缓冲中还有待发送的数据时，程序希望关闭连接的话，此时网络库必须等待数据发送完毕，而不能立即关闭连接</p>
<p>因为使用的是Epoll的LT电平触发，所以网络库在处理socket可读事件的时候必须一次性把socket中的数据读完（从内核buffer到应用层buffer），否则会一直触发POLLIN事件</p>
<p>此时就会出现“粘包”现象，亦即buffer中有部分数据不完整的情况，需要使用codec分包，等待构成一条完整的信息再通知程序的业务逻辑</p>
<p>为什么不用边缘触发edge trigger 一是与传统的poll兼容，二是电平触发编程更容易，三是读写的时候不必等候出现EAGAIN，可以节省系统调用，降低延迟<br>
事件触发采用level trigger,因此并不会反复调用read()直到其返回EAGAIN,从而可以降低消息处理的延迟。</p>
<p>Buffer类的实现细节<br>
Buffer不是线程安全的<br>
•对于input buffer, onMessage()回调始终发生在该TcpConnection所属的那个 IO线程，应用程序应该在onMessage()完成对input buffer的操作，并且不要 把input buffer暴露给其他线程。这样所有对input buffer的操作都在同一个线 程，Buffer class不必是线程安全的。<br>
•对于output buffer,应用程序不会直接操作它，而是调用TcpConnection::send ()来发送数据，后者是线程安全的。<br>
如果TcpConnection:: send()调用发生在该TcpConnection所属的那个IO线程, 那么它会转而调用TcpConnection:: sendlnLoop , sendlnLoop()会在当前线程(也 就是IO线程)操作output buffer；如果TcpConnection::send()调用发生在别的 线程，它不会在当前线程调用sendlnLoopO, rfl］是通过EventLoop: : runlnLoop ()把 sendlnLoop函数调用转移到IO线程</p>
<p>首先需要给 TcpConnection 添加 inputBuffer_ 成员变量。<br>
然后TcpConnection:: handleRead()成员函数会使用Buffer来读取数据。</p>
<p>一般不需要直接操作buffer<br>
buffer内部是vector&lt; char &gt; ，是一块连续的内存,同时buffer准备了一块额外的65536栈上内存extrabuf，利用readv来读取内存，既避免了需要一个很大的出事buffer，也避免了反复调用read造成的系统开销</p>
<p>主buffer分为三个部分：prependable、readable、writable<br>
<img src="https://lixin-scut.github.io//post-images/1582201221076.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582201289610.png" alt=""><br>
buffer使用下标而不是迭代器，因为vector是自增长的，重新分配内存之后会使得原来的指针失效</p>
<p>Buffer 里有两个常数 kCheapPrepend 和 klnitialSize,定义了 prependable的初始大小和writable的初始大小，readable的初始大小为0。</p>
<p>每当全部数据读完了，readindex == writeindex，readindex和writeindex返回原位以备新一轮使用</p>
<p>vector的capacity() 以指数方式自动动态增长，让push_back()的平均复杂度是常数。</p>
<p>内部腾挪<br>
有时候，经过若干次读写，readindex移到了比较靠后的位置，留下了巨大的 prependable空间，Buffer在这种情况下不会重新分配内存，而是先把已有的数据移到前面去，腾出 writable空间</p>
<p>prepend前方添加：有时候readIndex比较靠后，buffer前半部分有一定的空间，可以先序列化消息，然后再在序列化数据的前面添加消息的长度</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[移动语义和完美转发]]></title>
        <id>https://lixin-scut.github.io//post/yi-dong-yu-yi-he-wan-mei-zhuan-fa</id>
        <link href="https://lixin-scut.github.io//post/yi-dong-yu-yi-he-wan-mei-zhuan-fa">
        </link>
        <updated>2020-02-20T10:33:14.000Z</updated>
        <content type="html"><![CDATA[<p>个人总结：</p>
<h3 id="移动语义">移动语义</h3>
<p>移动是相对于拷贝来说，亦即我们希望对对象进行拥有权的转移而不是简单地创造一个完全一样的对象，比如指针，我们希望直接移交指针，而不是创造指针指向的对象再新建一个指针指向它<br>
当然需要移动的一个重要原因是IO类或unique_ptr等类不应该被拷贝，包含不能被共享的资源（我的网络库项目中继承了boost::noncopyable的也不能被拷贝）<br>
移动构造函数和移动赋值函数就是这么来的<br>
用高级语言之间的术语来说就是类似做了一次浅拷贝，而不是深拷贝，但是我们使用了右值<br>
简单来说，一个<strong>左值表达式</strong>表示的是一个<strong>对象的身份</strong>，一个<strong>右值表达式</strong>表示的是<strong>对象的值</strong>，更通俗地说：凡是取地址（&amp;）操作可以成功的都是左值，其余都是右值。从而对于左值的引用就是左值引用，而对于右值的引用就是右值引用。（注意右值引用本身等于一个表达式，也是一个左值）<br>
但是我们不能直接把一个左值绑定到右值引用上，必须使用std::move,将左值转换为右值。<br>
但是move也不是随便用的调用move后，我们<strong>不能再对移后源对象</strong>的值<strong>做任何假设</strong>，<strong>只能对其进行销毁或赋予新值</strong>，不能使用一个移后源对象的值。</p>
<p>move的原理就是利用了类型折叠，<strong>通常</strong>我们<strong>不能将一个右值引用</strong>绑定到一个<strong>左值</strong>上，但是，c++语言在正常绑定规则之外定义了<strong>两个例外规则</strong><br>
当我们将一个<strong>左值</strong>（如i）传递给函数的<strong>右值引用参数</strong>，且此右值引用指向模板类型参数（如T&amp;&amp;）时，编译器<strong>推断模板类型参数</strong>为实参的<strong>左值引用</strong>类型。因此，当我们调用f3（i）时，编译器推断<strong>T</strong>的类型为<strong>int&amp;，而非int</strong><br>
通常我们<strong>不能（直接）定义</strong>一个<strong>引用的引用</strong>，但是，通过<strong>类型别名</strong>或通过<strong>模板类型参数间接定义</strong>是可以的<br>
在这种情况下，我们可以使用第二个例外绑定规则：如果我们间接创建一个<strong>引用的引用</strong>，则这些<strong>引用</strong>形成了 <strong>“折叠”</strong>。在所有情况下（除了一个例外），引用会<strong>折叠成</strong>一个<strong>普通的左值引用类型</strong>。在新标准中，折叠规则扩展到右值引用。<strong>只在一种特殊情况下</strong>引用会<strong>折叠成右值引用：右值引用的右值引用</strong>。即，对于一个给定类型X：<br>
1.X&amp;、&amp;、X&amp; &amp;&amp;和X&amp;&amp; &amp;都折叠成类型X&amp;<br>
2.<strong>类型X&amp;&amp; &amp;&amp;折叠成X&amp;&amp;</strong><br>
move是一个函数模板，而不是一个单独的函数，源代码比较精简，就贴上了了<br>
<img src="https://lixin-scut.github.io//post-images/1582273516470.png" alt=""></p>
<h3 id="完美转发">完美转发</h3>
<p>这个还是我第一次见到的新词，不过其实《C++ primer》里面也有提到了，但是单独一小节转发作为介绍<br>
其核心思想也很简单，如果函数模板中调用了另一普通函数，假设普通函数希望获得外部元素的引用，那么我们就把引用传进来，但是正常情况下，形参会忽略顶层const和引用（就是你传个int引用给模板，模板肯定认为是int，不可能直接认为是int&amp;），此时普通函数就永远无法获得一个引用。<br>
此时可能我们可能会想到用前面的引用折叠啊！那样子的话就可以保存左值引用/右值引用的性质啦！<br>
确实如此，但是有一个很细微的问题，就是前面提到的，<strong>右值引用本身等于一个表达式，也是一个左值</strong>，如果把一个右值传给实例化模板，固然得到了右值引用，但是右值引用本身又是一个左值。。。如果普通函数此时希望得到一个右值来填充右值引用形参，就无法保持右值这个性质了【注意是右值不是右值引用】。<br>
此时就需要新工具了 为了能够保持原对象的性质，这时，我们需要<code>std::forward&lt;T&gt;()</code>。与std::move()相区别的是，move()会无条件的将一个参数转换成右值，而forward()则会保留参数的左右值类型。<br>
emplace_back 和 emplace 就是典型的利用forward的例子，，当 emplace _ back 将这些实参传递给 construct 时，我们必须使用 forward来保持实参的原始类型<br>
原理：insert或push成员，此时会使用拷贝初始化，与之相对的是emplace会使用直接初始化，emplace将参数传递给元素类型的构造函数，在容器内存空间中直接构造元素，而不是push、insert等拷贝值<br>
emplace可以接受可变数量的形参，push insert只能单个</p>
<h3 id="参考资料">参考资料：</h3>
<p>《C++ primer》<br>
13.6对象移动<br>
使用移动而不是拷贝的另一个原因源于<strong>IO类或unique_ptr等类不应该被拷贝</strong>，包含不能被共享的资源<br>
在旧标准中，没有直接的方法移动对象，在新标准中，我们可以<strong>用容器保存不可以拷贝</strong>的类型，只要它们能被<strong>移动</strong>即可<br>
标准库容器、string和shared_ptr类既支持移动也支持拷贝，<strong>IO类和unique_ptr类可以移动但不可以拷贝</strong></p>
<p>13.6.1右值引用<br>
为了<strong>支持移动操作</strong>，新标准引入了一种新的引用类型—<strong>右值引用</strong>，其有一个重要的性质，<strong>只能绑定到一个将要销毁的对象</strong>，因此我们可以自由地将一个<strong>右值引用的资源移动到另一个对象中</strong><br>
一般而言，一个<strong>左值表达式</strong>表示的是一个<strong>对象的身份</strong>，一个<strong>右值表达式</strong>表示的是<strong>对象的值</strong><br>
对于常规引用（即左值引用），我们<strong>不能</strong>将其绑定到要求<strong>转换的表达式、字面常量或是返回右值的表达式</strong>。而右值引用完全相反，我们可以将一个右值引用绑定到这类表达式上，但<strong>不能将一个右值引用直接绑定到一个左值上</strong>。<br>
<img src="https://lixin-scut.github.io//post-images/1582271568985.png" alt=""><br>
左值引用可用的表达式：返回左值引用的函数，赋值、下标、解引用和<strong>前置递增/递减运算符</strong><br>
右值引用可用的表达式：返回非引用类型的函数，算术、关系、位以及<strong>后置递增/递减运算符</strong><br>
但是我们可以将一个const的左值引用绑定到右值表达式中。<br>
左值表达式与右值表达式的区别：左值有持久的状态，右值要么是字面常量，要么是在表达式求值过程中创建的临时对象<br>
由于右值引用只能绑定到临时对象，所以<strong>1.所引用的对象将要被销毁2.该对象没有其他用户</strong>。这两个特性意味着使用右值引用的代码可以自由接管所引用的对象的资源<br>
右值引用指向将要被销毁的对象，因此，我们可以从绑定到右值引用的对象窃取状态<br>
<strong>变量</strong>可以看作<strong>只有一个运算对象而没有运算符的表达式</strong>，所以变量表达式都是左值 <strong>（导致右值引用本身是一个左值！）</strong><br>
<img src="https://lixin-scut.github.io//post-images/1582271716251.png" alt=""><br>
原因：变量是持久的，直至离开作用域才被销毁<br>
虽然不能将一个右值引用<strong>直接绑定</strong>到一个左值上，但可以<strong>显式</strong>地将一个<strong>左值</strong>转换为对应的<strong>右值引用</strong>类型，我们还可以用过调用一个名为move的新标准库函数来获得绑定到左值上的右值引用，move调用告诉编译器：我们有一个左值，但是我们希望像一个右值一样处理它，但<strong>对某个左值调用move后</strong>就意味着承诺除了对该左值进行<strong>赋值或销毁外不再使用它</strong><br>
int &amp;&amp;rr3 = std::move(rr1); //完成转移后，rr1为移后源对象，相当于一次移动<br>
调用move后，我们不<strong>能再对移后源对象</strong>rr1的值<strong>做任何假设</strong>，<strong>只能对其进行销毁或赋予新值</strong>，不能使用一个移后源对象的值<br>
对move不提供using声明，直接调用std::move而不是move，<strong>避免潜在的名字冲突</strong></p>
<p>13.6.2移动构造函数和移动赋值运算符<br>
移动构造函数的<strong>第一个参数</strong>是该类类型的一个<strong>引用</strong>，不同于拷贝构造函数，这个引用参数是一个<strong>右值引用</strong>，与拷贝构造函数一样，<strong>任何额外参数都必须有默认实参</strong><br>
移动构造函数必须保证移后源对象处于可销毁状态（销毁它是无害的）（对移后源对象<strong>赋值nullptr</strong>），特别是在资源完成移动后，必须保证源对象必须不再指向被移动的资源—这些资源的所有权已经归属新创建的对象<br>
移动构造函数<strong>不分配任何新内存</strong>，它接管原对象中的内存后，将<strong>给定对象中的指针</strong>都置为<strong>nullptr</strong>，从而完成从给定对象的移动操作，此对象将继续存在，移后源对象将会被销毁<br>
因为移动操作只是接管资源，通常不需要分配任何资源，因此移动操作<strong>通常不会抛出任何异常</strong>，但除非告诉标准库我们的移动构造函数不会抛出异常，否则它会认为移动我们的类对象时可能会抛出异常，并且为了处理这种可能性而做一些额外的工作<br>
<strong>noexcept是我们承诺一个函数不抛出异常</strong>的一种方法。我们在一个函数的参数列表后指定noexcept。在一个构造函数中，noexcept出现在<strong>参数列表和初始化列表开始的冒号之间</strong>，同时我们必须在类头文件的<strong>声明和定义</strong>中（<strong>定义在类外时</strong>）<strong>都指定</strong>noexcept<br>
如果<strong>不对移动构造函数显式声明noexcept，就会自动使用拷贝构造函数</strong>而不是移动构造函数<br>
<strong>移动赋值运算符也应该标记为noexcept</strong><br>
在移动赋值运算符中，我们<strong>首先检查</strong>左侧对象与右侧右值引用<strong>是否指向同一地址</strong>，如果<strong>相同则不要做任何操作</strong>（<strong>自赋值检查</strong>），否则，<strong>先释放左侧</strong>运算对象所使用的内存，并接管给定对象的内存<br>
从<strong>一个对象移动数据并不会销毁此对象</strong>，但当我们编写一个移动操作时，必须确保移后源对象<strong>进入一个可析构状态</strong>，除此之外，移动操作还必须保证移后源对象仍然是<strong>有效的（对象有效是指可以安全地为其赋予新值或者可以安全地使用而不依赖于当前值）</strong> 同时移动操作无法保证移后源对象中留下的值，所以我们的程序不应该依赖于移后源对象中的数据<br>
总结：在移动操作之后，移后源对象必须保持有效、可析构的状态，但是用户不能对其值进行任何假设<br>
<strong>编译器不会为某些类合成移动操作</strong>，特别是当一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，<strong>编译器就不会为它合成移动构造函数和移动赋值运算符，反而类会通过正常的函数匹配从而使用对应的拷贝操作来代替移动操作</strong><br>
<strong>只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符</strong>，编译器可以移动内置类型成员，如果一个成员是类类型，且该类有对应的移动操作，编译器也能移动这个成员<br>
与拷贝操作不同，<strong>移动操作永远不会隐式定义为删除的函数</strong>。但是如果我们显式地要求编译器生成=default的移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数<br>
将合成的移动操作定义为删除的函数遵循以下原则：<br>
<img src="https://lixin-scut.github.io//post-images/1582272040308.png" alt=""><br>
<strong>如果类定义了移动操作，则也必须定义拷贝操作</strong>，否则<strong>拷贝操作</strong>都会默认地被<strong>定义为删除的</strong><br>
如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则<br>
来确定使用哪个构造函数，赋值操作的情况类似<br>
<img src="https://lixin-scut.github.io//post-images/1582272110377.png" alt=""><br>
如果一个类有一个拷贝构造函数但未定义移动构造函数，编译器不会合成移动构造函数，这意味着此类将有拷贝构造函数但不会有移动构造函数。如果一个类没有移动构造函数，函数匹配规则保证该类型的对象只会被拷贝，即使我们试图通过调用 move 來移动它们时也是如此<br>
值得注意的是，用拷贝构造函数代替移动构造函数几乎肯定是安全的</p>
<p>拷贝并交换赋值运算符和移动操作</p>
<p>对于同时定义了移动构造函数和拷贝构造函数的类，将其拷贝赋值运算符的参数改成非引用类型变为通用的赋值运算符，此时运算符有一个非引用参数.这意味着此参数要进行拷 贝初始化。依赖于实参的类型，拷贝初始化要么使用拷贝构造函数，要么使用移动构造函数——左值被拷贝，右值被移动。因此，单一的赋值运算符 就实现了拷贝赋值运算符和移动赋值运算符两种功能。<br>
<img src="https://lixin-scut.github.io//post-images/1582272138253.png" alt=""><br>
更新三/五法则<br>
所有五个应该看作一个整体：一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作，并且某些类必须定义拷贝构造函数、拷贝赋值运算符和析构函数才能正确工作<br>
移动迭代器<br>
新标准库中定义了一种移动迭代器（move iterator )适配器<br>
一个移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器<br>
一个普通迭代器的解引用运算符返回一个指向元素的左值。与其他迭代器不同，移动迭代器的，解引用运算符生成一个右值引用。<br>
通过调用标准库的 make_move_iterator 函数将一个普通迭代器转换为一个移动迭代器。此函数接受一个迭代器参数，返回一个移动迭代器。<br>
原迭代器的所有其他操作在移动迭代器中都照常工作。特别是，可以将移动迭代器传递给uninitialized_copy<br>
<img src="https://lixin-scut.github.io//post-images/1582272331524.png" alt=""><br>
uninitialized _ copy 对输入序列中的毎个元素调用 construct 来将元素&quot;拷贝&quot;到目的位置。此算法使用迭代器的解引用运算符从输入序列中提取元素。由于我们传递给它的是移动迭代器，因此解引用运算符生成的是一个右值引用，这意味着 construct 将使用移动构造函数来构造元素。<br>
值得注意的是，标准库不保证哪些算法适用移动迭代器，哪些不适用。由于移动一个对象可能销毁掉原对象，因此你只有在确信算法在为一个元素赋值或将其传递给一个用户 定义的函数后不再访问它时，才能将移动迭代器传递给算法。<br>
当我们调用move是，必须绝对确认移后源对象没有其他用户</p>
<p>注意：<br>
1.noexcept不能忘了，并且声明和定义的时候都需要<br>
2.不一定需要std::move<br>
3.自检使用<code>(&amp;rhs != this)</code>而不是<code>(rhs != *this)</code>或者<code>(rhs == *this)</code>，前者是指针可以直接比较，后者是类通常没有定义<br>
4.记得先free后转移，因为进行了自移动检查，所以可以直接free</p>
<p><strong>如果类定义了移动操作，则也必须定义拷贝操作</strong>，否则<strong>拷贝操作</strong>都会默认地被<strong>定义为删除的</strong></p>
<p>13.6.3右值引用和成员函数<br>
一个成员函数最好同时提供拷贝和移动版本，一个版本接受一个指向 const 的左值引用，第二个版本接受一个指向非const 的右值引用。<br>
一般来说，我们不需要为函数操作定义接受一个 constX &amp;&amp;或是一个（普通的）X&amp;参数的版本。<br>
当我们希望从实参&quot;窃取&quot;数据时，通常传递一个右值引用。为了达到这一目的，实参不能是const的。类似的，从一个对象进行拷贝的操作不应该改变该对象。因此，通常不需要定义一个接受一个（普通的） X &amp;参数的版本。<br>
区分移动和拷贝的重载函数通常有一个版本接受一个 const T&amp;,而另一个版本接受一个 T &amp;&amp;。</p>
<p>右值和左值引用成员函数<br>
<img src="https://lixin-scut.github.io//post-images/1582272484444.png" alt=""><br>
旧标准中允许对一个右值进行赋值，为了维持向后兼容性，新标准库类仍然允许向右值赋值。但是，我们可能希望在自己的类中阻止这种用法。<br>
引用限定符：强制左侧运算对象（即this 指向的对象）是一个左值/右值。<br>
<img src="https://lixin-scut.github.io//post-images/1582272518873.png" alt=""><br>
引用限定符可以是&amp;或&amp;&amp;，分别指出 this 可以指向一个左值或右值<br>
引用限定符只能用于（非 static )成员函数，且必须同时出现在函数的声明和定义中<br>
对于&amp;限定的函数，我们只能将它用于左值；对于&amp;&amp;限定的函数，只能用于右值:<br>
<img src="https://lixin-scut.github.io//post-images/1582272551649.png" alt=""><br>
一个函数可以同时用 const 和引用限定。在此情况下，引用限定符必须跟随在const限定符之后</p>
<p>重载和引用函数<br>
就像一个成员函数可以根据是否有 const 来区分其重载版本一样，引用限定符也可以区分重载版本。而且，我们可以综合引用限定符和 const 来区分一个成员函数的重载版本<br>
<img src="https://lixin-scut.github.io//post-images/1582272623950.png" alt=""><br>
当我们对一个右值执行 sorted 时，它可以安全地直接对 data 成员进行排序。对象是一个右值，意味着没有其他用户，因此我们可以改变对象。当对一个 const 右值或一个左值执行 sorted 时，我们不能改变对象，因此就需要在排序前拷贝 data 。<br>
<img src="https://lixin-scut.github.io//post-images/1582272662022.png" alt=""><br>
如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符。</p>
<p>16.2.5 模板实参推断和引用<br>
编译器会应用正常的引用绑定规则；<strong>const是底层</strong>的，<strong>不是顶层</strong>的 <strong>（因为引用的本质就是指针，准确的说是一个常量指针，它本身不可能修改指向的对象，自带顶层）</strong><br>
<strong>注意const int&amp; 中的const是底层const 指int是const，而不是指引用</strong><br>
当一个函数参数是模板类型参数的一个<strong>普通（左值）引用</strong>时（即，形如T&amp;），绑定规则告诉我们，<strong>只能传递</strong>给它一个<strong>左值</strong>（如，一个变量或者一个返回引用类型的表达式）。实参可以是const类型，也可以不是，如果<strong>实参是const</strong>的，则<strong>T将会被推断为const类型</strong><br>
<img src="https://lixin-scut.github.io//post-images/1582272988605.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582272993157.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582273000713.png" alt=""><br>
<strong>通常</strong>我们<strong>不能将一个右值引用</strong>绑定到一个<strong>左值</strong>上，但是，c++语言在正常绑定规则之外定义了<strong>两个例外规则</strong>，允许这种绑定，这两个例外规则是move这种标准库设施正确工作的基础<br>
当我们将一个<strong>左值</strong>（如i）传递给函数的<strong>右值引用参数</strong>，且此右值引用指向模板类型参数（如T&amp;&amp;）时，编译器<strong>推断模板类型参数</strong>为实参的<strong>左值引用</strong>类型。因此，当我们调用f3（i）时，编译器推断<strong>T</strong>的类型为<strong>int&amp;，而非int</strong><br>
通常我们<strong>不能（直接）定义</strong>一个<strong>引用的引用</strong>，但是，通过<strong>类型别名</strong>或通过<strong>模板类型参数间接定义</strong>是可以的<br>
在这种情况下，我们可以使用第二个例外绑定规则：如果我们间接创建一个<strong>引用的引用</strong>，则这些<strong>引用</strong>形成了 <strong>“折叠”</strong>。在所有情况下（除了一个例外），引用会<strong>折叠成</strong>一个<strong>普通的左值引用类型</strong>。在新标准中，折叠规则扩展到右值引用。<strong>只在一种特殊情况下</strong>引用会<strong>折叠成右值引用：右值引用的右值引用</strong>。即，对于一个给定类型X：<br>
1.X&amp;、&amp;、X&amp; &amp;&amp;和X&amp;&amp; &amp;都折叠成类型X&amp;<br>
2.<strong>类型X&amp;&amp; &amp;&amp;折叠成X&amp;&amp;</strong><br>
引用折叠<strong>只能</strong>应用于<strong>间接创建的引用的引用</strong>，如类型别名或模板参数<br>
<img src="https://lixin-scut.github.io//post-images/1582273368906.png" alt=""><br>
即使f3的函数参数形式是一个右值引用（即，T&amp;&amp;），此调用也会用一个左值引用类型（即，int&amp;）实例化f3<br>
这两个规则导致了两个重要结果：<br>
1.如果一个函数参数是一个指向模板类型参数的右值引用（如，T&amp;&amp;），则它可以被绑定到一个左值；且<br>
2.如果实参是一个左值，则推断出的模板实参类型将是一个左值引用，且函数参数将会被实例化为一个（普通）左值引用参数（T&amp;）<br>
<img src="https://lixin-scut.github.io//post-images/1582273374564.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582273379208.png" alt=""><br>
T&amp;&amp; 等于拷贝 T&amp; 等于绑定引用<br>
当代码涉及的类型可能是普通（非引用）类型，也可能是引用类型时，编写正确的代码就变得异常困难（虽然remove_reference这样的类型转换类可能会有帮助）<br>
在实际中，<strong>右值引用</strong>通常用于两种情况：<strong>模板转发其实参（16.2.7）</strong> 或<strong>模板被重载（16.3）</strong><br>
目前应该注意的是，使用右值引用的函数模板通常使用我们在13.6.3节中看到的方式来进行重载（函数后添加引用限定符）<br>
<img src="https://lixin-scut.github.io//post-images/1582273477764.png" alt=""><br>
与非模板函数一样，第一个版本将绑定到可修改的右值，而第二个版本将绑定到左值或const右值。</p>
<p>注意，折叠是先观察实参的类型和形参的类型再决定T需要什么类型，而不是根据实参的类型直接决定T的类型</p>
<p>16.2.6理解std::move<br>
用途：移动操作 绑定到将要销毁的对象 1.转换的表达式<code>i*42</code> 2.字面值 42 3.返回右值的表达式<br>
标准库 move 函数（参见13.6.1节，第472页）是使用右值引用的模板的一个很好的例子。<br>
虽然不能直接将一个右值引用绑定到一个左值上，但可用 <strong>move 获得一个绑定到左值上的右值引用</strong>。由于 move 本质上可以<strong>接受任何类型的实参</strong>，因此我们不会惊讶于它是一个<strong>函数模板</strong>。<br>
<img src="https://lixin-scut.github.io//post-images/1582273516470.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582273953551.png" alt=""><br>
这正是我们所寻求的——我们希望将一个右值引用绑定到一个左值。这个实例的函数体返回 static cast &lt; string &amp;&amp;&gt;( t )。在此情况下，t的类型为 string&amp; , cast将其转换为string &amp;&amp;。</p>
<p>static _ cast 只能用于其他合法的类型转换（参见4.11.3节，第145页）。但是，这里又有一条针对右值引用的特许规则：虽然不能隐式地将一个左值转换为右值引用，但我们可以用 <strong>static _ cast 显式地将一个左值转换为一个右值引用</strong>。</p>
<p>16.2.7转发<br>
某些函数需要将其一个或多个实参连同类型不变地<strong>转发给其他函数（即在函数内部调用其他函数或自身）</strong>。在此情况下，我们需要<strong>保持</strong>被转发实参的<strong>所有性质</strong>，包括实参类型<strong>是否是 const</strong> 的以及实参是<strong>左值还是右值</strong>。<br>
<img src="https://lixin-scut.github.io//post-images/1582274032316.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582274038078.png" alt=""><br>
F，T1不相互影响，但T1可用于F（int可以作为int&amp;的参数）<br>
f和j并不相互影响<br>
<strong>j的值被拷贝到t1中，f中的引用参数被绑定到t1，而非j，从而其改变不会影响j</strong>使其参数能保持给定实参的&quot;左值性&quot;。更进一步，可以想到我们也希望保持参数的 const 属性。<br>
通过将一个函数参数定义为一个<strong>指向模板类型参数的右值引用</strong>，我们可以保持其对应实参的所有类型信息。而使用<strong>引用参数</strong>（无论是左值还是右值）使得我们可以<strong>保持 const属性</strong>，因为在<strong>引用类型中的 const 是底层的</strong>。<br>
如果一个函数参数是指向模板类型参数的<strong>右值引用(如T&amp;&amp;)</strong>，它对应的实参的<strong>const属性和左值/右值属性将得到保持</strong>，但是只完成了一半工作，如果普通函数需要右值填充右值引用，而右值引用本身还是一个左值，所以必须保持右值这个性质<br>
可使用一个名为<strong>forward</strong>的新标准库设施来传递flip2的参数，它能保持原始实参的类型。类似move,forward定义在<strong>头文件utility</strong>中。与move不同，forward<strong>必须通过显式模板实参來调用</strong>（参见16.2.2节，第603页）。forward<strong>返回该显式实参类型的右值引用</strong>。即，<strong><code>forward&lt;T&gt;</code></strong> 的返回类型是<strong>T&amp;&amp;</strong>。<br>
通常情况下.我们使用forward传递那些定义为模板类型参数的右值引用的函数参数。通过其返回类型上的<strong>引用折叠</strong>，forward可以<strong>保持</strong>给定实参的<strong>左值/右值属性</strong>：<br>
如果实参是一个右值，则 Type 是一个普通（非引用）类型，<code>forward &lt; Type &gt;</code>将返回Types&amp;&amp;。如果实参是一个左值，则通过引用折叠， Type 本身是一个左值引用类型。在此情况下，返回类型是一个指向左值引用类型的右值引用。再次对 <code>forward &lt; Type &gt;</code>的返回类型进行引用折叠，将返同一个左值引用类型。<br>
当用于一个指向模板参数类型的右值引用函数参数（T &amp;&amp;)时， forward 会保持实参类型的所有细节。<br>
<code>f（std::forward&lt;T2&gt;（t2）,std::forward&lt;T1&gt;(t1)）;</code></p>
<p>习题感悟<br>
注意：虽然会忽视顶层const，但是首先需要判断实参的类型是否相同，再判断类型是否可转换，如果两参数一个为const一个非const，不能同用一个T<br>
解引用运算符首先检查curr是否仍在作用范围内，如果是，则返回curr所指元素的一个引用。<br>
注意 单引号的'a'就是char类型<br>
将sum返回的类型自动改为保证足够容纳其计算结果的类型，decltype会自动判断a+b需要什么类型才能容纳</p>
<pre><code>template &lt;typename T&gt; auto sum(const T&amp;a,const T&amp;b) -&gt;decltype(a+b)//将函数的返回类型指定为a+b的类型
{
	return a+b;
}
</code></pre>
<p>注意，折叠是先观察实参的类型和形参的类型再决定T需要什么类型，而不是根据实参的类型直接决定T的类型</p>
<p>博客<br>
<a href="https://blog.csdn.net/suchto/article/details/54947998">移动语义（move semantic）和完美转发（perfect forward）</a><br>
<a href="https://www.jianshu.com/p/d19fc8447eaa">[c++11]我理解的右值引用、移动语义和完美转发</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 题23:链表中环的入口节点]]></title>
        <id>https://lixin-scut.github.io//post/lian-biao-ti-23lian-biao-zhong-huan-de-ru-kou-jie-dian</id>
        <link href="https://lixin-scut.github.io//post/lian-biao-ti-23lian-biao-zhong-huan-de-ru-kou-jie-dian">
        </link>
        <updated>2020-02-20T01:29:07.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述<br>
给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p>
<p>这道题一个就是hashset，一个就是双指针法<br>
我并没有参考书本的双指针法，而是使用了leetcode的方法，但是需要注意赋新值给快指针时需要slow也前进一步，因为相当于fast先走一步，所以slow也必须next一次（需要复习一下leetcode上的数学证明）</p>
<pre><code>class Solution {
public:
    //双指针
    ListNode* EntryNodeOfLoop(ListNode* pHead){
        if(pHead==NULL)
            return NULL;
        ListNode *fast,*slow;
        fast=pHead-&gt;next;
        slow=pHead;
        while(fast!=slow){
            if(fast==NULL||fast-&gt;next==NULL)
                return NULL;
            fast=fast-&gt;next-&gt;next;
            slow=slow-&gt;next;
        }
        slow=slow-&gt;next;
        fast=pHead; //注意因为这一步相当于fast先走一步，所以slow也必须next一次
        while(slow!=fast){
            slow=slow-&gt;next;
            fast=fast-&gt;next;
        }
        return slow;
    }
    /*
    //使用hashset
    ListNode* EntryNodeOfLoop(ListNode* pHead)
    {
        unordered_set&lt;ListNode*&gt; Node_set;
        if(pHead==NULL)
              return NULL;
        while(pHead!=NULL){
            if(Node_set.count(pHead))
                return pHead;
            Node_set.insert(pHead);
            pHead=pHead-&gt;next;
        }
        return NULL;
    }
    */
};
</code></pre>
<p>书本题解：<br>
解决这个问题的第一步是如何确定一个链表中包含环。受到面试题22 的启发，我们可以用两个指针来解决这个问题。和前面的问题一样，定义 两个指针，同时从链表的头节点出发，一个指针一次走一步，另一个指针 一次走两步。如果走得快的指针追上了走得慢的指针，那么链表就包含环； 如果走得快的指针走到了链表的末尾(m_pNext指向NULL)都没有追上第 一个指针，那么链表就不包含环。<br>
第二步是如何找到环的入口。我们还是可以用两个指针来解决这个问 题。先定义两个指针P|和P2指向链表的头节点。如果链表中的环有n个节 点，则指针Pi先在链表上向前移动n步，然后两个指针以相同的速度向前 移动。当第二个指针指向环的入口节点时，第一个指针已经围绕着环走了 一圈，又回到了入口节点。<br>
剩下的问题是如何得到环中节点的数目。我们在前面提到判断一个链 表里是否有环时用到了一快一慢两个指针。如果两个指针相遇，则表明链 表中存在环。两个指针相遇的节点一定是在环中。可以从这个节点出发， 一边继续向前移动一边计数，当再次回到这个节点时，就可以得到环中节 点数了。</p>
<pre><code>ListNode* MeetingNode(ListNode* pHead)
{
    if(pHead == nullptr)
        return nullptr;

    ListNode* pSlow = pHead-&gt;m_pNext;
    if(pSlow == nullptr)
        return nullptr;

    ListNode* pFast = pSlow-&gt;m_pNext;
    while(pFast != nullptr &amp;&amp; pSlow != nullptr)
    {
        if(pFast == pSlow)
            return pFast;

        pSlow = pSlow-&gt;m_pNext;

        pFast = pFast-&gt;m_pNext;
        if(pFast != nullptr)
            pFast = pFast-&gt;m_pNext;
    }
    return nullptr;
}

ListNode* EntryNodeOfLoop(ListNode* pHead)
{
    ListNode* meetingNode = MeetingNode(pHead);
    if(meetingNode == nullptr)
        return nullptr;

    // 得到环中结点的数目
    int nodesInLoop = 1;
    ListNode* pNode1 = meetingNode;
    while(pNode1-&gt;m_pNext != meetingNode)
    {
        pNode1 = pNode1-&gt;m_pNext;
        ++nodesInLoop;
    }

    // 先移动pNode1，次数为环中结点的数目
    pNode1 = pHead;
    for(int i = 0; i &lt; nodesInLoop; ++i)
        pNode1 = pNode1-&gt;m_pNext;

    // 再移动pNode1和pNode2
    ListNode* pNode2 = pHead;
    while(pNode1 != pNode2)
    {
        pNode1 = pNode1-&gt;m_pNext;
        pNode2 = pNode2-&gt;m_pNext;
    }

    return pNode1;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TcpServer]]></title>
        <id>https://lixin-scut.github.io//post/tcpserver-jie-shou-xin-lian-jie</id>
        <link href="https://lixin-scut.github.io//post/tcpserver-jie-shou-xin-lian-jie">
        </link>
        <updated>2020-02-19T13:43:22.000Z</updated>
        <content type="html"><![CDATA[<p>TcpServer新建连接的相关函数调用顺序见图8(有的函数名是简写，省略了 poll(2)调用)。其中 Channel::handleEvent()的触发条件是 listening socket 可读, 表明有新连接到达。TcpServer会为新连接创建对应的TcpConnection对象。<br>
<img src="https://lixin-scut.github.io//post-images/1582119932027.png" alt=""></p>
<h3 id="tcpserver-class">TcpServer class</h3>
<p>TcpServer class 的功能是管理 accept(2)获得的 TcpConnection。TcpServer 是供用户直接使用的，生命期由用户控制。TcpServer的接口如下，用户只需要设置好 callback,再调用 start()即可。</p>
<p>TcpServer内部使用Acceptor来获得新连接的fd。它保存用户提供的Connection- Callback 和Messagecallback,在新建TcpConnection的时候会原样传给后者。TcpServer 持有目前存活的 TcpConnection 的 shared_ptr (定义为 TcpConnectionPtr),因为 TcpConnection对象的生命期是模糊的，用户也可以持有TcpConnectionPtr。</p>
<p>每个TcpConnection对象有一个名字，这个名字是由其所属的TcpServer在创建 TcpConnection 对象时生成，名字是 ConnectionMap 的 key.<br>
在新连接到达时，Acceptor会回调newConnection(),后者会创建TcpConnection对象conn,把它加入ConnectionMap,设置好callback,再调用 conn-&gt;connectEstablished(), 其中会回调用户提供的ConnectionCallback代码<br>
<strong>练习：给TcpServer的构造函数增加string参数，用于初始化name_成员变量。</strong><br>
注意muduo尽量让依赖是单向的，TcpServer会用到Acceptor,但Acceptor并不知道 TcpServer 的存在。TcpServer 会创建 TcpConnection,但 TcpConnection 并 不知道TcpServer的存在。<br>
<strong>优化点：£64可以考虑改用make_shared()以节约一次new。</strong></p>
<p>TcpServer向TcpConnection注册CloseCallback,用于接收连接断开的消息。<br>
通常TcpServer的生命期长于它建立的TcpConnection,因此不用担心TcpServer 对象失效。<br>
TcpServer::removeConnection()把 conn 从 ConnectionMap 中移除。这时 TcpConnection 已经快要被销毁：如果用户不持有TcpConnectionPtr的话，conn的引用计数已降到1。注意这里一定要用EventLoop::queuelnLoop <strong>（unknown）</strong>,否则就会出现对象生命期管理问题，即Channel::handleEvent()<strong>（unknown）</strong> 有可能引发TcpConnection析构，继而把当前Channel对象也析构了，导致程序崩溃。<br>
另外注意这里用boost:: bind让TcpConnection的生命期 长到调用connectDestroyed()的时刻。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[模板的实现]]></title>
        <id>https://lixin-scut.github.io//post/mo-ban-de-shi-xian</id>
        <link href="https://lixin-scut.github.io//post/mo-ban-de-shi-xian">
        </link>
        <updated>2020-02-19T08:43:21.000Z</updated>
        <content type="html"><![CDATA[<p>模板这个东西，是C++里可以独当一面的领域，STL的基础和核心就是它了，但是侯捷大神的《STL源码剖析》并没有把模板的原理作为核型概念，而更多地讲它的应用，所以还是得到《深度探索C++对象模型》中去了解一下</p>
<p>个人总结：<br>
对于声明：</p>
<ol>
<li>对于模板的声明，程序什么反应都不做，哪怕是类模板中的static类型这种与类对象无关的对象都必须等到模板的实例化，所有的类型和成员都必须通过模板的某个实体来存取和操作</li>
<li>从1出发，我们可以发现模板不能直接通过类型提取static对象，同时通过前向声明来声明定义的指针都不会触发实例化，但例外是引用会触发实例化，因为实例的初始化必须指向一个对象，而指针完全可以指向nullptr</li>
<li>从2出发，我们惊讶地发现编译器对于模板的巨大的宽容，比如2中定义的引用实例化时才会对类型进行转化，如果没有转换的可能，这个定义就是错误的，才会在编译时被挑出来。</li>
<li>但是，哪怕模板被引用或者定义之类的实例化了，类中的成员函数还是会顽强地保持模板状态，直至被调用的时候才会实例化</li>
<li>从4出发就会引出一个大问题：并不是一个template具现出来的所有类型就一定能够完整支持一组member functions所需要的所有运算符。比如以某些类类型<br>
作为T，但是这个类类型根本没有定义==符号的话，如果类模板的成员函数用到了<br>
相等判断直接gg。</li>
<li>类模板的成员函数的具现时机：<br>
■在编译时候。那么函数将“具现”于它存在的那个文件中，<br>
■在链接时候.那么编译器会被一些辅助工具重新激活。template函数实体可能被放在这个文件中、别的文件中，或一个分离的储存位置上。</li>
</ol>
<p>关于编译：</p>
<ol>
<li>目前的编译器，面对一个template声明，在它被一组实际参数具现之前，只能施行以有限的错误检查。template中那些与语法无关的十分明显的错误，编译器却会让它通过</li>
<li>所有与类型有关的检验，如果牵涉到 template参数、都必须延迟到真正的实例化操作才发生</li>
<li>所有语汇(lexing)错误和解析(parsing)错误都会被通过，但同时都会在处理template声明的过程中被标示出来</li>
<li>每当遇到模板的具例化，这组标记就被推往解析器,然后调用类型检验等等</li>
</ol>
<p>模板中的名称决议方式</p>
<ol>
<li>首先必须能够区分以下两种意义:<br>
一种是C++ Standard所谓的uscope of the template definition ,也就是“定义出 template” 的程序。<br>
另一种是 C++ Standard 所谓的scope of the template instantiation，也就是“具现出 template” 的程序.</li>
<li>对于一个nonmember name的决议结果是根据这个name的使用是否与“用以具现出该template的参数类型”有关而决定的.<br>
<strong>如果其使用互不相关，那么就以scope of the template declaration来决定name</strong><br>
<strong>如果其使用互有关联，那么就以scope of the template instantiation来决定name</strong></li>
<li>函数的决议结果只和函数的原型(signature)有关</li>
<li><strong>这意味着一个编译器必须保持两个scope contexts：</strong><br>
1)scope of the template declaration,用以专注于一般的 template class.<br>
2)scope of the template instantiation，用以专注于特定的实体。<br>
<strong>编译器的决议(resolution)算法必须决定哪一个才是适当的scope,然后在 其中搜寻适当的name.</strong></li>
</ol>
<p>模板的具现行为</p>
<ol>
<li>不同编译器的模板实例化策略可以分为编译时策略和链接时期策略</li>
<li>不论编译时期或链接时期的实例化策略，其弱点就是当template实体被产生出来时，有时候会大量增加编译时间</li>
<li>模板实例化的定义位置，一种是放在类似头文件的文件中在引用，例外一种就是在头文件中找到的模板实例化就把实例化相应地放到源文件中</li>
<li>对于类模板成员函数的按需实例化：一种方法是忽略它，全部都给实例化出来。另一种策略就是仿照链接操作，检测看看哪一个函数真正需要，然后再为它们产生实体</li>
<li>阻止同一类型的多次实例化：产生多个实体，然后从链接器中提供支持，只留下其中一个实体，其余都忽略。另一个办法就是由使用者来导引“仿真链接阶段”的具现 策略，决定哪些实体才是需要的的。</li>
<li>最接近我们需求的模板自动实例化方法：<br>
a.	<strong>一个程序的程序代码被编译时，最初并不会产生任何“template实例体”。然而，相关信息已经被产生于object files之中。</strong><br>
b.	<strong>当object files被链接在一块儿时，会有一个prelinker程序被执行起来。它会检查object files,寻找template实体的相互参考以及对应的定义。</strong><br>
c.	<strong>对于每一个“参考到template实体”而“该实体却没有定义”的情况,prelinker将该文件视为与另一个文件（含有实例化）同类。 以这种方法，就可以将必要的程序具现操作指定给特定的文件。</strong> 这些都会注册在prelinker所产生的.ii文件中（放在磁盘目录ii_file）。<br>
d.	prelinker重新执行编译器，重新编译每一个&quot;.ii文件曾被改变过”的文 件。这个过程不断重复，直到所有必要的具现操作都已完成。<br>
e.	所有的object files被链接成一个可执行文件。</li>
<li>上述机制的缺陷在于虚函数，<strong>如果一个virtual function被具现(instantiated)出来，其具现点紧跟在其class 的具现点之后</strong>，<strong>导致具现(instantiated )出Point class的一个float实体及其 virtual_func().由于每一个virtual function的地址被放置于table之中</strong>，<strong>如果 virtual table 被产生出来,每一个 virtual function 也都必须被具现(instantiated)</strong> ,<strong>然而，如果编译器遵循cfront的virtual table实现体制，那么在Point的 float实体有一个virtual destructor定义被具现出来”之前，这个table不会被产生</strong></li>
<li>C++ Standard也已经扩充了对template的支持，允许程序员明确地要求在一个文件中将整个class template具现出来，以手动方式先在个别的object module中完成预先具现操作 （pre-instantiation）,虽然沉闷，却是唯一保证效率的方法</li>
</ol>
<p>《Effective C++》<br>
template的三个主要方向：<br>
1.template的声明<br>
2.如何具现（instantiates）出class object以及inline nonmember，以及 member template functions，这些是每一个编译单位都会拥有一份实体<br>
3.如何具现（instantiates）出nonmenber以及member template functions，以及static template class members，这些都是每一个可执行文件只需要一个实体的东西<br>
具现（instantiates）：表示行程将真正的类型和表达式绑定到template相关形式参数（formal parameters）上头</p>
<p><img src="https://lixin-scut.github.io//post-images/1582184776039.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582184916822.png" alt=""><br>
当编译器看到template class声明时，它会做出什么反应？<strong>在实际程序中，什么反应也没有</strong>，也就是说，与普通情况下不同，模板的static data members并不可用。nested enum 或其 enumerators 也一样。他们<strong>都需要通过模板的某个实体来存取和操作。</strong></p>
<p>所以不能这样写：</p>
<pre><code>// error :
Point::Status s;
</code></pre>
<p>同样的道理，freeList和chunkSize对程序而言也还不可用。我们不能够写:</p>
<pre><code>// error :
Point::freeList;
</code></pre>
<p>我们必须明确地指定类型，才能使用freeList <strong>（注意此处已经实例化了一个匹配float类型的类）</strong></p>
<pre><code>// ok :
Point&lt; float &gt;::freeList;
</code></pre>
<p>像上面这样使用static member,会使其一份实体与Point class的float instantiation在程序中产生关联。如果我们写:</p>
<pre><code>// ok :另一个实体(instance) 
Point&lt; double &gt;::freeList;
</code></pre>
<p>就会出现第二个JreeList实体，与Point class的double instantiation产生关联<br>
如果我们定义一个指针，指向特定的实体，像这样:<br>
<code>Point&lt; float &gt; *ptr = 0;</code><br>
这一次，程序中什么也没有发生.为什么呢？<strong>因为一个指向class object的指针, 本身并不是一个class object,编译器不需要知道与该class有关的任何members的数据或object布局数据</strong>，所以将Point的一个float实体具现也就没有必要 <strong>（重点：前向声明并不需要知晓类的实现）</strong></p>
<p>如果不是pointer而是reference,又如何？假设：<br>
const Point&lt; float &gt; &amp;ref = 0;<br>
是的，<strong>reference真的会具现出一个&quot;Point的float实体”来</strong>,这个定义的真正语意 会被扩展为：<br>
//内部扩展<br>
Point&lt; float &gt; temporary( float (0));<br>
const Point&lt; float &gt; &amp;ref = temporary;<br>
<strong>因为reference并不是无物(no object)的代名词。0被视为整数</strong>,必须被转换为以下类型的一个对象:Point&lt; float &gt;<br>
<strong>如果没有转换的可能，这个定义就是错误的，会在编译时被挑出来</strong>,<br>
所以，一个<strong>class object的定义</strong>，不论是由编译器暗中地做(像稍早程序代码中出现过的temporary),或是由程序员像下面这样明确地做：<br>
const Point&lt; float &gt; origin;<br>
都会<strong>导致template class的“具现”</strong>，也就是说，float instantiation的真正对象布局会被产生出来。回顾先前的template声明，我们看到Point有三个nonstatic members,每一个的类型都是Type^ Type现在被绑定为float,所以origin的配 置空间必须足够容纳三个float成员，<br>
<strong>然而，member functions (至少对于那些未被使用过的)不应该被&quot;实体&quot;化,<br>
只有在member functions被使用的时候，C++ Standard才要求它们被“具现”出来。</strong><br>
当前的编译器并不精确遵循这项要求.之所以由使用者来主导“具现'<br>
(instantiantion)规则，有两个主要原因:<br>
1.空间和时间效率的考虑°如果class中有100个member functions,但你的程序只针对某个类型使用其中两个，针对另一个类型使用其中五个，那么将其它193个函数都“具现”将会花费大量的时间和空间:<br>
2.尚未实现的机能。<strong>并不是一个template具现出来的所有类型就一定能够完整支持一组member functions所需要的所有运算符。</strong> 如果只“具现&quot; 那些真正用到的member functions, template就能够支持那些原本可能会 造成编译时期错误的类型(types)</p>
<p><strong>函数在什么时候“具现”出来呢？当前流行两种策略：</strong><br>
■在编译时候。那么函数将“具现”于origin和p存在的那个文件中，<br>
■在链接时候.那么编译器会被一些辅助工具重新激活。template函数实体可能被放在这个文件中、别的文件中，或一个分离的储存位置上。</p>
<p>Template 的错误报告(Error Reporting within a Template)<br>
<img src="https://lixin-scut.github.io//post-images/1582107028746.png" alt=""></p>
<ol>
<li>L4：使用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">字</mi><mi mathvariant="normal">符</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">对</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">这</mi><mi mathvariant="normal">项</mi><mi mathvariant="normal">错</mi><mi mathvariant="normal">误</mi><mi mathvariant="normal">有</mi><mi mathvariant="normal">两</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">面</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">第</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">，</mi></mrow><annotation encoding="application/x-tex">字符是不对的，这项错误有两方面.第一，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.10556em;vertical-align:0em;"></span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">符</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">项</span><span class="mord cjk_fallback">错</span><span class="mord cjk_fallback">误</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">两</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">面</span><span class="mord">.</span><span class="mord cjk_fallback">第</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">，</span></span></span></span>并不是一个 可以合法用于标识符的字符；第二，class声明中只允许有public, protected, private 三 个卷标(labels) , $ 的出现使 public$ 不成为 public .第一点是语汇(lexical)上的错误，第二点则是造句/解析(syntactic/parsing)上的错误。</li>
<li>L5： t被初始化为整数常量1024,或许可以，也或许不可以，视T的真实类型而定。一般而言，只有template的各个实体才诊断得出来</li>
<li>L6： _t并不是哪一个member的名称，tt才是。这种错误一般会在“类型检验”这个阶段被找出来.是的，每一个名称必须绑定于一个定义身上，要不就会产生错误.</li>
<li>L8： !=运算符可能已定义好，但也可能还没有，视T的真正类型而定。 和第2点一样，只有template的各个实体才诊断得出来.</li>
<li>L9：我们意外地键入ex两次.这个错误会在编译时期的解析(parsing) 阶段被发现,C++语言中一个合法的句子不允许一个标识符紧跟在另一个标识符之后。</li>
<li>L13：我们忘记以一个分号作为class声明的结束，这项错误也会在编译时期的语句分析(parsing)阶段被发现。<br>
在一个nontempiate class声明中，这六个既露骨又潜沉的错误会被编译器挑 出来.<strong>但templa class却不同，举个例子，所有与类型有关的检验，如果牵涉到 template参数、都必须延迟到真正的具现操作(instantiation)发生，才得为之。</strong></li>
</ol>
<p>那么，什么样的错误会在编译器处理template声明时被标示出来？这里有一<br>
部分和template的处理策略有关。cfront对template的处理是完全解析(parse) 所以在一个parsing策略之下，<strong>所有语汇(lexing)错误和解析(parsing)错误都 会在处理template声明的过程中被标示出来。</strong></p>
<p>语汇分析器(lexical analyzer)会在L4捕捉到一个不合法的字符，解析器 (parser)会这样标示它：<br>
<code>public$:	// caught</code><br>
表示这是一个不合法的卷标(label)，解析器(parser)不会把&quot;对一个未命名的 member做出参考操作”视为错误：<br>
<code>_t ( t ) // not caught</code><br>
但它会抓出L9腿 出现两次”以及L13 “缺少一个分号”这两种错误。</p>
<p>在一个十分普遍的替代策略中(例如［BALL92a］中所记录)，template的声明被收集成为一系列的lexical tokens ,而parsing操作延迟，直到真正有具现操作(instantiation)发生时才开始。<strong>每当看到一个instantiation发生，这组token 就被推往parser,然后调用类型检验等等</strong>。面对先前出现的那个template声明， lexical tokenizing会指出什么错误吗？事实上很少，只有L4所使用的不合法 字符会被指出。其余的template声明都被解析为合法的tokens并被收集起来。</p>
<p><strong>目前的编译器，面对一个template声明，在它被一组实际参数具现之前，只 能施行以有限的错误检查.template中那些与语法无关的错误，程序员可能认为 十分明显，编译器却让它通过了，只有在特定实体被定义之后，才会发出抱怨。</strong> 这是目前实现技术上的一个大问题。<br>
<strong>Nonmember 和 member template functions 在具现行为(instantiation)发生之前也一样没有做到完全的类型检验.这导致某些十分露骨的template错误声明竟然得以通过编译。</strong><br>
例如下面的template声明:</p>
<pre><code>template &lt;class type&gt; 
class Foo
{
public:
		Foo();
		type val ();
		void val( type v );
private:
		type _val;
	};
</code></pre>
<p>不论是efront或Sun编译器或Borland编译器，都不会对以下程序代码产生怨言：</p>
<pre><code>//目前各家编译器都不会显示出以下定义的语句合法而语意错误：
//	(a) bogus_meinber 不是 class 的一个 member function
//	(b) dbx 不是 class 的一个 data member
template &lt;class type&gt;
double Foo&lt; type &gt;::bogus_member() ( return this-&gt;dbx; }
</code></pre>
<p>Template中的名称决议方式 (Name Resolution within a Template)<br>
你必须能够区分以下两种意义:<br>
一种是C++ Standard所谓的uscope of the template definition ,也就是“定义出 template” 的程序。<br>
另一种是 C++ Standard 所谓的scope of the template instantiation，也就是“具现出 template” 的程序.<br>
<img src="https://lixin-scut.github.io//post-images/1582186451379.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582186477895.png" alt=""></p>
<p>Template之中，对于一个nonmember name的决议结果是根据这个name的使用是否与“用以具现出该template的参数类型”有关而决定的.<br>
<strong>如果其使用互不相关，那么就以scope of the template declaration来决定name</strong><br>
<strong>如果其使用互有关联，那么就以scope of the template instantiation来决定name</strong></p>
<p>在第一个例子中，foo()与用以具现ScopeRules的参数类型无关:</p>
<pre><code>// the resolution of foo() is not
// dependent on the template argument 
member = foo( _val );
</code></pre>
<p>这是因为_val的类型是int； _val是一个“类型不会变动”的template class<br>
membero也就是说，被用来具现出这个template的真正类型，对于val的类型<br>
并没有影响,此外，<strong>函数的决议结果只和函数的原型(signature)有关</strong>，和函数的_member的类型并不会影响哪一个foo()实体被选中<br>
foo()的调用与template参数毫无关联！所以调用操作必须根据scope of the template declaration来决议，在此scope中，只有一个foo()候选者(注意，这种行为不能够以一个简单的宏扩展——比如使用一个#define宏——重现之)</p>
<p>让我们另外看看&quot;与类型相关” (type-dependent)的用法:<br>
<code>sr0.type_dependent ();</code><br>
这个函数的内容如下:<br>
<code>return foo( _member )；</code><br>
它究竟会调用哪一个foo呢？<br>
这个例子很清楚地与template参数有关，因为该参数将决定member的真 正类型.所以这一次foo必须在scope of the template instantiation中决议，本例中这个scope有两个foo函数声明。由于member的类型在本例中为int, 所以应该是int版的foo出线，如果ScopeRules是以double类型具现出来, 那么就应该是double版的foo出线，如果ScopeRules是以unsigned int或 long类型具现出来，那么foo调用操作就暧昧不明.最后，如果ScopeRules是以某一个class类型具现出来，而该class没有针对int或double实现出 convertion运算符，那么调用操作会被标示为错误。不管如何改变，都是由 scope of the template instantiation 来决定，而不是由 scope of the template declaration 决定。<br>
<strong>这意味着一个编译器必须保持两个scope contexts：</strong></p>
<ol>
<li>scope of the template declaration,用以专注于一般的 template class.</li>
<li>scope of the template instantiation，用以专注于特定的实体。<br>
<strong>编译器的决议(resolution)算法必须决定哪一个才是适当的scope,然后在 其中搜寻适当的name.</strong></li>
</ol>
<p>Member Function 的具现行为(Member Function Instantiation)<br>
对于template的支持，最困难莫过于template function的具现(instantiation)，目前的编译器提供了两个策略：<br>
一个是编译时期策略，程序代码必须在program text file中备妥可用；<br>
另一个是链接时期策略，有一些meta compilation 工具可以导引编译器的具现行为(instantiation)<br>
下面是编译器设计者必须回答的三个主要问题:</p>
<ol>
<li>编译器如何找出函数的定义？<br>
答案之一是包含template program text file ,就好像它是个header文件一样. Borland编译器就是遵循这个策略,另一种方法是要求一个文件命名规则，例如, 我们可以要求，在Point.h文件中发现的函数声明，其template program text —定 要放置于文件PointC或Point.cpp中，依此类推。efront就是遵循这个策略。 Edison Design Group编译器对此两种策略都支持，</li>
<li>编译器如何能够只具现出程序中用到的member functions?<br>
解决办法之一就是，根本忽略这项要求，把一个已经具现出来的class的所有member functions都产生出来。Borland就是这么做的	虽然它也提供#pragmas让你压制(或具现出)特定实体。另一种策略就是仿真链接操作，检测 看看哪一个函数真正需要，然后只为它(们)产生实体。cfront就是这么做的’ Edison Design Group编译器对此两种策略都支持。</li>
<li>编译器如何阻止member definitions在多个.o文件中都被具现呢？<br>
解决办法之一就是产生多个实体，然后从链接器中提供支持，只留下其中一个实体，其余都忽略。另一个办法就是由使用者来导引“仿真链接阶段”的具现 策略，决定哪些实体(instances)才是所需求的。</li>
</ol>
<p><strong>目前，不论编译时期或链接时期的具现(instantiation)策略，其弱点就是，当template实体被产生出来时，有时候会大量增加编译时间</strong>，很显然，这将是template functions第一次具现时的必要条件。然而当那些函数被非必要地再次具现，或是当“决定那些函数是否需要再具现”所花的代价太大时，编译器的表现令人失望!</p>
<p>C++支持template的原始意图可以想见是一个由使用者导引的自动具现机 制(use-directed automatic instantiation mechanism),既不需要使用者的介入，也 不需要相同文件有多次的具现行为。但是这已被证明是非常难以达成的任务，比 任何人此刻所能想象的还要难(请参考[STROUP94])。ptlink,随着cfront 3.0版 所附的原始具现工具，提供了 一个由使用者执行的自动具现机制(use-driven automatic instantiation mechanism)，但它实在太复杂了，即使是久经世故的人也 没法一下子了解.</p>
<p>Edison Design Group 开发出一套第二代的 directed-instantiation 机制，非常接 近于(我所知的)template facility原始涵义。它的主要过程如下：</p>
<ol>
<li><strong>一个程序的程序代码被编译时，最初并不会产生任何“template具现 体”。然而，相关信息已经被产生于object files之中。</strong></li>
<li><strong>当object files被链接在一块儿时，会有一个prelinker程序被执行起来. 它会检查object files,寻找template实体的相互参考以及对应的定义。</strong></li>
<li><strong>对于每一个“参考到template实体”而“该实体却没有定义”的情况,prelinker将该文件视为与另一个文件（在其中，实体已经具现）同类。 以这种方法，就可以将必要的程序具现操作指定给特定的文件。</strong> 这些都会注册在prelinker所产生的.ii文件中（放在磁盘目录ii_file）。</li>
<li>prelinker重新执行编译器，重新编译每一个&quot;.ii文件曾被改变过”的文 件。这个过程不断重复，直到所有必要的具现操作都已完成。</li>
<li>所有的object files被链接成一个可执行文件。</li>
</ol>
<p>这种directed-instantiation体制的主要成本在于，程序第一次被编译时的.ii 文件设定时间，次要成本则是必须针对每一个“compile afterwards&quot;执行 prelinker,以确保所有被参考到的templates都存在有定义.在最初的设定以及成 功地第一次链接之后，重新编译操作包含以下程序：</p>
<ol>
<li>对于每一个将被重新编译的program text file,编译器检查其对应的,ii 文件。</li>
<li>如果对应的.ii文件列出一组要被具现（instantiated）的templates,那 些templates （而且也只有那些templates）会在此次编译时被具现。</li>
<li>prelinker必须执行起来，确保所有被参考到的templates已经被定义妥当。<br>
以我的观点，出现某种形式的automated template机制，是“对程序员友善 的C++编译系统”的一个必要组件.虽然大家也公认，目前没有任何一个系统 是完美的。作为一个程序开发者，我不会使用（也不会推荐）一个没有这种机制 的编译系统。<br>
不幸的是，没有任何一个机制是没有bugs的。Edison Design Group的编译 器使用了一个由cfront2,0引人的算法。对程序中的每一个class 自动产生virtual table的单一实体（在大部分情况下）.例如下面的class声明：</li>
</ol>
<pre><code>class Primitiveobject : public Geometry 
{
public:
		virtual ～Primitiveobject(); 
		virtual void draw();
...
}
</code></pre>
<p>如果它被含入于15个或45个程序源码中，编译器如何能够确保只有一个virtual table实体被产生出来呢？产生15份或45份实体倒还容易些!</p>
<p>Andy Koenig以下面的方法解决这个问题：每一个virtual function的地址都 被放置于active classes的virtual table中，如果取得函数地址，则表示virtual<br>
function的定义必定出现在程序的某个地点；否则程序就无法链接成功。此外,<br>
该函数只能有一个实体，否则也是链接不成功•那么，就把virtual table放在定<br>
义了该class之第一个non-inline nonpure virtual function的文件中吧。以我们的 例子而言，编译器会将virtual table产生在储存着virtual destructor的文件之中。</p>
<p>不幸的是，在template之中，这种单一定义并不一定为真,在template所支持的“将模块中的每一样东西都编译”的模型下，不只是多个定义可能被产生,而且链接器也放任让多个定义同时出现，它只要选择其中一个而将其余都忽略也 就是了。</p>
<p>好吧，真是有趣，但Edison Design Gro叩的automatic instantiation机制做什 么事呢？考虑下面这个library函数：</p>
<pre><code>void foo ( const Point&lt; float &gt; *ptr )
{
ptr-&gt;virtual func();
}
</code></pre>
<p>virtual function call被转换为类似这样的东西:</p>
<pre><code>// C + +伪码
// ptr-&gt;virtual__func ();
(*ptr-&gt;vtbl_Point&lt; float &gt;[ 2 ] ) ( ptr );
</code></pre>
<p>于是<strong>导致具现(instantiated )出Point class的一个float实体及其 virtual_func().由于每一个virtual function的地址被放置于table之中</strong>，<strong>如果 virtual table 被产生出来,每一个 virtual function 也都必须被具现(instantiated)</strong> , 这就是为什么C++ Standard有下面的文字说明的缘故：</p>
<p><strong>如果一个virtual function被具现(instantiated)出来，其具现点紧跟在其class 的具现点之后。</strong></p>
<p><strong>然而，如果编译器遵循cfront的virtual table实现体制，那么在Point的 float实体有一个virtual destructor定义被具现出来”之前，这个table不会被产生</strong>。除非在这一点上，并没有明确使用virtual destructor以担保其具现行为 (instantiation)<br>
EdisCii Design Group的automatic template机制并不明确它自己的编译器对 于第一个non inline、 nonpure virtual function的隐晦使用，所以并没有把它标示 于.ii文件中。结果，链接器反而回头抱怨_vtbl_point&lt; float &gt;符号没有出现<br>
并拒绝产生一个可执行文件。噢，真是麻烦！ Automatic instantiation在此失效!<br>
程序员必须明确地强迫将destructor具现出来.目前的编译系统是以pragma 指令来支持此需求<br>
<strong>然而C++ Standard也已经扩充了对template的支持，允许程序员明确地要求在一个文件中将整个class template具现出来:</strong><br>
<code>template class Point3d&lt; float &gt;;</code><br>
<strong>或是针对一个 template class 的个别 member function：</strong><br>
<code>template float Point3d&lt;float&gt;::X() const;</code><br>
<strong>或是针对某个个别template function：</strong><br>
<code>template Point3d&lt;float&gt; operator+（ const Point3d&lt;float&gt;&amp;r const Point3d&lt;float&gt;&amp; ）;</code><br>
<strong>在实现层面上，template instantiation似乎拒绝全面自动化。甚至虽然每一件 工作都做对了，产生出来的object files的重新编译成本仍然可能太高——如果程序十分巨大的话！以手动方式先在个别的object module中完成预先具现操作 （pre-instantiation）,虽然沉闷，却是唯一有效率的方法。</strong></p>
<p>博客：<a href="https://blog.csdn.net/lianhunqianr1/article/details/79966911">C++Template 模版的本质</a><br>
C++实现参数化类（class template）技术：</p>
<p>1.定义模板类，让每个模板类拥有模板签名。<br>
模板类语法：</p>
<pre><code>template&lt;typename T&gt;
class X{...};
</code></pre>
<ul>
<li>上面的模板签名可以理解成：<code>X&lt;typename T&gt;;</code>主要包括模板参数<code>&lt;typename T&gt;</code>和模板名字X（类名）， 基本的语法可以参考《C++ Templates: The Complete Guide》，《C++ primer》等书籍。</li>
<li>模板参数在形式上主要包括四类：  <br>
     为什么会存在这些分类，主要是满足不同类对参数化的需求:</li>
</ul>
<ol>
<li>type template parameter，类型模板参数，以class或typename 标记；<br>
此类主要是解决朴实的参数化类的问题（上面描述的问题），也是模板设计的初衷。</li>
<li>non-type template parameter，非类型模板参数，比如整型，布尔，枚举，指针，引用等;<br>
此类主要是提供给大小，长度等整型标量参数的控制，其次还提供参数算术运算能力，这些能力结合模板特化为模板提供了初始化值，条件判断，递归循环等能力，这些能力促使模板拥有图灵完备的计算能力。</li>
<li>template template parameter，模板参数是模板;<br>
此类参数需要依赖其他模板参数（作为自己的入参），然后生成新的模板参数，可以用于策略类的设计policy-base class。<br>
4. parameter pack，C++11的变长模板参数 ；<br>
此类参数是C++11新增的，主要的目的是支持模板参数个数的动态变化，类似函数的变参，但有自己独有语法用于定义和解析（unpack），模板变参主要用于支持参数个数变化的类和函数，比如std::bind，可以绑定不同函数和对应参数，惰性执行，模板变参结合std::tuple就可以实现。</li>
</ol>
<p>2.在用模板类声明变量的地方，把模板实参（Arguments）（类型）带入模板类，然后按照匹配规则进行匹配，选择最佳匹配模板.<br>
模板实参和形参类似于函数的形参和实参，模板实参只能是在编译时期确定的类型或者常量，C++17支持模板类实参推导。<br>
3.选好模板类之后，编译器会进行模板类实例化--记带入实际参数的类型或者常量自动生成代码，然后再进行通常的编译。</p>
<p>C++实现模板函数（function template）技术：<br>
模板函数实现技术和模板类形式上差不多：</p>
<pre><code>template&lt;typename T&gt;
retType  function_name(T  t)；
</code></pre>
<p>其中几个关键点：</p>
<p>函数模板的签名包括模板参数，返回值，函数名，函数参数,  cv-qualifier；<br>
<strong>函数模板编译顺序大致：名称查找(可能涉及参数依赖查找)-&gt;实参推导-&gt;模板实参替换(实例化,可能涉及 SFINAE)-&gt;函数重载决议-&gt;编译；</strong><br>
函数模板可以在实例化时候进行参数推导，必须知道每个模板的实参，但不必指定每个模板的实参。编译器会从函数实参推导缺失的模板实参。这发生在尝试调用函数、取函数模板地址时，和某些其他语境中；<br>
函数模板在进行实例化后(template argument deduction/substitution)会进行函数重载解析（overloading resolution, 此时的函数签名不包括返回值；<br>
函数模板实例化过程中，参数推导不匹配所有的模板或者同时存在多个模板实例满足，或者函数重载决议有歧义等，实例化失败；<br>
为了编译函数模板调用，编译器必须在非模板重载、模板重载和模板重载的特化间决定一个无歧义最佳的模板；</p>
<p>实现C++模板的几个核心技术：</p>
<ol>
<li>SFINAE -Substitution failure is not an error ；<br>
      要理解这句话的关键点是failure和error在模板实例化中意义，模板实例化时候，编译器会用模板实参或者通过模板实参推导出参数类型带入可能的模板集（模板备选集合）中一个一个匹配，找到最优匹配的模板定义，<br>
Failure：在模板集中，单个匹配失败；<br>
Error： 在模板集中，所有的匹配失败；<br>
所以单个匹配失败，不能报错误，只有所有的匹配都失败了才报错误。</li>
</ol>
<p>2.  模板特化<br>
模板特化为了支持模板类或者模板函数在特定的情况（指明模板的部分参数（偏特化）或者全部参数（完全特化））下特殊实现和优化，而这个机制给与模板某些高阶功能提供了基础，比如模板的递归（提供递归终止条件实现），模板条件判断（提供true或者false 条件实现）等。</p>
<ol start="3">
<li>
<p>模板实参推导<br>
模板实参推导机制给与编译器可以通过实参去反推模板的形参，然后对模板进行实例化，具体推导规则见参考;</p>
</li>
<li>
<p>模板计算<br>
模板参数支持两大类计算：<br>
一类是类型计算（通过不同的模板参数返回不同的类型），此类计算为构建类型系统提供了基础，也是泛型编程的基础；<br>
一类是整型参数的算术运算, 此类计算提供了模板在实例化时候动态匹配模板的能力；实参通过计算后的结果作为新的实参去匹配特定模板（模板特化）。</p>
</li>
</ol>
<p>5. 模板递归<br>
 模板递归是模板元编程的基础，也是C++11变参模板的基础。<br>
例子：</p>
<pre><code> template &lt;unsiganed int n&gt; struc Sum_Soluntion
{
		enum Value { N = Sum_Solution4&lt;n-1&gt;::N+n };
};

template &lt;&gt; struc Sum_Soluntion&lt;1&gt;
{
		enum Value { N = 1 };
};
</code></pre>
]]></content>
    </entry>
</feed>