<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-09-09T15:17:39.355Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[数组 134.加油站]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-134jia-you-zhan</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-134jia-you-zhan">
        </link>
        <updated>2019-09-09T14:50:55.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。<br>
你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。<br>
如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p>
<p>说明: <br>
如果题目有解，该答案即为唯一答案。<br>
输入数组均为非空数组，且长度相同。<br>
输入数组中的元素均为非负数。<br>
示例 1:<br>
输入:<br>
gas  = [1,2,3,4,5]<br>
cost = [3,4,5,1,2]<br>
输出: 3<br>
解释:<br>
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油<br>
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油<br>
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油<br>
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油<br>
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油<br>
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。<br>
因此，3 可为起始索引。<br>
示例 2:</p>
<p>输入:<br>
gas  = [2,3,4]<br>
cost = [3,4,3]<br>
输出: -1<br>
解释:<br>
你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。<br>
我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油<br>
开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油<br>
开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油<br>
你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。<br>
因此，无论怎样，你都不可能绕环路行驶一周。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/gas-station<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>一开始的思路是将两个数组相减得到差值diff，等于负数的地方是不可以作为出发点的，然后将第一个正数作为出发点（因为说只有唯一解），然后以出发点为轴翻转diff（参考之前的数组向右移位k位）然后对diff求和看最后一位是否为0。<br>
代码如下：</p>
<pre><code>class Solution {
public:
    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) {
        vector&lt;int&gt; diff;    
        for(int i = 0;i&lt;gas.size();++i)
            diff.push_back(gas[i]-cost[i]);
        int first = 0;
        for(int i = 1;i&lt;diff.size()+1;++i)
            if(diff[i-1]&gt;0){
                first=i;
                break;
            }
        if(first==0)
            return -1;
        swap_diff(diff,0,diff.size()-1);
        swap_diff(diff,0,first-1);
        swap_diff(diff,first,diff.size()-1);
        for(int i = 1;i&lt;diff.size();++i){
            diff[i]+=diff[i-1];
            if(i!=(diff.size()-1)&amp;&amp;diff[i]&lt;=0)
                return -1;
            }
        if(diff[diff.size()-1]&gt;=0)
            return first-1;
        else
            return -1;
    }
    void swap_diff(vector&lt;int&gt;&amp; diff,int beg,int last){
        for(int i=beg;i&lt;last;++i){
            int temp = diff[i];
            diff[i]=diff[last];
            diff[last]=temp;
            if(--last == i)
                break;
        }
    }
};
</code></pre>
<p>这段代码是很有问题的，diff中的正数可能有多个，只考虑第一个的话，万一是{1，-10，11，...}的情况肯定白给了。如果对diff中的正数进行逐个参考，那么时间复杂度直接变成n^2，得不偿失，所以我的算法是有本质的问题的，所以打算直接看题解，官方题解如下：</p>
<blockquote>
<p>1.如果 sum(gas) &lt; sum(cost) ，那么不可能环行一圈，这种情况下答案是 -1 。<br>
我们可以用这个式子计算环行过程中邮箱里剩下的油：total_tank = sum(gas) - sum(cost) ，如果 total_tank &lt; 0 则返回 -1 。<br>
2.对于加油站 i ，如果 gas[i] - cost[i] &lt; 0 ，则不可能从这个加油站出发，因为在前往 i + 1 的过程中，汽油就不够了。<br>
第二个规则可以被一般化，我们引入变量 curr_tank ，记录当前油箱里剩余的总油量。如果在某一个加油站 curr_tank比 0 小，意味着我们无法到达这个加油站。<br>
下一步我们把这个加油站当做新的起点，并将 curr_tank 重置为 0 ，因为重新出发，油箱中的油为 0 。（从上一次重置的加油站到当前加油站的任意一个加油站出发，到达当前加油站之前， curr_tank 也一定会比 0 小）</p>
<p>整体算法：<br>
那么现在算法是很直接明了的：<br>
初始化 total_tank 和 curr_tank 为 0 ，并且选择 0 号加油站为起点。<br>
遍历所有的加油站：<br>
每一步中，都通过加上 gas[i] 和减去 cost[i] 来更新 total_tank 和 curr_tank 。<br>
如果在 i + 1 号加油站， curr_tank &lt; 0 ，将 i + 1 号加油站作为新的起点，同时重置 curr_tank = 0 ，让油箱也清空。<br>
如果 total_tank &lt; 0 ，返回 -1 ，否则返回 starting station。</p>
</blockquote>
<pre><code>class Solution:
    def canCompleteCircuit(self, gas, cost):
        &quot;&quot;&quot;
        :type gas: List[int]
        :type cost: List[int]
        :rtype: int
        &quot;&quot;&quot;
        n = len(gas)
        
        total_tank, curr_tank = 0, 0
        starting_station = 0
        for i in range(n):
            total_tank += gas[i] - cost[i]
            curr_tank += gas[i] - cost[i]
            # If one couldn't get here,
            if curr_tank &lt; 0:
                # Pick up the next station as the starting one.
                starting_station = i + 1
                # Start with an empty tank.
                curr_tank = 0
        
        return starting_station if total_tank &gt;= 0 else -1
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(N) ， 这是因为只有一个遍历了所有加油站一次的循环。<br>
空间复杂度： O(1) ，因为此算法只使用了常数个变量。</p>
</blockquote>
<p>关于算法原理可以看官方题解和高赞题解的详细解答。<br>
这是最后代码：</p>
<pre><code>class Solution {
public:
    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) {
        int sum=0;
        int curr=0;
        int first=0;
        for(int i=0;i&lt;gas.size();++i){
            sum+=gas[i]-cost[i];
            curr+=gas[i]-cost[i];
            if(curr&lt;0)
            {
                first=i+1;
                curr=0;
            }
        }
        return sum&gt;=0?first:-1;
    }
};
</code></pre>
<p>感想：还是得打好数学基础啊！这题没有理解这个数学概念（如果一个数组的总和非负，那么一定可以找到其中找到一个点开始，累加和一直都是非负的）的话就直接白给了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ C++ primer 第四章 笔记+习题 4.1-4.5]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-si-zhang-bi-ji-xi-ti-41-45</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-si-zhang-bi-ji-xi-ti-41-45">
        </link>
        <updated>2019-09-09T11:50:55.000Z</updated>
        <content type="html"><![CDATA[<p>4.1.1<br>
字面值和变量是最简单的表达式<br>
函数调用也是一种特殊的运算符<br>
小整数类型（bool、char、short）一般会被提升为较大的整数类型，主要是int<br>
左值可以位于赋值语句的左侧，右值则不能 另一种解释：左值指的是既能够出现在等号左边也能出现在等号右边的变量(或表达式)，右值指的则是只能出现在等号右边的变量(或表达式).<br>
当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）<br>
在需要右值的地方可以用左值来代替，但是不能把右值当成左值（也就是位置）来使用</p>
<ol>
<li>赋值运算符 需要一个非常量的左值作为其左侧运算对象，得到的结果也仍然是一个左值。</li>
<li>取地址符 作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值。</li>
<li>内置解引用运算符、下标运算符、迭代器解引用运算符、string和vector的下标运算符的求值结果都是左值</li>
<li>内置类型和迭代器的递增递减运算符作用于左值运算对象，其前置版本所得结果也是左值（后置版本则将对象原始值的副本作为右值返回。）</li>
<li>decltype中，如果表达式的求值结果是一个左值，则得到一个引用类型。例如 p的类型是int*，解引用符生成左值，所以 decltype（*p）的结果是int&amp;。另一方面，取地址运算符生成右值，<strong>所以decltype（&amp;p）的结果为int，指向整形指针的指针。</strong><br>
4.1.2<br>
括号无视优先级和结合律<br>
结合律对表达式产生影响的一个典型示例是输入输出运算 cin&gt;&gt;v1&gt;&gt;v2;//<strong>左结合律，先读入v1，再读入v2</strong></li>
</ol>
<p>习题4.1<br>
105，和平常的运算顺序一致<br>
习题4.2<br>
（a）*(vec.begin) （b）*(vec.begin)+1<br>
知识点：调用运算符的优先级高于解引用运算符</p>
<p>4.1.3<br>
表达式中的求值顺序是不确定的，尽量不要在表达式中进行求值 比如 cout&lt;&lt;i&lt;&lt;++i;<br>
有四种运算符明确规定了运算对象的求值顺序（<strong>先左后右</strong>） 1.逻辑与&amp;&amp; 2.逻辑或 3.条件运算符 ?:   4.逗号运算符</p>
<p>习题4.3<br>
可以，程序员可以灵活使用括号符，应当承担保证代码正确的责任，进一步提高效率。</p>
<p>4.2<br>
左结合律：优先级相同时从左到右进行组合<br>
算术运算符的运算对象和求值对象都是右值<br>
在表达式求值前，小整数类型（bool、char、short）一般会被提升为较大的整数类型<br>
一元运算符可以作用于一个指针 或 算术值 得到一个提升后的副本 比如 bool b=true；  -b为true 运算过程为  负号使得b变为int类型并等于1 取负后得到-1 -1再变为布尔类型得到真。<br>
除法运算中商无论正负，一律向0取整，即直接切除小数部分<br>
<strong>取模运算中 结果的符号与被除数相同。</strong></p>
<p>习题4.4<br>
(12/3*4)+(5*15)+(24%4/2) = 91<br>
习题4.5<br>
（a）-86（b）-18（c）0（d）-2<br>
习题4.6</p>
<pre><code>if（a%2） 
	cout&lt;&lt;&quot;奇数&quot;&lt;&lt;endl; 
else
	cout&lt;&lt;&quot;偶数&quot;&lt;&lt;endl; 
</code></pre>
<p>习题4.7<br>
当前值大于变量类型所能容纳的范围<br>
int i = 2^16+1;double d=2^64+1 ;int i = -2^16-1</p>
<p>4.3<br>
关系运算符用于算术类型或指针类型，逻辑运算符作用于任意能转换成布尔值的类型 两者的返回值都是布尔类型，都是右值<br>
将更重要的条件放在逻辑运算符的<strong>左边</strong><br>
在if（val == true）语句中，<strong>会先将true转换为val的类型，而不是将val转换为布尔类型，</strong> 等同于if（val == 1）所以一般使用if（val）<br>
进行比较运算时除非比较的对象是布尔类型，否则不要用true和false来作为运算对象<br>
习题4.8<br>
先左后右<br>
习题4.9<br>
先判断cp的值是否为零，如果不为0再判断*p的值是否为0<br>
习题4.10</p>
<pre><code>int i；
while（cin&gt;&gt;i）
	if(i==42)
		break;
</code></pre>
<p>习题4.12<br>
先判断j&lt;k是否成立，得到bool值转化为0或1，再与i比较是否相等！等同于  if(i!=(j&lt;k) )<br>
知识点：右结合律，并且使用类型转换</p>
<p>4.4<br>
赋值运算符的左侧运算对象必须是一个可修改的左值<br>
赋值运算符的结果是它的左侧运算对象，并且是一个左值<br>
使用花括号进行初始值列表初始化的时候<strong>不允许出现窄化转换</strong>，即精确度损失 int i; i = {3.14}是错误的<br>
初始值列表可以为空，无论左侧运算对象的类型是什么，此时编译器创建一个<strong>值初始化的临时量赋给左侧运算对象，比如int为0 ，string为空</strong><br>
赋值运算符满足<strong>右结合律</strong>，<strong>因此 ival = jval = 0；的运算是正确的</strong><br>
多重赋值语句需要类型相同或者是可以相互转换的类型<br>
<strong>不能把指针的值赋给int</strong>，因为int*无法转换成 int<br>
赋值运算符等级较低，最好多用括号<br>
a += b与 a = a + b的区别在于<strong>复合运算符只求值一次，普通运算符求值两次</strong><br>
（题目 4.13）</p>
<p>习题4.13<br>
（a）d=i=3（注意右结合律导致精度损失 ）（b）i=3 d=3.5<br>
知识点：赋值语句右结合律，精度损失<br>
习题4.14<br>
第一个报错，第二个永远等于true<br>
习题4.15<br>
不能把int*赋给int，就算当中的值可以视为一个整数<br>
习题4.16<br>
右结合律<br>
（a） (p=getPtr())!=0（b）i==1024</p>
<p>4.5递增和递减运算符<br>
前置++和后置++都必须作用于左值运算对象，前置版本将对象本身作为左值返回，<strong>后置版本则将对象原始值的副本作为右值返回。</strong><br>
后置递增运算符比较消耗性能，降低了可读性，除非能够使程序更简洁，否则不建议使用<br>
如果想在一条复合表达式中既将变量+1或-1又能使用它原来的值，就应当使用后置递增递减符<br>
*ptr++ 等同于*(ptr++)** 递增运算符的优先级高于解引用运算符**<br>
<strong>运算对象可按任意顺序求值</strong>，所以*ptr = func(*ptr++);的最终结果是<strong>未定义的</strong>，最终结果取决于编译器自身执行的顺序</p>
<p>习题4.17<br>
前置递增运算符在使用变量前递增，后置递增符则在使用后递增<br>
习题4.18<br>
先向前移动再解引用，容易导致访问未知地址的值<br>
习题4.19<br>
（a）不正确，前者判断是否为空指针，后者则先递增指针再判断值是否为0，容易读取到未知值<br>
（b）判断ival和ival+1两个值是否都非0<br>
（c）未定义值，不知道++在何时运行（注意和&amp;&amp;的区别，&amp;&amp;是必需先完成右边再算左边）</p>
<p>习题感悟<br>
if（i！=j&lt;k）等同于  if(i!=(j&lt;k) ) 右结合律<br>
int i;double d; d=i=3.5;//d=i=3（注意右结合律导致精度损失 ）<br>
不能把int*赋给int，就算当中的值可以视为一个整数<br>
ival++&amp;&amp;ival 判断ival和ival+1两个值是否都非0，注意先判断ival再递增，再判断右边值</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 299 猜数字游戏]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-299-cai-shu-zi-you-xi</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-299-cai-shu-zi-you-xi">
        </link>
        <updated>2019-09-09T03:17:52.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目如下：<br>
你正在和你的朋友玩 猜数字（Bulls and Cows）游戏：你写下一个数字让你的朋友猜。每次他猜测后，你给他一个提示，告诉他有多少位数字和确切位置都猜对了（称为“Bulls”, 公牛），有多少位数字猜对了但是位置不对（称为“Cows”, 奶牛）。你的朋友将会根据提示继续猜，直到猜出秘密数字。<br>
请写出一个根据秘密数字和朋友的猜测数返回提示的函数，用 A 表示公牛，用 B 表示奶牛。<br>
请注意秘密数字和朋友的猜测数都可能含有重复数字。</p>
<p>示例 1:<br>
输入: secret = &quot;1807&quot;, guess = &quot;7810&quot;<br>
输出: &quot;1A3B&quot;<br>
解释: 1 公牛和 3 奶牛。公牛是 8，奶牛是 0, 1 和 7。<br>
示例 2:<br>
输入: secret = &quot;1123&quot;, guess = &quot;0111&quot;<br>
输出: &quot;1A1B&quot;<br>
解释: 朋友猜测数中的第一个 1 是公牛，第二个或第三个 1 可被视为奶牛。<br>
说明: 你可以假设秘密数字和朋友的猜测数都只包含数字，并且它们的长度永远相等。</p>
</blockquote>
<p>题目非常拗口....完全就是美式风格，一种为了出题而强行出题的感觉，而且本土化做得不够，公牛奶牛bullscows完全和题目对应不上，这是要扣钱的啊！<br>
还是先说一下思路吧<br>
我一开始其实并没有太好的想法，然后遍历对比相等的数量，最后再遍历对比，时间复杂度为o(n^2),空间复杂度为o(1),比较笨的方法，先把时间复杂度降下来，又发现空间复杂度上去了，所以还是老老实实看题解吧</p>
<p>这一次没有官方题解，依旧是网友题解：</p>
<blockquote>
<p>方法一：我的思路很简单，先遍历一次字符串，如果两个字符串当前索引字符相同，则将&quot;公牛数&quot;加一；否则，将秘密字符串的字符放入HashMap中，进行次数统计，将猜的字符放入一个Array中。<br>
第一次遍历完毕后进行第二次遍历，此时的array中是猜的字符串中没有对上号的字符，依次获取array中的字符，看HashMap中是否有该字符，如果有，则让&quot;母牛数&quot;加一，然后将该字符的次数减一，如果该字符在Map中的次数为零则清除。<br>
方法一代码如下：</p>
<pre><code>/*
    Time complexity: O(n)
    Space complexity: O(n)
 */
public String getHint(String secret, String guess) {
    int aCount = 0;
    int bCount = 0;
    ArrayList&lt;Character&gt; list = new ArrayList&lt;&gt;();
    HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();
    for (int i = 0; i &lt; secret.length(); i++) {
        char temp = secret.charAt(i);
        if (temp == guess.charAt(i))
            aCount++;
        else {
            list.add(guess.charAt(i));
            if (map.containsKey(temp))
                map.put(temp, map.get(temp) + 1);
            else
                map.put(temp, 1);
        }
    }
    for (Character c : list) {
        if (map.containsKey(c)) {
            bCount++;
            map.put(c, map.get(c) - 1);
            if (map.get(c) == 0)
                map.remove(c);
        }
    }
    return aCount + &quot;A&quot; + bCount + &quot;B&quot;;
}
</code></pre>
<p>方法二：由于猜的数字只包括0~9这九位数字，因此我们可以定义两个10位数组来存储某个数出现的次数，索引代表数值，索引处的值代表次数。<br>
思路如下：先遍历一次字符串，如果字符相等，公牛数加一，否则，将它们对应的数组中的次数加一。<br>
第一次遍历完毕后可以得到两个数组，分别对应了两个字符串中某一个数出现的次数(匹配的字符不算)，然后我们可以再进行一次遍历，两个数组每一个索引处的最小值相加即可得到母牛数。<br>
代码如下：</p>
<pre><code>/*
    Time complexity: O(n)
    Space complexity: O(n)
 */
public String getHint(String secret, String guess) {
    int aCount = 0;     // 公牛数
    int bCount = 0;     // 母牛数
    //int mapS[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    //int mapG[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    int[] mapS[] = new int[10];
    int[] mapG[] = new int[10];

    for (int i = 0; i &lt; secret.length(); i++) {
        char temp = secret.charAt(i);
        if (temp == guess.charAt(i))
            aCount++;
        else {
            mapS[temp - '0']++;
            mapG[guess.charAt(i) - '0']++;
        }
    }
    for (int i = 0; i &lt; 10; i++) {
        bCount += Math.min(mapG[i], mapS[i]);
    }
    return aCount + &quot;A&quot; + bCount + &quot;B&quot;;
}
</code></pre>
<p>作者：janvysun<br>
链接：https://leetcode-cn.com/problems/bulls-and-cows/solution/javaliang-chong-fang-fa-by-janvysun/<br>
来源：力扣（LeetCode）<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>&quot;Bulls&quot;：遍历两个字符串，相同位置相同字符的个数</p>
<p>&quot;Cows&quot;：排出完全猜对的数字，统计secret中剩余数字和出现的次数，再比对guess中出现相同数的次数</p>
<p>public String getHint(String secret, String guess) {<br>
int bulls = 0, cows = 0;<br>
int[] dict = new int[10];<br>
//计数<br>
for (int i = 0; i &lt; secret.length(); i++) {<br>
dict[secret.charAt(i) - '0']++;<br>
}</p>
<pre><code>for (int i = 0; i &lt; guess.length(); i++) {
    if (guess.charAt(i) == secret.charAt(i)) {
        bulls++;
        dict[secret.charAt(i) - '0']--;
        if (dict[secret.charAt(i) - '0'] &lt; 0) cows--;
    } else if (dict[guess.charAt(i) - '0'] &gt; 0) {
        cows++;
        dict[guess.charAt(i) - '0']--;
    }
}

return bulls + &quot;A&quot; + cows + &quot;B&quot;;
</code></pre>
<p>}</p>
<p>作者：zxy0917<br>
链接：https://leetcode-cn.com/problems/bulls-and-cows/solution/java-shi-yong-zi-dian-shu-zu-by-zxy0917/<br>
来源：力扣（LeetCode）<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<p>上面两种方法其实我都不是特别满意，首先是不太希望用hash-map，用了确实方便很多，但是还是希望用基础的数组知识解决。上面的方法还是给我很多启发的，首先是空间复杂度可以压低到长度为10的数组，反正就是个数字（0-9），然后是string的数字转化为阿拉伯数字（secret.charAt(i) - '0'），对bulls和cows的处理：</p>
<p>下面是最终代码：</p>
<pre><code>class Solution {
public:
    string getHint(string secret, string guess) {
	int Bulls = 0, Cows = 0;
	vector&lt;int&gt; v(10, 0);
	for (auto i : secret)
			++v[i - '0'];
	for (int i = 0; i&lt;guess.size(); ++i)
		if (guess[i] == secret[i]) {
			++Bulls;
			--v[guess[i] - '0'];
			guess[i] = 'a';
		}
	for (int i = 0; i&lt;guess.size(); ++i)
		if (guess[i] != 'a')
			if(v[guess[i] - '0'] &gt; 0) {
			--v[guess[i] - '0'];
			++Cows;
		}
        string b = to_string(Bulls)+'A'+to_string(Cows)+'B';
        return b;
    }
};
</code></pre>
<p>中间遇到一些坑：<br>
1.string的数字（实际上是ASCII编码）怎么转化为阿拉伯数字呢？上面的题解给我的思路就是guess[i] - '0'，挺不错的，查了很多方法都比较复杂，这个挺好的。<br>
2.相等值的干扰，本来以为相等值最好处理，结果是最难处理的干扰因素，前面的提交错误都是Bulls造成Cows值错误，题解中的处理比较复杂，我是直接暴力地把它变成'a'然后再加判断条件，最后通过了。</p>
<p>感想：其实这一次做题有点特殊，六点多起床到实验室做题，下午得作报告，本来想着八点多做完吃个早餐就开始忙活报告的事，结果这道题一直提交错误，各种特例出错，心态有点爆炸，不止一次出现放弃然后贴代码的念头，自己心烦意乱也没法好好分析，幸好最后还是咬咬牙坚持了下来能够一步一步地改过来，下午的会议也出奇地顺利，所以还是努力吧，未来的自己一定会感激现在努力的自己。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 41. 缺失的第一个正数[困难]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-41-que-shi-de-di-yi-ge-zheng-shu-kun-nan</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-41-que-shi-de-di-yi-ge-zheng-shu-kun-nan">
        </link>
        <updated>2019-09-08T13:24:52.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个未排序的整数数组，找出其中没有出现的最小的正整数。<br>
示例 1:<br>
输入: [1,2,0]<br>
输出: 3<br>
示例 2:<br>
输入: [3,4,-1,1]<br>
输出: 2<br>
示例 3:<br>
输入: [7,8,9,11,12]<br>
输出: 1<br>
说明:<br>
你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/first-missing-positive<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>第一次做困难的题，还是比较紧张的<br>
下意识想到的办法是建立另外一个数组，利用这个数组的下标来存储已经有的数值（此时其实已经犯了一个错误，常数级别的空间就意味着必须原地操作）<br>
然后考虑需要处理的情况有<br>
1.把负值全部变为0；<br>
2.取最大值作为另外一个数组的大小值；<br>
因为昨天回家了，所以是在平板上做题的，没有保存好代码，只保存了最后的代码</p>
<pre><code>public:
    int firstMissingPositive(vector&lt;int&gt;&amp; nums) {
        if(nums.size()==0)
            return 1;
        for (int i=0;i&lt;nums.size();++i)
            if(nums[i]&gt;nums.size())
                nums[i] = 0; 
        vector&lt;int&gt; norm(nums.size(),0);
        for(auto i : nums)
            if(i&gt;0){
                norm[i-1]=1;
            }
        for(int i = 0;i&lt;nums.size();++i)
            if(norm[i]!=1)
                return i+1;
        return nums.size()+1;     
    }

</code></pre>
<p>最后提交还是毫无疑问地出错了。。。系统给我安排一个过亿的数值能不出错嘛。。。<br>
这个时候不小心瞄到一眼答案，发现必须把大于数组长度的值置为0，hhh修改后就通过啦！（当然此时已经不符合常数级别空间的要求）</p>
<p>官方题解如下（图比较多，比较麻烦）</p>
<blockquote>
<p>方法 1：索引作为哈希表。<br>
数据预处理</p>
<p>首先我们可以不考虑负数和零，因为不需要考虑。同样可以不考虑大于 n 的数字，<br>
因为首次缺失的正数一定小于或等于 n + 1 。<br>
缺失的正数为 n + 1 的情况会单独考虑。<br>
为了不考虑这些数，又要保证时间复杂度为O(N) ，因此<br>
不能将这些元素弹出。我们可以将这些数用 1 替换。<br>
为了确保缺失的第一个正数不是 1，先要在这步操作前确定 1 是否存在。</p>
<p>如何实现就地算法<br>
现在我们有一个只包含正数的数组，范围为 1 到 n，<br>
现在的问题是在 \mathcal{O}(N)O(N) 的时间和常数空间内找出首次缺失的正数。<br>
如果可以使用哈希表，且哈希表的映射是 正数 -&gt; 是否存在 的话，这其实很简单。<br>
&quot;脏工作环境&quot; 的解决方法是将一个字符串 hash_str 分配 n 个 0，并且用类似于哈希表的方法，如果在数组中出现数字 i 则将字符串中 hash_str[i] 修改为 1 。</p>
<p>我们不使用这种方法，但是借鉴这种 使用索引作为哈希键值 的想法。<br>
最终的想法是 使用索引作为哈希键 以及 元素的符号作为哈希值 来实现是否存在的检测。<br>
例如，nums[2] 元素的负号意味着数字 2 出现在 nums 中。nums[3]元素的正号表示 3 没有出现在 nums 中。<br>
为了完成此操作，我们遍历一遍数组（该操作在数据预处理使得数组中只有正数的操作后），检查每个元素值 elem 以及将nums[elem] 元素的符号变为符号来表示数字 elem 出现在 nums 中。注意，当数字出现多次时需要保证符号只会变化 1 次。<br>
算法</p>
<p>现在可以开始写算法了。</p>
<p>检查 1 是否存在于数组中。如果没有，则已经完成，1 即为答案。<br>
如果 nums = [1]，答案即为 2 。<br>
将负数，零，和大于 n 的数替换为 1 。<br>
遍历数组。当读到数字 a 时，替换第 a 个元素的符号。<br>
注意重复元素：只能改变一次符号。由于没有下标 n ，使用下标 0 的元素保存是否存在数字 n。<br>
再次遍历数组。返回第一个正数元素的下标。<br>
如果 nums[0] &gt; 0，则返回 n 。<br>
如果之前的步骤中没有发现 nums 中有正数元素，则返回n + 1。<br>
代码</p>
<p>JavaPython<br>
class Solution {<br>
public int firstMissingPositive(int[] nums) {<br>
int n = nums.length;</p>
<pre><code>// 基本情况
int contains = 0;
for (int i = 0; i &lt; n; i++)
  if (nums[i] == 1) {
    contains++;
    break;
  }

if (contains == 0)
  return 1;

// nums = [1]
if (n == 1)
  return 2;

// 用 1 替换负数，0，
// 和大于 n 的数
// 在转换以后，nums 只会包含
// 正数
for (int i = 0; i &lt; n; i++)
  if ((nums[i] &lt;= 0) || (nums[i] &gt; n))
    nums[i] = 1;

// 使用索引和数字符号作为检查器
// 例如，如果 nums[1] 是负数表示在数组中出现了数字 `1`
// 如果 nums[2] 是正数 表示数字 2 没有出现
for (int i = 0; i &lt; n; i++) {
  int a = Math.abs(nums[i]);
  // 如果发现了一个数字 a - 改变第 a 个元素的符号
  // 注意重复元素只需操作一次
  if (a == n)
    nums[0] = - Math.abs(nums[0]);
  else
    nums[a] = - Math.abs(nums[a]);
}

// 现在第一个正数的下标
// 就是第一个缺失的数
for (int i = 1; i &lt; n; i++) {
  if (nums[i] &gt; 0)
    return i;
}

if (nums[0] &gt; 0)
  return n;

return n + 1;
</code></pre>
<p>}<br>
}<br>
复杂性分析<br>
时间复杂度： O(N) 由于所有的操作一共只会遍历长度为 N 的数组 4 次。<br>
空间复杂度： O(1) 由于只使用了常数的空间。</p>
</blockquote>
<p>最后还是很精妙的，当然前期处理非常重要，然后还有一点很重要，只有当当前下标的值处理好后，才会进行下标递增！（可以参考题解中的桶排序，其中精妙的思想还有如下：</p>
<blockquote>
<p>补充内容：<br>
交换两个整数，有两种比较 tricky 的做法。下面给出结论。<br>
“基于异或运算”是因为利用了“异或运算”是不进位的二进制加法。它有如下性质：<br>
如果 a ^ b = c ，那么 a ^ c = b 与 b ^ c = a 同时成立，利用这一条，可以用于交换两个变量的值。<br>
于是，交换两个变量的值，例如 a 和 b，不使用第三个变量，有两种不同的方法：<br>
基于异或运算	<br>
a = a ^ b<br>
b = a ^ b<br>
a = a ^ b<br>
基于加减法<br>
a = a + b<br>
b = a - b<br>
a = a - b<br>
我理解的方式就是自己在纸上写几个例子，并且记住这个结论。个人觉得“基于异或运算”交换两个变量的值好记一些，因为右边都一样，左边依次是 a、b、a。</p>
<p>在这里特别感谢用户 @davidlaid 给出的意见：<br>
对于异或运算实现的交换方法，如果调用 swap(nums, i, i)，那么最终的结果会变为 0。<br>
对于加减法实现的交换方法，有可能发生溢出。<br>
调用 swap(nums, i, i)，那么最终的结果会变为 0 这是因为，如果是在数组中，自己和自己交换，只有 1 个空间，这个数会在异或运算的过程中变为 0，因此单独判断一下就好了。我个人还是比价少用这个技巧的，如果题目中限制了不能使用额外的存储空间，才用“基于异或运算实现的交换方法”。</p>
<p>参考代码 2：基于异或运算交换两个变量的值。<br>
PythonPythonJava<br>
from typing import List<br>
class Solution:<br>
def firstMissingPositive(self, nums: List[int]) -&gt; int:<br>
size = len(nums)<br>
for i in range(size):<br>
while 1 &lt;= nums[i] &lt;= size and nums[i] != nums[nums[i] - 1]:<br>
self.__swap(nums, i, nums[i] - 1)<br>
for i in range(size):<br>
if i + 1 != nums[i]:<br>
return i + 1<br>
return size + 1</p>
<pre><code>def __swap(self, nums, index1, index2):
    if index1 == index2:
        return
    nums[index1] = nums[index1] ^ nums[index2]
    nums[index2] = nums[index1] ^ nums[index2]
    nums[index1] = nums[index1] ^ nums[index2]
</code></pre>
<p>作者：liweiwei1419<br>
链接：https://leetcode-cn.com/problems/first-missing-positive/solution/tong-pai-xu-python-dai-ma-by-liweiwei1419/<br>
来源：力扣（LeetCode）<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<p>异或互换和加法互换都很神奇，实现了两个对象之间的互换而不需要额外的参数！所以从别人身上学到了很多有趣的东西啊，也同时验证了我之前的随心感想，在leetcode还是可以学到很多知识的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 189.旋转数组]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-189xuan-zhuan-shu-zu</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-189xuan-zhuan-shu-zu">
        </link>
        <updated>2019-09-06T13:27:51.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p>
<p>示例 1:</p>
<p>输入: [1,2,3,4,5,6,7] 和 k = 3<br>
输出: [5,6,7,1,2,3,4]<br>
解释:<br>
向右旋转 1 步: [7,1,2,3,4,5,6]<br>
向右旋转 2 步: [6,7,1,2,3,4,5]<br>
向右旋转 3 步: [5,6,7,1,2,3,4]</p>
<p>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。<br>
要求使用空间复杂度为 O(1) 的 原地 算法。</p>
</blockquote>
<blockquote>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/rotate-array<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>按照昨天学习到的思想，对题目进行分解：<br>
首先是特殊情况：k == 0 || nums.size() == 0 || nums.size() == 1 || nums.size() == k，直接白给return<br>
然后是两种情况<br>
第一种 k大于size 第二种k小于size<br>
其实第一种可以通过k%size转化为第二种（发现自己居然忘了c++的取余数为%）<br>
但是最后被旋转原地移动难住了，最后只能暴力出奇迹，一位一位地移动了：</p>
<pre><code>class Solution {
	public:
		void rotate(vector&lt;int&gt;&amp; nums, int k) {
			if (k == 0 || nums.size() == 0 || nums.size() == 1 || nums.size() == k)
				return;
			else if (nums.size()&lt;k)
				k = k%nums.size();
			while (k&gt;0) {
				int temp = nums[nums.size() - 1];
				for (int j = nums.size() - 1; j&gt;0; --j)
					nums[j] = nums[j - 1];
				nums[0] = temp;
				--k;
			}
			return;
		}
	};
</code></pre>
<p>最后提交居然超过了时间限制？<br>
一看题解，what？第一个就是暴力解啊？？？我的还是做了情况优化的，把Java代码转化为C++，还是白给了。。。C++无人权啊！！！<br>
题解明天再看吧，剩下的时间处理一下c++，星期一还得报告呢<br>
今天很无语，遇到很奇葩的事情了，详情看随心感想吧，<br>
第一次无法按时完成任务...好无力啊</p>
<p>9.8补充：<br>
官方题解<br>
第一个就是暴力题解了，只是c++铁定会超时，就算进行情况优化和把官方java题解照搬过来也是全部木大，后来才发现leetcode会对c++严格很多</p>
<blockquote>
<p>题解二：<br>
方法 2：使用额外的数组<br>
算法<br>
我们可以用一个额外的数组来将每个元素放到正确的位置上，也就是原本数组里下标为 ii 的我们把它放到 (i+k)%数组长度(i+k)%数组长度 的位置。然后把新的数组拷贝到原数组中。<br>
Java<br>
public class Solution {<br>
public void rotate(int[] nums, int k) {<br>
int[] a = new int[nums.length];<br>
for (int i = 0; i &lt; nums.length; i++) {<br>
a[(i + k) % nums.length] = nums[i];<br>
}<br>
for (int i = 0; i &lt; nums.length; i++) {<br>
nums[i] = a[i];<br>
}<br>
}<br>
}<br>
复杂度分析<br>
时间复杂度： O(n) 。将数字放到新的数组中需要一遍遍历，另一边来把新数组的元素拷贝回原数组。<br>
空间复杂度： O(n)。另一个数组需要原数组长度的空间。</p>
</blockquote>
<p>题解二比较简单，但是空间复杂度比较高，在常数空间复杂度的情况下并不适用</p>
<blockquote>
<p>题解三：<br>
方法 3：使用环状替换<br>
算法<br>
如果我们直接把每一个数字放到它最后的位置，但这样的后果是遗失原来的元素。因此，我们需要把被替换的数字保存在变量 temp 里面。然后，我们将被替换数字（temp）放到它正确的位置，并继续这个过程 n 次， n 是数组的长度。这是因为我们需要将数组里所有的元素都移动。但是，这种方法可能会有个问题，如果 n%k==0，其中 k=k%n （因为如果 k 大于 n ，移动 k 次实际上相当于移动 k%n 次）。这种情况下，我们会发现在没有遍历所有数字的情况下回到出发数字。此时，我们应该从下一个数字开始再重复相同的过程。</p>
<p>现在，我们看看上面方法的证明。假设，数组里我们有 n 个元素并且 k 是要求移动的次数。更进一步，假设 n%k=0 。第一轮中，所有移动数字的下标 i满足 i%k<mark>0。这是因为我们每跳 k 步，我们只会到达相距为 k 个位置下标的数。每一轮，我们都会移动n/k个元素。下一轮中，我们会移动满足 i%k</mark>1的位置的数。这样的轮次会一直持续到我们再次遇到i%k==0 的地方为止，此时 i=k 。此时在正确位置上的数字共有k*n/k 	 =n 个。因此所有数字都在正确位置上。<br>
让我们看一下接下来的例子，以更好地说明这个过程：<br>
nums: [1, 2, 3, 4, 5, 6]<br>
k: 2<br>
Java<br>
public class Solution {<br>
public void rotate(int[] nums, int k) {<br>
k = k % nums.length;<br>
int count = 0;<br>
for (int start = 0; count &lt; nums.length; start++) {<br>
int current = start;<br>
int prev = nums[start];<br>
do {<br>
int next = (current + k) % nums.length;<br>
int temp = nums[next];<br>
nums[next] = prev;<br>
prev = temp;<br>
current = next;<br>
count++;<br>
} while (start != current);<br>
}<br>
}<br>
}<br>
复杂度分析</p>
<p>时间复杂度：O(n) 。只遍历了每个元素一次。<br>
空间复杂度：O(1) 。使用了常数个额外空间。</p>
</blockquote>
<p>第三个就是我一开始想到的操作了，但是还是算是比较复杂，我更喜欢第四个：</p>
<blockquote>
<p>方法 4：使用反转<br>
算法<br>
这个方法基于这个事实：当我们旋转数组 k 次， k%n 个尾部元素会被移动到头部，剩下的元素会被向后移动。<br>
在这个方法中，我们首先将所有元素反转。然后反转前 k 个元素，再反转后面 n-k 个元素，就能得到想要的结果。<br>
假设 n=7 且k=3 。</p>
<p>原始数组                  : 1 2 3 4 5 6 7<br>
反转所有数字后             : 7 6 5 4 3 2 1<br>
反转前 k 个数字后          : 5 6 7 4 3 2 1<br>
反转后 n-k 个数字后        : 5 6 7 1 2 3 4 --&gt; 结果<br>
Java<br>
public class Solution {<br>
public void rotate(int[] nums, int k) {<br>
k %= nums.length;<br>
reverse(nums, 0, nums.length - 1);<br>
reverse(nums, 0, k - 1);<br>
reverse(nums, k, nums.length - 1);<br>
}<br>
public void reverse(int[] nums, int start, int end) {<br>
while (start &lt; end) {<br>
int temp = nums[start];<br>
nums[start] = nums[end];<br>
nums[end] = temp;<br>
start++;<br>
end--;<br>
}<br>
}<br>
}<br>
复杂度分析</p>
<p>时间复杂度：O(n)。 nn 个元素被反转了总共 3 次。<br>
空间复杂度：O(1) 。 没有使用额外的空间。</p>
</blockquote>
<p>哈哈哈可以说是非常优雅了，一开始我也想到翻转，但是却没想到可以翻转两次！666！<br>
后面是我的代码：</p>
<pre><code>class Solution {
public:
    void rotate(vector&lt;int&gt;&amp; nums, int k) {
        if (k == 0 || nums.size() == 0 || nums.size() == 1 || nums.size() == k)
			return;
		else if (nums.size()&lt;k)
			k = k%nums.size();
        swap_num(nums,0,nums.size()-1);
        swap_num(nums,0,k-1);
        swap_num(nums,k,nums.size()-1);
        
    }
    void swap_num(vector&lt;int&gt;&amp; nums,int first,int last){
        while(first&lt;last){
            int temp = nums[first];
            nums[first] = nums[last];
            nums[last] = temp;
            ++first;--last;
        }
    }
};
</code></pre>
<p>总体来说这一次还是有不小的进步的，开始学会思考情况了，但是解决问题的能力还是有待提高啊！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第三章 笔记+习题 3.5-3.6]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-san-zhang-bi-ji-xi-ti-35-36</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-san-zhang-bi-ji-xi-ti-35-36">
        </link>
        <updated>2019-09-06T07:17:15.000Z</updated>
        <content type="html"><![CDATA[<p>3.5<br>
数组大小固定 如果元素个数不确定，就是用vector<br>
数组声明 a[d] 其中d必须是一个常量字面值或者是一个<strong>常量表达式</strong><br>
非内置的数据类型默认初始化为空<br>
函数内部定义的数组 默认初始化会含有未定义的值<br>
数组定义时必须指定数组的类型，<strong>不允许用auto关键字</strong><br>
引用无法组成数组<br>
<strong>列表初始化可以缺省数组的维度</strong><br>
使用字符串字面值初始化字符数组时，需要保留空间给结尾的<strong>空字符‘\0’</strong><br>
数组<strong>不允许拷贝初始化和赋值</strong> 但vector可以进行拷贝<br>
数组声明阅读由内向外<br>
指向数组的指针 int (*Parray)[10] = &amp;arr;  数组的应用 int (&amp;Rarra)[10] = arr; 注意不能漏掉括号 去掉括号就成了 指针数组和非法定义<br>
int *(&amp;Rarra) [10] = arr; 一个含有10个int指针的数组的引用<br>
<strong>int *ptrs[10];//指针的数组  int (*ptrs)[10];//数组的指针</strong></p>
<p>习题3.27<br>
a c 非法 不是一个常量值啊 d 非法 还有结尾空字符放不进去<br>
习题3.28<br>
string[] 为空 外部int[]为0 内部int[]为空未定值<br>
知识点：不同作用域的定义的默认值<br>
习题3.29<br>
缺点：固定大小，初始化的方式不同</p>
<p>3.5.2<br>
数组下标类型为 size_t<br>
数组元素可以通过范围for语句以及下标运算符访问<br>
注意数组可以使用范围for语句，但是！调用的形式是：<br>
int a[10]; for(auto i : <strong>a</strong> ) i++;</p>
<p>习题3.30<br>
ix最后会等于size，ia[10]是不存在的，强行调用会导致内存出错<br>
习题3.31</p>
<pre><code>int main() {
	int a[10];
	for (int i = 0; i &lt; 10; ++i) {
		a[i] = i;
		cout &lt;&lt; a[i] &lt;&lt; ' ';
	}
};
</code></pre>
<p>知识点：数组的初始化<br>
习题3.31</p>
<pre><code>int main() {
	int a[10];
	for (int i = 0; i &lt; 10; ++i) {
		a[i] = i;
		cout &lt;&lt; a[i] &lt;&lt; ' ';
	}
	int b[10] ;
	for (int i = 0; i &lt; 10; ++i) 
		b[i] = a[i];	
	vector&lt;int&gt; v1(10, 10);
	vector&lt;int&gt; v2 = v1;
	for (auto i : v2)
		cout &lt;&lt; i &lt;&lt; ' ';
}
</code></pre>
<p>知识点：数组和vector的差异，初始化、拷贝等<br>
习题3.33<br>
将会强行调用未定义的值，出现难以预料的结果。<br>
知识点：数组默认初始化</p>
<p>3.5.3<br>
数组的每个元素都有地址，可以对特定元素使用取地址符<br>
<strong>数组名字本身就是一个指向数组首元素的指针</strong> int *b = arr;<br>
使用数组的时候实质上真正使用的是指向数组某元素的指针<br>
所以涉及数组<strong>的auto会定义为指针 而非数组  但decltype 返回的类型是同等维度的数组</strong><br>
<strong>指向数组的指针就等于一个迭代器</strong> 支持++等运算符<br>
标准库函数begin和end 将数组作为参数 int *beg = begin(ia); int *last = end(ia); 定义在iterator头文件内<br>
<strong>指针支持所有迭代器运算</strong><br>
两个指针相减得到的值类型为ptrdiff_t 带符号类型 定义在cstddef头文件中<br>
如果含有点运算符和解引用符 最好在必要的地方加上括号<br>
<strong>指针也可以进行下标运算</strong><br>
对数组执行下标运算其实就是对指向数组元素的指针执行下标运算<br>
int *p = &amp;ia[2]; int j =p[1]; //等价于*p(1)<br>
标准库类型的下标必须是无符号类型 例如string和vector  内置的下标无此要求 比如指针和数组<br>
<strong>下标[-1]就是指最后一个值</strong></p>
<p>习题3.34<br>
将p1指针移动到p2<br>
习题3.35</p>
<pre><code>int main() {
	int a[10];
	for (int i = 0; i &lt; 10; ++i) {
		a[i] = i;
		cout &lt;&lt; a[i] &lt;&lt; ' ';
	}
	for (int *i = begin(a); i != end(a); ++i) {
		*i = 0;
		cout &lt;&lt; *i &lt;&lt; ' ';
	}
};
</code></pre>
<p>知识点：数组指针的定义与调用<br>
习题3.36</p>
<pre><code>int main() {
	int a[3] = {1,2,3};
	int b[3] = {1,2,3};
	if (sizeof(a) == sizeof(b)) {
		int i = 0;
		int length = sizeof(a) / sizeof(a[0]);
		while (i&lt;length&amp;&amp;a[i] == b[i])
			++i;
		if (i == length)
			cout &lt;&lt; &quot;they are equal!&quot; &lt;&lt; endl;
		else 
			cout &lt;&lt; &quot;they are difference!&quot; &lt;&lt; endl;
	}
	else
		cout &lt;&lt; &quot;they are difference!&quot; &lt;&lt; endl;
	vector&lt;int&gt; i = { 1,2,3 };
	vector&lt;int&gt; j = { 1,2,3 };
	if (i == j)
		cout &lt;&lt; &quot;they are equal!&quot; &lt;&lt; endl;
	else
		cout &lt;&lt; &quot;they are difference!&quot; &lt;&lt; endl;
};
</code></pre>
<p>知识点：数组的比较、<strong>数组的长度</strong>，vector的比较</p>
<p>3.5.4<br>
c风格字符串必须以空字符结束 char ca[ ]<br>
上述函数皆以空字符为监测点<br>
c风格字符串实际上是一个数组直接 使用时等于使用指针<br>
c风格字符串函数使用时需要不断判断空间问题，所以string比其安全高效<br>
strcmp（参数1，参数2）比较参数1和参数（1、若参数1&gt;参数2，返回正数；2、若参数1&lt;参数2，返回负数；3、若参数1=参数2，返回0；）</p>
<p>习题3.37<br>
输出hello'\0'注意空字符<br>
习题3.38<br>
两个指针相加的值最后是未知的，使用一个未知地址值的指针是非常危险的事。<br>
习题3.39</p>
<pre><code>int main() {
	char a[6] = &quot;hallo&quot;;
	char b[6] = &quot;abcde&quot;;
	if (!strcmp(a,b))
		cout &lt;&lt; &quot;they are equal!&quot; &lt;&lt; endl;
	else
		cout &lt;&lt; &quot;they are difference!&quot; &lt;&lt; endl;

	string i = { &quot;hello&quot; };
	string j = { &quot;hallo&quot; };
	if (i == j)
		cout &lt;&lt; &quot;they are equal!&quot; &lt;&lt; endl;
	else
		cout &lt;&lt; &quot;they are difference!&quot; &lt;&lt; endl;
};
</code></pre>
<p>知识点：string比较、C风格字符串比较<br>
习题3.40</p>
<pre><code>int main() {
	char a[6] = &quot;hallo&quot;;
	char b[6] = &quot;abcde&quot;;
	char c[12];
	strcat(a, b);
	strcpy(c, a);
};
</code></pre>
<p>知识点：C风格字符串函数的运用</p>
<p>3.5.5<br>
为了兼容旧代码</p>
<ol>
<li>任何出现字符串字面值都可以用以空字符结束的字符数组来代替 比如用来初始化string对象</li>
<li>string中有c_str成员函数用于处理c风格字符串</li>
<li>可以用数组初始化vector对象<br>
习题3.41</li>
</ol>
<pre><code>int main() {
	int a[10] = { 1,2,3,4,5,6,7,8,9,10 };
	vector&lt;int&gt; i (begin(a),end(a));
	for (auto x : i)
		cout &lt;&lt; x &lt;&lt; ' ';
};
</code></pre>
<p>知识点：用整形数组初始化vector<br>
习题3.42</p>
<pre><code>int main() {
	int a[10] ;
	vector&lt;int&gt; i = { 1,2,3,4,5,6,7,8,9,10 };
	int e = 0;
	for (auto x : i)
		a[e++] = x;
	for (auto x : a)
		cout &lt;&lt; x &lt;&lt; ' ';
};
</code></pre>
<p>知识点：整型数组的循环与初始化</p>
<p>3.6<br>
严格来说c++并没有多维数组 而是<strong>数组的数组</strong> 所以<strong>对数组名是指针的指针</strong>，对数组名ia的<strong>第一次解引用*ia得到还是指针</strong>，第二次解引用**ia才获得数组第一个元素<br>
当表达式提供的下标运算符数量和数组维度相同时 访问的是特定元素。如果下标运算符数量比数组维度小，则结是给定索引处的一个内层数组<br>
用范围for语句处理多维数组，除了<strong>最内层的循环外，其他所有循环的控制变量都应该是引用类型</strong><br>
在声明指向数组的指针时必须要注意括号，建议使用auto 或者类型别名（using、typedef）<br>
（题目3.43）</p>
<p>习题3.43</p>
<pre><code>int main() {
	int ia[3][3] = { {1,2,3},{ 4,5,6 } ,{ 7,8,9 } };
	for (int (&amp;x)[3] : ia)
		for (int y : x)
			cout &lt;&lt; y &lt;&lt; ' ';
	for (int x = 0; x &lt; 3; ++x)
		for (int y = 0; y &lt; 3; ++y)
			cout &lt;&lt; ia[x][y] &lt;&lt; ' ';
	for (int (*x)[3] = begin(ia); x != end(ia); ++x)
		for (int * y = *x;y != *x+3; ++y)
			cout &lt;&lt; *y &lt;&lt; ' ';	
};
</code></pre>
<p>知识点：多维数组中范围for语句、指针和下标的运用<br>
习题3.44</p>
<pre><code>//typedef int a[3];
using a = int[3];
int main() {
	
	int ia[3][3] = { {1,2,3},{ 4,5,6 } ,{ 7,8,9 } };
	for (auto &amp;x : ia)
		for (auto y : x)
			cout &lt;&lt; y &lt;&lt; ' ';
	for (int x = 0; x &lt; 3; ++x)
		for (int y = 0; y &lt; 3; ++y)
			cout &lt;&lt; ia[x][y] &lt;&lt; ' ';
	for (a *x = begin(ia); x != end(ia); ++x)
		for (int*  y = *x;y != *x+3; ++y)
			cout &lt;&lt; *y &lt;&lt; ' ';	
};
</code></pre>
<p>知识点：typedef的运用<br>
习题3.55</p>
<pre><code>int main() {
	int ia[3][3] = { {1,2,3},{ 4,5,6 } ,{ 7,8,9 } };
	for (auto &amp;x : ia)
		for (auto y : x)
			cout &lt;&lt; y &lt;&lt; ' ';
	for (int x = 0; x &lt; 3; ++x)
		for (int y = 0; y &lt; 3; ++y)
			cout &lt;&lt; ia[x][y] &lt;&lt; ' ';
	for (auto x = begin(ia); x != end(ia); ++x)
		for (auto  y = *x;y != *x+3; ++y)
			cout &lt;&lt; *y &lt;&lt; ' ';	
};
</code></pre>
<p>知识点：auto的应用</p>
<p>习题感悟、<br>
数组在不同作用域的定义的默认值受类型影响<br>
数组指针可以使用begin（ia）和end（ia）<br>
数组的长度计算得用	int length = sizeof(a) / sizeof(a[0]);<br>
c风格字符数组有很多自定义函数<br>
可以用整形数组初始化vector<br>
注意！！！！！！<br>
typedef 定义数组是这样子的 typedef int a[4] 把a定义为int[4]的类型别名！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于leetcode的小感想]]></title>
        <id>https://lixin-ee.github.io//post/guan-yu-leetcode-de-xiao-gan-xiang</id>
        <link href="https://lixin-ee.github.io//post/guan-yu-leetcode-de-xiao-gan-xiang">
        </link>
        <updated>2019-09-05T12:25:03.000Z</updated>
        <content type="html"><![CDATA[<p>  昨天查询leetcode经验时，在知乎上看到一个高赞答案说leetcode是程序员的八股文，对此我是十分不赞成的。<br>
  倘若只是依靠死记硬背来应付面试，是十分可笑的，就好像华工的游泳考试，你依靠憋着一口气，或许可以应付50米，但绝不可能应付更长的距离。<br>
  回想起一直以来健身房的经历，我觉得leetcode是一个健身房，同时算法与数据结构是程序员强壮的肌肉，但凡有力量、有速度、有技巧的运动员，哪个是瘦骨嶙峋的？当然没有强壮的肌肉你仍可跑步、游泳、打球，毕竟再普通的程序员也知道能用乘法不用加法、能用指数不用乘法的道理吧，但是没有算法与数据结构这一强壮的肌肉，你便无法做出很多漂亮的动作（比如自重引体向上）和理想的成绩，leetcode无疑是现今最好的健身房，虽然有些困难的题目确实很困难，但是我们总不能一开始无法自重引体向上就对健身房避而远之吧？<br>
   就我自己而言，仅仅五天五道题，便觉得受益良多，仿佛在与一位大师交流。非常  庆幸我能早一点遇到leetcode，而不是等到明年三月份再临时抱佛脚便咒骂这是“八股文”。我想哪怕以后不从事算法相关的工作，我现在学到的东西所带来的对思维的影响，都会在以后带来无穷的益处。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 80. 删除排序数组中的重复项 II]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-80-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang-ii</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-80-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang-ii">
        </link>
        <updated>2019-09-05T11:42:44.000Z</updated>
        <content type="html"><![CDATA[<p>题目如下：</p>
<blockquote>
<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p>示例 1:</p>
<p>给定 nums = [1,1,1,2,2,3],</p>
<p>函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。</p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>老样子，还是想用快慢指针（知道迭代器本身其实就是个指针后，还是改名了。。。），但是这一次比较麻烦，需要对重复的次数进行计算，还好是有序数组，省去很多麻烦，但是码代码的过程可不轻松，还是对暂时量和快指针的变化掌握得很差，中途多次错误都是因为没有掌握好快指针的位置变化，但是可喜可贺的是，这一次专门针对特殊情况作了考虑（包括万恶的空数组！！！）所以第二次提交就通过了，但是执行用时不理想啊，用了28ms（不知道是不是leetcode的问题呢）<br>
我的代码如下：</p>
<pre><code>class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        int i = 0;
        if(nums.size()!=0)
         for(int j=0;j&lt;nums.size();){
            int temp = nums[j];
            nums[i++]=nums[j];
            int cal = 1;
            ++j;
            while(j&lt;nums.size()&amp;&amp;nums[j]==temp){
                ++cal;
                if (cal&lt;3)
                    nums[i++]=nums[j];
                    ++j;
            }
          }              
         else
          return i;
        return i;
    }
};
</code></pre>
<p>然后看一下官方题解：</p>
<p>你以为我要贴官方题解吗？其实没有哒！<br>
好吧这次quo实没有官方题解，只有网友讨论，不过幸运的是有个非常好的高赞题解：</p>
<blockquote>
<p>原地删除肯定是双指针，一个指向遍历的元素，一个指向可以写入的位置，后者的大小是小于等于前者的，关键在于题目条件的转化，如何实现限制最多两次的重复出现。<br>
我们先不考虑边界情况，只考虑中间的情况，假设当前遍历位置为i，写指针的可写入位置为current+1，对于i处的值，其写入的条件是重复小于等于2次，我们考虑已经写入的最后两位current和current-1，这两个位置的情况有两个，相等和不相等，首先考虑相等的情况，此时若i处的值和current-1或者说current处的值相同，那么，i处的值肯定不能加入；然后考虑不相等的情况，即current-1和current处值不相等，那么i处的值无论为什么，都满足题意的，即可以加入，综上所述，当i处的值与current-1处的值不相等时，i处的值可以加入，其他情况均不能加入。<br>
接着考虑边界情况，我们只需要考虑开始即可，开始时，前两个值无论等还是不等，都要原封不动的挪到新数组里，由于新数组就是在原数组上进行修改的，因此前两位直接不动即可，只需要修改遍历指针和写入指针就行。<br>
以上算法只需要进行一次遍历即可，时间复杂度O(n)，空间复杂度O(1)。</p>
</blockquote>
<pre><code>int removeDuplicates(vector&lt;int&gt;&amp; nums) 
{
	if (nums.size() &lt;= 1)
		return nums.size();
	int current = 1;           //新数组中有效位置的最后一位，新加入的数据应当写到current+1
	for (int i = 2; i &lt; nums.size();i++) //从第三位开始循环，前两位无论如何都是要加入新数组的
	{
		if (nums[i] != nums[current - 1])  //符合条件，加入新数组
		{
			current += 1;
			nums[current] = nums[i];
		}
	}
	return current+1;
}
</code></pre>
<blockquote>
<p>作者：luo-ben-zhu-xiao-man-tou<br>
链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/solution/zhi-jie-bian-li-yi-ci-ji-ke-by-luo-ben-zhu-xiao-ma/<br>
来源：力扣（LeetCode）<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<p>好强哒！！！最让我佩服的不是代码，而是这清晰的思路，我就是缺乏这种对全局的考虑，老是想到哪写到哪，总是觉得写算法是冒出一个问题处理一个，其实正应该像他这样，把问题细化为大分类，再把特殊的情况慢慢细化为小分类，这样才能概括到尽可能多（甚至是全部）的答案啊！<br>
我提交的代码（先只看他的思想不看代码的好习惯下码出来的！！！）：<br>
class Solution {<br>
public:<br>
int removeDuplicates(vector<int>&amp; nums) {<br>
if(nums.size()&lt;3)<br>
return nums.size();<br>
else{<br>
int i=2;<br>
for(int j=2;j&lt;nums.size();j++)<br>
if(nums[j]!=nums[i-2])<br>
nums[i++]=nums[j];</p>
<pre><code>        return i;
    }    
}
</code></pre>
<p>};<br>
然后和他的代码对比一下，还是很多地方值得改进的，比如变量名，可以大大提高可读性的嘛！<br>
最后感想有点多，就写成一篇文章吧。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ C++ primer 第三章 笔记+习题 3.1-3.4]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-san-zhang-bi-ji-xi-ti-31-24</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-san-zhang-bi-ji-xi-ti-31-24">
        </link>
        <updated>2019-09-05T07:07:06.000Z</updated>
        <content type="html"><![CDATA[<p>3.1<br>
using声明 无须专门的前缀 using std::cin;<br>
每个名字都需要独立的using声明<br>
头文件不应包含using声明 否则会影响到所有使用该头文件的程序<br>
区分using指示和using声明</p>
<p>习题3.1<br>
由于是复习，所以一直有用using声明和using指示hhh<br>
但是必须说明using指示并不是好东西，多处引入using指示容易造成命名域污染</p>
<p>3.2<br>
string 表示可变长的字符序列 头文件 #include <string>  string定义在命名空间std中 最好在文件头加上using std::string <strong>始终要记得string不是内置类型</strong><br>
string empty； 默认初始化为空字符串<br>
string定义字符串末尾不含有空字符，长度不需要+1<br>
string初始化方式 string s1;string s2(s1); string s2 = s1; string s3(“value”); string s(5,’a’) = aaaaa;<br>
初始化的方式： 拷贝初始化 等号= ，直接初始化 括号（），列表初始化 花括号{ }<br>
！！！不一定有括号的就是直接初始化，拷贝初始化也可以用括号<br>
例如 int p(1);//直接初始化  int p1(p2);//拷贝初始化<br>
3.2.2<br>
一个类要定义各种运算符在该类对象上的新含义<br>
使用cin读取string对象时，会自动忽略开头的空白（空格符换行符制表符等） 然后<strong>遇到下一处空白停止读取，所以cin无法读取空格</strong><br>
如果<strong>需要保留输入的空白符，使用getline函数 遇到换行符为止</strong>（注意<strong>换行符也会被读进来，但换行符不会被存进string对象</strong>）<br>
如果输入一开始为换行符 则getline得到空string<br>
empty函数返回布尔值<br>
size函数返回值并非int，<strong>而是一个string::size_type类型的值</strong>，它是一个无符号类型的值unsigned，能够存放下任何string对象的大小<br>
注意size函数调用<strong>必须有括号size（）</strong><br>
所以不能将size函数的返回值<strong>与负值进行比较或其他操作 否则会触发强制转换</strong><br>
string <strong>相加为串接两个运算对象</strong><br>
标准库允许将字符字面值和字符串字面值转化为string对象 但混用时必须保证+加号两侧至少有一个string对象 例子 s = “hello” + “,” + s2 ; 错误 第一个加号无string对象<br>
所以 <strong>字符串字面值并非是string类型 而是array数组</strong></p>
<p>习题3.2</p>
<pre><code>	int main() {
	string s;
	//while (getline(cin, s))
		while(cin&gt;&gt;s)
		cout &lt;&lt; s &lt;&lt; endl;
};
</code></pre>
<p>习题3.3<br>
输入运算符自动忽略开头的空白，并且遇到下一处空白时停止读取，所以无法读取空白，但是getline不同，可以读取空白字符，包括<strong>换行符</strong>，只是读取后抛弃，不存入string中。<br>
习题3.4<br>
<code>int main() { 	string s1,s2; 	cout &lt;&lt; &quot;please input the first one:&quot;; 	getline(cin, s1); 	cout &lt;&lt; &quot;please input anothor one:&quot;; 	getline(cin, s2); 	if (s1 == s2) 		cout &lt;&lt; &quot;they are equal.&quot; &lt;&lt; endl; 	//else if (s1 &gt; s2) 	//	cout &lt;&lt; s1 &lt;&lt; endl; 	//else 	//	cout &lt;&lt; s2 &lt;&lt; endl; 	else if (s1.size() == s2.size()) 		cout &lt;&lt; &quot;they have same length.&quot; &lt;&lt; endl; 	else if (s1.size() &gt; s2.size()) 		cout &lt;&lt; s1 &lt;&lt; endl; 	else 		cout &lt;&lt; s2 &lt;&lt; endl; };</code><br>
习题3.5</p>
<pre><code>	int main() {
	string s,temp;
	cin &gt;&gt; s;
	while (cin &gt;&gt; temp) {
		//s = s + temp;
		s = s + &quot; &quot; + temp;
		cout &lt;&lt; s &lt;&lt;endl;
	}
};
</code></pre>
<p>3.2.3<br>
cctype 头文件中的函数可以用于处理string对象<br>
c中的标准库可以再c++中使用，name.h 变为 cname<br>
处理每个字符 使用基于范围for语句<br>
for (declaration : expression) {statement;} 其中declaration负责定义一个变量用于访问序列中的基础元素，expression为一个循环对象<br>
上述语句可以<strong>配合 auto 和 decltype</strong>来使用 比如 for (auto char1 : string1 )<br>
如果想改变string对象中字符的值，必须把循环变量expression设为<strong>引用类型</strong><br>
只处理一部分字符，使用迭代器或下标运算符[]<br>
string对象的下标<strong>从0计起</strong> s[s.size()-1]为最后一个字符<br>
下标运算符接受的输入参数是string::size_type 会将带符号类型值自动转化为该类型<br>
使用下标运算符前必须检验string对象是否为空 if(!s.empty())</p>
<p>习题3.6</p>
<pre><code>	int main() {
	string s;
	getline(cin,s);
	if (!s.empty())
	for (auto &amp;c : s) {
		c = 'X';
	}
	cout &lt;&lt; s &lt;&lt; endl;
};
</code></pre>
<pre><code>习题3.7
单纯的char是值拷贝传递，无法对原string进行改动，但是char&amp;可以
习题3.8
循环for更好用，操作起来更加方便，避免了while循环条件的寻找和阅读for循环头的复杂性，可读性更高
习题3.9
不合法，必须检查是否为空string 但是是能够正常输出，但size（）等于0
习题3.10
</code></pre>
<pre><code>	int main() {
	string s;
	getline(cin,s);
	if (!s.empty())
		for (char &amp;c : s) {
			if (!ispunct(c))
				cout &lt;&lt; c;
		}
};
</code></pre>
<pre><code>习题3.11
合法，c为const char &amp;
</code></pre>
<p>3.3<br>
vector表示对象的集合，其中所有对象的类型都相同 其中每个对象都有一个与之对应的索引<br>
头文件声明 #include<vector>   using std::vector;<br>
<strong>vector 是一个类模板 不是一个类型</strong><br>
vector能容纳大多数类型的对象作为元素，包括vector，<strong>唯独引用例外</strong>，因为引用不是对象<br>
vector对象默认初始化为空vector  vector<string> sver;<br>
vector对象之间可以互相赋值拷贝 但类型必须相同<br>
初始化的三个例外 1.拷贝初始化 = ，只能提供一个初始值 2.类内初始值只能用<strong>拷贝初始化=或者花括号初始化{ }</strong> 3.初始元素值的列表只能放在<strong>花括号</strong>内，所以称为列表初始化，而不能放在圆括号内<br>
可以使用 (元素数量，元素统一初始值) 进行初始化 元素统一初始值可以缺省（除非有些元素比如类明确要求提供初始值）<br>
所以vector<int> v1{10，1}和vector<int> v1（10，1）意思完全不一样<br>
圆括号不能用于列表初始化，但是花括号也可以进行直接初始化 vector<string> v1{10} vector<string> v1{10，“hi”}都是<strong>合法</strong>的 因为10无法作为元素初始值<br>
可以使用数组来初始化vector，需提供首元素地址和尾后地址，比如vecor<int> i (begin(arr),end(arr));<br>
vector<T> v(n)值初始化：**只提供对象容纳的元素数量而不用略去初始值，**此时库会创建一个值初始化的元素处置，并赋给容器中的所有元素，元素初值由元素类型决定</p>
<pre><code>习题3.12
a合法，空vector；b不合法，类型不匹配；c合法，10个“null”
习题3.13
</code></pre>
<p>（a）0<br>
（b）10,0<br>
（c）10,42<br>
（d）1,10<br>
（e）2,10和42<br>
（f）10，空<br>
（g）10，“hi”</p>
<p>3.3.2<br>
vector对象使用直接初始化的情况 1.初始值已知并较少 2.初始值是另外一个vector的副本 3.所有元素的初始值一样<br>
一般先创建一个空vector对象，再用<strong>push_back</strong>向其中添加元素<br>
重点知识：上述初始化的原因是vector对象能够高效增长，<strong>不需要提前定义长度</strong><br>
不能使用** 范围for 循环语句**对vector对象添加元素<br>
原因：范围for语句预先预定了迭代器end的位置，添加元素会导致end不断变化（STL剖析的解释：vector扩展空间并不是单纯地在内存下一段继续添加，而是必须alloc新的内存，再把原来的vector元素全部搬过去）</p>
<pre><code>习题3.14
</code></pre>
<pre><code>	int main() {
int i;
	vector&lt;int&gt; v_i;
	while (cin &gt;&gt;i)
		v_i.push_back(i);
	for (auto i : v_i)
		cout &lt;&lt; i &lt;&lt; ' ';
};
</code></pre>
<pre><code>习题3.15
</code></pre>
<pre><code>int main() {
	string s;
	vector&lt;string&gt; v_s;
	while (cin &gt;&gt; s)
		v_s.push_back(s);
	for (auto s : v_s)
		cout &lt;&lt; s &lt;&lt; ' ';
};
</code></pre>
<p>3.3.3<br>
vector.size() 返回的类型是** vectot<int>::size_type** 与string有区别<br>
vector对象能否比较决定于元素的类型 如类类型不一定能比较<br>
vector<strong>不能用下标形式向空vector添加元素 只能用push_back</strong><br>
缓冲区溢出：编译器无法发现通过下标访问不存在元素的错误 避免方法”：尽可能使用 范围for语句</p>
<pre><code>习题3.16
</code></pre>
<pre><code>	int main() {
	vector&lt;string&gt; v;
	cout &lt;&lt; v.size() &lt;&lt; endl;
	for (auto s : v)
		cout &lt;&lt; s &lt;&lt; ' ';
};
</code></pre>
<pre><code>习题3.17
</code></pre>
<pre><code>	int main() {
	vector&lt;string&gt; v_s ;
	string s;
	while (cin &gt;&gt; s)
		v_s.push_back(s);
	for (auto &amp;s : v_s)
		for (auto &amp;e : s)
			if (islower(e))
				e = toupper(e);
	for (auto s : v_s)
			cout &lt;&lt; s &lt;&lt; ' ';
};
</code></pre>
<pre><code>习题3.18
错误的，汇报运行时错误，必须用push_back添加元素
习题3.19
```
</code></pre>
<p>vector<int>i1{42,42,42,42,42,42,42,42,42,42};<br>
vector<int>i2(10,42);<br>
vector<int>i3=i2;</p>
<pre><code>	习题3.20
</code></pre>
<pre><code>int main() {
vector&lt;int&gt; v_i;
int i;
while (cin &gt;&gt; i)
	v_i.push_back(i);
for (int x = 0; x &lt; v_i.size()-1; ++x)
	cout &lt;&lt; v_i[x] + v_i[x + 1] &lt;&lt; ' ';
cout &lt;&lt; endl;
for (int x = 0,l = v_i.size(); x &lt;  (v_i.size()+1)/2; ++x)
	cout &lt;&lt; v_i[x] + v_i[l-1-x] &lt;&lt; ' ';
</code></pre>
<p>};</p>
<pre><code>	
3.4.1
具有迭代器的类型同时拥有返回迭代器的成员 例如begin 和 end
迭代器是容器所用，不是模板
begin 负责返回指向第一个元素的迭代器 end 负责返回指向容器“**尾元素的下一位置**”的迭代器 等于指向一个本不存在的“尾后”元素 称尾后迭代器
如果容器为空 begin和end返回统一迭代器 尾后迭代器
我们并不知道迭代器的准确类型 所以**定义时应该使用auto**
对于end不能++或—
迭代器类型 iterator或const_iterator 后者只能读不能写
begin 和 end 返回的迭代器类型取决于是否是常量
用cbegin和cend可以强行返回const_iterator
通过解引用访问迭代器指向的类的成员时 (*it).empty() 圆括号必不可少
或者使用it-&gt;empty（）
vector的push_back功能可能会使迭代器失效（stl的解释：vector的扩增capacity需要在新内存中进行复制粘贴，而迭代器本质是一个特定地址的指针）

习题3.21
	`
	int main() {
	vector&lt;int&gt; v{1,2,3,4,5,6};
	cout &lt;&lt; v.size() &lt;&lt; endl;
	for (auto i = v.begin();i!=v.end();++i)
		cout &lt;&lt; *i &lt;&lt; ' ';
};
`
	习题3.22
	`int main(){
	string text{ &quot;AbdGGasjd&quot; };
	for (auto &amp;i = text.begin(); i != text.end(); ++i)
	{
		*i = toupper(*i);
		cout &lt;&lt; *i ;
	}
};`
	习题3.23
</code></pre>
<pre><code>int main(){
vector&lt;int&gt; vi(10, 10);
for (auto &amp;i = vi.begin(); i != vi.end(); ++i)
	*i = *i * 2;
for (auto &amp;i = vi.begin(); i != vi.end(); ++i)
cout &lt;&lt; *i &lt;&lt;endl;
</code></pre>
<p>};</p>
<pre><code>	
3.4.2
	注意不能iter1+iter1
注意迭代器向前移动的概念 也就是向右移动
两个迭代器相减 得到类型为difference_type的带符号整型数
**交换两个迭代器的元素 iter_swap!!!**
习题3.24
	`int main() {
	vector&lt;int&gt; v_i;
	int i;
	while (cin &gt;&gt; i)
		v_i.push_back(i);
	for(auto ib=v_i.begin() ; ib!= v_i.end()-1; ++ib)
		cout &lt;&lt; *ib + *(ib+1) &lt;&lt; ' ';
	cout &lt;&lt; endl;
	for (auto ib = v_i.begin(),ie = v_i.end(); ie - ib&gt;0; ++ib)
		cout &lt;&lt; *ib + *(--ie) &lt;&lt; ' ';
};
`
	习题3.25
</code></pre>
<pre><code>int main() {
vector&lt;unsigned&gt; scores(11,0);
unsigned grade;
auto i = scores.begin();
while (cin &gt;&gt; grade) 
	if (grade &lt;= 100)
		++*(i + grade / 10);
for (auto i : scores)
	cout &lt;&lt; i &lt;&lt; ' ';
</code></pre>
<p>};</p>
<pre><code>								 
	习题3.26
	迭代器虽然支持相减，但是是不支持相加的！
	

	

习题感悟：
	string.size（）必须有括号
	必须检查string是否为空
	可以多看看自带的函数表（比如string的标点判断ispunct）
	c++中eof的键盘输入为windows Ctrl+Z linux  Ctrl+d（似乎是受编译器影响），用于结束while（cin&gt;&gt;string）
toupper(e) 返回char e的大写形式
迭代器是容器所用，不是模板
	字符串数组char text[]
迭代器向中间靠拢时，可以用 v_i.end()-v_i.begin()&gt;0来判断是否到了中位值</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux（Ubuntu）避坑]]></title>
        <id>https://lixin-ee.github.io//post/linuxubuntubi-keng</id>
        <link href="https://lixin-ee.github.io//post/linuxubuntubi-keng">
        </link>
        <updated>2019-09-05T01:48:18.000Z</updated>
        <content type="html"><![CDATA[<p>用su - 切换到root，输入密码提示认证失败。经查阅原来Ubuntu安装后，root用户默认是被锁定了的，不允许登录，也不允许 su 到 root<br>
终端下</p>
<p>lixin@lixin:~$ sudo passwd<br>
Password: &lt;--- 输入安装时那个用户的密码<br>
Enter new UNIX password: &lt;--- 新的Root用户密码<br>
Retype new UNIX password: &lt;--- 重复新的Root用户密码<br>
passwd：已成功更新密码</p>
]]></content>
    </entry>
</feed>