<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-03-28T02:12:35.638Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>千里之行，始于足下。不积跬步，无以至千里。</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[DFS 695. 岛屿的最大面积[中等]]]></title>
        <id>https://lixin-scut.github.io//post/dfs-695-dao-yu-de-zui-da-mian-ji-zhong-deng</id>
        <link href="https://lixin-scut.github.io//post/dfs-695-dao-yu-de-zui-da-mian-ji-zhong-deng">
        </link>
        <updated>2020-03-27T14:06:36.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>给定一个包含了一些 0 和 1 的非空二维数组 grid 。<br>
一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。<br>
找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)<br>
示例 1:<br>
[[0,0,1,0,0,0,0,1,0,0,0,0,0],<br>
[0,0,0,0,0,0,0,1,1,1,0,0,0],<br>
[0,1,1,0,1,0,0,0,0,0,0,0,0],<br>
[0,1,0,0,1,1,0,0,1,0,1,0,0],<br>
[0,1,0,0,1,1,0,0,1,1,1,0,0],<br>
[0,0,0,0,0,0,0,0,0,0,1,0,0],<br>
[0,0,0,0,0,0,0,1,1,1,0,0,0],<br>
[0,0,0,0,0,0,0,1,1,0,0,0,0]]<br>
对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。<br>
示例 2:<br>
[[0,0,0,0,0,0,0,0]]<br>
对于上面这个给定的矩阵, 返回 0。<br>
注意: 给定的矩阵grid 的长度和宽度都不超过 50。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/max-area-of-island<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>一开始感觉比较像是动态规划的累积问题<br>
但是有个问题是 示例1中，如果只考虑当前格的左边和上边的话，会导致重复考虑</p>
<p>所以我第二个想法是直接DFS并用visited数组保存已探测的格子<br>
注意怎么样通过修改函数返回值从而不断缩减函数的参数</p>
<pre><code>class Solution {
public:
    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        if(grid.empty())
        {   return 0; }
        int rowSize = grid.size();
        int colSize = grid[0].size();
        
        vector&lt;vector&lt;bool&gt;&gt; visited(rowSize, vector&lt;bool&gt;(colSize, false));
        int ans = 0;

        for(int row = 0; row &lt; rowSize; ++row)
        {
            for(int col = 0; col &lt; colSize; ++col)
            {
                int temp = maxAreaOfIsland(grid, visited, row, col);
                ans = temp &gt; ans ? temp : ans;
            }
        }
        
        return ans;
    }
    
    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid,
                         vector&lt;vector&lt;bool&gt;&gt;&amp; visited,
                         int row,
                         int col)
    {
        
        if(row &gt;= grid.size() || col &gt;= grid[0].size() 
           || visited[row][col])
        {   return 0; }
        
        visited[row][col] = true;
        
        if(grid[row][col] == 0)
        {   return 0;}
        
        return 1 + maxAreaOfIsland(grid,visited,row-1,col)
                + maxAreaOfIsland(grid,visited,row,col-1)
                + maxAreaOfIsland(grid,visited,row+1,col)
                + maxAreaOfIsland(grid,visited,row,col+1);
    }
    
};
</code></pre>
<p>官方题解：<br>
官方题解有个很妙的地方，就是因为数组不需要追溯过往状态，所以访问过的位置可以直接修改置0，从而避免了使用额外的visited数组记录访问状态。</p>
<blockquote>
<p>方法一：深度优先搜索<br>
算法<br>
我们想知道网格中每个连通形状的面积，然后取最大值。<br>
如果我们在一个土地上，以 4 个方向探索与之相连的每一个土地（以及与这些土地相连的土地），那么探索过的土地总数将是该连通形状的面积。<br>
为了确保每个土地访问不超过一次，我们每次经过一块土地时，将这块土地的值置为 0。这样我们就不会多次访问同一土地。</p>
</blockquote>
<pre><code>class Solution {
    int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int cur_i, int cur_j) {
        if (cur_i &lt; 0 || cur_j &lt; 0 || cur_i == grid.size() || cur_j == grid[0].size() || grid[cur_i][cur_j] != 1)
            return 0;
        grid[cur_i][cur_j] = 0;
        int di[4] = {0, 0, 1, -1};
        int dj[4] = {1, -1, 0, 0};
        int ans = 1;
        for (int index = 0; index != 4; ++index) {
            int next_i = cur_i + di[index], next_j = cur_j + dj[index];
            ans += dfs(grid, next_i, next_j);
        }
        return ans;
    }
public:
    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int ans = 0;
        for (int i = 0; i != grid.size(); ++i)
            for (int j = 0; j != grid[0].size(); ++j)
                ans = max(ans, dfs(grid, i, j));
        return ans;
    }
};
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(R∗C)。其中R 是给定网格中的行数，C 是列数。我们访问每个网格最多一次。<br>
空间复杂度：O(R∗C)，递归的深度最大可能是整个网格的大小，因此最大可能使用 O(R∗C) 的栈空间。</p>
</blockquote>
<blockquote>
<p>方法二：深度优先搜索 + 栈<br>
算法<br>
我们可以用栈来实现深度优先搜索算法。这种方法本质与方法一相同，唯一的区别是：<br>
方法一通过函数的调用来表示接下来想要遍历哪些土地，让下一层函数来访问这些土地。而方法二把接下来想要遍历的土地放在栈里，然后在取出这些土地的时候访问它们。<br>
访问每一片土地时，我们将对围绕它四个方向进行探索，找到还未访问的土地，加入到栈 stack 中；<br>
另外，只要栈 stack 不为空，就说明我们还有土地待访问，那么就从栈中取出一个元素并访问。</p>
</blockquote>
<pre><code>class Solution {
public:
    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int ans = 0;
        for (int i = 0; i != grid.size(); ++i)
            for (int j = 0; j != grid[0].size(); ++j) {
                int cur = 0;
                stack&lt;int&gt; stacki;
                stack&lt;int&gt; stackj;
                stacki.push(i);
                stackj.push(j);
                while (!stacki.empty()) {
                    int cur_i = stacki.top(), cur_j = stackj.top();
                    stacki.pop();
                    stackj.pop();
                    if (cur_i &lt; 0 || cur_j &lt; 0 || cur_i == grid.size() || cur_j == grid[0].size() || grid[cur_i][cur_j] != 1)
                        continue;
                    ++cur;
                    grid[cur_i][cur_j] = 0;
                    int di[4] = {0, 0, 1, -1};
                    int dj[4] = {1, -1, 0, 0};
                    for (int index = 0; index != 4; ++index) {
                        int next_i = cur_i + di[index], next_j = cur_j + dj[index];
                        stacki.push(next_i);
                        stackj.push(next_j);
                    }
                }
                ans = max(ans, cur);
            }
        return ans;
    }
};
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(R∗C)。其中R 是给定网格中的行数，C 是列数。我们访问每个网格最多一次。<br>
空间复杂度：O(R∗C)，栈中最多会存放所有的土地，土地的数量最多为R∗C 块，因此使用的空间为 O(R∗C)。</p>
</blockquote>
<blockquote>
<p>方法三：广度优先搜索<br>
算法<br>
我们把方法二中的栈改为队列，每次从队首取出土地，并将接下来想要遍历的土地放在队尾，就实现了广度优先搜索算法。</p>
</blockquote>
<pre><code>class Solution {
public:
    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int ans = 0;
        for (int i = 0; i != grid.size(); ++i)
            for (int j = 0; j != grid[0].size(); ++j) {
                int cur = 0;
                queue&lt;int&gt; queuei;
                queue&lt;int&gt; queuej;
                queuei.push(i);
                queuej.push(j);
                while (!queuei.empty()) {
                    int cur_i = queuei.front(), cur_j = queuej.front();
                    queuei.pop();
                    queuej.pop();
                    if (cur_i &lt; 0 || cur_j &lt; 0 || cur_i == grid.size() || cur_j == grid[0].size() || grid[cur_i][cur_j] != 1)
                        continue;
                    ++cur;
                    grid[cur_i][cur_j] = 0;
                    int di[4] = {0, 0, 1, -1};
                    int dj[4] = {1, -1, 0, 0};
                    for (int index = 0; index != 4; ++index) {
                        int next_i = cur_i + di[index], next_j = cur_j + dj[index];
                        queuei.push(next_i);
                        queuej.push(next_j);
                    }
                }
                ans = max(ans, cur);
            }
        return ans;
    }
};
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(R∗C)。其中 R 是给定网格中的行数，C 是列数。我们访问每个网格最多一次。<br>
空间复杂度：O(R∗C)，队列中最多会存放所有的土地，土地的数量最多为 R∗C 块，因此使用的空间为 O(R∗C)。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机网络体系分层层次]]></title>
        <id>https://lixin-scut.github.io//post/ji-suan-ji-wang-luo-ti-xi-fen-ceng</id>
        <link href="https://lixin-scut.github.io//post/ji-suan-ji-wang-luo-ti-xi-fen-ceng">
        </link>
        <updated>2020-03-26T09:15:15.000Z</updated>
        <content type="html"><![CDATA[<h3 id="分层概念">分层概念</h3>
<p>  每层通过在该层中执行某些动作或使用直接下层的服务来提供服务，例如由第n层提供的服务可能包括报文从网络的一边到另一边的可靠传送，这可能是通过使用第n-1层的边缘到边缘的不可靠报文传送服务，加上第n层的检测和重传丢失报文的功能来实现的。<br>
  一个协议层能够用软件、硬件或两者的结合来实现。诸如HTTP和SMTP这样的应用层协议几乎总是在端系统中用软件实现的，运输层协议也是如此，因为物理层和数据链路层负责处理跨越特定链路的通信，它们通常是实现在与给定链路相联系的网络接口卡（例如以太网或WiFi接口卡）中，网络层经常是硬件和软件实现的混合体</p>
<h3 id="优缺点">优缺点</h3>
<p><strong>优点：</strong><br>
  协议分层具有概念化和结构化的优点<br>
  采用多层是有益的,通过分层, 每层只负责通信的一个方面。互联网络的目标之一是对应用隐藏所有关于物理布局( 拓扑) 和低层协议的异构性的细 节，分层设计允许开发人员分别实现系统的不同部分, 它们通常由在不同领域的专业人员完成。<br>
  分层体系结构的另一个主要优点是具有协议复用的能力。这种复用形式允许多种协议共存于同一基础设施中。它也允许相同协议对象( 例如连接) 的多个实例同时存在, 并且不会被混淆。</p>
<p><strong>缺点：</strong><br>
  分层的一个潜在缺点是一层可能冗余较低层的功能<br>
  第二种潜在的缺点是某层的功能可能需要仅在其他某层才出现的信息</p>
<p>  因特网的协议栈由5个层次组成：<strong>物理层、链路层、网络层、运输层和应用层</strong><br>
  OSI参考模型的7层是：<strong>应用层、表示层、会话层</strong>，运输层，网络层，数据链路层和物理层<br>
<img src="https://lixin-scut.github.io//post-images/1585214284826.png" alt=""></p>
<p>(1)应用层<br>
  应用层是网络应用程序及它们的应用层协议存留的地方，因特网的用层包括许多协议，例如HTTP，SMTP(它提供了电子邮件报文的传输）和FTP(它提供两个端系统之间的文件传送）。我们将看到某些网络功能，如将像www这样对人友好的端系统名字转换为32比特网络地址<br>
  应用层的信息分组称为<strong>报文（message)</strong><br>
(2)运输层<br>
  因特网的运输层在应用程序端点之间传送应用层报文在因特网中，有两个运输协议.<br>
即TCP和UDP<br>
  TCP向它的应用程序提供了面向连接的服务，包括了应用层报文向目的地的确保传递和流量控制（即发送方/接收方速率匹配），TCP也将长报文划分为短报文.并提供拥塞控制机制，因此当网络拥塞时，源抑制其传输速率.<br>
  UDP协议向它的应用程序提供无连接服务，这是一种不提供不必要服务的服务，没有可靠性.没有流量控制.也没有拥塞控制在本书中.<br>
  我们把运输层分组称为<strong>报文段（segment)。</strong><br>
(3)网络层<br>
  因特网的网络层负责将称为<strong>数据报（datagnim)</strong><br>
  网络层分组从一台主机移动到另一台主机.在一台源主机中的因特网运输层协议（TCP或UDP)向网络层递交运输层报文段和目的地址，就像你通过邮政服务寄信件时提供一个目的地址一样<br>
  因特网的网络层包括著名的IP协议，该协议定义了在数据报中的各个字段以及端系统和路由器如何作用于这些字段<br>
  网络层包括了IP协议和一些路由选择协议，但通常把它简单地称为IP层.这反映IP是将因特网连接在一起的粘合剂这样的事实<br>
(4)链路层<br>
  因特网的网络层通过源和目的地之间的一系列路由器路由数据报，为了将分组从一个结点（主机或路由器）移动到路径上的下一个结点，网络层必须依靠该链路层的服务，特別是在每个结点.网络层将数据报下传给链路层.链路层沿着路径将数据报传递给下一个结点。在下个结点，链路层将数据报上传给网络层，<br>
  我们把链路层分组称为<strong>帧(frame)</strong><br>
(5)物理层<br>
  虽然链路层的任务是将整个帧从一个网络元素移动到邻近的网络元素.而物理层的任务是将该帧中的一个一个比特从一个结点移动到下一个结点，</p>
<h3 id="各层次包含的协议">各层次包含的协议：</h3>
<p>应用层：<br>
HTTP DNS</p>
<p>运输层：<br>
TCP UDP ICMP</p>
<p>网络层：<br>
IP<br>
路由选择算法</p>
<p>链路层：</p>
<p>物理层：</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 494. 目标和[中等][未做出]]]></title>
        <id>https://lixin-scut.github.io//post/dong-tai-gui-hua-494-mu-biao-he-zhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/dong-tai-gui-hua-494-mu-biao-he-zhong-deng-wei-zuo-chu">
        </link>
        <updated>2020-03-26T04:44:24.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。<br>
返回可以使最终数组和为目标数 S 的所有添加符号的方法数。<br>
示例 1:<br>
输入: nums: [1, 1, 1, 1, 1], S: 3<br>
输出: 5<br>
解释:<br>
-1+1+1+1+1 = 3<br>
+1-1+1+1+1 = 3<br>
+1+1-1+1+1 = 3<br>
+1+1+1-1+1 = 3<br>
+1+1+1+1-1 = 3<br>
一共有5种方法让最终目标和为3。<br>
注意:<br>
数组非空，且长度不会超过20。<br>
初始的数组的和不会超过1000。<br>
保证返回的最终结果能被32位整数存下。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/target-sum<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>我本来想用动态规划，但是可能的情况似乎不断增加<br>
看了题解的动态规划法，原来是需要先转化为背包问题的<br>
时间复杂度：O(N∗sum)，其中 N 是数组 nums 的长度。<br>
空间复杂度：O(sum)</p>
<p>然后想到了回溯递归法<br>
出现的问题<br>
1.if(0 == S)必须判断<br>
2.溢出问题。。。这个我没啥特别好的办法。。。只能先把int 改成 long了<br>
复杂度分析<br>
时间复杂度：O(2^N)，其中 N 是数组 nums 的长度。<br>
空间复杂度：O(N)，为递归使用的栈空间大小。</p>
<p>还有位运算法<br>
尴尬，位运算法超时了。。。因为必须逐位循环，时间复杂度在O(2^N)再套一个length</p>
<pre><code>class Solution {
public:
    // 动态规划
    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S)
    {
        int sum = 0;
        for(auto num : nums)
        {
            sum += num;
        }
        // 这里的判断很重要，排除极端情况和无法整除的情况
        if((sum &gt; 0 &amp;&amp; S &gt; sum) || (sum &lt; 0 &amp;&amp; S &lt; sum) || (sum + S) % 2 == 1) 
        {   return 0; }
        int target = (sum + S) / 2; 
        
        // 我直接优化了空间，注意必须从后往前更新，否则会不断叠加，然后原始是需要加上nums的一维
        vector&lt;int&gt; sumDP(target + 1, 0);
        sumDP[0] = 1;
        for(auto num : nums)
        {
            for(int i = target; i &gt;= 0; --i)
            {
                if(i - num &gt;=0)
                {
                    sumDP[i] += sumDP[i - num];
                }
            }
        }
        return sumDP.back();
    }
    /*
    // 超时
    // 位运算法
    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S)
    {
        int ways = 0;
        long res;
        int len = nums.size();
        int ans = 0;
        while(ways &lt; pow(2, len))
        {
            int bit = 1;
            res = 0;
            for(int i = 0; i &lt; len ; ++i)
            {
                if(ways &amp; (bit &lt;&lt; i))
                {
                    res += static_cast&lt;long&gt;(nums[i]);
                }
                else
                {
                    res -= static_cast&lt;long&gt;(nums[i]);
                }
            }
            if(static_cast&lt;int&gt;(res) == S)
            { ++ans; }
            ++ways;
        }
        return ans;
    }
    
    // 回溯递归法
    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) {
        int ans = 0;
        findTargetSumWays(nums, S, 0, ans);
        return ans;
    }
    
    void findTargetSumWays(vector&lt;int&gt;&amp; nums, long S, int num, int&amp; ans)
    {
        if(num == nums.size() )
        {   
            // 必须单独判断
            if(0 == S)
            {    
                ++ans;
            }
            return;
        }
        
        // 不要用++num
        findTargetSumWays(nums, S+nums[num], num + 1, ans);
        findTargetSumWays(nums, S-nums[num], num + 1, ans);
    }
    */
};
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>暴力解法<br>
暴力解法就是dfs了，这道题而言，暴力解法是完全可以的，而且不会超时，因为题目中说了数组长度不会超过20，20个数字的序列，组合方式撑死了2^20种，算下来才1024×1024<br>
也就是说，可以把数组中每个数字前面都用负号和正号，然后进行组合的求和，并判断这个和是否会等于S，然后就标记，最后统计出等于S的组合个数就好了。<br>
具体使用dfs，就是一个前序遍历二叉树的实现，递归地+或-每个元素，到所有元素都遍历完成的时候，最后那个判断target是否等于零。</p>
</blockquote>
<pre><code>class Solution {
public:
    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) {
        return dfs(nums, S, 0);
    }

    int dfs(vector&lt;int&gt; &amp;nums, uint target, int left) {
        if (target == 0 &amp;&amp; left == nums.size()) return 1;
        if (left &gt;= nums.size()) return 0;
        int ans = 0;
        ans += dfs(nums, target - nums[left], left + 1);
        ans += dfs(nums, target + nums[left], left + 1);
        return ans;
    }
};
</code></pre>
<blockquote>
<p>01背包<br>
本题解参考热评解法<br>
01背包其实不是这种解法的重点，重点是怎么把题目转化成求解01背包的形式。<br>
如果只是单纯的求解和为某个S的组合个数，那就是01背包。。。<br>
但是这题目中不仅有加，还有减，就得进行一个转化了。<br>
思路就是把整个集合看成两个子集，Q表示整个集合，P表示正数子集，N表示负数子集， T表示目标和，用S(X)表示集合的求和函数，集合中均为非负数，N集合是指选中这部分元素作为负数子集。</p>
</blockquote>
<pre><code>S(P)−S(N)=T
S(P)+S(N)+S(P)−S(N)=T+S(P)+S(N)
2S(P)=S(Q)+T
</code></pre>
<blockquote>
<p>也就是：正数集的和的两倍 == 等于目标和 + 序列总和<br>
所以问题就转换成了，找到一个正数集P，其和的两倍等于目标和+序列总和。。。<br>
简单吧，完全就是01背包了嘛！！！<br>
对于01背包，其实我都差不多背下来了，你会发现背了以后，写着写着，就理解了。<br>
需要注意的是，虽然序列总和不超过1000，但是S可是会接近int的上界。。。很容易出现超过整型范围的操作。</p>
</blockquote>
<pre><code>class Solution {
public:
    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) {
        long sum = 0;
        for (const int &amp;it : nums) sum += it;
        if ((S + sum) % 2 == 1 || S &gt; sum) return 0;
        S = (S + sum) / 2;
        int *dp = new int[S + 1];
        memset(dp, 0, (S + 1) * sizeof(int));
        dp[0] = 1;
        for (const int &amp;it : nums) {
            for (int j = S; j &gt;= it; j--)
                dp[j] += dp[j - it];
        }
        int ans = dp[S];
        delete[] dp;
        return ans;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 494. 目标和[中等]]]></title>
        <id>https://lixin-scut.github.io//post/dong-tai-gui-hua-494-mu-biao-he-zhong-deng</id>
        <link href="https://lixin-scut.github.io//post/dong-tai-gui-hua-494-mu-biao-he-zhong-deng">
        </link>
        <updated>2020-03-26T04:44:24.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。<br>
返回可以使最终数组和为目标数 S 的所有添加符号的方法数。<br>
示例 1:<br>
输入: nums: [1, 1, 1, 1, 1], S: 3<br>
输出: 5<br>
解释:<br>
-1+1+1+1+1 = 3<br>
+1-1+1+1+1 = 3<br>
+1+1-1+1+1 = 3<br>
+1+1+1-1+1 = 3<br>
+1+1+1+1-1 = 3<br>
一共有5种方法让最终目标和为3。<br>
注意:<br>
数组非空，且长度不会超过20。<br>
初始的数组的和不会超过1000。<br>
保证返回的最终结果能被32位整数存下。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/target-sum<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>我本来想用动态规划，但是可能的情况似乎不断增加<br>
看了题解的动态规划法，原来是需要先转化为背包问题的</p>
<p>然后想到了回溯递归法<br>
出现的问题<br>
1.if(0 == S)必须判断<br>
2.溢出问题。。。这个我没啥特别好的办法。。。只能先把int 改成 long了</p>
<p>还有位运算法<br>
尴尬，位运算法超时了。。。因为必须逐位循环。</p>
<pre><code>class Solution {
public:
    // 动态规划
    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S)
    {
        int sum = 0;
        for(auto num : nums)
        {
            sum += num;
        }
        // 这里的判断很重要，排除极端情况和无法整除的情况
        if((sum &gt; 0 &amp;&amp; S &gt; sum) || (sum &lt; 0 &amp;&amp; S &lt; sum) || (sum + S) % 2 == 1) 
        {   return 0; }
        int target = (sum + S) / 2; 
        
        // 我直接优化了空间，注意必须从后往前更新，否则会不断叠加，然后原始是需要加上nums的一维
        vector&lt;int&gt; sumDP(target + 1, 0);
        sumDP[0] = 1;
        for(auto num : nums)
        {
            for(int i = target; i &gt;= 0; --i)
            {
                if(i - num &gt;=0)
                {
                    sumDP[i] += sumDP[i - num];
                }
            }
        }
        return sumDP.back();
    }
    /*
    // 超时
    // 位运算法
    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S)
    {
        int ways = 0;
        long res;
        int len = nums.size();
        int ans = 0;
        while(ways &lt; pow(2, len))
        {
            int bit = 1;
            res = 0;
            for(int i = 0; i &lt; len ; ++i)
            {
                if(ways &amp; (bit &lt;&lt; i))
                {
                    res += static_cast&lt;long&gt;(nums[i]);
                }
                else
                {
                    res -= static_cast&lt;long&gt;(nums[i]);
                }
            }
            if(static_cast&lt;int&gt;(res) == S)
            { ++ans; }
            ++ways;
        }
        return ans;
    }
    
    // 回溯递归法
    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) {
        int ans = 0;
        findTargetSumWays(nums, S, 0, ans);
        return ans;
    }
    
    void findTargetSumWays(vector&lt;int&gt;&amp; nums, long S, int num, int&amp; ans)
    {
        if(num == nums.size() )
        {   
            // 必须单独判断
            if(0 == S)
            {    
                ++ans;
            }
            return;
        }
        
        // 不要用++num
        findTargetSumWays(nums, S+nums[num], num + 1, ans);
        findTargetSumWays(nums, S-nums[num], num + 1, ans);
    }
    */
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 416. 分割等和子集[中等][未做出]]]></title>
        <id>https://lixin-scut.github.io//post/dong-tai-gui-hua-416-fen-ge-deng-he-zi-ji</id>
        <link href="https://lixin-scut.github.io//post/dong-tai-gui-hua-416-fen-ge-deng-he-zi-ji">
        </link>
        <updated>2020-03-25T00:24:36.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。<br>
注意:<br>
每个数组中的元素不会超过 100<br>
数组的大小不会超过 200<br>
示例 1:<br>
输入: [1, 5, 11, 5]<br>
输出: true<br>
解释: 数组可以分割成 [1, 5, 5] 和 [11].<br>
示例 2:<br>
输入: [1, 2, 3, 5]<br>
输出: false<br>
解释: 数组不能分割成两个元素和相等的子集.<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/partition-equal-subset-sum<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>【未做出】<br>
这道题可以视为有两个背包<br>
一个数只有两种状态，放在第一个背包或者放在第二个背包，用0和1表示<br>
然后用两者的差值<br>
重点在于状态转移方程</p>
<p>最后还是看了题解，把能否达到某个sum的boolean值作为第二维<br>
然后不断地从已有的sum加上当前num，更新可以达到的sum<br>
最终检测是否能够达到target</p>
<p>需要注意的点：</p>
<ol>
<li>当前num是否大于target</li>
<li>等于时可以直接返回</li>
<li>一开始可以检查总的sum是否为奇数，奇数不可能对分</li>
<li><code>sumDP[0][0]</code>需要初始化为true</li>
</ol>
<pre><code>class Solution {
public:
    // 动态规划：空间压缩
    bool canPartition(vector&lt;int&gt;&amp; nums) 
    {
        int sum = 0;
        for(auto num : nums)
        {
            sum += num;
        }
        if(sum % 2 == 1)
        {   return false; }
        
        int target = sum / 2;
        int length = nums.size();
        vector&lt;bool&gt; sumDP(target + 1, false);
        
        sumDP[0] = true;
        if(nums[0] &lt;= target)
        {   
            sumDP[nums[0]] = true;
        }
        
        for(int num = 1; num &lt; length; ++num)
        {
            for(int sum = target; sum &gt;= 0; --sum)
            {
                if(nums[num] == target)
                {
                        return true;
                }
                if(sum &gt; nums[num] )
                {
                    sumDP[sum] = sumDP[sum] || sumDP[sum - nums[num]];
                }
            }
        }
        
        return sumDP[target];
    }
    
    /*
    // 动态规划
    bool canPartition(vector&lt;int&gt;&amp; nums) 
    {
        int sum = 0;
        for(auto num : nums)
        {
            sum += num;
        }
        if(sum % 2 == 1)
        {   return false; }
        
        int target = sum / 2;
        int length = nums.size();
        vector&lt;vector&lt;bool&gt;&gt; sumDP(length, vector&lt;int&gt;(target + 1, false));
        
        
        sumDP[0][0] = true;
        if(nums[0] &lt;= target)
        {   sumDP[0][nums[0]] = true;}
        
        for(int num = 1; num &lt; length; ++num)
        {
            for(int sum = 0; sum &lt; target + 1; ++sum)
            {
                sumDP[num][sum] = sumDP[num-1][sum];
                if(nums[num] == target)
                {
                    return true;
                }
                if(sum &gt; nums[num] )
                {
                    sumDP[num][sum] = sumDP[num - 1][sum] || sumDP[num - 1][sum - nums[num]];
                }
            }
        }
        return sumDP[length - 1][target];
    }
    */
};
</code></pre>
<p>网友题解</p>
<blockquote>
<p>事实上，这是一个典型的“动态规划”问题，并且它的“原形”是“0-1 背包问题”。使用“动态规划”解决问题的思路是“以空间换时间”，“规划”这个词在英文中就是“填表格”的意思，代码执行的过程，也可以称之为“填表格”。<br>
“动态规划”的方法可以认为是为我们提供了一个思考问题的方向，我们不是直接面对问题求解，而是去找原始问题（或者说和原始问题相关的问题）的最开始的样子，通过“状态转移方程”（这里没法再解释了，可以结合下文理解）记录下每一步求解的结果，直到最终问题解决。<br>
而直接面对问题求解，就是我们熟悉的“递归”方法，由于有大量重复子问题，我们就需要加缓存，这叫“记忆化递归”，这里就不给参考代码了，感兴趣的朋友可以自己写一下，比较一下它们两种思考方式的不同之处和优缺点。<br>
做这道题需要做这样一个等价转换：是否可以从这个数组中挑选出一些正整数，使得这些数的和等于整个数组元素的和的一半。前提条件是：数组的和一定得是偶数，即数组的和一定得被 2 整除，这一点是特判。</p>
</blockquote>
<blockquote>
<p>本题与 0-1 背包问题有一个很大的不同，即：<br>
0-1 背包问题选取的物品的容积总量不能超过规定的总量；<br>
本题选取的数字之和需要恰恰好等于规定的和的一半。<br>
这一点区别，决定了在初始化的时候，所有的值应该初始化为 false。 （《背包九讲》的作者在介绍 0-1 背包问题的时候，有强调过这点区别，我在这里也只是再重复一下。）<br>
作为“0-1 背包问题”，它的特点是：“每个数只能用一次”。思路是：物品一个一个选，容量也一点一点放大考虑（这一点是“动态规划”的思想，特别重要）。<br>
如果在实际生活中，其实我们也是这样做的，一个一个尝试把候选物品放入“背包”，看什么时候能容纳的价值最大。<br>
具体做法是：画一个 len 行，target + 1 列的表格。这里 len 是物品的个数，target 是背包的容量。len 行表示一个一个物品考虑，target + 1多出来的那 1 列，表示背包容量从 0 开始，很多时候，我们需要考虑这个容量为 0 的数值。<br>
状态定义：dp[i][j]表示从数组的 [0, i] 这个子区间内挑选一些正整数，每个数只能用一次，使得这些数的和恰好等于 j。<br>
状态转移方程：很多时候，状态转移方程思考的角度是“分类讨论”，对于“0-1 背包问题”而言就是“当前考虑到的数字选与不选”。<br>
1、不选择 nums[i]，如果在 [0, i - 1] 这个子区间内已经有一部分元素，使得它们的和为 j ，那么 dp[i][j] = true；<br>
2、选择 nums[i]，如果在 [0, i - 1] 这个子区间内就得找到一部分元素，使得它们的和为 j - nums[i]。<br>
状态转移方程是：<br>
dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i]]<br>
一般写出状态转移方程以后，就需要考虑边界条件（一般而言也是初始化条件）。<br>
1、j - nums[i] 作为数组的下标，一定得保证大于等于 0 ，因此 nums[i] &lt;= j；<br>
2、注意到一种非常特殊的情况：j 恰好等于 nums[i]，即单独 nums[j] 这个数恰好等于此时“背包的容积” j，这也是符合题意的。<br>
因此完整的状态转移方程是：<br>
dp[i][j]=<br>
dp[i−1][j],   至少是这个答案，如果 dp[i−1][j] 为真，直接计算下一个状态<br>
true,  nums[i] = j<br>
dp[i−1][j−nums[i]],  nums[i] &lt; j<br>
说明：虽然写成花括号，但是它们的关系是或者。<br>
初始化：dp[0][0] = false，因为是正整数，当然凑不出和为 0。<br>
输出：dp[len - 1][target]，这里 len 表示数组的长度，target 是数组的元素之和（必须是偶数）的一半。</p>
</blockquote>
<pre><code>public class Solution {

    public boolean canPartition(int[] nums) {
        int len = nums.length;
        if (len == 0) {
            return false;
        }

        int sum = 0;
        for (int num : nums) {
            sum += num;
        }

        // 特判：如果是奇数，就不符合要求
        if ((sum &amp; 1) == 1) {
            return false;
        }

        int target = sum / 2;

        // 创建二维状态数组，行：物品索引，列：容量（包括 0）
        boolean[][] dp = new boolean[len][target + 1];

        // 先填表格第 0 行，第 1 个数只能让容积为它自己的背包恰好装满
        if (nums[0] &lt;= target) {
            dp[0][nums[0]] = true;
        }

        // 再填表格后面几行
        for (int i = 1; i &lt; len; i++) {
            for (int j = 0; j &lt;= target; j++) {
                // 直接从上一行先把结果抄下来，然后再修正
                dp[i][j] = dp[i - 1][j];

                if (nums[i] == j) {
                    dp[i][j] = true;
                    continue;
                }
                if (nums[i] &lt; j) {
                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]];
                }
            }
        }
        return dp[len - 1][target];
    }
}

</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(NC)：这里 N 是数组元素的个数，C 是数组元素的和的一半。<br>
空间复杂度：O(NC)。</p>
</blockquote>
<blockquote>
<p>下面是几点说明：<br>
1、修改状态数组初始化的定义：dp[0][0] = true。<br>
注意到：容量为 0 的时候，即 dp[i][0] 按照本意来说，应该设置为 false ，但是注意到状态转移方程（代码中）：<br>
dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]];<br>
j - nums[i] == 0 成立的时候，根据上面分析，就说明单独的 nums[i] 这个数就恰好能够在被分割为单独的一组，其余的数分割成为另外一组，因此，我们把初始化的 dp[i][0] 设置成为 true 在代码运行层面是完全没有问题的。<br>
2、观察状态转移方程的特点，or 的结果只要为真，表格下面所有的值都为真，因此在填表的时候，只要表格的最后一列是 true，代码就可以结束，直接返回 true 即可。<br>
参考代码 2：</p>
</blockquote>
<pre><code>public class Solution {

    public boolean canPartition(int[] nums) {
        int len = nums.length;
        if (len == 0) {
            return false;
        }

        int sum = 0;
        for (int num : nums) {
            sum += num;
        }

        if ((sum &amp; 1) == 1) {
            return false;
        }

        int target = sum / 2;

        boolean[][] dp = new boolean[len][target + 1];
        // 初始化成为 true 虽然不符合状态定义，但是从状态转移来说是完全可以的
        dp[0][0] = true;

        if (nums[0] &lt;= target) {
            dp[0][nums[0]] = true;
        }

        for (int i = 1; i &lt; len; i++) {
            for (int j = 0; j &lt;= target; j++) {

                dp[i][j] = dp[i - 1][j];

                if (nums[i] &lt;= j) {
                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]];
                }
            }

            // 由于状态转移方程的特殊性，提前结束，可以认为是剪枝操作
            if (dp[i][target]) {
                return true;
            }
        }
        return dp[len - 1][target];
    }
}
</code></pre>
<blockquote>
<p>3、“0-1 背包问题”常规优化：“状态数组”从二维降到一维，减少空间复杂度。<br>
在“填表格”的时候，当前行只参考了上一行的值，因此状态数组可以只设置 2 行，使用“滚动数组”的技巧“填表格”即可；<br>
实际上连“滚动数组”都不必，在“填表格”的时候，当前行总是参考了它上面一行 “头顶上” 那个位置和“左上角”某个位置的值。因此，我们可以只开一个一维数组，从后向前依次填表即可。<br>
这一点第 1 次接触的时候，可能会觉得很奇怪，理解的办法是，就拿题目中的示例，画一个表格，自己模拟一遍程序是如何“填表”的行为，就很清楚为什么状态数组压缩到 1 行的时候，需要“从后前向”填表。<br>
“从后向前” 写的过程中，一旦 nums[i] &lt;= j 不满足，可以马上退出当前循环，因为后面的 j 的值肯定越来越小，没有必要继续做判断，直接进入外层循环的下一层。相当于也是一个剪枝，这一点是“从前向后”填表所不具备的。<br>
参考代码 3：只展示了状态数组压缩到一维，并且“从后向前”填表格的代码。</p>
</blockquote>
<pre><code>public class Solution {

    public boolean canPartition(int[] nums) {
        int len = nums.length;
        if (len == 0) {
            return false;
        }

        int sum = 0;
        for (int num : nums) {
            sum += num;
        }

        if ((sum &amp; 1) == 1) {
            return false;
        }

        int target = sum / 2;

        boolean[] dp = new boolean[target + 1];
        dp[0] = true;

        if (nums[0] &lt;= target) {
            dp[nums[0]] = true;
        }

        for (int i = 1; i &lt; len; i++) {
            for (int j = target; nums[i] &lt;= j; j--) {
                if (dp[target]) {
                    return true;
                }

                dp[j] = dp[j] || dp[j - nums[i]];
            }
        }
        return dp[target];
    }
}

</code></pre>
<blockquote>
<p>最后思考为什么题目说是正整数，有 0 是否可以，有实数可以吗，有负数可以吗？<br>
0 的存在意义不大，放在哪个子集都是可以的；<br>
实数有可能是无理数，也可能是无限不循环小数，在计算整个数组元素的和的一半，要除法，然后在比较两个子集元素的和是否相等的时候，就会遇到精度的问题；<br>
再说负数，负数其实也是可以存在的，但要用到“回溯搜索”解决。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ARP地址解析协议]]></title>
        <id>https://lixin-scut.github.io//post/arp-di-zhi-jie-xi-xie-yi</id>
        <link href="https://lixin-scut.github.io//post/arp-di-zhi-jie-xi-xie-yi">
        </link>
        <updated>2020-03-24T08:04:32.000Z</updated>
        <content type="html"><![CDATA[<h3 id="交换局域网">交换局域网</h3>
<p>  交换机运行在链路层，所以它们交换链路层帧（而不是网络层数据报），它们使用链路层地址而不是IP地址来转发链路层帧通过交换机网络。</p>
<h3 id="链路层寻址和arp">链路层寻址和ARP</h3>
<p>  在网络层和链路层都需要地址<br>
  地址解析协议（ARP)：将IP地址转换为链路层地址的机制</p>
<h3 id="mac地址">MAC地址</h3>
<p>  适配器（即网络接口） 具 有链路层地址，而不是主机或路由器<br>
  具有多个网络接口的主机或路由器将具有与之相关联的多个链路层 地址<br>
  链路 层交换 机并不具有与它们的接口 (这些接口是与主机和路由器相连的）相关联的链路 层地址<br>
  链路层交换机的任务是在主机与路由器之间承载数据报，交换机透 明地执行该项任 务<br>
  链路层地址有各种不同的称呼：LAN地址（LAN address)、物理 地址（physical address）或MAC地址（MAC address)<br>
  MAC地址长度为6字节，每个字节被表示为一对十六进制数，MAC地址被设计为永久的<br>
  没有两块适 配器 具有相同的地址<br>
  适配器的MAC地址具有扁平结构（这与层次结构相反），IP地址具有层次结构（即一个网 络部分和一个主机部分）<br>
  发送适配器将目的适配器的MAC地址插入到该帧中，适配器接收到一个帧将会与其自身的MAC地址进行MAC地址匹配，不匹配的话丢弃该帧<br>
  MAC广 播地址：广播地址是48个连续的1组成的字符串（即以十六进制 表示法表示的FF-FF-FF-FF- FF-FF）<br>
  主机和路由器接口除了网络层地址之外还有MAC地址，这有如下几个原因首先，</p>
<ol>
<li>局域网是为任 意网络层协议而设计的.而不只是用于IP和因特网</li>
<li>为了使网络体系结构中各层次成为 极 为独立的构建模块.不同的层次需要有它们自己的寻址方案</li>
<li>我们现在已经看到3种 类型的地 址：应用层的主机名、网络层的IP地址以及链路层的MAC地址</li>
</ol>
<h3 id="地址解析协议">地址解析协议</h3>
<p>  地址解析协议(address resolution protocol, ARP)<br>
  发送主机中的ARP 模 块将取在相同局域网上的任何IP地址作为输人，然后返回相应的MAC地址<br>
  DNS为在因特网中任何地方的主机解析主机名，而ARP只为在同一个子网上的主机和路由器接口解析IP地址<br>
  每台主机或路由器在 其内存中具有一个ARP表（ARP table).这张表包含IP地址到MAC地址的映射关系，ARP表也包含 —个 寿命（TTL)值.它指示了从表中删除每个映射的时间<br>
  如果ARP表中当前没有该目的主机的表项，首先，发送方构造一 个称为ARP分组（ARP packet)的特殊分组，包括 发送和接 收IP地址及MAC地址<br>
一个ARP分组 具 有包含链路层地址的字段，因而可认为是链路层协议，但它也包含网络层地址，因而也 可 认为是为网络层协议，最好把ARP看成是跨越链路层和网络层边界两边的 协议</p>
<h3 id="发送数据报到子网以外">发送数据报到子网以外</h3>
<p><img src="https://lixin-scut.github.io//post-images/1585037105955.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1585037110271.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 518. 零钱兑换 II[中等][未做出]]]></title>
        <id>https://lixin-scut.github.io//post/dong-tai-gui-hua-518-ling-qian-dui-huan-iizhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/dong-tai-gui-hua-518-ling-qian-dui-huan-iizhong-deng-wei-zuo-chu">
        </link>
        <updated>2020-03-23T01:37:07.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 <br>
示例 1:<br>
输入: amount = 5, coins = [1, 2, 5]<br>
输出: 4<br>
解释: 有四种方式可以凑成总金额:<br>
5=5<br>
5=2+2+1<br>
5=2+1+1+1<br>
5=1+1+1+1+1<br>
示例 2:<br>
输入: amount = 3, coins = [2]<br>
输出: 0<br>
解释: 只用面额2的硬币不能凑成总金额3。<br>
示例 3:<br>
输入: amount = 10, coins = [10]<br>
输出: 1<br>
注意:<br>
你可以假设：<br>
0 &lt;= amount (总金额) &lt;= 5000<br>
1 &lt;= coin (硬币面额) &lt;= 5000<br>
硬币种类不超过 500 种<br>
结果符合 32 位符号整数<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/coin-change-2<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这个就和爬阶梯和斐波那契基本完全一致了<br>
这里我犯了个错误，其实不完全一致，因为阶梯是等于排序，1+2和2+1是不同的，而硬币是组合，此时是相同的。<br>
看了题解发现是首先选取某一种硬币的面值，再确定要用多少颗这种硬币（组合）<br>
在后面的循环中基于前面已有的情况继续计算。</p>
<pre><code>class Solution {
public:
    int change(int amount, vector&lt;int&gt;&amp; coins) {
        if(coins.empty())
        {   return 0; }
        if(0 == amount)
        {   return 1; }
        
        vector&lt;vector&lt;int&gt;&gt; counts(coins.size() + 1, vector&lt;int&gt;(amount + 1, 0));
        counts[0][0] = 1;
        for(auto coin : coins)
        {
            
        }
        for(int i = 1; i &lt;= coins.size(); ++i)
        {
            for(int j = 0; j &lt;= amount; ++j)
            {
                for(int k = 0; j - k*coins[i-1] &gt;= 0; ++k)
                {
                    counts[i][j] += counts[i-1][j - k*coins[i-1]] ;
                }
            }
        }
        return counts[coins.size()][amount];
    }
};
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>方法：动态规划<br>
这道题是典型的“完全背包问题”。“完全背包问题”的特点是：背包里的物品可以无限次选取。<br>
本题特殊的地方在于：从背包里选取的物品必须刚刚好装满需要考虑的容量，而不是小于等于就好，注意这点细微的区别。<br>
完全背包问题是基于 0-1 背包问题的扩展。它们的不同之处在于：<br>
0-1 背包问题：当前考虑的物品用或者不用；<br>
完全背包问题：当前考虑的物品用或者不用，如果用，用几个。<br>
思路依然是：一个一个物品考虑，容量一点一点扩大，整个过程是一个尝试和比较的过程。</p>
</blockquote>
<blockquote>
<p>第 1 步：定义状态<br>
dp[i][j]：硬币列表的前缀子区间 [0, i] 能够凑成总金额 j 的组合数。<br>
说明：背包问题有一个特点，顺序无关，在最开始，我们强调过这道问题的这个性质，因此可以一个一个硬币去看。</p>
</blockquote>
<blockquote>
<p>第 2 步：思考状态转移方程<br>
对于遍历到的每一种面值的硬币，逐个考虑添加到 “总金额” 中。由于硬币的个数可以无限选取，因此对于一种新的面值的硬币 coins[i - 1]（注意这里有一个位移偏差），依次考虑选取 0 枚、1 枚、2 枚，以此类推，直到选取这种面值的硬币的总金额超过需要的总金额 j，dp[i][j] 是它们的值的和。<br>
状态转移方程是：</p>
</blockquote>
<pre><code>Java
dp[i][j] = dp[i - 1][j - 0 * coins[i]] + 
           dp[i - 1][j - 1 * coins[i]] +
           dp[i - 1][j - 2 * coins[i]] + 
           ... + 
           dp[i - 1][j - k * coins[i]]
</code></pre>
<blockquote>
<p>这里状态转移要成立，需要满足：<code>j - k * coins[i] &gt;= 0</code>。<code>dp[i][j]</code> 相对于 <code>dp[i - 1][j]</code> 而言，多考虑的一枚硬币，是“正在考虑的那枚硬币的面值”，<code>coins[i]</code>，而这枚硬币选取的个数（从 0 开始）就是<code>dp[i][j]</code> 这个问题可以分解的各个子问题的分类标准。<br>
事实上，这个状态转移方程有优化的空间，因为做了很多重复的工作，读者可以试着自己优化一下状态转移方程。</p>
</blockquote>
<blockquote>
<p>第 3 步：思考初始化<br>
<code>dp[0][0]</code> 的值应该设置为 1，它虽然没有意义，但是是一个被参考的值，原因是：当 <code>dp[i - 1][j - k * coins[i]]</code> 的第 2 个坐标 <code>j - k * coins[i] == 0</code> 成立的时候，k 个硬币 <code>coin[i]</code> 就恰好成为了一种组合，因此，<code>dp[0][0] = 1</code>。<br>
填写第 1 行，也是初始化的时候需要考虑的内容，第 1 行即考虑第 1 个数，能够组合出的容量就只有 <code>coins[0]</code> 的整数倍数。<br>
事实上，可以考虑多设置一行，把第 1 行除了 <code>dp[0][0]</code> 全部设置为 0，这样可以避免这种复杂的初始化讨论，这一步留给读者完成。</p>
</blockquote>
<blockquote>
<p>第 4 步：思考输出<br>
输出就是表格的最后一格的数值，即 <code>dp[len - 1][amount]</code>。</p>
</blockquote>
<blockquote>
<p>第 5 步：考虑状态压缩<br>
当前状态行的值，只和上一行的状态值相关，因此可以考虑状态压缩，使用滚动数组技巧即可，这里暂不展示代码。<br>
参考代码 1：</p>
</blockquote>
<pre><code>Java
public class Solution {

    public int change(int amount, int[] coins) {
        int len = coins.length;
        if (len == 0) {
            if (amount == 0) {
                return 1;
            }
            return 0;
        }

        int[][] dp = new int[len][amount + 1];
        // 这个值语义不正确，但是是一个被其它状态参考的值，这样设置是正确的
        dp[0][0] = 1;

        // 填第 1 行
        for (int i = coins[0]; i &lt;= amount; i += coins[0]) {
            dp[0][i] = 1;
        }

        for (int i = 1; i &lt; len; i++) {
            for (int j = 0; j &lt;= amount; j++) {
                for (int k = 0; j - k * coins[i] &gt;= 0; k++) {
                    dp[i][j] += dp[i - 1][j - k * coins[i]];
                }
            }
        }
        return dp[len - 1][amount];
    }
}
</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(NM^2 )，这里金额为 M，硬币数为 N。第 1 层循环与硬币总数同规模，第 2 层循环与要求的总金额同规模，第 3 层循环在“最坏情况下”，硬币的面值为 1 时，与要求的总金额同规模。<br>
空间复杂度：O(NM)，表格有 N 行，M 列。</p>
</blockquote>
<blockquote>
<p>方法二：优化状态转移方程<br>
根据状态转移方程其实可以得到递推公式。状态转移方程的表达形式“看起来”像是一个“无穷级数”，可以通过如下方式得到一个 “递推公式”</p>
</blockquote>
<pre><code>dp[i][j] = dp[i - 1][j - 0 * coins[i - 1]] + 
           dp[i - 1][j - 1 * coins[i - 1]] +
           dp[i - 1][j - 2 * coins[i - 1]] + 
           ... + 
           dp[i - 1][j - k * coins[i - 1]]
</code></pre>
<blockquote>
<p>这里 <code>j - k * coins[i] &gt;= 0</code>。我们将这个等式记为“等式（1）。<br>
将 j 用 <code>coins[i]</code> 替换，得：</p>
</blockquote>
<pre><code>dp[i][j - coins[i]] = dp[i - 1][j - coins[i] - 0 * coins[i]] + 
                      dp[i - 1][j - coins[i] - 1 * coins[i]] +
                      dp[i - 1][j - coins[i] - 2 * coins[i]] + 
                      ... + 
                      dp[i - 1][j - coins[i] - k * coins[i]]
</code></pre>
<blockquote>
<p>这里 <code>j - coins[i] - k * coins[i] &gt;= 0</code>。<br>
整理一下：</p>
</blockquote>
<pre><code>dp[i][j - coins[i]] = dp[i - 1][j - 1 * coins[i]] + 
                      dp[i - 1][j - 2 * coins[i]] +
                      dp[i - 1][j - 3 * coins[i]] + 
                      ... + 
                      dp[i - 1][j - k * coins[i]]
</code></pre>
<blockquote>
<p>这里 <code>j - k * coins[i] &gt;= 0</code>。我们将这个等式记为“等式（2）”。<br>
将 等式（1）- 等式（2），得：<br>
<code>dp[i][j] - dp[i][j - coins[i]] = dp[i - 1][j]</code><br>
整理得：<br>
<code>dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i]]</code><br>
所以其实每一行单元的值的填写我们只要看它的左边就好了，如果没有左边，它至少是上一行单元格的值。<br>
请读者比较这里状态压缩和 0-1 背包问题的不同之处。<br>
参考代码 2：</p>
</blockquote>
<pre><code>Java
public class Solution {

    public int change(int amount, int[] coins) {
        int len = coins.length;
        if (len == 0) {
            if (amount == 0) {
                return 1;
            }
            return 0;
        }

        int[][] dp = new int[len][amount + 1];
        dp[0][0] = 1;

        for (int i = coins[0]; i &lt;= amount; i += coins[0]) {
            dp[0][i] = 1;
        }

        for (int i = 1; i &lt; len; i++) {
            for (int j = 0; j &lt;= amount; j++) {
                dp[i][j] = dp[i - 1][j];
                if (j - coins[i] &gt;= 0) {
                    dp[i][j] += dp[i][j - coins[i]];
                }
            }
        }
        return dp[len - 1][amount];
    }
}
</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(NM)，这里金额为 M，硬币数为 N。与参考代码 1 相比缩减了最内层的循环，时间复杂度降低了一级。<br>
空间复杂度：O(NM)，表格有 N 行，M 列。</p>
</blockquote>
<blockquote>
<p>第 5 步：考虑状态压缩<br>
这个方法只是优化了状态转移方程，因此，我们直接跳到第 5 步，考虑状态压缩。<br>
参考代码 3：</p>
</blockquote>
<pre><code>Java
public class Solution {

    public int change(int amount, int[] coins) {
        int len = coins.length;
        if (len == 0) {
            if (amount == 0) {
                return 1;
            }
            return 0;
        }

        int[] dp = new int[amount + 1];
        dp[0] = 1;

        for (int i = coins[0]; i &lt;= amount; i += coins[0]) {
            dp[i] = 1;
        }

        for (int i = 1; i &lt; len; i++) {
            
            // 从 coins[i] 开始即可
            for (int j = coins[i] ; j &lt;= amount; j++) {
                dp[j] += dp[j - coins[i]];
            }
        }
        return dp[amount];
    }
}
</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(NM)，这里金额为 M，硬币数为 N。<br>
空间复杂度：O(M)，表格只有 1 行，M 列。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[类型萃取type-traits]]></title>
        <id>https://lixin-scut.github.io//post/lei-xing-cui-qu-type-traits</id>
        <link href="https://lixin-scut.github.io//post/lei-xing-cui-qu-type-traits">
        </link>
        <updated>2020-03-22T11:45:00.000Z</updated>
        <content type="html"><![CDATA[<h3 id="类型萃取的作用">类型萃取的作用</h3>
<p>  类型萃取使用模板技术来萃取类型(包含自定义类型和内置类型)的某些特性，用以判断该类型是否含有某些特性，从而在泛型算法中来对该类型进行特殊的处理用来提高效率或者其他。<br>
  例如:在STL中的destory算法根据函数的参数类型的特性:是否有trivial destructor来选择对应的策略来进行destory，如果为内置类型，则不调用该类型的destructor，否则对迭代器范围内的对象调用destructor来进行destory。</p>
<h3 id="sgi-stl中type-traits可以萃取的类型属性">SGI-STL中type traits可以萃取的类型属性</h3>
<p>在SGI-STL中，可以萃取的类型属性如下:<br>
1: has_trivial_default_constructor<br>
2: has_trivial_copy_constructor<br>
3: has_trivial_assignment_operator<br>
4: has_trivial_destructor<br>
5: is_POD_type</p>
<h3 id="stl源码剖析">《STL源码剖析》</h3>
<p>  迭代器所指对象的型别，称为该迭代器的value type。模板template的参数型别推导技巧虽然可用于value type,却非全面可用：万一 value type必须用于函数的传回值，就束手无策了，毕竟函数的&quot;template参数推导机制”推而导之的只是参数，无法推导函数的回返值型别。<br>
<img src="https://lixin-scut.github.io//post-images/1584878499604.png" alt=""><br>
  但是上述方法有个隐晦的陷阱：并不是所有迭代器都是class type<br>
原生指针就不是，如果不是class type,就无法为它定义内嵌型别。但STL (以及整个泛 型思维)绝对必须接受原生指针作为一种迭代器，所以上面这样还不够。</p>
<p>  template partial specialization 可以让上述的一般化概念针对特定情况(例如针对原生指针)做特殊化处理</p>
<p><strong>Partial Specialization (偏特化)的意义</strong><br>
  如果class template拥有一个以上的 template参数，我们可以针对其中某个(或数个，但非全部)template参数进行特化工作。<br>
  我们可以在泛化设计中提供一个特化版本（也就是将泛化版本中的某些template参数赋予明确的指定）。<br>
  partial specialization的字面意义容易误导我们以为，所谓“偏特化版” 一定 是对template参数u或v或T（或某种组合）指定某个参数值。其实不然,对于 partial specialization 的意义说得十分得体：“所谓 partial specialization 的 意思是提供另一份template定义式，而其本身仍为templatized<br>
  对partial specialization的定义是：“针对（任何）template参数<strong>更进一步的条件限制</strong>所设计出来的一个特化版本”。<br>
<img src="https://lixin-scut.github.io//post-images/1584878670205.png" alt=""><br>
  有了偏特化，我们便可以解决前述“内嵌型别”未能解决的问题。<br>
  先前的问题是原生指针并非class，因此无法为它们定义内嵌型别。现在我们可以针对“迭代器之template参数为指针”者，设计特化版的迭代器。<br>
下面这个class template专门用来“萃取” 迭代器的特性，而value type正是迭代器的特性之一：</p>
<pre><code>template &lt;class I&gt;
struct iterator_traits   / / traits 意为 &quot;特性”
{	
typedef typename I::value_type value_type； 
};
</code></pre>
<p>  这个所谓的traits,其意义是，如果I定义有自己的value type,那么通过这个traits的作用，萃取出来的value_type就是 I::value_type。 换句话说， 如果I定义有自己的value type,先前那个 func() 可以改写成这样：</p>
<pre><code>template &lt;class I&gt;
typename iterator_traits&lt;I&gt;::value_type // 这一整行是函数回返型别
func(I ite)
{  return *ite; }
</code></pre>
<p>  除了多一层间接性,好处是traits可以拥有特化版本。<br>
令 iterator_traites 拥有一个 partial specializations 如下：</p>
<pre><code>template &lt;class T&gt;
struct iterator_traits&lt;T*&gt;  //偏特化版	迭代器是个原生指针
{
typedef T value_type;
);
</code></pre>
<p>于是，原生指针int*虽然不是一种class type,亦可通过traits取其value type.这就解决了先前的问题。</p>
<p>注意，针对“指向常数对象的指针(pointer-to-const) ”，下面这个式子<br>
<code>iterator_traits&lt;const int*&gt;::value_type</code><br>
获得的是const int而非int，这是我们期望的吗？我们希望利用这种机制来声明一个暂时变量，使其型别与迭代器的value type相同，而现在，声明一个无法赋值 (因 const 之故)的暂时变量没什么用,因此如果迭代器是个pointer_to_const, 我们应该设法令其value type为一个non-const型别。没问题, 只要另外设计一个特化版本，就能解决这个问题：</p>
<pre><code>template &lt;class T&gt;
struct iterator_traits&lt;const T*&gt; //偏特化版	当迭代器是个 pointe_to_const 时,
{ 
 typedef T value_type ；	//萃取出来的型别应该是T而非const T
};
</code></pre>
<p>  现在，不论面对的是迭代器My iter,或是原生指针<code>int*</code>或<code>const int*</code>, 都可以通过traits取出正确的(我们所期望的)value type</p>
<p>  图3-1说明了 traits所扮演的“特性萃取机”角色，萃取各个迭代器的特性。 这里所谓的迭代器特性，指的是迭代器的相应型别(associated types)。当然，若要这个特性萃取机ntraits能够有效运作，每一个迭代器必须遵循约定，自行以内嵌型别定义(nested typedef)的方式定义出相应型别(associated types)。<br>
<img src="https://lixin-scut.github.io//post-images/1584879350263.png" alt=""><br>
最常用到的迭代器相应型别有五种：value type, difference type,pointer,reference, iterator catagoly。如果你希望你所开发的容器能与STL相容，一定要为你的容器的迭代器定义这五种相应型别</p>
<pre><code>template &lt;class I&gt;
struct iterator_trattb {
typedef typename I::iterator_category   iterator_category;
typedef typename I::value_type          value_type；
typedef typename I::difference_type     difference_type;
typedef typename I::pointer             pointer;
typedef typename I::reference           reference
};
</code></pre>
<p>  iterator_traits 必须针对传入之型别为 pointer 及 pointer-to-const 者, 设计特化版本</p>
<h3 id="value-type">value type</h3>
<p>  所谓value type,是指迭代器所指对象的型别，任何一个打算与STL算法有完美搭配的class,都应该定义自己的value type内嵌型别。</p>
<h3 id="difference-type">difference type</h3>
<p>  difference type用来表示两个迭代器之间的距离，因此它也可以用来表示一个容器的最大容量，因为对于连续空间的容器而言，头尾之间的距离就是其最大容量。 如果一个泛型算法提供计数功能，例如STL的count(),其传回值就必须使用迭代器的 difference type：</p>
<pre><code>template &lt;class I, class T&gt;
typename iterator_traits&lt;I&gt;::difference_type // 这一整行是函数回返型别 
count(I first, I last, const T&amp; value) 
{
	for ( ; first != last ; ++first)
		if (*first == value)
			++n;
	return n;
}
</code></pre>
<p>  针对相应型别difference type, traits的如下两个(针对原生指针而写的)特化版本，以C++内建的ptrdiff_t (定义于<code>&lt;cstddef&gt;</code>头文件)作为原生指针的 difference type：</p>
<pre><code>template &lt;class I&gt;
struct iterator_traits 
{
	...
	typedef typename I::difference_type difference_type；
	};
	
// 针对原生指针而设计的偏特化(partial specialization)版
template &lt;class T&gt; 
struct iterator_traits&lt;T*&gt; 
{
	...
	typedef ptrdiff_t	difference_type;
};
// 针对原声的pointer-to-const而设计的偏特化(partial specialization)版
template &lt;class T&gt; 
struct iterator_traits&lt;const T*&gt; 
{
	...
	typedef ptrdiff_t	difference_type;
};
</code></pre>
<p>现在，任何时候当我们需要任何迭代器I的difference type ,可以这么写:<br>
<code>typename iterator_traits&lt;I&gt;::difference_type</code></p>
<h3 id="reference-type">reference type</h3>
<p>  从“迭代器所指之物的内容是否允许改变”的角度观之，迭代器分为两种：<br>
不允许改变“所指对象之内容”者，称为constant iterators,例如 const int* pic；<br>
允许改变&quot;所指对象之内容”者，称为mutable iterators,例如int* pi<br>
  当我们对一个mutable iterators进行提领操作时，获得的不应该是一个右值(rvalue),应该是一个左值(lvalue),因为右值不允许赋值操作(assignment),左值才允许.<br>
  在C++中，函数如果要传回左值，都是以by reference的方式进行，所以当 p是个mutable iterators时,如果其value type是T,那么*p的型别不应该是T, 应该是t&amp;°将此道理扩充，如果p是一个constant iterators,其value type是t, 那么*p的型别不应该是 const T, 而应该是 const T&amp;。 这里所讨论的*P的型 别，即所谓的reference type 。</p>
<h3 id="pointer-type">pointer type</h3>
<p>  pointers和references在C++中有非常密切的关联。如果“传回一个左值，令它代表P所指之物”是可能的，那么“传回一个左值，令它代表P所指之物的地址”也一定可以。也就是说，我们能够传回一个pointer,指向迭代器所指之物</p>
<pre><code>Item&amp; operator*() const { return *ptr; }
Item* operator-&gt;() const { return ptr; }
</code></pre>
<p>item&amp; 便是 Listlter 的 reference type,而 item* 便是其 pointer type<br>
<img src="https://lixin-scut.github.io//post-images/1584880412269.png" alt=""></p>
<h3 id="iterator_category">iterator_category</h3>
<p>根据移动特性与施行操作，迭代器被分为五类:<br>
  •	Input Iterator：这种迭代器所指的对象，不允许外界改变。只读（readonly）。<br>
  •	Output Iterator：唯写（write only）。<br>
  •	Forward Iterator：允许“写入型”算法，在此种迭代器所形成的区间上进行读写操作。<br>
  •	Bidirectional Iterator：可双向移动。某些算法需要逆向走访某个迭代器区间，可以使用Bidirectional Iterators。<br>
  •	Random Access Iterator：前四种迭代器都只供应一部分指针算术能力（前三种支持 operator++, 第四种再加上 operator--）, 第五种则涵盖所有指针 算术能力，包括 <code>p+n, p-n, p[n], p1-p2, p1&lt;p2</code><br>
<img src="https://lixin-scut.github.io//post-images/1584880509062.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自定义比较]]></title>
        <id>https://lixin-scut.github.io//post/zi-ding-yi-bi-jiao</id>
        <link href="https://lixin-scut.github.io//post/zi-ding-yi-bi-jiao">
        </link>
        <updated>2020-03-22T02:12:15.000Z</updated>
        <content type="html"><![CDATA[<p>今天在做题的时候发现一个问题，就是自定义比较函数的问题<br>
可以分为两类</p>
<ol>
<li>函数中的自定义比较和容器中的自定义比较</li>
<li>类外的自定义比较和类内的自定义比较</li>
</ol>
<h3 id="函数中的自定义比较和容器中的自定义比较">函数中的自定义比较和容器中的自定义比较</h3>
<p>  像sort函数的自定义比较比较简单，直接穿入函数指针就行了，一般是直接用函数名<br>
  比较特别的是容器的自定义比较，它们并不是接受函数指针，而是接受一个函数对象<br>
  比如对于priority_queue，如果想定义小顶堆，需要以下函数对象而不是函数<br>
<strong>亦即定义了一个重载了调用运算符的类，</strong><br>
  如果类定义了调用运算符，则该类的对象称作函数对象（function object）。因为可以调用这种对象，所以我们说这些对象的&quot;行为像函数一样&quot;。</p>
<pre><code>struct compare
    {
        bool operator()(ListNode* node1,ListNode* node2)
        {
            return node1-&gt;val&gt;=node2-&gt;val;
        }
    };
</code></pre>
<p>  而且注意大于小于的返回判断，如果使用 &lt;= ，返回的反而是大顶堆。。。</p>
<p>  详细可参考以前的博文：<a href="https://lixin-scut.github.io/post/guan-yu-priority-de-zi-ding-yi-bi-jiao/">关于priority_queue堆的自定义比较</a></p>
<h3 id="类外的自定义比较和类内的自定义比较">类外的自定义比较和类内的自定义比较</h3>
<p>  问题出现于网上做题的时候，在成员函数使用sort的时候希望获得逆序数组，就需要定义一个比较函数<br>
此时如果直接用</p>
<pre><code>bool comp(int i1, int i2)  const
    {   return i1 &gt; i2; }
</code></pre>
<p>是会白给的，因为这个函数属于成员函数，必须定义了类对象才有实体，而sort要求必须编译的时候就能获得确定的函数了。</p>
<p>此时有两种方法<br>
第一种是加上static关键字让它变成静态成员函数，摆脱对类对象的依赖<br>
  注意同时必须去除const ，因为const只能对成员函数使用</p>
<pre><code>static bool comp(int i1, int i2) 
    {   return i1 &gt; i2; }
</code></pre>
<p>第二种是重载调用运算符<br>
  注意必须是重载调用运算符为类成员函数<br>
  如果类定义了调用运算符，则该类的对象称作函数对象（function object）。因为可以调用这种对象，所以我们说这些对象的&quot;行为像函数一样&quot;。<br>
  所以不受类对象的限制。<br>
  然后这里可以放心加上const了</p>
<pre><code> bool operator()(int i1, int i2) const
    {   return i1 &gt; i2; }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 322. 零钱兑换[中等]]]></title>
        <id>https://lixin-scut.github.io//post/dong-tai-gui-hua-322-ling-qian-dui-huan-zhong-deng</id>
        <link href="https://lixin-scut.github.io//post/dong-tai-gui-hua-322-ling-qian-dui-huan-zhong-deng">
        </link>
        <updated>2020-03-22T00:37:45.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。<br>
示例 1:<br>
输入: coins = [1, 2, 5], amount = 11<br>
输出: 3<br>
解释: 11 = 5 + 5 + 1<br>
示例 2:<br>
输入: coins = [2], amount = 3<br>
输出: -1<br>
说明:<br>
你可以认为每种硬币的数量是无限的。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/coin-change<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>  我想到的一个做法就是类似于阶梯法，把可能达到的情况都考虑一遍，并只取最小值，比如[1, 2, 5]达到5 可以从 0，3，4出发，从0出发最少只要1步，从4出发至少都需要3步。<br>
  这个做法的缺点是是需要大容量的数组<br>
  需要注意的是起始条件，利用-1代表不可达，不能用0，否则无法区分amounts[0]的情况，同时符合题目不可达返回-1的要求</p>
<p>  第二种方法就是不断使用最大面额的币种直到不能使用，再考虑下一币种<br>
  这种方法存在缺陷，比如[3, 10]来凑15，很明显无法使用10 ，但是45又可以先用3个10，似乎必须逐步回退10的个数<br>
  最终网友题解中也是利用这种思想，就是贪心算法+深度优先遍历BFS</p>
<pre><code>class Solution {
public:
    int coinChange(vector&lt;int&gt;&amp; coins, int amount) 
    {
        if(coins.empty())
        {   return -1; }
        sort(coins.begin(), coins.end(), Solution());
        int ans = INT_MAX;
        coinChange(coins, amount, 0, 0, ans);
        return ans == INT_MAX ? -1 : ans;
    }
    
    void coinChange(vector&lt;int&gt;&amp; coins, int amount, int coinIndex, int count, int&amp; ans) 
    {
        if(0 == amount)
        {   
            ans = min(count, ans);
            return; 
        }
        if(coinIndex == coins.size())
        {   return; }
        for(int num = amount/coins[coinIndex];  num &gt;= 0 &amp;&amp; num + count &lt; ans; --num)
        {
            coinChange(coins, amount - coins[coinIndex]*num, coinIndex + 1, count + num, ans);
        }
        
    }
    
    bool operator()(int i1, int i2) const
    {   return i1 &gt; i2; }
        
    /*
    int coinChange(vector&lt;int&gt;&amp; coins, int amount) 
    {
        if(coins.empty() || amount &lt; 0)
        {   return -1; }
        
        vector&lt;int&gt; amounts(amount+1 , -1);
        amounts[0] = 0;
        
        for(int i=0; i &lt;= amount; ++i)
        {
            for(auto coin : coins)
            {
                if(i &gt;= coin &amp;&amp; amounts[i - coin] != -1)
                {
                    amounts[i] = (amounts[i] != -1 &amp;&amp; amounts[i] &lt; amounts[i - coin] + 1) ? 
                                    amounts[i] : amounts[i - coin] + 1;
                }
            }
        }
        return amounts[amount];
    }
    */
};
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>  动态规划问题的一般形式就是求最值。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求最长递增子序列呀，最小编辑距离呀等等。<br>
  既然是要求最值，核心问题是什么呢？求解动态规划的核心问题是穷举。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。<br>
  动态规划就这么简单，就是穷举就完事了？我看到的动态规划问题都很难啊！<br>
  首先，动态规划的穷举有点特别，因为这类问题存在「重叠子问题」，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。<br>
  而且，动态规划问题一定会具备「最优子结构」，才能通过子问题的最值得到原问题的最值。<br>
  另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出正确的「状态转移方程」才能正确地穷举。<br>
  以上提到的重叠子问题、最优子结构、状态转移方程就是动态规划三要素。具体什么意思等会会举例详解，但是在实际的算法问题中，写出状态转移方程是最困难的，这也就是为什么很多朋友觉得动态规划问题困难的原因，我来提供我研究出来的一个思维框架，辅助你思考状态转移方程：<br>
  明确「状态」 -&gt; 定义 dp 数组/函数的含义 -&gt; 明确「选择」-&gt; 明确 base case。<br>
下面通过斐波那契数列问题和凑零钱问题来详解动态规划的基本原理。前者主要是让你明白什么是重叠子问题（斐波那契数列严格来说不是动态规划问题），后者主要举集中于如何列出状态转移方程。</p>
</blockquote>
<blockquote>
<p>凑零钱问题<br>
先看下题目：给你 k 种面值的硬币，面值分别为 c1, c2 ... ck，每种硬币的数量无限，再给一个总金额 amount，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。算法的函数签名如下：<br>
// coins 中是可选硬币面值，amount 是目标金额<br>
int coinChange(int[] coins, int amount);<br>
比如说 k = 3，面值分别为 1，2，5，总金额 amount = 11。那么最少需要 3 枚硬币凑出，即 11 = 5 + 5 + 1。<br>
  你认为计算机应该如何解决这个问题？显然，就是把所有肯能的凑硬币方法都穷举出来，然后找找看最少需要多少枚硬币。</p>
</blockquote>
<blockquote>
<p>1、暴力递归<br>
  首先，这个问题是动态规划问题，因为它具有「最优子结构」的。要符合「最优子结构」，子问题间必须互相独立。啥叫相互独立？你肯定不想看数学证明，我用一个直观的例子来讲解。<br>
  比如说，你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。<br>
  得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。<br>
  但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，此消彼长。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。<br>
  回到凑零钱问题，为什么说它符合最优子结构呢？比如你想求 amount = 11 时的最少硬币数（原问题），如果你知道凑出 amount = 10 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案，因为硬币的数量是没有限制的，子问题之间没有相互制，是互相独立的。<br>
  那么，既然知道了这是个动态规划问题，就要思考如何列出正确的状态转移方程？<br>
  先确定「状态」，也就是原问题和子问题中变化的变量。由于硬币数量无限，所以唯一的状态就是目标金额 amount。<br>
  然后确定 dp 函数的定义：当前的目标金额是 n，至少需要 dp(n) 个硬币凑出该金额。<br>
  然后确定「选择」并择优，也就是对于每个状态，可以做出什么选择改变当前状态。具体到这个问题，无论当的目标金额是多少，选择就是从面额列表 coins 中选择一个硬币，然后目标金额就会减少：</p>
</blockquote>
<pre><code># 伪码框架
def coinChange(coins: List[int], amount: int):
    # 定义：要凑出金额 n，至少要 dp(n) 个硬币
    def dp(n):
        # 做选择，选择需要硬币最少的那个结果
        for coin in coins:
            res = min(res, 1 + dp(n - coin))
        return res
    # 我们要求的问题是 dp(amount)
    return dp(amount)
</code></pre>
<blockquote>
<p>  最后明确 base case，显然目标金额为 0 时，所需硬币数量为 0；当目标金额小于 0 时，无解，返回 -1：</p>
</blockquote>
<pre><code>def coinChange(coins: List[int], amount: int):

    def dp(n):
        # base case
        if n == 0: return 0
        if n &lt; 0: return -1
        # 求最小值，所以初始化为正无穷
        res = float('INF')
        for coin in coins:
            subproblem = dp(n - coin)
            # 子问题无解，跳过
            if subproblem == -1: continue
            res = min(res, 1 + subproblem)

        return res if res != float('INF') else -1
    
    return dp(amount)
</code></pre>
<blockquote>
<p>  至此，状态转移方程其实已经完成了，以上算法已经是暴力解法了，以上代码的数学形式就是状态转移方程：<br>
dp(n)=<br>
{<br>
0,                                               n=0<br>
−1,                                              n&lt;0<br>
min{dp(n−coin)+1∣coin∈coins}, n&gt;0<br>
}<br>
  时间复杂度分析：子问题总数 x 每个子问题的时间。<br>
  子问题总数为递归树节点个数，这个比较难看出来，是 O(n^k)，总之是指数级别的。每个子问题中含有一个 for 循环，复杂度为 O(k)。所以总时间复杂度为 O(k * n^k)，指数级别。</p>
</blockquote>
<blockquote>
<p>2、带备忘录的递归<br>
只需要稍加修改，就可以通过备忘录消除子问题：</p>
</blockquote>
<pre><code>def coinChange(coins: List[int], amount: int):
    # 备忘录
    memo = dict()
    def dp(n):
        # 查备忘录，避免重复计算
        if n in memo: return memo[n]

        if n == 0: return 0
        if n &lt; 0: return -1
        res = float('INF')
        for coin in coins:
            subproblem = dp(n - coin)
            if subproblem == -1: continue
            res = min(res, 1 + subproblem)
        
        # 记入备忘录
        memo[n] = res if res != float('INF') else -1
        return memo[n]
    
    return dp(amount)
</code></pre>
<blockquote>
<p>  很显然「备忘录」大大减小了子问题数目，完全消除了子问题的冗余，所以子问题总数不会超过金额数 n，即子问题数目为 O(n)。处理一个子问题的时间不变，仍是 O(k)，所以总的时间复杂度是 O(kn)。</p>
</blockquote>
<blockquote>
<p>3、dp 数组的迭代解法<br>
  当然，我们也可以自底向上使用 dp table 来消除重叠子问题，dp 数组的定义和刚才 dp 函数类似，定义也是一样的：<br>
  dp[i] = x 表示，当目标金额为 i 时，至少需要 x 枚硬币。</p>
</blockquote>
<pre><code>int coinChange(vector&lt;int&gt;&amp; coins, int amount) {
    // 数组大小为 amount + 1，初始值也为 amount + 1
    vector&lt;int&gt; dp(amount + 1, amount + 1);
    // base case
    dp[0] = 0;
    for (int i = 0; i &lt; dp.size(); i++) {
        // 内层 for 在求所有子问题 + 1 的最小值
        for (int coin : coins) {
            // 子问题无解，跳过
            if (i - coin &lt; 0) continue;
            dp[i] = min(dp[i], 1 + dp[i - coin]);
        }
    }
    return (dp[amount] == amount + 1) ? -1 : dp[amount];
}
</code></pre>
<blockquote>
<p>  PS：为啥 dp 数组初始化为 amount + 1 呢，因为凑成 amount 金额的硬币数最多只可能等于 amount（全用 1 元面值的硬币），所以初始化为 amount + 1 就相当于初始化为正无穷，便于后续取最小值。</p>
</blockquote>
<p>第二种解法是贪心算法+深度优先遍历BFS</p>
<blockquote>
<p>解题思路<br>
贪心<br>
  想要总硬币数最少，肯定是优先用大面值硬币，所以对 coins 按从大到小排序<br>
  先丢大硬币，再丢会超过总额时，就可以递归下一层丢的是稍小面值的硬币<br>
乘法对加法的加速<br>
  优先丢大硬币进去尝试，也没必要一个一个丢，可以用乘法算一下最多能丢几个</p>
</blockquote>
<pre><code>k = amount / coins[c_index] 计算最大能投几个
amount - k * coins[c_index] 减去扔了 k 个硬币
count + k 加 k 个硬币
</code></pre>
<blockquote>
<p>  如果因为丢多了导致最后无法凑出总额，再回溯减少大硬币数量<br>
最先找到的并不是最优解<br>
  注意不是现实中发行的硬币，面值组合规划合理，会有奇葩情况<br>
  考虑到有 [1,7,10] 这种用例，按照贪心思路 10 + 1 + 1 + 1 + 1 会比 7 + 7 更早找到<br>
   所以还是需要把所有情况都递归完<br>
ans 疯狂剪枝<br>
  贪心虽然得不到最优解，但也不是没用的<br>
  我们快速算出一个贪心的 ans 之后，虽然还会有奇葩情况，但是绝大部分普通情况就可以疯狂剪枝了</p>
</blockquote>
<pre><code>void coinChange(vector&lt;int&gt;&amp; coins, int amount, int c_index, int count, int&amp; ans)
{
    if (amount == 0)
    {
        ans = min(ans, count);
        return;
    }
    if (c_index == coins.size()) return;

    for (int k = amount / coins[c_index]; k &gt;= 0 &amp;&amp; k + count &lt; ans; k--)
    {
        coinChange(coins, amount - k * coins[c_index], c_index + 1, count + k, ans);
    }
}

int coinChange(vector&lt;int&gt;&amp; coins, int amount)
{
    if (amount == 0) return 0;
    sort(coins.rbegin(), coins.rend());
    int ans = INT_MAX;
    coinChange(coins, amount, 0, 0, ans);
    return ans == INT_MAX ? -1 : ans;
}
</code></pre>
]]></content>
    </entry>
</feed>