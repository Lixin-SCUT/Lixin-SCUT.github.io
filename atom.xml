<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-04-09T01:44:09.182Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>千里之行，始于足下。不积跬步，无以至千里。</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[数组 849. 到最近的人的最大距离[简单]]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-849-dao-zui-jin-de-ren-de-zui-da-ju-chi-jian-dan</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-849-dao-zui-jin-de-ren-de-zui-da-ju-chi-jian-dan">
        </link>
        <updated>2020-04-08T08:22:49.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>在一排座位（ seats）中，1 代表有人坐在座位上，0 代表座位上是空的。<br>
至少有一个空座位，且至少有一人坐在座位上。<br>
亚历克斯希望坐在一个能够使他与离他最近的人之间的距离达到最大化的座位上。<br>
返回他到离他最近的人的最大距离。<br>
示例 1：<br>
输入：[1,0,0,0,1,0,1]<br>
输出：2<br>
解释：<br>
如果亚历克斯坐在第二个空位（seats[2]）上，他到离他最近的人的距离为 2 。<br>
如果亚历克斯坐在其它任何一个空位上，他到离他最近的人的距离为 1 。<br>
因此，他到离他最近的人的最大距离是 2 。<br>
示例 2：<br>
输入：[1,0,0,0]<br>
输出：3<br>
解释：<br>
如果亚历克斯坐在最后一个座位上，他离最近的人有 3 个座位远。<br>
这是可能的最大距离，所以答案是 3 。<br>
提示：<br>
1 &lt;= seats.length &lt;= 20000<br>
seats 中只含有 0 和 1，至少有一个 0，且至少有一个 1。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/maximize-distance-to-closest-person<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>第一想法就是寻找最大的连续0的数量，然后取其中点吧</p>
<p>然后发现不对劲啊，比如示例二，在边缘的0没必要取中点啊。<br>
所以我针对边缘进行单独提取，使用left和right两个下标先检测两边的连续0的数量，再检测中间的连续0的数量</p>
<p>实现过程中需要注意的事项</p>
<ol>
<li>注意好初始化和重新赋值</li>
<li>中间的连续0的数量对于maxZeros的更新的规律为(zeroCounts + 1) / 2</li>
</ol>
<p>时间复杂度是O(n)，因为每个元素最多只被访问一次。</p>
<pre><code>class Solution {
public:
    int maxDistToClosest(vector&lt;int&gt;&amp; seats) {
        if(seats.empty())
        {   return 0;}
        
        int maxZeros = 0;
        int zeroCounts = 0;
        
        int left = 0;
        int right = seats.size() - 1;
        while(seats[left] == 0)
        {
            ++zeroCounts;
            maxZeros = maxZeros &gt; zeroCounts ? maxZeros : zeroCounts; 
            ++left;
        }
        
        zeroCounts = 0;
        while(seats[right] == 0)
        {
            ++zeroCounts;
            maxZeros = maxZeros &gt; zeroCounts ? maxZeros : zeroCounts; 
            --right;
        }
        
        for(int i = left; i &lt; right; ++i)
        {
            if(seats[i] == 1)
            {
                zeroCounts = 0;
            }
            if(seats[i] == 0)
            {
                ++zeroCounts;
                maxZeros = maxZeros &gt; (zeroCounts + 1) / 2 ? maxZeros : (zeroCounts + 1) / 2;
            }
        }
        return maxZeros;
    }
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>方法一：计算座位到最近的人的最大距离【通过】<br>
思路<br>
令 left[i] 为座位 i 到坐在 i 左边的人的最近距离。同理 right[i] 为座位 i 到坐在 i 右边的人的最近距离。那么该座位到最近的人的距离为 min(left[i], right[i])。<br>
算法<br>
如果 i 左边的位置是空的，那么 left[i] = left[i - 1] + 1；否则 left[i] = 0。right[i] 的计算方法类似。</p>
</blockquote>
<pre><code>class Solution {
    public int maxDistToClosest(int[] seats) {
        int N = seats.length;
        int[] left = new int[N], right = new int[N];
        Arrays.fill(left, N);
        Arrays.fill(right, N);

        for (int i = 0; i &lt; N; ++i) {
            if (seats[i] == 1) left[i] = 0;
            else if (i &gt; 0) left[i] = left[i-1] + 1;
        }

        for (int i = N-1; i &gt;= 0; --i) {
            if (seats[i] == 1) right[i] = 0;
            else if (i &lt; N-1) right[i] = right[i+1] + 1;
        }

        int ans = 0;
        for (int i = 0; i &lt; N; ++i)
            if (seats[i] == 0)
                ans = Math.max(ans, Math.min(left[i], right[i]));
        return ans;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(N)，其中 N 是 seats 的长度。<br>
空间复杂度：O(N)，存储 left 和 right 的空间。</p>
</blockquote>
<blockquote>
<p>方法二：双指针【通过】<br>
思路<br>
遍历所有座位 seats，找出每个空位左边最近的人和右边最近的人，更新当前空位到最近的人的距离。<br>
算法<br>
使用 prev 记录 i 最左边第一个有人的位置，future 记录 i 最右边第一个有人的位置。<br>
座位 i 到最近的人的距离为 min(i - prev, future - i)。另外有一种特殊情况，如果座位 i 左边没有人，则认为到左边第一个人的距离是无限大，右边同理。</p>
</blockquote>
<pre><code>class Solution {
    public int maxDistToClosest(int[] seats) {
        int N = seats.length;
        int prev = -1, future = 0;
        int ans = 0;

        for (int i = 0; i &lt; N; ++i) {
            if (seats[i] == 1) {
                prev = i;
            } else {
                while (future &lt; N &amp;&amp; seats[future] == 0 || future &lt; i)
                    future++;

                int left = prev == -1 ? N : i - prev;
                int right = future == N ? N : future - i;
                ans = Math.max(ans, Math.min(left, right));
            }
        }

        return ans;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(N)，其中 N 是 seats 的长度。<br>
空间复杂度：O(1)。</p>
</blockquote>
<blockquote>
<p>方法三：按零分组【通过】<br>
思路<br>
如果两人之间有连续 K 个空座位，那么其中存在至少一个座位到两边最近的人的距离为 (K+1) / 2。<br>
算法<br>
假设两个人之间有 K 个空座位，则存在座位到最近的人的距离为 (K+1) / 2。<br>
对于边缘的座位，它们的一侧没有人，那么认为它们到该侧最近的人的距离为 K。</p>
</blockquote>
<pre><code>class Solution {
    public int maxDistToClosest(int[] seats) {
        int N = seats.length;
        int K = 0; //current longest group of empty seats
        int ans = 0;

        for (int i = 0; i &lt; N; ++i) {
            if (seats[i] == 1) {
                K = 0;
            } else {
                K++;
                ans = Math.max(ans, (K + 1) / 2);
            }
        }

        for (int i = 0; i &lt; N; ++i)  if (seats[i] == 1) {
            ans = Math.max(ans, i);
            break;
        }

        for (int i = N-1; i &gt;= 0; --i)  if (seats[i] == 1) {
            ans = Math.max(ans, N - 1 - i);
            break;
        }

        return ans;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(N)，其中 N 是 seats 的长度。<br>
空间复杂度：O(1)。在 Python中 seats[::-1] 的空间为 O(N)，但它可以被省略。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 174:地下城游戏[困难][未做出]]]></title>
        <id>https://lixin-scut.github.io//post/dong-tai-gui-hua-174di-xia-cheng-you-xi-kun-nan-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/dong-tai-gui-hua-174di-xia-cheng-you-xi-kun-nan-wei-zuo-chu">
        </link>
        <updated>2020-04-07T09:50:08.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。<br>
骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。<br>
有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。<br>
为了尽快到达公主，骑士决定每次只向右或向下移动一步。<br>
编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。<br>
例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -&gt; 右 -&gt; 下 -&gt; 下，则骑士的初始健康点数至少为 7。</p>
</blockquote>
<table>
<thead>
<tr>
<th>-</th>
<th>-</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>-2 (K)</td>
<td>-3</td>
<td>3</td>
</tr>
<tr>
<td>-5</td>
<td>-10</td>
<td>1</td>
</tr>
<tr>
<td>10</td>
<td>30</td>
<td>-5 (P)</td>
</tr>
</tbody>
</table>
<blockquote>
<p>说明:<br>
骑士的健康点数没有上限。<br>
任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/dungeon-game<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>解题思路：<br>
很明显的动态规划<br>
而且规定了每次只向右或向下移动一步<br>
这个状态转移比较有趣，选的是top和left两者最大的值，而不是最小值，再倒推健康点数<br>
然后按照上次的官方题解，可以原地修改值，而不用新建一个容器</p>
<p>做完我才发现我理解错题意了。。。其实是记录每条路径的负数的最小值。。。再从中选出最大值<br>
我暂时的想法是用一个pair记录每个格子当前值和曾经的最小值，因为动态规划需要当前值，最终结果则需要最小值<br>
状态方程改为 判断最小值的最大者，而不是当前值的最大者<br>
后来修改了注意，不用pair，而是使用修改原vector+记录最小值的vector的模式</p>
<p>然后发现这个方法是错误的<br>
一个比较极端的情况是 {{0, -100, 200}, {0,0,0}} 和 {{0, -100, 200}, {0, -1, -100}}。<br>
很明显前者需要比较最小值（hpMap），而后者需要比较当前值（dungeon）</p>
<p>直接看题解吧<br>
发现问题所在了，应该逆向思维，从后往前推<br>
然后每个点根据当前的值来确定，如果当前值为正数，则置为0，为负数则直接翻转<br>
然后每个值的当前值等于right和bottom的最小值（注意此时是正值），再减去当前值（注意是减去，等于翻转）<br>
得到的就是正的血量<br>
记得最后要+1.</p>
<pre><code>class Solution {
public:
    int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon)
    {
        if(dungeon.empty())
        {   return 0;}
        
        //vector&lt;vector&lt;int&gt;&gt; hpMap(dungeon.begin(), dungeon.end());
        
        for(int row = dungeon.size() - 1; row &gt;= 0; --row)
        {
            for(int col = dungeon[0].size() - 1; col &gt;= 0; --col)
            {
                if(row == dungeon.size() - 1 &amp;&amp; col == dungeon[0].size() - 1)
                {
                    dungeon[row][col] = max(0, -dungeon[row][col]);
                    continue;
                }
                
                if(row == dungeon.size() - 1)
                {
                    int hpMin = dungeon[row][col + 1] - dungeon[row][col];
                    dungeon[row][col] = max(0, hpMin);
                    continue;
                }
                if(col == dungeon[0].size() - 1)
                {
                    int hpMin = dungeon[row + 1][col] - dungeon[row][col];
                    dungeon[row][col] = max(0, hpMin);
                    continue;
                }
                
                int hpMin = min(dungeon[row][col + 1], dungeon[row + 1][col]) - dungeon[row][col];
                dungeon[row][col] = max(0, hpMin);
            }
        }
        return dungeon[0][0] + 1;
    }
    
    /*
    错误代码
    int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon) {
        if(dungeon.empty())
        {   return 0;}
        
        vector&lt;vector&lt;int&gt;&gt; hpMap(dungeon.begin(), dungeon.end());
        
        for(int row = 0; row &lt; dungeon.size(); ++row)
        {
            for(int col = 0; col &lt; dungeon[0].size(); ++col)
            {
                if(row == 0 &amp;&amp; col == 0)
                {
                    continue;
                }               
                else if(row == 0)
                {
                    dungeon[row][col] += dungeon[row][col - 1];
                    hpMap[row][col] = hpMap[row][col - 1];
                    hpMap[row][col] = hpMap[row][col] &lt; dungeon[row][col] ? hpMap[row][col] : dungeon[row][col];
                    continue;
                }
                else if(col == 0)
                {
                    dungeon[row][col] += dungeon[row - 1][col];
                    hpMap[row][col] = hpMap[row - 1][col];
                    hpMap[row][col] = hpMap[row][col] &lt; dungeon[row][col] ? hpMap[row][col] : dungeon[row][col];
                    continue;
                }
                else
                {
                    
                    if(hpMap[row][col - 1]  ==  hpMap[row - 1][col])
                    {
                         dungeon[row][col] += dungeon[row][col - 1] &gt; dungeon[row - 1][col] ? dungeon[row][col - 1] : dungeon[row - 1][col];
                         hpMap[row][col] = hpMap[row][col - 1] &lt; dungeon[row][col] ? hpMap[row][col - 1] : dungeon[row][col];
                    }
                    else
                    {
                        dungeon[row][col] += hpMap[row][col - 1] &gt; hpMap[row - 1][col] ? dungeon[row][col - 1] : dungeon[row - 1][col];
                        hpMap[row][col] = hpMap[row][col - 1] &gt; hpMap[row - 1][col] ? hpMap[row][col - 1] : hpMap[row - 1][col];
                        hpMap[row][col] = hpMap[row][col] &lt; dungeon[row][col] ? hpMap[row][col] : dungeon[row][col];
                    }
                }
            }
        }
        
        return hpMap.back().back() &gt;= 0 ? 1 : -hpMap.back().back() + 1;
    }
    */
};
</code></pre>
<p>网友题解：<br>
<a href="https://leetcode-cn.com/problems/dungeon-game/solution/cong-hui-su-dao-ji-yi-hua-sou-suo-dao-dong-tai-gui/">从回溯 到 记忆化搜索 到 动态规划</a></p>
<p>动态规划</p>
<blockquote>
<p>我们的动态规划是从最后一个开始走的，每走一步，出来就记录一下，然后不断复用。<br>
其实核心的公式我们已经知道了，也就是最优子结构：<br>
<code>needMin + globalDun[i][j] = Math.min(dp[i + 1][j], dp[i][j + 1])</code><br>
其实这段代码：</p>
</blockquote>
<pre><code>if (needMin &lt; 0) {  
	res =  0;
} else {
	res =  needMin;
}
</code></pre>
<blockquote>
<p>可以等价于下面这段：<br>
<code>dp[i][j] = Math.max(0, needMin);</code><br>
所以我们可以来看下这个代码：</p>
</blockquote>
<pre><code>public int calculateMinimumHPBest(int[][] dungeon) {
    if (dungeon == null || dungeon.length == 0 || dungeon[0].length == 0) {
        return 0;
    }
    int rowSize = dungeon.length;
    int colSize = dungeon[0].length;
    int[][] dp = new int[rowSize][colSize];
    // 设置最后一个值。
  	dp[rowSize - 1][colSize -1] = Math.max(0, -dungeon[rowSize - 1][colSize - 1]);

    // 设置最后一列的值
  	for (int i = rowSize - 2; i &gt;= 0; --i) {
        int needMin = dp[i + 1][colSize - 1] - dungeon[i][colSize - 1];
        dp[i][colSize -1] = Math.max(0, needMin);
    }

    // 设置最后一行的值
  	for (int i = colSize - 2; i &gt;= 0; --i) {
        int needMin = dp[rowSize - 1][i + 1] - dungeon[rowSize - 1][i];
        dp[rowSize - 1][i] = Math.max(0, needMin);
    }

    for (int i = rowSize - 2; i &gt;= 0; --i) {
        for (int j = colSize - 2; j &gt;= 0; --j) {
			// 从右边和下边选择一个最小值，然后减去当前的 dungeon 值
            int needMin = Math.min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j];
            dp[i][j] = Math.max(0, needMin);
        }
    }
    return dp[0][0] + 1;
}
</code></pre>
<blockquote>
<p>时间复杂度O(N),空间复杂度O(N)。</p>
</blockquote>
<p>网友题解可以进一步压缩空间复杂度，首先可以改为一维数组暂存，然后对比网友题解，我直接使用了原数组进行修改，所以空间复杂度为O(1)。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[atomic类型]]></title>
        <id>https://lixin-scut.github.io//post/atomic-lei-xing</id>
        <link href="https://lixin-scut.github.io//post/atomic-lei-xing">
        </link>
        <updated>2020-04-07T02:50:32.000Z</updated>
        <content type="html"><![CDATA[<p>首先从一个问题开始：</p>
<blockquote>
<p>自增++i是否是原子操作<br>
两种解释：<br>
1.++i的操作分三步：<br>
（1）栈中取出i<br>
（2）i自增1<br>
（3）将i存到栈<br>
2.++i分为三个阶段：<br>
（1）内存读入到寄存器<br>
（2）寄存器自增<br>
（3）存入内存<br>
这三个阶段中间都可以被中断分离开.<br>
所以i++不是原子操作，上面的三个步骤中任何一个步骤同时操作，都可能导致i的值不正确自增</p>
</blockquote>
<p>  所以++i明显是线程不安全的，所以对于共享的变量（全局变量、静态变量）都需要加锁才能安全地进行自增等操作，但这未免效率太低了，而且可移植性差，到了别的系统可能锁就白给了，所以C++为了追求极致，C++11中开发了自己的atomic类型，本质是一个模板，主要根据不同的编译器和系统来确定可以使用的互斥器等类型，然后封装了高效的同步或互斥操作，并提供了相对应的复制、读取和递增递减等线程安全的操作。</p>
<p>下面是详细介绍</p>
<p>  C++11 标准中，相当大的一个变化就是引入了多线程的支持，这使得用C/C++进行线程编程时，不必依赖第三方库和标准。<br>
  而C++11对多线程的支持，最为重要的部分，就是在原子操作中引入了原子类型的概念。</p>
<h3 id="原子操作">原子操作</h3>
<p>  所谓原子操作，就是多线程程序中“最小的且不可并行化的”操作。对于在多个线程间共享的一个资源而言，这意味着同一时刻，多个线程中有且仅有一个线程在对这个资源进行操作，即互斥访问。提到“互斥”访问，熟悉多线程开发的同学可能立即想到Windows平台下使用的临界区/CRITICAL_SECTION、互斥体/Mutex。实现互斥通常需要平台相关的特殊指令，在C++11标准之前，这意味着需要在C/C++代码中嵌入平台相关的内联汇编代码。 平台相关意味着：1.你必须了解平台相关的编译器扩展；2.无法跨平台运行你的多线程程序。</p>
<pre><code>#include ＜pthread.h＞
#include ＜iostream＞
using namespace std;
static long long total=0;
pthread_mutex_t m=PTHREAD_MUTEX_INITIALIZER;
void*func(void*){
long long i;
for(i=0;i＜100000000LL;i++){
pthread_mutex_lock(＆m);
total+=i;
pthread_mutex_unlock(＆m);
}
}
int main(){
pthread_t thread1,thread2;
if(pthread_create(＆thread1,NULL,＆func,NULL)){
throw;
}
if(pthread_create(＆thread2,NULL,＆func,NULL)){
throw;
}
pthread_join(thread1,NULL);
pthread_join(thread2,NULL);
cout＜＜total＜＜endl;//9999999900000000
return 0;
}
//编译选项:g++6-3-1.cpp-lpthread
</code></pre>
<p>  代码中，我们启动两个线程来更新变量total的值，为了防止数据竞争问题，我们需要使用pthread_mutex_t类型的互斥锁，来保证两个线程互斥地访问total，从而得到total的正确结果。这个例子演示了多线程开发的基本问题：</p>
<p>  找到多个线程共享的资源/数据(飞机上洗手间里的马桶)。操作这些资源/数据的代码称之为临界区（洗手间）。<br>
  线程进入临界区并加锁，防止其他线程进入临界区(进房间后立即锁门，其他人排队)。<br>
  更新/操作共享的资源/数据(…………)<br>
  线程离开临界区，独享权让给其他等待的线程(解锁，开门。下一位……)。<br>
  如果多个线程各干各的活，没有共享的资源/数据，老死不相往来，那就没有临界区、互斥锁等所有这些破事了，完美！</p>
<p>但是！</p>
<p>  对于熟悉单线程开发的同学来说，互斥锁的管理无疑是个负担。需要说明的是，上述代码仅仅演示最基本、最简单的情形。复杂、特殊情况下，这个管理负担还是挺重的，这里就不展开讨论。</p>
<p>  “就两个线程就共享了一个数据，需要承担互斥锁的管理负担？！”相较于单线程程序，虽然只多写了两行代码，但是程序员都是懒惰的——能不写的代码坚决不写，能少写的坚决不多写(在保证代码可读性的前提下)，这也是优秀程序员的标准做法。</p>
<p>  另外一个问题是跨平台——上述代码在LINUX平台下用g++编译运行的，但是在Windows平台上，得做一番改动/重写才能运行起来。Once for all? ! No way!</p>
<p>  C++11标准从不同的视角看待这个问题：需要同步的总是资源/数据，而不是代码。因此C++11对数据进行了更为良好的抽象，引入&quot;原子数据类型&quot;/atomic类型，以达到对开发者掩盖互斥锁、临界区的目的。要知道，这些临界区、互斥锁才是平台相关的东西。来看下面的示例代码。</p>
<pre><code>#include&lt;atomic&gt;
#include&lt;thread&gt;
#include&lt;iostream&gt;

using namespace std;
std::atomic_llong total{ 0 };//原子数据类型

void func(int)
{
    for (long long i = 0; i&lt;100000000LL; ++i)
    {
        total += i;
    }
}

int main()
{
    thread t1(func, 0);
    thread t2(func, 0);
    t1.join();
    t2.join();
    cout&lt;&lt;total&lt;&lt;endl;//9999999900000000
    return 0;
}
//编译选项:g++ -std=c++11 6-3-2.cpp-lpthread
</code></pre>
<p>  代码中，将total定义为“原子数据类型”：atomic_llong, 该数据类型长度等于C++11中内置数据类型long long。可以看到，程序员不需要为原子数据类型显示地调用加锁、解锁的API，线程就能够对共享数据total进行互斥地访问。太容易了，又可以“偷懒”了！</p>
<p>  上述代码，书1作者在Linux系统下开发，用g++编译器编译运行的。代码不做任何改动，我在Windows系统下使用Visual Studio 2015编译运行也OK的。</p>
<p>  那么问题来了：既然原子操作都是平台相关的，那么atomic数据类型又如何帮助我们“掩盖”这种平台相关性呢？C++11 对常见的原子操作进行了抽象，定义出统一的接口，并根据编译选项/环境产生平台相关的实现。新标准将原子操作定义为atomic模板类的成员函数，囊括了绝大多数典型的操作——读、写、比较、交换等。</p>
<h3 id="原子数据类型atomic类型">原子数据类型/atomic类型</h3>
<p>让我们先来看一下atomic模板类:</p>
<pre><code>template &lt;class T&gt; struct atomic

//example
#include&lt;atomic&gt;

void test()
{
    std::atomic_int nThreadData; // std::atomic_int  &lt;----&gt; std::atomic&lt;int&gt;
    nThreadData = 10;
    nThreadData.store(10);
    //TODO: use nThreadData here;
}
</code></pre>
<p>  对于内置型数据类型，C11和C++11标准中都已经提供了实例化原子类型，如下表所示：<br>
<img src="https://lixin-scut.github.io//post-images/1586228285225.png" alt=""></p>
<p>atomic类型原子操作接口如下：<br>
<img src="https://lixin-scut.github.io//post-images/1586228358118.png" alt=""><br>
这些接口函数的说明和示例代码，可参考如下链接：<br>
https://en.cppreference.com/<br>
http://www.cplusplus.com/</p>
<p>  更详细的接口介绍可以查看：<a href="https://www.cnblogs.com/haippy/p/3304556.html">C++11 并发指南六(atomic 类型详解三 std::atomic (续))</a>，该作者针对atomic有四篇文章，详细介绍了相关的接口。</p>
<p>  总体而言，在多线程程序中使用这些内置数据类型对应的atomic类型，还是不难的，应付一般的多线程问题还是得心应手的。有的同学会立即想到，线程间需要交互好多数据？用自定义数据类型/UDT去实例化atomic模板类, 岂不是可以大大缩减开发的工作量？请注意表#2最后一列，class-type就是指自定义数据类型/UDT.</p>
<p>  但是！UDT要满足以下5个条件，才可作为模板参数去实例化atomic模板：</p>
<pre><code>#include &lt;atomic&gt;
#include &lt;type_traits&gt;

using namespace std;

struct MY_UDT
{
    //TODO:data member here
};

int main()
{
    auto ret = std::is_trivially_copyable&lt;MY_UDT&gt;::value;
    ret = std::is_copy_constructible&lt;MY_UDT&gt;::value;
    ret = std::is_move_constructible&lt;MY_UDT&gt;::value;
    ret = std::is_copy_assignable&lt;MY_UDT&gt;::value;
    ret = std::is_move_assignable&lt;MY_UDT&gt;::value;

    return 0;
}
</code></pre>
<p>  MY_UDT是用户自定义数据类型，上述代码中，5个ret值必须都为true。也就是说对UDT的拷贝构造、赋值构造、移动赋值等各方面都提出了要求……“要求这么高！？”用了atomic模板类，既不劳烦你写加锁/解锁代码，又不用你考虑跨平台那档子事，多好！ 哪有无缘无故的好事？总要付出一定代价的。</p>
<h3 id="内存模型">内存模型</h3>
<p>  通常情况下，内存模型是一个硬件上的概念，表示的是机器指令（或者将其视为汇编指令也可以）是以什么样的顺序被处理器执行的。现代的处理器并不是逐条处理机器指令的。<br>
<img src="https://lixin-scut.github.io//post-images/1586228634335.png" alt=""></p>
<h4 id="顺序一致内存顺序memory_order_seq_cst">顺序一致内存顺序/memory_order_seq_cst</h4>
<p>  定义规则：全部存取都按照顺序执行。</p>
<p>  memory_order_seq_cst 表示该原子操作必须顺序一致的，这是C++11中所有atomic原子操作的默认值。这样来理解“顺序一致”：即代码在线程中运行的顺序与程序员看到的代码顺序一致。也就是说，用此值提示编译器“不要给我重排序指令，不要整什么指令乱序执行，就按照我代码的先后顺序执行机器指令”。在示例代码中，a的赋值语句先于b的赋值语句执行，这种称之为”先于发生(happens-before)“关系。用memory_order_seq_cst 可以确保这种happens_before关系。</p>
<h4 id="松散内存顺序memory_order_relaxed">松散内存顺序/memory_order_relaxed</h4>
<p>  定义规则：不对执行顺序做任何保证。</p>
<p>  表示该原子操作指令可以任由编译器重排或者由处理器乱序执行。就是说”想怎么乱就怎么乱吧，不管了，只要能提高指令执行效率“。代码清单6-23中使用的就是松散内存模型，在Observer中打印出(0,2)这样的结果也是合理的——把我代码中的顺序都彻底整反了！</p>
<h4 id="release-acquire内存顺序">Release-acquire内存顺序</h4>
<p><strong>memory_orderacquire</strong></p>
<p>  规则定义：本线程中，所有后续的读操作，必须在本条原子操作完成后执行。(本线程中，我先读，你们后读……)</p>
<p><strong>memory_order_release</strong></p>
<p>  规则定义：本线程中，所有之前的写操作完成后，才能执行本原子操作。（在本线程中，你们先写，我最后写……）</p>
<p>  上面讲的顺序一致和松散方式对应着两个极端——一个是严格禁止”乱“，一个是允许随便”乱“。但是现实的问题是：严格禁止”乱“，指令执行不够快；允许随便”乱“，又得不到正确结果。</p>
<h4 id="release-consume内存顺序">Release-consume内存顺序</h4>
<p><strong>memory_order_consume</strong></p>
<p>  规则定义：本线程中，所有后续的有关本算子类型的操作，必须在本条原子操作完成之后执行。(本线程中，我只关心我自己，当我用memory_order_consume时，后面所有对我的读写操作都不能被提前执行……)</p>
<p>  相比于memory_order__acquire，memory_order_consume进一步放松了依赖关系。大家发现没有，前面讲的几种内存顺序都是在操控/安排多个atomic数据之间的读写顺序，而memory_order_consume仅仅考虑对一个atomic数据的读写顺序。</p>
<h3 id="参考资料">参考资料：</h3>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/107092432?utm_source=wechat_timeline">C++11 - atomic类型和内存模型</a></li>
<li><a href="https://www.cnblogs.com/haippy/p/3252056.html">C++11 并发指南六(atomic 类型详解一 atomic_flag 介绍)</a>，该作者针对atomic有四篇文章，详细介绍了相关的接口。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[布隆过滤器]]></title>
        <id>https://lixin-scut.github.io//post/bu-long-guo-lu-qi</id>
        <link href="https://lixin-scut.github.io//post/bu-long-guo-lu-qi">
        </link>
        <updated>2020-04-07T02:07:18.000Z</updated>
        <content type="html"><![CDATA[<h3 id="个人总结">个人总结：</h3>
<p><strong>概念</strong></p>
<p>  布隆过滤器是一种概率型数据结构，利用了位图的思想来节省空间，通过使用多个不同的哈希函数生成多个哈希值，并对每个生成的哈希值指向的 bit 位置 1。从而达到高效的插入和查询。需要注意的是由于插入存在覆盖，查询的结果是具有失败概率的，同时覆盖的存在也导致传统的布隆过滤器并不支持删除操作。</p>
<p><strong>优缺点与用途</strong></p>
<p>优点：</p>
<ol>
<li>不需要存储数据本身，只用比特表示，因此空间占用相对于传统方式有巨大的优势，并且能够保密数据；</li>
<li>时间效率也较高，插入和查询的时间复杂度均为O(k)；</li>
<li>哈希函数之间相互独立，可以在硬件指令层面并行计算。</li>
</ol>
<p>缺点：</p>
<ol>
<li>存在假阳性的概率，不适用于任何要求100%准确率的情境；</li>
<li>只能插入和查询元素，不能删除元素，这与产生假阳性的原因是相同的。可以简单地通过计数（即将一个比特扩展为计数值）来记录元素数，但仍然无法保证删除的元素一定在集合中。</li>
</ol>
<p>  所以，在对查准度要求没有那么苛刻，而对时间、空间效率要求较高的场合非常合适布隆过滤器，例如利用布隆过滤器减少磁盘 IO 或者网络请求，因为一旦一个值必定不存在的话，我们可以不用进行后续昂贵的查询请求。所以，由于布隆过滤器不存在假阴性问题，所以用作“不存在”逻辑的处理时有奇效，比如可以用来作为缓存系统（如Redis）的缓冲，防止缓存穿透。</p>
<p>下面为详细内容，主要转载 YoungChen__ 的<a href="https://www.jianshu.com/p/2104d11ee0a2">详解布隆过滤器的原理、使用场景和注意事项</a></p>
<h3 id="什么是布隆过滤器">什么是布隆过滤器</h3>
<p>  本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。</p>
<p>  相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</p>
<h3 id="实现原理">实现原理</h3>
<p><strong>HashMap 的问题</strong></p>
<p>  讲述布隆过滤器的原理之前，我们先思考一下，通常你判断某个元素是否存在用的是什么？应该蛮多人回答 HashMap 吧，确实可以将值映射到 HashMap 的 Key，然后可以在 O(1) 的时间复杂度内返回结果，效率奇高。但是 HashMap 的实现也有缺点，例如存储容量占比高，考虑到负载因子的存在，通常空间是不能被用满的，而一旦你的值很多例如上亿的时候，那 HashMap 占据的内存大小就变得很可观了。</p>
<p>  还比如说你的数据集存储在远程服务器上，本地服务接受输入，而数据集非常大不可能一次性读进内存构建 HashMap 的时候，也会存在问题。</p>
<p><strong>布隆过滤器数据结构</strong></p>
<p>  布隆过滤器是一个 bit 向量或者说 bit 数组，长这样：</p>
<p><img src="https://lixin-scut.github.io//post-images/1586225925249.png" alt=""></p>
<p>  如果我们要映射一个值到布隆过滤器中，我们需要使用多个不同的哈希函数生成多个哈希值，并对每个生成的哈希值指向的 bit 位置 1，例如针对值 “baidu” 和三个不同的哈希函数分别生成了哈希值 1、4、7，则上图转变为：</p>
<p><img src="https://lixin-scut.github.io//post-images/1586225949536.png" alt=""></p>
<p>  Ok，我们现在再存一个值 “tencent”，如果哈希函数返回 3、4、8 的话，图继续变为：</p>
<p><img src="https://lixin-scut.github.io//post-images/1586225970063.png" alt=""></p>
<p>  值得注意的是，4 这个 bit 位由于两个值的哈希函数都返回了这个 bit 位，因此它被覆盖了。现在我们如果想查询 “dianping” 这个值是否存在，哈希函数返回了 1、5、8三个值，结果我们发现 5 这个 bit 位上的值为 0，说明没有任何一个值映射到这个 bit 位上，因此我们可以很确定地说 “dianping” 这个值不存在。而当我们需要查询 “baidu” 这个值是否存在的话，那么哈希函数必然会返回 1、4、7，然后我们检查发现这三个 bit 位上的值均为 1，那么我们可以说 “baidu” 存在了么？答案是不可以，只能是 “baidu” 这个值可能存在。</p>
<p>  这是为什么呢？答案跟简单，因为随着增加的值越来越多，被置为 1 的 bit 位也会越来越多，这样某个值 “taobao” 即使没有被存储过，但是万一哈希函数返回的三个 bit 位都被其他值置位了 1 ，那么程序还是会判断 “taobao” 这个值存在。</p>
<h3 id="支持删除么">支持删除么</h3>
<p>  传统的布隆过滤器并不支持删除操作。但是名为 Counting Bloom filter 的变种可以用来测试元素计数个数是否绝对小于某个阈值，它支持元素删除。可以参考文章 <a href="https://cloud.tencent.com/developer/article/1136056">Counting Bloom Filter</a> 的原理和实现</p>
<h3 id="如何选择哈希函数个数和布隆过滤器长度">如何选择哈希函数个数和布隆过滤器长度</h3>
<p>  很显然，过小的布隆过滤器很快所有的 bit 位均为 1，那么查询任何值都会返回“可能存在”，起不到过滤的目的了。布隆过滤器的长度会直接影响误报率，布隆过滤器越长其误报率越小。</p>
<p>  另外，哈希函数的个数也需要权衡，个数越多则布隆过滤器 bit 位置位 1 的速度越快，且布隆过滤器的效率越低；但是如果太少的话，那我们的误报率会变高。</p>
<p><img src="https://lixin-scut.github.io//post-images/1586226067467.png" alt=""></p>
<p>  如何选择适合业务的 k 和 m 值呢，这里直接贴一个公式：</p>
<p><img src="https://lixin-scut.github.io//post-images/1586226081707.png" alt=""></p>
<p>  k 为哈希函数个数，m 为布隆过滤器长度，n 为插入的元素个数，p 为误报率。<br>
  至于如何推导这个公式，我在知乎发布的<a href="https://zhuanlan.zhihu.com/p/43263751">文章</a>有涉及，感兴趣可以看看，不感兴趣的话记住上面这个公式就行了。</p>
<h3 id="最佳实践">最佳实践</h3>
<p>  常见的适用常见有，利用布隆过滤器减少磁盘 IO 或者网络请求，因为一旦一个值必定不存在的话，我们可以不用进行后续昂贵的查询请求。</p>
<p>  另外，既然你使用布隆过滤器来加速查找和判断是否存在，那么性能很低的哈希函数不是个好选择，推荐 MurmurHash、Fnv 这些。</p>
<h3 id="大value拆分">大Value拆分</h3>
<p>  Redis 因其支持 setbit 和 getbit 操作，且纯内存性能高等特点，因此天然就可以作为布隆过滤器来使用。但是布隆过滤器的不当使用极易产生大 Value，增加 Redis 阻塞风险，因此生成环境中建议对体积庞大的布隆过滤器进行拆分。</p>
<p>  拆分的形式方法多种多样，但是本质是不要将 Hash(Key) 之后的请求分散在多个节点的多个小 bitmap 上，而是应该拆分成多个小 bitmap 之后，对一个 Key 的所有哈希函数都落在这一个小 bitmap 上。</p>
<p>参考资料：</p>
<ol>
<li><a href="https://www.jianshu.com/p/2104d11ee0a2">详解布隆过滤器的原理、使用场景和注意事项</a></li>
<li><a href="https://www.jianshu.com/p/bef2ec1c361f">布隆过滤器（Bloom Filter）原理及Guava中的具体实现</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/72378274">数学之美：布隆过滤器</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[回溯法 51. N皇后（全排列）[困难]]]></title>
        <id>https://lixin-scut.github.io//post/hui-su-fa-51-n-huang-hou-quan-pai-lie-kun-nan</id>
        <link href="https://lixin-scut.github.io//post/hui-su-fa-51-n-huang-hou-quan-pai-lie-kun-nan">
        </link>
        <updated>2020-04-06T08:59:26.000Z</updated>
        <content type="html"><![CDATA[<p>题目</p>
<blockquote>
<p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。<br>
给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。<br>
每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。<br>
示例:<br>
输入: 4<br>
输出: [<br>
[&quot;.Q..&quot;,  // 解法 1<br>
&quot;...Q&quot;,<br>
&quot;Q...&quot;,<br>
&quot;..Q.&quot;],<br>
[&quot;..Q.&quot;,  // 解法 2<br>
&quot;Q...&quot;,<br>
&quot;...Q&quot;,<br>
&quot;.Q..&quot;]<br>
]<br>
解释: 4 皇后问题存在两个不同的解法。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/n-queens<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>解题思考：<br>
这道题其实在剑指offer里面出现过<br>
需要把题目的本质抽象出来：全排列问题<br>
建立一个数组，将其下标视为棋盘的行，将下标对应的元素视为棋盘的列<br>
判断条件：当两个棋在同一个对角线上时，一定会有 x2 - x1 = y2 - y1;或者x2 - x1 = -（y2 - y1）; (亦即判断两者的斜率是否等于1或者 -1)</p>
<p>然后因为复杂度有点高，我突然在想可不可以用动态规划hhh</p>
<p>实现注意：</p>
<ol>
<li>我一开始老是想着在递归的过程中（也就是非叶子结点）来处理已有的序列，导致了check的位置很尴尬（因为也要考虑当前序列），最后发现还是不如直接在叶子节点进行处理</li>
<li>回溯法一定要记得状态恢复，同时因为使用了状态恢复，可以传引用调用，以免内存消耗过高（从98M降低到8M）</li>
</ol>
<pre><code>class Solution {
public:
    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) {
        if(n &lt;= 0)
        {   return vector&lt;vector&lt;string&gt;&gt;{}; }
        if(n == 1)
        {   return vector&lt;vector&lt;string&gt;&gt;{{&quot;Q&quot;}}; }
        
        vector&lt;int&gt; queensLocate(n);
        for(int i = 0; i &lt; n; ++i)
        {
            queensLocate[i] = i;
        }
        
        int counts = 0;
        vector&lt;vector&lt;string&gt;&gt; res;
        solveNQueens(queensLocate, 0, res);
        
        return res;
    }
    
    // 注意此处使用了DFS+回溯法进行状态还原，所以完全queensLocate可以使用传引用
    void solveNQueens(vector&lt;int&gt;&amp; queensLocate, int level, vector&lt;vector&lt;string&gt;&gt;&amp; res)
    {
        int length = queensLocate.size();
        
        // 一开始我钻了牛角尖，其实完全可以使用DFS，每个数字和自身交换一次，等到叶子结点再进行checkLocate
        if(level &gt;= length)
        {     
            if(checkLocate(queensLocate))
                {
                string strTemp(length, '.'); // 记得是char
                vector&lt;string&gt; resTemp(length, strTemp);
                for(int i = 0; i &lt; length; ++i)
                {
                    resTemp[i][queensLocate[i]] = 'Q'; // 记得是char
                }
                res.push_back(resTemp);
            }
            return;
        }
        
        for(int i = level ; i &lt; length; ++i) // 注意int i = level，先和自身交换一次
        {
            swap(queensLocate[level],queensLocate[i]);
            solveNQueens(queensLocate, level + 1, res); // 思考level的变化
						// 此处其实可以检查 0 - level 的值是否符合要求，进行剪枝。
            swap(queensLocate[level],queensLocate[i]); // 状态还原很重要
        }
        
    }
    
    bool checkLocate(vector&lt;int&gt;&amp; queensLocate)
    {
        for(int i = 0; i &lt; queensLocate.size(); ++i)
        {
            for(int j = i + 1; j &lt; queensLocate.size(); ++j)
            {
                if(i - j == queensLocate[i] - queensLocate[j] || - i + j == queensLocate[i] - queensLocate[j]) // 注意是并的关系 ||
                {
                    return false;
                }
            }
        }
        return true;
    }
};
</code></pre>
<p><a href="https://leetcode-cn.com/problems/n-queens/solution/hui-su-suan-fa-xiang-jie-by-labuladong/">网友题解</a><br>
网友题解有很多图，我就不强行转过来了<br>
注意我们的核心思想一致，都是转化为全排列问题，但是实现细节不一致<br>
我使用的方法是实现确定好位置，然后不断地交换他们的位置，注意我没有进行剪枝的（其实可以判断0- level 的节点是否已经冲突，已经冲突的话就剪枝）<br>
然后网友题解和我以前做全排列的方法比较像，也就是视为一棵树不断地进行选择，并记录哪些元素已经被选择过了，因此可以进行剪枝，并且把剪枝操作和最终判断合为一起（如果达到长度后直接push_back）。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[extern C ]]></title>
        <id>https://lixin-scut.github.io//post/extern-c</id>
        <link href="https://lixin-scut.github.io//post/extern-c">
        </link>
        <updated>2020-04-05T09:18:32.000Z</updated>
        <content type="html"><![CDATA[<h3 id="链接指示externc">链接指示：extern&quot;C&quot;</h3>
<p>  C++使用链接指示（linkage directive)指出任意非C++函数所用的语言。<br>
  要想把C++代码和其他语言（包括C语言）编写的代码放在一起使用，要求我们必须有权访问该语言的编译器，并且这个编译器与当前的C++编译器是兼容的</p>
<h3 id="声明一个非c的函数">声明一个非C++的函数</h3>
<p>  链接指示可以有两种形式：单个的或复合的。链接指示不能出现在类定义或函数定义的内部。同样的链接指示必须在函数的每个声明中都出现。<br>
  链接指示的第一种形式包含一个关键字extern.后面是一个字符串字面值常量以及一个 &quot;普通的&quot;函数声明。<br>
  其中的字符串字面值常量指出了编写函数所用的语言。编译器应该支持对C语言的链 接指示。此外，编译器也可能会支持其他语言的链接指示，如extern&quot;Ada&quot;、extern &quot;FORTRAN&quot;等。</p>
<h3 id="链接指示与头文件">链接指示与头文件</h3>
<p>  我们可以令链接指示后面跟上花括号括起来的若干函数的声明，从而一次性建立多个 链接。花括号的作用是将适用于该链接指示的多个声明聚合在一起，否则花括号就会被忽 略，花括号中声明的函数名字就是可见的，就好像在花括号之外声明的一样。<br>
<img src="https://lixin-scut.github.io//post-images/1586079345046.png" alt=""><br>
  当一个#include指示被放置在复合链接指示的花括号中时，头文件中的所有普通函数声明都被认为是由链接指示的语言编写的。链接指示可以嵌套，因此如果头文件包含带自带链接指示的函数，则该函数的链接不受影响。<br>
  C++从C语言继承的标准库函数可定义成C函数，但并非必须：决定使用还是C++实现C标准库，是毎个C++实现的事情。</p>
<h3 id="指向externc函数的指针">指向extern&quot;C&quot;函数的指针</h3>
<p>  编写函数所用的语言是函数类型的一部分。因此，对于使用链接指示定义的函数来说，它的每个声明都必须使用相同的链接指示。而且，指向其他语言编写的函数的指针必须与函数本身使用相同的链接指示：</p>
<pre><code>//pf指向一个C函数，该函数接受一个int返回void 
extern&quot;C&quot;void(*pf)(int); 
</code></pre>
<p>  当我们使用pf调用函数时，编详器认定当前调用的是一个c函数。<br>
  <strong>指向C函数的指针与指向C++函数的指针是不一样的类型</strong>。一个指向C函数的指针不能用在执行初始化或赋值操作后指向C++函数，反之亦然。就像其他类型不匹配的问题一样，如果我们试图在两个链接指示不同的指针之间进行赋值操作，则程序将发生错误：</p>
<h3 id="链接指示对整个声明都有效">链接指示对整个声明都有效</h3>
<p>  当我们使用链接指示时，它不仅对函数有效，而且<strong>对作为返回类型或形参类型的函数指针也有效</strong>：<br>
<img src="https://lixin-scut.github.io//post-images/1586079363829.png" alt=""><br>
  因为链接指示同时作用于声明语句中的所有函数，所以如果我们希望给C++函数传入 一个指向C函数的指针，则<strong>必须使用类型别名</strong></p>
<h3 id="导出c函数到其他语言">导出C++函数到其他语言</h3>
<p>  通过使用链接指示对函数进行<strong>定义</strong>，我们可以令一个C++函数在其他语言编写的程序 中可用：</p>
<pre><code>//calc函数可以被C程序调用 
extern &quot;C&quot; double calc(double dparm){/*...*/} 
</code></pre>
<p>  编译器将为该函数生成适合于指定语言的代码。<br>
  值得注意的是，可被多种语言共享的函数的返回类型或形参类型受到很多限制。<br>
<img src="https://lixin-scut.github.io//post-images/1586079379457.png" alt=""></p>
<h3 id="重载函数与链接指示">重载函数与链接指示</h3>
<p>  链接指示与重载函数的相互作用依赖于目标语言。如果目标语言支持重载函数，则为 该语言实现链接指示的编译很可能也支持重载这些C++的函数。<br>
  C语言不支持函数重载，因此也就不难理解为什么一个C链接指示只能用于说明一组重载函数中的某一个了：<br>
<img src="https://lixin-scut.github.io//post-images/1586079386823.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 64. 最小路径和[中等]]]></title>
        <id>https://lixin-scut.github.io//post/dong-tai-gui-hua-64-zui-xiao-lu-jing-he-zhong-deng</id>
        <link href="https://lixin-scut.github.io//post/dong-tai-gui-hua-64-zui-xiao-lu-jing-he-zhong-deng">
        </link>
        <updated>2020-04-05T05:44:10.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。<br>
说明：每次只能向下或者向右移动一步。<br>
示例:<br>
输入:<br>
[<br>
  [1,3,1],<br>
[1,5,1],<br>
[4,2,1]<br>
]<br>
输出: 7<br>
解释: 因为路径 1→3→1→1→1 的总和最小。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/minimum-path-sum<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>一开始我觉得可以用动态规划，因为限制了只能向下或者向右<br>
亦即 每个点只有两种情况，考虑左边和上边转移到当前节点<br>
然后就是状态转移方程<br>
<code>steps[col][row] = grid[i][j] + min(steps[col - 1][row], steps[col][row + 1])</code></p>
<p>注意判断边界条件</p>
<p>实现过程：</p>
<ol>
<li>用grid直接初始化steps，两者维度一致，可以省略逐个初始化</li>
<li>我使用INT_MAX来赋值边界值，但是始终没法逃避col == 0 &amp;&amp; row == 0的单独判断。</li>
<li>注意好条件运算符中的判断条件的对应关系。</li>
</ol>
<p>题目扩展：不限制向下或向右，怎么设计（我一个考虑是用图的最短路径来做，但是转化为图连通矩阵相对比较麻烦）</p>
<pre><code>class Solution {
public:
    int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        if(grid.empty())
        {   return 0; }
        vector&lt;vector&lt;int&gt;&gt; steps(grid.begin(), grid.end());
        for(int col = 0; col &lt; steps.size(); ++col)
        {
            for(int row = 0; row &lt; steps[0].size(); ++row)
            {
                if(col == 0 &amp;&amp; row == 0)
                {
                    continue;
                }
                
                int up = col &gt; 0 ? steps[col - 1][row] : INT_MAX;
                int left = row &gt; 0 ? steps[col][row - 1] : INT_MAX;
                
                steps[col][row] = grid[col][row] + min(up, left);
            }
        }
        return steps.back().back();
    }
};

/*
一开始我觉得可以用动态规划，因为限制了只能向下或者向右
亦即 每个点只有两种情况，考虑左边和上边转移到当前节点
然后就是状态转移方程
steps[col][row] = grid[i][j] + min(steps[col - 1][row], steps[col][row + 1]) 

注意判断边界条件

扩展：不限制向下或向右，怎么设计
*/
</code></pre>
<p>官方题解</p>
<blockquote></blockquote>
<p>方法 1： 暴力<br>
暴力就是利用递归，对于每个元素我们考虑两条路径，向右走和向下走，在这两条路径中挑选路径权值和较小的一个。<br>
<code>cost(i,j)=grid[i][j]+min(cost(i+1,j),cost(i,j+1))</code></p>
<pre><code>Java
public class Solution {
    public int calculate(int[][] grid, int i, int j) {
        if (i == grid.length || j == grid[0].length) return Integer.MAX_VALUE;
        if (i == grid.length - 1 &amp;&amp; j == grid[0].length - 1) return grid[i][j];
        return grid[i][j] + Math.min(calculate(grid, i + 1, j), calculate(grid, i, j + 1));
    }
    public int minPathSum(int[][] grid) {
        return calculate(grid, 0, 0);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 ：O(2^(m+n) )。每次移动最多可以有两种选择。<br>
空间复杂度 ：O(m+n)。递归的深度是 m+n。</p>
</blockquote>
<blockquote>
<p>方法 2：二维动态规划<br>
算法<br>
我们新建一个额外的 dp 数组，与原矩阵大小相同。在这个矩阵中，dp(i,j) 表示从坐标 (i,j) 到右下角的最小路径权值。我们初始化右下角的 dp 值为对应的原矩阵值，然后去填整个矩阵，对于每个元素考虑移动到右边或者下面，因此获得最小路径和我们有如下递推公式：<code>dp(i,j)=grid(i,j)+min(dp(i+1,j),dp(i,j+1))</code><br>
注意边界情况。下图描述了这个过程：</p>
</blockquote>
<pre><code>Java
public class Solution {
    public int minPathSum(int[][] grid) {
        int[][] dp = new int[grid.length][grid[0].length];
        for (int i = grid.length - 1; i &gt;= 0; i--) {
            for (int j = grid[0].length - 1; j &gt;= 0; j--) {
                if(i == grid.length - 1 &amp;&amp; j != grid[0].length - 1)
                    dp[i][j] = grid[i][j] +  dp[i][j + 1];
                else if(j == grid[0].length - 1 &amp;&amp; i != grid.length - 1)
                    dp[i][j] = grid[i][j] + dp[i + 1][j];
                else if(j != grid[0].length - 1 &amp;&amp; i != grid.length - 1)
                    dp[i][j] = grid[i][j] + Math.min(dp[i + 1][j], dp[i][j + 1]);
                else
                    dp[i][j] = grid[i][j];
            }
        }
        return dp[0][0];
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 ：O(mn)。遍历整个矩阵恰好一次。<br>
空间复杂度 ：O(mn)。额外的一个同大小矩阵。</p>
</blockquote>
<blockquote>
<p>方法 3：一维动态规划<br>
算法<br>
在上个解法中，我们可以用一个一维数组来代替二维数组，dp 数组的大小和行大小相同。这是因为对于某个固定状态，只需要考虑下方和右侧的节点。首先初始化 dp 数组最后一个元素是右下角的元素值，然后我们向左移更新每个 dp(j) 为：dp(j)=grid(i,j)+min(dp(j),dp(j+1))<br>
我们对于每一行都重复这个过程，然后向上一行移动，计算完成后 dp(0) 就是最后的结果。</p>
</blockquote>
<p>Java<br>
public class Solution {<br>
public int minPathSum(int[][] grid) {<br>
int[] dp = new int[grid[0].length];<br>
for (int i = grid.length - 1; i &gt;= 0; i--) {<br>
for (int j = grid[0].length - 1; j &gt;= 0; j--) {<br>
if(i == grid.length - 1 &amp;&amp; j != grid[0].length - 1)<br>
dp[j] = grid[i][j] +  dp[j + 1];<br>
else if(j == grid[0].length - 1 &amp;&amp; i != grid.length - 1)<br>
dp[j] = grid[i][j] + dp[j];<br>
else if(j != grid[0].length - 1 &amp;&amp; i != grid.length - 1)<br>
dp[j] = grid[i][j] + Math.min(dp[j], dp[j + 1]);<br>
else<br>
dp[j] = grid[i][j];<br>
}<br>
}<br>
return dp[0];<br>
}<br>
}</p>
<blockquote>
<p>复杂度分析<br>
时间复杂度 ：O(mn)。遍历整个矩阵恰好一次。<br>
空间复杂度 ：O(n)。额外的一维数组，和一行大小相同。</p>
</blockquote>
<blockquote>
<p>方法 4：动态规划（不需要额外存储空间）<br>
算法<br>
和方法 2 相同，惟一的区别是，不需要用额外的 dp 数组，而是在原数组上存储，这样就不需要额外的存储空间。递推公式如下：<br>
grid(i,j)=grid(i,j)+min(grid(i+1,j),grid(i,j+1))</p>
</blockquote>
<pre><code>Java
public class Solution {
    public int minPathSum(int[][] grid) {
        for (int i = grid.length - 1; i &gt;= 0; i--) {
            for (int j = grid[0].length - 1; j &gt;= 0; j--) {
                if(i == grid.length - 1 &amp;&amp; j != grid[0].length - 1)
                    grid[i][j] = grid[i][j] +  grid[i][j + 1];
                else if(j == grid[0].length - 1 &amp;&amp; i != grid.length - 1)
                    grid[i][j] = grid[i][j] + grid[i + 1][j];
                else if(j != grid[0].length - 1 &amp;&amp; i != grid.length - 1)
                    grid[i][j] = grid[i][j] + Math.min(grid[i + 1][j],grid[i][j + 1]);
            }
        }
        return grid[0][0];
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 ：O(mn)。遍历整个矩阵恰好一次。<br>
空间复杂度 ：O(1)。不需要额外空间。</p>
</blockquote>
<p>官方的空间压缩很值得学习。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[随机概率p转化为等概率]]></title>
        <id>https://lixin-scut.github.io//post/sui-ji-gai-lu-p-zhuan-hua-wei-deng-gai-lu</id>
        <link href="https://lixin-scut.github.io//post/sui-ji-gai-lu-p-zhuan-hua-wei-deng-gai-lu">
        </link>
        <updated>2020-04-05T02:22:55.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>有一个随机数发生器random函数，可以以概率P产生0，概率(1-P)产生1，请问能否利用这个随机数发生器，构造出新的发生器，以1/2的概率产生0和1。</p>
</blockquote>
<p>题解一：<br>
等概率产生0、1，就需要找到两个独立事件，当这两个独立事件发生的概率相同，就得到所求<br>
两次调用该randon函数，如果其概率为P(x)，调用2次<br>
P(1) = p       P(0) = 1-p<br>
P'(1) =p      P'(0) = 1-p<br>
则不同结果的概率如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">情况</th>
<th style="text-align:center">概率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">p*p</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">p*(1-p)</td>
</tr>
<tr>
<td style="text-align:center">01</td>
<td style="text-align:center">(1-p)*p</td>
</tr>
<tr>
<td style="text-align:center">00</td>
<td style="text-align:center">(1-p)*(1-p)</td>
</tr>
</tbody>
</table>
<p>用随机数生成器产生<code>00，01，10，11</code>，各自的概率分别为<code>p*p，p*(1-p)，(1-p)*p，(1-p)*(1-p)</code>可以发现生成01，10的概率相同，因此只保留这两种情况，其他的舍弃，然后将01映射为0，10映射为1，则得到等概率生成器。</p>
<pre><code>int random_equal()  
{  
    int i = random();  
    int j = random();  
    int result;  
  
    while (true)  
    {  
        if (i == 0 &amp;&amp; j == 1)  
        {  
            result = 0;  
            break;  
        }  
        else if (i == 1 &amp;&amp; j == 0)  
        {  
            result = 1;  
            break;  
        }  
        else  
            continue;  
    }  
  
    return result;  
}  
</code></pre>
<p>题解二：<br>
思路是叠加多个原始构造器，通过每次叠加的和与期望值对比，来决定是0和1，具体如下：<br>
迭代N次，则期望<code>E=( (1-p)*1 + p*0) * N</code> 。比较累加N次的和Sum和E，Sum大则返回0，Sum小则返回1。</p>
<p>拓展1：用等概率生成（0,1）的构造器等概率生成（0,1,2,3）。<br>
假设，原始构造器为Rand2()，则Rand2() * 2为（0,2），Rand2()* 2 + Rand2()则可以生成（0,1,2,3）。注意Rand2()* 2 + Rand2()不等于Rand2()* 3，后者等于（0,3），只用了一次构造器。前者由part1:（0,2）和part2:（0,1）构成。最终结果（0,1,2,3）任何一个数字都由part1和part2中唯一的数字相加得到。<br>
用Rand4（等概率生成0,1,2,3）可以进一步生成Rand16。方法为：Rand4()* 4 + Rand4()</p>
<p>拓展2：用等概率生成（0,1）的构造器等概率生成（0,1,2,3，...，N）。<br>
思路同上相似。由（0,1）的构造器可以生成（0，...，2^n ） 的构造器，其中每次构造生成的随机数个数是<code>上一次的平方</code>。只需要构造到保证2^n&gt;N即可。当得到的随机数处于[ N, 2^n ）时，递归生成一次，直到构造数为[0,N)时，退出本次随机数生成。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 子序列最小差]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-zi-xu-lie-zui-xiao-chai</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-zi-xu-lie-zui-xiao-chai">
        </link>
        <updated>2020-04-05T02:14:59.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>将一个数组分成两部分，不要求两部分所包含的元素个数相等，要求使得这两个部分的和的差值最小。比如对于数组{1,0,1,7,2,4}，可以分成{1,0,1,2,4}和{7}，使得这两部分的差值最小。</p>
</blockquote>
<p>思路：<br>
这个问题可以转化为求数组的一个子集，使得这个子集中的元素的和尽可能接近sum/2，其中sum为数组中所有元素的和。这样转换之后这个问题就很类似0-1背包问题了：在n件物品中找到m件物品，他们的可以装入背包中，且总价值最大不过这里不考虑价值，就考虑使得这些元素的和尽量接近sum/2。</p>
<p>下面列状态方程：<br>
<code>dp[i][j]</code>表示前i件物品中，总和最接近j的所有物品的总和，其中包括两种情况：</p>
<ol>
<li>第i件物品没有包括在其中</li>
<li>第i件物品包括在其中<br>
如果第i件物品没有包括在其中，则<code>dp[i][j] = dp[i-1][j]</code><br>
如果第i件物品包括在其中，则<code>dp[i][j] = dp[i-1][j-vec[i]]</code><br>
当然，这里要确保<code>j-vec[i] &gt;= 0</code>。</li>
</ol>
<p>所以状态转移方程为：<br>
<code>dp[i][j] = max(dp[i-1][j],dp[i-1][j-vec[i]]+vec[i]);</code></p>
<pre><code>using namespace std;
//返回两部分的差值
int diff(vector&lt;int&gt;&amp; vec)
{
    int len = vec.size();
 
    int sum = 0;
    for (int i = 0; i &lt; len; ++i) {
        sum += vec[i];
    }
 
    vector&lt;vector&lt;int&gt;&gt; dp;
    for (int i = 0; i &lt;= len; i++) {
        vector&lt;int&gt;tmp;
        for (int j = 0; j &lt;= sum / 2; ++j) {
            tmp.push_back(0);
        }
        dp.push_back(tmp);
    }
    for (int i = 1; i &lt;= len; ++i) {
        for (int j = 1; j &lt;= sum / 2; ++j) {
            if(j&gt;=vec[i-1])dp[i][j] = max(dp[i-1][j],dp[i-1][j-vec[i-1]]+vec[i-1]);
            else dp[i][j] = dp[i - 1][j];
        }
    }
 
    return sum - 2*dp[len][sum / 2];
}
 
int main()
{
    vector&lt;int&gt; vec = { 1,2,3,4,5};
 
    cout &lt;&lt; diff(vec) &lt;&lt; endl;
    system(&quot;pause&quot;);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[公有继承，保护继承，私有继承]]></title>
        <id>https://lixin-scut.github.io//post/gong-you-ji-cheng-bao-hu-ji-cheng-si-you-ji-cheng</id>
        <link href="https://lixin-scut.github.io//post/gong-you-ji-cheng-bao-hu-ji-cheng-si-you-ji-cheng">
        </link>
        <updated>2020-04-04T08:34:07.000Z</updated>
        <content type="html"><![CDATA[<p>总结：</p>
<pre><code>//公有继承                      对象访问    成员访问
public    --&gt;  public              Y         Y
protected --&gt;  protected           N         Y
private   --&gt;  private             N         N
 
//保护继承                      对象访问    成员访问
public    --&gt;  protected           N         Y
protected --&gt;  protected           N         Y
private   --&gt;  protected           N         N
 
//私有继承                      对象访问    成员访问
public    --&gt;  private             N         Y
protected --&gt;  private             N         Y
private   --&gt;  private             N         N
</code></pre>
<h3 id="预备知识">预备知识</h3>
<p>  首先有一个很重要的概念：类和类的用户<br>
  类就不用说了，就是类的本身，类的用户则很广，其中最典型的就是类的对象，对！对象自身也被视为类的用户，而不能被视为类。同时！派生类的派生类也视为用户！（注意不是对象），它也被视为使用派生类的用户。只有接受这一点才能继续下去。<br>
  但是同时也有个例外，友元视为类的成员的一部分，所以友元的访问权限和成员一致（所以友元并非被视为友元）。</p>
<p>  某个类对其继承而来的成员的访问权限受到两个因素影响：一是在基类中该成员的访问说明符，二是在派生类的派生列表中的访问说明符。</p>
<h3 id="类的成员的关键字">类的成员的关键字</h3>
<p>  派生类无法访问基类的私有成员（private）<br>
  派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。和其他使用基类的代码一样.派生类能访问公有成员，而不能访问私有成员。<br>
  不过在某些时候基类中还有这样一种成员，基类希望它的派生类有权访问该成员，同时禁止其他用户访问。我們用受保护的(protected)访问运算符说明这样的成员。<br>
  一个类使用 protected 关键字来声明那些它希望与派生类分享但是不想被其他用户访问使用的成员。 protected 说明符可以看做是 public 和 private 中和后的产物：<br>
•和私有成员类似，受保护的成员对于类的用户来说是不可访问的。（只能通过基类的非私有的成员函数来访问）<br>
•和公有成员类似，受保护的成员对于<strong>派生类的成员和友元</strong>来说是可访问的。<br>
•派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权。</p>
<h3 id="访问控制与继承">访问控制与继承</h3>
<p>  派生访问说明符对于<strong>派生类的成员（及友元）</strong> 能否访问其直接基类的成员没什么影响。<br>
  派生访问说明符的目的是控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限：<br>
  如果继承是公有的，则成员将遵循其原有的访问说明符，<br>
  派生访问说明符还可以控制继承自派生类的新类的访问权限</p>
<p>  派生类采用受保护继承，则基类的所有公有成员在新定义的类中都是受保护的。</p>
<p>  派生类向基类的转换是否可访问由使用该转换的代码决定，同时派生类的派生访问说明符也会有影响。假定 D 继承自 B :<br>
  •只有当 D 公有地继承 B 时，<strong>用户代码</strong>（对象、用户）才能使用派生类向基类的转换：如果 D 继承 B的方式是受保护的或者私有的，则用户代码不能使用该转换。<br>
  •不论 D以什么方式继承 B ， D 的<strong>成员函数和友元</strong>都能使用派生类向基类的转换：派生类向其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的。<br>
  •如果 D 继承 B 的方式是公有的或者受保护的，则 <strong>继承自D 的派生类</strong>的成员和友元可以使用 D 向 B 的类型转换；反之，如果 D 维承 B 的方式是私有的，则不能使用。<br>
  如果基类的公有成员是可访问的，则派生类向基类的类型转换也是可访问的；反之则不行。</p>
<h3 id="区别">区别</h3>
<p>  公有继承的区别就很明显了<br>
  主要就是保护继承和私有继承的区别<br>
  这两者的区别就在于继续继承下去的时候，私有继承依然保持private，而保护继承则为protected，说明再次派生的派生类的成员可以继续访问，而private已经不能再访问了。</p>
<h3 id="友元">友元</h3>
<p>  就像友元关系不能传递一样（参见7.3.4节，第250页），友元关系同样也不能继承。基类的友元在访问派生类成员时不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员：</p>
<p>  当一个类将另一个类声明为友元时，这种友元关系只对做出声明的类有效。对于原來<br>
  那个类来说，其友元的基类或者派生类不具有特殊的访问能力：<br>
  不能继承友元关系；每个类负责控制各自成员的访问权限<br>
  有时我们需要改变派生类继承的某个名字的访问级别，通过使用 using 声明可以达到这一目的：<br>
  通过在类的内部使用 using 声明语句，我们可以将该类的直接或间接基类中的任何可访问成员（例如，非私有成员）标记出来。</p>
<h3 id="默认派生运算符">默认派生运算符</h3>
<p>  默认派生运算符（例如class derived：private base中的private）也由定义派生类所用的关键字来决定。默认情况下，使用 class 关键字定义的派生类是私有继承的；而使用 struct 关键字定义的派生类是公有继承的：<br>
  在使用 struct 关键字和 class 关键字定义的类之间唯一的差别就是默认成员访问说明符及默认派生访问说明符;<br>
  一个私有派生的类最好显式化将 private 指明出来，:而不要仅仅依赖于默认的设置。显式声明的好处是可以令私有继承关系清晰明了，不至于产生误会。</p>
<h3 id="final">final</h3>
<p>  有时我们会定义这样一种类，我们不希望其他类继承它，或者不想考虑它是否适合作为一个基类。为了实现这一目的， C ++11新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字 final ：<br>
<code>class NoDerived final { /* */} //NoDerive不能作为基类</code></p>
<h3 id="例子">例子</h3>
<p>一个比较有趣的解释例子<br>
<a href="https://www.cnblogs.com/feng-qing-yang/p/5962312.html">C++公有继承，私有继承和保护继承的区别</a></p>
]]></content>
    </entry>
</feed>