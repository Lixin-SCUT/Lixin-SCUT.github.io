<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-03-02T08:26:22.728Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>In the darkest night,Rising like a spire.</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[希尔排序]]></title>
        <id>https://lixin-scut.github.io//post/xi-er-pai-xu</id>
        <link href="https://lixin-scut.github.io//post/xi-er-pai-xu">
        </link>
        <updated>2020-03-02T02:42:30.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://lixin-scut.github.io/post/pai-xu-suan-fa/">排序算法及其实现</a></p>
<p>  如何让待排序的记录个数较少呢?很容易想到的就是将原本有大量记录数的记录进行分组。分割成若干个子序列，此时每个子序列待排序的记录个数就比较少了，然后在这些子序列内分别进行直接插入排序，当整个序列都基本有序时，注意只是基本有序时，再对全体记录进行一次直接插入排序。<br>
  基本有序，就是小的关键字基本在前面，大的基本在后面，不大不小的基本在中间，我们分割待排序记录的目的是减少待排序记录的个数，并使整个序列向基本有序发展。<br>
  因此，我们需要采取跳跃分割的策略:将相距某个“增量”的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序。<br>
  注意！不能各自分组，而是依靠<strong>增量</strong>来模拟分组</p>
<pre><code>class ShellSort
{
public:
    void ShellSort0(vector&lt;int&gt; &amp;numbers);
};

void ShellSort::ShellSort0(vector&lt;int&gt; &amp;numbers)
{
    int len = numbers.size();
    int step = len;
    int i, j;
    do{
        step = (step+1) / 2 ;
        for(i = step; i &lt; len; ++i)
        {
            if(numbers[i] &lt; numbers[i-step])
            {
                int temp = numbers[i];
                for(j = i-step; j&gt;=0 &amp;&amp; temp&lt;numbers[j] ; j -= step)
                {
                    numbers[j + step] = numbers[j];
                }
                numbers[j + step] = temp;
            }
        }
    }while(step &gt; 1);
    print(numbers);
}

</code></pre>
<p>比较需要注意的就是增量的选择，我是直接模仿二分法，每次处以2并向上取整。<br>
<img src="https://lixin-scut.github.io//post-images/1583124356537.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1583124368262.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 题40:最小的k个数]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-ti-40zui-xiao-de-k-ge-shu</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-ti-40zui-xiao-de-k-ge-shu">
        </link>
        <updated>2020-03-02T01:12:01.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p>
</blockquote>
<p>  这一题就没啥特别的了，就是用大顶堆就好，记得priority_queue默认是大顶堆less，而不是小顶堆greater<br>
  然后就是还没想到的快速排序思想法，同样是找到第k个数；只是要注意k和下标、迭代器（左闭右开）的关系</p>
<pre><code>class Solution {
public:
    //快速排序思想法
    vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k){
        if(input.size()&lt;k)
            return vector&lt;int&gt;();
        GetLeastNumbers_Solution(input,k,0,input.size()-1);
        return vector&lt;int&gt;(input.begin(),input.begin()+k);
    }
    
    void GetLeastNumbers_Solution(vector&lt;int&gt; &amp;input, int k,int beg,int end){
        int flag=input[beg];
        int left=beg;
        int right=end;
        while(left&lt;right){
            while(left&lt;right&amp;&amp;input[right]&gt;=flag)
                --right;
            swap(input[left],input[right]);
            while(left&lt;right&amp;&amp;input[left]&lt;=flag)
                ++left;
            swap(input[left],input[right]);
        }
        if(left==k)
            return;
        if(left&lt;k)
            GetLeastNumbers_Solution(input,k,left+1,end);
        else
            GetLeastNumbers_Solution(input,k,beg,left+1);
    }
    /*
    //大顶堆
    vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) {
        vector&lt;int&gt; res;
        if(k&gt;input.size())
            return res;
        priority_queue&lt;int&gt; min_k;
        for(auto i:input){
            min_k.push(i);
            if(min_k.size()&gt;k)
                min_k.pop();
        }

        while(min_k.size()){
            res.push_back(min_k.top());
            min_k.pop();
        }
        return res;
    }
    */
};

</code></pre>
<p>书本题解：</p>
<blockquote>
<p>  解法一:时间复杂度为(n)的算法，只有当我们可以修改输入的数组时可用从解决面试题39 “数组中出现次数超过一半的数字”得到了启发，我们同样可以基于Partition函数来解决这个问题。如果基于数组的第k个数字来调整，则使得比第k个数字小的所有数字都位于数组的左边，比第k个数字大的所有数字都位于数组的右边。这样调整之后，位于数组中左边的k个数字就是最小的k个数字(这k个数字不一定是排序的)。<br>
  采用这种思路是有限制的。我们需要修改输入的数组，因为函数Partition会调整数组中数字的顺序。<br>
  解法二:时间复杂度为O(nlogk)的算法，特别适合处理海量数据。我们可以先创建一个大小为比的数据容器来存储最小的k个数字，接下来每次从输入的n个整数中读入一个数。如果容器中已有的数字少于k个, 则直接把这次读入的整数放入容器之中；如果容器中已有k个数字了，也就是容器已满，此时我们不能再插入新的数字而只能替换已有的数字。找 出这已有的k个数中的最大值，然后拿这次待插入的整数和最大值进行比 较。如果待插入的值比当前已有的最大值小，则用这个数替换当前已有的最大值：如果待插入的值比当前已有的最大值还要大，那么这个数不可能是最小的k个整数之一，于是我们可以抛弃这个整数。<br>
当容器满了之后，我们要做3件事情：一是在k个整数中找到最大数；二是有可能在这个容器中删除最大数；三是有可能要插入一个新的数字。如果用一棵二叉树来实现这个数据容器，那么我们能在O(logk)时间内实现这3步操作。因此，对于k个输入数字而言，总的时间效率就是 O(nlogk)<br>
（注意：是重要记得堆中的数据是没排序的，需要额外排序）<br>
解法比较<br>
  基于函数Partition的第一种解法的平均时间复杂度是O(n)，比第二种解法要快，但同时它也有明显的限制，比如会修改输入的数组。<br>
  第二种解法虽然慢一点，但它有两个明显的优点。一是没有修改输入的数据（代码中的变量data）。我们每次只是从data中读入数字，所有的操作都是在容器leastNumbers中进行的。二是该算法适合海量数据的输入 。假设题目是要求从海量的数据中找出最小的k个数字，由『内存的大小是有限的， 有可能不能把这些海量的数据一次性全部载入内存。这个时候，我们可以从辅助存储空间（如硬盘）中每次读入一个数字，根据GetLeastNumbers 的方式判断是不是需要放入容器leastNumbers即可。这种思路只要求内存能够容纳leastNumbers即可，因此它最适合的情形就是n很大并且比较小的问题。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 题39:数组中出现次数超过一半的数字[未做出]]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-ti-39shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-ti-39shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-wei-zuo-chu">
        </link>
        <updated>2020-03-02T00:54:17.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
</blockquote>
<p>  一开始我用的是单次遍历的方法，亦即不断检测最大重复数字，遇到相同的数字就+1，遇到不同的数字就要-1，次数变为0就要替换res<br>
然后注意的就是这个数字可能是不存在的，所以必须循环一次计算次数是否真的超过数组一半<br>
  然后就是快速排序的思想改进，因为中位数肯定就是出现次数超过一半的数，所以直接看当前数字所处的位置就行<br>
需要注意的是细节，比如为什么是numbers.size()/2<br>
  然后最坑的就是我不小心在if后面加了一个分号。。完全不会报错就跳到下一句去了，只有用了clion才发现这个warning</p>
<pre><code>class Solution {
public:
    //快速排序思想法的改版【未做出】
    int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers){
        if(numbers.empty())
            return 0;
        int res=MoreThanHalfNum_Solution(numbers,numbers.size()/2,0,numbers.size()-1);
        if(CheckNum(res,numbers))
            return res;
        else 
            return 0;
    }
    
    int MoreThanHalfNum_Solution(vector&lt;int&gt; &amp;numbers,int target,int left,int right){
        int flag=numbers[left];
        int beg=left;
        int end=right;
        while(beg&lt;end){
            while(beg&lt;end&amp;&amp;numbers[end]&gt;=flag)
                --end;
            swap(numbers[beg],numbers[end]);
            while(beg&lt;end&amp;&amp;numbers[beg]&lt;=flag)
                ++beg;
            swap(numbers[beg],numbers[end]);
        }
        if(beg==target)
            return numbers[beg];
        if(beg&lt;target)
            return MoreThanHalfNum_Solution(numbers,target,beg+1,right);
        else
            return MoreThanHalfNum_Solution(numbers,target,left,beg-1);
    }
    
    /*
    //次数互减
    int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) {
        int res,num;
        for(int i=0;i&lt;numbers.size();++i){
            if(i==0)
                res=numbers[i],num=1;
            else if(res==numbers[i])
                ++num;
            else if(res!=numbers[i]){
                if(num==1)
                    res=numbers[i];
                else
                    --num;
            }
        }
        if(CheckNum(res,numbers))
            return res;
        else 
            return 0;
    }
    */
    bool CheckNum(int res,vector&lt;int&gt; &amp;numbers){
        int num=0;
        for(auto i:numbers)
            if(i==res)
                ++num;
        return num&gt;numbers.size()/2;
    }    
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>如果是排好序的数组，那么我们就能很容易统计出每个数字出现的次数。 题目给出的数组没有说是排序的，因此我们需要先给它排序。排序的时间复杂度是O(NlogN)，最直观的算法通常不是面试官满意的算法<br>
解法一：基于Partition函数的时间复杂度为的算法<br>
数组中有一个数字出现的次数超过了数组长度的一半。如果 把这个数组排序，那么排序之后位于数组中间的数字一定就是那个出现次 数超过数组长度一半的数字。也就是说，这个数字就是统计学上的中位数, 即长度为n的数组中第n/2大的数字。我们有成熟的时间复杂度为O(N)的 算法得到数组中任意第k大的数字。<br>
这种算法受快速排序算法的启发。在随机快速排序算法中，我们先在数组中随机选择一个数字，然后调整数组中数字的顺序，使得比选中的数字小的数字都排在它的左边，比选中的数字大的数字都排在它的右边。如 果这个选中的数字的下标刚好是n/2,那么这个数字就是数组的中位数；如 果它的下标大于n/2,那么中位数应该位于它的左边，我们可以接着在它的 左边部分的数组中查找；如果它的下标小于n/2,那么中位数应该位于它的 右边，我们可以接着在它的右边部分的数组中查找。这是一个典型的递归过程。<br>
在面试的时候，除了要完成基本功能即找到符合要求的数字，还要考虑一些无效的输入。如果函数的输入参数是一个指针(数组在参数传 递的时候退化为指针)，就要考虑这个指针可能为nullptr。下面的函数 ChecklnvalidArray用来判断输入的数组是不是无效的。题目中说数组中有 一个数字出现的次数超过数组长度的一半，可能输入的数组中出现频率最高的数字都没有达到这个标准，这就是我们定义了一个 CheckMoreThanHalf函数的原因。<br>
解法二：根据数组特点找出时间复杂度为的算法<br>
接下来我们从另外一个角度来解决这个问题。数组中有一个数字出现 的次数超过数组长度的一半，也就是说它出现的次数比其他所有数字出现 次数的和还要多。因此，我们可以考虑在遍历数组的时候保存两个值：一个是数组中的一个数字；另一个是次数。当我们遍历到下一个数字的时候， 如果下一个数字和我们之前保存的数字相同，则次数加1；如果下一个数字和我们之前保存的数字不同，则次数减1。如果次数为零，那么我们需要保存下一个数字，并把次数设为1。由于我们要找的数字出现的次数比其他所 有数字出现的次数之和还要多，那么要找的数字肯定是最后一次把次数设 为1时对应的数字。</p>
</blockquote>
<pre><code>bool g_bInputInvalid = false;

bool CheckInvalidArray(int* numbers, int length)
{
    g_bInputInvalid = false;
    if(numbers == nullptr &amp;&amp; length &lt;= 0)
        g_bInputInvalid = true;

    return g_bInputInvalid;
}

bool CheckMoreThanHalf(int* numbers, int length, int number)
{
    int times = 0;
    for(int i = 0; i &lt; length; ++i)
    {
        if(numbers[i] == number)
            times++;
    }
 
    bool isMoreThanHalf = true;
    if(times * 2 &lt;= length)
    {
        g_bInputInvalid = true;
        isMoreThanHalf = false;
    }

    return isMoreThanHalf;
}

// ====================方法1====================
int MoreThanHalfNum_Solution1(int* numbers, int length)
{
    if(CheckInvalidArray(numbers, length))
        return 0;
 
    int middle = length &gt;&gt; 1;
    int start = 0;
    int end = length - 1;
    int index = Partition(numbers, length, start, end);
    while(index != middle)
    {
        if(index &gt; middle)
        {
            end = index - 1;
            index = Partition(numbers, length, start, end);
        }
        else
        {
            start = index + 1;
            index = Partition(numbers, length, start, end);
        }
    }
 
    int result = numbers[middle];
    if(!CheckMoreThanHalf(numbers, length, result))
        result = 0;

    return result;
}

// ====================方法2====================
int MoreThanHalfNum_Solution2(int* numbers, int length)
{
    if(CheckInvalidArray(numbers, length))
        return 0;
 
    int result = numbers[0];
    int times = 1;
    for(int i = 1; i &lt; length; ++i)
    {
        if(times == 0)
        {
            result = numbers[i];
            times = 1;
        }
        else if(numbers[i] == result)
            times++;
        else
            times--;
    }
 
    if(!CheckMoreThanHalf(numbers, length, result))
        result = 0;
 
    return result;
}
</code></pre>
<blockquote>
<p>述两种算法的时间复杂度都是O(n)。我们注意到，在第一种解法中，需要交换数组中数字的顺序，这就会修改输入的数组。是不是可以修改输 入的数组呢？在面试的时候，我们可以和面试官讨论，让他明确需求。如果面试官说不能修改输入的数组，那就只能采用第二种解法了。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 题38:字符串的排列[未做出]]]></title>
        <id>https://lixin-scut.github.io//post/zi-fu-chuan-ti-38zi-fu-chuan-de-pai-lie-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/zi-fu-chuan-ti-38zi-fu-chuan-de-pai-lie-wei-zuo-chu">
        </link>
        <updated>2020-03-02T00:25:31.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。<br>
输入描述:<br>
输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</p>
</blockquote>
<p>【未做出】<br>
一开始我打算用leetcode的做法，也就是回溯法，但是这样实在是太复杂了，需要记录或者去除已经采用的数字，第二个函数足足需要5到6个参数，而且需要很多局部变量<br>
所以还是参考书本的固定交换法<br>
注意和书本不同的是，这里首先需要去除重复值的交换（但是同时必须保证自己和自己换，所以需要加上num!=i的判断）<br>
其次要求返回的结果是排序的，这里就只能使用sort了。</p>
<pre><code>class Solution {
public:
    vector&lt;string&gt; Permutation(string str) {
        vector&lt;string&gt; res;
        if(str.empty())
            return res;
        Permutation(str,0,res);
        sort(res.begin(),res.end());
        return res;
    }
    
    void Permutation(string str,int num,vector&lt;string&gt; &amp;res)
    {
        if(num==str.size()){
            res.push_back(str);
            return;
        }
        for(int i=num;i&lt;str.size();++i){
            if(str[num]==str[i]&amp;&amp;num!=i)
                continue;
            swap(str[num],str[i]);
            Permutation(str,num+1,res);
            swap(str[num],str[i]);
        }
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>我们求整个字符串的排列，可以看成两步。第一步求所有可能出现在第一个位置的字符，即把第一个字符和后面所有的字符交换。。第二步固定第一个字符，求后面所有字符的排列。这时候我们仍把后面的所有字符分成两部分：后面字符的第一个字符，以及这个字符之后的所有字符。然后把第一个字符逐一和它后面的字符交换，这其实是典型的递归思路</p>
</blockquote>
<pre><code>void Permutation(char* pStr)
{
    if(pStr == nullptr)
        return;

    Permutation(pStr, pStr);
}

void Permutation(char* pStr, char* pBegin)
{
    if(*pBegin == '\0')
    {
        printf(&quot;%s\n&quot;, pStr);
    }
    else
    {
        for(char* pCh = pBegin; *pCh != '\0'; ++ pCh)
        {
            char temp = *pCh;
            *pCh = *pBegin;
            *pBegin = temp;

            Permutation(pStr, pBegin + 1);

            temp = *pCh;
            *pCh = *pBegin;
            *pBegin = temp;
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Epoll]]></title>
        <id>https://lixin-scut.github.io//post/epoll</id>
        <link href="https://lixin-scut.github.io//post/epoll">
        </link>
        <updated>2020-03-01T15:05:32.000Z</updated>
        <content type="html"><![CDATA[<p>epoll是Linux独有的高效的IO multiplexing机制<br>
epoll与poll的不同之处主要在于poll每次返回整个文件描述符数组，用户代码需要遍历数组以找到哪些文件描述符上有IO事件,而 epoll_wait返回的是活动fd的列表，需要遍历的数组通常会小得多。在并发连接数较大而活动连接比例不高时，epoll比poll更高效。<br>
我们把epoll(封装为EPoller class,它与Poller class具有完全相同的接口。我们可以定义Poller基类并提供两份实现PollPoller和EPollPoller<br>
EPoller的关键数据结构如下，其中events_不是保存所有关注的fd列表，而是一次epoll_wait调用返回的活动fd列表，它的大小是自适应的。</p>
<pre><code>typedef std::vecotr&lt;struct epoll_event&gt; EventList;
typedef std::map&lt;int, Channel*&gt; ChannelMap;
int epollfd_;
EventList events_;
ChannelMap channels_;
</code></pre>
<p>struct epoll_event的定义如下，epoll_data是个union, 主要使用的是其ptr成员，用于存放Channel*</p>
<pre><code>typedef union epoll_data
(
		void	*ptr;
		int	fd;
		uint32_t u32;
		uint64_t u64;
} epoll_data_t;

struct epoll_event
(
		uint32_t events；	/* Epoll events */
		epoll_data_t data;	/* User data variable */
}；
</code></pre>
<p>为了减少转换，Channel没有自己定义IO事件的常量，而是直接使用 poll的定义(POLLIN、ROLLOUT等等),在Linux中它们和epoll的常量相等。</p>
<p>如果当前活动fd的数目填满了 events_,那么下次就尝试接收更多的活动fd。 events_的初始长度是16 ( kInitEventListSize ),其会根据程序的IO繁忙程度自动增长，但目前不会自动收缩。<br>
EPoller::fillActiveChannels()的功能是将 events_中的活动 fd 填入 activeChannel</p>
<p>因为epoll是有状态的，因此updateChannel()和removechannel()两个函数要时刻维护内核中的fd状态与应用程序的状态相符，Channel:: index() 和Channel::set_index()被挪用为标记此Channel是否位于epoll的关注列表之中。 这两个函数的复杂度是O(log N),因为Linux内核用红黑树来管理epoll关注的文件 描述符清单。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TcpClient]]></title>
        <id>https://lixin-scut.github.io//post/tcpclient</id>
        <link href="https://lixin-scut.github.io//post/tcpclient">
        </link>
        <updated>2020-03-01T13:46:53.000Z</updated>
        <content type="html"><![CDATA[<p>每个 TcpClient 只管理一个TcpConnection。<br>
要点：</p>
<ul>
<li>
<p>TcpClient具备TcpConnection断开之后重新连接的功能，加上Connector具 备反复尝试连接的功能，因此客户端和服务端的启动顺序无关紧要。可以先启动客户端，一旦服务端启动，半分钟之内即可恢复连接(由Connector:: kMaxRetryDelayMs常数控制)；在客户端运行期间服务端可以重启，客户端也会自动重连。</p>
</li>
<li>
<p>连接断开后初次重试的延迟应该有随机性，比方说服务端崩溃，它所有的客户 连接同时断开，然后0.5s之后同时再次发起连接，这样既可能造成SYN丢包, 也可能给服务端带来短期大负载，影响其服务质量。因此每个TcpClient应该等待一段随机的时间(0.5~2s),再重试，避免拥塞。</p>
</li>
<li>
<p>发起连接的时候如果发生TCP SYN丢包，那么系统默认的重试间隔是3s,这期 间不会返回错误码，而且这个间隔似乎不容易修改。如果需要缩短间隔，可以再用一个定时器，在0.5s或1s之后发起另一次连接。如果有需求的话，这个功能可以做到Connector中。</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[流量控制滑动窗口与MSS、MTU]]></title>
        <id>https://lixin-scut.github.io//post/liu-liang-kong-zhi-hua-dong-chuang-kou-yu-mssmtu</id>
        <link href="https://lixin-scut.github.io//post/liu-liang-kong-zhi-hua-dong-chuang-kou-yu-mssmtu">
        </link>
        <updated>2020-03-01T08:38:07.000Z</updated>
        <content type="html"><![CDATA[<h3 id="tcp接收窗口字段">TCP接收窗口字段</h3>
<p>每个TCP报文头部有16比特的接收窗口字段，表明接收端可用缓存空间的大小，报文段发送方在相反方向上可接受的最大序列号值为TCP头部中ACK号和窗口大小字段之和。<br>
可以通过窗口缩放因子(Window Scaling)选项增大窗口。</p>
<h3 id="tcp流量控制服务">TCP流量控制服务</h3>
<p>消除发送方使接收方缓存溢出的可能性，亦即速度匹配服务.即发送方的发送速率与接收方应用程序的读取速率相四配<br>
流量控制和拥塞控制采取的动作非常相似，但然是针对完全不同的原因而采取的措施<br>
TCP通过让发送方维护一个称为接收窗口的变量来提供流量控制<br>
接收窗口用于给发送方一个指示——该接收方还有多少可用的缓存空间<br>
<img src="https://lixin-scut.github.io//post-images/1583052025198.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1583052027872.png" alt=""><br>
空间是随着时间变化的.所以rwnd是动态的<br>
服务器通过把当前的rwnd值放入发给客户端的报文段接收窗口字段中，从而提供流量控制服务<br>
通过将未确认的数据铍控制在值rwnd以内，就可以保证主机A不会使主机B的接收缓存溢出，因此主机A在该连接的整个生命周期须保证<br>
LastByteSent-LastByteAcked&lt;=rwnd<br>
当主机B的接收窗口为0时.主机A继续发送只有一个字节数据的报文段，防止rwnd=0后，服务器有空闲却无法发送修改rwnd的回执（TCP规定服务器仅在它有数据或有确认要发时才会发送报文段给主机A）</p>
<h3 id="mss与mtu">MSS与MTU</h3>
<p>MSS:TCP报文的数据字段的最大长度（不包含TCP首部）<br>
MTU:IP首部+TCP报文<br>
MSS保证一个TCP报文段加上TCP/IP首部长度（通常40字节）将适合单个链路层帧<br>
TCP首部20字节，IP首部20字节，<br>
MTU一般为1500，所以MSS为1460.</p>
<p>MTU: 链路层帧能承载的最大数据量叫做最大传送单元（MaximumTransmissionUnit)，是OSI五层网络模型中链路层(datalink layer)对一次可以发送的最大数据的限制。</p>
<p>以太网帧的数据字段（46 -1500字节）承载了IP数据报，以太网的最大传输单元 (MTU)是1500 字节这意味符，如果IP数据报超过1500字节.则主机必须将该数据报分片，数据字段的最小长度是46字节：这意味着如果IP数据报小于46字节，数据报必须被填充到46字节，当采用填充时，传递到网络层的数据包括IP数据报和填充部分网络层使用IP数据报首部中的长度字段来去除填充部分</p>
<p>MSS: 是Maximum Segement Size缩写，表示TCP报文中data部分的最大长度，是TCP协议在OSI五层网络模型中传输层对一次可以发送的最大数据的限制。</p>
<p>当需要传输的数据大于MSS或者MTU时，数据会被拆分成多个包进行传输。由于MSS是根据MTU计算出来的，因此当发送的数据满足MSS时，必然满足MTU。</p>
<h3 id="糊涂窗口综合征">糊涂窗口综合征</h3>
<p>基于窗口的流量控制机制，尤其是不使用大小固定的报文段的情况,可能会出现称为糊涂窗口综合征（Silly Window Syndrome, SWS）的缺陷。当出现该问题时，交换数据段大小不是全长的而是一些较小的数据段。由于每个报文段中有用数据相对 于头部信息的比例较小，因此耗费的资源也更多，相应的传输效率也更低。<br>
TCP连接的两端都可能导致SWS的出现：接收端的通告窗口较小（没有等到窗口变大才通告），或者发送端发送的数据段较小（没有等待将其他数据组合成一个更大的报文段）。 要避免SWS问题，必须在发送端或接收端实现相关规则。TCP无法提前预知某一端的行为。<br>
需要遵循以下规则：</p>
<ol>
<li>对于接收端来说，不应通告小的窗口值。描述的接收算法中，在窗口可增 至一个全长的报文段（即接收端MSS）或者接收端缓存空间的一半（取两者中较小者）之前, 不能通告比当前窗口（可能为0）更大的窗口值。注意到可能有两种情况会用到该规则：当 应用程序处理接收到的数据后使得可用缓存增大，以及TCP接收端需要强制返回对窗口探 测的响应。</li>
<li>对于发送端来说，不应发送小的报文段，而且需由Nagle算法控制何时发送。为避免 SWS问题，只有至少满足以下条件之一时才能传输报文段：<br>
（a）	全长（发送MSS字节）的报文段可以发送。<br>
（b）	数据段长度N接收端通告过的最大窗口值的一半的，可以发送。<br>
（c）	满足以下任一条件的都可以发送：（i）某一 ACK不是目前期盼的（即没有未经确认的在传数据）;（ii）该连接禁用Nagle算法。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浏览器打开一个网页的全过程]]></title>
        <id>https://lixin-scut.github.io//post/liu-lan-qi-da-kai-yi-ge-wang-ye-de-quan-guo-cheng</id>
        <link href="https://lixin-scut.github.io//post/liu-lan-qi-da-kai-yi-ge-wang-ye-de-quan-guo-cheng">
        </link>
        <updated>2020-03-01T06:54:51.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>域名解析：浏览器获得URL地址，向操作系统请求该URL对应的IP地址，操作系统查询DNS获得对应的IP地址</li>
<li>确认好了IP和端口号，则可以向该IP地址对应的服务器的该端口号发起TCP连接请求</li>
<li>IP协议指定了出发地（客户端）和目的地（服务器），网络层的路由器选择算法决定了会经过那些路由器（OSPF与BGP），链路层的ARP协议负责求下一个节点的MAC地址（不止是要目的地，还要中间节点的地址）。</li>
<li>服务器接收到TCP连接请求后，回复可以连接请求，</li>
<li>浏览器收到回传的数据后，还会向服务器发送数据包，表示三次握手结束</li>
<li>三次握手成功后，开始通讯，根据HTTP协议的要求，组织一个请求的数据包，里面包含请求的资源路径、你的身份信息等，例如，<code>www.abc.com/images/1/</code>表示的资源路径是<code>images/1/</code>，发送后，服务器响应请求，将数据返回给浏览器，数据可以是根据HTML协议组织的网页，里面包含页面的布局、文字等等，也可以是图片或者脚本程序等，如果资源路径指定的资源不存在，服务器就会返回404错误，如果返回的是一个页面，则根据页面里的一些外链URL地址，重复上述步骤，再次获取</li>
<li>渲染页面，并开始响应用户的操作</li>
<li>窗口关闭时，通过四次挥手终止与服务器的连接</li>
</ol>
<p>关于1中的细节：<br>
  URL可分割成几个部分：协议、网络地址、资源路径<br>
  协议：指从该计算机获取资源的方式，常见的是HTTP、FTP<br>
  网络地址：可以是域名或者是IP地址，也可以包括端口号，如果不注明端口号，默认是80端口<br>
  如果地址不是一个IP地址，则需要通过DNS（域名系统）将该地址解析成IP地址，IP地址对应着网络上的一台计算机，DNS服务器本身也有IP，本机网络设置包含DNS服务器的IP。<br>
DNS查找过程：<br>
  首先主机会查询本地HOST文件，然后查询DNS的缓存，如果没有就给本地DNS发送查询请求。DNS查询分为两种方式，一种是递归查询，一种是迭代查询。如果是迭代查询，本地的DNS服务器，向根域名服务器发送查询请求，根域名服务器告知该域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到查询到该域名的IP地址。DNS服务器是基于UDP的，因此会用到UDP协议。<br>
  例如递归查询中，<code>www.abc.com</code>不是一个IP，则需要向DNS询问请求<code>www.abc.com</code>对应的IP，获得IP，在这个过程中，你的电脑直接询问DNS服务器可能没有发现<code>www.abc.com</code>对应的IP，就会向它的上级服务器询问，这样依次一层层向上级找，最高可达根节点，直到找到或者全部找不到为止<br>
  端口号不同的窗口负责不同的服务，如果输入<code>www.abc.com:8080/</code>，则表示不使用默认的80端口，而使用指定的8080端口</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[直接插入排序]]></title>
        <id>https://lixin-scut.github.io//post/zhi-jie-cha-ru-pai-xu</id>
        <link href="https://lixin-scut.github.io//post/zhi-jie-cha-ru-pai-xu">
        </link>
        <updated>2020-03-01T01:00:54.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://lixin-scut.github.io/post/pai-xu-suan-fa/">排序算法及其实现</a></p>
<p>  直接插入排序算法 直接插入排序(StraightInsertionSort)的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表。</p>
<pre><code>class StraightInsertionSort
{
public:
    void StraightInsertionSort0(vector&lt;int&gt; &amp;numbers);
};

void StraightInsertionSort::StraightInsertionSort0(vector&lt;int&gt; &amp;numbers) {
    int len = numbers.size();
    int i;
    int j;
    for (i = 1; i &lt; len; ++i)
    {
        if(numbers[i] &lt; numbers[i-1])
        {
            int temp = numbers[i];
            for (j = i - 1; j&gt;=0 &amp;&amp; numbers[j] &gt; temp; --j)
            {
                    numbers[j + 1] = numbers[j];
            }
            numbers[++j] = temp;
        }
    }
    print(numbers);
}
</code></pre>
<p>时间复杂度：<br>
<img src="https://lixin-scut.github.io//post-images/1583028460111.png" alt=""></p>
<p>我一开始的实现：</p>
<pre><code>    void StraightInsertionSort::StraightInsertionSort0(vector&lt;int&gt; &amp;numbers) {
        int len = numbers.size();
        for (int i = 1; i &lt; len; ++i) {  // i和j可以放到循环外定义
            int temp = numbers[i];   // 必须设置哨兵
            int j;
            for (j = i - 1; j &gt;= 0; --j) {
                if (numbers[j] &gt; temp)  // 这里其实可以放到循环头内，所见代码
                {
                    numbers[j + 1] = numbers[j];
                }
                else
                {
                    break; // 通过把前面的判断放到循环里，这一部分可以省略
                }
            }
            numbers[++j] = temp; // 记得递增
        }
        print(numbers);
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[简单选择排序]]></title>
        <id>https://lixin-scut.github.io//post/jian-dan-xuan-ze-pai-xu</id>
        <link href="https://lixin-scut.github.io//post/jian-dan-xuan-ze-pai-xu">
        </link>
        <updated>2020-03-01T00:57:43.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://lixin-scut.github.io/post/pai-xu-suan-fa/">排序算法及其实现</a></p>
<p>  排序时找到合适的关键字再做交换，并且只移动一次就完成相应关键字的排序定位工作，这就是选择排序法的初步思想。<br>
  选择排序的基本思想是毎一趟在n-i+1(i=1,2,...,n-1)个记录中选取关键字最小的记录作为有序序列的第i个记录。</p>
<pre><code>void SimpleSelectionSort::SimpleSelectionSort0(vector&lt;int&gt; &amp;numbers)
{
    int len = numbers.size();
    for (int i = 0; i &lt; len; ++i)
    {
        int min = i;
        for(int j = i+1; j &lt; len; ++j)
        {
            if(numbers[min] &gt; numbers[j]) // 注意为了保证稳定，一定不能包含等于
            {
                min = j;
            }
        }
        if(min != i)
						swap(numbers[min],numbers[i]);
    }
    print(numbers);
}
</code></pre>
<p>  简单选择排序法(SimpleSelectionSort) 就是通过 n-1次关键字间的比较,从n-i+1个记录中选出关键字最小的记录，并和第i(1 &lt;= i &lt;= n)个记录交换之。</p>
<p>复杂度分析：<br>
<img src="https://lixin-scut.github.io//post-images/1582940921126.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582940933596.png" alt=""></p>
]]></content>
    </entry>
</feed>