<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-12-17T01:41:01.678Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[二分查找 374. 猜数字大小]]></title>
        <id>https://lixin-ee.github.io//post/er-fen-cha-zhao-374-cai-shu-zi-da-xiao</id>
        <link href="https://lixin-ee.github.io//post/er-fen-cha-zhao-374-cai-shu-zi-da-xiao">
        </link>
        <updated>2019-12-17T01:27:26.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>我们正在玩一个猜数字游戏。 游戏规则如下：<br>
我从 1 到 n 选择一个数字。 你需要猜我选择了哪个数字。<br>
每次你猜错了，我会告诉你这个数字是大了还是小了。<br>
你调用一个预先定义好的接口 guess(int num)，它会返回 3 个可能的结果（-1，1 或 0）：<br>
-1 : 我的数字比较小<br>
1 : 我的数字比较大<br>
0 : 恭喜！你猜对了！<br>
示例 :<br>
输入: n = 10, pick = 6<br>
输出: 6<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/guess-number-higher-or-lower<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题其实才应该放到第一题吧。。。那个刷题顺序说实话不算特别严谨<br>
然后其实没啥难的，就是把二分法复现了一下，主要就是mid=first+(last-first)/2;是左倾还是右倾，从而影响后面是first=mid+1还是last=mid-1;<br>
然后吐槽一下题目的语文水平，题目中的我的数字是指要猜的数字而不是mid</p>
<pre><code>// Forward declaration of guess API.
// @param num, your guess
// @return -1 if my number is lower, 1 if my number is higher, otherwise return 0
int guess(int num);

class Solution {
public:
    int guessNumber(int n) {
       int first=1,last=n, mid;
        while(first&lt;last){
            //mid=first+(last-first)/2;
            mid=first+(last-first+1)/2;
            int res=guess(mid);
            if(res==0)
                return mid;
            else if(res==-1)
                //last=mid;
                last=mid-1;
            else
                //first=mid+1;  
                first=mid;
        }
        return first;
    }
};
</code></pre>
<p>这道题就没太多值得讨论的地方了，二分查找基本题<br>
建议看一下<a href="https://lixin-ee.github.io/post/er-fen-cha-zhao-fa-mo-ban/">二分查找法模板</a></p>
<p>然后就是官方题解中的三分查找法<br>
方法 3：三分查找<br>
算法<br>
在二分查找中，我们选择中间元素作为分隔点。而在三分查找中，我们选择两个分隔点（比方记作 m1 和 m2），那么给定范围会被分成 3 个相等长度的部分。如果答案 num 比 m1 小，那么我们对 m1 左边的区间做三分查找。如果 num 在 m1 和 m2 中间，我们对中间区域进行三分查找。否则我们对 m2 右边的区域进行三分查找。</p>
<pre><code>public class Solution extends GuessGame {
    public int guessNumber(int n) {
        int low = 1;
        int high = n;
        while (low &lt;= high) {
            int mid1 = low + (high - low) / 3;
            int mid2 = high - (high - low) / 3;
            int res1 = guess(mid1);
            int res2 = guess(mid2);
            if (res1 == 0)
                return mid1;
            if (res2 == 0)
                return mid2;
            else if (res1 &lt; 0)
                high = mid1 - 1;
            else if (res2 &gt; 0)
                low = mid2 + 1;
            else {
                low = mid1 + 1;
                high = mid2 - 1;
            }
        }
        return -1;
    }
}
</code></pre>
<p>复杂度分析</p>
<p>时间复杂度： O(log_3 n)为三分查找所需的时间复杂度。<br>
空间复杂度： O(1) 。没有使用额外的空间。</p>
<p>看起来三分查找会比二分查找更快，但是为什么二分查找使用得更广泛？<br>
二分查找和三分查找的比较<br>
<img src="https://lixin-ee.github.io//post-images/1576546844828.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二分查找 162. 寻找峰值[中等]]]></title>
        <id>https://lixin-ee.github.io//post/er-fen-cha-zhao-162-xun-zhao-feng-zhi-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/er-fen-cha-zhao-162-xun-zhao-feng-zhi-zhong-deng">
        </link>
        <updated>2019-12-16T03:16:16.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>峰值元素是指其值大于左右相邻值的元素。<br>
给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。<br>
数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。<br>
你可以假设 nums[-1] = nums[n] = -∞。<br>
示例 1:<br>
输入: nums = [1,2,3,1]<br>
输出: 2<br>
解释: 3 是峰值元素，你的函数应该返回其索引 2。<br>
示例 2:<br>
输入: nums = [1,2,1,3,5,6,4]<br>
输出: 1 或 5<br>
解释: 你的函数可以返回索引 1，其峰值元素为 2；<br>
     或者返回索引 5， 其峰值元素为 6。<br>
说明:<br>
你的解法应该是 O(logN) 时间复杂度的。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/find-peak-element<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题又和普通的二分查找有区别<br>
我一开始的想法是递归调用二分查找，因为数组是无序的，所以需要两边都继续查找下去，相当于树的每个节点都要搜索到。</p>
<p>突然发现又读错题了，因为示例2中说明其实返回其中一个峰值就好，不需要返回最大的峰值</p>
<p>不过我还是没想到比较好的方法，还是继续老方法</p>
<p>似乎在序列的右边一定会出现峰值（错误 3 7 6 5 0 就不符合）</p>
<p>尝试向递增那一边移动（最后证明这个是正确的，因为相邻两节点不相同，而且两边有负无穷，所以只要一直向递增的方向移动一定会到达峰值，可以把3 7 6 5 0化为连续函数就清楚了）</p>
<p>边界条件着实是麻烦啊，注意(mid!=0&amp;&amp;nums[mid-1]&gt;nums[mid])中的mid!=0不可缺少<br>
幸好边界比较明显，所以最后边界判断也不算特别复杂</p>
<p>主要是：<br>
一开始不小心把三个if分开了，导致一直mid[0-1]错误<br>
然后用else连起来后发现自己在if else和&amp;&amp;的组合判断上犯了一个很严重的错误<br>
if(mid<mark>0&amp;&amp;nums[mid]&gt;nums[mid+1])<br>
return mid;<br>
else if(mid</mark>nums.size()-1&amp;&amp;nums[mid]&gt;nums[mid-1])<br>
return mid;<br>
else if(nums[mid]&gt;nums[mid-1]&amp;&amp;nums[mid]&gt;nums[mid+1])<br>
在这里如果mid==0但是不符合nums[mid]&gt;nums[mid+1]的话！是会继续判断下一个if而不是跳出判断的！！！</p>
<pre><code>class Solution {
public:
    int max=-1;
    int findPeakElement(vector&lt;int&gt;&amp; nums) {
        int first=0,last=nums.size()-1,mid;
        while(first&lt;last){
            mid=first+(last-first)/2;
            if(mid==0){
                if(nums[mid]&gt;nums[mid+1])
                return mid;
            }
            else if(mid==nums.size()-1){
                if(nums[mid]&gt;nums[mid-1])
                return mid;
            }
            else if(nums[mid]&gt;nums[mid-1]&amp;&amp;nums[mid]&gt;nums[mid+1])
                return mid;
             if(mid!=0&amp;&amp;nums[mid-1]&gt;nums[mid])
                 last=mid;
            else
                first=mid+1;
        }
        return first;
    }
};
</code></pre>
<p>然后来看一下题解</p>
<blockquote>
<p>思路<br>
标签：二分查找<br>
过程：<br>
首先要注意题目条件，在题目描述中出现了 nums[-1] = nums[n] = -∞，这就代表着 只要数组中存在一个元素比相邻元素大，那么沿着它一定可以找到一个峰值<br>
根据上述结论，我们就可以使用二分查找找到峰值<br>
查找时，左指针 l，右指针 r，以其保持左右顺序为循环条件<br>
根据左右指针计算中间位置 m，并比较 m 与 m+1 的值，如果 m 较大，则左侧存在峰值，r = m，如果 m + 1 较大，则右侧存在峰值，l = m + 1<br>
时间复杂度：O(logN)<br>
代码</p>
</blockquote>
<pre><code>Java
class Solution {
    public int findPeakElement(int[] nums) {
        int left = 0, right = nums.length - 1;
        for (; left &lt; right; ) {
            int mid = left + (right - left) / 2;
            if (nums[mid] &gt; nums[mid + 1]) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
}
</code></pre>
<p>看完这个题解才发现自己搞复杂了 我的主判断是nums[mid-1]&gt;nums[mid]，但是我的mid计算是左倾的，明显用nums[mid]&gt;nums[mid+1]更加方便，就不会出现超出下标范围的情况了，果然还是欠缺考虑啊<br>
修改代码如下：</p>
<pre><code>class Solution {
public:
    int max=-1;
    int findPeakElement(vector&lt;int&gt;&amp; nums) {
        int first=0,last=nums.size()-1,mid;
        while(first&lt;last){
            mid=first+(last-first)/2;
             if(nums[mid]&gt;nums[mid+1])
                 last=mid;
            else
                first=mid+1;
        }
        return first;
    }
};
</code></pre>
<p>代码简洁了超级多，时间复杂度和空间复杂度也下降了</p>
<p>然后是官方题解解释：<br>
<a href="https://leetcode-cn.com/problems/find-peak-element/solution/xun-zhao-feng-zhi-by-leetcode/">寻找峰值</a><br>
其实方法一致，而且比较难复制，我就不贴了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二分查找 154. 寻找旋转排序数组中的最小值 II[困难]]]></title>
        <id>https://lixin-ee.github.io//post/154-xun-zhao-xuan-zhuan-pai-xu-shu-zu-zhong-de-zui-xiao-zhi-iikun-nan</id>
        <link href="https://lixin-ee.github.io//post/154-xun-zhao-xuan-zhuan-pai-xu-shu-zu-zhong-de-zui-xiao-zhi-iikun-nan">
        </link>
        <updated>2019-12-15T02:33:05.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br>
( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。<br>
请找出其中最小的元素。<br>
注意数组中可能存在重复的元素。<br>
示例 1：<br>
输入: [1,3,5]<br>
输出: 1<br>
示例 2：<br>
输入: [2,2,2,0,1]<br>
输出: 0<br>
说明：<br>
这道题是 寻找旋转排序数组中的最小值 的延伸题目。<br>
允许重复会影响算法的时间复杂度吗？会如何影响，为什么？<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题我也只想到如果边界和mid一样的话就往中间靠拢直至只有一边是异常的<br>
然后处理过程中有点小问题，因为上一题81题的判断条件是(nums[mid]==nums[first]&amp;&amp;nums[mid]==nums[last])<br>
这里有个与逻辑保证了避开mid和first或者mid和last相等时把自身去掉的情况<br>
然后一开始我忽略了这点导致失败了，比如[1,3]会导致1把自己去掉<br>
所以需要加上判断mid!=first和mid!=last才行<br>
时间复杂度和空间复杂度都不堪入目啊，好好看看题解用了啥方法吧</p>
<pre><code>class Solution {
public:
    int findMin(vector&lt;int&gt;&amp; nums) {
        if(nums.empty()) return -1;
        int first=0,last=nums.size()-1,mid;
        while(first&lt;last){
            mid=first+(last-first)/2;
            if(mid!=first&amp;&amp;nums[mid]==nums[first])
                ++first;
            else if(mid!=last&amp;&amp;nums[mid]==nums[last])
                --last;
            else if(nums[mid]&lt;nums[first])
                last=mid;
            else if(nums[mid]&gt;nums[last])
                first=mid+1;
            else
                return nums[first];
        }
        return nums[first];
    }
};
</code></pre>
<p>来看看网友题解吧<br>
<img src="https://lixin-ee.github.io//post-images/1576377717081.png" alt=""></p>
<pre><code>class Solution {
    public int findMin(int[] nums) {
        int left = 0, right = nums.length - 1;
        while (left &lt; right) {
            int mid = (left + right) / 2;
            if (nums[mid] &gt; nums[right]) left = mid + 1;
            else if (nums[mid] &lt; nums[right]) right = mid;
            else right = right - 1;
        }
        return nums[left];
    }
}
</code></pre>
<p>其实思路还是一样的，只能通过缩减边界来处理，最坏情况就等同于顺序搜索了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二分查找 153. 寻找旋转排序数组中的最小值[中等]]]></title>
        <id>https://lixin-ee.github.io//post/er-fen-cha-zhao-153-xun-zhao-xuan-zhuan-pai-xu-shu-zu-zhong-de-zui-xiao-zhi-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/er-fen-cha-zhao-153-xun-zhao-xuan-zhuan-pai-xu-shu-zu-zhong-de-zui-xiao-zhi-zhong-deng">
        </link>
        <updated>2019-12-14T02:47:05.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br>
( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。<br>
请找出其中最小的元素。<br>
你可以假设数组中不存在重复元素。<br>
示例 1:<br>
输入: [3,4,5,1,2]<br>
输出: 1<br>
示例 2:<br>
输入: [4,5,6,7,0,1,2]<br>
输出: 0<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>我一开始的想法是把mid和first last做比较，如果有异常的话说明当前序列有问题，最小值应该处于有异常的一端<br>
没有异常的话就照常处理<br>
判断条件是重点<br>
异常判断分为两个 if(nums[mid]&lt;nums[first])和else if(nums[mid]&gt;nums[last])<br>
最后如果没有异常的话，可以直接返回nums[first]<br>
遇到的小坑就是习惯性返回了first，其实应该是nums[first]</p>
<pre><code>class Solution {
public:
    int findMin(vector&lt;int&gt;&amp; nums) {
        if(nums.empty()) return -1;
        int first=0,last=nums.size()-1,mid;
        while(first&lt;last){
            mid=first+(last-first)/2;
            if(nums[mid]&lt;nums[first])
                last=mid;
            else if(nums[mid]&gt;nums[last])
                first=mid+1;
            else
                return nums[first];
        }
        return nums[first];
    }
};
</code></pre>
<p>然后来看看官方题解：</p>
<blockquote>
<p>方法 1：二分搜索<br>
想法<br>
一种暴力的解法是搜索整个数组，找到其中的最小元素，这样的时间复杂度是 O(N)其中 N 是给定数组的大小。<br>
一个非常棒的解决该问题的办法是使用二分搜索。在二分搜索中，我们找到区间的中间点并根据某些条件决定去区间左半部分还是右半部分搜索。<br>
由于给定的数组是有序的，我们就可以使用二分搜索。然而，数组被旋转了，所以简单的使用二分搜索并不可行。<br>
在这个问题中，我们使用一种改进的二分搜索，判断条件与标准的二分搜索有些不同。<br>
我们希望找到旋转排序数组的最小值，如果数组没有被旋转呢？如何检验这一点呢？<br>
如果数组没有被旋转，是升序排列，就满足 last element &gt; first element。</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1576292058115.png" alt=""></p>
<blockquote>
<p>在这个改进版本的二分搜索算法中，我们需要找到这个点。下面是关于变化点的特点：<br>
所有变化点左侧元素 &gt; 数组第一个元素<br>
所有变化点右侧元素 &lt; 数组第一个元素<br>
算法<br>
找到数组的中间元素 mid。<br>
如果中间元素 &gt; 数组第一个元素，我们需要在 mid 右边搜索变化点。<br>
如果中间元素 &lt; 数组第一个元素，我们需要在 mid 做边搜索变化点。</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1576292147178.png" alt=""></p>
<pre><code>class Solution {
  public int findMin(int[] nums) {
    // If the list has just one element then return that element.
    if (nums.length == 1) {
      return nums[0];
    }

    // initializing left and right pointers.
    int left = 0, right = nums.length - 1;

    // if the last element is greater than the first element then there is no rotation.
    // e.g. 1 &lt; 2 &lt; 3 &lt; 4 &lt; 5 &lt; 7. Already sorted array.
    // Hence the smallest element is first element. A[0]
    if (nums[right] &gt; nums[0]) {
      return nums[0];
    }
    
    // Binary search way
    while (right &gt;= left) {
      // Find the mid element
      int mid = left + (right - left) / 2;

      // if the mid element is greater than its next element then mid+1 element is the smallest
      // This point would be the point of change. From higher to lower value.
      if (nums[mid] &gt; nums[mid + 1]) {
        return nums[mid + 1];
      }

      // if the mid element is lesser than its previous element then mid element is the smallest
      if (nums[mid - 1] &gt; nums[mid]) {
        return nums[mid];
      }

      // if the mid elements value is greater than the 0th element this means
      // the least value is still somewhere to the right as we are still dealing with elements
      // greater than nums[0]
      if (nums[mid] &gt; nums[0]) {
        left = mid + 1;
      } else {
        // if nums[0] is greater than the mid value then this means the smallest value is somewhere to
        // the left
        right = mid - 1;
      }
    }
    return -1;
  }
｝
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：和二分搜索一样O(logN)<br>
空间复杂度：O(1)</p>
</blockquote>
<p>其实官网的思路和我的一致，不过官网的更加优雅，把正常情况和左边异常情况合为一起了，我判断的条件更多，也能早那么一点结束循环。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于信号与信号处理程序（SIGCHLD和waitpid）]]></title>
        <id>https://lixin-ee.github.io//post/guan-yu-xin-hao-yu-xin-hao-chu-li-cheng-xu-sigchld-he-waitpid</id>
        <link href="https://lixin-ee.github.io//post/guan-yu-xin-hao-yu-xin-hao-chu-li-cheng-xu-sigchld-he-waitpid">
        </link>
        <updated>2019-12-14T01:54:58.000Z</updated>
        <content type="html"><![CDATA[<p>在阅读UNP第五章的子进程处理僵死进程的时候出了点小问题<br>
主要就是在子进程结束后会发送SIGCHLD信号给父进程<br>
然后父进程需要处理这个已经变成僵死进程的子进程，否则就会占用内核空间，如果是巨型web服务器这样会耗尽进程资源直接木大。<br>
但是注意僵死进程本身并非一个bug或者副产物，因为设置僵死状态的目的是维护子进程的信息，以便父进程可以在以后某个时候获取子进程的进程id、终止状态以及资源利用信息，正确处理好僵死进程能让它变成纯正效应的。</p>
<p>然后5.7-5.10主要就是讲述了大型服务器上多个子进程同时结束会怎么样</p>
<p>首先明确一个概念是信号不排队<br>
这句话其实有点歧义，正解应该是实时信号会排队，但是队列中多个相同信号只能排一个位置<br>
man 7 signal原文：</p>
<blockquote>
<ol>
<li>Multiple instances of real-time signals can be queued. By contrast, if multiple instances of a standard signal are delivered while that signal is currently blocked, then only one instance is queued.</li>
</ol>
</blockquote>
<p>所以如果多个子进程结束返送SIGCHLD会导致只有一个SIGCHLD在排队</p>
<p>进入处理程序后，由于wait只执行一次，所以只能处理第一个僵死进程</p>
<p>所以达不到我们所希望的  每个SIGCHLD处理一次，因为SIGCHLD只有一个</p>
<p>那我们在一个SIGCHLD内循环调用wait不就行了吗？也不行，因为wait这家伙会阻塞父进程的，你就一直在那while那就不用干活了</p>
<p>这个时候waitpid就出场了，好家伙有个option，可以指定WNOHANG，让内核在没有已终止子进程时不要阻塞，所以可以疯狂while</p>
<p>现在进入主题了<br>
我一开始的问题是把SIGCHLD和waitpid这两者的关系弄错了<br>
虽然这两者的很紧密，一般是一起出现<br>
但是！！！没有因果关系先后关系和依附关系，wait只是信号处理函数中调用的一个函数<br>
而不是说必须有信号才能调用wait，你喜欢的话随时可以调用wait</p>
<p>摘录知乎匿名用户的回答：</p>
<blockquote>
<p>wait函数或者waitpid函数回收子进程又不是依据信号来的，发送SIGCHLD信号只是异步通知父进程一下而已，你排不排队和信号递交不递交与wait/waitpid又不相干，主进程循环调用wait/waitpid函数，函数去检查有没有死掉的子进程，并做相应处理，并不涉及到信号排队。</p>
</blockquote>
<p>也就是说就算SIGCHLD只能有一个在排队，只要合理利用waitpid就能处理好所有僵死进程，因为它会处理当前所有僵死进程<br>
无论是多少个SIGCHLD合为一个，waitpid都能处理好，并且！！！waitpid并不知道是多少个SIGCHLD合为一个，无法去直接了解到多少个，也不需要知道，它只需要利用while处理好所有能处理到的僵尸进程就好（注意waitpid的pid参数必须设置为-1）</p>
<p>就如同知乎用户payall4u的回答：</p>
<blockquote>
<p>假设,产生了四个子线程abcd,时间顺序大概是<br>
a.............b..c.d(假设bcd发生的时间间隔很短)<br>
a死亡触发handler,wait函数回收掉a,sleep,这时候父进程sleep,子进程b死亡,向主进程发送信号,父进程收到b发出的信号,处理b发生的信号.假设处理的同时,收到了c的信号,c信号进入等待队列,接下来收到d发出的信号,发现等待队列里存在SIGCHLD信号,父线程会毫不留情的丢弃(就是不接受,不是接受然后抛弃)d发出的信号.然后回收进程b,接下来通过两次for循环回收c,d,所以这里并不是父进程把d的信号列入队列,而是通过三次wait函数和把bcd都回收掉</p>
</blockquote>
<p>所以这个问题的核心在于，这两者是无关的<br>
我们需要做的只是在信号不重复排队的情况下运用wait等函数处理好就行，并非两者有依附关系。</p>
<p>最后附上waitpid的性质<br>
waitpid（等待子进程的中断和结束）</p>
<p>所需头文件<br>
#include &lt;sys/types.h&gt;<br>
#include &lt;sys/wait.h&gt;</p>
<p>函数说明<br>
waitpid()会暂时停止目前进程的执行，直到有信号来到或子进程结束。如果在调用waitpid()子进程已经结束，则waitpid()会立即返回子进程结束状态值。子进程的结束状态值会由参数status返回，而子进程的进程识别码也会一起返回。如果不在意结束状态值，则参数status可以设成NULL。参数pid为欲等待的子进程识别码</p>
<p>函数原型<br>
pid_t waitpid(pid_t pid,int * status,int options)<br>
函数传入值<br>
pid<br>
&lt;-1：等待进程组识别码为pid绝对值的任何子进程<br>
-1: 等待任何子进程，相当于wait()<br>
0：等待进程组识别码与目前进程相同的任何子进程<br>
&gt;0：等待任何子进程识别码为pid的子进程</p>
<p>options<br>
参数options可以为0 或下面的OR 组合<br>
WNOHANG：如果没有任何已经结束的子进程则马上返回，不予以等待。此时返回值为0<br>
WUNTRACED：如果子进程进入暂停执行情况则马上返回，但结束状态不予以理会</p>
<p>参考资料：<a href="https://www.zhihu.com/question/50613096">unp中说Linux信号不排队，如何解释下面的情况？</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二分查找 81. 搜索旋转排序数组 II[中等]]]></title>
        <id>https://lixin-ee.github.io//post/81-sou-suo-xuan-zhuan-pai-xu-shu-zu-ii</id>
        <link href="https://lixin-ee.github.io//post/81-sou-suo-xuan-zhuan-pai-xu-shu-zu-ii">
        </link>
        <updated>2019-12-13T03:36:20.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br>
( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。<br>
编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br>
示例 1:<br>
输入: nums = [2,5,6,0,0,1,2], target = 0<br>
输出: true<br>
示例 2:<br>
输入: nums = [2,5,6,0,0,1,2], target = 3<br>
输出: false<br>
进阶:<br>
这是 搜索旋转排序数组 的延伸题目，本题中的 nums  可能包含重复元素。<br>
这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>//本来想着说将33题的代码稍微改一下就上马，结果8太行，比如这种例子[1,3,1,1,1]里面找3这种例子<br>
//本来想着说优先判断if(nums[mid]==nums[first]&amp;&amp;nums[mid]==nums[last])这个来处理特殊情况，但是始终没法处理[1,3,1,1,1]和[1,1,1,3,1]这两种相互矛盾的情况啊<br>
//扛不住了看了一下题解，没果然没那么简单啊，高赞回答还是用++first,--last;逐步解决的，但是时间复杂度只击败了30.63%，莫非有更好的解法？</p>
<pre><code>class Solution {
public:
    int search(vector&lt;int&gt;&amp; nums, int target) {
        if(nums.empty()) return 0;
        int first=0,last=nums.size()-1,mid;
        while(first&lt;last){
            mid=first+(last-first)/2;
            if(nums[mid]==nums[first]&amp;&amp;nums[mid]==nums[last]) ++first,--last;
            else if(nums[mid]&lt;nums[first]^target&lt;=nums[mid]^target&gt;=nums[first])
                first=mid+1;
            else
                last=mid;
        }
        if(nums[first]==target)
            return 1;
        return 0;
    }
};
</code></pre>
<p>来看一下网友题解：</p>
<blockquote>
<p>解题思路：<br>
本题是需要使用二分查找，怎么分是关键，举个例子：<br>
第一类<br>
10111 和 11101 这种。此种情况下 nums[start] == nums[mid]，分不清到底是前面有序还是后面有序，此时 start++ 即可。相当于去掉一个重复的干扰项。<br>
第二类<br>
2 3 4 5 6 7 1 这种，也就是 nums[start] &lt; nums[mid]。此例子中就是 2 &lt; 5；<br>
这种情况下，前半部分有序。因此如果 nums[start] &lt;=target&lt;nums[mid]，则在前半部分找，否则去后半部分找。<br>
第三类<br>
6 7 1 2 3 4 5 这种，也就是 nums[start] &gt; nums[mid]。此例子中就是 6 &gt; 2；<br>
这种情况下，后半部分有序。因此如果 nums[mid] &lt;target&lt;=nums[end]。则在后半部分找，否则去前半部分找。</p>
</blockquote>
<pre><code>public boolean search(int[] nums, int target) {
        if (nums == null || nums.length == 0) {
            return false;
        }
        int start = 0;
        int end = nums.length - 1;
        int mid;
        while (start &lt;= end) {
            mid = start + (end - start) / 2;
            if (nums[mid] == target) {
                return true;
            }
            if (nums[start] == nums[mid]) {
                start++;
                continue;
            }
            //前半部分有序
            if (nums[start] &lt; nums[mid]) {
                //target在前半部分
                if (nums[mid] &gt; target &amp;&amp; nums[start] &lt;= target) {
                    end = mid - 1;
                } else {  //否则，去后半部分找
                    start = mid + 1;
                }
            } else {
                //后半部分有序
                //target在后半部分
                if (nums[mid] &lt; target &amp;&amp; nums[end] &gt;= target) {
                    start = mid + 1;
                } else {  //否则，去后半部分找
                    end = mid - 1;

                }
            }
        }
        //一直没找到，返回false
        return false;

    }
</code></pre>
<p>最后还是发现无法优雅地处理重复元素的情况，只能一点一点夹逼，在最坏的情况下 比如111...1112111...111的情况下直接退化成时间复杂度为O（n）的顺序查找<br>
然后评论里顺序查找直接击败了100%hhh</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二分查找 33. 搜索旋转排序数组[中等][未做出]]]></title>
        <id>https://lixin-ee.github.io//post/er-fen-cha-zhao-33-sou-suo-xuan-zhuan-pai-xu-shu-zu-zhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/er-fen-cha-zhao-33-sou-suo-xuan-zhuan-pai-xu-shu-zu-zhong-deng-wei-zuo-chu">
        </link>
        <updated>2019-12-12T01:34:20.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br>
( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。<br>
搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。<br>
你可以假设数组中不存在重复的元素。<br>
你的算法时间复杂度必须是 O(log n) 级别。<br>
示例 1:<br>
输入: nums = [4,5,6,7,0,1,2], target = 0<br>
输出: 4<br>
示例 2:<br>
输入: nums = [4,5,6,7,0,1,2], target = 3<br>
输出: -1<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/search-in-rotated-sorted-array<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>//这道题的话我一开始的想法是；将mid和first和last比较，如果<br>
//没如果完呢，发现自己看错题目了，是进行旋转后再进行查找，而不是查找旋转点<br>
//旋转之后必定中间值大于最右值 小于最左值<br>
//所以需要对边界条件进行分情况监测<br>
//弃疗了，边界条件太复杂了，情况太多了</p>
<p>错误代码如下：</p>
<pre><code>class Solution {
public:
    int search(vector&lt;int&gt;&amp; nums, int target) {
        if(nums.empty())
            return -1;
        int first=0,last=nums.size()-1,mid;
        while(first&lt;last){
            mid=first+(last-first)/2;
            if(target==nums[mid])
                return mid;
            if(nums[first]&gt;nums[last]){
               if(target&gt;nums[last]&amp;&amp;target&lt;nums[first])
                   return -1;
                
                if(nums[mid]&gt;=nums[first])
                    if(target&gt;nums[mid]||target&lt;nums[first]) first=mid+1;
                    else last=mid;
                
                if(nums[mid]&lt;=nums[first])
                    if(target&gt;nums[mid]||target&lt;nums[first]) last=mid;
                    else first=mid+1;
            }else{
                if(target&lt;nums[mid]) last=mid;
                else first=mid+1;
            }   
					}
        if(nums[first]==target) return first; 
        return -1; 
    }
};
</code></pre>
<p>补充<br>
//最后看了题解，这个异或太6了，实在是太6了</p>
<pre><code>class Solution {
public:
    int search(vector&lt;int&gt;&amp; nums, int target) {
        if(nums.empty()) return -1;
        int first=0,last=nums.size()-1,mid;
        while(first&lt;last){
            mid=first+(last-first)/2;
            if(nums[mid]&lt;nums[first]^target&lt;=nums[mid]^target&gt;=nums[first])
                first=mid+1;
            else
                last=mid;
        }
        if(nums[first]==target)
            return first;
        return -1;
    }
};
</code></pre>
<p>然后是网友原题解</p>
<pre><code>class Solution {
public:
    int search(vector&lt;int&gt;&amp; nums, int target) {
        int lo = 0, hi = nums.size() - 1;
        while (lo &lt; hi) {
            int mid = (lo + hi) / 2;
            if ((nums[0] &gt; target) ^ (nums[0] &gt; nums[mid]) ^ (target &gt; nums[mid]))
                lo = mid + 1;
            else
                hi = mid;
        }
        return lo == hi &amp;&amp; nums[lo] == target ? lo : -1;
    }
};
</code></pre>
<blockquote>
<p>以二分搜索为基本思路</p>
</blockquote>
<blockquote>
<p>简要来说：<br>
nums[0] &lt;= nums[mid]（0 - mid不包含旋转）且nums[0] &lt;= target &lt;= nums[mid] 时 high 向前规约；<br>
nums[mid] &lt; nums[0]（0 - mid包含旋转），target &lt;= nums[mid] &lt; nums[0] 时向前规约（target 在旋转位置到 mid 之间）<br>
nums[mid] &lt; nums[0]，nums[mid] &lt; nums[0] &lt;= target 时向前规约（target 在 0 到旋转位置之间）<br>
其他情况向后规约<br>
也就是说nums[mid] &lt; nums[0]，nums[0] &gt; target，target &gt; nums[mid] 三项均为真或者只有一项为真时向后规约。</p>
</blockquote>
<blockquote>
<p>原文的分析是：<br>
注意到原数组为有限制的有序数组（除了在某个点会突然下降外均为升序数组）<br>
if nums[0] &lt;= nums[I] 那么 nums[0] 到 nums[i] 为有序数组,那么当 nums[0] &lt;= target &lt;= nums[i] 时我们应该在 0-i0−i 范围内查找；<br>
if nums[i] &lt; nums[0] 那么在 0-i0−i 区间的某个点处发生了下降（旋转），那么 I+1I+1 到最后一个数字的区间为有序数组，并且所有的数字都是小于 nums[0] 且大于 nums[i]，当target不属于 nums[0] 到 nums[i] 时（target &lt;= nums[i] &lt; nums[0] or nums[i] &lt; nums[0] &lt;= target），我们应该在 0-i0−i 区间内查找。<br>
上述三种情况可以总结如下：<br>
nums[0] &lt;= target &lt;= nums[i]<br>
target &lt;= nums[i] &lt; nums[0]<br>
nums[i] &lt; nums[0] &lt;= target<br>
所以我们进行三项判断：<br>
(nums[0] &lt;= target)， (target &lt;= nums[i]) ，(nums[i] &lt; nums[0])，现在我们想知道这三项中有哪两项为真（明显这三项不可能均为真或均为假（因为这三项可能已经包含了所有情况））<br>
所以我们现在只需要区别出这三项中有两项为真还是只有一项为真。<br>
使用 “异或” 操作可以轻松的得到上述结果（两项为真时异或结果为假，一项为真时异或结果为真，可以画真值表进行验证）<br>
之后我们通过二分查找不断做小 target 可能位于的区间直到 low==high，此时如果 nums[low]==target 则找到了，如果不等则说明该数组里没有此项。</p>
</blockquote>
<p>剩下的网友题解就和这个大同小异了</p>
<p>然后是官方的通用题解，虽然复杂一点，但是寻找旋转点的方法通用性更高</p>
<blockquote>
<p>方法：二分查找<br>
题目要找到一种 O(logN)时间内的搜索方法，这提示我们可以用二分查找的方法。<br>
算法非常直接：<br>
找到旋转的下标 rotation_index ，也就是数组中最小的元素。二分查找在这里可以派上用场。<br>
在选中的数组区域中再次使用二分查找。</p>
</blockquote>
<pre><code>class Solution {
  int [] nums;
  int target;

  public int find_rotate_index(int left, int right) {
    if (nums[left] &lt; nums[right])
      return 0;

    while (left &lt;= right) {
      int pivot = (left + right) / 2;
      if (nums[pivot] &gt; nums[pivot + 1])
        return pivot + 1;
      else {
        if (nums[pivot] &lt; nums[left])
          right = pivot - 1;
        else
          left = pivot + 1;
      }
    }
    return 0;
  }

  public int search(int left, int right) {
    /*
    Binary search
    */
    while (left &lt;= right) {
      int pivot = (left + right) / 2;
      if (nums[pivot] == target)
        return pivot;
      else {
        if (target &lt; nums[pivot])
          right = pivot - 1;
        else
          left = pivot + 1;
      }
    }
    return -1;
  }

  public int search(int[] nums, int target) {
    this.nums = nums;
    this.target = target;

    int n = nums.length;

    if (n == 0)
      return -1;
    if (n == 1)
      return this.nums[0] == target ? 0 : -1;

    int rotate_index = find_rotate_index(0, n - 1);

    // if target is the smallest element
    if (nums[rotate_index] == target)
      return rotate_index;
    // if array is not rotated, search in the entire array
    if (rotate_index == 0)
      return search(0, n - 1);
    if (target &lt; nums[0])
      // search in the right side
      return search(rotate_index, n - 1);
    // search in the left side
    return search(0, rotate_index);
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度： O(logN)。<br>
空间复杂度： O(1) 。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二分查找法模板]]></title>
        <id>https://lixin-ee.github.io//post/er-fen-cha-zhao-fa-mo-ban</id>
        <link href="https://lixin-ee.github.io//post/er-fen-cha-zhao-fa-mo-ban">
        </link>
        <updated>2019-12-11T01:13:28.000Z</updated>
        <content type="html"><![CDATA[<p>原文转自<a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/">二分查找法模板-liweiwei1419</a></p>
<p>其实二分查找法主要就是边界问题比较麻烦，我个人的理解是mid的左倾和右倾的问题，但是我个人也表述得不是很好，所以转发一下网友的优秀题解，以供日后使用<br>
下面开始是原文：</p>
<p>1、导读<br>
本文介绍了我这半年以来，在刷题过程中使用“二分查找法”刷题的一个模板，包括这个模板的优点、使用技巧、注意事项、调试方法等。虽说是模板，但我不打算一开始就贴出代码，因为这个模板根本没有必要记忆，只要你能够理解文中叙述的知识点和注意事项，并加以应用（刷题），相信你会和我一样喜欢这个模板，并且认为使用它是自然而然的事情。</p>
<p>这个模板应该能够帮助你解决 LeetCode 带“二分查找”标签的常见问题（简单、中等难度）。只要你能够理解文中叙述的知识点和注意事项，并加以应用（其实就是多刷题），相信你会和我一样喜欢这个模板，并且认为使用它是自然而然的事情。</p>
<p>3、“传统的”二分查找法模板的问题<br>
（1）取中位数索引的代码有问题<br>
<code>int mid = (left + right) / 2</code><br>
这行代码是有问题的，在 left 和 right 都比较大的时候，left + right 很有可能超过 int 类型能表示的最大值，即整型溢出，为了避免这个问题，应该写成：<br>
<code>int mid = left + (right - left) / 2 ;</code><br>
事实上，int mid = left + (right - left) / 2 在 right 很大、 left 是负数且很小的时候， right - left 也有可能超过 int 类型能表示的最大值，只不过一般情况下 left 和 right 表示的是数组索引值，left 是非负数，因此 right - left 溢出的可能性很小。</p>
<p>更好的写法是：<br>
<code>int mid = (left + right) &gt;&gt;&gt; 1 ;</code><br>
原因在后文介绍，请读者留意：</p>
<p>使用“左边界索引 + 右边界索引”，然后“无符号右移 1 位”是推荐的写法。</p>
<p>（2）循环可以进行的条件写成 while (left &lt;= right) 时，在退出循环的时候，需要考虑返回 left 还是 right，稍不注意，就容易出错<br>
以本题（LeetCode 第 35 题：搜索插入位置）为例。<br>
分析：根据题意并结合题目给出的 4 个示例，不难分析出这个问题的等价表述如下：<br>
1、如果目标值（严格）大于排序数组的最后一个数，返回这个排序数组的长度，否则进入第 2 点。<br>
2、返回排序数组从左到右，大于或者等于目标值的第 1 个数的索引。</p>
<p>事实上，当给出数组中有很多数和目标值相等的时候，我们返回任意一个与之相等的数的索引值都可以，不过为了简单起见，也为了方便后面的说明，我们返回第 1 个符合题意的数的索引。</p>
<p>题目告诉你“排序数组”，其实就是在疯狂暗示你用二分查找法。 二分查找法的思想并不难，但写好一个二分法并不简单，下面就借着这道题为大家做一个总结。</p>
<p>刚接触二分查找法的时候，我们可能会像下面这样写代码，我把这种写法容易出错的地方写在了注释里：<br>
参考代码：针对本题（LeetCode 第 35 题）</p>
<pre><code>public class Solution3 {

    public int searchInsert(int[] nums, int target) {
        int len = nums.length;
        if (nums[len - 1] &lt; target) {
            return len;
        }

        int left = 0;
        int right = len - 1;

        while (left &lt;= right) {
            int mid = (left + right) / 2;
            // 等于的情况最简单，我们应该放在第 1 个分支进行判断
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] &lt; target) {
                // 题目要我们返回大于或者等于目标值的第 1 个数的索引
                // 此时 mid 一定不是所求的左边界，
                // 此时左边界更新为 mid + 1
                left = mid + 1;
            } else {
                // 既然不会等于，此时 nums[mid] &gt; target
                // mid 也一定不是所求的右边界
                // 此时右边界更新为 mid - 1
                right = mid - 1;
            }
        }
        // 注意：一定得返回左边界 left，
        // 如果返回右边界 right 提交代码不会通过
        // 【注意】下面我尝试说明一下理由，如果你不太理解下面我说的，那是我表达的问题
        // 但我建议你不要纠结这个问题，因为我将要介绍的二分查找法模板，可以避免对返回 left 和 right 的讨论

        // 理由是对于 [1,3,5,6]，target = 2，返回大于等于 target 的第 1 个数的索引，此时应该返回 1
        // 在上面的 while (left &lt;= right) 退出循环以后，right &lt; left，right = 0 ，left = 1
        // 根据题意应该返回 left，
        // 如果题目要求你返回小于等于 target 的所有数里最大的那个索引值，应该返回 right
				
        return left;
    }
}
</code></pre>
<p>说明：<br>
1、当把二分查找法的循环可以进行的条件写成 while (left &lt;= right) 时，在写最后一句 return 的时候，如果不假思索，把左边界 left 返回回去，虽然写对了，但可以思考一下为什么不返回右边界 right 呢？<br>
2、但是事实上，返回 left 是有一定道理的，如果题目换一种问法，你可能就要返回右边界 right，这句话不太理解没有关系，我也不打算讲得很清楚（在上面代码的注释中我已经解释了原因），因为实在太绕了，这不是我要说的重点。</p>
<p>由此，我认为“传统二分查找法模板”使用的痛点在于：<br>
传统二分查找法模板，当退出 while 循环的时候，在返回左边界还是右边界这个问题上，比较容易出错。<br>
那么，是不是可以回避这个问题呢？答案是肯定的，答案就在下面我要介绍的“神奇的”二分查找法模板里。</p>
<p>4、“神奇的”二分查找法模板的基本思想<br>
（1）首先把循环可以进行的条件写成 while(left &lt; right)，在退出循环的时候，一定有 left == right 成立，此时返回 left 或者 right 都可以<br>
或许你会问：退出循环的时候还有一个数没有看啊（退出循环之前索引 left 或 索引 right 上的值）？<br>
没有关系，我们就等到退出循环以后来看，甚至经过分析，有时都不用看，就能确定它是目标数值。<br>
（什么时候需要看最后剩下的那个数，什么时候不需要，会在第 5 点介绍。）<br>
更深层次的思想是“夹逼法”或者称为“排除法”。</p>
<p>（2）“神奇的”二分查找法模板的基本思想（特别重要）<br>
“排除法”即：在每一轮循环中排除一半以上的元素，于是在对数级别的时间复杂度内，就可以把区间“夹逼” 只剩下 1 个数，而这个数是不是我们要找的数，单独做一次判断就可以了。<br>
“夹逼法”或者“排除法”是二分查找算法的基本思想，“二分”是手段，在目标元素不确定的情况下，“二分” 也是“最大熵原理”告诉我们的选择。<br>
还是 LeetCode 第 35 题，下面给出使用 while (left &lt; right) 模板写法的 2 段参考代码，以下代码的细节部分在后文中会讲到，因此一些地方不太明白没有关系，暂时跳过即可。</p>
<pre><code>public class Solution {

    public int searchInsert(int[] nums, int target) {
        int len = nums.length;

        if (len == 0) {
            return 0;
        }

        int left = 0;
        int right = len;

        while (left &lt; right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] &lt; target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }
}
</code></pre>
<p>参考代码 2：对于是否接在原有序数组后面单独判断，不满足的时候，再在候选区间的索引范围 [0, size - 1] 内使用二分查找法进行搜索。</p>
<pre><code>public class Solution {

    // 只会把比自己大的覆盖成小的
    // 二分法
    // 如果有一连串数跟 target 相同，则返回索引最靠前的

    // 特例： 3 5 5 5 5 5 5 5 5 5
    // 特例： 3 6 7 8

    // System.out.println(&quot;尝试过的值：&quot; + mid);
    // 1 2 3 5 5 5 5 5 5 6 ，target = 5
    // 1 2 3 3 5 5 5 6 target = 4


    public int searchInsert(int[] nums, int target) {
        int len = nums.length;
        if (len == 0) {
            return -1;
        }
        if (nums[len - 1] &lt; target) {
            return len;
        }
        int left = 0;
        int right = len - 1;
        while (left &lt; right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] &lt; target) {
                // nums[mid] 的值可以舍弃
                left = mid + 1;
            } else {
                // nums[mid] 不能舍弃
                right = mid;
            }
        }
        return right;
    }

    public static void main(String[] args) {
        int[] nums = {1, 2, 3, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6};
        int target = 4;
        Solution2 solution2 = new Solution2();
        int searchInsert = solution2.searchInsert(nums, target);
        System.out.println(searchInsert);
    }
}
</code></pre>
<p>5、细节、注意事项、调试方法<br>
（1）前提：思考左、右边界，如果左、右边界不包括目标数值，会导致错误结果<br>
例：LeetCode 第 69 题：x 的平方根</p>
<p>实现 int sqrt(int x) 函数。</p>
<p>计算并返回 x 的平方根，其中 x 是非负整数。</p>
<p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<p>分析：一个非负整数的平方根最小可能是 0 ，最大可能是它自己。<br>
因此左边界可以取 0 ，右边界可以取 x。<br>
可以分析得再细一点，但这道题没有必要，因为二分查找法会帮你排除掉不符合的区间元素。</p>
<p>例：LeetCode 第 287 题：寻找重复数</p>
<p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p>
<p>分析：题目告诉我们“其数字都在 1 到 n 之间（包括 1 和 n）”。因此左边界可以取 1 ，右边界可以取 n。</p>
<p>要注意 2 点：</p>
<p>如果 left 和 right 表示的是数组的索引，就要考虑“索引是否有效” ，即“索引是否越界” 是重要的定界依据；</p>
<p>左右边界一定要包括目标元素，例如 LeetCode 第 35 题：“搜索插入位置” ，当 target 比数组中的最后一个数字还要大（不能等于）的时候，插入元素的位置就是数组的最后一个位置 + 1，即 (len - 1 + 1 =) len，如果忽略掉这一点，把右边界定为 len - 1 ，代码就不能通过在线测评。</p>
<p>（2）中位数先写 int mid = (left + right) &gt;&gt;&gt; 1 ; 根据循环里分支的编写情况，再做调整<br>
理解这一点，首先要知道：当数组的元素个数是偶数的时候，中位数有左中位数和右中位数之分。</p>
<p>当数组的元素个数是偶数的时候：<br>
使用 int mid = left + (right - left) / 2 ; 得到左中位数的索引；</p>
<p>使用 int mid = left + (right - left + 1) / 2 ; 得到右中位数的索引。</p>
<p>当数组的元素个数是奇数的时候，以上二者都能选到最中间的那个中位数。<br>
其次，</p>
<p>int mid = left + (right - left) / 2 ; 等价于 int mid = (left + right) &gt;&gt;&gt; 1；</p>
<p>int mid = left + (right - left + 1) / 2 ; 等价于 int mid = (left + right + 1) &gt;&gt;&gt; 1 。</p>
<p>我们使用一个具体的例子来验证：当左边界索引 left = 3，右边界索引 right = 4 的时候，</p>
<p>mid1 = left + (right - left) // 2 = 3 + (4 - 3) // 2 = 3 + 0 = 3，</p>
<p>mid2 = left + (right - left + 1) // 2 = 3 + (4 - 3 + 1) // 2 = 3 + 1 = 4。</p>
<p>左中位数 mid1 是索引 left，右中位数 mid2 是索引 right。</p>
<p>记忆方法：</p>
<p>(right - left) 不加 11 选左中位数，加 11 选右中位数。</p>
<p>那么，什么时候使用左中位数，什么时候使用右中位数呢？选中位数的依据是为了避免死循环，得根据分支的逻辑来选择中位数，而分支逻辑的编写也有技巧，下面具体说。</p>
<p>（3）先写逻辑上容易想到的分支逻辑，这个分支逻辑通常是排除中位数的逻辑；<br>
在逻辑上，“可能是也有可能不是”让我们感到犹豫不定，但**“一定不是”是我们非常坚决的，通常考虑的因素特别单一，因此“好想” **。在生活中，我们经常听到这样的话：找对象时，“有车、有房，可以考虑，但没有一定不要”；找工作时，“事儿少、离家近可以考虑，但是钱少一定不去”，就是这种思想的体现。</p>
<p>例：LeetCode 第 69 题：x 的平方根</p>
<p>实现 int sqrt(int x) 函数。</p>
<p>计算并返回 x 的平方根，其中 x 是非负整数。</p>
<p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<p>分析：因为题目中说“返回类型是整数，结果只保留整数的部分，小数部分将被舍去”。例如 55 的平方根约等于 2.2362.236，在这道题应该返回 22。因此如果一个数的平方小于或者等于 x，那么这个数有可能是也有可能不是 x 的平方根，但是能很肯定的是，如果一个数的平方大于 x ，这个数肯定不是 x 的平方根。</p>
<p>注意：先写“好想”的分支，排除了中位数之后，通常另一个分支就不排除中位数，而不必具体考虑另一个分支的逻辑的具体意义，且代码几乎是固定的。</p>
<p>（4）循环内只写两个分支，一个分支排除中位数，另一个分支不排除中位数，循环中不单独对中位数作判断<br>
既然是“夹逼”法，没有必要在每一轮循环开始前单独判断当前中位数是否是目标元素，因此分支数少了一支，代码执行效率更高。</p>
<p>以下是“排除中位数的逻辑”思考清楚以后，可能出现的两个模板代码。<br>
<img src="https://lixin-ee.github.io//post-images/1576028651703.png" alt=""><br>
可以排除“中位数”的逻辑，通常比较好想，但并不绝对，这一点视情况而定。</p>
<p>分支条数变成 2 条，比原来 3 个分支要考虑的情况少，好处是：</p>
<p>不用在每次循环开始单独考虑中位数是否是目标元素，节约了时间，我们只要在退出循环的时候，即左右区间压缩成一个数（索引）的时候，去判断这个索引表示的数是否是目标元素，而不必在二分的逻辑中单独做判断。</p>
<p>这一点很重要，希望读者结合具体练习仔细体会，每次循环开始的时候都单独做一次判断，在统计意义上看，二分时候的中位数恰好是目标元素的概率并不高，并且即使要这么做，也不是普适性的，不能解决绝大部分的问题。</p>
<p>还以 LeetCode 第 35 题为例，通过之前的分析，我们需要找到“大于或者等于目标值的第 1 个数的索引”。对于这道题而言：</p>
<p>（1）如果中位数小于目标值，它就应该被排除，左边界 left 就至少是 mid + 1；</p>
<p>（2）如果中位数大于等于目标值，还不能够肯定它就是我们要找的数，因为要找的是等于目标值的第 11 个数的索引，中位数以及中位数的左边都有可能是符合题意的数，因此右边界就不能把 mid 排除，因此右边界 right 至多是 mid，此时右边界不向左边收缩。</p>
<p>下一点就更关键了。</p>
<p>（5）根据分支逻辑选择中位数的类型，可能是左中位数，也可能是右位数，选择的标准是避免死循环<br>
<img src="https://lixin-ee.github.io//post-images/1576028680066.png" alt=""><br>
死循环容易发生在区间只有 22 个元素时候，此时中位数的选择尤为关键。选择中位数的依据是：避免出现死循环。我们需要确保：</p>
<p>（下面的这两条规则说起来很绕，可以暂时跳过）。</p>
<p>1、如果分支的逻辑，在选择左边界的时候，不能排除中位数，那么中位数就选“右中位数”，只有这样区间才会收缩，否则进入死循环；</p>
<p>2、同理，如果分支的逻辑，在选择右边界的时候，不能排除中位数，那么中位数就选“左中位数”，只有这样区间才会收缩，否则进入死循环。</p>
<p>理解上面的这个规则可以通过具体的例子。针对以上规则的第 1 点：如果分支的逻辑，在选择左边界的时候不能排除中位数，例如：</p>
<pre><code>while left &lt; right:
      # 不妨先写左中位数，看看你的分支会不会让你代码出现死循环，从而调整
    mid = left + (right - left) // 2
    # 业务逻辑代码
    if (check(mid)):
        # 选择右边界的时候，可以排除中位数
        right = mid - 1
    else:
        # 选择左边界的时候，不能排除中位数
        left = mid
</code></pre>
<p>在区间中的元素只剩下 22 个时候，例如：left = 3，right = 4。此时左中位数就是左边界，如果你的逻辑执行到 left = mid 这个分支，且你选择的中位数是左中位数，此时左边界就不会得到更新，区间就不会再收缩（理解这句话是关键），从而进入死循环；<br>
为了避免出现死循环，你需要选择中位数是右中位数，当逻辑执行到 left = mid 这个分支的时候，因为你选择了右中位数，让逻辑可以转而执行到 right = mid - 1 让区间收缩，最终成为 1 个数，退出 while 循环。<br>
上面这段话不理解没有关系，因为我还没有举例子，你有个印象就好，类似地，理解选择中位数的依据的第 2 点。</p>
<p>（6）退出循环的时候，可能需要对“夹逼”剩下的那个数单独做一次判断，这一步称之为“后处理”。<br>
二分查找法之所以高效，是因为它利用了数组有序的特点，在每一次的搜索过程中，都可以排除将近一半的数，使得搜索区间越来越小，直到区间成为一个数。回到这一节最开始的疑问：“区间左右边界相等（即收缩成 1 个数）时，这个数是否会漏掉”，解释如下：</p>
<p>1、如果你的业务逻辑保证了你要找的数一定在左边界和右边界所表示的区间里出现，那么可以放心地返回 left 或者 right，无需再做判断；</p>
<p>2、如果你的业务逻辑不能保证你要找的数一定在左边界和右边界所表示的区间里出现，那么只要在退出循环以后，再针对 nums[left] 或者 nums[right] （此时 nums[left] == nums[right]）单独作一次判断，看它是不是你要找的数即可，这一步操作常常叫做“后处理”。</p>
<p>如果你能确定候选区间里目标元素一定存在，则不必做“后处理”。<br>
例：LeetCode 第 69 题：x 的平方根</p>
<p>实现 int sqrt(int x) 函数。</p>
<p>计算并返回 x 的平方根，其中 x 是非负整数。</p>
<p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<p>分析：非负实数 x 的平方根在 [0, x] 内一定存在，故退出 while (left &lt; right) 循环以后，不必单独判断 left 或者 right 是否符合题意。</p>
<p>如果你不能确定候选区间里目标元素一定存在，需要单独做一次判断。<br>
例：LeetCode 第 704 题：二分查找</p>
<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<p>分析：因为目标数有可能不在数组中，当候选区间夹逼成一个数的时候，要单独判断一下这个数是不是目标数，如果不是，返回 -1。</p>
<p>（7）取中位数的时候，要避免在计算上出现整型溢出；<br>
int mid = (left + right) / 2; 的问题：在 left 和 right 很大的时候，left + right 会发生整型溢出，变成负数，这是一个 bug ，得改！</p>
<p>int mid = left + (right - left) / 2; 在 right 很大、 left 是负数且很小的时候， right - left 也有可能超过 int 类型能表示的最大值，只不过一般情况下 left 和 right 表示的是数组索引值，left 是非负数，因此 right - left 溢出的可能性很小。因此，它是正确的写法。下面介绍推荐的写法。</p>
<p>int mid = (left + right) &gt;&gt;&gt; 1; 如果这样写， left + right 在发生整型溢出以后，会变成负数，此时如果除以 22 ，mid 是一个负数，但是经过无符号右移，可以得到在不溢出的情况下正确的结果。</p>
<p>解释“无符号右移”：在 Java 中，无符号右移运算符 &gt;&gt;&gt; 和右移运算符 &gt;&gt; 的区别如下：</p>
<p>右移运算符 &gt;&gt; 在右移时，丢弃右边指定位数，左边补上符号位；<br>
无符号右移运算符 &gt;&gt;&gt; 在右移时，丢弃右边指定位数，左边补上 00，也就是说，对于正数来说，二者一样，而负数通过 &gt;&gt;&gt; 后能变成正数。<br>
下面解释上面的模板中，取中位数的时候使用先用“＋”，然后“无符号右移”。</p>
<p>1、int mid = (left + right) / 2 与 int mid = left + (right - left) / 2 两种写法都有整型溢出的风险，没有哪一个是绝对安全的，注意：这里我们取平均值用的是除以 2，并且是整除：</p>
<p>int mid = (left + right) / 2 在 left 和 right 都很大的时候会溢出；<br>
int mid = left + (right - left) / 2 在 right 很大，且 left 是负数且很小的时候会溢出；<br>
2、写算法题的话，一般是让你在数组中做二分查找，因此 left 和 right 一般都表示数组的索引，因此 left 在绝大多数情况下不会是负数并且很小，因此使用 int mid = left + (right - left) // 2 相对 int mid = (left + right) // 2 更安全一些，并且也能向别人展示我们注意到了整型溢出这种情况，但事实上，还有更好的方式；</p>
<p>3、建议使用 int mid = (left + right) &gt;&gt;&gt; 1 这种写法，其实是大有含义的：</p>
<p>JDK8 中采用 int mid = (left + right) &gt;&gt;&gt; 1 ，重点不在 + ，而在 &gt;&gt;&gt; 。</p>
<p>我们看极端的情况，left 和 high 都是整型最大值的时候，注意，此时 3232 位整型最大值它的二进制表示的最高位是 00，它们相加以后，最高位是 11 ，变成负数，但是再经过无符号右移 &gt;&gt;&gt;（重点是忽略了符号位，空位都以 00 补齐），就能保证使用 + 在整型溢出了以后结果还是正确的。</p>
<p>Java 中 Collections 和 Arrays 提供的 binarySearch 方法，我们点进去看 left 和 right 都表示索引，使用无符号右移又不怕整型溢出，那就用 int mid = (left + right) &gt;&gt;&gt; 1 好啦。位运算本来就比使用除法快，这样看来使用 + 和 &lt;&lt;&lt; 真的是又快又好了。</p>
<p>我想这一点可能是 JDK8 的编写者们更层次的考量。</p>
<p>看来以后写算法题，就用 int mid = (left + right) &gt;&gt;&gt; 1 吧，反正更多的时候 left 和 right 表示索引。</p>
<p>（8）编码一旦出现死循环，输出必要的变量值、分支逻辑是调试的重要方法。<br>
当出现死循环的时候的调试方法：打印输出左右边界、中位数的值和目标值、分支逻辑等必要的信息。</p>
<p>按照我的经验，一开始编码的时候，稍不注意就很容易出现死循环，不过没有关系，你可以你的代码中写上一些输出语句，就容易理解“在区间元素只有 2 个的时候容易出现死循环”。具体编码调试的细节，可以参考我在「力扣」第 69 题：x 的平方根的题解《二分查找 + 牛顿法（Python 代码、Java 代码）》 。</p>
<p>6、总结<br>
总结一下，我爱用这个模板的原因、技巧、优点和注意事项：</p>
<p>（1）原因：<br>
无脑地写 while left &lt; right: ，这样你就不用判断，在退出循环的时候你应该返回 left 还是 right，因为返回 left 或者 right 都对；</p>
<p>（2）技巧：<br>
先写分支逻辑，并且先写排除中位数的逻辑分支（因为更多时候排除中位数的逻辑容易想，但是前面我也提到过，这并不绝对），另一个分支的逻辑你就不用想了，写出第 1 个分支的反面代码即可（下面的说明中有介绍），再根据分支的情况选择使用左中位数还是右中位数；</p>
<p>说明：这里再多说一句。如果从代码可读性角度来说，只要是你认为好想的逻辑分支，就把它写在前面，并且加上你的注释，这样方便别人理解，而另一个分支，你就不必考虑它的逻辑了。有的时候另一个分支的逻辑并不太好想，容易把自己绕进去。如果你练习做得多了，会形成条件反射。</p>
<p>我简单总结了一下，左右分支的规律就如下两点：</p>
<p>如果第 1 个分支的逻辑是“左边界排除中位数”（left = mid + 1），那么第 2 个分支的逻辑就一定是“右边界不排除中位数”（right = mid），反过来也成立；</p>
<p>如果第 2 个分支的逻辑是“右边界排除中位数”（right = mid - 1），那么第 2 个分支的逻辑就一定是“左边界不排除中位数”（left = mid），反之也成立。</p>
<p>“反过来也成立”的意思是：如果在你的逻辑中，“边界不能排除中位数”的逻辑好想，你就把它写在第 1 个分支，另一个分支是它的反面，你可以不用管逻辑是什么，按照上面的规律直接给出代码就可以了。能这么做的理论依据就是“排除法”。</p>
<p>在「力扣」第 287 题：寻找重复数的题解《二分法（Python 代码、Java 代码）》和这篇题解的评论区中，有我和用户<br>
@fighterhit 给出的代码，在一些情况下，我们先写了不排除中位数的逻辑分支，更合适的标准就是“哪个逻辑分支好想，就先写哪一个”，欢迎大家参与讨论。</p>
<p>（3）优点：<br>
分支条数只有 2 条，代码执行效率更高，不用在每一轮循环中单独判断中位数是否符合题目要求，写分支的逻辑的目的是尽量排除更多的候选元素，而判断中位数是否符合题目要求我们放在最后进行，这就是第 5 点；</p>
<p>说明：每一轮循环开始都单独判断中位数是否符合要求，这个操作不是很有普适性，因为从统计意义上说，中位数直接就是你想找的数的概率并不大，有的时候还要看看左边，还要看看右边。不妨就把它放在最后来看，把候选区间“夹逼”到只剩 1 个元素的时候，视情况单独再做判断即可。</p>
<p>（4）注意事项 1：<br>
左中位数还是右中位数选择的标准根据分支的逻辑而来，标准是每一次循环都应该让区间收缩，当候选区间只剩下 2 个元素的时候，为了避免死循环发生，选择正确的中位数类型。如果你实在很晕，不防就使用有 2 个元素的测试用例，就能明白其中的原因，另外在代码出现死循环的时候，建议你可以将左边界、右边界、你选择的中位数的值，还有分支逻辑都打印输出一下，出现死循环的原因就一目了然了；</p>
<p>（5）注意事项 2：<br>
如果能确定要找的数就在候选区间里，那么退出循环的时候，区间最后收缩成为 1 个数后，直接把这个数返回即可；如果你要找的数有可能不在候选区间里，区间最后收缩成为 1 个数后，还要单独判断一下这个数是否符合题意。</p>
<p>最后给出两个模板，大家看的时候看注释，不必也无需记忆它们。<br>
<img src="https://lixin-ee.github.io//post-images/1576028920322.png" alt=""><br>
<img src="https://lixin-ee.github.io//post-images/1576028931626.png" alt=""><br>
说明：我写的时候，一般是先默认将中位数写成左中位数，再根据分支的情况，看看是否有必要调整成右中位数，即是不是要在 (right - left) 这个括号里面加 11 。</p>
<p>虽说是两个模板，区别在于选中位数，中位数根据分支逻辑来选，原则是区间要收缩，且不出现死循环，退出循环的时候，视情况，有可能需要对最后剩下的数单独做判断。</p>
<p>我想我应该是成功地把你绕晕了，如果您觉得啰嗦的地方，就当我是“重要的事情说了三遍”吧，确实是重点的地方我才会重复说。当然，最好的理解这个模板的方法还是应用它。在此建议您不妨多做几道使用“二分查找法”解决的问题，用一下我说的这个模板，在发现问题的过程中，体会这个模板好用的地方，相信你一定会和我一样爱上这个模板的。</p>
<p>在「力扣」的探索版块中，给出了二分查找法的 3 个模板，我这篇文章着重介绍了第 2 个模板，但是我介绍的角度和这个版块中给出的角度并不一样，第 1 个模板被我“嫌弃”了，第 3 个模板我看过了，里面给出的例题也可以用第 2 个模板来完成，如果大家有什么使用心得，欢迎与我交流。</p>
<p>在这里补充一个小细节：除以 2 这件事情，还可以用右移 1 位来代替，位移运算的效率更高些。具体来说是这样：</p>
<p>1、Python 代码</p>
<p>mid = left + (right - left) // 2<br>
可以替换成：</p>
<p>mid = (left + right) &gt;&gt; 1<br>
2、Java 代码</p>
<p>int mid = l + (r - l) / 2;<br>
可以替换成：</p>
<p>int mid = (left + right) &gt;&gt;&gt; 1;<br>
注意：Java 中要使用 &gt;&gt;&gt; 表示无符号右移，有符号位移是不行的。</p>
<p>你没有看错，请注意，我现在又告诉你取 (left + right) 的一半，但不是除以 2 ，而是无符号右移一位，理由如下：</p>
<p>1、left 和 right 一般表示数组或列表的索引，它们都是正数；</p>
<p>2、即使 left 和 right 都很大，对于 Java 语言来说，(left + right) 可能发生整型溢出，但是无符号右移一位仍然能够得到正确的结果，而 Python 整型溢出了以后，类型自动升为 long 类型。</p>
<p>所以，在理解的基础上记住这个结论：取中位数用“+” 和“无符号右移”更优，事实上，Java 的 JDK 就是这么做的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二分查找 35. 搜索插入位置[简单]]]></title>
        <id>https://lixin-ee.github.io//post/er-fen-cha-zhao-35-sou-suo-cha-ru-wei-zhi</id>
        <link href="https://lixin-ee.github.io//post/er-fen-cha-zhao-35-sou-suo-cha-ru-wei-zhi">
        </link>
        <updated>2019-12-11T00:49:52.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br>
你可以假设数组中无重复元素。<br>
示例 1:<br>
输入: [1,3,5,6], 5<br>
输出: 2<br>
示例 2:<br>
输入: [1,3,5,6], 2<br>
输出: 1<br>
示例 3:<br>
输入: [1,3,5,6], 7<br>
输出: 4<br>
示例 4:<br>
输入: [1,3,5,6], 0<br>
输出: 0<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/search-insert-position<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>//本来以为挺简单的，但是边界条件略麻烦啊<br>
//这道题难点就在于会出现边界问题，这两个点我单独提取出来判断<br>
//然后就是插入点的问题，是从0开始算的下标，所以必须取右半边<br>
//注意即使取右半边也不会出现大于size()-1的情况，所以两个边界条件最好还是单独判断</p>
<pre><code>class Solution {
public:
    int searchInsert(vector&lt;int&gt;&amp; nums, int target) {
        int first=0,last=nums.size()-1,mid;
        if(target&gt;nums.back())
            return nums.size();
        if(target&lt;nums.front())
            return 0;
        while(first&lt;last){
            mid=first+(last-first)/2;
            if(target==nums[mid])
                return mid;
            if(target&gt;nums[mid])
                first=mid+1;
            else
                last=mid;
        }
        return first;
    }
};
</code></pre>
<p>先来看看网友题解<br>
一个是dalao给出的二分查找法模板，我会新开一篇文章转发<br>
二是针对这道题的解法，我写得代码其实通用性高了一点，因为题目保证没有重复的元素，所有可以在边界条件上更宽松一点，主要的难点也是头和尾两个点之一了</p>
<pre><code>解法1：循环搜索
class Solution {
public:
    int searchInsert(vector&lt;int&gt;&amp; nums, int target) {
        int len=nums.size();
        if(len==0) return 0;
        for(int i=0;i&lt;len;i++)
        {
            if(nums[i]&gt;=target) return i;
        }
        return len;
    }
};
解法2：二分查找
class Solution {
public:
    int searchInsert(vector&lt;int&gt;&amp; nums, int target) {
        int mid=0;
        int head=0;
        int last=nums.size()-1;
        while(head&lt;last)
        {
            mid=(last-head)/2+head;
            if(target&gt;nums[mid])
            {
                head=mid+1;
            }
            else if(target&lt;nums[mid])
            {
                last=mid-1;
            }
            else return mid;
        }
        if(target&lt;=nums[head])//插入位置在开头的情况
            return head;
        return head+1;//插入位置在结尾的情况
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[快速排序法实现[未完成]]]></title>
        <id>https://lixin-ee.github.io//post/kuai-su-pai-xu-fa-shi-xian</id>
        <link href="https://lixin-ee.github.io//post/kuai-su-pai-xu-fa-shi-xian">
        </link>
        <updated>2019-12-10T12:59:38.000Z</updated>
        <content type="html"><![CDATA[<p>9.9快速排序<br>
希尔排序相当于直接插入排序的升级，它们同属于插入排序类，堆排序相当于简单选择排序的升级，它们同属于选择排序类。而快速排序其实就是我们前面认为最慢的冒泡排序的升级，它们都属于交换排序类。它也是通过不断比较和移动交换来实现排序的，只不过它的实现，增大了记录的比较和移动的距离</p>
<p>9.9.1快速排序算法<br>
快速排序（QuickSort）的基本思想是：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序</p>
<p>9.9.2快速排序复杂度分析<br>
快速排序的时间性能取决于快速排序递归的深度<br>
在最优情况下，Partition每次都划分得很均匀，如果排序n个关键字，其递归树的深度就为floor(logn)+1<br>
在最优的情况下，快速排序算法的时间复杂度为O(nlogn)<br>
在最坏的情况下，待排序的序列为正序或者逆序，每次划分只得到一个比上一次划分少一个记录的子序列，注意另一个为空, 时间复杂度为O(nlogn)<br>
空间复杂度来说，主要是递归造成的栈空间的使用，最好情况，递归树的深度为logn，其空间复杂度也就为O(logn)，最坏情况需要进行n-1次递归调用，其空间复杂度为〇(n),<br>
平均情况，空间复杂度也为〇(logn)。<br>
由于关键字的比较和交换是跳跃进行的，因此，快速排序是一种不稳定的排序方法。</p>
<p>第一份实现是我在<a href="https://lixin-ee.github.io/post/shu-zu-287-xun-zhao-chong-fu-shu/">数组 287. 寻找重复数 </a>中实现的，主要是基于迭代器的版本<br>
为了提高算法的泛型能力我用了迭代器（bidiretional iterator，支持++和--）而不是数组下标。书里的方法对于middle的两分法是分为 [low,middle-1]、 [middle+1,high] 对于数组下标来说这是小菜一碟，但是对于迭代器来说就不一样了，比如{1，0}这种情况当middle去到了边缘处，如果middle是迭代器，middle+1是没问题的，毕竟还有尾后迭代器，但是middle-1就8行了，所以只能用[low,middle]、 [middle+1,high]算是为了通用性牺牲了一点计算量吧。<br>
然后注意不要把vi.end()传给high了，必须是vi.end()-1。</p>
<pre><code>void QuickSort(vector&lt;int&gt; &amp;vi, vector&lt;int&gt;::iterator low, vector&lt;int&gt;::iterator high) {
	vector&lt;int&gt;::iterator middle;
	if (low &lt; high) {
		middle = partition(vi,low,high);
		QuickSort(vi, low, middle);
		QuickSort(vi, ++middle, high);
	}
}

vector&lt;int&gt;::iterator partition(vector&lt;int&gt; &amp;vi, vector&lt;int&gt;::iterator low, vector&lt;int&gt;::iterator high) {
	int pivotkey;
	if (low &lt; high)
		pivotkey = *low;
	while (low &lt; high) {
	while (low &lt; high&amp;&amp;pivotkey &lt;= *high) 
			--high;
	iter_swap(low, high);
		while (low &lt; high&amp;&amp;*low &lt;= pivotkey) 
			++low;
		iter_swap(low, high);	
	}
	return low;
}
</code></pre>
<p>第二个版本是我在354题中实现的数组下标版本，这个就和大话数据结构中的没啥区别了，和迭代器主要的区别也是在于mid-1</p>
<pre><code>void quicksort(vector&lt;int&gt; &amp;vi,int beg,int end){
        if(beg&lt;end){
            int mid=partition(vi,beg,end);
            quicksort(vi,beg,mid-1);
            quicksort(vi,mid+1,end);
        }
    }
    
    int partition(vector&lt;int&gt; &amp;vi,int low,int high){
        int pivotkey=vi[low];
        while(low&lt;high){
            while(low&lt;high&amp;&amp;pivotkey&lt;=vi[high])
                --high;
            swap(vi[low],vi[high]);
            while(low&lt;high&amp;&amp;vi[low]&lt;pivotkey)
                ++low;
            swap(vi[low],vi[high])；
        }
        return low;
    }
};
</code></pre>
<p>需要注意的点：<br>
1.忘了定义pivotkey，定义后又忘了用来比较pivotkey&lt;=vi[high]<br>
2.先--high再到++low，不小心弄反了<br>
3.下标版可以直接mid-1，因为int等于-1没事，迭代器则不能指向begin之前<br>
4.记得return low;<br>
5.每个while都必须判断low&lt;high，特别是循环中的两个while</p>
<p>9.9.3快速排序优化<br>
1.优化选取枢轴<br>
三数取中（median-of-three)法。即取三个关键字先进行排序，将中间数作为枢轴，一般是取左端、右端和中间三个数，也可以随机选取。这样至少这个中间数一定不会是最小或者最大的数<br>
九数取中,它先从数组中分三次取样，每次取三个数，三个样品各取出中数，然后从这三个中数当中再取出一个中数作为枢轴。</p>
<p>2.优化不必要的交换<br>
观察图9-9-1至图9-9-6,我们发现，50这个关键字，其位置变化是1—9—3—6—S,可 其实它的最终目标就是S,当中的交换其实是不需要的。因此我们对Partition函数的代码再进行 优化。</p>
<p>3.优化小数组时的排序方案<br>
如果数组非常小，其实快速排序反而不如直接插入排序来得更好（直接插入是简单排序中性能最好的）。其原因在于快速排序用到了递归操作</p>
<p>4 优化递归操作<br>
QSort函数在其尾部有两次递归操作。如果 待排序的序列划分极端不平衡，递归深度将趋近于n,而不是平衡时的logn，<br>
栈的大小是很有限的，每次递归调用都会耗费—定的栈空间，函数的 参数越多，每次递归耗费的空间也越多。因此如果能减少递归，将会大大提高性能。<br>
相当于处理好了1/2再对剩下的1/2进行处理<br>
当我们将if改成while后（见加粗代码部分），因为第一次递归以后，变量low就没有用 处了，所以可以将pivot+1赋值给low，再循环后，来一次Partition(L,low,high),其效果等同于QSort(L，pivot+1,high);结果相同，但因采用迭代而不是递归的方法可以缩减堆栈深 度，从而提高了整体性能。</p>
]]></content>
    </entry>
</feed>