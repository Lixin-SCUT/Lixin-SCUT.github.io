<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-05-01T04:11:26.123Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>千里之行，始于足下。不积跬步，无以至千里。</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[10. 规则特例 -Google C++编程规范]]></title>
        <id>https://lixin-scut.github.io//post/10-gui-ze-te-li-google-cbian-cheng-gui-fan</id>
        <link href="https://lixin-scut.github.io//post/10-gui-ze-te-li-google-cbian-cheng-gui-fan">
        </link>
        <updated>2020-05-01T04:07:22.000Z</updated>
        <content type="html"><![CDATA[<p>  前面说明的编程习惯基本都是强制性的. 但所有优秀的规则都允许例外, 这里就是探讨这些特例.</p>
<h3 id="101-现有不合规范的代码">10.1. 现有不合规范的代码</h3>
<p><strong>总述</strong></p>
<p>  对于现有不符合既定编程风格的代码可以网开一面.</p>
<p><strong>说明</strong></p>
<p>  <strong>当你修改使用其他风格的代码时, 为了与代码原有风格保持一致可以不使用本指南约定</strong>. 如果不放心, 可以与代码原作者或现在的负责人员商讨. 记住,<strong>一致性 也包括原有的一致性.</strong></p>
<h3 id="102-windows-代码">10.2. Windows 代码</h3>
<p><strong>总述</strong></p>
<p>  Windows 程序员有自己的编程习惯, 主要源于 Windows 头文件和其它 Microsoft 代码. 我们希望任何人都可以顺利读懂你的代码, 所以针对所有平台的 C++ 编程只给出一个单独的指南.</p>
<p><strong>说明</strong></p>
<p>  如果你习惯使用 Windows 编码风格, 这儿有必要重申一下某些你可能会忘记的指南:</p>
<ol>
<li>不要使用匈牙利命名法 (比如把整型变量命名成 iNum). 使用 Google 命名约定, 包括对源文件使用 .cc 扩展名.</li>
<li>Windows 定义了很多原生类型的同义词 (YuleFox 注: 这一点, 我也很反感), 如 DWORD, HANDLE 等等. 在调用 Windows API 时这是完全可以接受甚至鼓励的. 即使如此, 还是尽量使用原有的 C++ 类型, 例如使用 const TCHAR * 而不是 LPCTSTR.</li>
<li>使用 Microsoft Visual C++ 进行编译时, 将警告级别设置为 3 或更高, 并将所有警告(warnings)当作错误(errors)处理.</li>
<li><strong>不要使用 #pragma once; 而应该使用 Google 的头文件保护规则</strong>. 头文件保护的路径应该相对于项目根目录 (Yang.Y 注: 如 #ifndef SRC_DIR_BAR_H_, 参考 #define 保护 一节).</li>
<li><strong>除非万不得已, 不要使用任何非标准的扩展, 如 #pragma 和declspec.</strong><br>
使用__declspec(dllimport) 和__declspec(dllexport) 是允许的, 但必须通过宏来使用, 比如 DLLIMPORT 和 DLLEXPORT, 这样其他人在分享使用这些代码时可以很容易地禁用这些扩展.</li>
</ol>
<p>然而, 在 Windows 上仍然有一些我们偶尔需要违反的规则:</p>
<ol>
<li>通常我们 禁止使用多重继承, 但在使用 COM 和 ATL/WTL 类时可以使用多重继承. 为了实现 COM 或 ATL/WTL 类/接口, 你可能不得不使用多重实现继承.</li>
<li>虽然代码中不应该使用异常, 但是在 ATL 和部分 STL（包括 Visual C++ 的 STL) 中异常被广泛使用. 使用 ATL 时, 应定义 _ATL_NO_EXCEPTIONS 以禁用异常. 你需要研究一下是否能够禁用 STL 的异常, 如果无法禁用, 可以启用编译器异常. (注意这只是为了编译 STL, 自己的代码里仍然不应当包含异常处理).</li>
<li>通常为了利用头文件预编译, 每个每个源文件的开头都会包含一个名为 StdAfx.h 或 precompile.h 的文件. 为了使代码方便与其他项目共享, 请避免显式包含此文件 (除了在 precompile.cc 中), 使用 /FI 编译器选项以自动包含该文件.</li>
<li>资源头文件通常命名为 resource.h 且只包含宏, 这一文件不需要遵守本风格指南.</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[9. 格式 -Google C++编程规范]]></title>
        <id>https://lixin-scut.github.io//post/9-ge-shi-google-cbian-cheng-gui-fan</id>
        <link href="https://lixin-scut.github.io//post/9-ge-shi-google-cbian-cheng-gui-fan">
        </link>
        <updated>2020-05-01T03:44:42.000Z</updated>
        <content type="html"><![CDATA[<p>  每个人都可能有自己的代码风格和格式, 但如果一个项目中的所有人都遵循同一风格的话, 这个项目就能更顺利地进行. 每个人未必能同意下述的每一处格式规则, 而且其中的不少规则需要一定时间的适应, 但整个项目服从统一的编程风格是很重要的, 只有这样才能让所有人轻松地阅读和理解代码.</p>
<p>  为了帮助你正确的格式化代码, 我们写了一个 emacs 配置文件.</p>
<h3 id="91-行长度">9.1. 行长度</h3>
<p><strong>总述</strong></p>
<p><strong>每一行代码字符数不超过 80.</strong></p>
<p>  我们也认识到这条规则是有争议的, 但很多已有代码都遵照这一规则, 因此我们感觉一致性更重要.</p>
<p><strong>优点</strong></p>
<p>  提倡该原则的人认为强迫他们调整编辑器窗口大小是很野蛮的行为. 很多人同时并排开几个代码窗口, 根本没有多余的空间拉伸窗口. 大家都把窗口最大尺寸加以限定, 并且 80 列宽是传统标准. 那么为什么要改变呢?</p>
<p><strong>缺点</strong></p>
<p>  反对该原则的人则认为更宽的代码行更易阅读. 80 列的限制是上个世纪 60 年代的大型机的古板缺陷; 现代设备具有更宽的显示屏, 可以很轻松地显示更多代码.</p>
<p><strong>结论</strong></p>
<p>  80 个字符是最大值.</p>
<p>  如果无法在不伤害易读性的条件下进行断行, 那么注释行可以超过 80 个字符, 这样可以方便复制粘贴. 例如, 带有命令示例或 URL 的行可以超过 80 个字符.</p>
<p>  包含长路径的 #include 语句可以超出80列.</p>
<p>  <strong>头文件保护 可以无视该原则.</strong></p>
<h3 id="92-非-ascii-字符">9.2. 非 ASCII 字符</h3>
<p><strong>总述</strong></p>
<p>  <strong>尽量不使用非 ASCII 字符, 使用时必须使用 UTF-8 编码.</strong></p>
<p><strong>说明</strong></p>
<p>  即使是英文, 也不应将用户界面的文本硬编码到源代码中, 因此非 ASCII 字符应当很少被用到. 特殊情况下可以适当包含此类字符. 例如, 代码分析外部数据文件时, 可以适当硬编码数据文件中作为分隔符的非 ASCII 字符串; 更常见的是 (不需要本地化的) 单元测试代码可能包含非 ASCII 字符串. 此类情况下, 应使用 UTF-8 编码, 因为很多工具都可以理解和处理 UTF-8 编码.</p>
<p>  十六进制编码也可以, 能增强可读性的情况下尤其鼓励 —— 比如 &quot;\xEF\xBB\xBF&quot;, 或者更简洁地写作 u8&quot;\uFEFF&quot;, 在 Unicode 中是 零宽度 无间断 的间隔符号, 如果不用十六进制直接放在 UTF-8 格式的源文件中, 是看不到的.</p>
<p>(译者注: &quot;\xEF\xBB\xBF&quot; 通常用作 UTF-8 with BOM 编码标记)</p>
<p>  使用 u8 前缀把带 uXXXX 转义序列的字符串字面值编码成 UTF-8. 不要用在本身就带 UTF-8 字符的字符串字面值上, 因为如果编译器不把源代码识别成 UTF-8, 输出就会出错.</p>
<p>  <strong>别用 C++11 的 char16_t 和 char32_t, 它们和 UTF-8 文本没有关系, wchar_t 同理, 除非你写的代码要调用 Windows API, 后者广泛使用了 wchar_t.</strong></p>
<h3 id="93-空格还是制表位">9.3. 空格还是制表位</h3>
<p><strong>总述</strong></p>
<p>  <strong>只使用空格, 每次缩进 2 个空格.</strong></p>
<p><strong>说明</strong></p>
<p>  <strong>我们使用空格缩进. 不要在代码中使用制表符. 你应该设置编辑器将制表符转为空格.</strong></p>
<h3 id="94-函数声明与定义">9.4. 函数声明与定义</h3>
<p><strong>总述</strong></p>
<p>  返回类型和函数名在同一行, 参数也尽量放在同一行, 如果放不下就对形参分行, 分行方式与 函数调用 一致.</p>
<p><strong>说明</strong></p>
<p>函数看上去像这样:</p>
<pre><code>
ReturnType ClassName::FunctionName(Type par_name1, Type par_name2) {
  DoSomething();
  ...
}
</code></pre>
<p>如果同一行文本太多, 放不下所有参数:</p>
<pre><code>ReturnType ClassName::ReallyLongFunctionName(Type par_name1, Type par_name2,
                                             Type par_name3) {
  DoSomething();
  ...
}
</code></pre>
<p>甚至连第一个参数都放不下:</p>
<pre><code>ReturnType LongClassName::ReallyReallyReallyLongFunctionName(
    Type par_name1,  // 4 space indent
    Type par_name2,
    Type par_name3) {
  DoSomething();  // 2 space indent
  ...
}
</code></pre>
<p>注意以下几点:</p>
<ol>
<li>使用好的参数名.</li>
<li>只有在参数未被使用或者其用途非常明显时, 才能省略参数名.</li>
<li>如果返回类型和函数名在一行放不下, 分行.</li>
<li>如果返回类型与函数声明或定义分行了, 不要缩进.</li>
<li>左圆括号总是和函数名在同一行.</li>
<li>函数名和左圆括号间永远没有空格.</li>
<li>圆括号与参数间没有空格.</li>
<li>左大括号总在最后一个参数同一行的末尾处, 不另起新行.</li>
<li>右大括号总是单独位于函数最后一行, 或者与左大括号同一行.</li>
<li>右圆括号和左大括号间总是有一个空格.</li>
<li>所有形参应尽可能对齐.</li>
<li>缺省缩进为 2 个空格.</li>
<li>换行后的参数保持 4 个空格的缩进.</li>
<li>未被使用的参数, 或者根据上下文很容易看出其用途的参数, 可以省略参数名:</li>
</ol>
<pre><code>class Foo {
 public:
  Foo(Foo&amp;&amp;);
  Foo(const Foo&amp;);
  Foo&amp; operator=(Foo&amp;&amp;);
  Foo&amp; operator=(const Foo&amp;);
};
</code></pre>
<p><strong>未被使用的参数如果其用途不明显的话, 在函数定义处将参数名注释起来:</strong></p>
<pre><code>class Shape {
 public:
  virtual void Rotate(double radians) = 0;
};

class Circle : public Shape {
 public:
  void Rotate(double radians) override;
};

void Circle::Rotate(double /*radians*/) {}
</code></pre>
<pre><code>// 差 - 如果将来有人要实现, 很难猜出变量的作用.
void Circle::Rotate(double) {}
</code></pre>
<p><strong>属性, 和展开为属性的宏, 写在函数声明或定义的最前面, 即返回类型之前:</strong></p>
<pre><code>MUST_USE_RESULT bool IsOK();
</code></pre>
<h3 id="95-lambda-表达式">9.5. Lambda 表达式</h3>
<p><strong>总述</strong></p>
<p>  Lambda 表达式对形参和函数体的格式化和其他函数一致; 捕获列表同理, 表项用逗号隔开.</p>
<p><strong>说明</strong></p>
<p>  若用引用捕获, 在变量名和 &amp; 之间不留空格.</p>
<pre><code>int x = 0;
auto add_to_x = [&amp;x](int n) { x += n; };
</code></pre>
<p>短 lambda 就写得和内联函数一样.</p>
<pre><code>std::set&lt;int&gt; blacklist = {7, 8, 9};
std::vector&lt;int&gt; digits = {3, 9, 1, 8, 4, 7, 1};
digits.erase(std::remove_if(digits.begin(), digits.end(), [&amp;blacklist](int i) {
               return blacklist.find(i) != blacklist.end();
             }),
             digits.end());
</code></pre>
<h3 id="96-函数调用">9.6. 函数调用</h3>
<p><strong>总述</strong></p>
<p>  要么一行写完函数调用, 要么在圆括号里对参数分行, 要么参数另起一行且缩进四格. 如果没有其它顾虑的话, 尽可能精简行数, 比如把多个参数适当地放在同一行里.</p>
<p><strong>说明</strong></p>
<p>函数调用遵循如下形式：</p>
<pre><code>bool retval = DoSomething(argument1, argument2, argument3);
</code></pre>
<p>注意此处和函数定义不同</p>
<p>  <strong>如果同一行放不下, 可断为多行, 后面每一行都和第一个实参对齐, 左圆括号后和右圆括号前不要留空格：</strong></p>
<pre><code>bool retval = DoSomething(averyveryveryverylongargument1,
                          argument2, argument3);
</code></pre>
<p>参数也可以放在次行, 缩进四格：</p>
<pre><code>if (...) {
  ...
  ...
  if (...) {
    DoSomething(
        argument1, argument2,  // 4 空格缩进
        argument3, argument4);
  }
</code></pre>
<p>  把多个参数放在同一行以减少函数调用所需的行数, 除非影响到可读性. 有人认为把每个参数都独立成行, 不仅更好读, 而且方便编辑参数. 不过, 比起所谓的参数编辑, 我们更看重可读性, 且后者比较好办：</p>
<p>  如果一些参数本身就是略复杂的表达式, 且降低了可读性, 那么可以直接创建临时变量描述该表达式, 并传递给函数：</p>
<pre><code>int my_heuristic = scores[x] * y + bases[x];
bool retval = DoSomething(my_heuristic, x, y, z);
</code></pre>
<p>  或者放着不管, 补充上注释：</p>
<pre><code>bool retval = DoSomething(scores[x] * y + bases[x],  // Score heuristic.
                          x, y, z);
</code></pre>
<p>  如果某参数独立成行, 对可读性更有帮助的话, 那也可以如此做. <strong>参数的格式处理应当以可读性而非其他作为最重要的原则.</strong></p>
<p>  <strong>此外, 如果一系列参数本身就有一定的结构, 可以酌情地按其结构来决定参数格式：</strong></p>
<pre><code>// 通过 3x3 矩阵转换 widget.
my_widget.Transform(x1, x2, x3,
                    y1, y2, y3,
                    z1, z2, z3);
</code></pre>
<h3 id="97-列表初始化格式">9.7. 列表初始化格式</h3>
<p><strong>总述</strong></p>
<p>  您平时<strong>怎么格式化函数调用, 就怎么格式化 列表初始化.</strong></p>
<p><strong>说明</strong></p>
<p>  <strong>如果列表初始化伴随着名字, 比如类型或变量名, 格式化时将将名字视作函数调用名, {} 视作函数调用的括号. 如果没有名字, 就视作名字长度为零.</strong></p>
<pre><code>// 一行列表初始化示范.
return {foo, bar};
functioncall({foo, bar});
pair&lt;int, int&gt; p{foo, bar};

// 当不得不断行时.
SomeFunction(
    {&quot;assume a zero-length name before {&quot;},  // 假设在 { 前有长度为零的名字.
    some_other_function_parameter);
SomeType variable{
    some, other, values,
    {&quot;assume a zero-length name before {&quot;},  // 假设在 { 前有长度为零的名字.
    SomeOtherType{
        &quot;Very long string requiring the surrounding breaks.&quot;,  // 非常长的字符串, 前后都需要断行.
        some, other values},
    SomeOtherType{&quot;Slightly shorter string&quot;,  // 稍短的字符串.
                  some, other, values}};
SomeType variable{
    &quot;This is too long to fit all in one line&quot;};  // 字符串过长, 因此无法放在同一行.
MyType m = {  // 注意了, 您可以在 { 前断行.
    superlongvariablename1,
    superlongvariablename2,
    {short, interior, list},
    {interiorwrappinglist,
     interiorwrappinglist2}};
</code></pre>
<h3 id="98-条件语句">9.8. 条件语句</h3>
<p><strong>总述</strong></p>
<p>  <strong>倾向于不在圆括号内使用空格. 关键字 if 和 else 另起一行.</strong></p>
<p><strong>说明</strong></p>
<p>  对基本条件语句有两种可以接受的格式. 一种在圆括号和条件之间有空格, 另一种没有.</p>
<p>  最常见的是没有空格的格式. 哪一种都可以, 最重要的是 保持一致. 如果你是在修改一个文件, 参考当前已有格式. 如果是写新的代码, 参考目录下或项目中其它文件. 还在犹豫的话, 就不要加空格了.</p>
<pre><code>if (condition) {  // 圆括号里没有空格.
  ...  // 2 空格缩进.
} else if (...) {  // else 与 if 的右括号同一行.
  ...
} else {
  ...
}
</code></pre>
<p>  如果你更喜欢在圆括号内部加空格:</p>
<pre><code>if ( condition ) {  // 圆括号与空格紧邻 - 不常见
  ...  // 2 空格缩进.
} else {  // else 与 if 的右括号同一行.
  ...
}
</code></pre>
<p>  <strong>注意所有情况下 if 和左圆括号间都有个空格. 右圆括号和左大括号之间也要有个空格:</strong></p>
<pre><code>
if(condition)     // 差 - IF 后面没空格.
if (condition){   // 差 - { 前面没空格.
if(condition){    // 变本加厉地差.
</code></pre>
<pre><code>if (condition) {  // 好 - IF 和 { 都与空格紧邻.
</code></pre>
<p>  如果能增强可读性, 简短的条件语句允许写在同一行. 只有当语句简单并且没有使用 else 子句时使用:</p>
<pre><code>if (x == kFoo) return new Foo();
if (x == kBar) return new Bar();
</code></pre>
<p>  如果语句有 else 分支则不允许:</p>
<pre><code>// 不允许 - 当有 ELSE 分支时 IF 块却写在同一行
if (x) DoThis();
else DoThat();
</code></pre>
<p>  通常, 单行语句不需要使用大括号, 如果你喜欢用也没问题; 复杂的条件或循环语句用大括号可读性会更好. 也有一些项目要求 if 必须总是使用大括号:</p>
<pre><code>if (condition)
  DoSomething();  // 2 空格缩进.

if (condition) {
  DoSomething();  // 2 空格缩进.
}
</code></pre>
<p>  但如果语句中某个 if-else 分支使用了大括号的话, 其它分支也必须使用:</p>
<pre><code>// 不可以这样子 - IF 有大括号 ELSE 却没有.
if (condition) {
  foo;
} else
  bar;

// 不可以这样子 - ELSE 有大括号 IF 却没有.
if (condition)
  foo;
else {
  bar;
}
</code></pre>
<pre><code>// 只要其中一个分支用了大括号, 两个分支都要用上大括号.
if (condition) {
  foo;
} else {
  bar;
}
</code></pre>
<h3 id="99-循环和开关选择语句">9.9. 循环和开关选择语句</h3>
<p><strong>总述</strong></p>
<p>  switch 语句可以使用大括号分段, 以表明 cases 之间不是连在一起的. 在单语句循环里, 括号可用可不用. 空循环体应使用 {} 或 continue.</p>
<p><strong>说明</strong></p>
<p>  switch 语句中的 case 块可以使用大括号也可以不用, 取决于你的个人喜好. 如果用的话, 要按照下文所述的方法.</p>
<p>  <strong>如果有不满足 case 条件的枚举值, switch 应该总是包含一个 default 匹配</strong> (如果有输入值没有 case 去处理, 编译器将给出 warning). <strong>如果 default 应该永远执行不到, 简单的加条 assert</strong>:</p>
<pre><code>switch (var) {
  case 0: {  // 2 空格缩进
    ...      // 4 空格缩进
    break;
  }
  case 1: {
    ...
    break;
  }
  default: {
    assert(false);
  }
}
</code></pre>
<p>在单语句循环里, 括号可用可不用：</p>
<pre><code>for (int i = 0; i &lt; kSomeNumber; ++i)
  printf(&quot;I love you\n&quot;);

for (int i = 0; i &lt; kSomeNumber; ++i) {
  printf(&quot;I take it back\n&quot;);
}
</code></pre>
<p><strong>空循环体应使用 {} 或 continue, 而不是一个简单的分号.</strong></p>
<pre><code>while (condition) {
  // 反复循环直到条件失效.
}
for (int i = 0; i &lt; kSomeNumber; ++i) {}  // 可 - 空循环体.
while (condition) continue;  // 可 - contunue 表明没有逻辑.
while (condition);  // 差 - 看起来仅仅只是 while/loop 的部分之一.
</code></pre>
<h3 id="910-指针和引用表达式">9.10. 指针和引用表达式</h3>
<p><strong>总述</strong></p>
<p>  <strong>句点或箭头前后不要有空格. 指针/地址操作符 (*, &amp;) 之后不能有空格.</strong></p>
<p><strong>说明</strong></p>
<p>  下面是指针和引用表达式的正确使用范例:</p>
<pre><code>x = *p;
p = &amp;x;
x = r.y;
x = r-&gt;y;
</code></pre>
<p>注意:</p>
<ol>
<li>在访问成员时, 句点或箭头前后没有空格.</li>
<li>指针操作符 * 或 &amp; 后没有空格.</li>
</ol>
<p><strong>在声明指针变量或参数时, 星号与类型或变量名紧挨都可以:</strong></p>
<pre><code>// 好, 空格前置.
char *c;
const string &amp;str;

// 好, 空格后置.
char* c;
const string&amp; str;
</code></pre>
<pre><code>int x, *y;  // 不允许 - 在多重声明中不能使用 &amp; 或 *
char * c;  // 差 - * 两边都有空格
const string &amp; str;  // 差 - &amp; 两边都有空格.
</code></pre>
<p>  <strong>在单个文件内要保持风格一致, 所以, 如果是修改现有文件, 要遵照该文件的风格.</strong></p>
<h3 id="911-布尔表达式">9.11. 布尔表达式</h3>
<p><strong>总述</strong></p>
<p>  如果一个布尔表达式超过 标准行宽, 断行方式要统一一下.</p>
<p><strong>说明</strong></p>
<p>下例中, 逻辑与 (&amp;&amp;) 操作符总位于行尾:</p>
<pre><code>if (this_one_thing &gt; this_other_thing &amp;&amp;
    a_third_thing == a_fourth_thing &amp;&amp;
    yet_another &amp;&amp; last_one) {
  ...
}
</code></pre>
<p>  注意, 上例的逻辑与 (&amp;&amp;) 操作符均位于行尾. 这个格式在 Google 里很常见, 虽然把所有操作符放在开头也可以. 可以考虑额外插入圆括号, 合理使用的话对增强可读性是很有帮助的. 此外, 直接用符号形式的操作符, 比如 &amp;&amp; 和 ~, 不要用词语形式的 and 和 compl.</p>
<h3 id="912-函数返回值">9.12. 函数返回值</h3>
<p><strong>总述</strong></p>
<p>  <strong>不要在 return 表达式里加上非必须的圆括号.</strong></p>
<p><strong>说明</strong></p>
<p>  只有在写 x = expr 要加上括号的时候才在 return expr; 里使用括号.</p>
<pre><code>return result;                  // 返回值很简单, 没有圆括号.
// 可以用圆括号把复杂表达式圈起来, 改善可读性.
return (some_long_condition &amp;&amp;
        another_condition);
</code></pre>
<pre><code>return (value);                // 毕竟您从来不会写 var = (value);
return(result);                // return 可不是函数！
</code></pre>
<h3 id="913-变量及数组初始化">9.13. 变量及数组初始化</h3>
<p><strong>总述</strong></p>
<p>  用 =, () 和 {} 均可.</p>
<p><strong>说明</strong></p>
<p>  您可以用 =, () 和 {}, 以下的例子都是正确的：</p>
<pre><code>int x = 3;
int x(3);
int x{3};
string name(&quot;Some Name&quot;);
string name = &quot;Some Name&quot;;
string name{&quot;Some Name&quot;};
</code></pre>
<p>  请务必小心列表初始化 {...} 用 std::initializer_list 构造函数初始化出的类型. 非空列表初始化就会优先调用 std::initializer_list, 不过空列表初始化除外, 后者原则上会调用默认构造函数. <strong>为了强制禁用 std::initializer_list 构造函数, 请改用括号.</strong></p>
<pre><code>vector&lt;int&gt; v(100, 1);  // 内容为 100 个 1 的向量.
vector&lt;int&gt; v{100, 1};  // 内容为 100 和 1 的向量.
</code></pre>
<p>  此外,<strong>列表初始化不允许整型类型的四舍五入, 这可以用来避免一些类型上的编程失误.</strong></p>
<pre><code>int pi(3.14);  // 好 - pi == 3.
int pi{3.14};  // 编译错误: 缩窄转换.
</code></pre>
<h3 id="914-预处理指令">9.14. 预处理指令</h3>
<p><strong>总述</strong></p>
<p>  <strong>预处理指令不要缩进, 从行首开始.</strong></p>
<p><strong>说明</strong></p>
<p>  <strong>即使预处理指令位于缩进代码块中, 指令也应从行首开始.</strong></p>
<pre><code>// 好 - 指令从行首开始
  if (lopsided_score) {
#if DISASTER_PENDING      // 正确 - 从行首开始
    DropEverything();
# if NOTIFY               // 非必要 - # 后跟空格
    NotifyClient();
# endif
#endif
    BackToNormal();
  }
// 差 - 指令缩进
  if (lopsided_score) {
    #if DISASTER_PENDING  // 差 - &quot;#if&quot; 应该放在行开头
    DropEverything();
    #endif                // 差 - &quot;#endif&quot; 不要缩进
    BackToNormal();
  }
</code></pre>
<h3 id="915-类格式">9.15. 类格式</h3>
<p><strong>总述</strong></p>
<p>  <strong>访问控制块的声明依次序是 public:, protected:, private:, 每个都缩进 1 个空格.</strong></p>
<p><strong>说明</strong></p>
<p>  类声明 (下面的代码中缺少注释, 参考 类注释) 的基本格式如下:</p>
<pre><code>class MyClass : public OtherClass {
 public:      // 注意有一个空格的缩进
  MyClass();  // 标准的两空格缩进
  explicit MyClass(int var);
  ~MyClass() {}

  void SomeFunction();
  void SomeFunctionThatDoesNothing() {
  }

  void set_some_var(int var) { some_var_ = var; }
  int some_var() const { return some_var_; }

 private:
  bool SomeInternalFunction();

  int some_var_;
  int some_other_var_;
};
</code></pre>
<p>注意事项:</p>
<ol>
<li>所有基类名应在 80 列限制下尽量与子类名放在同一行.</li>
<li>关键词 public:, protected:, private: 要缩进 1 个空格.</li>
<li>除第一个关键词 (一般是 public) 外, 其他关键词前要空一行. 如果类比较小的话也可以不空.</li>
<li>这些关键词后不要保留空行.</li>
<li>public 放在最前面, 然后是 protected, 最后是 private.</li>
<li>关于声明顺序的规则请参考 声明顺序 一节.</li>
</ol>
<h3 id="916-构造函数初始值列表">9.16. 构造函数初始值列表</h3>
<p><strong>总述</strong></p>
<p>  <strong>构造函数初始化列表放在同一行或按四格缩进并排多行.</strong></p>
<p><strong>说明</strong></p>
<p>  下面两种初始值列表方式都可以接受:</p>
<pre><code>// 如果所有变量能放在同一行:
MyClass::MyClass(int var) : some_var_(var) {
  DoSomething();
}

// 如果不能放在同一行,
// 必须置于冒号后, 并缩进 4 个空格
MyClass::MyClass(int var)
    : some_var_(var), some_other_var_(var + 1) {
  DoSomething();
}

// 如果初始化列表需要置于多行, 将每一个成员放在单独的一行
// 并逐行对齐
MyClass::MyClass(int var)
    : some_var_(var),             // 4 space indent
      some_other_var_(var + 1) {  // lined up
  DoSomething();
}

// 右大括号 } 可以和左大括号 { 放在同一行
// 如果这样做合适的话
MyClass::MyClass(int var)
    : some_var_(var) {}
</code></pre>
<h3 id="917-命名空间格式化">9.17. 命名空间格式化</h3>
<p><strong>总述</strong></p>
<p>  命名空间内容不缩进.</p>
<p><strong>说明</strong></p>
<p>  <strong>命名空间 不要增加额外的缩进层次</strong>, 例如:</p>
<pre><code>namespace {

void foo() {  // 正确. 命名空间内没有额外的缩进.
  ...
}

}  // namespace
</code></pre>
<p>不要在命名空间内缩进:</p>
<pre><code>namespace {

  // 错, 缩进多余了.
  void foo() {
    ...
  }

}  // namespace
</code></pre>
<p><strong>声明嵌套命名空间时, 每个命名空间都独立成行.</strong></p>
<pre><code>namespace foo {
namespace bar {
</code></pre>
<h3 id="919-水平留白">9.19. 水平留白</h3>
<p><strong>总述</strong></p>
<p>  水平留白的使用根据在代码中的位置决定. 永远不要在行尾添加没意义的留白.</p>
<p><strong>说明</strong></p>
<p><strong>通用</strong></p>
<pre><code>void f(bool b) {  // 左大括号前总是有空格.
  ...
int i = 0;  // 分号前不加空格.
// 列表初始化中大括号内的空格是可选的.
// 如果加了空格, 那么两边都要加上.
int x[] = { 0 };
int x[] = {0};

// 继承与初始化列表中的冒号前后恒有空格.
class Foo : public Bar {
 public:
  // 对于单行函数的实现, 在大括号内加上空格
  // 然后是函数实现
  Foo(int b) : Bar(), baz_(b) {}  // 大括号里面是空的话, 不加空格.
  void Reset() { baz_ = 0; }  // 用括号把大括号与实现分开.
  ...
</code></pre>
<p>  <strong>添加冗余的留白会给其他人编辑时造成额外负担. 因此, 行尾不要留空格.</strong> 如果确定一行代码已经修改完毕, 将多余的空格去掉; 或者在专门清理空格时去掉（尤其是在没有其他人在处理这件事的时候). (Yang.Y 注: 现在大部分代码编辑器稍加设置后, 都支持自动删除行首/行尾空格, 如果不支持, 考虑换一款编辑器或 IDE)</p>
<p><strong>循环和条件语句</strong></p>
<pre><code>if (b) {          // if 条件语句和循环语句关键字后均有空格.
} else {          // else 前后有空格.
}
while (test) {}   // 圆括号内部不紧邻空格.
switch (i) {
for (int i = 0; i &lt; 5; ++i) {
switch ( i ) {    // 循环和条件语句的圆括号里可以与空格紧邻.
if ( test ) {     // 圆括号, 但这很少见. 总之要一致.
for ( int i = 0; i &lt; 5; ++i ) {
for ( ; i &lt; 5 ; ++i) {  // 循环里内 ; 后恒有空格, ;  前可以加个空格.
switch (i) {
  case 1:         // switch case 的冒号前无空格.
    ...
  case 2: break;  // 如果冒号有代码, 加个空格.
</code></pre>
<p><strong>操作符</strong></p>
<pre><code>// 赋值运算符前后总是有空格.
x = 0;

// 其它二元操作符也前后恒有空格, 不过对于表达式的子式可以不加空格.
// 圆括号内部没有紧邻空格.
v = w * x + y / z;
v = w*x + y/z;
v = w * (x + z);

// 在参数和一元操作符之间不加空格.
x = -5;
++x;
if (x &amp;&amp; !y)
  ...
</code></pre>
<p><strong>模板和转换</strong></p>
<pre><code>// 尖括号(&lt; and &gt;) 不与空格紧邻, &lt; 前没有空格, &gt; 和 ( 之间也没有.
vector&lt;string&gt; x;
y = static_cast&lt;char*&gt;(x);

// 在类型与指针操作符之间留空格也可以, 但要保持一致.
vector&lt;char *&gt; x;
</code></pre>
<h3 id="919-垂直留白">9.19. 垂直留白</h3>
<p><strong>总述</strong></p>
<p>  垂直留白越少越好.</p>
<p><strong>说明</strong></p>
<p>  这不仅仅是规则而是原则问题了: <strong>不在万不得已, 不要使用空行. 尤其是: 两个函数定义之间的空行不要超过 2 行, 函数体首尾不要留空行, 函数体中也不要随意添加空行.</strong></p>
<p>  <strong>基本原则是: 同一屏可以显示的代码越多, 越容易理解程序的控制流. 当然, 过于密集的代码块和过于疏松的代码块同样难看, 这取决于你的判断. 但通常是垂直留白越少越好.</strong></p>
<p>下面的规则可以让加入的空行更有效:</p>
<ol>
<li>函数体内开头或结尾的空行可读性微乎其微.</li>
<li>在多重 if-else 块里加空行或许有点可读性.</li>
</ol>
<h3 id="译者笔记">译者笔记</h3>
<ol>
<li>
<p>对于代码格式, 因人, 系统而异各有优缺点, 但同一个项目中遵循同一标准还是有必要的;</p>
</li>
<li>
<p>行宽原则上不超过 80 列, 把 22 寸的显示屏都占完, 怎么也说不过去;</p>
</li>
<li>
<p>尽量不使用非 ASCII 字符, 如果使用的话, 参考 UTF-8 格式 (尤其是 UNIX/Linux 下, Windows 下可以考虑宽字符), 尽量不将字符串常量耦合到代码中, 比如独立出资源文件, 这不仅仅是风格问题了;</p>
</li>
<li>
<p><strong>UNIX/Linux 下无条件使用空格</strong>, MSVC 的话使用 Tab 也无可厚非;</p>
</li>
<li>
<p>函数参数, 逻辑条件, 初始化列表: 要么所有参数和函数名放在同一行, 要么所有参数并排分行;</p>
</li>
<li>
<p>除函数定义的左大括号可以置于行首外, 包括函数/类/结构体/枚举声明, 各种语句的左大括号置于行尾, 所有右大括号独立成行;</p>
</li>
<li>
<p>./-&gt; 操作符前后不留空格, */&amp; 不要前后都留, 一个就可, 靠左靠右依各人喜好;</p>
</li>
<li>
<p>预处理指令/命名空间不使用额外缩进, 类/结构体/枚举/函数/语句使用缩进;</p>
</li>
<li>
<p>初始化用 = 还是 () 依个人喜好, 统一就好;</p>
</li>
<li>
<p>return 不要加 ();</p>
</li>
<li>
<p>水平/垂直留白不要滥用, 怎么易读怎么来.</p>
</li>
<li>
<p>关于 UNIX/Linux 风格为什么要把左大括号置于行尾 (.cc 文件的函数实现处, 左大括号位于行首), 我的理解是代码看上去比较简约, 想想行首除了函数体被一对大括号封在一起之外, 只有右大括号的代码看上去确实也舒服; Windows 风格将左大括号置于行首的优点是匹配情况一目了然.</p>
</li>
<li>
<p>80 行限制事实上有助于避免代码可读性失控, 比如超多重嵌套块, 超多重函数调用等等.</p>
</li>
<li>
<p><strong>Linux 上设置好了 Locale 就几乎一劳永逸设置好所有开发环境的编码</strong>, 不像奇葩的 Windows.</p>
</li>
<li>
<p><strong>Google 强调有一对 if-else 时, 不论有没有嵌套, 都要有大括号</strong>. Apple 正好 有栽过跟头 .</p>
</li>
<li>
<p>其实我主张指针／地址操作符与变量名紧邻, int* a, b vs int *a, b, 新手会误以为前者的 b 是 int * 变量, 但后者就不一样了, 高下立判.</p>
</li>
<li>
<p>在这风格指南里我才刚知道 C++ 原来还有所谓的 Alternative operator representations, 大概没人用吧.</p>
</li>
<li>
<p>注意构造函数初始值列表（Constructer Initializer List）与列表初始化（Initializer List）是两码事, 我就差点混淆了它们的翻译.</p>
</li>
<li>
<p>事实上, 如果您熟悉英语本身的书写规则, 就会发现该风格指南在格式上的规定与英语语法相当一脉相承. 比如普通标点符号和单词后面还有文本的话, 总会留一个空格; 特殊符号与单词之间就不用留了, 比如 if (true) 中的圆括号与 true.</p>
</li>
<li>
<p>本风格指南没有明确规定 <strong>void 函数里要不要用 return 语句</strong>, 不过就 Google 开源项目 leveldb 并没有写; 此外从 Is a blank return statement at the end of a function whos return type is void necessary? 来看, <strong>return; 比 return ; 更约定俗成</strong>（事实上 cpplint 会对后者报错, 指出分号前有多余的空格）, 且可用来提前跳出函数栈.</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL 176. 第二高的薪水[简单]]]></title>
        <id>https://lixin-scut.github.io//post/mysql-176-di-er-gao-de-xin-shui-jian-dan</id>
        <link href="https://lixin-scut.github.io//post/mysql-176-di-er-gao-de-xin-shui-jian-dan">
        </link>
        <updated>2020-05-01T03:16:06.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>编写一个 SQL 查询，获取 Employee 表中第二高的薪水（Salary） 。<br>
+----+--------+<br>
| Id | Salary |<br>
+----+--------+<br>
| 1  | 100    |<br>
| 2  | 200    |<br>
| 3  | 300    |<br>
+----+--------+<br>
例如上述 Employee 表，SQL查询应该返回 200 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 null。<br>
+---------------------+<br>
| SecondHighestSalary |<br>
+---------------------+<br>
| 200                 |<br>
+---------------------+<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/second-highest-salary<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>主要是下面几个点<br>
1.列别名， AS SecondHighestSalary<br>
2. 降序排序，使用ORDER BY +DESC<br>
3. 限制行数  LIMIT 1,1，注意行数从0开始，第一行为0<br>
4. 去重， 使用DISTINCT<br>
5. 返回NULL，使用子查询</p>
<pre><code>SELECT (SELECT DISTINCT Salary 
        FROM Employee
        ORDER BY Salary DESC
        LIMIT 1,1) AS SecondHighestSalary;
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>方法一：使用子查询和 LIMIT 子句<br>
算法<br>
将不同的薪资按降序排序，然后使用 LIMIT 子句获得第二高的薪资。</p>
</blockquote>
<pre><code>MySQL
SELECT DISTINCT
    Salary AS SecondHighestSalary
FROM
    Employee
ORDER BY Salary DESC
LIMIT 1 OFFSET 1
</code></pre>
<blockquote>
<p>然而，如果没有这样的第二最高工资，这个解决方案将被判断为 “错误答案”，因为本表可能只有一项记录。为了克服这个问题，我们可以将其作为临时表。</p>
</blockquote>
<pre><code>MySQL
SELECT
    (SELECT DISTINCT
            Salary
        FROM
            Employee
        ORDER BY Salary DESC
        LIMIT 1 OFFSET 1) AS SecondHighestSalary
;
</code></pre>
<blockquote>
<p>方法二：使用 IFNULL 和 LIMIT 子句<br>
解决 “NULL” 问题的另一种方法是使用 “IFNULL” 函数，如下所示。</p>
</blockquote>
<pre><code>MySQL
SELECT
    IFNULL(
      (SELECT DISTINCT Salary
       FROM Employee
       ORDER BY Salary DESC
        LIMIT 1 OFFSET 1),
    NULL) AS SecondHighestSalary
</code></pre>
<p>《MySQL知识点》<br>
<strong>排序检索数据</strong><br>
  检索出的数据并不是以纯粹的随机顺序显示的。如果不排 序，数据一般将以它在底层表中出现的顺序显示。这可以是数据最初添加到表中的顺序。但是，如果数据后来进行过更新或删除，则此顺 序将会受到MySQL重用回收存储空间的影响。因此，如果不明确控 制的话，不能(也不应该)依赖该排序顺序。关系数据库设计理论认 为，如果不明确规定排序顺序，则不应该假定检索出的数据的顺序有 意义。<br>
  为了明确地排序用SELECT语句检索出的数据，可使用ORDER BY子句。 ORDER BY子句取一个或多个列的名字，据此对输出进行排序<br>
  通常，ORDERBY子句中使用的列将 是为显示所选择的列。但是，实际上并不一定要这样，用非 检索的列排序数据是完全合法的。<br>
  在按多个列排序时，排序完全按所规定的顺序进行。<br>
  数据排序不限于升序排序(从A到Z)。这只是默认的排序顺序，还可 以使用ORDER BY子句以降序(从Z到A)顺序排序。为了进行降序排序， 必须指定DESC关键字。<br>
  DESC关键字只应用到直接位于其前面的列名。如果想在多个列上进行降序排序，必须 对每个列指定DESC关键字。</p>
<p><strong>LIMIT关键字</strong><br>
  使用ORDER BY和LIMIT的组合，能够找出一个列中最高或最低的值。<br>
  SELECT语句返回所有匹配的行，它们可能是指定表中的每个行。为了返回第一行或前几行，可使用LIMIT子句<br>
  带一个值的LIMIT总是从第一行开始，给出的数为返回的行数。 带两个值的LIMIT可以指定从行号为第一个值的位置开始。<br>
  检索出来的第一行为行0而不是行1。因此，LIMIT1,1 将检索出第二行而不是第一行。<br>
  在行数不够时 LIMIT中指定要检索的行数为检索的最大行 数。如果没有足够的行(例如，给出LIMIT 10, 5，但只有13 行)，MySQL将只返回它能返回的那么多行。<br>
  MySQL 5的LIMIT语法 LIMIT 3, 4的含义是从行4开始的3 行还是从行3开始的4行?如前所述，它的意思是从行3开始的4 行，这容易把人搞糊涂。<br>
  由于这个原因，MySQL 5支持LIMIT的另一种替代语法。LIMIT 4 OFFSET 3意为从行3开始取4行，就像LIMIT 3, 4一样。</p>
<p><strong>DISTINCT关键字</strong><br>
  使用DISTINCT关键字检索出有不同值的列表，此关键字指示MySQL 只返回不同的值。<br>
  不能部分使用DISTINCT DISTINCT关键字应用于所有列而 不仅是前置它的列。如果给出SELECT DISTINCT vend_id, prod_price，除非指定的两个列都不同，否则所有行都将被 检索出来。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 31. 下一个排列[中等][未做出]]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-31-xia-yi-ge-pai-lie-zhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-31-xia-yi-ge-pai-lie-zhong-deng-wei-zuo-chu">
        </link>
        <updated>2020-05-01T02:30:07.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。<br>
如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。<br>
必须原地修改，只允许使用额外常数空间。<br>
以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br>
1,2,3 → 1,3,2<br>
3,2,1 → 1,2,3<br>
1,1,5 → 1,5,1<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/next-permutation<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>第一感觉是从后往前找到第一个顺序（相对于逆序）的两个数字进行交换<br>
如果一直找到头部都还是逆序的话直接反转整个vector<br>
然后翻车了hhh，确实没那么简单， 比如 1，3，2 交换为3，1，2的话不符合2，1，3</p>
<p>最后还是看了题解</p>
<ol>
<li>首先从后往前找出第一个顺序点</li>
<li>寻找可以交换的大于交换点的第一个数字</li>
<li>交换后对交换点后进行转换（亦即逆序变为顺序）</li>
</ol>
<p>确实比较有趣</p>
<pre><code>class Solution {
public:
    void nextPermutation(vector&lt;int&gt;&amp; nums) {
        int i = nums.size() - 2;
        while(i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i+1])
        {
            --i;
        }
        if(i &gt;=0)
        {
            int j = nums.size() - 1;
            while(j &gt;= 0 &amp;&amp; nums[j] &lt;= nums[i])
            {
                --j;
            }
            swap(nums[i], nums[j]);
        }
        reverse(nums.begin() + i + 1, nums.end());
    }
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>概要<br>
我们需要找到给定数字列表的下一个字典排列，而不是由给定数组形成的数字。<br>
解决方案<br>
方法一：暴力法<br>
算法<br>
在这种方法中，我们找出由给定数组的元素形成的列表的每个可能的排列，并找出比给定的排列更大的排列。<br>
但是这个方法是一种非常天真的方法，因为它要求我们找出所有可能的排列<br>
这需要很长时间，实施起来也很复杂。<br>
因此，这种方法根本无法通过。 所以，我们直接采用正确的方法。<br>
复杂度分析<br>
时间复杂度：O(n!)，可能的排列总计有 n! 个。<br>
空间复杂度：O(n)，因为数组将用于存储排列。<br>
方法二：一遍扫描<br>
算法<br>
首先，我们观察到对于任何给定序列的降序，没有可能的下一个更大的排列。<br>
例如，以下数组不可能有下一个排列：<br>
[9, 5, 4, 3, 1]<br>
我们需要从右边找到第一对两个连续的数字 a[i] 和 a[i−1]，它们满足 a[i]&gt;a[i−1]。现在，没有对 a[i−1] 右侧的重新排列可以创建更大的排列，因为该子数组由数字按降序组成。因此，我们需要重新排列 a[i−1] 右边的数字，包括它自己。<br>
现在，什么样子的重新排列将产生下一个更大的数字呢？我们想要创建比当前更大的排列。因此，我们需要将数字 a[i−1] 替换为位于其右侧区域的数字中比它更大的数字，例如 a[j]。<br>
我们交换数字 a[i−1] 和 a[j]。我们现在在索引 i−1 处有正确的数字。 但目前的排列仍然不是我们正在寻找的排列。我们需要通过仅使用 a[i−1]右边的数字来形成最小的排列。 因此，我们需要放置那些按升序排列的数字，以获得最小的排列。<br>
但是，请记住，在从右侧扫描数字时，我们只是继续递减索引直到我们找到 a[i] 和 a[i−1] 这对数。其中，a[i]&gt;a[i−1]。因此，a[i−1] 右边的所有数字都已按降序排序。此外，交换 a[i−1] 和 a[j] 并未改变该顺序。因此，我们只需要反转<br>
a[i−1] 之后的数字，以获得下一个最小的字典排列。</p>
</blockquote>
<pre><code>public class Solution {
    public void nextPermutation(int[] nums) {
        int i = nums.length - 2;
        while (i &gt;= 0 &amp;&amp; nums[i + 1] &lt;= nums[i]) {
            i--;
        }
        if (i &gt;= 0) {
            int j = nums.length - 1;
            while (j &gt;= 0 &amp;&amp; nums[j] &lt;= nums[i]) {
                j--;
            }
            swap(nums, i, j);
        }
        reverse(nums, i + 1);
    }

    private void reverse(int[] nums, int start) {
        int i = start, j = nums.length - 1;
        while (i &lt; j) {
            swap(nums, i, j);
            i++;
            j--;
        }
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)，在最坏的情况下，只需要对整个数组进行两次扫描。<br>
空间复杂度：O(1)，没有使用额外的空间，原地替换足以做到。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 120. 三角形最小路径和[中等]]]></title>
        <id>https://lixin-scut.github.io//post/dong-tai-gui-hua-120-san-jiao-xing-zui-xiao-lu-jing-he-zhong-deng</id>
        <link href="https://lixin-scut.github.io//post/dong-tai-gui-hua-120-san-jiao-xing-zui-xiao-lu-jing-he-zhong-deng">
        </link>
        <updated>2020-05-01T01:16:01.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。<br>
例如，给定三角形：<br>
[<br>
[2],<br>
[3,4],<br>
[6,5,7],<br>
[4,1,8,3]<br>
]<br>
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。<br>
说明：<br>
如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/triangle<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>第一反应是每层选择最小的数字，但是很明显这样子是不行的<br>
比如 [0]、[10，0]、[0, 99, 99] 明显第二层应该选10而不是0<br>
偷看标签知道是动态规划<br>
面对题目编程的话，普通方法应该是n^2的复杂度<br>
然后突然就来灵感了<br>
用一个容量为n的容器保存每一层每一个格子的路径和<br>
状态转移方程就是上一层两个可能的转移的节点的最小值加上当前节点的和，比如5这个节点就只需要考虑3和4<br>
然后如果不可能的位置就置为0吧<br>
本质上应该用一个容量为n*n的容器，n是层数，我的方法是直接进行了空间压缩</p>
<p>hhh实现的时候有个问题，我一开始从前到后更新，发现这样会被覆盖啊。。。比如0依赖于-1和0，但是1依赖于0和1，0已经被覆盖了</p>
<p>实现中注意的问题</p>
<ol>
<li>我把数组的长度修改为n+1，这样第一个数就不要单独判断了，但是相应地内循环需要修改判断条件和下标</li>
<li>因为我选择了初始化为INT_MAX，所以必须手动导入第一行，另外导致必须手动判断空数组</li>
<li>从后到前更新，原因前面有说</li>
</ol>
<pre><code>class Solution {
public:
    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) {
        int n = triangle.size();
        if(n == 0)
        {   return 0; }
        vector&lt;int&gt; counts(n + 1, INT_MAX);
        
        counts[1] = triangle[0][0];
        for(int i = 1; i &lt; n; ++i)
        {
            for(int j = i+1; j &gt; 0; --j)
            {
                counts[j] = min(counts[j - 1], counts[j]) + triangle[i][j - 1];
            }
        }
        
        int ans = INT_MAX;
        for(int i : counts)
        {
            ans = min(ans, i);
        }
        return ans;
    }
};
</code></pre>
<p>然后看了网友题解发现一个很有趣的事，就是外循环可以从底向上，这样子的话确实初始化方便一点。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[8. 注释 -Google C++编程规范]]></title>
        <id>https://lixin-scut.github.io//post/8-zhu-shi-google-cbian-cheng-gui-fan</id>
        <link href="https://lixin-scut.github.io//post/8-zhu-shi-google-cbian-cheng-gui-fan">
        </link>
        <updated>2020-04-30T15:11:17.000Z</updated>
        <content type="html"><![CDATA[<p>  注释虽然写起来很痛苦, 但对保证代码可读性至关重要. 下面的规则描述了如何注释以及在哪儿注释. <strong>当然也要记住: 注释固然很重要, 但最好的代码应当本身就是文档. 有意义的类型名和变量名, 要远胜过要用注释解释的含糊不清的名字.</strong></p>
<p>  <strong>你写的注释是给代码读者看的, 也就是下一个需要理解你的代码的人. 所以慷慨些吧, 下一个读者可能就是你!</strong></p>
<h3 id="81-注释风格">8.1. 注释风格</h3>
<p><strong>总述</strong></p>
<p>  使用 // 或<code>/* */</code>, 统一就好.</p>
<p><strong>说明</strong></p>
<p>  // 或 <code>/* */</code> 都可以; <strong>但 // 更 常用</strong>. 要在如何注释及注释风格上确保统一.</p>
<h3 id="82-文件注释">8.2. 文件注释</h3>
<p><strong>总述</strong></p>
<p>  <strong>在每一个文件开头加入版权公告.</strong></p>
<p>  <strong>文件注释描述了该文件的内容</strong>. 如果一个文件<strong>只声明, 或实现, 或测试</strong>了一个对象, 并且这个对象已经在它的声明处进行了详细的注释, 那么<strong>就没必要再加上文件注释</strong>. 除此之外的其他文件都需要文件注释.</p>
<p><strong>说明</strong></p>
<p>  法律公告和作者信息</p>
<p>  <strong>每个文件都应该包含许可证引用. 为项目选择合适的许可证版本.(比如, Apache 2.0, BSD, LGPL, GPL)</strong></p>
<p>  如果你对原始作者的文件做了重大修改, 请考虑删除原作者信息.</p>
<p><strong>文件内容</strong></p>
<p>  <strong>如果一个 .h 文件声明了多个概念, 则文件注释应当对文件的内容做一个大致的说明, 同时说明各概念之间的联系</strong>. 一个一到两行的文件注释就足够了, <strong>对于每个概念的详细文档应当放在各个概念中, 而不是文件注释中</strong>.</p>
<p>  不要在 .h 和 .cc 之间复制注释, 这样的注释偏离了注释的实际意义.</p>
<h3 id="83-类注释">8.3. 类注释</h3>
<p><strong>总述</strong></p>
<p>  <strong>每个类的定义都要附带一份注释, 描述类的功能和用法, 除非它的功能相当明显.</strong></p>
<pre><code>// Iterates over the contents of a GargantuanTable.
// Example:
//    GargantuanTableIterator* iter = table-&gt;NewIterator();
//    for (iter-&gt;Seek(&quot;foo&quot;); !iter-&gt;done(); iter-&gt;Next()) {
//      process(iter-&gt;key(), iter-&gt;value());
//    }
//    delete iter;
class GargantuanTableIterator {
  ...
};
</code></pre>
<p><strong>说明</strong></p>
<p>  类注释应当为读者理解<strong>如何使用与何时使用类</strong>提供足够的信息, 同时应当提醒读者<strong>在正确使用此类时应当考虑的因素</strong>. 如果类<strong>有任何同步前提</strong>, 请用文档说明. 如果该类的实例可被多线程访问, 要特别注意文档说明<strong>多线程环境下相关的规则和常量使用</strong>.</p>
<p>  如果你想<strong>用一小段代码演示这个类的基本用法或通常用法</strong>, 放在类注释里也非常合适.</p>
<p>  如果类的声明和定义分开了(例如分别放在了 .h 和 .cc 文件中), 此时, <strong>描述类用法的注释应当和接口定义放在一起</strong>,<strong>描述类的操作和实现的注释应当和实现放在一起.</strong></p>
<h3 id="84-函数注释">8.4. 函数注释</h3>
<p><strong>总述</strong></p>
<p>  <strong>函数声明处的注释描述函数功能; 定义处的注释描述函数实现.</strong></p>
<p><strong>说明</strong></p>
<p>函数声明</p>
<p>  基本上每个函数<strong>声明处</strong>前都应当加上注释, 描述函数的<strong>功能和用途</strong>. 只有在函数的功能简单而明显时才能省略这些注释(例如, 简单的取值和设值函数). <strong>注释使用叙述式 (“Opens the file”) 而非指令式 (“Open the file”); 注释只是为了描述函数, 而不是命令函数做什么</strong>. 通常, <strong>注释不会描述函数如何工作. 那是函数定义部分的事情.</strong></p>
<p>函数声明处注释的内容:</p>
<ol>
<li>函数的输入输出.</li>
<li>对类成员函数而言: 函数调用期间对象是否需要保持引用参数, 是否会释放这些参数.</li>
<li>函数是否分配了必须由调用者释放的空间.</li>
<li>参数是否可以为空指针.</li>
<li>是否存在函数使用上的性能隐患.</li>
<li>如果函数是可重入的, 其同步前提是什么?</li>
</ol>
<p>举例如下:</p>
<pre><code>// Returns an iterator for this table.  It is the client's
// responsibility to delete the iterator when it is done with it,
// and it must not use the iterator once the GargantuanTable object
// on which the iterator was created has been deleted.
//
// The iterator is initially positioned at the beginning of the table.
//
// This method is equivalent to:
//    Iterator* iter = table-&gt;NewIterator();
//    iter-&gt;Seek(&quot;&quot;);
//    return iter;
// If you are going to immediately seek to another place in the
// returned iterator, it will be faster to use NewIterator()
// and avoid the extra seek.
Iterator* GetIterator() const;
</code></pre>
<p>  但也要避免罗罗嗦嗦, 或者对显而易见的内容进行说明. 下面的注释就没有必要加上 “否则返回 false”, 因为已经暗含其中了:</p>
<pre><code>// Returns true if the table cannot hold any more entries.
bool IsTableFull();
</code></pre>
<p>  <strong>注释函数重载时, 注释的重点应该是函数中被重载的部分, 而不是简单的重复被重载的函数的注释</strong>. <strong>多数情况下, 函数重载不需要额外的文档, 因此也没有必要加上注释.</strong></p>
<p>  注释构造/析构函数时, 切记读代码的人知道构造/析构函数的功能, 所以 “销毁这一对象” 这样的注释是没有意义的. 你<strong>应当注明的是注明构造函数对参数做了什么 (例如, 是否取得指针所有权) 以及析构函数清理了什么</strong>. 如果都是些无关紧要的内容, 直接省掉注释. 析构函数前没有注释是很正常的.</p>
<p><strong>函数定义</strong></p>
<p>  <strong>如果函数的实现过程中用到了很巧妙的方式, 那么在函数定义处应当加上解释性的注释</strong>. 例如, 你所使用的编程技巧, 实现的大致步骤, 或解释如此实现的理由. 举个例子, 你可以说明为什么函数的前半部分要加锁而后半部分不需要.</p>
<p>  不要 从 .h 文件或其他地方的函数声明处直接复制注释. <strong>简要重述函数功能是可以的, 但注释重点要放在如何实现上.</strong></p>
<h3 id="85-变量注释">8.5. 变量注释</h3>
<p><strong>总述</strong></p>
<p>  通常变量名本身足以很好说明变量用途. 某些情况下, 也需要额外的注释说明.</p>
<p><strong>说明</strong></p>
<p><strong>类数据成员</strong></p>
<p>  <strong>每个类数据成员 (也叫实例变量或成员变量) 都应该用注释说明用途</strong>. 如果有非变量的参数(例如特殊值, 数据成员之间的关系, 生命周期等)不能够用类型与变量名明确表达, 则应当加上注释. 然而, 如果变量类型与变量名已经足以描述一个变量, 那么就不再需要加上注释.</p>
<p><strong>特别地, 如果变量可以接受 NULL 或 -1 等警戒值, 须加以说明</strong>. 比如:</p>
<pre><code>private:
 // Used to bounds-check table accesses. -1 means
 // that we don't yet know how many entries the table has.
 int num_total_entries_;
</code></pre>
<p><strong>全局变量</strong></p>
<p>  <strong>和数据成员一样, 所有全局变量也要注释说明含义及用途, 以及作为全局变量的原因</strong>. 比如:</p>
<pre><code>// The total number of tests cases that we run through in this regression test.
const int kNumTestCases = 6;
</code></pre>
<h3 id="86-实现注释">8.6. 实现注释</h3>
<p><strong>总述</strong></p>
<p>对于代码中巧妙的, 晦涩的, 有趣的, 重要的地方加以注释.</p>
<p><strong>说明</strong></p>
<p><strong>代码前注释</strong></p>
<p>巧妙或复杂的代码段前要加注释. 比如:</p>
<pre><code>// Divide result by two, taking into account that x
// contains the carry from the add.
for (int i = 0; i &lt; result-&gt;size(); i++) {
  x = (x &lt;&lt; 8) + (*result)[i];
  (*result)[i] = x &gt;&gt; 1;
  x &amp;= 1;
}
</code></pre>
<p><strong>行注释</strong></p>
<p>比较隐晦的地方要在行尾加入注释. 在行尾空两格进行注释. 比如:</p>
<pre><code>// If we have enough memory, mmap the data portion too.
mmap_budget = max&lt;int64&gt;(0, mmap_budget - index_-&gt;length());
if (mmap_budget &gt;= data_size_ &amp;&amp; !MmapData(mmap_chunk_bytes, mlock))
  return;  // Error already logged.
</code></pre>
<p>注意, 这里用了两段注释分别描述这段代码的作用, 和提示函数返回时错误已经被记入日志.</p>
<p><strong>如果你需要连续进行多行注释, 可以使之对齐获得更好的可读性:</strong></p>
<pre><code>DoSomething();                  // Comment here so the comments line up.
DoSomethingElseThatIsLonger();  // Two spaces between the code and the comment.
{ // One space before comment when opening a new scope is allowed,
  // thus the comment lines up with the following comments and code.
  DoSomethingElse();  // Two spaces before line comments normally.
}
std::vector&lt;string&gt; list{
                    // Comments in braced lists describe the next element...
                    &quot;First item&quot;,
                    // .. and should be aligned appropriately.
&quot;Second item&quot;};
DoSomething(); /* For trailing block comments, one space is fine. */
</code></pre>
<p><strong>函数参数注释</strong></p>
<p><strong>如果函数参数的意义不明显</strong>, 考虑用下面的方式进行弥补:</p>
<ol>
<li>如果参数是一个字面常量, 并且这一常量在多处函数调用中被使用, 用以推断它们一致, 你应当用一个常量名让这一约定变得更明显, 并且保证这一约定不会被打破.</li>
<li><strong>考虑更改函数的签名, 让某个 bool 类型的参数变为 enum 类型, 这样可以让这个参数的值表达其意义</strong>.</li>
<li><strong>如果某个函数有多个配置选项, 你可以考虑定义一个类或结构体以保存所有的选项, 并传入类或结构体的实例</strong>. 这样的方法有许多优点, 例如这样的选项可以在调用处用变量名引用, 这样就能清晰地表明其意义. 同时也减少了函数参数的数量, 使得函数调用更易读也易写. 除此之外, 以这样的方式, 如果你使用其他的选项, 就无需对调用点进行更改.</li>
<li>用具名变量代替大段而复杂的嵌套表达式.</li>
<li>万不得已时, 才考虑在调用点用注释阐明参数的意义.</li>
</ol>
<p>比如下面的示例的对比:</p>
<pre><code>// What are these arguments?
const DecimalNumber product = CalculateProduct(values, 7, false, nullptr);
</code></pre>
<p>和</p>
<pre><code>ProductOptions options;
options.set_precision_decimals(7);
options.set_use_cache(ProductOptions::kDontUseCache);
const DecimalNumber product =
    CalculateProduct(values, options, /*completion_callback=*/nullptr);
</code></pre>
<p>哪个更清晰一目了然.</p>
<p><strong>不允许的行为</strong></p>
<p>  <strong>不要描述显而易见的现象, 永远不要 用自然语言翻译代码作为注释</strong>, 除非即使对深入理解 C++ 的读者来说代码的行为都是不明显的. <strong>要假设读代码的人 C++ 水平比你高, 即便他/她可能不知道你的用意</strong>:</p>
<p>  <strong>你所提供的注释应当解释代码 为什么 要这么做和代码的目的, 或者最好是让代码自文档化</strong>.</p>
<p>比较这样的注释:</p>
<pre><code>// Find the element in the vector.  &lt;-- 差: 这太明显了!
auto iter = std::find(v.begin(), v.end(), element);
if (iter != v.end()) {
  Process(element);
}
</code></pre>
<p>和这样的注释:</p>
<pre><code>// Process &quot;element&quot; unless it was already processed.
auto iter = std::find(v.begin(), v.end(), element);
if (iter != v.end()) {
  Process(element);
}
</code></pre>
<p>  自文档化的代码根本就不需要注释. 上面例子中的注释对下面的代码来说就是毫无必要的:</p>
<pre><code>if (!IsAlreadyProcessed(element)) {
  Process(element);
}
</code></pre>
<h3 id="87-标点-拼写和语法">8.7. 标点, 拼写和语法</h3>
<p><strong>总述</strong></p>
<p>  注意标点, 拼写和语法; 写的好的注释比差的要易读的多.</p>
<p><strong>说明</strong></p>
<p>  注释的通常写法是包含正确大小写和结尾句号的完整叙述性语句. 大多数情况下, 完整的句子比句子片段可读性更高. 短一点的注释, 比如代码行尾注释, 可以随意点, 但依然要注意风格的一致性.</p>
<p>  虽然被别人指出该用分号时却用了逗号多少有些尴尬, 但清晰易读的代码还是很重要的. 正确的标点, 拼写和语法对此会有很大帮助.</p>
<h3 id="88-todo-注释">8.8. TODO 注释</h3>
<p><strong>总述</strong></p>
<p>  <strong>对那些临时的, 短期的解决方案, 或已经够好但仍不完美的代码使用 TODO 注释</strong>.</p>
<p>  TODO 注释要使用<strong>全大写的字符串 TODO, 在随后的圆括号里写上你的名字, 邮件地址, bug ID, 或其它身份标识和与这一 TODO 相关的 issue</strong>. 主要目的是让添加注释的人 (也是可以请求提供更多细节的人) 可根据规范的 TODO 格式进行查找. 添加 TODO 注释并不意味着你要自己来修正, 因此当你加上带有姓名的 TODO 时, 一般都是写上自己的名字.</p>
<pre><code>// TODO(kl@gmail.com): Use a &quot;*&quot; here for concatenation operator.
// TODO(Zeke) change this to use relations.
// TODO(bug 12345): remove the &quot;Last visitors&quot; feature
</code></pre>
<p>  如果加 TODO 是为了在 “将来某一天做某事”, 可以附上一个非常明确的时间 “Fix by November 2005”), 或者一个明确的事项 (“Remove this code when all clients can handle XML responses.”).</p>
<h3 id="89-弃用注释">8.9. 弃用注释</h3>
<p><strong>总述</strong></p>
<p>  <strong>通过弃用注释（DEPRECATED comments）以标记某接口点已弃用.</strong></p>
<p>  您可以写上包含全大写的 DEPRECATED 的注释, 以标记某接口为弃用状态. 注释可以放在接口声明前, 或者同一行.</p>
<p>  在 DEPRECATED 一词后, 在括号中留下您的名字, 邮箱地址以及其他身份标识.</p>
<p>  <strong>弃用注释应当包涵简短而清晰的指引, 以帮助其他人修复其调用点</strong>. 在 C++ 中, <strong>你可以将一个弃用函数改造成一个内联函数, 这一函数将调用新的接口</strong>.</p>
<p>  仅仅标记接口为 DEPRECATED 并不会让大家不约而同地弃用, 您还得亲自主动修正调用点（callsites）, 或是找个帮手.</p>
<p>  修正好的代码应该不会再涉及弃用接口点了, 着实改用新接口点. 如果您不知从何下手, 可以找标记弃用注释的当事人一起商量.</p>
<h3 id="译者笔记">译者笔记</h3>
<ol>
<li>关于注释风格, 很多 C++ 的 coders 更喜欢行注释, C coders 或许对块注释依然情有独钟, 或者在文件头大段大段的注释时使用块注释;</li>
<li>文件注释可以炫耀你的成就, 也是为了捅了篓子别人可以找你;</li>
<li>注释要言简意赅, 不要拖沓冗余, 复杂的东西简单化和简单的东西复杂化都是要被鄙视的;</li>
<li>对于 Chinese coders 来说, 用英文注释还是用中文注释, it is a problem, 但不管怎样, 注释是为了让别人看懂, 难道是为了炫耀编程语言之外的你的母语或外语水平吗；</li>
<li>注释不要太乱, 适当的缩进才会让人乐意看. 但也没有必要规定注释从第几列开始 (我自己写代码的时候总喜欢这样), UNIX/LINUX 下还可以约定是使用 tab 还是 space, 个人倾向于 space;</li>
<li>TODO 很不错, 有时候, 注释确实是为了标记一些未完成的或完成的不尽如人意的地方, 这样一搜索, 就知道还有哪些活要干, 日志都省了.</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[7. 命名约定 -Google C++编程规范]]></title>
        <id>https://lixin-scut.github.io//post/7-ming-ming-yue-ding-google-cbian-cheng-gui-fan</id>
        <link href="https://lixin-scut.github.io//post/7-ming-ming-yue-ding-google-cbian-cheng-gui-fan">
        </link>
        <updated>2020-04-30T14:54:12.000Z</updated>
        <content type="html"><![CDATA[<h3 id="71-通用命名规则">7.1. 通用命名规则</h3>
<p><strong>总述</strong></p>
<p>  函数命名, 变量命名, 文件命名要有描述性; 少用缩写.</p>
<p><strong>说明</strong></p>
<p>  尽可能使用描述性的命名, 别心疼空间, 毕竟相比之下让代码易于新读者理解更重要. 不要用只有项目开发者能理解的缩写, 也不要通过砍掉几个字母来缩写单词.</p>
<pre><code>int price_count_reader;    // 无缩写
int num_errors;            // &quot;num&quot; 是一个常见的写法
int num_dns_connections;   // 人人都知道 &quot;DNS&quot; 是什么
</code></pre>
<pre><code>int n;                     // 毫无意义.
int nerr;                  // 含糊不清的缩写.
int n_comp_conns;          // 含糊不清的缩写.
int wgc_connections;       // 只有贵团队知道是什么意思.
int pc_reader;             // &quot;pc&quot; 有太多可能的解释了.
int cstmr_id;              // 删减了若干字母.
</code></pre>
<p>  注意, 一些特定的广为人知的缩写是允许的, 例如<strong>用 i 表示迭代变量和用 T 表示模板参数.</strong></p>
<p>  模板参数的命名应当遵循对应的分类: <strong>类型模板参数</strong>应当遵循 <strong>类型命名 的规则</strong>, 而<strong>非类型模板</strong>应当遵循 <strong>变量命名 的规则</strong>.</p>
<h3 id="72-文件命名">7.2. 文件命名</h3>
<p><strong>总述</strong></p>
<p>  <strong>文件名要全部小写</strong>, 可以包含下划线 (<code>_</code>) 或连字符 (<code>-</code>), 依照项目的约定. 如果没有约定, 那么 “<code>_</code>” 更好.</p>
<p><strong>说明</strong></p>
<p>可接受的文件命名示例:</p>
<ol>
<li>my_useful_class.cc</li>
<li>my-useful-class.cc</li>
<li>myusefulclass.cc</li>
<li>myusefulclass_test.cc // <code>_unittest</code> 和 <code>_regtest</code> 已弃用.</li>
</ol>
<p>  C++ 文件要以 .cc 结尾, 头文件以 .h 结尾. 专门插入文本的文件则以 .inc 结尾, 参见 头文件自足.</p>
<p>  不要使用已经存在于 /usr/include 下的文件名 (Yang.Y 注: 即编译器搜索系统头文件的路径), 如 db.h.</p>
<p>  通常应尽量让文件名更加明确. http_server_logs.h 就比 logs.h 要好. 定义类时文件名一般成对出现, 如 foo_bar.h 和 foo_bar.cc, 对应于类 FooBar.</p>
<p>  内联函数必须放在 .h 文件中. 如果内联函数比较短, 就直接放在 .h 中.</p>
<h3 id="73-类型命名">7.3. 类型命名</h3>
<p><strong>总述</strong></p>
<p>  <strong>类型名称的每个单词首字母均大写（最典型就是类）</strong>, 不包含下划线: <code>MyExcitingClass</code>,<code>MyExcitingEnum</code>.</p>
<p><strong>说明</strong></p>
<p>  所有类型命名 —— 类, 结构体, 类型定义 (typedef), 枚举, 类型模板参数 —— 均使用相同约定, 即以大写字母开始, 每个单词首字母均大写, 不包含下划线. 例如:</p>
<pre><code>// 类和结构体
class UrlTable { ...
class UrlTableTester { ...
struct UrlTableProperties { ...

// 类型定义
typedef hash_map&lt;UrlTableProperties *, string&gt; PropertiesMap;

// using 别名
using PropertiesMap = hash_map&lt;UrlTableProperties *, string&gt;;

// 枚举
enum UrlTableErrors { ...
</code></pre>
<h3 id="74-变量命名">7.4. 变量命名</h3>
<p><strong>总述</strong></p>
<p>  变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾, 但结构体的就不用, 如: a_local_variable, a_struct_data_member, a_class_data_member_.</p>
<p><strong>说明</strong></p>
<p><strong>普通变量命名</strong></p>
<p>举例:</p>
<pre><code>string table_name;  // 好 - 用下划线.
string tablename;   // 好 - 全小写.

string tableName;  // 差 - 混合大小写
</code></pre>
<p><strong>类数据成员</strong></p>
<p>  不管是静态的还是非静态的, <strong>类数据成员都可以和普通变量一样, 但要接下划线.</strong></p>
<pre><code>class TableInfo {
  ...
 private:
  string table_name_;  // 好 - 后加下划线.
  string tablename_;   // 好.
  static Pool&lt;TableInfo&gt;* pool_;  // 好.
};
</code></pre>
<p><strong>结构体变量</strong></p>
<p>  不管是静态的还是非静态的, <strong>结构体数据成员都可以和普通变量一样, 不用像类那样接下划线:</strong></p>
<pre><code>struct UrlTableProperties {
  string name;
  int num_entries;
  static Pool&lt;UrlTableProperties&gt;* pool;
};
</code></pre>
<p>  结构体与类的使用讨论, 参考 结构体 vs. 类.</p>
<h3 id="75-常量命名">7.5. 常量命名</h3>
<p><strong>总述</strong></p>
<p>  声明为 <code>constexpr</code> 或 <code>const</code> 的变量, 或在程序运行期间其值始终保持不变的, <strong>命名时以 “k” 开头, 大小写混合</strong>. 例如:</p>
<p><code>const int kDaysInAWeek = 7;</code></p>
<p><strong>说明</strong></p>
<p>  所有具有静态存储类型的变量 (例如<strong>静态变量或全局变量</strong>, 参见 存储类型) <strong>都应当以此方式命名</strong>. 对于其他存储类型的变量, 如自动变量等, 这条规则是可选的. 如果不采用这条规则, 就按照一般的变量命名规则.</p>
<h3 id="76-函数命名">7.6. 函数命名</h3>
<p><strong>总述</strong></p>
<p>  <strong>常规函数使用大小写混合, 取值和设值函数则要求与变量名匹配:</strong></p>
<pre><code>MyExcitingFunction();
MyExcitingMethod();
my_exciting_member_variable(); 
set_my_exciting_member_variable();
</code></pre>
<p><strong>说明</strong></p>
<p>  一般来说, 函数名的<strong>每个单词首字母大写</strong> (即 “驼峰变量名” 或 “帕斯卡变量名”), <strong>没有下划线</strong>. 对于首字母缩写的单词, 更倾向于将它们视作一个单词进行首字母大写 (例如, 写作 StartRpc() 而非 StartRPC()).</p>
<pre><code>AddTableEntry()
DeleteUrl()
OpenFileOrDie()
</code></pre>
<p>(同样的命名规则<strong>同时适用于类作用域与命名空间作用域的常量</strong>, 因为它们是作为 API 的一部分暴露对外的, 因此应当让它们看起来像是一个函数, 因为在这时, 它们实际上是一个对象而非函数的这一事实对外不过是一个无关紧要的实现细节.)</p>
<p>  <strong>取值和设值函数的命名与变量一致. 一般来说它们的名称与实际的成员变量对应</strong>, 但并不强制要求. 例如 int count() 与 void set_count(int count).</p>
<h3 id="77-命名空间命名">7.7. 命名空间命名</h3>
<p><strong>总述</strong></p>
<p>  命名空间以小写字母命名. 最高级命名空间的名字取决于项目名称. 要注意避免嵌套命名空间的名字之间和常见的顶级命名空间的名字之间发生冲突.</p>
<p>  顶级命名空间的名称应当是项目名或者是该命名空间中的代码所属的团队的名字. 命名空间中的代码, 应当存放于和命名空间的名字匹配的文件夹或其子文件夹中.</p>
<p>  注意 不使用缩写作为名称 的规则同样适用于命名空间. 命名空间中的代码极少需要涉及命名空间的名称, 因此没有必要在命名空间中使用缩写.</p>
<p>  要避免嵌套的命名空间与常见的顶级命名空间发生名称冲突. 由于名称查找规则的存在, 命名空间之间的冲突完全有可能导致编译失败. 尤其是, 不要创建嵌套的 std 命名空间. 建议使用更独特的项目标识符 (websearch::index, websearch::index_util) 而非常见的极易发生冲突的名称 (比如 websearch::util).</p>
<p>  对于 internal 命名空间, 要当心加入到同一 internal 命名空间的代码之间发生冲突 (由于内部维护人员通常来自同一团队, 因此常有可能导致冲突). 在这种情况下, 请使用文件名以使得内部名称独一无二 (例如对于 frobber.h, 使用 websearch::index::frobber_internal).</p>
<h3 id="78-枚举命名">7.8. 枚举命名</h3>
<p><strong>总述</strong></p>
<p>  <strong>枚举的命名应当和 常量 或 宏 一致: kEnumName 或是 ENUM_NAME.</strong></p>
<p><strong>说明</strong></p>
<p>  <strong>单独的枚举值应该优先采用 常量 的命名方式</strong>. 但 宏 方式的命名也可以接受. 枚举名 UrlTableErrors (以及 AlternateUrlTableErrors) 是类型, 所以要用大小写混合的方式.</p>
<pre><code>enum UrlTableErrors {
    kOK = 0,
    kErrorOutOfMemory,
    kErrorMalformedInput,
};
enum AlternateUrlTableErrors {
    OK = 0,
    OUT_OF_MEMORY = 1,
    MALFORMED_INPUT = 2,
};
</code></pre>
<p>  2009 年 1 月之前, 我们一直建议采用 宏 的方式命名枚举值. 由于枚举值和宏之间的命名冲突, 直接导致了很多问题. 由此, 这里改为<strong>优先选择常量风格的命名方式. 新代码应该尽可能优先使用常量风格</strong>. 但是老代码没必要切换到常量风格, 除非宏风格确实会产生编译期问题.</p>
<h3 id="79-宏命名">7.9. 宏命名</h3>
<p><strong>总述</strong></p>
<p>  你并不打算 使用宏, 对吧? 如果你一定要用, 像这样命名: <strong>MY_MACRO_THAT_SCARES_SMALL_CHILDREN.</strong></p>
<p><strong>说明</strong></p>
<p>  参考 预处理宏; <strong>通常 不应该 使用宏. 如果不得不用, 其命名像枚举命名一样全部大写, 使用下划线</strong>:</p>
<pre><code>#define ROUND(x) ...
#define PI_ROUNDED 3.0
</code></pre>
<h3 id="710-命名规则的特例">7.10. 命名规则的特例</h3>
<p><strong>总述</strong></p>
<p>如果你命名的实体与已有 C/C++ 实体相似, 可参考现有命名策略.</p>
<p>bigopen(): 函数名, 参照 open() 的形式</p>
<p>uint: typedef</p>
<p>bigpos: struct 或 class, 参照 pos 的形式</p>
<p>sparse_hash_map: STL 型实体; 参照 STL 命名约定</p>
<p>LONGLONG_MAX: 常量, 如同 INT_MAX</p>
<p>译者笔记</p>
<ol>
<li>感觉 Google 的命名约定很高明, 比如写了简单的类 QueryResult, 接着又可以直接定义一个变量 query_result, 区分度很好; 再次, 类内变量以下划线结尾, 那么就可以直接传入同名的形参, 比如 TextQuery::TextQuery(std::string word) : word_(word) {} , 其中 word_ 自然是类内私有成员.</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[并查集 547. 朋友圈[中等]]]></title>
        <id>https://lixin-scut.github.io//post/bing-cha-ji-547-peng-you-quan-zhong-deng</id>
        <link href="https://lixin-scut.github.io//post/bing-cha-ji-547-peng-you-quan-zhong-deng">
        </link>
        <updated>2020-04-29T15:23:01.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。<br>
给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。<br>
示例 1:<br>
输入:<br>
[[1,1,0],<br>
[1,1,0],<br>
[0,0,1]]<br>
输出: 2<br>
说明：已知学生0和学生1互为朋友，他们在一个朋友圈。<br>
第2个学生自己在一个朋友圈。所以返回2。<br>
示例 2:<br>
输入:<br>
[[1,1,0],<br>
[1,1,1],<br>
[0,1,1]]<br>
输出: 1<br>
说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。<br>
注意：<br>
N 在[1,200]的范围内。<br>
对于所有学生，有M[i][i] = 1。<br>
如果有M[i][j] = 1，则有M[j][i] = 1。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/friend-circles<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>一开始我的想法比较秀<br>
直接用一个栈保存当前所有“朋友”下标，然后把相应的列全部置0，每个大循环才把ans加一。缺点就是会导致很多没必要的重复循环，改进的方法可以用一个bool的vector保存状态，直接置false的话避免没必要的循环。</p>
<p>然后看了题解发现是并查集，刚好借助这一题来学习一下并查集吧<br>
核心API就是 union()、find()、connect()和count()这三个成员函数和counts、parents[n]、sizes[n]这三个数据成员</p>
<pre><code>class Solution {
public:
		// 并查集
    int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M)
    {
        counts = M.size();
        for(int i = 0; i &lt; M.size(); ++i)
        {
            parents.push_back(i);
            sizes.push_back(1);
        }
        
        for(int i = 0; i &lt; M.size(); ++i)
        {
            for(int j = i+1; j &lt; M.size(); ++j)
            {
                if(M[i][j] == 1)
                {
                    unionM(i,j);
                }
            }
        }
        return counts;
    }
    
    void unionM(int p, int q)
    {
        int rootP = find(p);
        int rootQ = find(q);
        if(rootP == rootQ)
        {   return ; }
        
        if(sizes[rootP] &lt; sizes[rootQ])
        {
            parents[rootP] = rootQ;
            sizes[rootQ] += sizes[rootP];
        }
        else
        {
            parents[rootQ] = rootP;
            sizes[rootP] += sizes[rootQ];
        }
              
        --counts;
        return;    
    }
    
    int find(int x)
    {
        while(x != parents[x])
        {
            parents[x] = parents[parents[x]];
            x= parents[x];
        }
        return x;
    }
    
    bool connected(int p ,int q)
    {
        int rootP = find(p);
        int rootQ = find(q);
        return (rootP == rootQ);
    }
    
    int count()
    {
        return counts;
    }
    
private:
    int counts;
    vector&lt;int&gt; parents;
    vector&lt;int&gt; sizes;
    
    // DFS
    /*
    int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) {
        int ans = 0;
        stack&lt;int&gt; friends;
        for(int i = 0; i &lt; M.size(); ++i)
        {
            if(M[i][i] == 1)
            {
                ++ans;
                M[i][i] = 0;
            }
            friends.push(i);
            while(!friends.empty())
            {
                int index = friends.top();
                friends.pop();
                for(int j = 0; j &lt; M.size(); ++j)
                {
                    if(index != j)
                    {
                        if(M[index][j] == 1)
                        {
                            friends.push(j);  
                        }
                    }
                    M[index][j] = 0;
                }
            }

        }
        return ans;
    }
    */
};
</code></pre>
<p>题解比较长，就不强行贴上来了，可直接查看<a href="https://leetcode-cn.com/problems/friend-circles/solution/union-find-suan-fa-xiang-jie-by-labuladong/">Union-Find 算法详解</a></p>
<p>核心思想：<br>
我们的 Union-Find 算法主要需要实现这两个 API：</p>
<pre><code>class UF {
    /* 将 p 和 q 连接 */
    public void union(int p, int q);
    /* 判断 p 和 q 是否连通 */
    public boolean connected(int p, int q);
    /* 返回图中有多少个连通分量 */
    public int count();
		
		// 记录连通分量
    private int count;
    // 节点 x 的节点是 parent[x]
    private int[] parent;

    /* 构造函数，n 为图的节点总数 */
    public UF(int n) {
        // 一开始互不连通
        this.count = n;
        // 父节点指针初始指向自己
        parent = new int[n];
        for (int i = 0; i &lt; n; i++)
            parent[i] = i;
    }

}
</code></pre>
<p>如果某两个节点被连通，则让其中的（任意）一个节点的根节点接到另一个节点的根节点上：</p>
<pre><code>public void union(int p, int q) {
    int rootP = find(p);
    int rootQ = find(q);
    if (rootP == rootQ)
        return;
    // 将两棵树合并为一棵
    parent[rootP] = rootQ;
    // parent[rootQ] = rootP 也一样
    count--; // 两个分量合二为一
}

/* 返回某个节点 x 的根节点 */
private int find(int x) {
    // 根节点的 parent[x] == x
    while (parent[x] != x)
        x = parent[x];
    return x;
}

/* 返回当前的连通分量个数 */
public int count() { 
    return count;
}
</code></pre>
<p>这样，如果节点p和q连通的话，它们一定拥有相同的根节点：</p>
<pre><code>public boolean connected(int p, int q) {
    int rootP = find(p);
    int rootQ = find(q);
    return rootP == rootQ;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math 60. 第k个排列[中等]]]></title>
        <id>https://lixin-scut.github.io//post/math-60-di-k-ge-pai-lie-zhong-deng</id>
        <link href="https://lixin-scut.github.io//post/math-60-di-k-ge-pai-lie-zhong-deng">
        </link>
        <updated>2020-04-29T12:57:12.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。<br>
按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：<br>
&quot;123&quot;<br>
&quot;132&quot;<br>
&quot;213&quot;<br>
&quot;231&quot;<br>
&quot;312&quot;<br>
&quot;321&quot;<br>
给定 n 和 k，返回第 k 个排列。<br>
说明：<br>
给定 n 的范围是 [1, 9]。<br>
给定 k 的范围是[1,  n!]。<br>
示例 1:<br>
输入: n = 3, k = 3<br>
输出: &quot;213&quot;<br>
示例 2:<br>
输入: n = 4, k = 9<br>
输出: &quot;2314&quot;<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/permutation-sequence<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>最简单的话就是回溯穷举法了，但是很明显应该是有规律的</p>
<p>首先我们将其视为一个迭代的选择过程，有n层迭代，每层选择上一层没选择过的数字，所以我引入了used的bool数组<br>
然后可以固定每一位上数字的时候，它所处的范围都是固定的，<br>
比如123中 如果选定首位为2，那它至少是3起步的，最多为4的，因为选定首位为1的时候可能的数有两个</p>
<p>然后每一层的可能性数量刚好是<code>(n-1)*(n-2)*...*1</code>,所以流程如下</p>
<ol>
<li>int num = (k - 1) / counts ; counts为当前位数的可能性个数（比如第一位可能性共有6个）算出第一位所需的used的第num+1个数字</li>
<li>然后注意index初始化为-1（受num+1影响），然后记得将j赋给index</li>
<li>赋值并修改used状态</li>
<li>k -= num * counts;减去当前位数所占的数字，然后重复上述步骤计算剩余位</li>
<li>最后一位比较特殊，因为k=0的时候k-1得不到我们想要的结果，所以直接寻找used数组中唯一为true的位数，赋值即可</li>
</ol>
<p>其实很多地方可以优化的，很明显的一个就是我完全可以用vector保存1234...n，然后每次取出然后erase，但是erase存在内存搬移，本质上时间复杂度变化，主要还是代码更加简洁，但是暂时无头绪如何优化，先看看题解</p>
<pre><code>class Solution {
public:
    string getPermutation(int n, int k) {
        string ans ;
        vector&lt;bool&gt; used(n, true);
        int counts = 1;
        for(int i = 1; i &lt; n; ++i)
        {
            counts *= i;
        }
        
        
        
        for(int i = 0; i &lt; n; ++i)
        {
            if(i &lt; n - 1)
            {
                int num = (k - 1) / counts ;
                int index = -1;
                for(int j = 0;j &lt; n; ++j)
                {
                    if(used[j])
                    {
                        ++index;
                        if(index == num)
                        {
                            index = j;
                            break;
                        }
                    }   
                }
                ans.push_back('1' + index);
                used[index] = false;
            
                k -= num * counts;
                
                counts /= (n - i - 1);
            }
            else
            {
                int j = 0;
                for(; j &lt; n ; ++j)
                {
                    if(used[j])
                    {
                        break;
                    }
                }       
                ans.push_back('1' + j);
            }
        }
        
        return ans;
    }
};
</code></pre>
<p>网友题解比较精彩， 不过主体也是利用容器保存123...n，然后逐步erase，然后就是回溯法吧</p>
<blockquote>
<p>深度优先遍历 + 剪枝、双链表模拟<br>
思路分析：<br>
比较容易想到的是，使用同「力扣」第 46 题： “全排列” ，即使用回溯搜索的思想，依次得到全排列，输出所求的第 k 个全排列即可。但事实上，我们不必求出所有的全排列。基于以下几点考虑：<br>
1、我们知道所求排列一定在叶子结点处得到。事实上，进入每一个分支的时候，我们都可以通过递归的层数，直接计算这一分支可以得到的叶子结点的个数；<br>
这是因为：进入一个分支的时候，我们可以根据已经选定的数的个数，进而确定还未选定的数的个数，然后计算阶乘，就知道这一个分支的叶子结点有多少个。<br>
2、如果 k 大于这一个分支将要产生的叶子结点数，直接跳过这个分支，这个操作叫“剪枝”；<br>
3、如果k 小于等于这一个分支将要产生的叶子结点数，那说明所求的全排列一定在这一个分支将要产生的叶子结点里，需要递归求解；<br>
4、计算阶乘的时候，你可以使用循环计算，特别注意：0!=1，它表示了没有数可选的时候，即表示到达叶子结点了，排列数只剩下 1 个；<br>
又因为题目中说“给定 n 的范围是 [1,9]，故可以实现把从 0 到 9 的阶乘计算好，放在一个数组里，可以根据索引直接获得阶乘值，见文后“代码 2”。<br>
方法一：借助“回溯”方法中的“剪枝”技巧</p>
</blockquote>
<pre><code>import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Solution {

    /**
     * 记录数字是否使用过
     */
    private boolean[] used;

    /**
     * 阶乘数组
     */
    private int[] factorial;

    private int n;
    private int k;
    /**
     * 从根结点到叶子结点的路径
     */
    private List&lt;Integer&gt; path;

    public String getPermutation(int n, int k) {
        this.n = n;
        this.k = k;
        used = new boolean[n + 1];
        Arrays.fill(used, false);

        // 计算阶乘数组
        factorial = new int[n + 1];
        factorial[0] = 1;
        for (int i = 1; i &lt;= n; i++) {
            factorial[i] = factorial[i - 1] * i;
        }

        path = new ArrayList&lt;&gt;(n);
        dfs(0);

        StringBuilder stringBuilder = new StringBuilder();
        for (Integer c : path) {
            stringBuilder.append(c);
        }
        return stringBuilder.toString();
    }

    /**
     * @param index 在这一步之前已经选择了几个数字，其值恰好等于这一步需要确定的索引位置
     * @return
     */
    private void dfs(int index) {
        if (index == n) {
            return;
        }

        // 还未确定的数字的全排列的个数，第 1 次进入的时候是 n - 1
        int cnt = factorial[n - 1 - index];
        for (int i = 1; i &lt;= n; i++) {
            if (used[i]) {
                continue;
            }
            if (cnt &lt; k) {
                k -= cnt;
                continue;
            }
            path.add(i);
            used[i] = true;
            dfs(index + 1);
        }
    }
}
</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(N<sup>2)，最坏肯定是要找到第N！个，但是第1层只需要比较N-1次，第2层比较N-2次，以此类推，所以最坏是O(N</sup>2)。<br>
空间复杂度：O(N)，nums、used、pre 都与 N 等长，factorial 数组就 10 个数，是常数级别的。</p>
</blockquote>
<blockquote>
<p>方法二：双链表模拟<br>
事实上，上面的过程也可以循环实现，只不过需要借助一个列表，每次选出一个数，就将这个数从列表里面拿出。因为这个列表要支持频繁的删除操作，因此使用双链表，在 Java 中 LinkedList 就是使用双链表实现的。</p>
</blockquote>
<pre><code>import java.util.LinkedList;
import java.util.List;

public class Solution {

    public String getPermutation(int n, int k) {
        // 注意：相当于在 n 个数字的全排列中找到索引为 k - 1 的那个数，因此 k 先减 1
        k --;

        int[] factorial = new int[n];
        factorial[0] = 1;
        // 先算出所有的阶乘值
				//  {0,1,2,6,24,120,720,5040,40320,362880,3628800};
        for (int i = 1; i &lt; n; i++) {
            factorial[i] = factorial[i - 1] * i;
        }

        // 因为要频繁做删除，使用链表
        List&lt;Integer&gt; nums = new LinkedList&lt;&gt;();
        for (int i = 1; i &lt;= n; i++) {
            nums.add(i);
        }

        StringBuilder stringBuilder = new StringBuilder();

        // i 表示剩余的数字个数，初始化为 n - 1
        for (int i = n - 1; i &gt;= 0; i--) {
            int index = k / factorial[i] ;
            stringBuilder.append(nums.remove(index));
            k -= index * factorial[i];
        }
        return stringBuilder.toString();
    }
}
</code></pre>
<p>贴一个C++版</p>
<pre><code>class Solution {
    static const vector&lt;int&gt; fac;
public:
    string getPermutation(int n, int k) {
        string res;
        string s = string(&quot;123456789&quot;).substr(0, n);
        --k;
        while(k &gt; 0)
        {
            size_t i = k/fac[n - 1];
            res.push_back(s[i]);
            s.erase(s.begin() + i);
            k %= fac[n - 1];
            --n;
        }
        return res + s;
    }
};
const vector&lt;int&gt; Solution::fac = {0,1,2,6,24,120,720,5040,40320,362880,3628800};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL 175. 组合两个表[简单]]]></title>
        <id>https://lixin-scut.github.io//post/mysql-175-zu-he-liang-ge-biao-jian-dan</id>
        <link href="https://lixin-scut.github.io//post/mysql-175-zu-he-liang-ge-biao-jian-dan">
        </link>
        <updated>2020-04-29T07:26:44.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>表1: Person<br>
+-------------+---------+<br>
| 列名         | 类型     |<br>
+-------------+---------+<br>
| PersonId    | int     |<br>
| FirstName   | varchar |<br>
| LastName    | varchar |<br>
+-------------+---------+<br>
PersonId 是上表主键<br>
表2: Address<br>
+-------------+---------+<br>
| 列名         | 类型    |<br>
+-------------+---------+<br>
| AddressId   | int     |<br>
| PersonId    | int     |<br>
| City        | varchar |<br>
| State       | varchar |<br>
+-------------+---------+<br>
AddressId 是上表主键<br>
 编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：<br>
FirstName, LastName, City, State<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/combine-two-tables<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题比较简单，重点在于“无论 person 是否有地址信息”，主要就是默认的inner join和outer join的区别，并且还有on和where的区别</p>
<pre><code>SELECT FirstName, LastName, City, State
FROM Person LEFT OUTER JOIN Address
ON Person.PersonId = Address.PersonId
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>方法：使用 outer join<br>
算法<br>
因为表 Address 中的 personId 是表 Person 的外关键字，所以我们可以连接这两个表来获取一个人的地址信息。<br>
考虑到可能不是每个人都有地址信息，我们应该使用 outer join 而不是默认的 inner join。</p>
</blockquote>
<pre><code>MySQL
select FirstName, LastName, City, State
from Person left join Address
on Person.PersonId = Address.PersonId
;
</code></pre>
<p><strong>注意：如果没有某个人的地址信息，使用 where 子句过滤记录将失败，因为它不会显示姓名信息。</strong></p>
<p><strong>《MySQL必知必会》相关知识点</strong><br>
  MySQL的联结表默认为内部联结或等值联结(equijoin)的简单联结，另外三种联结分别是自联结、自然联结和外部联结。</p>
<p><strong>自联结</strong><br>
  自联结就是同一个表联结起来，需要配合表别名使用，使用表别名的主要原因之一是能在单条SELECT语句中不止一次引用相同的表</p>
<p>  自联结可以解决子查询的问题： 自联结通常作为外部语句用来替代 从相同表中检索数据时使用的子查询语句。虽然最终的结果是 相同的，但有时候处理联结远比处理子查询快得多。应该试一 下两种方法，以确定哪一种的性能更好</p>
<p><strong>自然联结</strong><br>
  标准的联结(前一章中介绍的内部联结)返回所有数据，甚 至相同的列多次出现。自然联结排除多次出现，使每个列只返回一次。<br>
  但是系统不完成这项工作，由你自己完成它。自然联结是这样一种联结，其中你只能选择那些唯一的列。这一 般是通过对表使用通配符(SELECT * )，对所有其他表的列使用明确的子 集来完成的。</p>
<p>  事实上，迄今为止我们默认建立的每个内部联结都是自然联结，很可能我们永远都不会用到不是自然联结的内部联结。</p>
<p><strong>外部联结</strong><br>
  联结包含了那些在相关表中没有关联行的行。这种 类型的联结称为外部联结。<br>
  许多联结将一个表中的行与另一个表中的行相关联。但有时候会需要包含没有关联行的那些行。<br>
  在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字 指定包括其所有行的表(RIGHT指出的是OUTER JOIN右边的表，而LEFT 指出的是OUTER JOIN左边的表)。</p>
<p><strong>外部联结的类型</strong><br>
  存在两种基本的外部联结形式:左外部联结 和右外部联结。它们之间的唯一差别是所关联的表的顺序不 同。换句话说，左外部联结可通过颠倒FROM或WHERE子句中表的顺序转换为右外部联结。因此，两种类型的外部联结可互 换使用，而究竟使用哪一种纯粹是根据方便而定。</p>
<p>  使用LEFT OUTER JOIN从FROM子句的左边表中选择所有行。为了从右边的表中选择所有行，应该使用RIGHT OUTER JOIN</p>
<p>注意<br>
  没有<code>*=</code>操作符 MySQL不支持简化字符<code>*=</code>和<code>=*</code>的使用，这两 种操作符在其他DBMS中是很流行的。</p>
<p><strong>使用带聚集函数的联结</strong><br>
  聚集函数用来汇总数据。虽然至今为止聚集函数，但这些函数也可以与联结一起使用。<br>
  聚集函数也可以方便地与其他联结一起使用</p>
<p><strong>使用联结和联结条件</strong></p>
<ul>
<li><strong>注意所使用的联结类型。一般我们使用内部联结，但使用外部联结也是有效的。</strong></li>
<li>保证使用正确的联结条件，否则将返回不正确的数据。</li>
<li><strong>应该总是提供联结条件，否则会得出笛卡儿积。</strong></li>
<li>在一个联结中可以包含多个表，甚至对于每个联结可以采用不同的联结类型。虽然这样做是合法的，一般也很有用，但应该在一 起测试它们前，分别测试每个联结。这将使故障排除更为简单。</li>
</ul>
]]></content>
    </entry>
</feed>