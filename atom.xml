<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2020-01-20T02:19:16.770Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[数组 4. 寻找两个有序数组的中位数[困难][未做出][二分查找][分治法]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-4-xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-shu-kun-nan-wei-zuo-chu-er-fen-cha-zhao-fen-zhi-fa</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-4-xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-shu-kun-nan-wei-zuo-chu-er-fen-cha-zhao-fen-zhi-fa">
        </link>
        <updated>2020-01-20T01:36:27.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。<br>
请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。<br>
你可以假设 nums1 和 nums2 不会同时为空。<br>
示例 1:<br>
nums1 = [1, 3]<br>
nums2 = [2]<br>
则中位数是 2.0<br>
示例 2:<br>
nums1 = [1, 2]<br>
nums2 = [3, 4]<br>
则中位数是 (2 + 3)/2 = 2.5<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>【未做出】<br>
【二分查找】<br>
这道题的难点在于如何把时间复杂度压缩到log(m+n)<br>
也就是说只能通过二分查找来实现<br>
最后毫无疑问还是没做出来<br>
而且题解很复杂...只能靠敲代码来先理解一下了</p>
<pre><code>    //二分寻找分割点
    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        int len1=nums1.size();
        int len2=nums2.size();
        if(len1&gt;len2)
            return findMedianSortedArrays(nums2,nums1);
        int min=0,max=len1;
        while(min&lt;=max){
            int i=min+(max-min)/2;
            int j=(len1+len2+1)/2-i;
            if(j!=0&amp;&amp;i!=len1&amp;&amp;nums2[j-1]&gt;nums1[i])
                min=i+1;
            else if(i!=0&amp;&amp;j!=len2&amp;&amp;nums1[i-1]&gt;nums2[j])
                max=i-1;
            else{
                int maxleft=0;
                if(i==0) maxleft=nums2[j-1];
                else if(j==0) maxleft=nums1[i-1];
                else maxleft=std::max(nums1[i-1],nums2[j-1]);
                if((len1+len2)%2==1) return maxleft;
                
                int minright=0;
                if(i==len1) minright=nums2[j];
                else if(j==len2) minright=nums1[i];
                else minright=std::min(nums2[j],nums1[i]);
                
                return double(maxleft+minright)/2.0;
            }
        }
        return 0.0;
    }
</code></pre>
<pre><code>//log(m+n)的方法
    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2){
        int n=nums1.size();
        int m=nums2.size();
        int left=(n+m+1)/2;
        int right=(n+m+2)/2;
        return double(getKth(nums1,0,n-1,nums2,0,m-1,left)+getKth(nums1,0,n-1,nums2,0,m-1,right))*0.5;
    }
    
    int getKth(vector&lt;int&gt;&amp; nums1,int start1,int end1,vector&lt;int&gt;&amp; nums2,int start2,int end2,int k){
        int len1=end1-start1+1;
        int len2=end2-start2+1;
        if(len1&gt;len2) return getKth(nums2,start2,end2,nums1,start1,end1,k);
        if(len1==0) return nums2[start2+k-1];
        
        if(k==1) return min(nums1[start1],nums2[start2]);
        
        int i=start1+min(len1,k/2)-1;
        int j=start2+min(len2,k/2)-1;
        
        if(nums1[i]&gt;nums2[j])
            return getKth(nums1,start1,end1,nums2,j+1,end2,k-(j-start2+1));
        else
            return getKth(nums1,i+1,end1,nums2,start2,end2,k-(i-start1+1));
    }
</code></pre>
<p>来看一下网友题解：</p>
<blockquote>
<p>解法一<br>
简单粗暴，先将两个数组合并，两个有序数组的合并也是归并排序中的一部分。然后根据奇数，还是偶数，返回中位数。<br>
代码</p>
</blockquote>
<pre><code>public double findMedianSortedArrays(int[] nums1, int[] nums2) {
    int[] nums;
    int m = nums1.length;
    int n = nums2.length;
    nums = new int[m + n];
    if (m == 0) {
        if (n % 2 == 0) {
            return (nums2[n / 2 - 1] + nums2[n / 2]) / 2.0;
        } else {

            return nums2[n / 2];
        }
    }
    if (n == 0) {
        if (m % 2 == 0) {
            return (nums1[m / 2 - 1] + nums1[m / 2]) / 2.0;
        } else {
            return nums1[m / 2];
        }
    }

    int count = 0;
    int i = 0, j = 0;
    while (count != (m + n)) {
        if (i == m) {
            while (j != n) {
                nums[count++] = nums2[j++];
            }
            break;
        }
        if (j == n) {
            while (i != m) {
                nums[count++] = nums1[i++];
            }
            break;
        }

        if (nums1[i] &lt; nums2[j]) {
            nums[count++] = nums1[i++];
        } else {
            nums[count++] = nums2[j++];
        }
    }

    if (count % 2 == 0) {
        return (nums[count / 2 - 1] + nums[count / 2]) / 2.0;
    } else {
        return nums[count / 2];
    }
}
</code></pre>
<blockquote>
<p>时间复杂度：遍历全部数组 (m+n)<br>
空间复杂度：开辟了一个数组，保存合并后的两个数组 O(m+n)</p>
</blockquote>
<blockquote>
<p>解法二<br>
其实，我们不需要将两个数组真的合并，我们只需要找到中位数在哪里就可以了。<br>
开始的思路是写一个循环，然后里边判断是否到了中位数的位置，到了就返回结果，但这里对偶数和奇数的分类会很麻烦。当其中一个数组遍历完后，出了 for 循环对边界的判断也会分几种情况。总体来说，虽然复杂度不影响，但代码会看起来很乱。<br>
首先是怎么将奇数和偶数的情况合并一下。<br>
用 len 表示合并后数组的长度，如果是奇数，我们需要知道第 （len+1）/2 个数就可以了，如果遍历的话需要遍历 int(len/2 ) + 1 次。如果是偶数，我们需要知道第 len/2和 len/2+1 个数，也是需要遍历 len/2+1 次。所以遍历的话，奇数和偶数都是 len/2+1 次。<br>
返回中位数的话，奇数需要最后一次遍历的结果就可以了，偶数需要最后一次和上一次遍历的结果。所以我们用两个变量 left 和 right，right 保存当前循环的结果，在每次循环前将 right 的值赋给 left。这样在最后一次循环的时候，left 将得到 right 的值，也就是上一次循环的结果，接下来 right 更新为最后一次的结果。<br>
循环中该怎么写，什么时候 A 数组后移，什么时候 B 数组后移。用 aStart 和 bStart 分别表示当前指向 A 数组和 B 数组的位置。如果 aStart 还没有到最后并且此时 A 位置的数字小于 B 位置的数组，那么就可以后移了。也就是aStart＜m&amp;&amp;A[aStart]&lt; B[bStart]。<br>
但如果 B 数组此刻已经没有数字了，继续取数字 B[ bStart ]，则会越界，所以判断下 bStart 是否大于数组长度了，这样 || 后边的就不会执行了，也就不会导致错误了，所以增加为 aStart＜m&amp;&amp;(bStart) &gt;= n||A[aStart]&lt;B[bStart]) 。</p>
</blockquote>
<pre><code>public double findMedianSortedArrays(int[] A, int[] B) {
    int m = A.length;
    int n = B.length;
    int len = m + n;
    int left = -1, right = -1;
    int aStart = 0, bStart = 0;
    for (int i = 0; i &lt;= len / 2; i++) {
        left = right;
        if (aStart &lt; m &amp;&amp; (bStart &gt;= n || A[aStart] &lt; B[bStart])) {
            right = A[aStart++];
        } else {
            right = B[bStart++];
        }
    }
    if ((len &amp; 1) == 0)
        return (left + right) / 2.0;
    else
        return right;
}
</code></pre>
<blockquote>
<p>时间复杂度：遍历 len/2+1 次，len=m+n，所以时间复杂度依旧是 O(m+n)。<br>
空间复杂度：我们申请了常数个变量，也就是 m，n，len，left，right，aStart，bStart 以及 i。<br>
总共 8 个变量，所以空间复杂度是 O(1)。</p>
</blockquote>
<blockquote>
<p>解法三<br>
上边的两种思路，时间复杂度都达不到题目的要求 O(log(m+n)。看到 log，很明显，我们只有用到二分的方法才能达到。我们不妨用另一种思路，题目是求中位数，其实就是求第 k 小数的一种特殊情况，而求第 k 小数有一种算法。<br>
解法二中，我们一次遍历就相当于去掉不可能是中位数的一个值，也就是一个一个排除。由于数列是有序的，其实我们完全可以一半儿一半儿的排除。假设我们要找第 k 小数，我们可以每次循环排除掉 k/2 个数。看下边一个例子。<br>
假设我们要找第 7 小的数字。</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1579485718965.png" alt=""></p>
<blockquote>
<p>我们比较两个数组的第 k/2 个数字，如果 k 是奇数，向下取整。也就是比较第 3 个数字，上边数组中的 4 和下边数组中的 3，如果哪个小，就表明该数组的前 k/2 个数字都不是第 k 小数字，所以可以排除。也就是 1，2，3 这三个数字不可能是第 7 小的数字，我们可以把它排除掉。将 1349 和 45678910 两个数组作为新的数组进行比较。<br>
更一般的情况 A[1] ，A[2] ，A[3]，A[k/2] ... ，B[1]，B[2]，B[3]，B[k/2] ... ，如果 A[k/2]&lt;B[k/2] ，那么A[1]，A[2]，A[3]，A[k/2]都不可能是第 k 小的数字。<br>
A 数组中比 A[k/2] 小的数有 k/2-1 个，B 数组中，B[k/2] 比 A[k/2] 小，假设 B[k/2] 前边的数字都比 A[k/2] 小，也只有 k/2-1 个，所以比 A[k/2] 小的数字最多有 k/1-1+k/2-1=k-2个，所以 A[k/2] 最多是第 k-1 小的数。而比 A[k/2] 小的数更不可能是第 k 小的数了，所以可以把它们排除。<br>
橙色的部分表示已经去掉的数字。</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1579485758441.png" alt=""></p>
<blockquote>
<p>由于我们已经排除掉了 3 个数字，就是这 3 个数字一定在最前边，所以在两个新数组中，我们只需要找第 7 - 3 = 4 小的数字就可以了，也就是 k = 4。此时两个数组，比较第 2 个数字，3 &lt; 5，所以我们可以把小的那个数组中的 1 ，3 排除掉了。</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1579485777165.png" alt=""></p>
<blockquote>
<p>我们又排除掉 2 个数字，所以现在找第 4 - 2 = 2 小的数字就可以了。此时比较两个数组中的第 k / 2 = 1 个数，4 == 4，怎么办呢？由于两个数相等，所以我们无论去掉哪个数组中的都行，因为去掉 1 个总会保留 1 个的，所以没有影响。为了统一，我们就假设 4 &gt; 4 吧，所以此时将下边的 4 去掉。</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1579485790534.png" alt=""></p>
<blockquote>
<p>由于又去掉 1 个数字，此时我们要找第 1 小的数字，所以只需判断两个数组中第一个数字哪个小就可以了，也就是 4。<br>
所以第 7 小的数字是 4。<br>
我们每次都是取 k/2 的数进行比较，有时候可能会遇到数组长度小于 k/2的时候。</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1579485802417.png" alt=""></p>
<blockquote>
<p>此时 k / 2 等于 3，而上边的数组长度是 2，我们此时将箭头指向它的末尾就可以了。这样的话，由于 2 &lt; 3，所以就会导致上边的数组 1，2 都被排除。造成下边的情况。</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1579485818138.png" alt=""></p>
<blockquote>
<p>由于 2 个元素被排除，所以此时 k = 5，又由于上边的数组已经空了，我们只需要返回下边的数组的第 5 个数字就可以了。<br>
从上边可以看到，无论是找第奇数个还是第偶数个数字，对我们的算法并没有影响，而且在算法进行中，k 的值都有可能从奇数变为偶数，最终都会变为 1 或者由于一个数组空了，直接返回结果。<br>
所以我们采用递归的思路，为了防止数组长度小于 k/2，所以每次比较 min(k/2，len(数组) 对应的数字，把小的那个对应的数组的数字排除，将两个新数组进入递归，并且 k 要减去排除的数字的个数。递归出口就是当 k=1 或者其中一个数字长度是 0 了。</p>
</blockquote>
<pre><code>public double findMedianSortedArrays(int[] nums1, int[] nums2) {
    int n = nums1.length;
    int m = nums2.length;
    int left = (n + m + 1) / 2;
    int right = (n + m + 2) / 2;
    //将偶数和奇数的情况合并，如果是奇数，会求两次同样的 k 。
    return (getKth(nums1, 0, n - 1, nums2, 0, m - 1, left) + getKth(nums1, 0, n - 1, nums2, 0, m - 1, right)) * 0.5;  
}
    
    private int getKth(int[] nums1, int start1, int end1, int[] nums2, int start2, int end2, int k) {
        int len1 = end1 - start1 + 1;
        int len2 = end2 - start2 + 1;
        //让 len1 的长度小于 len2，这样就能保证如果有数组空了，一定是 len1 
        if (len1 &gt; len2) return getKth(nums2, start2, end2, nums1, start1, end1, k);
        if (len1 == 0) return nums2[start2 + k - 1];

        if (k == 1) return Math.min(nums1[start1], nums2[start2]);

        int i = start1 + Math.min(len1, k / 2) - 1;
        int j = start2 + Math.min(len2, k / 2) - 1;

        if (nums1[i] &gt; nums2[j]) {
            return getKth(nums1, start1, end1, nums2, j + 1, end2, k - (j - start2 + 1));
        }
        else {
            return getKth(nums1, i + 1, end1, nums2, start2, end2, k - (i - start1 + 1));
        }
    }
</code></pre>
<blockquote>
<p>时间复杂度：每进行一次循环，我们就减少 k/2 个元素，所以时间复杂度是 O(log(k))，而 k=(m+n)/2，所以最终的复杂也就是O(log(m+n）。<br>
空间复杂度：虽然我们用到了递归，但是可以看到这个递归属于尾递归，所以编译器不需要不停地堆栈，所以空间复杂度为 O(1)。</p>
</blockquote>
<blockquote>
<p>解法四<br>
我们首先理一下中位数的定义是什么<br>
中位数（又称中值，英语：Median）中的专有名词，代表一个样本、种群或 中的一个数值，其可将数值集合划分为相等的上下两部分。<br>
所以我们只需要将数组进行切。<br>
一个长度为 m 的数组，有 0 到 m 总共 m + 1 个位置可以切。</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1579486075016.png" alt=""></p>
<blockquote>
<p>我们把数组 A 和数组 B 分别在 i 和 j 进行切割。</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1579486089238.png" alt=""></p>
<blockquote>
<p>将 i 的左边和 j 的左边组合成「左半部分」，将 i 的右边和 j 的右边组合成「右半部分」。</p>
</blockquote>
<blockquote>
<p>当 A 数组和 B 数组的总长度是偶数时，如果我们能够保证<br>
*左半部分的长度等于右半部分<br>
i + j = m - i  + n - j  , 也就是 j = ( m + n ) / 2 - i<br>
*左半部分最大的值小于等于右半部分最小的值 max ( A [ i - 1 ] , B [ j - 1 ]）） &lt;= min ( A [ i ] , B [ j ]））<br>
那么，中位数就可以表示如下（左半部分最大值 + 右半部分最小值 ）/ 2。<br>
（max ( A [ i - 1 ] , B [  j  - 1 ]）+ min ( A [ i ] , B [ j ]）） /  2</p>
</blockquote>
<blockquote>
<p>当 A 数组和 B 数组的总长度是奇数时，如果我们能够保证<br>
*左半部分的长度比右半部分大 1<br>
i + j = m - i  + n - j  + 1也就是 j = ( m + n + 1) / 2 - i<br>
*左半部分最大的值小于等于右半部分最小的值 max ( A [ i - 1 ] , B [ j - 1 ]）） &lt;= min ( A [ i ] , B [ j ]））<br>
那么，中位数就是左半部分最大值，也就是左半部比右半部分多出的那一个数。max ( A [ i - 1 ] , B [  j - 1 ]）</p>
</blockquote>
<blockquote>
<p>上边的第一个条件我们其实可以合并为j=(m+n+1)/2−i，因为如果 m+n 是偶数，由于我们取的是 intint 值，所以加 11 也不会影响结果。当然，由于 0&lt;=i&lt;=m ，为了保证 0 &lt;= j &lt;= n0&lt;=j&lt;=n，我们必须保证 m&lt;=n。<br>
m≤n,i&lt;m,  j=(m+n+1)/2−i≥(m+m+1)/2−i&gt;(m+m+1)/2−m=0<br>
m≤n,i&gt;0,  j=(m+n+1)/2−i≤(n+n+1)/2−i&lt;(n+n+1)/2=n</p>
</blockquote>
<blockquote>
<p>最后一步由于是 int 间的运算，所以 1/2=01/2=0。<br>
而对于第二个条件，奇数和偶数的情况是一样的，我们进一步分析。为了保证 max ( A [ i - 1 ] , B [ j - 1 ]）） &lt;= min ( A [ i ] , B [ j ]）），因为 A 数组和 B 数组是有序的，所以 A [ i - 1 ] &lt;= A [ i ]，B [ i - 1 ] &lt;= B [ i ] 这是天然的，所以我们只需要保证 B [ j - 1 ] &lt; = A [ i ] 和 A [ i - 1 ] &lt;= B [ j ] 所以我们分两种情况讨论：</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1579486260677.png" alt=""><br>
<img src="https://lixin-ee.github.io//post-images/1579486275631.png" alt=""></p>
<pre><code>class Solution {
    public double findMedianSortedArrays(int[] A, int[] B) {
        int m = A.length;
        int n = B.length;
        if (m &gt; n) { 
            return findMedianSortedArrays(B,A); // 保证 m &lt;= n
        }
        int iMin = 0, iMax = m;
        while (iMin &lt;= iMax) {
            int i = (iMin + iMax) / 2;
            int j = (m + n + 1) / 2 - i;
            if (j != 0 &amp;&amp; i != m &amp;&amp; B[j-1] &gt; A[i]){ // i 需要增大
                iMin = i + 1; 
            }
            else if (i != 0 &amp;&amp; j != n &amp;&amp; A[i-1] &gt; B[j]) { // i 需要减小
                iMax = i - 1; 
            }
            else { // 达到要求，并且将边界条件列出来单独考虑
                int maxLeft = 0;
                if (i == 0) { maxLeft = B[j-1]; }
                else if (j == 0) { maxLeft = A[i-1]; }
                else { maxLeft = Math.max(A[i-1], B[j-1]); }
                if ( (m + n) % 2 == 1 ) { return maxLeft; } // 奇数的话不需要考虑右半部分

                int minRight = 0;
                if (i == m) { minRight = B[j]; }
                else if (j == n) { minRight = A[i]; }
                else { minRight = Math.min(B[j], A[i]); }

                return (maxLeft + minRight) / 2.0; //如果是偶数的话返回结果
            }
        }
        return 0.0;
    }
}
</code></pre>
<blockquote>
<p>时间复杂度：我们对较短的数组进行了二分查找，所以时间复杂度是 O(log（min（m，n））。<br>
空间复杂度：只有一些固定的变量，和数组长度无关，所以空间复杂度是 O(1)。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ UNP 第十一章 守护进程]]></title>
        <id>https://lixin-ee.github.io//post/unp-di-shi-yi-zhang-shou-hu-jin-cheng</id>
        <link href="https://lixin-ee.github.io//post/unp-di-shi-yi-zhang-shou-hu-jin-cheng">
        </link>
        <updated>2020-01-19T14:44:23.000Z</updated>
        <content type="html"><![CDATA[<h3 id="概述">概述</h3>
<p>守护进程(daemon)是在后台运行且不与任何控制终端关联的进程，执行不同的管理任务。<br>
守护进程没有控制终端，通常源于它们由系统初始化脚本启动。<br>
然而守护进程也可能从某个 终端由用户在shell提示符下键入命令行启动，这样的守护进程必须亲自脱离与控制终端的关联, 从而避免与作业控制、终端会话管理、终端产生信号等发生任何不期望的交互，也可以避免在 后台运行的守护进程非预期地输出到终端。</p>
<p>守护进程的多种启动方法：<br>
(1)	在系统启动阶段，许多守护进程由系统初始化脚本启动。<br>
这些脚本通常位于/etc目录 或以/etc/rc开头的某个目录中，它们的具体位置和内容却是实现相关的。由这些脚本启动的 守护进程一开始时拥有超级用户特权。<br>
inetd超级服务器、Web服务器、 邮件服务器和syslogd守护进程都是由脚本启动的<br>
(2)许多网络服务器由inetd超级服务器启动。inetd自身又由上一条中的某个脚本启动。inetd监听网络请求(Telnet、FTP等)，每当有一个请求到达时，启动相应的 实际服务器(Telnet服务器、FTP服务器等)。<br>
(3)	cron守护进程按照规则定期执行一些程序，<br>
(4)	at命令用于指定将来某个时刻的程序执行。<br>
(5)	守护进程还可以从用户终端或在前台或在后台启动。这么做往往是为了测试守护程序或重启因某种原因而终止了的某个守护进程。</p>
<p>syslog函数是输出消息的标准方法，它把消息发送给syslogd守护进程。因为守护进程没有控制终端，所以当有事发生时它们得有输出消息的某种方法可用，而这 些消息既可能是普通的通告性消息，也可能是需由系统管理员处理的紧急事件消息。</p>
<h3 id="syslogd守护进程">syslogd守护进程</h3>
<p>Unix系统中的syslogd守护进程通常由某个系统初始化脚本启动，而且在系统工作期间一 直运行<br>
(1)	读取配置文件，通常为/etc/syslog.conf的配置文件指定本守护进程可能收取的各种 日志消息(logmessage)应该如何处理。<br>
(2)	创建一个Unix域数据报套接字，给它捆绑路径名/var/run/log<br>
(3)	创建一个UDP套接字，给它捆绑端口514 (syslog服务使用的端口号)。<br>
(4)	打开路径名/dev/klog，来自内核中的任何出错消息看着像是这个设备的输入。</p>
<p>此后syslogd守护进程在一个无限循环中运行：调用select以等待它的3个描述符(分别来自上述第2、第3和第4步)之一变为可读，读入日志消息，并按照配置文件进行处理。</p>
<p>通过创建一个Unix域数据报套接字，我们就可以从自己的守护进程中通过往syslogd绑定的路径名发送我们的消息达到发送日志消息的目的（然而更简单的接口是使用syslog函数）<br>
另外，我们也可以创建一个UDP套接字，通过往环回地址和端口514发送我们的消息达到发送日志消息的目的。</p>
<h3 id="syslog-函数">syslog 函数</h3>
<p>既然守护进程没有控制终端，它们就不能把消息fprintf到stderr上。从守护进程中登记消息的常用技巧就是调用syslog函数。</p>
<pre><code>#include &lt;syslog.h&gt;
void syslog (int priority, const char * message,...)；
</code></pre>
<p>priority参数是级别(level)和设施(facility)两者的组合<br>
message参数类似printf的格式串，不过增设了&amp;m规范，它将被替换成与当前errno值对应的出错消息。<br>
<img src="https://lixin-ee.github.io//post-images/1579445628642.png" alt=""><br>
级别(level)和设施(facility)的目的在于，允许在/etc/syslog.conf文件中统一配置来自同--给定设施的所有 消息，或者统一配置具有相同级别的所有消息。</p>
<p>当syslog被应用进程首次调用时，它创建一个Unix域数据报套接字，然后调用connect连接到由syslogd守护进程创建的Unix域数据报套接字的众所周知路径名<br>
这个套接字一直保持打开，直到进程终止为止。作为替换，进程也可以调用openlog和closelog。<br>
<img src="https://lixin-ee.github.io//post-images/1579445774736.png" alt=""></p>
<h3 id="inetd守护进程">inetd守护进程</h3>
<p>系统可能存在许多服务器，普通的网络服务进程模型存在两个问题<br>
(1)	所有这些守护进程含有几乎相同的启动代码，既表现在创建套接字上，也表现在演变成 守护进程上<br>
(2)	每个守护进程在进程表中占据一个表项，然而它们大部分时间处于睡眠状态。<br>
4.3BSD版本通过提供一个因特网超级服务器(即inetd守护进程)<br>
(1)	通过由inetd处理普通守护进程的大部分启动细节以简化守护程序的编写。<br>
(2)	单个进程(inetd)就能为多个服务等待外来的客户请求，以此取代每个服务一个进程 的做法。<br>
<img src="https://lixin-ee.github.io//post-images/1579446077984.png" alt=""><br>
子进程调用dup2三次，把这个待处理套接字的描述符复制到描述符0、1和2 (标 准输入、标准输出和标准错误输出)，然后关闭原套接字描述符。子进程打开的描述符于是只有 0、1和2。子进程自标准输入读实际是从所处理的套接字读，往标准输出或标准错误输出写实际 上是往所处理的套接字写。</p>
<p>inetd通常不适用于服务密集型服务器，其中值得注意的有邮件服务器和Web服务器。举例来说，我们在4.8节介绍过的sendmail通常作为一个标准的并发服务器来运行。这种模式下每个客户连接的进程控制开销仅仅是一个fork,而由inetd启动的每个TCP服务器的开销是一个fork加一个exec。而Web服务器则使用多种技术把每个客户连接的进程控制开销降低到最小</p>
<h3 id="总结">总结：</h3>
<p>守护进程是在后台运行并独立于所有终端控制的进程。许多网络服务器作为守护进程运行。守护进程产生的所有输出通常通过调用syslog函数发送给syslogd守护进程。系统管理员可根 据发送消息的守护进程以及消息的严重级别，完全控制这些消息的处理方式。<br>
启动任意一个程序并让它作为守护进程运行需要以下步骤：调用fork以转到后台运行，调用setsid建立一个新的POSIX会话并成为会话头进程，再次fork以避免无意中获得新的控制终端，改变工作目录和文件创建模式掩码，最后关闭所有非必要的描述符。unp编写daemon_init 函数处理所有这些细节。<br>
许多Unix服务器由inetd守护进程启动。它处理全部守护进程化所需的步骤，当启动真正 的服务器时，套接字已在标准输入、标准输出和标准错误输出上打开。这样我们无需调用 socket、bind、listen和accpet,因为这些步骤已由inetd处理。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UNP 第十一章 名字与地址转换]]></title>
        <id>https://lixin-ee.github.io//post/unp-di-shi-yi-zhang-ming-zi-yu-di-zhi-zhuan-huan</id>
        <link href="https://lixin-ee.github.io//post/unp-di-shi-yi-zhang-ming-zi-yu-di-zhi-zhuan-huan">
        </link>
        <updated>2020-01-19T12:32:29.000Z</updated>
        <content type="html"><![CDATA[<p>数值地址可以变动而名字保持不变；</p>
<h3 id="域名系统">域名系统</h3>
<p>域名系统(Domain Name System, DNS)主要用于主机名字与IP地址之间的映射。</p>
<p>资源记录：DNS中的条目称为资源记录(resource record, RR)。<br>
A A记录把一个主机名映射成一个32位的IPv4地址<br>
PTR 称为&quot;指针记录&quot;(pointer record)的PTR记录把IP地址映射成主机名。对于IPv4 地址，32位地址的4个字节先反转顺序，每个字节都转换成各自的十进制ASCII 值(0~255)后，再添上in-addr.arpa,结果字符串用于PTR查询。<br>
MX	MX记录把一个主机指定作为给定主机的&quot;邮件交换器&quot;(mail exchanger)<br>
CNAME CNAME代表&quot;canonical name&quot;(规范名字)，它的常见用法是为常用的服务(例 如ftp和www)指派CNAME记录。</p>
<p><strong>解析器和名字服务器</strong><br>
  每个组织机构往往运行一个或多个名字服务器(name server),它们通常就是所谓的BIND(Berkeley Internet Name Domain的简称)程序。诸如我们在本书中编写的客户和服务器等应用程序通过调用称为解析器(resolver)的函数库中的函数接触DNS服务器。<br>
  常见的解析器函数是gethostbyname和gethostbyaddr，前者把主机名映射成IPv4地址，后者则执行相反的映射。<br>
由全体应用进程共享的集中式解析器守护进程<br>
<img src="https://lixin-ee.github.io//post-images/1579437602489.png" alt=""></p>
<h3 id="gethostbyname-函数">gethostbyname 函数</h3>
<p>大多数应用程序应该处理名字而不是地址。<br>
查找主机名最基本的函数是gethostbyname，如果调用成功，它就返回一个指向hostent 结构的指针，该结构中含有所查找主机的所有IPv4地址。<br>
这个函数只能返回IPv4地址，getaddrinfo函数能够同时处理IPv4地址和IPv6地址。</p>
<pre><code>#include &lt;netdb.h&gt;
struct hostent * gethostbyname (const char * hostname)；
返回：若成功则为非空指针，若出错则为NULL旦设置h_ermo
</code></pre>
<p>函数返回的非空指针指向如下的hostent结构。</p>
<pre><code>struct hostent {
char	*h_name；	/* official (canonical) name of host */
char	**h_aliases；	/* pointer to array of pointers to alias names */
int	h_addrtype ；	/* host address type： AF_INET */
int	h_length;	/* length of address： 4 */
char	**h_addr_list；	/* ptr to array of ptrs with IPv4 addrs */
};
</code></pre>
<p>gethostbyname执行的是对A记录的查询。它只能返回IPv4地址。<br>
hostent中所查询主机的正式主机名(official host)和所有别名(alias)都是以空字符结尾的C字符串。<br>
返回的h_name称为所查询主机的规范(canonical)名字<br>
<img src="https://lixin-ee.github.io//post-images/1579438562380.png" alt=""><br>
gethostbyname与我们介绍过的其他套接字函数的不同之处在于：当发生错误时，它不设置errno变量，而是将全局整数变量h_errno设置为在头文件&lt;netdb.h&gt;中定义的下列常值之一：<br>
•	HOST_NOT_FOUND;<br>
•	TRY_AGAIN;<br>
•	NO_RECOVERY;<br>
•	NO_DATA (等同于NO_ADDRESS)。<br>
如今多数解析器提供名为hstrerror的函数，它以某个h_errno值作为唯一的参数，返回 的是一个const char * 指针，指向相应错误的说明。</p>
<pre><code>代码图11-3
</code></pre>
<h3 id="gethostbyaddr-函数">gethostbyaddr 函数</h3>
<p>gethostbyaddr函数试图由一个二进制的IP地址找到相应的主机名，与gethostbyname的行为刚好相反。</p>
<pre><code>#include &lt;netdb.h&gt;
struct hostent *gethostbyaddr （const char *addr, socklen_t len, int family）；
返回：若成功则为非空指针，若出错则为NULL旦设置h_errno
</code></pre>
<p>本函数返回一个指向与之前所述同样的hostent结构的指针，感兴趣的字段通常是存放规范主机名的h_name<br>
addr参数实际上不是char * 类型，而是一个指向存放IPv4地址的某个in_addr结构的指针； len参数是这个结构的大小：对于IPv4地址为4。family参数为AF_INET。<br>
gethostbyaddr在in_addr.arpa域中向一个名字服务器查询PTR记录</p>
<h3 id="getservbyname-和-getservbyport-函数">getservbyname 和 getservbyport 函数</h3>
<p>getservtbyname函数用于根据给定名字查找相应服务的端口号</p>
<pre><code>#include &lt;netdb.h&gt;
struct servent *getservbyname (const char *servname, const char * protoname)；
返回：若成功则为非空指针，若出错则为NULL
</code></pre>
<p>函数返回的非空指针指向如下的servent结构。</p>
<pre><code>struct servent (
char * s_name ；
char **s_aliases；
int s_port;
char *s_proto； /* protocol to use */
};
</code></pre>
<p>服务名参数servmme必须指定。如果同时指定了协议(Wprotoname参数为非空指针)，那么指定服务必须有匹配的协议。<br>
如protoname 未指定而servname指定服务支持多个协议，那么返回哪个端口号取决于实现。<br>
servent结构中我们关心的主要字段是端口号。既然端口号是<strong>以网络字节序（大端序）返回</strong>的，把它存放到套接字地址结构时<strong>绝对不能调用htons</strong></p>
<p>getservbyport用于根据给定端口号和可选协议查找相应服务</p>
<pre><code>#include &lt;netdb.h&gt;
struct servent *getservbyport (int port, const char * protoname);
返回：若成功则为非空指针，若出错则为NULL
</code></pre>
<p>prot参数的值必须为网络字节序，所以需要使用htons将int转化为网络字节序的大端序<br>
必须清楚的是，协议参数并非可有可无，一个端口在不同协议上可以对应不同服务，有些端口号在TCP上用于一种服务，在UDP上却用于完全不同的另一种服务。</p>
<pre><code>code 图11-4
</code></pre>
<h3 id="getaddrinfo-函数">getaddrinfo 函数</h3>
<p>前面的gethostbyname和gethostbyaddr这两个函数仅仅支持IPv4。<br>
getaddrinfo函数能够处理<strong>名字到地址</strong>以及<strong>服务到端口</strong>这两种转换，返回的是一个<strong>sockaddr结构</strong>而不是一个地址列表。这些sockaddr结构随后<strong>可由套接字函数直接使用</strong>。<br>
getaddrinfo函数把<strong>协议相关性</strong>完全隐藏在这个库函数内部。</p>
<pre><code>#include &lt;netdb.h&gt;
int getaddrinfo (const char * hostname, const char * service, const struct addrinfo *hints, struct addrinfo **result)；
返回：若成功则为0,若出错则为非0
</code></pre>
<p>本函数通过result指针参数返回一个指向<strong>addrinfo结构链表</strong>的指针<br>
<img src="https://lixin-ee.github.io//post-images/1579439365268.png" alt=""><br>
hostname参数是一个主机名或地址串<br>
service参数是一个服务名或十进制端口号数串<br>
hints参数可以是一个空指针，也可以是一个指向某个addrinfo结构的指针，调用者在这个 结构中填入关于<strong>期望返回的信息类型的暗示</strong><br>
举例来说，如果指定的服务既支持TCP也支持UDP （例如指代某个DNS服务器的domain服务），那么调用者可以把如hints结构中的ai_socktype成员设置为SOCK_DGRAM，使得返回的仅仅是适用于数据报套接字的信息。<br>
hints结构中调用者可以设置的成员有：<br>
•	ai_flags （零个或多个或在一起的AI_xxx值）；<br>
•	ai_fainily （某个AF_xxx值）；<br>
•	ai_socktype （某个SOCK_xxx值）；<br>
•	ai_protocol<br>
ai_flags成员可用的标志值及其含义如下<br>
<img src="https://lixin-ee.github.io//post-images/1579439508597.png" alt=""><br>
如果hints参数是一个空指针，本函数就假设ai_flag、ai_socktype和ai_protocol的值均为0，ai_family的值为AF_UNSPEC<br>
如果本函数返回成功,result参数指向的变量已被填入一个指针，它指向的是由其中的ai_next成员串接起来的<strong>addrinfo结构链表</strong>。<br>
可导致返回多个addrinfo结构的情形有以 下两个<br>
⑴ 如果与hostname参数关联的地址有多个，那么适用于所请求地址族(可通过加* 结构的 ai.family成员设置)的每个地址都返回一个对应的结构。<br>
(2)如果service参数指定的服务支持多个套接字类型，那么每个套接字类型都可能返回一个对应的结构，具体取决于hints结构的ai_socktype成员<br>
<img src="https://lixin-ee.github.io//post-images/1579439728957.png" alt=""><br>
<img src="https://lixin-ee.github.io//post-images/1579439862881.png" alt=""><br>
<img src="https://lixin-ee.github.io//post-images/1579439744282.png" alt=""><br>
在addrinfo结构中返回的信息可现成用于socket调用，随后现成用于适合客户的connect 或sendto调用，或者是适合服务器的bind调用。<br>
socket函数的参数就是addrinfo结构中的 ai_family、ai_socktype和ai_addr成员。connect或bind函数的第二个和第三个参数就是该 结构中的ai_addr (―个指向适当类型套接字地址结构的指针，地址结构的内容由getaddrinfo 函数填写)和ai_addrlen (这个套接字地址结构的大小)成员。<br>
如果在hints结构中设置了AI_CANONNAME标志，那么本函数返回的第一个addrinfo结构的 ai_canonname成员指向所查找主机的规范名字。<br>
<img src="https://lixin-ee.github.io//post-images/1579439933528.png" alt=""><br>
只有在未提供ai_socktype暗示信息时才可能为每个IP地址返回多个addrinfo结构<br>
常见的输入：<br>
•指定hostname和service。这是TCP或UDP客户进程调用getaddrinfo的常规输入。该调用 返回后，TCP客户在一个循环中针对每个返回的IP地址，逐一调用socket和connect, 直到有一个连接成功<br>
•典型的服务器进程只指定service而不指定hostname,同时在hints结构中指定AI_PASSIVE标志。返回的套接字地址结构中应含有一个值为INADDR_ANY （对于IPv4 ）的IP地址。TCP服务器随后调用socket、bind和listen。<br>
如果服务器想要malloc另一个套接字地址结构以从accept获取客户的地址，那么返回的 ai_addrlen值给出了这个套接字地址结构的大小。<br>
如果服务器清楚自己只处理一种类型的套接字，那么应该把结构的ai_socktype成员设置成SOCK_STREAM或SOCK_DGRAM。这样可以避免返回多个结 构，其中可能出现错误的ai_socktype值。<br>
•服务器程序的另一种设计 方法是使用select或poll函数让服务器进程处理多个套接字。这种情形下，服务器将 遍历由getaddrinfo返回的整个addrinfo结构链表，并为每个结构创建一个套接字， 再使用select或poll。</p>
<h3 id="gai_strerror-函数">gai_strerror 函数</h3>
<p>可由getaddrinfo返回的非0借误值的名字和含义。gai_strerror以这些值 为它的唯一参数，返回一个指向对应的出错信息串的指针。<br>
<img src="https://lixin-ee.github.io//post-images/1579440374672.png" alt=""></p>
<h3 id="freeaddrinfo-函数">freeaddrinfo 函数</h3>
<p>由getaddrinfo返回的所有存储空间都是动态获取的（譬如来自malloc调用），包括 addrinfo结构、ai_addr结构和ai_canonname字符串。这些存储空间通过调用freeaddrinfo 返还给系统。</p>
<pre><code>#include &lt;necdb. h&gt;
void freeaddrinfo（struct addrinfo *ai）;
</code></pre>
<p>ai参数应指向由getaddrinfo返回的第一个addrinfo结构<br>
假设我们调用getaddrinfo，遍历返回的addrinfo结构链表后找到所需的结构。如果我们为保存其信息而仅仅复制这个addrinfo结构，然后调用freeaddrinfo,那就引入了一个潜藏的错误。原因在于这个addrinfo结构本身指向动态分配的内存空间（用于存放套接字地址结构 和可能有的规范主机名），因此由我们保存的结构指向的内存空间己在调用freeaddrinfo时返还给系统，稍后可能用于其他目的。<br>
只复制这个addrinfo结构而不复制由它转而指向的其他结构称为浅复制（shallow copy），既复制这个addrinfo结构又复制由它指向的所有其他结构称为深复制（deepcopy）</p>
<h3 id="host_serv-函数">host_serv 函数</h3>
<p><strong>UNP自制函数</strong>，该函数初始化一个方顽s结构，调用getaddrinfo,若出错则返回一个空指针。<br>
访问getaddrinfo的第一个接口函数<strong>不要求调用者分配并填写一个加this结构</strong>。该结构中我 们感兴趣的两个字段(地址族和套接字类型)</p>
<pre><code>code 图11-9
</code></pre>
<h3 id="tcp_connect-函数">tcp_connect 函数</h3>
<p><strong>UNP自制函数</strong>，<br>
tcp_connect执行客户的通常步骤：创建一个TCP套接字并连接到一个服务器。</p>
<pre><code>code 11-10
</code></pre>
<pre><code>code 11-11
</code></pre>
<h3 id="tcp_listen函数">tcp_listen函数</h3>
<p><strong>UNP自制函数</strong>，<br>
即tcp_listen执行TCP服务器的通常步骤：创建一个TCP套接字，给它捆绑服 务器的众所周知端口，并允许接受外来的连接请求。</p>
<pre><code>code 11-12
</code></pre>
<pre><code>code11-13
</code></pre>
<h3 id="getnameinfo-函数">getnameinfo 函数</h3>
<p>getnameinfo是getaddrinfo的互补函数，它以一个套接字地址为参数，返回描述其中的 主机的一个字符串和描述其中的服务的另一个字符串。<br>
这个函数是协议无关的</p>
<pre><code>#include &lt;netdb.h&gt;
int. getnameinfo(const struct sockaddr *sockaddr, socklen_t addrlen,
char *host, socklen_t hostlen,
char *serv, socklen_t servlen, int flags)；
返回：若成功则为0,若出错则为非0
</code></pre>
<p>sockaddr指向一个套接字地址结构，其中包含待转换成直观可读的字符串的协议地址， addrlen是这个结构的长度。<br>
待返回的2个直观可读字符串由调用者预先分配存储空间，host和hostlen指定主机字符串， serv和servlen指定服务字符串。如果调用者不想返回主机字符串，那就指定hostlen为0。同样， 把servlen指定为0就是不想返回服务字符串。<br>
sock_ntop和getnameinfo的差别在于，前者不涉及DNS,只返回IP地址和端口号的一个可显示版本；后者通常尝试获取主机和服务的名字。<br>
<img src="https://lixin-ee.github.io//post-images/1579442945579.png" alt=""></p>
<h3 id="可重入函数">可重入函数</h3>
<p>如果一个函数在相同的时间点可以被多个线程同时安全地调用，就称该函数是线程安全的<br>
可重入：可以被中断后继续执行而输出结果不变<br>
可重入函数主要用于多任务环境中，一个可重入的函数简单来说就是可以被中断的函数，也就是说，可以在这个函数执行的任何时刻中断它，转入OS调度下去执行另外一段代码，而返回控制时不会出现什么错误；而不可重入的函数由于使用了一些系统资源，比如全局变量区，中断向量表等，所以它如果被中断的话，可能会出现问题，这类函数是不能运行在多任务环境下的。</p>
<p>gethostbyname函数使用了static存储类别限定词，共用同一个host变量，导致它是不可重入的函数</p>
<p>在一个普通的UNIX进程中发生重入问题的条件是:从它的主控制流中和某个信号处理函数 中同时调用gethostbyname或gethostbyaddr等共用变量的函数。</p>
<p>•因历史原因，gethostbyname, gethostbyaddr, getservbyname和getservbyport这4个函数是不可重入的，因为它们都返回指向同一个静态结构的指针。<br>
•	inet_pton和inet_ntop 总是可重入的。<br>
・因历史原因，inet_ntoa是不可重入的<br>
•	getaddrinfo可重入的前提是由它调用的函数都可重入，这就是说，它应该调用可重入 版本的gethostbyname （以解析主机名）和getservbyname （以解析服务名）。本函数 返回的结果全部存放在动态分配内存空间的原因之一就是允许它可重入。<br>
・getnameinfo可重入的前提是由它调用的函数都可重入，这就是说，它应该调用可重入 版本的gethostbyaddr （以反向解析主机名）和getservbyport （以反向解析服务名）。 它的2个结果字符串（分别为主机名和服务名）由调用者分配存储空间，从而允许它可 重入。</p>
<p>errno变量存在类似的问题。这个整型变量历来每个进程各有一个副本。首先应该注意若没有任何错误发生则errno的值不会改变。因此，除非知道发生了一个错<br>
误（通常由函数调用返回-1指示），否则不应该查看errno的值。<br>
但是从close系统调用返回时把错误码存入errno到稍后由程序显示errno的值之间存在一个小的时间窗口，期间同一个进程内的另一个执行线程（例如一个信号处理函数的某次调用）可 能改变了errno的值。</p>
<p>许多版本的标准I/O函数库是不可重入的，也就是说我们不应该从信号处 理函数中调用标准I/O函数。</p>
<h3 id="gethostbyname_r-和-gethostbyaddr_r-函数">gethostbyname_r 和 gethostbyaddr_r 函数</h3>
<p>有两种方法可以把诸如gethostbyname之类不可重入的函数改为可重入函数。<br>
（1）	把由不可重入函数填写并返回静态结构的做法改为由调用者分配再由可重入函数填写结构。<br>
<img src="https://lixin-ee.github.io//post-images/1579444046232.png" alt=""><br>
（2）	由可重入函数调用nalloc以动态分配内存空间。这是getaddrinfo使用的技巧。这种方法的问题是调用该函数的应用进程必须调用freeaddrinfo释放动态分配的内存空间。如果不 这么做就会导致内存空间泄漏（memory leak）</p>
<p>例子：Solaris 2.x用于从名字到地址和从地址到名字进行解析的可重入函数<br>
<img src="https://lixin-ee.github.io//post-images/1579444125130.png" alt=""></p>
<h3 id="其他网络相关信息">其他网络相关信息</h3>
<p>应用进程可能想要查找四类与网络相关的信息：主机、网络、协议和服务。<br>
<img src="https://lixin-ee.github.io//post-images/1579444252223.png" alt=""><br>
只有主机和网络信息可通过DNS获取， 协议和服务信息总是从相应的文件中读取。<br>
如果使用DNS查找主机和网络信息，那么只有键值查找函数才有意义。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UNP 第八章 基本UDP套接字编程]]></title>
        <id>https://lixin-ee.github.io//post/unp-di-ba-zhang-ji-ben-udp-tao-jie-zi-bian-cheng</id>
        <link href="https://lixin-ee.github.io//post/unp-di-ba-zhang-ji-ben-udp-tao-jie-zi-bian-cheng">
        </link>
        <updated>2020-01-19T11:43:03.000Z</updated>
        <content type="html"><![CDATA[<p>UDP是无连接不可靠的数据报协议<br>
  使用UDP编写的一些常见的应用程序有：DNS （域名系统）、NFS （网络文件系统）和 SNMP （简单网络管理协议）</p>
<p>  客户不与服务器建立连接，而是只管使用<strong>sendto函数</strong>给服务器发送数据报，其中必须指定目的地（即服务器） 的地址作为参数。服务器不接受来自客户的连接，而是只管调用recvfrom函数，等待 来自某个客户的数据到达。recvfrom将与所接收的数据报一道返回客户的协议地址，因此服务器可以把响应发送给正确的客户。<br>
<img src="https://lixin-ee.github.io//post-images/1579434261265.png" alt=""></p>
<h3 id="recvfrom和sendto-函数">recvfrom和sendto 函数</h3>
<pre><code>#include &lt;sys/socket.h&gt;
ssize_t recvfrom （int sockfd, void *buff, size_t nbytes, int flags, struct sockaddr *from, socklen_t *addrlen）；
ssize_t sendto（int sockfd, const void *buff, size_t nbytes, int flags, const struct sockaddr *to, socklen_t addrlen）；
均返回：若成功则为读或写的字节数，若出错则为-1
</code></pre>
<p>  前三个参数 sockfd, buff, nbytes、nbytes等同于read和write函数的三个参数：描述符、指向读入或写出缓冲区的指针和读写字节数。<br>
flag默认置为0<br>
  sendto的to参数指向一个含有数据报接收者的协议地址（例如IP地址及端口号）的套接字 地址结构，其大小由addrlen参数指定。<br>
  recvfrom的from参数指向一个将由该函数在返回时填写数据报发送者的协议地址的套接字地址结构，而在该套接字地址结构中填写的字节数则放在 addrlen参数所指的整数中返回给调用者。<br>
  注意sendto的最后一个参数是一个<strong>整数值</strong>，而 recvfrom的最后一个参数是一个指向整数值的<strong>指针</strong>（即值-结果参数）。（这里似乎书中有错，sendto我改成整数了）<br>
  这两个函数都把所读写数据的长度作为函数返回值。</p>
<p>  写一个长度为0的数据报是可行的。在UDP情况下，这会形成一个只包含一个IP首部（对于 IPv4通常为20个字节）和一个8字节UDP首部而没有数据的IP数据报。<br>
这也意味着对于数据报协议，recvfrom<strong>返回0值是可接受的</strong>：它并不像TCP套接字上read<strong>返回0值那样表示对端己关闭连接</strong>。既然UDP是无连接的，因此也就没有诸如关闭一个UDP连接之类事情。<br>
  如果recvfrom的from参数是一个空指针，那么相应的长度参数（addrlen）也<strong>必须</strong>是一个空指针，表示我们并不关心数据发送者的协议地址。</p>
<h3 id="udp服务器与客户端">UDP服务器与客户端</h3>
<p>  大多数TCP服务器是并发的，而大多数UDP服务器是迭代的。因为UDP 是一个无连接的协议，它没有像TCP中EOF之类的东西。<br>
<img src="https://lixin-ee.github.io//post-images/1579434887538.png" alt=""></p>
<p>  对于一个UDP套接字，如果其进程首次调用sendto时它没有绑定一个本地端口，那么内核就在此时为它选择一个临时端口。</p>
<p>  UDP是不可靠的。如果一个客户数据报丢失〈譬如被客户主机 与服务器主机之间的某个路由器丢弃），客户可能将永远阻塞于recvfrom调用，等待一个永远不会到达的服务器应答。类似地如果客户数据报到达服务器，但是服务器的应答丢失了，客户也可能将永远阻塞于recvfrom调用。防止这样永久阻塞的一般方法是给客户的recvfrom 调用设置一个超时。</p>
<p>  大多数IP实现接受目的地址为本主机任一IP地址的数据报，而不管数据报到达的接口，称之为弱端系统模型（weak end system model）.如果一个系统实现的是强端系统模型（strong end system model）,那么它将只接受到达接口与目的地址一致的数据报.</p>
<h4 id="服务器进程未运行">服务器进程未运行</h4>
<p>  服务器主机会响应一个port unreachable（端口不可达）ICMP消息，不过这个ICMP错误不返回给客户进程，亦即sendto返回成功，仅仅由UDP处理<br>
我们称这个ICMP错误为异步错误（asynchronous error）。该错误由sendto引起，但是sendto本身却成功返回。我们知道从UDP输出操作成功返回仅仅表示在接口输出队列中具有存放所形成IP数据报的空间。该ICMP错误直到后来才返回。</p>
<p>  一个基本规则是：对于一个UDP套接字，由它引发的异步错误却并不返给它，除非它已连接。</p>
<p>recvfrom可以返回的信息仅有errno值，它没有办法返回出错数据报的目的IP地址和目的UDP端口号。因此做出决定：仅在进程己将其UDP套接字连接到恰恰一个对端后，这些异步错误才返回给进程。</p>
<p><strong>小结</strong><br>
以圆点的形式给出了在客户发送UDP数据报时必须指定或选择的四个值<br>
<img src="https://lixin-ee.github.io//post-images/1579435416524.png" alt=""><br>
客户必须给sendto调用指定服务器的IP地址和端口号。<br>
客户的临时端口是在第一次调用sendto时一次性选定，不能改变<br>
然而客户的IP地址却可以随客户发送的每个UDP数据报而变动<br>
其原因如图8-11所示：如果客户主机是多宿的，客户有可能在两个目的地之间交替选择，其中一个由左边的数据链路外出，另一个由右边的数据链路外出。在这种最坏的情形下，由内核基于外出数据链路选择的客户IP地址将随每个数据报而改变。</p>
<p>  服务器可能想从到达的IP数据报上取得至少四条信息：源IP地址、目的IP地址、源端口号 和目的端口号<br>
  对于UDP套接字，目的IP地址只能通过为IPv4设置IP_RECVDSTADDR 套接字选项然后调用recvmsg （而不是recvfrom） 取得。<br>
  由于UDP是无连接的，因此目的IP地址可随发送到服务器的每个数据报而改变。<br>
<img src="https://lixin-ee.github.io//post-images/1579435551507.png" alt=""></p>
<h3 id="udp-的-connect-函数">UDP 的 connect 函数</h3>
<p>udp的connect函数只需要指定对端套接字，本端套接字一般由内核决定<br>
  UDP套接字可以调用connect ，然而这样做的结果却与TCP连接大相径庭：没有三路握手过程。内核只是检查是否存在立即可知的错误(例如一个显然不可达的目的地)，记录对端的IP地址和端口号(取自传递给connect的套接字地址结构)，然后立即返回到调用进程。</p>
<p>有了这个能力后，我们必须区分：<br>
・未连接UDP套接字(unconnected UDP socket)，新创建UDP套接字默认如此；<br>
・已连接UDP套接字(connected UDP socket)，对UDP套接字调用connect的结果。<br>
对于已连接UDP套接字，与默认的未连接UDP套接字相比，发生了三个变化。<br>
(1)	我们再也不能给输出操作指定目的IP地址和端口号。<br>
  也就是说，我们<strong>不使用sendto, 而改用write或send</strong>。写到已连接UDP套接字上的任何内容都自动发送到由connect指定的协议地址（例如IP地址和端口号）。<br>
（其实我们可以给已连接UDP套接字调用sendto,但是不能指定目的地址）<br>
（2）	我们不必使用recvfrom以获悉数据报的发送者，而改用read、recv或recvmsg。<br>
  在一个已连接UDP套接字上，由内核为输入操作返回的数据报只有那些来自connect所指定协议地址的数据报。目的地为这个已连接UDP套接字的本地协议地址（例如IP地址和端口号），发源地却不是该套接字早先connect到的协议地址的数据报，不会投递到该套接字。这样就限制一个己连接UDP套接字能且仅能与一个对端交换数据报。<br>
（3）	由已连接UDP套接字引发的异步错误会返回给它们所在的进程，而未连接UDP套接字不接收任何异步错误。<br>
<img src="https://lixin-ee.github.io//post-images/1579435986068.png" alt=""><br>
<img src="https://lixin-ee.github.io//post-images/1579436001986.png" alt=""><br>
  应用进程首先调用connect指定对端的IP地址和端口号，然后使用read和write与对端进 程交换数据。<br>
  udp的connect函数只需要指定对端套接字，本端套接字一般由内核决定<br>
  来自任何其他IP地址或端口的数据报不投递给这个已连接 套接字，因为它们要么源IP地址要么源UDP端口不与该套接字connect到的协议地址相匹配。 这些数据报可能投递给同一个主机上的其他某个UDP套接字。如果没有相匹配的其他套接字， UDP将丢弃它们并生成相应的ICMP端口不可达错误。<br>
  UDP客户进程或服务器进程只在使用自己的UDP套接字与确定的唯一对端进行通信时，才可以调用connect.<br>
<img src="https://lixin-ee.github.io//post-images/1579436097404.png" alt=""><br>
  通常通过在/etc/resolv.conf文件中列出服务器主机的IP地址，一个DNS客户主机就能 被配置成使用一个或多个DNS服务器。如果列出的是单个服务器主机（图中最左边的方框），客户进程就可以调用connect,但是如果列出的是多个服务器主机（图中从右边数第二个方框）， 客户进程就不能调用connect，另外DNS服务器进程通常是处理客户请求的，因此服务器进程不能调用connect</p>
<p><strong>给一个UDP套接字多次调用connect</strong><br>
拥有一个已连接UDP套接字的进程可出于下列两个目的之一再次调用connect：<br>
・指定新的IP地址和端口号；<br>
・断开套接字。<br>
为了断开一个已UDP套接字连接，我们再次调用connect时把套接字地址结构的地址族成员（对于IPv4为sin_family）设置为AF_UNSPEC。这么做可能会返回一个EAFNOSUPPORT错误，不过没有关系。使套接字断开连接的是在已连接 UDP套接字上调用connect的进程</p>
<p><strong>UDP套接字接收缓冲区</strong><br>
由UDP给某个特定套接字排队的UDP数据报数目受限于该套接字接收缓冲区的大小。我们可以使用SO_RCVBUF套接字选项修改该值</p>
<p><strong>UDP中的外出接口的确定</strong><br>
  已连接UDP套接字还可用来确定用于某个特定目的地的外出接口。这是由connect函数应用到UDP套接字时的一个副作用造成的：内核选择本地IP地址（假设其进程未曾调用bind显式指派它）。这个本地IP地址通过为目的IP地址搜索路由表得到外出接口，然后选用该接口的主IP地址而选定。<br>
  connect到一个指定的IP地址后可以调用getsockname 得到本地IP地址和端口号<br>
  在UDP套接字上调用connect并不给对端主机发送任何信息，它完全是一个本地操作，只是保存对端的IP地址和端口号。<br>
  同时在一个未绑定端口号的UDP套接字上调用connect同时也给该套接字指派一个临时端口。</p>
<h3 id="使用select函数的tcp和udp回射服务器程序">使用select函数的TCP和UDP回射服务器程序</h3>
<p>无需在调用bind之前设置SO_REUSEADDR套接字选项，因为TCP端口是独立于UDP端口的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UNP 第七章 套接字选项]]></title>
        <id>https://lixin-ee.github.io//post/unp-unix-wang-luo-bian-cheng-di-qi-zhang-tao-jie-zi-xuan-xiang</id>
        <link href="https://lixin-ee.github.io//post/unp-unix-wang-luo-bian-cheng-di-qi-zhang-tao-jie-zi-xuan-xiang">
        </link>
        <updated>2020-01-19T11:29:36.000Z</updated>
        <content type="html"><![CDATA[<p>套接字选项</p>
<h1 id="getsockopt-和-setsockopt-函数">getsockopt 和 setsockopt 函数</h1>
<p>这两个函数仅用于套接字。</p>
<pre><code>#include &lt;sys/socket.h&gt;
		 int getsockopt (int sockfd, int level, int optname, void *optval, socklen_t *optlen)；
		int setsockopt (int sockfd, int level, int optname, const void *optval,socklen_t optlen)；
		均返回：若成功则为0,若出错则为-1
</code></pre>
<p>sock必须指向一个打开的套接字描述符<br>
level（级别）指定系统中解释选项的代码或 为通用套接字代码，或为某个特定于协议的代码（例如IPv4、IPv6, TCP或SCTP）。<br>
optval是一个指向某个变量（* optval）的指针，setsockopt从* optval冲取得选项待设置的 新值，getsockopt则把已获取的选项当前值存放到* optval的大小由最后一个参数指定， 它对于setsockopt是一个值参数，对于getsockopt是一个值-结果参数。</p>
<p><img src="https://lixin-ee.github.io//post-images/1579433584392.png" alt=""><br>
<img src="https://lixin-ee.github.io//post-images/1579433609152.png" alt=""><br>
汇总了可由getsockopt获取或由setsockopt设置的选项。</p>
<p>套接字选项粗分为两大基本类型：一是启用或禁止某个特性的二元选项（称为标志选项）， 二是取得并返回我们可以设置或检查的特定值的选项（称为值选项）。<br>
标有“标志”的列指出一个选项是否为标志选项。当给这些标志选项调用getsockopt函数时，* optval是一个整数，* optval 中返回的值为0表示相应选项被禁止，不为0表示相应选项被启用。类似地，setsockopt函数需 要一个不为0的* optval值来启用选项，一个为0的值来禁止选项。如果“标志&quot;列不含有 “ • ”，那么相应选项用于在用户进程与系统之间传递所指定数据类型的值。</p>
<h1 id="检查选项是否受支持并获取默认值">检查选项是否受支持并获取默认值</h1>
<pre><code>/checkopts.c
//Code by Lixin on 2020.01.17

#inlcude &quot;unp.h&quot;
#include &lt;netinet/tcp.h&gt;

union val{
	int i_val;
	long l_val;
	struct linger linger_val;
	struct timeval timeval_val;
}val;

struct sock_opts{
	const char *opt_str;
	int opt_level;
	int opt_name;
	char *(*opt_val_str)(union val *,int);
}sock_opts[]={
	{&quot;SO_KEEAPALIVE&quot;,SOL_SOCKET,SO_KEEPALIVE,sock_str_flag},
	{NULL,0,0,NULL}
}

int main(int argc,char **argv)
{
	int fd;
	socklen_t, len;
	struct sock_opts *ptr;

	for(ptr=socl_opts;ptr-&gt;opt_str!=NULL;ptr++){
		printf(&quot;%s:&quot;,ptr-&gt;opt_str);
		if(ptr-&gt;opt_val_str==NULL)
			printf(&quot;(undefined)\n&quot;);
		else{
			switch(ptr-&gt;opt_level){
				case SOL_SOCKET:
				case IPPROTO_IP:
				case IPPROTO_TCP:
					fd=socket(AF_INET,SOCK_STREAM,0);
					break;
				default:
					perror(&quot;cannot creat fd for level %d\n&quot;,ptr-&gt;opt_level);
			}

			len=sizeof(val);
			if(getsockopt(fd,ptr-&gt;opt_level,ptr-&gt;opt_name,&amp;val,&amp;len)==-1){
				perror(&quot;getsockopt error&quot;);
			}else{
				printf(&quot;default = %s\n&quot;,(*ptr-&gt;opt_val_str)(&amp;val,len));
			}
			close(fd);
		}
	}
	exit(0);
}
</code></pre>
<h1 id="套接字状态">套接字状态</h1>
<p>下面的套接字选项是由TCP己连接套接字从监听套接字继承来的<br>
SO_DEBUG、SO_DONTROUTE、SO_KEEPALIVE, SO_LINGER、SO_OOBINLINE 、SO_RCVBUF、 SO_RCVL0WAT, SO_SNDBUF、SO_SNDL0WAT、TCP_MAXSEG和TCP_NODELAY。<br>
这对TCP是很重要 的，因为accept—直要到TCP层完成三路握手后才会给服务器返回己连接套接字。如果想在三路握手完成时确保这些套接字选项中的某一个是给已连接套接字设置的，那么我们必须先给监 听套接字设置该选项。</p>
<h1 id="通用套接字选项">通用套接字选项</h1>
<p>通用套接字选项是协议无关的，不过其中有些选项只会应用到 某些特定类型的套接字中。</p>
<p>SO_BROADCAST 套接字选项<br>
本选项开启或禁止进程发送广播消息的能力。只有数据报套接字支持广播，并且还必须是 在支持广播消息的网络上（例如以太网、令牌环网等）。我们不可能在点对点链路上进行广播， 也不可能在基于连接的传输协议（例如TCP和SCTP）之上进行广播。<br>
由于应用进程在发送广播数据报之前必须设置本套接字选项，因此它能够有效地防止一个 进程在其应用程序根本没有设计成可广播时就发送广播数据报。<br>
如果目的地 址是一个广播地址且本套接字选项没有设置，那么返回EACCES错误</p>
<p>SO_DEBUG套接字选项<br>
本选项仅由TCP支持。当给一个TCP套接字开启本选项时，内核将为TCP在该套接字发送和 接收的所有分组保留详细跟踪信息。</p>
<p>SO_DONTR0UTE 套接字选项<br>
本选项规定外出的分组将绕过底层协议的正常路由机制。<br>
在IPv4情况下外出分 组将被定向到适当的本地接口，也就是由其目的地址的网络和子网部分确定的本地接口。<br>
路由守护进程（route和gated）经常使用本选项来绕过路由表（路由表不正确的情况下）， 以强制将分组从特定接口送出。</p>
<p>SO_ERROR套接字选项<br>
当一个套接字上发生错误时，内核中的协议模块将该套接字的名为 so_error的变量设为标准的Unix Exxx值中的一个，我们称它为该套接字的待处理错误（pending error）。内核能够以下面两种方式之一立即通知进程这个错误。<br>
1）	如果进程阻塞在对该套接字的select调用上，那么无论是检查可读条件还是可<br>
写条件，select均返回并设置其中一个或所有两个条件。<br>
（2）	如果进程使用信号驱动式I/O模型，那就给进程或进程组产生一个SIGIO信号。<br>
进程然后可以通过访问SO_ERROR套接字选项获取so_error的值。由getsockopt返回的整 数值就是该套接字的待处理错误。so_error随后由内核复位为0<br>
一个套接字上出现的待处理错误一旦返回给用户进程，它的so_error 就得复位为0.<br>
这是我们遇到的第一个可以获取但不能设置的套接字选项。</p>
<p>SO_KEEPALIVE 套接字选项<br>
给一个TCP套接字设置保持存活（keep-alive）选项后，如果2小时内在该套接字的任一方向 上都没有数据交换，TCP就自动给对端发送一个保持存活探测分节（keep-alive probe）。这是一个对端必须响应的TCP分节，它会导致以下三种情况之一。<br>
（1）	对端以期望的ACK响应。应用进程得不到通知（因为一切正常）。在又经过仍无动静的 2小时后，TCP将发出另一个探测分节。<br>
（2）	对端以RST响应，它告知本端TCP：对端己崩溃且已重新启动。该套接字的待处理错误 被置为ECONNRESET,套接字本身则被关闭。<br>
（3）	对端对保持存活探测分节没有任何响应<br>
如果根本没有对TCP的探测分节的响应，该套接字的待处理错误就被置为ETIMEOUT,套接字本身则被关闭。然而如果该套接字收到一个ICMP错误作为某个探测分节的响应，那就返回相应的错误,套接字本身也被关闭。<br>
这种情形下一个常见的ICMP错误是“host unreachable&quot;（主机不可达），说明对端主机可能并没有崩溃，只是不可达，这种情况下待处理错误被置为EHOSTUNREACH.发生这种情况的原因或者是发生网结故障，或者是对端主机已经崩 溃，而最后一跳的路由器也已经检测到它的崩溃。<br>
本选项的功用是检测对端主机是否崩溃或变得不可达（譬如拨号调制解调器连接掉线，电 源发生故障，等等）。如果对端进程崩溃，它的TCP将跨连接发送一个FIN,这可以通过调用 select很容易地检测到。（这就是我们在6.4节中使用select的原因。）同时也要认识到，即使 对任何保持存活探测分节均无响应（第三种情况），我们也不能肯定对端主机已经崩溃，因而 TCP可能会终止一个有效连接。<br>
本选项一般由服务器使用，保持存活选项将检测出客户已经断开的半开连接并终 止它们。不过客户也可以使用。</p>
<p>SO_LINGER套接字选项<br>
本选项指定close函数对面向连接的协议（例如TCP和SCTP,但不是UDP）如何操作。默 认操作是close立即返回，但是如果有数据残留在套接字发送缓冲区中，系统将试着把这些数据发送给对端。<br>
<img src="https://lixin-ee.github.io//post-images/1579433640262.png" alt=""><br>
SO_LINGER套接字选项使得我们可以改变这个默认设置。本选项要求在用户进程与内核间 传递如下结构，它在头文件＜sys/socket.h＞中定义：</p>
<pre><code>struct linger（
int	l_onoff;	/* ==off, nonzero=on */
int l_linger；	/* linger time, POSIX specifies units as seconds */
};
</code></pre>
<p>对setsockopt的调用将根据其中两个结构成员的值形成下列3种情形之一：<br>
（1）	如果l_onoff为0,那么关闭本选项。l_linger的值被忽略，先前讨论的TCP默认设置生效，即close立即返回。<br>
（2）	如果l_onoff为非0值且linger为0,那么当close某个连接时TCP将中止该连接 。这就是说TCP将丢弃保留在套接字发送缓冲区中的任何数据，并发送一个RST给对端，而没有通常的四分组连接终止序列。这么一来避免了TCP的TIME_WAIT状态，然而存在以下可能性：在2MSL秒内创建该连接的另一个化身，导致来自刚被终止的连接上的旧的重复分节被不正确地递送到新的化 身上。<br>
（3）如果l_onoff为非0值且linger也为非0值，那么当套接字关闭时内核将拖延一段时 间。这就是说如果在套接字发送缓冲区中仍残留有数据，那么进程将被投入睡眠，直到（a）所 有数据都已发送完且均被对方确认或（b）延滞时间到。如果套接字被设置为非阻塞型，那么它将不等待Close完成，即使延滞时间为非0也是如此。<br>
当使用SO_LINGER选项的这个 特性时，应用进程检查close的返回值是非常重要的，因为如果在数据发送完并被确认前延滞 时间到的话，close将返回EWOULDBLOCK错误，且套接字发送缓冲区中的任何残留数据都被丢弃。<br>
<img src="https://lixin-ee.github.io//post-images/1579433666835.png" alt=""><br>
默认情况下客户的close立即返回。 如图所示，客户的close可能在服务器读套接字接收缓区中的剩余数据之前就返回。对于服务 器主机来说，在服务器应用进程读这些剩余数据之前就崩溃是完全可能的，而且客户应用进程 永远不会知道。<br>
<img src="https://lixin-ee.github.io//post-images/1579433677337.png" alt=""><br>
客户可以设置SO_LINGER套接字选项，指定一个正的延滞时间。这种情况下客户的close 要到它的数据和FIN已被服务器主机的TCP确认后才返回<br>
然而我们仍然有与图7-7一样的问题：在服务器应用进程读这些剩余数据之前就崩溃是完全可能的，而且客户应用进程 永远不会知道。</p>
<p>更糟糕的是，图7-9展示了当给SO_LINGER选项设置偏低的延滞时间值时可能发生的现象。<br>
<img src="https://lixin-ee.github.io//post-images/1579433688864.png" alt=""><br>
这里有一个基本原则：设置SO_LINGER套接字选项后，close的成功返回只是告诉我们先 前发送的数据(和FIN)已由对端TCP确认，而不能告诉我们对端应用进程是否已读取数据。如 果不设置该套接字选项，那么我们连对端TCP是否确认了数据都不知道。<br>
让客户知道服务器己读取其数据的一个方法是改为调用shutdown (并设置它的第二个参数 为SHUT_WR)而不是调用close,并等待对端close连接的当地端(服务器端)<br>
<img src="https://lixin-ee.github.io//post-images/1579433700519.png" alt=""><br>
当关闭连接的本地端(客户端)时，根据所调用的函 数(close或shutdown)以及是否设置了SO_LINGER套接字选项，可在以下3个不同的时机返 回：<br>
(1)	close立即返回，根本不等待(默认状况，图7-7).<br>
(2)	close一直拖延到接收了对于客户端FIN的ACK才返回(图7-8).<br>
(3)后跟一个read调用的shutdown一直等到接收了对端的FIN才返回(图7-10).</p>
<p>获知对端应用进程已读取我们的数据的另外一个方法是使用应用级确认(application-level acknowledge),简称应用ACK (applicationACK)<br>
<img src="https://lixin-ee.github.io//post-images/1579433723131.png" alt=""><br>
<img src="https://lixin-ee.github.io//post-images/1579433736764.png" alt=""></p>
<p><img src="https://lixin-ee.github.io//post-images/1579433758408.png" alt=""></p>
<p><img src="https://lixin-ee.github.io//post-images/1579433770612.png" alt=""></p>
<p>SO_OOBINLINE 套接字选项<br>
当本选项开启时，带外数据将被留在正常的输入队列中（即在线留存）。这种情况下接收函 数的MSG_OOB志不能用来读带外数据。</p>
<p>SO_RCVBUF 和 SO_SNDBUF 套接字选项<br>
每个套接字都有一个发送缓冲区和一个接收缓冲区。<br>
对于TCP 来说，套接字接收缓冲区中可用空间的大小限定了TCP通告对端的窗口大小。TCP套接字接收 缓冲区不可能溢出，因为不允许对端发出超过本端所通告窗口大小的数据。这就是TCP的流量 控制，如果对端无视窗口大小而发出了超过该窗口大小的数据，本端TCP将丢弃它们。<br>
这两个套接字选项允许我们改变这两个缓冲区的默认大小。<br>
当设置TCP套接字接收缓冲区的大小时，函数调用的顺序很重要。这是因为TCP的窗口规 模选项（2.6节）是在建立连接时用SYN分节与对端互换得到的。<br>
对于客户，这意味着SO.RCVBUF 选项必须在调用connect之前设置；<br>
对于服务器，这意味着该选项必须在调用listen之前给监 听套接字设置。给己连接套接字设置该选项对于可能存在的窗口规模选项没有任何影响，因为 accept直到TCP的三路握手完成才会创建并返回已连接套接字。这就是必须给监听套接字设置 本选项的原因。<br>
TCP套接字缓冲区的大小至少应该是相应连接的MSS值的四倍。依据是TCP快速恢复算法的工作 机制.TCP发送端使用3个重复的确认来检测某个分节是否丢失，如果窗口大小不足以存放4个这样的分节，那就不可能连发三个重复的确认，从而无法激 活快速恢复算法.<br>
为避免潜在的缓冲区空间浪费，TCP套接字缓冲区大小还必须是相应连接的MSS值的偶数 倍。<br>
客户也必须有足够分节容量的发送缓冲区（一般至少为管道容量的两倍），因为客户TCP必须为每个分节保留一个副本，直到接 收到来自服务器的相应ACK<br>
理解的重点在于全双工管道的概念、它的容量以及它们如何关系到连接两端的套接字缓冲 区大小。管道的容量称为带宽-延迟积（bandwidth-delayproduct）,它通过将带宽（bit/s）和RTT （秒）相乘，再将结果由位转换为字节许算得到。其中RTT可以很容易地使用ping程序测得。<br>
带宽是相应于两个端点之间最慢链路的值<br>
应用程序在把套接字缓冲区的大小设置成某个 预配置的“大”值时，应该确保这样做不会反而让缓冲区变小了；最好一开始就调用 getsockopt获取系统的默认值并判定是否已足够大.</p>
<p>SO_RCVLOWAT 和 SO_SNDLOWAT 套接字选项<br>
每个套接字还有一个接收低水位标记和一个发送低水位标记。它们由select函数使用，这两个套接字选项允许我们修改这两个低水位标记。<br>
接收低水位标记是让select返回&quot;可读&quot;时套接字接收缓冲区中所需的数据量。<br>
发送低水位标记是让select返回&quot;可写”时套接字发送缓 冲区中所需的可用空间。<br>
只要一个UDP套接字的发送缓冲区大小大于该套 接字的低水位标记，该UDP套接字就总是可写。记得UDP并没有发送缓冲区， 而只有发送缓冲区大小这个属性。</p>
<p>SO_RCVTIMEO和 SO_SNDTIMEO套接字选项<br>
这两个选项允许我们给套接字的接收和发送设置一个超时值。<br>
注意，访问它们的 getsockopt和setsockopt函数的参数是指向timeval结构的指针，这可让我们用秒数和微秒数来规定超时。我们通过设置其值为0s和0us来禁止超时。默认 情况下这两个超时都是禁止的.</p>
<p>O_REUSEADDR 和 SO_REUSEPORT 套接字选项<br>
SO_REUSEADDR套接字选项能起到以下4个不同的功用。<br>
（1）	SO_REUSEADDR允许启动一个监听服务器并捆绑其众所周知端口，即使以前建立的将该 端口用作它们的本地端口的连接仍存在。这个条件通常是这样碰到的：<br>
a）	启动一个监听服务器；<br>
b）	连接请求到达，派生一个子进程来处理这个客户；<br>
c）	监听服务器终止，但子进程继续为现有连接上的客户提供服务；<br>
d）	重启监听服务器。<br>
默认情况下，当监听服务器在步骤d通过调用socket, bind和listen重新启动时，由于它 试图捆绑一个现有连接（即正由早先派生的那个子进程处理着的连接）上的端口，从而bind调 用会失败。但是如果该服务器在socket和bind两个调用之间设置了SO_REUSEADDR套接字选项， 那么bind将成功。所有TCP服务器都应该指定本套接字选项，以允许服务器在这种情形下被重 新启动。<br>
（2）	SO_REUSEADDR允许在同一端口上启动同一服务器的多个实例，只要每个实例捆绑一个 不同的本地IP地址即可。<br>
对于TCP,我们绝不可能启动捆绑相同IP地址和相同端口号的多个服务器：这是完全重复 的捆绑(completely duplicate binding)。<br>
为了安全起见，有些操作系统不允许对已经绑定了通配地址的端口再捆绑任何“更为明确 的”地址，也就是说不论是否预先设置SO_REUSEADDR,上述例子中的系列bind调用都会失败。 在这样的系统上，执行通配地址捆绑的服务器进程必须最后一个启动。这么做是为了防止把恶 意的服务器捆绑到某个系统服务正在使用的IP地址和端口上，造成合法请求被截取。<br>
（3）SO_REUSEADDR允许单个进程捆绑同一端口到多个套接字上，只要每次捆绑指定不同的 本地IP地址即可。<br>
（4）SO_REUSEADDR允许完全重复的捆绑：当一个IP地址和端口已绑定到某个套接字上时， 如果传输协议支持，同样的IP地址和端口还可以捆绑到另一个套接字上。(3)	一般来说本特性仅支 持UDP套接字。</p>
<p>4.4BSD随多播支持的添加引入了SO_REUSEPORT这个套接字选项</p>
<p>以下面的建议来总结对这些套接字选项的讨论：<br>
（1）	在所有TCP服务器程序中，在调用bind之前设置SO_REUSEADDR套接字选项；<br>
（2）	当编写一个可在同一时刻在同一主机上运行多次的多播应用程序时，设置SO_REUSEADDR 套接字选项，并将所参加多播组的地址作为本地IP地址捆绑。</p>
<p>SO_TYPE套接字选项<br>
本选项返回套接字的类型，返回的整数值是一个诸如SOCK_STREAM或SOCK_DGRAM之类的值。本选项通常由启动时继承了套接字的进程使用。</p>
<h1 id="ipv4套接字选项">IPv4套接字选项</h1>
<p>下列套接字选项由IPv4处理，它们的级别（即getsockopt和setsockopt函数的第二个参数）为IPPROTO_IP。</p>
<p>IP_HDRINCL套接字选项<br>
如果本选项是给一个原始IP套接字设置的，那么我们必须为所有在该原始套接 字上发送的数据报构造自己的IP首部。一般情况下，在原始套接字上发送的数据报其IP首部是 由内核构造的，不过有些应用程序（特别是路由跟踪程序traceroute）需要构造自己的IP首部 以取代IP置于该首部中的某些字段。<br>
当本选项开启时，我们构造完整的IP首部，不过下列情况例外。<br>
・IP总是计算并存储IP首部校验和。<br>
・如果我们将IP标识字段置为0，内核将设置该字段。<br>
・如果源IP地址是INADDR/ANY,，IP将把它设置为外出接口的主IP地址。<br>
・如何设置IP选项取决于实现。有些实现取出我们预先使用IP_OPTIONS套接字选项设置的任何IP选项，把它们添加到我们构造的首部中，而其他实现则要求我们亲自在首部指定任何期望的IP选项。<br>
・IP首部中有些字段必须以主机字节序填写，有些字段必须以网络字节序填写，具体取决 于实现。这使得利用本套接字选项编排原始分组的代码不像期待的那样便于移植。</p>
<p>IP_OPTIONS套接字选项<br>
本选项的设置允许我们在IPv4首部中设置IP选项。</p>
<p>IP_TTL套接字选项<br>
我们可以使用本选项设置或获取系统用在从某个给定套接字发送的单播分组上的默认TTL 值</p>
<p>TCP 套接字选项<br>
TCP有两个套接字选项，它们的级别（即getsockopt和setsockopt函数的第二个参数） 为IPPROTO_TCP。<br>
TCP_MAXSEG套接字选项<br>
本选项允许我们获取或设置TCP连接的最大分节大小（MSS）。<br>
返回值是我们的TCP可以发 送给对端的最大数据量，它通常是由对端使用SYN分节通告的MSS,除非我们的TCP选择使用 一个比对端通告的MSS小些的值。<br>
如果该值在相应套接字的连接建立之前取得，那么返回值是 未从对端收到MSS选项的情况下所用的默认值。<br>
如果用上譬如说时间戳选项的话，那么实际用于连接中的最大分节大小可能小于本套接字选项的返回值，因为时间戳选项在每个分节中要占用12字节的TCP选项容量。<br>
如果TCP支持路径MTU发现功能，那么它将发送的每个分节的最大数据量还可能在连接存活期内改变。如果到对端的路径发生变动，该值就会有所调整。<br>
一旦连接建立，本选项的值就是对端通告的MSS选项值，TCP不能发送超过该值的分节。 当然，TCP总是可以发送数据量少于对端通告的MSS值的分节。</p>
<p>TCP_NODELAY 套接字选项<br>
开启本选项将禁止TCP的Nagle算法，默认情况下 该算法是启动的。<br>
Nagle算法的目的在于减少广域网（WAN）上小分组的数目。该算法指出：如果某个给定连接上有待确认数据（outstanding data）,那么原本应该作为用户写操作之响应的在该连接上立 即发送相应小分组的行为就不会发生，直到现有数据被确认为止。这里&quot;小”分组的定义就是小于MSS的任何分组。TCP总是尽可能地发送最大大小的分组，Nagle算法的目的在于防止一个 连接在任何时刻有多个小分组待确认。<br>
Nagle算法常常与另一个TCP算法联合使用：ACK延滞算法（delayed ACK algorithm）。该算 法使得TCP在接收到数据后不立即发送ACK,而是等待一小段时间（典型值为50〜200ms）,然 后才发送ACK。 TCP期待在这一小段时间内自身有数据发送回对端，被延滞的ACK就可以由这 些数据捎带，从而省掉一个TCP分节。<br>
待确认数据（outstanding data）直译为未决数据，也就是我<strong>们的TCP已发送</strong>但还在<strong>等待对端确认</strong>的数据<br>
然而对于其服务器不在相反方向产生数据以便携带ACK的客户来说，ACK延滞算法存在问 题。这些客户可能觉察到明显的延迟，因为客户TCP要等到服务器的ACK延滞定时器超时才继 续给服务器发送数据。这些客户需要一种禁止Nagle算法的方法，TCP_NODELAY选项就能起到这 个作用。	<br>
另一类不适合使用Nagle算法和TCP的ACK延滞算法的客户是以若干小片数据向服务器发 送单个逻辑请求的客户。<br>
考虑例子：<br>
假设某个客户向它的服务器发送一个400字节的请求，该请 求由一个4字节的请求类型和后跟的396字节的请求数据构成。<br>
如果客户先执行一个4字节的 write调用，再执行一个396字节的write调用，那么第二个写操作的数据将一直等到服务器的 TCP确认了第一个写操作的4字节数据后才由客户的TCP发送出去。（Nagle算法）<br>
而且，由于服务器应用进程 难以在收到其余396字节前对先收到的4字节数据进行操作，服务器的TCP将拖延该4字节数据的 ACK （也就是说，暂时不会有从服务器到客户的任何数据可以捎带这个ACK）。（ACK延滞算法）<br>
有三种办法修 正这类客户程序。<br>
（1）	使用writev （ 14.4节）而不是两次调用write。对于本例子，单个writev调用最终导致 调用TCP输出功能一次而不是两次，其结果是只产生一个TCP分节。这是首选的办法。<br>
（2）	把前4字节的数据和后396字节的数据复制到单个缓冲区中，然后对该缓冲区调用一次 write<br>
（3）	设置TCP项NODELAY套接字选项，继续调用write两次。这是<strong>最不可取的办法，而且有损于网络，通常不应该考虑。</strong></p>
<h1 id="fcntl-函数">fcntl 函数</h1>
<p>与代表&quot;file control&quot;（文件控制）的名字相符，fcntl函数可执行各种描述符控制操作。<br>
图7-20汇总了由fcntl、ioctl 和路由套接字执行的不同操作。<br>
<img src="https://lixin-ee.github.io//post-images/1579433790286.png" alt=""><br>
・非阻塞式I/O。通过使用F_SETFL命令设置O_NONBLOCK文件状态标志，我们可以把一个 套接字设置为非阻塞型。<br>
・信号驱动式I/O。通过使用F_SETFL命令设置O_ASYNC文件状态标志，我们可以把一个套 接字设置成一旦其状态发生变化，内核就产生一个SIGIO信号。<br>
・F_SETOWN命令允许我们指定用于接收SIGIO和SIGURG信号的套接字属主(进程ID或进程组ID)。其中SIGIO信号是套接字被设置为信号驱动式I/O型后产生的SIGURG信号是在新的带外数据到达套接字时产生的。F_GETOWN命令返回套接字的当前属主。<br>
套接字属主 亦即 套接字的进程组 ID</p>
<pre><code>#include &lt;fcntl.h&gt;
int fcntl (int fd, int cmd,.../* int arg */ )；
返回：若成功则取决于cmd,若出错则为-1
</code></pre>
<p>每种描述符(包括套接字描述符)都有一组由F_GETFL命令获取或由F_SETFL命令设置的 文件标志。其中影响套接字描述符的两个标志是：<br>
O_NONBLOCK	非阻塞式 I/O:<br>
O_ASYNC	信号驱动式I/O。</p>
<p>使用fcntl开启非阻塞式I/O的典型代码：</p>
<pre><code>flags = fcntl (fd, F_GETFL, 0)；
flags |= O_NONBLOCK;
fcntl(fd, F_SETFL, flags)
</code></pre>
<p>错误代码<br>
<code>fcntl(fd, F_SETFL, O_NONBLOCK)；</code><br>
这段代码在设置非阻塞标志的同时也清除了所有其他文件状态标志。设置某个文件状态标 志的唯一正确的方法是：先取得当前标志，与新标志逻辑或后再设置标志。<br>
以下代码关闭非阻塞标志，其中假设flags是由上面所示的fcntl调用来设置的：</p>
<pre><code>flags &amp;=~O_NONBLOCK;
fcntl(fd, F_SETFL, flags) ;
</code></pre>
<p>信号SIGIO和SIGURG与其他信号的不同之处在于，这两个信号仅在己使用F_SETOWN命令给相关套接字指派了属主后才会产生。F_SETOWN命令的整数类型arg参数既可以是一个正整数，指出接收信号的进程ID,也可以是一个负整数，其绝对值指出接收信号的进程，F_GETOWN 命令把套接字属主作为fcntl函数的返回值返回，它既可以是进程ID (一个正的返回值)，也可以是进程组ID （一个除-1以外的负值）。指定接收信号的套接字属主为一个进程或一个进程组的差别在于：前者仅导致单个进程接收信号，而后者则导致整个进程组中的所有进程（也许不止一个进程）接收信号。<br>
使用socket函数新创建的套接字并没有属主。然而如果一个新的套接字是从一个监听套接 字创建来的，那么套接字属主将由已连接套接字从监听套接字继承而来</p>
<p>总结：<br>
最常用的选项是：SO_KEEPALIVE, SO_RCVBUF、SO_SNDBUF和SO_REUSEADDR，其中最 后那个选项应该总是在一个TCP服务器进程调用bind之前预先设置<br>
许多TCP服务器设置SO_KEEPALIVE套接字选项以自动终止一个半开连接。该选项的优点在于它由TCP层处理，不需要有一个应用级的休止状态定时器；而它的缺点是无法区别客户主机崩溃和到客户主机连通性的暂时丢失。<br>
SO_LINGER套接字选项使得我们能够更好地控制Close函数返回的时机，而且允许我们强制发送RST而不是TCP的四分组连接终止序列。我们必须小心发送RST,因为这么做回避了TCP 的TIME_WAIT状态。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串长度：strlen、size、sizeof、length]]></title>
        <id>https://lixin-ee.github.io//post/zi-fu-chuan-chang-du-strlensizesizeoflength</id>
        <link href="https://lixin-ee.github.io//post/zi-fu-chuan-chang-du-strlensizesizeoflength">
        </link>
        <updated>2020-01-19T02:49:18.000Z</updated>
        <content type="html"><![CDATA[<p>问题的起源是一道笔试题</p>
<pre><code>char s[]=&quot;\\123456\123456\t&quot;;
printf(&quot;%d\n&quot;,strlen(s));
</code></pre>
<p>一道很明显的C++环境下的C语言题目<br>
这里考察了转义字符的性质和strlen的性质<br>
注意 \ 表示字符 <br>
\123表示字符 {<br>
（这里的要点是\转义字符后面跟的是八进制和十六进制 十进制下一共0~255个字符，跟八进制的话后面最多到377（转换成十进制255），所以只能接最多三个数字，超过三个数字的部分就不能视为转义字符的一部分了，但是注意这里跟编译器有关，比如vs取三位，LINUX取低一位）<br>
\t 表示制表符<br>
所以答案是 12</p>
<p>啥啥啥？？？为啥不是13，说好的C字符串必须带有一个'\0'呢</p>
<p>原因就在于strlen这个家伙<br>
strlen()函数求出的字符串长度为有效长度，即不包含字符串末尾结束符‘\0’，因而返回的结果是第一个'\0'前字符元素的个数。</p>
<p>那size和sizeof呢？</p>
<p>sizeof求得的结果是存储该字符串的变量占用的空间大小，因而一定会包括'\0'，若'\0'后还有空余的空间，也会包含到结果里面。<br>
同时sizeof 操作符的参数可以是数组、指针、类型、对象、函数等，函数 strlen 的参数只能是字符串。<br>
对于 sizeof， 其参数不同时，其返回的值也不一样，如下：<br>
1、数组：编译时分配的数组空间大小；<br>
2、指针：存储该指针所用的空间大小(32位机器上是4，64位机器上是8)；<br>
3、类型：该类型所占的空间大小；<br>
4、对象：对象的实际占用空间大小(这个指的是在 C++ 中)；<br>
5、函数：函数的返回类型所占的空间大小。函数的返回类型不能是 void 类型；</p>
<p>所以如果你把数组指针传进去，sizeof得到的仅仅是指针的大小</p>
<p>strlen和sizeof的对比<br>
1、sizeof 是一个操作符，而 strlen 是 C 语言的库函数。<br>
2、sizeof 的参数可以是任意数据类型或者表达式，而 strlen 只能以结尾为 '\0' 的字符串作参数。<br>
3、sizeof 的结果在编译时就计算出了，而 strlen 必须在运行时才能计算出来。<br>
4、sizeof 计算数据类型占内存的大小，strlen 计算字符串实际长度，要记住 strlen 计算出来的结果不包括结束符 '\0'。<br>
5、sizeof 反应的并非真实字符串长度而是所占空间大小，所以memset 初始化字符串的时候用 sizeof 较好。<br>
6、系统函数返回值是 char * (字符指针)类型的会在末尾加上结束符 '\0'。<br>
7、无论是 sizeof 还是 strlen 计算结果的单位都是字节。<br>
我们还需要注意一点，strlen 函数，当数组名作为参数传入时，实际上数组就退化成指针了。<br>
参考博文：<a href="http://www.veryitman.com/2019/03/07/%E4%B8%8D%E8%A7%81%E5%BE%97%E4%BD%A0%E4%BC%9A%E8%AE%A1%E7%AE%97C%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6/">不见得你会计算C字符串长度</a></p>
<p>size呢？咋不说size？8好意思，size是string等stl容器专用的成员函数，C语言字符串char * 是不能使用的，毕竟是string.size()，char* 怎么调用呢。。。<br>
最后c++中的size()和length()没有区别</p>
<p>剩下的说下要点：<br>
size函数返回值并非int，而是一个string::size_type类型的值，它是一个无符号类型的值unsigned，能够存放下任何string对象的大小<br>
所以不能将size函数的返回值与负值进行比较或其他操作 否则会触发强制转换<br>
（注意就像侯捷说的，不是说程序员或者用户就笨到跑去string.size()==-1，而是有时候某些变量在循环中不小心递减变成了负值，比如我就试过不小心递减到-1，然后导致size()&lt;-1永远成立，（无符号数和有符号数一起运算时，有符号数强行转化为无符号数，所以-1会强制转换变为最大的无符号数，所以负值的int永远大于无符号数））<br>
注意size函数调用必须有括号size（）</p>
<p>自己的实验代码：vs2015下运行</p>
<pre><code>	//指针型
	char *str_p = &quot;123456789&quot;;
	cout &lt;&lt; strlen(str_p) &lt;&lt; endl; //9
	cout &lt;&lt; sizeof(str_p) &lt;&lt; endl; //4  环境为vs2015
	//cout &lt;&lt; str_p.size() &lt;&lt; endl;//报错,必须包含类类型

	//数组型
	char str_a[] = &quot;123456789&quot;;
	cout &lt;&lt; strlen(str_a) &lt;&lt; endl; //9
	cout &lt;&lt; sizeof(str_a) &lt;&lt; endl; //10
	//cout &lt;&lt; str_a.size() &lt;&lt; endl;//报错

	//string
	string str_s= &quot;123456789&quot;;
	cout &lt;&lt; str_s.size() &lt;&lt; endl; //9
	cout &lt;&lt; str_s.length() &lt;&lt; endl; //9
	//cout &lt;&lt; strlen(str_s) &lt;&lt; endl;//无法隐式转换为const char *
	cout &lt;&lt; sizeof(str_s) &lt;&lt; endl; //28
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 23. 合并K个排序链表[困难]]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-23-he-bing-k-ge-pai-xu-lian-biao-kun-nan</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-23-he-bing-k-ge-pai-xu-lian-biao-kun-nan">
        </link>
        <updated>2020-01-19T01:29:44.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。<br>
示例:<br>
输入:<br>
[<br>
  1-&gt;4-&gt;5,<br>
  1-&gt;3-&gt;4,<br>
  2-&gt;6<br>
]<br>
输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/merge-k-sorted-lists<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>/*<br>
之前是两两合并，时间复杂度是O(n+m)，现在的话如果迭代使用两两合并的话，时间复杂度就要提升一个等级了O(k*(n+m))<br>
然后如果每次都搜索所有的list并取最小值的话 时间复杂度就是k*n了</p>
<p>然后复现一下官方代码<br>
1.分治法 在我的逐一对比的基础上复现为两两对比（也就是类似于归并排序）<br>
2.暴力法我就不实现了hhh，太暴力了吧<br>
3.优先队列的做法说实话有点trick，相当于利用了优先队列的内置sort</p>
<p>然后实现优先队列的遇到的点很值得拿出来说说<br>
1.for范围语句中必须判断i是否为null，否则会强行解引用null出错<br>
2.最重要的就是priority的比较行为定义了<br>
和sort等泛型函数不同，compare传入的不是简单的函数类型，而是一个函数对象！并且函数对象中重载了调用运算符<br>
priority_queue&lt;class Type,class Container,class Compare&gt;  （当然其自身有<code>great&lt;T&gt;</code>和<code>less&lt;T&gt;</code>两个定义，默认less）<br>
struct compare<br>
{<br>
bool operator()(ListNode* node1,ListNode* node2)<br>
{<br>
return node1-&gt;val&gt;=node2-&gt;val;<br>
}<br>
};</p>
<p>而且注意大于小于的返回判断，如果使用 &lt;=，返回的反而是大顶堆。。。</p>
<pre><code> 实现代码
</code></pre>
<pre><code>class Solution {
public:
    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists){

        priority_queue&lt;ListNode*,vector&lt;ListNode*&gt;,cmp&gt; list_queue;
        for(auto i:lists)
            if(i)
                list_queue.push(i);
        ListNode* head=new ListNode(0);
        ListNode* cur=head;
        while(list_queue.size()){
            cur-&gt;next=list_queue.top();
            list_queue.pop();
            cur=cur-&gt;next;
            if(cur-&gt;next)
                list_queue.push(cur-&gt;next);
        }
        return head-&gt;next;
    }
    
    struct cmp
    {
        bool operator()(ListNode* node1,ListNode* node2)
        {
            return node1-&gt;val&gt;=node2-&gt;val;
        }
    };


    /*
    //分治法（类似归并排序）
    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) {
        int len=lists.size();
        if(len==0) return NULL;
        int i=len-1;
        ListNode* head=new ListNode(0);
        while(i){    
            for(int beg=0,end=i;beg&lt;end;++beg,--end){
                SortList(head,lists[beg],lists[end]);
                lists[beg]=head-&gt;next;
            }
            i=i/2;    
        }
        return lists[0];
    }
    
    
    void SortList(ListNode* head,ListNode* list1,ListNode* list2){
        ListNode* cur=head;
        while(list1!=NULL&amp;&amp;list2!=NULL){
            if(list1-&gt;val&lt;=list2-&gt;val)
                cur-&gt;next=list1,list1=list1-&gt;next;
            else
                cur-&gt;next=list2,list2=list2-&gt;next;
            cur=cur-&gt;next;
        }
        cur-&gt;next=list1?list1:list2;
    }
    
    // 逐一比较法
    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) {
        ListNode* head=new ListNode(0);
        int len=lists.size();
        if(len==0) return head-&gt;next;
        ListNode* cur;
        head-&gt;next=lists[0];
        for(int i=1;i&lt;len;++i)
            SortList(head,head-&gt;next,lists[i]);
        return head-&gt;next;
    }
    */
};
</code></pre>
<p>方法 1：暴力<br>
想法 &amp; 算法<br>
遍历所有链表，将所有节点的值放到一个数组中。<br>
将这个数组排序，然后遍历所有元素得到正确顺序的值。<br>
用遍历得到的值，创建一个新的有序链表。</p>
<pre><code>class Solution(object):
    def mergeKLists(self, lists):
        &quot;&quot;&quot;
        :type lists: List[ListNode]
        :rtype: ListNode
        &quot;&quot;&quot;
        self.nodes = []
        head = point = ListNode(0)
        for l in lists:
            while l:
                self.nodes.append(l.val)
                l = l.next
        for x in sorted(self.nodes):
            point.next = ListNode(x)
            point = point.next
        return head.next
</code></pre>
<p>复杂度分析<br>
时间复杂度：O(NlogN) ，其中 N 是节点的总数目。<br>
遍历所有的值需花费 O(N) 的时间。<br>
一个稳定的排序算法花费 O(NlogN) 的时间。<br>
遍历同时创建新的有序链表花费 O(N) 的时间。<br>
空间复杂度：O(N) 。<br>
排序花费 O(N) 空间（这取决于你选择的算法）。<br>
创建一个新的链表花费O(N) 的空间。</p>
<p>方法 2：逐一比较<br>
算法<br>
比较 k 个节点（每个链表的首节点），获得最小值的节点。<br>
将选中的节点接在最终有序链表的后面。<br>
复杂度分析<br>
时间复杂度： O(kN) ，其中 \text{k}k 是链表的数目。<br>
几乎最终有序链表中每个节点的时间开销都为 O(k) （k-1 次比较）。<br>
总共有 N 个节点在最后的链表中。<br>
空间复杂度：<br>
O(n) 。创建一个新的链表空间开销为 O(n) 。<br>
O(1) 。重复利用原来的链表节点，每次选择节点时将它直接接在最后返回的链表后面，而不是创建一个新的节点。<br>
方法 3：用优先队列优化方法 2<br>
算法<br>
几乎与上述方法一样，除了将 比较环节 用 优先队列 进行了优化。</p>
<pre><code>from Queue import PriorityQueue

class Solution(object):
    def mergeKLists(self, lists):
        &quot;&quot;&quot;
        :type lists: List[ListNode]
        :rtype: ListNode
        &quot;&quot;&quot;
        head = point = ListNode(0)
        q = PriorityQueue()
        for l in lists:
            if l:
                q.put((l.val, l))
        while not q.empty():
            val, node = q.get()
            point.next = ListNode(val)
            point = point.next
            node = node.next
            if node:
                q.put((node.val, node))
        return head.next
</code></pre>
<p>复杂度分析<br>
时间复杂度：O(Nlogk) ，其中 k 是链表的数目。<br>
弹出操作时，比较操作的代价会被优化到 O(logk) 。同时，找到最小值节点的时间开销仅仅为O(1)。<br>
最后的链表中总共有 N 个节点。<br>
空间复杂度：<br>
O(n) 。创造一个新的链表需要 O(n) 的开销。<br>
O(k) 。以上代码采用了重复利用原有节点，所以只要 O(1) 的空间。同时优先队列（通常用堆实现）需要 O(k) 的空间（远比大多数情况的N要小）。</p>
<p>方法 4：逐一两两合并链表<br>
算法<br>
将合并k 个链表的问题转化成合并 2 个链表 k-1 次。这里是 合并两个有序链表 的题目。<br>
复杂度分析<br>
<img src="https://lixin-ee.github.io//post-images/1579398348227.png" alt=""></p>
<p>方法 5：分治<br>
想法 &amp; 算法<br>
<img src="https://lixin-ee.github.io//post-images/1579398405621.png" alt=""></p>
<pre><code>class Solution(object):
    def mergeKLists(self, lists):
        &quot;&quot;&quot;
        :type lists: List[ListNode]
        :rtype: ListNode
        &quot;&quot;&quot;
        amount = len(lists)
        interval = 1
        while interval &lt; amount:
            for i in range(0, amount - interval, interval * 2):
                lists[i] = self.merge2Lists(lists[i], lists[i + interval])
            interval *= 2
        return lists[0] if amount &gt; 0 else lists

    def merge2Lists(self, l1, l2):
        head = point = ListNode(0)
        while l1 and l2:
            if l1.val &lt;= l2.val:
                point.next = l1
                l1 = l1.next
            else:
                point.next = l2
                l2 = l1
                l1 = point.next.next
            point = point.next
        if not l1:
            point.next=l2
        else:
            point.next=l1
        return head.next
</code></pre>
<p><img src="https://lixin-ee.github.io//post-images/1579398425599.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 15. 三数之和[中等][未做出]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-15-san-shu-zhi-he-zhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-15-san-shu-zhi-he-zhong-deng-wei-zuo-chu">
        </link>
        <updated>2020-01-17T23:32:23.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。<br>
注意：答案中不可以包含重复的三元组。<br>
示例：<br>
给定数组 nums = [-1, 0, 1, 2, -1, -4]，<br>
满足要求的三元组集合为：<br>
[<br>
[-1, 0, 1],<br>
[-1, -1, 2]<br>
]<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/3sum<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>【未做出】<br>
可以利用16.最接近的三数之和 来做，不过这次target是0，而且必须等于target<br>
1.先排序 2.指定固定值 3.遍历 4.可作针对性优化</p>
<p>实现过程中遇到的问题：<br>
1.不能重复。。。所以想改用unordered_set,但是很离奇地不能用它的迭代器去初始化vector，然后改用set，结果超时了<br>
2.于是查看题解，发现是重复元素的问题<br>
3.添加条件i&gt;0&amp;&amp;nums[i]==nums[i-1])，因为我们排好序了，所以再添加nums[i]&gt;0的情况，大于0的话他后面数也铁定大于0，不可能和为0</p>
<pre><code>class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {
        int len=nums.size();
        quicksort(nums,0,len-1);
        set&lt;vector&lt;int&gt;&gt; res;
        for(int i=0;i&lt;len;++i){
            if((i&gt;0&amp;&amp;nums[i]==nums[i-1])||nums[i]&gt;0)
                continue;
            
            for(int j=i+1,k=len-1;j&lt;k;){
                int sum=nums[i]+nums[j]+nums[k];
                if(sum==0)
                    res.insert(vector&lt;int&gt;({nums[i],nums[j],nums[k]}));   
                if(sum&gt;0)
                    --k;
                else
                    ++j;
            }
        }
        return vector&lt;vector&lt;int&gt;&gt;(res.begin(),res.end());      
    }
    
    void quicksort(vector&lt;int&gt; &amp;nums,int beg,int end){
        if(beg&lt;end){
            int mid=partition(nums,beg,end);
            quicksort(nums,beg,mid-1);
            quicksort(nums,mid+1,end);
        }
    }
    
    int partition(vector&lt;int&gt; &amp;nums,int beg,int end){
        int pivotkey=nums[beg];
        while(beg&lt;end){
            while(beg&lt;end&amp;&amp;pivotkey&lt;=nums[end])
                --end;
            nums[beg]=nums[end];
            while(beg&lt;end&amp;&amp;pivotkey&gt;=nums[beg])
                ++beg;
            nums[end]=nums[beg];
        }
        nums[beg]=pivotkey;
        return beg;
    }
};
</code></pre>
<p>然后来看看网友题解：</p>
<blockquote>
<p>解题方案<br>
思路<br>
标签：数组遍历<br>
首先对数组进行排序，排序后固定一个数 nums[i]，再使用左右指针指向 nums[i]后面的两端，数字分别为 nums[L] 和 nums[R]，计算三个数的和sum 判断是否满足为 0，满足则添加进结果集<br>
如果 nums[i]大于 0，则三数之和必然无法等于 0，结束循环<br>
如果 nums[i] == nums[i−1]，则说明该数字重复，会导致结果重复，所以应该跳过<br>
当 sum == 0 时，nums[L] == nums[L+1] 则会导致结果重复，应该跳过，L++<br>
当 sum== 0 时，nums[R] == nums[R−1] 则会导致结果重复，应该跳过，R--<br>
时间复杂度：O(n^2)，n 为数组长度<br>
代码</p>
</blockquote>
<pre><code>class Solution {
    public static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {
        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList();
        int len = nums.length;
        if(nums == null || len &lt; 3) return ans;
        Arrays.sort(nums); // 排序
        for (int i = 0; i &lt; len ; i++) {
            if(nums[i] &gt; 0) break; // 如果当前数字大于0，则三数之和一定大于0，所以结束循环
            if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue; // 去重
            int L = i+1;
            int R = len-1;
            while(L &lt; R){
                int sum = nums[i] + nums[L] + nums[R];
                if(sum == 0){
                    ans.add(Arrays.asList(nums[i],nums[L],nums[R]));
                    while (L&lt;R &amp;&amp; nums[L] == nums[L+1]) L++; // 去重
                    while (L&lt;R &amp;&amp; nums[R] == nums[R-1]) R--; // 去重
                    L++;
                    R--;
                }
                else if (sum &lt; 0) L++;
                else if (sum &gt; 0) R--;
            }
        }        
        return ans;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 5. 最长回文子串[中等][未做出]]]></title>
        <id>https://lixin-ee.github.io//post/zi-fu-chuan-5-zui-chang-hui-wen-zi-chuan-zhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/zi-fu-chuan-5-zui-chang-hui-wen-zi-chuan-zhong-deng-wei-zuo-chu">
        </link>
        <updated>2020-01-16T14:21:05.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。<br>
示例 1：<br>
输入: &quot;babad&quot;<br>
输出: &quot;bab&quot;<br>
注意: &quot;aba&quot; 也是一个有效答案。<br>
示例 2：<br>
输入: &quot;cbbd&quot;<br>
输出: &quot;bb&quot;<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/longest-palindromic-substring<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>【未做出】<br>
本来以为和大话数据结构里面的KMP匹配算法比较像<br>
结果发现不是的 KMP是类似于 ababa之中的前面一个【aba】ba和后面一个ab【aba】匹配<br>
然后偷看tag发现需要用动态规划来做<br>
我的想法是先确定两边beg和end 然后不断收缩比较，但是这样子的话等于C2-n种情况 再加上比较，直接立方级别的时间复杂度啊<br>
看题解！</p>
<p>实现动态规划需要注意的点<br>
1.动态规划数组pd需要初始化为false而不是true 否则必须将不通过if的pd[l][r]重置为false，所以还是初始化为false比较方便<br>
2.动态规划时间复杂度很高，区间判断和修改放在同一个if里面就好，独立出来会超时<br>
3.可以空间压缩 画图可以发现，当前格子总是参考左下角格子（行为r，列为l）（if判断可以省略掉没有左下角的格子），比如[0,4]参考[1,3]，对于r来说不重要，只要l+1就行，所以可以使用两个bool数组保存列，注意是保存【列】！！！，然后注意如果不通过判断的话需要刷新值置为false！！！这一步不可或缺，否则最后都是true了。然后发现如果是l需要l+1的话，完全可以用一个bool数组列就解决了。</p>
<pre><code>class Solution {
public:
    string longestPalindrome(string s) {
        int len=s.size();
        string res;
        int beg=0,end=0;
        if(len==0) return res;
        //vector&lt;vector&lt;bool&gt;&gt; pd(len,vector&lt;bool&gt;(len,false));
        vector&lt;bool&gt; cur(len,false);
        for(int r=0;r&lt;len;++r)
            for(int l=0;l&lt;r;++l)
                //pd[l][r]=(s[l]==s[r]&amp;&amp;(r-l&lt;=2||pd[l+1][r-1]));
                if(s[l]==s[r]&amp;&amp;(r-l&lt;=2||cur[l+1])){
                    cur[l]=true;
                    if(r-l&gt;end-beg)
                        beg=l,end=r;
                }
                else cur[l]=false;        
        return s.substr(beg,end-beg+1);
    }
};
</code></pre>
<p>中心扩散法实现：</p>
<pre><code>    string longestPalindrome(string s) {
        int len=s.size();
        if(len&lt;2)
            return s;
        string maxStr;
				//hhh一开始int i忘了赋值了，居然无法通过提交，似乎提交用的编译器不会执行值初始化，使用的是默认初始化，导致函数体内部的内置类型变量将不被初始化，此时变量的值是未定义的（undefined）
        for(int i=0;i&lt;len-1;++i){   
            string oddStr=isPalin(s,i,i);
            string evenStr=isPalin(s,i,i+1);
            maxStr=maxStr.size()&gt;oddStr.size()?maxStr:oddStr;
            maxStr=maxStr.size()&gt;evenStr.size()?maxStr:evenStr;
        }
        return maxStr;
    }
    
    string isPalin(const string &amp;s,int left,int right){
        string res;
        while(left&gt;=0&amp;&amp;right&lt;s.size()){
            if(s[left]==s[right]){
                --left;
                ++right;
            }else
                break;
        }
        return s.substr(left+1,right-left-1);
    }
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>方法一：暴力匹配 （Brute Force）<br>
根据回文子串的定义，枚举所有长度大于等于 22 的子串，依次判断它们是否是回文；<br>
在具体实现时，可以只针对大于“当前得到的最长回文子串长度”的子串进行“回文验证”；<br>
在记录最长回文子串的时候，可以只记录“当前子串的起始位置”和“子串长度”，不必做截取。这一步我们放在后面的方法中实现。<br>
说明：暴力解法时间复杂度高，但是思路清晰、编写简单。由于编写正确性的可能性很大，可以使用暴力匹配算法检验我们编写的其它算法是否正确。优化的解法在很多时候，是基于“暴力解法”，以空间换时间得到的，因此思考清楚暴力解法，分析其缺点，很多时候能为我们打开思路。</p>
</blockquote>
<pre><code>class Solution {
private:
    bool valid(string s, int left, int right) {
        // 验证子串 s[left, right] 是否为回文串
        while (left &lt; right) {
            if (s[left] != s[right]) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }

public:
    string longestPalindrome(string s) {
        // 特判
        int size = s.size();
        if (size &lt; 2) {
            return s;
        }

        int maxLen = 1;
        string res = s.substr(0, 1);

        // 枚举所有长度大于等于 2 的子串
        for (int i = 0; i &lt; size - 1; i++) {
            for (int j = i + 1; j &lt; size; j++) {
                if (j - i + 1 &gt; maxLen &amp;&amp; valid(s, i, j)) {
                    maxLen = j - i + 1;
                    res = s.substr(i, maxLen);
                }
            }
        }
        return res;
    }
};

// 运行结果超出内存限制
</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(N^3)，这里 N 是字符串的长度，枚举字符串的左边界、右边界，然后继续验证子串是否是回文子串，这三种操作都与 N 相关；<br>
空间复杂度：O(1)，只使用到常数个临时变量，与字符串长度无关。</p>
</blockquote>
<blockquote>
<p>方法二：动态规划<br>
“动态规划”最关键的步骤是想清楚“状态如何转移”，事实上，“回文”是天然具有“状态转移”性质的：<br>
一个回文去掉两头以后，剩下的部分依然是回文（这里暂不讨论边界）。<br>
依然从回文串的定义展开讨论：<br>
1、如果一个字符串的头尾两个字符都不相等，那么这个字符串一定不是回文串；<br>
2、如果一个字符串的头尾两个字符相等，才有必要继续判断下去。<br>
（1）如果里面的子串是回文，整体就是回文串；<br>
（2）如果里面的子串不是回文串，整体就不是回文串。<br>
即在头尾字符相等的情况下，里面子串的回文性质据定了整个子串的回文性质，这就是状态转移。因此可以把“状态”定义为原字符串的一个子串是否为回文子串。<br>
第 1 步：定义状态<br>
dp[i][j] 表示子串 s[i, j] 是否为回文子串。<br>
第 2 步：思考状态转移方程<br>
这一步在做分类讨论（根据头尾字符是否相等），根据上面的分析得到：<br>
dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]<br>
分析这个状态转移方程：<br>
（1）“动态规划”事实上是在填一张二维表格，i 和 j 的关系是 i &lt;= j ，因此，只需要填这张表的上半部分；<br>
（2）看到 dp[i + 1][j - 1] 就得考虑边界情况。<br>
边界条件是：表达式 [i + 1, j - 1] 不构成区间，即长度严格小于 2，即 j - 1 - (i + 1) + 1 &lt; 2 ，整理得 j - i &lt; 3。<br>
这个结论很显然：当子串 s[i, j] 的长度等于 2 或者等于 3 的时候，我其实只需要判断一下头尾两个字符是否相等就可以直接下结论了。<br>
如果子串 s[i + 1, j - 1] 只有 1 个字符，即去掉两头，剩下中间部分只有 11 个字符，当然是回文；<br>
如果子串 s[i + 1, j - 1] 为空串，那么子串 s[i, j] 一定是回文子串。<br>
因此，在 s[i] == s[j] 成立和 j - i &lt; 3 的前提下，直接可以下结论，dp[i][j] = true，否则才执行状态转移。<br>
（这一段看晕的朋友，直接看代码吧。我写晕了，车轱辘话来回说。）<br>
第 3 步：考虑初始化<br>
初始化的时候，单个字符一定是回文串，因此把对角线先初始化为 1，即 dp[i][i] = 1 。<br>
事实上，初始化的部分都可以省去。因为只有一个字符的时候一定是回文，dp[i][i] 根本不会被其它状态值所参考。<br>
第 3 步：考虑初始化<br>
初始化的时候，单个字符一定是回文串，因此把对角线先初始化为 1，即 dp[i][i] = 1 。<br>
事实上，初始化的部分都可以省去。因为只有一个字符的时候一定是回文，dp[i][i] 根本不会被其它状态值所参考。<br>
第 4 步：考虑输出<br>
只要一得到 dp[i][j] = true，就记录子串的长度和起始位置，没有必要截取，因为截取字符串也要消耗性能，记录此时的回文子串的“起始位置”和“回文长度”即可。<br>
第 5 步：考虑状态是否可以压缩<br>
因为在填表的过程中，只参考了左下方的数值。事实上可以压缩，但会增加一些判断语句，增加代码编写和理解的难度，丢失可读性。在这里不做状态压缩。<br>
下面是编码的时候要注意的事项：总是先得到小子串的回文判定，然后大子串才能参考小子串的判断结果。<br>
思路是：<br>
1、在子串右边界 j 逐渐扩大的过程中，枚举左边界可能出现的位置；<br>
2、左边界枚举的时候可以从小到大，也可以从大到小。<br>
这两版代码的差别仅在内层循环，希望大家能够自己动手，画一下表格，思考为什么这两种代码都是可行的，相信会对“动态规划”作为一种“表格法”有一个更好的理解。</p>
</blockquote>
<pre><code>public class Solution {


    public String longestPalindrome(String s) {
        int len = s.length();
        if (len &lt; 2) {
            return s;
        }

        boolean[][] dp = new boolean[len][len];

        int maxLen = 1;
        int start = 0;

        for (int j = 1; j &lt; len; j++) {
            for (int i = 0; i &lt; j; i++) {

                dp[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt; 3 || dp[i + 1][j - 1]);

                if (dp[i][j]) {
                    int curLen = j - i + 1;
                    if (curLen &gt; maxLen) {
                        maxLen = curLen;
                        start = i;
                    }
                }
            }
        }
        return s.substring(start, start + maxLen);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(N^2)。<br>
空间复杂度：O(N^2)，二维 dp 问题，一个状态得用二维有序数对表示</p>
</blockquote>
<blockquote>
<p>方法三：中心扩散法<br>
暴力法采用双指针两边夹，验证是否是回文子串。<br>
除了枚举字符串的左右边界以外，比较容易想到的是枚举可能出现的回文子串的“中心位置”，从“中心位置”尝试尽可能扩散出去，得到一个回文串。<br>
因此中心扩散法的思路是：遍历每一个索引，以这个索引为中心，利用“回文串”中心对称的特点，往两边扩散，看最多能扩散多远。<br>
枚举“中心位置”时间复杂度为 O(N)，从“中心位置”扩散得到“回文子串”的时间复杂度为 O(N)，因此时间复杂度可以降到 O(N^2)。<br>
在这里要注意一个细节：回文串在长度为奇数和偶数的时候，“回文中心”的形式是不一样的。<br>
奇数回文串的“中心”是一个具体的字符，例如：回文串 &quot;aba&quot; 的中心是字符 &quot;b&quot;；<br>
偶数回文串的“中心”是位于中间的两个字符的“空隙”，例如：回文串串 &quot;abba&quot; 的中心是两个 &quot;b&quot; 中间的那个“空隙”。<br>
我们可以设计一个方法，兼容以上两种情况：<br>
1、如果传入重合的索引编码，进行中心扩散，此时得到的回文子串的长度是奇数；<br>
2、如果传入相邻的索引编码，进行中心扩散，此时得到的回文子串的长度是偶数。</p>
</blockquote>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;

class Solution {

private:

    string centerSpread(string s, int left, int right) {
        // left = right 的时候，此时回文中心是一个空隙，向两边扩散得到的回文子串的长度是奇数
        // right = left + 1 的时候，此时回文中心是一个字符，向两边扩散得到的回文子串的长度是偶数
        int size = s.size();
        int i = left;
        int j = right;
        while (i &gt;= 0 &amp;&amp; j &lt; size) {
            if (s[i] == s[j]) {
                i--;
                j++;
            } else {
                break;
            }
        }
        // 这里要小心，跳出 while 循环时，恰好满足 s.charAt(i) != s.charAt(j)，因此不能取 i，不能取 j
        return s.substr(i + 1, j - i - 1);
    }

public:


    string longestPalindrome(string s) {
        // 特判
        int size = s.size();
        if (size &lt; 2) {
            return s;
        }

        int maxLen = 1;
        string res = s.substr(0, 1);

        // 中心位置枚举到 len - 2 即可
        for (int i = 0; i &lt; size - 1; i++) {
            string oddStr = centerSpread(s, i, i);
            string evenStr = centerSpread(s, i, i + 1);
            string maxLenStr = oddStr.size() &gt; evenStr.size() ? oddStr : evenStr;
            if (maxLenStr.length() &gt; maxLen) {
                maxLen = maxLenStr.size();
                res = maxLenStr;
            }
        }
        return res;
    }
};
</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(N^2)<br>
空间复杂度：O(1)，只使用到常数个临时变量，与字符串长度无关。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 54. 螺旋矩阵[中等]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-54-luo-xuan-ju-zhen-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-54-luo-xuan-ju-zhen-zhong-deng">
        </link>
        <updated>2020-01-16T01:35:45.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。<br>
示例 1:<br>
输入:<br>
[<br>
[ 1, 2, 3 ],<br>
[ 4, 5, 6 ],<br>
[ 7, 8, 9 ]<br>
]<br>
输出: [1,2,3,6,9,8,7,4,5]<br>
示例 2:<br>
输入:<br>
[<br>
[1, 2, 3, 4],<br>
[5, 6, 7, 8],<br>
[9,10,11,12]<br>
]<br>
输出: [1,2,3,4,8,12,11,10,9,5,6,7]<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/spiral-matrix<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>可以参考螺旋矩阵II<br>
设置四个边界 left right top bottom</p>
<p>实现中需要注意的点：<br>
1.不小心把bottom和right的赋值搞反了。。。<br>
2.和n*n的矩阵不同，这里必须每个循环都判断&amp;&amp;res.size()&lt;len，否则[[1,2,3,4],[5,6,7,8],[9,10,11,12]]最后会出现[1,2,3,4,8,12,11,10,9,5,6,7,6]那个6的情况（是正确的）</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        vector&lt;int&gt; res;
        if(matrix.empty()) return res;
        int top=0,bottom=matrix.size()-1,left=0,right=matrix[0].size()-1; 
        int len=(bottom+1)*(right+1);
        while(res.size()&lt;len){
            for(int i=left;i&lt;=right&amp;&amp;res.size()&lt;len;++i)
                res.push_back(matrix[top][i]);
            ++top;
            for(int i=top;i&lt;=bottom&amp;&amp;res.size()&lt;len;++i)
                res.push_back(matrix[i][right]);
            --right;
            for(int i=right;i&gt;=left&amp;&amp;res.size()&lt;len;--i)
                res.push_back(matrix[bottom][i]);
            --bottom;
            for(int i=bottom;i&gt;=top&amp;&amp;res.size()&lt;len;--i)
                res.push_back(matrix[i][left]);
            ++left;
        }
        return res;
    }
};
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>这里的方法不需要记录已经走过的路径，所以执行用时和内存消耗都相对较小<br>
首先设定上下左右边界<br>
其次向右移动到最右，此时第一行因为已经使用过了，可以将其从图中删去，体现在代码中就是重新定义上边界<br>
判断若重新定义后，上下边界交错，表明螺旋矩阵遍历结束，跳出循环，返回答案<br>
若上下边界不交错，则遍历还未结束，接着向下向左向上移动，操作过程与第一，二步同理<br>
不断循环以上步骤，直到某两条边界交错，跳出循环，返回答案</p>
</blockquote>
<pre><code>class Solution {
public:
    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        vector &lt;int&gt; ans;
        if(matrix.empty()) return ans; //若数组为空，直接返回答案
        int u = 0; //赋值上下左右边界
        int d = matrix.size() - 1;
        int l = 0;
        int r = matrix[0].size() - 1;
        while(true)
        {
            for(int i = l; i &lt;= r; ++i) ans.push_back(matrix[u][i]); //向右移动直到最右
            if(++ u &gt; d) break; //重新设定上边界，若上边界大于下边界，则遍历遍历完成，下同
            for(int i = u; i &lt;= d; ++i) ans.push_back(matrix[i][r]); //向下
            if(-- r &lt; l) break; //重新设定有边界
            for(int i = r; i &gt;= l; --i) ans.push_back(matrix[d][i]); //向左
            if(-- d &lt; u) break; //重新设定下边界
            for(int i = d; i &gt;= u; --i) ans.push_back(matrix[i][l]); //向上
            if(++ l &gt; r) break; //重新设定左边界
        }
        return ans;
    }
};
</code></pre>
<blockquote>
<p>时间复杂度： O(N)，其中 N 是输入矩阵所有元素的个数。因为我们将矩阵中的每个元素都添加进答案里。<br>
空间复杂度： O(N)，需要矩阵 ans 存储信息。</p>
</blockquote>
<p>这个就是我那种的变种，不过我使用了size来判断，他使用了边界条件了判断</p>
]]></content>
    </entry>
</feed>