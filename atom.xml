<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-11-17T14:27:37.313Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[C++ primer 第十六章 笔记+习题 16.1]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-liu-zhang-bi-ji-xi-ti-161</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-liu-zhang-bi-ji-xi-ti-161">
        </link>
        <updated>2019-11-17T12:24:32.000Z</updated>
        <content type="html"><![CDATA[<p>16 模板与泛型编程<br>
16.1定义模型<br>
16.1.1 函数模板<br>
一个<strong>函数模板</strong>就是一个<strong>公式</strong>，可用来<strong>生成针对特定类型的函数版本</strong> 。compare的模板版本可能像下面这样 ；</p>
<p>模板定义以<strong>关键字 template <strong>开始，后跟一个</strong>模板参数列表</strong> （template parameter list ),这是一个逗号分隔的一个或多个模板参数( templateparameter )的列表，用小于号（&lt;）和大于号（&gt;）包围起来<br>
在模板定义中，<strong>模板参数列表不能为空</strong>。<br>
模板参数表示在类或函数定义中用到的<strong>类型或值</strong>。当使用模板时，我们（隐式地或显式地）指定<strong>模板实参 （template argument )</strong> 将其绑定到模板参数上。<br>
当我们调用一个函数模板时，编译器（通常）用<strong>函数实参</strong>来为我们<strong>推断模板实参</strong>。<br>
编译器用推断出的模板参数来为我们<strong>实例化( instantiate)</strong> 一个特定版本的函数。当编译器实例化一个模板时，它使用实际的模板实参代替对应的模板参数来创建出模板的一个新&quot;实例&quot;。例如，给定下面的调用：</p>
<p>这些编译器生成的版本通常被称为<strong>模板的实例</strong><br>
我们的 compare 函数有一个<strong>模板类型参数（type parameter )</strong>。一般来说，我们可以将<br>
类型参数看作<strong>类型说明符</strong>.就像内置类型或类类型说明符一样使用。特别是，类型参数可以用来<strong>指定返回类型</strong>或<strong>函数的参数类型</strong>，以及在<strong>函数体内</strong>用于<strong>变量声明</strong>或<strong>类型转换</strong>：<br>
类型参数前必须使用<strong>关键字 class 或 typename</strong> ：<br>
// 错误： U 之前必须加上 class 或 typename<br>
template&lt;typename T,U&gt; T calc(const T&amp;,const U&amp;);<br>
看起來用关键字 typename 来指定模板类型参数比用 class 更为直观。</p>
<p>除了定义类型参数，还可以在模板中定义<strong>非类型参数( nontypeparameter )<strong>一个非类型参数表示</strong>一个值</strong>而<strong>非一个类型</strong>。我们<strong>通过一个特定的类型名</strong>而非关键字 class 或typename 来<strong>指定非类型参数</strong>。<br>
当一个模板被实例化时，非类型参数被一个<strong>用户提供</strong>的或<strong>编译器推断出</strong>的值所代替。这些值<strong>必须是常量表达式</strong>（参见2.4.4节，第58页），从而允许编译器在编译时实例化模板。</p>
<p>在template&lt;unsigned N,unsigned M&gt;中 N和M只是一个值，unsigned是一个类型，但重点在于N M这两个值<br>
一个<strong>非类型参数</strong>可以是一个<strong>整型</strong>，或者是一个指向对象或函数类型的<strong>指针或（左值）引用</strong>。绑定到<strong>非类型整型参数</strong>的实参<strong>必须是一个常量表达式</strong>。绑定到<strong>指针或引用非类型参数</strong>的实参必须具有<strong>静态的生存期</strong>（static对象或者）（参见第12章，第400页）。我们不能用一个普通（非static )局部变量或动态对象作为指针或引用非类型模板参数的实参。指针参数也可以用 <strong>nullptr 或一个值为0的常量表达式</strong>来实例化。<br>
在模板定义内，模板非类型参数是一个常量值。在需要常量表达式的地方，可以使用非类型参数，例如，指定数组大小。<br>
函数模板可声明为** inline 或 constexpr** 的，如同非模板函数一样。 inline 或constexpr 说明符放在<strong>模板参数列表之后，返回类型之前</strong>：</p>
<p>•模板中的函数参数是 const 的引用。<br>
•函数体中的条件判断仅使用&lt;比较运算。</p>
<p>通过将函数参数设定为 const 的引用，我们保证了函数可以用于不能拷贝的类型。大多数类型，包括内置类型和我们已经用过的标准库类型（除 unique _ ptr 和IO类型之外 ）都是允许拷贝的。</p>
<p>模板程序应该尽量<strong>减少对实参类型的要求</strong>。</p>
<p>当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。当我们使用（而不是定义）模板时，编译器才生成代码，这一特性影响了我们如何组织代码以及<strong>错误何时被检测到</strong>。<br>
通常，当我们<strong>调用一个函数</strong>时，编详器<strong>只需要</strong>掌握函数的<strong>声明</strong>。类似的，当我们<strong>使用一个类类型的对象</strong>时，<strong>类定义必须是可用的</strong>，但<strong>成员函数的定义不必已经出现</strong>。因此，我们将<strong>类定义</strong>和<strong>函数声明</strong>放在<strong>头文件中</strong>，而<strong>普通函数</strong>和<strong>类的成员函数的定义</strong>放在<strong>源文件</strong>中。<br>
<strong>模板则不同</strong>：为了生成一个<strong>实例化版本</strong>，编译器需要掌握函数模板或类模板成员函数的<strong>定义</strong>。因此，与非模板代码不同，<strong>模板的头文件</strong>通常既<strong>包括声明也包括定定义。</strong><br>
<strong>函数模板</strong>和<strong>类模板成员函数</strong>的定义通常放在<strong>头文件中</strong>。<br>
当使用模板时，所有不依赖于模板参数的名字都必须是可见的，这是由模板的提供者保证的<br>
用来实例化模板的所有函数、类型以及与类型关联的运算符的声明都必须是可见的，这是由模板的用户来保证的。</p>
<p>通常，编译器会在三个阶段报告错误。<br>
第一个阶段是<strong>编译模板本身</strong>时。在这个阶段，编译器通常不会发现很多错误。编译器可以检查语法错误，例如忘记分号或者变量名拼错等，但也就这么多了。<br>
第二个阶段是编译器遇到<strong>模板使用</strong>时。在此阶段，编译器仍然没有很多可检查的。对于函数模板调用，编译器通常会检查实参数目是否正确。还能检查参数类型是否匹配。对于类模板，编译器可以检查用户是否提供了正确数目的模板实参，但也仅限于此了。<br>
第三个阶段是<strong>模板实例化</strong>时，只有这个阶段才能发现类型相关的错误。依赖于编译器如何管理实例化，这类错误可能在链接时才报告。<br>
当我们编写模板时，代码不能是针对特定类型的，但模板代码通常对其所使用的类型有一些假设。例如，我们最初的 compare 函数中的代码就假定实参类型定义了&lt;运算符。<br>
保证传递给模板的<strong>实参支持模板所要求的操作</strong>，以及这些操作在模板中<strong>能正确工作</strong>，是<strong>调用者的责任</strong>。</p>
<p>习题16.1<br>
编译器用推断出的模板参数来为我们<strong>实例化( instantiate)</strong> 一个特定版本的函数。当编译器实例化一个模板时，它使用实际的模板实参代替对应的模板参数来创建出模板的一个新&quot;实例&quot;<br>
习题16.2</p>
<pre><code>template &lt;typename T&gt; int compare(const T &amp;v1, const T &amp;v2) {
	if (less&lt;T&gt;()(v1, v2)) return -1;
	if (less&lt;T&gt;()(v2, v1))return 1;
	return 0;
}
</code></pre>
<p>注意<code>less&lt;type&gt;</code>本身也是一个模板，需要创建一个临时对象才能使用，所以中间有个空括号<br>
习题16.3<br>
error C2678: 二进制“&lt;”: 没有找到接受“const Sales_Data”类型的左操作数的运算符(或没有可接受的转换)<br>
习题16.4</p>
<pre><code>template&lt;typename T, typename B&gt; T Find(const T beg, const T end, B value) {
	for (T i = beg; i != end; ++i)
		if (*i == value)
			return i;
	return end;
}
int main() {
	vector&lt;int&gt; vi{ 1,2,3,4,5,6,7 };
	list&lt;string&gt; ls{ &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot; };
	string s = &quot;4&quot;;
	cout &lt;&lt; *Find(ls.begin(), ls.end(), s) &lt;&lt; endl;
}
</code></pre>
<p>需要注意的点：<br>
1.库函数find的返回值为迭代器（虽然是输入迭代器），这里我还是直接用T吧<br>
2.注意循环判断条件不能用<code>i&lt;end</code>，因为只有随机迭代器才支持关系运算符，题目中的list使用双向迭代器就没法用小于号<br>
习题16.5</p>
<pre><code>template&lt;typename T, unsigned N&gt; void print(T(&amp;arr)[N]) {
	for (auto elem : arr)
		cout &lt;&lt; elem &lt;&lt; endl;
}
int main() {
	int arri[5]{ 1,2,3,4,5 };
	char arrc[6] = &quot;12345&quot;;
	cout &lt;&lt; strlen(arrc)&lt;&lt;endl;
	print(arri);
}
</code></pre>
<p>需要注意的点：<br>
1<code>.T(&amp;arr)[N]</code>的括号不可少，否则就是引用的数组了。然后N也不可少，N也属于形参类型的一部分<br>
2.strlen计算长度的时候会忽视空字符，但是实际char数组中还是得老老实实加上一位存空字符，否则会报错（昨天的面试题中就有一道考strlen细节的）<br>
习题16.6</p>
<pre><code>template&lt;typename T, unsigned N&gt; T* begin(const T(&amp;arr)[N])
{// error C2234: “arr”: 引用数组是非法的,(&amp;arr即可)
	return arr;
}

template&lt;typename T, unsigned N&gt; T* end(const T(&amp;arr)[N])
{
	return arr + N;
}

int main() {
	int arri[5]{ 1,2,3,4,5 };
	char arrc[6] = &quot;12345&quot;;
	cout &lt;&lt; *begin(arrc) &lt;&lt;&quot; &quot;&lt;&lt;*(end(arrc)-2)&lt;&lt; endl;
}
</code></pre>
<p>此题主要针对的是数组的调用，例如begin(arr)，而不是vi.begin()<br>
习题16.7</p>
<pre><code>template&lt;typename T&gt; unsigned length(T(&amp;arr)) {
	unsigned len = 0;
	for (auto i : arr)
		++len;
	return len;
}

template&lt;typename T,unsigned N&gt; unsigned lengthN(T(&amp;arr)[N]) {
	return N;
}
int main() {
	int arri[5]{ 1,2,3,4,5 };
	char arrc[6] = &quot;12345&quot;;
	cout &lt;&lt; length(arrc)&lt;&lt; endl;
	cout &lt;&lt; lengthN(arrc) &lt;&lt; endl;
}
</code></pre>
<p>两种形式，第二种未免太暴力了一点。。。<br>
习题16.8<br>
因为大多数自定义类型，比如类都是有定义<mark>而没有定义&lt;，！=可以直接利用</mark>的定义来工作，比如迭代器中，所以==保证了较高的通用性</p>
<p>习题感悟：<br>
需要注意的点：<br>
1.库函数find的返回值为迭代器（虽然是输入迭代器），这里我还是直接用T吧<br>
2.注意循环判断条件不能用<code>i&lt;end</code>，因为只有随机迭代器才支持关系运算符，题目中的list使用双向迭代器就没法用小于号<br>
1<code>.T(&amp;arr)[N]</code>的括号不可少，否则就是引用的数组了。然后N也不可少，N也属于形参类型的一部分<br>
2.strlen计算长度的时候会忽视空字符，但是实际char数组中还是得老老实实加上一位存空字符，否则会报错（昨天的面试题中就有一道考strlen细节的）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 104. 二叉树的最大深度[简单]]]></title>
        <id>https://lixin-ee.github.io//post/shu-104-er-cha-shu-de-zui-da-shen-du-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/shu-104-er-cha-shu-de-zui-da-shen-du-jian-dan">
        </link>
        <updated>2019-11-17T00:53:18.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个二叉树，找出其最大深度。<br>
二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>
说明: 叶子节点是指没有子节点的节点。<br>
示例：<br>
给定二叉树 [3,9,20,null,null,15,7]，<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7<br>
返回它的最大深度 3 。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>其实那个题号顺序还是有那么一点问题，我感觉这道题理应放在111前面<br>
寻找最小深度的时候可着实是麻烦了一把，这一次求最大深度，就没那么麻烦了，直接大力出奇迹，连叶节点的判断都不用了，反正i最大的那个肯定就是叶节点（非叶节点的深度不可能超过叶节点的）<br>
代码也非常简洁：</p>
<pre><code>class Solution {
public:
    int maxDepth(TreeNode* root) {
        return preorder(root,0);
    }
    
    int preorder(TreeNode* cur,int i){
        if(cur==NULL)
            return i;
        return max(preorder(cur-&gt;left,i+1),preorder(cur-&gt;right,i+1));
    }
};
</code></pre>
<p>官方题解如下：</p>
<blockquote>
<p>方法一：递归<br>
算法<br>
直观的方法是通过递归来解决问题。在这里，我们演示了 DFS（深度优先搜索）策略的示例。</p>
</blockquote>
<pre><code>Java
class Solution {
  public int maxDepth(TreeNode root) {
    if (root == null) {
      return 0;
    } else {
      int left_height = maxDepth(root.left);
      int right_height = maxDepth(root.right);
      return java.lang.Math.max(left_height, right_height) + 1;
    }
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：我们每个结点只访问一次，因此时间复杂度为 O(N)，<br>
其中 N 是结点的数量。<br>
空间复杂度：在最糟糕的情况下，树是完全不平衡的，例如每个结点只剩下左子结点，递归将会被调用 N 次（树的高度），因此保持调用栈的存储将是 O(N)。但在最好的情况下（树是完全平衡的），树的高度将是log(N)。因此，在这种情况下的空间复杂度将是O(log(N))。</p>
</blockquote>
<blockquote>
<p>方法二：迭代<br>
我们还可以在栈的帮助下将上面的递归转换为迭代。<br>
我们的想法是使用 DFS 策略访问每个结点，同时在每次访问时更新最大深度。<br>
所以我们从包含根结点且相应深度为 1 的栈开始。然后我们继续迭代：将当前结点弹出栈并推入子结点。每一步都会更新深度。</p>
</blockquote>
<pre><code>Java
import javafx.util.Pair;
import java.lang.Math;

class Solution {
  public int maxDepth(TreeNode root) {
    Queue&lt;Pair&lt;TreeNode, Integer&gt;&gt; stack = new LinkedList&lt;&gt;();
    if (root != null) {
      stack.add(new Pair(root, 1));
    }

    int depth = 0;
    while (!stack.isEmpty()) {
      Pair&lt;TreeNode, Integer&gt; current = stack.poll();
      root = current.getKey();
      int current_depth = current.getValue();
      if (root != null) {
        depth = Math.max(depth, current_depth);
        stack.add(new Pair(root.left, current_depth + 1));
        stack.add(new Pair(root.right, current_depth + 1));
      }
    }
    return depth;
  }
};
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(N)。<br>
空间复杂度：O(N)。</p>
</blockquote>
<p>官方的解法一致，这道题还是比较简单的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 111. 二叉树的最小深度[简单]]]></title>
        <id>https://lixin-ee.github.io//post/shu-111-er-cha-shu-de-zui-xiao-shen-du-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/shu-111-er-cha-shu-de-zui-xiao-shen-du-jian-dan">
        </link>
        <updated>2019-11-16T07:51:43.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个二叉树，找出其最小深度。<br>
最小深度是从根节点到最近叶子节点的最短路径上的节点数量。<br>
说明: 叶子节点是指没有子节点的节点。<br>
示例:<br>
给定二叉树 [3,9,20,null,null,15,7],<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7<br>
返回它的最小深度  2.<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/minimum-depth-of-binary-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题的要点在于累计当前节点到根节点的距离并检测是否是根节点<br>
和前面的题目还是非常相似的<br>
说实话这一题真的是蛮波折的，一开始不想用全局值了，以为利用min直接返回局部i值就好，结果遇到了++i这个小插曲，然后遇到了严重问题，遇到非叶节点的NULL节点时返回的值是无效的<br>
然后还是得老老实实学习前几题那样先放弃null节点，然后再判断叶子节点进行返回，<br>
同时全局值一开始必须设为int_max，然后必须判断root值是否为null（因为没法把res值设为0）<br>
代码如下：</p>
<pre><code>class Solution {
int res=INT_MAX;
public:
    int minDepth(TreeNode* root) {
        if(root==NULL)
            return 0;
        preorder(root,1);
        return res;
    }
    
    void preorder(TreeNode* cur,int i){
        if(cur==NULL)
            return; 
        if(cur-&gt;left==NULL&amp;&amp;cur-&gt;right==NULL) //这里又傻逼了，直接用了cur==null判断，明显会导致非叶节点的返回
        {
            res=res&lt;i?res:i;
            return;
        } 
        preorder(cur-&gt;left,i+1);
        preorder(cur-&gt;right,i+1);//这里傻逼了，用++i，导致第二个i疯狂增长
        return;
    }
};
</code></pre>
<p>然后来看一下网友题解：<br>
思路：</p>
<blockquote>
<p>很多人写出的代码都不符合 1,2 这个测试用例，是因为没搞清楚题意<br>
题目中说明:叶子节点是指没有子节点的节点，这句话的意思是 1 不是叶子节点<br>
题目问的是到叶子节点的最短距离，所以所有返回结果为 1 当然不是这个结果<br>
另外这道题的关键是搞清楚递归结束条件<br>
叶子节点的定义是左孩子和右孩子都为 null 时叫做叶子节点<br>
当 root 节点左右孩子都为空时，返回 1<br>
当 root 节点左右孩子有一个为空时，返回不为空的孩子节点的深度<br>
当 root 节点左右孩子都不为空时，返回左右孩子较小深度的节点值<br>
第一版代码:</p>
</blockquote>
<pre><code>class Solution {
public int minDepth(TreeNode root) {
if(root == null) return 0;
//这道题递归条件里分为三种情况
//1.左孩子和有孩子都为空的情况，说明到达了叶子节点，直接返回1即可
if(root.left == null &amp;&amp; root.right == null) return 1;
//2.如果左孩子和由孩子其中一个为空，那么需要返回比较大的那个孩子的深度        
int m1 = minDepth(root.left);
int m2 = minDepth(root.right);
//这里其中一个节点为空，说明m1和m2有一个必然为0，所以可以返回m1 + m2 + 1;
if(root.left == null || root.right == null) return m1 + m2 + 1;

//3.最后一种情况，也就是左右孩子都不为空，返回最小深度+1即可
return Math.min(m1,m2) + 1; 
}
}
</code></pre>
<blockquote>
<p>代码可以进行简化，当左右孩子为空时 m1 和 m2都为 0<br>
可以和情况 2 进行合并，即返回 m1+m2+1<br>
简化后代码如下:</p>
</blockquote>
<pre><code>class Solution {
    public int minDepth(TreeNode root) {
        if(root == null) return 0;
        int m1 = minDepth(root.left);
        int m2 = minDepth(root.right);
        //1.如果左孩子和右孩子有为空的情况，直接返回m1+m2+1
        //2.如果都不为空，返回较小深度+1
        return root.left == null || root.right == null ? m1 + m2 + 1 : Math.min(m1,m2) + 1;
    }
}
</code></pre>
<p>666呀比起我的代码简化了许多，我是一直累计下去，而他是利用递归从尾部到根结点不断地累计。</p>
<p>然后来看一下官方题解：</p>
<blockquote>
<p>方法 1：递归<br>
算法<br>
最直接的思路就是递归。<br>
我们用深度优先搜索来解决这个问题。</p>
</blockquote>
<pre><code>class Solution {
  public int minDepth(TreeNode root) {
    if (root == null) {
      return 0;
    }

    if ((root.left == null) &amp;&amp; (root.right == null)) {
      return 1;
    }

    int min_depth = Integer.MAX_VALUE;
    if (root.left != null) {
      min_depth = Math.min(minDepth(root.left), min_depth);
    }
    if (root.right != null) {
      min_depth = Math.min(minDepth(root.right), min_depth);
    }

    return min_depth + 1;
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：我们访问每个节点一次，时间复杂度为O(N) ，其中 NN 是节点个数。<br>
空间复杂度：最坏情况下，整棵树是非平衡的，例如每个节点都只有一个孩子，递归会调用 N （树的高度）次，因此栈的空间开销是O(N) 。但在最好情况下，树是完全平衡的，高度只有 log(N)，因此在这种情况下空间复杂度只有 O(log(N)) 。</p>
</blockquote>
<blockquote>
<p>方法 2：深度优先搜索迭代<br>
我们可以利用栈将上述解法中的递归变成迭代。<br>
想法是对于每个节点，按照深度优先搜索的策略访问，同时在访问到叶子节点时更新最小深度。<br>
我们从一个包含根节点的栈开始，当前深度为 1 。<br>
然后开始迭代：弹出当前栈顶元素，将它的孩子节点压入栈中。当遇到叶子节点时更新最小深度。</p>
</blockquote>
<pre><code>import javafx.util.Pair;
class Solution {
  public int minDepth(TreeNode root) {
    LinkedList&lt;Pair&lt;TreeNode, Integer&gt;&gt; stack = new LinkedList&lt;&gt;();
    if (root == null) {
      return 0;
    }
    else {
      stack.add(new Pair(root, 1));
    }

    int min_depth = Integer.MAX_VALUE;
    while (!stack.isEmpty()) {
      Pair&lt;TreeNode, Integer&gt; current = stack.pollLast();
      root = current.getKey();
      int current_depth = current.getValue();
      if ((root.left == null) &amp;&amp; (root.right == null)) {
        min_depth = Math.min(min_depth, current_depth);
      }
      if (root.left != null) {
        stack.add(new Pair(root.left, current_depth + 1));
      }
      if (root.right != null) {
        stack.add(new Pair(root.right, current_depth + 1));
      }
    }
    return min_depth;
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：每个节点恰好被访问一遍，复杂度为 O(N)。<br>
空间复杂度：最坏情况下我们会在栈中保存整棵树，此时空间复杂度为 O(N)。</p>
</blockquote>
<blockquote>
<p>方法 3：宽度优先搜索迭代<br>
深度优先搜索方法的缺陷是所有节点都必须访问到，以保证能够找到最小深度。因此复杂度是 O(N)。<br>
一个优化的方法是利用宽度优先搜索，我们按照树的层次去迭代，第一个访问到的叶子就是最小深度的节点，这样就不要遍历所有的节点了。</p>
</blockquote>
<pre><code>import javafx.util.Pair;
class Solution {
  public int minDepth(TreeNode root) {
    LinkedList&lt;Pair&lt;TreeNode, Integer&gt;&gt; stack = new LinkedList&lt;&gt;();
    if (root == null) {
      return 0;
    }
    else {
      stack.add(new Pair(root, 1));
    }

    int current_depth = 0;
    while (!stack.isEmpty()) {
      Pair&lt;TreeNode, Integer&gt; current = stack.poll();
      root = current.getKey();
      current_depth = current.getValue();
      if ((root.left == null) &amp;&amp; (root.right == null)) {
        break;
      }
      if (root.left != null) {
        stack.add(new Pair(root.left, current_depth + 1));
      }
      if (root.right != null) {
        stack.add(new Pair(root.right, current_depth + 1));
      }
    }
    return current_depth;
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：最坏情况下，这是一棵平衡树，我们需要按照树的层次一层一层的访问完所有节点，除去最后一层的节点。这样访问了 N/2 个节点，因此复杂度是 O(N)。<br>
空间复杂度：和时间复杂度相同，也是 O(N)。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于虚函数和纯虚函数]]></title>
        <id>https://lixin-ee.github.io//post/guan-yu-xu-han-shu-he-chun-xu-han-shu</id>
        <link href="https://lixin-ee.github.io//post/guan-yu-xu-han-shu-he-chun-xu-han-shu">
        </link>
        <updated>2019-11-15T08:16:03.000Z</updated>
        <content type="html"><![CDATA[<p>今天在做15.8的题的时候产生了一点疑问，如果隔代继承的话如果我不去覆盖虚函数会怎么样？还是使用基类的虚函数吗<br>
首先来看一下虚函数的定义</p>
<blockquote>
<p>对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成虚函数 (virtualfunction)</p>
</blockquote>
<p>但是同时</p>
<blockquote>
<p>如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接维承其在基类中的版本<br>
当我们在派生类中覆盖了某个虚函数时，可以再一次使用virtual 关键字指出该函数的性质。然而这么做并非必须，因为一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数。</p>
</blockquote>
<p>所以虚函数的覆盖定义仅仅是一种“希望”，最终的决定权还是在派生类上，不覆盖的话还是继续原封不动继承。而且覆盖的时候就算不加上virtual，都会继续有虚函数这个性质，所以后面的派生类照样可以选择覆盖或者不覆盖</p>
<p>而对于纯虚函数：</p>
<blockquote>
<p>可以将 net_price 定义成纯虚 (pure virtual )函数从而令程序实现我们的设计意图，这样做可以清晰明了地告诉用户当前这个 net_price 函数是没有实际意义的。<br>
含有（或者未经覆盖直接继承）纯虚函数的类是抽象基类 （abstractbaseclass )。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。我们不能（直接）创建一个抽象基类的对象。<br>
Disc_quote的派生类必须给出自己的net _ price定义，否则它们仍将是抽象基类</p>
</blockquote>
<p>所以纯虚函数是必须覆盖的。</p>
<p>所以一开始的问题的答案当然是肯定的<br>
测试代码如下：</p>
<pre><code>class B {
public:
	virtual void fcn1() { cout &lt;&lt; &quot;B-fcn1&quot; &lt;&lt; endl; };
	virtual void fcn2() { cout &lt;&lt; &quot;B-fcn1&quot; &lt;&lt; endl; };
};

class D1 :public B {
public:
	void fcn1() { cout &lt;&lt; &quot;D1-fcn1&quot; &lt;&lt; endl; }
};

class D2 :public D1 {
public:
	void fcn2() { cout &lt;&lt; &quot;D2-fcn2&quot; &lt;&lt; endl; }
};

int main()
{
	B b;
	D1 d1;
	D2 d2;
	b.fcn1();
	b.fcn2();
	d1.fcn1();
	d1.fcn2();
	d2.fcn1();
	d2.fcn2();
}
</code></pre>
<p>得到的答案如预料之中<br>
<img src="https://lixin-ee.github.io//post-images/1573806400737.png" alt=""></p>
<p>然后来测试一下纯虚函数</p>
<pre><code>class B {
public:
	virtual void fcn1() { cout &lt;&lt; &quot;B-fcn1&quot; &lt;&lt; endl; };
	virtual void fcn2() { cout &lt;&lt; &quot;B-fcn2&quot; &lt;&lt; endl; };
};

class V :public B{
public:
	virtual void fcn1() =0;
	virtual void fcn2() =0;
};

class D1 :public V {
public:
	void fcn1() { cout &lt;&lt; &quot;D1-fcn1&quot; &lt;&lt; endl; }
	void fcn2() { cout &lt;&lt; &quot;D1-fcn2&quot; &lt;&lt; endl; }
};

class D2 :public D1 {
public:
	void fcn1() { cout &lt;&lt; &quot;D2-fcn1&quot; &lt;&lt; endl; }
};

int main()
{
	B b;
	D1 d1;
	D2 d2;
	b.fcn1();
	b.fcn2();
	d1.fcn1();
	d1.fcn2();
	d2.fcn1();
	d2.fcn2();
}
</code></pre>
<p>结果如下：<br>
<img src="https://lixin-ee.github.io//post-images/1573806696185.png" alt=""></p>
<p>可以得出的结论有<br>
1.V中的纯虚函数=0直接覆盖了B中的定义，如果D1中不覆盖直接继承纯虚函数会被视为抽象基类，而覆盖后仍然保持虚函数性质，同时对于D2来说就是两个普通的虚函数了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 129. 求根到叶子节点数字之和[中等]]]></title>
        <id>https://lixin-ee.github.io//post/shu-129-qiu-gen-dao-xie-zi-jie-dian-shu-zi-zhi-he-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/shu-129-qiu-gen-dao-xie-zi-jie-dian-shu-zi-zhi-he-zhong-deng">
        </link>
        <updated>2019-11-15T01:37:13.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。<br>
例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。<br>
计算从根到叶子节点生成的所有数字之和。<br>
说明: 叶子节点是指没有子节点的节点。</p>
<p>示例 1:<br>
输入: [1,2,3]<br>
1<br>
/ <br>
2   3<br>
输出: 25<br>
解释:<br>
从根到叶子节点路径 1-&gt;2 代表数字 12.<br>
从根到叶子节点路径 1-&gt;3 代表数字 13.<br>
因此，数字总和 = 12 + 13 = 25.<br>
示例 2:<br>
输入: [4,9,0,5,1]<br>
4<br>
/ <br>
9   0<br>
 / <br>
5   1<br>
输出: 1026<br>
解释:<br>
从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495.<br>
从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491.<br>
从根到叶子节点路径 4-&gt;0 代表数字 40.<br>
因此，数字总和 = 495 + 491 + 40 = 1026.</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/sum-root-to-leaf-numbers<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题和之前的差别不大，主要是传递值并且传递一个vector引用进行存储</p>
<pre><code>class Solution {
public:
    int sumNumbers(TreeNode* root) {
        vector&lt;int&gt; vi;
        int res=0;
        preorder(root,res,vi);
        for(auto i:vi)
            res+=i;
        return res;
    }
    
    void preorder(TreeNode* cur,int res,vector&lt;int&gt; &amp;vi){
        if(cur==NULL)
            return;
        res=res*10+cur-&gt;val;
        if(cur-&gt;left==NULL&amp;&amp;cur-&gt;right==NULL){
            vi.push_back(res);
            return;
        }
        preorder(cur-&gt;left,res,vi);
        preorder(cur-&gt;right,res,vi);
        return;
    }
};
</code></pre>
<p>看下网友题解</p>
<blockquote>
<p>思路一:<br>
二叉树的题目我们首先想到的就是递归求解。递归的方式很简单，用先序遍历的变形。<br>
先遍历根节点；<br>
遍历左子树，遍历左子树的时候，把走当前路径的数字带到左子树的求解中；<br>
遍历右子树，遍历右子树的时候，把走当前路径的数字带到右子树的求解中；<br>
更新总的和。<br>
代码一:</p>
</blockquote>
<pre><code>Java
class Solution {
    private int sum = 0;
    private void helper(TreeNode node, int father) {
        if (node == null) return ;
        int current = father * 10 + node.val;
        if (node.left == null &amp;&amp; node.right == null) {
            sum += current;
            return;
        }
        helper(node.left, current);
        helper(node.right, current);
    }

    public int sumNumbers(TreeNode root) {
        if (root == null) return sum;
        helper(root, 0);
        return sum;
    }
}
</code></pre>
<blockquote>
<p>思路二:<br>
通常还可以用 stack 的思路来解递归的题目。先序非递归的代码我们知道是用 stack 来保存遍历过的元素。而因为本题要记录到叶节点的数字，所以需要一个额外的 stack 来记录数字。每次出 stack 之后，如果是叶子节点，那么加和；如果不是，那么就看左右子树，入 stack。<br>
代码二:</p>
</blockquote>
<pre><code>Java
class Solution {
    public int sumNumbers(TreeNode root) {
        int sum = 0;
        if (root == null) return sum;
        Stack&lt;TreeNode&gt; nodeStack = new Stack&lt;&gt;();
        Stack&lt;Integer&gt; numStack = new Stack&lt;&gt;();
        nodeStack.add(root);
        numStack.add(0);
        while (!nodeStack.isEmpty()) {
            TreeNode current = nodeStack.pop();
            Integer currentNum = numStack.pop() * 10 + current.val;
            if (current.left == null &amp;&amp; current.right == null) {
                sum += currentNum;
            }
            if (current.left != null) {
                nodeStack.add(current.left);
                numStack.add(currentNum);
            }
            if (current.right != null) {
                nodeStack.add(current.right);
                numStack.add(currentNum);
            }
        } 
        return sum;
    }
}
</code></pre>
<blockquote>
<p>思路三:<br>
其实，我们可以看到，最关键的是找到叶子节点，然后加和这个操作。叶子节点我们同样可以用层序遍历的方式来解这道题目。层序遍历用队列来解。<br>
代码三:</p>
</blockquote>
<pre><code>Java
public class Solution {
    public int sumNumbers(TreeNode root) {
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();
        Queue&lt;Integer&gt; numQueue = new LinkedList&lt;Integer&gt;();
        if(root == null) return 0;
        int res = 0;
        queue.add(root);
        numQueue.add(0);
        while(!queue.isEmpty()) {
            int size = queue.size();
            // 把该层的都入队，同时如果遇到叶节点，计算更新
            while(size-- &gt; 0) {
                root = queue.poll();
                int val = numQueue.poll() * 10 + root.val;
                if(root.left == null &amp;&amp; root.right == null)
                    res += val;
                if(root.left != null) {
                    queue.add(root.left);
                    numQueue.add(val);
                }
                if (root.right != null) {
                    queue.add(root.right);
                    numQueue.add(val);
                }
            }
        }
        return res;
    }
}
</code></pre>
<blockquote>
<p>总结，二叉树的题目，大多数都是遍历的变形，面试时候看用 bfs，还是 dfs，一般来说很快就能得出答案。写非递归代码的时候，注意判断一下非空，不要把 null 节点入队或者入栈。</p>
</blockquote>
<p>看了一下第一个递归的解答，发现用全局sum确实方便很多，毕竟也没要求返回每个值，用vector有点大材小用了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[error C4430: 缺少类型说明符 - 假定为 int。注意: C++ 不支持默认 int]]></title>
        <id>https://lixin-ee.github.io//post/error-c4430-que-shao-lei-xing-shuo-ming-fu-jia-ding-wei-int-zhu-yi-c-bu-zhi-chi-mo-ren-int</id>
        <link href="https://lixin-ee.github.io//post/error-c4430-que-shao-lei-xing-shuo-ming-fu-jia-ding-wei-int-zhu-yi-c-bu-zhi-chi-mo-ren-int">
        </link>
        <updated>2019-11-14T12:48:25.000Z</updated>
        <content type="html"><![CDATA[<p>这个错误是在编写类的时候出现的，主要问题在于类的实用出现在了声明和定义前面。最严重的程度就是两个类互相包含，或者两个头文件相互包含了（想起经典表情包hhh，-我要引用头文件2！-那你得先完成头文件1！！-我得引用头文件2才能完成头文件1！！！-那你先完成头文件1才能引用头文件2啊！！！！）<br>
主要原因还是c++不允许使用不完全类型，除了指针引用和参数类型返回类型<br>
原笔记：<br>
类可以先声明再定义，先声明未定义的时候称为前向声明，此时是一个不完全类型，只能用于1.定义指向这种类型的指针或者引用2.声明（不能定义）以不完全类型作为参数或者返回类型的函数</p>
<p>解决方法就是调整定义的位置或者增加声明。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Chrome下如何复制禁止复制网页上的文字]]></title>
        <id>https://lixin-ee.github.io//post/chrome-xia-ru-he-fu-zhi-jin-zhi-fu-zhi-wang-ye-shang-de-wen-zi</id>
        <link href="https://lixin-ee.github.io//post/chrome-xia-ru-he-fu-zhi-jin-zhi-fu-zhi-wang-ye-shang-de-wen-zi">
        </link>
        <updated>2019-11-14T12:42:42.000Z</updated>
        <content type="html"><![CDATA[<p>今天贴个和工作不太相关但是异常好用的东西<br>
起因是党支部最近很多写感想的操作，然后我发现网上真的因此衍生了一大堆 如何写相关感想 的网站hhh，当然天底下没有免费的午餐，现在都逐渐开始收费了。但是这些写手的质量实在堪忧啊，如果是高质量模板付费还好说，这种质量我觉得只适合Ctrl+CV了<br>
不多废话了，下面是方法</p>
<p>上网或工作的时候，看到一些文章大家可能想复制或是收藏起来，但是当你要复制的时候却发现,根本复制不了,被网站做复制限制了，右键也给禁了。这可怎么办呢?正所谓，万物皆可破，在这里给大家介绍一个简单的方法，因为本人用的是Chrome浏览器，所以在此介绍下Chrome下如何复制的方法。</p>
<p>1,在你要复制文字的页面，按F12，选择“ Console” 输入：document.body.innerText 然后按回车</p>
<p>2，红色矩形框中的文字就是你所获得的文字了。然后你就可以任意复制你需要的文字了。</p>
<p>非常简单 但是非常实用hhh</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ C++ primer 第十五章 笔记+习题 15.6-15.9]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-wu-zhang-bi-ji-xi-ti-156-159</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-wu-zhang-bi-ji-xi-ti-156-159">
        </link>
        <updated>2019-11-14T07:16:42.000Z</updated>
        <content type="html"><![CDATA[<p>15.6继承中的类作用域<br>
<strong>每个类定义</strong>自己的<strong>作用域</strong>（参见7.4节，第253页），在这个<strong>作用域内</strong>我们<strong>定义类的成员</strong>。<br>
当存在继承关系时，<strong>派生类</strong>的作用域<strong>嵌套</strong>（参见2.2.4节，第43页）在其<strong>基类</strong>的<strong>作用域之内</strong>。如果一个名字在派生类的作用域内无法正确解析，则编译器将<strong>继续</strong>在<strong>外层的基类作用域中寻找</strong>该名字的定义。</p>
<p>一个<strong>对象、引用或指针</strong>的<strong>静态类型</strong>（参见15.2.3节，第532页）<strong>决定</strong>了该对象的<strong>哪些成员是可见的</strong>。即使静态类型与动态类型可能<strong>不一致</strong>（当使用基类的引用或指针时会发生这种情况），但是我们<strong>能使用哪些成员</strong>仍然是由<strong>静态类型决定</strong>的。</p>
<p>quote不能用，disc_quote继承自quote</p>
<p>和其他作用域一样，派生类也能重用定义在其直接基类或间接基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字（参见2.2.4节，第43页）； //变量（手写的笔记）<br>
<strong>派生类的成员将隐藏同名的基类成员</strong>我们通过<strong>作用域运算符</strong>来使用一个<strong>被隐藏</strong>的基类成员;</p>
<p>除了覆盖继承而来的虚函数之外，派生类<strong>最好不要重用</strong>其他定义在基类中的名字。</p>
<p><strong>声明在内层作用域</strong>的函数并<strong>不会重载声明在外层作用域的函数</strong>（参化6.4.1节，第210页）。因此，定义<strong>派生类中的函数</strong>也<strong>不会重载</strong>其<strong>基类中的成员</strong>。<strong>（直接被隐藏掉）</strong><br>
如果派生类（即内层作用域）的成员与基类（即外层作用域）的某个成员同名，则<strong>派生类</strong>将在其作用域内<strong>隐藏该基类成员</strong>。<strong>即使</strong>派生类成员和基类成员的<strong>形参列表不一致</strong>，基类成员<strong>也仍然会被隐藏掉</strong>。</p>
<p>我们现在可以理解为什么基类与派生类中的<strong>虚函数必须有相同的形参列表</strong>了（参见15.3节，第537页）。<strong>假如</strong>基类与派生类的虚函数接受的<strong>实参不同</strong>.则我们就<strong>无法通过基类的引用或指针调用派生类的虚函数</strong>了。</p>
<p>因为 Base 类中没有 f 2（），所以第一条语句是非法的，即使当前的指针碰巧指向了一个派生类对象也无济于事。</p>
<p>在上面的每条调用语句中，指针都指向了D2类型的对象，但是由于我们调用的是<strong>非虚函数</strong>，所以<strong>不会发生动态绑定</strong>。实际调用的函数版本<strong>由指针的静态类型决定</strong>。</p>
<p>和其他函数一样，成员函数<strong>无论是否是虚函数都能被重载</strong>。派生类可以覆盖重载函数的0个或多个实例。如果派生类希望基类所有的重载版本对于它来说<strong>都是可见的</strong>，那么它就需要<strong>覆盖所有的版本，或者一个也不覆盖</strong>。<br>
一种好的解决方案是为<strong>重载的成员</strong>提供一条 <strong>using 声明语句</strong>（参见15.5节，第546页），这样我们就<strong>无须覆盖基类</strong>中的<strong>每一个重载版本</strong>了。 using Base::fcn;<br>
using 声明语句<strong>指定一个名字</strong>而<strong>不指定形参列表</strong>，所以—条基类成员函数的 using 声明语句就可以把该函数的<strong>所有重载实例</strong>添加到<strong>派生类作用域</strong>中。此时，派生类只需要定义其特有的函数就可以了，而<strong>无须为继承而来的其他函数重新定义</strong>。<br>
类内 using 声明的一般规则<strong>同样适用于重载函数的名字</strong>（参见15.5节，第546页）；基类函数的<strong>每个实例</strong>在派生类中都必须是<strong>可访问的</strong>。对派生类没有重新定义的重载版本的访问实际上是对 Using 声明点的访问。</p>
<p>习题15.23<br>
如果想要覆盖继承而来的虚函数，需要使形参数目一致或者使用using声明语句</p>
<p>15.7 构造函数与拷贝控制<br>
15.7.1 虚析构函数<br>
<strong>继承关系</strong>对<strong>基类拷贝控制</strong>最直接的影响是<strong>基类</strong>通常应该定义一个<strong>虚析构函数</strong>，样可以确保delete基类指针时将运行正确的虚构函数版本(动态绑定虚析构函数)<br>
当我们<strong>delete</strong> 一个<strong>动态分配的对象的指针</strong>时将执行析构函数(参化13.1.3节，第445页）。如果该指针指向<strong>继承体系中的某个类型</strong>，则有可能出现<strong>指针的静态类型</strong>与<strong>被删除对象的动态类型不符</strong>的情况（参见15.2.2节，第530页）。<br>
如果基类的<strong>析构函数不是虚函数</strong>，则 <strong>delete—个指向派生类对象的基类指针</strong>将产生未定义的行为。<br>
之前我们曾介绍过一条经验准则，即如果一个类需要析构函数，那么它也同样需要拷贝和赋值操作（参见13.1.4节，第447页）。<strong>基类的析构函数并不遵循上述准则</strong>，它是一个重要的例外。一个<strong>基类总是需要析构函数</strong>，而且它<strong>能将析构函数设定为虚函数</strong>。此时，该析构函数为了成为虚函数而<strong>令内容为空</strong>，我们显然无法由此推断该基类还需要赋值运算或拷贝构造函数。</p>
<p><strong>如果一个类定义了析构函数</strong>，即使它通过= default 的形式使用了合成的版本，<strong>编译器</strong>也<strong>不会为这个类合成移动操作</strong></p>
<p>习题15.24<br>
基类都需要虚析构函数，虚析构函数的函数体为空，需要动态销毁对象，这样可以确保delete基类指针时将运行正确的虚构函数版本(动态绑定虚析构函数)</p>
<p>15.7.2 合成拷贝控制与继承<br>
基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似：它们对类本身的成员依次进行初始化、赋值或销毁的操作。此外，这些合成的成员还<strong>负责使用直接基类中对应的操作</strong>对一个对象的<strong>直接基类部分</strong>进行初始化、赋值或销毁的操作：<br>
•合成的 Bulk _ quote 默认构造函数运行 Disc _ quote 的默认构造函数，后者又运<br>
行 Quote 的默认构造函数。<br>
•  Quote 的默认构造函数将 bookNo 成员默认初始化为空字符串，同时使用类内初始值将 price 初始化为0。<br>
•  Quote 的构造函数完成后，继续执行 Disc _ quote 的构造函数，它使用类内初始值初始化 qty 和 discount 。<br>
•  Disc _ quote 的构造函数完成后，继续执行 Bulk _ quote 的构造函数，但是它什么具体工作也不做。</p>
<p>值得注意的是，无论基类成员是合成的版本（如 Quote 继承体系的例子）还是自定义的版本都没有太大影响。<strong>唯一的要求</strong>是<strong>相应的成员应该可访问</strong>（参见15.5节，第542页）并且不是一个被删除的函数。<br>
<strong>派生类的析构函数</strong>来说，它除了销毁派生类自己的成员外，<strong>还负责销毁</strong>派生类的<strong>直接基类</strong>；该直接基类又销毁它自己的直接基类，<strong>以此类推直至继承链的顶端</strong>。<br>
如前所述， Quote因为定义了析构函数而不能拥有合成的移动操作，因此当我们<strong>移动 Quote对象</strong>时实际使用的是<strong>合成的拷贝操作</strong>（参见13.6.2节，第477页）。如我们即将看到的那样， <strong>Quote没有移动操作</strong>意味着它的<strong>派生类也没有</strong>。</p>
<p>基类或派生类也能出于同样的原因将其合成的默认构造函数或者任何一个拷贝控制成员<strong>定义成被删除的函数</strong><br>
•如果<strong>基类中的</strong>默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是<strong>被删除的函数或者不可访问</strong>（参见15.5节，第543页），则<strong>派生类中对应的成员将是被删除的</strong>，原因是编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值或销毁操作。<br>
•如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分。<br>
•和过去一样，编译器将不会合成一个删除掉的移动操作。当我们使用 =default请求一个移动操作时，如果基类中的对应操作是删除的或不可访问的，那么派生类中该函数将是被删除的，原因是派生类对象的基类部分不可移动。同样，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是被删除的。</p>
<p>在实际编程过程中，如果<strong>在基类中没有</strong>默认、拷贝或移动构造函数，则一般情况下<strong>派生类也不会定义相应的操作</strong>。</p>
<p>默认情况下，基类通常不含有<strong>合成</strong>的移动操作，而且在它的派生类中也没有合成的移动操作。<br>
因为<strong>基类缺少</strong>移动操作<strong>会阻止派生类拥有</strong>自己的合成移动操作，所以当我们确实需要执行移动操作时<strong>应该首先在基类中进行定义</strong>。</p>
<p><strong>一旦基类定义了移动操作，则它也必须同时显式定义拷贝操作。基类中定义了移动操作后派生类将会自动获得合成的移动操作</strong></p>
<p>习题15.25<br>
因为Bulk_quote的构造函数需要调用Disc_quote的构造函数，如果没有的话，Bulk_quote的构造函数会被定义为删除的</p>
<p>15.7.3 派生类的拷贝控制成员<br>
派生类的<strong>拷贝和移动构造函数</strong>在拷贝和移动自有成员的同时，也要<strong>拷贝和移动基类部分的成员</strong>。类似的，<strong>派生类赋值运算符</strong>也必须为其<strong>基类部分的成员赋值</strong>。<br>
当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。</p>
<p>在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝（或移动）基类部分，则必须在派生类的构造函数初始值列表中<strong>显式地使用基类的拷贝（或移动）构造函数</strong>。</p>
<p>与拷贝和移动构造函数一样，<strong>派生类的赋值运算符</strong>（参见13.1.2节，第443页和13.6.2节，第474页）也必须<strong>显式地为其基类部分赋值</strong>：</p>
<p>派生类<strong>析构函数只负责销毁</strong>由派生类<strong>自己分配的资源，基类析构函数会被自动调用执行</strong>：</p>
<p>对象<strong>销毁的顺序正好与其创建的顺序相反</strong>：派生类析构函数首先执行，然后是基类的析构函数，以此类推，沿着继承体系的反方向直至最后。</p>
<p>当我们构建一个对象时，需要把<strong>对象的类和构造函数的类看作是同一个</strong>；<strong>对虚函数的调用绑定正好符合</strong>这种把对象的类和构造函数的类看成同一个的要求；<strong>对于析构函数也是同样的道理</strong>。<br>
如果构造函数或析构函数<strong>调用了某个虚函数</strong>，则我们应该执行与构造函数或析构函数<strong>所属类型相对应的虚函数版本</strong>。</p>
<p>习题15.26</p>
<pre><code>class Quote {
public:
	Quote() = default;
	Quote(const string &amp;book,double sales_price):bookNo(book),price(sales_price){}
	string isbn() const { return bookNo;}
	virtual double net_price(size_t n)const { return n*price; }
	virtual ~Quote()=default;
	virtual void Debug();
	Quote(const Quote&amp;) = default;
	Quote(Quote&amp;&amp;) = default;
	Quote&amp; operator=(const Quote&amp;) = default;
	Quote&amp; operator=(Quote&amp;&amp;) = default;
private:
	string bookNo;
protected:
	double price = 0.0;
};

class Disc_quote :public Quote {
public:
	Disc_quote() = default;
	Disc_quote(const string &amp;book, double price, size_t qty, double disc) :Quote(book, price), quantity(qty), discount(disc) {};
	double net_price(size_t)const = 0;
	Disc_quote(const Disc_quote&amp;);
	Disc_quote(Disc_quote&amp;&amp;);
	Disc_quote&amp; operator=(const Disc_quote&amp;);
	Disc_quote&amp; operator=(Disc_quote&amp;&amp;);
	virtual ~Disc_quote() = default;
protected:
	size_t quantity = 0;
	double discount = 0.0;
};

Disc_quote::Disc_quote(const Disc_quote &amp;disc):Quote(disc),quantity(disc.quantity),discount(disc.discount) {
	cout &lt;&lt; &quot;This is disc's copy construct&quot; &lt;&lt; endl;
}

Disc_quote::Disc_quote(Disc_quote &amp;&amp;disc) : Quote(disc), quantity(disc.quantity), discount(disc.discount) {
	cout &lt;&lt; &quot;This is disc's move construct&quot; &lt;&lt; endl;
}

Disc_quote&amp; Disc_quote::operator=(const Disc_quote&amp; disc) {
	Quote::operator=(disc);
	quantity = disc.quantity;
	discount = disc.discount;
	cout &lt;&lt; &quot;This is disc's copy operator=&quot; &lt;&lt; endl;
	return *this;
}

Disc_quote&amp; Disc_quote::operator=(Disc_quote&amp;&amp; disc) {
	if (&amp;disc != this) {
		Quote::operator=(disc);
		quantity = disc.quantity;
		discount = disc.discount;
	}
	cout &lt;&lt; &quot;This is disc's move operator=&quot; &lt;&lt; endl;
	return *this;
}

class Bulk_quote :public Disc_quote {
public:
	Bulk_quote() = default;
	Bulk_quote(const string &amp;book, double price, size_t qty, double disc) :Disc_quote(book, price, qty, disc) {};
	double net_price(size_t)const override;
	void Debug();
	Bulk_quote(const Bulk_quote &amp;bulk) :Disc_quote(bulk) { cout &lt;&lt; &quot;This is disc's copy construct&quot; &lt;&lt; endl; };
	Bulk_quote(Bulk_quote &amp;&amp;bulk) :Disc_quote(bulk) { cout &lt;&lt; &quot;This is disc's move construct&quot; &lt;&lt; endl; };
	Bulk_quote&amp; operator=(const Bulk_quote &amp;bulk) { Disc_quote::operator=(bulk); cout &lt;&lt; &quot;This is disc's copy operator=&quot; &lt;&lt; endl; return *this; };
	Bulk_quote&amp; operator=(Bulk_quote &amp;&amp;bulk) { Disc_quote::operator=(bulk); cout &lt;&lt; &quot;This is disc's move operator=&quot; &lt;&lt; endl; return *this; };
	virtual ~Bulk_quote() = default;
};
</code></pre>
<p>注意：移动构造函数那一堆我还是蛮不确定的！</p>
<p>15.7.4继承的构造函数<br>
在 C ++11新标准中，派生类能够<strong>重用</strong>其<strong>直接基类定义的构造函数</strong>。<br>
一个类<strong>只初始化</strong>它的直接基类，出于同样的原因，一个类<strong>也只继承</strong>其直接基类的构造函数。<strong>类不能继承默认、拷贝和移动构造函数</strong>。<strong>如果派生类没有直接定义</strong>这些构造函数，则<strong>编译器</strong>将为派生类<strong>合成</strong>它们。<br>
派生类<strong>继承基类构造函数</strong>的方式是提供一条<strong>注明了（直接）基类名的 using 声明语句</strong>。</p>
<p><strong>通常情况下using 声明语句只是令某个名字在当前作用域内可见</strong>。而<strong>当作用于构造函数时， using 声明语句将令编译器产生代码</strong>。对于基类的<strong>毎个构造函数</strong>，编译器都<strong>生成一个与之对应的派生类构造函数</strong>。<br>
这些编译器生成的构造函数形如：<br>
derivec (parms) : base (args)  { }<br>
其中，derived是派生类的名字，base是基类的名字，parms是构造函数的形参列表，args将<strong>派生类构造函数的形参传递给基类的构造函数</strong>。<br>
<strong>如果派生类含有自己的数据成员，则这些成员将被默认初始化</strong><br>
和普通成员的 using 声明不一样，一个构造函数的 using 声明<strong>不会改变该构造函数的访问级别</strong>。<br>
一个 <strong>using 声明</strong>语句<strong>不能指定 explicit 或 constexpr</strong> 。如果<strong>基类的构造函数是 explicit</strong> (参见7.5.4节，第265页）<strong>或者 constexpr</strong>(参见7.5.6节，第267页），则<strong>继承的构造函数也拥有相同的属性</strong>。<br>
当一个基类构造函数含有<strong>默认实参</strong>（参见6.5.1节，第211页）时.这些实参<strong>并不会被继承</strong>。相反，<strong>派生类</strong>将获得<strong>多个继承的构造函数</strong>，<strong>其中每个构造函数分别省略掉一个含有默认实参的形参。</strong><br>
例如，如果基类有一个接受两个形参的构造函数.其中第二个形参含有默认实参，则派生类将获得两个构造函数：一个构造函数接受两个形参（没有默认实参），另一个构造函数只接受一个形参，它对应于基类中最左侧的没有默认值的那个形参。<br>
第一个例外是<strong>派生类</strong>可以<strong>继承一部分构造函数</strong>，而<strong>为其他构造函数定义自己的版本</strong>。如果派生类定义的构造函数与基类的构造函数<strong>具有相同的参数列表</strong>，则该构造函数<strong>将不会被继承</strong>。定义在派生类中的构造函数将替换继承而来的构造函数。<br>
第二个例外是默认、拷贝和移动构造函数不会被继承。这些构造函数按照正常规则<strong>被合成</strong>。<strong>继承的构造函数不会被作为用户定义的构造函数来使用</strong>，因此，如果一个类<strong>只含有继承的构造函数</strong>.则它也将拥有一个<strong>合成的默认构造函数</strong>。（不等同于自己定义的）</p>
<p>习题15.27</p>
<pre><code>class Bulk_quote :public Disc_quote {
public:
	//Bulk_quote() = default;
	//Bulk_quote(const string &amp;book, double price, size_t qty, double disc) :Disc_quote(book, price, qty, disc) {};
	using Disc_quote::Disc_quote;
｝
</code></pre>
<p>15.8 容器与继承<br>
当我们使用<strong>容器</strong>存放<strong>继承体系中的对象</strong>时，通常<strong>必须</strong>采取间接存储的方式。因为不允许在容器中保存<strong>不同类型</strong>的元素，所以我们不能把<strong>具有继承关系的多种类型</strong>的对象直接存放在容器当中</p>
<p>当派生类对象被赋值给基类对象时，其中的<strong>派生类部分将被切掉</strong>，因此<strong>容器</strong>和<strong>存在继承关系的类型无法兼容</strong>。</p>
<p>当我们希望在容器中存放具有继承关系的对象时，我们实际上<strong>存放的</strong>通常是<strong>基类的指针</strong>（<strong>更好的选择是智能指针</strong>（参见12.1节，第400页））。和往常一样，这些<strong>指针所指对象</strong>的<strong>动态类型</strong>可能是基类类型，也可能是派生类类型</p>
<p>我们可将一个派生类的普通指针转换成基类指针一样（参见15.2.2节，第言30页），我们也能把一个<strong>派生类的智能指针</strong>转换成<strong>基类的智能指针</strong>。<br>
当我们调<strong>用 push _ back 时</strong>该对象<strong>被转换成shared _ ptr &lt; Quote &gt;</strong> 。因此尽管在形式上有所差别，但实际上 basket 的<strong>所有元素的类型都是相同</strong>的。</p>
<p>15.8.1编写basket类<br>
习题15.30</p>
<pre><code>class Basket {
public:
	void add_item(const shared_ptr&lt;Quote&gt; &amp;sale) { items.insert(sale); }
	void add_item(const Quote&amp; sale) { items.insert(shared_ptr&lt;Quote&gt;(sale.clone())); }
	void add_item(Quote&amp;&amp; sale) { items.insert(shared_ptr&lt;Quote&gt;(std::move(sale).clone())); }
	double total_receipt(ostream&amp;) const;
private:
	static bool compare(const shared_ptr&lt;Quote&gt; &amp;lhs, const shared_ptr&lt;Quote&gt; &amp;rhs) { return lhs-&gt;isbn() &lt; rhs-&gt;isbn(); }
	multiset&lt;shared_ptr&lt;Quote&gt;, decltype(compare)*&gt; items{ compare };
};

double Basket::total_receipt(ostream &amp;os) const {
	double sum = 0.0;
	for (auto iter = items.begin(); iter != items.end(); iter = items.upper_bound(*iter)) {
		sum += print_total(os, **iter, items.count(*iter));
		os &lt;&lt; &quot;Total Sale:&quot; &lt;&lt; sum &lt;&lt; endl;
		return sum;
	}
}
</code></pre>
<p>15.9 文本查询程序再探<br>
15.9.1面向对象的解决方案<br>
习题15.31<br>
（a） OrQuery AndQuery NotQuery WordQuery<br>
（b）OrQuery AndQuery NotQuery WordQuery<br>
（c）OrQuery AndQuery-2  WordQuery<br>
15.9.2Query_base和Query类<br>
习题15.32<br>
都是使用默认的拷贝操作和析构函数（只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符，）（编译器不会为某些类合成移动操作，特别是当一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符，反而类会通过正常的函数匹配从而使用对应的拷贝操作来代替移动操作）<br>
习题15.32<br>
由于没有数据成员，所以合成的拷贝控制足以应付所有问题（能够构造Query_base类型的对象么？不是抽象基类吗？）</p>
<p>15.9.3  派生类<br>
习题15.34<br>
（a）<br>
1: Query::Query(const std::string&amp; s) <br>
2: WordQuery::WordQuery(const std::string&amp; s) <br>
3: AndQuery::AndQuery(const Query&amp; left, const Query&amp; right);<br>
4: BinaryQuery(const Query&amp;l, const Query&amp; r, std::string s);<br>
5: Query::Query(std::shared_ptr&lt;Query_base&gt; query) 2times<br>
6: OrQuery::OrQuery(const Query&amp; left, const Query&amp; right);<br>
7: BinaryQuery(const Query&amp;l, const Query&amp; r, std::string s);<br>
8: Query::Query(std::shared_ptr&lt;Query_base&gt; query) 2times<br>
(b)：运算符&quot;&lt;&lt;&quot;会调用Query的rep成员，Query.rep()调用的是OrQuery的rep(因为初始化对象q时使用的是值是&quot;|&quot;运算符返回的Query，而该对象的智能指针q指向的是一个OrQuery对象)，而OrQuery并没有定义rep成员，所以直接使用直接基类BinaryQuery的rep成员</p>
<p>(c)：q调用的是OrQuery的eval函数，因为是虚函数，且使用引用调用，需动态绑定</p>
<p>习题15.35<br>
直接使用书中代码<br>
习题15.36<br>
习题15.37<br>
没看懂，网上的答案是 若要含有base类型的成员，应当在派生类中声明 friend class Query_base<br>
习题15.38<br>
(a)：错误，Binary_Query是抽象基类，不能实例化<br>
(B)：错误，不存在AndQuery到Query之间的转化<br>
(c)：同上</p>
<p>15.9.4 eval函数<br>
习题15.39<br>
加上书中的eval函数即可<br>
习题 15.40<br>
如果rhs是空集，那么内容到lhs<br>
如果lhs是空集，那么内容为rhs<br>
如果都为空集，那么内容为空<br>
习题15.41<br>
非智能指针，所有的new都需要进行手动delete.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 113. 路径总和 II[中等]]]></title>
        <id>https://lixin-ee.github.io//post/shu-113-lu-jing-zong-he-iizhong-deng</id>
        <link href="https://lixin-ee.github.io//post/shu-113-lu-jing-zong-he-iizhong-deng">
        </link>
        <updated>2019-11-14T01:54:30.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。<br>
说明: 叶子节点是指没有子节点的节点。<br>
示例:<br>
给定如下二叉树，以及目标和 sum = 22，<br>
5<br>
/ <br>
4   8<br>
/   / <br>
11  13  4<br>
/  \    / <br>
7    2  5   1<br>
返回:</p>
<p>[<br>
[5,4,11,2],<br>
[5,8,4,5]<br>
]<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/path-sum-ii<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题其实和之前的差不多，只是需要额外地增加一个vector记录路径<br>
然后主要的点为<br>
1.改进了sum，直接将sum进行自身递减，省去了一定一个res变量<br>
2.但是我没想好如何处理vector的问题，既需要一个全局的<code>vector&lt;vector&lt;int&gt;&gt;</code>，又需要一个<code>vector&lt;int&gt;</code>，导致内存使用量很高</p>
<p>最终代码如下：</p>
<pre><code>class Solution {
     vector&lt;vector&lt;int&gt;&gt; vvi;

public:
    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) {
        vector&lt;int&gt; vi;
        preorder(root,sum,vi);
        return vvi;
    }
     void preorder(TreeNode* root, int sum,vector&lt;int&gt; vi) {
        if(root==NULL)
            return;
        sum-=root-&gt;val;
        vi.push_back(root-&gt;val);
        if(root-&gt;left==NULL&amp;&amp;root-&gt;right==NULL&amp;&amp;!sum)
            vvi.push_back(vi);
        preorder(root-&gt;left,sum,vi);
        preorder(root-&gt;right,sum,vi);
        return ;
    }
};
</code></pre>
<p>然后来看一下网友题解：</p>
<pre><code>class Solution {
    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) {
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        helper(root, sum, res, new ArrayList&lt;Integer&gt;());
        return res;
    }

    private void helper(TreeNode root, int sum, List&lt;List&lt;Integer&gt;&gt; res, ArrayList&lt;Integer&gt; tmp) {
        if (root == null) return;
        tmp.add(root.val);
        if (root.left == null &amp;&amp; root.right == null &amp;&amp; sum - root.val == 0) res.add(new ArrayList&lt;&gt;(tmp));
        helper(root.left, sum - root.val, res, tmp);
        helper(root.right, sum - root.val, res, tmp);
        tmp.remove(tmp.size() - 1);
    }
}
</code></pre>
<p>感觉这个和我的差不多呀。。。。所以好像没什么特别好的方法能降低空间复杂度了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 112. 路径总和[简单]]]></title>
        <id>https://lixin-ee.github.io//post/shu-112-lu-jing-zong-he-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/shu-112-lu-jing-zong-he-jian-dan">
        </link>
        <updated>2019-11-13T02:32:08.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。<br>
说明: 叶子节点是指没有子节点的节点。<br>
示例: <br>
给定如下二叉树，以及目标和 sum = 22，</p>
<pre><code>          5
         / \
        4   8
       /   / \
      11  13  4
     /  \      \
    7    2      1
</code></pre>
<p>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/path-sum<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题的和前面的无差，主要的难点在于返回值的处理，回忆<a href="https://lixin-ee.github.io/post/shu-100-xiang-tong-de-shu-jian-dan/">100.相同的树</a>中的方法，完全可以把递归放到return语句中，从而不需要额外的变量来存储返回结果。<br>
然后这一题中注意返回结果的处理必须是或逻辑而不是与逻辑<br>
然后提交过程中发现的小问题是我一开始以为全部数都是正数所以提前判断是否大于sum结果测试用例有负数直接翻车了只能删掉提前判断没错我就是一口气说这么多不带标点符号hhh<br>
最终代码如下</p>
<pre><code>class Solution {
public:
    bool hasPathSum(TreeNode* root, int sum) {
        int res=0;
        return preorder(root,res,sum);
    }
    bool preorder(TreeNode* cur, int res,const int sum){
        if(cur==NULL)
            return false;
        res+=cur-&gt;val;
        if(cur-&gt;left==NULL&amp;&amp;cur-&gt;right==NULL&amp;&amp;res==sum)
            return true;
        return preorder(cur-&gt;left, res,sum)||preorder(cur-&gt;right,res,sum);
    }
    
};
</code></pre>
<blockquote>
<p>官方题解：<br>
方法 1：递归<br>
最直接的方法就是利用递归，遍历整棵树：如果当前节点不是叶子，对它的所有孩子节点，递归调用 hasPathSum 函数，其中 sum 值减去当前节点的权值；如果当前节点是叶子，检查 sum 值是否为 0，也就是是否找到了给定的目标和。</p>
</blockquote>
<pre><code>Java
class Solution {
  public boolean hasPathSum(TreeNode root, int sum) {
    if (root == null)
      return false;

    sum -= root.val;
    if ((root.left == null) &amp;&amp; (root.right == null))
      return (sum == 0);
    return hasPathSum(root.left, sum) || hasPathSum(root.right, sum);
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：我们访问每个节点一次，时间复杂度为 O(N) ，其中 N 是节点个数。<br>
空间复杂度：最坏情况下，整棵树是非平衡的，例如每个节点都只有一个孩子，递归会调用 N 次（树的高度），因此栈的空间开销是 O(N) 。但在最好情况下，树是完全平衡的，高度只有 log(N)，因此在这种情况下空间复杂度只有 O(log(N)) 。</p>
</blockquote>
<blockquote>
<p>方法 2：迭代<br>
算法<br>
我们可以用栈将递归转成迭代的形式。深度优先搜索在除了最坏情况下都比广度优先搜索更快。最坏情况是指满足目标和的 root-&gt;leaf 路径是最后被考虑的，这种情况下深度优先搜索和广度优先搜索代价是相通的。<br>
利用深度优先策略访问每个节点，同时更新剩余的目标和。<br>
所以我们从包含根节点的栈开始模拟，剩余目标和为 sum - root.val。<br>
然后开始迭代：弹出当前元素，如果当前剩余目标和为 0 并且在叶子节点上返回 True；如果剩余和不为零并且还处在非叶子节点上，将当前节点的所有孩子以及对应的剩余和压入栈中。</p>
</blockquote>
<pre><code>class Solution {
  public boolean hasPathSum(TreeNode root, int sum) {
    if (root == null)
      return false;

    LinkedList&lt;TreeNode&gt; node_stack = new LinkedList();
    LinkedList&lt;Integer&gt; sum_stack = new LinkedList();
    node_stack.add(root);
    sum_stack.add(sum - root.val);

    TreeNode node;
    int curr_sum;
    while ( !node_stack.isEmpty() ) {
      node = node_stack.pollLast();
      curr_sum = sum_stack.pollLast();
      if ((node.right == null) &amp;&amp; (node.left == null) &amp;&amp; (curr_sum == 0))
        return true;

      if (node.right != null) {
        node_stack.add(node.right);
        sum_stack.add(curr_sum - node.right.val);
      }
      if (node.left != null) {
        node_stack.add(node.left);
        sum_stack.add(curr_sum - node.left.val);
      }
    }
    return false;
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：和递归方法相同是 O(N)。<br>
空间复杂度：当树不平衡的最坏情况下是 O(N) 。在最好情况（树是平衡的）下是 O(logN)。</p>
</blockquote>
<p>哈哈哈又被官方题解的优雅秀到了，我是用一个额外的参数res来计算值然后判断相等，从而额外地需要将sum传进去递归里面，但是官方是直接用sum递减来处理，省去了额外的参数负担，妙呀！</p>
]]></content>
    </entry>
</feed>