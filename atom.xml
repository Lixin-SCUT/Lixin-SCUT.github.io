<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2020-01-12T14:57:16.937Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[链表 142. 环形链表 II[中等][未做出]]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-142-huan-xing-lian-biao-iizhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-142-huan-xing-lian-biao-iizhong-deng-wei-zuo-chu">
        </link>
        <updated>2020-01-11T11:51:18.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<br>
为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。<br>
说明：不允许修改给定的链表。<br>
示例 1：<br>
输入：head = [3,2,0,-4], pos = 1<br>
输出：tail connects to node index 1<br>
解释：链表中有一个环，其尾部连接到第二个节点。<br>
示例 2：<br>
输入：head = [1,2], pos = 0<br>
输出：tail connects to node index 0<br>
解释：链表中有一个环，其尾部连接到第一个节点。<br>
示例 3：<br>
输入：head = [1], pos = -1<br>
输出：no cycle<br>
解释：链表中没有环。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/linked-list-cycle-ii<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>最简单的就是用哈希表了 然后用hash表的时候有点翻车，把指针类型写成了*ListNode了，应该是ListNode*<br>
然后就是考虑双指针法了，检查是否有环是很简单，但是最后停留的位置是未知的。我觉得应该引入第三个指针<br>
看题解去！<br>
哇好心痛，其实就差一步我就做出来的了，就主要是没了解到一个重点 入环点在的位置一定是 m+aN，此时快指针和慢指针的差刚好（b-a）N，同时也是慢指针的值，等于慢指针总共走的路程还是环长（虽然此时不在环上），离入环点还差m步（理解一下m+aN和（b-a）N之间的差别），那么我引入的第三个指针（也可以用fast代替）刚好可以从头指针走m步<br>
好气啊！</p>
<p>实现注意点：<br>
1.两个指针应该从一个虚拟头节点开始而不是从head开始，否则一开始走过的路程就是1了，所以一般定义fast是head-&gt;next，slow就是head，等于预先走了一步<br>
2.fast的判断和两次连续next很重要<br>
2.又忘了判断空链表了。。。</p>
<pre><code>class Solution {
public:

    ListNode *detectCycle(ListNode *head) {
        if(head==NULL)return NULL;
        ListNode *fast=head-&gt;next,*slow=head;
        while(fast!=slow){
            if(fast!=NULL&amp;&amp;fast-&gt;next!=NULL)
                fast=fast-&gt;next-&gt;next; //注意判断条件和两次连续next，没必要分开两次判断next
            else
                return NULL;
            slow=slow-&gt;next;
        }
        fast=head;
        slow=slow-&gt;next;//注意这里，因为fast=head;相当于提前走了一步
        while(fast!=slow)
            fast=fast-&gt;next,slow=slow-&gt;next;
        return slow;     
				/*哈希表解法
        unordered_set&lt;ListNode*&gt; List_set;
        ListNode *cur=head;
        while(true)
            if(cur==NULL)
                return NULL;
            else if(List_set.count(cur))
                return cur;
            else{
                List_set.insert(cur);
                cur=cur-&gt;next;
            }
        */
    }
};
</code></pre>
<p>然后来看看官方题解和网友题解：</p>
<blockquote>
<p>方法 1：哈希表<br>
想法<br>
如果我们用一个 Set 保存已经访问过的节点，我们可以遍历整个列表并返回第一个出现重复的节点。<br>
算法<br>
首先，我们分配一个 Set 去保存所有的列表节点。我们逐一遍历列表，检查当前节点是否出现过，如果节点已经出现过，那么一定形成了环且它是环的入口。否则如果有其他点是环的入口，我们应该先访问到其他节点而不是这个节点。其他情况，没有成环则直接返回 null 。<br>
算法会在遍历有限个节点后终止，这是因为输入列表会被分成两类：成环的和不成环的。一个不成欢的列表在遍历完所有节点后会到达 null - 即链表的最后一个元素后停止。一个成环列表可以想象成是一个不成环列表将最后一个 null 元素换成环的入口。<br>
如果 while 循环终止，我们返回 null 因为我们已经将所有的节点遍历了一遍且没有遇到重复的节点，这种情况下，列表是不成环的。对于循环列表， while 循环永远不会停止，但在某个节点上， if 条件会被满足并导致函数的退出。</p>
</blockquote>
<pre><code>public class Solution {
    public ListNode detectCycle(ListNode head) {
        Set&lt;ListNode&gt; visited = new HashSet&lt;ListNode&gt;();

        ListNode node = head;
        while (node != null) {
            if (visited.contains(node)) {
                return node;
            }
            visited.add(node);
            node = node.next;
        }

        return null;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)<br>
不管是成环还是不成环的输入，算法肯定都只会访问每个节点一次。对于非成环列表这是显而易见的，因为第 n 个节点指向 null ，这会让循环退出。对于循环列表， if 条件满足时会导致函数的退出，因为它指向了某个已经访问过的节点。两种情况下，访问的节点数最多都是 n 个，所以运行时间跟节点数目成线性关系。<br>
空间复杂度：O(n)<br>
不管成环或者不成欢的输入，我们都需要将每个节点插入 Set 中一次。两者唯一的区别是最后访问的节点后是 null 还是一个已经访问过的节点。因此，由于 Set 包含 n 个不同的节点，所需空间与节点数目也是线性关系的。</p>
</blockquote>
<blockquote>
<p>方法 1：Floyd<br>
解题思路：<br>
这类链表题目一般都是使用双指针法解决的，例如寻找距离尾部第K个节点、寻找环入口、寻找公共尾部入口等。<br>
算法流程：<br>
双指针第一次相遇： 设两指针 fast，slow 指向链表头部 head，fast 每轮走 22 步，slow 每轮走 11 步；</p>
</blockquote>
<blockquote>
<p>第一种结果： fast 指针走过链表末端，说明链表无环，直接返回 null；<br>
TIPS: 若有环，两指针一定会相遇。因为每走 1 轮，fast 与 slow 的间距 +1，fast 终会追上 slow；<br>
第二种结果： 当fast == slow时， 两指针在环中 第一次相遇 。下面分析此时fast 与 slow走过的 步数关系 ：<br>
设链表共有 a+b 个节点，其中 链表头部到链表入口 有 a 个节点（不计链表入口节点）， 链表环 有 b 个节点（这里需要注意，a 和 b 是未知数，例如图解上链表 a=4 , b=5）；设两指针分别走了f，s 步，则有：<br>
fast 走的步数是slow步数的 2 倍，即 f=2s；（解析： fast 每轮走 2 步）<br>
fast 比 slow多走了 n 个环的长度，即f=s+nb；（ 解析： 双指针都走过 a 步，然后在环内绕圈直到重合，重合时 fast 比 slow 多走 环的长度整数倍 ）；<br>
以上两式相减得：f=2nb，s=nb，即fast和slow 指针分别走了 2n，n个环的周长 （注意： n 是未知数，不同链表的情况不同）。<br>
目前情况分析：<br>
如果让指针从链表头部一直向前走并统计步数k，那么所有 走到链表入口节点时的步数 是：k=a+nb（先走 a 步到入口节点，之后每绕 1 圈环（ b 步）都会再次到入口节点）。<br>
而目前，slow 指针走过的步数为 nb 步。因此，我们只要想办法让 slow 再走 a 步停下来，就可以到环的入口。<br>
但是我们不知道 a 的值，该怎么办？依然是使用双指针法。我们构建一个指针，此指针需要有以下性质：此指针和slow 一起向前走 a 步后，两者在入口节点重合。那么从哪里走到入口节点需要 a 步？答案是链表头部head。<br>
双指针第二次相遇：<br>
slow指针位置不变 ，将fast指针重新 指向链表头部节点 ；slow和fast同时每轮向前走 1 步；<br>
TIPS：此时 f=0，s=nb ；<br>
当 fast 指针走到f=a 步时，slow 指针走到步s=a+nb，此时 两指针重合，并同时指向链表环入口 。<br>
返回slow指针指向的节点。<br>
复杂度分析：<br>
时间复杂度 O(N) ：第二次相遇中，慢指针须走步数 a&lt;a+b；第一次相遇中，慢指针须走步数a+b−x&lt;a+b，其中 x 为双指针重合点与环入口距离；因此总体为线性复杂度；<br>
空间复杂度 O(1) ：双指针使用常数大小的额外空间。</p>
</blockquote>
<pre><code>public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast = head, slow = head;
        while (true) {
            if (fast == null || fast.next == null) return null;
            fast = fast.next.next;
            slow = slow.next;
            if (fast == slow) break;
        }
        fast = head;
        while (slow != fast) {
            slow = slow.next;
            fast = fast.next;
        }
        return fast;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Linux基础] 源码编译与链接 （鸟哥Linux第二十一章）]]></title>
        <id>https://lixin-ee.github.io//post/linux-ji-chu-ruan-jian-an-zhuang-yuan-shi-ma-yu-tarball-niao-ge-linux-di-er-shi-yi-zhang</id>
        <link href="https://lixin-ee.github.io//post/linux-ji-chu-ruan-jian-an-zhuang-yuan-shi-ma-yu-tarball-niao-ge-linux-di-er-shi-yi-zhang">
        </link>
        <updated>2020-01-11T07:11:12.000Z</updated>
        <content type="html"><![CDATA[<p>了解如何将开放源码的程序设计、加入函式库的原理、透过编译而成为可以执行 的 binary program，最后使用该执行档</p>
<p>注意，与Windows不同，Linux 上面的软件几乎都是经过 GPL 的授权，所以每个软件几乎均提供源代码， 并且你可以自行修改该程序代码，以符合你个人的需求</p>
<p>Linux 系统上真正认识的可执行文件其实是二进制文件 ( binary program)<br>
例如，shell scripts 只是利用 shell (例如 bash) 这支程序的功能进行一些判断式，而最终执行的除了 bash 提供的功能外，仍是呼叫一些已经编译好的二进制程序来执行<br>
可以用file命令来判断，如果是 binary 而且是可以执行的时候，他就会显示执行文件类别 (ELF 64-bit LSB executable)， 同时会说明是否使用<strong>动态函式库 (shared libs)</strong>，而如果是一般的 script ，那他就会显示 出 text executables 之类的字样</p>
<p>vim编写的程序代码文件其实就是一般的纯 文本档。 在完成这个原始码文件的编写之后，再来就是要将这个文件『编译』成为操作系统看的懂 得 binary program 啰，而要编译自然就需要『编译程序』来动作， 经过编译程序的编译与连结之后， 就会产生一支可以执行的 binary program</p>
<p>编译的过程当中还会产生所谓的目标文件 (Object file)<br>
程序当中『引用、呼叫』 其他的外部子程序，或者是利用其他软件库提供的『函数功能』，这个时候，我们就必须要在编译的过程当中， 将该函式库加进去<br>
最后编译程序就可以将所有的程序代码与函式库作一个<strong>连结 (Link)</strong> 以产生正确的执行档</p>
<p>开放源码：就是程序代码，写给人类看的程序语言，但机器并不认识，所以无法执行；<br>
编译程序：将程序代码转译成为机器看得懂的语言，就类似翻译者的角色；<br>
可执行文件：经过编译程序变成二进制程序后，机器可以执行的文件。</p>
<ul>
<li>make 与 configure<br>
使用类似 gcc 的编译程序来进行编译的过程并不简单，大型项目可能会有成百上千个源文件和头文件，需要使用 make 这个指令的相关功能来进行编译过程的指令简化<br>
当执行 make 时，make 会在当时的目录下搜寻 Makefile(or makefile) 这个文本文件<br>
Makefile 里面则记录了原始码<strong>如何编译</strong>的详细信息， make 会自动的判别原始码<strong>是否经过变动</strong>了，而自动更新执行档<br>
通常软件开发商都会写一支<strong>侦测程序configure或者是config</strong>来侦测用户的作业环境， 以及该作业环境是否有软件开发商所需要的其他功能，该侦测程序侦 测完毕后，就会主动的建立这个Makefile的规则文件</li>
</ul>
<p>侦测程序会侦测的数据大约有底下这些：<br>
是否有适合的编译程序可以编译本软件的程序代码；<br>
是否已经存在本软件所需要的函式库，或其他需要的相依软件；<br>
操作系统平台是否适合本软件，包括 Linux 的核心版本；<br>
核心的表头定义档 (header include) 是否存在 (驱动程序必须要的侦测)。<br>
<img src="https://lixin-ee.github.io//post-images/1578728268148.png" alt=""></p>
<p>所以，我们无法在 CentOS 7.x 上面编译出 binary program 后，还将他拿到 SuSE 上面执行，这个动作通常是不可能成功</p>
<ul>
<li>Tarball<br>
所谓的 Tarball 文件，其实就是将软件的所有原始码文件先以 tar 打包（注意不是压缩），然后再以压缩技术来压缩<br>
通常最常见的就是以 gzip 来压缩了。因为利用了 tar 与 gzip 的功能，所以 tarball 文件一般的扩展 名就会写成 * .tar.gz 或者是简写为 * .tgz，相应地 bzip2 与 xz 的后缀名也会变成 * .tar.bz2, * .tar.xz 之类</li>
</ul>
<p>安装压缩包通常就会有：<br>
源代码文件；<br>
侦测程序文件 (可能是 configure 或 config 等檔名)；<br>
本软件的简易说明与安装说明 (INSTALL 或 README)。</p>
<ul>
<li>编译简单范例<br>
<code>[root@study ~]# gcc hello.c</code><br>
如果我们直接以 gcc 编译原始码，并且没有加上任何参数，则执行档的档名会被 自动设定为 a.out 这个文件名<br>
<code>[root@study ~]# ./a.out</code><br>
执行文件时在文件名前面一定要加上./</li>
</ul>
<pre><code>[root@study ~]# gcc -c hello.c
[root@study ~]# gcc -o hello hello.o
</code></pre>
<p>利用 hello.o 这个目标文件制作出一个名为 hello 的执行文件</p>
<p>当我们有多个.c源文件的时候</p>
<pre><code>[root@study ~]# gcc - c thanks.c thanks_2.c
[root@study ~]# gcc -o thanks thanks.o thanks_2.o
</code></pre>
<p>制作目标文件的原因，源文件一般并非仅只有一个文件，无法直接进行编译，需要先产生目标文件，然后再以连结制作成为<strong>单个 binary 可执行文件</strong>。另外， 如果有一天，你更新了 thanks_2.c 这个文件的内容，则你只要<strong>重新编译</strong>thanks_2.c 来产生新的 thanks_2.o ，然后再以连结制作出新的 binary 可执行文件即可，而<strong>不必重新编译</strong>其他没有更动过的源文件。</p>
<p>-O选项： 产生优化的参数<br>
-Wall 为产生更详细的编译过程信息。警告讯息 (warning) 不用理会也没有关系</p>
<ul>
<li>呼叫外部函式库：加入连结的函式库<br>
.h头文件都可以看作是外部库library<br>
对于.h头文件，gcc会直接抓取，只需要在源文件中声明，不需要在命令行中加上</li>
</ul>
<p>而对于非.h头文件的数据库<br>
编译时加入额外函式库连结的方式</p>
<pre><code>[root@study ~]# gcc sin.c -lm -L/lib -L/lib64  #重点在 -lm 
[root@study ~]# ./a.out 
</code></pre>
<p>-lm参数：<br>
-l ：是『加入某个函式库(library)』的意思，<br>
-m ：则是 libm.so 这个函式库，其中， lib 与扩展名(.a 或 .so)不需要写<br>
所以 -lm 表示使用 libm.so (或 libm.a) 这个函式库的意思～至于那个 -L 后面接的路径表示： 『函式库 libm.so 请到 /lib 或 /lib64 里面搜寻』</p>
<p>[root@study ~]# gcc sin.c -lm -I/usr/include<br>
定义出要 include 文件放置的目录，-I/path后面接的路径( Path )就是设定要去搜寻相关的 include 文件的目录</p>
<ul>
<li>gcc 的简易用法 ( 编译、参数与链结)<br>
仅将原始码编译成为目标文件，并不制作链接等功能：<br>
<code>[root@study ~]# gcc -c hello.c</code><br>
会自动的产生 hello.o 这个文件，但是并不会产生 binary 执行档。</li>
</ul>
<p>在编译的时候，依据作业环境给予优化执行速度<br>
<code>[root@study ~]# gcc -O hello.c -c</code><br>
会自动的产生 hello.o 这个文件，并且进行优化</p>
<p>在进行 binary file 制作时，将连结的函式库与相关的路径填入<br>
<code>[root@study ~]# gcc sin.c -lm -L/lib -I/usr/include</code><br>
这个指令较常下达在最终连结成 binary file 的时候，<br>
-lm 指的是 libm.so 或 libm.a 这个函式库文件；<br>
-L 后面接的路径是刚刚上面那个函式库的搜寻目录；<br>
-I 后面接的是原始码内的 include 文件之所在目录。</p>
<p>将编译的结果输出成某个特定档名<br>
<code>[root@study ~]# gcc -o hello hello.c</code><br>
-o 后面接的是要输出的 binary file 檔名</p>
<p>在编译的时候，输出较多的讯息说明<br>
<code>[root@study ~]# gcc -o hello hello.c -Wall</code><br>
加入 -Wall 之后，程序的编译会变的较为严谨一点，所以警告讯息也会显示出来！</p>
<p>另外，我们通常称 -Wall 或者 -O 这些非必要的参数为旗标 (FLAGS)，使用的是 C 程序语言时也会简称这些旗标为 CFLAGS</p>
<ul>
<li>用 make  进行宏编译<br>
makefile 一次性完成编译和链接等工作</li>
</ul>
<p>[root@study ~]#  vim makefile<br>
main: main.o haha.o sin_value.o cos_value.o<br>
gcc -o main main.o haha.o sin_value.o cos_value.o -lm<br>
注意，第二行前面有一个tab缩进</p>
<p>疑惑：『如果建立一个 shell script 来将上面的所有动作都按顺序集结在一起，不是具有同样的效果吗』<br>
<strong>注意！效果当然不一样</strong>，以上面的测试为例，我们仅写出 main 需要的目标文件，结果 make会主动的去判断每个目标文件相关的原始码文件，并直接予以编译，最后再直接进行连结的动作，<strong>同时！</strong> 如果我们更动过某些原始码文件，则 make 也可以<strong>主动判断</strong>哪一个原始码与相关的目标文件文件有更新过， 并仅更新该文件，可大大的节省编译时间</p>
<p>make有这些好处：<br>
简化编译时所需要下达的指令；<br>
若在编译完成之后，修改了某个原始码文件，则 make <strong>仅会针对被修改</strong>了的文件进行编译，其他的object file不会被更动；<br>
最后可以依照<strong>相依性</strong>来更新 (update) 执行档。</p>
<ul>
<li>makefile的基本语法与变量</li>
</ul>
<pre><code>目标(target): 目标文件 1 目标文件 2
&lt;tab&gt; gcc -o 欲建立的执行文件 目标文件 1 目标文件 2
</code></pre>
<p>目标 (target) 就是我们想要建立的信息，而目标文件就是具有相关性的 object files ，那建立执行文件的语法就是以 tab按键开头的那一行！特别留意，『命令行必须要以 tab 按键作为开头』才行<br>
在 makefile 当中的 # 代表批注；<br>
tab 需要在命令行 (例如 gcc 这个编译程序指令) 的第一个字符；<br>
目标 (target) 与相依文件(就是目标文件)之间需以『:』隔开。</p>
<p>Makefile里面可以有多个动作<br>
例如</p>
<pre><code>main: main.o haha.o sin_value.o cos_value.o
		gcc -o main main.o haha.o sin_value.o cos_value.o -lm
clean:
		rm -f main main.o haha.o sin_value.o cos_value.o
</code></pre>
<p><code>[root@study ~]# make clean &lt;==就是这里！透过 make 以 clean 为目标</code><br>
我们的 makefile 里面就具有至少两个目标，分别是 main 与 clean ，如果我们想要建立main 的话，输入『make main』，如果想要清除有的没的，输入『make clean』即可，而如果想要<strong>先清除目标文件再编译 main 这</strong>个程序的话，就可以这样输入：『make clean main』</p>
<p>Makefile中可以使用变量<br>
例如：</p>
<pre><code>[root@study ~]#  vi makefile
LIBS = -lm
OBJS = main.o haha.o sin_value.o cos_value.o
main: ${OBJS}
		gcc -o main ${OBJS} ${LIBS}
clean:
		rm -f main ${OBJS}
</code></pre>
<p>与 bash shell script 的语法有点不太相同，变量的基本语法为：</p>
<ol>
<li>变量与变量内容以『=』隔开，同时两边可以具有空格；</li>
<li>变量左边不可以有 tab ，例如上面范例的第一行 LIBS 左边不可以是tab；</li>
<li>变量与变量内容在『=』两边不能具有『:』；</li>
<li>在习惯上，变数最好是以『大写字母』为主；</li>
<li>运用变量时，以 ${变量} 或 $(变量) 使用；</li>
<li>在该 shell 的<strong>环境变量</strong>是可以被套用的，例如提到的 CFLAGS 这个变数！</li>
<li>在指令列模式也可以给予变量。<br>
由于 gcc 在进行编译的行为时，会主动的去读取 CFLAGS 这个环境变量，所以，你可以直接在 shell定义出这个环境变量，也可以在 makefile 文件里面去定义，更可以在指令列当中给出<br>
<code>[root@study ~]# CFLAGS=&quot;-Wall&quot; make clean main</code><br>
这个动作在上 make 进行编译时，会去取用 CFLAGS 的变量内容<br>
万一这个CFLAGS 的内容在指令列与 makefile 里面并不相同，即出现同名变量的时候，环境变量取用的规则是这样的：</li>
<li>make 指令列后面加上的环境变量为优先；</li>
<li>makefile 里面指定的环境变量第二；</li>
<li>shell 原本具有的环境变量第三。<br>
此外，还有一些特殊的变量需要了解的喔：<br>
$@：代表目前的目标(target)<br>
例如</li>
</ol>
<pre><code>[root@study ~]#  vi makefile
LIBS = -lm
OBJS = main.o haha.o sin_value.o cos_value.o
CFLAGS = -Wall
main: ${OBJS}
		gcc -o $@ ${OBJS} ${LIBS} &lt;==那个 $@ 就是 main ！
clean:
		rm -f main ${OBJS}
</code></pre>
<ul>
<li>函式库管理<br>
很多的软件之间都会互相取用彼此提供的函式库来进行特殊功能的运作<br>
依据函式库被使用的类型而分为两大类，分别是静态(Static) 与动态 (Dynamic) 函式库两类</li>
</ul>
<p>静态函式库的特色：<br>
扩展名：<strong>(扩展名为 .a)</strong><br>
这类的函式库通常扩展名为<strong>libxxx.a 的类型</strong>；<br>
编译行为：<br>
这类函式库在编<strong>译的时候会直接整合到执行程序</strong>当中，所以利用静态函式库编译成的<strong>文件会比较大一些</strong>；<br>
独立执行的状态：<br>
这类函式库最大的优点，就是<strong>编译成功的可执行文件可以独立执行</strong>，而不需要再向外部要求读取函式库的内容 (请参照动态函式库的说明)。<br>
升级难易度：<br>
虽然执行档可以独立执行，但因为函式库是直接整合到执行档中， 因此<strong>若函式库升级时，整个执行档必须要重新编译</strong>才能将新版的函式库整合到程序当中。 也就是说，在升级方面，只要函式库升级了，所有将此函式库纳入的程序都需要重新编译</p>
<p>动态函式库的特色：<br>
<strong>扩展名：(扩展名为 .so)</strong><br>
这类函式库通常扩展名为<strong>libxxx.so 的类型</strong>；<br>
编译行为：<br>
动态函式库与静态函式库的编译行为差异挺大的。 与静态函式库被整个捉到程序中不同的，动态函式库在编译的时候，<strong>在程序里面只有一个『指向 (Pointer)』的位置而已</strong>。也就是说，动态函式库的内容<strong>并没有被整合到执行档当中</strong>，而是当执行档要使用到函式库的机制时， 程序才会去读<strong>取函式库来使用</strong>。由于执行文件当中仅具有指向动态函式库所在的指标而已， 并不包含函式库的内容，所以他的文件会比较小一点。<br>
独立执行的状态：<br>
这类型的函式库所编译出来的程序<strong>不能被独立执行</strong>， 因为当我们使用到函式库的机制时，程序才会去读取函式库，所以函式库文件『必须要存在』才行，而且，函式库的<strong>所在目录也不能改变</strong>，因为我们的可执行文件里面仅有『指标』亦即当要取用该动态函式库时， 程序会主动去某个路径下读取，呵呵！所以动态函式库<strong>不能随意移动或删除</strong>，会影响很多相依的程序软件喔！<br>
升级难易度：<br>
虽然这类型的执行档无法独立运作，然而由于是具有指向的功能， 所以，当函式库<strong>升级后，执行档根本不需要进行重新编译的行为</strong>，因为执行档会直接指向新的函式库文件 (前提是函式库新旧版本的档名相同)。</p>
<p>目前的 Linux distribution 比较倾向于使用动态函式库，因为如同上面提到的最重要的一点， 就是函式库的升级方便</p>
<p>ldconfig  与 /etc/ld.so.conf<br>
如果我们将常用到的动态函式库先加载内存当中 (快取, cache)，如此一来，当软件要取用动态函式库时，就不需要从头由硬盘里面读出，这样就可以增进动态函式库的读取速度</p>
<p>将动态函式库加载高速缓存当中：</p>
<ol>
<li>首先，我们必须要在 /etc/ld.so.conf 里面写下『 想要读入高速缓存当中的动态函式库所在的目录』，注意是目录而不是文件；</li>
<li>接下来则是利用 ldconfig 这个执行档将 /etc/ld.so.conf 的资料读入快取当中；</li>
<li>同时也将数据记录一份在 /etc/ld.so.cache 这个文件当中</li>
</ol>
<p>ldconfig 还可以用来判断动态函式库的链接信息。想要将目前系统下函式库加入到快取当中时，可以这样做：</p>
<pre><code>[root@study ~]#  ldconfig [-f conf] [ -C cache]
[root@study ~]#  ldconfig [-p]
</code></pre>
<p>选项与参数：<br>
-f conf ：那个 conf 指的是某个文件名，也就是说，使用 conf 作为 libarary<br>
函式库的取得路径，而不以 /etc/ld.so.conf 为默认值<br>
-C cache：那个 cache 指的是某个文件名，也就是说，使用 cache 作为快取暂存<br>
的函式库资料，而不以 /etc/ld.so.cache 为默认值<br>
-p  ：列出目前有的所有函式库资料内容 (在 /etc/ld.so.cache 内的资料)</p>
<p>范例一：假设我的 Mariadb 数据库函式库在 /usr/lib64/mysql 当中，如何读进 cache ？<br>
<code>[root@study ~]# vim /etc/ld.so.conf.d/vbird.conf</code><br>
/usr/lib64/mysql &lt;==这一行新增的啦！<br>
<code>[root@study ~]# ldconfig &lt;==画面上不会显示任何的信息，不要太紧张！正常的！</code><br>
<code>[root@study ~]# ldconfig -p</code></p>
<ul>
<li>程序的动态函式库解析： ldd<br>
判断某个可执行的 binary 文件含有什么动态函式库<br>
<code>[root@study ~]# ldd [-vdr] [filename]</code><br>
选项与参数：<br>
-v ：列出所有内容信息；<br>
-d ：重新将资料有遗失的 link 点显示出来<br>
-r ：将 ELF 有关的错误内容显示出来</li>
</ul>
<p>安装文件时，可以先以 ldd 来视察『相依函式库』之间的相关性，亦即『 相依属性』</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 62. 不同路径[中等][未做出]]]></title>
        <id>https://lixin-ee.github.io//post/dong-tai-gui-hua-62-bu-tong-lu-jing-zhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/dong-tai-gui-hua-62-bu-tong-lu-jing-zhong-deng-wei-zuo-chu">
        </link>
        <updated>2020-01-11T01:11:27.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。<br>
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。<br>
问总共有多少条不同的路径？<br>
例如，上图是一个7 x 3 的网格。有多少可能的路径？<br>
说明：m 和 n 的值均不超过 100。<br>
示例 1:<br>
输入: m = 3, n = 2<br>
输出: 3<br>
解释:<br>
从左上角开始，总共有 3 条路径可以到达右下角。<br>
1.向右 -&gt; 向右 -&gt; 向下<br>
2.向右 -&gt; 向下 -&gt; 向右<br>
3.向下 -&gt; 向右 -&gt; 向右<br>
示例 2:<br>
输入: m = 7, n = 3<br>
输出: 28<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/unique-paths<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>其实这道题挺像回溯法的，但是我看了一眼tag其实是动态规划？<br>
一开始用的就是类似于回溯法的递归，然后又被自己坑了，递归调用中慎重用++i，只能用i+1,两次递归调用中会出现第二次递归i已经又增大了1的情况<br>
然后暴力递归果断爆炸了</p>
<p>然后我发现一个问题是似乎每个路径的长度是确定的</p>
<p>只能想一下动态规划了<br>
一开始实在没什么头绪，只能牺牲空间复杂度了，然后发现无论是vecotr还是unordered_map都很复杂<br>
还是老老实实看题解吧，没那么时间可以浪费了</p>
<p>看了题解才发现其实是70题提过的方法，只是当时没好好记录和复现，唉<br>
然后题目还提到了有化为一维数组的方法</p>
<p>复现过程中的点<br>
1.将m* n数组初始化为1<br>
2.循环标志i和j从1开始，因为边界点的可能性都是为1的，这一点和第一点相互照应。<br>
3.一维数组的压缩就是利用当前行只需要上一列的内容来压缩（可以先考虑压缩到两行cur和pre，然后在考虑cur本身也是pre）</p>
<p>最后就是排列组合的问题了，步骤确定，那么只要选定步骤中任意m次向右或者n次向下就行了，等于C上m或n,C下的len为m+n-2，有时间的话可以了解一下C上m或n都是结果相同的</p>
<p>所以从今天起，每道题只花少量时间去思考，想不出来就看题解的思路，然后按照思路来自己复现（不能照抄代码）</p>
<p>实现代码</p>
<pre><code>    /*自己弄的蹩脚的递归法
    void move(int i,int j,int m, int n,int &amp;res){
        if(i==m&amp;&amp;j==n){
            ++res;
            return;
        }
        if(i&lt;m)
            move(i+1,j,m,n,res);
        if(j&lt;n)
            move(i,j+1,m,n,res);
        return;
    }
    */
</code></pre>
<pre><code>    /*二维数组动态递归
        int uniquePaths(int m, int n) {
        vector&lt;vector&lt;int&gt;&gt; status(m,vector&lt;int&gt;(n,1));
        for(int i=1;i&lt;m;++i)
            for(int j=1;j&lt;n;++j)
                status[i][j]=status[i-1][j]+status[i][j-1];
        return status[m-1][n-1];
    }
</code></pre>
<pre><code>//单维数组存储
    int uniquePaths(int m, int n) {
        vector&lt;int&gt; status(m,1);
        for(int j=1;j&lt;n;++j)
            for(int i=1;i&lt;m;++i)
                status[i]+=status[i-1];
        return status[m-1];
    }
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>思路<br>
思路一：排列组合<br>
因为机器到底右下角，向下几步，向右几步都是固定的，<br>
比如，m=3, n=2，我们只要向下 1 步，向右 2 步就一定能到达终点。<br>
所以有 C{m+n-2} {m-1}</p>
</blockquote>
<pre><code>def uniquePaths(self, m: int, n: int) -&gt; int:
        return int(math.factorial(m+n-2)/math.factorial(m-1)/math.factorial(n-1))
</code></pre>
<blockquote>
<p>思路二：动态规划<br>
我们令 dp[i][j] 是到达 i, j 最多路径<br>
动态方程：dp[i][j] = dp[i-1][j] + dp[i][j-1]<br>
注意，对于第一行 dp[0][j]，或者第一列 dp[i][0]，由于都是在边界，所以只能为 1<br>
时间复杂度：O(m*n)<br>
空间复杂度：O(m * n))<br>
优化：因为我们每次只需要 dp[i-1][j],dp[i][j-1]<br>
所以我们只要记录这两个数，直接看代码吧！<br>
代码<br>
思路二：</p>
</blockquote>
<pre><code>Java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for (int i = 0; i &lt; n; i++) dp[0][i] = 1;
        for (int i = 0; i &lt; m; i++) dp[i][0] = 1;
        for (int i = 1; i &lt; m; i++) {
            for (int j = 1; j &lt; n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];  
    }
}
</code></pre>
<blockquote>
<p>优化1：空间复杂度 O(2n)</p>
</blockquote>
<pre><code>Java
class Solution {
    public int uniquePaths(int m, int n) {
        int[] pre = new int[n];
        int[] cur = new int[n];
        Arrays.fill(pre, 1);
        Arrays.fill(cur,1);
        for (int i = 1; i &lt; m;i++){
            for (int j = 1; j &lt; n; j++){
                cur[j] = cur[j-1] + pre[j];
            }
            pre = cur.clone();
        }
        return pre[n-1]; 
    }
}
</code></pre>
<blockquote>
<p>优化2：空间复杂度 O(n)</p>
</blockquote>
<pre><code>Java
class Solution {
    public int uniquePaths(int m, int n) {
        int[] cur = new int[n];
        Arrays.fill(cur,1);
        for (int i = 1; i &lt; m;i++){
            for (int j = 1; j &lt; n; j++){
                cur[j] += cur[j-1] ;
            }
        }
        return cur[n-1];
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 215. 数组中的第K个最大元素[中等]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-215-shu-zu-zhong-de-di-k-ge-zui-da-yuan-su-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-215-shu-zu-zhong-de-di-k-ge-zui-da-yuan-su-zhong-deng">
        </link>
        <updated>2020-01-10T01:25:57.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br>
示例 1:<br>
输入: [3,2,1,5,6,4] 和 k = 2<br>
输出: 5<br>
示例 2:<br>
输入: [3,2,3,1,2,4,5,5,6] 和 k = 4<br>
输出: 4<br>
说明:<br>
你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/kth-largest-element-in-an-array<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>一开始我想的是用空间换时间，创建一个k大小的数组，然后不断插入到合适的位置（等等，这不就是插入排序吗？插入需要查找感觉也没简化多少啊）<br>
然后发现其实可以转化为为堆排序，然后返回下标<br>
然后就是tag中的分治法 我只想到了分治排序（也就是归并排序）（注意别和快速排序搞混了）<br>
然后有一个想法分治分成多个部分然后合并成k份或者分成k份，但是后来发现有问题</p>
<p>插入排序的时间复杂度是平方，放弃<br>
先实现堆排序,我在复现的过程中犯了一个错误，HeapAdjust应该只有一个循环，每次处理一个非子节点，而不是一次把所有节点放进去，否则的话后面排序的时候会很麻烦<br>
此时其实和快速排序没啥子区别的了</p>
<p>然后题解中其实提到我想到的k大小数组和分治法的方法，分别是K大小的堆和快速选择</p>
<p>实现的代码：<br>
堆排序</p>
<pre><code>/*
    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {
        int len=nums.size();
        for(int i=(len-1)/2;i&gt;=0;--i)
            HeapAdjust(nums,i,len);
        
        for(int i=len-1;i&gt;0;--i){
            swap(nums[0],nums[i]);
            HeapAdjust(nums,0,i);
        }
        return nums[len-k];  
    }
    
    void HeapAdjust(vector&lt;int&gt; &amp;nums,int s,int len){
            int temp=nums[s];
            for(int j=2*s+1;j&lt;len;j=2*j+1){
                if(j&lt;len-1&amp;&amp;nums[j+1]&gt;nums[j])
                    ++j;
                if(temp&gt;nums[j])
                    break;
                nums[s]=nums[j];
                s=j;
            }
            nums[s]=temp;
    }
*/
</code></pre>
<p>快速排序随机切实现</p>
<pre><code>/*
    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {
        int target;
        int len=nums.size();
        int left=0,right=len-1;
        while(true){
            target=binartselect(nums,left,right);
            if(target==len-k)
                return nums[target];
            else if(target&lt;len-k)
                left=target+1;
            else
                right=target-1;
        }
    }
    
    int binartselect(vector&lt;int&gt;&amp; nums,int left,int right){
        int pivotkey=nums[left];  
        
        //C++的随机数实现 加到标题上方便搜索
        if(right&gt;left){
            default_random_engine e;
            uniform_int_distribution&lt;unsigned&gt; u(left,right);
            pivotkey=nums[u(e)];
        }
        while(left&lt;right){
            while(left&lt;right&amp;&amp;nums[right]&gt;=pivotkey) //这里一定要是&gt;=否则遇上重复数会导致无限循环
                --right;
            nums[left]=nums[right];
            while(left&lt;right&amp;&amp;nums[left]&lt;=pivotkey) //这里一定要是&lt;=否则遇上重复数会导致无限循环
                ++left;
            nums[right]=nums[left];           
        }
        nums[left]=pivotkey;
        return left;
    }
*/
</code></pre>
<p>优先队列实现：</p>
<pre><code>class Solution {
public:
    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {
        priority_queue&lt;int,vector&lt;int&gt;,great&lt;int&gt;&gt; res; //底层数据结构是大顶堆，注意每次会弹出最大值
        for(auto i:nums){
            res.push(i);
            if(res.size()&gt;k)
                res.pop();
        }
        return res.top();
    }
  
};
</code></pre>
<p>然后来看看网友题解</p>
<blockquote>
<p>方法一：暴力解法<br>
题目要求我们找到“数组排序后的第 k 个最大的元素，而不是第 kk 个不同的元素” ，<br>
语义是从右边往左边数第 k 个元素（从 1 开始），那么从左向右数是第几个呢，我们列出几个找找规律就好了。<br>
一共 6 个元素，找第 2 大，索引是 4；<br>
一共 6 个元素，找第 4 大，索引是 2。<br>
因此，升序排序以后，目标元素的索引是 len - k。这是最简单的思路，如果只答这个方法，面试官可能并不会满意，但是在我们平时的开发工作中，还是不能忽视这种思路简单的方法，理由如下：<br>
最简单同时也一定是最容易编码的，编码成功的几率最高，可以用这个最简单思路编码的结果和其它思路编码的结果进行比对，验证高级算法的正确性；<br>
在数据规模小、对时间复杂度、空间复杂度要求不高的时候，简单问题简单做；<br>
思路简单的算法考虑清楚了，有些时候能为实现高级算法铺路，这道题也是如此；<br>
低级算法往往容错性最好，即在输入不满足题目条件的时候，往往还能得到正确的答案，而高级算法对输入数据的要求就非常苛刻，这一点可以参考 「力扣」第 4 题：“寻找两个有序数组的中位数”。</p>
</blockquote>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

class Solution {
public:
    int findKthLargest(vector&lt;int&gt; &amp;nums, int k) {
        int size = nums.size();
        sort(begin(nums), end(nums));
        return nums[size - k];
    }
};
</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(NlogN)，这里 N 是数组的长度，算法的性能消耗主要在排序，JDK 默认使用快速排序，因此时间复杂度为O(NlogN)。<br>
空间复杂度：O(1)，这里是原地排序，没有借助额外的辅助空间。<br>
到这里，我们已经分析出了：<br>
1、我们应该返回最终排定以后位于 len - k 的那个元素；<br>
2、性能消耗主要在排序，JDK 默认使用快速排序。<br>
学习过 “快速排序” 的朋友，一定知道一个操作叫 partition，它是 “分而治之” 思想当中 “分” 的那一步。经过 partition 操作以后，每一次都能排定一个元素，并且这个元素左边的数都不大于它，这个元素右边的数都不小于它，并且我们还能知道排定以后的元素的索引。于是可以应用 “减而治之”（分治思想的特例）的思想，把问题规模转化到一个更小的范围里。</p>
</blockquote>
<blockquote>
<p>于是得到方法二。<br>
方法二：借助 partition 操作定位到最终排定以后索引为 len - k 的那个元素（特别注意：随机化切分元素）<br>
以下是注意事项，因为很重要，所以放在前面说：<br>
快速排序虽然快，但是如果实现得不好，在遇到特殊测试用例的时候，时间复杂度会变得很高。如果你使用 partition 的方法完成这道题，时间排名不太理想，可以考虑一下是什么问题，这个问题很常见。<br>
以下的描述基于 “快速排序” 算法知识的学习，如果忘记的朋友们可以翻一翻自己的《数据结构与算法》教材，复习一下，partition 过程、分治思想和 “快速排序” 算法的优化。<br>
分析：我们在学习 “快速排序” 的时候，接触的第 1 个操作就是 partition（切分），简单介绍如下：<br>
partition（切分）操作，使得：<br>
对于某个索引 j，nums[j] 已经排定，即 nums[j] 经过 partition（切分）操作以后会放置在它 “最终应该放置的地方”；<br>
nums[left] 到 nums[j - 1] 中的所有元素都不大于 nums[j]；<br>
nums[j + 1] 到 nums[right] 中的所有元素都不小于 nums[j]。<br>
partition（切分）操作总能排定一个元素，还能够知道这个元素它最终所在的位置，这样每经过一次 partition（切分）操作就能缩小搜索的范围，这样的思想叫做 “减而治之”（是 “分而治之” 思想的特例）。<br>
切分过程可以不借助额外的数组空间，仅通过交换数组元素实现。下面是参考代码：</p>
</blockquote>
<pre><code>public class Solution {

    public int findKthLargest(int[] nums, int k) {
        int len = nums.length;
        int left = 0;
        int right = len - 1;

        // 转换一下，第 k 大元素的索引是 len - k
        int target = len - k;

        while (true) {
            int index = partition(nums, left, right);
            if (index == target) {
                return nums[index];
            } else if (index &lt; target) {
                left = index + 1;
            } else {
                right = index - 1;
            }
        }
    }

    /**
     * 在数组 nums 的子区间 [left, right] 执行 partition 操作，返回 nums[left] 排序以后应该在的位置
     * 在遍历过程中保持循环不变量的语义
     * 1、[left + 1, j] &lt; nums[left]
     * 2、(j, i] &gt;= nums[left]
     *
     * @param nums
     * @param left
     * @param right
     * @return
     */
    public int partition(int[] nums, int left, int right) {
        int pivot = nums[left];
        int j = left;
        for (int i = left + 1; i &lt;= right; i++) {
            if (nums[i] &lt; pivot) {
                // 小于 pivot 的元素都被交换到前面
                j++;
                swap(nums, j, i);
            }
        }
        // 在之前遍历的过程中，满足 [left + 1, j] &lt; pivot，并且 (j, i] &gt;= pivot
        swap(nums, j, left);
        // 交换以后 [left, j - 1] &lt; pivot, nums[j] = pivot, [j + 1, right] &gt;= pivot
        return j;
    }

    private void swap(int[] nums, int index1, int index2) {
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(N)，这里 N 是数组的长度，理由可以参考本题解下用户 @ZLW 的评论，需要使用主定理进行分析。<br>
空间复杂度：O(1)，原地排序，没有借助额外的辅助空间。<br>
注意：本题必须随机初始化 pivot 元素，否则通过时间会很慢，因为测试用例中有极端测试用例。<br>
为了应对极端测试用例，使得递归树加深，可以在循环一开始的时候，随机交换第 1 个元素与它后面的任意 1 个元素的位置；<br>
说明：最极端的是顺序数组与倒序数组，此时递归树画出来是链表，时间复杂度是 O(N^2)，根本达不到减治的效果。</p>
</blockquote>
<p>参考代码 3：<br>
随机选取元素</p>
<pre><code>import java.util.Random;

public class Solution {

    private static Random random = new Random(System.currentTimeMillis());

    public int findKthLargest(int[] nums, int k) {
        int len = nums.length;
        int target = len - k;
        int left = 0;
        int right = len - 1;
        while (true) {
            int index = partition(nums, left, right);
            if (index &lt; target) {
                left = index + 1;
            } else if (index &gt; target) {
                right = index - 1;
            } else {
                return nums[index];
            }
        }
    }

    // 在区间 [left, right] 这个区间执行 partition 操作

    private int partition(int[] nums, int left, int right) {
        // 在区间随机选择一个元素作为标定点
        if (right &gt; left) {
            int randomIndex = left + 1 + random.nextInt(right - left);
            swap(nums, left, randomIndex);
        }

        int pivot = nums[left];
        int j = left;
        for (int i = left + 1; i &lt;= right; i++) {
            if (nums[i] &lt; pivot) {
                j++;
                swap(nums, j, i);
            }
        }
        swap(nums, left, j);
        return j;
    }

    private void swap(int[] nums, int index1, int index2) {
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp;
    }
} 
</code></pre>
<blockquote>
<p>2、使用双指针，将与 pivot 相等的元素等概论地分到 pivot 最终排定位置的两边。<br>
参考代码 4：使用双指针的办法找到切分元素的位置。</p>
</blockquote>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

class Solution {
private:
    int partition(vector&lt;int&gt; &amp;nums, int left, int right) {
        // 随机在 [left, right] 中, 选择一个数值作为标定点 pivot
        swap(nums[left], nums[rand() % (right - left + 1) + left]);

        int pivot = nums[left];
        while (left &lt; right) {
            while (left &lt; right &amp; nums[right] &gt;= pivot) {
                right--;
            }
            nums[left] = nums[right];
            while (left &lt; right &amp; nums[left] &lt; pivot) {
                left++;
            }
            nums[right] = nums[left];
        }
        nums[left] = pivot;
        return left;
    }

public:
    int findKthLargest(vector&lt;int&gt; &amp;nums, int k) {
        int size = nums.size();
        int target = size - k;

        int left = 0;
        int right = size - 1;
        while (true) {
            int p = partition(nums, left, right);
            if (p == target) {
                return nums[p];
            } else if (target &lt; p) {
                right = p - 1;
            } else {
                left = p + 1;
            }
        }
    }
};

</code></pre>
<blockquote>
<p>方法三：优先队列<br>
优先队列的思路是很朴素的。因为第 K 大元素，其实就是整个数组排序以后后半部分最小的那个元素。因此，我们可以维护一个有 K 个元素的最小堆：<br>
1、如果当前堆不满，直接添加；<br>
2、堆满的时候，如果新读到的数小于等于堆顶，肯定不是我们要找的元素，只有新都到的数大于堆顶的时候，才将堆顶拿出，然后放入新读到的数，进而让堆自己去调整内部结构。<br>
说明：这里最合适的操作其实是 replace，即直接把新读进来的元素放在堆顶，然后执行下沉（siftDown）操作。Java 当中的 PriorityQueue 没有提供这个操作，只好先 poll() 再 offer()。<br>
优先队列的写法就很多了，这里例举一下我能想到的（以下的写法大同小异，没有本质差别）。<br>
假设数组有 len 个元素。<br>
思路1：把 len 个元素都放入一个最小堆中，然后再 pop() 出 len - k 个元素，此时最小堆只剩下 k 个元素，堆顶元素就是数组中的第 k 个最大元素。<br>
思路2：把 len 个元素都放入一个最大堆中，然后再 pop() 出 k - 1 个元素，因为前 k - 1 大的元素都被弹出了，此时最大堆的堆顶元素就是数组中的第 k 个最大元素。<br>
根据以上思路，分别写出下面的代码：<br>
参考代码 5：</p>
</blockquote>
<pre><code>Java
import java.util.PriorityQueue;

public class Solution {

    public int findKthLargest(int[] nums, int k) {
        int len = nums.length;
        // 使用一个含有 len 个元素的最小堆，默认是最小堆，可以不写 lambda 表达式：(a, b) -&gt; a - b
        PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;(len, (a, b) -&gt; a - b);
        for (int i = 0; i &lt; len; i++) {
            minHeap.add(nums[i]);
        }
        for (int i = 0; i &lt; len - k; i++) {
            minHeap.poll();
        }
        return minHeap.peek();
    }
}
</code></pre>
<blockquote>
<p>参考代码 6：</p>
</blockquote>
<pre><code>Java
import java.util.PriorityQueue;

public class Solution {

    public int findKthLargest(int[] nums, int k) {
        int len = nums.length;
        // 使用一个含有 len 个元素的最大堆，lambda 表达式应写成：(a, b) -&gt; b - a
        PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;(len, (a, b) -&gt; b - a);
        for (int i = 0; i &lt; len; i++) {
            maxHeap.add(nums[i]);
        }
        for (int i = 0; i &lt; k - 1; i++) {
            maxHeap.poll();
        }
        return maxHeap.peek();
    }
}
</code></pre>
<blockquote>
<p>思路 3：只用 k 个容量的优先队列，而不用全部 len 个容量。<br>
参考代码 7：</p>
</blockquote>
<pre><code>import java.util.PriorityQueue;

public class Solution {

    public int findKthLargest(int[] nums, int k) {
        int len = nums.length;
        // 使用一个含有 k 个元素的最小堆
        PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;(k, (a, b) -&gt; a - b);
        for (int i = 0; i &lt; k; i++) {
            minHeap.add(nums[i]);
        }
        for (int i = k; i &lt; len; i++) {
            // 看一眼，不拿出，因为有可能没有必要替换
            Integer topEle = minHeap.peek();
            // 只要当前遍历的元素比堆顶元素大，堆顶弹出，遍历的元素进去
            if (nums[i] &gt; topEle) {
                minHeap.poll();
                minHeap.add(nums[i]);
            }
        }
        return minHeap.peek();
    }
}
</code></pre>
<blockquote>
<p>思路 4：用 k + 1 个容量的优先队列，使得上面的过程更“连贯”一些，到了 k 个以后的元素，就进来一个，出去一个，让优先队列自己去维护大小关系。</p>
</blockquote>
<pre><code>import java.util.PriorityQueue;

public class Solution5 {
    public int findKthLargest(int[] nums, int k) {
        int len = nums.length;
        // 最小堆
        PriorityQueue&lt;Integer&gt; priorityQueue = new PriorityQueue&lt;&gt;(k + 1, (a, b) -&gt; (a - b));
        for (int num : nums) {
            priorityQueue.add(num);
            if (priorityQueue.size() == k + 1) {
                priorityQueue.poll();
            }
        }
        return priorityQueue.peek();
    }
}
</code></pre>
<blockquote>
<p>思路 5：综合考虑以上两种情况，总之都是为了节约空间复杂度。即 k 较小的时候使用最小堆，k 较大的时候使用最大堆。、</p>
</blockquote>
<pre><code>import java.util.PriorityQueue;

public class Solution {

    // 根据 k 的不同，选最大堆和最小堆，目的是让堆中的元素更小
    // 思路 1：k 要是更靠近 0 的话，此时 k 是一个较大的数，用最大堆
    // 例如在一个有 6 个元素的数组里找第 5 大的元素
    // 思路 2：k 要是更靠近 len 的话，用最小堆

    // 所以分界点就是 k = len - k

    public int findKthLargest(int[] nums, int k) {
        int len = nums.length;
        if (k &lt;= len - k) {
            // System.out.println(&quot;使用最小堆&quot;);
            // 特例：k = 1，用容量为 k 的最小堆
            // 使用一个含有 k 个元素的最小堆
            PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;(k, (a, b) -&gt; a - b);
            for (int i = 0; i &lt; k; i++) {
                minHeap.add(nums[i]);
            }
            for (int i = k; i &lt; len; i++) {
                // 看一眼，不拿出，因为有可能没有必要替换
                Integer topEle = minHeap.peek();
                // 只要当前遍历的元素比堆顶元素大，堆顶弹出，遍历的元素进去
                if (nums[i] &gt; topEle) {
                    minHeap.poll();
                    minHeap.add(nums[i]);
                }
            }
            return minHeap.peek();

        } else {
            // System.out.println(&quot;使用最大堆&quot;);
            assert k &gt; len - k;
            // 特例：k = 100，用容量为 len - k + 1 的最大堆
            int capacity = len - k + 1;
            PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;(capacity, (a, b) -&gt; b - a);
            for (int i = 0; i &lt; capacity; i++) {
                maxHeap.add(nums[i]);
            }
            for (int i = capacity; i &lt; len; i++) {
                // 看一眼，不拿出，因为有可能没有必要替换
                Integer topEle = maxHeap.peek();
                // 只要当前遍历的元素比堆顶元素大，堆顶弹出，遍历的元素进去
                if (nums[i] &lt; topEle) {
                    maxHeap.poll();
                    maxHeap.add(nums[i]);
                }
            }
            return maxHeap.peek();
        }
    }
}
</code></pre>
<p>思路五降低空间复杂度的思维很值得学习，我本来以为大顶堆不适用，但是其实找第k大的数字也就是找第len-k+1小的数，此时如果len-k+1小于k的话完全可以用大顶堆来降低空间复杂度</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ [Linux基础] 系统服务 (daemons) （鸟哥Linux第十七章）]]></title>
        <id>https://lixin-ee.github.io//post/linux-ji-chu-xi-tong-fu-wu-daemons-niao-ge-linux-di-shi-qi-zhang</id>
        <link href="https://lixin-ee.github.io//post/linux-ji-chu-xi-tong-fu-wu-daemons-niao-ge-linux-di-shi-qi-zhang">
        </link>
        <updated>2020-01-09T13:15:09.000Z</updated>
        <content type="html"><![CDATA[<p>这个题目我纠结了许久，最后还是用的系统服务<br>
虽然鸟哥这本书的用词用语和大陆差得太远了，但是daemons翻译成系统服务确实比守护进程略微好一点，一开始我还以为守护进程是保证安全的函数。。。</p>
<ul>
<li>系统服务 (daemons)简介<br>
『常驻在记体体中的程序，且可以提供一些系统或网络功能，那就是服务』<br>
系统为了某些功能必须要提供一些服务 (不论是系统本身还是网络方面)，这个服务就称为service 。<br>
达成这个service的<strong>程序</strong>我们就称呼他为 daemon</li>
</ul>
<p>早期的Unix系统核心第一个启动的程序是 init ， 然后 init 去唤起所有的系统所需要的服务<br>
后来改用 systemd 启动服务管理机制</p>
<p>systemd 将过去所谓的 daemon 执行脚本通通称为一个服务单位 (unit)，而每种服务单位 依据功能来区分时，就分类为不同的类型 (type)。<br>
基本的类型有包括系统服务、数据监听与交换的插槽档服务 (socket)、储存系统状态的快照类型、提供不同类似执行等级分类的操作环境 (target) 等</p>
<p>配置文件都放置在底下的目录中：<br>
/usr/lib/systemd/system/：每个服务最主要的启动脚本设定，有点类似以前的 /etc/init.d 底下的文件；<br>
/run/systemd/system/：系统执行过程中所产生的服务脚本，这些脚本的优先序要比 /usr/lib/systemd/system/ 高<br>
/etc/systemd/system/：管理员依据主机系统的需求所建立的执行脚本</p>
<p>systemd 的 unit 类型分类：主要靠扩展 名来区分上述所谓的不同的类型 (type)</p>
<ul>
<li>透过 systemctl 管理服务<br>
systemd 这个启动服务的机制，主要是透过一只名为 systemctl 的指令来处理，注意， systemd 就是仅有 systemctl 这个处理指令<br>
一般来说，服务的启动有两个阶段，一 个是『开机的时候设定要不要启动这个服务』， 以及『你现在要不要启动这个服务』<br>
<code>[root@study ~]# systemctl [command] [unit]</code><br>
command 主要有：<br>
start ：立刻启动后面接的 unit<br>
stop ：立刻关闭后面接的 unit<br>
restart ：立刻关闭后启动后面接的 unit，亦即执行 stop 再 start 的意思<br>
reload ：不关闭后面接的 unit 的情况下，重载配置文件，让设定生效<br>
enable ：设定下次开机时，后面接的 unit 会被启动<br>
disable ：设定下次开机时，后面接的 unit 不会被启动<br>
status ：目前后面接的这个 unit 的状态，会列出有没有正在执行、开机预设执行否、登录等信息等！<br>
is-active ：目前有没有正在运作中<br>
is-enable ：开机时有没有预设要启用这个 unit<br>
mask：注销服务<br>
unmask：取消注销</li>
</ul>
<p>注意不应该使用 kill 的方式来关掉一个正常的服务！否则 systemctl 会无法继续监控该服务的</p>
<p>status 的Active除了running 跟 dead 之外，基本上还有几个常见的状态：<br>
active (running)：正有一只或多只程序正在系统中执行的<br>
active (exited)：仅执行一次就正常结束的服务，目前并没有任何程序在系统中执行。 通常用 bash shell 写的小型服务，大多是属于这种类型 (无须常驻内存)。<br>
active (waiting)：正在执行当中，不过还再等待其他的事件才能继续处理。举例来说，打印的队列相关服务就是这种状态<br>
inactive：这个服务目前没有运作的意思。</p>
<p>status 的Load状态除了 enable/disable之外，还有：<br>
enabled：这个 daemon 将在开机时被执行<br>
disabled：这个 daemon 在开机时不会被执行<br>
static：这个 daemon 不可以自己启动 (enable 不可)，不过可能会被其他的 enabled 的服务来唤醒 (相依属性的服务)<br>
mask：这个 daemon 无论如何都无法被启动！因为已经被强制注销 (非删除)</p>
<p>很多服务彼此之间是有相依性的,所以关闭一个服务可能会连带着关闭多个服务</p>
<ul>
<li>透过 systemctl 观察系统上所有的服务<br>
上一小节谈到的是单一服务的启动/关闭/观察，以及相依服务要注销的功能。那系统上面有多少的服务存在等任务就得要透过 list-units 及 list-unit-files 来观察了<br>
<code>[root@study ~]# systemctl [command] [ [--type=TYPE] [ --all]</code><br>
command:<br>
list-units ：依据 unit 列出目前有启动的 unit。若加上 --all 才会列出没启动的。<br>
list-unit-files ：依据 /usr/lib/systemd/system/ 内的文件，将所有文件列表说明。<br>
--type=TYPE：就是之前提到的 unit type，主要有 service, socket, target 等</li>
</ul>
<p>list-units（默认） 输出列表中各项主要的意义是：<br>
UNIT ：项目的名称，包括各个 unit 的类别 (看扩展名)<br>
LOAD ：开机时是否会被加载，默认 systemctl 显示的是有加载的项目而已<br>
ACTIVE ：目前的状态，须与后续的 SUB 搭配，就是我们用 systemctl status 观察时active 的项目<br>
DESCRIPTION ：详细描述啰</p>
<p>systemctl list-unit-files 会将系统上所有的服务通通列出来～而不像 list-units 仅以 unit 分类作大致的说明。列表中的 STATE 状态就是前两个小节谈到的开机是否会加载的那个状态项目，主要有enabled / disabled / mask / static 等等。</p>
<ul>
<li>透过 systemctl  管理不同的操作环境 (target unit)<br>
<code>[root@study ~]# systemctl [command] [unit.target]</code><br>
选项与参数：<br>
command:<br>
get-default ：取得目前的 target<br>
set-default ：设定后面接的 target 成为默认的操作模式<br>
isolate       ：切换到后面接的模式</li>
</ul>
<p>CentOS 7.1 的预设情况下，就有 26 个 target unit，而跟操作界面相关性比较高的target 主要有底下几个：<br>
graphical.target：就是文字加上图形界面，这个项目已经包含了底下的 multi-user.target 项目<br>
multi-user.target：纯文本模式<br>
rescue.target：在无法使用 root 登入的情况下，systemd 在开机时会多加一个额外的暂时系统，与你原本的系统无关。这时你可以取得 root 的权限来维护你的系统。 但是这是额外系统，因此可能需要动到 chroot 的方式来取得你原有的系统喔<br>
emergency.target：紧急处理系统的错误，还是需要使用 root 登入的情况，在无法使用 rescue.target 时，可以尝试使用这种模式<br>
shutdown.target：就是关机的流程。<br>
getty.target：可以设定你需要几个 tty 之类的，如果想要降低 tty 的项目，可以修改这个东西的配置文件</p>
<p>在正常的切换情况下，使用上述 isolate 的方式即可。不过为了方便起见，systemd 也提供了数个简单的指令给我们切换操作模式之用<br>
systemctl poweroff 系统关机<br>
systemctl reboot 重新启动<br>
systemctl suspend 进入暂停模式<br>
systemctl hibernate 进入休眠模式<br>
systemctl rescue 强制进入救援模式<br>
systemctl emergency 强制进入紧急救援模式</p>
<ul>
<li>
<p>透过 systemctl  分析各服务之间的相依<br>
<code>[root@study ~]# systemctl list-dependencies [unit] [ --reverse]</code><br>
选项与参数：<br>
--reverse ：反向追踪谁使用这个 unit</p>
</li>
<li>
<p>与 systemd  的 daemon 运作过程相关的目录简介<br>
/usr/lib/systemd/system/：<br>
默认的启动脚本配置文件都放在这里，这里的数据尽量不要修改<br>
/run/systemd/system/：<br>
系统执行过程中所产生的服务脚本<br>
/etc/systemd/system/：<br>
管理员依据主机系统的需求所建立的执行脚本<br>
/etc/sysconfig/* ：<br>
几乎所有的服务都会将初始化的一些选项设定写入到这个目录下<br>
/var/lib/：<br>
一些会产生数据的服务都会将他的数据写入到 /var/lib/ 目录中。<br>
/run/：<br>
放置了好多 daemon 的暂存档，包括 lock file 以及 PID file 等等。</p>
</li>
</ul>
<p>通过<code>[root@study ~]# systemctl list-socket</code>查询 socket file 放置在哪里</p>
<ul>
<li>
<p>网络服务与端口口对应简介<br>
主机是透过端口号 (port number) 分辨不同的服务要求<br>
/etc/services 指定了服务与哪个端口对应，可以直接用<code>cat /etc/services</code>查询</p>
</li>
<li>
<p>关闭网络服务<br>
会产生一个网络监听端口 (port) 的程序，就可以称为网络服务<br>
可以通过  <code>systemctl stop[unit]</code>或者<code>systemctl disable [unit]</code> 来关闭</p>
</li>
<li>
<p>systemctl  针对 service 类型的配置文件<br>
systemctl 配置文件的设定项目简介<br>
整个设定分为三个部份，就是：<br>
[Unit]： unit 本身的说明，以及与其他相依 daemon 的设定，包括在什么服务之后才启动此 unit 之类的设<br>
定值；<br>
[Service], [Socket], [Timer], [Mount], [Path]..：不同的 unit type 就得要使用相对应的设定项目。我们拿的是<br>
sshd.service 来当模板，所以这边就使用 [Service] 来设定。 这个项目内主要在规范服务启动的脚本、环境<br>
配置文件档名、重新启动的方式等等。<br>
[Install]：这个项目就是将此 unit 安装到哪个 target 里面去</p>
</li>
</ul>
<p>配置文件内有些设定规则还是得要说明一下：<br>
设定项目通常是可以重复的，例如我可以重复设定两个 After 在配置文件中，不过，后面的设定会取代前面，因此，如果你想要将设定值归零， 可以使用类似『 After= 』的设定，亦即该项目的等号后面什么都没有，就将该设定归零了 (reset)。<br>
如果设定参数需要有『是/否』的项目 (布尔值, boolean)，你可以使用 1, yes, true, on 代表启动，用 0, no, false,off 代表关闭<br>
空白行、开头为 # 或 ; 的那一行，都代表批注</p>
<p>systemctl  针对 timer   的配置文件</p>
<p>CentOS 7.x 预设启动的服务简易说明<br>
使用 systemctl list-unit-files--type=service 查询<br>
部分服务上简易说明<br>
dovecot<br>
( 网络)可以设定 POP3/IMAP 等收受信件的服务，如果你的 Linux 主机是 email server 才需要这个服务，否则不需要启动<br>
httpd ( 网络)<br>
这个服务可以让你的 Linux 服务器成为 www server 喔！<br>
named<br>
( 网络)这是领域名服务器 (Domain Name System) 的服务， 这个服务非常重要，但是设定非常困难，目前应该不需要这个服务<br>
nfs nfs-server<br>
( 网络)这就是 Network Filesystem，是 Unix-Like 之间互相作为网络驱动器机的一个功能。<br>
smb<br>
nmb<br>
( 网络)这个服务可以让 Linux 仿真成为 Windows 上面的网络上的芳邻。 如果你的 Linux 主机想要<br>
做为 Windows 客户端的网络驱动器机服务器，这玩意儿得要好好玩一玩。<br>
vsftpd ( 网络)作为文件传输服务器 (FTP) 的服务。<br>
sshd<br>
( 网络)这个是远程联机服务器的软件功能， 这个通讯协议比 telnet 好的地方在于 sshd 在传送资料时可以进行加密，这个服务不要关闭<br>
rpcbind ( 网络)达成 RPC 协议的重要服务，包括 NFS, NIS 等等都需要这东西的协助<br>
postfix<br>
( 网络)寄件的邮件主机～因为系统还是会产生很多 email 讯息，例如 crond / atd 就会传送 email给本机用户！ 所以这个服务千万不能关，即使你不是 mail server 也是要启用这服务才行</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UNP-UNIX网络编程 第四章]]></title>
        <id>https://lixin-ee.github.io//post/unp-unix-wang-luo-bian-cheng-di-si-zhang</id>
        <link href="https://lixin-ee.github.io//post/unp-unix-wang-luo-bian-cheng-di-si-zhang">
        </link>
        <updated>2020-01-09T12:45:33.000Z</updated>
        <content type="html"><![CDATA[<p>主要讲述编写一个完整的TCP客户/服务器程序所需要的基本套接字函数<br>
并发服务器：它是在同时有大量的客户连接到同一服务器上时用于提供并发性的一种常用Unix技术。每个客户连接都迫使服务器为它派生（fork） 一个新的进程。</p>
<p><img src="https://lixin-ee.github.io//post-images/1578574785629.png" alt=""></p>
<ul>
<li>socket 函数<br>
为了执行网络I/O, 一个进程必须做的第一件事情就是调用socket函数，指定期望的通信协议类型</li>
</ul>
<pre><code>#include &lt;sys/socket.h&gt;
int socket （int family, int type, int protocol）;
</code></pre>
<p>返回：若成功则为非负描述符，若出错则为-1<br>
family参数指明协议族，type 参数指明套接字类型，protocol参数应设为图4-4所示的某个协议 类型常值，或者设为0,以选择所给定family和type组合的系统默认值。<br>
<img src="https://lixin-ee.github.io//post-images/1578574917564.png" alt=""><br>
<img src="https://lixin-ee.github.io//post-images/1578574720688.png" alt=""><br>
socket函数在成功时返回一个小的非负整数值，它与文件描述符类似，我们把它称为套接字描述符（socket descriptor）,简称sockfd。<br>
我们并没有指定本地协议地址或远程协议地址<br>
AF_XXX 和 PF_XXX，AF_前缀表示地址族，PF一前缀表示协议族</p>
<ul>
<li>connect 函数<br>
TCP客户用connect函数来建立与TCP服务器的连接。</li>
</ul>
<pre><code>#include &lt;sys/socket.h&gt;
int connect （int sockfd, const struct sockaddr *servaddr, socklen_t addrlen）;
</code></pre>
<p>sockfd是由socket函数返回的套接字描述符，第二个、第三个参数分别是一个指向套接字地址结构的指针和该结构的大小<br>
套接字地址结构必须含有服务器的IP地址和端口号。<br>
<strong>客户</strong>在调用函数connect前不必非得调用bind函数，因为如果 需要的话，内核会确定源IP地址，并选择一个临时端口作为源端口。<br>
如果是TCP套接字，调用connect函数将激发TCP的三路握手过程<br>
其中连接出错返回可能有以下几种情况<br>
（1）	若TCP客户没有收到SYN分节的响应，则返回ETIMEDOUT错误。<br>
（2）	若对客户的SYN的响应是RST （表示复位），则表明该服务器主机在我们指定的端口上 没有进程在等待与之连接（例如服务器进程也许没在运行）。这是一种硬错误（hard error）.客户一接收到RST就马上返回ECONNREFUSED错误。<br>
RST是TCP在发生错误时发送的一种TCP分节。产生RST的三个条件是：目的地为某端口的 SYN到达，然而该端口上没有正在监听的服务器（如前所述）；TCP想取消一个己有连接；TCP 接收到一个根本不存在的连接上的分节。<br>
（3）若客户发出的SYN在中间的某个路由器上引发了一个“destination unreachable &quot;（目的地 不可达）ICMP错误，则认为是一种软错误（soft error）<br>
客户主机内核保存该消息，并按第一种情况中所述的时间间隔继续发送SYN。若在某个规定的时间（4.4BSD规定75s）后仍未收到响应，则把保存的消息（即ICMP错误）作为EHOSTUNREACH或ENETUNREACH错误返回给进程。<br>
以下两种情形也是有可能的：一是按照本地系统的转发表，根本没有到达远程系统的路径；二是 connect调用根本不等待就返回。</p>
<p>注意区分情况2和情况3，一个是到达了目的地址，但是不存在相应的端口，一个是根本没法到达目的地址</p>
<p><strong>注意！！！</strong><br>
若connect失败则该<strong>套接字不再可用，必须关闭</strong>，我们<strong>不能对这样的套接字再次调用connect函数</strong>。当循环调用函数connect为给定主机尝试 各个IP地址直到有一个成功时，在每次connect失败后，都必须close当前的套接字描述符并重新调用socket。</p>
<ul>
<li>bind 函数<br>
bind函数把一个本地协议地址赋予一个套接字，其中协议地址是32位的IPv4地址与16位的TCP或UDP端口号的组合。</li>
</ul>
<pre><code>#include &lt;sys/socket.h&gt;
int bind（int sockfd, const struct sockaddr *myaddr, socklen_t addrlen）；
返回：若成功则为0,若出错则为-1
</code></pre>
<p>第二个参数是一个指向特定于协议的地址结构的指针，第三个参数是该地址结构的长度。 对于TCP,调用bind函数可以指定一个端口号，或指定一个IP地址，也可以两者都指定，还可以都不指定。</p>
<p>1.服务器在启动时捆绑它们的众所周知端口<br>
2.如果一个TCP客户或服务器未曾调用bind捆绑一个端口，当调用connect或listen时，内核就要为相应的 套接字选择一个临时端口。让内核来选择临时端口对于TCP客户来说是正常的，对于TCP服务器来说却极为罕见。<br>
3.进程可以把一个特定的IP地址捆绑到它的套接字上，不过这个IP地址必须属于其所在主机的网络接口之一。<br>
4.客户通常不把IP地址捆绑到它的套接字上。当连接套接字时，内核将根据所用外出网络 接口来选择源IP地址，而所用外出接口则取决于到达服务器所需的路径。<br>
5.如果TCP服务器没有把IP地址捆绑到它的套接字上，内核就把客户发送的SYN的目的IP 地址作为服务器的源IP地址</p>
<p>调用bind可以指定IP地址或端口，可以两者都指定，也可以都不指定。图<br>
4-6汇总了如何根据预期的结果，设置sin_addr和sin_port的值。<br>
<img src="https://lixin-ee.github.io//post-images/1578746168950.png" alt=""><br>
如果指定端口号为0,那么内核就在bind被调用时选择一个临时端口。然而如果指定IP地 址为通配地址，那么内核将等到套接字<strong>已连接</strong>（TCP）或己在套接字上<strong>发出数据报</strong>（UDP）时 才选择一个本地IP地址。<br>
对于IPv4来说，通配地址由常值INADDR_ANY来指定，其值一般为0。它告知内核去选择IP地址。<br>
struct sockaddr_in servaddr；<br>
servaddr.sin_addr.s_addr = htonl（INADDR_ANY）;	/* wildcard*/<br>
如果让内核来为套接字选择一个临时端口号，那么必须注意，函数bind<strong>并不返回所选择的值</strong>。实际上，由于bind函数的第二个参数有const限定词，它无法返回所选之值。为了得到内核所选择的这个临时端口值，必须调用<strong>函数getsockname</strong>来返回协议地址。</p>
<ul>
<li>listen 函数<br>
listen函数仅由TCP服务器调用，它做两件事情。<br>
(1)	当<strong>socket函数</strong>创建一个套接字时，它被假设为一个<strong>主动套接字</strong>，也就是说，它是一个将调用connect发起连接的客户套接字。<strong>listen函数</strong>把一个未连接的套接字转换成一个<strong>被动套接字</strong>，指示内核应接受指向该套接字的<strong>连接请求</strong>。根据TCP状态转换图〈图2-4),调用listen 导致套接字从CLOSED状态转换到LISTEN状态。<br>
(2)	本函数的第二个参数规定了内核应该为相应套接字<strong>排队</strong>的最大连接个数。</li>
</ul>
<pre><code>#include &lt;sys/socket.h&gt;
int listen (int sockfd, int backlog)；
	返回：若成功则为0,若出错则为-1
</code></pre>
<p>在调用socket和bind这两个函数<strong>之后</strong>，并在调用accept函数之前<strong>调用</strong>。</p>
<p>backlog参数并非任意设置，必须认识到内核为任何一个给定的监听套接字维护两个 队列：<br>
(1)	未完成连接队列(incomplete connection queue),每个这样的SYN分节对应其中一项： 已由某个客户发出并到达服务器，而服务器正在等待完成相应的TCP三路握手过程。这些套接字处于SYN_RCVD状态(图2-4)。<br>
(2)	已完成连接队列(completed connection queue),每个已完成TCP三路握手过程的客户对 应其中一项。这些套接字处于ESTABLISHED状态(图2-4)。<br>
<img src="https://lixin-ee.github.io//post-images/1578746600887.png" alt=""><br>
<img src="https://lixin-ee.github.io//post-images/1578746644512.png" alt=""><br>
当来自客户的<strong>SYN</strong>到达时，TCP在<strong>未完成连接队列</strong>中创建一个新项，然后响应以三路握手的第二个分节：服务器的SYN响应，其中捎带对客户SYN的ACK 。这一项一直保留在未完成连接队列中，直到三路握手的第三个分节（客户对服务器<strong>SYN的ACK</strong>）到达或者该项超时为止。<br>
如果三路握手正常 完成，该项就从未完成连接队列移到已完成连接队列的队尾。当进程调用accept时（该函数在 下一节讲解），已完成连接队列中的队头项将返回给进程，或者如果该队列为空，那么进程将被投入睡眠，直到TCP在该队列中放入一项才唤醒它。</p>
<p>关于backlog的注意事项<br>
• listen函数的backlog参数曾被规定为这两个队列总和的最大值。<br>
• 不要把由backlog定义为0,因为不同的实现对此有不同的解释。如果你不想让任 何客户连接到你的监听套接字上，那就关掉该监听套接字。<br>
• 在三路握手正常完成的前提下（也就是说没有丢失分节，从而没有重传），未完成连接 队列中的任何一项在其中的存留时间就是一个RTT,<br>
• 当一个客户SYN到达时，若这些队列是满的，TCP就忽略该分节， 也就是不发送RST。这么做是因为：这种情况是暂时的，客户TCP将重发SYN,期望不久就能在这些队列中找到可用空间。<br>
要是服务器TCP立即响应以一个RST,客户的 connect调用就会立即返回一个错误，强制应用进程处理这种情况，而不是让TCP的正 常重传机制来处理。另外，客户<strong>无法区别响应SYN的RST</strong>究竟意味着“该端口没有服务器在监听”，还是意味着“该端口有服务器在监听，不过它的队列满了”<br>
•在三路握手完成之后，但在服务器调用accept之前到达的<strong>数据</strong>应由服务器TCP排队，最 大数据量为相应已连接套接字的<strong>接收缓冲区</strong>大小。</p>
<p>SYN泛滥（SYN flooding）：以高速率给受害主机发送SYN的程序，用以强行塞爆一个或多个TCP端口的未完成连接队列</p>
<ul>
<li>accept 函数<br>
accept函数由TCP服务器调用，用于从已完成连接队列队头返回下一个己完成连接。如果已完成连接队列为空，那么进程被投入睡眠（假定套接字为默认的阻塞方式）。</li>
</ul>
<pre><code>#include &lt;sys/socket.h&gt;
int accept （int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen）；
返回：若成功则为非负描述符，若出错则为-1
</code></pre>
<p>参数cloaddr和addrlen用来返回已连接的对端进程（客户）的协议地址。addrlen是值-结果参数：调用前，我们将由* addrlen所引用的整数值置为由<strong>cliaddr所指的套接字地址结构的长度</strong>，返回时，该整数值即为由内核存放在该套接字地址结构内的<strong>确切字节数</strong>。<br>
如果accept成功，那么其返回值是由内核自动生成的一个<strong>全新描述符</strong>，代表与所返回客户的TCP连接。在讨论accept函数时，我们称它的第一个参数为<strong>监听套接字（listening socket）描 述符</strong>（由socket创建，随后用作bind和listen的第一个参数的描述符），称它的返回值为<strong>已连接套接字（connected socket）描述符</strong>。区分这两个套接字非常重要。一个服务器通常<strong>仅仅创建一个监听套接字</strong>，它在该服务器的<strong>生命期内一直存在</strong>。内核为<strong>每个</strong>由服务器进程接受的客户连接创建一个<strong>已连接套接字</strong>（也就是说对于它的TCP三路握手过程已经完成）。当服务器完成对某个给定客户的服务时，相应的<strong>已连接套接字就被关闭</strong>。</p>
<p>注意，虽然是形参，但本函数最多返回三个值：一个既可能是新套接字描述符也可能是出错指示的整数、客户进程的协议地址（由cliaddr指针所指）以及该地址的大小（由addrlen指针所指）。如果我们对返回客户协议地址不感兴趣，那么可以把cliaddr和addrlen均置为空指针.</p>
<ul>
<li>fork 和 exec 函数<br>
fork函数是Unix中派生新进程的唯-方法</li>
</ul>
<pre><code>#include &lt;unistd.h&gt;
pid_t fork（void）;
返回:在子进程中为0,在父进程中为于进程ID,若出错则为-1
</code></pre>
<p>理解fork最困难之处在于调用它一次，它却返回两次。 它在调用进程（称为父进程）中返回一次，返回值是新派生进程（称为子进程）的进程ID号 <strong>(亦即子进程的ID)</strong>； 在子进程又返回一次，返回值为0<br>
因此，<strong>返回值本身告知当前进程是子进程还是父进程</strong>。<br>
fork具有返回值的原因：子进程总是可以通过调用getppid取得父进程的进程ID。相反，父进程可以有许多子进程， 而且无法获取各个子进程的进程ID。如果父进程想要跟踪所有子进程的进程ID,那么它必须记 录每次调用fork的返回值。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 148. 排序链表[中等][未做出][值得手撕]]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-148-pai-xu-lian-biao-zhong-deng-wei-zuo-chu-zhi-de-shou-si</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-148-pai-xu-lian-biao-zhong-deng-wei-zuo-chu-zhi-de-shou-si">
        </link>
        <updated>2020-01-09T01:19:20.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。<br>
示例 1:<br>
输入: 4-&gt;2-&gt;1-&gt;3<br>
输出: 1-&gt;2-&gt;3-&gt;4<br>
示例 2:<br>
输入: -1-&gt;5-&gt;3-&gt;4-&gt;0<br>
输出: -1-&gt;0-&gt;3-&gt;4-&gt;5<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/sort-list<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>【未做出】【值得手撕】<br>
主要难点在于常数空间复杂度和时间复杂度之间的制约吧<br>
一开始甚至想交换val hhh<br>
nlogn的排序算法有堆排序 归并排序和快速排序<br>
堆排序虽然显示无需额外的空间，但是实际上只有在完全二叉树能够满足随机访问的情况下才能实现，也就是必须要数组下标 在链表中反而需要一次循环<br>
然后就是归并排序 归并排序的核心在于把两个序列合成一个序列 数组中需要额外的空间进行合并，但是链表的特性却可以省略这一部分，所以打算实现一下链表的归并排序<br>
首先我想到的难点在于需要一个保留一个头结点，然后因为无法使用随机下标，所以迭代的归并排序比递归的好</p>
<p>实现的过程中遇到了比较多细节问题，所以打算先参考一下网友题解的实现方法。主要就是分开merge 和 cut 两个函数进行合并和切割<br>
我一开始比较困惑tail的作用，一开始以为是没用的，但是后来才发现是大大的用处，因为cut切断后，merge创建一个ehead来自成一个链表，后面得串回来，就是利用tail-&gt;next串回来的<br>
注意tail虽然全程看起来只是对自身进行操作，但是链表的next指针特性决定了其当前值，所以并非所看到的的那么简单，一定动手画图了解<br>
然后merge返回值和cut返回值需要额外注意，merge返回值是一个头结点，需要和tail配合，这里的话其实可以优化返回一个尾节点直接串起来，但是相应地需要循环去找尾节点，其实差不多。cur的返回值是尾节点的下一节点，所以需要提前保存，因为要切断。<br>
然后就是对空节点的判断，代码中没有针对right为空的情况进行判断，而是主要利用不同位置的while进行间接判断，所以代码的整体性也很重要。</p>
<p>题解实现代码</p>
<pre><code>class Solution {
public:
    ListNode* sortList(ListNode* head) {
        ListNode *ehead=new ListNode(0);
        ehead-&gt;next=head;
        int step=1;
        int len=0;
        for(ListNode *p=head;p!=NULL;p=p-&gt;next)
            ++len;
        ListNode *cur=ehead-&gt;next,*tail=ehead;;
        while(step&lt;len){
            while(cur!=NULL){
                ListNode *left=cur;
                cur=cut(left,step);
                ListNode *right=cur;
                cur=cut(right,step);
                tail-&gt;next=merge(left,right);
                while (tail-&gt;next!=NULL) {
                    tail = tail-&gt;next;
                }
            }
            cur=ehead-&gt;next;
            tail=ehead;
            step*=2;
        }
        return ehead-&gt;next;
    }
		
	ListNode* cut(ListNode *cur,int step){
        while(--step&amp;&amp;cur)
            cur=cur-&gt;next;
        if(!cur) return cur;
        
        ListNode *temp=cur-&gt;next;
        cur-&gt;next=NULL;
        return temp;
    }
    
    ListNode* merge(ListNode *left,ListNode *right){
        ListNode *ehead=new ListNode(0);
        ListNode *cur=ehead;
        while(left&amp;&amp;right){
            if(left-&gt;val&lt;=right-&gt;val){
                cur-&gt;next=left;
                left=left-&gt;next;
            }else{
                cur-&gt;next=right;
                right=right-&gt;next;
            }
            cur=cur-&gt;next;         
        }
        cur-&gt;next=left?left:right;
        return ehead-&gt;next;
    }
</code></pre>
<p>然后来看看详细的网友题解：</p>
<blockquote>
<p>bottom-to-up 的归并思路是这样的：先两个两个的 merge，完成一趟后，再 4 个4个的 merge，直到结束。举个简单的例子：[4,3,1,7,8,9,2,11,5,6].<br>
step=1: (3-&gt;4)-&gt;(1-&gt;7)-&gt;(8-&gt;9)-&gt;(2-&gt;11)-&gt;(5-&gt;6)<br>
step=2: (1-&gt;3-&gt;4-&gt;7)-&gt;(2-&gt;8-&gt;9-&gt;11)-&gt;(5-&gt;6)<br>
step=4: (1-&gt;2-&gt;3-&gt;4-&gt;7-&gt;8-&gt;9-&gt;11)-&gt;5-&gt;6<br>
step=8: (1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;9-&gt;11)<br>
链表里操作最难掌握的应该就是各种断链啊，然后再挂接啊。在这里，我们主要用到链表操作的两个技术：<br>
merge(l1, l2)，双路归并，我相信这个操作大家已经非常熟练的，就不做介绍了。<br>
cut(l, n)，可能有些同学没有听说过，它其实就是一种 split 操作，即断链操作。不过我感觉使用 cut 更准确一些，它表示，将链表 l 切掉前 n 个节点，并返回后半部分的链表头。<br>
额外再补充一个 dummyHead 大法，已经讲过无数次了，仔细体会吧。<br>
希望同学们能把双路归并和 cut 断链的代码烂记于心，以后看到类似的题目能够刷到手软。<br>
掌握了这三大神器后，我们的 bottom-to-up 算法伪代码就十分清晰了：</p>
</blockquote>
<pre><code>current = dummy.next;
tail = dummy;
for (step = 1; step &lt; length; step *= 2) {
	while (current) {
		// left-&gt;@-&gt;@-&gt;@-&gt;@-&gt;@-&gt;@-&gt;null
		left = current;

		// left-&gt;@-&gt;@-&gt;null   right-&gt;@-&gt;@-&gt;@-&gt;@-&gt;null
		right = cut(current, step); // 将 current 切掉前 step 个头切下来。

		// left-&gt;@-&gt;@-&gt;null   right-&gt;@-&gt;@-&gt;null   current-&gt;@-&gt;@-&gt;null
		current = cut(right, step); // 将 right 切掉前 step 个头切下来。
		
		// dummy.next -&gt; @-&gt;@-&gt;@-&gt;@-&gt;null，最后一个节点是 tail，始终记录
		//                        ^
		//                        tail
		tail.next = merge(left, right);
		while (tail-&gt;next) tail = tail-&gt;next; // 保持 tail 为尾部
	}
}
</code></pre>
<blockquote>
<p>下面是比较正式的代码。</p>
</blockquote>
<pre><code>class Solution {
public:
    ListNode* sortList(ListNode* head) {
        ListNode dummyHead(0);
        dummyHead.next = head;
        auto p = head;
        int length = 0;
        while (p) {
            ++length;
            p = p-&gt;next;
        }
        
        for (int size = 1; size &lt; length; size &lt;&lt;= 1) {
            auto cur = dummyHead.next;
            auto tail = &amp;dummyHead;
            
            while (cur) {
                auto left = cur;
                auto right = cut(left, size); // left-&gt;@-&gt;@ right-&gt;@-&gt;@-&gt;@...
                cur = cut(right, size); // left-&gt;@-&gt;@ right-&gt;@-&gt;@  cur-&gt;@-&gt;...
                
                tail-&gt;next = merge(left, right);
                while (tail-&gt;next) {
                    tail = tail-&gt;next;
                }
            }
        }
        return dummyHead.next;
    }
    
    ListNode* cut(ListNode* head, int n) {
        auto p = head;
        while (--n &amp;&amp; p) {
            p = p-&gt;next;
        }
        
        if (!p) return nullptr;
        
        auto next = p-&gt;next;
        p-&gt;next = nullptr;
        return next;
    }
    
    ListNode* merge(ListNode* l1, ListNode* l2) {
        ListNode dummyHead(0);
        auto p = &amp;dummyHead;
        while (l1 &amp;&amp; l2) {
            if (l1-&gt;val &lt; l2-&gt;val) {
                p-&gt;next = l1;
                p = l1;
                l1 = l1-&gt;next;       
            } else {
                p-&gt;next = l2;
                p = l2;
                l2 = l2-&gt;next;
            }
        }
        p-&gt;next = l1 ? l1 : l2;
        return dummyHead.next;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[接口和函数的区别]]></title>
        <id>https://lixin-ee.github.io//post/jie-kou-he-han-shu-de-qu-bie</id>
        <link href="https://lixin-ee.github.io//post/jie-kou-he-han-shu-de-qu-bie">
        </link>
        <updated>2020-01-08T23:56:06.000Z</updated>
        <content type="html"><![CDATA[<p>以前我以为接口就是给客户调用的函数，看了muduo和设计模式后才发现不是这样的<br>
以简单工厂模式为例子，接口就可以是算法派生出来的加减乘除法这个都是给客户调用的接口，实现了特定的功能<br>
而muduo中提出不要用设计模式中使用虚函数提供接口的方法，因为虚函数的正确调用完全依赖与virtual table的offset，一改动二进制兼容就木大了<br>
然后注意虚函数不是纯虚函数，不用子类必须override，而是子类可以选择性根据自身实现的功能进行override</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ UNP-UNIX网络编程 第三章]]></title>
        <id>https://lixin-ee.github.io//post/unp-unix-wang-luo-bian-cheng-di-san-zhang</id>
        <link href="https://lixin-ee.github.io//post/unp-unix-wang-luo-bian-cheng-di-san-zhang">
        </link>
        <updated>2020-01-08T12:57:36.000Z</updated>
        <content type="html"><![CDATA[<p>套接字地址结构从进程到内核和从内核到进程。<br>
地址转换函数在地址的文本表达和它们存放在套接字地址结构中的二进制值之间进行转换。<br>
地址转换函数在地址的文本表达和它们存放在套接字地址结构中的二进制值之间进行转换。多数现存的IPv4代码使用inet_addr和inet_ntoa这两个函数，不过两个新函数inet_pton 和i net_ntop同时适用于IPv4和IPv6两种代码。</p>
<p>注意 本书中为了克服函数对于IPv4和IPv6两种协议的协议相关问题，开发了一组名字以sock_开头的函数，它们以协议无关方式使用套接字地址结构。并贯穿全书使用这组函数。</p>
<ul>
<li>IPv4套接字地址结构<br>
IPv4套接字地址结构通常也称为&quot;网际套接字地址结构”，它以sockaddr_in命名，定义在 &lt;netinet/in.h&gt;头文件中。<br>
<img src="https://lixin-ee.github.io//post-images/1578488858968.png" alt=""><br>
POSIX规范只需要设置这个结构中的3个字段：<strong>sin_family, sin_addr和sin_port。</strong><br>
相对应地，他们的类型是：<br>
sa_family_t可以是任何无符号整数类型，通常是一个8位的无符号整数<br>
in_addr_t数据 类型必须是一个至少32位的无符号整数类型<br>
in_port_t必须是-个至少16位的无符号 整数类型<br>
<img src="https://lixin-ee.github.io//post-images/1578489062325.png" alt=""></li>
</ul>
<p>注意！IPv4地址和TCP或UDP端口号在套接字地址结构中总是以<strong>网络字节序（大端序）</strong> 来存储。<br>
32位IPv4地址存在<strong>两种不同的访问方法</strong>。<br>
举例来说，如果serv定义为某个网际套接字地址结构，那么serv. sin_addr将按<strong>in_addr结构</strong>引用其中的32位IPv4地址，而serv.sin_addr.s_addr将按<strong>in_addr_t整数</strong>（通常是一个无符号的32位整数）引用同—个32位IPv4地址。因此，我们必须正确地使用IPv4地址，尤其是在将它作为函数的参数时， 因为编译器对<strong>传递结构</strong>和<strong>传递整数</strong>的处理是完全不同的。<br>
套接字地址结构仅在给定主机上使用：虽然结构中的某些字段（例如IP地址和端口号） 用在不同主机之间的通信中，但是结构本身并不在主机之间传递。</p>
<ul>
<li>
<p>值-结果参数<br>
当往一个套接字<strong>函数</strong>传递一个套接字地址<strong>结构</strong>时，该结构总是以<strong>引用</strong>形式来 传递，也就是说传递的是指向该结构的一个<strong>指针</strong>。该结构的长度也作为一个参数来传递，不过其传递方式取决于该结构的<strong>传递方向</strong>：是从进程到内核，还是从内核到进程。<br>
(1)	从进程到内核传递套接字地址结构的函数有3个：bind、connect和sendto。这些函数 的一个参数是指向某个套接字地址结构的指针，另一个参数是该结构的整数大小（套接字地址结构大小的数据类型实际上是socklen.t,而不是int）<br>
(2)	从内核到进程传递套接字地址结构的函数有4个：accepts、recvfrom、getsockname 和getpeernameo。这4个函数的其中两个参数是指向某个套接字地址结构的指针和指向表示该结构大小的整数变量的指针。<br>
<img src="https://lixin-ee.github.io//post-images/1578489792892.png" alt=""><br>
注意！！！函数调用时，结构大小<strong>只是一个希望的值</strong>，当函数返回时，结构大小又是一个<strong>实际大小的结果(result)</strong>,它告诉进程内核在该结构中<strong>究竞存储了多少信息</strong>。这种类型的参数称为值-结果(value-result)参数。</p>
</li>
<li>
<p>字节排序函数、大端序、小端序<br>
小端 和 大端 表示多个字节值的哪一端(小端或大端)存储在该值的起始 地址.<br>
低序字节存储在起始地址，这称为小端（little-endian）字节序；<br>
另一种方法是将高序字节存储在起 始地址，这称为大端（big-endian）字节序。<br>
<strong>记忆方法</strong>：大端序就是我们日常的<strong>书写顺序</strong>（在纸上（内存）写一个数字，先写高位再写地位），小端序则是反过来</p>
</li>
</ul>
<p>当前系统所用的字节序称为主机字节序(host byte order)<br>
<img src="https://lixin-ee.github.io//post-images/1578490222230.png" alt=""><br>
网络协议必须指定一个网络字节序（network byte order），网际协议使用<strong>大端字节序</strong>来传送这些多字节整数。<br>
套接字地址结构中的某些字 段必须按照网络字节序进行维护。<br>
两种字节序之间的转换使用以下4个函数。<br>
<img src="https://lixin-ee.github.io//post-images/1578490503887.png" alt=""><br>
h代表host, n代表network, s代表short, l代表long</p>
<p>注意：当使用这些函数时，我们并不关心主机字节序和网络字节序的真实值（或为大端，或为小端）。我们所要做的只是调用适当的函数在主机和网络字节序之间转换某个给定值。在那些与网际协议所用字节序（大端）相同的系统中，这四个函数通常被定义为空宏。（一句话，为求保险（优雅地说是提高可移植性），默认调用转换就完事了）</p>
<ul>
<li>
<p>字节操纵函数<br>
操纵多字节字段的函数有两组，主要用于处理套接字地址<strong>结构</strong>（原因是结构并不全是字符串）<br>
<img src="https://lixin-ee.github.io//post-images/1578490776599.png" alt=""><br>
本书中我们只使用bzero，bzero把目标字节串中指定数目的字节置为0。我们经常使用该函数来把一个<strong>套接字地址结构</strong>初始化为0。<br>
bcopy将指定数目的字节从源字节串移到目标字节串。bcmp比较两个任意的字节 串，若相同则返回值为0,否则返回值为非0。<br>
<img src="https://lixin-ee.github.io//post-images/1578490880005.png" alt=""><br>
memset把目标字节串指定数目的字节置为值c。memcpy类似bcopy,不过两个指针参数的顺序是相反的。<br>
memcmp比较两个任意的字节串，若相同则返回0,否则返回一个非0值，是大于0还是小于0 则取决于第一个不等的字节</p>
</li>
<li>
<p>inet_aton、inet_addr 和 inet_ntoa 函数<br>
函数名中a和n分别代表ASCII和数值(numeric)<br>
地址转换函数：在ASCII字符串与网络字节序的二进制值之间转换网际地址。<br>
（1）inet_aton、inet_addr 和 inet_ntoa在点分十进制数组（例如&quot;206.168. 112.96&quot;） 与它长度为32位的网络字节序二进制值间转换IPv4地址。<br>
（2）	两个较新的函数inet_pton和inet_ntop对于IPv4地址和IPv6地址都适用。<br>
<img src="https://lixin-ee.github.io//post-images/1578491193169.png" alt=""><br>
inet_aton将strptr所指C字符串转换成一个32位的网络字节序二进制值，并通过指针addrptr来存储。若成功返回1,否则返回0。（如果addrptr指针为空，那么该函数仍 然对输入的字符串执行有效性检查，但是不存储任何结果）<br>
inet_ntoa函数将一个32位的网络字节序二进制IPv4地址转换成相应的点分十进制数串。 由该函数的返回值所指向的字符串驻留在静态内存中。这意味着该函数是<strong>不可重入</strong>的<br>
<strong>（inet_addr已被废弃，新的代码应该改用inet_aton函数）</strong> inet_addr进行相同的转换，返回值为32位的网络字节序二进制值。当出错时该函 数返回INADDR_NONE常值（通常是一个<strong>32位均为1的值</strong>）。这意味着点分十进制数串 255.255.255.255 （这是IPv4的有限广播地址）不能由该函数处理，因为它的二进制值被用来指示该函数失败。</p>
</li>
<li>
<p>inet pton 和 inet ntop 函数<br>
函数名中p和n分别代表表达(presentation)和数值(numeric)<br>
地址的表达格式通常是ASCII字符串，数值格式则是存放到套接字地址结构中的二进制值。<br>
<img src="https://lixin-ee.github.io//post-images/1578491510912.png" alt=""><br>
这两个函数family参数既可以是AF_INET,也可以是AF_INET6。如果以不被支持的地址族作为family参数,这两个函数就都返回一个错误，并将errno置为EAFNOSUPPORT。<br>
第一个函数尝试转换由strptr指针所指的字符串，并通过odd中addrptr指针存放二进制结果。成 功则返回值为1,否则返回 值为0。<br>
inet_ntop进行相反的转换，从数值格式(addrptr)转换到表达格式(strptr)。<br>
len参数是目标存储单元的大小，以免该函数溢出其调用者的缓冲区。如果len太小，不足以容纳表达格式结果(包括结尾的空字符)，那么返回一个空指针，并置errno为ENOSPC。<br>
inet_ntop函数的strptr参数不可以是一个空指针。调用者必须为目标存储单元分配内存并指定其大小。调用成功时，这个指针就是该函数的返回值。<br>
<img src="https://lixin-ee.github.io//post-images/1578491749818.png" alt=""></p>
</li>
<li>
<p>sock_ntop和相关函数<br>
inet_ntop的一个基本问题是：它要求调用者传递一个指向某个二进制地址的指针，而该 地址通常包含在一个套接字地址结构中，这就要求调用者必须知道这个结构的格式和地址族。这就使得我们的代码与协议相关了。<br>
为了解决这个问题，我们将自行编写一个名为sockntop的函数，它以指向某个套接字地 址结构的指针为参数，查看该结构的内部，然后调用适当的函数返回该地址的表达格式。<br>
<img src="https://lixin-ee.github.io//post-images/1578491955024.png" alt=""><br>
sockaddr指向一个长度为addrlen的套接字地址结构，本函数用它自己的静态缓冲区来保存 结果，而指向该缓冲区的一个指针就是它的返回值。<br>
<strong>对结果进行静态存储导致该函数不可重入且非线程安全.</strong></p>
</li>
</ul>
<p>书中还为操作套接字地址结构定义了其他几个函数，它们将简化我们的代码在IPv4与IPv6 之间的移植。<br>
<img src="https://lixin-ee.github.io//post-images/1578492138671.png" alt=""><br>
<img src="https://lixin-ee.github.io//post-images/1578492154760.png" alt=""></p>
<ul>
<li>readn, writen 和 readline 函数<br>
字节流套接字（例如TCP套接字）上的read和write函数所表现的行为不同于通常的文件 I/O。经常会出现输入或输出的字节数可能<strong>比请求的数量少</strong>，原因在于内核中用于套接字的缓冲区可能已达到了极限。此时所需的 是调用者<strong>多次调用</strong>read或write函数，以输入或输出剩余的字节。<br>
这个现象在read一个字节流套接字时很常 见，但是在write 一个字节流套接字时只能在该套接字为<strong>非阻塞</strong>的前提下才出现。（阻塞情况下一直阻塞知道发送完成）<br>
书中为了防止出现这种情况 ，不让实现返回一个不足的字节计数值，编写了writen函数来取代write函数。<br>
当出现输入或输出的字节数少于请求字节数时，会产生ETNTR错误（表示系统调用被一个捕获的信号中断） ，如果发生该错误则继续进行readn, writen 的读或写操作。<br>
注意，如果每读一个字节的数据就调用一次系统的read函数。这是非常低效 率的，但是不能因此改用标准I/O函数库（称为stdio），究其原因在于stdio提供的默认缓冲区的状态是不可见 的</li>
</ul>
<p>良好的防御 性编程（defensiveprogramming）技术要求这些程序不仅能够期望它们的对端程序也遵循相同的 网络协议，而且能够检查出未预期的网络数据传送并加以修正（恶意企图自然也被检查出来）， 这样使得网络应用能够从存在问题的网络数据传送中恢复，可能的话还会继续工作。</p>
<p>所以在readn中使用stdio来缓冲数据提升 性能违背了这些目标，这样的应用进程在任何时刻都没有办法分辨 stdio缓冲区中是否持有未预期的数据。<br>
所以！<strong>依照缓冲区而不是文本行的要求来考虑编程</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 238. 除自身以外数组的乘积 [中等][未做出]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-238-chu-zi-shen-yi-wai-shu-zu-de-cheng-ji-zhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-238-chu-zi-shen-yi-wai-shu-zu-de-cheng-ji-zhong-deng-wei-zuo-chu">
        </link>
        <updated>2020-01-07T14:34:36.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。<br>
示例:<br>
输入: [1,2,3,4]<br>
输出: [24,12,8,6]<br>
说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。<br>
进阶：<br>
你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/product-of-array-except-self<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>【未做出】<br>
第一眼：很简单嘛，利用前一个的值不就行了嘛！然后突然发现不能用除法hhh<br>
然后第二个难点在于线性时间复杂度，那就说明不能每个元素单独进行计算，比如1的时候算2x3x4 2的时候算1x3x4。必须把计算结果重复利用起来</p>
<p>完全没思路啊！！！时间复杂度一直没想好是怎么降低到线性，而且也没有常数空间复杂度的想法，好菜啊！！！<br>
偷看题解发现是左积和右积？<br>
不是很懂<br>
看完题解后才发现太秀了吧<br>
我有一个问题是忘了使用输出数组这个空间和线性时间复杂度不一定是一次n，可以多次n的嘛<br>
不过题解的思想确实是很巧妙<br>
然后我在复现题解的时候用了for范围语句和for+迭代器，结果忘了要同时读取res和nums，结果全部木大hhh。下标发看起来很复杂但还是最通用的</p>
<p>网友题解实现</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) {
        int len=nums.size();
        vector&lt;int&gt; res(len,1);
        int k=1;
        for(auto i=0;i&lt;len;++i){
            res[i]=res[i]*k;
            k*=nums[i];
        }
        k=1;
        for(auto i=len-1;i&gt;=0;--i){
            res[i]=res[i]*k;
            k*=nums[i];
        }
        return res;
    }
};
</code></pre>
<p>网友题解<br>
乘积 = 当前数左边的乘积 * 当前数右边的乘积</p>
<pre><code>class Solution {
    public int[] productExceptSelf(int[] nums) {
        int[] res = new int[nums.length];
        int k = 1;
        for(int i = 0; i &lt; res.length; i++){
            res[i] = k;
            k = k * nums[i]; // 此时数组存储的是除去当前元素左边的元素乘积
        }
        k = 1;
        for(int i = res.length - 1; i &gt;= 0; i--){
            res[i] *= k; // k为该数右边的乘积。
            k *= nums[i]; // 此时数组等于左边的 * 该数右边的。
        }
        return res;
    }
}
</code></pre>
]]></content>
    </entry>
</feed>