<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-11-09T12:37:36.646Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[写树算法的套路框架]]></title>
        <id>https://lixin-ee.github.io//post/xie-shu-suan-fa-de-tao-lu-kuang-jia</id>
        <link href="https://lixin-ee.github.io//post/xie-shu-suan-fa-de-tao-lu-kuang-jia">
        </link>
        <updated>2019-11-09T12:36:19.000Z</updated>
        <content type="html"><![CDATA[<p>解题思路：<br>
二叉树算法 设计的总路线：明确一个节点要做的事情，然后剩下的事抛给框架。</p>
<pre><code>void traverse(TreeNode root) {
    // root 需要做什么？在这做。
    // 其他的不用 root 操心，抛给框架
    traverse(root.left);
    traverse(root.right);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 100. 相同的树[简单]]]></title>
        <id>https://lixin-ee.github.io//post/shu-100-xiang-tong-de-shu-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/shu-100-xiang-tong-de-shu-jian-dan">
        </link>
        <updated>2019-11-09T11:58:46.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定两个二叉树，编写一个函数来检验它们是否相同。<br>
如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。<br>
示例 1:<br>
输入:   1         1<br>
/ \       / <br>
2   3     2   3<br>
[1,2,3],   [1,2,3]<br>
输出: true<br>
示例 2:<br>
输入:   1          1<br>
/           <br>
2             2<br>
[1,2],     [1,null,2]<br>
输出: false<br>
示例 3:<br>
输入:    1         1<br>
/ \       / <br>
2   1     1   2<br>
[1,2,1],   [1,1,2]<br>
输出: false<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/same-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题的难点在于如果单纯地分开判断前中后序的遍历顺序的话是无法得到结果的，只有<br>
1、同时遍历前序<br>
2、利用前序+中序或者中序+后序可以唯一确定一棵二叉树（注意，前序+后序无法唯一确定一棵二叉树）</p>
<p>我还是使用了第一种方法，并且使用递归，会方便很多，主要的难点就在于应付三种情况<br>
1.两者同时为NULL<br>
2.两者其一为NULL<br>
同时因为使用迭代法，所以需要使用一个函数外的bool变量作为返回值</p>
<p>最后代码为：</p>
<pre><code>class Solution {
bool res=true;
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(p==NULL&amp;&amp;q==NULL)
            return res;
        if(p==NULL||q==NULL&amp;&amp;!(p==NULL&amp;&amp;q==NULL)){
            res=false;
            return res;
        }
        if(p-&gt;val!=q-&gt;val){
            res=false;
            return res;
        } 
        isSameTree(p-&gt;left, q-&gt;left);
        isSameTree(p-&gt;right, q-&gt;right);
        return res;
    }
};
</code></pre>
<p>然后来看一下官方题解</p>
<blockquote>
<p>方法一：递归<br>
直觉<br>
最简单的策略是使用递归。首先判断 p 和 q 是不是 None，然后判断它们的值是否相等。<br>
若以上判断通过，则递归对子结点做同样操作。</p>
</blockquote>
<pre><code>class Solution {
  public boolean isSameTree(TreeNode p, TreeNode q) {
    // p and q are both null
    if (p == null &amp;&amp; q == null) return true;
    // one of p and q is null
    if (q == null || p == null) return false;
    if (p.val != q.val) return false;
    return isSameTree(p.right, q.right) &amp;&amp;
            isSameTree(p.left, q.left);
  }
}
</code></pre>
<p>官网题解这里比我好很多，特别是返回值的处理，我用了一个全局变量，但是官方题解直接返回</p>
<blockquote>
<p>方法二：迭代<br>
直觉<br>
从根开始，每次迭代将当前结点从双向队列中弹出。然后，进行方法一中的判断：<br>
p 和 q 不是 None,<br>
p.val 等于 q.val,<br>
若以上均满足，则压入子结点。</p>
</blockquote>
<pre><code>class Solution {
 public boolean check(TreeNode p, TreeNode q) {
   // p and q are null
   if (p == null &amp;&amp; q == null) return true;
   // one of p and q is null
   if (q == null || p == null) return false;
   if (p.val != q.val) return false;
   return true;
 }

 public boolean isSameTree(TreeNode p, TreeNode q) {
   if (p == null &amp;&amp; q == null) return true;
   if (!check(p, q)) return false;

   // init deques
   ArrayDeque&lt;TreeNode&gt; deqP = new ArrayDeque&lt;TreeNode&gt;();
   ArrayDeque&lt;TreeNode&gt; deqQ = new ArrayDeque&lt;TreeNode&gt;();
   deqP.addLast(p);
   deqQ.addLast(q);

   while (!deqP.isEmpty()) {
     p = deqP.removeFirst();
     q = deqQ.removeFirst();

     if (!check(p, q)) return false;
     if (p != null) {
       // in Java nulls are not allowed in Deque
       if (!check(p.left, q.left)) return false;
       if (p.left != null) {
         deqP.addLast(p.left);
         deqQ.addLast(q.left);
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 : O(N)，其中 N 是树的结点数，因为每个结点都访问一次。<br>
空间复杂度 : 最优情况（完全平衡二叉树）时为 O(log(N))，最坏情况下（完全不平衡二叉树）时为 O(N)，用于维护双向队列。</p>
</blockquote>
<p>网友解析：第二种方法是层次遍历的非递归算法</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 102. 二叉树的层次遍历[中等]]]></title>
        <id>https://lixin-ee.github.io//post/shu-102-er-cha-shu-de-ceng-ci-bian-li-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/shu-102-er-cha-shu-de-ceng-ci-bian-li-zhong-deng">
        </link>
        <updated>2019-11-08T11:53:23.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。<br>
例如:<br>
给定二叉树: [3,9,20,null,null,15,7],<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7<br>
返回其层次遍历结果：</p>
</blockquote>
<pre><code>[
  [3],
  [9,20],
  [15,7]
]
</code></pre>
<blockquote>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这里我想复杂了，老是想着如何去把指针移动到同层，其实官方题解就特别简单<br>
如何遍历一棵树<br>
有两种通用的遍历树的策略：<br>
深度优先搜索（DFS）<br>
在这个策略中，我们采用深度作为优先级，以便从跟开始一直到达某个确定的叶子，然后再返回根到达另一个分支。<br>
深度优先搜索策略又可以根据根节点、左孩子和右孩子的相对顺序被细分为先序遍历，中序遍历和后序遍历。<br>
宽度优先搜索（BFS）<br>
我们按照高度顺序一层一层的访问整棵树，高层次的节点将会比低层次的节点先被访问到。<br>
下图中的顶点按照访问的顺序编号，按照 1-2-3-4-5 的顺序来比较不同的策略。<br>
<img src="https://lixin-ee.github.io//post-images/1573214236442.png" alt=""><br>
本问题就是用宽度优先搜索遍历来划分层次：[[1], [2, 3], [4, 5]]。</p>
<p>方法 1：递归<br>
算法<br>
最简单的解法就是递归，首先确认树非空，然后调用递归函数 helper(node, level)，参数是当前节点和节点的层次。程序过程如下：</p>
<p>输出列表称为 levels，当前最高层数就是列表的长度 len(levels)。比较访问节点所在的层次 level 和当前最高层次 len(levels) 的大小，如果前者更大就向 levels 添加一个空列表。<br>
将当前节点插入到对应层的列表 levels[level] 中。<br>
递归非空的孩子节点：helper(node.left / node.right, level + 1)。</p>
<pre><code>class Solution {
    List&lt;List&lt;Integer&gt;&gt; levels = new ArrayList&lt;List&lt;Integer&gt;&gt;();

    public void helper(TreeNode node, int level) {
        // start the current level
        if (levels.size() == level)
            levels.add(new ArrayList&lt;Integer&gt;());

         // fulfil the current level
         levels.get(level).add(node.val);

         // process child nodes for the next level
         if (node.left != null)
            helper(node.left, level + 1);
         if (node.right != null)
            helper(node.right, level + 1);
    }
    
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
        if (root == null) return levels;
        helper(root, 0);
        return levels;
    }
}
</code></pre>
<p>复杂度分析<br>
时间复杂度：O(N)，因为每个节点恰好会被运算一次。<br>
空间复杂度：O(N)，保存输出结果的数组包含 N 个节点的值。</p>
<p>方法 2：迭代<br>
算法<br>
上面的递归方法也可以写成迭代的形式。<br>
我们将树上顶点按照层次依次放入队列结构中，队列中元素满足 FIFO（先进先出）的原则。在 Java 中可以使用 Queue 接口中的 LinkedList实现。在 Python 中如果使用 Queue 结构，但因为它是为多线程之间安全交换而设计的，所以使用了锁，会导致性能不佳。因此在 Python 中可以使用 deque 的 append() 和 popleft() 函数来快速实现队列的功能。<br>
第 0 层只包含根节点 root ，算法实现如下：<br>
初始化队列只包含一个节点 root 和层次编号 0 ： level = 0。<br>
当队列非空的时候：<br>
在输出结果 levels 中插入一个空列表，开始当前层的算法。<br>
计算当前层有多少个元素：等于队列的长度。<br>
将这些元素从队列中弹出，并加入 levels 当前层的空列表中。<br>
将他们的孩子节点作为下一层压入队列中。<br>
进入下一层 level++。<br>
实现</p>
<pre><code>class Solution {
  public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
    List&lt;List&lt;Integer&gt;&gt; levels = new ArrayList&lt;List&lt;Integer&gt;&gt;();
    if (root == null) return levels;

    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();
    queue.add(root);
    int level = 0;
    while ( !queue.isEmpty() ) {
      // start the current level
      levels.add(new ArrayList&lt;Integer&gt;());

      // number of elements in the current level
      int level_length = queue.size();
      for(int i = 0; i &lt; level_length; ++i) {
        TreeNode node = queue.remove();

        // fulfill the current level
        levels.get(level).add(node.val);

        // add child nodes of the current level
        // in the queue for the next level
        if (node.left != null) queue.add(node.left);
        if (node.right != null) queue.add(node.right);
      }
      // go to next level
      level++;
    }
    return levels;
  }
}
</code></pre>
<p>复杂度分析<br>
时间复杂度：O(N)，因为每个节点恰好会被运算一次。<br>
空间复杂度：O(N)，保存输出结果的数组包含 N 个节点的值。</p>
<p>我的第一个实现：</p>
<pre><code>class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; vi;
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {
        leveladd(root,0);
        return vi;
    }
    void leveladd(TreeNode* cur,int level){
        if(cur==NULL)
            return;
        if(level==vi.size())
            vi.push_back(vector&lt;int&gt;());
        vi[level].push_back(cur-&gt;val);
        leveladd(cur-&gt;left,level+1);
        leveladd(cur-&gt;right,level+1);
        return;
    }  
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树 前中后遍历（144、94、145）]]></title>
        <id>https://lixin-ee.github.io//post/er-cha-shu-qian-zhong-hou-bian-li-14494145</id>
        <link href="https://lixin-ee.github.io//post/er-cha-shu-qian-zhong-hou-bian-li-14494145">
        </link>
        <updated>2019-11-08T07:59:03.000Z</updated>
        <content type="html"><![CDATA[<p>这三道题都是大话数据结构里面有的，所以复习一遍大话然后将代码用c++仿真一遍。<br>
<strong>先序遍历</strong></p>
<blockquote>
<p>144 二叉树的前序遍历<br>
给定一个二叉树，返回它的 前序 遍历。</p>
<p>示例:<br>
输入: [1,null,2,3]<br>
1<br>
<br>
2<br>
/<br>
3</p>
<p>输出: [1,2,3]<br>
进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/binary-tree-preorder-traversal<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>递归</p>
<pre><code>class Solution {
vector&lt;int&gt; res;
public:
    vector&lt;int&gt; preorderTraversal(TreeNode* root) {
        if(root==NULL){
            return res;
        }else
            res.push_back(root-&gt;val);
        preorderTraversal(root-&gt;left);
        preorderTraversal(root-&gt;right);
        return res;
    }
};
</code></pre>
<p>算法复杂度<br>
时间复杂度：访问每个节点恰好一次，时间复杂度为 O(N) ，其中 N 是节点的个数，也就是树的大小。<br>
空间复杂度：取决于树的结构，最坏情况存储整棵树，因此空间复杂度是 O(N)。</p>
<p>官方题解：<br>
方法 2：莫里斯遍历<br>
方法基于 莫里斯的文章，可以优化空间复杂度。算法不会使用额外空间，只需要保存最终的输出结果。如果实时输出结果，那么空间复杂度是 O(1)O(1)。</p>
<p>算法<br>
算法的思路是从当前节点向下访问先序遍历的前驱节点，每个前驱节点都恰好被访问两次。<br>
首先从当前节点开始，向左孩子走一步然后沿着右孩子一直向下访问，直到到达一个叶子节点（当前节点的中序遍历前驱节点），所以我们更新输出并建立一条伪边 predecessor.right = root 更新这个前驱的下一个点。如果我们第二次访问到前驱节点，由于已经指向了当前节点，我们移除伪边并移动到下一个顶点。<br>
如果第一步向左的移动不存在，就直接更新输出并向右移动。</p>
<pre><code>class Solution {
  public List&lt;Integer&gt; preorderTraversal(TreeNode root) {
    LinkedList&lt;Integer&gt; output = new LinkedList&lt;&gt;();

    TreeNode node = root;
    while (node != null) {
      if (node.left == null) {
        output.add(node.val);
        node = node.right;
      }
      else {
        TreeNode predecessor = node.left;
        while ((predecessor.right != null) &amp;&amp; (predecessor.right != node)) {
          predecessor = predecessor.right;
        }

        if (predecessor.right == null) {
          output.add(node.val);
          predecessor.right = node;
          node = node.left;
        }
        else{
          predecessor.right = null;
          node = node.right;
        }
      }
    }
    return output;
  }
}
</code></pre>
<p>时间复杂度：每个前驱恰好访问两次，因此复杂度是 O(N)O(N)，其中 NN 是顶点的个数，也就是树的大小。<br>
空间复杂度：我们在计算中不需要额外空间，但是输出需要包含 NN 个元素，因此空间复杂度为 O(N)O(N)</p>
<p><strong>中序遍历</strong></p>
<blockquote>
<p>给定一个二叉树，返回它的中序 遍历。<br>
示例:<br>
输入: [1,null,2,3]<br>
1<br>
<br>
2<br>
/<br>
3<br>
输出: [1,3,2]<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/binary-tree-inorder-traversal<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<pre><code>class Solution {
vector&lt;int&gt; res;
public:
    vector&lt;int&gt; inorderTraversal(TreeNode* root) {
        if(root==NULL)
            return res;
        inorderTraversal(root-&gt;left);
        res.push_back(root-&gt;val);
        inorderTraversal(root-&gt;right);
        return res;   
    }
};
</code></pre>
<p>复杂度分析<br>
时间复杂度：O(n)。递归函数 T(n)=2⋅T(n/2)+1。<br>
空间复杂度：最坏情况下需要空间O(n)，平均情况为O(logn)。</p>
<p>下面是官方题解：<br>
方法二：基于栈的遍历<br>
本方法的策略与上衣方法很相似，区别是使用了栈。</p>
<pre><code>public class Solution {
    public List &lt; Integer &gt; inorderTraversal(TreeNode root) {
        List &lt; Integer &gt; res = new ArrayList &lt; &gt; ();
        Stack &lt; TreeNode &gt; stack = new Stack &lt; &gt; ();
        TreeNode curr = root;
        while (curr != null || !stack.isEmpty()) {
            while (curr != null) {
                stack.push(curr);
                curr = curr.left;
            }
            curr = stack.pop();
            res.add(curr.val);
            curr = curr.right;
        }
        return res;
    }
}
</code></pre>
<p>复杂度分析<br>
时间复杂度：O(n)。<br>
空间复杂度：O(n)。</p>
<p>方法三：莫里斯遍历<br>
本方法中，我们使用一种新的数据结构：线索二叉树。方法如下：<br>
Step 1: 将当前节点current初始化为根节点<br>
Step 2: While current不为空，<br>
若current没有左子节点<br>
a. 将current添加到输出<br>
b. 进入右子树，亦即, current = current.right<br>
否则<br>
a. 在current的左子树中，令current成为最右侧节点的右子节点<br>
b. 进入左子树，亦即，current = current.left<br>
举例而言:<br>
1<br>
/   <br>
2     3<br>
/ \   /<br>
4   5 6</p>
<p>首先，1 是根节点，所以将 current 初始化为 1。1 有左子节点 2，current 的左子树是</p>
<pre><code>     2
    / \
   4   5
</code></pre>
<p>在此左子树中最右侧的节点是 5，于是将 current(1) 作为 5 的右子节点。令 current = cuurent.left (current = 2)。<br>
现在二叉树的形状为:</p>
<pre><code>     2
    / \
   4   5
        \
         1
          \
           3
          /
         6
</code></pre>
<p>对于 current(2)，其左子节点为4，我们可以继续上述过程</p>
<pre><code>    4
     \
      2
       \
        5
         \
          1
           \
            3
           /
          6
</code></pre>
<p>由于 4 没有左子节点，添加 4 为输出，接着依次添加 2, 5, 1, 3 。节点 3 有左子节点 6，故重复以上过程。<br>
最终的结果是 [4,2,5,1,6,3]。</p>
<pre><code>class Solution {
    public List &lt; Integer &gt; inorderTraversal(TreeNode root) {
        List &lt; Integer &gt; res = new ArrayList &lt; &gt; ();
        TreeNode curr = root;
        TreeNode pre;
        while (curr != null) {
            if (curr.left == null) {
                res.add(curr.val);
                curr = curr.right; // move to next right node
            } else { // has a left subtree
                pre = curr.left;
                while (pre.right != null) { // find rightmost
                    pre = pre.right;
                }
                pre.right = curr; // put cur after the pre node
                TreeNode temp = curr; // store cur node
                curr = curr.left; // move cur to the top of the new tree
                temp.left = null; // original cur left be null, avoid infinite loops
            }
        }
        return res;
    }
}
</code></pre>
<p>复杂度分析<br>
时间复杂度：O(n)。 想要证明时间复杂度是O(n)，最大的问题是找到每个节点的前驱节点的时间复杂度。乍一想，找到每个节点的前驱节点的时间复杂度应该是 O(nlogn)，因为找到一个节点的前驱节点和树的高度有关。<br>
但事实上，找到所有节点的前驱节点只需要O(n) 时间。一棵 n 个节点的二叉树只有 n−1 条边，每条边只可能使用2次，一次是定位节点，一次是找前驱节点。<br>
故复杂度为O(n)。<br>
空间复杂度：O(n)。使用了长度为 n 的数组。</p>
<p><strong>后序遍历</strong><br>
给定一个二叉树，返回它的 后序 遍历。<br>
示例:<br>
输入: [1,null,2,3]<br>
1<br>
<br>
2<br>
/<br>
3</p>
<p>输出: [3,2,1]<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/binary-tree-postorder-traversal<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<pre><code>class Solution {
    vector&lt;int&gt; res;
public:
    vector&lt;int&gt; postorderTraversal(TreeNode* root) {
        if(root==NULL) 
            return res; 
        postorderTraversal(root-&gt;left);        
        postorderTraversal(root-&gt;right); 
        res.push_back(root-&gt;val); 
        return res; 
    }
};
</code></pre>
<p>官方迭代题解：<br>
方法 1：迭代<br>
算法<br>
从根节点开始依次迭代，弹出栈顶元素输出到输出列表中，然后依次压入它的所有孩子节点，按照从上到下、从左至右的顺序依次压入栈中。<br>
因为深度优先搜索后序遍历的顺序是从下到上、从左至右，所以需要将输出列表逆序输出。</p>
<pre><code>class Solution {
  public List&lt;Integer&gt; postorderTraversal(TreeNode root) {
    LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();
    LinkedList&lt;Integer&gt; output = new LinkedList&lt;&gt;();
    if (root == null) {
      return output;
    }

    stack.add(root);
    while (!stack.isEmpty()) {
      TreeNode node = stack.pollLast();
      output.addFirst(node.val);
      if (node.left != null) {
        stack.add(node.left);
      }
      if (node.right != null) {
        stack.add(node.right);
      }
    }
    return output;
  }
}
</code></pre>
<p>复杂度分析<br>
时间复杂度：访问每个节点恰好一次，因此时间复杂度为 O(N)，其中 N 是节点的个数，也就是树的大小。<br>
空间复杂度：取决于树的结构，最坏情况需要保存整棵树，因此空间复杂度为 O(N)。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于 无法解析的外部符号 的问题]]></title>
        <id>https://lixin-ee.github.io//post/guan-yu-wu-fa-jie-xi-de-wai-bu-fu-hao-de-wen-ti</id>
        <link href="https://lixin-ee.github.io//post/guan-yu-wu-fa-jie-xi-de-wai-bu-fu-hao-de-wen-ti">
        </link>
        <updated>2019-11-07T09:34:58.000Z</updated>
        <content type="html"><![CDATA[<p>在做课后题13.48的时候定义了自己的String，在编译的时候遇到上述问题<br>
报错分别为<code>error LNK2001: 无法解析的外部符号 &quot;private: static class std::allocator&lt;char&gt; String::alloc&quot;</code><br>
以及</p>
<pre><code>error C4996: 'std::uninitialized_copy::_Unchecked_iterators::_Deprecate': Call to 'std::uninitialized_copy' with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'
1&gt;  c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory(102): note: 参见“std::uninitialized_copy::_Unchecked_iterators::_Deprecate”的声明
</code></pre>
<p>网上找到的解决方案为<br>
首先，C4996这个问题，解决方案：<br>
1、打开project的属性<br>
2、打开c/c++目录<br>
3、点击预处理器<br>
4、在右侧表单中编辑第一条“预处理器定义”<br>
5、将报错提示中的问题填入，我的时_SCL_SECURE_NO_WARNINGS<br>
6、应用确认<br>
或者在头文件前加上：#pragma warning(disable:4996)</p>
<p>接着LNK2001 无法解析的外部符号 &quot;private: static class std::allocator：<br>
原因在于第26行<code>static allocator&lt;char&gt; alloc;</code>，类内静态变量未初始化，删去static或者在类外定义</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 21. 合并两个有序链表[简单]]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-21-he-bing-liang-ge-you-xu-lian-biao-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-21-he-bing-liang-ge-you-xu-lian-biao-jian-dan">
        </link>
        <updated>2019-11-07T01:50:31.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<p>示例：<br>
输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>
输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/merge-two-sorted-lists<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>其实这个在STL源码里面有说过，就是6.5.1 set_union，主要是判断两个链表当前值的大小，先把小的值放到新链表里，如果有一个链表走到尾端了立即停止循环并将另一链表直接接到新链表后面。</p>
<pre><code>class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if(l1==NULL)
            return l2;
        if(l2==NULL)
            return l1;
        ListNode* ehead=new ListNode(-1);
        ListNode* cur=ehead;
        while(l1!=NULL||l2!=NULL){
            if(l1-&gt;val&lt;=l2-&gt;val){
                cur-&gt;next=l1;
                l1=l1-&gt;next;
            }else{
                cur-&gt;next=l2;
                l2=l2-&gt;next;
            }
            cur=cur-&gt;next;
            if(l1==NULL){
                cur-&gt;next=l2;break;}
            if(l2==NULL){
                cur-&gt;next=l1;break;}
        }
        return ehead-&gt;next;
    }
};
</code></pre>
<p>当时做这道题的时候是在家里，没法对照着STL源码来写，对比了一下，主要的差异点在于<br>
1.最后接上链表的操作，其实可以直接两个都接上，因为肯定有一个为空，不需要判断两次<br>
2.set需要判断相等的情况，而链表不需要</p>
<p>然后看一下题解吧<br>
首先是递归的：<br>
思路<br>
标签：链表、递归<br>
这道题可以使用递归实现，新链表也不需要构造新节点，我们下面列举递归三个要素<br>
终止条件：两条链表分别名为 l1 和 l2，当 l1 为空或 l2 为空时结束<br>
返回值：每一层调用都返回排序好的链表头<br>
本级递归内容：如果 l1 的 val 值更小，则将 l1.next 与排序好的链表头相接，l2 同理O(m+n)，m 为 l1的长度，n 为 l2 的长度</p>
<pre><code>class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if(l1 == null) {
            return l2;
        }
        if(l2 == null) {
            return l1;
        }

        if(l1.val &lt; l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        } else {
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }
    }
}
</code></pre>
<p>复杂度分析</p>
<p>时间复杂度：O(n+m)。 因为每次调用递归都会去掉 l1 或者 l2 的头元素（直到至少有一个链表为空），函数 mergeTwoList 中只会遍历每个元素一次。所以，时间复杂度与合并后的链表长度为线性关系。</p>
<p>空间复杂度：O(n+m)。调用 mergeTwoLists 退出时 l1 和 l2 中每个元素都一定已经被遍历过了，所以n+m 个栈帧会消耗 O(n+m) 的空间。</p>
<p>方法 2：迭代<br>
想法<br>
我们可以用迭代的方法来实现上述算法。我们假设 l1 元素严格比 l2元素少，我们可以将 l2 中的元素逐一插入 l1 中正确的位置。</p>
<p>算法<br>
首先，我们设定一个哨兵节点 &quot;prehead&quot; ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 prev 指针，我们需要做的是调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：如果 l1 当前位置的值小于等于 l2 ，我们就把 l1 的值接在 prev 节点的后面同时将 l1 指针往后移一个。否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都把 prev 向后移一个元素。</p>
<p>在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表。</p>
<pre><code>class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode* prehead = new ListNode(-1);
        ListNode* prev = prehead;
        while(l1 != NULL &amp;&amp; l2 != NULL) {
            if(l1-&gt;val &lt;= l2-&gt;val) {
                prev-&gt;next = l1;
                l1 = l1-&gt;next;
            } else {
                prev-&gt;next = l2;
                l2 = l2-&gt;next;
            }
            prev = prev-&gt;next;
        }
        prev-&gt;next = l1 != NULL ? l1 : l2;

        return prehead-&gt;next;
    }
};
</code></pre>
<p>时间复杂度：O(n+m) 。因为每次循环迭代中，l1 和 l2 只有一个元素会被放进合并链表中， while 循环的次数等于两个链表的总长度。所有其他工作都是常数级别的，所以总的时间复杂度是线性的。<br>
空间复杂度：O(1) 。迭代的过程只会产生几个指针，所以它所需要的空间是常数级别的。</p>
<p>果然还是递归优雅一点hhh</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第十三章 笔记+习题 13.6]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-san-zhang-bi-ji-xi-ti-136</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-san-zhang-bi-ji-xi-ti-136">
        </link>
        <updated>2019-11-06T12:48:42.000Z</updated>
        <content type="html"><![CDATA[<p>13.6对象移动<br>
使用移动而不是拷贝的另一个原因源于<strong>IO类或unique_ptr等类不应该被拷贝</strong>，包含不能被共享的资源<br>
在旧标准中，没有直接的方法移动对象，在新标准中，我们可以<strong>用容器保存不可以拷贝</strong>的类型，只要它们能被<strong>移动</strong>即可<br>
标准库容器、string和shared_ptr类既支持移动也支持拷贝，<strong>IO类和unique_ptr类可以移动但不可以拷贝</strong></p>
<p>13.6.1右值引用<br>
为了<strong>支持移动操作</strong>，新标准引入了一种新的引用类型—<strong>右值引用</strong>，其有一个重要的性质，<strong>只能绑定到一个将要销毁的对象</strong>，因此我们可以自由地将一个<strong>右值引用的资源移动到另一个对象中</strong><br>
一般而言，一个<strong>左值表达式</strong>表示的是一个<strong>对象的身份</strong>，一个<strong>右值表达式</strong>表示的是<strong>对象的值</strong><br>
对于常规引用（即左值引用），我们<strong>不能</strong>将其绑定到要求<strong>转换的表达式、字面常量或是返回右值的表达式</strong>。而右值引用完全相反，我们可以将一个右值引用绑定到这类表达式上，但<strong>不能将一个右值引用直接绑定到一个左值上</strong>。</p>
<p>左值引用可用的表达式：返回左值引用的函数，赋值、下标、解引用和<strong>前置递增/递减运算符</strong><br>
右值引用可用的表达式：返回非引用类型的函数，算术、关系、位以及<strong>后置递增/递减运算符</strong><br>
但是我们可以将一个const的左值引用绑定到右值表达式中。<br>
左值表达式与右值表达式的区别：左值有持久的状态，右值要么是字面常量，要么是在表达式求值过程中创建的临时对象<br>
由于右值引用只能绑定到临时对象，所以<strong>1.所引用的对象将要被销毁2.该对象没有其他用户</strong>。这两个特性意味着使用右值引用的代码可以自由接管所引用的对象的资源<br>
右值引用指向将要被销毁的对象，因此，我们可以从绑定到右值引用的对象窃取状态<br>
<strong>变量</strong>可以看作<strong>只有一个运算对象而没有运算符的表达式</strong>，所以变量表达式都是左值 <strong>（导致右值引用本身是一个左值！）</strong></p>
<p>原因：变量是持久的，直至离开作用域才被销毁<br>
虽然不能将一个右值引用<strong>直接绑定</strong>到一个左值上，但可以<strong>显式</strong>地将一个<strong>左值</strong>转换为对应的<strong>右值引用</strong>类型，我们还可以用过调用一个名为move的新标准库函数来获得绑定到左值上的右值引用，move调用告诉编译器：我们有一个左值，但是我们希望像一个右值一样处理它，但<strong>对某个左值调用move后</strong>就意味着承诺除了对该左值进行<strong>赋值或销毁外不再使用它</strong><br>
int &amp;&amp;rr3 = std::move(rr1); //完成转移后，rr1为移后源对象，相当于一次移动<br>
调用move后，我们不<strong>能再对移后源对象</strong>rr1的值<strong>做任何假设</strong>，<strong>只能对其进行销毁或赋予新值</strong>，不能使用一个移后源对象的值<br>
对move不提供using声明，直接调用std::move而不是move，<strong>避免潜在的名字冲突</strong></p>
<p>习题13.45<br>
右值引用只能绑定到一个将要销毁的对象，表示的是对象的值，可以将其绑定到要求转换的表达式、字面常量或是返回右值的表达式。右值短暂，要么是字面常量，要么是在表达式求值过程中创建的临时对象<br>
习题13.46<br>
r1 f()返回一个非引用类型的int临时变量，只能用右值引用&amp;&amp;<br>
r2 下标符号返回的是左值， 只能用左值引用&amp;<br>
r3 r1是右值引用，但是本质上是一个变量，也就是一个左值，所以得用左值引用&amp;<br>
r4 两者习题相乘等于算术符号，只能用 右值引用<br>
习题13.47 13.48</p>
<pre><code>String::String(const String &amp;s) {
	auto newdata = alloc_n_copy(s.begin(), s.end());
	elements = newdata.first;
	first_free = cap = newdata.second;
	cout &lt;&lt; &quot;拷贝构造函数&quot; &lt;&lt; endl;
}

String&amp; String::operator=(const String &amp;rhs) {
	auto data = alloc_n_copy(rhs.begin(), rhs.end());
	free();
	elements = data.first;
	first_free = cap = data.second;
	cout &lt;&lt; &quot;拷贝赋值函数&quot; &lt;&lt; endl;
	return *this;
}
</code></pre>
<p>非常神奇，第一次拷贝的时候用了1次拷贝构造函数，第二次用了2次，第三次用了3次，第四次用了4次，第五次用了5次。。。和我的想象差距非常大，似乎每次push_back时都需要将每个元素注意地拷贝构造（为啥？）</p>
<p>13.6.2移动构造函数和移动赋值运算符<br>
移动构造函数的<strong>第一个参数</strong>是该类类型的一个<strong>引用</strong>，不同于拷贝构造函数，这个引用参数是一个<strong>右值引用</strong>，与拷贝构造函数一样，<strong>任何额外参数都必须有默认实参</strong><br>
移动构造函数必须保证移后源对象处于可销毁状态（销毁它是无害的）（对移后源对象<strong>赋值nullptr</strong>），特别是在资源完成移动后，必须保证源对象必须不再指向被移动的资源—这些资源的所有权已经归属新创建的对象<br>
移动构造函数<strong>不分配任何新内存</strong>，它接管原对象中的内存后，将<strong>给定对象中的指针</strong>都置为<strong>nullptr</strong>，从而完成从给定对象的移动操作，此对象将继续存在，移后源对象将会被销毁<br>
因为移动操作只是接管资源，通常不需要分配任何资源，因此移动操作<strong>通常不会抛出任何异常</strong>，但除非告诉标准库我们的移动构造函数不会抛出异常，否则它会认为移动我们的类对象时可能会抛出异常，并且为了处理这种可能性而做一些额外的工作<br>
<strong>noexcept是我们承诺一个函数不抛出异常</strong>的一种方法。我们在一个函数的参数列表后指定noexcept。在一个构造函数中，noexcept出现在<strong>参数列表和初始化列表开始的冒号之间</strong>，同时我们必须在类头文件的<strong>声明和定义</strong>中（<strong>定义在类外时</strong>）<strong>都指定</strong>noexcept<br>
如果<strong>不对移动构造函数显式声明noexcept，就会自动使用拷贝构造函数</strong>而不是移动构造函数<br>
<strong>移动赋值运算符也应该标记为noexcept</strong><br>
在移动赋值运算符中，我们<strong>首先检查</strong>左侧对象与右侧右值引用<strong>是否指向同一地址</strong>，如果<strong>相同则不要做任何操作</strong>（<strong>自赋值检查</strong>），否则，<strong>先释放左侧</strong>运算对象所使用的内存，并接管给定对象的内存<br>
从<strong>一个对象移动数据并不会销毁此对象</strong>，但当我们编写一个移动操作时，必须确保移后源对象<strong>进入一个可析构状态</strong>，除此之外，移动操作还必须保证移后源对象仍然是<strong>有效的（对象有效是指可以安全地为其赋予新值或者可以安全地使用而不依赖于当前值）</strong> 同时移动操作无法保证移后源对象中留下的值，所以我们的程序不应该依赖于移后源对象中的数据<br>
总结：在移动操作之后，移后源对象必须保持有效、可析构的状态，但是用户不能对其值进行任何假设<br>
<strong>编译器不会为某些类合成移动操作</strong>，特别是当一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，<strong>编译器就不会为它合成移动构造函数和移动赋值运算符，反而类会通过正常的函数匹配从而使用对应的拷贝操作来代替移动操作</strong><br>
<strong>只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符</strong>，编译器可以移动内置类型成员，如果一个成员是类类型，且该类有对应的移动操作，编译器也能移动这个成员<br>
与拷贝操作不同，<strong>移动操作永远不会隐式定义为删除的函数</strong>。但是如果我们显式地要求编译器生成=default的移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数<br>
将合成的移动操作定义为删除的函数遵循以下原则：</p>
<p><strong>如果类定义了移动操作，则也必须定义拷贝操作</strong>，否则<strong>拷贝操作</strong>都会默认地被<strong>定义为删除的</strong><br>
如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则<br>
来确定使用哪个构造函数，赋值操作的情况类似</p>
<p>如果一个类有一个拷贝构造函数但未定义移动构造函数，编译器不会合成移动构造函数，这意味着此类将有拷贝构造函数但不会有移动构造函数。如果一个类没有移动构造函数，函数匹配规则保证该类型的对象只会被拷贝，即使我们试图通过调用 move 來移动它们时也是如此<br>
值得注意的是，用拷贝构造函数代替移动构造函数几乎肯定是安全的</p>
<p>拷贝并交换赋值运算符和移动操作</p>
<p>对于同时定义了移动构造函数和拷贝构造函数的类，将其拷贝赋值运算符的参数改成非引用类型变为通用的赋值运算符，此时运算符有一个非引用参数.这意味着此参数要进行拷 贝初始化。依赖于实参的类型，拷贝初始化要么使用拷贝构造函数，要么使用移动构造函数——左值被拷贝，右值被移动。因此，单一的赋值运算符 就实现了拷贝赋值运算符和移动赋值运算符两种功能。</p>
<p>更新三/五法则<br>
所有五个应该看作一个整体：一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作，并且某些类必须定义拷贝构造函数、拷贝赋值运算符和析构函数才能正确工作<br>
移动迭代器<br>
新标准库中定义了一种移动迭代器（move iterator )适配器<br>
一个移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器<br>
一个普通迭代器的解引用运算符返回一个指向元素的左值。与其他迭代器不同，移动迭代器的，解引用运算符生成一个右值引用。<br>
通过调用标准库的 make_move_iterator 函数将一个普通迭代器转换为一个移动迭代器。此函数接受一个迭代器参数，返回一个移动迭代器。<br>
原迭代器的所有其他操作在移动迭代器中都照常工作。特别是，可以将移动迭代器传递给uninitialized_copy</p>
<p>uninitialized _ copy 对输入序列中的毎个元素调用 construct 来将元素&quot;拷贝&quot;到目的位置。此算法使用迭代器的解引用运算符从输入序列中提取元素。由于我们传递给它的是移动迭代器，因此解引用运算符生成的是一个右值引用，这意味着 construct 将使用移动构造函数来构造元素。<br>
值得注意的是，标准库不保证哪些算法适用移动迭代器，哪些不适用。由于移动一个对象可能销毁掉原对象，因此你只有在确信算法在为一个元素赋值或将其传递给一个用户 定义的函数后不再访问它时，才能将移动迭代器传递给算法。<br>
当我们调用move是，必须绝对确认移后源对象没有其他用户</p>
<p>习题13.49</p>
<pre><code>StrVec::StrVec(StrVec &amp;&amp;s) noexcept
	:elements(s.elements),first_free(s.first_free),cap(s.cap){
	s.elements = s.first_free = s.cap = nullptr;
}
StrVec &amp;StrVec::operator=(StrVec &amp;&amp;rhs)noexcept {
	if (&amp;rhs != this) {
		free();
		elements = rhs.elements;
		first_free = rhs.first_free;
		cap = rhs.cap;
		rhs.elements = rhs.first_free = rhs.cap = nullptr;
	}
	return *this;
}
</code></pre>
<p>注意：<br>
1.noexcept不能忘了，并且声明和定义的时候都需要<br>
2.不一定需要std::move<br>
3.自检使用<code>(&amp;rhs != this)</code>而不是<code>(rhs != *this)</code>或者<code>(rhs == *this)</code>，前者是指针可以直接比较，后者是类通常没有定义<br>
4.记得先free后转移，因为进行了自移动检查，所以可以直接free</p>
<p>习题13.50</p>
<pre><code>String::String(String &amp;&amp;s) noexcept: elements(s.elements),first_free(s.first_free),cap(s.cap){
	s.elements = s.first_free = s.cap = nullptr;
	cout &lt;&lt; &quot;移动构造函数&quot; &lt;&lt; endl;
}
String &amp;String::operator=(String &amp;&amp;rhs)noexcept {
	if (&amp;rhs != this) {
		free();
		elements = rhs.elements;
		first_free = rhs.first_free;
		cap = rhs.cap;
	}
	cout &lt;&lt; &quot;移动赋值函数&quot; &lt;&lt; endl;
	return *this;
}
</code></pre>
<p>验证代码</p>
<pre><code>	vector&lt;String&gt; vs;
	String s(&quot;123&quot;);
	vs.push_back(s);
	vs.push_back(&quot;123&quot;);
</code></pre>
<p>很明显地，s是一个恒存在的左值，所以动用了拷贝构造函数<br>
同时&quot;123&quot;是一个即将销毁的右值，所以动用了移动构造函数<br>
同时！第二次push_back除非reallocate将s拷贝的值移动时也是移动构造函数<br>
明显地函数会自动根据参数的类型选择相应的构造函数</p>
<p>习题13.51<br>
此时形参值将要被销毁或者只是一个局部对象，会被视为右值，会自动调用移动构造函数</p>
<p>习题13.52<br>
第一个赋值中右侧运算对象是一个左值，因此必须使用拷贝构造函数（注意此处的hp其实是未定义的，否则就是拷贝赋值函数了）<br>
第二个中强行move了hp2，将一个右值引用绑定到hp2上，此时拷贝构造函数和移动构造函数都可以，但是移动构造函数是精确匹配的。</p>
<p>习题13.53<br>
因为缺少移动赋值函数，每次拷贝赋值函数都需要进行交换拷贝操作，对于右值对象来说需要额外的内存和操作（先拷贝构造再拷贝赋值再销毁）</p>
<pre><code>Hasptr1(Hasptr1&amp;&amp; p) noexcept : ps(p.ps), i(p.i)
	{
		p.ps = 0;
		std::cout &lt;&lt; &quot;call move constructor&quot; &lt;&lt; std::endl;
	}
	// Hasptr&amp; operator=(Hasptr1 &amp;&amp;rhs) noexcept
	//{
	//    if (this != &amp;rhs)
	//    {
	//        delete ps;
	//        ps = rhs.ps;
	//        i = rhs.i;
	//        rhs.ps = nullptr;
	//        std::cout &lt;&lt; &quot;call move assignment&quot; &lt;&lt; std::endl;
	//    }

</code></pre>
<p>13.54<br>
<strong>如果类定义了移动操作，则也必须定义拷贝操作</strong>，否则<strong>拷贝操作</strong>都会默认地被<strong>定义为删除的</strong></p>
<p>13.6.3右值引用和成员函数<br>
一个成员函数最好同时提供拷贝和移动版本，一个版本接受一个指向 const 的左值引用，第二个版本接受一个指向非const 的右值引用。<br>
一般来说，我们不需要为函数操作定义接受一个 constX &amp;&amp;或是一个（普通的）X&amp;参数的版本。<br>
当我们希望从实参&quot;窃取&quot;数据时，通常传递一个右值引用。为了达到这一目的，实参不能是const的。类似的，从一个对象进行拷贝的操作不应该改变该对象。因此，通常不需要定义一个接受一个（普通的） X &amp;参数的版本。<br>
区分移动和拷贝的重载函数通常有一个版本接受一个 const T&amp;,而另一个版本接受一个 T &amp;&amp;。</p>
<p>右值和左值引用成员函数</p>
<p>旧标准中允许对一个右值进行赋值，为了维持向后兼容性，新标准库类仍然允许向右值赋值。但是，我们可能希望在自己的类中阻止这种用法。<br>
引用限定符：强制左侧运算对象（即this 指向的对象）是一个左值/右值。</p>
<p>引用限定符可以是&amp;或&amp;&amp;，分别指出 this 可以指向一个左值或右值<br>
引用限定符只能用于（非 static )成员函数，且必须同时出现在函数的声明和定义中<br>
对于&amp;限定的函数，我们只能将它用于左值；对于&amp;&amp;限定的函数，只能用于右值:</p>
<p>一个函数可以同时用 const 和引用限定。在此情况下，引用限定符必须跟随在const限定符之后</p>
<p>重载和引用函数<br>
就像一个成员函数可以根据是否有 const 来区分其重载版本一样，引用限定符也可以区分重载版本。而且，我们可以综合引用限定符和 const 来区分一个成员函数的重载版本</p>
<p>当我们对一个右值执行 sorted 时，它可以安全地直接对 data 成员进行排序。对象是一个右值，意味着没有其他用户，因此我们可以改变对象。当对一个 const 右值或一个左值执行 sorted 时，我们不能改变对象，因此就需要在排序前拷贝 data 。</p>
<p>如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符。</p>
<p>习题13.55</p>
<pre><code>	void push_back(const string &amp;t)&amp; { data-&gt;push_back(t); }
	void push_back(string &amp;&amp;t)&amp;&amp; { data-&gt;push_back(t); }
</code></pre>
<p>习题13.56<br>
ret.sorted()会陷入无限循环（不断地调用左值形参版本）<br>
习题13.57<br>
会调用右值形参版本，如果没有右值形参版本，则陷入无限循环<br>
习题13.58</p>
<pre><code>class Foo{
public:
	Foo(std::vector&lt;int&gt; vi) :data(vi) {};
	Foo sorted() &amp;&amp; ;
	Foo sorted()const &amp;;
	std::vector&lt;int&gt; data;
};

Foo Foo::sorted() &amp;&amp; {
	std::sort(data.begin(), data.end());
	return *this;
}

Foo Foo::sorted()const &amp; {
	Foo ret(*this);
	sort(ret.data.begin(), ret.data.end());
	return ret;
}
</code></pre>
<p>56运行结果</p>
<pre><code>warning C4717: “Foo::sorted”: 如递归所有控件路径，函数将导致运行时堆栈溢出
</code></pre>
<p>57运行结果<br>
未注释右值形参版本的话输出正确，注释掉的话如下</p>
<pre><code>warning C4717: “Foo::sorted”: 如递归所有控件路径，函数将导致运行时堆栈溢出
</code></pre>
<p>习题感悟<br>
1.noexcept不能忘了，并且声明和定义的时候都需要<br>
2.不一定需要std::move<br>
3.自检使用<code>(&amp;rhs != this)</code>而不是<code>(rhs != *this)</code>或者<code>(rhs == *this)</code>，前者是指针可以直接比较，后者是类通常没有定义<br>
4.记得先free后转移，因为进行了自移动检查，所以可以直接free<br>
<strong>如果类定义了移动操作，则也必须定义拷贝操作</strong>，否则<strong>拷贝操作</strong>都会默认地被<strong>定义为删除的</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 160. 相交链表[简单]]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-160-xiang-jiao-lian-biao-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-160-xiang-jiao-lian-biao-jian-dan">
        </link>
        <updated>2019-11-06T01:26:08.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>编写一个程序，找到两个单链表相交的起始节点。</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1573004036742.png" alt=""><br>
<img src="https://lixin-ee.github.io//post-images/1573004040961.png" alt=""></p>
<blockquote>
<p>注意：<br>
如果两个链表没有交点，返回 null.<br>
在返回结果后，两个链表仍须保持原有的结构。<br>
可假定整个链表结构中没有循环。<br>
程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/intersection-of-two-linked-lists<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题如果用哈希表的话是没啥难度的，所以重点在于如何满足O(n) 时间复杂度，且仅用 O(1) 内存。<br>
我最后想到的办法是制造一个环，从两个链表的头部同时出发，然后谁先达到尾部就直接把链表接到另一个的尾部<br>
但是在复习完有环链表的判断后才发现最后的相遇点不是一定在交点那里的，GG</p>
<p>纠结了太久了，直接看官方解答吧：</p>
<blockquote>
<p>方法一: 暴力法<br>
对链表A中的每一个结点 a_i	 ，遍历整个链表 B 并检查链表 B 中是否存在结点和 a_i  相同。<br>
复杂度分析<br>
时间复杂度 : (mn)。<br>
空间复杂度 : O(1)。</p>
<p>方法二: 哈希表法<br>
遍历链表 A 并将每个结点的地址/引用存储在哈希表中。然后检查链表 B 中的每一个结点 b_i 是否在哈希表中。若在，则 b_i为相交结点。<br>
复杂度分析<br>
时间复杂度 : O(m+n)。<br>
空间复杂度 : O(m) 或 O(n)。</p>
<p>方法三：双指针法<br>
创建两个指针 pA 和 pB，分别初始化为链表 A 和 B 的头结点。然后让它们向后逐结点遍历。<br>
当 pA 到达链表的尾部时，将它重定位到链表 B 的头结点 (你没看错，就是链表 B); 类似的，当 pB 到达链表的尾部时，将它重定位到链表 A 的头结点。<br>
若在某一时刻 pA 和 pB 相遇，则 pA/pB 为相交结点。<br>
想弄清楚为什么这样可行, 可以考虑以下两个链表: A={1,3,5,7,9,11} 和 B={2,4,9,11}，相交于结点 9。 由于 B.length (=4) &lt; A.length (=6)，pB 比 pA 少经过 2 个结点，会先到达尾部。将 pB 重定向到 A 的头结点，pA 重定向到 B 的头结点后，pB 要比 pA 多走 2 个结点。因此，它们会同时到达交点。<br>
如果两个链表存在相交，它们末尾的结点必然相同。因此当 pA/pB 到达链表结尾时，记录下链表 A/B 对应的元素。若最后元素不相同，则两个链表不相交。</p>
<p>复杂度分析<br>
时间复杂度 : O(m+n)。<br>
空间复杂度 : O(1)。</p>
</blockquote>
<p>妙啊！确实是简单题hhh，我只猜到了开头没猜到结局hhh，两者无论如何走过的路程都是一样的，所以当两者相等时退出循环判断，只需要判断最后的结点是否是NULL就好（甚至于都不用判断，直接返回就好）<br>
自己复现的代码如下：</p>
<pre><code>ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if(headA==NULL||headB==NULL)
            return NULL;
        ListNode *cur1=headA,*cur2=headB;
        while(cur1!=cur2){
            cur1=cur1==NULL?headB:cur1-&gt;next;
            cur2=cur2==NULL?headA:cur2-&gt;next;
        }
        return cur1;
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 2. 两数相加[中等]]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-2-liang-shu-xiang-jia-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-2-liang-shu-xiang-jia-zhong-deng">
        </link>
        <updated>2019-11-05T07:27:17.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。<br>
如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。<br>
您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>示例：<br>
输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>
输出：7 -&gt; 0 -&gt; 8<br>
原因：342 + 465 = 807</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/add-two-numbers<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>本题目其实相对不算特别难（因为链表按个位算起的），主要的难点在于<br>
1.如果两链表长度不等的话，存储起来比较麻烦，我本来想原地操作，但是这样子反而比较难操作（因为必须对两个链表同时操作直至其中一个到结尾，同时需要返回正确的那个链表的头结点）<br>
2.当一个链表去到尾部后的处理，以及如何判断两个链表达到结尾退出循环的判断<br>
2.进位其实还是比较好处理的，直接一个int就好<br>
最终代码如下</p>
<pre><code>class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        int flag=0;
        ListNode* ehead=new ListNode(0);
        ListNode* cur=ehead;
        int res,i1,i2;        
        while(l1!=NULL||l2!=NULL){
            i1=l1!=NULL?l1-&gt;val:0;
            i2=l2!=NULL?l2-&gt;val:0;
            res=(i1+i2+flag)%10;
            flag=(i1+i2+flag)/10;
            ListNode* newnode=new ListNode(res);
            cur-&gt;next=newnode;
            cur=newnode;
            if(l1!=NULL)
                l1=l1-&gt;next;
            if(l2!=NULL)
                l2=l2-&gt;next;
        }
        if(flag){
            ListNode* newnode=new ListNode(1);
            cur-&gt;next=newnode;
            cur=newnode;
        }
        cur-&gt;next=NULL;
        return ehead-&gt;next;
    }
};
</code></pre>
<p>比较重要的点就是<br>
1 <code>while(l1!=NULL||l2!=NULL)</code> 必须是或判断<br>
2 <code>i1=l1!=NULL?l1-&gt;val:0;</code> 这里使用条件语句能够节省很多代码</p>
<p>然后先来看一下网友的题解吧</p>
<pre><code>class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* head=new ListNode(-1);//存放结果的链表
        ListNode* h=head;//移动指针
        int sum=0;//每个位的加和结果
        bool carry=false;//进位标志
        while(l1!=NULL||l2!=NULL)
        {
            sum=0;
            if(l1!=NULL)
            {
                sum+=l1-&gt;val;
                l1=l1-&gt;next;
            }
            if(l2!=NULL)
            {
                sum+=l2-&gt;val;
                l2=l2-&gt;next;
            }
            if(carry)
                sum++;
            h-&gt;next=new ListNode(sum%10);
            h=h-&gt;next;
            carry=sum&gt;=10?true:false;
        }
        if(carry)
        {
            h-&gt;next=new ListNode(1);
        }
        return head-&gt;next;
    }
};
</code></pre>
<p>这里我没贴上补位的题解，因为补位需要先循环确定长度。主要是第二种做法比较巧妙的是利用一个sum来计算和。</p>
<p>官方题解和我的一毛一样hhh</p>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(max(m,n))，假设 m 和 n 分别表示 l1 和 l2 的长度，上面的算法最多重复max(m,n) 次。<br>
空间复杂度：O(max(m,n))， 新列表的长度最多为 max(m,n)+1。</p>
</blockquote>
<p>拓展</p>
<p>如果链表中的数字不是按逆序存储的呢？例如：<br>
(3→4→2)+(4→6→5)=8→0→7</p>
<p>最后这个拓展比较有趣，网友们的想法是利用递归或者栈，这个想法还是比较有趣的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[递归套路解决链表问题]]></title>
        <id>https://lixin-ee.github.io//post/di-gui-tao-lu-jie-jue-lian-biao-wen-ti</id>
        <link href="https://lixin-ee.github.io//post/di-gui-tao-lu-jie-jue-lian-biao-wen-ti">
        </link>
        <updated>2019-11-04T08:16:32.000Z</updated>
        <content type="html"><![CDATA[<p>递归套路解决链表问题：<br>
1.找终止条件：当head指向链表只剩一个元素的时候，自然是不可能重复的，因此return<br>
2.想想应该返回什么值：应该返回的自然是已经去重的链表的头节点<br>
3.每一步要做什么：宏观上考虑，此时head.next已经指向一个去重的链表了，而根据第二步，我应该返回一个去重的链表的头节点。因此这一步应该做的是判断当前的head和head.next是否相等，如果相等则说明重了，返回head.next，否则返回head</p>
]]></content>
    </entry>
</feed>