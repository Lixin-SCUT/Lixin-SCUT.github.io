<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2020-01-09T01:32:27.516Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[链表 148. 排序链表[中等][未做出][值得手撕]]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-148-pai-xu-lian-biao-zhong-deng-wei-zuo-chu-zhi-de-shou-si</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-148-pai-xu-lian-biao-zhong-deng-wei-zuo-chu-zhi-de-shou-si">
        </link>
        <updated>2020-01-09T01:19:20.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。<br>
示例 1:<br>
输入: 4-&gt;2-&gt;1-&gt;3<br>
输出: 1-&gt;2-&gt;3-&gt;4<br>
示例 2:<br>
输入: -1-&gt;5-&gt;3-&gt;4-&gt;0<br>
输出: -1-&gt;0-&gt;3-&gt;4-&gt;5<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/sort-list<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>【未做出】【值得手撕】<br>
主要难点在于常数空间复杂度和时间复杂度之间的制约吧<br>
一开始甚至想交换val hhh<br>
nlogn的排序算法有堆排序 归并排序和快速排序<br>
堆排序虽然显示无需额外的空间，但是实际上只有在完全二叉树能够满足随机访问的情况下才能实现，也就是必须要数组下标 在链表中反而需要一次循环<br>
然后就是归并排序 归并排序的核心在于把两个序列合成一个序列 数组中需要额外的空间进行合并，但是链表的特性却可以省略这一部分，所以打算实现一下链表的归并排序<br>
首先我想到的难点在于需要一个保留一个头结点，然后因为无法使用随机下标，所以迭代的归并排序比递归的好</p>
<p>实现的过程中遇到了比较多细节问题，所以打算先参考一下网友题解的实现方法。主要就是分开merge 和 cut 两个函数进行合并和切割<br>
我一开始比较困惑tail的作用，一开始以为是没用的，但是后来才发现是大大的用处，因为cut切断后，merge创建一个ehead来自成一个链表，后面得串回来，就是利用tail-&gt;next串回来的<br>
注意tail虽然全程看起来只是对自身进行操作，但是链表的next指针特性决定了其当前值，所以并非所看到的的那么简单，一定动手画图了解<br>
然后merge返回值和cut返回值需要额外注意，merge返回值是一个头结点，需要和tail配合，这里的话其实可以优化返回一个尾节点直接串起来，但是相应地需要循环去找尾节点，其实差不多。cur的返回值是尾节点的下一节点，所以需要提前保存，因为要切断。<br>
然后就是对空节点的判断，代码中没有针对right为空的情况进行判断，而是主要利用不同位置的while进行间接判断，所以代码的整体性也很重要。</p>
<p>题解实现代码</p>
<pre><code>class Solution {
public:
    ListNode* sortList(ListNode* head) {
        ListNode *ehead=new ListNode(0);
        ehead-&gt;next=head;
        int step=1;
        int len=0;
        for(ListNode *p=head;p!=NULL;p=p-&gt;next)
            ++len;
        ListNode *cur=ehead-&gt;next,*tail=ehead;;
        while(step&lt;len){
            while(cur!=NULL){
                ListNode *left=cur;
                cur=cut(left,step);
                ListNode *right=cur;
                cur=cut(right,step);
                tail-&gt;next=merge(left,right);
                while (tail-&gt;next!=NULL) {
                    tail = tail-&gt;next;
                }
            }
            cur=ehead-&gt;next;
            tail=ehead;
            step*=2;
        }
        return ehead-&gt;next;
    }
		
	ListNode* cut(ListNode *cur,int step){
        while(--step&amp;&amp;cur)
            cur=cur-&gt;next;
        if(!cur) return cur;
        
        ListNode *temp=cur-&gt;next;
        cur-&gt;next=NULL;
        return temp;
    }
    
    ListNode* merge(ListNode *left,ListNode *right){
        ListNode *ehead=new ListNode(0);
        ListNode *cur=ehead;
        while(left&amp;&amp;right){
            if(left-&gt;val&lt;=right-&gt;val){
                cur-&gt;next=left;
                left=left-&gt;next;
            }else{
                cur-&gt;next=right;
                right=right-&gt;next;
            }
            cur=cur-&gt;next;         
        }
        cur-&gt;next=left?left:right;
        return ehead-&gt;next;
    }
</code></pre>
<p>然后来看看详细的网友题解：</p>
<blockquote>
<p>bottom-to-up 的归并思路是这样的：先两个两个的 merge，完成一趟后，再 4 个4个的 merge，直到结束。举个简单的例子：[4,3,1,7,8,9,2,11,5,6].<br>
step=1: (3-&gt;4)-&gt;(1-&gt;7)-&gt;(8-&gt;9)-&gt;(2-&gt;11)-&gt;(5-&gt;6)<br>
step=2: (1-&gt;3-&gt;4-&gt;7)-&gt;(2-&gt;8-&gt;9-&gt;11)-&gt;(5-&gt;6)<br>
step=4: (1-&gt;2-&gt;3-&gt;4-&gt;7-&gt;8-&gt;9-&gt;11)-&gt;5-&gt;6<br>
step=8: (1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;9-&gt;11)<br>
链表里操作最难掌握的应该就是各种断链啊，然后再挂接啊。在这里，我们主要用到链表操作的两个技术：<br>
merge(l1, l2)，双路归并，我相信这个操作大家已经非常熟练的，就不做介绍了。<br>
cut(l, n)，可能有些同学没有听说过，它其实就是一种 split 操作，即断链操作。不过我感觉使用 cut 更准确一些，它表示，将链表 l 切掉前 n 个节点，并返回后半部分的链表头。<br>
额外再补充一个 dummyHead 大法，已经讲过无数次了，仔细体会吧。<br>
希望同学们能把双路归并和 cut 断链的代码烂记于心，以后看到类似的题目能够刷到手软。<br>
掌握了这三大神器后，我们的 bottom-to-up 算法伪代码就十分清晰了：</p>
</blockquote>
<pre><code>current = dummy.next;
tail = dummy;
for (step = 1; step &lt; length; step *= 2) {
	while (current) {
		// left-&gt;@-&gt;@-&gt;@-&gt;@-&gt;@-&gt;@-&gt;null
		left = current;

		// left-&gt;@-&gt;@-&gt;null   right-&gt;@-&gt;@-&gt;@-&gt;@-&gt;null
		right = cut(current, step); // 将 current 切掉前 step 个头切下来。

		// left-&gt;@-&gt;@-&gt;null   right-&gt;@-&gt;@-&gt;null   current-&gt;@-&gt;@-&gt;null
		current = cut(right, step); // 将 right 切掉前 step 个头切下来。
		
		// dummy.next -&gt; @-&gt;@-&gt;@-&gt;@-&gt;null，最后一个节点是 tail，始终记录
		//                        ^
		//                        tail
		tail.next = merge(left, right);
		while (tail-&gt;next) tail = tail-&gt;next; // 保持 tail 为尾部
	}
}
</code></pre>
<blockquote>
<p>下面是比较正式的代码。</p>
</blockquote>
<pre><code>class Solution {
public:
    ListNode* sortList(ListNode* head) {
        ListNode dummyHead(0);
        dummyHead.next = head;
        auto p = head;
        int length = 0;
        while (p) {
            ++length;
            p = p-&gt;next;
        }
        
        for (int size = 1; size &lt; length; size &lt;&lt;= 1) {
            auto cur = dummyHead.next;
            auto tail = &amp;dummyHead;
            
            while (cur) {
                auto left = cur;
                auto right = cut(left, size); // left-&gt;@-&gt;@ right-&gt;@-&gt;@-&gt;@...
                cur = cut(right, size); // left-&gt;@-&gt;@ right-&gt;@-&gt;@  cur-&gt;@-&gt;...
                
                tail-&gt;next = merge(left, right);
                while (tail-&gt;next) {
                    tail = tail-&gt;next;
                }
            }
        }
        return dummyHead.next;
    }
    
    ListNode* cut(ListNode* head, int n) {
        auto p = head;
        while (--n &amp;&amp; p) {
            p = p-&gt;next;
        }
        
        if (!p) return nullptr;
        
        auto next = p-&gt;next;
        p-&gt;next = nullptr;
        return next;
    }
    
    ListNode* merge(ListNode* l1, ListNode* l2) {
        ListNode dummyHead(0);
        auto p = &amp;dummyHead;
        while (l1 &amp;&amp; l2) {
            if (l1-&gt;val &lt; l2-&gt;val) {
                p-&gt;next = l1;
                p = l1;
                l1 = l1-&gt;next;       
            } else {
                p-&gt;next = l2;
                p = l2;
                l2 = l2-&gt;next;
            }
        }
        p-&gt;next = l1 ? l1 : l2;
        return dummyHead.next;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[接口和函数的区别]]></title>
        <id>https://lixin-ee.github.io//post/jie-kou-he-han-shu-de-qu-bie</id>
        <link href="https://lixin-ee.github.io//post/jie-kou-he-han-shu-de-qu-bie">
        </link>
        <updated>2020-01-08T23:56:06.000Z</updated>
        <content type="html"><![CDATA[<p>以前我以为接口就是给客户调用的函数，看了muduo和设计模式后才发现不是这样的<br>
以简单工厂模式为例子，接口就可以是算法派生出来的加减乘除法这个都是给客户调用的接口，实现了特定的功能<br>
而muduo中提出不要用设计模式中使用虚函数提供接口的方法，因为虚函数的正确调用完全依赖与virtual table的offset，一改动二进制兼容就木大了<br>
然后注意虚函数不是纯虚函数，不用子类必须override，而是子类可以选择性根据自身实现的功能进行override</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ UNP-UNIX网络编程 第三章]]></title>
        <id>https://lixin-ee.github.io//post/unp-unix-wang-luo-bian-cheng-di-san-zhang</id>
        <link href="https://lixin-ee.github.io//post/unp-unix-wang-luo-bian-cheng-di-san-zhang">
        </link>
        <updated>2020-01-08T12:57:36.000Z</updated>
        <content type="html"><![CDATA[<p>套接字地址结构从进程到内核和从内核到进程。<br>
地址转换函数在地址的文本表达和它们存放在套接字地址结构中的二进制值之间进行转换。<br>
地址转换函数在地址的文本表达和它们存放在套接字地址结构中的二进制值之间进行转换。多数现存的IPv4代码使用inet_addr和inet_ntoa这两个函数，不过两个新函数inet_pton 和i net_ntop同时适用于IPv4和IPv6两种代码。</p>
<p>注意 本书中为了克服函数对于IPv4和IPv6两种协议的协议相关问题，开发了一组名字以sock_开头的函数，它们以协议无关方式使用套接字地址结构。并贯穿全书使用这组函数。</p>
<ul>
<li>IPv4套接字地址结构<br>
IPv4套接字地址结构通常也称为&quot;网际套接字地址结构”，它以sockaddr_in命名，定义在 &lt;netinet/in.h&gt;头文件中。<br>
<img src="https://lixin-ee.github.io//post-images/1578488858968.png" alt=""><br>
POSIX规范只需要设置这个结构中的3个字段：<strong>sin_family, sin_addr和sin_port。</strong><br>
相对应地，他们的类型是：<br>
sa_family_t可以是任何无符号整数类型，通常是一个8位的无符号整数<br>
in_addr_t数据 类型必须是一个至少32位的无符号整数类型<br>
in_port_t必须是-个至少16位的无符号 整数类型<br>
<img src="https://lixin-ee.github.io//post-images/1578489062325.png" alt=""></li>
</ul>
<p>注意！IPv4地址和TCP或UDP端口号在套接字地址结构中总是以<strong>网络字节序（大端序）</strong> 来存储。<br>
32位IPv4地址存在<strong>两种不同的访问方法</strong>。<br>
举例来说，如果serv定义为某个网际套接字地址结构，那么serv. sin_addr将按<strong>in_addr结构</strong>引用其中的32位IPv4地址，而serv.sin_addr.s_addr将按<strong>in_addr_t整数</strong>（通常是一个无符号的32位整数）引用同—个32位IPv4地址。因此，我们必须正确地使用IPv4地址，尤其是在将它作为函数的参数时， 因为编译器对<strong>传递结构</strong>和<strong>传递整数</strong>的处理是完全不同的。<br>
套接字地址结构仅在给定主机上使用：虽然结构中的某些字段（例如IP地址和端口号） 用在不同主机之间的通信中，但是结构本身并不在主机之间传递。</p>
<ul>
<li>
<p>值-结果参数<br>
当往一个套接字<strong>函数</strong>传递一个套接字地址<strong>结构</strong>时，该结构总是以<strong>引用</strong>形式来 传递，也就是说传递的是指向该结构的一个<strong>指针</strong>。该结构的长度也作为一个参数来传递，不过其传递方式取决于该结构的<strong>传递方向</strong>：是从进程到内核，还是从内核到进程。<br>
(1)	从进程到内核传递套接字地址结构的函数有3个：bind、connect和sendto。这些函数 的一个参数是指向某个套接字地址结构的指针，另一个参数是该结构的整数大小（套接字地址结构大小的数据类型实际上是socklen.t,而不是int）<br>
(2)	从内核到进程传递套接字地址结构的函数有4个：accepts、recvfrom、getsockname 和getpeernameo。这4个函数的其中两个参数是指向某个套接字地址结构的指针和指向表示该结构大小的整数变量的指针。<br>
<img src="https://lixin-ee.github.io//post-images/1578489792892.png" alt=""><br>
注意！！！函数调用时，结构大小<strong>只是一个希望的值</strong>，当函数返回时，结构大小又是一个<strong>实际大小的结果(result)</strong>,它告诉进程内核在该结构中<strong>究竞存储了多少信息</strong>。这种类型的参数称为值-结果(value-result)参数。</p>
</li>
<li>
<p>字节排序函数、大端序、小端序<br>
小端 和 大端 表示多个字节值的哪一端(小端或大端)存储在该值的起始 地址.<br>
低序字节存储在起始地址，这称为小端（little-endian）字节序；<br>
另一种方法是将高序字节存储在起 始地址，这称为大端（big-endian）字节序。<br>
<strong>记忆方法</strong>：大端序就是我们日常的<strong>书写顺序</strong>（在纸上（内存）写一个数字，先写高位再写地位），小端序则是反过来</p>
</li>
</ul>
<p>当前系统所用的字节序称为主机字节序(host byte order)<br>
<img src="https://lixin-ee.github.io//post-images/1578490222230.png" alt=""><br>
网络协议必须指定一个网络字节序（network byte order），网际协议使用<strong>大端字节序</strong>来传送这些多字节整数。<br>
套接字地址结构中的某些字 段必须按照网络字节序进行维护。<br>
两种字节序之间的转换使用以下4个函数。<br>
<img src="https://lixin-ee.github.io//post-images/1578490503887.png" alt=""><br>
h代表host, n代表network, s代表short, l代表long</p>
<p>注意：当使用这些函数时，我们并不关心主机字节序和网络字节序的真实值（或为大端，或为小端）。我们所要做的只是调用适当的函数在主机和网络字节序之间转换某个给定值。在那些与网际协议所用字节序（大端）相同的系统中，这四个函数通常被定义为空宏。（一句话，为求保险（优雅地说是提高可移植性），默认调用转换就完事了）</p>
<ul>
<li>
<p>字节操纵函数<br>
操纵多字节字段的函数有两组，主要用于处理套接字地址<strong>结构</strong>（原因是结构并不全是字符串）<br>
<img src="https://lixin-ee.github.io//post-images/1578490776599.png" alt=""><br>
本书中我们只使用bzero，bzero把目标字节串中指定数目的字节置为0。我们经常使用该函数来把一个<strong>套接字地址结构</strong>初始化为0。<br>
bcopy将指定数目的字节从源字节串移到目标字节串。bcmp比较两个任意的字节 串，若相同则返回值为0,否则返回值为非0。<br>
<img src="https://lixin-ee.github.io//post-images/1578490880005.png" alt=""><br>
memset把目标字节串指定数目的字节置为值c。memcpy类似bcopy,不过两个指针参数的顺序是相反的。<br>
memcmp比较两个任意的字节串，若相同则返回0,否则返回一个非0值，是大于0还是小于0 则取决于第一个不等的字节</p>
</li>
<li>
<p>inet_aton、inet_addr 和 inet_ntoa 函数<br>
函数名中a和n分别代表ASCII和数值(numeric)<br>
地址转换函数：在ASCII字符串与网络字节序的二进制值之间转换网际地址。<br>
（1）inet_aton、inet_addr 和 inet_ntoa在点分十进制数申（例如&quot;206.168. 112.96&quot;） 与它长度为32位的网络字节序二进制值间转换IPv4地址。<br>
（2）	两个较新的函数inet_pton和inet_ntop对于IPv4地址和IPv6地址都适用。<br>
<img src="https://lixin-ee.github.io//post-images/1578491193169.png" alt=""><br>
inet_aton将strptr所指C字符串转换成一个32位的网络字节序二进制值，并通过指针addrptr来存储。若成功返回1,否则返回0。（如果addrptr指针为空，那么该函数仍 然对输入的字符串执行有效性检查，但是不存储任何结果）<br>
inet_ntoa函数将一个32位的网络字节序二进制IPv4地址转换成相应的点分十进制数串。 由该函数的返回值所指向的字符串驻留在静态内存中。这意味着该函数是<strong>不可重入</strong>的<br>
<strong>（inet_addr已被废弃，新的代码应该改用inet_aton函数）</strong> inet_addr进行相同的转换，返回值为32位的网络字节序二进制值。当出错时该函 数返回INADDR_NONE常值（通常是一个<strong>32位均为1的值</strong>）。这意味着点分十进制数串 255.255.255.255 （这是IPv4的有限广播地址）不能由该函数处理，因为它的二进制值被用来指示该函数失败。</p>
</li>
<li>
<p>inet pton 和 inet ntop 函数<br>
函数名中p和n分别代表表达(presentation)和数值(numeric)<br>
地址的表达格式通常是ASCII字符串，数值格式则是存放到套接字地址结构中的二进制值。<br>
<img src="https://lixin-ee.github.io//post-images/1578491510912.png" alt=""><br>
这两个函数family参数既可以是AF_INET,也可以是AF_INET6。如果以不被支持的地址族作为family参数,这两个函数就都返回一个错误，并将errno置为EAFNOSUPPORT。<br>
第一个函数尝试转换由strptr指针所指的字符串，并通过odd中addrptr指针存放二进制结果。成 功则返回值为1,否则返回 值为0。<br>
inet_ntop进行相反的转换，从数值格式(addrptr)转换到表达格式(strptr)。<br>
len参数是目标存储单元的大小，以免该函数溢出其调用者的缓冲区。如果len太小，不足以容纳表达格式结果(包括结尾的空字符)，那么返回一个空指针，并置errno为ENOSPC。<br>
inet_ntop函数的strptr参数不可以是一个空指针。调用者必须为目标存储单元分配内存并指定其大小。调用成功时，这个指针就是该函数的返回值。<br>
<img src="https://lixin-ee.github.io//post-images/1578491749818.png" alt=""></p>
</li>
<li>
<p>sock_ntop和相关函数<br>
inet_ntop的一个基本问题是：它要求调用者传递一个指向某个二进制地址的指针，而该 地址通常包含在一个套接字地址结构中，这就要求调用者必须知道这个结构的格式和地址族。这就使得我们的代码与协议相关了。<br>
为了解决这个问题，我们将自行编写一个名为sockntop的函数，它以指向某个套接字地 址结构的指针为参数，查看该结构的内部，然后调用适当的函数返回该地址的表达格式。<br>
<img src="https://lixin-ee.github.io//post-images/1578491955024.png" alt=""><br>
sockaddr指向一个长度为addrlen的套接字地址结构，本函数用它自己的静态缓冲区来保存 结果，而指向该缓冲区的一个指针就是它的返回值。<br>
<strong>对结果进行静态存储导致该函数不可重入且非线程安全.</strong></p>
</li>
</ul>
<p>书中还为操作套接字地址结构定义了其他几个函数，它们将简化我们的代码在IPv4与IPv6 之间的移植。<br>
<img src="https://lixin-ee.github.io//post-images/1578492138671.png" alt=""><br>
<img src="https://lixin-ee.github.io//post-images/1578492154760.png" alt=""></p>
<ul>
<li>readn, writen 和 readline 函数<br>
字节流套接字（例如TCP套接字）上的read和write函数所表现的行为不同于通常的文件 I/O。经常会出现输入或输出的字节数可能<strong>比请求的数量少</strong>，原因在于内核中用于套接字的缓冲区可能已达到了极限。此时所需的 是调用者<strong>多次调用</strong>read或write函数，以输入或输出剩余的字节。<br>
这个现象在read一个字节流套接字时很常 见，但是在write 一个字节流套接字时只能在该套接字为<strong>非阻塞</strong>的前提下才出现。（阻塞情况下一直阻塞知道发送完成）<br>
书中为了防止出现这种情况 ，不让实现返回一个不足的字节计数值，编写了writen函数来取代write函数。<br>
当出现输入或输出的字节数少于请求字节数时，会产生ETNTR错误（表示系统调用被一个捕获的信号中断） ，如果发生该错误则继续进行readn, writen 的读或写操作。<br>
注意，如果每读一个字节的数据就调用一次系统的read函数。这是非常低效 率的，但是不能因此改用标准I/O函数库（称为stdio），究其原因在于stdio提供的默认缓冲区的状态是不可见 的</li>
</ul>
<p>良好的防御 性编程（defensiveprogramming）技术要求这些程序不仅能够期望它们的对端程序也遵循相同的 网络协议，而且能够检查出未预期的网络数据传送并加以修正（恶意企图自然也被检查出来）， 这样使得网络应用能够从存在问题的网络数据传送中恢复，可能的话还会继续工作。</p>
<p>所以在readn中使用stdio来缓冲数据提升 性能违背了这些目标，这样的应用进程在任何时刻都没有办法分辨 stdio缓冲区中是否持有未预期的数据。<br>
所以！<strong>依照缓冲区而不是文本行的要求来考虑编程</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 238. 除自身以外数组的乘积 [中等][未做出]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-238-chu-zi-shen-yi-wai-shu-zu-de-cheng-ji-zhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-238-chu-zi-shen-yi-wai-shu-zu-de-cheng-ji-zhong-deng-wei-zuo-chu">
        </link>
        <updated>2020-01-07T14:34:36.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。<br>
示例:<br>
输入: [1,2,3,4]<br>
输出: [24,12,8,6]<br>
说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。<br>
进阶：<br>
你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/product-of-array-except-self<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>【未做出】<br>
第一眼：很简单嘛，利用前一个的值不就行了嘛！然后突然发现不能用除法hhh<br>
然后第二个难点在于线性时间复杂度，那就说明不能每个元素单独进行计算，比如1的时候算2x3x4 2的时候算1x3x4。必须把计算结果重复利用起来</p>
<p>完全没思路啊！！！时间复杂度一直没想好是怎么降低到线性，而且也没有常数空间复杂度的想法，好菜啊！！！<br>
偷看题解发现是左积和右积？<br>
不是很懂<br>
看完题解后才发现太秀了吧<br>
我有一个问题是忘了使用输出数组这个空间和线性时间复杂度不一定是一次n，可以多次n的嘛<br>
不过题解的思想确实是很巧妙<br>
然后我在复现题解的时候用了for范围语句和for+迭代器，结果忘了要同时读取res和nums，结果全部木大hhh。下标发看起来很复杂但还是最通用的</p>
<p>网友题解实现</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) {
        int len=nums.size();
        vector&lt;int&gt; res(len,1);
        int k=1;
        for(auto i=0;i&lt;len;++i){
            res[i]=res[i]*k;
            k*=nums[i];
        }
        k=1;
        for(auto i=len-1;i&gt;=0;--i){
            res[i]=res[i]*k;
            k*=nums[i];
        }
        return res;
    }
};
</code></pre>
<p>网友题解<br>
乘积 = 当前数左边的乘积 * 当前数右边的乘积</p>
<pre><code>class Solution {
    public int[] productExceptSelf(int[] nums) {
        int[] res = new int[nums.length];
        int k = 1;
        for(int i = 0; i &lt; res.length; i++){
            res[i] = k;
            k = k * nums[i]; // 此时数组存储的是除去当前元素左边的元素乘积
        }
        k = 1;
        for(int i = res.length - 1; i &gt;= 0; i--){
            res[i] *= k; // k为该数右边的乘积。
            k *= nums[i]; // 此时数组等于左边的 * 该数右边的。
        }
        return res;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ UNP-UNIX网络编程 第二章]]></title>
        <id>https://lixin-ee.github.io//post/unp-unix-wang-luo-bian-cheng-di-er-zhang</id>
        <link href="https://lixin-ee.github.io//post/unp-unix-wang-luo-bian-cheng-di-er-zhang">
        </link>
        <updated>2020-01-07T13:21:19.000Z</updated>
        <content type="html"><![CDATA[<p>传输层：TCP、UDP<br>
出于工程实用性考虑，不考虑SCTP</p>
<ul>
<li>
<p>网络协议示例<br>
IPv4 网际协议版本4 (Internet Protocol version 4).：IPv4 (通常称之为IP)，一直是网际协议族的主力协议。它使用32位地址。 IPv4给TCP、UDP, SCTPs ICMP和IGMP提供分组递送服务。<br>
TCP 传输控制协议(Transmission Control Protocol)：TCP是一个面向连接的协议， 为用户进程提供可靠的全双工字节流。TCP套接字是一种流套接字(stream socket)。TCP关心确认、超时和重传之类的细节。大多数因特网应用程序使用 TCP。注意，TCP既可以使用IPv4,也可以使用IPv6.<br>
UDP 用户数据报协议(User Datagram Protocol) ：UDP是一个无连接协议。UDP套接字是一种数据报套接字(datagram socket)。 UDP数据报不能保证最终到达它们 的目的地。与TCP一样，UDP既可以使用IPv4,也可以使用IPv6。<br>
ICMP 网际控制消息协议(Internet Control Message Protocol)：ICMP处理在路由器和 主机之间流通的错误和控制消息。这些消息通常由TCP/IP网络支持软件本身</p>
</li>
<li>
<p>用户数据报协议(UDP)<br>
应用进程往一个 UDP套接字写入一个消息，该消息随后被封装(encapsulating)到一个UDP数据报，该UDP数据报进而又被封装到一个IP数据报，然后发送到目的地。<br>
UDP不保证UDP数据报会到达其最终目的地，不保证各个数据报的先后顺序跨网络后保持不变，也不保证每个数据报只到达一次。<br>
每个UDP数据报都有一个长度。如果一个数据报正确地到达其目的地，那么该数据报的长度将随数据一道传递给接收端应用进程。我们巳经提到过TCP是一个字节流(byte-stream)协议， 没有任何记录边界，这一点不同于UDP。（关于粘包与分包）<br>
UDP提供无连接的(connectionless)服务</p>
</li>
<li>
<p>传输控制协议(TCP)<br>
TCP提供客户与服务器之间的连接(connection)。TCP客户先与某个给定服务器建立一个连接，再跨该连接与那个服务器交换数据，然后终止这个连接。<br>
TCP还提供了可靠性(reliability)。当TCP向另一端发送数据时，它要求对端返回一 个确认.如果没有收到确认，TCP就自动重传数据并等待更长时间。在数次重传失败后，TCP才放弃。<br>
TCP含有用于动态估算客户和服务器之间的往返时间(round-trip time, RTT)的算法，以便它知道等待一个确认需要多少时间。<br>
TCP通过给其中每个字节关联一个序列号对所发送的数据进行排序(sequencing)接收端TCP将先根据它们的序列号重新排序，再把结果数据传递给接收应用。(注意粘包分包是指TCP报文段除去首部后交给应用层后应用层无法正确分包！所以本质上和TCP无关，TCP是也可以按序列号排序组合好所有报文段的，所以粘包分包是应用层的问题！)<br>
TCP提供流量控制(flow control)，TCP拥有通告窗口(advertised window)，确保发送端发送的数据不会使接收缓冲区溢出<br>
TCP连接是全双工的(full-d叩lex)。这意味着在一个给定的连接上应用可以在任何 时刻在进出两个方向上既发送数据又接收数据。<br>
UDP不提供流量控制，但UDP可以是全双工的.</p>
</li>
<li>
<p>TCP连接的建立和终止<br>
建立个TCP连接时会发生下述情形。<br>
(1) 服务器必须准备好接受外来的连接。这通常通过调用socket、bind和listen这3个函 数来完成，我们称之为被动打开(passiveopen)。<br>
(2) 客户通过调用connect发起主动打开(activeopen),这导致客户TCP发送一个SYN (同 步)分节，它告诉服务器客户将在(待建立的)连接中发送的数据的初始序列号。通常SYN分节不携带数据，其所在IP数据报只含有一个IP首部、一个TCP首部及可能有的TCP选项。<br>
(3) 服务器必须确认(ACK)客户的SYN,同时自己也得发送一个SYN分节，它含有服务 器将在同一连接中发送的数据的初始序列号。服务器在单个分节中发送SYN和对客户SYN的 ACK (确认)。<br>
(4) 客户必须确认服务器的SYN。</p>
</li>
</ul>
<p>连接建立至少需要3个分组，因此称之为TCP的三路握手(three-way handshake).<br>
<img src="https://lixin-ee.github.io//post-images/1578405307478.png" alt=""><br>
因为SYN占据一个字节的序列号空间，所以每一个SYN 的ACK中的确认号就是该SYN的初始序列号加1。类似地，每一个FIN (表示结束)的ACK中的 确认号为该FIN的序列号加1。<br>
<strong>ACK不占序列号</strong></p>
<p>与网络连接相关的系统调用函数的意义：<br>
如果将建立TCP连接类比于一个电话系统<br>
socket函数等同于有电话可用.<br>
bind函数是在告诉别人你的电话号码，这样他们可以呼叫你<br>
listen函效是打开电话振铃， 这样当有一个外来呼叫到达时，你就可以听到.<br>
connect函数要求我们知道对方的电话号码 并拨打它.<br>
accept函数发生在被呼叫的人应答电话之时<br>
不同之处在于accept只在连接建立之后返回客户的标识</p>
<p>域名系统DNS提供了 一种类似于电话薄的服务<br>
getaddrinfo类似于在电话簿中查找某个人的电话号 码<br>
getnameinfo则类似于有一本按照电话号码而不是按照用户名排序的电话簿。</p>
<ul>
<li>TCP 选项<br>
<strong>MSS选项</strong>：通告对端它的最大分节大小(maximum segment size),也就是它在本连接的每个TCP分节中愿意接受的最大数据量。<br>
<strong>窗口规模选项</strong>:能够通告对端的最大窗口大小是65535,因为在TCP 首部中相应的字段占16位,在一个TCP连接上使用窗口规模的前提是它的两个端系统必须都支持这个选项。<br>
<strong>时间戳选项</strong>：对于高速网络连接是必要的，它可以防止由失而复现的分组05可 能造成的数据损坏	<br>
后两个选项有时称为&quot;RFC 1323选项&quot;，高带宽或长延迟的网络被 称为&quot;长胖管道&quot;(longfhtpipe),这两个选项也称为&quot;长胖管道选项&quot;</li>
</ul>
<p><strong>失而复现的分组</strong>，并不是超时重传的分组，而是由暂时的路由原因造成的迷途的分组。当路由稳定后，它们又会正常到达目的地，其前提是它们在此前尚未被路由器丢弃.高速网络中32位的序列号短时间内就可能循环一轮重新使用，若不用时间戳选项，失而复现的分组所承载的分节可能与再次使用相同序列号的真正 分节发生混淆。</p>
<ul>
<li>TCP连接终止<br>
TCP建立一个连接需3个分节，终止一个连接则需4个分节。<br>
(1) 某个应用进程首先调用close,我们称该端执行<strong>主动关闭</strong>(active close)。该端的TCP 于是发送个FIN分节，表示数据发送完毕。<br>
(2) 接收到这个FIN的对端执行<strong>被动关闭</strong>(passive close)。这个FIN由TCP确认。它的接收也作为一个<strong>文件结束符</strong>(end-of-file)传递给接收端应用进程(放在已排队等候该应用进程接收 的任何其他数据之后)，因为FIN的接收意味着接收端应用进程在相应连接上再无额外数据可 接收。<br>
(3) 一段时间后，接收到这个文件结束符的应用进程将调用close关闭它的套接字。这导致 它的TCP也发送一个FIN.<br>
(4) 接收这个最终FIN的原发送端TCP (即执行主动关闭的那一端)确认这个FIN。<br>
步骤2和步骤3发送的分节都出自执行被动关闭那一端，有可能被合并成一个分节。<br>
<img src="https://lixin-ee.github.io//post-images/1578406215415.png" alt=""><br>
类似SYN, 一个FIN也占据1个字节的序列号空间。因此，每个FIN的ACK确认号就是这个 FIN的序列号加1。</li>
</ul>
<p>在步骤2与步骤3之间，从执行被动关闭一端到执行主动关闭一端流动数据是可能的。这称 为半关闭（half-close) ，与shutdown函数有关<br>
当一个Unix<strong>进程</strong>无论自愿地（调用exit或从main函数返 回）还是非自愿地（收到一个终止本进程的信号）终止时，<strong>所有打开的描述符</strong>都被关闭，这也 导致仍然打开的<strong>任何TCP连接</strong>上也发出一个<strong>FIN</strong>。</p>
<p>TCP状态转换图<br>
理解状态转换图是使用netstat命令诊断网络问题的基础<br>
状态转换图给出11种TCP状态的名称。这些状态可使用netstat显示， 它是一个在调试客户/服务器应用时很有用的工具。（第5章中使用netstat去监视状态的 变化。)<br>
<img src="https://lixin-ee.github.io//post-images/1578406476029.png" alt=""></p>
<p>一个完整的TCP连接所发生的实际分组交换情况，包括连接建立、数据传送和连接终止3个阶段。图中还展示了每个端点所历经的TCP状态。<br>
<img src="https://lixin-ee.github.io//post-images/1578406540777.png" alt=""><br>
客户通告一个值为536字节的MSS （表明该客户只实现了最小重组缓冲区大小），服务 器通告一个值为1460字节的MSS （以太网上IPv4的典型值）。不同方向上MSS值不相同不成问题(全双工，只需要遵守对方的发送规则就好)<br>
服务器对客户请求的确认是伴随其应答发送的。这种做法称为捎带（piggy backing）<br>
如果该连接的整个目的仅仅是发送一个单分节的请求和接收一个单分节的应答，那么使用TCP有8个分节的开销。如果改用UDP,那么只需交换两个分组：一个承载请求，一个承载应答。UDP避免了TCP连接建立和终止所需的开销，然而从TCP切换到UDP将丧失TCP提供给应用进程的全部可靠性</p>
<ul>
<li>
<p>TIME WAIT 状态<br>
TIME_WAIT状态：执行主动关闭的那端经历了这个状态。该端点停留在这个状态的持续时间是最长分节生命期(maximum segment lifetime, MSL)的两倍，有时候称之为<strong>2MSL</strong>。<br>
MSL是任何<strong>IP数据报</strong>能够在因特网中存活的最长时间，因为每个数据报含有一个称为跳限(hop limit)的8位字段，最大值为255。<br>
所以可以假设：具有最大跳限(255)的分组在网络中存在的时间不可能超过MSL秒。<br>
&quot;迷途”：路由异常的结果，某个路由器崩溃或某两个路由器之间的某 个链路断开时，路由协议需花数秒钟到数分钟的时间才能稳定并找出另一条通路。<br>
TCP必须正确处理这些迷途的重复分组<br>
所以TIME_WAIT状态有两个存在的理由：<br>
(1)	可靠地实现TCP全双工连接的终止；<br>
假设最终的ACK丢失了来解释。被动关闭端将重新发送它的最终那个FIN,因此主动关闭端必须维护状态信息，以允许它重新发送最终那个ACK<br>
执行主动关闭的那一端必须保持处于TIME_WAIT：因为可能不得不重传最终那个ACK。<br>
(2)	允许迷途的重复分节在网络中消逝。<br>
关闭这个连接后过一段时间后很有可能在相同的IP 地址和端口之间建立另一个连接。后一个连接称为前一个连接的化身(incarnation),因为它们 的IP地址和端口号都相同<br>
TCP必须防止来自某个连接的老的重复分组在该连接已终止后再现， 从而被误解成属于同一连接的某个新的化身。<br>
既然TIME_WAIT状态的持续时间是MSL的2倍，这就足以让某个方向上的分组最多存活MSL秒即被丢弃，另一个方向上的应答最多存活MSL秒也被丢弃。<br>
进一步地，能够保证每成功建立一个TCP连接时，来自该连接先前化身的老的重复分组都已在网络中消逝了。</p>
</li>
<li>
<p>端口号<br>
多个进程可能同时使用TCP、UDP和SCTP这3种传输层协议中的任何一种。这3 种协议都使用16位整数的端口号(port number)来区分这些进程。<br>
当一个客户想要跟一个服务器联系并使用服务时，需要获得用于标识众所周知的服务的众所周知的端口 (well-known port)<br>
而客户自身通常使用短期存活的临时端口(ephemeral port)。<br>
端口号被划分成以下3段：<br>
(1)	众所周知的端口为0-1023。<br>
(2)	已登记的端口(registered port)为1024-49151<br>
(3)	49152~65535是动态的(dynamic)或私用的(private)端口，也是临时端口。<br>
同时在UNIX中需要额外注意的是<br>
Unix系统有保留端口 (reserved port)的概念，指的是小于1024的任何端口。这些端口只能赋予特权用户（root）进程的套接字。</p>
</li>
</ul>
<p>套接字对<br>
一个TCP连接的套接字对（socket pair）是一个定义该连接的两个端点的四元组：本地IP地址、本地TCP端口号、外地IP地址、外地TCP端口号。<br>
标识每个端点的两个值（IP地址和端口号）通常称为一个套接字。</p>
<ul>
<li>
<p>TCP端口号与并发服务器<br>
套接字中的星号*代表通配（wildcard）符<br>
服务器的监听套接字（listening socket）经常使用｛*:port, *:*}，代表服务器在任意本地接口（第一个星号） 的特定端口port上等待连接请求，外地IP地址和外地端口都没有指定。<br>
必须在服务器主机上区分监听套接字和已连接套接字（connected socket）， 己连接套接字使用与监听套接字相同的本地端口，连接一旦建立，已连接套接字的特定本地地址随即填入。<br>
有时可能存在多个服务使用同一端口的情况，此时TCP无法仅仅通过查看目的端口号来分离外来的分节到不同的端点。它必须查看套接字对的所有4个元素才能确定由哪个端点接收某个到达的分节。</p>
</li>
<li>
<p>缓冲区大小及限制<br>
影响IP数据报大小的限制：<br>
•	IPv4数据报的最大大小是65 535字节，包括IPv4首部（因为总长度字 段占据16位。）<br>
•许多网络有一个可由硬件规定的MTU。举例来说，以太网的MTU是1500字节。（进一步导致TCP报文段数据段的最大长度MSS等于1460字节，TCP首部都是20个字节，但IPv4首部是20字节）<br>
同时，IPv4要求的最小链路MTU是68字节.这允许最大的IPv4首部（包括20字节的固定长度部 分和最多40字节的选项部分）拼接最小的片段（IPv4首部中片段偏移字段以8个字节为 单位）<br>
•	在两个主机之间的路径中最小的MTU称为<strong>路径MTU</strong>（path MTU）。1500字节的以太网 MTU是当今常见的路径MTU。两个主机之间相反的两个方向上路径MTU可以不一致<br>
•	当一个IP数据报将从某个接口送出时，如果它的大小超过相应链路的MTU, IPv4将执行分片（fragmentation）。这些片段在到达最终目的地之前通常不会被重组 （reassembling）, <strong>IPv4主机</strong>对其产生的数据报执行分片，<strong>IPv4路由器</strong>则对其转发的数据报执行分片。<br>
•	但是，IPv4首部的“不分片（don,tfragment）&quot;位（即DF位）若被设置，那么不管是 发送这些数据报的主机还是转发它们的路山器，都不允许对它们分片。当路由器接收到一个超过其外出链路MTU大小且设置了DF位的IPv4数据报时，它将产生一个ICMPv4的“目的地不可达，需分片但DF位已设置”的出错消息<br>
•	IPv4定义了最小重组缓冲区大小（minimum reassembly buffer size）,它是IPv4 必须保证支持的最小数据报大小，其值为576字节。<br>
•	TCP有一个MSS （maximum segment size,最大分节大小），用于向对端TCP通告对端在每个 分节中能发送的最大TCP数据量。MSS的目的是告诉对端其重组缓冲区大小的实际值，从而试图避免分片。MSS经常设置成MTU 减去IP和TCP首部的固定长度。在以太网中使用IPv4的MSS值为1460, （TCP首部都是20个字节，但IPv4首部是20字节）。</p>
</li>
<li>
<p>TCP 输出<br>
<img src="https://lixin-ee.github.io//post-images/1578486758834.png" alt=""><br>
每一个TCP套接字有一个发送缓冲区，我们可以使用SO_SNDBUF套接字选项来更改该缓冲区的大小。当某个应用进程调用write时，内核从该<strong>应用进程的缓冲区</strong>中复制所有数据到所写<strong>套接字的发送缓冲区</strong>。<br>
因此，从写一个TCP套接字的write调用成功返回仅仅表示我们 可以重新使用原来的<strong>应用进程缓冲区</strong>，并不表明对端的TCP或应用进程己接收到数据。<br>
伴随来自对端的 ACK的不断到达，本端TCP至此才能从<strong>套接字发送缓冲区</strong>中丢弃己确认的数据。TCP必须为已发送的数据保留一个副本，直到它被对端确认为止。</p>
</li>
<li>
<p>UDP 输出<br>
<img src="https://lixin-ee.github.io//post-images/1578486946325.png" alt=""><br>
以虚线框展示套接字发送缓冲区，因为它实际上并不存在。<br>
任何UDP套接字都有<strong>发送缓冲区大小</strong>（我们可以使用SO_SNDBUF套接字选项更改它，见7.5节），不过它<strong>仅仅是</strong>可写到该套接字的UDP数据报的<strong>大小上限。</strong>（只是用于判断单个UDP数据报的大小）<br>
如果一个应用进程写一个大于套接字发送缓冲区大小的数据报，内核将返回该进程一个EMSGSIZE错误。<br>
既然UDP是不可靠的，它不必保存应用进程数据的一个副本，因此无需一个真正的发送缓冲区。<br>
UDP简单地给来自用户的数据报安上它的8字节的首部以构成UDP数据报，然后传 递给IP。<br>
如果某个UDP应用进程发送大数据报（譬如说2000字节的数据报），那么它们相比TCP应用数据更有可能被<strong>分片</strong>，因为TCP会把应用数据划分成MSS大小的块，而UDP却没有对等的手段。</p>
</li>
<li>
<p>标准因特网服务<br>
<img src="https://lixin-ee.github.io//post-images/1578487266054.png" alt=""><br>
上图TCP/IP多数实现都提供的若干标准服务<br>
这些服务通常由Unix主机的inetd守护进程提供<br>
注意，当我们连接到daytime服务器时，服务器执行主动关闭，然而当连接到echo服务器时，客户执行主动关闭。<br>
拒绝服务攻击和其他资源使用攻击，在如今的系统中，这些简单的服 务通常被禁用。</p>
</li>
</ul>
<p>常见因特网应用的协议使用<br>
<img src="https://lixin-ee.github.io//post-images/1578487587325.png" alt=""><br>
前两个因特网应用ping和traceroute是使用ICMP协议实现的网络诊断应用<br>
紧接着是3个流行的路由协议<br>
接下来5个是基于UDP的网络应用</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Linux基础] 进程 （鸟哥Linux第十六章）]]></title>
        <id>https://lixin-ee.github.io//post/linux-ji-chu-jin-cheng-niao-ge-linux-di-shi-liu-zhang</id>
        <link href="https://lixin-ee.github.io//post/linux-ji-chu-jin-cheng-niao-ge-linux-di-shi-liu-zhang">
        </link>
        <updated>2020-01-07T11:40:57.000Z</updated>
        <content type="html"><![CDATA[<p>在 Linux 系统当中：『触发任何一个事件时，系统都会将他定义成为一个进程，并且给予这个进程一个 ID ，称为 PID，同时依据启发这个进程的用户与相关属性关系，给予这个 PID 一组有效的权限设定。』</p>
<ul>
<li>进程与程序 (process &amp; program)<br>
『执行一个程序或指令』就可以触发一个事件而取得一个 PID<br>
『不同的使用者身份执行同一个 program 时，系统给予的权限也都不相同』</li>
</ul>
<p>当 root 执行这个 touch 指令时，他取得的是 UID/GID = 0/0 的权限，而当普通用户 (假设UID/GID=501/501) 执行这个 touch 时，他的权限就跟 root 不同<br>
当我们登入并执行 bash 时，系统已经给我们一个 PID 了，这个 PID 就是依据登入者的 UID/GID (/etc/passwd) 来的</p>
<p>父进程衍生出来的子进程在一般状态下，也会沿用这个进程的相关权限</p>
<p>程序 (program)：通常为 binary program ，放置在储存媒体中 (如硬盘、光盘、软盘、磁带等)， 为实体文件的型态存在；<br>
进程 (process)：程序被触发后，执行者的权限与属性、程序的程序代码与所需数据等都会被加载内存中， 操 作系统并给予这个内存内的单元一个标识符 (PID)，可以说，进程就是一个正在运作中的程序。</p>
<ul>
<li>子进程与父进程<br>
当我们登 入系统后，会取得一个 bash的shell ，然后，我们用这个 bash 提供的接口去执行另一个指令，例如/usr/bin/passwd 或者是 touch 等等，那些另外执行的指令也会被触发得到新PID成『子进程』，原本的 bash 环境下，就称为『父进程』了<br>
<img src="https://lixin-ee.github.io//post-images/1578397893602.png" alt=""></li>
</ul>
<p>每个进程都有一个 PID ，那某个进程的父进程就透过 Parent PID (PPID) 来判断</p>
<ul>
<li>
<p>fork and exec进程呼叫的流程<br>
在 Linux 的 进程呼叫通常称为 fork-and-exec 的流程<br>
进程都会藉由父进程以复制 (fork) 的方式产生一个 一模一样的子进程， 然后被复制出来的子进程再以 exec 的方式来执行实际要进行的程序，最终就 成为一个子进程的存在。<br>
<img src="https://lixin-ee.github.io//post-images/1578398079861.png" alt=""></p>
</li>
<li>
<p>系统或网络服务：常驻在内存的进程<br>
常驻在内存当中，在后台当中一直持续不断运作的进程通常都是负责一些系统所提供的功能以服务用户各项任务，因此这些常驻程序就会被我们称为：服务 （守护进程）(daemon)。</p>
</li>
<li>
<p>工作管理 (job control)<br>
『当我们登入系统取得 bash shell 之 后，在<strong>单一终端机接口</strong>下同时进行多个工作的行为管理 』<br>
因为进行工作管理的行为中， 其实每个工作都是目前 bash 的子进程，亦即彼此之间是有相关性的。 我们无法以 job control 的方式由 tty1 的环境去管理 tty2 的 bash</p>
</li>
</ul>
<p>由于假设我们只有一个终端接口，因此在可以出现提示字符让你操作的环境就称为前端 (foreground)， 至于其他工作就可以让你放入后台 (background) 去暂停或运作。</p>
<p>放入背景的工作想要运作时， 无法与使用者互动。所以类似于 vim 绝对不可能在背景里面执行 (running) 的<br>
放入背景的工作是不可以使用 [ctrl]+c 来终止的</p>
<p>总结：<br>
? 这些工作所触发的进程必须来自于你 shell 的子进程(只管理自己的 bash)；<br>
? 前景：你可以控制与下达指令的这个环境称为前景的工作 (foreground)；<br>
? 背景：可以自行运作的工作，你无法使用 [ctrl]+c 终止他，可使用 bg/fg 呼叫该工作；<br>
? 背景中『执行』的进程不能等待 terminal/shell 的输入(input)</p>
<ul>
<li>job control 的管理命令</li>
</ul>
<ol>
<li>
<p>直接将指令丢到背景中『执行』的 &amp; 命令<br>
在该指令的最后面加上一个『 &amp; 』代表将该指令丢到背景中， 此时 bash 会给予这个指令一个『工作号码(job number)』，至于后面那个则是该指令所触发的『 PID 』了<br>
进程完成后将会显示Done，后台任务不怕被 [ctrl]+c 中断</p>
</li>
<li>
<p>将『目前』的工作丢到背景中『暂停』：[ctrl]-z<br>
在 vim 的一般模式下，按下 [ctrl] 及 z 这两个按键，屏幕上会出现 [1] ，表示这是第一个工作， 而 那个 + 代表最近一个被丢进背景的工作，且目前在背景下预设会被取用的那个工作 (与 fg 这个指 令有关 )，而那个 Stopped 则代表目前这个工作的状态。在预设的情况下，使用 [ctrl]-z 丢到背景当 中的工作都是『暂停』的状态</p>
</li>
<li>
<p>观察目前的背景工作状态： jobs<br>
<code>[root@study ~]# jobs [-lrs] 选项与参数：</code><br>
-l ：除了列出 job number 与指令串之外，同时列出 PID 的号码；<br>
-r ：仅列出正在背景 run 的工作；<br>
-s ：仅列出正在背景当中暂停 (stop) 的工作。<br>
+代表最近被放到背景的工作号码， - 代表最近最后第二个被放置到背景中的工作号码</p>
</li>
<li>
<p>将背景工作拿到前景来处理：fg<br>
<code>[root@study ~]# fg %jobnumber</code><br>
选项与参数：<br>
%jobnumber ：jobnumber 为工作号码(数字)。注意这个命令中那个 % 是可有可无的（KILL中则必须有）<br>
如果输入『 fg - 』 则代表将 - 号的那个工作号码拿出来</p>
</li>
<li>
<p>让工作在背景下的状态变成运作中： bg<br>
[ctrl]-z 可以将目前的工作丢到背景底下去『暂停』，bg让一个工作在 背景底下『 Run 』<br>
指令列最后方多了一个 &amp; 的符号啰！ 代表该工作被启动在背景当中了</p>
</li>
<li>
<p>管理背景当中的工作： kill</p>
</li>
</ol>
<pre><code>[root@study ~]#  kill -signal %jobnumber
[root@study ~]#  kill -l 
</code></pre>
<p>选项与参数：<br>
-l ：这个是 L 的小写，列出目前 kill 能够使用的讯号 (signal) 有哪些<br>
signal ：代表给予后面接的那个工作什么样的指示啰！用 man 7 signal 可知：<br>
-1 ：重新读取一次参数的配置文件 (类似 reload)；<br>
-2 ：代表与由键盘输入 [ctrl]-c 同样的动作；<br>
-9 ：立刻强制删除一个工作；<br>
-15：以正常的进程方式终止一项工作。与 -9 是不一样的。</p>
<p>-9 这个 signal 通常是用在『强制删除一个不正常的工作』时所使用的， -15 则是<br>
以正常步骤结束一项工作(<strong>15 也是默认值</strong>)</p>
<p>kill 后面接的数字默认会是 PID ，如果想要管理 bash 的工作控制，就必须要加上 %数字 了</p>
<ul>
<li>脱机管理问题<br>
工作管理当中提到的『背景』指的是 bash 的背景，并不是放到系统的背景，所以，工作管理的背景依旧与终端机有关</li>
</ul>
<p>在工作尚未结束的情况下你脱机了，该工作不会继续进行，而是会被中断掉。<br>
at 是将工作放置到系统背景， 而与终端机无关。<br>
也可以尝试使用 nohup 这个指令来处理，这个 nohup 可以让你在脱机或<br>
注销系统后，还能够让工作继续进行<br>
在终端机前景中工作[root@study ~]#  nohup [ 指令与 参数 ]<br>
在终端机背景中工作[root@study ~]#  nohup [ 指令与 参数 ] &amp;<br>
nohup 并不支持 bash 内建的指令，因此必须要是外部指令才行</p>
<ul>
<li>进程管理</li>
</ul>
<p>进程的观察</p>
<ol>
<li>ps 将某个时间点的进程运作情况撷取下来<br>
选项与参数：<br>
-A ：所有的 process 均显示出来，与 -e 具有同样的效用；<br>
-a ：不与 terminal 有关的所有 process ；<br>
-u ：有效使用者 (effective user) 相关的 process ；<br>
x ：通常与 a 这个参数一起使用，可列出较完整信息。<br>
输出格式规划：<br>
l ：较长、较详细的将该 PID 的的信息列出；<br>
j ：工作的格式 (jobs format)<br>
-f ：做一个更为完整的输出。</li>
</ol>
<p>观察系统所有的进程数据[root@study ~]#  ps aux<br>
也是能够观察所有系统的数据[root@study ~]#  ps -lA<br>
连同部分进程树状态[root@study ~]#  ps axjf</p>
<p>重点：<br>
只能查阅自己 bash 进程的『 ps -l 』<br>
可以查阅所有系统运作的进程『 ps aux 』</p>
<p>但是ps -l 与 ps aux 显示的项目<strong>并不相同</strong></p>
<p>仅观察自己的 bash 相关进程： ps -l<br>
F：代表这个进程旗标 (process flags)，说明这个进程的总结权限，常见号码有：<br>
若为 4 表示此进程的权限为 root ；<br>
若为 1 则表示此子进程仅进行复制(fork)而没有实际执行(exec)。<br>
  S：代表这个进程的状态 (STAT)，主要的状态有：<br>
R (Running)：该程序正在运作中；<br>
S (Sleep)：该程序目前正在睡眠状态(idle)，但可以被唤醒(signal)。<br>
D ：不可被唤醒的睡眠状态，通常这支程序可能在等待 I/O 的情况(ex&gt;打印)<br>
T ：停止状态(stop)，可能是在工作控制(背景暂停)或除错 (traced) 状态；<br>
Z (Zombie)：僵尸状态，进程已经终止但却无法被移除至内存外。<br>
  UID/PID/PPID：代表『此进程被该 UID 所拥有/进程的 PID 号码/此进程的父进程 PID 号码』<br>
  C：代表 CPU 使用率，单位为百分比；<br>
  PRI/NI：Priority/Nice 的缩写，代表此进程被 CPU 所执行的优先级，数值越小代表该进程越快被 CPU 执行。详细的 PRI 与 NI 将在下一小节说明。<br>
  ADDR/SZ/WCHAN：都与内存有关，ADDR 是 kernel function，指出该进程在内存的哪个部分，如果是个running 的进程，一般就会显示『 - 』 / SZ 代表此进程用掉多少内存 / WCHAN 表示目前进程是否运作中，同样的， 若为 - 表示正在运作中。<br>
  TTY：登入者的终端机位置，若为远程登录则使用动态终端接口 (pts/n)；<br>
  TIME：使用掉的 CPU 时间，注意，是此进程实际花费 CPU 运作的时间，而不是系统时间；<br>
  CMD：就是 command 的缩写，造成此进程的触发程序之指令为何。</p>
<p>观察系统所有进程： ps aux<br>
各字段的意义为：<br>
  USER：该 process 属于那个使用者账号的？<br>
  PID ：该 process 的进程标识符。<br>
  %CPU：该 process 使用掉的 CPU 资源百分比；<br>
  %MEM：该 process 所占用的物理内存百分比；<br>
  VSZ ：该 process 使用掉的虚拟内存量 (Kbytes)<br>
  RSS ：该 process 占用的固定的内存量 (Kbytes)<br>
  TTY ：该 process 是在那个终端机上面运作，若与终端机无关则显示 ?，另外， tty1-tty6 是本机上面的登<br>
入者进程，若为 pts/0 等等的，则表示为由网络连接进主机的进程。<br>
  STAT：该进程目前的状态，状态显示与 ps -l 的 S 旗标相同 (R/S/T/Z)<br>
  START：该 process 被触发启动的时间；<br>
  TIME ：该 process 实际使用 CPU 运作的时间。<br>
  COMMAND：该进程的实际指令为何？</p>
<p><strong>『僵尸 (zombie) 』进程</strong><br>
造成僵尸进程的成因是因为该进程应该已经执行完毕，或者是因故应该要终止了， 但是该进程的父进程却无法完整的将该进程结束掉，而造成那个进程一直存在内存当中。<br>
如果你发现在某个进程的 CMD 后面还接上<code>&lt;defunct&gt;</code> 时，就代表该进程是僵尸进程</p>
<p>重点<br>
不要仅仅将僵尸进程 kill 掉而已，要找出该进程的父进程</p>
<ol start="2">
<li>top：动态观察进程的变化<br>
<code>[root@study ~]# top [-d 数 字 ] | top [-bnp]</code><br>
选项与参数：<br>
-d ：后面可以接秒数，就是整个进程画面更新的秒数。预设是 5 秒；<br>
-b ：以批次的方式执行 top ，还有更多的参数可以使用喔！<br>
通常会搭配数据流重导向来将批次的结果输出成为文件。<br>
-n ：与 -b 搭配，意义是，需要进行几次 top 的输出结果。<br>
-p ：指定某些个 PID 来进行观察监测而已。</li>
</ol>
<p>在 top 执行过程当中可以使用的按键指令：<br>
? ：显示在 top 当中可以输入的按键指令；<br>
P ：以 CPU 的使用资源排序显示；<br>
M ：以 Memory 的使用资源排序显示；<br>
N ：以 PID 来排序喔！<br>
T ：由该 Process 使用的 CPU 时间累积 (TIME+) 排序。<br>
k ：给予某个 PID 一个讯号 (signal)<br>
r ：给予某个 PID 重新制订一个 nice 值。<br>
q ：离开 top 软件的按键。</p>
<ol start="3">
<li>pstree进程之间的相关性<br>
<code>[root@study ~]#pstree [-A|U] [-up]</code><br>
选项与参数：<br>
-A ：各进程树之间的连接以 ASCII 字符来连接；<br>
-U ：各进程树之间的连接以万国码的字符来连接。在某些终端接口下可能会有错误；<br>
-p ：并同时列出每个 process 的 PID；<br>
-u ：并同时列出每个 process 的所属账号名称。</li>
</ol>
<p>由 pstree 的输出我们也可以很清楚的知道，所有的进程都是依附在<strong>systemd</strong>这支进程底下的，这支进程的 PID 是1，因为他是由 Linux 核心所主动呼叫的第一支程序，所以 PID就是一号了。 这也是我们刚刚提到僵尸进程时有提到，为啥发生僵尸进程需要重新启动？ 因为僵尸进程挂载systemd名下，要消灭这些僵尸进程就需要重新启动，而重新启动systemd就是reboot</p>
<ul>
<li>进程相互之间的管理<br>
进程的互相管理：透过给予该进程一个讯号 (signal) 去告知该进程下一步的行为</li>
</ul>
<p>常见的 signal<br>
1 SIGHUP 启动被终止的进程，可让该 PID 重新读取自己的配置文件，类似重新启动<br>
2 SIGINT 相当于用键盘输入 [ctrl]-c 来中断一个进程的进行<br>
9 SIGKILL代表强制中断一个进程的进行，如果该进程进行到一半， 那么尚未完成的部分可能会有『半产品』产生，类似 vim 会有 .filename.swp 保留下来。<br>
15 SIGTERM 以正常的结束进程来终止该进程。由于是正常的终止， 所以后续的动作会将他完成。不过，如果该进程已经发生问题，就是无法使用正常的方法终止时， 输入这个 signal 也是没有用的。<br>
19 SIGSTOP 相当于用键盘输入 [ctrl]-z 来暂停一个进程的进行</p>
<p>只要记得『1,9,15』这三个号码的意义即可更多的讯号信息请自行 man 7 signal</p>
<ol>
<li>
<p>kill -signal PID<br>
kill 可以帮我们将这个 signal 传送给<strong>某个工作</strong> (%jobnumber) 或者是<strong>某个 PID</strong> (直接输入数字)。<br>
要再次强调的是： kill 后面<strong>直接加数字</strong>与<strong>加上 %number</strong> 的情况是不同的<br>
想要将某个进程删除的话，就可以透过使用pstree -p 找到相关进程， 然后再以 kill -9 将该进程删除</p>
</li>
<li>
<p>killall -signal  指令名称<br>
<code>[root@study ~]# killall [-iIe] [command name]</code><br>
选项与参数：<br>
-i ：interactive 的意思，交互式的，若需要删除时，会出现提示字符给用户；<br>
-e ：exact 的意思，表示『后面接的 command name 要一致』，但整个完整的指令不能超过 15 个字符。<br>
-I ：指令名称(可能含参数)忽略大小写。</p>
</li>
</ol>
<p>注意会强制终止所有以 [command name] 启动的进程，所以最好加上-i</p>
<ul>
<li>关于进程的执行顺序<br>
由 top 的输出结果我们也发现， 系统同时间有非常多的进程在运行中，只是绝大部分的进程都在休眠 (sleeping) 状态而已。 想一想，如果所有的进程同时被唤醒，那么 CPU 应该要先处理那个进程呢？也就是说，那个进程被执行的优先序比较高？ 这就得要考虑到进程的优先执行序 (Priority) 与 CPU 排程</li>
</ul>
<p>Priority  与 Nice<br>
PRI 值越低代表越优先的意思。不过这个 PRI 值是由核心动态调整的， 用户无法直接调整 PRI值的。<br>
ps -l命令可以看到当前进程的PRI 值和Nice 值（NI）<br>
PRI 与 NI 的相关性如下：<br>
PRI(new) = PRI(old) + nice<br>
当 nice 值为负值时，那么该进程就会降低 PRI 值，亦即会变的较优先被处理。</p>
<p>要调整某个进程的优先执行序，就是『调整该进程的 nice 值』 调整某个进程 nice 值有两种方式，分别是：<br>
  一开始执行程序就立即给予一个特定的 nice 值：用 nice 指令；<br>
  调整某个已经存在的 PID 的 nice 值：用 renice 指令。</p>
<p>nice  ：新执行的指令即给予新的 nice  值<br>
<code>[root@study ~]# nice [-n 数 字 ] command</code><br>
选项与参数：<br>
-n ：后面接一个数值，数值的范围 -20 ~ 19。</p>
<p>renice  ：已存在进程的 nice  重新调整<br>
<code>[root@study ~]# renice [number] PID</code><br>
选项与参数：<br>
PID ：某个进程的 ID 啊！</p>
<p>renice 后面接上数值及 PID 即可。因为后面接的是 PID ，所以你务必要以 ps 或者其他进程观察的指令去找出 PID 才行</p>
<ul>
<li>系统资源的观察<br>
free 观察内存使用情况<br>
<code>[root@study ~]# free [ [-b|-k|-m|-g|-h] [-t] [-s N -c N]</code><br>
选项与参数：<br>
-b ：直接输入 free 时，显示的单位是 Kbytes，我们可以使用 b(bytes), m(Mbytes)<br>
k(Kbytes), 及 g(Gbytes) 来显示单位喔！也可以直接让系统自己指定单位 (-h)<br>
-t ：在输出的最终结果，显示物理内存与 swap 的总量。<br>
-s ：可以让系统每几秒钟输出一次，不间断的一直输出的意思！对于系统观察挺有效！<br>
-c ：与 -s 同时处理～让 free 列出几次的意思</li>
</ul>
<p>uname ：查阅系统与LINUX内核相关信息<br>
<code>[root@study ~]# uname [-asrmpi]</code><br>
选项与参数：<br>
-a ：所有系统相关的信息，包括底下的数据都会被列出来；<br>
-s ：系统核心名称<br>
-r ：核心的版本<br>
-m ：本系统的硬件名称，例如 i686 或 x86_64 等；<br>
-p ：CPU 的类型，与 -m 类似，只是显示的是 CPU 的类型！<br>
-i ：硬件的平台 (ix86)</p>
<p>uptime：观察系统启动时间与工作负载<br>
显示出目前系统已经开机多久的时间，以及 1, 5, 15 分钟的平均负载。</p>
<p><strong>netstat  ：追踪网络或插槽文件</strong><br>
这个指令比较常被用在网络的监控方面，但也可以用于进程<br>
netstat 的输出分为两大部分，分别是网络<br>
与系统自己的进程相关性部分<br>
<code>[root@study ~]# netstat -[atunlp]</code><br>
选项与参数：<br>
-a ：将目前系统上所有的联机、监听、Socket 数据都列出来<br>
<strong>-t ：列出 tcp 网络封包的数据</strong><br>
-u ：列出 udp 网络封包的数据<br>
-n ：不以进程的服务名称，以端口号 (port number) 来显示；<br>
-l ：列出目前正在网络监听 (listen) 的服务；<br>
-p ：列出该网络服务的进程 PID</p>
<p>目前系统上已在监听的网络联机及其 PID<br>
<code>[root@study ~]# netstat -tulnp</code></p>
<p>显示内容可分为connections 和sockets文件</p>
<p>connections 输出字段有：<br>
Proto ：网络的封包协议，主要分为 TCP 与 UDP 封包，相关资料请参考服务器篇；<br>
Recv-Q：非由用户程序链接到此 socket 的复制的总 bytes 数；<br>
Send-Q：非由远程主机传送过来的 acknowledged 总 bytes 数；<br>
Local Address ：本地端的 IP:port 情况<br>
Foreign Address：远程主机的 IP:port 情况<br>
State ：联机状态，主要有建立(ESTABLISED)及监听(LISTEN)；</p>
<p>socket file 可以沟通两个进程之间的信息，因此进程可以取得对方传送过来的资料。<br>
socket file 的输出字段有：<br>
Proto ：一般就是 unix 啦；<br>
RefCnt：连接到此 socket 的进程数量；<br>
Flags ：联机的旗标；<br>
Type ：socket 存取的类型。主要有确认联机的 STREAM 与不需确认的 DGRAM 两种；<br>
State ：若为 CONNECTED 表示多个进程之间已经联机建立。<br>
Path ：连接到此 socket 的相关程序的路径！或者是相关数据输出的路径。</p>
<p>dmesg  分析核心产生的讯息</p>
<p>vmstat 侦测系统资源变化<br>
可以动态侦测『 CPU / 内存 / 磁盘输入输出状态 』</p>
<pre><code>[root@study ~]#  vmstat [-a] [ 延迟 [总计侦测次数 ]] &lt;==CPU/内存等信息
[root@study ~]#  vmstat [-fs] &lt;==内存相关
[root@study ~]#  vmstat [-S  单位 ] &lt;==设定显示数据的单位
[root@study ~]#  vmstat [-d] &lt;==与磁盘有关
[root@study ~]#  vmstat [-p  分区槽] &lt;==与磁盘有关
</code></pre>
<p>选项与参数：<br>
-a ：使用 inactive/active(活跃与否) 取代 buffer/cache 的内存输出信息；<br>
-f ：开机到目前为止，系统复制 (fork) 的进程数；<br>
-s ：将一些事件 (开机至目前为止) 导致的内存变化情况列表说明；<br>
-S ：后面可以接单位，让显示的数据有单位。例如 K/M 取代 bytes 的容量；<br>
-d ：列出磁盘的读写总量统计表<br>
-p ：后面列出分区槽，可显示该分区槽的读写总量统计表</p>
<p>统计目前主机 CPU 状态，每秒一次，共计三次<br>
[root@study ~]# vmstat 1 3</p>
<p>进程字段 (procs) 的项目分别为：<br>
r ：等待运作中的进程数量；b：不可被唤醒的进程数量。这两个项目越多，代表系统越忙碌 (因为系统太<br>
忙，所以很多进程就无法被执行或一直在等待而无法被唤醒之故)。<br>
内存字段 (memory) 项目分别为：<br>
swpd：虚拟内存被使用的容量； free：未被使用的内存容量； buff：用于缓冲存储器； cache：用于高速<br>
缓存。 这部份则与 free 是相同的。<br>
内存置换空间 (swap) 的项目分别为：<br>
si：由磁盘中将进程取出的量； so：由于内存不足而将没用到的进程写入到磁盘的 swap 的容量。 如果 si/so<br>
的数值太大，表示内存内的数据常常得在磁盘与主存储器之间传来传去，系统效能会很差！<br>
磁盘读写 (io) 的项目分别为：<br>
bi：由磁盘读入的区块数量； bo：写入到磁盘去的区块数量。如果这部份的值越高，代表系统的 I/O 非常<br>
忙碌！<br>
系统 (system) 的项目分别为：<br>
in：每秒被中断的进程次数； cs：每秒钟进行的事件切换次数；这两个数值越大，代表系统与接口设备的<br>
沟通非常频繁！ 这些接口设备当然包括磁盘、网络卡、时间钟等。<br>
CPU 的项目分别为：<br>
us：非核心层的 CPU 使用状态； sy：核心层所使用的 CPU 状态； id：闲置的状态； wa：等待 I/O 所<br>
耗费的 CPU 状态； st：被虚拟机 (virtual machine) 所盗用的 CPU 使用状态 (2.6.11 以后才支持)。</p>
<ul>
<li>特殊文件与进程</li>
</ul>
<p>具有 SUID/SGID 权限的指令执行状态<br>
SUID 的权限与进程的相关性：<br>
1 SUID 权限仅对二进制程序(binary program)有效；<br>
2 执行者对于该程序需要具有 x 的可执行权限；<br>
3 本权限仅在执行该程序的过程中有效 (run-time)；<br>
4 执行者将具有该程序拥有者 (owner) 的权限。</p>
<p>所以整个 SUID 的权限会生效是由于『具有该权限的程序被触发』<br>
例如在触发 passwd 后，会取得一个新的进程与 PID，该 PID 产生时透过 SUID 来给予该 PID 特殊的权限设定（root）</p>
<p>查询整个系统的 SUID/SGID 的文件 find / -perm /6000</p>
<p>/proc/*  代表的意义<br>
内存当中的数据又都是写入到 /proc/* 这个目录下的<br>
目前主机上面的各个进程的 PID 都是以目录的型态存在于 /proc 当中<br>
比如开机所执行的第一支程序 systemd 他的 PID 是 1 ， 这个 PID 的所有相关信息都写入在 /proc/1/* 当中<br>
可以使用 ll /proc/1 来观察，目录下主要有两个文件<br>
cmdline：这个进程被启动的指令串；<br>
environ：这个进程的环境变量内容</p>
<p>查询已开启文件或已执行进程开启之文件<br>
fuser ：藉由文件( 或文件系统) 找出正在使用该文件<br>
<code>[root@study ~]# fuser [-umv] [-k [i] [-signal]] file/dir</code><br>
选项与参数：<br>
-u ：除了进程的 PID 之外，同时列出该进程的拥有者；<br>
-m ：后面接的那个档名会主动的上提到该文件系统的最顶层，对 umount 不成功很有效<br>
-v ：可以列出每个文件与进程还有指令的完整相关性<br>
-k ：找出使用该文件/目录的 PID ，并试图以 SIGKILL 这个讯号给予该 PID；<br>
-i ：必须与 -k 配合，在删除 PID 之前会先询问使用者意愿<br>
-signal：例如 -1 -15 等等，若不加的话，预设是 SIGKILL (-9)</p>
<p>如果卸除硬盘时发现系统通知：『 device is busy 』，那表示这个文件系统正在忙碌中， 表示有某支进程有利用到该文件系统，那么你就可以利用 fuser 来追踪</p>
<p>lsof  ：列出被进程所开启的文件档名<br>
fuser 是由文件或者装置去找出使用该文件或装置的进程，lsof 反过来查出某个进程开启或者使用的文件与装置<br>
<code>[root@study ~]# lsof [-aUu] [+d]</code><br>
选项与参数：<br>
-a ：多项数据需要『同时成立』才显示出结果时！<br>
-U ：仅列出 Unix like 系统的 socket 文件类型；<br>
-u ：后面接 username，列出该使用者相关进程所开启的文件；<br>
+d ：后面接目录，亦即找出某个目录底下已经被开启的文件！</p>
<p>pidof  ：通过正在执行的程序找出其相应的的 PID<br>
<code>[root@study ~]# pidof [-sx] program_name</code><br>
选项与参数：<br>
-s ：仅列出一个 PID 而不列出所有的 PID<br>
-x ：同时列出该 program name 可能的 PPID 那个进程的 PID<br>
例如如果要找的是 bash ，那就 pidof bash ，立刻列出相应的 PID 号码</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 回溯 89. 格雷编码[中等]]]></title>
        <id>https://lixin-ee.github.io//post/hui-su-89-ge-lei-bian-ma-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/hui-su-89-ge-lei-bian-ma-zhong-deng">
        </link>
        <updated>2020-01-07T01:06:53.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。<br>
给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。<br>
示例 1:<br>
输入: 2<br>
输出: [0,1,3,2]<br>
解释:<br>
00 - 0<br>
01 - 1<br>
11 - 3<br>
10 - 2<br>
对于给定的 n，其格雷编码序列并不唯一。<br>
例如，[0,2,3,1] 也是一个有效的格雷编码序列。<br>
00 - 0<br>
10 - 2<br>
11 - 3<br>
01 - 1<br>
示例 2:<br>
输入: 0<br>
输出: [0]<br>
解释: 我们定义格雷编码序列必须以 0 开头。<br>
     给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。<br>
     因此，当 n = 0 时，其格雷编码序列为 [0]。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/gray-code<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>偷看了tag知道是回溯法hhh<br>
但是这个题目真的看得我有点吃力，卧槽终于看懂了，原来后面的数值就是格雷码强行转化而来的二进制对应的十进制数<br>
这个可以用树来解决，我发现的规律是每一层都是按照[0,1]和[1,0]循环出现的，因为这样才能保证相邻两个叶节点之间只在路径上有一个差异<br>
（一开始我以为是0接[0,1],1接[1,0]，后面发现是两者循环）<br>
当然也可以交换顺序[1,0]和[0,1]循环 就是保持相接处相同就好<br>
但是这个循环是在每一层里面循环，类似于层次遍历<br>
但是回溯法似乎无法用层次遍历来做（特别是层次遍历的队列），但是我打算利用层次遍历的思想，传一个层数的形参和一个bool形参(注意，此处想表达的其实是layer和vector&lt; bool&gt;)指示下一个循环<br>
然后希望尽量改掉利用全局变量的习惯</p>
<p>我的代码里面要注意layer这个概念，因为本质上这是一棵根节点为0的树，根节点是无用的，叶节点的layer是0，但是为了保持统一性我还是保留了根节点的层（2-1-0层）<br>
然后为了节省形参数我使用了layer递减的方法，然后flag自然也是相当于逆序使用的<br>
count也需要注意，其实这里就相当于大端序了，从高位到低位，和示例相同，如果想要小端序（从个位开始）那么还得计算2的幂比较麻烦，但是也是符合答案的情况</p>
<p>最后遇到的坑是忘了把flag传引用了，一定记得flag和res都是传引用而不是传值，否则就全部木大了</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; grayCode(int n) {
        if(n==0) return vector&lt;int&gt;({0});
        vector&lt;int&gt; res;
        vector&lt;bool&gt; flag(n,true);
        int layer=n;
        GaryCode(0,0,layer,flag,res);
        return res;
    }
    
    void GaryCode(int add,int count,int layer,vector&lt;bool&gt; &amp;flag,vector&lt;int&gt; &amp;res){
        count=add+count*2;
        if(layer==0) {
            res.push_back(count);
            return;
        }
        if(flag[layer-1]){
            flag[layer-1]=!flag[layer-1];
            GaryCode(0,count,layer-1,flag,res);
            GaryCode(1,count,layer-1,flag,res);
        }else{
            flag[layer-1]=!flag[layer-1];
            GaryCode(1,count,layer-1,flag,res);
            GaryCode(0,count,layer-1,flag,res);
        }
        return;            
    }  
};
</code></pre>
<p>然后来看看网友们的精妙解法：<br>
思路：<br>
设 n 阶格雷码集合为 G(n)，则 G(n+1) 阶格雷码为：<br>
给 G(n) 阶格雷码每个元素二进制形式前面添加 0，得到 G'(n)<br>
设 G(n) 集合倒序（镜像）为 R(n)，给 R(n) 每个元素二进制形式前面添加 1，得到 R'(n)；<br>
G(n+1) = G'(n) ∪ R'(n) 拼接两个集合即可得到下一阶格雷码。<br>
根据以上规律，可从 0 阶格雷码推导致任何阶格雷码。<br>
代码解析：<br>
由于最高位前默认为 00，因此 G'(n) = G(n)，只需在 res(即 G(n)G(n) )后添加 R'(n)即可；<br>
计算 R'(n)：执行 head = 1 &lt;&lt; i 计算出对应位数，以给 R(n)前添加 1 得到对应 R'(n)；<br>
倒序遍历 res(即 G(n) )：依次求得 R'(n) 各元素添加至 res 尾端，遍历完成后 res(即 G(n+1))。</p>
<pre><code>class Solution {
    public List&lt;Integer&gt; grayCode(int n) {
        List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;() {{ add(0); }};
        int head = 1;
        for (int i = 0; i &lt; n; i++) {
            for (int j = res.size() - 1; j &gt;= 0; j--)
                res.add(head + res.get(j));
            head &lt;&lt;= 1;
        }
        return res;
    }
}
</code></pre>
<p>然后是利用格雷码性质的题解</p>
<blockquote>
<p>解法二 直接推导<br>
解法一我觉得，在不了解格雷码的情况下，还是可以想到的，下边的话，应该是之前了解过格雷码才写出来的。看下维基百科提供的一个生成格雷码的思路。<br>
以二进制为 0 值的格雷码为第零项，第一项改变最右边的位元，第二项改变右起第一个为1的位元的左边位元，第三、四项方法同第一、二项，如此反复，即可排列出n个位元的格雷码。<br>
以 n = 3 为例。<br>
0 0 0 第零项初始化为 0。<br>
0 0 1 第一项改变上一项最右边的位元<br>
0 1 1 第二项改变上一项右起第一个为 1 的位元的左边位<br>
0 1 0 第三项同第一项，改变上一项最右边的位元<br>
1 1 0 第四项同第二项，改变最上一项右起第一个为 1 的位元的左边位<br>
1 1 1 第五项同第一项，改变上一项最右边的位元<br>
1 0 1 第六项同第二项，改变最上一项右起第一个为 1 的位元的左边位<br>
1 0 0 第七项同第一项，改变上一项最右边的位元<br>
思路有了，代码自然也就出来了。</p>
</blockquote>
<pre><code>public List&lt;Integer&gt; grayCode2(int n) {
    List&lt;Integer&gt; gray = new ArrayList&lt;Integer&gt;();
    gray.add(0); //初始化第零项
    for (int i = 1; i &lt; 1 &lt;&lt; n; i++) {
        //得到上一个的值
        int previous = gray.get(i - 1);
        //同第一项的情况
        if (i % 2 == 1) {
            previous ^= 1; //和 0000001 做异或，使得最右边一位取反
            gray.add(previous);
        //同第二项的情况
        } else {
            int temp = previous;
            //寻找右边起第第一个为 1 的位元
            for (int j = 0; j &lt; n; j++) {
                if ((temp &amp; 1) == 1) {
                    //和 00001000000 类似这样的数做异或，使得相应位取反
                    previous = previous ^ (1 &lt;&lt; (j + 1));
                    gray.add(previous);
                    break;
                }
                temp = temp &gt;&gt; 1;
            }
        }
    }
    return gray;
}
</code></pre>
<blockquote>
<p>时间复杂度：由于每添加两个数需要找第一个为 1 的位元，需要 O（n），所以O(n2^n)。<br>
空间复杂度：O（1）。</p>
</blockquote>
<blockquote>
<p>解法三 公式<br>
二进制转成格雷码有一个公式。<br>
所以我们遍历 0 到 2^n-1，然后利用公式转换即可。即最高位保留，其它位是当前位和它的高一位进行异或操作。</p>
</blockquote>
<pre><code>public List&lt;Integer&gt; grayCode(int n) {
    List&lt;Integer&gt; gray = new ArrayList&lt;Integer&gt;();
    for(int binary = 0;binary &lt; 1 &lt;&lt; n; binary++){
        gray.add(binary ^ binary &gt;&gt; 1);
    }
    return gray;
}
</code></pre>
<blockquote>
<p>时间复杂度：O(2^n)，因为有这么多的结果。<br>
空间复杂度：O（1）。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ [Linux基础] Linux  账号管理 （鸟哥Linux第十三章）]]></title>
        <id>https://lixin-ee.github.io//post/linux-ji-chu-linux-zhang-hao-guan-li-niao-ge-linux-di-shi-san-zhang</id>
        <link href="https://lixin-ee.github.io//post/linux-ji-chu-linux-zhang-hao-guan-li-niao-ge-linux-di-shi-san-zhang">
        </link>
        <updated>2020-01-06T13:24:14.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p>使用者标识符： UID  与 GID<br>
每个登入的使用者至少都会取得两个 ID ，一个是使用者 ID (User ID ，简称<br>
UID)、一个是群组 ID (Group ID ，简称 GID)。<br>
每一个文件都会有所谓的拥有者 ID 与拥有群组 ID，利用 UID 与 GID判别他的拥有者与群组<br>
UID 与账号的对应性：在一部正常运作的 Linux 主机 环境下不能随便更改UID（否则下次登录将没有办法进入自己的家目录）</p>
</li>
<li>
<p>记录相关信息的文件<br>
/etc/passwd 文件<br>
每一行都代表一个账号，有几行就代表有几个账号在系统中<br>
不过 需要特别留意的是，里头很多账号本来就是系统正常运作所必须要的，我们可以简称他为系统账号， 例如 bin, daemon, adm, nobody 等等，这些账号请不要随意删除<br>
id 范围：<br>
0 (系统管理员root) 1~999 (系统账号) 1000~60000 (可登入账号)</p>
</li>
</ul>
<p>由于系统账号主要是用来进行运作系统所需服务的权限设定， 所以系统账号默认都不会主动建立家 目录</p>
<p>/etc/shadow 文件<br>
记录家秘密吗的文件，/etc/passwd 的权限需设定为 -rw-r--r-- 这样的情况</p>
<p>一般用户的密码忘记了：<br>
这个最容易解决，请系统管理员帮忙， 他会重新设定好你的密码而不需要知道你 的旧密码，利用 root 的身份使用 passwd 指令来处理即可<br>
root 密码忘记了：<br>
无法使用 root 的身份登入， 但我们知道 root 的密码在 /etc/shadow 当中，因此你可以使用各种可行的方法开机进入 Linux 再去修改。 例如重新启动进入单人维 护模式(第十九章)后，系统会主动的给予 root 权限的 bash 接口， 此时再以 passwd 修改密码即可；或以 Live CD 开机后挂载根目录去修改 /etc/shadow，将里面的 root 的密码字段清空， 再重新启动后 root 将 不用密码即可登入！登入后再赶快以 passwd 指令去设定 root 密码即可</p>
<p>/etc/group 文件<br>
记录 GID 与组名的对应</p>
<p>有效群组(effective group) 与初始群组(initial group)<br>
假如我同时加入多个群组，那么我在作业的时候，到底是以那个群组为准？</p>
<p>/etc/passwd 里面的第四栏的 GID  就是所谓的『初始群组 (initial group) 』！也就是说，当用户一<strong>登入系统</strong>，立刻就拥有这个群组的相关权限</p>
<p>groups命令 ：有效与支持群组的观察<br>
输出所有支持群组，第一个输出的群组即为有效群组 (effective group) 了<br>
通常有效群组的作用是在<strong>新建文件</strong></p>
<p>newgrp: 有效群组的切换<br>
要切换的 群组必须是你已经有支持的群组<br>
newgrp 这个指令，这个指令可 以变更目前用户的有效群组， 而且是另外以一个 shell 来提供这个功能</p>
<p>加入一个群组有两个方式，一个是透过系统管理员 (root) 利用 usermod 帮你加入，如果 你的系统有设定群组管理员，那么你可以透过 群组管理员以 gpasswd 帮你加入他所管理的群组中</p>
<ul>
<li>账号管理<br>
新增与移除使用者： useradd, 相关配置文件, passwd, usermod, userdel</li>
</ul>
<p>useradd新建使用者<br>
可以简单的使用『 useradd 账号 』来建立 使用者即可</p>
<p>设定密码passwd<br>
使用 useradd 建立了账号之后，在预设的情况下，该账号是暂时被封锁的，需要使用使用 passwd 设定新密码<br>
<code>[root@study ~]# passwd [ -- stdin] [ 账号名称]</code><br>
要帮一般账号建立密码需要使用『 passwd 账号 』的格式，使 用『 passwd 』表示修改自己的密码</p>
<p>chage更详细的密码参数设置功能</p>
<p>usermod账号相关数据的微调<br>
在 useradd 的时候加入了错误的设定数据。或者是，在使用 useradd 后，发现某些地方还可以进行细部修改</p>
<p>userdel删除用户的相关数据<br>
使用 userdel 的时机通常是『你真的确定不要让该用户在主机上面使用任 何数据了！』</p>
<ul>
<li>用户功能<br>
id 这个指令则可以查询某人或自己的相关 UID/GID 等等的信息<br>
<code>[root@study ~]# id [username]</code></li>
</ul>
<p>finger  finger 可以查阅很多用户相关的 信息<br>
<code>[root@study ~]# finger [-s] username</code></p>
<p>chsh change shell 的简写<br>
<code>[vbird1@study ~]$ chsh [-ls]</code><br>
选项与参数：<br>
-l ：列出目前系统上面可用的 shell ，其实就是 /etc/shells 的内容<br>
-s ：设定修改自己的 Shell 啰</p>
<ul>
<li>新增与移除群组<br>
groupadd<br>
<code>[root@study ~]# groupadd [-g gid] [-r] 组名</code><br>
选项与参数：<br>
-g ：后面接某个特定的 GID ，用来直接给予某个 GID<br>
-r ：建立系统群组啦！与 /etc/login.defs 内的 GID_MIN 有关。<br>
新建的与使用者私 有群组无关的其他群组时，使用小于 1000 以下的 GID 为宜，最好能够使用『 groupadd -r 群组名』的方式来建立</li>
</ul>
<p>groupmod 进行 group 相关参数的修改</p>
<p>groupdel  删除群组<br>
『必须要确认 /etc/passwd 内的账号没有任何人使用该群组作为 initial group 』如果有某个账号 (/etc/passwd) 的 initial group 使用该群组』就不能删除</p>
<p>gpasswd：群组管理员功能</p>
<ul>
<li>使用者身份切换<br>
su 是最简单的身份切换指令了，可以进行任何身份的切换<br>
[root@study ~]# su [lm] [-c 指令 ] [username]<br>
选项与参数：<br>
-：单纯使用 - 如『 su - 』代表使用 login-shell 的变量文件读取方式来登入系统； 若使用者名称没有加上去，则代表切换为 root 的身份。<br>
-l ：与 - 类似，但后面需要加欲切换的使用者账号！也是 login-shell 的方式。<br>
-m ：-m 与 -p 是一样的，表示『使用目前的环境设定，而不读取新使用者的配置文件』<br>
-c ：仅进行一次指令，所以 -c 后面可以加上指令喔！</li>
</ul>
<p>注意：单纯使用『 su 』切换成为 root 的身份，读取的变量设定方式为 non-login shell 的方式，这种方式 很多原本的变量不会被改变,应该使用『 su - 』</p>
<p>sudo<br>
sudo 的执行则仅需要自己的密 码即可， 甚至可以设定不需要密码即可执行 sudo 由于 sudo 可以让你以其他用户的身份执行 指令 (通常是使用 root 的身份来执行指令)，因此<strong>并非所有人</strong>都能够执行 sudo ， 而是仅有规范到 /etc/sudoers 内的用户才能够执行 sudo 这个指令<br>
<code>[root@study ~]# sudo [-b] [-u 新使用者 账号]</code><br>
选项与参数：<br>
-b ：将后续的指令放到背景中让系统自行执行，而不与目前的 shell 产生影响<br>
-u ：后面可以接欲切换的使用者，若无此项则代表切换身份为 root 。</p>
<p>sudo 可以让你切换身份来进行某项任务<br>
sudo 执行的重点是：『能否使用 sudo 必须要看 /etc/sudoers 的设定值， 而可使用 sudo 者 是透过输入用户自己的密码来执行<strong>后续的指令串</strong>』</p>
<p>visudo 与 /etc/sudoers<br>
除了 root 之外的其他账号，若想要使用 sudo 执行属于 root 的权限 指令，则 root 需要先使用 visudo 去修改 /etc/sudoers ，让该账号能够使用全部或部分的 root 指令 功能。</p>
<ul>
<li>查询使用者： w, who, last, lastlog<br>
w 或 who：目前已登入在系统上面的用户<br>
last:登录时间和登录状态<br>
lastlog:每个账号的最近登入的时间</li>
</ul>
<p>使用者对谈： write, mesg, wall<br>
write 可 以直接将讯息传给接收者 write 使用者 账号  用户所在终端接口<br>
mail 使用者邮件信箱</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一三五年模型]]></title>
        <id>https://lixin-ee.github.io//post/yi-san-wu-nian-mo-xing</id>
        <link href="https://lixin-ee.github.io//post/yi-san-wu-nian-mo-xing">
        </link>
        <updated>2020-01-06T12:28:59.000Z</updated>
        <content type="html"><![CDATA[<p>今天看了B站视频<a href="https://www.bilibili.com/video/av82067647?from=search&amp;seid=16182117202617172289">【半佛】你知道奶茶加盟到底有多坑人吗？</a>后结合当前短暂的人生经历（特别是本科的惨痛经历）得到的感想（同时也是第三篇随心感想hhh）</p>
<p>人生就是不断做选择<br>
选项的多少取决于当前的位置能力<br>
选择的好坏则取决于你所获得的信息<br>
我曾经看过一段话就是网络公司对未来的预测可分为一三五年的<br>
我回想一下，我目前的状态也是，一年前了解秋招能够找到offer， 三年前了解能找到很好的offer ，五年前了解则是行业顶尖了（先不讨论执行力）<br>
所以现在抽象一个一三五年模型：<br>
找出自己的目标，分为一三五年目标，<br>
一年目标必须清晰到具体每天要做什么事，能够随时了解目前的进度，每天50%以上的努力要为一年目标服务<br>
然后三年目标为主要目标，要清楚达成目标的途径和需求，可以有弯路，但是必须不时停下来审视自己不断纠正。<br>
五年目标为大目标，可以模糊一点，但必须不断寻找信息和途径使得这个目标逐渐明确， 最后向下划分为三年目标和一年目标</p>
<p>但是这其中包含了已知信息和预见性的问题（目标的基础就是已有信息和预见性）</p>
<p>已知信息的获取很重要（先不考虑信息筛选能力），就好像怎么知道开一家奶茶店会不会赚钱<br>
高中的时候信息向我涌来，躺着学习就行<br>
大学和研究生需要自己去调查，去搜索信息 但是还有很多渠道：师兄师姐、公司招聘、甚至有牛客网这种大家坦诚并且【整理好信息】给你筛选的途径<br>
获取知识的途径也很简单 书籍、视频、leetcode ，所以我也同意孟岩所说的：能够通过勤奋学到的东西没有任何难度。<br>
那么毕业工作后呢？怎么去获取进一步的信息？<br>
我感觉这就是老一辈经常强调人脉重要性的原因，这里不是平时的朋友的概念，也不是那些帮你走后门提供便利的人<br>
而是相当于一本书、一部视频或者一个网站的人，你能够从中获取到相关的信息<br>
比如如何去找相关的上司了解这些东西？或者和行业内的大佬进行关键信息获取的交谈<br>
越往上走，这些信息越来越抽象（怎么赚钱？怎么升职？怎么了解一个行业的信息）<br>
并且获取的难度越高，没有几个人愿意和你敞开来聊（说出口的话就不受你控制了），没几个人愿意暴露自己的缺点弱点或者难堪的过去（谁知道要到什么时候才能释怀呢？）<br>
但是幸好还是有前人的部分书籍总结（或许不是知识，但也有助于改变观念）和网络论坛等渠道（读书和搜索的重要性）<br>
但要达到更高的位置，一定要学会总结经验，抽象经验模型（就好像现在抽象出一三五年模型，不仅仅是盯着眼前的秋招）<br>
更更更重要的是：转化别人的经历为经验。普通人需要犯错后学习，聪明的人主动从别人的指导中学习，精明的人则暗中从别人的经历中学习。</p>
<p>然后就是预见性<br>
怎么知道未来三五年什么会火 现在问自己一句 三五年后什么会火？后台会怎么样？算法会怎么样？<br>
你的预见性不会超出你的已知信息可预测的范围，所以别妄想自己能够通过想象看得更远，一切合理的预见性都从你的已知信息出发进行预测。所以目标不是竖起来就行的了（就好像我要赚一百万一千万），这个目标一定不能是你凭空想象出来的，要实地考察，询问了解，应该是你通过已有信息建立起来一个切实可行的目标，否则它就是空想，这也是很多目标无法达成的原因之一吧</p>
<p>所以终究还是回到了已有信息的问题，那么最后的问题就是，如何去拓展你获取信息的渠道呢？</p>
<p>现在需要获取的信息：五年后达到目标的岗位和途径<br>
需要做的事：尽量做高信息量的交谈，尽量做高信息量的学习</p>
<p>其他想法<br>
一个人懒，不是完全因为他的性格或者身体，很可能是他的已知信息和预见性不足，导致他无法动用意志力去执行高价值行为。（如果你清楚知道某件事五年后让你年入五十万，你会选择不做吗？）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 46. 全排列[中等][回溯]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-46-quan-pai-lie-zhong-deng-hui-su</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-46-quan-pai-lie-zhong-deng-hui-su">
        </link>
        <updated>2020-01-06T01:54:11.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个没有重复数字的序列，返回其所有可能的全排列。<br>
示例:<br>
输入: [1,2,3]<br>
输出:<br>
[<br>
[1,2,3],<br>
[1,3,2],<br>
[2,1,3],<br>
[2,3,1],<br>
[3,1,2],<br>
[3,2,1]<br>
]<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/permutations<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>第一想法反而是昨天的解法，也就是从空集开始，每次往已有集合里面添加一个新元素，然后把符合条件的集合提取出来（错误 因为这样子是有序子序列，但是像 3 2 1是无序序列，不可能先添加3 再添加1 再添加2）<br>
然后利用排列的思想，想用递归来解决问题（也就是<code>4*3*2*1</code>）对递归函数传入一个数组，选择数组其中一个值并加入结果序列中，然后从数组中去除这个值，再继续调用。<br>
陷入一种很尴尬的处境，因为如果要递归调用的话，那么得去除当前nums中的当前元素，erase只接受迭代器，但是得保证当前的nums在下一个循环中必须是不变的，所以我增加了两个临时变量auto tempn=nums,tempc=cur;<br>
注意递归函数的形参必须是传值调用。<br>
原来是用回溯法，前几题见过，但是还没细看<br>
我发现我无意中实现的就是回溯算法hhh但是题解中用了额外的used数组记录已用数据+状态重置，确实比我的temp节省很多额外的空间<br>
不过回溯法还有很多细节需要注意，值得好好看题解</p>
<p>然后来看网友题解</p>
<p><img src="https://lixin-ee.github.io//post-images/1578276026030.png" alt=""></p>
<blockquote>
<p>首先解释“回溯”算法的应用，“回溯”算法主要用于搜索，因此有时候“回溯算法”也叫“回溯搜索”。这里“搜索”的意思是“查找所需要的解”。我们每天使用的“搜索引擎”就是帮助我们在庞大的互联网上搜索我们需要的信息。<br>
而这里的“回溯”指的是“状态重置”，可以理解为“回到过去”、“恢复现场”，是在编码的过程中，为了节约空间而使用的一种技巧。</p>
</blockquote>
<blockquote>
<p>“全排列”就是一个非常经典的“回溯”算法的应用。我们知道，N 个数字的全排列一共有 N! 这么多个。<br>
大家可以尝试一下在纸上写 3 个数字、4 个数字、5 个数字的全排列，相信不难找到这样的方法。<br>
例如数组 [1, 2, 3] 的全排列。<br>
我们先写以 1 开头的全排列，它们是：[1, 2, 3], [1, 3, 2]；<br>
再写以 2 开头的全排列，它们是：[2, 1, 3], [2, 3, 1]；<br>
最后写以 3 开头的全排列，它们是：[3, 1, 2], [3, 2, 1]。<br>
我们只需要按顺序枚举每一位可能出现的情况，已经选择的数字在接下来要确定的数字中不能出现。按照这种策略选取就能够做到不重不漏，把可能的全排列都枚举出来。<br>
在枚举第一位的时候，有 3 种情况。<br>
在枚举第二位的时候，前面已经出现过的数字就不能再被选取了；<br>
在枚举第三位的时候，前面 2 个已经选择过的数字就不能再被选取了。<br>
这样的思路，我们可以用一个树形结构来表示。</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1578276151121.png" alt=""></p>
<blockquote>
<p>使用编程的方法得到全排列，就是在这样的一个树形结构中进行编程，具体来说，就是执行一次深度优先遍历，从树的根结点到叶子结点形成的路径就是一个全排列。<br>
下面我们解释如何编码：<br>
1、首先这棵树除了根结点和叶子结点以外，每一个结点做的事情其实是一样的，即在已经选了一些数的前提，我们需要在剩下还没有选择的数中按照顺序依次选择一个数，这显然是一个递归结构；<br>
2、递归的终止条件是，数已经选够了，因此我们需要一个变量来表示当前递归到第几层，我们把这个变量叫做 depth；<br>
3、这些结点实际上表示了搜索（查找）全排列问题的不同阶段，为了区分这些不同阶段，我们就需要一些变量来记录为了得到一个全排列，我们进行到那一步了，在这里我们需要两个变量：<br>
（1）已经选了哪些数，到叶子结点时候，这些已经选择的数就构成了一个全排列；<br>
（2）一个布尔数组 used，初始化的时候都为 false 表示这些数还没有被选择，当我们选定一个数的时候，就将这个数组的相应位置设置为 true ，这样在考虑下一个位置的时候，就能够以 O(1)O(1) 的时间复杂度判断这个数是否被选择过，这是一种“以空间换时间”的思想。<br>
我们把这两个变量称之为“状态变量”，它们表示了我们在求解一个问题的时候所处的阶段。<br>
4、在非叶子结点处，产生不同的分支，这一操作的语义是：在还未选择的数中依次选择一个元素作为下一个位置的元素，这显然得通过一个循环实现。<br>
5、另外，因为是执行深度优先遍历，从较深层的结点返回到较浅层结点的时候，需要做“状态重置”，即“回到过去”、“恢复现场”，我们举一个例子。<br>
从 [1, 2, 3] 到 [1, 3, 2] ，深度优先遍历是这样做的，从 [1, 2, 3] 回到 [1, 2] 的时候，需要撤销刚刚已经选择的数 3，因为在这一层只有一个数 3 我们已经尝试过了，因此程序回到上一层，需要撤销对 2 的选择，好让后面的程序知道，选择 3 了以后还能够选择 2。<br>
这种在遍历的过程中，从深层结点回到浅层结点的过程中所做的操作就叫“回溯”</p>
</blockquote>
<blockquote>
<p>下面我们就来看看代码应该如何编写：<br>
参考代码 1：（注意：这个代码是错误的，希望读者能自己运行一下测试用例自己发现原因，然后再阅读后面的内容）</p>
</blockquote>
<pre><code>import java.util.ArrayList;
import java.util.List;


public class Solution {

    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {
        // 首先是特判
        int len = nums.length;
        // 使用一个动态数组保存所有可能的全排列
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();

        if (len == 0) {
            return res;
        }

        boolean[] used = new boolean[len];
        List&lt;Integer&gt; path = new ArrayList&lt;&gt;();

        dfs(nums, len, 0, path, used, res);
        return res;
    }

    private void dfs(int[] nums, int len, int depth,
                     List&lt;Integer&gt; path, boolean[] used,
                     List&lt;List&lt;Integer&gt;&gt; res) {
        if (depth == len) {
            res.add(path);
            return;
        }

        for (int i = 0; i &lt; len; i++) {
            if (!used[i]) {
                path.add(nums[i]);
                used[i] = true;

                dfs(nums, len, depth + 1, path, used, res);
                // 注意：这里是状态重置，是从深层结点回到浅层结点的过程，代码在形式上和递归之前是对称的
                used[i] = false;
                path.remove(depth);
            }
        }
    }

    public static void main(String[] args) {
        int[] nums = {1, 2, 3};
        Solution solution = new Solution();
        List&lt;List&lt;Integer&gt;&gt; lists = solution.permute(nums);
        System.out.println(lists);
    }
}
</code></pre>
<blockquote>
<p>这段代码在运行的时候输出如下：<br>
[[], [], [], [], [], []]<br>
原因出现在递归终止条件这里：<br>
if (depth == len) {<br>
res.add(path);<br>
return;<br>
}<br>
path 这个变量所指向的对象在递归的过程中只有一份，深度优先遍历完成以后，因为回到了根结点（因为我们之前说了，从深层结点回到浅层结点的时候，需要撤销之前的选择），因此 path 这个变量回到根结点以后都为空。<br>
在 Java 中，因为都是值传递，对象类型变量在传参的过程中，复制的都是变量的地址。这些地址被添加到 res 变量，但实际上指向的是同一块内存地址，因此我们会看到 6 个空的列表对象。解决的方法很简单，在 res.add(path); 这里做一次拷贝即可。<br>
修改的部分：</p>
</blockquote>
<pre><code>Java
if (depth == len) {
    res.add(new ArrayList&lt;&gt;(path));
    return;
}
</code></pre>
<blockquote>
<p>此时再提交到「力扣」上就能得到一个 Accept 了。<br>
希望大家能够通过这个例子理解“回溯”这个方法在搜索问题中起到的作用。<br>
下面我们对这一版的代码做以下几个说明：<br>
1、如果在每一个非叶子结点分支的尝试，我都创建新的变量表示状态，那么不需要“回溯”，在递归终止的时候，也不需要做拷贝。这样的做法虽然可以得到解，但同时会创建很多中间变量，这些中间变量很多时候是我们不需要的，会有一定空间和时间上的消耗。</p>
</blockquote>
<blockquote>
<p>为了验证上面的说明，我们写如下代码进行实验：<br>
参考代码 2：</p>
</blockquote>
<pre><code>Java
import java.util.ArrayList;
import java.util.List;

public class Solution {

    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {
        // 首先是特判
        int len = nums.length;
        // 使用一个动态数组保存所有可能的全排列
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();

        if (len == 0) {
            return res;
        }


        boolean[] used = new boolean[len];
        List&lt;Integer&gt; path = new ArrayList&lt;&gt;();

        dfs(nums, len, 0, path, used, res);
        return res;
    }

    private void dfs(int[] nums, int len, int depth,
                     List&lt;Integer&gt; path, boolean[] used,
                     List&lt;List&lt;Integer&gt;&gt; res) {
        if (depth == len) {
            // 3、不用拷贝，因为每一层传递下来的 path 变量都是新建的
            res.add(path);
            return;
</code></pre>
<blockquote>
<p>这就好比我们在实验室里做对比实验，每一个步骤的尝试都要保证使用的材料是一样的。为此有两种办法：<br>
（1）每做完一种尝试，都把实验材料恢复成做上一个实验之前的样子，只有这样做出的对比才有意义；<br>
（2）每一次尝试都使用同样的新的材料做实验。<br>
只不过很多时候，做实验对材料有破坏性。不过在计算机的世界里，“恢复现场”和“回到过去”是相对容易的。<br>
在一些字符串的“回溯”问题中，有些时候不需要回溯就是这个原因，因为字符串变量在拼接的过程中会产生新的对象（针对 Java 和 Python 语言，其它语言我并不清楚）。<br>
如果你使用 Python 语言，会知道有这样一种语法：[1, 2, 3] + [4] 也是创建了一个新的列表对象，我们已经在“参考代码 2”中展示这种写法。<br>
2、也可以不使用 used 数组，在遍历的过程中，对于一个数是否使用过，就得遍历 path 里的每一个元素，这个操作的时间复杂度是 O(N)O(N)，一般情况下，没有必要节约这个空间。<br>
3、ArrayList 是 Java 中的动态数组，Java 建议我们如果一开始就知道这个集合里需要保存元素的大小，可以在初始化的时候直接传入。<br>
在 res 变量初始化的时候，最好传入 len 的阶乘。<br>
在 path 变量初始化的时候，可以传入 len 。<br>
4、path 变量我们发现只是对它的末尾位置进行增加和删除的操作，显然它是一个栈，因此，使用栈语义会更清晰。但同时 Stack 这个类的文档我们，由于一些设计上的问题，建议我们使用：<br>
<code>Deque&lt;Integer&gt; stack = new ArrayDeque&lt;Integer&gt;();</code><br>
这一点让我很奔溃，Deque 是双端队列，它提供了更灵活的接口，同时破坏了语义，一不小心，如果用错了接口，就会导致程序错误。我采用的做法是接收官方的建议，在程序变量命名和使用的接口时让语义尽量清晰：<br>
这里 path 我需要表示它是从根结点到叶子结点的路径，我认为这个语义更重要，因此不改名为 stack。而在末尾添加元素和删除元素的时候，分别使用 addLast() 和 removeLast()<br>
方法强调只在末尾操作。<br>
5、布尔数组在这题里的作用是判断某个位置上的元素是否已经使用过。有两种等价的替换方式：</p>
</blockquote>
<blockquote>
<p>（1）哈希表；<br>
参考代码 3：</p>
</blockquote>
<pre><code>JavaPython
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class Solution {

    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {
        int len = nums.length;

        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(factorial(len));
        if (len == 0) {
            return res;
        }

        // 使用哈希表检测一个数字是否使用过
        Set&lt;Integer&gt; used = new HashSet&lt;&gt;(len);
        Deque&lt;Integer&gt; path = new ArrayDeque&lt;&gt;(len);

        dfs(nums, len, 0, path, used, res);
        return res;
    }

    private int factorial(int n) {
        int res = 1;
        for (int i = 2; i &lt;= n; i++) {
            res *= i;
        }
        return res;
    }

    private void dfs(int[] nums, int len, int depth,
                     Deque&lt;Integer&gt; path, Set&lt;Integer&gt; used,
                     List&lt;List&lt;Integer&gt;&gt; res) {
        if (depth == len) {
            res.add(new ArrayList&lt;&gt;(path));
            return;
        }

        for (int i = 0; i &lt; len; i++) {
            if (!used.contains(i)) {
                used.add(i);
                path.addLast(nums[i]);

                dfs(nums, len, depth + 1, path, used, res);

                path.removeLast();
                used.remove(i);
            }
        }
    }
}
</code></pre>
<blockquote>
<p>（2）位掩码，即使用一个整数表示布尔数组。此时可以将空间复杂度降到 O(1)（不包括 path 变量和 res 变量）。<br>
参考代码 4：</p>
</blockquote>
<pre><code>JavaPython
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.List;


public class Solution {

    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {
        int len = nums.length;
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(factorial(len));
        if (len == 0) {
            return res;
        }

        int used = 0;
        Deque&lt;Integer&gt; path = new ArrayDeque&lt;&gt;(len);
        dfs(nums, len, 0, path, used, res);
        return res;
    }

    private int factorial(int n) {
        int res = 1;
        for (int i = 2; i &lt;= n; i++) {
            res *= i;
        }
        return res;
    }

    private void dfs(int[] nums, int len, int depth,
                     Deque&lt;Integer&gt; path, int used,
                     List&lt;List&lt;Integer&gt;&gt; res) {
        if (depth == len) {
            res.add(new ArrayList&lt;&gt;(path));
            return;
        }

        for (int i = 0; i &lt; len; i++) {
            if (((used &gt;&gt; i) &amp; 1) == 0) {
                path.addLast(nums[i]);
                used ^= (1 &lt;&lt; i);

                dfs(nums, len, depth + 1, path, used, res);
                used ^= (1 &lt;&lt; i);
                path.removeLast();
            }
        }
    }
}
</code></pre>
<blockquote>
<p>总结<br>
下面思考一个问题，为什么得使用深度优先遍历？下面是我给出的答案。<br>
1、状态空间很大，如果每一个状态都去创建新的变量，消耗很大。<br>
就这本题，我们只需要叶子结点的那个状态。在候选数比较多的时候，我们在非叶子结点上创建新的状态变量的性能消耗就很严重。<br>
2、深度优先遍历的好处是：不同状态之间的切换很容易，想一想这个遍历的过程，每两个状态之间的差别只有 1 处，因此回退非常方便，这也正是“回溯”这个技巧可以用于搜索的原因。<br>
3、如果使用广度优先遍历，从浅层转到深层，状态的变化就很大，此时我们不得不在每一个状态都新建变量去保存它，从性能来说是不划算的。<br>
使用深度优先遍历，我们是直接使用了系统栈，系统栈帮助我们保存了每一个结点的状态信息。于是我们不用编写结点类，不必手动编写栈完成深度优先遍历。广度优先遍历就得使用队列，然后编写结点类。<br>
大家可以尝试使用广度优先遍历实现一下，就能体会到这一点。<br>
4、由于回溯算法的时间复杂度很高，因此，如果我们在遍历的时候，如果能够提前知道这一条分支不能搜索到满意的结果，就可以提前结束，这一步操作称之为剪枝。</p>
</blockquote>
]]></content>
    </entry>
</feed>