<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-09-02T12:38:30.917Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[GitHub远程提交代码]]></title>
        <id>https://lixin-ee.github.io//post/github-yuan-cheng-ti-jiao-dai-ma</id>
        <link href="https://lixin-ee.github.io//post/github-yuan-cheng-ti-jiao-dai-ma">
        </link>
        <updated>2019-09-02T12:27:19.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1下载git工具">1.下载git工具</h1>
<h1 id="2在将要上传的文件文件夹中右键-git-bash-here">2.在将要上传的文件/文件夹中右键 git bash here</h1>
<p>注意，例如我要提交 cpp-primer中的chapter1文件夹，就应该在cpp-primer文件夹中打开git工具</p>
<h1 id="3绑定用户">3.绑定用户</h1>
<pre><code>git config --global user.name &quot;Lixin-ee&quot;
git config --global user.email &quot;im_lixin@foxmail.com&quot;
</code></pre>
<h1 id="4生成ssh-key">4.生成ssh key</h1>
<p><code>cd ~/.ssh</code><br>
检查是否已生成密钥，如果返回的ls有3个文件,则密钥已经生成。<br>
如果没有密钥，则通过下面命令生成<br>
<code>ssh-keygen -t rsa -C &quot;im_lixin@foxmail.com&quot;</code><br>
生成成功后，去对应目录C:\Users\你的电脑名.ssh里用记事本打开id_rsa.pub，得到ssh key公钥。</p>
<h1 id="5为github账号配置ssh-key">5.为github账号配置ssh key</h1>
<p>切换到github-settings-SSH key-Add SSH key-填上标题（最好跟本地仓库保持一致）。</p>
<h1 id="6建立本地仓库">6.建立本地仓库</h1>
<p>执行指令：<br>
<code>git init</code><br>
初始化成功后你会发现项目里多了一个隐藏文件夹.git<br>
执行指令：<br>
<code>git add .</code><br>
将所有文件添加到仓库<br>
执行指令：<br>
<code>git commit -m &quot;提交文件&quot;</code><br>
注意双引号内是github仓库中文件的注释！！！一定要修改，比如我的可以改成chapter1.</p>
<h1 id="7到github-text仓库复制仓库地址">7.到github text仓库复制仓库地址</h1>
<p>执行指令：<br>
<code>git remote add origin https://github.com/Lixin-ee/cpp-primer.git</code></p>
<h1 id="8上传本地代码">8.上传本地代码</h1>
<p>执行指令：<br>
<code>git push -u origin master</code></p>
<h1 id="9刷新github">9.刷新github</h1>
<p>完成！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第一章 笔记+习题]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-yi-zhang-bi-ji-xi-ti</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-yi-zhang-bi-ji-xi-ti">
        </link>
        <updated>2019-09-02T07:30:37.000Z</updated>
        <content type="html"><![CDATA[<p>1.1<br>
c++程序必须有一个函数命名为main<br>
函数定义包括四部分：返回类型，函数名，函数主题，形参列表<br>
main函数的返回类型必须为int<br>
main的返回值用于指示状态，返回值0表明成功，非0用于指出错误类型</p>
<p>习题1.2</p>
<pre><code>int main() {
	return -1;
}
</code></pre>
<p>//程序“[45476] cpphomework.exe”已退出，返回值为 -1 (0xffffffff)。</p>
<p>1.2<br>
iostream 分为 istream和ostream<br>
cin 标准输入 cout 标准输出 cerr 标准错误 clog 输出程序运行的一般信息<br>
#include&lt;头文件&gt;<br>
输出运算符 &lt;&lt; 左侧的运算对象必须是一个ostream对象，右侧运算对象就是要打印的值<br>
endl 操纵符 结束当前行，并将缓冲区的内容刷到设备中<br>
st::指出cout和endl是定义在名为std的命名空间中<br>
标准库所有名字都在命名空间std中<br>
命名空间 避免名字相同冲突<br>
::作用域运算符<br>
输入运算符&gt;&gt;</p>
<p>习题1.3</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;

int main() {
	cout &lt;&lt; &quot;Hello,World&quot; &lt;&lt; endl;
}
</code></pre>
<p>习题1.4</p>
<pre><code>int main() {
	int a = 1, b = 3;
	cout &lt;&lt; &quot;a+b=&quot;&lt;&lt;a+b&lt;&lt; endl;
	cout &lt;&lt; &quot;a*b=&quot; &lt;&lt; a*b &lt;&lt; endl;
}
</code></pre>
<p>习题1.5</p>
<pre><code>int main() {
	int a = 1, b = 3;
	cout &lt;&lt; &quot;a+b=&quot;;
	cout &lt;&lt; a + b &lt;&lt; endl;
	cout &lt;&lt; &quot;a*b=&quot; ;
	cout &lt;&lt;  a*b &lt;&lt; endl;
	while (1);
}
</code></pre>
<p>注意此处为了维持格式一致，endl的使用时机要把握好。</p>
<p>习题1.6<br>
非常明显的不合法，因为一句代码的结束是以分号为标志的，如果没有遇到分号，则程序会自动读取第二行，所以需要把多余的分号去除。</p>
<p>1.3注释简介<br>
// 双斜线注释 用于半行和单行附注<br>
/* */注释界定符 用于多行注释<br>
/* */注释界定符 不能嵌套在另外一个注释界定符内</p>
<p>习题1.7<br>
warning C4138: 在注释外找到“*/”<br>
习题1.8<br>
第一句 合法 输出*  实际输出/*<br>
第二句 合法 输出*/  实际输出*/<br>
第三句 不合法  实际不合法<br>
第四句 不合法 实际不合法</p>
<p>1.4 控制流<br>
习题 1.9</p>
<pre><code>int main() {
	int i = 50;
	int sum = 0;
	while (i &lt;= 100) {
		sum += i;
		++i;
	}
	cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl;
}
</code></pre>
<p>习题1.10<br>
int main() {<br>
int i = 10;<br>
while (i &gt;=0) {<br>
cout &lt;&lt; i-- &lt;&lt; endl;<br>
}<br>
}<br>
习题1.11</p>
<pre><code>int main() {
	int begin,end;
	cout &lt;&lt; &quot;Please input one number:&quot;;
	cin &gt;&gt; begin;
	cout &lt;&lt; &quot;Please input another number:&quot;;
	cin &gt;&gt; end;
	if (end &lt; begin)
		swap(begin, end);
	while (end &gt;= begin) 
	  cout &lt;&lt; begin++ &lt;&lt; endl;
}
</code></pre>
<p>1.4.2<br>
for循环头中定义的变量在循环结束后不能再使用<br>
while同理，循环条件中定义的变量作用范围仅仅在循环体内</p>
<p>习题 1.12<br>
完成了从-100到100的整数的相加和，sum终值为0<br>
习题1.13<br>
本题比较简单，主要需要注意的是for循环头的特性（1）循环头可以定义多个变量，但所有变量都只能是同一个类型，同时变量作用域只在循环内（2）表达式也可以有多个，但是一般来说都是用来改变判断条件的，太复杂反而适得其反。<br>
习题1.14<br>
for循环的循环起始很确定，通过循环头就一览无遗，适合于确定次数的循环（但是同时要求对循环头有良好的书写习惯）。while适用于只知道判断条件的不确定次数循环，并且需要阅读循环体确认循环变化。<br>
习题1.15<br>
如今许多IDE都为我们提供了自动补全、自动监测等功能，我们甚至无须编译就可以知道错误所在，但是在手写灵感、工作交流当中，避免形式错误还是很重要的。</p>
<p>1.4.3<br>
while(std::cin&gt;&gt;value) 此循环条件实际上检测的是std::cin<br>
习题 1.16</p>
<pre><code>int main() {
	int i = 0,sum = 0;//i的定义必不可少！
	while (cin &gt;&gt; i)//当遇到的输入不为int整数时结束输入
		sum += i;
	cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl;
}
</code></pre>
<p>1.5 类简介<br>
1.5.1	<br>
每一个类都定义了一个新类型 其类型名就是类名<br>
每个对象可以1编写函数调用参数 2用输入运算符&gt;&gt;和输出运算符&lt;&lt;进行读写 3用赋值运算符=进行赋值 4.用加法运算符进行相加？ 5用复合赋值运算符+=进行运算<br>
头文件定义 不属于标准库的头文件 #include “Class_type.h”</p>
<p>习题1.20</p>
<pre><code>int main() {
	Sales_item item_t;
	while (cin &gt;&gt; item_t)
		cout &lt;&lt; item_t&lt;&lt;endl;
}
</code></pre>
<p>习题1.21</p>
<pre><code>int main() {
	Sales_item item_1,item_2;
	cin &gt;&gt; item_1 &gt;&gt; item_2;
	cout &lt;&lt; item_1 + item_2 &lt;&lt; endl;
}
</code></pre>
<p>习题1.22<br>
int main() {<br>
Sales_item item_s;<br>
Sales_item item_t;<br>
while (cin &gt;&gt; item_t) {<br>
item_s += item_t;<br>
cout &lt;&lt; item_s &lt;&lt; endl;<br>
}<br>
}<br>
习题1.23<br>
int main() {<br>
Sales_item item_last, item_curr;<br>
int sum = 1;<br>
if(cin &gt;&gt; item_curr) {<br>
item_last = item_curr;<br>
while (cin &gt;&gt; item_curr) {<br>
if (item_curr.isbn == item_last.isbn) {<br>
item_last += item_curr;<br>
++sum;<br>
}<br>
else<br>
{<br>
cout &lt;&lt; item_last &lt;&lt; '\t' &lt;&lt; sum &lt;&lt; endl;<br>
item_last = item_curr;<br>
sum = 1;<br>
}<br>
}<br>
cout &lt;&lt; item_last &lt;&lt; endl;<br>
}<br>
}</p>
<h1 id="总结">总结</h1>
<p>第一章比较基础，但是从练习中我们可以体会到很多细节，例如for循环头的隐藏设定，参数应该设定为局部变量还是全局变量，参数的作用域影响函数的运行以及输出输入，仔细阅读类定义的头文件再使用类的功能会事半功倍。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode刷题感想09.02]]></title>
        <id>https://lixin-ee.github.io//post/leetcode-shua-ti-gan-xiang-0902</id>
        <link href="https://lixin-ee.github.io//post/leetcode-shua-ti-gan-xiang-0902">
        </link>
        <updated>2019-09-02T02:49:37.000Z</updated>
        <content type="html"><![CDATA[<p>今天第一次开始刷leetcode，遵循前辈们的意见从容易开始刷，第一次选择了一个链表题，题目如下</p>
<p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。<br>
现有一个链表 -- head = [4,5,1,9]，它可以表示为:<br>
输入: head = [4,5,1,9], node = 5<br>
输出: [4,1,9]<br>
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p>
<p>非常基础的一个链表结点删除，但是看到代码后我却无从下手了</p>
<pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void deleteNode(ListNode* node) {
        }
};
</code></pre>
<p>what？只给了一个形参？不是应该给出链表的吗？<br>
但是还是立即开始思考如何遍历链表，这个过程中就暴露自己对遍历记得不牢固了，一直纠结判断条件到底是先判断结点值是否相等还是当前节点是否已经到达尾结点，翻查书籍后发现也不对啊，书中描述至少应该给出链表和删除标记（删除位置或删除值）<br>
心灰意冷下打开评论才发现是自己读题错误了，题目给出的条件是删除【给定的】节点！<br>
然后瞬间就想出答案了</p>
<pre><code>class Solution {
public:
    void deleteNode(ListNode* node) {
        node-&gt;val = node-&gt;next-&gt;val;
        node-&gt;next =  node-&gt;next-&gt;next;
        }
};
</code></pre>
<p>同时发现一个小问题，一开始在调用val数据成员时想按老习惯进行解引用(*)和调用符（.），由于解引用符的优先级低于调用符，所以是必需在解引用指针时加上括号的，于是就出现了下面的情况：</p>
<pre><code>class Solution {
public:
    void deleteNode(ListNode* node) {
        (*node).val = (*((*node).next)).val;
        (*node).next = (*((*node).next)).next;
        }
};
</code></pre>
<p>代码是自己写的自己还能懂，但是如果和同事交接时，这可读性可以说是惨不忍睹了...所以老习惯不一定是好习惯啊。<br>
这一次的心得体会：还是得好好看题！看清楚题目要求比一切都重要！同时基础要扎实！培养良好的代码风格！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[开始我的博客之路]]></title>
        <id>https://lixin-ee.github.io//post/kai-shi-wo-de-bo-ke-zhi-lu</id>
        <link href="https://lixin-ee.github.io//post/kai-shi-wo-de-bo-ke-zhi-lu">
        </link>
        <updated>2019-09-01T12:13:05.000Z</updated>
        <content type="html"><![CDATA[<p>在今天正式开始我的博客之路<br>
说来惭愧，其实早就知道博客的存在，并从中获取到了非常多的知识以及问题的解决方案，只是一直没有把时间分配出来写博客。但在学习的过程中，越发感觉到编写技术博客的便利之处，例如将书中的笔记整理上传到博客中，方便在手机随时查看，同时可以把相关的文件和完成的项目上传到github，与博客相辅相成，对学习有很大帮助。在与参加实习和秋招的师兄师姐的交流中得到很多令人醍醐灌顶的指点，其中之一便是一个技术博客对一位普通大学学生转化成合格的程序员的重要性，决定从今天起，也就是研二的第一天起坚持更新博客。</p>
<p>初步的构想是为来年的实习打好坚实的基础，目标岗位是C++后台开发与机器学习算法岗。首先开始复习C++与算法数据结构，将C++ primer的笔记重新整理一遍，并将相应的课后题重新做一遍巩固基础知识点。开始LeetCode刷题，将重难点与感想更新到博客上。</p>
<p>千里之行始于足下，但更重要的是看清自己的目标、自己的能力以及自己走过的路。这几天放慢学习的脚步，细细看了很多秋招面经，也与很多师兄师姐谈心，感叹自己之前还是不够拼搏，没有将许多宝贵的时间进行充分的利用，但种下一棵树最好的时间一个是十年前，一个便是现在，虽未必能在一年后的秋招中获得最理想的结果，但我相信踏实走过的路，总会回报以相应的美景。<br>
-2019.09.01</p>
]]></content>
    </entry>
</feed>