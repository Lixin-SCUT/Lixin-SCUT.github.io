<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-02-18T09:04:46.988Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[头文件中的声明与定义]]></title>
        <id>https://lixin-scut.github.io//post/tou-wen-jian-zhong-de-sheng-ming-yu-ding-yi</id>
        <link href="https://lixin-scut.github.io//post/tou-wen-jian-zhong-de-sheng-ming-yu-ding-yi">
        </link>
        <updated>2020-02-18T08:07:18.000Z</updated>
        <content type="html"><![CDATA[<h3 id="头文件与源文件的关系">头文件与源文件的关系：</h3>
<p>建议函数和变量在头文件中声明，在源文件中定义,<br>
含有函数声明的头文件应该被包含到定义函数的源文件中，<br>
通过以上的配合，其实就是将所有用到该函数的cpp文件中的声明移动到头文件中，编译器会自动在包含了头文件的cpp文件中搜索函数定义，从而以后可以很方便地修改函数的声明（比如修改形参数量），不需要一个一个地在使用了该函数的cpp文件中修改。</p>
<h3 id="注意点或例外">注意点或例外：</h3>
<p><strong>头文件中不应：</strong></p>
<ol>
<li>头文件不应包含using声明<br>
否则会影响到所有使用该头文件的程序：头文件如果在其顶层作用域中含有using指示或using声明，则会将名字注入到所有包含了该头文件的文件中。通常情况下，头文件应该只负责定义接口部分的名字，而不定义实现部分的名字。因此，头文件最多只能在它的函数或命名空间内使用using指示或using声明</li>
</ol>
<p><strong>头文件中应该加入：</strong></p>
<ol>
<li>通常应该在函数声明中指定默认实参，并将该声明放在合适的头文件中</li>
<li>与其他函数不同，内联函数和Constexpr函数可以多次定义，但需要保持一致，所以通常定义在头文件中</li>
<li>如果非成员函数是类接口的组成部分，则这些函数的声明应该与类（的声明）在同一个头文件内</li>
<li>友元的声明仅仅指定了访问的权限，并非一个通常意义上的函数声明，所以如果希望类的用户能够调用某个友元的函数，那么就必须在友元声明之外专门对函数进行一次声明，通常会把友元的声明和类本身放置在同一个头文件中（类的外部）</li>
<li>在一个构造函数中，noexcept出现在参数列表和初始化列表开始的冒号之间，同时我们必须在类头文件的声明和定义中（定义在类外时）都指定noexcept</li>
<li>函数模板和类模板成员函数的定义通常放在头文件中：<br>
为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义。因此，与非模板代码不同，模板的头文件通常既包括声明也包括定定义。</li>
<li>模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明应该放在前面，然后是这些模板的特例化版本。</li>
<li>命名空间的定义可以不连续的特性使得我们可以将几个独立的接口和实现文件（头文件+源文件）组成一个命名空间。此时，命名空间的组织方式类似于我们管理自定义类及函数的方式：<br>
• 命名空间的一部分成员的作用是定义类，以及声明作为类接口的函数及对象，则这些成员应该置于头文件中，这些头文件将被包含在使用了这些成员的文件中。<br>
• 命名空间成员的定义部分则置于另外的源文件中。<br>
在程序中某些实体只能定义一次：如非内联函数、静态数据成员、变量等，命名空间中定义的名字也需要满足这一要求，我们可以通过上面的方式组织命名空间并达到目的。这种接口和实现分离的机制确保我们所需的函数和其他名字只定义一次，而只要是用到这些实体的地方都能看到对于实体名字的声明</li>
<li>如果一个头文件定义了未命名的命名空间，则该命名空间中定义的名字将在毎个包含了该头文件的文件中对应不同实体。</li>
</ol>
<p>#头文件中可以写类的实现吗<br>
可以，但是不建议，因为除了内联函数和Constexpr函数等函数，其他大部分类成员函数必须遵守唯一定义的规则，因为编译器不让你重复定义一个函数两次。如果有两个cpp文件都包含一个h文件，而那个h文件里有函数的定义的话，就相当于定义了那个函数两次，编译器就会报错。</p>
<p>#编译库文件的话可以把类的实现写在头文件中吗<br>
不应该，库只对用户开放有限的说明，目的是让用户可以使用库，但却不知道库的具体实现。典型的就是提供给用户头文件和.lib二进制文件。头文件通常包含数据结构声明或定义和函数的原型声明以及常量宏定义，而库文件则是实际的数据结构和函数功能实现。（注：对于动态链接的库，只是把链接放到了运行阶段，原理类似）。这种方式下，用户只知道有限的使用信息，对于库的实现对用户是不可见的。这就起到了隐藏实现的作用，</p>
<p>#头文件中#ifdef，#endif 有什么作用。<br>
预处理变量之头文件保护符：预处理器看到#include标记时就会用指定的头文件的内容代替#include，使用头文件保护符以防止头文件被某个文件重复包含。<br>
#define 将一个名字设定为预处理变量 #ifdef 当且仅当变量已定义时为真 #ifndef当且仅当变量未定义时时为真   遇到#endif指令停止<br>
预处理变量无视作用域的规则<br>
预处理变量 包括头文件保护符必须唯一 使用头文件中类的名字来构建保护符的名字，同时大写预处理变量的名字</p>
<p>#Static 关键字可以在头文件中声明吗<br>
可以，在头文件里面声明一个 static 变量，在两个不同的 cpp 里面#include 这个变量有没有问题<br>
但是因为static变量只能在当前文件中使用，所以在不同的源文件中有不同的实体，彼此是相互独立的<br>
<a href="https://lixin-scut.github.io/post/czhong-de-guan-jian-zi-static/">C++中的关键字 static</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 题21:调整数组顺序使奇数位于偶数前面[未做出]]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-ti-21diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-ti-21diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-wei-zuo-chu">
        </link>
        <updated>2020-02-18T01:48:36.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述<br>
输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<p>【未做出】<br>
一开始想着就像快速排序那样，从两边开始，遇到不符合的就交换，后来发现一个问题就是[2,1,3]这种交换了变成[3,1,2]，1和3就没法保证相对位置不变了<br>
然后想着从中间开始，但是没法确认奇数偶数的数量的话也没办法啊。。。比如211111，最后2会交换到哪里呢？</p>
<p>网友题解：</p>
<ul>
<li>1.要想保证原有次序，则只能顺次移动或相邻交换。</li>
<li>2.i从左向右遍历，找到第一个偶数。</li>
<li>3.j从i+1开始向后找，直到找到第一个奇数。</li>
<li>4.将[i,...,j-1]的元素整体后移一位，最后将找到的奇数放入i位置，然后i++。</li>
<li>5.終止條件：j向後遍歷查找失敗。</li>
</ul>
<p>实现的时候也需要注意一下<br>
1.此题和书本的题目并不完全一致，书本是不要求稳定性的，可以使用双指针<br>
2.本题完全可以参考插入排序使用空间换时间，比如两次遍历，第一次找奇数第二次找偶数，但是比较简单，所以我针对不使用额外空间的方法<br>
3.基本思想也是插入排序，首先i是指第一个偶数，所以i只需要一次遍历，后面只需要在调动的时候++i即可<br>
4.j不断寻找剩下的奇数并通过循环后移将奇数插入前面<br>
5.我不小心把k的判断条件写成了&lt;=,一直报错，所以一定要注意细节</p>
<pre><code>class Solution {
public:
    void reOrderArray(vector&lt;int&gt; &amp;array) {
        int i=0;
        for(;i&lt;array.size();++i)
            if(array[i]%2==0)
                break;
        for(int j=i;j&lt;array.size();++j)
            if(array[j]%2){
                int temp=array[j];
                for(int k=j;k&gt;=i+1;--k)
                    array[k]=array[k-1];
                array[i]=temp;
                ++i;
                cout&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;endl;
            }
    }
};
</code></pre>
<p>书本题解：<br>
题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序, 使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。<br>
基本功能的解法：可以维护两个指针：第一个指针初始化时指向数组的第一 个数字，它只向后移动；第二个指针初始化时指向数组的最后一个数字， 它只向前移动。在两个指针相遇之前，第一个指针总是位于第二个指针的 前面。如果第一个指针指向的数字是偶数，并且第二个指针指向的数字是奇数，则交换这两个数字。<br>
如果将题目要求进行修改，比如整理负数和非负数，要解决新的问题，其实只需要修改函数ReorderOddEven中的两处判断的标准，而大的逻辑框架完全不需要改动。因此我们可以把这个逻辑框架抽象出来，而把判断的标准变成一个函数指针，也就是用一个单独的函数来判断数字是不是符合标准。这样我们就把整个函数解耦成两部分：一是判断数字应该在数组前半部分还是后半部分的标准；二是拆分数组的操作。<br>
解耦的好处就是提高了代码的重用性，为功能扩展提供了便利。</p>
<pre><code>// ====================方法一====================
void ReorderOddEven_1(int *pData, unsigned int length)
{
    if(pData == nullptr || length == 0)
        return;

    int *pBegin = pData;
    int *pEnd = pData + length - 1;

    while(pBegin &lt; pEnd)
    {
        // 向后移动pBegin，直到它指向偶数
        while(pBegin &lt; pEnd &amp;&amp; (*pBegin &amp; 0x1) != 0)
            pBegin ++;

        // 向前移动pEnd，直到它指向奇数
        while(pBegin &lt; pEnd &amp;&amp; (*pEnd &amp; 0x1) == 0)
            pEnd --;

        if(pBegin &lt; pEnd)
        {
            int temp = *pBegin;
            *pBegin = *pEnd;
            *pEnd = temp;
        }
    }
}

// ====================方法二====================
void ReorderOddEven_2(int *pData, unsigned int length)
{
    Reorder(pData, length, isEven);
}

void Reorder(int *pData, unsigned int length, bool (*func)(int))
{
    if(pData == nullptr || length == 0)
        return;

    int *pBegin = pData;
    int *pEnd = pData + length - 1;

    while(pBegin &lt; pEnd) 
    {
        // 向后移动pBegin
        while(pBegin &lt; pEnd &amp;&amp; !func(*pBegin))
            pBegin ++;

        // 向前移动pEnd
        while(pBegin &lt; pEnd &amp;&amp; func(*pEnd))
            pEnd --;

        if(pBegin &lt; pEnd)
        {
            int temp = *pBegin;
            *pBegin = *pEnd;
            *pEnd = temp;
        }
    }
}

bool isEven(int n)
{
    return (n &amp; 1) == 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 题20:表示数值的字符串[未做出]]]></title>
        <id>https://lixin-scut.github.io//post/zi-fu-chuan-ti-20biao-shi-shu-zhi-de-zi-fu-chuan-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/zi-fu-chuan-ti-20biao-shi-shu-zhi-de-zi-fu-chuan-wei-zuo-chu">
        </link>
        <updated>2020-02-17T01:47:12.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串&quot;+100&quot;,&quot;5e2&quot;,&quot;-123&quot;,&quot;3.1416&quot;和&quot;-1E-16&quot;都表示数值。 但是&quot;12e&quot;,&quot;1a3.14&quot;,&quot;1.2.3&quot;,&quot;+-5&quot;和&quot;12e+4.3&quot;都不是。</p>
</blockquote>
<p>主要的点是了解规则和分割任务，哪些数字可以没有哪些可以有</p>
<pre><code>class Solution {
public:
    bool isNumeric(char* string)
    {
        char *str=string;
        if(str==nullptr)
            return false;
        bool numeric=scanInterger(&amp;str);
        
        if(*str=='.')
        {
            ++str;
            numeric=scanUnsignedInterger(&amp;str)||numeric;
        }
        if(*str=='e'||*str=='E'){
            ++str;
            numeric=numeric&amp;&amp;scanInterger(&amp;str);
        }
        return numeric&amp;&amp;*str=='\0';
    }


bool scanInterger(char **str){
    if(**str=='+'||**str=='-')
        ++(*str);
    return scanUnsignedInterger(str);
}

bool scanUnsignedInterger(char **str){
    char *before=*str;
    while(**str!='\0')
        if(**str&gt;='0'&amp;&amp;**str&lt;='9')
            ++*str;
        else
            break;
    return *str&gt;before;
}
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>表示数值的字符串遵循模式<code>A[.[B]][e|EC]</code>或者<code>.B[e|EC]</code>,其中A为数值的整数部分，B紧跟着小数点为数值的小数部分，C紧跟着'e'或者'E'为数值的指数部分。在小数里可能没有数值的整数部分。例如，小数.123等于0.123。 因此A部分不是必需的。如果一个数没有整数部分，那么它的小数部分不能为空<br>
上述A和C都是可能以'+'或者'-'开头的0〜9的数位串；B也是0〜9 的数位串，但是前面不能有正负号<br>
判断一个字符串是否符合上述模式时，首先尽可能多地扫描0〜9的数位(有可能在起始处有'+'或者'-'，也就是前面模式中表示数值整数的A部分。如果遇到小数点'.'则开始扫描表示数值小数部分的B部分。如果遇到'e'或者'E',则开始扫描表示数值指数的C部分。</p>
</blockquote>
<pre><code>// 数字的格式可以用A[.[B]][e|EC]或者.B[e|EC]表示，其中A和C都是
// 整数（可以有正负号，也可以没有），而B是一个无符号整数
bool isNumeric(const char* str)
{
    if(str == nullptr)
        return false;

    bool numeric = scanInteger(&amp;str);

    // 如果出现'.'，接下来是数字的小数部分
    if(*str == '.')
    {
        ++str;

        // 下面一行代码用||的原因：
        // 1. 小数可以没有整数部分，例如.123等于0.123；
        // 2. 小数点后面可以没有数字，例如233.等于233.0；
        // 3. 当然小数点前面和后面可以有数字，例如233.666
        numeric = scanUnsignedInteger(&amp;str) || numeric;
    }

    // 如果出现'e'或者'E'，接下来跟着的是数字的指数部分
    if(*str == 'e' || *str == 'E')
    {
        ++str;

        // 下面一行代码用&amp;&amp;的原因：
        // 1. 当e或E前面没有数字时，整个字符串不能表示数字，例如.e1、e1；
        // 2. 当e或E后面没有整数时，整个字符串不能表示数字，例如12e、12e+5.4
        numeric = numeric &amp;&amp; scanInteger(&amp;str);
    }

    return numeric &amp;&amp; *str == '\0';
}

bool scanUnsignedInteger(const char** str)
{
    const char* before = *str;
    while(**str != '\0' &amp;&amp; **str &gt;= '0' &amp;&amp; **str &lt;= '9')
        ++(*str);

    // 当str中存在若干0-9的数字时，返回true
    return *str &gt; before;
}

// 整数的格式可以用[+|-]B表示, 其中B为无符号整数
bool scanInteger(const char** str)
{
    if(**str == '+' || **str == '-')
        ++(*str);
    return scanUnsignedInteger(str);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TimerQueue定时器]]></title>
        <id>https://lixin-scut.github.io//post/timerqueue-ding-shi-qi</id>
        <link href="https://lixin-scut.github.io//post/timerqueue-ding-shi-qi">
        </link>
        <updated>2020-02-16T13:57:18.000Z</updated>
        <content type="html"><![CDATA[<p>传统的Reactor通过控制select(2)和poll(2)的等待时间来实现定时，而现在在Linux中有了timerfd,可以用和处理IO事件相同的方式来处理定时，代码的一致性更好</p>
<h3 id="timerqueue-class">TimerQueue class</h3>
<p>muduo的定时器功能由三个class实现,TimerId、Timer、TimerQueue,用户只能看到第一个class,另外两个都是内部实现细节。<br>
TimerQueue的接口很简单，只有两个函数addTimer()和cancel()<br>
addTimer()是供 EventLoop 使用的, EventLoop会把它封装为更好用的runAt()、runAfter()、runEvery()等函数。</p>
<p>TimerQueue数据结构的选择<br>
需求：<br>
1.高效地组织目前尚未到期的Timer<br>
2.能快速地根据当前时间找到已经到期的Timer<br>
3.也要能高效地添加和删除Timer<br>
选择<br>
1.线性表：以按到期时间排好序的线性表为数据结构，缺点：必须进行线性查找<br>
2.二叉堆：能够最快地返回当前到期Timer，复杂度降为O(logN),但是C++标准库的make_heap()等函数不能高效地删除heap中间的某个元素，需要自己实现(令Timer记住自己在heap中的位置) ，否则还是必须遍历查找<br>
3.二叉搜索树（map下为红黑树）:把Timer按到期 时间先后排好序。操作的复杂度仍然是O(log N),不过memory locality比heap要差一些，实际速度可能略慢。但是不能直接用map&lt;Timestamp, Timer*&gt;,因为这 样无法处理两个Timer到期时间相同的情况。有两个解决方案，一是用multimap或 multiset,二是设法区分key。<br>
mudu采用的是第二种做法，这样可以避免使用不常见的multimap class。具体来说，以pair&lt;Timestamp, Timer*&gt;为key,这样即便两个Timer的到期时间相同，它们的地址也必定不同。</p>
<p>最终选用set，因为只需要key而不需要value<br>
TimerQueue 使用了一个 Channel 来观察 timerfd_上的 readable 事件。注意 TimerQueue的成员函数只能在其所属的IO线程调用，因此不必加锁。</p>
<h3 id="改进">改进</h3>
<p>TimerQueue的实现目前有一个不理想的地方，Timer是用裸指针管理的，需要手 动deleteo这里用shared.ptr似乎有点小题大做了。在C++11中，或许可以改进为 unique_ptr,避免手动管理资源</p>
<p>关键的getExpired()函数：这个函数会从timers一中移除已到期的 Timer,并通过vector返回它们。<br>
<img src="https://lixin-scut.github.io//post-images/1581863682263.png" alt=""></p>
<p>EventLoop的改动<br>
EventLoop新增了几个方便用户使用的定时器接口，这几个函数都转而调用 TimerQueue::addTimer()o注意这几个EventLoop成员函数应该允许跨线程使用，比方说想在某个IO线程中执行超时回调。这就带来线程安全性方面的问题，muduo 的解决办法不是加锁，而是把对TimerQueue的操作转移到IO线程来进行，这会用到介绍的 EventLoop:: runInLoop()函数。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[对象模型：普通继承、多重继承与菱形继承]]></title>
        <id>https://lixin-scut.github.io//post/dui-xiang-mo-xing-pu-tong-ji-cheng-duo-chong-ji-cheng-yu-ling-xing-ji-cheng</id>
        <link href="https://lixin-scut.github.io//post/dui-xiang-mo-xing-pu-tong-ji-cheng-duo-chong-ji-cheng-yu-ling-xing-ji-cheng">
        </link>
        <updated>2020-02-16T09:28:05.000Z</updated>
        <content type="html"><![CDATA[<p>对象模型受三点影响：</p>
<ol>
<li>语言本身提供的特性，比如虚拟继承</li>
<li>编译器带来的优化（比如空类插入的char）</li>
<li>编译器要求的字节对齐</li>
</ol>
<h3 id="普通继承">普通继承</h3>
<p>空类的对象模型中有一个编译器安插进去的char，使得sizeof为1，使得空类的两个不同对象在内存中也有独一无二的地址，能够区分开来</p>
<p>静态数据成员只有一个实体，存放在全局数据段中（静态内存），对静态成员取指针只会获得一个指向其数据类型的指针，其类型和class类型无关，不会内含在class类型内<br>
编译器会对不同类中的静态数据成员进行编码，以及name-mangling</p>
<p>因为对形参类型的决议早于整个类声明的完成，所以typedef一定要放在类的开头<br>
而对成员函数的决议会等到整个类声明的完整出现再开始，所以数据成员可以放在后面<br>
非静态成员在对象模型中的顺序和声明顺序一致，和构造函数的构造列表顺序无关</p>
<p>普通数据成员都需要利用类对象来存取，在成员函数中暗中使用了this指针进行提取，使用类对象的起始地址加上offset进行提取</p>
<p>虚拟继承对普通数据成员的存取只是加上了一层间接性</p>
<p>在没有虚函数的情况下，类并没有什么特别</p>
<p>不要随便将类分层，否则容易出现强行padding增大size的情况（如果不padding的话用基类向派生类赋值会导致错误覆盖）<br>
<img src="https://lixin-scut.github.io//post-images/1581851687596.png" alt=""></p>
<p>虚拟继承就是在类对象模型前加上vptr（就算基类没有虚函数而派生类有，vptr也是放在对象模型头部，当然此时把一个派生类对象转换成基类对象就需要编译器介入）<br>
<img src="https://lixin-scut.github.io//post-images/1581852068371.png" alt=""></p>
<h3 id="多重继承">多重继承</h3>
<p>多重继承按照继承的顺序来搭建对象模型<br>
<img src="https://lixin-scut.github.io//post-images/1581852180064.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1581852133439.png" alt=""></p>
<h3 id="虚拟继承">虚拟继承</h3>
<p>虚拟继承中的空虚拟基类的派生类不需要插入char了，只需要一个指针</p>
<p>虚拟继承会将对象模型分割为两个部分：不变局部和共享局部，后者就是虚继承基类对象部分的体现，它们的位置会因为每次派生操作而变化，只可以被简洁存取</p>
<p>一般的布局策略是先安排好派生类的不变部分，然后再建立共享部分<br>
编译器会1.在派生类对象部分分配指向共享部分的指针 2.使用virtual base class table 3.在vtable中分配负的offset使得指向共享部分<br>
<img src="https://lixin-scut.github.io//post-images/1581852581219.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1581852655079.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1581852745780.png" alt=""></p>
<p>Microsoft 下的C++编译器的对象模型<br>
<a href="https://www.cnblogs.com/QG-whz/p/4909359.html">图说C++对象模型：对象内存布局详解</a></p>
<pre><code>//自己的代码
class Base {
public:
    int i1;
    virtual void func1(){ cout &lt;&lt; &quot;func2()&quot; &lt;&lt; endl; };
};

class Derived : public Base {
public:
    int i2;
    virtual void func2(){ cout &lt;&lt; &quot;func1()&quot; &lt;&lt; endl; };
};


void functest(int i){
    cout &lt;&lt; i &lt;&lt; endl;
}
int main() {
    typedef void (*Func)();
    Base b;
    Derived d;
    d.i1 = 8;
    d.i2 = 88;

    int **p=(int**)&amp;b;
    cout&lt;&lt;&quot;基类的虚函数表地址:&quot;&lt;&lt;*p&lt;&lt;endl;
    cout&lt;&lt;&quot;基类的虚函数表中虚函数的地址:0x&quot;&lt;&lt;hex&lt;&lt;**p&lt;&lt;endl;
    
    p=(int**)&amp;d;
    cout&lt;&lt;&quot;派生类的虚函数表地址:&quot;&lt;&lt;p[0]&lt;&lt;endl;
    cout&lt;&lt;&quot;派生类的虚函数表中虚函数的地址:0x&quot;&lt;&lt;p[0][0]&lt;&lt;endl;

    int* i1Ptr = &amp;(d.i1);
    int* i2Ptr = &amp;(d.i2);
    cout &lt;&lt; p+1 &lt;&lt; endl ;
    cout &lt;&lt; i1Ptr &lt;&lt; &quot; &quot; &lt;&lt; i2Ptr &lt;&lt; endl;

//注意**p是一个int而不是int*
//注意在Clion的编译器和Microsoft一致，派生类题添加新的虚函数时，会把虚函数的指针加到基类的虚函数表里面，i2的位置表明并没有新的虚函数表
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[红黑树与二叉平衡树]]></title>
        <id>https://lixin-scut.github.io//post/hong-hei-shu-yu-er-cha-ping-heng-shu</id>
        <link href="https://lixin-scut.github.io//post/hong-hei-shu-yu-er-cha-ping-heng-shu">
        </link>
        <updated>2020-02-16T08:23:39.000Z</updated>
        <content type="html"><![CDATA[<p>#红黑树的时间复杂度<br>
一棵含有n个节点的红黑树的高度至多为2log(n+1)<br>
红黑树能够以O(logn) 的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在三次旋转之内解决。<br>
而迭代器遍历是O(N)</p>
<p>非递归遍历一棵红黑树的时间复杂度和遍历数组的时间复杂度是一样的，多么令人惊奇的结果。<br>
       我们将分析得出这一结果。采用迭代器遍历红黑树的算法主要在迭代器增1操作：<br>
1. 判断右子树是不是空，如果不为空，找到右子树的最小值begin(right(tree))，结束。如果右子树为空，如果右子树为空，转2；<br>
2. 往根节点爬，直到父节点为空或者本节点是父节点的左子节点，然后取父节点的值。<br>
因此红黑树的一条边最多被访问两次：一条边最多只能被从父节点到子节点访问一次和从子节点到父节点访问一次。如果有第三次访问，注意到我们的遍历过程是完全无状态的（步骤1和2判断的唯一是根据当前节点，没有任何其余状态变量）。那么必然会导致至少一个访问的重复，与现实矛盾。证明出一条边最多被访问两次。另外一条边最小要被访问一次，原因是很显然的。因此二叉树的遍历是O(E)的，其中E为树的边数，我们知道一个节点的节点数和边数的关系为N = E + 1，故得出迭代器遍历一棵红黑树的时间复杂度是O(N)。</p>
<p>#红黑树和二叉平衡树（AVL树）的区别</p>
<ol>
<li>红黑树不追求&quot;完全平衡&quot;，即不像AVL那样要求节点的 |balFact| &lt;= 1，它只要求部分达到平衡，但是提出了为节点增加颜色，<strong>红黑是用非严格的平衡来换取增删节点时候旋转次数的降低</strong>，<strong>任何不平衡都会在三次旋转之内解决</strong>，而AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，<strong>旋转的次数比红黑树要多。</strong></li>
<li>就插入节点导致树失衡的情况，AVL和RB-Tree都是最多两次树旋转来实现复衡rebalance，旋转的量级是O(1)<br>
删除节点导致失衡，AVL需要维护从被删除节点到根节点root这条路径上所有节点的平衡，<strong>旋转的量级为O(logN)</strong>，而<strong>RB-Tree最多只需要旋转3次实现复衡</strong>，只需O(1)，所以说RB-Tree删除节点的rebalance的效率更高，开销更小！</li>
<li>AVL的结构相较于RB-Tree更为平衡，插入和删除引起失衡，如2所述，RB-Tree复衡效率更高；当然，由于AVL高度平衡，因此AVL的Search效率更高啦。</li>
<li>针对插入和删除节点导致失衡后的rebalance操作，红黑树能够提供一个比较&quot;便宜&quot;的解决方案，降低开销，是对search，insert ，以及delete效率的折衷，总体来说，RB-Tree的统计性能高于AVL.</li>
<li>故引入RB-Tree是功能、性能、空间开销的折中结果。<br>
5.1 AVL更平衡，结构上更加直观，时间效能针对读取而言更高；维护稍慢，空间开销较大。<br>
5.2 红黑树，读取略逊于AVL，维护强于AVL，空间开销与AVL类似，内容极多时略优于AVL，维护优于AVL。<br>
红黑树的查询性能略微逊色于AVL树，因为其比AVL树会稍微不平衡最多一层，也就是说红黑树的查询性能只比相同内容的AVL树最多多一次比较，但是，红黑树在插入和删除上优于AVL树，AVL树每次插入删除会进行大量的平衡度计算，而红黑树为了维持红黑性质所做的红黑变换和旋转的开销，相较于AVL树为了维持平衡的开销要小得多<br>
总结：红黑树有着良好的稳定性和完整的功能，性能表现也很不错，综合实力强，在诸如STL的场景中需要稳定表现。实际应用中，若搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。</li>
</ol>
<p>epoll 底层是什么实现(红黑树)<br>
epoll 底层实现原理 在内核中维护红黑树以及 callback 回掉函数</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 题19:正则表达式匹配[未做出]]]></title>
        <id>https://lixin-scut.github.io//post/zi-fu-chuan-ti-19zheng-ze-biao-da-shi-pi-pei-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/zi-fu-chuan-ti-19zheng-ze-biao-da-shi-pi-pei-wei-zuo-chu">
        </link>
        <updated>2020-02-16T01:23:08.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
请实现一个函数用来匹配包括'.'和'<em>'的正则表达式。模式中的字符'.'表示任意一个字符，而'</em>'表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;ab<em>ac</em>a&quot;匹配，但是与&quot;aa.a&quot;和&quot;ab*a&quot;均不匹配</p>
</blockquote>
<p>【未做出】<br>
本来我的想法是从pattern入手，然后分别判断'.'和'*'<br>
可惜在盘点'*'的时候发现一个问题，b*b和bbbbb怎么匹配呢。。。因为必须留下一个b和最后一个b匹配，所以不能直接使用while直接判断</p>
<p>直接看书中题解<br>
注意第二个判断条件中if(*str!='\0'&amp;&amp;*pattern=='\0')不可以改为if(*str=='\0'||*pattern=='\0')<br>
因为测试用例 “”和 “.*” 这两者中明显str可以到尾后位置，而pattern肯定不会先到尾后位置<br>
书中答案相当于递归调用所有的三种可能性（甚至把“.*”都揉合在一起进行判断了）<br>
总之三种判断就是对应了状态机中的状态转移，非常巧妙<br>
最好就是注意和string不同，字符串变量有'\0'兜尾，不用担心if( *(pattern+1)=='*')溢出</p>
<pre><code>class Solution {
public:
    bool match(char* str, char* pattern)
    {
        if(str==nullptr||pattern==nullptr)
                return false;
        return matchCore(str,pattern);
    }
    
    bool matchCore(char *str,char *pattern)
    {
        if(*str=='\0'&amp;&amp;*pattern=='\0')
            return true;
        if(*str!='\0'&amp;&amp;*pattern=='\0')
            return false;
        if(*(pattern+1)=='*')
        {
            if(*(pattern)==*str||(*pattern=='.'&amp;&amp;*str!='\0'))
                return matchCore(str+1,pattern+2)
                ||matchCore(str+1,pattern)
                ||matchCore(str,pattern+2);
            else
                return matchCore(str,pattern+2);
        }
        if(*str==*pattern||(*pattern=='.'&amp;&amp;*str!='\0'))
            return matchCore(str+1,pattern+1);
        
        return false;
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>每次从字符串里拿出一个字符和模式中的字符去匹配。先来分析如何匹配一个字符。如果模式中的字符ch是'.'，那么它可以匹配字符串中的任意字符。如果模式中的字符ch不是而且字符串中的字符也是ch,那么它们相互匹配。当字符串中的字符和模式中的字符相匹配时，接着匹配后面的字符。<br>
相对而言，当模式中的第二个字符不是'*'时，问题要简单很多。如果字符串中的第一个字符和模式中的第一个字符相匹配，那么在字符串和模式上都向后移动一个字符，然后匹配剩余的字符串和模式。如果字符串中的第一个字符和模式中的第一个字符不相匹配，则直接返回false。<br>
当模式中的第二个字符是'*'时，问题要复杂一些，因为可能有多种不同的匹配方式。一种选择是在模式上向后移动两个字符。这相当于'*'和它前面的字符被忽略了，因为'*'可以匹配字符串中的0个字符。如果模式中的第一个字符和字符串中的第一个字符相匹配，则在字符串上向后移动一个字符, 而在模式上有两种选择：可以在模式上向后移动两个字符，也可以保持模式不变。</p>
</blockquote>
<pre><code>bool match(const char* str, const char* pattern)
{
    if(str == nullptr || pattern == nullptr)
        return false;

    return matchCore(str, pattern);
}

bool matchCore(const char* str, const char* pattern)
{
    if(*str == '\0' &amp;&amp; *pattern == '\0')
        return true;

    if(*str != '\0' &amp;&amp; *pattern == '\0')
        return false;

    if(*(pattern + 1) == '*')
    {
        if(*pattern == *str || (*pattern == '.' &amp;&amp; *str != '\0'))
            // 进入有限状态机的下一个状态
            return matchCore(str + 1, pattern + 2)
            // 继续留在有限状态机的当前状态 
            || matchCore(str + 1, pattern)
            // 略过一个'*' 
            || matchCore(str, pattern + 2);
        else
            // 略过一个'*'
            return matchCore(str, pattern + 2);
    }

    if(*str == *pattern || (*pattern == '.' &amp;&amp; *str != '\0'))
        return matchCore(str + 1, pattern + 1);

    return false;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[红黑树--set与map的 底层实现]]></title>
        <id>https://lixin-scut.github.io//post/hong-hei-shu-map-di-ceng-shi-xian</id>
        <link href="https://lixin-scut.github.io//post/hong-hei-shu-map-di-ceng-shi-xian">
        </link>
        <updated>2020-02-15T08:30:36.000Z</updated>
        <content type="html"><![CDATA[<h3 id="二叉搜索树binary-search-tree">二叉搜索树(binary search tree)</h3>
<p>二叉搜索树,可提供对数时间的元素插入和访问.二叉搜索树的节点放置规则是：任何节点的键值一定大于其左子树中的每一个节点的键值，并小于其右子树中的每一个节点的键值。因此，从根节点一直往左走，直至无左路可走，即得最小元素；从根节点一直往右走，直至无 右路可走，即得最大元素。<br>
插入新元素时，可从根节点开始，遇键值较大 者就向左，遇键值较小者就向右，一直到尾端，即为插入点。<br>
欲删除旧节点A,情况可分两种。<br>
如果A只有一个子节点，我们就直接将A的子节点连至A的父节点，并将A删除。如果A有两个子节点，我们就以右子树内的最小节点取代A。注意，右子树的最小节点极易获得：从右子节点开始(视为右子树的根节点)，一直向左走至底即是。</p>
<h3 id="平衡二叉搜索树balanced-binary-search-tree">平衡二叉搜索树(balanced binary search tree )</h3>
<p>因为输入值不够随机，也许因为经过某些插入或删除操作，二叉搜索树可能会失去平衡，造成搜寻效率低落的情况</p>
<p>所谓树形平衡与否，并没有一个绝对的测量标准。大概定义为没有任何一个节点过深（深度过大）</p>
<h3 id="avl-tree-adelson-velskii-landis-tree">AVL tree （ Adelson-Velskii-Landis tree ）</h3>
<p>AVLtree是一个“加上了额外平衡条件”的二叉搜索树。其平衡条件的建立是为了确保整棵树的深度为O(logN)。<br>
直观上的最佳平衡条件是每个节点的左右子树有着相同的高度，但AVLtree退而求其次，只要求任何节点的左右子树高度相差最多1<br>
只要修改最深的失去平衡的节点就能使整棵树重新获得平衡<br>
只要调整“插入点至根节点”路径上，平衡状态被破坏之各节点 中最深的那一个，便可使整棵树重新获得平衡。假设该最深节点为X,由于节点最 多拥有两个子节点，而所谓“平衡被破坏”意味着X的左右两棵子树的高度相差 2,因此我们可以轻易将情况分为四种：</p>
<ol>
<li>插入点位于X的左子节点的左子树——左左。</li>
<li>插入点位于X的左子节点的右子树——左右。</li>
<li>插入点位于X的右子节点的左子树——右左。</li>
<li>插入点位于X的右子节点的右子树——右右。<br>
情况1,4彼此对称，称为外侧(outside)插入，可以采用单旋转操作(single rotation)调整解决。<br>
情况2, 3彼此对称，称为内侧(inside)插入，可以采用双旋 转操作(double rotation)调整解决。</li>
</ol>
<h3 id="rb-tree-红黑树">RB-tree (红黑树)</h3>
<p>RB-tree,不仅是一个二叉搜索树，而且必须满足以下规则:</p>
<ol>
<li>每个节点不是红色就是黑色(图中深色底纹代表黑色，浅色底纹代表红色,</li>
<li>根节点为黑色。</li>
<li>如果节点为红，其子节点必须为黑。</li>
<li>任一节点至NULL (树尾端)的任何路径，所含之黑节点数必须相同。<br>
（注意上述四点中并无一点要求深度，仅仅对颜色作出了要求，使用二叉搜索树的插入方法，然后主要通过第四点进行控制）<br>
根据规则4,新增节点必须为红(注意，这里不是指所有业节点都是红的，叶节点也可以是黑的)；<br>
根据规则3,新增节点之父节点必须为黑。<br>
当新节点根据二叉搜索树的规则到达其插入点，却未能符合上述条件时，就必须调 整颜色并旋转树形。</li>
</ol>
<p>假设新节点为X,其父节点为P,祖父节点为G,伯父节点（父节点之兄弟节点）为S,曾祖父节点为GG。现在，根据二叉搜索树的规则，新节点X必为叶节点。根据红黑树规则4, X必为红。若P亦为红（这就违反了规则3,必须调整树形）,则G必为黑（因为原为RB-tree,必须遵循规则3）。于是、根据X的插入位置及外围节点（S和GG）的颜色，有以下四种情况<br>
<img src="https://lixin-scut.github.io//post-images/1581758953264.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1581758969684.png" alt=""><br>
注意，红黑树可能会产生不平衡的状态（高度相差1以上），但是无所谓，红黑树的平衡性就是比ACL树弱，但红黑树的搜索平均效率和AVL树几乎相等<br>
<img src="https://lixin-scut.github.io//post-images/1581768019234.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1581768036420.png" alt=""></p>
<p>RB-tree有红黑二色，并且拥有左右子节点，其结构为了有更大的弹性，节点分为两层，下图显示节点双层结构和迭代器双层结构的关系。<br>
<img src="https://lixin-scut.github.io//post-images/1581768119608.png" alt=""><br>
RB-tree迭代器属于双向迭代器，但不具备随机定位能力，其提领操作和成员<br>
访问操作与list十分近似，较为特殊的是其前进和后退操作。</p>
<p><img src="https://lixin-scut.github.io//post-images/1581768212987.png" alt=""><br>
每当插入新节点时，不但要依照RB-tree的规则来调整，并且维护 header 的正确性，使其父节点指向根节点，左子节点指向最小节点，右子节点指向最大节点。</p>
<p>insert_unique() 和 insert_equal() 前者表示被插入节点的键值（key）在整棵树中必须独一无二（因此，如果树中已存在相同的键值，插入操作就不会真正进 行），后者表示被插入节点的键值在整棵树中可以重复，因此，无论如何插入都会 成功（除非空间不足导致配置失败）<br>
insert_equal中，遇到相同的节点继续往右走<br>
insert_unique的返回值是个pair，第一元素是个RB-tree迭代器，指向新增节点，第二元素表示插入成功与否</p>
<h3 id="set">set</h3>
<p>set&lt;T&gt;::iterator 被定义为底层 RB-tree 的 const_iterator, 杜绝写入操作。<br>
set拥有与list相同的某些性质：当客户端对它进行元素新增操作 （insert）或删除操作（erase） 时，操作之前的所有迭代器，在操作完成之后都 依然有效。当然，被删除的那个元素的迭代器必然是个例外。</p>
<h3 id="map">map</h3>
<p>如果想要修正元素的键值，答案是不行，因为map元素的键值关系到map元素的排列规则。任意改变map 元素键值将会严重破坏map组织。但如果想要修正元素的实值，答案是可以，因为map元素的实值并不影响map元素的排列规则。因此，map iterators既不是一种 constant iterators 也不是一种 mutable iterators</p>
<p>map拥有和list相同的某些性质：当客户端对它进行元素新增操作 (insert) 或删除操作 (erase) 时，操作之前的所有迭代器，在操作完成之后都 依然有效,当然，被删除的那个元素的迭代器必然是个例外。<br>
插入操作返回一个pair,其第一元素是个迭代器，指向插入妥当的新元素， 或指向插入失败点（键值重复）的旧元素。</p>
<p>附录：红黑树的代码<br>
<img src="https://lixin-scut.github.io//post-images/1581840657808.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1581840674954.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1581840695332.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1581840708526.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1581840722636.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1581840745694.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1581840779069.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1581840797319.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[事务管理四要素 ACID]]></title>
        <id>https://lixin-scut.github.io//post/shi-wu-guan-li-si-yao-su-acid</id>
        <link href="https://lixin-scut.github.io//post/shi-wu-guan-li-si-yao-su-acid">
        </link>
        <updated>2020-02-15T08:15:54.000Z</updated>
        <content type="html"><![CDATA[<p>原子性（Atomicity）<br>
原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。<br>
一致性（Consistency）<br>
事务前后数据的完整性必须保持一致。<br>
隔离性（Isolation）<br>
事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。<br>
持久性（Durability）<br>
持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[B 树和 B+树的区别]]></title>
        <id>https://lixin-scut.github.io//post/b-shu-he-bshu-de-qu-bie</id>
        <link href="https://lixin-scut.github.io//post/b-shu-he-bshu-de-qu-bie">
        </link>
        <updated>2020-02-15T07:49:47.000Z</updated>
        <content type="html"><![CDATA[<p>一，b树<br>
b树（balance tree）和b+树应用在数据库索引，可以认为是m叉的多路平衡查找树，但是从理论上讲，二叉树查找速度和比较次数都是最小的，为什么不用二叉树呢？<br>
因为我们要考虑磁盘IO的影响，它相对于内存来说是很慢的。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。所以我们要减少IO次数，对于树来说，IO次数就是树的高度，而“矮胖”就是b树的特征之一，它的每个节点最多包含m个孩子，m称为b树的阶，m的大小取决于磁盘页的大小。</p>
<p>█一个M阶的b树具有如下几个特征：<br>
定义任意非叶子结点最多只有M个儿子，且M&gt;2；<br>
根结点的儿子数为[2, M]；<br>
除根结点以外的非叶子结点的儿子数为[M/2, M]，向上取整；<br>
非叶子结点的关键字个数=儿子数-1；<br>
所有叶子结点位于同一层；<br>
k个关键字把节点拆成k+1段，分别指向k+1个儿子，同时满足查找树的大小关系。</p>
<p>█有关b树的一些特性，注意与后面的b+树区分：<br>
关键字集合分布在整颗树中；<br>
任何一个关键字出现且只出现在一个结点中；<br>
搜索有可能在非叶子结点结束；<br>
其搜索性能等价于在关键字全集内做一次二分查找；</p>
<p>b树在查询时的比较次数并不比二叉树少，尤其是节点中的数非常多时，但是内存的比较速度非常快，耗时可以忽略，所以只要树的高度低，IO少，就可以提高查询性能，这是b树的优势之一。</p>
<p>二，b+树<br>
b+树，是b树的一种变体，查询性能更好。m阶的b+树的特征：<br>
有n棵子树的非叶子结点中含有n个关键字（b树是n-1个），这些关键字不保存数据，只用来索引，所有数据都保存在叶子节点（b树是每个关键字都保存数据）。<br>
所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。<br>
所有的非叶子结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。<br>
通常在b+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。<br>
同一个数字会在不同节点中重复出现，根节点的最大元素就是b+树的最大元素。</p>
<p>█b+树相比于b树的查询优势：<br>
b+树的中间节点不保存数据，所以磁盘页能容纳更多节点元素，更“矮胖”；（B树的每个结点都存储了key和data，B+树的data存储在叶子节点上。）<br>
b+树查询必须查找到叶子节点，b树只要匹配到即可不用管元素位置，因此b+树查找更稳定（并不慢）；<br>
对于范围查找来说，b+树只需遍历叶子节点链表即可，b树却需要重复地中序遍历</p>
<p><a href="https://www.cnblogs.com/20189223cjt/p/11262450.html">B-树与B+树的区别</a></p>
]]></content>
    </entry>
</feed>