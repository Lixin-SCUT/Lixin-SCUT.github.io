<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-10-27T13:57:50.191Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[关于指针形参的问题]]></title>
        <id>https://lixin-ee.github.io//post/guan-yu-zhi-zhen-xing-can-de-wen-ti</id>
        <link href="https://lixin-ee.github.io//post/guan-yu-zhi-zhen-xing-can-de-wen-ti">
        </link>
        <updated>2019-10-27T13:53:25.000Z</updated>
        <content type="html"><![CDATA[<p>今天做递归的时候发现一个很严重的问题</p>
<pre><code>ListNode* reverse_list(ListNode* head,ListNode* n,ListNode* n_next){
        if(n_next!=NULL){
            reverse_list(head,n_next,n_next-&gt;next);
            n_next-&gt;next=n;
            cout&lt;&lt;head-&gt;val&lt;&lt;endl;
        }    
        else{
            head=n; 
            cout&lt;&lt;head-&gt;val&lt;&lt;endl;
        }
 
       return n;
    }
		
ListNode* reverseList(ListNode* head) {
        if(head==NULL)
            return NULL;
        //ListNode *ln=head-&gt;next;
        ListNode*n=reverse_list(head,head,head-&gt;next);
        n-&gt;next=NULL;
        return head;
    }
    
</code></pre>
<p>为了改变head的值我把head指针传了进去，但是！在递归回来的途中程序却吧head的值改回原值了？WTF？这个问题弄了一个早上也没弄懂，晚上了研究一下发现了问题所在：<br>
head=n;<br>
注意这里我直接使用了指针形参，而不是对指针形参进行解引用再赋值<br>
此时其实和平常我们使用指针形参的情形不太一样，平常我们只会对指针形参进行解引用再赋值，从而达到不需要值传递。但是！指针形参本身就是一个值传递，所以如果像上面直接使用指针形参的值，虽然在函数内是可以改变指针指向的对象，但其实这个指针形参是一个临时变量，一旦离开函数这个临时变量就没了。所以对于指针形参，如果想达到改变值的情况，只能1.对于指针指向的值可以直接改变值2.如果想改变指针的值，形参必须改成指针的引用 也就是*（&amp;head）。</p>
<p>因为所谓的指针形参传递对于指针这个形参本身来说还是值传递！是复制了指针形参过去的！！只有对于指针指向的对象来说才是相当于引用传递，所以head的形参必须改成指针的引用 也就是*（&amp;head）<br>
所以最终代码为</p>
<pre><code>class Solution {

public:
    ListNode* reverse_list(ListNode* (&amp;head),ListNode* n,ListNode* n_next){</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 206. 反转链表 难度：简单]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-206-fan-zhuan-lian-biao-nan-du-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-206-fan-zhuan-lian-biao-nan-du-jian-dan">
        </link>
        <updated>2019-10-27T01:44:48.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>反转一个单链表。<br>
示例:<br>
输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br>
进阶:<br>
你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p>
</blockquote>
<p>难点要点：<br>
1.如何保证指针改变后还能保存指针之前指向的值？比如1-&gt;2-&gt;3 将2指向1后，怎么读3的值？<br>
2.注意链表题<br>
我的思路就是利用三个变量分别保存好这三者，然后进行迭代</p>
<pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(head==NULL)
            return NULL;
        //ListNode *ln=head-&gt;next;
        ListNode *ln=head;
        ListNode *lnn=ln-&gt;next;
        ListNode *temp=NULL;
        while(lnn!=NULL){
            ln-&gt;next=temp;
            temp=ln;
            ln=lnn;
            lnn=lnn-&gt;next;         
        }
        ln-&gt;next=temp;
        head=ln;
        return head;
    }
};
</code></pre>
<p>做递归的时候发现一个很严重的问题</p>
<pre><code>ListNode* reverse_list(ListNode* head,ListNode* n,ListNode* n_next){
        if(n_next!=NULL){
            reverse_list(head,n_next,n_next-&gt;next);
            n_next-&gt;next=n;
            cout&lt;&lt;head-&gt;val&lt;&lt;endl;
        }    
        else{
            head=n; 
            cout&lt;&lt;head-&gt;val&lt;&lt;endl;
        }
 
       return n;
    }


ListNode* reverseList(ListNode* head) {
        if(head==NULL)
            return NULL;
        //ListNode *ln=head-&gt;next;
        ListNode*n=reverse_list(head,head,head-&gt;next);
        n-&gt;next=NULL;
        return head;
    }
    
</code></pre>
<p>为了改变head的值我把head指针传了进去，但是！在递归回来的途中程序却吧head的值改回原值了？WTF？这个问题弄了一个早上也没弄懂，后面再研究一下</p>
<p>10.27晚上更新：因为所谓的指针形参传递对于指针这个形参本身来说还是值传递！是复制了指针形参过去的！！只有对于指针指向的对象来说才是相当于引用传递，所以head的形参必须改成指针的引用 也就是*（&amp;head）<br>
所以最终代码为</p>
<pre><code>class Solution {

public:
    ListNode* reverse_list(ListNode* (&amp;head),ListNode* n,ListNode* n_next){
        
        if(n_next!=NULL){
            reverse_list(head,n_next,n_next-&gt;next);
            n_next-&gt;next=n;
        }    
        else{
            head=n; 
        }
 
       return n;
    }


ListNode* reverseList(ListNode* head) {
        if(head==NULL)
            return NULL;
        //ListNode *ln=head-&gt;next;
        ListNode* n=reverse_list(head,head,head-&gt;next);
        n-&gt;next=NULL;
        return head;
    }
};
</code></pre>
<p>先来看一下题解：</p>
<blockquote>
<p>方法一：迭代<br>
假设存在链表 1 → 2 → 3 → Ø，我们想要把它改成 Ø ← 1 ← 2 ← 3。</p>
<p>在遍历列表时，将当前节点的 next 指针改为指向前一个元素。由于节点没有引用其上一个节点，因此必须事先存储其前一个元素。在更改引用之前，还需要另一个指针来存储下一个节点。不要忘记在最后返回新的头引用！</p>
</blockquote>
<pre><code>public ListNode reverseList(ListNode head) {
    ListNode prev = null;
    ListNode curr = head;
    while (curr != null) {
        ListNode nextTemp = curr.next;
        curr.next = prev;
        prev = curr;
        curr = nextTemp;
    }
    return prev;
}
</code></pre>
<blockquote>
<p>复杂度分析</p>
<p>时间复杂度：O(n)，假设 nn 是列表的长度，时间复杂度是 O(n)。<br>
空间复杂度：O(1)</p>
</blockquote>
<blockquote>
<p>方法二：递归<br>
递归版本稍微复杂一些，其关键在于反向工作。假设列表的其余部分已经被反转，现在我该如何反转它前面的部分？</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1572145652208.png" alt=""></p>
<pre><code>public ListNode reverseList(ListNode head) {
    if (head == null || head.next == null) return head;
    ListNode p = reverseList(head.next);
    head.next.next = head;
    head.next = null;
    return p;
}
</code></pre>
<blockquote>
<p>复杂度分析</p>
<p>时间复杂度：O(n)，假设 nn 是列表的长度，那么时间复杂度为O(n)。<br>
空间复杂度：O(n)，由于使用递归，将会使用隐式栈空间。递归深度可能会达到 n 层。</p>
</blockquote>
<p>然后是比较直观的网友题解</p>
<blockquote>
<p>迭代：<br>
<img src="https://lixin-ee.github.io//post-images/1572145715655.png" alt=""></p>
</blockquote>
<pre><code>ListNode* reverseList(ListNode* head) {
        if(!head){
            return nullptr;
        }
        ListNode* first = head;//始终指向原链表的首位元素
        ListNode* target = head-&gt;next;//始终指向即将要放到当前链表首元素之前的目标元素
        while(target != nullptr){
            first-&gt;next = target-&gt;next;
            ListNode* temp = target-&gt;next;
            target-&gt;next = head;
            head = target;
            target = temp;
        }
        return head;
    }
</code></pre>
<p>递归：</p>
<pre><code>ListNode* reverseList(ListNode* head) {
        if(!head){
            return nullptr;
        }
        return reverse(head, head, head-&gt;next);        
    }
    
    ListNode* reverse(ListNode* head, ListNode* first, ListNode* target){
        if(!target){
            return head;
        }
        first-&gt;next = target-&gt;next;
        ListNode* temp = target-&gt;next;
        target-&gt;next = head;
        return reverse(target, first, temp);
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math 204. 计数质数 难度：简单]]></title>
        <id>https://lixin-ee.github.io//post/math-204-ji-shu-zhi-shu</id>
        <link href="https://lixin-ee.github.io//post/math-204-ji-shu-zhi-shu">
        </link>
        <updated>2019-10-26T01:37:24.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>统计所有小于非负整数 n 的质数的数量。</p>
<p>示例:<br>
输入: 10<br>
输出: 4<br>
解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</p>
</blockquote>
<p>没什么想法，这几天状态很低落，直接看一下题解吧<br>
解决方案:</p>
<blockquote>
<p>一、暴力法（计算超时）：<br>
验证一个数是否为质数（素数）有很多方法。但最容易想到的莫非用暴力计算的方式一步步碾压过去的方法。虽然这种方法不是最优的，但是其对于我们了解素数仍是有所帮助的。<br>
思路：验证某个数是否为质数时，将其对每一个比其小的数进行取余运算，并对取余为零的情况进行计数。由于质数是指在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。所以，当计数结果为 1 时，该数为质数。<br>
在实际操作中，由于 1 和任意一个数必然取余为零，所以可以直接排除。并当没有取余为零的情况时，其才为质数。<br>
得代码如下：</p>
</blockquote>
<pre><code>int countPrimes(int n) {
    int count = 0;
    for (int i = 2; i &lt; n; i++){
        bool sign = true;
        for (int j = 2; j &lt; i; j++){
            if (i % j == 0)
            {
                sign = false;
                break;
            }
        }
        if (sign)
            count++; ;
    }
    return count;
}
</code></pre>
<blockquote>
<p>二、优化暴力算法：<br>
细究暴力计算的方法，我们可以发现，假如一个数为 9 ，那么其二分之一（4.5）后的数都可以不用进行计算，因为肯定是有余的 。事实上情况会比这更好一些：对正整数 n ，如果用 2 到 √n 之间(包含边界)的所有整数去除，均无法整除，则 n 为质数。<br>
并且，我们可以发现，一切非 2 偶数一定不可能为质数。所以，我们可以在此处进行另一步的优化。<br>
有个这些令人庆幸的发现，我们的代码也将如虎添翼：</p>
</blockquote>
<pre><code>int countPrimes(int n) {
    if(n &lt; 3)
        return 0;;
    //从3开始验算，所以初始值为1（2为质数）。
    int count = 1;
    for (int i = 3; i &lt; n; i++){
        //当某个数为 2 的 n 次方时（n为自然数），其 &amp; (n - 1) 所得值将等价于取余运算所得值
        //*如果 x = 2^n ，则 x &amp; (n - 1) == x % n
        //if(i % 2 == 0)
        if ((i &amp; 1) == 0)
            continue; ;
        bool sign = true;
        //用 j * j &lt;= i 代替 j &lt;= √i 会更好。
        //因为我们已经排除了所有偶数，所以每次循环加二将规避偶数会减少循环次数
        for (int j = 3; j * j &lt;=i; j+=2){
            if (i % j == 0){
                sign = false;
                break;
            }
        }
        if (sign)
            count++; ;
    }
    return count;
}
</code></pre>
<blockquote>
<p>(暴力法系列的 C# 和 C++ 的代码几乎相同。)<br>
经过对暴力算法的此番优化，我们的代码初步达到了应用的最低门槛，但显然还是不大理想，好似总感觉存在不必要的操作。但我们经过以上的研究（可以早一步排除偶数），再结合质数的性质，可以推想出：如果我们在进行顺序遍历时，每取得一个数（排除0、1），如果将它所有的倍数（排除0、1、本身）都清除，那么，剩下的数是不是必为素数？<br>
没错，这个有趣且实用的方法便是著名的厄拉多塞筛法！</p>
<p>三、厄拉多塞筛法：<br>
使用厄拉多塞筛法进行 1 到 64 的质数查找的过程如下：</p>
</blockquote>
<pre><code>int countPrimes(int n) {
    int count = 0;
    //初始默认所有数为质数
    vector&lt;bool&gt; signs(n, true);
    for (int i = 2; i &lt; n; i++) {
        if (signs[i]) {
            count++;
            for (int j = i + i; j &lt; n; j += i) {
                //排除不是质数的数
                signs[j] = false;
            }
        }
    }
    return count;
}
</code></pre>
<p>四、运用比特表（Bitmap）算法对筛法进行内存优化：</p>
<p>上面运用厄拉多塞筛法求一定范围内的质数已经十分高效了。然而，我们使用布尔数组标记一个数是否为质数时，每个值都占用了一个字节（Byte）。但是，我们仅需要两个不同的值来表示是否为质数即可。即一个比特（bit）来表示即可（0、1）。如果这样的话，我们便最优可节省八分之七的空间（然而，还得结合代码和实际情况，并不是用了就一定有效果）。</p>
<p>关于比特表算法在此便简要概述以下（可略过）：<br>
假如有从 1 至 8 总共八个数。现有一个字节大小的内存空间可供使用（仅供参考，不考虑实际用途及比特算法的最佳用处）。如何将每个数登记下来，并可以随时检查一个数是否存在呢？</p>
<p>如果用一个数组表示，即使不考虑数组的内存开销，哪怕用一个 byte 类型的变量记录每一数也将超出内存可使用范围。但是由于每个字节共有八个比特位，则可以用每个比特位来表示每个数字则恰好可以登记完所有的数字。</p>
<p>示例：</p>
<p>登记数字 1 ：0 0 0 0 0 0 0 1<br>
登记数字 1、3：0 0 0 0 0 1 0 1<br>
登记数字 1、2、3、4、5 ：0 0 0 1 1 1 1 1<br>
得代码如下：</p>
<pre><code>int countPrimes(int n) {
    int count = 0;
    //一个 int 变量不知道占多少字节（但请注意，这里采用了常量）
    const int size = sizeof(int) * 8;
    vector&lt;int&gt; signs(n / size + 1,0);
    for (int i = 2; i &lt; n; i++){
        //将元素和需确定得数字经行按位或运算，如果值改变，说明不存在该数字（未登记该数字），则其为质数。
        //在C++中，其提供了 bitset 来操作位，在此便不做介绍了。如果用了，可读性肯定会更好。
        //(当某个数为 2 的 n 次方时（n为自然数），其 &amp; (n - 1) 所得值将等价于取余运算所得值)
        //*如果 x = 2^n ，则 x &amp; (n - 1) == x % n
        //下面判断可以写成
        //if ((signs[i / size] &amp; (1 &lt;&lt; (i % 32))) == 0)
        if ((signs[i / size] &amp; (1 &lt;&lt; (i &amp; (size - 1)))) == 0){
            count++;
            for (int j = i + i; j &lt; n; j += i){
                //登记该数字
            	signs[j / size] |= 1 &lt;&lt; (j &amp; (size - 1));
            }
        }
    }
    return count;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math 365. 水壶问题 难度：中等]]></title>
        <id>https://lixin-ee.github.io//post/math-365-shui-hu-wen-ti-nan-du-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/math-365-shui-hu-wen-ti-nan-du-zhong-deng">
        </link>
        <updated>2019-10-25T02:00:12.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？<br>
如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。<br>
你允许：<br>
装满任意一个水壶<br>
清空任意一个水壶<br>
从一个水壶向另外一个水壶倒水，直到装满或者倒空<br>
示例 1: (From the famous &quot;Die Hard&quot; example)<br>
输入: x = 3, y = 5, z = 4<br>
输出: True<br>
示例 2:<br>
输入: x = 2, y = 6, z = 5<br>
输出: False</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/water-and-jug-problem<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>难点要点：<br>
1.需要考虑所有情况，比如再x往y里面不断倒水，y装满后x剩下的水可以作为基础，继续重复。然后还需要考虑一个桶里有水，同时另一个桶可以有空桶和装满两种情况。</p>
<p>我没有找到其中的规律， 只能暴力找所有的解了，所以还是看一下网友题解吧</p>
<blockquote>
<p>ax + by = z 求是否有合理的解 ，如果反过来将x ，y视 为系数 ，并且x= t1 * k ，y= t2 * k<br>
化简 a * t1 * k + b * t2 * k == z;<br>
然后 k * (a * t1 + b * t2) = z;<br>
也就是说z为 a 和 b 的最大公约数k的倍数<br>
特判为 0 的时候 以及 使得等式成立的基本条件 x + y &gt;= z</p>
</blockquote>
<pre><code>class Solution {
public:
bool canMeasureWater(int x, int y, int z) {           
    return z == 0 || ( x + y &gt;= z &amp;&amp; z % __gcd( x , y ) == 0);
}
};
</code></pre>
<blockquote>
<p>若a,b是整数,且gcd(a,b)=d，那么对于任意的整数x,y,ax+by都一定是d的倍数，特别地，一定存在整数x,y，使ax+by=d成立。</p>
<p>本题先判断所需要的水量是否大于两个桶的容量之和，如果不大于，判断所需要的水量是否是两个桶容量的最大公约数的倍数，根据裴蜀定理可以证明：</p>
<p>如果所需要的水量是两个水壶容量的最大公约数的倍数，且水量不大于两个水壶的容量之和，那么必然可以用这两个水壶操作得到所需要的水量。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math 367. 有效的完全平方数 难度：简单]]></title>
        <id>https://lixin-ee.github.io//post/math-367-you-xiao-de-wan-quan-ping-fang-shu-nan-du</id>
        <link href="https://lixin-ee.github.io//post/math-367-you-xiao-de-wan-quan-ping-fang-shu-nan-du">
        </link>
        <updated>2019-10-24T01:08:58.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。<br>
说明：不要使用任何内置的库函数，如  sqrt。</p>
<p>示例 1：<br>
输入：16<br>
输出：True<br>
示例 2：<br>
输入：14<br>
输出：False</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/valid-perfect-square<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>思路：<br>
其实这道题和之前的求开方值非常像，所以我直接用了牛顿迭代法来做了（二分法也是可以的）只是最后需要加上判断条件。</p>
<pre><code>class Solution {
public:
    bool isPerfectSquare(int num) {
        if(num==0||num==1)
            return true;
        int res=sqrts(double(num),num);
        if(res*res==num)
            return true;
        return false;
        
    }
    
    double sqrts(double x,int num){
        double res=(x+num/x)/2;
        if(res==x)
            return x;
        else
            return sqrts(res,num);
    }
};
</code></pre>
<p>对于判断条件，一开始我是想利用res平方是否等于原值来判断的，但是注意！就算double有精度限制，但是就好像计算器一样，如果将其平方是会等于原值的！所以最后我直接讲res强制转换为int，只取整数部分再相乘判断。</p>
<p>下面是网友题解：</p>
<blockquote>
<p>解法：二分法</p>
</blockquote>
<pre><code>class Solution {
public:
    bool isPerfectSquare(int num) {
        int start=1;
        int end=num;
        int mid=start+(end-start)/2;
        while(start&lt;=end)
        {
            if(pow(mid,2)&gt;num)
            {
                end=mid-1;
            }
            else if(pow(mid,2)&lt;num)
            {
                start=mid+1;
            }
            else return true;
            mid=(end-start)/2+start;
        }
        return false;
    }
};
</code></pre>
<blockquote>
<p>解法：公式法<br>
利用 1+3+5+7+9+…+(2n-1)=n^2，即完全平方数肯定是前n个连续奇数的和</p>
</blockquote>
<pre><code>class Solution {
public:
    bool isPerfectSquare(int num) {
        int i=1;
        while(num&gt;0)
        {
            num-=i;
            i+=2;
        }
        return num==0;
    }
};
</code></pre>
<p>解法：牛顿迭代法</p>
<pre><code>if(1 == num) return true;
        int i = num / 2;
        while((double)i * i &gt; num){
            i = (i + num / i) / 2;
        }
        return i * i == num;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math 50. Pow(x, n) 难度：中等]]></title>
        <id>https://lixin-ee.github.io//post/math-50-powx-n-nan-du-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/math-50-powx-n-nan-du-zhong-deng">
        </link>
        <updated>2019-10-23T02:48:00.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>实现 pow(x, n) ，即计算 x 的 n 次幂函数。</p>
<p>示例 1:<br>
输入: 2.00000, 10<br>
输出: 1024.00000<br>
示例 2:<br>
输入: 2.10000, 3<br>
输出: 9.26100<br>
示例 3:<br>
输入: 2.00000, -2<br>
输出: 0.25000<br>
解释: 2-2 = 1/22 = 1/4 = 0.25<br>
说明:<br>
-100.0 &lt; x &lt; 100.0<br>
n 是 32 位有符号整数，其数值范围是 [−2^31, 2^31 − 1] 。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/powx-n<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>要点难点：<br>
1.如果逐个相乘的暴力法肯定会超时<br>
2.n取INT_MIN的时候需要额外的处理<br>
3.需要将负号转化为导数<br>
我的思路<br>
1.既然不能逐个相乘，就利用这几题中都利用到的（逆向）二分法，每次递增一倍，比如 1 2 4 8...如果下一步翻倍的时候会大于n的话，就从1开始重新翻倍<br>
2.针对x为0，1的特例进行优化，同时在对n的负值进行处理的时候单独对INT_MIN进行预处理（先乘一次）<br>
3.优化点：如果有空间的话，可以用一个vector把之前计算的值存起来<br>
最后代码如下：</p>
<pre><code>class Solution {
public:
    double myPow(double x, int n) {
        if(x==0||x==1)
            return x;
        if(n==0)
            return 1;
        if(n&lt;0){
            x=1/x;
            if(n==INT_MIN)
                n=-(n+1),x*=x;
            else
                n=-n;
        }

        int i=1,j=1;
        double res=x,temp=x;
        while(j!=n){
        do{
            res*=temp;
            temp*=temp;
            j+=i;
            i=2*i;  
            }while(j&lt;=n-i);          
        i=1;
        temp=x;
        }
        cout&lt;&lt;res&lt;&lt;endl;
        return res;    
    }
};
</code></pre>
<p>最后来看官方题解和网友题解：</p>
<blockquote>
<p>方法：快速幂算法（递归）<br>
直观想法<br>
假定我们已经得到了 x ^ n的结果，我们如何得到 x ^ {2 * n}的结果？很明显，我们不需要将 x 再乘 n 次。使用公式 (x ^ n) ^ 2 = x ^ {2 * n}，我们可以在一次计算内得到 x ^ {2 * n} 的值。使用该优化方法，我们可以降低算法的时间复杂度。<br>
算法假定我们已经得到了 x ^ {n / 2}的结果，并且我们现在想得到 x ^ n的结果。我们令 A 是 x ^ {n / 2}的结果，我们可以根据 n 的奇偶性来分别讨论 x ^ n的值。如果 n 为偶数，我们可以用公式 (x ^ n) ^ 2 = x ^ {2 * n}来得到 x ^ n = A * A。如果 n 为奇数，那么 A * A = x ^ {n - 1} 。直观上看，我们需要再乘一次 xx ，即 x ^ n = A * A * x。该方法可以很方便的使用递归实现。我们称这种方法为 &quot;快速幂&quot;，因为我们只需最多 O(\log n)O(logn) 次运算来得到 x ^ n 。</p>
</blockquote>
<pre><code>class Solution {
public:
    double fastPow(double x, long long n) {
        if (n == 0) {
            return 1.0;
        }
        double half = fastPow(x, n / 2);
        if (n % 2 == 0) {
            return half * half;
        } else {
            return half * half * x;
        }
    }
    double myPow(double x, int n) {
        long long N = n;
        if (N &lt; 0) {
            x = 1 / x;
            N = -N;
        }
        return fastPow(x, N);
    }
};
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(logn). 每一次我们使用公式 (x ^ n) ^ 2 = x ^ {2 * n}<br>
, n 都变为原来的一半。因此我们需要至多 O(logn) 次操作来得到结果。<br>
空间复杂度：O(logn). 每一次计算，我们需要存储 x ^ {n / 2} 的结果。 我们需要计算O(logn) 次，所以空间复杂度为 O(logn) 。</p>
<p>同时网友提供的另一种二分思想递归：</p>
</blockquote>
<pre><code>class Solution {
public:
    double myPow(double x, int n) {
        if (n == 0) { return 1; }
        if (n == 1) { return x; }
        if (n == -1) { return 1 / x; }
        double half = myPow(x, n / 2);
        double rest = myPow(x, n % 2);
        double total = rest * half * half;
        return total;
    }
};
</code></pre>
<blockquote>
<p>另外一种移位的解法：<br>
先介绍快速幂：<br>
众所周知，如果我们要求a的n次方，最朴素的想法一定是把它们乘起来，这样的复杂度是O(n),显然太差了。<br>
然后我们想到一种优化，如果我们能求得 2的k次方=n的话，我们只需要将a的平方相乘k次，这样的复杂度是O(log2n)，但是我们很难找到这样的k。<br>
于是我们将这一想法再一次优化，我们只要能找到 2的k1次方+2的k2次方+...=n就好了，这样的复杂度还是O(log2n)<br>
这一想法可以通过数的二进制位运算轻易解决，比如9的二进制是1001，也就是从右往左数第i位，我们的答案就乘上a的2的i次方<br>
于是就有了一下算法</p>
</blockquote>
<pre><code>class Solution {
public:
    
    double qpow(double a, long long b){
        double res = 1;
        while(b){
            if(b&amp;1) res = res*a;
            b &gt;&gt;= 1;
            a *= a;
        }
        return res;
    }
    
  
    double myPow(double x, long long n) {
        if(n == 0) return 1;
        if(n &gt; 0) return qpow(x,n);
        if(n &lt; 0) return 1/qpow(x,-n);
        return 1.0;
    }
};
</code></pre>
<p>另一种不需要移位的方法：</p>
<pre><code>class Solution {
public:
    double myPow(double x, int n) {
        long long N = n;
        if (N &lt; 0) {
            x = 1 / x;
            N = -N;
        }
        double ans = 1;
        double current_product = x;
        for (long long i = N; i ; i /= 2) {
            if ((i % 2) == 1) {
                ans = ans * current_product;
            }
            current_product = current_product * current_product;
        }
        return ans;
    }
};
</code></pre>
<p>复杂度分析<br>
时间复杂度：O(logn). 对每一个 n 的二进制位表示，我们都至多需要累乘 1 次，所以总的时间复杂度为 O(logn) 。<br>
空间复杂的：O(1). 我们只需要用到 2 个变量来保存当前的乘积和最终的结果 x 。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ C++ primer 第十三章 笔记+习题 13.3-13.5]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-san-zhang-bi-ji-xi-ti-133-135</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-san-zhang-bi-ji-xi-ti-133-135">
        </link>
        <updated>2019-10-23T01:00:08.000Z</updated>
        <content type="html"><![CDATA[<p>13.3交换操作<br>
为了<strong>交换两个对象我们需要进行一次拷贝和两次赋值</strong>，但理论上这些内存分配都是不必要的，我们更希望使用swap交换指针，而不是分配对象的新副本<br>
与拷贝控制成员不同，<strong>swap不是必要的</strong>，但是对于分配了资源的类，定义swap可能是一种很重要的优化手段<br>
swap有其内置版本，标准库的std::swap，但是如果一个类的成员有自己类型特定的swap函数，调用std::swap就是错误的了。<br>
所以应该使用swap而不是std::swap，swap函数会自动匹配最优版本，如果不存在类型特定的版本，程序也会自动使用std中的版本<br>
<strong>定义了swap的类通常会使用swap来定义它们的赋值运算符</strong>，称为拷贝并交换技术，这种技术将左侧运算对象和右侧对象的一个副本进行交换<strong>注意此时形参必须是值传递，但是swap依然是引用传递</strong><br>
在上述版本的赋值运算符中，参数并不是一个引用，所以<strong>右侧运算对象是以传值方式传递</strong>给了赋值运算符。因此rhs是右侧运算对象的一个副本<br>
在函数体中，rhs获得了*this原来保存的指针，并将rhs 的指针存入了*this。但结束时析构函数会被执行，rhs会被销毁，delete了rhs现在指向的内存，即左侧对象原来指向的内存</p>
<p>习题13.29<br>
因为在函数内部声明了std名字域的swap，所以调用的是标准库的swap而不是递归调用自身<br>
习题13.30<br>
void swap(HasPtr &amp;lhs, HasPtr &amp;rhs) {<br>
std::swap(lhs.ps, rhs.ps);<br>
std::swap(lhs.i, rhs.i);<br>
cout &lt;&lt; &quot;now we swap!&quot; &lt;&lt; endl;<br>
}<br>
习题13.31</p>
<pre><code>class HasPtr
{
	friend void swap(HasPtr &amp;lhs, HasPtr &amp;rhs);
public:
	HasPtr(const HasPtr &amp;hs) : ps(new string(*hs.ps)), i(hs.i) {};
	~HasPtr() { delete ps; }
	HasPtr(const string &amp;s = string(), int si = 0) :ps(new string(s)), i(si) {}
	HasPtr &amp;operator=(const HasPtr &amp;hp) {
		string *s = new string(*hp.ps);
		delete ps;
		*ps = *s;
		delete s;
		i = hp.i;
		return *this;
	}
	bool operator&lt;(const HasPtr &amp;rhs) const{ return i &lt; rhs.i; };
private:
	string *ps;
	int i;
};

void swap(HasPtr &amp;lhs, HasPtr &amp;rhs) {
	std::swap(lhs.ps, rhs.ps);
	std::swap(lhs.i, rhs.i);
	cout &lt;&lt; &quot;now we swap!&quot; &lt;&lt; endl;
}


int main()
{
	vector&lt;HasPtr&gt; hp;
	for (int i = 5; i &gt; 0; --i)
		hp.push_back(HasPtr(&quot;123&quot;, i));
//	for (auto h : hp)
//		cout &lt;&lt; h.i &lt;&lt; endl;
//	sort(hp.begin(), hp.end());
	swap(hp[0], hp[1]);
}
</code></pre>
<p>这题离奇地报错，似乎是sort内部无法调用自定义的swap<br>
习题13.32<br>
不需要，因为类指针的时候需要对左侧计数进行递增，交换的话两边的计数值应该都是不变的。</p>
<p>13.4拷贝控制示例<br>
拷贝赋值运算符通常执行拷贝构造函数和析构函数中也要完成的工作，这种情况下，公共的工作应该放在private的工具函数中完成。</p>
<p>习题13.33<br>
Folder的话会拷贝副本，同时需要改变f的内容，不能使用const<br>
习题13.34</p>
<pre><code>class Message
{
	friend class Folder; 
	friend void swap(Message &amp;, Message &amp;);
public:
	explicit Message(const string &amp;str = &quot;&quot;) :contents(str) {};
	Message(const Message &amp;m) :contents(m.contents), folders(m.folders) { add_to_Folders(m); };
	Message&amp; operator=(const Message &amp;m);
	~Message() { remove_from_Folders(); };
	void save(Folder&amp;);
	void remove(Folder&amp;);
private:
	string contents;
	set&lt;Folder*&gt; folders;
	void add_to_Folders(const Message&amp;);
	void remove_from_Folders();
};

void Message::save(Folder &amp;f) {
	folders.insert(&amp;f);
	f.addMsg(this);
}
void Message::remove(Folder &amp;f) {
	folders.erase(&amp;f);
	f.remMsg(this);
}

void Message::add_to_Folders(const Message &amp;m) {
	for (auto f : m.folders)
		f-&gt;addMsg(this);
}
void Message::remove_from_Folders() {
	for (auto f : folders)
		f-&gt;remMsg(this);
}

Message&amp; Message::operator=(const Message &amp;m){
	remove_from_Folders();
	contents = m.contents;
	folders = m.folders;
	add_to_Folders(m);
	return *this;

}

void swap(Message &amp;lhs, Message &amp;rhs) {
	using std::swap;
	for (auto f : lhs.folders)
		f-&gt;remMsg(&amp;lhs);
	for (auto f : rhs.folders)
		f-&gt;remMsg(&amp;rhs);
	swap(lhs.folders, rhs.folders);
	swap(lhs.contents, rhs.contents);
	for (auto f : lhs.folders)
		f-&gt;addMsg(&amp;lhs);
	for (auto f : rhs.folders)
		f-&gt;addMsg(&amp;rhs);
}
</code></pre>
<p>习题13.35<br>
会直接拷贝contents和folders，但是却没有将其添加进相应的folders对象里面，所以如果进行删除的话会导致变成空悬指针。<br>
习题13.36</p>
<pre><code>class Folder {
public:
	void addMsg(Message *m) { message.insert(m); }
	void remMsg(Message*) { message.erase(m); };
private:
	set&lt;Message*&gt; message;
};
</code></pre>
<p>习题13.37</p>
<pre><code>void Message::addFolders(Folder &amp;f) {
	folders.insert(&amp;f);
	f.addMsg(this);
}

void Message::remFolders(Folder &amp;f) {
	folders.erase(&amp;f);
	f.remMsg(this);
}
</code></pre>
<p>习题13.38<br>
因为swap后面需要为folders加上lhs，但是赋值运算符中并不需要拷贝左值<br>
当涉及到动态分配内存或指针时,拷贝并交换是一个完成该功能的精简的方式. ，但是在Message类中,并未涉及到动态分配内存和指针,这种方法并不会产生任何益处，同时还会因为很多指针操作让程序变得更复杂难难以实现</p>
<p>13.5动态内存管理类<br>
某些类需要在运行时分配可变大小的内存空间，这种类通常使用标准库容器来保存它们的数据，比如vector。但某些类<strong>需要自己进行内存分配</strong>，这些类一般来说<strong>必须定义自己的拷贝控制成员来管理所分配的内存</strong><br>
在StrVec类中，我们将使用一个allocator来获得原始内存。由于<strong>allocator分配的内存是未构造的</strong>，我们将在需要添加新元素时使用allocator的construct成员在原始内存中创建对象。类似的，当我们需要删除一个元素时，我们将使用destroy成员来销毁元素</p>
<p>用allocator分配内存时，必须记住内存是未构造的，为了使用此原始内存，我们必须调用construct，construct的<strong>第一个参数必须是一个指针</strong>，指向调用allocate所分配的未构造的内存空间，剩余参数确定用哪个构造函数来构造对象<br>
construct会使用后置递增来使得first_free在当前地址构造一个对象后递增指向下一个未构造的元素<br>
<strong>不能传递给deallocate一个空指针</strong></p>
<p>新标准中避免string拷贝的两种机制1.部分标准库类定义了所谓的“移动构造函数”，通常将资源从给定对象“移动”而不是拷贝到正在创建的对象，具体实现细节尚未公开，但可以假定string的移动构造函数进行了指针的拷贝，而不是为字符分配内存空间然后拷贝字符；2.定义在utility头文件中的标准库函数move，当reallocate在新内存中构造string时，它必须调用move来表示希望使用string的移动构造函数，如果漏掉了move调用，将会使用string的拷贝构造函数，其次我们<strong>通常不为move提供一个using声明</strong>，当我们使用move时，<strong>直接调用std:move而不是move</strong></p>
<p>习题13.39</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math 69. x 的平方根 难度：简单]]></title>
        <id>https://lixin-ee.github.io//post/math-69-x-de-ping-fang-gen</id>
        <link href="https://lixin-ee.github.io//post/math-69-x-de-ping-fang-gen">
        </link>
        <updated>2019-10-22T09:04:02.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>实现 int sqrt(int x) 函数。<br>
计算并返回 x 的平方根，其中 x 是非负整数。<br>
由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<p>示例 1:<br>
输入: 4<br>
输出: 2<br>
示例 2:<br>
输入: 8<br>
输出: 2<br>
说明: 8 的平方根是 2.82842...,<br>
     由于返回类型是整数，小数部分将被舍去。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/sqrtx<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>要点：<br>
1.如果确定平方根的范围<br>
这道题还是比较有趣的，因为仅凭一个数字，基本没有办法去推测它的开方会落在哪里，越大的数值和其自身的平方根距离反而越大，所以我一开始使用的暴力解法</p>
<pre><code>class Solution {
public:
    int mySqrt(int x) {
        int i=0;
        while(i&lt;46341&amp;&amp;x&gt;=i*i)
            ++i;
        return i-1;
    }
};
</code></pre>
<p>需要注意的点是<code>i&lt;46341&amp;&amp;x&gt;=i*i</code>判断条件中，范围判断必须先于平方运算，否则会溢出</p>
<p>然后来看一下网友题解吧：</p>
<blockquote>
<p>方法一：二分法<br>
思路分析：使用二分法搜索平方根的思想很简单，就类似于小时候我们看的电视节目中的“猜价格”游戏，高了就往低了猜，低了就往高了猜，范围越来越小。因此，使用二分法猜算术平方根就很自然。</p>
<p>一个数的平方根肯定不会超过它自己，不过直觉还告诉我们，一个数的平方根最多不会超过它的一半，例如 8 的平方根，8 的一半是 4，4^2=16&gt;8，如果这个数越大越是如此，因此我们要计算一下，这个边界是多少。为此，解如下不等式：<br>
(a/2)^2&gt;a<br>
意即：如果一个数的一半的平方大于它自己，那么这个数的取值范围。解以上不等式得 a≥4 或者 a≤0。<br>
于是边界值就是 4，那么对 0、1、2、3 分别计算结果，很容易知道，这 4 个数的平方根依次是 0、1、1、1。</p>
<p>注意：这 4 个特值如果没有考虑到，有可能导致你设置的搜索边界不正确。在使用二分法寻找平方根的时候，要特别注意边界值的选择，以下给出两个参考代码。<br>
参考代码 1：所有的数都放在一起考虑，为了照顾到 0 把左边界设置为 0，为了照顾到 1 把右边界设置为 x // 2 + 1。</p>
</blockquote>
<pre><code>public class Solution {

    public int mySqrt(int x) {
        // 注意：针对特殊测试用例，例如 2147395599
        // 要把搜索的范围设置成长整型
        // 为了照顾到 0 把左边界设置为 0
        long left = 0;
        // # 为了照顾到 1 把右边界设置为 x // 2 + 1
        long right = x / 2 + 1;
        while (left &lt; right) {
            // 注意：这里一定取右中位数，如果取左中位数，代码会进入死循环
            // long mid = left + (right - left + 1) / 2;
            long mid = (left + right + 1) &gt;&gt;&gt; 1;
            long square = mid * mid;
            if (square &gt; x) {
                right = mid - 1;
            } else {
                left = mid;
            }
        }
        // 因为一定存在，因此无需后处理
        return (int) left;
    }

}
</code></pre>
<blockquote>
<p>要注意到：如果中点 mid 声明为 int 类型，针对大整型测试用例通不过，因此变量需要声明为 long 类型，下同。<br>
参考代码 2：事实上，只要单独照顾一下 00 这个特例就可以了。</p>
</blockquote>
<pre><code>public class Solution {

    public int mySqrt(int x) {
        if (x == 0) {
            return 0;
        }
        // 注意：针对特殊测试用例，例如 2147395599
        // 要把搜索的范围设置成长整型
        long left = 1;
        long right = x / 2;
        while (left &lt; right) {
            // 注意：这里一定取右中位数，如果取左中位数，代码会进入死循环
            // long mid = left + (right - left + 1) / 2;
            long mid = (left + right + 1) &gt;&gt;&gt; 1;
            long square = mid * mid;
            if (square &gt; x) {
                right = mid - 1;
            } else {
                left = mid;
            }
        }
        // 因为一定存在，因此无需后处理
        return (int) left;
    }

}
</code></pre>
<blockquote>
<p>注意： 这里二分法的使用是有技巧的（如果你没有意识到，这里很可能是个“坑”），下面我就上面注释中提到的：<br>
注意：这里一定取右中位数，如果取左中位数，代码可能会进入死循环。<br>
做一些解释。当 x = 9 的时候，如果取中点为左中位数，你看到死循环发生在 left = 3， right = 4 的时候，此时区间只有 2 个元素。这是为什么呢？<br>
此时索引区间 [3, 4] 的中位数为左中位数，即 mid = 3 ，此时 square = 9 &lt; 9 不成立，进入 left = mid 这个分支，你发现问题了吗，区间不发生收缩，即下一轮循环的索引区间还是 [3, 4]，此时中位数还取左中位数，即 mid = 3 ，square = 9 &lt; 9 不成立，又进入 left = mid 这个分支，死循环就是这样产生的。<br>
接着，请你把 mid = left + (right - left) // 2 改成 mid = left + (right - left + 1) // 2 ，即选择右中位数，再观察一下控制台输出，就知道此时为什么要选右中位数了。<br>
这个二分法模板我用了很久，感觉非常好用。于是我专门把这个二分法模板好用的地方、使用它的技巧和注意事项整理在了「力扣 」第 35 题：搜索插入位置的题解《特别好用的二分查找法模板（Python 代码、Java 代码）》，希望能对大家有所帮助。</p>
</blockquote>
<p>复杂度分析：<br>
时间复杂度：O(logN)，二分法的时间复杂度是对数级别的。<br>
空间复杂度：O(1)，使用了常数个数的辅助空间用于存储和比较。<br>
总结： 使用二分查找法搜索，注意特值对搜索边界的影响。</p>
<blockquote>
<p>以下这部分内容是根据与用户 @lukas 在本题解下的讨论而添加的。<br>
在这里补充一下，如果你实在不太想分析 a 的平方根可能的上界，之前说了，它肯定不会超过 a 自己，即使你把上界写成一个很大的数，例如 999999，这个数必须得是力扣的测试用例都达不到的数，在二分查找的过程中，不符合要求的数每次会被很快砍掉一半。<br>
参考代码 3：干脆我不讨论 a 的边界，让二分法去排除不符合的区间吧，对数级别的时间复杂度对性能不会有很大影响。</p>
</blockquote>
<pre><code>public class Solution {

    public int mySqrt(int x) {
        long left = 0;
        long right = Integer.MAX_VALUE;
        while (left &lt; right) {
            // 这种取中位数的方法又快又好，是我刚学会的，原因在下面这篇文章的评论区
            // https://www.liwei.party/2019/06/17/leetcode-solution-new/search-insert-position/
            // 注意：这里得用无符号右移
            long mid = (left + right + 1) &gt;&gt;&gt; 1;
            long square = mid * mid;
            if (square &gt; x) {
                right = mid - 1;
            } else {
                left = mid;
            }
        }
        return (int) left;
    }
}

</code></pre>
<blockquote>
<p>方法二：牛顿迭代法<br>
下面这种方法可以很有效地求出根号 a 的近似值：首先随便猜一个近似值 x，然后不断令 x 等于 x 和 a/x 的平均数，迭代个六七次后 x 的值就已经相当精确了。</p>
<p>例如，我想求根号 2 等于多少。假如我猜测的结果为 4，虽然错的离谱，但你可以看到使用牛顿迭代法后这个值很快就趋近于根号 2 了：<br>
( 4 + 2/ 4 ) / 2 = 2.25<br>
( 2.25 + 2/ 2.25 ) / 2 = 1.56944..<br>
( 1.56944..+ 2/1.56944..) / 2 = 1.42189..<br>
( 1.42189..+ 2/1.42189..) / 2 = 1.41423..<br>
….<br>
<img src="https://lixin-ee.github.io//post-images/1571745994223.png" alt=""><br>
这种算法的原理很简单，我们仅仅是不断用 (x, f(x))(x,f(x)) 的切线来逼近方程 x^2-a=0 的根。根号 a 实际上就是 x^2-a=0 的一个正实根，这个函数的导数是 2x。也就是说，函数上任一点 (x,f(x)) 处的切线斜率是 2x。那么，x-f(x)/(2x) 就是一个比 x 更接近的近似值。代入 f(x)=x^2-a得到 x-(x^2-a)/(2x)，也就是 (x+a/x)/2。<br>
同样的方法可以用在其它的近似值计算中。Quake III 的源码中有一段非常牛B的开方取倒函数。<br>
知道方程实现就非常简单了。<br>
我用了递归</p>
</blockquote>
<pre><code>class Solution {
    int s;
    
 public int mySqrt(int x) {
     s=x;
     if(x==0) return 0;
    return ((int)(sqrts(x)));
  }
    
    public double sqrts(double x){
      double res = (x + s / x) / 2;
    if (res == x) {
      return x;
    } else {
      return sqrts(res);
    }
    } 
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math 29. 两数相除 难度：中等]]></title>
        <id>https://lixin-ee.github.io//post/math-29-liang-shu-xiang-chu-nan-du-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/math-29-liang-shu-xiang-chu-nan-du-zhong-deng">
        </link>
        <updated>2019-10-21T12:13:15.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。<br>
返回被除数 dividend 除以除数 divisor 得到的商。</p>
<p>示例 1:<br>
输入: dividend = 10, divisor = 3<br>
输出: 3<br>
示例 2:<br>
输入: dividend = 7, divisor = -3<br>
输出: -2<br>
说明:</p>
<p>被除数和除数均为 32 位有符号整数。<br>
除数不为 0。<br>
假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。本题中，如果除法结果溢出，则返回 2^31 − 1。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/divide-two-integers<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>难点和要点：<br>
1.如何实现除法并且不超时<br>
2.溢出的处理，主要在于-2^31除以-1的问题<br>
我的思路<br>
1.暴力法 或者 模仿传统的竖式除法，但是后者我没有想到应该如何进行从左往右提取数字（不能使用除法）<br>
2.关于溢出的处理，我的想法是设置int标志位，将被除数和除数都化为负数，此时只需要对-2^31除以-1进行特殊判断，然后最后根据int标志位来对结果取负。</p>
<p>暴力法代码：</p>
<pre><code>class Solution {
public:
    int divide(int dividend, int divisor) {
        int flag=0;
        if(dividend&gt;0){
            dividend=-dividend;
            ++flag;
        }
        if(divisor&gt;0){ divisor=-divisor; ++flag; }
        int res=0;
        while(dividend&lt;=divisor){
            dividend-=divisor;
            if(res==INT_MAX){
                if(flag==0)
                    return INT_MAX;
                else
                    return INT_MIN;
            }
            ++res;
        }
        if(flag==1)
            return -res;
        return res;
    }
};
</code></pre>
<p>最后暴力法还是白给了，2^32除以1超时了</p>
<p>所以直接看下网友题解：<br>
<img src="https://lixin-ee.github.io//post-images/1571663112931.png" alt=""><br>
代码：</p>
<pre><code>def divide(self, dividend: int, divisor: int) -&gt; int:
    sign = (dividend &gt; 0) ^ (divisor &gt; 0)
    dividend = abs(dividend)
    divisor = abs(divisor)
    count = 0
    #把除数不断左移，直到它大于被除数
    while dividend &gt;= divisor:
        count += 1
        divisor &lt;&lt;= 1
    result = 0
    while count &gt; 0:
        count -= 1
        divisor &gt;&gt;= 1
        if divisor &lt;= dividend:
            result += 1 &lt;&lt; count #这里的移位运算是把二进制（第count+1位上的1）转换为十进制
            dividend -= divisor
    if sign: result = -result
    return result if -(1&lt;&lt;31) &lt;= result &lt;= (1&lt;&lt;31)-1 else (1&lt;&lt;31)-1 
</code></pre>
<blockquote>
<p>题解二：<br>
直接举个例子如果被除数 15，除数 3，用我们上面的方法要遍历 5 次。<br>
接下来，我们使用不断 增倍除数<br>
比如：<br>
被除数 除数<br>
15 3<br>
12 6<br>
6 12<br>
发现除数 大于 被除数大，再重现开始<br>
6 3<br>
...<br>
3 3<br>
虽然这个例子遍历次数相等，对于较大的数，可以减少时间复杂度。</p>
</blockquote>
<pre><code>class Solution {
    public int divide(int dividend, int divisor) {
        int sign = (dividend ^ divisor) &gt;&gt; 31;
        long lDividend = Math.abs((long) dividend);
        long lDivisor = Math.abs((long) divisor);
        long res = 0;
        while (lDividend &gt;= lDivisor){
            long tmp = lDivisor;
            long i = 1;
            while (lDividend &gt;= tmp){
                lDividend -= tmp;
                res += i;
                i &lt;&lt;= 1;
                tmp &lt;&lt;= 1;
            }
        }
        if (sign == -1) res *= -1;
        if (res &lt; Integer.MIN_VALUE) return Integer.MIN_VALUE;
        else if (res &gt; Integer.MAX_VALUE) return Integer.MAX_VALUE;
        return (int)res;
        
    }
}
</code></pre>
<p>注意本题被系统归纳为二分查找类别，其实题解二算是一个二分查找法的逆向思维，二分查找法是从大值不断划分到1，逆向则是不断递增到大值。</p>
<pre><code>class Solution {
    public int divide(int dividend, int divisor) {
        /** 除数为零就返回-1 按照测试样例的要求写的*/
        if (divisor==0)
            return -1;
        if (dividend==0)
            return 0;
        /** -2147483648, -1 这个测试样例的确没想到，结果翻车了*/
        if (dividend==Integer.MIN_VALUE &amp;&amp; divisor==-1)
            return Integer.MAX_VALUE;
        /** 符号位的处理参考了大佬的异或处理方法*/
        boolean negetive= (dividend^ divisor)&lt;0;
        /** div_count 是当前divisor_tmp相对于divisor的倍数 */
        int res=0, div_count=1;
        /** 因为值溢出之后边界问题处理太繁琐了，直接将数值转为long省去麻烦 */
        long dividend_tmp= Math.abs((long)dividend);
        long divisor_tmp= Math.abs((long)divisor);
        
        /** 按标准的二分查找代码模板写的 */
        while (dividend_tmp&gt;= divisor_tmp) {
            dividend_tmp-= divisor_tmp;
            res+= div_count;
            
            if (dividend_tmp&lt; Math.abs(divisor))
                break;
            
            /** divisor_tmp无法倍增时，就将其初始化为divisor绝对值，重新开始下一轮倍增*/
            if (dividend_tmp- divisor_tmp&lt; divisor_tmp) {
                divisor_tmp= Math.abs(divisor);
                div_count=1;
                continue;
            } 
            
            /** 不断倍增divisor_tmp直到和dividend_tmp一样大*/
            divisor_tmp+= divisor_tmp;
            div_count+= div_count;
        }
        return negetive? 0-res: res;
    }
}
</code></pre>
<p>然后上述题解都是受边界问题影响，用long之类的其实是不合理的，我的改用负数计算反而还不错，题解中也有类似的</p>
<pre><code>class Solution {
    public int divide(int dividend, int divisor) {
        boolean sign = (dividend &gt; 0) ^ (divisor &gt; 0);
        int result = 0;
        if(dividend&gt;0) {
            dividend = -dividend;
        }
        if(divisor&gt;0) divisor = -divisor;
        while(dividend &lt;= divisor) {
            int temp_result = -1;
            int temp_divisor = divisor;
            while(dividend &lt;= (temp_divisor &lt;&lt; 1)) {
                if(temp_divisor &lt;= (Integer.MIN_VALUE &gt;&gt; 1))break;
                temp_result = temp_result &lt;&lt; 1;
                temp_divisor = temp_divisor &lt;&lt; 1;
            }
            dividend = dividend - temp_divisor;
            result += temp_result;
        }
        if(!sign) {
            if(result &lt;= Integer.MIN_VALUE) return Integer.MAX_VALUE;
            result = - result;
        }
        return result;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第十三章 笔记+习题 13.1-13.2]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-san-zhang-bi-ji-xi-ti-131-132</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-san-zhang-bi-ji-xi-ti-131-132">
        </link>
        <updated>2019-10-20T11:27:11.000Z</updated>
        <content type="html"><![CDATA[<p>13拷贝控制<br>
一个类包含几个基本操作：拷贝、移动、赋值和销毁，类定义了五个特殊的成员函数来控制这些操作：拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符和析构函数。其中构造函数定义了当用同类型的另一个对象初始化本对象时做什么，赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么。析构函数定义了当此类型对象销毁时做什么。我们称这些操作为拷贝控制操作<br>
如果没有主动定义所有这些拷贝控制成员，编译器会自动为它定义缺失的操作</p>
<p>13.1拷贝、赋值与销毁<br>
13.1.1拷贝构造函数<br>
如果一个构造函数的第一个参数是自身类类型的引用，且<strong>任何额外参数都有默认值</strong>，则此构造函数是拷贝构造函数<br>
拷贝构造函数的<strong>第一个参数必须是一个引用类型</strong>，并且此参数几乎总是一个<strong>const的引用</strong><br>
拷贝构造函数在几种情况下都会被隐式地使用，因此拷贝构造函数通常<strong>不是explicit的</strong>（形参不可进行类型转换）<br>
一般情况下，合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中。对于某些类来说，合成拷贝构造函数用来<strong>阻止拷贝</strong>该类类型的对象<br>
每个成员的类型决定了它如何拷贝：类类型用自身的拷贝构造函数，内置类型的成员直接拷贝，<strong>数组无法直接拷贝</strong>，需要通过合成的拷贝构造函数逐个元素地拷贝<br>
当使用<strong>直接初始化</strong>时，我们实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数<strong>最匹配的构造函数</strong>。<br>
而当我们使用<strong>拷贝初始化</strong>时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换<br>
<strong>拷贝初始化通常使用拷贝构造函数来完成</strong>，如果一个类有一个移动构造函数，则拷贝初始化有时会使用移动构造函数而非拷贝构造函数来完成<br>
部分类类型还会对它们所分配的对象使用拷贝初始化。比如标准库容器的初始化会调用<strong>insert或push成员</strong>，此时会使用<strong>拷贝初始化</strong>，与之相对的是<strong>emplace会使用直接初始化</strong><br>
在函数调用过程中，具有<strong>非引用类型的参数要进行拷贝初始化</strong><br>
拷贝构造函数被用来初始化非引用类类型参数，这一特性<strong>解释了为什么拷贝构造函数自己的参数必须是引用类型</strong>，如果参数不是引用类型，则调用永远也不会成功：因为如果参数不是引用类型的话，为了调用拷贝构造函数，我们必须拷贝它的实参，为了拷贝实参又需要调用拷贝构造函数，导致<strong>进入无限调用自身的死循环</strong><br>
当传递一个实参或从函数返回一个值时，我们不能隐式使用一个explicit构造函数（比如shared_ptr）<br>
在拷贝初始化过程中，编译器可以跳过拷贝/移动构造函数，直接创建对象</p>
<p>习题13.1<br>
如果一个构造函数的第一个参数时自身类类型的引用，且任何额外的参数都有默认值，则为拷贝构造函数。拷贝构造函数用于拷贝初始化。<br>
习题13.2<br>
拷贝构造函数的第一个参数不是引用类型，如果参数不是引用类型，则调用永远也不会成功：因为如果参数不是引用类型的话，为了调用拷贝构造函数，我们必须拷贝它的实参，为了拷贝实参又需要调用拷贝构造函数，导致<strong>进入无限调用自身的死循环</strong><br>
习题13.3<br>
StrBlob 需要拷贝 data这个智能指针，将会使引用计数+1，<br>
StrBlobPtr 需要拷贝1.wptr 弱指针复制不影响计数器 2.curr<br>
习题13.4<br>
1 point形参的拷贝<br>
2 local的初始化 和heap的初始化都用了拷贝构造函数<br>
3 point类型数组的花括号列表初始化<br>
4.返回类型的拷贝<br>
要点：heap的初始化虽然是直接初始化，当使用<strong>直接初始化</strong>时，我们实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数<strong>最匹配的构造函数</strong>。<br>
习题13.5<br>
<code>HasPtr(const HasPtr &amp;hp) :ps(new string(*hp.ps))，i(hp.i){}</code></p>
<p>13.1.2拷贝赋值运算符<br>
与拷贝构造函数一样，如果拷贝赋值运算符<strong>未定义</strong>的话，编译器会为该类<strong>生成一个合成拷贝赋值运算符</strong><br>
<strong>重载运算符</strong>本质上是一个<strong>函数</strong>，其名字由operator关键字后接表示要定义的运算符的符号组成，比如赋值运算符就是一个名为operator=的函数<br>
重载运算符的参数表示运算符的运算对象，某些运算符包括赋值运算符都<strong>必须定义为成员函数</strong>，对于一个二元运算符，其<strong>左侧运算对象绑定到隐式的this参数</strong>，右侧运算对象作为显式参数传递<br>
非成员函数和成员函数的区别：成员函数有一个隐式的this参数可供调用。<br>
拷贝赋值运算符接受一个与其所在类<strong>相同类型</strong>的参数<br>
赋值运算符通常<strong>返回一个指向其左侧运算对象的引用</strong></p>
<p>习题13.6<br>
拷贝复制运算符，其实就是一个名为 operator= 的重载函数(operator后加表示要定义的运算符的符号)，重载运算符，有返回类型和参数，返回类型通常是左侧运算符的引用<br>
合成的拷贝赋值运算符将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员（对于数组类型的成员，则逐个赋值数组元素），如果一个类未定义自己的拷贝赋值运算符或者希望进制该类型对象的赋值，就会生成一个合成拷贝赋值运算符。<br>
习题13.7<br>
StrBlob 需要拷贝 data这个智能指针，原指针值引用计数-1 新指针值引用计数+1，<br>
StrBlobPtr 需要拷贝1.wptr 弱指针复制不影响计数器 2.curr<br>
习题13.8<br>
<code>HasPtr &amp;operator=(const HasPtr &amp;hp){ 		string *s = new string(*hp.ps); 		delete ps; 		*ps = *s; 		delete s; 		i = hp.i; 		return *this; 	}</code><br>
记得要delete动态内存ps 和s</p>
<p>13.1.3析构函数<br>
析构函数释放对象使用的资源，并销毁对象的<strong>非static对象</strong><br>
析构函数是类的一个成员函数，名字由<strong>波浪号接类名</strong>构成，它<strong>没有返回值，也不接受参数</strong><br>
由于析构函数不接受参数，所以它<strong>不能被重载</strong>，一个特定的类只有唯一一个析构函数<br>
析构函数包含一个函数体和一个析构部分，<strong>首先执行函数体</strong>，然后销毁成员，成员<strong>按初始化顺序的逆序销毁</strong><br>
析构函数的<strong>函数体</strong>主要用于执行类设计者的<strong>收尾工作</strong><br>
<strong>析构部分是隐式的</strong>，与函数体无关，在执行析构函数体后再进行销毁操作。成员销毁时发生什么完全依赖于成员的类型，销毁类类型的成员需要执行成员自己的析构函数，<strong>内置类型没有析构函数</strong>，因此销毁内置类型成员什么也不需要<br>
<strong>隐式销毁一个内置指针类型的成员不会delete它所指向的对象</strong><br>
<strong>与普通指针不同，智能指针是类类型，所以具有析构函数</strong></p>
<p>当指向一个对象的<strong>引用或指针离开作用域，析构函数不会执行</strong><br>
编译器会自动定义一个合成析构函数</p>
<p>习题13.9<br>
析构函数是类的一个成员函数，名字由波浪号接类名构成，它没有返回值，也不接受参数。合成析构函数用来析构类的非static对象或者阻止该类型的对象被销毁，当一个类未定义自己的析构函数时编译器就会为它定义一个合成析构函数<br>
习题13.10<br>
StrBlob 需要将data这个智能指针的原指针值引用计数-1 ，如果引用数为0，调用智能指针类的析构函数<br>
StrBlobPtr 需要1.调用wptr的析构函数 弱指针删除不影响计数器 2.销毁内置类型对象curr<br>
习题13.11<br>
<code>~HasPtr() { delete ps; }</code><br>
习题13.12<br>
三次 item1，item2和accum<br>
知识点：当指向一个对象的引用或者指针离开作用域，析构函数并不会执行<br>
习题13.13</p>
<pre><code>struct X {
public:
	X(int i):val(i){ cout &lt;&lt; &quot;fisrt&quot; &lt;&lt; endl; }
	X(const X&amp; xi) :val(xi.val) { cout &lt;&lt; &quot;second&quot; &lt;&lt; endl; }
	X &amp;operator=(const X&amp; xi) { val = xi.val; cout &lt;&lt; &quot;third&quot; &lt;&lt; endl;};
	~X()
	{
		cout&lt;&lt; val &lt;&lt; &quot; yao mo de le!&quot; &lt;&lt; endl;
	}
	int val;
};

void print_cp(X x) {
	cout &lt;&lt; x.val &lt;&lt; endl;
}

void print_ref(X&amp; x) {
	cout &lt;&lt; x.val &lt;&lt; endl;
}

void test() {
	X x(10);
	cout &lt;&lt; &quot;------------------------&quot; &lt;&lt; endl;
	print_cp(x);
	cout &lt;&lt; &quot;------------------------&quot; &lt;&lt; endl;
	print_ref(x);
	cout &lt;&lt; &quot;------------------------&quot; &lt;&lt; endl;
	X *xp = new X(5);
	cout &lt;&lt; &quot;------------------------&quot; &lt;&lt; endl;
	delete xp;
	cout &lt;&lt; &quot;------------------------&quot; &lt;&lt; endl;
	vector&lt;X&gt; xv1(1,x);
	cout &lt;&lt; &quot;------------------------&quot; &lt;&lt; endl;
	vector&lt;X&gt; xv2{ x };
	cout &lt;&lt; &quot;------------------------&quot; &lt;&lt; endl;
}

int main()
{
	test();
}
</code></pre>
<p>输出结果为<br>
<img src="https://lixin-ee.github.io//post-images/1571578562038.png" alt=""><br>
其中比较有意思的结果为：<br>
1.当使用<strong>直接初始化</strong>时，我们实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数<strong>最匹配的构造函数</strong>。<br>
所以new表达式用的是默认构造函数而不是拷贝构造函数、然后vector的都是使用拷贝构造函数<br>
2.<br>
vector使用花括号里列表初始化时，还需要进行一次临时对象的拷贝构造函数，再对元素进行拷贝构造函数，所以一共使用了两次，然后初始化完了临时对象立即被销毁。<br>
注意 拷贝构造函数的参数必须是const 引用</p>
<p>13.1.4三/五法则<br>
在三个基本操作可以控制类的拷贝操作：拷贝构造函数、拷贝赋值运算符和析构函数<br>
<strong>如果这个类需要一个析构函数，我们几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符</strong><br>
例子：如果一个类需要在构造函数中分配动态内存，但自动合成的析构函数无法delete一个指针数据成员，所以需要定义一个析构函数来释放构造函数分配的内存。此时如果使用合成的拷贝构造函数和拷贝赋值运算符，这些函数简单拷贝指针成员，这意味着该类可能有多个对象指向相同的内存。<br>
所以如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝赋值运算符和拷贝构造函数。同时需要拷贝构造函数就几乎可以肯定其需要拷贝赋值运算符，但例外地，<strong>需要拷贝构造函数或需要拷贝赋值运算符时，却不一定需要析构函数</strong></p>
<p>习题13.14<br>
将会输出相同的序号，因为合成拷贝构造函数只会复制mysn、<br>
习题13.15<br>
会，因为定义了拷贝构造函数后将不会使用合成的拷贝构造函数，但是由于函数的参数是非引用类型，所以新的输出结果中就会输出与拷贝构造也不同的序号（两次变更，连a都不同了）<br>
注意：不要忘记形参拷贝的拷贝构造<br>
习题13.16<br>
输出abc的唯一序号<br>
习题13.17</p>
<pre><code>int main()
{
	numbered a(10);
	numbered b = a, c = b;
	f(a), f(b), f(c);
}
</code></pre>
<ol>
<li></li>
</ol>
<pre><code>class numbered {
public:
	numbered(int i):mysn(i){}
	int mysn;
};

void f(numbered s) { cout &lt;&lt; s.mysn &lt;&lt; endl; }
</code></pre>
<p>输出 10 10 10<br>
2.</p>
<pre><code>class numbered {
public:
	numbered(int i):mysn(i){}
	numbered(const numbered &amp;n) :mysn(n.mysn) { ++mysn;}
	int mysn;
};

void f(numbered s) { cout &lt;&lt; s.mysn &lt;&lt; endl; }
</code></pre>
<p>输出11 12 13<br>
3.</p>
<pre><code>class numbered {
public:
	numbered(int i):mysn(i){}
	numbered(const numbered &amp;n) :mysn(n.mysn) { ++mysn;}
	int mysn;
};

void f(numbered &amp;s) { cout &lt;&lt; s.mysn &lt;&lt; endl; }
</code></pre>
<p>输出 10 11 12<br>
注意：不要忘记形参拷贝的拷贝构造</p>
<p>13.1.5使用=default<br>
我们可以通过将拷贝控制成员<strong>定义为=default来显式地要求编译器生成合成的版本</strong><br>
当我们使用=default时，合成的成员函数会<strong>隐式地声明为内联函数</strong>，如果不希望其定义为内联，则应该只在成员的<strong>类外定义使用=default</strong></p>
<p>我们只能对具有合成版本的成员函数使用=default（<strong>即默认构造函数或拷贝控制成员</strong>）</p>
<p>13.1.6阻止拷贝<br>
（大多数类还是应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式地还是显式地）<br>
对于<strong>某些类来说拷贝构造和拷贝赋值是不合理的，比如iostream不应该拷贝</strong>，以避免多个对象写入或读取相同的IO缓冲<br>
在新标准下，我们可以通过将拷贝构造函数和拷贝赋值运算符<strong>定义为删除的函数 来阻止拷贝</strong><br>
删除的函数：虽然声明了它，但是<strong>不能以任何的方式使用它</strong>，在函数的参数列表后面加上=delete来指出我们希望将其定义为删除的<br>
与=default不同，<strong>=delete必须出现在函数第一次声明的时候</strong>，另外我们可以<strong>对任何函数指定=delete</strong>，但=default只能用于合成的默认构造函数或拷贝控制成员<br>
但注意，<strong>析构函数可以使用=delete，但不应该使用，否则就无法销毁此类型的对象了。</strong><br>
对于一个删除了析构函数的类型（或者一个类有某个成员的类型删除了析构函数），编译器将<strong>不允许定义</strong>该类型的变量或临时对象<br>
对于删除了析构函数的类型，我们不能定义变量或成员，但可以<strong>动态分配这种类型的对象，但同时也不能释放这些对象</strong></p>
<p>这些规则的含义是，<strong>如果类有不能默认构造、拷贝、复制或销毁的数据成员，则对应的成员函数将被定义为删除的</strong></p>
<p>本质上，当不可能拷贝、赋值或销毁类的成员时，类的合成拷贝控制成员就被定义删除的<br>
在新标准发布前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为private来阻止拷贝的<br>
声明但不定义一个成员函数是合法的，通过声明但不定义的private的拷贝构造函数，我们可以预先阻止任何拷贝该类型的企图，因为任何拷贝操作都会在编译阶段标记为错误的<br>
但在新标准下，应该使用=delete而不是声明为private</p>
<p>习题13.18</p>
<pre><code>class Employee {
public:
	Employee() { num = ++s_num; };
	Employee(string n) :name(n),num(++s_num) {}
	string name;
	int num;
	static int s_num;
};

int Employee::s_num = 0;
</code></pre>
<p>类的static成员一般都得在类外定义，并且需要加上类名作用域符号</p>
<p>习题3.19<br>
不需要拷贝构造函数，因为我们希望保证雇员的对象是唯一的，不应该出现多个证号相同的对象</p>
<pre><code>class Employee {
public:
	Employee() { num = ++s_num; };
	Employee(string n) :name(n),num(++s_num) {}
	Employee(const Employee &amp;) = delete;
	Employee&amp; operator=(const Employee &amp;) = delete;
	string name;
	int num;
	static int s_num;
};
</code></pre>
<p>注意，声明为delete或者default是属于一个声明，不需要形参名</p>
<p>习题13.20<br>
只会使用默认合成的拷贝构造函数、拷贝赋值运算符和析构函数<br>
习题13.21<br>
不需要，因为使用了智能指针类和内置类型，这两者都有自己的拷贝控制成员或者位拷贝，不需要额外的操作了。</p>
<p>13.2拷贝控制和资源管理<br>
<strong>管理类外资源的类</strong>必须定义<strong>拷贝控制成员</strong>，所以需要通过析构函数来释放对象所分配的资源（则也需要拷贝构造函数和拷贝赋值运算符）<br>
为了定义这种类，可以定义其拷贝操作，<strong>使类的行为看起来像一个值或者像一个指针</strong>。1.当类的行为<strong>像一个值</strong>时，<strong>拷贝副本和原对象是完全独立的</strong>，改变副本不会对原对象有任何影响，反之亦然。2.当指针的行为<strong>像一个指针</strong>时，则<strong>需要共享状态</strong>，副本和原对象使用相同的底层数据，改变副本也会改变原对象，反之亦然</p>
<p>习题13.22<br>
突然发现就是之前的代码</p>
<pre><code>class HasPtr
{
public:
	HasPtr(const HasPtr &amp;hs) : ps(new string(*hs.ps)), i(hs.i) {};
	~HasPtr() { delete ps; }
	HasPtr(const string &amp;s=string()):ps(new string(s)),i(0){}
	HasPtr &amp;operator=(const HasPtr &amp;hp) {
		string *s = new string(*hp.ps);
		delete ps;
		*ps = *s;
		delete s;
		i = hp.i;
		return *this;
	}
private:
	string *ps;
	int i;
};
</code></pre>
<p>13.2.1行为像一个值的类<br>
<strong>赋值运算符通常组合了析构函数和构造函数的操作</strong>。类似析构函数，赋值操作会<strong>销毁左侧运算对象的资源</strong>。类似拷贝构造函数，赋值操作会从右侧运算对象拷贝数据。<br>
拷贝赋值操作必须保证以正确的顺序运行，<strong>即使将一个对象赋予它自身，也能保证正确</strong>。所以必须保证赋值运算符是异常下安全的，即使异常发生时也能将左侧运算对象置于一个有意义的状态：！！所以<strong>在销毁左侧运算对象之前先拷贝右侧运算对象</strong></p>
<p>习题13.23<br>
没有差异hhhh，很神奇地我先拷贝了	<code>string *s = new string(*hp.ps);</code>然后再执行了<code>delete ps;</code>，符合在销毁左侧运算对象之前先拷贝右侧运算对象<br>
习题13.24<br>
未定义析构函数：ps属于动态内存指针，没有显式delete的话就会导致内存泄漏<br>
未定义拷贝构造函数：默认拷贝构造函数会复制指针值，容易造成空悬指针的现象<br>
习题13.25<br>
拷贝操作需要重新定义一个shared_ptr，而不是拷贝原来的shared_ptr，然后因为使用了智能指针类，它有自己的析构函数，所以不需要定义析构函数<br>
习题13.26</p>
<pre><code>class StrBlob {
	friend class StrBlobPtr;
public:

	StrBlob() :data(make_shared&lt;vector&lt;string&gt;&gt;()) {};
	StrBlob(initializer_list&lt;string&gt; i1) :data(make_shared&lt;vector&lt;string&gt;&gt;(i1)) {};
	StrBlob(const StrBlob &amp;sb):data(make_shared&lt;vector&lt;string&gt;&gt;(*sb.data)) {};
	StrBlob&amp; operator=(const StrBlob &amp;sb) {
		data = make_shared&lt;vector&lt;string&gt;&gt;(*sb.data);
	}
private:
	shared_ptr&lt;vector&lt;string&gt;&gt; data;
};
</code></pre>
<p>暂时只发现了这种比较暴力的share_ptr复制方法，不知道有没有更方便的一点的库函数复制方法。</p>
<p>13.2.2定义行为像指针的类<br>
我们需要为行为像指针的类定义拷贝构造函数和拷贝赋值运算符，来<strong>拷贝指针成员本身而不是它指向的对象</strong><br>
令一个类展现类似指针的行为的最好方法是<strong>使用shared_ptr来管理类中的资源</strong></p>
<p>需要<strong>将计数器保存在动态内存中</strong>，1.当创建一个对象时，我们也分配一个新的计数器。2.当拷贝或赋值对象时，我们拷贝指向计数器的指针，使得副本和原对象指向相同的计数器<br>
析构函数不能无条件地delete数据成员，因为可能还有其他对象指向这块内存，<strong>析构函数应该先递减引用计数</strong>，如果计数器变为0，则析构函数释放相应的数据成员指向的内存（先递减再检测）<br>
拷贝赋值运算符需要<strong>递增右侧</strong>运算对象的引用计数（拷贝构造函数的工作），<strong>递减左侧</strong>运算对象的引用计数，在必要时释放使用的内存（析构函数的工作）</p>
<p>习题13.27</p>
<pre><code>class HasPtr {
public:
	HasPtr(const string &amp;s=string()):ps(new string(s)),i(0),use(new size_t(1)){}
	HasPtr(const HasPtr &amp;p) :ps(p.ps), i(p.i), use(p.use) { ++*use; }
	HasPtr&amp; operator=(const HasPtr&amp;);
	~HasPtr();
private:
	string *ps;
	int i;
	size_t *use;
};

HasPtr::~HasPtr() {
	if (--*use == 0) {
		delete ps;
		delete use;
	}
}

HasPtr&amp; HasPtr::operator=(const HasPtr &amp;rhs) {
	++*rhs.use;   //递增右侧计数
	if (--*use == 0) {   //递减左侧计数（思考此处如何保证自我复制的正确）
		delete ps;
		delete use;
	}
	ps = rhs.ps;
	i = rhs.i;
	use = rhs.use;
	return *this;
}
</code></pre>
<p>编写拷贝赋值运算符的时候应该时刻思考此处如何保证自我复制的正确<br>
习题13.28</p>
<pre><code>class TreeNode {
public:
	TreeNode(const string &amp;s=string()) : value(s), count(new int(1)), left(nullptr), right(nullptr) { }
	TreeNode(const TreeNode &amp;rhs) : value(rhs.value), count(rhs.count), left(rhs.left), right(rhs.right) { ++*count; }
	TreeNode&amp; operator=(const TreeNode &amp;rhs);
	~TreeNode() {
		if (--*count == 0) {
			delete left;
			delete right;
			delete count;
		}
	}

private:
	std::string value;
	int         *count;
	TreeNode    *left;
	TreeNode    *right;
};

TreeNode&amp; TreeNode::operator=(const TreeNode &amp;rhs)
{
	++*rhs.count;
	if (--*count == 0) {
		delete left;
		delete right;
		delete count;
	}
	value = rhs.value;
	left = rhs.left;
	right = rhs.right;
	count = rhs.count;
	return *this;
}

class BinStrTree {
public:
	BinStrTree() : root(new TreeNode()) { }
	BinStrTree(const BinStrTree &amp;bst) : root(new TreeNode(*bst.root)) { }
	BinStrTree&amp; operator=(const BinStrTree &amp;bst);
	~BinStrTree() { delete root; }

private:
	TreeNode *root;
};

BinStrTree&amp; BinStrTree::operator=(const BinStrTree &amp;bst)
{
	TreeNode *new_root = new TreeNode(*bst.root);
	delete root;
	root = new_root;
	return *this;
}
</code></pre>
<p>注意!!!题目有错，count应该为int * 否则复制起来没意义的<br>
然后注意树的根节点应该用像值一样的类，因为树的根节点不应该被多个对象共享</p>
<p>习题感悟<br>
习题13.5<code>HasPtr(const HasPtr &amp;hp) :ps(new string(*hp.ps))，i(hp.i){}</code><br>
习题13.8<br>
<code>HasPtr &amp;operator=(const HasPtr &amp;hp){ 		string *s = new string(*hp.ps); 		delete ps; 		*ps = *s; 		delete s; 		i = hp.i; 		return *this; 	}</code>记得要delete动态内存ps 和s<br>
习题13.11<br>
<code>~HasPtr() { delete ps; }</code><br>
当指向一个对象的引用或者指针离开作用域，析构函数并不会执行<br>
当使用<strong>直接初始化</strong>时，我们实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数<strong>最匹配的构造函数</strong>。<br>
注意 拷贝构造函数的参数必须是const 引用<br>
不要忘记形参拷贝和花括号初始化的拷贝构造<br>
vector使用花括号里列表初始化时，还需要进行一次临时对象的拷贝构造函数，再对元素进行拷贝构造函数，所以一共使用了两次，然后初始化完了临时对象立即被销毁。<br>
类的static成员一般都得在类外定义，并且需要加上类名作用域符号<br>
声明为delete或者default是属于一个声明，不需要形参名<br>
即使将一个对象赋予它自身，也能保证正确，所以<strong>在销毁左侧运算对象之前先拷贝右侧运算对象</strong><br>
编写拷贝赋值运算符的时候应该时刻思考此处如何保证自我复制的正确</p>
]]></content>
    </entry>
</feed>