<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-10-05T03:06:14.039Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[字符串 242. 有效的字母异位词]]></title>
        <id>https://lixin-ee.github.io//post/zi-fu-chuan-242-you-xiao-de-zi-mu-yi-wei-ci</id>
        <link href="https://lixin-ee.github.io//post/zi-fu-chuan-242-you-xiao-de-zi-mu-yi-wei-ci">
        </link>
        <updated>2019-10-05T02:57:12.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
<p>示例 1:<br>
输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;<br>
输出: true<br>
示例 2:<br>
输入: s = &quot;rat&quot;, t = &quot;car&quot;<br>
输出: false<br>
说明:<br>
你可以假设字符串只包含小写字母。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/valid-anagram<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题也是简单题，非常适合用来夯实基础<br>
我一开始的思路是对于s每个存在的字母，都分别对s和t中该字母的数量进行count，注意顺序容器不像关联容器的count，没有自带的count，必须使用泛型算法中的count</p>
<pre><code>class Solution {
public:
    bool isAnagram(string s, string t) {
        int lens=s.size(),lent=t.size();
        if(lens!=lent)
            return false;
        for(auto c:s)
            if(count(s.begin(),s.end(),c)!=count(t.begin(),t.end(),c))
                return false;
        return true;
    }
};
</code></pre>
<p>提交的时候发现超时了，想想也是哦，count算法看起来很方便，其实背后是需要循环一遍字符串的，再加上外部的循环，等于时间复杂度位o(n^2)，实在不是一个好解法<br>
然后我想到了hashmap，可以先循环s，用map记录出现的单词和相应的次数，再循环t递减次数并监督是否有小于0的情况。但是后来转念一想，假设都是小写字母的话，一个大小为26的vector就足以应付了，所以得到代码如下</p>
<pre><code>class Solution {
public:
    bool isAnagram(string s, string t) {
        int lens=s.size(),lent=t.size();
        if(lens!=lent)
            return false;
        vector&lt;int&gt; vi(26,0);
        for(auto c:s)
            ++vi[c-'a'];
        for(auto c:t)
            if(--vi[c-'a']&lt;0)
                return false;
        return true;
    }
};
</code></pre>
<p>然后最后复习一遍快速排序吧，如果对空间复杂度有要求的话还是必须用快速排序，桶排序就不如前一种算法了。</p>
<pre><code>class Solution {
public:
    bool isAnagram(string s, string t) {
        int lens=s.size(),lent=t.size();
        if(lens!=lent)
            return false;
        Qsort(0,s.size()-1,s);
        Qsort(0,t.size()-1,t);
        if(s!=t)
            return false;
        return true;
    }
    
    void Qsort(int beg,int end,string &amp;s){
        if(beg&lt;end){
         int middle=partition(beg,end,s);
         Qsort(beg,middle-1,s);
         Qsort(middle+1,end,s);
        }
    }
    
    int partition(int beg,int end,string &amp;s){
        int flag=s[beg];
        while(beg&lt;end){
            while(beg&lt;end&amp;&amp;s[end]&gt;=flag)
                --end;
            swap(s[beg],s[end]);
            while(beg&lt;end&amp;&amp;s[beg]&lt;=flag)
                ++beg;
            swap(s[beg],s[end]);
        }
        return beg;
    }
};
</code></pre>
<p>快速排序有不少需要注意的地方，比如判断条件的设置和返回值的设置。<br>
最后看了一下官方题解，和我的思路一致。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 290. 单词规律]]></title>
        <id>https://lixin-ee.github.io//post/zi-fu-chuan-290-dan-ci-gui-lu</id>
        <link href="https://lixin-ee.github.io//post/zi-fu-chuan-290-dan-ci-gui-lu">
        </link>
        <updated>2019-10-04T04:57:13.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。<br>
这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。</p>
<p>示例1:<br>
输入: pattern = &quot;abba&quot;, str = &quot;dog cat cat dog&quot;<br>
输出: true<br>
示例 2:<br>
输入:pattern = &quot;abba&quot;, str = &quot;dog cat cat fish&quot;<br>
输出: false</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/word-pattern<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>又是一道让我无力吐槽的题目翻译，也太抽象了吧，真的是逼得我去看题解才看得明白</p>
<blockquote>
<p>首先要正确理解题目的意思，举例说明：<br>
pattern = &quot;abba&quot;, str = &quot;dog cat cat dog&quot;<br>
意思是a-&gt;dog,b-&gt;cat,由于a！=b,所以dog也应该!=cat，满足返回true；</p>
</blockquote>
<p>这就很明显了，其实和昨天的题<a href="">同构字符串</a>是一模一样的思路，只是最好先把str中的单词抽出来放到<code>vector&lt;string&gt;</code>里面，和Java等语言不同，c++没有按空格分割string单词的函数，只能自己分割一下了，然后就两种方法，昨天已经实现了map的方法，今天就来实现下下标检查法吧：</p>
<pre><code>class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        map&lt;char,int&gt; alpha;
        for(auto c:magazine){
            if(!alpha.insert(make_pair(c,1)).second)
                ++alpha[c];
        }        
        for(auto c:ransomNote)
            if(!alpha.count(c))
                return false;
            else if(alpha[c]&gt;0)
                --alpha[c];
            else
                return false;
        return true;
        
    }
};
</code></pre>
<p>主要注意的点就在于string分割，特别是最后一个单词，必须考虑只有一个单词的情况，所以必须引入temp，然后将最后一个单词的提取放到循环外。<br>
然后我的string分割可能复杂了一点，网友题解中有一个不错的贴上了供日后参考：</p>
<pre><code>// 分割字符串
vector&lt;string&gt; words;
string s;
for (int i = 0; i &lt; str.size(); i++)
    if (str[i] == ' ') {
        if (s.size())
            words.push_back(s);
            s = &quot;&quot;;
    } else
        s += str[i];

if (s.size())
    words.push_back(s);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 205. 同构字符串]]></title>
        <id>https://lixin-ee.github.io//post/zi-fu-chuan-205-tong-gou-zi-fu-chuan</id>
        <link href="https://lixin-ee.github.io//post/zi-fu-chuan-205-tong-gou-zi-fu-chuan">
        </link>
        <updated>2019-10-03T02:50:19.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定两个字符串 s 和 t，判断它们是否是同构的。<br>
如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。<br>
所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p>
<p>示例 1:<br>
输入: s = &quot;egg&quot;, t = &quot;add&quot;<br>
输出: true<br>
示例 2:<br>
输入: s = &quot;foo&quot;, t = &quot;bar&quot;<br>
输出: false<br>
示例 3:<br>
输入: s = &quot;paper&quot;, t = &quot;title&quot;<br>
输出: true</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/isomorphic-strings<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题也是简单题，第一感觉就是使用哈希map，但是有个细节问题需要解决，题目描述得不够清楚，下面通过我的几次错误提交来分析吧<br>
第一方案：一个map stot<br>
只使用一个map从s映射到t，但此时是无法保存t中的情况，所以错误的测试用例是&quot;ab&quot;-&quot;aa&quot;，因为对于s来说两个都是不同元素，但是t中则是相同的元素<br>
第二方案：使用map同时记录s-t和t-s，这时有个问题是如果s中的a对应t中的b，那t中的a需不需要对应s中的b呢？这里我首先猜测是需要的，所以将所有字符对映射到map中，然后也出现了错误测试用例&quot;ab&quot;-&quot;bc&quot;，说明是这个映射是分离的<br>
最终方案：那就无话可说啦，必须上两个map了，代码如下：</p>
<pre><code>class Solution {
public:
    bool isIsomorphic(string s, string t) {
        int lens=s.size(),lent=t.size();
        if(lens!=lent)
            return false;
        if(!lens)
            return true;
        map&lt;char,char&gt; stot;
        map&lt;char,char&gt; ttos;
        for(int i=0;i&lt;lens;++i){
            if(stot.count(s[i])||ttos.count(t[i])){
                if(t[i]!=stot[s[i]]||s[i]!=ttos[t[i]])
                    return false;
            }
            else{
                stot.insert(make_pair(s[i],t[i]));
                ttos.insert(make_pair(t[i],s[i]));
            }
        }
        return true;
    }
};
</code></pre>
<p>然后网友题解中有一个很秀的操作，向我们诠释了为啥这是一道简单题：</p>
<blockquote>
<p>同构代表两个字符串中每个位置上字符在自身第一次出现的索引相同</p>
</blockquote>
<p>这就很简单了，太秀了吧！</p>
<pre><code>class Solution {
public:
    bool isIsomorphic(string s, string t) {
       if(s.size()!=t.size())
            return false;
       for(int i=0;i&lt;s.size();++i)
           if(s.find(s[i])!=t.find(t[i]))
               return false;
        return true;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 345. 反转字符串中的元音字母]]></title>
        <id>https://lixin-ee.github.io//post/345-fan-zhuan-zi-fu-chuan-zhong-de-yuan-yin-zi-mu</id>
        <link href="https://lixin-ee.github.io//post/345-fan-zhuan-zi-fu-chuan-zhong-de-yuan-yin-zi-mu">
        </link>
        <updated>2019-10-03T01:51:15.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>编写一个函数，以字符串作为输入，反转该字符串中的元音字母。</p>
<p>示例 1:<br>
输入: &quot;hello&quot;<br>
输出: &quot;holle&quot;<br>
示例 2:<br>
输入: &quot;leetcode&quot;<br>
输出: &quot;leotcede&quot;<br>
说明:<br>
元音字母不包含字母&quot;y&quot;。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/reverse-vowels-of-a-string<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题也是简单题（因为上一道中等题被锁了...）这道题的位置其实可以放在前面一点，用的方法也是比较简单，主要还是使用find_first_of和find_last_of 主要需要注意的点还是重新搜索的点必须是left+1和right-1，否则会原地打转。<br>
然后来复习一下fin_first_of吧，在stl源码剖析中使用的是迭代器的版本，返回的也是最简单的迭代器。然后其内部实现其实时间复杂度是<code>o(n*m)</code>，其中m是vowel的长度，内部是两次迭代，所以看起来程序很简单，但是其实花的时间也不少。<br>
看了一下网友题解，基本都是使用 set和双指针的结合，其实就和我这个思路一致了。</p>
<pre><code>class Solution {
public:
    string reverseVowels(string s) {
        string vowel=&quot;aeiouAEIOU&quot;;
        int left=s.find_first_of(vowel);
        int right=s.find_last_of(vowel);
        while(left!=string::npos&amp;&amp;right!=string::npos&amp;&amp;left&lt;right){
            swap(s[left],s[right]);
            left=s.find_first_of(vowel,left+1);
            right=s.find_last_of(vowel,right-1);
        }
        return s;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 151. 翻转字符串里的单词]]></title>
        <id>https://lixin-ee.github.io//post/zi-fu-chuan-151-fan-zhuan-zi-fu-chuan-li-de-dan-ci</id>
        <link href="https://lixin-ee.github.io//post/zi-fu-chuan-151-fan-zhuan-zi-fu-chuan-li-de-dan-ci">
        </link>
        <updated>2019-10-02T10:28:28.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个字符串，逐个翻转字符串中的每个单词。</p>
<p>示例 1：<br>
输入: &quot;the sky is blue&quot;<br>
输出: &quot;blue is sky the&quot;<br>
示例 2：<br>
输入: &quot;  hello world!  &quot;<br>
输出: &quot;world! hello&quot;<br>
解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<br>
示例 3：<br>
输入: &quot;a good   example&quot;<br>
输出: &quot;example good a&quot;<br>
解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/reverse-words-in-a-string<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题一开始没看清楚，上来就是想直接reverse，结果输出一直很奇怪，才发现是将单词的位置进行翻转，而单词内部不需要进行翻转（当然输出错误的主要原因也在于我一直把s当作space拿去匹配了...）<br>
这个整体还是和前一题一样，对元素进行翻转，但是这一次需要自己进行元素的搜索，所以可以看作<a href="https://lixin-ee.github.io/post/zi-fu-chuan-344fan-zhuan-zi-fu-chuan/">反转字符串</a>和<a href="https://lixin-ee.github.io/post/zi-fu-chuan-58-zui-hou-yi-ge-dan-ci-de-chang-du/">最后一个单词的长度</a>这两道题的结合吧。<br>
但是因为这一次没有对空间复杂度作出要求，所以我直接使用了额外的字符串进行保存。一开始老是没想起来怎么插入比较好，然后翻阅了笔记发现append这个函数最适合，比较类似可以设置范围的push_back，注意string的push_back只能以单个字符char作为参数的！然后还需要注意的是append参数的迭代器范围都是左闭右开的，所以右边的迭代器还需要额外+1.剩下的就是判断和空格插入的世纪问题了。<br>
最后结果如下：</p>
<pre><code>class Solution {
public:
    string reverseWords(string s) {
        int len=s.size();
        string space=&quot; &quot;;
        if(len==0)
            return s;
        string s_copy;
        int beg=s.find_last_not_of(space);
        int end=s.find_last_of(space,beg);
        while(beg!=string::npos){
            cout&lt;&lt;beg&lt;&lt;&quot; &quot;&lt;&lt;end&lt;&lt;endl;
            if(end==string::npos){
                s_copy.append(s.begin(),s.begin()+beg+1);
                break;
            }
            else
                 s_copy.append(s.begin()+end+1,s.begin()+beg+1);
            beg=s.find_last_not_of(space,end);
            end=s.find_last_of(space,beg);
            if(beg!=string::npos)
                s_copy.push_back(' ');
        }
        return s_copy;
    } 
};
</code></pre>
<p>然后来考虑原地算法，原地算法的难点不在反转，反转其实可以考虑<a href="https://lixin-ee.github.io/post/shu-zu-189xuan-zhuan-shu-zu/">数组189 旋转数组</a>，先对数组整体进行reverse，再对单个单词进行reverse。难点在于如何检测并去除多余的空格，我看了一下网友题解，基本是将元素进行移动或者将首尾的空格无视掉（使用substr），还是牺牲一点空间舒服一点啊hhh</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 344.反转字符串]]></title>
        <id>https://lixin-ee.github.io//post/zi-fu-chuan-344fan-zhuan-zi-fu-chuan</id>
        <link href="https://lixin-ee.github.io//post/zi-fu-chuan-344fan-zhuan-zi-fu-chuan">
        </link>
        <updated>2019-10-02T04:02:45.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。<br>
不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。<br>
你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p>
<p>示例 1：<br>
输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]<br>
输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]<br>
示例 2：<br>
输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]<br>
输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/reverse-string<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题还是简单题，其实就是按照下标进行互换，主要点在于对下标的判断条件，最好还是使用beg&lt;end这个判断条件比较方便。<br>
我的做法也比较简单，因为没有插入操作或者让迭代器失效的操作，所以直接用迭代器来判断，然后因为题目说可以默认容器中的元素全部都是小写字母，所以可以使用原地互换的方法而不用担心溢出问题，最后结果如下：</p>
<pre><code>class Solution {
public:
    void reverseString(vector&lt;char&gt;&amp; s) {
        if(!s.size())
            return;
        auto beg=s.begin();
        auto end=s.end()-1;
        while(beg&lt;end){
            *beg=*beg+*end;
            *end=*beg-*end;
            *beg=*beg-*end;
            ++beg,--end;
        }
    }
};
</code></pre>
<p>然后主要还是复习一STL源码，因为这么常用的算法肯定已经被库内实现的了。<br>
库内的翻转函数名字叫reverse 主要的要点在于<br>
1.首先区分容器迭代器的内容，因为非random_accesss_iterator的话是没法进行&lt;小于号判断的（但是可以++和--），如果是bidiretional的话就进行first<mark>last||first</mark>--last的判断<br>
2.进行iter_swap(first,last)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 383. 赎金信]]></title>
        <id>https://lixin-ee.github.io//post/zi-fu-chuan-383-shu-jin-xin</id>
        <link href="https://lixin-ee.github.io//post/zi-fu-chuan-383-shu-jin-xin">
        </link>
        <updated>2019-10-01T11:29:08.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串ransom能不能由第二个字符串magazines里面的字符构成。如果可以构成，返回 true ；否则返回 false。<br>
(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。)</p>
<p>注意：<br>
你可以假设两个字符串均只含有小写字母。</p>
<p>canConstruct(&quot;a&quot;, &quot;b&quot;) -&gt; false<br>
canConstruct(&quot;aa&quot;, &quot;ab&quot;) -&gt; false<br>
canConstruct(&quot;aa&quot;, &quot;aab&quot;) -&gt; true</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/ransom-note<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这一次是我第一次正式吐槽题目，其实题目的出发点是好的，但是题目描述非常烂，第一次我以为是在第二个字符串中只要包含了第一字符串的字母就vans了，上来就是一个set，结果发现第二个例程无法通过。本来以为是必须按要求的顺序，百思不得其解就看了网友题解，才明白原来是第二个数组中的每个字母只能用一次，wtf写个赎金信还要求字母不得重复的吗？<br>
算了算了，其实方法和上一题重复字符的官方题解就很相似，使用map并记录次数，对于第一个字符串中的相应字符进行递减，低于0的就返回false<br>
题解如下，这一次第一次没有官方题解也没有比较好的网友题解，然后leetcode日常歧视关联容器，耗费时间永远不低。</p>
<pre><code>class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        map&lt;char,int&gt; alpha;
        for(auto c:magazine){
            if(!alpha.insert(make_pair(c,1)).second)
                ++alpha[c];
        }        
        for(auto c:ransomNote)
            if(!alpha.count(c))
                return false;
            else if(alpha[c]&gt;0)
                --alpha[c];
            else
                return false;
        return true;
        
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 387. 字符串中的第一个唯一字符]]></title>
        <id>https://lixin-ee.github.io//post/zi-fu-chuan-387-zi-fu-chuan-zhong-de-di-yi-ge-wei-yi-zi-fu</id>
        <link href="https://lixin-ee.github.io//post/zi-fu-chuan-387-zi-fu-chuan-zhong-de-di-yi-ge-wei-yi-zi-fu">
        </link>
        <updated>2019-09-30T15:42:40.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p>
<p>案例:<br>
s = &quot;leetcode&quot;<br>
返回 0.<br>
s = &quot;loveleetcode&quot;,<br>
返回 2.</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/first-unique-character-in-a-string<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>面对重复元素的问题，一方面如果必须是常数空间复杂度的话，可以用暴力法或者排序法进行解决，另一方面如果对空间复杂度没要求或者要求线性时间复杂度的话，那最好就是用关联容器map或者set了。<br>
首先我用暴力法解决一下，主要就是对每个元素进行一次遍历，如果没有重复的话就返回其位置。需要注意的是j的取值也是从0开始，而且必须跳过i，否则会只对身后的元素进行判断。</p>
<pre><code>class Solution {
public:
    int firstUniqChar(string s) {
        int len = s.size();
        if(!len)
            return -1;
        if(len==1)
            return 0;
        for(int i=0;i&lt;len;++i)
            for(int j=0;j&lt;len;++j)
                if(s[i]==s[j]&amp;&amp;i!=j)
                    break;
                else if(j==len-1)
                    return i;
        return -1;
        
    }
};
</code></pre>
<p>暴力法实现完了，第二个自然就是关联容器了，因为需要返回值的位置，所以需要的位置来保存值的位置，所以使用map或者multi，然后我首先想到的是map，map的实现如下，主要需要注意的1.我一开始的想法是如果插入失败就等于有重复的值在map里面了，就使用erase去除，但是这样会导致一个问题就是只能检测偶数的重复，如果遇到奇数的重复反而变不重复了（因为我们最后是检测不重复，而不是重复）所以后面改成如果插入失败就把下标搜索将second改为n+1。3.map的下标是直接返回second值的，不需要再调用second 3. 需要再遍历一遍map，因为map不会按照插入顺序进行保存的，而是根据关键字的有序来保存的，比如例子中的leetcode，<code>(*map.begin()).second</code> 返回的反而是c的位置（同时注意调用的括号所在，调用运算符的优先级高于解引用运算符）。<br>
代码如下：</p>
<pre><code>class Solution {
public:
    int firstUniqChar(string s) {
        int len = s.size();
        if(!len)
            return -1;
        if(len==1)
            return 0;
        map&lt;char,int&gt; maps;
        int i=0;
        for(auto c:s){
            if(!maps.insert(make_pair(c,i)).second)
                maps[c]=len+1;
            ++i;          
        }
        
        if(maps.empty())
            return -1;
        int min=len+1;
        for(auto m:maps)
            if(m.second!=-1)
            min=min&lt;m.second?min:m.second;
        if(min==len+1)
            return -1;
        return min;
    }
};
</code></pre>
<p>然后我突然觉得可能multimap更加适合这种情况，第二次的时候不需要遍历map，而是直接遍历字符串，用count来计算字符在multimap的数量（注意不可以使用下标运算符了，只能使用find），但是很遗憾，在面对超长字符串的时候会导致超时。</p>
<pre><code>class Solution {
public:
    int firstUniqChar(string s) {
        int len = s.size();
        if(!len)
            return -1;
        if(len==1)
            return 0;
        multimap&lt;char,int&gt; maps;
        int i=0;
        for(auto c:s){
            maps.insert(make_pair(c,i));
            ++i;          
        }
        for(auto c:s){
            int j=maps.count(c);   
            if(j==1)
                return maps.find(c)-&gt;second;
        }
        return -1;
       
    }
};
</code></pre>
<p>看一下官方题解：</p>
<blockquote>
<p>方法一： 线性时间复杂度解法<br>
这道题最优的解法就是线性复杂度了，为了保证每个元素是唯一的，至少得把每个字符都遍历一遍。</p>
<p>算法的思路就是遍历一遍字符串，然后把字符串中每个字符出现的次数保存在一个散列表中。这个过程的时间复杂度为 O(N)，其中 N 为字符串的长度。</p>
<p>接下来需要再遍历一次字符串，这一次利用散列表来检查遍历的每个字符是不是唯一的。如果当前字符唯一，直接返回当前下标就可以了。第二次遍历的时间复杂度也是 O(N)。</p>
</blockquote>
<pre><code>class Solution {
    public int firstUniqChar(String s) {
        HashMap&lt;Character, Integer&gt; count = new HashMap&lt;Character, Integer&gt;();
        int n = s.length();
        // build hash map : character and how often it appears
        for (int i = 0; i &lt; n; i++) {
            char c = s.charAt(i);
            count.put(c, count.getOrDefault(c, 0) + 1);
        }
        
        // find the index
        for (int i = 0; i &lt; n; i++) {
            if (count.get(s.charAt(i)) == 1) 
                return i;
        }
        return -1;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度： O(N)<br>
只遍历了两遍字符串，同时散列表中查找操作是常数时间复杂度的。<br>
空间复杂度： O(N)<br>
用到了散列表来存储字符串中每个元素出现的次数。</p>
</blockquote>
<p>其实和我的想法一致，就是map的键值和第二次搜索的处理不同，值得向官方题解学习一下</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[三种线性排序算法 计数排序、桶排序与基数排序]]></title>
        <id>https://lixin-ee.github.io//post/san-chong-xian-xing-pai-xu-suan-fa-ji-shu-pai-xu-tong-pai-xu-yu-ji-shu-pai-xu</id>
        <link href="https://lixin-ee.github.io//post/san-chong-xian-xing-pai-xu-suan-fa-ji-shu-pai-xu-tong-pai-xu-yu-ji-shu-pai-xu">
        </link>
        <updated>2019-09-30T13:00:57.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章对应的就是前面的算法题 <a href="https://lixin-ee.github.io/post/shu-zu-164-zui-da-jian-ju/">数组164.最大间距</a>，今天在地铁上特地重新复习了一下排序算法<br>
本文主要参考了<a href="https://www.byvoid.com/zhs/blog/sort-radix">BYVoid 原创讲解</a><br>
其实比较常用的算法是基于比较的算法，因为在面对超长数组的时候内存是最大的制掣因素。<br>
众所周知，基于比较的排序算法是不能突破O(NlogN)的。简单证明如下：<br>
N个数有N!个可能的排列情况，也就是说基于比较的排序算法的判定树有N!个叶子结点，比较次数至少为log(N!)=O(NlogN)(斯特林公式)。</p>
<p>但有趣的事，非基于比较的排序，如计数排序，桶排序，和在此基础上的基数排序，则可以突破O(NlogN)时间下限。<strong>但要注意的是，非基于比较的排序算法的使用都是有条件限制的，例如元素的大小限制</strong>，相反，基于比较的排序则没有这种限制(在一定范围内)。但并非因为有条件限制就会使非基于比较的排序算法变得无用，对于特定场合有着特殊的性质数据，非基于比较的排序算法则能够非常巧妙地解决。</p>
<p>[计数排序]<br>
首先从计数排序(Counting Sort)开始介绍起，假设我们有一个待排序的整数序列A，其中元素的最小值不小于0，最大值不超过K。建立一个长度为K的线性表C，用来记录不大于每个值的元素的个数。</p>
<p>算法思路如下：</p>
<p>扫描序列A，以A中的每个元素的值为索引，把出现的个数填入C中。此时C[i]可以表示A中值为i的元素的个数。<br>
对于C从头开始累加，使C[i]&lt;-C[i]+C[i-1]。这样，C[i]就表示A中值不大于i的元素的个数。<br>
按照统计出的值，输出结果。<br>
由线性表C我们可以很方便地求出排序后的数据，定义B为目标的序列，Order[i]为排名第i的元素在A中的位置，则可以用以下方法统计。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
using namespace std;
void CountingSort(int *A,int *B,int *Order,int N,int K)
{
    int *C=new int[K+1];
    int i;
    memset(C,0,sizeof(int)*(K+1));
    for (i=1;i&lt;=N;i++) //把A中的每个元素分配
        C[A[i]]++;
    for (i=2;i&lt;=K;i++) //统计不大于i的元素的个数
        C[i]+=C[i-1];
    for (i=N;i&gt;=1;i--)
    {
        B[C[A[i]]]=A[i]; //按照统计的位置，将值输出到B中，将顺序输出到Order中
        Order[C[A[i]]]=i;
        C[A[i]]--;
    }
}
int main()
{
    int *A,*B,*Order,N=15,K=10,i;
    A=new int[N+1];
    B=new int[N+1];
    Order=new int[N+1];
    for (i=1;i&lt;=N;i++)
        A[i]=rand()%K+1; //生成1..K的随机数
    printf(&quot;Before CS:\n&quot;);
    for (i=1;i&lt;=N;i++)
        printf(&quot;%d &quot;,A[i]);
    CountingSort(A,B,Order,N,K);
    printf(&quot;\nAfter CS:\n&quot;);
    for (i=1;i&lt;=N;i++)
        printf(&quot;%d &quot;,B[i]);
    printf(&quot;\nOrder:\n&quot;);
    for (i=1;i&lt;=N;i++)
        printf(&quot;%d &quot;,Order[i]);
    return 0;
}
程序运行效果如下：

Before CS:
2 8 5 1 10 5 9 9 3 5 6 6 2 8 2
After CS:
1 2 2 2 3 5 5 5 6 6 8 8 9 9 10
Order:
4 1 13 15 9 3 6 10 11 12 2 14 7 8 5
</code></pre>
<p>我们可以看到，计数排序的要点在于1.提前知道数组的取值范围 2.取值范围K在内存能够接受的范围内。3.通过反向操作保证其为稳定排序算法。<br>
计数排序的时间复杂度为O(N+K)，空间复杂度为O(N+K)。当K不是很大时，这是一个很有效的线性排序算法。更重要的是，它是一种<strong>稳定排序算法</strong>，即排序后的相同值的元素原有的相对位置不会发生改变(表现在Order上)，这是计数排序很重要的一个性质，就是根据这个性质，我们才能把它应用到基数排序。</p>
<p>[桶排序]<br>
在读计数排序的代码时我发现了一个问题，一是如果重复的元素越多，浪费的空间就越多，比如有很多个2的时候。二是计数排序似乎饶了点弯子，比如当我们刚刚统计出C，C[i]可以表示A中值为i的元素的个数，此时我们直接顺序地扫描C，就可以求出排序后的结果。的确是这样，不过这种方法不再是计数排序，而是桶排序(Bucket Sort)，确切地说，是桶排序的一种特殊情况，但是直接顺序搜索c得到的的桶排序是不稳定的，同时也需要占到太多的额外空间。（不要小看稳定，单个数组看不出来问题所在，如果是map这种分为key-value和map-value的，把key-value弄乱了就出大事了）<br>
正式的桶排序如下：<br>
首先定义桶，桶为一个数据容器，每个桶存储一个区间内的数。依然有一个待排序的整数序列A，元素的最小值不小于0，最大值不超过K。假设我们有M个桶，第i个桶Bucket[i]存储i*K/M至(i+1)K/M之间的数，有如下桶排序的一般方法：</p>
<p>扫描序列A，根据每个元素的值所属的区间，放入指定的桶中(顺序放置)。<br>
对每个桶中的元素进行排序，什么排序算法都可以，例如快速排序。<br>
依次收集每个桶中的元素，顺序放置到输出序列中。<br>
对该算法简单分析，如果数据是期望平均分布的，则每个桶中的元素平均个数为N/M。如果对每个桶中的元素排序使用的算法是快速排序，每次排序的时间复杂度为O(N/Mlog(N/M))。则总的时间复杂度为O(N)+O(M)O(N/Mlog(N/M)) = O(N+ Nlog(N/M)) = O(N + NlogN - NlogM)。当M接近于N是，桶排序的时间复杂度就可以近似认为是O(N)的。就是桶越多，时间效率就越高，而桶越多，空间却就越大，由此可见时间和空间是一个矛盾的两个方面。</p>
<p>桶中元素的顺序放入和顺序取出是有必要的，因为这样可以确定桶排序是一种稳定排序算法，配合基数排序是很好用的。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
using namespace std;
struct linklist
{
    linklist *next;
    int value;
    linklist(int v,linklist *n):value(v),next(n){}
    ~linklist() {if (next) delete next;}
};
inline int cmp(const void *a,const void *b)
{
    return *(int *)a-*(int *)b;
}
</code></pre>
<p>为了方便，我把A中元素加入桶中时是倒序放入的，而收集取出时也是倒序放入序列的，所以不违背稳定排序。</p>
<pre><code>void BucketSort(int *A,int *B,int N,int K)
{
    linklist *Bucket[101],*p;//建立桶
    int i,j,k,M;
    M=K/100;
    memset(Bucket,0,sizeof(Bucket));
    for (i=1;i&lt;=N;i++)
    {
        k=A[i]/M; //把A中的每个元素按照的范围值放入对应桶中
        Bucket[k]=new linklist(A[i],Bucket[k]);
    }
    for (k=j=0;k&lt;=100;k++)
    {
        i=j;
        for (p=Bucket[k];p;p=p-&gt;next)
            B[++j]=p-&gt;value; //把桶中每个元素取出，排序并加入B
        delete Bucket[k];
        qsort(B+i+1,j-i,sizeof(B[0]),cmp);
    }
}
int main()
{
    int *A,*B,N=100,K=10000,i;
    A=new int[N+1];
    B=new int[N+1];
    for (i=1;i&lt;=N;i++)
        A[i]=rand()%K+1; //生成1..K的随机数
    BucketSort(A,B,N,K);
    for (i=1;i&lt;=N;i++)
        printf(&quot;%d &quot;,B[i]);
    return 0;
}
</code></pre>
<p>[基数排序]<br>
下面说到我们的重头戏，基数排序(Radix Sort)。上述的基数排序和桶排序都只是在研究一个关键字的排序，现在我们来讨论有多个关键字的排序问题。</p>
<p>假设我们有一些二元组(a,b)，要对它们进行以a为首要关键字，b的次要关键字的排序。我们可以先把它们先按照首要关键字排序，分成首要关键字相同的若干堆。然后，在按照次要关键值分别对每一堆进行单独排序。最后再把这些堆串连到一起，使首要关键字较小的一堆排在上面。按这种方式的基数排序称为MSD(Most Significant Dight)排序。</p>
<p>第二种方式是从最低有效关键字开始排序，称为LSD(Least Significant Dight)排序。首先对所有的数据按照次要关键字排序，然后对所有的数据按照首要关键字排序。要注意的是，使用的排序算法必须是稳定的，否则就会取消前一次排序的结果。由于不需要分堆对每堆单独排序，LSD方法往往比MSD简单而开销小。下文介绍的方法全部是基于LSD的。</p>
<p>通常，基数排序要用到计数排序或者桶排序。使用计数排序时，需要的是Order数组。使用桶排序时，可以用链表的方法直接求出排序后的顺序。下面是一段用桶排序对二元组基数排序的程序：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
using namespace std;
struct data
{
    int key[2];
};
struct linklist
{
    linklist *next;
    data value;
    linklist(data v,linklist *n):value(v),next(n){}
    ~linklist() {if (next) delete next;}
};
void BucketSort(data *A,int N,int K,int y)
{
    linklist *Bucket[101],*p;//建立桶
    int i,j,k,M;
    M=K/100+1;
    memset(Bucket,0,sizeof(Bucket));
    for (i=1;i&lt;=N;i++)
    {
        k=A[i].key[y]/M; //把A中的每个元素按照的范围值放入对应桶中
        Bucket[k]=new linklist(A[i],Bucket[k]);
    }
    for (k=j=0;k&lt;=100;k++)
    {
        for (p=Bucket[k];p;p=p-&gt;next) j++;
        for (p=Bucket[k],i=1;p;p=p-&gt;next,i++)
            A[j-i+1]=p-&gt;value; //把桶中每个元素取出
        delete Bucket[k];
    }
}
void RadixSort(data *A,int N,int K)
{
    for (int j=1;j&gt;=0;j--) //从低优先到高优先 LSD
        BucketSort(A,N,K,j);
}
int main()
{
    int N=100,K=1000,i;
    data *A=new data[N+1];
    for (i=1;i&lt;=N;i++)
    {
        A[i].key[0]=rand()%K+1;
        A[i].key[1]=rand()%K+1;
    }
    RadixSort(A,N,K);
    for (i=1;i&lt;=N;i++)
        printf(&quot;(%d,%d) &quot;,A[i].key[0],A[i].key[1]);
    printf(&quot;\n&quot;);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 58. 最后一个单词的长度]]></title>
        <id>https://lixin-ee.github.io//post/zi-fu-chuan-58-zui-hou-yi-ge-dan-ci-de-chang-du</id>
        <link href="https://lixin-ee.github.io//post/zi-fu-chuan-58-zui-hou-yi-ge-dan-ci-de-chang-du">
        </link>
        <updated>2019-09-29T10:05:17.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个仅包含大小写字母和空格 ' ' 的字符串，返回其最后一个单词的长度。<br>
如果不存在最后一个单词，请返回 0 。</p>
<p>说明：一个单词是指由字母组成，但不包含任何空格的字符串。<br>
示例:<br>
输入: &quot;Hello World&quot;<br>
输出: 5</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/length-of-last-word<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题也是简单题，其中主要的要点在于特殊例子。我一开始的想法是单纯地检测空格<br>
1.首先考虑最简单的情况，那就是正常的字符串，比如&quot;hallo world&quot;最后一个空格肯定是在最后一个单词前面，所以可以使用string的搜索算法 find_last_of(&quot; &quot;),然后用length减去返回的下标再减去1，同时适用于空格在字符串一开头的地方，比如&quot; hallo&quot;<br>
2.然后考虑特例之空格符出现在最后并且有单词，此时需要检测两个空格（因为 find_last_of是使用反向迭代器进行搜索的，所以后面所述的第一个对应最后一个）首先对第一个空格的位置进行检测证明loc=len-1，然后注意从第一个空格的位置loc-1开始搜索第二个空格，将第二个空格的位置与第一个空格的位置相减再减1就得到了返回值。与此种情况适用于最后一个单词被一对空格包住或者仅仅是单词+空格的情况，比如&quot;hallo &quot;<br>
3.但是上述情况都无法解决空格重复的情况，比如&quot;hallo     &quot;（后面带有多个空格），仔细思考后发现其实第一次检测可以把find_last_of(&quot; &quot;)改为更好的find_last_not_of(&quot; &quot;)这样子也保证了最后一个单词的存在，结合对单词前面的空格的检测，就能很轻松地得到最后一个单词了。但是注意有一个暗坑：如果没有空格，并且只有一个字母时，返回的下标是0，这个时候如果使用find_last_of(space, i - 1);进行空格探测是会因为-1而从最后一个位置开始检测的（注意在容器下标中是不可以使用-1的，但是此处应该是对size进行取模了），所以必须加上一个if检测。<br>
最后代码如下：</p>
<pre><code>class Solution {
public:
    int lengthOfLastWord(string s) {
		int len = s.size();
		if (len == 0)
			return 0;
		string space = &quot; &quot;;
		int i = s.find_last_not_of(space);
		if (i == string::npos)
			return 0;
		else if (!i)
			return 1;
		int j = s.find_last_of(space, i - 1);
		cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;
		if (j == string::npos)
			return i + 1;
		else
			return i - j; 
    }
};
</code></pre>
<p>其实细节还是蛮多的，比如如果找不到的时候，返回的下标可不是0或者-1，而是string::npos，这个值最好不要直接进行输出，用于比较就好，然后名字域是在string而不是std</p>
<p>然后贴一个网友题解，其实现是和我的想法一致的，只是我用的是封装好的string库函数，而网友的是完整的实现：</p>
<blockquote>
<p>思路<br>
标签：字符串遍历<br>
从字符串末尾开始向前遍历，其中主要有两种情况<br>
第一种情况，以字符串&quot;Hello World&quot;为例，从后向前遍历直到遍历到头或者遇到空格为止，即为最后一个单词&quot;World&quot;的长度5<br>
第二种情况，以字符串&quot;Hello World &quot;为例，需要先将末尾的空格过滤掉，再进行第一种情况的操作，即认为最后一个单词为&quot;World&quot;，长度为5<br>
所以完整过程为先从后过滤掉空格找到单词尾部，再从尾部向前遍历，找到单词头部，最后两者相减，即为单词的长度<br>
时间复杂度：O(n)，n为结尾空格和结尾单词总体长度<br>
代码</p>
</blockquote>
<pre><code>Java
class Solution {
    public int lengthOfLastWord(String s) {
        int end = s.length() - 1;
        while(end &gt;= 0 &amp;&amp; s.charAt(end) == ' ') end--;
        if(end &lt; 0) return 0;
        int start = end;
        while(start &gt;= 0 &amp;&amp; s.charAt(start) != ' ') start--;
        return end - start;
    }
}
</code></pre>
]]></content>
    </entry>
</feed>