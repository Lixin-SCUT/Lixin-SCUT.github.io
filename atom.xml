<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-09-24T01:23:10.166Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[数组 674. 最长连续递增序列]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-674-zui-chang-lian-xu-di-zeng-xu-lie</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-674-zui-chang-lian-xu-di-zeng-xu-lie">
        </link>
        <updated>2019-09-23T14:47:37.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个未经排序的整数数组，找到最长且连续的的递增序列。</p>
<p>示例 1:<br>
输入: [1,3,5,4,7]<br>
输出: 3<br>
解释: 最长连续递增序列是 [1,3,5], 长度为3。<br>
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。<br>
示例 2:<br>
输入: [2,2,2,2,2]<br>
输出: 1<br>
解释: 最长连续递增序列是 [2], 长度为1。<br>
注意：数组长度不会超过10000。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>哈哈哈好久没遇到这么简单的题了，嗯主要就是中间变量的设置吧，比如max和cout的递增时机和赋值时机，这个没什么难度，一次过了，时间复杂度o（n），空间复杂度o（1）</p>
<pre><code>class Solution {
public:
    int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) {
        int len=nums.size();
        if(len==0)
            return 0;
        int max=1;
        int cout=1;
        for(int i=1;i&lt;len;++i){
            if(nums[i]&gt;nums[i-1])
                ++cout;
            else 
                cout=1;
            max=max&gt;cout?max:cout;
        }
        return max;
    }
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>解决方法：滑动窗口<br>
算法：<br>
每个（连续）增加的子序列是不相交的，并且每当 nums[i-1]&gt;=nums[i] 时，每个此类子序列的边界都会出现。当它这样做时，它标志着在 nums[i] 处开始一个新的递增子序列，我们将这样的 i 存储在变量 anchor 中。<br>
例如，如果 nums=[7，8，9，1，2，3]，那么 anchor 从 0 开始（nums[anchor]=7），并再次设置为 anchor=3（nums[anchor]=1）。无论 anchor 的值如何，我们都会记录 i-anchor+1 的候选答案、子数组 nums[anchor]、nums[anchor+1]、…、nums[i] 的长度，并且我们的答案会得到适当的更新。</p>
</blockquote>
<pre><code>Java
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        int ans = 0, anchor = 0;
        for (int i = 0; i &lt; nums.length; ++i) {
            if (i &gt; 0 &amp;&amp; nums[i-1] &gt;= nums[i]) anchor = i;
            ans = Math.max(ans, i - anchor + 1);
        }
        return ans;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(N)，其中 N 是 nums 的长度。我们通过 nums 执行一个循环。<br>
空间复杂度：O(1)，anchor 和 ans 使用了常数级空间。</p>
</blockquote>
<p>其实官方题解是更加简洁的，直接判定每一个存在的转折点anchor，然后将当前位置减去anchor再进行判断存进ans里面。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 334. 递增的三元子序列]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-334-di-zeng-de-san-yuan-zi-xu-lie</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-334-di-zeng-de-san-yuan-zi-xu-lie">
        </link>
        <updated>2019-09-23T09:35:00.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。<br>
数学表达式如下:<br>
如果存在这样的 i, j, k,  且满足 0 ≤ i &lt; j &lt; k ≤ n-1，<br>
使得 arr[i] &lt; arr[j] &lt; arr[k] ，返回 true ; 否则返回 false 。<br>
说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1) 。</p>
<p>示例 1:<br>
输入: [1,2,3,4,5]<br>
输出: true<br>
示例 2:<br>
输入: [5,4,3,2,1]<br>
输出: false</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/increasing-triplet-subsequence<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题其实蛮尴尬的，一开始我以为是判断三个连续的递增子序列，楞了一下怎么这么简单，然后提交错误后分析了错误用例才发现其实要求是ijk这三者是符合大小就行了，也就等于说我们希望在整个数组中从左到右找到三个递增的数列就ok了<br>
由于时间不够，所以直接看了题解，一开始判断三个连续的我就不贴出来啦hhh<br>
然后这一次是没有官方题解的，只有网友解：</p>
<blockquote>
<p>3个连续递增子序列<br>
有3个槽位，a,b,c<br>
满足条件 a &lt; b &lt; c，即可<br>
需要将合适的元素填入这3个槽位</p>
</blockquote>
<pre><code>class Solution {
    public boolean increasingTriplet(int[] nums) {
        int one = Integer.MAX_VALUE;
        int two = Integer.MAX_VALUE;
        
        for (int n : nums) {
            if (n &lt;= one) {
                one = n;
            } else if (n &lt;= two) {
                two = n;
            } else {
                return true;
            }
        }
        
        return false;
    }
}
</code></pre>
<p>这一份最简洁，但是没有解释好原理，特别是one=n这一步其实很让人疑惑，比如数组{2，3，1，5} 此时最后结果为one=1 two=3 ，这里其实是有点让人摸不着头脑的<br>
然后看另外一位网友的解答</p>
<blockquote>
<p>首先，如果只有一个最小值，然后找不到中间值，那么这个数组必然不包含递增的三个数（因为连递增的两个数都找不到）。</p>
<p>然后假设我们找到了两个递增的值，那么如果下一个值小于最小值，我们就应该将最小值的指针定位到这个值上。我们尽可能的使用最小值，防止后面出现了更小的一对递增值，而即使不出现，也不妨碍我们找到解（因为最终是看能否找到大于中间值的值）。<br>
如果下一个值大于最小值，且小于中间值，则我们使用该值作为中间值(因为如果最小的中间值都得不到解，那么就是false，这样也保证了覆盖所有的情况)。</p>
<p>最后，如果找到了大于中间值的值，则为true.</p>
</blockquote>
<p>他的代码有点瑕疵我就不贴上来了。这样一来就很明显了，其实我们是把后面出现的最小值叠在了上面，相当于探寻一个新的递增序列，比如{3，4，1，2，5}，1和2都会叠在3和4上面，构成新的递增序列，但是不用怕，因为只有比原值小的才能叠上去，哪怕1把3覆盖了，所以只要出现5，就一定能正确返回true。<br>
我一开始想过用栈的想法，但是栈的先进先出的特性明显不太适合这个状况，当然这个做法其实是有点取巧的了，就如评论里说，最终的结果无法保证下标的正确性。需要付出额外的代价才能返回正确的坐标。<br>
连续几天没通过了吧，不过还是不要气馁，“无用功”乃成功之母！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 42. 接雨水]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-42-jie-yu-shui</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-42-jie-yu-shui">
        </link>
        <updated>2019-09-22T13:17:05.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<br>
<img src="https://lixin-ee.github.io//post-images/1569158527522.png" alt=""><br>
上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。<br>
示例:<br>
输入: [0,1,0,2,1,0,1,3,2,1,2,1]<br>
输出: 6<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/trapping-rain-water<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题一开始还是没有比较好的思路，主要的纠结点在于如何处理左边的结点，一开始本来想用暴力法，但是太暴力了，所以想改进一下。改进的方法为确定一个左值left，然后寻找一个右值能够大于或者等于left，同时在过程中累积雨水量rain，如果能够找到符合条件的右值，就将rain累加到总的雨水量中去<br>
以为为未通过的代码：问题也很明显，只能收集到从左到右符合条件（先低后高）的点，遇到【4，3，2】这种先高后低的情况就没办法检测到，只能从右到左再做一遍，此时就发现思路有问题了，所以直接看题解吧</p>
<pre><code>class Solution {
public:
    int trap(vector&lt;int&gt;&amp; height) {
        int len = height.size();
        if(len==0||len==1||len==2){
            return 0;
        }
        int rain_all=0;
        int left=0;
        int rain=0;
        for(int i=0;i&lt;len;++i)
            if(height[i]&gt;0){
                left=i;
                if(i&gt;=len-2)
                    return 0;
                break;
            }else if(i==len-1)
                return 0;
        for(int i=left;i&lt;len-2;){
            int h = height[i];
            for(int j=i+1;j&lt;len;++j)
                if(j==len-1&amp;&amp;height[j]&lt;h){
                    rain=0;
                    ++i;
                    break;
                }else if(height[j]&lt;h){
                    rain+=h-height[j];
                }else{
                    rain_all+=rain;
                    rain=0;
                    i=j;
                    break;
                }      
        }
        return rain_all;
    }
};
</code></pre>
<p>官方题解：<br>
方法 1：暴力<br>
直观想法<br>
直接按问题描述进行。对于数组中的每个元素，我们找出下雨后水能达到的最高位置，等于两边最大高度的较小值减去当前高度的值。</p>
<p>算法<br>
初始化ans=0<br>
从左向右扫描数组：<br>
初始化 max_left=0 和max_right=0<br>
从当前元素向左扫描并更新：<br>
max_left=max(max_left,height[j])<br>
从当前元素向右扫描并更新：<br>
max_right=max(max_right,height[j])<br>
将min(max_left,max_right)−height[i] 累加到 ans</p>
<pre><code>Java
int trap(vector&lt;int&gt;&amp; height)
{
    int ans = 0;
    int size = height.size();
    for (int i = 1; i &lt; size - 1; i++) {
        int max_left = 0, max_right = 0;
        for (int j = i; j &gt;= 0; j--) { //Search the left part for max bar size
            max_left = max(max_left, height[j]);
        }
        for (int j = i; j &lt; size; j++) { //Search the right part for max bar size
            max_right = max(max_right, height[j]);
        }
        ans += min(max_left, max_right) - height[i];
    }
    return ans;
}
</code></pre>
<p>复杂性分析<br>
时间复杂度： O(n^2)。数组中的每个元素都需要向左向右扫描。<br>
空间复杂度O(1) 的额外空间</p>
<p>方法 2：动态编程<br>
直观想法<br>
在暴力方法中，我们仅仅为了找到最大值每次都要向左和向右扫描一次。但是我们可以提前存储这个值。因此，可以通过动态编程解决。<br>
这个概念可以见下图解释：<br>
<img src="https://lixin-ee.github.io//post-images/1569159456849.png" alt=""><br>
算法<br>
找到数组中从下标 i 到最左端最高的条形块高度left_max。<br>
找到数组中从下标 i 到最右端最高的条形块高度 right_max。<br>
扫描数组height 并更新答案：<br>
累加min(max_left[i],max_right[i])−height[i] 到 ans 上</p>
<pre><code>C++
int trap(vector&lt;int&gt;&amp; height)
{
	if(height == null)
		return 0;
    int ans = 0;
    int size = height.size();
    vector&lt;int&gt; left_max(size), right_max(size);
    left_max[0] = height[0];
    for (int i = 1; i &lt; size; i++) {
        left_max[i] = max(height[i], left_max[i - 1]);
    }
    right_max[size - 1] = height[size - 1];
    for (int i = size - 2; i &gt;= 0; i--) {
        right_max[i] = max(height[i], right_max[i + 1]);
    }
    for (int i = 1; i &lt; size - 1; i++) {
        ans += min(left_max[i], right_max[i]) - height[i];
    }
    return ans;
}
</code></pre>
<p>复杂性分析<br>
时间复杂度：O(n)。<br>
存储最大高度数组，需要两次遍历，每次 O(n) 。<br>
最终使用存储的数据更新ans ，O(n)。<br>
空间复杂度：O(n) 额外空间。<br>
和方法 1 相比使用了额外的 O(n) 空间用来放置left_max 和right_max 数组。</p>
<p>方法 3：栈的应用<br>
直观想法<br>
我们可以不用像方法 2 那样存储最大高度，而是用栈来跟踪可能储水的最长的条形块。使用栈就可以在一次遍历内完成计算。<br>
我们在遍历数组时维护一个栈。如果当前的条形块小于或等于栈顶的条形块，我们将条形块的索引入栈，意思是当前的条形块被栈中的前一个条形块界定。如果我们发现一个条形块长于栈顶，我们可以确定栈顶的条形块被当前条形块和栈的前一个条形块界定，因此我们可以弹出栈顶元素并且累加答案到 ans 。</p>
<p>算法<br>
使用栈来存储条形块的索引下标。<br>
遍历数组：<br>
当栈非空且height[current]&gt;height[st.top()]<br>
意味着栈中元素可以被弹出。弹出栈顶元素 top。<br>
计算当前元素和栈顶元素的距离，准备进行填充操作<br>
distance=current−st.top()−1<br>
找出界定高度<br>
bounded_height=min(height[current],height[st.top()])−height[top]<br>
往答案中累加积水量ans+=distance×bounded_height<br>
将当前索引下标入栈<br>
将urrent 移动到下个位置<br>
C++</p>
<pre><code>int trap(vector&lt;int&gt;&amp; height)
{
    int ans = 0, current = 0;
    stack&lt;int&gt; st;
    while (current &lt; height.size()) {
        while (!st.empty() &amp;&amp; height[current] &gt; height[st.top()]) {
            int top = st.top();
            st.pop();
            if (st.empty())
                break;
            int distance = current - st.top() - 1;
            int bounded_height = min(height[current], height[st.top()]) - height[top];
            ans += distance * bounded_height;
        }
        st.push(current++);
    }
    return ans;
}
</code></pre>
<p>复杂性分析<br>
时间复杂度：O(n)。<br>
单次遍历 O(n) ，每个条形块最多访问两次（由于栈的弹入和弹出），并且弹入和弹出栈都是 O(1) 的。<br>
空间复杂度：O(n)。 栈最多在阶梯型或平坦型条形块结构中占用 O(n) 的空间。</p>
<p>方法 4：使用双指针<br>
直观想法<br>
和方法 2 相比，我们不从左和从右分开计算，我们想办法一次完成遍历。<br>
从动态编程方法的示意图中我们注意到，只要right_max[i]&gt;left_max[i] （元素 0 到元素 6），积水高度将由 left_max 决定，类似地 left_max[i]&gt;right_max[i]（元素 8 到元素 11）。<br>
所以我们可以认为如果一端有更高的条形块（例如右端），积水的高度依赖于当前方向的高度（从左到右）。当我们发现另一侧（右侧）的条形块高度不是最高的，我们则开始从相反的方向遍历（从右到左）。<br>
我们必须在遍历时维护left_max 和 right_max ，但是我们现在可以使用两个指针交替进行，实现 1 次遍历即可完成。</p>
<p>算法<br>
初始化 left 指针为 0 并且right 指针为 size-1<br>
While left&lt;right, do:<br>
If height[left] &lt;height[right]<br>
If eight[left]≥left_max, 更新left_max<br>
Else 累加left_max−height[left] 到ans<br>
left = left + 1.<br>
Else<br>
If height[right]≥right_max, 更新 right_max<br>
Else 累加 right_max−height[right] 到 ans<br>
right =right - 1.</p>
<pre><code>int trap(vector&lt;int&gt;&amp; height)
{
    int left = 0, right = height.size() - 1;
    int ans = 0;
    int left_max = 0, right_max = 0;
    while (left &lt; right) {
        if (height[left] &lt; height[right]) {
            height[left] &gt;= left_max ? (left_max = height[left]) : ans += (left_max - height[left]);
            ++left;
        }
        else {
            height[right] &gt;= right_max ? (right_max = height[right]) : ans += (right_max - height[right]);
            --right;
        }
    }
    return ans;
}
复杂性分析
</code></pre>
<p>时间复杂度：O(n)。单次遍历的时间O(n)。<br>
空间复杂度：O(1)的额外空间。left,right, left_max 和 right_max 只需要常数的空间。</p>
<p>借用评论的一句话：这么多解法 ，我一个也没想起来，依旧菜鸡...<br>
这一整周状态都很差，感觉从那件水桶时间开始就一直碰到不好的事，幸好刷leetcode算是比较舒服的一件事了，现在来看一下这四个题解吧<br>
（1）首先虽然暴力法很暴力，不过还是有可取的地方的，其思想是取两边的最大值，然后再取两个最大值中的<strong>小值</strong>，其实就相当于把两边的最大值移动到当前位置的两边，测试一个当前位置自己能够装多少水，然后累积每个位置的水。<br>
（2）第二题其实是暴力解的进一步简化，思想比较简单，但是很实用，就是把最大值提前算出来放好，计算的时候再用上，用空间换取了时间，这一个题解对我的震撼很大，因为之前都是不太看得起暴力解，但是这里让我意识到从暴力解入手进行优化也是很重要的一种思路啊！所以还是<strong>不能好高骛远！</strong> 扎扎实实才能站得更高更稳！<br>
我给出的代码如下</p>
<pre><code>class Solution {
public:
    int trap(vector&lt;int&gt;&amp; height) {
        int len = height.size();
        if(len==0||len==1||len==2){
            return 0;
        }
        int left=0,right=0;
       vector&lt;int&gt; max_left(len),max_right(len);
        for(int i=0;i&lt;len;++i)
            if(left&gt;height[i])
               max_left[i]=left;
            else
                max_left[i]=height[i],left=height[i];
        for(int i=len-1;i&gt;=0;--i)
            if(right&gt;height[i])
                max_right[i]=right;
            else
                 max_right[i]=height[i],right=height[i];
        int ans=0;
        for(int i=0;i&lt;len;++i)
            ans+=(max_left[i]&lt;max_right[i]?max_left[i]:max_right[i])-height[i];
        return ans;
    }
};
</code></pre>
<p>（3）题解三用到了栈，但是我一开始想了很久都没想明白是怎么做到的，因为比如很简单的情况 21013，第二个1进来的时候只能对0进行操作，此时对比0两边的数，ans只能增加1，而实际上0这个位置可以增加2（因为最大的值其实是2），题解中非常巧妙地引入了distance的概念，相当于把水按行来计算，而不是和前两题一样按照列来算，比如2101中，101把第一行的空格子填满了，而213时（注意0和第二个1被弹出栈了），计算distance相当于把第二行给填满了（(2-1)+3），一开始还不容易看出呢，同时push被安排在while循环后面，不仅感叹妙啊！需要注意的地方是如果弹出栈顶后栈为空（等于没了一边边界），就需要break跳出循环直接push了</p>
<pre><code>class Solution {
public:
    int trap(vector&lt;int&gt;&amp; height) {
        int len = height.size();
        if(len==0||len==1||len==2){
            return 0;
        }
        stack&lt;int&gt; s;
        int ans=0;
        for(int i=0;i&lt;len;++i){
            if(s.empty())
                s.push(i);
            else{
                while(height[i]&gt;height[s.top()]){
                    int top = s.top();
                    s.pop();
                    if(s.empty())
                        break;
                    int distance = i-s.top()-1;
                    ans += ((height[i]&lt;height[s.top()]?height[i]:height[s.top()])-height[top])*distance;
                }
                s.push(i);
            }    
        }
        return ans;
    }
};
</code></pre>
<p>题解四的思路就比较6了直接两面夹击，使用双指针进行比较，也是相当于直接把边界缩减到当前元素的两边</p>
<pre><code>class Solution {
public:
    int trap(vector&lt;int&gt;&amp; height) {
        int len = height.size();
        if(len==0||len==1||len==2){
            return 0;
        }
        
        int ans=0;
        int left_max=0;
        int right_max=0;
        auto left=height.begin(),right=height.end()-1;
        while(left&lt;right){
            if(*left&lt;*right)
                if(*left&gt;=left_max)
                    left_max=*left,++left;
                else
                    ans+= left_max-*left,++left;
            else
                if(*right&gt;=right_max)
                    right_max=*right,--right;
                else
                    ans+= right_max-*right,--right;
        
        }
        return ans;
    }
};
</code></pre>
<p>这几天状态比较差，但是今晚还是坚持下来了，感谢努力的自己！（没有打游戏hhh，当然也做题做得有点晚了没法去健身房，但是晚上回宿舍的路上真的很舒服啊！）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ 迭代器类型]]></title>
        <id>https://lixin-ee.github.io//post/c-die-dai-qi-lei-xing</id>
        <link href="https://lixin-ee.github.io//post/c-die-dai-qi-lei-xing">
        </link>
        <updated>2019-09-22T13:02:00.000Z</updated>
        <content type="html"><![CDATA[<p>最近复习c++primer的容器部分，经常要接触迭代器的操作，比如递增或者算术操作，但是根据STL源码剖析中提及的，不同性质的容器使用了不同的容器类型，其中五种迭代器又根据等级的不同，支持的操作也有所不同，所以整理了一篇文章，以备日后复习或者参考使用<br>
##1. 迭代器(iterator)是一中检查容器内元素并遍历元素的数据类型。<br>
(1) 每种容器类型都定义了自己的迭代器类型，如vector:<br>
<code>vector&lt;int&gt;::iterator iter;这条语句定义了一个名为iter的变量，它的数据类型是由vector&lt;int&gt;定义的iterator类型。</code><br>
(2) 使用迭代器读取vector中的每一个元素：</p>
<pre><code>vector&lt;int&gt; ivec(10,1);
for(vector&lt;int&gt;::iterator iter=ivec.begin();iter!=ivec.end();++iter)
{
*iter=2; //使用 * 访问迭代器所指向的元素
}
const_iterator:
只能读取容器中的元素，而不能修改。
for(vector&lt;int&gt;::const_iterator citer=ivec.begin();citer!=ivec.end();citer++)
{
cout&lt;&lt;*citer;
//*citer=3; error
}
vector&lt;int&gt;::const_iterator 和 const vector&lt;int&gt;::iterator的区别
const vector&lt;int&gt;::iterator newiter=ivec.begin();
*newiter=11; //可以修改指向容器的元素
//newiter++; //迭代器本身不能被修改 
</code></pre>
<p>(3) iterator的算术操作：<br>
iterator除了进行++,--操作，可以将iter+n,iter-n赋给一个新的iteraor对象。还可以使用一个iterator减去另外一个iterator.</p>
<pre><code>const vector&lt;int&gt;::iterator newiter=ivec.begin();
vector&lt;int&gt;::iterator newiter2=ivec.end();
cout&lt;&lt;&quot;\n&quot;&lt;&lt;newiter2-newiter; 
</code></pre>
<p>一個很典型使用vector的STL程式:</p>
<pre><code> #include &lt;vector&gt;
 #include &lt;iostream&gt;
 
 using namespace std;

 int main() {
 vector&lt;int&gt; ivec;
 ivec.push_back(1);
 ivec.push_back(2);
 ivec.push_back(3);
  ivec.push_back(4);
 
 for(vector&lt;int&gt;::iterator iter = ivec.begin();1. iter != ivec.end(); ++iter)
 cout &lt;&lt; *iter &lt;&lt; endl;
 }
</code></pre>
<p>##2. Iterator（迭代器）模式<br>
一、概述<br>
Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。<br>
由于Iterator模式的以上特性：与聚合对象耦合，在一定程度上限制了它的广泛运用，一般仅用于底层聚合支持类，如STL的list、vector、stack等容器类及ostream_iterator等扩展iterator。<br>
根据STL中的分类，iterator包括：<br>
Input Iterator：只能单步向前迭代元素，不允许修改由该类迭代器引用的元素。<br>
Output Iterator：该类迭代器和Input Iterator极其相似，也只能单步向前迭代元素，不同的是该类迭代器对元素只有写的权力。<br>
Forward Iterator：该类迭代器可以在一个正确的区间中进行读写操作，它拥有Input Iterator的所有特性，和Output Iterator的部分特性，以及单步向前迭代元素的能力。<br>
Bidirectional Iterator：该类迭代器是在Forward Iterator的基础上提供了单步向后迭代元素的能力。<br>
Random Access Iterator：该类迭代器能完成上面所有迭代器的工作，它自己独有的特性就是可以像指针那样进行算术计算，而不是仅仅只有单步向前或向后迭代。<br>
这五类迭代器的从属关系，如下图所示，其中箭头A→B表示，A是B的强化类型，这也说明了如果一个算法要求B，那么A也可以应用于其中。</p>
<p>input output<br>
\ /<br>
forward<br>
|<br>
bidirectional<br>
|<br>
random access<br>
图1、五种迭代器之间的关系<br>
vector 和deque提供的是RandomAccessIterator，list提供的是BidirectionalIterator，set和map提供的 iterators是 ForwardIterator，关于STL中iterator迭代器的操作如下：<br>
说明：每种迭代器均可进行包括表中前一种迭代器可进行的操作。<br>
迭代器操作                      说明<br>
(1)所有迭代器<br>
p++                              后置自增迭代器<br>
++p                              前置自增迭代器<br>
(2)输入迭代器<br>
*p                                 复引用迭代器，作为右值<br>
p=p1                             将一个迭代器赋给另一个迭代器<br>
p==p1                           比较迭代器的相等性<br>
p!=p1                            比较迭代器的不等性<br>
(3)输出迭代器<br>
*p                                 复引用迭代器，作为左值<br>
p=p1                             将一个迭代器赋给另一个迭代器<br>
(4)正向迭代器<br>
提供输入输出迭代器的所有功能<br>
(5)双向迭代器<br>
--p                                前置自减迭代器<br>
p--                                后置自减迭代器<br>
(6)随机迭代器<br>
p+=i                              将迭代器递增i位<br>
p-=i                               将迭代器递减i位<br>
p+i                                在p位加i位后的迭代器<br>
p-i                                 在p位减i位后的迭代器<br>
p[i]                                返回p位元素偏离i位的元素引用<br>
p&lt;p1                             如果迭代器p的位置在p1前，返回true，否则返回false<br>
p&lt;=p1                           p的位置在p1的前面或同一位置时返回true，否则返回false<br>
p&gt;p1                             如果迭代器p的位置在p1后，返回true，否则返回false<br>
p&gt;=p1                           p的位置在p1的后面或同一位置时返回true，否则返回false<br>
只有顺序容器和关联容器支持迭代器遍历，各容器支持的迭代器的类别如下：<br>
容器                 支持的迭代器类别            容器               支持的迭代器类别            容器                 支持的迭代器类别<br>
vector              随机访问                      deque              随机访问                       list                   双向<br>
set                   双向                            multiset            双向                           map                 双向<br>
multimap          双向                             stack                不支持                        queue              不支持<br>
priority_queue   不支持<br>
##二、结构<br>
Iterator模式的结构如下图所示：<br>
<img src="https://lixin-ee.github.io//post-images/1569157561984.JPG" alt=""><br>
图2、Iterator模式类图示意<br>
##三、应用<br>
Iterator模式有三个重要的作用：<br>
1）它支持以不同的方式遍历一个聚合.复杂的聚合可用多种方式进行遍历，如二叉树的遍历，可以采用前序、中序或后序遍历。迭代器模式使得改变遍历算法变得很容易: 仅需用一个不同的迭代器的实例代替原先的实例即可，你也可以自己定义迭代器的子类以支持新的遍历，或者可以在遍历中增加一些逻辑，如有条件的遍历等。<br>
2）迭代器简化了聚合的接口. 有了迭代器的遍历接口，聚合本身就不再需要类似的遍历接口了，这样就简化了聚合的接口。<br>
3）在同一个聚合上可以有多个遍历 每个迭代器保持它自己的遍历状态，因此你可以同时进行多个遍历。<br>
4）此外，Iterator模式可以为遍历不同的聚合结构（需拥有相同的基类）提供一个统一的接口，即支持多态迭代。<br>
简单说来，迭代器模式也是Delegate原则的一个应用，它将对集合进行遍历的功能封装成独立的Iterator，不但简化了集合的接口，也使得修改、增 加遍历方式变得简单。从这一点讲，该模式与Bridge模式、Strategy模式有一定的相似性，但Iterator模式所讨论的问题与集合密切相关， 造成在Iterator在实现上具有一定的特殊性，具体将在示例部分进行讨论。<br>
##四、优缺点<br>
正如前面所说，与集合密切相关，限制了 Iterator模式的广泛使用，就个人而言，我不大认同将Iterator作为模式提出的观点，但它又确实符合模式“经常出现的特定问题的解决方案”的 特质，以至于我又不得不承认它是个模式。在一般的底层集合支持类中，我们往往不愿“避轻就重”将集合设计成集合 + Iterator 的形式，而是将遍历的功能直接交由集合完成，以免犯了“过度设计”的诟病，但是，如果我们的集合类确实需要支持多种遍历方式（仅此一点仍不一定需要考虑 Iterator模式，直接交由集合完成往往更方便），或者，为了与系统提供或使用的其它机制，如STL算法，保持一致时，Iterator模式才值得考虑。<br>
##五、举例<br>
可以考虑使用两种方式来实现Iterator模式：内嵌类或者友元类。通常迭代类需访问集合类中的内部数据结构，为此，可在集合类中设置迭代类为friend class，但这不利于添加新的迭代类，因为需要修改集合类，添加friend class语句。也可以在抽象迭代类中定义protected型的存取集合类内部数据的函数，这样迭代子类就可以访问集合类数据了，这种方式比较容易添加新的迭代方式，但这种方式也存在明显的缺点：这些函数只能用于特定聚合类，并且，不可避免造成代码更加复杂。<br>
STL的list::iterator、deque::iterator、rbtree::iterator等采用的都是外部Iterator类的形式，虽然STL的集合类的iterator分散在各个集合类中，但由于各Iterator类具有相同的基类，保持了相同的对外的接口（包括一些traits及tags等，感兴趣者请认真阅读参考1、2），从而使得它们看起来仍然像一个整体，同时也使得应用algorithm成为可能。我们如果要扩展STL的iterator，也需要注意这一点，否则，我们扩展的iterator将可能无法应用于各algorithm。<br>
以下是一个遍历二叉树的Iterator的例子，为了方便支持多种遍历方式，并便于遍历方式的扩展，其中还使用了Strategy模式（见笔记21）：<br>
（注：1、虽然下面这个示例是本系列所有示例中花费我时间最多的一个，但我不得不承认，它非常不完善，感兴趣的朋友，可以考虑参考下面的参考材料将其补充完善，或提出宝贵改进意见。2、 我本想考虑将其封装成与STL风格一致的形式，使得我们遍历二叉树必须通过Iterator来进行，但由于二叉树在结构上较线性存储结构复杂，使访问必须 通过Iterator来进行，但这不可避免使得BinaryTree的访问变得异常麻烦，在具体应用中还需要认真考虑。3、以下只提供了Inorder&lt;中序&gt;遍历iterator的实现。）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第九章 笔记+习题 9.3]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-jiu-zhang-bi-ji-xi-ti-93</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-jiu-zhang-bi-ji-xi-ti-93">
        </link>
        <updated>2019-09-21T07:43:48.000Z</updated>
        <content type="html"><![CDATA[<p>9.3顺序容器操作<br>
顺序容器和关联容器的不同之处在于两者组织元素的方式<br>
9.3.1向顺序容器添加元素<br>
向一个vector、string、deque插入元素会使所有指向容器的迭代器、引用和指针失效（list则不会）<br>
当使用插入元素操作时，必须记得<strong>不同容器使用不同策略</strong>来分配元素空间，直接影响到程序性能<br>
当我们使用一个对象来初始化容器或插入到容器中，实际上放入的是<strong>对象值的拷贝而不是对象本身</strong><br>
string可以接受字符的push_back<br>
insert函数允许在容器的任意位置插入0个或多个元素<br>
vector、deque、string使用<strong>insert可能会很耗时</strong><br>
新标准下个数添加和范围添加的insert返回指向第一个新加入元素的迭代器，如果范围为空，insert返回第一个参数<br>
<strong>emplace将参数传递给元素类型的构造函数</strong>，在容器内存空间中直接构造元素，而不是push、insert等拷贝值<br>
emplace函数的参数根据元素类型而变化，参数必须与元素类型的构造函数相匹配</p>
<p>习题9.18</p>
<pre><code>int main() {
	string s;
	deque&lt;string&gt; ds;
	while (cin &gt;&gt; s)
		ds.push_back(s);
	for (const auto &amp;i : ds) 
		cout &lt;&lt; i &lt;&lt; endl;
}
</code></pre>
<p>习题9.19<br>
由于我用的是for范围语句，所以直接把deque改成list就好<br>
知识点：主要还是复习一下STL中list的迭代器和数据结构和元素操作<br>
习题9.20</p>
<pre><code>int main() {
	list&lt;int&gt; li{1,2,3,4,5,6,7,8,9,10};
	deque&lt;int&gt; even;
	deque&lt;int&gt; odd;
	for (const auto &amp;i : li) {
		if (i % 2)
			odd.push_back(i);
		else
			even.push_back(i);
	}
	for (auto i : odd)
		cout &lt;&lt; i &lt;&lt; endl;
	for (auto i : even)
		cout &lt;&lt; i &lt;&lt; endl;
}
</code></pre>
<p>习题9.21<br>
换成vector之后，实际效果也是等于头部插入，但是！list是双向指针，只需要改变相关指针指向的对象即可，vector就必须把后面的元素全部后移一位，必要的时候还必须申请新的空间把整个vector复制到新的内存空间中去。<br>
习题9.22<br>
注意insert插入的位置时给定iter的前面，返回的是新插入的元素的迭代器，所以这个程序会永远循环下去（就算中间的内容不执行），同时mid这个迭代器会失效</p>
<pre><code>int main() {
	vector&lt;int&gt; iv{1,2,3,4,5,6,7,8,9,10};
	vector&lt;int&gt;::iterator iter = iv.begin(), mid = iv.begin() + iv.size() / 2;
	int val;
	while (iter != mid) {
		if (*mid == val) {
			iv.insert(mid, 2 * val);
			break;
		}
		else
			--mid;
	}
}
</code></pre>
<p>9.3.2访问元素<br>
访问成员函数（front、back、下标[ ]和at( )）<strong>返回的都是引用</strong>，如果容器是const就返回const引用<br>
但是！<strong>如果使用auto保存返回值时，需要将标量定义为引用类型，否则就获得指向最后一个元素的引用</strong>！ auto &amp;v = c.back()； auto v = c.back(); 前者获得引用后者获得拷贝<br>
编译器并不检查下标范围错误<br>
at成员函数 如果下标越界，at会抛出一个out_of_range异常</p>
<p>习题9.23<br>
四者皆为第一个元素<br>
<strong>注意区分 begin end front back</strong><br>
习题9.24</p>
<pre><code>int main() {
	vector&lt;int&gt; iv;
	//int i1 = iv.at(0);//通过编译，但是运行会报错，显示abort被调用
	//int i2 = iv[0];//运行会报错，显示out of range
	//int i3 = iv.front();//显示 vector iterator not dereferenable
	//int i4 = *iv.begin();//显示 vector iterator not dereferenable
}
</code></pre>
<p>9.3.3删除元素<br>
注意<strong>pop也会执行destroy的删除操作</strong><br>
在erase(b,e)中，e指向我们要删除的最后一个元素之后的位置<br>
<strong>上述操作皆会使非相关迭代器失效，但与insert并不完全一致，具体看表9.7</strong><br>
注意erase的迭代器对是同一对迭代器的时候，其实啥都不会发生。迭代器不相等时，注意是<strong>左闭右开的区间</strong>，比如想要删除所有元素，应该使用erase(v.begin().v.end())，而不是v.end()-1</p>
<p>习题9.25</p>
<pre><code>int main() {
	vector&lt;int&gt; iv{1,2,3,4,5};
	auto i1 = iv.begin(),i2=iv.begin();
	iv.erase(i1, i2);
	cout &lt;&lt; *iv.begin() &lt;&lt; endl;
	auto i3 = iv.end(), i4 = iv.end();
	iv.erase(i3, i4);
	cout &lt;&lt; iv.back() &lt;&lt; endl;
}
</code></pre>
<p>注意erase的迭代器对是同一对迭代器的时候，其实啥都不会发生.迭代器不相等时，注意是左闭右开的区间，比如想要删除所有元素，应该使用erase(v.begin().v.end())，而不是v.end()-1<br>
习题9.26</p>
<pre><code>int main() {
	int ia[] = { 0,1,1,2,3,5,8,13,21,55,89 };
	vector&lt;int&gt; iv(begin(ia),end(ia));
	list&lt;int&gt; il(begin(ia), end(ia));
	auto i = iv.begin();
	while (i != iv.end())
		if (!(*i % 2))
			i = iv.erase(i);
		else
			++i;
	for (auto x : iv)
		cout &lt;&lt; x &lt;&lt; endl;
	auto i1 = il.begin();
	while (i1 != il.end())
		if (*i1 % 2)
			i1 = il.erase(i1);
		else
			++i1;
	for (auto x : il)
		cout &lt;&lt; x &lt;&lt; endl;
}
</code></pre>
<p>知识点：list和vector等容器都可以直接用数组的指针对来初始化<code>vector&lt;int&gt; iv(begin(ia),end(ia));</code>，同时注意！！！，取反符号！的优先级特别低，比取模符号%的优先级低，所以要加括号</p>
<p>9.3.4特殊的forward_list操作<br>
删除或添加元素需要访问前驱并改变前驱的链接，单向链表没有方法获取一个元素的前驱<br>
所以forward_list删除添加元素需要通过改变给定元素之后的元素来完成，<br>
forward_list定义了before_begin 返回一个<strong>首前迭代器</strong>，这个迭代器允许我们在链表首元素之前并不存在的元素“之后”（也就是链首）添加删除元素</p>
<p>习题9.27</p>
<pre><code>int main() {
	vector&lt;int&gt; iv{ 0,1,1,2,3,5,8,13,21,55,89 };
	forward_list&lt;int&gt; fli(iv.begin(), iv.end());
	for (auto i = fli.begin(), i2 = fli.before_begin(); i != fli.end();) {
		if (*i % 2)
			i = fli.erase_after(i2);
		else
			++i, ++i2;
	}
	for (auto i : fli)
		cout &lt;&lt; i &lt;&lt; endl;	
}
</code></pre>
<p>知识点：forward_list的erase删除的是指定位置的后一个元素，返回的是删除元素的后一个元素的迭代器，所以所以需要两个迭代器合作才能做到删除特定元素，同时要注意这对迭代器的初始化、递增和赋值操作。例如需要i2 = fli.before_begin()<br>
才能删除首元素<br>
习题9.28</p>
<pre><code>int main() {
	forward_list&lt;string&gt; fli{&quot;123&quot;,&quot;456&quot;,&quot;789&quot;};
	string s1 = &quot;2887&quot;,s2 = &quot;2887&quot;;
	flist_i(fli, s1, s2);
	for (auto s : fli)
		cout &lt;&lt; s &lt;&lt; endl;
}

void flist_i(forward_list&lt;string&gt; &amp;fs, string s1, string s2) {
	for (auto i = fs.begin(); i != fs.end();) {
		auto i2 = i;
		if (*i == s1) {
			fs.insert_after(i, s2);
			return;
		}
		else
			++i;
		if (i == fs.end())
			fs.insert_after(i2, s2);
	}
	return;
}
</code></pre>
<p>知识点：还是老样子，必须注意如果迭代器i去到了end之后，就没法在链表末尾插入了（因为必须要末尾的前一个元素才能调用insert_after），同时forward_list是Forward Iterator，没法进行算术操作（注意，也没法--）。所以需要额外的迭代器进行递增</p>
<p>9.3.5改变容器大小<br>
resize 如果当前大小大于要求大小，将会删除容器后部的元素会被删除；如果小于要求大小，会将新元素添加容器后部，resize有一个可选的元素值参数，用于初始化添加到容器的元素**（但只有一个！）**如果未提供则会进行值初始化<br>
resize如果缩小容器，被删除元素的迭代器、引用和指针都会失效</p>
<p>习题9.29<br>
把vec的size()变为100个，同时进行值初始化，然后会变小，11-25的元素全部被删除。<br>
习题9.30<br>
必须能够进行值初始化或者有自己的默认构造函数</p>
<p>9.3.6容器操作可能使迭代器失效<br>
每次改变容器后都需要正确地重新定位迭代器，特别是vector、string、deque<br>
insert和erase都返回迭代器，可以用于更新迭代器，erase返回迭代器指向序列的下一个元素，inset返回指向新插入元素的迭代器<br>
1.添加或删除vector或string的元素2.或在deque首元素之外的位置删除添加元素 都会使得end返回的迭代器失效，所以不要在上面两种情况下缓存end返回的迭代器<br>
多使用v.end()而不是缓存end</p>
<p>习题9.31<br>
list是bidiretional iterator，forwaid_list是forward iterator，两者的迭代器都无法支持算术操作+=，只能进行递增操作</p>
<pre><code>int main() {
	//list&lt;int&gt; li = { 1,2,3,4,5,6,7,8 }; 
	/*auto iter = li.begin();
	while (iter != li.end()) {
		if (*iter % 2) {
			iter = li.insert(iter, *iter);
			advance(iter, 2);
		}
		else
		{
			iter = li.erase(iter);
		}
	}*/
	forward_list&lt;int&gt; li = { 1,2,3,4,5,6,7,8 };
	auto iter = li.begin();
	auto iter2 = li.before_begin();
	while (iter != li.end()) {
		if (*iter % 2) {
			iter = li.insert_after(iter, *iter);
			advance(iter, 1);
			advance(iter2, 2);
		}
		else
		{
			iter = li.erase_after(iter2);
		}
	}
} 
</code></pre>
<p>知识点，迭代器的前进可以使用advance！适用于list和slist的情况<br>
习题9.32<br>
不合法，*和++之间的的等级++比较高，这样子会把iter先递增，如果此时iter处于最后一个元素或者尾后迭代器，对iter进行递增会引发错误报告<br>
习题9.33<br>
begin会失效，不返回的话继续使用begin等于使用一个野指针<br>
习题9.34<br>
注意++iter在while循环外面了，等于无限循环了，作者的本意是想遇到vi中的奇数就复制一遍，遇到偶数跳过</p>
<p>9.4 vector对象是如何增长的<br>
vector和string是连续存储的，不能将新元素随意添加到内存的其他位置<br>
vector和string获取新内存空间时会分配比新的空间需求更大的内存空间作为备用<br>
reserve仅处理需求大于当前容量的请求，小于等于的不做任何操作<br>
shrink_to_fit可以选择忽略缩小空间请求，不一定退回内存空间<br>
capacity的值取决于标准库的实现<br>
只要没有操作需求超出了vector的容量，就不能重新分配内存空间（只有当迫不得已的时候才可以分配新的内存空间）<br>
遵循一个原则：确保添加元素的高效率保持在n的常数倍<br>
<strong>resize（）是元素个数，而不是直接影响capacity，只有capacity小于resize的大小才会增加</strong></p>
<p>习题9.35<br>
size是用户添加的元素数量，capacity是vector目前占有的空间的内存大小，也就是可以容纳的元素的最大数量<br>
习题9.36<br>
不可能<br>
习题9.37<br>
list是使用指针来存储前后元素的位置，不需要在内存连续存储，所以可以任意增长，array是一旦声明定义的时候就必须指定大小值，size和capacity是一样的，永远不会变化的。<br>
习题9.38<br>
STL源码剖析的分析应该是以2的次幂来增长的（但是我自己实测VS2015是1.5倍，有点尴尬）<br>
习题9.39<br>
首先分配了至少能容纳1024个元素的<code>vector&lt;string&gt;</code>，然后进行插入，插入完成后将size()大小修改为当前元素个数的1.5倍<br>
<strong>注意！！！resize（）是元素个数，而不是直接影响capacity，只有capacity小于resize的大小才会增加</strong><br>
习题9.40<br>
前两个都是resize小于capacity，都是1000，1000个的时候变成1500，1048视情况而定</p>
<p>9.5额外的string操作<br>
9.5.1构造string的其他方法<br>
从一个const char*创建string，指针指向的数组必须以空字符结尾，拷贝操作遇到空字符时停止<br>
如果给构造函数传递一个计数值，数组就不必以空字符结尾<br>
substr操作<br>
s.substr(pos,n) 返回一个string，包含s中从pos开始的n个字符的拷贝，pos默认值为0，n的默认值为s.size()-pos<br>
如果开始位置超过string的大小，则substr函数抛出一个out_of_range异常</p>
<p>习题9.41</p>
<pre><code>int main() {
	vector&lt;char&gt; c{'h','a','l','l','o'};
	string s(c.begin(),c.end());
	for (auto i : c) {
		s.push_back(i);
	}
}
</code></pre>
<p>习题9.42<br>
先读入ostringstream中保存再一次过读入string</p>
<p>习题感悟 注意区分 begin end front back<br>
注意erase的迭代器对是同一对迭代器的时候，其实啥都不会发生。迭代器不相等时，注意是左闭右开的区间，比如想要删除所有元素，应该使用erase(v.begin().v.end())，而不是v.end()-1<br>
list和vector等容器都可以直接用数组的指针对来初始化<code>vector&lt;int&gt; iv(begin(ia),end(ia));</code><br>
同时注意！！！，取反符号！的优先级特别低，比取模符号%的优先级低，所以要加括号<br>
forward_list的erase删除的是指定位置的后一个元素，返回的是删除元素的后一个元素的迭代器，所以所以需要两个迭代器合作才能做到删除特定元素，同时要注意这对迭代器的初始化、递增和赋值操作。例如需要i2 = fli.before_begin()<br>
才能删除首元素<br>
必须注意如果迭代器i去到了end之后，就没法在链表末尾插入了（因为必须要末尾的前一个元素才能调用insert_after），同时forward_list是Forward Iterator，没法进行算术操作（注意，也没法--）。所以需要额外的迭代器进行递增<br>
迭代器的前进可以使用advance！适用于list和slist的情况<br>
注意！！！resize（）是元素个数，而不是直接影响capacity，只有capacity小于resize的大小才会增加</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++引用的本质]]></title>
        <id>https://lixin-ee.github.io//post/cyin-yong-de-ben-zhi</id>
        <link href="https://lixin-ee.github.io//post/cyin-yong-de-ben-zhi">
        </link>
        <updated>2019-09-21T07:35:00.000Z</updated>
        <content type="html"><![CDATA[<p>最近逛博客的时候突然对引用这个东西产生了疑惑，引用的性质学了一大堆，还挺好用的，可是它的性质确实非常奇怪，首先不是个对象，vector等容器是不可以存引用，C数组也8行。其次它的性质也表现得像个对象，它一声明定义就必须初始化，初始化过后就等于绑定对象的别名。整体来说引用就相当于一个幽灵，看得到却摸不着，所以去搜了一下文章，找到一篇还不错的博文，可惜找不到原文了，所以图全部丢了，但是结论什么的还是很直观的。<br>
原文   http://blog.csdn.net/zsp_skyer/article/details/20069993（已经404）<br>
一、背景：<br>
当前很多文章或书籍中都说：<br>
1、“引用 ”是一个别名，作为目标的别名使用。<br>
2、“引用”不是值，不占用存储空间。<br>
3、“引用”只有声明，没有定义。<br>
4、证实对以上说法的一段常见代码和输出结果：<br>
上图代码输出结果：</p>
<p>从以上图可以看出，变量 b 作为对变量 a 的引用确实是像极了别名，以上图，从传统的 C++ 编程角度来看确实没有什么错，取地址的就取地址，取值的就取值，没什么特别的，感觉很舒服，完全就是别名的含义，于是乎，很多人就将上面的几点作为对引用的认识了（包括我自己）。</p>
<p>二、问题提出：<br>
我们知道函数传递参数无非就有两种：按值传参和按址传参，可能还有另外一种：经常听别人说的按引用传参。对于按值传参我们都知道是将实参的拷贝进行传递，被调用函数无法改变实参的值；按址传递是将实参的地址进行传递，可以改变实参的值。但别人又说按引用传递也可以改变实参的值，看来还真的可能还有按引用传递这种传参方式。请看下图：</p>
<p>上图代码输出结果：</p>
<p>从上图可以看出，按引用确实可以改变实参的值，这时候又有人喊了，按引用传参其实就是按址传参，我靠，说的罗里吧嗦的，那么现在的问题是：<br>
1、引用真的只是目标的一个别名吗？<br>
2、引用真的不占用内存空间吗？<br>
3、引用自身的值真的是目标自身的值吗？</p>
<p>三、问题分析：<br>
1、引用真的只是目标的一个别名吗？（如果是，你它有什么能力改变实参？如果不是，那引用到底是什么？）<br>
2、引用真的不占用内存空间吗？（如果占用，它肯定有内存地址，那这地址是什么？）<br>
3、引用自身的值真的是目标自身的值吗？ （如果不是，那引用自身的值是什么？）</p>
<p>四、问题验证：<br>
我们就针对上面的问题从汇编的角度看引用，还是使用上面的交换 a, b 值的代码。<br>
1、</p>
<p>调用 exchange 函数时上图中内存 a 的地址为：0x001ff7e0，内存 b 的地址为：0x001ff7d4 ；内存 a 中的值为：5，内存 b 中的值为：0Ah（即是10）。很明显，上图是把 a 和 b 的地址压栈了。<br>
2、</p>
<p>进入 exchange 函数中，此时调试观察到内存 first 中的值为：0x001ff7e0，内存 second 中的值为：0x001ff7d4，此时很明显了，结合上面的那点，内存 first 中的值其实就是内存 a 的地址：0x001ff7e0，不是内存 a 中的值：5；内存 second 中的值其实就是内存 b 的地址：0x001ff7d4，不是内存 b 中的值：10。也就是说 exchange 函数中，形参 first 和 second 作为对实参 a 和 b 的引用，接收的真正内容是实参 a 和 b 的内存地址 0x001ff7e0和 0x001ff7d4，而不是实参 a 和 b 的值 5 和 10。到这里问题提出中的三点就不攻自破了。所以引用不只是目标的别名这么简单，它有占内存空间，它有值，它的值其实就是目标的地址。既然它有占内存空间那它自身的地址是什么呢？我们在源码中写个汇编取它自身的地址看看：</p>
<p>调试观察到内存 first 的地址为：0x001ff6fc，内存 second 的地址为：0x001ff700</p>
<p>五、结论：<br>
综上所述，作为对目标 a 和 b 的引用 first 和 second，它们占用内存空间，自身的值就是目标 a 和 b 的内存地址， 也就是说它们的值是地址类型，聪明你们联想到什么了没？哈哈，没错，就是指针，也就是说，引用的本质就是指针，准确的说是一个常量指针（这个指针和其他指针的区别就是这个指针被规定指向了哪个目标，并且不能被修改；其他指针可以指向任何目标），引用这个东西其实是编译器对常量指针的包装修饰后，提供给你的一个工具而已。开头的代码片段中的【int a; int &amp;b = a;】将会被编译器转化成【int *const b = &amp;a;】，语句【cout &lt;&lt; &quot;变量 b 的内存地址为：&quot; &lt;&lt; &amp;b &lt;&lt; endl;】将被解析成【cout &lt;&lt; &quot;变量 b 的内存地址为：&quot; &lt;&lt; &amp;*b &lt;&lt; endl;】这就是当我们打印普通变量和引用变量的时候会输出相同地址的原因。所以就不难解析引用必须要初始化是因为 const 类型变量必须初始化，而这个指针也必须有所指；也不难解析按引用传参，其实就是按址传参；也不难解析对引用的操作，其实就是对目标的操作了。</p>
<p>下面将文章开头的代码段中的引用替换成常量指针后的效果：</p>
<p>上图代码输出结果：</p>
<p>怎么样？和开头的代码效果一样吧？所以最终一句话概括：“引用”就是 C++ 中的常量指针！</p>
<p>注意：本人能力有限，如有错漏，欢迎指正提出！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 11. 盛最多水的容器]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-11-sheng-zui-duo-shui-de-rong-qi</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-11-sheng-zui-duo-shui-de-rong-qi">
        </link>
        <updated>2019-09-21T03:43:25.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>
说明：你不能倾斜容器，且 n 的值至少为 2。<br>
图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。<br>
示例:<br>
输入: [1,8,6,2,5,4,8,3,7]<br>
输出: 49</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/container-with-most-water<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>今天这题算是没做出来吧，前期有三个想法，但是各自有不同的困惑所以没实现（1）想从前向后遍历的时候很难确定什么时候应该更改第一个值（2）使用哈希表或者另外一个数组的存储一对值的话又需要进行排序（3）从中间开始的话向两边扩张不知道应该移动哪一边，所以最后用了暴力解法直接o(n^2)来判断每一对值得长度，太暴力了我就不贴出来了hhh，不浪费时间钻牛角尖了直接看官方题解吧：</p>
<blockquote>
<p>摘要<br>
如题意，垂直的两条线段将会与坐标轴构成一个矩形区域，较短线段的长度将会作为矩形区域的宽度，两线间距将会作为矩形区域的长度，而我们必须最大化该矩形区域的面积。<br>
方法二：双指针法<br>
算法<br>
这种方法背后的思路在于，两线段之间形成的区域总是会受到其中较短那条长度的限制。此外，两线段距离越远，得到的面积就越大。<br>
我们在由线段长度构成的数组中使用两个指针，一个放在开始，一个置于末尾。 此外，我们会使用变量 maxarea 来持续存储到目前为止所获得的最大面积。 在每一步中，我们会找出指针所指向的两条线段形成的区域，更新 maxarea，并将指向较短线段的指针向较长线段那端移动一步。<br>
这种方法如何工作？<br>
最初我们考虑由最外围两条线段构成的区域。现在，为了使面积最大化，我们需要考虑更长的两条线段之间的区域。如果我们试图将指向较长线段的指针向内侧移动，矩形区域的面积将受限于较短的线段而不会获得任何增加。但是，在同样的条件下，移动指向较短线段的指针尽管造成了矩形宽度的减小，但却可能会有助于面积的增大。因为移动较短线段的指针会得到一条相对较长的线段，这可以克服由宽度减小而引起的面积减小。</p>
</blockquote>
<pre><code> Java
 public class Solution {
     public int maxArea(int[] height) {
         int maxarea = 0, l = 0, r = height.length - 1;
         while (l &lt; r) {
             maxarea = Math.max(maxarea, Math.min(height[l], height[r]) * (r - l));
             if (height[l] &lt; height[r])
                 l++;
             else
                 r--;
         }
         return maxarea;
			}
 }
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)，一次扫描。<br>
空间复杂度：O(1)，使用恒定的空间。</p>
</blockquote>
<p>题解一就不说了，题解二非常精妙，又是一种“哇原来还可以这么做的感觉！”，其实代码过程非常简单，但是这道题的难度是中等，和我之前从中间向两边的思路存在的疑惑一样，我觉得主要的问题就在指针的移动选择，到底应该符合什么条件才能经过所有可能的更大值呢，重要的就在于移动最小值的证明。题解中已经把表象说得比较明白了，只有移动较短的那一条才能更有可能地获得更大值，然后更猛的来了，有数学大神贴出了数学证明<br>
由于博客难以贴出数学公式，具体可以查看链接：</p>
<blockquote>
<p>作者：r3n4ive<br>
链接：https://leetcode-cn.com/problems/container-with-most-water/solution/shuang-zhi-zhen-fa-zheng-que-xing-zheng-ming-by-r3/<br>
来源：力扣（LeetCode）<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<p>所以最后的代码为：</p>
<pre><code>class Solution {
public:
    int maxArea(vector&lt;int&gt;&amp; height) {
        int len = height.size();
        if(len==0||len==1)
            return 0;
        auto left=height.begin();
        auto right=height.end()-1;
        int maxArea=0;
        while(left!=right){
            if(*right&gt;*left)
                maxArea= maxArea&gt;(*left)*(right-left)?maxArea:(*left)*(right-left),++left;
            else
                maxArea= maxArea&gt;(*right)*(right-left)?maxArea:(*right)*(right-left),--right;
        }
        return maxArea;
    }
};
</code></pre>
<p>其实过程中还是有一丢丢波折，比如搞混了什么时候该用left什么时候该用right，都是很细微的错误hhh，所以还是得细心细心再细心！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第九章 笔记+习题 9.1-9.2]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-jiu-zhang-bi-ji-xi-ti-91-93</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-jiu-zhang-bi-ji-xi-ti-91-93">
        </link>
        <updated>2019-09-20T01:34:24.000Z</updated>
        <content type="html"><![CDATA[<p>9顺序容器<br>
顺序容器 不依赖于元素的值，而是与元素加入容器时的位置相对应<br>
顺序容器是可序的，但是不一定是有序的，同时在内存中不一定是连续排列的<br>
9.1顺序容器概述<br>
顺序容器在两个方面有不同的折中 1.添加和删除元素的代价 2.非顺序访问容器中元素的代价<br>
string和vector将元素<strong>保存在连续的内存空间</strong>中，可以用下标快速访问，但是在中间位置添加或删除元素非常耗时<br>
list和forward_list在<strong>任何位置添加删除元素都很快速</strong>，但是<strong>不支持随机访问</strong>，只能遍历整个容器来访问元素，而且额外内存开销很大<br>
deque支持快速随机访问，<strong>在中间位置添加删除元素代价高</strong>，但在两端添加删除元素快<br>
array对象大小固定，不支持添加删除元素或该表容器大小<br>
<strong>forward_list没有size操作</strong>， 达到与最好的手写的单向链表数据结构相当的性能<br>
应用中占主导地位的操作（访问操作or插入/删除元素）决定了容器类型的选择</p>
<p>习题9.1<br>
（a）list 因为需要排序，可能在任意位置进行元素的增删<br>
（b）deque，注意vector是无法在头部直接删除的<br>
（c）暂时选择vector 因为增删操作不是很明显</p>
<p>9.2容器库概览<br>
每个容器都定义在一个头文件中，<strong>文件名与类型名相同</strong><br>
<strong>容器均定义为模板类</strong><br>
顺序容器几乎可以保存任意类型的元素，<strong>包括以容器作为元素类型</strong></p>
<p>习题9.2<br>
<code>list&lt;deque&lt;int&gt;&gt; l;</code></p>
<p>9.2.1迭代器<br>
forward_list迭代器<strong>不支持递减运算符（forward iterator，不是bidiretional iterator）</strong><br>
迭代器<strong>算术运算</strong>，只能应用于string vector deque和array迭代器（<strong>random acess iterator</strong>）<br>
<strong>注意！只有random acess iterator 支持小于&lt; 大于&gt;等关系符</strong><br>
end迭代器不会指向范围中的最后一个元素，而是指向尾元素之后的位置<br>
迭代器begin和end必须指向相同的容器，可以指向相同的位置（此时容器为空），<strong>但不能指向begin之前的位置</strong><br>
可以通过直接检测begin==end是否为真来确定范围是否为空</p>
<p>习题9.3<br>
1.指向同一个容器或者是尾元素之后的位置 ，begin可以反复递增达到end<br>
2.end指向尾后迭代位置，并且begin不能在end后面<br>
习题9.4</p>
<pre><code>int main() {
	vector&lt;int&gt; v{ 1,2,3,4,5,6,7,8,9,10 };
	int i;
	cin &gt;&gt; i;
	cout &lt;&lt; Search(v.begin(), v.end(), i) &lt;&lt; endl;
}
bool Search(vector&lt;int&gt;::iterator&amp; beg, vector&lt;int&gt;::iterator&amp; end, int i) {
	while (beg != end)
		if (*beg == i) {
			return true;
		}
		else
			++beg;
	return false;
}
</code></pre>
<p>习题9.5</p>
<pre><code>int main() {
	vector&lt;int&gt; v{ 1,2,3,4,5,6,7,8,9,10 };
	int i;
	cin &gt;&gt; i;
	auto it = Search(v.begin(), v.end(), i);
	if (it != v.end())
		cout &lt;&lt; *it &lt;&lt; endl;
	else
		cout &lt;&lt; &quot;i is not found&quot; &lt;&lt; endl;
}

vector&lt;int&gt;::iterator&amp; Search(vector&lt;int&gt;::iterator&amp; beg, vector&lt;int&gt;::iterator&amp; end, int i) {
	while (beg != end)
		if (*beg == i) {
			return beg;
		}
		else
			++beg;
	return end;
}
</code></pre>
<p>习题9.6<br>
注意！只有random acess iterator 支持小于&lt; 大于&gt;等关系符，list仅仅是双向迭代器bidiretional iterator，所以是无法使用小于的</p>
<p>9.2.2容器类型成员<br>
反向迭代器就是反向遍历容器的迭代器，<strong>各种操作的含义发生了颠倒（递增递减也是，递增会变成向前移动，得到上一个元素）</strong><br>
通过类型别名，我们可以在不了解容器中元素类型的情况下使用它，比如value_type reference，在STL源码剖析中可以看到内部定义了这个类型别名，可以直接用，但是需要显式加上作用域<br>
使用类型别名时需要显式使用其【类名】 比如<code>vector&lt;int&gt;::iterator i;// vector&lt;int&gt;是很重要的显式类名，特别是int</code></p>
<p>习题9.7<br>
<code>vector&lt;int&gt;::iterator i;</code><br>
习题9.8<br>
<code>list&lt;string&gt;::const_iterator 和list&lt;string&gt;::iterator</code></p>
<p>9.2.3begin和end成员<br>
带r的版本返回反向迭代器<br>
以c开头的版本则返回const迭代器<br>
<strong>不以c开头的函数都是被重载过的</strong>，也就是实际上有两个名为begin的成员，一个是const成员，返回const_itrerator;一个是非常量成员，返回iterator<br>
可以将iterator转换成const_iterator 反之则不行<br>
以c开头的版本用于支持auto与迭代器函数结合使用 auto it = a.cbegin();//强制获得const迭代器<br>
当auto与迭代器函数结合使用时，获得的迭代器类型依赖于容器类型，但cbegin和cend可以强行获得const版本<br>
auto it = a.begin(); 仅当a是const时，it是const_iterator的<br>
<strong>注意：<code>vector&lt;int&gt;::const_iterator</code>和cbegin()的const是low-level const，可以递增iterator不能递增所指向的值</strong></p>
<p>习题9.9<br>
一个根据容器的const与否返回相应的迭代器，另一个强制返回const迭代器<br>
习题9.10<br>
根据上一题</p>
<pre><code>it1 vector&lt;int&gt;::iterator 
it2 vector&lt;int&gt;::const_iterator
it3 vector&lt;int&gt;::const_iterator
it4 vector&lt;int&gt;::const_iterator
</code></pre>
<p>注意：<code>vector&lt;int&gt;::const_iterator和cbegin()的const</code>是low-level const，可以递增iterator不能递增所指向的值</p>
<p>9.2.4容器定义和初始化<br>
除array外，其他容器的默认构造函数都会创建一个指定类型的空容器，且都可以接受指定容器大小和元素初始值的参数（array必须指定大小，但是注意和c数组是不一样的，例如array&lt;int, 5&gt; a;）<br>
注意相同和相容的区别<br>
将一个容器拷贝为新容器的方法1.直接拷贝整个容器2.拷贝迭代器指定的元素范围<br>
直接拷贝时，容器类型和元素类型必须匹配<br>
迭代器范围拷贝时不要求容器类型和元素类型完全相同，只要拷贝的元素能够转换类型<br>
新标准中允许对容器进行列表初始化<br>
定义array时除了指定元素类型，还要指定容器大小 array&lt;string,10&gt;;//保存10个string数组<br>
为了使用array类型，必须同时指定元素类型和大小 array&lt;int,10&gt;::size_type i;<br>
由于大小是array类型的一部分，所以array不支持普通的容器构造函数<br>
默认构造的array是非空的，如果我们对array进行列表初始化，初始值的数目必须等于或小于array的大小<br>
如果array的元素类型是一个类类型，则该类必须有一个默认构造函数，以使初始化能够进行<br>
<strong>array可以进行拷贝或对象赋值操作，内置数组类型则不能</strong></p>
<p>习题9.11</p>
<pre><code>vector&lt;int&gt; v;

vector&lt;int&gt; v(v2);
vector&lt;int&gt; v=v2;

vector&lt;int&gt; v{1,2,3,4,5,6};

vector&lt;int&gt; v(v2.begin(),v2.end());

vector&lt;int&gt; v(10);

vector&lt;int&gt; v(10,0);
</code></pre>
<p>习题9.12<br>
前者由于是值直接拷贝必须类型相同，后者使用迭代器的话，不需要知道迭代器的容器的类型，所以只需要类型相容即可。<br>
习题9.13</p>
<pre><code>int main() {
	vector&lt;int&gt; v{ 1,2,3,4,5,6,7,8,9,10 };
	list&lt;int&gt; v1{ 1,2,3,4,5,6,7,8,9,10 };
	int i;
	cin &gt;&gt; i;
	vector&lt;double&gt; v2(v.begin(),v.end());
	vector&lt;double&gt; v3(v1.begin(), v1.end());
}
</code></pre>
<p>9.2.5赋值和swap<br>
所有容器都可用赋值运算<br>
如果两个容器原来大小不同，赋值运算后左边大小等于右边大小（但类型必须相同）（容器赋值操作会影响大小）<br>
array允许赋值，但左右两边的运算对象必须具有相同的类型(包括大小)<br>
array不支持assign，也不允许用花括号包围的值列表进行列表赋值（但是可以列表初始化！）注意区分赋值和初始化</p>
<p>assign 顺序容器，从一个不同但相容的类型赋值（例如用vector的char*赋予一个list中的string），或者从容器的一个子序列赋值<br>
array 使用swap必须大小相同<br>
除array以外，交换两个容器内容的操作保证会很快，swap并不对任何元素进行拷贝、删除或插入操作，只是交换两个容器的内部数据结构，保证在常数时间内完成（只是交换了指针，而没有交换元素的值。array则是地址不变，改变值）例如</p>
<pre><code>vector&lt;int&gt; v{ 1 };
	vector&lt;int&gt; v1{ 0 };
	auto i = v.begin();
	swap(v, v1);
	cout &lt;&lt; *i &lt;&lt; endl;//返回1
	cout &lt;&lt; *v.begin()&lt;&lt;endl;//返回0
	cout &lt;&lt; (i == v1.begin()) &lt;&lt; endl;//返回1（true）
</code></pre>
<p>除string外，swap操作不会使指向容器的迭代器、引用和指针失效，仍指向swap操作之前所指向的那些元素，但是这些元素已经属于不同容器了（string调用swap则会导致迭代器引用指针失效）<br>
swap两个array会真正交换它们的元素，但指针、引用和迭代器等不变</p>
<p>习题9.14</p>
<pre><code>int main() {
	list&lt;char*&gt; c{ &quot;abcd&quot; };
	vector&lt;string&gt; vs;
	vs.assign(c.begin(),c.end());
	cout &lt;&lt; *vs.begin() &lt;&lt; endl;
}
</code></pre>
<p>注意，赋值和初始化是不一样的，可以用assign来赋值，但是如果是迭代器必须用一对迭代器<br>
<code>*v.begin()</code>是正确的！！！<code>*vs.empty()</code> 才是错误的，调用符的优先级比解引用符高，但是v.begin返回一个迭代器（vector的甚至就是一个指针），所以是正确的</p>
<p>9.2.6容器大小操作<br>
size()返回容器中元素的数目<br>
empty当size为0时返回布尔值true,否则返回false；<br>
max_size返回一个大于或等于该类型容器所能容纳的最大元素数的值。<br>
forward_list支持max_size和empty,但不支持size<br>
9.2.7关系运算符<br>
每个容器类型都支持相等运算符（=和!=);<br>
除了无序关联容器外的所有容器都支持关系运算符（&gt;、&gt;=、&lt;、&lt;=)。<br>
关系运算符左右两边的运算对象必须是相同类型的容器，<br>
且必须保存相同类型的元素。<br>
•如果两个容器具有相同大小直所有元素都两两对应相等，则这两个容器相等；否则<br>
两个容器不等。<br>
•如果两个容器大小不同，但较小容器中每个元素都等于较大容器中的对应元素，则<br>
较小容器小于较大容器。<br>
•如果两个容器都不是另一个容器的前缀子序列，则它们的比较结果取决于第一个不<br>
相等的元素的比较结果。<br>
只有当其元素类型也定义了相应的比较运算符时，我们才可以使用关系运算符来比较两个容器。<br>
容器的相等运算符实际上是使用元素的==运算符实现比较的，而其他关系运算符是使用元素的&lt;运算符。</p>
<p>习题9.15<br>
非常简单 直接== 可以参考下一题<br>
习题9.16<br>
可以把list拷贝到另外一个vector里面</p>
<pre><code>int main() {
	list&lt;int&gt; li{ 1,2,3,4,5,6 };
	vector&lt;int&gt; vi{ 1,2,3,4,5,6 };
	vector&lt;int&gt; vl;
	vl.assign(li.begin(), li.end());
	if (vl == vi)
		cout &lt;&lt; &quot;666&quot; &lt;&lt; endl;
	else
		cout &lt;&lt; &quot;8xing&quot; &lt;&lt; endl;
}
</code></pre>
<p>习题9.17<br>
c1 c2必须支持关系运算符 同时容器类型和包含元素的类型必须相同</p>
<p>习题感悟<br>
注意！只有random acess iterator 支持小于&lt; 大于&gt;等关系符<br>
注意：<code>vector&lt;int&gt;::const_iterator和cbegin()的const</code>是low-level const，可以递增iterator不能递增所指向的值<br>
前者由于是值直接拷贝必须类型相同，后者使用迭代器的话，不需要知道迭代器的容器的类型，所以只需要类型相容即可。<br>
<code>*v.begin()</code>是正确的！！！<code>*vs.empty()</code> 才是错误的，调用符的优先级比解引用符高，但是v.begin返回一个迭代器（vector的甚至就是一个指针），所以是正确的</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 714. 买卖股票的最佳时机含手续费]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-714-mai-mai-gu-piao-de-zui-jia-shi-ji-han-shou-xu-fei</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-714-mai-mai-gu-piao-de-zui-jia-shi-ji-han-shou-xu-fei">
        </link>
        <updated>2019-09-20T00:51:59.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。<br>
你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。<br>
返回获得利润的最大值。</p>
<p>示例 1:<br>
输入: prices = [1, 3, 2, 8, 4, 9], fee = 2<br>
输出: 8<br>
解释: 能够达到的最大利润:<br>
在此处买入 prices[0] = 1<br>
在此处卖出 prices[3] = 8<br>
在此处买入 prices[4] = 4<br>
在此处卖出 prices[5] = 9<br>
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.<br>
注意:<br>
0 &lt; prices.length &lt;= 50000.<br>
0 &lt; prices[i] &lt; 50000.<br>
0 &lt;= fee &lt; 50000.</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这一题的主要点也就是手续费吧，有了之前的铺垫这一题比较简单，只需要在卖出的时候减去手续费就好，重点还是复习如何简化动态规划的循环体。</p>
<pre><code>class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices, int fee) {
    const int n = prices.size();
        if(n==0||n==1)
            return 0;
	int dp_i10 = 0, dp_i11 = -prices[0];
	for (int i = 1; i &lt; n; i++) {
			dp_i10 = dp_i10&gt;dp_i11 + prices[i]-fee ? dp_i10:dp_i11 + prices[i]-fee;
			dp_i11 = dp_i11&gt;dp_i10-prices[i] ? dp_i11:dp_i10-prices[i];
		}
        return dp_i10;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 309. 最佳买卖股票时机含冷冻期]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-309-zui-jia-mai-mai-gu-piao-shi-ji-han-leng-dong-qi</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-309-zui-jia-mai-mai-gu-piao-shi-ji-han-leng-dong-qi">
        </link>
        <updated>2019-09-19T12:14:00.000Z</updated>
        <content type="html"><![CDATA[<p>官方原题：</p>
<blockquote>
<p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​<br>
设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:<br>
你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>
卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。<br>
示例:<br>
输入: [1,2,3,0,2]<br>
输出: 3<br>
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这一题主要的考点在于这个冷冻期，冷冻期明显地影响了我们的状态转移，一开始我被这个东西弄得到是抓耳挠腮，一直在思考怎么在源码上改动。但是后来才发现这个其实是一个非常不好的习惯，就是没有跳出代码的约束，总想着从代码出来修修补补，其实应该从根源上的抽象出发思考问题所在，才能解决具体的代码问题。<br>
后来冷静下来，利用题解中学到的只是，将所有的状态列出来<br>
0-0-0 0-1-0 0-1-1 1-0-0 1-0-1 1-1-0 1-1-1<br>
二进制来看三位数就八个状态，其中收到冷冻期的影响，1-0-1是不存在的，所以第三天的1买入状态是受到第一天的影响，其他情况下均不受影响，代码无须改变，所以代码的改动主要集中于<br>
<code>dp[i][k][1] = dp[i - 1][k][1]&gt;dp[i - 1][k - 1][0] - prices[i] ? dp[i - 1][k][1] : dp[i - 1][k - 1][0] - prices[i];</code><br>
上面<br>
同时由于k不受限制，k是完全可以去掉的<br>
最后的想法是</p>
<pre><code>dp0= dp0&gt;dp1+prices[i]?dp0:dp1+prices[i];	    
 dp1= dp1&gt;dpt-prices[i]?dp1:dpt-prices[i];
</code></pre>
<p>dpt代表了前两天的交易dp0；<br>
但是保存这个dp0比较麻烦，需要额外的两个向量</p>
<pre><code>dpt2=dp0;
dp0= dp0&gt;dp1+prices[i]?dp0:dp1+prices[i];	    
dp1= dp1&gt;dpt-prices[i]?dp1:dpt-prices[i];
dpt=dpt2;
</code></pre>
<p>首先保存当前的dp0（昨天的）准备给明天用，然后使用前天的dp0也就是dpt进行计算，最后将昨天的dp0 也就是dpt2赋给dpt<br>
最后代码：</p>
<pre><code>class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        const int n = prices.size();
        if(n==0||n==1)
            return 0;
       int dp0=0,dpt= 0 ;
	   int dp1 = - prices[0];
       int dpt2;
	for (int i = 1; i &lt; n; ++i) {
            dpt2=dp0;
			dp0= dp0&gt;dp1+prices[i]?dp0:dp1+prices[i];	    
            dp1= dp1&gt;dpt-prices[i]?dp1:dpt-prices[i];
            dpt=dpt2;
			}
		
	
	return dp0;
    }
};
</code></pre>
<p>其实中间几次提交都闹出了不少低级错误，一开始dpt dpt2忘了初始化，直接未定义值出来结果三万多还不信重新提交了一次。。。恍然大悟之后将dpt进行赋值的时候又鸠占鹊巢吧dp0的初始值给占去了，最后远程连接实验室电脑用vs15检查才发现了问题所在，还是得细心啊！</p>
]]></content>
    </entry>
</feed>