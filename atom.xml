<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-09-26T14:05:14.540Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[数组 287. 寻找重复数]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-287-xun-zhao-chong-fu-shu</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-287-xun-zhao-chong-fu-shu">
        </link>
        <updated>2019-09-26T08:09:57.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p>
<p>示例 1:<br>
输入: [1,3,4,2,2]<br>
输出: 2<br>
示例 2:<br>
输入: [3,1,3,4,2]<br>
输出: 3<br>
说明：<br>
不能更改原数组（假设数组是只读的）。<br>
只能使用额外的 O(1) 的空间。<br>
时间复杂度小于 O(n2) 。<br>
数组中只有一个重复的数字，但它可能不止重复出现一次。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/find-the-duplicate-number<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这个的话和昨天的相比的话也是比较明显的，普通的方法就是排序加遍历，排序可以分为快速排序和桶排序为主的两种原地排序和非原地排序之分，这两者主要的区别在于空间和时间上的取舍，但是明显地都不符合本题目的要求，所以应该是使用了非排序的方法。<br>
我一开始的时候想过使用每个位置的数组和来检测重复值，但是明显地如果重复数字出现多次的话就无法适用了，所以还是先看官方题解吧</p>
<blockquote>
<p>注释 ：<br>
前面的两种方法不满足提示中给出的约束条件，但它们是您在技术面试中可能会想到的解决方案。作为一名面试官，我个人不希望有人提出循环解决方案。<br>
证明：<br>
证明 nums 中存在至少一个副本是鸽子洞原理的简单应用。这里，nums 中的每个数字都是一个 “鸽子”，nums 中可以出现的每个不同的数字都是一个 “鸽子洞”。因为有 n+1个数是 n 个不同的可能数，鸽子洞原理意味着至少有一个数是重复的。<br>
方法一：排序<br>
如果对数字进行排序，则任何重复的数字都将与排序后的数组相邻。<br>
算法：<br>
算法相当简单。首先，我们对数组进行排序，然后将每个元素与前一个元素进行比较。因为数组中只有一个重复的元素，所以我们知道数组的长度至少为 2，一旦找到重复的元素，我们就可以返回它。</p>
</blockquote>
<pre><code>JavaPython
class Solution {
    public int findDuplicate(int[] nums) {
        Arrays.sort(nums);
        for (int i = 1; i &lt; nums.length; i++) {
            if (nums[i] == nums[i-1]) {
                return nums[i];
            }
        }

        return -1;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(nlgn)。排序调用在 Python 和 Java 中花费 O(nlgn) 时间，因此它支配后续的线性扫描。<br>
空间复杂度：O(1) (or O(n))，在这里，我们对 nums 进行排序，因此内存大小是恒定的。如果我们不能修改输入数组，那么我们必须为 nums 的副本分配线性空间，并对其进行排序。<br>
方法二：集合<br>
如果我们在数组上迭代时存储每个元素，我们可以在数组上迭代时简单地检查每个元素。</p>
<p>算法：<br>
为了实现线性时间复杂性，我们需要能够在恒定时间内将元素插入数据结构（并查找它们）。set 很好地满足这些约束，所以我们迭代数组并将每个元素插入 seen 中。在插入之前，我们检查它是否已经存在。如果是，那么我们找到了我们的副本，所以我们返回它。</p>
</blockquote>
<pre><code>JavaPython
class Solution {
    public int findDuplicate(int[] nums) {
        Set&lt;Integer&gt; seen = new HashSet&lt;Integer&gt;();
        for (int num : nums) {
            if (seen.contains(num)) {
                return num;
            }
            seen.add(num);
        }

        return -1;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)。Python 和 Java 都依赖于底层的哈希表，所以插入和查找有固定的时间复杂度。因此，该算法是线性的，因为它由一个执行 N 次恒定工作的 for 循环组成。<br>
空间复杂度：O(n)，在最坏的情况下，重复元素出现两次，其中一次出现在数组索引 n-1 处。在这种情况下，seen 将包含 n−1 不同的值，因此将占用 O(n) 空间。</p>
<p>方法三：弗洛伊德的乌龟和兔子（循环检测）<br>
如果我们对 nums 进行这样的解释，即对于每对索引 i 和值 v_i而言，“下一个” v_j位于索引 v_i处，我们可以将此问题减少到循环检测。</p>
<p>算法：<br>
首先，我们可以很容易地证明问题的约束意味着必须存在一个循环。因为 nums 中的每个数字都在 1 和 n 之间，所以它必须指向存在的索引。此外，由于 0 不能作为 nums 中的值出现，nums[0] 不能作为循环的一部分。</p>
</blockquote>
<pre><code>class Solution {
    public int findDuplicate(int[] nums) {
        // Find the intersection point of the two runners.
        int tortoise = nums[0];
        int hare = nums[0];
        do {
            tortoise = nums[tortoise];
            hare = nums[nums[hare]];
        } while (tortoise != hare);

        // Find the &quot;entrance&quot; to the cycle.
        int ptr1 = nums[0];
        int ptr2 = tortoise;
        while (ptr1 != ptr2) {
            ptr1 = nums[ptr1];
            ptr2 = nums[ptr2];
        }

        return ptr1;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)。<br>
空间复杂度：O(1)。</p>
</blockquote>
<p>题解一比较简单，我打算自己实现以下快速排序</p>
<pre><code>void QuickSort(vector&lt;int&gt; &amp;vi, vector&lt;int&gt;::iterator low, vector&lt;int&gt;::iterator high) {
	vector&lt;int&gt;::iterator middle;
	if (low &lt; high) {
		middle = partition(vi,low,high);
		QuickSort(vi, low, middle);
		QuickSort(vi, ++middle, high);
	}
}

vector&lt;int&gt;::iterator partition(vector&lt;int&gt; &amp;vi, vector&lt;int&gt;::iterator low, vector&lt;int&gt;::iterator high) {
	int pivotkey;
	if (low &lt; high)
		pivotkey = *low;
	while (low &lt; high) {
	while (low &lt; high&amp;&amp;pivotkey &lt;= *high) 
			--high;
	iter_swap(low, high);
		while (low &lt; high&amp;&amp;*low &lt;= pivotkey) 
			++low;
		iter_swap(low, high);	
	}
	return low;
}
</code></pre>
<p>哇居然被这个弄得有点焦头烂额，因为主要的槽点在于迭代器上，为了提高算法的泛型能力我用了迭代器（bidiretional iterator，支持++和--）而不是数组下标。书里的方法对于middle的两分法是分为 <code>[low,middle-1]、 [middle+1,high]</code> 对于数组下标来说这是小菜一碟，但是对于迭代器来说就不一样了，比如{1，0}这种情况当middle去到了边缘处，如果middle是迭代器，middle+1是没问题的，毕竟还有尾后迭代器，但是middle-1就8行了，所以只能用<code>[low,middle]、 [middle+1,high]</code>算是为了通用性牺牲了一点计算量吧。</p>
<p>题解二是一个集合，最简单的明显就是我一开始想到的set大法啦hhh，因为set的insert会返回一对pair，pair的second就用了bool值反映插入的成功与否，也太方便了吧hhh，当然set的底层是RB-tree，所以其中的操作可不简单，有时间得好好复习stl源码剖析。</p>
<p>第三个题解就是目标解了，不过就好像评论中所说，这个方法实在是太取巧了，颇有一种打哪指哪的感觉hhh<br>
这个方法重点在于把数组视为一个链表，其中的元素值就是指针，如果n+1个元素中有重复的，必然会形成一个内循环。<br>
贴一个网友给的其中的数学原理</p>
<pre><code> #此题转换为链表找环的开始位置，前提条件告诉我们是一定有环
 # 根据floyd判圈办法，一个快指针一个慢指针，二者一定在环上相遇，设相遇点为M点，
 # 快是慢的速度的2倍，时间相同，设慢的距离为s，那么快的距离为2s
 # m为链表头距离环开始位置的距离，k为环开始位置到M点的距离, N为环长度
 # s = m + a*N +k, 2s = m + b*N +k，二者相减，s = (a-b)*N
 # 由此可见，慢指针走过的距离是环长的整数倍，即链表头到M点是环长的整数倍
 # 如果是1倍的话，把m截距离旋转到环上，跟环融合，那么链表头一定落在M点，
# 即fast和slow都落在M点，那么二者到环开始位置距离相同，必然在此处相遇。
# 如果是N倍（N&gt;1）时，只不过slow指针多转几圈而已，后二者仍在此处相遇
</code></pre>
<pre><code>class Solution {
public:
    int findDuplicate(vector&lt;int&gt;&amp; nums) {
        int len=nums.size();
        if(len&lt;2)
            return 0;
        if(len==2)
            return nums[0];
        int fast=nums[0],slow=nums[0];
        do{
            slow=nums[slow];
            fast=nums[nums[fast]];
        }while(fast!=slow);
        fast=nums[0];
        while(slow!=fast){
            slow=nums[slow];
            fast=nums[fast];
        }
        return fast;
    }
};
</code></pre>
<p>比较难理解的就在于这一段了，这一段增速都是一致的，但是最后的落点只是值相同，而不是同一个点 比如{1，2，3，4，5，2}，m为2 M为5 环长度为4 5-2+1=4，此时slow从5出发，fast从1出发，大家都是只需一步就去到了2，但是并不是同一个2</p>
<pre><code>fast=nums[0];
        while(slow!=fast){
						slow=nums[slow];
						fast=nums[fast];
        }
</code></pre>
<p>然后网友给出了更有趣的一个重复数二分法，既符合了条件，又不会有太针对性的感觉。</p>
<blockquote>
<p>方法：二分法<br>
关键：这道题的关键是对要定位的“数”做二分，而不是对数组的索引做二分。要定位的“数”根据题意在 11 和 nn 之间，每一次二分都可以将搜索区间缩小一半。</p>
<p>以 <code>[1, 2, 2, 3, 4, 5, 6, 7]</code> 为例，一共有 8 个数，每个数都在 1 和 7 之间。1 和 7 的中位数是 4，遍历整个数组，统计小于 4 的整数的个数，至多应该为 3 个，如果超过 3 个就说明重复的数存在于区间 <code>[1,4)</code>（注意：左闭右开）中；否则，重复的数存在于区间 [4,7]（注意：左右都是闭）中。这里小于 4 的整数有 4 个（它们是 1, 2, 2, 3），因此砍掉右半区间，连中位数也砍掉。以此类推，最后区间越来越小，直到变成 1 个整数，这个整数就是我们要找的重复的数。</p>
</blockquote>
<p>参考代码 1：</p>
<pre><code>C++
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

class Solution {
public:
    int findDuplicate(vector&lt;int&gt; &amp;nums) {
        int len = nums.size();
        int left = 0;
        int right = len - 1;

        while (left &lt; right) {
            int mid = (left + right) &gt;&gt; 1;
            int counter = 0;
            for (int num:nums) {
                if (num &lt;= mid) {
                    counter++;
                }
            }

            if (counter &gt; mid) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
};
</code></pre>
<blockquote>
<p>说明：1、在 Python 中，整除使用 // ，如果使用 / ，在不能整除的时候，会返回一个小数；<br>
2、之所以写成 mid = left + (right - left + 1) // 2 ，是因为下面的分支条件是：left = mid 和 right = mid - 1，如果写成 mid = left + (right - left) // 2 就会陷入死循环。我们还是以具体例子为例。<br>
当一个整数数组（按升序排列）的个数为奇数时，不论 mid = left + (right - left) // 2 和 mid = left + (right - left + 1) // 2 都落在了相同的一个数，大家不妨拿 [1,2,3,4,5] 做验证；</p>
<p>当一个整数数组（按升序排列）的个数为偶数时：<br>
（1） mid = left + (right - left) // 2 找到的是中间位置偏左的元素；<br>
（2） mid = left + (right - left + 1) // 2 找到的是中间位置偏右的元素。<br>
可以拿 [1,2,3,4] 验证。<br>
因此如果分支是：left = mid 和 right = mid - 1，说明，当只有 2 个元素的时候，中位数不能取左边，否则会出现死循环，因此中位数的取法是 mid = left + (right - left + 1) // 2。<br>
如果分支是：left = mid + 1 和 right = mid，说明，当只有 2 个元素的时候，中位数不能取右边，否则会出现死循环，因此中位数的取法是 mid = left + (right - left) // 2。</p>
<p>3、<code>while left &lt; right</code> 一定是严格小于，这样退出循环的时候就一定有 l==r 成立，就不必纠结该返回 l 还是 r 了。</p>
<p>总结一下：while left &lt; right 一定是严格小于，最后把一个区间“夹逼”成一个数，二分法先写两个分支，再根据分支的情况，调整如何取中点。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 164. 最大间距]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-164-zui-da-jian-ju</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-164-zui-da-jian-ju">
        </link>
        <updated>2019-09-25T14:44:26.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。<br>
如果数组元素个数小于 2，则返回 0。</p>
<p>示例 1:<br>
输入: [3,6,9,1]<br>
输出: 3<br>
解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。<br>
示例 2:<br>
输入: [10]<br>
输出: 0<br>
解释: 数组元素个数小于 2，因此返回 0。<br>
说明:<br>
你可以假设数组中所有元素都是非负整数，且数值在 32 位有符号整数范围内。<br>
请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/maximum-gap<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这一题的话比较特殊吧，因为题目其实很明显了，如果用最显眼的方法那就无非是快速排序+遍历相减了，时间复杂度明显是o(nlogn+n)，但是题目又明显地让我们用线性的空间复杂度来换线性的时间复杂度，很明显应该用桶排序了，所以先来看一下题解吧：</p>
<blockquote>
<p>方法 1：比较排序<br>
想法<br>
按照题意实现。</p>
<p>算法<br>
将整个数组排序后，遍历数组找到相邻元素间的最大间距。</p>
</blockquote>
<pre><code>C++
int maximumGap(vector&lt;int&gt;&amp; nums)
{
    if (nums.empty() || nums.size() &lt; 2)            // check if array is empty or small sized
        return 0;
    sort(nums.begin(), nums.end());                 // sort the array
    int maxGap = 0;
    for (int i = 0; i &lt; nums.size() - 1; i++)
        maxGap = max(nums[i + 1] - nums[i], maxGap);
    return maxGap;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(nlogn)。排序的复杂度是 O(nlogn)，遍历的复杂度是 O(n)，总复杂度是O(nlogn)。<br>
空间复杂度：除去输入数组之外，不需要额外空间（因为大多数都是原地排序）。</p>
<p>方法 2：基数排序<br>
算法<br>
这个方法与第一种方法相似，不过我们基于基数排序而非传统的比较排序。</p>
</blockquote>
<pre><code>c++
int maximumGap(vector&lt;int&gt;&amp; nums)
{
    if (nums.empty() || nums.size() &lt; 2)
        return 0;

    int maxVal = *max_element(nums.begin(), nums.end());

    int exp = 1;                                 // 1, 10, 100, 1000 ...
    int radix = 10;                              // base 10 system

    vector&lt;int&gt; aux(nums.size());

    /* LSD Radix Sort */
    while (maxVal / exp &gt; 0) {                   // Go through all digits from LSD to MSD
        vector&lt;int&gt; count(radix, 0);

        for (int i = 0; i &lt; nums.size(); i++)    // Counting sort
            count[(nums[i] / exp) % 10]++;

        for (int i = 1; i &lt; count.size(); i++)   // you could also use partial_sum()
            count[i] += count[i - 1];

        for (int i = nums.size() - 1; i &gt;= 0; i--)
            aux[--count[(nums[i] / exp) % 10]] = nums[i];

        for (int i = 0; i &lt; nums.size(); i++)
            nums[i] = aux[i];

        exp *= 10;
    }

    int maxGap = 0;

    for (int i = 0; i &lt; nums.size() - 1; i++)
        maxGap = max(nums[i + 1] - nums[i], maxGap);

    return maxGap;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(d⋅(n+k))≈O(n)<br>
由于在数组上的线性迭代是接近线性复杂度，所以方法的时间性能瓶颈主要是基数排序。<br>
基数排序以计数排序为基础。</p>
<p>计数排序时间复杂度是 O(n+k)，其中 k 是数组 n个元素的基数（数字个数）。如果 k≤O(n)，计数排序可以在线性时间内完成。在我们的例子中，基数是固定的（比如，k = 10），因此计数排序运行时间是线性的 O(n)。<br>
基数排序运行 d 轮计数排序（其中每个元素由最多 d 个数字组成）。因此有效运行时间是 O(d⋅(n+k))，但在我们的例子中，最大可能的 32 位有符号是 2147483647，因此d≤10 是常数。<br>
因此基数排序的时间效率是 O(n)。<br>
空间复杂度：O(n+k)≈O(n)额外空间。</p>
<p>计数排序需要额外 O(k) 空间，基数排序需要一个和输入数组相同大小的辅助数组。然而给定的 k 是一个固定小常数，所以在大输入情况下计数排序的额外空间是可以被忽略的。</p>
</blockquote>
<blockquote>
<p>方法 3：桶和鸽笼原理<br>
想法</p>
<p>对整个数组排序的代价很大，最坏情况下需要让每个元素都和其他所有元素比较。</p>
<p>如果我们不需要比较所有元素对呢？如果我们将元素分类，比如说用桶，这个想法将是可能的。我们只需要比较这些桶即可。</p>
<p>题外话：鸽笼原理</p>
<p>鸽笼原理描述说，n 个物品放入 m个容器中，如果 n&gt;m 那么一定有一个容器装有至少两个物品。</p>
<p>假设对于数组中的任意一个元素都有一个桶，那么每个元素恰好占据一个桶。现在减少桶的个数，必然会有一些桶包含超过一个元素。</p>
<p>现在讨论元素之间的间距。考虑最好情况，假设元素排好序且两两之间间距相同。这意味着任意相邻元素都有恒定的差值。所以 n 个元素有 n−1 个间距，假设为 t，显然可以得到 t=(max−min)/(n−1)，其中 max 和 min 是数组中最大和最小的元素。这个间距就是相邻元素间最大间距，也就是我们要的答案。</p>
<p>显然，t 是具有相同数量（n）和相同区间（max−min）的数组中，都可以满足的最小值。证明：假设从一个相等间距的数组出发，改变相邻量元素的间距，假设将 arr[i−1] 和arr[i] 之间的间距变成 t−p，那么 arr[i] 和 arr[i+1] 之间的间距就增长为 t+p。因此最大间距就从 t 变成了t+p，因此最大间距 t只会增加。</p>
<p>桶！</p>
<p>回到我们的问题，我们已经了解了鸽笼原理的应用，那么如果我们用桶来代替单独元素作比较，比较的次数会减小，因为桶中可能有多个元素。这并不能马上解决完这个问题。如果在桶中比较元素？那问题将会得到很好解决。</p>
<p>所以现在的想法是：如果我们只需要在桶之间相互比较，而不用比较桶内的元素，看起来会非常理想。这也将解决排序问题：只需要将元素分配到合适的桶中，因为桶已经有序，所以我们只需要比较桶，不需要将所有元素排序并比较了。</p>
<p>说明</p>
<p>以下是一些说明：</p>
<p>桶的大小是相同的嘛？<br>
是的，他们大小都为 bb。</p>
<p>那么桶之间的间距也是固定的嘛？<br>
是的，桶之间的间距是 1。这意味着两个大小为 3 的相邻桶分别代表的区间是 3 - 63−6 和 4 - 74−7。不会出现重叠。</p>
<p>为什么说两个相邻桶之间可能出现最大间距？<br>
桶的大小也就是桶的容积，是桶可以容纳的最大区间范围。然而桶内的区间范围取决于桶内最大元素和最小元素的差值。例如一个大小为 55 的桶包含值域 6-106−10，它保存了元素 7,8,97,8,9 那么实际容积就是 (9 - 7) + 1 = 3(9−7)+1=3 与桶的大小不相等。</p>
<p>如何比较相邻两个桶？<br>
我们比较实际范围，也就是前一个桶的最大元素和后一个桶的最小元素。比如说，两个大小为 55 的桶，分别保存元素 [1,2,3][1,2,3] 和 [9,10][9,10]，那么桶之间的间距就是 9-3=69−3=6（大于任意一个桶的大小）。</p>
<p>是否还要再比较一次元素？！<br>
是的，需要！但只需要比较两倍桶个数的元素（每个桶的最大最小元素）。如果按照上面的做法，你会发现当选择了合适的桶大小时，比较次数远远小于数组中实际元素个数。</p>
<p>算法</p>
<p>选择合适的桶大小 bb 满足 1&lt;b≤(max−min)/(n−1)。设 b=⌊(max−min)/(n−1)⌋。<br>
所有 n 个元素被分为 k=⌈(max−min)/b⌉ 个桶。<br>
因此第 i 个桶保存的值区间为：[min+(i−1)∗b, min+i∗b)（下标从 1 开始）。<br>
显然很容易计算出每个元素属于哪个桶，floor⌊(num−min)/b⌋（下标从 0 开始）其中 num 是元素的值。<br>
当所有 n 个元素都遍历过后，比较 k−1 个相邻桶找到最大间距。</p>
</blockquote>
<pre><code>c++
class Bucket {
public:
    bool used = false;
    int minval = numeric_limits&lt;int&gt;::max();        // same as INT_MAX
    int maxval = numeric_limits&lt;int&gt;::min();        // same as INT_MIN
};

int maximumGap(vector&lt;int&gt;&amp; nums)
{
    if (nums.empty() || nums.size() &lt; 2)
        return 0;

    int mini = *min_element(nums.begin(), nums.end()),
        maxi = *max_element(nums.begin(), nums.end());

    int bucketSize = max(1, (maxi - mini) / ((int)nums.size() - 1));        // bucket size or capacity
    int bucketNum = (maxi - mini) / bucketSize + 1;                         // number of buckets
    vector&lt;Bucket&gt; buckets(bucketNum);

    for (auto&amp;&amp; num : nums) {
        int bucketIdx = (num - mini) / bucketSize;                          // locating correct bucket
        buckets[bucketIdx].used = true;
        buckets[bucketIdx].minval = min(num, buckets[bucketIdx].minval);
        buckets[bucketIdx].maxval = max(num, buckets[bucketIdx].maxval);
    }

    int prevBucketMax = mini, maxGap = 0;
    for (auto&amp;&amp; bucket : buckets) {
        if (!bucket.used)
            continue;

        maxGap = max(maxGap, bucket.minval - prevBucketMax);
        prevBucketMax = bucket.maxval;
    }

    return maxGap;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n+b)≈O(n)。<br>
线性遍历一遍数组中的元素，复杂度为 O(n)。找到桶之间的最大间距需要线性遍历一遍所有的桶，复杂度为 O(b)。所以总复杂度是线性的。<br>
空间复杂度：O(2⋅b)≈O(b) 的额外空间。<br>
每个桶只需要存储最大和最小元素，因此额外空间和桶个数线性相关。</p>
</blockquote>
<p>第一个题解就没啥好说的啦，第二个题解也是为了引出第三个题解，第三个题解的重点在于如何分配桶的容量和桶的个数，然后细节之处就在于桶的容量个数的计算和某个元素落入哪个桶的取值计算（floor和ceil的取舍），以及最后如何遍历桶（只保留每个桶的最大最小值，然后对比每个桶的差），我在细节处栽了很多跟头，即使知道了题解，还是得细心啊，而且得回去重新看一遍计数排序、基数排序和桶排序的那个线性时间复杂度的算法！<br>
最后代码如下：</p>
<pre><code>class Solution {
public:
    int maximumGap(vector&lt;int&gt;&amp; nums) {
        int len = nums.size();
	if (len==0||len==1)
		return 0;
	vector&lt;vector&lt;int&gt;&gt; bucket(len, vector&lt;int&gt;(2, -1));
	int max_ele = *max_element(nums.begin(), nums.end()), min_lel = *min_element(nums.begin(), nums.end());
	int cap = ceil((double)(max_ele - min_lel) / (double)(len - 1));
        if(!cap)
            return 0;
	for (auto i : nums) {
		int n = (i - min_lel) / cap;
		if (bucket[n][0] == -1)
			bucket[n][0] = i, bucket[n][1] = i;
		else {
			bucket[n][0] = bucket[n][0] &lt; i ? bucket[n][0] : i;
			bucket[n][1] = bucket[n][1] &gt; i ? bucket[n][1] : i;
		}
	}
	int diff = 0;
	int temp = bucket[0][1];
	for (int i = 1; i &lt; len ; ++i) {
		if (bucket[i][0] != -1)
			diff = bucket[i][0] - temp&gt;diff? bucket[i][0] - temp:diff , temp = bucket[i][1];
	}
	return diff;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第十章 笔记+习题 10.1-10.3]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-zhang-bi-ji-xi-ti-101-103</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-zhang-bi-ji-xi-ti-101-103">
        </link>
        <updated>2019-09-25T01:23:35.000Z</updated>
        <content type="html"><![CDATA[<p>10泛型算法<br>
泛型算法 1.“算法”：因为它们实现了一些<strong>经典算法的公共接口</strong> 如排序和搜索 2.“泛型”：因为它们可以用于不同类型的元素和多种容器类型</p>
<p>10.1概述<br>
大部分算法都定义在头文件algorithm中，标准库还在头文件numeric中定义了一组数值泛型算法<br>
泛型算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作<br>
find（begin，end，value）：寻找指定数值，返回在范围中第一个等于指定值的迭代器，如无匹配元素，<strong>返回第二个参数（迭代器）来表示搜索失败</strong><br>
注意！find函数的第二个参数指向的元素（位置）不会被检测，也就是<strong>开区间[begin,end）</strong> 因此可以通过<strong>比较返回值和第二个参数来判断是否成功</strong><br>
<strong>find可以使用指针</strong>，所以可以在<strong>内置数组</strong>中寻找值，使用begin()和end()函数可以获取内置数组的指针 int a[10];//<strong>begin(a),end(a)</strong><br>
这些步骤都不依赖于容器所保存的元素类型，甚至无须理会保存元素的是不是容器<br>
迭代器令算法不依赖于容器，但依赖于元素类型操作（= &lt; &gt;等）<br>
泛型算法本身不会执行容器的操作，只会运行于迭代器之上，永远不会改变底层容器的大小</p>
<p>习题10.1</p>
<pre><code>int main() {
	vector&lt;int&gt; vi;
	int i;
	while (cin &gt;&gt; i)
		vi.push_back(i);
	cout&lt;&lt;count(vi.begin(), vi.end(), 123)&lt;&lt;endl;
}
</code></pre>
<p>习题10.2</p>
<pre><code>int main() {
	list&lt;string&gt; ls;
	string s;
	while (cin &gt;&gt; s)
		ls.push_back(s);
	cout&lt;&lt;count(ls.begin(), ls.end(), &quot;123&quot;)&lt;&lt;endl;
}
</code></pre>
<p>10.2初始泛型算法<br>
标准库算法都对一个范围内的元素进行操作，称为输入范围（注意是开区间，要处理的第一个元素和尾元素之后位置形成的范围），理解算法的最基本方法是了解它们<strong>是否读取元素、改变元素和重排元素顺序</strong><br>
10.2.1只读算法<br>
只读算法：只读取元素不改变元素<br>
accumulate(begin,end,original_value) 求和函数<strong>第三个参数</strong>的类型决定了函数中<strong>使用哪个加法运算符以及返回值的类型</strong>，original_value是指和的初值。 <strong>如果第三个参数为0，而容器中的元素类型为double，返回值函还是int</strong><br>
第三个参数<strong>不能是字符串字面值</strong>而必须是<strong>显式创建的string</strong><br>
accumulate(v.cbegin(),v.cend(),string(“ ”))//正确<br>
accumulate(v.cbegin(),v.cend(),“ ”) //错误<br>
对于只读取而不改变元素的算法，通常最好使用<strong>cbegin和cend</strong>迭代器，但使用cbegin和cend迭代器会使得泛型函数返回c迭代器<br>
equal(v1.cbegin(),v2.cend(),v2.cbegin()) 比较两个序列是否保存相同的值<br>
由于迭代器的原因，我们可以使用equal比较两个不同类型的容器中的元素，甚至元素类型也不必一样<br>
注意！那些<strong>只接受单一迭代器</strong>来表示第二个序列的算法，<strong>都假定第二个序列至少与第一个序列一样长</strong></p>
<p>习题10.3</p>
<pre><code>int main() {
		vector&lt;int&gt; vi;
		int i;
		while (cin &gt;&gt; i)
			vi.push_back(i);
		cout &lt;&lt; accumulate(vi.cbegin(), vi.cend(), 0) &lt;&lt; endl;
}
</code></pre>
<p>习题10.4<br>
第三个参数为0，决定了返回值的类型是int，所以导致小数部分全部失效<br>
习题10.5<br>
3.5.4节P109 将比较符运用在c风格字符串上时，实际比较的将是指针而非字符串本身</p>
<p>10.2.2写容器元素的算法<br>
使用写入算法时必须保证序列原大小至少不小于我们要求算法写入的数目，因为<strong>算法不会执行容器操作，因此它们自身无法改变容器的大小</strong></p>
<p>fill算法：将给定值赋予输入序列中的每个元素<br>
一些算法接受一个迭代器指出一个单独的目的位置 例如函数fill_n</p>
<p>向目的位置迭代器写入数据的算法<strong>假定目的位置足够大</strong>，能容纳要写入的元素<br>
back_inserter 插入迭代器：定义在头文件iterator中，<strong>向容器添加元素的迭代器</strong>，保证算法有足够元素空间来容纳输出数据<br>
back_inserter接受一个指向容器的引用（需要绑定的容器），<strong>返回一个与该容器绑定的插入迭代器</strong>，当我们通过插入迭代器赋值时，赋值运算符会<strong>调用push_back</strong>将一个具有给定值的元素添加到容器中<br>
常常使用back_inserter来创建一个迭代器，作为算法的目的位置来使用</p>
<p>copy 拷贝算法，第三个参数表示目的序列的起始位置，目的序列至少要包含于输入序列一样多的元素<br>
copy返回的是其目的位置迭代器（递增后）的值，ret指向a2,的尾后位置<br>
其他泛型算法的 <strong>_copy版本</strong> 经常用于利用旧序列计算新元素的值，并保存在新创建的新序列中，例如replace_copy算法接受额外的第三个迭代器参数，指出调整后序列的保存位置</p>
<p>习题10.6</p>
<pre><code>int main()
{
	vector&lt;int&gt; i;
	fill_n(i.begin(), i.size(), 0);
}
</code></pre>
<p>知识点：注意fill_n的第二个参数是元素个是而不是迭代器<br>
习题10.7<br>
（a）无法保证size是一致的，应该vec.resize(lst.size())<br>
（b）reserve和resize是不一致的，reserve是capacity，不代表size，fill_n是看size的<br>
习题10.8<br>
这个算法是通过一个迭代器adapter来进行插入操作的，自身并没有针对容器内容进行容器大小操作，所以还是符合规矩的。</p>
<p>10.2.3重排容器元素的算法<br>
sort 利用元素类型的&lt;运算符来实现排序<br>
unique 重排输入范围，使得每个单词只出现一次，并排列在范围前部，返回指向不重复区域之后一个位置的迭代器</p>
<p>习题10.9</p>
<pre><code>int main()
{
	vector&lt;string&gt; vs;
	string s;
	while (cin &gt;&gt; s)
		vs.push_back(s);
	for (auto i : vs)
		cout &lt;&lt; i &lt;&lt; &quot; &quot;;
	cout &lt;&lt; endl;
	elimDups(vs);
}

void elimDups(vector&lt;string&gt; &amp;words) {
	sort(words.begin(), words.end());
	auto end_unique = unique(words.begin(), words.end());
	for (auto i : words)
		cout &lt;&lt; i &lt;&lt; &quot; &quot; ;
	cout &lt;&lt; endl;
	words.erase(end_unique, words.end());
	for (auto i : words)
		cout &lt;&lt; i &lt;&lt; &quot; &quot;;
	cout &lt;&lt; endl;
}
</code></pre>
<p>知识点：unique返回指向不重复区域之后一个位置的迭代器（所以还是会指向第一个重复的元素的！）<br>
习题10.10<br>
因为算法应该是泛型的，每种容器对于容器大小的处理都有所不同，甚至于有些会反过来影响算法（比如vector容量变化会导致迭代器失效），所以泛型算法应该摆脱这个影响。</p>
<p>10.3定制操作<br>
sort算法默认使用元素类型的 <strong>&lt;</strong> 运算符，但如果元素不支持该运算符，就需要重载sort的默认行为</p>
<p>10.3.1向算法传递函数<br>
谓词：可调用的表达式，其返回结果是一个能用做条件的值。分为一元谓词（只接受单一参数）和二元谓词（接受两个参数）.<br>
接受谓词参数的算法对输入序列中的每个元素依次调用谓词，所以元素类型必须能转换为谓词的参数类型<br>
接受一个二元谓词参数的sort版本用这个谓词代替&lt;来比较元素<br>
stable_sort算法：相同长度的单词按字典序排列，同时是稳定排序，并维持相等元素的原有顺序</p>
<p>习题10.11</p>
<pre><code>int main()
{
	vector&lt;string&gt; vs;
	string s;
	while (cin &gt;&gt; s)
		vs.push_back(s);
	for (auto i : vs)
		cout &lt;&lt; i &lt;&lt; &quot; &quot;;
	cout &lt;&lt; endl;
	elimDups(vs);
}

void elimDups(vector&lt;string&gt; &amp;words) {
	stable_sort(words.begin(), words.end(),isShorter);
	auto end_unique = unique(words.begin(), words.end());
	for (auto i : words)
		cout &lt;&lt; i &lt;&lt; &quot; &quot; ;
	cout &lt;&lt; endl;
	words.erase(end_unique, words.end());
	for (auto i : words)
		cout &lt;&lt; i &lt;&lt; &quot; &quot;;
	cout &lt;&lt; endl;
}

bool isShorter(const string &amp;s1, const string &amp;s2) {
	return s1.size() &lt; s2.size();
}
</code></pre>
<p>习题感悟：将比较符运用在c风格字符串上时，实际比较的将是指针而非字符串本身<br>
注意fill_n的第二个参数是元素个是而不是迭代器<br>
unique返回指向不重复区域之后一个位置的迭代器（所以还是会指向第一个重复的元素的！）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer  第九章 笔记+习题 9.5-9.6]]></title>
        <id>https://lixin-ee.github.io//post/c-primer</id>
        <link href="https://lixin-ee.github.io//post/c-primer">
        </link>
        <updated>2019-09-24T01:40:18.000Z</updated>
        <content type="html"><![CDATA[<p>9.5额外的string操作<br>
9.5.1构造string的其他方法<br>
从一个const char*创建string，指针指向的数组必须以空字符结尾，拷贝操作遇到空字符时停止<br>
如果给构造函数传递一个计数值，数组就不必以空字符结尾<br>
substr操作<br>
s.substr(pos,n) 返回一个string，包含s中从pos开始的n个字符的拷贝，pos默认值为0，n的默认值为s.size()-pos<br>
如果开始位置超过string的大小，则substr函数抛出一个out_of_range异常</p>
<p>习题9.41</p>
<pre><code>int main() {
	vector&lt;char&gt; c{'h','a','l','l','o'};
	string s(c.begin(),c.end());
	for (auto i : c) {
		s.push_back(i);
	}
}
</code></pre>
<p>习题9.42<br>
先读入ostringstream中保存再一次过读入string</p>
<p>9.5.2改变string的其他方法<br>
string定义了额外的<br>
1.接受下标版本的insert和assign<br>
2.接受c风格字符数组的insert和assign（替换整个string）3.append（末尾追加）和replace函数（替换）<br>
append、assign、replace、insert有不同版本，且有共同接口<br>
<strong>assign总是替换string所有内容</strong>，append总是将新字符追加到string末尾<br>
replace提供两种指定删除元素范围的方式1一个位置和一个长度2一对迭代器<br>
insert 指定插入点1.一个下标2.一个迭代器<br>
并不是每个函数都支持所有形式的参数，<strong>insert就不支持【下标+初始化列表参数】</strong><br>
insert插入**最后一个位置是的下标是s.insert(s.size(),ins_s);**而不是s.size()-1</p>
<p>习题9.43</p>
<pre><code>void sreplace(string s, string oldVal, string newVal) {
	for (auto i = s.begin(); i &lt; s.end() - oldVal.size()+1; ++i)
		if (s.substr(i - s.begin(), oldVal.size()) == oldVal) {
			s.erase(i - s.begin(), oldVal.size());
			s.insert(i - s.begin(), newVal);
		}		
	cout &lt;&lt; s &lt;&lt; endl;
}
</code></pre>
<p>知识点：使用s.substr(pos,n) 提取一小段string，s.substr(pos,n) 返回一个string，包含s中从pos开始的n个字符的拷贝<br>
习题9.44</p>
<pre><code>void sreplace(string s, string oldVal, string newVal) {
	int i = s.find(oldVal);
	s.replace(i, oldVal.size(), newVal);
	cout &lt;&lt; s &lt;&lt; endl;
}
</code></pre>
<p>习题9.45</p>
<pre><code>void sadd(string &amp;s, string front_s, string back_s) {
	s.insert(s.begin(), front_s.begin(),front_s.end());
	s.append(back_s);
}
</code></pre>
<p>知识点：注意string的insert接受的是（iter1，iter_beg,iter_end）<br>
习题9.46</p>
<pre><code>void sadd(string &amp;s, string front_s, string back_s) {
	s.insert(0, front_s);
	s.insert(s.size(),back_s);
}
</code></pre>
<p>知识点：注意insert插入最后一个位置是的下标是s.insert(s.size(),ins_s);而不是s.size()-1</p>
<p>9.5.3string搜索操作<br>
搜索函数操作返回一个string::size_type 表示匹配发生位置的下标<br>
搜索失败返回一个名为<strong>string::npos的static成员</strong>，标准库将npos定义为一个const string::size_type类型，<strong>并初始化值为-1</strong>，npos是一个unsigned类型，可以表示任何string最大的可能大小<br>
string搜索函数返回的都是unsigned类型，<strong>所以不应该用int或带符号类型来保存其返回值</strong>。<br>
搜索函数（以及其他string的操作）都是大小写敏感的<br>
可以传递给find操作一个可选的开始位置，这个可选的参数指出从哪个位置开始搜索<br>
rfind成员函数：从右到左搜索最后一个匹配项，但是<strong>注意和find_last_of并不同</strong> 比如寻找”abc”  ** rfind找的是cba** ，find_last_of找的是abc</p>
<p>习题9.47</p>
<pre><code>int main() {
	string s = { &quot;ab2c3d7R4E6&quot; };
	int i = 0;
	while (i &lt; s.size()) {
		i = s.find_first_of(&quot;0123456789&quot;, i);
		if (i == -1) 
			break;
		cout &lt;&lt; s[i++] &lt;&lt; endl;
	}
	i = 0;
	while (i &lt; s.size()) {
		i = s.find_first_not_of(&quot;0123456789&quot;, i);
		if (i == -1)
			break;
		cout &lt;&lt; s[i++] &lt;&lt; endl;
	}
}
</code></pre>
<p>小小地偷懒了一下hhh，不过find_first_of真的挺神奇的<br>
习题9.48<br>
搜索失败返回一个名为string::npos的static成员，标准库将npos定义为一个const string::size_type类型，并初始化值为-1，npos是一个unsigned类型，可以表示任何string最大的可能大小<br>
习题9.49</p>
<pre><code>int main() {
	string s = { &quot;pscjdoposjcpijsapicjdipsc&quot; };
	string sp{ &quot;dfpg&quot; };
	int i = 0,temp=0, len = 0,x=0,y=0;
	while (i&lt;s.size()) {
		i = s.find_first_of(sp, i);
		if (i==-1) {
			break;
		}
		if (len &lt;(i - temp)) {
			len = (i - temp);
			x = temp;
			y = i;
		}
		
		temp = ++i;
	}
	if(x||y)
		while(x!=y)
		cout &lt;&lt; s[x++] &lt;&lt; endl;
}
</code></pre>
<p>9.5.4compare函数<br>
根据s是等与、大于还是小于参数指定的字符串，s.compare返回<strong>0、正数和负数</strong><br>
compare有六个版本，根据我们是要比较两个string还是一个string与一个字符数组，参数各有不同<br>
9.5.5数值转换<br>
string参数中第一个非空白符必须是符号（+或-）或数字，它可以以0x或0X开头来表示十六进制数<br>
string参数也可以以小数点开头，<strong>并且可以包含e或E来表示指数部分</strong><br>
根据基数不同，string参数可以包含字母字符，对应大于数字9的数<br>
如果string不能转换为一个数值，这些函数将会抛出一个invalid_argument异常，如果转换得到的数值无法用任何类型表示，则抛出一个out_of_range异常</p>
<p>习题9.50</p>
<pre><code>int main() {
	vector&lt;string&gt; vs{ &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot; };
	int sum = 0;
	for (auto i : vs) {
		sum += stoi(i);
	}
	cout &lt;&lt; sum &lt;&lt; endl;
}
</code></pre>
<pre><code>int main() {
	vector&lt;string&gt; vs{ &quot;1.01&quot;,&quot;2.02&quot;,&quot;3.03&quot;,&quot;4.04&quot;,&quot;5.05&quot;,&quot;6.06&quot;,&quot;7.07&quot;,&quot;8.08&quot;,&quot;9.09&quot; };
	double sum = 0;
	for (auto i : vs) {
		sum += stod(i);
	}
	cout &lt;&lt; sum &lt;&lt; endl;
}
</code></pre>
<p>习题9.51</p>
<pre><code>class Date
{
public://class默认是私有继承，记得要加public
	unsigned _year;
	unsigned _month;
	unsigned _day;
	void _show()
	{
		cout &lt;&lt; _year &lt;&lt; &quot;年&quot; &lt;&lt; _month &lt;&lt; &quot;月&quot; &lt;&lt; _day &lt;&lt; &quot;日&quot; &lt;&lt; endl;
	}
	//构造函数
	Date(string);
};

Date::Date(string s)
{
	int flag = 0;
	string number = &quot;0123456789/&quot;;
	string coma = &quot;,&quot;;
	string month;
	unsigned pos, pos1, pos2, pos3;
	unsigned _pos, _pos1;

	/*利用一个判断，现判定怎样初始化*/
	if ((pos = s.find_first_not_of(number)) == string::npos)
	{
		flag = 1;
	}
	if ((pos = s.find_first_of(coma)) != string::npos)
	{
		flag = 2;
	}

	switch (flag)
	{
	case 1:/*处理1/1/1991的格式*/
		pos1 = 0;
		pos1 = s.find_first_of(&quot;/&quot;, pos1);
		_day = stoul(s.substr(0, pos1));//先截取目标字符串，再将字符串转化为unsigned
		pos2 = ++pos1;
		pos1 = s.find_first_of(&quot;/&quot;, pos1);
		_month = stoul(s.substr(pos2, pos1));
		pos3 = ++pos1;
		_year = stoul(s.substr(pos3, s.size() - 1));
		break;
	case 2:/*处理January 1,1900的格式*/
		_pos;
		_pos = s.find_first_of(number);
		month = s.substr(0, _pos);
		//本来想用switch,表达式的结果的类型可以是 整数类型，枚举类型，或者类类型
		//（但该类需要有单一的转换到整数类型或（可以是字符类型，但不能是浮点类型、字符串、指针类型等）
		if (month == &quot;January &quot;) _month = 1;
		if (month == &quot;February &quot;) _month = 2;
		if (month == &quot;March &quot;) _month = 3;
		if (month == &quot;April &quot;) _month = 4;
		if (month == &quot;May &quot;) _month = 5;
		if (month == &quot;June &quot;) _month = 6;
		if (month == &quot;July &quot;) _month = 7;
		if (month == &quot;August &quot;) _month = 8;
		if (month == &quot;September &quot;) _month = 9;
		if (month == &quot;October &quot;) _month = 10;
		if (month == &quot;November &quot;) _month = 11;
		if (month == &quot;December &quot;) _month = 12;

		_pos1 = ++_pos;
		_pos = s.find_first_of(number, _pos);
		_day = stoul(s.substr(_pos1 - 1, _pos));

		_year = stoul(s.substr(_pos, s.size() - 1));
		break;
	case 0:/*处理Jan 1 1995的格式*/
		_pos;
		_pos = s.find_first_of(number);
		month = s.substr(0, _pos);
		if (month == &quot;Jan &quot;) _month = 1;
		if (month == &quot;Feb &quot;) _month = 2;
		if (month == &quot;Mar &quot;) _month = 3;
		if (month == &quot;Apr &quot;) _month = 4;
		if (month == &quot;May &quot;) _month = 5;
		if (month == &quot;Jun &quot;) _month = 6;
		if (month == &quot;Jul &quot;) _month = 7;
		if (month == &quot;Aug &quot;) _month = 8;
		if (month == &quot;Sep &quot;) _month = 9;
		if (month == &quot;Oct &quot;) _month = 10;
		if (month == &quot;Nov &quot;) _month = 11;
		if (month == &quot;Dec &quot;) _month = 12;

		_pos1 = ++_pos;
		_pos = s.find_first_of(number, _pos);
		_day = stoul(s.substr(_pos1 - 1, _pos));

		_year = stoul(s.substr(_pos, s.size() - 1));
		break;
	}
}

int main()
{
	Date _today(&quot;25/2/2017&quot;);
	_today._show();

	Date _tomorrow(&quot;January 1,1995&quot;);
	_tomorrow._show();

	Date _2tomorrow(&quot;Jan 1 1995&quot;);
	_2tomorrow._show();

	return 0;

}
</code></pre>
<p>9.6容器适配器<br>
三个顺序容器适配器：stack（栈）、queue（队列）、propriety_queue<br>
适配器：使某种事物的行为看起来像另外一种事物一样，一个容器适配器接受一种已有的容器，使其行为看起来像一种不同的类型<br>
每个适配器都定义了两个构造函数1.默认构造函数创建一个空对象2.接受一个容器的构造函数拷贝该容器来初始化适配器<br>
栈（stack）适配器 定义在头文件stack中 先进后出<br>
每个容器适配器都基于底层容器类型的操作定义自己的特殊操作，我们只可以使用适配器操作，<strong>而不能使用底层容器类型的操作</strong> 例如：stack基于deque实现时，我们不能直接使用deque的操作，也就是不能再stack上调用push_back,而必须使用stack自己的操作push<br>
队列适配器 queue和priority_queue 定义在queue头文件中 先进先出<br>
书中此处的pop()介绍有误，其实就是用的deque的pop_front()来实现的，是删除元素并不返回<br>
priority_queue允许我们为<strong>队列中的元素建立优先级</strong>，新加入的元素会排在所有优先级比它低的元素之前</p>
<p><strong>stack默认用vector  queue默认用deque priority_queue默认用vector</strong></p>
<p>习题9.52</p>
<pre><code>
int main() {
	string equ{ &quot;1+3+5-4&quot; };
	int sum;
	stack&lt;string&gt; s;
	string equ_l;
	int i = 0,j=0;
	while (i &lt; equ.size()) {
		i = equ.find_first_not_of(num, i);
		if (i == -1) {
			s.push(equ.substr(j, equ.size()-j));
			break;
		}
		s.push(equ.substr(j, i - j));
		if (equ.substr(i, 1) == &quot;)&quot;) {
			string equ_l;
			while (s.top() != &quot;(&quot;)
				equ_l += s.top(), s.pop();
			s.pop();
			s.push(cal(equ_l));
		}
		else
		s.push(equ.substr(i,1));
		j = ++i;
	}
	string equ_all;
	while (!s.empty()) {
		equ_all+=s.top();
		s.pop();
	}
	cout &lt;&lt; stoi(cal(equ_all)) &lt;&lt; endl;
		

}

string cal(string s) {
	int i = 0, j = 0;
	int a = 0, b = 0;
	char sym;
	i = s.find_first_not_of(num, i);
	a = stoi(s.substr(j, i - j));
	while (i &lt; s.size()) {	
		sym = s[i];
		j = ++i;
		i = s.find_first_not_of(num, i);
		b = stoi(s.substr(j, i - j));
		switch (sym) {
		case '+':
			a += b;
			break;
		case'-':
			a -= b;
			break;
		}
		return to_string(a);
	}
}
</code></pre>
<p>习题感悟<br>
使用s.substr(pos,n) 提取一小段string，s.substr(pos,n) 返回一个string，包含s中从pos开始的n个字符的拷贝<br>
注意string的insert接受的是（iter1，iter_beg,iter_end）<br>
注意insert插入最后一个位置是的下标是s.insert(s.size(),ins_s);而不是s.size()-1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 674. 最长连续递增序列]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-674-zui-chang-lian-xu-di-zeng-xu-lie</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-674-zui-chang-lian-xu-di-zeng-xu-lie">
        </link>
        <updated>2019-09-23T14:47:37.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个未经排序的整数数组，找到最长且连续的的递增序列。</p>
<p>示例 1:<br>
输入: [1,3,5,4,7]<br>
输出: 3<br>
解释: 最长连续递增序列是 [1,3,5], 长度为3。<br>
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。<br>
示例 2:<br>
输入: [2,2,2,2,2]<br>
输出: 1<br>
解释: 最长连续递增序列是 [2], 长度为1。<br>
注意：数组长度不会超过10000。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>哈哈哈好久没遇到这么简单的题了，嗯主要就是中间变量的设置吧，比如max和cout的递增时机和赋值时机，这个没什么难度，一次过了，时间复杂度o（n），空间复杂度o（1）</p>
<pre><code>class Solution {
public:
    int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) {
        int len=nums.size();
        if(len==0)
            return 0;
        int max=1;
        int cout=1;
        for(int i=1;i&lt;len;++i){
            if(nums[i]&gt;nums[i-1])
                ++cout;
            else 
                cout=1;
            max=max&gt;cout?max:cout;
        }
        return max;
    }
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>解决方法：滑动窗口<br>
算法：<br>
每个（连续）增加的子序列是不相交的，并且每当 nums[i-1]&gt;=nums[i] 时，每个此类子序列的边界都会出现。当它这样做时，它标志着在 nums[i] 处开始一个新的递增子序列，我们将这样的 i 存储在变量 anchor 中。<br>
例如，如果 nums=[7，8，9，1，2，3]，那么 anchor 从 0 开始（nums[anchor]=7），并再次设置为 anchor=3（nums[anchor]=1）。无论 anchor 的值如何，我们都会记录 i-anchor+1 的候选答案、子数组 nums[anchor]、nums[anchor+1]、…、nums[i] 的长度，并且我们的答案会得到适当的更新。</p>
</blockquote>
<pre><code>Java
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        int ans = 0, anchor = 0;
        for (int i = 0; i &lt; nums.length; ++i) {
            if (i &gt; 0 &amp;&amp; nums[i-1] &gt;= nums[i]) anchor = i;
            ans = Math.max(ans, i - anchor + 1);
        }
        return ans;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(N)，其中 N 是 nums 的长度。我们通过 nums 执行一个循环。<br>
空间复杂度：O(1)，anchor 和 ans 使用了常数级空间。</p>
</blockquote>
<p>其实官方题解是更加简洁的，直接判定每一个存在的转折点anchor，然后将当前位置减去anchor再进行判断存进ans里面。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 334. 递增的三元子序列]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-334-di-zeng-de-san-yuan-zi-xu-lie</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-334-di-zeng-de-san-yuan-zi-xu-lie">
        </link>
        <updated>2019-09-23T09:35:00.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。<br>
数学表达式如下:<br>
如果存在这样的 i, j, k,  且满足 0 ≤ i &lt; j &lt; k ≤ n-1，<br>
使得 arr[i] &lt; arr[j] &lt; arr[k] ，返回 true ; 否则返回 false 。<br>
说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1) 。</p>
<p>示例 1:<br>
输入: [1,2,3,4,5]<br>
输出: true<br>
示例 2:<br>
输入: [5,4,3,2,1]<br>
输出: false</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/increasing-triplet-subsequence<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题其实蛮尴尬的，一开始我以为是判断三个连续的递增子序列，楞了一下怎么这么简单，然后提交错误后分析了错误用例才发现其实要求是ijk这三者是符合大小就行了，也就等于说我们希望在整个数组中从左到右找到三个递增的数列就ok了<br>
由于时间不够，所以直接看了题解，一开始判断三个连续的我就不贴出来啦hhh<br>
然后这一次是没有官方题解的，只有网友解：</p>
<blockquote>
<p>3个连续递增子序列<br>
有3个槽位，a,b,c<br>
满足条件 a &lt; b &lt; c，即可<br>
需要将合适的元素填入这3个槽位</p>
</blockquote>
<pre><code>class Solution {
    public boolean increasingTriplet(int[] nums) {
        int one = Integer.MAX_VALUE;
        int two = Integer.MAX_VALUE;
        
        for (int n : nums) {
            if (n &lt;= one) {
                one = n;
            } else if (n &lt;= two) {
                two = n;
            } else {
                return true;
            }
        }
        
        return false;
    }
}
</code></pre>
<p>这一份最简洁，但是没有解释好原理，特别是one=n这一步其实很让人疑惑，比如数组{2，3，1，5} 此时最后结果为one=1 two=3 ，这里其实是有点让人摸不着头脑的<br>
然后看另外一位网友的解答</p>
<blockquote>
<p>首先，如果只有一个最小值，然后找不到中间值，那么这个数组必然不包含递增的三个数（因为连递增的两个数都找不到）。</p>
<p>然后假设我们找到了两个递增的值，那么如果下一个值小于最小值，我们就应该将最小值的指针定位到这个值上。我们尽可能的使用最小值，防止后面出现了更小的一对递增值，而即使不出现，也不妨碍我们找到解（因为最终是看能否找到大于中间值的值）。<br>
如果下一个值大于最小值，且小于中间值，则我们使用该值作为中间值(因为如果最小的中间值都得不到解，那么就是false，这样也保证了覆盖所有的情况)。</p>
<p>最后，如果找到了大于中间值的值，则为true.</p>
</blockquote>
<p>他的代码有点瑕疵我就不贴上来了。这样一来就很明显了，其实我们是把后面出现的最小值叠在了上面，相当于探寻一个新的递增序列，比如{3，4，1，2，5}，1和2都会叠在3和4上面，构成新的递增序列，但是不用怕，因为只有比原值小的才能叠上去，哪怕1把3覆盖了，所以只要出现5，就一定能正确返回true。<br>
我一开始想过用栈的想法，但是栈的先进先出的特性明显不太适合这个状况，当然这个做法其实是有点取巧的了，就如评论里说，最终的结果无法保证下标的正确性。需要付出额外的代价才能返回正确的坐标。<br>
连续几天没通过了吧，不过还是不要气馁，“无用功”乃成功之母！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 42. 接雨水]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-42-jie-yu-shui</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-42-jie-yu-shui">
        </link>
        <updated>2019-09-22T13:17:05.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<br>
<img src="https://lixin-ee.github.io//post-images/1569158527522.png" alt=""><br>
上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。<br>
示例:<br>
输入: [0,1,0,2,1,0,1,3,2,1,2,1]<br>
输出: 6<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/trapping-rain-water<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题一开始还是没有比较好的思路，主要的纠结点在于如何处理左边的结点，一开始本来想用暴力法，但是太暴力了，所以想改进一下。改进的方法为确定一个左值left，然后寻找一个右值能够大于或者等于left，同时在过程中累积雨水量rain，如果能够找到符合条件的右值，就将rain累加到总的雨水量中去<br>
以为为未通过的代码：问题也很明显，只能收集到从左到右符合条件（先低后高）的点，遇到【4，3，2】这种先高后低的情况就没办法检测到，只能从右到左再做一遍，此时就发现思路有问题了，所以直接看题解吧</p>
<pre><code>class Solution {
public:
    int trap(vector&lt;int&gt;&amp; height) {
        int len = height.size();
        if(len==0||len==1||len==2){
            return 0;
        }
        int rain_all=0;
        int left=0;
        int rain=0;
        for(int i=0;i&lt;len;++i)
            if(height[i]&gt;0){
                left=i;
                if(i&gt;=len-2)
                    return 0;
                break;
            }else if(i==len-1)
                return 0;
        for(int i=left;i&lt;len-2;){
            int h = height[i];
            for(int j=i+1;j&lt;len;++j)
                if(j==len-1&amp;&amp;height[j]&lt;h){
                    rain=0;
                    ++i;
                    break;
                }else if(height[j]&lt;h){
                    rain+=h-height[j];
                }else{
                    rain_all+=rain;
                    rain=0;
                    i=j;
                    break;
                }      
        }
        return rain_all;
    }
};
</code></pre>
<p>官方题解：<br>
方法 1：暴力<br>
直观想法<br>
直接按问题描述进行。对于数组中的每个元素，我们找出下雨后水能达到的最高位置，等于两边最大高度的较小值减去当前高度的值。</p>
<p>算法<br>
初始化ans=0<br>
从左向右扫描数组：<br>
初始化 max_left=0 和max_right=0<br>
从当前元素向左扫描并更新：<br>
max_left=max(max_left,height[j])<br>
从当前元素向右扫描并更新：<br>
max_right=max(max_right,height[j])<br>
将min(max_left,max_right)−height[i] 累加到 ans</p>
<pre><code>Java
int trap(vector&lt;int&gt;&amp; height)
{
    int ans = 0;
    int size = height.size();
    for (int i = 1; i &lt; size - 1; i++) {
        int max_left = 0, max_right = 0;
        for (int j = i; j &gt;= 0; j--) { //Search the left part for max bar size
            max_left = max(max_left, height[j]);
        }
        for (int j = i; j &lt; size; j++) { //Search the right part for max bar size
            max_right = max(max_right, height[j]);
        }
        ans += min(max_left, max_right) - height[i];
    }
    return ans;
}
</code></pre>
<p>复杂性分析<br>
时间复杂度： O(n^2)。数组中的每个元素都需要向左向右扫描。<br>
空间复杂度O(1) 的额外空间</p>
<p>方法 2：动态编程<br>
直观想法<br>
在暴力方法中，我们仅仅为了找到最大值每次都要向左和向右扫描一次。但是我们可以提前存储这个值。因此，可以通过动态编程解决。<br>
这个概念可以见下图解释：<br>
<img src="https://lixin-ee.github.io//post-images/1569159456849.png" alt=""><br>
算法<br>
找到数组中从下标 i 到最左端最高的条形块高度left_max。<br>
找到数组中从下标 i 到最右端最高的条形块高度 right_max。<br>
扫描数组height 并更新答案：<br>
累加min(max_left[i],max_right[i])−height[i] 到 ans 上</p>
<pre><code>C++
int trap(vector&lt;int&gt;&amp; height)
{
	if(height == null)
		return 0;
    int ans = 0;
    int size = height.size();
    vector&lt;int&gt; left_max(size), right_max(size);
    left_max[0] = height[0];
    for (int i = 1; i &lt; size; i++) {
        left_max[i] = max(height[i], left_max[i - 1]);
    }
    right_max[size - 1] = height[size - 1];
    for (int i = size - 2; i &gt;= 0; i--) {
        right_max[i] = max(height[i], right_max[i + 1]);
    }
    for (int i = 1; i &lt; size - 1; i++) {
        ans += min(left_max[i], right_max[i]) - height[i];
    }
    return ans;
}
</code></pre>
<p>复杂性分析<br>
时间复杂度：O(n)。<br>
存储最大高度数组，需要两次遍历，每次 O(n) 。<br>
最终使用存储的数据更新ans ，O(n)。<br>
空间复杂度：O(n) 额外空间。<br>
和方法 1 相比使用了额外的 O(n) 空间用来放置left_max 和right_max 数组。</p>
<p>方法 3：栈的应用<br>
直观想法<br>
我们可以不用像方法 2 那样存储最大高度，而是用栈来跟踪可能储水的最长的条形块。使用栈就可以在一次遍历内完成计算。<br>
我们在遍历数组时维护一个栈。如果当前的条形块小于或等于栈顶的条形块，我们将条形块的索引入栈，意思是当前的条形块被栈中的前一个条形块界定。如果我们发现一个条形块长于栈顶，我们可以确定栈顶的条形块被当前条形块和栈的前一个条形块界定，因此我们可以弹出栈顶元素并且累加答案到 ans 。</p>
<p>算法<br>
使用栈来存储条形块的索引下标。<br>
遍历数组：<br>
当栈非空且height[current]&gt;height[st.top()]<br>
意味着栈中元素可以被弹出。弹出栈顶元素 top。<br>
计算当前元素和栈顶元素的距离，准备进行填充操作<br>
distance=current−st.top()−1<br>
找出界定高度<br>
bounded_height=min(height[current],height[st.top()])−height[top]<br>
往答案中累加积水量ans+=distance×bounded_height<br>
将当前索引下标入栈<br>
将urrent 移动到下个位置<br>
C++</p>
<pre><code>int trap(vector&lt;int&gt;&amp; height)
{
    int ans = 0, current = 0;
    stack&lt;int&gt; st;
    while (current &lt; height.size()) {
        while (!st.empty() &amp;&amp; height[current] &gt; height[st.top()]) {
            int top = st.top();
            st.pop();
            if (st.empty())
                break;
            int distance = current - st.top() - 1;
            int bounded_height = min(height[current], height[st.top()]) - height[top];
            ans += distance * bounded_height;
        }
        st.push(current++);
    }
    return ans;
}
</code></pre>
<p>复杂性分析<br>
时间复杂度：O(n)。<br>
单次遍历 O(n) ，每个条形块最多访问两次（由于栈的弹入和弹出），并且弹入和弹出栈都是 O(1) 的。<br>
空间复杂度：O(n)。 栈最多在阶梯型或平坦型条形块结构中占用 O(n) 的空间。</p>
<p>方法 4：使用双指针<br>
直观想法<br>
和方法 2 相比，我们不从左和从右分开计算，我们想办法一次完成遍历。<br>
从动态编程方法的示意图中我们注意到，只要right_max[i]&gt;left_max[i] （元素 0 到元素 6），积水高度将由 left_max 决定，类似地 left_max[i]&gt;right_max[i]（元素 8 到元素 11）。<br>
所以我们可以认为如果一端有更高的条形块（例如右端），积水的高度依赖于当前方向的高度（从左到右）。当我们发现另一侧（右侧）的条形块高度不是最高的，我们则开始从相反的方向遍历（从右到左）。<br>
我们必须在遍历时维护left_max 和 right_max ，但是我们现在可以使用两个指针交替进行，实现 1 次遍历即可完成。</p>
<p>算法<br>
初始化 left 指针为 0 并且right 指针为 size-1<br>
While left&lt;right, do:<br>
If height[left] &lt;height[right]<br>
If eight[left]≥left_max, 更新left_max<br>
Else 累加left_max−height[left] 到ans<br>
left = left + 1.<br>
Else<br>
If height[right]≥right_max, 更新 right_max<br>
Else 累加 right_max−height[right] 到 ans<br>
right =right - 1.</p>
<pre><code>int trap(vector&lt;int&gt;&amp; height)
{
    int left = 0, right = height.size() - 1;
    int ans = 0;
    int left_max = 0, right_max = 0;
    while (left &lt; right) {
        if (height[left] &lt; height[right]) {
            height[left] &gt;= left_max ? (left_max = height[left]) : ans += (left_max - height[left]);
            ++left;
        }
        else {
            height[right] &gt;= right_max ? (right_max = height[right]) : ans += (right_max - height[right]);
            --right;
        }
    }
    return ans;
}
复杂性分析
</code></pre>
<p>时间复杂度：O(n)。单次遍历的时间O(n)。<br>
空间复杂度：O(1)的额外空间。left,right, left_max 和 right_max 只需要常数的空间。</p>
<p>借用评论的一句话：这么多解法 ，我一个也没想起来，依旧菜鸡...<br>
这一整周状态都很差，感觉从那件水桶时间开始就一直碰到不好的事，幸好刷leetcode算是比较舒服的一件事了，现在来看一下这四个题解吧<br>
（1）首先虽然暴力法很暴力，不过还是有可取的地方的，其思想是取两边的最大值，然后再取两个最大值中的<strong>小值</strong>，其实就相当于把两边的最大值移动到当前位置的两边，测试一个当前位置自己能够装多少水，然后累积每个位置的水。<br>
（2）第二题其实是暴力解的进一步简化，思想比较简单，但是很实用，就是把最大值提前算出来放好，计算的时候再用上，用空间换取了时间，这一个题解对我的震撼很大，因为之前都是不太看得起暴力解，但是这里让我意识到从暴力解入手进行优化也是很重要的一种思路啊！所以还是<strong>不能好高骛远！</strong> 扎扎实实才能站得更高更稳！<br>
我给出的代码如下</p>
<pre><code>class Solution {
public:
    int trap(vector&lt;int&gt;&amp; height) {
        int len = height.size();
        if(len==0||len==1||len==2){
            return 0;
        }
        int left=0,right=0;
       vector&lt;int&gt; max_left(len),max_right(len);
        for(int i=0;i&lt;len;++i)
            if(left&gt;height[i])
               max_left[i]=left;
            else
                max_left[i]=height[i],left=height[i];
        for(int i=len-1;i&gt;=0;--i)
            if(right&gt;height[i])
                max_right[i]=right;
            else
                 max_right[i]=height[i],right=height[i];
        int ans=0;
        for(int i=0;i&lt;len;++i)
            ans+=(max_left[i]&lt;max_right[i]?max_left[i]:max_right[i])-height[i];
        return ans;
    }
};
</code></pre>
<p>（3）题解三用到了栈，但是我一开始想了很久都没想明白是怎么做到的，因为比如很简单的情况 21013，第二个1进来的时候只能对0进行操作，此时对比0两边的数，ans只能增加1，而实际上0这个位置可以增加2（因为最大的值其实是2），题解中非常巧妙地引入了distance的概念，相当于把水按行来计算，而不是和前两题一样按照列来算，比如2101中，101把第一行的空格子填满了，而213时（注意0和第二个1被弹出栈了），计算distance相当于把第二行给填满了（(2-1)+3），一开始还不容易看出呢，同时push被安排在while循环后面，不仅感叹妙啊！需要注意的地方是如果弹出栈顶后栈为空（等于没了一边边界），就需要break跳出循环直接push了</p>
<pre><code>class Solution {
public:
    int trap(vector&lt;int&gt;&amp; height) {
        int len = height.size();
        if(len==0||len==1||len==2){
            return 0;
        }
        stack&lt;int&gt; s;
        int ans=0;
        for(int i=0;i&lt;len;++i){
            if(s.empty())
                s.push(i);
            else{
                while(height[i]&gt;height[s.top()]){
                    int top = s.top();
                    s.pop();
                    if(s.empty())
                        break;
                    int distance = i-s.top()-1;
                    ans += ((height[i]&lt;height[s.top()]?height[i]:height[s.top()])-height[top])*distance;
                }
                s.push(i);
            }    
        }
        return ans;
    }
};
</code></pre>
<p>题解四的思路就比较6了直接两面夹击，使用双指针进行比较，也是相当于直接把边界缩减到当前元素的两边</p>
<pre><code>class Solution {
public:
    int trap(vector&lt;int&gt;&amp; height) {
        int len = height.size();
        if(len==0||len==1||len==2){
            return 0;
        }
        
        int ans=0;
        int left_max=0;
        int right_max=0;
        auto left=height.begin(),right=height.end()-1;
        while(left&lt;right){
            if(*left&lt;*right)
                if(*left&gt;=left_max)
                    left_max=*left,++left;
                else
                    ans+= left_max-*left,++left;
            else
                if(*right&gt;=right_max)
                    right_max=*right,--right;
                else
                    ans+= right_max-*right,--right;
        
        }
        return ans;
    }
};
</code></pre>
<p>这几天状态比较差，但是今晚还是坚持下来了，感谢努力的自己！（没有打游戏hhh，当然也做题做得有点晚了没法去健身房，但是晚上回宿舍的路上真的很舒服啊！）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ 迭代器类型]]></title>
        <id>https://lixin-ee.github.io//post/c-die-dai-qi-lei-xing</id>
        <link href="https://lixin-ee.github.io//post/c-die-dai-qi-lei-xing">
        </link>
        <updated>2019-09-22T13:02:00.000Z</updated>
        <content type="html"><![CDATA[<p>最近复习c++primer的容器部分，经常要接触迭代器的操作，比如递增或者算术操作，但是根据STL源码剖析中提及的，不同性质的容器使用了不同的容器类型，其中五种迭代器又根据等级的不同，支持的操作也有所不同，所以整理了一篇文章，以备日后复习或者参考使用<br>
##1. 迭代器(iterator)是一中检查容器内元素并遍历元素的数据类型。<br>
(1) 每种容器类型都定义了自己的迭代器类型，如vector:<br>
<code>vector&lt;int&gt;::iterator iter;这条语句定义了一个名为iter的变量，它的数据类型是由vector&lt;int&gt;定义的iterator类型。</code><br>
(2) 使用迭代器读取vector中的每一个元素：</p>
<pre><code>vector&lt;int&gt; ivec(10,1);
for(vector&lt;int&gt;::iterator iter=ivec.begin();iter!=ivec.end();++iter)
{
*iter=2; //使用 * 访问迭代器所指向的元素
}
const_iterator:
只能读取容器中的元素，而不能修改。
for(vector&lt;int&gt;::const_iterator citer=ivec.begin();citer!=ivec.end();citer++)
{
cout&lt;&lt;*citer;
//*citer=3; error
}
vector&lt;int&gt;::const_iterator 和 const vector&lt;int&gt;::iterator的区别
const vector&lt;int&gt;::iterator newiter=ivec.begin();
*newiter=11; //可以修改指向容器的元素
//newiter++; //迭代器本身不能被修改 
</code></pre>
<p>(3) iterator的算术操作：<br>
iterator除了进行++,--操作，可以将iter+n,iter-n赋给一个新的iteraor对象。还可以使用一个iterator减去另外一个iterator.</p>
<pre><code>const vector&lt;int&gt;::iterator newiter=ivec.begin();
vector&lt;int&gt;::iterator newiter2=ivec.end();
cout&lt;&lt;&quot;\n&quot;&lt;&lt;newiter2-newiter; 
</code></pre>
<p>一個很典型使用vector的STL程式:</p>
<pre><code> #include &lt;vector&gt;
 #include &lt;iostream&gt;
 
 using namespace std;

 int main() {
 vector&lt;int&gt; ivec;
 ivec.push_back(1);
 ivec.push_back(2);
 ivec.push_back(3);
  ivec.push_back(4);
 
 for(vector&lt;int&gt;::iterator iter = ivec.begin();1. iter != ivec.end(); ++iter)
 cout &lt;&lt; *iter &lt;&lt; endl;
 }
</code></pre>
<p>##2. Iterator（迭代器）模式<br>
一、概述<br>
Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。<br>
由于Iterator模式的以上特性：与聚合对象耦合，在一定程度上限制了它的广泛运用，一般仅用于底层聚合支持类，如STL的list、vector、stack等容器类及ostream_iterator等扩展iterator。<br>
根据STL中的分类，iterator包括：<br>
Input Iterator：只能单步向前迭代元素，不允许修改由该类迭代器引用的元素。<br>
Output Iterator：该类迭代器和Input Iterator极其相似，也只能单步向前迭代元素，不同的是该类迭代器对元素只有写的权力。<br>
Forward Iterator：该类迭代器可以在一个正确的区间中进行读写操作，它拥有Input Iterator的所有特性，和Output Iterator的部分特性，以及单步向前迭代元素的能力。<br>
Bidirectional Iterator：该类迭代器是在Forward Iterator的基础上提供了单步向后迭代元素的能力。<br>
Random Access Iterator：该类迭代器能完成上面所有迭代器的工作，它自己独有的特性就是可以像指针那样进行算术计算，而不是仅仅只有单步向前或向后迭代。<br>
这五类迭代器的从属关系，如下图所示，其中箭头A→B表示，A是B的强化类型，这也说明了如果一个算法要求B，那么A也可以应用于其中。</p>
<p>input output<br>
\ /<br>
forward<br>
|<br>
bidirectional<br>
|<br>
random access<br>
图1、五种迭代器之间的关系<br>
vector 和deque提供的是RandomAccessIterator，list提供的是BidirectionalIterator，set和map提供的 iterators是 ForwardIterator，关于STL中iterator迭代器的操作如下：<br>
说明：每种迭代器均可进行包括表中前一种迭代器可进行的操作。<br>
迭代器操作                      说明<br>
(1)所有迭代器<br>
p++                              后置自增迭代器<br>
++p                              前置自增迭代器<br>
(2)输入迭代器<br>
*p                                 复引用迭代器，作为右值<br>
p=p1                             将一个迭代器赋给另一个迭代器<br>
p==p1                           比较迭代器的相等性<br>
p!=p1                            比较迭代器的不等性<br>
(3)输出迭代器<br>
*p                                 复引用迭代器，作为左值<br>
p=p1                             将一个迭代器赋给另一个迭代器<br>
(4)正向迭代器<br>
提供输入输出迭代器的所有功能<br>
(5)双向迭代器<br>
--p                                前置自减迭代器<br>
p--                                后置自减迭代器<br>
(6)随机迭代器<br>
p+=i                              将迭代器递增i位<br>
p-=i                               将迭代器递减i位<br>
p+i                                在p位加i位后的迭代器<br>
p-i                                 在p位减i位后的迭代器<br>
p[i]                                返回p位元素偏离i位的元素引用<br>
p&lt;p1                             如果迭代器p的位置在p1前，返回true，否则返回false<br>
p&lt;=p1                           p的位置在p1的前面或同一位置时返回true，否则返回false<br>
p&gt;p1                             如果迭代器p的位置在p1后，返回true，否则返回false<br>
p&gt;=p1                           p的位置在p1的后面或同一位置时返回true，否则返回false<br>
只有顺序容器和关联容器支持迭代器遍历，各容器支持的迭代器的类别如下：<br>
容器                 支持的迭代器类别            容器               支持的迭代器类别            容器                 支持的迭代器类别<br>
vector              随机访问                      deque              随机访问                       list                   双向<br>
set                   双向                            multiset            双向                           map                 双向<br>
multimap          双向                             stack                不支持                        queue              不支持<br>
priority_queue   不支持<br>
##二、结构<br>
Iterator模式的结构如下图所示：<br>
<img src="https://lixin-ee.github.io//post-images/1569157561984.JPG" alt=""><br>
图2、Iterator模式类图示意<br>
##三、应用<br>
Iterator模式有三个重要的作用：<br>
1）它支持以不同的方式遍历一个聚合.复杂的聚合可用多种方式进行遍历，如二叉树的遍历，可以采用前序、中序或后序遍历。迭代器模式使得改变遍历算法变得很容易: 仅需用一个不同的迭代器的实例代替原先的实例即可，你也可以自己定义迭代器的子类以支持新的遍历，或者可以在遍历中增加一些逻辑，如有条件的遍历等。<br>
2）迭代器简化了聚合的接口. 有了迭代器的遍历接口，聚合本身就不再需要类似的遍历接口了，这样就简化了聚合的接口。<br>
3）在同一个聚合上可以有多个遍历 每个迭代器保持它自己的遍历状态，因此你可以同时进行多个遍历。<br>
4）此外，Iterator模式可以为遍历不同的聚合结构（需拥有相同的基类）提供一个统一的接口，即支持多态迭代。<br>
简单说来，迭代器模式也是Delegate原则的一个应用，它将对集合进行遍历的功能封装成独立的Iterator，不但简化了集合的接口，也使得修改、增 加遍历方式变得简单。从这一点讲，该模式与Bridge模式、Strategy模式有一定的相似性，但Iterator模式所讨论的问题与集合密切相关， 造成在Iterator在实现上具有一定的特殊性，具体将在示例部分进行讨论。<br>
##四、优缺点<br>
正如前面所说，与集合密切相关，限制了 Iterator模式的广泛使用，就个人而言，我不大认同将Iterator作为模式提出的观点，但它又确实符合模式“经常出现的特定问题的解决方案”的 特质，以至于我又不得不承认它是个模式。在一般的底层集合支持类中，我们往往不愿“避轻就重”将集合设计成集合 + Iterator 的形式，而是将遍历的功能直接交由集合完成，以免犯了“过度设计”的诟病，但是，如果我们的集合类确实需要支持多种遍历方式（仅此一点仍不一定需要考虑 Iterator模式，直接交由集合完成往往更方便），或者，为了与系统提供或使用的其它机制，如STL算法，保持一致时，Iterator模式才值得考虑。<br>
##五、举例<br>
可以考虑使用两种方式来实现Iterator模式：内嵌类或者友元类。通常迭代类需访问集合类中的内部数据结构，为此，可在集合类中设置迭代类为friend class，但这不利于添加新的迭代类，因为需要修改集合类，添加friend class语句。也可以在抽象迭代类中定义protected型的存取集合类内部数据的函数，这样迭代子类就可以访问集合类数据了，这种方式比较容易添加新的迭代方式，但这种方式也存在明显的缺点：这些函数只能用于特定聚合类，并且，不可避免造成代码更加复杂。<br>
STL的list::iterator、deque::iterator、rbtree::iterator等采用的都是外部Iterator类的形式，虽然STL的集合类的iterator分散在各个集合类中，但由于各Iterator类具有相同的基类，保持了相同的对外的接口（包括一些traits及tags等，感兴趣者请认真阅读参考1、2），从而使得它们看起来仍然像一个整体，同时也使得应用algorithm成为可能。我们如果要扩展STL的iterator，也需要注意这一点，否则，我们扩展的iterator将可能无法应用于各algorithm。<br>
以下是一个遍历二叉树的Iterator的例子，为了方便支持多种遍历方式，并便于遍历方式的扩展，其中还使用了Strategy模式（见笔记21）：<br>
（注：1、虽然下面这个示例是本系列所有示例中花费我时间最多的一个，但我不得不承认，它非常不完善，感兴趣的朋友，可以考虑参考下面的参考材料将其补充完善，或提出宝贵改进意见。2、 我本想考虑将其封装成与STL风格一致的形式，使得我们遍历二叉树必须通过Iterator来进行，但由于二叉树在结构上较线性存储结构复杂，使访问必须 通过Iterator来进行，但这不可避免使得BinaryTree的访问变得异常麻烦，在具体应用中还需要认真考虑。3、以下只提供了Inorder&lt;中序&gt;遍历iterator的实现。）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第九章 笔记+习题 9.3-9.4]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-jiu-zhang-bi-ji-xi-ti-93</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-jiu-zhang-bi-ji-xi-ti-93">
        </link>
        <updated>2019-09-21T07:43:48.000Z</updated>
        <content type="html"><![CDATA[<p>9.3顺序容器操作<br>
顺序容器和关联容器的不同之处在于两者组织元素的方式<br>
9.3.1向顺序容器添加元素<br>
向一个vector、string、deque插入元素会使所有指向容器的迭代器、引用和指针失效（list则不会）<br>
当使用插入元素操作时，必须记得<strong>不同容器使用不同策略</strong>来分配元素空间，直接影响到程序性能<br>
当我们使用一个对象来初始化容器或插入到容器中，实际上放入的是<strong>对象值的拷贝而不是对象本身</strong><br>
string可以接受字符的push_back<br>
insert函数允许在容器的任意位置插入0个或多个元素<br>
vector、deque、string使用<strong>insert可能会很耗时</strong><br>
新标准下个数添加和范围添加的insert返回指向第一个新加入元素的迭代器，如果范围为空，insert返回第一个参数<br>
<strong>emplace将参数传递给元素类型的构造函数</strong>，在容器内存空间中直接构造元素，而不是push、insert等拷贝值<br>
emplace函数的参数根据元素类型而变化，参数必须与元素类型的构造函数相匹配</p>
<p>习题9.18</p>
<pre><code>int main() {
	string s;
	deque&lt;string&gt; ds;
	while (cin &gt;&gt; s)
		ds.push_back(s);
	for (const auto &amp;i : ds) 
		cout &lt;&lt; i &lt;&lt; endl;
}
</code></pre>
<p>习题9.19<br>
由于我用的是for范围语句，所以直接把deque改成list就好<br>
知识点：主要还是复习一下STL中list的迭代器和数据结构和元素操作<br>
习题9.20</p>
<pre><code>int main() {
	list&lt;int&gt; li{1,2,3,4,5,6,7,8,9,10};
	deque&lt;int&gt; even;
	deque&lt;int&gt; odd;
	for (const auto &amp;i : li) {
		if (i % 2)
			odd.push_back(i);
		else
			even.push_back(i);
	}
	for (auto i : odd)
		cout &lt;&lt; i &lt;&lt; endl;
	for (auto i : even)
		cout &lt;&lt; i &lt;&lt; endl;
}
</code></pre>
<p>习题9.21<br>
换成vector之后，实际效果也是等于头部插入，但是！list是双向指针，只需要改变相关指针指向的对象即可，vector就必须把后面的元素全部后移一位，必要的时候还必须申请新的空间把整个vector复制到新的内存空间中去。<br>
习题9.22<br>
注意insert插入的位置时给定iter的前面，返回的是新插入的元素的迭代器，所以这个程序会永远循环下去（就算中间的内容不执行），同时mid这个迭代器会失效</p>
<pre><code>int main() {
	vector&lt;int&gt; iv{1,2,3,4,5,6,7,8,9,10};
	vector&lt;int&gt;::iterator iter = iv.begin(), mid = iv.begin() + iv.size() / 2;
	int val;
	while (iter != mid) {
		if (*mid == val) {
			iv.insert(mid, 2 * val);
			break;
		}
		else
			--mid;
	}
}
</code></pre>
<p>9.3.2访问元素<br>
访问成员函数（front、back、下标[ ]和at( )）<strong>返回的都是引用</strong>，如果容器是const就返回const引用<br>
但是！<strong>如果使用auto保存返回值时，需要将标量定义为引用类型，否则就获得指向最后一个元素的引用</strong>！ auto &amp;v = c.back()； auto v = c.back(); 前者获得引用后者获得拷贝<br>
编译器并不检查下标范围错误<br>
at成员函数 如果下标越界，at会抛出一个out_of_range异常</p>
<p>习题9.23<br>
四者皆为第一个元素<br>
<strong>注意区分 begin end front back</strong><br>
习题9.24</p>
<pre><code>int main() {
	vector&lt;int&gt; iv;
	//int i1 = iv.at(0);//通过编译，但是运行会报错，显示abort被调用
	//int i2 = iv[0];//运行会报错，显示out of range
	//int i3 = iv.front();//显示 vector iterator not dereferenable
	//int i4 = *iv.begin();//显示 vector iterator not dereferenable
}
</code></pre>
<p>9.3.3删除元素<br>
注意<strong>pop也会执行destroy的删除操作</strong><br>
在erase(b,e)中，e指向我们要删除的最后一个元素之后的位置<br>
<strong>上述操作皆会使非相关迭代器失效，但与insert并不完全一致，具体看表9.7</strong><br>
注意erase的迭代器对是同一对迭代器的时候，其实啥都不会发生。迭代器不相等时，注意是<strong>左闭右开的区间</strong>，比如想要删除所有元素，应该使用erase(v.begin().v.end())，而不是v.end()-1</p>
<p>习题9.25</p>
<pre><code>int main() {
	vector&lt;int&gt; iv{1,2,3,4,5};
	auto i1 = iv.begin(),i2=iv.begin();
	iv.erase(i1, i2);
	cout &lt;&lt; *iv.begin() &lt;&lt; endl;
	auto i3 = iv.end(), i4 = iv.end();
	iv.erase(i3, i4);
	cout &lt;&lt; iv.back() &lt;&lt; endl;
}
</code></pre>
<p>注意erase的迭代器对是同一对迭代器的时候，其实啥都不会发生.迭代器不相等时，注意是左闭右开的区间，比如想要删除所有元素，应该使用erase(v.begin().v.end())，而不是v.end()-1<br>
习题9.26</p>
<pre><code>int main() {
	int ia[] = { 0,1,1,2,3,5,8,13,21,55,89 };
	vector&lt;int&gt; iv(begin(ia),end(ia));
	list&lt;int&gt; il(begin(ia), end(ia));
	auto i = iv.begin();
	while (i != iv.end())
		if (!(*i % 2))
			i = iv.erase(i);
		else
			++i;
	for (auto x : iv)
		cout &lt;&lt; x &lt;&lt; endl;
	auto i1 = il.begin();
	while (i1 != il.end())
		if (*i1 % 2)
			i1 = il.erase(i1);
		else
			++i1;
	for (auto x : il)
		cout &lt;&lt; x &lt;&lt; endl;
}
</code></pre>
<p>知识点：list和vector等容器都可以直接用数组的指针对来初始化<code>vector&lt;int&gt; iv(begin(ia),end(ia));</code>，同时注意！！！，取反符号！的优先级特别低，比取模符号%的优先级低，所以要加括号</p>
<p>9.3.4特殊的forward_list操作<br>
删除或添加元素需要访问前驱并改变前驱的链接，单向链表没有方法获取一个元素的前驱<br>
所以forward_list删除添加元素需要通过改变给定元素之后的元素来完成，<br>
forward_list定义了before_begin 返回一个<strong>首前迭代器</strong>，这个迭代器允许我们在链表首元素之前并不存在的元素“之后”（也就是链首）添加删除元素</p>
<p>习题9.27</p>
<pre><code>int main() {
	vector&lt;int&gt; iv{ 0,1,1,2,3,5,8,13,21,55,89 };
	forward_list&lt;int&gt; fli(iv.begin(), iv.end());
	for (auto i = fli.begin(), i2 = fli.before_begin(); i != fli.end();) {
		if (*i % 2)
			i = fli.erase_after(i2);
		else
			++i, ++i2;
	}
	for (auto i : fli)
		cout &lt;&lt; i &lt;&lt; endl;	
}
</code></pre>
<p>知识点：forward_list的erase删除的是指定位置的后一个元素，返回的是删除元素的后一个元素的迭代器，所以所以需要两个迭代器合作才能做到删除特定元素，同时要注意这对迭代器的初始化、递增和赋值操作。例如需要i2 = fli.before_begin()<br>
才能删除首元素<br>
习题9.28</p>
<pre><code>int main() {
	forward_list&lt;string&gt; fli{&quot;123&quot;,&quot;456&quot;,&quot;789&quot;};
	string s1 = &quot;2887&quot;,s2 = &quot;2887&quot;;
	flist_i(fli, s1, s2);
	for (auto s : fli)
		cout &lt;&lt; s &lt;&lt; endl;
}

void flist_i(forward_list&lt;string&gt; &amp;fs, string s1, string s2) {
	for (auto i = fs.begin(); i != fs.end();) {
		auto i2 = i;
		if (*i == s1) {
			fs.insert_after(i, s2);
			return;
		}
		else
			++i;
		if (i == fs.end())
			fs.insert_after(i2, s2);
	}
	return;
}
</code></pre>
<p>知识点：还是老样子，必须注意如果迭代器i去到了end之后，就没法在链表末尾插入了（因为必须要末尾的前一个元素才能调用insert_after），同时forward_list是Forward Iterator，没法进行算术操作（注意，也没法--）。所以需要额外的迭代器进行递增</p>
<p>9.3.5改变容器大小<br>
resize 如果当前大小大于要求大小，将会删除容器后部的元素会被删除；如果小于要求大小，会将新元素添加容器后部，resize有一个可选的元素值参数，用于初始化添加到容器的元素**（但只有一个！）**如果未提供则会进行值初始化<br>
resize如果缩小容器，被删除元素的迭代器、引用和指针都会失效</p>
<p>习题9.29<br>
把vec的size()变为100个，同时进行值初始化，然后会变小，11-25的元素全部被删除。<br>
习题9.30<br>
必须能够进行值初始化或者有自己的默认构造函数</p>
<p>9.3.6容器操作可能使迭代器失效<br>
每次改变容器后都需要正确地重新定位迭代器，特别是vector、string、deque<br>
insert和erase都返回迭代器，可以用于更新迭代器，erase返回迭代器指向序列的下一个元素，inset返回指向新插入元素的迭代器<br>
1.添加或删除vector或string的元素2.或在deque首元素之外的位置删除添加元素 都会使得end返回的迭代器失效，所以不要在上面两种情况下缓存end返回的迭代器<br>
多使用v.end()而不是缓存end</p>
<p>习题9.31<br>
list是bidiretional iterator，forwaid_list是forward iterator，两者的迭代器都无法支持算术操作+=，只能进行递增操作</p>
<pre><code>int main() {
	//list&lt;int&gt; li = { 1,2,3,4,5,6,7,8 }; 
	/*auto iter = li.begin();
	while (iter != li.end()) {
		if (*iter % 2) {
			iter = li.insert(iter, *iter);
			advance(iter, 2);
		}
		else
		{
			iter = li.erase(iter);
		}
	}*/
	forward_list&lt;int&gt; li = { 1,2,3,4,5,6,7,8 };
	auto iter = li.begin();
	auto iter2 = li.before_begin();
	while (iter != li.end()) {
		if (*iter % 2) {
			iter = li.insert_after(iter, *iter);
			advance(iter, 1);
			advance(iter2, 2);
		}
		else
		{
			iter = li.erase_after(iter2);
		}
	}
} 
</code></pre>
<p>知识点，迭代器的前进可以使用advance！适用于list和slist的情况<br>
习题9.32<br>
不合法，*和++之间的的等级++比较高，这样子会把iter先递增，如果此时iter处于最后一个元素或者尾后迭代器，对iter进行递增会引发错误报告<br>
习题9.33<br>
begin会失效，不返回的话继续使用begin等于使用一个野指针<br>
习题9.34<br>
注意++iter在while循环外面了，等于无限循环了，作者的本意是想遇到vi中的奇数就复制一遍，遇到偶数跳过</p>
<p>9.4 vector对象是如何增长的<br>
vector和string是连续存储的，不能将新元素随意添加到内存的其他位置<br>
vector和string获取新内存空间时会分配比新的空间需求更大的内存空间作为备用<br>
reserve仅处理需求大于当前容量的请求，小于等于的不做任何操作<br>
shrink_to_fit可以选择忽略缩小空间请求，不一定退回内存空间<br>
capacity的值取决于标准库的实现<br>
只要没有操作需求超出了vector的容量，就不能重新分配内存空间（只有当迫不得已的时候才可以分配新的内存空间）<br>
遵循一个原则：确保添加元素的高效率保持在n的常数倍<br>
<strong>resize（）是元素个数，而不是直接影响capacity，只有capacity小于resize的大小才会增加</strong></p>
<p>习题9.35<br>
size是用户添加的元素数量，capacity是vector目前占有的空间的内存大小，也就是可以容纳的元素的最大数量<br>
习题9.36<br>
不可能<br>
习题9.37<br>
list是使用指针来存储前后元素的位置，不需要在内存连续存储，所以可以任意增长，array是一旦声明定义的时候就必须指定大小值，size和capacity是一样的，永远不会变化的。<br>
习题9.38<br>
STL源码剖析的分析应该是以2的次幂来增长的（但是我自己实测VS2015是1.5倍，有点尴尬）<br>
习题9.39<br>
首先分配了至少能容纳1024个元素的<code>vector&lt;string&gt;</code>，然后进行插入，插入完成后将size()大小修改为当前元素个数的1.5倍<br>
<strong>注意！！！resize（）是元素个数，而不是直接影响capacity，只有capacity小于resize的大小才会增加</strong><br>
习题9.40<br>
前两个都是resize小于capacity，都是1000，1000个的时候变成1500，1048视情况而定</p>
<p>习题感悟 注意区分 begin end front back<br>
注意erase的迭代器对是同一对迭代器的时候，其实啥都不会发生。迭代器不相等时，注意是左闭右开的区间，比如想要删除所有元素，应该使用erase(v.begin().v.end())，而不是v.end()-1<br>
list和vector等容器都可以直接用数组的指针对来初始化<code>vector&lt;int&gt; iv(begin(ia),end(ia));</code><br>
同时注意！！！，取反符号！的优先级特别低，比取模符号%的优先级低，所以要加括号<br>
forward_list的erase删除的是指定位置的后一个元素，返回的是删除元素的后一个元素的迭代器，所以所以需要两个迭代器合作才能做到删除特定元素，同时要注意这对迭代器的初始化、递增和赋值操作。例如需要i2 = fli.before_begin()<br>
才能删除首元素<br>
必须注意如果迭代器i去到了end之后，就没法在链表末尾插入了（因为必须要末尾的前一个元素才能调用insert_after），同时forward_list是Forward Iterator，没法进行算术操作（注意，也没法--）。所以需要额外的迭代器进行递增<br>
迭代器的前进可以使用advance！适用于list和slist的情况<br>
注意！！！resize（）是元素个数，而不是直接影响capacity，只有capacity小于resize的大小才会增加</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++引用的本质]]></title>
        <id>https://lixin-ee.github.io//post/cyin-yong-de-ben-zhi</id>
        <link href="https://lixin-ee.github.io//post/cyin-yong-de-ben-zhi">
        </link>
        <updated>2019-09-21T07:35:00.000Z</updated>
        <content type="html"><![CDATA[<p>最近逛博客的时候突然对引用这个东西产生了疑惑，引用的性质学了一大堆，还挺好用的，可是它的性质确实非常奇怪，首先不是个对象，vector等容器是不可以存引用，C数组也8行。其次它的性质也表现得像个对象，它一声明定义就必须初始化，初始化过后就等于绑定对象的别名。整体来说引用就相当于一个幽灵，看得到却摸不着，所以去搜了一下文章，找到一篇还不错的博文，可惜找不到原文了，所以图全部丢了，但是结论什么的还是很直观的。<br>
原文   http://blog.csdn.net/zsp_skyer/article/details/20069993（已经404）<br>
一、背景：<br>
当前很多文章或书籍中都说：<br>
1、“引用 ”是一个别名，作为目标的别名使用。<br>
2、“引用”不是值，不占用存储空间。<br>
3、“引用”只有声明，没有定义。<br>
4、证实对以上说法的一段常见代码和输出结果：<br>
上图代码输出结果：</p>
<p>从以上图可以看出，变量 b 作为对变量 a 的引用确实是像极了别名，以上图，从传统的 C++ 编程角度来看确实没有什么错，取地址的就取地址，取值的就取值，没什么特别的，感觉很舒服，完全就是别名的含义，于是乎，很多人就将上面的几点作为对引用的认识了（包括我自己）。</p>
<p>二、问题提出：<br>
我们知道函数传递参数无非就有两种：按值传参和按址传参，可能还有另外一种：经常听别人说的按引用传参。对于按值传参我们都知道是将实参的拷贝进行传递，被调用函数无法改变实参的值；按址传递是将实参的地址进行传递，可以改变实参的值。但别人又说按引用传递也可以改变实参的值，看来还真的可能还有按引用传递这种传参方式。请看下图：</p>
<p>上图代码输出结果：</p>
<p>从上图可以看出，按引用确实可以改变实参的值，这时候又有人喊了，按引用传参其实就是按址传参，我靠，说的罗里吧嗦的，那么现在的问题是：<br>
1、引用真的只是目标的一个别名吗？<br>
2、引用真的不占用内存空间吗？<br>
3、引用自身的值真的是目标自身的值吗？</p>
<p>三、问题分析：<br>
1、引用真的只是目标的一个别名吗？（如果是，你它有什么能力改变实参？如果不是，那引用到底是什么？）<br>
2、引用真的不占用内存空间吗？（如果占用，它肯定有内存地址，那这地址是什么？）<br>
3、引用自身的值真的是目标自身的值吗？ （如果不是，那引用自身的值是什么？）</p>
<p>四、问题验证：<br>
我们就针对上面的问题从汇编的角度看引用，还是使用上面的交换 a, b 值的代码。<br>
1、</p>
<p>调用 exchange 函数时上图中内存 a 的地址为：0x001ff7e0，内存 b 的地址为：0x001ff7d4 ；内存 a 中的值为：5，内存 b 中的值为：0Ah（即是10）。很明显，上图是把 a 和 b 的地址压栈了。<br>
2、</p>
<p>进入 exchange 函数中，此时调试观察到内存 first 中的值为：0x001ff7e0，内存 second 中的值为：0x001ff7d4，此时很明显了，结合上面的那点，内存 first 中的值其实就是内存 a 的地址：0x001ff7e0，不是内存 a 中的值：5；内存 second 中的值其实就是内存 b 的地址：0x001ff7d4，不是内存 b 中的值：10。也就是说 exchange 函数中，形参 first 和 second 作为对实参 a 和 b 的引用，接收的真正内容是实参 a 和 b 的内存地址 0x001ff7e0和 0x001ff7d4，而不是实参 a 和 b 的值 5 和 10。到这里问题提出中的三点就不攻自破了。所以引用不只是目标的别名这么简单，它有占内存空间，它有值，它的值其实就是目标的地址。既然它有占内存空间那它自身的地址是什么呢？我们在源码中写个汇编取它自身的地址看看：</p>
<p>调试观察到内存 first 的地址为：0x001ff6fc，内存 second 的地址为：0x001ff700</p>
<p>五、结论：<br>
综上所述，作为对目标 a 和 b 的引用 first 和 second，它们占用内存空间，自身的值就是目标 a 和 b 的内存地址， 也就是说它们的值是地址类型，聪明你们联想到什么了没？哈哈，没错，就是指针，也就是说，引用的本质就是指针，准确的说是一个常量指针（这个指针和其他指针的区别就是这个指针被规定指向了哪个目标，并且不能被修改；其他指针可以指向任何目标），引用这个东西其实是编译器对常量指针的包装修饰后，提供给你的一个工具而已。开头的代码片段中的【int a; int &amp;b = a;】将会被编译器转化成【int *const b = &amp;a;】，语句【cout &lt;&lt; &quot;变量 b 的内存地址为：&quot; &lt;&lt; &amp;b &lt;&lt; endl;】将被解析成【cout &lt;&lt; &quot;变量 b 的内存地址为：&quot; &lt;&lt; &amp;*b &lt;&lt; endl;】这就是当我们打印普通变量和引用变量的时候会输出相同地址的原因。所以就不难解析引用必须要初始化是因为 const 类型变量必须初始化，而这个指针也必须有所指；也不难解析按引用传参，其实就是按址传参；也不难解析对引用的操作，其实就是对目标的操作了。</p>
<p>下面将文章开头的代码段中的引用替换成常量指针后的效果：</p>
<p>上图代码输出结果：</p>
<p>怎么样？和开头的代码效果一样吧？所以最终一句话概括：“引用”就是 C++ 中的常量指针！</p>
<p>注意：本人能力有限，如有错漏，欢迎指正提出！</p>
]]></content>
    </entry>
</feed>