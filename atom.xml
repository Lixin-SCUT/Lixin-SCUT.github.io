<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-09-21T09:49:58.139Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[C++ primer 第九章 笔记+习题 9.3]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-jiu-zhang-bi-ji-xi-ti-93</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-jiu-zhang-bi-ji-xi-ti-93">
        </link>
        <updated>2019-09-21T07:43:48.000Z</updated>
        <content type="html"><![CDATA[<p>9.3顺序容器操作<br>
顺序容器和关联容器的不同之处在于两者组织元素的方式<br>
9.3.1向顺序容器添加元素<br>
向一个vector、string、deque插入元素会使所有指向容器的迭代器、引用和指针失效（list则不会）<br>
当使用插入元素操作时，必须记得<strong>不同容器使用不同策略</strong>来分配元素空间，直接影响到程序性能<br>
当我们使用一个对象来初始化容器或插入到容器中，实际上放入的是<strong>对象值的拷贝而不是对象本身</strong><br>
string可以接受字符的push_back<br>
insert函数允许在容器的任意位置插入0个或多个元素<br>
vector、deque、string使用<strong>insert可能会很耗时</strong><br>
新标准下个数添加和范围添加的insert返回指向第一个新加入元素的迭代器，如果范围为空，insert返回第一个参数<br>
<strong>emplace将参数传递给元素类型的构造函数</strong>，在容器内存空间中直接构造元素，而不是push、insert等拷贝值<br>
emplace函数的参数根据元素类型而变化，参数必须与元素类型的构造函数相匹配</p>
<p>习题9.18</p>
<pre><code>int main() {
	string s;
	deque&lt;string&gt; ds;
	while (cin &gt;&gt; s)
		ds.push_back(s);
	for (const auto &amp;i : ds) 
		cout &lt;&lt; i &lt;&lt; endl;
}
</code></pre>
<p>习题9.19<br>
由于我用的是for范围语句，所以直接把deque改成list就好<br>
知识点：主要还是复习一下STL中list的迭代器和数据结构和元素操作<br>
习题9.20</p>
<pre><code>int main() {
	list&lt;int&gt; li{1,2,3,4,5,6,7,8,9,10};
	deque&lt;int&gt; even;
	deque&lt;int&gt; odd;
	for (const auto &amp;i : li) {
		if (i % 2)
			odd.push_back(i);
		else
			even.push_back(i);
	}
	for (auto i : odd)
		cout &lt;&lt; i &lt;&lt; endl;
	for (auto i : even)
		cout &lt;&lt; i &lt;&lt; endl;
}
</code></pre>
<p>习题9.21<br>
换成vector之后，实际效果也是等于头部插入，但是！list是双向指针，只需要改变相关指针指向的对象即可，vector就必须把后面的元素全部后移一位，必要的时候还必须申请新的空间把整个vector复制到新的内存空间中去。<br>
习题9.22<br>
注意insert插入的位置时给定iter的前面，返回的是新插入的元素的迭代器，所以这个程序会永远循环下去（就算中间的内容不执行），同时mid这个迭代器会失效</p>
<pre><code>int main() {
	vector&lt;int&gt; iv{1,2,3,4,5,6,7,8,9,10};
	vector&lt;int&gt;::iterator iter = iv.begin(), mid = iv.begin() + iv.size() / 2;
	int val;
	while (iter != mid) {
		if (*mid == val) {
			iv.insert(mid, 2 * val);
			break;
		}
		else
			--mid;
	}
}
</code></pre>
<p>9.3.2访问元素<br>
访问成员函数（front、back、下标[ ]和at( )）<strong>返回的都是引用</strong>，如果容器是const就返回const引用<br>
但是！<strong>如果使用auto保存返回值时，需要将标量定义为引用类型，否则就获得指向最后一个元素的引用</strong>！ auto &amp;v = c.back()； auto v = c.back(); 前者获得引用后者获得拷贝<br>
编译器并不检查下标范围错误<br>
at成员函数 如果下标越界，at会抛出一个out_of_range异常</p>
<p>习题9.23<br>
四者皆为第一个元素<br>
<strong>注意区分 begin end front back</strong><br>
习题9.24</p>
<pre><code>int main() {
	vector&lt;int&gt; iv;
	//int i1 = iv.at(0);//通过编译，但是运行会报错，显示abort被调用
	//int i2 = iv[0];//运行会报错，显示out of range
	//int i3 = iv.front();//显示 vector iterator not dereferenable
	//int i4 = *iv.begin();//显示 vector iterator not dereferenable
}
</code></pre>
<p>9.3.3删除元素<br>
注意<strong>pop也会执行destroy的删除操作</strong><br>
在erase(b,e)中，e指向我们要删除的最后一个元素之后的位置<br>
<strong>上述操作皆会使非相关迭代器失效，但与insert并不完全一致，具体看表9.7</strong><br>
注意erase的迭代器对是同一对迭代器的时候，其实啥都不会发生。迭代器不相等时，注意是<strong>左闭右开的区间</strong>，比如想要删除所有元素，应该使用erase(v.begin().v.end())，而不是v.end()-1</p>
<p>习题9.25</p>
<pre><code>int main() {
	vector&lt;int&gt; iv{1,2,3,4,5};
	auto i1 = iv.begin(),i2=iv.begin();
	iv.erase(i1, i2);
	cout &lt;&lt; *iv.begin() &lt;&lt; endl;
	auto i3 = iv.end(), i4 = iv.end();
	iv.erase(i3, i4);
	cout &lt;&lt; iv.back() &lt;&lt; endl;
}
</code></pre>
<p>注意erase的迭代器对是同一对迭代器的时候，其实啥都不会发生.迭代器不相等时，注意是左闭右开的区间，比如想要删除所有元素，应该使用erase(v.begin().v.end())，而不是v.end()-1<br>
习题9.26</p>
<pre><code>int main() {
	int ia[] = { 0,1,1,2,3,5,8,13,21,55,89 };
	vector&lt;int&gt; iv(begin(ia),end(ia));
	list&lt;int&gt; il(begin(ia), end(ia));
	auto i = iv.begin();
	while (i != iv.end())
		if (!(*i % 2))
			i = iv.erase(i);
		else
			++i;
	for (auto x : iv)
		cout &lt;&lt; x &lt;&lt; endl;
	auto i1 = il.begin();
	while (i1 != il.end())
		if (*i1 % 2)
			i1 = il.erase(i1);
		else
			++i1;
	for (auto x : il)
		cout &lt;&lt; x &lt;&lt; endl;
}
</code></pre>
<p>知识点：list和vector等容器都可以直接用数组的指针对来初始化<code>vector&lt;int&gt; iv(begin(ia),end(ia));</code>，同时注意！！！，取反符号！的优先级特别低，比取模符号%的优先级低，所以要加括号</p>
<p>9.3.4特殊的forward_list操作<br>
删除或添加元素需要访问前驱并改变前驱的链接，单向链表没有方法获取一个元素的前驱<br>
所以forward_list删除添加元素需要通过改变给定元素之后的元素来完成，<br>
forward_list定义了before_begin 返回一个<strong>首前迭代器</strong>，这个迭代器允许我们在链表首元素之前并不存在的元素“之后”（也就是链首）添加删除元素</p>
<p>习题9.27</p>
<pre><code>int main() {
	vector&lt;int&gt; iv{ 0,1,1,2,3,5,8,13,21,55,89 };
	forward_list&lt;int&gt; fli(iv.begin(), iv.end());
	for (auto i = fli.begin(), i2 = fli.before_begin(); i != fli.end();) {
		if (*i % 2)
			i = fli.erase_after(i2);
		else
			++i, ++i2;
	}
	for (auto i : fli)
		cout &lt;&lt; i &lt;&lt; endl;	
}
</code></pre>
<p>知识点：forward_list的erase删除的是指定位置的后一个元素，返回的是删除元素的后一个元素的迭代器，所以所以需要两个迭代器合作才能做到删除特定元素，同时要注意这对迭代器的初始化、递增和赋值操作。例如需要i2 = fli.before_begin()<br>
才能删除首元素<br>
习题9.28</p>
<pre><code>int main() {
	forward_list&lt;string&gt; fli{&quot;123&quot;,&quot;456&quot;,&quot;789&quot;};
	string s1 = &quot;2887&quot;,s2 = &quot;2887&quot;;
	flist_i(fli, s1, s2);
	for (auto s : fli)
		cout &lt;&lt; s &lt;&lt; endl;
}

void flist_i(forward_list&lt;string&gt; &amp;fs, string s1, string s2) {
	for (auto i = fs.begin(); i != fs.end();) {
		auto i2 = i;
		if (*i == s1) {
			fs.insert_after(i, s2);
			return;
		}
		else
			++i;
		if (i == fs.end())
			fs.insert_after(i2, s2);
	}
	return;
}
</code></pre>
<p>知识点：还是老样子，必须注意如果迭代器i去到了end之后，就没法在链表末尾插入了（因为必须要末尾的前一个元素才能调用insert_after），同时forward_list是Forward Iterator，没法进行算术操作（注意，也没法--）。所以需要额外的迭代器进行递增</p>
<p>习题感悟 注意区分 begin end front back<br>
注意erase的迭代器对是同一对迭代器的时候，其实啥都不会发生。迭代器不相等时，注意是左闭右开的区间，比如想要删除所有元素，应该使用erase(v.begin().v.end())，而不是v.end()-1<br>
list和vector等容器都可以直接用数组的指针对来初始化<code>vector&lt;int&gt; iv(begin(ia),end(ia));</code><br>
同时注意！！！，取反符号！的优先级特别低，比取模符号%的优先级低，所以要加括号<br>
forward_list的erase删除的是指定位置的后一个元素，返回的是删除元素的后一个元素的迭代器，所以所以需要两个迭代器合作才能做到删除特定元素，同时要注意这对迭代器的初始化、递增和赋值操作。例如需要i2 = fli.before_begin()<br>
才能删除首元素<br>
必须注意如果迭代器i去到了end之后，就没法在链表末尾插入了（因为必须要末尾的前一个元素才能调用insert_after），同时forward_list是Forward Iterator，没法进行算术操作（注意，也没法--）。所以需要额外的迭代器进行递增</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++引用的本质]]></title>
        <id>https://lixin-ee.github.io//post/cyin-yong-de-ben-zhi</id>
        <link href="https://lixin-ee.github.io//post/cyin-yong-de-ben-zhi">
        </link>
        <updated>2019-09-21T07:35:00.000Z</updated>
        <content type="html"><![CDATA[<p>最近逛博客的时候突然对引用这个东西产生了疑惑，引用的性质学了一大堆，还挺好用的，可是它的性质确实非常奇怪，首先不是个对象，vector等容器是不可以存引用，C数组也8行。其次它的性质也表现得像个对象，它一声明定义就必须初始化，初始化过后就等于绑定对象的别名。整体来说引用就相当于一个幽灵，看得到却摸不着，所以去搜了一下文章，找到一篇还不错的博文，可惜找不到原文了，所以图全部丢了，但是结论什么的还是很直观的。<br>
原文   http://blog.csdn.net/zsp_skyer/article/details/20069993（已经404）<br>
一、背景：<br>
当前很多文章或书籍中都说：<br>
1、“引用 ”是一个别名，作为目标的别名使用。<br>
2、“引用”不是值，不占用存储空间。<br>
3、“引用”只有声明，没有定义。<br>
4、证实对以上说法的一段常见代码和输出结果：<br>
上图代码输出结果：</p>
<p>从以上图可以看出，变量 b 作为对变量 a 的引用确实是像极了别名，以上图，从传统的 C++ 编程角度来看确实没有什么错，取地址的就取地址，取值的就取值，没什么特别的，感觉很舒服，完全就是别名的含义，于是乎，很多人就将上面的几点作为对引用的认识了（包括我自己）。</p>
<p>二、问题提出：<br>
我们知道函数传递参数无非就有两种：按值传参和按址传参，可能还有另外一种：经常听别人说的按引用传参。对于按值传参我们都知道是将实参的拷贝进行传递，被调用函数无法改变实参的值；按址传递是将实参的地址进行传递，可以改变实参的值。但别人又说按引用传递也可以改变实参的值，看来还真的可能还有按引用传递这种传参方式。请看下图：</p>
<p>上图代码输出结果：</p>
<p>从上图可以看出，按引用确实可以改变实参的值，这时候又有人喊了，按引用传参其实就是按址传参，我靠，说的罗里吧嗦的，那么现在的问题是：<br>
1、引用真的只是目标的一个别名吗？<br>
2、引用真的不占用内存空间吗？<br>
3、引用自身的值真的是目标自身的值吗？</p>
<p>三、问题分析：<br>
1、引用真的只是目标的一个别名吗？（如果是，你它有什么能力改变实参？如果不是，那引用到底是什么？）<br>
2、引用真的不占用内存空间吗？（如果占用，它肯定有内存地址，那这地址是什么？）<br>
3、引用自身的值真的是目标自身的值吗？ （如果不是，那引用自身的值是什么？）</p>
<p>四、问题验证：<br>
我们就针对上面的问题从汇编的角度看引用，还是使用上面的交换 a, b 值的代码。<br>
1、</p>
<p>调用 exchange 函数时上图中内存 a 的地址为：0x001ff7e0，内存 b 的地址为：0x001ff7d4 ；内存 a 中的值为：5，内存 b 中的值为：0Ah（即是10）。很明显，上图是把 a 和 b 的地址压栈了。<br>
2、</p>
<p>进入 exchange 函数中，此时调试观察到内存 first 中的值为：0x001ff7e0，内存 second 中的值为：0x001ff7d4，此时很明显了，结合上面的那点，内存 first 中的值其实就是内存 a 的地址：0x001ff7e0，不是内存 a 中的值：5；内存 second 中的值其实就是内存 b 的地址：0x001ff7d4，不是内存 b 中的值：10。也就是说 exchange 函数中，形参 first 和 second 作为对实参 a 和 b 的引用，接收的真正内容是实参 a 和 b 的内存地址 0x001ff7e0和 0x001ff7d4，而不是实参 a 和 b 的值 5 和 10。到这里问题提出中的三点就不攻自破了。所以引用不只是目标的别名这么简单，它有占内存空间，它有值，它的值其实就是目标的地址。既然它有占内存空间那它自身的地址是什么呢？我们在源码中写个汇编取它自身的地址看看：</p>
<p>调试观察到内存 first 的地址为：0x001ff6fc，内存 second 的地址为：0x001ff700</p>
<p>五、结论：<br>
综上所述，作为对目标 a 和 b 的引用 first 和 second，它们占用内存空间，自身的值就是目标 a 和 b 的内存地址， 也就是说它们的值是地址类型，聪明你们联想到什么了没？哈哈，没错，就是指针，也就是说，引用的本质就是指针，准确的说是一个常量指针（这个指针和其他指针的区别就是这个指针被规定指向了哪个目标，并且不能被修改；其他指针可以指向任何目标），引用这个东西其实是编译器对常量指针的包装修饰后，提供给你的一个工具而已。开头的代码片段中的【int a; int &amp;b = a;】将会被编译器转化成【int *const b = &amp;a;】，语句【cout &lt;&lt; &quot;变量 b 的内存地址为：&quot; &lt;&lt; &amp;b &lt;&lt; endl;】将被解析成【cout &lt;&lt; &quot;变量 b 的内存地址为：&quot; &lt;&lt; &amp;*b &lt;&lt; endl;】这就是当我们打印普通变量和引用变量的时候会输出相同地址的原因。所以就不难解析引用必须要初始化是因为 const 类型变量必须初始化，而这个指针也必须有所指；也不难解析按引用传参，其实就是按址传参；也不难解析对引用的操作，其实就是对目标的操作了。</p>
<p>下面将文章开头的代码段中的引用替换成常量指针后的效果：</p>
<p>上图代码输出结果：</p>
<p>怎么样？和开头的代码效果一样吧？所以最终一句话概括：“引用”就是 C++ 中的常量指针！</p>
<p>注意：本人能力有限，如有错漏，欢迎指正提出！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 11. 盛最多水的容器]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-11-sheng-zui-duo-shui-de-rong-qi</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-11-sheng-zui-duo-shui-de-rong-qi">
        </link>
        <updated>2019-09-21T03:43:25.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>
说明：你不能倾斜容器，且 n 的值至少为 2。<br>
图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。<br>
示例:<br>
输入: [1,8,6,2,5,4,8,3,7]<br>
输出: 49</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/container-with-most-water<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>今天这题算是没做出来吧，前期有三个想法，但是各自有不同的困惑所以没实现（1）想从前向后遍历的时候很难确定什么时候应该更改第一个值（2）使用哈希表或者另外一个数组的存储一对值的话又需要进行排序（3）从中间开始的话向两边扩张不知道应该移动哪一边，所以最后用了暴力解法直接o(n^2)来判断每一对值得长度，太暴力了我就不贴出来了hhh，不浪费时间钻牛角尖了直接看官方题解吧：</p>
<blockquote>
<p>摘要<br>
如题意，垂直的两条线段将会与坐标轴构成一个矩形区域，较短线段的长度将会作为矩形区域的宽度，两线间距将会作为矩形区域的长度，而我们必须最大化该矩形区域的面积。<br>
方法二：双指针法<br>
算法<br>
这种方法背后的思路在于，两线段之间形成的区域总是会受到其中较短那条长度的限制。此外，两线段距离越远，得到的面积就越大。<br>
我们在由线段长度构成的数组中使用两个指针，一个放在开始，一个置于末尾。 此外，我们会使用变量 maxarea 来持续存储到目前为止所获得的最大面积。 在每一步中，我们会找出指针所指向的两条线段形成的区域，更新 maxarea，并将指向较短线段的指针向较长线段那端移动一步。<br>
这种方法如何工作？<br>
最初我们考虑由最外围两条线段构成的区域。现在，为了使面积最大化，我们需要考虑更长的两条线段之间的区域。如果我们试图将指向较长线段的指针向内侧移动，矩形区域的面积将受限于较短的线段而不会获得任何增加。但是，在同样的条件下，移动指向较短线段的指针尽管造成了矩形宽度的减小，但却可能会有助于面积的增大。因为移动较短线段的指针会得到一条相对较长的线段，这可以克服由宽度减小而引起的面积减小。</p>
</blockquote>
<pre><code> Java
 public class Solution {
     public int maxArea(int[] height) {
         int maxarea = 0, l = 0, r = height.length - 1;
         while (l &lt; r) {
             maxarea = Math.max(maxarea, Math.min(height[l], height[r]) * (r - l));
             if (height[l] &lt; height[r])
                 l++;
             else
                 r--;
         }
         return maxarea;
			}
 }
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)，一次扫描。<br>
空间复杂度：O(1)，使用恒定的空间。</p>
</blockquote>
<p>题解一就不说了，题解二非常精妙，又是一种“哇原来还可以这么做的感觉！”，其实代码过程非常简单，但是这道题的难度是中等，和我之前从中间向两边的思路存在的疑惑一样，我觉得主要的问题就在指针的移动选择，到底应该符合什么条件才能经过所有可能的更大值呢，重要的就在于移动最小值的证明。题解中已经把表象说得比较明白了，只有移动较短的那一条才能更有可能地获得更大值，然后更猛的来了，有数学大神贴出了数学证明<br>
由于博客难以贴出数学公式，具体可以查看链接：</p>
<blockquote>
<p>作者：r3n4ive<br>
链接：https://leetcode-cn.com/problems/container-with-most-water/solution/shuang-zhi-zhen-fa-zheng-que-xing-zheng-ming-by-r3/<br>
来源：力扣（LeetCode）<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<p>所以最后的代码为：</p>
<pre><code>class Solution {
public:
    int maxArea(vector&lt;int&gt;&amp; height) {
        int len = height.size();
        if(len==0||len==1)
            return 0;
        auto left=height.begin();
        auto right=height.end()-1;
        int maxArea=0;
        while(left!=right){
            if(*right&gt;*left)
                maxArea= maxArea&gt;(*left)*(right-left)?maxArea:(*left)*(right-left),++left;
            else
                maxArea= maxArea&gt;(*right)*(right-left)?maxArea:(*right)*(right-left),--right;
        }
        return maxArea;
    }
};
</code></pre>
<p>其实过程中还是有一丢丢波折，比如搞混了什么时候该用left什么时候该用right，都是很细微的错误hhh，所以还是得细心细心再细心！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第九章 笔记+习题 9.1-9.2]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-jiu-zhang-bi-ji-xi-ti-91-93</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-jiu-zhang-bi-ji-xi-ti-91-93">
        </link>
        <updated>2019-09-20T01:34:24.000Z</updated>
        <content type="html"><![CDATA[<p>9顺序容器<br>
顺序容器 不依赖于元素的值，而是与元素加入容器时的位置相对应<br>
顺序容器是可序的，但是不一定是有序的，同时在内存中不一定是连续排列的<br>
9.1顺序容器概述<br>
顺序容器在两个方面有不同的折中 1.添加和删除元素的代价 2.非顺序访问容器中元素的代价<br>
string和vector将元素<strong>保存在连续的内存空间</strong>中，可以用下标快速访问，但是在中间位置添加或删除元素非常耗时<br>
list和forward_list在<strong>任何位置添加删除元素都很快速</strong>，但是<strong>不支持随机访问</strong>，只能遍历整个容器来访问元素，而且额外内存开销很大<br>
deque支持快速随机访问，<strong>在中间位置添加删除元素代价高</strong>，但在两端添加删除元素快<br>
array对象大小固定，不支持添加删除元素或该表容器大小<br>
<strong>forward_list没有size操作</strong>， 达到与最好的手写的单向链表数据结构相当的性能<br>
应用中占主导地位的操作（访问操作or插入/删除元素）决定了容器类型的选择</p>
<p>习题9.1<br>
（a）list 因为需要排序，可能在任意位置进行元素的增删<br>
（b）deque，注意vector是无法在头部直接删除的<br>
（c）暂时选择vector 因为增删操作不是很明显</p>
<p>9.2容器库概览<br>
每个容器都定义在一个头文件中，<strong>文件名与类型名相同</strong><br>
<strong>容器均定义为模板类</strong><br>
顺序容器几乎可以保存任意类型的元素，<strong>包括以容器作为元素类型</strong></p>
<p>习题9.2<br>
<code>list&lt;deque&lt;int&gt;&gt; l;</code></p>
<p>9.2.1迭代器<br>
forward_list迭代器<strong>不支持递减运算符（forward iterator，不是bidiretional iterator）</strong><br>
迭代器<strong>算术运算</strong>，只能应用于string vector deque和array迭代器（<strong>random acess iterator</strong>）<br>
<strong>注意！只有random acess iterator 支持小于&lt; 大于&gt;等关系符</strong><br>
end迭代器不会指向范围中的最后一个元素，而是指向尾元素之后的位置<br>
迭代器begin和end必须指向相同的容器，可以指向相同的位置（此时容器为空），<strong>但不能指向begin之前的位置</strong><br>
可以通过直接检测begin==end是否为真来确定范围是否为空</p>
<p>习题9.3<br>
1.指向同一个容器或者是尾元素之后的位置 ，begin可以反复递增达到end<br>
2.end指向尾后迭代位置，并且begin不能在end后面<br>
习题9.4</p>
<pre><code>int main() {
	vector&lt;int&gt; v{ 1,2,3,4,5,6,7,8,9,10 };
	int i;
	cin &gt;&gt; i;
	cout &lt;&lt; Search(v.begin(), v.end(), i) &lt;&lt; endl;
}
bool Search(vector&lt;int&gt;::iterator&amp; beg, vector&lt;int&gt;::iterator&amp; end, int i) {
	while (beg != end)
		if (*beg == i) {
			return true;
		}
		else
			++beg;
	return false;
}
</code></pre>
<p>习题9.5</p>
<pre><code>int main() {
	vector&lt;int&gt; v{ 1,2,3,4,5,6,7,8,9,10 };
	int i;
	cin &gt;&gt; i;
	auto it = Search(v.begin(), v.end(), i);
	if (it != v.end())
		cout &lt;&lt; *it &lt;&lt; endl;
	else
		cout &lt;&lt; &quot;i is not found&quot; &lt;&lt; endl;
}

vector&lt;int&gt;::iterator&amp; Search(vector&lt;int&gt;::iterator&amp; beg, vector&lt;int&gt;::iterator&amp; end, int i) {
	while (beg != end)
		if (*beg == i) {
			return beg;
		}
		else
			++beg;
	return end;
}
</code></pre>
<p>习题9.6<br>
注意！只有random acess iterator 支持小于&lt; 大于&gt;等关系符，list仅仅是双向迭代器bidiretional iterator，所以是无法使用小于的</p>
<p>9.2.2容器类型成员<br>
反向迭代器就是反向遍历容器的迭代器，<strong>各种操作的含义发生了颠倒（递增递减也是，递增会变成向前移动，得到上一个元素）</strong><br>
通过类型别名，我们可以在不了解容器中元素类型的情况下使用它，比如value_type reference，在STL源码剖析中可以看到内部定义了这个类型别名，可以直接用，但是需要显式加上作用域<br>
使用类型别名时需要显式使用其【类名】 比如<code>vector&lt;int&gt;::iterator i;// vector&lt;int&gt;是很重要的显式类名，特别是int</code></p>
<p>习题9.7<br>
<code>vector&lt;int&gt;::iterator i;</code><br>
习题9.8<br>
<code>list&lt;string&gt;::const_iterator 和list&lt;string&gt;::iterator</code></p>
<p>9.2.3begin和end成员<br>
带r的版本返回反向迭代器<br>
以c开头的版本则返回const迭代器<br>
<strong>不以c开头的函数都是被重载过的</strong>，也就是实际上有两个名为begin的成员，一个是const成员，返回const_itrerator;一个是非常量成员，返回iterator<br>
可以将iterator转换成const_iterator 反之则不行<br>
以c开头的版本用于支持auto与迭代器函数结合使用 auto it = a.cbegin();//强制获得const迭代器<br>
当auto与迭代器函数结合使用时，获得的迭代器类型依赖于容器类型，但cbegin和cend可以强行获得const版本<br>
auto it = a.begin(); 仅当a是const时，it是const_iterator的<br>
<strong>注意：<code>vector&lt;int&gt;::const_iterator</code>和cbegin()的const是low-level const，可以递增iterator不能递增所指向的值</strong></p>
<p>习题9.9<br>
一个根据容器的const与否返回相应的迭代器，另一个强制返回const迭代器<br>
习题9.10<br>
根据上一题</p>
<pre><code>it1 vector&lt;int&gt;::iterator 
it2 vector&lt;int&gt;::const_iterator
it3 vector&lt;int&gt;::const_iterator
it4 vector&lt;int&gt;::const_iterator
</code></pre>
<p>注意：<code>vector&lt;int&gt;::const_iterator和cbegin()的const</code>是low-level const，可以递增iterator不能递增所指向的值</p>
<p>9.2.4容器定义和初始化<br>
除array外，其他容器的默认构造函数都会创建一个指定类型的空容器，且都可以接受指定容器大小和元素初始值的参数（array必须指定大小，但是注意和c数组是不一样的，例如array&lt;int, 5&gt; a;）<br>
注意相同和相容的区别<br>
将一个容器拷贝为新容器的方法1.直接拷贝整个容器2.拷贝迭代器指定的元素范围<br>
直接拷贝时，容器类型和元素类型必须匹配<br>
迭代器范围拷贝时不要求容器类型和元素类型完全相同，只要拷贝的元素能够转换类型<br>
新标准中允许对容器进行列表初始化<br>
定义array时除了指定元素类型，还要指定容器大小 array&lt;string,10&gt;;//保存10个string数组<br>
为了使用array类型，必须同时指定元素类型和大小 array&lt;int,10&gt;::size_type i;<br>
由于大小是array类型的一部分，所以array不支持普通的容器构造函数<br>
默认构造的array是非空的，如果我们对array进行列表初始化，初始值的数目必须等于或小于array的大小<br>
如果array的元素类型是一个类类型，则该类必须有一个默认构造函数，以使初始化能够进行<br>
<strong>array可以进行拷贝或对象赋值操作，内置数组类型则不能</strong></p>
<p>习题9.11</p>
<pre><code>vector&lt;int&gt; v;

vector&lt;int&gt; v(v2);
vector&lt;int&gt; v=v2;

vector&lt;int&gt; v{1,2,3,4,5,6};

vector&lt;int&gt; v(v2.begin(),v2.end());

vector&lt;int&gt; v(10);

vector&lt;int&gt; v(10,0);
</code></pre>
<p>习题9.12<br>
前者由于是值直接拷贝必须类型相同，后者使用迭代器的话，不需要知道迭代器的容器的类型，所以只需要类型相容即可。<br>
习题9.13</p>
<pre><code>int main() {
	vector&lt;int&gt; v{ 1,2,3,4,5,6,7,8,9,10 };
	list&lt;int&gt; v1{ 1,2,3,4,5,6,7,8,9,10 };
	int i;
	cin &gt;&gt; i;
	vector&lt;double&gt; v2(v.begin(),v.end());
	vector&lt;double&gt; v3(v1.begin(), v1.end());
}
</code></pre>
<p>9.2.5赋值和swap<br>
所有容器都可用赋值运算<br>
如果两个容器原来大小不同，赋值运算后左边大小等于右边大小（但类型必须相同）（容器赋值操作会影响大小）<br>
array允许赋值，但左右两边的运算对象必须具有相同的类型(包括大小)<br>
array不支持assign，也不允许用花括号包围的值列表进行列表赋值（但是可以列表初始化！）注意区分赋值和初始化</p>
<p>assign 顺序容器，从一个不同但相容的类型赋值（例如用vector的char*赋予一个list中的string），或者从容器的一个子序列赋值<br>
array 使用swap必须大小相同<br>
除array以外，交换两个容器内容的操作保证会很快，swap并不对任何元素进行拷贝、删除或插入操作，只是交换两个容器的内部数据结构，保证在常数时间内完成（只是交换了指针，而没有交换元素的值。array则是地址不变，改变值）例如</p>
<pre><code>vector&lt;int&gt; v{ 1 };
	vector&lt;int&gt; v1{ 0 };
	auto i = v.begin();
	swap(v, v1);
	cout &lt;&lt; *i &lt;&lt; endl;//返回1
	cout &lt;&lt; *v.begin()&lt;&lt;endl;//返回0
	cout &lt;&lt; (i == v1.begin()) &lt;&lt; endl;//返回1（true）
</code></pre>
<p>除string外，swap操作不会使指向容器的迭代器、引用和指针失效，仍指向swap操作之前所指向的那些元素，但是这些元素已经属于不同容器了（string调用swap则会导致迭代器引用指针失效）<br>
swap两个array会真正交换它们的元素，但指针、引用和迭代器等不变</p>
<p>习题9.14</p>
<pre><code>int main() {
	list&lt;char*&gt; c{ &quot;abcd&quot; };
	vector&lt;string&gt; vs;
	vs.assign(c.begin(),c.end());
	cout &lt;&lt; *vs.begin() &lt;&lt; endl;
}
</code></pre>
<p>注意，赋值和初始化是不一样的，可以用assign来赋值，但是如果是迭代器必须用一对迭代器<br>
<code>*v.begin()</code>是正确的！！！<code>*vs.empty()</code> 才是错误的，调用符的优先级比解引用符高，但是v.begin返回一个迭代器（vector的甚至就是一个指针），所以是正确的</p>
<p>9.2.6容器大小操作<br>
size()返回容器中元素的数目<br>
empty当size为0时返回布尔值true,否则返回false；<br>
max_size返回一个大于或等于该类型容器所能容纳的最大元素数的值。<br>
forward_list支持max_size和empty,但不支持size<br>
9.2.7关系运算符<br>
每个容器类型都支持相等运算符（=和!=);<br>
除了无序关联容器外的所有容器都支持关系运算符（&gt;、&gt;=、&lt;、&lt;=)。<br>
关系运算符左右两边的运算对象必须是相同类型的容器，<br>
且必须保存相同类型的元素。<br>
•如果两个容器具有相同大小直所有元素都两两对应相等，则这两个容器相等；否则<br>
两个容器不等。<br>
•如果两个容器大小不同，但较小容器中每个元素都等于较大容器中的对应元素，则<br>
较小容器小于较大容器。<br>
•如果两个容器都不是另一个容器的前缀子序列，则它们的比较结果取决于第一个不<br>
相等的元素的比较结果。<br>
只有当其元素类型也定义了相应的比较运算符时，我们才可以使用关系运算符来比较两个容器。<br>
容器的相等运算符实际上是使用元素的==运算符实现比较的，而其他关系运算符是使用元素的&lt;运算符。</p>
<p>习题9.15<br>
非常简单 直接== 可以参考下一题<br>
习题9.16<br>
可以把list拷贝到另外一个vector里面</p>
<pre><code>int main() {
	list&lt;int&gt; li{ 1,2,3,4,5,6 };
	vector&lt;int&gt; vi{ 1,2,3,4,5,6 };
	vector&lt;int&gt; vl;
	vl.assign(li.begin(), li.end());
	if (vl == vi)
		cout &lt;&lt; &quot;666&quot; &lt;&lt; endl;
	else
		cout &lt;&lt; &quot;8xing&quot; &lt;&lt; endl;
}
</code></pre>
<p>习题9.17<br>
c1 c2必须支持关系运算符 同时容器类型和包含元素的类型必须相同</p>
<p>习题感悟<br>
注意！只有random acess iterator 支持小于&lt; 大于&gt;等关系符<br>
注意：<code>vector&lt;int&gt;::const_iterator和cbegin()的const</code>是low-level const，可以递增iterator不能递增所指向的值<br>
前者由于是值直接拷贝必须类型相同，后者使用迭代器的话，不需要知道迭代器的容器的类型，所以只需要类型相容即可。<br>
<code>*v.begin()</code>是正确的！！！<code>*vs.empty()</code> 才是错误的，调用符的优先级比解引用符高，但是v.begin返回一个迭代器（vector的甚至就是一个指针），所以是正确的</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 714. 买卖股票的最佳时机含手续费]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-714-mai-mai-gu-piao-de-zui-jia-shi-ji-han-shou-xu-fei</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-714-mai-mai-gu-piao-de-zui-jia-shi-ji-han-shou-xu-fei">
        </link>
        <updated>2019-09-20T00:51:59.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。<br>
你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。<br>
返回获得利润的最大值。</p>
<p>示例 1:<br>
输入: prices = [1, 3, 2, 8, 4, 9], fee = 2<br>
输出: 8<br>
解释: 能够达到的最大利润:<br>
在此处买入 prices[0] = 1<br>
在此处卖出 prices[3] = 8<br>
在此处买入 prices[4] = 4<br>
在此处卖出 prices[5] = 9<br>
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.<br>
注意:<br>
0 &lt; prices.length &lt;= 50000.<br>
0 &lt; prices[i] &lt; 50000.<br>
0 &lt;= fee &lt; 50000.</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这一题的主要点也就是手续费吧，有了之前的铺垫这一题比较简单，只需要在卖出的时候减去手续费就好，重点还是复习如何简化动态规划的循环体。</p>
<pre><code>class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices, int fee) {
    const int n = prices.size();
        if(n==0||n==1)
            return 0;
	int dp_i10 = 0, dp_i11 = -prices[0];
	for (int i = 1; i &lt; n; i++) {
			dp_i10 = dp_i10&gt;dp_i11 + prices[i]-fee ? dp_i10:dp_i11 + prices[i]-fee;
			dp_i11 = dp_i11&gt;dp_i10-prices[i] ? dp_i11:dp_i10-prices[i];
		}
        return dp_i10;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 309. 最佳买卖股票时机含冷冻期]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-309-zui-jia-mai-mai-gu-piao-shi-ji-han-leng-dong-qi</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-309-zui-jia-mai-mai-gu-piao-shi-ji-han-leng-dong-qi">
        </link>
        <updated>2019-09-19T12:14:00.000Z</updated>
        <content type="html"><![CDATA[<p>官方原题：</p>
<blockquote>
<p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​<br>
设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:<br>
你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>
卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。<br>
示例:<br>
输入: [1,2,3,0,2]<br>
输出: 3<br>
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这一题主要的考点在于这个冷冻期，冷冻期明显地影响了我们的状态转移，一开始我被这个东西弄得到是抓耳挠腮，一直在思考怎么在源码上改动。但是后来才发现这个其实是一个非常不好的习惯，就是没有跳出代码的约束，总想着从代码出来修修补补，其实应该从根源上的抽象出发思考问题所在，才能解决具体的代码问题。<br>
后来冷静下来，利用题解中学到的只是，将所有的状态列出来<br>
0-0-0 0-1-0 0-1-1 1-0-0 1-0-1 1-1-0 1-1-1<br>
二进制来看三位数就八个状态，其中收到冷冻期的影响，1-0-1是不存在的，所以第三天的1买入状态是受到第一天的影响，其他情况下均不受影响，代码无须改变，所以代码的改动主要集中于<br>
<code>dp[i][k][1] = dp[i - 1][k][1]&gt;dp[i - 1][k - 1][0] - prices[i] ? dp[i - 1][k][1] : dp[i - 1][k - 1][0] - prices[i];</code><br>
上面<br>
同时由于k不受限制，k是完全可以去掉的<br>
最后的想法是</p>
<pre><code>dp0= dp0&gt;dp1+prices[i]?dp0:dp1+prices[i];	    
 dp1= dp1&gt;dpt-prices[i]?dp1:dpt-prices[i];
</code></pre>
<p>dpt代表了前两天的交易dp0；<br>
但是保存这个dp0比较麻烦，需要额外的两个向量</p>
<pre><code>dpt2=dp0;
dp0= dp0&gt;dp1+prices[i]?dp0:dp1+prices[i];	    
dp1= dp1&gt;dpt-prices[i]?dp1:dpt-prices[i];
dpt=dpt2;
</code></pre>
<p>首先保存当前的dp0（昨天的）准备给明天用，然后使用前天的dp0也就是dpt进行计算，最后将昨天的dp0 也就是dpt2赋给dpt<br>
最后代码：</p>
<pre><code>class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        const int n = prices.size();
        if(n==0||n==1)
            return 0;
       int dp0=0,dpt= 0 ;
	   int dp1 = - prices[0];
       int dpt2;
	for (int i = 1; i &lt; n; ++i) {
            dpt2=dp0;
			dp0= dp0&gt;dp1+prices[i]?dp0:dp1+prices[i];	    
            dp1= dp1&gt;dpt-prices[i]?dp1:dpt-prices[i];
            dpt=dpt2;
			}
		
	
	return dp0;
    }
};
</code></pre>
<p>其实中间几次提交都闹出了不少低级错误，一开始dpt dpt2忘了初始化，直接未定义值出来结果三万多还不信重新提交了一次。。。恍然大悟之后将dpt进行赋值的时候又鸠占鹊巢吧dp0的初始值给占去了，最后远程连接实验室电脑用vs15检查才发现了问题所在，还是得细心啊！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ C++ primer 第八章 笔记+习题 ]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-ba-zhang-bi-ji-xi-ti</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-ba-zhang-bi-ji-xi-ti">
        </link>
        <updated>2019-09-19T08:24:00.000Z</updated>
        <content type="html"><![CDATA[<p>8.1IO类<br>
之前我们使用的IO类型和对象都是操纵char数据，默认情况下关联到用户的控制台窗口。<br>
iostream定义了读写流的基本类型，fstream定义了读写命名文件的类型，sstream定义了读写内存string对象的类型<br>
8.1.1<br>
不能拷贝或对IO对象赋值，同时<strong>不能将形参或者返回类型</strong>设置为流类型（因为不能拷贝）<br>
进行IO操作的函数通常以<strong>引用方式传递和返回流</strong>，<strong>读写一个IO对象会改变它的状态</strong>，因此传递和返回的引用<strong>不能使用const</strong><br>
8.1.2<br>
访问和操纵流的条件状态<br>
一个流一旦发生错误，其上后续的IO操作都会失败。只有当一个流处于无错状态时，我们才可以从它读取数据。代码通常应该在使用一个流之前检查它是否处于良好状态<br>
确定一个流对象的状态最简单的方法是将它当做一个条件来使用：while(cin&gt;&gt;word)，while将会循环检查&gt;&gt;表达式返回的流的状态<br>
iostate类型，与机器无关，提供了表达流状态的完整功能，这个类型应作为一个位集合来使用<br>
IO库定义了四个iostate类型的constexpr值，表示特定的位模式<br>
badbit 系统级错误 如不可恢复的读写错误 failbit可恢复错误 eofbit 输出流达到文件结束位置 goodbit值为0，表示流未发生错误<br>
到达文件结束位置eofbit和failbit都会被置位，badbit被置位时failbit也会返回true<br>
所以我们可以使用goodbit或者failbit确定流的总体状态，eof和bad只代表特定的错误<br>
标准库定义了一组函数来查询这些标志位的状态<br>
rdstate( )返回一个iostate值，对应流的当前状态<br>
setstate()操作将给定条件的位置置位，表示发生了对应错误<br>
clear()是一个重载成员 不接受参数的版本用于复位所有错误标志位，带参数的clear接受一个iostate值，表示流的新状态</p>
<p>习题8.1+8.2</p>
<pre><code>int main() {
	RaP(cin);
}

istream &amp;RaP(istream &amp;is) {
	string s;
	while (is&gt;&gt;s) {
		cout &lt;&lt; s &lt;&lt; endl;
	}
	is.clear();
	return is;
}
</code></pre>
<p>习题8.3<br>
badbit :流已崩溃  eofbit :流达到了文件结束位置  failbit ：IO操作失败 这三者置位时循环会终止</p>
<p>8.1.3管理输出缓冲<br>
每个输出流都管理一个缓冲区，用来保存程序读写的数据<br>
缓冲机制使得操作系统可以将程序的多个输出操作组合成单一的系统级操作<br>
导致缓冲刷新的原因：1.程序正常结束。2.缓冲区满 3.使用操纵符endl等显式刷新缓冲区4.在输出操作后用操纵符unitbuf设置流的内部状态来清空缓冲区。默认情况下对cerr是设置unitbuf的，因此写到cerr的内容都是立即刷新的5.一个输出流可能被关联到另一个流，当读写到被关联的流时，关联到的流的缓冲区就会被刷新，比如cin、cerr被关联到cout<br>
使用unitbuf操纵符 每次输出操作后都刷新缓冲区，每次写操作之后都进行一次flush操作<br>
nounitbuf操纵符 重置流，使其恢复使用正常的系统管理的缓冲区刷新机制<br>
cout&lt;&lt;unitbuf; cout&lt;&lt;nounitbuf;<br>
程序崩溃后缓冲区不会自动刷新<br>
tie将输入流（）关联到一个输出流中，任何试图从输入流读取数据的操作都会先刷新输出流，保证用户提示信息在读操作操作之前被打印出来<br>
标准库将cin 和cout关联在一起<br>
tie( )返回关联的输出流的指针，tie(&amp;o)将调用对象绑定到输出流o</p>
<p>8.2文件输入输出<br>
ifstream 从给定文件读取数据<br>
ofstream 向给定文件写入数据<br>
fstream 读写给定文件<br>
使用文件流需要添加<code>#include&lt;fstream&gt;</code><br>
8.2.1使用文件流对象<br>
文件名既可以是库类型string对象，也可以是c风格字符数组 <strong>(意思是文件名用string，而不是用string代替文件) 例如 string file_name =file.txt; fstream strm(file_name);</strong><br>
可以用继承类型的对象来替代使用基类型对象的地方，所以可以用fstream代替iostream<br>
当一个fstream 对象被销毁的时候，close会被自动调用</p>
<p>习题8.4</p>
<pre><code>#include&lt;fstream&gt;
using namespace std;
fstream &amp;RaP(fstream &amp;is);

int main() {
	string f = &quot;test.txt&quot;;
	fstream fstrm(f);
	&amp;RaP(fstrm);
}

fstream &amp;RaP(fstream &amp;is) {
	vector&lt;string&gt; vs;
	string s;
	while (getline(is,s)) {
		cout &lt;&lt; s &lt;&lt; endl;
		vs.push_back(s);
	}
	return is;
</code></pre>
<p>习题8.5</p>
<pre><code>fstream &amp;RaP(fstream &amp;is) {
	vector&lt;string&gt; vs;
	string s;
	while (is&gt;&gt;s) {
		cout &lt;&lt; s &lt;&lt; endl;
		vs.push_back(s);
	}
	return is;
}
</code></pre>
<p>习题8.6<br>
其实就和284页一模一样，但是需要注意！<strong>main函数的形参只能通过命令行来输入</strong>，vs中的调试是没办法输入的<br>
<img src="https://lixin-ee.github.io//post-images/1568890886547.png" alt=""></p>
<p>8.2.2文件模式<br>
截断文件：清空当前文件的所有内容<br>
以out默认模式打开文件会丢失数据，因为其默认带上trunc模式<br>
保留文件已有内容必须显式指定in或者app配合out<br>
每次调用open都会（需要）设置模式<br>
习题8.7<br>
fstream out(argv[2])或者fstream out(argv[2]，ofstream::out )<br>
习题8.8<br>
fstream out(argv[2]，ofstream::app )<br>
fstream out(argv[2]，ofstream::out | ofstream::app )</p>
<p>8.3string流<br>
istringstream从string读取数据<br>
ostringstream 向string写入数据<br>
stringstream 读写数据<br>
istringstream 对整行文本进行分步操作<br>
ostringstream 逐步构造输出，最后一起打印</p>
<p>习题8.9</p>
<pre><code>istream &amp;RaP(istream &amp;is) {
	string s;
	getline(cin, s);
	istringstream ist(s);
	string output;
	while (ist &gt;&gt; output)
		cout &lt;&lt; output&lt;&lt;endl;
	return is;
}
</code></pre>
<p>习题8.10</p>
<pre><code>int main() {
	string file = &quot;test.txt&quot;;
	ifstream in(file);
	string s;
	vector&lt;string&gt; vs;
	while (in &gt;&gt; s)
		vs.push_back(s);
	for (auto i : vs) {
		istringstream is(i);
		string output;
		is &gt;&gt; output;
		cout &lt;&lt; output;
	}
}
</code></pre>
<p>习题8.11</p>
<pre><code>	istringstream is;
	for (auto i : vs) {
		is.str(i);
		string output;
		is &gt;&gt; output;
		cout &lt;&lt; output;
	}
</code></pre>
<p>知识点 如果在定义了istringstream而没有绑定string，可以在后面用str（s）绑定<br>
习题8.12<br>
<strong>PersonInfo是一个聚合类，此时不能定义初始值。</strong><br>
习题8.13<br>
其实把前面改成类似习题8.10就行了</p>
<pre><code>string file = &quot;test.txt&quot;;
	ifstream in(file);
	string s;
	while (getline(in,s))
</code></pre>
<p>习题8.14<br>
输出操作希望调用引用传递，但同时不希望拥有写入数据的权限</p>
<p>习题感悟<br>
badbit :流已崩溃  eofbit :流达到了文件结束位置  failbit ：IO操作失败 这三者置位时while(cin)会停止<br>
使用文件流需要添加<code>#include&lt;fstream&gt;</code><br>
main函数的形参只能通过命令行来输入<br>
如果在定义了istringstream而没有绑定string，可以在后面用str（s）绑定<br>
<strong>PersonInfo是一个聚合类，此时不能定义初始值。</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一个通用方法团灭 6 道股票问题 bylabuladong]]></title>
        <id>https://lixin-ee.github.io//post/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-bylabuladong</id>
        <link href="https://lixin-ee.github.io//post/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-bylabuladong">
        </link>
        <updated>2019-09-18T10:45:43.000Z</updated>
        <content type="html"><![CDATA[<p>作者：labuladong<br>
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/solution/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-w-5/<br>
来源：力扣（LeetCode）<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>这 6 道股票买卖问题是有共性的，我们通过对第四题（限制最大交易次数为 k）的分析一道一道解决。因为第四题是一个最泛化的形式，其他的问题都是这个形式的简化。</p>
<p>第一题是只进行一次交易，相当于 k = 1；第二题是不限交易次数，相当于 k = +infinity（正无穷）；第三题是最多只进行 2 次交易，相当于 k = 2；剩下两道也是不限次数，但是加了交易「冷冻期」和「手续费」的额外条件，其实就是第二题的变种，都很容易处理。</p>
<p>#一、穷举框架<br>
首先，还是一样的思路：如何穷举？这里的穷举思路和上篇文章递归的思想不太一样。</p>
<p>递归其实是符合我们思考的逻辑的，一步步推进，遇到无法解决的就丢给递归，一不小心就做出来了，可读性还很好。缺点就是一旦出错，你也不容易找到错误出现的原因。比如上篇文章的递归解法，肯定还有计算冗余，但确实不容易找到。</p>
<p>而这里，我们不用递归思想进行穷举，而是利用「状态」进行穷举。我们具体到每一天，看看总共有几种可能的「状态」，再找出每个「状态」对应的「选择」。我们要穷举所有「状态」，穷举的目的是根据对应的「选择」更新状态。听起来抽象，你只要记住「状态」和「选择」两个词就行，下面实操一下就很容易明白了。</p>
<pre><code>for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 择优(选择1，选择2...)
</code></pre>
<p>比如说这个问题，每天都有三种「选择」：买入、卖出、无操作，我们用 buy, sell, rest 表示这三种选择。但问题是，并不是每天都可以任意选择这三种选择的，因为 sell 必须在 buy 之后，buy 必须在 sell 之后。那么 rest 操作还应该分两种状态，一种是 buy 之后的 rest（持有了股票），一种是 sell 之后的 rest（没有持有股票）。而且别忘了，我们还有交易次数 k 的限制，就是说你 buy 还只能在 k &gt; 0 的前提下操作。<strong>（这里我觉得是有问题的，下文会提及，应该为k&lt;限制次数的时候才能买入）</strong></p>
<p>很复杂对吧，不要怕，我们现在的目的只是穷举，你有再多的状态，老夫要做的就是一把梭全部列举出来。这个问题的「状态」有三个，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨用 1 表示持有，0 表示没有持有）。然后我们用一个三维数组就可以装下这几种状态的全部组合：</p>
<pre><code>dp[i][k][0 or 1]
0 &lt;= i &lt;= n-1, 1 &lt;= k &lt;= K
n 为天数，大 K 为最多交易数
此问题共 n × K × 2 种状态，全部穷举就能搞定。

for 0 &lt;= i &lt; n:
    for 1 &lt;= k &lt;= K:
        for s in {0, 1}:
            dp[i][k][s] = max(buy, sell, rest)
</code></pre>
<p>而且我们可以用自然语言描述出每一个状态的含义，比如说 dp[3][2][1] 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 dp[2][3][0] 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。很容易理解，对吧？</p>
<p>我们想求的最终答案是 dp[n - 1][K][0]，即最后一天，最多允许 K 次交易，最多获得多少利润。读者可能问为什么不是 dp[n - 1][K][1]？因为 [1] 代表手上还持有股票，[0] 表示手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。</p>
<p>记住如何解释「状态」，一旦你觉得哪里不好理解，把它翻译成自然语言就容易理解了。</p>
<p>#二、状态转移框架<br>
现在，我们完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。只看「持有状态」，可以画个状态转移图。<br>
<img src="https://lixin-ee.github.io//post-images/1568804331349.png" alt=""><br>
通过这个图可以很清楚地看到，每种状态（0 和 1）是如何转移而来的。根据这个图，我们来写一下状态转移方程：</p>
<pre><code>dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
              max(   选择 rest  ,           选择 sell      )

解释：今天我没有持有股票，有两种可能：
要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；
要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。

dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
              max(   选择 rest  ,           选择 buy         )

解释：今天我持有着股票，有两种可能：
要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；
要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。
</code></pre>
<p>这个解释应该很清楚了，如果 buy，就要从利润中减去 prices[i]，如果 sell，就要给利润增加 prices[i]。今天的最大利润就是这两种可能选择中较大的那个。而且注意 k 的限制，我们在选择 buy 的时候，把 k 减小了 1，很好理解吧，当然你也可以在 sell 的时候减 1，一样的。<strong>（最大的问题在这里，我认为作者的本意是 buy 的时候，把 k 增加1）</strong><br>
现在，我们已经完成了动态规划中最困难的一步：状态转移方程。如果之前的内容你都可以理解，那么你已经可以秒杀所有问题了，只要套这个框架就行了。不过还差最后一点点，就是定义 base case，即最简单的情况。</p>
<pre><code>dp[-1][k][0] = 0
解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。
dp[-1][k][1] = -infinity
解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。
dp[i][0][0] = 0
解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。
dp[i][0][1] = -infinity
解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。
</code></pre>
<p>把上面的状态转移方程总结一下：</p>
<pre><code>base case：
dp[-1][k][0] = dp[i][0][0] = 0
dp[-1][k][1] = dp[i][0][1] = -infinity

状态转移方程：
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
</code></pre>
<p>读者可能会问，这个数组索引是 -1 怎么编程表示出来呢，负无穷怎么表示呢？这都是细节问题，有很多方法实现。现在完整的框架已经完成，下面开始具体化。</p>
<p>#三、秒杀题目<br>
第一题，k = 1</p>
<p>直接套状态转移方程，根据 base case，可以做一些化简：</p>
<pre><code>dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])
dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) （注意 dp[i-1][0][0]等于第i-1天都还没买入过一次）
            = max(dp[i-1][1][1], -prices[i])
解释：k = 0 的 base case，所以 dp[i-1][0][0] = 0。

现在发现 k 都是 1，不会改变，即 k 对状态转移已经没有影响了。
可以进行进一步化简去掉所有 k：
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][1], -prices[i])
</code></pre>
<p>直接写出代码：</p>
<pre><code>
int n = prices.length;
int[][] dp = new int[n][2];
for (int i = 0; i &lt; n; i++) {
    dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
    dp[i][1] = Math.max(dp[i-1][1], -prices[i]);
}
return dp[n - 1][0];
</code></pre>
<p>显然 i = 0 时 dp[i-1] 是不合法的。这是因为我们没有对 i 的 base case 进行处理。可以这样处理：</p>
<pre><code>
for (int i = 0; i &lt; n; i++) {
    if (i - 1 == -1) {
        dp[i][0] = 0;
        // 解释：
        //   dp[i][0] 
        // = max(dp[-1][0], dp[-1][1] + prices[i])
        // = max(0, -infinity + prices[i]) = 0
        dp[i][1] = -prices[i];
        //解释：
        //   dp[i][1] 
        // = max(dp[-1][1], dp[-1][0] - prices[i])
        // = max(-infinity, 0 - prices[i]) 
        // = -prices[i]
        continue;
    }
    dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
    dp[i][1] = Math.max(dp[i-1][1], -prices[i]);
}
return dp[n - 1][0];
</code></pre>
<p>第一题就解决了，但是这样处理 base case 很麻烦，而且注意一下状态转移方程，新状态只和相邻的一个状态有关，其实不用整个 dp 数组，只需要一个变量储存相邻的那个状态就足够了，这样可以把空间复杂度降到 O(1):</p>
<pre><code>
// k == 1
int maxProfit_k_1(int[] prices) {
    int n = prices.length;
    // base case: dp[-1][0] = 0, dp[-1][1] = -infinity
    int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;
    for (int i = 0; i &lt; n; i++) {
        // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
        // dp[i][1] = max(dp[i-1][1], -prices[i])
        dp_i_1 = Math.max(dp_i_1, -prices[i]);
    }
    return dp_i_0;
}
</code></pre>
<p>两种方式都是一样的，不过这种编程方法简洁很多。但是如果没有前面状态转移方程的引导，是肯定看不懂的。后续的题目，我主要写这种空间复杂度 O(1) 的解法。</p>
<p>第二题，k = +infinity</p>
<p>如果 k 为正无穷，那么就可以认为 k 和 k - 1 是一样的。可以这样改写框架：</p>
<pre><code>dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
            = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i])
</code></pre>
<p>我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了：</p>
<pre><code>dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])
</code></pre>
<p>直接翻译成代码：</p>
<pre><code>int maxProfit_k_inf(int[] prices) {
    int n = prices.length;
    int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;
    for (int i = 0; i &lt; n; i++) {
        int temp = dp_i_0;
        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
        dp_i_1 = Math.max(dp_i_1, temp - prices[i]);
    }
    return dp_i_0;
}
</code></pre>
<p>第三题，k = +infinity with cooldown</p>
<p>每次 sell 之后要等一天才能继续交易。只要把这个特点融入上一题的状态转移方程即可：</p>
<p>dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])<br>
dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])<br>
解释：第 i 天选择 buy 的时候，要从 i-2 的状态转移，而不是 i-1 。<br>
翻译成代码：</p>
<p>int maxProfit_with_cool(int[] prices) {<br>
int n = prices.length;<br>
int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;<br>
int dp_pre_0 = 0; // 代表 dp[i-2][0]<br>
for (int i = 0; i &lt; n; i++) {<br>
int temp = dp_i_0;<br>
dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);<br>
dp_i_1 = Math.max(dp_i_1, dp_pre_0 - prices[i]);<br>
dp_pre_0 = temp;<br>
}<br>
return dp_i_0;<br>
}</p>
<p>第四题，k = +infinity with fee</p>
<p>每次交易要支付手续费，只要把手续费从利润中减去即可。改写方程：</p>
<pre><code>dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i] - fee)
解释：相当于买入股票的价格升高了。
在第一个式子里减也是一样的，相当于卖出股票的价格减小了。
</code></pre>
<p>直接翻译成代码：</p>
<pre><code>int maxProfit_with_fee(int[] prices, int fee) {
    int n = prices.length;
    int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;
    for (int i = 0; i &lt; n; i++) {
        int temp = dp_i_0;
        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
        dp_i_1 = Math.max(dp_i_1, temp - prices[i] - fee);
    }
    return dp_i_0;
}
</code></pre>
<p>第五题，k = 2</p>
<p>k = 2 和前面题目的情况稍微不同，因为上面的情况都和 k 的关系不太大。要么 k 是正无穷，状态转移和 k 没关系了；要么 k = 1，跟 k = 0 这个 base case 挨得近，最后也没有存在感。</p>
<p>这道题 k = 2 和后面要讲的 k 是任意正整数的情况中，对 k 的处理就凸显出来了。我们直接写代码，边写边分析原因。</p>
<p>原始的动态转移方程，没有可化简的地方</p>
<pre><code>dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
</code></pre>
<p>按照之前的代码，我们可能想当然这样写代码（错误的）：</p>
<pre><code>int k = 2;
int[][][] dp = new int[n][k + 1][2];
for (int i = 0; i &lt; n; i++)
    if (i - 1 == -1) { /* 处理一下 base case*/ }
    dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
    dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);
}
return dp[n - 1][k][0];
</code></pre>
<p>为什么错误？我这不是照着状态转移方程写的吗？</p>
<p>还记得前面总结的「穷举框架」吗？就是说我们必须穷举所有状态。其实我们之前的解法，都在穷举所有状态，只是之前的题目中 k 都被化简掉了。这道题由于没有消掉 k 的影响，所以必须要对 k 进行穷举：</p>
<pre><code>int max_k = 2;
int[][][] dp = new int[n][max_k + 1][2];
for (int i = 0; i &lt; n; i++) {
    for (int k = max_k; k &gt;= 1; k--) { //**按照之前的问题，此处我认为k应从1开始递增**
        if (i - 1 == -1) { /*处理 base case */ }
        dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
        dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);
    }
}
// 穷举了 n × max_k × 2 个状态，正确。
return dp[n - 1][max_k][0];
</code></pre>
<p>如果你不理解，可以返回第一点「穷举框架」重新阅读体会一下。</p>
<p>这里 k 取值范围比较小，所以可以不用 for 循环，直接把 k = 1 和 2 的情况手动列举出来也可以：</p>
<pre><code>dp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])
dp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])
dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])
dp[i][1][1] = max(dp[i-1][1][1], -prices[i])

int maxProfit_k_2(int[] prices) {
    int dp_i10 = 0, dp_i11 = Integer.MIN_VALUE;
    int dp_i20 = 0, dp_i21 = Integer.MIN_VALUE;
    for (int price : prices) {
        dp_i20 = Math.max(dp_i20, dp_i21 + price);
        dp_i21 = Math.max(dp_i21, dp_i10 - price);
        dp_i10 = Math.max(dp_i10, dp_i11 + price);
        dp_i11 = Math.max(dp_i11, -price);
    }
    return dp_i20;
}
</code></pre>
<p>有状态转移方程和含义明确的变量名指导，相信你很容易看懂。其实我们可以故弄玄虚，把上述四个变量换成 a, b, c, d。这样当别人看到你的代码时就会一头雾水，大惊失色，不得不对你肃然起敬。</p>
<p>第六题，k = any integer<br>
有了上一题 k = 2 的铺垫，这题应该和上一题的第一个解法没啥区别。但是出现了一个超内存的错误，原来是传入的 k 值会非常大，dp 数组太大了。现在想想，交易次数 k 最多有多大呢？<br>
一次交易由买入和卖出构成，至少需要两天。所以说有效的限制 k 应该不超过 n/2，如果超过，就没有约束作用了，相当于 k = +infinity。这种情况是之前解决过的。<br>
直接把之前的代码重用：</p>
<pre><code>int maxProfit_k_any(int max_k, int[] prices) {
    int n = prices.length;
    if (max_k &gt; n / 2) 
        return maxProfit_k_inf(prices);

    int[][][] dp = new int[n][max_k + 1][2];
    for (int i = 0; i &lt; n; i++) 
        for (int k = max_k; k &gt;= 1; k--) {
            if (i - 1 == -1) { 
                /* 处理 base case */
                dp[i][k][0] = 0;
                dp[i][k][1] = -prices[i];
                continue;
            }
            dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
            dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);     
        }
    return dp[n - 1][max_k][0];
}
</code></pre>
<p>四、最后总结<br>
本文给大家讲了如何通过状态转移的方法解决复杂的问题，用一个状态转移方程秒杀了 6 道股票买卖问题，现在想想，其实也不算难对吧？这已经属于动态规划问题中较困难的了。<br>
关键就在于列举出所有可能的「状态」，然后想想怎么穷举更新这些「状态」。一般用一个多维 dp 数组储存这些状态，从 base case 开始向后推进，推进到最后的状态，就是我们想要的答案。想想这个过程，你是不是有点理解「动态规划」这个名词的意义了呢？<br>
具体到股票买卖问题，我们发现了三个状态，使用了一个三维数组，无非还是穷举 + 更新，不过我们可以说的高大上一点，这叫「三维 DP」，怕不怕？这个大实话一说，立刻显得你高人一等，名利双收有没有。<br>
所以，大家不要被各种高大上的名词吓到，再多的困难问题，奇技淫巧，也不过是基本套路的不断升级组合产生的。只要把住算法的底层原理，即可举一反三，逐个击破。</p>
<p>作者：labuladong<br>
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/solution/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-w-5/<br>
来源：力扣（LeetCode）<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 188. 买卖股票的最佳时机 IV]]></title>
        <id>https://lixin-ee.github.io//post/188-mai-mai-gu-piao-de-zui-jia-shi-ji-iv</id>
        <link href="https://lixin-ee.github.io//post/188-mai-mai-gu-piao-de-zui-jia-shi-ji-iv">
        </link>
        <updated>2019-09-18T10:44:29.000Z</updated>
        <content type="html"><![CDATA[<p>原题目</p>
<blockquote>
<p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。<br>
设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。<br>
注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:<br>
输入: [2,4,1], k = 2<br>
输出: 2<br>
解释: 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。<br>
示例 2:<br>
输入: [3,2,6,5,0,3], k = 2<br>
输出: 7<br>
解释: 在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。<br>
     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>参考股票买卖问题的动态规划，可以得出本次与前面的题的差别在于k等于不定值，既可以等于无限，也可以等于特定值，坑也是在这个上面，由于和之前的差不多，我直接加工了之前的代码，主要是增加了k和n/2的对比，主要是想限制k的不合理值，降低维数：</p>
<pre><code>class Solution {
public:
    int maxProfit(int k, vector&lt;int&gt;&amp; prices) {
         const int n = prices.size();
        if(n==0||n==1)
            return 0;
	const int max_k = k&lt;n/2?k:n/2;
	vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(n, vector&lt;vector&lt;int&gt;&gt;(max_k+1, vector&lt;int&gt;(2,0)));
	for (int i = 0; i &lt; n; i++) {
		for (int k = 1; k &lt;=max_k; k++) {
			if (i - 1 == -1) { 
				dp[0][k][0] = 0 ;
				dp[0][k][1] = - prices[0];
			}
			else {
				dp[i][k][0] = dp[i - 1][k][0]&gt;dp[i - 1][k][1] + prices[i] ? dp[i - 1][k][0] : dp[i - 1][k][1] + prices[i];
				dp[i][k][1] = dp[i - 1][k][1]&gt;dp[i - 1][k - 1][0] - prices[i] ? dp[i - 1][k][1] : dp[i - 1][k - 1][0] - prices[i];
			}
		}
	}
	return dp[n - 1][max_k][0];
    }
};
</code></pre>
<p>结果显示内存爆炸，出问题的用例是：<br>
1000000000<br>
[106,373,495,46,359,919,906,440,783,583,784,73,238,701,972,308,165,774,990,675,737,990,713,157,211,880,961,132,980,...]</p>
<p>k值我是处理过的，不应该是它的影响，然后翻看了题解中其他人也有这个问题，最后仔细思考了一下，发现一个比较奇葩的问题，虽然代码是对的，但是其实k&gt;n/2的时候已经等于无限购买次数的情况了，那就和题目二的情况一样了，完全可以使用题目二的代码来取消k的作用，降低维数，所以给出代码如下：</p>
<pre><code>class Solution {
public:
    int maxProfit(int k, vector&lt;int&gt;&amp; prices) {
         const int n = prices.size();
        if(n==0||n==1)
            return 0;
        if(k&gt;n/2){
            int len=prices.size();
        int max=0;
        vector&lt;int&gt; profit(len,0);
        for(int i=1;i&lt;len;++i)
            profit[i]=prices[i]-prices[i-1];
        for(int i=0;i&lt;len;++i)
            if(profit[i]&gt;0)
                max +=profit[i];
        return max;
            
        }
	const int max_k = k;
	vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(n, vector&lt;vector&lt;int&gt;&gt;(max_k+1, vector&lt;int&gt;(2,0)));
	for (int i = 0; i &lt; n; i++) {
		for (int k = 1; k &lt;=max_k; k++) {
			if (i - 1 == -1) { 
				dp[0][k][0] = 0 ;
				dp[0][k][1] = - prices[0];
			}
			else {
				dp[i][k][0] = dp[i - 1][k][0]&gt;dp[i - 1][k][1] + prices[i] ? dp[i - 1][k][0] : dp[i - 1][k][1] + prices[i];
				dp[i][k][1] = dp[i - 1][k][1]&gt;dp[i - 1][k - 1][0] - prices[i] ? dp[i - 1][k][1] : dp[i - 1][k - 1][0] - prices[i];
			}
		}
	}
	return dp[n - 1][max_k][0];
    }
};
</code></pre>
<p>最后顺利通过，虽然花的时间还是比较多，不过通过这一次还是认识到不能简单地照搬代码，还是得老老实实地思考优化等方面的问题！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第七章 笔记+习题 7.4-7.6]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-qi-zhang-bi-ji-xi-ti-74-76</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-qi-zhang-bi-ji-xi-ti-74-76">
        </link>
        <updated>2019-09-17T11:33:12.000Z</updated>
        <content type="html"><![CDATA[<p>7.4<br>
一个类就是一个作用域<br>
一旦遇到类名，定义的剩余部分就在类的作用域之内了，包括<strong>参数列表和函数体</strong>，所以参数列表内的参数不需要再声明类<br>
但返回类型出现在类名之前，所以要想把类成员作为返回类型，<strong>必须在返回类型前加上类名</strong></p>
<p>习题7.33<br>
pos的作用域并不在类里面，需要改成Screen::pos</p>
<p>7.4.1名字查找与类的作用域<br>
编译器处理完类中的<strong>全部声明后才会处理成员函数的定义</strong>，所以成员函数体中可以使用类中定义的任何名字，<strong>但是类型名不同，必须定义在一开始，否则会找不到</strong><br>
如果某个成员的声明使用了类中尚未出现的名字，编译器将会在定义该类的作用域中继续查找<br>
如果成员使用了外层作用域中的某个名字，<strong>则该名字代表一种类型</strong>，类不可以在之后重新定义该名字，合法但不应该在类内重新定义<br>
typedef int type_out;  class C{ type_out i; typedef double type_out;//<strong>合法但不应该</strong>在类内重新定义}<br>
类型名的定义通常出现在类的开始处（using typedef）<br>
可以通过作用域运算符来访问不同作用域中的同名运算符</p>
<p>习题7.34<br>
有问题！！类型名和类数据成员名字不同，必须定义在一开始，否则会找不到<br>
习题7.35<br>
类内不应该再定义Type 但合法，所以内部的都是 double，但 外部定义的函数返回类型用的是string的Type</p>
<p>7.5.1构造函数初始值列表<br>
我们定义变量时习惯于立即对其进行初始化，而非先定义再赋值<br>
如果没有在构造函数的初始值列表中显式地初始化成员，则该成员将在构造函数体之前执行<strong>默认初始化</strong><br>
如果成员是<strong>const、引用，或者属于某种未提供默认构造函数的类类型</strong>，我们必须通过构造函数初始值列表为这些成员提供初值初始化，不能通过后续赋值<br>
在初始值列表中初始值的前后位置关系不会影响实际的初始化顺序<br>
最好令构造函数初始值列表中初始值的顺序与成员声明的顺序保持一致，而且尽量避免使用某些成员初始化其他成员，最好用构造函数的参数作为成员的初始值<br>
默认构造函数和提供了默认实参的构造函数功能相同<br>
如果一个构造函数为<strong>所有参数提供了默认实参，则它实际上也定义了默认构造函数</strong><br>
并非所有的参数都应该有一个默认值</p>
<p>习题7.36<br>
其实是合法的，只是不应该使用base，因为在初始值列表中初始值的前后位置关系不会影响实际的初始化顺序，所以base%J是未知的<br>
习题7.37<br>
第一种调用了第三个 next调用了第一个默认函数  last调用了第一个为&quot;9-999-99999-9&quot;<br>
知识点：如果一个构造函数为<strong>所有参数提供了默认实参，则它实际上也定义了默认构造函数</strong><br>
习题7.38<br>
Sales_data(std::istream &amp;is){ read(is,*this);}<br>
习题7.39<br>
不合法，这样子它就定义了两个默认构造函数，有二义性<br>
知识点：如果一个构造函数为<strong>所有参数提供了默认实参，则它实际上也定义了默认构造函数</strong><br>
习题7.40</p>
<pre><code> class Employee
{   
string EmployeeID;//员工号
string name;//员工姓名
int age;//员工年龄
char sex;//员工性别
string CompanyName;//所属公司
}
</code></pre>
<p>7.5.2委托构造函数<br>
委托构造函数，使用其所在类中的其他构造函数来执行它想要的初始化过程<br>
委托构造函数参数列表必须与类中的另外一个构造函数匹配<br>
当一个构造函数委托给另一个构造函数时，<strong>受委托的构造函数的初始值列表和函数体中的内容依次执行，然后控制权才会交还给委托着的函数体</strong>（例子中的{read(is,*this);}）</p>
<p>习题7.41</p>
<pre><code>Sales_Data(string &amp;s,int &amp;i,double &amp;p,double &amp;a):ISBN(s),units_sold(i),price(p),ave(a){ cout &lt;&lt; &quot;three parameters construction&quot; &lt;&lt; endl; }
		Sales_Data(string &amp;s) :Sales_Data(s, 0, 0) { cout &lt;&lt; &quot;string construction&quot; &lt;&lt; endl; }
		Sales_Data(istream &amp;is) :Sales_Data() { read(is, *this); cout &lt;&lt; &quot;istream construction&quot; &lt;&lt; endl;
		}
		Sales_Data() :Sales_Data(&quot; &quot;, 0, 0) { cout &lt;&lt; &quot;default construction&quot; &lt;&lt; endl; }
</code></pre>
<p>习题7.42<br>
其实就和7.41差不多啦！</p>
<p>7.5.3默认构造函数的作用<br>
value initialization<br>
那么如果在list initialization形式中，没有任何args，也就是<br>
[new] T [object] {};<br>
这时就称为值初始化。这个初始化类型的名字其实有点不明确，按我的理解，实质应该叫做“广义默认初始化”。因为值初始化一般是三种处理方式：<br>
如果T有用户定义的默认构造函数，直接调用；<br>
如果T有编译器生成的默认构造函数，先0值初始化再调用；<br>
如果T根本不是类，直接0值初始化。<br>
而以上三种其实都可以看作默认初始化。<br>
default initialization<br>
[new] T object;<br>
默认初始化除了在值初始化过程中可能进行之外，也可以以上面形式单独进行。这种初始化的独特地方在于，如果T是非class类型，则给出非确定值（不赋值），比如：<br>
int i; double d; bool b;<br>
其实这也就是兼容最早的C行为。<br>
zero initialization<br>
0值初始化除了在值初始化过程中可能进行之外，也可以单独作用于静态（或者线程局部）变量：<br>
static T object;</p>
<p>小结<br>
所有其他初始化形式都是list initialization的特殊表现形式或者与其相关。理解的要点在于，list中的参数要么按构造函数的参数声明顺序，要么按aggregate类型成员声明顺序，逐个赋值。当某些成员没有被这样显示给定值时，进行广义默认初始化（value initialization）：或调用默认构造函数，或赋0值。这么看来，这一堆初始化其实挺符合我们的一贯认知。<br>
习题 7.43</p>
<pre><code>class C{
	NoDefault D;
	C():D(0){}
}
</code></pre>
<p>习题7.44<br>
不合法，NoDefault是一个类，仅仅定义了有十个NoDefault类型的对象，而NoDefault没有默认构造函数，必须初始化<br>
习题7.45<br>
合法，有默认构造函数，可以进行值初始化<br>
习题7.46<br>
（a）错误 系统会自动合成（b）错误 所有形参都有默认实参的也是默认构造函数 （c）不对，应该提供 （d）错误，数据成员类型为类类型时，无法生成默认构造函数</p>
<p>7.5.4隐式的类类型转换<br>
如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，并把这种构造函数称作转换构造函数。比如Sales_data类中，接受string的构造函数实际上定义了string向Sales_data隐式转换的规则，在需要使用Sales_data的地方可以使用string来代替。 比如 string s=”9-999-99999-9”; item.combine(s);//combine为Sales_data的成员<strong>可以给常量引用传递一个临时量！普通引用的话这里会报错</strong><br>
编译器只会自动地执行一步类型转换，而不能进行连续两次隐式类型转换,比如：item.combine(”9-999-99999-9”);//先转为string，再转为类类型。<strong>(注意此处是指需要类类型的地方，而不是指构造函数，Sales_data item(“9-999-99999-9”)还是正确的)</strong> 可以Sales_data item（string（“9-999-99999-9”））<br>
<strong>explicit</strong>抑制构造函数定义的隐式转换，只对一个实参的构造函数有效<br>
需要多个实参的构造函数不能用于执行隐式转换，所以无须将这些构造函数指定为explicit<br>
explicit只能在类内声明构造函数时使用，在类外部定义时不应该重复<br>
使用explicit关键字声明构造函数时只能以直接初始化的形式（括号）使用，而且编译器不会在自动转换过程中使用该构造函数<br>
仍可以对explicit声明的构造函数进行显式地强制转换 item.combine(Sales_data(s));</p>
<p>习题7.47<br>
优点：防止用户用了错误的类型进行初始化从而得到不符合初衷的值，保证了程序的严谨性，缺点就是可能要进行显式转换。<br>
习题7.48<br>
（a）const char* 到string的转换<br>
（b）string 到类类型的转换<br>
（c）正确，<br>
习题7.49<br>
（b）错误，无法从string向引用进行转换（a）和（c）都是正确的<br>
知识点：<strong>可以给常量引用传递一个临时量！</strong><br>
习题7.50<br>
单个参数的构造函数都可以设置为explicit<br>
习题7.51<br>
string需要向下兼容c语言，而vector不需要</p>
<p>7.5.5聚合类<br>
聚合类使得用户可以直接访问其成员，并且具有特殊的初始化语法<br>
聚合类的特性：1.所有成员都是public的2.没有定义任何构造函数3，<strong>没有类内初始值</strong>4.没有基类，也没有virtual函数<br>
对聚合类进行初始化的初始值的顺序<strong>必须与声明的顺序一致</strong>，且初始值列表的元素个数不能超过类的成员数量 例如 struct Data{int ival; string s}   Data val={0,”Anna”};//这里的顺序不可以反过来<br>
如果初始值列表中的元素个数<strong>少于</strong>类的成员数量，<strong>则靠后的成员被值初始化</strong></p>
<p>习题7.52<br>
下面的初始化希望将Sales_data 视为一个聚合类，但是Sales_data的数据成员具有初始值，所以无法当做聚合类进行初始化，并且没有合适的构造函数，两个解决办法 1.去掉初始值，变为聚合类 2.增加接受三个参数的构造函数</p>
<p>7.5.6字面值常量类<br>
构造函数<strong>不可以是const</strong>的，但<strong>字面值常量类的构造函数可以是constexpr函数</strong>，并且必须至少提供一个constexpr构造函数<br>
constexpr构造函数必须符合<strong>构造函数的要求（不能包含返回语句）</strong>，又要<strong>符合constexpr函数的要求（只能执行返回语句）</strong>，所以constexpr构造函数体<strong>一般为空</strong><br>
constexpr构造函数<strong>必须初始化所有数据成员</strong></p>
<p>习题7.53</p>
<pre><code>class Debug
{
public:
	constexpr Debug(bool b=true):hw(b),io(b),other(b){}
	constexpr Debug(bool h ,bool i,bool o) : hw(h),io(i), other(o) {}
	void set_hw(bool h = true) { hw = h; }
	void set_io(bool i = true) { io = i; }
	void set_other(bool o = true) { other = o; }
private:
	bool hw;
	bool io;
	bool other;

};
</code></pre>
<p>习题7.54<br>
不应该，set需要执行相应的赋值操作。同时constexpr函数必须有返回值和返回语句<br>
习题7.55<br>
不是。字面值常量类至少必须含有一个constexpr构造函数，同时string不是字面值类型</p>
<p>7.6 类的静态成员<br>
static 静态成员<strong>与类关联，而与特定的对象无关（等于每个对象都可以通用的成员）所以静态成员应该在类外定义，否则每创建一个对象就会被定义一次</strong><br>
静态成员可以是private或者public，静态数据成员的类型可以是常量、引用、指针、类类型等等。<br>
类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据，同时静态成员函数<strong>也不与任何对象绑定在一起，不包含this 指针，不能被声明为const</strong><br>
使用作用域运算符来直接访问静态成员，也可以使用类的对象、引用或者指针来访问<br>
成员函数不用通过作用域运算符就能直接使用静态成员<br>
静态成员函数也可以在类外部进行定义，<strong>但不能重复static关键字</strong>，static只出现在类内部的声明语句<br>
<strong>静态成员不是由类的构造函数初始化的</strong>，不能在类的内部初始化静态成员，<strong>必须在类的外部定义和初始化每个静态成员</strong><br>
一个静态数据成员只能定义一次<br>
静态数据成员定义在任何函数之外，因此存在于程序的整个生命周期中<br>
把静态数据成员的定义和其他非内联函数的定义放在同一个文件中，确保对象只定义一次<br>
例外：可以在类内部初始化constexpr的静态成员，但必须提供const整数类型的类内初始值（常量表达式） 例如 static constexpr int i =10;//<strong>必须是constexpr，不能是const</strong><br>
如果仅仅用于类内，则在类内已经初始化的const或者constexpr static不需要分别定义，否则必须有一条定义语句<br>
特别地，<strong>静态数据成员的类型可以是它所属的类类型</strong>（等于不完全类型），而<strong>非静态数据成员只能声明成它所属的类的指针或引用</strong><br>
静态成员<strong>可以作为默认实参</strong>，非静态数据成员则不能</p>
<p>习题7.56<br>
类的静态成员只与类相关联，而与特定的对象无关，优点在于可以独立于特定的对象 ，其作用域存在与整个程序运行期间。<br>
习题7.57</p>
<pre><code>class Account
{
	static constexpr int period = 30;
	double daily_tbl[period];
	std::string owner;
	double amount;
	static double interestRate;
	static double initRate();
public:
	static double rate() { return interestRate; }
	static void rate(double);
};
</code></pre>
<p>习题7.58<br>
rate显示定义错误，必须为常量成员。需要加上const或者constexpr<br>
vec在类内的定义被误认为是要定义一个函数了，它的直接初始化和函数定义的括号是冲突的，从而显示从vecsize不是类型名，应该在外部声明时才使用example::vec(example::vecsize)<br>
vec显示声明不兼容，两个声明冲突了；</p>
<p>习题感悟<br>
类型名和类数据成员名字不同，必须定义在一开始，否则会找不到<br>
如果成员使用了外层作用域中的某个名字，<strong>则该名字代表一种类型</strong>，类不可以在之后重新定义该名字，合法但不应该<strong>在类内重新定义</strong><br>
在初始值列表中初始值的前后位置关系不会影响实际的初始化顺序，所以用一个成员来初始化另一个成员，结果是未知的<br>
如果一个构造函数为<strong>所有参数提供了默认实参，则它实际上也定义了默认构造函数</strong><br>
可以给常量引用传递一个临时量！<br>
可以在类内部初始化constexpr的静态成员，但必须提供const整数类型的类内初始值（常量表达式） 例如 static constexpr int i =10;//<strong>必须是constexpr，不能是const</strong><br>
<code>static constexpr int vecsize = 20; vector&lt;double&gt; vec(vecsize);</code><br>
vec在类内的定义被误认为是要定义一个函数了，它的直接初始化和函数定义的括号是冲突的，从而显示从vecsize不是类型名，应该在外部声明时才使用</p>
]]></content>
    </entry>
</feed>