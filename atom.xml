<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-09-30T13:53:40.164Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[三种线性排序算法 计数排序、桶排序与基数排序]]></title>
        <id>https://lixin-ee.github.io//post/san-chong-xian-xing-pai-xu-suan-fa-ji-shu-pai-xu-tong-pai-xu-yu-ji-shu-pai-xu</id>
        <link href="https://lixin-ee.github.io//post/san-chong-xian-xing-pai-xu-suan-fa-ji-shu-pai-xu-tong-pai-xu-yu-ji-shu-pai-xu">
        </link>
        <updated>2019-09-30T13:00:57.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章对应的就是前面的算法题 <a href="https://lixin-ee.github.io/post/shu-zu-164-zui-da-jian-ju/">数组164.最大间距</a>，今天在地铁上特地重新复习了一下排序算法<br>
本文主要参考了<a href="https://www.byvoid.com/zhs/blog/sort-radix">BYVoid 原创讲解</a><br>
其实比较常用的算法是基于比较的算法，因为在面对超长数组的时候内存是最大的制掣因素。<br>
众所周知，基于比较的排序算法是不能突破O(NlogN)的。简单证明如下：<br>
N个数有N!个可能的排列情况，也就是说基于比较的排序算法的判定树有N!个叶子结点，比较次数至少为log(N!)=O(NlogN)(斯特林公式)。</p>
<p>但有趣的事，非基于比较的排序，如计数排序，桶排序，和在此基础上的基数排序，则可以突破O(NlogN)时间下限。<strong>但要注意的是，非基于比较的排序算法的使用都是有条件限制的，例如元素的大小限制</strong>，相反，基于比较的排序则没有这种限制(在一定范围内)。但并非因为有条件限制就会使非基于比较的排序算法变得无用，对于特定场合有着特殊的性质数据，非基于比较的排序算法则能够非常巧妙地解决。</p>
<p>[计数排序]<br>
首先从计数排序(Counting Sort)开始介绍起，假设我们有一个待排序的整数序列A，其中元素的最小值不小于0，最大值不超过K。建立一个长度为K的线性表C，用来记录不大于每个值的元素的个数。</p>
<p>算法思路如下：</p>
<p>扫描序列A，以A中的每个元素的值为索引，把出现的个数填入C中。此时C[i]可以表示A中值为i的元素的个数。<br>
对于C从头开始累加，使C[i]&lt;-C[i]+C[i-1]。这样，C[i]就表示A中值不大于i的元素的个数。<br>
按照统计出的值，输出结果。<br>
由线性表C我们可以很方便地求出排序后的数据，定义B为目标的序列，Order[i]为排名第i的元素在A中的位置，则可以用以下方法统计。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
using namespace std;
void CountingSort(int *A,int *B,int *Order,int N,int K)
{
    int *C=new int[K+1];
    int i;
    memset(C,0,sizeof(int)*(K+1));
    for (i=1;i&lt;=N;i++) //把A中的每个元素分配
        C[A[i]]++;
    for (i=2;i&lt;=K;i++) //统计不大于i的元素的个数
        C[i]+=C[i-1];
    for (i=N;i&gt;=1;i--)
    {
        B[C[A[i]]]=A[i]; //按照统计的位置，将值输出到B中，将顺序输出到Order中
        Order[C[A[i]]]=i;
        C[A[i]]--;
    }
}
int main()
{
    int *A,*B,*Order,N=15,K=10,i;
    A=new int[N+1];
    B=new int[N+1];
    Order=new int[N+1];
    for (i=1;i&lt;=N;i++)
        A[i]=rand()%K+1; //生成1..K的随机数
    printf(&quot;Before CS:\n&quot;);
    for (i=1;i&lt;=N;i++)
        printf(&quot;%d &quot;,A[i]);
    CountingSort(A,B,Order,N,K);
    printf(&quot;\nAfter CS:\n&quot;);
    for (i=1;i&lt;=N;i++)
        printf(&quot;%d &quot;,B[i]);
    printf(&quot;\nOrder:\n&quot;);
    for (i=1;i&lt;=N;i++)
        printf(&quot;%d &quot;,Order[i]);
    return 0;
}
程序运行效果如下：

Before CS:
2 8 5 1 10 5 9 9 3 5 6 6 2 8 2
After CS:
1 2 2 2 3 5 5 5 6 6 8 8 9 9 10
Order:
4 1 13 15 9 3 6 10 11 12 2 14 7 8 5
</code></pre>
<p>我们可以看到，计数排序的要点在于1.提前知道数组的取值范围 2.取值范围K在内存能够接受的范围内。3.通过反向操作保证其为稳定排序算法。<br>
计数排序的时间复杂度为O(N+K)，空间复杂度为O(N+K)。当K不是很大时，这是一个很有效的线性排序算法。更重要的是，它是一种<strong>稳定排序算法</strong>，即排序后的相同值的元素原有的相对位置不会发生改变(表现在Order上)，这是计数排序很重要的一个性质，就是根据这个性质，我们才能把它应用到基数排序。</p>
<p>[桶排序]<br>
在读计数排序的代码时我发现了一个问题，一是如果重复的元素越多，浪费的空间就越多，比如有很多个2的时候。二是计数排序似乎饶了点弯子，比如当我们刚刚统计出C，C[i]可以表示A中值为i的元素的个数，此时我们直接顺序地扫描C，就可以求出排序后的结果。的确是这样，不过这种方法不再是计数排序，而是桶排序(Bucket Sort)，确切地说，是桶排序的一种特殊情况，但是直接顺序搜索c得到的的桶排序是不稳定的，同时也需要占到太多的额外空间。（不要小看稳定，单个数组看不出来问题所在，如果是map这种分为key-value和map-value的，把key-value弄乱了就出大事了）<br>
正式的桶排序如下：<br>
首先定义桶，桶为一个数据容器，每个桶存储一个区间内的数。依然有一个待排序的整数序列A，元素的最小值不小于0，最大值不超过K。假设我们有M个桶，第i个桶Bucket[i]存储i*K/M至(i+1)K/M之间的数，有如下桶排序的一般方法：</p>
<p>扫描序列A，根据每个元素的值所属的区间，放入指定的桶中(顺序放置)。<br>
对每个桶中的元素进行排序，什么排序算法都可以，例如快速排序。<br>
依次收集每个桶中的元素，顺序放置到输出序列中。<br>
对该算法简单分析，如果数据是期望平均分布的，则每个桶中的元素平均个数为N/M。如果对每个桶中的元素排序使用的算法是快速排序，每次排序的时间复杂度为O(N/Mlog(N/M))。则总的时间复杂度为O(N)+O(M)O(N/Mlog(N/M)) = O(N+ Nlog(N/M)) = O(N + NlogN - NlogM)。当M接近于N是，桶排序的时间复杂度就可以近似认为是O(N)的。就是桶越多，时间效率就越高，而桶越多，空间却就越大，由此可见时间和空间是一个矛盾的两个方面。</p>
<p>桶中元素的顺序放入和顺序取出是有必要的，因为这样可以确定桶排序是一种稳定排序算法，配合基数排序是很好用的。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
using namespace std;
struct linklist
{
    linklist *next;
    int value;
    linklist(int v,linklist *n):value(v),next(n){}
    ~linklist() {if (next) delete next;}
};
inline int cmp(const void *a,const void *b)
{
    return *(int *)a-*(int *)b;
}
</code></pre>
<p>为了方便，我把A中元素加入桶中时是倒序放入的，而收集取出时也是倒序放入序列的，所以不违背稳定排序。</p>
<pre><code>void BucketSort(int *A,int *B,int N,int K)
{
    linklist *Bucket[101],*p;//建立桶
    int i,j,k,M;
    M=K/100;
    memset(Bucket,0,sizeof(Bucket));
    for (i=1;i&lt;=N;i++)
    {
        k=A[i]/M; //把A中的每个元素按照的范围值放入对应桶中
        Bucket[k]=new linklist(A[i],Bucket[k]);
    }
    for (k=j=0;k&lt;=100;k++)
    {
        i=j;
        for (p=Bucket[k];p;p=p-&gt;next)
            B[++j]=p-&gt;value; //把桶中每个元素取出，排序并加入B
        delete Bucket[k];
        qsort(B+i+1,j-i,sizeof(B[0]),cmp);
    }
}
int main()
{
    int *A,*B,N=100,K=10000,i;
    A=new int[N+1];
    B=new int[N+1];
    for (i=1;i&lt;=N;i++)
        A[i]=rand()%K+1; //生成1..K的随机数
    BucketSort(A,B,N,K);
    for (i=1;i&lt;=N;i++)
        printf(&quot;%d &quot;,B[i]);
    return 0;
}
</code></pre>
<p>[基数排序]<br>
下面说到我们的重头戏，基数排序(Radix Sort)。上述的基数排序和桶排序都只是在研究一个关键字的排序，现在我们来讨论有多个关键字的排序问题。</p>
<p>假设我们有一些二元组(a,b)，要对它们进行以a为首要关键字，b的次要关键字的排序。我们可以先把它们先按照首要关键字排序，分成首要关键字相同的若干堆。然后，在按照次要关键值分别对每一堆进行单独排序。最后再把这些堆串连到一起，使首要关键字较小的一堆排在上面。按这种方式的基数排序称为MSD(Most Significant Dight)排序。</p>
<p>第二种方式是从最低有效关键字开始排序，称为LSD(Least Significant Dight)排序。首先对所有的数据按照次要关键字排序，然后对所有的数据按照首要关键字排序。要注意的是，使用的排序算法必须是稳定的，否则就会取消前一次排序的结果。由于不需要分堆对每堆单独排序，LSD方法往往比MSD简单而开销小。下文介绍的方法全部是基于LSD的。</p>
<p>通常，基数排序要用到计数排序或者桶排序。使用计数排序时，需要的是Order数组。使用桶排序时，可以用链表的方法直接求出排序后的顺序。下面是一段用桶排序对二元组基数排序的程序：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
using namespace std;
struct data
{
    int key[2];
};
struct linklist
{
    linklist *next;
    data value;
    linklist(data v,linklist *n):value(v),next(n){}
    ~linklist() {if (next) delete next;}
};
void BucketSort(data *A,int N,int K,int y)
{
    linklist *Bucket[101],*p;//建立桶
    int i,j,k,M;
    M=K/100+1;
    memset(Bucket,0,sizeof(Bucket));
    for (i=1;i&lt;=N;i++)
    {
        k=A[i].key[y]/M; //把A中的每个元素按照的范围值放入对应桶中
        Bucket[k]=new linklist(A[i],Bucket[k]);
    }
    for (k=j=0;k&lt;=100;k++)
    {
        for (p=Bucket[k];p;p=p-&gt;next) j++;
        for (p=Bucket[k],i=1;p;p=p-&gt;next,i++)
            A[j-i+1]=p-&gt;value; //把桶中每个元素取出
        delete Bucket[k];
    }
}
void RadixSort(data *A,int N,int K)
{
    for (int j=1;j&gt;=0;j--) //从低优先到高优先 LSD
        BucketSort(A,N,K,j);
}
int main()
{
    int N=100,K=1000,i;
    data *A=new data[N+1];
    for (i=1;i&lt;=N;i++)
    {
        A[i].key[0]=rand()%K+1;
        A[i].key[1]=rand()%K+1;
    }
    RadixSort(A,N,K);
    for (i=1;i&lt;=N;i++)
        printf(&quot;(%d,%d) &quot;,A[i].key[0],A[i].key[1]);
    printf(&quot;\n&quot;);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 58. 最后一个单词的长度]]></title>
        <id>https://lixin-ee.github.io//post/zi-fu-chuan-58-zui-hou-yi-ge-dan-ci-de-chang-du</id>
        <link href="https://lixin-ee.github.io//post/zi-fu-chuan-58-zui-hou-yi-ge-dan-ci-de-chang-du">
        </link>
        <updated>2019-09-29T10:05:17.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个仅包含大小写字母和空格 ' ' 的字符串，返回其最后一个单词的长度。<br>
如果不存在最后一个单词，请返回 0 。</p>
<p>说明：一个单词是指由字母组成，但不包含任何空格的字符串。<br>
示例:<br>
输入: &quot;Hello World&quot;<br>
输出: 5</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/length-of-last-word<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题也是简单题，其中主要的要点在于特殊例子。我一开始的想法是单纯地检测空格<br>
1.首先考虑最简单的情况，那就是正常的字符串，比如&quot;hallo world&quot;最后一个空格肯定是在最后一个单词前面，所以可以使用string的搜索算法 find_last_of(&quot; &quot;),然后用length减去返回的下标再减去1，同时适用于空格在字符串一开头的地方，比如&quot; hallo&quot;<br>
2.然后考虑特例之空格符出现在最后并且有单词，此时需要检测两个空格（因为 find_last_of是使用反向迭代器进行搜索的，所以后面所述的第一个对应最后一个）首先对第一个空格的位置进行检测证明loc=len-1，然后注意从第一个空格的位置loc-1开始搜索第二个空格，将第二个空格的位置与第一个空格的位置相减再减1就得到了返回值。与此种情况适用于最后一个单词被一对空格包住或者仅仅是单词+空格的情况，比如&quot;hallo &quot;<br>
3.但是上述情况都无法解决空格重复的情况，比如&quot;hallo     &quot;（后面带有多个空格），仔细思考后发现其实第一次检测可以把find_last_of(&quot; &quot;)改为更好的find_last_not_of(&quot; &quot;)这样子也保证了最后一个单词的存在，结合对单词前面的空格的检测，就能很轻松地得到最后一个单词了。但是注意有一个暗坑：如果没有空格，并且只有一个字母时，返回的下标是0，这个时候如果使用find_last_of(space, i - 1);进行空格探测是会因为-1而从最后一个位置开始检测的（注意在容器下标中是不可以使用-1的，但是此处应该是对size进行取模了），所以必须加上一个if检测。<br>
最后代码如下：</p>
<pre><code>class Solution {
public:
    int lengthOfLastWord(string s) {
		int len = s.size();
		if (len == 0)
			return 0;
		string space = &quot; &quot;;
		int i = s.find_last_not_of(space);
		if (i == string::npos)
			return 0;
		else if (!i)
			return 1;
		int j = s.find_last_of(space, i - 1);
		cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;
		if (j == string::npos)
			return i + 1;
		else
			return i - j; 
    }
};
</code></pre>
<p>其实细节还是蛮多的，比如如果找不到的时候，返回的下标可不是0或者-1，而是string::nops，这个值最好不要直接进行输出，用于比较就好，然后名字域是在string而不是std</p>
<p>然后贴一个网友题解，其实现是和我的想法一致的，只是我用的是封装好的string库函数，而网友的是完整的实现：</p>
<blockquote>
<p>思路<br>
标签：字符串遍历<br>
从字符串末尾开始向前遍历，其中主要有两种情况<br>
第一种情况，以字符串&quot;Hello World&quot;为例，从后向前遍历直到遍历到头或者遇到空格为止，即为最后一个单词&quot;World&quot;的长度5<br>
第二种情况，以字符串&quot;Hello World &quot;为例，需要先将末尾的空格过滤掉，再进行第一种情况的操作，即认为最后一个单词为&quot;World&quot;，长度为5<br>
所以完整过程为先从后过滤掉空格找到单词尾部，再从尾部向前遍历，找到单词头部，最后两者相减，即为单词的长度<br>
时间复杂度：O(n)，n为结尾空格和结尾单词总体长度<br>
代码</p>
</blockquote>
<pre><code>JavaJavaScript
class Solution {
    public int lengthOfLastWord(String s) {
        int end = s.length() - 1;
        while(end &gt;= 0 &amp;&amp; s.charAt(end) == ' ') end--;
        if(end &lt; 0) return 0;
        int start = end;
        while(start &gt;= 0 &amp;&amp; s.charAt(start) != ' ') start--;
        return end - start;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 14. 最长公共前缀]]></title>
        <id>https://lixin-ee.github.io//post/zi-fu-chuan-14-zui-chang-gong-gong-qian-zhui</id>
        <link href="https://lixin-ee.github.io//post/zi-fu-chuan-14-zui-chang-gong-gong-qian-zhui">
        </link>
        <updated>2019-09-28T10:07:52.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>编写一个函数来查找字符串数组中的最长公共前缀。<br>
如果不存在公共前缀，返回空字符串 &quot;&quot;。</p>
<p>示例 1:<br>
输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]<br>
输出: &quot;fl&quot;<br>
示例 2:<br>
输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]<br>
输出: &quot;&quot;<br>
解释: 输入不存在公共前缀。<br>
说明:<br>
所有输入只包含小写字母 a-z 。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/longest-common-prefix<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<pre><code>class Solution {
public:
    string longestCommonPrefix(vector&lt;string&gt;&amp; strs) {
        int len = strs.size();
        if(len==0)
            return &quot;&quot;;
        if(len == 1)
            return strs[0];
        int share = 0;
        int flen = strs[0].size()&lt;strs[1].size()?strs[0].size():strs[1].size();
        for(int i=0;i&lt;flen;++i,++share)
            if(strs[0][i]!=strs[1][i])
                break;
        if(!share)
            return &quot;&quot;;
        for(int i=2;i&lt;len;++i){
            for(int j=0;j&lt;share;++j)
                if(strs[i][j]!=strs[0][j]){
                    share=j;
                    break;
                }
            if(!share)
            return &quot;&quot;;
        }
        string s(strs[0],0,share);
        return s;      
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 28. 实现 strStr()]]></title>
        <id>https://lixin-ee.github.io//post/zi-fu-chuan-28-shi-xian-strstr</id>
        <link href="https://lixin-ee.github.io//post/zi-fu-chuan-28-shi-xian-strstr">
        </link>
        <updated>2019-09-27T14:50:52.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>实现 strStr() 函数。</p>
<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。<br>
示例 1:<br>
输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;<br>
输出: 2<br>
示例 2:<br>
输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;<br>
输出: -1<br>
说明:</p>
<p>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。<br>
对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p>
</blockquote>
<p>这道题刚好是《大话数据结构》中串章节介绍的KMP模式匹配算法，首先我来实现一下最简单的暴力逐位匹配法：</p>
<pre><code>class Solution {
public:
    int strStr(string haystack, string needle) {
        int lenh=haystack.size();
        int lenn=needle.size();
        if(lenh&lt;lenn)
            return -1;
        if(!lenn)
            return 0;
        for(int i=0;i&lt;lenh-lenn+1;++i)
            for(int j=0;j&lt;lenn;++j){
                if(haystack[i+j]!=needle[j])
                    break;
                if(j==lenn-1)
                    return i;
            }
        return -1;    
    }
};
</code></pre>
<p>暴力法没啥可以担心的，基本测试用例过了，整个都可以通过了，有趣的是leetcode居然显示0ms击败了100%hhh（C++天下第一！）<br>
然后后面来看一下KMP模式匹配算法吧</p>
<pre><code>class Solution {
public:
  
void get_nextval(string &amp;t, vector&lt;int&gt; &amp;nextval) {
	int i, j;
	i = 0;
	j = -1;
	nextval[0] = -1;
	while (i &lt; t.size()-1) {
		if (j == -1 || t[i] == t[j]) {
			++i, ++j;
			if (t[i] != t[j])
				nextval[i] = j;
			else
				nextval[i] = nextval[j];
		}
		else
			j = nextval[j] ;
	}
}

int Index_KPM(string s, string t) {
	int i = 0;
	int j = 0;
	vector&lt;int&gt; nextval(t.size());
	get_nextval(t, nextval);
	while (i&lt;s.size() &amp;&amp; j&lt;int(t.size())) {
		if (j == -1 || s[i] == t[j]) {
			++j, ++i;
		}
		else {
			j = nextval[j];
		}
	}
	if (j &gt;= t.size())
		return i - t.size();
	else
		return -1;
}

    
    int strStr(string haystack, string needle) {
        int lenh=haystack.size();
        int lenn=needle.size();
        if(lenh&lt;lenn)
            return -1;
        if(!lenn)
            return 0;
        return Index_KPM(haystack,needle);
    }
};
</code></pre>
<p>这里有一个比较蛋疼的地方，大话数据结构中字符串下标0用于存储字符串的长度，所以上述的0相应地换成-1的话是处于一个不合法的状态，而因为j可能处于负数的状态，所以是不可以直接和字符串的size（）返回值进行比较的，因为size返回的是无符号数，和负数强行比较的话会隐式转换把负数变成很大的正数，从而导致一直无法进入循环，但是此时编译器是不会报任何错误的。<br>
这里的话建议结合大话数据结构和leetcode上的题解来理解，大话的问题在于很抽象，对用于回退的next数组的含义解释得比较抽象，但是非常好的是循序渐进，先说了next再说nextval这两种递进的情况。然后leetcode题解的好处在与利用有限状态机这个概念解释清楚了next数组直接跳转的含义，比如 ababaaaba对应于011234224（注意大话原文中的下标0用于存储数组长度，所以这里的0其实应该对应于-1），第三个a如果不匹配的话就跳回到3的状态，结合大话的解释就解决了题解中的概念不清晰的问题，两者刚好相辅相成。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 287. 寻找重复数]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-287-xun-zhao-chong-fu-shu</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-287-xun-zhao-chong-fu-shu">
        </link>
        <updated>2019-09-26T08:09:57.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p>
<p>示例 1:<br>
输入: [1,3,4,2,2]<br>
输出: 2<br>
示例 2:<br>
输入: [3,1,3,4,2]<br>
输出: 3<br>
说明：<br>
不能更改原数组（假设数组是只读的）。<br>
只能使用额外的 O(1) 的空间。<br>
时间复杂度小于 O(n2) 。<br>
数组中只有一个重复的数字，但它可能不止重复出现一次。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/find-the-duplicate-number<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这个的话和昨天的相比的话也是比较明显的，普通的方法就是排序加遍历，排序可以分为快速排序和桶排序为主的两种原地排序和非原地排序之分，这两者主要的区别在于空间和时间上的取舍，但是明显地都不符合本题目的要求，所以应该是使用了非排序的方法。<br>
我一开始的时候想过使用每个位置的数组和来检测重复值，但是明显地如果重复数字出现多次的话就无法适用了，所以还是先看官方题解吧</p>
<blockquote>
<p>注释 ：<br>
前面的两种方法不满足提示中给出的约束条件，但它们是您在技术面试中可能会想到的解决方案。作为一名面试官，我个人不希望有人提出循环解决方案。<br>
证明：<br>
证明 nums 中存在至少一个副本是鸽子洞原理的简单应用。这里，nums 中的每个数字都是一个 “鸽子”，nums 中可以出现的每个不同的数字都是一个 “鸽子洞”。因为有 n+1个数是 n 个不同的可能数，鸽子洞原理意味着至少有一个数是重复的。<br>
方法一：排序<br>
如果对数字进行排序，则任何重复的数字都将与排序后的数组相邻。<br>
算法：<br>
算法相当简单。首先，我们对数组进行排序，然后将每个元素与前一个元素进行比较。因为数组中只有一个重复的元素，所以我们知道数组的长度至少为 2，一旦找到重复的元素，我们就可以返回它。</p>
</blockquote>
<pre><code>JavaPython
class Solution {
    public int findDuplicate(int[] nums) {
        Arrays.sort(nums);
        for (int i = 1; i &lt; nums.length; i++) {
            if (nums[i] == nums[i-1]) {
                return nums[i];
            }
        }

        return -1;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(nlgn)。排序调用在 Python 和 Java 中花费 O(nlgn) 时间，因此它支配后续的线性扫描。<br>
空间复杂度：O(1) (or O(n))，在这里，我们对 nums 进行排序，因此内存大小是恒定的。如果我们不能修改输入数组，那么我们必须为 nums 的副本分配线性空间，并对其进行排序。<br>
方法二：集合<br>
如果我们在数组上迭代时存储每个元素，我们可以在数组上迭代时简单地检查每个元素。</p>
<p>算法：<br>
为了实现线性时间复杂性，我们需要能够在恒定时间内将元素插入数据结构（并查找它们）。set 很好地满足这些约束，所以我们迭代数组并将每个元素插入 seen 中。在插入之前，我们检查它是否已经存在。如果是，那么我们找到了我们的副本，所以我们返回它。</p>
</blockquote>
<pre><code>JavaPython
class Solution {
    public int findDuplicate(int[] nums) {
        Set&lt;Integer&gt; seen = new HashSet&lt;Integer&gt;();
        for (int num : nums) {
            if (seen.contains(num)) {
                return num;
            }
            seen.add(num);
        }

        return -1;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)。Python 和 Java 都依赖于底层的哈希表，所以插入和查找有固定的时间复杂度。因此，该算法是线性的，因为它由一个执行 N 次恒定工作的 for 循环组成。<br>
空间复杂度：O(n)，在最坏的情况下，重复元素出现两次，其中一次出现在数组索引 n-1 处。在这种情况下，seen 将包含 n−1 不同的值，因此将占用 O(n) 空间。</p>
<p>方法三：弗洛伊德的乌龟和兔子（循环检测）<br>
如果我们对 nums 进行这样的解释，即对于每对索引 i 和值 v_i而言，“下一个” v_j位于索引 v_i处，我们可以将此问题减少到循环检测。</p>
<p>算法：<br>
首先，我们可以很容易地证明问题的约束意味着必须存在一个循环。因为 nums 中的每个数字都在 1 和 n 之间，所以它必须指向存在的索引。此外，由于 0 不能作为 nums 中的值出现，nums[0] 不能作为循环的一部分。</p>
</blockquote>
<pre><code>class Solution {
    public int findDuplicate(int[] nums) {
        // Find the intersection point of the two runners.
        int tortoise = nums[0];
        int hare = nums[0];
        do {
            tortoise = nums[tortoise];
            hare = nums[nums[hare]];
        } while (tortoise != hare);

        // Find the &quot;entrance&quot; to the cycle.
        int ptr1 = nums[0];
        int ptr2 = tortoise;
        while (ptr1 != ptr2) {
            ptr1 = nums[ptr1];
            ptr2 = nums[ptr2];
        }

        return ptr1;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)。<br>
空间复杂度：O(1)。</p>
</blockquote>
<p>题解一比较简单，我打算自己实现以下快速排序</p>
<pre><code>void QuickSort(vector&lt;int&gt; &amp;vi, vector&lt;int&gt;::iterator low, vector&lt;int&gt;::iterator high) {
	vector&lt;int&gt;::iterator middle;
	if (low &lt; high) {
		middle = partition(vi,low,high);
		QuickSort(vi, low, middle);
		QuickSort(vi, ++middle, high);
	}
}

vector&lt;int&gt;::iterator partition(vector&lt;int&gt; &amp;vi, vector&lt;int&gt;::iterator low, vector&lt;int&gt;::iterator high) {
	int pivotkey;
	if (low &lt; high)
		pivotkey = *low;
	while (low &lt; high) {
	while (low &lt; high&amp;&amp;pivotkey &lt;= *high) 
			--high;
	iter_swap(low, high);
		while (low &lt; high&amp;&amp;*low &lt;= pivotkey) 
			++low;
		iter_swap(low, high);	
	}
	return low;
}
</code></pre>
<p>哇居然被这个弄得有点焦头烂额，因为主要的槽点在于迭代器上，为了提高算法的泛型能力我用了迭代器（bidiretional iterator，支持++和--）而不是数组下标。书里的方法对于middle的两分法是分为 <code>[low,middle-1]、 [middle+1,high]</code> 对于数组下标来说这是小菜一碟，但是对于迭代器来说就不一样了，比如{1，0}这种情况当middle去到了边缘处，如果middle是迭代器，middle+1是没问题的，毕竟还有尾后迭代器，但是middle-1就8行了，所以只能用<code>[low,middle]、 [middle+1,high]</code>算是为了通用性牺牲了一点计算量吧。</p>
<p>题解二是一个集合，最简单的明显就是我一开始想到的set大法啦hhh，因为set的insert会返回一对pair，pair的second就用了bool值反映插入的成功与否，也太方便了吧hhh，当然set的底层是RB-tree，所以其中的操作可不简单，有时间得好好复习stl源码剖析。</p>
<p>第三个题解就是目标解了，不过就好像评论中所说，这个方法实在是太取巧了，颇有一种打哪指哪的感觉hhh<br>
这个方法重点在于把数组视为一个链表，其中的元素值就是指针，如果n+1个元素中有重复的，必然会形成一个内循环。<br>
贴一个网友给的其中的数学原理</p>
<pre><code> #此题转换为链表找环的开始位置，前提条件告诉我们是一定有环
 # 根据floyd判圈办法，一个快指针一个慢指针，二者一定在环上相遇，设相遇点为M点，
 # 快是慢的速度的2倍，时间相同，设慢的距离为s，那么快的距离为2s
 # m为链表头距离环开始位置的距离，k为环开始位置到M点的距离, N为环长度
 # s = m + a*N +k, 2s = m + b*N +k，二者相减，s = (a-b)*N
 # 由此可见，慢指针走过的距离是环长的整数倍，即链表头到M点是环长的整数倍
 # 如果是1倍的话，把m截距离旋转到环上，跟环融合，那么链表头一定落在M点，
# 即fast和slow都落在M点，那么二者到环开始位置距离相同，必然在此处相遇。
# 如果是N倍（N&gt;1）时，只不过slow指针多转几圈而已，后二者仍在此处相遇
</code></pre>
<pre><code>class Solution {
public:
    int findDuplicate(vector&lt;int&gt;&amp; nums) {
        int len=nums.size();
        if(len&lt;2)
            return 0;
        if(len==2)
            return nums[0];
        int fast=nums[0],slow=nums[0];
        do{
            slow=nums[slow];
            fast=nums[nums[fast]];
        }while(fast!=slow);
        fast=nums[0];
        while(slow!=fast){
            slow=nums[slow];
            fast=nums[fast];
        }
        return fast;
    }
};
</code></pre>
<p>比较难理解的就在于这一段了，这一段增速都是一致的，但是最后的落点只是值相同，而不是同一个点 比如{1，2，3，4，5，2}，m为2 M为5 环长度为4 5-2+1=4，此时slow从5出发，fast从1出发，大家都是只需一步就去到了2，但是并不是同一个2</p>
<pre><code>fast=nums[0];
        while(slow!=fast){
						slow=nums[slow];
						fast=nums[fast];
        }
</code></pre>
<p>然后网友给出了更有趣的一个重复数二分法，既符合了条件，又不会有太针对性的感觉。</p>
<blockquote>
<p>方法：二分法<br>
关键：这道题的关键是对要定位的“数”做二分，而不是对数组的索引做二分。要定位的“数”根据题意在 11 和 nn 之间，每一次二分都可以将搜索区间缩小一半。</p>
<p>以 <code>[1, 2, 2, 3, 4, 5, 6, 7]</code> 为例，一共有 8 个数，每个数都在 1 和 7 之间。1 和 7 的中位数是 4，遍历整个数组，统计小于 4 的整数的个数，至多应该为 3 个，如果超过 3 个就说明重复的数存在于区间 <code>[1,4)</code>（注意：左闭右开）中；否则，重复的数存在于区间 [4,7]（注意：左右都是闭）中。这里小于 4 的整数有 4 个（它们是 1, 2, 2, 3），因此砍掉右半区间，连中位数也砍掉。以此类推，最后区间越来越小，直到变成 1 个整数，这个整数就是我们要找的重复的数。</p>
</blockquote>
<p>参考代码 1：</p>
<pre><code>C++
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

class Solution {
public:
    int findDuplicate(vector&lt;int&gt; &amp;nums) {
        int len = nums.size();
        int left = 0;
        int right = len - 1;

        while (left &lt; right) {
            int mid = (left + right) &gt;&gt; 1;
            int counter = 0;
            for (int num:nums) {
                if (num &lt;= mid) {
                    counter++;
                }
            }

            if (counter &gt; mid) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
};
</code></pre>
<blockquote>
<p>说明：1、在 Python 中，整除使用 // ，如果使用 / ，在不能整除的时候，会返回一个小数；<br>
2、之所以写成 mid = left + (right - left + 1) // 2 ，是因为下面的分支条件是：left = mid 和 right = mid - 1，如果写成 mid = left + (right - left) // 2 就会陷入死循环。我们还是以具体例子为例。<br>
当一个整数数组（按升序排列）的个数为奇数时，不论 mid = left + (right - left) // 2 和 mid = left + (right - left + 1) // 2 都落在了相同的一个数，大家不妨拿 [1,2,3,4,5] 做验证；</p>
<p>当一个整数数组（按升序排列）的个数为偶数时：<br>
（1） mid = left + (right - left) // 2 找到的是中间位置偏左的元素；<br>
（2） mid = left + (right - left + 1) // 2 找到的是中间位置偏右的元素。<br>
可以拿 [1,2,3,4] 验证。<br>
因此如果分支是：left = mid 和 right = mid - 1，说明，当只有 2 个元素的时候，中位数不能取左边，否则会出现死循环，因此中位数的取法是 mid = left + (right - left + 1) // 2。<br>
如果分支是：left = mid + 1 和 right = mid，说明，当只有 2 个元素的时候，中位数不能取右边，否则会出现死循环，因此中位数的取法是 mid = left + (right - left) // 2。</p>
<p>3、<code>while left &lt; right</code> 一定是严格小于，这样退出循环的时候就一定有 l==r 成立，就不必纠结该返回 l 还是 r 了。</p>
<p>总结一下：while left &lt; right 一定是严格小于，最后把一个区间“夹逼”成一个数，二分法先写两个分支，再根据分支的情况，调整如何取中点。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 164. 最大间距]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-164-zui-da-jian-ju</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-164-zui-da-jian-ju">
        </link>
        <updated>2019-09-25T14:44:26.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。<br>
如果数组元素个数小于 2，则返回 0。</p>
<p>示例 1:<br>
输入: [3,6,9,1]<br>
输出: 3<br>
解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。<br>
示例 2:<br>
输入: [10]<br>
输出: 0<br>
解释: 数组元素个数小于 2，因此返回 0。<br>
说明:<br>
你可以假设数组中所有元素都是非负整数，且数值在 32 位有符号整数范围内。<br>
请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/maximum-gap<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这一题的话比较特殊吧，因为题目其实很明显了，如果用最显眼的方法那就无非是快速排序+遍历相减了，时间复杂度明显是o(nlogn+n)，但是题目又明显地让我们用线性的空间复杂度来换线性的时间复杂度，很明显应该用桶排序了，所以先来看一下题解吧：</p>
<blockquote>
<p>方法 1：比较排序<br>
想法<br>
按照题意实现。</p>
<p>算法<br>
将整个数组排序后，遍历数组找到相邻元素间的最大间距。</p>
</blockquote>
<pre><code>C++
int maximumGap(vector&lt;int&gt;&amp; nums)
{
    if (nums.empty() || nums.size() &lt; 2)            // check if array is empty or small sized
        return 0;
    sort(nums.begin(), nums.end());                 // sort the array
    int maxGap = 0;
    for (int i = 0; i &lt; nums.size() - 1; i++)
        maxGap = max(nums[i + 1] - nums[i], maxGap);
    return maxGap;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(nlogn)。排序的复杂度是 O(nlogn)，遍历的复杂度是 O(n)，总复杂度是O(nlogn)。<br>
空间复杂度：除去输入数组之外，不需要额外空间（因为大多数都是原地排序）。</p>
<p>方法 2：基数排序<br>
算法<br>
这个方法与第一种方法相似，不过我们基于基数排序而非传统的比较排序。</p>
</blockquote>
<pre><code>c++
int maximumGap(vector&lt;int&gt;&amp; nums)
{
    if (nums.empty() || nums.size() &lt; 2)
        return 0;

    int maxVal = *max_element(nums.begin(), nums.end());

    int exp = 1;                                 // 1, 10, 100, 1000 ...
    int radix = 10;                              // base 10 system

    vector&lt;int&gt; aux(nums.size());

    /* LSD Radix Sort */
    while (maxVal / exp &gt; 0) {                   // Go through all digits from LSD to MSD
        vector&lt;int&gt; count(radix, 0);

        for (int i = 0; i &lt; nums.size(); i++)    // Counting sort
            count[(nums[i] / exp) % 10]++;

        for (int i = 1; i &lt; count.size(); i++)   // you could also use partial_sum()
            count[i] += count[i - 1];

        for (int i = nums.size() - 1; i &gt;= 0; i--)
            aux[--count[(nums[i] / exp) % 10]] = nums[i];

        for (int i = 0; i &lt; nums.size(); i++)
            nums[i] = aux[i];

        exp *= 10;
    }

    int maxGap = 0;

    for (int i = 0; i &lt; nums.size() - 1; i++)
        maxGap = max(nums[i + 1] - nums[i], maxGap);

    return maxGap;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(d⋅(n+k))≈O(n)<br>
由于在数组上的线性迭代是接近线性复杂度，所以方法的时间性能瓶颈主要是基数排序。<br>
基数排序以计数排序为基础。</p>
<p>计数排序时间复杂度是 O(n+k)，其中 k 是数组 n个元素的基数（数字个数）。如果 k≤O(n)，计数排序可以在线性时间内完成。在我们的例子中，基数是固定的（比如，k = 10），因此计数排序运行时间是线性的 O(n)。<br>
基数排序运行 d 轮计数排序（其中每个元素由最多 d 个数字组成）。因此有效运行时间是 O(d⋅(n+k))，但在我们的例子中，最大可能的 32 位有符号是 2147483647，因此d≤10 是常数。<br>
因此基数排序的时间效率是 O(n)。<br>
空间复杂度：O(n+k)≈O(n)额外空间。</p>
<p>计数排序需要额外 O(k) 空间，基数排序需要一个和输入数组相同大小的辅助数组。然而给定的 k 是一个固定小常数，所以在大输入情况下计数排序的额外空间是可以被忽略的。</p>
</blockquote>
<blockquote>
<p>方法 3：桶和鸽笼原理<br>
想法</p>
<p>对整个数组排序的代价很大，最坏情况下需要让每个元素都和其他所有元素比较。</p>
<p>如果我们不需要比较所有元素对呢？如果我们将元素分类，比如说用桶，这个想法将是可能的。我们只需要比较这些桶即可。</p>
<p>题外话：鸽笼原理</p>
<p>鸽笼原理描述说，n 个物品放入 m个容器中，如果 n&gt;m 那么一定有一个容器装有至少两个物品。</p>
<p>假设对于数组中的任意一个元素都有一个桶，那么每个元素恰好占据一个桶。现在减少桶的个数，必然会有一些桶包含超过一个元素。</p>
<p>现在讨论元素之间的间距。考虑最好情况，假设元素排好序且两两之间间距相同。这意味着任意相邻元素都有恒定的差值。所以 n 个元素有 n−1 个间距，假设为 t，显然可以得到 t=(max−min)/(n−1)，其中 max 和 min 是数组中最大和最小的元素。这个间距就是相邻元素间最大间距，也就是我们要的答案。</p>
<p>显然，t 是具有相同数量（n）和相同区间（max−min）的数组中，都可以满足的最小值。证明：假设从一个相等间距的数组出发，改变相邻量元素的间距，假设将 arr[i−1] 和arr[i] 之间的间距变成 t−p，那么 arr[i] 和 arr[i+1] 之间的间距就增长为 t+p。因此最大间距就从 t 变成了t+p，因此最大间距 t只会增加。</p>
<p>桶！</p>
<p>回到我们的问题，我们已经了解了鸽笼原理的应用，那么如果我们用桶来代替单独元素作比较，比较的次数会减小，因为桶中可能有多个元素。这并不能马上解决完这个问题。如果在桶中比较元素？那问题将会得到很好解决。</p>
<p>所以现在的想法是：如果我们只需要在桶之间相互比较，而不用比较桶内的元素，看起来会非常理想。这也将解决排序问题：只需要将元素分配到合适的桶中，因为桶已经有序，所以我们只需要比较桶，不需要将所有元素排序并比较了。</p>
<p>说明</p>
<p>以下是一些说明：</p>
<p>桶的大小是相同的嘛？<br>
是的，他们大小都为 bb。</p>
<p>那么桶之间的间距也是固定的嘛？<br>
是的，桶之间的间距是 1。这意味着两个大小为 3 的相邻桶分别代表的区间是 3 - 63−6 和 4 - 74−7。不会出现重叠。</p>
<p>为什么说两个相邻桶之间可能出现最大间距？<br>
桶的大小也就是桶的容积，是桶可以容纳的最大区间范围。然而桶内的区间范围取决于桶内最大元素和最小元素的差值。例如一个大小为 55 的桶包含值域 6-106−10，它保存了元素 7,8,97,8,9 那么实际容积就是 (9 - 7) + 1 = 3(9−7)+1=3 与桶的大小不相等。</p>
<p>如何比较相邻两个桶？<br>
我们比较实际范围，也就是前一个桶的最大元素和后一个桶的最小元素。比如说，两个大小为 55 的桶，分别保存元素 [1,2,3][1,2,3] 和 [9,10][9,10]，那么桶之间的间距就是 9-3=69−3=6（大于任意一个桶的大小）。</p>
<p>是否还要再比较一次元素？！<br>
是的，需要！但只需要比较两倍桶个数的元素（每个桶的最大最小元素）。如果按照上面的做法，你会发现当选择了合适的桶大小时，比较次数远远小于数组中实际元素个数。</p>
<p>算法</p>
<p>选择合适的桶大小 bb 满足 1&lt;b≤(max−min)/(n−1)。设 b=⌊(max−min)/(n−1)⌋。<br>
所有 n 个元素被分为 k=⌈(max−min)/b⌉ 个桶。<br>
因此第 i 个桶保存的值区间为：[min+(i−1)∗b, min+i∗b)（下标从 1 开始）。<br>
显然很容易计算出每个元素属于哪个桶，floor⌊(num−min)/b⌋（下标从 0 开始）其中 num 是元素的值。<br>
当所有 n 个元素都遍历过后，比较 k−1 个相邻桶找到最大间距。</p>
</blockquote>
<pre><code>c++
class Bucket {
public:
    bool used = false;
    int minval = numeric_limits&lt;int&gt;::max();        // same as INT_MAX
    int maxval = numeric_limits&lt;int&gt;::min();        // same as INT_MIN
};

int maximumGap(vector&lt;int&gt;&amp; nums)
{
    if (nums.empty() || nums.size() &lt; 2)
        return 0;

    int mini = *min_element(nums.begin(), nums.end()),
        maxi = *max_element(nums.begin(), nums.end());

    int bucketSize = max(1, (maxi - mini) / ((int)nums.size() - 1));        // bucket size or capacity
    int bucketNum = (maxi - mini) / bucketSize + 1;                         // number of buckets
    vector&lt;Bucket&gt; buckets(bucketNum);

    for (auto&amp;&amp; num : nums) {
        int bucketIdx = (num - mini) / bucketSize;                          // locating correct bucket
        buckets[bucketIdx].used = true;
        buckets[bucketIdx].minval = min(num, buckets[bucketIdx].minval);
        buckets[bucketIdx].maxval = max(num, buckets[bucketIdx].maxval);
    }

    int prevBucketMax = mini, maxGap = 0;
    for (auto&amp;&amp; bucket : buckets) {
        if (!bucket.used)
            continue;

        maxGap = max(maxGap, bucket.minval - prevBucketMax);
        prevBucketMax = bucket.maxval;
    }

    return maxGap;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n+b)≈O(n)。<br>
线性遍历一遍数组中的元素，复杂度为 O(n)。找到桶之间的最大间距需要线性遍历一遍所有的桶，复杂度为 O(b)。所以总复杂度是线性的。<br>
空间复杂度：O(2⋅b)≈O(b) 的额外空间。<br>
每个桶只需要存储最大和最小元素，因此额外空间和桶个数线性相关。</p>
</blockquote>
<p>第一个题解就没啥好说的啦，第二个题解也是为了引出第三个题解，第三个题解的重点在于如何分配桶的容量和桶的个数，然后细节之处就在于桶的容量个数的计算和某个元素落入哪个桶的取值计算（floor和ceil的取舍），以及最后如何遍历桶（只保留每个桶的最大最小值，然后对比每个桶的差），我在细节处栽了很多跟头，即使知道了题解，还是得细心啊，而且得回去重新看一遍计数排序、基数排序和桶排序的那个线性时间复杂度的算法！<br>
最后代码如下：</p>
<pre><code>class Solution {
public:
    int maximumGap(vector&lt;int&gt;&amp; nums) {
        int len = nums.size();
	if (len==0||len==1)
		return 0;
	vector&lt;vector&lt;int&gt;&gt; bucket(len, vector&lt;int&gt;(2, -1));
	int max_ele = *max_element(nums.begin(), nums.end()), min_lel = *min_element(nums.begin(), nums.end());
	int cap = ceil((double)(max_ele - min_lel) / (double)(len - 1));
        if(!cap)
            return 0;
	for (auto i : nums) {
		int n = (i - min_lel) / cap;
		if (bucket[n][0] == -1)
			bucket[n][0] = i, bucket[n][1] = i;
		else {
			bucket[n][0] = bucket[n][0] &lt; i ? bucket[n][0] : i;
			bucket[n][1] = bucket[n][1] &gt; i ? bucket[n][1] : i;
		}
	}
	int diff = 0;
	int temp = bucket[0][1];
	for (int i = 1; i &lt; len ; ++i) {
		if (bucket[i][0] != -1)
			diff = bucket[i][0] - temp&gt;diff? bucket[i][0] - temp:diff , temp = bucket[i][1];
	}
	return diff;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第十章 笔记+习题 10.1-10.3]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-zhang-bi-ji-xi-ti-101-103</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-zhang-bi-ji-xi-ti-101-103">
        </link>
        <updated>2019-09-25T01:23:35.000Z</updated>
        <content type="html"><![CDATA[<p>10泛型算法<br>
泛型算法 1.“算法”：因为它们实现了一些<strong>经典算法的公共接口</strong> 如排序和搜索 2.“泛型”：因为它们可以用于不同类型的元素和多种容器类型</p>
<p>10.1概述<br>
大部分算法都定义在头文件algorithm中，标准库还在头文件numeric中定义了一组数值泛型算法<br>
泛型算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作<br>
find（begin，end，value）：寻找指定数值，返回在范围中第一个等于指定值的迭代器，如无匹配元素，<strong>返回第二个参数（迭代器）来表示搜索失败</strong><br>
注意！find函数的第二个参数指向的元素（位置）不会被检测，也就是<strong>开区间[begin,end）</strong> 因此可以通过<strong>比较返回值和第二个参数来判断是否成功</strong><br>
<strong>find可以使用指针</strong>，所以可以在<strong>内置数组</strong>中寻找值，使用begin()和end()函数可以获取内置数组的指针 int a[10];//<strong>begin(a),end(a)</strong><br>
这些步骤都不依赖于容器所保存的元素类型，甚至无须理会保存元素的是不是容器<br>
迭代器令算法不依赖于容器，但依赖于元素类型操作（= &lt; &gt;等）<br>
泛型算法本身不会执行容器的操作，只会运行于迭代器之上，永远不会改变底层容器的大小</p>
<p>习题10.1</p>
<pre><code>int main() {
	vector&lt;int&gt; vi;
	int i;
	while (cin &gt;&gt; i)
		vi.push_back(i);
	cout&lt;&lt;count(vi.begin(), vi.end(), 123)&lt;&lt;endl;
}
</code></pre>
<p>习题10.2</p>
<pre><code>int main() {
	list&lt;string&gt; ls;
	string s;
	while (cin &gt;&gt; s)
		ls.push_back(s);
	cout&lt;&lt;count(ls.begin(), ls.end(), &quot;123&quot;)&lt;&lt;endl;
}
</code></pre>
<p>10.2初始泛型算法<br>
标准库算法都对一个范围内的元素进行操作，称为输入范围（注意是开区间，要处理的第一个元素和尾元素之后位置形成的范围），理解算法的最基本方法是了解它们<strong>是否读取元素、改变元素和重排元素顺序</strong><br>
10.2.1只读算法<br>
只读算法：只读取元素不改变元素<br>
accumulate(begin,end,original_value) 求和函数<strong>第三个参数</strong>的类型决定了函数中<strong>使用哪个加法运算符以及返回值的类型</strong>，original_value是指和的初值。 <strong>如果第三个参数为0，而容器中的元素类型为double，返回值函还是int</strong><br>
第三个参数<strong>不能是字符串字面值</strong>而必须是<strong>显式创建的string</strong><br>
accumulate(v.cbegin(),v.cend(),string(“ ”))//正确<br>
accumulate(v.cbegin(),v.cend(),“ ”) //错误<br>
对于只读取而不改变元素的算法，通常最好使用<strong>cbegin和cend</strong>迭代器，但使用cbegin和cend迭代器会使得泛型函数返回c迭代器<br>
equal(v1.cbegin(),v2.cend(),v2.cbegin()) 比较两个序列是否保存相同的值<br>
由于迭代器的原因，我们可以使用equal比较两个不同类型的容器中的元素，甚至元素类型也不必一样<br>
注意！那些<strong>只接受单一迭代器</strong>来表示第二个序列的算法，<strong>都假定第二个序列至少与第一个序列一样长</strong></p>
<p>习题10.3</p>
<pre><code>int main() {
		vector&lt;int&gt; vi;
		int i;
		while (cin &gt;&gt; i)
			vi.push_back(i);
		cout &lt;&lt; accumulate(vi.cbegin(), vi.cend(), 0) &lt;&lt; endl;
}
</code></pre>
<p>习题10.4<br>
第三个参数为0，决定了返回值的类型是int，所以导致小数部分全部失效<br>
习题10.5<br>
3.5.4节P109 将比较符运用在c风格字符串上时，实际比较的将是指针而非字符串本身</p>
<p>10.2.2写容器元素的算法<br>
使用写入算法时必须保证序列原大小至少不小于我们要求算法写入的数目，因为<strong>算法不会执行容器操作，因此它们自身无法改变容器的大小</strong></p>
<p>fill算法：将给定值赋予输入序列中的每个元素<br>
一些算法接受一个迭代器指出一个单独的目的位置 例如函数fill_n</p>
<p>向目的位置迭代器写入数据的算法<strong>假定目的位置足够大</strong>，能容纳要写入的元素<br>
back_inserter 插入迭代器：定义在头文件iterator中，<strong>向容器添加元素的迭代器</strong>，保证算法有足够元素空间来容纳输出数据<br>
back_inserter接受一个指向容器的引用（需要绑定的容器），<strong>返回一个与该容器绑定的插入迭代器</strong>，当我们通过插入迭代器赋值时，赋值运算符会<strong>调用push_back</strong>将一个具有给定值的元素添加到容器中<br>
常常使用back_inserter来创建一个迭代器，作为算法的目的位置来使用</p>
<p>copy 拷贝算法，第三个参数表示目的序列的起始位置，目的序列至少要包含于输入序列一样多的元素<br>
copy返回的是其目的位置迭代器（递增后）的值，ret指向a2,的尾后位置<br>
其他泛型算法的 <strong>_copy版本</strong> 经常用于利用旧序列计算新元素的值，并保存在新创建的新序列中，例如replace_copy算法接受额外的第三个迭代器参数，指出调整后序列的保存位置</p>
<p>习题10.6</p>
<pre><code>int main()
{
	vector&lt;int&gt; i;
	fill_n(i.begin(), i.size(), 0);
}
</code></pre>
<p>知识点：注意fill_n的第二个参数是元素个是而不是迭代器<br>
习题10.7<br>
（a）无法保证size是一致的，应该vec.resize(lst.size())<br>
（b）reserve和resize是不一致的，reserve是capacity，不代表size，fill_n是看size的<br>
习题10.8<br>
这个算法是通过一个迭代器adapter来进行插入操作的，自身并没有针对容器内容进行容器大小操作，所以还是符合规矩的。</p>
<p>10.2.3重排容器元素的算法<br>
sort 利用元素类型的&lt;运算符来实现排序<br>
unique 重排输入范围，使得每个单词只出现一次，并排列在范围前部，返回指向不重复区域之后一个位置的迭代器</p>
<p>习题10.9</p>
<pre><code>int main()
{
	vector&lt;string&gt; vs;
	string s;
	while (cin &gt;&gt; s)
		vs.push_back(s);
	for (auto i : vs)
		cout &lt;&lt; i &lt;&lt; &quot; &quot;;
	cout &lt;&lt; endl;
	elimDups(vs);
}

void elimDups(vector&lt;string&gt; &amp;words) {
	sort(words.begin(), words.end());
	auto end_unique = unique(words.begin(), words.end());
	for (auto i : words)
		cout &lt;&lt; i &lt;&lt; &quot; &quot; ;
	cout &lt;&lt; endl;
	words.erase(end_unique, words.end());
	for (auto i : words)
		cout &lt;&lt; i &lt;&lt; &quot; &quot;;
	cout &lt;&lt; endl;
}
</code></pre>
<p>知识点：unique返回指向不重复区域之后一个位置的迭代器（所以还是会指向第一个重复的元素的！）<br>
习题10.10<br>
因为算法应该是泛型的，每种容器对于容器大小的处理都有所不同，甚至于有些会反过来影响算法（比如vector容量变化会导致迭代器失效），所以泛型算法应该摆脱这个影响。</p>
<p>10.3定制操作<br>
sort算法默认使用元素类型的 <strong>&lt;</strong> 运算符，但如果元素不支持该运算符，就需要重载sort的默认行为</p>
<p>10.3.1向算法传递函数<br>
谓词：可调用的表达式，其返回结果是一个能用做条件的值。分为一元谓词（只接受单一参数）和二元谓词（接受两个参数）.<br>
接受谓词参数的算法对输入序列中的每个元素依次调用谓词，所以元素类型必须能转换为谓词的参数类型<br>
接受一个二元谓词参数的sort版本用这个谓词代替&lt;来比较元素<br>
stable_sort算法：相同长度的单词按字典序排列，同时是稳定排序，并维持相等元素的原有顺序</p>
<p>习题10.11</p>
<pre><code>int main()
{
	vector&lt;string&gt; vs;
	string s;
	while (cin &gt;&gt; s)
		vs.push_back(s);
	for (auto i : vs)
		cout &lt;&lt; i &lt;&lt; &quot; &quot;;
	cout &lt;&lt; endl;
	elimDups(vs);
}

void elimDups(vector&lt;string&gt; &amp;words) {
	stable_sort(words.begin(), words.end(),isShorter);
	auto end_unique = unique(words.begin(), words.end());
	for (auto i : words)
		cout &lt;&lt; i &lt;&lt; &quot; &quot; ;
	cout &lt;&lt; endl;
	words.erase(end_unique, words.end());
	for (auto i : words)
		cout &lt;&lt; i &lt;&lt; &quot; &quot;;
	cout &lt;&lt; endl;
}

bool isShorter(const string &amp;s1, const string &amp;s2) {
	return s1.size() &lt; s2.size();
}
</code></pre>
<p>习题10.12</p>
<pre><code>int main()
{
	vector&lt;Sales_Data&gt; vs;
	string s;
	while (cin &gt;&gt; s)
		vs.push_back(Sales_Data(s));
	for (auto i : vs)
		cout &lt;&lt; i.ISBN &lt;&lt; &quot; &quot;;
	cout &lt;&lt; endl;
	stable_sort(vs.begin(), vs.end(),compareISBN);
	for (auto i : vs)
		cout &lt;&lt; i.ISBN &lt;&lt; &quot; &quot;;
	cout &lt;&lt; endl;
}

bool compareISBN(const Sales_Data &amp;s1, const Sales_Data &amp;s2) {
	int result = s1.ISBN.compare(s2.ISBN);
	if (result &lt; 0)
		return true;
	else
		return false;
}
</code></pre>
<p><strong>注意！这里发现 Sales_data的构造函数的函数体中的read出现了问题，原因是Sales_data定义早于read，然而如果把read声明放在Sales_data定义前面，read的参数中又有Sales_data的引用，所以此时必须把Sales_data的声明放在read前面，注意！此时Sales_data是不完全类型，在read声明中必须使用不完全类型的声明或者引用，不可以直接使用Sales_data。</strong></p>
<p>习题10.13</p>
<pre><code>int main()
{
	vector&lt;string&gt; vs;
	string s;
	while (cin &gt;&gt; s)
		vs.push_back(s);
	if (string_size(vs))
		cout &lt;&lt; &quot;yes!&quot; &lt;&lt; endl;
	
}


bool string_size(vector&lt;string&gt; &amp;s) {
	auto i=partition(s.begin(),s.end(), size_5);
	auto f = s.begin();
	while (f &lt; i) {
		cout &lt;&lt; *f++ &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;
	return f &lt; i;
}

bool size_5(string &amp;s) {
	return s.size() &gt;= 5;
}
</code></pre>
<p>10.3.2lambda表达式<br>
我们可以向一个算法传递任何类别的可调用对象<br>
对于一个对象或者一个表达式，如果可以对其使用<strong>调用运算符（圆括号( )）</strong>，则称它为可调用的<br>
一个lambda表达式表示一个可调用的代码单元，可以将其理解为一个未命名的内联函数<br>
lambda具有一个返回类型，一个参数列表和一个函数体，但与函数不同，<strong>lambda可以定义在函数内部</strong><br>
[capture list] (parameter list) -&gt; return type {function body}<br>
lambda<strong>必须使用尾置返回</strong>，可以<strong>忽略参数列表和返回类型</strong>，但<strong>必须永远包含捕获列表和函数体</strong> 如 auto f = [ ] { return 42; }<br>
如果忽略返回类型，并且lambda函数体内只包含一句return语句，则lambda根据函数体中的代码<strong>自动推断返回类型</strong>，如果函数体包含其他语句，则返回void<br>
<strong>lambda不能有默认参数</strong> 因此一个lambda调用的实参数目永远与形参数目相等<br>
捕获列表为空则代表lambda不适用它所在的函数中的任何局部变量<br>
lambda必须在<strong>捕获列表</strong>中捕获所在<strong>函数中的局部变量</strong>才能在其<strong>函数体中使用该变量</strong>，不能因为位于所在函数中就直接使用局部变量</p>
<p>捕获列表只用于局部非static变量，lambda<strong>可以直接使用局部static变量和它所在函数之外声明的名字</strong>，比如cout，cout定义在头文件iostream中</p>
<p>习题10.14</p>
<pre><code>int main()
{
	auto f = [](int x,int i) {return i + x; };
	cout &lt;&lt; f(10,10) &lt;&lt; endl;
}
</code></pre>
<p>习题10.15</p>
<pre><code>int main()
{
	int i = 10;
	auto f = [i](int x) {return i + x; };
	cout &lt;&lt; f(10) &lt;&lt; endl;
}
</code></pre>
<p>习题10.16<br>
<code>void biggies(vector&lt;string&gt; &amp;words, vector&lt;string&gt;::size_type sz) { 	elimDups(words); 	stable_sort(words.begin(), words.end(), [](const string &amp;a, const string &amp;b) {return a.size() &lt; b.size(); }); 	auto wc = find_if(words.begin(), words.end(), [sz](const string &amp;a) {return a.size() &gt;= sz; }); 	auto count = words.end() - wc; 	cout &lt;&lt; count &lt;&lt; &quot; &quot; &lt;&lt; make_plural(count, &quot;word&quot;, &quot;s&quot;) &lt;&lt; &quot; of length&quot; &lt;&lt; sz &lt;&lt; &quot; or longer&quot; &lt;&lt; endl; 	for_each(wc, words.end(), [](const string &amp;s) {cout &lt;&lt; s &lt;&lt; &quot; &quot;; }); 	cout&lt;&lt;endl }</code><br>
习题10.17</p>
<pre><code>int main()
{
	vector&lt;Sales_Data&gt; vs;
	string s;
	while (cin &gt;&gt; s)
		vs.push_back(Sales_Data(s));
	for (auto i : vs)
		cout &lt;&lt; i.ISBN &lt;&lt; &quot; &quot;;
	cout &lt;&lt; endl;
	int s_size = 5;
	stable_sort(vs.begin(), vs.end(), [](const Sales_Data &amp;s1, const Sales_Data &amp;s2) {return s1.ISBN &lt; s2.ISBN; });
	for (auto i : vs)
		cout &lt;&lt; i.ISBN &lt;&lt; &quot; &quot;;
	cout &lt;&lt; endl;
}
</code></pre>
<p>习题10.18</p>
<pre><code>void biggies(vector&lt;string&gt; &amp;words, vector&lt;string&gt;::size_type sz) {
	elimDups(words);
	stable_sort(words.begin(), words.end(), [](const string &amp;a, const string &amp;b) {return a.size() &lt; b.size(); });
	auto wc = partition(words.begin(), words.end(), [sz](const string &amp;a) {return a.size() &gt;= sz; });
	auto count = wc-words.begin();
	cout &lt;&lt; count &lt;&lt; &quot; &quot; &lt;&lt; make_plural(count, &quot;word&quot;, &quot;s&quot;) &lt;&lt; &quot; of length&quot; &lt;&lt; sz &lt;&lt; &quot; or longer&quot; &lt;&lt; endl;
	for_each(word.begin(),wc[](const string &amp;s) {cout &lt;&lt; s &lt;&lt; &quot; &quot;; });
	cout&lt;&lt;endl
}
</code></pre>
<p>主要是partition会将符合条件的元素放在前面，返回指向第一个不符合条件的迭代器。<br>
习题10.19<br>
stable_partition可以保持容器原有元素的顺序，以vector中第一个元素102，把vector分成两个部分，分别是{44，99，35，1，2}和{101，201，110}。并且只是把小于102的元素移动到前面，比102大的元素移动到后面。<br>
而partition可以看出，改变了元素的相对位置，两个部分分别是：{2，44，99，35，1}和110，201，102，前面一部分都是小于102的元素，后面一部分是大于等于102的元素。</p>
<p>10.3.3lambda捕获和返回<br>
当向一个函数传递一个lambda时，同时定义了<strong>一个新类型和该类型的一个对象</strong>：传递的参数就是此编译器生成的<strong>类类型的未命名对象</strong>。类似的当使用auto定义一个用lambda初始化的变量时，定义了一个从lambda生成的类型的对象<br>
从lambda生成的<strong>类</strong>都包含一个对应该lambda所<strong>捕获的变量的数据成员</strong><br>
类似于参数传递，变量的捕获方式也可以是值或者引用<br>
与参数不同，被捕获的变量的值是在lambda<strong>创建时拷贝</strong>，而不是调用时拷贝，因此在<strong>创建lambda后对变量进行修改不会影响到lambda内对应的值</strong><br>
采用引用方式捕获一个变量时，必须保证被引用的对象在lambda执行的时候是存在的<br>
引用捕获是必要的，特别是对于不能拷贝的变量，比如ostream<br>
我们也可以从一个<strong>函数返回lambda</strong>，但与函数不能返回一个局部变量的引用相同，此lambda<strong>也不能包含引用捕获</strong>（局部变量会在函数结束后被销毁）<br>
隐式捕获：让<strong>编译器</strong>根据lambda体中的代码来<strong>推断</strong>我们需要使用哪些变量<br>
在捕获列表中，<strong>&amp;</strong> 告诉编译器采用<strong>引用捕获方式</strong>，<strong>=</strong> 则采用<strong>值捕获方式</strong><br>
可以混用隐式捕获和显式捕获，但当我们使用混用时，捕获列表第一个元素必须是一个&amp;或=，以<strong>指定默认隐式捕获方式</strong>。同时混用时显式捕获的变量<strong>必须使用与隐式捕获不同的方式</strong><br>
可变lambda<br>
默认情况下lambda不能改变值捕获的变量的值，如果想要改变值捕获的变量的值，则需要在参数列表首加上关键字mutable<br>
<strong>mutable是指在lambda内改变值捕获变量的值，而不是指改变外层变量的值！值捕获是无法改变变量的值的，改变外层变量的值应该用引用捕获</strong></p>
<p>习题10.20</p>
<pre><code>int main()
{
	vector&lt;string&gt; vs;
	string s;
	while (cin &gt;&gt; s)
		vs.push_back(s);
	int len = 6;
	int i = count_if(vs.begin(), vs.end(), [len](string &amp;s) {return s.size() &gt; len; });
	cout &lt;&lt; i &lt;&lt; endl;
}
</code></pre>
<p>习题10.21</p>
<pre><code>int main()
{
	int i=10;
	auto decline = [&amp;i] () mutable {return (--i) &gt; 0 ?false:true; };
	while (!decline())
		cout &lt;&lt; i &lt;&lt; endl;
	cout &lt;&lt; i &lt;&lt; endl;
}
</code></pre>
<p>注意此处不应该用mutable，而应该用引用捕获，因为mutable是指在lambda内改变值捕获变量的值，而不是指改变外层变量的值！值捕获是无法改变变量的值的，改变外层变量的值应该用引用捕获</p>
<p>10.3.4参数绑定<br>
lambda：适合只在一两个地方使用的简单操作<br>
函数：需要在很多地方使用相同的操作，或者一个操作需要很多语句才能完成<br>
如果lambda捕获列表为空，则可以用函数来代替它。但如果lambda捕获了局部变量，则较难用函数达到相同效果（指形参数量是否相同，可能lambda只需要一个形参和一个捕获变量，函数就需要两个形参）<br>
bind 标准库函数，定义在头文件functional中，可将bind函数看作一个<strong>通用的函数适配器</strong><br>
它<strong>接受一个可调用对象</strong>，生成一个新的可调用对象来“适应”原对象的参数列表<br>
调用bind 的一般形式<br>
arg_list中参数可能包含形如_n的名字，这些参数是占位符，表示newCallable的参数，数值n表示生成的可调用对象中参数的位置，_1为newCallable的第一个参数 _2为第二个参数</p>
<p>此bind调用只有一个占位符，表示check6只接受单一参数。占位符出现在arg_list的第一个位置，代表check6的此参数对应check_size的第一个参数，因此调用check6时需要给他传递一个参数，然后check6将此参数传递给check_size</p>
<p>使用placeholders名字<br>
名字_n都定义在名为placeholders的命名空间中，而这个命名空间又定义在std命名空间中，但是两个命名空间都需要声明 <code>using std::palceholders::_1</code><br>
using namespace namespace_name;更加方便，所有来自namespace_name的名字都可以在程序中直接使用  <code>using namespace std::placeholders;</code><br>
bind可以将调用对象中的参数进行顺序调整 比如<code>auto g = bind(f,a,b,_2,c,_1)</code> 调用时等于<code>g(_1,_2)</code><br>
不能用bind来代替对os的捕获，<strong>bind只能拷贝参数</strong><br>
使用标准库函数<strong>ref（）来传递引用对象</strong> 比如ref（ostream） cref（）const引用<br>
<strong>旧标准中的bind1st和bind2nd已经被弃用(STL源码剖析中的已经不适用了)</strong></p>
<p>习题10.22</p>
<pre><code>int main()
{
		vector&lt;string&gt; vs;
		string s;
		while (cin &gt;&gt; s)
			vs.push_back(s);
		int len = 6;
		int i = count_if(vs.begin(), vs.end(), size6);
		cout &lt;&lt; i &lt;&lt; endl;

}

bool size6(string &amp;s) {
	int len = 6;
	return s.size() &gt; len;
}
</code></pre>
<p>注意，在函数参数列表中调用函数只需要函数名字，不需要列表！比如size6就行，不用size6(s)<br>
习题10.23<br>
bind的参数包括三个部分：一个是调用的函数名，一个值捕获的变量，一个形参占位符<br>
习题10.24</p>
<pre><code>int main()
{
	vector&lt;int&gt; vlen{ 0,1,2,3,4,5,6,7,8,9 };
	string s{&quot;1234567&quot;};
	int len = s.size();
	cout &lt;&lt; *find_if(vlen.begin(), vlen.end(), bind(check_size, _1, len))&lt;&lt;endl;

}

bool check_size(int i, int len) {
	return i&gt; len;
}
</code></pre>
<p>习题10.25</p>
<pre><code>void biggies(vector&lt;string&gt; &amp;words, vector&lt;string&gt;::size_type sz) {
	elimDups(words);
	stable_sort(words.begin(), words.end(), [](const string &amp;a, const string &amp;b) {return a.size() &lt; b.size(); });
	auto wc = partition(words.begin(), words.end(), bind(check_size, _1, sz));
	auto count = wc - words.begin();
	cout &lt;&lt; count &lt;&lt; &quot; &quot; &lt;&lt; make_plural(count, &quot;word&quot;, &quot;s&quot;) &lt;&lt; &quot; of length&quot; &lt;&lt; sz &lt;&lt; &quot; or longer&quot; &lt;&lt; endl;
	for_each(word.begin(), wc[](const string &amp;s) { cout &lt;&lt; s &lt;&lt; &quot; &quot;; });
	cout &lt;&lt; endl
}

bool check_size(string s, int len) {
	return s.size()&gt; len;
}
</code></pre>
<p>习题感悟：将比较符运用在c风格字符串上时，实际比较的将是指针而非字符串本身<br>
注意fill_n的第二个参数是元素个是而不是迭代器<br>
unique返回指向不重复区域之后一个位置的迭代器（所以还是会指向第一个重复的元素的！）<br>
注意此处不应该用mutable，而应该用引用捕获，因为mutable是指在lambda内改变值捕获变量的值，而不是指改变外层变量的值！值捕获是无法改变变量的值的，改变外层变量的值应该用引用捕获<br>
注意，在函数参数列表中调用函数只需要函数名字，不需要列表！比如size6就行，不用size6(s)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer  第九章 笔记+习题 9.5-9.6]]></title>
        <id>https://lixin-ee.github.io//post/c-primer</id>
        <link href="https://lixin-ee.github.io//post/c-primer">
        </link>
        <updated>2019-09-24T01:40:18.000Z</updated>
        <content type="html"><![CDATA[<p>9.5额外的string操作<br>
9.5.1构造string的其他方法<br>
从一个const char*创建string，指针指向的数组必须以空字符结尾，拷贝操作遇到空字符时停止<br>
如果给构造函数传递一个计数值，数组就不必以空字符结尾<br>
substr操作<br>
s.substr(pos,n) 返回一个string，包含s中从pos开始的n个字符的拷贝，pos默认值为0，n的默认值为s.size()-pos<br>
如果开始位置超过string的大小，则substr函数抛出一个out_of_range异常</p>
<p>习题9.41</p>
<pre><code>int main() {
	vector&lt;char&gt; c{'h','a','l','l','o'};
	string s(c.begin(),c.end());
	for (auto i : c) {
		s.push_back(i);
	}
}
</code></pre>
<p>习题9.42<br>
先读入ostringstream中保存再一次过读入string</p>
<p>9.5.2改变string的其他方法<br>
string定义了额外的<br>
1.接受下标版本的insert和assign<br>
2.接受c风格字符数组的insert和assign（替换整个string）3.append（末尾追加）和replace函数（替换）<br>
append、assign、replace、insert有不同版本，且有共同接口<br>
<strong>assign总是替换string所有内容</strong>，append总是将新字符追加到string末尾<br>
replace提供两种指定删除元素范围的方式1一个位置和一个长度2一对迭代器<br>
insert 指定插入点1.一个下标2.一个迭代器<br>
并不是每个函数都支持所有形式的参数，<strong>insert就不支持【下标+初始化列表参数】</strong><br>
insert插入**最后一个位置是的下标是s.insert(s.size(),ins_s);**而不是s.size()-1</p>
<p>习题9.43</p>
<pre><code>void sreplace(string s, string oldVal, string newVal) {
	for (auto i = s.begin(); i &lt; s.end() - oldVal.size()+1; ++i)
		if (s.substr(i - s.begin(), oldVal.size()) == oldVal) {
			s.erase(i - s.begin(), oldVal.size());
			s.insert(i - s.begin(), newVal);
		}		
	cout &lt;&lt; s &lt;&lt; endl;
}
</code></pre>
<p>知识点：使用s.substr(pos,n) 提取一小段string，s.substr(pos,n) 返回一个string，包含s中从pos开始的n个字符的拷贝<br>
习题9.44</p>
<pre><code>void sreplace(string s, string oldVal, string newVal) {
	int i = s.find(oldVal);
	s.replace(i, oldVal.size(), newVal);
	cout &lt;&lt; s &lt;&lt; endl;
}
</code></pre>
<p>习题9.45</p>
<pre><code>void sadd(string &amp;s, string front_s, string back_s) {
	s.insert(s.begin(), front_s.begin(),front_s.end());
	s.append(back_s);
}
</code></pre>
<p>知识点：注意string的insert接受的是（iter1，iter_beg,iter_end）<br>
习题9.46</p>
<pre><code>void sadd(string &amp;s, string front_s, string back_s) {
	s.insert(0, front_s);
	s.insert(s.size(),back_s);
}
</code></pre>
<p>知识点：注意insert插入最后一个位置是的下标是s.insert(s.size(),ins_s);而不是s.size()-1</p>
<p>9.5.3string搜索操作<br>
搜索函数操作返回一个string::size_type 表示匹配发生位置的下标<br>
搜索失败返回一个名为<strong>string::npos的static成员</strong>，标准库将npos定义为一个const string::size_type类型，<strong>并初始化值为-1</strong>，npos是一个unsigned类型，可以表示任何string最大的可能大小<br>
string搜索函数返回的都是unsigned类型，<strong>所以不应该用int或带符号类型来保存其返回值</strong>。<br>
搜索函数（以及其他string的操作）都是大小写敏感的<br>
可以传递给find操作一个可选的开始位置，这个可选的参数指出从哪个位置开始搜索<br>
rfind成员函数：从右到左搜索最后一个匹配项，但是<strong>注意和find_last_of并不同</strong> 比如寻找”abc”  ** rfind找的是cba** ，find_last_of找的是abc</p>
<p>习题9.47</p>
<pre><code>int main() {
	string s = { &quot;ab2c3d7R4E6&quot; };
	int i = 0;
	while (i &lt; s.size()) {
		i = s.find_first_of(&quot;0123456789&quot;, i);
		if (i == -1) 
			break;
		cout &lt;&lt; s[i++] &lt;&lt; endl;
	}
	i = 0;
	while (i &lt; s.size()) {
		i = s.find_first_not_of(&quot;0123456789&quot;, i);
		if (i == -1)
			break;
		cout &lt;&lt; s[i++] &lt;&lt; endl;
	}
}
</code></pre>
<p>小小地偷懒了一下hhh，不过find_first_of真的挺神奇的<br>
习题9.48<br>
搜索失败返回一个名为string::npos的static成员，标准库将npos定义为一个const string::size_type类型，并初始化值为-1，npos是一个unsigned类型，可以表示任何string最大的可能大小<br>
习题9.49</p>
<pre><code>int main() {
	string s = { &quot;pscjdoposjcpijsapicjdipsc&quot; };
	string sp{ &quot;dfpg&quot; };
	int i = 0,temp=0, len = 0,x=0,y=0;
	while (i&lt;s.size()) {
		i = s.find_first_of(sp, i);
		if (i==-1) {
			break;
		}
		if (len &lt;(i - temp)) {
			len = (i - temp);
			x = temp;
			y = i;
		}
		
		temp = ++i;
	}
	if(x||y)
		while(x!=y)
		cout &lt;&lt; s[x++] &lt;&lt; endl;
}
</code></pre>
<p>9.5.4compare函数<br>
根据s是等与、大于还是小于参数指定的字符串，s.compare返回<strong>0、正数和负数</strong><br>
compare有六个版本，根据我们是要比较两个string还是一个string与一个字符数组，参数各有不同<br>
9.5.5数值转换<br>
string参数中第一个非空白符必须是符号（+或-）或数字，它可以以0x或0X开头来表示十六进制数<br>
string参数也可以以小数点开头，<strong>并且可以包含e或E来表示指数部分</strong><br>
根据基数不同，string参数可以包含字母字符，对应大于数字9的数<br>
如果string不能转换为一个数值，这些函数将会抛出一个invalid_argument异常，如果转换得到的数值无法用任何类型表示，则抛出一个out_of_range异常</p>
<p>习题9.50</p>
<pre><code>int main() {
	vector&lt;string&gt; vs{ &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot; };
	int sum = 0;
	for (auto i : vs) {
		sum += stoi(i);
	}
	cout &lt;&lt; sum &lt;&lt; endl;
}
</code></pre>
<pre><code>int main() {
	vector&lt;string&gt; vs{ &quot;1.01&quot;,&quot;2.02&quot;,&quot;3.03&quot;,&quot;4.04&quot;,&quot;5.05&quot;,&quot;6.06&quot;,&quot;7.07&quot;,&quot;8.08&quot;,&quot;9.09&quot; };
	double sum = 0;
	for (auto i : vs) {
		sum += stod(i);
	}
	cout &lt;&lt; sum &lt;&lt; endl;
}
</code></pre>
<p>习题9.51</p>
<pre><code>class Date
{
public://class默认是私有继承，记得要加public
	unsigned _year;
	unsigned _month;
	unsigned _day;
	void _show()
	{
		cout &lt;&lt; _year &lt;&lt; &quot;年&quot; &lt;&lt; _month &lt;&lt; &quot;月&quot; &lt;&lt; _day &lt;&lt; &quot;日&quot; &lt;&lt; endl;
	}
	//构造函数
	Date(string);
};

Date::Date(string s)
{
	int flag = 0;
	string number = &quot;0123456789/&quot;;
	string coma = &quot;,&quot;;
	string month;
	unsigned pos, pos1, pos2, pos3;
	unsigned _pos, _pos1;

	/*利用一个判断，现判定怎样初始化*/
	if ((pos = s.find_first_not_of(number)) == string::npos)
	{
		flag = 1;
	}
	if ((pos = s.find_first_of(coma)) != string::npos)
	{
		flag = 2;
	}

	switch (flag)
	{
	case 1:/*处理1/1/1991的格式*/
		pos1 = 0;
		pos1 = s.find_first_of(&quot;/&quot;, pos1);
		_day = stoul(s.substr(0, pos1));//先截取目标字符串，再将字符串转化为unsigned
		pos2 = ++pos1;
		pos1 = s.find_first_of(&quot;/&quot;, pos1);
		_month = stoul(s.substr(pos2, pos1));
		pos3 = ++pos1;
		_year = stoul(s.substr(pos3, s.size() - 1));
		break;
	case 2:/*处理January 1,1900的格式*/
		_pos;
		_pos = s.find_first_of(number);
		month = s.substr(0, _pos);
		//本来想用switch,表达式的结果的类型可以是 整数类型，枚举类型，或者类类型
		//（但该类需要有单一的转换到整数类型或（可以是字符类型，但不能是浮点类型、字符串、指针类型等）
		if (month == &quot;January &quot;) _month = 1;
		if (month == &quot;February &quot;) _month = 2;
		if (month == &quot;March &quot;) _month = 3;
		if (month == &quot;April &quot;) _month = 4;
		if (month == &quot;May &quot;) _month = 5;
		if (month == &quot;June &quot;) _month = 6;
		if (month == &quot;July &quot;) _month = 7;
		if (month == &quot;August &quot;) _month = 8;
		if (month == &quot;September &quot;) _month = 9;
		if (month == &quot;October &quot;) _month = 10;
		if (month == &quot;November &quot;) _month = 11;
		if (month == &quot;December &quot;) _month = 12;

		_pos1 = ++_pos;
		_pos = s.find_first_of(number, _pos);
		_day = stoul(s.substr(_pos1 - 1, _pos));

		_year = stoul(s.substr(_pos, s.size() - 1));
		break;
	case 0:/*处理Jan 1 1995的格式*/
		_pos;
		_pos = s.find_first_of(number);
		month = s.substr(0, _pos);
		if (month == &quot;Jan &quot;) _month = 1;
		if (month == &quot;Feb &quot;) _month = 2;
		if (month == &quot;Mar &quot;) _month = 3;
		if (month == &quot;Apr &quot;) _month = 4;
		if (month == &quot;May &quot;) _month = 5;
		if (month == &quot;Jun &quot;) _month = 6;
		if (month == &quot;Jul &quot;) _month = 7;
		if (month == &quot;Aug &quot;) _month = 8;
		if (month == &quot;Sep &quot;) _month = 9;
		if (month == &quot;Oct &quot;) _month = 10;
		if (month == &quot;Nov &quot;) _month = 11;
		if (month == &quot;Dec &quot;) _month = 12;

		_pos1 = ++_pos;
		_pos = s.find_first_of(number, _pos);
		_day = stoul(s.substr(_pos1 - 1, _pos));

		_year = stoul(s.substr(_pos, s.size() - 1));
		break;
	}
}

int main()
{
	Date _today(&quot;25/2/2017&quot;);
	_today._show();

	Date _tomorrow(&quot;January 1,1995&quot;);
	_tomorrow._show();

	Date _2tomorrow(&quot;Jan 1 1995&quot;);
	_2tomorrow._show();

	return 0;

}
</code></pre>
<p>9.6容器适配器<br>
三个顺序容器适配器：stack（栈）、queue（队列）、propriety_queue<br>
适配器：使某种事物的行为看起来像另外一种事物一样，一个容器适配器接受一种已有的容器，使其行为看起来像一种不同的类型<br>
每个适配器都定义了两个构造函数1.默认构造函数创建一个空对象2.接受一个容器的构造函数拷贝该容器来初始化适配器<br>
栈（stack）适配器 定义在头文件stack中 先进后出<br>
每个容器适配器都基于底层容器类型的操作定义自己的特殊操作，我们只可以使用适配器操作，<strong>而不能使用底层容器类型的操作</strong> 例如：stack基于deque实现时，我们不能直接使用deque的操作，也就是不能再stack上调用push_back,而必须使用stack自己的操作push<br>
队列适配器 queue和priority_queue 定义在queue头文件中 先进先出<br>
书中此处的pop()介绍有误，其实就是用的deque的pop_front()来实现的，是删除元素并不返回<br>
priority_queue允许我们为<strong>队列中的元素建立优先级</strong>，新加入的元素会排在所有优先级比它低的元素之前</p>
<p><strong>stack默认用vector  queue默认用deque priority_queue默认用vector</strong></p>
<p>习题9.52</p>
<pre><code>
int main() {
	string equ{ &quot;1+3+5-4&quot; };
	int sum;
	stack&lt;string&gt; s;
	string equ_l;
	int i = 0,j=0;
	while (i &lt; equ.size()) {
		i = equ.find_first_not_of(num, i);
		if (i == -1) {
			s.push(equ.substr(j, equ.size()-j));
			break;
		}
		s.push(equ.substr(j, i - j));
		if (equ.substr(i, 1) == &quot;)&quot;) {
			string equ_l;
			while (s.top() != &quot;(&quot;)
				equ_l += s.top(), s.pop();
			s.pop();
			s.push(cal(equ_l));
		}
		else
		s.push(equ.substr(i,1));
		j = ++i;
	}
	string equ_all;
	while (!s.empty()) {
		equ_all+=s.top();
		s.pop();
	}
	cout &lt;&lt; stoi(cal(equ_all)) &lt;&lt; endl;
		

}

string cal(string s) {
	int i = 0, j = 0;
	int a = 0, b = 0;
	char sym;
	i = s.find_first_not_of(num, i);
	a = stoi(s.substr(j, i - j));
	while (i &lt; s.size()) {	
		sym = s[i];
		j = ++i;
		i = s.find_first_not_of(num, i);
		b = stoi(s.substr(j, i - j));
		switch (sym) {
		case '+':
			a += b;
			break;
		case'-':
			a -= b;
			break;
		}
		return to_string(a);
	}
}
</code></pre>
<p>习题感悟<br>
使用s.substr(pos,n) 提取一小段string，s.substr(pos,n) 返回一个string，包含s中从pos开始的n个字符的拷贝<br>
注意string的insert接受的是（iter1，iter_beg,iter_end）<br>
注意insert插入最后一个位置是的下标是s.insert(s.size(),ins_s);而不是s.size()-1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 674. 最长连续递增序列]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-674-zui-chang-lian-xu-di-zeng-xu-lie</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-674-zui-chang-lian-xu-di-zeng-xu-lie">
        </link>
        <updated>2019-09-23T14:47:37.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个未经排序的整数数组，找到最长且连续的的递增序列。</p>
<p>示例 1:<br>
输入: [1,3,5,4,7]<br>
输出: 3<br>
解释: 最长连续递增序列是 [1,3,5], 长度为3。<br>
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。<br>
示例 2:<br>
输入: [2,2,2,2,2]<br>
输出: 1<br>
解释: 最长连续递增序列是 [2], 长度为1。<br>
注意：数组长度不会超过10000。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>哈哈哈好久没遇到这么简单的题了，嗯主要就是中间变量的设置吧，比如max和cout的递增时机和赋值时机，这个没什么难度，一次过了，时间复杂度o（n），空间复杂度o（1）</p>
<pre><code>class Solution {
public:
    int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) {
        int len=nums.size();
        if(len==0)
            return 0;
        int max=1;
        int cout=1;
        for(int i=1;i&lt;len;++i){
            if(nums[i]&gt;nums[i-1])
                ++cout;
            else 
                cout=1;
            max=max&gt;cout?max:cout;
        }
        return max;
    }
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>解决方法：滑动窗口<br>
算法：<br>
每个（连续）增加的子序列是不相交的，并且每当 nums[i-1]&gt;=nums[i] 时，每个此类子序列的边界都会出现。当它这样做时，它标志着在 nums[i] 处开始一个新的递增子序列，我们将这样的 i 存储在变量 anchor 中。<br>
例如，如果 nums=[7，8，9，1，2，3]，那么 anchor 从 0 开始（nums[anchor]=7），并再次设置为 anchor=3（nums[anchor]=1）。无论 anchor 的值如何，我们都会记录 i-anchor+1 的候选答案、子数组 nums[anchor]、nums[anchor+1]、…、nums[i] 的长度，并且我们的答案会得到适当的更新。</p>
</blockquote>
<pre><code>Java
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        int ans = 0, anchor = 0;
        for (int i = 0; i &lt; nums.length; ++i) {
            if (i &gt; 0 &amp;&amp; nums[i-1] &gt;= nums[i]) anchor = i;
            ans = Math.max(ans, i - anchor + 1);
        }
        return ans;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(N)，其中 N 是 nums 的长度。我们通过 nums 执行一个循环。<br>
空间复杂度：O(1)，anchor 和 ans 使用了常数级空间。</p>
</blockquote>
<p>其实官方题解是更加简洁的，直接判定每一个存在的转折点anchor，然后将当前位置减去anchor再进行判断存进ans里面。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 334. 递增的三元子序列]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-334-di-zeng-de-san-yuan-zi-xu-lie</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-334-di-zeng-de-san-yuan-zi-xu-lie">
        </link>
        <updated>2019-09-23T09:35:00.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。<br>
数学表达式如下:<br>
如果存在这样的 i, j, k,  且满足 0 ≤ i &lt; j &lt; k ≤ n-1，<br>
使得 arr[i] &lt; arr[j] &lt; arr[k] ，返回 true ; 否则返回 false 。<br>
说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1) 。</p>
<p>示例 1:<br>
输入: [1,2,3,4,5]<br>
输出: true<br>
示例 2:<br>
输入: [5,4,3,2,1]<br>
输出: false</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/increasing-triplet-subsequence<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题其实蛮尴尬的，一开始我以为是判断三个连续的递增子序列，楞了一下怎么这么简单，然后提交错误后分析了错误用例才发现其实要求是ijk这三者是符合大小就行了，也就等于说我们希望在整个数组中从左到右找到三个递增的数列就ok了<br>
由于时间不够，所以直接看了题解，一开始判断三个连续的我就不贴出来啦hhh<br>
然后这一次是没有官方题解的，只有网友解：</p>
<blockquote>
<p>3个连续递增子序列<br>
有3个槽位，a,b,c<br>
满足条件 a &lt; b &lt; c，即可<br>
需要将合适的元素填入这3个槽位</p>
</blockquote>
<pre><code>class Solution {
    public boolean increasingTriplet(int[] nums) {
        int one = Integer.MAX_VALUE;
        int two = Integer.MAX_VALUE;
        
        for (int n : nums) {
            if (n &lt;= one) {
                one = n;
            } else if (n &lt;= two) {
                two = n;
            } else {
                return true;
            }
        }
        
        return false;
    }
}
</code></pre>
<p>这一份最简洁，但是没有解释好原理，特别是one=n这一步其实很让人疑惑，比如数组{2，3，1，5} 此时最后结果为one=1 two=3 ，这里其实是有点让人摸不着头脑的<br>
然后看另外一位网友的解答</p>
<blockquote>
<p>首先，如果只有一个最小值，然后找不到中间值，那么这个数组必然不包含递增的三个数（因为连递增的两个数都找不到）。</p>
<p>然后假设我们找到了两个递增的值，那么如果下一个值小于最小值，我们就应该将最小值的指针定位到这个值上。我们尽可能的使用最小值，防止后面出现了更小的一对递增值，而即使不出现，也不妨碍我们找到解（因为最终是看能否找到大于中间值的值）。<br>
如果下一个值大于最小值，且小于中间值，则我们使用该值作为中间值(因为如果最小的中间值都得不到解，那么就是false，这样也保证了覆盖所有的情况)。</p>
<p>最后，如果找到了大于中间值的值，则为true.</p>
</blockquote>
<p>他的代码有点瑕疵我就不贴上来了。这样一来就很明显了，其实我们是把后面出现的最小值叠在了上面，相当于探寻一个新的递增序列，比如{3，4，1，2，5}，1和2都会叠在3和4上面，构成新的递增序列，但是不用怕，因为只有比原值小的才能叠上去，哪怕1把3覆盖了，所以只要出现5，就一定能正确返回true。<br>
我一开始想过用栈的想法，但是栈的先进先出的特性明显不太适合这个状况，当然这个做法其实是有点取巧的了，就如评论里说，最终的结果无法保证下标的正确性。需要付出额外的代价才能返回正确的坐标。<br>
连续几天没通过了吧，不过还是不要气馁，“无用功”乃成功之母！</p>
]]></content>
    </entry>
</feed>