<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-04-26T08:00:00.708Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>千里之行，始于足下。不积跬步，无以至千里。</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[3.类 -Google C++编程规范]]></title>
        <id>https://lixin-scut.github.io//post/3lei-google-cbian-cheng-gui-fan</id>
        <link href="https://lixin-scut.github.io//post/3lei-google-cbian-cheng-gui-fan">
        </link>
        <updated>2020-04-26T07:16:05.000Z</updated>
        <content type="html"><![CDATA[<h3 id="构造函数的职责">构造函数的职责</h3>
<p><strong>总述</strong></p>
<p>  不要在构造函数中<strong>调用虚函数</strong>, 也不要在无法报出错误时进行可能失败的初始化.</p>
<p><strong>定义</strong></p>
<p>  在构造函数中可以进行各种初始化操作.</p>
<p><strong>优点</strong></p>
<ol>
<li>无需考虑类是否被初始化.</li>
<li>经过构造函数完全初始化后的对象可以为 const 类型, 也能更方便地被标准容器或算法使用.</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>如果在构造函数内调用了自身的虚函数, 这类调用是不会重定向到子类的虚函数实现. 即使当前没有子类化实现, 将来仍是隐患.</li>
<li>在没有使程序崩溃 (因为并不是一个始终合适的方法) 或者使用异常 (因为已经被 禁用 了) 等方法的条件下, 构造函数很难上报错误</li>
<li><strong>如果执行失败, 会得到一个初始化失败的对象, 这个对象有可能进入不正常的状态</strong>, 必须使用 bool IsValid() 或类似这样的机制才能检查出来, 然而这是一个十分容易被疏忽的方法.</li>
<li><strong>构造函数的地址是无法被取得的</strong>, 因此, 举例来说, 由构造函数完成的工作是无法以简单的方式交给其他线程的.</li>
</ol>
<p><strong>结论</strong></p>
<p>  构造函数不允许调用虚函数. 如果代码允许, 直接终止程序是一个合适的处理错误的方式. 否则, 考虑用 Init() 方法或工厂函数.</p>
<p>  <strong>构造函数不得调用虚函数, 或尝试报告一个非致命错误.</strong> 如果对象需要进行有意义的 (non-trivial) 初始化, 考虑使用明确的 Init() 方法或使用工厂模式. Avoid Init() methods on objects with no other states that affect which public methods may be called (此类形式的半构造对象有时无法正确工作).</p>
<h3 id="隐式类型转换">隐式类型转换</h3>
<p><strong>总述</strong></p>
<p>  <strong>不要定义隐式类型转换. 对于转换运算符和单参数构造函数, 请使用 explicit 关键字.</strong></p>
<p><strong>定义</strong></p>
<p>  隐式类型转换允许一个某种类型 (称作 源类型) 的对象被用于需要另一种类型 (称作 目的类型) 的位置, 例如, 将一个 int 类型的参数传递给需要 double 类型的函数.</p>
<p>  除了语言所定义的隐式类型转换, 用户还可以<strong>通过在类定义中添加合适的成员定义自己需要的转换. 在源类型中定义隐式类型转换, 可以通过目的类型名的类型转换运算符实现 (例如 operator bool()).</strong> 在目的类型中定义隐式类型转换, 则通过以源类型作为其唯一参数 (或唯一无默认值的参数) 的构造函数实现.</p>
<p>  explicit 关键字可以用于构造函数或 (在 C++11 引入) 类型转换运算符, 以保证只有当目的类型在调用点被显式写明时才能进行类型转换, 例如使用 cast. 这不仅作用于隐式类型转换, 还能作用于 C++11 的列表初始化语法:</p>
<pre><code>class Foo {
  explicit Foo(int x, double y);
  ...
};

void Func(Foo f);
</code></pre>
<p>此时下面的代码是不允许的:</p>
<pre><code>Func({42, 3.14});  // Error
</code></pre>
<p>  <strong>这一代码从技术上说并非隐式类型转换, 但是语言标准认为这是 explicit 应当限制的行为.</strong></p>
<p><strong>优点</strong></p>
<ol>
<li>有时目的类型名是一目了然的, 通过避免显式地写出类型名, 隐式类型转换可以让一个类型的可用性和表达性更强.</li>
<li><strong>隐式类型转换可以简单地取代函数重载.</strong></li>
<li>在初始化对象时, 列表初始化语法是一种简洁明了的写法.</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>隐式类型转换会隐藏类型不匹配的错误. 有时, 目的类型并不符合用户的期望, 甚至用户根本没有意识到发生了类型转换.</li>
<li><strong>隐式类型转换会让代码难以阅读, 尤其是在有函数重载的时候, 因为这时很难判断到底是哪个函数被调用.</strong></li>
<li>单参数构造函数有可能会被无意地用作隐式类型转换.</li>
<li>如果单参数构造函数没有加上 explicit 关键字, 读者无法判断这一函数究竟是要作为隐式类型转换, 还是作者忘了加上 explicit 标记.</li>
<li>并没有明确的方法用来判断哪个类应该提供类型转换, 这会使得代码变得含糊不清.</li>
<li>如果目的类型是隐式指定的, 那么列表初始化会出现和隐式类型转换一样的问题, 尤其是在列表中只有一个元素的时候.</li>
</ol>
<p><strong>结论</strong></p>
<p>  <strong>在类型定义中, 类型转换运算符和单参数构造函数都应当用 explicit 进行标记.</strong> 一个例外是,<strong>拷贝和移动构造函数不应当被标记为 explicit, 因为它们并不执行类型转换</strong>. 对于设计目的就是用于对其他类型进行透明包装的类来说, 隐式类型转换有时是必要且合适的. 这时应当联系项目组长并说明特殊情况.</p>
<p>  <strong>不能以一个参数进行调用的构造函数不应当加上 explicit. 接受一个 std::initializer_list 作为参数的构造函数也应当省略 explicit, 以便支持拷贝初始化</strong> (例如 MyType m = {1, 2};) .</p>
<h3 id="可拷贝类型和可移动类型">可拷贝类型和可移动类型</h3>
<p><strong>总述</strong></p>
<p>  <strong>如果你的类型需要, 就让它们支持拷贝 / 移动. 否则, 就把隐式产生的拷贝和移动函数禁用.</strong></p>
<p><strong>定义</strong></p>
<p>  <strong>可拷贝类型允许对象</strong>在初始化时得到来自相同类型的另一对象的值, 或在赋值时被赋予相同类型的另一对象的值, 同时不改变源对象的值. 对于用户定义的类型, 拷贝操作一般通过拷贝构造函数与拷贝赋值操作符定义. string 类型就是一个可拷贝类型的例子.</p>
<p>  <strong>可移动类型允许对象</strong>在初始化时得到来自相同类型的临时对象的值, 或在赋值时被赋予相同类型的临时对象的值 (因此所有可拷贝对象也是可移动的). <code>std::unique_ptr&lt;int&gt;</code> 就是一个可移动但不可复制的对象的例子. 对于用户定义的类型, 移动操作一般是通过移动构造函数和移动赋值操作符实现的.</p>
<p>  拷贝 / 移动构造函数在某些情况下会被编译器隐式调用. 例如, 通过传值的方式传递对象.</p>
<p><strong>优点</strong></p>
<p>  可移动及可拷贝类型的对象可以通过传值的方式进行传递或者返回, 这使得 API 更简单, 更安全也更通用. 与传指针和引用不同, 这样的传递不会造成所有权, 生命周期, 可变性等方面的混乱, 也就没必要在协议中予以明确. 这同时也防止了客户端与实现在非作用域内的交互, 使得它们更容易被理解与维护. 这样的对象可以和需要传值操作的通用 API 一起使用, 例如大多数容器.</p>
<p>  拷贝 / 移动构造函数与赋值操作一般来说要比它们的各种替代方案, 比如 Clone(), CopyFrom() or Swap(), 更容易定义, 因为它们能通过编译器产生, 无论是隐式的还是通过 = default. 这种方式很简洁, 也保证所有数据成员都会被复制. 拷贝与移动构造函数一般也更高效, 因为它们不需要堆的分配或者是单独的初始化和赋值步骤, 同时, 对于类似 省略不必要的拷贝 这样的优化它们也更加合适.</p>
<p>  <strong>移动操作允许隐式且高效地将源数据转移出右值对象.</strong> 这有时能让代码风格更加清晰.</p>
<p><strong>缺点</strong></p>
<p>  许多类型都不需要拷贝, 为它们提供拷贝操作会让人迷惑, 也显得荒谬而不合理. 单件类型 (Registerer), 与特定的作用域相关的类型 (Cleanup), 与其他对象实体紧耦合的类型 (Mutex) 从逻辑上来说都不应该提供拷贝操作. 为基类提供拷贝 / 赋值操作是有害的, 因为在使用它们时会造成 对象切割 . 默认的或者随意的拷贝操作实现可能是不正确的, 这往往导致令人困惑并且难以诊断出的错误.</p>
<p>  拷贝构造函数是隐式调用的, 也就是说, 这些调用很容易被忽略. 这会让人迷惑, 尤其是对那些所用的语言约定或强制要求传引用的程序员来说更是如此. 同时, 这从一定程度上说会鼓励过度拷贝, 从而导致性能上的问题.</p>
<p><strong>结论</strong></p>
<p>  如果需要就让你的类型可拷贝 / 可移动. 作为一个经验法则, 如果对于你的用户来说这个拷贝操作不是一眼就能看出来的, 那就不要把类型设置为可拷贝.<strong>如果让类型可拷贝, 一定要同时给出拷贝构造函数和赋值操作的定义, 反之亦然. 如果让类型可拷贝, 同时移动操作的效率高于拷贝操作, 那么就把移动的两个操作 (移动构造函数和赋值操作) 也给出定义.</strong> 如果类型不可拷贝, 但是移动操作的正确性对用户显然可见, 那么把这个类型设置为只可移动并定义移动的两个操作.</p>
<p>  如果定义了拷贝/移动操作, 则要保证这些操作的默认实现是正确的. 记得时刻检查默认操作的正确性, 并且在文档中说明类是可拷贝的且/或可移动的.</p>
<pre><code>class Foo {
 public:
  Foo(Foo&amp;&amp; other) : field_(other.field) {}
  // 差, 只定义了移动构造函数, 而没有定义对应的赋值运算符.

 private:
  Field field_;
};
</code></pre>
<p>  <strong>由于存在对象切割的风险, 不要为任何有可能有派生类的对象提供赋值操作或者拷贝 / 移动构造函数</strong> (当然也不要继承有这样的成员函数的类). 如果你的基类需要可复制属性, 请提供一个 <strong>public virtual Clone() 和一个 protected 的拷贝构造函数以供派生类实现.</strong></p>
<p>  如果你的类不需要拷贝 / 移动操作, 请显式地通过在 public 域中使用 = delete 或其他手段禁用之.</p>
<pre><code>// MyClass is neither copyable nor movable.
MyClass(const MyClass&amp;) = delete;
MyClass&amp; operator=(const MyClass&amp;) = delete;
</code></pre>
<h3 id="结构体-vs-类">结构体 VS. 类</h3>
<p><strong>总述</strong></p>
<p>  <strong>仅当只有数据成员时使用 struct, 其它一概使用 class.</strong></p>
<p><strong>说明</strong></p>
<p>  在 C++ 中 struct 和 class 关键字几乎含义一样. 我们为这两个关键字添加我们自己的语义理解, 以便为定义的数据类型选择合适的关键字.</p>
<p>  struct 用来定义包含数据的被动式对象, 也可以包含相关的常量, 但除了存取数据成员之外, 没有别的函数功能. 并且存取功能是通过直接访问位域, 而非函数调用. 除了构造函数, 析构函数, Initialize(), Reset(), Validate() 等类似的用于设定数据成员的函数外, 不能提供其它功能的函数.</p>
<p>  如果需要更多的函数功能, class 更适合. 如果拿不准, 就用 class.</p>
<p><strong>为了和 STL 保持一致, 对于仿函数等特性可以不用 class 而是使用 struct.</strong></p>
<p>  注意: 类和结构体的成员变量使用不同的 命名规则.</p>
<h3 id="继承">继承</h3>
<p><strong>总述</strong></p>
<p>  使用组合 (YuleFox 注: 这一点也是 GoF 在<code>&lt;&lt;Design Patterns&gt;&gt;</code>里反复强调的) 常常比使用继承更合理. 如果使用继承的话, 定义为 public 继承.</p>
<p><strong>定义</strong></p>
<p>  当子类继承基类时, 子类包含了父基类所有数据及操作的定义. C++ 实践中, 继承主要用于两种场合: 实现继承, 子类继承父类的实现代码; 接口继承, 子类仅继承父类的方法名称.</p>
<p><strong>优点</strong></p>
<p>  实现继承通过原封不动的复用基类代码减少了代码量. 由于继承是在编译时声明, 程序员和编译器都可以理解相应操作并发现错误. 从编程角度而言, 接口继承是用来强制类输出特定的 API. 在类没有实现 API 中某个必须的方法时, 编译器同样会发现并报告错误.</p>
<p><strong>缺点</strong></p>
<p>  对于实现继承, 由于子类的实现代码散布在父类和子类间之间, 要理解其实现变得更加困难. 子类不能重写父类的非虚函数, 当然也就不能修改其实现. 基类也可能定义了一些数据成员, 因此还必须区分基类的实际布局.</p>
<p><strong>结论</strong></p>
<p>  所有继承必须是 public 的. 如果你想使用私有继承, 你应该替换成把基类的实例作为成员对象的方式.</p>
<p>  不要过度使用实现继承. 组合常常更合适一些. 尽量做到只在 “是一个” (“is-a”, YuleFox 注: 其他 “has-a” 情况下请使用组合) 的情况下使用继承: 如果 Bar 的确 “是一种” Foo, Bar 才能继承 Foo.</p>
<p>  必要的话, 析构函数声明为 virtual. 如果你的类有虚函数, 则析构函数也应该为虚函数.</p>
<p>  对于可能被子类访问的成员函数, 不要过度使用 protected 关键字. 注意, 数据成员都必须是 私有的.</p>
<p>  对于重载的虚函数或虚析构函数, 使用 override, 或 (较不常用的) final 关键字显式地进行标记. 较早 (早于 C++11) 的代码可能会使用 virtual 关键字作为不得已的选项. 因此, 在声明重载时, 请使用 override, final 或 virtual 的其中之一进行标记. 标记为 override 或 final 的析构函数如果不是对基类虚函数的重载的话, 编译会报错, 这有助于捕获常见的错误. 这些标记起到了文档的作用, 因为如果省略这些关键字, 代码阅读者不得不检查所有父类, 以判断该函数是否是虚函数.</p>
<h3 id="多重继承">多重继承</h3>
<p><strong>总述</strong></p>
<p>  真正需要用到多重实现继承的情况少之又少. <strong>只在以下情况我们才允许多重继承: 最多只有一个基类是非抽象类; 其它基类都是以 Interface 为后缀的 纯接口类.</strong></p>
<p><strong>定义</strong></p>
<p>  多重继承允许子类拥有多个基类. <strong>要将作为 纯接口 的基类和具有 实现 的基类区别开来.</strong></p>
<p><strong>优点</strong></p>
<p>  相比单继承 (见 继承), 多重实现继承可以复用更多的代码.</p>
<p><strong>缺点</strong></p>
<p>  真正需要用到多重 实现 继承的情况少之又少. 有时多重实现继承看上去是不错的解决方案, 但这时你通常也可以找到一个更明确, 更清晰的不同解决方案.</p>
<p><strong>结论</strong></p>
<p>  只有当所有父类除第一个外都是 纯接口类 时, 才允许使用多重继承. 为确保它们是纯接口, 这些类必须以 Interface 为后缀.</p>
<h3 id="接口">接口</h3>
<p><strong>总述</strong></p>
<p>  <strong>接口是指满足特定条件的类, 这些类以 Interface 为后缀 (不强制).</strong></p>
<p><strong>定义</strong></p>
<p>当一个类满足以下要求时, 称之为纯接口:</p>
<ol>
<li><strong>只有纯虚函数 (“=0”) 和静态函数 (除了下文提到的析构函数).</strong></li>
<li><strong>没有非静态数据成员.</strong></li>
<li><strong>没有定义任何构造函数. 如果有, 也不能带有参数, 并且必须为 protected.</strong></li>
<li>如果它是一个子类, 也只能从满足上述条件并以 Interface 为后缀的类继承.</li>
</ol>
<p>  接口类不能被直接实例化, 因为它声明了纯虚函数. 为确保接口类的所有实现可被正确销毁, 必须为之声明虚析构函数 (作为上述第 1 条规则的特例, 析构函数不能是纯虚函数). 具体细节可参考 Stroustrup 的 The C++ Programming Language, 3rd edition 第 12.4 节.</p>
<p><strong>优点</strong></p>
<p>  以 Interface 为后缀可以提醒其他人不要为该接口类增加函数实现或非静态数据成员. 这一点对于 多重继承 尤其重要. 另外, 对于 Java 程序员来说, 接口的概念已是深入人心.</p>
<p><strong>缺点</strong></p>
<p>  Interface 后缀增加了类名长度, 为阅读和理解带来不便. 同时, 接口属性作为实现细节不应暴露给用户.</p>
<p><strong>结论</strong></p>
<p>  只有在满足上述条件时, 类才以 Interface 结尾, 但反过来, 满足上述需要的类未必一定以 Interface 结尾.</p>
<h3 id="运算符重载">运算符重载</h3>
<p><strong>总述</strong></p>
<p>  除少数特定环境外, <strong>不要重载运算符. 也不要创建用户定义字面量.</strong></p>
<p><strong>定义</strong></p>
<p>  C++ 允许用户通过使用 operator 关键字 对内建运算符进行重载定义 , 只要其中一个参数是用户定义的类型. operator 关键字还允许用户使用 operator&quot;&quot; 定义新的字面运算符, 并且<strong>定义类型转换函数, 例如 operator bool().</strong></p>
<p><strong>优点</strong></p>
<p>  重载运算符可以让代码更简洁易懂, 也使得用户定义的类型和内建类型拥有相似的行为. 重载运算符对于某些运算来说是符合符合语言习惯的名称 (例如 ==, &lt;, =, &lt;&lt;), 遵循这些语言约定可以让用户定义的类型更易读, 也能更好地和需要这些重载运算符的函数库进行交互操作.</p>
<p>  对于创建用户定义的类型的对象来说, 用户定义字面量是一种非常简洁的标记.</p>
<p><strong>缺点</strong></p>
<ol>
<li>要提供正确, 一致, 不出现异常行为的操作符运算需要花费不少精力, 而且如果达不到这些要求的话, 会导致令人迷惑的 Bug.</li>
<li>过度使用运算符会带来难以理解的代码, 尤其是在重载的操作符的语义与通常的约定不符合时.</li>
<li>函数重载有多少弊端, 运算符重载就至少有多少.</li>
<li>运算符重载会混淆视听, 让你误以为一些耗时的操作和操作内建类型一样轻巧.</li>
<li>对重载运算符的调用点的查找需要的可就不仅仅是像 grep 那样的程序了, 这时需要能够理解 C++ 语法的搜索工具.</li>
<li><strong>如果重载运算符的参数写错, 此时得到的可能是一个完全不同的重载而非编译错误.</strong> 例如: foo &lt; bar 执行的是一个行为, 而 &amp;foo &lt; &amp;bar 执行的就是完全不同的另一个行为了.</li>
<li>重载某些运算符本身就是有害的. 例如, 重载一元运算符 &amp; 会导致同样的代码有完全不同的含义, 这取决于重载的声明对某段代码而言是否是可见的. <strong>重载诸如 &amp;&amp;, || 和 , 会导致运算顺序和内建运算的顺序不一致.</strong></li>
<li>运算符从通常定义在类的外部, 所以对于同一运算, 可能出现不同的文件引入了不同的定义的风险. 如果两种定义都链接到同一二进制文件, 就会导致未定义的行为, 有可能表现为难以发现的运行时错误.</li>
<li>用户定义字面量所创建的语义形式对于某些有经验的 C++ 程序员来说都是很陌生的.</li>
</ol>
<p><strong>结论</strong></p>
<p>  <strong>只有在意义明显, 不会出现奇怪的行为并且与对应的内建运算符的行为一致时才定义重载运算符.</strong> 例如, | 要作为位或或逻辑或来使用, 而不是作为 shell 中的管道.</p>
<p>  只有对用户自己定义的类型重载运算符. 更准确地说, 将它们和它们所操作的类型定义在同一个头文件中, .cc 中和命名空间中. 这样做无论类型在哪里都能够使用定义的运算符, 并且最大程度上避免了多重定义的风险. 如果可能的话, <strong>请避免将运算符定义为模板, 因为此时它们必须对任何模板参数都能够作用</strong>. 如果你定义了一个运算符, 请将其相关且有意义的运算符都进行定义, 并且保证这些定义的语义是一致的. 例如, 如果你重载了 &lt;, 那么请将所有的比较运算符都进行重载, 并且保证对于同一组参数, &lt; 和 &gt; 不会同时返回 true.</p>
<p>  <strong>建议不要将不进行修改的二元运算符定义为成员函数. 如果一个二元运算符被定义为类成员, 这时隐式转换会作用域右侧的参数却不会作用于左侧</strong>. 这时会出现 a &lt; b 能够通过编译而 b &lt; a 不能的情况, 这是很让人迷惑的.</p>
<p>  <strong>不要为了避免重载操作符而走极端</strong>. 比如说, 应当定义 ==, =, 和 &lt;&lt; 而不是 Equals(), CopyFrom() 和 PrintTo(). 反过来说, <strong>不要只是为了满足函数库需要而去定义运算符重载</strong>. 比如说, 如果你的类型没有自然顺序, 而你要将它们存入 std::set 中, 最好还是定义一个自定义的比较运算符而不是重载 &lt;.</p>
<p>  不要重载 &amp;&amp;, ||, , 或一元运算符 &amp;. 不要重载 operator&quot;&quot;, 也就是说, 不要引入用户定义字面量.</p>
<p>  类型转换运算符在 隐式类型转换 一节有提及. = 运算符在 可拷贝类型和可移动类型 一节有提及. 运算符 &lt;&lt; 在 流 一节有提及. 同时请参见 函数重载 一节, 其中提到的的规则对运算符重载同样适用.</p>
<h3 id="存取控制">存取控制</h3>
<p><strong>总述</strong></p>
<p>  <strong>将 所有 数据成员声明为 private, 除非是 static const 类型成员</strong> (遵循 常量命名规则). 处于技术上的原因, 在使用 Google Test 时我们允许测试固件类中的数据成员为 protected.</p>
<h3 id="声明顺序">声明顺序</h3>
<p><strong>总述</strong></p>
<p>  <strong>将相似的声明放在一起, 将 public 部分放在最前.</strong></p>
<p><strong>说明</strong></p>
<p>  类定义一般应以 public: 开始, 后跟 protected:, 最后是 private:. 省略空部分.</p>
<p>  在各个部分中, 建议将类似的声明放在一起, <strong>并且建议以如下的顺序: 类型 (包括 typedef, using 和嵌套的结构体与类), 常量, 工厂函数, 构造函数, 赋值运算符, 析构函数, 其它函数, 数据成员.</strong></p>
<p>  不要将大段的函数定义内联在类定义中. 通常，只有那些普通的, 或性能关键且短小的函数可以内联在类定义中. 参见 内联函数 一节.</p>
<h3 id="译者笔记">译者笔记：</h3>
<ol>
<li>不在构造函数中做太多逻辑相关的初始化;</li>
<li>编译器提供的默认构造函数不会对变量进行初始化, 如果定义了其他构造函数, 编译器不再提供, 需要编码者自行提供默认构造函数;</li>
<li>为避免隐式转换, 需将单参数构造函数声明为 explicit;</li>
<li>为避免拷贝构造函数, 赋值操作的滥用和编译器自动生成, 可将其声明为 private 且无需实现;</li>
<li>仅在作为数据集合时使用 struct;</li>
<li>组合 &gt; 实现继承 &gt; 接口继承 &gt; 私有继承, 子类重载的虚函数也要声明 virtual 关键字, 虽然编译器允许不这样做;</li>
<li>避免使用多重继承, 使用时, 除一个基类含有实现外, 其他基类均为纯接口;</li>
<li>接口类类名以 Interface 为后缀, 除提供带实现的虚析构函数, 静态成员函数外, 其他均为纯虚函数, 不定义非静态数据成员, 不提供构造函数, 提供的话, 声明为 protected;</li>
<li>为降低复杂性, 尽量不重载操作符, 模板, 标准类中使用时提供文档说明;</li>
<li>存取函数一般内联在头文件中;</li>
<li>声明次序: public -&gt; protected -&gt; private;</li>
<li>函数体尽量短小, 紧凑, 功能单一;</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[派生类中声明新的虚函数]]></title>
        <id>https://lixin-scut.github.io//post/pai-sheng-lei-zhong-sheng-ming-xin-de-xu-han-shu</id>
        <link href="https://lixin-scut.github.io//post/pai-sheng-lei-zhong-sheng-ming-xin-de-xu-han-shu">
        </link>
        <updated>2020-04-26T07:04:59.000Z</updated>
        <content type="html"><![CDATA[<p>这种情况本不应该发生，应该在基类中定义好所有的接口，派生类仅仅负责继承基类并且override虚函数即可，探讨这种情况存粹是我比较好奇。</p>
<p>假设有这样三个类的声明：</p>
<pre><code>class A {
public:
    virtual void fun1() {
        cout &lt;&lt; &quot;A::fun1&quot; &lt;&lt; endl;
    }
};

class B : public A {
public:
    virtual void fun1() {
        cout &lt;&lt; &quot;B::fun1&quot; &lt;&lt; endl;
    }
    virtual void fun2() {
        cout &lt;&lt; &quot;B::fun2&quot; &lt;&lt; endl;
    }
};

class C : public B {
public:
    virtual void fun2() {
        cout &lt;&lt; &quot;C::fun2&quot; &lt;&lt; endl;
    }
};

B *pb1 = new B;
B *pb2 = new C;
pb1-&gt;fun2(); // B::fun2
pb2-&gt;fun2(); // C::fun2
</code></pre>
<p>继承A后，新声明了个虚函数fun2，并被C继承，此时用B的指针指向C的对象可以实现多态。<br>
观察内存可以发现B和C的虚函数表里只保存了fun1的地址，并没有fun2的地址</p>
<p>真实的情况是这样的。类B不仅覆盖了A，还增加了一个虚函数，<strong>所以B里面就会有两张虚函数表，一张用来保存fun1，一张用来保存fun2。</strong></p>
<p>因此写成C语言大概就这样：</p>
<pre><code>void A_fun1(A* this)
{
    cout &lt;&lt; &quot;A::fun1&quot; &lt;&lt; endl;
}

void B_fun1(A* this)
{
    cout &lt;&lt; &quot;B::fun1&quot; &lt;&lt; endl;
}

void B_fun2(B* this)
{
    cout &lt;&lt; &quot;B::fun2&quot; &lt;&lt; endl;
}

void C_fun2(B* this)
{
    cout &lt;&lt; &quot;C::fun2&quot; &lt;&lt; endl;
}

struct vtable_A
{
    void (*fun1)(A*);
};

struct vtable_B
{
    void (*fun2)(B*);
};

vtable_A vtable_A_instance_A = { &amp;A_fun1 };
vtable_A vtable_A_instance_B = { &amp;B_fun1 };
vtable_B vtable_B_instance_B = { &amp;B_fun2 };
vtable_B vtable_B_instance_C = { &amp;C_fun2 };

struct A
{
    vtable_A* vtable;
};

struct B
{
    A _A;
    vtable_B* vtable;
};

struct C
{
    B _B;
};

void ctor_A(A* a)
{
    a-&gt;vtable = &amp;vtable_A_instance_A;
}

void ctor_B(B* b)
{
    ctor_A(&amp;b._A);
    b-&gt;_A.vtable = &amp;vtable_A_instance_B;
    b-&gt;vtable = &amp;vtable_B_instance_B;
}

void ctor_C(C* c)
{
    ctor_B(&amp;c._B);
    c._B.vtable = &amp;vtable_B_instance_C;
}

int main()
{
    B* pb1 = (B*)malloc(sizeof(B));
    ctor_B(pb1);
    C* temp = (C*)malloc(sizeof(C));
    ctor_C(temp);
    B* pb2 = &amp;temp._B;
    pb1-&gt;vtable-&gt;fun2(pb1);
    pb2-&gt;vtable-&gt;fun2(pb1);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2.作用域 -Google C++编程规范]]></title>
        <id>https://lixin-scut.github.io//post/2zuo-yong-yu-google-cbian-cheng-gui-fan</id>
        <link href="https://lixin-scut.github.io//post/2zuo-yong-yu-google-cbian-cheng-gui-fan">
        </link>
        <updated>2020-04-24T08:27:03.000Z</updated>
        <content type="html"><![CDATA[<h3 id="命名空间">命名空间</h3>
<ol>
<li>鼓励在 .cc 文件内使用匿名命名空间或 static 声明. 使用具名的命名空间时, 其名称可基于项目名或相对路径.</li>
<li><strong>禁止使用 using 指示（using-directive）。禁止使用内联命名空间（inline namespace）。</strong></li>
</ol>
<p><strong>命名空间定义:</strong><br>
  命名空间将全局作用域细分为独立的, 具名的作用域, 可<strong>有效防止全局作用域的命名冲突.</strong><br>
  举例来说, 两个不同项目的全局作用域都有一个类 Foo, 这样在编译或运行时造成冲突. 如果每个项目将代码置于不同命名空间中, project1::Foo 和 project2::Foo 作为不同符号自然不会冲突.</p>
<p><strong>内联命名空间</strong><br>
内联命名空间会自动把内部的标识符放到外层作用域</p>
<pre><code>namespace X {
inline namespace Y {
void foo();
}  // namespace Y
}  // namespace X
</code></pre>
<p>X::Y::foo() 与 X::foo() 彼此可代替。<strong>内联命名空间主要用来保持跨版本的 ABI 兼容性。</strong><br>
<strong>但是，在头文件中使用匿名空间导致违背 C++ 的唯一定义原则 (One Definition Rule (ODR)).</strong></p>
<p>使用命名空间的守则：</p>
<ul>
<li>遵守 命名空间命名 中的规则。</li>
<li>像之前的几个例子中一样，在命名空间的最后注释出命名空间的名字。</li>
<li>用命名空间把文件包含, gflags 的声明/定义, 以及类的前置声明以外的整个源文件封装起来, 以区别于其它命名空间:</li>
</ul>
<pre><code>// .h 文件
namespace mynamespace {

// 所有声明都置于命名空间中
// 注意不要使用缩进
class MyClass {
    public:
    ...
    void Foo();
};

} // namespace mynamespace
</code></pre>
<pre><code>// .cc 文件
namespace mynamespace {

// 函数定义都置于命名空间中
void MyClass::Foo() {
    ...
}

} // namespace mynamespace
</code></pre>
<p>更复杂的 .cc 文件包含更多, 更复杂的细节, 比如 gflags 或 using 声明。</p>
<pre><code>#include &quot;a.h&quot;

DEFINE_FLAG(bool, someflag, false, &quot;dummy flag&quot;);

namespace a {

...code for a...                // 左对齐

} // namespace a
</code></pre>
<ul>
<li>不要在命名空间 std 内声明任何东西, 包括标准库的类前置声明. 在 std 命名空间声明实体是未定义的行为, 会导致如不可移植. 声明标准库下的实体, 需要包含对应的头文件.</li>
<li><strong>不应该使用 using 指示 引入整个命名空间的标识符号</strong>。</li>
</ul>
<pre><code>// 禁止 —— 污染命名空间
using namespace foo;
</code></pre>
<ul>
<li><strong>不要在头文件中使用 命名空间别名 除非显式标记内部命名空间使用</strong>。因为任何在头文件中引入的命名空间都会成为公开API的一部分。</li>
</ul>
<pre><code>// 在 .cc 中使用别名缩短常用的命名空间
namespace baz = ::foo::bar::baz;
</code></pre>
<pre><code>// 在 .h 中使用别名缩短常用的命名空间
namespace librarian {
namespace impl {  // 仅限内部使用
namespace sidetable = ::pipeline_diagnostics::sidetable;
}  // namespace impl

inline void my_inline_function() {
  // 限制在一个函数中的命名空间别名
  namespace baz = ::foo::bar::baz;
  ...
}
}  // namespace librarian
</code></pre>
<ul>
<li><strong>禁止用内联命名空间</strong></li>
</ul>
<h3 id="匿名命名空间和静态变量">匿名命名空间和静态变量</h3>
<p>  在 .cc 文件中定义一个<strong>不需要被外部引用的变量时</strong>，可以将它们放在<strong>匿名命名空间或声明为 static</strong> 。但是<strong>不要在 .h 文件中这么做</strong>。</p>
<p>定义:</p>
<p>  所有置于匿名命名空间的声明都具有<strong>内部链接性（仅在文件内有效）</strong>，<strong>函数和变量可以经由声明为 static 拥有内部链接性</strong>，这意味着你在这个文件中声明的这些标识符都不能在另一个文件中被访问。即使两个文件声明了完全一样名字的标识符，它们所指向的实体实际上是完全不同的。</p>
<p>结论:</p>
<p>  <strong>推荐、鼓励在 .cc 中对于不需要在其他地方引用的标识符使用内部链接性声明，但是不要在 .h 中使用。</strong></p>
<p>匿名命名空间的声明和具名的格式相同，在最后注释上 namespace :</p>
<pre><code>namespace {
...
}  // namespace
</code></pre>
<h3 id="非成员函数-静态成员函数和全局函数">非成员函数、静态成员函数和全局函数</h3>
<p>  使用<strong>静态成员函数</strong>或<strong>命名空间内的非成员函数</strong>, <strong>尽量不要用裸的全局函数</strong>. 将一系列函数直接置于命名空间中，<strong>不要用类的静态方法模拟出命名空间的效果</strong>，类的静态方法应当和类的实例或静态数据紧密相关.</p>
<p>优点:</p>
<p>  某些情况下, 非成员函数和静态成员函数是非常有用的, <strong>将非成员函数放在命名空间内可避免污染全局作用域</strong>.</p>
<p>缺点:</p>
<p>  <strong>将非成员函数和静态成员函数作为新类的成员或许更有意义</strong>, 当它们<strong>需要访问外部资源或具有重要的依赖关系时</strong>更是如此.</p>
<p>结论:</p>
<p>  有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的. 这样的函数可以被定义成静态成员, 或是非成员函数. 非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内. <strong>相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类, 不如使用命名空间</strong> 。</p>
<p>  <strong>定义在同一编译单元的函数, 被其他编译单元直接调用可能会引入不必要的耦合和链接时依赖; 静态成员函数对此尤其敏感.</strong> 可以考虑提取到新类中, 或者将函数置于独立库的命名空间内.</p>
<p>  <strong>如果你必须定义非成员函数, 又只是在 .cc 文件中使用它, 可使用匿名命名空间 或 static 链接关键字 (如 static int Foo() {...}) 限定其作用域.</strong></p>
<h3 id="局部变量">局部变量</h3>
<p>  <strong>将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化.</strong></p>
<p>  C++ 允许在函数的任何位置声明变量. 我们<strong>提倡在尽可能小的作用域中声明变量, 离第一次使用越近越好</strong>. 这使得代码浏览者更容易定位变量声明的位置, 了解变量的类型和初始值. 特别是，<strong>应使用初始化的方式替代声明再赋值</strong>, 比如:</p>
<p>  <strong>有一个例外, 如果变量是一个对象, 每次进入作用域都要调用其构造函数, 每次退出作用域都要调用其析构函数. 这会导致效率降低.</strong></p>
<pre><code>// 低效的实现
for (int i = 0; i &lt; 1000000; ++i) {
    Foo f;                  // 构造函数和析构函数分别调用 1000000 次!
    f.DoSomething(i);
}
</code></pre>
<p>在循环作用域外面声明这类变量要高效的多:</p>
<pre><code>Foo f;                      // 构造函数和析构函数只调用 1 次
for (int i = 0; i &lt; 1000000; ++i) {
    f.DoSomething(i);
}
</code></pre>
<h3 id="静态和全局变量">静态和全局变量</h3>
<p>  禁止定义静态储存周期<strong>非POD变量</strong>，禁止使用<strong>含有副作用的函数初始化POD全局变量</strong>，因为<strong>多编译单元中的静态变量执行时的构造和析构顺序是未明确的，这将导致代码的不可移植</strong>。</p>
<p>  <strong>禁止使用类的 静态储存周期 变量：由于构造和析构函数调用顺序的不确定性，它们会导致难以发现的 bug</strong> 。不过 constexpr 变量除外，毕竟它们又不涉及动态初始化或析构。</p>
<p><strong>静态生存周期的对象，即包括了全局变量，静态变量，静态类成员变量和函数静态变量，都必须是原生数据类型</strong> (POD : Plain Old Data): 即 int, char 和 float, 以及 POD 类型的指针、数组和结构体。</p>
<p>  <strong>静态变量的构造函数、析构函数和初始化的顺序在 C++ 中是只有部分明确的，甚至随着构建变化而变化，导致难以发现的 bug</strong>. 所以除了禁用类类型的全局变量，我们<strong>也不允许用函数返回值来初始化 POD 变量</strong>，除非该函数（比如 getenv() 或 getpid() ）不涉及任何全局变量。<strong>函数作用域里的静态变量除外，毕竟它的初始化顺序是有明确定义的，而且只会在指令执行到它的声明那里才会发生。</strong></p>
<p>  <strong>同一个编译单元内是明确的</strong>，静态初始化优先于动态初始化，初始化顺序按照声明顺序进行，销毁则逆序。<strong>不同的编译单元之间初始化和销毁顺序属于未明确行为 (unspecified behaviour)</strong>。</p>
<p>  同理，<strong>全局和静态变量在程序中断时会被析构</strong>，无论所谓中断是从 main() 返回还是对 exit() 的调用。析构顺序正好与构造函数调用的顺序相反。但既然<strong>构造顺序未定义，那么析构顺序当然也就不定了。</strong> 比如，在程序结束时某静态变量已经被析构了，但代码还在跑——比如其它线程——并试图访问它且失败；再比如，一个静态 string 变量也许会在一个引用了前者的其它变量析构之前被析构掉。</p>
<p>  改善以上析构问题的办法之一是<strong>用 quick_exit() 来代替 exit() 并中断程序</strong>。它们的不同之处是<strong>前者不会执行任何析构，也不会执行 atexit() 所绑定的任何 handlers</strong>. 如果您想在执行 quick_exit() 来中断时执行某 handler（比如刷新 log），您可以把它绑定到 _at_quick_exit(). 如果您想在 exit() 和 quick_exit() 都用上该 handler, 都绑定上去。</p>
<p>  综上所述，<strong>我们只允许 POD 类型的静态变量，即完全禁用 vector (使用 C 数组替代) 和 string (使用 const char [])</strong>。</p>
<p>  如果<strong>您确实需要一个 class 类型的静态或全局变量</strong>，可以考虑在 main() 函数或 pthread_once() 内<strong>初始化一个指针且永不回收</strong>。注意<strong>只能用 raw 指针，别用智能指针，毕竟后者的析构函数涉及到上文指出的不定顺序问题</strong>。<br>
（疑惑： 这个解决方法的目的是？）</p>
<p>  上文提及的静态变量泛指静态生存周期的对象, 包括: <strong>全局变量, 静态变量, 静态类成员变量, 以及函数静态变量.</strong></p>
<p>注意事项：</p>
<ol>
<li><strong>cc 中的匿名命名空间可避免命名冲突, 限定作用域</strong>, 避免直接使用 using 关键字污染命名空间;</li>
<li>嵌套类符合局部使用原则, 只是不能在其他头文件中前置声明, 尽量不要 public;</li>
<li><strong>尽量不用全局函数和全局变量, 考虑作用域和命名空间限制, 尽量单独形成编译单元;</strong></li>
<li><strong>多线程中的全局变量 (含静态成员变量) 不要使用 class 类型 (含 STL 容器), 避免不明确行为导致的 bug.</strong></li>
<li>作用域的使用, 除了考虑名称污染, 可读性之外, 主要是为<strong>降低耦合, 提高编译/执行效率.</strong></li>
<li>注意「using 指示（using-directive）」和「using 声明（using-declaration）」的区别。</li>
<li>匿名命名空间说白了就是文件作用域，就像<strong>C static 声明的作用域一样，后者已经被 C++ 标准提倡弃用。</strong></li>
<li>局部变量在声明的同时进行显式值初始化，比起隐式初始化再赋值的两步过程要高效，同时也贯彻了计算机体系结构重要的概念「局部性（locality）」。</li>
<li>注意<strong>别在循环犯大量构造和析构的低级错误。</strong></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 79. 单词搜索[中等][回溯]]]></title>
        <id>https://lixin-scut.github.io//post/zi-fu-chuan-79-dan-ci-sou-suo-zhong-deng-hui-su</id>
        <link href="https://lixin-scut.github.io//post/zi-fu-chuan-79-dan-ci-sou-suo-zhong-deng-hui-su">
        </link>
        <updated>2020-04-24T08:03:39.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。<br>
单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。<br>
示例:<br>
board =<br>
[<br>
['A','B','C','E'],<br>
['S','F','C','S'],<br>
['A','D','E','E']<br>
]<br>
给定 word = &quot;ABCCED&quot;, 返回 true<br>
给定 word = &quot;SEE&quot;, 返回 true<br>
给定 word = &quot;ABCB&quot;, 返回 false<br>
提示：<br>
board 和 word 中只包含大写和小写英文字母。<br>
1 &lt;= board.length &lt;= 200<br>
1 &lt;= board[i].length &lt;= 200<br>
1 &lt;= word.length &lt;= 10^3<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/word-search<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>我似乎使用的比较暴力的方法，就是直接每个格子作为起点惊醒深度遍历+回溯来完成<br>
主要是通过传引用来达成节省空间的。</p>
<pre><code>class Solution {
public:
    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) {
        if(board.empty() &amp;&amp; word.empty())
        {   return true; }
        if(word.empty())
        {   return true; }
        
        int row = board.size();
        int col = board[0].size();
        
        vector&lt;vector&lt;bool&gt;&gt; visited(row, vector&lt;bool&gt;(col, false));
        
        for(int i = 0; i &lt; row; ++i)
        {
            for(int j = 0; j &lt; col; ++j)
            {
                if(exist(board, word, i, j, 0, visited))
                {   return true; }
            }
        }
        return false;
    }
    
    bool exist(const vector&lt;vector&lt;char&gt;&gt;&amp; board, const string&amp; word, int i, int j, int index, vector&lt;vector&lt;bool&gt;&gt;&amp; visited)
    {
        if(index == word.size())
        {   return true; }
        if(i &lt; 0 || i &gt;= board.size() || j &lt; 0 || j &gt;= board[0].size() || visited[i][j])
        {   return false; }
        if(word[index] != board[i][j])
        {   return false; }
        
        visited[i][j] = true;
        return visited[i][j] = (exist(board, word, i, j+1, index+1, visited)
               || exist(board, word, i, j-1, index+1, visited)
               || exist(board, word, i+1, j, index+1, visited)
               || exist(board, word, i-1, j, index+1, visited));
    }
};
</code></pre>
<p>网友题解：</p>
<pre><code>public class Solution {

    private boolean[][] marked;

    //        x-1,y
    // x,y-1  x,y    x,y+1
    //        x+1,y
    private int[][] direction = {{-1, 0}, {0, -1}, {0, 1}, {1, 0}};
    // 盘面上有多少行
    private int m;
    // 盘面上有多少列
    private int n;
    private String word;
    private char[][] board;

    public boolean exist(char[][] board, String word) {
        m = board.length;
        if (m == 0) {
            return false;
        }
        n = board[0].length;
        marked = new boolean[m][n];
        this.word = word;
        this.board = board;

        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt; n; j++) {
                if (dfs(i, j, 0)) {
                    return true;
                }
            }
        }
        return false;
    }

    private boolean dfs(int i, int j, int start) {
        if (start == word.length() - 1) {
            return board[i][j] == word.charAt(start);
        }
        if (board[i][j] == word.charAt(start)) {
            marked[i][j] = true;
            for (int k = 0; k &lt; 4; k++) {
                int newX = i + direction[k][0];
                int newY = j + direction[k][1];
                if (inArea(newX, newY) &amp;&amp; !marked[newX][newY]) {
                    if (dfs(newX, newY, start + 1)) {
                        return true;
                    }
                }
            }
            marked[i][j] = false;
        }
        return false;
    }

    private boolean inArea(int x, int y) {
        return x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n;
    }

    public static void main(String[] args) {

//        char[][] board =
//                {
//                        {'A', 'B', 'C', 'E'},
//                        {'S', 'F', 'C', 'S'},
//                        {'A', 'D', 'E', 'E'}
//                };
//
//        String word = &quot;ABCCED&quot;;


        char[][] board = {{'a', 'b'}};
        String word = &quot;ba&quot;;
        Solution solution = new Solution();
        boolean exist = solution.exist(board, word);
        System.out.println(exist);
    }
}
</code></pre>
<p>说明：<br>
偏移量数组在二维平面内是经常使用的，可以把它的设置当做一个技巧，并且在这个问题中，偏移量数组内的 4 个偏移的顺序无关紧要；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1.头文件 -Google C++编程规范]]></title>
        <id>https://lixin-scut.github.io//post/1tou-wen-jian-google-cbian-cheng-gui-fan</id>
        <link href="https://lixin-scut.github.io//post/1tou-wen-jian-google-cbian-cheng-gui-fan">
        </link>
        <updated>2020-04-23T09:21:18.000Z</updated>
        <content type="html"><![CDATA[<h3 id="define-保护">#define 保护</h3>
<p>所有头文件都应该使用 #define 来防止头文件被多重包含, 命名格式当是: <code>&lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H_ .</code></p>
<p>  为保证唯一性, 头文件的命名应该基于所在项目源代码树的全路径. 例如, 项目 foo 中的头文件 foo/src/bar/baz.h 可按如下方式保护:</p>
<pre><code>#ifndef FOO_BAR_BAZ_H_
#define FOO_BAR_BAZ_H_
...
#endif // FOO_BAR_BAZ_H_
</code></pre>
<p>  <strong>注意： 命名并非必须是路径+文件名，完全可以用其他格式甚至其他意义的名字，只要不冲突就好</strong></p>
<h3 id="前置声明">前置声明</h3>
<p>尽可能地<strong>避免使用前置声明</strong>。使用 #include 包含需要的头文件即可。</p>
<p>  前置声明的类是不完全类型（incomplete type），我们只能定义指向该类型的指针或引用，或者声明（但不能定义）以不完全类型作为参数或者返回类型的函数。毕竟编译器不知道不完全类型的定义，我们不能创建其类的任何对象，也不能声明成类内部的数据成员。</p>
<p>优点：</p>
<ol>
<li>前置声明能够<strong>节省编译时间</strong>，多余的 #include 会迫使编译器展开更多的文件，处理更多的输入。</li>
<li>前置声明能够<strong>节省不必要的重新编译的时间</strong>。 #include 使代码因为头文件中无关的改动而被重新编译多次。</li>
</ol>
<p>缺点：</p>
<ol>
<li>前置声明<strong>隐藏了依赖关系</strong>，头文件改动时，用户的代码会跳过必要的重新编译过程。</li>
<li>前置声明<strong>可能会被库的后续更改所破坏</strong>。前置声明函数或模板有时会妨碍头文件开发者变动其 API. 例如扩大形参类型，加个自带默认参数的模板形参等等。</li>
<li>前置声明来自命名空间 std:: 的 symbol 时，其行为未定义。</li>
<li>很难判断什么时候该用前置声明，什么时候该用 #include 。极端情况下，用前置声明代替 includes 甚至都会<strong>暗暗地改变代码的含义：</strong></li>
</ol>
<pre><code>// b.h:
struct B {};
struct D : B {};

// good_user.cc:
#include &quot;b.h&quot;
void f(B*);
void f(void*);
void test(D* x) { f(x); }  // calls f(B*)
</code></pre>
<p><em><em>如果 #include 被 B 和 D 的前置声明替代， test() 就会调用 f(void</em>) .</em>*<br>
5. 前置声明了不少来自头文件的 symbol 时，就会比单单一行的 include 冗长。<br>
6. <strong>仅仅为了能前置声明而重构代码（比如用指针成员代替对象成员）</strong> 会使代码变得更慢更复杂.</p>
<h3 id="内联函数">内联函数</h3>
<p>只有当函数只有 10 行甚至更少时才将其定义为内联函数.</p>
<p>  有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要; 比如虚函数和递归函数就不会被正常内联.</p>
<ol>
<li>通常, 递归函数不应该声明成内联函数.（YuleFox 注: 递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的, 大多数编译器都不支持内联递归函数).</li>
<li>虚函数内联的主要原因则是想把它的函数体放在类定义内, 为了图个方便, 抑或是当作文档描述其行为, 比如精短的存取函数.</li>
</ol>
<h3 id="include-的路径及顺序">#include 的路径及顺序</h3>
<p>  使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖: 相关头文件, C 库, C++ 库, 其他库的 .h, 本项目内的 .h.<br>
  项目内头文件应按照项目源代码目录树结构排列, 避免使用 UNIX 特殊的快捷目录 . (当前目录) 或 .. (上级目录).</p>
<p>  如, dir/foo.cc 或 dir/foo_test.cc 的主要作用是实现或测试 dir2/foo2.h 的功能, foo.cc 中包含头文件的次序如下:</p>
<ol>
<li>dir2/foo2.h (优先位置, 详情如下)</li>
<li>C 系统文件</li>
<li>C++ 系统文件</li>
<li>其他库的 .h 文件</li>
<li>本项目内 .h 文件</li>
</ol>
<p>  这种优先的顺序排序保证当 dir2/foo2.h 遗漏某些必要的库时， dir/foo.cc 或 dir/foo_test.cc 的构建会立刻中止。<br>
  <strong>因此这一条规则保证维护这些文件的人们首先看到构建中止的消息而不是维护其他包的人们。</strong></p>
<p>  您所依赖的符号 (symbols) 被哪些头文件所定义，您就应该包含（include）哪些头文件，前置声明 (forward declarations) 情况除外。<br>
  比如您要用到 bar.h 中的某个符号, <strong>哪怕您所包含的 foo.h 已经包含了 bar.h, 也照样得包含 bar.h</strong>, 除非 foo.h 有明确说明它会自动向您提供 bar.h 中的 symbol. 不过，<strong>凡是 cc 文件所对应的「相关头文件」已经包含的，就不用再重复包含进其 cc 文件里面了</strong>，就像 foo.cc 只包含 foo.h 就够了，不用再管后者所包含的其它内容。</p>
<p>例外：<br>
  有时，平台特定（system-specific）代码需要<strong>条件编译（conditional includes），这些代码可以放到其它 includes 之后</strong>。当然，您的平台特定代码也要够简练且独立，比如：</p>
<pre><code>#include &quot;foo/public/fooserver.h&quot;

#include &quot;base/port.h&quot;  // For LANG_CXX11.

#ifdef LANG_CXX11
#include &lt;initializer_list&gt;
#endif  // LANG_CXX11
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库：锁]]></title>
        <id>https://lixin-scut.github.io//post/shu-ju-ku-suo</id>
        <link href="https://lixin-scut.github.io//post/shu-ju-ku-suo">
        </link>
        <updated>2020-04-23T08:19:42.000Z</updated>
        <content type="html"><![CDATA[<h3 id="mysql都有什么锁死锁判定原理和具体场景死锁怎么解决">mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决?</h3>
<p>MySQL有三种锁的级别：页级、表级、行级。</p>
<ol>
<li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</li>
<li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</li>
<li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</li>
</ol>
<p><strong>死锁</strong><br>
  死锁: 是指两个或两个以上的进程在执行过程中。因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等竺的进程称为死锁进程。</p>
<p>  表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB。<br>
  死锁的关键在于：两个(或以上)的Session加锁的顺序不一致。<br>
  那么对应的解决死锁问题的关键就是：让不同的session加锁有次序。</p>
<p><strong>死锁的解决办法</strong></p>
<ol>
<li>查出的线程杀死 kill<br>
SELECT trx_MySQL_thread_id FROM information_schema.INNODB_TRX;</li>
<li>设置锁的超时时间<br>
  Innodb 行锁的等待时间，单位秒。可在会话级别设置，RDS 实例该参数的默认值为 50（秒）。<br>
  生产环境不推荐使用过大的 innodb_lock_wait_timeout参数值<br>
  该参数支持在会话级别修改，方便应用在会话级别单独设置某些特殊操作的行锁等待超时时间，如下：<br>
  set innodb_lock_wait_timeout=1000; —设置当前会话 Innodb 行锁等待超时时间，单位秒。</li>
<li>指定获取锁的顺序</li>
</ol>
<p><strong>锁的种类</strong></p>
<ul>
<li>悲观锁（Pessimistic Lock）<br>
  悲观锁特点:先获取锁，再进行业务操作。<br>
  即“悲观”的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作。通常所说的“一锁二查三更新”即指的是使用悲观锁。通常来讲在数据库上的悲观锁需要数据库本身提供支持，即通过常用的select … for update操作来实现悲观锁。当数据库执行select for update时会获取被select中的数据行的行锁，因此其他并发执行的select for update如果试图选中同一行则会发生排斥（需要等待行锁被释放），因此达到锁的效果。select for update获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。</li>
</ul>
<p>补充：<br>
不同的数据库对select for update的实现和支持都是有所区别的，</p>
<ol>
<li>oracle支持select for update no wait，表示如果拿不到锁立刻报错，而不是等待，MySQL就没有no wait这个选项。</li>
<li>MySQL还有个问题是select for update语句执行中所有扫描过的行都会被锁上，这一点很容易造成问题。因此如果在MySQL中用悲观锁务必要确定走了索引，而不是全表扫描。</li>
</ol>
<ul>
<li>乐观锁（Optimistic Lock）:<br>
  乐观锁，也叫乐观并发控制，它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，那么当前正在提交的事务会进行回滚。<br>
  乐观锁的特点先进行业务操作，不到万不得已不去拿锁。即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好。<br>
  乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。<br>
  一般的做法是在需要锁的数据上增加一个版本号，或者时间戳，</li>
</ul>
<p>实现方式举例如下：<br>
  乐观锁（给表加一个版本号字段） 这个并不是乐观锁的定义，给表加版本号，是数据库实现乐观锁的一种方式。</p>
<ol>
<li>SELECT data AS old_data, version AS old_version FROM …;</li>
<li>根据获取的数据进行业务操作，得到new_data和new_version</li>
<li>UPDATE SET data = new_data, version = new_version WHERE version = old_version<br>
if (updated row &gt; 0) {<br>
// 乐观锁获取成功，操作完成<br>
} else {<br>
// 乐观锁获取失败，回滚并重试<br>
}</li>
</ol>
<p>注意：</p>
<ol>
<li>乐观锁在不发生取锁失败的情况下开销比悲观锁小，但是一旦发生失败回滚开销则比较大，因此适合用在取锁失败概率比较小的场景，可以提升系统并发性能</li>
<li>乐观锁还适用于一些比较特殊的场景，例如在业务操作过程中无法和数据库保持连接等悲观锁无法适用的地方。</li>
</ol>
<h3 id="总结">总结</h3>
<p>  悲观锁和乐观锁是数据库用来保证数据并发安全防止更新丢失的两种方法，例子在select ... for update前加个事务就可以防止更新丢失。悲观锁和乐观锁大部分场景下差异不大，一些独特场景下有一些差别，一般我们可以从如下几个方面来判断。</p>
<ol>
<li>
<p>响应速度： 如果需要非常高的响应速度，建议采用乐观锁方案，成功就执行，不成功就失败，不需要等待其他并发去释放锁。'</p>
</li>
<li>
<p>冲突频率： 如果冲突频率非常高，建议采用悲观锁，保证成功率，如果冲突频率大，乐观锁会需要多次重试才能成功，代价比较大。</p>
</li>
<li>
<p>重试代价： 如果重试代价大，建议采用悲观锁。</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库：事务]]></title>
        <id>https://lixin-scut.github.io//post/shu-ju-ku-shi-wu</id>
        <link href="https://lixin-scut.github.io//post/shu-ju-ku-shi-wu">
        </link>
        <updated>2020-04-23T07:29:04.000Z</updated>
        <content type="html"><![CDATA[<h3 id="事务">事务</h3>
<p>  事务是对数据库中一系列操作进行统一的回滚或者提交的操作，主要用来保证数据的完整性和一致性。</p>
<h3 id="事务四大特性acid">事务四大特性（ACID）</h3>
<p>原子性、一致性、隔离性、持久性</p>
<p><strong>原子性（Atomicity）:</strong><br>
  原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p>
<p><strong>一致性（Consistency）:</strong><br>
  事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没收到。</p>
<p><strong>隔离性（Isolation）:</strong><br>
  隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</p>
<p><strong>持久性（Durability）:</strong><br>
  持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>
<h2 id="事务的并发与事务隔离级别">事务的并发与事务隔离级别</h2>
<p>每个级别会引发什么问题，MySQL默认是哪个级别?</p>
<p><img src="https://lixin-scut.github.io//post-images/1587627485392.png" alt=""><br>
  从理论上来说, 事务应该彼此完全隔离, 以避免并发事务所导致的问题，然而, 那样会对性能产生极大的影响, 因为事务必须按顺序运行， 在实际开发中, 为了提升性能, 事务会以较低的隔离级别运行， 事务的隔离级别可以通过隔离事务属性指定。</p>
<p><strong>事务的并发问题</strong></p>
<ol>
<li>脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</li>
<li>不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。</li>
<li>幻读：幻读解决了不可重复读，保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）。<br>
<img src="https://lixin-scut.github.io//post-images/1587627503240.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1587627525081.png" alt=""></li>
</ol>
<p>  例如：事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作 这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。 而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有跟没有修改一样，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。<br>
  小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。</p>
<p><strong>事务的隔离级别</strong><br>
<img src="https://lixin-scut.github.io//post-images/1587627552072.png" alt=""></p>
<ol>
<li>读未提交：另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据脏读</li>
<li>不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。</li>
<li>可重复读：在同一个事务里，SELECT的结果是事务开始时时间点的状态，因此，同样的SELECT操作读到的结果会是一致的。但是，会有幻读现象</li>
<li>串行化：最高的隔离级别，在这个隔离级别下，不会产生任何异常。并发的事务，就像事务是在一个个按照顺序执行一样</li>
</ol>
<p>特别注意：</p>
<ol>
<li>MySQL默认的事务隔离级别为repeatable-read</li>
<li>MySQL 支持 四种事务隔离级别.</li>
<li>事务的隔离级别要得到底层数据库引擎的支持, 而不是应用程序或者框架的支持.</li>
<li>Oracle 支持的 2 种事务隔离级别：READ_COMMITED , SERIALIZABLE</li>
<li>SQL规范所规定的标准，不同的数据库具体的实现可能会有些差异</li>
<li>MySQL中默认事务隔离级别是“可重复读”时并不会锁住读取到的行<br>
  事务隔离级别：未提交读时，写数据只会锁住相应的行。<br>
  事务隔离级别为：可重复读时，写数据会锁住整张表。<br>
  事务隔离级别为：串行化时，读写数据都会锁住整张表。</li>
<li>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大，鱼和熊掌不可兼得啊。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed，它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。<br>
<img src="https://lixin-scut.github.io//post-images/1587627572153.png" alt=""></li>
</ol>
<p><strong>事务传播行为</strong></p>
<ol>
<li>PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</li>
<li>PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</li>
<li>PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</li>
<li>PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。</li>
<li>PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li>
<li>PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。</li>
<li>PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</li>
</ol>
<p><strong>嵌套事务</strong></p>
<p>  嵌套是子事务套在父事务中执行，子事务是父事务的一部分，在进入子事务之前，父事务建立一个回滚点，叫save point，然后执行子事务，这个子事务的执行也算是父事务的一部分，然后子事务执行结束，父事务继续执行。重点就在于那个save point。<br>
  如果子事务回滚，会发生什么？<br>
  父事务会回滚到进入子事务前建立的save point，然后尝试其他的事务或者其他的业务逻辑，父事务之前的操作不会受到影响，更不会自动回滚。<br>
  如果父事务回滚，会发生什么？<br>
  父事务回滚，子事务也会跟着回滚！为什么呢，因为父事务结束之前，子事务是不会提交的，我们说子事务是父事务的一部分，正是这个道理。那么：<br>
  事务的提交，是什么情况？<br>
  是父事务先提交，然后子事务提交，还是子事务先提交，父事务再提交？答案是第二种情况，还是那句话，子事务是父事务的一部分，由父事务统一提交。<br>
参考文章：<a href="https://blog.csdn.net/liangxw1/article/details/51197560">关于Spring事务的面试题</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 76. 最小覆盖子串[困难][未做出]]]></title>
        <id>https://lixin-scut.github.io//post/zi-fu-chuan-76-zui-xiao-fu-gai-zi-chuan-kun-nan-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/zi-fu-chuan-76-zui-xiao-fu-gai-zi-chuan-kun-nan-wei-zuo-chu">
        </link>
        <updated>2020-04-23T07:07:05.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。<br>
示例：<br>
输入: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot;<br>
输出: &quot;BANC&quot;<br>
说明：<br>
如果 S 中不存这样的子串，则返回空字符串 &quot;&quot;。<br>
如果 S 中存在这样的子串，我们保证它是唯一的答案。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/minimum-window-substring<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>第一想法是维持一个队列，不断地把所需的字母+其所处的位置 放入队列 ，然后每当遇到和队列头相同的元素的时候就出队列<br>
但是同时也需要更新队内的元素的下标，</p>
<p>然后第二想法就是记录更新每个所需字母的位置，然后用最大值减去最小值，但是同时需要检查是否已经满足条件 重复字符很麻烦。</p>
<p>最后第三个想法就是记录所有所需字母的下标，然后再按需计算（递归回溯等）</p>
<p>最后看了题解发现是hashmap + 双指针，确实把我的方法中的可行的部分提取出来+不可行的地方去除了。</p>
<pre><code>class Solution {
public:
    string minWindow(string s, string t) {
        
        unordered_map&lt;char, int&gt; letter_need;
        unordered_map&lt;char, int&gt; letter_get;
        for(auto c : t)
        {            
            ++letter_need[c];
        }
        
        int match = 0;
        int left = 0;
        int right = 0;
        char c = '\0';
        string ans = &quot;&quot;;
        while(right &lt; s.size())
        {     
            c = s[right];
            if(letter_need.count(c) == 1)
            {
                ++letter_get[c];
                if(letter_need[c] == letter_get[c])
                {
                    ++match;
                }
            }
            
            
            while(match == letter_need.size())
            {
                c = s[left];
                if(letter_need.count(c) == 1)
                {
                    --letter_get[c];
                    if(letter_get[c] &lt; letter_need[c])
                    {
                        --match;
                        string temp = s.substr(left, right - left + 1);
                        ans = (ans != &quot;&quot; &amp;&amp; ans.size() &lt; temp.size()) ? ans : temp;
                    }
                }
                ++left;
            }
            ++right;
        }
        
        return ans;
    }
};
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>题目不难理解，就是说要在 S(source) 中找到包含 T(target) 中全部字母的一个子串，顺序无所谓，但这个子串一定是所有可能子串中最短的。<br>
如果我们使用暴力解法，代码大概是这样的：</p>
</blockquote>
<pre><code>for (int i = 0; i &lt; s.size(); i++)
    for (int j = i + 1; j &lt; s.size(); j++)
        if s[i:j] 包含 t 的所有字母:
            更新答案
</code></pre>
<blockquote>
<p>思路很直接吧，但是显然，这个算法的复杂度肯定大于 O(N^2)了，不好。<br>
滑动窗口算法的思路是这样：<br>
1、我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引闭区间 [left, right] 称为一个「窗口」。<br>
2、我们先不断地增加 right 指针扩大窗口 [left, right]，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。<br>
3、此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。<br>
4、重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。<br>
这个思路其实也不难，第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。<br>
上述过程可以简单地写出如下伪码框架：</p>
</blockquote>
<pre><code>string s, t;
// 在 s 中寻找 t 的「最小覆盖子串」
int left = 0, right = 0;
string res = s;

while(right &lt; s.size()) {
    window.add(s[right]);
    right++;
    // 如果符合要求，移动 left 缩小窗口
    while (window 符合要求) {
        // 如果这个窗口的子串更短，则更新 res
        res = minLen(res, window);
        window.remove(s[left]);
        left++;
    }
}
return res;
</code></pre>
<blockquote>
<p>如果上述代码你也能够理解，那么你离解题更近了一步。现在就剩下一个比较棘手的问题：如何判断 window 即子串 s[left...right] 是否符合要求，是否包含 t 的所有字符呢？<br>
可以用两个哈希表当作计数器解决。用一个哈希表 needs 记录字符串 t 中包含的字符及出现次数，用另一个哈希表 window 记录当前「窗口」中包含的字符及出现的次数，如果 window 包含所有 needs 中的键，且这些键对应的值都大于等于 needs 中的值，那么就可以知道当前「窗口」符合要求了，可以开始移动 left 指针了。</p>
</blockquote>
<pre><code>string minWindow(string s, string t) {
    // 记录最短子串的开始位置和长度
    int start = 0, minLen = INT_MAX;
    int left = 0, right = 0;
    
    unordered_map&lt;char, int&gt; window;
    unordered_map&lt;char, int&gt; needs;
    for (char c : t) needs[c]++;
    
    int match = 0;
    
    while (right &lt; s.size()) {
        char c1 = s[right];
        if (needs.count(c1)) {
            window[c1]++;
            if (window[c1] == needs[c1]) 
                match++;
        }
        right++;
        
        while (match == needs.size()) {
            if (right - left &lt; minLen) {
                // 更新最小子串的位置和长度
                start = left;
                minLen = right - left;
            }
            char c2 = s[left];
            if (needs.count(c2)) {
                window[c2]--;
                if (window[c2] &lt; needs[c2])
                    match--;
            }
            left++;
        }
    }
    return minLen == INT_MAX ?
                &quot;&quot; : s.substr(start, minLen);
}

作者：labuladong
链接：https://leetcode-cn.com/problems/minimum-window-substring/solution/hua-dong-chuang-kou-suan-fa-tong-yong-si-xiang-by-/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<blockquote>
<p>这个算法的时间复杂度是 O(M+N)，M 和 N 分别是字符串 S 和 T 的长度。因为我们先用 for 循环遍历了字符串 T 来初始化 needs，时间 O(N)，之后的两个 while 循环最多执行2M 次，时间O(M)。<br>
读者也许认为嵌套的 while 循环复杂度应该是平方级，但是你这样想，while 执行的次数就是双指针 left 和 right 走的总路程，最多是 2M 嘛。</p>
</blockquote>
<blockquote>
<p>最后总结<br>
通过上面三道题，我们可以总结出滑动窗口算法的抽象思想：</p>
</blockquote>
<pre><code>int left = 0, right = 0;

while (right &lt; s.size()) {
    window.add(s[right]);
    right++;
    
    while (valid) {
        window.remove(s[left]);
        left++;
    }
}
</code></pre>
<blockquote>
<p>其中 window 的数据类型可以视具体情况而定，比如上述题目都使用哈希表充当计数器，当然你也可以用一个数组实现同样效果，因为我们只处理英文字母。<br>
稍微麻烦的地方就是这个 valid 条件，为了实现这个条件的实时更新，我们可能会写很多代码。比如前两道题，看起来解法篇幅那么长，实际上思想还是很简单，只是大多数代码都在处理这个问题而已。</p>
</blockquote>
<p>官方题解：</p>
<blockquote>
<p>方法一：滑动窗口<br>
思路<br>
本问题要求我们返回字符串 S 中包含字符串 T 的全部字符的最小窗口。我们称包含 T 的全部字母的窗口为 可行 窗口。<br>
可以用简单的滑动窗口法来解决本问题。<br>
在滑动窗口类型的问题中都会有两个指针。一个用于延伸现有窗口的 right 指针，和一个用于收缩窗口的 left 指针。在任意时刻，只有一个指针运动，而另一个保持静止。<br>
本题的解法很符合直觉。我们通过移动 right 指针不断扩张窗口。当窗口包含全部所需的字符后，如果能收缩，我们就收缩窗口直到得到最小窗口。<br>
答案就是最小的可行窗口。<br>
算法<br>
初始，left 指针和 right 指针都指向 S 的第一个元素.<br>
将 right 指针右移，扩张窗口，直到得到一个可行窗口，亦即包含 T 的全部字母的窗口。<br>
得到可行的窗口后，将 left 指针逐个右移，若得到的窗口依然可行，则更新最小窗口大小。<br>
若窗口不再可行，则跳转至 2 。</p>
</blockquote>
<pre><code>class Solution {
  public String minWindow(String s, String t) {

      if (s.length() == 0 || t.length() == 0) {
          return &quot;&quot;;
      }

      // Dictionary which keeps a count of all the unique characters in t.
      Map&lt;Character, Integer&gt; dictT = new HashMap&lt;Character, Integer&gt;();
      for (int i = 0; i &lt; t.length(); i++) {
          int count = dictT.getOrDefault(t.charAt(i), 0);
          dictT.put(t.charAt(i), count + 1);
      }

      // Number of unique characters in t, which need to be present in the desired window.
      int required = dictT.size();

      // Left and Right pointer
      int l = 0, r = 0;

      // formed is used to keep track of how many unique characters in t
      // are present in the current window in its desired frequency.
      // e.g. if t is &quot;AABC&quot; then the window must have two A's, one B and one C.
      // Thus formed would be = 3 when all these conditions are met.
      int formed = 0;

      // Dictionary which keeps a count of all the unique characters in the current window.
      Map&lt;Character, Integer&gt; windowCounts = new HashMap&lt;Character, Integer&gt;();

      // ans list of the form (window length, left, right)
      int[] ans = {-1, 0, 0};

      while (r &lt; s.length()) {
          // Add one character from the right to the window
          char c = s.charAt(r);
          int count = windowCounts.getOrDefault(c, 0);
          windowCounts.put(c, count + 1);

          // If the frequency of the current character added equals to the
          // desired count in t then increment the formed count by 1.
          if (dictT.containsKey(c) &amp;&amp; windowCounts.get(c).intValue() == dictT.get(c).intValue()) {
              formed++;
          }

          // Try and contract the window till the point where it ceases to be 'desirable'.
          while (l &lt;= r &amp;&amp; formed == required) {
              c = s.charAt(l);
              // Save the smallest window until now.
              if (ans[0] == -1 || r - l + 1 &lt; ans[0]) {
                  ans[0] = r - l + 1;
                  ans[1] = l;
                  ans[2] = r;
              }

              // The character at the position pointed by the
              // `Left` pointer is no longer a part of the window.
              windowCounts.put(c, windowCounts.get(c) - 1);
              if (dictT.containsKey(c) &amp;&amp; windowCounts.get(c).intValue() &lt; dictT.get(c).intValue()) {
                  formed--;
              }

              // Move the left pointer ahead, this would help to look for a new window.
              l++;
          }

          // Keep expanding the window once we are done contracting.
          r++;   
      }

      return ans[0] == -1 ? &quot;&quot; : s.substring(ans[1], ans[2] + 1);
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度: O(∣S∣+∣T∣)，其中 ∣S∣ 和 ∣T∣ 代表字符串 S 和 T 的长度。在最坏的情况下，可能会对 S 中的每个元素遍历两遍，左指针和右指针各一遍。<br>
空间复杂度: O(∣S∣+∣T∣)。当窗口大小等于 ∣S∣ 时为S 。当 ∣T∣ 包括全部唯一字符时为 T 。</p>
</blockquote>
<blockquote>
<p>方法二：优化滑动窗口<br>
思路<br>
对上一方法进行改进，可以将时间复杂度下降到 O(2∗∣filtered_S∣+∣S∣+∣T∣) ，其中 filtered_S 是从 S 中去除所有在 T 中不存在的元素后，得到的字符串。<br>
当 ∣filtered_S∣&lt;&lt;&lt;∣S∣ 时，优化效果显著。这种情况可能是由于 T 的长度远远小于 S ，因此 S 中包括大量 T 中不存在的字符。<br>
算法<br>
我们建立一个 filtered_S 列表，其中包括 S 中的全部字符以及它们在 S 的下标，但这些字符必须在 T 中出现。<br>
S = &quot;ABCDDDDDDEEAFFBC&quot; T = &quot;ABC&quot;<br>
filtered_S = [(0, 'A'), (1, 'B'), (2, 'C'), (11, 'A'), (14, 'B'), (15, 'C')]<br>
此处的 (0, 'A') 表示字符 'A' 在字符串 S 中的下标为 0 。<br>
现在我们可以在更短的字符串filtered_S 中使用滑动窗口法。</p>
</blockquote>
<pre><code>class Solution {
    public String minWindow(String s, String t) {

        if (s.length() == 0 || t.length() == 0) {
            return &quot;&quot;;
        }

        Map&lt;Character, Integer&gt; dictT = new HashMap&lt;Character, Integer&gt;();

        for (int i = 0; i &lt; t.length(); i++) {
            int count = dictT.getOrDefault(t.charAt(i), 0);
            dictT.put(t.charAt(i), count + 1);
        }

        int required = dictT.size();

        // Filter all the characters from s into a new list along with their index.
        // The filtering criteria is that the character should be present in t.
        List&lt;Pair&lt;Integer, Character&gt;&gt; filteredS = new ArrayList&lt;Pair&lt;Integer, Character&gt;&gt;();
        for (int i = 0; i &lt; s.length(); i++) {
            char c = s.charAt(i);
            if (dictT.containsKey(c)) {
                filteredS.add(new Pair&lt;Integer, Character&gt;(i, c));
            }
        }

        int l = 0, r = 0, formed = 0;
        Map&lt;Character, Integer&gt; windowCounts = new HashMap&lt;Character, Integer&gt;();  
        int[] ans = {-1, 0, 0};

        // Look for the characters only in the filtered list instead of entire s.
        // This helps to reduce our search.
        // Hence, we follow the sliding window approach on as small list.
        while (r &lt; filteredS.size()) {
            char c = filteredS.get(r).getValue();
            int count = windowCounts.getOrDefault(c, 0);
            windowCounts.put(c, count + 1);

            if (dictT.containsKey(c) &amp;&amp; windowCounts.get(c).intValue() == dictT.get(c).intValue()) {
                formed++;
            }

            // Try and contract the window till the point where it ceases to be 'desirable'.
            while (l &lt;= r &amp;&amp; formed == required) {
                c = filteredS.get(l).getValue();

                // Save the smallest window until now.
                int end = filteredS.get(r).getKey();
                int start = filteredS.get(l).getKey();
                if (ans[0] == -1 || end - start + 1 &lt; ans[0]) {
                    ans[0] = end - start + 1;
                    ans[1] = start;
                    ans[2] = end;
                }

                windowCounts.put(c, windowCounts.get(c) - 1);
                if (dictT.containsKey(c) &amp;&amp; windowCounts.get(c).intValue() &lt; dictT.get(c).intValue()) {
                    formed--;
                }
                l++;
            }
            r++;
        }
        return ans[0] == -1 ? &quot;&quot; : s.substring(ans[1], ans[2] + 1);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 : O(∣S∣+∣T∣)， 其中 ∣S∣ 和 ∣T∣ 分别代表字符串 S 和T 的长度。 本方法时间复杂度与方法一相同，但当 ∣filtered_S∣ &lt;&lt;&lt; ∣S∣ 时，复杂度会下降，因为此时迭代次数是 2∗∣filtered_S∣+∣S∣+∣T∣。<br>
空间复杂度 : O(∣S∣+∣T∣)。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 688. “马”在棋盘上的概率[中等]]]></title>
        <id>https://lixin-scut.github.io//post/dong-tai-gui-hua-688-ma-zai-qi-pan-shang-de-gai-lu-zhong-deng</id>
        <link href="https://lixin-scut.github.io//post/dong-tai-gui-hua-688-ma-zai-qi-pan-shang-de-gai-lu-zhong-deng">
        </link>
        <updated>2020-04-23T01:39:40.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>已知一个 NxN 的国际象棋棋盘，棋盘的行号和列号都是从 0 开始。即最左上角的格子记为 (0, 0)，最右下角的记为 (N-1, N-1)。 <br>
现有一个 “马”（也译作 “骑士”）位于 (r, c) ，并打算进行 K 次移动。 <br>
如下图所示，国际象棋的 “马” 每一步先沿水平或垂直方向移动 2 个格子，然后向与之相垂直的方向再移动 1 个格子，共有 8 个可选的位置。<br>
现在 “马” 每一步都从可选的位置（包括棋盘外部的）中独立随机地选择一个进行移动，直到移动了 K 次或跳到了棋盘外面。<br>
求移动结束后，“马” 仍留在棋盘上的概率。<br>
示例：<br>
输入: 3, 2, 0, 0<br>
输出: 0.0625<br>
解释:<br>
输入的数据依次为 N, K, r, c<br>
第 1 步时，有且只有 2 种走法令 “马” 可以留在棋盘上（跳到（1,2）或（2,1））。对于以上的两种情况，各自在第2步均有且只有2种走法令 “马” 仍然留在棋盘上。<br>
所以 “马” 在结束后仍在棋盘上的概率为 0.0625。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/knight-probability-in-chessboard<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>一开始的想法是存储每个格子的走K次的可能性,比如第一次、第二次、第三次每个格子的可能性<br>
然后实现中需要注意的点</p>
<ol>
<li>一开始很明显是用三维数组，但是我为了压缩空间+更明显地表现状态的变化，所以用上了二位数组</li>
<li>增加了4个外围概率，一定要初始化为0，并且不能计算概率</li>
<li>受第二点影响，所以循环应该起始于2，终止于N+2而不是N+4</li>
<li>概率之和要除以8</li>
</ol>
<pre><code>class Solution {
public:
    double knightProbability(int N, int K, int r, int c) {
        double ans = 0;
        
        vector&lt;vector&lt;double&gt;&gt; probability(N + 4, vector&lt;double&gt;(N + 4, 0));
        vector&lt;vector&lt;double&gt;&gt; temp(N + 4, vector&lt;double&gt;(N + 4, 0));
        probability[r + 2][c + 2] = 1;
        
        for(int k = 0; k &lt; K; ++k)
        {
            for(int i = 2; i &lt; N + 2; ++i)  // 注意限定范围是 N + 2
            {
                for(int j = 2; j &lt; N + 2; ++j)
                {
                    temp[i][j] = (probability[i - 1][j - 2] + probability[i - 2][j - 1]
                                + probability[i - 2][j + 1] + probability[i - 1][j + 2]
                                + probability[i + 1][j - 2] + probability[i + 2][j - 1]
                                + probability[i + 2][j + 1] + probability[i + 1][j + 2]) / 8;
                }
            }
            probability = temp;
        }
        for(int i = 2; i &lt; N + 2; ++i)
        {
                for(int j = 2; j &lt; N + 2; ++j)
                {
                    ans += probability[i][j];
                }
        }
        return ans;
    }
};
</code></pre>
<p>复杂度分析<br>
时间复杂度：<br>
O(KN^2)。其中 N,K 为题目中的定义。我们对 N^2 元素的每一层 dp 进行 O(1) 工作，并且考虑了 K 层。<br>
空间复杂度：O(N^2)，二维矩阵。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 56. 合并区间[中等]]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-56-he-bing-qu-jian-zhong-deng</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-56-he-bing-qu-jian-zhong-deng">
        </link>
        <updated>2020-04-22T02:08:49.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>给出一个区间的集合，请合并所有重叠的区间。<br>
示例 1:<br>
输入: [[1,3],[2,6],[8,10],[15,18]]<br>
输出: [[1,6],[8,10],[15,18]]<br>
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].<br>
示例 2:<br>
输入: [[1,4],[4,5]]<br>
输出: [[1,5]]<br>
解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/merge-intervals<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>看起来似乎是先排序后合并，只要前一个区间的右区间大于后一个区间的左区间，就需要合并</p>
<p>忽略了一个包含问题了</p>
<p>排序超时了hhh<br>
所以必须是一次遍历的？</p>
<p>看了题解发现不是的<br>
只是两个点</p>
<ol>
<li>sort可以进行vector的排序。。。就是类似于优先级排序</li>
<li>我一开始的循环符合条件，但是有重复的情况存在，加上排序就超时了</li>
</ol>
<p>实现中需要注意的点</p>
<ol>
<li>用空间换时间，一开始用vector的erase，需要进行元素搬移，很费时间</li>
<li>注意j的判断和大于等于的判断</li>
<li>注意i=j，而不能直接++i</li>
<li>最后我去掉了j，用temp来暂存</li>
</ol>
<pre><code>class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {
        if(intervals.empty())
        {   return intervals; }
        
        /*
        // out of time
        sort(intervals.begin(), intervals.end(), Solution());
        auto cur_vec = intervals.begin();
        while(cur_vec != intervals.end())
        {
            auto next_vec = cur_vec + 1;
            if(next_vec == intervals.end() || (*cur_vec)[1] &lt; (*next_vec)[0])
            {
                ++cur_vec;
            }
            else 
            {
                if((*cur_vec)[1] &lt; (*next_vec)[1])
                {
                    (*cur_vec)[1] = (*next_vec)[1];
                }
                intervals.erase(next_vec);
            }
        }
        */
        
        sort(intervals.begin(), intervals.end());
        vector&lt;vector&lt;int&gt;&gt; ans;
        for(int i = 0; i &lt;  intervals.size();)
        {
            vector&lt;int&gt; temp =  intervals[i];
            ++i;
            while(i &lt; intervals.size() &amp;&amp; temp[1] &gt;= intervals[i][0])
            {
                temp[1] = temp[1] &gt; intervals[i][1] ? temp[1] : intervals[i][1];
                ++i;
            }
            ans.push_back(temp);
        }
        
        return ans;
    }
    
    bool operator()(const vector&lt;int&gt;&amp; lhs, const vector&lt;int&gt;&amp; rhs) const
    {
        if(lhs[0] == rhs[0])
        {
            return lhs[1] &lt; rhs[1];
        }
        return lhs[0] &lt; rhs[0];
    }
};
</code></pre>
<p>官方题解</p>
<blockquote>
<p>方法：排序<br>
思路<br>
如果我们按照区间的左端点排序，那么在排完序的列表中，可以合并的区间一定是连续的。如下图所示，标记为蓝色、黄色和绿色的区间分别可以合并成一个大区间，它们在排完序的列表中是连续的：<br>
算法<br>
我们用数组 merged 存储最终的答案。<br>
首先，我们将列表中的区间按照左端点升序排序。然后我们将第一个区间加入 merged 数组中，并按顺序依次考虑之后的每个区间：<br>
如果当前区间的左端点在数组 merged 中最后一个区间的右端点之后，那么它们不会重合，我们可以直接将这个区间加入数组 merged 的末尾；<br>
否则，它们重合，我们需要用当前区间的右端点更新数组 merged 中最后一个区间的右端点，将其置为二者的较大值。</p>
</blockquote>
<pre><code>class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {
        if (intervals.size() == 0) {
            return {};
        }
        sort(intervals.begin(), intervals.end());
        vector&lt;vector&lt;int&gt;&gt; merged;
        for (int i = 0; i &lt; intervals.size(); ++i) {
            int L = intervals[i][0], R = intervals[i][1];
            if (!merged.size() || merged.back()[1] &lt; L) {
                merged.push_back({L, R});
            }
            else {
                merged.back()[1] = max(merged.back()[1], R);
            }
        }
        return merged;
    }
};

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/merge-intervals/solution/he-bing-qu-jian-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(nlogn)，其中 n 为区间的数量。除去排序的开销，我们只需要一次线性扫描，所以主要的时间开销是排序的 O(nlogn)。<br>
空间复杂度：O(logn)，其中 n 为区间的数量。这里计算的是存储答案之外，使用的额外空间。O(logn) 即为排序所需要的空间复杂度。</p>
</blockquote>
<p>网友题解</p>
<blockquote>
<p>解题思路<br>
我的方法思路很简单，很容易理解，一句话概括就是把这道题当成一个括号匹配的题：<br>
定义一个数组(box)，初始化每个元素为0用来记录匹配情况<br>
首先遍历输入，每个区间开始的值，在box下标对应的位置+1，每个区间结束的值，在box下标对应的地方-1<br>
然后遍历box(从0到区间所能到达的最大值，这个最大值可以在开始遍历的时候记录一下)，累加box[i]不是0的值，记录在cnt里面。如果到某个位置i的时候cnt为0，而box[i]不为0，这说明这是合并之后的区间中的一个开始的位置，用l记录这个位置，然后知道cnt有恢复到0，说明这个区间结束，用r记录当前位置，然后把l，r加到结果数组中。<br>
然后可能会有疑问，首尾相接的话，box里面对应的值不就是0了吗？对于这种情况，首尾相接的肯定要合并，对应的地方是0正合心意<br>
到这里，忽略了一种情况，区间里只有一个值的情况，即首尾相同的，如[[1,3][0,0]]<br>
这时候[0,0]这个区间就丢掉了…………<br>
迫不得已，又加了一个数组keng，来记录只有一个值的区间，然后，可算是通过了<br>
此方法的优缺点分析：<br>
优点：容易理解，不用排序，自带升序序列，速度在区间范围较小的情况下，要比排序快<br>
缺点：如果区间范围很大，如[0,10000]酱紫的，那可能就慢了。当然，辅助空间用的确实多…………</p>
</blockquote>
<pre><code>/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** merge(int** intervals, int intervalsSize, int* intervalsColSize, int* returnSize, int** returnColumnSizes){
    int box[10005];
    int keng[10005];
    int maxNum = 0;
    int l, r, cnt;
    returnSize[0] = 0;
    int **returnArr = (int**)calloc(intervalsSize, sizeof(int*));
    returnColumnSizes[0] = (int*)calloc(intervalsSize, sizeof(int));
    for(int i = 0; i &lt; intervalsSize; ++i) {
        returnArr[i] = (int*)calloc(2, sizeof(int));
        returnColumnSizes[0][i] = 2;
    }
    memset(box, 0, sizeof(box));
    memset(keng, 0, sizeof(keng));
    for(int i = 0; i &lt; intervalsSize; ++i) {
        if(box[intervals[i][0]] == box[intervals[i][1]]) {
            keng[intervals[i][0]] = 1;
        }
        ++box[intervals[i][0]];
        --box[intervals[i][1]];
        maxNum = maxNum &lt; intervals[i][1] ? intervals[i][1] : maxNum;
    }
    for(int i = 0; i &lt;= maxNum; ++i) {
        if(!box[i] &amp;&amp; keng[i] &amp;&amp; cnt == 0) {
            returnArr[returnSize[0]][0] = i;
            returnArr[returnSize[0]++][1] = i;
        }
        if(box[i]) {
            if(cnt == 0) {
                l = i;
            }
            cnt += box[i];
            if(cnt == 0) {
                r = i;
                returnArr[returnSize[0]][0] = l;
                returnArr[returnSize[0]++][1] = r;
            }
        }
    }
    return returnArr;
}

作者：hamiguaex163com
链接：https://leetcode-cn.com/problems/merge-intervals/solution/na-kong-jian-huan-shi-jian-er-qie-wo-mei-pai-xu-_-/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
]]></content>
    </entry>
</feed>