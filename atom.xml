<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-04-19T03:41:43.184Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>千里之行，始于足下。不积跬步，无以至千里。</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[链表 面试题 02.01. 移除重复节点[简单]]]></title>
        <id>https://lixin-scut.github.io//post/lian-biao-mian-shi-ti-0201-yi-chu-chong-fu-jie-dian-jian-dan</id>
        <link href="https://lixin-scut.github.io//post/lian-biao-mian-shi-ti-0201-yi-chu-chong-fu-jie-dian-jian-dan">
        </link>
        <updated>2020-04-19T03:28:37.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。<br>
示例1:<br>
输入：[1, 2, 3, 3, 2, 1]<br>
输出：[1, 2, 3]<br>
示例2:<br>
输入：[1, 1, 1, 1, 2]<br>
输出：[1, 2]<br>
提示：<br>
链表长度在[0, 20000]范围内。<br>
链表元素在[0, 20000]范围内。<br>
进阶：<br>
如果不得使用临时缓冲区，该怎么解决？<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/remove-duplicate-node-lcci<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>如果是排序链表的话直接两个双指针就好，<br>
但是示例一有个问题是非排序+可重复的链表，所以很明显困难很多。<br>
我的第一想法还是哈希表，毕竟如果想去除所有重复元素的话还是得老老实实遍历<br>
看了一下提示确实如此<br>
然后进阶的话需要双指针，但双指针的方法太繁琐，时间复杂度是n^2 不值得实现</p>
<p>实现需要注意的点：变量命名很重要，我用了next_node，容易和节点的next冲突，容易出问题</p>
<pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    
    // hashset
    ListNode* removeDuplicateNodes(ListNode* head) {
        if(head == nullptr)
        {   return head; }
            
        unordered_set&lt;int&gt; value_set;
        ListNode* cur_node = head;
        ListNode* next_node = head-&gt;next;
        value_set.insert(cur_node-&gt;val);
        
        while(next_node != nullptr)
        {
            if(value_set.count(next_node-&gt;val) &gt; 0)
            {
                next_node = next_node-&gt;next;
            }
            else
            {
                cur_node-&gt;next = next_node;
                value_set.insert(next_node-&gt;val);
                cur_node = next_node;
                next_node = next_node-&gt;next;
            }
        }
        cur_node -&gt; next = nullptr;
        return head;
    }    
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库：索引]]></title>
        <id>https://lixin-scut.github.io//post/shu-ju-ku-suo-yin</id>
        <link href="https://lixin-scut.github.io//post/shu-ju-ku-suo-yin">
        </link>
        <updated>2020-04-18T03:38:36.000Z</updated>
        <content type="html"><![CDATA[<h3 id="索引概念">索引概念</h3>
<p>何为索引：<br>
  数据库索引，是数据库管理系统中一个排序的数据结构，索引的实现通常使用B树及其变种B+树。<br>
  在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p>
<h3 id="索引的作用">索引的作用</h3>
<p>索引作用是协助快速查询、更新数据库表中数据。<br>
但是同时为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。</p>
<h3 id="索引的优缺点">索引的优缺点</h3>
<p><strong>优点：</strong><br>
创建索引可以大大提高系统的性能：</p>
<ol>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
<li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li>
<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li>
<li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li>
<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li>
</ol>
<p><strong>缺点：</strong><br>
增加索引也有许多不利的方面：</p>
<ol>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li>
<li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li>
<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>
</ol>
<h3 id="适合与不适合使用索引的情形">适合与不适合使用索引的情形</h3>
<p>索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。</p>
<p><strong>一般来说，应该在这些列上创建索引：</strong><br>
（1）在<strong>经常需要搜索</strong>的列上，可以加快搜索的速度；<br>
（2）在作为主键的列上，强制该列的<strong>唯一性</strong>和组织表中数据的排列结构；<br>
（3）在<strong>经常用在连接</strong>的列上，这些列主要是一些外键，可以加快连接的速度；<br>
（4）在<strong>经常需要根据范围进行搜索</strong>的列上创建索引，因为索引已经排序，其指定的范围是连续的；<br>
（5）在<strong>经常需要排序的列上</strong>创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；<br>
（6）在<strong>经常使用在WHERE子句中</strong>的列上面创建索引，加快条件的判断速度。</p>
<p><strong>对于有些列不应该创建索引：</strong><br>
（1）对于那些在查询中<strong>很少使用或者参考的列</strong>不应该创建索引。<br>
  这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。<br>
（2）对于那些<strong>只有很少数据值的列</strong>也不应该增加索引。<br>
  这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。<br>
（3）对于那些<strong>定义为text, image和bit数据类型</strong>的列不应该增加索引。这是因为这些列的数据量要么相当大，要么取值很少。<br>
（4）当<strong>修改性能远远大于检索性能</strong>时，不应该创建索引。<br>
  这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</p>
<h3 id="什么样的字段适合建索引">什么样的字段适合建索引</h3>
<p>唯一、不为空、经常被查询的字段</p>
<h3 id="mysql-btree索引和hash索引的区别">MySQL B+Tree索引和Hash索引的区别?</h3>
<p><strong>Hash索引和B+树索引的特点：</strong></p>
<ol>
<li>
<p>Hash索引结构的特殊性，其<strong>检索效率非常高</strong>，索引的检索可以一次定位;</p>
</li>
<li>
<p>B+树索引需要<strong>从根节点到枝节点</strong>，最后才能访问到页节点这样多次的IO访问;</p>
</li>
</ol>
<p><strong>为什么不都用Hash索引而使用B+树索引？</strong></p>
<ol>
<li>
<p>Hash索引仅仅能满足&quot;=&quot;,&quot;IN&quot;和&quot;&quot;查询，<strong>不能使用范围查询</strong>,因为经过相应的Hash算法处理之后的Hash值的大小关系，并不能保证和Hash运算前完全一样；</p>
</li>
<li>
<p>Hash索引<strong>无法被用来进行数据的排序操作</strong>，因为Hash值的大小关系并不一定和Hash运算前的键值完全一样；</p>
</li>
<li>
<p>Hash索引<strong>不能利用部分索引键查询</strong>，对于组合索引，Hash索引在计算Hash值的时候是组合索引键合并后再一起计算Hash值，而不是单独计算Hash值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash索引也无法被利用；</p>
</li>
<li>
<p>Hash索引在任何时候都<strong>不能避免表扫描</strong>，由于不同索引键存在相同Hash值，所以即使取满足某个Hash键值的数据的记录条数，也无法从Hash索引中直接完成查询，还是要回表查询数据；</p>
</li>
<li>
<p>Hash索引<strong>遇到大量Hash值相等</strong>的情况后性能并不一定就会比B+树索引高。</p>
</li>
</ol>
<p>补充：</p>
<ol>
<li>MySQL中，只有HEAP/MEMORY引擎才显示支持Hash索引。</li>
<li>常用的InnoDB引擎中默认使用的是B+树索引，它会实时监控表上索引的使用情况，如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引（在InnoDB中默认开启自适应哈希索引），通过观察搜索模式，MySQL会利用index key的前缀建立哈希索引，如果一个表几乎大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。</li>
</ol>
<p>B+树索引和哈希索引的明显区别是：<br>
3. 如果是<strong>等值查询</strong>，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；<br>
4. 如果是<strong>范围查询检索</strong>，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；<br>
同理，哈希索引没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；<br>
5. 哈希索引也不支持多列联合索引的最左匹配规则；<br>
6. B+树索引的关键字<strong>检索效率比较平均</strong>，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。<br>
7. 在大多数场景下，都会有范围查询、排序、分组等查询特征，用B+树索引就可以了。</p>
<h3 id="b树和b树的区别">B树和B+树的区别</h3>
<ol>
<li>
<p>B树<br>
  <strong>每个节点都存储key和data</strong>，所有节点组成这棵树，并且<strong>叶子节点指针为nul</strong>，叶子结点不包含任何关键字信息。</p>
</li>
<li>
<p>B+树<br>
  <strong>所有的叶子结点中包含了全部关键字的信息</strong>，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接，<strong>所有的非终端结点可以看成是索引部分</strong>，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)</p>
</li>
</ol>
<h3 id="为什么说b比b树更适合实际应用中操作系统的文件索引和数据库索引">为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？</h3>
<ol>
<li>
<p>B+的磁盘读写代价更低<br>
  B+的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p>
</li>
<li>
<p>B+树的查询效率更加稳定<br>
  由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
</li>
</ol>
<h3 id="聚集索引和非聚集索引区别">聚集索引和非聚集索引区别?</h3>
<ol>
<li>
<p>聚合索引(clustered index):<br>
  聚集索<strong>引表记录的排列顺序和索引的排列顺序一致</strong>，所以查询效率快，只要找到第一个索引值记录，其余就连续性的记录在物理也一样连续存放。聚集索引对应的缺点就是修改慢，因为为了保证表中记录的物理和索引顺序一致，在记录插入的时候，会对数据页重新排序。<br>
  聚集索引类似于新华字典中用拼音去查找汉字，拼音检索表于书记顺序都是按照a~z排列的，就像相同的逻辑顺序于物理顺序一样，当你需要查找a,ai两个读音的字，或是想一次寻找多个傻(sha)的同音字时，也许向后翻几页，或紧接着下一行就得到结果了。</p>
</li>
<li>
<p>非聚合索引(nonclustered index):<br>
  非聚集索引<strong>指定了表中记录的逻辑顺序</strong>，但是<strong>记录的物理和索引不一定一致</strong>，两种索引<strong>都采用B+树结构</strong>，非聚集索引的叶子层并不和实际数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针方式。非聚集索引层次多，不会造成数据重排。<br>
  非聚集索引类似在新华字典上通过偏旁部首来查询汉字，检索表也许是按照横、竖、撇来排列的，但是由于正文中是a~z的拼音顺序，所以就类似于逻辑地址于物理地址的不对应。同时适用的情况就在于分组，大数目的不同值，频繁更新的列中，这些情况即不适合聚集索引。<br>
根本区别：<br>
  聚集索引和非聚集索引的根本区别是<strong>表记录的排列顺序和与索引的排列顺序是否一致</strong>。</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 面试题 01.09. 字符串轮转[简单][KMP]]]></title>
        <id>https://lixin-scut.github.io//post/zi-fu-chuan-mian-shi-ti-0109-zi-fu-chuan-lun-zhuan-jian-dan-kmp</id>
        <link href="https://lixin-scut.github.io//post/zi-fu-chuan-mian-shi-ti-0109-zi-fu-chuan-lun-zhuan-jian-dan-kmp">
        </link>
        <updated>2020-04-18T03:09:02.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>字符串轮转。给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成（比如，waterbottle是erbottlewat旋转后的字符串）。<br>
示例1:<br>
输入：s1 = &quot;waterbottle&quot;, s2 = &quot;erbottlewat&quot;<br>
输出：True<br>
示例2:<br>
输入：s1 = &quot;aa&quot;, &quot;aba&quot;<br>
输出：False<br>
提示：<br>
字符串长度在[0, 100000]范围内。<br>
说明:<br>
你能只调用一次检查子串的方法吗？<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/string-rotation-lcci<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>一开始理解错了，以为是整体旋转，原来是局部旋转。</p>
<p>卧槽提示很秀，<br>
首先可以视为寻找是否有一种方式可以把第一个字符串分成两部分，即x和y，如此一来，第一个字符串就是xy，第二个字符串就是yx。例如，x = wat，y = erbottle。那么，第一个字符串xy = waterbottle，第二个字符串yx = erbottlewat。</p>
<p>然后进一步地，如果将旋转后拼接起来，会发现一定会包含子串，转化为KMP字符串匹配问题</p>
<p>实现中注意的问题</p>
<ol>
<li>i和j的两次初始化不相同，nextval[0]的初始化为-1</li>
<li>然后特别重要的问题j &lt; (int)s2.size()，因为j可能设计-1，如果和size_t比较会强行转化为超级大的正数</li>
</ol>
<pre><code>class Solution {
public:
    bool isFlipedString(string s1, string s2) {
        
        if(s1.size() != s2.size())
        {   return false; }
        if(s1.empty() &amp;&amp; s2.empty())
        {   return true; }
        s1 += s1;
        vector&lt;int&gt; nextval(s2.size(),0);
        GetNextval(s2, nextval);
        int i = 0;
        int j = 0;
        while(i &lt; s1.size() &amp;&amp; j &lt; (int)s2.size())
        {
            if(j == -1 || s1[i] == s2[j] )
            {
                ++i;
                ++j;
            }
            else
            {
                j = nextval[j];
            }
        }
        if(j &gt;= s2.size())
        {
            return true;
        }
        else
        {
            return false;
    
        }
    }
      
    void GetNextval(const string&amp; s, vector&lt;int&gt;&amp; nextval)
    {
        int i = 0;
        int j = -1;
        nextval[0] = -1;
        while(i &lt; s.size() - 1)
        {
            if(j == -1 || s[i] == s[j])
            {
                ++i;
                ++j;
                if(s[i] != s[j])
                {
                    nextval[i] = j;
                }
                else
                {
                    nextval[i] = nextval[j];
                }
            }
            else
            {
                j = nextval[j];
            }
        }
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 面试题 01.08. 零矩阵[中等]]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-mian-shi-ti-0108-ling-ju-zhen-zhong-deng</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-mian-shi-ti-0108-ling-ju-zhen-zhong-deng">
        </link>
        <updated>2020-04-17T02:12:07.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。<br>
示例 1：<br>
输入：<br>
[<br>
[1,1,1],<br>
[1,0,1],<br>
[1,1,1]<br>
]<br>
输出：<br>
[<br>
[1,0,1],<br>
[0,0,0],<br>
[1,0,1]<br>
]<br>
示例 2：<br>
输入：<br>
[<br>
[0,1,2,0],<br>
[3,4,5,2],<br>
[1,3,1,5]<br>
]<br>
输出：<br>
[<br>
[0,0,0,0],<br>
[0,4,5,0],<br>
[0,3,1,0]<br>
]<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/zero-matrix-lcci<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>第一想法还是暴力法，检测到0的坐标分别存好，然后再次循环置0<br>
当然最好肯定是时间复杂度爆炸了</p>
<p>题解有个不错的，就是标记行头和列头，不需要额外的hashset</p>
<pre><code>class Solution {
public:
    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        if(matrix.empty())
        {
            return;
        }
        int row = matrix.size();
        int col = matrix[0].size();
        unordered_set&lt;int&gt; zero_row;
        unordered_set&lt;int&gt; zero_col;
        for(int i = 0; i &lt; row; ++i)
        {
            for(int j = 0; j &lt; col; ++j)
            {
                if(matrix[i][j] == 0)
                {
                    zero_row.insert(i);
                    zero_col.insert(j);
                }
            }
        }
        
        for(int i = 0; i &lt; row; ++i)
        {
            for(int j = 0; j &lt; col; ++j)
            {
                if(zero_row.count(i) == 1 || zero_col.count(j) == 1)
                {
                    matrix[i][j] = 0;
                }
            }
        }
        return ;
    }
};
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>需要设零的行i：将该行的第一列元素matrix[i][0]设为0，表示该行需要清零；<br>
需要设为零的列j：将该列的第一行元素matrix[0][j]设为0，表示该列需要清零；<br>
根据第一行和第一列的标记，进行清零操作。<br>
matrix[0][0]即表示第一行又表示第一列,需要特殊处理</p>
</blockquote>
<pre><code>class Solution {
    public void setZeroes(int[][] matrix) {
        boolean shu = false;
        boolean hen = false;
        for (int i = 0; i &lt; matrix.length; i++) {
            for (int j = 0; j &lt; matrix[0].length; j++) {
                if (matrix[i][j] == 0) {
                    if (i == 0) {
                        hen = true;
                    }
                    if (j == 0) {
                        shu = true;
                    }
                    matrix[i][0] = 0;
                    matrix[0][j] = 0;
                }
            }
        }
        
        for (int i = 1; i &lt; matrix.length; i++) {
            if (matrix[i][0] == 0) {
                for (int j = 1; j &lt; matrix[0].length; j++) {
                    matrix[i][j] = 0;
                }
            }
        }

        for (int i = 1; i &lt; matrix[0].length; i++) {
            if (matrix[0][i] == 0) {
                for (int j = 1; j &lt; matrix.length; j++) {
                    matrix[j][i] = 0;
                }
            }
        }

        if (shu) {
            for (int i = 0; i &lt; matrix.length; i++) {
                matrix[i][0] = 0;
            }
        }
        if (hen) {
            for (int i = 0; i &lt; matrix[0].length; i++) {
                matrix[0][i] = 0;
            }
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nginx基础概念]]></title>
        <id>https://lixin-scut.github.io//post/nginx-ji-chu-gai-nian</id>
        <link href="https://lixin-scut.github.io//post/nginx-ji-chu-gai-nian">
        </link>
        <updated>2020-04-16T03:01:31.000Z</updated>
        <content type="html"><![CDATA[<p>  前几天面试的时候面试官提起Nginx，并嘱托我应当了解一下，今天先来看一下它的基础概念</p>
<h3 id="nginx-的产生">Nginx 的产生</h3>
<p>  Nginx 同 Apache 一样都是一种 Web 服务器。基于 REST 架构风格，以统一资源描述符（Uniform Resources Identifier）URI 或者统一资源定位符（Uniform Resources Locator）URL 作为沟通依据，通过 HTTP 协议提供各种网络服务。</p>
<p>  然而，这些服务器在设计之初受到当时环境的局限，例如当时的用户规模，网络带宽，产品特点等局限并且各自的定位和发展都不尽相同。这也使得各个 Web 服务器有着各自鲜明的特点。</p>
<p>  Apache 的发展时期很长，而且是毫无争议的世界第一大服务器。它有着很多优点：稳定、开源、跨平台等等。</p>
<p>  它出现的时间太早了，它兴起的年代，互联网产业远远比不上现在。所以它被设计为一个重量级的。</p>
<p>  它不支持高并发的服务器。在 Apache 上运行数以万计的并发访问，会导致服务器消耗大量内存。</p>
<p>  操作系统对其进行进程或线程间的切换也消耗了大量的 CPU 资源，导致 HTTP 请求的平均响应速度降低。</p>
<p>  这些都决定了 Apache 不可能成为高性能 Web 服务器，轻量级高并发服务器 Nginx 就应运而生了。</p>
<p>  俄罗斯的工程师 Igor Sysoev，他在为 Rambler Media 工作期间，使用 C 语言开发了 Nginx。</p>
<p>  Nginx 作为 Web 服务器一直为 Rambler Media 提供出色而又稳定的服务。然后呢，Igor Sysoev 将 Nginx 代码开源，并且赋予自由软件许可证。</p>
<h3 id="nginx-的有优点">Nginx 的有优点</h3>
<ol>
<li>Nginx 使用基于事件驱动架构，使得其可以支持数以百万级别的 TCP 连接。高度的模块化和自由软件许可证使得第三方模块层出不穷（这是个开源的时代啊）。</li>
<li>Nginx 是一个跨平台服务器，可以运行在 Linux、Windows、FreeBSD、Solaris、AIX、Mac OS 等操作系统上。这些优秀的设计带来的极大的稳定性。<br>
Nginx 的用武之地</li>
<li>Nginx 是一款自由的、开源的、高性能的 HTTP 服务器和反向代理服务器；同时也是一个 IMAP、POP3、SMTP 代理服务器。</li>
<li>Nginx 可以作为一个 HTTP 服务器进行网站的发布处理，另外 Nginx 可以作为反向代理进行负载均衡的实现。</li>
</ol>
<h3 id="关于代理">关于代理</h3>
<p>  说到代理，首先我们要明确一个概念，所谓代理就是一个代表、一个渠道；此时就涉及到两个角色，一个是被代理角色，一个是目标角色。</p>
<p>  被代理角色通过这个代理访问目标角色完成一些任务的过程称为代理操作过程；如同生活中的专卖店，客人到 adidas 专卖店买了一双鞋，这个专卖店就是代理，被代理角色就是 adidas 厂家，目标角色就是用户。</p>
<h3 id="正向代理">正向代理</h3>
<p>  说反向代理之前，我们先看看正向代理，正向代理也是大家最常接触到的代理模式，我们会从两个方面来说关于正向代理的处理模式，分别从软件方面和生活方面来解释一下什么叫正向代理。</p>
<p>  在如今的网络环境下，我们如果由于技术需要要去访问国外的某些网站，此时你会发现位于国外的某网站我们通过浏览器是没有办法访问的。</p>
<p>  此时大家可能都会用一个操作 FQ 进行访问，FQ 的方式主要是找到一个可以访问国外网站的代理服务器，我们将请求发送给代理服务器，代理服务器去访问国外的网站，然后将访问到的数据传递给我们！</p>
<p>  上述这样的代理模式称为正向代理，正向代理最大的特点是客户端非常明确要访问的服务器地址；服务器只清楚请求来自哪个代理服务器，而不清楚来自哪个具体的客户端；正向代理模式屏蔽或者隐藏了真实客户端信息。</p>
<p>  来看个示意图（我把客户端和正向代理框在一块，同属于一个环境，后面我有介绍）：<br>
<img src="https://lixin-scut.github.io//post-images/1587007081275.png" alt=""><br>
  客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的 IP 地址，还有代理程序的端口。</p>
<p>  总结来说：正向代理，&quot;它代理的是客户端&quot;，是一个位于客户端和原始服务器（Origin Server）之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标（原始服务器）。</p>
<p>  然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。</p>
<p>正向代理的用途：<br>
  访问原来无法访问的资源，如 Google。可以做缓存，加速访问资源。对客户端访问授权，上网进行认证。代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息。</p>
<h3 id="反向代理">反向代理</h3>
<p>  明白了什么是正向代理，我们继续看关于反向代理的处理方式，举例如我国的某宝网站，每天同时连接到网站的访问人数已经爆表，单个服务器远远不能满足人民日益增长的购买欲望了。</p>
<p>  此时就出现了一个大家耳熟能详的名词：分布式部署；也就是通过部署多台服务器来解决访问人数限制的问题。</p>
<p>  淘宝网站中大部分功能也是直接使用 Nginx 进行反向代理实现的，并且通过封装 Nginx 和其他的组件之后起了个高大上的名字：Tengine。</p>
<p>有兴趣的童鞋可以访问 Tengine 的官网查看具体的信息：http://tengine.taobao.org/</p>
<p>  那么反向代理具体是通过什么样的方式实现的分布式的集群操作呢，我们先看一个示意图（我把服务器和反向代理框在一块，同属于一个环境，后面我有介绍）：<br>
<img src="https://lixin-scut.github.io//post-images/1587007163164.png" alt=""><br>
  通过上述的图解大家就可以看清楚了，多个客户端给服务器发送的请求，Nginx 服务器接收到之后，按照一定的规则分发给了后端的业务处理服务器进行处理了。</p>
<p>  此时请求的来源也就是客户端是明确的，但是请求具体由哪台服务器处理的并不明确了，Nginx 扮演的就是一个反向代理角色。</p>
<p>  客户端是无感知代理的存在的，反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。因为客户端不需要任何配置就可以访问。</p>
<p>  反向代理，&quot;它代理的是服务端&quot;，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息</p>
<p>反向代理的作用：<br>
  保证内网的安全，通常将反向代理作为公网访问地址，Web 服务器是内网。负载均衡，通过反向代理服务器来优化网站的负载。</p>
<h3 id="项目场景">项目场景</h3>
<p>  通常情况下，我们在实际项目操作时，正向代理和反向代理很有可能会存在同一个应用场景中，正向代理代理客户端的请求去访问目标服务器，目标服务器是一个反向单利服务器，反向代理了多台真实的业务处理服务器。<br>
具体的拓扑图如下：<br>
<img src="https://lixin-scut.github.io//post-images/1587007185663.png" alt=""><br>
截了一张图来说明正向代理和反向代理二者之间的区别，如下图：<br>
<img src="https://lixin-scut.github.io//post-images/1587007193887.png" alt=""></p>
<p>图解：<br>
  在正向代理中，Proxy 和 Client 同属于一个 LAN（图中方框内），隐藏了客户端信息。在反向代理中，Proxy 和 Server 同属于一个 LAN（图中方框内），隐藏了服务端信息。</p>
<p>  实际上，Proxy 在两种代理中做的事情都是替服务器代为收发请求和响应，不过从结构上看正好左右互换了一下，所以把后出现的那种代理方式称为反向代理了。</p>
<h3 id="负载均衡">负载均衡</h3>
<p>  我们已经明确了所谓代理服务器的概念，那么接下来，Nginx 扮演了反向代理服务器的角色，它是依据什么样的规则进行请求分发的呢？不用的项目应用场景，分发的规则是否可以控制呢？</p>
<p>  这里提到的客户端发送的、Nginx 反向代理服务器接收到的请求数量，就是我们说的负载量。请求数量按照一定的规则进行分发，到不同的服务器处理的规则，就是一种均衡规则。</p>
<p>所以将服务器接收到的请求按照规则分发的过程，称为负载均衡。</p>
<p>  负载均衡在实际项目操作过程中，有硬件负载均衡和软件负载均衡两种，硬件负载均衡也称为硬负载，如 F5 负载均衡，相对造价昂贵成本较高。</p>
<p>  但是数据的稳定性安全性等等有非常好的保障，如中国移动中国联通这样的公司才会选择硬负载进行操作。</p>
<p>  更多的公司考虑到成本原因，会选择使用软件负载均衡，软件负载均衡是利用现有的技术结合主机硬件实现的一种消息队列分发机制。<br>
<img src="https://lixin-scut.github.io//post-images/1587007222915.png" alt=""></p>
<p>Nginx 支持的负载均衡调度算法方式如下：</p>
<ol>
<li><strong>weight 轮询（默认）</strong>：<br>
  接收到的请求按照顺序逐一分配到不同的后端服务器，即使在使用过程中，某一台后端服务器宕机，Nginx 会自动将该服务器剔除出队列，请求受理情况不会受到任何影响。</li>
</ol>
<p>  这种方式下，可以给不同的后端服务器设置一个权重值（weight），用于调整不同的服务器上请求的分配率。</p>
<p>  权重数据越大，被分配到请求的几率越大；该权重值，主要是针对实际工作环境中不同的后端服务器硬件配置进行调整的。</p>
<ol start="2">
<li>
<p><strong>ip_hash</strong>：<br>
  每个请求按照发起客户端的 ip 的 hash 结果进行匹配，这样的算法下一个固定 ip 地址的客户端总会访问到同一个后端服务器，这也在一定程度上解决了集群部署环境下 Session 共享的问题。</p>
</li>
<li>
<p><strong>fair</strong>：<br>
  智能调整调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配。</p>
</li>
</ol>
<p>  响应时间短处理效率高的服务器分配到请求的概率高，响应时间长处理效率低的服务器分配到的请求少，它是结合了前两者的优点的一种调度算法。</p>
<p>  但是需要注意的是 Nginx 默认不支持 fair 算法，如果要使用这种调度算法，请安装 upstream_fair 模块。</p>
<ol start="4">
<li><strong>url_hash</strong>：<br>
  按照访问的 URL 的 hash 结果分配请求，每个请求的 URL 会指向后端固定的某个服务器，可以在 Nginx 作为静态服务器的情况下提高缓存效率。<br>
同样要注意 Nginx 默认不支持这种调度算法，要使用的话需要安装 Nginx 的 hash 软件包。</li>
</ol>
<h3 id="web-服务器对比">Web 服务器对比</h3>
<p>几种常用 Web 服务器对比如下图：<br>
<img src="https://lixin-scut.github.io//post-images/1587007297373.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 面试题 01.06. 字符串压缩[简单]]]></title>
        <id>https://lixin-scut.github.io//post/zi-fu-chuan-mian-shi-ti-0106-zi-fu-chuan-ya-suo-jian-dan</id>
        <link href="https://lixin-scut.github.io//post/zi-fu-chuan-mian-shi-ti-0106-zi-fu-chuan-ya-suo-jian-dan">
        </link>
        <updated>2020-04-16T02:35:33.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。<br>
示例1:<br>
输入：&quot;aabcccccaaa&quot;<br>
输出：&quot;a2b1c5a3&quot;<br>
示例2:<br>
输入：&quot;abbccd&quot;<br>
输出：&quot;abbccd&quot;<br>
解释：&quot;abbccd&quot;压缩后为&quot;a1b2c2d1&quot;，比原字符串长度更长。<br>
提示：<br>
字符串长度在[0, 50000]范围内。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/compress-string-lcci<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>两个想法 1.bitset+位运算 2.sort排序+循环统计<br>
首先还是复习一下位运算</p>
<p>实现sort+loop的时候才发现不需要排序呀。这样子也没必要bitset了</p>
<p>实现中需要注意的点：</p>
<ol>
<li>意这里循环的初始化 配合 变量初始化</li>
<li>char应该用push_back而不是 string的operator+</li>
<li>数字和字母不同，因为有超过10的可能，不能直接int+'0'</li>
<li>return的判断应为小于等于，而不是小于</li>
</ol>
<pre><code>class Solution {
public:
    // sort + loop
    string compressString(string S)
    {
        if(S.empty())
        {
            return S;
        }
        
        // string S_temp = S;
        // sort(S_temp.begin(), S_temp.end());
        
        string res;
        char temp = S[0];
        int count = 1;
        for(int i = 1; i &lt;= S.size(); ++i) // 注意这里 配合初始化，i从1开始
        {
            if(i ==  S.size() || S[i] != temp)
            {
                res.push_back(temp); // char应该用push_back而不是 string的operator+
                res += to_string(count); // 注意这里不能直接push_back('0' + count)，防止超过10
                temp = S[i];
                count = 1;
            }
            else
            {
                ++count;
            }
        }
        return S.size() &lt;= res.size() ? S : res; // 小于等于
    }
};
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>双指针法：<br>
这道题考察的第一个点是如何找到字符串中连续的字符。方法是使用双指针，移动两个下标 i 和 j。<br>
这道题考察的第二个点是构建字符串的时间复杂度。例如在 C++ 中，res += s 和 res = res + s 的含义是不一样的。前者是直接在 res 后面添加字符串；后者是用一个临时对象计算 res + s，会消耗很多时间和内存。<br>
同样的，在 Java 中，要使用 StringBuilder，而不能直接用字符串相加。</p>
</blockquote>
<pre><code>string compressString(string S) {
    int N = S.length();
    string res;
    int i = 0;
    while (i &lt; N) {
        int j = i;
        while (j &lt; N &amp;&amp; S[j] == S[i]) {
            j++;
        }
        res += S[i];
        res += to_string(j - i);
        i = j;
    }

    if (res.length() &lt; S.length()) {
        return res;
    } else {
        return S;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 面试题 01.05. 一次编辑[中等]]]></title>
        <id>https://lixin-scut.github.io//post/zi-fu-chuan-mian-shi-ti-0105-yi-ci-bian-ji-zhong-deng</id>
        <link href="https://lixin-scut.github.io//post/zi-fu-chuan-mian-shi-ti-0105-yi-ci-bian-ji-zhong-deng">
        </link>
        <updated>2020-04-15T15:29:20.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。<br>
示例 1:<br>
输入:<br>
first = &quot;pale&quot;<br>
second = &quot;ple&quot;<br>
输出: True<br>
示例 2:<br>
输入:<br>
first = &quot;pales&quot;<br>
second = &quot;pal&quot;<br>
输出: False<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/one-away-lcci<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>我第一反应还是hashset<br>
等等。。。还是得用hashmap统计次数。。。<br>
然后发现我的想法是错的。。。因为例如“123” “312”这种错位的明显无法通过一次操作完成<br>
同样地排序法也不可能了</p>
<p>最终的绝杀就是编辑距离。。。</p>
<p>不过还是选择了相对简化的方法</p>
<ol>
<li>由于限制了操作只有一次，首先判断size是否大于2</li>
<li>首先判断size是否相等，相等的时候只适用于修改</li>
<li>其次判断一次跳跃，视为删除或增加</li>
</ol>
<p>实现中注意的问题</p>
<ol>
<li>初始化变量为0 因为两个空数组有可能直接返回</li>
<li>abs函数接受int，size_t引起候选歧义</li>
</ol>
<pre><code>class Solution {
public:
    bool oneEditAway(string first, string second) {
        if(abs(static_cast&lt;int&gt;(first.size() - second.size())) &gt; 1) // abs函数接受int，size_t引起候选歧义
            return false;
        if(first.size() == second.size())
        {
            int diff = 0; // 初始化变量为0 因为两个空数组有可能直接返回
            for(int i = 0; i &lt; first.size(); ++i)
            {
                if(first[i] != second[i])
                {
                    ++diff;
                }
            }
            return diff &lt;= 1;
        }
        
        if(first.size() &gt; second.size())
        {
            swap(first, second);
        }
        
        bool diff = true;
        for(int i = 0, j = 0; i &lt; first.size() &amp;&amp; j &lt;second.size(); )
        {
            if(first[i] == second[j])
            {   
                ++i;
                ++j;
                continue; 
            }
            if(diff)
            {
                diff = false;
                ++j;
            }
            else
            {
                return diff;
            }
        }
        return true; // 注意不能返回diff，可能被修改为false
    }
    
};
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>双指针<br>
算法：<br>
首先判断两个字符串长度，相差大于一返回 false<br>
双指针遍历两个字符串，同时记录编辑次数 op_cnt：<br>
若 first[i] == second[j]，不需编辑，i，j 加一<br>
若 first[i] != second[j]，分为三种情况：<br>
first[i] == second[j+1]，那么 j++，op_cnt++<br>
first[i+1] == second[j]，那么 i++，op_cnt++<br>
以上两种都不符合，那么使用替换操作，i++，j++，op_cnt++<br>
注意，一旦 op_cnt &gt; 1，返回 false<br>
遍历结束后，若仍有一方未走到结尾，且相差的长度 + op_cnt 大于 1，则返回 false</p>
</blockquote>
<pre><code>class Solution {
public:
  bool oneEditAway(string first, string second) {
    int len1 = first.size(), len2 = second.size();
    if (abs(len1 - len2) &gt; 1) return false;
    int i = 0, j = 0;
    int op_cnt = 0;
    while (i &lt; len1 &amp;&amp; j &lt; len2) {
      if (first[i] == second[j]) {
        i++, j++;
      } else {
        if (first[i] == second[j+1]) {
          j++;
          if (op_cnt &gt; 0) return false;
          else op_cnt++;
        } else if (first[i+1] == second[j]) {
          i++;
          if (op_cnt &gt; 0) return false;
          else op_cnt++;
        } else {
          i++, j++;
          if (op_cnt &gt; 0) return false;
          else op_cnt++;
        }
      }
    }
    if (max(len1 - i, len2 - j) + op_cnt &gt; 1) return false;
    return true;
  }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[位集合bitset - 位运算]]></title>
        <id>https://lixin-scut.github.io//post/wei-ji-he-bitset-wei-yun-suan</id>
        <link href="https://lixin-scut.github.io//post/wei-ji-he-bitset-wei-yun-suan">
        </link>
        <updated>2020-04-14T13:39:21.000Z</updated>
        <content type="html"><![CDATA[<p>今天在做题 面试题 01.04. 回文排列 的时候在看网友题解发现了C++新增的容器bitset，下面是简略的介绍</p>
<h3 id="基础概念">基础概念</h3>
<ol>
<li>
<p>bitset所在的头文件<code>&lt;bitset&gt;</code></p>
</li>
<li>
<p>命名空间std</p>
</li>
<li>
<p><code>bitset&lt;N&gt;</code>属于非类型模板参数</p>
</li>
</ol>
<pre><code>#include &lt;bitset&gt;
std::bitset&lt;8&gt; bs;      

// 模板参数是一个size_t类型的数值（value），而非一个类型
// numeric_limits&lt;size_t&gt;::min() == 0
// std::bitset&lt;8&gt; 表示的二进制位为8位，
// 默认的构造函数将其初始为全0

cout &lt;&lt; bs.to_ulong() &lt;&lt; endl;      // 0
cout &lt;&lt; bs.to_string() &lt;&lt; endl;     // 00000000
</code></pre>
<h3 id="bitset-的构造">bitset 的构造</h3>
<p>唯一需要注意的是，bitset&lt;&gt;模板类虽然重载了中括号运算符，bs[0]表示的是将该数值转换为二进制时的最末尾元素，而非首位（其意义和数组并不相同）。</p>
<pre><code>std::bitset&lt;8&gt; bs;
//bs[0] = 1;            // 0000 0001
//bs[7] = 1;            // 1000 0000
</code></pre>
<ol>
<li>默认无参构造<br>
初始化全部位为0<br>
-十进制或者16进制数值</li>
</ol>
<pre><code>std::bitset&lt;8&gt; bs(7);
bs.to_string()  // 0000 0111
std::bitset&lt;8&gt; bs(0x07);
bs.to_string()  // 0000 0111
</code></pre>
<p>这里也存在一些高大上的构造方式：</p>
<pre><code>bitset&lt;numeric_limits&lt;unsigned short&gt;::digits&gt; bs1(267);
    // 16位 
bitset&lt;numeric_limits&lt;unsigned long&gt;::digits&gt; bs2(267);
    // 32位
</code></pre>
<ol start="2">
<li>用string对象</li>
</ol>
<pre><code>std::bitset&lt;8&gt; bs(&quot;00000111&quot;);
bs.to_ulong();      // 7
</code></pre>
<h3 id="bitset的操作">bitset的操作</h3>
<table>
<thead>
<tr>
<th style="text-align:center">成员函数</th>
<th style="text-align:center">函数功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">bs.any()</td>
<td style="text-align:center">是否存在值为1的二进制位</td>
</tr>
<tr>
<td style="text-align:center">bs.none()</td>
<td style="text-align:center">是否不存在值为1的二进制位 或者说是否全部位为0</td>
</tr>
<tr>
<td style="text-align:center">bs.size()</td>
<td style="text-align:center">位长，也即是非模板参数值</td>
</tr>
<tr>
<td style="text-align:center">bs.count()</td>
<td style="text-align:center">值为1的个数</td>
</tr>
<tr>
<td style="text-align:center">bs.test(pos)</td>
<td style="text-align:center">测试pos处的二进制位是否为1 与0做或运算</td>
</tr>
<tr>
<td style="text-align:center">bs.set()</td>
<td style="text-align:center">全部位置1</td>
</tr>
<tr>
<td style="text-align:center">bs.set(pos)</td>
<td style="text-align:center">pos位处的二进制位置1 与1做或运算</td>
</tr>
<tr>
<td style="text-align:center">bs.reset()</td>
<td style="text-align:center">全部位置0</td>
</tr>
<tr>
<td style="text-align:center">bs.reset(pos)</td>
<td style="text-align:center">pos位处的二进制位置0 与0做或运算</td>
</tr>
<tr>
<td style="text-align:center">bs.flip()</td>
<td style="text-align:center">全部位逐位取反</td>
</tr>
<tr>
<td style="text-align:center">bs.flip(pos)</td>
<td style="text-align:center">pos处的二进制位取反</td>
</tr>
<tr>
<td style="text-align:center">bs.to_ulong()</td>
<td style="text-align:center">将二进制转换为unsigned long输出</td>
</tr>
<tr>
<td style="text-align:center">bs.to_string()</td>
<td style="text-align:center">将二进制转换为字符串输出</td>
</tr>
<tr>
<td style="text-align:center">~bs</td>
<td style="text-align:center">按位取反 效果等效为bs.flip()</td>
</tr>
<tr>
<td style="text-align:center">os &lt;&lt; b</td>
<td style="text-align:center">将二进制位输出到os流 小值在右，大值在左</td>
</tr>
</tbody>
</table>
<h3 id="一些高级用法">一些高级用法</h3>
<p>首先看一个简单实例：</p>
<pre><code>&quot;1000 0000&quot; - &gt; 1
&quot;1000 1000&quot; - &gt; 17
</code></pre>
<p>如何实现2进制向10进制的转换，而且二进制的表示形式是一种逆序的形式，即低位在前。</p>
<pre><code>int bin2dec(const string&amp; bin)
{
    std::bitset&lt;8&gt; bs(string(bin.rbegin(), bin.rend()));
    return bs.to_ulong();
}
</code></pre>
<p>这里回顾开头引用中的话，bitset的强大之处不在于表示一个二进制的数值，而是表达一种情况数，一个二进制位可以表示两种情况，两个二进制位可以表示4种状况数，3个二进制位可以表达8种状况数，等等。</p>
<p>将Bitsets视为一组标志</p>
<pre><code>enum Color{red, yellow, green, blue, white, black, numColors};
// 初始状态下，全部颜色都未使用
bitset&lt;numColors&gt; usedColors;

// something happens
usedColors.set(red);
usedColors.set(blue);

cout &lt;&lt; &quot;bitfield of used colors: &quot; &lt;&lt; usedColors &lt;&lt; endl;
cout &lt;&lt; &quot;bitfield of unused colors: &quot; &lt;&lt; ~usedColors &lt;&lt; endl;

// process if any color is used 
if (usedColors.any())
{
    for (int c = 0; c &lt; numColors; ++c)
    {   // 貌似只有遍历，而没有提供返回值为1的下标
        if (usedColor[Color(c)])
        {
            // 
        }
    }
}
</code></pre>
<p>参考链接：<a href="https://blog.csdn.net/weixin_44489823/article/details/92640750">bitset详解</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[位运算 面试题 01.04. 回文排列[简单]]]></title>
        <id>https://lixin-scut.github.io//post/wei-yun-suan-mian-shi-ti-0104-hui-wen-pai-lie</id>
        <link href="https://lixin-scut.github.io//post/wei-yun-suan-mian-shi-ti-0104-hui-wen-pai-lie">
        </link>
        <updated>2020-04-14T13:30:03.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。<br>
回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。<br>
回文串不一定是字典当中的单词。<br>
示例1：<br>
输入：&quot;tactcoa&quot;<br>
输出：true（排列有&quot;tacocat&quot;、&quot;atcocta&quot;，等等）<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/palindrome-permutation-lcci<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题比较特别，第一想法是关键点在于其中的数字的奇偶数<br>
只有一个字母的个数能够为奇数，否则就不可能达到对齐</p>
<p>实现注意：</p>
<ol>
<li>测试证明是不止小写字符，所以得用128元素的数组，ascii码有128个符号。</li>
<li>注意统计方法。</li>
</ol>
<p>然后看了题解可以用比较新的bitset位集合方法</p>
<pre><code>class Solution {
public:
    // bitset位运算版
    bool canPermutePalindrome(string s) 
    {
        bitset&lt;128&gt; letters_counts;
        
        for(char c : s)
        {
            letters_counts.flip(c);
        }
        
        return letters_counts.count() &lt;= 1;
    }
    /*
		// 固定数组
    bool canPermutePalindrome(string s) {
        vector&lt;int&gt; letters_counts(128, 0);
        
        for(char c : s)
        {
            ++letters_counts[c];
        }
        int odd_counts = 0;
        for(int i : letters_counts)
        {
            if(i % 2 == 1)
            {
                ++odd_counts;
            }
        }
        return odd_counts &lt;= 1;
    }
    */
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 面试题 01.03. URL化[简单]]]></title>
        <id>https://lixin-scut.github.io//post/zi-fu-chuan-mian-shi-ti-0103-url-hua-jian-dan</id>
        <link href="https://lixin-scut.github.io//post/zi-fu-chuan-mian-shi-ti-0103-url-hua-jian-dan">
        </link>
        <updated>2020-04-14T08:10:55.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>URL化。编写一种方法，将字符串中的空格全部替换为%20。假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。（注：用Java实现的话，请使用字符数组实现，以便直接在数组上操作。）<br>
示例1:<br>
输入：&quot;Mr John Smith    &quot;, 13<br>
输出：&quot;Mr%20John%20Smith&quot;<br>
示例2:<br>
输入：&quot;               &quot;, 5<br>
输出：&quot;%20%20%20%20%20&quot;<br>
提示：<br>
字符串长度在[0, 500000]范围内。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/string-to-url-lcci<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>比较简单， 从后往前替换即可</p>
<p>实现起来才知道这简单的题可不简单</p>
<ol>
<li>题目可没有明说S刚刚好能容纳结果，只是保证长度肯定够，所以必须遍历S统计空格的结果，而且循环必须控制在length内</li>
<li>然后返回值也不能直接返回S，而是要返回修改后字符串的长度</li>
</ol>
<p>果然还是不能自大啊</p>
<pre><code>class Solution {
public:
    string replaceSpaces(string S, int length) {
        if(S.empty())
        {   return S; }
        
        int num_of_space = 0;
        for(int i = 0; i &lt; length; ++i)
        {
            if(S[i] == ' ')
            {
                ++num_of_space;
            }
        }
        int i = length - 1;
        int j = num_of_space * 2 + length - 1;
        
        while(i &lt; j)
        {
            if(S[i] != ' ')
            {
                S[j] = S[i];
            }
            else
            {
                S[j--] = '0';
                S[j--] = '2';
                S[j] = '%';
            }
            --i;
            --j;
        }
        return S.substr(0, num_of_space * 2 + length);
    }
};
</code></pre>
]]></content>
    </entry>
</feed>