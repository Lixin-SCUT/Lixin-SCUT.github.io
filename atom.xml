<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-04-23T08:14:57.057Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>千里之行，始于足下。不积跬步，无以至千里。</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[数据库：事务]]></title>
        <id>https://lixin-scut.github.io//post/shu-ju-ku-shi-wu</id>
        <link href="https://lixin-scut.github.io//post/shu-ju-ku-shi-wu">
        </link>
        <updated>2020-04-23T07:29:04.000Z</updated>
        <content type="html"><![CDATA[<h3 id="事务">事务</h3>
<p>  事务是对数据库中一系列操作进行统一的回滚或者提交的操作，主要用来保证数据的完整性和一致性。</p>
<h3 id="事务四大特性acid">事务四大特性（ACID）</h3>
<p>原子性、一致性、隔离性、持久性</p>
<p><strong>原子性（Atomicity）:</strong><br>
  原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p>
<p><strong>一致性（Consistency）:</strong><br>
  事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没收到。</p>
<p><strong>隔离性（Isolation）:</strong><br>
  隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</p>
<p><strong>持久性（Durability）:</strong><br>
  持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>
<h2 id="事务的并发与事务隔离级别">事务的并发与事务隔离级别</h2>
<p>每个级别会引发什么问题，MySQL默认是哪个级别?</p>
<p><img src="https://lixin-scut.github.io//post-images/1587627485392.png" alt=""><br>
  从理论上来说, 事务应该彼此完全隔离, 以避免并发事务所导致的问题，然而, 那样会对性能产生极大的影响, 因为事务必须按顺序运行， 在实际开发中, 为了提升性能, 事务会以较低的隔离级别运行， 事务的隔离级别可以通过隔离事务属性指定。</p>
<p><strong>事务的并发问题</strong></p>
<ol>
<li>脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</li>
<li>不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。</li>
<li>幻读：幻读解决了不可重复读，保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）。<br>
<img src="https://lixin-scut.github.io//post-images/1587627503240.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1587627525081.png" alt=""></li>
</ol>
<p>  例如：事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作 这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。 而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有跟没有修改一样，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。<br>
  小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。</p>
<p><strong>事务的隔离级别</strong><br>
<img src="https://lixin-scut.github.io//post-images/1587627552072.png" alt=""></p>
<ol>
<li>读未提交：另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据脏读</li>
<li>不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。</li>
<li>可重复读：在同一个事务里，SELECT的结果是事务开始时时间点的状态，因此，同样的SELECT操作读到的结果会是一致的。但是，会有幻读现象</li>
<li>串行化：最高的隔离级别，在这个隔离级别下，不会产生任何异常。并发的事务，就像事务是在一个个按照顺序执行一样</li>
</ol>
<p>特别注意：</p>
<ol>
<li>MySQL默认的事务隔离级别为repeatable-read</li>
<li>MySQL 支持 四种事务隔离级别.</li>
<li>事务的隔离级别要得到底层数据库引擎的支持, 而不是应用程序或者框架的支持.</li>
<li>Oracle 支持的 2 种事务隔离级别：READ_COMMITED , SERIALIZABLE</li>
<li>SQL规范所规定的标准，不同的数据库具体的实现可能会有些差异</li>
<li>MySQL中默认事务隔离级别是“可重复读”时并不会锁住读取到的行<br>
  事务隔离级别：未提交读时，写数据只会锁住相应的行。<br>
  事务隔离级别为：可重复读时，写数据会锁住整张表。<br>
  事务隔离级别为：串行化时，读写数据都会锁住整张表。</li>
<li>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大，鱼和熊掌不可兼得啊。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed，它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。<br>
<img src="https://lixin-scut.github.io//post-images/1587627572153.png" alt=""></li>
</ol>
<p><strong>事务传播行为</strong></p>
<ol>
<li>PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</li>
<li>PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</li>
<li>PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</li>
<li>PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。</li>
<li>PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li>
<li>PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。</li>
<li>PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</li>
</ol>
<p><strong>嵌套事务</strong></p>
<p>  嵌套是子事务套在父事务中执行，子事务是父事务的一部分，在进入子事务之前，父事务建立一个回滚点，叫save point，然后执行子事务，这个子事务的执行也算是父事务的一部分，然后子事务执行结束，父事务继续执行。重点就在于那个save point。<br>
  如果子事务回滚，会发生什么？<br>
  父事务会回滚到进入子事务前建立的save point，然后尝试其他的事务或者其他的业务逻辑，父事务之前的操作不会受到影响，更不会自动回滚。<br>
  如果父事务回滚，会发生什么？<br>
  父事务回滚，子事务也会跟着回滚！为什么呢，因为父事务结束之前，子事务是不会提交的，我们说子事务是父事务的一部分，正是这个道理。那么：<br>
  事务的提交，是什么情况？<br>
  是父事务先提交，然后子事务提交，还是子事务先提交，父事务再提交？答案是第二种情况，还是那句话，子事务是父事务的一部分，由父事务统一提交。<br>
参考文章：<a href="https://blog.csdn.net/liangxw1/article/details/51197560">关于Spring事务的面试题</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 76. 最小覆盖子串[困难][未做出]]]></title>
        <id>https://lixin-scut.github.io//post/zi-fu-chuan-76-zui-xiao-fu-gai-zi-chuan-kun-nan-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/zi-fu-chuan-76-zui-xiao-fu-gai-zi-chuan-kun-nan-wei-zuo-chu">
        </link>
        <updated>2020-04-23T07:07:05.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。<br>
示例：<br>
输入: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot;<br>
输出: &quot;BANC&quot;<br>
说明：<br>
如果 S 中不存这样的子串，则返回空字符串 &quot;&quot;。<br>
如果 S 中存在这样的子串，我们保证它是唯一的答案。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/minimum-window-substring<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>第一想法是维持一个队列，不断地把所需的字母+其所处的位置 放入队列 ，然后每当遇到和队列头相同的元素的时候就出队列<br>
但是同时也需要更新队内的元素的下标，</p>
<p>然后第二想法就是记录更新每个所需字母的位置，然后用最大值减去最小值，但是同时需要检查是否已经满足条件 重复字符很麻烦。</p>
<p>最后第三个想法就是记录所有所需字母的下标，然后再按需计算（递归回溯等）</p>
<p>最后看了题解发现是hashmap + 双指针，确实把我的方法中的可行的部分提取出来+不可行的地方去除了。</p>
<pre><code>class Solution {
public:
    string minWindow(string s, string t) {
        
        unordered_map&lt;char, int&gt; letter_need;
        unordered_map&lt;char, int&gt; letter_get;
        for(auto c : t)
        {            
            ++letter_need[c];
        }
        
        int match = 0;
        int left = 0;
        int right = 0;
        char c = '\0';
        string ans = &quot;&quot;;
        while(right &lt; s.size())
        {     
            c = s[right];
            if(letter_need.count(c) == 1)
            {
                ++letter_get[c];
                if(letter_need[c] == letter_get[c])
                {
                    ++match;
                }
            }
            
            
            while(match == letter_need.size())
            {
                c = s[left];
                if(letter_need.count(c) == 1)
                {
                    --letter_get[c];
                    if(letter_get[c] &lt; letter_need[c])
                    {
                        --match;
                        string temp = s.substr(left, right - left + 1);
                        ans = (ans != &quot;&quot; &amp;&amp; ans.size() &lt; temp.size()) ? ans : temp;
                    }
                }
                ++left;
            }
            ++right;
        }
        
        return ans;
    }
};
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>题目不难理解，就是说要在 S(source) 中找到包含 T(target) 中全部字母的一个子串，顺序无所谓，但这个子串一定是所有可能子串中最短的。<br>
如果我们使用暴力解法，代码大概是这样的：</p>
</blockquote>
<pre><code>for (int i = 0; i &lt; s.size(); i++)
    for (int j = i + 1; j &lt; s.size(); j++)
        if s[i:j] 包含 t 的所有字母:
            更新答案
</code></pre>
<blockquote>
<p>思路很直接吧，但是显然，这个算法的复杂度肯定大于 O(N^2)了，不好。<br>
滑动窗口算法的思路是这样：<br>
1、我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引闭区间 [left, right] 称为一个「窗口」。<br>
2、我们先不断地增加 right 指针扩大窗口 [left, right]，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。<br>
3、此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。<br>
4、重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。<br>
这个思路其实也不难，第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。<br>
上述过程可以简单地写出如下伪码框架：</p>
</blockquote>
<pre><code>string s, t;
// 在 s 中寻找 t 的「最小覆盖子串」
int left = 0, right = 0;
string res = s;

while(right &lt; s.size()) {
    window.add(s[right]);
    right++;
    // 如果符合要求，移动 left 缩小窗口
    while (window 符合要求) {
        // 如果这个窗口的子串更短，则更新 res
        res = minLen(res, window);
        window.remove(s[left]);
        left++;
    }
}
return res;
</code></pre>
<blockquote>
<p>如果上述代码你也能够理解，那么你离解题更近了一步。现在就剩下一个比较棘手的问题：如何判断 window 即子串 s[left...right] 是否符合要求，是否包含 t 的所有字符呢？<br>
可以用两个哈希表当作计数器解决。用一个哈希表 needs 记录字符串 t 中包含的字符及出现次数，用另一个哈希表 window 记录当前「窗口」中包含的字符及出现的次数，如果 window 包含所有 needs 中的键，且这些键对应的值都大于等于 needs 中的值，那么就可以知道当前「窗口」符合要求了，可以开始移动 left 指针了。</p>
</blockquote>
<pre><code>string minWindow(string s, string t) {
    // 记录最短子串的开始位置和长度
    int start = 0, minLen = INT_MAX;
    int left = 0, right = 0;
    
    unordered_map&lt;char, int&gt; window;
    unordered_map&lt;char, int&gt; needs;
    for (char c : t) needs[c]++;
    
    int match = 0;
    
    while (right &lt; s.size()) {
        char c1 = s[right];
        if (needs.count(c1)) {
            window[c1]++;
            if (window[c1] == needs[c1]) 
                match++;
        }
        right++;
        
        while (match == needs.size()) {
            if (right - left &lt; minLen) {
                // 更新最小子串的位置和长度
                start = left;
                minLen = right - left;
            }
            char c2 = s[left];
            if (needs.count(c2)) {
                window[c2]--;
                if (window[c2] &lt; needs[c2])
                    match--;
            }
            left++;
        }
    }
    return minLen == INT_MAX ?
                &quot;&quot; : s.substr(start, minLen);
}

作者：labuladong
链接：https://leetcode-cn.com/problems/minimum-window-substring/solution/hua-dong-chuang-kou-suan-fa-tong-yong-si-xiang-by-/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<blockquote>
<p>这个算法的时间复杂度是 O(M+N)，M 和 N 分别是字符串 S 和 T 的长度。因为我们先用 for 循环遍历了字符串 T 来初始化 needs，时间 O(N)，之后的两个 while 循环最多执行2M 次，时间O(M)。<br>
读者也许认为嵌套的 while 循环复杂度应该是平方级，但是你这样想，while 执行的次数就是双指针 left 和 right 走的总路程，最多是 2M 嘛。</p>
</blockquote>
<blockquote>
<p>最后总结<br>
通过上面三道题，我们可以总结出滑动窗口算法的抽象思想：</p>
</blockquote>
<pre><code>int left = 0, right = 0;

while (right &lt; s.size()) {
    window.add(s[right]);
    right++;
    
    while (valid) {
        window.remove(s[left]);
        left++;
    }
}
</code></pre>
<blockquote>
<p>其中 window 的数据类型可以视具体情况而定，比如上述题目都使用哈希表充当计数器，当然你也可以用一个数组实现同样效果，因为我们只处理英文字母。<br>
稍微麻烦的地方就是这个 valid 条件，为了实现这个条件的实时更新，我们可能会写很多代码。比如前两道题，看起来解法篇幅那么长，实际上思想还是很简单，只是大多数代码都在处理这个问题而已。</p>
</blockquote>
<p>官方题解：</p>
<blockquote>
<p>方法一：滑动窗口<br>
思路<br>
本问题要求我们返回字符串 S 中包含字符串 T 的全部字符的最小窗口。我们称包含 T 的全部字母的窗口为 可行 窗口。<br>
可以用简单的滑动窗口法来解决本问题。<br>
在滑动窗口类型的问题中都会有两个指针。一个用于延伸现有窗口的 right 指针，和一个用于收缩窗口的 left 指针。在任意时刻，只有一个指针运动，而另一个保持静止。<br>
本题的解法很符合直觉。我们通过移动 right 指针不断扩张窗口。当窗口包含全部所需的字符后，如果能收缩，我们就收缩窗口直到得到最小窗口。<br>
答案就是最小的可行窗口。<br>
算法<br>
初始，left 指针和 right 指针都指向 S 的第一个元素.<br>
将 right 指针右移，扩张窗口，直到得到一个可行窗口，亦即包含 T 的全部字母的窗口。<br>
得到可行的窗口后，将 left 指针逐个右移，若得到的窗口依然可行，则更新最小窗口大小。<br>
若窗口不再可行，则跳转至 2 。</p>
</blockquote>
<pre><code>class Solution {
  public String minWindow(String s, String t) {

      if (s.length() == 0 || t.length() == 0) {
          return &quot;&quot;;
      }

      // Dictionary which keeps a count of all the unique characters in t.
      Map&lt;Character, Integer&gt; dictT = new HashMap&lt;Character, Integer&gt;();
      for (int i = 0; i &lt; t.length(); i++) {
          int count = dictT.getOrDefault(t.charAt(i), 0);
          dictT.put(t.charAt(i), count + 1);
      }

      // Number of unique characters in t, which need to be present in the desired window.
      int required = dictT.size();

      // Left and Right pointer
      int l = 0, r = 0;

      // formed is used to keep track of how many unique characters in t
      // are present in the current window in its desired frequency.
      // e.g. if t is &quot;AABC&quot; then the window must have two A's, one B and one C.
      // Thus formed would be = 3 when all these conditions are met.
      int formed = 0;

      // Dictionary which keeps a count of all the unique characters in the current window.
      Map&lt;Character, Integer&gt; windowCounts = new HashMap&lt;Character, Integer&gt;();

      // ans list of the form (window length, left, right)
      int[] ans = {-1, 0, 0};

      while (r &lt; s.length()) {
          // Add one character from the right to the window
          char c = s.charAt(r);
          int count = windowCounts.getOrDefault(c, 0);
          windowCounts.put(c, count + 1);

          // If the frequency of the current character added equals to the
          // desired count in t then increment the formed count by 1.
          if (dictT.containsKey(c) &amp;&amp; windowCounts.get(c).intValue() == dictT.get(c).intValue()) {
              formed++;
          }

          // Try and contract the window till the point where it ceases to be 'desirable'.
          while (l &lt;= r &amp;&amp; formed == required) {
              c = s.charAt(l);
              // Save the smallest window until now.
              if (ans[0] == -1 || r - l + 1 &lt; ans[0]) {
                  ans[0] = r - l + 1;
                  ans[1] = l;
                  ans[2] = r;
              }

              // The character at the position pointed by the
              // `Left` pointer is no longer a part of the window.
              windowCounts.put(c, windowCounts.get(c) - 1);
              if (dictT.containsKey(c) &amp;&amp; windowCounts.get(c).intValue() &lt; dictT.get(c).intValue()) {
                  formed--;
              }

              // Move the left pointer ahead, this would help to look for a new window.
              l++;
          }

          // Keep expanding the window once we are done contracting.
          r++;   
      }

      return ans[0] == -1 ? &quot;&quot; : s.substring(ans[1], ans[2] + 1);
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度: O(∣S∣+∣T∣)，其中 ∣S∣ 和 ∣T∣ 代表字符串 S 和 T 的长度。在最坏的情况下，可能会对 S 中的每个元素遍历两遍，左指针和右指针各一遍。<br>
空间复杂度: O(∣S∣+∣T∣)。当窗口大小等于 ∣S∣ 时为S 。当 ∣T∣ 包括全部唯一字符时为 T 。</p>
</blockquote>
<blockquote>
<p>方法二：优化滑动窗口<br>
思路<br>
对上一方法进行改进，可以将时间复杂度下降到 O(2∗∣filtered_S∣+∣S∣+∣T∣) ，其中 filtered_S 是从 S 中去除所有在 T 中不存在的元素后，得到的字符串。<br>
当 ∣filtered_S∣&lt;&lt;&lt;∣S∣ 时，优化效果显著。这种情况可能是由于 T 的长度远远小于 S ，因此 S 中包括大量 T 中不存在的字符。<br>
算法<br>
我们建立一个 filtered_S 列表，其中包括 S 中的全部字符以及它们在 S 的下标，但这些字符必须在 T 中出现。<br>
S = &quot;ABCDDDDDDEEAFFBC&quot; T = &quot;ABC&quot;<br>
filtered_S = [(0, 'A'), (1, 'B'), (2, 'C'), (11, 'A'), (14, 'B'), (15, 'C')]<br>
此处的 (0, 'A') 表示字符 'A' 在字符串 S 中的下标为 0 。<br>
现在我们可以在更短的字符串filtered_S 中使用滑动窗口法。</p>
</blockquote>
<pre><code>class Solution {
    public String minWindow(String s, String t) {

        if (s.length() == 0 || t.length() == 0) {
            return &quot;&quot;;
        }

        Map&lt;Character, Integer&gt; dictT = new HashMap&lt;Character, Integer&gt;();

        for (int i = 0; i &lt; t.length(); i++) {
            int count = dictT.getOrDefault(t.charAt(i), 0);
            dictT.put(t.charAt(i), count + 1);
        }

        int required = dictT.size();

        // Filter all the characters from s into a new list along with their index.
        // The filtering criteria is that the character should be present in t.
        List&lt;Pair&lt;Integer, Character&gt;&gt; filteredS = new ArrayList&lt;Pair&lt;Integer, Character&gt;&gt;();
        for (int i = 0; i &lt; s.length(); i++) {
            char c = s.charAt(i);
            if (dictT.containsKey(c)) {
                filteredS.add(new Pair&lt;Integer, Character&gt;(i, c));
            }
        }

        int l = 0, r = 0, formed = 0;
        Map&lt;Character, Integer&gt; windowCounts = new HashMap&lt;Character, Integer&gt;();  
        int[] ans = {-1, 0, 0};

        // Look for the characters only in the filtered list instead of entire s.
        // This helps to reduce our search.
        // Hence, we follow the sliding window approach on as small list.
        while (r &lt; filteredS.size()) {
            char c = filteredS.get(r).getValue();
            int count = windowCounts.getOrDefault(c, 0);
            windowCounts.put(c, count + 1);

            if (dictT.containsKey(c) &amp;&amp; windowCounts.get(c).intValue() == dictT.get(c).intValue()) {
                formed++;
            }

            // Try and contract the window till the point where it ceases to be 'desirable'.
            while (l &lt;= r &amp;&amp; formed == required) {
                c = filteredS.get(l).getValue();

                // Save the smallest window until now.
                int end = filteredS.get(r).getKey();
                int start = filteredS.get(l).getKey();
                if (ans[0] == -1 || end - start + 1 &lt; ans[0]) {
                    ans[0] = end - start + 1;
                    ans[1] = start;
                    ans[2] = end;
                }

                windowCounts.put(c, windowCounts.get(c) - 1);
                if (dictT.containsKey(c) &amp;&amp; windowCounts.get(c).intValue() &lt; dictT.get(c).intValue()) {
                    formed--;
                }
                l++;
            }
            r++;
        }
        return ans[0] == -1 ? &quot;&quot; : s.substring(ans[1], ans[2] + 1);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 : O(∣S∣+∣T∣)， 其中 ∣S∣ 和 ∣T∣ 分别代表字符串 S 和T 的长度。 本方法时间复杂度与方法一相同，但当 ∣filtered_S∣ &lt;&lt;&lt; ∣S∣ 时，复杂度会下降，因为此时迭代次数是 2∗∣filtered_S∣+∣S∣+∣T∣。<br>
空间复杂度 : O(∣S∣+∣T∣)。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 688. “马”在棋盘上的概率[中等]]]></title>
        <id>https://lixin-scut.github.io//post/dong-tai-gui-hua-688-ma-zai-qi-pan-shang-de-gai-lu-zhong-deng</id>
        <link href="https://lixin-scut.github.io//post/dong-tai-gui-hua-688-ma-zai-qi-pan-shang-de-gai-lu-zhong-deng">
        </link>
        <updated>2020-04-23T01:39:40.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>已知一个 NxN 的国际象棋棋盘，棋盘的行号和列号都是从 0 开始。即最左上角的格子记为 (0, 0)，最右下角的记为 (N-1, N-1)。 <br>
现有一个 “马”（也译作 “骑士”）位于 (r, c) ，并打算进行 K 次移动。 <br>
如下图所示，国际象棋的 “马” 每一步先沿水平或垂直方向移动 2 个格子，然后向与之相垂直的方向再移动 1 个格子，共有 8 个可选的位置。<br>
现在 “马” 每一步都从可选的位置（包括棋盘外部的）中独立随机地选择一个进行移动，直到移动了 K 次或跳到了棋盘外面。<br>
求移动结束后，“马” 仍留在棋盘上的概率。<br>
示例：<br>
输入: 3, 2, 0, 0<br>
输出: 0.0625<br>
解释:<br>
输入的数据依次为 N, K, r, c<br>
第 1 步时，有且只有 2 种走法令 “马” 可以留在棋盘上（跳到（1,2）或（2,1））。对于以上的两种情况，各自在第2步均有且只有2种走法令 “马” 仍然留在棋盘上。<br>
所以 “马” 在结束后仍在棋盘上的概率为 0.0625。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/knight-probability-in-chessboard<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>一开始的想法是存储每个格子的走K次的可能性,比如第一次、第二次、第三次每个格子的可能性<br>
然后实现中需要注意的点</p>
<ol>
<li>一开始很明显是用三维数组，但是我为了压缩空间+更明显地表现状态的变化，所以用上了二位数组</li>
<li>增加了4个外围概率，一定要初始化为0，并且不能计算概率</li>
<li>受第二点影响，所以循环应该起始于2，终止于N+2而不是N+4</li>
<li>概率之和要除以8</li>
</ol>
<pre><code>class Solution {
public:
    double knightProbability(int N, int K, int r, int c) {
        double ans = 0;
        
        vector&lt;vector&lt;double&gt;&gt; probability(N + 4, vector&lt;double&gt;(N + 4, 0));
        vector&lt;vector&lt;double&gt;&gt; temp(N + 4, vector&lt;double&gt;(N + 4, 0));
        probability[r + 2][c + 2] = 1;
        
        for(int k = 0; k &lt; K; ++k)
        {
            for(int i = 2; i &lt; N + 2; ++i)  // 注意限定范围是 N + 2
            {
                for(int j = 2; j &lt; N + 2; ++j)
                {
                    temp[i][j] = (probability[i - 1][j - 2] + probability[i - 2][j - 1]
                                + probability[i - 2][j + 1] + probability[i - 1][j + 2]
                                + probability[i + 1][j - 2] + probability[i + 2][j - 1]
                                + probability[i + 2][j + 1] + probability[i + 1][j + 2]) / 8;
                }
            }
            probability = temp;
        }
        for(int i = 2; i &lt; N + 2; ++i)
        {
                for(int j = 2; j &lt; N + 2; ++j)
                {
                    ans += probability[i][j];
                }
        }
        return ans;
    }
};
</code></pre>
<p>复杂度分析<br>
时间复杂度：<br>
O(KN^2)。其中 N,K 为题目中的定义。我们对 N^2 元素的每一层 dp 进行 O(1) 工作，并且考虑了 K 层。<br>
空间复杂度：O(N^2)，二维矩阵。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 56. 合并区间[中等]]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-56-he-bing-qu-jian-zhong-deng</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-56-he-bing-qu-jian-zhong-deng">
        </link>
        <updated>2020-04-22T02:08:49.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>给出一个区间的集合，请合并所有重叠的区间。<br>
示例 1:<br>
输入: [[1,3],[2,6],[8,10],[15,18]]<br>
输出: [[1,6],[8,10],[15,18]]<br>
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].<br>
示例 2:<br>
输入: [[1,4],[4,5]]<br>
输出: [[1,5]]<br>
解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/merge-intervals<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>看起来似乎是先排序后合并，只要前一个区间的右区间大于后一个区间的左区间，就需要合并</p>
<p>忽略了一个包含问题了</p>
<p>排序超时了hhh<br>
所以必须是一次遍历的？</p>
<p>看了题解发现不是的<br>
只是两个点</p>
<ol>
<li>sort可以进行vector的排序。。。就是类似于优先级排序</li>
<li>我一开始的循环符合条件，但是有重复的情况存在，加上排序就超时了</li>
</ol>
<p>实现中需要注意的点</p>
<ol>
<li>用空间换时间，一开始用vector的erase，需要进行元素搬移，很费时间</li>
<li>注意j的判断和大于等于的判断</li>
<li>注意i=j，而不能直接++i</li>
<li>最后我去掉了j，用temp来暂存</li>
</ol>
<pre><code>class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {
        if(intervals.empty())
        {   return intervals; }
        
        /*
        // out of time
        sort(intervals.begin(), intervals.end(), Solution());
        auto cur_vec = intervals.begin();
        while(cur_vec != intervals.end())
        {
            auto next_vec = cur_vec + 1;
            if(next_vec == intervals.end() || (*cur_vec)[1] &lt; (*next_vec)[0])
            {
                ++cur_vec;
            }
            else 
            {
                if((*cur_vec)[1] &lt; (*next_vec)[1])
                {
                    (*cur_vec)[1] = (*next_vec)[1];
                }
                intervals.erase(next_vec);
            }
        }
        */
        
        sort(intervals.begin(), intervals.end());
        vector&lt;vector&lt;int&gt;&gt; ans;
        for(int i = 0; i &lt;  intervals.size();)
        {
            vector&lt;int&gt; temp =  intervals[i];
            ++i;
            while(i &lt; intervals.size() &amp;&amp; temp[1] &gt;= intervals[i][0])
            {
                temp[1] = temp[1] &gt; intervals[i][1] ? temp[1] : intervals[i][1];
                ++i;
            }
            ans.push_back(temp);
        }
        
        return ans;
    }
    
    bool operator()(const vector&lt;int&gt;&amp; lhs, const vector&lt;int&gt;&amp; rhs) const
    {
        if(lhs[0] == rhs[0])
        {
            return lhs[1] &lt; rhs[1];
        }
        return lhs[0] &lt; rhs[0];
    }
};
</code></pre>
<p>官方题解</p>
<blockquote>
<p>方法：排序<br>
思路<br>
如果我们按照区间的左端点排序，那么在排完序的列表中，可以合并的区间一定是连续的。如下图所示，标记为蓝色、黄色和绿色的区间分别可以合并成一个大区间，它们在排完序的列表中是连续的：<br>
算法<br>
我们用数组 merged 存储最终的答案。<br>
首先，我们将列表中的区间按照左端点升序排序。然后我们将第一个区间加入 merged 数组中，并按顺序依次考虑之后的每个区间：<br>
如果当前区间的左端点在数组 merged 中最后一个区间的右端点之后，那么它们不会重合，我们可以直接将这个区间加入数组 merged 的末尾；<br>
否则，它们重合，我们需要用当前区间的右端点更新数组 merged 中最后一个区间的右端点，将其置为二者的较大值。</p>
</blockquote>
<pre><code>class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {
        if (intervals.size() == 0) {
            return {};
        }
        sort(intervals.begin(), intervals.end());
        vector&lt;vector&lt;int&gt;&gt; merged;
        for (int i = 0; i &lt; intervals.size(); ++i) {
            int L = intervals[i][0], R = intervals[i][1];
            if (!merged.size() || merged.back()[1] &lt; L) {
                merged.push_back({L, R});
            }
            else {
                merged.back()[1] = max(merged.back()[1], R);
            }
        }
        return merged;
    }
};

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/merge-intervals/solution/he-bing-qu-jian-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(nlogn)，其中 n 为区间的数量。除去排序的开销，我们只需要一次线性扫描，所以主要的时间开销是排序的 O(nlogn)。<br>
空间复杂度：O(logn)，其中 n 为区间的数量。这里计算的是存储答案之外，使用的额外空间。O(logn) 即为排序所需要的空间复杂度。</p>
</blockquote>
<p>网友题解</p>
<blockquote>
<p>解题思路<br>
我的方法思路很简单，很容易理解，一句话概括就是把这道题当成一个括号匹配的题：<br>
定义一个数组(box)，初始化每个元素为0用来记录匹配情况<br>
首先遍历输入，每个区间开始的值，在box下标对应的位置+1，每个区间结束的值，在box下标对应的地方-1<br>
然后遍历box(从0到区间所能到达的最大值，这个最大值可以在开始遍历的时候记录一下)，累加box[i]不是0的值，记录在cnt里面。如果到某个位置i的时候cnt为0，而box[i]不为0，这说明这是合并之后的区间中的一个开始的位置，用l记录这个位置，然后知道cnt有恢复到0，说明这个区间结束，用r记录当前位置，然后把l，r加到结果数组中。<br>
然后可能会有疑问，首尾相接的话，box里面对应的值不就是0了吗？对于这种情况，首尾相接的肯定要合并，对应的地方是0正合心意<br>
到这里，忽略了一种情况，区间里只有一个值的情况，即首尾相同的，如[[1,3][0,0]]<br>
这时候[0,0]这个区间就丢掉了…………<br>
迫不得已，又加了一个数组keng，来记录只有一个值的区间，然后，可算是通过了<br>
此方法的优缺点分析：<br>
优点：容易理解，不用排序，自带升序序列，速度在区间范围较小的情况下，要比排序快<br>
缺点：如果区间范围很大，如[0,10000]酱紫的，那可能就慢了。当然，辅助空间用的确实多…………</p>
</blockquote>
<pre><code>/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** merge(int** intervals, int intervalsSize, int* intervalsColSize, int* returnSize, int** returnColumnSizes){
    int box[10005];
    int keng[10005];
    int maxNum = 0;
    int l, r, cnt;
    returnSize[0] = 0;
    int **returnArr = (int**)calloc(intervalsSize, sizeof(int*));
    returnColumnSizes[0] = (int*)calloc(intervalsSize, sizeof(int));
    for(int i = 0; i &lt; intervalsSize; ++i) {
        returnArr[i] = (int*)calloc(2, sizeof(int));
        returnColumnSizes[0][i] = 2;
    }
    memset(box, 0, sizeof(box));
    memset(keng, 0, sizeof(keng));
    for(int i = 0; i &lt; intervalsSize; ++i) {
        if(box[intervals[i][0]] == box[intervals[i][1]]) {
            keng[intervals[i][0]] = 1;
        }
        ++box[intervals[i][0]];
        --box[intervals[i][1]];
        maxNum = maxNum &lt; intervals[i][1] ? intervals[i][1] : maxNum;
    }
    for(int i = 0; i &lt;= maxNum; ++i) {
        if(!box[i] &amp;&amp; keng[i] &amp;&amp; cnt == 0) {
            returnArr[returnSize[0]][0] = i;
            returnArr[returnSize[0]++][1] = i;
        }
        if(box[i]) {
            if(cnt == 0) {
                l = i;
            }
            cnt += box[i];
            if(cnt == 0) {
                r = i;
                returnArr[returnSize[0]][0] = l;
                returnArr[returnSize[0]++][1] = r;
            }
        }
    }
    return returnArr;
}

作者：hamiguaex163com
链接：https://leetcode-cn.com/problems/merge-intervals/solution/na-kong-jian-huan-shi-jian-er-qie-wo-mei-pai-xu-_-/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[哈希表 36. 有效的数独[中等][未做出]]]></title>
        <id>https://lixin-scut.github.io//post/ha-xi-biao-36-you-xiao-de-shu-du-zhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/ha-xi-biao-36-you-xiao-de-shu-du-zhong-deng-wei-zuo-chu">
        </link>
        <updated>2020-04-21T05:12:01.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。<br>
数字 1-9 在每一行只能出现一次。<br>
数字 1-9 在每一列只能出现一次。<br>
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。<br>
上图是一个部分填充的有效的数独。<br>
数独部分空格内已填入了数字，空白格用 '.' 表示。<br>
示例 1:<br>
输入:<br>
[<br>
[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],<br>
[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],<br>
[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],<br>
[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],<br>
[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],<br>
[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],<br>
[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],<br>
[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],<br>
[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]<br>
]<br>
输出: true<br>
示例 2:<br>
输入:<br>
[<br>
  [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],<br>
  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],<br>
  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],<br>
  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],<br>
  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],<br>
  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],<br>
  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],<br>
  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],<br>
  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]<br>
]<br>
输出: false<br>
解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。<br>
但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。<br>
说明:<br>
一个有效的数独（部分已被填充）不一定是可解的。<br>
只需要根据以上规则，验证已经填入的数字是否有效即可。<br>
给定数独序列只包含数字 1-9 和字符 '.' 。<br>
给定数独永远是 9x9 形式的。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/valid-sudoku<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>只想到了暴力法。。。<br>
然后发现官方题解也是优化版的暴力法。。。用空间换时间<br>
然后发现对3 * 3的格子定序号比较麻烦，首先要把行数化为3的倍数，然后再把列化为0、1、2，再相加<br>
实现需要注意的点</p>
<ol>
<li>非数字可以直接跳过</li>
<li>先使用相与判断是否有重复</li>
<li>然后可以直接插入</li>
</ol>
<p>最后的话还可以用bitset来降低空间复杂度</p>
<pre><code>class Solution {
public:
    // 数组版
    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) 
    {
        vector&lt;vector&lt;char&gt;&gt; row(9,vector&lt;char&gt;(9, 0));
        vector&lt;vector&lt;char&gt;&gt; col(9,vector&lt;char&gt;(9, 0));
        vector&lt;vector&lt;char&gt;&gt; box(9,vector&lt;char&gt;(9, 0));
        
        for(int i = 0; i &lt; 9; ++i)
        {
            for(int j = 0; j &lt; 9; ++j)
            {
                if(board[i][j] == '.')
                {   continue; }
                if(row[i][board[i][j] - '1'] == 1
                   || col[j][board[i][j] - '1'] == 1
                   || box[(i/3)*3 + j/3][board[i][j] - '1'] == 1)
                {   return false; }
                row[i][board[i][j] - '1'] = 1;
                col[j][board[i][j] - '1'] = 1;
                box[(i/3)*3 + j/3][board[i][j] - '1'] = 1;
            }
        }
        return true;
    }
    /*
    // 哈希表版
    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {
        vector&lt;set&lt;char&gt;&gt; row(9);
        vector&lt;set&lt;char&gt;&gt; col(9);
        vector&lt;set&lt;char&gt;&gt; box(9);
        
        for(int i = 0; i &lt; 9; ++i)
        {
            for(int j = 0; j &lt; 9; ++j)
            {
                if(board[i][j] == '.')
                {   continue; }
                if(row[i].count(board[i][j]) == 1
                   || col[j].count(board[i][j]) == 1
                   || box[(i/3)*3 + j/3].count(board[i][j]) == 1)
                {   return false; }
                row[i].insert(board[i][j]);
                col[j].insert(board[i][j]);
                box[(i/3)*3 + j/3].insert(board[i][j]);
            }
        }
        return true;
    }
    */
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>思路<br>
一个简单的解决方案是遍历该 9 x 9 数独 三 次，以确保：<br>
行中没有重复的数字。<br>
列中没有重复的数字。<br>
3 x 3 子数独内没有重复的数字。<br>
实际上，所有这一切都可以在一次迭代中完成。<br>
方法：一次迭代<br>
首先，让我们来讨论下面两个问题：<br>
如何枚举子数独？<br>
可以使用 box_index = (row / 3) * 3 + columns / 3，其中 / 是整数除法。<br>
如何确保行 / 列 / 子数独中没有重复项？<br>
可以利用 value -&gt; count 哈希映射来跟踪所有已经遇到的值。<br>
现在，我们完成了这个算法的所有准备工作：<br>
遍历数独。<br>
检查看到每个单元格值是否已经在当前的行 / 列 / 子数独中出现过：<br>
如果出现重复，返回 false。<br>
如果没有，则保留此值以进行进一步跟踪。<br>
返回 true。</p>
</blockquote>
<pre><code>class Solution {
  public boolean isValidSudoku(char[][] board) {
    // init data
    HashMap&lt;Integer, Integer&gt; [] rows = new HashMap[9];
    HashMap&lt;Integer, Integer&gt; [] columns = new HashMap[9];
    HashMap&lt;Integer, Integer&gt; [] boxes = new HashMap[9];
    for (int i = 0; i &lt; 9; i++) {
      rows[i] = new HashMap&lt;Integer, Integer&gt;();
      columns[i] = new HashMap&lt;Integer, Integer&gt;();
      boxes[i] = new HashMap&lt;Integer, Integer&gt;();
    }

    // validate a board
    for (int i = 0; i &lt; 9; i++) {
      for (int j = 0; j &lt; 9; j++) {
        char num = board[i][j];
        if (num != '.') {
          int n = (int)num;
          int box_index = (i / 3 ) * 3 + j / 3;

          // keep the current cell value
          rows[i].put(n, rows[i].getOrDefault(n, 0) + 1);
          columns[j].put(n, columns[j].getOrDefault(n, 0) + 1);
          boxes[box_index].put(n, boxes[box_index].getOrDefault(n, 0) + 1);

          // check if this value has been already seen before
          if (rows[i].get(n) &gt; 1 || columns[j].get(n) &gt; 1 || boxes[box_index].get(n) &gt; 1)
            return false;
        }
      }
    }

    return true;
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(1)，因为我们只对 81 个单元格进行了一次迭代。<br>
空间复杂度：O(1)。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 17. 电话号码的字母组合[中等]]]></title>
        <id>https://lixin-scut.github.io//post/zi-fu-chuan-17-dian-hua-hao-ma-de-zi-mu-zu-he-zhong-deng</id>
        <link href="https://lixin-scut.github.io//post/zi-fu-chuan-17-dian-hua-hao-ma-de-zi-mu-zu-he-zhong-deng">
        </link>
        <updated>2020-04-20T12:11:35.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。<br>
给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。<br>
示例:<br>
输入：&quot;23&quot;<br>
输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].<br>
说明:<br>
尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p>
</blockquote>
<p>首先的想法是回溯+递归<br>
实现中需要注意的点</p>
<ol>
<li>字符的转换很重要</li>
<li>本来以为每个字符循环三次，才发现7和9这两个奇葩，还是得好好看题。</li>
<li>所以必须用字符表了。。。。</li>
</ol>
<pre><code>class Solution {
public:
    vector&lt;string&gt; letterCombinations(string digits) {
        vector&lt;string&gt; res;
        if(digits.empty())
        {    return res; }
        
        string temp;
        letterCombinations(digits, 0, temp, res);
        return res;
    }
    
    void letterCombinations(const string&amp; digits, int num, string temp, vector&lt;string&gt;&amp; res)
    {
        if(num == digits.size())
        {
            res.push_back(temp);
            return;
        }
        string letter = letters[digits[num] - '2'];
        
        for(int i = 0; i &lt; letter.size(); ++i)
        {
            char c = letter[i];
            temp.push_back(c);
            letterCombinations(digits, num + 1, temp, res);
            temp.pop_back();
        }
        
    }
private:
    vector&lt;string&gt; letters {&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;};
    
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 3. 无重复字符的最长子串[中等]]]></title>
        <id>https://lixin-scut.github.io//post/zi-fu-chuan-3-wu-chong-fu-zi-fu-de-zui-chang-zi-chuan-zhong-deng</id>
        <link href="https://lixin-scut.github.io//post/zi-fu-chuan-3-wu-chong-fu-zi-fu-de-zui-chang-zi-chuan-zhong-deng">
        </link>
        <updated>2020-04-19T04:30:36.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。<br>
示例 1:<br>
输入: &quot;abcabcbb&quot;<br>
输出: 3<br>
解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。<br>
示例 2:<br>
输入: &quot;bbbbb&quot;<br>
输出: 1<br>
解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。<br>
示例 3:<br>
输入: &quot;pwwkew&quot;<br>
输出: 3<br>
解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。<br>
     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>hhh和剑指offer那题应该是一样的<br>
可以用一个固定数组记录当前字母上一次出现的位置，再对比当前不含重复字符串的长度，按照条件判断增加长度。</p>
<p>提交错了3次才发现是不止小写字母。。。</p>
<p>看了剑指offer发现这也是无意中实现了动态规划</p>
<p>实现中需要注意的</p>
<ol>
<li>注意题目描述是否是仅仅包含小写字母</li>
<li>变量初始化为0，配合返回空数组</li>
<li>固定数组初始化为-1，以免和第一个元素0冲突</li>
</ol>
<pre><code>class Solution {
public:
    int lengthOfLongestSubstring(string s) {

        vector&lt;int&gt; last_locate(128, -1);
        int cur_len = 0;
        int max_len = 0;
        for(int i = 0; i &lt; s.size(); ++i)
        {
            if(last_locate[s[i]] == -1)
            {
                ++cur_len;
                last_locate[s[i]] = i;
            }
            else
            {
                int distance = i - last_locate[s[i]];
                last_locate[s[i]] = i;
                if(distance &gt; cur_len)
                {
                    ++cur_len;
                }
                else
                {
                    cur_len = distance;
                }
            }
            max_len = max_len &gt; cur_len ? max_len : cur_len;
        }
        return max_len;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 面试题 02.01. 移除重复节点[简单]]]></title>
        <id>https://lixin-scut.github.io//post/lian-biao-mian-shi-ti-0201-yi-chu-chong-fu-jie-dian-jian-dan</id>
        <link href="https://lixin-scut.github.io//post/lian-biao-mian-shi-ti-0201-yi-chu-chong-fu-jie-dian-jian-dan">
        </link>
        <updated>2020-04-19T03:28:37.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。<br>
示例1:<br>
输入：[1, 2, 3, 3, 2, 1]<br>
输出：[1, 2, 3]<br>
示例2:<br>
输入：[1, 1, 1, 1, 2]<br>
输出：[1, 2]<br>
提示：<br>
链表长度在[0, 20000]范围内。<br>
链表元素在[0, 20000]范围内。<br>
进阶：<br>
如果不得使用临时缓冲区，该怎么解决？<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/remove-duplicate-node-lcci<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>如果是排序链表的话直接两个双指针就好，<br>
但是示例一有个问题是非排序+可重复的链表，所以很明显困难很多。<br>
我的第一想法还是哈希表，毕竟如果想去除所有重复元素的话还是得老老实实遍历<br>
看了一下提示确实如此<br>
然后进阶的话需要双指针，但双指针的方法太繁琐，时间复杂度是n^2 不值得实现</p>
<p>实现需要注意的点：变量命名很重要，我用了next_node，容易和节点的next冲突，容易出问题</p>
<pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    
    // hashset
    ListNode* removeDuplicateNodes(ListNode* head) {
        if(head == nullptr)
        {   return head; }
            
        unordered_set&lt;int&gt; value_set;
        ListNode* cur_node = head;
        ListNode* next_node = head-&gt;next;
        value_set.insert(cur_node-&gt;val);
        
        while(next_node != nullptr)
        {
            if(value_set.count(next_node-&gt;val) &gt; 0)
            {
                next_node = next_node-&gt;next;
            }
            else
            {
                cur_node-&gt;next = next_node;
                value_set.insert(next_node-&gt;val);
                cur_node = next_node;
                next_node = next_node-&gt;next;
            }
        }
        cur_node -&gt; next = nullptr;
        return head;
    }    
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库：索引]]></title>
        <id>https://lixin-scut.github.io//post/shu-ju-ku-suo-yin</id>
        <link href="https://lixin-scut.github.io//post/shu-ju-ku-suo-yin">
        </link>
        <updated>2020-04-18T03:38:36.000Z</updated>
        <content type="html"><![CDATA[<h3 id="索引概念">索引概念</h3>
<p>何为索引：<br>
  数据库索引，是数据库管理系统中一个排序的数据结构，索引的实现通常使用B树及其变种B+树。<br>
  在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p>
<h3 id="索引的作用">索引的作用</h3>
<p>索引作用是协助快速查询、更新数据库表中数据。<br>
但是同时为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。</p>
<h3 id="索引的优缺点">索引的优缺点</h3>
<p><strong>优点：</strong><br>
创建索引可以大大提高系统的性能：</p>
<ol>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
<li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li>
<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li>
<li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li>
<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li>
</ol>
<p><strong>缺点：</strong><br>
增加索引也有许多不利的方面：</p>
<ol>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li>
<li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li>
<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>
</ol>
<h3 id="适合与不适合使用索引的情形">适合与不适合使用索引的情形</h3>
<p>索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。</p>
<p><strong>一般来说，应该在这些列上创建索引：</strong><br>
（1）在<strong>经常需要搜索</strong>的列上，可以加快搜索的速度；<br>
（2）在作为主键的列上，强制该列的<strong>唯一性</strong>和组织表中数据的排列结构；<br>
（3）在<strong>经常用在连接</strong>的列上，这些列主要是一些外键，可以加快连接的速度；<br>
（4）在<strong>经常需要根据范围进行搜索</strong>的列上创建索引，因为索引已经排序，其指定的范围是连续的；<br>
（5）在<strong>经常需要排序的列上</strong>创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；<br>
（6）在<strong>经常使用在WHERE子句中</strong>的列上面创建索引，加快条件的判断速度。</p>
<p><strong>对于有些列不应该创建索引：</strong><br>
（1）对于那些在查询中<strong>很少使用或者参考的列</strong>不应该创建索引。<br>
  这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。<br>
（2）对于那些<strong>只有很少数据值的列</strong>也不应该增加索引。<br>
  这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。<br>
（3）对于那些<strong>定义为text, image和bit数据类型</strong>的列不应该增加索引。这是因为这些列的数据量要么相当大，要么取值很少。<br>
（4）当<strong>修改性能远远大于检索性能</strong>时，不应该创建索引。<br>
  这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</p>
<h3 id="什么样的字段适合建索引">什么样的字段适合建索引</h3>
<p>唯一、不为空、经常被查询的字段</p>
<h3 id="mysql-btree索引和hash索引的区别">MySQL B+Tree索引和Hash索引的区别?</h3>
<p><strong>Hash索引和B+树索引的特点：</strong></p>
<ol>
<li>
<p>Hash索引结构的特殊性，其<strong>检索效率非常高</strong>，索引的检索可以一次定位;</p>
</li>
<li>
<p>B+树索引需要<strong>从根节点到枝节点</strong>，最后才能访问到页节点这样多次的IO访问;</p>
</li>
</ol>
<p><strong>为什么不都用Hash索引而使用B+树索引？</strong></p>
<ol>
<li>
<p>Hash索引仅仅能满足&quot;=&quot;,&quot;IN&quot;和&quot;&quot;查询，<strong>不能使用范围查询</strong>,因为经过相应的Hash算法处理之后的Hash值的大小关系，并不能保证和Hash运算前完全一样；</p>
</li>
<li>
<p>Hash索引<strong>无法被用来进行数据的排序操作</strong>，因为Hash值的大小关系并不一定和Hash运算前的键值完全一样；</p>
</li>
<li>
<p>Hash索引<strong>不能利用部分索引键查询</strong>，对于组合索引，Hash索引在计算Hash值的时候是组合索引键合并后再一起计算Hash值，而不是单独计算Hash值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash索引也无法被利用；</p>
</li>
<li>
<p>Hash索引在任何时候都<strong>不能避免表扫描</strong>，由于不同索引键存在相同Hash值，所以即使取满足某个Hash键值的数据的记录条数，也无法从Hash索引中直接完成查询，还是要回表查询数据；</p>
</li>
<li>
<p>Hash索引<strong>遇到大量Hash值相等</strong>的情况后性能并不一定就会比B+树索引高。</p>
</li>
</ol>
<p>补充：</p>
<ol>
<li>MySQL中，只有HEAP/MEMORY引擎才显示支持Hash索引。</li>
<li>常用的InnoDB引擎中默认使用的是B+树索引，它会实时监控表上索引的使用情况，如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引（在InnoDB中默认开启自适应哈希索引），通过观察搜索模式，MySQL会利用index key的前缀建立哈希索引，如果一个表几乎大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。</li>
</ol>
<p>B+树索引和哈希索引的明显区别是：<br>
3. 如果是<strong>等值查询</strong>，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；<br>
4. 如果是<strong>范围查询检索</strong>，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；<br>
同理，哈希索引没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；<br>
5. 哈希索引也不支持多列联合索引的最左匹配规则；<br>
6. B+树索引的关键字<strong>检索效率比较平均</strong>，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。<br>
7. 在大多数场景下，都会有范围查询、排序、分组等查询特征，用B+树索引就可以了。</p>
<h3 id="b树和b树的区别">B树和B+树的区别</h3>
<ol>
<li>
<p>B树<br>
  <strong>每个节点都存储key和data</strong>，所有节点组成这棵树，并且<strong>叶子节点指针为nul</strong>，叶子结点不包含任何关键字信息。</p>
</li>
<li>
<p>B+树<br>
  <strong>所有的叶子结点中包含了全部关键字的信息</strong>，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接，<strong>所有的非终端结点可以看成是索引部分</strong>，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)</p>
</li>
</ol>
<h3 id="为什么说b比b树更适合实际应用中操作系统的文件索引和数据库索引">为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？</h3>
<ol>
<li>
<p>B+的磁盘读写代价更低<br>
  B+的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p>
</li>
<li>
<p>B+树的查询效率更加稳定<br>
  由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
</li>
</ol>
<h3 id="聚集索引和非聚集索引区别">聚集索引和非聚集索引区别?</h3>
<ol>
<li>
<p>聚合索引(clustered index):<br>
  聚集索<strong>引表记录的排列顺序和索引的排列顺序一致</strong>，所以查询效率快，只要找到第一个索引值记录，其余就连续性的记录在物理也一样连续存放。聚集索引对应的缺点就是修改慢，因为为了保证表中记录的物理和索引顺序一致，在记录插入的时候，会对数据页重新排序。<br>
  聚集索引类似于新华字典中用拼音去查找汉字，拼音检索表于书记顺序都是按照a~z排列的，就像相同的逻辑顺序于物理顺序一样，当你需要查找a,ai两个读音的字，或是想一次寻找多个傻(sha)的同音字时，也许向后翻几页，或紧接着下一行就得到结果了。</p>
</li>
<li>
<p>非聚合索引(nonclustered index):<br>
  非聚集索引<strong>指定了表中记录的逻辑顺序</strong>，但是<strong>记录的物理和索引不一定一致</strong>，两种索引<strong>都采用B+树结构</strong>，非聚集索引的叶子层并不和实际数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针方式。非聚集索引层次多，不会造成数据重排。<br>
  非聚集索引类似在新华字典上通过偏旁部首来查询汉字，检索表也许是按照横、竖、撇来排列的，但是由于正文中是a~z的拼音顺序，所以就类似于逻辑地址于物理地址的不对应。同时适用的情况就在于分组，大数目的不同值，频繁更新的列中，这些情况即不适合聚集索引。<br>
根本区别：<br>
  聚集索引和非聚集索引的根本区别是<strong>表记录的排列顺序和与索引的排列顺序是否一致</strong>。</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 面试题 01.09. 字符串轮转[简单][KMP]]]></title>
        <id>https://lixin-scut.github.io//post/zi-fu-chuan-mian-shi-ti-0109-zi-fu-chuan-lun-zhuan-jian-dan-kmp</id>
        <link href="https://lixin-scut.github.io//post/zi-fu-chuan-mian-shi-ti-0109-zi-fu-chuan-lun-zhuan-jian-dan-kmp">
        </link>
        <updated>2020-04-18T03:09:02.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>字符串轮转。给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成（比如，waterbottle是erbottlewat旋转后的字符串）。<br>
示例1:<br>
输入：s1 = &quot;waterbottle&quot;, s2 = &quot;erbottlewat&quot;<br>
输出：True<br>
示例2:<br>
输入：s1 = &quot;aa&quot;, &quot;aba&quot;<br>
输出：False<br>
提示：<br>
字符串长度在[0, 100000]范围内。<br>
说明:<br>
你能只调用一次检查子串的方法吗？<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/string-rotation-lcci<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>一开始理解错了，以为是整体旋转，原来是局部旋转。</p>
<p>卧槽提示很秀，<br>
首先可以视为寻找是否有一种方式可以把第一个字符串分成两部分，即x和y，如此一来，第一个字符串就是xy，第二个字符串就是yx。例如，x = wat，y = erbottle。那么，第一个字符串xy = waterbottle，第二个字符串yx = erbottlewat。</p>
<p>然后进一步地，如果将旋转后拼接起来，会发现一定会包含子串，转化为KMP字符串匹配问题</p>
<p>实现中注意的问题</p>
<ol>
<li>i和j的两次初始化不相同，nextval[0]的初始化为-1</li>
<li>然后特别重要的问题j &lt; (int)s2.size()，因为j可能设计-1，如果和size_t比较会强行转化为超级大的正数</li>
</ol>
<pre><code>class Solution {
public:
    bool isFlipedString(string s1, string s2) {
        
        if(s1.size() != s2.size())
        {   return false; }
        if(s1.empty() &amp;&amp; s2.empty())
        {   return true; }
        s1 += s1;
        vector&lt;int&gt; nextval(s2.size(),0);
        GetNextval(s2, nextval);
        int i = 0;
        int j = 0;
        while(i &lt; s1.size() &amp;&amp; j &lt; (int)s2.size())
        {
            if(j == -1 || s1[i] == s2[j] )
            {
                ++i;
                ++j;
            }
            else
            {
                j = nextval[j];
            }
        }
        if(j &gt;= s2.size())
        {
            return true;
        }
        else
        {
            return false;
    
        }
    }
      
    void GetNextval(const string&amp; s, vector&lt;int&gt;&amp; nextval)
    {
        int i = 0;
        int j = -1;
        nextval[0] = -1;
        while(i &lt; s.size() - 1)
        {
            if(j == -1 || s[i] == s[j])
            {
                ++i;
                ++j;
                if(s[i] != s[j])
                {
                    nextval[i] = j;
                }
                else
                {
                    nextval[i] = nextval[j];
                }
            }
            else
            {
                j = nextval[j];
            }
        }
    }
};
</code></pre>
]]></content>
    </entry>
</feed>