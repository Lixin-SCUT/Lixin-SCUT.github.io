<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-05-17T14:33:32.234Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>千里之行，始于足下。不积跬步，无以至千里。</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[OpenWrt使用SSH登陆]]></title>
        <id>https://lixin-scut.github.io//post/openwrt-shi-yong-ssh-deng-lu</id>
        <link href="https://lixin-scut.github.io//post/openwrt-shi-yong-ssh-deng-lu">
        </link>
        <updated>2020-05-17T13:56:30.000Z</updated>
        <content type="html"><![CDATA[<p>今晚在捣鼓电脑的时候发现网速突然非常慢了，就想看看连接到的每个设备的网速，OpenWrt的web后台管理界面中没有继承网速查看的软件包，必须通过SSH连接到路由器才能观看，所以只能先用终端连接路由器了<br>
命令非常简单：</p>
<pre><code>ssh -p 22 root@192.168.2.1
</code></pre>
<p>密码还是默认密码</p>
<p>但是报错：</p>
<pre><code>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the RSA key sent by the remote host is
SHA256:i4j9TxqQwiMWyaUIINlKARG4W/lBnxQv6KJ2y7cB5Sg.
Please contact your system administrator.
Add correct host key in /Users/lixin/.ssh/known_hosts to get rid of this message.
Offending ECDSA key in /Users/lixin/.ssh/known_hosts:5
RSA host key for 192.168.2.1 has changed and you have requested strict checking.
Host key verification failed.
</code></pre>
<p>一开始没有仔细看，以为是终端的问题<br>
查看了登陆OpenWrt的指南以为是必须要使用Putty等工具才能登陆<br>
查了好一阵子都没有结果<br>
然后看了一下路由器web后端有dropbear<br>
查阅dropbear相关博文<a href="http://blog.chinaunix.net/uid-11707862-id-5732715.html">无密码登陆ssh服务器(openwrt dropbear)笔记</a></p>
<blockquote>
<p>我用的平台是win32上的cygwin。<br>
先运行用ssh-keygen生成一对公密钥，密钥和公钥默认保存为</p>
</blockquote>
<pre><code>~/.ssh/id_rsa
~/.ssh/id_rsa.pub
</code></pre>
<blockquote>
<p>生成公密钥后，密钥不用动，放在原位置就可以，但要保管好（锁的钥匙要保管好呀.....)<br>
把密钥添加到openwrt的/ect/dropbear/authorized_keys就可以。<br>
之后在cygwin运行ssh root@openwrt.local就可以不用密码登陆了。<br>
密钥可以复制到手机上，之后导入connectbot中，之后设置好，connectbot同样不用密码就可以登陆openwrt了</p>
</blockquote>
<p>突然发现涉及到秘钥的问题，赶紧回头看一下<br>
仔细看了一下才发现是RSAkey的问题！<br>
所以赶紧查了一下错误，果然如此<br>
参考博文：<a href="https://www.xuebuyuan.com/602989.html">SSH连接时出现Host key verification failed的原因及解决方法</a></p>
<blockquote>
<p>用OpenSSH的人都知ssh会把你每个你访问过计算机的公钥(public key)都记录在~/.ssh/known_hosts。当下次访问相同计算机时，OpenSSH会核对公钥。如果公钥不同，OpenSSH会发出警告，避免你受到DNS Hijack之类的攻击。<br>
SSH对主机的public_key的检查等级是根据<br>
StrictHostKeyChecking变量来配置的。默认情况下，<br>
StrictHostKeyChecking=ask。简单所下它的三种配置值：</p>
</blockquote>
<ol>
<li></li>
</ol>
<p>StrictHostKeyChecking=no<br>
#最不安全的级别，当然也没有那么多烦人的提示了，相对安全的内网测试时建议使用。如果连接server的key在本地不存在，那么就自动添加到文件中（默认是known_hosts），并且给出一个警告。<br>
2.<br>
StrictHostKeyChecking=ask  #默认的级别，就是出现刚才的提示了。如果连接和key不匹配，给出提示，并拒绝登录。<br>
3.<br>
StrictHostKeyChecking=yes  #<br>
最安全的级别，如果连接与key不匹配，就拒绝连接，不会提示详细信息。</p>
<blockquote>
<p>－－－－－－－－－－－－－<br>
解决方法 1<br>
－－－－－－－－－－－－－<br>
对于我来说，在内网的进行的一些测试，为了方便，选择最低的安全级别。在.ssh/config（或者/etc/ssh/ssh_config）中配置：<br>
StrictHostKeyChecking no<br>
UserKnownHostsFile /dev/null<br>
（注：这里为了简便，将knownhostfile设为/dev/null，就不保存在known_hosts中了）</p>
</blockquote>
<blockquote>
<p>－－－－－－－－－－－－－－－<br>
解决方法 2<br>
－－－－－－－－－－－－－－－<br>
vi ~/.ssh/known_hosts<br>
删除对应ip的相关rsa信息</p>
</blockquote>
<blockquote>
<p>－－－－－－－－－－－－－－－<br>
解决方法 3<br>
－－－－－－－－－－－－－－－<br>
rm known_hosts</p>
</blockquote>
<p>作为一个学习过linux的人，当然是应该选择方法2了<br>
打开文件发现果然有四个默认秘钥，而且192.168.2.1赫然在目<br>
然后此时才想来，之前帮家里的k3路由器刷系统的时候就是用了SSH<br>
当时还登陆了SSH开启webUI中心，所以这个秘钥肯定就是k3遗留下来的历史问题了<br>
删除之后在进行SSH登陆OpenWrt，成功登陆！</p>
<p>然后就是安装网速查看软件，也是有小坑的，需要先更新软件列表</p>
<p>在openwrt安装iftop命令：</p>
<pre><code>#首先得更新软件清单才能安装软件，略蛋疼
opkg update
#安装iftop
opkg install iftop
</code></pre>
<p>然后运行命令</p>
<pre><code>iftop -i br-lan
</code></pre>
<p>大功告成！下次就可以看看是不是舍友的ipad占了过量的网速了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python - 异步IO]]></title>
        <id>https://lixin-scut.github.io//post/python-yi-bu-io</id>
        <link href="https://lixin-scut.github.io//post/python-yi-bu-io">
        </link>
        <updated>2020-05-13T14:20:50.000Z</updated>
        <content type="html"><![CDATA[<p>在IO编程一节中，我们已经知道，CPU的速度远远快于磁盘、网络等IO。在一个线程中，CPU执行代码的速度极快，然而，一旦遇到IO操作，如读写文件、发送网络数据时，就需要等待IO操作完成，才能继续进行下一步操作。这种情况称为同步IO。</p>
<p>在IO操作的过程中，当前线程被挂起，而其他需要CPU执行的代码就无法被当前线程执行了。</p>
<p>因为一个IO操作就阻塞了当前线程，导致其他代码无法执行，所以我们必须使用多线程或者多进程来并发执行代码，为多个用户服务。每个用户都会分配一个线程，如果遇到IO导致线程被挂起，其他用户的线程不受影响。</p>
<p>多线程和多进程的模型虽然解决了并发问题，但是系统不能无上限地增加线程。由于系统切换线程的开销也很大，所以，一旦线程数量过多，CPU的时间就花在线程切换上了，真正运行代码的时间就少了，结果导致性能严重下降。</p>
<p>由于我们要解决的问题是<strong>CPU高速执行能力和IO设备的龟速严重不匹配</strong>，多线程和多进程只是解决这一问题的一种方法。</p>
<p>另一种解决IO问题的方法是<strong>异步IO。当代码需要执行一个耗时的IO操作时，它只发出IO指令，并不等待IO结果，然后就去执行其他代码了</strong>。一段时间后，当<strong>IO返回结果时，再通知CPU进行处理</strong>。</p>
<p>可以想象如果按普通顺序写出的代码实际上是没法完成异步IO的：</p>
<pre><code>
do_some_code()
f = open('/path/to/file', 'r')
r = f.read() # &lt;== 线程停在此处等待IO操作结果
# IO操作完成后线程才能继续执行:
do_some_code(r)

</code></pre>
<p>所以，同步IO模型的代码是无法实现异步IO模型的。</p>
<p><strong>异步IO模型需要一个消息循环</strong>，在消息循环中，主线程<strong>不断地重复“读取消息-处理消息”这一过程</strong>：</p>
<pre><code>loop = get_event_loop()
while True:
    event = loop.get_event()
    process_event(event)
</code></pre>
<p>消息模型其实早在应用在桌面应用程序中了。一个GUI程序的主线程就负责不停地读取消息并处理消息。所有的键盘、鼠标等消息都被发送到GUI程序的消息队列中，然后由GUI程序的主线程处理。</p>
<p>由于GUI线程处理键盘、鼠标等消息的速度非常快，所以用户感觉不到延迟。某些时候，GUI线程在一个消息处理的过程中遇到问题导致一次消息处理时间过长，此时，用户会感觉到整个GUI程序停止响应了，敲键盘、点鼠标都没有反应。这种情况说明在消息模型中，处理一个消息必须非常迅速，否则，主线程将无法及时处理消息队列中的其他消息，导致程序看上去停止响应。</p>
<p>消息模型是如何解决同步IO必须等待IO操作这一问题的呢？</p>
<ol>
<li>当遇到IO操作时，代码<strong>只负责发出IO请求</strong>，不等待IO结果，然后<strong>直接结束本轮消息处理，进入下一轮消息处理过程</strong>。</li>
<li>当IO操作完成后，将<strong>收到一条“IO完成”的消息</strong>，<strong>处理该消息时就可以直接获取IO操作结果</strong>。</li>
</ol>
<p>在“发出IO请求”到收到“IO完成”的这段时间里，<strong>同步IO模型下，主线程只能挂起</strong>，但<strong>异步IO模型下，主线程并没有休息</strong>，而是在消息循环中继续处理其他消息。这样，在异步IO模型下，<strong>一个线程就可以同时处理多个IO请求</strong>，并且没有切换线程的操作。对于大多数IO密集型的应用程序，使用异步IO将大大提升系统的多任务处理能力。</p>
<h2 id="协程">协程</h2>
<p>在学习异步IO模型前，我们先来了解协程。</p>
<p>协程，又称微线程，纤程。英文名Coroutine。</p>
<p>协程的概念很早就提出来了，但直到最近几年才在某些语言（如Lua）中得到广泛应用。</p>
<p>子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。</p>
<p>所以<strong>子程序调用是通过栈实现的</strong>，一个线程就是执行一个子程序。</p>
<p>子程序调用总是一个入口，一次返回，<strong>调用顺序是明确的</strong>。</p>
<p>而<strong>协程的调用和子程序不同</strong>。</p>
<p>协程看上去也是子程序，但<strong>执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行</strong>。</p>
<p>注意，<strong>在一个子程序中中断，去执行其他子程序，不是函数调用，有点类似CPU的中断</strong>。比如子程序A、B：</p>
<pre><code>def A():
    print('1')
    print('2')
    print('3')

def B():
    print('x')
    print('y')
    print('z')
</code></pre>
<p>假设由协程执行，在执行A的过程中，可以随时中断，去执行B，B也可能在执行过程中中断再去执行A，结果可能是：</p>
<pre><code>1
2
x
y
3
z
</code></pre>
<p>但是在A中是没有调用B的，所以协程的调用比函数调用理解起来要难一些。</p>
<p>看起来A、B的执行有点像多线程，但<strong>协程的特点在于是一个线程执行</strong>，那和多线程比，协程有何优势？</p>
<p>最大的优势就是<strong>协程极高的执行效率</strong>。因为<strong>子程序切换不是线程切换</strong>，而是<strong>由程序自身控制</strong>，因此，<strong>没有线程切换的开销</strong>，和多线程比，线程<strong>数量越多，协程的性能优势就越明显</strong>。</p>
<p>第二大优势就是<strong>不需要多线程的锁机制</strong>，因为只有一个线程，也<strong>不存在同时写变量冲突</strong>，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p>
<p>因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是<strong>多进程+协程，既充分利用多核，又充分发挥协程的高效率</strong>，可获得极高的性能。</p>
<p>Python<strong>对协程的支持是通过generator实现的</strong>。</p>
<p>在generator中，我们不但可以<strong>通过for循环来迭代</strong>，还可以不断<strong>调用next()函数获取</strong>由<strong>yield语句返回的下一个值</strong>。</p>
<p>但是Python的<strong>yield不仅可以返回一个值</strong>，它<strong>还可以接收调用者发出的参数</strong>。</p>
<p>来看例子：</p>
<p>传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但一不小心就可能死锁。</p>
<p>如果改用协程，生产者生产消息后，直接通过yield跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高：</p>
<pre><code>def consumer():
    r = ''
    while True:
        n = yield r
        if not n:
            return
        print('[CONSUMER] Consuming %s...' % n)
        r = '200 OK'

def produce(c):
    c.send(None)
    n = 0
    while n &lt; 5:
        n = n + 1
        print('[PRODUCER] Producing %s...' % n)
        r = c.send(n)
        print('[PRODUCER] Consumer return: %s' % r)
    c.close()

c = consumer()
produce(c)
</code></pre>
<p>执行结果：</p>
<pre><code>[PRODUCER] Producing 1...
[CONSUMER] Consuming 1...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 2...
[CONSUMER] Consuming 2...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 3...
[CONSUMER] Consuming 3...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 4...
[CONSUMER] Consuming 4...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 5...
[CONSUMER] Consuming 5...
[PRODUCER] Consumer return: 200 OK
</code></pre>
<p>注意到<strong>consumer函数是一个generator</strong>，把一个consumer传入produce后：</p>
<ol>
<li>
<p>首先调用<strong>c.send(None)</strong> 启动生成器；</p>
</li>
<li>
<p>然后，一旦生产了东西，通过<strong>c.send(n)切换到consumer</strong>执行；</p>
</li>
<li>
<p><strong>consumer通过yield拿到消息</strong>，处理，<strong>又通过yield把结果传回</strong>；</p>
</li>
<li>
<p>produce拿到consumer处理的结果，<strong>继续生产下一条消息</strong>；</p>
</li>
<li>
<p>produce决定不生产了，<strong>通过c.close()关闭consumer</strong>，整个过程结束。</p>
</li>
</ol>
<p><strong>整个流程无锁，由一个线程执行，produce和consumer协作完成任务，所以称为“协程”，而非线程的抢占式多任务</strong>。</p>
<p>最后套用Donald Knuth的一句话总结协程的特点：</p>
<p><strong>“子程序就是协程的一种特例。”</strong></p>
<h2 id="asyncio-消息循环模型">asyncio-消息循环模型</h2>
<p>asyncio是Python 3.4版本引入的标准库，直接内置了对异步IO的支持。</p>
<p>asyncio的编程模型就是一个消息循环。我们从asyncio模块中直接获取一个EventLoop的引用，然后把需要执行的协程扔到EventLoop中执行，就实现了异步IO。</p>
<p>用asyncio实现Hello world代码如下：</p>
<pre><code>
import asyncio

@asyncio.coroutine
def hello():
    print(&quot;Hello world!&quot;)
    # 异步调用asyncio.sleep(1):
    r = yield from asyncio.sleep(1)
    print(&quot;Hello again!&quot;)

# 获取EventLoop:
loop = asyncio.get_event_loop()
# 执行coroutine
loop.run_until_complete(hello())
loop.close()

</code></pre>
<p>@asyncio.coroutine把一个generator标记为coroutine类型，然后，我们就把这个coroutine扔到EventLoop中执行。</p>
<p>hello()会首先打印出Hello world!，然后，yield from语法可以让我们方便地调用另一个generator。由于asyncio.sleep()也是一个coroutine，所以线程不会等待asyncio.sleep()，而是直接中断并执行下一个消息循环。当asyncio.sleep()返回时，线程就可以从yield from拿到返回值（此处是None），然后接着执行下一行语句。</p>
<p>把asyncio.sleep(1)看成是一个耗时1秒的IO操作，在此期间，主线程并未等待，而是去执行EventLoop中其他可以执行的coroutine了，因此可以实现并发执行。</p>
<p>我们用Task封装两个coroutine试试：</p>
<pre><code>
import threading
import asyncio

@asyncio.coroutine
def hello():
    print('Hello world! (%s)' % threading.currentThread())
    yield from asyncio.sleep(1)
    print('Hello again! (%s)' % threading.currentThread())

loop = asyncio.get_event_loop()
tasks = [hello(), hello()]
loop.run_until_complete(asyncio.wait(tasks))
loop.close()

</code></pre>
<p>观察执行过程：</p>
<pre><code>
Hello world! (&lt;_MainThread(MainThread, started 140735195337472)&gt;)
Hello world! (&lt;_MainThread(MainThread, started 140735195337472)&gt;)
(暂停约1秒)
Hello again! (&lt;_MainThread(MainThread, started 140735195337472)&gt;)
Hello again! (&lt;_MainThread(MainThread, started 140735195337472)&gt;)

</code></pre>
<p>由打印的当前线程名称可以看出，两个coroutine是由同一个线程并发执行的。</p>
<p>如果把asyncio.sleep()换成真正的IO操作，则多个coroutine就可以由一个线程并发执行。</p>
<p>我们用asyncio的异步网络连接来获取sina、sohu和163的网站首页：</p>
<pre><code>import asyncio

@asyncio.coroutine
def wget(host):
    print('wget %s...' % host)
    connect = asyncio.open_connection(host, 80)
    reader, writer = yield from connect
    header = 'GET / HTTP/1.0\r\nHost: %s\r\n\r\n' % host
    writer.write(header.encode('utf-8'))
    yield from writer.drain()
    while True:
        line = yield from reader.readline()
        if line == b'\r\n':
            break
        print('%s header &gt; %s' % (host, line.decode('utf-8').rstrip()))
    # Ignore the body, close the socket
    writer.close()

loop = asyncio.get_event_loop()
tasks = [wget(host) for host in ['www.sina.com.cn', 'www.sohu.com', 'www.163.com']]
loop.run_until_complete(asyncio.wait(tasks))
loop.close()
</code></pre>
<p>执行结果如下：</p>
<pre><code>wget www.sohu.com...
wget www.sina.com.cn...
wget www.163.com...
(等待一段时间)
(打印出sohu的header)
www.sohu.com header &gt; HTTP/1.1 200 OK
www.sohu.com header &gt; Content-Type: text/html
...
(打印出sina的header)
www.sina.com.cn header &gt; HTTP/1.1 200 OK
www.sina.com.cn header &gt; Date: Wed, 20 May 2015 04:56:33 GMT
...
(打印出163的header)
www.163.com header &gt; HTTP/1.0 302 Moved Temporarily
www.163.com header &gt; Server: Cdn Cache Server V2.0
...
</code></pre>
<p>可见3个连接由一个线程通过coroutine并发完成。</p>
<p><strong>小结</strong></p>
<p>asyncio提供了完善的异步IO支持；</p>
<p>异步操作需要在coroutine中通过yield from完成；</p>
<p>多个coroutine可以封装成一组Task然后并发执行。</p>
<h2 id="asyncawait">async/await</h2>
<p>用asyncio提供的@asyncio.coroutine可以把一个generator标记为coroutine类型，然后在coroutine内部用yield from调用另一个coroutine实现异步操作。</p>
<p>为了简化并更好地标识异步IO，从Python 3.5开始引入了新的语法async和await，可以让coroutine的代码更简洁易读。</p>
<p>请注意，async和await是针对coroutine的新语法，要使用新的语法，只需要做两步简单的替换：</p>
<p>把@asyncio.coroutine替换为async；<br>
把yield from替换为await。<br>
让我们对比一下上一节的代码：</p>
<pre><code>@asyncio.coroutine
def hello():
    print(&quot;Hello world!&quot;)
    r = yield from asyncio.sleep(1)
    print(&quot;Hello again!&quot;)
</code></pre>
<p>用新语法重新编写如下：</p>
<pre><code>async def hello():
    print(&quot;Hello world!&quot;)
    r = await asyncio.sleep(1)
    print(&quot;Hello again!&quot;)
</code></pre>
<p>剩下的代码保持不变。</p>
<p><strong>小结</strong></p>
<p>Python从3.5版本开始为asyncio提供了async和await的新语法；</p>
<p>注意新语法只能用在Python 3.5以及后续版本，如果使用3.4版本，则仍需使用上一节的方案。</p>
<h2 id="aiohttp">aiohttp</h2>
<p>asyncio可以实现单线程并发IO操作。如果仅用在客户端，发挥的威力不大。如果把asyncio用在服务器端，例如Web服务器，由于HTTP连接就是IO操作，因此可以用单线程+coroutine实现多用户的高并发支持。</p>
<p>asyncio实现了TCP、UDP、SSL等协议，aiohttp则是基于asyncio实现的HTTP框架。</p>
<p>我们先安装aiohttp：</p>
<pre><code>pip install aiohttp
</code></pre>
<p>然后编写一个HTTP服务器，分别处理以下URL：</p>
<ul>
<li>
<p><code>/</code> - 首页返回<code>b'&lt;h1&gt;Index&lt;/h1&gt;'</code>；</p>
</li>
<li>
<p><code>/hello/{name}</code>- 根据URL参数返回文本<code>hello, %s!</code>。</p>
</li>
</ul>
<p>代码如下：</p>
<pre><code>import asyncio

from aiohttp import web

async def index(request):
    await asyncio.sleep(0.5)
    return web.Response(body=b'&lt;h1&gt;Index&lt;/h1&gt;')

async def hello(request):
    await asyncio.sleep(0.5)
    text = '&lt;h1&gt;hello, %s!&lt;/h1&gt;' % request.match_info['name']
    return web.Response(body=text.encode('utf-8'))

async def init(loop):
    app = web.Application(loop=loop)
    app.router.add_route('GET', '/', index)
    app.router.add_route('GET', '/hello/{name}', hello)
    srv = await loop.create_server(app.make_handler(), '127.0.0.1', 8000)
    print('Server started at http://127.0.0.1:8000...')
    return srv

loop = asyncio.get_event_loop()
loop.run_until_complete(init(loop))
loop.run_forever()
</code></pre>
<p>注意aiohttp的初始化函数init()也是一个coroutine，loop.create_server()则利用asyncio创建TCP服务。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python - Web开发]]></title>
        <id>https://lixin-scut.github.io//post/python-web-kai-fa</id>
        <link href="https://lixin-scut.github.io//post/python-web-kai-fa">
        </link>
        <updated>2020-05-13T10:05:00.000Z</updated>
        <content type="html"><![CDATA[<p>最早的软件都是运行在大型机上的，软件使用者通过“哑终端”登陆到大型机上去运行软件。后来随着PC机的兴起，软件开始主要运行在桌面上，而数据库这样的软件运行在服务器端，这种<strong>Client/Server模式简称CS架构</strong>。</p>
<p>随着互联网的兴起，人们发现，CS架构不适合Web，最大的原因是Web应用程序的修改和升级非常迅速，而<strong>CS架构需要每个客户端逐个升级桌面App</strong>，因此，<strong>Browser/Server模式开始流行，简称BS架构</strong>。</p>
<p>在BS架构下，<strong>客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端</strong>。浏览器只需要请求服务器，获取Web页面，并把Web页面展示给用户即可。</p>
<p>当然，Web页面也具有极强的交互性。由于Web页面是用HTML编写的，而HTML具备超强的表现力，并且，<strong>服务器端升级后，客户端无需任何部署就可以使用到新的版本</strong>，因此，BS架构迅速流行起来。</p>
<p>今天，除了重量级的软件如Office，Photoshop等，大部分软件都以Web形式提供。比如，新浪提供的新闻、博客、微博等服务，均是Web应用。</p>
<p>Web应用开发可以说是目前软件开发中最重要的部分。Web开发也经历了好几个阶段：</p>
<p>静态Web页面：由文本编辑器直接编辑并生成静态的HTML页面，如果要修改Web页面的内容，就需要再次编辑HTML源文件，早期的互联网Web页面就是静态的；</p>
<p>CGI：由于静态Web页面无法与用户交互，比如用户填写了一个注册表单，静态Web页面就无法处理。要处理用户发送的动态数据，出现了Common Gateway Interface，简称CGI，用C/C++编写。</p>
<p>ASP/JSP/PHP：由于Web应用特点是修改频繁，用C/C++这样的低级语言非常不适合Web开发，而脚本语言由于开发效率高，与HTML结合紧密，因此，迅速取代了CGI模式。ASP是微软推出的用VBScript脚本编程的Web开发技术，而JSP用Java来编写脚本，PHP本身则是开源的脚本语言。</p>
<p>MVC：为了解决直接用脚本语言嵌入HTML导致的可维护性差的问题，Web应用也引入了<strong>Model-View-Controller的模式</strong>，来简化Web开发。ASP发展为ASP.Net，JSP和PHP也有一大堆MVC框架。</p>
<p>目前，Web开发技术仍在快速发展中，异步开发、新的MVVM前端技术层出不穷。</p>
<p>Python的诞生历史比Web还要早，由于Python是一种解释型的脚本语言，开发效率高，所以非常适合用来做Web开发。</p>
<p>Python有上百种Web开发框架，有很多成熟的模板技术，选择Python开发Web应用，不但开发效率高，而且运行速度快。</p>
<h2 id="http协议简介">HTTP协议简介</h2>
<p>在Web应用中，服务器把网页传给浏览器，实际上就是把网页的HTML代码发送给浏览器，让浏览器显示出来。而浏览器和服务器之间的传输协议是HTTP，所以：</p>
<ol>
<li>
<p><strong>HTML是一种用来定义网页的文本</strong>，会HTML，就可以<strong>编写网页</strong>；</p>
</li>
<li>
<p><strong>HTTP是在网络上传输HTML的协议</strong>，用于<strong>浏览器和服务器的通信</strong>。</p>
</li>
</ol>
<p>我们需要在浏览器很方便地调试我们的Web应用，而Chrome提供了一套完整地调试工具，非常适合Web开发。</p>
<p>安装好Chrome浏览器后，打开Chrome，在菜单中选择“视图”，“开发者”，“开发者工具”，就可以显示开发者工具<br>
Elements显示网页的结构，Network显示浏览器和服务器的通信。我们点Network，确保第一个小红灯亮着，Chrome就会记录所有浏览器和服务器之间的通信：<br>
当我们在地址栏输入<code>www.sina.com.cn</code>时，浏览器将显示新浪的首页。在这个过程中，浏览器都干了哪些事情呢？通过Network的记录，我们就可以知道。在Network中，定位到第一条记录，点击，右侧将显示Request Headers，点击右侧的view source，我们就可以看到浏览器发给新浪服务器的请求<br>
最主要的头两行分析如下，第一行：</p>
<pre><code>GET / HTTP/1.1
</code></pre>
<p>GET表示一个读取请求，将从服务器获得网页数据，/表示URL的路径，URL总是以/开头，/就表示首页，最后的HTTP/1.1指示采用的HTTP协议版本是1.1。目前HTTP协议的版本就是1.1，但是大部分服务器也支持1.0版本，主要区别在于1.1版本允许多个HTTP请求复用一个TCP连接，以加快传输速度。</p>
<p>从第二行开始，每一行都类似于<code>Xxx: abcdefg</code>：</p>
<pre><code>Host: www.sina.com.cn
</code></pre>
<p>表示请求的域名是<code>www.sina.com.cn</code>。如果一台服务器有多个网站，服务器就需要通过Host来区分浏览器请求的是哪个网站。</p>
<p>继续往下找到Response Headers，点击view source，显示服务器返回的原始响应数据</p>
<p>HTTP响应分为Header和Body两部分（Body是可选项），我们在Network中看到的Header最重要的几行如下：</p>
<pre><code>200 OK
</code></pre>
<p>200表示一个成功的响应，后面的OK是说明。失败的响应有404 Not Found：网页不存在，500 Internal Server Error：服务器内部出错，等等。</p>
<pre><code>Content-Type: text/html
</code></pre>
<p>Content-Type指示响应的内容，这里是text/html表示HTML网页。请注意，<strong>浏览器就是依靠Content-Type来判断响应的内容是网页还是图片，是视频还是音乐。</strong> 浏览器并不靠URL来判断响应的内容，所以，即使URL是<code>http://example.com/abc.jpg</code>，它也不一定就是图片。</p>
<p>HTTP响应的Body就是HTML源码，我们在菜单栏选择“视图”，“开发者”，“查看网页源码”就可以在浏览器中直接查看HTML源码</p>
<p>当浏览器读取到新浪首页的HTML源码后，它会解析HTML，显示页面，然后，根据HTML里面的各种链接，再发送HTTP请求给新浪服务器，拿到相应的图片、视频、Flash、JavaScript脚本、CSS等各种资源，最终显示出一个完整的页面。所以我们在Network下面能看到很多额外的HTTP请求。</p>
<h3 id="http请求">HTTP请求</h3>
<p>跟踪了新浪的首页，我们来总结一下HTTP请求的流程：</p>
<p>步骤1：浏览器首先向服务器发送HTTP请求，请求包括：</p>
<p>方法：GET还是POST，<strong>GET仅请求资源</strong>，<strong>POST会附带用户数据</strong>；</p>
<p>路径：<code>/full/url/path</code>；</p>
<p>域名：由Host头指定：<code>Host: www.sina.com.cn</code></p>
<p>以及其他相关的Header；</p>
<p>如果是POST，那么请求还包括一个Body，包含用户数据。</p>
<p>步骤2：服务器向浏览器返回HTTP响应，响应包括：</p>
<p>响应代码：200表示成功，3xx表示重定向，4xx表示客户端发送的请求有错误，5xx表示服务器端处理时发生了错误；</p>
<p>响应类型：<strong>由Content-Type指定</strong>，例如：Content-Type: text/html;charset=utf-8表示响应类型是HTML文本，并且编码是UTF-8，Content-Type: image/jpeg表示响应类型是JPEG格式的图片；</p>
<p>以及其他相关的Header；</p>
<p>通常服务器的HTTP响应会携带内容，也就是有一个<strong>Body，包含响应的内容，网页的HTML源码就在Body中</strong>。</p>
<p>步骤3：如果浏览器还需要继续向服务器请求其他资源，比如图片，就再次发出HTTP请求，重复步骤1、2。</p>
<p>Web采用的HTTP协议采用了非常简单的请求-响应模式，从而大大简化了开发。当我们编写一个页面时，我们只需要在HTTP响应中把HTML发送出去，不需要考虑如何附带图片、视频等，浏览器如果需要请求图片和视频，它会发送另一个HTTP请求，因此，一个HTTP请求只处理一个资源。</p>
<p>HTTP协议同时具备极强的扩展性，虽然<strong>浏览器请求</strong>的是<code>http://www.sina.com.cn/</code>的首页，但是新浪<strong>在HTML中可以链入其他服务器的资源（反向代理）</strong>，比如<code>&lt;img src=&quot;http://i1.sinaimg.cn/home/2013/1008/U8455P30DT20131008135420.png&quot;&gt;</code>，从而将请求压力分散到各个服务器上，并且，一个站点可以链接到其他站点，无数个站点互相链接起来，就形成了World Wide Web，简称“三达不溜”（WWW）。</p>
<h3 id="http格式">HTTP格式</h3>
<p>每个HTTP请求和响应都遵循相同的格式，一个HTTP包含Header和Body两部分，其中Body是可选的。</p>
<p>HTTP协议是一种文本协议，所以，它的格式也非常简单。HTTP GET请求的格式：</p>
<pre><code>GET /path HTTP/1.1
Header1: Value1
Header2: Value2
Header3: Value3
</code></pre>
<p><strong>每个Header一行一个，换行符是\r\n</strong>。</p>
<p>HTTP POST请求的格式：</p>
<pre><code>POST /path HTTP/1.1
Header1: Value1
Header2: Value2
Header3: Value3

body data goes here...
</code></pre>
<p>当<strong>遇到连续两个\r\n时，Header部分结束，后面的数据全部是Body</strong>。</p>
<p>HTTP响应的格式：</p>
<pre><code>200 OK
Header1: Value1
Header2: Value2
Header3: Value3

body data goes here...
</code></pre>
<p>HTTP响应<strong>如果包含body，也是通过\r\n\r\n来分隔的</strong>。请再次注意，<strong>Body的数据类型由Content-Type头来确定</strong>，如果是网页，Body就是文本，如果是图片，Body就是图片的二进制数据。</p>
<p><strong>当存在Content-Encoding时，Body数据是被压缩的，最常见的压缩方式是gzip</strong>，所以，看到Content-Encoding: gzip时，需要将Body数据先解压缩，才能得到真正的数据。压缩的目的在于减少Body的大小，加快网络传输。</p>
<h2 id="html简介">HTML简介</h2>
<p>网页就是HTML？这么理解大概没错。因为网页中不但包含文字，还有图片、视频、Flash小游戏，有复杂的排版、动画效果，所以，HTML定义了一套语法规则，来告诉浏览器如何把一个丰富多彩的页面显示出来。</p>
<p>最简单的HTML：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Hello&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1&gt;Hello, world!&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>可以用文本编辑器编写HTML，然后保存为hello.html，双击或者把文件拖到浏览器中</p>
<p>HTML文档就是一系列的Tag组成，最外层的Tag是<code>&lt;html&gt;</code>。规范的HTML也包含<code>&lt;head&gt;...&lt;/head&gt;</code>和<code>&lt;body&gt;...&lt;/body&gt;</code>（注意不要和HTTP的Header、Body搞混了），由于HTML是富文档模型，所以，还有一系列的Tag用来表示链接、图片、表格、表单等等。</p>
<h3 id="css简介">CSS简介</h3>
<p>CSS是<strong>Cascading Style Sheets（层叠样式表）</strong> 的简称，CSS用来<strong>控制HTML里的所有元素如何展现</strong>，比如，给标题元素<code>&lt;h1&gt;</code>加一个样式，变成48号字体，灰色，带阴影：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Hello&lt;/title&gt;
  &lt;style&gt;
    h1 {
      color: #333333;
      font-size: 48px;
      text-shadow: 3px 3px 3px #666666;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1&gt;Hello, world!&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="javascript简介">JavaScript简介</h3>
<p>JavaScript虽然名称有个Java，但它和Java真的一点关系没有。JavaScript是为了<strong>让HTML具有交互性而作为脚本语言添加的</strong>，JavaScript既可以内嵌到HTML中，也可以从外部链接到HTML中。如果我们希望当用户点击标题时把标题变成红色，就必须通过JavaScript来实现：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Hello&lt;/title&gt;
  &lt;style&gt;
    h1 {
      color: #333333;
      font-size: 48px;
      text-shadow: 3px 3px 3px #666666;
    }
  &lt;/style&gt;
  &lt;script&gt;
    function change() {
      document.getElementsByTagName('h1')[0].style.color = '#ff0000';
    }
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1 onclick=&quot;change()&quot;&gt;Hello, world!&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>小结</strong></p>
<p>如果要学习Web开发，首先要对HTML、CSS和JavaScript作一定的了解。HTML定义了页面的内容，CSS来控制页面元素的样式，而JavaScript负责页面的交互逻辑。</p>
<h2 id="wsgi接口">WSGI接口</h2>
<p>了解了HTTP协议和HTML文档，我们其实就明白了一个Web应用的本质就是：</p>
<ol>
<li>
<p>浏览器发送一个HTTP请求；</p>
</li>
<li>
<p>服务器收到请求，生成一个HTML文档；</p>
</li>
<li>
<p>服务器把HTML文档作为HTTP响应的Body发送给浏览器；</p>
</li>
<li>
<p>浏览器收到HTTP响应，从HTTP Body取出HTML文档并显示。</p>
</li>
</ol>
<p>所以，<strong>最简单的Web应用就是先把HTML用文件保存好，用一个现成的HTTP服务器软件，接收用户请求，从文件中读取HTML</strong>，返回。<strong>Apache、Nginx、Lighttpd</strong>等这些常见的<strong>静态服务器</strong>就是干这件事情的。</p>
<p>如果要动态生成HTML，就需要把上述步骤自己来实现。不过，接受HTTP请求、解析HTTP请求、发送HTTP响应都是苦力活，如果我们自己来写这些底层代码，还没开始写动态HTML呢，就得花个把月去读HTTP规范。</p>
<p>正确的做法是<strong>底层代码由专门的服务器软件实现，我们用Python专注于生成HTML文档</strong>。因为我们不希望接触到TCP连接、HTTP原始请求和响应格式，所以，<strong>需要一个统一的接口，让我们专心用Python编写Web业务</strong>。</p>
<p>这个接口就是<strong>WSGI：Web Server Gateway Interface</strong>。</p>
<p>WSGI接口定义非常简单，它只要求Web开发者<strong>实现一个函数，就可以响应HTTP请求</strong>。我们来看一个最简单的Web版本的“Hello, web!”：</p>
<pre><code>def application(environ, start_response):
    start_response('200 OK', [('Content-Type', 'text/html')])
    return [b'&lt;h1&gt;Hello, web!&lt;/h1&gt;']
</code></pre>
<p>上面的application()函数就是符合WSGI标准的一个HTTP处理函数，它接收两个参数：</p>
<ol>
<li>
<p>environ：一个<strong>包含所有HTTP请求信息的dict对象</strong>；</p>
</li>
<li>
<p>start_response：一个<strong>发送HTTP响应的函数</strong>。</p>
</li>
</ol>
<p>在application()函数中，调用：</p>
<pre><code>start_response('200 OK', [('Content-Type', 'text/html')])
</code></pre>
<p>就<strong>发送了HTTP响应的Header</strong>，注意Header只能发送一次，也就是只能调用一次start_response()函数。start_response()函数接收两个参数，一个是<strong>HTTP响应码</strong>，一个是一组list表示的<strong>HTTP Header</strong>，每个Header用一个包含两个str的tuple表示。</p>
<p>通常情况下，都应该把<strong>Content-Type头</strong>发送给浏览器。其他很多常用的HTTP Header也应该发送。</p>
<p>然后，函数的返回值<code>b'&lt;h1&gt;Hello, web!&lt;/h1&gt;'</code>将作为<strong>HTTP响应的Body</strong>发送给浏览器。</p>
<p>有了WSGI，我们关心的就是如何从environ这个dict对象拿到HTTP请求信息，然后构造HTML，通过start_response()发送Header，最后返回Body。</p>
<p>整个application()函数本身没有涉及到任何解析HTTP的部分，也就是说，底层代码不需要我们自己编写，我们只负责在更高层次上考虑如何响应请求就可以了。</p>
<p>不过这个application()函数怎么调用？如果我们自己调用，<strong>两个参数environ和start_response我们没法提供，返回的bytes也没法发给浏览器</strong>。</p>
<p>所以<strong>application()函数必须由WSGI服务器来调用</strong>。有很多符合WSGI规范的服务器，我们可以挑选一个来用。但是现在，我们只想尽快测试一下我们编写的application()函数真的可以把HTML输出到浏览器，所以需要赶紧找一个最简单的WSGI服务器，把我们的Web应用程序跑起来。</p>
<p>好消息是<strong>Python内置了一个WSGI服务器，这个模块叫wsgiref</strong>，它是用纯Python编写的WSGI服务器的参考实现。所谓“参考实现”是指该实现完全符合WSGI标准，但是<strong>不考虑任何运行效率，仅供开发和测试使用</strong>。</p>
<h3 id="运行wsgi服务">运行WSGI服务</h3>
<p>我们先编写hello.py，<strong>实现Web应用程序的WSGI处理函数</strong>：</p>
<pre><code>
# hello.py

def application(environ, start_response):
    start_response('200 OK', [('Content-Type', 'text/html')])
    return [b'&lt;h1&gt;Hello, web!&lt;/h1&gt;']
		
</code></pre>
<p>然后，再编写一个server.py，<strong>负责启动WSGI服务器，加载application()函数</strong>：</p>
<pre><code>
# server.py
# 从wsgiref模块导入:
from wsgiref.simple_server import make_server
# 导入我们自己编写的application函数:
from hello import application

# 创建一个服务器，IP地址为空，端口是8000，处理函数是application:
httpd = make_server('', 8000, application)
print('Serving HTTP on port 8000...')
# 开始监听HTTP请求:
httpd.serve_forever()

</code></pre>
<p>注意：如果8000端口已被其他程序占用，启动将失败，请修改成其他端口。</p>
<p>启动成功后，打开浏览器，输入<code>http://localhost:8000/</code>，就可以看到结果了：</p>
<p>在命令行可以看到wsgiref打印的log信息</p>
<p>按Ctrl+C终止服务器。</p>
<p>如果你觉得这个Web应用太简单了，可以稍微改造一下，从environ里读取PATH_INFO，这样可以显示更加动态的内容：</p>
<pre><code>
# hello.py

def application(environ, start_response):
    start_response('200 OK', [('Content-Type', 'text/html')])
    body = '&lt;h1&gt;Hello, %s!&lt;/h1&gt;' % (environ['PATH_INFO'][1:] or 'web')
    return [body.encode('utf-8')]
		
</code></pre>
<p>你可以在地址栏输入用户名作为URL的一部分，将返回Hello, xxx!：</p>
<h3 id="小结">小结</h3>
<p>无论多么复杂的Web应用程序，入口都是一个WSGI处理函数。HTTP请求的所有输入信息都可以通过environ获得，HTTP响应的输出都可以通过start_response()加上函数返回值作为Body。</p>
<p>复杂的Web应用程序，光靠一个WSGI函数来处理还是太底层了，我们需要在WSGI之上再抽象出Web框架，进一步简化Web开发。</p>
<h2 id="web框架">Web框架</h2>
<p>解了WSGI框架，我们发现：其实一个Web App，就是写一个WSGI的处理函数，针对每个HTTP请求进行响应。</p>
<p>但是如何处理HTTP请求不是问题，问题是如何处理100个不同的URL。</p>
<p><strong>每一个URL可以对应GET和POST请求，当然还有PUT、DELETE等请求</strong>，但是我们通常只考虑最常见的GET和POST请求。</p>
<p>一个最简单的想法是从environ变量里取出HTTP请求的信息，然后逐个判断：</p>
<pre><code>def application(environ, start_response):
    method = environ['REQUEST_METHOD']
    path = environ['PATH_INFO']
    if method=='GET' and path=='/':
        return handle_home(environ, start_response)
    if method=='POST' and path='/signin':
        return handle_signin(environ, start_response)
    ...
</code></pre>
<p>只是这么写下去代码是肯定没法维护了。</p>
<p>代码这么写没法维护的原因是因为WSGI提供的接口虽然比HTTP接口高级了不少，但和Web App的处理逻辑比，还是比较低级，我们<strong>需要在WSGI接口之上能进一步抽象，让我们专注于用一个函数处理一个URL，至于URL到函数的映射，就交给Web框架来做</strong>。</p>
<p>由于用Python开发一个Web框架十分容易，所以Python有上百个开源的Web框架。这里我们先不讨论各种Web框架的优缺点，直接选择一个<strong>比较流行的Web框架——Flask</strong>来使用。</p>
<p>用Flask框架编写Web App比WSGI接口简单，我们先用pip安装Flask：</p>
<pre><code>$ pip install flask
</code></pre>
<p>然后写一个app.py，<strong>处理3个URL</strong>，分别是：</p>
<ul>
<li>
<p>GET /：首页，返回Home；</p>
</li>
<li>
<p>GET /signin：登录页，显示登录表单；</p>
</li>
<li>
<p>POST /signin：处理登录表单，显示登录结果。</p>
</li>
</ul>
<p>注意噢，<strong>同一个URL/signin分别有GET和POST两种请求</strong>，映射到两个处理函数中。</p>
<p>Flask通过<strong>Python的装饰器</strong>在内部<strong>自动地把URL和函数给关联起来</strong>，所以，我们写出来的代码就像这样：</p>
<pre><code>from flask import Flask
from flask import request

app = Flask(__name__)

@app.route('/', methods=['GET', 'POST'])
def home():
    return '&lt;h1&gt;Home&lt;/h1&gt;'

@app.route('/signin', methods=['GET'])
def signin_form():
    return '''&lt;form action=&quot;/signin&quot; method=&quot;post&quot;&gt;
              &lt;p&gt;&lt;input name=&quot;username&quot;&gt;&lt;/p&gt;
              &lt;p&gt;&lt;input name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/p&gt;
              &lt;p&gt;&lt;button type=&quot;submit&quot;&gt;Sign In&lt;/button&gt;&lt;/p&gt;
              &lt;/form&gt;'''

@app.route('/signin', methods=['POST'])
def signin():
    # 需要从request对象读取表单内容：
    if request.form['username']=='admin' and request.form['password']=='password':
        return '&lt;h3&gt;Hello, admin!&lt;/h3&gt;'
    return '&lt;h3&gt;Bad username or password.&lt;/h3&gt;'

if __name__ == '__main__':
    app.run()
</code></pre>
<p>运行python app.py，Flask自带的Server在端口5000上监听：</p>
<pre><code>$ python app.py 
 * Running on http://127.0.0.1:5000/
</code></pre>
<p>GET /：打开浏览器，输入首页地址<code>http://localhost:5000/：</code><br>
首页显示Home则正确</p>
<p>GET /signin：再在浏览器地址栏输入<code>http://localhost:5000/signin</code>，会显示登录表单：</p>
<p>POST /signin：输入预设的用户名admin和口令password，登录成功：<br>
输入其他错误的用户名和口令，登录失败</p>
<p>实际的Web App应该拿到用户名和口令后，去数据库查询再比对，来判断用户是否能登录成功。</p>
<p>除了Flask，常见的Python Web框架还有：</p>
<ul>
<li>
<p>Django：全能型Web框架；</p>
</li>
<li>
<p>web.py：一个小巧的Web框架；</p>
</li>
<li>
<p>Bottle：和Flask类似的Web框架；</p>
</li>
<li>
<p>Tornado：Facebook的开源异步Web框架。</p>
</li>
</ul>
<p><strong>小结：</strong><br>
有了Web框架，我们在编写Web应用时，注意力就从WSGI处理函数转移到URL+对应的处理函数，这样，编写Web App就更加简单了。</p>
<p>在编写URL处理函数时，除了配置URL外，从HTTP请求拿到用户数据也是非常重要的。Web框架都提供了自己的API来实现这些功能。Flask通过<code>request.form['name']</code>来获取表单的内容。</p>
<h2 id="使用模板">使用模板</h2>
<p>Web框架把我们从WSGI中拯救出来了。现在，我们只需要不断地编写函数，带上URL，就可以继续Web App的开发了。</p>
<p>但是，Web App不仅仅是处理逻辑，展示给用户的页面也非常重要。在函数中返回一个包含HTML的字符串，简单的页面还可以，但是，想想新浪首页的6000多行的HTML</p>
<p>俗话说得好，不懂前端的Python工程师不是好的产品经理。有Web开发经验的同学都明白，Web App最复杂的部分就在HTML页面。HTML不仅要正确，还要通过CSS美化，再加上复杂的JavaScript脚本来实现各种交互和动画效果。总之，生成HTML页面的难度很大。</p>
<p>由于在Python代码里拼字符串是不现实的，所以，模板技术出现了。</p>
<h2 id="mvcmodel-view-controller">MVC：Model-View-Controller</h2>
<p>使用模板，我们需要预先准备一个HTML文档，这个HTML文档不是普通的HTML，而是嵌入了一些变量和指令，然后，根据我们传入的数据，替换后，得到最终的HTML，发送给用户：<br>
<img src="https://lixin-scut.github.io//post-images/1589379121294.png" alt=""></p>
<p>这就是传说中的<strong>MVC：Model-View-Controller，中文名“模型-视图-控制器”</strong>。</p>
<p><strong>Python处理URL的函数就是C：Controller</strong>，Controller负责<strong>业务逻辑</strong>，比如检查用户名是否存在，取出用户信息等等；</p>
<p><strong>包含变量{{ name }}的模板就是V：View</strong>，View负责<strong>显示逻辑</strong>，通过简单地替换一些变量，View最终输出的就是用户看到的HTML。</p>
<p>MVC中的Model在哪？<strong>Model是用来传给View的，这样View在替换变量的时候，就可以从Model中取出相应的数据。</strong></p>
<p>上面的例子中，Model就是一个dict：</p>
<pre><code>{ 'name': 'Michael' }
</code></pre>
<p>只是因为Python支持关键字参数，很多Web框架允许<strong>传入关键字参数，然后，在框架内部组装出一个dict作为Model</strong>。</p>
<p>现在，我们把上次直接输出字符串作为HTML的例子用高端大气上档次的MVC模式改写一下：</p>
<pre><code>from flask import Flask, request, render_template

app = Flask(__name__)

@app.route('/', methods=['GET', 'POST'])
def home():
    return render_template('home.html')

@app.route('/signin', methods=['GET'])
def signin_form():
    return render_template('form.html')

@app.route('/signin', methods=['POST'])
def signin():
    username = request.form['username']
    password = request.form['password']
    if username=='admin' and password=='password':
        return render_template('signin-ok.html', username=username)
    return render_template('form.html', message='Bad username or password', username=username)

if __name__ == '__main__':
    app.run()
</code></pre>
<p>Flask<strong>通过render_template()函数来实现模板的渲染</strong>。和Web框架类似，Python的模板也有很多种。Flask默认支持的模板是jinja2，所以我们先直接安装jinja2：</p>
<pre><code>$ pip install jinja2
</code></pre>
<p>然后，开始编写jinja2模板：</p>
<h3 id="homehtml">home.html</h3>
<p>用来显示首页的模板：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Home&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1 style=&quot;font-style:italic&quot;&gt;Home&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="formhtml">form.html</h3>
<p>用来显示登录表单的模板：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Please Sign In&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  {% if message %}
  &lt;p style=&quot;color:red&quot;&gt;{{ message }}&lt;/p&gt;
  {% endif %}
  &lt;form action=&quot;/signin&quot; method=&quot;post&quot;&gt;
    &lt;legend&gt;Please sign in:&lt;/legend&gt;
    &lt;p&gt;&lt;input name=&quot;username&quot; placeholder=&quot;Username&quot; value=&quot;{{ username }}&quot;&gt;&lt;/p&gt;
    &lt;p&gt;&lt;input name=&quot;password&quot; placeholder=&quot;Password&quot; type=&quot;password&quot;&gt;&lt;/p&gt;
    &lt;p&gt;&lt;button type=&quot;submit&quot;&gt;Sign In&lt;/button&gt;&lt;/p&gt;
  &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="signin-okhtml">signin-ok.html</h3>
<p>登录成功的模板：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Welcome, {{ username }}&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;p&gt;Welcome, {{ username }}!&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>登录失败的模板呢？我们在form.html中加了一点条件判断，把form.html重用为登录失败的模板。</p>
<p>最后，一定要把模板放到正确的templates目录下，templates和app.py在同级目录下，然后启动python app.py</p>
<p>通过MVC，我们<strong>在Python代码中处理M：Model和C：Controller</strong>，而V：View是通过模板处理的，这样，我们就成功地把Python代码和HTML代码最大限度地分离了。</p>
<p>使用模板的另一大好处是，<strong>模板改起来很方便</strong>，而且，改完保存后，刷新浏览器就能看到最新的效果，这对于调试HTML、CSS和JavaScript的前端工程师来说实在是太重要了。</p>
<p>在Jinja2模板中，我们<strong>用{{ name }}表示一个需要替换的变量。很多时候，还需要循环、条件判断等指令语句，在Jinja2中，用{% ... %}表示指令</strong>。</p>
<p>比如循环输出页码：</p>
<pre><code>{% for i in page_list %}
    &lt;a href=&quot;/page/{{ i }}&quot;&gt;{{ i }}&lt;/a&gt;
{% endfor %}
</code></pre>
<p>如果page_list是一个list：[1, 2, 3, 4, 5]，上面的模板将输出5个超链接。</p>
<p>除了Jinja2，常见的模板还有：</p>
<ul>
<li>
<p>Mako：用<code>&lt;% ... %&gt;</code>和<code>${xxx}</code>的一个模板；</p>
</li>
<li>
<p>Cheetah：也是用<code>&lt;% ... %&gt;</code>和<code>${xxx}</code>的一个模板；</p>
</li>
<li>
<p>Django：Django是一站式框架，内置一个用<code>{% ... %}</code>和<code>{{ xxx }}</code>的模板。</p>
</li>
</ul>
<p><strong>小结</strong></p>
<p>有了MVC，我们就分离了Python代码和HTML代码。HTML代码全部放到模板里，写起来更有效率。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python - 数据库]]></title>
        <id>https://lixin-scut.github.io//post/python-shu-ju-ku</id>
        <link href="https://lixin-scut.github.io//post/python-shu-ju-ku">
        </link>
        <updated>2020-05-13T08:56:56.000Z</updated>
        <content type="html"><![CDATA[<p>为了便于程序保存和读取数据，而且，能直接通过条件快速查询到指定的数据，就出现了数据库（Database）这种专门用于集中存储和查询的软件。</p>
<p>关系型数据库：两个表格有个映射关系，比如假设有两个表：Class表和Student表，根据班级idGrade_ID可以在班级表中查找到对应的所有班级，从而查询到这个班的所有学生信息，也就是Grade表的每一行对应Class表的多行，在关系数据库中，这种基于表（Table）的一对多的关系就是关系数据库的基础。</p>
<p>根据某个年级的ID就可以查找所有班级的行，这种查询语句在关系数据库中称为SQL语句，可以写成：</p>
<pre><code>SELECT * FROM classes WHERE grade_id = '1';
</code></pre>
<p>类似的，Class表的一行记录又可以关联到Student表的多行记录</p>
<h2 id="sqlite">SQLite</h2>
<p>SQLite是一种<strong>嵌入式数据库</strong>，它的<strong>数据库就是一个文件</strong>。由于SQLite本身是C写的，而且体积很小，所以，经常被集成到各种应用程序中，甚至在iOS和Android的App中都可以集成。</p>
<p><strong>Python就内置了SQLite3</strong>，所以，在Python中使用SQLite，不需要安装任何东西，直接使用。</p>
<p>在使用SQLite前，我们先要搞清楚几个概念：</p>
<p>表是数据库中<strong>存放关系数据的集合</strong>，一个数据库里面通常都包含多个表，比如学生的表，班级的表，学校的表，等等。<strong>表和表之间通过外键关联</strong>。</p>
<p>要操作<strong>关系数据库</strong>，首先需要连接到数据库，<strong>一个数据库连接称为Connection</strong>；</p>
<p>连接到数据库后，需要打开游标，称之为Cursor，通过Cursor执行SQL语句，然后，获得执行结果。</p>
<p>Python定义了一套操作数据库的API接口，任何数据库要连接到Python，只需要提供符合Python标准的数据库驱动即可。</p>
<p>由于SQLite的驱动内置在Python标准库中，所以我们可以直接来操作SQLite数据库。</p>
<p>我们在Python交互式命令行实践一下：</p>
<pre><code># 导入SQLite驱动:
&gt;&gt;&gt; import sqlite3
# 连接到SQLite数据库
# 数据库文件是test.db
# 如果文件不存在，会自动在当前目录创建:
&gt;&gt;&gt; conn = sqlite3.connect('test.db')
# 创建一个Cursor:
&gt;&gt;&gt; cursor = conn.cursor()
# 执行一条SQL语句，创建user表:
&gt;&gt;&gt; cursor.execute('create table user (id varchar(20) primary key, name varchar(20))')
&lt;sqlite3.Cursor object at 0x10f8aa260&gt;
# 继续执行一条SQL语句，插入一条记录:
&gt;&gt;&gt; cursor.execute('insert into user (id, name) values (\'1\', \'Michael\')')
&lt;sqlite3.Cursor object at 0x10f8aa260&gt;
# 通过rowcount获得插入的行数:
&gt;&gt;&gt; cursor.rowcount
1
# 关闭Cursor:
&gt;&gt;&gt; cursor.close()
# 提交事务:
&gt;&gt;&gt; conn.commit()
# 关闭Connection:
&gt;&gt;&gt; conn.close()
</code></pre>
<p>我们再试试查询记录：</p>
<pre><code>&gt;&gt;&gt; conn = sqlite3.connect('test.db')
&gt;&gt;&gt; cursor = conn.cursor()
# 执行查询语句:
&gt;&gt;&gt; cursor.execute('select * from user where id=?', ('1',))
&lt;sqlite3.Cursor object at 0x10f8aa340&gt;
# 获得查询结果集:
&gt;&gt;&gt; values = cursor.fetchall()
&gt;&gt;&gt; values
[('1', 'Michael')]
&gt;&gt;&gt; cursor.close()
&gt;&gt;&gt; conn.close()
</code></pre>
<p>使用Python的DB-API时，<strong>只要搞清楚Connection和Cursor对象，打开后一定记得关闭，就可以放心地使用</strong>。</p>
<p>使用Cursor对象执行<strong>insert，update，delete</strong>语句时，<strong>执行结果由rowcount返回影响的行数</strong>，就可以拿到执行结果。</p>
<p>使用Cursor对象执行<strong>select</strong>语句时，<strong>通过featchall()可以拿到结果集</strong>。结果集是一个<strong>list</strong>，每个元素都是一个<strong>tuple</strong>，对应一行记录。</p>
<p>如果SQL语句带有参数，那么需要<strong>把参数按照位置传递给execute()方法</strong>，有几个?占位符就必须对应几个参数，例如：</p>
<pre><code>cursor.execute('select * from user where name=? and pwd=?', ('abc', 'password'))
</code></pre>
<p>SQLite支持常见的标准SQL语句以及几种常见的数据类型。具体文档请参阅SQLite官方网站。</p>
<p><strong>小结</strong></p>
<p>在Python中操作数据库时，要<strong>先导入数据库对应的驱动</strong>，然后，<strong>通过Connection对象和Cursor对象操作数据</strong>。</p>
<p><strong>要确保打开的Connection对象和Cursor对象都正确地被关闭，否则，资源就会泄露。</strong></p>
<p>如何才能确保出错的情况下也关闭掉Connection对象和Cursor对象呢？请回忆try:...except:...finally:...的用法。</p>
<h2 id="mysql">MySQL</h2>
<p>MySQL是Web世界中使用最广泛的数据库服务器。SQLite的特点是轻量级、可嵌入，但<strong>不能承受高并发访问，适合桌面和移动应用</strong>。而MySQL是<strong>为服务器端设计的数据库，能承受高并发访问</strong>，同时占用的内存也远远大于SQLite。</p>
<p>此外，MySQL内部有多种数据库引擎，最常用的引擎是<strong>支持数据库事务</strong>的InnoDB。</p>
<h3 id="安装mysql">安装MySQL</h3>
<p>可以直接从MySQL官方网站下载最新的Community Server 5.6.x版本。MySQL是跨平台的，选择对应的平台下载安装文件，安装即可。</p>
<p>安装时，MySQL会提示输入root用户的口令，请务必记清楚。如果怕记不住，就把口令设置为password。</p>
<p>在Windows上，安装时请选择UTF-8编码，以便正确地处理中文。</p>
<p>在Mac或Linux上，需要编辑MySQL的配置文件，把数据库默认的编码全部改为UTF-8。MySQL的配置文件默认存放在<code>/etc/my.cnf</code>或者<code>/etc/mysql/my.cnf</code>：</p>
<pre><code>[client]
default-character-set = utf8

[mysqld]
default-storage-engine = INNODB
character-set-server = utf8
collation-server = utf8_general_ci
</code></pre>
<p>重启MySQL后，可以通过MySQL的客户端命令行检查编码：</p>
<pre><code>
$ mysql -u root -p
Enter password: 
Welcome to the MySQL monitor...
...

mysql&gt; show variables like '%char%';
+--------------------------+--------------------------------------------------------+
| Variable_name            | Value                                                  |
+--------------------------+--------------------------------------------------------+
| character_set_client     | utf8                                                   |
| character_set_connection | utf8                                                   |
| character_set_database   | utf8                                                   |
| character_set_filesystem | binary                                                 |
| character_set_results    | utf8                                                   |
| character_set_server     | utf8                                                   |
| character_set_system     | utf8                                                   |
| character_sets_dir       | /usr/local/mysql-5.1.65-osx10.6-x86_64/share/charsets/ |
+--------------------------+--------------------------------------------------------+
8 rows in set (0.00 sec)
</code></pre>
<p>看到utf8字样就表示编码设置正确。</p>
<p>注：如果MySQL的版本≥5.5.3，可以把编码设置为utf8mb4，utf8mb4和utf8完全兼容，但它支持最新的Unicode标准，可以显示emoji字符。</p>
<h3 id="安装mysql驱动">安装MySQL驱动</h3>
<p>由于MySQL服务器以独立的进程运行，并通过网络对外服务，所以，需要支持Python的MySQL驱动来连接到MySQL服务器。MySQL官方提供了mysql-connector-python驱动，但是安装的时候需要给pip命令加上参数<code>--allow-external</code>：</p>
<pre><code>$ pip install mysql-connector-python --allow-external mysql-connector-python
</code></pre>
<p>如果上面的命令安装失败，可以试试另一个驱动：</p>
<pre><code>$ pip install mysql-connector
</code></pre>
<p>我们演示如何连接到MySQL服务器的test数据库：</p>
<pre><code>
# 导入MySQL驱动:
&gt;&gt;&gt; import mysql.connector
# 注意把password设为你的root口令:
&gt;&gt;&gt; conn = mysql.connector.connect(user='root', password='password', database='test')
&gt;&gt;&gt; cursor = conn.cursor()
# 创建user表:
&gt;&gt;&gt; cursor.execute('create table user (id varchar(20) primary key, name varchar(20))')
# 插入一行记录，注意MySQL的占位符是%s:
&gt;&gt;&gt; cursor.execute('insert into user (id, name) values (%s, %s)', ['1', 'Michael'])
&gt;&gt;&gt; cursor.rowcount
1
# 提交事务:
&gt;&gt;&gt; conn.commit()
&gt;&gt;&gt; cursor.close()
# 运行查询:
&gt;&gt;&gt; cursor = conn.cursor()
&gt;&gt;&gt; cursor.execute('select * from user where id = %s', ('1',))
&gt;&gt;&gt; values = cursor.fetchall()
&gt;&gt;&gt; values
[('1', 'Michael')]
# 关闭Cursor和Connection:
&gt;&gt;&gt; cursor.close()
True
&gt;&gt;&gt; conn.close()
由于Python的DB-API定义都是通用的，所以，操作MySQL的数据库代码和SQLite类似。
</code></pre>
<p><strong>小结</strong></p>
<ol>
<li>
<p>执行INSERT等操作后要调用<code>commit()</code>提交事务；</p>
</li>
<li>
<p>MySQL的SQL占位符是<code>%s</code>。</p>
</li>
</ol>
<h2 id="sqlalchemy">SQLAlchemy</h2>
<p>数据库表是一个二维表，包含多行多列。把一个表的内容用Python的数据结构表示出来的话，可以<strong>用一个list表示多行</strong>，<strong>list的每一个元素是tuple</strong>，表示一行记录，比如，包含id和name的user表：</p>
<pre><code>[
    ('1', 'Michael'),
    ('2', 'Bob'),
    ('3', 'Adam')
]
</code></pre>
<p>Python的DB-API返回的数据结构就是像上面这样表示的。</p>
<p><strong>但是用tuple表示一行很难看出表的结构</strong>。如果把一个tupl<strong>e用class实例来表示</strong>，就可以更容易地看出表的结构来：</p>
<pre><code>class User(object):
    def __init__(self, id, name):
        self.id = id
        self.name = name

[
    User('1', 'Michael'),
    User('2', 'Bob'),
    User('3', 'Adam')
]
</code></pre>
<p>这就是传说中的ORM技术：Object-Relational Mapping，把关系数据库的表结构映射到对象上。是不是很简单？</p>
<p>但是由谁来做这个转换呢？所以ORM框架应运而生。</p>
<p>在Python中，最有名的ORM框架是SQLAlchemy。我们来看看SQLAlchemy的用法。</p>
<p>首先通过pip安装SQLAlchemy：</p>
<pre><code>$ pip install sqlalchemy
</code></pre>
<p>然后，利用上次我们在MySQL的test数据库中创建的user表，用SQLAlchemy来试试：</p>
<p>第一步，导入SQLAlchemy，并初始化DBSession：</p>
<pre><code>
# 导入:
from sqlalchemy import Column, String, create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base

# 创建对象的基类:
Base = declarative_base()

# 定义User对象:
class User(Base):
    # 表的名字:
    __tablename__ = 'user'

    # 表的结构:
    id = Column(String(20), primary_key=True)
    name = Column(String(20))

# 初始化数据库连接:
engine = create_engine('mysql+mysqlconnector://root:password@localhost:3306/test')
# 创建DBSession类型:
DBSession = sessionmaker(bind=engine)

</code></pre>
<p>以上代码完成SQLAlchemy的初始化和具体每个表的class定义。如果有多个表，就继续定义其他class，例如School：</p>
<pre><code>class School(Base):
    __tablename__ = 'school'
    id = ...
    name = ...
</code></pre>
<p>create_engine()用来初始化数据库连接。SQLAlchemy用一个字符串表示连接信息：</p>
<pre><code>'数据库类型+数据库驱动名称://用户名:口令@机器地址:端口号/数据库名'
</code></pre>
<p>你只需要根据需要替换掉用户名、口令等信息即可。</p>
<p>下面，我们看看如何向数据库表中添加一行记录。</p>
<p>由于有了ORM，我们向数据库表中添加一行记录，可以视为添加一个User对象：</p>
<pre><code>
# 创建session对象:
session = DBSession()
# 创建新User对象:
new_user = User(id='5', name='Bob')
# 添加到session:
session.add(new_user)
# 提交即保存到数据库:
session.commit()
# 关闭session:
session.close()

</code></pre>
<p>可见，关<strong>键是获取session，然后把对象添加到session，最后提交并关闭。DBSession对象可视为当前数据库连接</strong>。</p>
<p>如何从数据库表中查询数据呢？<strong>有了ORM，查询出来的可以不再是tuple，而是User对象</strong>。SQLAlchemy提供的查询接口如下：</p>
<pre><code># 创建Session:
session = DBSession()
# 创建Query查询，filter是where条件，最后调用one()返回唯一行，如果调用all()则返回所有行:
user = session.query(User).filter(User.id=='5').one()
# 打印类型和对象的name属性:
print('type:', type(user))
print('name:', user.name)
# 关闭Session:
session.close()
</code></pre>
<p>运行结果如下：</p>
<pre><code>type: &lt;class '__main__.User'&gt;
name: Bob
</code></pre>
<p>可见，ORM就是把数据库表的行与相应的对象建立关联，互相转换。</p>
<p>由于关系数据库的<strong>多个表还可以用外键实现一对多、多对多等关联</strong>，相应地，ORM框架也可以<strong>提供两个对象之间的一对多、多对多等功能</strong>。</p>
<p>例如，如果一个User拥有多个Book，就可以定义一对多关系如下：</p>
<pre><code>class User(Base):
    __tablename__ = 'user'

    id = Column(String(20), primary_key=True)
    name = Column(String(20))
    # 一对多:
    books = relationship('Book')

class Book(Base):
    __tablename__ = 'book'

    id = Column(String(20), primary_key=True)
    name = Column(String(20))
    # “多”的一方的book表是通过外键关联到user表的:
    user_id = Column(String(20), ForeignKey('user.id'))
</code></pre>
<p>当我们<strong>查询一个User对象时，该对象的books属性将返回一个包含若干个Book对象的list</strong>。</p>
<p><strong>小结</strong></p>
<p>ORM框架的作用就是把数据库表的一行记录与一个对象互相做自动转换。</p>
<p>正确使用ORM的前提是了解关系数据库的原理。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python - 网络编程	]]></title>
        <id>https://lixin-scut.github.io//post/python-wang-luo-bian-cheng</id>
        <link href="https://lixin-scut.github.io//post/python-wang-luo-bian-cheng">
        </link>
        <updated>2020-05-13T08:21:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="tcpip简介">TCP/IP简介</h2>
<p>虽然大家现在对互联网很熟悉，但是计算机网络的出现比互联网要早很多。</p>
<p>计算机为了联网，就必须规定通信协议，早期的计算机网络，都是由各厂商自己规定一套协议，IBM、Apple和Microsoft都有各自的网络协议，互不兼容，这就好比一群人有的说英语，有的说中文，有的说德语，说同一种语言的人可以交流，不同的语言之间就不行了。</p>
<p>为了把全世界的所有不同类型的计算机都连接起来，就必须规定一套全球通用的协议，为了实现互联网这个目标，互联网协议簇（Internet Protocol Suite）就是通用协议标准。Internet是由inter和net两个单词组合起来的，原意就是连接“网络”的网络，有了Internet，任何私有网络，只要支持这个协议，就可以联入互联网。</p>
<p>因为互联网协议包含了上百种协议标准，但是最重要的两个协议是TCP和IP协议，所以，大家把互联网的协议简称TCP/IP协议。</p>
<p>通信的时候，双方必须知道对方的标识，好比发邮件必须知道对方的邮件地址。互联网上每个计算机的唯一标识就是IP地址，类似123.123.123.123。如果一台计算机同时接入到两个或更多的网络，比如路由器，它就会有两个或多个IP地址，所以，IP地址对应的实际上是计算机的网络接口，通常是网卡。</p>
<p>IP协议负责把数据从一台计算机通过网络发送到另一台计算机。数据被分割成一小块一小块，然后通过IP包发送出去。由于互联网链路复杂，两台计算机之间经常有多条线路，因此，路由器就负责决定如何把一个IP包转发出去。IP包的特点是按块发送，途径多个路由，但不保证能到达，也不保证顺序到达。</p>
<p>P地址实际上是一个32位整数（称为IPv4），以字符串表示的IP地址如192.168.0.1实际上是把32位整数按8位分组后的数字表示，目的是便于阅读。</p>
<p>IPv6地址实际上是一个128位整数，它是目前使用的IPv4的升级版，以字符串表示类似于<code>2001:0db8:85a3:0042:1000:8a2e:0370:7334</code>。</p>
<p>TCP协议则是建立在IP协议之上的。TCP协议负责在两台计算机之间建立可靠连接，保证数据包按顺序到达。TCP协议会通过握手建立连接，然后，对每个IP包编号，确保对方按顺序收到，如果包丢掉了，就自动重发。</p>
<p>许多常用的更高级的协议都是建立在TCP协议基础上的，比如用于浏览器的HTTP协议、发送邮件的SMTP协议等。</p>
<p>一个TCP报文除了包含要传输的数据外，还包含源IP地址和目标IP地址，源端口和目标端口。</p>
<p>端口有什么作用？在两台计算机通信时，只发IP地址是不够的，因为同一台计算机上跑着多个网络程序。一个TCP报文来了之后，到底是交给浏览器还是QQ，就需要端口号来区分。每个网络程序都向操作系统申请唯一的端口号，这样，两个进程在两台计算机之间建立网络连接就需要各自的IP地址和各自的端口号。</p>
<p>一个进程也可能同时与多个计算机建立链接，因此它会申请很多端口。</p>
<h2 id="tcp编程">TCP编程</h2>
<p>Socket是网络编程的一个抽象概念。通常我们用一个Socket表示“打开了一个网络链接”，而打开一个Socket需要知道目标计算机的IP地址和端口号，再指定协议类型即可。</p>
<h3 id="客户端">客户端</h3>
<p>大多数连接都是可靠的TCP连接。创建TCP连接时，主动发起连接的叫客户端，被动响应连接的叫服务器。</p>
<p>举个例子，当我们在浏览器中访问新浪时，我们自己的计算机就是客户端，浏览器会主动向新浪的服务器发起连接。如果一切顺利，新浪的服务器接受了我们的连接，一个TCP连接就建立起来的，后面的通信就是发送网页内容了。</p>
<p>所以，我们要创建一个基于TCP连接的Socket，可以这样做：</p>
<pre><code>
# 导入socket库:
import socket

# 创建一个socket:
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# 建立连接:
s.connect(('www.sina.com.cn', 80))

</code></pre>
<p>创建Socket时，AF_INET指定使用IPv4协议，如果要用更先进的IPv6，就指定为AF_INET6。SOCK_STREAM指定使用面向流的TCP协议，这样，一个Socket对象就创建成功，但是还没有建立连接。</p>
<p>客户端要主动发起TCP连接，必须知道服务器的IP地址和端口号。新浪网站的IP地址可以用域名<code>www.sina.com.cn</code>自动转换到IP地址，但是怎么知道新浪服务器的端口号呢？</p>
<p>答案是作为服务器，提供什么样的服务，端口号就必须固定下来。由于我们想要访问网页，因此新浪提供网页服务的服务器必须把端口号固定在80端口，因为80端口是Web服务的标准端口。其他服务都有对应的标准端口号，例如SMTP服务是25端口，FTP服务是21端口，等等。端口号小于1024的是Internet标准服务的端口，端口号大于1024的，可以任意使用。</p>
<p>因此，我们连接新浪服务器的代码如下：</p>
<pre><code>s.connect(('www.sina.com.cn', 80))
</code></pre>
<p>注意<strong>参数是一个tuple</strong>，<strong>包含地址和端口号</strong>。</p>
<p>建立TCP连接后，我们就可以向新浪服务器发送请求，要求返回首页的内容：</p>
<pre><code>
# 发送数据:
s.send(b'GET / HTTP/1.1\r\nHost: www.sina.com.cn\r\nConnection: close\r\n\r\n')

</code></pre>
<p>TCP连接创建的是双向通道，双方都可以同时给对方发数据。但是谁先发谁后发，怎么协调，要根据具体的协议来决定。例如，HTTP协议规定客户端必须先发请求给服务器，服务器收到后才发数据给客户端。</p>
<p>发送的文本格式必须符合HTTP标准，如果格式没问题，接下来就可以接收新浪服务器返回的数据了：</p>
<pre><code>
# 接收数据:
buffer = []
while True:
    # 每次最多接收1k字节:
    d = s.recv(1024)
    if d:
        buffer.append(d)
    else:
        break
data = b''.join(buffer)

</code></pre>
<p>接收数据时，调用recv(max)方法，一次最多接收指定的字节数，因此，在一个while循环中反复接收，直到recv()返回空数据，表示接收完毕，退出循环。</p>
<p>当我们接收完数据后，调用close()方法关闭Socket，这样，一次完整的网络通信就结束了：</p>
<pre><code>
# 关闭连接:
s.close()

</code></pre>
<p>接收到的数据包括HTTP头和网页本身，我们只需要把HTTP头和网页分离一下，把HTTP头打印出来，网页内容保存到文件：</p>
<pre><code>
header, html = data.split(b'\r\n\r\n', 1)
print(header.decode('utf-8'))
# 把接收的数据写入文件:
with open('sina.html', 'wb') as f:
    f.write(html)
		
</code></pre>
<p>现在，只需要在浏览器中打开这个sina.html文件，就可以看到新浪的首页了。</p>
<h3 id="服务器">服务器</h3>
<p>和客户端编程相比，服务器编程就要复杂一些。</p>
<p>服务器进程首先要绑定一个端口并监听来自其他客户端的连接。如果某个客户端连接过来了，服务器就与该客户端建立Socket连接，随后的通信就靠这个Socket连接了。</p>
<p>所以，服务器会打开固定端口（比如80）监听，每来一个客户端连接，就创建该Socket连接。由于服务器会有大量来自客户端的连接，所以，服务器要能够区分一个Socket连接是和哪个客户端绑定的。一个Socket依赖4项：服务器地址、服务器端口、客户端地址、客户端端口来唯一确定一个Socket。</p>
<p>但是服务器还需要同时响应多个客户端的请求，所以，每个连接都需要一个新的进程或者新的线程来处理，否则，服务器一次就只能服务一个客户端了。</p>
<p>我们来编写一个简单的服务器程序，它接收客户端连接，把客户端发过来的字符串加上Hello再发回去。</p>
<p>首先，创建一个基于IPv4和TCP协议的Socket：</p>
<pre><code>s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
</code></pre>
<p>然后，我们要绑定监听的地址和端口。服务器可能有多块网卡，可以绑定到某一块网卡的IP地址上，也可以用0.0.0.0绑定到所有的网络地址，还可以用127.0.0.1绑定到本机地址。127.0.0.1是一个特殊的IP地址，表示本机地址，如果绑定到这个地址，客户端必须同时在本机运行才能连接，也就是说，外部的计算机无法连接进来。</p>
<p>端口号需要预先指定。因为我们写的这个服务不是标准服务，所以用9999这个端口号。请注意，<strong>小于1024的端口号必须要有管理员权限才能绑定</strong>：</p>
<pre><code># 监听端口:
s.bind(('127.0.0.1', 9999))
</code></pre>
<p>紧接着，调用listen()方法开始监听端口，传入的参数指定等待连接的最大数量：</p>
<pre><code>s.listen(5)
print('Waiting for connection...')
</code></pre>
<p>接下来，服务器程序通过一个永久循环来接受来自客户端的连接，accept()会等待并返回一个客户端的连接:</p>
<pre><code>while True:
    # 接受一个新连接:
    sock, addr = s.accept()
    # 创建新线程来处理TCP连接:
    t = threading.Thread(target=tcplink, args=(sock, addr))
    t.start()
</code></pre>
<p><strong>每个连接都必须创建新线程（或进程）来处理，否则，单线程在处理连接的过程中，无法接受其他客户端的连接</strong>：</p>
<pre><code>def tcplink(sock, addr):
    print('Accept new connection from %s:%s...' % addr)
    sock.send(b'Welcome!')
    while True:
        data = sock.recv(1024)
        time.sleep(1)
        if not data or data.decode('utf-8') == 'exit':
            break
        sock.send(('Hello, %s!' % data.decode('utf-8')).encode('utf-8'))
    sock.close()
    print('Connection from %s:%s closed.' % addr)
</code></pre>
<p>连接建立后，服务器首先发一条欢迎消息，然后等待客户端数据，并加上Hello再发送给客户端。如果客户端发送了exit字符串，就直接关闭连接。</p>
<p>要测试这个服务器程序，我们还需要编写一个客户端程序：</p>
<pre><code>
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# 建立连接:
s.connect(('127.0.0.1', 9999))
# 接收欢迎消息:
print(s.recv(1024).decode('utf-8'))
for data in [b'Michael', b'Tracy', b'Sarah']:
    # 发送数据:
    s.send(data)
    print(s.recv(1024).decode('utf-8'))
s.send(b'exit')
s.close()

</code></pre>
<p>我们需要打开两个命令行窗口，一个运行服务器程序，另一个运行客户端程序，就可以看到效果了：</p>
<pre><code>
┌────────────────────────────────────────────────────────┐
│Command Prompt                                    - □ x │
├────────────────────────────────────────────────────────┤
│$ python echo_server.py                                 │
│Waiting for connection...                               │
│Accept new connection from 127.0.0.1:64398...           │
│Connection from 127.0.0.1:64398 closed.                 │
│                                                        │
│       ┌────────────────────────────────────────────────┴───────┐
│       │Command Prompt                                    - □ x │
│       ├────────────────────────────────────────────────────────┤
│       │$ python echo_client.py                                 │
│       │Welcome!                                                │
│       │Hello, Michael!                                         │
└───────┤Hello, Tracy!                                           │
        │Hello, Sarah!                                           │
        │$                                                       │
        │                                                        │
        │                                                        │
        └────────────────────────────────────────────────────────┘
				
</code></pre>
<p>需要注意的是，客户端程序运行完毕就退出了，而服务器程序会永远运行下去，必须按Ctrl+C退出程序。</p>
<p><strong>小结</strong></p>
<p>用TCP协议进行Socket编程在Python中十分简单，对于客户端，要主动连接服务器的IP和指定端口，对于服务器，要首先监听指定端口，然后，对每一个新的连接，创建一个线程或进程来处理。通常，服务器程序会无限运行下去。</p>
<p>同一个端口，被一个Socket绑定了以后，就不能被别的Socket绑定了。</p>
<h2 id="udp编程">UDP编程</h2>
<p>TCP是建立可靠连接，并且通信双方都可以以流的形式发送数据。相对TCP，UDP则是面向无连接的协议。</p>
<p>使用UDP协议时，不需要建立连接，只需要知道对方的IP地址和端口号，就可以直接发数据包。但是，能不能到达就不知道了。</p>
<p>虽然用UDP传输数据不可靠，但它的优点是和TCP比，速度快，对于不要求可靠到达的数据，就可以使用UDP协议。</p>
<p>我们来看看如何通过UDP协议传输数据。和TCP类似，使用UDP的通信双方也分为客户端和服务器。服务器首先需要绑定端口：</p>
<pre><code>
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
# 绑定端口:
s.bind(('127.0.0.1', 9999))

</code></pre>
<p>创建Socket时，SOCK_DGRAM指定了这个Socket的类型是UDP。绑定端口和TCP一样，但是<strong>不需要调用listen()方法，而是直接接收来自任何客户端的数据</strong>：</p>
<pre><code>
print('Bind UDP on 9999...')
while True:
    # 接收数据:
    data, addr = s.recvfrom(1024)
    print('Received from %s:%s.' % addr)
    s.sendto(b'Hello, %s!' % data, addr)
		
</code></pre>
<p>recvfrom()方法返回数据和客户端的地址与端口，这样，服务器收到数据后，直接调用sendto()就可以把数据用UDP发给客户端。</p>
<p>注意这里省掉了多线程，因为这个例子很简单。</p>
<p>客户端使用UDP时，首先仍然创建基于UDP的Socket，然后，不需要调用connect()，直接通过sendto()给服务器发数据：</p>
<pre><code>s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
for data in [b'Michael', b'Tracy', b'Sarah']:
    # 发送数据:
    s.sendto(data, ('127.0.0.1', 9999))
    # 接收数据:
    print(s.recv(1024).decode('utf-8'))
s.close()
</code></pre>
<p>从服务器接收数据仍然调用recv()方法。</p>
<p>仍然用两个命令行分别启动服务器和客户端测试，结果如下：</p>
<pre><code>
┌────────────────────────────────────────────────────────┐
│Command Prompt                                    - □ x │
├────────────────────────────────────────────────────────┤
│$ python udp_server.py                                  │
│Bind UDP on 9999...                                     │
│Received from 127.0.0.1:63823...                        │
│Received from 127.0.0.1:63823...                        │
│Received from 127.0.0.1:63823...                        │
│       ┌────────────────────────────────────────────────┴───────┐
│       │Command Prompt                                    - □ x │
│       ├────────────────────────────────────────────────────────┤
│       │$ python udp_client.py                                  │
│       │Welcome!                                                │
│       │Hello, Michael!                                         │
└───────┤Hello, Tracy!                                           │
        │Hello, Sarah!                                           │
        │$                                                       │
        │                                                        │
        │                                                        │
        └────────────────────────────────────────────────────────┘
</code></pre>
<p><strong>小结</strong></p>
<p>UDP的使用与TCP类似，但是不需要建立连接。此外，服务器绑定UDP端口和TCP端口互不冲突，也就是说，UDP的9999端口与TCP的9999端口可以各自绑定。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python - 常用第三方模块]]></title>
        <id>https://lixin-scut.github.io//post/python-chang-yong-di-san-fang-mo-kuai</id>
        <link href="https://lixin-scut.github.io//post/python-chang-yong-di-san-fang-mo-kuai">
        </link>
        <updated>2020-05-13T07:24:22.000Z</updated>
        <content type="html"><![CDATA[<p>除了内建的模块外，Python还有大量的第三方模块。</p>
<p>基本上，所有的第三方模块都会在PyPI - the Python Package Index上注册，只要找到对应的模块名字，即可用pip安装。</p>
<p>此外，在安装第三方模块一节中，我们强烈推荐安装Anaconda，安装后，数十个常用的第三方模块就已经就绪，不用pip手动安装。</p>
<h2 id="pillow-图像处理">Pillow - 图像处理</h2>
<p>PIL：Python Imaging Library，已经是Python平台事实上的图像处理标准库了。PIL功能非常强大，但API却非常简单易用。</p>
<p>由于PIL仅支持到Python 2.7，加上年久失修，于是一群志愿者在PIL的基础上创建了兼容的版本，名字叫Pillow，支持最新Python 3.x，又加入了许多新特性，因此，我们可以直接安装使用Pillow。</p>
<h3 id="安装pillow">安装Pillow</h3>
<p>如果安装了Anaconda，Pillow就已经可用了。否则，需要在命令行下通过pip安装：</p>
<pre><code>$ pip install pillow
</code></pre>
<p>如果遇到Permission denied安装失败，请加上sudo重试。</p>
<h3 id="操作图像">操作图像</h3>
<p>来看看最常见的图像缩放操作，只需三四行代码：</p>
<pre><code>
from PIL import Image

# 打开一个jpg图像文件，注意是当前路径:
im = Image.open('test.jpg')
# 获得图像尺寸:
w, h = im.size
print('Original image size: %sx%s' % (w, h))
# 缩放到50%:
im.thumbnail((w//2, h//2))
print('Resize image to: %sx%s' % (w//2, h//2))
# 把缩放后的图像用jpeg格式保存:
im.save('thumbnail.jpg', 'jpeg')

</code></pre>
<p>其他功能如切片、旋转、滤镜、输出文字、调色板等一应俱全。</p>
<p>比如，模糊效果也只需几行代码：</p>
<pre><code>from PIL import Image, ImageFilter

# 打开一个jpg图像文件，注意是当前路径:
im = Image.open('test.jpg')
# 应用模糊滤镜:
im2 = im.filter(ImageFilter.BLUR)
im2.save('blur.jpg', 'jpeg')

</code></pre>
<p>PIL的ImageDraw提供了一系列绘图方法，让我们可以直接绘图。比如要生成字母验证码图片：</p>
<pre><code>from PIL import Image, ImageDraw, ImageFont, ImageFilter

import random

# 随机字母:
def rndChar():
    return chr(random.randint(65, 90))

# 随机颜色1:
def rndColor():
    return (random.randint(64, 255), random.randint(64, 255), random.randint(64, 255))

# 随机颜色2:
def rndColor2():
    return (random.randint(32, 127), random.randint(32, 127), random.randint(32, 127))

# 240 x 60:
width = 60 * 4
height = 60
image = Image.new('RGB', (width, height), (255, 255, 255))
# 创建Font对象:
font = ImageFont.truetype('Arial.ttf', 36)
# 创建Draw对象:
draw = ImageDraw.Draw(image)
# 填充每个像素:
for x in range(width):
    for y in range(height):
        draw.point((x, y), fill=rndColor())
# 输出文字:
for t in range(4):
    draw.text((60 * t + 10, 10), rndChar(), font=font, fill=rndColor2())
# 模糊:
image = image.filter(ImageFilter.BLUR)
image.save('code.jpg', 'jpeg')

</code></pre>
<p>如果运行的时候报错：<br>
<code>IOError: cannot open resource</code><br>
这是因为PIL无法定位到字体文件的位置，可以根据操作系统提供绝对路径，比如：<br>
<code>'/Library/Fonts/Arial.ttf'</code><br>
要详细了解PIL的强大功能，请请参考Pillow官方文档：</p>
<p><code>https://pillow.readthedocs.org/</code></p>
<h3 id="小结">小结</h3>
<p>PIL提供了操作图像的强大功能，可以通过简单的代码完成复杂的图像处理。</p>
<h2 id="requests-处理url资源">requests - 处理URL资源</h2>
<p>我们已经讲解了Python内置的urllib模块，用于访问网络资源。但是，它用起来比较麻烦，而且，缺少很多实用的高级功能。</p>
<p>更好的方案是使用requests。它是一个Python第三方库，处理URL资源特别方便。</p>
<h3 id="安装requests">安装requests</h3>
<p>如果安装了Anaconda，requests就已经可用了。否则，需要在命令行下通过pip安装：</p>
<pre><code>$ pip install requests
</code></pre>
<p>如果遇到Permission denied安装失败，请加上sudo重试。</p>
<h3 id="使用requests">使用requests</h3>
<p>要通过GET访问一个页面，只需要几行代码：</p>
<pre><code>&gt;&gt;&gt; import requests
&gt;&gt;&gt; r = requests.get('https://www.douban.com/') # 豆瓣首页
&gt;&gt;&gt; r.status_code
200
&gt;&gt;&gt; r.text
r.text
'&lt;!DOCTYPE HTML&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta name=&quot;description&quot; content=&quot;提供图书、电影、音乐唱片的推荐、评论和...'
</code></pre>
<p>对于带参数的URL，传入一个dict作为params参数：</p>
<pre><code>&gt;&gt;&gt; r = requests.get('https://www.douban.com/search', params={'q': 'python', 'cat': '1001'})
&gt;&gt;&gt; r.url # 实际请求的URL
'https://www.douban.com/search?q=python&amp;cat=1001'
</code></pre>
<p>requests自动检测编码，可以使用encoding属性查看：</p>
<pre><code>&gt;&gt;&gt; r.encoding
'utf-8'
</code></pre>
<p>无论响应是文本还是二进制内容，我们都可以用content属性获得bytes对象：</p>
<pre><code>&gt;&gt;&gt; r.content
b'&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;\n...'
</code></pre>
<p>requests的方便之处还在于，对于特定类型的响应，例如JSON，可以直接获取：</p>
<pre><code>&gt;&gt;&gt; r = requests.get('https://query.yahooapis.com/v1/public/yql?q=select%20*%20from%20weather.forecast%20where%20woeid%20%3D%202151330&amp;format=json')
&gt;&gt;&gt; r.json()
{'query': {'count': 1, 'created': '2017-11-17T07:14:12Z', ...
</code></pre>
<p>需要传入HTTP Header时，我们传入一个dict作为headers参数：</p>
<pre><code>&gt;&gt;&gt; r = requests.get('https://www.douban.com/', headers={'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit'})
&gt;&gt;&gt; r.text
'&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;UTF-8&quot;&gt;\n &lt;title&gt;豆瓣(手机版)&lt;/title&gt;...'
</code></pre>
<p>要发送POST请求，只需要把get()方法变成post()，然后传入data参数作为POST请求的数据：</p>
<pre><code>&gt;&gt;&gt; r = requests.post('https://accounts.douban.com/login', data={'form_email': 'abc@example.com', 'form_password': '123456'})
</code></pre>
<p>requests默认使用<code>application/x-www-form-urlencoded</code>对POST数据编码。如果要传递JSON数据，可以直接传入json参数：</p>
<pre><code>params = {'key': 'value'}
r = requests.post(url, json=params) # 内部自动序列化为JSON
</code></pre>
<p>类似的，上传文件需要更复杂的编码格式，但是requests把它简化成files参数：</p>
<pre><code>&gt;&gt;&gt; upload_files = {'file': open('report.xls', 'rb')}
&gt;&gt;&gt; r = requests.post(url, files=upload_files)
</code></pre>
<p>在读取文件时，注意务必使用'rb'即二进制模式读取，这样获取的bytes长度才是文件的长度。</p>
<p>把post()方法替换为put()，delete()等，就可以以PUT或DELETE方式请求资源。</p>
<p>除了能轻松获取响应内容外，requests对获取HTTP响应的其他信息也非常简单。例如，获取响应头：</p>
<pre><code>&gt;&gt;&gt; r.headers
{Content-Type': 'text/html; charset=utf-8', 'Transfer-Encoding': 'chunked', 'Content-Encoding': 'gzip', ...}
&gt;&gt;&gt; r.headers['Content-Type']
'text/html; charset=utf-8'
</code></pre>
<p>requests对Cookie做了特殊处理，使得我们不必解析Cookie就可以轻松获取指定的Cookie：</p>
<pre><code>&gt;&gt;&gt; r.cookies['ts']
'example_cookie_12345'
</code></pre>
<p>要在请求中传入Cookie，只需准备一个dict传入cookies参数：</p>
<pre><code>&gt;&gt;&gt; cs = {'token': '12345', 'status': 'working'}
&gt;&gt;&gt; r = requests.get(url, cookies=cs)
</code></pre>
<p>最后，要指定超时，传入以秒为单位的timeout参数：</p>
<pre><code>&gt;&gt;&gt; r = requests.get(url, timeout=2.5) # 2.5秒后超时
</code></pre>
<h2 id="chardet-字符串编码检测">chardet - 字符串编码检测</h2>
<p>字符串编码一直是令人非常头疼的问题，尤其是我们在处理一些不规范的第三方网页的时候。虽然Python提供了Unicode表示的str和bytes两种数据类型，并且可以通过encode()和decode()方法转换，但是，在不知道编码的情况下，对bytes做decode()不好做。</p>
<p>对于未知编码的bytes，要把它转换成str，需要先“猜测”编码。猜测的方式是先收集各种编码的特征字符，根据特征字符判断，就能有很大概率“猜对”。</p>
<p>当然，我们肯定不能从头自己写这个检测编码的功能，这样做费时费力。chardet这个第三方库正好就派上了用场。用它来检测编码，简单易用。</p>
<h3 id="安装chardet">安装chardet</h3>
<p>如果安装了Anaconda，chardet就已经可用了。否则，需要在命令行下通过pip安装：</p>
<pre><code>$ pip install chardet
</code></pre>
<p>如果遇到Permission denied安装失败，请加上sudo重试。</p>
<h3 id="使用chardet">使用chardet</h3>
<p>当我们拿到一个bytes时，就可以对其检测编码。用chardet检测编码，只需要一行代码：</p>
<pre><code>&gt;&gt;&gt; chardet.detect(b'Hello, world!')
{'encoding': 'ascii', 'confidence': 1.0, 'language': ''}
</code></pre>
<p>检测出的编码是ascii，注意到还有个confidence字段，表示检测的概率是1.0（即100%）。</p>
<p>我们来试试检测GBK编码的中文：</p>
<pre><code>&gt;&gt;&gt; data = '离离原上草，一岁一枯荣'.encode('gbk')
&gt;&gt;&gt; chardet.detect(data)
{'encoding': 'GB2312', 'confidence': 0.7407407407407407, 'language': 'Chinese'}
</code></pre>
<p>检测的编码是GB2312，注意到GBK是GB2312的超集，两者是同一种编码，检测正确的概率是74%，language字段指出的语言是'Chinese'。</p>
<p>对UTF-8编码进行检测：</p>
<pre><code>&gt;&gt;&gt; data = '离离原上草，一岁一枯荣'.encode('utf-8')
&gt;&gt;&gt; chardet.detect(data)
{'encoding': 'utf-8', 'confidence': 0.99, 'language': ''}
</code></pre>
<p>我们再试试对日文进行检测：</p>
<pre><code>&gt;&gt;&gt; data = '最新の主要ニュース'.encode('euc-jp')
&gt;&gt;&gt; chardet.detect(data)
{'encoding': 'EUC-JP', 'confidence': 0.99, 'language': 'Japanese'}
</code></pre>
<p>可见，用chardet检测编码，使用简单。获取到编码后，再转换为str，就可以方便后续处理。</p>
<p>chardet支持检测的编码列表请参考官方文档Supported encodings。</p>
<h2 id="psutil">psutil</h2>
<p>用Python来编写脚本简化日常的运维工作是Python的一个重要用途。在Linux下，有许多系统命令可以让我们时刻监控系统运行的状态，如ps，top，free等等。要获取这些系统信息，Python可以通过subprocess模块调用并获取结果。但这样做显得很麻烦，尤其是要写很多解析代码。</p>
<p>在Python中获取系统信息的另一个好办法是使用psutil这个第三方模块。顾名思义，psutil = process and system utilities，它不仅可以通过一两行代码实现系统监控，还可以跨平台使用，支持Linux／UNIX／OSX／Windows等，是系统管理员和运维小伙伴不可或缺的必备模块。</p>
<h3 id="安装psutil-系统监控">安装psutil - 系统监控</h3>
<p>如果安装了Anaconda，psutil就已经可用了。否则，需要在命令行下通过pip安装：</p>
<pre><code>$ pip install psutil
</code></pre>
<p>如果遇到Permission denied安装失败，请加上sudo重试。</p>
<h3 id="获取cpu信息">获取CPU信息</h3>
<p>我们先来获取CPU的信息：</p>
<pre><code>&gt;&gt;&gt; import psutil
&gt;&gt;&gt; psutil.cpu_count() # CPU逻辑数量
4
&gt;&gt;&gt; psutil.cpu_count(logical=False) # CPU物理核心
2
# 2说明是双核超线程, 4则是4核非超线程
</code></pre>
<p>统计CPU的用户／系统／空闲时间：</p>
<pre><code>&gt;&gt;&gt; psutil.cpu_times()
scputimes(user=10963.31, nice=0.0, system=5138.67, idle=356102.45)
</code></pre>
<p>再实现类似top命令的CPU使用率，每秒刷新一次，累计10次：</p>
<pre><code>&gt;&gt;&gt; for x in range(10):
...     print(psutil.cpu_percent(interval=1, percpu=True))
... 
[14.0, 4.0, 4.0, 4.0]
[12.0, 3.0, 4.0, 3.0]
[8.0, 4.0, 3.0, 4.0]
[12.0, 3.0, 3.0, 3.0]
[18.8, 5.1, 5.9, 5.0]
[10.9, 5.0, 4.0, 3.0]
[12.0, 5.0, 4.0, 5.0]
[15.0, 5.0, 4.0, 4.0]
[19.0, 5.0, 5.0, 4.0]
[9.0, 3.0, 2.0, 3.0]
</code></pre>
<h3 id="获取内存信息">获取内存信息</h3>
<p>使用psutil获取物理内存和交换内存信息，分别使用：</p>
<pre><code>&gt;&gt;&gt; psutil.virtual_memory()
svmem(total=8589934592, available=2866520064, percent=66.6, used=7201386496, free=216178688, active=3342192640, inactive=2650341376, wired=1208852480)
&gt;&gt;&gt; psutil.swap_memory()
sswap(total=1073741824, used=150732800, free=923009024, percent=14.0, sin=10705981440, sout=40353792)
</code></pre>
<p>返回的是字节为单位的整数，可以看到，总内存大小是8589934592 = 8 GB，已用7201386496 = 6.7 GB，使用了66.6%。</p>
<p>而交换区大小是1073741824 = 1 GB。</p>
<h3 id="获取磁盘信息">获取磁盘信息</h3>
<p>可以通过psutil获取磁盘分区、磁盘使用率和磁盘IO信息：</p>
<pre><code>&gt;&gt;&gt; psutil.disk_partitions() # 磁盘分区信息
[sdiskpart(device='/dev/disk1', mountpoint='/', fstype='hfs', opts='rw,local,rootfs,dovolfs,journaled,multilabel')]
&gt;&gt;&gt; psutil.disk_usage('/') # 磁盘使用情况
sdiskusage(total=998982549504, used=390880133120, free=607840272384, percent=39.1)
&gt;&gt;&gt; psutil.disk_io_counters() # 磁盘IO
sdiskio(read_count=988513, write_count=274457, read_bytes=14856830464, write_bytes=17509420032, read_time=2228966, write_time=1618405)
可以看到，磁盘'/'的总容量是998982549504 = 930 GB，使用了39.1%。文件格式是HFS，opts中包含rw表示可读写，journaled表示支持日志。
</code></pre>
<h3 id="获取网络信息">获取网络信息</h3>
<p>psutil可以获取网络接口和网络连接信息：</p>
<pre><code>&gt;&gt;&gt; psutil.net_io_counters() # 获取网络读写字节／包的个数
snetio(bytes_sent=3885744870, bytes_recv=10357676702, packets_sent=10613069, packets_recv=10423357, errin=0, errout=0, dropin=0, dropout=0)
&gt;&gt;&gt; psutil.net_if_addrs() # 获取网络接口信息
{
  'lo0': [snic(family=&lt;AddressFamily.AF_INET: 2&gt;, address='127.0.0.1', netmask='255.0.0.0'), ...],
  'en1': [snic(family=&lt;AddressFamily.AF_INET: 2&gt;, address='10.0.1.80', netmask='255.255.255.0'), ...],
  'en0': [...],
  'en2': [...],
  'bridge0': [...]
}
&gt;&gt;&gt; psutil.net_if_stats() # 获取网络接口状态
{
  'lo0': snicstats(isup=True, duplex=&lt;NicDuplex.NIC_DUPLEX_UNKNOWN: 0&gt;, speed=0, mtu=16384),
  'en0': snicstats(isup=True, duplex=&lt;NicDuplex.NIC_DUPLEX_UNKNOWN: 0&gt;, speed=0, mtu=1500),
  'en1': snicstats(...),
  'en2': snicstats(...),
  'bridge0': snicstats(...)
}
</code></pre>
<p>要获取当前网络连接信息，使用net_connections()：</p>
<pre><code>&gt;&gt;&gt; psutil.net_connections()
Traceback (most recent call last):
  ...
PermissionError: [Errno 1] Operation not permitted

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  ...
psutil.AccessDenied: psutil.AccessDenied (pid=3847)
</code></pre>
<p>你可能会得到一个AccessDenied错误，原因是<strong>psutil获取信息也是要走系统接口，而获取网络连接信息需要root权限</strong>，这种情况下，可以退出Python交互环境，用sudo重新启动：</p>
<pre><code>$ sudo python3
Password: ******
Python 3.8 ... on darwin
Type &quot;help&quot;, ... for more information.
&gt;&gt;&gt; import psutil
&gt;&gt;&gt; psutil.net_connections()
[
    sconn(fd=83, family=&lt;AddressFamily.AF_INET6: 30&gt;, type=1, laddr=addr(ip='::127.0.0.1', port=62911), raddr=addr(ip='::127.0.0.1', port=3306), status='ESTABLISHED', pid=3725),
    sconn(fd=84, family=&lt;AddressFamily.AF_INET6: 30&gt;, type=1, laddr=addr(ip='::127.0.0.1', port=62905), raddr=addr(ip='::127.0.0.1', port=3306), status='ESTABLISHED', pid=3725),
    sconn(fd=93, family=&lt;AddressFamily.AF_INET6: 30&gt;, type=1, laddr=addr(ip='::', port=8080), raddr=(), status='LISTEN', pid=3725),
    sconn(fd=103, family=&lt;AddressFamily.AF_INET6: 30&gt;, type=1, laddr=addr(ip='::127.0.0.1', port=62918), raddr=addr(ip='::127.0.0.1', port=3306), status='ESTABLISHED', pid=3725),
    sconn(fd=105, family=&lt;AddressFamily.AF_INET6: 30&gt;, type=1, ..., pid=3725),
    sconn(fd=106, family=&lt;AddressFamily.AF_INET6: 30&gt;, type=1, ..., pid=3725),
    sconn(fd=107, family=&lt;AddressFamily.AF_INET6: 30&gt;, type=1, ..., pid=3725),
    ...
    sconn(fd=27, family=&lt;AddressFamily.AF_INET: 2&gt;, type=2, ..., pid=1)
]
</code></pre>
<h3 id="获取进程信息">获取进程信息</h3>
<p>通过psutil可以获取到所有进程的详细信息：</p>
<pre><code>&gt;&gt;&gt; psutil.pids() # 所有进程ID
[3865, 3864, 3863, 3856, 3855, 3853, 3776, ..., 45, 44, 1, 0]
&gt;&gt;&gt; p = psutil.Process(3776) # 获取指定进程ID=3776，其实就是当前Python交互环境
&gt;&gt;&gt; p.name() # 进程名称
'python3.6'
&gt;&gt;&gt; p.exe() # 进程exe路径
'/Users/michael/anaconda3/bin/python3.6'
&gt;&gt;&gt; p.cwd() # 进程工作目录
'/Users/michael'
&gt;&gt;&gt; p.cmdline() # 进程启动的命令行
['python3']
&gt;&gt;&gt; p.ppid() # 父进程ID
3765
&gt;&gt;&gt; p.parent() # 父进程
&lt;psutil.Process(pid=3765, name='bash') at 4503144040&gt;
&gt;&gt;&gt; p.children() # 子进程列表
[]
&gt;&gt;&gt; p.status() # 进程状态
'running'
&gt;&gt;&gt; p.username() # 进程用户名
'michael'
&gt;&gt;&gt; p.create_time() # 进程创建时间
1511052731.120333
&gt;&gt;&gt; p.terminal() # 进程终端
'/dev/ttys002'
&gt;&gt;&gt; p.cpu_times() # 进程使用的CPU时间
pcputimes(user=0.081150144, system=0.053269812, children_user=0.0, children_system=0.0)
&gt;&gt;&gt; p.memory_info() # 进程使用的内存
pmem(rss=8310784, vms=2481725440, pfaults=3207, pageins=18)
&gt;&gt;&gt; p.open_files() # 进程打开的文件
[]
&gt;&gt;&gt; p.connections() # 进程相关网络连接
[]
&gt;&gt;&gt; p.num_threads() # 进程的线程数量
1
&gt;&gt;&gt; p.threads() # 所有线程信息
[pthread(id=1, user_time=0.090318, system_time=0.062736)]
&gt;&gt;&gt; p.environ() # 进程环境变量
{'SHELL': '/bin/bash', 'PATH': '/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:...', 'PWD': '/Users/michael', 'LANG': 'zh_CN.UTF-8', ...}
&gt;&gt;&gt; p.terminate() # 结束进程
Terminated: 15 &lt;-- 自己把自己结束了
</code></pre>
<p>和获取网络连接类似，获取一个root用户的进程需要root权限，启动Python交互环境或者.py文件时，需要sudo权限。</p>
<p>psutil还提供了一个test()函数，可以模拟出ps命令的效果：</p>
<pre><code>$ sudo python3
Password: ******
Python 3.6.3 ... on darwin
Type &quot;help&quot;, ... for more information.
&gt;&gt;&gt; import psutil
&gt;&gt;&gt; psutil.test()
USER         PID %MEM     VSZ     RSS TTY           START    TIME  COMMAND
root           0 24.0 74270628 2016380 ?             Nov18   40:51  kernel_task
root           1  0.1 2494140    9484 ?             Nov18   01:39  launchd
root          44  0.4 2519872   36404 ?             Nov18   02:02  UserEventAgent
root          45    ? 2474032    1516 ?             Nov18   00:14  syslogd
root          47  0.1 2504768    8912 ?             Nov18   00:03  kextd
root          48  0.1 2505544    4720 ?             Nov18   00:19  fseventsd
_appleeven    52  0.1 2499748    5024 ?             Nov18   00:00  appleeventsd
root          53  0.1 2500592    6132 ?             Nov18   00:02  configd
...
</code></pre>
<p>psutil还可以获取用户信息、Windows服务等很多有用的系统信息，具体请参考psutil的官网：https://github.com/giampaolo/psutil</p>
<h2 id="virtualenv">virtualenv</h2>
<p>virtualenv为应用提供了<strong>隔离的Python运行环境</strong>，解决了<strong>不同应用间多版本</strong>的冲突问题。</p>
<p>在开发Python应用程序的时候，系统安装的Python3只有一个版本：3.4。所有第三方的包都会被pip安装到Python3的site-packages目录下。</p>
<p>如果我们要同时开发多个应用程序，那这些应用程序都会共用一个Python，就是安装在系统的Python 3。如果应用A需要jinja 2.7，而应用B需要jinja 2.6怎么办？</p>
<p>这种情况下，每个应用可能需要各自拥有<strong>一套“独立”的Python运行环境</strong>。virtualenv就是用来为一个应用创建一套“隔离”的Python运行环境。</p>
<p>首先，我们用pip安装virtualenv：</p>
<pre><code>$ pip3 install virtualenv
</code></pre>
<p>然后，假定我们要开发一个新的项目，需要一套独立的Python运行环境，可以这么做：</p>
<p>第一步，创建目录：</p>
<pre><code>Mac:~ michael$ mkdir myproject
Mac:~ michael$ cd myproject/
Mac:myproject michael$
</code></pre>
<p>第二步，创建一个独立的Python运行环境，命名为venv：</p>
<pre><code>Mac:myproject michael$ virtualenv --no-site-packages venv
Using base prefix '/usr/local/.../Python.framework/Versions/3.4'
New python executable in venv/bin/python3.4
Also creating executable in venv/bin/python
Installing setuptools, pip, wheel...done.
</code></pre>
<p>命令virtualenv就可以创建一个独立的Python运行环境，我们还加上了参数--no-site-packages，这样，已经安装到系统Python环境中的所有第三方包都不会复制过来，这样，我们就得到了一个不带任何第三方包的“干净”的Python运行环境。</p>
<p>新建的Python环境被放到当前目录下的venv目录。有了venv这个Python环境，可以用source进入该环境：</p>
<pre><code>Mac:myproject michael$ source venv/bin/activate
(venv)Mac:myproject michael$
</code></pre>
<p>注意到命令提示符变了，有个(venv)前缀，表示当前环境是一个名为venv的Python环境。</p>
<p>下面正常安装各种第三方包，并运行python命令：</p>
<pre><code>(venv)Mac:myproject michael$ pip install jinja2
...
Successfully installed jinja2-2.7.3 markupsafe-0.23
(venv)Mac:myproject michael$ python myapp.py
...
</code></pre>
<p><strong>在venv环境下，用pip安装的包都被安装到venv这个环境下，系统Python环境不受任何影响</strong>。也就是说，venv环境是专门针对myproject这个应用创建的。</p>
<p>退出当前的venv环境，使用deactivate命令：</p>
<pre><code>(venv)Mac:myproject michael$ deactivate 
Mac:myproject michael$ 
</code></pre>
<p>此时就回到了正常的环境，现在pip或python均是在系统Python环境下执行。</p>
<p>完全可以针对每个应用创建独立的Python运行环境，这样就可以对每个应用的Python环境进行隔离。</p>
<p>virtualenv是如何创建“独立”的Python运行环境的呢？原理很简单，就是把系统Python复制一份到virtualenv的环境，用命令source venv/bin/activate进入一个virtualenv环境时，virtualenv会修改相关环境变量，让命令python和pip均指向当前的virtualenv环境。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Python - 常用内建模块]]></title>
        <id>https://lixin-scut.github.io//post/python-chang-yong-nei-jian-mo-kuai</id>
        <link href="https://lixin-scut.github.io//post/python-chang-yong-nei-jian-mo-kuai">
        </link>
        <updated>2020-05-13T02:36:20.000Z</updated>
        <content type="html"><![CDATA[<h2 id="datetime">datetime</h2>
<p>datetime是Python处理日期和时间的标准库。</p>
<h3 id="获取当前日期和时间">获取当前日期和时间</h3>
<p>获取当前日期和时间：</p>
<pre><code>&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; now = datetime.now() # 获取当前datetime
&gt;&gt;&gt; print(now)
2015-05-18 16:28:07.198690
&gt;&gt;&gt; print(type(now))
&lt;class 'datetime.datetime'&gt;
</code></pre>
<p>注意到<strong>datetime是模块，datetime模块还包含一个datetime类</strong>，通过from datetime import datetime导入的才是datetime这个类。</p>
<p><strong>如果仅导入import datetime，则必须引用全名datetime.datetime</strong>。</p>
<p><strong>datetime.now()返回当前日期和时间，其类型是datetime。</strong></p>
<h3 id="获取指定日期和时间">获取指定日期和时间</h3>
<p>要指定某个日期和时间，我们直接用参数构造一个datetime：</p>
<pre><code>&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; dt = datetime(2015, 4, 19, 12, 20) # 用指定日期时间创建datetime
&gt;&gt;&gt; print(dt)

2015-04-19 12:20:00
</code></pre>
<h3 id="datetime转换为timestamp">datetime转换为timestamp</h3>
<p>在计算机中，时间实际上是用数字表示的。我们把1970年1月1日 00:00:00 UTC+00:00时区的时刻称为epoch time，记为0（1970年以前的时间timestamp为负数），当前<strong>时间就是相对于epoch time的秒数，称为timestamp</strong>。</p>
<p>你可以认为：</p>
<pre><code>timestamp = 0 = 1970-1-1 00:00:00 UTC+0:00
</code></pre>
<p>对应的北京时间是：</p>
<pre><code>timestamp = 0 = 1970-1-1 08:00:00 UTC+8:00
</code></pre>
<p>可见<strong>timestamp的值与时区毫无关系，因为timestamp一旦确定，其UTC时间就确定了</strong>，转换到任意时区的时间也是完全确定的，这就是为什么计算机存储的当前时间是以timestamp表示的，因为<strong>全球各地的计算机在任意时刻的timestamp都是完全相同的（假定时间已校准）</strong>。</p>
<p>把一个datetime类型转换为timestamp只需要简单调用<strong>timestamp()方法</strong>：</p>
<pre><code>&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; dt = datetime(2015, 4, 19, 12, 20) # 用指定日期时间创建datetime
&gt;&gt;&gt; dt.timestamp() # 把datetime转换为timestamp
1429417200.0
</code></pre>
<p>注意Python的<strong>timestamp是一个浮点数</strong>。如果<strong>有小数位，小数位表示毫秒数。</strong></p>
<p><strong>某些编程语言（如Java和JavaScript）的timestamp使用整数表示毫秒数</strong>，这种情况下<strong>只需要把timestamp除以1000</strong>就得到Python的浮点表示方法。</p>
<h3 id="timestamp转换为datetime">timestamp转换为datetime</h3>
<p>要把timestamp转换为datetime，使用datetime提供的<strong>fromtimestamp()方法</strong>：</p>
<pre><code>&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; t = 1429417200.0
&gt;&gt;&gt; print(datetime.fromtimestamp(t))
2015-04-19 12:20:00
</code></pre>
<p>注意到timestamp是一个浮点数，它没有时区的概念，而<strong>datetime是有时区的。上述转换是在timestamp和本地时间做转换。</strong></p>
<p>本地时间是指当前操作系统设定的时区。例如北京时区是东8区，则本地时间：</p>
<pre><code>2015-04-19 12:20:00
</code></pre>
<p>实际上就是UTC+8:00时区的时间：</p>
<pre><code>2015-04-19 12:20:00 UTC+8:00
</code></pre>
<p>而此刻的格林威治标准时间与北京时间差了8小时，也就是UTC+0:00时区的时间应该是：</p>
<pre><code>2015-04-19 04:20:00 UTC+0:00
</code></pre>
<p>timestamp也可以直接被转换到UTC标准时区的时间：</p>
<pre><code>&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; t = 1429417200.0
&gt;&gt;&gt; print(datetime.fromtimestamp(t)) # 本地时间
2015-04-19 12:20:00
&gt;&gt;&gt; print(datetime.utcfromtimestamp(t)) # UTC时间
2015-04-19 04:20:00
</code></pre>
<h3 id="str转换为datetime">str转换为datetime</h3>
<p>很多时候，用户输入的日期和时间是字符串，要处理日期和时间，首先必须把str转换为datetime。转换方法是通过<strong>datetime.strptime()</strong> 实现，需要一个日期和时间的格式化字符串：</p>
<pre><code>&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; cday = datetime.strptime('2015-6-1 18:19:59', '%Y-%m-%d %H:%M:%S')
&gt;&gt;&gt; print(cday)
2015-06-01 18:19:59
</code></pre>
<p><strong>字符串<code>'%Y-%m-%d %H:%M:%S'</code>规定了日期和时间部分的格式</strong>。详细的说明请参考Python文档。</p>
<p>注意转换后的datetime是没有时区信息的。</p>
<h3 id="datetime转换为str">datetime转换为str</h3>
<p>如果已经有了datetime对象，要把它格式化为字符串显示给用户，就需要转换为str，转换方法是通过<strong>strftime()</strong> 实现的，<strong>同样需要一个日期和时间的格式化字符串</strong>：</p>
<pre><code>&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; now = datetime.now()
&gt;&gt;&gt; print(now.strftime('%a, %b %d %H:%M'))
Mon, May 05 16:28
</code></pre>
<h3 id="datetime加减">datetime加减</h3>
<p>对日期和时间进行加减实际上就是把datetime往后或往前计算，得到新的datetime。加减可以直接用+和-运算符，不过需要导入timedelta这个类：</p>
<pre><code>&gt;&gt;&gt; from datetime import datetime, timedelta
&gt;&gt;&gt; now = datetime.now()
&gt;&gt;&gt; now
datetime.datetime(2015, 5, 18, 16, 57, 3, 540997)
&gt;&gt;&gt; now + timedelta(hours=10)
datetime.datetime(2015, 5, 19, 2, 57, 3, 540997)
&gt;&gt;&gt; now - timedelta(days=1)
datetime.datetime(2015, 5, 17, 16, 57, 3, 540997)
&gt;&gt;&gt; now + timedelta(days=2, hours=12)
datetime.datetime(2015, 5, 21, 4, 57, 3, 540997)
</code></pre>
<p>可见，使用timedelta你可以很容易地算出前几天和后几天的时刻。</p>
<h3 id="本地时间转换为utc时间">本地时间转换为UTC时间</h3>
<p>本地时间是指系统设定时区的时间，例如北京时间是UTC+8:00时区的时间，而UTC时间指UTC+0:00时区的时间。</p>
<p>一个datetime类型有一个<strong>时区属性tzinfo，但是默认为None</strong>，所以无法区分这个datetime到底是哪个时区，除非强行给datetime设置一个时区：</p>
<pre><code>&gt;&gt;&gt; from datetime import datetime, timedelta, timezone
&gt;&gt;&gt; tz_utc_8 = timezone(timedelta(hours=8)) # 创建时区UTC+8:00
&gt;&gt;&gt; now = datetime.now()
&gt;&gt;&gt; now
datetime.datetime(2015, 5, 18, 17, 2, 10, 871012)

&gt;&gt;&gt; dt = now.replace(tzinfo=tz_utc_8) # 强制设置为UTC+8:00
&gt;&gt;&gt; dt
datetime.datetime(2015, 5, 18, 17, 2, 10, 871012, tzinfo=datetime.timezone(datetime.timedelta(0, 28800)))
</code></pre>
<p>如果系统时区恰好是UTC+8:00，那么上述代码就是正确的，否则，不能强制设置为UTC+8:00时区。</p>
<h3 id="时区转换">时区转换</h3>
<p>我们可以先通过utcnow()拿到当前的UTC时间，再转换为任意时区的时间：</p>
<pre><code>

# 拿到UTC时间，并强制设置时区为UTC+0:00:
&gt;&gt;&gt; utc_dt = datetime.utcnow().replace(tzinfo=timezone.utc)
&gt;&gt;&gt; print(utc_dt)
2015-05-18 09:05:12.377316+00:00

# astimezone()将转换时区为北京时间:
&gt;&gt;&gt; bj_dt = utc_dt.astimezone(timezone(timedelta(hours=8)))
&gt;&gt;&gt; print(bj_dt)
2015-05-18 17:05:12.377316+08:00

# astimezone()将转换时区为东京时间:
&gt;&gt;&gt; tokyo_dt = utc_dt.astimezone(timezone(timedelta(hours=9)))
&gt;&gt;&gt; print(tokyo_dt)
2015-05-18 18:05:12.377316+09:00

# astimezone()将bj_dt转换时区为东京时间:
&gt;&gt;&gt; tokyo_dt2 = bj_dt.astimezone(timezone(timedelta(hours=9)))
&gt;&gt;&gt; print(tokyo_dt2)
2015-05-18 18:05:12.377316+09:00

</code></pre>
<p>时区转换的关键在于，拿到一个datetime时，要获知其正确的时区，然后强制设置时区，作为基准时间。</p>
<p>利用带时区的datetime，通过astimezone()方法，可以转换到任意时区。</p>
<p>注：不是必须从UTC+0:00时区转换到其他时区，任何带时区的datetime都可以正确转换，例如上述bj_dt到tokyo_dt的转换。</p>
<h3 id="小结">小结</h3>
<p>datetime表示的时间需要时区信息才能确定一个特定的时间，否则只能视为本地时间。</p>
<p>如果要存储datetime，最佳方法是将其转换为timestamp再存储，因为timestamp的值与时区完全无关。</p>
<h2 id="collections">collections</h2>
<p>collections是Python内建的一个集合模块，提供了许多有用的集合类。</p>
<h3 id="namedtuple">namedtuple</h3>
<p>我们知道tuple可以表示不变集合，例如，一个点的二维坐标就可以表示成：</p>
<pre><code>&gt;&gt;&gt; p = (1, 2)
</code></pre>
<p>但是，看到(1, 2)，<strong>很难看出这个tuple是用来表示一个坐标的</strong>。</p>
<p>定义一个class又小题大做了，这时，namedtuple就派上了用场：</p>
<pre><code>&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; Point = namedtuple('Point', ['x', 'y'])
&gt;&gt;&gt; p = Point(1, 2)
&gt;&gt;&gt; p.x
1
&gt;&gt;&gt; p.y
2
</code></pre>
<p>namedtuple<strong>是一个函数</strong>，它用来<strong>创建一个自定义的tuple对象</strong>，并且<strong>规定了tuple元素的个数</strong>，并可以<strong>用属性而不是索引来引用tuple的某个元素</strong>。</p>
<p>这样一来，我们用namedtuple可以很方便地定义一种数据类型，它具备tuple的不变性，又可以根据属性来引用，使用十分方便。</p>
<p>可以验证<strong>创建的Point对象是tuple的一种子类</strong>：</p>
<pre><code>&gt;&gt;&gt; isinstance(p, Point)
True
&gt;&gt;&gt; isinstance(p, tuple)
True
</code></pre>
<p>类似的，如果要用坐标和半径表示一个圆，也可以用namedtuple定义：</p>
<pre><code>
# namedtuple('名称', [属性list]):
Circle = namedtuple('Circle', ['x', 'y', 'r'])

</code></pre>
<h3 id="deque">deque</h3>
<p>使用list存储数据时，按索引访问元素很快，但是插入和删除元素就很慢了，因为list是线性存储，数据量大的时候，插入和删除效率很低。</p>
<p>deque是为了高效实现<strong>插入和删除操作的双向列表</strong>，<strong>适合用于队列和栈</strong>：</p>
<pre><code>&gt;&gt;&gt; from collections import deque
&gt;&gt;&gt; q = deque(['a', 'b', 'c'])
&gt;&gt;&gt; q.append('x')
&gt;&gt;&gt; q.appendleft('y')
&gt;&gt;&gt; q
deque(['y', 'a', 'b', 'c', 'x'])
</code></pre>
<p>deque除了实现list的<strong>append()和pop()</strong> 外，还支持<strong>appendleft()和popleft()</strong>，这样就可以非常高效地往头部添加或删除元素。</p>
<h3 id="defaultdict">defaultdict</h3>
<p>使用dict时，如果引用的Key不存在，就会抛出KeyError。<strong>如果希望key不存在时，返回一个默认值，就可以用defaultdict</strong>：</p>
<pre><code>&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; dd = defaultdict(lambda: 'N/A')
&gt;&gt;&gt; dd['key1'] = 'abc'
&gt;&gt;&gt; dd['key1'] # key1存在
'abc'
&gt;&gt;&gt; dd['key2'] # key2不存在，返回默认值
'N/A'
</code></pre>
<p>注意默认值是<strong>调用函数返回</strong>的，而函数在创建defaultdict对象时传入。</p>
<p>除了在Key不存在时返回默认值，defaultdict的其他行为跟dict是完全一样的。</p>
<h3 id="ordereddict">OrderedDict</h3>
<p>使用<strong>dict时，Key是无序的</strong>。在对dict做迭代时，我们无法确定Key的顺序。</p>
<p>如果要<strong>保持Key的顺序，可以用OrderedDict</strong>：</p>
<pre><code>&gt;&gt;&gt; from collections import OrderedDict
&gt;&gt;&gt; d = dict([('a', 1), ('b', 2), ('c', 3)])
&gt;&gt;&gt; d # dict的Key是无序的
{'a': 1, 'c': 3, 'b': 2}
&gt;&gt;&gt; od = OrderedDict([('a', 1), ('b', 2), ('c', 3)])
&gt;&gt;&gt; od # OrderedDict的Key是有序的
OrderedDict([('a', 1), ('b', 2), ('c', 3)])
</code></pre>
<p>注意，OrderedDict的Key会<strong>按照插入的顺序排列，不是Key本身排序</strong>：</p>
<pre><code>&gt;&gt;&gt; od = OrderedDict()
&gt;&gt;&gt; od['z'] = 1
&gt;&gt;&gt; od['y'] = 2
&gt;&gt;&gt; od['x'] = 3
&gt;&gt;&gt; list(od.keys()) # 按照插入的Key的顺序返回
['z', 'y', 'x']
</code></pre>
<p>OrderedDict可以实现一个<strong>FIFO（先进先出）的dict</strong>，当<strong>容量超出限制时，先删除最早添加的Key</strong>：</p>
<pre><code>from collections import OrderedDict

class LastUpdatedOrderedDict(OrderedDict):

    def __init__(self, capacity):
        super(LastUpdatedOrderedDict, self).__init__()
        self._capacity = capacity

    def __setitem__(self, key, value):
        containsKey = 1 if key in self else 0
        if len(self) - containsKey &gt;= self._capacity:
            last = self.popitem(last=False)
            print('remove:', last)
        if containsKey:
            del self[key]
            print('set:', (key, value))
        else:
            print('add:', (key, value))
        OrderedDict.__setitem__(self, key, value)
</code></pre>
<h3 id="chainmap">ChainMap</h3>
<p>ChainMap可以把<strong>一组dict</strong>串起来并组成一个<strong>逻辑上的dict</strong>。ChainMap<strong>本身也是一个dict</strong>，但是查找的时候，会<strong>按照顺序在内部的dict依次查找</strong>。</p>
<p>什么时候使用ChainMap最合适？举个例子：应用程序往往都需要传入参数，参数可以通过命令行传入，可以通过环境变量传入，还可以有默认参数。我们可以<strong>用ChainMap实现参数的优先级查找</strong>，即先查命令行参数，如果没有传入，再查环境变量，如果没有，就使用默认参数。</p>
<p>下面的代码演示了如何查找user和color这两个参数：</p>
<pre><code>
from collections import ChainMap
import os, argparse

# 构造缺省参数:
defaults = {
    'color': 'red',
    'user': 'guest'
}

# 构造命令行参数:
parser = argparse.ArgumentParser()
parser.add_argument('-u', '--user')
parser.add_argument('-c', '--color')
namespace = parser.parse_args()
command_line_args = { k: v for k, v in vars(namespace).items() if v }

# 组合成ChainMap:
combined = ChainMap(command_line_args, os.environ, defaults)

# 打印参数:
print('color=%s' % combined['color'])
print('user=%s' % combined['user'])
没有任何参数时，打印出默认参数：

$ python3 use_chainmap.py 
color=red
user=guest

</code></pre>
<p>当传入命令行参数时，优先使用命令行参数：</p>
<pre><code>$ python3 use_chainmap.py -u bob
color=red
user=bob
</code></pre>
<p>同时传入命令行参数和<strong>环境变量</strong>，命令行参数的优先级较高：</p>
<pre><code># python3 前面的都是环境变量
$ user=admin color=green python3 use_chainmap.py -u bob
color=green
user=bob
</code></pre>
<h3 id="counter">Counter</h3>
<p>Counter是一个简单的计数器，例如，统计字符出现的个数：</p>
<pre><code>&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; c = Counter()
&gt;&gt;&gt; for ch in 'programming':
...     c[ch] = c[ch] + 1
...
&gt;&gt;&gt; c
Counter({'g': 2, 'm': 2, 'r': 2, 'a': 1, 'i': 1, 'o': 1, 'n': 1, 'p': 1})
&gt;&gt;&gt; c.update('hello') # 也可以一次性update
&gt;&gt;&gt; c
Counter({'r': 2, 'o': 2, 'g': 2, 'm': 2, 'l': 2, 'p': 1, 'a': 1, 'i': 1, 'n': 1, 'h': 1, 'e': 1})
</code></pre>
<p><strong>Counter实际上也是dict的一个子类</strong>，上面的结果可以看出每个字符出现的次数。</p>
<h2 id="base64">base64</h2>
<p>Base64是一种<strong>用64个字符来表示任意二进制数据</strong>的方法。</p>
<p>用记事本打开exe、jpg、pdf这些文件时，我们都会看到一大堆乱码，因为二进制文件包含很多无法显示和打印的字符，所以，如果要让记事本这样的文本处理软件能处理二进制数据，就需要一个二进制到字符串的转换方法。Base64是一种最常见的二进制编码方法。</p>
<p>Base64的原理很简单，首先，准备一个包含64个字符的数组：</p>
<pre><code>['A', 'B', 'C', ... 'a', 'b', 'c', ... '0', '1', ... '+', '/']
</code></pre>
<p>然后，对二进制数据进行处理，每3个字节一组，一共是3x8=24bit，划为4组，每组正好6个bit：</p>
<p><img src="https://lixin-scut.github.io//post-images/1589339175185.png" alt=""></p>
<p>这样我们得到4个数字作为索引，然后查表，获得相应的4个字符，就是编码后的字符串。</p>
<p>所以，Base64编码会把3字节的二进制数据编码为4字节的文本数据，长度增加33%，好处是编码后的文本数据可以在邮件正文、网页等直接显示。</p>
<p>如果要编码的二进制数据不是3的倍数，最后会剩下1个或2个字节怎么办？Base64用\x00字节在末尾补足后，再在编码的末尾加上1个或2个=号，表示补了多少字节，解码的时候，会自动去掉。</p>
<p>Python内置的base64可以直接进行base64的编解码：</p>
<pre><code>&gt;&gt;&gt; import base64
&gt;&gt;&gt; base64.b64encode(b'binary\x00string')
b'YmluYXJ5AHN0cmluZw=='
&gt;&gt;&gt; base64.b64decode(b'YmluYXJ5AHN0cmluZw==')
b'binary\x00string'
</code></pre>
<p>由于标准的Base64编码后可能出现字符+和/，在URL中就不能直接作为参数，所以又有一种&quot;url safe&quot;的base64编码，其实就是把字符+和/分别变成-和_：</p>
<pre><code>&gt;&gt;&gt; base64.b64encode(b'i\xb7\x1d\xfb\xef\xff')
b'abcd++//'
&gt;&gt;&gt; base64.urlsafe_b64encode(b'i\xb7\x1d\xfb\xef\xff')
b'abcd--__'
&gt;&gt;&gt; base64.urlsafe_b64decode('abcd--__')
b'i\xb7\x1d\xfb\xef\xff'
</code></pre>
<p>还可以自己定义64个字符的排列顺序，这样就可以自定义Base64编码，不过，通常情况下完全没有必要。</p>
<p>Base64是一种通过查表的编码方法，不能用于加密，即使使用自定义的编码表也不行。</p>
<p>Base64适用于小段内容的编码，比如数字证书签名、Cookie的内容等。</p>
<p>由于=字符也可能出现在Base64编码中，但=用在URL、Cookie里面会造成歧义，所以，很多Base64编码后会把=去掉：</p>
<pre><code>
# 标准Base64:
'abcd' -&gt; 'YWJjZA=='
# 自动去掉=:
'abcd' -&gt; 'YWJjZA'

</code></pre>
<p>去掉=后怎么解码呢？因为Base64是把3个字节变为4个字节，所以，Base64编码的长度永远是4的倍数，因此，需要加上=把Base64字符串的长度变为4的倍数，就可以正常解码了。</p>
<h2 id="struct">struct</h2>
<p>准确地讲，Python没有专门处理字节的数据类型。但由于b'str'可以表示字节，所以，字节数组＝二进制str。而在C语言中，我们可以很方便地用struct、union来处理字节，以及字节和int，float的转换。</p>
<p>在Python中，比方说要把一个32位无符号整数变成字节，也就是4个长度的bytes，你得配合位运算符这么写：</p>
<pre><code>&gt;&gt;&gt; n = 10240099
&gt;&gt;&gt; b1 = (n &amp; 0xff000000) &gt;&gt; 24
&gt;&gt;&gt; b2 = (n &amp; 0xff0000) &gt;&gt; 16
&gt;&gt;&gt; b3 = (n &amp; 0xff00) &gt;&gt; 8
&gt;&gt;&gt; b4 = n &amp; 0xff
&gt;&gt;&gt; bs = bytes([b1, b2, b3, b4])
&gt;&gt;&gt; bs
b'\x00\x9c@c'
</code></pre>
<p>非常麻烦。如果换成浮点数就无能为力了。</p>
<p>好在Python提供了一个struct模块来<strong>解决bytes和其他二进制数据类型的转换</strong>。</p>
<p>struct的pack函数把任意数据类型变成bytes：</p>
<pre><code>&gt;&gt;&gt; import struct
&gt;&gt;&gt; struct.pack('&gt;I', 10240099)
b'\x00\x9c@c'
</code></pre>
<p>pack的第一个参数是处理指令，'&gt;I'的意思是：</p>
<p><code>&gt;</code>表示字节顺序是big-endian，也就是网络序，I表示4字节无符号整数。</p>
<p>后面的参数个数要和处理指令一致。</p>
<p>unpack把bytes变成相应的数据类型：</p>
<pre><code>&gt;&gt;&gt; struct.unpack('&gt;IH', b'\xf0\xf0\xf0\xf0\x80\x80')
(4042322160, 32896)
</code></pre>
<p>根据&gt;IH的说明，后面的bytes依次变为I：4字节无符号整数和H：2字节无符号整数。</p>
<p>所以，尽管Python不适合编写底层操作字节流的代码，但在对性能要求不高的地方，利用struct就方便多了。</p>
<p>struct模块定义的数据类型可以参考Python官方文档：</p>
<p>https://docs.python.org/3/library/struct.html#format-characters</p>
<p>Windows的位图文件（.bmp）是一种非常简单的文件格式，我们来用struct分析一下。</p>
<p>首先找一个bmp文件。</p>
<p>读入前30个字节来分析：</p>
<pre><code>
&gt;&gt;&gt; s = b'\x42\x4d\x38\x8c\x0a\x00\x00\x00\x00\x00\x36\x00\x00\x00\x28\x00\x00\x00\x80\x02\x00\x00\x68\x01\x00\x00\x01\x00\x18\x00'

</code></pre>
<p>BMP格式采用小端方式存储数据，文件头的结构按顺序如下：</p>
<p>两个字节：'BM'表示Windows位图，'BA'表示OS/2位图； 一个4字节整数：表示位图大小； 一个4字节整数：保留位，始终为0； 一个4字节整数：实际图像的偏移量； 一个4字节整数：Header的字节数； 一个4字节整数：图像宽度； 一个4字节整数：图像高度； 一个2字节整数：始终为1； 一个2字节整数：颜色数。</p>
<p>所以，组合起来用unpack读取：</p>
<pre><code>&gt;&gt;&gt; struct.unpack('&lt;ccIIIIIIHH', s)
</code></pre>
<p>(b'B', b'M', 691256, 0, 54, 40, 640, 360, 1, 24)<br>
结果显示，b'B'、b'M'说明是Windows位图，位图大小为640x360，颜色数为24。</p>
<h2 id="hashlib">hashlib</h2>
<p>摘要算法简介</p>
<p>摘要算法在很多地方都有广泛的应用。要注意摘要算法不是加密算法，不能用于加密（因为无法通过摘要反推明文），只能用于防篡改，但是它的单向计算特性决定了可以在不存储明文口令的情况下验证用户口令。</p>
<p>Python的<strong>hashlib提供了常见的摘要算法，如MD5，SHA1等等</strong>。</p>
<p>什么是摘要算法呢？摘要算法又称<strong>哈希算法、散列算法</strong>。它通过一个函数，把<strong>任意长度的数据转换为一个长度固定的数据串</strong>（通常用16进制的字符串表示）。</p>
<p>举个例子，你写了一篇文章，内容是一个字符串'how to use python hashlib - by Michael'，并附上这篇文章的摘要是'2d73d4f15c0db7f5ecb321b6a65e5d6d'。如果有人篡改了你的文章，并发表为'how to use python hashlib - by Bob'，你可以一下子指出Bob篡改了你的文章，因为根据'how to use python hashlib - by Bob'计算出的摘要不同于原始文章的摘要。</p>
<p>可见，<strong>摘要算法就是通过摘要函数f()对任意长度的数据data计算出固定长度的摘要digest，目的是为了发现原始数据是否被人篡改过</strong>。</p>
<p>摘要算法之所以能指出数据是否被篡改过，就是因为<strong>摘要函数是一个单向函数，计算f(data)很容易，但通过digest反推data却非常困难</strong>。而且，<strong>对原始数据做一个bit的修改，都会导致计算出的摘要完全不同</strong>。</p>
<p>我们以常见的摘要算法MD5为例，计算出一个字符串的MD5值：</p>
<pre><code>import hashlib

md5 = hashlib.md5()
md5.update('how to use md5 in python hashlib?'.encode('utf-8'))
print(md5.hexdigest())
</code></pre>
<p>计算结果如下：</p>
<pre><code>d26a53750bc40b38b65a520292f69306
</code></pre>
<p>如果数据量很大，可以分块多次调用update()，最后计算的结果是一样的：</p>
<pre><code>import hashlib

md5 = hashlib.md5()
md5.update('how to use md5 in '.encode('utf-8'))
md5.update('python hashlib?'.encode('utf-8'))
print(md5.hexdigest())
</code></pre>
<p>改动一个字母，计算的结果完全不同。</p>
<p>MD5是最常见的摘要算法，速度很快，生成结果是固定的128 bit字节，通常用一个32位的16进制字符串表示。</p>
<p>另一种常见的摘要算法是SHA1，调用SHA1和调用MD5完全类似：</p>
<pre><code>import hashlib

sha1 = hashlib.sha1()
sha1.update('how to use sha1 in '.encode('utf-8'))
sha1.update('python hashlib?'.encode('utf-8'))
print(sha1.hexdigest())
</code></pre>
<p>SHA1的结果是160 bit字节，通常用一个40位的16进制字符串表示。</p>
<p>比SHA1更安全的算法是SHA256和SHA512，不过越安全的算法不仅越慢，而且摘要长度更长。</p>
<p>有没有可能<strong>两个不同的数据通过某个摘要算法得到了相同的摘要</strong>？完全有可能，因为任何摘要算法都是<strong>把无限多的数据集合映射到一个有限的集合中</strong>。这种情况称为碰撞，比如Bob试图根据你的摘要反推出一篇文章'how to learn hashlib in python - by Bob'，并且这篇文章的摘要恰好和你的文章完全一致，这种情况也并非不可能出现，但是非常非常困难。</p>
<p>摘要算法应用</p>
<p>摘要算法能应用到什么地方？举个常用例子：</p>
<p>任何允许用户登录的网站都会存储用户登录的用户名和口令。如何存储用户名和口令呢？方法是存到数据库表中：</p>
<table>
<thead>
<tr>
<th style="text-align:center">name</th>
<th style="text-align:center">password</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">michael</td>
<td style="text-align:center">123456</td>
</tr>
<tr>
<td style="text-align:center">bob</td>
<td style="text-align:center">abc999</td>
</tr>
<tr>
<td style="text-align:center">alice</td>
<td style="text-align:center">alice2008</td>
</tr>
</tbody>
</table>
<p>如果以明文保存用户口令，如果数据库泄露，所有用户的口令就落入黑客的手里。此外，网站运维人员是可以访问数据库的，也就是能获取到所有用户的口令。</p>
<p>正确的保存口令的方式是<strong>不存储用户的明文口令，而是存储用户口令的摘要</strong>，比如MD5：</p>
<table>
<thead>
<tr>
<th style="text-align:center">username</th>
<th style="text-align:center">password</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">michael</td>
<td style="text-align:center">e10adc3949ba59abbe56e057f20f883e</td>
</tr>
<tr>
<td style="text-align:center">bob</td>
<td style="text-align:center">878ef96e86145580c38c87f0410ad153</td>
</tr>
<tr>
<td style="text-align:center">alice</td>
<td style="text-align:center">99b1c2188db85afee403b1536010c2c9</td>
</tr>
</tbody>
</table>
<p>当用户登录时，首先<strong>计算用户输入的明文口令的MD5，然后和数据库存储的MD5对比，如果一致，说明口令输入正确，如果不一致，口令肯定错误</strong>。</p>
<p>存储MD5的好处是即使运维人员能访问数据库，也无法获知用户的明文口令。</p>
<p>采用MD5存储口令是否就一定安全呢？也不一定。假设你是一个黑客，已经拿到了存储MD5口令的数据库，如何通过MD5反推用户的明文口令呢？暴力破解费事费力</p>
<p>考虑这么个情况，很多用户喜欢用123456，888888，password这些简单的口令，于是，黑客可以事先计算出这些常用口令的MD5值，得到一个反推表：</p>
<p>'e10adc3949ba59abbe56e057f20f883e': '123456'<br>
'21218cca77804d2ba1922c33e0151105': '888888'<br>
'5f4dcc3b5aa765d61d8327deb882cf99': 'password'<br>
这样，无需破解，只需要对比数据库的MD5，黑客就获得了使用常用口令的用户账号。</p>
<p>对于用户来讲，当然不要使用过于简单的口令。但是，我们能否在程序设计上对简单口令加强保护呢？</p>
<p>由于常用口令的MD5值很容易被计算出来，所以，要确保存储的用户口令不是那些已经被计算出来的常用口令的MD5，这一方法<strong>通过对原始口令加一个复杂字符串来实现，俗称“加盐”：</strong></p>
<pre><code>def calc_md5(password):
    return get_md5(password + 'the-Salt')
</code></pre>
<p>经过Salt处理的MD5口令，<strong>只要Salt不被黑客知道，即使用户输入简单口令，也很难通过MD5反推明文口令</strong>。</p>
<p>但是如果有两个用户都使用了相同的简单口令比如123456，在数据库中，将存储两条相同的MD5值，这说明这两个用户的口令是一样的。有没有办法让使用相同口令的用户存储不同的MD5呢--如果假定用户无法修改登录名，就可以通过把登录名作为Salt的一部分来计算MD5，从而实现相同口令的用户也存储不同的MD5。</p>
<h2 id="hmac">hmac</h2>
<p>通过哈希算法，我们可以验证一段数据是否有效，方法就是对比该数据的哈希值，例如，判断用户口令是否正确，我们用保存在数据库中的password_md5对比计算md5(password)的结果，如果一致，用户输入的口令就是正确的。</p>
<p>为了防止黑客通过彩虹表根据哈希值反推原始口令，在计算哈希的时候，不能仅针对原始输入计算，需要增加一个salt来使得相同的输入也能得到不同的哈希，这样，大大增加了黑客破解的难度。</p>
<p>如果salt是我们自己随机生成的，通常我们计算MD5时采用md5(message + salt)。但实际上，把salt看做一个“口令”，加salt的哈希就是：计算一段message的哈希时，根据不通口令计算出不同的哈希。<strong>要验证哈希值，必须同时提供正确的口令。</strong></p>
<p><strong>这实际上就是Hmac算法：Keyed-Hashing for Message Authentication</strong>。它通过一个标准算法，在计算哈希的过程中，<strong>把key混入计算过程中。</strong></p>
<p>和我们自定义的加salt算法不同，Hmac算法针对所有哈希算法都通用，无论是MD5还是SHA-1。采用Hmac替代我们自己的salt算法，可以使程序算法更标准化，也更安全。</p>
<p>Python自带的hmac模块实现了标准的Hmac算法。我们来看看如何使用hmac实现带key的哈希。</p>
<p>我们首先需要准备待计算的原始消息message，随机key，哈希算法，这里采用MD5，使用hmac的代码如下：</p>
<pre><code>&gt;&gt;&gt; import hmac
&gt;&gt;&gt; message = b'Hello, world!'
&gt;&gt;&gt; key = b'secret'
&gt;&gt;&gt; h = hmac.new(key, message, digestmod='MD5')
&gt;&gt;&gt; # 如果消息很长，可以多次调用h.update(msg)
&gt;&gt;&gt; h.hexdigest()
'fa4ee7d173f2d97ee79022d1a7355bcf'
</code></pre>
<p>可见使用hmac和普通hash算法非常类似。hmac输出的长度和原始哈希算法的长度一致。需要注意<strong>传入的key和message都是bytes类型，str类型需要首先编码为bytes。</strong></p>
<h2 id="itertools">itertools</h2>
<p>Python的内建模块itertools提供了非常有用的用于<strong>操作迭代对象</strong>的函数。</p>
<p>itertools模块提供的全部是<strong>处理迭代功能的函数</strong>，它们的<strong>返回值不是list，而是Iterator</strong>，<strong>只有用for循环迭代的时候才真正计算</strong>。</p>
<p>首先，我们看看itertools提供的几个“无限”迭代器：</p>
<p><strong>count()</strong></p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; natuals = itertools.count(1)
&gt;&gt;&gt; for n in natuals:
...     print(n)
...
1
2
3
...
</code></pre>
<p>因为count()会创建一个<strong>无限的迭代器</strong>，所以上述代码会打印出自然数序列，根本停不下来，<strong>只能按Ctrl+C退出</strong>。</p>
<p><strong>cycle()</strong> 会把传入的一个序列无限重复下去：</p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; cs = itertools.cycle('ABC') # 注意字符串也是序列的一种
&gt;&gt;&gt; for c in cs:
...     print(c)
...
'A'
'B'
'C'
'A'
'B'
'C'
...
</code></pre>
<p>同样停不下来。</p>
<p><strong>repeat()</strong> 负责把一个元素无限重复下去，不过<strong>如果提供第二个参数就可以限定重复次数</strong>：</p>
<pre><code>&gt;&gt;&gt; ns = itertools.repeat('A', 3)
&gt;&gt;&gt; for n in ns:
...     print(n)
...
A
A
A
</code></pre>
<p>**无限序列只有在for迭代时才会无限地迭代下去，如果只是创建了一个迭代对象，它不会事先把无限个元素生成出来，**事实上也不可能在内存中创建无限多个元素。</p>
<p>无限序列虽然可以无限迭代下去，但是通常我们会<strong>通过takewhile()等函数根据条件判断来截取出一个有限的序列</strong>：</p>
<pre><code>&gt;&gt;&gt; natuals = itertools.count(1)
&gt;&gt;&gt; ns = itertools.takewhile(lambda x: x &lt;= 10, natuals)
&gt;&gt;&gt; list(ns)
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
</code></pre>
<p>itertools提供的几个迭代器操作函数更加有用：</p>
<h3 id="chain">chain()</h3>
<p>chain()可以把一组迭代对象串联起来，形成一个更大的迭代器：</p>
<pre><code>
&gt;&gt;&gt; for c in itertools.chain('ABC', 'XYZ'):
...     print(c)
# 迭代效果：'A' 'B' 'C' 'X' 'Y' 'Z'
</code></pre>
<h3 id="groupby">groupby()</h3>
<p>groupby()把迭代器中相邻的重复元素挑出来放在一起：</p>
<pre><code>&gt;&gt;&gt; for key, group in itertools.groupby('AAABBBCCAAA'):
...     print(key, list(group))
...
A ['A', 'A', 'A']
B ['B', 'B', 'B']
C ['C', 'C']
A ['A', 'A', 'A']
</code></pre>
<p>实际上<strong>挑选规则是通过函数完成的</strong>，只要作用于函数的两个元素返回的值相等，这两个元素就被认为是在一组的，而<strong>函数返回值作为组的key</strong>。如果我们要忽略大小写分组，就可以让元素'A'和'a'都返回相同的key：</p>
<pre><code>&gt;&gt;&gt; for key, group in itertools.groupby('AaaBBbcCAAa', lambda c: c.upper()):
...     print(key, list(group))
...

A ['A', 'a', 'a']
B ['B', 'B', 'b']
C ['c', 'C']
A ['A', 'A', 'a']
</code></pre>
<h2 id="contextlib">contextlib</h2>
<p>在Python中，读写文件这样的资源要特别注意，必须在使用完毕后正确关闭它们。正确关闭文件资源的一个方法是使用try...finally：</p>
<pre><code>try:
    f = open('/path/to/file', 'r')
    f.read()
finally:
    if f:
        f.close()
</code></pre>
<p>写try...finally非常繁琐。Python的with语句允许我们非常方便地使用资源，而不必担心资源没有关闭，所以上面的代码可以简化为：</p>
<pre><code>with open('/path/to/file', 'r') as f:
    f.read()
</code></pre>
<p>并不是只有open()函数返回的fp对象才能使用with语句。<strong>实际上，任何对象，只要正确实现了上下文管理，就可以用于with语句</strong>。</p>
<p>实现<strong>上下文管理</strong>是通过<code>__enter__和__exit__</code>这两个方法实现的。例如，下面的class实现了这两个方法：</p>
<pre><code>class Query(object):

    def __init__(self, name):
        self.name = name

    def __enter__(self):
        print('Begin')
        return self
    
    def __exit__(self, exc_type, exc_value, traceback):
        if exc_type:
            print('Error')
        else:
            print('End')
    
    def query(self):
        print('Query info about %s...' % self.name)
</code></pre>
<p>这样我们就可以把自己写的资源对象用于with语句：</p>
<pre><code>with Query('Bob') as q:
    q.query()
</code></pre>
<h3 id="contextmanager">@contextmanager</h3>
<p>编写__enter__和__exit__仍然很繁琐，因此Python的标准库contextlib提供了更简单的写法，上面的代码可以改写如下：</p>
<pre><code>from contextlib import contextmanager

class Query(object):

    def __init__(self, name):
        self.name = name

    def query(self):
        print('Query info about %s...' % self.name)

@contextmanager
def create_query(name):
    print('Begin')
    q = Query(name)
    yield q
    print('End')
</code></pre>
<p>@contextmanager这个decorator接受一个generator，用yield语句把<code>with ... as var</code>把变量输出出去，然后，with语句就可以正常地工作了：</p>
<pre><code>with create_query('Bob') as q:
    q.query()
</code></pre>
<p>很多时候，我们希望在某段代码执行前后自动执行特定代码，也可以用@contextmanager实现。例如：</p>
<pre><code>@contextmanager
def tag(name):
    print(&quot;&lt;%s&gt;&quot; % name)
    yield
    print(&quot;&lt;/%s&gt;&quot; % name)

with tag(&quot;h1&quot;):
    print(&quot;hello&quot;)
    print(&quot;world&quot;)
</code></pre>
<p>上述代码执行结果为：</p>
<pre><code>&lt;h1&gt;
hello
world
&lt;/h1&gt;
</code></pre>
<p>代码的执行顺序是：</p>
<ol>
<li>with语句首先执行yield之前的语句，因此打印出<code>&lt;h1&gt;</code>；</li>
<li>yield调用会执行with语句内部的所有语句，因此打印出hello和world；</li>
<li>最后执行yield之后的语句，打印出<code>&lt;/h1&gt;</code>。<br>
因此，@contextmanager让我们通过编写generator来简化上下文管理。</li>
</ol>
<h3 id="closing">@closing</h3>
<p>如果一个对象没有实现上下文，我们就不能把它用于with语句。这个时候，可以用<strong>closing()来把该对象变为上下文对象</strong>。例如，用with语句使用urlopen()：</p>
<pre><code>from contextlib import closing
from urllib.request import urlopen

with closing(urlopen('https://www.python.org')) as page:
    for line in page:
        print(line)
</code></pre>
<p><strong>closing也是一个经过@contextmanager装饰的generator</strong>，这个generator编写起来其实非常简单：</p>
<pre><code>@contextmanager
def closing(thing):
    try:
        yield thing
    finally:
        thing.close()
</code></pre>
<p>它的作用就是把任意对象变为上下文对象，并支持with语句。</p>
<h2 id="urllib">urllib</h2>
<p>urllib提供了一系列用于<strong>操作URL的功能</strong>。</p>
<h3 id="get">Get</h3>
<p>urllib的request模块可以非常方便地抓取URL内容，也就是<strong>发送一个GET请求到指定的页面，然后返回HTTP的响应</strong>：</p>
<p>例如，对豆瓣的一个URLhttps://api.douban.com/v2/book/2129650进行抓取，并返回响应：</p>
<pre><code>from urllib import request

with request.urlopen('https://api.douban.com/v2/book/2129650') as f:
    data = f.read()
    print('Status:', f.status, f.reason)
    for k, v in f.getheaders():
        print('%s: %s' % (k, v))
    print('Data:', data.decode('utf-8'))
</code></pre>
<p>可以看到HTTP响应的头和JSON数据：</p>
<pre><code>Status: 200 OK
Server: nginx
Date: Tue, 26 May 2015 10:02:27 GMT
Content-Type: application/json; charset=utf-8
Content-Length: 2049
Connection: close
Expires: Sun, 1 Jan 2006 01:00:00 GMT
Pragma: no-cache
Cache-Control: must-revalidate, no-cache, private
X-DAE-Node: pidl1
Data: {&quot;rating&quot;:{&quot;max&quot;:10,&quot;numRaters&quot;:16,&quot;average&quot;:&quot;7.4&quot;,&quot;min&quot;:0},&quot;subtitle&quot;:&quot;&quot;,&quot;author&quot;:[&quot;廖雪峰编著&quot;],&quot;pubdate&quot;:&quot;2007-6&quot;,...}
</code></pre>
<p>如果我们要想模拟浏览器发送GET请求，就需要使用Request对象，通过往Request对象添加HTTP头，我们就可以把请求伪装成浏览器。例如，模拟iPhone 6去请求豆瓣首页：</p>
<pre><code>from urllib import request

req = request.Request('http://www.douban.com/')
req.add_header('User-Agent', 'Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25')
with request.urlopen(req) as f:
    print('Status:', f.status, f.reason)
    for k, v in f.getheaders():
        print('%s: %s' % (k, v))
    print('Data:', f.read().decode('utf-8'))
</code></pre>
<p>这样豆瓣会返回适合iPhone的移动版网页：</p>
<pre><code>...
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0&quot;&gt;
    &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;
    &lt;link rel=&quot;apple-touch-icon&quot; sizes=&quot;57x57&quot; href=&quot;http://img4.douban.com/pics/cardkit/launcher/57.png&quot; /&gt;
...
</code></pre>
<h3 id="post">Post</h3>
<p>如果要以POST发送一个请求，<strong>只需要把参数data以bytes形式传入</strong>。</p>
<p>我们模拟一个微博登录，先读取登录的邮箱和口令，然后按照weibo.cn的登录页的格式以username=xxx&amp;password=xxx的编码传入：</p>
<pre><code>from urllib import request, parse

print('Login to weibo.cn...')
email = input('Email: ')
passwd = input('Password: ')
login_data = parse.urlencode([
    ('username', email),
    ('password', passwd),
    ('entry', 'mweibo'),
    ('client_id', ''),
    ('savestate', '1'),
    ('ec', ''),
    ('pagerefer', 'https://passport.weibo.cn/signin/welcome?entry=mweibo&amp;r=http%3A%2F%2Fm.weibo.cn%2F')
])

req = request.Request('https://passport.weibo.cn/sso/login')
req.add_header('Origin', 'https://passport.weibo.cn')
req.add_header('User-Agent', 'Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25')
req.add_header('Referer', 'https://passport.weibo.cn/signin/login?entry=mweibo&amp;res=wel&amp;wm=3349&amp;r=http%3A%2F%2Fm.weibo.cn%2F')

with request.urlopen(req, data=login_data.encode('utf-8')) as f:
    print('Status:', f.status, f.reason)
    for k, v in f.getheaders():
        print('%s: %s' % (k, v))
    print('Data:', f.read().decode('utf-8'))
</code></pre>
<p>如果登录成功，我们获得的响应如下：</p>
<pre><code>Status: 200 OK
Server: nginx/1.2.0
...
Set-Cookie: SSOLoginState=1432620126; path=/; domain=weibo.cn
...
Data: {&quot;retcode&quot;:20000000,&quot;msg&quot;:&quot;&quot;,&quot;data&quot;:{...,&quot;uid&quot;:&quot;1658384301&quot;}}
</code></pre>
<p>如果登录失败，我们获得的响应如下：</p>
<pre><code>...
Data: {&quot;retcode&quot;:50011015,&quot;msg&quot;:&quot;\u7528\u6237\u540d\u6216\u5bc6\u7801\u9519\u8bef&quot;,&quot;data&quot;:{&quot;username&quot;:&quot;example@python.org&quot;,&quot;errline&quot;:536}}
Handler
</code></pre>
<p>如果还需要更复杂的控制，比如<strong>通过一个Proxy去访问网站，我们需要利用ProxyHandler来处理</strong>，示例代码如下：</p>
<pre><code>proxy_handler = urllib.request.ProxyHandler({'http': 'http://www.example.com:3128/'})
proxy_auth_handler = urllib.request.ProxyBasicAuthHandler()
proxy_auth_handler.add_password('realm', 'host', 'username', 'password')
opener = urllib.request.build_opener(proxy_handler, proxy_auth_handler)
with opener.open('http://www.example.com/login.html') as f:
    pass
</code></pre>
<p><strong>小结</strong></p>
<p>urllib提供的功能就是利用程序去执行各种HTTP请求。<strong>如果要模拟浏览器完成特定功能，需要把请求伪装成浏览器。伪装的方法是先监控浏览器发出的请求，再根据浏览器的请求头来伪装，User-Agent头就是用来标识浏览器的</strong>。</p>
<h2 id="xml">XML</h2>
<p>ML虽然比JSON复杂，在Web中应用也不如以前多了，不过仍有很多地方在用，所以，有必要了解如何操作XML。</p>
<p>DOM vs SAX</p>
<p>操作XML有两种方法：DOM和SAX。</p>
<ol>
<li>DOM会把整个XML读入内存，解析为树，因此占用内存大，解析慢，优点是可以任意遍历树的节点。</li>
<li>SAX是流模式，边读边解析，占用内存小，解析快，缺点是我们需要自己处理事件。</li>
</ol>
<p>正常情况下，<strong>优先考虑SAX，因为DOM实在太占内存</strong>。</p>
<p>在Python中使用SAX解析XML非常简洁，通常我们关心的事件是start_element，end_element和char_data，准备好这3个函数，然后就可以解析xml了。</p>
<p>举个例子，当SAX解析器读到一个节点时：</p>
<pre><code>&lt;a href=&quot;/&quot;&gt;python&lt;/a&gt;
</code></pre>
<p>会产生3个事件：</p>
<ol>
<li>
<p>start_element事件，在读取<code>&lt;a href=&quot;/&quot;&gt;</code>时；</p>
</li>
<li>
<p>char_data事件，在读取python时；</p>
</li>
<li>
<p>end_element事件，在读取<code>&lt;/a&gt;</code>时。</p>
</li>
</ol>
<p>用代码实验一下：</p>
<pre><code>from xml.parsers.expat import ParserCreate

class DefaultSaxHandler(object):
    def start_element(self, name, attrs):
        print('sax:start_element: %s, attrs: %s' % (name, str(attrs)))

    def end_element(self, name):
        print('sax:end_element: %s' % name)

    def char_data(self, text):
        print('sax:char_data: %s' % text)

xml = r'''&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;ol&gt;
    &lt;li&gt;&lt;a href=&quot;/python&quot;&gt;Python&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;/ruby&quot;&gt;Ruby&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
'''

handler = DefaultSaxHandler()
parser = ParserCreate()
parser.StartElementHandler = handler.start_element
parser.EndElementHandler = handler.end_element
parser.CharacterDataHandler = handler.char_data
parser.Parse(xml)
</code></pre>
<p>需要注意的是读取一大段字符串时，CharacterDataHandler可能被多次调用，所以需要自己保存起来，在EndElementHandler里面再合并。</p>
<p>除了解析XML外，如何生成XML呢？99%的情况下需要生成的XML结构都是非常简单的，因此，最简单也是最有效的生成XML的方法是拼接字符串：</p>
<pre><code>L = []
L.append(r'&lt;?xml version=&quot;1.0&quot;?&gt;')
L.append(r'&lt;root&gt;')
L.append(encode('some &amp; data'))
L.append(r'&lt;/root&gt;')
return ''.join(L)
</code></pre>
<p>如果要生成复杂的XML呢，此时建议不要用XML，改成JSON。</p>
<p><strong>小结</strong></p>
<p>解析XML时，注意找出自己感兴趣的节点，响应事件时，把节点数据保存起来。解析完毕后，就可以处理数据。</p>
<h2 id="htmlparser">HTMLParser</h2>
<p>如果我们要编写一个搜索引擎，第一步是用爬虫把目标网站的页面抓下来，第二步就是解析该HTML页面，看看里面的内容到底是新闻、图片还是视频。</p>
<p>假设第一步已经完成了，第二步解析HTML</p>
<p>HTML本质上是XML的子集，但是HTML的语法没有XML那么严格，所以<strong>不能用标准的DOM或SAX来解析HTML</strong>。</p>
<p>好在Python提供了HTMLParser来非常方便地解析HTML，只需简单几行代码：</p>
<pre><code>from html.parser import HTMLParser
from html.entities import name2codepoint

class MyHTMLParser(HTMLParser):

    def handle_starttag(self, tag, attrs):
        print('&lt;%s&gt;' % tag)

    def handle_endtag(self, tag):
        print('&lt;/%s&gt;' % tag)

    def handle_startendtag(self, tag, attrs):
        print('&lt;%s/&gt;' % tag)

    def handle_data(self, data):
        print(data)

    def handle_comment(self, data):
        print('&lt;!--', data, '--&gt;')

    def handle_entityref(self, name):
        print('&amp;%s;' % name)

    def handle_charref(self, name):
        print('&amp;#%s;' % name)

parser = MyHTMLParser()
parser.feed('''&lt;html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
&lt;!-- test html parser --&gt;
    &lt;p&gt;Some &lt;a href=\&quot;#\&quot;&gt;html&lt;/a&gt; HTML&amp;nbsp;tutorial...&lt;br&gt;END&lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;''')
</code></pre>
<p>feed()方法可以多次调用，也就是不一定一次把整个HTML字符串都塞进去，可以一部分一部分塞进去。</p>
<p>特殊字符有两种，一种是英文表示的<code>&amp;nbsp</code>;，一种是数字表示的<code>&amp;#1234;</code>，这两种字符都可以通过Parser解析出来。</p>
<p><strong>小结</strong></p>
<p>利用HTMLParser，可以把网页中的文本、图像等解析出来。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python - 正则表达式]]></title>
        <id>https://lixin-scut.github.io//post/python-zheng-ze-biao-da-shi</id>
        <link href="https://lixin-scut.github.io//post/python-zheng-ze-biao-da-shi">
        </link>
        <updated>2020-05-13T01:16:34.000Z</updated>
        <content type="html"><![CDATA[<p>字符串是编程时涉及到的最多的一种数据结构，对字符串进行操作的需求几乎无处不在。比如判断一个字符串是否是合法的Email地址，虽然可以编程提取@前后的子串，再分别判断是否是单词和域名，但这样做不但麻烦，而且代码难以复用。</p>
<p>正则表达式是一种用来匹配字符串的强有力的武器。它的设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的。</p>
<p>所以我们判断一个字符串是否是合法的Email的方法是：</p>
<ol>
<li>
<p>创建一个匹配Email的正则表达式；</p>
</li>
<li>
<p>用该正则表达式去匹配用户的输入来判断是否合法。</p>
</li>
</ol>
<p>因为正则表达式也是用字符串表示的，所以，我们要首先了解如何用字符来描述字符。</p>
<p>在正则表达式中，如果直接给出字符，就是精确匹配。<strong>用\d可以匹配一个数字</strong>，<strong>\w可以匹配一个字母或数字</strong>，所以：</p>
<ol>
<li>
<p>'00\d'可以匹配'007'，但无法匹配'00A'；</p>
</li>
<li>
<p>'\d\d\d'可以匹配'010'；</p>
</li>
<li>
<p>'\w\w\d'可以匹配'py3'；</p>
</li>
</ol>
<p><strong><code>.</code>可以匹配任意字符</strong>，所以：</p>
<p>'py.'可以匹配'pyc'、'pyo'、'py!'等等。</p>
<p>要匹配变长的字符，在正则表达式中，<strong>用<code>*</code>表示任意个字符（包括0个），用+表示至少一个字符，用?表示0个或1个字符，用{n}表示n个字符，用{n,m}表示n-m个字符：</strong></p>
<p>来看一个复杂的例子：\d{3}\s+\d{3,8}。</p>
<p>我们来从左到右解读一下：</p>
<p>\d{3}表示匹配3个数字，例如'010'；</p>
<p>\s可以匹配一个空格（也包括Tab等空白符），<strong>所以\s+表示至少有一个空格</strong>，例如匹配' '，' '等；</p>
<p>\d{3,8}表示3-8个数字，例如'1234567'。</p>
<p>综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。</p>
<p>如果要匹配'010-12345'这样的号码呢？由于'-'是特殊字符，在正则表达式中，要用''转义，所以，上面的正则是\d{3}-\d{3,8}。</p>
<p>但是，仍然无法匹配'010 - 12345'，因为带有空格。所以我们需要更复杂的匹配方式。</p>
<h3 id="进阶">进阶</h3>
<p>要做更精确地匹配，<strong>可以用[]表示范围</strong>，比如：</p>
<ol>
<li>
<p><code>[0-9a-zA-Z\_]</code>可以匹配<strong>一个</strong>数字、字母或者下划线；</p>
</li>
<li>
<p><code>[0-9a-zA-Z\_]+</code>可以匹配<strong>至少</strong>由一个数字、字母或者下划线组成的字符串，比如'a100'，'0_Z'，'Py3000'等等；</p>
</li>
<li>
<p><code>[a-zA-Z\_][0-9a-zA-Z\_]*</code>可以匹配由字母或下划线开头，后接<strong>任意个</strong>由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量；</p>
</li>
<li>
<p><code>[a-zA-Z\_][0-9a-zA-Z\_]{0, 19}</code>更精确地限制了变量的长度是<strong>1-20个</strong>字符（前面1个字符+后面最多19个字符）。</p>
</li>
</ol>
<p><code>A|B</code>可以匹配<strong>A或B</strong>，所以(P|p)ython可以匹配'Python'或者'python'。</p>
<p><code>^</code>表示行的开头，<code>^\d</code>表示必须以数字开头。</p>
<p><code>$</code>表示行的结束，<code>\d$</code>表示必须以数字结束。</p>
<p>你可能注意到了，py也可以匹配'python'，但是<strong>加上^py$就变成了整行匹配，就只能匹配'py'了</strong>。</p>
<h3 id="re模块">re模块</h3>
<p>有了准备知识，我们就可以在Python中使用正则表达式了。Python提供<strong>re模块，包含所有正则表达式的功能</strong>。</p>
<p><strong>由于Python的字符串本身也用\转义</strong>，所以要特别注意：</p>
<pre><code>
s = 'ABC\\-001' # Python的字符串
# 对应的正则表达式字符串变成：
# 'ABC\-001'

</code></pre>
<p>因此我们<strong>强烈建议使用Python的r前缀</strong>，就不用考虑转义的问题了：</p>
<pre><code>
s = r'ABC\-001' # Python的字符串
# 对应的正则表达式字符串不变：
# 'ABC\-001'

</code></pre>
<p>先看看如何判断正则表达式是否匹配：</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; re.match(r'^\d{3}\-\d{3,8}$', '010-12345')
&lt;_sre.SRE_Match object; span=(0, 9), match='010-12345'&gt;
&gt;&gt;&gt; re.match(r'^\d{3}\-\d{3,8}$', '010 12345')
&gt;&gt;&gt;
</code></pre>
<p>match()方法判断是否匹配，<strong>如果匹配成功，返回一个Match对象，否则返回None。</strong></p>
<p>常见的判断方法就是：</p>
<pre><code>test = '用户输入的字符串'
if re.match(r'正则表达式', test):
    print('ok')
else:
    print('failed')
</code></pre>
<h3 id="切分字符串">切分字符串</h3>
<p>用正则表达式切分字符串比用固定的字符更灵活，请看正常的切分代码：</p>
<pre><code>&gt;&gt;&gt; 'a b   c'.split(' ')
['a', 'b', '', '', 'c']
</code></pre>
<p>嗯，<strong>无法识别连续的空格</strong>，用正则表达式试试：</p>
<pre><code>&gt;&gt;&gt; re.split(r'\s+', 'a b   c')
['a', 'b', 'c']
</code></pre>
<p><strong>无论多少个空格都可以正常分割</strong>。</p>
<p>加入<code>,</code>试试：</p>
<pre><code>&gt;&gt;&gt; re.split(r'[\s\,]+', 'a,b, c  d')
['a', 'b', 'c', 'd']
</code></pre>
<p>再加入<code>;</code>试试：</p>
<pre><code>&gt;&gt;&gt; re.split(r'[\s\,\;]+', 'a,b;; c  d')
['a', 'b', 'c', 'd']
</code></pre>
<p>用正则表达式来把不规范的输入转化成正确的数组。</p>
<h3 id="分组">分组</h3>
<p>除了简单地判断是否匹配之外，正则表达式还有<strong>提取子串的强大功能</strong>。<strong>用()表示的就是要提取的分组（Group）</strong>。比如：</p>
<p><code>^(\d{3})-(\d{3,8})$</code>分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：</p>
<pre><code>&gt;&gt;&gt; m = re.match(r'^(\d{3})-(\d{3,8})$', '010-12345')
&gt;&gt;&gt; m
&lt;_sre.SRE_Match object; span=(0, 9), match='010-12345'&gt;
&gt;&gt;&gt; m.group(0)
'010-12345'
&gt;&gt;&gt; m.group(1)
'010'
&gt;&gt;&gt; m.group(2)
'12345'
如果正则表达式中定义了组，就可以在Match对象上用group()方法提取出子串来。
</code></pre>
<p>注意到<strong>group(0)永远是原始字符串</strong>，group(1)、group(2)……表示第1、2、……个子串。</p>
<p>提取子串非常有用。来看一个更厉害的例子：</p>
<pre><code>&gt;&gt;&gt; t = '19:05:30'
&gt;&gt;&gt; m = re.match(r'^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$', t)
&gt;&gt;&gt; m.groups()
('19', '05', '30')
</code></pre>
<p>这个正则表达式可以直接识别合法的时间。但是有些时候，用正则表达式也无法做到完全验证，比如识别日期：</p>
<pre><code>'^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$'
</code></pre>
<p>对于'2-30'，'4-31'这样的非法日期，用正则还是识别不了，或者说写出来非常困难，这时就需要程序配合识别了。</p>
<h3 id="贪婪匹配">贪婪匹配</h3>
<p>最后需要特别指出的是，<strong>正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符</strong>。举例如下，匹配出数字后面的0：</p>
<pre><code>&gt;&gt;&gt; re.match(r'^(\d+)(0*)$', '102300').groups()
('102300', '')
</code></pre>
<p>由于\d+采用贪婪匹配，直接把后面的0全部匹配了，结果<code>0*</code>只能匹配空字符串了。</p>
<p>必须让\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，<strong>加个?就可以让\d+采用非贪婪匹配</strong>：</p>
<pre><code>&gt;&gt;&gt; re.match(r'^(\d+?)(0*)$', '102300').groups()
('1023', '00')
</code></pre>
<h3 id="编译">编译</h3>
<p>当我们在Python中使用正则表达式时，re模块内部会干两件事情：</p>
<ol>
<li>
<p>编译正则表达式，如果正则表达式的字符串本身不合法，会报错；</p>
</li>
<li>
<p>用编译后的正则表达式去匹配字符串。</p>
</li>
</ol>
<p>如果一个正则表达式要重复使用几千次，出于效率的考虑，我们<strong>可以预编译re.compile该正则表达式，接下来重复使用时就不需要编译这个步骤了</strong>，直接匹配：</p>
<pre><code>
&gt;&gt;&gt; import re
# 编译:
&gt;&gt;&gt; re_telephone = re.compile(r'^(\d{3})-(\d{3,8})$')
# 使用：
&gt;&gt;&gt; re_telephone.match('010-12345').groups()
('010', '12345')
&gt;&gt;&gt; re_telephone.match('010-8086').groups()
('010', '8086')

</code></pre>
<p><strong>编译后生成Regular Expression对象</strong>，由于该对象自己包含了正则表达式，所以调用对应的方法时不用给出正则字符串。</p>
<h3 id="练习">练习</h3>
<p>请尝试写一个验证Email地址的正则表达式。版本一应该可以验证出类似的Email：</p>
<pre><code>
someone@gmail.com
bill.gates@microsoft.com
# -*- coding: utf-8 -*-
import re
def is_valid_email(addr):
    if re.match(r'[0-9a-zA-Z\.]*@[a-z]*.com',addr):
        return True
    else:
        return False
# 测试:
assert is_valid_email('someone@gmail.com')
assert is_valid_email('bill.gates@microsoft.com')
assert not is_valid_email('bob#example.com')
assert not is_valid_email('mr-bob@example.com')
print('ok')

</code></pre>
<p>版本二可以提取出带名字的Email地址：</p>
<pre><code>&lt;Tom Paris&gt; tom@voyager.org =&gt; Tom Paris
bob@example.com =&gt; bob
# -*- coding: utf-8 -*-
import re
def name_of_email(addr):
    return re.match(r'\&lt;?([a-zA-Z\s]*)\&gt;?[a-zA-Z\s]*@.*', addr).group(1)
    # return re.match(r'^\&lt;?(\w+\s*\w+)\&gt;?\s*\w*\@\w+\.\w+$', addr).group(1)
# 测试:
assert name_of_email('&lt;Tom Paris&gt; tom@voyager.org') == 'Tom Paris'
assert name_of_email('tom@voyager.org') == 'tom'
print('ok')
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python - 进程和线程	]]></title>
        <id>https://lixin-scut.github.io//post/python-jin-cheng-he-xian-cheng</id>
        <link href="https://lixin-scut.github.io//post/python-jin-cheng-he-xian-cheng">
        </link>
        <updated>2020-05-13T00:12:41.000Z</updated>
        <content type="html"><![CDATA[<p>现在，多核CPU已经非常普及了，但是，即使过去的单核CPU，也可以执行多任务。由于CPU执行代码都是顺序执行的，那么，单核CPU是怎么执行多任务的呢？</p>
<p>答案就是操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。</p>
<p>真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。</p>
<p>对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。</p>
<p>有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。</p>
<p>由于每个进程至少要干一件事，所以，一个进程至少有一个线程。当然，像Word这种复杂的进程可以有多个线程，多个线程可以同时执行，多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。当然，真正地同时执行多线程需要多核CPU才可能实现。</p>
<p>前面编写的所有的Python程序，都是执行单任务的进程，也就是只有一个线程。如果我们要同时执行多个任务怎么办？</p>
<p>有两种解决方案：</p>
<p>一种是启动多个进程，每个进程虽然只有一个线程，但多个进程可以一块执行多个任务。</p>
<p>还有一种方法是启动一个进程，在一个进程内启动多个线程，这样，多个线程也可以一块执行多个任务。</p>
<p>当然还有第三种方法，就是启动多个进程，每个进程再启动多个线程，这样同时执行的任务就更多了，当然这种模型更复杂，实际很少采用。</p>
<p>总结一下就是，多任务的实现有3种方式：</p>
<ol>
<li>多进程模式；</li>
<li>多线程模式；</li>
<li>多进程+多线程模式。<br>
同时执行多个任务通常各个任务之间并不是没有关联的，而是需要相互通信和协调，有时，任务1必须暂停等待任务2完成后才能继续执行，有时，任务3和任务4又不能同时执行，所以，多进程和多线程的程序的复杂度要远远高于我们前面写的单进程单线程的程序。</li>
</ol>
<p>因为复杂度高，调试困难，所以，不是迫不得已，我们也不想编写多任务。但是，有很多时候，没有多任务还真不行。想想在电脑上看电影，就必须由一个线程播放视频，另一个线程播放音频，否则，单线程实现的话就只能先把视频播放完再播放音频，或者先把音频播放完再播放视频，这显然是不行的。</p>
<p>Python既支持多进程，又支持多线程，我们会讨论如何编写这两种多任务程序。</p>
<h3 id="小结">小结</h3>
<p>线程是最小的执行单元，而进程由至少一个线程组成。如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间。</p>
<p>多进程和多线程的程序涉及到同步、数据共享的问题，编写起来更复杂。</p>
<h2 id="多进程">多进程</h2>
<p>要让Python程序实现多进程（multiprocessing），我们先了解操作系统的相关知识。</p>
<p>Unix/Linux操作系统提供了一个fork()系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，但是<strong>fork()调用一次，返回两次</strong>，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，<strong>分别在父进程和子进程内返回</strong>。</p>
<p><strong>子进程永远返回0，而父进程返回子进程的ID</strong>。这样做的理由是，一个父进程可以fork出很多子进程，所以，<strong>父进程要记下每个子进程的ID</strong>，而**子进程只需要调用getppid()**就可以拿到父进程的ID。</p>
<p>Python的<strong>os模块封装了常见的系统调用，其中就包括fork</strong>，可以在Python程序中轻松创建子进程：</p>
<pre><code>import os

print('Process (%s) start...' % os.getpid())
# Only works on Unix/Linux/Mac:
pid = os.fork()
if pid == 0:
    print('I am child process (%s) and my parent is %s.' % (os.getpid(), os.getppid()))
else:
    print('I (%s) just created a child process (%s).' % (os.getpid(), pid))
</code></pre>
<p>运行结果如下：</p>
<pre><code>Process (876) start...
I (876) just created a child process (877).
I am child process (877) and my parent is 876.
</code></pre>
<p>由于Windows没有fork调用，上面的代码在Windows上无法运行。而Mac系统是基于BSD（Unix的一种）内核，所以，在Mac下运行是没有问题的</p>
<p>有了fork调用，一个进程在接到新任务时就可以复制出一个子进程来处理新任务，常见的Apache服务器就是由父进程监听端口，每当有新的http请求时，就fork出子进程来处理新的http请求。</p>
<h3 id="multiprocessing">multiprocessing</h3>
<p>如果你打算编写多进程的服务程序，Unix/Linux无疑是正确的选择。由于Windows没有fork调用，难道在Windows上无法用Python编写多进程的程序？</p>
<p>由于Python是跨平台的，自然也应该提供一个跨平台的多进程支持。</p>
<p><strong>multiprocessing模块就是跨平台版本的多进程模块</strong>。</p>
<p>multiprocessing模块<strong>提供了一个Process类来代表一个进程对象</strong></p>
<p>下面的例子演示了启动一个子进程并等待其结束：</p>
<pre><code>
from multiprocessing import Process
import os

# 子进程要执行的代码
def run_proc(name):
    print('Run child process %s (%s)...' % (name, os.getpid()))

if __name__=='__main__':
    print('Parent process %s.' % os.getpid())
    p = Process(target=run_proc, args=('test',))
    print('Child process will start.')
    p.start()
    p.join()
    print('Child process end.')
		
</code></pre>
<p>执行结果如下：</p>
<pre><code>Parent process 928.
Child process will start.
Run child process test (929)...
Process end.
</code></pre>
<p>创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动，这样创建进程比fork()还要简单。</p>
<p><strong>join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步</strong>。</p>
<h3 id="pool">Pool</h3>
<p>如果要启动大量的子进程，可以<strong>用进程池的方式批量创建子进程</strong>：</p>
<pre><code>from multiprocessing import Pool
import os, time, random

def long_time_task(name):
    print('Run task %s (%s)...' % (name, os.getpid()))
    start = time.time()
    time.sleep(random.random() * 3)
    end = time.time()
    print('Task %s runs %0.2f seconds.' % (name, (end - start)))

if __name__=='__main__':
    print('Parent process %s.' % os.getpid())
    p = Pool(4)
    for i in range(5):
        p.apply_async(long_time_task, args=(i,))
    print('Waiting for all subprocesses done...')
    p.close()
    p.join()
    print('All subprocesses done.')
</code></pre>
<p>执行结果如下：</p>
<pre><code>Parent process 669.
Waiting for all subprocesses done...
Run task 0 (671)...
Run task 1 (672)...
Run task 2 (673)...
Run task 3 (674)...
Task 2 runs 0.14 seconds.
Run task 4 (673)...
Task 1 runs 0.27 seconds.
Task 3 runs 0.86 seconds.
Task 0 runs 1.41 seconds.
Task 4 runs 1.91 seconds.
All subprocesses done.
</code></pre>
<p>代码解读：</p>
<ol>
<li>对<strong>Pool对象调用join()方法</strong>会等待<strong>所有子进程</strong>执行完毕</li>
<li><strong>调用join()之前必须先调用close()</strong></li>
<li><strong>调用close()之后就不能继续添加新的Process了</strong>。</li>
</ol>
<p>请注意输出的结果，task 0，1，2，3是立刻执行的，而<strong>task 4要等待前面某个task完成后才执行，这是因为Pool的默认大小在我的电脑上是4</strong>，因此，最多同时执行4个进程。这是Pool有意设计的限制，并不是操作系统的限制。如果改成：</p>
<pre><code>p = Pool(5)
</code></pre>
<p>就可以同时跑5个进程。</p>
<p>由于Pool的默认大小是CPU的核数，如果你拥有8核CPU，你要提交至少9个子进程才能看到上面的等待效果。</p>
<h3 id="子进程">子进程</h3>
<p>很多时候，<strong>子进程并不是自身，而是一个外部进程</strong>。我们创建了子进程后，<strong>还需要控制子进程的输入和输出</strong>。</p>
<p><strong>subprocess模块</strong>可以让我们非常方便地<strong>启动一个子进程，然后控制其输入和输出。</strong></p>
<p>下面的例子演示了如何在Python代码中运行命令<code>nslookup www.python.org</code>，这和命令行直接运行的效果是一样的：</p>
<pre><code>import subprocess

print('$ nslookup www.python.org')
r = subprocess.call(['nslookup', 'www.python.org'])
print('Exit code:', r)
</code></pre>
<p>运行结果：</p>
<pre><code>$ nslookup www.python.org
Server:		192.168.19.4
Address:	192.168.19.4#53

Non-authoritative answer:
www.python.org	canonical name = python.map.fastly.net.
Name:	python.map.fastly.net
Address: 199.27.79.223

Exit code: 0
</code></pre>
<p>如果子进程还需要输入，则可以通过communicate()方法输入：</p>
<pre><code>import subprocess

print('$ nslookup')
p = subprocess.Popen(['nslookup'], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
output, err = p.communicate(b'set q=mx\npython.org\nexit\n')
print(output.decode('utf-8'))
print('Exit code:', p.returncode)
</code></pre>
<p>上面的代码相当于在命令行执行命令nslookup，然后手动输入：</p>
<pre><code>set q=mx
python.org
exit
</code></pre>
<p>运行结果如下：</p>
<pre><code>$ nslookup
Server:		192.168.19.4
Address:	192.168.19.4#53

Non-authoritative answer:
python.org	mail exchanger = 50 mail.python.org.

Authoritative answers can be found from:
mail.python.org	internet address = 82.94.164.166
mail.python.org	has AAAA address 2001:888:2000:d::a6


Exit code: 0
</code></pre>
<h3 id="进程间通信">进程间通信</h3>
<p>Process之间肯定是需要通信的，操作系统提供了很多机制来实现进程间的通信。Python的<strong>multiprocessing模块</strong>包装了底层的机制，提供了Queue、Pipes等多种方式来交换数据。</p>
<p>我们以Queue为例，在父进程中创建两个子进程，一个往Queue里写数据，一个从Queue里读数据：</p>
<pre><code>
from multiprocessing import Process, Queue
import os, time, random

# 写数据进程执行的代码:
def write(q):
    print('Process to write: %s' % os.getpid())
    for value in ['A', 'B', 'C']:
        print('Put %s to queue...' % value)
        q.put(value)
        time.sleep(random.random())

# 读数据进程执行的代码:
def read(q):
    print('Process to read: %s' % os.getpid())
    while True:
        value = q.get(True)
        print('Get %s from queue.' % value)

if __name__=='__main__':
    # 父进程创建Queue，并传给各个子进程：
    q = Queue()
    pw = Process(target=write, args=(q,))
    pr = Process(target=read, args=(q,))
    # 启动子进程pw，写入:
    pw.start()
    # 启动子进程pr，读取:
    pr.start()
    # 等待pw结束:
    pw.join()
    # pr进程里是死循环，无法等待其结束，只能强行终止:
    pr.terminate()
		
</code></pre>
<p>运行结果如下：</p>
<pre><code>
Process to write: 50563
Put A to queue...
Process to read: 50564
Get A from queue.
Put B to queue...
Get B from queue.
Put C to queue...
Get C from queue.

</code></pre>
<p>在Unix/Linux下，multiprocessing模块封装了fork()调用，使我们不需要关注fork()的细节。</p>
<p>由于Windows没有fork调用，因此，multiprocessing需要“模拟”出fork的效果，<strong>父进程所有Python对象都必须通过pickle序列化再传到子进程去</strong>，所以，如果multiprocessing在Windows下调用失败了，要先考虑是不是pickle失败了。</p>
<h3 id="小结-2">小结</h3>
<p>在Unix/Linux下，可以使用fork()调用实现多进程。</p>
<p>要实现跨平台的多进程，可以使用multiprocessing模块。</p>
<p>进程间通信是通过Queue、Pipes等实现的。</p>
<h2 id="多线程">多线程</h2>
<p>多任务可以由多进程完成，也可以由一个进程内的多线程完成。</p>
<p>我们前面提到了进程是由若干线程组成的，一个进程至少有一个线程。</p>
<p>由于线程是操作系统直接支持的执行单元，因此，高级语言通常都内置多线程的支持，Python也不例外，并且，<strong>Python的线程是真正的Posix Thread，而不是模拟出来的线程</strong>。</p>
<p>Python的标准库<strong>提供了两个模块</strong>：<code>_thread</code>和<code>threading</code>，<code>_thread</code>是低级模块，<code>threading</code>是高级模块，对<code>_thread</code>进行了封装。绝大多数情况下，我们<strong>只需要使用<code>threading</code>这个高级模块</strong>。</p>
<p>启动一个线程就是把一个函数传入并创建Thread实例，然后<strong>调用start()开始执行</strong>：</p>
<pre><code>
import time, threading

# 新线程执行的代码:
def loop():
    print('thread %s is running...' % threading.current_thread().name)
    n = 0
    while n &lt; 5:
        n = n + 1
        print('thread %s &gt;&gt;&gt; %s' % (threading.current_thread().name, n))
        time.sleep(1)
    print('thread %s ended.' % threading.current_thread().name)

print('thread %s is running...' % threading.current_thread().name)
t = threading.Thread(target=loop, name='LoopThread')
t.start()
t.join()
print('thread %s ended.' % threading.current_thread().name)

</code></pre>
<p>执行结果如下：</p>
<pre><code>
thread MainThread is running...
thread LoopThread is running...
thread LoopThread &gt;&gt;&gt; 1
thread LoopThread &gt;&gt;&gt; 2
thread LoopThread &gt;&gt;&gt; 3
thread LoopThread &gt;&gt;&gt; 4
thread LoopThread &gt;&gt;&gt; 5
thread LoopThread ended.
thread MainThread ended.

</code></pre>
<p>由于任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，Python的threading模块有个<strong>current_thread()函数，它永远返回当前线程的实例</strong>。<br>
主线程实例的名字叫MainThread，子线程的名字在创建时指定，我们用LoopThread命名子线程。名字仅仅在打印时用来显示，完全没有其他意义，如果不起名字Python就自动给线程命名为Thread-1，Thread-2……</p>
<h3 id="lock">Lock</h3>
<p>多线程和多进程最大的不同在于</p>
<ol>
<li><strong>多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响</strong></li>
<li>而多线程中，<strong>所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改</strong></li>
<li>因此，线程之间共享数据<strong>最大的危险在于多个线程同时改一个变量</strong>，把内容给改乱了。</li>
</ol>
<p>来看看多个线程同时操作一个变量怎么把内容给改乱了：</p>
<pre><code>
# multithread
import time, threading

# 假定这是你的银行存款:
balance = 0

def change_it(n):
    # 先存后取，结果应该为0:
    global balance
    balance = balance + n
    balance = balance - n

def run_thread(n):
    for i in range(1000000):
        change_it(n)

t1 = threading.Thread(target=run_thread, args=(5,))
t2 = threading.Thread(target=run_thread, args=(8,))
t1.start()
t2.start()
t1.join()
t2.join()
print(balance)

</code></pre>
<p>我们定义了一个共享变量balance，初始值为0，并且启动两个线程，先存后取，理论上结果应该为0，但是，由于线程的调度是由操作系统决定的，当t1、t2交替执行时，只要循环次数足够多，balance的结果就不一定是0了。</p>
<p>原因是因为高级语言的一条语句在CPU执行时是若干条语句，即使一个简单的计算：</p>
<pre><code>balance = balance + n
</code></pre>
<p>也分两步：</p>
<ol>
<li>计算balance + n，存入临时变量中；</li>
<li>将临时变量的值赋给balance。</li>
</ol>
<p>也就是可以看成：</p>
<pre><code>x = balance + n
balance = x
</code></pre>
<p>由于x是局部变量，两个线程各自都有自己的x，当代码正常执行时：</p>
<pre><code>初始值 balance = 0

t1: x1 = balance + 5 # x1 = 0 + 5 = 5
t1: balance = x1     # balance = 5
t1: x1 = balance - 5 # x1 = 5 - 5 = 0
t1: balance = x1     # balance = 0

t2: x2 = balance + 8 # x2 = 0 + 8 = 8
t2: balance = x2     # balance = 8
t2: x2 = balance - 8 # x2 = 8 - 8 = 0
t2: balance = x2     # balance = 0
    
结果 balance = 0
</code></pre>
<p>但是t1和t2是交替运行的，如果操作系统以下面的顺序执行t1、t2：</p>
<p>初始值 balance = 0</p>
<pre><code>t1: x1 = balance + 5  # x1 = 0 + 5 = 5

t2: x2 = balance + 8  # x2 = 0 + 8 = 8
t2: balance = x2      # balance = 8

t1: balance = x1      # balance = 5
t1: x1 = balance - 5  # x1 = 5 - 5 = 0
t1: balance = x1      # balance = 0

t2: x2 = balance - 8  # x2 = 0 - 8 = -8
t2: balance = x2   # balance = -8

结果 balance = -8
</code></pre>
<p>究其原因，是因为<strong>修改balance需要多条语句</strong>，而执行这几条语句时，线程可能中断，从而导致多个线程把同一个对象的内容改乱了。</p>
<p>两个线程同时一存一取，就可能导致余额不对，你肯定不希望你的银行存款莫名其妙地变成了负数，所以，我们必须确保一个线程在修改balance的时候，别的线程一定不能改。</p>
<p>如果我们要确保balance计算正确，就要给change_it()上一把锁，当某个线程开始执行change_it()时，我们说，该线程因为获得了锁，因此其他线程不能同时执行change_it()，只能等待，直到锁被释放后，获得该锁以后才能改。由于锁只有一个，无论多少线程，同一时刻最多只有一个线程持有该锁，所以，不会造成修改的冲突。**创建一个锁就是通过threading.Lock()**来实现：</p>
<pre><code>balance = 0
lock = threading.Lock()

def run_thread(n):
    for i in range(100000):
        # 先要获取锁:
        lock.acquire()
        try:
            # 放心地改吧:
            change_it(n)
        finally:
            # 改完了一定要释放锁:
            lock.release()
</code></pre>
<p>当多个线程同时执行lock.acquire()时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。</p>
<p>获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。所以我们<strong>用try...finally来确保锁一定会被释放</strong>。</p>
<p>锁的好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行，坏处当然也很多，首先是阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了。其次，由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。</p>
<h3 id="多核cpu">多核CPU</h3>
<p>如果你不幸拥有一个多核CPU，你肯定在想，多核应该可以同时执行多个线程。</p>
<p>如果写一个死循环的话，会出现什么情况呢？</p>
<p>打开Mac OS X的Activity Monitor，或者Windows的Task Manager，都可以监控某个进程的CPU使用率。</p>
<p>我们可以监控到一个死循环线程会100%占用一个CPU。</p>
<p>如果有两个死循环线程，在多核CPU中，可以监控到会占用200%的CPU，也就是占用两个CPU核心。</p>
<p>要想把N核CPU的核心全部跑满，就必须启动N个死循环线程。</p>
<p>试试用Python写个死循环：</p>
<pre><code>import threading, multiprocessing

def loop():
    x = 0
    while True:
        x = x ^ 1

for i in range(multiprocessing.cpu_count()):
    t = threading.Thread(target=loop)
    t.start()
</code></pre>
<p>启动与CPU核心数量相同的N个线程，<strong>在4核CPU上可以监控到CPU占用率仅有102%，也就是仅使用了一核。</strong></p>
<p>但是用C、C++或Java来改写相同的死循环，直接可以把全部核心跑满，4核就跑到400%，8核就跑到800%，为什么Python不行呢？</p>
<p>因为Python的线程虽然是真正的线程，但<strong>解释器执行代码时，有一个GIL锁</strong>：Global Interpreter Lock，<strong>任何Python线程执行前，必须先获得GIL锁</strong>，然后，<strong>每执行100条字节码，解释器就自动释放GIL锁</strong>，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，<strong>多线程在Python中只能交替执行</strong>，即使100个线程跑在100核CPU上，也只能用到1个核。</p>
<p>GIL是Python解释器设计的历史遗留问题，通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器。</p>
<p>所以，在Python中，<strong>可以使用多线程，但不要指望能有效利用多核</strong>。如果一定要通过多线程利用多核，那<strong>只能通过C扩展来实现，不过这样就失去了Python简单易用的特点</strong>。</p>
<p>不过，也不用过于担心，Python虽然不能利用多线程实现多核任务，但<strong>可以通过多进程实现多核任务</strong>。多个Python进程有各自独立的GIL锁，互不影响。</p>
<h3 id="小结-3">小结</h3>
<p>多线程编程，模型复杂，容易发生冲突，必须用锁加以隔离，同时，又要小心死锁的发生。</p>
<p>Python解释器由于设计时有<strong>GIL全局锁，导致了多线程无法利用多核（但是注意可以多进程利用多核）</strong>。多线程的并发在Python中就是一个美丽的梦。</p>
<h2 id="threadlocal">ThreadLocal</h2>
<p>在多线程环境下，每个线程都有自己的数据。<strong>一个线程使用自己的局部变量比使用全局变量好，因为局部变量只有线程自己能看见，不会影响其他线程</strong>，而全局变量的修改必须加锁。</p>
<p>但是<strong>局部变量也有问题，就是在函数调用的时候，传递起来很麻烦</strong>：</p>
<pre><code>def process_student(name):
    std = Student(name)
    # std是局部变量，但是每个函数都要用它，因此必须传进去：
    do_task_1(std)
    do_task_2(std)

def do_task_1(std):
    do_subtask_1(std)
    do_subtask_2(std)

def do_task_2(std):
    do_subtask_2(std)
    do_subtask_2(std)
</code></pre>
<p>每个函数一层一层调用都这么传参数那还得了？用全局变量？也不行，因为每个线程处理不同的Student对象，不能共享。</p>
<p>如果用一个全局dict存放所有的Student对象，然后以thread自身作为key获得线程对应的Student对象如何？</p>
<pre><code>global_dict = {}

def std_thread(name):
    std = Student(name)
    # 把std放到全局变量global_dict中：
    global_dict[threading.current_thread()] = std
    do_task_1()
    do_task_2()

def do_task_1():
    # 不传入std，而是根据当前线程查找：
    std = global_dict[threading.current_thread()]
    ...

def do_task_2():
    # 任何函数都可以查找出当前线程的std变量：
    std = global_dict[threading.current_thread()]
    ...
</code></pre>
<p>这种方式理论上是可行的，它最大的优点是消除了std对象在每层函数中的传递问题，但是，每个函数获取std的代码有点丑。</p>
<p>有没有更简单的方式？</p>
<p>ThreadLocal应运而生，不用查找dict，ThreadLocal帮你自动做这件事：</p>
<pre><code>
import threading
    
# 创建全局ThreadLocal对象:
local_school = threading.local()

def process_student():
    # 获取当前线程关联的student:
    std = local_school.student
    print('Hello, %s (in %s)' % (std, threading.current_thread().name))

def process_thread(name):
    # 绑定ThreadLocal的student:
    local_school.student = name
    process_student()

t1 = threading.Thread(target= process_thread, args=('Alice',), name='Thread-A')
t2 = threading.Thread(target= process_thread, args=('Bob',), name='Thread-B')
t1.start()
t2.start()
t1.join()
t2.join()

</code></pre>
<p>执行结果：</p>
<pre><code>
Hello, Alice (in Thread-A)
Hello, Bob (in Thread-B)

</code></pre>
<p>全局变量local_school就是一个<strong>ThreadLocal对象</strong>，每个Thread对它都可以读写student属性，但互不影响。你可以把local_school<strong>看成全局变量</strong>，但<strong>每个属性如local_school.student都是线程的局部变量</strong>，可以任意读写而互不干扰，也不用管理锁的问题，ThreadLocal内部会处理。</p>
<p>可以理解为全局变量local_school是<strong>一个dict</strong>，不但可以用local_school.student，还<strong>可以绑定其他变量</strong>，如local_school.teacher等等。</p>
<p>ThreadLocal最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。</p>
<h3 id="小结-4">小结</h3>
<p>一个ThreadLocal变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。<strong>ThreadLocal解决了参数在一个线程中各个函数之间互相传递的问题</strong>。</p>
<h2 id="进程-vs-线程">进程 vs. 线程</h2>
<p>我们介绍了多进程和多线程，这是实现多任务最常用的两种方式。现在，我们来讨论一下这两种方式的优缺点。</p>
<p>首先，要实现多任务，通常我们会设计<strong>Master-Worker模式</strong>，Master负责分配任务，Worker负责执行任务，因此，多任务环境下，通常是一个Master，多个Worker。</p>
<p>如果用多进程实现Master-Worker，主进程就是Master，其他进程就是Worker。</p>
<p>如果用多线程实现Master-Worker，主线程就是Master，其他线程就是Worker。</p>
<p>多进程模式最大的优点就是<strong>稳定性高</strong>，因为一个子进程崩溃了，不会影响主进程和其他子进程。（当然主进程挂了所有进程就全挂了，但是Master进程只负责分配任务，挂掉的概率低）著名的Apache最早就是采用多进程模式。</p>
<p>多进程模式的缺点是<strong>创建进程的代价大</strong>，在Unix/Linux系统下，用fork调用还行，在Windows下创建进程开销巨大。另外，操作系统能同时运行的进程数也是有限的，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都会成问题。</p>
<p>多线程模式通常比多进程快一点，但是也快不到哪去，而且，多线程模式致命的缺点就是<strong>任何一个线程挂掉都可能直接造成整个进程崩溃</strong>，因为所有线程共享进程的内存。在Windows上，如果一个线程执行的代码出了问题，你经常可以看到这样的提示：“该程序执行了非法操作，即将关闭”，其实往往是某个线程出了问题，但是操作系统会强制结束整个进程。</p>
<p>在Windows下，<strong>多线程的效率比多进程要高</strong>，所以微软的IIS服务器默认采用多线程模式。由于多线程存在稳定性的问题，IIS的稳定性就不如Apache。为了缓解这个问题，IIS和Apache现在又有多进程+多线程的混合模式，真是把问题越搞越复杂。</p>
<h3 id="线程切换">线程切换</h3>
<p>无论是多进程还是多线程，只要数量一多，效率肯定上不去，为什么呢？</p>
<p>我们打个比方，假设你不幸正在准备中考，每天晚上需要做语文、数学、英语、物理、化学这5科的作业，每项作业耗时1小时。</p>
<p>如果你先花1小时做语文作业，做完了，再花1小时做数学作业，这样，依次全部做完，一共花5小时，这种方式称为单任务模型，或者批处理任务模型。</p>
<p>假设你打算切换到多任务模型，可以先做1分钟语文，再切换到数学作业，做1分钟，再切换到英语，以此类推，只要切换速度足够快，这种方式就和单核CPU执行多任务是一样的了，以幼儿园小朋友的眼光来看，你就正在同时写5科作业。</p>
<p>但是，切换作业是有代价的，比如从语文切到数学，要先收拾桌子上的语文书本、钢笔（这叫保存现场），然后，打开数学课本、找出圆规直尺（这叫准备新环境），才能开始做数学作业。操作系统在切换进程或者线程时也是一样的，它需要先保存当前执行的现场环境（CPU寄存器状态、内存页等），然后，把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等），才能开始执行。这个切换过程虽然很快，但是也需要耗费时间。如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。</p>
<p>所以，<strong>多任务一旦多到一个限度，就会消耗掉系统所有的资源，结果效率急剧下降，所有任务都做不好。</strong></p>
<h3 id="计算密集型-vs-io密集型">计算密集型 vs. IO密集型</h3>
<p>是否采用多任务的第二个考虑是任务的类型。我们可以把任务分为计算密集型和IO密集型。</p>
<p>计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，<strong>计算密集型任务同时进行的数量应当等于CPU的核心数</strong>。</p>
<p>计算密集型任务由于<strong>主要消耗CPU资源</strong>，因此，代码运行效率至关重要。Python这样的<strong>脚本语言运行效率很低，完全不适合计算密集型任务</strong>。对于计算密集型任务，<strong>最好用C语言编写</strong>。</p>
<p>第二种任务的类型是IO密集型，<strong>涉及到网络、磁盘IO的任务都是IO密集型任务</strong>，这类任务的特点是CPU消耗很少，任务的大部分时间都在<strong>等待IO操作完成</strong>（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任<strong>务越多，CPU效率越高</strong>，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。</p>
<p>IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。<strong>对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。</strong></p>
<h3 id="异步io">异步IO</h3>
<p>考虑到CPU和IO之间巨大的速度差异，一个任务在执行的过程中大部分时间都在等待IO操作，单进程单线程模型会导致别的任务无法并行执行，<strong>因此，我们才需要多进程模型或者多线程模型来支持多任务并发执行</strong>。</p>
<p>现代操作系统对IO操作已经做了巨大的改进，最大的特点就是支持异步IO。如果充分利用操作系统提供的异步IO支持，就<strong>可以用单进程单线程模型来执行多任务</strong>，这种全新的模型称为<strong>事件驱动模型</strong>，Nginx就是支持异步IO的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。由于系统总的进程数量十分有限，因此操作系统调度非常高效。用异步IO编程模型来实现多任务是一个主要的趋势。</p>
<p>对应到Python语言，<strong>单线程的异步编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。</strong></p>
<h2 id="分布式进程">分布式进程</h2>
<p>在Thread和Process中，应当<strong>优选Process</strong>，因为<strong>Process更稳定</strong>，而且，<strong>Process可以分布到多台机器上</strong>，而<strong>Thread最多只能分布到同一台机器的多个CPU上</strong>。</p>
<p>Python的multiprocessing模块不但支持多进程，其中<strong>managers子模块</strong>还支持把多进程<strong>分布到多台机器上</strong>。一个服务进程可以作为调度者，将任务分布到其他多个进程中，<strong>依靠网络通信</strong>。由于managers模块封装很好，不必了解网络通信的细节，就可以很容易地编写分布式多进程程序。</p>
<p>举个例子：如果我们已经有一个通过Queue通信的多进程程序在同一台机器上运行，现在，由于处理任务的进程任务繁重，希望把发送任务的进程和处理任务的进程分布到两台机器上。怎么用分布式进程实现？</p>
<p>原有的Queue可以继续使用，但是，<strong>通过managers模块把Queue通过网络暴露出去，就可以让其他机器的进程访问Queue了</strong>。</p>
<p>我们先看服务进程，服务进程负责启动Queue，把Queue注册到网络上，然后往Queue里面写入任务：</p>
<pre><code>
# task_master.py

import random, time, queue
from multiprocessing.managers import BaseManager

# 发送任务的队列:
task_queue = queue.Queue()
# 接收结果的队列:
result_queue = queue.Queue()

# 从BaseManager继承的QueueManager:
class QueueManager(BaseManager):
    pass

# 把两个Queue都注册到网络上, callable参数关联了Queue对象:
QueueManager.register('get_task_queue', callable=lambda: task_queue)
QueueManager.register('get_result_queue', callable=lambda: result_queue)

# 绑定端口5000, 设置验证码'abc':
manager = QueueManager(address=('', 5000), authkey=b'abc')
# 启动Queue:
manager.start()

# 获得通过网络访问的Queue对象:
task = manager.get_task_queue()
result = manager.get_result_queue()

# 放几个任务进去:
for i in range(10):
    n = random.randint(0, 10000)
    print('Put task %d...' % n)
    task.put(n)
		
# 从result队列读取结果:
print('Try get results...')
for i in range(10):
    r = result.get(timeout=10)
    print('Result: %s' % r)
		
# 关闭:
manager.shutdown()
print('master exit.')

</code></pre>
<p>请注意，当我们在一台机器上写多进程程序时，创建的Queue可以直接拿来用，但是，在分布式多进程环境下，添加任务到Queue不可以直接对原始的task_queue进行操作，那样就绕过了QueueManager的封装，必须通过<code>manager.get_task_queue()</code>获得的Queue接口添加。</p>
<p>然后，在另一台机器上启动任务进程（本机上启动也可以）：</p>
<pre><code>
# task_worker.py

import time, sys, queue
from multiprocessing.managers import BaseManager

# 创建类似的QueueManager:
class QueueManager(BaseManager):
    pass

# 由于这个QueueManager只从网络上获取Queue，所以注册时只提供名字:
QueueManager.register('get_task_queue')
QueueManager.register('get_result_queue')

# 连接到服务器，也就是运行task_master.py的机器:
server_addr = '127.0.0.1'
print('Connect to server %s...' % server_addr)
# 端口和验证码注意保持与task_master.py设置的完全一致:
m = QueueManager(address=(server_addr, 5000), authkey=b'abc')
# 从网络连接:
m.connect()
# 获取Queue的对象:
task = m.get_task_queue()
result = m.get_result_queue()
# 从task队列取任务,并把结果写入result队列:
for i in range(10):
    try:
        n = task.get(timeout=1)
        print('run task %d * %d...' % (n, n))
        r = '%d * %d = %d' % (n, n, n*n)
        time.sleep(1)
        result.put(r)
    except Queue.Empty:
        print('task queue is empty.')
# 处理结束:
print('worker exit.')

</code></pre>
<p>任务进程要通过网络连接到服务进程，所以要指定服务进程的IP。</p>
<p>现在，可以试试分布式进程的工作效果了。先启动task_master.py服务进程：</p>
<pre><code>$ python3 task_master.py 
Put task 3411...
Put task 1605...
Put task 1398...
Put task 4729...
Put task 5300...
Put task 7471...
Put task 68...
Put task 4219...
Put task 339...
Put task 7866...
Try get results...
</code></pre>
<p>task_master.py进程发送完任务后，开始等待result队列的结果。现在启动task_worker.py进程：</p>
<pre><code>$ python3 task_worker.py
Connect to server 127.0.0.1...
run task 3411 * 3411...
run task 1605 * 1605...
run task 1398 * 1398...
run task 4729 * 4729...
run task 5300 * 5300...
run task 7471 * 7471...
run task 68 * 68...
run task 4219 * 4219...
run task 339 * 339...
run task 7866 * 7866...
worker exit.
</code></pre>
<p>task_worker.py进程结束，在task_master.py进程中会继续打印出结果：</p>
<pre><code>Result: 3411 * 3411 = 11634921
Result: 1605 * 1605 = 2576025
Result: 1398 * 1398 = 1954404
Result: 4729 * 4729 = 22363441
Result: 5300 * 5300 = 28090000
Result: 7471 * 7471 = 55815841
Result: 68 * 68 = 4624
Result: 4219 * 4219 = 17799961
Result: 339 * 339 = 114921
Result: 7866 * 7866 = 61873956
</code></pre>
<p>这个简单的Master/Worker模型有什么用？其实这就是一个简单但真正的分布式计算，把代码稍加改造，启动多个worker，就可以把任务分布到几台甚至几十台机器上，比如把计算n * n的代码换成发送邮件，就实现了邮件队列的异步发送。</p>
<p>Queue对象存储在哪？注意到task_worker.py中根本没有创建Queue的代码，所以，<strong>Queue对象存储在task_master.py进程中</strong>：</p>
<pre><code>
                                             │
┌─────────────────────────────────────────┐     ┌──────────────────────────────────────┐
│task_master.py                           │  │  │task_worker.py                        │
│                                         │     │                                      │
│  task = manager.get_task_queue()        │  │  │  task = manager.get_task_queue()     │
│  result = manager.get_result_queue()    │     │  result = manager.get_result_queue() │
│              │                          │  │  │              │                       │
│              │                          │     │              │                       │
│              ▼                          │  │  │              │                       │
│  ┌─────────────────────────────────┐    │     │              │                       │
│  │QueueManager                     │    │  │  │              │                       │
│  │ ┌────────────┐ ┌──────────────┐ │    │     │              │                       │
│  │ │ task_queue │ │ result_queue │ │&lt;───┼──┼──┼──────────────┘                       │
│  │ └────────────┘ └──────────────┘ │    │     │                                      │
│  └─────────────────────────────────┘    │  │  │                                      │
└─────────────────────────────────────────┘     └──────────────────────────────────────┘
                                             │

                                          Network
</code></pre>
<p>而<strong>Queue之所以能通过网络访问，就是通过QueueManager实现的</strong>。由于QueueManager管理的不止一个Queue，所以，要给每个Queue的网络调用接口起个名字，比如get_task_queue。</p>
<p><strong>authkey有什么用？这是为了保证两台机器正常通信，不被其他机器恶意干扰</strong>。如果task_worker.py的authkey和task_master.py的authkey不一致，肯定连接不上。</p>
<h3 id="小结-5">小结</h3>
<p>Python的分布式进程接口简单，封装良好，适合需要把繁重任务分布到多台机器的环境下。</p>
<p>注意Queue的作用是用来传递任务和接收结果，每个任务的描述数据量要尽量小。比如发送一个处理日志文件的任务，就不要发送几百兆的日志文件本身，而是发送日志文件存放的完整路径，由Worker进程再去共享的磁盘上读取文件。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Python - IO编程]]></title>
        <id>https://lixin-scut.github.io//post/python-io-bian-cheng</id>
        <link href="https://lixin-scut.github.io//post/python-io-bian-cheng">
        </link>
        <updated>2020-05-12T14:17:38.000Z</updated>
        <content type="html"><![CDATA[<p>O在计算机中指Input/Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。</p>
<p>比如你打开浏览器，浏览器这个程序就需要通过网络IO获取网页。浏览器首先会发送数据给服务器，告诉它我想要的HTML，这个动作是往外发数据，叫Output，随后服务器把网页发过来，这个动作是从外面接收数据，叫Input。</p>
<p>所以，通常，程序完成IO操作会有Input和Output两个数据流。当然也有只用一个的情况，比如，从磁盘读取文件到内存，就只有Input操作，反过来，把数据写到磁盘文件里，就只是一个Output操作。</p>
<p>IO编程中，Stream（流）是一个很重要的概念，可以把流想象成一个水管，数据就是水管里的水，但是只能单向流动。Input Stream就是数据从外面（磁盘、网络）流进内存，Output Stream就是数据从内存流到外面去。对于浏览网页来说，浏览器和服务器之间至少需要建立两根水管，才可以既能发数据，又能收数据。</p>
<p>由于CPU和内存的速度远远高于外设的速度，所以，在IO编程中，就存在速度严重不匹配的问题。举个例子来说，比如要把100M的数据写入磁盘，CPU输出100M的数据只需要0.01秒，可是磁盘要接收这100M数据可能需要10秒，怎么办呢？有两种办法：</p>
<p>第一种是CPU等着，也就是程序暂停执行后续代码，等100M的数据在10秒后写入磁盘，再接着往下执行，这种模式称为同步IO；</p>
<p>另一种方法是CPU不等待，只是告诉磁盘继续读写，于是，后续代码可以立刻接着执行，这种模式称为异步IO。</p>
<p>同步和异步的区别就在于是否等待IO执行的结果</p>
<p>很明显，使用异步IO来编写程序性能会远远高于同步IO，但是异步IO的缺点是编程模型复杂，而通知你的方法也各不相同。比如回调模式和轮询模式。总之，异步IO的复杂度远远高于同步IO。</p>
<p>操作IO的能力都是由操作系统提供的，每一种编程语言都会把操作系统提供的低级C接口封装起来方便使用，Python也不例外。我们后面会详细讨论Python的IO编程接口。</p>
<p>注意，<strong>本章的IO编程都是同步模式</strong>，异步IO由于复杂度太高，后续涉及到服务器端程序开发时我们再讨论。</p>
<h2 id="文件读写">文件读写</h2>
<p>读写文件是最常见的IO操作。Python内置了读写文件的函数，用法和C是兼容的。</p>
<p>读写文件前，我们先必须了解一下，<strong>在磁盘上读写文件的功能都是由操作系统提供的，现代操作系统不允许普通的程序直接操作磁盘</strong>，所以，读写文件就是<strong>请求操作系统打开一个文件对象（通常称为文件描述符）</strong>，然后，<strong>通过操作系统提供的接口</strong>从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。</p>
<h3 id="读文件">读文件</h3>
<p>要以读文件的模式打开一个文件对象，使用Python内置的<strong>open()函数，传入文件名和标示符</strong>：</p>
<pre><code>&gt;&gt;&gt; f = open('/Users/michael/test.txt', 'r')
</code></pre>
<p><strong>标示符'r'表示读</strong>，这样，我们就成功地打开了一个文件。</p>
<p>如果<strong>文件不存在，open()函数就会抛出一个IOError的错误</strong>，并且给出错误码和详细的信息告诉你文件不存在：</p>
<pre><code>&gt;&gt;&gt; f=open('/Users/michael/notfound.txt', 'r')
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
FileNotFoundError: [Errno 2] No such file or directory: '/Users/michael/notfound.txt'
</code></pre>
<p>如果文件打开成功，接下来，<strong>调用read()方法可以一次读取文件的全部内容</strong>，Python把内容读到内存，<strong>用一个str对象表示</strong>：</p>
<pre><code>&gt;&gt;&gt; f.read()
'Hello, world!'
</code></pre>
<p>最后一步是调用close()方法关闭文件。<strong>文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的</strong>：</p>
<pre><code>&gt;&gt;&gt; f.close()
</code></pre>
<p>由于文件读写时都有可能产生IOError，<strong>一旦出错，后面的f.close()就不会调用</strong>。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try ... finally来实现：</p>
<pre><code>try:
    f = open('/path/to/file', 'r')
    print(f.read())
finally:
    if f:
        f.close()
</code></pre>
<p>但是每次都这么写实在太繁琐，所以，Python<strong>引入了with语句来自动帮我们调用close()方法</strong>：</p>
<pre><code>with open('/path/to/file', 'r') as f:
    print(f.read())
</code></pre>
<p>这和前面的try ... finally是一样的，但是<strong>代码更简洁，并且不必调用f.close()方法。</strong></p>
<ol>
<li><strong>调用read()会一次性读取文件的全部内容</strong>，如果文件有10G，内存就爆了，</li>
<li>所以，要保险起见，<strong>可以反复调用read(size)方法</strong>，每次<strong>最多读取</strong>size个字节的内容。</li>
<li>另外，<strong>调用readline()可以每次读取一行内容</strong></li>
<li>调用<strong>readlines()一次读取所有内容并按行返回list</strong>。<br>
因此，要根据需要决定怎么调用。</li>
</ol>
<p>如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便：</p>
<pre><code>for line in f.readlines():
    print(line.strip()) # 把末尾的'\n'删掉
</code></pre>
<h3 id="file-like-object">file-like Object</h3>
<p>像open()函数返回的这种有个read()方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。<strong>file-like Object不要求从特定类继承，只要写个read()方法就行</strong>。</p>
<p><strong>StringIO就是在内存中创建的file-like Object，常用作临时缓冲</strong>。</p>
<h3 id="二进制文件">二进制文件</h3>
<p>前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要<strong>读取二进制文件</strong>，比如图片、视频等等，<strong>用'rb'模式</strong>打开文件即可：</p>
<pre><code>&gt;&gt;&gt; f = open('/Users/michael/test.jpg', 'rb')
&gt;&gt;&gt; f.read()
b'\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...' # 十六进制表示的字节
字符编码
</code></pre>
<p>要读取<strong>非UTF-8编码</strong>的文本文件，需要<strong>给open()函数传入encoding参数</strong>，例如，读取GBK编码的文件：</p>
<pre><code>&gt;&gt;&gt; f = open('/Users/michael/gbk.txt', 'r', encoding='gbk')
&gt;&gt;&gt; f.read()
'测试'
</code></pre>
<p>遇到有些编码不规范的文件，你可能会遇到UnicodeDecodeError，因为在文本文件中可能<strong>夹杂了一些非法编码的字符</strong>。遇到这种情况，open()函数还接收一个<strong>errors参数</strong>，表示如果<strong>遇到编码错误后如何处理</strong>。最简单的方式是直接忽略：</p>
<pre><code>&gt;&gt;&gt; f = open('/Users/michael/gbk.txt', 'r', encoding='gbk', errors='ignore')

</code></pre>
<h3 id="写文件">写文件</h3>
<p>写文件和读文件是一样的，唯一区别是<strong>调用open()函数时，传入标识符'w'或者'wb'表示写文本文件或写二进制文件</strong>：</p>
<pre><code>&gt;&gt;&gt; f = open('/Users/michael/test.txt', 'w')
&gt;&gt;&gt; f.write('Hello, world!')
&gt;&gt;&gt; f.close()
</code></pre>
<p>你可以反复调用write()来写入文件，但是<strong>务必要调用f.close()来关闭文件</strong>。当我们<strong>写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入</strong>。<br>
<strong>只有调用close()方法时，操作系统才保证把没有写入的数据全部写入磁盘</strong>。<strong>忘记调用close()的后果是数据可能只写了一部分到磁盘，剩下的丢失了</strong>。所以，<strong>还是用with语句来得保险</strong>：</p>
<pre><code>with open('/Users/michael/test.txt', 'w') as f:
    f.write('Hello, world!')
</code></pre>
<p>要<strong>写入特定编码的文本文件</strong>，请给open()函数传入<strong>encoding参数</strong>，将字符串自动转换成指定编码。</p>
<p>细心的童鞋会发现，<strong>以'w'模式写入文件时，如果文件已存在，会直接覆盖</strong>（相当于删掉后新写入一个文件）。如果我们希望追加到文件末尾怎么办？可以<strong>传入'a'以追加（append）模式写入</strong>。</p>
<pre><code>with open('/Users/michael/test.txt', 'a') as f:
    f.write('Hello, world!')
</code></pre>
<p>所有模式的定义及含义可以参考Python的官方文档。</p>
<h3 id="windows路径问题">windows路径问题</h3>
<p>文件路径不能用反斜杠‘\’。举个例子，如果我传入的文件路径是这样的：</p>
<p><code>sys.path.append('c:\Users\mshacxiang\VScode_project\web_ddt')</code></p>
<p>则会报错<code>SyntaxError: (unicode error) 'unicodeescape' codec can't decode bytes in position 2-3: tr</code></p>
<p>原因分析：在windows系统当中读取文件路径可以使用,但是在python字符串中\有转义的含义，如\t可代表TAB，\n代表换行，所以我们需要采取一些方式使得\不被解读为转义字符。目前有3个解决方案</p>
<p>1、在路径前面加r，即保持字符原始值的意思。</p>
<p><code>sys.path.append(r'c:\Users\mshacxiang\VScode_project\web_ddt')</code></p>
<p>2、替换为双反斜杠</p>
<p><code>sys.path.append('c:\\Users\\mshacxiang\\VScode_project\\web_ddt')</code></p>
<p>3、替换为正斜杠</p>
<p><code>sys.path.append('c:/Users/mshacxiang/VScode_project/web_ddt')</code></p>
<h2 id="stringio和bytesio">StringIO和BytesIO</h2>
<h3 id="stringio">StringIO</h3>
<p>很多时候，数据读写不一定是文件，也可以在内存中读写。</p>
<p><strong>StringIO顾名思义就是在内存中读写str。类似于C++的iostringstream</strong></p>
<p>要把str写入StringIO，我们需要先创建一个StringIO，然后，像文件一样写入即可：</p>
<pre><code>&gt;&gt;&gt; from io import StringIO

&gt;&gt;&gt; f = StringIO()
&gt;&gt;&gt; f.write('hello')
5
&gt;&gt;&gt; f.write(' ')
1
&gt;&gt;&gt; f.write('world!')
6
&gt;&gt;&gt; print(f.getvalue())
hello world!
</code></pre>
<p><strong>getvalue()方法用于获得写入后的str</strong>。</p>
<p>要读取StringIO，可以用一个str初始化StringIO，然后，像读文件一样读取：</p>
<pre><code>&gt;&gt;&gt; from io import StringIO

&gt;&gt;&gt; f = StringIO('Hello!\nHi!\nGoodbye!')
&gt;&gt;&gt; while True:
...     s = f.readline()
...     if s == '':
...         break
...     print(s.strip())
...
Hello!
Hi!
Goodbye!

</code></pre>
<h3 id="bytesio">BytesIO</h3>
<p>StringIO操作的只能是str，如果要操作<strong>二进制数据，就需要使用BytesIO</strong>。</p>
<p>BytesIO实现了在内存中读写bytes，我们创建一个BytesIO，然后写入一些bytes：</p>
<pre><code>&gt;&gt;&gt; from io import BytesIO
&gt;&gt;&gt; f = BytesIO()
&gt;&gt;&gt; f.write('中文'.encode('utf-8'))
6
&gt;&gt;&gt; print(f.getvalue())
b'\xe4\xb8\xad\xe6\x96\x87'
</code></pre>
<p>请注意，<strong>写入的不是str，而是经过UTF-8编码的bytes</strong>。</p>
<p>和StringIO类似，可以用一个bytes初始化BytesIO，然后，像读文件一样读取：</p>
<pre><code>&gt;&gt;&gt; from io import BytesIO
&gt;&gt;&gt; f = BytesIO(b'\xe4\xb8\xad\xe6\x96\x87')
&gt;&gt;&gt; f.read()
b'\xe4\xb8\xad\xe6\x96\x87'
</code></pre>
<h3 id="小结">小结</h3>
<p>StringIO和BytesIO是在内存中操作str和bytes的方法，使得和读写文件具有一致的接口。</p>
<h2 id="操作文件和目录">操作文件和目录</h2>
<p>如果我们要操作文件、目录，可以在命令行下面输入操作系统提供的各种命令来完成。比如dir、cp等命令。</p>
<p>如果要在Python程序中执行这些目录和文件的操作怎么办？其实<strong>操作系统提供的命令只是简单地调用了操作系统提供的接口函数，Python内置的os模块也可以直接调用操作系统提供的接口函数。</strong></p>
<p>打开Python交互式命令行，我们来看看如何使用os模块的基本功能：</p>
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; os.name # 操作系统类型
'posix'
</code></pre>
<p>如果是posix，说明系统是Linux、Unix或Mac OS X，如果是nt，就是Windows系统。</p>
<p>要获取详细的系统信息，可以调用uname()函数：</p>
<pre><code>&gt;&gt;&gt; os.uname()
posix.uname_result(sysname='Darwin', nodename='MichaelMacPro.local', release='14.3.0', version='Darwin Kernel Version 14.3.0: Mon Mar 23 11:59:05 PDT 2015; root:xnu-2782.20.48~5/RELEASE_X86_64', machine='x86_64')
</code></pre>
<p>注意不要漏掉括号，否则就是返回函数类型<br>
注意uname()函数在Windows上不提供，也就是说，os模块的某些函数是跟操作系统相关的。</p>
<h3 id="环境变量">环境变量</h3>
<p>在操作系统中定义的<strong>环境变量，全部保存在os.environ这个变量中</strong>，可以直接查看：</p>
<pre><code>&gt;&gt;&gt; os.environ
environ({'VERSIONER_PYTHON_PREFER_32_BIT': 'no', 'TERM_PROGRAM_VERSION': '326', 'LOGNAME': 'michael', 'USER': 'michael', 'PATH': '/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/X11/bin:/usr/local/mysql/bin', ...})
</code></pre>
<p>要获取某个环境变量的值，可以调用os.environ.get('key')：</p>
<pre><code>&gt;&gt;&gt; os.environ.get('PATH')
'/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/X11/bin:/usr/local/mysql/bin'
&gt;&gt;&gt; os.environ.get('x', 'default')
'default'
</code></pre>
<h3 id="操作文件和目录-2">操作文件和目录</h3>
<p>操作文件和目录的函数一部分放在<strong>os模块中</strong>，一部分放在<strong>os.path模块</strong>中，这一点要注意一下。</p>
<p>查看、创建和删除目录可以这么调用：</p>
<pre><code># 查看当前目录的绝对路径:
&gt;&gt;&gt; os.path.abspath('.')
'/Users/michael'

# 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:
&gt;&gt;&gt; os.path.join('/Users/michael', 'testdir')
'/Users/michael/testdir'

# 然后创建一个目录:
&gt;&gt;&gt; os.mkdir('/Users/michael/testdir')

# 删掉一个目录:
&gt;&gt;&gt; os.rmdir('/Users/michael/testdir')
</code></pre>
<p><strong>把两个路径合成一个时，不要直接拼字符串，而要通过os.path.join()函数</strong>，这样可以<strong>正确处理不同操作系统的路径分隔符</strong>。</p>
<p>在Linux/Unix/Mac下，os.path.join()返回这样的字符串：</p>
<pre><code>part-1/part-2
</code></pre>
<p>而Windows下会返回这样的字符串：</p>
<pre><code>part-1\part-2
</code></pre>
<p>同样的道理，要<strong>拆分路径</strong>时，也不要直接去拆字符串，而要<strong>通过os.path.split()函数</strong>，这样可以把一个路径拆分为两部分，<strong>后一部分总是最后级别的目录或文件名</strong>：</p>
<pre><code>&gt;&gt;&gt; os.path.split('/Users/michael/testdir/file.txt')
('/Users/michael/testdir', 'file.txt')
</code></pre>
<p><strong>os.path.splitext()可以直接让你得到文件扩展名</strong>，很多时候非常方便：</p>
<pre><code>&gt;&gt;&gt; os.path.splitext('/path/to/file.txt')
('/path/to/file', '.txt')
</code></pre>
<p>这些合并、拆分路径的函数<strong>并不要求目录和文件要真实存在</strong>，它们<strong>只对字符串进行操作</strong>。</p>
<p>文件操作使用下面的函数。假定当前目录下有一个test.txt文件：</p>
<pre><code># 对文件重命名:
&gt;&gt;&gt; os.rename('test.txt', 'test.py')
# 删掉文件:
&gt;&gt;&gt; os.remove('test.py')
</code></pre>
<p>但是<strong>复制文件的函数居然在os模块中不存在</strong>！原因是<strong>复制文件并非由操作系统提供的系统调用</strong>。理论上讲，我们通过上一节的读写文件可以完成文件复制，只不过要多写很多代码。</p>
<p>幸运的是<strong>shutil模块提供了copyfile()的函数</strong>，你还可以在shutil模块中找到很多实用函数，它们可以看做是os模块的补充。</p>
<p>最后看看如何利用Python的特性来过滤文件。比如我们要列出当前目录下的所有目录，只需要一行代码：</p>
<pre><code>&gt;&gt;&gt; [x for x in os.listdir('.') if os.path.isdir(x)]
['.lein', '.local', '.m2', '.npm', '.ssh', '.Trash', '.vim', 'Applications', 'Desktop', ...]
</code></pre>
<p>要列出所有的.py文件，也只需一行代码：</p>
<pre><code>&gt;&gt;&gt; [x for x in os.listdir('.') if os.path.isfile(x) and os.path.splitext(x)[1]=='.py']
['apis.py', 'config.py', 'models.py', 'pymonitor.py', 'test_db.py', 'urls.py', 'wsgiapp.py']
</code></pre>
<h3 id="小结-2">小结</h3>
<p>Python的os模块封装了操作系统的目录和文件操作，要注意这些函数有的在os模块中，有的在os.path模块中。</p>
<h2 id="序列化">序列化</h2>
<p>在程序运行的过程中，所有的变量都是在内存中，比如，定义一个dict：</p>
<pre><code>d = dict(name='Bob', age=20, score=88)
</code></pre>
<p>可以随时修改变量，比如把name改成'Bill'，但是一旦程序结束，变量所占用的内存就被操作系统全部回收。如果没有把修改后的'Bill'存储到磁盘上，下次重新运行程序，变量又被初始化为'Bob'。</p>
<p>我们<strong>把变量从内存中变成可存储或传输的过程称之为序列化</strong>，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。</p>
<p><strong>序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。</strong></p>
<p>反过来，<strong>把变量内容从序列化的对象重新读到内存里称之为反序列化</strong>，即unpickling。</p>
<p>Python提供了pickle模块来实现序列化。</p>
<p>首先，我们尝试把一个对象序列化并写入文件：</p>
<pre><code>&gt;&gt;&gt; import pickle
&gt;&gt;&gt; d = dict(name='Bob', age=20, score=88)
&gt;&gt;&gt; pickle.dumps(d)
b'\x80\x03}q\x00(X\x03\x00\x00\x00ageq\x01K\x14X\x05\x00\x00\x00scoreq\x02KXX\x04\x00\x00\x00nameq\x03X\x03\x00\x00\x00Bobq\x04u.'
</code></pre>
<p><strong>pickle.dumps()方法把任意对象序列化成一个bytes</strong>，然后，就可以把这个<strong>bytes写入文件</strong>。或者用另一个方法pickle.dump()直接把对象序列化后<strong>写入一个file-like Object</strong>：</p>
<pre><code>&gt;&gt;&gt; f = open('dump.txt', 'wb')
&gt;&gt;&gt; pickle.dump(d, f)
&gt;&gt;&gt; f.close()
</code></pre>
<p>当我们要把对象从磁盘读到内存时，可以<strong>先把内容读到一个bytes</strong>，然后<strong>用pickle.loads()方法反序列化出对象</strong>，也可以<strong>直接用pickle.load()方法从一个file-like Object中直接反序列化出对象</strong>。</p>
<p>打开另一个Python命令行来反序列化刚才保存的对象：</p>
<pre><code>&gt;&gt;&gt; f = open('dump.txt', 'rb')
&gt;&gt;&gt; d = pickle.load(f)
&gt;&gt;&gt; f.close()
&gt;&gt;&gt; d
{'age': 20, 'score': 88, 'name': 'Bob'}
变量的内容又回来了！
</code></pre>
<p>当然，这个变量和原来的变量是<strong>完全不相干的对象</strong>，它们<strong>只是内容相同而已。</strong></p>
<p>Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它<strong>只能用于Python，并且可能不同版本的Python彼此都不兼容</strong>，因此，<strong>只能用Pickle保存那些不重要的数据</strong>，不能成功地反序列化也没关系。</p>
<h3 id="json">JSON</h3>
<p>如果我们要在不同的编程语言之间传递对象，就<strong>必须把对象序列化为标准格式</strong>，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。</p>
<p>JSON表示的对象就是标准的JavaScript语言的对象，JSON和Python内置的数据类型对应如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">JSON类型</th>
<th style="text-align:center">Python类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">{}</td>
<td style="text-align:center">dict</td>
</tr>
<tr>
<td style="text-align:center">[]</td>
<td style="text-align:center">list</td>
</tr>
<tr>
<td style="text-align:center">&quot;string&quot;</td>
<td style="text-align:center">str</td>
</tr>
<tr>
<td style="text-align:center">1234.56</td>
<td style="text-align:center">int或float</td>
</tr>
<tr>
<td style="text-align:center">true/false</td>
<td style="text-align:center">True/False</td>
</tr>
<tr>
<td style="text-align:center">null</td>
<td style="text-align:center">None</td>
</tr>
</tbody>
</table>
<p>Python<strong>内置的json模块</strong>提供了非常完善的Python对象到JSON格式的转换。我们先看看如何把Python对象变成一个JSON：</p>
<pre><code>&gt;&gt;&gt; import json
&gt;&gt;&gt; d = dict(name='Bob', age=20, score=88)
&gt;&gt;&gt; json.dumps(d)
'{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}'
</code></pre>
<p><strong>dumps()方法返回一个str，内容就是标准的JSON</strong>。类似的，<strong>dump()方法可以直接把JSON写入一个file-like Object</strong>。</p>
<p>要把JSON<strong>反序列化为Python对象，用loads()或者对应的load()方法</strong>，前者把<strong>JSON的字符串</strong>反序列化，后者从<strong>file-like Object中读取字符串</strong>并反序列化：</p>
<pre><code>&gt;&gt;&gt; json_str = '{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}'
&gt;&gt;&gt; json.loads(json_str)
{'age': 20, 'score': 88, 'name': 'Bob'}
</code></pre>
<p>由于JSON标准规定JSON编码是UTF-8，所以我们总是能正确地在Python的str与JSON的字符串之间转换。</p>
<h3 id="json进阶">JSON进阶</h3>
<p>Python的dict对象可以直接序列化为JSON的{}，不过，很多时候，我们更喜欢用class表示对象，比如定义Student类，然后序列化：</p>
<pre><code>import json

class Student(object):
    def __init__(self, name, age, score):
        self.name = name
        self.age = age
        self.score = score

s = Student('Bob', 20, 88)
print(json.dumps(s))
</code></pre>
<p>运行代码，毫不留情地得到一个TypeError：</p>
<pre><code>Traceback (most recent call last):
  ...
TypeError: &lt;__main__.Student object at 0x10603cc50&gt; is not JSON serializable
</code></pre>
<p>错误的原因是<strong>Student对象不是一个可序列化为JSON的对象</strong>。</p>
<p>仔细看看dumps()方法的参数列表，可以发现，除了第一个必须的obj参数外，dumps()方法还提供了一大堆的可选参数：</p>
<p>https://docs.python.org/3/library/json.html#json.dumps</p>
<p>这些<strong>可选参数就是让我们来定制JSON序列化</strong>。前面的代码之所以无法把Student类实例序列化为JSON，是因为<strong>默认情况下，dumps()方法不知道如何将Student实例变为一个JSON的{}对象</strong>。</p>
<p><strong>可选参数default就是把任意一个对象变成一个可序列为JSON的对象</strong>，我们只需要<strong>为Student专门写一个转换函数，再把函数传进去即可</strong>：</p>
<pre><code>def student2dict(std):
    return {
        'name': std.name,
        'age': std.age,
        'score': std.score
    }
</code></pre>
<p>这样，Student实例首先被student2dict()函数转换成dict，然后再被顺利序列化为JSON：</p>
<pre><code>&gt;&gt;&gt; print(json.dumps(s, default=student2dict))
{&quot;age&quot;: 20, &quot;name&quot;: &quot;Bob&quot;, &quot;score&quot;: 88}
</code></pre>
<p>不过，下次如果遇到一个Teacher类的实例，照样无法序列化为JSON。我们可以把任意class的实例变为dict：</p>
<pre><code>print(json.dumps(s, default=lambda obj: obj.__dict__))
</code></pre>
<p>因为<strong>通常class的实例都有一个dict属性</strong>，它就是一个dict，用来存储实例变量。也有<strong>少数例外，比如定义了slots的class</strong>。</p>
<p>同样的道理，如果我们要把JSON反序列化为一个Student对象实例，loads()方法首先转换出一个dict对象，然后，我们传入的object_hook函数负责把dict转换为Student实例：</p>
<pre><code>def dict2student(d):
    return Student(d['name'], d['age'], d['score'])
</code></pre>
<p>运行结果如下：</p>
<pre><code>&gt;&gt;&gt; json_str = '{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}'
&gt;&gt;&gt; print(json.loads(json_str, object_hook=dict2student))
&lt;__main__.Student object at 0x10cd3c190&gt;
</code></pre>
<p>打印出的是反序列化的Student实例对象。</p>
<h3 id="小结-3">小结</h3>
<p>Python语言特定的序列化模块是pickle，但如果要把序列化搞得更通用、更符合Web标准，就可以使用json模块。</p>
<p>json模块的dumps()和loads()函数是定义得非常好的接口的典范。当我们使用时，只需要传入一个必须的参数。但是，当默认的序列化或反序列机制不满足我们的要求时，我们又可以传入更多的参数来定制序列化或反序列化的规则，既做到了接口简单易用，又做到了充分的扩展性和灵活性。</p>
]]></content>
    </entry>
</feed>