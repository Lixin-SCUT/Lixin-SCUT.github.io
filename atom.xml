<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-03-03T16:49:17.962Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>In the darkest night,Rising like a spire.</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[进程间通信方式]]></title>
        <id>https://lixin-scut.github.io//post/jin-cheng-jian-tong-xin-fang-shi</id>
        <link href="https://lixin-scut.github.io//post/jin-cheng-jian-tong-xin-fang-shi">
        </link>
        <updated>2020-03-03T09:52:50.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>管道<br>
管道，通常指无名管道。<br>
①	半双工的，具有固定的读端和写端；<br>
②	只能用于具有亲属关系的进程之间的通信；<br>
③	可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write函数。但是它不是普通的文件，并不属于其他任何文件系统，只能用于内存中。<br>
④	Int pipe(int fd[2]);当一个管道建立时，会创建两个文件文件描述符，要关闭管道只需将这两个文件描述符关闭即可。<br>
协同进程：连接到另一进程的两个单向管道</li>
<li>FIFO（有名管道）<br>
①	FIFO可以再无关的进程之间交换数据，与无名管道不同；<br>
②	FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中；<br>
③	Int mkfifo(const char* pathname,mode_t mode);</li>
<li>消息队列<br>
①	消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符来标识；<br>
②	消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级；<br>
③	消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除；<br>
④	消息队列可以实现消息的随机查询</li>
<li>信号量<br>
①	信号量是一个计数器，信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据；<br>
②	信号量用于进程间同步，若要在进程间传递数据需要结合共享内存；<br>
③	信号量基于操作系统的PV操作，程序对信号量的操作都是原子操作；</li>
<li>共享内存<br>
①	共享内存，指两个或多个进程共享一个给定的存储区；<br>
②	共享内存是最快的一种进程通信方式，因为进程是直接对内存进行存取；<br>
③	因为多个进程可以同时操作，所以需要进行同步；<br>
④	信号量+共享内存通常结合在一起使用。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字节对齐]]></title>
        <id>https://lixin-scut.github.io//post/zi-jie-dui-qi</id>
        <link href="https://lixin-scut.github.io//post/zi-jie-dui-qi">
        </link>
        <updated>2020-03-03T09:51:39.000Z</updated>
        <content type="html"><![CDATA[<p>现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。</p>
<p>1、	平台原因(移植原因)</p>
<ol>
<li>不是所有的硬件平台都能访问任意地址上的任意数据的；</li>
<li>某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异<br>
2、性能原因：</li>
<li>数据结构(尤其是栈)应该尽可能地在自然边界上对齐。</li>
<li>为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字节序]]></title>
        <id>https://lixin-scut.github.io//post/zi-jie-xu</id>
        <link href="https://lixin-scut.github.io//post/zi-jie-xu">
        </link>
        <updated>2020-03-03T09:44:59.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>字节排序函数、大端序、小端序<br>
  小端 和 大端 表示多个字节值的哪一端(小端或大端)存储在该值的起始 地址.<br>
  低序字节存储在起始地址，这称为小端（little-endian）字节序；<br>
  另一种方法是将高序字节存储在起 始地址，这称为大端（big-endian）字节序。<br>
<strong>记忆方法</strong>：大端序就是我们日常的<strong>书写顺序</strong>（在纸上（内存）写一个数字，先写高位再写地位），小端序则是反过来</li>
</ul>
<p>当前系统所用的字节序称为主机字节序(host byte order)<br>
<img src="https://lixin-scut.github.io//post-images/1578490222230.png" alt=""><br>
  网络协议必须指定一个网络字节序（network byte order），网际协议使用<strong>大端字节序</strong>来传送这些多字节整数。<br>
套接字地址结构中的某些字 段必须按照网络字节序进行维护。<br>
两种字节序之间的转换使用以下4个函数。<br>
<img src="https://lixin-scut.github.io//post-images/1578490503887.png" alt=""><br>
h代表host, n代表network, s代表short, l代表long</p>
<p>  注意：当使用这些函数时，我们并不关心主机字节序和网络字节序的真实值（或为大端，或为小端）。我们所要做的只是调用适当的函数在主机和网络字节序之间转换某个给定值。在那些与网际协议所用字节序（大端）相同的系统中，这四个函数通常被定义为空宏。（一句话，为求保险（优雅地说是提高可移植性），默认调用转换就完事了）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[死锁]]></title>
        <id>https://lixin-scut.github.io//post/si-suo</id>
        <link href="https://lixin-scut.github.io//post/si-suo">
        </link>
        <updated>2020-03-03T07:25:22.000Z</updated>
        <content type="html"><![CDATA[<h3 id="死锁">死锁</h3>
<p>  如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，该进程集合就是死锁的。<br>
  由于所有的进程都在等待，所以没有一个进程能引发可以唤醒该进程集合中的其他进程的事件，这样, 所有的进程都只好无限期等待。<br>
  在大多数情况下，每个进程所等待的事件是释放该进程集合中其他进程所占有的资源。换言之，这个死锁进程集合中的每一个进程都在等待另一个死锁的进程已经占有的资源。但是由于所有进程都不能运行，它们中的任何一个都无法释放资源，所以没有一个进程可以被唤醒。 这种死锁称为资源死锁（resource deadlock）。</p>
<h3 id="发生条件">发生条件</h3>
<p>资源死锁的条件<br>
发生（资源）死锁的四个必要条件：<br>
1）	互斥条件。每个资源要么已经分配给了一个进程，要么就是可用的。<br>
2）	占有和等待条件。已经得到了某个资源的进程可以再请求新的资源。<br>
3）	不可抢占条件。已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。<br>
4）	环路等待条件。死锁发生时，系统中一定有由两个或两个以上的进程组成的一条环路，该环路中的每个进程都在等待着下一个进程所占有的资源。<br>
  死锁发生时，以上四个条件一定是<strong>同时满足</strong>的。如果其中任何一个条件不成立，死锁就不会发生。</p>
<h3 id="处理策略">处理策略</h3>
<p>有四种处理死锁的策略：<br>
1）	鸵鸟算法：忽略该问题。也许如果你忽略它，它也会忽略你。<br>
2）	检测死锁并恢复。让死锁发生，检测它们是否发生，一旦发生死锁，采取行动解决问题。<br>
3）	死锁避免，仔细对资源进行分配，动态地避免死锁。<br>
4）	通过破坏引起死锁的四个必要条件之一，防止死锁的产生。</p>
<h3 id="死锁检测">死锁检测</h3>
<p>  对系统构造一张资源分配图，如果这张图包含了一个或一个以上的环， 那么死锁就存在。在此环中的任何一个进程都是死锁进程。如果没有这样的环，系统就没有发生死锁。<br>
  如果有多种相同的资源存在，就需要采用另一种方法来检测死锁：基于矩阵的算 法来检测这个进程中的死锁。</p>
<h3 id="从死锁中恢复">从死锁中恢复</h3>
<ol>
<li>利用抢占恢复<br>
临时将某个资源从它的当前所有者那里转移到另一个进程</li>
<li>利用回滚恢复<br>
周期性地对进程进行检查点检查（checkpointed）。进程检查点检查就是将进程的状态写入一个文件以备以后重启。将该进程复位到一个更早的状态，那时它还没有取得所需的资源，接着就把这个资源分配给一个 死锁进程。如果复位后的进程试图重新获得对该资源的控制，它就必须一直等到该资源可用时为止。</li>
<li>通过杀死进程恢复<br>
最直接也是最简单的解决死锁的方法是杀死一个或若干个进程。一种方法是杀掉环中的一个进程。如果走运的话，其他进程将可以继续。如果这样做行不通的话，就需要继续杀死别的进程直到打破死锁环。<br>
  另一种方法是选一个环外的进程作为牺牲品以释放该进程的资源。<br>
  另一方面，更新数据库的进程在第二次运行时并非总是安全的。如果一个进程将数据库的某个记录 加1,那么运行它一次，将它杀死后，再次执行，就会对该记录加2,这显然是错误的。</li>
</ol>
<h3 id="死锁避免">死锁避免</h3>
<ol>
<li>资源轨迹图</li>
<li>安全状态和不安全状态<br>
  不安全状态并不是死锁。系统能运行一段时间。实际上，甚至有一个进程能够完成。安全状态和不安全状态的区别是：从安全状态出发，系统能够保证所有进程都 能完成，而从不安全状态出发，就没有这样的保证。</li>
<li>银行家算法<br>
  银行家算法就是对每一个请求迸行检查，检查如果满足这一请求是否会达到安全状态。若是，那么 就满足该请求，若否，那么就推迟对这一请求的满足。为了看状态是否安全，银行家看他是否有足够的 资源满足某一个客户。如果可以，那么这笔投资认为是能够收回的，并且接着检查最接近最大限额的一 个客户，以此类推。如果所有投资最终都被收回，那么该状态是安全的，最初的请求可以批准。</li>
</ol>
<h3 id="死锁预防">死锁预防</h3>
<ol>
<li>破坏互斥条件：如果资源不被一个进程所独占，那么死锁肯定不会产生。<br>
  允许两 个进程同时使用打印机会造成混乱，通过采用假脱机打印机（spooling printer）技术可以允许若干个进程同时产生输出。该模型中惟一真正请求使用物理打印机的进程是打印机守护进程，由于守护进程决不会请求别的资源，所以不会因打印机而产生死锁。</li>
<li>破坏占有和等待条件：只要禁止已持有资源的进程再等待其他资源便可以消 除死锁。<br>
  一种实现方法是规定所有进程在开始执行前请求所需的全部资源。如果所需的全部资源可用， 那么就将它们分配给这个进程，于是该进程肯定能够运行结束。如果有一个或多个资源正被使用，那么就不进行分配，进程等待。<br>
  另一种破坏占有和等待条件的略有不同的方案是，要求当一个进程请求资源时，先暂时释放其当前占用的所有资源，然后再尝试一次获得所需的全部资源。</li>
<li>破坏不可抢占条件<br>
  现在只剩下一个条件了。消除环路等待有几种方法。一种是保证每一个进程在任何时刻只能占用一个资源，如果要请求另外一个资源，它必须先释放第一个资源。但<br>
  该算法的一个变种是摈弃必须按升序请求资源的限制，而仅仅要求不允许进程请求比当前所占有资源编号低的资源。</li>
</ol>
<h3 id="两阶段加锁">两阶段加锁</h3>
<p>  在第一阶段，进程试图对所有所需的记录进行加锁， 一次锁一个记录。如果第一阶段加锁成功，就开始第二阶段，完成更新然后释放锁。在第一阶段并没有做实际的工作。<br>
  如果在第一阶段某个进程需要的记录已经被加锁，那么该进程释放它所有加锁的记录，然后重新开始第一阶段。从某种意义上说，这种方法类似于提前或者至少是未实施一些不可逆的操作之前请求所有资源。<br>
  如果在第一阶段遇到了已加锁的记录，并不会释放锁然后重新开始， 这就可能产生死锁。<br>
  不过，在一般意义下，这种策略并不通用。例如，在实时系统和进程控制系统中，由于一个进程缺 少一个可用资源就半途中断它，并重新开始该进程，这是不可接受的。</p>
<h3 id="通信死锁">通信死锁</h3>
<p>  另一种死锁发生在通信系统中（比如说网络），即两个或两个以上进程利用发送信息来通信时。一种普遍的情形是进程A向进程B发送请求信息，然后阻塞直至B回复。假设请求信息丢失，A将阻塞以等待回复，而B 会阻塞等待一个向其发送命令的请求，因此发生死锁。<br>
  仅仅如此并非经典的资源死锁。A没有占有B所需的资源，反之亦然。事实上，并没有完全可见的资源。但是，根据标准的定义，在一系列进程中，每个进程因为等待另外一个进程引发的事件而产生阻塞，这就是一种死锁。相比于更加常见的资源死锁，我们把上面这种情况叫做通信死锁 （communication deadlock）</p>
<h3 id="活锁">活锁</h3>
<p>  在某种情形下，轮询（忙等待）可用于进入临界区或存取资源。<br>
  现在假设有一对进程使用两种资源。每个进程需要两种资源，它们利用轮询原语enter_region去尝试取得必要的锁，如果尝试失败，则该进程继续尝试。如果进程A先运行并得到资源1,然后进程2运行并得到资源2,以后不管哪一个进程运行，都不会有任何进展，但是哪一个进程也没有被阻塞。结果 是两个进程总是一再消耗完分配给它们的CPU配 额，但是没有进展也没有阻塞。因此，没有出现 死锁现象（因为没有进程阻塞），但是从现象上 看好像死锁发生了，这就是活锁（livelock）。</p>
<h3 id="饥饿">饥饿</h3>
<p>  与死锁和活锁非常相似的一个问题是饥饿（starvation）。在动态运行的系统中，在任何时刻都可能请求资源。这就需要一些策略来决定在什么时候谁获得什么资源。虽然这个策略表面上很有道理，但依 然有可能使一些进程永远得不到服务，虽然它们并不是死锁进程。<br>
作为一个例子，考虑打印机分配。设想系统采用某种算法来保证打印机分配不产生死锁。现在假设若干进程同时都请求打印机，究竟哪一个进程能获得打印机呢？<br>
一个可能的分配方案是把打印机分配给打印最小文件的进程（假设这个信息可知）。这个方法让尽 量多的顾客满意，并且看起来很公平。我们考虑下面的情况：在一个繁忙的系统中，有一个进程有一个 很大的文件要打印，每当打印机空闲，系统纵观所有进程，并把打印机分配给打印最小文件的进程。如 果存在一个固定的进程流，其中的进程都是只打印小文件，那么，要打印大文件的进程永远也得不到打 印机。很简单，它会饥饿而死”（无限制地推后，尽管它没有被阻塞）。<br>
  饥饿可以通过先来先服务资源分配策略来避免。在这种机制下，等待最久的进程会是下一个被调度的进程。随着时间的推移，所有进程都会变成最“老”的，因而，最终能够获得资源而完成。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux文件系统]]></title>
        <id>https://lixin-scut.github.io//post/linux-wen-jian-xi-tong</id>
        <link href="https://lixin-scut.github.io//post/linux-wen-jian-xi-tong">
        </link>
        <updated>2020-03-03T07:09:15.000Z</updated>
        <content type="html"><![CDATA[<h3 id="文件系统">文件系统</h3>
<p>磁盘分区完毕后还需要进行格式化(format)，之后操作系统才能够使用这个文件系统。这是因为每种操作系统所设定的文件属性/权限并不相同。为了存放这些文件所需的数据，因此就需要将分区槽进行格式化，以成为操作系统能够利用的『文件系统格式(filesystem)』<br>
文件系统通常会将这两部份的数据（文件权限(rwx)与文件属性(拥有者、 群组、时间参数等)）分别存放在不同的区块，权限与属性放置到 inode 中，至于实际数据则放置到 data block 区块中</p>
<h3 id="层次分析">层次分析</h3>
<ol>
<li>用户层，日常使用的各种程序，需要的接口主要是文件的创建、删除、读、写、关闭等；</li>
<li>VFS层，文件相关的操作都有对应的System Call函数接口，接口调用VFS对应的函数；</li>
<li>文件系统层，用户的操作通过VFS转到各种文件系统。文件系统把文件读写命令转化为对磁盘LBA的操作，起了一个翻译和磁盘管理的工作；</li>
<li>缓存层；</li>
<li>块设备层，块设备接口Block Device是用来访问磁盘LBA的层级，读写命令组合之后插入到命令队列，磁盘的驱动从队列读命令执行；</li>
<li>磁盘驱动层；</li>
<li>磁盘物理层；</li>
</ol>
<h3 id="读取文件过程">读取文件过程</h3>
<ol>
<li>根据文件所在目录的inode信息，找到目录文件对应数据块；</li>
<li>根据文件名从数据块中找到对应的inode节点信息；</li>
<li>从文件inode节点信息中找到文件内容所在数据块块号；</li>
<li>读取数据块内容</li>
</ol>
<h3 id="inode">inode</h3>
<p>superblock：记录此 filesystem 的整体信息，包括 inode/block 的总量、使用量、剩余量， 以及文件系统的 格式与相关信息等；<br>
inode：记录文件的属性，一个文件占用一个 inode，同时记录此文件的数据所在的 block 号码；</p>
<p>  每个文件都会占用一个 inode ，inode 内则有文件数据放置的 block 号码。<br>
  一个incode可能会拥有（占用）多个block，这种数据存取的方法我们称为索引式文件系统(indexed allocation)</p>
<p>inode 记录的文件数据至少有底下这些<br>
该文件的存取模式(read/write/excute)；<br>
该文件的拥有者与群组(owner/group)；<br>
该文件的容量；<br>
该文件建立或状态改变的时间(ctime)；<br>
最近一次的读取时间(atime)；<br>
最近修改的时间(mtime)；<br>
定义文件特性的旗标(flag)，如 SetUID...；<br>
该文件真正内容的指向 (pointer)；<br>
每个 inode 大小均固定为 128 bytes (新的 ext4 与 xfs 可设定到 256 bytes)；<br>
每个文件都仅会占用一个 inode 而已；<br>
  承上，因此文件系统能够建立的文件数量与 inode 的数量有关；<br>
  系统读取文件时需要先找到 inode，并分析 inode 所记录的权限与用户是否符合，若符合才能够开始实际 读取 block 的内容。</p>
<h3 id="软链接和硬链接">软链接和硬链接</h3>
<p><strong>hard link</strong>：多个档名对应到同一个 inode 号码<br>
  hard link 只是在某个目录下新增一笔档名链接到某 inode 号码的关连记录而已<br>
  硬链接hard link最大的好处就是 『安全』，如果你将任何一个『档名』删除，其实 inode 与 block 都还是存在的<br>
  使用 hard link 设定链接文件时，磁盘的空间与 inode 的数目都不会改变<br>
  hard link 的制作中，其实还是可能会改变系统的 block 的，那就是当你新增这笔数据却刚好将目录的 block 填满时，就可能会新加一个 block 来记录文件名关连性，而导致磁盘空间的变化。不过， 一般 hard link 所用掉的关连数据量很小，所以通常不会改变 inode 与磁盘空间的大小<br>
hard link 是有限制的：</p>
<ol>
<li>不能跨 Filesystem；</li>
<li>不能直接 link 目录。</li>
<li>如果使用 hard link 链接到目录时， 链接的数据需要连同被链接目录底下的所有数据都建立链接</li>
</ol>
<p><strong>Symbolic Link</strong>(符号链接，亦即是快捷方式)<br>
  Symbolic link 就是在建立一个独立的 文件，而这个文件会让数据的读取指向他它link 的那个文件的档名！由于只是利用文件来做为指向的 动作， 所以，当来源档被删除之后，symbolic link 的文件会『开不了』，<br>
  符号链接可以跨越文件系统！！！也可以链接项目，因为只看文件名不看inode<br>
  两个文件指向不同的 inode 号码，当然就是两个独立的文件存在！ 而且连结档的重要内容就是他会写上目标文件的『文件名』<br>
  Symbolic Link 与 Windows 的快捷方式可以给他划上等号，由 Symbolic link 所建立的文件为一个独立的新的文件，所以会占用掉 inode 与 block</p>
<p>  个人测试：Symbolic Link之后删除源文件，会显示No such file 。但是！！！！我重建源文件后（用vim重建不同内容的同名文件或者用ln硬链接同名文件），会自动连接上！！！<br>
  stat对于软连接不会寻找源文件，lstat才会获取原始文件</p>
<p>使用 ln 如果不加任何参数的话，那么就是 Hard Link使用 ln 如果不加任何参数的话，那么就是 Hard Link要制作连结档就必须要使用 ln 这个指令，使用 ln 如果不加任何参数的话，那么就是 Hard Link</p>
<pre><code>[root@study ~]# ln [-sf] 来源文件 目标文件
选项与参数：
-s ：如果不加任何参数就进行连结，那就是 hard link，至于 -s 就是 symbolic link
-f ：如果 目标文件 存在时，就主动的将目标文件直接移除后再建立
</code></pre>
<p>关于目录的 link 数量<br>
  以 hard link 进行『文件的连结』时，可以发现，在 ls -l 所显 示的第二字段会增加一才对<br>
  当我们建立一个新目录名称为 /tmp/testing 时，基本上会有三个东西，那就是：</p>
<pre><code>/tmp/testing
/tmp/testing/.
/tmp/testing/..
</code></pre>
<p>所以新的目录的 link 数为 2 ，而上层目录的 link 数则会增加 1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math  题43:	整数中1出现的次数[未做出]]]></title>
        <id>https://lixin-scut.github.io//post/math-ti-43-zheng-shu-zhong-1-chu-xian-de-ci-shu-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/math-ti-43-zheng-shu-zhong-1-chu-xian-de-ci-shu-wei-zuo-chu">
        </link>
        <updated>2020-03-03T00:53:59.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>输入一个整数n，求1~n这n个整数的十进制表示中1出现的次数。例如，输入12, 1〜12这些整数中包含1的数字有1、10、11和12,共出现了5次。</p>
</blockquote>
<p>  一开始把题目看成了统计当前数字中的1....<br>
  暴力法比较麻烦的是不仅要循环递增数字，还要循环数字本身，数字一旦大了时间复杂度就爆炸了<br>
  然后就是书中的规律法，比较有趣，就是使用逐位计算，需要注意的就是</p>
<ol>
<li>位数为1时的处理</li>
<li>最高位为1的次数需要额外+1</li>
<li>剩余位需要-2（当前位和最高位），理解为何剩余位可以取0-9而不是除去1或者只能取到当前最大值</li>
</ol>
<pre><code>class Solution {
public:
    //数学规律递归法【未做出】
    int NumberOf1Between1AndN_Solution(int n)
    {
        if(n&lt;1)
            return 0;
        string ns=to_string(n);
        int length=ns.size();
        int count=0;
        for(auto i:ns){
            count+=count_one(i-'0',length,n);
            --length;
        }
        return count;
    }
    
    int count_one(int i,int bit,int &amp;n){
        int count=0;
        if(i==0&amp;&amp;bit==1)
            return 0;
        if(bit==1){
            return 1;
        }
        
        //最高位为1的次数
        if(i&gt;1)
            count+=pow(10,bit-1);
        else if(i==1)
            count+=n-1*pow(10,bit-1)+1;
        
        //剩余位数为1的次数 
        count+=i*(bit-1)*pow(10,bit-2);
        n-=i*pow(10,bit-1);
        return count;
    }
    
    
    /*
    //逐个数计算法
    int NumberOf1Between1AndN_Solution(int n)
    {
        if(n&lt;1)
            return 0;
        int count;
        count=0;
        for(int i=1;i&lt;=n;++i){
            count+=count_one(i);
        }
        return count;
    }
    
    int count_one(int n){
        int count=0;
        int temp;
        while(n&gt;0){
            temp=n%10;
            if(temp==1)
                ++count;
            n/=10;
        }
        return count;
    }
    */
};
</code></pre>
<p>书本题解：<br>
  最直观的方法, 也就是累加1〜n中每个整数1出现的次数。我们可以每次通过对10求余数判断整数的个位数字是不是1。如果这个数字大于10,则除以10之后再判断个位数字是不是1。<br>
  在上述思路中，我们对每个数字都要做除法和求余运算，以求出该数字中1出现的次数。如果输入数字n，n有O(logn)位，我们需要判断每一位是不是1,那么它的时间复杂度是O(nlogn)。当输入的n非常大的时候，需要大量的计算，运算效率不高。<br>
  如果希望不用计算每个数字的1的个数，那就只能去寻找1在数字中出现的规律了。为了找到规律，我们不妨用一个稍微大一点的数字如21345 作为例子来分析。我们把1〜21345的所有数字分为两段：一段是1〜1345： 另一段是1346〜21345。<br>
  我们先看1346〜21345中1出现的次数。1的出现分为两种情况。首先分析1出现在最高位(本例中是万位)的情况。在1346-21345的数字中， 1出现在10000〜19999这10000个数字的万位中，一共出现了10^4次。<br>
  值得注意的是，并不是对所有5位数而言在万位出现的次数都是10000 次。对于万位是1的数字如输入12345, 1只出现在10000-12345的万位, 出现的次数不是1次，而是2346次，也就是除去最高数字之后剩下的数字再加上1 (2345+1=2346次)。<br>
  接下来分析1出现在除最高位之外的其他4位数中的情况。例子中 1346〜21345这20000个数字中后4位中1出现的次数是8000次。由于最高位是2,我们可以再把1346〜21345分成两段：1346〜11345和11346〜21345,每一段剩下的4位数字中，选择其中一位是1，其余三位可以在0〜 9这10个数字中任意选择，因此根据排列组合原则，总共出现的次数是2X 4x10^3=8000 次。<br>
  至于在1〜1345中1出现的次数，我们就可以用递归求得了。这也是 我们为什么要把1〜21345分成1〜1345和1346-21345两段的原因。因为把21345的最高位去掉就变成1345,便于我们采用递归的思路。<br>
  这种思路是每次去掉最高位进行递归，递归的次数和位数相同。一个数字n有O(logn)位，因此这种思路的时间复杂度是O(logn),比前面的原始方法要好很多。</p>
<pre><code>int NumberOf1(unsigned int n);

int NumberOf1Between1AndN_Solution1(unsigned int n)
{
    int number = 0;

    for(unsigned int i = 1; i &lt;= n; ++ i)
        number += NumberOf1(i);

    return number;
}

int NumberOf1(unsigned int n)
{
    int number = 0;
    while(n)
    {
        if(n % 10 == 1)
            number ++;

        n = n / 10;
    }

    return number;
}

// ====================方法二====================
int NumberOf1(const char* strN);
int PowerBase10(unsigned int n);

int NumberOf1Between1AndN_Solution2(int n)
{
    if(n &lt;= 0)
        return 0;

    char strN[50];
    sprintf(strN, &quot;%d&quot;, n);

    return NumberOf1(strN);
}

int NumberOf1(const char* strN)
{
    if(!strN || *strN &lt; '0' || *strN &gt; '9' || *strN == '\0')
        return 0;

    int first = *strN - '0';
    unsigned int length = static_cast&lt;unsigned int&gt;(strlen(strN));

    if(length == 1 &amp;&amp; first == 0)
        return 0;

    if(length == 1 &amp;&amp; first &gt; 0)
        return 1;

    // 假设strN是&quot;21345&quot;
    // numFirstDigit是数字10000-19999的第一个位中1的数目
    int numFirstDigit = 0;
    if(first &gt; 1)
        numFirstDigit = PowerBase10(length - 1);
    else if(first == 1)
        numFirstDigit = atoi(strN + 1) + 1;

    // numOtherDigits是01346-21345除了第一位之外的数位中1的数目
    int numOtherDigits = first * (length - 1) * PowerBase10(length - 2);
    // numRecursive是1-1345中1的数目
    int numRecursive = NumberOf1(strN + 1);

    return numFirstDigit + numOtherDigits + numRecursive;
}

int PowerBase10(unsigned int n)
{
    int result = 1;
    for(unsigned int i = 0; i &lt; n; ++ i)
        result *= 10;

    return result;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 题42:连续子数组的最大和]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-ti-42lian-xu-zi-shu-zu-de-zui-da-he</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-ti-42lian-xu-zi-shu-zu-de-zui-da-he">
        </link>
        <updated>2020-03-03T00:31:57.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)<br>
例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。</p>
</blockquote>
<p>非常简单，就是如果max小于0的话说明它对当前值已经没有增益了，必须舍弃掉<br>
而大于等于0的话则值得继续加下去<br>
需要注意的点是必须把max和res初始化为INT_MIN，仅仅值初始化或者初始化为0的话如果整个数组都是负数的话会返回错误的结果<br>
然后这个条件判断最后可以转化为动态规划</p>
<pre><code>class Solution {
public:
    int FindGreatestSumOfSubArray(vector&lt;int&gt; array) {
        int max,res;
        max=INT_MIN;
        res=INT_MIN;
        for(auto num:array){
            /*
            if(max&lt;0)
                max=num;
            else
                max+=num;
             */
            max=num&gt;max+num?num:max+num;//动态规划
            res=res&gt;max?res:max;
        }
        return res;
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>动态规划法<br>
  如果算法的功底足够扎实，那么我们还可以用动态规划的思想来分析这个问题。如果用函数f(i)表示以第i个数字结尾的子数组的最大和，那么我们需要求出max[f(i)],<br>
  当以第i-1个数字结尾的子数组中所有数字的和小于0时，如果把这个负数与第，个数累加，则得到的结果比第i个数字本身还要小，所以这种情况下以第i个数字结尾的子数组就是第i个数字本身。如果以第i-1个数字结尾的子数组中所有数字的和大于0, 则与第i个数字累加就得到以第i个数字结尾的子数组中所有数字的和。<br>
  注意，虽然通常我们用递归的方式分析动态规划的问题，但最终都会基于循环去编码。<br>
  面试的时候我们要考虑无效的输入，如输入的数组参数为空指针、数 组长度小于等于0等情况。此时我们让函数返回什么数字？如果返回0,那我们又怎么区分子数组的和的最大值是0和无效输入这两种不同情况呢？ 因此，我们定义了一个全局变量来标记是否输入无效。</p>
</blockquote>
<pre><code>bool g_InvalidInput = false;

int FindGreatestSumOfSubArray(int *pData, int nLength)
{
    if((pData == nullptr) || (nLength &lt;= 0))
    {
        g_InvalidInput = true;
        return 0;
    }

    g_InvalidInput = false;

    int nCurSum = 0;
    int nGreatestSum = 0x80000000;
    for(int i = 0; i &lt; nLength; ++i)
    {
        if(nCurSum &lt;= 0)
            nCurSum = pData[i];
        else
            nCurSum += pData[i];

        if(nCurSum &gt; nGreatestSum)
            nGreatestSum = nCurSum;
    }

    return nGreatestSum;
} 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 题41:数据流的中位数]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-ti-41shu-ju-liu-de-zhong-wei-shu</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-ti-41shu-ju-liu-de-zhong-wei-shu">
        </link>
        <updated>2020-03-03T00:12:48.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p>
</blockquote>
<p>  这道题没啥好说的，其实是左大顶堆和右小顶堆的配合<br>
  主要就是要控制好两个堆的数量之差，相差不能超过1，并且必须有一个得是保存中心点的<br>
  然后就是注意每次插入都要手动更新min，不能指望客户每次插入都查询min，否则就会导致多次插入出现问题</p>
<p>  最坑的点就是！！！size()返回的是无符号数！！！一定要防止size()相减得到负数或者size()和负数比较！！！<br>
  否则无符号数和有符号数一起运算时，有符号数强行转化为无符号数，接着负数会强行转化为一个很大的正数，导致判断一直通过或者一直不通过</p>
<pre><code>class Solution {
public:
    void Insert(int num)
    {
        if(left_max.size()==0&amp;&amp;right_min.size()==0){
            left_max.push(num);
            mid=GetMedian();
            return;
        }
                
        if((double)num&lt;=mid)
            left_max.push(num);
        else
            right_min.push(num);
        if(left_max.size()&gt;right_min.size()+1){
            right_min.push(left_max.top());
            left_max.pop();
        }
        if(right_min.size()&gt;left_max.size()){
            left_max.push(right_min.top());
            right_min.pop();
        }
        mid=GetMedian();
    }

    double GetMedian()
    { 
        if(left_max.size()==0&amp;&amp;right_min.size()==0)
            return 0.0;
        if(left_max.size()==right_min.size())
            mid=static_cast&lt;double&gt;(left_max.top()+right_min.top())/2;
        else 
            mid=static_cast&lt;double&gt;(left_max.top());
        return mid;
    }

private:
    priority_queue&lt;int&gt; left_max;
    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; right_min;
    double mid;
};
</code></pre>
<p>书本题解<br>
<img src="https://lixin-scut.github.io//post-images/1583195223562.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1583195244385.png" alt=""></p>
<blockquote>
<p>  我们注意到整个数据容器被分隔成两部分。位于容器左边部分的数据比右边的数据小。另外，P1指向的数据是左边部分最大的数，P2指向的数据是左边部分最小的数。<br>
  如果能够保证数据容器左边的数据都小于右边的数据，那么即使左、 右两边内部的数据没有排序，也可以根据左边最大的数及右边最小的数得 到中位数。如何快速从一个数据容器中找出最大数？用最大堆实现这个数据容器，因为位于堆顶的就是最大的数据。同样，也可以快速从最小堆中找出最小数。<br>
  因此，可以用如下思路来解决这个问题：用一个最大堆实现左边的数据容器，用一个最小堆实现右边的数据容器。往堆中插入一个数据的时间 效率是O(logn)。由于只需要O(1)时间就可以得到位于堆顶的数据，因此得 到中位数的时间复杂度是O(1)。</p>
</blockquote>
<pre><code>template&lt;typename T&gt; class DynamicArray
{
public:
    void Insert(T num)
    {
        if(((min.size() + max.size()) &amp; 1) == 0)
        {
            if(max.size() &gt; 0 &amp;&amp; num &lt; max[0])
            {
                max.push_back(num);
                push_heap(max.begin(), max.end(), less&lt;T&gt;());

                num = max[0];

                pop_heap(max.begin(), max.end(), less&lt;T&gt;());
                max.pop_back();
            }

            min.push_back(num);
            push_heap(min.begin(), min.end(), greater&lt;T&gt;());
        }
        else
        {
            if(min.size() &gt; 0 &amp;&amp; min[0] &lt; num)
            {
                min.push_back(num);
                push_heap(min.begin(), min.end(), greater&lt;T&gt;());

                num = min[0];

                pop_heap(min.begin(), min.end(), greater&lt;T&gt;());
                min.pop_back();
            }

            max.push_back(num);
            push_heap(max.begin(), max.end(), less&lt;T&gt;());
        }
    }

    T GetMedian()
    {
        int size = min.size() + max.size();
        if(size == 0)
            throw exception(&quot;No numbers are available&quot;);

        T median = 0;
        if((size &amp; 1) == 1)
            median = min[0];
        else
            median = (min[0] + max[0]) / 2;

        return median;
    }

private:
    vector&lt;T&gt; min;
    vector&lt;T&gt; max;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[归并排序]]></title>
        <id>https://lixin-scut.github.io//post/gui-bing-pai-xu</id>
        <link href="https://lixin-scut.github.io//post/gui-bing-pai-xu">
        </link>
        <updated>2020-03-02T18:21:50.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://lixin-scut.github.io/post/pai-xu-suan-fa/">排序算法及其实现</a></p>
<p>  归并排序(Merging Sort)就是利用归并的思想实现的排序方法。它的原理是假设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1,然后两两归并，得到「n/2」(「x」表示不小于x的最小整数)个长度为2或1的有序子序列;再两两归并，......，<br>
  如此重复，直至得到一个长度为n的有序序列为止，这种排序方法称为2路归并排序。</p>
<pre><code>class MergingSort
{
public:
    void MergingSort0(vector&lt;int&gt; &amp;numbers);

private:
    void Divide(vector&lt;int&gt; &amp;numbers, int beg, int end);
    void Merge(vector&lt;int&gt; &amp;numbers, int beg, int mid, int end);
};

void MergingSort::MergingSort0(vector&lt;int&gt; &amp;numbers)
{
    Divide(numbers, 0, numbers.size()-1);
    print(numbers);
}

void MergingSort::Divide(vector&lt;int&gt; &amp;numbers,
                         int beg,
                         int end)
{
    if(beg == end)
        return;
    int mid = beg + (end - beg) / 2;
    Divide(numbers, beg, mid);
    Divide(numbers, mid+1,end);
    Merge(numbers, beg, mid+1, end);
}

void MergingSort::Merge(vector&lt;int&gt; &amp;numbers,
                        int beg,
                        int mid,
                        int end)
{
    vector&lt;int&gt; temp;
    temp.reserve(end - beg + 1);
    int loc = 0;
    int left = beg;
    int right = mid;
    while(left &lt; mid &amp;&amp; right &lt;= end)
    {
        if(numbers[left] &lt;= numbers[right])
        {
            temp[loc] = numbers[left];
            ++left;
        }
        else
        {
            temp[loc] = numbers[right];
            ++right;
        }
        ++loc;
    }

    int remain = left &lt; mid ? left : right;
    while(loc &lt; end - beg + 1)
    {
        temp[loc] = numbers[remain];
        ++loc;
        ++remain;
    }

    loc = 0;
    while(loc &lt; end - beg + 1)
    {
        numbers[loc + beg] = temp[loc];
        ++loc;
    }
}
</code></pre>
<p>归并排序是第一个需要额外空间的排序方法，因为把两个数组合为一个数组时除非不断地往后挪， 不然最好使用额外的数组保存排序结果。<br>
（我实现过程中犯的一个错误就是直接在原数组swap，这样会破坏有序性）</p>
<h3 id="复杂度分析">复杂度分析</h3>
<p>我们来分析一下归并排序的时间复杂度，一趟归并需要将相邻的有序序列进行两两归并。这需要将待排序序列中的所有记录扫描一遍，因此耗费O(n)时间，而由完全二叉树的深度可知，整个归并排序需要进行ceil(logn)次，因此，总的时间复杂度为O(nlogn)，而且这是归并排序算法中最好、最坏、平均的时间性能。<br>
由于归并排序在归并过程中需要与原始记录序列同样数墩的存储空间存放归并结果以 及递归时深度为logn的栈空间，因此空间复杂度为0(n+bgn)。<br>
另外，Merge函数中需要两两比较，不存在跳跃，因此归并排序是一种稳定的排序算法。<br>
也就是说，归并排序是一种比较占用内存，但却效率高且稳定的算法</p>
<h3 id="非递归实现">非递归实现</h3>
<p>因为需要递归到长度为1的子数组，所以递归的归并排序会耗费很多栈空间<br>
所以来看一下迭代的实现</p>
<pre><code>void MergingSort::MergingSort1(vector&lt;int&gt; &amp;numbers)
{
    int len = numbers.size();
    int step;
    int loc;

    step = 1;
    while(step &lt; len)
    {
        for(loc = 0;loc &lt; len-step; loc += 2*step )
        {
            if(loc &lt; len - 2*step)
            { Merge(numbers,loc,loc+step,loc+2*step-1); }
            else if (loc &lt; len - step)
            { Merge(numbers,loc,loc+step,len-1); }
        }
        step *= 2;
    }
    print(numbers);
}
</code></pre>
<p>迭代版比较简单，仍然使用了Merge()，所以Merge一定要有较高的通用性<br>
主要是当尾部第二个子序列不足step的时候需要额外的判断<br>
注意！如果尾部连一个子序列都不足step的时候是直接跳过的，因为后面肯定会和前面的子序列归并排序，不需要担心。<br>
（细节就是len不要定义为size()-1了。。。）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[堆排序]]></title>
        <id>https://lixin-scut.github.io//post/dui-pai-xu</id>
        <link href="https://lixin-scut.github.io//post/dui-pai-xu">
        </link>
        <updated>2020-03-02T17:36:14.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://lixin-scut.github.io/post/pai-xu-suan-fa/">排序算法及其实现</a></p>
<p>  其实以前我已经写过一次堆排序了（<a href="https://lixin-scut.github.io/post/dui-pai-xu-shi-xian/">堆排序实现</a>），这次就当作是复习和优化了</p>
<p>  堆排序（Heap Sort)就是利用堆（假设利用大顶堆）进行排序的方法。它的基本思想是， 将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根结点。将它移走 （其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的次小值。如此反复执行，便能得到一个有序序列了。</p>
<pre><code>class HeapSort
{
public:
    void HeapSort0(vector&lt;int&gt; &amp;numbers);

private:
    void HeapAdjust(int loc,vector&lt;int&gt; &amp;numbers, int end);
};

void HeapSort::HeapSort0(vector&lt;int&gt; &amp;numbers)
{
    int len = numbers.size();

    // build a heap first;
    for(int loc = len/2; loc &gt;= 0; --loc)
    {
        HeapAdjust(loc,numbers,len-1);
    }

    for(int loc = len-1; loc &gt; 0; --loc)
    {
        swap(numbers[loc],numbers[0]);
        HeapAdjust(0, numbers, loc-1);
    }
    print(numbers);
}


void HeapSort::HeapAdjust(int loc,
                          vector&lt;int&gt; &amp;numbers,
                          int end)
{
    int temp;
    int j;
    temp = numbers[loc];
    for(j = loc*2+1; j&lt;=end; j = j*2+1)
    {
        if(j&lt;end &amp;&amp; numbers[j] &lt; numbers[j+1])
        { ++j; }

        if(temp&gt;numbers[j])
        { break; }

        numbers[(j-1)/2] = numbers[j];
    }
    numbers[(j-1)/2] = temp;
}
</code></pre>
<p>  在实现的过程中有个问题就是下标问题，堆排序原来的性质是按下标1开始算的（例如当前节点的父节点下标为floor(loc/2)），但是C++的容器下标从0开始，所以就需要相应地+1或者-1。</p>
<p>  整个排序过程分为两个for循环。第一个循环要完成的就是将现在的待排序序列构建成一个大顶堆。第二个循环要完成的就是逐步将每个最大值的根结点与末尾元素交换，并且再调整其成为大顶堆。<br>
  所以注意！！！第一个循环后并非是有序顺序，大顶堆和二叉树不同，并非左子树的节点都小于右子树</p>
<p>  循环从(length-1)/2开始是因为从1到(length-1)/2都是有孩子的节点<br>
  我们所谓的将待排序的序列构建成为一个大顶堆，其实就是从下往上、从右到左，将每个非终端结点（非叶结点）当作根结点，将其和其子树调整成大顶堆</p>
<h3 id="堆排序复杂度分析">堆排序复杂度分析</h3>
<p>  运行时间主要是消耗在初始构建堆和在重建堆时的反复筛选上。<br>
  在构建堆的过程中，因为我们是完全二叉树从最下层最右边的非终端结点开始构 建，将它与其孩子进行比较和若有必要的互换，对于每个非终端结点来说，其实最多进行两次比较和互换操作，因此整个构建堆的时间复杂度为o(n)。<br>
  在正式排序时，第i次取堆顶记录重建堆需要用O(logi)的时间（完全二叉树的某个结点到根结点的距离为floor(logi)+1,并且需要取n-1次堆顶记录，因此，重建堆的时间复杂度为〇(nlogn)<br>
  所以总体来说，堆排序的时间复杂度为〇(nlogn)。由于堆排序对原始记录的排序状态并不敏感，因此它无论是最好、最坏和平均时间复杂度均为〇(nlogn)。<br>
  空间复杂度上，它只有一个用来交换的暂存单元，也非常的不错。<br>
  不过由于记录的比较与交换是跳跃式进行，因此堆排序也是一种<strong>不稳定的排序</strong>方法。</p>
]]></content>
    </entry>
</feed>