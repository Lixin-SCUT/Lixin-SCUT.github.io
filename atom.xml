<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-04-29T08:27:25.636Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>千里之行，始于足下。不积跬步，无以至千里。</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[MySQL 175. 组合两个表[简单]]]></title>
        <id>https://lixin-scut.github.io//post/mysql-175-zu-he-liang-ge-biao-jian-dan</id>
        <link href="https://lixin-scut.github.io//post/mysql-175-zu-he-liang-ge-biao-jian-dan">
        </link>
        <updated>2020-04-29T07:26:44.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>表1: Person<br>
+-------------+---------+<br>
| 列名         | 类型     |<br>
+-------------+---------+<br>
| PersonId    | int     |<br>
| FirstName   | varchar |<br>
| LastName    | varchar |<br>
+-------------+---------+<br>
PersonId 是上表主键<br>
表2: Address<br>
+-------------+---------+<br>
| 列名         | 类型    |<br>
+-------------+---------+<br>
| AddressId   | int     |<br>
| PersonId    | int     |<br>
| City        | varchar |<br>
| State       | varchar |<br>
+-------------+---------+<br>
AddressId 是上表主键<br>
 编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：<br>
FirstName, LastName, City, State<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/combine-two-tables<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题比较简单，重点在于“无论 person 是否有地址信息”，主要就是默认的inner join和outer join的区别，并且还有on和where的区别</p>
<pre><code>SELECT FirstName, LastName, City, State
FROM Person LEFT OUTER JOIN Address
ON Person.PersonId = Address.PersonId
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>方法：使用 outer join<br>
算法<br>
因为表 Address 中的 personId 是表 Person 的外关键字，所以我们可以连接这两个表来获取一个人的地址信息。<br>
考虑到可能不是每个人都有地址信息，我们应该使用 outer join 而不是默认的 inner join。</p>
</blockquote>
<pre><code>MySQL
select FirstName, LastName, City, State
from Person left join Address
on Person.PersonId = Address.PersonId
;
</code></pre>
<p><strong>注意：如果没有某个人的地址信息，使用 where 子句过滤记录将失败，因为它不会显示姓名信息。</strong></p>
<p><strong>《MySQL必知必会》相关知识点</strong><br>
  MySQL的联结表默认为内部联结或等值联结(equijoin)的简单联结，另外三种联结分别是自联结、自然联结和外部联结。</p>
<p><strong>自联结</strong><br>
  自联结就是同一个表联结起来，需要配合表别名使用，使用表别名的主要原因之一是能在单条SELECT语句中不止一次引用相同的表</p>
<p>  自联结可以解决子查询的问题： 自联结通常作为外部语句用来替代 从相同表中检索数据时使用的子查询语句。虽然最终的结果是 相同的，但有时候处理联结远比处理子查询快得多。应该试一 下两种方法，以确定哪一种的性能更好</p>
<p><strong>自然联结</strong><br>
  标准的联结(前一章中介绍的内部联结)返回所有数据，甚 至相同的列多次出现。自然联结排除多次出现，使每个列只返回一次。<br>
  但是系统不完成这项工作，由你自己完成它。自然联结是这样一种联结，其中你只能选择那些唯一的列。这一 般是通过对表使用通配符(SELECT * )，对所有其他表的列使用明确的子 集来完成的。</p>
<p>  事实上，迄今为止我们默认建立的每个内部联结都是自然联结，很可能我们永远都不会用到不是自然联结的内部联结。</p>
<p><strong>外部联结</strong><br>
  联结包含了那些在相关表中没有关联行的行。这种 类型的联结称为外部联结。<br>
  许多联结将一个表中的行与另一个表中的行相关联。但有时候会需要包含没有关联行的那些行。<br>
  在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字 指定包括其所有行的表(RIGHT指出的是OUTER JOIN右边的表，而LEFT 指出的是OUTER JOIN左边的表)。</p>
<p><strong>外部联结的类型</strong><br>
  存在两种基本的外部联结形式:左外部联结 和右外部联结。它们之间的唯一差别是所关联的表的顺序不 同。换句话说，左外部联结可通过颠倒FROM或WHERE子句中表的顺序转换为右外部联结。因此，两种类型的外部联结可互 换使用，而究竟使用哪一种纯粹是根据方便而定。</p>
<p>  使用LEFT OUTER JOIN从FROM子句的左边表中选择所有行。为了从右边的表中选择所有行，应该使用RIGHT OUTER JOIN</p>
<p>注意<br>
  没有<code>*=</code>操作符 MySQL不支持简化字符<code>*=</code>和<code>=*</code>的使用，这两 种操作符在其他DBMS中是很流行的。</p>
<p><strong>使用带聚集函数的联结</strong><br>
  聚集函数用来汇总数据。虽然至今为止聚集函数，但这些函数也可以与联结一起使用。<br>
  聚集函数也可以方便地与其他联结一起使用</p>
<p><strong>使用联结和联结条件</strong></p>
<ul>
<li><strong>注意所使用的联结类型。一般我们使用内部联结，但使用外部联结也是有效的。</strong></li>
<li>保证使用正确的联结条件，否则将返回不正确的数据。</li>
<li><strong>应该总是提供联结条件，否则会得出笛卡儿积。</strong></li>
<li>在一个联结中可以包含多个表，甚至对于每个联结可以采用不同的联结类型。虽然这样做是合法的，一般也很有用，但应该在一 起测试它们前，分别测试每个联结。这将使故障排除更为简单。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 71. 简化路径[中等]]]></title>
        <id>https://lixin-scut.github.io//post/zi-fu-chuan-71-jian-hua-lu-jing</id>
        <link href="https://lixin-scut.github.io//post/zi-fu-chuan-71-jian-hua-lu-jing">
        </link>
        <updated>2020-04-29T05:00:24.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。<br>
在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径<br>
请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。<br>
示例 1：<br>
输入：&quot;/home/&quot;<br>
输出：&quot;/home&quot;<br>
解释：注意，最后一个目录名后面没有斜杠。<br>
示例 2：<br>
输入：&quot;/../&quot;<br>
输出：&quot;/&quot;<br>
解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。<br>
示例 3：<br>
输入：&quot;/home//foo/&quot;<br>
输出：&quot;/home/foo&quot;<br>
解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。<br>
示例 4：<br>
输入：&quot;/a/./b/../../c/&quot;<br>
输出：&quot;/c&quot;<br>
示例 5：<br>
输入：&quot;/a/../../b/../c//.//&quot;<br>
输出：&quot;/c&quot;<br>
示例 6：<br>
输入：&quot;/a//b////c/d//././/..&quot;<br>
输出：&quot;/a/b/c&quot;<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/simplify-path<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>首先题意就是<br>
1.遇到/./直接消除<br>
2.遇到/../消除上一级</p>
<p>我想到一个比较便捷的方法hhh，直接用栈来保存，不管斜杠，直接保存文件目录名和.、..两种，遇到..就pop一下，.可以直接忽略，其他的直接入栈</p>
<p>实现中需要注意的问题</p>
<ol>
<li>所有判断条件都需要加上范围判断，防止访问到非法区域</li>
<li>先找到第一个非斜杠，再找第一个斜杠或者尾后区域</li>
<li>pop之前记得要先判断栈是否为空</li>
<li>因为不需要用到栈的特性加上需要从头访问，所以我用了vector而不是stack或者deque</li>
<li>最后的字符串很麻烦，首先如果是空的路径或者只有&quot;/../&quot;，就只能返回&quot;/&quot;</li>
<li>然后最后还必须把&quot;/&quot;去掉，所以只能按照i的位置来判断是否需要加。。。</li>
</ol>
<pre><code>class Solution {
public:
    string simplifyPath(string path) {
        vector&lt;string&gt; result;
        
        string folder;
        int beg = 0;
        int end = 0;
        int i = 0;
        while(i &lt; path.size())
        {
            while(i &lt; path.size() &amp;&amp; path[i] == '/')
            {
                ++i;
            }
            beg = i;
            while(i &lt; path.size() &amp;&amp; path[i] != '/')
            {
                ++i;
            }
            end = i;
            if(beg &lt; path.size() &amp;&amp; beg &lt; end)
            {
                folder = path.substr(beg, end - beg );
                if(folder == &quot;.&quot;)
                {  continue; }
                else if(folder == &quot;..&quot;)
                {
                    if(!result.empty())
                    {
                        result.pop_back();
                    }
                }
                else
                {
                    result.push_back(folder);
                }
            }
        }
        
        string ans = &quot;/&quot;;
        for(int i = 0; i &lt; result.size(); ++i)
        {
            ans += result[i] ;
            if(i != result.size() - 1)
            {   ans += &quot;/&quot;; } 
        }
        return ans;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 25. K 个一组翻转链表[困难]]]></title>
        <id>https://lixin-scut.github.io//post/lian-biao-25-k-ge-yi-zu-fan-zhuan-lian-biao-kun-nan</id>
        <link href="https://lixin-scut.github.io//post/lian-biao-25-k-ge-yi-zu-fan-zhuan-lian-biao-kun-nan">
        </link>
        <updated>2020-04-29T04:42:52.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。<br>
k 是一个正整数，它的值小于或等于链表的长度。<br>
如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。<br>
示例：<br>
给你这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5<br>
当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5<br>
当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5<br>
说明：<br>
你的算法只能使用常数的额外空间。<br>
你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/reverse-nodes-in-k-group<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>首先想到的是链表反转，这个不难<br>
困难点在于传入函数的两个节点，因为链表反转后必须和前后两个节点进行一个重新链接，所以必须保存好前后两个节点。<br>
最后我是用的是辅助头节点+左开右闭的方式，亦即例如1-2-3-4-5，要反转3-4的时候，传入2和4作为辅助节点<br>
因为pre_node初始化的原因，我们可以把pre_node初始化为5，在循环中直接连接起来<br>
然后2的话必须手动和4连接起来<br>
注意我们必须提前保存3的节点，而不是cur_node节点4，因为反转后变为1-2-4-3，所以3刚好就是下一个需要传入的辅助节点</p>
<p>实现中需要注意的：</p>
<ol>
<li>注意函数中，结点值的指向的变化，最好是保留temp值用于赋值</li>
<li>防止出现循环链表</li>
</ol>
<pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        if(head == nullptr)
        {
            return head;
        }
        ListNode* virHead = new ListNode(-1);
        virHead-&gt;next = head;
        
        ListNode* begin = virHead;
        ListNode* cur_node = begin;
        int index = 0;
        
        while(cur_node != nullptr)
        {
            cur_node = cur_node -&gt;next;
            ++index;
            if(cur_node != nullptr &amp;&amp; index == k)
            {
                ListNode* temp = begin-&gt;next;
                reverseList(begin, cur_node);
                begin = temp;
                cur_node = temp;
                index = 0;
            }
        }
        return virHead-&gt;next;
    }
    
    void reverseList(ListNode* begin, ListNode* end)
    {
        ListNode* pre_node = end-&gt;next;
        ListNode* cur_node = begin-&gt;next;
        ListNode* next_node = end;
        
        ListNode* last = end-&gt;next;
        
        while(cur_node != last)
        {
            next_node = cur_node-&gt;next;
            cur_node-&gt;next = pre_node;
            pre_node = cur_node;
            cur_node = next_node;
        }
        
        begin-&gt;next = pre_node;
    }
};
</code></pre>
<p>然后贴一个网友题解，他的是断开再重连，但是他说的时间复杂度我不是很赞同<br>
，我认为是O(2n)</p>
<blockquote>
<p>步骤分解:<br>
1.链表分区为已翻转部分+待翻转部分+未翻转部分<br>
2.每次翻转前，要确定翻转链表的范围，这个必须通过 k 此循环来确定<br>
3.需记录翻转链表前驱和后继，方便翻转完成后把已翻转部分和未翻转部分连接起来<br>
4.初始需要两个变量 pre 和 end，pre 代表待翻转链表的前驱，end 代表待翻转链表的末尾<br>
5.经过k此循环，end 到达末尾，记录待翻转链表的后继 next = end.next<br>
6.翻转链表，然后将三部分链表连接起来，然后重置 pre 和 end 指针，然后进入下一次循环<br>
7.特殊情况，当翻转部分长度不足 k 时，在定位 end 完成后，end==null，已经到达末尾，说明题目已完成，直接返回即可</p>
</blockquote>
<pre><code>public ListNode reverseKGroup(ListNode head, int k) {
    ListNode dummy = new ListNode(0);
    dummy.next = head;

    ListNode pre = dummy;
    ListNode end = dummy;

    while (end.next != null) {
        for (int i = 0; i &lt; k &amp;&amp; end != null; i++) end = end.next;
        if (end == null) break;
        ListNode start = pre.next;
        ListNode next = end.next;
        end.next = null;
        pre.next = reverse(start);
        start.next = next;
        pre = start;

        end = pre;
    }
    return dummy.next;
}

private ListNode reverse(ListNode head) {
    ListNode pre = null;
    ListNode curr = head;
    while (curr != null) {
        ListNode next = curr.next;
        curr.next = pre;
        pre = curr;
        curr = next;
    }
    return pre;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[shared_ptr与weak_ptr的底层实现]]></title>
        <id>https://lixin-scut.github.io//post/shared_ptr-yu-weak_ptr-de-di-ceng-shi-xian</id>
        <link href="https://lixin-scut.github.io//post/shared_ptr-yu-weak_ptr-de-di-ceng-shi-xian">
        </link>
        <updated>2020-04-28T08:41:54.000Z</updated>
        <content type="html"><![CDATA[<p>面试的时候遇到一个问题：weak_ptr怎么去感知shared_ptr已经被析构呢？</p>
<p>先贴一下我的思考过程吧：</p>
<h3 id="面试回答">面试回答</h3>
<p>在面试的过程中我参考了引用计数的方式</p>
<ol>
<li>认为在shared_ptr里面应该有一个弱引用计数</li>
<li>在shared_ptr赋值给weak_ptr的时候就会相应地增加这个弱引用计数</li>
<li>然后在weak_ptr析构的时候自动提升为shared_ptr然后减少弱引用计数。</li>
<li>最后在shared_ptr析构的时候，如果普通计数达到了就析构所指对象，但是  如果此时弱引用计数不为0的话就先不用析构shared_ptr，使得weak_ptr可以继续访问shared_ptr的弱引用计数</li>
</ol>
<p>  但是这个答案有个问题就是如果由shared_ptr来保存弱引用计数的话，如果shared_ptr析构后怎么保存这个弱引用计数呢？后来面试结束后我去寻找这个问题的答案</p>
<h3 id="官方文档">官方文档</h3>
<p>  c++的官方文档中中并没有给出函数的具体代码，但是从成员函数的描述中我们可以发现一些蛛丝马迹</p>
<p>首先是lock()：</p>
<blockquote>
<p>Returns a shared_ptr with the information preserved by the weak_ptr object if it is not <strong>expired</strong>.<br>
说明和expired成员函数有关（虽然有点强行hhh）</p>
</blockquote>
<p>然后再看expired()：</p>
<blockquote>
<p>Returns whether the weak_ptr object is either empty or there are no more shared_ptr in the owner group it belongs to.<br>
Expired pointers act as empty weak_ptr objects when locked, and thus can no longer be used to restore an owning shared_ptr.<br>
This function <strong>shall return the same as (use_count()==0)</strong>, although it may do so in a more efficient way.</p>
</blockquote>
<p>这里就说明expired内部很可能是调用了use_count来作为返回判断结果</p>
<p>最后看一下use_count()</p>
<blockquote>
<p>Returns the number of shared_ptr objects that share ownership over the same pointer as this object.<br>
Notice that weak_ptr objects in the owning group are not counted.<br>
If this is an empty weak_ptr, the function <strong>returns zero</strong>.<br>
Library implementations are not required to keep a count of any particular set of owners, and thus it may not be efficient to call this function. To check specifically <strong>whether use_count is 0</strong>, you can use member expired instead, which may be faster.</p>
</blockquote>
<p>这里就说明会返回一个0，那这个0是怎么来的呢？</p>
<p>代码实验</p>
<pre><code>weak_ptr&lt;int&gt; weak_ptr1;

void setptr()
{
    shared_ptr&lt;int&gt; shared_ptr1(new int(10));
    weak_ptr1 = shared_ptr1;
    cout&lt;&lt;weak_ptr1.use_count()&lt;&lt;endl;
}

int main() {
    setptr();
    cout&lt;&lt;weak_ptr1.use_count()&lt;&lt;endl;
}
// 输出 1 与 0
</code></pre>
<p>  注意此时shared_ptr应该已经是被析构的了，说明我在面试中的答案确实无法完全解释这个问题，应该是从某处继续保留了这个0值</p>
<h3 id="boost源码">boost源码</h3>
<p>智能指针都是起源于boost库<br>
所以最后还是探索一下源码</p>
<p>这篇文章<a href="https://blog.csdn.net/ithiker/article/details/51532484?utm_source=blogxgwz1">C++ 智能指针（shared_ptr/weak_ptr）源码分析</a>总结得比较好，值得学习<br>
源码有一千行+，就不直接贴上来了</p>
<p>首先上个人总结：</p>
<ol>
<li>两种智能指针内部都包含两个部分，一个是指向动态分配对象的裸指针，另一个是对象__shared_count或者__weak_count，两者都是包含指向一个管理对象的指针</li>
<li>指向动态分配对象的裸指针主要用于重载原生指针的操作，进行访问等</li>
<li>对象__shared_count或者__weak_count指向同一个管理对象，其中包括use_count、weak_count、指向动态分配对象的裸指针和删除器</li>
<li>注意__shared_ptr直接包含的裸指针是为了实现一般指针的<code>-&gt;,*</code>等操作，通过__shared_count间接包含的指针是为了管理对象的生命周期，回收相关资源。</li>
<li>然后注意use_count达到0的时候就会析构被管理的动态分配对象和shared_ptr，但是如果weak_ptr还存在的话，那_M_weak_count必不为1，所以管理对象_Sp_counted_base_impl不会被析构，所以就可以让weak_ptr的use_count()操作返回0，但是注意_M_weak_count是无法返回的</li>
<li>注意除了循环引用，还有一个问题就是多个不相关的shared_ptr指向同一个对象造成二次析构，所以此时就要使用enable_shared_from_this，基本思想是通过M继承模板类enable_shared_from_this，这样对象M内部将会有一个__weak_ptr指针_M_weak_this，在第一次创建指向M的shared_ptr Pt时，通过模板特化，将会初始化_M_weak_this;这样M内部也会产生一个指向自身的weak_ptr，并且该weak_ptr内部的管理对象与Pt的管理对象是相同的。这样，在M内部，当需要传递指向M的智能指针时，可以通过继承而来的shared_from_this方法获取到指向M的智能指针而不会发生内存泄漏。</li>
<li>在采用<code>shared_ptr&lt;M&gt; p(new M);</code>形式创建p来管理M时，我们实际发现这中间有两次的动态内存分配：一次为创建被管理对象M，一次为创建管理对象；采用<code>shared_ptr&lt;M&gt; p(make_shared&lt;M&gt;);</code>的方式，采用这种方式系统将会分配一大块内存同时存放管理对象和被管理对象，这就避免了上面所说的二次内存分配的问题，同时程序中也不会出现new操作符，符合&quot;no naked new!&quot;的编程倡导。</li>
</ol>
<h3 id="主要分析">主要分析</h3>
<p>主要的类关系<br>
<img src="https://lixin-scut.github.io//post-images/1588074947135.png" alt=""><br>
  从上面的类图可以清楚的看出shared_ptr内部含有一个指向<strong>被管理对象(managed object)</strong> T的指针以及一个<code>__shared_count</code>对象，  <code>__shared_count</code>对象包含一个指向<strong>管理对象(manager object)</strong> 的基类指针，管理对象(manager object)由具有原子属性的use_count和weak_count、指向被管理对象(managed object)T的指针、以及用来销毁被管理对象的deleter组成，以下均将用new创建后托管给shared_ptr等智能指针管理的对象叫做<strong>被管理对象（managed object)</strong>；shared_ptr等智能指针内部创建的用来维护被管理对象生命周期的实例叫做<strong>管理对象(manager object)</strong>：<br>
<img src="https://lixin-scut.github.io//post-images/1588075047344.png" alt=""></p>
<p>  weak_ptr内部组成与shared_ptr类似，内部同样含有一个指向被管理对象T的指针以及一个__weak_count对象：<br>
<img src="https://lixin-scut.github.io//post-images/1588075070650.png" alt=""></p>
<p>  从图对比可以看出，shared_ptr与weak_ptr的差异主要是由__shared_ptr与__weak_ptr体现出来的，而__shared_ptr与__weak_ptr的差异则主要是由__shared_count与__weak_count体现出来。</p>
<p>  通过shared_ptr的构造函数，可以发现，在创建一个shared_ptr的时候需要一个new 操作符返回被管理对象的地址来初始化shared_ptr, shared_ptr在内部会构建一个_shared_count对象，由_shared_count对象的构造函数可知，创建shared_ptr的时候也动态的创建了一个管理对象_Sp_counted_base_impl:</p>
<pre><code>template&lt;typename _Tp1&gt; explicit __shared_ptr(_Tp1* __p)
: _M_ptr(__p), _M_refcount(__p) {
    __glibcxx_function_requires(_ConvertibleConcept&lt;_Tp1*, _Tp*&gt;)
    typedef int _IsComplete[sizeof(_Tp1)];
    __enable_shared_from_this_helper(_M_refcount, __p, __p);
}
 
template&lt;typename _Ptr&gt;
__shared_count(_Ptr __p) : _M_pi(0)
{
    __try
   {
	  typedef typename std::tr1::remove_pointer&lt;_Ptr&gt;::type _Tp;
	  _M_pi = new _Sp_counted_base_impl&lt;_Ptr, _Sp_deleter&lt;_Tp&gt;, _Lp&gt;(__p, _Sp_deleter&lt;_Tp&gt;());
    }
    __catch(...)
    {
        delete __p;
	__throw_exception_again;
    }
</code></pre>
<p>  <strong>shared_ptr内部包含一个指向被管理对象的指针_M_ptr, <code>_Sp_counted_base_impl</code>内部也含有一个指向被管理对象的指针_M_ptr， 它们是不是重复多余了呢？</strong></p>
<p>  实际上不多余，它们有各自的功能。这首先要从shared_ptr的拷贝构造或者赋值构造说起，当一个shared_ptr对象sp2是由sp1拷贝构造或者赋值构造得来的时候，实际上构造完成后sp1内部的__shared_count对象包含的指向管理对象的指针与sp2内部的__shared_count对象包含的指向管理对象的指针是相等的，也就是说当<strong>多个shared_ptr对象来管理同一个对象时，它们共同使用同一个动态分配的管理对象。</strong> 这可以从下面的__share_ptr的构造函数和__shared_count的构造函数清楚的看出。</p>
<pre><code>template&lt;typename _Tp1&gt;
 __shared_ptr(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __r)
 : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) // never throws
{__glibcxx_function_requires(_ConvertibleConcept&lt;_Tp1*, _Tp*&gt;)}
 
 
__shared_count&amp;
operator=(const __shared_count&amp; __r) // nothrow
{
    _Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;
    if (__tmp != _M_pi)
    {
        if (__tmp != 0)
            __tmp-&gt;_M_add_ref_copy();
	if (_M_pi != 0)
	    _M_pi-&gt;_M_release();
	
        _M_pi = __tmp;
    }
}
</code></pre>
<p>  上面说说当多个shared_ptr对象来管理同一个对象时，它们共同使用同一个动态分配的管理对象，为什么上面给出的_shared_count的构造函数中出现了<code>__tmp != _M_pi</code>的情形呢？这在sp2未初始化时（<code>_M_pi</code>为0，<code>_r._M_pi</code>非0）便是这样的情形。</p>
<p>  更一般的，也可以考虑这样的情形：shared_ptr实例sp1开始指向类A的实例对象a1, 另外一个shared_ptr实例sp2指向类A的实例对象a2（a1 != a2)，当把sp2赋值给sp1时便会出现上面的情形。假设初始时有且仅有一个sp1指向a1, 有且仅有一个sp2指向a2; 则赋值结束时sp1与sp2均指向a2, 没有指针指向a1, sp1指向的a1以及其对应的管理对象均应该被析构。这在上面的代码中我们可以很清楚的看到：因为<code>__tmp != _M_pi</code>,  <code>__tmp-&gt;_M_add_ref_copy()</code>将会增加a2的use_count的引用计数；由于a1内部的_M_pi != 0, 将会调用其_M_release()函数：</p>
<pre><code>//************_Sp_counted_base*****************//
void
_M_add_ref_copy()
{ __gnu_cxx::__atomic_add_dispatch(&amp;_M_use_count, 1); }
 
 
//************_Sp_counted_base*****************//
void
_M_release() // nothrow
{
    // Be race-detector-friendly.  For more info see bits/c++config.
    _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_use_count);
	if (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_use_count, -1) == 1)
	{
            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_use_count);
	    _M_dispose();
	    // There must be a memory barrier between dispose() and destroy()
	    // to ensure that the effects of dispose() are observed in the
	    // thread that runs destroy().
	    // See http://gcc.gnu.org/ml/libstdc++/2005-11/msg00136.html
	    if (_Mutex_base&lt;_Lp&gt;::_S_need_barriers)
	    {
		    __atomic_thread_fence (__ATOMIC_ACQ_REL);
	    }
 
            // Be race-detector-friendly.  For more info see bits/c++config.
            _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_weak_count);
	    if (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_weak_count, -1) == 1)
            {
		_GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_weak_count);
	        _M_destroy();
             }
	}
}
 
//************_Sp_counted_base*****************//
// Called when _M_use_count drops to zero, to release the resources
// managed by *this.
virtual void
_M_dispose() = 0; // nothrow
 
// Called when _M_weak_count drops to zero.
virtual void
_M_destroy() // nothrow
{ delete this; }
 
//************_Sp_counted_base_impl*************//
virtual void
_M_dispose() // nothrow
{ _M_del(_M_ptr); }
</code></pre>
<p>  <code>_M_release()</code>函数首先对a1的use_count减去1，并对比减操作之前的值，如果减之前是1，说明减后是0，a1没有任何shared_ptr指针指向它了，应该将a1对象销毁，于是调用_M_dispose()函数销毁a1; 同时对a1的weak_count减去1，也对比减操作之前的值，如果减之前是1，说明减后是0，a1没有weak_ptr指向它了，应该将管理对象销毁，于是调用_M_destroy()销毁了管理对象。这就可以解答为什么图2所示中shared_ptr内部含有两个指向被管理对象的指针了：<strong><code>shared_ptr</code>直接包含的裸指针是为了实现一般指针的<code>-&gt;,*</code>等操作，通过<code>shared_count</code>间接包含的指针是为了管理对象的生命周期，回收相关资源。</strong></p>
<p>  换句话说，<strong><code>shared_count</code>内部的<code>use_count</code>主要用来标记被管理对象的生命周期，<code>weak_count</code>主要用来标记管理对象的生命周期。</strong></p>
<p>  当一个shared_ptr超出作用域被销毁时，它会调用其_share_count的_M_release()对use_count和weak_count进行自减并判断是否需要释放管理对象和被管理对象，这是RAII原理的核心体现：</p>
<pre><code>~__shared_count() // nothrow
 {
	 if (_M_pi != 0)
	  _M_pi-&gt;_M_release();
 }
</code></pre>
<p>对于weak_ptr, 其对应的__weak_count的拷贝构造函数如下:</p>
<pre><code>//************_Sp_counted_base*****************//
 void
 _M_weak_add_ref() // nothrow
{ __gnu_cxx::__atomic_add_dispatch(&amp;_M_weak_count, 1); }
 
//************_Sp_counted_base*****************//
void
_M_weak_release() // nothrow
{
    // Be race-detector-friendly. For more info see bits/c++config.
    _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_weak_count);
    if (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_weak_count, -1) == 1)
    {
        _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_weak_count);
	if (_Mutex_base&lt;_Lp&gt;::_S_need_barriers)
	{
	    // See _M_release(),
	    // destroy() must observe results of dispose()
            __atomic_thread_fence (__ATOMIC_ACQ_REL);
	}
	_M_destroy();
    }
}
 
__weak_count&lt;_Lp&gt;&amp;
operator=(const __shared_count&lt;_Lp&gt;&amp; __r) // nothrow
{
    _Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;
    if (__tmp != 0)
        __tmp-&gt;_M_weak_add_ref();
  
    if (_M_pi != 0)
        _M_pi-&gt;_M_weak_release();
  
    _M_pi = __tmp;  
	
    return *this;
}
      
__weak_count&lt;_Lp&gt;&amp;
operator=(const __weak_count&lt;_Lp&gt;&amp; __r) // nothrow
{
    _Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;
    if (__tmp != 0)
        __tmp-&gt;_M_weak_add_ref();
    if (_M_pi != 0)
        _M_pi-&gt;_M_weak_release();
    _M_pi = __tmp;
	
    return *this;
}
 
__weak_count&lt;_Lp&gt;&amp;
operator=(const __shared_count&lt;_Lp&gt;&amp; __r) // nothrow
{
    _Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;
    if (__tmp != 0)
      __tmp-&gt;_M_weak_add_ref();
    if (_M_pi != 0)
      _M_pi-&gt;_M_weak_release();
    _M_pi = __tmp;  
    return *this;
}
 
~__weak_count() // nothrow
{
    if (_M_pi != 0)
        _M_pi-&gt;_M_weak_release();
}
</code></pre>
<p>从上面可以看出:</p>
<p>  <code>__weak_count</code>相关的赋值拷贝以及析构函数均只会影响到weak_count的值，对use_count没有影响；当weak_count为0时，释放管理对象。也就是说__weak_ptr不影响被管理对象的生命周期。同时<strong>由于weak_ptr没有像shared_ptr那样实现*，-&gt;等常见指针相关操作符，weak_ptr不能直接操作被管理对象；</strong><br>
  <code>__weak_count</code>自身间的赋值以及<code>__shared_count</code>对<code>__weak_count</code>的赋值时，它们都具有同样的指向管理对象的指针；也就是说<strong>当多个<code>weak_ptr</code>和<code>shared_ptr</code>指向同一个被管理对象时，它们共享同一个管理对象</strong>，这就保证了可以通过<code>__weak_ptr</code>可以判断<code>__shared_ptr</code>指向的被管理对象是否存在以及获取到被管理对象的指针。<br>
 <br>
<code>__shared_ptr</code>与<code>__weak_ptr</code>在管理同一对象时，它们间的关系如下图4所示：<br>
<img src="https://lixin-scut.github.io//post-images/1588075449346.png" alt=""></p>
<p>  由于weak_ptr不能直接操作被管理对象但其仍然持有指向被管理对象的指针（用来初始化内部的__weak_count对象），weak_ptr与被管理对象用虚线联接。</p>
<p>  <code>_weak_ptr</code>有几个重要的成员函数：通过expired()方法来判断对象是否过期（已经被释放）；通过use_count()方法返回目前有多少个<code>__shared_ptr</code>对象指向被管理对象；通过lock()方法返回一个指向被管理对象的<code>__shared_ptr</code>指针，调用者可以通过这个<code>__shared_ptr</code>指针来操纵被管理对象而不用担心资源泄漏；</p>
<pre><code>/*************_weak_ptr*************************/
long
use_count() const // never throws
{ return _M_refcount._M_get_use_count(); }
 
bool
expired() const // never throws
{ return _M_refcount._M_get_use_count() == 0; }
 
__shared_ptr&lt;_Tp, _Lp&gt;
lock() const // never throws
{
#ifdef __GTHREADS
       // Optimization: avoid throw overhead.
    if (expired())
              return __shared_ptr&lt;element_type, _Lp&gt;();
 
    __try
    {
            return __shared_ptr&lt;element_type, _Lp&gt;(*this);
    }
    __catch(const bad_weak_ptr&amp;)
    {
        // Q: How can we get here?
       // A: Another thread may have invalidated r after the
       //    use_count test above.
       return __shared_ptr&lt;element_type, _Lp&gt;();
     }
    
#else
    // Optimization: avoid try/catch overhead when single threaded.
    return expired() ? __shared_ptr&lt;element_type, _Lp&gt;()
                     : __shared_ptr&lt;element_type, _Lp&gt;(*this);
 
#endif
} // XXX MT
</code></pre>
<p>  当然shared_ptr也不是万能的，使用的时候也要注意到它给程序员挖的一个大坑：shared_ptr能够管理对象的生命周期，负责对象资源释放，其前提条件是所有shared_ptr共用同一个管理对象。如果多个shared_ptr使用多个管理对象来管理同一个被管理对象，这些管理对象在use_count为0时均会释放被管理对象，将会造成多个管理对象多次释放被管理对象，造成twice delete的堆错误。下面的例子在单独使用裸指针的时候没有问题，采用shared_ptr将会出现twice delete的问题：</p>
<pre><code>class Thing {
public:
	void foo();
	void defrangulate();
};
void transmogrify(Thing *);
int main()
{
	Thing * t1 = new Thing;
	t1-&gt;foo();
	...
	delete t1; // done with the object
}
...
void Thing::foo()
{
	// we need to transmogrify this object
	transmogrify(this);
}
void transmogrify(Thing * ptr)
{
	ptr-&gt;defrangulate();
	/* etc. */
}
//***** Use shared_ptr***************************//
class Thing {
public:
	void foo();
	void defrangulate();
};
void transmogrify(shared_ptr&lt;Thing&gt;);
int main()
{
	shared_ptr&lt;Thing&gt; t1(new Thing); // create manager object A for the Thing
	t1-&gt;foo();
	...
	// Thing is supposed to get deleted when t1 goes out of scope
}
void Thing::foo()
{
	// we need to transmogrify this object
	shared_ptr&lt;Thing&gt; sp_for_this(this); //  create manager object B for the Thing
	transmogrify(sp_for_this);
	
	// Thing is supposed to get deleted when sp_for_this and other shared_ptr goes out of scope
}
void transmogrify(shared_ptr&lt;Thing&gt; ptr)
{
	ptr-&gt;defrangulate();
	/* etc. */
}
</code></pre>
<p>  上面注释处分别创建了两个shared_ptr指针t1，sp_for_this, 它们各自有自己的管理对象，但被管理的堆内存却是一样的，这就导致在t1和sp_for_this析构时，它们各自的管理对象均会析构被管理对象，造成twice delete。</p>
<p>  怎样解决上面这一广泛存在问题：当一个对象M创建后，如果一个函数f（另一个类的成员函数或是其它自由函数）的形参为M类型的智能指针，如何在对象M内部将对象M的指针作为实参传递给该函数f ? C++引入了enable_shared_from_this利用weak_ptr的特性解决了这一问题。其基本思想是通过M继承模板类enable_shared_from_this，这样对象M内部将会有一个__weak_ptr指针_M_weak_this，在第一次创建指向M的shared_ptr Pt时，通过模板特化，将会初始化_M_weak_this;这样M内部也会产生一个指向自身的weak_ptr，并且该weak_ptr内部的管理对象与Pt的管理对象是相同的（这可以从weak_ptr内部的_M_assign函数看出）。</p>
<pre><code>// Friend of enable_shared_from_this.
template&lt;typename _Tp1, typename _Tp2&gt;
void __enable_shared_from_this_helper(const __shared_count&lt;&gt;&amp;, const enable_shared_from_this&lt;_Tp1&gt;*, const _Tp2*);
 
 
template&lt;typename _Tp1&gt;
explicit __shared_ptr(_Tp1* __p)
: _M_ptr(__p), _M_refcount(__p)
{
	__glibcxx_function_requires(_ConvertibleConcept&lt;_Tp1*, _Tp*&gt;) typedef int _IsComplete[sizeof(_Tp1)];
	__enable_shared_from_this_helper(_M_refcount, __p, __p);
 
} 
 
template&lt;typename _Tp&gt;
class enable_shared_from_this
{
protected:
	enable_shared_from_this() { }
      
    enable_shared_from_this(const enable_shared_from_this&amp;) { }
 
    enable_shared_from_this&amp;
    operator=(const enable_shared_from_this&amp;)
    { return *this; }
 
    ~enable_shared_from_this() { }
 
public:
    shared_ptr&lt;_Tp&gt;
    shared_from_this()
    { return shared_ptr&lt;_Tp&gt;(this-&gt;_M_weak_this); }
 
    shared_ptr&lt;const _Tp&gt;
    shared_from_this() const
    { return shared_ptr&lt;const _Tp&gt;(this-&gt;_M_weak_this); }
 
    private:
    template&lt;typename _Tp1&gt;
    void
    _M_weak_assign(_Tp1* __p, const __shared_count&lt;&gt;&amp; __n) const
    { _M_weak_this._M_assign(__p, __n); }
 
    template&lt;typename _Tp1&gt;
    friend void
    __enable_shared_from_this_helper(const __shared_count&lt;&gt;&amp; __pn, const enable_shared_from_this* __pe, const _Tp1* __px)
    {
	if (__pe != 0)
	 __pe-&gt;_M_weak_assign(const_cast&lt;_Tp1*&gt;(__px), __pn);
    }
    
    mutable weak_ptr&lt;_Tp&gt;  _M_weak_this;
};
 
_M_assign(_Tp* __ptr, const __shared_count&lt;_Lp&gt;&amp; __refcount)
{
    _M_ptr = __ptr;
   _M_refcount = __refcount;
}
</code></pre>
<p>  这样，在M内部，当需要传递指向M的智能指针时，可以通过继承而来的shared_from_this方法获取到指向M的智能指针而不会发生内存泄漏。上面示例中改写后的正确代码为：</p>
<pre><code>class Thing : public enable_shared_from_this&lt;Thing&gt; {
public:
	void foo();
	void defrangulate();
};
int main()
{
	// The following starts a manager object for the Thing and also
	// initializes the weak_ptr member that is now part of the Thing and share same manager object.
	shared_ptr&lt;Thing&gt; t1(new Thing);
	t1-&gt;foo();
	...
}
void Thing::foo()
{
	// get a shared_ptr from the weak_ptr in this object
	shared_ptr&lt;Thing&gt; sp_this = shared_from_this();
	transmogrify(sp_this);
}
void transmogrify(shared_ptr&lt;Thing&gt; ptr)
{
	ptr-&gt;defrangulate();
	/* etc. */
}
</code></pre>
<p>  解决了所有的坑，shared_ptr是不是就十全十美了呢？当然不是，shared_ptr也存在不足：在采用<code>shared_ptr&lt;M&gt; p(new M);</code>形式创建p来管理M时，我们实际发现这中间有两次的动态内存分配：一次为创建被管理对象M，一次为创建管理对象；而内存分配通常是比较昂贵的操作。</p>
<p>  如果频繁的需要创建指向多个不同对象的智能指针，可以采用<code>shared_ptr&lt;M&gt; p(make_shared&lt;M&gt;);</code>的方式，采用这种方式系统将会分配一大块内存同时存放管理对象和被管理对象，这就避免了上面所说的二次内存分配的问题，同时程序中也不会出现new操作符，符合&quot;no naked new!&quot;的编程倡导。当然这也有缺点，如果所有指向该对象的智能指针都销毁了，尽管对象的析构函数会被调用，析构被管理对象，但是如果还有weak_ptr指向该块对象所在的内存，存放管理对象的部分内存仍将不会被释放，因而导致在所有其他weak_ptr销毁前整块内存（尽管被管理对象已经析构了）将不会进入系统的内存池循环使用。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 93. 复原IP地址[中等]]]></title>
        <id>https://lixin-scut.github.io//post/zi-fu-chuan-93-fu-yuan-ip-di-zhi-zhong-deng</id>
        <link href="https://lixin-scut.github.io//post/zi-fu-chuan-93-fu-yuan-ip-di-zhi-zhong-deng">
        </link>
        <updated>2020-04-28T02:38:52.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。<br>
示例:<br>
输入: &quot;25525511135&quot;<br>
输出: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/restore-ip-addresses<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>第一想法是首先列出IP地址的限制</p>
<ol>
<li>长度不小于4，不超过12</li>
<li>每个位置可能的数字为0-255</li>
</ol>
<p>然后打算采用递归的方法<br>
然后分割为4部分， 然后不断地检测剩余的长度是否符合要求</p>
<p>然后发现一个0的问题。。。比如01和010这种<br>
必须判断合理性</p>
<pre><code>class Solution {
public:
    vector&lt;string&gt; restoreIpAddresses(string s) 
    {
        vector&lt;string&gt; res;
        restoreIpAddresses(s,&quot;&quot;, 0, 0, res);
        return res;
    }
    
    void restoreIpAddresses(string s,string ip, int beg, int level, vector&lt;string&gt;&amp; res)
    {
        if(level == 4 )
        {   
            if(beg == s.size())
            {   res.push_back(ip.substr(1)); }
            return;
        }
        if(s.size() - beg &lt; (4 - level)
           || s.size() - beg &gt; (4 - level)*3)
        {
            return;
        }
        
        
        string temp = &quot;&quot;;
        
        temp = ip + &quot;.&quot; + s.substr(beg, 1);
        restoreIpAddresses(s, temp, beg+1, level+1, res);
        if(s.size() - beg &gt; 1 &amp;&amp; stoi(s.substr(beg,2)) &gt; 9)
        {
            temp = ip + &quot;.&quot; + s.substr(beg, 2);
            restoreIpAddresses(s, temp, beg+2, level+1, res);
        }
        
        if(s.size() - beg &gt; 2 &amp;&amp; stoi(s.substr(beg,3)) &lt; 256 &amp;&amp; stoi(s.substr(beg,3)) &gt; 99)
        {
            temp = ip + &quot;.&quot; + s.substr(beg, 3);
            restoreIpAddresses(s, temp, beg+3, level+1, res);
        }        
    }
};
</code></pre>
<p>比较好的网友题解：</p>
<pre><code>class Solution {
public:
    vector&lt;string&gt; restoreIpAddresses(string s) {
        vector&lt;string&gt; res;
       // string out = &quot;&quot;;
        helper(res,s,&quot;&quot;,4);
        return res;
    }
    
    void helper(vector&lt;string&gt;&amp; res,string s,string out,int k)
    {
        if(k==0)
        {
            if(s.empty())     //注意点一，原字符串s应该要为空了
                res.push_back(out);
        }
        else
        {
            for(int i = 1;i&lt;=3;i++)
            {
                //截取某部分进行判断，如果合法则进入下一个递归
                if(s.size()&gt;=i&amp;&amp;isValid(s.substr(0,i)))  //注意点二，越界判断
                {
                    if(k==1)  //k==1代表当前ip再添加多一个结点就够四个了
                        helper(res,s.substr(i),out+s.substr(0,i),k-1);
                    else
                        helper(res,s.substr(i),out+s.substr(0,i)+'.',k-1);
                }
            }
        }
    }
    
    //判断是否合法
    bool isValid(string s)
    {
        if(s.empty()||s.size()&gt;3||(s.size()&gt;1&amp;&amp;s[0]=='0'))
            return false;
        int num = atoi(s.c_str());
        return num&gt;=0&amp;&amp;num&lt;=255;
    }
};
</code></pre>
<p>网友题解整洁很多，值得学习</p>
<blockquote>
<p>官方题解：<br>
直觉<br>
最朴素的解法是暴力法,<br>
换而言之，检查点可能的所有位置，并只保留有效的部分。在最坏的情况下，有11个可能的位置，因此需要11×10×9=990 次检查。<br>
可以通过以下两个概念来优化。<br>
第一个概念是 约束规划。<br>
这意味着对每个点的放置设置一些限制。若已经放置了一个点，下一个点只有 3 种可能：1/2/3个数字之后。<br>
这样做传播了_约束_ ，且减少了需要考虑的情况。我们只需要检测 3×3×3=27种情况，而非990 种。<br>
第二个概念是 回溯。<br>
我们假设已经放置了一或两个点使得无法摆放其他点来生成有效IP地址。这时应该做什么？ 回溯。T也就是说，回到之前，改变上一个摆放点的位置。并试着继续。如果依然不行，则继续 回溯。<br>
方法： 回溯(DFS)<br>
这是一个回溯函数backtrack(prev_pos = -1, dots = 3) 的算法，该函数使用上一个放置的点 prev_pos<br>
和待放置点的数量 dots 两个参数 :<br>
遍历三个有效位置curr_pos 以放置点。<br>
 检查从上一个点到现在点中间的部分是否有效 :<br>
  是 :<br>
   放置该点。<br>
   检查全部 3个点是否放好:<br>
    是 :<br>
     将结果添加到输出列表中。<br>
    否 :<br>
     继续放下一个点 backtrack(curr_pos, dots - 1)。<br>
   回溯，移除最后一个点。</p>
</blockquote>
<pre><code>class Solution {
  int n;
  String s;
  LinkedList&lt;String&gt; segments = new LinkedList&lt;String&gt;();
  ArrayList&lt;String&gt; output = new ArrayList&lt;String&gt;();

  public boolean valid(String segment) {
    /*
    Check if the current segment is valid :
    1. less or equal to 255      
    2. the first character could be '0' 
    only if the segment is equal to '0'
    */
    int m = segment.length();
    if (m &gt; 3)
      return false;
    return (segment.charAt(0) != '0') ? (Integer.valueOf(segment) &lt;= 255) : (m == 1);
  }

  public void update_output(int curr_pos) {
    /*
    Append the current list of segments 
    to the list of solutions
    */
    String segment = s.substring(curr_pos + 1, n);
    if (valid(segment)) {
      segments.add(segment);
      output.add(String.join(&quot;.&quot;, segments));
      segments.removeLast();
    }
  }

  public void backtrack(int prev_pos, int dots) {
    /*
    prev_pos : the position of the previously placed dot
    dots : number of dots to place
    */
    // The current dot curr_pos could be placed 
    // in a range from prev_pos + 1 to prev_pos + 4.
    // The dot couldn't be placed 
    // after the last character in the string.
    int max_pos = Math.min(n - 1, prev_pos + 4);
    for (int curr_pos = prev_pos + 1; curr_pos &lt; max_pos; curr_pos++) {
      String segment = s.substring(prev_pos + 1, curr_pos + 1);
      if (valid(segment)) {
        segments.add(segment);  // place dot
        if (dots - 1 == 0)      // if all 3 dots are placed
          update_output(curr_pos);  // add the solution to output
        else
          backtrack(curr_pos, dots - 1);  // continue to place dots
        segments.removeLast();  // remove the last placed dot 
      }
    }
  }

  public List&lt;String&gt; restoreIpAddresses(String s) {
    n = s.length();
    this.s = s;
    backtrack(-1, 3);
    return output;
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 : 如上文所述，需要检查的组合不多于27个。<br>
空间复杂度 : 常数空间存储解，不多于19 个有效IP地址。</p>
</blockquote>
<p>hhh这个时间复杂度和空间复杂度非常有趣</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 567. 字符串的排列[中等]]]></title>
        <id>https://lixin-scut.github.io//post/zi-fu-chuan-567-zi-fu-chuan-de-pai-lie-zhong-deng</id>
        <link href="https://lixin-scut.github.io//post/zi-fu-chuan-567-zi-fu-chuan-de-pai-lie-zhong-deng">
        </link>
        <updated>2020-04-28T01:18:40.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。<br>
换句话说，第一个字符串的排列之一是第二个字符串的子串。<br>
示例1:<br>
输入: s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;<br>
输出: True<br>
解释: s2 包含 s1 的排列之一 (&quot;ba&quot;).<br>
 示例2:<br>
输入: s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;<br>
输出: False<br>
 注意：<br>
输入的字符串只包含小写字母<br>
两个字符串的长度都在 [1, 10,000] 之间<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/permutation-in-string<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>第一想法的话是保存s1的字符数量，然后在s2中探测是否有符合数量的字符串,但是发现行不通，错误例子&quot;adc&quot;-&quot;dcda&quot;<br>
然后想到滑动窗口+固定数组，亦即使用26个元素的数组，然后模仿滑动窗口，在递增某个字符的同时递减某个字符，然后比较两个数组是否相等。</p>
<p>最后官方题解的优化很值得学习，记录match的数量，当match的数量达到26的时候就说明匹配成功了</p>
<pre><code>class Solution {
public:
    bool checkInclusion(string s1, string s2) {    
        if(s2.size() &lt; s1.size())
        {   return false; }
        
        vector&lt;int&gt; letters(26, 0);
        
        for(char c : s1)
        {
            ++letters[c - 'a'];
        }
        
        vector&lt;int&gt; letters_temp(26, 0);
        for(int i = 0; i &lt; s2.size(); ++i)
        {
            if(i &lt; s1.size())
            {
                ++letters_temp[s2[i] - 'a'];
            }
            else
            {
                --letters_temp[s2[i-s1.size()] - 'a'];
                ++letters_temp[s2[i] - 'a'];
            }
            if(i &gt;= s1.size() - 1)
            {
                if(letters_temp == letters)
                {   
                    return true;
                }
            }
        }
        return false;
    }
};
</code></pre>
<blockquote>
<p>方法一 暴力 [超过时间限制]<br>
算法<br>
最简单的方法是生成短字符串的所有排列，并检查生成的排列是否是较长字符串的子字符串。<br>
为了生成所有可能的配对，我们使用函数permute（string_1，string_2，current_index）。此函数创建短字符串 s1 的所有可能排列。<br>
为此，permute将当前元素 currentindex 的索引作为参数之一。然后，它将当前元素与数组中的每个其他元素交换，向右移动，以便生成数组元素的新排序。完成交换后，它会再次调用置换，但这次使用数组中下一个元素的索引。返回时，我们反转当前函数调用中的交换。<br>
因此，当我们到达数组的末尾时，会生成数组元素的新排序。以下动画描述了生成排列的过程。</p>
</blockquote>
<pre><code>public class Solution {
    boolean flag = false;
    public boolean checkInclusion(String s1, String s2) {
        permute(s1, s2, 0);
        return flag;
    }
    public String swap(String s, int i0, int i1) {
        if (i0 == i1)
            return s;
        String s1 = s.substring(0, i0);
        String s2 = s.substring(i0 + 1, i1);
        String s3 = s.substring(i1 + 1);
        return s1 + s.charAt(i1) + s2 + s.charAt(i0) + s3;
    }
    void permute(String s1, String s2, int l) {
        if (l == s1.length()) {
            if (s2.indexOf(s1) &gt;= 0)
                flag = true;
        } else {
            for (int i = l; i &lt; s1.length(); i++) {
                s1 = swap(s1, l, i);
                permute(s1, s2, l + 1);
                s1 = swap(s1, l, i);
            }
        }
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n!)。我们将 s1 的短字符串 s1 的所有排列与 s2 匹配。这里，n 指的是 s1 的长度。<br>
空间复杂度：O(n^2)。递归树的深度是 n（n 是指短字符串 s1 的长度）。递归树的每个节点都包含一个 max 的字符串。长度 n。</p>
</blockquote>
<blockquote>
<p>方法二 排序 [超过时间限制]:<br>
算法<br>
这种方法背后的想法是，只有当两个字符串包含相同次数的相同字符时，一个字符串才是另一个字符串的排列。只有sorted(x)=sorted(y)时，一个字符串x才是其他字符串 y 的排列。<br>
为了检查这一点，我们可以对两个字符串进行排序并进行比较。我们对短字符串 s1 和 s2 的所有子字符串进行排序，对它们进行排序并将它们与排序的 s1 字符串进行比较。如果两者完全匹配，s1 的排列是 s2 的子字符串，否则不是。</p>
</blockquote>
<pre><code>public class Solution {

    public boolean checkInclusion(String s1, String s2) {
        s1 = sort(s1);
        for (int i = 0; i &lt;= s2.length() - s1.length(); i++) {
            if (s1.equals(sort(s2.substring(i, i + s1.length()))))
                return true;
        }
        return false;
    }
    public String sort(String s) {
        char[] t = s.toCharArray();
        Arrays.sort(t);
        return new String(t);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(l1log(l1)+(l2−l1)l1log(l1))。其中 l1是字符串 l1 的长度，l2是字符串 l2的长度。<br>
空间复杂度：O(l1)。使用了 t 数组。</p>
</blockquote>
<blockquote>
<p>方法三 使用哈希表 [超过时间限制]<br>
算法<br>
如上所述，只有当两个字符串包含具有相同频率的相同字符时，一个字符串才是另一个字符串的排列。我们可以考虑与 s1 长度相同的长字符串 s2 中的每个可能的子字符串，并检查出现在两者中的字符出现的频率。如果每个字母的频率完全匹配，则只有 s1 的排列可以是 s2 的子字符串。<br>
为了实现这种方法，我们不使用排序然后比较元素的相等性，而是使用一个哈希表 s1map来存储短字符串 s1 中所有字符的出现频率。我们考虑 s2 的每个可能的子串，其长度与 s1 的长度相同，也可以找到相应的哈希表，即 s2map。因此，所考虑的子字符串可以被视为一个长度窗口，如 s1 迭代超过 s2。如果获得的两个哈希表对于任何这样的窗口是相同的，我们可以得出结论 s1 的排列是 s2 的子字符串，否则不是。<br>
复杂度分析<br>
时间复杂度：O(l+26∗l1∗(l2−l1))。这个哈希表包含最多26个键。其中l1是字符串 l1的长度，l2是字符串 l2的长度。<br>
空间复杂度：O(1)。表包含最多 26 个键值对。</p>
</blockquote>
<blockquote>
<p>方法四 使用数组 [通过]<br>
算法<br>
我们可以使用更简单的数组数据结构来存储频率，而不是仅使用特殊的哈希表数据结构来存储字符出现的频率。给定字符串仅包含小写字母（'a'到'z'）。因此我们需要采用大小为 26 的数组。其余过程与最后一种方法保持一致。</p>
</blockquote>
<pre><code>public class Solution {
    public boolean checkInclusion(String s1, String s2) {
        if (s1.length() &gt; s2.length())
            return false;
        int[] s1map = new int[26];
        for (int i = 0; i &lt; s1.length(); i++)
            s1map[s1.charAt(i) - 'a']++;
        for (int i = 0; i &lt;= s2.length() - s1.length(); i++) {
            int[] s2map = new int[26];
            for (int j = 0; j &lt; s1.length(); j++) {
                s2map[s2.charAt(i + j) - 'a']++;
            }
            if (matches(s1map, s2map))
                return true;
        }
        return false;
    }
    public boolean matches(int[] s1map, int[] s2map) {
        for (int i = 0; i &lt; 26; i++) {
            if (s1map[i] != s2map[i])
                return false;
        }
        return true;
    }
}
</code></pre>
<blockquote>
<p>时间复杂度：O(l+26∗l1∗(l2−l1))。这个哈希表包含最多26个键。其中l1是字符串 l1的长度，l2是字符串 l2的长度。<br>
空间复杂度：O(1)。使用 s1map 和 s2map，大小为 26。</p>
</blockquote>
<blockquote>
<p>方法五 滑动窗口 [通过]:<br>
算法<br>
我们可以为 s2 中的第一个窗口创建一次哈希表，而不是为 s2 中考虑的每个窗口重新生成哈希表。然后，稍后当我们滑动窗口时，我们知道我们添加了一个前面的字符并将新的后续字符添加到所考虑的新窗口中。因此，我们可以通过仅更新与这两个字符相关联的索引来更新哈希表。同样，对于每个更新的哈希表，我们将哈希表的所有元素进行比较以获得所需的结果。</p>
</blockquote>
<pre><code>public class Solution {
    public boolean checkInclusion(String s1, String s2) {
        if (s1.length() &gt; s2.length())
            return false;
        int[] s1map = new int[26];
        int[] s2map = new int[26];
        for (int i = 0; i &lt; s1.length(); i++) {
            s1map[s1.charAt(i) - 'a']++;
            s2map[s2.charAt(i) - 'a']++;
        }
        for (int i = 0; i &lt; s2.length() - s1.length(); i++) {
            if (matches(s1map, s2map))
                return true;
            s2map[s2.charAt(i + s1.length()) - 'a']++;
            s2map[s2.charAt(i) - 'a']--;
        }
        return matches(s1map, s2map);
    }
    public boolean matches(int[] s1map, int[] s2map) {
        for (int i = 0; i &lt; 26; i++) {
            if (s1map[i] != s2map[i])
                return false;
        }
        return true;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(l+26∗l1∗(l2−l1))。这个哈希表包含最多26个键。其中l1是字符串 l1的长度，l2是字符串 l2的长度。<br>
空间复杂度：O(1)</p>
</blockquote>
<blockquote>
<p>方法六 优化的滑动窗口 [通过]:<br>
算法<br>
上一种方法可以优化，如果不是比较每个更新的 s2map 的哈希表的所有元素，而是对应于 s2 考虑的每个窗口，我们会跟踪先前哈希表中已经匹配的元素数量当我们向右移动窗口时，只更新匹配元素的数量。<br>
为此，我们维护一个 count 变量，该变量存储字符数（26个字母表中的数字），这些字符在 s1 中具有相同的出现频率，当前窗口在 s2 中。当我们滑动窗口时，如果扣除最后一个元素并添加新元素导致任何字符的新频率匹配，我们将 count 递增1.如果不是，我们保持 count 完整。但是，如果添加频率相同的字符（添加和删除之前）相同的字符，现在会导致频率不匹配，这会通过递减相同的 count 变量来考虑。如果在移动窗口后，count 的计算结果为26，则表示所有字符的频率完全匹配。所以，我们立即返回一个True。</p>
</blockquote>
<pre><code>public class Solution {
    public boolean checkInclusion(String s1, String s2) {
        if (s1.length() &gt; s2.length())
            return false;
        int[] s1map = new int[26];
        int[] s2map = new int[26];
        for (int i = 0; i &lt; s1.length(); i++) {
            s1map[s1.charAt(i) - 'a']++;
            s2map[s2.charAt(i) - 'a']++;
        }
        int count = 0;
        for (int i = 0; i &lt; 26; i++)
            if (s1map[i] == s2map[i])
                count++;
        for (int i = 0; i &lt; s2.length() - s1.length(); i++) {
            int r = s2.charAt(i + s1.length()) - 'a', l = s2.charAt(i) - 'a';
            if (count == 26)
                return true;
            s2map[r]++;
            if (s2map[r] == s1map[r])
                count++;
            else if (s2map[r] == s1map[r] + 1)
                count--;
            s2map[l]--;
            if (s2map[l] == s1map[l])
                count++;
            else if (s2map[l] == s1map[l] - 1)
                count--;
        }
        return count == 26;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(l1+(l2−l1))O(l1 +(l2−l1))。其中 l1是字符串 l1的长度，l2是字符串 l2 的长度。<br>
空间复杂度：O(1)。常数级的空间。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[6. 其他 C++ 特性 -Google C++编程规范]]></title>
        <id>https://lixin-scut.github.io//post/6-qi-ta-c-te-xing-google-cbian-cheng-gui-fan</id>
        <link href="https://lixin-scut.github.io//post/6-qi-ta-c-te-xing-google-cbian-cheng-gui-fan">
        </link>
        <updated>2020-04-27T12:49:32.000Z</updated>
        <content type="html"><![CDATA[<h3 id="61-引用参数">6.1. 引用参数</h3>
<p><strong>所有按引用传递的参数必须加上 const.</strong></p>
<p><strong>定义:</strong></p>
<p>  在 C 语言中, 如果函数需要修改变量的值, 参数必须为指针, 如<code>int foo(int *pval)</code>. 在 C++ 中, 函数还可以声明引用参数: <code>int foo(int &amp;val)</code>.</p>
<p><strong>优点:</strong></p>
<p>  定义引用参数防止出现<code>(*pval)++</code>这样丑陋的代码. 像拷贝构造函数这样的应用也是必需的. <strong>而且更明确, 不接受 NULL 指针.</strong></p>
<p><strong>缺点:</strong></p>
<p>  容易引起误解, 因为引用在语法上是值变量却拥有指针的语义.</p>
<p><strong>结论:</strong></p>
<p>  函数参数列表中, 所有引用参数都必须是 const:</p>
<pre><code>void Foo(const string &amp;in, string *out);
</code></pre>
<p>  事实上这在 Google Code 是一个硬性约定: 输入参数是值参或 const 引用, 输出参数为指针. 输入参数可以是 const 指针, 但决不能是非 const 的引用参数，<strong>除非用于交换，比如 swap().</strong></p>
<p>有时候，<em><em>在输入形参中用 const T</em> 指针比 const T&amp; 更明智</em>*。比如：</p>
<ol>
<li>您会传 <strong>null 指针</strong>。</li>
<li>函数要把<strong>指针</strong>或<strong>对地址的引用</strong>赋值给输入形参。<br>
  总之大多时候输入形参往往是 const T&amp;. 若用 const T* 说明输入另有处理。所以若您要用 const T*, 则应有理有据，否则会害得读者误解。</li>
</ol>
<h3 id="62-右值引用">6.2. 右值引用</h3>
<p><strong>只在定义移动构造函数与移动赋值操作时使用右值引用. 不要使用 std::forward.</strong></p>
<p><strong>定义:</strong></p>
<p>  右值引用是一种只能绑定到临时对象的引用的一种, 其语法与传统的引用语法相似. 例如, void f(string&amp;&amp; s); 声明了一个其参数是一个字符串的右值引用的函数.<br>
优点:</p>
<p>  用于定义移动构造函数 (使用类的右值引用进行构造的函数) 使得移动一个值而非拷贝之成为可能. 例如, 如果 v1 是一个<code>vector&lt;string&gt;</code>, 则 <code>auto v2(std::move(v1))</code>将很可能不<strong>再进行大量的数据复制而只是简单地进行指针操作</strong>, 在某些情况下这将带来大幅度的性能提升.</p>
<p>  右值引用使得编写通用的函数封装来转发其参数到另外一个函数成为可能, 无论其参数是否是临时对象都能正常工作.</p>
<p>  右值引用能实现可移动但不可拷贝的类型, 这一特性对那些在拷贝方面没有实际需求, 但有时又需要将它们作为函数参数传递或塞入容器的类型很有用.</p>
<p>  <strong>要高效率地使用某些标准库类型, 例如 std::unique_ptr, std::move 是必需的.</strong></p>
<p><strong>缺点:</strong></p>
<p>  右值引用是一个相对比较新的特性 (由 C++11 引入), 它尚未被广泛理解. 类似引用崩溃, 移动构造函数的自动推导这样的规则都是很复杂的.</p>
<p><strong>结论:</strong></p>
<p>  <strong>只在定义移动构造函数与移动赋值操作时使用右值引用, 不要使用 std::forward 功能函数. 你可能会使用 std::move 来表示将值从一个对象移动而不是复制到另一个对象.</strong></p>
<h3 id="63-函数重载">6.3. 函数重载</h3>
<p>若要用好函数重载，最好能让读者一看调用点（call site）就胸有成竹，不用花心思猜测调用的重载函数到底是哪一种。该规则适用于构造函数。</p>
<p><strong>定义:</strong></p>
<p>  你可以编写一个参数类型为 const string&amp; 的函数, 然后用另一个参数类型为 const char* 的函数重载它:</p>
<pre><code>class MyClass {
    public:
    void Analyze(const string &amp;text);
    void Analyze(const char *text, size_t textlen);
};
</code></pre>
<p><strong>优点:</strong></p>
<p>  通过重载参数不同的同名函数, 令代码更加直观. 模板化代码需要重载, 同时为使用者带来便利.</p>
<p><strong>缺点:</strong></p>
<p>  <strong>如果函数单单靠不同的参数类型而重载</strong>（acgtyrant 注：这意味着参数数量不变），读者就得<strong>十分熟悉 C++ 五花八门的匹配规则，以了解匹配过程具体到底如何</strong>。另外，<strong>当派生类只重载了某个函数的部分变体，继承语义容易令人困惑</strong>。</p>
<p><strong>结论:</strong></p>
<p>  如果您打算重载一个函数, <strong>可以试试改在函数名里加上参数信息</strong>。例如，用 AppendString() 和 AppendInt() 等， 而不是一口气重载多个 Append().</p>
<h3 id="64-缺省参数">6.4. 缺省参数</h3>
<p>我们<strong>不允许使用缺省函数参数，少数极端情况除外。尽可能改用函数重载。</strong></p>
<p><strong>优点:</strong></p>
<p>  当您有依赖缺省参数的函数时，您也许偶尔会修改修改这些缺省参数。通过缺省参数，不用再为个别情况而特意定义一大堆函数了。与函数重载相比，缺省参数语法更为清晰，代码少，也很好地区分了「必选参数」和「可选参数」。</p>
<p><strong>缺点:</strong></p>
<p>  <strong>缺省参数会干扰函数指针，害得后者的函数签名（function signature）往往对不上所实际要调用的函数签名</strong>。即在一个现有函数添加缺省参数，就会改变它的类型，那么调用其地址的代码可能会出错，不过函数重载就没这问题了。此外，<strong>缺省参数会造成臃肿的代码，毕竟它们在每一个调用点（call site）都有重复</strong>（译者 注：我猜可能是因为调用函数的代码表面上看来省去了不少参数，但编译器在编译时还是会在每一个调用代码里统统补上所有默认实参信息，造成大量的重复）。函数重载正好相反，毕竟它们所谓的「缺省参数」只会出现在函数定义里。</p>
<p><strong>结论:</strong></p>
<p>  由于缺点并不是很严重，有些人依旧偏爱缺省参数胜于函数重载。<strong>所以除了以下情况，我们要求必须显式提供所有参数</strong>（acgtyrant 注：即不能再通过缺省参数来省略参数了）。</p>
<p>其一，位于 .cc 文件里的<strong>静态函数</strong>或<strong>匿名空间函数</strong>，毕竟<strong>都只能在局部文件里调用该函数了</strong>。</p>
<p>其二，可以在<strong>构造函数里用缺省参数</strong>，毕竟<strong>不可能取得它们的地址</strong>。</p>
<p>其三，<strong>可以用来模拟变长数组。</strong></p>
<pre><code>// 通过空 AlphaNum 以支持四个形参
string StrCat(const AlphaNum &amp;a,
              const AlphaNum &amp;b = gEmptyAlphaNum,
              const AlphaNum &amp;c = gEmptyAlphaNum,
              const AlphaNum &amp;d = gEmptyAlphaNum);
</code></pre>
<h3 id="65-变长数组和-alloca">6.5. 变长数组和 alloca()</h3>
<p>我们不允许使用变长数组和 alloca().</p>
<p><strong>优点:</strong></p>
<p>  变长数组具有浑然天成的语法. 变长数组和 alloca() 也都很高效.</p>
<p><strong>缺点:</strong></p>
<p>  <strong>变长数组和 alloca() 不是标准 C++ 的组成部分</strong>. 更重要的是, <strong>它们根据数据大小动态分配堆栈内存, 会引起难以发现的内存越界 bugs: “在我的机器上运行的好好的, 发布后却莫名其妙的挂掉了”.</strong></p>
<p><strong>结论:</strong></p>
<p>  <strong>改用更安全的分配器（allocator），就像 <code>std::vector</code> 或 <code>std::unique_ptr&lt;T[]&gt;</code>.</strong></p>
<h3 id="66-友元">6.6. 友元</h3>
<p>我们允许合理的使用友元类及友元函数.</p>
<p>  通常<strong>友元应该定义在同一文件内, 避免代码读者跑到其它文件查找使用该私有成员的类.</strong> 经常用到友元的一个地方是将 FooBuilder 声明为 Foo 的友元, 以便 FooBuilder 正确构造 Foo 的内部状态, 而无需将该状态暴露出来. 某些情况下, <strong>将一个单元测试类声明成待测类的友元会很方便.</strong></p>
<p>  友元扩大了 (但没有打破) 类的封装边界. <strong>某些情况下, 相对于将类成员声明为 public, 使用友元是更好的选择, 尤其是如果你只允许另一个类访问该类的私有成员时. 当然, 大多数类都只应该通过其提供的公有成员进行互操作.</strong></p>
<h3 id="67-异常">6.7. 异常</h3>
<p><strong>我们不使用 C++ 异常.</strong></p>
<p><strong>优点:</strong></p>
<ol>
<li>异常允许应用高层决定如何处理在底层嵌套函数中「不可能发生」的失败（failures），不用管那些含糊且容易出错的错误代码（acgtyrant 注：error code, 我猜是Ｃ语言函数返回的非零 int 值）。</li>
<li>很多现代语言都用异常。引入异常使得 C++ 与 Python, Java 以及其它类 C++ 的语言更一脉相承。</li>
<li>有些第三方 C++ 库依赖异常，禁用异常就不好用了。</li>
<li><strong>异常是处理构造函数失败的唯一途径</strong>。虽然可以用工厂函数（acgtyrant 注：factory function, 出自 C++ 的一种设计模式，即「简单工厂模式」）或 Init() 方法代替异常, 但是前者要求在堆栈分配内存，后者会导致刚创建的实例处于 ”无效“ 状态。</li>
<li>在测试框架里很好用。</li>
</ol>
<p><strong>缺点:</strong></p>
<ol>
<li><strong>在现有函数中添加 throw 语句时，您必须检查所有调用点</strong>。要么让所有调用点统统具备最低限度的异常安全保证，要么眼睁睁地看异常一路欢快地往上跑，最终中断掉整个程序。<strong>举例，f() 调用 g(), g() 又调用 h(), 且 h 抛出的异常被 f 捕获。当心 g, 否则会没妥善清理好</strong>。</li>
<li>还有更常见的，<strong>异常会彻底扰乱程序的执行流程并难以判断，函数也许会在您意料不到的地方返回</strong>。您或许会加一大堆何时何处处理异常的规定来降低风险，然而开发者的记忆负担更重了。</li>
<li>异常安全需要RAII和不同的编码实践. 要轻松编写出正确的异常安全代码需要大量的支持机制. 更进一步地说, 为了避免读者理解整个调用表, <strong>异常安全必须隔绝从持续状态写到 “提交” 状态的逻辑</strong>. 这一点有利有弊 (因为你也许不得不为了隔离提交而混淆代码). 如果允许使用异常, 我们就不得不时刻关注这样的弊端, 即使有时它们并不值得.</li>
<li><strong>启用异常会增加二进制文件数据，延长编译时间（或许影响小），还可能加大地址空间的压力</strong>。</li>
<li><strong>滥用异常会变相鼓励开发者去捕捉不合时宜，或本来就已经没法恢复的「伪异常」</strong>。比如，用户的输入不符合格式要求时，也用不着抛异常。如此之类的伪异常列都列不完。</li>
</ol>
<p><strong>结论:</strong></p>
<p>  从表面上看来，使用异常利大于弊, 尤其是在新项目中. 但是对于现有代码, 引入异常会牵连到所有相关代码. 如果新项目允许异常向外扩散, 在跟以前未使用异常的代码整合时也将是个麻烦. 因为 Google 现有的大多数 C++ 代码都没有异常处理, 引入带有异常处理的新代码相当困难.</p>
<p>  鉴于 Google 现有代码不接受异常, 在现有代码中使用异常比在新项目中使用的代价多少要大一些. 迁移过程比较慢, 也容易出错. 我们不相信异常的使用有效替代方案, 如错误代码, 断言等会造成严重负担.</p>
<p>  我们并不是基于哲学或道德层面反对使用异常, 而是在实践的基础上. 我们希望在 Google 使用我们自己的开源项目, 但项目中使用异常会为此带来不便, 因此我们也建议不要在 Google 的开源项目中使用异常. 如果我们需要把这些项目推倒重来显然不太现实.</p>
<p>对于 Windows 代码来说, 有个 特例.</p>
<p>  (译者注: 对于异常处理, 显然不是短短几句话能够说清楚的, 以构造函数为例, 很多 C++ 书籍上都提到当构造失败时只有异常可以处理, <strong>Google 禁止使用异常这一点, 仅仅是为了自身的方便, 说大了, 无非是基于软件管理成本上, 实际使用中还是自己决定)</strong></p>
<h3 id="68-运行时类型识别">6.8. 运行时类型识别</h3>
<p><strong>我们禁止使用 RTTI.</strong></p>
<p><strong>定义:</strong></p>
<p>  <strong>RTTI 允许程序员在运行时识别 C++ 类对象的类型. 它通过使用 typeid 或者 dynamic_cast 完成.</strong></p>
<p><strong>优点:</strong></p>
<p>  RTTI 的标准替代 (下面将描述) 需要对有问题的类层级进行修改或重构. 有时这样的修改并不是我们所想要的, 甚至是不可取的, 尤其是在一个已经广泛使用的或者成熟的代码中.</p>
<p>  <strong>RTTI 在某些单元测试中非常有用</strong>. 比如进行工厂类测试时, <strong>用来验证一个新建对象是否为期望的动态类型. RTTI 对于管理对象和派生对象的关系也很有用</strong>.</p>
<p>在考虑多个抽象对象时 RTTI 也很好用. 例如:</p>
<pre><code>bool Base::Equal(Base* other) = 0;
bool Derived::Equal(Base* other) {
  Derived* that = dynamic_cast&lt;Derived*&gt;(other);
  if (that == NULL)
    return false;
  ...
}
</code></pre>
<p><strong>缺点:</strong></p>
<p>  <strong>在运行时判断类型通常意味着设计问题. 如果你需要在运行期间确定一个对象的类型, 这通常说明你需要考虑重新设计你的类.</strong></p>
<p>  随意地使用 RTTI 会使你的代码难以维护. 它使得基于类型的判断树或者 switch 语句散布在代码各处. 如果以后要进行修改, 你就必须检查它们.</p>
<p><strong>结论:</strong></p>
<p>  RTTI 有合理的用途但是容易被滥用, 因此在使用时请务必注意. <strong>在单元测试中可以使用 RTTI, 但是在其他代码中请尽量避免</strong>. 尤其是在新代码中, 使用 RTTI 前务必三思. 如果你的代码需要根据不同的对象类型执行不同的行为的话, <strong>请考虑用以下的两种替代方案之一查询类型:</strong></p>
<p>  <strong>虚函数可以根据子类类型的不同而执行不同代码</strong>. 这是把工作交给了对象本身去处理.</p>
<p>  如果这一<strong>工作需要在对象之外完成, 可以考虑使用双重分发的方案, 例如使用访问者设计模式. 这就能够在对象之外进行类型判断</strong>.</p>
<p>  <strong>如果程序能够保证给定的基类实例实际上都是某个派生类的实例, 那么就可以自由使用 dynamic_cast. 在这种情况下, 使用 dynamic_cast 也是一种替代方案.</strong></p>
<p><strong>基于类型的判断树是一个很强的暗示, 它说明你的代码已经偏离正轨了. 不要像下面这样:</strong></p>
<pre><code>if (typeid(*data) == typeid(D1)) {
  ...
} else if (typeid(*data) == typeid(D2)) {
  ...
} else if (typeid(*data) == typeid(D3)) {
...
</code></pre>
<p>  一旦在类层级中加入新的子类, 像这样的代码往往会崩溃. 而且, 一旦某个子类的属性改变了, 你很难找到并修改所有受影响的代码块.</p>
<p>  不要去手工实现一个类似 RTTI 的方案. 反对 RTTI 的理由同样适用于这些方案, 比如带类型标签的类继承体系. 而且, 这些方案会掩盖你的真实意图.</p>
<h3 id="69-类型转换">6.9. 类型转换</h3>
<p><strong>使用 C++ 的类型转换, 如 static_cast&lt;&gt;(). 不要使用 int y = (int)x 或 int y = int(x) 等转换方式;</strong></p>
<p><strong>定义:</strong></p>
<p>  C++ 采用了有别于 C 的类型转换机制, 对转换操作进行归类.</p>
<p><strong>优点:</strong></p>
<p>  C 语言的类型转换问题在于模棱两可的操作; 有时是在做强制转换 (如 (int)3.5), 有时是在做类型转换 (如 (int)&quot;hello&quot;). 另外, C++ 的类型转换在查找时更醒目.</p>
<p><strong>缺点:</strong></p>
<p>  恶心的语法.</p>
<p><strong>结论:</strong></p>
<p>不要使用 C 风格类型转换. 而应该使用 C++ 风格.</p>
<ol>
<li>用 static_cast 替代 C 风格的<strong>值转换</strong>, 或某个<strong>类指针需要明确的向上转换为父类指针时.</strong></li>
<li><strong>用 const_cast 去掉 const 限定符</strong>.</li>
<li><strong>用 reinterpret_cast 指针类型和整型或其它指针之间进行不安全的相互转换</strong>. 仅在你对所做一切了然于心时使用.</li>
</ol>
<p>至于 dynamic_cast 参见 6.8. 运行时类型识别.</p>
<h3 id="610-流">6.10. 流</h3>
<p>  <strong>只在记录日志时使用流.</strong></p>
<p><strong>定义:</strong></p>
<p>  流用来替代 printf() 和 scanf().</p>
<p><strong>优点:</strong></p>
<p>  <strong>有了流, 在打印时不需要关心对象的类型. 不用担心格式化字符串与参数列表不匹配</strong> (虽然在 gcc 中使用 printf 也不存在这个问题). <strong>流的构造和析构函数会自动打开和关闭对应的文件.</strong></p>
<p><strong>缺点:</strong></p>
<p>  <strong>流使得 pread() 等功能函数很难执行</strong>. 如果不使用 printf 风格的格式化字符串, <strong>某些格式化操作 (尤其是常用的格式字符串 <code>%.*s</code>) 用流处理性能是很低的</strong>. 流不支持字符串操作符重新排序 (%1s), 而这一点对于软件国际化很有用.</p>
<p><strong>结论:</strong></p>
<p>  <strong>不要使用流, 除非是日志接口需要. 使用 printf 之类的代替.</strong></p>
<p>  使用流还有很多利弊, 但代码一致性胜过一切. <strong>不要在代码中使用流</strong>.</p>
<p><strong>拓展讨论:</strong></p>
<p>  对这一条规则存在一些争论, 这儿给出点深层次原因. 回想一下<strong>唯一性原则 (Only One Way): 我们希望在任何时候都只使用一种确定的 I/O 类型, 使代码在所有 I/O 处都保持一致</strong>. 因此, 我们不希望用户来决定是使用流还是 printf + read/write. 相反, 我们应该决定到底用哪一种方式. 把日志作为特例是因为日志是一个非常独特的应用, 还有一些是历史原因.</p>
<p>  流的支持者们主张流是不二之选, 但观点并不是那么清晰有力. 他们指出的流的每个优势也都是其劣势.<strong>流最大的优势是在输出时不需要关心打印对象的类型. 这是一个亮点. 同时, 也是一个不足: 你很容易用错类型, 而编译器不会报警</strong>. 使用流时容易造成的这类错误:</p>
<pre><code>cout &lt;&lt; this;   // 输出地址
cout &lt;&lt; *this;  // 输出值
</code></pre>
<p>由于 &lt;&lt; 被重载, 编译器不会报错. 就因为这一点我们反对使用操作符重载.</p>
<p>有人说 printf 的格式化丑陋不堪, 易读性差, 但流也好不到哪儿去. 看看下面两段代码吧, 实现相同的功能, 哪个更清晰?</p>
<pre><code>cerr &lt;&lt; &quot;Error connecting to '&quot; &lt;&lt; foo-&gt;bar()-&gt;hostname.first
     &lt;&lt; &quot;:&quot; &lt;&lt; foo-&gt;bar()-&gt;hostname.second &lt;&lt; &quot;: &quot; &lt;&lt; strerror(errno);

fprintf(stderr, &quot;Error connecting to '%s:%u: %s&quot;,
        foo-&gt;bar()-&gt;hostname.first, foo-&gt;bar()-&gt;hostname.second,
        strerror(errno));
</code></pre>
<p>  你可能会说, “把流封装一下就会比较好了”, 这儿可以, 其他地方呢? 而且不要忘了, 我们的目标是使语言更紧凑, 而不是添加一些别人需要学习的新装备.</p>
<p>  每一种方式都是各有利弊, “没有最好, 只有更适合”. <strong>简单性原则告诫我们必须从中选择其一, 最后大多数决定采用 printf + read/write.</strong></p>
<h3 id="611-前置自增和自减">6.11. 前置自增和自减</h3>
<p><strong>对于迭代器和其他模板对象使用前缀形式 (++i) 的自增, 自减运算符.</strong></p>
<p><strong>定义:</strong></p>
<p>  对于变量在自增 (++i 或 i++) 或自减 (--i 或 i--) 后表达式的值又没有没用到的情况下, 需要确定到底是使用前置还是后置的自增 (自减).</p>
<p><strong>优点:</strong></p>
<p>  不考虑返回值的话, 前置自增 (++i) 通常要比后置自增 (i++) 效率更高. 因为后置自增 (或自减) 需要对表达式的值 i 进行一次拷贝. 如果 i 是迭代器或其他非数值类型, 拷贝的代价是比较大的. 既然两种自增方式实现的功能一样, 为什么不总是使用前置自增呢?</p>
<p><strong>缺点:</strong></p>
<p>  在 C 开发中, 当表达式的值未被使用时, 传统的做法是使用后置自增, 特别是在 for 循环中. 有些人觉得后置自增更加易懂, 因为这很像自然语言, 主语 (i) 在谓语动词 (++) 前.</p>
<p><strong>结论:</strong></p>
<p>  <strong>对简单数值 (非对象), 两种都无所谓. 对迭代器和模板类型, 使用前置自增 (自减).</strong></p>
<h3 id="612-const-用法">6.12. const 用法</h3>
<p><strong>我们强烈建议你在任何可能的情况下都要使用 const. 此外有时改用 C++11 推出的 constexpr 更好。</strong></p>
<p><strong>定义:</strong></p>
<p>  在声明的变量或参数前加上关键字 const 用于指明变量值不可被篡改 (如 const int foo ). 为类中的函数加上 const 限定符表明该函数不会修改类成员变量的状态 (如 class Foo { int Bar(char c) const; };).<br>
优点:</p>
<p>  大家更容易理解如何使用变量. 编译器可以更好地进行类型检测, 相应地, 也能生成更好的代码. 人们对编写正确的代码更加自信, 因为他们知道所调用的函数被限定了能或不能修改变量值. 即使是在无锁的多线程编程中, 人们也知道什么样的函数是安全的.</p>
<p><strong>缺点:</strong></p>
<p>  <strong>const 是入侵性的: 如果你向一个函数传入 const 变量, 函数原型声明中也必须对应 const 参数 (否则变量需要 const_cast 类型转换), 在调用库函数时显得尤其麻烦.</strong></p>
<p><strong>结论:</strong></p>
<p>  const 变量, 数据成员, 函数和参数为编译时类型检测增加了一层保障; 便于尽早发现错误. 因此, 我们强烈建议<strong>在任何可能的情况下使用 const:</strong></p>
<ol>
<li><strong>如果函数不会修改传你入的引用或指针类型参数, 该参数应声明为 const</strong>.</li>
<li>尽可能将函数声明为 const. 访问函数应该总是 const. 其他不会修改任何数据成员, 未调用非 const 函数, 不会返回数据成员非 const 指针或引用的函数也应该声明成 const.</li>
<li>如果数据成员在对象构造之后不再发生变化, 可将其定义为 const.<br>
然而, 也不要发了疯似的使用 const. 像 const int * const * const x; 就有些过了, 虽然它非常精确的描述了常量 x. 关注真正有帮助意义的信息: 前面的例子写成 const int** x 就够了.</li>
</ol>
<p>  <strong>关键字 mutable 可以使用, 但是在多线程中是不安全的, 使用时首先要考虑线程安全</strong>.</p>
<p><strong>const 的位置:</strong></p>
<p>  有人喜欢 int const <em>foo 形式, 不喜欢 const int</em> foo, 他们认为前者更一致因此可读性也更好: 遵循了 const 总位于其描述的对象之后的原则. 但是一致性原则不适用于此, “不要过度使用” 的声明可以取消大部分你原本想保持的一致性. 将 const 放在前面才更易读, 因为在自然语言中形容词 (const) 是在名词 (int) 之前.</p>
<p>  <strong>这是说, 我们提倡但不强制 const 在前. 但要保持代码的一致性! (Yang.Y 注: 也就是不要在一些地方把 const 写在类型前面, 在其他地方又写在后面, 确定一种写法, 然后保持一致.)</strong></p>
<h3 id="613-constexpr-用法">6.13. constexpr 用法</h3>
<p><strong>在 C++11 里，用 constexpr 来定义真正的常量，或实现常量初始化。</strong></p>
<p><strong>定义:</strong></p>
<p>  <strong>变量可以被声明成 constexpr 以表示它是真正意义上的常量，即在编译时和运行时都不变。函数或构造函数也可以被声明成 constexpr, 以用来定义 constexpr 变量。</strong></p>
<p><strong>优点:</strong></p>
<p>  如今 constexpr 就可以定义浮点式的真・常量，不用再依赖字面值了；也可以定义用户自定义类型上的常量；甚至也可以定义函数调用所返回的常量。</p>
<p><strong>缺点:</strong></p>
<p>  若过早把变量优化成 constexpr 变量，将来又要把它改为常规变量时，挺麻烦的；当前对constexpr函数和构造函数中允许的限制可能会导致这些定义中解决的方法模糊。</p>
<p><strong>结论:</strong></p>
<p>  靠 constexpr 特性，方才实现了 C++ 在接口上打造真正常量机制的可能。<strong>好好用 constexpr 来定义真・常量以及支持常量的函数。避免复杂的函数定义，以使其能够与constexpr一起使用</strong>。 千万别痴心妄想地想靠 constexpr 来强制代码「内联」。</p>
<h3 id="614-整型">6.14. 整型</h3>
<p>  C++ 内建整型中, 仅使用 int.<strong>如果程序中需要不同大小的变量, 可以使用 &lt;stdint.h&gt; 中长度精确的整型, 如 int16_t.如果您的变量可能不小于 2^31 (2GiB), 就用 64 位变量比如 int64_t</strong>. 此外要留意，哪怕您的值并不会超出 int 所能够表示的范围，在计算过程中也可能会溢出。<strong>所以拿不准时，干脆用更大的类型。</strong></p>
<p><strong>定义:</strong></p>
<p>  <strong>C++ 没有指定整型的大小</strong>. 通常人们假定 short 是 16 位, int 是 32 位, long 是 32 位, long long 是 64 位.</p>
<p><strong>优点:</strong></p>
<p>  保持声明统一.</p>
<p><strong>缺点:</strong></p>
<p>  <strong>C++ 中整型大小因编译器和体系结构的不同而不同.</strong></p>
<p><strong>结论:</strong></p>
<p>  &lt;stdint.h&gt; <strong>定义了 int16_t, uint32_t, int64_t 等整型</strong>, 在需要确保整型大小时可以使用它们代替 short, unsigned long long 等. 在 C 整型中, 只使用 int. 在合适的情况下, 推荐使用<strong>标准类型如 size_t 和 ptrdiff_t</strong>.</p>
<p>  <strong>如果已知整数不会太大, 我们常常会使用 int</strong>, 如循环计数. 在类似的情况下使用原生类型 int. 你可以认为 int 至少为 32 位, 但不要认为它会多于 32 位. <strong>如果需要 64 位整型, 用 int64_t 或 uint64_t</strong>.</p>
<p>  <strong>对于大整数, 使用 int64_t</strong>.</p>
<p>  <strong>不要使用 uint32_t 等无符号整型, 除非你是在表示一个位组而不是一个数值（亦即用作位运算而不是数值表达）, 或是你需要定义二进制补码溢出. 尤其是不要为了指出数值永不会为负, 而使用无符号类型. 相反, 你应该使用断言来保护数据.</strong></p>
<p>  如果您的代码涉及容器返回的大小（size），确保其类型足以应付容器各种可能的用法。拿不准时，类型越大越好。</p>
<p>  <strong>小心整型类型转换和整型提升</strong>（译者 注：integer promotions,<strong>比如 int 与 unsigned int 运算时，前者被提升为 unsigned int 而有可能溢出</strong>），总有意想不到的后果。</p>
<p>关于无符号整数:</p>
<p>  有些人, 包括一些教科书作者, 推荐使用无符号类型表示非负数. 这种做法试图达到自我文档化. 但是, 在 C 语言中, 这一优点被由其导致的 bug 所淹没. 看看下面的例子:</p>
<pre><code>for (unsigned int i = foo.Length()-1; i &gt;= 0; --i) ...
</code></pre>
<p>  上述循环永远不会退出! 有时 gcc 会发现该 bug 并报警, 但大部分情况下都不会. 类似的 bug 还会出现在比较有符合变量和无符号变量时. 主要是 C 的类型提升机制会致使无符号类型的行为出乎你的意料.</p>
<p>  <strong>因此, 使用断言来指出变量为非负数, 而不是使用无符号型!</strong></p>
<h3 id="615-64-位下的可移植性">6.15. 64 位下的可移植性</h3>
<p>  代码应该对 64 位和 32 位系统友好. 处理打印, 比较, 结构体对齐时应切记:<br>
  <strong>对于某些类型, printf() 的指示符在 32 位和 64 位系统上可移植性不是很好.</strong> C99 标准定义了一些可移植的格式化指示符. 不幸的是, MSVC 7.1 并非全部支持, 而且标准中也有所遗漏, 所以有时我们不得不自己定义一个丑陋的版本 (头文件 inttypes.h 仿标准风格):</p>
<pre><code>// printf macros for size_t, in the style of inttypes.h
#ifdef _LP64
#define __PRIS_PREFIX &quot;z&quot;
#else
#define __PRIS_PREFIX
#endif

// Use these macros after a % in a printf format string
// to get correct 32/64 bit behavior, like this:
// size_t size = records.size();
// printf(&quot;%&quot;PRIuS&quot;\n&quot;, size);
#define PRIdS __PRIS_PREFIX &quot;d&quot;
#define PRIxS __PRIS_PREFIX &quot;x&quot;
#define PRIuS __PRIS_PREFIX &quot;u&quot;
#define PRIXS __PRIS_PREFIX &quot;X&quot;
#define PRIoS __PRIS_PREFIX &quot;o&quot;
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">不要使用</th>
<th style="text-align:center">使用</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">void * (或其他指针类型)</td>
<td style="text-align:center">%lx</td>
<td style="text-align:center">%p</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">int64_t</td>
<td style="text-align:center">%qd, %lld</td>
<td style="text-align:center">%&quot;PRId64&quot;</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">uint64_t</td>
<td style="text-align:center">%qu, %llu, %llx</td>
<td style="text-align:center">%&quot;PRIu64&quot;, %&quot;PRIx64&quot;</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">size_t</td>
<td style="text-align:center">%u</td>
<td style="text-align:center">%&quot;PRIuS&quot;, %&quot;PRIxS&quot;</td>
<td style="text-align:center">C99 规定 %zu</td>
</tr>
<tr>
<td style="text-align:center">ptrdiff_t</td>
<td style="text-align:center">%d</td>
<td style="text-align:center">%&quot;PRIdS&quot;</td>
<td style="text-align:center">C99 规定 %zd</td>
</tr>
</tbody>
</table>
<p>  注意<code>PRI*</code>宏会被编译器扩展为独立字符串. 因此如果使用非常量的格式化字符串, 需要将宏的值而不是宏名插入格式中. 使用<code>PRI*</code>宏同样可以在 % 后包含长度指示符. 例如, <code>printf(&quot;x = %30&quot;PRIuS&quot;\n&quot;, x)</code>在 32 位 Linux 上将被展开为 <code>printf(&quot;x = %30&quot; &quot;u&quot; &quot;\n&quot;, x)</code>, 编译器当成 <code>printf(&quot;x = %30u\n&quot;, x)</code>处理 (Yang.Y 注: 这在 MSVC 6.0 上行不通, VC 6 编译器不会自动把引号间隔的多个字符串连接一个长字符串).</p>
<ol>
<li>记住 <code>sizeof(void *) != sizeof(int)</code>. 如果需要一个指针大小的整数要用 <code>intptr_t</code>.</li>
<li>你要非常小心的对待结构体对齐, 尤其是要持久化到磁盘上的结构体 (Yang.Y 注: 持久化 - 将数据按字节流顺序保存在磁盘文件或数据库中). 在 64 位系统中, 任何含有<code>int64_t</code>/<code>uint64_t</code>成员的类/结构体, 缺省都以 8 字节在结尾对齐. 如果 32 位和 64 位代码要共用持久化的结构体, 需要确保两种体系结构下的结构体对齐一致. 大多数编译器都允许调整结构体对齐. gcc 中可使用 <code>__attribute__((packed))</code>. MSVC 则提供了 <code>#pragma pack()</code> 和 <code>__declspec(align())</code> (YuleFox 注, 解决方案的项目属性里也可以直接设置).</li>
<li>创建 64 位常量时使用 LL 或 ULL 作为后缀, 如:</li>
</ol>
<pre><code>int64_t my_value = 0x123456789LL;
uint64_t my_mask = 3ULL &lt;&lt; 48;
</code></pre>
<ol start="4">
<li>如果你确实需要 32 位和 64 位系统具有不同代码, 可以使用 #ifdef _LP64 指令来切分 32/64 位代码. (尽量不要这么做, 如果非用不可, 尽量使修改局部化)</li>
</ol>
<h3 id="616-预处理宏">6.16. 预处理宏</h3>
<p><strong>使用宏时要非常谨慎, 尽量以内联函数, 枚举和常量代替之.</strong></p>
<p>  <strong>宏意味着你和编译器看到的代码是不同的. 这可能会导致异常行为, 尤其因为宏具有全局作用域.</strong></p>
<p>  值得庆幸的是, C++ 中, 宏不像在 C 中那么必不可少.<br>
<strong>以往用宏展开性能关键的代码, 现在可以用内联函数替代.</strong><br>
<strong>用宏表示常量可被 const 变量代替</strong>.<br>
<strong>用宏 “缩写” 长变量名可被引用代替</strong>.<br>
用宏进行条件编译… 这个, 千万别这么做, 会令测试更加痛苦 (#define 防止头文件重包含当然是个特例).</p>
<p>  <strong>宏可以做一些其他技术无法实现的事情</strong>, 在一些代码库 (尤其是底层库中) 可以看到宏的某些特性 (如用 # 字符串化, 用 ## 连接等等). <strong>但在使用前, 仔细考虑一下能不能不使用宏达到同样的目的.</strong></p>
<p>下面给出的用法模式可以避免使用宏带来的问题; <strong>如果你要宏, 尽可能遵守</strong>:</p>
<ol>
<li><strong>不要在 .h 文件中定义宏.</strong></li>
<li><strong>在马上要使用时才进行 #define, 使用后要立即 #undef.</strong></li>
<li>不要只是对已经存在的宏使用#undef，选择一个不会冲突的名称；</li>
<li>不要试图使用展开后会<strong>导致 C++ 构造不稳定的宏</strong>, 不然也至少要附上文档说明其行为.</li>
<li><strong>不要用 ## 处理函数，类和变量的名字。</strong></li>
</ol>
<h3 id="617-0-nullptr-和-null">6.17.  0, nullptr 和 NULL</h3>
<p>整数用 0, 实数用 0.0, 指针用 nullptr 或 NULL, <strong>字符 (串) 用 '\0'.</strong></p>
<p>  整数用 0, 实数用 0.0, 这一点是毫无争议的.</p>
<p>  对于指针 (地址值), 到底是用 0, NULL 还是 nullptr. C++11 项目用 nullptr; C++03 项目则用 NULL, 毕竟它看起来像指针。<strong>实际上，一些 C++ 编译器对 NULL 的定义比较特殊，可以输出有用的警告，特别是 sizeof(NULL) 就和 sizeof(0) 不一样。</strong></p>
<p>  字符 (串) 用 '\0', 不仅类型正确而且可读性好.</p>
<h3 id="618-sizeof">6.18. sizeof</h3>
<p>尽可能用 sizeof(varname) 代替 sizeof(type).</p>
<p>  使用 sizeof(varname) 是因为当代码中变量类型改变时会自动更新. 您或许会用 sizeof(type) 处理不涉及任何变量的代码，比如处理来自外部或内部的数据格式，这时用变量就不合适了。</p>
<pre><code>Struct data;
Struct data; memset(&amp;data, 0, sizeof(data));
</code></pre>
<p><strong>Warning</strong></p>
<pre><code>memset(&amp;data, 0, sizeof(Struct));
</code></pre>
<pre><code>if (raw_size &lt; sizeof(int)) {
    LOG(ERROR) &lt;&lt; &quot;compressed record not big enough for count: &quot; &lt;&lt; raw_size;
    return false;
}
</code></pre>
<h3 id="619-auto">6.19. auto</h3>
<p>用 auto 绕过烦琐的类型名，只要可读性好就继续用，别用在局部变量之外的地方。</p>
<p><strong>定义：</strong></p>
<p>  C++11 中，若变量被声明成 auto, 那它的类型就会被自动匹配成初始化表达式的类型。您可以用 auto 来复制初始化或绑定引用。</p>
<pre><code>vector&lt;string&gt; v;
...
auto s1 = v[0];  // 创建一份 v[0] 的拷贝。
const auto&amp; s2 = v[0];  // s2 是 v[0] 的一个引用。
</code></pre>
<p><strong>优点：</strong></p>
<p>  C++ 类型名有时又长又臭，特别是涉及模板或命名空间的时候。就像：</p>
<pre><code>sparse_hash_map&lt;string, int&gt;::iterator iter = m.find(val);
</code></pre>
<p>返回类型好难读，代码目的也不够一目了然。重构其：</p>
<pre><code>auto iter = m.find(val);
</code></pre>
<p>好多了。</p>
<p>  没有 auto 的话，我们不得不在同一个表达式里写同一个类型名两次，无谓的重复，就像：</p>
<pre><code>diagnostics::ErrorStatus* status = new 
diagnostics::ErrorStatus(&quot;xyz&quot;);
</code></pre>
<p>有了 auto, 可以更方便地用中间变量，显式编写它们的类型轻松点。</p>
<p><strong>缺点：</strong></p>
<p>  类型够明显时，特别是初始化变量时，代码才会够一目了然。但以下就不一样了：</p>
<pre><code>auto i = x.Lookup(key);
</code></pre>
<p>看不出其类型是啥，x 的类型声明恐怕远在几百行之外了。</p>
<p>  <strong>程序员必须会区分 auto 和 const auto&amp; 的不同之处，否则会复制错东西。</strong></p>
<p>  <strong>auto 和 C++11 列表初始化的合体令人摸不着头脑：</strong></p>
<pre><code>auto x(3);  // 圆括号。
auto y{3};  // 大括号。
</code></pre>
<p>  <strong>它们不是同一回事——x 是 int, y 则是<code>std::initializer_list&lt;int&gt;</code>.</strong> 其它一般不可见的代理类型（译者注：normally-invisible proxy types, 它涉及到 C++ 鲜为人知的坑：<code>Why is vector&lt;bool&gt; not a STL container?</code>）也有大同小异的陷阱。</p>
<p>  如果在接口里用 auto, 比如声明头文件里的一个常量，那么只要仅仅因为程序员一时修改其值而导致类型变化的话——API 要翻天覆地了。</p>
<p><strong>结论：</strong></p>
<p>  <strong>auto 只能用在局部变量里用。别用在文件作用域变量（亦即作用域为整个文件的变量），命名空间作用域变量和类数据成员里。永远别列表初始化 auto 变量。</strong></p>
<p>  <strong>auto 还可以和 C++11 特性「尾置返回类型（trailing return type）」一起用，不过后者只能用在 lambda 表达式里。</strong></p>
<h3 id="620-列表初始化">6.20. 列表初始化</h3>
<p>你可以用列表初始化。</p>
<p>  早在 C++03 里，聚合类型（aggregate types）就已经可以被列表初始化了，比如数组和不自带构造函数的结构体：</p>
<pre><code>struct Point { int x; int y; };
Point p = {1, 2};
</code></pre>
<p>  <strong>C++11 中，该特性得到进一步的推广，任何对象类型都可以被列表初始化</strong>示范如下：</p>
<p>// Vector 接收了一个初始化列表。</p>
<pre><code>vector&lt;string&gt; v{&quot;foo&quot;, &quot;bar&quot;};

// 不考虑细节上的微妙差别，大致上相同。
// 您可以任选其一。
vector&lt;string&gt; v = {&quot;foo&quot;, &quot;bar&quot;};

// 可以配合 new 一起用。
auto p = new vector&lt;string&gt;{&quot;foo&quot;, &quot;bar&quot;};

// map 接收了一些 pair, 列表初始化大显神威。
map&lt;int, string&gt; m = {{1, &quot;one&quot;}, {2, &quot;2&quot;}};

// 初始化列表也可以用在返回类型上的隐式转换。
vector&lt;int&gt; test_function() { return {1, 2, 3}; }

// 初始化列表可迭代。
for (int i : {-1, -2, -3}) {}

// 在函数调用里用列表初始化。
void TestFunction2(vector&lt;int&gt; v) {}
TestFunction2({1, 2, 3});
</code></pre>
<p>  <strong>用户自定义类型也可以定义接收<code>std::initializer_list&lt;T&gt;</code> 的构造函数和赋值运算符，以自动列表初始化</strong></p>
<p><strong>个人笔记：列表的本质就是initializer_list，所以使用auto时不可以用列表初始化</strong></p>
<pre><code>class MyType {
 public:
  // std::initializer_list 专门接收 init 列表。
  // 得以值传递。
  MyType(std::initializer_list&lt;int&gt; init_list) {
    for (int i : init_list) append(i);
  }
  MyType&amp; operator=(std::initializer_list&lt;int&gt; init_list) {
    clear();
    for (int i : init_list) append(i);
  }
};
MyType m{2, 3, 5, 7};
</code></pre>
<p>  最后，<strong>列表初始化也适用于常规数据类型的构造，哪怕没有接收 <code>std::initializer_list&lt;T&gt;</code> 的构造函数。</strong></p>
<pre><code>double d{1.23};
// MyOtherType 没有 std::initializer_list 构造函数，
 // 直接上接收常规类型的构造函数。
class MyOtherType {
 public:
  explicit MyOtherType(string);
  MyOtherType(int, string);
};
MyOtherType m = {1, &quot;b&quot;};
// 不过如果构造函数是显式的（explict），您就不能用 `= {}` 了。
MyOtherType m{&quot;b&quot;};
</code></pre>
<p>  <strong>千万别直接列表初始化 auto 变量</strong>，看下一句，估计没人看得懂：</p>
<p><strong>Warning</strong></p>
<pre><code>auto d = {1.23};        // d 即是 std::initializer_list&lt;double&gt;
</code></pre>
<pre><code>auto d = double{1.23};  // 善哉 -- d 即为 double, 并非 std::initializer_list.
</code></pre>
<p>至于格式化，参见 9.7. 列表初始化格式.</p>
<h3 id="621-lambda-表达式">6.21. Lambda 表达式</h3>
<p><strong>适当使用 lambda 表达式。别用默认 lambda 捕获，所有捕获都要显式写出来。</strong></p>
<p><strong>定义：</strong></p>
<p>  Lambda 表达式是创建匿名函数对象的一种简易途径，常用于把函数当参数传，例如：</p>
<pre><code>std::sort(v.begin(), v.end(), [](int x, int y) {
    return Weight(x) &lt; Weight(y);
});
</code></pre>
<p>  C++11 首次提出 Lambdas, 还<strong>提供了一系列处理函数对象的工具</strong>，比如<strong>多态包装器（polymorphic wrapper） std::function.</strong></p>
<p><strong>优点：</strong></p>
<ol>
<li>传函数对象给 STL 算法，Lambdas 最简易，可读性也好。</li>
<li><strong>Lambdas, std::functions 和 std::bind 可以搭配成通用回调机制（general purpose callback mechanism）；写接收有界函数为参数的函数也很容易了。</strong></li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li><strong>Lambdas 的变量捕获略旁门左道，可能会造成悬空指针。</strong></li>
<li><strong>Lambdas 可能会失控；层层嵌套的匿名函数难以阅读。</strong></li>
</ol>
<p><strong>结论：</strong></p>
<ol>
<li>按 format 小用 lambda 表达式怡情。</li>
<li><strong>禁用默认捕获，捕获都要显式写出来</strong>。打比方，比起 [=](int x) {return x + n;}, 您该写成 [n](int x) {return x + n;} 才对，这样读者也好一眼看出 n 是被捕获的值。</li>
<li><strong>匿名函数始终要简短，如果函数体超过了五行，那么还不如起名（acgtyrant 注：即把 lambda 表达式赋值给对象），或改用函数。</strong></li>
<li><strong>如果可读性更好，就显式写出 lambd 的尾置返回类型，就像auto.</strong></li>
</ol>
<h3 id="622-模板编程">6.22. 模板编程</h3>
<p><strong>不要使用复杂的模板编程</strong></p>
<p><strong>定义:</strong></p>
<p>  模板编程指的是利用c++ 模板实例化机制是图灵完备性, 可以被用来实现编译时刻的类型判断的一系列编程技巧</p>
<p><strong>优点:</strong></p>
<p>  模板编程能够实现非常灵活的类型安全的接口和极好的性能, 一些常见的工具比如Google Test, std::tuple, std::function 和 Boost.Spirit. 这些工具如果没有模板是实现不了的</p>
<p><strong>缺点:</strong></p>
<ol>
<li>模板编程所使用的技巧对于使用c++不是很熟练的人是比较晦涩, 难懂的. 在复杂的地方使用模板的代码让人更不容易读懂, 并且debug 和 维护起来都很麻烦</li>
<li><strong>模板编程经常会导致编译出错的信息非常不友好</strong>: 在代码出错的时候, 即使这个接口非常的简单,** 模板内部复杂的实现细节也会在出错信息显示. 导致这个编译出错信息看起来非常难以理解**.</li>
<li><strong>大量的使用模板编程接口会让重构工具</strong>(Visual Assist X, Refactor for C++等等)<strong>更难发挥用途</strong>. 首先模板的代码会在很多上下文里面扩展开来, 所以很难确认重构对所有的这些展开的代码有用, 其次有些重构工具只对已经做过模板类型替换的代码的AST 有用. 因此重构工具对这些模板实现的原始代码并不有效, 很难找出哪些需要重构.</li>
</ol>
<p><strong>结论:</strong></p>
<ol>
<li>模板编程有时候能够实现更简洁更易用的接口, 但是更多的时候却适得其反. 因此<strong>模板编程最好只用在少量的基础组件, 基础数据结构上, 因为模板带来的额外的维护成本会被大量的使用给分担掉</strong></li>
<li>在使用模板编程或者其他复杂的模板技巧的时候, 你一定要再三考虑一下. 考虑一下你们团队成员的平均水平是否能够读懂并且能够维护你写的模板代码.或者一个非c++ 程序员和一些只是在出错的时候偶尔看一下代码的人能够读懂这些错误信息或者能够跟踪函数的调用流程. <strong>如果你使用递归的模板实例化, 或者类型列表, 或者元函数, 又或者表达式模板, 或者依赖SFINAE, 或者sizeof 的trick 手段来检查函数是否重载, 那么这说明你模板用的太多了, 这些模板太复杂了, 我们不推荐使用</strong></li>
<li>如果你使用模板编程, 你必须考虑尽可能的把复杂度最小化, 并且尽量不要让模板对外暴漏. <strong>你最好只在实现里面使用模板, 然后给用户暴露的接口里面并不使用模板, 这样能提高你的接口的可读性.</strong> 并且你应该<strong>在这些使用模板的代码上写尽可能详细的注释.</strong> 你的注释里面应该详细的包含这些代码是怎么用的, 这些模板生成出来的代码大概是什么样子的. 还需要<strong>额外注意在用户错误使用你的模板代码的时候需要输出更人性化的出错信息. 因为这些出错信息也是你的接口的一部分</strong>, 所以你的代码必须调整到这些错误信息在用户看起来应该是非常容易理解, 并且用户很容易知道如何修改这些错误</li>
</ol>
<h3 id="623-boost-库">6.23. Boost 库</h3>
<p><strong>只使用 Boost 中被认可的库.</strong></p>
<p><strong>定义:</strong></p>
<p>  Boost 库集 是一个广受欢迎, 经过同行鉴定, 免费开源的 C++ 库集.</p>
<p><strong>优点:</strong></p>
<p>  Boost代码质量普遍较高, 可移植性好, 填补了 C++ 标准库很多空白, 如型别的特性, 更完善的绑定器, 更好的智能指针。</p>
<p><strong>缺点:</strong></p>
<p>  某些 Boost 库提倡的编程实践可读性差, 比如元编程和其他高级模板技术, 以及过度 “函数化” 的编程风格.</p>
<p><strong>结论:</strong></p>
<p>  <strong>为了向阅读和维护代码的人员提供更好的可读性, 我们只允许使用 Boost 一部分经认可的特性子集. 目前允许使用以下库:</strong></p>
<ol>
<li>Call Traits : boost/call_traits.hpp</li>
<li>Compressed Pair : boost/compressed_pair.hpp</li>
<li>&lt;The Boost Graph Library (BGL) : boost/graph, except serialization (adj_list_serialize.hpp) and parallel/distributed algorithms and data structures(boost/graph/parallel/* and boost/graph/distributed/*)</li>
<li>Property Map : boost/property_map.hpp</li>
<li>The part of Iterator that deals with defining iterators: boost/iterator/iterator_adaptor.hpp, boost/iterator/iterator_facade.hpp, and boost/function_output_iterator.hpp</li>
<li>The part of Polygon that deals with Voronoi diagram construction and doesn’t depend on the rest of Polygon: boost/polygon/voronoi_builder.hpp, boost/polygon/voronoi_diagram.hpp, and boost/polygon/voronoi_geometry_type.hpp</li>
<li>Bimap : boost/bimap</li>
<li>Statistical Distributions and Functions : boost/math/distributions</li>
<li>Multi-index : boost/multi_index</li>
<li>Heap : boost/heap</li>
<li>The flat containers from Container: boost/container/flat_map, and boost/container/flat_set</li>
</ol>
<p>我们正在积极考虑增加其它 Boost 特性, 所以列表中的规则将不断变化.</p>
<p>以下库可以用，但由于如今已经被 C++ 11 标准库取代，不再鼓励：</p>
<ol>
<li>Pointer Container : boost/ptr_container, 改用 std::unique_ptr</li>
<li>Array : boost/array.hpp, 改用 std::array</li>
</ol>
<h3 id="624-c11">6.24. C++11</h3>
<p>适当用 C++11（前身是 C++0x）的库和语言扩展，在贵项目用 C++11 特性前三思可移植性。</p>
<p><strong>定义：</strong></p>
<p>  C++11 有众多语言和库上的<a href="https://en.wikipedia.org/wiki/C%2B%2B11">变革</a> 。</p>
<p><strong>优点：</strong></p>
<p>  在二〇一四年八月之前，C++11 一度是官方标准，被大多 C++ 编译器支持。它标准化很多我们早先就在用的 C++ 扩展，简化了不少操作，大大改善了性能和安全。</p>
<p><strong>缺点：</strong></p>
<p>  C++11 相对于前身，复杂极了：1300 页 vs 800 页！很多开发者也不怎么熟悉它。于是从长远来看，前者特性对代码可读性以及维护代价难以预估。我们说不准什么时候采纳其特性，特别是在被迫依赖老实工具的项目上。</p>
<p>  和 6.23. Boost 库 一样，有些 C++11 扩展提倡实则对可读性有害的编程实践——就像去除冗余检查（比如类型名）以帮助读者，或是鼓励模板元编程等等。有些扩展在功能上与原有机制冲突，容易招致困惑以及迁移代价。</p>
<p><strong>缺点：</strong></p>
<p>  C++11 特性除了个别情况下，可以用一用。除了本指南会有不少章节会加以讨若干 C++11 特性之外，<strong>以下特性最好不要用：</strong></p>
<ol>
<li>尾置返回类型，比如用 auto foo() -&gt; int 代替 int foo(). 为了兼容于现有代码的声明风格。</li>
<li>编译时合数 <code>&lt;ratio&gt;</code>, 因为它涉及一个重模板的接口风格。</li>
<li><code>&lt;cfenv&gt;</code> 和 <code>&lt;fenv.h&gt;</code>头文件，因为编译器尚不支持。</li>
<li>默认 lambda 捕获。</li>
</ol>
<p><strong>译者笔记</strong></p>
<ol>
<li>实际上，缺省参数会改变函数签名的前提是改变了它接收的参数数量，比如把 void a() 改成 void a(int b = 0), 开发者改变其代码的初衷也许是，在不改变「代码兼容性」的同时，又提供了可选 int 参数的余地，然而这终究会破坏函数指针上的兼容性，毕竟函数签名确实变了。</li>
<li>此外把自带缺省参数的函数地址赋值给指针时，会丢失缺省参数信息。</li>
<li>我还发现 滥用缺省参数会害得读者光只看调用代码的话，会误以为其函数接受的参数数量比实际上还要少。</li>
<li>friend 实际上只对函数／类赋予了对其所在类的访问权限，并不是有效的声明语句。所以除了在头文件类内部写 friend 函数／类，还要在类作用域之外正式地声明一遍，最后在对应的 .cc 文件加以定义。</li>
<li>本风格指南都强调了「友元应该定义在同一文件内，避免代码读者跑到其它文件查找使用该私有成员的类」。那么可以把其声明放在类声明所在的头文件，定义也放在类定义所在的文件。</li>
<li>由于友元函数／类并不是类的一部分，自然也不会是类可调用的公有接口，于是我主张全集中放在类的尾部，即的数据成员之后，参考 声明顺序 。</li>
<li>对使用 C++ 异常处理应具有怎样的态度？ 非常值得一读。</li>
<li>注意初始化 const 对象时，必须在初始化的同时值初始化。</li>
<li>用断言代替无符号整型类型，深有启发。</li>
<li>auto 在涉及迭代器的循环语句里挺常用。</li>
<li>Should the trailing return type syntax style become the default for new C++11 programs? 讨论了 auto 与尾置返回类型一起用的全新编码风格，值得一看。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[5. 来自 Google 的奇技 -Google C++编程规范]]></title>
        <id>https://lixin-scut.github.io//post/5-lai-zi-google-de-qi-ji-google-cbian-cheng-gui-fan</id>
        <link href="https://lixin-scut.github.io//post/5-lai-zi-google-de-qi-ji-google-cbian-cheng-gui-fan">
        </link>
        <updated>2020-04-27T12:41:14.000Z</updated>
        <content type="html"><![CDATA[<p>  Google 用了很多自己实现的技巧 / 工具使 C++ 代码更加健壮, 我们使用 C++ 的方式可能和你在其它地方见到的有所不同.</p>
<h3 id="51-所有权与智能指针">5.1. 所有权与智能指针</h3>
<p><strong>总述</strong></p>
<p>  动态分配出的对象最好有单一且固定的所有主, 并通过智能指针传递所有权.</p>
<p><strong>定义</strong></p>
<p>  所有权是一种登记／管理动态内存和其它资源的技术. 动态分配对象的所有主是一个对象或函数, 后者负责确保当前者无用时就自动销毁前者. 所有权有时可以共享, 此时就由最后一个所有主来负责销毁它. 甚至也可以不用共享, 在代码中直接把所有权传递给其它对象.</p>
<p>  <strong>智能指针是一个通过重载 * 和 -&gt; 运算符以表现得如指针一样的类</strong>. 智能指针类型被用来自动化所有权的登记工作, 来确保执行销毁义务到位. std::unique_ptr 是 C++11 新推出的一种智能指针类型, 用来表示动态分配出的对象的独一无二的所有权; 当 std::unique_ptr 离开作用域时, 对象就会被销毁. std::unique_ptr 不能被复制, 但可以把它移动（move）给新所有主. std::shared_ptr 同样表示动态分配对象的所有权, 但可以被共享, 也可以被复制; 对象的所有权由所有复制者共同拥有, 最后一个复制者被销毁时, 对象也会随着被销毁.</p>
<p><strong>优点</strong></p>
<ol>
<li>如果没有清晰、逻辑条理的所有权安排, 不可能管理好动态分配的内存.</li>
<li>传递对象的所有权, 开销比复制来得小, 如果可以复制的话.</li>
<li>传递所有权也比”借用”指针或引用来得简单, 毕竟它大大省去了两个用户一起协调对象生命周期的工作.</li>
<li>如果所有权逻辑条理, 有文档且不紊乱的话, 可读性会有很大提升.</li>
<li>可以不用手动完成所有权的登记工作, 大大简化了代码, 也免去了一大波错误之恼.</li>
<li>对于 const 对象来说, 智能指针简单易用, 也比深度复制高效.</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>不得不用指针（不管是智能的还是原生的）来表示和传递所有权. 指针语义可要比值语义复杂得许多了, 特别是在 API 里：这时不光要操心所有权, 还要顾及别名, 生命周期, 可变性以及其它大大小小的问题.</li>
<li>其实值语义的开销经常被高估, 所以所有权传递带来的性能提升不一定能弥补可读性和复杂度的损失.</li>
<li>如果 API 依赖所有权的传递, 就会害得客户端不得不用单一的内存管理模型.</li>
<li><strong>如果使用智能指针, 那么资源释放发生的位置就会变得不那么明显.</strong></li>
<li>std::unique_ptr 的所有权传递原理是 C++11 的 move 语法, 后者毕竟是刚刚推出的, 容易迷惑程序员.</li>
<li>如果原本的所有权设计已经够完善了, 那么若要引入所有权共享机制, 可能不得不重构整个系统.</li>
<li>所有权共享机制的登记工作在运行时进行, 开销可能相当大.</li>
<li>某些极端情况下 (例如循环引用), 所有权被共享的对象永远不会被销毁.</li>
<li>智能指针并不能够完全代替原生指针.</li>
</ol>
<p><strong>结论</strong></p>
<p>  如果必须使用动态分配, 那么更倾向于将所有权保持在分配者手中. 如果其他地方要使用这个对象, 最好传递它的拷贝, 或者传递一个不用改变所有权的指针或引用. 倾向于使用 std::unique_ptr 来明确所有权传递, 例如：</p>
<pre><code>std::unique_ptr&lt;Foo&gt; FooFactory();
void FooConsumer(std::unique_ptr&lt;Foo&gt; ptr);
</code></pre>
<p>  <strong>如果没有很好的理由, 则不要使用共享所有权. 这里的理由可以是为了避免开销昂贵的拷贝操作, 但是只有当性能提升非常明显, 并且操作的对象是不可变的（比如说 <code>std::shared_ptr&lt;const Foo&gt; ）</code>时候, 才能这么做. 如果确实要使用共享所有权, 建议于使用 std::shared_ptr .</strong></p>
<p>  <strong>不要使用 std::auto_ptr, 使用 std::unique_ptr 代替它.</strong></p>
<h3 id="52-cpplint">5.2. Cpplint</h3>
<p><strong>总述</strong></p>
<p>  使用 cpplint.py 检查风格错误.</p>
<p><strong>说明</strong></p>
<p>  cpplint.py 是一个用来分析源文件, 能检查出多种风格错误的工具. 它不并完美, 甚至还会漏报和误报, 但它仍然是一个非常有用的工具. 在行尾加 // NOLINT, 或在上一行加 // NOLINTNEXTLINE, 可以忽略报错.</p>
<p>  某些项目会指导你如何使用他们的项目工具运行 cpplint.py. 如果你参与的项目没有提供, 你可以单独下载 cpplint.py.</p>
<h3 id="译者笔记">译者笔记</h3>
<ol>
<li>把智能指针当成对象来看待的话, 就很好领会它与所指对象之间的关系了.</li>
<li>原来 Rust 的 Ownership 思想是受到了 C++ 智能指针的很大启发啊.</li>
<li>scoped_ptr 和 auto_ptr 已过时. 现在是 shared_ptr 和 uniqued_ptr 的天下了.</li>
<li>按本文来说, 似乎除了智能指针, 还有其它所有权机制, 值得留意.</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[4. 函数 -Google C++编程规范]]></title>
        <id>https://lixin-scut.github.io//post/4-han-shu-google-cbian-cheng-gui-fan</id>
        <link href="https://lixin-scut.github.io//post/4-han-shu-google-cbian-cheng-gui-fan">
        </link>
        <updated>2020-04-27T12:27:34.000Z</updated>
        <content type="html"><![CDATA[<h3 id="41-参数顺序">4.1. 参数顺序</h3>
<p><strong>总述</strong></p>
<p>  函数的参数顺序为: <strong>输入参数在先, 后跟输出参数.</strong></p>
<p><strong>说明</strong></p>
<p>  C/C++ 中的函数参数或者是函数的输入, 或者是函数的输出, 或兼而有之. <strong>输入参数</strong>通常是<strong>值参或 const 引用</strong>, <strong>输出参数或输入/输出参数</strong>则一般为<strong>非 const 指针</strong>. 在排列参数顺序时, 将所有的输入参数置于输出参数之前. 特别要注意, <strong>在加入新参数时不要因为它们是新参数就置于参数列表最后, 而是仍然要按照前述的规则</strong>, 即将新的输入参数也置于输出参数之前.</p>
<p>  这并非一个硬性规定. 输入/输出参数 (通常是类或结构体) 让这个问题变得复杂. 并且, 有时候为了其他函数保持一致, 你可能不得不有所变通.</p>
<h3 id="42-编写简短函数">4.2. 编写简短函数</h3>
<p><strong>总述</strong></p>
<p>  我们倾向于编写简短, 凝练的函数.</p>
<p><strong>说明</strong></p>
<p>  我们承认长函数有时是合理的, 因此并不硬性限制函数的长度. <strong>如果函数超过 40 行, 可以思索一下能不能在不影响程序结构的前提下对其进行分割.</strong></p>
<p>  即使一个长函数现在工作的非常好, 一旦有人对其修改, 有可能出现新的问题, 甚至导致难以发现的 bug. 使函数尽量简短, 以便于他人阅读和修改代码.</p>
<p>  在处理代码时, 你可能会发现复杂的长函数. 不要害怕修改现有代码: 如果证实这些代码使用 / 调试起来很困难, 或者你只需要使用其中的一小段代码, 考虑将其分割为更加简短并易于管理的若干函数.</p>
<h3 id="43-引用参数">4.3. 引用参数</h3>
<p><strong>总述</strong></p>
<p>  <strong>所有按引用传递的参数必须加上 const.</strong></p>
<p><strong>定义</strong></p>
<p>  在 C 语言中, 如果函数需要修改变量的值, 参数必须为指针, 如 <code>int foo(int *pval).</code>在 C++ 中, 函数还可以声明为引用参数:<code>int foo(int &amp;val).</code></p>
<p><strong>优点</strong></p>
<p>  <strong>定义引用参数可以防止出现<code>(*pval)++</code> 这样丑陋的代码.</strong> 引用参数对于拷贝构造函数这样的应用也是必需的. <strong>同时也更明确地不接受空指针.</strong></p>
<p><strong>缺点</strong></p>
<p>  容易引起误解, 因为引用在语法上是值变量却拥有指针的语义.</p>
<p><strong>结论</strong></p>
<p>  函数参数列表中, 所有引用参数都必须是 const:</p>
<p><code>void Foo(const string &amp;in, string *out);</code><br>
  事实上这在 Google Code 是一个硬性约定: 输入参数是值参或 const 引用, 输出参数为指针. 输入参数可以是 const 指针, 但<strong>决不能是非 const 的引用参数, 除非特殊要求, 比如 swap().</strong></p>
<p><em><em>有时候, 在输入形参中用 const T</em> 指针比 const T&amp; 更明智.</em>* 比如:</p>
<ol>
<li><strong>可能会传递空指针</strong>.</li>
<li>函数要把指针或<strong>对地址的引用</strong>赋值给输入形参.<br>
  总而言之, 大多时候输入形参往往是 const T&amp;. 若用 const T* 则说明输入另有处理. 所以若要使用 const T*, 则应给出相应的理由, 否则会使得读者感到迷惑.</li>
</ol>
<h3 id="44-函数重载">4.4. 函数重载</h3>
<p><strong>总述</strong></p>
<p>  若要使用函数重载, 则必须能让读者一看调用点就胸有成竹, 而不用花心思猜测调用的重载函数到底是哪一种. 这一规则也适用于构造函数.</p>
<p><strong>定义</strong></p>
<p>  你可以编写一个参数类型为 const string&amp; 的函数, 然后用另一个参数类型为 const char* 的函数对其进行重载:</p>
<pre><code>class MyClass {
    public:
    void Analyze(const string &amp;text);
    void Analyze(const char *text, size_t textlen);
};
</code></pre>
<p><strong>优点</strong></p>
<p>  通过重载参数不同的同名函数, 可以令代码更加直观. 模板化代码需要重载, 这同时也能为使用者带来便利.</p>
<p><strong>缺点</strong></p>
<p>  如果函数单靠不同的参数类型而重载 (acgtyrant 注：这意味着参数数量不变), 读者就得十分熟悉 C++ 五花八门的匹配规则, 以了解匹配过程具体到底如何. 另外, 如果派生类只重载了某个函数的部分变体, 继承语义就容易令人困惑.</p>
<p><strong>结论</strong></p>
<p>  <strong>如果打算重载一个函数, 可以试试改在函数名里加上参数信息</strong>. 例如, 用 AppendString() 和 AppendInt() 等, 而不是一口气重载多个 Append(). 如果重载函数的目的是为了支持不同数量的同一类型参数, 则优先考虑使用 std::vector 以便使用者可以用 列表初始化 指定参数.</p>
<h3 id="45-缺省参数">4.5. 缺省参数</h3>
<p><strong>总述</strong></p>
<p>  <strong>只允许在非虚函数中使用缺省参数, 且必须保证缺省参数的值始终一致</strong>. 缺省参数与 函数重载 遵循同样的规则. <strong>一般情况下建议使用函数重载</strong>, <strong>尤其是在缺省函数带来的可读性提升不能弥补下文中所提到的缺点的情况下.</strong></p>
<p><strong>优点</strong></p>
<p>  有些函数一般情况下使用默认参数, 但有时需要又使用非默认的参数. 缺省参数为这样的情形提供了便利, 使程序员不需要为了极少的例外情况编写大量的函数. 和函数重载相比, 缺省参数的语法更简洁明了, 减少了大量的样板代码, 也更好地区别了 “必要参数” 和 “可选参数”.</p>
<p><strong>缺点</strong></p>
<p>  <strong>缺省参数实际上是函数重载语义的另一种实现方式, 因此所有 不应当使用函数重载的理由 也都适用于缺省参数.</strong></p>
<p>  <strong>虚函数调用的缺省参数取决于目标对象的静态类型</strong>, 此时无法保证给定函数的所有重载声明的都是同样的缺省参数.</p>
<p>  <strong>缺省参数是在每个调用点都要进行重新求值的, 这会造成生成的代码迅速膨胀</strong>（像 void f(int n = counter++); 这样的代码.）. 作为读者, 一般来说也更希望缺省的参数在声明时就已经被固定了, 而不是在每次调用时都可能会有不同的取值.</p>
<p>  <strong>缺省参数会干扰函数指针, 导致函数签名与调用点的签名不一致</strong>. 而函数重载不会导致这样的问题.</p>
<p><strong>结论</strong></p>
<p>  对于虚函数, 不允许使用缺省参数, 因为在虚函数中缺省参数不一定能正常工作.<strong>如果在每个调用点缺省参数的值都有可能不同, 在这种情况下缺省函数也不允许使用</strong>. (例如, 不要写像 void f(int n = counter++); 这样的代码.)</p>
<p>  在其他情况下, 如果缺省参数对可读性的提升远远超过了以上提及的缺点的话, 可以使用缺省参数. 如果仍有疑惑, 就使用函数重载.</p>
<h3 id="46-函数返回类型后置语法">4.6. 函数返回类型后置语法</h3>
<p><strong>总述</strong></p>
<p>  只有在常规写法 (返回类型前置) 不便于书写或不便于阅读时使用返回类型后置语法.</p>
<p><strong>定义</strong></p>
<p>  C++ 现在允许两种不同的函数声明方式. 以往的写法是将返回类型置于函数名之前. 例如:</p>
<pre><code>int foo(int x);
</code></pre>
<p>  C++11 引入了这一新的形式. 现在可以在函数名前使用 auto 关键字, 在参数列表之后后置返回类型. 例如:</p>
<pre><code>auto foo(int x) -&gt; int;
</code></pre>
<p>  后置返回类型为函数作用域. 对于像 int 这样简单的类型, 两种写法没有区别. 但对于复杂的情况, 例如类域中的类型声明或者以函数参数的形式书写的类型, 写法的不同会造成区别.</p>
<p><strong>优点</strong></p>
<p>  <strong>后置返回类型是显式地指定 Lambda 表达式 的返回值的唯一方式</strong>. 某些情况下, 编译器可以自动推导出 Lambda 表达式的返回类型, 但并不是在所有的情况下都能实现. 即使编译器能够自动推导, 显式地指定返回类型也能让读者更明了.</p>
<p>  <strong>有时在已经出现了的函数参数列表之后指定返回类型</strong>, 能够让书写更简单, 也更易读,<strong>尤其是在返回类型依赖于模板参数时</strong>. 例如:</p>
<pre><code>template &lt;class T, class U&gt; auto add(T t, U u) -&gt; decltype(t + u);
</code></pre>
<p>对比下面的例子:</p>
<pre><code>template &lt;class T, class U&gt; decltype(declval&lt;T&amp;&gt;() + declval&lt;U&amp;&gt;()) add(T t, U u);
</code></pre>
<p><strong>缺点</strong></p>
<p>  后置返回类型相对来说是非常新的语法, 而且在 C 和 Java 中都没有相似的写法, 因此可能对读者来说比较陌生.</p>
<p>  在已有的代码中有大量的函数声明, 你不可能把它们都用新的语法重写一遍. 因此实际的做法只能是使用旧的语法或者新旧混用. 在这种情况下, 只使用一种版本是相对来说更规整的形式.</p>
<p><strong>结论</strong></p>
<p>  在大部分情况下, 应当继续使用以往的函数声明写法, 即将返回类型置于函数名前. <strong>只有在必需的时候 (如 Lambda 表达式) 或者使用后置语法能够简化书写并且提高易读性的时候才使用新的返回类型后置语法</strong>. 但是后一种情况一般来说是很少见的, 大部分时候都出现在相当复杂的模板代码中, 而多数情况下不鼓励写这样 复杂的模板代码.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 143. 重排链表[中等]]]></title>
        <id>https://lixin-scut.github.io//post/lian-biao-143-chong-pai-lian-biao-zhong-deng</id>
        <link href="https://lixin-scut.github.io//post/lian-biao-143-chong-pai-lian-biao-zhong-deng">
        </link>
        <updated>2020-04-27T11:01:21.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ，<br>
将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…<br>
你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。<br>
示例 1:<br>
给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.<br>
示例 2:<br>
给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/reorder-list<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题是在面试的时候遇到的<br>
一开始只用了暴力法，提出了递归法，面试官提示可以用链表的惯常处理方法<br>
我首先想到的就是双指针和中点处理，继而根据插入节点的顺序想起链表反转，最后再进行链表合并集合<br>
刚好融合了三个独立的链表处理方法，确实是非常好的面试题</p>
<p>需要注意的方法：</p>
<ol>
<li>中点函数需要判断空链表，因为slow=head等于走了一步，fast必须相应fast=head-&gt;next</li>
<li>中点的位置很重要！因为有奇偶数的区别，并且我做了优化，切断了middle后的节点，防止后面的combine的时候造成list1直接跑到list2那里。</li>
<li>反转链表需要把pre_node初始化为nullptr，然后返回值也是pre_node</li>
<li>combine的时候需要一个虚头节点。</li>
</ol>
<pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void reorderList(ListNode* head) 
    {
        ListNode* middle = FindMiddle(head);
        middle = Reverse(middle);
        head = CombineList(head, middle);     
    }


    ListNode* FindMiddle(ListNode* head)
    {
        if(head == nullptr)
        {   return head; }
        
        ListNode* fast = head-&gt;next;
        ListNode* slow = head; 
        while(fast != nullptr &amp;&amp; fast-&gt;next != nullptr)
        {
            slow = slow-&gt;next;
            fast = fast-&gt;next-&gt;next;
        }
        ListNode*  ret = slow-&gt;next;
        slow-&gt;next = nullptr;
        return ret;
    }

    ListNode* Reverse(ListNode* head)
    {
        ListNode* pre_node = nullptr;
        ListNode* cur_node = head;
        ListNode* next_node = nullptr;
        while(cur_node != nullptr)
        {
            next_node = cur_node-&gt;next;
            cur_node-&gt;next = pre_node;
            pre_node = cur_node;
            cur_node = next_node;
        }
        return pre_node;
    }

    ListNode* CombineList(ListNode* list1, ListNode* list2)
    {
        ListNode* head = new ListNode(0);
        ListNode* cur = head;
        while(list1 != nullptr &amp;&amp; list2 != nullptr)
        {
            cur-&gt;next = list1;
            list1 = list1-&gt;next;
            cur = cur-&gt;next;
            
            cur-&gt;next = list2;
            list2 = list2-&gt;next;
            cur = cur-&gt;next;
        }
        
        cur-&gt;next = list1 == nullptr ? list2 : list1;
        return head-&gt;next;
    }

};
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>解法一 存储<br>
链表的缺点就是不能随机存储，当我们想取末尾元素的时候，只能从头遍历一遍，很耗费时间。第二次取末尾元素的时候，又得遍历一遍。<br>
所以先来个简单粗暴的想法，把链表存储到线性表中，然后用双指针依次从头尾取元素即可。</p>
</blockquote>
<pre><code>public void reorderList(ListNode head) {
    if (head == null) {
        return;
    }
    //存到 list 中去
    List&lt;ListNode&gt; list = new ArrayList&lt;&gt;();
    while (head != null) {
        list.add(head);
        head = head.next;
    }
    //头尾指针依次取元素
    int i = 0, j = list.size() - 1;
    while (i &lt; j) {
        list.get(i).next = list.get(j);
        i++;
        //偶数个节点的情况，会提前相遇
        if (i == j) {
            break;
        }
        list.get(j).next = list.get(i);
        j--;
    }
    list.get(i).next = null;
}
</code></pre>
<blockquote>
<p>解法二 递归<br>
参考 这里。<br>
解法一中也说到了，我们的问题就是取尾元素的时候，需要遍历一遍链表。<br>
如果我们的递归函数能够返回当前头元素对应的尾元素，并且将头元素和尾元素之间的链表按要求完成，那就变得简单了。<br>
我们只需要将 head 指向 tail，tail 指向处理完的链表头即可。															然后我们把之前的 tail.next 返回就是外层 head 对应的 tail 了。<br>
递归出口的话，如果只有一个节点，那么我们只需要将 head.next 返回。</p>
</blockquote>
<pre><code>if (len == 1) {
    ListNode outTail = head.next;
    head.next = null;
    return outTail;
}
</code></pre>
<blockquote>
<p>如果是两个节点，我们需要将 head.next.next 返回。</p>
</blockquote>
<pre><code>if (len == 2) {
    ListNode outTail = head.next.next;
    head.next.next = null;
    return outTail;
}
</code></pre>
<blockquote>
<p>然后总体的代码就是下边的样子</p>
</blockquote>
<pre><code>public void reorderList(ListNode head) {

    if (head == null || head.next == null || head.next.next == null) {
        return;
    }
    int len = 0;
    ListNode h = head;
    //求出节点数
    while (h != null) {
        len++;
        h = h.next;
    }

    reorderListHelper(head, len);
}

private ListNode reorderListHelper(ListNode head, int len) {
    if (len == 1) {
        ListNode outTail = head.next;
        head.next = null;
        return outTail;
    }
    if (len == 2) {
        ListNode outTail = head.next.next;
        head.next.next = null;
        return outTail;
    }
    //得到对应的尾节点，并且将头结点和尾节点之间的链表通过递归处理
    ListNode tail = reorderListHelper(head.next, len - 2);
    ListNode subHead = head.next;//中间链表的头结点
    head.next = tail;
    ListNode outTail = tail.next;  //上一层 head 对应的 tail
    tail.next = subHead;
    return outTail;
}
</code></pre>
<blockquote>
<p>解法三<br>
参考 这里，主要是利用到一头一尾取元素的特性。<br>
主要是三步，举个例子。<br>
1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6<br>
第一步，将链表平均分成两半<br>
1 -&gt; 2 -&gt; 3<br>
4 -&gt; 5 -&gt; 6<br>
第二步，将第二个链表逆序<br>
1 -&gt; 2 -&gt; 3<br>
6 -&gt; 5 -&gt; 4<br>
第三步，依次连接两个链表<br>
1 -&gt; 6 -&gt; 2 -&gt; 5 -&gt; 3 -&gt; 4<br>
第一步找中点的话，可以应用 19 题 的方法，快慢指针。快指针一次走两步，慢指针一次走一步，当快指针走到终点的话，慢指针会刚好到中点。如果节点个数是偶数的话，slow 走到的是左端点，利用这一点，我们可以把奇数和偶数的情况合并，不需要分开考虑。<br>
第二步链表逆序的话，在 第 2 题 讨论过了，有迭代和递归的两种方式，迭代的话主要利用两个指针，依次逆转。<br>
第三步的话就很简单了，两个指针分别向后移动就可以。</p>
</blockquote>
<pre><code>public void reorderList(ListNode head) {
    if (head == null || head.next == null || head.next.next == null) {
        return;
    }
    //找中点，链表分成两个
    ListNode slow = head;
    ListNode fast = head;
    while (fast.next != null &amp;&amp; fast.next.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }

    ListNode newHead = slow.next;
    slow.next = null;
    
    //第二个链表倒置
    newHead = reverseList(newHead);
    
    //链表节点依次连接
    while (newHead != null) {
        ListNode temp = newHead.next;
        newHead.next = head.next;
        head.next = newHead;
        head = newHead.next;
        newHead = temp;
    }

}

private ListNode reverseList(ListNode head) {
    if (head == null) {
        return null;
    }
    ListNode tail = head;
    head = head.next;

    tail.next = null;

    while (head != null) {
        ListNode temp = head.next;
        head.next = tail;
        tail = head;
        head = temp;
    }

    return tail;
}
</code></pre>
]]></content>
    </entry>
</feed>