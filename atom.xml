<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2020-02-08T23:45:36.423Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[数组 题11:旋转数组的最小数字]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-ti-11xuan-zhuan-shu-zu-de-zui-xiao-shu-zi</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-ti-11xuan-zhuan-shu-zu-de-zui-xiao-shu-zi">
        </link>
        <updated>2020-02-08T16:01:59.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>
输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>
例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
</blockquote>
<p>一定要注意right=mid和left=mid，不能用mid+1或者mid-1，因为有可能临界点两个数字在mid那里，然后注意题目那里没说明数字会重复，所以需要判断是否三者相等再相应缩减范围</p>
<pre><code>class Solution {
public:
    int minNumberInRotateArray(vector&lt;int&gt; rotateArray) {
        if(rotateArray.empty())
            return 0;
        int left=0;
        int right=rotateArray.size()-1;
        while(left&lt;right-1){
            int mid=left+(right-left)/2;
            while(rotateArray[mid]==rotateArray[right]&amp;&amp;
                 rotateArray[mid]==rotateArray[left])
                ++left,--right;
            if(rotateArray[left]&gt;rotateArray[mid])
                right=mid;
            else if(rotateArray[mid]&gt;rotateArray[right])
                left=mid;
            else
                return rotateArray[left];
        }
        return rotateArray[right];
    }
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>这道题最直观的解法并不难，从头到尾遍历数组一次，我们就能找出 最小的元素。这种思路的时间复杂度显然是O(n)。但是这种思路没有利用输入的旋转数组的特性<br>
和二分查找法一样，我们用两个指针分别指向数组的第一个元素和最 后一个元素。按照题目中旋转的规则，第一个元素应该是大于或者等于最 后一个元素的(这其实不完全对，还有特例，后面再加以讨论)。<br>
如果中间元素位于后面的递增子数组，那么它应该小于或者等 于第二个指针指向的元素。此时该数组中最小的元素应该位于该中间元素 的前面。<br>
不管是移动第一个指针还是第二个指针，查找范围都会缩小到原来的 一半。接下来我们再用更新之后的两个指针重复做新一轮的查找。<br>
按照上述思路，第一个指针总是指向前面递增数组的元素，而第二个 指针总是指向后面递增数组的元素。最终第一个指针将指向前面子数组的 最后一个元素，而第二个指针会指向后面子数组的第一个元素。也就是它 们最终会指向两个相邻的元素，而第二个指针指向的刚好是最小的元素。 这就是循环结束的条件。<br>
最后两个指针的距离是1,表明第一个指针已经指向第一个递增子数组 的末尾，而第二个指针指向第二个递增子数组的开头。第二个子数组的 第一个数字就是最小的数字，因此第二个指针指向的数字就是我们查找 的结果。<br>
当然需要再仔细分析下标为indexI和index2 （index 1和index2分别与图2.13中 Pi和P2相对应）的两个数相同的情况。当两个指针指向的数字及它们中间的数字三者相同 的时候，我们无法判断中间的数字是位于前面的子数组还是后面的子数组, 也就无法移动两个指针来缩小查找的范围。此时，我们不得不采用顺序查 找的方法。</p>
</blockquote>
<pre><code>int Min(int* numbers, int length)
{
    if(numbers == nullptr || length &lt;= 0)
        throw new std::exception(&quot;Invalid parameters&quot;);
 
    int index1 = 0;
    int index2 = length - 1;
    int indexMid = index1;
    while(numbers[index1] &gt;= numbers[index2])
    {
        // 如果index1和index2指向相邻的两个数，
        // 则index1指向第一个递增子数组的最后一个数字，
        // index2指向第二个子数组的第一个数字，也就是数组中的最小数字
        if(index2 - index1 == 1)
        {
            indexMid = index2;
            break;
        }
 
        // 如果下标为index1、index2和indexMid指向的三个数字相等，
        // 则只能顺序查找
        indexMid = (index1 + index2) / 2;
        if(numbers[index1] == numbers[index2] &amp;&amp; numbers[indexMid] == numbers[index1])
            return MinInOrder(numbers, index1, index2);

        // 缩小查找范围
        if(numbers[indexMid] &gt;= numbers[index1])
            index1 = indexMid;
        else if(numbers[indexMid] &lt;= numbers[index2])
            index2 = indexMid;
    }
 
    return numbers[indexMid];
}

int MinInOrder(int* numbers, int index1, int index2)
{
    int result = numbers[index1];
    for(int i = index1 + 1; i &lt;= index2; ++i)
    {
        if(result &gt; numbers[i])
            result = numbers[i];
    }

    return result;
}
</code></pre>
<p>注意如果第一个就是最小数字的话不如进入while循环<br>
然后两指针相同的情况是leetcode处理得更好</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 题10:斐波那契数列-台阶-变态跳台阶]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-ti-10fei-bo-na-qi-shu-lie</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-ti-10fei-bo-na-qi-shu-lie">
        </link>
        <updated>2020-02-08T00:49:45.000Z</updated>
        <content type="html"><![CDATA[<h2 id="斐波那契数列">斐波那契数列</h2>
<blockquote>
<p>题目描述<br>
大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。<br>
n&lt;=39</p>
</blockquote>
<p>没什么特别的，主要就是暂时变量的选择有两种，一定要把握好</p>
<pre><code>class Solution {
public:
    /*
    //动态规划
    int Fibonacci(int n){
        if(n&lt;=0)
            return 0;
        vector&lt;int&gt; res(n,1);
        for(int i=2;i&lt;n;++i)
            res[i]=res[i-1]+res[i-2];
        return res.back();
    }
    */
    /*
    //暂时变量版
    int Fibonacci(int n) {
        if(n&lt;=0)
            return 0;
        if(n==1||n==2)
            return 1;
        int cur,pre,i;
        cur=1;
        pre=1;
        i=3;
        while(i&lt;=n)
        {
            int temp=cur;
            cur+=pre;
            pre=temp;
            ++i;
        }
        return cur;
        
    }
    */
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>我们的教科书上反复用这个问题来讲解递归函数，并不能说明递归的 解法最适合这道题目。我们不难发现，在递归过程中有很多节点是重复的，而且重复的节点数会随着n的增大而急剧增加，这意味着计算量会随着n的增大而急剧增大。<br>
想办法避免重复计算就行了.比如我们可以把己经得到 的数列中间项保存起来，在下次需要计算的时候我们先杳找一下，如果前 面已经计算过就不用再重复计算了。<br>
更简单的办法是从下往上计算，首先根据f(0)和f(1)算出f(2),再根据 f(1)和f(2)算出f(3)……以此类推就可以算出第n项了。很容易理解，这种思路的时间复杂度是O(n)。<br>
用不同的方法求解斐波那契数列的时间效率大不相同。第一种基于递归的解法虽然直观但时间效率很低，在实际软件开发中不会用这种方法， 也不可能得到面试官的青睐。第二种方法把递归的算法用循环实现，极大地提高了时间效率。第三种方法把求斐波那契数列转换成求矩阵的乘方， 是一种很有创意的算法。虽然我们可以用O(logn)求得矩阵的n次方，但由于隐含的时间常数较大，很少会有软件采用这种算法。另外，实现这种解法的代码也很复杂，不太适合面试。因此第三种方法不是一种实用的算法, 不过应聘者可以用它来展示自己的知识面。</p>
</blockquote>
<pre><code>// ====================方法1：递归====================
long long Fibonacci_Solution1(unsigned int n)
{
    if(n &lt;= 0)
        return 0;

    if(n == 1)
        return 1;

    return Fibonacci_Solution1(n - 1) + Fibonacci_Solution1(n - 2);
}

// ====================方法2：循环====================
long long Fibonacci_Solution2(unsigned n)
{
    int result[2] = {0, 1};
    if(n &lt; 2)
        return result[n];

    long long  fibNMinusOne = 1;
    long long  fibNMinusTwo = 0;
    long long  fibN = 0;
    for(unsigned int i = 2; i &lt;= n; ++ i)
    {
        fibN = fibNMinusOne + fibNMinusTwo;

        fibNMinusTwo = fibNMinusOne;
        fibNMinusOne = fibN;
    }

     return fibN;
}

// ====================方法3：基于矩阵乘法====================
#include &lt;cassert&gt;

struct Matrix2By2
{
    Matrix2By2
    (
        long long m00 = 0, 
        long long m01 = 0, 
        long long m10 = 0, 
        long long m11 = 0
    )
    :m_00(m00), m_01(m01), m_10(m10), m_11(m11) 
    {
    }

    long long m_00;
    long long m_01;
    long long m_10;
    long long m_11;
};

Matrix2By2 MatrixMultiply
(
    const Matrix2By2&amp; matrix1, 
    const Matrix2By2&amp; matrix2
)
{
    return Matrix2By2(
        matrix1.m_00 * matrix2.m_00 + matrix1.m_01 * matrix2.m_10,
        matrix1.m_00 * matrix2.m_01 + matrix1.m_01 * matrix2.m_11,
        matrix1.m_10 * matrix2.m_00 + matrix1.m_11 * matrix2.m_10,
        matrix1.m_10 * matrix2.m_01 + matrix1.m_11 * matrix2.m_11);
}

Matrix2By2 MatrixPower(unsigned int n)
{
    assert(n &gt; 0);

    Matrix2By2 matrix;
    if(n == 1)
    {
        matrix = Matrix2By2(1, 1, 1, 0);
    }
    else if(n % 2 == 0)
    {
        matrix = MatrixPower(n / 2);
        matrix = MatrixMultiply(matrix, matrix);
    }
    else if(n % 2 == 1)
    {
        matrix = MatrixPower((n - 1) / 2);
        matrix = MatrixMultiply(matrix, matrix);
        matrix = MatrixMultiply(matrix, Matrix2By2(1, 1, 1, 0));
    }

    return matrix;
}

long long Fibonacci_Solution3(unsigned int n)
{
    int result[2] = {0, 1};
    if(n &lt; 2)
        return result[n];

    Matrix2By2 PowerNMinus2 = MatrixPower(n - 1);
    return PowerNMinus2.m_00;
}

</code></pre>
<h2 id="跳台阶">跳台阶</h2>
<blockquote>
<p>题目描述<br>
一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
</blockquote>
<p>其实就是斐波那契数列的变形，分为数组法和空间优化法</p>
<pre><code>class Solution {
public:
    int jumpFloor(int number) {
        //动态规划法：空间复杂度优化
        if(number&lt;=0) return 0;
        if(number==1) return 1;
        int level_1=1,level_2=1,res;
        for(;number&gt;1;--number){
            res=level_1+level_2;
            level_2=level_1;
            level_1=res;
        }
        return res;
            
        /*
        //动态规划法
        vector&lt;int&gt; count(number+1,1);
        for(int i=2;i&lt;=number;++i)
            count[i]=count[i-2]+count[i-1];
        return count.back();
        */
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>首先我们考虑最简单的情况。如果只有1级台阶，那显然只有一种跳 法。如果有2级台阶，那就有两种跳法：一种是分两次跳，每次跳1级； 另一种就是一次跳2级。<br>
接着我们再来讨论一般情况。我们把n级台阶时的跳法看成n的函数， 记为f(n)。当n&gt;2时，第一次跳的时候就有两种不同的选择：一是第一次只 跳1级，此时跳法数目等于后面剩下的n-1级台阶的跳法数目，即为f(n-1）； 二是第一次跳2级，此时跳法数目等于后面剩下的n-2级台阶的跳法数目， 即为f(n-2）。因此，n级台阶的不同跳法的总数f(n)=f(n-1)+f(n-2)。</p>
</blockquote>
<h2 id="变态跳台阶">变态跳台阶</h2>
<blockquote>
<p>题目描述<br>
一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
</blockquote>
<pre><code>class Solution {
public:
    int jumpFloorII(int number) {
        //就是把前面所有情况加到一起，然后加上自身的一次
        //可以发现规律是比例为2的等比数列求和
        //其实就是 1，2，4，8，16，...
        return pow(2,number-1);
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我的网络库项目-Network Library]]></title>
        <id>https://lixin-scut.github.io//post/wo-de-wang-luo-ku-xiang-mu-network-library</id>
        <link href="https://lixin-scut.github.io//post/wo-de-wang-luo-ku-xiang-mu-network-library">
        </link>
        <updated>2020-02-07T13:05:00.000Z</updated>
        <content type="html"><![CDATA[<p>这里专门存放我的网络库项目大纲<br>
目标是实现一个网络库，能够实现one thread one loop模式的网络服务功能<br>
主要参考的对象为陈硕的muduo。<br>
在这个过程中将之前学习的C++、算法与数据结构、计算机网络、操作系统、UNIX网络编程等知识运用到项目中。</p>
<p>1.准备工作</p>
<p>2.阅读《Linux高性能》和muduo源码、编译和例子测试</p>
<p>3.项目的架构和特点等实现<br>
整理muduo列出的所有重点，通过自己逐点实现代码，并与muduo源码进行比较，分析其中的差异并进行进一步的思考与学习。</p>
<p>1.one thread one loop<br>
线程<br>
一般而言，多线程服务器中的线程可分为以下几类：<br>
IO线程(负责网络IO)<br>
计算线程(负责复杂计算)<br>
第三方库所用线程<br>
本程序中的Log线程属于第三种，其它线程属于IO线程，因为Web静态服务器计算量较小，所以没有分配计算线程，减少跨线程分配的开销，让IO线程兼顾计算任务。除Log线程外，每个线程一个事件循环，遵循One loop per thread。</p>
<p>Reactor并发模型<br>
程序使用Reactor模型，并使用多线程提高并发度。为避免线程频繁创建和销毁带来的开销，使用线程池，在程序的开始创建固定数量的线程。使用epoll作为IO多路复用的实现方式。</p>
<p>MainReactor只有一个，负责响应client的连接请求，并建立连接，它使用一个NIO Selector。在建立连接后用Round Robin的方式分配给某个SubReactor,因为涉及到跨线程任务分配，需要加锁，这里的锁由某个特定线程中的loop创建，只会被该线程和主线程竞争。</p>
<p>SubReactor可以有一个或者多个，每个subReactor都会在一个独立线程中运行，并且维护一个独立的NIO Selector。</p>
<p>当主线程把新连接分配给了某个SubReactor，该线程此时可能正阻塞在多路选择器(epoll)的等待中，怎么得知新连接的到来呢？这里使用了eventfd进行异步唤醒，线程会从epoll_wait中醒来，得到活跃事件，进行处理。</p>
<p>学习muduo库中的runInLoop和queueInLoop的设计方法，这两个方法主要用来执行用户的某个回调函数，queueInLoop是跨进程调用的精髓所在，具有极大的灵活性，我们只需要绑定好回调函数就可以了。</p>
<p>2.RAII机制</p>
<p>智能指针</p>
<p>3.EPOLL<br>
epoll的触发模式在这里我选择了ET模式，muduo使用的是LT，这两者IO处理上有很大的不同。ET模式要比LE复杂许多，它对用户提出了更高的要求，即每次读，必须读到不能再读(出现EAGAIN)，每次写，写到不能再写(出现EAGAIN)。而LT则简单的多，可以选择也这样做，也可以为编程方便，比如每次只read一次(muduo就是这样做的，这样可以减少系统调用次数)。</p>
<p>4.定时器<br>
每个SubReactor持有一个定时器，用于处理超时请求和长时间不活跃的连接。muduo中介绍了时间轮的实现和用stl里set的实现，这里我的实现直接使用了stl里的priority_queue，底层是小根堆，并采用惰性删除的方式，时间的到来不会唤醒线程，而是每次循环的最后进行检查，如果超时了再删，因为这里对超时的要求并不会很高，如果此时线程忙，那么检查时间队列的间隔也会短，如果不忙，也给了超时请求更长的等待时间。</p>
<p>5.缓冲区设置<br>
6.如何优雅地关闭连接<br>
7.round robin<br>
8.reactor</p>
<p>10.log日志<br>
Log的实现了学习了muduo，Log的实现分为前端和后端，前端往后端写，后端往磁盘写。为什么要这样区分前端和后端呢？因为只要涉及到IO，无论是网络IO还是磁盘IO，肯定是慢的，慢就会影响其它操作，必须让它快才行。</p>
<p>这里的Log前端是前面所述的IO线程，负责产生log，后端是Log线程，设计了多个缓冲区，负责收集前端产生的log，集中往磁盘写。这样，Log写到后端是没有障碍的，把慢的动作交给后端去做好了。</p>
<p>后端主要是由多个缓冲区构成的，集满了或者时间到了就向文件写一次。采用了muduo介绍了“双缓冲区”的思想，实际采用4个多的缓冲区(为什么说多呢？为什么4个可能不够用啊，要有备无患)。4个缓冲区分两组，每组的两个一个主要的，另一个防止第一个写满了没地方写，写满或者时间到了就和另外两个交换指针，然后把满的往文件里写。</p>
<p>与Log相关的类包括FileUtil、LogFile、AsyncLogging、LogStream、Logging。 其中前4个类每一个类都含有一个append函数，Log的设计也是主要围绕这个append函数展开的。</p>
<p>FileUtil是最底层的文件类，封装了Log文件的打开、写入并在类析构的时候关闭文件，底层使用了标准IO，该append函数直接向文件写。<br>
LogFile进一步封装了FileUtil，并设置了一个循环次数，每过这么多次就flush一次。<br>
AsyncLogging是核心，它负责启动一个log线程，专门用来将log写入LogFile，应用了“双缓冲技术”，其实有4个以上的缓冲区，但思想是一样的。AsyncLogging负责(定时到或被填满时)将缓冲区中的数据写入LogFile中。<br>
LogStream主要用来格式化输出，重载了&lt;&lt;运算符，同时也有自己的一块缓冲区，这里缓冲区的存在是为了缓存一行，把多个&lt;&lt;的结果连成一块。<br>
Logging是对外接口，Logging类内涵一个LogStream对象，主要是为了每次打log的时候在log之前和之后加上固定的格式化的信息，比如打log的行、文件名等信息。</p>
<p>11.核心结构<br>
程序中的每一个类和结构体当然都必不可少，其中能体现并发模型和整体架构的，我认为是有两个：</p>
<p>Channel类：Channel是Reactor结构中的“事件”，它自始至终都属于一个EventLoop，负责一个文件描述符的IO事件，在Channel类中保存这IO事件的类型以及对应的回调函数，当IO事件发生时，最终会调用到Channel类中的回调函数。因此，程序中所有带有读写时间的对象都会和一个Channel关联，包括loop中的eventfd，listenfd，HttpData等。<br>
EventLoop：One loop per thread意味着每个线程只能有一个EventLoop对象，EventLoop即是时间循环，每次从poller里拿活跃事件，并给到Channel里分发处理。EventLoop中的loop函数会在最底层(Thread)中被真正调用，开始无限的循环，直到某一轮的检查到退出状态后从底层一层一层的退出。</p>
<p>思考问题：<br>
网络库的io模型是怎么样的，为什么这个io模型是高性能的？<br>
muduo的多线程体现在什么地方？<br>
muduo的主线程accepte的fd如何分发给其他线程？<br>
muduo的定时器如何实现？<br>
muduo如何限制连接的数量？<br>
muduo如何设计buffer？<br>
muduo的定时器是如何设计的？<br>
如何安全的关闭tcp连接，能不能直接close，如何直接close会发生什么？<br>
muduo是如何 线程安全的对 对象的声明周期进行管理？</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[队列 题9:用两个栈实现队列]]></title>
        <id>https://lixin-scut.github.io//post/dui-lie-ti-9yong-liang-ge-zhan-shi-xian-dui-lie</id>
        <link href="https://lixin-scut.github.io//post/dui-lie-ti-9yong-liang-ge-zhan-shi-xian-dui-lie">
        </link>
        <updated>2020-02-07T03:33:50.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
</blockquote>
<pre><code>class Solution
{
public:
    void push(int node) {
        stack1.push(node);
    }

    int pop() {
        if(stack2.empty()){
            while(stack1.size()){
                stack2.push(stack1.top());
                stack1.pop();
            }
        }
				//补充
				 if(stack2.empty())
					 throw new exception(&quot;queue is empty&quot;);
					 
        int res=stack2.top();
        stack2.pop();
        return res;
    }

private:
    stack&lt;int&gt; stack1;
    stack&lt;int&gt; stack2;
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>1插入一个元素,先把它插入stack<br>
2删除一个元素的步骤：当stack2不为空时，在stack2中的栈顶元素是最先进入队列的元素，可以弹出。当stack2 为空时，我们把stack1中的元素逐个弹出并压入stack2。由于先进入队列的元素被压到stackl的底端，经过弹出和压入操作之后就处于stack2的顶端, 又可以直接弹出。</p>
</blockquote>
<pre><code>template &lt;typename T&gt; class CQueue
{
public:
    CQueue(void);
    ~CQueue(void);
    
    // 在队列末尾添加一个结点
    void appendTail(const T&amp; node);

    // 删除队列的头结点
    T deleteHead();

private:
    stack&lt;T&gt; stack1;
    stack&lt;T&gt; stack2;
};

template &lt;typename T&gt; CQueue&lt;T&gt;::CQueue(void)
{
}

template &lt;typename T&gt; CQueue&lt;T&gt;::~CQueue(void)
{
}

template&lt;typename T&gt; void CQueue&lt;T&gt;::appendTail(const T&amp; element)
{
    stack1.push(element);
} 

template&lt;typename T&gt; T CQueue&lt;T&gt;::deleteHead()
{
    if(stack2.size()&lt;= 0)
    {
        while(stack1.size()&gt;0)
        {
            T&amp; data = stack1.top();
            stack1.pop();
            stack2.push(data);
        }
    }

    if(stack2.size() == 0)
        throw new exception(&quot;queue is empty&quot;);

    T head = stack2.top();
    stack2.pop();

    return head;
}
</code></pre>
<p>注意我的代码中存在鲁棒性不强的问题，在判断stack2为空之后可能stack1还是可能为空，所以需要再次检查一次stack2是否为空</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 题8:二叉树的下一个节点]]></title>
        <id>https://lixin-scut.github.io//post/shu-ti-8er-cha-shu-de-xia-yi-ge-jie-dian</id>
        <link href="https://lixin-scut.github.io//post/shu-ti-8er-cha-shu-de-xia-yi-ge-jie-dian">
        </link>
        <updated>2020-02-05T10:36:13.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
</blockquote>
<p>主要是要注意我把两种情况合在一起计算了，一是 目标节点是其父节点的左子节点，二是 目标是其父节点的右子节点。循环的条件很重要，本来我用的是判断当前节点和父节点的关系，但是后来发现要先判断父节点是否为空，就改了，最后的判断也相应地需要修改</p>
<pre><code>class Solution {
public:
    TreeLinkNode* GetNext(TreeLinkNode* pNode)
    {
        TreeLinkNode *cur;
        if(pNode-&gt;right!=NULL){
            cur=pNode-&gt;right;
            while(cur-&gt;left!=NULL)
                cur=cur-&gt;left;
            return cur;
        }
        cur=pNode;
        while(cur-&gt;next!=NULL)
            if(cur!=cur-&gt;next-&gt;left)
                cur=cur-&gt;next;
            else
                break;
        if(cur-&gt;next!=NULL)
            return cur-&gt;next;
        return NULL;
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>1.如果一个节点有右了树，那么它的下一个节点就是它的右子树中的最 左子节点。<br>
2.一个节点没有右子树的情形：<br>
a.如果节点是它父节点的左子节点，那么它的下一个节点就是它的父节点。<br>
b.如果一个节点既没有右子树，并且它还是它父节点的右子节点，那么 这种情形就比较复杂。我们可以沿着指向父节点的指针一直向上遍历，直 到找到一个是它父节点的左子节点的节点。如果这样的节点存在，那么这 个节点的父节点就是我们要找的下一个节点。</p>
</blockquote>
<pre><code>struct BinaryTreeNode
{
    int                    m_nValue;
    BinaryTreeNode*        m_pLeft;
    BinaryTreeNode*        m_pRight;
    BinaryTreeNode*        m_pParent;
};

BinaryTreeNode* GetNext(BinaryTreeNode* pNode)
{
    if(pNode == nullptr)
        return nullptr;

    BinaryTreeNode* pNext = nullptr;
    if(pNode-&gt;m_pRight != nullptr)
    {
        BinaryTreeNode* pRight = pNode-&gt;m_pRight;
        while(pRight-&gt;m_pLeft != nullptr)
            pRight = pRight-&gt;m_pLeft;

        pNext = pRight;
    }
    else if(pNode-&gt;m_pParent != nullptr)
    {
        BinaryTreeNode* pCurrent = pNode;
        BinaryTreeNode* pParent = pNode-&gt;m_pParent;
        while(pParent != nullptr &amp;&amp; pCurrent == pParent-&gt;m_pRight)
        {
            pCurrent = pParent;
            pParent = pParent-&gt;m_pParent;
        }

        pNext = pParent;
    }

    return pNext;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 题7:重建二叉树[未做出][待阅读]]]></title>
        <id>https://lixin-scut.github.io//post/shu-ti-7chong-jian-er-cha-shu-wei-zuo-chu-dai-yue-du</id>
        <link href="https://lixin-scut.github.io//post/shu-ti-7chong-jian-er-cha-shu-wei-zuo-chu-dai-yue-du">
        </link>
        <updated>2020-02-05T01:13:45.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回</p>
</blockquote>
<p>这道题的要点主要在于前序遍历和中序遍历的要点关联，难点在于两个数组的范围是不一致的，所以必须要两对下标（或者两对迭代器）来处理<br>
然后在迭代的时候需要中间变量来处理好在两个数组中左右子树的节点范围变化</p>
<pre><code>class Solution {
public:
    //TreeNode* buildTree(vector&lt;int&gt; &amp;pre,int pre_beg,int pre_end,vector&lt;int&gt; &amp;vin,int vin_beg,int vin_end);
    TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) {
        if(pre.empty()||vin.empty())
            return NULL;
        return buildTree(pre,0,pre.size()-1,vin,0,vin.size()-1);
    }
    
    TreeNode* buildTree(vector&lt;int&gt; &amp;pre,int pre_beg,int pre_end,vector&lt;int&gt; &amp;vin,int vin_beg,int vin_end)
    {
        int rootValue=pre[pre_beg];
        TreeNode *cur=new TreeNode(rootValue);
        
        if(pre_beg==pre_end){
            if(vin_beg==vin_end&amp;&amp;pre[pre_beg]==vin[vin_beg])
                return cur;
        }
        int vin_cur;
        for(int i=vin_beg;i&lt;=vin_end;++i)
            if(vin[i]==rootValue){
                vin_cur=i;
                break;
            }
        
        int leftLength=vin_cur-vin_beg;
        int left_pre_end=pre_beg+leftLength;
        if(leftLength&gt;0){
            cur-&gt;left=buildTree(pre,pre_beg+1,left_pre_end,vin,vin_beg,vin_cur-1);
        }
        if(leftLength&lt;pre_end-pre_beg)
            cur-&gt;right=buildTree(pre,left_pre_end+1,pre_end,vin,vin_cur+1,vin_end);
        return cur;
    }
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>在二叉树的前序遍历序列中，第一个数字总是树的根节点的值。但在 中序遍历序列中，根节点的值在序列的中间，左子树的节点的值位于根节 点的值的左边，而右子树的节点的值位于根节点的值的右边。因此我们需 要扫描中序遍历序列，才能找到根节点的值。<br>
我们已经分别找到了左、右子树的前序遍历序列和中序遍历序列, 我们可以用同样的方法分别构建左、右子树。也就是说，接下来的事情可以用递归的方法去完成。</p>
</blockquote>
<pre><code>BinaryTreeNode* Construct(int* preorder, int* inorder, int length)
{
    if(preorder == nullptr || inorder == nullptr || length &lt;= 0)
        return nullptr;

    return ConstructCore(preorder, preorder + length - 1,
        inorder, inorder + length - 1);
}

BinaryTreeNode* ConstructCore
(
    int* startPreorder, int* endPreorder, 
    int* startInorder, int* endInorder
)
{
    // 前序遍历序列的第一个数字是根结点的值
    int rootValue = startPreorder[0];
    BinaryTreeNode* root = new BinaryTreeNode();
    root-&gt;m_nValue = rootValue;
    root-&gt;m_pLeft = root-&gt;m_pRight = nullptr;

    if(startPreorder == endPreorder)
    {
        if(startInorder == endInorder &amp;&amp; *startPreorder == *startInorder)
            return root;
        else
            throw std::exception(&quot;Invalid input.&quot;);
    }

    // 在中序遍历中找到根结点的值
    int* rootInorder = startInorder;
    while(rootInorder &lt;= endInorder &amp;&amp; *rootInorder != rootValue)
        ++ rootInorder;

    if(rootInorder == endInorder &amp;&amp; *rootInorder != rootValue)
        throw std::exception(&quot;Invalid input.&quot;);

    int leftLength = rootInorder - startInorder;
    int* leftPreorderEnd = startPreorder + leftLength;
    if(leftLength &gt; 0)
    {
        // 构建左子树
        root-&gt;m_pLeft = ConstructCore(startPreorder + 1, leftPreorderEnd, 
            startInorder, rootInorder - 1);
    }
    if(leftLength &lt; endPreorder - startPreorder)
    {
        // 构建右子树
        root-&gt;m_pRight = ConstructCore(leftPreorderEnd + 1, endPreorder,
            rootInorder + 1, endInorder);
    }

    return root;
}

</code></pre>
<blockquote>
<p>在函数ConstructCore中，我们先根据前序遍历序列的第一个数字创建 根节点，接卜来在中序遍历序列中找到根节点的位置，这样就能确定左、 右子树节点的数量。在前序遍历和中序遍历序列中划分了左、右子树节点 的值之后，我们就可以递归地调用函数ConstructCore去分别构建它的左、 右子树</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 题6:从尾到头打印链表[未做出]]]></title>
        <id>https://lixin-scut.github.io//post/lian-biao-ti-6cong-wei-dao-tou-da-yin-lian-biao-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/lian-biao-ti-6cong-wei-dao-tou-da-yin-lian-biao-wei-zuo-chu">
        </link>
        <updated>2020-02-04T00:43:41.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p>
</blockquote>
<p>这道题一开始我只想到了deque的push_front和vector强行插入头节点 以及 将链表翻转<br>
但是这三种方式都不是很好，翻转链表还会改变链表的结构，需要和面试官商量<br>
然后看了书之后才发现书的方法是特别简洁而巧妙，所以但看书还是不够的，得老老实实动手</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; printListFromTailToHead(ListNode* head) {
        //【未做出】
        /*
        //首先就是可以用栈存储
        stack&lt;int&gt; node_val;
        ListNode *cur=head;
        vector&lt;int&gt; res;
        while(cur!=NULL){
            node_val.push(cur-&gt;val);
            cur=cur-&gt;next;
        }
        while(node_val.size()){
            res.push_back(node_val.top());
            node_val.pop();
        }
        return res;
        */
        //然后通过栈联想到递归（这个思维很重要，不要仅仅限制于递归到栈）
        vector&lt;int&gt; res;
        if(head==NULL)
            return res;
        add_value(head,res);
        return res;
    }
    
    void add_value(ListNode* cur,vector&lt;int&gt; &amp;res){
        if(cur-&gt;next!=NULL)
            add_value(cur-&gt;next,res);
        res.push_back(cur-&gt;val);
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>解决这个问题肯定是要遍历链表<br>
遍历的顺序是从头到尾，可输出的顺序却是从尾到头。第一个遍历的节点最后一个输出，而最后一个遍历到的节点第一个输出。这就是典型的“后进先出”，我们可以用栈实现这种顺序。</p>
</blockquote>
<pre><code>void PrintListReversingly_Iteratively(ListNode* pHead)
{
    std::stack&lt;ListNode*&gt; nodes;

    ListNode* pNode = pHead;
    while(pNode != nullptr)
    {
        nodes.push(pNode);
        pNode = pNode-&gt;m_pNext;
    }

    while(!nodes.empty())
    {
        pNode = nodes.top();
        printf(&quot;%d\t&quot;, pNode-&gt;m_nValue);
        nodes.pop();
    }
}
</code></pre>
<blockquote>
<p>既然想到了用栈来实现这个函数，而递归在本质上就是一个栈结构， 于是很自然地又想到了用递归来实现。要实现反过来输出链表，我们每访 问到一个节点的时候，先递归输出它后面的节点，再输出该节点自身，这 样链表的输出结果就反过来了。</p>
</blockquote>
<pre><code>void PrintListReversingly_Recursively(ListNode* pHead)
{
    if(pHead != nullptr)
    {
        if (pHead-&gt;m_pNext != nullptr)
        {
            PrintListReversingly_Recursively(pHead-&gt;m_pNext);
        }
 
        printf(&quot;%d\t&quot;, pHead-&gt;m_nValue);
    }
}
</code></pre>
<blockquote>
<p>上面的基于递归的代码看起来很简洁，但有一个问题：当链表非常长的时候，就会导致函数调用的层级很深，从而有可能导致函数调用栈溢出。显然用栈基于循环实现的代码的鲁棒性要好一点。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 题5:替换空格[未做出]]]></title>
        <id>https://lixin-scut.github.io//post/zi-fu-chuan-ti-5ti-huan-kong-ge-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/zi-fu-chuan-ti-5ti-huan-kong-ge-wei-zuo-chu">
        </link>
        <updated>2020-02-03T00:04:40.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
</blockquote>
<p>这道题的难点在于这是个char* ，而不是string，所以不能简单地一次循环把空格直接替换<br>
否则因为是把一个字符换成三个字符，而char* 的空间是固定的，直接空间就炸裂了<br>
所以必须先循环一遍，统计空格的数量，再分配新的空间<br>
为什么返回是void???原来是因为早已安排了额外的空间length...所以不能用sizeof....<br>
提交之后一直没通过，原来是'\0'这个家伙，所以书中的int cur=new_len;而不是int cur=new_len-1;<br>
我有个想法，平时可以将char* 中的'\0'类比string的尾后位置，因为它既不会算入size()，又可以有这个位置（str[end]）</p>
<pre><code>class Solution {
public:
	void replaceSpace(char *str,int length) {
        int ori_len=0;//记得size不会统计'\0'
        int count_space=0;
        int i=0;
        while(str[i]!='\0'){
            ++ori_len;
            if(str[i]==' ')
                ++count_space;
            ++i;
        }
        int new_len=ori_len+2*count_space;
        if(length&lt;=new_len)//注意length参数
            return;
        int cur=new_len;
        int pre=ori_len;//注意！！！这里不可以忽略'\0'这个家伙
        //重点是从后往前降低时间复杂度，不要从前往后
        while(pre&gt;=0&amp;&amp;cur&gt;pre) //注意 不是必须去到pre==0，当cur和pre重合就说明没有空格了，可以提前结束
        {
            if(str[pre]==' '){
                str[cur--]='0';
                str[cur--]='2';
                str[cur--]='%';
            }else
                str[cur--]=str[pre];
            --pre;
        }
	}
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>看到这个题目，我们首先应该想到的是原来一个空格字符，替换之后变成，％、2和0这3个字符，因此字符串会变长。如果是在原来的字符串 上进行替换，就有可能覆盖修改在该字符串后面的内存。如果是创建新的字符串并在新的字符串上进行替换，那么我们可以自己分配足够多的内存。 由于有两种不同的解决方案，我们应该向面试官问清楚，让他明确告诉我们他的需求。<br>
暴力法：<br>
最直观的做法是从头到尾扫描字符 串，每次碰到空格字符的时候进行替换。由于是把1个字符替换成3个字 符，我们必须要把空格后面所有的字符都后移2字节，否则就有两个字符 被覆盖了。<br>
假设字符串的长度是如 对每个空格字符，需要移动后面O(n)个字符, 因此对于含有O(n)个空格字符的字符串而言，总的时间效率是O(n^2)<br>
时间复杂度为O(n)的解法:<br>
先遍历一次字符串，统计出字符串中空格的总数， 并可以由此计算出替换之后的字符串的总长度。<br>
从字符串的后面开始复制和替换。首先准备两个指针：P1和P2。 P1指向原始字符串的末尾，而P2指向替换之后的字符串的末尾。接下来向前移动指针R1,逐个把它指向的字符复制到P2指向的位置，直到碰到第一个空格为止。<br>
碰到第一个空格之后， 把P1向前移动1格，在已之前插入字符串&quot;%20&quot;„由于&quot;％20&quot;的长度为3, 同时也要把P2向前移动3格<br>
当P1和P2指向同一位置，表明所有空格都已经替换完毕。（可以提前终止，不必走完整个字符串）<br>
从上面的分析中我们可以看出，所有的字符都只复制（移动）一次， 因此这个算法的时间效率是O(n),比第一个思路要快。</p>
</blockquote>
<pre><code>/*length 为字符数组str的总容量，大于或等于字符串str的实际长度*/
void ReplaceBlank(char str[], int length)
{
    if(str == nullptr &amp;&amp; length &lt;= 0)
        return;

    /*originalLength 为字符串str的实际长度*/
    int originalLength = 0;
    int numberOfBlank = 0;
    int i = 0;
    while(str[i] != '\0')
    {
        ++ originalLength;

        if(str[i] == ' ')
            ++ numberOfBlank;

        ++ i;
    }

    /*newLength 为把空格替换成'%20'之后的长度*/
    int newLength = originalLength + numberOfBlank * 2;
    if(newLength &gt; length)
        return;

    int indexOfOriginal = originalLength;
    int indexOfNew = newLength;
    while(indexOfOriginal &gt;= 0 &amp;&amp; indexOfNew &gt; indexOfOriginal)
    {
        if(str[indexOfOriginal] == ' ')
        {
            str[indexOfNew --] = '0';
            str[indexOfNew --] = '2';
            str[indexOfNew --] = '%';
        }
        else
        {
            str[indexOfNew --] = str[indexOfOriginal];
        }

        -- indexOfOriginal;
    }
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 题4:二维数组中的查找]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-er-wei-shu-zu-zhong-de-cha-zhao</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-er-wei-shu-zu-zhong-de-cha-zhao">
        </link>
        <updated>2020-02-02T00:59:11.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述<br>
在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<pre><code>class Solution {
public:
    bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) {
        if(array.empty())
               return false;
        int row,col;
        row=array.size();
        col=array[0].size();
        int cur_row,cur_col;
        cur_row=0,cur_col=col-1;
        while(cur_row&lt;row&amp;&amp;cur_col&gt;=0){
            if(target==array[cur_row][cur_col])
                return true;
            if(target&lt;array[cur_row][cur_col])
                --cur_col;
            else 
                ++cur_row;
        }
        return false;
    }
};
</code></pre>
<p>书本题解：<br>
难题是因为我们在二维数组的中间选取一个数字来和要查找的数字进行比较，这就导致下一次要查找的是两个相互重叠的区域。<br>
我们发现如下规律：首先选取数组中右上角的数字。如果该数字等于要查找的数字，则查找过程结束；如果该数字大于要查找的数字，则剔除这个数字所在的列；如果该数字小于要查找的数字, 则剔除这个数字所在的行。也就是说，如果要查找的数字不在数组的右上 角，则每一次都在数组的查找范围中剔除一行或者一列，这样每一步都可 以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。</p>
<pre><code>#include &lt;cstdio&gt;

bool Find(int* matrix, int rows, int columns, int number)
{
    bool found = false;

    if(matrix != nullptr &amp;&amp; rows &gt; 0 &amp;&amp; columns &gt; 0)
    {
        int row = 0;
        int column = columns - 1;
        while(row &lt; rows &amp;&amp; column &gt;=0)
        {
            if(matrix[row * columns + column] == number)
            {
                found = true;
                break;
            }
            else if(matrix[row * columns + column] &gt; number)
                -- column;
            else
                ++ row;
        }
    }

    return found;
}
</code></pre>
<p>我们每次都选取数组查找范围内的右上角数字。同样，我们也可以选取左下角的数字。感兴趣的读者不妨自己分析一下每次 都选取左下角数字的查找过程。但我们不能选择左上角数字或者右下角数字。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 题3:数组中重复的数字[未做出]]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-shu-zu-zhong-chong-fu-de-shu-zi</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-shu-zu-zhong-chong-fu-de-shu-zi">
        </link>
        <updated>2020-02-01T03:26:23.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
</blockquote>
<p>因为数组的条件比较苛刻，所以其实有很多巧妙的解法，不修改原数组的方法是对数字的范围进行二分法，修改原数组的方法是利用数组下表一一对应的方法，上述两者都需要额外的空间，如果有额外的空间的话可以很方便地利用hashset解决问题</p>
<pre><code>class Solution {
public:
    // Parameters:
    //        numbers:     an array of integers
    //        length:      the length of array numbers
    //        duplication: (Output) the duplicated number in the array number
    // Return value:       true if the input is valid, and there are some duplications in the array number
    //                     otherwise false
    //不修改原数组的方法
    bool duplicate(int numbers[], int length, int* duplication){
        if(length==0) return -1;
        int left=0,right=length-1;
        while(left&lt;right){
            int mid=left+(right-left)/2;
            int count=0;
            for(int i=0;i&lt;length;++i)
                if(numbers[i]&gt;=left&amp;&amp;numbers[i]&lt;=mid)
                    ++count;
            if(count&gt;mid-left+1)
                right=mid;
            else
                left=mid+1;
        }
        if(left==right)
            return left;
        return -1;
    }
    
    /*
    //修改原数组的方法
    bool duplicate(int numbers[], int length, int* duplication){
        for(int i=0;i&lt;length;++i){
            while(i!=numbers[i]){
                if(numbers[i]==numbers[numbers[i]])
                    return true;
                swap(numbers[i],numbers[numbers[i]]);
            }
        }
        return false;
    }
    
    //hashset方法
    bool duplicate(int numbers[], int length, int* duplication) {
        unordered_set&lt;int&gt; num_set;
        for(int i=0;i&lt;length;++i){
            if(num_set.count(numbers[i]))
                return true;
            num_set.insert(numbers[i]);
        }
        return false;
    }
    */
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>解决这个问题的一个简单的方法是先把输入的数组排序。从排序的数组中找出重复的数字只需要从头到尾扫描排序后的数组。排序一个长度为n的数组需要O(nlogn)的时间。<br>
还可以利用哈希表来解决这个问题。从头到尾按顺序扫描数组的每个 数字，每扫描到一个数字的时候，都可以用0(1)的时间来判断哈希表里是否已经包含了该数字。如果哈希表里还没有这个数字，就把它加入哈希表。 如果哈希表里已经存在该数字，就找到一个重复的数字。这个算法的时间 复杂度是O(n)，但它提高时间效率是以一个大小为O(n)的哈希表为代价的。<br>
空间复杂度是0(1)的算法：我们注意到数组中的数字都在0〜n-1的范围内。如果这个数组中没有 重复的数字，那么当数组排序之后数字i将出现在下标为i的位置。由于数组中有重复的数字，有些位置可能存在多个数字，同时有些位置可能没有数字。<br>
现在让我们重排这个数组。从头到尾依次扫描这个数组中的每个数字。 当扫描到下标为i的数字时，首先比较这个数字(用〃，表示)是不是等于i. 如果是，则接着扫描下一个数字；如果不是，则再拿它和第加个数字进行 比较。如果它和第彻个数字相等，就找到了一个重复的数字(该数字在下 标为，和m的位置都出现了)；如果它和第m个数字不相等，就把第i个数字和第m个数字交换，把m放到属于它的位置。接下来再重复这个比较、 交换的过程，直到我们发现一个重复的数字。</p>
</blockquote>
<pre><code>bool duplicate(int numbers[], int length, int* duplication)
{
    if(numbers == nullptr || length &lt;= 0)
        return false;

    for(int i = 0; i &lt; length; ++i)
    {
        if(numbers[i] &lt; 0 || numbers[i] &gt; length - 1)
            return false;
    }

    for(int i = 0; i &lt; length; ++i)
    {
        while(numbers[i] != i)
        {
            if(numbers[i] == numbers[numbers[i]])
            {
                *duplication = numbers[i];
                return true;
            }

            // 交换numbers[i]和numbers[numbers[i]]             
            int temp = numbers[i];
            numbers[i] = numbers[temp];
            numbers[temp] = temp;
        }
    }

    return false;
}
</code></pre>
<blockquote>
<p>代码中尽管有一个两重循环，但每个数字最多只要交换两次就能找到 属于它自己的位置，因此总的时间复杂度是O(n).另外，所有的操作步骤 都是在输入数组上进行的，不需要额外分配内存，因此空间复杂度为O(1)。</p>
</blockquote>
<blockquote>
<p>接下来我们尝试避免使用O(n)的辅助空间并且不修改原数组的方法。为什么数组中会有重复的数字？假如没有重复的数字，那么在从1〜〃的范围里只有&quot;个数字。由于 数组里包含超过n个数字，所以一定包含了重复的数字。看起来在某范围 里数字的个数对解决这个问题很重要。<br>
我们把从1〜n的数字从中间的数字m分为两部分，前面一半为1〜m， 后面一半为m+1〜n。如果1〜m的数字的数目超过m,那么这一半的区间 里一定包含重复的数字；否则，另一半m+1〜n的区间里一定包含重复的数 字。我们可以继续把包含重复数字的区间一分为二，直到找到一个重复的 数字。这个过程和二分查找算法很类似，只是多了一步统计区间里数字的数目。<br>
注意是利用某个数字去对比数组中的元素，而不是用数组的元素去对比数字</p>
</blockquote>
<pre><code>int getDuplication(const int* numbers, int length)
{
    if(numbers == nullptr || length &lt;= 0)
        return -1;

    int start = 1;
    int end = length - 1;
    while(end &gt;= start)
    {
        int middle = ((end - start) &gt;&gt; 1) + start;
        int count = countRange(numbers, length, start, middle);
        if(end == start)
        {
            if(count &gt; 1)
                return start;
            else
                break;
        }

        if(count &gt; (middle - start + 1))
            end = middle;
        else
            start = middle + 1;
    }
    return -1;
}

int countRange(const int* numbers, int length, int start, int end)
{
    if(numbers == nullptr)
        return 0;

    int count = 0;
    for(int i = 0; i &lt; length; i++)
        if(numbers[i] &gt;= start &amp;&amp; numbers[i] &lt;= end)
            ++count;
    return count;
}
</code></pre>
<blockquote>
<p>上述代码按照二分查找的思路，如果输入长度为n的数组，那么函数 countRange将被调用O(logn)次，每次需要O(n)的时间，因此总的时间复杂 度是O(nlogn)，空间复杂度为O(1)。和最前面提到的需要O(n)的辅助空间 的算法相比，这种算法相当于以时间换空间。<br>
需要指出的是，这种算法不能保证找出所有重复的数字。</p>
</blockquote>
<blockquote>
<p>从上述分析中我们可以看出，如果面试官提出不同的功能要求(找出任意一个重复的数字、找出所有重复的数字)或者性能要求(时间效率优先、空间效率优先)，那么我们最终选取的算法也将不同。这也说明在面试中和面试官交流的重要性，我们一定要在动手写代码之前弄清楚面试官的需求。</p>
</blockquote>
]]></content>
    </entry>
</feed>