<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-09-05T11:17:30.976Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[ C++ primer 第三章 笔记+习题 3.1-3.4]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-san-zhang-bi-ji-xi-ti-31-24</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-san-zhang-bi-ji-xi-ti-31-24">
        </link>
        <updated>2019-09-05T07:07:06.000Z</updated>
        <content type="html"><![CDATA[<p>3.1<br>
using声明 无须专门的前缀 using std::cin;<br>
每个名字都需要独立的using声明<br>
头文件不应包含using声明 否则会影响到所有使用该头文件的程序<br>
区分using指示和using声明</p>
<p>习题3.1<br>
由于是复习，所以一直有用using声明和using指示hhh<br>
但是必须说明using指示并不是好东西，多处引入using指示容易造成命名域污染</p>
<p>3.2<br>
string 表示可变长的字符序列 头文件 #include <string>  string定义在命名空间std中 最好在文件头加上using std::string <strong>始终要记得string不是内置类型</strong><br>
string empty； 默认初始化为空字符串<br>
string定义字符串末尾不含有空字符，长度不需要+1<br>
string初始化方式 string s1;string s2(s1); string s2 = s1; string s3(“value”); string s(5,’a’) = aaaaa;<br>
初始化的方式： 拷贝初始化 等号= ，直接初始化 括号（），列表初始化 花括号{ }<br>
！！！不一定有括号的就是直接初始化，拷贝初始化也可以用括号<br>
例如 int p(1);//直接初始化  int p1(p2);//拷贝初始化<br>
3.2.2<br>
一个类要定义各种运算符在该类对象上的新含义<br>
使用cin读取string对象时，会自动忽略开头的空白（空格符换行符制表符等） 然后<strong>遇到下一处空白停止读取，所以cin无法读取空格</strong><br>
如果<strong>需要保留输入的空白符，使用getline函数 遇到换行符为止</strong>（注意<strong>换行符也会被读进来，但换行符不会被存进string对象</strong>）<br>
如果输入一开始为换行符 则getline得到空string<br>
empty函数返回布尔值<br>
size函数返回值并非int，<strong>而是一个string::size_type类型的值</strong>，它是一个无符号类型的值unsigned，能够存放下任何string对象的大小<br>
注意size函数调用<strong>必须有括号size（）</strong><br>
所以不能将size函数的返回值<strong>与负值进行比较或其他操作 否则会触发强制转换</strong><br>
string <strong>相加为串接两个运算对象</strong><br>
标准库允许将字符字面值和字符串字面值转化为string对象 但混用时必须保证+加号两侧至少有一个string对象 例子 s = “hello” + “,” + s2 ; 错误 第一个加号无string对象<br>
所以 <strong>字符串字面值并非是string类型 而是array数组</strong></p>
<p>习题3.2</p>
<pre><code>	int main() {
	string s;
	//while (getline(cin, s))
		while(cin&gt;&gt;s)
		cout &lt;&lt; s &lt;&lt; endl;
};
</code></pre>
<p>习题3.3<br>
输入运算符自动忽略开头的空白，并且遇到下一处空白时停止读取，所以无法读取空白，但是getline不同，可以读取空白字符，包括<strong>换行符</strong>，只是读取后抛弃，不存入string中。<br>
习题3.4</p>
<pre><code>int main() {
	string s1,s2;
	cout &lt;&lt; &quot;please input the first one:&quot;;
	getline(cin, s1);
	cout &lt;&lt; &quot;please input anothor one:&quot;;
	getline(cin, s2);
	if (s1 == s2)
		cout &lt;&lt; &quot;they are equal.&quot; &lt;&lt; endl;
	//else if (s1 &gt; s2)
	//	cout &lt;&lt; s1 &lt;&lt; endl;
	//else
	//	cout &lt;&lt; s2 &lt;&lt; endl;
	else if (s1.size() == s2.size()) 
		cout &lt;&lt; &quot;they have same length.&quot; &lt;&lt; endl;
	else if (s1.size() &gt; s2.size()) 
		cout &lt;&lt; s1 &lt;&lt; endl;
	else
		cout &lt;&lt; s2 &lt;&lt; endl;
};
</code></pre>
<pre><code>习题3.5
</code></pre>
<pre><code>	int main() {
	string s,temp;
	cin &gt;&gt; s;
	while (cin &gt;&gt; temp) {
		//s = s + temp;
		s = s + &quot; &quot; + temp;
		cout &lt;&lt; s &lt;&lt;endl;
	}
};
</code></pre>
<p>3.2.3<br>
cctype 头文件中的函数可以用于处理string对象<br>
c中的标准库可以再c++中使用，name.h 变为 cname<br>
处理每个字符 使用基于范围for语句<br>
for (declaration : expression) {statement;} 其中declaration负责定义一个变量用于访问序列中的基础元素，expression为一个循环对象<br>
上述语句可以<strong>配合 auto 和 decltype</strong>来使用 比如 for (auto char1 : string1 )<br>
如果想改变string对象中字符的值，必须把循环变量expression设为<strong>引用类型</strong><br>
只处理一部分字符，使用迭代器或下标运算符[]<br>
string对象的下标<strong>从0计起</strong> s[s.size()-1]为最后一个字符<br>
下标运算符接受的输入参数是string::size_type 会将带符号类型值自动转化为该类型<br>
使用下标运算符前必须检验string对象是否为空 if(!s.empty())</p>
<p>习题3.6</p>
<pre><code>	int main() {
	string s;
	getline(cin,s);
	if (!s.empty())
	for (auto &amp;c : s) {
		c = 'X';
	}
	cout &lt;&lt; s &lt;&lt; endl;
};
</code></pre>
<pre><code>习题3.7
单纯的char是值拷贝传递，无法对原string进行改动，但是char&amp;可以
习题3.8
循环for更好用，操作起来更加方便，避免了while循环条件的寻找和阅读for循环头的复杂性，可读性更高
习题3.9
不合法，必须检查是否为空string 但是是能够正常输出，但size（）等于0
习题3.10
</code></pre>
<pre><code>	int main() {
	string s;
	getline(cin,s);
	if (!s.empty())
		for (char &amp;c : s) {
			if (!ispunct(c))
				cout &lt;&lt; c;
		}
};
</code></pre>
<pre><code>习题3.11
合法，c为const char &amp;
</code></pre>
<p>3.3<br>
vector表示对象的集合，其中所有对象的类型都相同 其中每个对象都有一个与之对应的索引<br>
头文件声明 #include<vector>   using std::vector;<br>
<strong>vector 是一个类模板 不是一个类型</strong><br>
vector能容纳大多数类型的对象作为元素，包括vector，<strong>唯独引用例外</strong>，因为引用不是对象<br>
vector对象默认初始化为空vector  vector<string> sver;<br>
vector对象之间可以互相赋值拷贝 但类型必须相同<br>
初始化的三个例外 1.拷贝初始化 = ，只能提供一个初始值 2.类内初始值只能用<strong>拷贝初始化=或者花括号初始化{ }</strong> 3.初始元素值的列表只能放在<strong>花括号</strong>内，所以称为列表初始化，而不能放在圆括号内<br>
可以使用 (元素数量，元素统一初始值) 进行初始化 元素统一初始值可以缺省（除非有些元素比如类明确要求提供初始值）<br>
所以vector<int> v1{10，1}和vector<int> v1（10，1）意思完全不一样<br>
圆括号不能用于列表初始化，但是花括号也可以进行直接初始化 vector<string> v1{10} vector<string> v1{10，“hi”}都是<strong>合法</strong>的 因为10无法作为元素初始值<br>
可以使用数组来初始化vector，需提供首元素地址和尾后地址，比如vecor<int> i (begin(arr),end(arr));<br>
vector<T> v(n)值初始化：**只提供对象容纳的元素数量而不用略去初始值，**此时库会创建一个值初始化的元素处置，并赋给容器中的所有元素，元素初值由元素类型决定</p>
<pre><code>习题3.12
a合法，空vector；b不合法，类型不匹配；c合法，10个“null”
习题3.13
</code></pre>
<p>（a）0<br>
（b）10,0<br>
（c）10,42<br>
（d）1,10<br>
（e）2,10和42<br>
（f）10，空<br>
（g）10，“hi”</p>
<p>3.3.2<br>
vector对象使用直接初始化的情况 1.初始值已知并较少 2.初始值是另外一个vector的副本 3.所有元素的初始值一样<br>
一般先创建一个空vector对象，再用<strong>push_back</strong>向其中添加元素<br>
重点知识：上述初始化的原因是vector对象能够高效增长，<strong>不需要提前定义长度</strong><br>
不能使用** 范围for 循环语句**对vector对象添加元素<br>
原因：范围for语句预先预定了迭代器end的位置，添加元素会导致end不断变化（STL剖析的解释：vector扩展空间并不是单纯地在内存下一段继续添加，而是必须alloc新的内存，再把原来的vector元素全部搬过去）</p>
<pre><code>习题3.14
</code></pre>
<pre><code>	int main() {
int i;
	vector&lt;int&gt; v_i;
	while (cin &gt;&gt;i)
		v_i.push_back(i);
	for (auto i : v_i)
		cout &lt;&lt; i &lt;&lt; ' ';
};
</code></pre>
<pre><code>习题3.15
</code></pre>
<pre><code>int main() {
	string s;
	vector&lt;string&gt; v_s;
	while (cin &gt;&gt; s)
		v_s.push_back(s);
	for (auto s : v_s)
		cout &lt;&lt; s &lt;&lt; ' ';
};
</code></pre>
<p>3.3.3<br>
vector.size() 返回的类型是** vectot<int>::size_type** 与string有区别<br>
vector对象能否比较决定于元素的类型 如类类型不一定能比较<br>
vector<strong>不能用下标形式向空vector添加元素 只能用push_back</strong><br>
缓冲区溢出：编译器无法发现通过下标访问不存在元素的错误 避免方法”：尽可能使用 范围for语句</p>
<pre><code>习题3.16
</code></pre>
<pre><code>	int main() {
	vector&lt;string&gt; v;
	cout &lt;&lt; v.size() &lt;&lt; endl;
	for (auto s : v)
		cout &lt;&lt; s &lt;&lt; ' ';
};
</code></pre>
<pre><code>习题3.17
</code></pre>
<pre><code>	int main() {
	vector&lt;string&gt; v_s ;
	string s;
	while (cin &gt;&gt; s)
		v_s.push_back(s);
	for (auto &amp;s : v_s)
		for (auto &amp;e : s)
			if (islower(e))
				e = toupper(e);
	for (auto s : v_s)
			cout &lt;&lt; s &lt;&lt; ' ';
};
</code></pre>
<pre><code>习题3.18
错误的，汇报运行时错误，必须用push_back添加元素
习题3.19
```
</code></pre>
<p>vector<int>i1{42,42,42,42,42,42,42,42,42,42};<br>
vector<int>i2(10,42);<br>
vector<int>i3=i2;</p>
<pre><code>	习题3.20
</code></pre>
<pre><code>int main() {
vector&lt;int&gt; v_i;
int i;
while (cin &gt;&gt; i)
	v_i.push_back(i);
for (int x = 0; x &lt; v_i.size()-1; ++x)
	cout &lt;&lt; v_i[x] + v_i[x + 1] &lt;&lt; ' ';
cout &lt;&lt; endl;
for (int x = 0,l = v_i.size(); x &lt;  (v_i.size()+1)/2; ++x)
	cout &lt;&lt; v_i[x] + v_i[l-1-x] &lt;&lt; ' ';
</code></pre>
<p>};</p>
<pre><code>	
3.4.1
具有迭代器的类型同时拥有返回迭代器的成员 例如begin 和 end
迭代器是容器所用，不是模板
begin 负责返回指向第一个元素的迭代器 end 负责返回指向容器“**尾元素的下一位置**”的迭代器 等于指向一个本不存在的“尾后”元素 称尾后迭代器
如果容器为空 begin和end返回统一迭代器 尾后迭代器
我们并不知道迭代器的准确类型 所以**定义时应该使用auto**
对于end不能++或—
迭代器类型 iterator或const_iterator 后者只能读不能写
begin 和 end 返回的迭代器类型取决于是否是常量
用cbegin和cend可以强行返回const_iterator
通过解引用访问迭代器指向的类的成员时 (*it).empty() 圆括号必不可少
或者使用it-&gt;empty（）
vector的push_back功能可能会使迭代器失效（stl的解释：vector的扩增capacity需要在新内存中进行复制粘贴，而迭代器本质是一个特定地址的指针）

习题3.21
	`
	int main() {
	vector&lt;int&gt; v{1,2,3,4,5,6};
	cout &lt;&lt; v.size() &lt;&lt; endl;
	for (auto i = v.begin();i!=v.end();++i)
		cout &lt;&lt; *i &lt;&lt; ' ';
};
`
	习题3.22
	`int main(){
	string text{ &quot;AbdGGasjd&quot; };
	for (auto &amp;i = text.begin(); i != text.end(); ++i)
	{
		*i = toupper(*i);
		cout &lt;&lt; *i ;
	}
};`
	习题3.23
</code></pre>
<pre><code>int main(){
vector&lt;int&gt; vi(10, 10);
for (auto &amp;i = vi.begin(); i != vi.end(); ++i)
	*i = *i * 2;
for (auto &amp;i = vi.begin(); i != vi.end(); ++i)
cout &lt;&lt; *i &lt;&lt;endl;
</code></pre>
<p>};</p>
<pre><code>	
3.4.2
	注意不能iter1+iter1
注意迭代器向前移动的概念 也就是向右移动
两个迭代器相减 得到类型为difference_type的带符号整型数
**交换两个迭代器的元素 iter_swap!!!**
习题3.24
	`int main() {
	vector&lt;int&gt; v_i;
	int i;
	while (cin &gt;&gt; i)
		v_i.push_back(i);
	for(auto ib=v_i.begin() ; ib!= v_i.end()-1; ++ib)
		cout &lt;&lt; *ib + *(ib+1) &lt;&lt; ' ';
	cout &lt;&lt; endl;
	for (auto ib = v_i.begin(),ie = v_i.end(); ie - ib&gt;0; ++ib)
		cout &lt;&lt; *ib + *(--ie) &lt;&lt; ' ';
};
`
	习题3.25
</code></pre>
<pre><code>int main() {
vector&lt;unsigned&gt; scores(11,0);
unsigned grade;
auto i = scores.begin();
while (cin &gt;&gt; grade) 
	if (grade &lt;= 100)
		++*(i + grade / 10);
for (auto i : scores)
	cout &lt;&lt; i &lt;&lt; ' ';
</code></pre>
<p>};</p>
<pre><code>								 
	习题3.26
	迭代器虽然支持相减，但是是不支持相加的！
	

	

习题感悟：
	string.size（）必须有括号
	必须检查string是否为空
	可以多看看自带的函数表（比如string的标点判断ispunct）
	c++中eof的键盘输入为windows Ctrl+Z linux  Ctrl+d（似乎是受编译器影响），用于结束while（cin&gt;&gt;string）
toupper(e) 返回char e的大写形式
迭代器是容器所用，不是模板
	字符串数组char text[]
迭代器向中间靠拢时，可以用 v_i.end()-v_i.begin()&gt;0来判断是否到了中位值</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux（Ubuntu）避坑]]></title>
        <id>https://lixin-ee.github.io//post/linuxubuntubi-keng</id>
        <link href="https://lixin-ee.github.io//post/linuxubuntubi-keng">
        </link>
        <updated>2019-09-05T01:48:18.000Z</updated>
        <content type="html"><![CDATA[<p>用su - 切换到root，输入密码提示认证失败。经查阅原来Ubuntu安装后，root用户默认是被锁定了的，不允许登录，也不允许 su 到 root<br>
终端下</p>
<p>lixin@lixin:~$ sudo passwd<br>
Password: &lt;--- 输入安装时那个用户的密码<br>
Enter new UNIX password: &lt;--- 新的Root用户密码<br>
Retype new UNIX password: &lt;--- 重复新的Root用户密码<br>
passwd：已成功更新密码</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 26. 删除排序数组中的重复项]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-26-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-26-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang">
        </link>
        <updated>2019-09-04T11:53:01.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p>示例 1:</p>
<p>给定数组 nums = [1,1,2],</p>
<p>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。</p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>嗯？题目似曾相识呀！完全可以用昨天的快慢双迭代器（我自己形容为新旧双迭代器）来解决嘛<br>
于是迅速脑海复习一遍，给出代码：</p>
<pre><code>int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        int i = 1;
        for(int j=1;j&lt;nums.size();j++)
            if(nums[j]!=nums[j-1])
                nums[i++]=nums[j];
        return i;

    }
</code></pre>
<p>其实中途还是给自己挖了坑，比如把i放进循环头里面定义了...太低级的错误啦，循环头定义的变量作用域只在循环体内。然后就是后置++这个点，其实并不好，只是为了代码简洁才这样，但是写程序时还是得老老实实前置++，即节省内存又增加可读性（并不是代码越少可读性越高！）<br>
然后激动地提交，期望一次过，当然还是标准结局：嗯？怎么又错了？<br>
一看到空数组...无语了，其实一开始是考虑过空数组的，但是看题目说有序数组就默认是非空数组了...还是得学习贾诩的算无遗策啊hhhh<br>
最后的代码：</p>
<pre><code>public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        if(nums.size()&gt;0){
        int i = 1;
        for(int j=1;j&lt;nums.size();j++)
            if(nums[j]!=nums[j-1])
                nums[i++]=nums[j];
        return i;
        }
        else
            return 0;
    }
</code></pre>
<p>感想：<br>
这一次还是很激动的，毕竟利用了昨天学习到的知识这么快就做出来了！而且本来打算今晚去剪头发的，如果写题写到九点多就尴尬了。本来还想着回到宿舍再写题，但是咬咬牙还是坚持下来了，果然越努力越幸运呀hhh</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第二章 笔记+习题 2.4-2.6]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-er-zhang-bi-ji-xi-ti-24</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-er-zhang-bi-ji-xi-ti-24">
        </link>
        <updated>2019-09-04T03:06:42.000Z</updated>
        <content type="html"><![CDATA[<p>2.4<br>
const 常量关键字，const对象一旦创建后就不能改变值，所以const对象必须初始化<br>
默认状态下 const对象仅在文件内有效，添加extern关键字就可以分享使用，只需要定义一次，在其他文件直接用extern声明就好<br>
声明和定义是不一样的</p>
<p>习题2.26<br>
（a）不合法，const必须初始化（b）合法（c）合法（d）</p>
<p>2.4.1<br>
对const的引用 const int ci = 1024; const int &amp;r1 = ci;<br>
引用的例外：初始化常量引用允许用任意表达式作为初始值 甚至是不同类型的值,只要该表达式的结果能转换成引用的类型即可，尤其是允许为一个常量引用绑定一个非常量的<br>
的对象、字面值，甚至一个一般表达式<br>
当 执行 double dval = 3.14; const int &amp;r1 = dval;时，实际编译时是 const int temp = dval; const int &amp;ri = temp; 将ri绑定到一个不会变化的临时量temp上，所以合法。<br>
<strong>常量应用仅对引用可参与的操作做出了界限，对引用对象本身是否是常量并未限定<br>
指向常量对象的引用必须是常量引用，不能是普通引用，但常量引用可以绑定到普通对象上。</strong></p>
<p>2.4.2<br>
存放常量的地址只能是 指向常量的指针（区分常量指针，同时指向常量的指针也没有规定必须指向常量对象）<br>
常量指针 必须初始化的固定值指针<br>
从右向左阅读，离变量名最近的符号决定变量的自身类型 一开始的符号决定指向的类型<br>
注意*的位置<br>
int errnumb = 0；int *const curerr = &amp;errnumb； 指向int变量的常量指针<br>
const double pi=3.1415；const double *const pip = &amp;pi；指向double常量（第一个const）的常量指针（第二个const）</p>
<p>习题2.27<br>
（a）不合法，指向常量的必须是常量引用<br>
（b）合法，常量指针可以指向非常量（c）合法（d）合法（e）合法<br>
（f）不合法，常量指针必须初始化<br>
（g）合法，指向常量的指针可以指向非常量，只是操作受到限制<br>
习题2.28<br>
（a）不合法，常量指针必须初始化<br>
（b）不合法，常量指针必须初始化<br>
（c）不合法，常量和常量引用必须初始化<br>
（d）不合法，常量指针必须初始化<br>
（e）指向常量的指针<br>
习题2.29<br>
（a）合法，常量可以赋值给非常量<br>
（b）不合法，不能把指向常量的指针直接赋给普通指针<br>
（c）不合法，不能用普通指针指向常量<br>
（d）如果是初始化，合法，如果是赋值，不合法<br>
（e）不合法，常量指针不能被赋值<br>
（f）不合法，常量不可以赋值</p>
<p>2.4.3<br>
顶层const 指针本身就是个常量 底层const 指针所指对象是个常量<br>
const int ci = 42；const int *const p3 = &amp;ci; 时 int *p = p3；为错误操作，因为p3为底层const 指向常量，只能由指向常量的指针<br>
习题2.30<br>
v2：顶层const          p2：底层const          p3:顶层const<br>
习题2.31<br>
合法；<br>
不合法 ；合法 ；<br>
不合法；合法</p>
<p>2.4.4<br>
常量表达式：值不会改变并且在编译过程中就能得到计算结果的表达式<br>
用常量表达式初始化的const对象也是常量表达式</p>
<p>声明为constexpr的变量一定是一个常量，而且必须用常量表达式进行初始化<br>
如果你认定变量是一个常量表达式，那就把它声明成constexpr类型</p>
<p>字面值类型：算数类型（int、double）、引用、指针<br>
非字面值类型：自定义类、IO库、string类 不能被定义成constexpr<br>
constexpr指针的值不能改标 相当于常量指针但位置与const不同<br>
int const *p 等同于 constexpr int *p<br>
constexpr const int *p 指向整形常量的常量指针<br>
定义在函数体之外的对象的地址固定不变，可用于初始化constexpr指针</p>
<p>习题2.32<br>
非法，null是保留字 修改变量名并最好使用nullptr</p>
<p>2.5.1<br>
类型别名 某种类型的同义词<br>
定义类型别名（1）typedef （2）别名声明 关键词 using<br>
类型别名可以间接使用 typedef double a； using b = a； 则b也是double类型<br>
地址的类型别名 typedef int *pint；<br>
**但注意 const pint *ps 等于指向int的常量指针，而非指向int常量的指针，**因为使用了类型别名后不等同于直接展开的。</p>
<p>2.5.2<br>
auto类型说明符 让编译器分析表达式所属的类型<br>
auto类型的变量必须有初始值<br>
如果在一条auto语句中声明多个变量，则语句中所有变量的初始基本类型都必须一样<br>
auto i = 0,*p = &amp;i;//正确，初始基本类型都是int（声明符号*不算在基本类型内）<br>
auto 会以引用对象的类型作为auto的类型，而不是把它视为引用，如果想定义为引用 必须使用auto &amp;<br>
auto会忽略顶层const 保留底层const 所以顶层const需要明确指出 const auto<br>
常量引用可以绑定字面值</p>
<p>习题2.33<br>
a = 42;<br>
b = 42;<br>
c = 42；<br>
e:error；<br>
f:error；<br>
g:error；<br>
习题2.35<br>
第一个auto  j  类型为int<br>
第二个auto  &amp;k 类型为const int &amp;<br>
第三个auto *p类型为const int *<br>
第四个auto j2类型为const int<br>
第五个auto &amp;k2 类型为const int&amp;</p>
<p>2.5.3<br>
decltype 选择并返回操作数的数据类型<br>
使用方法 decltype（f（）） sum = x；<br>
引用从来都作为其所指对象的同义词出现，只有用在decltype处是一个例外：decltype并不管引用的对象是谁，只返回引用类型<br>
int i = 1，*p = &amp;i；&amp;r = i； 其中decltype（r）返回引用类型，decltype（r+0）返回int<br>
decltype（i=i1）返回引用 而当表达式的内容是解引用操作，则decltype将得到引用类型 所以decltype（*p）返回int&amp; 而不是int<br>
decltype的括号数量影响返回值 decltype（（变量））双层括号永远返回引用类型 decltype（变量） 单层括号就返回变量的类型。双层括号会被当做一个可作为赋值语句左值的表达式<br>
先执行decltype中的表达式再计算定义的表达式 decltype(a=b) c = a;//结果c = b</p>
<p>习题2.36<br>
decltype(())双层括号表示引用（注意引用必须初始化）<br>
a是int类型   4<br>
b是int类型   4<br>
c是int类型   4<br>
d是int &amp;类型    4<br>
全是4！！！！！！！！！！！<br>
习题2.37<br>
a int 3;<br>
b int 4;<br>
c int 3;<br>
d int &amp; 3;<br>
习题2.38<br>
1：如果使用引用类型，auto会识别为其所指对象的类型，decltype则会识别为引用的类型。<br>
2：decltype(())双括号的差别。</p>
<p>2.6<br>
类类型 相当于以类的形式自定义数据类型<br>
struct 关键词<br>
类体的花括号形成一个新的作用域  表示结束的花括号后必须写一个分号，因为类体后面可以紧跟变量名，以示对该类型对象的定义<br>
类体内定义类的成员<br>
没有初始值的成员将被默认初始化<br>
类内初始值可以用花括号和等号，不能用圆括号</p>
<p>习题2.39<br>
error C2628: “example”后面接“int”是非法的(是否忘记了“;”?)<br>
error C3874: “main”的返回类型应为“int”而非“example”<br>
非常有趣，第二个错误显示编译器试图把类声明视为返回类型</p>
<p>2.6.3<br>
类一般定义在头文件中<br>
头文件改变后需要重新编译源文件获取更新过的声明<br>
预处理器 看到#include标记就会使用指定的头文件的内容代替#include<br>
另外一项预处理功能是头文件保护符 依赖于预处理变量<br>
#define 将一个名字设定为预处理变量 #ifdef 当且仅当变量已定义时为真 #ifndef当且仅当变量未定义时时为真   遇到#endif指令停止<br>
预处理变量无视作用域的规则<br>
预处理变量 包括头文件保护符必须唯一 使用头文件中类的名字来构建保护符的名字，同时大写预处理变量的名字<br>
头文件保护符是给头文件用在其自身的！！！</p>
<p>习题2.40 2.41 2.42<br>
struct Sales_Data {<br>
public:<br>
string ISBN;<br>
int units_sold = 0;<br>
double price = 0.00;<br>
double ave = 0.00;</p>
<pre><code>	int input_data(istream &amp;in) {
		in &gt;&gt; ISBN &gt;&gt; units_sold &gt;&gt; price;
		ave = price*ave / ave;
	}
	
	Sales_Data&amp; add_data(Sales_Data&amp; data1,Sales_Data&amp; data2) {
		if (data1.equal_isbn(data2)) {
			Sales_Data sum;
			sum.units_sold = data1.units_sold + data2.units_sold;

			sum.ave = (data1.units_sold*data1.price + data2.units_sold*data2.price) / sum.units_sold;
			sum.price = sum.ave;
			return sum;
		}
		else
		{
			std::cerr &lt;&lt; &quot;Data must have same ISBN&quot; &lt;&lt; std::endl;
		}

		
	}

	bool equal_isbn(Sales_Data exam)const {
		return ((*this).ISBN == exam.ISBN);
	}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组-27. 移除元素]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-27-yi-chu-yuan-su</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-27-yi-chu-yuan-su">
        </link>
        <updated>2019-09-03T14:44:56.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目要求<br>
给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p>示例 1:</p>
<p>给定 nums = [3,2,2,3], val = 3,</p>
<p>函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</p>
<p>你不需要考虑数组中超出新长度后面的元素。<br>
示例 2:</p>
<p>给定 nums = [0,1,2,2,3,0,4,2], val = 2,</p>
<p>函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p>
<p>注意这五个元素可为任意顺序。</p>
<p>你不需要考虑数组中超出新长度后面的元素。<br>
说明:</p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<p>// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝<br>
int len = removeElement(nums, val);</p>
<p>// 在函数里修改输入数组对于调用者是可见的。<br>
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。<br>
for (int i = 0; i &lt; len; i++) {<br>
    print(nums[i]);<br>
}</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/remove-element<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>我第一次给出的答案为下：</p>
<pre><code>class Solution {
public:
    int removeElement(vector&lt;int&gt;&amp; nums, int val) {
        int cut_len = 0 ;
        for(int i = 0;i&lt;nums.size();i++)
            if(nums[i]==val){
                ++cut_len;
                for (int j=i;j&lt;nums.size()-2;j++)
                    nums[j]=nums[j+1];
            }
         
         return nums.size()-cut_len;
    }
   
};
</code></pre>
<p>一提交，可以说是惨不忍睹了，算法有一个特点：解决办法和使用范围是同等重要的！<br>
我这个解法很明显没有考虑连续的val的情况 比如{3，2，2，3}去除2，第二个2很明显被前移略过了，想了一下应该是受算法书的“后面的元素往前移动”的惯性思维的影响，问题是算法书是去掉固定位置的值呢。。。<br>
修改了几次，还是有不少问题<br>
比如一开始j&lt;nums.size()-2处如果size为1，那么无符号的负数直接变成一个怪物，直接内存爆炸。<br>
最后深感这种方法的缺陷，于是观看官方答案：</p>
<blockquote>
<p>方法一：双指针<br>
思路</p>
<p>既然问题要求我们就地删除给定值的所有元素，我们就必须用 O(1)O(1) 的额外空间来处理它。如何解决？我们可以保留两个指针 i 和j，其中 i 是慢指针，j 是快指针。</p>
<p>算法</p>
<p>当 nums[j] 与给定的值相等时，递增 jj 以跳过该元素。只要 nums[j] 不等于nums[j] 我们就复制 nums[j] 到 nums[i]并同时递增两个索引。重复这一过程，直到 jj到达数组的末尾，该数组的新长度为 i。</p>
<p>该与 删除排序数组中的重复项 的解法十分相似。</p>
<pre><code>Java
public int removeElement(int[] nums, int val) {
    int i = 0;
    for (int j = 0; j &lt; nums.length; j++) {
        if (nums[j] != val) {
            nums[i] = nums[j];
            i++;
        }
    }
    return i;
}
</code></pre>
<p>复杂度分析</p>
<p>时间复杂度：O(n)，<br>
假设数组总共有 n 个元素，i 和 j 至少遍历 2n 步。</p>
<p>空间复杂度：O(1)。</p>
</blockquote>
<p>不禁感叹：妙啊！！！（第二种官方解法略坑，不考虑原数组顺序，就不贴上来了）<br>
主要思想就是使用两个指针（迭代器）,一个作为新数组的迭代器，一个作为旧数组的迭代器，旧数组有不同的就交给新数组，目标值的就跳过，既实现了原地修改，又避免了处理目标值这种棘手的问题，真的妙啊！<br>
复现如下：</p>
<pre><code>class Solution {
public:
    int removeElement(vector&lt;int&gt;&amp; nums, int val) {
        int i = 0;
        for(int j= 0;j&lt;nums.size();++j)
            if(nums[j]!=val)
               nums[i++]=nums[j];
         return i;
    
    }
};
</code></pre>
<p>其实复现中还是遇到了不少问题，一开始非常自大，看一眼就开始复现了，结果错漏百出，所以还是得老老实实分析出官方解法的算法思想，而不是流于代码表面，这样才可以在其他题目中轻轻松松复现出来！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第二章 笔记+习题 2.1-2.3]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-er-zhang-xi-ti-bi-ji</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-er-zhang-xi-ti-bi-ji">
        </link>
        <updated>2019-09-03T12:02:35.000Z</updated>
        <content type="html"><![CDATA[<p>2.1.1<br>
char 可以表示的范围-128-127 其中-128的表示为1000 0000 而0的表示为0000 0000（无负0）<br>
习题2.1<br>
区别在于类型数据所占的比特（16、32、64、16） 以及 含义（整型、长整型、长整型、和短整型）；无符号类型所有比特都是用来存储值，无法表示负数，带符号类型则可以表示负数，用一位来表示符号；float是单精度浮点数，只有6位有效数字，double是双精度浮点数，有10位有效数字<br>
练习2.2 利率应该使用float，本金使用int，付款使用double，因为一般利率为0.0xx，本金为10的倍数的正整数，付款容易出现小数。</p>
<p>2.1.2<br>
注意 不仅仅是等号=才会触发强制转换 所有符号包括&lt; &lt;= &gt; &gt;=都会触发强制转换，所以负值的int永远大于无符号数<br>
对无符号类型赋一个超出表示范围的值，初始值是对无符号类型表示数值总数取模后的余数 例如8比特大小的unsigned char可以表示0-255（256个数）则强行赋值-1的话，结果就是对-1取模256所得的余数255<br>
取模方法<br>
-17 % 10 的计算结果如下：r = (-17) - (-17 / 10) x 10 = (-17) - (-1 x 10) = -7<br>
17 % -10 的计算结果如下：r = 17 - (17 / -10) x (-10) = (17) - (-1 x -10) = 7<br>
-17 % -10 的计算结果如下：r = (-17) - (-17 / -10) x (-10) = (-17) - (1 x -10) = -7<br>
注意 -1%256=（-1）-（-1/256）x 256=255<br>
对带符号类型赋一个超出表示范围的值，结果是未定义的。<br>
unsigned符号默认忽略int 所以unsigned a；和unsigned int a；是一样的</p>
<p>习题2.3<br>
u2 - u = 32； u - u2 = -32 mod 2^32 = 4294967264；<br>
i2 - i = 32 i - i2=-32 i - u=0 u - i = 0</p>
<p>2.1.3<br>
严格来说十进制字面值不会是负值，负号并不在字面值之内，它的作用仅仅是对字面值取负值而已<br>
小数默认为double<br>
十进制字面值的类型：int、long、long long<br>
八进制和十六进制：int、unsigned int、long、unsigned long、long long和unsigned long long（输出不加规范的话还是十进制）<br>
自动选择能够容纳字面值的最小范围<br>
单引号‘a’ char型字面值 双引号“abc” 字符串型字面值<br>
字符串型字面值的类型实际上是由常量字符构成的数组<br>
编译器在每个字符串的结尾处添加一个空字符，因此字符串字面值的实际长度要比内容多1<br>
两个字符串字面值位置紧邻或仅由空格、缩进和换行符分隔，则它们实际上视为一个整体<br>
两类字符程序员不能直接使用：1.不可打印字符：退格等控制字符 2.特殊含义字符，需要使用转义序列<br>
true false 是布尔类型的字面值 nullptr是指针字面值</p>
<p>习题2.5<br>
（a）char型、wchar_t、字符串、宽字符串<br>
（b）int、unsigned int、long、unsigned long、八进制int、十六进制int<br>
（c）double、float、long double<br>
（d）int、unsigned int、double、double<br>
习题2.6<br>
第一组为十进制，输出为可见，第二组为八进制，输出还是可见，但是第一个0代表的就是八进制<br>
习题2.7<br>
（a）字符串常量，其中\145为八进制数，转化为e，\012转义为换行符 Latin1字符集<br>
(b)long double<br>
(c)float<br>
(d)long double<br>
习题2.8</p>
<pre><code>	cout &lt;&lt; &quot;2\115\0122\t\115&quot; &lt;&lt; endl;
</code></pre>
<p>2.2.1<br>
对象 是指一块能存储数据并具有某种类型的内存空间<br>
变量初始化不等于赋值<br>
花括号列表初始化会因为存在信息丢失（精确度丢失的问题）而拒绝初始化请求，编译器报错 等号初始化和括号初始化能够直接执行转换（直接丢弃部分值）<br>
默认初始化：1.定义在任何函数体之外的内置类型变量会初始化为0 2.定义在函数体内部的内置类型变量将不被初始化，此时变量的值是未定义的（undefined）<br>
std::string  empty;初始化为空串**（不可以输出）**<br>
注意</p>
<p>习题2.9<br>
(a)定义不正确，应该在函数调用外定义<br>
(b)列表赋值不允许精度丢失<br>
(c)错误，从左到右，所以b等于未定义（第一种情况<br>
(d)正确，但是会丢失精度 最后等于3<br>
习题2.10<br>
string不是内置类型，所以全部为空，int在函数外的为0，函数内部的是未定义的</p>
<p>2.2.2<br>
分离式编译 将程序分割为若干个文件，每个文件可以被独立编译。.<br>
声明 仅规定变量的类型和名字 定义 创建与名字关联的实体，申请存储空间 并赋初始值声明关键字 extern<br>
如果含有初始化的话就等于定义，抵消了extern的作用，同时试图初始化由extern标记的已定义变量会引发错误<br>
定义能且只能被定义一次，但可以被多次声明<br>
int j； 声明并定义  extern int j；声明  extern int j=1；定义</p>
<p>习题2.11<br>
(a)定义，因为已经初始化了(b)声明(c)声明</p>
<p>2.2.3标识符<br>
标识符对大小写字母敏感<br>
命名规范 1.体现实际含义 2.使用小写字母 3.用户自定义的类名一般以大写字母开头 4.多个单词组成时应有明显区分</p>
<p>习题2.12<br>
（a）非法 double是关键词<br>
（b）合法<br>
（c）符号-非法<br>
（d）非法，应该字母或下划线开头<br>
（e）合法，因为大小写敏感，Double不属于关键字</p>
<p>2.2.4<br>
全局作用域：函数体外定义 块作用域：定义在函数块内<br>
内层作用域中可以重新定义外层作用域已有的名字 但是不建议</p>
<p>习题2.13<br>
j=100，因为内层作用域中的同名向量会覆盖外层的名字<br>
习题2.14<br>
输出i=100 sum=45，for循环头定义的i作用域只能在循环体内，且会覆盖外层作用域的参数。</p>
<p>2.3复合类型<br>
一个声明语句：基本数据类型+声明符（例如&amp; *） 每个声明符命名了一个变量，并且指定该变量为与基本数据类型有关的某种类型（引用或指针）<br>
2.3.1<br>
引用  int i = 1024； int &amp;refer = i;  //refer指向i<br>
<strong>引用必须被初始化，不能只声明不定义</strong><br>
引用 是把变量和它的初始值绑定（bind）在一起，而不是把初始值拷贝给应用，<br>
引用将和它的初始值对象一直绑定在一起，而无法将应用重新绑定到另外一个对象，因引用必须初始化。<br>
可以给引用赋值（区分初始化）<br>
赋值和初始化的区别(赋值：已经存在的对象，初始化：刚刚构造的对象，赋值的时候调用重载的赋值运算符，初始化的时候调用拷贝构造函数。)。<br>
引用可以复引用 int &amp;refer2 = refer; 但是无法定义引用的引用，因为引用本身不是一个对象<br>
引用可以用于赋值或初始化 int i2 = refer;<br>
引用类型的初始值必须是一个对象，不可以是字面值或者某个表达式</p>
<p>习题2.15<br>
（b） 不合法，不能用普通引用指向字面值常量（d）不合法，引用必须初始化<br>
习题2.16<br>
都合法，只是c、d会损失精度<br>
习题2.17<br>
两个都为10</p>
<p>2.3.2<br>
指针与引用的区别：1.指针是一个对象，可以对其进行赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象（引用只能指向一个对象）2.指针无须在定义时赋初值<br>
定义指针类型 int *ip1<br>
获取指针的地址 &amp; 取地址符 int *ip2 = &amp;ip1；<br>
<strong>不能定义指向引用的指针 因为引用不是对象</strong><br>
所有指针的类型都要和它所指向的对象严格匹配<br>
指针的四个状态1.指向一个对象2.指向紧邻对象所占空间的下一位置 3.空指针 4.无效指针<br>
就算指向的对象为初始化，指针也不为空<br>
无效指针不能访问，否则引发错误<br>
* 解引用符<br>
空指针生成方法 int *p1 = nullptr;   int *p2 = 0;   int *p3 = NULL;（需要引用#include cstdlib）<br>
nullptr 通用的特殊类型字面值 更推荐使用<br>
NULL 预处理变量 值为0<br>
一个指针指向某对象，而另一指针指向另外对象的下一地址，指针值可能相同<br>
void* 指针 可以存放任何类型的对象的地址 但只能进行指针比较，作为函数输入输出或者赋给另外一个void*指针，<strong>不能直接操作所指对象，不能赋给其他特定类型的指针对象</strong><br>
<em><em>不能用int初始int</em>，就是int中可能是地址的值也不行</em>*</p>
<p>习题2.18</p>
<pre><code>	int x,y= 10;
	int *x_p = &amp;x;
	*x_p = 20;
	cout &lt;&lt; *x_p &lt;&lt; endl;  //20
	x_p = &amp;y;
	cout &lt;&lt; *x_p &lt;&lt; endl; //10
</code></pre>
<p>习题2.19<br>
指针是一个对象，引用不是一个对象，所以有指针的引用，没有引用的指针。<br>
习题2.20<br>
将i的值进行平方<br>
习题2.21<br>
（a）非法，指针的类型应该和其指向的对象的类型一致，不会执行默认类型转换（b）非法，<em><em>不能用int初始int</em>，就是int中可能是地址的值也不行</em>*<br>
习题2.22<br>
if(p)判断p是否为空指针  if(*p)判断p指向的值是否为0 <strong>就算指向的对象为初始化，指针也不为空</strong><br>
习题2.23<br>
只能通过if进行空指针判断，对象的有效性是必需由程序员保证的<br>
习题2.24<br>
void*指针可以指向任何类型的指针，只是不能进行直接的操作。</p>
<p>2.3.3<br>
声明符应该靠近变量而不是类型，<em><em>比如int</em> p1,p2;//其实等同于int *p1;int p2;</em>*<br>
根据*的个数可以判断指针的级别 同时也等于解引用次数<br>
存在指向指针的引用 int *i = 42; int *p ;<strong>int *&amp;r=p;</strong><br>
使用从右向左阅读，离变量名最近的符号对变量的类型有最直接的影响 例如int *&amp;r<br>
习题2.25<br>
(a)ip是int指针，i是int，r是int引用<br>
(b)i是int，ip是int指针<br>
(c)ip是int指针，ip2是int<br>
<strong>声明符应该靠近变量而不是类型的原因</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组832-翻转图像]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-fan-zhuan-tu-xiang</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-fan-zhuan-tu-xiang">
        </link>
        <updated>2019-09-03T01:32:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。</p>
<p>水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 [1, 1, 0] 的结果是 [0, 1, 1]。</p>
<p>反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。例如，反转 [0, 1, 1] 的结果是 [1, 0, 0]。</p>
<p>示例 1:</p>
<p>输入: [[1,1,0],[1,0,1],[0,0,0]]<br>
输出: [[1,0,0],[0,1,0],[1,1,1]]<br>
解释: 首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；<br>
然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]<br>
示例 2:</p>
<p>输入: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]<br>
输出: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]<br>
解释: 首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；<br>
然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]<br>
说明:</p>
<p>1 &lt;= A.length = A[0].length &lt;= 20<br>
0 &lt;= A[i][j] &lt;= 1</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/flipping-an-image</p>
<pre><code>class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; flipAndInvertImage(vector&lt;vector&lt;int&gt;&gt;&amp; A) {
   	}
}
</code></pre>
<p>刚刚看到题目的时候还是首先下意识看形参了（后来发现这样并不是一个好习惯）看到嵌套的vector，思考了一会，首先必须打开第一层，于是想使用模板具有的迭代器配合for范围语句进行翻转，然后考虑如果使得0、1反转，发现简单的1-temp就可以实现反转了。于是得到下面代码：</p>
<pre><code>for (auto &amp;vec : A) {
		auto head = vec.begin();
		auto last = vec.end();
		last = last - 1;
           if(last == head){
               auto only = *head;
				*head = 1 - only;}
           else{
        while (head != last) {
			swap(head,last)；
			++head;
			if (head == last)
				break;
			else if ((--last) == head) {
				auto mid = *head;
				*head = 1 - mid;
		  	}
		  }
  	}
  }
        return A;
				}
</code></pre>
<p>这段代码一看过去就知道有许多值得优化的地方了，说一下遇到的<strong>坑点</strong>吧：<br>
1.for范围语句定义的参数是值拷贝的，必须改为引用拷贝，否则后面的工作全都是在一个副本上操作的（全部木大！）<br>
2.vec.end()返回的是尾后迭代器！！！不是指向最后一个值！！！<br>
3.由于存在一个值的情况，必须先判断迭代器指向的位置是否相等。<br>
4.迭代器的解引用似乎出现了问题，既不能赋值，也不能作为swap的形参进行传递，只能通过temp进行传递（解决方法：迭代器有专用的swap，iter_swap)<br>
5.两个迭代器同时向中间移动，重合判断会比较麻烦。（第一次bug居然是尾后迭代器进行递增了...）</p>
<p>终于完成后看了一下评论，果然发现自己的思考思路有问题，官方给出的题解如下（基于JAVA)</p>
<pre><code>class Solution {
    public int[][] flipAndInvertImage(int[][] A) {
        int C = A[0].length;
        for (int[] row: A)
            for (int i = 0; i &lt; (C + 1) / 2; ++i) {
                int tmp = row[i] ^ 1;
                row[i] = row[C - 1 - i] ^ 1;
                row[C - 1 - i] = tmp;
            }

        return A;
    }
}
</code></pre>
<p>不得不说解答还是挺精妙的，当我还在想奇数个元素时如何修改中位数时，解答就已经用【保存temp变量再交换】的思想解决了，省去了一个if判断，非常精妙。<br>
问题很明显：这是个数组问题，不是vector问题！！！应该从数组出发，那么最简单的方法就应该是下标嘛！唉又把简单的问题复杂化了。不过这样也有个好处，就是让自己能够多点把学到的东西用起来，主动去查找bug背后的原因<br>
修改后的代码如下：</p>
<pre><code>class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; flipAndInvertImage(vector&lt;vector&lt;int&gt;&gt;&amp; A) {
       for (auto &amp;vec :A)
	{
		int len = vec.size();
		for(int i = 0;i&lt;=len-i-1;++i){
				int temp = 1 - vec[i];
				swap(vec[i], vec[len - i - 1]);
				vec[i] = 1 - vec[i];
				vec[len - i - 1] = temp;
		}

	}
        return A;
    }
};
</code></pre>
<p>另外吐槽一点，leetcode的运算时间很迷，第一次提交最后代码居然是28ms，不服后再次提交变成了12ms...</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub远程提交代码]]></title>
        <id>https://lixin-ee.github.io//post/github-yuan-cheng-ti-jiao-dai-ma</id>
        <link href="https://lixin-ee.github.io//post/github-yuan-cheng-ti-jiao-dai-ma">
        </link>
        <updated>2019-09-02T12:27:19.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1下载git工具">1.下载git工具</h1>
<h1 id="2在将要上传的文件文件夹中右键-git-bash-here">2.在将要上传的文件/文件夹中右键 git bash here</h1>
<p>注意，例如我要提交 cpp-primer中的chapter1文件夹，就应该在cpp-primer文件夹中打开git工具</p>
<h1 id="3绑定用户">3.绑定用户</h1>
<pre><code>git config --global user.name &quot;Lixin-ee&quot;
git config --global user.email &quot;im_lixin@foxmail.com&quot;
</code></pre>
<h1 id="4生成ssh-key">4.生成ssh key</h1>
<p><code>cd ~/.ssh</code><br>
检查是否已生成密钥，如果返回的ls有3个文件,则密钥已经生成。<br>
如果没有密钥，则通过下面命令生成<br>
<code>ssh-keygen -t rsa -C &quot;im_lixin@foxmail.com&quot;</code><br>
生成成功后，去对应目录C:\Users\你的电脑名.ssh里用记事本打开id_rsa.pub，得到ssh key公钥。</p>
<h1 id="5为github账号配置ssh-key">5.为github账号配置ssh key</h1>
<p>切换到github-settings-SSH key-Add SSH key-填上标题（最好跟本地仓库保持一致）。</p>
<h1 id="6建立本地仓库">6.建立本地仓库</h1>
<p>执行指令：<br>
<code>git init</code><br>
初始化成功后你会发现项目里多了一个隐藏文件夹.git<br>
执行指令：<br>
<code>git add .</code><br>
将所有文件添加到仓库<br>
执行指令：<br>
<code>git commit -m &quot;提交文件&quot;</code><br>
注意双引号内是github仓库中文件的注释！！！一定要修改，比如我的可以改成chapter1.</p>
<h1 id="7到github-text仓库复制仓库地址">7.到github text仓库复制仓库地址</h1>
<p>执行指令：<br>
<code>git remote add origin https://github.com/Lixin-ee/cpp-primer.git</code></p>
<h1 id="8上传本地代码">8.上传本地代码</h1>
<p>执行指令：<br>
<code>git push -u origin master</code></p>
<h1 id="9刷新github">9.刷新github</h1>
<p>完成！</p>
<p>参考：https://www.jianshu.com/p/191d1e21f7ed</p>
<p>更新：<br>
如果通过其他途径更新了库，需要先同步本地仓库才能重新上传<br>
命令：<br>
<code>git pull --rebase origin master</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第一章 笔记+习题]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-yi-zhang-bi-ji-xi-ti</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-yi-zhang-bi-ji-xi-ti">
        </link>
        <updated>2019-09-02T07:30:37.000Z</updated>
        <content type="html"><![CDATA[<p>1.1<br>
c++程序必须有一个函数命名为main<br>
函数定义包括四部分：返回类型，函数名，函数主题，形参列表<br>
main函数的返回类型必须为int<br>
main的返回值用于指示状态，返回值0表明成功，非0用于指出错误类型</p>
<p>习题1.2</p>
<pre><code>int main() {
	return -1;
}
</code></pre>
<p>//程序“[45476] cpphomework.exe”已退出，返回值为 -1 (0xffffffff)。</p>
<p>1.2<br>
iostream 分为 istream和ostream<br>
cin 标准输入 cout 标准输出 cerr 标准错误 clog 输出程序运行的一般信息<br>
#include&lt;头文件&gt;<br>
输出运算符 &lt;&lt; 左侧的运算对象必须是一个ostream对象，右侧运算对象就是要打印的值<br>
endl 操纵符 结束当前行，并将缓冲区的内容刷到设备中<br>
st::指出cout和endl是定义在名为std的命名空间中<br>
标准库所有名字都在命名空间std中<br>
命名空间 避免名字相同冲突<br>
::作用域运算符<br>
输入运算符&gt;&gt;</p>
<p>习题1.3</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;

int main() {
	cout &lt;&lt; &quot;Hello,World&quot; &lt;&lt; endl;
}
</code></pre>
<p>习题1.4</p>
<pre><code>int main() {
	int a = 1, b = 3;
	cout &lt;&lt; &quot;a+b=&quot;&lt;&lt;a+b&lt;&lt; endl;
	cout &lt;&lt; &quot;a*b=&quot; &lt;&lt; a*b &lt;&lt; endl;
}
</code></pre>
<p>习题1.5</p>
<pre><code>int main() {
	int a = 1, b = 3;
	cout &lt;&lt; &quot;a+b=&quot;;
	cout &lt;&lt; a + b &lt;&lt; endl;
	cout &lt;&lt; &quot;a*b=&quot; ;
	cout &lt;&lt;  a*b &lt;&lt; endl;
	while (1);
}
</code></pre>
<p>注意此处为了维持格式一致，endl的使用时机要把握好。</p>
<p>习题1.6<br>
非常明显的不合法，因为一句代码的结束是以分号为标志的，如果没有遇到分号，则程序会自动读取第二行，所以需要把多余的分号去除。</p>
<p>1.3注释简介<br>
// 双斜线注释 用于半行和单行附注<br>
/* */注释界定符 用于多行注释<br>
/* */注释界定符 不能嵌套在另外一个注释界定符内</p>
<p>习题1.7<br>
warning C4138: 在注释外找到“*/”<br>
习题1.8<br>
第一句 合法 输出*  实际输出/*<br>
第二句 合法 输出*/  实际输出*/<br>
第三句 不合法  实际不合法<br>
第四句 不合法 实际不合法</p>
<p>1.4 控制流<br>
习题 1.9</p>
<pre><code>int main() {
	int i = 50;
	int sum = 0;
	while (i &lt;= 100) {
		sum += i;
		++i;
	}
	cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl;
}
</code></pre>
<p>习题1.10<br>
int main() {<br>
int i = 10;<br>
while (i &gt;=0) {<br>
cout &lt;&lt; i-- &lt;&lt; endl;<br>
}<br>
}<br>
习题1.11</p>
<pre><code>int main() {
	int begin,end;
	cout &lt;&lt; &quot;Please input one number:&quot;;
	cin &gt;&gt; begin;
	cout &lt;&lt; &quot;Please input another number:&quot;;
	cin &gt;&gt; end;
	if (end &lt; begin)
		swap(begin, end);
	while (end &gt;= begin) 
	  cout &lt;&lt; begin++ &lt;&lt; endl;
}
</code></pre>
<p>1.4.2<br>
for循环头中定义的变量在循环结束后不能再使用<br>
while同理，循环条件中定义的变量作用范围仅仅在循环体内</p>
<p>习题 1.12<br>
完成了从-100到100的整数的相加和，sum终值为0<br>
习题1.13<br>
本题比较简单，主要需要注意的是for循环头的特性（1）循环头可以定义多个变量，但所有变量都只能是同一个类型，同时变量作用域只在循环内（2）表达式也可以有多个，但是一般来说都是用来改变判断条件的，太复杂反而适得其反。<br>
习题1.14<br>
for循环的循环起始很确定，通过循环头就一览无遗，适合于确定次数的循环（但是同时要求对循环头有良好的书写习惯）。while适用于只知道判断条件的不确定次数循环，并且需要阅读循环体确认循环变化。<br>
习题1.15<br>
如今许多IDE都为我们提供了自动补全、自动监测等功能，我们甚至无须编译就可以知道错误所在，但是在手写灵感、工作交流当中，避免形式错误还是很重要的。</p>
<p>1.4.3<br>
while(std::cin&gt;&gt;value) 此循环条件实际上检测的是std::cin<br>
习题 1.16</p>
<pre><code>int main() {
	int i = 0,sum = 0;//i的定义必不可少！
	while (cin &gt;&gt; i)//当遇到的输入不为int整数时结束输入
		sum += i;
	cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl;
}
</code></pre>
<p>1.5 类简介<br>
1.5.1	<br>
每一个类都定义了一个新类型 其类型名就是类名<br>
每个对象可以1编写函数调用参数 2用输入运算符&gt;&gt;和输出运算符&lt;&lt;进行读写 3用赋值运算符=进行赋值 4.用加法运算符进行相加？ 5用复合赋值运算符+=进行运算<br>
头文件定义 不属于标准库的头文件 #include “Class_type.h”</p>
<p>习题1.20</p>
<pre><code>int main() {
	Sales_item item_t;
	while (cin &gt;&gt; item_t)
		cout &lt;&lt; item_t&lt;&lt;endl;
}
</code></pre>
<p>习题1.21</p>
<pre><code>int main() {
	Sales_item item_1,item_2;
	cin &gt;&gt; item_1 &gt;&gt; item_2;
	cout &lt;&lt; item_1 + item_2 &lt;&lt; endl;
}
</code></pre>
<p>习题1.22<br>
int main() {<br>
Sales_item item_s;<br>
Sales_item item_t;<br>
while (cin &gt;&gt; item_t) {<br>
item_s += item_t;<br>
cout &lt;&lt; item_s &lt;&lt; endl;<br>
}<br>
}<br>
习题1.23<br>
int main() {<br>
Sales_item item_last, item_curr;<br>
int sum = 1;<br>
if(cin &gt;&gt; item_curr) {<br>
item_last = item_curr;<br>
while (cin &gt;&gt; item_curr) {<br>
if (item_curr.isbn == item_last.isbn) {<br>
item_last += item_curr;<br>
++sum;<br>
}<br>
else<br>
{<br>
cout &lt;&lt; item_last &lt;&lt; '\t' &lt;&lt; sum &lt;&lt; endl;<br>
item_last = item_curr;<br>
sum = 1;<br>
}<br>
}<br>
cout &lt;&lt; item_last &lt;&lt; endl;<br>
}<br>
}</p>
<h1 id="总结">总结</h1>
<p>第一章比较基础，但是从练习中我们可以体会到很多细节，例如for循环头的隐藏设定，参数应该设定为局部变量还是全局变量，参数的作用域影响函数的运行以及输出输入，仔细阅读类定义的头文件再使用类的功能会事半功倍。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表237-删除指定节点]]></title>
        <id>https://lixin-ee.github.io//post/leetcode-shua-ti-gan-xiang-0902</id>
        <link href="https://lixin-ee.github.io//post/leetcode-shua-ti-gan-xiang-0902">
        </link>
        <updated>2019-09-02T02:49:37.000Z</updated>
        <content type="html"><![CDATA[<p>今天第一次开始刷leetcode，遵循前辈们的意见从容易开始刷，第一次选择了一个链表题，题目如下</p>
<p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。<br>
现有一个链表 -- head = [4,5,1,9]，它可以表示为:<br>
输入: head = [4,5,1,9], node = 5<br>
输出: [4,1,9]<br>
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p>
<p>非常基础的一个链表结点删除，但是看到代码后我却无从下手了</p>
<pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void deleteNode(ListNode* node) {
        }
};
</code></pre>
<p>what？只给了一个形参？不是应该给出链表的吗？<br>
但是还是立即开始思考如何遍历链表，这个过程中就暴露自己对遍历记得不牢固了，一直纠结判断条件到底是先判断结点值是否相等还是当前节点是否已经到达尾结点，翻查书籍后发现也不对啊，书中描述至少应该给出链表和删除标记（删除位置或删除值）<br>
心灰意冷下打开评论才发现是自己读题错误了，题目给出的条件是删除【给定的】节点！<br>
然后瞬间就想出答案了</p>
<pre><code>class Solution {
public:
    void deleteNode(ListNode* node) {
        node-&gt;val = node-&gt;next-&gt;val;
        node-&gt;next =  node-&gt;next-&gt;next;
        }
};
</code></pre>
<p>同时发现一个小问题，一开始在调用val数据成员时想按老习惯进行解引用(*)和调用符（.），由于解引用符的优先级低于调用符，所以是必需在解引用指针时加上括号的，于是就出现了下面的情况：</p>
<pre><code>class Solution {
public:
    void deleteNode(ListNode* node) {
        (*node).val = (*((*node).next)).val;
        (*node).next = (*((*node).next)).next;
        }
};
</code></pre>
<p>代码是自己写的自己还能懂，但是如果和同事交接时，这可读性可以说是惨不忍睹了...所以老习惯不一定是好习惯啊。<br>
这一次的心得体会：还是得好好看题！看清楚题目要求比一切都重要！同时基础要扎实！培养良好的代码风格！</p>
]]></content>
    </entry>
</feed>