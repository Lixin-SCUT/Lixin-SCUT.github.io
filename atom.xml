<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-03-18T09:16:54.430Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>In the darkest night,rising like a spire.</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[用户态和内核态]]></title>
        <id>https://lixin-scut.github.io//post/yong-hu-tai-he-nei-he-tai</id>
        <link href="https://lixin-scut.github.io//post/yong-hu-tai-he-nei-he-tai">
        </link>
        <updated>2020-03-18T08:35:09.000Z</updated>
        <content type="html"><![CDATA[<h3 id="用户态和内核态">用户态和内核态</h3>
<p>  当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核代码中执行。<br>
  当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。当进程在执行用户自己的代码时，则称其处于用户运行态（用 户态）。即此时处理器在特权级最低的（3级）用户代码中运行。<br>
  用户运行一个程序，该程序所创建的进程开始是运行在用户态的，如果要执行文件操作，网络数据发送等操作，必须通过write，send等系统调用，这些系统调用会调用内核中的代码来完成操作，这时，必须切换到Ring0，然后进入3GB-4GB中的内核地址空间去执行这些代码完成操作，完成后，切换回Ring3，回到用户态。这样，用户态的程序就不能 随意操作内核地址空间，具有一定的安全保护作用。</p>
<h3 id="区分内核态和用户态的原因">区分内核态和用户态的原因</h3>
<p>  在CPU中运行的操作系统程序和用户程序对应的机器指令集是不同的。操作系统程序使用所有指令，但用户程序只能使用部分指令。从资源管理和程序控制执行的角度出发，将指令系统分为两大部分：特权指令和非特权指令。在程序执行时，根据执行程序对资源和机器指令的使用权限，把机器设置为两个状态：内核态和用户态。<br>
  避免代码进行潜在危险的操作，以防止给操作系统带来安全隐患。系统调用与返回的情况下进行两种方式的转换。<br>
  用户态状态下，执行的代码被硬件限定，不能进行某些操作，比如写入其他进程的存储空间，以防止给操作系统带来安全隐患。内核禁止此状态下的代码进行潜在危险的操作，比如写入系统配置文件、杀掉其他用户的进程、重启系统等。</p>
<h3 id="用户态切换到内核态的3种方式">用户态切换到内核态的3种方式：</h3>
<ol>
<li>系统调用<br>
这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。</li>
<li>异常<br>
当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</li>
<li>外围设备的中断<br>
当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[编译与链接]]></title>
        <id>https://lixin-scut.github.io//post/bian-yi-yu-lian-jie</id>
        <link href="https://lixin-scut.github.io//post/bian-yi-yu-lian-jie">
        </link>
        <updated>2020-03-18T07:55:50.000Z</updated>
        <content type="html"><![CDATA[<p>其实叫编译过程是不对的，因为编译与链接都只是C++文本文件到可执行文件的一环，但是似乎大家是是习惯了叫做编译，我也暂时没想到好的名称来代替，就暂时只用这个博文名吧。</p>
<p><strong>预处理</strong></p>
<ul>
<li>
<p>展开所有的宏定义，完成字符常量替换。</p>
</li>
<li>
<p>处理条件编译语句，通过是否具有某个宏来决定过滤掉哪些代码。</p>
</li>
<li>
<p>处理#include指令，将被包含的文件插入到该指令所在位置。</p>
</li>
<li>
<p>过滤掉所有注释语句。</p>
</li>
<li>
<p>添加行号和文件名标识。</p>
</li>
<li>
<p>保留所有#pragma编译器指令。</p>
</li>
</ul>
<p><strong>编译</strong></p>
<ul>
<li>
<p>词法分析。</p>
</li>
<li>
<p>语法分析。</p>
</li>
<li>
<p>语义分析。</p>
</li>
<li>
<p>中间语言生成。</p>
</li>
<li>
<p>目标代码生成与优化。</p>
</li>
</ul>
<p><strong>链接</strong></p>
<p>各个源代码模块独立的被编译，然后将他们组装起来成为一个整体，组装的过程就是链接。被链接的各个部分本本身就是二进制文件，所以在被链接时需要将所有目标文件的代码段拼接在一起，然后将所有对符号地址的引用加以修正。</p>
<ul>
<li>
<p>静态链接</p>
<p>静态链接最简单的情况就是在编译时和静态库链接在一起成为完整的可执行程序。这里所说的静态库就是对多个目标文件（.o）文件的打包，通常静态链接的包名为<code>lib****.a</code>，静态链接所有被用到的目标文件都会复制到最终生成的可执行目标文件中。这种方式的好处是在运行时，可执行目标文件已经完全装载完毕，只要按指令序执行即可，速度比较快，但缺点也有很多</p>
</li>
</ul>
<p>静态链接是对目标文件的打包，打包命令如下</p>
<pre><code>    gcc -c test1.c    // 生成test1.o
    gcc -c test2.c    // 生成test2.c
    ar cr libtest.a test1.o test2.o
</code></pre>
<p>首先编译得到test1.o和test2.o两个目标文件，之后通过ar命令将这两个文件打包为.a文件，文件名格式为lib + 静态库名 + .a后缀。在生成可执行文件需要使用到它的时候只需要在编译时加上即可。需要注意的是，使用静态库时加在最后的名字不是libtest.a，而是l + 静态库名。</p>
<pre><code>    gcc -o main main.c -ltest
</code></pre>
<ul>
<li>
<p>动态链接</p>
<p>静态链接发生于编译阶段，加载至内存前已经完整，但缺点是如果多个程序都需要使用某个静态库，则该静态库会在每个程序中都拷贝一份，非常浪费内存资源，所以出现了动态链接的方式来解决这个问题。</p>
<p>动态链接在形式上倒是和静态链接非常相似，首先也是需要打包，打包成动态库，不过文件名格式为lib + 动态库名 + .so后缀。不过动态库的打包不需要使用ar命令，gcc就可以完成，但要注意在编译时要加上-fPIC选项，打包时加上-shared选项。</p>
<pre><code>  gcc -fPIC -c test1.c 
  gcc -fPIC -c test2.c
  gcc -shared test1.o test2.o -o libtest.so
</code></pre>
<p>使用动态链接的用法也和静态链接相同。</p>
<pre><code>  gcc -o main main.c -ltest
</code></pre>
</li>
</ul>
<p>如果仅仅像上面的步骤是没有办法正常使用库的，我们可以通过加-Lpath指定搜索库文件的目录（-L.表示当前目录），默认情况下会到环境变量LD_LIBRARY_PATH指定的目录下搜索库文件，默认情况是/usr/lib，我们可以将库文件拷贝到那个目录下再链接。</p>
<p>二者的优缺点：</p>
<ul>
<li>
<p>动态库运行时会先检查内存中是否已经有该库的拷贝，若有则共享拷贝，否则重新加载动态库（C语言的标准库就是动态库）。静态库则是每次在编译阶段都将静态库文件打包进去，当某个库被多次引用到时，内存中会有多份副本，浪费资源。</p>
</li>
<li>
<p>动态库另一个有点就是更新很容易，当库发生变化时，如果接口没变只需要用新的动态库替换掉就可以了。但是如果是静态库的话就需要重新被编译。</p>
</li>
<li>
<p>不过静态库也有优点，主要就是静态库一次性完成了所有内容的绑定，运行时就不必再去考虑链接的问题了，执行效率会稍微高一些。</p>
</li>
</ul>
<p><strong>链接</strong></p>
<p>符号解析</p>
<ul>
<li>
<p>可重定位目标文件</p>
<p>对于独立编译的可重定位目标文件，其ELF文件格式包括ELF头（指定文件大小及字节序）、.text（代码段）、.rodata（只读数据区）、.data（已初始化数据区）、.bss（未初始化全局变量）、.symtab（符号表）等，其中链接时最需要关注的就是符号表。每个可重定位目标文件都有一张符号表，它包含该模块定义和引用的符号的信息，简而言之就是我们在每个模块中定义和引用的全局变量（包括定义在本模块的全局变量、静态全局变量和引用自定义在其他模块的全局变量）需要通过一张表来记录，在链接时通过查表将各个独立的目标文件合并成一个完整的可执行文件。</p>
</li>
<li>
<p>解析符号表</p>
<p>解析符号引用的目的是将每个引用与可重定位目标文件的符号表中的一个符号定义联系起来。</p>
</li>
</ul>
<p>重定位</p>
<ul>
<li>
<p>合并节</p>
<p>多个可重定位目标文件中相同的节合并成一个完整的聚合节，比如多个目标文件的.data节合并成可执行文件的.data节。链接器将运行时存储地址赋予每个节，完成这步每条指令和全局变量都有运行时地址了。</p>
</li>
<li>
<p>重定位符号引用</p>
<p>这步修改全部代码节和数据节对每个符号的符号引用，使其指向正确的运行时地址。局部变量可以通过进栈、出栈临时分配，但全局变量（&quot;符号&quot;）的位置则是在各个可重定位目标文件中预留好的。通过上一步合并节操作后，指令中所有涉及符号的引用都会通过一定的寻址方式来定位该符号，比如相对寻址、绝对寻址等。</p>
</li>
</ul>
<p>可执行目标文件</p>
<ul>
<li>
<p>ELF头部</p>
<p>描述文件总体格式，并且包括程序的入口点（entry point），也就是程序运行时执行的第一条指令地址。</p>
</li>
<li>
<p>段头部表</p>
<p>描述了可执行文件数据段、代码段等各段的大小、虚拟地址、段对齐、执行权限等。实际上通过段头部表描绘了虚拟存储器运行时存储映像，比如每个UNIX程序的代码段总是从虚拟地址Ox0804800开始的。</p>
</li>
<li>
<p>其他段</p>
<p>和可重定位目标文件各段基本相同，但完成了多个节的合并和重定位工作。</p>
</li>
</ul>
<p><strong>加载</strong></p>
<ul>
<li>
<p>克隆</p>
<p>新程序的执行首先需要通过父进程外壳通过fork得到一个子进程，该子进程除了pid等标识和父进程不同外其他基本均与父进程相同。</p>
</li>
<li>
<p>重新映射</p>
<p>当子进程执行execve系统调用时会先清空子进程现有的虚拟存储器段（简而言之就是不再映射到父进程的各个段），之后重新创建子进程虚拟存储器各段和可执行目标文件各段的映射。这个阶段我们可以理解为对复制来的父进程页表进程重写，映射到外存中可执行文件的各个段。</p>
</li>
<li>
<p>虚页调入</p>
<p>加载过程并没有实际将磁盘中可执行文件调入内存，所做的工作仅仅是复制父进程页表、清空旧页表、建立新页表映射工作。之后加载器跳转到入口地址_start开始执行程序，接下来的过程需要配合虚拟存储器来完成。CPU获得指令的虚拟地址后，若包含该指令或数据的页尚未调入内存则将其从外存中调入，调入内存后修改页表得到虚拟页号和物理页号的对应关系。之后重新取同一条指令或数据时因该页已经被调入内存，所以通过虚拟地址得到虚拟页号，虚拟页号通过查页表可以得到物理页号，通过物理页号 + 页内偏移得到具体的物理地址，此时可以通过物理地址取得想要的数据。</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在main()函数之前执行代码]]></title>
        <id>https://lixin-scut.github.io//post/zai-mainhan-shu-zhi-qian-zhi-xing-dai-ma</id>
        <link href="https://lixin-scut.github.io//post/zai-mainhan-shu-zhi-qian-zhi-xing-dai-ma">
        </link>
        <updated>2020-03-18T07:22:16.000Z</updated>
        <content type="html"><![CDATA[<p>这个是一道面试题，挺有趣的，考察的也算是对已有知识的利用和知识面的广度。</p>
<p>1.利用全局对象和静态对象的性质<br>
在main函数之前声明一个类的全局的对象。那么其执行顺序，根据全局对象的生存期和作用域，肯定先于main函数。<br>
静态对象同理</p>
<p>2.attribute关键字<br>
gcc中可以使用attribute关键字，声明constructor和destructor函数</p>
<pre><code>__attribute__((constructor)) void before_main()  
{  
   printf(&quot;before main\n&quot;); 
}  
  
__attribute__((destructor)) void after_main()  
{  
   printf(&quot;after main\n&quot;);  
}
</code></pre>
<p>3.onexit函数<br>
microsoft的C++编译器支持onexit函数。原型如下：</p>
<pre><code>_onexit_t _onexit(
   _onexit_t function
);

_onexit_t_m _onexit_m(
   _onexit_t_m function
);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[覆盖、重载和隐藏的区别]]></title>
        <id>https://lixin-scut.github.io//post/fu-gai-chong-zai-he-yin-cang-de-qu-bie</id>
        <link href="https://lixin-scut.github.io//post/fu-gai-chong-zai-he-yin-cang-de-qu-bie">
        </link>
        <updated>2020-03-18T07:13:28.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>覆盖（override）是派生类中重新定义的函数，其函数名、参数列表（个数、类型和顺序）、返回值类型和父类完全相同，只有函数体有区别。派生类虽然继承了基类的同名函数，但用派生类对象调用该函数时会根据对象类型调用相应的函数。覆盖<strong>只能发生在类的成员函数</strong>中（对于override来说，一般用在虚函数上）。</li>
<li>隐藏是指派生类函数屏蔽了与其同名的函数，这里仅要求基类和派生类函数的函数名相同即可。隐藏比覆盖涵盖的范围更宽泛，毕竟参数不加限定。</li>
<li>重载是具有相同函数名但参数列表不同（个数、类型或顺序）的两个函数（不关心返回值），当调用函数时根据传递的参数列表来确定具体调用哪个函数。重载<strong>可以是同一个类的成员函数也可以是类外函数</strong>。</li>
<li>注意隐藏和重载的重要区别在于是否可见和候选函数，如果被隐藏了，等于优先级降低，所以可能直接不可见，无法作为候选函数，只有当前作用域没有适合的候选函数时才会到外层作用域考虑被隐藏的同名函数</li>
</ul>
<p><strong>重载和函数模板的区别</strong></p>
<ol>
<li>重载需要多个函数，这些函数彼此之间函数名相同，但参数列表中参数数量和类型不同。在区分各个重载函数时我们并不关心函数体。</li>
<li>模板函数是一个通用函数，函数的类型和形参不直接指定而用虚拟类型来代表。但只适用于形参个数相同而类型不同的函数。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深拷贝与浅拷贝]]></title>
        <id>https://lixin-scut.github.io//post/shen-kao-bei-yu-qian-kao-bei</id>
        <link href="https://lixin-scut.github.io//post/shen-kao-bei-yu-qian-kao-bei">
        </link>
        <updated>2020-03-18T06:59:01.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>浅拷贝：浅拷贝仅仅是拷贝向被指向对象的内存地址，如果原地址中对象被改变了，那么浅拷贝指向的对象也会相应改变。所以指针和引用的拷贝都属于浅拷贝</li>
<li>深拷贝：开辟了一块新的内存地址用于存放实际指向的对象，最后会存在两份相同的数据。</li>
<li>所以当同一类的不同对象互相赋值时，需要注意含有指针或引用的成员。特别是指向动态内存中的对象，如果B中有一个成员变量指针已经申请了动态内存，那A中的那个成员变量也指向同一块内存。这就会出现问题：当B把内存释放了，这时A的指针就是空悬指针了</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图 329. 矩阵中的最长递增路径[困难][未做出]]]></title>
        <id>https://lixin-scut.github.io//post/tu-329-ju-zhen-zhong-de-zui-chang-di-zeng-lu-jing-kun-nan-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/tu-329-ju-zhen-zhong-de-zui-chang-di-zeng-lu-jing-kun-nan-wei-zuo-chu">
        </link>
        <updated>2020-03-18T04:55:39.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个整数矩阵，找出最长递增路径的长度。<br>
对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。<br>
示例 1:<br>
输入: nums =<br>
[<br>
[9,9,4],<br>
[6,6,8],<br>
[2,1,1]<br>
]<br>
输出: 4<br>
解释: 最长递增路径为 [1, 2, 6, 9]。<br>
示例 2:<br>
输入: nums =<br>
[<br>
[3,4,5],<br>
[3,2,6],<br>
[2,2,1]<br>
]<br>
输出: 4<br>
解释: 最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>【未做出】<br>
首先我想用的是动态规划，但是很明显单纯的动态规划是不够的，<br>
因为动态规划需要依赖于过去的状态和状态转移方程，而我们无法从后面的信息去更新现有的信息（右下角更新左上角）<br>
所以看了题解之后发现果然是必须利用存储信息的<br>
利用存储信息然后不断地更新旧信息，从而使得不需要更新的信息只需要O(1)的时间复杂度<br>
代码如下：<br>
注意diretion数组，用于上下左右四个位置的转移，减少循环和判断条件的复杂度</p>
<pre><code>class Solution {
public:
    int longestIncreasingPath(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        if(matrix.empty())
        {   return 0; }
        row = matrix.size(); 
        col = matrix[0].size();
        
        vector&lt;vector&lt;int&gt;&gt; cache(row,vector&lt;int&gt;(col,0));
        int res = 0;
        
        for(int r = 0; r &lt; row; ++r )
        {
            for(int c = 0; c &lt; col; ++c)
            {
                int temp = longestIncreasingPath(matrix, r, c, cache);
                res = res &gt; temp? res : temp;
            }
        }
        
        return res;
    }
    
    int longestIncreasingPath(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int r, int c, vector&lt;vector&lt;int&gt;&gt;&amp; cache)
    {
        if(cache[r][c] != 0)
        {   return cache[r][c]; }
        
        for(auto d : direction)
        {
            if(r+d[0] &gt;= 0 &amp;&amp; r+d[0] &lt; row 
               &amp;&amp; c+d[1] &gt;= 0 &amp;&amp; c+d[1] &lt; col 
               &amp;&amp; matrix[r+d[0]][c+d[1]] &gt; matrix[r][c])
            {
                cache[r][c] = max(cache[r][c],longestIncreasingPath(matrix, r+d[0], c+d[1], cache));
        
            }
        }
        
        return ++cache[r][c];
    }

private:
    int row, col;
    vector&lt;vector&lt;int&gt;&gt; direction  = { { 0 , 1 }, { 1 , 0 }, { 0 , -1 }, { -1 , 0 } };
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>正文<br>
方法一：朴素的深度优先搜索 【超时】<br>
直觉<br>
深度优先搜索可以找到从任何单元格开始的最长递增路径。我们可以对全部单元格进行深度优先搜索。<br>
算法<br>
每个单元格可以看作图<br>
G 中的一个定点。若两相邻细胞的值满足a&lt;b，则存在有向边 (a,b)。问题转化成：<br>
寻找有向图 G 中的最长路径。<br>
很显然,我们可以使用深度优先搜索或广度优先搜索从根开始访问连接的所有细胞。在搜索期间更新路径的最大长度，并在搜索完成后得到答案。<br>
一般而言，在深度优先搜索或广度优先搜索中，我们可以使用集合visited 来避免重复访问。在下一节中我们将介绍基于此的更优算法。</p>
</blockquote>
<pre><code>// Naive DFS Solution
// Time Limit Exceeded
public class Solution {
  private static final int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
  private int m, n;

  public int longestIncreasingPath(int[][] matrix) {
      if (matrix.length == 0) return 0;
      m = matrix.length;
      n = matrix[0].length;
      int ans = 0;
      for (int i = 0; i &lt; m; ++i)
          for (int j = 0; j &lt; n; ++j)
              ans = Math.max(ans, dfs(matrix, i, j));
      return ans;
  }

  private int dfs(int[][] matrix, int i, int j) {
      int ans = 0;
      for (int[] d : dirs) {
          int x = i + d[0], y = j + d[1];
          if (0 &lt;= x &amp;&amp; x &lt; m &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; n &amp;&amp; matrix[x][y] &gt; matrix[i][j])
              ans = Math.max(ans, dfs(matrix, x, y));
      }
      return ++ans;
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 ：O(2^(m+n))。对每个有效递增路径均进行搜索。在最坏情况下，会有 O(2^(m+n)) 次调用。例如：<br>
空间复杂度 ： O(mn)。 对于每次深度优先搜索，系统栈需要 O(h) 空间，其中 h 为递归的最深深度。最坏情况下，O(h)=O(mn)。</p>
</blockquote>
<blockquote>
<p>解法二：记忆化深度优先搜索 【通过】<br>
直觉<br>
将递归的结果存储下来，这样每个子问题只需要计算一次。<br>
算法<br>
从上面的分析中，我们知道在淳朴的深度优先搜索方法中有许多重复的计算。<br>
一个优化途径是我们可以用一个集合来避免一次深度优先搜索中的重复访问。该优化可以将一次深度优先搜索的时间复杂度优化到 O(mn)<br>
O(mn)，总时间复杂度 O(m<sup>2*n</sup>2 )。<br>
下面介绍一个更有力的优化方法，记忆化。<br>
在计算中，记忆化是一种优化技术，它通过存储“昂贵”的函数调用的结果，在相同的输入再次出现时返回缓存的结果，以此加快程序的速度。<br>
在本问题中，我们多次递归调用 dfs(x, y) 。但是，如果我们已经知道四个相邻单元格的结果，就只需要常数时间。在搜索过程中，如果未计算过单元格的结果，我们会计算并将其缓存；否则，直接从缓存中获取之。<br>
Java</p>
</blockquote>
<pre><code>// DFS + Memoization Solution
// Accepted and Recommended
public class Solution {
    private static final int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    private int m, n;

    public int longestIncreasingPath(int[][] matrix) {
        if (matrix.length == 0) return 0;
        m = matrix.length; n = matrix[0].length;
        int[][] cache = new int[m][n];
        int ans = 0;
        for (int i = 0; i &lt; m; ++i)
            for (int j = 0; j &lt; n; ++j)
                ans = Math.max(ans, dfs(matrix, i, j, cache));
        return ans;
    }

    private int dfs(int[][] matrix, int i, int j, int[][] cache) {
        if (cache[i][j] != 0) return cache[i][j];
        for (int[] d : dirs) {
            int x = i + d[0], y = j + d[1];
            if (0 &lt;= x &amp;&amp; x &lt; m &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; n &amp;&amp; matrix[x][y] &gt; matrix[i][j])
                cache[i][j] = Math.max(cache[i][j], dfs(matrix, x, y, cache));
        }
        return ++cache[i][j];
    }
}

</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 : O(mn)。 每个顶点/单元格均计算一次，且只被计算一次。每条边也均计算一次并只计算一次。总时间复杂度是 O(V+E)。V 是顶点总数，E 是边总数。本问题中，O(V)=O(mn)，O(E)=O(4V)=O(mn)。<br>
空间复杂度 : O(mn)。缓存决定了空间复杂度。</p>
</blockquote>
<blockquote>
<p>方法三：“剥洋葱”（动态规划） 【通过】<br>
直觉<br>
每个细胞的结果只与相邻的结果相关，能否使用动态规划？<br>
算法<br>
如果我们定义从单元格 (i,j) 开始的最长递增路径为函数f(i,j)<br>
则可以写出状态转移函数<br>
<code>f(i,j)=max{f(x,y)∣(x,y) is a nei∗∗∗or of(i,j) and matrix[x][y]&gt;matrix[i][j]}+1</code><br>
此公式与以前方法中使用的公式相同。有了状态转移函数，你可能会觉得可以使用动态规划来推导出所有结果，去他的深度优先搜索!<br>
这听起来很美好，可惜你忽略了一件事：我们没有依赖列表。<br>
想要让动态规划有效，如果问题 B 依赖于问题 A 的结果，就必须确保问题 A 比问题 B先计算。这样的依赖顺序对许多问题十分简单自然。如著名的斐波那契数列：<br>
F(0)=1,F(1)=1,F(n)=F(n−1)+F(n−2)<br>
子问题 F(n) 依赖于 F(n−1) 和 F(n−2)。因此，自然顺序就是正确的计算顺序。被依赖者总会先被计算。<br>
这种依赖顺序的术语是“拓扑顺序”或“拓扑排序”：<br>
对有向无环图的拓扑排序是顶点的一个线性排序，使得对于任何有向边 (u,v)，顶点 u 都在 顶点 v 的前面。<br>
在本问题中，拓扑顺序并不简单自然。没有矩阵的值，我们无法知道两个邻居 A 和 B 的依赖关系。作为预处理，我们必须显式执行拓扑排序。之后，我们可以按照存储的拓扑顺序使用状态转移函数动态地解决问题。<br>
有多种实现拓扑排序的方法。这里我们使用的是一种被称为“剥洋葱”的方法。其思路是在一个有向无环图中，会有一些不依赖于其他顶点的顶点，称为“叶子”。我们将这些叶子放在一个列表中（他们的内部排序不重要），然后将他们从图中移除。移除之后，会产生新的“叶子”。重复以上过程，就像一层一层一层地拨开洋葱的心。最后，列表中就会存储有效的拓扑排序。<br>
在本问题中，因为我们想要求出在整个图中最长的路径，也就是“洋葱”的层总数。因此，我们可以在“剥离”的期间计算层数，在不调用动态规划的情况下返回计数。</p>
</blockquote>
<pre><code>// Topological Sort Based Solution
// An Alternative Solution
public class Solution {
    private static final int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    private int m, n;
    public int longestIncreasingPath(int[][] grid) {
        int m = grid.length;
        if (m == 0) return 0;
        int n = grid[0].length;
        // padding the matrix with zero as boundaries
        // assuming all positive integer, otherwise use INT_MIN as boundaries
        int[][] matrix = new int[m + 2][n + 2];
        for (int i = 0; i &lt; m; ++i)
            System.arraycopy(grid[i], 0, matrix[i + 1], 1, n);

        // calculate outdegrees
        int[][] outdegree = new int[m + 2][n + 2];
        for (int i = 1; i &lt;= m; ++i)
            for (int j = 1; j &lt;= n; ++j)
                for (int[] d: dir)
                    if (matrix[i][j] &lt; matrix[i + d[0]][j + d[1]])
                        outdegree[i][j]++;

        // find leaves who have zero out degree as the initial level
        n += 2;
        m += 2;
        List&lt;int[]&gt; leaves = new ArrayList&lt;&gt;();
        for (int i = 1; i &lt; m - 1; ++i)
            for (int j = 1; j &lt; n - 1; ++j)
                if (outdegree[i][j] == 0) leaves.add(new int[]{i, j});

        // remove leaves level by level in topological order
        int height = 0;
        while (!leaves.isEmpty()) {
            height++;
            List&lt;int[]&gt; newLeaves = new ArrayList&lt;&gt;();
            for (int[] node : leaves) {
                for (int[] d:dir) {
                    int x = node[0] + d[0], y = node[1] + d[1];
                    if (matrix[node[0]][node[1]] &gt; matrix[x][y])
                        if (--outdegree[x][y] == 0)
                            newLeaves.add(new int[]{x, y});
                }
            }
            leaves = newLeaves;
        }
        return height;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 : O(mn)。拓扑排序的时间复杂度为 O(V+E)=O(mn)。V 是顶点总数，<br>
E 是边总数。本问题中，O(V)=O(mn)，O(E)=O(4V)=O(mn)。<br>
空间复杂度 : O(mn)。我们需要存储出度和每层的叶子。<br>
要点<br>
记忆化: 对于大量重复调用的问题，缓存其结果。<br>
动态规划要求按照拓扑顺序解决子问题。对于很多问题，拓扑顺序与自然秩序一致。而对于那些并非如此的问题，需要首先执行拓扑排序。因此,对于复杂拓扑问题（如本题），使用记忆化搜索通常是更容易更好的选择。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表的环问题]]></title>
        <id>https://lixin-scut.github.io//post/lian-biao-de-huan-wen-ti</id>
        <link href="https://lixin-scut.github.io//post/lian-biao-de-huan-wen-ti">
        </link>
        <updated>2020-03-17T02:16:14.000Z</updated>
        <content type="html"><![CDATA[<p>因为链表的环问题比较多，我直接整理为一个博文，方便查阅</p>
<p>相关博文传送门<br>
<a href="https://lixin-scut.github.io/post/lian-biao-142-huan-xing-lian-biao-iizhong-deng-wei-zuo-chu/">链表 142. 环形链表 II[中等]</a><br>
<a href="https://lixin-scut.github.io/post/lian-biao-141-huan-xing-lian-biao-nan-du-jian-dan/">链表 141. 环形链表 难度：简单</a><br>
<a href="https://lixin-scut.github.io/post/lian-biao-ti-23lian-biao-zhong-huan-de-ru-kou-jie-dian/">链表 题23:链表中环的入口节点</a></p>
<p>链表的环问题主要可以分为下面几个部分：</p>
<ol>
<li>链表长度</li>
<li>链表是否有环</li>
<li>链表环入口</li>
<li>链表环长度<br>
下面就逐一解决</li>
</ol>
<h3 id="单链表长度">单链表长度</h3>
<p><strong>思路：</strong><br>
这个比较简单，直接遍历一次并计数即可<br>
<strong>代码：</strong></p>
<pre><code>//计算单链表长度
int lengthNode(Node *node)
{
	if (nullptr == node) // 防止漏写= 变为 赋值node为空指针
	{
		cout &lt;&lt; &quot;error&quot; &lt;&lt; endl;
		return 0;
	}
	int length= 0;
	Node *pTmp = node;
	while (pTmp-&gt;next) //从头到尾遍历链表，计数器依次累加
	{
		pTmp = pTmp-&gt;next;
		++length;
	}
	return length;
}
</code></pre>
<h3 id="单链表是否有环">单链表是否有环</h3>
<p><strong>思路：</strong><br>
  设置两个指针，都指向头结点，一个走的快，一个走的慢，<br>
  如果有环，那么若干步以后，快指针总会超过慢的指针一圈；<br>
  如果没有，那么若干步以后，快指针指向NULL。</p>
<p><strong>数学证明：</strong></p>
<blockquote>
<p>根据floyd判圈办法，一个快指针一个慢指针，二者一定在环上相遇，设相遇点为M点，<br>
快是慢的速度的2倍，时间相同，设慢的距离为s，那么快的距离为2s<br>
m为链表头距离环开始位置的距离，k为环开始位置到M点的距离, N为环长度<br>
s = m + aN +k, 2s = m + bN +k，二者相减，s = (a-b)*N<br>
由此可见，慢指针走过的距离是环长的整数倍，即链表头到M点是环长的整数倍<br>
如果是1倍的话，把m截距离旋转到环上，跟环融合，那么链表头一定落在M点，<br>
即fast和slow都落在M点，那么二者到环开始位置距离相同，必然在此处相遇。<br>
如果是N倍（N&gt;1）时，只不过slow指针多转几圈而已，后二者仍在此处相遇</p>
</blockquote>
<p><strong>代码</strong></p>
<pre><code>bool hasCycle(ListNode *head) {
        if(!head)
            return false;
        ListNode *fast=head-&gt;next;
        ListNode *slow=head;
        while(fast!=slow){
            if(fast==NULL||fast-&gt;next==NULL)
                return false;
            fast=fast-&gt;next-&gt;next;
            slow=slow-&gt;next;
        }
        return true;
    }
</code></pre>
<h3 id="单链表环入口">单链表环入口</h3>
<p><strong>思路</strong><br>
  依然使用双指针法。首先使得两个指针相遇<br>
  然后slow指针位置不变 ，将fast指针重新指向链表头部节点 ；slow和fast同时每轮向前走 1 步；<br>
  两指针重合时指向链表环入口 。<br>
  返回slow指针指向的节点。</p>
<p><strong>数学证明</strong></p>
<blockquote>
<p>双指针第一次相遇： 设两指针 fast，slow 指向链表头部 head，fast 每轮走 2 步，slow 每轮走 1 步；<br>
当fast == slow时， 两指针在环中 第一次相遇 。<br>
下面分析此时fast 与 slow走过的 步数关系 ：<br>
设链表共有 a+b 个节点，其中 链表头部到链表入口 有 a 个节点（不计链表入口节点）， 链表环 有 b 个节点（这里需要注意，a 和 b 是未知数）；设两指针分别走了f，s 步，则有：<br>
fast 走的步数是slow步数的 2 倍，即 f=2s；（解析： fast 每轮走 2 步）<br>
fast 比 slow多走了 n 个环的长度，即f=s+nb；（ 解析： 双指针都走过 a 步，然后在环内绕圈直到重合，重合时 fast 比 slow 多走 环的长度整数倍 ）；<br>
以上两式相减得：f=2nb，s=nb，即fast和slow 指针分别走了 2n，n个环的周长 （注意： n 是未知数，不同链表的情况不同）。<br>
目前情况分析：<br>
如果让指针从链表头部一直向前走并统计步数k，那么所有 走到链表入口节点时的步数 是：k=a+nb（先走 a 步到入口节点，之后每绕 1 圈环（ b 步）都会再次到入口节点）。<br>
而目前，slow 指针走过的步数为 nb 步。因此，我们只要想办法让 slow 再走 a 步停下来，就可以到环的入口。<br>
但是我们不知道 a 的值，该怎么办？依然是使用双指针法。我们构建一个指针，此指针需要有以下性质：此指针和slow 一起向前走 a 步后，两者在入口节点重合。那么从哪里走到入口节点需要 a 步？答案是链表头部head。<br>
双指针第二次相遇：<br>
slow指针位置不变 ，将fast指针重新 指向链表头部节点 ；slow和fast同时每轮向前走 1 步；<br>
TIPS：此时 f=0，s=nb ；<br>
当 fast 指针走到f=a 步时，slow 指针走到步s=a+nb，此时 两指针重合，并同时指向链表环入口 。<br>
返回slow指针指向的节点。</p>
</blockquote>
<p><strong>代码</strong></p>
<pre><code>ListNode *detectCycle(ListNode *head)
{
        if(nullptr == head) 
				{ return NULL; }
        ListNode *fast = head-&gt;next,*slow=head;
        while(fast != slow)
				{
            if(nullptr != fast &amp;&amp; nullptr != fast-&gt;next)
						{
                fast = fast-&gt;next-&gt;next; //注意判断条件和两次连续next，没必要分开两次判断next
						}
            else
             {   return NULL; }
            slow = slow-&gt;next;
        }
        fast = head;
        slow = slow-&gt;next;//注意这里，因为fast=head;相当于提前走了一步
        while(fast != slow)
       {     
						 fast = fast-&gt;next;
						 slow = slow-&gt;next;
				 }
        return slow;     
}
</code></pre>
<h3 id="单链表环长度">单链表环长度</h3>
<p><strong>思路</strong><br>
  快慢指针第一次相遇（超一圈）时开始计数，计数器累加，第二次相遇时停止计数<br>
  第二次相遇的时候快指针比慢指针正好又多走了一圈，也就是多走的距离等于环长</p>
<p><strong>代码：</strong></p>
<pre><code>//计算单链表环的长度  
int loopLength(pNode pHead)  
{  
	//首先通过上面的借口判断，链表是否有环
	if(isLoop(pHead) == false) 
	{
		return 0;  //没有环，则直接返回
	}
	pNode fast = pHead;  
	pNode slow = pHead;  
	int length = 0;  //环的长度
	bool begin = false;  //第一次相遇的 flag
	bool agian = false;  //第二次相遇的 flag
	while( fast != NULL &amp;&amp; fast-&gt;next != NULL)  
	{  
		fast = fast-&gt;next-&gt;next;  
		slow = slow-&gt;next;  
		//超两圈后停止计数，挑出循环  
		if(fast == slow &amp;&amp; agian == true)  
		{
			break;  
		}
		
		//超一圈后开始计数  
		if(fast == slow &amp;&amp; agian == false)  
		{             
			begin = true;  
			agian = true;  
		}  
		
		//计数 +1  
		if(begin == true)  
		{
			++length;
		}
	}  
	
	return length;  
} 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[volatile关键字]]></title>
        <id>https://lixin-scut.github.io//post/volatile-guan-jian-zi</id>
        <link href="https://lixin-scut.github.io//post/volatile-guan-jian-zi">
        </link>
        <updated>2020-03-16T10:32:07.000Z</updated>
        <content type="html"><![CDATA[<p>  volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。<br>
  遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，比如<br>
  <code>int num1 = numConst; int num2 = numConst;</code><br>
  由于编译器认为num2和num1所需赋的值一致，可能会把寄存器中num1的值直接给num2，但是多线程中很可能numConst已经被另一个线程改变了，从而导致num2的值不正确。<br>
  如果使用volatile来限定numConst，则可以提供对特殊地址的稳定访问。声明时语法：<br>
  <code>int volatile vInt;</code><br>
  当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。<br>
volatile用在如下的几个地方：</p>
<ol>
<li>中断服务程序中修改的供其它程序检测的变量需要加volatile；</li>
<li>多进程或多线程的并行并发环境下各任务间共享的标志应该加volatile；</li>
<li>存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；</li>
</ol>
<p>详细用法可参考<a href="https://www.cnblogs.com/god-of-death/p/7852394.html">C/C++ Volatile关键词深度剖析</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Effective C++摘录]]></title>
        <id>https://lixin-scut.github.io//post/effective-czhai-lu</id>
        <link href="https://lixin-scut.github.io//post/effective-czhai-lu">
        </link>
        <updated>2020-03-16T10:04:08.000Z</updated>
        <content type="html"><![CDATA[<p>今天遇到一道题：</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

class A {
public:
    virtual void foo(int a = 0) {
        cout &lt;&lt; a &lt;&lt; endl;
    }
};

class B : public A {
public:
    virtual void foo(int a = 1) {
        cout &lt;&lt; a &lt;&lt; endl;
    }
};

int main() {
    A* p = new B();
    p-&gt;foo();
}
</code></pre>
<p>问输出是啥？<br>
很明显问题在于默认值<br>
根据条款37:绝不重新定义继承而来的缺省参数值，因为缺省参数值是静态的，所以输出为0.<br>
感受到了Effective C++的强大，所以特地整合一下Effective的大概条款，方便以后扩充</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[网络状态分析工具]]></title>
        <id>https://lixin-scut.github.io//post/wang-luo-zhuang-tai-fen-xi-gong-ju</id>
        <link href="https://lixin-scut.github.io//post/wang-luo-zhuang-tai-fen-xi-gong-ju">
        </link>
        <updated>2020-03-16T08:50:37.000Z</updated>
        <content type="html"><![CDATA[<h3 id="ping">ping</h3>
<p>  ping （ Packet Internet Groper,因特网包探索器）是 Windows、UNIX 和 Linux 系统下的 一个命令。ping也属于一个通信协议，是TCP/IP协议的一部分。利用ping命令可以检查网 络是否连通，可以很好地帮助分析和判定网络故障。应用格式：<code>ping IPAddress</code>，该命令还可以加许多参数使用<br>
<img src="https://lixin-scut.github.io//post-images/1584348819311.png" alt=""><br>
  ping 发送一个 ICMP （Internet Control Messages Protocol,因特网信报控制协议），请求 消息给目的地并报告是否收到所希望的ICMP echo （ICMP回声应答），它是用来检查网络是否通畅或者网络连接速度的命令。<br>
  ping所利用的原理是这样的：利用网络上机器IP地址的唯一性，给目标IP地址发送一个数据包，再要求对方返回一个同样大小的数据包来确定两台网络机器是否连接相通以及时延是 多少。<br>
  ping指的是端对端连通，通常用来作为可用性的检查，</p>
<p>  Ping程序使用的是ICMP协议，并不具有通常所说的 TCP/UDP 端口<br>
  ICMP不像TCP或UDP有端口，但它确实含有两个域：类型(type)和代码(code)。而且这些域的作用和端口也完全不同<br>
  ping没有指定端口这个选项，它是网络层的，端口是传输层的概念。</p>
<p><strong>ping的使用</strong><br>
使用ping检查连通性有以下6个步骤。<br>
(1)使用ipconfig/all观察本地网络设置是否正确。<br>
(2) ping 127.0.0.1,来检查本地的TCP/IP协议有没有设置好。<br>
(3) ping本机IP地址，这样是为了检查本机的IP地址是否设置有误。<br>
(4) ping本网网关或本网IP地址，这样的是为了检查硬件设备是否有问题，也可以检 查本机与本地网络连接是否正常。(在非局域网中这一步骤可以忽略)<br>
(5) ping本地DNS地址，这样做是为了检查本地DNS服务器是否工作正常。<br>
(6) ping远程IP地址，这主要是检查本网或本机与外部的连接是否正常。ping远程IP 地址还可以用来测试网络延时。比如输入“pingwww.baidu.com”(百度域名)之后屏幕会显示<br>
  Linux的ping语法和Windows的差不多，但是Linux的ping数据包是64Byte,而 Windows的是32Byte, Windows下默认发送4次数据包后结束，Linux下的ping程序默认不停发送数据包，直到用户手动停止（停止指令是Ctrl+c）</p>
<h3 id="tcpdump">tcpdump</h3>
<p>  tcpdump可以将网络中传送的数据包的“头”完全截获下来提供分析。<br>
  它支持针 对协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助去掉无用 的信息。<br>
  由于它需要将网络界面设置为混杂模式，普通 用户不能正常执行，但具备root权限的用户可以直接执行它来获取网络上的信息。因此 系统中存在网络分析工具主要不会对本机安全产生威胁，而是会对网络上的其他计算机 的安全产生威胁。</p>
<p>  tcpdump根据使用者的定义对网络上的数据包进行截获和分析。<br>
  tcpdump支持相当多的不同参数，如使用-i参数指定tcpdump监听的网络界面，这在计 算机具有多个网络界面时非常有用；使用-c参数指定要监听的数据包数量，使用-w参数指 定将监听到的数据包写入文件中保存，等等。<br>
  tcpdump使用参数指定要监视数据包的类型、地址、端口等</p>
<p><strong>tcpdump使用</strong><br>
tcpdump采用命令行方式，它的命令格式为：</p>
<pre><code>tcpdump [ -adefInNOpqStvx ] [ -c 数量][-F 文件名]
[-i 网络接口 ] [ -r 文件名][-s snaplen ]
[-T类型][-w文件名][表达式]
</code></pre>
<p>  表达式是一个正则表达式，tcpdump利用它作为过滤报文的条件，如果一个报文满足表 达式的条件，则这个报文将会被捕获。如果没有给出任何条件，则网络上所有的信息包将会 被截获。在表达式中一般包含如下几种类型的关键字。<br>
1	）关于类型的关键字，主要包括host、net、port等，例如host 指明 一台主机，net 指明一个网络地址，port 指明端口号。如果没有指定类型，默认的类型是host。<br>
2	）确定传输方向的关键字，主要包括src、dst、dstorsrc、dst、src等，这些关键字 指明了传输的方向。举例说明，src指明IP包中源地址, dst net指明目的网络地址。如果没有指明方向关键字，则默认是src or dst关键字。<br>
3	）协议的关键字，主要包括fddi、ip、arp、rarp、tcp、udp等类型。如果没有指定任何协议，则tcpdump将会监听 所有协议的信息包。<br>
除了这3种类型的关键字之外，其他重要的关键字如下：gateway、broadcast、less、 greater等，还有3种逻辑运算：取非运算not/!,与运算and/&amp;&amp; ；或运算or/| | ；这些关键字可以组合起来构成强大的组合条件</p>
<p><strong>常用命令</strong><br>
1 ）截取某主机相关的包。<br>
a.	想要截获所有210.27.48.1的主机收到的和发出的所有的数据包，使用如下命令：<br>
<code>tcpdump host 210.27.48.1</code><br>
b.	想要截获主机210.27.48.1和主机210.27.48.2或210.27.48.3的通信，使用如下命令： （在命令行中使用括号时，一定要添加“\”）<br>
<code>tcpdump host 210.27.48.1 and \ (210.27.48.2 or 210.27.48.3 \）</code><br>
C.如果想要获取主机210.27.48.1除了和主机210.27.48.2之外所有主机通信的ip包，使 用如下命令：<br>
<code>tcpdump ip host 210.27.48.1 and ! 210.27.48.2</code><br>
d.如果想要获取主机210.27.48.1接收或发出的telnet包，使用如下命令：<br>
<code>tcpdump tcp port 23 host 210.27.48.1</code></p>
<p>2）	截取某端口相关的包。<br>
如果想要获取在端口 6666上通过的包，使用如下命令：<br>
<code>tcpdump port 6666</code></p>
<p>3）	截取某网卡的包。<br>
如果想要获取在网卡ethl上通过的包，使用如下命令：<br>
<code>tcpdump -iethl</code></p>
<h3 id="netstat">netstat</h3>
<p>  netstat命令用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本 机各端口的网络连接情况。netstat是在内核中访问网络及相关信息的程序，它能提供TCP连 接、对TCP和UDP的监听及获取进程内存管理的相关报告。</p>
<p>netstat的命令格式如下所示：<br>
netstat [-acCeFghilMnNoprstuvVwx] [-A&lt; 网络类型 &gt;][--ip]</p>
<p>  ①Active Internet connections, 称为有源TCP连接，其中Recv-Q和Send-Q指的是接收队列和发送队列，这些数字一般都 应该是0,如果不是则表示请求包和回包正在队列中堆积；<br>
  ②Active UNIX domain sockets, 称为有源UNIX域套接口<br>
  Proto显示连接使用的协议，RefCnt表示连接到本套接口上的进程号，Types显示套接口 的类型，State显示套接口当前的状态，Path表示连接到套接口的其他进程使用的路径名。<br>
常见参数如下所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-a</td>
<td style="text-align:center">(all)显示所有选项，默认不显示LISTEN相关</td>
</tr>
<tr>
<td style="text-align:center">-t</td>
<td style="text-align:center">(tcp)仅显示tcp相关选项</td>
</tr>
<tr>
<td style="text-align:center">-u</td>
<td style="text-align:center">(udp)仅显示udp相关选项</td>
</tr>
<tr>
<td style="text-align:center">-n</td>
<td style="text-align:center">拒绝显示别名，能显示数字的全部转化成数字。</td>
</tr>
<tr>
<td style="text-align:center">-l</td>
<td style="text-align:center">仅列出有在Listen (监听)的服务状态</td>
</tr>
<tr>
<td style="text-align:center">-P</td>
<td style="text-align:center">显示建立相关链接的程序名</td>
</tr>
<tr>
<td style="text-align:center">-r</td>
<td style="text-align:center">显示路由信息，路由表</td>
</tr>
<tr>
<td style="text-align:center">-e</td>
<td style="text-align:center">显示扩展信息，例如uid等</td>
</tr>
<tr>
<td style="text-align:center">-s</td>
<td style="text-align:center">按各个协议进行统计</td>
</tr>
<tr>
<td style="text-align:center">-c</td>
<td style="text-align:center">每隔一个固定时间，执行该netstat命令。</td>
</tr>
</tbody>
</table>
<p>提示：LISTEN和LISTENING的状态只有用-a或者才能看到</p>
<p>使用例子</p>
<table>
<thead>
<tr>
<th style="text-align:center">功能</th>
<th style="text-align:center">命令</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">(1)列出所有端口(包括监听和未监听的)：</td>
<td style="text-align:center">netstat -ao</td>
</tr>
<tr>
<td style="text-align:center">(2)列出所有 TCP 端 口:</td>
<td style="text-align:center">netstat -ato</td>
</tr>
<tr>
<td style="text-align:center">(3)列出所有 UDP 端口 :</td>
<td style="text-align:center">netstat -auo</td>
</tr>
<tr>
<td style="text-align:center">(4)列出所有处于监听状态的socket：</td>
<td style="text-align:center">netstat -lo</td>
</tr>
<tr>
<td style="text-align:center">(5)列出所有监听 TCP 端口的 socket：</td>
<td style="text-align:center">netstat -lto</td>
</tr>
<tr>
<td style="text-align:center">(6)列出所有监听 UDP 端口的 socket:</td>
<td style="text-align:center">netstat -luo</td>
</tr>
<tr>
<td style="text-align:center">(7)歹！J 出所有监听 UNIX 端口的 socket:</td>
<td style="text-align:center">netstat -lx。</td>
</tr>
<tr>
<td style="text-align:center">(8)在netstat输出中显示PID和进程名称：</td>
<td style="text-align:center">netstat -po</td>
</tr>
<tr>
<td style="text-align:center">(9)当你不想让主机，端口和用户名显示，使用数字代替那些名称。</td>
<td style="text-align:center">netstat-n</td>
</tr>
<tr>
<td style="text-align:center">(10)持续输出 netsta 信息:</td>
<td style="text-align:center">netstat -co</td>
</tr>
<tr>
<td style="text-align:center">(11)找出程序运行的端口 ：</td>
<td style="text-align:center">netstat -ap</td>
</tr>
<tr>
<td style="text-align:center">(12)找出运行在指定端口的进程，如</td>
<td style="text-align:center">netstat -an</td>
</tr>
<tr>
<td style="text-align:center">(13)显式网络接口列表：</td>
<td style="text-align:center">netstat -io</td>
</tr>
</tbody>
</table>
<p>(14) IP和TCP的分析，如查看链接某服务端口最多的IP地址命令是：<br>
<code>netstat -nat | grep &quot;192.168.1.15:22&quot; |awk '{print $5}'|awk -F: '(print $1 }'|sort|uniq -c|sort -nr|head -20</code><br>
(15) TCP 各自状态列表： <code>netstat -nat |awk '{print $6}'</code><br>
(16)先把各种TCP状态全都取出来，然后使用uniq -c统计，之后再进行排序：  <code>netstat -nat |awk'{print $6}'|sort|uniq -c</code></p>
<p><strong>netstat 常用命令详解</strong><br>
netstat 命令：用于显示各种网络相关信息，如网络连接，路由表，接口状态，无效连接，组播成员 等等。<br>
netstat命令是net-tools软件包中的一员<br>
<img src="https://lixin-scut.github.io//post-images/1583486844848.png" alt=""></p>
<p><strong>命令行选项：</strong><br>
-a:　　列出系统中所有网络连接，包括已经连接的网络服务、监听的网络服务和Socket套接字<br>
-t：　　列出TCP数据<br>
-u：　　列出UDP数据<br>
-l：　　列出正在监听的网络服务（不包含已经连接的网路服务）<br>
-n：　　用端口显示服务，而不用服务名<br>
-p：　　列出该服务的进程ID(PID)</p>
<p><strong>互联网联机字段:</strong><br>
 Proto :网络的封包协议，主要分为 TCP 与 UDP 封包，相关资料请参考服务器篇;<br>
 Recv-Q:非由用户程序链接到此 socket 的复制的总 bytes 数;<br>
 Send-Q:非由远程主机传送过来的 acknowledged 总 bytes 数;<br>
 Local Address :本地端的 IP:port 情况<br>
 Foreign Address:远程主机的 IP:port 情况<br>
 State :联机状态，主要有建立(ESTABLISED)及监听(LISTEN);</p>
<p><strong>本地socket file 的字段:</strong><br>
 Proto :一般就是 unix ;<br>
 RefCnt:连接到此 socket 的进程数量;<br>
 Flags :联机的旗标;<br>
 Type :socket 存取的类型。主要有确认联机的 STREAM 与不需确认的 DGRAM 两种;<br>
 State :若为 CONNECTED 表示多个进程之间已经联机建立。<br>
 Path :连接到此 socket 的相关程序的路径!或者是相关数据输出的路径。</p>
<p>例子：netstat -tlunp<br>
除了可以列出监听网络的接口与状态之外，最后一个字段还能够显示此服务的PID 号码以及进程的指令名称<br>
<img src="https://lixin-scut.github.io//post-images/1583487282316.png" alt=""><br>
使用netstat -an<br>
<img src="https://lixin-scut.github.io//post-images/1583487403214.png" alt=""></p>
<p><strong>完整选项</strong></p>
<pre><code>usage: netstat [-vWeenNcCF] [&lt;Af&gt;] -r         netstat {-V|--version|-h|--help}
       netstat [-vWnNcaeol] [&lt;Socket&gt; ...]
       netstat { [-vWeenNac] -i | [-cnNe] -M | -s [-6tuw] }

      -r, --route              display routing table
        -i, --interfaces         display interface table
        -g, --groups             display multicast group memberships
        -s, --statistics         display networking statistics (like SNMP)
        -M, --masquerade         display masqueraded connections

        -v, --verbose            be verbose
        -W, --wide               don't truncate IP addresses
        -n, --numeric            don't resolve names
        --numeric-hosts          don't resolve host names
        --numeric-ports          don't resolve port names
        --numeric-users          don't resolve user names
        -N, --symbolic           resolve hardware names
        -e, --extend             display other/more information
        -p, --programs           display PID/Program name for sockets
        -o, --timers             display timers
        -c, --continuous         continuous listing

        -l, --listening          display listening server sockets
        -a, --all                display all sockets (default: connected)
        -F, --fib                display Forwarding Information Base (default)
        -C, --cache              display routing cache instead of FIB
        -Z, --context            display SELinux security context for sockets

  &lt;Socket&gt;={-t|--tcp} {-u|--udp} {-U|--udplite} {-S|--sctp} {-w|--raw}
           {-x|--unix} --ax25 --ipx --netrom
  &lt;AF&gt;=Use '-6|-4' or '-A &lt;af&gt;' or '--&lt;af&gt;'; default: inet
</code></pre>
<p><strong>例子</strong><br>
(1)已知进程名，使用命令查看当前进程打开的文件句柄?<br>
执行命令“ulimit -a”,其中oepn files 对应的即为本机文件句柄数<br>
lsof -n |awk '{print $2}'|sort|uniq -c |sort -nr|more</p>
<p>[root@study ~]# lsof [-aUu] [+d]<br>
选项与参数:<br>
-a :多项数据需要『同时成立』才显示出结果时!<br>
-U :仅列出 Unix like 系统的 socket 文件类型;<br>
-u :后面接 username，列出该使用者相关进程所开启的文件; +d :后面接目录，亦即找出某个目录底下已经被开启的文件!</p>
<p>(2)已知进程名，使用命令查看当前进程的网络连接状态?<br>
netstat -tlunp<br>
(3)已知进程名，查看 eth0 网卡与 ip10.10.10.10:10653 之间的 TCP 数据包?<br>
tcpdump -i eth0 -nn 'tcp and port 10653 and host 10.1.1.180'</p>
<h3 id="lsof">lsof</h3>
<p>  lsof (list open file)是一个列出当前系统打开文件的工具。在Linux环境下，任何事物都 以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。所以 如传输控制协议(TCP)和用户数据报协议(UDP)套接字等，系统在后台都为该应用程序分 配了一个文件描述符，无论这个文件的本质如何，该文件描述符为应用程序与基础操作系统 之间的交互提供了通用接口。因为应用程序打开文件的描述符列表提供了大量关于这个应用 程序本身的信息，因此通过lsof工具能够查看这个列表对系统监测以及排错将是很有帮助的。<br>
  在终端下输入lsof即可显示系统打开的文件，因为lsof需要访问核心内存和各种文件, 所以必须以root用户的身份运行才能够充分地发挥其功能。</p>
<p><strong>输出结果</strong><br>
(1)每行显示一个打开的文件，若不指定条件默认将显示所有进程打开的所有文件。<br>
lsof输出各列信息的意义如下所述。</p>
<ol>
<li>COMMAND：进程的名称。</li>
<li>PlD：进程标识符。</li>
<li>USER：进程所有者。</li>
<li>FD：文件描述符，应用程序通过文件描述符识别该文件如cwd、txt等。</li>
<li>TYPE：文件类型，如DlR、REG等。</li>
<li>DEVlCE：指定磁盘的名称。</li>
<li>SIZE:文件的大小。</li>
<li>NODE：索引节点(文件在磁盘上的标识)。</li>
<li>NAME：打开文件的确切名称。</li>
</ol>
<p>(2)lsof语法格式是：<br>
lsof [ options ] filename</p>
<p>(3)	常用的参数列表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">lsof filename</td>
<td style="text-align:center">显示打开指定文件的所有进程</td>
</tr>
<tr>
<td style="text-align:center">lsof -a</td>
<td style="text-align:center">表示两个参数都必须满足时才显示结果</td>
</tr>
<tr>
<td style="text-align:center">lsof -c strlng</td>
<td style="text-align:center">显示COMMAND列中包含指定字符的进程所有打开的文件</td>
</tr>
<tr>
<td style="text-align:center">lsof -u username</td>
<td style="text-align:center">显示所属user进程打开的文件</td>
</tr>
<tr>
<td style="text-align:center">lsof -g gld</td>
<td style="text-align:center">显示归属gld的进程情况</td>
</tr>
<tr>
<td style="text-align:center">lsof +d /DlR/</td>
<td style="text-align:center">显示目录下被进程打开的文件</td>
</tr>
<tr>
<td style="text-align:center">lsof +D /DlR/</td>
<td style="text-align:center">同上，但是会搜索目录下的所有目录，时间相对较长</td>
</tr>
<tr>
<td style="text-align:center">lsof -d FD</td>
<td style="text-align:center">显示指定文件描述符的进程</td>
</tr>
<tr>
<td style="text-align:center">lsof -n</td>
<td style="text-align:center">不将工P转换为hostname,缺省是不加上-n参数</td>
</tr>
<tr>
<td style="text-align:center">lsof -i</td>
<td style="text-align:center">用以显示符合条件的进程情况</td>
</tr>
</tbody>
</table>
<p>(4)常用命令如下所述。<br>
1 )查看6666端口现在运行情况,命令：<br>
<code>lsof -i :6666</code><br>
2)查看所属root用户进程所打开的文件，文件类型为.txt：<br>
<code>lsof -a -u root-d txt</code><br>
3)监控打开的文件和设备。查看设备/dev/ttyl被哪些进程占用的命令是:<br>
<code>lsof /dev/tty1</code><br>
4）监控程序。如查看指定程序server打开的文件：<br>
<code>lsof -c server</code><br>
5）监控用户。比如查看指定用户sharexu打开的文件：<br>
<code>lsof -u sharexu</code></p>
<h3 id="http下的工具">HTTP下的工具</h3>
<p>通过wireshark或者tcpdump抓包实现。通过前者看到的数据更加清晰直观，通过后者抓到的数据更真实。</p>
<p><a href="https://www.cnblogs.com/golinux/p/11012781.html">tcpdump抓包命令使用</a><br>
<a href="https://www.jianshu.com/p/81bc5685085b">Wireshark抓包工具的使用</a><br>
<a href="https://blog.csdn.net/sdgihshdv/article/details/80593892">使用WireShark抓包工具深入理解TCP连接的三次握手以及知识延伸</a></p>
]]></content>
    </entry>
</feed>