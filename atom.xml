<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-10-15T12:20:46.244Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[vptr指针[未阅读]]]></title>
        <id>https://lixin-ee.github.io//post/vptr-zhi-zhen-wei-yue-du</id>
        <link href="https://lixin-ee.github.io//post/vptr-zhi-zhen-wei-yue-du">
        </link>
        <updated>2019-10-15T12:19:55.000Z</updated>
        <content type="html"><![CDATA[<p>原文<a href="https://www.cnblogs.com/yangguang-it/p/6547314.html">c++多态之——vptr指针</a><br>
之前做过一个测试，在一个类中定义一个virtual修饰的函数时，sizeof这个类，发现类的大小多了恰好一个指针的字节大小，当初不明白，只是记住有这么一个特性。后来，发现它就是c++编译器给我们添加的vptr指针。</p>
<p>当类中声明虚函数时，编译器会在类中生成一个虚函数表；</p>
<p>虚函数表是一个存储成员函数指针的数据结构；</p>
<p>虚函数表是由编译器自动生成与维护的；</p>
<p>virtual成员函数会被编译器放入虚函数表中；</p>
<p>存在虚函数时，每个对象都有一个指向虚函数的指针（vptr指针）</p>
<p>在实现多态的过程中，父类和派生类都有vptr指针。</p>
<p>对象中的vptr指针什么时候被初始化：</p>
<p>对象在创建时，由编译器对vptr指针进行初始化；</p>
<p>只有当对象的构造完全结束后vptr的指向才最终决定下来；</p>
<p>父类对象的vptr指向父类的虚函数表，子类对象的vptr指向子类的虚函数表。</p>
<p>定义子类对象时，vptr先指向父类的虚函数表，在父类构造完成之后，子类的vptr才指向自己的虚函数表。（这也就是在父类或者子类的构造函数中调用虚成员函数不会实现多态的原因，这是一道面试题）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[const函数或const对象只能调用const函数 错误：对象包含与成员函数不兼容的类型限定符]]></title>
        <id>https://lixin-ee.github.io//post/const-han-shu-zhong-zhi-neng-diao-yong-const-han-shu-cuo-wu-dui-xiang-bao-han-yu-cheng-yuan-han-shu-bu-jian-rong-de-lei-xing-xian-ding-fu</id>
        <link href="https://lixin-ee.github.io//post/const-han-shu-zhong-zhi-neng-diao-yong-const-han-shu-cuo-wu-dui-xiang-bao-han-yu-cheng-yuan-han-shu-bu-jian-rong-de-lei-xing-xian-ding-fu">
        </link>
        <updated>2019-10-15T12:12:35.000Z</updated>
        <content type="html"><![CDATA[<p>情况：<br>
在bool compareIsbn(const Sales_data &amp;lhs,const Sales_data &amp;rhs)中调用bool compareISBN(Sales_Data &amp;lhs, Sales_Data &amp;rhs)<br>
错误：对象包含与成员函数不兼容的类型限定符<br>
原因：<br>
1）const对象只能调用const函数；<br>
2）如果const函数中不小心修改了类成员或者调用了非常量函数，编译器会找出这类错误。<br>
解决方法<br>
将compareISBN改成<br>
bool compareISBN(const Sales_Data &amp;lhs, const Sales_Data &amp;rhs)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[类成员函数的调用 错误invalid use of non-static member function ]]></title>
        <id>https://lixin-ee.github.io//post/lei-cheng-yuan-han-shu-de-diao-yong-cuo-wu-invalid-use-of-non-static-member-function</id>
        <link href="https://lixin-ee.github.io//post/lei-cheng-yuan-han-shu-de-diao-yong-cuo-wu-invalid-use-of-non-static-member-function">
        </link>
        <updated>2019-10-15T12:01:40.000Z</updated>
        <content type="html"><![CDATA[<p>原文链接<a href="https://www.cnblogs.com/scoyer/p/6533685.html">记一次C++的纠错过程</a><br>
经历和我一模一样，甚至于可能连题号都一致，我就不画蛇添足了，<br>
情况：向泛型函数提交自定义的比较大小函数，例如sort(begin(),end,compareIsbn)<br>
主要问题：报错 invalid use of non-static member function<br>
原因：不能直接使用指针来调用类成员函数，特别是在定义其他类成员函数的时候。因为代码中定义了类但<strong>并没有初始化这个类的成员函数</strong>。当你声明了具体的实例之后，一个<strong>实例调用构造函数才被初始化了</strong>，所以<strong>函数指针才能指向具体的类的成员函数</strong>。<br>
解决办法<br>
1.创建对象或临时对象<br>
2.那如果在定义中想要传一个成员函数指针给其他函数调用，这就要利用static对象的特性了，因为static的生存周期是从被构造出来到程序结束，也就是程序编译之后就被初始化好了。</p>
<p>下面为原文</p>
<p>事出的起因是我在leetcode刷着一道题，需要排序，于是我就自定义了一个比较函数，代码如下：</p>
<p>复制代码</p>
<pre><code>class Solution {
public:
  inline int digit(int x) {
    if (!x) return 10;
    int ret = 1;
    while (x) ret *= 10, x /= 10;
    return ret;
  }
  inline int cmp(int a, int b) {
    long long ab = 1LL * a * digit(b) + b, ba = 1LL * b * digit(a) + a;
    return ab &gt; ba;
  }
  string largestNumber(vector&lt;int&gt; nums) {
    sort(nums.begin(), nums.end(), Solution::cmp);
    string ret;
    char t[100];
    for (int i = 0; i &lt; nums.size(); i++) {
      if (ret == &quot;0&quot; &amp;&amp; !nums[i]) continue;
      sprintf(t, &quot;%d&quot;, nums[i]);
      ret = ret + t;
    }
    return ret;
  }
};
</code></pre>
<p>结果这个函数死活通过不了编译，乱改乱改还出现了invalid use of non-static member function 问题。看来成员函数不让这么弄，翻阅C++大师Stanley Lippman的Essential C++找一下成员函数的相关用法，还参考了一些技术博客，原来是C++的语法不过关啊！！/哭</p>
<p>下面回顾一下我纠错的过程，先看下面一段代码熟悉一下怎么调用普通的函数指针：</p>
<pre><code>/*zhen hao*/
#include &lt;bits/stdc++.h&gt;
using namespace std;

int F(double x) { return int(x); }

int G(double x) { return int(x) + 1; }

int main() {
  int (*p1)(double) = &amp;F;
  int (*p2)(double) = &amp;G;
  cout &lt;&lt; (*p1)(1) &lt;&lt; endl;
  cout &lt;&lt; (*p2)(1) &lt;&lt; endl;
  return 0;
}
</code></pre>
<p>如果用指针指向类的成员函数的时候就稍有不同，试着根据自己的想法改一下，主要是加上类的scope运算符限定一下函数的范围：</p>
<pre><code>/*zhen hao*/
#include &lt;bits/stdc++.h&gt;
using namespace std;

class C {
public:
  C() {}
  int F(double x) { return int(x); }
  int G(double x) { return int(x) + 1; }
};

int main() {
  int (C::*p1)(double) = &amp;C::F; //编译通过
  int (C::*p2)(double) = &amp;C::G; //编译通过
  cout &lt;&lt; (C::*p1)(1) &lt;&lt; endl; //error: expected unqualified-id before '*' token
  cout &lt;&lt; (C::*p2)(1) &lt;&lt; endl; //error: expected unqualified-id before '*' token
  return 0;
}
</code></pre>
<p>想当然以为简单改一下可以，然而编译不通过问题出在哪里呢？编译器报的错误是什么意思？</p>
<p>（1）先简单解释一下这个qualified是什么意思？</p>
<p>单词的意思是有限制的，也就是一些有范围的变量，例如下面的代码：</p>
<pre><code>1 #include &lt;iostream&gt;
2 int main()  {
3    std::cout&lt;&lt;&quot;Hello world!&quot;&lt;&lt;std::endl; //cout和endl都是qualified name，因为他们都限定在std这个明明空间上。
4    return 0;
5 }
</code></pre>
<p>值得注意的是，如果我们之间在代码上指定命名空间的话，例如using namespace std，那么cout和endl就是unqualified name了。</p>
<p>（2）另外id的全称是identifier，即标识符。</p>
<p>所以上述编译器希望这是一个qualified-id，也就是希望p1，p2是一个不需要用C::限定的变量，去掉之后仍然报错，报的错误是<code>invalid use of 'unary *' on pointer to member</code>，不能够用指针指着成员直接使用。</p>
<p>书上指出，pointer to member function和pointer to function的不同点是，前者必须通过同一类对象加以调用，而该对象便是此member function内的this指针所指之物。</p>
<p>所以以下用法才是正确的：</p>
<pre><code>/*zhen hao*/
#include &lt;bits/stdc++.h&gt;
using namespace std;

class C {
public:
  C() {}
  int F(double x) { return int(x); }
  int G(double x) { return int(x) + 1; }
};

int main() {
  int (C::*p1)(double) = &amp;C::F;
  int (C::*p2)(double) = &amp;C::G;
  C *c = new C();
  cout &lt;&lt; (c-&gt;*p1)(1) &lt;&lt; endl;
  cout &lt;&lt; (c-&gt;*p2)(1) &lt;&lt; endl;
  return 0;
}
</code></pre>
<p>原来我们需要的是一个实例来调用成员函数指针。</p>
<p>到这里就要问为什么呢？</p>
<p>因为代码中定义了C类并没有初始化这个类的成员函数。当你声明了具体的实例之后，一个实例调用构造函数被初始化了，所以函数指针才能指向具体的类的成员函数。那如果想要传一个成员函数指针给其他函数调用该怎么做？这就要利用static对象的特性了，因为static的生存周期是从被构造出来到程序结束，也就是程序编译之后就被初始化好了。</p>
<p>所以我们将上述代码改一下就能改正错误的代码了：</p>
<pre><code>/*zhen hao*/
#include &lt;bits/stdc++.h&gt;
using namespace std;

class C {
public:
  C() {}
  static int F(double x) { return int(x); }
  static int G(double x) { return int(x) + 1; }
};

int main() {
  int (*p1)(double) = &amp;C::F;
  int (*p2)(double) = &amp;C::G;
  cout &lt;&lt; (*p1)(1) &lt;&lt; endl;
  cout &lt;&lt; (*p2)(1) &lt;&lt; endl;
  return 0;
}
</code></pre>
<p>用static关键字修饰之后的成员函数就像普通函数一样可以传给别的函数做参数，使用也像普通函数一样。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于istringstream等输入流]]></title>
        <id>https://lixin-ee.github.io//post/guan-yu-istringstream-deng-shu-ru-liu</id>
        <link href="https://lixin-ee.github.io//post/guan-yu-istringstream-deng-shu-ru-liu">
        </link>
        <updated>2019-10-15T11:32:18.000Z</updated>
        <content type="html"><![CDATA[<p>今天做题时<a href="https://lixin-ee.github.io/post/math-165-bi-jiao-ban-ben-hao/">版本号比较</a>遇到一个题解</p>
<pre><code>class Solution {
public:
    int compareVersion(string version1, string version2) {
        char c;
        int v1,v2;
        istringstream its1(version1);
        istringstream its2(version2);
        
        while(bool(its1&gt;&gt;v1) + bool(its2&gt;&gt;v2)){
            if(v1&gt;v2) return 1;
            if(v1&lt;v2) return -1;
            
            v1=0;
            v2=0;
            its1&gt;&gt;c;
            its2&gt;&gt;c;
            
        }
        
        return 0;
    }
};
</code></pre>
<p>输入是 输入: version1 = &quot;7.5.2.4&quot;, version2 = &quot;7.5.3&quot;<br>
一开始百思不得其解，为何会自动以点号为分割？同时为何会自动去掉前置0？<br>
受到评论指引，才发现原来v1和v2可是int类型！<br>
所以在这里可以看出，isrtringstream或者说输入流，都会按照赋值的类型来读取分割，比如如果是赋值给float，则会读入第一个点号，而忽略第二个点号。<br>
而istringstream的string意为将一个string作为读入字符串（类似于cin的缓冲区），而不是说istringstream只能赋值给string。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MATH 165. 比较版本号]]></title>
        <id>https://lixin-ee.github.io//post/math-165-bi-jiao-ban-ben-hao</id>
        <link href="https://lixin-ee.github.io//post/math-165-bi-jiao-ban-ben-hao">
        </link>
        <updated>2019-10-15T10:49:02.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>比较两个版本号 version1 和 version2。<br>
如果 version1 &gt; version2 返回 1，如果 version1 &lt; version2 返回 -1， 除此之外返回 0。<br>
你可以假设版本字符串非空，并且只包含数字和 . 字符。<br>
 &gt; . 字符不代表小数点，而是用于分隔数字序列。<br>
例如，2.5 不是“两个半”，也不是“差一半到三”，而是第二版中的第五个小版本。<br>
你可以假设版本号的每一级的默认修订版号为 0。例如，版本号 3.4 的第一级（大版本）和第二级（小版本）修订号分别为 3 和 4。其第三级和第四级修订号均为 0。</p>
<p>示例 1:<br>
输入: version1 = &quot;0.1&quot;, version2 = &quot;1.1&quot;<br>
输出: -1<br>
示例 2:<br>
输入: version1 = &quot;1.0.1&quot;, version2 = &quot;1&quot;<br>
输出: 1<br>
示例 3:<br>
输入: version1 = &quot;7.5.2.4&quot;, version2 = &quot;7.5.3&quot;<br>
输出: -1<br>
示例 4：<br>
输入：version1 = &quot;1.01&quot;, version2 = &quot;1.001&quot;<br>
输出：0<br>
解释：忽略前导零，“01” 和 “001” 表示相同的数字 “1”。<br>
示例 5：<br>
输入：version1 = &quot;1.0&quot;, version2 = &quot;1.0.0&quot;<br>
输出：0<br>
解释：version1 没有第三级修订号，这意味着它的第三级修订号默认为 “0”。<br>
 <br>
提示：<br>
版本字符串由以点 （.） 分隔的数字字符串组成。这个数字字符串可能有前导零。<br>
版本字符串不以点开始或结束，并且其中不会有两个连续的点。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/compare-version-numbers<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>一开始的想法是先分析一下难点<br>
1.靠点号分割的话，位数不同<br>
2.会有前导0<br>
然后思考一下处理方式<br>
1.利用find函数进行点号分割，分割之后可以当场进行对比，或者存进容器里面进行对比。前者需要对首先对长度进行对比，后者的话可以通过push_back来补充位数<br>
2.前导0的处理方法 一个是find函数检测并去掉多余的0，一个是转化为int自动去掉，最后一个则是在对应的数前面补0，比如02和1对比，就向1补0，使得02和01对比。<br>
最后为了代码的可读性，我选择了vector补位+补0</p>
<pre><code>class Solution {
public:
    int compareVersion(string version1, string version2) {
        vector&lt;string&gt; v1,v2;
        split(version1,v1);
        split(version2,v2);
        int len=0;
        if(v1.size()&gt;v2.size()){
            len=v1.size()-v2.size();
            while(len)
                --len,v2.push_back(&quot;0&quot;);
        }
        else{
            len=v2.size()-v1.size();
            while(len)
                --len,v1.push_back(&quot;0&quot;);
        }
        for(int i=0;i&lt;v1.size();++i ){
            if(v1[i].size()&gt;v2[i].size()){
                 len=v1[i].size()-v2[i].size();;
                 while(len)
                    --len,v2[i]=&quot;0&quot;+v2[i];
             }
              else{
                 len=v2[i].size()-v1[i].size();
                 while(len)
                    --len,v1[i]=&quot;0&quot;+v1[i];
             }
            if(v1[i]&gt;v2[i])
                return 1;
            else if (v1[i]&lt;v2[i])
                return -1;
        }
            
          return 0;        
    }
    
    void split(string &amp;version,vector&lt;string&gt; &amp;v){
        char comma='.';
        for(int i=0;i&lt;version.size();){
            int j=version.find(comma,i);
            if(j==string::npos){
                v.push_back(version.substr(i,version.size()-i));
                break;
            }              
            v.push_back(version.substr(i,j-i));
            i=j+1;
        }
    }   
};
</code></pre>
<p>这道题有个很明显的问题是代码比较臃肿，重复代码太多，所以我把分割操作合成一个函数了，可读性明显高了很多<br>
然后高赞网友题解都类似，都是点号分解<br>
最后是有个比较秀的操作：</p>
<pre><code>class Solution {
public:
    int compareVersion(string version1, string version2) {
        char c;
        int v1,v2;
        istringstream its1(version1);
        istringstream its2(version2);
        
        while(bool(its1&gt;&gt;v1) + bool(its2&gt;&gt;v2)){
            if(v1&gt;v2) return 1;
            if(v1&lt;v2) return -1;
            
            v1=0;
            v2=0;
            its1&gt;&gt;c;
            its2&gt;&gt;c;
            
        }
        
        return 0;
    }
};
</code></pre>
<p>注意是把 istringstream 强行输入赋值给int，此时输入流会强制读取一个符合int格式的string值，所以输入流会以点号为结束符，并且将其自动转化为int类型，也就同时完成了分割和去掉前置0两个任务，所以代码非常简单，只是需要仔细研究一下才好。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第十一章 笔记+习题 11.3-11.4]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-yi-zhang-bi-ji-xi-ti-113-114</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-yi-zhang-bi-ji-xi-ti-113-114">
        </link>
        <updated>2019-10-14T03:06:22.000Z</updated>
        <content type="html"><![CDATA[<p>11.3关联容器操作<br>
map的value_type为<code>pair&lt;const key_type,mapped_type&gt;</code><br>
我们不能改变pair中的关键字，因此这些pair的关键字部分是const的（set中的关键字也是const的）<br>
只有map类型才能定义mapped_type</p>
<p>11.3.1关联容器迭代器<br>
一个map 的value_type是一个pair，我们可以改变pair的值，但是不能改变关键字成员的值<br>
虽然map和set类型同时定义了iterator和const_iterator两种类型，但两种类型都只允许只读访问set中的元素，<strong>set的关键字是const的，set的迭代器也是const的</strong>。<br>
map和set类型都支持表9.2（p295）中的begin和end操作<br>
当时用一个迭代器遍历一个map、multimap、set或multiset时，迭代器按关键字升序遍历元素<br>
我们通常<strong>不对关联容器使用泛型算法</strong>，因为关键字是const，不能将关联容器传递给修改或重排容器元素的算法<br>
关联容器中的元素不<strong>能通过它们的关键字进行快速查找</strong>，所以使用关联容器定义的专用的find成员会比调用泛型find快得多<br>
在实际编程中，如果我们真要对一个关联容器使用算法，要么将它当做一个<strong>源序列</strong>，要么当做一个<strong>目的位置</strong><br>
迭代器的类型需要在iterator或者const_iterator加上类类型，比如map&lt;const string, size_t&gt;::const_iterator<br>
map和set中的 key_type其实都会自动加上const但是在声明类型时不需要加上，比如Sales_Data，除非是像map_it那样显式声明。只需要注意使用auto或者decltype时会自动加上const<br>
关联容器的迭代器时双向迭代器（由红黑树决定），只能进行相等不等的比较，无法进行小于的比较！！！</p>
<p>习题11.15<br>
value_type为 pair<code>&lt;int,vector&lt;int&gt;&gt;</code> key_type为int mapped_type为vector<br>
习题11.16</p>
<pre><code>	map&lt;string, int&gt; map_si{ {&quot;123&quot;,123} };
	(*map_si.begin()).second = 321;
</code></pre>
<p>注意的点：map的迭代器不能直接解引用就赋值，还是需要.second，然后第二个调用前的括号必不可少，第一个调用则不需要括号<br>
习题11.17<br>
（1）不合法，显示error type，因为关联容器的迭代器时const的，不能进行写操作<br>
（2）同上<br>
（3）（4）合法<br>
习题11.18<br>
注意不是<code>const_iterator&lt;map&lt;const string ,size_t&gt;&gt;</code>！<br>
而是<code>map&lt;const string, size_t&gt;::const_iterator</code><br>
需要在iterator或者const_iterator加上类类型， 比如string、map、vector等等<br>
习题11.19<br>
<code>multiset&lt;Sales_Data, bool(*)(const Sales_Data &amp;lhs, const Sales_Data &amp;rhs)&gt;::iterator mi=bookstore.begin();</code><br>
注意 map和set中的 key_type其实都会自动加上const但是在声明类型时不需要加上，比如Sales_Data，除非是像map_it那样显式声明。只需要注意使用decltype时会自动加上const，但是auto不会（auto忽略顶层const）</p>
<p>11.3.2添加元素<br>
向map和set插入一个已存在的元素没有任何影响<br>
insert有两个版本，分别接受一对迭代器，或是一个初始化器列表，对于一个给定的关键字，只有第一个带此关键字的元素才会被插入到容器中（<strong>对于map很重要</strong>，比如{{1,a}{1,b}}两者之间谁能插入）<br>
insert和emplace的返回值依赖于容器的类型和参数，对于不包含重复关键字的容器返回一个pair，告诉我们插入操作是否成功。返回的pair的first成员是一个迭代器，指向具有给定关键字（插入值）的元素，second成员是一个bool值，指出元素是插入成功还是已经存在于容器中。如果关键字插入失败，返回值为false，否则返回为true<br>
对于允许重复关键字的容器，接受单个元素的insert操作返回一个指向新元素的迭代器，这里无须返回一个bool值</p>
<p>习题11.20</p>
<pre><code>int main()
{
	map&lt;string, size_t&gt; word_count;
	string word;
	while (cin &gt;&gt; word)
		if (!word_count.insert(make_pair(word, 1)).second)
			++word_count[word];
}
</code></pre>
<p>insert更加容易编写阅读，因为下标运算符会强行将元素添加进去<br>
习题11.21<br>
将单词插入到map中，并在键值中记录单词出现的次数<br>
习题11.22<br>
参数类型<code>pair&lt;const string,vector&lt;int&gt;&gt;</code><br>
返回类型<code>pair&lt;map&lt;string,vector&lt;int&gt;&gt;::iterator,bool&gt;</code><br>
习题11.23</p>
<pre><code>int main()
{
	multimap&lt;string, vector&lt;string&gt;&gt; map_name;
	string first_name, last_name;
	while (cin) {
		cin &gt;&gt; first_name &gt;&gt; last_name;	
		map_name.insert({ first_name,{ last_name } });
	}
}
</code></pre>
<p>11.3.3删除新元素<br>
关联容器定义有三个版本的erase<br>
注意c.erase(b,e)不包括e 是左闭右开区间 insert中也是<br>
erase可以接受一个key_type参数，此版本删除所有匹配给定关键字的元素，返回实际删除的元素的数量</p>
<p>11.3.4map的下标操作<br>
map和unordered_map提供下标运算符和对应的at函数，返回的是second值<br>
set类型不支持下标和at()（或者说不需要）<br>
multimap和unordered_map不支持下标操作，因为有多个值与一个关键字相关联<br>
map下标运算符接受一个索引，获取与此关键字相关联的值，但是注意！！！如果关键字并不在map，会为它创建一个元素插入map中，并对关联值进行值初始化<br>
对关键字会强行加上顶层const<br>
由于下标运算符可能插入一个新元素，所以只可以对非const的map使用下标操作<br>
与vector和string不同，map下标运算符返回的类型与解引用map迭代器返回的类型不同，下标操作得到mapped_type对象，解引用迭代器得到一个value_type对象</p>
<p>习题11.24<br>
如果m中有关键字0，则将second改成1，否则向m插入{0，1}<br>
习题11.25<br>
vector的下标必须先构造，否则就是非法访问<br>
习题11.26<br>
map&lt;string,int&gt;中，下标操作的类型必须是string，返回类型是int，亦即key_type对其执行下标操作，mapped_type为其返回类型</p>
<p>11.3.5访问元素<br>
使用下标操作有一个严重的副作用，如果关键字还未在map中，下标操作会插入一个具有给定关键字的元素<br>
find bound都是返回迭代器<br>
使用find就可以值检查给定关键字是否在map中<br>
multimap和multiset中具有相同关键字的元素在容器中会相邻存储，需要配合cout和find使用（find一次只能找到一个！！！）<br>
lower_bound和upper_bound这两个操作都接受一个关键字，返回一个迭代器。lower_bound返回指向第一个给定关键字的迭代器，upper_bound返回指向最后一个匹配给定关键字的元素之后的位置的迭代器。如果寻找不到，则返回相同迭代器，指向不影响排序的关键字插入位置<br>
equal_range接受一个关键字，返回一个迭代器pair，若关键字存在，则第一个迭代器指向第一个匹配的元素，第二个迭代器指向最后一个匹配元素之后的位置。如果不存在，则指向相同位置（亦即返回左闭右开区间）</p>
<p>习题11.27<br>
需要计算相同元素的数量时使用count，需要判断元素是否存在时使用find<br>
习题11.28<br>
<code>map&lt;string,vector&lt;int&gt;&gt;::iterator ite;</code><br>
习题 11.29<br>
upper和lower返回同一个值，指向不影响排序的关键字插入位置<br>
equal_range如果不存在，则返回一对指向相同位置迭代器的pair<br>
习题11.30<br>
pos是一个pair 里面是一对迭代器，first是左边迭代器，second则是这个迭代器的值<br>
习题11.31</p>
<pre><code>int main()
{
	multimap&lt;string, string&gt; multim{ {&quot;123&quot;,&quot;456&quot;} ,{ &quot;123&quot;,&quot;456&quot; } ,{ &quot;123&quot;,&quot;456&quot; } ,{ &quot;123&quot;,&quot;456&quot; } };
	string name=&quot;123&quot;, product;
	if (multim.find(name) != multim.end())
		multim.erase(name);
	cout &lt;&lt; multim.empty();
}
</code></pre>
<p>习题11.32</p>
<pre><code>int main()
{
	multimap&lt;string, string&gt; multim{ {&quot;123&quot;,&quot;1&quot;} ,{ &quot;123&quot;,&quot;2&quot; } ,{ &quot;456&quot;,&quot;1&quot; } ,{ &quot;123&quot;,&quot;1&quot; } };
	string name=&quot;123&quot;, product;
	for (auto left = multim.begin(); left != multim.end();) {
		auto right = multim.upper_bound((*left).first);
		cout &lt;&lt; (*left).first &lt;&lt; &quot; &quot;;
		while (left != right) {
			cout &lt;&lt; (*left).second &lt;&lt; &quot; &quot;;
			++left;
		}
		cout &lt;&lt; endl;
	}
}
</code></pre>
<p>习题感悟：关联容器的迭代器时双向迭代器（由红黑树决定），只能进行相等不等的比较，无法进行小于的比较！！！</p>
<p>11.3.6一个单词转换map<br>
习题11.33<br>
直接仿真了书中代码hhh<br>
习题11.34<br>
如果没找到的话反而会将当前关键值插入map，并且值为空<br>
习题11.35<br>
如果有重复关键值，则只保存最早的一个，否则就不断更新，无重复关键值的话无差别<br>
习题11.36<br>
不影响，因为对value.size()进行了判断，如果只要空格的话是会报错的</p>
<p>11.4无序容器<br>
注意<strong>顺序容器对应无序容器，关联容器不等同于无序容器</strong><br>
新标准定义了4个无序关联容器，无序容器不是使用比较运算符来组织元素，而是使用一个哈希函数，和关键字类型的==运算符<br>
如果关键字类型固有就是无序的，或者性能测试发现问题可以用哈希技术解决，就可以使用无序容器<br>
无序容器提供了与有序容器相同的操作（find、insert等），所以unordered_map和unordered_set也可以使用这些操作<br>
无序容器也有允许重复关键字的版本<br>
<strong>通常可以用一个无序容器替换对相应的有序容器，反之亦然</strong><br>
无序容器在存储组织上为<strong>一组桶</strong>，每个桶保存零个或多个元素，无序容器使用一个哈希函数将元素映射到桶，容器首先计算元素的哈希值，并将<strong>具有一个特定哈希值的所有元素都保存在相同的桶中</strong>，所有具有相同关键字的元素都会在同一个桶中，因此无序容器的性能依赖于<strong>哈希函数的质量和桶的数量和大小</strong><br>
对于相同的参数，哈希函数总是产生相同的结果<br>
将不同关键字映射到相同的桶也是允许的，当一个桶保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个</p>
<p>默认情况下无序容器使用关键字类型的==运算符来比较元素，还是用一个hash&lt;key_type&gt;类型来生成每个元素的哈希值，标准库为内置类型包括指针提供了hash模板</p>
<p>习题11.37<br>
无序版本优势：当容器中key没有明显的顺序关系时更有用,且不需要耗费多余的时间来维护容器中的key序列<br>
有序版本优势：当容器中key有明显的顺序关系时更有用,且我们不需要考虑排序问题,容器自动维护序列(字典序)<br>
习题11.38</p>
<pre><code>int main()
{
	unordered_map&lt;string, size_t&gt; word_count;
	string word;
	while (cin &gt;&gt; word)
		if (!word_count.insert(make_pair(word, 1)).second)
			++word_count[word];
	for (const auto &amp;w : word_count)
		cout &lt;&lt; w.first &lt;&lt; &quot; &quot; &lt;&lt; w.second &lt;&lt; endl;
}
</code></pre>
<p>通常可以用一个无序容器替换对相应的有序容器，反之亦然，内部的处理方式不同，外部的操作还是大同小异</p>
<p>习题感悟<br>
迭代器的类型需要在iterator或者const_iterator加上类类型， 比如string、map、vector等等<br>
map和set中的 key_type其实都会自动加上const但是在声明类型时不需要加上，比如Sales_Data，除非是像map_it那样显式声明。只需要注意使用decltype时会自动加上const，但是auto不会（auto忽略顶层const）<br>
关联容器的迭代器时双向迭代器（由红黑树决定），只能进行相等不等的比较，无法进行小于的比较！！！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math 7. 整数反转]]></title>
        <id>https://lixin-ee.github.io//post/math-7-zheng-shu-fan-zhuan</id>
        <link href="https://lixin-ee.github.io//post/math-7-zheng-shu-fan-zhuan">
        </link>
        <updated>2019-10-14T02:40:28.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<p>示例 1:<br>
输入: 123<br>
输出: 321<br>
 示例 2:<br>
输入: -123<br>
输出: -321<br>
示例 3:<br>
输入: 120<br>
输出: 21<br>
注意:<br>
假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 <code>[−2^31,  2^31 − 1]</code>。请根据这个假设，如果反转后整数溢出那么就返回 0。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/reverse-integer<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题的难处在于<br>
1.负数的处理，并且负数能表示的位置比正数多一位<br>
2.末尾0的处理，反转后需要去除多余的0</p>
<p>其实主要就两种方法，一种是整数的整十除法，另一种就是转化为字符串进行操作。我偷懒就使用了字符串的方法，反转、判断溢出和对末尾0的处理方便很多，但是对于负数的处理比较麻烦，需要将-2^31单独判断一次。<br>
代码如下：</p>
<pre><code>class Solution {
public:
    int reverse(int x) {
        bool neg=false;
        if(x==-2147483648)
            return 0;
        if(x&lt;0){
            neg=true;
            x=-x;
        }
        string num_s=to_string(x);
        auto left=num_s.begin();
        auto right=num_s.end()-1;
        while(left&lt;right)
            iter_swap(left++,right--);
        if(num_s.size()==10){
            if(neg){
                 if(num_s&gt;&quot;2147483648&quot;)
                    return 0;
            }     
            else{
                if(num_s&gt;&quot;2147483647&quot;)
                    return 0;
            }           
        }        
        x=stoi(num_s);
        if(neg)
            x=-x;
        return x;
    }
};
</code></pre>
<p>可以看到代码不够优雅啊，而且其实字符串和整数的转换是需要比较多的库函数的。<br>
接下来看看官方题解：</p>
<blockquote>
<p>方法：弹出和推入数字 &amp; 溢出前进行检查<br>
思路<br>
我们可以一次构建反转整数的一位数字。在这样做的时候，我们可以预先检查向原整数附加另一位数字是否会导致溢出。</p>
<p>算法<br>
反转整数的方法可以与反转字符串进行类比。<br>
我们想重复“弹出” x 的最后一位数字，并将它“推入”到 rev 的后面。最后，rev 将与 x 相反。<br>
要在没有辅助堆栈 / 数组的帮助下 “弹出” 和 “推入” 数字，我们可以使用数学方法。</p>
</blockquote>
<pre><code>//pop operation:
pop = x % 10;
x /= 10;

//push operation:
temp = rev * 10 + pop;
rev = temp;
</code></pre>
<blockquote>
<p>但是，这种方法很危险，因为当 temp=rev⋅10+pop 时会导致溢出。<br>
幸运的是，事先检查这个语句是否会导致溢出很容易。<br>
为了便于解释，我们假设 rev 是正数。<br>
如果 temp=rev⋅10+pop 导致溢出，那么一定有rev≥ INTMAX/10<br>
如果 rev&gt; INTMAX/10，那么temp=rev⋅10+pop 一定会溢出。<br>
如果 rev== INTMAX/10，那么只要 pop&gt;7，temp=rev⋅10+pop 就会溢出。<br>
当 rev 为负时可以应用类似的逻辑。</p>
</blockquote>
<pre><code>class Solution {
public:
    int reverse(int x) {
        int rev = 0;
        while (x != 0) {
            int pop = x % 10;
            x /= 10;
            if (rev &gt; INT_MAX/10 || (rev == INT_MAX / 10 &amp;&amp; pop &gt; 7)) return 0;
            if (rev &lt; INT_MIN/10 || (rev == INT_MIN / 10 &amp;&amp; pop &lt; -8)) return 0;
            rev = rev * 10 + pop;
        }
        return rev;
    }
};
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(log(x))，x 中大约有log_10(x) 位数字。<br>
空间复杂度：O(1)</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 273. 整数转换英文表示]]></title>
        <id>https://lixin-ee.github.io//post/zi-fu-chuan-273-zheng-shu-zhuan-huan-ying-wen-biao-shi</id>
        <link href="https://lixin-ee.github.io//post/zi-fu-chuan-273-zheng-shu-zhuan-huan-ying-wen-biao-shi">
        </link>
        <updated>2019-10-13T13:01:49.000Z</updated>
        <content type="html"><![CDATA[<p>难度 困难</p>
<pre><code>将非负整数转换为其对应的英文表示。可以保证给定输入小于 2^31 - 1 。

示例 1:
输入: 123
输出: &quot;One Hundred Twenty Three&quot;
示例 2:
输入: 12345
输出: &quot;Twelve Thousand Three Hundred Forty Five&quot;
示例 3:
输入: 1234567
输出: &quot;One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven&quot;
示例 4:
输入: 1234567891
输出: &quot;One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One&quot;

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/integer-to-english-words
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
</code></pre>
<p>这道题一开始还是蛮难的，我的初步想法是依靠英文数字的特性，把数字切割为每三位的格式，再添加每三位之间的词。<br>
但是由于数字和字符串两者都不好从左到右处理位数的问题，所以我首先把数字转为字符串，然后补全到3的倍数，再进行切割，以逆序放入vector，比如123456789，最后得到{&quot;789&quot;,&quot;456&quot;,&quot;123&quot;}<br>
然后进行循环，对每个部分进行翻译和添加词汇<br>
先把最后代码放出来吧</p>
<pre><code>class Solution {
public:
#include &lt;iostream&gt;
    string numberToWords(int num) {
        if(!num)
            return &quot;Zero&quot;;
        string num_s=to_string(num);
        int len=num_s.size();
        vector&lt;string&gt; units{&quot;&quot;,&quot; Thousand&quot;,&quot; Million&quot;,&quot; Billion&quot;};
        vector&lt;string&gt; bits{&quot; One&quot;,&quot; Two&quot;,&quot; Three&quot;,&quot; Four&quot;,&quot; Five&quot;,&quot; Six&quot;,&quot; Seven&quot;,&quot; Eight&quot;,&quot; Nine&quot;};
        vector&lt;string&gt; tens_sp{&quot; Ten&quot;,&quot; Eleven&quot;,&quot; Twelve&quot;,&quot; Thirteen&quot;,&quot; Fourteen&quot;,&quot; Fifteen&quot;,&quot; Sixteen&quot;,&quot; Seventeen&quot;,&quot; Eighteen&quot;,&quot; Nineteen&quot;};
        vector&lt;string&gt; tens{&quot; Twenty&quot;,&quot; Thirty&quot;,&quot; Forty&quot;,&quot; Fifty&quot;,&quot; Sixty&quot;,&quot; Seventy&quot;,&quot; Eighty&quot;,&quot; Ninety&quot;};
        int time=len/3;
        if(time*3&lt;len){
            ++time;    
            while(len&lt;time*3)
                num_s=&quot;0&quot;+num_s,++len;    
        }
        vector&lt;string&gt; three_part;
        while(time&gt;0)
            three_part.push_back(num_s.substr(--time*3,3));
        string res;
        for(int i=0;i&lt;three_part.size();++i){
            string temp;
            if(stoi(three_part[i])==0)
                     continue;
             if(three_part[i][0]!='0'){
                temp+=bits[three_part[i][0]-'1']+&quot; Hundred&quot;;
             }
             if(three_part[i][1]!='0'){
                 if(three_part[i][1]=='1'){
                     temp+=tens_sp[three_part[i][2]-'0']+units[i];
                     res=temp+res;
                     continue;
                 } 
                 temp+=tens[three_part[i][1]-'2'];
             }
             if(three_part[i][2]!='0')
                 temp+=bits[three_part[i][2]-'1'];
            res=temp+units[i]+res;
        }   
        return res.substr(1,res.size()-1);
    }
};
</code></pre>
<p>然后说一下遇到的问题<br>
1.空格的问题，一开始被空格弄得有点头疼，因为一种情况是整十的数，可能会在最后面出现一个多余的空格。最后的处理办法是统一在前面或者后面添加空格，然后再去掉<br>
2.某段数字整体为空，此时需要加上一个判断<code>if(stoi(three_part[i])==0)</code>跳过这一整段，否则会添加多余的Thousand或者Billion</p>
<p>然后来看一下官方题解吧：</p>
<blockquote>
<p>方法：分治<br>
我们将这个问题分解成一系列子问题。例如，对于数字 1234567890，我们将它从低位开始每三个分成一组，得到 1,234,567,890，它的英文表示为 1 Billion 234 Million 567 Thousand 890。这样我们就将原问题分解成若干个三位整数转换为英文表示的问题了。</p>
<p>接下来，我们可以继续将三位整数分解，例如数字 234 可以分别成百位 2 和十位个位 34，它的英文表示为 2 Hundred 34。这样我们继续将原问题分解成一位整数和两位整数的英文表示。其中一位整数的表示是很容易的，而两位整数中除了 10 到 19 以外，其余整数的的表示可以分解成两个一位整数的表示，这样问题就被圆满地解决了。</p>
</blockquote>
<pre><code>class Solution {
    public String one(int num) {
        switch(num) {
            case 1: return &quot;One&quot;;
            case 2: return &quot;Two&quot;;
            case 3: return &quot;Three&quot;;
            case 4: return &quot;Four&quot;;
            case 5: return &quot;Five&quot;;
            case 6: return &quot;Six&quot;;
            case 7: return &quot;Seven&quot;;
            case 8: return &quot;Eight&quot;;
            case 9: return &quot;Nine&quot;;
        }
        return &quot;&quot;;
    }

    public String twoLessThan20(int num) {
        switch(num) {
            case 10: return &quot;Ten&quot;;
            case 11: return &quot;Eleven&quot;;
            case 12: return &quot;Twelve&quot;;
            case 13: return &quot;Thirteen&quot;;
            case 14: return &quot;Fourteen&quot;;
            case 15: return &quot;Fifteen&quot;;
            case 16: return &quot;Sixteen&quot;;
            case 17: return &quot;Seventeen&quot;;
            case 18: return &quot;Eighteen&quot;;
            case 19: return &quot;Nineteen&quot;;
        }
        return &quot;&quot;;
    }

    public String ten(int num) {
        switch(num) {
            case 2: return &quot;Twenty&quot;;
            case 3: return &quot;Thirty&quot;;
            case 4: return &quot;Forty&quot;;
            case 5: return &quot;Fifty&quot;;
            case 6: return &quot;Sixty&quot;;
            case 7: return &quot;Seventy&quot;;
            case 8: return &quot;Eighty&quot;;
            case 9: return &quot;Ninety&quot;;
        }
        return &quot;&quot;;
    }

    public String two(int num) {
        if (num == 0)
            return &quot;&quot;;
        else if (num &lt; 10)
            return one(num);
        else if (num &lt; 20)
            return twoLessThan20(num);
        else {
            int tenner = num / 10;
            int rest = num - tenner * 10;
            if (rest != 0)
              return ten(tenner) + &quot; &quot; + one(rest);
            else
              return ten(tenner);
        }
    }

    public String three(int num) {
        int hundred = num / 100;
        int rest = num - hundred * 100;
        String res = &quot;&quot;;
        if (hundred * rest != 0)
            res = one(hundred) + &quot; Hundred &quot; + two(rest);
        else if ((hundred == 0) &amp;&amp; (rest != 0))
            res = two(rest);
        else if ((hundred != 0) &amp;&amp; (rest == 0))
            res = one(hundred) + &quot; Hundred&quot;;
        return res;
    }

    public String numberToWords(int num) {
        if (num == 0)
            return &quot;Zero&quot;;

        int billion = num / 1000000000;
        int million = (num - billion * 1000000000) / 1000000;
        int thousand = (num - billion * 1000000000 - million * 1000000) / 1000;
        int rest = num - billion * 1000000000 - million * 1000000 - thousand * 1000;

        String result = &quot;&quot;;
        if (billion != 0)
            result = three(billion) + &quot; Billion&quot;;
        if (million != 0) {
            if (! result.isEmpty())
                result += &quot; &quot;;
            result += three(million) + &quot; Million&quot;;
        }
        if (thousand != 0) {
            if (! result.isEmpty())
                result += &quot; &quot;;
            result += three(thousand) + &quot; Thousand&quot;;
        }
        if (rest != 0) {
            if (! result.isEmpty())
                result += &quot; &quot;;
            result += three(rest);
        }
        return result;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析</p>
<p>时间复杂度：O(N)。其中 N 是输入整数的长度。由于输出的英文表示长度和输入整数的长度是成正比的，因此时间复杂度为 O(N)。<br>
空间复杂度：O(1)。</p>
</blockquote>
<p>hhh虽然我的也有分治法的影子，但是它的优雅好多啊，特别是把三位数字分开处理。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ C++ primer 第十一章 笔记+习题 11.1-11.2]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-yi-zhang-bi-ji-xi-ti-111-112</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-yi-zhang-bi-ji-xi-ti-111-112">
        </link>
        <updated>2019-10-13T01:45:38.000Z</updated>
        <content type="html"><![CDATA[<p>来到我最喜欢的一章啦hhh</p>
<p>11关联容器<br>
关联容器支持<strong>高效的关键字查找和访问</strong><br>
两个主要的关联容器类型是map和set<br>
map 关键字-值(key-value) 关键字起索引的作用，值则是与索引相关联的数据<br>
set中每个元素只包含一个关键字，set支持高效的关键字查询操作<br>
类型map和multimap定义在头文件map中；set和multiset定义在头文件set中，无序容器则定义在头文件unordered_map和unordered_set中</p>
<p>11.1使用关联容器<br>
map是关键字-值的集合，map称为关联数组，可以通过下标访问，但是其<strong>下标不必是整数类型</strong>，可以是其他类型<br>
类似于顺序容器，关联容器也是模板，定义一个map<strong>必须指定关键字和值的类型</strong><br>
当从map提取一个<strong>元素</strong>时（不是指提取一个值，是提取一个 <strong>关键字-值</strong> 元素），得到一个<strong>pair类型</strong>的对象<br>
pair是一个模板类型，保存两个名为<strong>first和second</strong>的（公有）数据成员<br>
set<br>
与顺序容器类似，可以对一个关联容器的元素进行列表初始化<br>
find调用返回一个迭代器，如果给定关键字在set中，迭代器指向该关键字，<strong>否则find返回尾后迭代器</strong></p>
<p>习题11.1<br>
首先一个是顺序容器一个是关联容器。map的元素必须是一个pair类型的值，可以指定pair之中的两个类型，然后map是会自动按照关键字顺序排序的，并且下标就是关键字，而不是必须是数字。<br>
习题11.2<br>
按照 增删查改 四个操作<br>
list：经常在头尾进行查改操作和任意位置进行增删操作的<br>
vector：只在尾部进行增删，而经常进行任意位置查改操作的<br>
deque：在头尾进行增删，和任意位置的查改操作。<br>
map：希望高效的关键字增删查改，并且关键字需要附带信息的<br>
set：希望高效的关键字增删查改<br>
习题11.3<br>
其实书里面的例题就很不错了，这里复现一下，主要是为了加深知识点</p>
<pre><code>int main()
{
	map&lt;string, int&gt; map_s;
	set&lt;string&gt; set_s{ &quot;123&quot;,&quot;456&quot;, &quot;789&quot; };
	string s;
	while (cin&gt;&gt;s)
	{
		if (set_s.find(s) != set_s.end())
			++map_s[s];
	}
	for (auto i : map_s)
		cout &lt;&lt; i.first&lt;&lt;&quot; &quot;&lt;&lt;i.second &lt;&lt; endl;
}
</code></pre>
<p>注意关联容器也是有顺序的，可以使用begin和end等关联容器<br>
习题11.4</p>
<pre><code>int main()
{
	map&lt;string, int&gt; map_s;
	set&lt;string&gt; set_s{ &quot;example&quot; };
	string s;
	while (cin&gt;&gt;s)
	{
		s.erase(remove_if(s.begin(), s.end(), ispunct),s.end());
		transform(s.begin(), s.end(), s.begin(), tolower);
		for (auto i : s)
			cout &lt;&lt; i;
		cout&lt;&lt; endl;
		if (set_s.find(s) != set_s.end())
			++map_s[s];
	}
	for (auto i : map_s)
		cout &lt;&lt; i.first&lt;&lt;&quot; &quot;&lt;&lt;i.second &lt;&lt; endl;
}
</code></pre>
<p>注意很多字符操作，比如ispunct和tolower等都可以配合_if后缀的泛型算法进行使用。注意for_each和transform的区别，前者其实是无法逐一改变容器元素值的，只有后者添加了参数进行结果复制。</p>
<p>11.2 关联容器概述<br>
关联容器都支持普通容器操作<br>
关联容器不支持顺序容器的位置相关操作，因为关联容器都是按关键字存储，也不支持构造函数或插入操作<br>
关联容器的迭代器都是<strong>双向的</strong></p>
<p>11.2.1定义关联容器<br>
1.每个关联容器都定义了一个默认构造函数，创建一个指定类型的空容器<br>
2.也可以将关联容器初始化为另一个同类型容器的拷贝(必须相同)，或是从一个范围来初始化关联容器（相容，只要这些值可以转化为所需类型）<br>
3.新标准下，也可以对关联容器进行值初始化</p>
<p>当初始化一个map时，必须提供关键字类型和值类型，我们将每个关键字-值对包围在花括号中 {key,value}<br>
一个map和set中的关键字必须是唯一的，multimap和multiset就可以重复<br>
用含有重复元素的容器或者列表初始化map或set，会自动忽略重复元素</p>
<p>习题11.5<br>
map的元素是一个pair，包含关键值和键值，而set只包含关键值，按需使用（但是算法题中明显map使用更多）<br>
习题11.6<br>
list是顺序容器，利用指针相连，而set是关联容器，其顺序是与添加顺序无关的。<br>
习题11.7</p>
<pre><code>int main()
{
	map&lt;string, vector&lt;string&gt;&gt; map_name;
	string first_name, last_name;
	while (cin) {
		cin &gt;&gt; first_name &gt;&gt; last_name;
		if (map_name.find(first_name) == map_name.end()) {
			map_name.insert({ first_name,{last_name} });
		}
		else
			map_name[first_name].push_back(last_name);
	}	
}
</code></pre>
<p>习题11.8</p>
<pre><code>int main()
{
	vector&lt;string&gt; vs;
	string s;
	while (cin &gt;&gt; s)
		if (find(vs.begin(), vs.end(), s) == vs.end())
			vs.push_back(s);
}
</code></pre>
<p>set的优点是对于重复的单词，会自动忽略，而不需要使用find遍历一遍。</p>
<p>11.2.2 关键字类型的要求<br>
对于有序容器map、multimap、set和multiset ，关键字类型必须定义元素比较方法， 默认情况下标准库使用关键字类型的&lt;运算符来比较两个关键字<br>
传递给排序算法的可调用对象必须满足与关联容器中关键字一样的类型要求<br>
自定义的比较操作必须在关键字类型上定义一个严格弱序（小于等于）：<br>
用来组织一个容器中元素的操作的类型也是该容器类型的一部分，必须在定义关联容器类型时提供此操作的类型，自定义的操作类型必须在尖括号中紧跟着元素类型给出 比如 <code>multiset&lt;Sales_data,decltype(compareIsbn)*&gt; bookstore(compareIsbn)</code><br>
当用decltype来获得一个函数指针类型时，必须加上一个*来指出我们要使用一个给定函数类型的指针。比如<code>decltype(compareISBN)*</code> <strong>因为虽然函数名本身是一个指针，但是decltype作用于函数名只会返回函数类型而不是一个指针</strong></p>
<p>习题11.9<br>
<code>map&lt;string,list&lt;size_t&gt;&gt; ;</code><br>
习题11.10<br>
vector可以，因为其迭代器是随机存取迭代器，定义了大小比较，list的是双向迭代器，无法进行大小比较。<br>
习题11.11</p>
<pre><code>multiset&lt;Sales_Data, bool(*)(const Sales_Data &amp;lhs, const Sales_Data &amp;rhs)&gt; bookstore(compareISBN);
</code></pre>
<p>注意点 如果不能使用decltype，就只能把函数类型完整写出来，主要是把函数名去掉，加上(*)注意括号必须有，指示是一个函数指针而不是一个返回指针的函数。<br>
然后注意const对象（比如形参）只能调用const函数，比如上述的const Sales_Data &amp;lhs和const Sales_Data &amp;rhs只能调用const的isbn( )</p>
<p>11.2.3 pair类型<br>
pair为标准库类型，定义在utility中<br>
一个pair保存两个数据成员，pair是一个用来生成特定类型的模板，当创建一个pair时，我们必须提供两个类型名<br>
pair的默认构造函数对数据成员进行<strong>值初始化</strong><br>
我们也可以为每个成员提供列表初始化<br>
pair的数据成员是public的，两个成员分别命名为<strong>first和second</strong><br>
如函数需返回一个pair，在新标准下，我们可以对返回值进行列表初始化<br>
若v不为空，我们返回一个由v中最后一个string及其大小组成的pair，否则隐式构造一个空pair并返回它 <code>return pair&lt;string,int&gt;( );</code><br>
在较早版本中中只能显式构造返回值<br>
同样还可以用make_pair生成pair对象</p>
<p>习题11.12</p>
<pre><code>int main()
{
	vector&lt;pair&lt;string, int&gt;&gt; vp;
	string s;
	int i;
	while (cin &gt;&gt; s&amp;&amp;cin &gt;&gt; i) {
		vp.push_back(make_pair(s, i));
	}
	for (auto p : vp)
		cout &lt;&lt; p.first&lt;&lt;&quot; &quot;&lt;&lt;p.second &lt;&lt; endl;
}
</code></pre>
<p>习题11.13</p>
<pre><code>int main()
{
	vector&lt;pair&lt;string, int&gt;&gt; vp;
	string s;
	int i;
	while (cin &gt;&gt; s&amp;&amp;cin &gt;&gt; i) {
		vp.push_back(make_pair(s, i));
		vp.push_back({ s,i });
		vp.push_back(pair&lt;string, int&gt;(s, i));
	}
	for (auto p : vp)
		cout &lt;&lt; p.first&lt;&lt;&quot; &quot;&lt;&lt;p.second &lt;&lt; endl;
}
</code></pre>
<p>第二种最易于编写，但是不容易理解，第三种最容易理解，但是不易于编写。所以第一种最适合最适中。<br>
习题11.14</p>
<pre><code>int main()
{
	map&lt;string, vector&lt;pair&lt;string,int&gt;&gt;&gt;map_name;
	string first_name, last_name;
	int birth;
	while (cin) {
		cin &gt;&gt; first_name &gt;&gt; last_name&gt;&gt;birth;
		if (map_name.find(first_name) == map_name.end()) {
			map_name.insert({ first_name,{ {last_name,birth} } });
		}
		else
			map_name[first_name].push_back({ last_name,birth });
	}
}
</code></pre>
<p>习题感悟：<br>
注意关联容器也是有顺序的，可以使用begin和end等关联容器<br>
很多字符操作，比如ispunct和tolower等都可以配合_if后缀的泛型算法进行使用。注意for_each和transform的区别，前者其实是无法逐一改变容器元素值的，只有后者添加了参数进行结果复制。<br>
因为虽然函数名本身是一个指针，但是decltype作用于函数名只会返回函数类型而不是一个指针<br>
注意点 如果不能使用decltype，就只能把函数类型完整写出来，主要是把函数名去掉，加上(*)注意括号必须有，指示是一个函数指针而不是一个返回指针的函数。<br>
然后注意const对象（比如形参）只能调用const函数，比如上述的const Sales_Data &amp;lhs和const Sales_Data &amp;rhs只能调用const的isbn( )</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 13. 罗马数字转整数 12. 整数转罗马数字]]></title>
        <id>https://lixin-ee.github.io//post/zi-fu-chuan-13-luo-ma-shu-zi-zhuan-zheng-shu</id>
        <link href="https://lixin-ee.github.io//post/zi-fu-chuan-13-luo-ma-shu-zi-zhuan-zheng-shu">
        </link>
        <updated>2019-10-12T01:38:42.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。<br>
字符          数值<br>
I             1<br>
V             5<br>
X             10<br>
L             50<br>
C             100<br>
D             500<br>
M             1000<br>
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。<br>
通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：<br>
I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 <br>
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>
给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<p>示例 1:<br>
输入: &quot;III&quot;<br>
输出: 3<br>
示例 2:<br>
输入: &quot;IV&quot;<br>
输出: 4<br>
示例 3:<br>
输入: &quot;IX&quot;<br>
输出: 9<br>
示例 4:<br>
输入: &quot;LVIII&quot;<br>
输出: 58<br>
解释: L = 50, V= 5, III = 3.<br>
示例 5:<br>
输入: &quot;MCMXCIV&quot;<br>
输出: 1994<br>
解释: M = 1000, CM = 900, XC = 90, IV = 4.</p>
</blockquote>
<p>这道题一开始还有蛮波折的，我一开始的想法是使用switch，然后两位两位地检测，但是每次只递增一位<br>
然后实现的时候发现会略麻烦，因为第一位和最后一位会比较难处理。<br>
然后突然想到一个问题，如果出现“IXL”这种情况怎么破？，既是IX又是XL？<br>
果断去评论区看看，结果被强行剧透了，可以直接使用map记录相应值，然后检测前一个值是否小于后一个值，如果是的话就需要减去。然后关于IXL这种情况的话，在罗马数字里面是不会出现这种情况的，然后测试用例中也都是正确的罗马数字案例。。。leetcode的题的质量还是有待提高啊。<br>
最后给出的代码如下：</p>
<pre><code>class Solution {
public:
    int romanToInt(string s) {
        int res=0;
        map&lt;char,int&gt; roman {{'I',1},{'V',5},{'X',10},{'L',50},{'C',100},{'D',500},{'M',1000}};
        int temp=0;
        for(int i=0;i&lt;s.size();++i){
            res+=roman[s[i]];
            if(roman[s[i]]&gt;temp)
                res-=2*temp;
            temp=roman[s[i]];
        }
        return res;     
    }
};
</code></pre>
<p>然后看一下网友代码，基本是和我前一种想法相符，使用switch或者map来进行两位字符的匹配，但是最简单还是上述的方法。</p>
<p>12.整数转罗马数字</p>
<blockquote>
<p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。<br>
字符          数值<br>
I             1<br>
V             5<br>
X             10<br>
L             50<br>
C             100<br>
D             500<br>
M             1000<br>
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 <br>
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>
给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p>
<p>示例 1:<br>
输入: 3<br>
输出: &quot;III&quot;<br>
示例 2:<br>
输入: 4<br>
输出: &quot;IV&quot;<br>
示例 3:<br>
输入: 9<br>
输出: &quot;IX&quot;<br>
示例 4:<br>
输入: 58<br>
输出: &quot;LVIII&quot;<br>
解释: L = 50, V = 5, III = 3.<br>
示例 5:<br>
输入: 1994<br>
输出: &quot;MCMXCIV&quot;<br>
解释: M = 1000, CM = 900, XC = 90, IV = 4.</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/integer-to-roman<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题相对简单一点，我的思路就是除以每个值，然后利用switch的case的特性，先把num转化为string得到位数，再根据相应的位数开始跳转到相应的case，并且case之间不需要break，从而从上至下执行一个完整的流程。</p>
<pre><code>class Solution {
public:
    string intToRoman(int num) {
        string s(to_string(num));
        int time=0;
        string res;
        switch(s.size()){
            case 4:
                time=num/1000;
                num=num%1000;
                while(time)
                    res+=&quot;M&quot;,--time;
            case 3:
                time=num/900;
                num=num%900;
                while(time)
                    res+=&quot;CM&quot;,--time;
                time=num/500;
                num=num%500;
                while(time)
                    res+=&quot;D&quot;,--time;
                time=num/400;
                num=num%400;
                while(time)
                    res+=&quot;CD&quot;,--time;
                time=num/100;
                num=num%100;
                while(time)
                    res+=&quot;C&quot;,--time;
            case 2:
                time=num/90;
                num=num%90;
                while(time)
                    res+=&quot;XC&quot;,--time;
                time=num/50;
                num=num%50;
                while(time)
                    res+=&quot;L&quot;,--time;
                time=num/40;
                num=num%40;
                while(time)
                    res+=&quot;XL&quot;,--time;
                time=num/10;
                num=num%10;
                while(time)
                    res+=&quot;X&quot;,--time;
            case 1:
                time=num/9;
                num=num%9;
                while(time)
                    res+=&quot;IX&quot;,--time;
                time=num/5;
                num=num%5;
                while(time)
                    res+=&quot;V&quot;,--time;
                time=num/4;
                num=num%4;
                while(time)
                    res+=&quot;IV&quot;,--time;
                while(num)
                    res+=&quot;I&quot;,--num;
                break;
            default:
                break;
        }
        return res;
    }
};
</code></pre>
<p>然后是网友题解，用到了贪心算法，代码量没那么大</p>
<pre><code>class Solution:
    def intToRoman(self, num: int) -&gt; str:
        # 把阿拉伯数字与罗马数字可能出现的所有情况和对应关系，放在两个数组中
        # 并且按照阿拉伯数字的大小降序排列，这是贪心选择思想
        nums = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
        romans = [&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;]

        index = 0
        res = ''
        while index &lt; 13:
            # 注意：这里是等于号，表示尽量使用大的&quot;面值&quot;
            while num &gt;= nums[index]:
                res += romans[index]
                num -= nums[index]
            index += 1
        return res
复杂度分析：
</code></pre>
<p>时间复杂度：O(1)，虽然看起来是两层循环，但是外层循环的次数最多 12，内层循环的此时其实也是有限次的，综合一下，时间复杂度是 O(1)。<br>
空间复杂度：O(1)，这里使用了两个辅助数字，空间都为 13，还有常数个变量，故空间复杂度是 O(1)。</p>
]]></content>
    </entry>
</feed>