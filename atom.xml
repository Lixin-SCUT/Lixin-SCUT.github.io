<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-03-11T04:38:28.799Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>In the darkest night,rising like a spire.</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[Redis数据库]]></title>
        <id>https://lixin-scut.github.io//post/redis-shu-ju-ku</id>
        <link href="https://lixin-scut.github.io//post/redis-shu-ju-ku">
        </link>
        <updated>2020-03-10T15:24:27.000Z</updated>
        <content type="html"><![CDATA[<h2 id="跳跃表">跳跃表</h2>
<p>跳跃表(skiplist)是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的 指针，从而达到快速访问节点的目的。<br>
跳跃表支持平均O(logN)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。<br>
在大部分情况下，跳跃表的效率可以和平衡树相媲美，并且因为跳跃表的实现比平衡树 要来得更为简单，所以有不少程序都使用跳跃表来代替平衡树。<br>
Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量 比较多，又或者有序集合中元素的成员(member)是比较长的字符串时，Redis就会使用跳 跃表来作为有序集合键的底层实现。</p>
<p><strong>跳跃表的实现</strong><br>
Redis 的跳跃表由 redis.h/zskiplistNode 和 redis.h/zskiplist 两个结构定义，其中zskiplistNode结构用于表示跳跃表节点，而zskiplist结构则用于保存跳跃表节点的相关信息，比如节点的数量，以及指向表头节点和表尾节点的指针等等。<br>
<img src="https://lixin-scut.github.io//post-images/1583856682528.png" alt=""><br>
跳跃表示例，位于图片最左边的是zskiplist结构，该结构包含以 下属性：</p>
<ul>
<li>header：指向跳跃表的表头节点。</li>
<li>tail：指向跳跃表的表尾节点。<br>
通过这两个指针，程序定位表头节点和表尾节点的复杂度为O(1)。</li>
<li>level：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内），用于在O(1)复杂度内获取跳跃表中层高最大的那个节点的层数量</li>
<li>length：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计 算在内），程序可以在O(1)复杂度内返回跳跃表的长度<br>
位于zskiplist结构右方的是四个zskiplistNode结构，该结构包含以下属性：<br>
层（level ）:节点中用LI、L2、L3等字样标记节点的各个层，L1代表第一层，L2 代表第二层，以此类推。每个层都带有两个属性：前进指针和跨度<br>
后退（backward）指针：节点中用BW字样标记节点的后退指针，它指向位于当前节 点的前一个节点。<br>
分值（score）：各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中， 节点按各自所保存的分值从小到大排列。<br>
成员对象（obj）：各个节点中的o1、o2和o3是节点所保存的成员对象。</li>
</ul>
<p>注意表头节点和其他节点的构造是一样的：表头节点也有后退指针、分值和成员对象，不 过表头节点的这些属性都不会被用到</p>
<p><strong>层</strong><br>
跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指 针，程序可以通过这些层来加快访问其他节点的速度，一般来说，层的数量越多，访问其他 节点的速度就越快。<br>
每次创建一个新跳跃表节点的时候，程序都根据幂次定律（power law,越大的数出现 的概率越小）随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的“高度”。</p>
<p><strong>前进指针</strong><br>
每个层都有一个指向表尾方向的前进指针（level[i] .forward属性），用于从表头 向表尾方向访问节点。</p>
<p><strong>跨度</strong><br>
层的跨度（level [i] .span属性）用于记录两个节点之间的距离：<br>
□两个节点之间的跨度越大，它们相距得就越远。<br>
□指向NULL的所有前进指针的跨度都为0,因为它们没有连向任何节点。<br>
初看上去，很容易以为跨度和遍历操作有关，但实际上并不是这样，遍历操作只使用前 进指针就可以完成了，跨度实际上是用来计算排位（rank）的：在查找某个节点的过程中， 将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。</p>
<p><strong>后退指针</strong><br>
节点的后退指针（backward属性）用于从表尾向表头方向访问节点：跟可以一次跳过 多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次只能后退至前一个节点。</p>
<p><strong>分值和成员</strong><br>
节点的分值（score属性）是一个doubl e类型的浮点数，跳跃表中的所有节点都按 分值从小到大来排序。<br>
节点的成员对象（obj属性）是一个指针，它指向一个字符串对象，而字符串对象则保 存着一个SDS值。<br>
在同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值 却可以是相同的：分值相同的节点将按照成员对象在字典序中的大小来进行排序，成员对象</p>
<p><strong>跳跃表的原理</strong><br>
跳跃表在redis中主要是有序表的一种底层实现。对于普通链表的查找，即使有序，我们也不能使用二分法，需要从头开始，一个一个找，时间复杂度为O(n)。而对于跳跃表，从名字可以看出跳跃表的优势就在于可以跳跃。如何做到呢？在于其特殊的层设计。比如我们查找46，普通链表只能从头开始查找，比对-3,2,17...直到46，要比对7次。但是对于跳跃表，我们可以从最高层开始查找：<br>
第一步：在L4层直接与55比对，发现大了，退回到第3层<br>
第二步：在L3层与21比对，发现小了，继续往前比对55，发现大了，退回到第二层<br>
第三步：在L2层与37比对，发现小了，往前，与55比对，发现大了，退回到第一层<br>
第四步：在第1层，与46比对，查找成功。<br>
共比对了6次，比普通链表只节省了一次，似乎没什么优势。但如果细想，当链表比较长的时候，在高层查找时，跳过的元素数量将相当可观，提速的效果将非常明显。比如如果元素在55之后，在L4层，我们直接就跳过了7个元素，这是非常大的进步。<br>
<img src="https://lixin-scut.github.io//post-images/1583858207217.png" alt=""><br>
<a href="https://blog.csdn.net/qq_34412579/article/details/101731935">跳表的各种时间复杂度、适用场景以及实现原理</a></p>
<h2 id="redis持久化">Redis持久化</h2>
<h3 id="rdb持久化">RDB持久化</h3>
<p>将服务器中的非空数据库以及它 们的键值对统称为数据库状态。<br>
Redis是内存数据库，它将自己的数据库状态储存在内存里面，必须将储存在内存中的数据库状态保存到磁盘 里面<br>
Redis提供了 RDB持久化功能，这个功能可以将Redis在内存中的数据库状态保存到磁盘里面，避免数据意外丢失。<br>
RDB持久化既可以手动执行，也可以根据服务器配置选项定期执行，该功能可以将某 个时间点上的数据库状态保存到一个RDB文件中<br>
RDB持久化功能所生成的RDB文件是一个经过压缩的二进制文件，通过该文件可以还 原生成RDB文件时的数据库状态</p>
<p><strong>RDB文件的创建与载入</strong><br>
有两个Redis命令可以用于生成RDB文件，一个是SAVE,另一个是BGSAVE<br>
SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞 期间，服务器不能处理任何命令请求：<br>
BGSAVE命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程(父进程)继续处理命令请求：<br>
创建RDB文件的实际工作由rdb.c/rdbSave函数完成<br>
RDB文件的载入工作是在服 务器启动时自动执行的，所以Redis并没有专门用于载入RDB文件的命令，只要Redis服 务器在启动时检测到RDB文件存在，它就会自动载入RDB文件。</p>
<p>因为AOF文件的更新频率通常比RDB文件的更新频率高，所以：</p>
<ul>
<li>如果服务器开启了 AOF持久化功能，那么服务器会优先使用AOF文件来还原数据 库状态。</li>
<li>只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。</li>
</ul>
<h3 id="aof持久化">AOF持久化</h3>
<p>除了 RDB持久化功能之外，Redis还提供了 AOF ( Append Only File )持久化功能。与 RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是通过保存 Redis服务器所执行的写命令来记录数据库状态的<br>
RDB持久化保存数据库状态的方法是将键值对保存到RDB文件中，而AOF持久化保存数据库状态的方法则是将服务器执行的SET、SADD、 RPUSH等命令保存到AOF文件中。<br>
服务器在启动时，可以通过载入和执行AOF文件中保存的命令来还原服务器关闭之前 的数据库状态</p>
<p><strong>AOF持久化的实现</strong><br>
AOF持久化功能的实现可以分为命令追加(append)、文件写入、文件同步(sync)三个步骤。</p>
<p><strong>命令追加</strong><br>
当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式 将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾<br>
注意写命令亦即修改数据库的命令，删除也是写命令，写命令不仅是添加命令</p>
<p><strong>AOF文件的写入与同步</strong><br>
Redis的服务器进程就是一个事件循环(loop),这个循环中的文件事件负责接收客户端 的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像serverCron函数这样需要定时运行的函数。<br>
因为服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到aof_buf缓冲 区里面，所以在服务器每次结束一个事件循环之前，它都会调用flushAppendOnlyFile函数，考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里面<br>
<img src="https://lixin-scut.github.io//post-images/1583855911517.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1583855930254.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1583855956684.png" alt=""></p>
<p><strong>AOF文件的载入与数据还原</strong><br>
因为AOF文件里面包含了重建数据库状态所需的所有写命令，所以服务器只要读入并 重新执行一遍AOF文件里面保存的写命令，就可以还原服务器关闭之前的数据库状态。</p>
<p><strong>AOF 重写</strong><br>
因为AOF持久化是通过保存被执行的写命令来记录数据库状态的，所以随着服务器运 行时间的流逝，AOF文件中的内容会越来越多，文件的体积也会越来越大，如果不加以控 制的话，体积过大的AOF文件很可能对Redis服务器、甚至整个宿主计算机造成影响，并 且AOF文件的体积越大，使用AOF文件来进行数据还原所需的时间就越多。<br>
为了解决AOF文件体积膨胀的问题，Redis提供了 AOF文件重写（rewrite）功能。通 过该功能，Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件，新旧两个 AOF文件所保存的数据库状态相同，但新AOF文件不会包含任何浪费空间的冗余命令，所 以新AOF文件的体积通常会比旧AOF文件的体积要小得多。</p>
<p><strong>AOF文件重写的实现</strong><br>
虽然Redis将生成新AOF文件替换旧AOF文件的功能命名为“AOF文件重写”，但实 际上，AOF文件重写并不需要对现有的AOF文件进行任何读取、分析或者写入操作，这个 功能是通过读取服务器当前的数据库状态来实现的。<br>
从数据库中读取键现在的值，然后用一条命令去记录键值对， 代替之前记录这个键值对的多条命令，这就是AOF重写功能的实现原理。<br>
aof_rewrite函数生成的新AOF文件只包含还原当前数据库状态所必须的命令, 所以新AOF文件不会浪费任何硬盘空间。</p>
<p><strong>AOF后台重写</strong><br>
上面介绍的AOF重写程序aof_rewrite函数可以很好地完成创建一个新AOF文件的 任务，但是，因为这个函数会进行大量的写入操作，所以调用这个函数的线程将被长时间阻塞, 因为Redis服务器使用单个线程来处理命令请求，所以如果由服务器直接调用aof_rewrite函数的话，那么在重写AOF文件期间，服务期将无法处理客户端发来的命令请求。<br>
所以Redis决定将AOF重写程序放到子进程里执行，这样做可以同时达到两个 目的：</p>
<ul>
<li>子进程进行AOF重写期间，服务器进程（父进程）可以继续处理命令请求。</li>
<li>子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的 情况下，保证数据的安全性。<br>
不过，使用子进程也有一个问题需要解决，因为子进程在进行AOF重写期间，服务器 进程还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，从而使得 服务器当前的数据库状态和重写后的AOF文件所保存的数据库状态不一致。</li>
</ul>
<p>为了解决这种数据不一致问题，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区 在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令之后，它会同时将这 个写命令发送给AOF缓冲区和AOF重写缓冲区，</p>
<p>这样一来可以保证：</p>
<ul>
<li>AOF缓冲区的内容会定期被写入和同步到AOF文件，对现有AOF文件的处理工作 会如常进行。</li>
<li>从创建子进程开始，服务器执行的所有写命令都会被记录到AOF重写缓冲区里面。<br>
当子进程完成AOF重写工作之后，它会向父进程发送一个信号，父进程在接到该信号 之后，会调用一个信号处理函数，并执行以下工作：<br>
1 ）将AOF重写缓冲区中的所有内容写入到新AOF文件中，这时新AOF文件所保存的 数据库状态将和服务器当前的数据库状态一致。<br>
2）对新的AOF文件进行改名，原子地（atomic）覆盖现有的AOF文件，完成新旧两 个AOF文件的替换。</li>
</ul>
<h2 id="慢查询日志">慢查询日志</h2>
<p>Redis的慢查询日志功能用于记录执行时间超过给定时长的命令请求，用户可以通过这 个功能产生的日志来监视和优化查询速度。<br>
服务器配置有两个和慢查询日志相关的选项：</p>
<ul>
<li>slowlog-log-slower-than选项指定执行时间超过多少微秒（1秒等于1 000 000 微秒）的命令请求会被记录到日志上。</li>
<li>slowlog-max-len选项指定服务器最多保存多少条慢查询日志。<br>
服务器使用先进先出的方式保存多条慢查询日志，当服务器存储的慢查询日志数量等于 slowlog-max-len选项的值时，服务器在添加一条新的慢查询日志之前，会先将最旧的 一条慢查询日志删除。</li>
</ul>
<p>使用SLOWLOG GET命令查看服务器所保存的慢查询日志:</p>
<p><strong>添加新日志</strong><br>
在每次执行命令的之前和之后，程序都会记录微秒格式的当前UNIX时间戳，这两个时间戳之间的差就是服务器执行命令所耗费的时长，服务器会将这个时长作为参数之一传给 slowlogPushEntryIfNeeded 函数，而 slowlogPushEntryIfNeeded 函数贝则负责检查是否需要为这次执行的命令创建慢查询日志</p>
<h2 id="线程">线程</h2>
<p>redis是单线程，线程安全<br>
redis可以能够快速执行的原因：<br>
(1) 绝大部分请求是纯粹的内存操作（非常快速）<br>
(2) 采用单线程,避免了不必要的上下文切换和竞争条件<br>
(3) 非阻塞IO - IO多路复用<br>
IO多路复用中有三种方式：select,poll,epoll。需要注意的是，select,poll是线程不安全的，epoll是线程安全的<br>
redis内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间 这3个条件不是相互独立的，特别是第一条，如果请求都是耗时的，采用单线程吞吐量及性能可想而知了。应该说redis为特殊的场景选择了合适的技术方案。</p>
<p>redis是单线程运行，所以多个redis命令是一个一个执行，所以是线程安全的 ， 但是分开的两个redis命令，对于【应用】不是线程安全的，因为这两个redis命令之间会有其他命令，就像不安全的i++操作，这个两个redis命令没有事务管理<br>
可以用RPOPLPUSH, 或者lua脚本，实现多个redis操作合为一个命令，这样就对【应用】线程安全了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[索引]]></title>
        <id>https://lixin-scut.github.io//post/suo-yin</id>
        <link href="https://lixin-scut.github.io//post/suo-yin">
        </link>
        <updated>2020-03-10T15:13:24.000Z</updated>
        <content type="html"><![CDATA[<p>为了快速随机访问文件中的记录，可以使用索引结构。每个索引结构与一个特定的搜索码相关联。<br>
索引中的词是按顺序排列的，数据库系统首先会查找索引，找到相应记录所在的磁盘块，然后取出该磁盘块,得到所需的记录。</p>
<p>有两种基本的索引类型：</p>
<ul>
<li>顺序索引。基于值的顺序排序。</li>
<li>散列索引。基于将值平均分布到若干散列桶中。一个值所属的散列桶是由一个函数决定的，该函数称为散列函数(hash function)。</li>
</ul>
<p><strong>顺序索引</strong><br>
顺序索引按顺序存储搜索码的值，并将每个搜索码与包含该搜 索码的记录关联起来。</p>
<ol>
<li>一个文件可以有多个索引，分别基于不同的搜索码。如果包含记录的文件按照某个搜索码指定的顺序排序，那么该搜索码对应的索引称为聚集索引。聚集索引称为主索引。聚集索引的搜索码常常是主码。</li>
<li>搜索码指定的顺序与文件中记录的物理顺序不同的索引成为非聚集索引或者辅助索引<br>
假定所有文件都按照某些搜索码顺序排列。这种在搜索码上有聚集索引的文件称为索引顺序文件</li>
</ol>
<p><strong>稠密索引和稀疏索引</strong><br>
索引项(index entry)或索引记录(index record)由一个搜索码值和指向具有该搜索码值的一条或者多条记录的指针构成，指向记录的指针包括磁盘块的标识和标识磁盘块内记录的块内偏移量<br>
我们可以使用的顺序索引有两类</p>
<ul>
<li>稠密索引：在稠密索引中，文件中的每个搜索码值都有一个索引项。在稠密聚集索引中，索引项包括搜索码值以及指向具有该搜索码值的第一条数据记录的指针。具有相同搜索码值的其余记录顺序地存储在第一条数据记录之后，由于该索引是聚集索引，因此记录根据相同的搜索码值排序。<br>
在稠密非聚集索引中，索引必须存储指向所有具有相同搜索曲旺衅翊也</li>
<li>稀疏索引：在稀疏索引中，只为搜索码的某些值建立索引项。只有当关系按搜索码排列顺序存储时才能使用稀疏索引，换句话说，只有索引是聚集索引时才能使用稀疏索引。 和稠密索引一样，每个索引项也包括一个搜索码值和指向具有该搜索码值的第一条数据记录的 指针。为了定位一条记录，我们找到其最大搜索码值小.坚等于所查找记录的搜索码值的索引，然后从该索引项指向的记录开始，沿着文件中的指针查找，直到找到所需的记录为止（字典中 每页顶部的单词共同构成了字典页内容的稀疏索引）。</li>
</ul>
<p>具有两级或两级以上的索引称为多级索引，利用多级索引搜索记录与用二分法搜索记录相比需要的I/O操作要少得多°。</p>
<p><strong>辅助索引</strong><br>
辅助索引必须是稠密索引，对每个搜索码值都有一个索引项，而且对文件中的每条记录都有一个指针。<br>
候选码上的辅助索引看起来和稠密聚集索引没有太大的区别，只不过索引中一系列的连续值指向 的记录不是连续存放的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[事务性隔离性级别]]></title>
        <id>https://lixin-scut.github.io//post/shi-wu-xing-ge-chi-xing-ji-bie</id>
        <link href="https://lixin-scut.github.io//post/shi-wu-xing-ge-chi-xing-ji-bie">
        </link>
        <updated>2020-03-10T14:33:26.000Z</updated>
        <content type="html"><![CDATA[<h3 id="事务性隔离性级别">事务性隔离性级别</h3>
<ul>
<li>可串行化(serializable)：通常保证可串行化调度。<br>
最高的隔离级别，它通过强制事务串行执行（注意是串行），避免了幻读情况，由于他大量加上锁，导致大量的请求超时，因此性能会比较底下，再特别需要数据一致性且并发量不需要那么大的时候才可能考虑这个隔离级别。</li>
<li>可重复读(repeatable read)：只允许读取已提交数据，而且在一个事务两次读取一个数据项期间，其他事务不得更新该数据。<br>
解决了脏读的问题，该级别保证了每行的记录的结果是一致的，也就是上面说的读了旧数据的问题，但是却无法解决另一个问题，幻读，指的就是某个事务在读取某个范围的数据，但是另一个事务又向这个范围的数据去插入数据，导致多次读取的时候，数据的行数不一致。虽然读取同一条数据可以保证一致性，但是却不能保证没有插入新的数据。</li>
<li>已提交读(read committed)：只允许读取已提交数据，但不要求可重复读。<br>
大多数数据库系统的默认隔离级别是READ COMMITTED，这种隔离级别就是一个事务的开始，只能看到已经完成的事务的结果，正在执行的，是无法被其他事务看到的。这种级别会出现读取旧数据的现象</li>
<li>未提交读(read uncommitted):允许读取未提交数据。<br>
事务中的修改，即使没有提交，其他事务也可以看得到，这种现象就叫做脏读，这种隔离级别会引起很多问题，如无必要，不要随便使用；这就是事务还没提交，而别的事务可以看到他其中修改的数据的后果，也就是脏读；</li>
</ul>
<p>以上所有隔离性级别都不允许脏写(dirty write),即如果一个数据项已经被另外一个尚未提交或中止的事务写入，则不允许对该数据项执行写操作。</p>
<p>隔离级别高的数据库的可靠性高，但并发量低，而隔离级别低的数据库可靠性低，但并发量高，系统开销小。</p>
<h3 id="幻读">幻读</h3>
<p>事务在插入已经检查过不存在的记录时，惊奇的发现这些数据已经存在了，之前的检测获取到的数据如同鬼影一般。<br>
MySql默认的隔离级别为Repeatable Read，因此只会出现幻读的情况。<br>
例子：<br>
在事务1中，查询User表id为1的是用户否存在，如果不存在则插入一条id为1的数据。<br>
<code>select * from User where id = 1;</code><br>
在事务1查询结束后，事务2往User表中插入了一条id为1的数据。<br>
<code>insert into</code>User<code>(</code>id<code>,</code>name<code>) values (1, 'Joonwhee');</code><br>
此时，由于事务1查询到id为1的用户不存在，因此插入1条id为1的数据。<br>
<code>insert into</code> User<code>(</code>id<code>,</code>name<code>) values (1, 'Chillax');</code><br>
但是由于事务2已经插入了1条id为1的数据，因此此时会报主键冲突，对于事务1 的业务来说是执行失败的，这里事务1就是发生了幻读，因为事务1读取的数据状态并不能支持他的下一步的业务，见鬼了一样。这里要灵活的理解读取的意思，第一次select是读取，第二次的insert其实也属于隐式的读取，只不过是在mysql的机制中读取的，插入数据也是要先读取一下有没有主键冲突才能决定是否执行插入。</p>
<h3 id="如何解决幻读">如何解决幻读</h3>
<p>将两行记录间的空隙加上锁，阻止新记录的插入；这个锁称为间隙锁。<br>
间隙锁与间隙锁之间没有冲突关系。跟间隙锁存在冲突关系的，是往这个间隙中插入一个记录这个操作。</p>
<h3 id="数据的锁的种类加锁的方式">数据的锁的种类，加锁的方式</h3>
<ol>
<li>锁是网络数据库中的一个非常重要的概念，当多个用户同时对数据库并发操作时，会带来数据不一致的问题，所以，锁主要用于多用户环境下保证数据库完整性和一致性。</li>
<li>数据库锁出现的目的：处理并发问题；</li>
<li>并发控制的主要采用的技术手段：乐观锁、悲观锁和时间戳。</li>
<li>从数据库系统角度分为三种：排他锁、共享锁、更新锁。从程序员角度分为两种：一种是悲观锁，一种乐观锁。</li>
</ol>
<h3 id="乐观锁与悲观锁">乐观锁与悲观锁</h3>
<p>注意乐观锁和悲观锁不是一种特定锁，而是指检查冲突手段的差异</p>
<p><strong>乐观锁</strong><br>
乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。乐观锁不会刻意使用数据库本身的锁机制，而是依据数据本身来保证数据的正确性。<br>
<img src="https://lixin-scut.github.io//post-images/1583851830110.png" alt=""><br>
在有效性检查机制中，由于事务乐观地执行，假定它们能够完成执行并且最终有效，因此也称为乐观的并发控制(optimistic concurrency control)机制。<br>
乐观锁的概念中其实已经阐述了它的具体实现细节。主要就是两个步骤：冲突检测和数据更新。其实现方式有一种比较典型的就是CAS(Compare and Swap)。</p>
<p>CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。<br>
我们在更新之前，先查询一下库存表中当前库存数（quantity），然后在做update的时候，以库存数作为一个修改条件。当我们提交更新的时候，判断数据库表对应记录的当前库存数与第一次取出来的库存数进行比对，如果数据库表当前库存数与第一次取出来的库存数相等，则予以更新，否则认为是过期数据。</p>
<p><strong>悲观锁：</strong><br>
悲观锁的实现往往依靠数据库提供的锁机制。在数据库中，悲观锁的流程如下：</p>
<ol>
<li>在对记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。</li>
<li>如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。具体响应方式由开发者根据实际需要决定。</li>
<li>如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。</li>
<li>期间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。</li>
<li>例如在对id = 1的记录修改前，先通过select…for update的方式进行加锁，然后再进行修改。这就是比较典型的悲观锁策略。<br>
封锁和时间戳排序是悲观的，因为当它们检测 到一个冲突时，它们强迫事务等待或回滚，即使该调度有可能是冲突可串行化的。</li>
</ol>
<p><strong>如何选择</strong></p>
<ol>
<li>在乐观锁与悲观锁的选择上面，主要看下两者的区别以及适用场景就可以了。<br>
乐观锁并未真正加锁，效率高。一旦锁的粒度掌握不好，更新失败的概率就会比较高，容易发生业务失败。</li>
<li>悲观锁依赖数据库锁，效率低。更新失败的概率比较低。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[放松系列！智力题]]></title>
        <id>https://lixin-scut.github.io//post/fang-song-xi-lie-zhi-li-ti</id>
        <link href="https://lixin-scut.github.io//post/fang-song-xi-lie-zhi-li-ti">
        </link>
        <updated>2020-03-10T12:21:03.000Z</updated>
        <content type="html"><![CDATA[<p>投完简历很紧张很紧张，但是也不想做那种无意义的放纵行为<br>
发现个很有趣的放松方法，就是看看那些智力题，答案都特别意料之外hhh，但是又是巧妙地将学到的算法和数据结构运用起来了。</p>
<h3 id="摔鸡蛋">摔鸡蛋：</h3>
<p>两个鸡蛋一样，只有在达到某个楼层高度时，才会摔碎。问100层楼至少需要试多少次？<br>
<strong>假设法</strong><br>
假设最多允许尝试X次，问能尝试到的最高的楼层。</p>
<ul>
<li>第1次从X楼扔下来。因为即使摔坏了，也可以用另一个鸡蛋遍历X-1次找到该楼层</li>
<li>第2次（还剩X-1次尝试次数）可以从X+(X-1)层扔下来。因为即使摔碎了，也可以用另一个鸡蛋遍历X-1-1次找到该楼层。</li>
<li>同理，第3次，可以从X+(X-1)+(X-2)层扔下来。</li>
<li>第X次。可以从第X+(X-1)+(X-2)+...+(X-(X-2))+1层扔下来，这就是最高可能尝试到的楼层X*(X+1)/2，下面所有的楼层都可以在X次尝试中到达。</li>
<li>当最高楼层为100时，可列出不等式：最高可能尝试到的楼层X*(X+1)/2 &gt; 100，解出X=14次。这就是最稳定的最快寻找到该楼层的扔鸡蛋次数。也就是说第一次扔鸡蛋要从14楼开始扔。14+13+12+11+...+2+1 = 105层，也就是14次尝试一定可以在1-105层中找到那个第N层。推出了公式X*(X+1)/2后，要想编程求任意总楼层条件下，就都很方便了。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 海量数据处理问题]]></title>
        <id>https://lixin-scut.github.io//post/hai-liang-shu-ju-zhao-zhong-wei-shu</id>
        <link href="https://lixin-scut.github.io//post/hai-liang-shu-ju-zhao-zhong-wei-shu">
        </link>
        <updated>2020-03-10T02:24:51.000Z</updated>
        <content type="html"><![CDATA[<p>这类题目的通用格式为：</p>
<blockquote>
<p>一个存有m个整数的文件，只有n G内存，写一个算法从中找到中位数。<br>
其中m以亿计，n多为1或2或4，无法一次完整读入m个数。</p>
</blockquote>
<p>比较类似的题目是<a href="https://lixin-scut.github.io/post/shu-zu-ti-41shu-ju-liu-de-zhong-wei-shu/">数组 题41:数据流的中位数</a><br>
但是请注意，大小顶堆的方法为了保证实时性是需要保留值的，所以不可能适用于这道题。</p>
<p>下面是给出了四种解决思路</p>
<h3 id="外排序">外排序</h3>
<p>使用外排序算法<br>
这个就太广了...思路二属于外排序的一个特例</p>
<h3 id="多路归并">多路归并</h3>
<ol>
<li>先对每nG个数进行排序，得到k个有序数组/链表</li>
<li>对k路数组/链表进行归并排序</li>
<li>其中利用堆来不断输出最值。</li>
</ol>
<h3 id="借鉴基数排序思想">借鉴基数排序思想</h3>
<p>可以用位来判断计数,从最高位到最低位。</p>
<ol>
<li>遍历所有数据，比较二进制的最高位(假设为第32位)，如果数字的最高位为0，则将这个数字写入 file_0文件中；如果最高位为 1，则将该数字写入file_1文件中。并记录最高位为0和1的个数（最高位为0的肯定是小于最高位为1的）记为N0、N1</li>
<li>根据N0和N1的大小就可以知道中位数的最高位是0还是1</li>
<li>假设N0&gt;N1，那么再计算最高位的下一位N00和N01，注意此时要顺应地变更中位数的位置为N0 -（N0+(N1-N0)/2）,而不是N0/2。</li>
</ol>
<p>改进：因为每位都只有0和1，可以设定多个计数器统计不同位数的值，这样一次只要磁盘io也可以统计出N0,N00,....的数值</p>
<h3 id="借鉴桶排序思想">借鉴桶排序思想</h3>
<p>例子<br>
一个整数假设为是32位无符号数<br>
第一次扫描把0~2<sup>32-1分成2</sup>16个区间，记录每个区间的整数数目<br>
找出中位数具体所在区间65536<em>i~65536</em>(i+1)-1<br>
第二次扫描则可找出具体中位数数值<br>
第一次扫描已经找出中位数具体所在区间65536<em>i~65536</em>(i+1)-1<br>
然后第二次扫描再统计在该区间内每个数出现的次数，就可以了<br>
详细流程<a href="https://blog.csdn.net/sytu_hzj/article/details/6856775">借鉴桶排序思想</a></p>
<p>从10亿个数据（int型占据4B）中找中位数，内存限制为2GB。</p>
<ol>
<li>读一遍10亿个整数，把整数映射进256M个区间中，每个区间有一个64位的无符号整数记录值位于该区间的元素个数。<br>
8B*256M=2GB，每个区间的值区间是2<sup>32/2</sup>28(256M)=16，即第一个区间统计值在0-15范围的整数个数，第二个区间统计值在16-31范围的整数个数。。。</li>
<li>从前往后对每一区段的个数累加，当这个值超过5亿时，记录下这个超过5亿的区段，即它的值的范围，记为[a,a+15]；比如如果加到这一段时，刚好是5亿零5，那么需要找出[a,a+15]区间的第5小的数。我们需要记录这一区段前的区段和m。然后释放内存。</li>
<li>再次遍历10亿个整数，对[a,a+15]值范围的整数计数，共有16个计数，</li>
<li>对新的计数依次与m进行累加，如果超过5亿就停止，该计数所对应的数值即第5亿个数字。<br>
改进：<br>
（1）如果是32位有符号整数，可以改变映射区间，有负有正。<br>
（2）如果是64位，可以增大区间范围<br>
（3）如果某区间的计数过大，发生溢出，就认为该整数即为所求或需做相应的处理。</li>
</ol>
<h1 id="其他海量数据处理问题总结">其他海量数据处理问题总结</h1>
<h2 id="top-n问题">TOP N问题</h2>
<ol>
<li>如何在海量数据中找出重复最多一个。</li>
</ol>
<ul>
<li>
<p>通过hash映射为小文件</p>
</li>
<li>
<p>通过hash_map统计各个小文件重读最多的并记录次数</p>
</li>
<li>
<p>对每个小文件重复最多的进行建立大根堆</p>
</li>
</ul>
<ol start="2">
<li>上亿有重数据，统计最多前N个。</li>
</ol>
<ul>
<li>
<p>内存存不下</p>
<ul>
<li>
<p>通过hash映射为小文件</p>
</li>
<li>
<p>通过hash_map统计各个小文件重读最多的并记录次数</p>
</li>
<li>
<p>对每个小文件重复最多的进行建立大根堆并重复N次取走堆顶并重建堆操作</p>
</li>
</ul>
</li>
<li>
<p>内存存得下</p>
<ul>
<li>
<p>直接内存通过hash_map统计并建大根堆</p>
</li>
<li>
<p>重复N次取走堆顶并重建堆操作</p>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li>海量日志数据，提取出某日访问百度次数最多的那个IP（同1）。</li>
</ol>
<ul>
<li>
<p>将IP % 1000映射到1000个小文件中</p>
<ul>
<li>
<p>相同IP会被映射到同一个文件</p>
</li>
<li>
<p>不会出现累加和更大情况</p>
</li>
</ul>
</li>
<li>
<p>分1000次在内存处理小文件，得到频率最大IP（使用map统计）</p>
</li>
<li>
<p>对这1000个IP建立大根堆</p>
</li>
</ul>
<ol start="4">
<li>1000w查询串统计最热门10个（同2）。</li>
</ol>
<ul>
<li>同上</li>
</ul>
<ol start="5">
<li>1G的文件，里面1行1个不超过16字节的词。内存限制1M，返回频数最高前100（同2）。</li>
</ol>
<ul>
<li>
<p>将单词 % 5000存入5000小文件</p>
<ul>
<li>
<p>平均各文件约200K</p>
</li>
<li>
<p>对超过1M的文件继续分割直到小于200K</p>
</li>
</ul>
</li>
<li>
<p>使用map统计各个词出现的频率</p>
</li>
<li>
<p>对5000词使用堆排序或归并排序</p>
</li>
</ul>
<h2 id="分布式top-n问题">分布式TOP N问题</h2>
<ol start="6">
<li>分布在100台电脑的海量数据，统计前十。</li>
</ol>
<ul>
<li>
<p>各数据只出现在一台机器中</p>
<ul>
<li>
<p>先在独立机器得到前十</p>
<ul>
<li>
<p>若可以放入内存直接堆排序</p>
</li>
<li>
<p>若不可全放入内存：哈希分块 -&gt; map统计 -&gt; 归总堆排</p>
</li>
</ul>
</li>
<li>
<p>再将100台计算机的TOP10组合起来堆排序</p>
</li>
</ul>
</li>
<li>
<p>同一元素可同时出现在不同机器中</p>
<ul>
<li>遍历所有数据，重新hash取模，使同一个元素只出现在单独的一台电脑中，然后采用上面方法先统计每台电脑TOP10再汇总起来</li>
</ul>
</li>
</ul>
<h2 id="快速外排序问题">快速外排序问题</h2>
<ol start="7">
<li>有10个1G文件，每行都是一个可重复用户query，按query频度排序。</li>
</ol>
<ul>
<li>
<p>顺序读取十个文件并采取哈希，将query写入10个文件中</p>
</li>
<li>
<p>通过hash_map(query, count)统计每个query出现次数，至少2G内存</p>
</li>
<li>
<p>通过得到的hash_map中query和query_count，对query_count排序并将重新输出到文件中，得到已排序好的文件</p>
</li>
<li>
<p>对十个文件进行归并排序（外排序）</p>
</li>
</ul>
<h2 id="公共数据问题">公共数据问题</h2>
<ol start="8">
<li>A,B两个文件各存放50亿url，每个为64Byte，限制内存4G找出公共url。</li>
</ol>
<ul>
<li>
<p>对A和B两个大文件，先通过url % 1000将数据映射到1000个文件中，单个文件大小约320M（我们只需要检查对应小文件A1 V B1......，不对应小文件不会有相同url）</p>
</li>
<li>
<p>通过hash_set统计，把A1的url存储到hash_set中，再遍历对应的B1小文件，检查是否在hash_set中，若存在则写入外存。重复循环处理对应的1000个对。</p>
</li>
</ul>
<ol start="9">
<li>1000w有重字符串，对字符串去重。</li>
</ol>
<ul>
<li>
<p>先hash分为多个文件</p>
</li>
<li>
<p>逐个文件检查并插入set中</p>
</li>
<li>
<p>多个set取交集</p>
</li>
</ul>
<h2 id="内存内top-n问题">内存内TOP N问题</h2>
<ol start="10">
<li>100w个数字找出最大100个。</li>
</ol>
<ul>
<li>
<p>堆排序法</p>
<ul>
<li>建大根堆，取走堆顶并重建堆，重复100次</li>
</ul>
</li>
<li>
<p>快排法</p>
<ul>
<li>使用快速排序划分，若某次枢纽元在后10000时（具体情况具体分析），对后10000数据排序后取前100</li>
</ul>
</li>
</ul>
<h2 id="位图法">位图法</h2>
<ol start="11">
<li>在2.5亿数字中找出不重复的整数。</li>
</ol>
<ul>
<li>
<p>使用2-Bit位图法，00表示不存在，01表示出现一次，10表示出现多次，11无意义。这样只需要1G内存。</p>
</li>
<li>
<p>或者hash划分小文件，小文件使用hash_set检查各个元素，得到的。</p>
</li>
</ul>
<ol start="12">
<li>如何在40亿数字中快速判断是否有某个数？</li>
</ol>
<ul>
<li>位图法标记某个数字是否存在，check标记数组。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Nim 游戏-轮流拿东西题目的核心思想]]></title>
        <id>https://lixin-scut.github.io//post/nim-you-xi-na-dong-xi-ti-mu-de-he-xin-si-xiang</id>
        <link href="https://lixin-scut.github.io//post/nim-you-xi-na-dong-xi-ti-mu-de-he-xin-si-xiang">
        </link>
        <updated>2020-03-10T02:01:04.000Z</updated>
        <content type="html"><![CDATA[<p>已经碰见这道题目好几次了<br>
<a href="https://lixin-scut.github.io/post/nao-jin-ji-zhuan-wan-292-nim-you-xi-jian-dan/">脑筋急转弯 292. Nim 游戏[简单]</a><br>
另外一种形式是：</p>
<blockquote>
<p>20 个银币，1 个金币，每次拿 1 个到 4 个，金币只能最后一个拿，且金币银币不能同时 拿，现在你先开始拿，问如何拿到金币。</p>
</blockquote>
<p>总结一下这类题的特征是</p>
<ol>
<li>其实有m个物品</li>
<li>每次必须拿1～n个</li>
<li>自己先手</li>
</ol>
<p>顺着推情况太多种了，我们尝试利用倒推法<br>
如果对面必输，那他最后肯定是面对n+1个的情况，因为无论他怎么拿，都只能剩下1～n个。<br>
再往上倒推，怎么让他最后肯定是面对n+1个的情况？我想了一下发现是有规律的，可以把剩下的物品全部划分为多个n+1的子部分，我要做的就是在他拿走x个之后，我再拿 n+1-x个<br>
但是上述是他先手，我后手控制，而且必须要求起始的物品个数是n+1的倍数<br>
所以问题的答案很明显了，我一次先手拿i个，就是为了使得m-i为n+1的倍数，如果m一开始就是n+1的倍数，那么等于我必输无疑。</p>
<p>相应的解题代码为</p>
<pre><code>class Solution {
public:
    bool canWinNim(int m, int n) {
        return m%(n+1) != 0;
    }
};

class Solution {
public:
    bool canWinNim(int m, int n) {
        return m &amp; n;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math 题60:n个骰子的点数]]></title>
        <id>https://lixin-scut.github.io//post/math-ti-60n-ge-tou-zi-de-dian-shu</id>
        <link href="https://lixin-scut.github.io//post/math-ti-60n-ge-tou-zi-de-dian-shu">
        </link>
        <updated>2020-03-10T00:21:50.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p>
<p>书本题解：</p>
<blockquote>
<p>一共有 6 个面，每个面上都有一个点数, 对应的 是1〜6之间的一个数字。所以n个骰子的点数和的最小值为n，最大值为6n。另外，根据排列组合的知识，我们还知道n个骰子的所有点数 的排列数为 6^n。要解决这个问题，我们需要先统计出每个点数出现的次数，然后把每个点数出现的次数除以 6^n,就能求出每个点数出现的概率。</p>
</blockquote>
<blockquote>
<p>解法一:基于递归求骰子点数,时间效率不够高<br>
要想求出n个骰子的点数和，可以先把n个骰子分为两堆:第一堆只有一个;另一堆有n-1个。单独的那一个有可能出现1〜6的点数。我们需要计算1〜6的每一种点数和剩下的n-1个骰子来计算点数和。接下来把剩下的n-1个骰子仍然分成两堆:第一堆只有一个;第二堆有n-2个。我们把上一轮那个单独骰子的点数和这一轮单独骰子的点数相加，再和剩下的个骰子来计算点数和。分析到这里，我们不难发现这是一种递归的思路，递归结束的条件就是最后只剩下一个骰子。<br>
我们可以定义一个长度为6n-n+1的数组，将和为s的点数出现的次数保存到数组的第s-n个元素里。</p>
</blockquote>
<pre><code>int g_maxValue = 6;

void PrintProbability_Solution1(int number)
{
    if(number &lt; 1)
        return;
 
    int maxSum = number * g_maxValue;
    int* pProbabilities = new int[maxSum - number + 1];
    for(int i = number; i &lt;= maxSum; ++i)
        pProbabilities[i - number] = 0;
 
    Probability(number, pProbabilities);
 
    int total = pow((double)g_maxValue, number);
    for(int i = number; i &lt;= maxSum; ++i)
    {
        double ratio = (double)pProbabilities[i - number] / total;
        printf(&quot;%d: %e\n&quot;, i, ratio);
    }
 
    delete[] pProbabilities;
}
 
void Probability(int number, int* pProbabilities)
{
    for(int i = 1; i &lt;= g_maxValue; ++i)
        Probability(number, number, i, pProbabilities);
}
 
void Probability(int original, int current, int sum, 
                 int* pProbabilities)
{
    if(current == 1)
    {
        pProbabilities[sum - original]++;
    }
    else
    {
        for(int i = 1; i &lt;= g_maxValue; ++i)
        {
            Probability(original, current - 1, i + sum, pProbabilities);
        }
    }
} 
</code></pre>
<blockquote>
<p>上述思路很简洁，实现起来也容易。但由于是基于递归的实现，它有很多计算是重复的，从而导致当 number 变大时性能慢得让人不能接受。</p>
</blockquote>
<blockquote>
<p>解法二:基于循环求骰子点数，时间性能好<br>
可以换一种思路来解决这个问题。我们可以考虑用两个数组来存储骰子点数的每个总数出现的次数。在一轮循环中，第一个数组中的第 n 个数 字表示骰子和为n<br>
出现的次数。在下一轮循环中，我们加上一个新的骰子, 此时和为 n 的骰子出现的次数应该等于上一轮循环中骰子点数和为n-1、 n-2、n-3、n-4、n-5与 n-6的次 数的总和，所以我们把另一个数组的第 n 个数字设为前一个数组对应的第n-1、 n-2、n-3、n-4、n-5与 n-6 个数字之和。<br>
(需要两个数组的原因：比如第一次得到123456.第二次则是234567...12,注意23456会重复，而且这五个没有n-6，会超出数组范围)</p>
</blockquote>
<pre><code>void PrintProbability_Solution2(int number)
{
    if(number &lt; 1)
        return;

    int* pProbabilities[2];
    pProbabilities[0] = new int[g_maxValue * number + 1];
    pProbabilities[1] = new int[g_maxValue * number + 1];
    for(int i = 0; i &lt; g_maxValue * number + 1; ++i)
    {
        pProbabilities[0][i] = 0;
        pProbabilities[1][i] = 0;
    }
 
    int flag = 0;
    for (int i = 1; i &lt;= g_maxValue; ++i) 
        pProbabilities[flag][i] = 1; 
    
    for (int k = 2; k &lt;= number; ++k) 
    {
        for(int i = 0; i &lt; k; ++i)
            pProbabilities[1 - flag][i] = 0;

        for (int i = k; i &lt;= g_maxValue * k; ++i) 
        {
            pProbabilities[1 - flag][i] = 0;
            for(int j = 1; j &lt;= i &amp;&amp; j &lt;= g_maxValue; ++j) 
                pProbabilities[1 - flag][i] += pProbabilities[flag][i - j];
        }
 
        flag = 1 - flag;
    }
 
    double total = pow((double)g_maxValue, number);
    for(int i = number; i &lt;= g_maxValue * number; ++i)
    {
        double ratio = (double)pProbabilities[flag][i] / total;
        printf(&quot;%d: %e\n&quot;, i, ratio);
    }
 
    delete[] pProbabilities[0];
    delete[] pProbabilities[1];
}
</code></pre>
<blockquote>
<p>上述代码中，我们定义了两个数组 pProbabilities[0]和 pProbabilities[l] 来存储骰 子的点数之和。在一轮循环中，一个数组的第 n 项等于另一个数组的第n-1、 n-2、n-3、n-4、n-5与 n-6项的和。在下一轮循环中，我们交换这两个数组(通过改变变量 flag 实现)再 重复这一计算过程。<br>
值得注意的是，上述代码没有在函数里把一个骰子的最大点数硬编码 (HardCode) 为 6,而是用一个变量 g maxValue 来表示。</p>
</blockquote>
<p>书本题解确实很巧妙<br>
1.从k开始外循环，不用考虑k之前的数，内循环则循环递增n-1至n-6的新骰子数<br>
2.利用两个数组轮流存储，并且利用bool隐式转换数组下标，精简了代码</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 题 59:队列的最大值[未做出]]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-ti-59dui-lie-de-zui-da-zhi-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-ti-59dui-lie-de-zui-da-zhi-wei-zuo-chu">
        </link>
        <updated>2020-03-09T23:39:06.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题目一">题目一</h3>
<blockquote>
<p>滑动窗口的最大值。给定一个数组和滑动窗口的大小，请找出所有滑动窗口里的最大值。例如，如果输入数组{2, 3, 4, 2, 6, 2, 5, 1}及滑动窗口的大小 3,那么一共存 在 6个滑动窗口，它们的最大值分别为{4,4,6,6,6,5}</p>
</blockquote>
<p>【未做出】<br>
我一开始想到的方法比较直接，就是用大顶堆来始终保证获得当前的最大值，并使用pair保存下标值，去除已经过期的元素<br>
实现的时候遇到一个问题，我在for循环头中不小心把loc重新定义了一次，导致覆盖了外部的loc<br>
时间复杂度比较高，建堆时间复杂度为 O(size) 插入和删除都是 O(logn)<br>
然后还是书本的队列法比较简单，就是在队列保存当前的下标值，然后保存所有小于当前最大值的数，直至遇到一个比当前值更大的数，就不断从头部推出。<br>
实现过程中发现必须是双端队列，比如{6,2,5,1}如果只是队列，那么5无法替代2，就会出错<br>
所以要使用deque,同时记得pop之前一定要检查size()</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size)
    {
        vector&lt;int&gt; res;
        int len(num.size());
        if(size == 0 || len &lt; size)
            return res;
        deque&lt;int&gt; maxnum;
        int loc;
        for(loc = 0;loc &lt; size;++loc)
        {
            if(maxnum.empty())
                maxnum.push_back(loc);
            while(maxnum.size() &amp;&amp; num[loc] &gt;= num[maxnum.front()])
                maxnum.pop_front();
            while(maxnum.size() &amp;&amp; num[loc] &gt;= num[maxnum.back()])
                maxnum.pop_back();
            maxnum.push_back(loc);
        }
        res.push_back(num[maxnum.front()]);
        for(;loc &lt; len;++loc)
        {
            if(loc - maxnum.front() &gt;= size)
                maxnum.pop_front();
            while(maxnum.size() &amp;&amp; num[loc] &gt;= num[maxnum.front()])
                maxnum.pop_front();
            while(maxnum.size() &amp;&amp; num[loc] &gt;= num[maxnum.back()])
                maxnum.pop_back();
            maxnum.push_back(loc);
            res.push_back(num[maxnum.front()]);
        }
        return res;
    }
		
    /*
    vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size)
    {
        int len(num.size());
        vector&lt;int&gt; res;
        if(size == 0 || len &lt; size)
            return res;
        priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;,compare&gt; maxnum;
        int loc;
        for(loc = 0; loc &lt; size; ++loc)
        {
            maxnum.push(make_pair(num[loc],loc));
        }
        res.push_back(maxnum.top().first);
        for( ; loc &lt; len ; ++loc)
        {
            maxnum.push(make_pair(num[loc],loc));
            while(loc - maxnum.top().second &gt;= size)
            {
                maxnum.pop();
            }
            res.push_back(maxnum.top().first);
        }
        return res;
    }
    
    struct compare{
        bool operator()(pair&lt;int,int&gt; numPair1,pair&lt;int,int&gt; numPair2)
        {
            return numPair1.first &lt;= numPair2.first;
        }
    };
    */
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>如果采用蛮力法，那么这个问题似乎不难解决:可以扫描每个滑动窗口的所有数字并找出其中的最大值。如果滑动窗口的大小为k，则需要 O(n)时间才能找出滑动窗口 里的最大值。对于长度为 n 的输入数组，这种算法的总时间复杂度是 O(nk)。<br>
实际上，一个滑动窗口可以看成一个队列。当窗口滑动时，处于窗口的第一个数字被删除，同时在窗口的末尾添加一个新的数字。这符合队列 的''先进先出”特性。如果能从队列中找出它的最大数，那么这个问题也 就解决了。<br>
如果 把队列用两个栈实现，由于可以用 O(1)时间得到栈中的最大值，那么也就可 以用O(1)时间 得到队列的最大值，因此总的时间复杂度也就降到了O(n)。<br>
下面换一种思路。我们并不把滑动窗口的每个数值都存入队列，而是 只把 有可能成为滑动窗口最大值的数值存入一个两端开口的队列deque.怎么知道滑动窗口是否包括一个数字? 应该在队列里存入数字在数组里的下标，而不是数值。当一个数字的下标 与当前处理的数字的下标之差大于或者等于滑动窗口的大小时，这个数字 已经从窗口中滑出，可以从队列中删除了。<br>
重点在于保证队列头部的数字一定是当前的最大值，保存有可能是滑动窗口最大值的数字的下标。在存入一个数字的下标之前，首先要判断队列里已有数字是 否小于待存入的数字。如果已有的数字小于待存入的数字，那么这些数字已经不可能是滑动窗口的最大值，因此它们将会被依次从队列的尾部 删除(调用函数 pop_back)。同时，如果队列头部的数字已经从窗口里滑出， 那么滑出的数字也需要从队列的头部删除(调用函数pop_front)。由于队列的头部和尾部都有可能删除数字，这也是需要两端开口的队列的原因。</p>
</blockquote>
<pre><code>vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size)
{
    vector&lt;int&gt; maxInWindows;
    if(num.size() &gt;= size &amp;&amp; size &gt;= 1)
    {
        deque&lt;int&gt; index;

        for(unsigned int i = 0; i &lt; size; ++i)
        {
            while(!index.empty() &amp;&amp; num[i] &gt;= num[index.back()])
                index.pop_back();

            index.push_back(i);
        }

        for(unsigned int i = size; i &lt; num.size(); ++i)
        {
            maxInWindows.push_back(num[index.front()]);

            while(!index.empty() &amp;&amp; num[i] &gt;= num[index.back()])
                index.pop_back();
            if(!index.empty() &amp;&amp; index.front() &lt;= (int) (i - size))
                index.pop_front();

            index.push_back(i);
        }
        maxInWindows.push_back(num[index.front()]);
    }

    return maxInWindows;
}
</code></pre>
<h3 id="题目二">题目二</h3>
<p>题目描述：</p>
<blockquote>
<p>队列的最大值。<br>
请定义一个队列并实现函数 max 得到队列里的最大值，要求函数 max、 push back 和 pop front 的时间复杂度都是 O(1)</p>
</blockquote>
<p>书本题解：</p>
<blockquote>
<p>滑动窗口可以看成一个队列，由于该解法和上题找滑动窗口的最大值类似，</p>
</blockquote>
<pre><code>template&lt;typename T&gt; class QueueWithMax
{
public:
    QueueWithMax() : currentIndex(0)
    {
    }

    void push_back(T number)
    {
        while(!maximums.empty() &amp;&amp; number &gt;= maximums.back().number)
            maximums.pop_back();

        InternalData internalData = { number, currentIndex };
        data.push_back(internalData);
        maximums.push_back(internalData);

        ++currentIndex;
    }

    void pop_front()
    {
        if(maximums.empty())
            throw new exception(&quot;queue is empty&quot;);

        if(maximums.front().index == data.front().index)
            maximums.pop_front();

        data.pop_front();
    }

    T max() const
    {
        if(maximums.empty())
            throw new exception(&quot;queue is empty&quot;);

        return maximums.front().number;
    }

private:
    struct InternalData
    {
        T number;
        int index;
    };

    deque&lt;InternalData&gt; data;
    deque&lt;InternalData&gt; maximums;
    int currentIndex;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 题58:翻转字符串]]></title>
        <id>https://lixin-scut.github.io//post/zi-fu-chuan-ti-58fan-zhuan-zi-fu-chuan</id>
        <link href="https://lixin-scut.github.io//post/zi-fu-chuan-ti-58fan-zhuan-zi-fu-chuan">
        </link>
        <updated>2020-03-09T23:22:42.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题目一">题目一</h3>
<p>题目描述：</p>
<blockquote>
<p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。 为简单起见，标点符号和普通字母一样处理。例如输入字符串&quot;I am a student. &quot;，则输出&quot;student. a am I&quot;。</p>
</blockquote>
<p>  第一想法就是定义一个reverse函数，先把整个字符串翻转，再以空格为标志，把单词逐个翻转<br>
  当然我的题解还是比较简单的版本，没有考虑字符串前面都是0的情况</p>
<pre><code>class Solution {
public:
    string ReverseSentence(string str) {
        if(str.empty())
            return str;
        Reverse(str,0,str.size()-1);
        int locSpace;
        locSpace = -1;
        for(int i=0;i &lt;= str.size();++i)
        {
            if(str[i] == ' ' || i == str.size())
            {
                Reverse(str,locSpace+1,i-1);
                locSpace = i;
            }
        }
        return str;
    }
    
    void  Reverse(string &amp;str,int beg,int end)
    {
        while(beg &lt; end)
        {
            char temp = str[beg];
            str[beg] = str[end];
            str[end] = temp;
            ++beg;
            --end;
        }
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>解题思路:第一步翻转句子中所有的字符。比如翻转 &quot;I am a student.&quot;中所 有的字符得到&quot;.tneduts a ma I&quot;,此时不但翻转了句子中单词的顺序，连单词内的字符顺序也被翻转了。第二步再翻转每个单词中字符的顺序，就得到了 &quot;student, a ami&quot;。这正是符合题目要求的输出。<br>
这种思路的关键在于实现一个函数以翻转字符串中的一段。在英语句子中，单词被空格符号分隔，因此我们可以通过扫描空格来 确定每 个单词的起始和终止位置。</p>
</blockquote>
<pre><code>char* ReverseSentence(char *pData)
{
    if(pData == nullptr)
        return nullptr;

    char *pBegin = pData;

    char *pEnd = pData;
    while(*pEnd != '\0')
        pEnd ++;
    pEnd--;

    // 翻转整个句子
    Reverse(pBegin, pEnd);

    // 翻转句子中的每个单词
    pBegin = pEnd = pData;
    while(*pBegin != '\0')
    {
        if(*pBegin == ' ')
        {
            pBegin ++;
            pEnd ++;
        }
        else if(*pEnd == ' ' || *pEnd == '\0')
        {
            Reverse(pBegin, --pEnd);
            pBegin = ++pEnd;
        }
        else
            pEnd ++;
    }

    return pData;
}
</code></pre>
<h3 id="题目二">题目二</h3>
<p>题目描述：</p>
<blockquote>
<p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如输入字符串&quot;abcdefg&quot;和数字2，该函数将返回左旋转2位得到的结果&quot;cdefgab&quot;。</p>
</blockquote>
<p>这个参考上一题的旋转<br>
先整体旋转，然后根据循环左移的位置再分别做两次旋转<br>
需要注意的就是左移的位数和字符串的长度的关系，如果恰好成倍数的话就不需要翻转<br>
不知道为什么，缺少return一直在报访问溢出。。。</p>
<pre><code>class Solution {
public:
    string LeftRotateString(string str, int n) {
        int len = str.size();
        if(str.empty() || len == 1 || n%len == 0)
            return str;
        n %= len;
        Reverse(str,0,len-1);
        Reverse(str,0,len-n-1);
        Reverse(str,len-n,len-1);
        return str;
    }
    
    void Reverse(string &amp;str,int beg,int end)
    {
        while(beg &lt; end)
        {
            swap(str[beg++],str[end--]);
        }
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>我们可以把字符串分为两部分。由于想把它的前两个字符移到后面， 我们就把前两个字符分到第一部分，把后面的所有字符分到第二部分。我们先分别翻转这两部分，接下来翻转 整个字符串，得到的刚好就是把原始字符串左旋转两位的结果。<br>
通过前面的分析，我们发现只需要调用 3 次前面的 Reverse 函数就可以实现字符 串的左旋转功能。<br>
字符串相关的代码时经常会发现两种问题:一是输入 空指针 nullptr 时程 序会崩溃;二是内存访问越界的问题，也就是试图访问不属于字符串的内存。</p>
</blockquote>
<pre><code>char* LeftRotateString(char* pStr, int n)
{
    if(pStr != nullptr)
    {
        int nLength = static_cast&lt;int&gt;(strlen(pStr));
        if(nLength &gt; 0 &amp;&amp; n &gt; 0 &amp;&amp; n &lt; nLength)
        {
            char* pFirstStart = pStr;
            char* pFirstEnd = pStr + n - 1;
            char* pSecondStart = pStr + n;
            char* pSecondEnd = pStr + nLength - 1;

            // 翻转字符串的前面n个字符
            Reverse(pFirstStart, pFirstEnd);
            // 翻转字符串的后面部分
            Reverse(pSecondStart, pSecondEnd);
            // 翻转整个字符串
            Reverse(pFirstStart, pSecondEnd);
        }
    }

    return pStr;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[原子性atomic与线程安全]]></title>
        <id>https://lixin-scut.github.io//post/yuan-zi-xing-atomic</id>
        <link href="https://lixin-scut.github.io//post/yuan-zi-xing-atomic">
        </link>
        <updated>2020-03-09T04:08:04.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</li>
<li>线程安全问题都是由全局变量及静态变量引起的。</li>
<li>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</li>
<li>对于线程不安全的对象我们可以通过如下方法来实现线程安全：<br>
①	加锁 利用Synchronized或者ReenTrantLock来对不安全对象进行加锁，来实现线程执行的串行化，从而保证多线程同时操作对象的安全性，一个是语法层面的互斥锁，一个是API层面的互斥锁.<br>
②	非阻塞同步来实现线程安全。原理就是：通俗点讲，就是先进性操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生冲突，那就再采取其他措施(最常见的措施就是不断地重试，知道成功为止)。这种方法需要硬件的支持，因为我们需要操作和冲突检测这两个步骤具备原子性。通常这种指令包括CAS SC,FAI TAS等。<br>
③	线程本地化，一种无同步的方案，就是利用Threadlocal来为每一个线程创造一个共享变量的副本来（副本之间是无关的）避免几个线程同时操作一个对象时发生线程安全问题。</li>
</ol>
<p><a href="https://blog.csdn.net/lg1259156776/article/details/52732879">对于可重入、线程安全、异步信号安全几个概念的理解</a></p>
<p><a href="https://github.com/luohaha/MyBlog/issues/3">原子操作是如何实现的</a><br>
原子操作对于我们来说，是非常熟悉的概念。在某些场景下，可以用原子操作来替换重量级的锁同步，从而提高程序性能。原子操作可以保障多个线程或进程在更新某块共享内存区时，可以避免同步原语。</p>
<p>对于原子操作的实现来说，需要分开考虑单处理器单核系统，和多处理器系统，多核系统。</p>
<p>对于单处理器单核系统来说，只要保证操作指令序列不被打断即可实现原子操作。对于简单的原子操作，cpu实现上会提供单条指令，比如INC和XCHG。对于复杂的原子操作，需要包含多条指令。执行过程中，出现上下文切换行为，比如任务切换，中断处理等。这里的行为会影响原子操作的原子性。因此需要自旋锁spinlock[1]来保证操作指令序列不会在执行的中途受干扰。</p>
<p>但是如果对于多处理器或者多核的系统，原子操作的实现除了需要spinlock来保证外，还需要保证不会受到同处理器上其他核，或者其他处理器的影响。当其他核上执行的指令访问的内存空间，与当前原子操作需要访问的内存空间存在冲突时，就会破坏原子操作的正确性。</p>
<p>在x86架构中，提供了指令前缀LOCK。LOCK保证了指令不会受其他处理器或cpu核的影响。在PentiumPro之前，LOCK的实现，是通过锁住bus（总线），从而阻止其他cpu核的内存访问。可想而知，这种实现是非常低效的。从PentiumPro开始，LOCK只会阻塞其他cpu核对相关内存的缓存块的访问。</p>
<p>现在，大多数的x86处理器都支持了CAS的硬件实现，保证了多处理器多核系统下的原子操作的正确性。CAS的实现同样无需锁住总线，只会阻塞其他cpu核对相关内存的缓存块的访问。同样的，在MIPS和ARM架构下，还支持了LL/SC的实现。LL/SC不会出现CAS中的ABA问题。</p>
<p>在继续深入以前，需要了解MESI缓存协议。当然，还存在其他的MESI变种，不过这里只会简单解释下MESI。每个cache line存在四种状态，Modified代表该cache line为该cpu核独有，且尚未写回（write back）到内存（对缓存一致性不了解的看这里）。Exclusive代表该cache line为该cpu核独有，且与内存一致。Shared代表该cache line为多核共享，且与内存一致。Invalid代表缓存失效。系统中多个核之间通过快速通道直接通信，比如intel家的QPI，amd家的Hypertransport。cpu核之间通信的消息包括读消息，以及读消息的响应消息。使无效消息，以及使无效消息的响应消息。当运行在某个cpu核的线程准备读取某个cache line的内容时，如果状态处于M,E,S，直接读取即可。如果状态处于I，则需要向其他cpu核广播读消息，在接受到其他cpu核的读响应后，更新cache line，并将状态设置为S。而当线程准备写入某个cache line时，如果处于M状态，直接写入。如果处于E状态，写入并将cache line状态改为M。如果处于S，则需要向其他cpu核广播使无效消息，并进入E状态，写入修改，后进入M状态。如果处于I，则需要向其他cpu核广播读消息核使无效消息，在收集到读响应后，更新cache line。在收集到使无效响应后，进入E状态，写入修改，后进入M状态。</p>
<p>从上面的说明可知，LOCK的实现，只需要保持cache line的M状态即可，此时就可以阻止其他cpu核对该块内存的修改，而不用去锁住整个总线。</p>
<p><a href="https://www.jianshu.com/p/c6e8ae5c0e8e">C++11编程底层知识：无锁数据结构：原子性、原子性原语</a></p>
<p><a href="https://blog.csdn.net/xuxile/article/details/73739536">JAVA基础篇-原子操作的实现原理</a><br>
<a href="https://www.infoq.cn/article/atomic-operation/">聊聊并发（五）——原子操作的实现原理</a></p>
<h3 id="自增i是否是原子操作">自增++i是否是原子操作</h3>
<p>i++的操作分三步：<br>
（1）栈中取出i<br>
（2）i自增1<br>
（3）将i存到栈<br>
所以i++不是原子操作，上面的三个步骤中任何一个步骤同时操作，都可能导致i的值不正确自增</p>
<h3 id="volatile关键字">Volatile关键字</h3>
<p><a href="https://www.cnblogs.com/god-of-death/p/7852394.html">C/C++ Volatile关键词深度剖析</a><br>
<a href="https://www.cnblogs.com/whutao/p/10516107.html">volatile关键字的学习</a></p>
<h3 id="stl容器的线程安全性">STL容器的线程安全性</h3>
<p><a href="https://blog.csdn.net/u012730075/article/details/14168351">STL容器的线程安全</a><br>
<a href="https://www.cnblogs.com/ztteng/archive/2013/11/07/3411738.html">STL容器是否是线程安全的</a></p>
<h3 id="内存池">内存池</h3>
<p>内存池对象不是线程安全的，在多线程编程中，创建一个对象时必须加锁。</p>
]]></content>
    </entry>
</feed>