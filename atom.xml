<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-03-22T03:25:05.103Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>千里之行，始于足下。不积跬步，无以至千里。</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[自定义比较]]></title>
        <id>https://lixin-scut.github.io//post/zi-ding-yi-bi-jiao</id>
        <link href="https://lixin-scut.github.io//post/zi-ding-yi-bi-jiao">
        </link>
        <updated>2020-03-22T02:12:15.000Z</updated>
        <content type="html"><![CDATA[<p>今天在做题的时候发现一个问题，就是自定义比较函数的问题<br>
可以分为两类</p>
<ol>
<li>函数中的自定义比较和容器中的自定义比较</li>
<li>类外的自定义比较和类内的自定义比较</li>
</ol>
<h3 id="函数中的自定义比较和容器中的自定义比较">函数中的自定义比较和容器中的自定义比较</h3>
<p>  像sort函数的自定义比较比较简单，直接穿入函数指针就行了，一般是直接用函数名<br>
  比较特别的是容器的自定义比较，它们并不是接受函数指针，而是接受一个函数对象<br>
  比如对于priority_queue，如果想定义小顶堆，需要以下函数对象而不是函数<br>
<strong>亦即定义了一个重载了调用运算符的类，</strong><br>
  如果类定义了调用运算符，则该类的对象称作函数对象（function object）。因为可以调用这种对象，所以我们说这些对象的&quot;行为像函数一样&quot;。</p>
<pre><code>struct compare
    {
        bool operator()(ListNode* node1,ListNode* node2)
        {
            return node1-&gt;val&gt;=node2-&gt;val;
        }
    };
</code></pre>
<p>  而且注意大于小于的返回判断，如果使用 &lt;= ，返回的反而是大顶堆。。。</p>
<p>  详细可参考以前的博文：<a href="https://lixin-scut.github.io/post/guan-yu-priority-de-zi-ding-yi-bi-jiao/">关于priority_queue堆的自定义比较</a></p>
<h3 id="类外的自定义比较和类内的自定义比较">类外的自定义比较和类内的自定义比较</h3>
<p>  问题出现于网上做题的时候，在成员函数使用sort的时候希望获得逆序数组，就需要定义一个比较函数<br>
此时如果直接用</p>
<pre><code>bool comp(int i1, int i2)  const
    {   return i1 &gt; i2; }
</code></pre>
<p>是会白给的，因为这个函数属于成员函数，必须定义了类对象才有实体，而sort要求必须编译的时候就能获得确定的函数了。</p>
<p>此时有两种方法<br>
第一种是加上static关键字让它变成静态成员函数，摆脱对类对象的依赖<br>
  注意同时必须去除const ，因为const只能对成员函数使用</p>
<pre><code>static bool comp(int i1, int i2) 
    {   return i1 &gt; i2; }
</code></pre>
<p>第二种是重载调用运算符<br>
  注意必须是重载调用运算符为类成员函数<br>
  如果类定义了调用运算符，则该类的对象称作函数对象（function object）。因为可以调用这种对象，所以我们说这些对象的&quot;行为像函数一样&quot;。<br>
  所以不受类对象的限制。<br>
  然后这里可以放心加上const了</p>
<pre><code> bool operator()(int i1, int i2) const
    {   return i1 &gt; i2; }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 322. 零钱兑换[中等]]]></title>
        <id>https://lixin-scut.github.io//post/dong-tai-gui-hua-322-ling-qian-dui-huan-zhong-deng</id>
        <link href="https://lixin-scut.github.io//post/dong-tai-gui-hua-322-ling-qian-dui-huan-zhong-deng">
        </link>
        <updated>2020-03-22T00:37:45.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。<br>
示例 1:<br>
输入: coins = [1, 2, 5], amount = 11<br>
输出: 3<br>
解释: 11 = 5 + 5 + 1<br>
示例 2:<br>
输入: coins = [2], amount = 3<br>
输出: -1<br>
说明:<br>
你可以认为每种硬币的数量是无限的。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/coin-change<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>  我想到的一个做法就是类似于阶梯法，把可能达到的情况都考虑一遍，并只取最小值，比如[1, 2, 5]达到5 可以从 0，3，4出发，从0出发最少只要1步，从4出发至少都需要3步。<br>
  这个做法的缺点是是需要大容量的数组<br>
  需要注意的是起始条件，利用-1代表不可达，不能用0，否则无法区分amounts[0]的情况，同时符合题目不可达返回-1的要求</p>
<p>  第二种方法就是不断使用最大面额的币种直到不能使用，再考虑下一币种<br>
  这种方法存在缺陷，比如[3, 10]来凑15，很明显无法使用10 ，但是45又可以先用3个10，似乎必须逐步回退10的个数<br>
  最终网友题解中也是利用这种思想，就是贪心算法+深度优先遍历BFS</p>
<pre><code>class Solution {
public:
    int coinChange(vector&lt;int&gt;&amp; coins, int amount) 
    {
        if(coins.empty())
        {   return -1; }
        sort(coins.begin(), coins.end(), Solution());
        int ans = INT_MAX;
        coinChange(coins, amount, 0, 0, ans);
        return ans == INT_MAX ? -1 : ans;
    }
    
    void coinChange(vector&lt;int&gt;&amp; coins, int amount, int coinIndex, int count, int&amp; ans) 
    {
        if(0 == amount)
        {   
            ans = min(count, ans);
            return; 
        }
        if(coinIndex == coins.size())
        {   return; }
        for(int num = amount/coins[coinIndex];  num &gt;= 0 &amp;&amp; num + count &lt; ans; --num)
        {
            coinChange(coins, amount - coins[coinIndex]*num, coinIndex + 1, count + num, ans);
        }
        
    }
    
    bool operator()(int i1, int i2) const
    {   return i1 &gt; i2; }
        
    /*
    int coinChange(vector&lt;int&gt;&amp; coins, int amount) 
    {
        if(coins.empty() || amount &lt; 0)
        {   return -1; }
        
        vector&lt;int&gt; amounts(amount+1 , -1);
        amounts[0] = 0;
        
        for(int i=0; i &lt;= amount; ++i)
        {
            for(auto coin : coins)
            {
                if(i &gt;= coin &amp;&amp; amounts[i - coin] != -1)
                {
                    amounts[i] = (amounts[i] != -1 &amp;&amp; amounts[i] &lt; amounts[i - coin] + 1) ? 
                                    amounts[i] : amounts[i - coin] + 1;
                }
            }
        }
        return amounts[amount];
    }
    */
};
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>  动态规划问题的一般形式就是求最值。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求最长递增子序列呀，最小编辑距离呀等等。<br>
  既然是要求最值，核心问题是什么呢？求解动态规划的核心问题是穷举。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。<br>
  动态规划就这么简单，就是穷举就完事了？我看到的动态规划问题都很难啊！<br>
  首先，动态规划的穷举有点特别，因为这类问题存在「重叠子问题」，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。<br>
  而且，动态规划问题一定会具备「最优子结构」，才能通过子问题的最值得到原问题的最值。<br>
  另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出正确的「状态转移方程」才能正确地穷举。<br>
  以上提到的重叠子问题、最优子结构、状态转移方程就是动态规划三要素。具体什么意思等会会举例详解，但是在实际的算法问题中，写出状态转移方程是最困难的，这也就是为什么很多朋友觉得动态规划问题困难的原因，我来提供我研究出来的一个思维框架，辅助你思考状态转移方程：<br>
  明确「状态」 -&gt; 定义 dp 数组/函数的含义 -&gt; 明确「选择」-&gt; 明确 base case。<br>
下面通过斐波那契数列问题和凑零钱问题来详解动态规划的基本原理。前者主要是让你明白什么是重叠子问题（斐波那契数列严格来说不是动态规划问题），后者主要举集中于如何列出状态转移方程。</p>
</blockquote>
<blockquote>
<p>凑零钱问题<br>
先看下题目：给你 k 种面值的硬币，面值分别为 c1, c2 ... ck，每种硬币的数量无限，再给一个总金额 amount，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。算法的函数签名如下：<br>
// coins 中是可选硬币面值，amount 是目标金额<br>
int coinChange(int[] coins, int amount);<br>
比如说 k = 3，面值分别为 1，2，5，总金额 amount = 11。那么最少需要 3 枚硬币凑出，即 11 = 5 + 5 + 1。<br>
  你认为计算机应该如何解决这个问题？显然，就是把所有肯能的凑硬币方法都穷举出来，然后找找看最少需要多少枚硬币。</p>
</blockquote>
<blockquote>
<p>1、暴力递归<br>
  首先，这个问题是动态规划问题，因为它具有「最优子结构」的。要符合「最优子结构」，子问题间必须互相独立。啥叫相互独立？你肯定不想看数学证明，我用一个直观的例子来讲解。<br>
  比如说，你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。<br>
  得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。<br>
  但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，此消彼长。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。<br>
  回到凑零钱问题，为什么说它符合最优子结构呢？比如你想求 amount = 11 时的最少硬币数（原问题），如果你知道凑出 amount = 10 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案，因为硬币的数量是没有限制的，子问题之间没有相互制，是互相独立的。<br>
  那么，既然知道了这是个动态规划问题，就要思考如何列出正确的状态转移方程？<br>
  先确定「状态」，也就是原问题和子问题中变化的变量。由于硬币数量无限，所以唯一的状态就是目标金额 amount。<br>
  然后确定 dp 函数的定义：当前的目标金额是 n，至少需要 dp(n) 个硬币凑出该金额。<br>
  然后确定「选择」并择优，也就是对于每个状态，可以做出什么选择改变当前状态。具体到这个问题，无论当的目标金额是多少，选择就是从面额列表 coins 中选择一个硬币，然后目标金额就会减少：</p>
</blockquote>
<pre><code># 伪码框架
def coinChange(coins: List[int], amount: int):
    # 定义：要凑出金额 n，至少要 dp(n) 个硬币
    def dp(n):
        # 做选择，选择需要硬币最少的那个结果
        for coin in coins:
            res = min(res, 1 + dp(n - coin))
        return res
    # 我们要求的问题是 dp(amount)
    return dp(amount)
</code></pre>
<blockquote>
<p>  最后明确 base case，显然目标金额为 0 时，所需硬币数量为 0；当目标金额小于 0 时，无解，返回 -1：</p>
</blockquote>
<pre><code>def coinChange(coins: List[int], amount: int):

    def dp(n):
        # base case
        if n == 0: return 0
        if n &lt; 0: return -1
        # 求最小值，所以初始化为正无穷
        res = float('INF')
        for coin in coins:
            subproblem = dp(n - coin)
            # 子问题无解，跳过
            if subproblem == -1: continue
            res = min(res, 1 + subproblem)

        return res if res != float('INF') else -1
    
    return dp(amount)
</code></pre>
<blockquote>
<p>  至此，状态转移方程其实已经完成了，以上算法已经是暴力解法了，以上代码的数学形式就是状态转移方程：<br>
dp(n)=<br>
{<br>
0,                                               n=0<br>
−1,                                              n&lt;0<br>
min{dp(n−coin)+1∣coin∈coins}, n&gt;0<br>
}<br>
  时间复杂度分析：子问题总数 x 每个子问题的时间。<br>
  子问题总数为递归树节点个数，这个比较难看出来，是 O(n^k)，总之是指数级别的。每个子问题中含有一个 for 循环，复杂度为 O(k)。所以总时间复杂度为 O(k * n^k)，指数级别。</p>
</blockquote>
<blockquote>
<p>2、带备忘录的递归<br>
只需要稍加修改，就可以通过备忘录消除子问题：</p>
</blockquote>
<pre><code>def coinChange(coins: List[int], amount: int):
    # 备忘录
    memo = dict()
    def dp(n):
        # 查备忘录，避免重复计算
        if n in memo: return memo[n]

        if n == 0: return 0
        if n &lt; 0: return -1
        res = float('INF')
        for coin in coins:
            subproblem = dp(n - coin)
            if subproblem == -1: continue
            res = min(res, 1 + subproblem)
        
        # 记入备忘录
        memo[n] = res if res != float('INF') else -1
        return memo[n]
    
    return dp(amount)
</code></pre>
<blockquote>
<p>  很显然「备忘录」大大减小了子问题数目，完全消除了子问题的冗余，所以子问题总数不会超过金额数 n，即子问题数目为 O(n)。处理一个子问题的时间不变，仍是 O(k)，所以总的时间复杂度是 O(kn)。</p>
</blockquote>
<blockquote>
<p>3、dp 数组的迭代解法<br>
  当然，我们也可以自底向上使用 dp table 来消除重叠子问题，dp 数组的定义和刚才 dp 函数类似，定义也是一样的：<br>
  dp[i] = x 表示，当目标金额为 i 时，至少需要 x 枚硬币。</p>
</blockquote>
<pre><code>int coinChange(vector&lt;int&gt;&amp; coins, int amount) {
    // 数组大小为 amount + 1，初始值也为 amount + 1
    vector&lt;int&gt; dp(amount + 1, amount + 1);
    // base case
    dp[0] = 0;
    for (int i = 0; i &lt; dp.size(); i++) {
        // 内层 for 在求所有子问题 + 1 的最小值
        for (int coin : coins) {
            // 子问题无解，跳过
            if (i - coin &lt; 0) continue;
            dp[i] = min(dp[i], 1 + dp[i - coin]);
        }
    }
    return (dp[amount] == amount + 1) ? -1 : dp[amount];
}
</code></pre>
<blockquote>
<p>  PS：为啥 dp 数组初始化为 amount + 1 呢，因为凑成 amount 金额的硬币数最多只可能等于 amount（全用 1 元面值的硬币），所以初始化为 amount + 1 就相当于初始化为正无穷，便于后续取最小值。</p>
</blockquote>
<p>第二种解法是贪心算法+深度优先遍历BFS</p>
<blockquote>
<p>解题思路<br>
贪心<br>
  想要总硬币数最少，肯定是优先用大面值硬币，所以对 coins 按从大到小排序<br>
  先丢大硬币，再丢会超过总额时，就可以递归下一层丢的是稍小面值的硬币<br>
乘法对加法的加速<br>
  优先丢大硬币进去尝试，也没必要一个一个丢，可以用乘法算一下最多能丢几个</p>
</blockquote>
<pre><code>k = amount / coins[c_index] 计算最大能投几个
amount - k * coins[c_index] 减去扔了 k 个硬币
count + k 加 k 个硬币
</code></pre>
<blockquote>
<p>  如果因为丢多了导致最后无法凑出总额，再回溯减少大硬币数量<br>
最先找到的并不是最优解<br>
  注意不是现实中发行的硬币，面值组合规划合理，会有奇葩情况<br>
  考虑到有 [1,7,10] 这种用例，按照贪心思路 10 + 1 + 1 + 1 + 1 会比 7 + 7 更早找到<br>
   所以还是需要把所有情况都递归完<br>
ans 疯狂剪枝<br>
  贪心虽然得不到最优解，但也不是没用的<br>
  我们快速算出一个贪心的 ans 之后，虽然还会有奇葩情况，但是绝大部分普通情况就可以疯狂剪枝了</p>
</blockquote>
<pre><code>void coinChange(vector&lt;int&gt;&amp; coins, int amount, int c_index, int count, int&amp; ans)
{
    if (amount == 0)
    {
        ans = min(ans, count);
        return;
    }
    if (c_index == coins.size()) return;

    for (int k = amount / coins[c_index]; k &gt;= 0 &amp;&amp; k + count &lt; ans; k--)
    {
        coinChange(coins, amount - k * coins[c_index], c_index + 1, count + k, ans);
    }
}

int coinChange(vector&lt;int&gt;&amp; coins, int amount)
{
    if (amount == 0) return 0;
    sort(coins.rbegin(), coins.rend());
    int ans = INT_MAX;
    coinChange(coins, amount, 0, 0, ans);
    return ans == INT_MAX ? -1 : ans;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux开机过程、Linux程序启动过程]]></title>
        <id>https://lixin-scut.github.io//post/linux-kai-ji-guo-cheng-linux-cheng-xu-qi-dong-guo-cheng</id>
        <link href="https://lixin-scut.github.io//post/linux-kai-ji-guo-cheng-linux-cheng-xu-qi-dong-guo-cheng">
        </link>
        <updated>2020-03-21T12:32:15.000Z</updated>
        <content type="html"><![CDATA[<h3 id="linux开机流程">Linux开机流程</h3>
<ol>
<li>加载BIOS的硬件信息与进行自我测试，并依据设置取得第一个可启动设备；</li>
<li>读取并执行第一个启动设备内MBR（主引导分区）的Boot Loader（即是gurb等程序）；</li>
<li>依据Boot Loader的设置加载Kernel，Kernel会开始检测硬件与加载驱动程序；</li>
<li>在硬件驱动成功后，Kernel会主动调用init进程（/sbin/init），而init会取得runlevel信息；
<ul>
<li>init执行/etc/rc.d/rc.sysinit文件来准备软件的操作环境（如网络、时区等）；</li>
<li>init执行runlevel的各个服务的启动（script方式）；</li>
<li>init执行/etc/rc.d/rc.local文件；</li>
<li>init执行终端机模拟程序mingetty来启动login程序，最后等待用户登录。</li>
</ul>
</li>
</ol>
<p>  从 CentOS 7.x 以后，Red Hat 系列的 distribution 放弃沿用多年的 System V 开机启动服务的流程，  改用 systemd 这个启动服务管理机制</p>
<ol>
<li>加载 BIOS 的硬件信息与进行自我测试，并依据设定取得第一个可开机的装置;</li>
<li>读取并执行第一个开机装置内 MBR 的 boot Loader (亦即是 grub2, spfdisk 等程序);</li>
<li>依据 boot loader 的设定加载 Kernel ，Kernel 会开始侦测硬件与加载驱动程序;</li>
<li>在硬件驱动成功后，Kernel 会主动呼叫 systemd 程序，并以 default.target 流程开机;
<ul>
<li>systemd 执行 sysinit.target 初始化系统及 basic.target 准备操作系统;</li>
<li>systemd 启动 multi-user.target 下的本机与服务器服务;</li>
<li>systemd 执行 multi-user.target 下的 /etc/rc.d/rc.local 文件;</li>
<li>systemd 执行 multi-user.target 下的 getty.target 及登入服务;</li>
<li>systemd 执行 graphical 需要的服务</li>
</ul>
</li>
</ol>
<h3 id="linux程序启动过程">linux程序启动过程</h3>
<ol>
<li>当你在 shell 中敲入一个命令要执行时，内核会帮我们创建一个新的进程</li>
<li>它在往这个新进程的进程空间里面加载进可执行程序的代码段和数据段后，也会加载进动态连接器(在Linux里面通常就是 /lib/ld-linux.so 符号链接所指向的那个程序，它本省就是一个动态库)的代码段和数据。</li>
<li>在这之后，内核将控制传递给动态链接库里面的代码。动态连接器接下来负责加载该命令应用程序所需要使用的各种动态库。</li>
<li>加载完毕，动态连接器才将控制传递给应用程序的main函数。如此，你的应用程序才得以运行。(过程链接表（PLT）,   Global Offset Table（GOT）)</li>
</ol>
<p>  一个进程在内存中主要占用了以下几个部分，分别是代码段、数据段、BSS，栈，堆，等参数。其中，代码、数据、BSS的内容是可执行文件中对应的内容，加载程序并不是把它们的内容从可执行程序中填充到内存中，而是将它们的信息（基地址、长度等）更新到进程控制块（task_struct）中，当CPU第 一次实际寻址执行的时候，就会引起缺页中断，操作系统再将实际的内容从可执行文件中复制内容到物理内存中。<br>
  堆的内容是程序执行中动态分配的，所以加载程序 只是将它的起始地址更新到进程控制块中，执行过程中遇到动态分配内存的操作的时候再在物理内存分配实际的页。参数区在新进程加载的时候要存入环境变量和命令行参数列表。栈在程序加载时候存入的内容就是环境参数列表和命令行参数列表的指针和命令行参数的个数。<br>
1）在shell界面输入./可执行文件名<br>
  经shell分析，该参数非shell内建命令，则认为是加载可执行文件。于是调用fork函数开始创建新进程，产生0x80中断，映射到函数sys_fork()中，调用find_empty_process()函数，为新进程申请一个可用的进程号。<br>
2）为可执行程序的管理结构找到存储空间<br>
  为了实现对进程的保护，系统为每个进程的管理专门设计了一个结构，即task_struct。内核通过调用get_free_page函数获得用于保存task_struct和内核栈的页面只能在内核的线性地址空间。<br>
3）shell进程为新进程复制task_struct结构<br>
  为可执行程序复制了task_struct后，新进程便继承了shell的全部管理信息。但由于每个进程呢的task_struct结构中的信息是不一样的，所以还要对该结构进行个性化设置（为防止在设置的过程中被切换到该进程，应先设置为不可中断状态）。个性化设置主要包括进程号、父进程、时间片、TSS段（为进程间切换而设计的，进程的切换时建立在对进程的保护的基础上的，在进程切换时TSS用来保存或恢复该进程的现场所用到的寄存器的值）。这些都是通过函数copy_process来完成的。<br>
4）复制新进程页表并设置其对应的页目录项<br>
  现在调用函数copy_mem为进程分段（LDT），更新代码段和数据段的基地址，即确定线性地址空间（关键在于确定段基址和限长）。接着就是分页，分页是建立在分段的基础上的。<br>
5）建立新进程与全局描述符（GDT）的关联<br>
  将新进程的TSS和LDT挂接在GDT的指定位置处。（注：TSS和LDT对进程的保护至关重要）<br>
6）将新进程设置为就绪状态<br>
7）加载可执行文件<br>
  进入do_execve函数之后，将可执行文件的头表加载到内存中并检测相关信息。加载执行程序（讲程序按需加载到内存）。</p>
<h3 id="参考资料">参考资料</h3>
<p>详细可查看<br>
<a href="https://blog.csdn.net/weixin_42255666/article/details/82501831">Linux启动流程详解</a><br>
<a href="https://www.cnblogs.com/liuhedong/p/10661608.html#sysv-init">Linux 启动过程详解</a><br>
<a href="https://www.runoob.com/linux/linux-system-boot.html">Linux 系统启动过程</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 474. 一和零[中等][未做出]]]></title>
        <id>https://lixin-scut.github.io//post/dong-tai-gui-hua-474-yi-he-ling-zhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/dong-tai-gui-hua-474-yi-he-ling-zhong-deng-wei-zuo-chu">
        </link>
        <updated>2020-03-21T03:16:02.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>在计算机界中，我们总是追求用有限的资源获取最大的收益。<br>
现在，假设你分别支配着 m 个 0 和 n 个 1。另外，还有一个仅包含 0 和 1 字符串的数组。<br>
你的任务是使用给定的 m 个 0 和 n 个 1 ，找到能拼出存在于数组中的字符串的最大数量。每个 0 和 1 至多被使用一次。<br>
注意:<br>
给定 0 和 1 的数量都不会超过 100。<br>
给定字符串数组的长度不会超过 600。<br>
示例 1:<br>
输入: Array = {&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;}, m = 5, n = 3<br>
输出: 4<br>
解释: 总共 4 个字符串可以通过 5 个 0 和 3 个 1 拼出，即 &quot;10&quot;,&quot;0001&quot;,&quot;1&quot;,&quot;0&quot;。<br>
示例 2:<br>
输入: Array = {&quot;10&quot;, &quot;0&quot;, &quot;1&quot;}, m = 1, n = 1<br>
输出: 2<br>
解释: 你可以拼出 &quot;10&quot;，但之后就没有剩余数字了。更好的选择是拼出 &quot;0&quot; 和 &quot;1&quot;。</p>
</blockquote>
<p>针对背包问题而来，这就是简化背包问题，只有0和1<br>
很明显应该用动态规划或者贪心算法<br>
一个比较笨的方法就是按照size排序，然后不断测试能够取得的最大数<br>
然后动态规划的话，就是记录当前字符选择或者不选择的最大值<br>
需要注意的点</p>
<ol>
<li>三维数组，然后每一维都额外+1，模拟等于0的初始化情况</li>
<li>需要检测字符串中的0和1的个数，为了复用代码我使用了参数模板，注意记得target是char而不是int，而且需要初始化</li>
<li>每次进入第三层循环都需要把上一层的二维数组拷贝过来，等于没有充足的1和0的话就直接取上一次的结果</li>
<li>注意返回值的下标不用+1</li>
<li>可以压缩空间为二维数组</li>
</ol>
<pre><code>class Solution {
public:
    /*
    int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) 
    {
        // 这里不能|| 0 == m || 0 == n
        if(strs.empty() )
        {   return 0; }
        
        int length = strs.size();
        vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; maxForm(length + 1, vector&lt;vector&lt;int&gt;&gt;(m + 1, vector&lt;int&gt;(n + 1, 0)));
        for(int leftStr = 1; leftStr &lt; length+1; ++leftStr)
        {
            int numOf1 = numOfNUM&lt;1&gt;(strs[leftStr-1]);
            int numOf0 = numOfNUM&lt;0&gt;(strs[leftStr-1]);
            
            for(int left0 = 0; left0 &lt; m+1; ++left0)
            {
                for(int left1 = 0; left1 &lt; n+1; ++left1)
                {
                    maxForm[leftStr][left0][left1] = maxForm[leftStr - 1][left0][left1]; // 如果没有充足的1和0的话就直接取上一次的结果
                    if(numOf0 &lt;= left0 &amp;&amp; numOf1 &lt;= left1) 
                    {
                        maxForm[leftStr][left0][left1] = max(maxForm[leftStr-1][left0][left1]
                                                             ,maxForm[leftStr-1][left0 - numOf0][left1 - numOf1] + 1);
                    }
                }
            }
        }
        return maxForm[length][m][n];
    }
    */
    
    // 二维数组
    int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) 
    {
        // 这里不能|| 0 == m || 0 == n
        if(strs.empty() )
        {   return 0; }
        
        int length = strs.size();
        vector&lt;vector&lt;int&gt;&gt; maxForm(m+1, vector&lt;int&gt;(n + 1, 0));
        for(int leftStr = 0; leftStr &lt; length; ++leftStr)
        {
            int numOf1 = numOfNUM&lt;1&gt;(strs[leftStr]);
            int numOf0 = numOfNUM&lt;0&gt;(strs[leftStr]);
            
            //注意这里修改了判断条件和循环方向，从后往前循环，避免了重复赋值
            for(int left0 = m; left0 &gt;= numOf0; --left0)
            {
                for(int left1 = n; left1 &gt;= numOf1; --left1)
                {
                        maxForm[left0][left1] = max(maxForm[left0][left1]
                                                    ,maxForm[left0 - numOf0][left1 - numOf1] + 1);
                }
            }
        }
        return maxForm[m][n];
    }
    
    
private:
    template&lt;unsigned NUM&gt;
    int numOfNUM(string str)
    {
        char target = '0' + NUM;
        int count = 0;
        for(auto c : str)
        {
            if(c == target)
            {
                ++count;
            }
        }
        return count;
    }
};
</code></pre>
<p>网友题解：<br>
动态规划（转换为 0-1 背包问题）</p>
<blockquote>
<p>思路：把总共的 0 个 1 的个数视为背包的容量，每一个字符串视为装进背包的物品。这道题就可以使用 0-1 背包问题的思路完成。这里的目标值是能放进背包的字符串的数量。<br>
思路依然是“一个一个尝试，容量一点一点尝试”，每个物品分类讨论：选与不选。<br>
第 1 步：定义状态<br>
dp[i][j][k] 表示子区间 [0, i] 能够使用 j 个 0 和 k 个 1 的字符串的最大数量。<br>
第 2 步：状态转移方程<br>
dp[i][j][k]=<br>
{<br>
dp[i−1][j][k],  不选择当前考虑的字符串，至少是这个数值<br>
dp[i−1][j−当前字符串使用0的个数][k−当前字符串使用1的个数] 选择当前考虑的字符串<br>
}<br>
第 3 步：初始化<br>
为了避免分类讨论，通常多设置一行。这里可以认为，第 0 个字符串是空串。第 1 行默认初始化为 0。<br>
第 4 步：输出<br>
输出是最后一个状态，即：dp[len][m][n]。</p>
</blockquote>
<pre><code>public class Solution {

    private int[] countZeroAndOne(String str) {
        int[] cnt = new int[2];
        for (char c : str.toCharArray()) {
            cnt[c - '0']++;
        }
        return cnt;
    }

    public int findMaxForm(String[] strs, int m, int n) {
        int len = strs.length;
        int[][][] dp = new int[len + 1][m + 1][n + 1];

        for (int i = 1; i &lt;= len; i++) {
            // 注意：有一位偏移
            int[] cnt = countZeroAndOne(strs[i - 1]);
            for (int j = 0; j &lt;= m; j++) {
                for (int k = 0; k &lt;= n; k++) {
                    // 先把上一行抄下来
                    dp[i][j][k] = dp[i - 1][j][k];

                    int zeros = cnt[0];
                    int ones = cnt[1];

                    if (j &gt;= zeros &amp;&amp; k &gt;= ones) {
                        dp[i][j][k] = Math.max(dp[i - 1][j][k], dp[i - 1][j - zeros][k - ones] + 1);
                    }
                }
            }
        }
        return dp[len][m][n];
    }
}
</code></pre>
<blockquote>
<p>第 5 步：思考状态压缩<br>
因为当前行只参考了上一行的值，因此可以使用滚动数组，也可以从后向前赋值。</p>
</blockquote>
<pre><code>public class Solution {

    private int[] calcZeroAndOne(String str) {
        int[] res = new int[2];
        for (char c : str.toCharArray()) {
            res[c - '0']++;
        }
        return res;
    }

    public int findMaxForm(String[] strs, int m, int n) {
        int[][] dp = new int[m + 1][n + 1];
        dp[0][0] = 0;
        for (String s : strs) {
            int[] zeroAndOne = calcZeroAndOne(s);
            int zeros = zeroAndOne[0];
            int ones = zeroAndOne[1];
            for (int i = m; i &gt;= zeros; i--) {
                for (int j = n; j &gt;= ones; j--) {
                    dp[i][j] = Math.max(dp[i][j], dp[i - zeros][j - ones] + 1);
                }
            }
        }
        return dp[m][n];
    }
}
</code></pre>
<p>另外一个优化过程：<br>
自顶向下( 记忆搜索)-&gt;自底向上(动态规划)-&gt;存储空间优化</p>
<blockquote>
<p>说明<br>
首先这是一个复杂一点的背包问题，m个0，n个1 可以看作是背包，而字符串数组strs是物品列表<br>
则对于每一个物品(str)，都有放进背包(背包的容量要变成m-numsOfStr0,n-numsOfStr1)和不放进背包两种选择,其中numsOfStr0表示str中0的个数，numsOfStr1表示str中1的个数<br>
则有<br>
状态: f(i,j,k)代表用j个0，k个1组装strs[0...i]的最大个数<br>
动态转移方程: f(i,j,k) = max(f(i-1,j,k),f(i-1,j-numsOfStr0,k-numsOfStr1))<br>
先用递归还原动态转移方程<br>
代码</p>
</blockquote>
<pre><code>class Solution {
public int findMaxForm(String[] strs, int m, int n) {
    if(strs.length == 0 || (m==0 &amp;&amp; n==0)){
        return 0;
    }
    return tryFindMaxForm(strs,strs.length-1,m,n);
}

// 用m，n 拼出 strs[0,i] 的 最大个数
public int tryFindMaxForm(String[] strs,int i,int m, int n){
    if(i&lt;0){
        return 0;
    }
    int numsOf0 = 0;
    int numsOf1 = 0;
    String str = strs[i];
    for(int j = 0;j&lt;str.length();j++){
        if(str.charAt(j) == '0'){
            numsOf0++;
        }else{
            numsOf1++;
        }
    }
    if(m&gt;=numsOf0&amp;&amp;n&gt;=numsOf1){
        return Math.max(tryFindMaxForm(strs,i-1,m,n),
                        1+tryFindMaxForm(strs,i-1,m-numsOf0,n-numsOf1));
    }else{
        return tryFindMaxForm(strs,i-1,m,n);
    }
}
</code></pre>
<p>执行结果，执行时长超时</p>
<blockquote>
<p>自顶向下-记忆化搜索<br>
在递归过程中会遇到重叠子问题 如<br>
f(8,5,4) = max(f(7,5,4),f(7,3,2)) str = 1100<br>
f(8,5,2) = max(f(7,5,2),f(7,3,2)) str = 11<br>
f(7,3,2) 会被重复计算<br>
所以可添加记忆化搜索</p>
</blockquote>
<p>代码</p>
<pre><code>class Solution {

private int[][][] memo;
public int findMaxForm(String[] strs, int m, int n) {
    if(strs.length == 0 || (m==0 &amp;&amp; n==0)){
        return 0;
    }
    this.memo = new int[strs.length][m+1][n+1];
    for(int i = 0;i&lt;memo.length;i++){
        for(int j=0;j&lt;memo[i].length;j++){
            Arrays.fill(memo[i][j],-1);
        }
    }
    return tryFindMaxForm(strs,strs.length-1,m,n);
}

// 用m，n 拼出 strs[0,i] 的 最大个数
public int tryFindMaxForm(String[] strs,int i,int m, int n){
    if(i&lt;0){
        return 0;
    }
    if(memo[i][m][n] != -1){
        return memo[i][m][n];
    }
    int numsOf0 = 0;
    int numsOf1 = 0;
    String str = strs[i];
    for(int j = 0;j&lt;str.length();j++){
        if(str.charAt(j) == '0'){
            numsOf0++;
        }else{
            numsOf1++;
        }
    }
    if(m&gt;=numsOf0&amp;&amp;n&gt;=numsOf1){
        memo[i][m][n] = Math.max(tryFindMaxForm(strs,i-1,m,n),
                                1+tryFindMaxForm(strs,i-1,m-numsOf0,n-numsOf1));
    }else{
        memo[i][m][n] = tryFindMaxForm(strs,i-1,m,n);
    }
    return memo[i][m][n];
}
   
}
</code></pre>
<blockquote>
<p>结果<br>
虽然执行成功，但是时间很长和空间占用很打，分析其原因有二<br>
递归方法栈过长导致执行时长增加<br>
三维数组在索引上的耗时和空间上的占用</p>
</blockquote>
<blockquote>
<p>非递归的动态规划<br>
为了解决3中的问题1，可以使用自底向上的动态规划，用循环替代递归<br>
代码</p>
</blockquote>
<pre><code>class Solution {

public int findMaxForm(String[] strs, int m, int n) {
    if(strs.length == 0 || (m==0 &amp;&amp; n==0)){
        return 0;
    }
    // dp[i][j][k] 表示j个0，k个1组成s[0...i]的最大个数，默认0
    int[][][] dp = new int[strs.length][m+1][n+1];
    
    for(int i=0;i&lt;strs.length;i++){
        int numsOf0 = 0;
        int numsOf1 = 0;
        String str = strs[i];
        for(int j = 0;j&lt;str.length();j++){
            if(str.charAt(j) == '0'){
                numsOf0++;
            }else{
                numsOf1++;
            }
        }
        for(int j=m;j&gt;=0;j--){
            for(int k=n;k&gt;=0;k--){
                if(j&gt;=numsOf0 &amp;&amp; k &gt;= numsOf1){
                    if(i==0){
                        dp[i][j][k] = 1;
                    }else{
                        dp[i][j][k] = Math.max(dp[i-1][j][k],1+dp[i-1][j-numsOf0][k-numsOf1]);
                    }
                }else{
                    dp[i][j][k] = i&gt;0 ? dp[i-1][j][k] : 0;
                }   
            }
        }
    }
    return dp[strs.length-1][m][n];
}
}
</code></pre>
<blockquote>
<p>结果<br>
执行时长有所下降，但是仍然很高，而且空间占用依旧很大，说明3中的问题2是一个比较严重的问题，我们还没有解决</p>
</blockquote>
<blockquote>
<p>动态规划的空间优化<br>
观察动态转移方程，我们发现dp[i][][] 只和dp[i-1][][] 有关，所以可以去掉第一维，只用一个二维数组保存上一次计算的结果<br>
代码</p>
</blockquote>
<pre><code>class Solution {

public int findMaxForm(String[] strs, int m, int n) {
    if(strs.length == 0 || (m==0 &amp;&amp; n==0)){
        return 0;
    }
    
    int[][] dp = new int[m+1][n+1];
   
    for(int i=0;i&lt;strs.length;i++){
        int numsOf0 = 0;
        int numsOf1 = 0;
        String str = strs[i];
        for(int j = 0;j&lt;str.length();j++){
            if(str.charAt(j) == '0'){
                numsOf0++;
            }else{
                numsOf1++;
            }
        }
        for(int j=m;j&gt;=numsOf0;j--){
            for(int k=n;k&gt;=numsOf1;k--){
                dp[j][k] = Math.max(dp[j][k],1+dp[j-numsOf0][k-numsOf1]);
            }
        }
    }
    return dp[m][n];
}
}
</code></pre>
<blockquote>
<p>结果<br>
经过最后一步优化，时间和空间性能都大幅提升</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[makefile 与 CMakeList]]></title>
        <id>https://lixin-scut.github.io//post/makefile-yu-cmakelist</id>
        <link href="https://lixin-scut.github.io//post/makefile-yu-cmakelist">
        </link>
        <updated>2020-03-19T13:00:54.000Z</updated>
        <content type="html"><![CDATA[<p>这两者可以说是大名鼎鼎了，今天就来认识一下</p>
<h3 id="makefile-与-cmakelist">makefile 与 CMakeList</h3>
<p>  .gcc是GNU Compiler Collection（就是GNU编译器套件），也可以简单认为是编译器，它可以编译很多种编程语言（括C、C++、Objective-C、Fortran、Java等等）。<br>
  当你的程序只有一个源文件时，直接就可以用gcc命令编译它。但是当你的程序包含很多个源文件时，用gcc命令逐个去编译时，你就很容易混乱而且工作量大。<br>
  所以出现了make工具，make工具可以看成是一个智能的批处理工具，它本身并没有编译和链接的功能，而是用类似于批处理的方式—通过调用makefile文件中用户指定的命令来进行编译和链接的。make工具就根据makefile中的命令进行编译和链接的。<br>
  makefile命令中就包含了调用gcc（也可以是别的编译器）去编译某个源文件的命令。makefile在一些简单的工程完全可以人工手写，但是当工程非常大的时候，手写makefile也是非常麻烦的，如果换了个平台makefile又要重新修改。</p>
<p>  这时候就出现了Cmake这个工具，cmake就可以更加简单的生成makefile文件给上面那个make用。当然cmake还有其他功能，就是可以跨平台生成对应平台能用的makefile，你不用再自己去修改了。<br>
  可是cmake根据什么生成makefile呢？它又要根据一个叫CMakeLists.txt文件（学名：组态档）去生成makefile。<br>
  最后CMakeLists.txt文件必须自己手写或者由IDE生成的</p>
<p>  make 是用来执行Makefile的，Makefile是类unix环境下(比如Linux)的类似于批处理的&quot;脚本&quot;文件。其基本语法是: 目标+依赖+命令，只有在目标文件不存在，或目标比依赖的文件更旧，命令才会被执行。<br>
  由此可见，Makefile和make可适用于任意工作，不限于编程。比如，可以用来管理latex。<br>
  Makefile+make可理解为类unix环境下的项目管理工具，但它太基础了，抽象程度不高，而且在windows下不太友好(针对visual studio用户)，于是就有了跨平台项目管理工具cmake，cmake是跨平台项目管理工具，它用更抽象的语法来组织项目。虽然，仍然是目标，依赖之类的东西，但更为抽象和友好，<br>
<img src="https://lixin-scut.github.io//post-images/1584623168910.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1584629291049.png" alt=""></p>
<h3 id="makefile">makefile</h3>
<p>  makefile带来的好处就是“自动化编译”，makefile中会定义一系列的规 则，指定哪些文件需要先编译，哪些文件需要后编译，哪些文件<strong>需要重新编译</strong>，甚至于进行更复杂的功能操作。<br>
<img src="https://lixin-scut.github.io//post-images/1584624719171.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1584624705759.png" alt=""><br>
一个makefile主要含有一系列的规则，如下所示：</p>
<pre><code>A: B
(tab)&lt;command&gt;
(tab)&lt;command&gt;
</code></pre>
<p>每个命令行前都必须有tab符号<br>
  当用户键入&quot;make clean*'命令时，会删除*.o和helloworld文件。写好makefile文件, 在命令行中直接键入make命令，就会执行makefile中的内容了</p>
<p><img src="https://lixin-scut.github.io//post-images/1584626076108.png" alt=""><br>
  这里应用到了变量。要设定一个变量，只要在一行的前端写下这个变量的名字，后面跟一个“=”号，后面跟要设定的这个变量的值即可。以后要引用这个变量，只写一个“$” 符号，后面是在括号里的变量名即可。<br>
  CFLAGS = -Wall -O -g：配置编译器设置，并把它赋值给CFLAGS变量，其中每个部分含义为：①-Wall：输出所有的警告信息；②-O：编译时进行优化；③-g：表示编译debug版本。</p>
<p><img src="https://lixin-scut.github.io//post-images/1584626123870.png" alt=""><br>
  在makefile规则中，通配符会被自动展开。但在变量的定义和函数引用时，通配符将失效。这种情况下如果需要通配符有效，就需要使用函数wildcard,它的用法是：<br>
<code>$(wildcard PATTERN...)</code><br>
  在makefile中，它被展开为已经存在的、使用空格分开的、匹配此模式的所有文件列表。<br>
  如果不存在任何符合此模式的文件，函数会忽略模式字符并返回空。需要注意的是：这种情况下的规则中通配符的展开和上面匹配通配符是有区别的。 下面这一行表示产生一个所有以.c、 .cpp结尾的文件的列表，然后存入变量SOURCES里。<br>
<code>SOURCES = $(wildcard *.c *.cpp)</code><br>
  patsubst函数，'用于匹配替换，有3个参数。第一个是一个需要匹配的式样，第二个表示用什么来替换它，第三个是一个需要被处理的由空格分隔的列表，比如：<br>
<code>$(patsubst %.c,%.o,$(dir))</code><br>
  是指用patsubst把$(击「)中的变量符合后缀是.c的全部替换成.O。<br>
  而下面这一行代码，则 表示把文件列表中所有的.c、.cpp字符变成.o,形成一个新的文件列表，然后存入0BJS变量中。<br>
<code>OBJS = $(patsubst %.c , %.o , $(patsubst %.cpp , %.o , $(SOURCES)))</code><br>
这几句命令表示把所有的.C、.cpp文件编译成.0文件。</p>
<pre><code>% .o ：% . c
			$(CC) $(CFLAGS) -c $&lt; -O $@
%.o : %.cpp
			$(XX) $(CFLAGS) -c $&lt; -O $@
</code></pre>
<p>这里有3个比较有用的内部变量：<br>
①<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">@</mi><mi mathvariant="normal">扩</mi><mi mathvariant="normal">展</mi><mi mathvariant="normal">成</mi><mi mathvariant="normal">当</mi><mi mathvariant="normal">前</mi><mi mathvariant="normal">规</mi><mi mathvariant="normal">则</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">目</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">文</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">名</mi><mi mathvariant="normal">；</mi><mi mathvariant="normal">②</mi></mrow><annotation encoding="application/x-tex">@ 扩展成当前规则的目的文件名；
②</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">@</span><span class="mord cjk_fallback">扩</span><span class="mord cjk_fallback">展</span><span class="mord cjk_fallback">成</span><span class="mord cjk_fallback">当</span><span class="mord cjk_fallback">前</span><span class="mord cjk_fallback">规</span><span class="mord cjk_fallback">则</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">目</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">文</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">名</span><span class="mord cjk_fallback">；</span><span class="mord">②</span></span></span></span>&lt;扩展成依靠列表中的第一个依靠文件；<br>
③而$^扩展成整个依靠的列表(除掉了里面所有重复的文件名)。</p>
<h3 id="cmakelist">CMakeList</h3>
<p>一、Cmake 简介<br>
  cmake 是一个跨平台、开源的构建系统。它是一个集软件构建、测试、打包于一身的软件。它使用与平台和编译器独立的配置文件来对软件编译过程进行控制</p>
<p>二、常用命令</p>
<ol>
<li>
<p>指定 cmake 的最小版本<br>
<code>cmake_minimum_required(VERSION 3.4.1)</code><br>
  这行命令是可选的，我们可以不写这句话，但在有些情况下，如果 CMakeLists.txt 文件中使用了一些高版本 cmake 特有的一些命令的时候，就需要加上这样一行，提醒用户升级到该版本之后再执行 cmake。</p>
</li>
<li>
<p>设置项目名称<br>
<code>project(demo)</code><br>
  这个命令不是强制性的，但最好都加上。它会引入两个变量 demo_BINARY_DIR 和 demo_SOURCE_DIR，同时，cmake 自动定义了两个等价的变量 PROJECT_BINARY_DIR 和 PROJECT_SOURCE_DIR。</p>
</li>
<li>
<p>设置编译类型</p>
</li>
</ol>
<pre><code>add_executable(demo demo.cpp) # 生成可执行文件
add_library(common STATIC util.cpp) # 生成静态库
add_library(common SHARED util.cpp) # 生成动态库或共享库
</code></pre>
<p>  add_library 默认生成是静态库，通过以上命令生成文件名字</p>
<ul>
<li>在 Linux 下是：<br>
demo<br>
libcommon.a<br>
libcommon.so</li>
<li>在 Windows 下是：<br>
demo.exe<br>
common.lib<br>
common.dll</li>
</ul>
<ol start="4">
<li>指定编译包含的源文件<br>
<strong>明确指定包含哪些源文件</strong><br>
<code>add_library(demo demo.cpp test.cpp util.cpp)</code></li>
</ol>
<p><strong>搜索所有的 cpp 文件</strong><br>
  aux_source_directory(dir VAR) 发现一个目录下所有的源代码文件并将列表存储在一个变量中。</p>
<pre><code>aux_source_directory(. SRC_LIST) # 搜索当前目录下的所有.cpp文件
add_library(demo ${SRC_LIST})
</code></pre>
<p><strong>自定义搜索规则</strong></p>
<pre><code>file(GLOB SRC_LIST &quot;*.cpp&quot; &quot;protocol/*.cpp&quot;)
add_library(demo ${SRC_LIST})
# 或者
file(GLOB SRC_LIST &quot;*.cpp&quot;)
file(GLOB SRC_PROTOCOL_LIST &quot;protocol/*.cpp&quot;)
add_library(demo ${SRC_LIST} ${SRC_PROTOCOL_LIST})
# 或者
aux_source_directory(. SRC_LIST)
aux_source_directory(protocol SRC_PROTOCOL_LIST)
add_library(demo ${SRC_LIST} ${SRC_PROTOCOL_LIST})
</code></pre>
<ol start="5">
<li>查找指定的库文件<br>
  find_library(VAR name path)查找到指定的预编译库，并将它的路径存储在变量中。<br>
  默认的搜索路径为 cmake 包含的系统库，因此如果是 NDK 的公共库只需要指定库的 name 即可。</li>
</ol>
<pre><code>find_library( # Sets the name of the path variable.
              log-lib
 
              # Specifies the name of the NDK library that
              # you want CMake to locate.
              log )
</code></pre>
<p>  类似的命令还有 find_file()、find_path()、find_program()、find_package()。</p>
<ol start="6">
<li>设置包含的目录</li>
</ol>
<pre><code>include_directories(
    ${CMAKE_CURRENT_SOURCE_DIR}
    ${CMAKE_CURRENT_BINARY_DIR}
    ${CMAKE_CURRENT_SOURCE_DIR}/include
)
</code></pre>
<p>  Linux 下还可以通过如下方式设置包含的目录<br>
<code>set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -L${CMAKE_CURRENT_SOURCE_DIR}&quot;)</code></p>
<ol start="7">
<li>设置链接库搜索目录</li>
</ol>
<pre><code>link_directories(
    ${CMAKE_CURRENT_SOURCE_DIR}/libs
)
</code></pre>
<p>  Linux 下还可以通过如下方式设置包含的目录</p>
<pre><code>set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -L${CMAKE_CURRENT_SOURCE_DIR}/libs&quot;)
</code></pre>
<ol start="8">
<li>设置 target 需要链接的库</li>
</ol>
<pre><code>target_link_libraries( # 目标库
                       demo
 
                       # 目标库需要链接的库
                       # log-lib 是上面 find_library 指定的变量名
                       ${log-lib} )
</code></pre>
<p>  在 Windows 下，系统会根据链接库目录，搜索xxx.lib 文件，Linux 下会搜索 xxx.so 或者 xxx.a 文件，如果都存在会优先链接动态库（so 后缀）。</p>
<p><strong>指定链接动态库或静态库</strong></p>
<pre><code>target_link_libraries(demo libface.a) # 链接libface.a
target_link_libraries(demo libface.so) # 链接libface.so
</code></pre>
<p>  指定全路径</p>
<pre><code>target_link_libraries(demo ${CMAKE_CURRENT_SOURCE_DIR}/libs/libface.a)
target_link_libraries(demo ${CMAKE_CURRENT_SOURCE_DIR}/libs/libface.so)
</code></pre>
<p>  指定链接多个库</p>
<pre><code>target_link_libraries(demo
    ${CMAKE_CURRENT_SOURCE_DIR}/libs/libface.a
    boost_system.a
    boost_thread
    pthread)
</code></pre>
<ol start="9">
<li>设置变量<br>
<strong>set 直接设置变量的值</strong></li>
</ol>
<pre><code>set(SRC_LIST main.cpp test.cpp)
add_executable(demo ${SRC_LIST})
</code></pre>
<p><strong>set 追加设置变量的值</strong></p>
<pre><code>set(SRC_LIST main.cpp)
set(SRC_LIST ${SRC_LIST} test.cpp)
add_executable(demo ${SRC_LIST})
</code></pre>
<p><strong>list 追加或者删除变量的值</strong></p>
<pre><code>set(SRC_LIST main.cpp)
list(APPEND SRC_LIST test.cpp)
list(REMOVE_ITEM SRC_LIST main.cpp)
add_executable(demo ${SRC_LIST})
</code></pre>
<ol start="10">
<li>条件控制<br>
<strong>if…elseif…else…endif</strong></li>
</ol>
<p><strong>逻辑判断和比较：</strong><br>
if (expression)：expression 不为空（0,N,NO,OFF,FALSE,NOTFOUND）时为真<br>
if (not exp)：与上面相反<br>
if (var1 AND var2)<br>
if (var1 OR var2)<br>
if (COMMAND cmd)：如果 cmd 确实是命令并可调用为真<br>
if (EXISTS dir) if (EXISTS file)：如果目录或文件存在为真<br>
if (file1 IS_NEWER_THAN file2)：当 file1 比 file2 新，或 file1/file2 中有一个不存在时为真，文件名需使用全路径<br>
if (IS_DIRECTORY dir)：当 dir 是目录时为真<br>
if (DEFINED var)：如果变量被定义为真<br>
if (var MATCHES regex)：给定的变量或者字符串能够匹配正则表达式 regex 时为真，此处 var 可以用 var 名，也可以用 ${var}<br>
if (string MATCHES regex)</p>
<p><strong>数字比较：</strong><br>
if (variable LESS number)：LESS 小于<br>
if (string LESS number)<br>
if (variable GREATER number)：GREATER 大于<br>
if (string GREATER number)<br>
if (variable EQUAL number)：EQUAL 等于<br>
if (string EQUAL number)</p>
<p><strong>字母表顺序比较：</strong><br>
if (variable STRLESS string)<br>
if (string STRLESS string)<br>
if (variable STRGREATER string)<br>
if (string STRGREATER string)<br>
if (variable STREQUAL string)<br>
if (string STREQUAL string)</p>
<p>示例：</p>
<pre><code>if(MSVC)
    set(LINK_LIBS common)
else()
    set(boost_thread boost_log.a boost_system.a)
endif()
target_link_libraries(demo ${LINK_LIBS})

# 或者
if(UNIX)
    set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -std=c++11 -fpermissive -g&quot;)
else()
    add_definitions(-D_SCL_SECURE_NO_WARNINGS
    D_CRT_SECURE_NO_WARNINGS
    -D_WIN32_WINNT=0x601
    -D_WINSOCK_DEPRECATED_NO_WARNINGS)
endif()
 
if(${CMAKE_BUILD_TYPE} MATCHES &quot;debug&quot;)
    ...
else()
    ...
endif()
</code></pre>
<p><strong>while…endwhile</strong></p>
<pre><code>while(condition)
    ...
endwhile()
</code></pre>
<p><strong>foreach…endforeach</strong></p>
<pre><code>foreach(loop_var RANGE start stop [step])
    ...
endforeach(loop_var)
</code></pre>
<p>  start 表示起始数，stop 表示终止数，step 表示步长，示例：</p>
<pre><code>foreach(i RANGE 1 9 2)
    message(${i})
endforeach(i)

# 输出：13579
</code></pre>
<ol start="11">
<li>打印信息</li>
</ol>
<pre><code>message(${PROJECT_SOURCE_DIR})
message(&quot;build with debug mode&quot;)
message(WARNING &quot;this is warnning message&quot;)
message(FATAL_ERROR &quot;this build has many error&quot;) # FATAL_ERROR 会导致编译失败
</code></pre>
<ol start="12">
<li>包含其它 cmake 文件</li>
</ol>
<pre><code>include(./common.cmake) # 指定包含文件的全路径
include(def) # 在搜索路径中搜索def.cmake文件
set(CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake) # 设置include的搜索路径
</code></pre>
<p>三、常用变量</p>
<ol>
<li>
<p>预定义变量<br>
PROJECT_SOURCE_DIR：工程的根目录<br>
PROJECT_BINARY_DIR：运行 cmake 命令的目录，通常是 ${PROJECT_SOURCE_DIR}/build<br>
PROJECT_NAME：返回通过 project 命令定义的项目名称<br>
CMAKE_CURRENT_SOURCE_DIR：当前处理的 CMakeLists.txt 所在的路径<br>
CMAKE_CURRENT_BINARY_DIR：target 编译目录<br>
CMAKE_CURRENT_LIST_DIR：CMakeLists.txt 的完整路径<br>
CMAKE_CURRENT_LIST_LINE：当前所在的行<br>
CMAKE_MODULE_PATH：定义自己的 cmake 模块所在的路径，SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)，然后可以用INCLUDE命令来调用自己的模块<br>
EXECUTABLE_OUTPUT_PATH：重新定义目标二进制可执行文件的存放位置<br>
LIBRARY_OUTPUT_PATH：重新定义目标链接库文件的存放位置</p>
</li>
<li>
<p>环境变量<br>
使用环境变量<br>
<code>$ENV{Name}</code><br>
写入环境变量<br>
<code>set(ENV{Name} value) # 这里没有“$”符号</code></p>
</li>
<li>
<p>系统信息<br>
CMAKE_MAJOR_VERSION：cmake 主版本号，比如 3.4.1 中的 3<br>
CMAKE_MINOR_VERSION：cmake 次版本号，比如 3.4.1 中的 4<br>
CMAKE_PATCH_VERSION：cmake 补丁等级，比如 3.4.1 中的 1<br>
CMAKE_SYSTEM：系统名称，比如 Linux-2.6.22<br>
CMAKE_SYSTEM_NAME：不包含版本的系统名，比如 Linux<br>
CMAKE_SYSTEM_VERSION：系统版本，比如 2.6.22<br>
CMAKE_SYSTEM_PROCESSOR：处理器名称，比如 i686<br>
UNIX：在所有的类 UNIX 平台下该值为 TRUE，包括 OS X 和 cygwin<br>
WIN32：在所有的 win32 平台下该值为 TRUE，包括 cygwin</p>
</li>
<li>
<p>主要开关选项<br>
BUILD_SHARED_LIBS：这个开关用来控制默认的库编译方式，如果不进行设置，使用 add_library 又没有指定库类型的情况下，默认编译生成的库都是静态库。如果 set(BUILD_SHARED_LIBS ON) 后，默认生成的为动态库<br>
CMAKE_C_FLAGS：设置 C 编译选项，也可以通过指令 add_definitions() 添加<br>
CMAKE_CXX_FLAGS：设置 C++ 编译选项，也可以通过指令 add_definitions() 添加<br>
<code>add_definitions(-DENABLE_DEBUG -DABC) # 参数之间用空格分隔</code></p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[程序的机器级表示]]></title>
        <id>https://lixin-scut.github.io//post/cheng-xu-de-ji-qi-ji-biao-shi</id>
        <link href="https://lixin-scut.github.io//post/cheng-xu-de-ji-qi-ji-biao-shi">
        </link>
        <updated>2020-03-19T10:12:18.000Z</updated>
        <content type="html"><![CDATA[<h3 id="程序编码">程序编码</h3>
<p>对于命令：<br>
linux&gt; gcc -Og -o p p1.c p2.c<br>
  -Og选项告诉编译器使用会生成符合原始C代码整体结构的机器代码的优化等级<br>
  提高gcc的优化级别，会使得产生的机器代码和初始源代码之间的关系非常难以理解。-O2，第二级优化是默认选择。<br>
  机器代码的两种形式：目标代码，可执行代码。目标代码包含了所有的指令但还没有填入地址的全局值，后者是处理器执行的代码格式。</p>
<p><strong>机器级代码</strong><br>
对于机器级编程来说，有两种抽象尤其重要：<br>
  第一种 由指令集体系结构或指令集架构来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。<br>
  第二种抽象是机器级程序使用的存储器地址是虚拟地址，提供的存储器模型看上去是一个非常大的字节数组。</p>
<p>  在整个编译过程中，编译器会完成大部分的工作，将把用 C 语言提供的相对比较抽象的执行模型表示的程序转化成处理器执行的非常基本的指令。汇编代码表示非常接近于机器代码。与机器代码的二进制格式相比，汇编代码的主要特点是它用可读性更好的文本格式表示。能够理解汇编代码以及它与原始c代码的联系，是理解计算机如何执行程序的关键一部。</p>
<p>  机器代码和原始的c代码差别非常大。一些通常对c语言程序员隐藏的处理器状态是可见的：</p>
<ol>
<li>程序计数器，PC，用%rip表示，指示要执行的下一条指令在存储器中的地址，这里的存储器是指主存。</li>
<li>整数寄存器，包含 16 个命名的位置，分别存储 64 位的值。这些寄存器可以存储地址 (对应于C语言的指针)或整数数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。</li>
<li>条件码寄存器，保存着最近执行的算术或逻辑指令的状态信息。用来实现if和while等。</li>
<li>一组向量寄存器可以存放一个或多个整数或浮点数据。<br>
  虽然 C 语言提供了一种模型，可以在内存中声明和分配各种数据类型的对象，机器代码只是将存储器看成一个很大的、按字节寻址的数组。</li>
</ol>
<p>  程序存储器（program memeory）包含：程序的可执行机器代码（代码和数据区），操作系统需要的一些信息（应该也在代码和数据区），用来管理过程调用和返回的运行时栈（栈），以及用户分配的存储器块（堆）。</p>
<p>  操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器存储器（processor memory）中的物理地址。</p>
<p>  一条机器指令只执行一个非常基本的操作。机器执行的程序只是一个字节序列，它是对一系列指令的编码。机器对产生这些指令的源代码几乎一无所知。</p>
<p><strong>反汇编：</strong><br>
gcc -O1 -s x.c 输出 汇编代码<br>
gcc -O1 -c x.c 输出 目标代码<br>
objdump -d x.o 反汇编机器代码<br>
gdb 可以直接对机器代码使用<br>
gcc -s产生的汇编代码中，所有以点开头的行都是用于指导汇编器和链接器的。</p>
<p>  gcc和objdump产生的汇编代码是ATT风格。<br>
  Intel用术语word表示16位数据类型，32为double words，64位为quad words，这是由于最初Intel系列是从16位开始的。<br>
  ATT风格的汇编代码指令都有一个字符后缀，表面操作数的大小。Intel风格的汇编代码是没有的。</p>
<h3 id="数据格式">数据格式</h3>
<p><img src="https://lixin-scut.github.io//post-images/1584703688881.png" alt=""><br>
  浮点数主要有两种形式:单精度(4 字节)值，对应于 C 语言数据类型 float;双精度 (8 字节) 值，对应于 C 语言数据类型 double。<br>
  大多数 GCC 生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。例如， 数据传送指令有四个变种:movb(传送字节)、movw(传送字)、movl(传送双 字)和movq(传送四字)。</p>
<h3 id="访问信息">访问信息</h3>
<p>  一个x86-64的中央处理单元(CPU)包含一组16个存储64位值的通用目的寄存器。 这些寄存器用来存储整数数据和指针。图显示了这 16 个寄存器。它们的名字都以%r开头，不过后面还跟着一些不同的命名规则的名字，</p>
<p><img src="https://lixin-scut.github.io//post-images/1584704053941.png" alt=""><br>
  指令可以对这16个寄存器的低位字节中存放的不同大小的数据进行操作。字节级操作可以访问最低的字节，16位操作可以访问最低的2个字节，32 位操作可以访问最低的4个字节，而 64 位操作可以访问整个寄存器。<br>
两条规则:</p>
<ol>
<li>生成 1 字节和 2 字节数字的指令会保持剩下的字节不变</li>
<li>生成 4 字节数字的指令会把高位4个字节置为0。<br>
  在常见的程序里不同的寄存器扮演不同的角色。 其中最特别的是栈指针%rsp，用来指明运行时栈的结束位置。有些程序会明确地读写这个寄存器。另外15个寄存器的用法更灵活。少量指令会使用某些特定的寄存器。</li>
</ol>
<p><strong>操作符指示数</strong><br>
  大多数指令有一个或多个操作数(operand),指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。X86-64 支持多种操作数格式。  源数据值可以以常数形式给出， 或是从寄存器或内存中读出。结果可以存放在寄存器或内存中。<br>
各种不同的操作数的可能性被分为三种类型。</p>
<ul>
<li>第一种类型是立即数(immediate),用来表示常数值。</li>
<li>第二种类型是寄存器 (register),它表示某个寄 存器的内容，</li>
<li>第三类操作数是内存引用，它会根据计算出来的地址(通常称为有效地址)访问某个内存位置。<br>
有多种不同的寻址模式，允许不同形式的内存引用。<br>
<img src="https://lixin-scut.github.io//post-images/1584704653508.png" alt=""></li>
</ul>
<p><strong>数据传送指令</strong><br>
  最频繁使用的指令是将数据从一个位置复制到另一个位置的指令。操作数表示的通用性使得一条简单的数据传送指令能够完成在许多机器中要好几条不同指令才能完成的功能。<br>
  多种不同的数据传送指令，它们或者源和目的类型不同，或者执行的转换 不同，或者具有的一些副作用不同。</p>
<p>  最简单形式的数据传送指令--MOV 类。这些指令把数据从源位置 复制到目的 位置，不做任何变化。<br>
  MOV类由四条指令组成:movb、movw、movl和 movqo这些指令都执行同样的操作;主要区别在于它们操作的数据大小不同:分别是 1、2、4和8字节。<br>
<img src="https://lixin-scut.github.io//post-images/1584704908715.png" alt=""><br>
  源操作数指定的值是一个立即数，存储在寄存器中或者内存中。目的操作数指定一个位置，要么是一个寄存器或者，要么是一个内存地址。<br>
  X86-64 加了一条限制，传送指令的两个操作数不能都指向内存位置。将一个值从一个内存位置复制到另一个内存位置需要两 条指令一第一条指令将源值 加载到寄存器中，第二条将该寄存器值写入目的位置</p>
<p><strong>压入和弹出栈数据</strong><br>
  栈在处理过程调用中起到至关重要的作用。栈是一种数据结构&quot;可以添加或者删除值，不过要遵循“后进先出”的原则。通过 push 操作把数据压入 栈中，通过 pop 操作删除数据;它具有一个属性:弹出的值永远是最近被压入而且仍然在 栈中的值。<br>
  程序栈存放在内存中某个区域。栈向下增长，顶元素的地址是所有栈中元素地址中最低的。<br>
<img src="https://lixin-scut.github.io//post-images/1584705120141.png" alt=""><br>
  pushq指令的功能是把数据压入到栈上，而popq指令是弹出数据。这些指令都只有 一个操作数 ——压入的数据源和弹出的数据目的。</p>
<h3 id="算术和逻辑操作">算术和逻辑操作</h3>
<p>  大多数整数和逻辑操作都分成了指令类，这些指令类有各种带不同大小操作数的变种(只有leaq没有其他大小的变种)<br>
<img src="https://lixin-scut.github.io//post-images/1584705341889.png" alt=""></p>
<p><strong>加载有效地址</strong><br>
  加载有效地址(load effective address)指令 leaq 实际上是 movq 指令的变形。它的指令形式是从内存读数据到寄存器，但实际上它根本就没有引用内存。<br>
  它的第一个操作数看 上去是一个内存引用，但该指令并不是从指定的位置读入数据，而是将有效地址写入到目的操作数。<br>
  这条指令可以为后 面的内存引用产生指针。另外，它还可以简<br>
洁地描述普通的算术操作。</p>
<p><strong>一元和二元操作</strong><br>
  第二组中的操作是一元操作，只有一个操作数，既是源又是目的。这个操作数可以是一个寄存器，也可以是一个内存位置。<br>
  第三组是二元操作，其中，第二个操作数既是源又是目的。<br>
  第一个操作数可以是立即数、寄存器或是内存位置。第 二个操作数可以是寄存器或是内存位置。注意， 当第二个操作数为内存地址时，处理器必须从内存读出值，执行操作，再把结果写回内存。</p>
<p><strong>移位操作</strong><br>
  最后一组是移位操作，先给出移位量，然后第二项给出的是要移位的数。可以进行算术和逻辑右移。移位量可以是一个立即数，或者放在单字节寄存器%ci 中。(这些指令很 特别，因为只允许以 这个特定的寄存器作为操作数。)原则上来说，1 个字节的移位量使得移位量的编码范围可以达到 2^8 - 1 = 255。x86-64 中，移位操作对 w位长的数据值进行操 作，移位量是由%cl 寄存器的低 m 位决定的，这里 2^m= w。高位会被忽略。<br>
  左移指令有两个名字:SAL和SHL。两者的效果是一样的，都是将 右边填上0。<br>
  右移指令不同，SAR 执行算术移位(填上符号位)，而 SHR 执行逻辑移位(填 上 0)。<br>
  移位操作的目的操作数可以是一个寄存器或是一个内存位置。</p>
<p><strong>特殊的算术操作</strong><br>
  x86-64指令集对128位(16字节)数的操作提供有限的支持。延续字(2字节)、 双字(4字节)和 四字(8 字节)的命名惯例，Intel 把 16 字节的数称为八字(oct word)<br>
<img src="https://lixin-scut.github.io//post-images/1584707754499.png" alt=""></p>
<h3 id="控制">控制</h3>
<p>  c 语言中的某些结构，比如条件语句、循环语句和分支语句，要求有条件的执行，根据数 据测谥的结果来决定操作执行的顺序。机器代码提供两种基本的低级机制来实现有条件的 行为:测试数据值，然后根据测试的结果来改变控制流或者数据流。<br>
  用 jump 指令可以改变一组机器代码指令的执行顺序，jump 指令指定控制应该被 传递到程序的某个其他部分，可能是依赖于某个测试的结果。编译器必须产生构建在这种 低级机制基础之上的指令序列，来实现 C 语言的控制结构。</p>
<p><strong>条件码</strong><br>
  除了整数寄存器，CPU还维护着一组单个位的条件码(conditioncode)寄存器，它们 描述了最 近的算术或逻辑操作的属性。可以检测这些寄存器来执行条件分支指令。最常用的条件码有:</p>
<ul>
<li>CF:进位标志。最近的操作使最高位产生了进位。可用来检查无符号操作的溢出。</li>
<li>ZF:零标志。最近的操作得出的结果为 0。</li>
<li>SF:符号标志。最近的操作得到的结果为负数。</li>
<li>OF:溢出标志。最近的操作导致一个补码溢出一正溢出或负溢出。</li>
</ul>
<p>  对于算术操作命令，leaq 指令不改变任何条件码，因为它是用来进行地址计算的。其他所有算术操作命令指令都会设置条件码。<br>
  对于逻辑操作，例如 XOR,进位标志和溢出标志会设 置成 0。对于移位操作， 进位标志将设置为最后一个被移出的位，而溢出标志设置为 0。 INC 和 DEC 指令会设置溢出和零标志，但是不会改变进位标志</p>
<p>  还有两类指令指令会设置条件码， 它们只设置条件码而不改变任 何其他寄存器;CMP 指令根据两个操作数之差来设置条件码。 除了只设置条件码 而不更新目的寄存器 之外，CMP指令与SUB 指令的行为是一样的。<br>
   如果两个操作数相等，这些指令会将零 标 志设置为 1,而其他的标志可以用来确定 两 个操作数之间的大小关系。TEST 指令的行为与 AND 指令一样，除了它们只设置条件码而不改变目的寄存器的值。<br>
<img src="https://lixin-scut.github.io//post-images/1584708146621.png" alt=""></p>
<p><strong>访问条件码</strong><br>
  条件码通常不会直接读取，常用的使用方法有三种:</p>
<ol>
<li>可以根据条件码的某种组合, 将一个字节 设置为 0 或者 1，</li>
<li>可以条件跳转到程序的某个其他的部分，</li>
<li>可以有条件地传送数据。<br>
  SET 指令指令根据条件码的某种组合，将一个字节 设置为0或者1。<br>
  它们之间的区别就在于它们考虑的条件码的组合是什么，这些指令名字的不同后缀指明了它们所考虑的条件码的组合。这些<strong>指令的后缀表示不同的条件而不是操作数大小</strong><br>
<img src="https://lixin-scut.github.io//post-images/1584708212499.png" alt=""></li>
</ol>
<p><strong>跳转指令</strong><br>
  正常执行的情况下，指令按照它们出现的顺序一条一条地执行。跳转(jump)指令会导 致执行切 换到程序中一个全新的位置。<br>
  在汇编代码中，这些跳转的目的地通常用一个标号(label)指明。<br>
  在产生目标代码文件时，汇编器会确定所有带标号指令的地址，并将跳转目标(目的指令的地址)编码为跳转指令的一部分。<br>
  间接跳转的写法是'* '后面跟一个操作数指示符<br>
  指令<code>jmp *%rax</code>用寄存器%rax 中的值作为跳转目标，<br>
  而指令<code>jmp *(%rax)</code>以%rax中的值作为读地址，从内存中读出跳转目标。<br>
<img src="https://lixin-scut.github.io//post-images/1584708984395.png" alt=""><br>
  表中所示的其他跳转指令都是有条件的——它们根据条件码的某种组合，或者跳转， 或者继续执行代码序列中下一条指令。这些指令的名字和跳转条件与 SET 指令的名字和设置条件是相匹配的。同 SET 指令一样，一些底层的机器指令有多个名字。 条件跳转只能是直接跳转。<br>
  当执行 PC 相对寻址时，程序计数器的值是跳转指令后面的那条指令 的地址， 而不是跳转指令本身的地址。这种惯例可以追溯到早期的实现，当时的处理器会 将更新程序计数器 作为执行一条指令的第一步。</p>
<p><strong>用条件传送来实现条件分支</strong><br>
  实现条件操作的传统方法是通过使用控制的条件转移。当条件满足时，程序沿着一条执行路径执行，而当条件不满足时，就走另一条路径。这种机制简单而通用，但是在现代处理器上，它可能会非常低效。<br>
  一种替代的策略是使用数据的条件转移。这种方法计算一个条件操作的两种结果，然 后再根据 条件是否满足从中选取一个。只有在一些受限制的情况中，这种策略才可行，但 是如果可行，就可 以用一条简单的条件传送指令来实现它，条件传送指令更符合现代处理 器的性能特性。<br>
<img src="https://lixin-scut.github.io//post-images/1584710289476.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1584710367200.png" alt=""><br>
  不是所有的条件表达式都可以用条件传送来编译。最重要的是，无论测试结果如何， 我们给出的抽象代码会对 then-expr 和 else-expr 都求值。如果这两个表达式中的任意一个可能产生错误条件或 者副作用，就会导致非法的行为。<br>
  使用条件传送也不总是会提高代码的效率。例如，如果 then-expr 或者 else-expr 的求值需要大量的计算，那么当相对应的条件不满足时，这些工作就白费了。编译器必须考虑 浪费的计算和由于分支预测错误所造成的性能处罚之间的相对性能。<br>
  条件数据传送提供了一种用条件控制转移来实现条件操作的替代策 略。它们只能用于非常受限制的情况，但是这些情况还是相当常见的，而且与现代处理器的运行方式更契合。</p>
<p><strong>循环</strong><br>
  汇编中没有相应的指令 存在，可以用条 件测试和跳转组合起来实现循环的效果。<br>
<strong>do-while 循环</strong><br>
do-while 语句的通用形式如下:</p>
<pre><code>do
		body-statement 
while (test-expr);
</code></pre>
<p>  这个循环的效果就是重复执行 body-statement,对 testrexpr 求值，如果求值的结果为非零，就继续循环。可以看到，body-statement 至少会执行一次。<br>
<img src="https://lixin-scut.github.io//post-images/1584711646950.png" alt=""><br>
  n在寄存器%rdi中传递给函数。可以看到寄存器%rax初始化为1。注意，虽然指令的目的寄存器是%eax,它实际上还会把%rax 的高 4 字节设置为 0。还可以看 到这个寄存器还会在第 4 行被乘法改变值。此外，%rax 用来返回函数值，所以通常会用来存放需要返回的程序值。因此我们断定%rax 对应程序值 result</p>
<p><strong>while 循环</strong><br>
  与 do-while 的不同之处在于，在第一次执行 body-statement 之前，它会对 test-expr 求值，循环有可能就中止了。<br>
  第一种翻译方法，我们称之为跳转到中间(jump to middle),它执行一个无条件跳转 跳到循环结尾处的测试，以此来执行初始的测试。</p>
<pre><code>		goto test; 
loop:
		body-statement
test:
		t = test-expr;
		if (t)
				goto loop;
</code></pre>
<p>  比较 fact_while和 fact_do的代码，可以看到它们非常相似，区别 仅在于循环前的gototest语句使得程序在修改 result或n的值之前，先执行对n的测试。</p>
<p>  第二种翻译方法，我们称之为 guarded-do,首先用条件分支，如果初始条件不成立就 跳过循环，把代码变 换为do-while循环。</p>
<p><strong>for 循环</strong><br>
  for 循环的通用形式如下:</p>
<pre><code>for (init-expr; test-expr; up date-exp r)
		body-statement
</code></pre>
<p>  这样一个循环的行为与下面 这段使用 while 循环的代码的行为一样:</p>
<pre><code>init-expr;
while (.test-expr) 
{ 
		body-statement
		update-expr;
}
</code></pre>
<p>  程序首先对初始表达式 init-expr 求值，然后进入循环;<br>
  GCC 为 for 循环产生的代码是 while 循环的两种翻译之一，这取决于优化的等级。</p>
<p>  综上所述，C 语言中三种形式的所有的循环 do-while、while 和 for 都可以 用一种简单的策略来翻译，产生包含一个或多个条件分支的代码。控制的条件转移提供了 将循环翻译成机器代码的基本 机制。</p>
<p><strong>switch 语句</strong><br>
  switch(开关)语句可以根据一个整数索引值进行多重分支(multiway branching)<br>
  通过使用跳转表 (jump table)这种数据结构使得实现更加高效。<br>
  跳转表是一个数组， 表项 i 是一个代码段的地址，这个 代码段实现当开关索引值等于 z 时程序应该采取的动作。 程序代码用开关索引值来执行一个跳转表内的数组引用，确定跳转指令的目标。和使用一组很长的 if-else 语句相比，使用跳转表的优点是执 行开关语句的时间与开关情况的数 量无关。<br>
<img src="https://lixin-scut.github.io//post-images/1584712102714.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1584712211543.png" alt=""></p>
<h3 id="过程">过程</h3>
<p>  过程是软件中一种很重要的抽象。它提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能。然后，可以在程序中不同的地方调用这个函数。设计良好的软件用过程作为抽象机制，隐藏某个行为的具体实现，同时又提供清晰简洁的接口定义，说明要计算的是哪些值，过程会对程序状态产生什么样的影响。<br>
  不同编程语言中，过程的形式多样:函数(function),方 法(method)、子例程(subroutine)、处理函数(handler)等等，但是它们有一些共有的特性。<br>
  要提供对过程的机器级支持，必须要处理许多不同的属性。这些动作包括下面一个或多个机制:</p>
<ol>
<li>传递控制。在进入过程 Q 的时候，程序计数器必须被设置为 Q 的代码的起始地址，然 后在返 回时，要把程序计数器设置为 P 中调用 Q 后面那条指令的地址。</li>
<li>传递数据。P 必须能够向 Q 提供一个或多个参数，Q 必须能够向 P 返回一个值。</li>
<li>分配和释放内存。在开始时，Q可能需要为局部变量分配空间，而在返回前，又必须 释放这些 存储空间。</li>
</ol>
<p><strong>运行时栈</strong><br>
  C语言过程调用机制的一个关键特性在于使用了栈数据结构提供的后进先出的内存管理原则<br>
  在过程P调用过程Q的例子中，可以看到当Q在执行时，P以及所有在向上追溯到P的调用链中的过程，都是暂时被挂起的。当Q运行时，它只需要为局部变量分配新的存储空间，或者设置到另一个过程的调用。<br>
  另一方面，当Q返回时，任何它所分配的局部存储空间都可以被释放。因此，程序可以用栈来管理它的过程所需要的存储空间，栈和程序寄存器存放着传递控制和数据、分配内存所需要的信息。<br>
x86-64的栈向低地址方向增长，而栈指针%rsp指向栈顶元素。<br>
当X86-64过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。这个部分称为过程的栈帧(stackfram)<br>
<img src="https://lixin-scut.github.io//post-images/1584785872848.png" alt=""><br>
  给出了运行时栈的通用结构，包括把它划分为栈帧。当前正在执行的过程的帧总是在栈顶。<br>
  当过程P调用过程Q时，会把返回地址压入栈中，指明当Q返回时，要从P程序的哪个位置继续执行。我们把这个返回地址当做P的栈帧的一部分，因为它存放的是与P相关的状态。<br>
  Q的代码会扩展当前栈的边界，分配它的栈帧所需的空间。在这个空间中，它可以保存寄存器的值，分配局部变量空间，为它调用的过程设置参数。<br>
  大多数过程的栈帧都是定长的，在过程的开始就分配好了。<br>
  通过寄存器，过程P可以传递最多6个整数值(也就是指针和整数)，但是如果Q需要更多的参数，P可以在调用Q之前在自己的栈帧里存储好这些参数。<br>
  许多过程有6个或者更少的参数，那么所有的参数都可以通过寄存器传递。实际上，许多函数甚至根本不需要栈帧。当所有的局部变量都可以保存在寄存器中，而且该函数不会调用任何其他函数</p>
<p><strong>转移控制</strong><br>
  将控制从函数P转移到函数Q只需要简单地把程序计数器(PC)设置为Q的代码的起始位置。不过，当稍后从Q返回的时候，处理器必须记录好它需要继续P的执行的代码位置。<br>
  用指令callQ调用过程Q。该指令会把地址A压入栈中，并将PC设置为Q的起始地址。压入的地址A被称为返回地址，是紧跟在call指令后面的那条指令的地址。<br>
<img src="https://lixin-scut.github.io//post-images/1584786069357.png" alt=""></p>
<p><strong>数据传送</strong><br>
  当调用一个过程时，除了要把控制传递给它并在过程返回时再传递回来之外，过程调用还可能包括把数据作为参数传递，而从过程返回还有可能包括返回一个值。<br>
  X86-64中，大部分过程间的数据传送是通过寄存器实现的<br>
  X86-64中，可以通过寄存器最多传递6个整型(例如整数和指针)参数。寄存器的使用是有特殊顺序的，寄存器使用的名字取决于要传递的数据类型的大小，会根据参数在参数列表中的顺序为它们分配寄存器。<br>
<img src="https://lixin-scut.github.io//post-images/1584786166666.png" alt=""><br>
  如果一个函数有大于6个整型参数，超出6个的部分就要通过栈来传递。<br>
  把参数1〜6复制到对应的寄存器，把参数7〜n放到栈上，而参数7位于栈顶。通过栈传递参数时，所有的数据大小都向8的倍数对齐。参数到位以后，程序就可以执行call指令将控制转移到过程Q了。过程Q可以通过寄存器访问参数，有必要的话也可以通过栈访问。相应地，如果Q也调用了某个有超过6个参数的函数，它也需要在自己的栈帧中为超出6个部分的参数分配空间</p>
<p><strong>栈上的局部存储</strong><br>
  有些时候，局部数据必须存放在内存中，常见的情况包括:</p>
<ul>
<li>寄存器不足够存放所有的本地数据。</li>
<li>对一个局部变量使用地址运算符因此必须能够为它产生一个地址。</li>
<li>某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到。</li>
</ul>
<p><strong>寄存器中的局部存储空间</strong><br>
  寄存器组是唯一被所有过程共享的资源。虽然在给定时刻只有一个过程是活动的，我们仍然必须确保当一个过程(调用者)调用另一个过程(被调用者)时，被调用者不会覆盖调用者稍后会使用的寄存器值。<br>
  为此，x86-64采用了一组统一的寄存器使用惯例，所有的过程(包括程序库)都必须遵循：<br>
  寄存器%rbx、%rbp和%r12〜%r15被划分为被调用者保存寄存器。当过程P调用过程Q时，Q必须保存这些寄存器的值，保证它们的值在Q返回到P时与Q被调用时是一样的。过程Q保存一个寄存器的值不变，要么就是根本不去改变它，要么就是把原始值压入栈中，改变寄存器的值，然后在返回前从栈中弹出旧值。<br>
  压入寄存器的值会在栈帧中创建标号为“保存的寄存器”的一部分。有了这条惯例，P的代码就能安全地把值存在被调用者保存寄存器中(当然，要先把之前的值保存到栈上)，调用Q，然后继续使用寄存器中的值，不用担心值被破坏。<br>
  所有其他的寄存器，除了栈指针%rsp,都分类为调用者保存寄存器。这就意味着任何函数都能修改它们。可以这样来理解“调用者保存”这个名字:过程P在某个此类寄存器中有局部数据，然后调用过程Q。因为Q可以随意修改这个寄存器，所以在调用之前首先保存好这个数据是P(调用者)的责任。</p>
<p><strong>递归过程</strong><br>
  递归调用一个函数本身与调用其他函数是一样的。栈规则提供了一种机制，每次函数调用都有它自己私有的状态信息(保存的返回位置和被调用者保存寄存器的值)存储空间。如果需要，它还可以提供局部变量的存储。栈分配和释放的规则很自然地就与函数调用-返回的顺序匹配。这种实现函数调用和返回的方法甚至对更复杂的情况也适用，包括相互递归调用</p>
<p><strong>指针运算</strong><br>
<img src="https://lixin-scut.github.io//post-images/1584791906137.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[上下文切换]]></title>
        <id>https://lixin-scut.github.io//post/shang-xia-wen-qie-huan</id>
        <link href="https://lixin-scut.github.io//post/shang-xia-wen-qie-huan">
        </link>
        <updated>2020-03-19T08:50:57.000Z</updated>
        <content type="html"><![CDATA[<h3 id="linux进程控制">Linux进程控制</h3>
<ul>
<li>进程地址空间（地址空间）<br>
  虚拟内存机制为每个进程提供了独占系统地址空间的假象。尽管每个进程地址空间内容不尽相同，但是他们的都有相似的结构。Linux进程的地址空间底部是保留给用户程序的，包括文本、数据、堆、栈等，其中文本区和数据区是通过存储器映射方式将磁盘中可执行文件的相应段映射至虚拟存储器地址空间中。<br>
  有一些&quot;敏感&quot;的地址需要注意下，从0xC0000000开始到0xFFFFFFFF是内核地址空间，通常情况下代码运行在用户态（使用0x00000000 ~ 0xC00000000的用户地址空间，对于32位进程来说，代码段从0x08048000开始），当发生系统调用、进程切换等操作时CPU控制寄存器设置模式位，进入内核模式，在该状态下进程可以访问全部存储器位置和执行全部指令。也就说32位进程的地址空间都是4G，但用户态下只能访问低3G的地址空间，若要访问3G ~ 4G的地址空间则只有进入内核态。</li>
<li>进程控制块（处理机）<br>
  进程的调度实际就是内核选择相应的进程控制块，被选择的进程控制块中包含了一个进程基本的信息。</li>
<li>上下文切换<br>
  内核管理所有进程控制块，而进程控制块记录了进程全部状态信息。每一次进程调度就是一次上下文切换，所谓的上下文本质上就是当前运行状态，主要包括通用寄存器、浮点寄存器、状态寄存器、程序计数器、用户栈和内核数据结构（页表、进程表、文件表）等。进程执行时刻，内核可以决定抢占当前进程并开始新的进程，这个过程由内核调度器完成，当调度器选择了某个进程时称为该进程被调度，该过程通过上下文切换来改变当前状态。一次完整的上下文切换通常是进程原先运行于用户态，之后因系统调用或时间片到切换到内核态执行内核指令，完成上下文切换后回到用户态，此时已经切换到进程B。</li>
</ul>
<h3 id="线程与进程">线程与进程</h3>
<p>  操作系统管理很多进程的执行。有些进程是来自各种程序、系统和应用程序的单独进程，而某些进程来自被分解为很多进程的应用或程序。当一个进程从内核中移出，另一个进程成为活动的，这些进程之间便发生了上下文切换。操作系统必须记录重启进程和启动新进程使之活动所需要的所有信息。这些信息被称作上下文，它描述了进程的现有状态。当进程成为活动的，它可以继续从被抢占的位置开始执行。<br>
进程的上下文信息包括：</p>
<ul>
<li>进程id</li>
<li>指向可执行文件的指针</li>
<li>栈</li>
<li>静态和动态分配的变量的内存</li>
<li>处理器寄存器<br>
等等</li>
</ul>
<p>  进程的上下文的多数信息都与地址空间的描述有关。进程的上下文使用很多系统资源，而且会花费一些时间来从一个进程的上下文切换到另一个进程的上下文。</p>
<p>  线程也有上下文。当线程被抢占时，就会发生线程之间的上下文切换。如果线程属于相同的进程，它们共享相同的地址空间，因为线程包含在它们所属于的进程的地址空间内。这样，进程需要恢复的多数信息对于线程而言是不需要的。尽管进程和它的线程共享了很多内容，但最为重要的是其地址空间和资源，有些信息对于线程而言是本地且唯一的，而线程的其他方面包含在进程的各个段的内部。</p>
<table>
<thead>
<tr>
<th style="text-align:center">上下文内容</th>
<th style="text-align:center">进    程</th>
<th style="text-align:center">线    程</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">指向可执行文件的指针</td>
<td style="text-align:center">●</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">栈</td>
<td style="text-align:center">●</td>
<td style="text-align:center">●</td>
</tr>
<tr>
<td style="text-align:center">内存(数据段和堆)</td>
<td style="text-align:center">●</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">状态</td>
<td style="text-align:center">●</td>
<td style="text-align:center">●</td>
</tr>
<tr>
<td style="text-align:center">优先级</td>
<td style="text-align:center">●</td>
<td style="text-align:center">●</td>
</tr>
<tr>
<td style="text-align:center">程序I/O的状态</td>
<td style="text-align:center">●</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">授予权限</td>
<td style="text-align:center">●</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">调度信息</td>
<td style="text-align:center">●</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">审计信息</td>
<td style="text-align:center">●</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">有关资源的信息-文件描述符-读/写指针</td>
<td style="text-align:center">●</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">有关事件和信号的信息</td>
<td style="text-align:center">●</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">寄存器组 -栈指针 -指令计数器 -诸如此类</td>
<td style="text-align:center">●</td>
<td style="text-align:center">●</td>
</tr>
</tbody>
</table>
<p>  对线程唯一或本地的信息包括线程id、处理器寄存器(当线程执行时寄存器的状态，包括程序计数器和栈指针)、线程状态及优先级、线程特定数据(thread-specific data，TSD)。线程id是在创建线程时指定的。线程能够访问它所属进程的数据段，因此线程可以读写它所属进程的全局声明数据。进程中一个线程做出的任何改动都可以被进程中的所有线程以及主线程获得。在多数情况下，这要求某种类型的同步以防止无意的更新。线程的局部声明变量不应当被任何对等线程访问。它们被放置到线程栈中，而且当线程完成时，它们便会被从栈中移走。</p>
<p>  TSD是一种结构体，包含线程私有的数据和信息。TSD可以包含进程全局数据的私有副本，还可以包含线程的信号掩码。信号掩码用来识别特定类型的信号，这些信号在发送给进程时不会被该线程接收。否则，如果操作系统给进程发送一个信号，进程的地址空间中的所有线程也会接收到那个信号。线程会接收所有没有被掩码遮蔽的信号。</p>
<p>  线程与它所属的进程共享代码段和栈段。它的指令指针指向进程的代码段的某个位置，是下一条可执行的线程指令，而且栈指针指向进程栈中线程的栈的顶部位置。线程还可以访问任何环境变量。进程的所有资源(例如文件描述符)都将与线程共享。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[pthread_once()]]></title>
        <id>https://lixin-scut.github.io//post/pthread_once</id>
        <link href="https://lixin-scut.github.io//post/pthread_once">
        </link>
        <updated>2020-03-19T01:24:52.000Z</updated>
        <content type="html"><![CDATA[<p>  在多线程环境中，有些事仅需要执行一次。通常当初始化应用程序时，可以比较容易地将其放在main函数中。但当写一个库时，就不能在main里面初始化了，此时可以用静态初始化，但使用一次初始化（pthread_once）会比较容易些。</p>
<pre><code>pthread_once_t once_control = PTHREAD_ONCE_INIT;
int pthread_once(pthread_once_t *once_control, void (*init_routine) (void))；
</code></pre>
<p><strong>功能：</strong><br>
  本函数使用初值为PTHREAD_ONCE_INIT的once_control变量保证init_routine()函数在本进程执行序列中仅执行一次。<br>
  在多线程编程环境下，尽管pthread_once()调用会出现在多个线程中，init_routine()函数仅执行一次，究竟在哪个线程中执行是不定的，是由内核调度来决定。</p>
<p><strong>底层：</strong><br>
  Linux Threads使用互斥锁和条件变量保证由pthread_once()指定的函数执行且仅执行一次，而once_control表示是否执行过。<br>
  如果once_control的初值不是PTHREAD_ONCE_INIT（Linux Threads定义为0），pthread_once() 的行为就会不正常。<br>
  在LinuxThreads中，实际&quot;一次性函数&quot;的执行状态有三种：NEVER（0）、IN_PROGRESS（1）、DONE （2），如果once初值设为1，则由于所有pthread_once()都必须等待其中一个激发&quot;已执行一次&quot;信号，因此所有pthread_once()都会陷入永久的等待中；如果设为2，则表示该函数已执行过一次，从而所有pthread_once()都会立即返回0。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[调度]]></title>
        <id>https://lixin-scut.github.io//post/diao-du</id>
        <link href="https://lixin-scut.github.io//post/diao-du">
        </link>
        <updated>2020-03-18T09:32:53.000Z</updated>
        <content type="html"><![CDATA[<p>  当计算机系统是多道程序设计系统时，通常就会有多个进程或线程同时竞争CPU。只要有两个或更多的进程处于就绪状态，如果只有一个CPU可用，那么就必须选择下一个要运行的进程。在操作系统中，完成选择工作的这一部分称为调度程序（scheduler）,该程序使用的算法称为调 度算法（scheduling algorithm）。</p>
<p>  进程切换的代价是比较高的。<br>
  首先用户态必须切换到内核态，然后要保存当前进程的状态，包括在进程表中存储寄存器值以便以 后重新装载。在许多系统中，内存映像（例如，页表内的内存访问位）也必须保存，<br>
  接着，通过运行调 度算法选定一个新进程之后，应该将新进程的内存映像重新装入MMU,最后新进程开始运行。<br>
  除此 之外，进程切换还要使整个内存高速缓存失效，强迫缓存从内存中动态重新装入两次（进入内核一次， 离开内核一次）。<br>
  总之，如果每秒钟切换进程的次数太多，会耗费大量CPU时间，所以有必要提醒注意。</p>
<p><strong>进程行为</strong><br>
  某些进程花费了绝大多数时间在计算上，而 其他进程则在等待I/O上花费了绝大多数时间。前者称为计算密集型（compute-bound）, 后者称为I/O密集型（I/O-bound）。<br>
  典型的计算密集型进程具有较长时间的CPU集中使用和较小频度的 I/O等待。 I/O密集型进程具有较短时间的CPU集中使用和频繁的I/O等待。它是I/O类的，因为这种进程 在I/O请求之间较少进行计算，并不是因为它们有转别长的I/O请求。在I/O开始后无论处理数据是多还是少，它们都花费同样的时间提出硬件请求读取磁盘块。</p>
<p><strong>何时调度</strong><br>
  第一，在创建一个新进程之后，需要决定是运行父进程还是运行子进程。由于这两种进程都处于就绪状态，所以这是一 种正常的调度决策，可以任意决定，也就是说，调度程序可以合法选择先运行父进程还是先运行子进程。<br>
  第二，在一个进程退出时必须做出调度决策。一个进程不再运行（因为它不再存在），所以必须从 就绪进程集中选择另外某个进程。如果没有就绪的进程，通常会运行一个系统提供的空闲进程。<br>
  第三，当一个进程阻塞在I/O和信号最上或由于其他原因阻塞时，必须选择另一个进程运行。<br>
  第四，在一个I/O中断发生时，必须做出调度决策。如果中断来自I/O设备，而该设备现在完成了工作，某些被阻塞的等待该I/O的进程就成为可运行的就绪进程。是否让新就绪的进程运行，这取决于 调度程序的决定，或者让中断发生时运行的进程继续运行，或者应该让某个其他进程运行。</p>
<p><strong>调度算法分类</strong><br>
根据如何处理时钟中断，可以把调度算法分为两类。<br>
  非抢占式调度算法挑选一个进 程，然后让该进程运行直至被阻塞（阻塞在I/O上或等待另一个进程），或者直到该进程自动释放CPU。 即使该进程运行了若干个小时，它也不会被强迫挂起。这样做的结果是，在时钟中断发生时不会进行调 度。在处理完时钟中断后，如果没有更高优先级的进程等待到时，则被中断的进程会继续执行。<br>
  相反，抢占式调度算法挑选一个进程，并且让该进程运行某个固定时段的最大值。如果在该时段结 束时，该进程仍在运行，它就被挂起，而调度程序挑选另一个进程运行（如果存在一个就绪进程）。进 行抢占式调度处理，需要在时间间隔的末端发生时钟中断，以便把CPU控制返回给调度程序。如果没有 可用的时钟，那么非抢占式调度就是惟一的选择了。</p>
<p><strong>调度算法分类</strong><br>
在不同的系统中，调度程序的优化是不同的。这里有必要 划分出三种环境：<br>
1）	批处理。<br>
2）	交互式。<br>
3）	实时。</p>
<p><strong>调度算法的目标</strong><br>
<img src="https://lixin-scut.github.io//post-images/1584525112161.png" alt=""></p>
<p><strong>策略和机制</strong><br>
  将调度机制（scheduling mechanism）与调度策略（scheduling policy）分离，也就是将调度算法以某种形式参数化，而参数可以由用户进程填写。</p>
<p><strong>线程调度</strong><br>
  当若干进程都有多个线程时，就存在两个层次的并行：进程和线程。在这样的系统中调度处理有本 质差别，这取决于所支持的是用户级线程还是内核级线程（或两者都支持）。<br>
  首先考虑用户级线程。由于内核并不知道有线程存在，所以内核还是和以前一样地操作，选取一个进程，并给予时间片控制。进程中的线程调度程序决定哪个线程运行。由于多 道线程并不存在时钟中断，所以这个线程可以按其意愿任意运行多长时间。如果该线程用完了进程的全 部时间片，内核就会选择另一个进程运行。<br>
  在进程终于又一次运行时，线程会接着运行。该线程会继续耗费进程的所有时间片，直到它完成工作。不过，该线程的这种不合群的行为不会影响到其他的进程。其他进程会得到调度程序所分配的 合适份额，不会考虑进程内部所发生的事。<br>
<img src="https://lixin-scut.github.io//post-images/1584525832250.png" alt=""><br>
  现在考虑使用内核级线程的情形。内核选择一个特定的线程运行。它不用考虑该线程属于哪个进程， 不过如果有必要的话，它可以这样做。对被选择的线程赋予一个时间片，而旦如果超过了时间片，就会 强制挂起该线程。</p>
<p><strong>内核线程与用户线程调度的区别</strong><br>
用户级线程和内核级线程之间的差别在于性能。用户级线程的线程切换需要少量的机器指令，而内核级线程需要完整的上下文切换，修改内存映像，使高速缓存失效，这导致了若干数量级的延退。<br>
  从进程A的一个线程切换到进程B的一个线程，其代价高于运行进程A的第2个线程（因为必须修改 内存映像，清除内存高速缓存的内容），内核对此是了解的，并可运用这些信息做出决定。例如，给定两个在其他方面同等重要的线程，其中一个线程与刚好阻塞的线程属于同一个进程，而另一个线程属于 其他的进程，那么应该倾向前者。<br>
  另一个重要因素是用户级线程可以使用专为应用程序定制的线程调度程序。由于运行系统了解所有线程的作用，所以会直接选择分派线程接着运行，这样分派线程就会启动另一个工作线程运行。在一个工作线程经常阻塞在磁盘I/O上的环境中，这个策略将并行度最大化。 而在内核级线程中，内核从来不了解每个线程的作用（虽然它们被赋予了不同的优先级）。不过，一般而言，应用定制的线程调度程序能够比内核更好地满足应用的需要。</p>
<p><strong>批处理系统中的调度</strong></p>
<ol>
<li>先来先服务<br>
  最简单的是非抢占式的先来先服务(first-come first-severd)算法。使用该算 法，进程按照它们请求CPU的顺序使用CPU。基本上，有一个就绪进程的单一队列。</li>
<li>最短作业优先<br>
  适用于运行时间可以预知的另一个非抢占式的批处理调度算法。</li>
<li>最短剩余时间优先<br>
  最短作业优先的抢占式版本是景短剩余时间优先(shortest remaining time next)算法。使用这个算 法，调度程序总是选择剩余运行时间最短的那个进程运行。再次提醒，有关的运行时间必须提前掌握。 当一个新的作业到达时，其整个时间同当前进程的剩余时间做比较。如果新的进程比当前运行进程需要 更少的时间，当前进程就被挂起，而运行新的进程。</li>
</ol>
<p><strong>交互式系统中的调度</strong><br>
  现在考察用于交互式系统中的一些调度算法，它们在个人计算机、服务器和其他类系统中都是常用的。</p>
<ol>
<li>轮转调度<br>
  一种最古老、最简单、最公平且使用最广的算法是轮转调度(round robin)。每个进程被分配一个 时间段，称为时间片(quantum),即允许该进程在该时间段中运行。如果在时间片结束时该进程还在运 行，则将剥夺CPU并分配给另一个进程。如果该进程在时间片结束前阻塞或结束，则CPU立即进行切换。当一 个进程用完它的时间片后，就被移到队列的末尾<br>
  时间片轮转调度中惟一有趣的一点是时间片的长度。CPU时间的20%浪费在管理开 销上。<br>
  时间片设得太短会导致过多的进程切换，降低了CPU效率，而设得太长又可能 引起对短的交互请求的响应时间变长。将时间片设为20ms~50 ms通常是一个比较合理的折中。</li>
<li>优先级调度<br>
  轮转调度做了一个隐含的假设，即所有的进程同等重要，但外部因素考虑在内的需要就导致了优先级调度。其基本思想很清楚：每个进程被赋予一个优先级，允许优先级最高的可运行进程先运行。<br>
  为了防止高优先级进程无休止地运行下去，调度程序可以在每个时钟滴答(即每个时钟中断)降低 当前进程的优先级。如果这个动作导致该进程的优先级低于次高优先级的进程，则进行进程切换。一个可采用的方法是，每个进程可以被赋予一个允许运行的最大时间片，当这个时间片用完时，下一个次高 优先级的进程获得机会运行。<br>
  优先级可以是静态赋予或动态赋予。如果不偶尔对优先级进行调整，则低优先级 进程很可能会产生饥饿现象。</li>
<li>多级队列<br>
  如前所述，长时间片的进程又会影响到响应时间，其解决办法是设立优先级类。属于最高优先级类的进程运行一个时间片，属于次高优先级类的进程运行2个时间片，再次一级运行4个时间片，以此类推。当一个进程用完分配的时间片后，它被移到下一类。</li>
<li>最短进程优先</li>
<li>保证调度</li>
<li>彩票调度</li>
<li>公平分享调度</li>
</ol>
<p><strong>实时系统中的调度</strong><br>
  实时系统通常可以分为硬实时（hard real time）和软实时（soft real time）,前者的含义是必须满足绝对的截止时间，后者的含义是虽然不希望偶尔错失截止时间，但是可以容忍。<br>
  实时系统中的事件可以按照响应方式进一步分类为周期性（以规则的时间间隔发生）事件或非周期 性（发生时间不可预知）事件。<br>
  实时系统使用的调度算法可以是上面介绍的算法中的任意一种。从实用考虑，轮转调度和优先级调度更为常用。惟一的局限是，缺乏一个时钟将运行过长的线程加以中断。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用户态和内核态]]></title>
        <id>https://lixin-scut.github.io//post/yong-hu-tai-he-nei-he-tai</id>
        <link href="https://lixin-scut.github.io//post/yong-hu-tai-he-nei-he-tai">
        </link>
        <updated>2020-03-18T08:35:09.000Z</updated>
        <content type="html"><![CDATA[<h3 id="用户态和内核态">用户态和内核态</h3>
<p>  当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核代码中执行。<br>
  当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。当进程在执行用户自己的代码时，则称其处于用户运行态（用 户态）。即此时处理器在特权级最低的（3级）用户代码中运行。<br>
  用户运行一个程序，该程序所创建的进程开始是运行在用户态的，如果要执行文件操作，网络数据发送等操作，必须通过write，send等系统调用，这些系统调用会调用内核中的代码来完成操作，这时，必须切换到Ring0，然后进入3GB-4GB中的内核地址空间去执行这些代码完成操作，完成后，切换回Ring3，回到用户态。这样，用户态的程序就不能 随意操作内核地址空间，具有一定的安全保护作用。</p>
<h3 id="区分内核态和用户态的原因">区分内核态和用户态的原因</h3>
<p>  在CPU中运行的操作系统程序和用户程序对应的机器指令集是不同的。操作系统程序使用所有指令，但用户程序只能使用部分指令。从资源管理和程序控制执行的角度出发，将指令系统分为两大部分：特权指令和非特权指令。在程序执行时，根据执行程序对资源和机器指令的使用权限，把机器设置为两个状态：内核态和用户态。<br>
  避免代码进行潜在危险的操作，以防止给操作系统带来安全隐患。系统调用与返回的情况下进行两种方式的转换。<br>
  用户态状态下，执行的代码被硬件限定，不能进行某些操作，比如写入其他进程的存储空间，以防止给操作系统带来安全隐患。内核禁止此状态下的代码进行潜在危险的操作，比如写入系统配置文件、杀掉其他用户的进程、重启系统等。</p>
<h3 id="用户态切换到内核态的3种方式">用户态切换到内核态的3种方式：</h3>
<ol>
<li>系统调用<br>
这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。</li>
<li>异常<br>
当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</li>
<li>外围设备的中断<br>
当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</li>
</ol>
]]></content>
    </entry>
</feed>