<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-03-04T05:25:01.239Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>In the darkest night,Rising like a spire.</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[快速排序]]></title>
        <id>https://lixin-scut.github.io//post/kuai-su-pai-xu</id>
        <link href="https://lixin-scut.github.io//post/kuai-su-pai-xu">
        </link>
        <updated>2020-03-04T03:03:04.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://lixin-scut.github.io/post/pai-xu-suan-fa/">排序算法及其实现</a></p>
<p>  快速排序应该是我用得最多的一个排序算法了，很早之前就实现过了，具体可以参考<a href="https://lixin-scut.github.io/post/kuai-su-pai-xu-fa-shi-xian/">快速排序法实现</a><br>
当然排版比较辣眼hhh，现在就当作整理和总结吧</p>
<p>  希尔排序相当于直接插入排序的升级，它们同属于插入排序类，堆排序相当于简单选择排序的升级，它们同属于选择排序类。而快速排序其实就是我们前面认为最慢的冒泡排序的升级，它们都属于交换排序类。它也是通过不断比较和移动交换来实现排序的，只不过它的实现，增大了记录的比较和移动的距离</p>
<p>  快速排序（QuickSort）的基本思想是：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序</p>
<pre><code>class QuickSort
{
public:
    void QuickSort0(vector&lt;int&gt; &amp;numbers);

private:
    void QuickSort0(vector&lt;int&gt; &amp;numbers, int beg, int end);
    int Partition(vector&lt;int&gt; &amp;numbers, int beg, int end);
};

void QuickSort::QuickSort0(vector&lt;int&gt; &amp;numbers)
{
    int length = numbers.size();
    QuickSort0(numbers, 0, length-1);
    print(numbers);
}

void QuickSort::QuickSort0(vector&lt;int&gt; &amp;numbers, int beg, int end)
{
    if(beg &lt; end)
    {
        int mid = Partition(numbers, beg, end);
        QuickSort0(numbers, beg, mid-1);
        QuickSort0(numbers, mid+1, end);
    }
}

int QuickSort::Partition(vector&lt;int&gt; &amp;numbers, int beg, int end)
{
        int pivotKey = numbers[beg];
        while(beg &lt; end)
        {
            while(beg &lt; end &amp;&amp; numbers[end] &gt;= pivotKey)
            { --end; }
           swap(numbers[beg] , numbers[end]);
            while(beg &lt; end &amp;&amp; numbers[beg] &lt;= pivotKey)
            { ++beg; }
            swap(numbers[beg] , numbers[end]);
        }
				return beg;
}
</code></pre>
<p>这里需要注意几点</p>
<ol>
<li>我使用下标法，所以可以mid-1、mid+1，迭代器就无法这么干，迭代器是不可以指向容器外的位置的，不能指向begin之前</li>
<li>比较时一定是 &gt;=和&lt;=，一定不能忘记判断等于，否则会陷入死循环</li>
<li>我其实做了一点优化，本来可以直接 <code>swap(numbers[beg] , numbers[end]);</code>，我直接把它留到了最后再赋值。</li>
<li>定义pivotKey，用于比较pivotkey&lt;=vi[high]</li>
<li>先--end再到++beg，不能弄反了</li>
<li>记得return beg;</li>
<li>每个while都必须判断low&lt;high，特别是循环中的两个while</li>
</ol>
<h3 id="快速排序复杂度分析">快速排序复杂度分析</h3>
<p>  快速排序的时间性能取决于快速排序递归的深度<br>
  在最优情况下，Partition每次都划分得很均匀，如果排序n个关键字，其递归树的深度就为floor(logn)+1，所以在最优的情况下，快速排序算法的时间复杂度为O(nlogn)<br>
  而在最坏的情况下，待排序的序列为正序或者逆序，每次划分只得到一个比上一次划分少一个记录的子序列（注意另一个为空，亦即只有左子树或者右子树）， 时间复杂度为O(n^2)。<br>
  空间复杂度来说，主要是递归造成的栈空间的使用，最好情况，递归树的深度为logn，其空间复杂度也就为O(logn)，最坏情况需要进行n-1次递归调用，其空间复杂度为〇(n),平均情况，空间复杂度也为〇(logn)。<br>
  由于关键字的比较和交换是跳跃进行的，因此，快速排序是一种不稳定的排序方法。</p>
<h3 id="优化">优化：</h3>
<ol>
<li>优化不必要的交换<br>
  关键字的最终目标就是beg==end的时候,当中的交换其实是不需要的。因此我们对Partition函数的代码再进行优化。</li>
</ol>
<pre><code>int QuickSort::Partition(vector&lt;int&gt; &amp;numbers, int beg, int end)
{
        int pivotKey = numbers[beg];
        while(beg &lt; end)
        {
            while(beg &lt; end &amp;&amp; numbers[end] &gt;= pivotKey)
            { --end; }
            numbers[beg] = numbers[end];
            while(beg &lt; end &amp;&amp; numbers[beg] &lt;= pivotKey)
            { ++beg; }
            numbers[end] = numbers[beg];
        }
        numbers[beg] = pivotKey;
        return beg;
}
</code></pre>
<ol start="2">
<li>优化选取枢轴<br>
  三数取中（median-of-three)法。即取三个关键字先进行排序，将中间数作为枢轴，一般是取左端、右端和中间三个数，也可以随机选取。这样至少这个中间数一定不会是最小或者最大的数<br>
  九数取中,它先从数组中分三次取样，每次取三个数，三个样品各取出中数，然后从这三个中数当中再取出一个中数作为枢轴。</li>
</ol>
<pre><code>        int pivotKey ;

        int mid = beg + (end - beg) / 2;

        if(numbers[beg] &gt; numbers[end])
        { swap(numbers[beg], numbers[end]); }
        if(numbers[mid] &gt; numbers[end])
        { swap(numbers[mid], numbers[end]); }
        if(numbers[mid] &gt; numbers[beg])
        { swap(numbers[beg], numbers[mid]); }
        
        pivotKey = numbers[beg];
</code></pre>
<ol start="3">
<li>
<p>优化小数组时的排序方案<br>
  如果数组非常小，其实快速排序反而不如直接插入排序来得更好（直接插入是简单排序中性能最好的）。其原因在于快速排序用到了递归操作.<br>
此处估计是参考了<a href="https://lixin-scut.github.io/post/stl-sortdi-ceng-shi-xian/">STL的sort()</a>影响hhh，但是这个数组长度阈值不好确定，得参考实际情况</p>
</li>
<li>
<p>优化递归操作<br>
  QSort函数在其尾部有两次递归操作。如果待排序的序列划分极端不平衡，递归深度将趋近于n,而不是平衡时的logn（也就是每次都只取到边界值为pivotKey）<br>
  栈的大小是很有限的，每次递归调用都会耗费—定的栈空间，函数的参数越多，每次递归耗费的空间也越多。因此如果能减少递归，将会大大提高性能。</p>
</li>
</ol>
<pre><code>void QuickSort::QuickSort0(vector&lt;int&gt; &amp;numbers, int beg, int end)
{
    if(beg &lt; end)
    {
        while(beg &lt; end){
            int mid = Partition(numbers, beg, end);
            QuickSort0(numbers, beg, mid-1);
            beg = mid+1;
        }
    }
}
</code></pre>
<p>  当我们将if改成while后，因为第一次递归以后，变量low就没有用处了，所以可以将pivot+1赋值给low，再循环后，来一次Partition(L,low,high),其效果等同于QSort(L，pivot+1,high);结果相同，但因采用迭代而不是递归的方法可以缩减堆栈深 度，从而提高了整体性能。<br>
  相当于处理好了1/2再对剩下的1/2进行处理</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ 题1:赋值运算符函数]]></title>
        <id>https://lixin-scut.github.io//post/c-ti-1fu-zhi-yun-suan-fu-han-shu</id>
        <link href="https://lixin-scut.github.io//post/c-ti-1fu-zhi-yun-suan-fu-han-shu">
        </link>
        <updated>2020-03-04T00:04:14.000Z</updated>
        <content type="html"><![CDATA[<p>题目：如下为类型CMyString的声明，请为该类型添加赋值运算符函数。</p>
<pre><code>class CMyString
{
public:
		CMyString(char  pData = nullptr);
		CMyString(const CMyString&amp; str);
		~CMyString(void);

private:
		char* m_pData;
}
</code></pre>
<p>关注如下几点：</p>
<ol>
<li>是否把返回值的类型声明为该类型的引用，并在函数结束前返回实 例自身的引用(*this)。只有返回一个引用，才可以允许连续赋值。</li>
<li>是否把传入的参数的类型声明为常量引用。如果传入的参数不是引 用而是实例，那么从形参到实参会调用一次复制构造函数。把参数 声明为引用可以避免这样的无谓消耗，能提高代码的效率。同时， 我们在赋值运算符函数内不会改变传入的实例的状态，因此应该为 传入的引用参数加上const关键字。</li>
<li>是否释放实例自身已有的内存。如果我们忘记在分配新内存之前释 放自身己有的空间，则程序将出现内存泄漏。</li>
<li>
<pre><code>判断传入的参数和当前的实例(\this)是不是同一个实例。如果是同一个则不进行赋值操作，直接返回。如果事先不判断就进行赋值，那么在释放实例自身内存的时候就会导致严重的问题：当\*this 和传入的参数是同一个实例时，一旦释放了自身的内存，传入的参数的内存也同时被释放了，因此再也找不到需要赋值的内容了。
</code></pre>
</li>
</ol>
<p>初级解法</p>
<pre><code>CMyString&amp; CMyString::operator = (const CMyString&amp; str)
{
    if(this == &amp;str)
        return *this;

    delete []m_pData;
    m_pData = nullptr;

    m_pData = new char[strlen(str.m_pData) + 1];
    strcpy(m_pData, str.m_pData);

    return *this;
}
</code></pre>
<p>  在前面的函数中，我们在分配内存之前先用delete释放了实例m_pData的内存。如果此时内存不足导致new char抛出异常，则m_pData将是一个 空指针，这样非常容易导致程序崩溃。也就是说，一旦在赋值运算符函数内部抛出一个异常，CMyString的实例不再保持有效的状态，这就违背了异常安全性(Exception Safety)原则。<br>
  要想在赋值运算符函数中实现异常安全性，我们有两种方法。一种简单的办法是我们先用new分配新内容，再用delete释放已有的内容。这样只在分配内容成功之后再释放原来的内容，也就是当分配内存失败时我们 能确保CMyString的实例不会被修改。我们还有一种更好的办法，即先创建一个临时实例，再交换临时实例和原来的实例。下面是这种思路的参考 代码：</p>
<pre><code>CMyString&amp; CMyString::operator =(const CMyString&amp; str)
{
		if(this!= &amp;str)
		{
				CMyString strTemp(str);
				
				char* pTemp = strTemp.m_pData;
				strTemp.m_pData = m_pData;
				m_pData = pTemp;
		}
		return *this;
}
</code></pre>
<p>  在新的代码中，我们在CMyString的构造函数里用new分配内存。如果由于内存不足抛出诸如bad_alloc等异常，但我们还没有修改原来实例的状态，因此实例的状态还是有效的，这也就保证了异常安全性。<br>
  在这个函数中，我们先创建一个临时实例strTemp,接着把strTemp.m_pData和实例自身的m_pData进行交换。由于strTemp是一个局部变量，但 程序运行到if的外面时也就出了该变量的作用域，就会自动调用strTemp 的析构函数，把strTemp.mjData所指向的内存释放掉。由于 strTemp.m_pData指向的内存就是实</p>
<p>使用swap<br>
  为了交换两个对象我们需要进行一次拷贝和两次赋值，但理论上这些内存分配都是不必要的，我们更希望使用swap交换指针，而不是分配对象的新副本<br>
  与拷贝控制成员不同，swap不是必要的，但是对于分配了资源的类，定义swap可能是一种很重要的优化手段</p>
<pre><code>// 特别注意什么时候用传值什么时候用传引用
CMyString&amp; CMyString::operatpr (CMyString str)
{
		swap(*this,str);
		return *this;
}

void CMyString::swap(CMyString&amp; lhs, CMyString&amp; rhs);
</code></pre>
<p>  在上述版本的赋值运算符中，参数并不是一个引用，所以右侧运算对象是以传值方式传递给了赋值运算符。因此rhs是右侧运算对象的一个副本<br>
  在函数体中，rhs获得了*this原来保存的指针，并将rhs 的指针存入了*this。但结束时析构函数会被执行，rhs会被销毁，delete了rhs现在指向的内存，即左侧对象原来指向的内存<br>
  这个技术的有趣之处在于它自动处理了自赋值情况切天然就是异常安全的，通过在改变左侧运算对象之前拷贝右侧运算对象保证了自赋值的正确，代码中唯一可能抛出异常的是拷贝构造函数中的new表达式，如果真的发生了异常，它也会发生在我们改变左侧运算对象之前</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 题45:把数组排成最小的数]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-ti-45</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-ti-45">
        </link>
        <updated>2020-03-03T23:31:11.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
</blockquote>
<p>重点在于比较方法，排序其实可以用快排来实现<br>
然后需要注意的是：<br>
注意：比较函数必须写在类外部（全局区域）或声明为静态函数<br>
当lessthan作为类的成员函数时，默认拥有一个this指针，这样和sort函数所需要使用的排序函数类型不一样。<br>
否则，会出现<code>&lt;unresolved overloaded function type&gt;</code>错误</p>
<pre><code>class Solution {
public:
    string PrintMinNumber(vector&lt;int&gt; numbers) {
        string res;
        if(numbers.empty())
            return res;
        vector&lt;string&gt; numbers_str;
        for(auto num:numbers){
            numbers_str.push_back(to_string(num));
        }
        sort(numbers_str.begin(),numbers_str.end(),LessThen);
        
        for(auto str:numbers_str){
            res+=str;
        }
        return res;
    }
    
    static bool LessThen(string s1,string s2){
        return s1+s2&lt;s2+s1;
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>  这道题其实是希望我们能找到一个排序规则，数组根据这个规则排序之后能排成一个最小的数字。要确定排序规则，就要比较两个数字，也就 是给出两个数字m和n，我们需要确定一个规则判断m和n哪个应该排在 前面，而不是仅仅比较这两个数字的值哪个更大。<br>
  根据题目的要求，两个数字m和n能拼接成数字mn和nm，如果mn&lt;nm, 那么我们应该打印出mn,也就是m应该排在n的前面，我们定义此时m小于n；反之，如果nm&lt;mn则我们定义m小于n；如果mn=nm,则m等于n。在下文中，符号“&lt;”、&quot;&gt;”及“=”表示常规意义的数值的大小关系, 而文字&quot;大于”、“小于”、“等于”表示我们新定义的大小关系。<br>
  接下来考虑怎么去拼接数字，即给出数字m和n，怎么得到数字mn和 nm并比较它们的大小。直接用数值去计算不难办到，但需要考虑的一个潜在问题就是m和n都在int型能表达的范围内，但把它们拼接起来的数字 mn和nm用int型表示就有可能溢出了，所以这还是一个隐形的大数问题。<br>
  一个非常直观的解决大数问题的方法就是把数字转换成字符串。另外, 由于把数字m和n拼接起来得到mn和mn,它们的位数肯定是相同的，因此比较它们的大小只需要按照字符串大小的比较规则就可以了。<br>
  我们先把数组中的整数转换成字符串，然后在函数compare中定义比较规则，并根据该规则调用库函数qsort排序，最后把排 好序的数组中的数字依次打印出来，就是该数组中数字能拼接出来的最小数字。这种思路的时间复杂度和qsort的时间复杂度相同，也就是O(nlogM), 这比用n!的时间求出所有排列的思路要好很多。</p>
</blockquote>
<pre><code>int compare(const void* strNumber1, const void* strNumber2);

// int型整数用十进制表示最多只有10位
const int g_MaxNumberLength = 10;
 
char* g_StrCombine1 = new char[g_MaxNumberLength * 2 + 1];
char* g_StrCombine2 = new char[g_MaxNumberLength * 2 + 1];
 
void PrintMinNumber(const int* numbers, int length)
{
    if(numbers == nullptr || length &lt;= 0)
        return;
 
    char** strNumbers = (char**)(new int[length]);
    for(int i = 0; i &lt; length; ++i)
    {
        strNumbers[i] = new char[g_MaxNumberLength + 1];
        sprintf(strNumbers[i], &quot;%d&quot;, numbers[i]);
    }
 
    qsort(strNumbers, length, sizeof(char*), compare);
 
    for(int i = 0; i &lt; length; ++i)
        printf(&quot;%s&quot;, strNumbers[i]);
    printf(&quot;\n&quot;);
 
    for(int i = 0; i &lt; length; ++i)
        delete[] strNumbers[i];
    delete[] strNumbers;
}
 
// 如果[strNumber1][strNumber2] &gt; [strNumber2][strNumber1], 返回值大于0
// 如果[strNumber1][strNumber2] = [strNumber2][strNumber1], 返回值等于0
// 如果[strNumber1][strNumber2] &lt; [strNumber2][strNumber1], 返回值小于0
int compare(const void* strNumber1, const void* strNumber2)
{
    // [strNumber1][strNumber2]
    strcpy(g_StrCombine1, *(const char**)strNumber1);
    strcat(g_StrCombine1, *(const char**)strNumber2);
 
    // [strNumber2][strNumber1]
    strcpy(g_StrCombine2, *(const char**)strNumber2);
    strcat(g_StrCombine2, *(const char**)strNumber1);
 
    return strcmp(g_StrCombine1, g_StrCombine2);
}
</code></pre>
<p><img src="https://lixin-scut.github.io//post-images/1583279065298.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1583279078008.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[进程间通信方式]]></title>
        <id>https://lixin-scut.github.io//post/jin-cheng-jian-tong-xin-fang-shi</id>
        <link href="https://lixin-scut.github.io//post/jin-cheng-jian-tong-xin-fang-shi">
        </link>
        <updated>2020-03-03T09:52:50.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>管道<br>
管道，通常指无名管道。<br>
①	半双工的，具有固定的读端和写端；<br>
②	只能用于具有亲属关系的进程之间的通信；<br>
③	可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write函数。但是它不是普通的文件，并不属于其他任何文件系统，只能用于内存中。<br>
④	Int pipe(int fd[2]);当一个管道建立时，会创建两个文件文件描述符，要关闭管道只需将这两个文件描述符关闭即可。<br>
协同进程：连接到另一进程的两个单向管道</li>
<li>FIFO（有名管道）<br>
①	FIFO可以再无关的进程之间交换数据，与无名管道不同；<br>
②	FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中；<br>
③	Int mkfifo(const char* pathname,mode_t mode);</li>
<li>消息队列<br>
①	消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符来标识；<br>
②	消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级；<br>
③	消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除；<br>
④	消息队列可以实现消息的随机查询</li>
<li>信号量<br>
①	信号量是一个计数器，信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据；<br>
②	信号量用于进程间同步，若要在进程间传递数据需要结合共享内存；<br>
③	信号量基于操作系统的PV操作，程序对信号量的操作都是原子操作；</li>
<li>共享内存<br>
①	共享内存，指两个或多个进程共享一个给定的存储区；<br>
②	共享内存是最快的一种进程通信方式，因为进程是直接对内存进行存取；<br>
③	因为多个进程可以同时操作，所以需要进行同步；<br>
④	信号量+共享内存通常结合在一起使用。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字节对齐]]></title>
        <id>https://lixin-scut.github.io//post/zi-jie-dui-qi</id>
        <link href="https://lixin-scut.github.io//post/zi-jie-dui-qi">
        </link>
        <updated>2020-03-03T09:51:39.000Z</updated>
        <content type="html"><![CDATA[<p>现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。</p>
<p>1、	平台原因(移植原因)</p>
<ol>
<li>不是所有的硬件平台都能访问任意地址上的任意数据的；</li>
<li>某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异<br>
2、性能原因：</li>
<li>数据结构(尤其是栈)应该尽可能地在自然边界上对齐。</li>
<li>为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字节序]]></title>
        <id>https://lixin-scut.github.io//post/zi-jie-xu</id>
        <link href="https://lixin-scut.github.io//post/zi-jie-xu">
        </link>
        <updated>2020-03-03T09:44:59.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>字节排序函数、大端序、小端序<br>
  小端 和 大端 表示多个字节值的哪一端(小端或大端)存储在该值的起始 地址.<br>
  低序字节存储在起始地址，这称为小端（little-endian）字节序；<br>
  另一种方法是将高序字节存储在起 始地址，这称为大端（big-endian）字节序。<br>
<strong>记忆方法</strong>：大端序就是我们日常的<strong>书写顺序</strong>（在纸上（内存）写一个数字，先写高位再写地位），小端序则是反过来</li>
</ul>
<p>当前系统所用的字节序称为主机字节序(host byte order)<br>
<img src="https://lixin-scut.github.io//post-images/1578490222230.png" alt=""><br>
  网络协议必须指定一个网络字节序（network byte order），网际协议使用<strong>大端字节序</strong>来传送这些多字节整数。<br>
套接字地址结构中的某些字 段必须按照网络字节序进行维护。<br>
两种字节序之间的转换使用以下4个函数。<br>
<img src="https://lixin-scut.github.io//post-images/1578490503887.png" alt=""><br>
h代表host, n代表network, s代表short, l代表long</p>
<p>  注意：当使用这些函数时，我们并不关心主机字节序和网络字节序的真实值（或为大端，或为小端）。我们所要做的只是调用适当的函数在主机和网络字节序之间转换某个给定值。在那些与网际协议所用字节序（大端）相同的系统中，这四个函数通常被定义为空宏。（一句话，为求保险（优雅地说是提高可移植性），默认调用转换就完事了）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[死锁]]></title>
        <id>https://lixin-scut.github.io//post/si-suo</id>
        <link href="https://lixin-scut.github.io//post/si-suo">
        </link>
        <updated>2020-03-03T07:25:22.000Z</updated>
        <content type="html"><![CDATA[<h3 id="死锁">死锁</h3>
<p>  如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，该进程集合就是死锁的。<br>
  由于所有的进程都在等待，所以没有一个进程能引发可以唤醒该进程集合中的其他进程的事件，这样, 所有的进程都只好无限期等待。<br>
  在大多数情况下，每个进程所等待的事件是释放该进程集合中其他进程所占有的资源。换言之，这个死锁进程集合中的每一个进程都在等待另一个死锁的进程已经占有的资源。但是由于所有进程都不能运行，它们中的任何一个都无法释放资源，所以没有一个进程可以被唤醒。 这种死锁称为资源死锁（resource deadlock）。</p>
<h3 id="发生条件">发生条件</h3>
<p>资源死锁的条件<br>
发生（资源）死锁的四个必要条件：<br>
1）	互斥条件。每个资源要么已经分配给了一个进程，要么就是可用的。<br>
2）	占有和等待条件。已经得到了某个资源的进程可以再请求新的资源。<br>
3）	不可抢占条件。已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。<br>
4）	环路等待条件。死锁发生时，系统中一定有由两个或两个以上的进程组成的一条环路，该环路中的每个进程都在等待着下一个进程所占有的资源。<br>
  死锁发生时，以上四个条件一定是<strong>同时满足</strong>的。如果其中任何一个条件不成立，死锁就不会发生。</p>
<h3 id="处理策略">处理策略</h3>
<p>有四种处理死锁的策略：<br>
1）	鸵鸟算法：忽略该问题。也许如果你忽略它，它也会忽略你。<br>
2）	检测死锁并恢复。让死锁发生，检测它们是否发生，一旦发生死锁，采取行动解决问题。<br>
3）	死锁避免，仔细对资源进行分配，动态地避免死锁。<br>
4）	通过破坏引起死锁的四个必要条件之一，防止死锁的产生。</p>
<h3 id="死锁检测">死锁检测</h3>
<p>  对系统构造一张资源分配图，如果这张图包含了一个或一个以上的环， 那么死锁就存在。在此环中的任何一个进程都是死锁进程。如果没有这样的环，系统就没有发生死锁。<br>
  如果有多种相同的资源存在，就需要采用另一种方法来检测死锁：基于矩阵的算 法来检测这个进程中的死锁。</p>
<h3 id="从死锁中恢复">从死锁中恢复</h3>
<ol>
<li>利用抢占恢复<br>
临时将某个资源从它的当前所有者那里转移到另一个进程</li>
<li>利用回滚恢复<br>
周期性地对进程进行检查点检查（checkpointed）。进程检查点检查就是将进程的状态写入一个文件以备以后重启。将该进程复位到一个更早的状态，那时它还没有取得所需的资源，接着就把这个资源分配给一个 死锁进程。如果复位后的进程试图重新获得对该资源的控制，它就必须一直等到该资源可用时为止。</li>
<li>通过杀死进程恢复<br>
最直接也是最简单的解决死锁的方法是杀死一个或若干个进程。一种方法是杀掉环中的一个进程。如果走运的话，其他进程将可以继续。如果这样做行不通的话，就需要继续杀死别的进程直到打破死锁环。<br>
  另一种方法是选一个环外的进程作为牺牲品以释放该进程的资源。<br>
  另一方面，更新数据库的进程在第二次运行时并非总是安全的。如果一个进程将数据库的某个记录 加1,那么运行它一次，将它杀死后，再次执行，就会对该记录加2,这显然是错误的。</li>
</ol>
<h3 id="死锁避免">死锁避免</h3>
<ol>
<li>资源轨迹图</li>
<li>安全状态和不安全状态<br>
  不安全状态并不是死锁。系统能运行一段时间。实际上，甚至有一个进程能够完成。安全状态和不安全状态的区别是：从安全状态出发，系统能够保证所有进程都 能完成，而从不安全状态出发，就没有这样的保证。</li>
<li>银行家算法<br>
  银行家算法就是对每一个请求迸行检查，检查如果满足这一请求是否会达到安全状态。若是，那么 就满足该请求，若否，那么就推迟对这一请求的满足。为了看状态是否安全，银行家看他是否有足够的 资源满足某一个客户。如果可以，那么这笔投资认为是能够收回的，并且接着检查最接近最大限额的一 个客户，以此类推。如果所有投资最终都被收回，那么该状态是安全的，最初的请求可以批准。</li>
</ol>
<h3 id="死锁预防">死锁预防</h3>
<ol>
<li>破坏互斥条件：如果资源不被一个进程所独占，那么死锁肯定不会产生。<br>
  允许两 个进程同时使用打印机会造成混乱，通过采用假脱机打印机（spooling printer）技术可以允许若干个进程同时产生输出。该模型中惟一真正请求使用物理打印机的进程是打印机守护进程，由于守护进程决不会请求别的资源，所以不会因打印机而产生死锁。</li>
<li>破坏占有和等待条件：只要禁止已持有资源的进程再等待其他资源便可以消 除死锁。<br>
  一种实现方法是规定所有进程在开始执行前请求所需的全部资源。如果所需的全部资源可用， 那么就将它们分配给这个进程，于是该进程肯定能够运行结束。如果有一个或多个资源正被使用，那么就不进行分配，进程等待。<br>
  另一种破坏占有和等待条件的略有不同的方案是，要求当一个进程请求资源时，先暂时释放其当前占用的所有资源，然后再尝试一次获得所需的全部资源。</li>
<li>破坏不可抢占条件<br>
  现在只剩下一个条件了。消除环路等待有几种方法。一种是保证每一个进程在任何时刻只能占用一个资源，如果要请求另外一个资源，它必须先释放第一个资源。但<br>
  该算法的一个变种是摈弃必须按升序请求资源的限制，而仅仅要求不允许进程请求比当前所占有资源编号低的资源。</li>
</ol>
<h3 id="两阶段加锁">两阶段加锁</h3>
<p>  在第一阶段，进程试图对所有所需的记录进行加锁， 一次锁一个记录。如果第一阶段加锁成功，就开始第二阶段，完成更新然后释放锁。在第一阶段并没有做实际的工作。<br>
  如果在第一阶段某个进程需要的记录已经被加锁，那么该进程释放它所有加锁的记录，然后重新开始第一阶段。从某种意义上说，这种方法类似于提前或者至少是未实施一些不可逆的操作之前请求所有资源。<br>
  如果在第一阶段遇到了已加锁的记录，并不会释放锁然后重新开始， 这就可能产生死锁。<br>
  不过，在一般意义下，这种策略并不通用。例如，在实时系统和进程控制系统中，由于一个进程缺 少一个可用资源就半途中断它，并重新开始该进程，这是不可接受的。</p>
<h3 id="通信死锁">通信死锁</h3>
<p>  另一种死锁发生在通信系统中（比如说网络），即两个或两个以上进程利用发送信息来通信时。一种普遍的情形是进程A向进程B发送请求信息，然后阻塞直至B回复。假设请求信息丢失，A将阻塞以等待回复，而B 会阻塞等待一个向其发送命令的请求，因此发生死锁。<br>
  仅仅如此并非经典的资源死锁。A没有占有B所需的资源，反之亦然。事实上，并没有完全可见的资源。但是，根据标准的定义，在一系列进程中，每个进程因为等待另外一个进程引发的事件而产生阻塞，这就是一种死锁。相比于更加常见的资源死锁，我们把上面这种情况叫做通信死锁 （communication deadlock）</p>
<h3 id="活锁">活锁</h3>
<p>  在某种情形下，轮询（忙等待）可用于进入临界区或存取资源。<br>
  现在假设有一对进程使用两种资源。每个进程需要两种资源，它们利用轮询原语enter_region去尝试取得必要的锁，如果尝试失败，则该进程继续尝试。如果进程A先运行并得到资源1,然后进程2运行并得到资源2,以后不管哪一个进程运行，都不会有任何进展，但是哪一个进程也没有被阻塞。结果 是两个进程总是一再消耗完分配给它们的CPU配 额，但是没有进展也没有阻塞。因此，没有出现 死锁现象（因为没有进程阻塞），但是从现象上 看好像死锁发生了，这就是活锁（livelock）。</p>
<h3 id="饥饿">饥饿</h3>
<p>  与死锁和活锁非常相似的一个问题是饥饿（starvation）。在动态运行的系统中，在任何时刻都可能请求资源。这就需要一些策略来决定在什么时候谁获得什么资源。虽然这个策略表面上很有道理，但依 然有可能使一些进程永远得不到服务，虽然它们并不是死锁进程。<br>
作为一个例子，考虑打印机分配。设想系统采用某种算法来保证打印机分配不产生死锁。现在假设若干进程同时都请求打印机，究竟哪一个进程能获得打印机呢？<br>
一个可能的分配方案是把打印机分配给打印最小文件的进程（假设这个信息可知）。这个方法让尽 量多的顾客满意，并且看起来很公平。我们考虑下面的情况：在一个繁忙的系统中，有一个进程有一个 很大的文件要打印，每当打印机空闲，系统纵观所有进程，并把打印机分配给打印最小文件的进程。如 果存在一个固定的进程流，其中的进程都是只打印小文件，那么，要打印大文件的进程永远也得不到打 印机。很简单，它会饥饿而死”（无限制地推后，尽管它没有被阻塞）。<br>
  饥饿可以通过先来先服务资源分配策略来避免。在这种机制下，等待最久的进程会是下一个被调度的进程。随着时间的推移，所有进程都会变成最“老”的，因而，最终能够获得资源而完成。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux文件系统]]></title>
        <id>https://lixin-scut.github.io//post/linux-wen-jian-xi-tong</id>
        <link href="https://lixin-scut.github.io//post/linux-wen-jian-xi-tong">
        </link>
        <updated>2020-03-03T07:09:15.000Z</updated>
        <content type="html"><![CDATA[<h3 id="文件系统">文件系统</h3>
<p>磁盘分区完毕后还需要进行格式化(format)，之后操作系统才能够使用这个文件系统。这是因为每种操作系统所设定的文件属性/权限并不相同。为了存放这些文件所需的数据，因此就需要将分区槽进行格式化，以成为操作系统能够利用的『文件系统格式(filesystem)』<br>
文件系统通常会将这两部份的数据（文件权限(rwx)与文件属性(拥有者、 群组、时间参数等)）分别存放在不同的区块，权限与属性放置到 inode 中，至于实际数据则放置到 data block 区块中</p>
<h3 id="层次分析">层次分析</h3>
<ol>
<li>用户层，日常使用的各种程序，需要的接口主要是文件的创建、删除、读、写、关闭等；</li>
<li>VFS层，文件相关的操作都有对应的System Call函数接口，接口调用VFS对应的函数；</li>
<li>文件系统层，用户的操作通过VFS转到各种文件系统。文件系统把文件读写命令转化为对磁盘LBA的操作，起了一个翻译和磁盘管理的工作；</li>
<li>缓存层；</li>
<li>块设备层，块设备接口Block Device是用来访问磁盘LBA的层级，读写命令组合之后插入到命令队列，磁盘的驱动从队列读命令执行；</li>
<li>磁盘驱动层；</li>
<li>磁盘物理层；</li>
</ol>
<h3 id="读取文件过程">读取文件过程</h3>
<ol>
<li>根据文件所在目录的inode信息，找到目录文件对应数据块；</li>
<li>根据文件名从数据块中找到对应的inode节点信息；</li>
<li>从文件inode节点信息中找到文件内容所在数据块块号；</li>
<li>读取数据块内容</li>
</ol>
<h3 id="inode">inode</h3>
<p>superblock：记录此 filesystem 的整体信息，包括 inode/block 的总量、使用量、剩余量， 以及文件系统的 格式与相关信息等；<br>
inode：记录文件的属性，一个文件占用一个 inode，同时记录此文件的数据所在的 block 号码；</p>
<p>  每个文件都会占用一个 inode ，inode 内则有文件数据放置的 block 号码。<br>
  一个incode可能会拥有（占用）多个block，这种数据存取的方法我们称为索引式文件系统(indexed allocation)</p>
<p>inode 记录的文件数据至少有底下这些<br>
该文件的存取模式(read/write/excute)；<br>
该文件的拥有者与群组(owner/group)；<br>
该文件的容量；<br>
该文件建立或状态改变的时间(ctime)；<br>
最近一次的读取时间(atime)；<br>
最近修改的时间(mtime)；<br>
定义文件特性的旗标(flag)，如 SetUID...；<br>
该文件真正内容的指向 (pointer)；<br>
每个 inode 大小均固定为 128 bytes (新的 ext4 与 xfs 可设定到 256 bytes)；<br>
每个文件都仅会占用一个 inode 而已；<br>
  承上，因此文件系统能够建立的文件数量与 inode 的数量有关；<br>
  系统读取文件时需要先找到 inode，并分析 inode 所记录的权限与用户是否符合，若符合才能够开始实际 读取 block 的内容。</p>
<h3 id="软链接和硬链接">软链接和硬链接</h3>
<p><strong>hard link</strong>：多个档名对应到同一个 inode 号码<br>
  hard link 只是在某个目录下新增一笔档名链接到某 inode 号码的关连记录而已<br>
  硬链接hard link最大的好处就是 『安全』，如果你将任何一个『档名』删除，其实 inode 与 block 都还是存在的<br>
  使用 hard link 设定链接文件时，磁盘的空间与 inode 的数目都不会改变<br>
  hard link 的制作中，其实还是可能会改变系统的 block 的，那就是当你新增这笔数据却刚好将目录的 block 填满时，就可能会新加一个 block 来记录文件名关连性，而导致磁盘空间的变化。不过， 一般 hard link 所用掉的关连数据量很小，所以通常不会改变 inode 与磁盘空间的大小<br>
hard link 是有限制的：</p>
<ol>
<li>不能跨 Filesystem；</li>
<li>不能直接 link 目录。</li>
<li>如果使用 hard link 链接到目录时， 链接的数据需要连同被链接目录底下的所有数据都建立链接</li>
</ol>
<p><strong>Symbolic Link</strong>(符号链接，亦即是快捷方式)<br>
  Symbolic link 就是在建立一个独立的 文件，而这个文件会让数据的读取指向他它link 的那个文件的档名！由于只是利用文件来做为指向的 动作， 所以，当来源档被删除之后，symbolic link 的文件会『开不了』，<br>
  符号链接可以跨越文件系统！！！也可以链接项目，因为只看文件名不看inode<br>
  两个文件指向不同的 inode 号码，当然就是两个独立的文件存在！ 而且连结档的重要内容就是他会写上目标文件的『文件名』<br>
  Symbolic Link 与 Windows 的快捷方式可以给他划上等号，由 Symbolic link 所建立的文件为一个独立的新的文件，所以会占用掉 inode 与 block</p>
<p>  个人测试：Symbolic Link之后删除源文件，会显示No such file 。但是！！！！我重建源文件后（用vim重建不同内容的同名文件或者用ln硬链接同名文件），会自动连接上！！！<br>
  stat对于软连接不会寻找源文件，lstat才会获取原始文件</p>
<p>使用 ln 如果不加任何参数的话，那么就是 Hard Link使用 ln 如果不加任何参数的话，那么就是 Hard Link要制作连结档就必须要使用 ln 这个指令，使用 ln 如果不加任何参数的话，那么就是 Hard Link</p>
<pre><code>[root@study ~]# ln [-sf] 来源文件 目标文件
选项与参数：
-s ：如果不加任何参数就进行连结，那就是 hard link，至于 -s 就是 symbolic link
-f ：如果 目标文件 存在时，就主动的将目标文件直接移除后再建立
</code></pre>
<p>关于目录的 link 数量<br>
  以 hard link 进行『文件的连结』时，可以发现，在 ls -l 所显 示的第二字段会增加一才对<br>
  当我们建立一个新目录名称为 /tmp/testing 时，基本上会有三个东西，那就是：</p>
<pre><code>/tmp/testing
/tmp/testing/.
/tmp/testing/..
</code></pre>
<p>所以新的目录的 link 数为 2 ，而上层目录的 link 数则会增加 1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math  题43:	整数中1出现的次数[未做出]]]></title>
        <id>https://lixin-scut.github.io//post/math-ti-43-zheng-shu-zhong-1-chu-xian-de-ci-shu-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/math-ti-43-zheng-shu-zhong-1-chu-xian-de-ci-shu-wei-zuo-chu">
        </link>
        <updated>2020-03-03T00:53:59.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>输入一个整数n，求1~n这n个整数的十进制表示中1出现的次数。例如，输入12, 1〜12这些整数中包含1的数字有1、10、11和12,共出现了5次。</p>
</blockquote>
<p>  一开始把题目看成了统计当前数字中的1....<br>
  暴力法比较麻烦的是不仅要循环递增数字，还要循环数字本身，数字一旦大了时间复杂度就爆炸了<br>
  然后就是书中的规律法，比较有趣，就是使用逐位计算，需要注意的就是</p>
<ol>
<li>位数为1时的处理</li>
<li>最高位为1的次数需要额外+1</li>
<li>剩余位需要-2（当前位和最高位），理解为何剩余位可以取0-9而不是除去1或者只能取到当前最大值</li>
</ol>
<pre><code>class Solution {
public:
    //数学规律递归法【未做出】
    int NumberOf1Between1AndN_Solution(int n)
    {
        if(n&lt;1)
            return 0;
        string ns=to_string(n);
        int length=ns.size();
        int count=0;
        for(auto i:ns){
            count+=count_one(i-'0',length,n);
            --length;
        }
        return count;
    }
    
    int count_one(int i,int bit,int &amp;n){
        int count=0;
        if(i==0&amp;&amp;bit==1)
            return 0;
        if(bit==1){
            return 1;
        }
        
        //最高位为1的次数
        if(i&gt;1)
            count+=pow(10,bit-1);
        else if(i==1)
            count+=n-1*pow(10,bit-1)+1;
        
        //剩余位数为1的次数 
        count+=i*(bit-1)*pow(10,bit-2);
        n-=i*pow(10,bit-1);
        return count;
    }
    
    
    /*
    //逐个数计算法
    int NumberOf1Between1AndN_Solution(int n)
    {
        if(n&lt;1)
            return 0;
        int count;
        count=0;
        for(int i=1;i&lt;=n;++i){
            count+=count_one(i);
        }
        return count;
    }
    
    int count_one(int n){
        int count=0;
        int temp;
        while(n&gt;0){
            temp=n%10;
            if(temp==1)
                ++count;
            n/=10;
        }
        return count;
    }
    */
};
</code></pre>
<p>书本题解：<br>
  最直观的方法, 也就是累加1〜n中每个整数1出现的次数。我们可以每次通过对10求余数判断整数的个位数字是不是1。如果这个数字大于10,则除以10之后再判断个位数字是不是1。<br>
  在上述思路中，我们对每个数字都要做除法和求余运算，以求出该数字中1出现的次数。如果输入数字n，n有O(logn)位，我们需要判断每一位是不是1,那么它的时间复杂度是O(nlogn)。当输入的n非常大的时候，需要大量的计算，运算效率不高。<br>
  如果希望不用计算每个数字的1的个数，那就只能去寻找1在数字中出现的规律了。为了找到规律，我们不妨用一个稍微大一点的数字如21345 作为例子来分析。我们把1〜21345的所有数字分为两段：一段是1〜1345： 另一段是1346〜21345。<br>
  我们先看1346〜21345中1出现的次数。1的出现分为两种情况。首先分析1出现在最高位(本例中是万位)的情况。在1346-21345的数字中， 1出现在10000〜19999这10000个数字的万位中，一共出现了10^4次。<br>
  值得注意的是，并不是对所有5位数而言在万位出现的次数都是10000 次。对于万位是1的数字如输入12345, 1只出现在10000-12345的万位, 出现的次数不是1次，而是2346次，也就是除去最高数字之后剩下的数字再加上1 (2345+1=2346次)。<br>
  接下来分析1出现在除最高位之外的其他4位数中的情况。例子中 1346〜21345这20000个数字中后4位中1出现的次数是8000次。由于最高位是2,我们可以再把1346〜21345分成两段：1346〜11345和11346〜21345,每一段剩下的4位数字中，选择其中一位是1，其余三位可以在0〜 9这10个数字中任意选择，因此根据排列组合原则，总共出现的次数是2X 4x10^3=8000 次。<br>
  至于在1〜1345中1出现的次数，我们就可以用递归求得了。这也是 我们为什么要把1〜21345分成1〜1345和1346-21345两段的原因。因为把21345的最高位去掉就变成1345,便于我们采用递归的思路。<br>
  这种思路是每次去掉最高位进行递归，递归的次数和位数相同。一个数字n有O(logn)位，因此这种思路的时间复杂度是O(logn),比前面的原始方法要好很多。</p>
<pre><code>int NumberOf1(unsigned int n);

int NumberOf1Between1AndN_Solution1(unsigned int n)
{
    int number = 0;

    for(unsigned int i = 1; i &lt;= n; ++ i)
        number += NumberOf1(i);

    return number;
}

int NumberOf1(unsigned int n)
{
    int number = 0;
    while(n)
    {
        if(n % 10 == 1)
            number ++;

        n = n / 10;
    }

    return number;
}

// ====================方法二====================
int NumberOf1(const char* strN);
int PowerBase10(unsigned int n);

int NumberOf1Between1AndN_Solution2(int n)
{
    if(n &lt;= 0)
        return 0;

    char strN[50];
    sprintf(strN, &quot;%d&quot;, n);

    return NumberOf1(strN);
}

int NumberOf1(const char* strN)
{
    if(!strN || *strN &lt; '0' || *strN &gt; '9' || *strN == '\0')
        return 0;

    int first = *strN - '0';
    unsigned int length = static_cast&lt;unsigned int&gt;(strlen(strN));

    if(length == 1 &amp;&amp; first == 0)
        return 0;

    if(length == 1 &amp;&amp; first &gt; 0)
        return 1;

    // 假设strN是&quot;21345&quot;
    // numFirstDigit是数字10000-19999的第一个位中1的数目
    int numFirstDigit = 0;
    if(first &gt; 1)
        numFirstDigit = PowerBase10(length - 1);
    else if(first == 1)
        numFirstDigit = atoi(strN + 1) + 1;

    // numOtherDigits是01346-21345除了第一位之外的数位中1的数目
    int numOtherDigits = first * (length - 1) * PowerBase10(length - 2);
    // numRecursive是1-1345中1的数目
    int numRecursive = NumberOf1(strN + 1);

    return numFirstDigit + numOtherDigits + numRecursive;
}

int PowerBase10(unsigned int n)
{
    int result = 1;
    for(unsigned int i = 0; i &lt; n; ++ i)
        result *= 10;

    return result;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 题42:连续子数组的最大和]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-ti-42lian-xu-zi-shu-zu-de-zui-da-he</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-ti-42lian-xu-zi-shu-zu-de-zui-da-he">
        </link>
        <updated>2020-03-03T00:31:57.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)<br>
例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。</p>
</blockquote>
<p>非常简单，就是如果max小于0的话说明它对当前值已经没有增益了，必须舍弃掉<br>
而大于等于0的话则值得继续加下去<br>
需要注意的点是必须把max和res初始化为INT_MIN，仅仅值初始化或者初始化为0的话如果整个数组都是负数的话会返回错误的结果<br>
然后这个条件判断最后可以转化为动态规划</p>
<pre><code>class Solution {
public:
    int FindGreatestSumOfSubArray(vector&lt;int&gt; array) {
        int max,res;
        max=INT_MIN;
        res=INT_MIN;
        for(auto num:array){
            /*
            if(max&lt;0)
                max=num;
            else
                max+=num;
             */
            max=num&gt;max+num?num:max+num;//动态规划
            res=res&gt;max?res:max;
        }
        return res;
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>动态规划法<br>
  如果算法的功底足够扎实，那么我们还可以用动态规划的思想来分析这个问题。如果用函数f(i)表示以第i个数字结尾的子数组的最大和，那么我们需要求出max[f(i)],<br>
  当以第i-1个数字结尾的子数组中所有数字的和小于0时，如果把这个负数与第，个数累加，则得到的结果比第i个数字本身还要小，所以这种情况下以第i个数字结尾的子数组就是第i个数字本身。如果以第i-1个数字结尾的子数组中所有数字的和大于0, 则与第i个数字累加就得到以第i个数字结尾的子数组中所有数字的和。<br>
  注意，虽然通常我们用递归的方式分析动态规划的问题，但最终都会基于循环去编码。<br>
  面试的时候我们要考虑无效的输入，如输入的数组参数为空指针、数 组长度小于等于0等情况。此时我们让函数返回什么数字？如果返回0,那我们又怎么区分子数组的和的最大值是0和无效输入这两种不同情况呢？ 因此，我们定义了一个全局变量来标记是否输入无效。</p>
</blockquote>
<pre><code>bool g_InvalidInput = false;

int FindGreatestSumOfSubArray(int *pData, int nLength)
{
    if((pData == nullptr) || (nLength &lt;= 0))
    {
        g_InvalidInput = true;
        return 0;
    }

    g_InvalidInput = false;

    int nCurSum = 0;
    int nGreatestSum = 0x80000000;
    for(int i = 0; i &lt; nLength; ++i)
    {
        if(nCurSum &lt;= 0)
            nCurSum = pData[i];
        else
            nCurSum += pData[i];

        if(nCurSum &gt; nGreatestSum)
            nGreatestSum = nCurSum;
    }

    return nGreatestSum;
} 
</code></pre>
]]></content>
    </entry>
</feed>