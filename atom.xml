<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-03-05T02:31:16.053Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>In the darkest night,Rising like a spire.</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[桶排序]]></title>
        <id>https://lixin-scut.github.io//post/tong-pai-xu</id>
        <link href="https://lixin-scut.github.io//post/tong-pai-xu">
        </link>
        <updated>2020-03-05T02:27:20.000Z</updated>
        <content type="html"><![CDATA[<p>https://lixin-scut.github.io/post/shu-zu-164-zui-da-jian-ju/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 题46:把数字翻译成字符串]]></title>
        <id>https://lixin-scut.github.io//post/zi-fu-chuan-ti-46ba-shu-zi-fan-yi-cheng-zi-fu-chuan</id>
        <link href="https://lixin-scut.github.io//post/zi-fu-chuan-ti-46ba-shu-zi-fan-yi-cheng-zi-fu-chuan">
        </link>
        <updated>2020-03-05T00:35:15.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>给定一个数字，我们按照如下规则把它翻译为字符串：0翻译成&quot;a&quot;，1翻译成&quot;b&quot;，……，11翻译成&quot;l&quot;，……，25翻译成&quot;z&quot;。一个数字可能有多个翻译。例如12258有5种不同的翻译，它们是&quot;bccfi&quot;、&quot;bwfi&quot;、&quot;bczi&quot;、&quot;mcfi&quot;和&quot;mzi&quot;。请编程实现一个函数用来计算一个数字有多少种不同的翻译方法。</p>
</blockquote>
<p>书本题解：<br>
  当最开始的一个或者两个数字被翻译成一个字符之后，我们接着翻译后而剩下的数字。显然，我们可以写一个递归函数来计算翻译的数目。<br>
  我们定义函数f(i)表小从第i位数字开始的不同翻译的数目，那么f(i)=f(i+1)+g(i,i+1)xf(i+2)。当第i位和第i+1位两位数字拼接起来的数字在 10〜25的范围内时，函数g(i,i+1)的值为1；否则为0。<br>
  尽管我们用递归的思路来分析这个问题，但由于存在重复的子问题， 递归并不是解决这个问题的最佳方法。还是以12258为例。如前所述，翻译12258可以分解成两个子问题：翻译1和2258,以及翻译12和258。接 下来我们翻译第一个子问题中剩下的2258,同样也可以分解成两个自问题： 翻译2和258,以及翻译22和58。注意到子问题翻译258重复出现了。<br>
  递归从最大的问题开始自上而下解决问题。我们也可以从最小的子问题开始自下而上解决问题，这样就可以消除重复的子问题。也就是说，我 们从数字的末尾开始，然后从右到左翻译并计算不同翻译的数目。</p>
<pre><code>int GetTranslationCount(int number)
{
    if(number &lt; 0)
        return 0;

    string numberInString = to_string(number);
    return GetTranslationCount(numberInString);
}

int GetTranslationCount(const string&amp; number)
{
    int length = number.length();
    int* counts = new int[length];
    int count = 0;

    for(int i = length - 1; i &gt;= 0; --i)
    {
        count = 0;
         if(i &lt; length - 1)
               count = counts[i + 1];
         else
               count = 1;

        if(i &lt; length - 1)
        {
            int digit1 = number[i] - '0';
            int digit2 = number[i + 1] - '0';
            int converted = digit1 * 10 + digit2;
            if(converted &gt;= 10 &amp;&amp; converted &lt;= 25)
            {
                if(i &lt; length - 2)
                    count += counts[i + 2];
                else
                    count += 1;
            }
        }

        counts[i] = count;
    }

    count = counts[0];
    delete[] counts;

    return count;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math 题44:数字序列中某一位的数字]]></title>
        <id>https://lixin-scut.github.io//post/math-ti-44shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi</id>
        <link href="https://lixin-scut.github.io//post/math-ti-44shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi">
        </link>
        <updated>2020-03-05T00:23:47.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从0开始计数）是5，第13位是1，第19位是4，等等。请写一个函数求任意位对应的数字。</p>
</blockquote>
<p>书本题解：<br>
序列的第1001位是什么？<br>
序列的前10位是0〜9这10个只有一位的数字。显然第1001位在这 10个数字之后，因此这10个数字可以直接跳过。我们再从后面紧跟着的序列中找第991 (991=1001-10)位的数字。<br>
接下来180位数字是90个10-99的两位数。由于991&gt;180,所以第 991位在所有的两位数之后。我们再跳过90个两位数，继续从后面找881 (881=991-180)位。<br>
接下来的2700位是900个100-999的三位数。由于811&lt;2700,所以 第811位是某个三位数中的一位。由于811=270x3+1,这意味着第811位是 从100开始的第270个数字即370的中间一位，也就是7。</p>
<pre><code>int digitAtIndex(int index)
{
	if(index &lt; 0)
		return -1;

	int digits = 1;
	while(true)
	{
		int numbers = countOfIntegers(digits);
		if(index &lt; numbers * digits)
			return digitAtIndex(index, digits);

		index -= digits * numbers;
		digits++;
	}

	return -1;
}

int countOfIntegers(int digits)
{
	if(digits == 1)
		return 10;

	int count = (int) std::pow(10, digits - 1);
	return 9 * count;
}

int digitAtIndex(int index, int digits)
{
	int number = beginNumber(digits) + index / digits;
	int indexFromRight = digits - index % digits;
	for(int i = 1; i &lt; indexFromRight; ++i)
		number /= 10;
	return number % 10;
}

int beginNumber(int digits)
{
	if(digits == 1)
		return 0;

	return (int) std::pow(10, digits - 1);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math 题17:打印1到最大的n位数]]></title>
        <id>https://lixin-scut.github.io//post/math-ti-17da-yin-1-dao-zui-da-de-n-wei-shu</id>
        <link href="https://lixin-scut.github.io//post/math-ti-17da-yin-1-dao-zui-da-de-n-wei-shu">
        </link>
        <updated>2020-03-05T00:12:17.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>输入数字n，按顺序打印出从1最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数即999。</p>
</blockquote>
<p>书本题解：</p>
<blockquote>
<p>  如果面试题是关于n位的整数并且没有限定n的取值范围，或者输入任意大小的整数，那么这道题目很有可能是需要考虑大数问题的 字符串 是一种简单、有效地表示大数的方法<br>
  如果我们在数字前面补0,就会发现n位所有十进制数其实就是n个从0到9 的全排列。也就是说，我们把数字的每一位都从0到9排列一遍，就得到 了所有的十进制数。只是在打印的时候，排在前面的。不打印出来罢了。<br>
  全排列用递归很容易表达，数字的每一位都可能是0〜9中的一个数， 然后设置下一位。递归结束的条件是我们已经设置了数字的最后一位。<br>
  定义了函数PrintNumbur,在这个函数里，只有在碰到第一个非0的字符之后才开始打印，直至字符串的结尾。</p>
</blockquote>
<pre><code>void Print1ToMaxOfNDigits_2(int n)
{
    if (n &lt;= 0)
        return;

    char* number = new char[n + 1];
    number[n] = '\0';

    for (int i = 0; i &lt; 10; ++i)
    {
        number[0] = i + '0';
        Print1ToMaxOfNDigitsRecursively(number, n, 0);
    }

    delete[] number;
}

void Print1ToMaxOfNDigitsRecursively(char* number, int length, int index)
{
    if (index == length - 1)
    {
        PrintNumber(number);
        return;
    }

    for (int i = 0; i &lt; 10; ++i)
    {
        number[index + 1] = i + '0';
        Print1ToMaxOfNDigitsRecursively(number, length, index + 1);
    }
}

// 字符串number表示一个数字，数字有若干个0开头
// 打印出这个数字，并忽略开头的0
void PrintNumber(char* number)
{
    bool isBeginning0 = true;
    int nLength = strlen(number);

    for (int i = 0; i &lt; nLength; ++i)
    {
        if (isBeginning0 &amp;&amp; number[i] != '0')
            isBeginning0 = false;

        if (!isBeginning0)
        {
            printf(&quot;%c&quot;, number[i]);
        }
    }

    printf(&quot;\t&quot;);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux/Unix常用命令]]></title>
        <id>https://lixin-scut.github.io//post/linuxunix-chang-yong-ming-ling</id>
        <link href="https://lixin-scut.github.io//post/linuxunix-chang-yong-ming-ling">
        </link>
        <updated>2020-03-04T10:56:52.000Z</updated>
        <content type="html"><![CDATA[<p>这篇博文主要是为了方便自己查看常用命令，并总结一些已有命令的特点和详情。<br>
因为我常用的的系统是macOS和Ubuntu（或者CentOS），所以某些细节可能会有出入</p>
<h2 id="日常管理用命令">日常管理用命令</h2>
<p><strong>ps</strong><br>
观察系统所有的进程数据[root@study ~]# ps aux<br>
也是能够观察所有系统的数据[root@study ~]# ps -lA<br>
连同部分进程树状态[root@study ~]# ps axjf<br>
仅观察自己的 bash 相关进程： ps -l<br>
选项与参数:<br>
-A :所有的 process 均显示出来，与 -e 具有同样的效用; -a :不与 terminal 有关的所有 process ;<br>
-u :有效使用者 (effective user) 相关的 process ; x :通常与 a 这个参数一起使用，可列出较完整信息。 输出格式规划:<br>
l :较长、较详细的将该 PID 的的信息列出;<br>
j :工作的格式 (jobs format) -f :做一个更为完整的输出。</p>
<p><strong>top</strong><br>
动态观察进程的变化<br>
top 预设使用 CPU 使用率 (%CPU) 作为排序的重点，如果你想要使用内存使用率排序，则可以按 下『M』<br>
选项与参数:<br>
-d :后面可以接秒数，就是整个进程画面更新的秒数。预设是 5 秒;<br>
-b :以批次的方式执行 top ，还有更多的参数可以使用喔! 通常会搭配数据流重导向来将批次的结果输出成为文件。<br>
-n :与 -b 搭配，意义是，需要进行几次 top 的输出结果。 -p :指定某些个 PID 来进行观察监测而已。<br>
在 top 执行过程当中可以使用的按键指令:<br>
? :显示在 top 当中可以输入的按键指令; P :以 CPU 的使用资源排序显示;<br>
M :以 Memory 的使用资源排序显示;<br>
N :以 PID 来排序喔!<br>
T :由该 Process 使用的 CPU 时间累积 (TIME+) 排序。 k :给予某个 PID 一个讯号 (signal)<br>
r :给予某个 PID 重新制订一个 nice 值。 q :离开 top 软件的按键。</p>
<h2 id="vim编辑命令">VIM编辑命令</h2>
<h2 id="网络检测专用命令">网络检测专用命令</h2>
<h2 id="命令详解">命令详解</h2>
<p><strong>ps</strong><br>
将某个时间点的进程运作情况撷取下来<br>
选项与参数：<br>
-A ：所有的 process 均显示出来，与 -e 具有同样的效用；<br>
-a ：不与 terminal 有关的所有 process ；<br>
-u ：有效使用者 (effective user) 相关的 process ；<br>
x ：通常与 a 这个参数一起使用，可列出较完整信息。<br>
输出格式规划：<br>
l ：较长、较详细的将该 PID 的的信息列出；<br>
j ：工作的格式 (jobs format)<br>
-f ：做一个更为完整的输出。<br>
观察系统所有的进程数据[root@study ~]# ps aux<br>
也是能够观察所有系统的数据[root@study ~]# ps -lA<br>
连同部分进程树状态[root@study ~]# ps axjf</p>
<p>重点：<br>
只能查阅自己 bash 进程的『 ps -l 』<br>
可以查阅所有系统运作的进程『 ps aux 』</p>
<p>但是ps -l 与 ps aux 显示的项目并不相同</p>
<p>仅观察自己的 bash 相关进程： ps -l<br>
F：代表这个进程旗标 (process flags)，说明这个进程的总结权限，常见号码有：<br>
若为 4 表示此进程的权限为 root ；<br>
若为 1 则表示此子进程仅进行复制(fork)而没有实际执行(exec)。<br>
 S：代表这个进程的状态 (STAT)，主要的状态有：<br>
R (Running)：该程序正在运作中；<br>
S (Sleep)：该程序目前正在睡眠状态(idle)，但可以被唤醒(signal)。<br>
D ：不可被唤醒的睡眠状态，通常这支程序可能在等待 I/O 的情况(ex&gt;打印)<br>
T ：停止状态(stop)，可能是在工作控制(背景暂停)或除错 (traced) 状态；<br>
Z (Zombie)：僵尸状态，进程已经终止但却无法被移除至内存外。<br>
 UID/PID/PPID：代表『此进程被该 UID 所拥有/进程的 PID 号码/此进程的父进程 PID 号码』<br>
 C：代表 CPU 使用率，单位为百分比；<br>
 PRI/NI：Priority/Nice 的缩写，代表此进程被 CPU 所执行的优先级，数值越小代表该进程越快被 CPU 执行。详细的 PRI 与 NI 将在下一小节说明。<br>
 ADDR/SZ/WCHAN：都与内存有关，ADDR 是 kernel function，指出该进程在内存的哪个部分，如果是个running 的进程，一般就会显示『 - 』 / SZ 代表此进程用掉多少内存 / WCHAN 表示目前进程是否运作中，同样的， 若为 - 表示正在运作中。<br>
 TTY：登入者的终端机位置，若为远程登录则使用动态终端接口 (pts/n)；<br>
 TIME：使用掉的 CPU 时间，注意，是此进程实际花费 CPU 运作的时间，而不是系统时间；<br>
 CMD：就是 command 的缩写，造成此进程的触发程序之指令为何。</p>
<p>观察系统所有进程： ps aux<br>
各字段的意义为：<br>
 USER：该 process 属于那个使用者账号的？<br>
 PID ：该 process 的进程标识符。<br>
 %CPU：该 process 使用掉的 CPU 资源百分比；<br>
 %MEM：该 process 所占用的物理内存百分比；<br>
 VSZ ：该 process 使用掉的虚拟内存量 (Kbytes)<br>
 RSS ：该 process 占用的固定的内存量 (Kbytes)<br>
 TTY ：该 process 是在那个终端机上面运作，若与终端机无关则显示 ?，另外， tty1-tty6 是本机上面的登<br>
入者进程，若为 pts/0 等等的，则表示为由网络连接进主机的进程。<br>
 STAT：该进程目前的状态，状态显示与 ps -l 的 S 旗标相同 (R/S/T/Z)<br>
 START：该 process 被触发启动的时间；<br>
 TIME ：该 process 实际使用 CPU 运作的时间。<br>
 COMMAND：该进程的实际指令为何？</p>
<p>『僵尸 (zombie) 』进程<br>
造成僵尸进程的成因是因为该进程应该已经执行完毕，或者是因故应该要终止了， 但是该进程的父进程却无法完整的将该进程结束掉，而造成那个进程一直存在内存当中。<br>
如果你发现在某个进程的 CMD 后面还接上<code>&lt;defunct&gt;</code>时，就代表该进程是僵尸进程<br>
重点<br>
不要仅仅将僵尸进程 kill 掉而已，要找出该进程的父进程</p>
<p><strong>top</strong><br>
top 主要分为两个画面，上面的画面为整个系统的资源使用状态，基本上总共有六行， 显示的内容依序是:<br>
 第一行(top...):这一行显示的信息分别为:<br>
o 目前的时间，亦即是 00:53:59 那个项目;<br>
o 开机到目前为止所经过的时间，亦即是 up 6:07, 那个项目;<br>
o 已经登入系统的用户人数，亦即是 3 users, 项目;<br>
o 系统在 1, 5, 15 分钟的平均工作负载。我们在第十五章谈到的 batch 工作方式为负载小于 0.8 就是<br>
这个负载啰!代表的是 1, 5, 15 分钟，系统平均要负责运作几个进程(工作)的意思。 越小代表系统 越闲置，若高于 1 得要注意你的系统进程是否太过繁复了!</p>
<p> 第二行(Tasks...):显示的是目前进程的总量与个别进程在什么状态(running, sleeping, stopped, zombie)。 比较 需要注意的是最后的 zombie 那个数值，如果不是 0 !好好看看到底是那个 process 变成僵尸了吧?<br>
 第三行(%Cpus...):显示的是 CPU 的整体负载，每个项目可使用 ? 查阅。需要特别注意的是 wa 项目，那 个项目代表的是 I/O wait， 通常你的系统会变慢都是 I/O 产生的问题比较大!因此这里得要注意这个项目 耗用 CPU 的资源喔! 另外，如果是多核心的设备，可以按下数字键『1』来切换成不同 CPU 的负载率。<br>
 第四行与第五行:表示目前的物理内存与虚拟内存 (Mem/Swap) 的使用情况。 再次重申，要注意的是 swap 的使用量要尽量的少!如果 swap 被用的很大量，表示系统的物理内存实在不足!<br>
 第六行:这个是当在 top 程序当中输入指令时，显示状态的地方。<br>
至于 top 下半部分的画面，则是每个 process 使用的资源情况。比较需要注意的是:<br>
 PID :每个 process 的 ID 啦!<br>
 USER:该 process 所属的使用者;<br>
 PR :Priority 的简写，进程的优先执行顺序，越小越早被执行;<br>
 NI :Nice 的简写，与 Priority 有关，也是越小越早被执行;<br>
 %CPU:CPU 的使用率;<br>
 %MEM:内存的使用率;<br>
 TIME+:CPU 使用时间的累加;</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[静态链接与动态链接-链接]]></title>
        <id>https://lixin-scut.github.io//post/jing-tai-lian-jie-yu-dong-tai-lian-jie-lian-jie</id>
        <link href="https://lixin-scut.github.io//post/jing-tai-lian-jie-yu-dong-tai-lian-jie-lian-jie">
        </link>
        <updated>2020-03-04T09:23:46.000Z</updated>
        <content type="html"><![CDATA[<h3 id="动态编译与静态编译">动态编译与静态编译</h3>
<ol>
<li>静态编译，编译器在编译可执行文件时，把需要用到的对应动态链接库中的部分提取出来，连接到可执行文件中去，使可执行文件在运行时不需要依赖于动态链接库；</li>
<li>动态编译的可执行文件需要附带一个动态链接库，在执行时，需要调用其对应动态链接库的命令。所以其优点一方面是缩小了执行文件本身的体积，另一方面是加快了编译速度，节省了系统资源。缺点是哪怕是很简单的程序，只用到了链接库的一两条命令，也需要附带一个相对庞大的链接库；二是如果其他计算机上没有安装对应的运行库，则用动态编译的可执行文件就不能运行。</li>
</ol>
<h3 id="动态链接和静态链接区别">动态链接和静态链接区别</h3>
<ol>
<li>静态连接库就是把(lib)文件中用到的函数代码直接链接进目标程序，程序运行的时候不再需要其它的库文件；动态链接就是把调用的函数所在文件模块（DLL）和调用函数在文件中的位置等信息链接进目标程序，程序运行的时候再从DLL中寻找相应函数代码，因此需要相应DLL文件的支持。</li>
<li>静态链接库与动态链接库都是共享代码的方式，如果采用静态链接库，则无论你愿不愿意，lib 中的指令都全部被直接包含在最终生成的 EXE 文件中了。但是若使用 DLL，该 DLL 不必被包含在最终 EXE 文件中，EXE 文件执行时可以“动态”地引用和卸载这个与 EXE 独立的 DLL 文件。</li>
<li>静态链接库和动态链接库的另外一个区别在于静态链接库中不能再包含其他的动态链接库或者静态库，而在动态链接库中还可以再包含其他的动态或静态链接库。</li>
<li>动态库就是在需要调用其中的函数时，根据函数映射表找到该函数然后调入堆栈执行。如果在当前工程中有多处对dll文件中同一个函数的调用，那么执行时，这个函数只会留下一份拷贝。但是如果有多处对lib文件中同一个函数的调用，那么执行时，该函数将在当前程序的执行空间里留下多份拷贝，而且是一处调用就产生一份拷贝。</li>
</ol>
<p>参考资料：<br>
《深入了解计算机系统》</p>
<h3 id="链接">链接</h3>
<p>  链接(linking)是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文 件可被加载(复制)到内存并执行。链接可以执行于编'译时(compile time),也就是在源代 码被翻译成机器代码时；也可以执行于加载时(load time),也就是在程序被加载器(loader)加载到内存并执行时；甚至执行于运行时(run time),也就是由应用程序来执行。在早 期的计算机系统中，链接是手动执行的。在现代系统中，链接是由叫做链接器(linker)的 程序自动执行的。<br>
  链接器使得分离编译(separate compilation) 成为可能。我们不用将一个大型的应用程序组织为一个巨大的源文件，而是可以 把它分解为更小、更好管理的模块，可以独立地修改和编译这些模块。当我们改变这些模块中的一个时，只需简单地重新编译它，并重新链接应用，而不必重新编译其他文件。</p>
<h3 id="编译器">编译器</h3>
<p>  编译系统提供编译器驱动程序(compiler driver),它代表用户在需要时调用语言预处理器、编译器、汇编器和链接器。<br>
<img src="https://lixin-scut.github.io//post-images/1583314062138.png" alt=""></p>
<ol>
<li>驱动程序首先运行C预处理器(cpp) ,它将C的源程序main. c翻译成一个ASCII码的中间文件main.i。</li>
<li>驱动程序运行C编译器(ccl)，它将main.i翻译成一个ASCII汇编语言文件main.s:</li>
<li>驱动程序运行汇编器(as)，它将main.s翻译成一个可重定位目标文件(relocatable object file)main.o</li>
<li>最后，它运行链接器程序Id,将main.o和 sum.o以及一些必要的系统目标文件组合起来，创建一个可执行目标文件(executable object file)prog</li>
</ol>
<h3 id="静态链接">静态链接</h3>
<p>  静态链接器(static linker)以一组可重定位目标文件和命令行 参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。输入的可重定位目标文件由各种不同的代码和数据节(section)组成，每一节都是一个连续的字节序列。<br>
为了构造可执行文件，链接器必须完成两个主要任务：<br>
  •符号解析(symbol resolution) o目标文件定义和引用符号，每个符号对应于一&quot;函 数、一个全局变量或一个静态变量(即C语言中任何以static属性声明的变量)。 符号解析的目的是将每个符号引用正好和一个符号定义关联起来。<br>
  •重定位(relocation) o编译器和汇编器生成从地址0开始的代码和数据节。链接器通 过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对 这些符号的引用，使得它们指向这个内存位置。链接器使用汇编器产生的重定位条 目(relocation entry)的详细指令，不加甄别地执行这样的重定位。<br>
  记住关于链接器的一 些基本事实：目标文件纯粹是字节块的集合。链接器将这些块连接起来，确 定被连接块的运行时位置，并且修改代码和数据块中的各种位置。</p>
<h3 id="目标文件">目标文件</h3>
<p>目标文件有三种形式：<br>
  •可重定位目标文件。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。<br>
  •可执行目标文件。包含二进制代码和数据，其形式可以被直接复制到内存并执行。<br>
  •共享目标文件。一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。<br>
  编译器和汇编器生成可重定位目标文件(包括共享目标文件)。链接器生成可执行目标文 件。从技术上来说，一个目标模块(object module)就是一哥字节序列，而一个目标文件(object file) 就是一个以文件形式存放在磁盘中的目标模块。不过，我们会互换地使用这些术语。<br>
  目标文件是按照特定的目标文件格式来组织的，各个系统的目标文件格式都不相同。</p>
<h3 id="静态库">静态库</h3>
<p>  所有的编译系统都提供一种机制，将所有相关的目标模块打包成为一个单独的文件，称为静态库(static library),它可以用做链接器的输入。 当链接器构造一个输出的可执行文件时，它只复制静态库里被应用程序引用的目标模块。<br>
静态库相关的函数可以被编译为独'切的 目标模块，然后封装成一个单独的静态库文件。然后，应用程序可以通过在命令行上指定 单独的文件名字来使用这些在库中定义的函数。<br>
  在链接时，链接器将只复制被程序引用的目标模块，这就减少了可执行文件在磁盘和内 存中的大小。另一方面，应用程序员只需要包含较少的库文件的名字<br>
  在Linux系统中，静态库以一种称为存档（archive）的特殊文件格式存放在磁盘中。存 档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置。存档文件名由后缀.a标识。<br>
<img src="https://lixin-scut.github.io//post-images/1583314592237.png" alt=""></p>
<h3 id="链接器如何使用静态库来解析引用">链接器如何使用静态库来解析引用</h3>
<p>  虽然静态库很有用，但是它们同时也是一个程序员迷惑的源头，原因在于Linux链接 器使用它们解析外部引用的方式。在符号解析阶段，链接器从左到右按照它们在编译器驱 动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件。（驱动程序自动将命令 行中所有的.c文件翻译为.o文件。）在这次扫描中，链接器维护一个可重定位目标文件的 集合E（这个集合中的文件会被合并起来形成可执行文件），一个未解析的符号（即引用了 但是尚未定义的符号）集合U,以及一个在前面输入文件中已定义的符号集合初始时，<br>
E、U和D均为空。<br>
  •对于命令行上的每个输入文件f，链接器会判断f是一个目标文件还是一个存档文件。如果是一个目标文件，那么链接器把f添加到E,修改U和D来反映中 的符号定义和引用，并继续下一个输入文件。<br>
  ・如果f是一个存档文件，那么链接器就尝试匹配U中未解析的符号和由存档文件成员定 义的符号。如果某个存档文件成员％,定义了一个符号来解析U中的一个引用，那么就 将m加到E中，并且链接器修改U和。来反映〃中的符号定义和引用。对存档文件中 所有的成员目标文件都依次进行这个过程，直到U和。都不再发生变化。此时，任何不 包含在E中的成员目标文件都简单地被丢弃，而链接器将继续处理下一个输入文件。<br>
  •如果当链接器完成对命令行上输入文件的扫描后，U是非空的，那么链接器就会输出一 个错误并终止玄否则，它会合并和重定位E中的目标文件，构建输出的可执行文件。<br>
  不幸的是，这种算法会导致一些令人困扰的链接时错误，因为命令行上的库和目标文 件的顺序非常重要。在命令行中，如果定义一个符号的库出现在引用这个符号的目标文件 之前，那么引用就不能被解析，链接会失败。<br>
  关于库的一般准则是将它们放在命令行的结尾。如果各个库的成员是相互独立的（也 就是说没有成员引用另一个成员定义的符号），那么这些库就可以以任何顺序放置在命令 行的结尾处。另一方面，如果库不是相互独立的，那么必须对它们排序，使得对于每个被 存档文件的成员外部引用的符号S,在命令行中至少有一个S的定义是在对S的引用之后 的。</p>
<h3 id="重定位">重定位</h3>
<p>  一旦链接器完成了符号解析这一步，就把代码中的每个符号引用和正好一个符号定义 （即它的一个输入目标模块中的一个符号表条目）关联起来。此时，链接器就知道它的输入 目标模块中的代码节和数据节的确切大小。现在就可以开始重定位步骤了，在这个步骤 中，将合并输入模块，并为每个符号分配运行时地址。重定位由两步组成：<br>
  •重定位节和符号定义。在这一步中，链接器将所有相同类型的节合并为同一类型的 新的聚合节。例如，来自所有输入模块的.data节被全部合并成一个节，这个节成 为输出的可执行目标文件的.data节。然后，链接器将运行时内存地址赋给新的聚 合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步 完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了。<br>
  •重定位节中的符号引用。在这一步中，链接器修改代码节和数据节中对每个符号的 引用，使得它们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目 标模块中称为重定位条目（relocation entry）的数据结构，我们接下来将会描述这种 数据结构。</p>
<h3 id="动态链接共享库">动态链接共享库</h3>
<p>  静态库仍然有一些明显的缺点。静态库和所有的软件一样，需要定期维护 和更新。<br>
  共享库(shared library)是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接 起来。这个过程称为动态链接(dynamic linking),是由一个叫做动态链接器(dynamic linker) 的程序来执行的。共享库也称为共享目标(shared object),在Linux系统中通常用.s后缀<br>
共  享库是以两种不同的方式来“共享&quot;的。首先，在任何给定的文件系统 中，对于一个库只有一个.s文件。所 有引用该库的可执行目标文件共享这个. s文件中的代码和数据，而不是像静态库的内容那样被复制和嵌入到引用它们的可执行的文件中。其次，在内存中一个共享库的.text节的一个副本可以 被不同的正在运行的进程共享。<br>
<img src="https://lixin-scut.github.io//post-images/1583314987298.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1583315044588.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线程同步机制]]></title>
        <id>https://lixin-scut.github.io//post/tong-bu-ji-zhi</id>
        <link href="https://lixin-scut.github.io//post/tong-bu-ji-zhi">
        </link>
        <updated>2020-03-04T07:42:34.000Z</updated>
        <content type="html"><![CDATA[<p>同步机制：<br>
信号量、管程、互斥是进程的同步机制，而信号量、互斥也可用于线程的同步，但管程只在进程同步中被用到；<br>
线程的同步除了信号量、互斥外，还有临界区、事件，没有看到教材上将这两种方式作为进程的同步方式；</p>
<p>线程同步同步是指多线程通过特定的设置来控制线程之间的执行顺序，也可以说在线程之间通过同步建立起执行顺序的关系；</p>
<p>线程同步</p>
<ol>
<li>主要的四种方式，临界区、互斥对象、信号量、事件对象；其中临界区和互斥对象主要用于互斥控制，信号量和事件对象主要用于同步控制；</li>
<li>临界区：对共享内存进行访问的程序片段称作临界区。<br>
通过对多线程的串行化来访问公共资源或一段代码，速度快、适合控制数据访问。在任意一个时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。</li>
<li>互斥对象：互斥对象和临界区很像，采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程同时访问。当前拥有互斥对象的线程处理完任务后必须将线程交出，以便其他线程访问该资源。<br>
比如：互斥锁、条件变量、读写锁、自旋锁</li>
<li>信号量：它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。在用CreateSemaphore()创建信号量时即要同时指出允许的最大资源计数和当前可用资源计数。一般是将当前可用资源计数设置为最 大资源计数，每增加一个线程对共享资源的访问，当前可用资源计数就会减1 ，只要当前可用资源计数是大于0 的，就可以发出信号量信号。但是当前可用计数减小 到0 时则说明当前占用资源的线程数已经达到了所允许的最大数目，不能在允许其他线程的进入，此时的信号量信号将无法发出。线程在处理完共享资源后，应在离 开的同时通过ReleaseSemaphore （）函数将当前可用资源计数加1 。在任何时候当前可用资源计数决不可能大于最大资源计数。</li>
<li>事件对象：通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[快速排序]]></title>
        <id>https://lixin-scut.github.io//post/kuai-su-pai-xu</id>
        <link href="https://lixin-scut.github.io//post/kuai-su-pai-xu">
        </link>
        <updated>2020-03-04T03:03:04.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://lixin-scut.github.io/post/pai-xu-suan-fa/">排序算法及其实现</a></p>
<p>  快速排序应该是我用得最多的一个排序算法了，很早之前就实现过了，具体可以参考<a href="https://lixin-scut.github.io/post/kuai-su-pai-xu-fa-shi-xian/">快速排序法实现</a><br>
当然排版比较辣眼hhh，现在就当作整理和总结吧</p>
<p>  希尔排序相当于直接插入排序的升级，它们同属于插入排序类，堆排序相当于简单选择排序的升级，它们同属于选择排序类。而快速排序其实就是我们前面认为最慢的冒泡排序的升级，它们都属于交换排序类。它也是通过不断比较和移动交换来实现排序的，只不过它的实现，增大了记录的比较和移动的距离</p>
<p>  快速排序（QuickSort）的基本思想是：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序</p>
<pre><code>class QuickSort
{
public:
    void QuickSort0(vector&lt;int&gt; &amp;numbers);

private:
    void QuickSort0(vector&lt;int&gt; &amp;numbers, int beg, int end);
    int Partition(vector&lt;int&gt; &amp;numbers, int beg, int end);
};

void QuickSort::QuickSort0(vector&lt;int&gt; &amp;numbers)
{
    int length = numbers.size();
    QuickSort0(numbers, 0, length-1);
    print(numbers);
}

void QuickSort::QuickSort0(vector&lt;int&gt; &amp;numbers, int beg, int end)
{
    if(beg &lt; end)
    {
        int mid = Partition(numbers, beg, end);
        QuickSort0(numbers, beg, mid-1);
        QuickSort0(numbers, mid+1, end);
    }
}

int QuickSort::Partition(vector&lt;int&gt; &amp;numbers, int beg, int end)
{
        int pivotKey = numbers[beg];
        while(beg &lt; end)
        {
            while(beg &lt; end &amp;&amp; numbers[end] &gt;= pivotKey)
            { --end; }
           swap(numbers[beg] , numbers[end]);
            while(beg &lt; end &amp;&amp; numbers[beg] &lt;= pivotKey)
            { ++beg; }
            swap(numbers[beg] , numbers[end]);
        }
				return beg;
}
</code></pre>
<p>这里需要注意几点</p>
<ol>
<li>我使用下标法，所以可以mid-1、mid+1，迭代器就无法这么干，迭代器是不可以指向容器外的位置的，不能指向begin之前</li>
<li>比较时一定是 &gt;=和&lt;=，一定不能忘记判断等于，否则会陷入死循环</li>
<li>我其实做了一点优化，本来可以直接 <code>swap(numbers[beg] , numbers[end]);</code>，我直接把它留到了最后再赋值。</li>
<li>定义pivotKey，用于比较pivotkey&lt;=vi[high]</li>
<li>先--end再到++beg，不能弄反了</li>
<li>记得return beg;</li>
<li>每个while都必须判断low&lt;high，特别是循环中的两个while</li>
</ol>
<h3 id="快速排序复杂度分析">快速排序复杂度分析</h3>
<p>  快速排序的时间性能取决于快速排序递归的深度<br>
  在最优情况下，Partition每次都划分得很均匀，如果排序n个关键字，其递归树的深度就为floor(logn)+1，所以在最优的情况下，快速排序算法的时间复杂度为O(nlogn)<br>
  而在最坏的情况下，待排序的序列为正序或者逆序，每次划分只得到一个比上一次划分少一个记录的子序列（注意另一个为空，亦即只有左子树或者右子树）， 时间复杂度为O(n^2)。<br>
  空间复杂度来说，主要是递归造成的栈空间的使用，最好情况，递归树的深度为logn，其空间复杂度也就为O(logn)，最坏情况需要进行n-1次递归调用，其空间复杂度为〇(n),平均情况，空间复杂度也为〇(logn)。<br>
  由于关键字的比较和交换是跳跃进行的，因此，快速排序是一种不稳定的排序方法。</p>
<h3 id="优化">优化：</h3>
<ol>
<li>优化不必要的交换<br>
  关键字的最终目标就是beg==end的时候,当中的交换其实是不需要的。因此我们对Partition函数的代码再进行优化。</li>
</ol>
<pre><code>int QuickSort::Partition(vector&lt;int&gt; &amp;numbers, int beg, int end)
{
        int pivotKey = numbers[beg];
        while(beg &lt; end)
        {
            while(beg &lt; end &amp;&amp; numbers[end] &gt;= pivotKey)
            { --end; }
            numbers[beg] = numbers[end];
            while(beg &lt; end &amp;&amp; numbers[beg] &lt;= pivotKey)
            { ++beg; }
            numbers[end] = numbers[beg];
        }
        numbers[beg] = pivotKey;
        return beg;
}
</code></pre>
<ol start="2">
<li>优化选取枢轴<br>
  三数取中（median-of-three)法。即取三个关键字先进行排序，将中间数作为枢轴，一般是取左端、右端和中间三个数，也可以随机选取。这样至少这个中间数一定不会是最小或者最大的数<br>
  九数取中,它先从数组中分三次取样，每次取三个数，三个样品各取出中数，然后从这三个中数当中再取出一个中数作为枢轴。</li>
</ol>
<pre><code>        int pivotKey ;

        int mid = beg + (end - beg) / 2;

        if(numbers[beg] &gt; numbers[end])
        { swap(numbers[beg], numbers[end]); }
        if(numbers[mid] &gt; numbers[end])
        { swap(numbers[mid], numbers[end]); }
        if(numbers[mid] &gt; numbers[beg])
        { swap(numbers[beg], numbers[mid]); }
        
        pivotKey = numbers[beg];
</code></pre>
<ol start="3">
<li>
<p>优化小数组时的排序方案<br>
  如果数组非常小，其实快速排序反而不如直接插入排序来得更好（直接插入是简单排序中性能最好的）。其原因在于快速排序用到了递归操作.<br>
此处估计是参考了<a href="https://lixin-scut.github.io/post/stl-sortdi-ceng-shi-xian/">STL的sort()</a>影响hhh，但是这个数组长度阈值不好确定，得参考实际情况</p>
</li>
<li>
<p>优化递归操作<br>
  QSort函数在其尾部有两次递归操作。如果待排序的序列划分极端不平衡，递归深度将趋近于n,而不是平衡时的logn（也就是每次都只取到边界值为pivotKey）<br>
  栈的大小是很有限的，每次递归调用都会耗费—定的栈空间，函数的参数越多，每次递归耗费的空间也越多。因此如果能减少递归，将会大大提高性能。</p>
</li>
</ol>
<pre><code>void QuickSort::QuickSort0(vector&lt;int&gt; &amp;numbers, int beg, int end)
{
    if(beg &lt; end)
    {
        while(beg &lt; end){
            int mid = Partition(numbers, beg, end);
            QuickSort0(numbers, beg, mid-1);
            beg = mid+1;
        }
    }
}
</code></pre>
<p>  当我们将if改成while后，因为第一次递归以后，变量low就没有用处了，所以可以将pivot+1赋值给low，再循环后，来一次Partition(L,low,high),其效果等同于QSort(L，pivot+1,high);结果相同，但因采用迭代而不是递归的方法可以缩减堆栈深 度，从而提高了整体性能。<br>
  相当于处理好了1/2再对剩下的1/2进行处理</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ 题1:赋值运算符函数]]></title>
        <id>https://lixin-scut.github.io//post/c-ti-1fu-zhi-yun-suan-fu-han-shu</id>
        <link href="https://lixin-scut.github.io//post/c-ti-1fu-zhi-yun-suan-fu-han-shu">
        </link>
        <updated>2020-03-04T00:04:14.000Z</updated>
        <content type="html"><![CDATA[<p>题目：如下为类型CMyString的声明，请为该类型添加赋值运算符函数。</p>
<pre><code>class CMyString
{
public:
		CMyString(char  pData = nullptr);
		CMyString(const CMyString&amp; str);
		~CMyString(void);

private:
		char* m_pData;
}
</code></pre>
<p>关注如下几点：</p>
<ol>
<li>是否把返回值的类型声明为该类型的引用，并在函数结束前返回实 例自身的引用(*this)。只有返回一个引用，才可以允许连续赋值。</li>
<li>是否把传入的参数的类型声明为常量引用。如果传入的参数不是引 用而是实例，那么从形参到实参会调用一次复制构造函数。把参数 声明为引用可以避免这样的无谓消耗，能提高代码的效率。同时， 我们在赋值运算符函数内不会改变传入的实例的状态，因此应该为 传入的引用参数加上const关键字。</li>
<li>是否释放实例自身已有的内存。如果我们忘记在分配新内存之前释 放自身己有的空间，则程序将出现内存泄漏。</li>
<li>
<pre><code>判断传入的参数和当前的实例(\this)是不是同一个实例。如果是同一个则不进行赋值操作，直接返回。如果事先不判断就进行赋值，那么在释放实例自身内存的时候就会导致严重的问题：当\*this 和传入的参数是同一个实例时，一旦释放了自身的内存，传入的参数的内存也同时被释放了，因此再也找不到需要赋值的内容了。
</code></pre>
</li>
</ol>
<p>初级解法</p>
<pre><code>CMyString&amp; CMyString::operator = (const CMyString&amp; str)
{
    if(this == &amp;str)
        return *this;

    delete []m_pData;
    m_pData = nullptr;

    m_pData = new char[strlen(str.m_pData) + 1];
    strcpy(m_pData, str.m_pData);

    return *this;
}
</code></pre>
<p>  在前面的函数中，我们在分配内存之前先用delete释放了实例m_pData的内存。如果此时内存不足导致new char抛出异常，则m_pData将是一个 空指针，这样非常容易导致程序崩溃。也就是说，一旦在赋值运算符函数内部抛出一个异常，CMyString的实例不再保持有效的状态，这就违背了异常安全性(Exception Safety)原则。<br>
  要想在赋值运算符函数中实现异常安全性，我们有两种方法。一种简单的办法是我们先用new分配新内容，再用delete释放已有的内容。这样只在分配内容成功之后再释放原来的内容，也就是当分配内存失败时我们 能确保CMyString的实例不会被修改。我们还有一种更好的办法，即先创建一个临时实例，再交换临时实例和原来的实例。下面是这种思路的参考 代码：</p>
<pre><code>CMyString&amp; CMyString::operator =(const CMyString&amp; str)
{
		if(this!= &amp;str)
		{
				CMyString strTemp(str);
				
				char* pTemp = strTemp.m_pData;
				strTemp.m_pData = m_pData;
				m_pData = pTemp;
		}
		return *this;
}
</code></pre>
<p>  在新的代码中，我们在CMyString的构造函数里用new分配内存。如果由于内存不足抛出诸如bad_alloc等异常，但我们还没有修改原来实例的状态，因此实例的状态还是有效的，这也就保证了异常安全性。<br>
  在这个函数中，我们先创建一个临时实例strTemp,接着把strTemp.m_pData和实例自身的m_pData进行交换。由于strTemp是一个局部变量，但 程序运行到if的外面时也就出了该变量的作用域，就会自动调用strTemp 的析构函数，把strTemp.mjData所指向的内存释放掉。由于 strTemp.m_pData指向的内存就是实</p>
<p>使用swap<br>
  为了交换两个对象我们需要进行一次拷贝和两次赋值，但理论上这些内存分配都是不必要的，我们更希望使用swap交换指针，而不是分配对象的新副本<br>
  与拷贝控制成员不同，swap不是必要的，但是对于分配了资源的类，定义swap可能是一种很重要的优化手段</p>
<pre><code>// 特别注意什么时候用传值什么时候用传引用
CMyString&amp; CMyString::operatpr (CMyString str)
{
		swap(*this,str);
		return *this;
}

void CMyString::swap(CMyString&amp; lhs, CMyString&amp; rhs);
</code></pre>
<p>  在上述版本的赋值运算符中，参数并不是一个引用，所以右侧运算对象是以传值方式传递给了赋值运算符。因此rhs是右侧运算对象的一个副本<br>
  在函数体中，rhs获得了*this原来保存的指针，并将rhs 的指针存入了*this。但结束时析构函数会被执行，rhs会被销毁，delete了rhs现在指向的内存，即左侧对象原来指向的内存<br>
  这个技术的有趣之处在于它自动处理了自赋值情况切天然就是异常安全的，通过在改变左侧运算对象之前拷贝右侧运算对象保证了自赋值的正确，代码中唯一可能抛出异常的是拷贝构造函数中的new表达式，如果真的发生了异常，它也会发生在我们改变左侧运算对象之前</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 题45:把数组排成最小的数]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-ti-45</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-ti-45">
        </link>
        <updated>2020-03-03T23:31:11.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
</blockquote>
<p>重点在于比较方法，排序其实可以用快排来实现<br>
然后需要注意的是：<br>
注意：比较函数必须写在类外部（全局区域）或声明为静态函数<br>
当lessthan作为类的成员函数时，默认拥有一个this指针，这样和sort函数所需要使用的排序函数类型不一样。<br>
否则，会出现<code>&lt;unresolved overloaded function type&gt;</code>错误</p>
<pre><code>class Solution {
public:
    string PrintMinNumber(vector&lt;int&gt; numbers) {
        string res;
        if(numbers.empty())
            return res;
        vector&lt;string&gt; numbers_str;
        for(auto num:numbers){
            numbers_str.push_back(to_string(num));
        }
        sort(numbers_str.begin(),numbers_str.end(),LessThen);
        
        for(auto str:numbers_str){
            res+=str;
        }
        return res;
    }
    
    static bool LessThen(string s1,string s2){
        return s1+s2&lt;s2+s1;
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>  这道题其实是希望我们能找到一个排序规则，数组根据这个规则排序之后能排成一个最小的数字。要确定排序规则，就要比较两个数字，也就 是给出两个数字m和n，我们需要确定一个规则判断m和n哪个应该排在 前面，而不是仅仅比较这两个数字的值哪个更大。<br>
  根据题目的要求，两个数字m和n能拼接成数字mn和nm，如果mn&lt;nm, 那么我们应该打印出mn,也就是m应该排在n的前面，我们定义此时m小于n；反之，如果nm&lt;mn则我们定义m小于n；如果mn=nm,则m等于n。在下文中，符号“&lt;”、&quot;&gt;”及“=”表示常规意义的数值的大小关系, 而文字&quot;大于”、“小于”、“等于”表示我们新定义的大小关系。<br>
  接下来考虑怎么去拼接数字，即给出数字m和n，怎么得到数字mn和 nm并比较它们的大小。直接用数值去计算不难办到，但需要考虑的一个潜在问题就是m和n都在int型能表达的范围内，但把它们拼接起来的数字 mn和nm用int型表示就有可能溢出了，所以这还是一个隐形的大数问题。<br>
  一个非常直观的解决大数问题的方法就是把数字转换成字符串。另外, 由于把数字m和n拼接起来得到mn和mn,它们的位数肯定是相同的，因此比较它们的大小只需要按照字符串大小的比较规则就可以了。<br>
  我们先把数组中的整数转换成字符串，然后在函数compare中定义比较规则，并根据该规则调用库函数qsort排序，最后把排 好序的数组中的数字依次打印出来，就是该数组中数字能拼接出来的最小数字。这种思路的时间复杂度和qsort的时间复杂度相同，也就是O(nlogM), 这比用n!的时间求出所有排列的思路要好很多。</p>
</blockquote>
<pre><code>int compare(const void* strNumber1, const void* strNumber2);

// int型整数用十进制表示最多只有10位
const int g_MaxNumberLength = 10;
 
char* g_StrCombine1 = new char[g_MaxNumberLength * 2 + 1];
char* g_StrCombine2 = new char[g_MaxNumberLength * 2 + 1];
 
void PrintMinNumber(const int* numbers, int length)
{
    if(numbers == nullptr || length &lt;= 0)
        return;
 
    char** strNumbers = (char**)(new int[length]);
    for(int i = 0; i &lt; length; ++i)
    {
        strNumbers[i] = new char[g_MaxNumberLength + 1];
        sprintf(strNumbers[i], &quot;%d&quot;, numbers[i]);
    }
 
    qsort(strNumbers, length, sizeof(char*), compare);
 
    for(int i = 0; i &lt; length; ++i)
        printf(&quot;%s&quot;, strNumbers[i]);
    printf(&quot;\n&quot;);
 
    for(int i = 0; i &lt; length; ++i)
        delete[] strNumbers[i];
    delete[] strNumbers;
}
 
// 如果[strNumber1][strNumber2] &gt; [strNumber2][strNumber1], 返回值大于0
// 如果[strNumber1][strNumber2] = [strNumber2][strNumber1], 返回值等于0
// 如果[strNumber1][strNumber2] &lt; [strNumber2][strNumber1], 返回值小于0
int compare(const void* strNumber1, const void* strNumber2)
{
    // [strNumber1][strNumber2]
    strcpy(g_StrCombine1, *(const char**)strNumber1);
    strcat(g_StrCombine1, *(const char**)strNumber2);
 
    // [strNumber2][strNumber1]
    strcpy(g_StrCombine2, *(const char**)strNumber2);
    strcat(g_StrCombine2, *(const char**)strNumber1);
 
    return strcmp(g_StrCombine1, g_StrCombine2);
}
</code></pre>
<p><img src="https://lixin-scut.github.io//post-images/1583279065298.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1583279078008.png" alt=""></p>
]]></content>
    </entry>
</feed>