<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-11-28T09:07:18.426Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[ C++ primer 第十八章 笔记+习题 18.3]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-ba-zhang-bi-ji-xi-ti-183</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-ba-zhang-bi-ji-xi-ti-183">
        </link>
        <updated>2019-11-28T02:03:50.000Z</updated>
        <content type="html"><![CDATA[<p>18.3 多重继承与虚继承<br>
多重继承（multiple inheritance)是指从<strong>多个直接基类</strong>（参见15.2.2节，第533页）中产生派生类的能力。多重继承的派生类<strong>继承了所有父类的属性</strong>。</p>
<p>18.3.1 多重继承<br>
在派生类的派生列表中可以包含多个基类：<br>
class Bear : public ZooAnimal{<br>
class Panda : <strong>public Bear, public Endangered</strong><code>{/*...*/};</code><br>
每个基类包含一个可选的访问说明符（参见15.5节，第543页）。一如往常，如果访问说明符被忽略掉了，则关键字<strong>class</strong>对应的默认访问说明符是<strong>private</strong>,关键字<strong>struct</strong>对应的是<strong>public</strong>(参见15.5节，第546巧:）。     和只有一个基类的继承一样，多重继承的<strong>派生列表</strong>也只能包含<strong>已经被定义过的类</strong>，而且这些类<strong>不能final的</strong>（参见15.2.2节，第533页）。对于派生类能够继承的基类个数，C++没有进行特殊规定；但是在某个给定的派生列表中，<strong>同一个基类只能出现一次</strong>。<br>
多重继承的派生类从每个基类中继承状态<br>
在多重继承关系中，<strong>派生类的对象</strong>包含有<strong>每个基类的子对象</strong>（参见15.2.2节，第530页）。</p>
<p>派生类构造函数初始化所有基类<br>
构造函数<strong>从上而下构造</strong><br>
构造一个派生类的对象将<strong>同时构造并初始化</strong>它的<strong>所有基类子对象</strong>。与从一个基类进行的派生一样（参见15.2.2节，第531页），多重继承的派生类的构造函数初始值<strong>也只能初始化它的直接基类</strong>：	<br>
派生类的构造函数初始值列表将实参分别传递给每个直接基类。其中<strong>基类的构造顺序与派生列表中基类的出现顺序保持一致</strong>，而与<strong>派生类构造函数初始值列表中基类的顺序无关</strong>。<br>
继承的构造函数与多重继承<br>
在C++11新标准中，<strong>允许</strong>派生类从它的<strong>一个或几个基类中继承构造函数</strong>（参见15.7.4节，第557页）。但是如果从多个基类中<strong>继承了相同的构造函数</strong>（即<strong>形参列表完全相同</strong>），则程序<strong>将产生错误</strong>：     <strong>如果</strong>一个类从它的多个基类中<strong>继承了相同的构造函数</strong>，则这个类<strong>必须为该构造函数定义它自己的版本</strong>：</p>
<p>析构函数与多重继承<br>
和往常一样，派生类的析构函数只负责清除派生类本身分配的资源，<strong>派生类的成员及基类都是自动销毁的。合成的析构函数体为空</strong>。<br>
<strong>析构函数的调用顺序正好与构造函数相反（派生列表逆序）</strong></p>
<p>多重继承的派生类的拷贝与移动操作<br>
多重继承的派生类如果<strong>定义了自己的拷贝/赋值构造函数和赋值运算符</strong>，则<strong>必须在完整的对象上执行</strong>拷贝、移动或赋值操作<strong>指对基类也要拷贝等</strong>（参见15.7.2节，第553页）。<strong>只有</strong>当派生类使用的是<strong>合成版本</strong>的拷贝、移动或赋值成员时，<strong>才会自动对其基类部分执行</strong>这些操作。在<strong>合成的拷贝控制成员中</strong>，<strong>每个基类分别使用自己的对应</strong>成员<strong>隐式地完成</strong>构造、赋值或销毁等工作。</p>
<p>习题18.21<br>
（a）正确，没有关键词的话 class默认为private<br>
（b）错误，同一个基类不能出现两次<br>
（c）正确<br>
习题18.22<br>
A-B-C-X-Y-Z-MI<br>
不要忘了MI本身</p>
<p>18.3.2 类型转换与多个基类<br>
在<strong>只有一个基类</strong>的情况下，派生类的指针或引用<strong>能自动转换成一个可访问基类</strong>的<strong>指针或引用</strong>（参见15.2.2节，第530页；参见15.5节，第544页）。<strong>多个基类的情况与之类似</strong>。我们可以<strong>令某个可访问基类的指针或引用</strong>直接<strong>指向一个派生类对象</strong>。例如，一个ZooAnimal、Bear或Endangered类型的指针或引用可以绑定到Panda对象上：</p>
<p>编译器<strong>不会在派生类向基类的几种转换中进行比较和选择</strong>，因为在它看来<strong>转换到任意 一种基类都一样好</strong>。<strong>容易产生二义性</strong></p>
<p><strong>对象、指针和引用的静态类型决定了我们能够使用哪些成员</strong>（参见15.6节，第547页）。如果我们使用一个ZooAnimal指针，则只有定义在 ZooAnimal中的操作是可以使用的，Panda接口中的Bear、Panda和Endangered 特有的部分都不可见。类似的，一个Bear类型的指针或引用只能访问Bear及 ZooAnimal的成员，一个Endangered的指针或引用只能访问Endangered的成员。<br>
通过Bear指针访问Panda对象：</p>
<p>习题18.23<br>
应该都是允许的<br>
习题18.24<br>
pirnt可行，用的是panda的print<br>
cuddle不可行<br>
highlight不可行<br>
delete调用的也是panda的析构函数<br>
习题18.25<br>
全都调用了mi的print<br>
然后析构顺序和构造顺序相反<br>
MI-D2-B2-D1-B1</p>
<p>18.3.3 多重继承下的类作用域<br>
在只有一个基类的情况下，派生类的作用域嵌套在直接基类和间接基类的作用域中 (参见15.6节，第547页）。查找过程沿着继承体系自底向上进行，直到找到所需的名字。 派生类的名字将隐藏基类的同名成员。<br>
在<strong>多重继承</strong>的情况下，相同的查找过程在<strong>所有直接基类</strong>中<strong>同时进行</strong>。如果<strong>名字在多个 基类中都被找到</strong>，则对该名字的使用将<strong>具有二义性</strong>。<br>
对于一个派生类来说，从它的几个基类中分别<strong>继承名字相同的成员</strong>是<strong>完全合法</strong>的，只不过在<strong>使用这个名字</strong>时<strong>必须明确指出它的版本</strong>。<br>
当一个类拥有多个基类时，有可能出现派生类从两个或更多基类中继承了同名成员的情况。此时，<strong>不加前缀限定符直接使用</strong>该名字将<strong>引发二义性</strong></p>
<p>有时即使派生类继承的<strong>两个函数形参列表不同</strong>也可能发生错误。此外，即使max_weight在<strong>一个类中是私有的</strong>，而在<strong>另一个类中是公有的或受保护的</strong>同样 <strong>也可能发生错误</strong>。最后一种情况，假如max_weight定义在Bear中而非ZooAnimal 中，上面的程序仍然是错误的。<br>
要想<strong>避免潜在的二义性</strong>，最好的办法是<strong>在派生类中为该函数定义一个新版本</strong>。</p>
<p>习题18.26<br>
错误观点：Base1中的print和Base2中的print都符合条件，具有二义性<br>
正确观点：编译出错的原因并不是由于二义性的原型，因为MI类也定义了<code>print(vector&lt;double&gt;)</code>函数，所以原因是该类的该函数名因此了其基类的函数名，而找到该名字后，进行类型检查由于无法将double转换为<code>vector&lt;double&gt;</code>类型，所以编译器报错。<br>
<strong>因为派生类的作用域嵌套在直接基类和间接基类中，所以基类的同名成员会被隐藏</strong><br>
直接使用Base1::print(42)<br>
习题18.27<br>
因为派生类会隐藏基类中同名对象所以<br>
（a）<br>
MI：ival print dvec<br>
Derived：sval dval<br>
Base2：fval dval<br>
Base1 无（注意被形参中的cval隐藏了）<br>
外层作用域 dval<br>
（b）dval有三个 外层作用域和derived、base2的（注意base2的虽然是private，但是也是可见的）<br>
（c）使用Base1::dval+Derived::dval<br>
（d）fval=dvec.back()<br>
（e）sval[0]=cval</p>
<p>注意的点：Base1的cval注意被形参中的cval隐藏了，base2的虽然是private，但是也是可见的）<br>
重点：<strong>因为派生类的作用域嵌套在直接基类和间接基类中，所以基类的同名成员会被隐藏</strong>，所以要想<strong>避免潜在的二义性</strong>，最好的办法是<strong>在派生类中为该函数定义一个新版本</strong>。</p>
<p>18.3.4 虚继承<br>
尽管在派生列表中同一个基类只能出现一次，但实际上派生类<strong>可以多次继承同一个类</strong>。派生类可以通过它的<strong>两个直接基类分别继承同一个间接基类</strong>，也可以直接继承某个基类，然后通过另一个基类再一次间接继承该类。<br>
在默认情况下，派生类中<strong>含有继承链上每个类对应的子部分</strong>。如果某个类在派生过程中出现了多次，则派生类中<strong>将包含该类的多个子对象</strong>。<strong>但会影响派生类的操作</strong><br>
在C++语言中我们通过<strong>虚继承（virtual inheritance)</strong> 的机制<strong>解决上述问题。</strong> 虚继承的目的是<strong>令某个类做出声明</strong>，<strong>承诺愿意共享它的基类</strong>。其中，<strong>共享的基类子对象</strong>称为<strong>虚基类</strong> (virtual base class)。在这种机制下，不论虚基类在继承体系中<strong>出现了多少次</strong>，在<strong>派生类</strong>中都<strong>只包含唯一一个共享的虚基类子对象</strong>。</p>
<p>另一个Panda类</p>
<p>观察这个新的继承体系，我们将发现虚继承的一个不太直观的特征：<strong>必须在虚派生的真实需求出现前就已经完成虚派生的操作</strong>。例如在我们的类中，当我们定义Panda时才出现了对虚派生的需求，但是如果Bear和Raccoon不是从ZooAnimal虚派生得到的，那么Panda的设计者就显得不太幸运了。<br>
在实际的编程过程中，位于中间层次的基类将其继承声明为虚继承一般不会带来什么 问题。通常情况下，使用虚继承的类层次是由一个人或一个项目组一次性设计完成的。对于一个独立开发的类来说，很少需要基类中的某一个是虚基类，况且新基类的开发者也无法改变己存在的类体系。<br>
<strong>虚派生只影响从指定了虚基类的派生类中进一步派生出的类，它不会影响派生类本身</strong><br>
使用虚基类<br>
我们指定虚基类的方式是<strong>在派生列表中添加关键字virtual</strong><br>
virtual说明符<strong>表明了一种愿望</strong>，即在<strong>后续的派生类</strong>当中共享虚基类的同一份实例。至于什么样的类能够作为虚基类并没有特殊规定。<br>
如果某个类指定了虚基类，则该类的派生仍按常规方式进行：<br>
<strong>不论基类是不是虚基类</strong>，<strong>派生类对象</strong>都能<strong>被可访问基类</strong>的<strong>指针或引用</strong>操作。</p>
<p>虚基类成员的可见性<br>
因为在每个共享的虚基类中<strong>只有唯一一个共享的子对象</strong>，所以该基类的成员<strong>可以被直 接访问</strong>，并且<strong>不会产生二义性</strong>。此外，如果<strong>虚基类的成员</strong>只被<strong>一条派生路径覆盖</strong>.则我们仍然可<strong>直接访问</strong>这个被覆盖的成员。但是如果成员被<strong>多于一个基类（派生？）覆盖</strong>，则一般情况下派生类必须<strong>为该成员自定义一个新的版本</strong>。<br>
<strong>覆盖：D1 D2重新定义了基类的成员</strong></p>
<p>习题18.28<br>
derived1的 bar和 derived2的ival都是可以直接访问的，剩下的都需要限定符来区分</p>
<p>18.3.5 构造函数与虚继承<br>
在虚派生中，<strong>虚基类</strong>是由<strong>最低层的派生类初始化</strong>的。以我们的程序为例，当创建Panda 对象时，由<strong>Panda的构造函数独自控制ZooAnimal的初始化过程</strong>。<br>
为了理解这一规则，我们不妨假设当以<strong>普通规则处理初始化</strong>任务时会发生什么情况。 在此例中，<strong>虚基类</strong>将会在<strong>多条继承路径上被重复初始化</strong>。<br>
当然，继承体系中的<strong>每个类</strong>都可能在<strong>某个时刻</strong>成为&quot;<strong>最低层的派生类</strong>&quot;。只要我们能创建<strong>虚基类的派生类对象</strong>，该派生类的<strong>构造函数就必须初始化它的虚基类</strong>。</p>
<p>虚继承的对象的构造方式<br>
<strong>含有虚基类</strong>的对象的<strong>构造顺序</strong>与<strong>一般的顺序稍有区别</strong>：<strong>首先</strong>使用提供给<strong>最低层派生类 构造函数</strong>的初始值初始化该对象的<strong>虚基类子部分</strong>，接下来按照直接基类在<strong>派生列表中出现的次序依次</strong>对其<strong>进行初始化</strong>。</p>
<p><strong>虚基类总是先于非虚基类构造</strong>，与它们在继承体系中的次序和位置无关（假设bear是虚继承，它也是先于zooanimal？）</p>
<p>构造函数与析构函数的次序<br>
一个类可以有<strong>多个虚基类</strong>。此时，这些<strong>虚的子对象</strong>按照它们在<strong>派生列表中出现的顺序<br>
从左向右依次构造</strong>。</p>
<p><strong>编译器按照</strong>直接基类的<strong>声明顺序</strong>对其<strong>依次进行检査</strong>，以<strong>确定其中是否含有虚基类</strong>。如果有，则<strong>先构造虚基类</strong>，然后<strong>按照声明的顺序</strong>逐一<strong>构造其他非虚基类</strong>。</p>
<p><strong>合成的拷贝和移动构造函数</strong>按照<strong>完全相同的顺序</strong>执行，<strong>合成的赋值运算符</strong>中的成员也<strong>按照该顺序赋值</strong>。和往常一样，对象的<strong>销毁顺序</strong>与<strong>构造顺序正好相反</strong>，首先销毁TeddyBear部分，最后销毁ZooAnimal部分。</p>
<p>习题18.29<br>
（a）构造顺序：Class、Base、D1、D2、MI、Class、Final，析构函数相反<br>
（b）有一个Base两个Class<br>
（c）（a）class 是base的基类（b）具有两个基类，不明确 （c）base是mi的间接基类<br>
注意：1.如果虚基类有基类的话，也需要提前构造 比如Base的Class<br>
2.非虚基类的话会导致重复构造，相应地用一个基类指针或引用去指向的话会导致二义性</p>
<pre><code>struct Base { int i = 0; };
struct D1 :public Base { int i1 = 0; };
struct D2 : public Base { int i2 = 0; };
struct MI :public D1, public D2 { int i3 = 0; };
int main() {
	MI mi1, *mi = &amp;mi1;
	Base *b = mi;//基类Base不明确
}
</code></pre>
<p>习题18.30</p>
<pre><code>class Class {};  
class Base :public Class {  
  
protected:  
    int ival;  
public:  
    Base() :ival(0),Class() {};  
    Base(const Base &amp;b) = default;  
    Base(int a) :ival(a),Class() {}  
};  
class D1 :public virtual Base {  
public:  
    D1() :Base() {}  
    D1(const D1 &amp;b) = default;  
    D1(int a) :Base(a) {}  
};  
class D2 :public virtual Base {  
public:  
    D2() :Base() {}  
    D2(const D2 &amp;b) = default;  
    D2(int a) :Base(a) {}  
};  
class MI :public D1, public D2 {  
public:  
    MI() {}  
    MI(const MI &amp;m) :Base(m), D1(m), D2(m) {}  
    MI(int i) :Base(i), D1(i), D2(i) {}  
};  
class Final :public MI, public Class {  
public:  
    Final() {}  
    Final(const Final &amp;f) : Base(f), MI(f), Class() {}  
    Final(int i) : Base(i), Class() {}  
};  
</code></pre>
<p>习题感悟：<br>
构造顺序不要忘了派生类MI本身<br>
<strong>因为派生类的作用域嵌套在直接基类和间接基类中，所以基类的同名成员会被隐藏</strong>，所以要想<strong>避免潜在的二义性</strong>，最好的办法是<strong>在派生类中为该函数定义一个新版本</strong>。<br>
注意：1.如果虚基类有基类的话，也需要提前构造 比如Base的Class<br>
2.非虚基类的话会导致重复构造，相应地用一个基类指针或引用去指向的话会导致二义性</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Word查找的通配符和特殊字符]]></title>
        <id>https://lixin-ee.github.io//post/word-cha-zhao-de-tong-pei-fu-he-te-shu-zi-fu</id>
        <link href="https://lixin-ee.github.io//post/word-cha-zhao-de-tong-pei-fu-he-te-shu-zi-fu">
        </link>
        <updated>2019-11-28T02:01:38.000Z</updated>
        <content type="html"><![CDATA[<p>通配符主要有：</p>
<p>*代表0至任意个字符；</p>
<p>^?代表任意字符；</p>
<p>^#代表任意数字；</p>
<p>^$代表任意字母；</p>
<p>^&amp;代表查找内容（在替换时使用）。</p>
<p>其他段落标记、人工换行符、制表符等等应该称为特殊字符。</p>
<p>所谓通配就是随意的，如我知道一个单词的第一个字母是B，第三个C，但第二个不知道了，那就搜索B?C</p>
<p>任意单个字符</p>
<p>键入?</p>
<p>例如，s?t可查找“sat”和“set”。</p>
<p>任意字符串</p>
<p>键入*</p>
<p>例如，s*d可查找“sad”和“started”。</p>
<p>单词的开头</p>
<p>键入&lt;</p>
<p>例如，&lt;(inter)查找“interesting”和“intercept”，但不查找“splintered”。</p>
<p>单词的结尾</p>
<p>键入&gt;</p>
<p>例如，(in)&gt;查找“in”和“within”，但不查找“interesting”。</p>
<p>指定字符之一</p>
<p>键入[]</p>
<p>例如，w[io]n查找“win”和“won”。</p>
<p>指定范围内任意单个字符</p>
<p>键入[-]</p>
<p>例如，[r-t]ight查找“right”和“sight”。必须用升序来表示该范围。</p>
<p>中括号内指定字符范围以外的任意单个字符</p>
<p>键入[!x-z]</p>
<p>例如，t[!a-m]ck查找“tock”和“tuck”，但不查找“tack”和“tick”。</p>
<p>n个重复的前一字符或表达式</p>
<p>键入{n}</p>
<p>例如，fe{2}d查找“feed”，但不查找“fed”。</p>
<p>至少n个前一字符或表达式</p>
<p>键入{n,}</p>
<p>例如，fe{1,}d查找“fed”和“feed”。</p>
<p>n到m个前一字符或表达式</p>
<p>键入{n,m}</p>
<p>例如，10{1,3}查找“10”、“100”和“1000”。</p>
<p>一个以上的前一字符或表达式</p>
<p>键入@</p>
<p>例如，lo@t查找“lot”和“loot”。<br>
<img src="https://lixin-ee.github.io//post-images/1574906600032.jpeg" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 109. 有序链表转换二叉搜索树[中等]]]></title>
        <id>https://lixin-ee.github.io//post/shu-109-you-xu-lian-biao-zhuan-huan-er-cha-sou-suo-shu-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/shu-109-you-xu-lian-biao-zhuan-huan-er-cha-sou-suo-shu-zhong-deng">
        </link>
        <updated>2019-11-28T01:38:10.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。<br>
本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。<br>
示例:<br>
给定的有序链表： [-10, -3, 0, 5, 9],<br>
一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：<br>
0<br>
/ <br>
-3   9<br>
/   /<br>
-10  5<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这是错误的代码</p>
<pre><code>class Solution {
public:
    TreeNode* sortedListToBST(ListNode* head) {
        
    }    
    void bulidTree(TreeNode *cur,ListNode *head){
        if(head==NULL)
            return;
        cur-&gt;val=head-&gt;val;
        head=head-&gt;next;
        if(cur-&gt;left==NULL&amp;&amp;cur-&gt;right==NULL){
            TreeNode *parent=new TreeNode(0);
            bulidTree(patent,head);
        }
        if(cur-&gt;left!=NULL)
    }
};
</code></pre>
<p>//偷偷看到了108的题解中有人用中序遍历来构建顺序二叉树，觉得挺靠谱的的，gogogo<br>
//发现中序遍历还是很不熟悉啊 准备看题解了，实在不行就用一般方法中那种疯狂左旋右旋的方法吧hhh<br>
//看了题解。。。发现和前一题差不多呀，强行对链表进行二分法hhh 需要一堆临时变量来存。第二个更绝，直接用数组存链表hhh</p>
<p>最后参考题解的代码如下</p>
<pre><code>class Solution {
public:
    TreeNode* sortedListToBST(ListNode* head) {
        vector&lt;int&gt; nums;
        while(head!=NULL){
            nums.push_back(head-&gt;val);
            head=head-&gt;next;
        }
        if(nums.empty())
            return NULL;
        TreeNode *root=new TreeNode(0);
        genTree(root,0,nums.size()-1,nums);
        return root;

    }
       
    void genTree(TreeNode *cur,int beg,int end,vector&lt;int&gt;&amp; nums){
        if(beg==end){
            cur-&gt;val=nums[beg];
            cur-&gt;left==NULL;
            cur-&gt;right==NULL;
            return;
        }
      int mid=(end-beg+1)/2+beg;
        cur-&gt;val=nums[mid];
        if(mid&gt;beg){
            //TreeNode *left=new TreeNode(0);
            //cur-&gt;left=left;
            cur-&gt;left=new TreeNode(0);
            genTree(cur-&gt;left,beg,mid-1,nums);
        }else
        {
            cur-&gt;left=NULL;
            return;
        }
        
        if(mid&lt;end){
            cur-&gt;right=new TreeNode(0);
            genTree(cur-&gt;right,mid+1,end,nums);
        }else
        {
            cur-&gt;right=NULL;
            return;
        }
        return;  
            }
};
</code></pre>
<p>//本来想用vector(list.begin(),list.end())初始化vector，结果发现list给的是头节点，没找到方法要怎么调用begin和end的</p>
<p>然后来看一下官方题解：</p>
<blockquote>
<p>方法 1：递归<br>
想法<br>
题目中最重要的要求是需要利用链表中的节点，构建一颗高度平衡的二叉搜索树，好消息是链表中的元素是升序的。<br>
众所周知，一棵二叉搜索树是一棵有根二叉树并且对于所有节点满足特殊的性质：对于树中任意一个点，它的权值必然 \geq≥ 所有左子树节点的权值，\leq≤ 所有右子树节点的权值。因为二叉树具有递归的子结构，二叉搜索树也同理：所有子树也是二叉搜索树。<br>
当前方法和下一个方法的主要思路是：<br>
给定列表中的中间元素将会作为二叉搜索树的根，该点左侧的所有元素递归的去构造左子树，同理右侧的元素构造右子树。这必然能够保证最后构造出的二叉搜索树是平衡的。<br>
算法<br>
由于我们得到的是一个有序链表而不是数组，我们不能直接使用下标来访问元素。我们需要知道链表中的中间元素。<br>
我们可以利用两个指针来访问链表中的中间元素。假设我们有两个指针 slow_ptr 和 fast_ptr。slow_ptr 每次向后移动一个节点而 fast_ptr 每次移动两个节点。当 fast_ptr 到链表的末尾时 slow_ptr 就访问到链表的中间元素。对于一个偶数长度的数组，中间两个元素都可用来作二叉搜索树的根。<br>
当找到链表中的中间元素后，我们将链表从中间元素的左侧断开，做法是使用一个 prev_ptr 的指针记录 slow_ptr 之前的元素，也就是满足 prev_ptr.next = slow_ptr。断开左侧部分就是让 prev_ptr.next = None。<br>
我们只需要将链表的头指针传递给转换函数，进行高度平衡二叉搜索树的转换。所以递归调用的时候，左半部分我们传递原始的头指针；右半部分传递 slow_ptr.next 作为头指针。</p>
</blockquote>
<pre><code>class Solution {
  private ListNode findMiddleElement(ListNode head) {
    // The pointer used to disconnect the left half from the mid node.
    ListNode prevPtr = null;
    ListNode slowPtr = head;
    ListNode fastPtr = head;

    // Iterate until fastPr doesn't reach the end of the linked list.
    while (fastPtr != null &amp;&amp; fastPtr.next != null) {
      prevPtr = slowPtr;
      slowPtr = slowPtr.next;
      fastPtr = fastPtr.next.next;
    }

    // Handling the case when slowPtr was equal to head.
    if (prevPtr != null) {
      prevPtr.next = null;
    }

    return slowPtr;
  }

  public TreeNode sortedListToBST(ListNode head) {

    // If the head doesn't exist, then the linked list is empty
    if (head == null) {
      return null;
    }

    // Find the middle element for the list.
    ListNode mid = this.findMiddleElement(head);

    // The mid becomes the root of the BST.
    TreeNode node = new TreeNode(mid.val);

    // Base case when there is just one element in the linked list
    if (head == mid) {
      return node;
    }

    // Recursively form balanced BSTs using the left and right halves of the original list.
    node.left = this.sortedListToBST(head);
    node.right = this.sortedListToBST(mid.next);
    return node;
  }
}
</code></pre>
<p><img src="https://lixin-ee.github.io//post-images/1574905972042.png" alt=""></p>
<blockquote>
<p>方法 2：递归 + 转成数组<br>
这个方法是空间换时间的经典案例。<br>
你可以通过使用更多空间来降低时间复杂度。<br>
在这个方法中，我们将给定的链表转成数组并利用数组来构建二叉搜索树。数组找中间元素只需要 O(1) 的时间，所以会降低整个算法的时间复杂度开销。<br>
算法<br>
将给定链表转成数组，将数组的头和尾记成 left 和 right 。<br>
找到中间元素 (left + right) / 2，记为 mid。这需要 O(1) 时间开销，也是与上面算法主要改进的地方。<br>
将中间元素作为二叉搜索树的根。<br>
递归构造二叉搜索树的左右两棵子树，两个子数组分别是 (left, mid - 1) 和 (mid + 1, right)。</p>
</blockquote>
<pre><code>class Solution {

  private List&lt;Integer&gt; values;

  public Solution() {
    this.values = new ArrayList&lt;Integer&gt;();
  }

  private void mapListToValues(ListNode head) {
    while (head != null) {
      this.values.add(head.val);
      head = head.next;
    }
  }

  private TreeNode convertListToBST(int left, int right) {
    // Invalid case
    if (left &gt; right) {
      return null;
    }

    // Middle element forms the root.
    int mid = (left + right) / 2;
    TreeNode node = new TreeNode(this.values.get(mid));

    // Base case for when there is only one element left in the array
    if (left == right) {
      return node;
    }

    // Recursively form BST on the two halves
    node.left = convertListToBST(left, mid - 1);
    node.right = convertListToBST(mid + 1, right);
    return node;
  }

  public TreeNode sortedListToBST(ListNode head) {

    // Form an array out of the given linked list and then
    // use the array to form the BST.
    this.mapListToValues(head);

    // Convert the array to
    return convertListToBST(0, this.values.size() - 1);
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：时间复杂度降到了 O(N) ，因为需要将链表转成数组。而取中间元素的开销变成了 O(1) 所以整体的时间复杂度降低了。<br>
空间复杂度：因为我们利用额外空间换取了时间复杂度的降低，空间复杂度变成了 O(N)，相较于之前算法的O(logN)有所提升，因为创建数组的开销。</p>
</blockquote>
<blockquote>
<p>方法 3：中序遍历模拟<br>
想法<br>
我们知道，二叉树有三种不同的遍历方法：<br>
前序遍历<br>
中序遍历 和<br>
后序遍历。<br>
中序遍历一棵二叉搜索树会有一个非常有趣的结论。<br>
中序遍历一棵二叉搜索树的结果是得到一个升序序列。<br>
这个方法模拟了二叉搜索树的构造过程，因为我们已经获得有序的链表，所以自然的产生了这样的想法。<br>
在描述算法之前，先看一下中序遍历是如何获得有序值的。<br>
基于解决这个问题的中序遍历的思想：<br>
我们知道中序遍历最左边的元素一定是给定链表的头部，类似地下一个元素一定是链表的下一个元素，以此类推。这是肯定的因为给定的初始链表保证了升序排列。<br>
在了解了中序遍历二叉搜索树和有序数组的关系之后，让我们来看看算法。<br>
算法<br>
首先用伪代码来理解一下算法。<br>
➔ function formBst(start, end)<br>
➔      mid = (start + end) / 2<br>
➔      formBst(start, mid - 1)<br>
➔<br>
➔      TreeNode(head.val)<br>
➔      head = head.next<br>
➔<br>
➔      formBst(mid + 1, end)<br>
➔<br>
遍历整个链表获得它的长度，我们用两个指针标记结果数组的开始和结束，记为 start 和 end，他们的初始值分别为 0 和 length - 1。<br>
记住，我们当前需要模拟中序遍历，找到中间元素 (start + end) / 2。注意这里并不需要在链表中找到确定的元素是哪个，只需要用一个变量告诉我们中间元素的下标。我们只需要递归调用这两侧。<br>
递归左半边，其中开始和结束的值分别为 start, mid - 1。<br>
在这个算法中，每当我们构建完二叉搜索树的左半部分时，链表中的头指针将指向根节点或中间节点（它成为根节点）。 因此，我们只需使用头指针指向的当前值作为根节点，并将指针后移一位，即 head = head.next。<br>
我们在递归右半部分 mid + 1, end。</p>
</blockquote>
<pre><code>class Solution {

  private ListNode head;

  private int findSize(ListNode head) {
    ListNode ptr = head;
    int c = 0;
    while (ptr != null) {
      ptr = ptr.next;  
      c += 1;
    }
    return c;
  }

  private TreeNode convertListToBST(int l, int r) {
    // Invalid case
    if (l &gt; r) {
      return null;
    }

    int mid = (l + r) / 2;

    // First step of simulated inorder traversal. Recursively form
    // the left half
    TreeNode left = this.convertListToBST(l, mid - 1);

    // Once left half is traversed, process the current node
    TreeNode node = new TreeNode(this.head.val);
    node.left = left;

    // Maintain the invariance mentioned in the algorithm
    this.head = this.head.next;

    // Recurse on the right hand side and form BST out of them
    node.right = this.convertListToBST(mid + 1, r);
    return node;
  }

  public TreeNode sortedListToBST(ListNode head) {
    // Get the size of the linked list first
    int size = this.findSize(head);

    this.head = head;

    // Form the BST now that we know the size
    return convertListToBST(0, size - 1);
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：时间复杂度仍然为 O(N) 因为我们需要遍历链表中所有的顶点一次并构造相应的二叉搜索树节点。<br>
空间复杂度：O(logN) ，额外空间只有一个递归栈，由于是一棵高度平衡的二叉搜索树，所以高度上界为logN。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[0视为空指针]]></title>
        <id>https://lixin-ee.github.io//post/0-shi-wei-kong-zhi-zhen</id>
        <link href="https://lixin-ee.github.io//post/0-shi-wei-kong-zhi-zhen">
        </link>
        <updated>2019-11-27T15:25:24.000Z</updated>
        <content type="html"><![CDATA[<p>在做习题18.20的时候发现一个函数匹配的问题<br>
题目为</p>
<pre><code>void f()
{
	compute(0);
}
</code></pre>
<p>解答为</p>
<p>五个compute全部是候选函数，除了空函数都可行，0视为NULL<br>
如果<strong>using声明</strong>出现在<strong>局部作用域</strong>中，则引入的名字将<strong>隐藏外层作用域的相关声明</strong>。<br>
只有using声明中的两个compute候选，</p>
<pre><code>namespace p  
{  
    void compute();//不可行  
    void compute(const void *);//可行,0-&gt;NULL  
}  
using p::compute;  
void compute(int);//可行,最佳匹配  
void compute(double, double = 1.1);//可行,int-&gt;double  
void compute(char*, char* = 0);//可行,0-&gt;NULL  
  
void f()  
{  
    compute(0);//与compute(int)版本最佳匹配  
}  


namespace p{  
    void compute();//不可行，可见  
    void compute(const void *);//可行,0-&gt;NULL，可见  
}  
void compute(int);//可行,不可见，被隐藏
void compute(double, double = 1.1);//可行,int-&gt;double,被隐藏 
void compute(char*, char* = 0);//可行,0-&gt;NULL，被隐藏
void f(){  
    using p::compute;  
    compute(0);
} 
</code></pre>
<p>然后网友答案中说0可以视为NULL 也就是空指针<br>
翻阅了一下笔记，确实如此：<br>
空指针生成方法 <code>int *p1 = nullptr; int *p2 = 0; int *p3 = NULL;（需要引用#include cstdlib）</code></p>
<p>C++空指针表示NULL、0、nullptr</p>
<p>空指针在之前可以用Null和0(在很多头文件中，NULL是一个被定义为0的符号常量)来表示。</p>
<p>C程序员通常使用NULL以指出这是一个指针（就像使用'\0'而不是0来表示空字符，以指出这是一个字符一样）</p>
<p>C++传统上更喜欢用简单的0，而不是等价的NULL</p>
<p>C++11提供了关键字nullptr</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第十八章 笔记+习题 18.2]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-ba-zhang-bi-ji-xi-ti-182</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-ba-zhang-bi-ji-xi-ti-182">
        </link>
        <updated>2019-11-27T13:32:34.000Z</updated>
        <content type="html"><![CDATA[<p>18.2命名空间<br>
<strong>多个库</strong>将名字放置在<strong>全局命名空间</strong>中将引发<strong>命名空间污染</strong>（namespace pollution)。<br>
命名空间(namespace)为防止名字冲突提供了更加可控的机制。命名空间分割了全局命名空间，其中<strong>每个命名空间是一个作用域</strong>。通过<strong>在某个命名空间中定义库的名字</strong>，库的作者及用户）可以避免全局名字固有的限制。<br>
18.2.1命名空间定义<br>
一个命名空间的<strong>定义</strong>包含<strong>两部分</strong>：首先是<strong>关键字namespace</strong>，随后是<strong>命名空间的名字</strong>。在命名空间名字后面是一系列由<strong>花括号括起來的声明和定义</strong>。只要能出现在全局作用域中的声明就能置于命名空间内，主要包括：<strong>类</strong>、<strong>变量</strong>（及其构始化操作）、<strong>函数</strong>（及其定义）、<strong>模板</strong>和<strong>其他命名空间</strong>：  	和其他名字一样，<strong>命名空间的名字</strong>也必须在定义它的<strong>作用域内保持唯一</strong>。命名空间既可以定义在全局作用域内，也可以定义在其他命名空间中，但是<strong>不能定义在函数或类的內部</strong>。     命名空间<strong>作用域后面无须分号</strong>。</p>
<p>和其他作用域类似，命名空间中的<strong>每个名字</strong>都必须表示<strong>该空间内的唯一实体</strong>。因为不同命名空间的作用域不同，所以在<strong>不同命名空间</strong>内可以有<strong>相同名字的成员</strong>。<br>
定义在某个命名空间中的名字可以被该<strong>命名空间内的其他成员直接访问</strong>，也可以被这些成员内嵌作用域中的任何单位访问。位于该<strong>命名空间之外</strong>的代码则必须<strong>明确指出</strong>所用的名字<strong>属于哪个命名空间</strong>：</p>
<p>命名空间可以<strong>定义在几个不同的部分</strong>，这一点与其他作用域不太一样。</p>
<p>可能是<strong>定义</strong>了一个名为nsp的<strong>新命名空间</strong>，<strong>也可能</strong>是为<strong>已经存在</strong>的命名空间<strong>添加一些新成员</strong>。<br>
命名空间的定义<strong>可以不连续的特性</strong>使得我们可以将<strong>几个独立的接口和实现文件（头文件+源文件）组成一个命名空间</strong>。此时，命名空间的组织方式<strong>类似于我们管理自定义类及函数</strong>的方式：<br>
•命名空间的一部分成员的<strong>作用是定义类，以及声明作为类接口的函数及对象</strong>，则这些成员应该<strong>置于头文件</strong>中，这些头文件将被<strong>包含在使用了这些成员的文件</strong>中。<br>
•命名空间成员的<strong>定义部分</strong>则置于<strong>另外的源文件中</strong>。</p>
<p>在程序中<strong>某些实体只能定义一次</strong>：如<strong>非内联函数</strong>、<strong>静态数据成员</strong>、<strong>变量</strong>等，<strong>命名空间中定义的名字也需要满足这一要求</strong>，我们可以通过上面的方式组织命名空间并达到目的。这种接口和实现分离的机制确保我们所需的函数和其他名字只定义一次，而只要是用到这些实体的地方都能看到对于实体名字的声明<br>
定义<strong>多个类型不相关的命名空间</strong>应该使用<strong>单独的文件</strong>分别表示<strong>每个类型</strong>（或关联类型构成的集合)。</p>
<p>假定作用域中存在合适的声明语句，则命名空间中的代码<strong>可以使用同一命名空间定义的名字的简写形式</strong>：<br>
也可以在命名空间定义的<strong>外部定义</strong>该命名空间的成员。命名空间对于<strong>名字的声明必须在作用域内</strong>，同时该<strong>名字的定义</strong>需要<strong>明确指出其所属的命名空间</strong>；<br>
尽管命名空间的成员<strong>可以定义在命名空间外部</strong>，但是这样的定义<strong>必须出现在所属命名空间的外层空间（还是需要加前缀）中</strong>。换句话说，我们可以在cplusplus_primer或<strong>全局作用域</strong>中定义Sales_data operator+,但是<strong>不能在一个不相关的作用域中定义这个运算符</strong>。</p>
<p>模块特例化<br>
<strong>模板特例化必须定义在原始模板所属的命名空间中</strong>（参见16.5节，第626页）。和其 他命名空间名字类似，<strong>只要</strong>我们<strong>在命名空间中声明了特例化，就能在命名空间外部定义它了</strong>！</p>
<p>全局命名空间<br>
全局作用域中定义的名字（即在所有类、函数及命名空间之外定义的名字）也就是定<br>
义在<strong>全局命名空间（global namespace)（不是std）<strong>中。<strong>全局命名空间以隐式的方式声明</strong>，并且在所有程序中都存在。<strong>全局作用域中定义的名字被隐式地添加到全局命名空间中</strong>。<br>
作用域运算符同样可以用于全局作用域的成员，因为</strong>全局作用域是隐式</strong>的，<strong>所以它并没有名字</strong>。下面的形式<br>
<strong>: :member_ name表示全局命名空间中的一个成员。</strong></p>
<p>嵌套的命名空间<br>
<strong>嵌套的命名空间</strong>是指<strong>定义在其他命名空间中的命名空间</strong><br>
嵌套的命名空间同时是<strong>一个嵌套的作用域</strong>，它<strong>嵌套在外层命名空间的作用域中</strong>。嵌套的命名空间中的名字遵循的规则与往常类似：<strong>内层命名空间声明的名字</strong>将<strong>隐藏外层命名空间声明的同名成员</strong>。在嵌套的命名空间中定义的名字<strong>只在内层命名空间中有效</strong>，<strong>外层命名空间</strong>中的代码要<strong>想访问它</strong>必须在名字前<strong>添加限定符</strong>。</p>
<p>内联命名空间<br>
<strong>内联命名空间中的名字</strong>可以<strong>被外层命名空间直接使用</strong>。也就是说，我们无须在内联命名空间的名字前添加表示该命名空问的前缀，通过外层命名空间的名字就可以直接访问它。     <strong>定义内联命名空间</strong>的方式是在关键字namespace前<strong>添加关键字inline</strong>：     inline namespace FifthEd{<br>
/ /该命名空间表示本书第5版的代码<br>
关键字inline<strong>必须出现在命名空间第一次定义的地方</strong>，<strong>后续再打开</strong>命名空间的时候<strong>可以写inline.也可以不写</strong>。<br>
当应用程序的代码在<strong>一次发布和另一次发布之间发生了改变</strong>时，<strong>常常会用到内联命名空间</strong>。<br>
<strong>新发布的可以直接用，旧发布的需要加上前缀</strong></p>
<p>未命名的命名空间<br>
<strong>未命名的命名空间</strong>（unnamed namespace)是指<strong>关键字namespace后紧跟花括号</strong>括起来的一系列声明语句。未命名的命名空间中定义的变量<strong>拥有静态生命周期</strong>：它们在第一次使用前创建，并且<strong>直到程序结束才销毁</strong>。<br>
一个未命名的命名空间可以在<strong>某个给定的文件内不连续</strong>，但是<strong>不能跨越多个文件</strong>。<strong>每个文件定义自己的未命名的命名空间</strong>，如果<strong>两个文件</strong>都含有未命名的<strong>命名空间</strong>，则这两个空间<strong>互相无关</strong>。在这两个未命名的命名空间中可以定义相同的名字，并且这些定义表示的是不同实体。<strong>如果一个头文件定义了未命名的命名空间</strong>，则该命名空间中定义的名字<strong>将在毎个包含了该头文件的文件中对应不同实体</strong>。<br>
和其他命名空间不同，<strong>未命名的命名空间仅在特定的文件内部有效</strong>，其作用范围不会橫跨多个不同的文件。     <strong>定义在未命名的命名空间中的名字可以直接使用(区分全局命名空间)</strong>，毕竟我们找不到什么命名空间的名宇来限定它们；同样的，<strong>我们也不能对未命名的命名空间的成员使用作用域运算符</strong>。<br>
<strong>未命名的命名空间</strong>中定义的<strong>名字的作用域</strong>与<strong>该命名空间所在的作用域相同</strong>。<strong>如果未命名的命名空间定义</strong>在文件的<strong>最外层作用域</strong>中，则该命名空间中的名字<strong>一定要与全局作用域中的名字有所区别</strong>：<br>
一个未命名的命名空间<strong>也能嵌套在其他命名空间</strong>当中。此时，未命名的命名空间中的成员<strong>可以通过外层命名空间的名字</strong>来访问：<br>
<strong>在文件中进行静态声明</strong>的做法已经被C++标准<strong>取消</strong>了，现在的做法是<strong>使用未命名的命名空间</strong>。</p>
<p>习题18.12<br>
只要在include的后面加上 namespace chapter{}就好<br>
习题18.13<br>
希望使用全局变量的时候<br>
命名的命名空间中定义的变量<strong>拥有静态生命周期</strong>：它们在第一次使用前创建，并且<strong>直到程序结束才销毁</strong><br>
或者希望减少命名空间冲突<br>
和其他命名空间不同，<strong>未命名的命名空间仅在特定的文件内部有效</strong>，其作用范围不会橫跨多个不同的文件。<br>
习题18.14<br>
<code>mathLib::MatrixLib::matrix mathLib::MatrixLib::operator*(const matrix &amp;,const matrix&amp;)</code><br>
注意返回类型不在作用域内，所以需要叫上作用域运算符</p>
<p>18.2.2使用命名空间成员<br>
像namespace_name::member_name这样使用命名空间的成员显然非常烦琐<br>
命名空间的别名<br>
<strong>命名空间的别名(name space alias)<strong>使得我们可以为命名空间的名字</strong>设定一个短得多的同义词</strong>。例如，一个很长的命名空间的名字形如<br>
namespace cplusplus_primer {/<em>...</em>/};<br>
我们可以为其设定一个短得多的同义词：<br>
<strong>namespace primer = cplusplus_primer;<br>
<strong>命名空间的别名声明以</strong>关键字namespace开始</strong>，后面是<strong>别名</strong>所用的名字、<strong>=符号</strong>、命名<br>
空间<strong>原来的名字</strong>以及一个分号。<strong>不能在命名空间还没有定义前就声明别名.否则将产生错误</strong>。<br>
命名空间的别名<strong>也可以指向一个嵌套的命名空间</strong>：<br>
namespace Qlib = cplusplus_primer::QueryLib;<br>
Qlib::Query q;</p>
<p>Using声明：扼要概述<br>
<strong>注意！！！using声明不是针对命名空间的！是针对作用域的，类也能用的！</strong>	一条using声明（using declaration)语句<strong>一次只引入命名空间的一个成员</strong>。它使得我们可以清楚地知道程序中所用的到底是哪个名字。 	using声明引入的名字遵守与过去一样的作用域规则：它的<strong>有效范围从using声明的地方开始，一直到using声明所在的作用域结束为止</strong>。在此过程中，<strong>外层作用域的同名实体</strong>将<strong>被隐藏</strong>。未加限定的名字只能在<strong>using声明所在的作用域</strong>以及其<strong>内层作用域</strong>中使用。在有效作用域结束后，我们就必须使用完整的经过限定的名字了。     一条using声明语句可出现在全局作用域、局部作用域、命名空间作用域从及类的作用域中。在<strong>类的作用域中</strong>，这样的声明语句<strong>只能指向基类成员</strong>（参见15.5节，第546页)。<br>
例如using Base::param;</p>
<p>using指示<br>
using指示(using directive)和using声明类似的地方是，我们可以使用命名空间名字的简写形式；<strong>和using声明不同的地方</strong>是，我们<strong>无法控制哪些名字是可见的</strong>，<strong>因为所有名字都是可见的</strong>。<br>
using指示以关键字using开始，后面是关键字namespace以及命名空间的名字。如果这里所用的名字不是一个己经定义好的命名空间的名字，则程序将发生错误。using指示可以出现在全局作用域、局部作用域和命名空间作用域中，但是<strong>不能出现在类的作用域中</strong>。<br>
using指示<strong>使得某个特定的命名空间中所有的名字都可见</strong>，这样我们就无须再为它们添加任何前缀限定符了。简写的名字从using指示开始，一直到using指示所在的作用域结束都能使用。     如果我们提供一个<strong>对std等命名空间</strong>的using指示而<strong>未做任何特殊控制</strong>的话，将<strong>重新引入</strong>由于使用了多个库而造成的<strong>名字冲突问题</strong>。</p>
<p>using指示与作用域<br>
<strong>using 指示</strong>引入的名字的作用域远比<strong>using 声明</strong>引入的名字的作用域<strong>复杂</strong>。如我们所知，<strong>using 声明的名字的作用域与using 声明语句本身的作用域一致</strong>，<br>
<strong>using指示</strong>所做的绝非声明别名这么简单。相反，它<strong>具有将命名空间成员提升到包含命名空间本身和using指示的最近作用域的能力</strong>。     using 声明和using 指示在作用域上的区别<strong>直接决定了它们工作方式的不同</strong>。对于<strong>using 声明来说</strong>，我们只是<strong>简单地令名字在局部作用域内有效</strong>。相反，<strong>using 指示</strong>是<strong>令整个命名空间的所有内容变得有效</strong>。通常情况下，<strong>命名空间中会含有一些不能出现在局部作用域中的定义</strong>，因此，using指示<strong>一般被看作是出现在最近的外层作用域中</strong>。</p>
<p>当命名空间被注入到它的外层作用域之后，<strong>很有可能该命名空间中定义的名字会与其外层作用域中的成员冲突</strong>。例如在manip中，blip的成员j就与全局作用域中的j产生了冲突。这种<strong>冲突是允许存在的</strong>，但是要想使用冲突的名字.我们<strong>就必须明确指出名字的版本</strong>。manip中所有未加限定的j都会产生二义性错误。</p>
<p>头文件与using声明或指示<br>
<strong>头文件</strong>如果在其<strong>顶层作用域</strong>中<strong>含有using指示或using声明</strong>，则会将名字<strong>注入到所有包含了该头文件的文件</strong>中。通常情况下，头文件应该只负责定义接口部分的名字，而不定义实现部分的名字。因此，<strong>头文件最多只能在它的函数或命名空间内使用using指示或using声明</strong>（参见3.1节，第75页）。</p>
<p>习题18.15<br>
<strong>using 指示</strong>引入的名字的作用域远比<strong>using 声明</strong>引入的名字的作用域<strong>复杂</strong>。如我们所知，<strong>using 声明的名字的作用域与using 声明语句本身的作用域一致</strong>，<br>
<strong>using指示</strong>所做的绝非声明别名这么简单。相反，它<strong>具有将命名空间成员提升到包含命名空间本身和using指示的最近作用域的能力</strong>。     using 声明和using 指示在作用域上的区别<strong>直接决定了它们工作方式的不同</strong>。对于<strong>using 声明来说</strong>，我们只是<strong>简单地令名字在局部作用域内有效</strong>。相反，<strong>using 指示</strong>是<strong>令整个命名空间的所有内容变得有效</strong>。通常情况下，<strong>命名空间中会含有一些不能出现在局部作用域中的定义</strong>，因此，using指示<strong>一般被看作是出现在最近的外层作用域中</strong>。</p>
<p>习题18.16+17<br>
位置1：相当于把exercise中的名字引入到外层作用域中<br>
位置2：相当于把exercise中的名字引入到函数的作用域中，会影响dvar的定义和ivar的使用<br>
如果是using指示，那么位置1和位置2差别不大，<strong>具有将命名空间成员提升到包含命名空间本身和using指示的最近作用域的能力</strong></p>
<pre><code>//1.1  
//using exercise::ivar;//错误，与全局变量ivar冲突，多次声明  
//using exercise::dvar;  
//using exercise::limi;  
//  
//void manip()  
//{  
//  double dvar = 3.1416;//覆盖using声明的dvar  
//  int iobj = limi + 1;  
//  ++ivar;  
//  ++::ivar;  
//}  
  
  
//1.2  
//void manip()  
//{  
//  using exercise::ivar;//隐藏全局变量  
//  using exercise::dvar;  
//  using exercise::limi;  
//  double dvar = 3.1416;//错误，多重定义，多次初始化，当前dvar对象已经可见  
//  int iobj = limi + 1;  
//  ++ivar;//exercise的ivar  
//  ++::ivar;//全局变量  
//}  
  
//2.1  
//using namespace exercise;  
//void manip()  
//{  
//  double dvar = 3.1416;//覆盖using声明的dvar  
//  int iobj = limi + 1;  
//  ++ivar;//错误，不明确,二义性,二者都可见  
//  ++::ivar;  
//}  
  
//2.2  
//void manip()  
//{  
//  using namespace exercise;  
//  double dvar = 3.1416;//覆盖using声明的dvar  
//  int iobj = limi + 1;  
//  ++ivar;//错误，不明确,二义性,二者都可见  
//  ++::ivar;  
//} 
</code></pre>
<p>18.2.3 类、命名空间与作用域<br>
对<strong>命名空间内部名字</strong>的查找遵循常规的查找规则：即<strong>由内向外</strong>依次査找每个外层作用域。外层作用域也可能是一个或多个嵌套的命名空间，直到最外层的全局命名空间査找过程终止。只有位于开放的块中且在<strong>使用点之前声明的名字才被考虑</strong>：     对于位于<strong>命名空间中的类</strong>来说，常规的查找规则仍然适用：当成员函数使用某个名字时，首先在该成员中进行查找，然后在类中查找（包括基类），<strong>接着在外层作用域中查找</strong>，这时一个或几个外层作用域可能就是命名空间</p>
<p>可以从<strong>函数的限定名推断出查找名字时检查作用域的次序</strong>，限定名以相反次序,指出被査找的作用域。</p>
<p>实参相关的查找与类类型形参</p>
<p>对于命名空间中名字的隐藏规则来说有一个重要的例外，它使得我们可以<strong>直接访问输出运算符</strong>。这个<strong>例外是</strong>，当我们给函数<strong>传递一个类类型的对象</strong>时，<strong>除了在常规的作用域查找</strong>外<strong>还会查找实参类（比如cin和string的std）所属的命名空间</strong>。这一例外对于<strong>传递类的引用或指针</strong>的调用<strong>同样有效</strong>。</p>
<p>查找规则的这个例外允许概念上<strong>作为类接口一部分的非成员函数无须单独的using<br>
声明就能被程序使用</strong>。<br>
不需要using std::operator&gt;&gt;或者std::operator&gt;&gt;()</p>
<p>查找与std：：move 和 std::forward<br>
接下来考虑标准库<strong>move和forward</strong>函数。送两个都是模板函数，在标准库的定义中它们都<strong>接受一个右值引用的函数形参</strong>。如我们所知，在函数模板中，<strong>右值引用形参可以匹配任何类型</strong>（参见16.2.6节，第611页）。<strong>如果我们的应用程序也定义</strong>了一个<strong>接受单一形参</strong>的<strong>move函数</strong>，则<strong>不管该形参是什么类型</strong>，应用程序的move函数<strong>都将与标准库的版本冲突</strong>。<strong>forward函数也是如此</strong>。<br>
因此，move(以及forward)的名字冲突要比其他标准库函数的冲突频繁得多。而且，因为move和forward执行的是非常特殊的类型操作，所以应用程序专口修改函数原有行为的概率非常小。<br>
对于move和forward来说，冲突很多但是大多数是无意的，这一特点<strong>解释了为什么我们建议最好使用它们的带限定语的完整版本的原因</strong>（参见12.1.5节，第417页）。通过<strong>书写std::move而非move</strong>，我们就能明确地知道想要使用的是函数的标准库版本。</p>
<p>友元声明与实参相关的查找<br>
当类声明了一个友元时，<strong>该友元声明并没有使得友元本身可见</strong>（参见7.2.1节，第242页）。然而，一个<strong>另外的未声明的类或函数</strong>如果<strong>第一次出现在友元声明中</strong>，则我们认为它是<strong>最近的外层命名空间的成员</strong>。这条规则与实参相关的查找规则结合在一起将产生意想不到的效果：</p>
<p>习题18.18<br>
会首先在当前作用域中查找，然后查找参数的类所属的命名空间，所以<br>
当参数为string时，会使用string类中查找到的swap函数，找到则不使用std版本的。若未int类型，则直接使用标准库版本的swap<br>
习题18.19<br>
会强制使用std的swap</p>
<p>18.2.4 重载与命名空间<br>
命名空间对<strong>函数的匹配过程</strong>有<strong>两方面的影响</strong>（参见6.4节，第209页）。其中<strong>一个影响非常明显</strong>：using声明或using指示能<strong>将某些函数添加到候选函数集</strong>。另外一个影响则比较微妙。<br>
与实参相关的查找与重载<br>
对于接受类类型实参的函数来说，其名字查找将在实参类所属的命名空间中进行。这条规则对于我们如何确定候选函数集同样也有影响。我们<strong>将在每个实参类</strong>（以及实参类的<strong>基类</strong>）<strong>所属的命名空间中搜寻候选函数</strong>。在这些命名空间中所有与被调用函数<strong>同名的函数都将被添加到候选集</strong>当中，即使其中某些函数在调用语句处不可见也是如此：</p>
<p>重载与using声明<br>
要想理解using声明与重载之间的交互关系，必须首先明确一条：<strong>using声明语句声明的是一个名字</strong>，<strong>而非一个特定的函数</strong>（参见15.6节，第551页）：<br>
using <strong>NS::print(int)</strong>;		//<strong>错误：不能指定形参列表</strong><br>
using NS::print;	//正确：using声明只弄明一个名字<br>
当我们<strong>为函数书写using声明</strong>时，该函数的<strong>所有版本</strong>都被引入到当前作用域中。<br>
比如using std::operator&gt;&gt;<br>
一个using声明囊括了<strong>重载函数的所有版本</strong>以确保<strong>不违反命名空间的接口</strong>。<br>
一个using声明引入的函数将<strong>重载</strong>该声明语句<strong>所属作用域中已有的其他同名函数</strong>。如果<strong>using声明</strong>出现在<strong>局部作用域</strong>中，则引入的名字将<strong>隐藏外层作用域的相关声明</strong>。如果using声明所在的作用域中己经有一个函数与新引入的函数<strong>同名且形参列表相同</strong>，则该using声明将<strong>引发错误</strong>。除此之外，using声明将为引入的名字添加额外的重载实例，并最终扩充候选函数集的规模。</p>
<p>重载与using指示<br>
如果命名空间的某个函数与该命名空间所属作用域的函数同名，则命名空间的函数将被添加到重载集合中：<br>
与using 声明不同的是，对于<strong>using 指示</strong>来说，<strong>引入</strong>一个与<strong>已有函数形参列表完全相同<br>
的函数并不会产生错误</strong>。此时，<strong>只要</strong>我们<strong>指明</strong>调用的是命名空间中的<strong>函数版本</strong>还是当前作用域的<strong>版本</strong>即可。</p>
<p>习题18.20<br>
五个compute全部是候选函数，除了空函数都可行，0视为NULL<br>
如果<strong>using声明</strong>出现在<strong>局部作用域</strong>中，则引入的名字将<strong>隐藏外层作用域的相关声明</strong>。<br>
只有using声明中的两个compute候选，</p>
<pre><code>namespace p  
{  
    void compute();//不可行  
    void compute(const void *);//可行,0-&gt;NULL  
}  
using p::compute;  
void compute(int);//可行,最佳匹配  
void compute(double, double = 1.1);//可行,int-&gt;double  
void compute(char*, char* = 0);//可行,0-&gt;NULL  
  
void f()  
{  
    compute(0);//与compute(int)版本最佳匹配  
}  


namespace p{  
    void compute();//不可行，可见  
    void compute(const void *);//可行,0-&gt;NULL，可见  
}  
void compute(int);//可行,不可见，被隐藏
void compute(double, double = 1.1);//可行,int-&gt;double,被隐藏 
void compute(char*, char* = 0);//可行,0-&gt;NULL，被隐藏
void f(){  
    using p::compute;  
    compute(0);
} 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第十八章 笔记+习题 18.1]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-ba-zhang-bi-ji-xi-ti-181</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-ba-zhang-bi-ji-xi-ti-181">
        </link>
        <updated>2019-11-27T02:23:35.000Z</updated>
        <content type="html"><![CDATA[<p>18.1异常处理<br>
异常处理 (exceptionhandling )机制允许程序中独立开发的部分能够在<strong>运行时就出现的问题进行通信并做出相应的处理</strong>。异常使得我们能够将<strong>问题的检测与解决过程分离开来</strong>。</p>
<p>18.1.1 抛出异常<br>
我们通过<strong>抛出( throwing )一条表达式来引发（raised )—个异常</strong>。被抛出的表达式的<strong>类型</strong>以及当前的<strong>调用链</strong>共同<strong>决定了哪段处理代码( handler )</strong> 将被用来处理该异常。被选中的处理代码是在调用链中与抛出对象类型匹配的最近的处理代码。其中，根据抛出对象的类型和内巧，程净的异常抛出部分将会告知异常处理部分到底发生了什么错误。<br>
当执行一个 throw 时，跟在 <strong>throw 后面的语句将不再被执行</strong>。.相反，程序的控制权从 throw 转移到与之匹配的 <strong>catch 模块</strong>。<br>
•沿着调用链的函数可能会提早退出。<br>
•一旦程序<strong>开始执行异常处理代码</strong>，则沿着<strong>调用链创建的对象将被销毁</strong>。<br>
因为跟在 throw 后面的语句将<strong>不再被执行</strong>，所以<strong>throw 语句的用法有点类似于 return语句</strong>：它通常作为<strong>条件语句的一部分</strong>或者作为某个<strong>函数的最后（或者唯一）一条语句</strong>。</p>
<p>当 throw 出现在一个try 语句块（try block )内时，检查与该 try 块关联的 catch 子句。如果找到了匹配的 catch ,就使用该 catch 处理异常。如果这一步没找到匹配的 catch 且该 try 语句嵌套在其他 try 块中，则继续检查与<strong>外层 try</strong> 匹配的catch 子句。如果还是找不到匹配的 catch ,则退出当前的函数，在<strong>调用当前函数的外层函数中</strong>继续寻找。<br>
如果对抛出异常的函数的调用语句位于一个 try 语句块内，则检查与该 try 块关联的 catch 子句。如果找到了匹配的 catch ,就使用该 catch 处理异常。否则，如果该try 语句嵌套在其他 try 块中，则继续检查与外层 try 匹配的 catch 子句。如果仍然没有找到匹配的 catch ,则退出当前这个主调函数，维续在调用了刚刚退出的这个函数的其他函数中寻找，以此类推。<br>
上述过程被称为 <strong>栈展开 （stack unwinding )过程</strong>。栈展开过程<strong>沿着嵌套函数的调用链</strong><br>
不断查找，直到找到了与异常匹配的 catch 子句为止；或者也可能一直没找到匹配的catch ,则退出主函数后查找过程终止。<br>
假设<strong>找到了一个匹配的 catch 子句</strong>，则程序进入该子句并执行其中的代码。当<strong>执行完这个 catch 子句后</strong>，找到与 try 块关联的<strong>最后一个 <strong>catch <strong>子句之后的点</strong>，并从这里</strong>继续执行</strong>。<br>
<strong>如果没找到匹配的 catch 子句，程序将退出</strong>。因为异常通常被认为是妨碍程序正常执行的事件，所以—旦引发了某个异常，就<strong>不能对它置之不理</strong>。当<strong>找不到匹配的 catch</strong>时，程序将<strong>调用标准库函数 terminate,</strong> 顾名思义， terminate 负责终止程序的执行过程。</p>
<p>在栈展开过程中，位于调用链上的语句块可能会提前退出。通常情况下，程序在这些块中创建了一些局部对象。我们已经知道，<strong>块退出后它的局部对象也将随之销毁</strong>，这条规则对于栈展开过程同样适用。如果在找展开过程中退出了某个块，<strong>编译器将负责确保在这个块中创建的对象能被正确地销毁。</strong> 如果某个局部对象的类型是类类型，则该对象的析构函数将被自动调用。与往常一样，编译器在销毁内置类型的对象时不需要做任何事情。<br>
<strong>析构函数总是会被执行的</strong>，但是函数中<strong>负责释放资源的代码却可能被跳过</strong><br>
如果一个块分配了资源，并且在<strong>负责释放这些资源的代码前面发生了异常</strong>，则<strong>释放资源的代码将不会被执行</strong>。另一方面，类对象分配的资源将由类的析构函数负责释放。因此，如果我们<strong>使用类来控制资源的分配</strong>，就能确保无论函数正常结果还是遭遇异常，<strong>资源都能被正确地释放</strong>。<br>
出于<strong>栈展开可能使用析构函数</strong>的考虑，<strong>析构函数不应该抛出不能被它自身处理的异常</strong>。换句话说，如果析构函数需要执行某个可能抛出异常的操作，则该操作应该被放置在一个 try 语句块当中，并且在析构函数内部得到处理。<br>
在实际的编程过程中，因为析构函数<strong>仅仅是释放资源，所以它不太可能抛出异常</strong>。所有<strong>标准库类型都能确保它们的析构函数不会引发异常</strong>。<br>
在栈展开的过程中，运行类类型的局部对象的析构函数。因为这些析构函数是自动执行的，所以它们不应该抛出异常。<strong>一旦在栈展开的过程中析构函数拋出了异常</strong>，并且析构函数<strong>自身没能捕获到该异常，则程序将被终止</strong>。</p>
<p><strong>异常对象( exceptionobject )<strong>是一种特殊的对象，编译器使用 <strong>异常抛出表达式来对异常对象进行拷贝初始化</strong>（参见13.1.1节，第441页）。因此， <strong>throw 语句中的表达式必须拥有完全类型</strong>  而且如果该表达式是</strong>类类型</strong>的话，则相应的类必须含有一个<strong>可访问的析构函数</strong>和一个<strong>可访问的拷贝或移动构造函数</strong>。如果该表达式是<strong>数组类型或函数类型</strong>，则表达式将被转换成与之<strong>对应的指针类型</strong>。<br>
<strong>异常对象位于由编译器管理的空间中</strong>，编译器确保无论最终调用的是哪个 catch 子句都能访问该空间。当异常处理完带后，异常对象被销毁。<br>
如果退出了某个块，则同时释放块中局部对象使用的内存。因此.<strong>抛出一个指向局部对象的指针几乎肯定是一种错误的行为</strong>。出于同样的原因，<strong>从函数中返回指向局部对象的指针也是错误的</strong><br>
我们抛出一条表达式时，该表达式的<strong>静态编译时类型</strong>（参见15.2.3节，第534页）<strong>决定</strong>了<strong>异常对象的类型</strong>。读者必须牢记这一点，因为很多情况下程序抛出的表达式类型来自于某个继承体系。如果一条 throw 表达式<strong>解引用</strong>一个基类指针，而该指针实际指向的是派生类对象，则抛出的对象将被切掉一部分（参见15.2.3节，第535页），<strong>只有基类部分被抛出</strong>。<br>
<strong>拋出指针</strong>要求在任何对应的<strong>处理代码存在的地方</strong>，指针<strong>所指的对象都必须存在</strong>。</p>
<p>习题18.1<br>
（a）range error的类类型<br>
（b）p指向error的指针类型，为exception类型，range error是它的派生类，，但异常对象的类型取决于静态类型，所以是exception类型<br>
改成指针会引发错误，如果退出了某个块，则同时释放块中局部对象使用的内存。因此.<strong>抛出一个指向局部对象的指针几乎肯定是一种错误的行为</strong>。出于同样的原因，<strong>从函数中返回指向局部对象的指针也是错误的</strong><br>
习题18.2<br>
程序会查找catch语句，如果在内外层作用域都找不到的话就销毁所有局部对象然后调用terminate的abort()<br>
发生异常，所在块之前的临时变量皆会被销毁，V会调用vector类的析构函数进行销毁，并释放相关内存，P指针会被销毁，<strong>但是P指针指向的内存由于是动态分配的，所以该内存不会被释放</strong>，造成内存泄漏。输入流对象会调用ifstream类的析构函数销毁，最后程序被终止<br>
习题18.3<br>
1.使用try catch，在catch语句中销毁局部变量和动态内存<br>
2.使用throw catch<br>
3.使用智能指针类<br>
4.使用类类型，在析构函数中delete指向动态内存的指针</p>
<p>18.1.2 捕获异常<br>
catch 子句（ catchclause )中的异常声明( exceptiondeclaration )看起来像是只包含一个形参的函数形参列表。像在形参列表中一样，如果 catch 无须访问抛出的表达式的话，则我们可以忽略捕获形参的名字。<br>
<strong>声明的类型</strong>决定了<strong>处理代码</strong>所能<strong>捕获的异常类型</strong>。这个类型<strong>必须是完全类型</strong>（参见7.3.3节，第250页），它可以是左值引用，但不能是右值引用（参见13.6.1节，第471页）。<br>
当进入一个 catch 语句后，通过<strong>异常对象初始化异常声明中的参数</strong>。和函数的参数类似，如果 catch 的参数类型是非引用类型，则该参数是异常对象的一个副本，在 catch语句内改变该参数实际上改变的是局部副本而非异常对象本身；相反，如果参数是引用类型，则和其他引用参数一样，该参数是异常对象的一个别名，此时改变参数也就是改变异常对象。<br>
catch 的参数还有一个特性也与函数的参数非常类似：如果 catch 的参数是基类类型，则我们可以使用其派生类类型的异常对象对其进行初始化。此时，如果 catch 的参数是<strong>非引用类型</strong>，则异常对象将<strong>被切掉一部分</strong>（参见15.2.3节，第535页），这与将派生类对象以值传递的方式传给一个普通函数差不多。另一方面，如果 catch 的参数是<strong>基类的引用</strong>，则该参数将<strong>以常规方式绑定</strong>到异常对象上。<br>
最后一点需要注意的是，<strong>异常声明的静态类型将决定 catch 语句所能执行的操作</strong>。如果 catch 的参数是基类类型，则 catch 无法使用派生类特有的任何成员。<br>
通常情况下，如果catch接受的异常与<strong>某个继承体系有关</strong>，则最好将该catch的参数<strong>定义成引用类型</strong>。</p>
<p>在搜寻 catch 语句的过程中，我们最终找到的 catch <strong>未必是异常的最佳匹配</strong>。相反，<strong>挑选出来的应该是第一个与异常匹配的</strong> catch 语句。因此，<strong>越是专门的 catch 越应该置于整个 catch 列表的前端。</strong>（<strong>并不像函数匹配那样</strong>）<br>
因为 catch 语句是<strong>按照其出现的顺序逐一进行匹配的</strong>，所以当程序使用具有继承关系的多个异常时必须对 catch 语句的顺序进行组织和管理，使得<strong>派生类异常</strong>的处理代码出现在<strong>基类异常</strong>的处理代码<strong>之前</strong>。<br>
与实参和形参的匹配规则相比，异常和 catch 异常声明的匹配规则受到更多限制。此时，<strong>绝大多数类型转换都不被允许</strong>，除了一些极细小的差别之外，要求异常的类型和catch 声明的类型是精确匹配的：<br>
•允许<strong>从非常量向常量的类型转换</strong>，也就是说，一条非常量对象的 throw 语句可以匹配一个接受常量引用的 catch 语句。<br>
•允许从<strong>派生类向基类</strong>的类型转换。<br>
•<strong>数组</strong>被转换化<strong>指向数组（元素）类型的指针</strong>，<strong>函数</strong>被转换成<strong>指向该函数类型的指针</strong>。<br>
除此之外，包括准算术类型转换和类类型转换在内，其他所有转换规则都不能在匹配catch 的过程中使用。<br>
如果在多个catch语句的类型之间存在着继承关系，则我们应该把<strong>继承链最底端</strong>的类（mos tderived type)<strong>放在前面</strong>，而将<strong>继承链最顶端</strong>的类（least derived type)<strong>放在后面</strong>。</p>
<p>有时，一个单独的 catch 语句不能完整地处理某个异常。在执行了某些校正操作之后，<strong>当前的 catch</strong> 可能会决定由<strong>调用链更上一层的函数</strong>接着处理异常。一条 catch 语句通过<strong>重 新抛出 （ rethrowing )<strong>的操作</strong>将异常传递</strong>给<strong>另外一个 catch 语句</strong>。这里的重新抛出仍然是一条 throw 语句，只不过<strong>不包含任何表达式</strong>：<br>
<strong>throw;<br>
空的 throw 语句只能出现</strong>在** catch 语句<strong>或</strong> catch 语句直接或间接调用的函数之内**。如果在<strong>处理代码之外的区域</strong>遇到了空 throw 语句，<strong>编译器将调用 terminate</strong> 。<br>
一个重新抛出语句<strong>并不指定新的表达式</strong>，而是将当前的异常对象<strong>沿着调用链向上传递</strong>。<br>
很多时候， catch 语句<strong>会改变其参数的内容</strong>。如果在改变了参数的内容后 catch 语句重新抛出异常，则只有当 catch <strong>异常声明是引用类型时</strong>我们<strong>对参数所做的改变才会被保留</strong>并继续传播：</p>
<p>为了<strong>一次性捕获所有异常</strong>.我们使用<strong>省略号</strong>作为<strong>异常声明</strong>，这样的处理代码称为**捕获所有异常( catch - all )**的处理代码，形如 <strong>catch (...)</strong>。一条捕获所有异常的语句可以与任意类型的异常匹配。<br>
<strong>catch (...)通常与重新抛出语句一起使用</strong>，其中 catch <strong>执行当前局部能完成的工作（处理收尾）</strong>，随后重新抛出异常：</p>
<p>catch (...)既能单独出现，也能与其他几个 catch 语句一起出现<br>
如果 catch (...) 与其他几个 catch 语句一起出现，<strong>则 catch {…) 必须在最后的位置</strong>。出现在捕获所有异常语句后面的 catch 语句将永远不会被匹配。</p>
<p>习题18.4<br>
exception是基类，能够接纳一切的派生类对象，下面派生类对象的catch就没意义了<br>
应该顺序倒过来<br>
习题18.5</p>
<pre><code>int main() {
	try {
	
	}
	catch (overflow_error err) { cout&lt;&lt;err.what(); abort(); }
	catch(underflow_error err) { cout &lt;&lt; err.what(); abort(); }
	catch (range_error err) { cout &lt;&lt; err.what(); abort(); }
	catch(domain_error err) { cout &lt;&lt; err.what(); abort(); }
	catch (invalid_argument err) { cout &lt;&lt; err.what(); abort(); }
	catch (out_of_range err) { cout &lt;&lt; err.what(); abort(); }
	catch (length_error err) { cout &lt;&lt; err.what(); abort(); }
	catch(runtime_error err) { cout &lt;&lt; .what(); abort(); }
	catch(logic_error err) { cout &lt;&lt; .what(); abort(); }
	catch(bad_cast err) { cout &lt;&lt; .what(); abort(); }
	catch(bad_alloc err) { cout &lt;&lt; .what(); abort(); }
}
</code></pre>
<p>习题18.6<br>
(a)：throw &amp;exceptionType()<br>
(b)：任何异常皆可<br>
(c)：throw int()</p>
<p>18.1.3 函数try语句块与构造函数<br>
<strong>构造函数</strong>在进入其函数体之前<strong>首先执行初始值列表</strong>。因为在初始值列表抛出异常时构造函数体内的** try 语句块还未生效**，所以构造函数体内的 catch 语句<strong>无法处理构造函数初始值列表抛出的异常</strong>。<br>
要想处理构造函数初始值抛出的异常，我们<strong>必须将构造函数写成函数 try 语句块</strong>（也称为<strong>函数测试块(function try block )<strong>的形式。<strong>函数 try 语句块</strong>使得一组 catch 语句</strong>既能处理构造函数体</strong>（或析构函数体)，<strong>也能处理</strong>构造函数的<strong>初始化过程</strong>（或析构函数的<strong>析构过程完全隐式的）)</strong>。</p>
<p>注意：关键字 try 出现在表示构造函数初始值列表的冒号以及表示构造函数体（此例为空）的花括号之前。与这个 try 关联的 catch 既能处理构造函数化抛出的异常，也能处理成员初始化列表抛出的异常。<br>
还有一种情况值得读者注意，在<strong>初始化构造函数的参数</strong>时<strong>也可能发生异常</strong>，这样的异常<strong>不属于函数 try 语句块</strong>的一部分。函数 try 语句块只能处理构造函数开始执行后发生的异常。和其他函数调用一样，如果在参数初始化的过程中发生了异常.则该异常<strong>属于调用表达式的一部分</strong>，并将<strong>在调用者所在的上下文中处理</strong>。<br>
<strong>处理构造函数初始值异常的唯一方法是将构造函数写成函数 try 语句块</strong>。</p>
<p>习题18.7</p>
<pre><code>template &lt;typename&gt;
	Blob&lt;T&gt;::Blob() try:data(std::make_shared&lt;std::vector&lt;T&gt;)){ } catch(const std::bad_alloc &amp;e){handle_out_of_memory(e);}
</code></pre>
<p>18.1.4 noexcept异常说明<br>
对于用户及编译器来说，预先知道某个函数不会抛出异常显然大有裨益。首先，知道函数不会抛出异常有助于简化调用该函数的化码；其次，如果编译器确认函数不会抛出异常，它就能执行某些特殊的优化操作，而这些优化操作并不适用于可能出错的代码<br>
我们可以通过提供 <strong>noexcept说明</strong> （ noexcept specification )<strong>指定某个函数不会抛出异常</strong>。<br>
void recoup(int) <strong>noexcept</strong>;  //不会抛出异常   <strong>注意noexcept的位置</strong>void alloc(int);  //可能抛出异常<br>
recoup 做了不抛出说明 （ nonthrowing specification )。</p>
<p><strong>noexcept 说明要么出现在该函数的所有声明语句和定义语句中，要么一次也不出现。</strong> 该说明应该在函数的尾置返回类型（参见6.3.3节，第206页）之前。<br>
我们也可以在<strong>函数指针的声明和定义中指定 noexcept</strong> 。<br>
在 <strong>typedef 或类型别名</strong>中则<strong>不能出现 noexcept</strong> 。<br>
在成员函数中， noexcept 说明符需要跟在 <strong>const 及引用限定符之后</strong>,而在 <strong>final</strong> 、<strong>override 或虚函数的=0之前</strong>。</p>
<p>读者需要请楚的一个事实是<strong>编译器并不会在编译时检查 noexcept 说明</strong>。实际上，如果一个函数在说明了 noexcept 的同时又含有 throw 语句或者调用了可能抛出异常的其他函数，编译器将顺利编译通过，并不会因为这种违反异常说明的情况而报错（不排除个别编译器会对这种用法提出警告）：<br>
尽管函数声明了它不会抛出异常，但实际上还是抛出了。<strong>一旦一个 noexcept 函数抛出了异常</strong>，程序就会<strong>调用 terminate</strong>以确保遵守不在运行时抛出异常的承诺。上述过程对是否执行栈展开未作约定，因此 <strong>noexcept 可以用在两种情况下</strong>：一是我们<strong>确认函数不会抛出异常</strong>，二是我们<strong>根本不知道该如何处理异常</strong>。<br>
指明某个函数不会抛出异常可以令该函数的调用者不必再考虑如何处理异常。无论是函数确实不抛出异常，还是程序被终止，调用者都无须为此负责。<br>
通常情况下，编译器不能也不必在编译时验证异常说明。</p>
<p>noexcept 说明符的实参常常与 <strong>noexcept 运算符 (noexcept operator )</strong> 混合使用。 noexcept 运算符是一个一元运算符，它的<strong>返回值是一个 bool 类型的右值常量表达式</strong>，用于<strong>表示给定的表达式是否会抛出异常</strong>。<br>
noexcept(recoup(i))  //如果recoup不抛出异常则结果为true;否则结果为false<br>
noexcept(e)<br>
当 e 调用的所有函数<strong>都做了不抛出说明</strong>且 e <strong>本身不含有 throw 语句</strong>时，上述表达式为true ；否则 noexcept ( e )返回 false 。<br>
我们可以使用 noexcept 运算符得到如下的异常说明：<br>
void f() noexcept (noexcept (g ()));  //<strong>f和g的异常说明一致<br>
注意后面的不是函数体，而是noexcept说明符</strong><br>
如果函数 g 承诺了不会抛出异常，则 f 也不会抛出异常；如果 g 没有异常说明符，或者 g虽然有异常说明符巧是允许抛出异常，则 f 也可能抛出异常。<br>
noexcept 有两层含义；当跟在函数参数列表后面时它是<strong>异常说明符</strong>；而当作为 noexcept 异常说明的 bool 实参出现时，它是一个<strong>运算符</strong>。void f() noexcept (noexcept (g ())); //第一个noexcept是异常说明符，第二个noexcept是运算符。</p>
<p>尽管 noexcept 说明符<strong>不属于函数类型的一部分</strong>，但是函数的<strong>异常说明仍然会影响函数的使用。</strong><br>
<strong>函数指针</strong>及该指针<strong>所指的函数必须具有一致的异常说明</strong>。也就是说，如果我们为某个<strong>指针做了不抛出异常的声明</strong>，则该指针将<strong>只能指向不抛出异常的函数</strong>。相反，如果我们<strong>显式或隐式</strong>地<strong>说明</strong>了指针<strong>可能抛出异常</strong>，则该指针<strong>可以指向任何函数</strong>，<strong>即使是承诺了不抛出异常</strong>的**函数也可以（不同于const，const指针也可以指向非常量）<br>
区分<code>(*func)(int)</code>和 <code>*fun(int)</code> 前者是一个指针，后者是一个函数，调用运算符优先级高于解引用运算符 **</p>
<p>如果一个<strong>虚函数</strong>承诺了它<strong>不会抛出异常</strong>，则后续<strong>派生出来的虚函数</strong>也<strong>必须做出同样的承诺</strong>；与之相反，如果<strong>基类的虚函数允许抛出异常</strong>，则<strong>派生类</strong>的对应函数<strong>既可以允许</strong>抛出异常，<strong>也可以不允许</strong>抛出异常</p>
<p>当编译器<strong>合成拷贝控制成员</strong>时，同时也<strong>生成一个异常说明</strong>。如果对<strong>所有成员</strong>和<strong>基类的所有操作</strong>都承诺了<strong>不会抛出异常</strong>，则<strong>合成的成员是 noexcept</strong> 的。如果合成成员调用的<strong>任意一个函数可能抛出异常</strong>，则合成的成员是<strong>noexcept ( false )</strong>。而且，如果我们定义了一个<strong>析构函数</strong>但是<strong>没有为它提供异常说明</strong>，则<strong>编译器将合成一个</strong>。合成的异常说明将与假设由编译器为类合成析构函数时所得的异常说明一致。</p>
<p>习题18.8<br>
noexcep异常说明可以用来指定某个函数不会抛出异常（C++11新特性），声明和定义时皆需要出现在函数之后，但在final、override、=0之前</p>
<p>18.1.5异常类层次</p>
<p><strong>类型 exception</strong> 仅仅定义了<strong>拷贝构造函数、拷贝赋值运算符、一个虚析构函数和一个名为 what 的虚成员</strong>其中 what 函数返回一个<code>const char *</code>,该指针指向一个以null结尾的字符数组，并且确保不会抛出任何异常。<br>
类exception、bad_cast和bad_alloc定义了默认构造函数。类runtime_error和logic_error没有默认构造函数，但是有一个可以接受C风格字符串或者标准库string类型实参的构造函数，这些实参负责提供关于错误的更多信息。<br>
由上可知，我们的面向应用的异常类继承自标准异常类。和其他继承体系一样，异常类也可以看作按照层次关系组织的。<strong>层次越低.表示的异常情况就越特殊</strong>。例如，在异常类继承体系中位于最顶层的通常是 exception , exception 表示的含义是某处出错了，至于错误的细节则未作描述。<br>
继承体系的第二层将 exception 划分为两个大的类别：<strong>运行时错误</strong>和<strong>逻辑错误</strong>。运行时错误表示的是<strong>只有在程序运行时才能检测到的错误</strong>；而逻辑错误一般指的是我们可以<strong>在程序代码中发现的错误</strong>。<br>
实际的应用程序通常会自定义exception（或者exception的标准库派⽣类）的派⽣类以扩展其继承体系。这些⾯向应⽤的异常类表示了与应⽤相关的异常条件<br>
我们使用自定义异常类的方式与使用标准异常类的方式完全一样。程序在某处抛出异常类型的对象，在另外的地方捕获并处理这些出现的问题。</p>
<p>习题18.9</p>
<pre><code>class out_of_stock :public std::runtime_error {
public:
	explicit out_of_stock(const std::string &amp;s) :std::runtime_error(s) {}
};

class isbn_mismatch :public std::logic_error {
public:
	explicit isbn_mismatch(const std::string &amp;s): std::logic_error(s){}
	isbn_mismatch(const std::string &amp;s, const std::string &amp;lhs, const std::string &amp;rhs) :std::logic_error(s), left(lhs), right(rhs) {}
	const std::string left, right;
};
Sales_Data&amp; Sales_Data::operator+=(const Sales_Data&amp; rhs) {
	if (isbn() != rhs.isbn())
		throw isbn_mismatch(&quot;wrong isbns&quot;, isbn(), rhs.isbn());
	units_sold += rhs.units_sold;
	ave += rhs.ave;
	return *this;
}
</code></pre>
<p>习题18.10<br>
自己定义的异常类型和标准库的异常类处理方式完全一样，一处抛出一处捕获<br>
主要差异在于自己定义的可以添加说明string 更加清晰，容易定位错误<br>
习题18.11<br>
what 函数返回一个<code>const char *</code>，该指针指向一个以null结尾的字符数组，并且确保不会抛出任何异常。<br>
<strong>noexcept 可以用在两种情况下</strong>：一是我们<strong>确认函数不会抛出异常</strong>，二是我们<strong>根本不知道该如何处理异常</strong>。<br>
what其实两种情况都有，一是不可能发生异常，而是如果发生了异常也无法处理，一旦处理反而会导致递归调用自身。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 108. 将有序数组转换为二叉搜索树[简单]]]></title>
        <id>https://lixin-ee.github.io//post/shu-108-jiang-you-xu-shu-zu-zhuan-huan-wei-er-cha-sou-suo-shu-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/shu-108-jiang-you-xu-shu-zu-zhuan-huan-wei-er-cha-sou-suo-shu-jian-dan">
        </link>
        <updated>2019-11-27T01:50:52.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。<br>
本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。<br>
示例:<br>
给定有序数组: [-10,-3,0,5,9],<br>
一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：<br>
0<br>
/ <br>
-3   9<br>
/   /<br>
-10  5<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>108</p>
<pre><code>class Solution {
public:
    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) {
        if(nums.empty())
            return NULL;
        TreeNode *root=new TreeNode(0);
        genTree(root,0,nums.size()-1,nums);
        return root;
    }
    
    void genTree(TreeNode *cur,int beg,int end,vector&lt;int&gt;&amp; nums){
        if(beg==end){
            cur-&gt;val=nums[beg];
            cur-&gt;left==NULL;
            cur-&gt;right==NULL;
            return;
        }
        int mid=(end-beg+1)/2+beg;
        cur-&gt;val=nums[mid];
        if(mid&gt;beg){
            //TreeNode *left=new TreeNode(0);
            //cur-&gt;left=left;
            cur-&gt;left=new TreeNode(0);
            genTree(cur-&gt;left,beg,mid-1,nums);
        }else
        {
            cur-&gt;left=NULL;
            return;
        }
        
        if(mid&lt;end){
            cur-&gt;right=new TreeNode(0);
            genTree(cur-&gt;right,mid+1,end,nums);
        }else
        {
            cur-&gt;right=NULL;
            return;
        }
        return;            
    }
};
</code></pre>
<p>//似曾相识，回去翻看了一下发现不是在大话数据结构或者算法，而是在算法导论<br>
//果然开卷有益，看到第一幅图就有思路了，发现重点在于高度平衡，这意味着高度不能超过log2（n）<br>
//然后联想到二分查找法，它的时间复杂度也是log2（n）<br>
//所以当前节点应该为数组的中间值，哪到底是取ceil还是floor呢？示例中是取了ceil<br>
//然后就发现自己坑了自己，一直输出不对，调试了才发现ceil是多此一举了。。。因为beg和end本来就是int啊。。。。自动向下取整问你怕不怕<br>
//所以之前那么多人用复杂得多的mid=(end-beg+1)/2+beg;还是有原因的<br>
//cur-&gt;val<mark>nums[beg];<br>
//日常哈皮把=写成</mark>，还巨难发现<br>
//又忘了空树的情况了。。。面向测试用例编程，哭唧唧</p>
<p>然后来看一下网友题解<br>
首先是简洁的代码</p>
<pre><code>class Solution {
public:
    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) {
        if(nums.empty()) return nullptr;
        return helper(nums,0,nums.size()-1);
    }

    TreeNode* helper(vector&lt;int&gt;&amp; nums, int left, int right){
        if(left &gt; right)
            return nullptr;
        int mid = (left+ right) /2;
        TreeNode *root = new TreeNode(nums[mid]);
        root-&gt;left = helper(nums, left,mid -1);
        root-&gt;right = helper(nums,mid+1, right);
        return root;
    }
};
</code></pre>
<p>然后是解释和多种解法：</p>
<blockquote>
<p>解法一 递归<br>
如果做了 98 题 和 99 题，那么又看到这里的升序数组，然后应该会想到一个点，二叉搜索树的中序遍历刚好可以输出一个升序数组。<br>
所以题目给出的升序数组就是二叉搜索树的中序遍历。<br>
根据中序遍历还原一颗树，又想到了 105 题 和 106 题，通过中序遍历加前序遍历或者中序遍历加后序遍历来还原一棵树。前序（后序）遍历的作用呢？提供根节点！然后根据根节点，就可以递归的生成左右子树。<br>
这里的话怎么知道根节点呢？平衡二叉树，既然要做到平衡，我们只要把根节点选为数组的中点即可。<br>
综上，和之前一样，找到了根节点，然后把数组一分为二，进入递归即可。注意这里的边界情况，包括左边界，不包括右边界。</p>
</blockquote>
<pre><code>public TreeNode sortedArrayToBST(int[] nums) {
    return sortedArrayToBST(nums, 0, nums.length);
}

private TreeNode sortedArrayToBST(int[] nums, int start, int end) {
    if (start == end) {
        return null;
    }
    int mid = (start + end) &gt;&gt;&gt; 1;
    TreeNode root = new TreeNode(nums[mid]);
    root.left = sortedArrayToBST(nums, start, mid);
    root.right = sortedArrayToBST(nums, mid + 1, end);

    return root;
}
</code></pre>
<blockquote>
<p>解法二 栈 DFS<br>
递归都可以转为迭代的形式。<br>
一部分递归算法，可以转成动态规划，实现空间换时间，例如 5题，10题，53题，72题，从自顶向下再向顶改为了自底向上。<br>
一部分递归算法，只是可以用栈去模仿递归的过程，对于时间或空间的复杂度没有任何好处，比如这道题，唯一好处可能就是能让我们更清楚的了解递归的过程吧。<br>
自己之前对于这种完全模仿递归思路写成迭代，一直也没写过，今天也就试试吧。<br>
思路的话，我们本质上就是在模拟递归，递归其实就是压栈出栈的过程，我们需要用一个栈去把递归的参数存起来。这里的话，就是函数的参数 start，end，以及内部定义的 root。为了方便，我们就定义一个类。</p>
</blockquote>
<pre><code>class MyTreeNode {
    TreeNode root;
    int start;
    int end 
    MyTreeNode(TreeNode r, int s, int e) {
        this.root = r;
        this.start = s;
        this.end = e;
    }
}
</code></pre>
<blockquote>
<p>第一步，我们把根节点存起来。</p>
</blockquote>
<pre><code>Stack&lt;MyTreeNode&gt; rootStack = new Stack&lt;&gt;();
int start = 0;
int end = nums.length;
int mid = (start + end) &gt;&gt;&gt; 1;
TreeNode root = new TreeNode(nums[mid]);
TreeNode curRoot = root;
rootStack.push(new MyTreeNode(root, start, end));
</code></pre>
<blockquote>
<p>然后开始递归的过程，就是不停的生成左子树。因为要生成左子树，end - start 表示当前树的可用数字的个数，因为根节点已经用去 1 个了，所以为了生成左子树，个数肯定需要大于 1。</p>
</blockquote>
<pre><code>while (end - start &gt; 1) {
    mid = (start + end) &gt;&gt;&gt; 1; //当前根节点
    end = mid;//左子树的结尾
    mid = (start + end) &gt;&gt;&gt; 1;//左子树的中点
    curRoot.left = new TreeNode(nums[mid]);
    curRoot = curRoot.left;
    rootStack.push(new MyTreeNode(curRoot, start, end));
}
</code></pre>
<blockquote>
<p>在递归中，返回 null 以后，开始生成右子树。这里的话，当 end - start &lt;= 1 ，也就是无法生成左子树了，我们就可以出栈，来生成右子树。</p>
</blockquote>
<pre><code>MyTreeNode myNode = rootStack.pop();
//当前作为根节点的 start end 以及 mid
start = myNode.start;
end = myNode.end;
mid = (start + end) &gt;&gt;&gt; 1;
start = mid + 1; //右子树的 start
curRoot = myNode.root; //当前根节点
if (start &lt; end) { //判断当前范围内是否有数
    mid = (start + end) &gt;&gt;&gt; 1; //右子树的 mid
    curRoot.right = new TreeNode(nums[mid]);
    curRoot = curRoot.right;
    rootStack.push(new MyTreeNode(curRoot, start, end));
}
</code></pre>
<blockquote>
<p>然后把上边几块内容组合起来就可以了。</p>
</blockquote>
<pre><code>class MyTreeNode {
    TreeNode root;
    int start;
    int end;

    MyTreeNode(TreeNode r, int s, int e) {
        this.root = r;
        this.start = s;
        this.end = e;
    }
}
public TreeNode sortedArrayToBST(int[] nums) {
    if (nums.length == 0) {
        return null;
    }
    Stack&lt;MyTreeNode&gt; rootStack = new Stack&lt;&gt;();
    int start = 0;
    int end = nums.length;
    int mid = (start + end) &gt;&gt;&gt; 1;
    TreeNode root = new TreeNode(nums[mid]);
    TreeNode curRoot = root;
    rootStack.push(new MyTreeNode(root, start, end));
    while (end - start &gt; 1 || !rootStack.isEmpty()) {
        //考虑左子树
        while (end - start &gt; 1) {
            mid = (start + end) &gt;&gt;&gt; 1; //当前根节点
            end = mid;//左子树的结尾
            mid = (start + end) &gt;&gt;&gt; 1;//左子树的中点
            curRoot.left = new TreeNode(nums[mid]);
            curRoot = curRoot.left;
            rootStack.push(new MyTreeNode(curRoot, start, end));
        }
        //出栈考虑右子树
        MyTreeNode myNode = rootStack.pop();
        //当前作为根节点的 start end 以及 mid
        start = myNode.start;
        end = myNode.end;
        mid = (start + end) &gt;&gt;&gt; 1;
        start = mid + 1; //右子树的 start
        curRoot = myNode.root; //当前根节点
        if (start &lt; end) { //判断当前范围内是否有数
            mid = (start + end) &gt;&gt;&gt; 1; //右子树的 mid
            curRoot.right = new TreeNode(nums[mid]);
            curRoot = curRoot.right;
            rootStack.push(new MyTreeNode(curRoot, start, end));
        }

    }

    return root;
}
</code></pre>
<blockquote>
<p>解法三 队列 BFS<br>
参考 这里。 和递归的思路基本一样，不停的划分范围。</p>
</blockquote>
<pre><code>class MyTreeNode {
    TreeNode root;
    int start;
    int end;

    MyTreeNode(TreeNode r, int s, int e) {
        this.root = r;
        this.start = s;
        this.end = e;
    }
}
public TreeNode sortedArrayToBST3(int[] nums) {
    if (nums.length == 0) {
        return null;
    }
    Queue&lt;MyTreeNode&gt; rootQueue = new LinkedList&lt;&gt;();
    TreeNode root = new TreeNode(0);
    rootQueue.offer(new MyTreeNode(root, 0, nums.length));
    while (!rootQueue.isEmpty()) {
        MyTreeNode myRoot = rootQueue.poll();
        int start = myRoot.start;
        int end = myRoot.end;
        int mid = (start + end) &gt;&gt;&gt; 1;
        TreeNode curRoot = myRoot.root;
        curRoot.val = nums[mid];
        if (start &lt; mid) {
            curRoot.left = new TreeNode(0);
            rootQueue.offer(new MyTreeNode(curRoot.left, start, mid));
        }
        if (mid + 1 &lt; end) {
            curRoot.right = new TreeNode(0);
            rootQueue.offer(new MyTreeNode(curRoot.right, mid + 1, end));
        }
    }

    return root;
}
</code></pre>
<blockquote>
<p>最巧妙的地方是它先生成 left 和 right 但不进行赋值，只是把范围传过去，然后出队的时候再进行赋值。这样最开始的根节点也无需单独考虑了。</p>
</blockquote>
<blockquote>
<p>扩展 求中点<br>
前几天和同学发现个有趣的事情，分享一下。<br>
首先假设我们的变量都是 int 值。<br>
二分查找中我们需要根据 start 和 end 求中点，正常情况下加起来除以 2 即可。<br>
int mid = (start + end) / 2<br>
但这样有一个缺点，我们知道int的最大值是 Integer.MAX_VALUE ，也就是2147483647。那么有一个问题，如果 start = 2147483645，end = = 2147483645，虽然 start 和 end都没有超出最大值，但是如果利用上边的公式，加起来的话就会造成溢出，从而导致mid计算错误。<br>
解决的一个方案就是利用数学上的技巧，我们可以加一个 start 再减一个 start 将公式变形。<br>
(start + end) / 2 = (start + end + start - start) / 2 = start + (end - start) / 2<br>
这样的话，就解决了上边的问题。<br>
然后当时和同学看到jdk源码中，求mid的方法如下<br>
int mid = (start + end) &gt;&gt;&gt; 1<br>
它通过移位实现了除以 2，但。。。这样难道不会导致溢出吗？<br>
首先大家可以补一下 补码 的知识。<br>
其实问题的关键就是这里了&gt;&gt;&gt; ，我们知道还有一种右移是&gt;&gt;。区别在于&gt;&gt;为有符号右移，右移以后最高位保持原来的最高位。而&gt;&gt;&gt;这个右移的话最高位补 0。<br>
所以这里其实利用到了整数的补码形式，最高位其实是符号位，所以当 start + end溢出的时候，其实本质上只是符号位收到了进位，而&gt;&gt;&gt;这个右移可以带着符号位右移，所以之前的信息没有丢掉。<br>
但&gt;&gt;有符号右移就会出现问题了，事实上 JDK6 之前都用的&gt;&gt;，这个 BUG 在 java 里竟然隐藏了十年之久。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第十七章 笔记+习题 17.5]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-qi-zhang-bi-ji-xi-ti-175</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-qi-zhang-bi-ji-xi-ti-175">
        </link>
        <updated>2019-11-26T12:45:18.000Z</updated>
        <content type="html"><![CDATA[<p>17.5 IO库再探<br>
17.5.1 格式化输入和输出<br>
除了条件状态外（参见8.1.2节，第279页），每个 iostream 对象还维护一个<strong>格式状态</strong>来控制 IO 如何格式化的细节。格式状态控制格式化的某些方面，如整型值是几进制、浮点值的精度、一个输出元素的宽度等。<br>
标准库定义了<strong>一组操纵符</strong>( manipulator )(参见1.2节，第6页）来<strong>修改流的格式状态</strong>，如表17.7和表17.8所示。一个操纵符是<strong>一个函数</strong>或是<strong>一个对象</strong>，会影响流的状态，并能用作输入或输出运算符的运算对象。类似输入和输出运算符，操纵符也<strong>返回它所处理的流对象</strong>，因此我们可以在一条语句中组合操纵符和数据。</p>
<p>操纵符用于<strong>两大类输出控制</strong>：控制<strong>数值的输出形式</strong>以及控制<strong>补白的数量和位置</strong>。大多数改变格式状态的操纵符都是<strong>设置/复原成对</strong>的;一个操纵符用来将格式状态设置为一个新值，而另一个用来将其复原，恢复为正常的默认格式。<br>
当操纵符改变流的格式化态时，通常改变后的状态对所有<strong>后续 IO 都生效。</strong></p>
<p>默认情况下，整型值的输入输出使用十进制。我们可以使用<strong>操纵符 hex 、 oct 和 dec</strong>将其改为<strong>十六进制、八进制或是改回十进制</strong>：<br>
注意，类似 boolalpha ,这些操纵符也会改变格式状态。它们会<strong>影响下一个和随后所有的整型输出</strong>，直至另一个操纵符又改变了格式为止。<br>
操纵符 hex 、 oct 和 dec 只影响整型运算对象，<strong>浮点值的表示形式不受影响</strong>。</p>
<p>如果需要打印八进制值或十六进制值，应该使用** showbase 操纵符**。当对流应用 showbase 操纵符时，<strong>会在输出结果中显示进制</strong>，它遵循与整型常量中指定进制相同的规范：<br>
•前导0x表示十六进制。<br>
•前导0表示八进制。<br>
•无前导字符串表示十进制。</p>
<p>操纵符 noshowbase 恢复 cout 的状态，从而不再显示整型值的进制。<br>
默认情况下，十六进制值会以小写打印，前导字符也是小写的 X 。 我们可以通过使用uppercase 操纵符来输出大写的 X 并将十六进制数字 a-f以大写输出：<br>
使用操纵符 nouppercase 、 noshowbase 和 dec 来重置流的状态。</p>
<p>•以多高精度（多少个数字）打印浮点值<br>
•数值是打印为十六进制、定点十进制还是科学记数法形式<br>
•对于没有小数部分的浮点值是否打印小数点<br>
<strong>默认情况下</strong>，<strong>浮点值</strong>按<strong>六位数字精度</strong>打印；如果浮点值<strong>没有小数部分，则不打印小数点</strong>：根据浮点数的<strong>值</strong>选择打印成<strong>定点十进制</strong>或<strong>科学记数法</strong>形式。标准库会选择一种可读性更好的格式：<strong>非常大和非常小</strong>的值打印<strong>为科学记数法</strong>形式，<strong>其他值</strong>打印为定点<strong>十进制</strong>形式。<br>
<strong>默认情况下</strong>，精度会<strong>控制打印的数字的总数</strong>。当打印时，浮点值按当前<strong>精度舍入</strong>而<strong>非截断</strong>。因此，如果当前精度为四位数字，则 3.14159将打印为3.142;如果精度为三位数字，则打印为3.14。</p>
<p>除非你需要控制浮点数的表示形式（如，按列打印数据或打印表示金额或百分比的数据），否则<strong>由标准库选择记数法是最好的方式</strong>。</p>
<p>默认情况下，当一个浮点值的小数部分为0时，不显示小数点。 showpoint 操纵符强制打印小数点：</p>
<p>当按列打印数据时，我们常常需要非常精细地控制数据格式。标准库提供了一些操纵符帮助我们完成所需的控制：</p>
<p>默认情况下，输入运算符会忽略空白符（空格符、制表符、换行符、换纸符和回车符)。<br>
操纵符 noskipws 会令输入运算符读取空白符，而不是跳过它们。为了恢复默认行为， 我们可以使用 skipws 操纵符</p>
<p>习题17.34</p>
<pre><code>int main() {
	cout &lt;&lt; noboolalpha &lt;&lt; true &lt;&lt; &quot; &quot; &lt;&lt; boolalpha &lt;&lt; true &lt;&lt; endl;
	cout &lt;&lt; hex &lt;&lt; 20 &lt;&lt;&quot; &quot;&lt;&lt; showbase &lt;&lt; 20 &lt;&lt; endl&lt;&lt;dec;
	cout &lt;&lt; 1.000000000000000 &lt;&lt;&quot; &quot;&lt;&lt; showpoint &lt;&lt; 1.00000000000000 &lt;&lt; endl;
	cout &lt;&lt; 1 &lt;&lt; &quot; &quot; &lt;&lt; showpos &lt;&lt;1 &lt;&lt; endl;

	cout &lt;&lt; setfill('#') &lt;&lt; &quot;i:&quot; &lt;&lt; setw(12) &lt;&lt; 16  &lt;&lt; endl ;
}
</code></pre>
<p>习题17.35</p>
<pre><code>int main() {
	cout &lt;&lt; hexfloat &lt;&lt;uppercase&lt;&lt; sqrt(2.0) &lt;&lt; endl;
}
</code></pre>
<p>习题17.36</p>
<pre><code>int main() {
	cout &lt;&lt; hexfloat &lt;&lt;uppercase&lt;&lt;internal&lt;&lt; sqrt(2.0) &lt;&lt; endl;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ C++ primer 第十六章 笔记+习题 16.5]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-liu-zhang-bi-ji-xi-ti-165</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-liu-zhang-bi-ji-xi-ti-165">
        </link>
        <updated>2019-11-26T08:45:31.000Z</updated>
        <content type="html"><![CDATA[<p>16.5 模板特例化<br>
<strong>当我们不能使用模板或者想制定特定的函数时就特例化，但其本质还是实例化</strong> 一个<strong>特例化版本</strong>就是模板的一个<strong>独立的定义</strong>，在<strong>其中一个或多个模板参数</strong>被指定为<strong>特定的类型</strong>。<br>
当我们特例化一个函数模板时，必须为原模板中的<strong>每个模板参数都提供实参</strong>。为了指出我们正在实例化一个模板，应使用<strong>关键字 template 后</strong>跟一个<strong>空尖括号对（&lt;&gt;）</strong>。空尖括号指出我们将为原模板的所有模板参数提供实参：</p>
<p>理解此特例化版本的困难之处是函数参数类型。当我们定义一个特例化版本时，函数参数类型必须与一个<strong>先前声明的模板中对应的类型匹配</strong>。本例中我们特例化：</p>
<p>当定义函数模板的特例化版本时，我们本质上接管了编译器的工作。即，我们为原模板的一个特殊实例提供了定义。重要的是要弄清：一个特例化版本本质上是一个实例，而非函数名的一个重载版本。<br>
特例化的<strong>本质是实例化一个模板</strong>，<strong>而非重载它</strong>。因此，特例化<strong>不影响函数匹配</strong><br>
我们将一个特殊的函数定义为一个<strong>特例化版本</strong>还是一个<strong>独立的非模板函数</strong>，会<strong>影响到函数匹配</strong>。</p>
<p>为了特例化一个模板，原模板的<strong>声明必须在作用域</strong>中。而且，在任何使用模板实例替代码之前，特例化版本的声明也必须在作用域中。<br>
对于普通类和函数，<strong>丢失声明的情况（通常）很容易发现</strong>——编译器将不能继续处理我们的代码。但是，如果丢失了一个特例化版本的声明，编译器通常可以用原模板生成代码。由于在丢失特例化版本时编译器通常会实例化原模板，很容易产生模板及其特例化版本声明顺序导致的错误，而这种错误又很难查找。<br>
如果一个程序使用一个特例化版本，而同时原模板的一个实例具有相同的模板实参集合，就会产生错误。但是，这种错误编译器又无法发现。<br>
<strong>模板</strong>及其<strong>特例化版本</strong>应该<strong>声明在同一个头文件中</strong>。所有<strong>同名模板的声明</strong>应该放在<strong>前面</strong>，<strong>然后是这些模板的特例化版本。</strong><br>
除了特例化函数模板，我们还可以<strong>特例化类模板</strong>。</p>
<p>在定义此特例化版本的 hash 时，唯一复杂的地方是：必须在<strong>原模板定义所在的命名空间中特例化它</strong>。</p>
<p>类似其他任何类，我们可以在<strong>类内或类外定义特例化版本的成员</strong>，本例中就是在类外定义的。重载的调用运算符必须为给定类型的值定义一个哈希函数。对于一个给定值，任何时候调用此函数都应该返回相同的结果。一个好的哈希函数对不相等的对象（几乎总是）应该产生不同的结果。<br>
假定我们的特例化版本在作用域中，当将 Sales _ data 作为容器的关键字类型时，<strong>编译器就会自动使用此特例化版本</strong>：<br>
为了使Sales_data 的用户能够使用hash 的特例化版本，我们应该在Sales_data 的<strong>头文件中定义该特例化版本</strong>。</p>
<p>与函数模板<strong>不同</strong>，<strong>类模板的特例化不必为所有模板参数提供实参</strong>。我们可以<strong>只指定一部分</strong>而非所有模板参数，或是参数的一部分而非全部特性。一个<strong>类模板</strong>的<strong>部分特例化</strong>(partial specialization )<strong>本身是一个模板</strong>，使用它时用户还必须为那些在特例化版本中未指定的模板参数提供实参<br>
我们<strong>只能部分特例化类模板，而不能部分特例化函数模板</strong>。</p>
<p>由于一个<strong>部分特例化版本本质是一个模板</strong>，与往常一样，我们首先定义模板参数。类似任何其他特例化版本，部分特例化版本的名字与原模板的名字相同。对每个未完全确定类型的模板参数，在特例化版本的模板参数列表中都有一项与之对应。在类名之后，我们为要特例化的模板参数指定实参，这些实参列于模板名之后的尖括号中。这些实参与原始模板中的参数按位置对应。<br>
部分特例化版本的模板参数列表是原始模板的参数列表的<strong>一个子集</strong>或者是<strong>一个特例化版本</strong>。<br>
我们<strong>可以只特例化特定成员函数</strong>而不是特例化整个模板。</p>
<p>习题16.62</p>
<pre><code>namespace std {
	template&lt;&gt;
	struct hash&lt;Sales_Data&gt;
	{
		typedef size_t result_type;
		typedef Sales_Data argument_type;
		size_t operator()(const Sales_Data &amp;s)const;
	};
	size_t hash&lt;Sales_Data&gt;::operator()(const Sales_Data &amp;s)const {
		return hash&lt;string&gt;()(s.ISBN) ^ hash&lt;unsigned&gt;()(s.units_sold) ^ hash&lt;double&gt;()(s.ave);

	}
}
</code></pre>
<p>习题16.63+16.64</p>
<pre><code>template &lt;typename T&gt;
int countv(vector&lt;T&gt; &amp;vt,T t) {
	int count=0;
	for (auto i : vt)
		if (i == t)
			++count;
	return count;
}
template&lt;&gt;
int countv(vector&lt;const char*&gt;&amp;vt, const char *t) {
	int count = 0;
	for (auto i : vt)
		if (i == t)
			++count;
	return count;
};
int main() {
	vector&lt;string&gt; vs{ &quot;123&quot;,&quot;456&quot;,&quot;789&quot;,&quot;123&quot; };
	vector&lt;int&gt; vi{ 1,2,3,4,5,1,2,3,1,2 };
	vector&lt;double&gt; vd{ 1.0,2.0,3.0,1.0 };
	cout &lt;&lt; countv(vs, string(&quot;123&quot;)) &lt;&lt; endl;
	cout &lt;&lt; countv(vi, 1) &lt;&lt; endl;
	cout &lt;&lt; countv(vd, 1.0) &lt;&lt; endl;
	vector&lt;const char*&gt; vc{ &quot;123&quot;,&quot;456&quot;,&quot;789&quot;,&quot;123&quot; };
	cout &lt;&lt; countv(vc, &quot;123&quot;) &lt;&lt; endl;
}
</code></pre>
<p>注意 	cout &lt;&lt; countv(vs, string(&quot;123&quot;)) &lt;&lt; endl;中 &quot;123&quot;属于<code>const char[]</code>，所以是无法直接和vs的string匹配的，必须用string来构造临时变量</p>
<p>习题16.65</p>
<pre><code>template&lt;&gt; string debug_rep(const char *p) {
	ostringstream ret;
	ret &lt;&lt; &quot;const char *p&quot;&lt;&lt;&quot; &quot;;
	ret &lt;&lt; &quot;pointer:&quot; &lt;&lt; p;
	if (p)
		ret &lt;&lt; &quot; &quot; &lt;&lt; *p;
	else
		ret &lt;&lt; &quot;null pointer&quot;;
	return ret.str();
}

template&lt;&gt; string debug_rep(char *p) {
	ostringstream ret;
	ret &lt;&lt; &quot;char *p&quot; &lt;&lt; &quot; &quot;;
	ret &lt;&lt; &quot;pointer:&quot; &lt;&lt; p;
	if (p)
		ret &lt;&lt; &quot; &quot; &lt;&lt; *p;
	else
		ret &lt;&lt; &quot;null pointer&quot;;
	return ret.str();
}
int main() {
	auto c = &quot;123&quot;;
	cout&lt;&lt;debug_rep(c)&lt;&lt;endl;
	char *cc = &quot;123&quot;;
	cout &lt;&lt; debug_rep(cc) &lt;&lt; endl;
}
</code></pre>
<p>注意：特例化的话本质上是模板的实例化，所以只需要模板的声明，而不需要模板的定义（注意区分模板的定义和实例化之间的区别）</p>
<p>习题16.66+16.67<br>
特例化能够保留原来的模板，保证较高的通用性，但是同时容易因为声明顺序或者代码错误出现调用了非目标的实例化函数。<br>
<strong>重载会改变匹配优先度，而特例化则不会</strong><br>
特例化的<strong>本质是实例化一个模板</strong>，<strong>而非重载它</strong>。因此，特例化<strong>不影响函数匹配</strong></p>
<p>习题感悟<br>
注意 	cout &lt;&lt; countv(vs, string(&quot;123&quot;)) &lt;&lt; endl;中 &quot;123&quot;属于<code>const char[]</code>，所以是无法直接和vs的string匹配的，必须用string来构造临时变量<br>
注意：特例化的话本质上是模板的实例化，所以只需要模板的声明，而不需要模板的定义（注意区分模板的定义和实例化之间的区别）<br>
特例化的<strong>本质是实例化一个模板</strong>，<strong>而非重载它</strong>。因此，特例化<strong>不影响函数匹配</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ C++ primer 第十六章 笔记+习题 16.4]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-liu-zhang-bi-ji-xi-ti-164</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-liu-zhang-bi-ji-xi-ti-164">
        </link>
        <updated>2019-11-26T01:39:00.000Z</updated>
        <content type="html"><![CDATA[<p>16.4可变参数模板<br>
一个可变参数模板(variadic template)就是一个<strong>接受可变数目参数</strong>的模板函数或模板类。可变数目的参数被称为<strong>参数包</strong>（parameterpacket)。存在两种参数包：模板参数包(template parameter packet),表示零个或多个模板参数；函数参数包（functionparameterpacket)，表示零个或多个函数参数。<br>
我们用一个<strong>省略号（一定必须是三个点，注意细节如何输入）</strong> 来指出一个模板参数或函数参数表示一个包，在一个模板参数列表中， <strong>class ...或 typename ...</strong> 指出接下来的参数表示零个或多个类型的列表：<br>
1.一个<strong>类型名后面跟一个省略号</strong>表示<strong>零个</strong>或多个给定类型的非类型参数的列表。<br>
2.在函数参数列表中，如果一个<strong>参数的类型</strong>是一个<strong>模板参数包</strong>，则此<strong>参数</strong>也是一个<strong>函数参数包</strong>。</p>
<p>声明了 foo 是一个可变参数函数模板，它有一个名为 T 的类型参数，和一个名为 Args的模板参数包。这个包表示零个或多个额外的类型参数。foo 的函数参数列表包含一个const &amp;类型的参数，指向 T 的类型，还包含一个名为 rest 的函数参数包，此包表示零个或多个函数参数。</p>
<p>当我们<strong>需要知道包中有多少元素</strong>时，可以使用** sizeof ...运算符**，sizeof ...也返回一个常量表达式<br>
cout&lt;&lt;sizeof…(Args)<br>
<strong>注意必须是在模板内部调用，而不是在函数外部调用</strong></p>
<p>习题16.51+52</p>
<pre><code>template&lt;typename T,typename... Args&gt;
void foo(const T &amp;t, const Args&amp;...rest) {
	cout&lt;&lt;sizeof...(Args)&lt;&lt;endl;
	cout &lt;&lt; sizeof...(rest) &lt;&lt; endl;
}
int main() {
	foo(123, &quot;123&quot;, 123, 123);
	foo(&quot;123&quot;, 123, &quot;12&quot;);
	foo(123,&quot;123&quot;);
	foo(&quot;12&quot;);
}
</code></pre>
<p>16.4.1 编写可变参数函数模板<br>
我们可以使用一个 <strong>initializer _ list</strong> 来定义一个可接受<strong>可变数目实参的函数</strong>。但是，所有实参<strong>必须具有相同的类型</strong>（或它们的类型可以转换为同一个公共类型）。当我们既不知道想要处理的实参的数目也不知道它们的类型时，可变参数函数是很有用的。<br>
可变参数函数<strong>通常是递归的</strong>（参见6.3.2节，第204页）。<strong>第一步调用处理</strong>包中的<strong>第一个实参</strong>，然后用<strong>剩余实参调用自身</strong>。我们的 <strong>print</strong>函数也是这样的模式，每次递归调用将<strong>第二个实参打印</strong>到<strong>第一个实参</strong>表示的<strong>流中</strong>。为了<strong>终止递归</strong>.我们还需要<strong>定义一个非可变参数</strong>的 print 函数，它接受一个流和一个对象</p>
<p>当定义可变参数版本的print时，<strong>非可变参数版本的声明必须在作用域中</strong>，否则，可变参数版本会<strong>无限递归</strong></p>
<p>习题16.53</p>
<pre><code>template &lt;typename T&gt; 
ostream &amp;print(ostream &amp;os, const T &amp;t) {
	return os &lt;&lt; t;
}
template&lt;typename T,typename...Args&gt;
ostream&amp; print(ostream &amp;os,T &amp;t, Args&amp;...rest) {
	os &lt;&lt; t&lt;&lt;&quot;,&quot;;
	return print(os, rest...);
}
</code></pre>
<p>注意 递归调用时需要用rest...来扩展可变参数列表作为实参<br>
习题16.54<br>
显示缺少&lt;&lt;定义<br>
习题16.55<br>
在可变参数版本眼中是看不到非可变参数版本的声明的，导致陷入无限调用自身递归，最后内存耗尽</p>
<p>16.4.2 包扩展<br>
对于一个参数包，<strong>除了获取其大小</strong>外，我们能对它做的<strong>唯一</strong>的事情就是<strong>扩展 （expand)<strong>它。当扩展一个包时，我们还要提供用于每个扩展元素的模式 （pattern )。 扩展一个包就是将它</strong>分解为构成的元素</strong>，对每个元素应用模式，获得扩展后的列表。我们通过<strong>在模式右边放一个省略号（...）来触发扩展操作。</strong></p>
<p>对 Args 的扩展中，编译器将模式 constArg &amp;应用到模板参数包 Args 中的每个元素。此，此模式的扩展结果是一个逗号分隔的零个或多个类型的列表，每个类型都形如const type&amp;<br>
第二个扩展发生在对 print 的（递归）调用中。在此情况下，模式是函数参数包的名字（即 rest )。此模式扩展出一个由包中元素组成的、逗号分隔的列表。</p>
<p>print 中的函数包扩展仅仅将包扩展为其构成元素， C ++语言还允许更复杂的扩展模式。例如，我们可以编写第二个可变参数函数，<strong>对其每个实参调用 debug_rep</strong> (参见16.3节，第615页），然后调用 print 打印结果 string</p>
<p><strong>注意符号的位置 是debug_rep(rest)…而不是debug_rep(rest…)，后者等于在debug_rep的形参中扩展了rest<br>
<strong>此模式表示我们希望对函数参数包 rest 中的</strong>每个元素</strong>调用 debug_rep</p>
<p>扩展中的模式会独立地应用于包中的每个元素。</p>
<p>习题16.56</p>
<pre><code>ostream &amp;errorMsg(ostream &amp;os, const Args&amp;...rest) {
	return print(os, debug_rep(rest)...);
}
</code></pre>
<p>习题16.57<br>
参数列表版本的只能定义同一类型的形参，可变参数列表的可以多种类型<br>
使用参数初始化列表initializer list也可以定义一个可接受可变参数数目的函数，但是所有的实参都必须具有相同的类型（或者可转变为相同的类型）</p>
<p>16.4.3 转发参数包<br>
<strong>保持类型信息</strong>是一个<strong>两阶段</strong>的过程。<strong>首先</strong>，为了保持实参中的类型信息，必须将 emplace_back 的函数参数<strong>定义为</strong>模板类型参数的<strong>右值引用</strong>（參见16.2.7节，第613页）：</p>
<p><strong>其次</strong>，当 emplace _ back 将这些实参传递给 construct 时，我们<strong>必须使用 forward</strong>来保持<strong>实参的原始类型</strong>（参见16.2.7节，第614页）；</p>
<p>习题16.58</p>
<pre><code>template&lt;class...Args&gt;
inline void StrVec::emplace_back(Args&amp;&amp;... args) {
	chk_n_alloc();
	alloc.construct(first_free++, std::forward&lt;Args&gt;args...);
}
</code></pre>
<p>习题16.59<br>
s作为参数被转发<br>
习题16.60<br>
接受可变参数模板，转发其参数初始化一个内存于内存空间，返回一个shared_ptr<br>
习题16.61<br>
其实和emplace比较像啦，接受可变参数目标然后new新的对象返回shared_ptr</p>
<p>习题感悟：<br>
注意 递归调用时需要用rest...来扩展可变参数列表作为实参</p>
]]></content>
    </entry>
</feed>