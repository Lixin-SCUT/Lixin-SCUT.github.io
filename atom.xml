<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-05-03T15:13:34.271Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>千里之行，始于足下。不积跬步，无以至千里。</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[数组 209. 长度最小的子数组[中等]]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-209-chang-du-zui-xiao-de-zi-shu-zu-zhong-deng</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-209-chang-du-zui-xiao-de-zi-shu-zu-zhong-deng">
        </link>
        <updated>2020-05-03T13:57:24.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的连续子数组，返回 0。<br>
示例: <br>
输入: s = 7, nums = [2,3,1,2,4,3]<br>
输出: 2<br>
解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。<br>
进阶:<br>
如果你已经完成了O(n) 时间复杂度的解法, 请尝试 O(n log n) 时间复杂度的解法。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/minimum-size-subarray-sum<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>第一想法就是因为是连续子数组，所以可以用双指针</p>
<p>但是实现起来也没那么简单</p>
<ol>
<li>一开始我的想法是先移动指针再判断是否等于s，但是很容易导致边界问题和奇怪的指针移动问题，比如第一个数就满足条件了呢</li>
<li>然后改为sum初始化为nums[0]，判断和s的关系再进行相应的指针移动</li>
<li>当一个数就能大于s的情况最特殊，我选择直接返回</li>
<li>然后递增right可能会到达尾后位置，此时必须判断再加sum，否则会导致段错误</li>
<li>为了方便返回0，我初始化为0，但是也导致了第一次修改ans需要特判</li>
</ol>
<pre><code>class Solution {
public:
    int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) {
        if(nums.size() == 0)
        {
            return 0;
        }
        int left = 0;
        int right = 0;
        int sum = nums[0];
        int ans = 0;
        while(right &lt; nums.size())
        {
            if(sum &gt;= s)
            {
                if(left == right)
                {
                    return 1;
                }
                else
                {
                    if(ans == 0)
                    {
                        ans =  right - left + 1;
                    }
                    else
                    {
                        ans = min(ans , right - left + 1);
                    }
                    sum -= nums[left];
                    ++left;
                }
            }
            else
            {
                ++right;
                if(right &lt; nums.size())
                {
                    sum += nums[right];
                }
            }
            
        }
        return ans;
    }
};
</code></pre>
<p>最后题目的进阶很明显是想用二分法，看看题解是怎么做的</p>
<p>网友题解：</p>
<blockquote>
<p>解法一 暴力破解<br>
从第 0 个数字开始，依次添加数字，记录当总和大于等于 s 时的长度。<br>
从第 1 个数字开始，依次添加数字，记录当总和大于等于 s 时的长度。<br>
从第 2 个数字开始，依次添加数字，记录当总和大于等于 s 时的长度。<br>
...<br>
从最后个数字开始，依次添加数字，记录当总和大于等于 s 时的长度。<br>
从上边得到的长度中选择最小的即可。</p>
</blockquote>
<pre><code>public int minSubArrayLen(int s, int[] nums) {
    int min = Integer.MAX_VALUE;
    int n = nums.length;
    for (int i = 0; i &lt; n; i++) {
        int start = i;
        int sum = 0;
        while (start &lt; n) {
            sum += nums[start];
            start++;
            //当前和大于等于 s 的时候结束
            if (sum &gt;= s) {
                min = Math.min(min, start - i);
                break;
            }
        }
    }
    //min 是否更新，如果没有更新说明数组所有的数字和小于 s, 没有满足条件的解, 返回 0
    return min == Integer.MAX_VALUE ? 0 : min;
}
</code></pre>
<blockquote>
<p>时间复杂度：O(n²)。</p>
</blockquote>
<blockquote>
<p>解法二 双指针<br>
受到 76 题 Minimum Window Substring 的启示，找一个范围使得其值满足某个条件，然后就会想到滑动窗口，也就是用双指针的方法。和这道题本质是一样的。<br>
用双指针 left 和 right 表示一个窗口。<br>
1.right 向右移增大窗口，直到窗口内的数字和大于等于了 s。进行第 2 步。<br>
2.记录此时的长度，left 向右移动，开始减少长度，每减少一次，就更新最小长度。直到当前窗口内的数字和小于了 s，回到第 1 步。</p>
</blockquote>
<pre><code>public int minSubArrayLen(int s, int[] nums) {
    int n = nums.length;
    if (n == 0) {
        return 0;
    }
    int left = 0;
    int right = 0;
    int sum = 0;
    int min = Integer.MAX_VALUE;
    while (right &lt; n) {
        sum += nums[right];
        right++;
        while (sum &gt;= s) {
            min = Math.min(min, right - left);
            sum -= nums[left];
            left++;
        }
    }
    return min == Integer.MAX_VALUE ? 0 : min;
}
</code></pre>
<blockquote>
<p>解法三 二分查找<br>
正常想的话，到解法二按理说已经结束了，但题目里让提出一个 O(nlog(n)) 的解法<br>
看到 log 就会想到二分查找，接着就会想到有序数组，最后，有序数组在哪里呢？<br>
定义一个新的数组，sums[i] ，代表从 0 到 i 的累积和，这样就得到了一个有序数组。<br>
这样做有个好处，那就是通过 sums 数组，如果要求 i 到 j 的所有子数组的和的话，就等于 sums[j] - sums[i - 1]。也就是前 j 个数字的和减去前 i - 1 个数字的和。<br>
然后求解这道题的话，算法和解法一的暴力破解还是一样的，也就是<br>
求出从第 0 个数字开始，总和大于等于 s 时的长度。<br>
求出从第 1 个数字开始，总和大于等于 s 时的长度。<br>
求出从第 2 个数字开始，总和大于等于 s 时的长度。<br>
...<br>
不同之处在于这里求总和时候，可以利用 sums 数组，不再需要累加了。<br>
比如求从第 i 个数字开始，总和大于等于 s 时的长度，我们只需要找从第 i + 1 个数字到第几个数字的和大于等于 s - nums[i] 即可。求 i + 1 到 j 的所有数字的和的话，前边已经说明过了，也就是 sums[j] - sums[i]。</p>
</blockquote>
<pre><code>public int minSubArrayLen(int s, int[] nums) {
    int n = nums.length;
    if (n == 0) {
        return 0;
    }
    int[] sums = new int[n];
    sums[0] = nums[0];
    for (int i = 1; i &lt; n; i++) {
        sums[i] = nums[i] + sums[i - 1];
    }
    int min = Integer.MAX_VALUE;
    for (int i = 0; i &lt; n; i++) {
        int s2 = s - nums[i]; //除去当前数字
        for (int j = i; j &lt; n; j++) {
            //i + 1 到  j 的所有数字和
            if (sums[j] - sums[i] &gt;= s2) {
                min = Math.min(min, j - i + 1);
            }
        }
    }
    return min == Integer.MAX_VALUE ? 0 : min;
}
</code></pre>
<blockquote>
<p>至于二分查找，我们只需要修改内层的 for 循环。对于 sums[j] - sums[i] &gt;= s2，通过移项，也就是 sums[j] &gt;= s2 + sums[i] ，含义就是寻找一个 sums[j]，使得其刚好大于等于 s2 + sums[i]。因为 sums 是个有序数组，所有找 sum[j] 可以采取二分的方法。</p>
</blockquote>
<pre><code>public int minSubArrayLen(int s, int[] nums) {
    int n = nums.length;
    if (n == 0) {
        return 0;
    }
    int[] sums = new int[n];
    sums[0] = nums[0];
    for (int i = 1; i &lt; n; i++) {
        sums[i] = nums[i] + sums[i - 1];
    }
    int min = Integer.MAX_VALUE;
    for (int i = 0; i &lt; n; i++) {
        int s2 = s - nums[i];
        //二分查找，目标值是 s2 + sums[i]
        int k = binarySearch(i, n - 1, sums, s2 + sums[i]);
        if (k != -1) {
            min = Math.min(min, k - i + 1);
        }

    }
    return min == Integer.MAX_VALUE ? 0 : min;
}

//寻求刚好大于 target 的 sums 的下标，也就是大于等于 target 所有 sums 中最小的那个
private int binarySearch(int start, int end, int[] sums, int target) {
    int mid = -1;
    while (start &lt;= end) {
        mid = (start + end) &gt;&gt;&gt; 1;
        if (sums[mid] == target) {
            return mid;
        } else if (sums[mid] &lt; target) {
            start = mid + 1;
        } else {
            end = mid - 1;
        }
    }
    //是否找到，没有找到返回 -1
    return sums[mid] &gt; target ? mid : -1;
}
</code></pre>
<blockquote>
<p>时间复杂度：O(nlog(n))。</p>
</blockquote>
<blockquote>
<p>解法四 二分查找<br>
题目中，我们要寻找连续的数字和大于等于 s 的最小长度。那么，我们可以对这个长度采取二分的方法去寻找吗？<br>
答案是肯定的，原因就是长度为 1 的所有连续数字中最大的和、长度为 2 的所有连续数字中最大的和、长度为 3 的所有连续数字中最大的和 ... 长度为 n 的所有连续数字中最大的和，同样是一个升序数组。<br>
算法的话就是对长度进行二分，寻求满足条件的最小长度。<br>
对于长度为 n 的数组，我们先去判断长度为 n/2 的连续数字中最大的和是否大于等于 s。<br>
1.如果大于等于 s ，那么我们需要减少长度，继续判断所有长度为 n/4 的连续数字<br>
2.如果小于 s，我们需要增加长度，我们继续判断所有长度为 (n/2 + n) / 2，也就是 3n/4 的连续数字。<br>
可以再结合下边的代码看一下。</p>
</blockquote>
<pre><code>public int minSubArrayLen(int s, int[] nums) {
    int n = nums.length;
    if (n == 0) {
        return 0;
    }
    int minLen = 0, maxLen = n;
    int midLen;
    int min = -1;
    while (minLen &lt;= maxLen) {
        //取中间的长度
        midLen = (minLen + maxLen) &gt;&gt;&gt; 1;
        //判断当前长度的最大和是否大于等于 s
        if (getMaxSum(midLen, nums) &gt;= s) {
            maxLen = midLen - 1; //减小长度
            min = midLen; //更新最小值
        } else {
            minLen = midLen + 1; //增大长度
        }
    }
    return min == -1 ? 0 : min;
}

private int getMaxSum(int len, int[] nums) {
    int n = nums.length;
    int sum = 0;
    int maxSum = 0;
    // 达到长度
    for (int i = 0; i &lt; len; i++) {
        sum += nums[i];
    }
    maxSum = sum; // 初始化 maxSum

    for (int i = len; i &lt; n; i++) {
        // 加一个数字减一个数字，保持长度不变
        sum += nums[i];
        sum = sum - nums[i - len];
        // 更新 maxSum
        maxSum = Math.max(maxSum, sum);
    }
    return maxSum;
}
</code></pre>
<blockquote>
<p>时间复杂度：O(nlog(n))。</p>
</blockquote>
<p>两种二分法的思路都特别有趣，前一种是利用sums数组来进行二分，逐个数组查找符合s的长度，其中寻找长度就是利用二分法。后一种是对长度入手，对每个长度进行二分，看看能否符合大于等于s的条件</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 152. 乘积最大子数组[中等][未做出]]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-152-cheng-ji-zui-da-zi-shu-zu-zhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-152-cheng-ji-zui-da-zi-shu-zu-zhong-deng-wei-zuo-chu">
        </link>
        <updated>2020-05-03T13:46:04.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字）。<br>
示例 1:<br>
输入: [2,3,-2,4]<br>
输出: 6<br>
解释: 子数组 [2,3] 有最大乘积 6。<br>
示例 2:<br>
输入: [-2,0,-1]<br>
输出: 0<br>
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/maximum-product-subarray<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>一开始觉得应该使用动态规划<br>
然后就是两个选择，继续当前数字，或者从当前数字重新开始<br>
但是问题就出在状态转移方程，不是很明白选择当前数字的话应该从前一个的哪个状态进行转移，比如当前如果是负数的话，明显前一个是负数的状态更好</p>
<p>第二个想法就是首先遍历得到负数的数量，但是相应地需要处理当前剩余的负数数量和遇到0时的处理方法</p>
<p>最后还是看了题解，主要是依靠维持max值和min值，后者就是专门用来应付负值的</p>
<p>实现需要注意的问题</p>
<ol>
<li>max和min初始化都为1，这点很重要，ans初始化为INT_MIN</li>
<li>遇到负值的时候需要交换max和min</li>
<li>然后注意因为会遇到0或者示例2的情况，所以需要对max和min进行一个判断，避免0影响后面的结果</li>
<li>一直更新ans</li>
</ol>
<pre><code>class Solution {
public:
    int maxProduct(vector&lt;int&gt;&amp; nums) {
        int length = nums.size();
        if(length == 0)
        {   return 0; }
        
        int max = 1;
        int min = 1;
        int ans = INT_MIN;
        for(int i = 0; i &lt; length; ++i)
        {
            if(nums[i] &lt; 0)
            {
                swap(max, min);
            }
            max = max*nums[i] &gt; nums[i] ? max*nums[i] : nums[i];
            min = min*nums[i] &lt; nums[i] ? min*nums[i] : nums[i];
            ans = ans &gt; max ? ans : max; 
        }
        return ans;
    }
};
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>解题方案<br>
思路<br>
标签：动态规划<br>
遍历数组时计算当前最大值，不断更新<br>
令imax为当前最大值，则当前最大值为 imax = max(imax * nums[i], nums[i])<br>
由于存在负数，那么会导致最大的变最小的，最小的变最大的。因此还需要维护当前最小值imin，imin = min(imin * nums[i], nums[i])<br>
当负数出现时则imax与imin进行交换再进行下一步计算<br>
时间复杂度：O(n)<br>
代码</p>
</blockquote>
<pre><code>class Solution {
    public int maxProduct(int[] nums) {
        int max = Integer.MIN_VALUE, imax = 1, imin = 1;
        for(int i=0; i&lt;nums.length; i++){
            if(nums[i] &lt; 0){ 
              int tmp = imax;
              imax = imin;
              imin = tmp;
            }
            imax = Math.max(imax*nums[i], nums[i]);
            imin = Math.min(imin*nums[i], nums[i]);
            
            max = Math.max(max, imax);
        }
        return max;
    }
}
</code></pre>
<p>然后这个的本质其实是动态规划，只是简化了许多<br>
如果以正规的动态规划来考虑的话应该如下：</p>
<blockquote>
<p>解题思路<br>
这题是求数组中子区间的最大乘积，对于乘法，我们需要注意，负数乘以负数，会变成正数，所以解这题的时候我们需要维护两个变量，当前的最大值，以及最小值，最小值可能为负数，但没准下一步乘以一个负数，当前的最大值就变成最小值，而最小值则变成最大值了。<br>
我们的动态方程可能这样：<br>
maxDP[i + 1] = max(maxDP[i] * A[i + 1], A[i + 1],minDP[i] * A[i + 1])<br>
minDP[i + 1] = min(minDP[i] * A[i + 1], A[i + 1],maxDP[i] * A[i + 1])<br>
dp[i + 1] = max(dp[i], maxDP[i + 1])<br>
这里，我们还需要注意元素为0的情况，如果A[i]为0，那么maxDP和minDP都为0，<br>
我们需要从A[i + 1]重新开始。</p>
</blockquote>
<pre><code>class Solution {
public:
    int maxProduct(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        if(n == 0){
            return 0;
        } else if(n == 1) {
            return nums[0];
        }
        int p = nums[0];
        int maxP = nums[0];
        int minP = nums[0];
        for(int i = 1; i &lt; n; i++) {
            int t = maxP;
            maxP = max(max(maxP * nums[i], nums[i]), minP *nums[i]);
            minP = min(min(t * nums[i], nums[i]), minP * nums[i]);
            p = max(maxP, p);
        }
        return p;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[文件系统的实现与磁盘]]></title>
        <id>https://lixin-scut.github.io//post/wen-jian-xi-tong-de-shi-xian-yu-ci-pan</id>
        <link href="https://lixin-scut.github.io//post/wen-jian-xi-tong-de-shi-xian-yu-ci-pan">
        </link>
        <updated>2020-05-02T10:47:40.000Z</updated>
        <content type="html"><![CDATA[<h3 id="文件系统的实现">文件系统的实现</h3>
<p>磁盘的0号扇区：主引导记录（MBR），MBR结尾是分区表。<br>
引导时，BIOS读入并执行MBR，确定活动分区，读取活动分区的第一个块，称引导块，引导块，装载操作系统；</p>
<p>实现<br>
1.连续分配：实现简单、读操作性能好；产生磁盘碎片<br>
2.链表分配：每个块的第一个字指向下一块的指针；随机读取速度慢；<br>
3.内存采用表的链表分配：FAT（文件分配表），每个磁盘的指针字放在内存里，加速随机存储；<br>
4.i节点：对应文件打开时，i节点才存储到内存中；占用内存空间小；</p>
<p>目录实现：文件属性存放在i节点（UNIX），存放在目录里（Windows）</p>
<p>日子结构文件系统LFS：i节点分散存储到整个磁盘中，需要维护；写操作缓冲到内存中，每隔一段时间放到一个独立的段，写到日志末尾；</p>
<p>日志文件系统：ＮＴＦＳ和ext：保持记录文件系统下一步要做什么；</p>
<h3 id="文件系统优化">文件系统优化</h3>
<p><strong>块大小</strong><br>
大块：空间利用率低；<br>
小块：多次寻道和旋转，速度慢；</p>
<h3 id="磁盘结构及管理">磁盘结构及管理</h3>
<p><strong>磁盘结构</strong></p>
<ol>
<li>盘面（Platter）：一个磁盘有多个盘面；</li>
<li>磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；</li>
<li>扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；</li>
<li>磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；</li>
<li>制动手臂（Actuator arm）：用于在磁道之间移动磁头；</li>
<li>主轴（Spindle）：使整个盘面转动。</li>
</ol>
<h3 id="磁盘调度算法">磁盘调度算法</h3>
<p>读写一个磁盘块的时间的影响因素有：</p>
<ol>
<li>
<p>旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）</p>
</li>
<li>
<p>寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）</p>
</li>
<li>
<p>实际的数据传输时间<br>
其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p>
</li>
<li>
<p><strong>先来先服务</strong><br>
FCFS, First Come First Served<br>
按照磁盘请求的顺序进行调度。<br>
优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</p>
</li>
<li>
<p><strong>最短寻道时间优先</strong><br>
SSTF, Shortest Seek Time First<br>
优先调度与当前磁头所在磁道距离最近的磁道。<br>
虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。</p>
</li>
<li>
<p><strong>电梯算法</strong><br>
SCAN<br>
电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。<br>
电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。<br>
因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。</p>
</li>
</ol>
<h3 id="io">I/O</h3>
<p>内存映射、DMA、中断</p>
<p><strong>标准io和文件io的区别</strong></p>
<p>1.定义<br>
　　标准 I/O：具有一定的可移植性。标准I/O库处理很多细节。例如缓存分配，以优化长度执行I/O等。标准的I/O提供了三种类型的缓存。<br>
（1）全缓存：当填满标准I/O缓存后才进行实际的I/O操作。<br>
（2）行缓存：当输入或输出中遇到新行符时，标准I/O库执行I/O操作。<br>
（3）不带缓存：stderr就是了。<br>
　　文件I/O：文件I/O称之为不带缓存的I/O（unbuffered I/O)。不带缓存指的是每个read，write都调用内核中的一个系统调用。也就是一般所说的低级I/O——操作系统提供的基本IO服务，与os绑定，特定于Unix平台。</p>
<p>2.区别<br>
　　首先：两者一个显著的不同点在于，标准I/O默认采用了缓冲机制，比如调用fopen函数，不仅打开一个文件，而且建立了一个缓冲区（读写模式下将建立两个缓冲区），还创建了一个包含文件和缓冲区相关数据的数据结构(FILE *)。低级I/O一般没有采用缓冲，需要自己创建缓冲区，不过其实在linux系统中，都是有使用称为内核缓冲的技术用于提高效率，读写调用是在内核缓冲区和进程缓冲区之间进行的数据复制。使用标准IO就不需要自己维护缓冲区了，标准IO库会根据stdin/stdout来选择缓冲类型，也就是说当你使用标准IO的时候，要清楚它的stdin/stdou是什么类型以及其默认的缓冲模式，如果不合适，你需要用setvbuf先设置，再使用，例如协同进程的标准输入和输出的类型都是管道，所以其默认的缓冲类型是全缓冲的，如果要使用标准IO，就需要现设置行缓冲。对于文件IO，只要你自己能维护好缓冲区，完全可以不用标准IO。<br>
　　其次从名字上来区分，文件I/O主要针对文件操作，读写硬盘等，标准I/O，主要是打印输出到屏幕等。因为他们设备不一样，文件io针对的是文件，标准io是对控制台，操作的是字符流。对于不同设备得特性不一样，必须有不同api访问才最高效。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[new与delete]]></title>
        <id>https://lixin-scut.github.io//post/new-yu-delete</id>
        <link href="https://lixin-scut.github.io//post/new-yu-delete">
        </link>
        <updated>2020-05-02T10:22:13.000Z</updated>
        <content type="html"><![CDATA[<h3 id="c中的运算符new和delete">C++中的运算符new和delete</h3>
<p>  new和delete是C++中的运算符，不是库函数，不需要库的支持，同时，他们是封装好的重载运算符，并且可以再次进行重载。<br>
（1）new是动态分配内存的运算符，自动计算需要分配的空间，在C++中，它属于重载运算符，可以对多种数据类型形式进行分配内存空间，比如int型、char型、结构体型和类等的动态申请的内存分配，分配类的内存空间时，同时调用类的构造函数，对内存空间进行初始化，即完成类的初始化工作。<br>
（2）delete是撤销动态申请的内存运算符。delete与new通常配对使用，与new的功能相反，可以对多种数据类型形式的内存进行撤销，包括类，撤销类的内存空间时，它要调用其析构函数，完成相应的清理工作，收回相应的内存资源。<br>
（3）典型用法</p>
<pre><code>int *p = new int；                         
delete p；  
</code></pre>
<pre><code>char *p = new char；                    
delete p；  
</code></pre>
<pre><code>// 类的类型 *p = new 类的类型；   
delete p；  
</code></pre>
<p>注意，指针p存于栈中，p所指向的内存空间却是在堆中。</p>
<pre><code>Obj * p = new Obj[100];                
delete [ ]p;  
</code></pre>
<p>  注意，new申请数组，delete删除的形式需要加括号“[ ]”，表示对数组空间的操作，总之，申请形式如何，释放的形式就如何</p>
<p>（4）内存说明。new申请的内存也是存于堆中，所以在不需要使用时，需要delete手动收回。</p>
<h3 id="newdelete与mallocfree之间的联系和区别">new/delete与malloc/free之间的联系和区别</h3>
<p><strong>(1) malloc/free和new/delete的联系</strong><br>
  a）存储方式相同。malloc和new动态申请的内存都位于堆中。申请的内存都不能自动被操作系统收回，都需要配套的free和delete来释放。</p>
<p>  b）除了带有构造函数和析构函数的类等数据类型以外，对于一般数据类型，如int、char等等，两组动态申请的方式可以通用，作用效果一样，只是形式不一样。</p>
<p>  c）内存泄漏对于malloc或者new都可以检查出来的，区别在于new可以指明是那个文件的那一行，而malloc没有这些信息。</p>
<p>  d）两组都需要配对使用，malloc配free，new配delete，注意，这不仅仅是习惯问题，如果不配对使用，容易造成内存泄露。同时，在C++中，两组之间不能混着用，虽说有时能编译过，但容易存在较大的隐患。</p>
<p><strong>(2) malloc/free和new/delete的区别</strong><br>
  a）malloc和free返回void类型指针，new和delete直接带具体类型的指针。</p>
<p>  b）malloc和free属于C语言中的函数，需要库的支持，而new/delete是C++中的运算符，况且可以重载，所以new/delete的执行效率高些。C++中为了兼用C语法，所以保留malloc和free的使用，但建议尽量使用new和delete。</p>
<p>  c）在C++中， new是类型安全的，而malloc不是。例如：</p>
<pre><code>int* p = new char[10];                  // 编译时指出错误  
delete [ ]p;                            //对数组需要加中括号“[ ]”  
int* p = malloc(sizeof(char )*10);      // 编译时无法指出错误  
free (p);                               //只需要所释放内存的头指针  
</code></pre>
<p>  d）使用new动态申请类对象的内存空间时，类对象的构建要调用构造函数，相当于对内存空间进行了初始化。而malloc动态申请的类对象的内存空间时，不会初始化，也就是说申请的内存空间无法使用，因为类的初始化是由构造函数完成的。delete和free的意义分别于new和malloc相反。</p>
<p>  e）不能用malloc和free来完成类对象的动态创建和删除。</p>
<h3 id="delete-this-合法吗">delete this 合法吗？</h3>
<p>合法，但：</p>
<ol>
<li>必须保证 <strong>this 对象是通过 new</strong>（不是 new[]、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的</li>
<li>必须保证调用 delete this 的成员函数是最后一个调用 this 的成员函数</li>
<li>必须保证成员函数的 delete this 后面没有调用 this 了</li>
<li>必须保证 delete this 后没有人使用了</li>
</ol>
<h3 id="三种new用法">三种new用法</h3>
<ol>
<li>plain new顾名思义就是普通的new，就是我们惯常使用的new。new失败后抛出标准异常std::bad_alloc而非返回NULL。<br>
string* ps = new string(&quot;abc&quot;);<br>
new handler，没有空间时的处理</li>
</ol>
<pre><code>// function to call if operator new can't allocate enough memory  
void outOfMem()  
{  
    //free memory  
    //or abort  
}  
int main()  
{  
    std::set_new_handler(outOfMem);  
    int *pBigDataArray = new int[100000000L];  
}  
  
void * operator new(std::size_t size) throw(std::bad_alloc)  
{                                        
    while (true) {  
        attempt to allocate size bytes;  
        if (the allocation was successful)  
        return (a pointer to the memory);  
    
        // allocation was unsuccessful; find out what the  
        // current new-handling function is  
        new_handler globalHandler = set_new_handler(0);  
        set_new_handler(globalHandler);  
        if (globalHandler) (*globalHandler)();  
        else throw std::bad_alloc();  
    }  
}  
</code></pre>
<ol start="2">
<li>nothrow new是不抛出异常的运算符new的形式。nothrow new在失败时，返回NULL。</li>
</ol>
<pre><code>char *p=new(nothrow) char[size];
</code></pre>
<ol start="3">
<li>placement new/delete 主要用途是：反复使用一块较大的动态分配成功的内存来构造不同类型的对象或者它们的数组。例如可以先申请一个足够大的字符数组，然后当需要时在它上面构造不同类型的对象或数组。placement new不用担心内存分配失败，因为它根本不分配内存，它只是调用对象的构造函数。</li>
</ol>
<pre><code>int main()  
{  
char *p=new(nothrow) char[sizeof(ADT)+2];  
if(p==NULL)  
  cout&lt;&lt;&quot;failure&quot;&lt;&lt;endl;  
  
ADT *q=new(p) ADT;  //placement new:不必担心失败  
// delete q;//错误!不能在此处调用delete q;  
q-&gt;ADT::~ADT();//显示调用析构函数  
delete []p;  
    return 0;  
}  
</code></pre>
<h3 id="如何定义一个只能在堆上栈上生成对象的类">如何定义一个只能在堆上（栈上）生成对象的类？</h3>
<ol>
<li>只能在堆上<br>
方法：将<strong>析构函数设置为私有</strong></li>
</ol>
<p>  原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。</p>
<pre><code>class  A    
{    
public :    
    A(){}    
    void  destory(){ delete   this ;}    
private :    
    ~A(){}    
};    

class  A    
{    
protected :    
    A(){}    
    ~A(){}    
public :    
    static  A* create()    
    {    
        return   new  A();    
    }    
    void  destory()    
    {    
        delete   this ;    
    }    
};   
</code></pre>
<ol start="2">
<li>只能在栈上</li>
</ol>
<p>方法：将<strong>new 和 delete 重载为私有</strong></p>
<p>  原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。</p>
<pre><code>class  A    
{    
private :    
    void * operator  new ( size_t  t){}      // 注意函数的第一个参数和返回值都是固定的     
    void  operator  delete ( void * ptr){}  // 重载了new就需要重载delete     
public :    
    A(){}    
    ~A(){}    
};   
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL 177. 第N高的薪水[中等]]]></title>
        <id>https://lixin-scut.github.io//post/mysql-177-di-n-gao-de-xin-shui-zhong-deng</id>
        <link href="https://lixin-scut.github.io//post/mysql-177-di-n-gao-de-xin-shui-zhong-deng">
        </link>
        <updated>2020-05-02T04:51:43.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>编写一个 SQL 查询，获取 Employee 表中第 n 高的薪水（Salary）。<br>
+----+--------+<br>
| Id | Salary |<br>
+----+--------+<br>
| 1  | 100    |<br>
| 2  | 200    |<br>
| 3  | 300    |<br>
+----+--------+<br>
例如上述 Employee 表，n = 2 时，应返回第二高的薪水 200。如果不存在第 n 高的薪水，那么查询应返回 null。<br>
+------------------------+<br>
| getNthHighestSalary(2) |<br>
+------------------------+<br>
| 200                    |<br>
+------------------------+<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/nth-highest-salary<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这一题和上一题绝大部分都相同，主要用于复习<br>
新的点在于</p>
<ol>
<li>SET设置变量，不能使用 LIMIT N-1，N-1是非法的</li>
<li>a OFFSET b和 b，a 刚好相反，注意区分</li>
</ol>
<pre><code>CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
SET n = N-1;
  RETURN (
      # Write your MySQL query statement below.
      SELECT (
          SELECT DISTINCT Salary
          FROM Employee
          ORDER BY Salary DESC
          LIMIT 1 OFFSET n
      )
  );
END
</code></pre>
<p>网友题解<br>
第一个方案，基于前面一道题，只要调整下limit的起始点即可，但是此方法不是很符合题意，因为给的不是一句sql，而是1个变量定义+1个sql</p>
<pre><code>CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
  SET n = N-1;
  RETURN (     
  SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT n,1
  );
END
</code></pre>
<p>第二个方案，按符合题意的思路来，只用一个sql，那么要先查出前N薪水，然后取最小就好了，注意可能总数不够前N，count一下比较即可</p>
<pre><code>CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
  RETURN (     
  SELECT  IF(count&lt;N,NULL,min) 
  FROM
    (SELECT MIN(Salary) AS min, COUNT(1) AS count
    FROM
      (SELECT DISTINCT Salary
      FROM Employee ORDER BY Salary DESC LIMIT N) AS a
    ) as b
  );
END
</code></pre>
<p>相关知识点：<br>
《MySQL必知必会》<br>
SET：<br>
SET命令用来将新值赋给被更新的列。</p>
<p>MIN：<br>
MIN()的功能与MAX()功能相反，它返回指定列的最小值。与MAX()一样，MIN()要求指定列名<br>
对非数值数据使用MIN() MIN()函数与MAX()函数类似， MySQL允许将它用来返回任意列中的最小值，包括返回文本 列中的最小值。在用于文本数据时，如果数据按相应的列排序，则MIN()返回最前面的行。<br>
NULL值 MIN()函数忽略列值为NULL的行。</p>
<p>COUNT()：<br>
COUNT()函数进行计数。可利用COUNT()确定表中行的数目或符合特定条件的行的数目。 COUNT()函数有两种使用方式。<br>
使用COUNT(*)对表中行的数目进行计数，不管表列中包含的是空值(NULL)还是非空值。<br>
使用COUNT(column)对特定列中具有值的行进行计数，忽略 NULL值。<br>
如果指定列名，则指定列的值为空的行被COUNT() 函数忽略，但如果COUNT()函数中用的是星号(*)，则不忽略。</p>
<p>IF语句<br>
如果条件为真，返回前者，否则返回后者</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 85. 最大矩形[困难][未做出]]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-85-zui-da-ju-xing-kun-nan-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-85-zui-da-ju-xing-kun-nan-wei-zuo-chu">
        </link>
        <updated>2020-05-02T03:31:41.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。<br>
示例:<br>
输入:<br>
[<br>
[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],<br>
[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],<br>
[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],<br>
[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]<br>
]<br>
输出: 6<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/maximal-rectangle<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>本来想利用 最大正方形的方法，但是此处行不通。。。<br>
比如 {{0, 0}, {1, 1}},答案明显是2，但是因为取三者最小，反而导致右下角输出还是1<br>
看了题解才发现，<br>
这道题以<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a>为基础，将每一行视为一个柱状图</p>
<p>看了题解发现需要依靠：数组 84. 柱状图中最大的矩形 作为解题基础<br>
实现中需要注意的地方：</p>
<ol>
<li>注意可能出现当前位置的数字为0，但是前面是1，此时需要将柱状图归为0</li>
<li>不知道为啥题目给的元素是char。。。而不是int，所以判断条件也需要相应地修改</li>
<li>然后ans更新的位置很重要</li>
</ol>
<pre><code>class Solution {
public:
    int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix)     
    {
        if(matrix.empty())
        {   return 0; }
        
        int row = matrix.size();
        int col = matrix[0].size();
        
        vector&lt;int&gt; heights(col, 0);
        int ans = 0;
        for(int i = 0; i &lt; row; ++i)
        {
            for(int j = 0; j &lt; col; ++j)
            {
                if(matrix[i][j] == '1')
                {
                    heights[j] += 1;
                }
                else
                {
                    heights[j] = 0;
                }
            }
            ans = max(ans, largestRectangleArea(heights));
        }
        return ans;
    }
    
    int largestRectangleArea(vector&lt;int&gt;&amp; heights)
    {
        stack&lt;int&gt; hstack;
        hstack.push(-1);
        int index = 0;
        int ans = 0;
        for(int i = 0; i &lt; heights.size(); ++i)
        { 
            while(hstack.top() != -1 &amp;&amp; heights[hstack.top()] &gt;= heights[i])
            {
                index = hstack.top();
                hstack.pop();
                ans = max(ans, heights[index] * (i - hstack.top() - 1));
            }
            hstack.push(i);
        }
        
        while(hstack.top() != -1)
        {
            index= hstack.top();
            hstack.pop();
            int temp = heights[index] * (heights.size() - hstack.top() - 1);
            ans = max(ans, temp);
        }
        return ans;
    }
};
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>解法一 暴力破解<br>
遍历每个点，求以这个点为矩阵右下角的所有矩阵面积。<br>
怎么找出这样的矩阵呢？如果我们知道了以这个点结尾的连续 1 的个数的话，问题就变得简单了。<br>
1.首先求出高度是 1 的矩形面积，也就是它自身的数，如图中橙色的 4，面积就是 4。<br>
2.然后向上扩展一行，高度增加一，选出当前列最小的数字，作为矩阵的宽，求出面积，对应上图的矩形框。<br>
3.然后继续向上扩展，重复步骤 2。<br>
按照上边的方法，遍历所有的点，求出所有的矩阵就可以了。</p>
</blockquote>
<pre><code>public int maximalRectangle(char[][] matrix) {
    if (matrix.length == 0) {
        return 0;
    }
    //保存以当前数字结尾的连续 1 的个数
    int[][] width = new int[matrix.length][matrix[0].length];
    int maxArea = 0;
    //遍历每一行
    for (int row = 0; row &lt; matrix.length; row++) {
        for (int col = 0; col &lt; matrix[0].length; col++) {
            //更新 width
            if (matrix[row][col] == '1') {
                if (col == 0) {
                    width[row][col] = 1;
                } else {
                    width[row][col] = width[row][col - 1] + 1;
                }
            } else {
                width[row][col] = 0;
            }
            //记录所有行中最小的数
            int minWidth = width[row][col];
            //向上扩展行
            for (int up_row = row; up_row &gt;= 0; up_row--) {
                int height = row - up_row + 1;
                //找最小的数作为矩阵的宽
                minWidth = Math.min(minWidth, width[up_row][col]);
                //更新面积
                maxArea = Math.max(maxArea, height * minWidth);
            }
        }
    }
    return maxArea;
}
</code></pre>
<blockquote>
<p>时间复杂度：O（m²n）。<br>
空间复杂度：O（mn）。</p>
</blockquote>
<blockquote>
<p>解法二<br>
利用84题的思想<br>
一个是最低柱子二分法</p>
</blockquote>
<pre><code>public int maximalRectangle(char[][] matrix) {
    if (matrix.length == 0) {
        return 0;
    }
    int[] heights = new int[matrix[0].length];
    int maxArea = 0;
    for (int row = 0; row &lt; matrix.length; row++) {
        //遍历每一列，更新高度
        for (int col = 0; col &lt; matrix[0].length; col++) {
            if (matrix[row][col] == '1') {
                heights[col] += 1;
            } else {
                heights[col] = 0;
            }
        }
        //调用上一题的解法，更新函数
        maxArea = Math.max(maxArea, largestRectangleArea(heights));
    }
    return maxArea;
}

public int largestRectangleArea(int[] heights) {
    int maxArea = 0;
    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
    int p = 0;
    while (p &lt; heights.length) {
        //栈空入栈
        if (stack.isEmpty()) {
            stack.push(p);
            p++;
        } else {
            int top = stack.peek();
            //当前高度大于栈顶，入栈
            if (heights[p] &gt;= heights[top]) {
                stack.push(p);
                p++;
            } else {
                //保存栈顶高度
                int height = heights[stack.pop()];
                //左边第一个小于当前柱子的下标
                int leftLessMin = stack.isEmpty() ? -1 : stack.peek();
                //右边第一个小于当前柱子的下标
                int RightLessMin = p;
                //计算面积
                int area = (RightLessMin - leftLessMin - 1) * height;
                maxArea = Math.max(area, maxArea);
            }
        }
    }
    while (!stack.isEmpty()) {
        //保存栈顶高度
        int height = heights[stack.pop()];
        //左边第一个小于当前柱子的下标
        int leftLessMin = stack.isEmpty() ? -1 : stack.peek();
        //右边没有小于当前高度的柱子，所以赋值为数组的长度便于计算
        int RightLessMin = heights.length;
        int area = (RightLessMin - leftLessMin - 1) * height;
        maxArea = Math.max(area, maxArea);
    }
    return maxArea;
}
</code></pre>
<blockquote>
<p>时间复杂度：O（mn）。<br>
空间复杂度：O（n）。</p>
</blockquote>
<blockquote>
<p>另外一个是直接用栈</p>
</blockquote>
<pre><code>public int maximalRectangle(char[][] matrix) {
    if (matrix.length == 0) {
        return 0;
    }
    int[] heights = new int[matrix[0].length];
    int maxArea = 0;
    for (int row = 0; row &lt; matrix.length; row++) {
        //遍历每一列，更新高度
        for (int col = 0; col &lt; matrix[0].length; col++) {
            if (matrix[row][col] == '1') {
                heights[col] += 1;
            } else {
                heights[col] = 0;
            }
        }
        //调用上一题的解法，更新函数
        maxArea = Math.max(maxArea, largestRectangleArea(heights));
    }
    return maxArea;
}

public int largestRectangleArea(int[] heights) {
    if (heights.length == 0) {
        return 0;
    }
    int[] leftLessMin = new int[heights.length];
    leftLessMin[0] = -1;
    for (int i = 1; i &lt; heights.length; i++) {
        int l = i - 1;
        while (l &gt;= 0 &amp;&amp; heights[l] &gt;= heights[i]) {
            l = leftLessMin[l];
        }
        leftLessMin[i] = l;
    }

    int[] rightLessMin = new int[heights.length];
    rightLessMin[heights.length - 1] = heights.length;
    for (int i = heights.length - 2; i &gt;= 0; i--) {
        int r = i + 1;
        while (r &lt;= heights.length - 1 &amp;&amp; heights[r] &gt;= heights[i]) {
            r = rightLessMin[r];
        }
        rightLessMin[i] = r;
    }
    int maxArea = 0;
    for (int i = 0; i &lt; heights.length; i++) {
        int area = (rightLessMin[i] - leftLessMin[i] - 1) * heights[i];
        maxArea = Math.max(area, maxArea);
    }
    return maxArea;
}
</code></pre>
<blockquote>
<p>时间复杂度：O（mn）。<br>
空间复杂度：O（n）。</p>
</blockquote>
<p>解法三</p>
<blockquote>
<p>解法二中套用的栈的解法，我们其实可以不用调用函数，而是把栈糅合到原来求 heights 中。因为栈的话并不是一次性需要所有的高度，所以可以求出一个高度，然后就操作栈。</p>
</blockquote>
<pre><code>public int maximalRectangle(char[][] matrix) {
    if (matrix.length == 0) {
        return 0;
    }
    int[] heights = new int[matrix[0].length + 1]; //小技巧后边讲
    int maxArea = 0;
    for (int row = 0; row &lt; matrix.length; row++) {
        Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();
        heights[matrix[0].length] = 0;
        //每求一个高度就进行栈的操作
        for (int col = 0; col &lt;= matrix[0].length; col++) {
            if (col &lt; matrix[0].length) { //多申请了 1 个元素，所以要判断
                if (matrix[row][col] == '1') {
                    heights[col] += 1;
                } else {
                    heights[col] = 0;
                }
            }
            if (stack.isEmpty() || heights[col] &gt;= heights[stack.peek()]) {
                stack.push(col);
            } else {
                //每次要判断新的栈顶是否高于当前元素
                while (!stack.isEmpty() &amp;&amp; heights[col] &lt; heights[stack.peek()]) {
                    int height = heights[stack.pop()];
                    int leftLessMin = stack.isEmpty() ? -1 : stack.peek();
                    int RightLessMin = col;
                    int area = (RightLessMin - leftLessMin - 1) * height;
                    maxArea = Math.max(area, maxArea);
                }
                stack.push(col);
            }
        }

    }
    return maxArea;
}
</code></pre>
<blockquote>
<p>时间复杂度：O（mn）。<br>
空间复杂度：O（n）。<br>
里边有一个小技巧，84 题 的栈解法中，我们用了两个 while 循环，第二个 while 循环用来解决遍历完元素栈不空的情况。其实，我们注意到两个 while 循环的逻辑完全一样的。所以我们可以通过一些操作，使得遍历结束后，依旧进第一个 while 循环，从而剩下了第 2 个 while 循环，代码看起来会更简洁。<br>
那就是 heights 多申请一个元素，赋值为 0。这样最后一次遍历的时候，栈顶肯定会大于当前元素，所以就进入了第一个 while 循环。</p>
</blockquote>
<p>解法四 动态规划</p>
<blockquote>
<p>参考<a href="https://leetcode.com/problems/maximal-rectangle/discuss/29054/Share-my-DP-solution">Share my DP solution</a>，这是 leetcode Solution 中投票最高的，但比较难理解，但如果结合 84 题去想的话就很容易了。<br>
解法二中，用了 84 题的两个解法，解法三中我们把栈糅合进了原算法，那么另一种可以一样的思路吗？不行！因为栈不要求所有的高度，可以边更新，边处理。而另一种，是利用两个数组， leftLessMin [ ] 和 rightLessMin [ ]。而这两个数组的更新，是需要所有高度的。<br>
解法二中，我们更新一次 heights，就利用之前的算法，求一遍 leftLessMin [ ] 和 rightLessMin [ ]，然后更新面积。而其实，我们求 leftLessMin [ ] 和 rightLessMin [ ] 可以利用之前的 leftLessMin [ ] 和 rightLessMin [ ] 来更新本次的。<br>
我们回想一下 leftLessMin [ ] 和 rightLessMin [ ] 的含义， leftLessMin [ i ] 代表左边第一个比当前柱子矮的下标，如下图橙色柱子时当前遍历的柱子。rightLessMin [ ] 时右边第一个。<br>
left 和 right 是对称关系，下边只考虑 left 的求法。<br>
如下图，如果当前新增的层全部是 1，当然这时最完美的情况，那么 leftLessMin [ ] 根本不需要改变。<br>
然而事实是残酷的，一定会有 0 的出现。<br>
我们考虑最后一个柱子的更新。上一层的 leftLessMin = 1，也就是蓝色 0 的位置是第一个比它低的柱子。但是在当前层，由于中间出现了 0。所以不再是之前的 leftLessMin ，而是和上次出现 0 的位置进行比较（因为 0 一定比当前柱子小），谁的下标大，更接近当前柱子，就选择谁。上图中出现 0 的位置是 2，之前的 leftLessMin 是 1，选一个较大的，那就是 2 了。</p>
</blockquote>
<pre><code>public int maximalRectangle4(char[][] matrix) {
    if (matrix.length == 0) {
        return 0;
    }
    int maxArea = 0;
    int cols = matrix[0].length;
    int[] leftLessMin = new int[cols];
    int[] rightLessMin = new int[cols];
    Arrays.fill(leftLessMin, -1); //初始化为 -1，也就是最左边
    Arrays.fill(rightLessMin, cols); //初始化为 cols，也就是最右边
    int[] heights = new int[cols];
    for (int row = 0; row &lt; matrix.length; row++) {
        //更新所有高度
        for (int col = 0; col &lt; cols; col++) {
            if (matrix[row][col] == '1') {
                heights[col] += 1;
            } else {
                heights[col] = 0;
            }
        }
		//更新所有leftLessMin
        int boundary = -1; //记录上次出现 0 的位置
        for (int col = 0; col &lt; cols; col++) {
            if (matrix[row][col] == '1') {
                //和上次出现 0 的位置比较
                leftLessMin[col] = Math.max(leftLessMin[col], boundary);
            } else {
                //当前是 0 代表当前高度是 0，所以初始化为 -1，防止对下次循环的影响
                leftLessMin[col] = -1; 
                //更新 0 的位置
                boundary = col;
            }
        }
        //右边同理
        boundary = cols;
        for (int col = cols - 1; col &gt;= 0; col--) {
            if (matrix[row][col] == '1') {
                rightLessMin[col] = Math.min(rightLessMin[col], boundary);
            } else {
                rightLessMin[col] = cols;
                boundary = col;
            }
        }
		
        //更新所有面积
        for (int col = cols - 1; col &gt;= 0; col--) {
            int area = (rightLessMin[col] - leftLessMin[col] - 1) * heights[col];
            maxArea = Math.max(area, maxArea);
        }

    }
    return maxArea;

}
</code></pre>
<blockquote>
<p>时间复杂度：O（mn）。<br>
空间复杂度：O（n）。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 84. 柱状图中最大的矩形[困难][未做出]]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-84-zhu-zhuang-tu-zhong-zui-da-de-ju-xing-kun-nan-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-84-zhu-zhuang-tu-zhong-zui-da-de-ju-xing-kun-nan-wei-zuo-chu">
        </link>
        <updated>2020-05-02T02:07:08.000Z</updated>
        <content type="html"><![CDATA[<p>题解描述：</p>
<blockquote>
<p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。<br>
求在该柱状图中，能够勾勒出来的矩形的最大面积。<br>
示例:<br>
输入: [2,1,5,6,2,3]<br>
输出: 10</p>
</blockquote>
<p>这道题是为了<a href="https://leetcode-cn.com/problems/maximal-rectangle/">85. 最大矩形</a>做铺垫的，所以我已经提前知道解法了，就直接纳入未做出里面吧。</p>
<p>实现中需要注意的点</p>
<ol>
<li>计算面积的时候，下标非常重要，一定要留意下标的位置及其意义，比如i是当前值而不是stack的值，再减去已经stack已经pop一次之后的值，所以需要额外地-1</li>
<li>提前push一个-1，方便后面的计算，不再需要额外的判断，同时需要注意注意判断条件</li>
<li>C++的栈的pop并不返回任何值，所以必须top后再pop</li>
</ol>
<pre><code>class Solution {
public:
    int largestRectangleArea(vector&lt;int&gt;&amp; heights) {
        stack&lt;int&gt; heights_stack;
        heights_stack.push(-1);
        int ans = 0;
        int index = 0;
        for(int i = 0; i &lt; heights.size(); ++i)
        {
            while(heights_stack.top() != -1 &amp;&amp; heights[heights_stack.top()] &gt;= heights[i])
            {
                index = heights_stack.top();
                heights_stack.pop();
                ans = max(ans, heights[index] * (i - heights_stack.top() - 1));
            }
            heights_stack.push(i);
        }
        
        
        while(heights_stack.top() != -1)
        {
            index = heights_stack.top();
            heights_stack.pop();
            ans = ans &gt; heights[index] * (heights.size() - heights_stack.top() - 1) ?
                ans : heights[index] * (heights.size() - heights_stack.top() - 1);
        }
        return ans;
    }
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>方法 1：暴力<br>
首先，我们可以想到，两个柱子间矩形的高由它们之间最矮的柱子决定。<br>
因此，我们可以考虑所有两两柱子之间形成的矩形面积，该矩形的高为它们之间最矮柱子的高度，宽为它们之间的距离，这样可以找到所要求的最大面积的矩形。</p>
</blockquote>
<pre><code>public class Solution {
   public int largestRectangleArea(int[] heights) {
       int maxarea = 0;
       for (int i = 0; i &lt; heights.length; i++) {
           for (int j = i; j &lt; heights.length; j++) {
               int minheight = Integer.MAX_VALUE;
               for (int k = i; k &lt;= j; k++)
                   minheight = Math.min(minheight, heights[k]);
               maxarea = Math.max(maxarea, minheight * (j - i + 1));
           }
       }
       return maxarea;
   }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n^3)。我们需要使用 O(n) 的时间找到 O(n^2) 枚举出来的所有柱子对之间的最矮柱子<br>
空间复杂度：O(1)。 只需要常数空间的额外变量</p>
</blockquote>
<p>方法 2：优化的暴力</p>
<blockquote>
<p>算法<br>
我们可以基于方法 1 进行一点点修改来优化算法。我们可以用前一对柱子之间的最低高度来求出当前柱子对间的最低高度。<br>
用数学语言来表达，height=min(minheight,heights(j)) ，其中， heights(j) 是第 j 个柱子的高度。</p>
</blockquote>
<pre><code>public class Solution {
   public int largestRectangleArea(int[] heights) {
       int maxarea = 0;
       for (int i = 0; i &lt; heights.length; i++) {
           int minheight = Integer.MAX_VALUE;
           for (int j = i; j &lt; heights.length; j++) {
               minheight = Math.min(minheight, heights[j]);
               maxarea = Math.max(maxarea, minheight * (j - i + 1));
           }
       }
       return maxarea;
   }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n^2)。 需要枚举所有可能的柱子对。<br>
空间复杂度：O(1) 。不需要额外的空间。</p>
</blockquote>
<p>方法 3：分治</p>
<blockquote>
<p>算法<br>
通过观察，可以发现，最大面积矩形存在于以下几种情况：<br>
确定了最矮柱子以后，矩形的宽尽可能往两边延伸。<br>
在最矮柱子左边的最大面积矩形（子问题）。<br>
在最矮柱子右边的最大面积矩形（子问题）。<br>
举个例子：<br>
[6, 4, 5, 2, 4, 3, 9]<br>
这里最矮柱子高度为 2 。以 2 为高的最大子矩阵面积是 2x7=14 。现在，我们考虑上面提到的第二种和第三种情况。我们对高度为 2 柱子的左边和右边采用同样的过程。在 2 的左边， 4 是最小的，形成区域为 4x3=12 。将左边区域再继续分，矩形的面积分别为 6x1=6 和 5x1=5 。同样的，我们可以求出右边区域的面积为 3x3=9, 4x1=4 和 9x1=9 。因此，我们得到最大面积是 16</p>
</blockquote>
<pre><code>public class Solution {
    public int calculateArea(int[] heights, int start, int end) {
        if (start &gt; end)
            return 0;
        int minindex = start;
        for (int i = start; i &lt;= end; i++)
            if (heights[minindex] &gt; heights[i])
                minindex = i;
        return Math.max(heights[minindex] * (end - start + 1), Math.max(calculateArea(heights, start, minindex - 1), calculateArea(heights, minindex + 1, end)));
    }
    public int largestRectangleArea(int[] heights) {
        return calculateArea(heights, 0, heights.length - 1);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：<br>
平均开销：O(nlogn)<br>
最坏情况：O(n^2)。如果数组中的数字是有序的，分治算法将没有任何优化效果。<br>
空间复杂度：O(n)。最坏情况下递归需要 O(n) 的空间。</p>
</blockquote>
<p>方法 4：优化的分治</p>
<blockquote>
<p>算法<br>
可以观察到，方法 3 中大的问题被分解成更小的子问题来求解，所以分治方法会有一定程度的优化。但是如果数组本身是升序或者降序的，将没有优化作用，原因是每次我们都需要在一个很大的 O(n) 级别的数组里找最小值。因此，最坏情况下总的时间复杂度变成了 O(n^2) 。我们可以用线段树代替遍历来找到区间最小值。单词查询复杂度就变成了O(logn) 。<br>
复杂度分析<br>
时间复杂度：O(nlogn) 。 对于长度为 n 的查询，线段树需要 logn 的时间。<br>
空间复杂度：O(n)。这是线段树的空间开销。</p>
</blockquote>
<p>方法 5：栈</p>
<blockquote>
<p>算法<br>
在这种方法中，我们维护一个栈。一开始，我们把 -1 放进栈的顶部来表示开始。初始化时，按照从左到右的顺序，我们不断将柱子的序号放进栈中，直到遇到相邻柱子呈下降关系，也就是 a[i−1]&gt;a[i] 。现在，我们开始将栈中的序号弹出，直到遇到 stack[j] 满足a[stack[j]]≤a[i] 。每次我们弹出下标时，我们用弹出元素作为高形成的最大面积矩形的宽是当前元素与 stack[top−1] 之间的那些柱子。也就是当我们弹出 stack[top] 时，记当前元素在原数组中的下标为 i ，当前弹出元素为高的最大矩形面积为：<br>
(i−stack[top−1]−1)×a[stack[top]].<br>
更进一步，当我们到达数组的尾部时，我们将栈中剩余元素全部弹出栈。在弹出每一个元素是，我们用下面的式子来求面积：<br>
(stack[top]−stack[top−1])×a[stack[top]]，<br>
其中，stack[top]表示刚刚被弹出的元素。因此，我们可以通过每次比较新计算的矩形面积来获得最大的矩形面积。<br>
下面的例子将进一步解释：<br>
[6, 7, 5, 2, 4, 5, 9, 3]</p>
</blockquote>
<pre><code>public class Solution {
    public int largestRectangleArea(int[] heights) {
        Stack &lt; Integer &gt; stack = new Stack &lt; &gt; ();
        stack.push(-1);
        int maxarea = 0;
        for (int i = 0; i &lt; heights.length; ++i) {
            while (stack.peek() != -1 &amp;&amp; heights[stack.peek()] &gt;= heights[i])
                maxarea = Math.max(maxarea, heights[stack.pop()] * (i - stack.peek() - 1));
            stack.push(i);
        }
        while (stack.peek() != -1)
            maxarea = Math.max(maxarea, heights[stack.pop()] * (heights.length - stack.peek() -1));
        return maxarea;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)。 n 个数字每个会被压栈弹栈各一次。<br>
空间复杂度： O(n)。用来存放栈中元素。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[协程]]></title>
        <id>https://lixin-scut.github.io//post/xie-cheng</id>
        <link href="https://lixin-scut.github.io//post/xie-cheng">
        </link>
        <updated>2020-05-01T12:31:00.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.liaoxuefeng.com/wiki/897692888725344/923057403198272">协程-廖雪峰</a></p>
<p>协程，又称微线程，纤程。英文名Coroutine。</p>
<p>协程的概念很早就提出来了，但直到最近几年才在某些语言（如Lua）中得到广泛应用。</p>
<p>子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。</p>
<p>所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。</p>
<p>子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。</p>
<p>协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p>
<p>注意，在一个子程序中中断，去执行其他子程序，不是函数调用，有点类似CPU的中断。比如子程序A、B：</p>
<pre><code>def A():
    print '1'
    print '2'
    print '3'

def B():
    print 'x'
    print 'y'
    print 'z'
</code></pre>
<p>假设由协程执行，在执行A的过程中，可以随时中断，去执行B，B也可能在执行过程中中断再去执行A，结果可能是：</p>
<pre><code>1
2
x
y
3
z
</code></pre>
<p>但是在A中是没有调用B的，所以协程的调用比函数调用理解起来要难一些。</p>
<p>看起来A、B的执行有点像多线程，但协程的特点在于是一个线程执行，那和多线程比，协程有何优势？</p>
<p>最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</p>
<p>第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p>
<p>因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。</p>
<p>Python对协程的支持还非常有限，用在generator中的yield可以一定程度上实现协程。虽然支持不完全，但已经可以发挥相当大的威力了。</p>
<p>来看例子：</p>
<p>传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但一不小心就可能死锁。</p>
<p>如果改用协程，生产者生产消息后，直接通过yield跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高：</p>
<pre><code>import time

def consumer():
    r = ''
    while True:
        n = yield r
        if not n:
            return
        print('[CONSUMER] Consuming %s...' % n)
        time.sleep(1)
        r = '200 OK'

def produce(c):
    c.next()
    n = 0
    while n &lt; 5:
        n = n + 1
        print('[PRODUCER] Producing %s...' % n)
        r = c.send(n)
        print('[PRODUCER] Consumer return: %s' % r)
    c.close()

if __name__=='__main__':
    c = consumer()
    produce(c)
</code></pre>
<p>执行结果：</p>
<pre><code>[PRODUCER] Producing 1...
[CONSUMER] Consuming 1...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 2...
[CONSUMER] Consuming 2...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 3...
[CONSUMER] Consuming 3...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 4...
[CONSUMER] Consuming 4...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 5...
[CONSUMER] Consuming 5...
[PRODUCER] Consumer return: 200 OK
</code></pre>
<p>注意到consumer函数是一个generator（生成器），把一个consumer传入produce后：</p>
<ol>
<li>
<p>首先调用c.next()启动生成器；</p>
</li>
<li>
<p>然后，一旦生产了东西，通过c.send(n)切换到consumer执行；</p>
</li>
<li>
<p>consumer通过yield拿到消息，处理，又通过yield把结果传回；</p>
</li>
<li>
<p>produce拿到consumer处理的结果，继续生产下一条消息；</p>
</li>
<li>
<p>produce决定不生产了，通过c.close()关闭consumer，整个过程结束。</p>
</li>
</ol>
<p>整个流程无锁，由一个线程执行，produce和consumer协作完成任务，所以称为“协程”，而非线程的抢占式多任务。</p>
<p>最后套用Donald Knuth的一句话总结协程的特点：</p>
<p>“子程序就是协程的一种特例。</p>
<p>另外一篇比较形象的：<br>
<a href="https://www.jianshu.com/p/6dde7f92951e">协程-简书</a></p>
<p><strong>什么是进程和线程？</strong></p>
<p>进程是应用程序的启动实例，进程拥有代码和打开的文件资源、数据资源、独立的内存空间。</p>
<p>线程从属于进程，是程序的实际执行者，一个进程至少包含一个主线程，也可以有更多的子线程，线程拥有自己的栈空间。<br>
<img src="https://lixin-scut.github.io//post-images/1588335767357.png" alt=""><br>
对操作系统而言，线程是最小的执行单元，进程是最小的资源管理单元。无论是进程还是线程，都是由操作系统所管理的。</p>
<p><strong>线程的状态</strong></p>
<p>线程具有五种状态：初始化、可运行、运行中、阻塞、销毁</p>
<p><strong>线程之间是如何进行协作的呢？</strong></p>
<p>最经典的例子是生产者/消费者模式，即若干个生产者线程向队列中系欸如数据，若干个消费者线程从队列中消费数据。</p>
<p><strong>生产者/消费者模式的性能问题是什么？</strong></p>
<ol>
<li>涉及到同步锁</li>
<li>涉及到线程阻塞状态和可运行状态之间的切换</li>
<li>设置到线程上下文的切换</li>
</ol>
<p><strong>什么是协程呢？</strong></p>
<p>协程（Coroutines）是一种比线程更加轻量级的存在，正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程。<br>
<img src="https://lixin-scut.github.io//post-images/1588335854198.png" alt=""><br>
协程不是被操作系统内核所管理的，而是完全由程序所控制，也就是在用户态执行。这样带来的好处是性能大幅度的提升，因为不会像线程切换那样消耗资源。</p>
<p>协程不是进程也不是线程，而是一个特殊的函数，这个函数可以在某个地方挂起，并且可以重新在挂起处外继续运行。所以说，协程与进程、线程相比并不是一个维度的概念。</p>
<p>一个进程可以包含多个线程，一个线程也可以包含多个协程。简单来说，一个线程内可以由多个这样的特殊函数在运行，但是有一点必须明确的是，一个线程的多个协程的运行是串行的。如果是多核CPU，多个进程或一个进程内的多个线程是可以并行运行的，但是一个线程内协程却绝对是串行的，无论CPU有多少个核。毕竟协程虽然是一个特殊的函数，但仍然是一个函数。一个线程内可以运行多个函数，但这些函数都是串行运行的。当一个协程运行时，其它协程必须挂起。</p>
<p><strong>进程、线程、协程的对比</strong></p>
<ol>
<li>协程既不是进程也不是线程，协程仅仅是一个特殊的函数，协程它进程和进程不是一个维度的。</li>
<li>一个进程可以包含多个线程，一个线程可以包含多个协程。</li>
<li>一个线程内的多个协程虽然可以切换，但是多个协程是串行执行的，只能在一个线程内运行，没法利用CPU多核能力。</li>
<li>协程与进程一样，切换是存在上下文切换问题的。</li>
</ol>
<p><strong>上下文切换</strong></p>
<ol>
<li>
<p>进程的切换者是操作系统，切换时机是根据操作系统自己的切换策略，用户是无感知的。进程的切换内容包括页全局目录、内核栈、硬件上下文，切换内容保存在内存中。进程切换过程是由“用户态到内核态到用户态”的方式，切换效率低。</p>
</li>
<li>
<p>线程的切换者是操作系统，切换时机是根据操作系统自己的切换策略，用户无感知。线程的切换内容包括内核栈和硬件上下文。线程切换内容保存在内核栈中。线程切换过程是由“用户态到内核态到用户态”， 切换效率中等。</p>
</li>
<li>
<p>协程的切换者是用户（编程者或应用程序），切换时机是用户自己的程序所决定的。协程的切换内容是硬件上下文，切换内存保存在用户自己的变量（用户栈或堆）中。协程的切换过程只有用户态，即没有陷入内核态，因此切换效率高。</p>
</li>
</ol>
<p>另外一篇偏向于实践的<br>
<a href="https://www.cnblogs.com/fushengliuyi/articles/12392402.html">Python协程与生成器</a></p>
<p><strong>概述：</strong></p>
<p>  协程（Coroutines）是一种比线程更加轻量级的存在，正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程。</p>
<p>  协程不是被操作系统内核所管理的，而是完全由程序所控制，也就是在用户态执行。这样带来的好处是性能大幅度的提升，因为不会像线程切换那样消耗资源。</p>
<p>  协程不是进程也不是线程，而是一个特殊的函数，这个函数可以在某个地方挂起，并且可以重新在挂起处外继续运行。所以说，协程与进程、线程相比并不是一个维度的概念。</p>
<p><strong>协程的好处：</strong></p>
<ol>
<li>无需线程上下文切换的开销</li>
<li>无需原子操作锁定及同步的开销<br>
  &quot;原子操作(atomic operation)是不需要synchronized&quot;，所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。原子操作可以是一个步骤，也可以是多个操作步骤，但是其顺序是不可以被打乱，或者切割掉只执行部分。视作整体是原子性的核心。</li>
<li>方便切换控制流，简化编程模型</li>
<li>高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。</li>
</ol>
<p><strong>缺点：</strong></p>
<p>  无法利用多核资源：协程的本质是个单线程,它不能同时将单个 CPU 的多个核用上，协程需要和进程配合才能运行在多 CPU 上.当然我们日常所编写的绝大部分应用都没有这个必要，除非是 CPU 集型应用。<br>
  进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序</p>
<p><strong>举例：</strong></p>
<p>  子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。</p>
<p>  所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。</p>
<p>  子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。</p>
<p>  协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p>
<p>  注意，在一个子程序中中断，去执行其他子程序，不是函数调用，有点类似CPU的中断。比如子程序A、B：</p>
<pre><code>def A():
    print '1'
    print '2'
    print '3'

def B():
    print 'x'
    print 'y'
    print 'z'
</code></pre>
<p>由协程执行，可能执行结果每次各不相同。</p>
<p>例如</p>
<pre><code>1
x
z
3
2
x
</code></pre>
<p><strong>yield:</strong></p>
<p>  理解协程，首先需要知道生成器是什么。生成器其实就是不断产出值的函数，只不过在函数中需要使用yield这一个关键词将值产出。下面来看一个例子：</p>
<pre><code>def gen():
    n = 0
    while True:
        yield n
        n += 1


g = gen()
print(g)  # &lt;generator object gen at 0x0000028E9CB64048&gt;
print(next(g))  # 输出结果为0
print(next(g))  # 输出结果为1
</code></pre>
<p>  我们调用gen()函数并不会直接执行该函数，而是会得到一个生成器对象。对这个生成器对象调用next()函数，这个生成器对象会开始执行到第一个yield处，于是产出一个值0，注意：这时候gen()就暂停在yield处，直到第二次调用next()函数。</p>
<p>  到这里我们可以发现，生成器函数是可以暂停的函数，它在调用方的驱使下（调用方使用next()函数），每次执行到yield处将yield后方的值产出给调用方后就暂停自己的执行，直到调用方下一次驱动它执行。</p>
<p><strong>send:</strong></p>
<pre><code>def gen():
    s = yield &quot;hello&quot;
    print(&quot;用户传递进来的值为：%s&quot; % s)
    yield s


g = gen()
print(next(g))
print(g.send(&quot;world&quot;)) 
</code></pre>
<p>执行结果为：</p>
<pre><code>def gen():
    s = yield &quot;hello&quot;
    print(&quot;用户传递进来的值为：%s&quot; % s)
    yield s


g = gen()
print(next(g))
print(g.send(&quot;world&quot;))
</code></pre>
<p>  来看看上面代码的执行：首先调用gen()得到一个生成器对象，这时候生成器函数还没有开始执行，接着调用next()函数，生成器函数执行到第一个yield处，产出字符串hello后暂停执行，调用方得到产出的值打印输出。然后调用方通过send()发送了一个字符串world给生成器函数，这时候，生成器函数将world赋值给s，继续它的执行，直到第二个yield处，将调用方传递进来的world返回给调用方。</p>
<p>  到这里我们可以发现，此时的生成器函数既可以暂停时产出值，又可以接收调用方传递进来的值恢复执行，这就和协程的思想差不多了。</p>
<p><strong>Event Loop：</strong></p>
<p>  在真正的理解协程之前，还有个东西时我觉得必须要理解的，那就是事件循环（Event Loop）。</p>
<p>  协程是单线程的，单线程就意味着所有的任务需要在单线程上排队执行，也就是前一个任务没有执行完成，后一个任务就没有办法执行。在CPU密集型的任务之中，这样其实还行，但是如果我们的任务都是IO密集型的呢？也就是我们大部分的任务都是在等待网络的数据返回，等待磁盘文件的数据，这就会造成CPU一直在等待这些任务的完成再去执行下一个任务。</p>
<p>  有没有什么办法能够让单线程的任务执行不这么笨呢？其实我们可以将这些需要等待IO设备的任务挂在一边嘛！这时候，如果我们的任务都是需要等待的任务，那么单线程在执行时遇到一个就把它挂起来，这里可以通过一个数据结构（例如队列）将这些处于执行等待状态的任务放进去，为什么是执行等待状态呢？因为它们正在执行但是又不得不等待例如网络数据的返回等等。直到将所有的任务都放进去之后，单线程就可以开始它的接连不断的表演了：有没有任务完成的小伙伴呀！快来我这里执行！</p>
<p>  此时如果有某个任务完成了，它会得到结果，于是发出一个信号：我完成了。那边还在循环追问的单线程终于得到了答复，就会去看看这个任务有没有绑定什么回调函数呀？如果绑定了回调函数就进去把回调函数给执行了，如果没有，就将它所在的任务恢复执行，并将结果返回。</p>
<p>  到这里事件循环的大致作用已经说完了，我们可以看到，仅仅有协程是不够的，我们还需要事件循环和它配合使用，这样才能让多个协程可以并发的执行。</p>
<p>  Python3.4中，引入了asyncio包，这个包提供了关于事件循环的实现，这就使得在Python中使用协程实现高并发成为可能。我们来模拟一个爬虫：</p>
<pre><code>import asyncio

@asyncio.coroutine
def get_html(url, name):
    print(&quot;%s get %s html start&quot; % (name, url))
    yield from asyncio.sleep(2)
    print(&quot;%s get %s html end&quot; % (name, url))


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    # 创建两个协程
    tasks = [
        get_html(&quot;http://www.baidu.com&quot;, &quot;A&quot;),
        get_html(&quot;http://www.souhu.com&quot;, &quot;B&quot;),
    ]
    # 启动事件循环并将协程放进去执行
    loop.run_until_complete(asyncio.wait(tasks))
</code></pre>
<p>  在上面的模拟爬虫的代码中，我们使用了装饰器@asyncio.coroutine来将这个get_html()函数定义为协程，在协程中使用了asyncio.sleep()函数模拟从网络请求数据。在执行的过程中，我们首先使用asyncio提供的get_event_loop()创建一个事件循环，这里我们不需要自己实现事件循环，接着创建两个协程，并将这两个协程扔到事件循环中执行。</p>
<p>结果：</p>
<pre><code>A get http://www.baidu.com html start
B get http://www.souhu.com html start
A get http://www.baidu.com html end
B get http://www.souhu.com html end
</code></pre>
<p>  仔细观察，我们会发现在协程中并没有使用time.sleep()函数，而是使用了asyncio.sleep()函数，是因为time.sleep()函数会将整个线程休眠几秒，而asyncio.sleep()其实也是一个协程，这个协程将和事件循环直接通信并将一个Future对象交给事件循环，事件循环会一直监视着它直到它的任务完成（在这里就是休眠两秒），并不会将整个线程都停止执行。</p>
<p>  到现在，我们可以使用基于生成器的协程和事件循环来做到高并发了。但是问题来了，这里是基于生成器的协程，生成器其实有自己的用法，为什么还要给它强加一个协程的用法呢？</p>
<p><strong>async/await：</strong></p>
<p>  Python3.5中引入了async/await这一组关键词，这就使得python可以定义原生协程了。await的用法和yield from用法类似，但是await后面只能跟Awaitable的对象（实现了__await__魔法方法），而yield from后面可以跟生成器、协程等等。</p>
<p>使用async/await修改上面的代码：</p>
<pre><code>import asyncio


async def get_html(url, name):
    print(&quot;%s get %s html start&quot; % (name, url))
    await asyncio.sleep(2)
    print(&quot;%s get %s html end&quot; % (name, url))


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    # 创建两个协程
    tasks = [
        get_html(&quot;http://www.baidu.com&quot;, &quot;A&quot;),
        get_html(&quot;http://www.souhu.com&quot;, &quot;B&quot;),
    ]
    # 启动事件循环并将协程放进去执行
    loop.run_until_complete(asyncio.wait(tasks))
</code></pre>
<p>  在Tornado的官方文档中，其实是建议用户使用async/await来定义原生协程，原因有以下几点：</p>
<p>1.原生协程要快于基于生成器的协程</p>
<p>2.原生协程可以使用async for和async with语法</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[10. 规则特例 -Google C++编程规范]]></title>
        <id>https://lixin-scut.github.io//post/10-gui-ze-te-li-google-cbian-cheng-gui-fan</id>
        <link href="https://lixin-scut.github.io//post/10-gui-ze-te-li-google-cbian-cheng-gui-fan">
        </link>
        <updated>2020-05-01T04:07:22.000Z</updated>
        <content type="html"><![CDATA[<p>  前面说明的编程习惯基本都是强制性的. 但所有优秀的规则都允许例外, 这里就是探讨这些特例.</p>
<h3 id="101-现有不合规范的代码">10.1. 现有不合规范的代码</h3>
<p><strong>总述</strong></p>
<p>  对于现有不符合既定编程风格的代码可以网开一面.</p>
<p><strong>说明</strong></p>
<p>  <strong>当你修改使用其他风格的代码时, 为了与代码原有风格保持一致可以不使用本指南约定</strong>. 如果不放心, 可以与代码原作者或现在的负责人员商讨. 记住,<strong>一致性 也包括原有的一致性.</strong></p>
<h3 id="102-windows-代码">10.2. Windows 代码</h3>
<p><strong>总述</strong></p>
<p>  Windows 程序员有自己的编程习惯, 主要源于 Windows 头文件和其它 Microsoft 代码. 我们希望任何人都可以顺利读懂你的代码, 所以针对所有平台的 C++ 编程只给出一个单独的指南.</p>
<p><strong>说明</strong></p>
<p>  如果你习惯使用 Windows 编码风格, 这儿有必要重申一下某些你可能会忘记的指南:</p>
<ol>
<li>不要使用匈牙利命名法 (比如把整型变量命名成 iNum). 使用 Google 命名约定, 包括对源文件使用 .cc 扩展名.</li>
<li>Windows 定义了很多原生类型的同义词 (YuleFox 注: 这一点, 我也很反感), 如 DWORD, HANDLE 等等. 在调用 Windows API 时这是完全可以接受甚至鼓励的. 即使如此, 还是尽量使用原有的 C++ 类型, 例如使用 const TCHAR * 而不是 LPCTSTR.</li>
<li>使用 Microsoft Visual C++ 进行编译时, 将警告级别设置为 3 或更高, 并将所有警告(warnings)当作错误(errors)处理.</li>
<li><strong>不要使用 #pragma once; 而应该使用 Google 的头文件保护规则</strong>. 头文件保护的路径应该相对于项目根目录 (Yang.Y 注: 如 #ifndef SRC_DIR_BAR_H_, 参考 #define 保护 一节).</li>
<li><strong>除非万不得已, 不要使用任何非标准的扩展, 如 #pragma 和declspec.</strong><br>
使用__declspec(dllimport) 和__declspec(dllexport) 是允许的, 但必须通过宏来使用, 比如 DLLIMPORT 和 DLLEXPORT, 这样其他人在分享使用这些代码时可以很容易地禁用这些扩展.</li>
</ol>
<p>然而, 在 Windows 上仍然有一些我们偶尔需要违反的规则:</p>
<ol>
<li>通常我们 禁止使用多重继承, 但在使用 COM 和 ATL/WTL 类时可以使用多重继承. 为了实现 COM 或 ATL/WTL 类/接口, 你可能不得不使用多重实现继承.</li>
<li>虽然代码中不应该使用异常, 但是在 ATL 和部分 STL（包括 Visual C++ 的 STL) 中异常被广泛使用. 使用 ATL 时, 应定义 _ATL_NO_EXCEPTIONS 以禁用异常. 你需要研究一下是否能够禁用 STL 的异常, 如果无法禁用, 可以启用编译器异常. (注意这只是为了编译 STL, 自己的代码里仍然不应当包含异常处理).</li>
<li>通常为了利用头文件预编译, 每个每个源文件的开头都会包含一个名为 StdAfx.h 或 precompile.h 的文件. 为了使代码方便与其他项目共享, 请避免显式包含此文件 (除了在 precompile.cc 中), 使用 /FI 编译器选项以自动包含该文件.</li>
<li>资源头文件通常命名为 resource.h 且只包含宏, 这一文件不需要遵守本风格指南.</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[9. 格式 -Google C++编程规范]]></title>
        <id>https://lixin-scut.github.io//post/9-ge-shi-google-cbian-cheng-gui-fan</id>
        <link href="https://lixin-scut.github.io//post/9-ge-shi-google-cbian-cheng-gui-fan">
        </link>
        <updated>2020-05-01T03:44:42.000Z</updated>
        <content type="html"><![CDATA[<p>  每个人都可能有自己的代码风格和格式, 但如果一个项目中的所有人都遵循同一风格的话, 这个项目就能更顺利地进行. 每个人未必能同意下述的每一处格式规则, 而且其中的不少规则需要一定时间的适应, 但整个项目服从统一的编程风格是很重要的, 只有这样才能让所有人轻松地阅读和理解代码.</p>
<p>  为了帮助你正确的格式化代码, 我们写了一个 emacs 配置文件.</p>
<h3 id="91-行长度">9.1. 行长度</h3>
<p><strong>总述</strong></p>
<p><strong>每一行代码字符数不超过 80.</strong></p>
<p>  我们也认识到这条规则是有争议的, 但很多已有代码都遵照这一规则, 因此我们感觉一致性更重要.</p>
<p><strong>优点</strong></p>
<p>  提倡该原则的人认为强迫他们调整编辑器窗口大小是很野蛮的行为. 很多人同时并排开几个代码窗口, 根本没有多余的空间拉伸窗口. 大家都把窗口最大尺寸加以限定, 并且 80 列宽是传统标准. 那么为什么要改变呢?</p>
<p><strong>缺点</strong></p>
<p>  反对该原则的人则认为更宽的代码行更易阅读. 80 列的限制是上个世纪 60 年代的大型机的古板缺陷; 现代设备具有更宽的显示屏, 可以很轻松地显示更多代码.</p>
<p><strong>结论</strong></p>
<p>  80 个字符是最大值.</p>
<p>  如果无法在不伤害易读性的条件下进行断行, 那么注释行可以超过 80 个字符, 这样可以方便复制粘贴. 例如, 带有命令示例或 URL 的行可以超过 80 个字符.</p>
<p>  包含长路径的 #include 语句可以超出80列.</p>
<p>  <strong>头文件保护 可以无视该原则.</strong></p>
<h3 id="92-非-ascii-字符">9.2. 非 ASCII 字符</h3>
<p><strong>总述</strong></p>
<p>  <strong>尽量不使用非 ASCII 字符, 使用时必须使用 UTF-8 编码.</strong></p>
<p><strong>说明</strong></p>
<p>  即使是英文, 也不应将用户界面的文本硬编码到源代码中, 因此非 ASCII 字符应当很少被用到. 特殊情况下可以适当包含此类字符. 例如, 代码分析外部数据文件时, 可以适当硬编码数据文件中作为分隔符的非 ASCII 字符串; 更常见的是 (不需要本地化的) 单元测试代码可能包含非 ASCII 字符串. 此类情况下, 应使用 UTF-8 编码, 因为很多工具都可以理解和处理 UTF-8 编码.</p>
<p>  十六进制编码也可以, 能增强可读性的情况下尤其鼓励 —— 比如 &quot;\xEF\xBB\xBF&quot;, 或者更简洁地写作 u8&quot;\uFEFF&quot;, 在 Unicode 中是 零宽度 无间断 的间隔符号, 如果不用十六进制直接放在 UTF-8 格式的源文件中, 是看不到的.</p>
<p>(译者注: &quot;\xEF\xBB\xBF&quot; 通常用作 UTF-8 with BOM 编码标记)</p>
<p>  使用 u8 前缀把带 uXXXX 转义序列的字符串字面值编码成 UTF-8. 不要用在本身就带 UTF-8 字符的字符串字面值上, 因为如果编译器不把源代码识别成 UTF-8, 输出就会出错.</p>
<p>  <strong>别用 C++11 的 char16_t 和 char32_t, 它们和 UTF-8 文本没有关系, wchar_t 同理, 除非你写的代码要调用 Windows API, 后者广泛使用了 wchar_t.</strong></p>
<h3 id="93-空格还是制表位">9.3. 空格还是制表位</h3>
<p><strong>总述</strong></p>
<p>  <strong>只使用空格, 每次缩进 2 个空格.</strong></p>
<p><strong>说明</strong></p>
<p>  <strong>我们使用空格缩进. 不要在代码中使用制表符. 你应该设置编辑器将制表符转为空格.</strong></p>
<h3 id="94-函数声明与定义">9.4. 函数声明与定义</h3>
<p><strong>总述</strong></p>
<p>  返回类型和函数名在同一行, 参数也尽量放在同一行, 如果放不下就对形参分行, 分行方式与 函数调用 一致.</p>
<p><strong>说明</strong></p>
<p>函数看上去像这样:</p>
<pre><code>
ReturnType ClassName::FunctionName(Type par_name1, Type par_name2) {
  DoSomething();
  ...
}
</code></pre>
<p>如果同一行文本太多, 放不下所有参数:</p>
<pre><code>ReturnType ClassName::ReallyLongFunctionName(Type par_name1, Type par_name2,
                                             Type par_name3) {
  DoSomething();
  ...
}
</code></pre>
<p>甚至连第一个参数都放不下:</p>
<pre><code>ReturnType LongClassName::ReallyReallyReallyLongFunctionName(
    Type par_name1,  // 4 space indent
    Type par_name2,
    Type par_name3) {
  DoSomething();  // 2 space indent
  ...
}
</code></pre>
<p>注意以下几点:</p>
<ol>
<li>使用好的参数名.</li>
<li>只有在参数未被使用或者其用途非常明显时, 才能省略参数名.</li>
<li>如果返回类型和函数名在一行放不下, 分行.</li>
<li>如果返回类型与函数声明或定义分行了, 不要缩进.</li>
<li>左圆括号总是和函数名在同一行.</li>
<li>函数名和左圆括号间永远没有空格.</li>
<li>圆括号与参数间没有空格.</li>
<li>左大括号总在最后一个参数同一行的末尾处, 不另起新行.</li>
<li>右大括号总是单独位于函数最后一行, 或者与左大括号同一行.</li>
<li>右圆括号和左大括号间总是有一个空格.</li>
<li>所有形参应尽可能对齐.</li>
<li>缺省缩进为 2 个空格.</li>
<li>换行后的参数保持 4 个空格的缩进.</li>
<li>未被使用的参数, 或者根据上下文很容易看出其用途的参数, 可以省略参数名:</li>
</ol>
<pre><code>class Foo {
 public:
  Foo(Foo&amp;&amp;);
  Foo(const Foo&amp;);
  Foo&amp; operator=(Foo&amp;&amp;);
  Foo&amp; operator=(const Foo&amp;);
};
</code></pre>
<p><strong>未被使用的参数如果其用途不明显的话, 在函数定义处将参数名注释起来:</strong></p>
<pre><code>class Shape {
 public:
  virtual void Rotate(double radians) = 0;
};

class Circle : public Shape {
 public:
  void Rotate(double radians) override;
};

void Circle::Rotate(double /*radians*/) {}
</code></pre>
<pre><code>// 差 - 如果将来有人要实现, 很难猜出变量的作用.
void Circle::Rotate(double) {}
</code></pre>
<p><strong>属性, 和展开为属性的宏, 写在函数声明或定义的最前面, 即返回类型之前:</strong></p>
<pre><code>MUST_USE_RESULT bool IsOK();
</code></pre>
<h3 id="95-lambda-表达式">9.5. Lambda 表达式</h3>
<p><strong>总述</strong></p>
<p>  Lambda 表达式对形参和函数体的格式化和其他函数一致; 捕获列表同理, 表项用逗号隔开.</p>
<p><strong>说明</strong></p>
<p>  若用引用捕获, 在变量名和 &amp; 之间不留空格.</p>
<pre><code>int x = 0;
auto add_to_x = [&amp;x](int n) { x += n; };
</code></pre>
<p>短 lambda 就写得和内联函数一样.</p>
<pre><code>std::set&lt;int&gt; blacklist = {7, 8, 9};
std::vector&lt;int&gt; digits = {3, 9, 1, 8, 4, 7, 1};
digits.erase(std::remove_if(digits.begin(), digits.end(), [&amp;blacklist](int i) {
               return blacklist.find(i) != blacklist.end();
             }),
             digits.end());
</code></pre>
<h3 id="96-函数调用">9.6. 函数调用</h3>
<p><strong>总述</strong></p>
<p>  要么一行写完函数调用, 要么在圆括号里对参数分行, 要么参数另起一行且缩进四格. 如果没有其它顾虑的话, 尽可能精简行数, 比如把多个参数适当地放在同一行里.</p>
<p><strong>说明</strong></p>
<p>函数调用遵循如下形式：</p>
<pre><code>bool retval = DoSomething(argument1, argument2, argument3);
</code></pre>
<p>注意此处和函数定义不同</p>
<p>  <strong>如果同一行放不下, 可断为多行, 后面每一行都和第一个实参对齐, 左圆括号后和右圆括号前不要留空格：</strong></p>
<pre><code>bool retval = DoSomething(averyveryveryverylongargument1,
                          argument2, argument3);
</code></pre>
<p>参数也可以放在次行, 缩进四格：</p>
<pre><code>if (...) {
  ...
  ...
  if (...) {
    DoSomething(
        argument1, argument2,  // 4 空格缩进
        argument3, argument4);
  }
</code></pre>
<p>  把多个参数放在同一行以减少函数调用所需的行数, 除非影响到可读性. 有人认为把每个参数都独立成行, 不仅更好读, 而且方便编辑参数. 不过, 比起所谓的参数编辑, 我们更看重可读性, 且后者比较好办：</p>
<p>  如果一些参数本身就是略复杂的表达式, 且降低了可读性, 那么可以直接创建临时变量描述该表达式, 并传递给函数：</p>
<pre><code>int my_heuristic = scores[x] * y + bases[x];
bool retval = DoSomething(my_heuristic, x, y, z);
</code></pre>
<p>  或者放着不管, 补充上注释：</p>
<pre><code>bool retval = DoSomething(scores[x] * y + bases[x],  // Score heuristic.
                          x, y, z);
</code></pre>
<p>  如果某参数独立成行, 对可读性更有帮助的话, 那也可以如此做. <strong>参数的格式处理应当以可读性而非其他作为最重要的原则.</strong></p>
<p>  <strong>此外, 如果一系列参数本身就有一定的结构, 可以酌情地按其结构来决定参数格式：</strong></p>
<pre><code>// 通过 3x3 矩阵转换 widget.
my_widget.Transform(x1, x2, x3,
                    y1, y2, y3,
                    z1, z2, z3);
</code></pre>
<h3 id="97-列表初始化格式">9.7. 列表初始化格式</h3>
<p><strong>总述</strong></p>
<p>  您平时<strong>怎么格式化函数调用, 就怎么格式化 列表初始化.</strong></p>
<p><strong>说明</strong></p>
<p>  <strong>如果列表初始化伴随着名字, 比如类型或变量名, 格式化时将将名字视作函数调用名, {} 视作函数调用的括号. 如果没有名字, 就视作名字长度为零.</strong></p>
<pre><code>// 一行列表初始化示范.
return {foo, bar};
functioncall({foo, bar});
pair&lt;int, int&gt; p{foo, bar};

// 当不得不断行时.
SomeFunction(
    {&quot;assume a zero-length name before {&quot;},  // 假设在 { 前有长度为零的名字.
    some_other_function_parameter);
SomeType variable{
    some, other, values,
    {&quot;assume a zero-length name before {&quot;},  // 假设在 { 前有长度为零的名字.
    SomeOtherType{
        &quot;Very long string requiring the surrounding breaks.&quot;,  // 非常长的字符串, 前后都需要断行.
        some, other values},
    SomeOtherType{&quot;Slightly shorter string&quot;,  // 稍短的字符串.
                  some, other, values}};
SomeType variable{
    &quot;This is too long to fit all in one line&quot;};  // 字符串过长, 因此无法放在同一行.
MyType m = {  // 注意了, 您可以在 { 前断行.
    superlongvariablename1,
    superlongvariablename2,
    {short, interior, list},
    {interiorwrappinglist,
     interiorwrappinglist2}};
</code></pre>
<h3 id="98-条件语句">9.8. 条件语句</h3>
<p><strong>总述</strong></p>
<p>  <strong>倾向于不在圆括号内使用空格. 关键字 if 和 else 另起一行.</strong></p>
<p><strong>说明</strong></p>
<p>  对基本条件语句有两种可以接受的格式. 一种在圆括号和条件之间有空格, 另一种没有.</p>
<p>  最常见的是没有空格的格式. 哪一种都可以, 最重要的是 保持一致. 如果你是在修改一个文件, 参考当前已有格式. 如果是写新的代码, 参考目录下或项目中其它文件. 还在犹豫的话, 就不要加空格了.</p>
<pre><code>if (condition) {  // 圆括号里没有空格.
  ...  // 2 空格缩进.
} else if (...) {  // else 与 if 的右括号同一行.
  ...
} else {
  ...
}
</code></pre>
<p>  如果你更喜欢在圆括号内部加空格:</p>
<pre><code>if ( condition ) {  // 圆括号与空格紧邻 - 不常见
  ...  // 2 空格缩进.
} else {  // else 与 if 的右括号同一行.
  ...
}
</code></pre>
<p>  <strong>注意所有情况下 if 和左圆括号间都有个空格. 右圆括号和左大括号之间也要有个空格:</strong></p>
<pre><code>
if(condition)     // 差 - IF 后面没空格.
if (condition){   // 差 - { 前面没空格.
if(condition){    // 变本加厉地差.
</code></pre>
<pre><code>if (condition) {  // 好 - IF 和 { 都与空格紧邻.
</code></pre>
<p>  如果能增强可读性, 简短的条件语句允许写在同一行. 只有当语句简单并且没有使用 else 子句时使用:</p>
<pre><code>if (x == kFoo) return new Foo();
if (x == kBar) return new Bar();
</code></pre>
<p>  如果语句有 else 分支则不允许:</p>
<pre><code>// 不允许 - 当有 ELSE 分支时 IF 块却写在同一行
if (x) DoThis();
else DoThat();
</code></pre>
<p>  通常, 单行语句不需要使用大括号, 如果你喜欢用也没问题; 复杂的条件或循环语句用大括号可读性会更好. 也有一些项目要求 if 必须总是使用大括号:</p>
<pre><code>if (condition)
  DoSomething();  // 2 空格缩进.

if (condition) {
  DoSomething();  // 2 空格缩进.
}
</code></pre>
<p>  但如果语句中某个 if-else 分支使用了大括号的话, 其它分支也必须使用:</p>
<pre><code>// 不可以这样子 - IF 有大括号 ELSE 却没有.
if (condition) {
  foo;
} else
  bar;

// 不可以这样子 - ELSE 有大括号 IF 却没有.
if (condition)
  foo;
else {
  bar;
}
</code></pre>
<pre><code>// 只要其中一个分支用了大括号, 两个分支都要用上大括号.
if (condition) {
  foo;
} else {
  bar;
}
</code></pre>
<h3 id="99-循环和开关选择语句">9.9. 循环和开关选择语句</h3>
<p><strong>总述</strong></p>
<p>  switch 语句可以使用大括号分段, 以表明 cases 之间不是连在一起的. 在单语句循环里, 括号可用可不用. 空循环体应使用 {} 或 continue.</p>
<p><strong>说明</strong></p>
<p>  switch 语句中的 case 块可以使用大括号也可以不用, 取决于你的个人喜好. 如果用的话, 要按照下文所述的方法.</p>
<p>  <strong>如果有不满足 case 条件的枚举值, switch 应该总是包含一个 default 匹配</strong> (如果有输入值没有 case 去处理, 编译器将给出 warning). <strong>如果 default 应该永远执行不到, 简单的加条 assert</strong>:</p>
<pre><code>switch (var) {
  case 0: {  // 2 空格缩进
    ...      // 4 空格缩进
    break;
  }
  case 1: {
    ...
    break;
  }
  default: {
    assert(false);
  }
}
</code></pre>
<p>在单语句循环里, 括号可用可不用：</p>
<pre><code>for (int i = 0; i &lt; kSomeNumber; ++i)
  printf(&quot;I love you\n&quot;);

for (int i = 0; i &lt; kSomeNumber; ++i) {
  printf(&quot;I take it back\n&quot;);
}
</code></pre>
<p><strong>空循环体应使用 {} 或 continue, 而不是一个简单的分号.</strong></p>
<pre><code>while (condition) {
  // 反复循环直到条件失效.
}
for (int i = 0; i &lt; kSomeNumber; ++i) {}  // 可 - 空循环体.
while (condition) continue;  // 可 - contunue 表明没有逻辑.
while (condition);  // 差 - 看起来仅仅只是 while/loop 的部分之一.
</code></pre>
<h3 id="910-指针和引用表达式">9.10. 指针和引用表达式</h3>
<p><strong>总述</strong></p>
<p>  <strong>句点或箭头前后不要有空格. 指针/地址操作符 (*, &amp;) 之后不能有空格.</strong></p>
<p><strong>说明</strong></p>
<p>  下面是指针和引用表达式的正确使用范例:</p>
<pre><code>x = *p;
p = &amp;x;
x = r.y;
x = r-&gt;y;
</code></pre>
<p>注意:</p>
<ol>
<li>在访问成员时, 句点或箭头前后没有空格.</li>
<li>指针操作符 * 或 &amp; 后没有空格.</li>
</ol>
<p><strong>在声明指针变量或参数时, 星号与类型或变量名紧挨都可以:</strong></p>
<pre><code>// 好, 空格前置.
char *c;
const string &amp;str;

// 好, 空格后置.
char* c;
const string&amp; str;
</code></pre>
<pre><code>int x, *y;  // 不允许 - 在多重声明中不能使用 &amp; 或 *
char * c;  // 差 - * 两边都有空格
const string &amp; str;  // 差 - &amp; 两边都有空格.
</code></pre>
<p>  <strong>在单个文件内要保持风格一致, 所以, 如果是修改现有文件, 要遵照该文件的风格.</strong></p>
<h3 id="911-布尔表达式">9.11. 布尔表达式</h3>
<p><strong>总述</strong></p>
<p>  如果一个布尔表达式超过 标准行宽, 断行方式要统一一下.</p>
<p><strong>说明</strong></p>
<p>下例中, 逻辑与 (&amp;&amp;) 操作符总位于行尾:</p>
<pre><code>if (this_one_thing &gt; this_other_thing &amp;&amp;
    a_third_thing == a_fourth_thing &amp;&amp;
    yet_another &amp;&amp; last_one) {
  ...
}
</code></pre>
<p>  注意, 上例的逻辑与 (&amp;&amp;) 操作符均位于行尾. 这个格式在 Google 里很常见, 虽然把所有操作符放在开头也可以. 可以考虑额外插入圆括号, 合理使用的话对增强可读性是很有帮助的. 此外, 直接用符号形式的操作符, 比如 &amp;&amp; 和 ~, 不要用词语形式的 and 和 compl.</p>
<h3 id="912-函数返回值">9.12. 函数返回值</h3>
<p><strong>总述</strong></p>
<p>  <strong>不要在 return 表达式里加上非必须的圆括号.</strong></p>
<p><strong>说明</strong></p>
<p>  只有在写 x = expr 要加上括号的时候才在 return expr; 里使用括号.</p>
<pre><code>return result;                  // 返回值很简单, 没有圆括号.
// 可以用圆括号把复杂表达式圈起来, 改善可读性.
return (some_long_condition &amp;&amp;
        another_condition);
</code></pre>
<pre><code>return (value);                // 毕竟您从来不会写 var = (value);
return(result);                // return 可不是函数！
</code></pre>
<h3 id="913-变量及数组初始化">9.13. 变量及数组初始化</h3>
<p><strong>总述</strong></p>
<p>  用 =, () 和 {} 均可.</p>
<p><strong>说明</strong></p>
<p>  您可以用 =, () 和 {}, 以下的例子都是正确的：</p>
<pre><code>int x = 3;
int x(3);
int x{3};
string name(&quot;Some Name&quot;);
string name = &quot;Some Name&quot;;
string name{&quot;Some Name&quot;};
</code></pre>
<p>  请务必小心列表初始化 {...} 用 std::initializer_list 构造函数初始化出的类型. 非空列表初始化就会优先调用 std::initializer_list, 不过空列表初始化除外, 后者原则上会调用默认构造函数. <strong>为了强制禁用 std::initializer_list 构造函数, 请改用括号.</strong></p>
<pre><code>vector&lt;int&gt; v(100, 1);  // 内容为 100 个 1 的向量.
vector&lt;int&gt; v{100, 1};  // 内容为 100 和 1 的向量.
</code></pre>
<p>  此外,<strong>列表初始化不允许整型类型的四舍五入, 这可以用来避免一些类型上的编程失误.</strong></p>
<pre><code>int pi(3.14);  // 好 - pi == 3.
int pi{3.14};  // 编译错误: 缩窄转换.
</code></pre>
<h3 id="914-预处理指令">9.14. 预处理指令</h3>
<p><strong>总述</strong></p>
<p>  <strong>预处理指令不要缩进, 从行首开始.</strong></p>
<p><strong>说明</strong></p>
<p>  <strong>即使预处理指令位于缩进代码块中, 指令也应从行首开始.</strong></p>
<pre><code>// 好 - 指令从行首开始
  if (lopsided_score) {
#if DISASTER_PENDING      // 正确 - 从行首开始
    DropEverything();
# if NOTIFY               // 非必要 - # 后跟空格
    NotifyClient();
# endif
#endif
    BackToNormal();
  }
// 差 - 指令缩进
  if (lopsided_score) {
    #if DISASTER_PENDING  // 差 - &quot;#if&quot; 应该放在行开头
    DropEverything();
    #endif                // 差 - &quot;#endif&quot; 不要缩进
    BackToNormal();
  }
</code></pre>
<h3 id="915-类格式">9.15. 类格式</h3>
<p><strong>总述</strong></p>
<p>  <strong>访问控制块的声明依次序是 public:, protected:, private:, 每个都缩进 1 个空格.</strong></p>
<p><strong>说明</strong></p>
<p>  类声明 (下面的代码中缺少注释, 参考 类注释) 的基本格式如下:</p>
<pre><code>class MyClass : public OtherClass {
 public:      // 注意有一个空格的缩进
  MyClass();  // 标准的两空格缩进
  explicit MyClass(int var);
  ~MyClass() {}

  void SomeFunction();
  void SomeFunctionThatDoesNothing() {
  }

  void set_some_var(int var) { some_var_ = var; }
  int some_var() const { return some_var_; }

 private:
  bool SomeInternalFunction();

  int some_var_;
  int some_other_var_;
};
</code></pre>
<p>注意事项:</p>
<ol>
<li>所有基类名应在 80 列限制下尽量与子类名放在同一行.</li>
<li>关键词 public:, protected:, private: 要缩进 1 个空格.</li>
<li>除第一个关键词 (一般是 public) 外, 其他关键词前要空一行. 如果类比较小的话也可以不空.</li>
<li>这些关键词后不要保留空行.</li>
<li>public 放在最前面, 然后是 protected, 最后是 private.</li>
<li>关于声明顺序的规则请参考 声明顺序 一节.</li>
</ol>
<h3 id="916-构造函数初始值列表">9.16. 构造函数初始值列表</h3>
<p><strong>总述</strong></p>
<p>  <strong>构造函数初始化列表放在同一行或按四格缩进并排多行.</strong></p>
<p><strong>说明</strong></p>
<p>  下面两种初始值列表方式都可以接受:</p>
<pre><code>// 如果所有变量能放在同一行:
MyClass::MyClass(int var) : some_var_(var) {
  DoSomething();
}

// 如果不能放在同一行,
// 必须置于冒号后, 并缩进 4 个空格
MyClass::MyClass(int var)
    : some_var_(var), some_other_var_(var + 1) {
  DoSomething();
}

// 如果初始化列表需要置于多行, 将每一个成员放在单独的一行
// 并逐行对齐
MyClass::MyClass(int var)
    : some_var_(var),             // 4 space indent
      some_other_var_(var + 1) {  // lined up
  DoSomething();
}

// 右大括号 } 可以和左大括号 { 放在同一行
// 如果这样做合适的话
MyClass::MyClass(int var)
    : some_var_(var) {}
</code></pre>
<h3 id="917-命名空间格式化">9.17. 命名空间格式化</h3>
<p><strong>总述</strong></p>
<p>  命名空间内容不缩进.</p>
<p><strong>说明</strong></p>
<p>  <strong>命名空间 不要增加额外的缩进层次</strong>, 例如:</p>
<pre><code>namespace {

void foo() {  // 正确. 命名空间内没有额外的缩进.
  ...
}

}  // namespace
</code></pre>
<p>不要在命名空间内缩进:</p>
<pre><code>namespace {

  // 错, 缩进多余了.
  void foo() {
    ...
  }

}  // namespace
</code></pre>
<p><strong>声明嵌套命名空间时, 每个命名空间都独立成行.</strong></p>
<pre><code>namespace foo {
namespace bar {
</code></pre>
<h3 id="919-水平留白">9.19. 水平留白</h3>
<p><strong>总述</strong></p>
<p>  水平留白的使用根据在代码中的位置决定. 永远不要在行尾添加没意义的留白.</p>
<p><strong>说明</strong></p>
<p><strong>通用</strong></p>
<pre><code>void f(bool b) {  // 左大括号前总是有空格.
  ...
int i = 0;  // 分号前不加空格.
// 列表初始化中大括号内的空格是可选的.
// 如果加了空格, 那么两边都要加上.
int x[] = { 0 };
int x[] = {0};

// 继承与初始化列表中的冒号前后恒有空格.
class Foo : public Bar {
 public:
  // 对于单行函数的实现, 在大括号内加上空格
  // 然后是函数实现
  Foo(int b) : Bar(), baz_(b) {}  // 大括号里面是空的话, 不加空格.
  void Reset() { baz_ = 0; }  // 用括号把大括号与实现分开.
  ...
</code></pre>
<p>  <strong>添加冗余的留白会给其他人编辑时造成额外负担. 因此, 行尾不要留空格.</strong> 如果确定一行代码已经修改完毕, 将多余的空格去掉; 或者在专门清理空格时去掉（尤其是在没有其他人在处理这件事的时候). (Yang.Y 注: 现在大部分代码编辑器稍加设置后, 都支持自动删除行首/行尾空格, 如果不支持, 考虑换一款编辑器或 IDE)</p>
<p><strong>循环和条件语句</strong></p>
<pre><code>if (b) {          // if 条件语句和循环语句关键字后均有空格.
} else {          // else 前后有空格.
}
while (test) {}   // 圆括号内部不紧邻空格.
switch (i) {
for (int i = 0; i &lt; 5; ++i) {
switch ( i ) {    // 循环和条件语句的圆括号里可以与空格紧邻.
if ( test ) {     // 圆括号, 但这很少见. 总之要一致.
for ( int i = 0; i &lt; 5; ++i ) {
for ( ; i &lt; 5 ; ++i) {  // 循环里内 ; 后恒有空格, ;  前可以加个空格.
switch (i) {
  case 1:         // switch case 的冒号前无空格.
    ...
  case 2: break;  // 如果冒号有代码, 加个空格.
</code></pre>
<p><strong>操作符</strong></p>
<pre><code>// 赋值运算符前后总是有空格.
x = 0;

// 其它二元操作符也前后恒有空格, 不过对于表达式的子式可以不加空格.
// 圆括号内部没有紧邻空格.
v = w * x + y / z;
v = w*x + y/z;
v = w * (x + z);

// 在参数和一元操作符之间不加空格.
x = -5;
++x;
if (x &amp;&amp; !y)
  ...
</code></pre>
<p><strong>模板和转换</strong></p>
<pre><code>// 尖括号(&lt; and &gt;) 不与空格紧邻, &lt; 前没有空格, &gt; 和 ( 之间也没有.
vector&lt;string&gt; x;
y = static_cast&lt;char*&gt;(x);

// 在类型与指针操作符之间留空格也可以, 但要保持一致.
vector&lt;char *&gt; x;
</code></pre>
<h3 id="919-垂直留白">9.19. 垂直留白</h3>
<p><strong>总述</strong></p>
<p>  垂直留白越少越好.</p>
<p><strong>说明</strong></p>
<p>  这不仅仅是规则而是原则问题了: <strong>不在万不得已, 不要使用空行. 尤其是: 两个函数定义之间的空行不要超过 2 行, 函数体首尾不要留空行, 函数体中也不要随意添加空行.</strong></p>
<p>  <strong>基本原则是: 同一屏可以显示的代码越多, 越容易理解程序的控制流. 当然, 过于密集的代码块和过于疏松的代码块同样难看, 这取决于你的判断. 但通常是垂直留白越少越好.</strong></p>
<p>下面的规则可以让加入的空行更有效:</p>
<ol>
<li>函数体内开头或结尾的空行可读性微乎其微.</li>
<li>在多重 if-else 块里加空行或许有点可读性.</li>
</ol>
<h3 id="译者笔记">译者笔记</h3>
<ol>
<li>
<p>对于代码格式, 因人, 系统而异各有优缺点, 但同一个项目中遵循同一标准还是有必要的;</p>
</li>
<li>
<p>行宽原则上不超过 80 列, 把 22 寸的显示屏都占完, 怎么也说不过去;</p>
</li>
<li>
<p>尽量不使用非 ASCII 字符, 如果使用的话, 参考 UTF-8 格式 (尤其是 UNIX/Linux 下, Windows 下可以考虑宽字符), 尽量不将字符串常量耦合到代码中, 比如独立出资源文件, 这不仅仅是风格问题了;</p>
</li>
<li>
<p><strong>UNIX/Linux 下无条件使用空格</strong>, MSVC 的话使用 Tab 也无可厚非;</p>
</li>
<li>
<p>函数参数, 逻辑条件, 初始化列表: 要么所有参数和函数名放在同一行, 要么所有参数并排分行;</p>
</li>
<li>
<p>除函数定义的左大括号可以置于行首外, 包括函数/类/结构体/枚举声明, 各种语句的左大括号置于行尾, 所有右大括号独立成行;</p>
</li>
<li>
<p>./-&gt; 操作符前后不留空格, */&amp; 不要前后都留, 一个就可, 靠左靠右依各人喜好;</p>
</li>
<li>
<p>预处理指令/命名空间不使用额外缩进, 类/结构体/枚举/函数/语句使用缩进;</p>
</li>
<li>
<p>初始化用 = 还是 () 依个人喜好, 统一就好;</p>
</li>
<li>
<p>return 不要加 ();</p>
</li>
<li>
<p>水平/垂直留白不要滥用, 怎么易读怎么来.</p>
</li>
<li>
<p>关于 UNIX/Linux 风格为什么要把左大括号置于行尾 (.cc 文件的函数实现处, 左大括号位于行首), 我的理解是代码看上去比较简约, 想想行首除了函数体被一对大括号封在一起之外, 只有右大括号的代码看上去确实也舒服; Windows 风格将左大括号置于行首的优点是匹配情况一目了然.</p>
</li>
<li>
<p>80 行限制事实上有助于避免代码可读性失控, 比如超多重嵌套块, 超多重函数调用等等.</p>
</li>
<li>
<p><strong>Linux 上设置好了 Locale 就几乎一劳永逸设置好所有开发环境的编码</strong>, 不像奇葩的 Windows.</p>
</li>
<li>
<p><strong>Google 强调有一对 if-else 时, 不论有没有嵌套, 都要有大括号</strong>. Apple 正好 有栽过跟头 .</p>
</li>
<li>
<p>其实我主张指针／地址操作符与变量名紧邻, int* a, b vs int *a, b, 新手会误以为前者的 b 是 int * 变量, 但后者就不一样了, 高下立判.</p>
</li>
<li>
<p>在这风格指南里我才刚知道 C++ 原来还有所谓的 Alternative operator representations, 大概没人用吧.</p>
</li>
<li>
<p>注意构造函数初始值列表（Constructer Initializer List）与列表初始化（Initializer List）是两码事, 我就差点混淆了它们的翻译.</p>
</li>
<li>
<p>事实上, 如果您熟悉英语本身的书写规则, 就会发现该风格指南在格式上的规定与英语语法相当一脉相承. 比如普通标点符号和单词后面还有文本的话, 总会留一个空格; 特殊符号与单词之间就不用留了, 比如 if (true) 中的圆括号与 true.</p>
</li>
<li>
<p>本风格指南没有明确规定 <strong>void 函数里要不要用 return 语句</strong>, 不过就 Google 开源项目 leveldb 并没有写; 此外从 Is a blank return statement at the end of a function whos return type is void necessary? 来看, <strong>return; 比 return ; 更约定俗成</strong>（事实上 cpplint 会对后者报错, 指出分号前有多余的空格）, 且可用来提前跳出函数栈.</p>
</li>
</ol>
]]></content>
    </entry>
</feed>