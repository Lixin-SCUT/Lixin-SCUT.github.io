<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-05-09T16:03:59.246Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>千里之行，始于足下。不积跬步，无以至千里。</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[Python - 函数式编程]]></title>
        <id>https://lixin-scut.github.io//post/python-han-shu-shi-bian-cheng</id>
        <link href="https://lixin-scut.github.io//post/python-han-shu-shi-bian-cheng">
        </link>
        <updated>2020-05-09T01:50:11.000Z</updated>
        <content type="html"><![CDATA[<h2 id="函数式编程">函数式编程</h2>
<p>函数是Python内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。</p>
<p>而函数式编程Functional Programming，虽然也可以归结到<strong>面向过程</strong>的程序设计，但其思想<strong>更接近数学计算</strong>。</p>
<p>对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。</p>
<p>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。</p>
<p>函数式编程的一个特点就是，<strong>允许把函数本身作为参数传入另一个函数</strong>，还<strong>允许返回一个函数</strong>！</p>
<p>Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。</p>
<h2 id="高阶函数">高阶函数</h2>
<h3 id="变量可以指向函数">变量可以指向函数</h3>
<p>函数本身也可以赋值给变量，即：变量可以指向函数。<br>
变量f现在已经指向了abs函数本身。直接调用abs()函数和调用变量f()完全相同。</p>
<pre><code>&gt;&gt;&gt; f = abs
&gt;&gt;&gt; f
&lt;built-in function abs&gt;

&gt;&gt;&gt; f(-10)
10
</code></pre>
<h3 id="函数名也是变量">函数名也是变量</h3>
<p>函数名其实就是指向函数的变量！对于abs()这个函数，完全可以把函数名abs看成变量，它指向一个可以计算绝对值的函数！</p>
<p>如果把abs指向其他对象，会有什么情况发生？</p>
<pre><code>&gt;&gt;&gt; abs = 10
&gt;&gt;&gt; abs(-10)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: 'int' object is not callable
</code></pre>
<p>把abs指向10后，就无法通过abs(-10)调用该函数了！因为abs这个变量已经不指向求绝对值函数而是指向一个整数10！</p>
<p>当然实际代码绝对不能这么写，这里是为了说明函数名也是变量。要恢复abs函数，请重启Python交互环境。</p>
<p>注：由于abs函数实际上是定义在import builtins模块中的，所以要让修改abs变量的指向在其它模块也生效，要用import builtins; builtins.abs = 10。</p>
<h3 id="传入函数">传入函数</h3>
<p>既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。</p>
<p>编写高阶函数，就是让<strong>函数的参数能够接收别的函数</strong>。</p>
<p>一个最简单的高阶函数：</p>
<pre><code>def add(x, y, f):
    return f(x) + f(y)
</code></pre>
<p>当我们调用add(-5, 6, abs)时，参数x，y和f分别接收-5，6和abs，根据函数定义，我们可以推导计算过程为：</p>
<pre><code>x = -5
y = 6
f = abs
f(x) + f(y) ==&gt; abs(-5) + abs(6) ==&gt; 11
return 11
</code></pre>
<h2 id="mapreduce">map/reduce</h2>
<h3 id="map">map</h3>
<p>map()函数接收两个参数，一个是函数，一个是<strong>Iterable</strong>，map将传入的函数依次作用到序列的每个元素，并把结果作为<strong>新的Iterator</strong>返回。</p>
<p>举例说明，比如我们有一个函数f(x)=x^2，要把这个函数作用在一个list [1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map()实现如下：</p>
<pre><code>&gt;&gt;&gt; def f(x):
...     return x * x
...
&gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
# 注意list(r) 操作，把一个Iterator直接变为list
&gt;&gt;&gt; list(r) 
[1, 4, 9, 16, 25, 36, 49, 64, 81]
</code></pre>
<p>map()传入的第一个参数是f，即函数对象本身。由于结果r是一个Iterator，Iterator是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list。</p>
<p>对比循环操作，map()作为高阶函数，事实上它<strong>把运算规则抽象了</strong>，因此，我们不但可以计算简单的f(x)=x2，还可以<strong>计算任意复杂的函数</strong></p>
<h3 id="reduce">reduce</h3>
<p>reduce把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上，这个函数必须接收两个参数，reduce把<strong>结果继续和序列的下一个元素做累积计算</strong>，其效果就是：</p>
<pre><code>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
</code></pre>
<p>比方说对一个序列求和，就可以用reduce实现：</p>
<pre><code>&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; def add(x, y):
...     return x + y
...
&gt;&gt;&gt; reduce(add, [1, 3, 5, 7, 9])
25
# 当然求和运算可以直接用Python内建函数sum()，没必要动用reduce
</code></pre>
<p>再比如要把序列[1, 3, 5, 7, 9]变换成整数13579，reduce就可以派上用场：</p>
<pre><code>&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; def fn(x, y):
...     return x * 10 + y
...
&gt;&gt;&gt; reduce(fn, [1, 3, 5, 7, 9])
13579
</code></pre>
<p>如果考虑到字符串str也是一个序列，对上面的例子稍加改动，配合map()，我们就可以写出把str转换为int的函数：</p>
<pre><code>&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; def fn(x, y):
...     return x * 10 + y
...
&gt;&gt;&gt; def char2num(s):
...     digits = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}
...     return digits[s]
...
&gt;&gt;&gt; reduce(fn, map(char2num, '13579'))
13579
</code></pre>
<p>整理成一个str2int的函数就是：</p>
<pre><code>from functools import reduce

DIGITS = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}

def str2int(s):
    def fn(x, y):
        return x * 10 + y
    def char2num(s):
        return DIGITS[s]
    return reduce(fn, map(char2num, s))
</code></pre>
<p>还可以用lambda函数进一步简化成：</p>
<pre><code>from functools import reduce

DIGITS = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}

def char2num(s):
    return DIGITS[s]

def str2int(s):
    return reduce(lambda x, y: x * 10 + y, map(char2num, s))
</code></pre>
<p><strong>个人代码练习</strong><br>
利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：['adam', 'LISA', 'barT']，输出：['Adam', 'Lisa', 'Bart']：</p>
<pre><code>def normalize(name):
    name = name.lower()
    return name[0].upper() + name[1:]
		
# 测试:
L1 = ['adam', 'LISA', 'barT']
L2 = list(map(normalize, L1))
print(L2)
# ['Adam', 'Lisa', 'Bart'] 
</code></pre>
<p>注意：</p>
<ol>
<li>不可以name[i] = name[i].lower() 的操作，因为string（区别于list）是一种不可变的数据类型，必须对name整体进行赋值，使用下标操作返回的是类似于右值</li>
<li>name = name.lower()中不能缺少前面的name</li>
</ol>
<p>编写一个prod()函数，可以接受一个list并利用reduce()求积：</p>
<pre><code># -*- coding: utf-8 -*-
from functools import reduce

def sums(lhs, rhs):
    return lhs * rhs

def prod(L):
    return reduce(sums, L)
</code></pre>
<p>注意：</p>
<ol>
<li>一定要记得return 否则赋值就会变为none</li>
</ol>
<h2 id="filter">filter</h2>
<p>Python内建的filter()函数用于过滤序列。</p>
<p>和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数<strong>依次作用于每个元素</strong>，然后根据<strong>返回值是True还是False</strong>决定<strong>保留还是丢弃该元素</strong>。</p>
<p>filter()的作用是从一个序列中筛出符合条件的元素。由于filter()使用了惰性计算，所以只有在取filter()结果的时候，才会真正筛选并每次返回下一个筛出的元素。</p>
<p>例如，在一个list中，<strong>删掉偶数，只保留奇数</strong>，可以这么写：</p>
<pre><code>def is_odd(n):
    return n % 2 == 1

list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))
#结果: [1, 5, 9, 15]
</code></pre>
<p>把一个序列中的空字符串删掉，可以这么写：</p>
<pre><code>def not_empty(s):
    return s and s.strip()

list(filter(not_empty, ['A', '', 'B', None, 'C', '  ']))
#结果: ['A', 'B', 'C']
</code></pre>
<p>可见用filter()这个高阶函数，关键在于<strong>正确实现一个“筛选”函数</strong>。</p>
<p>注意到filter()函数返回的是一个<strong>Iterator</strong>，也就是一个<strong>惰性序列</strong>，所以要强迫filter()完成计算结果，需要用<strong>list()函数获得所有结果并返回list</strong>。</p>
<p><strong>个人代码练习</strong><br>
回数是指从左向右读和从右向左读都是一样的数，例如12321，909。请利用filter()筛选出回数：</p>
<pre><code>def is_palindrome(x):
    if(x &lt; 0 or (x % 10 == 0 and x != 0)) :
        return False
    temp = 0
    while(temp &lt; x):
        temp = temp * 10 + x % 10
        x //= 10
    return temp == x or temp // 10 == x
		
		# 测试:
output = filter(is_palindrome, range(1, 1000))
print('1~1000:', list(output))
if list(filter(is_palindrome, range(1, 200))) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191]:
    print('测试成功!')
else:
    print('测试失败!')
</code></pre>
<p>注意</p>
<ol>
<li>注意除法的区别！！！单个除号是精确除，返回的是浮点数，必须用双除号</li>
</ol>
<h2 id="sorted">sorted</h2>
<p>排序算法</p>
<p>排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是<strong>比较两个元素的大小</strong>。<br>
如果是数字，我们可以直接比较，但如果是<strong>字符串或者两个dict</strong>直接比较数学上的大小是没有意义的，因此，比较的过程<strong>必须通过函数抽象出来</strong>。</p>
<p>Python内置的sorted()函数就可以对list进行排序：</p>
<pre><code>&gt;&gt;&gt; sorted([36, 5, -12, 9, -21])
[-21, -12, 5, 9, 36]
</code></pre>
<p>此外，sorted()函数也是一个高阶函数，它还可以<strong>接收一个key函数</strong>来实现<strong>自定义的排序</strong>，例如按绝对值大小排序：</p>
<pre><code>&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs)
[5, 9, -12, -21, 36]
</code></pre>
<p>key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。对比原始的list和经过key=abs处理过的list：</p>
<pre><code>list = [36, 5, -12, 9, -21]

keys = [36, 5,  12, 9,  21]
</code></pre>
<p>然后sorted()函数<strong>按照keys进行排序</strong>，并<strong>按照对应关系返回list相应的元素</strong>：</p>
<pre><code>keys排序结果 =&gt; [5, 9,  12,  21, 36]
                |  |    |    |   |
最终结果     =&gt; [5, 9, -12, -21, 36]
</code></pre>
<p>我们再看一个字符串排序的例子：</p>
<pre><code>&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'])
['Credit', 'Zoo', 'about', 'bob']
</code></pre>
<p>默认情况下，对字符串排序，是按照<strong>ASCII的大小</strong>比较的，<strong>由于'Z' &lt; 'a'，结果，大写字母Z会排在小写字母a的前面。</strong></p>
<p>现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能用一个key函数把字符串映射为忽略大小写排序即可。忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。</p>
<p>这样，我们给sorted传入key函数，即可实现忽略大小写的排序：</p>
<pre><code>&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower)
['about', 'bob', 'Credit', 'Zoo']
</code></pre>
<p>要进行反向排序，不必改动key函数，可以传入第三个参数reverse=True：</p>
<pre><code>&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)
['Zoo', 'Credit', 'bob', 'about']
</code></pre>
<p>从上述例子可以看出，高阶函数的抽象能力是非常强大的，而且，核心代码可以保持得非常简洁。</p>
<h3 id="小结">小结</h3>
<p>sorted()也是一个高阶函数。用sorted()排序的关键在于实现一个映射函数。</p>
<p><strong>个人代码联系</strong><br>
假设我们用一组tuple表示学生名字和成绩：</p>
<p>L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]<br>
请用sorted()对上述列表分别按名字排序：</p>
<pre><code>#-*- coding: utf-8 -*-

L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]

def by_name(t):
    return t[0]
		
L2 = sorted(L, key=by_name)
print(L2)

# [('Adam', 92), ('Bart', 66), ('Bob', 75), ('Lisa', 88)] 
</code></pre>
<p>再按成绩从高到低排序：</p>
<pre><code>#-*- coding: utf-8 -*-

L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]

def by_score(t):
    return -t[1]
    
L2 = sorted(L, key=by_score)
print(L2)

# [('Adam', 92), ('Lisa', 88), ('Bob', 75), ('Bart', 66)] 
</code></pre>
<h2 id="返回函数">返回函数</h2>
<h3 id="函数作为返回值">函数作为返回值</h3>
<p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</p>
<p>我们来实现一个可变参数的求和。通常情况下，求和的函数是这样定义的：</p>
<pre><code>def calc_sum(*args):
    ax = 0
    for n in args:
        ax = ax + n
    return ax
</code></pre>
<p>但是，如果<strong>不需要立刻求和</strong>，而是在<strong>后面的代码中，根据需要再计算</strong>，可以不返回求和的结果，而是<strong>返回求和的函数</strong>：</p>
<pre><code>def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax
    return sum
</code></pre>
<p>当我们调用lazy_sum()时，<strong>返回的并不是求和结果，而是求和函数</strong>：</p>
<pre><code>&gt;&gt;&gt; f = lazy_sum(1, 3, 5, 7, 9)
&gt;&gt;&gt; f
&lt;function lazy_sum.&lt;locals&gt;.sum at 0x101c6ed90&gt;
</code></pre>
<p><strong>调用函数f时，才真正计算求和的结果</strong>：</p>
<pre><code>&gt;&gt;&gt; f()
25
</code></pre>
<p>在函数lazy_sum中又定义了函数sum，并且，内部函数sum<strong>可以引用外部函数lazy_sum的参数和局部变量</strong>，当lazy_sum返回函数sum时，<strong>相关参数和变量都保存在返回的函数</strong>中，这种称为“<strong>闭包（Closure）</strong>”的程序结构拥有极大的威力。</p>
<p>注意，调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数：</p>
<pre><code>&gt;&gt;&gt; f1 = lazy_sum(1, 3, 5, 7, 9)
&gt;&gt;&gt; f2 = lazy_sum(1, 3, 5, 7, 9)
&gt;&gt;&gt; f1==f2
False
</code></pre>
<p>f1()和f2()的调用结果互不影响。</p>
<h3 id="闭包">闭包</h3>
<p>注意到返回的函数在其定义内部引用了局部变量args，所以，当一个函数返回了一个函数后，<strong>其内部的局部变量还被新函数引用</strong>。</p>
<p>另一个需要注意的问题是，返回的函数<strong>并没有立刻执行</strong>，而是<strong>直到调用了f()才执行</strong>。</p>
<p>例子如下：</p>
<pre><code>def count():
    fs = []
    for i in range(1, 4):
        def f():
             return i*i
        fs.append(f)
    return fs

f1, f2, f3 = count()
</code></pre>
<p>在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都返回了。</p>
<p>可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是：</p>
<pre><code>&gt;&gt;&gt; f1()
9
&gt;&gt;&gt; f2()
9
&gt;&gt;&gt; f3()
9
</code></pre>
<p>结果全部都是9，原因在于返回的函数引用了变量i，但它<strong>并非立刻执行</strong>。<strong>等到3个函数都返回时，它们所引用的变量i已经变成了3</strong>，因此最终结果为9。</p>
<p><strong>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</strong></p>
<p>如果一定要引用循环变量，需要再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p>
<pre><code> def count():
    def f(j):
        def g():
            return j*j
        return g
    fs = []
    for i in range(1, 4):
        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()
    return fs

&gt;&gt;&gt; f1, f2, f3 = count()
&gt;&gt;&gt; f1()
1
&gt;&gt;&gt; f2()
4
&gt;&gt;&gt; f3()
9
</code></pre>
<p><strong>个人代码练习</strong><br>
利用闭包返回一个计数器函数，每次调用它返回递增整数：</p>
<pre><code>def createCounter():
    i = 0
    def counter():
        nonlocal i
        i = i + 1
        return i
    return counter
		
# 测试:
counterA = createCounter()
print(counterA(), counterA(), counterA(), counterA(), counterA()) # 1 2 3 4 5
counterB = createCounter()
if [counterB(), counterB(), counterB(), counterB()] == [1, 2, 3, 4]:
    print('测试通过!')
else:
    print('测试失败!')
</code></pre>
<p>注意！遇到了今天说到的问题，但是很奇葩，前面其实也有提及</p>
<blockquote>
<p>在函数lazy_sum中又定义了函数sum，并且，内部函数sum<strong>可以引用外部函数lazy_sum的参数和局部变量</strong>，当lazy_sum返回函数sum时，<strong>相关参数和变量都保存在返回的函数</strong>中，这种称为“<strong>闭包（Closure）</strong>”的程序结构拥有极大的威力。</p>
</blockquote>
<p>wtf？难道i不算外部函数的局部变量吗？<br>
我自己的解决方法：必须在内部函数加上 nonlocal i 才能正常运行，否则就会报错说i这个局部变量在定义前就被使用了</p>
<p>解决方法总结：<br>
&quot;&quot;&quot; 实现计数器统计函数调用次数 &quot;&quot;&quot;</p>
<pre><code>def createCounter():
    &quot;&quot;&quot; 方法1：list的原理类似C语言的数组和指针，不受作用域影响
    直接改变值对应的地址。也就是说不是改变值的引用，而是永久改变值本身 &quot;&quot;&quot;
    L=[0]
    def counter():
        L[0]+=1
        return L[0]
    return counter

def createCounter():
    &quot;&quot;&quot; 方法2：使用global扩大变量作用域 &quot;&quot;&quot;
    global n
    n=0
    def counter():
        global n
        n+=1
        return n
    return counter

def createCounter():
    &quot;&quot;&quot; 方法3：使用nonlocal声明内层函数变量，使其能修改外层函数的变量 &quot;&quot;&quot;
    n=0
    def counter():
        nonlocal n
        n+=1
        return n
    return counter

def createCounter():
    &quot;&quot;&quot; 方法4：使用生成器在外层函数创建生成器对象，在内层函数调用next() &quot;&quot;&quot;
    def count_generator():
        n=0
        while True:
            n+=1
            yield n
    # 调用生成器函数创建生成器对象一定要在外层函数进行
    temp=count_generator()

    def get_num():
        return next(temp)
    return get_num
</code></pre>
<p>网友解释一：</p>
<blockquote>
<p>声明变量i<strong>非内部函数的局部变量</strong>，否则内部函数只能引用，一旦修改会视其为局部变量，报错“局部变量在赋值之前被引用”。</p>
</blockquote>
<p>网友解释二：</p>
<blockquote>
<p>因为python中一切皆是对象，我们平时使用的a=1，s=‘adada’这些‘赋值’语句实际上是在内存中开辟了一块空间存储了1和‘adada’这两个对象（包括其属性和方法）后将内存空间的地址赋值给了a和s（为了方便，我们称呼它们为引用）。而在之后使用a和s时其实就是根据内存空间找到对应对象，调用其中存储的内容<br>
既然如此，一个方法也可以单独存放在内存空间内作为一个对象被引用。而这就是高阶函数和返回函数讨论的问题。<br>
高阶函数是<strong>将方法作为参数传入其他方法中去使用</strong>，比如sorted中的key参数，map、reduce中的函数参数<br>
而返回函数则是将方法（为了方便称呼，我们叫它内函数）作为一个方法（外函数）的返回值<br>
根据C语言基础我们可以知道当一个方法调用return时，会释放掉其内存（准确的说是函数栈）空间，则该函数的局部变量（包括函数体内定义和传入的参数）都会被释放而无法正常访问。但是假如我们的内函数需要使用外函数的局部变量，那就<strong>需要把内函数使用的局部变量‘绑定’给内函数</strong>，从而在外函数被释放的前提下内函数的使用也不会受到影响。楼下有一层总结了四种方法，其中方法四就是利用了这一点，因为生成器被内函数使用绑定，所以外函数释放后也无所谓。<br>
但是，生成器占据的资源相较于1个数据肯定要大，而我们又想节约资源实现计数该怎么办？---我们需要修改外函数的局部变量<br>
重点来了！！！！！！<br>
试想外部有语句 a = 0<br>
内部有语句 a = a +1<br>
python不像c语言有定义语句，我<strong>怎么知道内部的语句究竟是赋值外部变量还是定义内部变量</strong>？？？？？？<br>
（ps：c语言的情况下，外部int a=0，内部若是int a =1则覆盖外部，若是修改外部则直接赋值语句a=a+1.所以不存在歧义）<br>
为了解决这个问题，<strong>存在nonlocal关键字，nonlocal标记的赋值语句代表我这是赋值外部（第一层外部），没有标记的代表定义内部变量（这是方法3）</strong><br>
而假如我们定义了多层，func1包含func2，fun2包含func3，func 3想修改 func1的变量，（<strong>nonlocal标记的赋值语句指的是func2中的变量修改，因此没用</strong>）。所以我们想出了一个办法，创建一个<strong>全局标记global</strong>，凡是被<strong>global声明的变量就是指在内存空间内有独立空间的变量</strong>，<strong>没有被声明的就是局部的</strong>，从而解决跨层修改变量的问题（这是方法2）<br>
最后谈谈方法一（使用列表），列表的实现是可变长度的数组（详见https://www.jb51.net/article/164319.htm）<br>
我觉得能用这种方法应该是因为列表的定义L=[0]和列表的赋值L[x]=y语句不同，所以不存在歧义的才可以如此使用。感觉和所谓的列表实现类似C语言数组（指针）所以能够无视作用域没有关系（在python面向对象来看，所有的引用其实都是指向内存区域的指针，但不是所有类型的引用都可以无视作用域）</p>
</blockquote>
<p>网友解释三：</p>
<blockquote>
<p>个人感觉评论区的各位大手子都很强，总结得都很好，但是都忽略了一个底层问题，为什么L[0]可以作为一个全局变量，而L不行会报错。<br>
以下分析灵感来源于这篇文章：https://zhuanlan.zhihu.com/p/34395671，只是自己一点理解，可能有很多不对的地方，给大家提供一点方向。<br>
L[0]作为一个<strong>可变类型list对象</strong>，对这个对象执行操作后，比如 L[0] = L[0] + 1，它的内存地址是不变的，这个操作的实质是更改了在这个内存地址的这个list的第一个值，使其加一。<br>
而L作为一个<strong>不可变类型int对象</strong>，当对其赋值时，实际是把这个对象指向这个int值的内存地址。例如先赋初值 L = 0，然后使 L = L + 1，这个操作的整个过程实质是：将L指向int值0的内存地址；运算L + 1为int值1，将L指向int值1的内存地址。<br>
可变类型的实质就是引用的地址不变，该地址上存储的值可变。<br>
不可变类型的实质就是引用的地址可以变，但任意引用地址存储的值不可改变。<br>
这样设定的用意我大胆猜测是为了合理分配内存的存储和读写资源，设定一部分可以复用的固定数据让其存储在一个且每个固定数据一一对应只有一个的地址，这样不管有多少变量的值需要等于这个数据，其最终都指向这个地址，只占用一个存储单元，这就是不可变类型会指向的地址。而另一部分则满足变量所引用的地址不变，但是值需要随时更新的需求，这样不管这个变量的值需要存在多少种情况或者如何改变，其地址永远保持不变，这就是可变类型会指向的地址。<br>
看着可能会很混乱，实质上，<br>
可变类型就是<strong>一个变量只能对应一个地址</strong>，但<strong>这个地址可以对应多个值</strong>。而不可变类型就是<strong>一个变量可以对应多个地址</strong>，但<strong>每个地址只能对应一个值</strong>。<br>
再举一个帮助理解的例子，<br>
a = 1 #没有发现已经存在的存储int值1的地址，创建存储int值1的地址A，将a指向A<br>
b = 1 #发现int值1存在于地址A，将b指向A<br>
x = [1,2,3] #在地址X创建list [1,2,3] ，将x指向X<br>
y = [1,2,3] #在地址Y创建list [1,2,3] ，将y指向Y<br>
print(id(a),id(b),id(a)==id(b)) # True<br>
print(id(x),id(y),id(x)==id(y)) # False<br>
结果是a和b的地址一致，而x和y的地址是不一致的，可以看出虽然x和y的值是一样的，但由于都是list类型，可变类型，那么 x = [1,2,3] 和 y = [1,2,3] 这两个操作都属于创建一个新的list，不管他们的值是否一样。list的赋值都是一个创建然后指向的过程。而 a = 1 和 b = 1的情况，如注释中所述，是一个先寻找是否存在存储该int值的地址，有则指向该地址，没有的话，则创建一个存储该int值的地址，然后指向该地址。两者的赋值语句的逻辑是截然不同的，这是最本质上的差别。<br>
接下来，重点来了，<br>
python中向函数传递参数只能是<strong>引用传递，表示把它的地址都传进去了</strong>，而非值传递。<br>
意思很直观，在调用函数传递参数时，传递的是引用，直白的就是传递对象的内存地址。<br>
那么，在上面描述的情况中，每次调用主函数返回子函数时，由于return命令的执行，该主函数使用的临时变量的内存都要释放，然而由于返回的子函数使用了主函数的临时变量，这个变量会和子函数绑定，存入该子函数的内存空间。<br>
当使用L作为这个临时变量或者说传递对象的时候，return子函数这个操作执行后，返回的子函数中的内存空间中存储的L实质上是L指向的内存地址，当进行 <strong>L = L + 1</strong>这个操作时，由于L现在代表的是一个引用，是一个内存地址，那么实质上的操作就是提取L指向的内存地址中的值；运算该值 + 1的结果；将L指向该结果的内存地址，这个操作需要一个随程序运行更新的起点地址，不然就是一个无法确定运行环境的闭包，而这是与闭包本身的定义相违背的。由于没有设定L为全局变量，所以python就会将这个L视为子函数的局部变量，在子函数内部寻找起点地址，然而又由于未提前在子函数内赋初值，进而报错“局部变量在赋值之前被引用”。<br>
这里大胆猜测，在使用global命令后，python将其置入一个包含所有global变量的总list或者其他可变类型的变量中，然后通过这个变量的变量加上位置实现其调用，原理与L[0]相同。<br>
而当L[0]作为一个临时变量或者说传递对象的时候，由于上文已经讲过的list对象操作的实质，在传进去的这个L[0]所引用的地址是可以直接进行值的改变的，那么则识别为全局变量，return执行后，子函数内存空间保存的是一个确定的指令，对L[0]所在内存地址进行加一。<br>
这个角度的理解方法总结来说，就是可变对象和不可变对象的实质，以及python中函数参数传递和临时变量存储在子函数内存空间中的实质。<br>
或者也有另一个角度的理解方法。<br>
当使用L作为这个临时变量或者说传递对象的时候，return子函数这个操作执行后，在子函数内部，由于并没有声明L是一个全局变量，L所进行的操作也不代表其是一个可变类型的全局变量。<br>
此处又有另外一个知识点，关于<strong>根据操作判断变量类型的逻辑</strong>，参考<br>
https://blog.csdn.net/zsdxqsjxlomer/article/details/78381626?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3<br>
https://blog.csdn.net/bigxuyang/article/details/77877935<br>
这两篇文章，会得到一个比较清晰的认知。<br>
<strong>关键点在于  L = [1,2,3]  这个操作在子函数内没有提前声明L是一个全局变量，纵然L的操作代表其是一个可变类型的变量，但该操作并没有触发python认定其为一个全局变量，则  L = [1,2,3]  这个操作相当于创建一个list类型的名为L的局部变量，而并没有调用之前创建的全局变量L。而  L.append 或者  L[0] = L[0] + 1 这类的list类型专属操作（实质是list这个class的method或者attribute），由于子函数内部在此操作前并没有创建L这个变量，那么触发python认定其为一个可变类型的全局变量，就会往外部寻找，则寻找到之前创建的全局变量L。</strong><br>
接上文，那么L就会被认定为一个<strong>局部变量</strong>，然而L并没有被赋初值，此时报错“局部变量在赋值之前被引用”。<br>
而当L[0]作为一个临时变量或者说传递对象的时候，当执行 L[0] = L[0] + 1这个操作，由于子函数内部在此操作前并没有创建L这个变量，那么触发python认定其为一个可变类型的全局变量，就会往外部寻找，则寻找到之前创建的全局变量L。<br>
这个角度的理解方法总结来说，就是python在闭包函数返回子函数时，判定临时变量是否为全局变量的逻辑。当没有声明变量为全局变量时，只有进行了触发python判定其为<strong>可变类型的全局变量</strong>的操作，才会去外部寻找该变量。所以，当执行 L = L + 1这个操作时，在没有声明L为全局变量的情况下，python是不会去外部寻找的，那么，又因为L并没有在子函数内的开头部分创建，必定会报错“局部变量在赋值之前被引用”。<br>
虽然说了这么多，但自我感觉也有很多地方有问题，发出来抛砖引玉，与大家共同讨论进步，欢迎大家指正。<br>
更新：值小的int会一直保持固定的地址。<br>
有几篇文章解释了相关问题，贴出来供大家参考一下。<br>
https://blog.csdn.net/WSBruce/article/details/79234389?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1<br>
https://blog.csdn.net/fragmentalice/article/details/81363494?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2<br>
https://blog.csdn.net/as480133937/article/details/87305247?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3</p>
</blockquote>
<h2 id="匿名函数">匿名函数</h2>
<p>在传入函数时，可以不需要显式地定义函数，直接传入匿名函数更方便。</p>
<p>在Python中，对匿名函数提供了有限支持。还是以map()函数为例，计算f(x)=x2时，除了定义一个f(x)的函数外，还可以直接传入匿名函数：</p>
<pre><code>&gt;&gt;&gt; list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
[1, 4, 9, 16, 25, 36, 49, 64, 81]
</code></pre>
<p>通过对比可以看出，匿名函数lambda x: x * x实际上就是：</p>
<pre><code>def f(x):
    return x * x
</code></pre>
<p>关键字lambda表示匿名函数，冒号前面的x表示函数参数。</p>
<p>匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。</p>
<p>用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数：</p>
<pre><code>&gt;&gt;&gt; f = lambda x: x * x
&gt;&gt;&gt; f
&lt;function &lt;lambda&gt; at 0x101c6ef28&gt;
&gt;&gt;&gt; f(5)
25
</code></pre>
<p>同样，也可以把匿名函数作为返回值返回，比如：</p>
<pre><code>def build(x, y):
    return lambda: x * x + y * y
</code></pre>
<p>注意不用在：前写参数的情况</p>
<ol>
<li>lambda本身不需要传入参数（也就是：后面的表达式里用不到：前的参数）</li>
<li>只使用def中已经定义的形参</li>
</ol>
<h2 id="装饰器">装饰器</h2>
<p>由于函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数</p>
<pre><code>&gt;&gt;&gt; def now():
...     print('2015-3-25')
...
&gt;&gt;&gt; f = now
&gt;&gt;&gt; f()
2015-3-25
</code></pre>
<p>函数对象有一个__name__属性，可以拿到函数的名字：</p>
<pre><code>&gt;&gt;&gt; now.__name__
'now'
&gt;&gt;&gt; f.__name__
'now'
</code></pre>
<p>如锅要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now()函数的定义，这种<strong>在代码运行期间动态增加功能</strong>的方式，称之为“装饰器”（Decorator）。</p>
<p>本质上，decorator就是一个<strong>返回函数的高阶函数</strong>。所以，我们要定义一个能打印日志的decorator，可以定义如下：</p>
<pre><code>def log(func):
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
</code></pre>
<p>观察上面的log，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。我们要<strong>借助Python的@语法</strong>，<strong>把decorator置于函数的定义处</strong>：</p>
<pre><code>@log
def now():
    print('2015-3-25')
</code></pre>
<p>调用now()函数，不仅会运行now()函数本身，还会在运行now()函数前打印一行日志：</p>
<pre><code>&gt;&gt;&gt; now()
call now():
2015-3-25
</code></pre>
<p>把@log放到now()函数的定义处，相当于执行了语句：</p>
<pre><code>now = log(now)
</code></pre>
<p>由于log()是一个decorator，返回一个函数，所以，原来的now()函数仍然存在，只是现在同名的now变量指向了新的函数，于是调用now()将执行新函数，即在log()函数中返回的<strong>wrapper()函数</strong>。</p>
<p>wrapper()函数的参数定义是<code>(*args, **kw)</code>，因此，wrapper()函数可以<strong>接受任意参数的调用</strong>。在wrapper()函数内，首先打印日志，再紧接着调用原始函数。</p>
<p>如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本：</p>
<pre><code>def log(text):
    def decorator(func):
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
</code></pre>
<p>这个3层嵌套的decorator用法如下：</p>
<pre><code>@log('execute')
def now():
    print('2015-3-25')
</code></pre>
<p>执行结果如下：</p>
<pre><code>&gt;&gt;&gt; now()
execute now():
2015-3-25
</code></pre>
<p>和两层嵌套的decorator相比，3层嵌套的效果是这样的：</p>
<pre><code>&gt;&gt;&gt; now = log('execute')(now)
</code></pre>
<p>我们来剖析上面的语句</p>
<ol>
<li>首先<strong>执行log('execute')</strong></li>
<li><strong>返回的是decorator函数</strong>，再调用返回的函数，参数是now函数</li>
<li>返回值<strong>最终是wrapper函数</strong>。</li>
</ol>
<p>以上两种decorator的定义都没有问题，但还差最后一步。因为函数也是对象，它有__name__等属性，但经过decorator装饰之后的函数，<strong>它们的name已经从原来的'now'变成了'wrapper'</strong>：</p>
<pre><code>&gt;&gt;&gt; now.__name__
'wrapper'
</code></pre>
<p>因为返回的那个wrapper()函数名字就是'wrapper'，所以，<strong>需要把原始函数的name等属性复制到wrapper()函数中</strong>，<strong>否则，有些依赖函数签名的代码执行就会出错</strong>。</p>
<p>不需要编写<code>wrapper.__name__ = func.__name__</code>这样的代码，Python内置的<strong>functools.wraps</strong>就是干这个事的，所以，一个完整的decorator的写法如下：</p>
<pre><code>import functools

def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
</code></pre>
<p>或者针对带参数的decorator：</p>
<pre><code>import functools

def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
</code></pre>
<p>import functools是导入functools模块，在定义wrapper()的前面加上@functools.wraps(func)即可。</p>
<h2 id="小结-2">小结</h2>
<p>在面向对象（OOP）的设计模式中，decorator被称为装饰模式。OOP的装饰模式需要通过继承和组合来实现，而Python除了能支持OOP的decorator外，<strong>直接从语法层次支持decorator</strong>。Python的decorator<strong>可以用函数实现，也可以用类实现</strong>。</p>
<p>decorator可以增强函数的功能，定义起来虽然有点复杂，但使用起来非常灵活和方便。</p>
<h2 id="偏函数">偏函数</h2>
<p>Python的functools模块提供了很多有用的功能，其中一个就是偏函数（Partial function）。要注意，这里的偏函数和数学意义上的偏函数不一样。</p>
<p>在介绍函数参数的时候，通过设定参数的默认值，可以降低函数调用的难度。而偏函数也可以做到这一点。举例如下：</p>
<p>int()函数可以把字符串转换为整数，当仅传入字符串时，int()函数默认按十进制转换：</p>
<pre><code>&gt;&gt;&gt; int('12345')
12345
</code></pre>
<p>但<strong>int()函数还提供额外的base参数，默认值为10</strong>。如果<strong>传入base参数，就可以做N进制的转换</strong>：</p>
<pre><code>&gt;&gt;&gt; int('12345', base=8)
5349
&gt;&gt;&gt; int('12345', 16)
74565
</code></pre>
<p>假设要转换大量的二进制字符串，每次都传入int(x, base=2)非常麻烦，于是，我们想到，可以定义一个int2()的函数，默认把base=2传进去：</p>
<pre><code>def int2(x, base=2):
    return int(x, base)
</code></pre>
<p>这样，我们转换二进制就非常方便了：</p>
<pre><code>&gt;&gt;&gt; int2('1000000')
64
&gt;&gt;&gt; int2('1010101')
85
</code></pre>
<p>functools.partial就是帮助我们<strong>创建一个偏函数的，不需要我们自己定义int2()</strong>，可以直接使用下面的代码创建一个新的函数int2：</p>
<pre><code>&gt;&gt;&gt; import functools
&gt;&gt;&gt; int2 = functools.partial(int, base=2)
&gt;&gt;&gt; int2('1000000')
64
&gt;&gt;&gt; int2('1010101')
85
</code></pre>
<p>所以，简单总结functools.partial的作用就是，<strong>把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数</strong>，调用这个新函数会更简单。</p>
<p>注意到上面的新的int2函数，<strong>仅仅是把base参数重新设定默认值为2，但也可以在函数调用时传入其他值</strong>：</p>
<pre><code>&gt;&gt;&gt; int2('1000000', base=10)
1000000
</code></pre>
<p>最后，创建偏函数时，实际上<strong>可以接收函数对象、<code>*args</code>和<code>kw</code>这3个参数</strong>，当传入：</p>
<pre><code>int2 = functools.partial(int, base=2)
</code></pre>
<p>实际上固定了int()函数的关键字参数base，也就是：</p>
<pre><code>int2('10010')
</code></pre>
<p>相当于：</p>
<pre><code>kw = { 'base': 2 }
int('10010', **kw)
</code></pre>
<p>当传入：</p>
<pre><code>max2 = functools.partial(max, 10)
</code></pre>
<p>实际上会把10作为<code>*args</code>的一部分<strong>自动加到左边</strong>，也就是：</p>
<pre><code>max2(5, 6, 7)
</code></pre>
<p>相当于：</p>
<pre><code>args = (10, 5, 6, 7)
max(*args)
</code></pre>
<p>结果为10。</p>
<h2 id="小结-3">小结</h2>
<p>当函数的参<strong>数个数太多，需要简化时</strong>，使用functools.partial可以创建一个新的函数，这个新函数可以<strong>固定住原函数的部分参数</strong>，从而在调用时更简单。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python - 高级特性]]></title>
        <id>https://lixin-scut.github.io//post/python-gao-ji-te-xing</id>
        <link href="https://lixin-scut.github.io//post/python-gao-ji-te-xing">
        </link>
        <updated>2020-05-08T11:33:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="提取容器的部分元素">提取容器的部分元素</h2>
<h3 id="list">list</h3>
<p>取一个list部分元素是非常常见的操作，Python提供了切片（Slice）操作符<br>
取前3个元素，用一行代码就可以完成切片：</p>
<pre><code>&gt;&gt;&gt; L[0:3]
['Michael', 'Sarah', 'Tracy']
</code></pre>
<p>L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。</p>
<p>注意区间是左闭右开，提取的元素数量刚好是右区间减去左区间</p>
<p>如果第一个索引是0，还可以省略：</p>
<pre><code>&gt;&gt;&gt; L[:3]
['Michael', 'Sarah', 'Tracy']
</code></pre>
<p>注意Python支持L[-1]取倒数第一个元素，那么同样支持<strong>倒数切</strong>片，试试：</p>
<pre><code>&gt;&gt;&gt; L[-2:]
['Bob', 'Jack']
&gt;&gt;&gt; L[-2:-1]
['Bob']
</code></pre>
<p><strong>注意倒数第一个元素的索引是-1。</strong></p>
<p>例子：</p>
<p><strong>提取连续元素</strong></p>
<p>前10个数：</p>
<pre><code>&gt;&gt;&gt; L[:10]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>后10个数：</p>
<pre><code>&gt;&gt;&gt; L[-10:]
[90, 91, 92, 93, 94, 95, 96, 97, 98, 99]
</code></pre>
<p>前11-20个数：</p>
<pre><code>&gt;&gt;&gt; L[10:20]
[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
</code></pre>
<p>规律间隔取值</p>
<p>前10个数，每两个取一个：</p>
<pre><code>&gt;&gt;&gt; L[:10:2]
[0, 2, 4, 6, 8]
</code></pre>
<p>所有数，每5个取一个：</p>
<pre><code>&gt;&gt;&gt; L[::5]
[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]
</code></pre>
<p>甚至什么都不写，只写[:]就可以原样复制一个list：</p>
<pre><code>&gt;&gt;&gt; L[:]
[0, 1, 2, 3, ..., 99]
</code></pre>
<h3 id="tuple">tuple</h3>
<p>tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是<strong>操作的结果仍是tuple</strong>：</p>
<pre><code>&gt;&gt;&gt; (0, 1, 2, 3, 4, 5)[:3]
(0, 1, 2)
</code></pre>
<h3 id="字符串">字符串</h3>
<p>字符串'xxx'也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是<strong>操作结果仍是字符串</strong>：</p>
<pre><code>&gt;&gt;&gt; 'ABCDEFG'[:3]
'ABC'
&gt;&gt;&gt; 'ABCDEFG'[::2]
'ACEG'
</code></pre>
<p>在很多编程语言中，针对字符串提供了很多各种截取函数（例如，substring），其实目的就是对字符串切片。Python没有针对字符串的截取函数，只需要切片一个操作就可以完成。</p>
<p><strong>个人练习代码</strong><br>
实现一个trim()函数去除字符串首尾的空格，</p>
<pre><code>def trim(s):
if len(s) == 0:
		return s
left = 0
while left &lt; len(s) and s[left] == ' ':
		left = left + 1
right = len(s) - 1
while right &gt;= 0 and s[right] == ' ':
		right = right - 1
if left &lt; right:
	 return s[left : right+1]
else:
	 return ''
</code></pre>
<h2 id="迭代">迭代</h2>
<p>给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。</p>
<p>在Python中，迭代是通过for ... in来完成的</p>
<p>Python的for循环抽象程度要高于C的for循环，因为Python的for循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上。</p>
<h3 id="无下标迭代-dict迭代">无下标迭代-dict迭代</h3>
<p>list这种数据类型虽然有下标，但很多其他数据类型是没有下标的，但是，只要是可迭代对象，无论有无下标，都可以迭代，比如dict就可以迭代：</p>
<pre><code>&gt;&gt;&gt; d = {'a': 1, 'b': 2, 'c': 3}
&gt;&gt;&gt; for key in d:
...     print(key)
</code></pre>
<p>注意，由于哈希函数的特性，dict的存储不是按照list的方式顺序排列，所以，<strong>迭代出的结果顺序很可能不一样</strong>。</p>
<p>默认情况下，<strong>dict迭代的是key</strong>。如果要<strong>迭代value</strong>，可以用<code>for value in d.values()</code>，如果要<strong>同时迭代key和value</strong>，可以用<code>for k, v in d.items()</code>。</p>
<p>判断一个对象是可迭代对象：通过collections模块的Iterable类型判断：</p>
<pre><code>&gt;&gt;&gt; from collections import Iterable
&gt;&gt;&gt; isinstance('abc', Iterable) # str是否可迭代
True
&gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代
True
&gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代
False
</code></pre>
<h3 id="下标循环">下标循环</h3>
<p>如果要对list实现类似Java那样的下标循环，可以使用Python内置的<strong>enumerate函数</strong>，可以<strong>把一个list变成索引-元素对</strong>，这样就可以在for循环中<strong>同时迭代索引和元素</strong>本身：</p>
<pre><code>&gt;&gt;&gt; for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)
...
0 A
1 B
2 C
</code></pre>
<p>上面的for循环里，同时引用了两个变量，在Python里是很常见的，比如下面的代码：</p>
<pre><code>&gt;&gt;&gt; for x, y in [(1, 1), (2, 4), (3, 9)]:
...     print(x, y)
...
1 1
2 4
3 9
</code></pre>
<p><strong>个人练习代码</strong><br>
使用迭代查找一个list中最小和最大值，并返回一个tuple：</p>
<pre><code>def findMinAndMax(L):
    if len(L) == 0:    
        return (None, None)
    max_num = L[0]
    min_num = L[0]
    for num in L:
        max_num = max(max_num, num)
        min_num = min(min_num, num)
    return (min_num, max_num)
</code></pre>
<h2 id="列表生成式">列表生成式</h2>
<p>列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来<strong>创建list的生成式</strong>。</p>
<p>例如要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))：</p>
<pre><code>&gt;&gt;&gt; list(range(1, 11))
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
</code></pre>
<p>要生成[1x1, 2x2, 3x3, ..., 10x10]<br>
列表生成式则可以用一行语句代替循环生成：</p>
<pre><code>&gt;&gt;&gt; [x * x for x in range(1, 11)]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
</code></pre>
<p>把要生成的元素x * x放到前面，后面跟for循环，就可以把list创建出来</p>
<p>for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：</p>
<pre><code>&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0]
[4, 16, 36, 64, 100]
</code></pre>
<p>还可以使用两层循环，可以生成全排列：</p>
<pre><code>&gt;&gt;&gt; [m + n for m in 'ABC' for n in 'XYZ']
['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']
</code></pre>
<ol>
<li>字符串可以<strong>直接相加</strong></li>
<li>循环<strong>可以并列</strong></li>
</ol>
<p>运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：</p>
<pre><code>&gt;&gt;&gt; import os # 导入os模块，模块的概念后面讲到
&gt;&gt;&gt; [d for d in os.listdir('.')] # os.listdir可以列出文件和目录
['.emacs.d', '.ssh', '.Trash', 'Adlm', 'Applications', 'Desktop', 'Documents', 'Downloads', 'Library', 'Movies', 'Music', 'Pictures', 'Public', 'VirtualBox VMs', 'Workspace', 'XCode']
</code></pre>
<p>for循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value：</p>
<pre><code>&gt;&gt;&gt; d = {'x': 'A', 'y': 'B', 'z': 'C' }
&gt;&gt;&gt; for k, v in d.items():
...     print(k, '=', v)
...
y = B
x = A
z = C
</code></pre>
<p>最后把一个list中所有的字符串变成小写：</p>
<pre><code>&gt;&gt;&gt; L = ['Hello', 'World', 'IBM', 'Apple']
&gt;&gt;&gt; [s.lower() for s in L]
['hello', 'world', 'ibm', 'apple']
</code></pre>
<h3 id="if-else">if ... else</h3>
<p>使用列表生成式的时候，不能在<strong>最后的if</strong>加上else：</p>
<pre><code>&gt;&gt;&gt; [x for x in range(1, 11) if x % 2 == 0]
[2, 4, 6, 8, 10]

&gt;&gt;&gt; [x for x in range(1, 11) if x % 2 == 0 else 0]
  File &quot;&lt;stdin&gt;&quot;, line 1
    [x for x in range(1, 11) if x % 2 == 0 else 0]
                                              ^
SyntaxError: invalid syntax
</code></pre>
<p>这是因为<strong>跟在for后面的if</strong>是一个筛选条件，不能带else，否则无法进行筛选</p>
<p>而把if写在for前面必须加else，否则报错：</p>
<pre><code>&gt;&gt;&gt; [x if x % 2 == 0 for x in range(1, 11)]
  File &quot;&lt;stdin&gt;&quot;, line 1
    [x if x % 2 == 0 for x in range(1, 11)]
                       ^
SyntaxError: invalid syntax
</code></pre>
<p>这是因为for前面的部分是一个表达式，它必须根据x计算出一个结果。因此，考察表达式：x if x % 2 == 0，它无法根据x计算出结果，因为缺少else，必须加上else：</p>
<pre><code>&gt;&gt;&gt; [x if x % 2 == 0 else -x for x in range(1, 11)]
[-1, 2, -3, 4, -5, 6, -7, 8, -9, 10]
上述for前面的表达式x if x % 2 == 0 else -x才能根据x计算出确定的结果。
</code></pre>
<p>可见，在一个列表生成式中，for前面的if ... else是表达式，而for后面的if是过滤条件，不能带else。</p>
<p><strong>个人代码练习</strong><br>
如果list中既包含字符串，又包含整数，由于非字符串类型没有lower()方法，需要使用内建的isinstance函数可以判断一个变量是不是字符串：</p>
<pre><code>L1 = ['Hello', 'World', 18, 'Apple', None]
L2 = [x.lower() for x in L1 if isinstance(x, str)]
</code></pre>
<p>注意没法使用lower(x) ，必须用x.lower()</p>
<h2 id="生成器">生成器</h2>
<p>受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p>
<p>所以，如果<strong>列表元素可以按照某种算法推算出来</strong>，那我们是否可以在循环的过程中<strong>不断推算出后续的元素</strong>呢？这样就<strong>不必创建完整的list</strong>，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。</p>
<h3 id="创建generator">创建generator</h3>
<p>把一个列表生成式的[]改成()，就创建了一个generator：</p>
<pre><code>&gt;&gt;&gt; L = [x * x for x in range(10)]
&gt;&gt;&gt; L
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
&gt;&gt;&gt; g = (x * x for x in range(10))
&gt;&gt;&gt; g
&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;
</code></pre>
<p>创建L和g的区别仅在于最外层的[]和()，L是一个list，而g是一个generator。</p>
<p><strong>打印generator的每一个元素</strong></p>
<p>如果要一个一个打印出来，可以通过next()函数获得generator的下一个返回值：</p>
<pre><code>&gt;&gt;&gt; next(g)
0
&gt;&gt;&gt; next(g)
1
&gt;&gt;&gt; next(g)
4
&gt;&gt;&gt; next(g)
9
&gt;&gt;&gt; next(g)
16
&gt;&gt;&gt; next(g)
25
&gt;&gt;&gt; next(g)
36
&gt;&gt;&gt; next(g)
49
&gt;&gt;&gt; next(g)
64
&gt;&gt;&gt; next(g)
81
&gt;&gt;&gt; next(g)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
StopIteration
</code></pre>
<p>generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值<br>
直到计算到最后一个元素，<strong>没有更多的元素时，抛出StopIteration的错误</strong>。</p>
<p>更便捷的方法是使用for循环，因为generator也是可迭代对象：</p>
<pre><code>&gt;&gt;&gt; g = (x * x for x in range(10))
&gt;&gt;&gt; for n in g:
...     print(n)
... 
0
1
4
9
16
25
36
49
64
81
</code></pre>
<p>由于StopIteration的错误的存在，创建了一个generator后，基本上永远不会调用next()，而是通过for循环来迭代它，不需要关心StopIteration的错误。</p>
<p><strong>定义generator的另一种方法</strong></p>
<p>如果一个<strong>函数定义</strong>中包含<strong>yield关键字</strong>（注意这里涉及协程），那么这个函数就不再是一个普通函数，而是一个generator</p>
<p>例子：斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到：</p>
<pre><code>def fib(max):
    n, a, b = 0, 0, 1
    while n &lt; max:
        yield b
        a, b = b, a + b
        n = n + 1
    return 'done'
		
&gt;&gt;&gt; f = fib(6)
&gt;&gt;&gt; f
&lt;generator object fib at 0x104feaaa0&gt;
</code></pre>
<p>generator和函数的执行流程不一样。</p>
<ol>
<li>函数是顺序执行，遇到return语句或者最后一行函数语句就返回。</li>
<li>而变成generator的函数，在每次<strong>调用next()的时候执行</strong>，<strong>遇到yield语句返回</strong>，再次执行时<strong>从上次返回的yield语句处继续执行</strong>。</li>
</ol>
<p>举个简单的例子，定义一个generator，依次返回数字1，3，5：</p>
<pre><code>def odd():
    print('step 1')
    yield 1
    print('step 2')
    yield(3)
    print('step 3')
    yield(5)
</code></pre>
<p>调用该generator时，首先要生成一个generator对象，然后用next()函数不断获得下一个返回值：</p>
<pre><code>&gt;&gt;&gt; o = odd()
&gt;&gt;&gt; next(o)
step 1
1
&gt;&gt;&gt; next(o)
step 2
3
&gt;&gt;&gt; next(o)
step 3
5
&gt;&gt;&gt; next(o)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
StopIteration

# 在执行过程中，遇到yield就中断，下次又继续执行。执行3次yield后，已经没有yield可以执行了，所以，第4次调用next(o)就报错。
</code></pre>
<p>由于错误的存在，同样地把函数改成generator后，我们基本上从来不会用next()来获取下一个返回值，而是直接使用for循环来迭代：</p>
<pre><code>&gt;&gt;&gt; for n in fib(6):
...     print(n)
</code></pre>
<p>但在循环过程中不断调用yield，可能会导致不断中断。要给循环设置一个条件来退出循环，不然就会产生一个无限数列出来。</p>
<p>但是用for循环调用generator时，<strong>拿不到generator的return语句的返回值</strong>。如果想要拿到返回值，<strong>必须捕获StopIteration错误</strong>，<strong>返回值包含在StopIteration的value中</strong></p>
<pre><code>&gt;&gt;&gt; g = fib(6)
&gt;&gt;&gt; while True:
...     try:
...         x = next(g)
...         print('g:', x)
...     except StopIteration as e:
...         print('Generator return value:', e.value)
...         break
...
g: 1
g: 1
g: 2
g: 3
g: 5
g: 8
Generator return value: done
</code></pre>
<p><strong>个人代码练习</strong><br>
杨辉三角把<br>
每一行看做一个list，试写一个generator，不断输出下一行的list：</p>
<pre><code># -*- coding: utf-8 -*-

def triangles():
    n, list_pre, list_cur  = 0, [1], [1, 1]
    while True:
        if n == 0:
            n = n + 1
            yield list_pre
        if n == 1:
            n = n + 1
            yield list_cur
        list_pre = list_cur
        list_cur = [1, 1]
        for i in range(1, len(list_pre)):
            list_cur.insert(i, list_pre[i] + list_pre[i - 1])
        n = n + 1
        yield list_cur
				
				
# 期待输出:
# [1]
# [1, 1]
# [1, 2, 1]
# [1, 3, 3, 1]
# [1, 4, 6, 4, 1]
# [1, 5, 10, 10, 5, 1]
# [1, 6, 15, 20, 15, 6, 1]
# [1, 7, 21, 35, 35, 21, 7, 1]
# [1, 8, 28, 56, 70, 56, 28, 8, 1]
# [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]
n = 0
results = []
for t in triangles():
    results.append(t)
    n = n + 1
    if n == 10:
        break

for t in results:
    print(t)

if results == [
    [1],
    [1, 1],
    [1, 2, 1],
    [1, 3, 3, 1],
    [1, 4, 6, 4, 1],
    [1, 5, 10, 10, 5, 1],
    [1, 6, 15, 20, 15, 6, 1],
    [1, 7, 21, 35, 35, 21, 7, 1],
    [1, 8, 28, 56, 70, 56, 28, 8, 1],
    [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]
]:
    print('测试通过!')
else:
    print('测试失败!')
</code></pre>
<h2 id="迭代器">迭代器</h2>
<h3 id="可迭代对象iterable">可迭代对象：Iterable</h3>
<p>可以直接作用于for循环的数据类型有以下几种：</p>
<p>一类是<strong>集合数据类型</strong>，如list、tuple、dict、set、str等；</p>
<p>一类是<strong>generator</strong>，包括<strong>生成器</strong>和<strong>带yield的generator function</strong>。</p>
<p>这些可以直接作用于for循环的对象统称为<strong>可迭代对象：Iterable。</strong></p>
<p><strong>可以使用isinstance()判断一个对象是否是Iterable对象：</strong></p>
<pre><code>&gt;&gt;&gt; from collections.abc import Iterable
&gt;&gt;&gt; isinstance([], Iterable)
True
&gt;&gt;&gt; isinstance({}, Iterable)
True
&gt;&gt;&gt; isinstance('abc', Iterable)
True
&gt;&gt;&gt; isinstance((x for x in range(10)), Iterable)
True
&gt;&gt;&gt; isinstance(100, Iterable)
False
</code></pre>
<h3 id="迭代器iterator">迭代器：Iterator</h3>
<p>而生成器不但可以作用于for循环，还<strong>可以被next()函数不断调用并返回下一个值</strong>，直到最<strong>后抛出StopIteration错误</strong>表示无法继续返回下一个值了。</p>
<p>可以被next()函数调用并不断返回下一个值的对象称为<strong>迭代器：Iterator</strong>。</p>
<p>可以使用isinstance()判断一个对象是否是Iterator对象：</p>
<pre><code>&gt;&gt;&gt; from collections.abc import Iterator
&gt;&gt;&gt; isinstance((x for x in range(10)), Iterator)
True
&gt;&gt;&gt; isinstance([], Iterator)
False
&gt;&gt;&gt; isinstance({}, Iterator)
False
&gt;&gt;&gt; isinstance('abc', Iterator)
False
</code></pre>
<p><strong>生成器都是Iterator对象</strong>，但<strong>list、dict、str虽然是Iterable，却不是Iterator。</strong></p>
<p>把list、dict、str等Iterable变成Iterator可以使用<strong>iter()函数</strong>：</p>
<pre><code>&gt;&gt;&gt; isinstance(iter([]), Iterator)
True
&gt;&gt;&gt; isinstance(iter('abc'), Iterator)
True
</code></pre>
<p><strong>为什么list、dict、str等数据类型不是Iterator？</strong></p>
<p>这是因为Python的<strong>Iterator对象表示的是一个数据流</strong>，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却<strong>不能提前知道序列的长度</strong>，只能不断通过next()函数实现按需计算下一个数据，所以<strong>Iterator的计算是惰性的</strong>，只有在需要返回下一个数据时它才会计算。</p>
<p>Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而<strong>使用list是永远不可能存储全体自然数的</strong>。</p>
<h3 id="小结">小结</h3>
<p>凡是可作用于for循环的对象都是<strong>Iterable类型</strong>；</p>
<p>凡是可作用于next()函数的对象都是<strong>Iterator类型</strong>，它们表示一个惰性计算的序列；</p>
<p>集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。</p>
<p>Python的for循环本质上就是通过不断调用next()函数实现的，例如：</p>
<pre><code>for x in [1, 2, 3, 4, 5]:
    pass
</code></pre>
<p>实际上完全等价于：</p>
<pre><code># 首先获得Iterator对象:
it = iter([1, 2, 3, 4, 5])
# 循环:
while True:
    try:
        # 获得下一个值:
        x = next(it)
    except StopIteration:
        # 遇到StopIteration就退出循环
        break
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python - 函数]]></title>
        <id>https://lixin-scut.github.io//post/python-han-shu</id>
        <link href="https://lixin-scut.github.io//post/python-han-shu">
        </link>
        <updated>2020-05-08T07:20:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="调用函数">调用函数</h2>
<p>要调用一个函数，需要知道函数的名称和参数，比如求绝对值的函数abs，只有一个参数。可以直接从Python的官方网站查看文档：</p>
<p>http://docs.python.org/3/library/functions.html#abs</p>
<p>也可以在交互式命令行通过help(abs)查看abs函数的帮助信息。help将会进入新界面，按q返回</p>
<p>调用函数的时候，如果传入的参数数量不对，会报TypeError的错误，并且Python会明确地告诉你：abs()有且仅有1个参数，但给出了两个：</p>
<pre><code>&gt;&gt;&gt; abs(1, 2)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: abs() takes exactly one argument (2 given)
</code></pre>
<p>如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报TypeError的错误，并且给出错误信息：str是错误的参数类型：</p>
<pre><code>&gt;&gt;&gt; abs('a')
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: bad operand type for abs(): 'str'
</code></pre>
<p>而max函数max()可以接收任意多个参数，并返回最大的那个：</p>
<pre><code>&gt;&gt;&gt; max(1, 2)
2
&gt;&gt;&gt; max(2, 3, 1, -5)
3
</code></pre>
<h3 id="数据类型转换">数据类型转换</h3>
<p>Python内置的常用函数还包括数据类型转换函数，比如int()函数可以把其他数据类型转换为整数：</p>
<pre><code>&gt;&gt;&gt; int('123')
123
&gt;&gt;&gt; int(12.34)
12
&gt;&gt;&gt; float('12.34')
12.34
&gt;&gt;&gt; str(1.23)
'1.23'
&gt;&gt;&gt; str(100)
'100'
&gt;&gt;&gt; bool(1)
True
&gt;&gt;&gt; bool('')
False
</code></pre>
<p>函数名其实就是<strong>指向一个函数对象的引用</strong>，完全可以<strong>把函数名赋给一个变量</strong>，相当于给这个函数起了一个“别名”：</p>
<pre><code>&gt;&gt;&gt; a = abs # 变量a指向abs函数
&gt;&gt;&gt; a(-1) # 所以也可以通过a调用abs函数
1
</code></pre>
<h2 id="定义函数">定义函数</h2>
<p>在Python中，定义一个函数要使用def语句，依次写出<strong>函数名、括号、括号中的参数和冒号:</strong>，然后，在缩进块中编写函数体，函数的返回值用return语句返回。</p>
<pre><code>def my_abs(param):
    if(param &lt; 0):
         param = - param
    return param
</code></pre>
<p>函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。</p>
<p>如果没有return语句，函数执行完毕后也会返回结果，只是<strong>结果为None</strong>。return None可以简写为return。</p>
<p>在Python交互环境中定义函数时，注意Python会出现...的提示。函数定义结束后需要按两次回车重新回到&gt;&gt;&gt;提示符下</p>
<p>如果你已经把my_abs()的函数定义<strong>保存为abstest.py文件</strong>了，那么，可以在该文件的当前目录下启动Python解释器，<strong>用from abstest import my_abs来导入my_abs()函数</strong>，注意abstest是文件名（<strong>不含.py扩展名</strong>）</p>
<h3 id="空函数">空函数</h3>
<p>如果想定义一个什么事也不做的空函数，可以用pass语句：</p>
<pre><code>def nop():
    pass
</code></pre>
<p>pass语句什么都不做，那有什么用？实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。</p>
<p>pass还可以用在其他语句里，比如：</p>
<pre><code>if age &gt;= 18:
    pass
</code></pre>
<p><strong>缺少了pass，代码运行就会有语法错误。</strong></p>
<h3 id="参数检查">参数检查</h3>
<p>调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出TypeError：</p>
<pre><code>&gt;&gt;&gt; my_abs(1, 2)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: my_abs() takes 1 positional argument but 2 were given
</code></pre>
<p><strong>但是如果参数类型不对，Python解释器就无法帮我们检查</strong>。</p>
<p>试试my_abs和内置函数abs的差别：</p>
<pre><code>&gt;&gt;&gt; my_abs('A')
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;&lt;stdin&gt;&quot;, line 2, in my_abs
TypeError: unorderable types: str() &gt;= int()
&gt;&gt;&gt; abs('A')
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: bad operand type for abs(): 'str'
</code></pre>
<p>当传入了不恰当的参数时，内置函数abs会检查出参数错误，而自己定义的my_abs没有参数检查，会导致if语句出错，出错信息和abs不一样。所以，这个函数定义不够完善。</p>
<p>需要修改一下my_abs的定义，对参数类型做检查，只允许整数和浮点数类型的参数。<br>
<strong>数据类型检查可以用内置函数isinstance()实现</strong>：</p>
<pre><code>def my_abs(x):
    if not isinstance(x, (int, float)):
        raise TypeError('bad operand type')
    if x &gt;= 0:
        return x
    else:
        return -x
</code></pre>
<p>添加了参数检查后，如果传入错误的参数类型，函数就可以抛出一个错误：</p>
<pre><code>&gt;&gt;&gt; my_abs('A')
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;&lt;stdin&gt;&quot;, line 3, in my_abs
TypeError: bad operand type
</code></pre>
<h3 id="返回多个值">返回多个值</h3>
<p>函数可以返回多个值</p>
<pre><code>import math

def move(x, y, step, angle=0):
    nx = x + step * math.cos(angle)
    ny = y - step * math.sin(angle)
    return nx, ny
</code></pre>
<p>import math语句表示导入math包，并允许后续代码引用math包里的sin、cos等函数。</p>
<p>然后，我们就可以同时获得返回值：</p>
<pre><code>&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)
&gt;&gt;&gt; print(x, y)
151.96152422706632 70.0
</code></pre>
<p>但其实这只是一种假象，<strong>Python函数返回的仍然是单一值</strong>：</p>
<pre><code>&gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6)
&gt;&gt;&gt; print(r)
(151.96152422706632, 70.0)
</code></pre>
<p>返回值<strong>实际上是一个tuple</strong>，但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，<strong>按位置赋给对应的值</strong><br>
所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。</p>
<h2 id="函数的参数">函数的参数</h2>
<p>定义函数的时候，我们把参数的名字和位置确定下来，函数的接口定义就完成了。对于函数的调用者来说，只需要知道如何传递正确的参数，以及函数将返回什么样的值就够了，函数内部的复杂逻辑被封装起来，调用者无需了解。</p>
<p>Python的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用<strong>默认参数、可变参数和关键字参数</strong>，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。</p>
<h3 id="位置参数">位置参数</h3>
<p>对于func(x)函数，参数x就是一个位置参数。<br>
当我们调用func函数时，必须传入有且仅有的一个参数x<br>
调用函数时，传入的值按照位置顺序依次赋给参数x，所以叫做位置参数</p>
<h3 id="默认参数">默认参数</h3>
<p>如果希望定义新的函数定义，但是希望避免因为缺少一个参数而无法正常调用旧的调用代码，可以增加了一个默认参数</p>
<pre><code>def power(x, n=2):
    s = 1
    while n &gt; 0:
        n = n - 1
        s = s * x
    return s
</code></pre>
<p>设置默认参数时，有几点要注意：</p>
<ol>
<li>
<p><strong>必选参数在前，默认参数在后</strong>，否则Python的解释器会报错</p>
</li>
<li>
<p>如何设置默认参数。<br>
当函数有多个参数时，把<strong>变化大的参数放前面</strong>，<strong>变化小的参数放后面</strong>。变化小的参数就可以作为默认参数。<br>
使用默认参数最大的好处是能<strong>降低调用函数的难度</strong>。</p>
</li>
</ol>
<p>有多个默认参数时，调用的时候，既可以按顺序提供默认参数，比如调用<code>enroll('Bob', 'M', 7)</code><br>
也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。比如调用<code>enroll('Adam', 'M', city='Tianjin')</code></p>
<p>默认参数很有用，但使用不当，也会掉坑里。默认参数有个最大的坑，</p>
<p>先定义一个函数，传入一个list，添加一个END再返回：</p>
<pre><code>def add_end(L=[]):
    L.append('END')
    return L
</code></pre>
<p>当你使用默认参数调用时，一开始结果也是对的：</p>
<pre><code>&gt;&gt;&gt; add_end()
['END']
</code></pre>
<p>但是，再次调用add_end()时，结果就不对了：</p>
<pre><code>&gt;&gt;&gt; add_end()
['END', 'END']
&gt;&gt;&gt; add_end()
['END', 'END', 'END']
</code></pre>
<p>默认参数虽然是[]，但是函数似乎每次都“记住了”上次添加了'END'后的list。</p>
<p>原因解释如下：</p>
<p>Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为<strong>默认参数L也是一个变量，它指向对象[]</strong>，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。</p>
<p><strong>定义默认参数要牢记一点：默认参数必须指向不变对象！</strong></p>
<p>要修改上面的例子，我们可以用None这个不变对象来实现：</p>
<pre><code>def add_end(L=None):
    if L is None:
        L = []
    L.append('END')
    return L
</code></pre>
<p>现在，无论调用多少次，都不会有问题：</p>
<pre><code>&gt;&gt;&gt; add_end()
['END']
&gt;&gt;&gt; add_end()
['END']
</code></pre>
<p>这就是设计str、None这样的不变对象的原因，因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。<br>
此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。</p>
<h3 id="可变参数">可变参数</h3>
<p>在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。</p>
<pre><code>def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum
</code></pre>
<p>定义可变参数和定义一个list或tuple参数相比，<strong>仅仅在参数前面加了一个*号</strong>。在函数内部，<strong>参数numbers接收到的是一个tuple</strong>，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，<strong>包括0个参</strong>数：</p>
<pre><code>&gt;&gt;&gt; calc(1, 2)
5
&gt;&gt;&gt; calc()
0
</code></pre>
<p>如果已经有一个list或者tuple，要调用一个可变参数，可以在list或tuple前面加一个<code>*</code>号，把list或tuple的元素变成可变参数传进去：</p>
<pre><code>&gt;&gt;&gt; nums = [1, 2, 3]
&gt;&gt;&gt; calc(*nums)
14
</code></pre>
<p><code>*nums</code>表示把nums这个list的所有元素作为可变参数传进去。</p>
<h3 id="关键字参数">关键字参数</h3>
<p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时<strong>自动组装为一个tuple</strong>。<br>
而关键字参数允许你传入<strong>0个或任意个</strong>含参数名的参数，这些关键字参数在函数内部<strong>自动组装为一个dict</strong>。</p>
<pre><code>def person(name, age, **kw):
    print('name:', name, 'age:', age, 'other:', kw)
</code></pre>
<p>函数person除了必选参数name和age外，还接受关键字参数kw。在调用该函数时，可以只传入必选参数：</p>
<pre><code>&gt;&gt;&gt; person('Michael', 30)
name: Michael age: 30 other: {}
</code></pre>
<p>也可以传入任意个数的关键字参数：</p>
<pre><code>&gt;&gt;&gt; person('Bob', 35, city='Beijing')
name: Bob age: 35 other: {'city': 'Beijing'}
&gt;&gt;&gt; person('Adam', 45, gender='M', job='Engineer')
name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}
</code></pre>
<p><strong>关键字参数可以扩展函数的功能</strong>。<br>
比如，在person函数里，我们保证能接收到name和age这两个参数，但是，<strong>如果调用者愿意提供更多的参数，我们也能收到</strong>。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。</p>
<p>和可变参数类似，<strong>也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去</strong></p>
<pre><code>&gt;&gt;&gt; extra = {'city': 'Beijing', 'job': 'Engineer'}
&gt;&gt;&gt; person('Jack', 24, city=extra['city'], job=extra['job'])
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
</code></pre>
<p>当然，上面复杂的调用可以用简化的写法：</p>
<pre><code>&gt;&gt;&gt; extra = {'city': 'Beijing', 'job': 'Engineer'}
&gt;&gt;&gt; person('Jack', 24, **extra)
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
</code></pre>
<p><code>**extra</code>表示把extra这个dict的所有key-value用关键字参数传入到函数的<code>**kw</code>参数，kw将获得一个dict，<strong>注意kw获得的dict是extra的一份拷贝</strong>，<strong>对kw的改动不会影响到函数外的extra</strong>。</p>
<h3 id="命名关键字参数">命名关键字参数</h3>
<p>对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过kw检查。</p>
<p>如果<strong>要限制关键字参数的名</strong>字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：</p>
<pre><code>def person(name, age, *, city, job):
    print(name, age, city, job)
</code></pre>
<p>和关键字参数<code>**kw</code>不同，命名关键字参数需要一个特殊分隔符<code>*</code>，<code>*</code>后面的参数被视为<strong>命名关键字参数</strong>。</p>
<p>如果函数定义中<strong>已经有了一个可变参数</strong>，<strong>后面跟着的命名关键字参数就不再需要一个特殊分隔符<code>*</code>了</strong>：</p>
<pre><code>def person(name, age, *args, city, job):
    print(name, age, args, city, job)
</code></pre>
<p><strong>命名关键字参数必须传入参数名</strong>，这和位置参数不同。<strong>如果没有传入参数名，调用将报错</strong>：</p>
<pre><code>&gt;&gt;&gt; person('Jack', 24, 'Beijing', 'Engineer')
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: person() takes 2 positional arguments but 4 were given
</code></pre>
<p>由于调用时缺少参数名city和job，Python解释器把这4个参数均视为位置参数，但person()函数仅接受2个位置参数。</p>
<p><strong>命名关键字参数可以有缺省值</strong>，从而简化调用：</p>
<pre><code>def person(name, age, *, city='Beijing', job):
    print(name, age, city, job)
</code></pre>
<p>由于<strong>命名关键字参数city具有默认值，调用时，可不传入city参数</strong>：</p>
<pre><code>&gt;&gt;&gt; person('Jack', 24, job='Engineer')
Jack 24 Beijing Engineer
</code></pre>
<p>使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个<code>*</code>作为特殊分隔符。如果缺少<code>*</code>，Python解释器将<strong>无法识别位置参数和命名关键字参数</strong>：</p>
<pre><code>def person(name, age, city, job):
    # 缺少 *，city和job被视为位置参数
    pass
</code></pre>
<h3 id="参数组合">参数组合</h3>
<p>在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，<strong>参数定义的顺序</strong>必须是：</p>
<ol>
<li>必选参数</li>
<li>默认参数</li>
<li>可变参数</li>
<li>命名关键字参数</li>
<li>关键字参数</li>
</ol>
<p>比如定义一个函数，包含上述若干种参数：</p>
<pre><code>def f1(a, b, c=0, *args, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)

def f2(a, b, c=0, *, d, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw)
</code></pre>
<p>在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。</p>
<pre><code>&gt;&gt;&gt; f1(1, 2)
a = 1 b = 2 c = 0 args = () kw = {}
&gt;&gt;&gt; f1(1, 2, c=3)
a = 1 b = 2 c = 3 args = () kw = {}
&gt;&gt;&gt; f1(1, 2, 3, 'a', 'b')
a = 1 b = 2 c = 3 args = ('a', 'b') kw = {}
&gt;&gt;&gt; f1(1, 2, 3, 'a', 'b', x=99)
a = 1 b = 2 c = 3 args = ('a', 'b') kw = {'x': 99}
&gt;&gt;&gt; f2(1, 2, d=99, ext=None)
a = 1 b = 2 c = 0 d = 99 kw = {'ext': None}
</code></pre>
<p><strong>最神奇的是通过一个tuple和dict，也可以调用上述函数</strong>：</p>
<pre><code>&gt;&gt;&gt; args = (1, 2, 3, 4)
&gt;&gt;&gt; kw = {'d': 99, 'x': '#'}
&gt;&gt;&gt; f1(*args, **kw)
a = 1 b = 2 c = 3 args = (4,) kw = {'d': 99, 'x': '#'}
&gt;&gt;&gt; args = (1, 2, 3)
&gt;&gt;&gt; kw = {'d': 88, 'x': '#'}
&gt;&gt;&gt; f2(*args, **kw)
a = 1 b = 2 c = 3 d = 88 kw = {'x': '#'}
</code></pre>
<p>所以，<strong>对于任意函数，都可以通过类似<code>func(*args, **kw)</code>的形式调用它，无论它的参数是如何定义的。</strong></p>
<p>虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。</p>
<h3 id="小结">小结</h3>
<p>Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。</p>
<p>默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！</p>
<p>要注意定义可变参数和关键字参数的语法：</p>
<p><code>*args</code>是可变参数，args接收的是一个tuple；</p>
<p><code>**kw</code>是关键字参数，kw接收的是一个dict。</p>
<p>以及调用函数时如何传入可变参数和关键字参数的语法：</p>
<p>可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过<code>*args</code>传入：<code>func(*(1, 2, 3))</code>；</p>
<p>关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过<code>**kw</code>传入：<code>func(**{'a': 1, 'b': 2})</code>。</p>
<p>使用<code>*args</code>和<code>**kw</code>是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。</p>
<p>命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。</p>
<p>定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。</p>
<h2 id="递归函数">递归函数</h2>
<p>在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。</p>
<p>来计算阶乘n! = 1 x 2 x 3 x ... x n，用函数fact(n)表示，可以看出：</p>
<p>fact(n) = n! = 1 x 2 x 3 x ... x (n-1) x n = (n-1)! x n = fact(n-1) x n</p>
<p>所以，fact(n)可以表示为n x fact(n-1)，只有n=1时需要特殊处理。</p>
<p>于是，fact(n)用递归的方式写出来就是：</p>
<pre><code>def fact(n):
    if n==1:
        return 1
    return n * fact(n - 1)
</code></pre>
<p>递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。</p>
<p>使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。</p>
<p><strong>解决递归调用栈溢出的方法是通过尾递归优化</strong>，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。</p>
<p>尾递归是指，<strong>在函数返回的时候，调用自身本身</strong>，并且，r<strong>eturn语句不能包含表达式</strong>。这样，<strong>编译器或者解释器就可以把尾递归做优化</strong>，使递归本身无论调用多少次，<strong>都只占用一个栈帧</strong>，不会出现栈溢出的情况。</p>
<p>上面的fact(n)函数由于return n * fact(n - 1)引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：</p>
<pre><code>def fact(n):
    return fact_iter(n, 1)

def fact_iter(num, product):
    if num == 1:
        return product
    return fact_iter(num - 1, num * product)
</code></pre>
<p><code>return fact_iter(num - 1, num * product)</code>仅返回递归函数本身，<code>num - 1</code>和<code>num * product</code>在函数调用前就会被计算，不影响函数调用。</p>
<p>尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。</p>
<p>遗憾的是，大多数编程语言没有针对尾递归做优化，Python标准的解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Python-哈希容器dict和set]]></title>
        <id>https://lixin-scut.github.io//post/python-ha-xi-rong-qi-dict-he-set</id>
        <link href="https://lixin-scut.github.io//post/python-ha-xi-rong-qi-dict-he-set">
        </link>
        <updated>2020-05-08T06:54:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="dict">dict</h2>
<p>Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。</p>
<p><strong>dict使用大括号初始化</strong></p>
<p>“名字”-“成绩”的对照表：</p>
<pre><code>&gt;&gt;&gt; d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}
&gt;&gt;&gt; d['Michael']
95
</code></pre>
<p>key-value存储方式，在放进去的时候，必须根据key算出value的存放位置，这样，取的时候才能根据key直接拿到value。</p>
<h3 id="元素操作">元素操作</h3>
<p>把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：</p>
<pre><code>&gt;&gt;&gt; d['Adam'] = 67
&gt;&gt;&gt; d['Adam']
67
</code></pre>
<p>由于一个key只能对应一个value，所以，<strong>多次对一个key放入value，后面的值会把前面的值冲掉</strong>：</p>
<pre><code>&gt;&gt;&gt; d['Jack'] = 90
&gt;&gt;&gt; d['Jack']
90
&gt;&gt;&gt; d['Jack'] = 88
&gt;&gt;&gt; d['Jack']
88
</code></pre>
<p><strong>如果key不存在，dict就会报错</strong>：</p>
<pre><code>&gt;&gt;&gt; d['Thomas']
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
KeyError: 'Thomas'
</code></pre>
<p>要避免key不存在的错误，有两种办法，一是<strong>通过in判断key是否存在</strong>：</p>
<blockquote>
<blockquote>
<blockquote>
<p>'Thomas' in d<br>
False<br>
二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的value：</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>d.get('Thomas')<br>
d.get('Thomas', -1)<br>
-1</p>
</blockquote>
</blockquote>
</blockquote>
<pre><code>注意：返回None的时候Python的交互环境不显示结果。
</code></pre>
<p>要删除一个key，用pop(key)方法，对应的value也会从dict中删除：</p>
<blockquote>
<blockquote>
<blockquote>
<p>d.pop('Bob')<br>
75</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>d<br>
{'Michael': 95, 'Tracy': 85}<br>
请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。</p>
</blockquote>
</blockquote>
</blockquote>
<p>和list比较，dict有以下几个特点：</p>
<ol>
<li>查找和插入的速度极快，不会随着key的增加而变慢；</li>
<li>需要<strong>占用大量的内存，内存浪费多</strong>。</li>
</ol>
<p>而list相反：</p>
<ol>
<li>查找和插入的时间随着元素的增加而增加；</li>
<li>占用空间小，浪费内存很少。<br>
所以，dict是用空间来换取时间的一种方法。</li>
</ol>
<p>dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是<strong>dict的key必须是不可变对象</strong>。</p>
<p>这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。</p>
<p>要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而<strong>list是可变的，就不能作为key</strong>：</p>
<pre><code>&gt;&gt;&gt; key = [1, 2, 3]
&gt;&gt;&gt; d[key] = 'a list'
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: unhashable type: 'list'
</code></pre>
<h2 id="set">set</h2>
<p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。</p>
<p>要创建一个set，需要提供一个list作为输入集合：</p>
<p><strong>set的初始化需要注明set()</strong></p>
<pre><code>&gt;&gt;&gt; s = set([1, 2, 3])
&gt;&gt;&gt; s
{1, 2, 3}
</code></pre>
<p>注意，<strong>传入的参数[1, 2, 3]是一个list</strong></p>
<p>由于哈希函数的原因，而显示的{1, 2, 3}只是告诉你这个set内部有1，2，3这3个元素，<strong>显示的顺序也不表示set是有序的</strong>。</p>
<p><strong>重复元素在set中自动被过滤</strong>：</p>
<pre><code>&gt;&gt;&gt; s = set([1, 1, 2, 2, 3, 3])
&gt;&gt;&gt; s
{1, 2, 3}
</code></pre>
<p><strong>添加元素add(key)</strong><br>
通过add(key)方法可以添加元素到set中，<strong>可以重复添加，但不会有效果</strong>：</p>
<pre><code>&gt;&gt;&gt; s.add(4)
&gt;&gt;&gt; s
{1, 2, 3, 4}
&gt;&gt;&gt; s.add(4)
&gt;&gt;&gt; s
{1, 2, 3, 4}
</code></pre>
<p><strong>删除元素remove(key)</strong><br>
通过remove(key)方法可以删除元素：</p>
<pre><code>&gt;&gt;&gt; s.remove(4)
&gt;&gt;&gt; s
{1, 2, 3}
</code></pre>
<p>set可以看成数学意义上的<strong>无序和无重复元素的集合</strong>，因此，两个set可以做<strong>数学意义上的交集、并集</strong>等操作：</p>
<pre><code>&gt;&gt;&gt; s1 = set([1, 2, 3])
&gt;&gt;&gt; s2 = set([2, 3, 4])
&gt;&gt;&gt; s1 &amp; s2
{2, 3}
&gt;&gt;&gt; s1 | s2
{1, 2, 3, 4}
</code></pre>
<p>set和dict的唯一区别仅在于没有存储对应的value，</p>
<p>但是，set的原理和dict一样，所以，<strong>同样不可以放入可变对象，因为无法判断两个可变对象是否相等</strong>，也就<strong>无法保证set内部“不会有重复元素”</strong>。</p>
<h2 id="不可变对象">不可变对象</h2>
<p>str是不变对象，而list是可变对象。</p>
<p>对于可变对象，比如list，对list进行操作，list内部的内容是会变化的，比如：</p>
<pre><code>&gt;&gt;&gt; a = ['c', 'b', 'a']
&gt;&gt;&gt; a.sort()
&gt;&gt;&gt; a
['a', 'b', 'c']
</code></pre>
<p>而对于不可变对象，比如str，对str进行操作呢：</p>
<pre><code>&gt;&gt;&gt; a = 'abc'
&gt;&gt;&gt; a.replace('a', 'A')
'Abc'
&gt;&gt;&gt; a
'abc'
</code></pre>
<p>虽然字符串有个replace()方法，也确实变出了<code>'Abc'</code>，但变量a最后仍是<code>'abc'</code></p>
<p>要始终牢记的是，<strong>a是变量，而'abc'才是字符串对象</strong>！<br>
有些时候，我们经常说，对象a的内容是'abc'，但其实是指，a本身是一个变量，它指向的对象的内容才是'abc'</p>
<p>当我们调用<code>a.replace('a', 'A')</code>时，实际上调用方法replace是<strong>作用在字符串对象'abc'上的</strong>，而这个方法虽然名字叫replace，但却没有改变字符串'abc'的内容。相反，replace方法<strong>创建了一个新字符串'Abc'并返回</strong>，如果我们用变量b指向该新字符串，就容易理解了，变量a仍指向原有的字符串'abc'，但变量b却指向新字符串'Abc'了：</p>
<p>所以，对于不变对象来说，<strong>调用对象自身的任意方法，也不会改变该对象自身的内容</strong>。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python-条件语句与循环语句]]></title>
        <id>https://lixin-scut.github.io//post/python-tiao-jian-yu-ju-yu-xun-huan-yu-ju</id>
        <link href="https://lixin-scut.github.io//post/python-tiao-jian-yu-ju-yu-xun-huan-yu-ju">
        </link>
        <updated>2020-05-08T03:12:44.000Z</updated>
        <content type="html"><![CDATA[<h3 id="条件判断">条件判断</h3>
<p>做条件判断在Python程序中，用if语句实现</p>
<p><strong>if语句的完整形式</strong>就是：</p>
<pre><code>if &lt;条件判断1&gt;:
    &lt;执行1&gt;
elif &lt;条件判断2&gt;:
    &lt;执行2&gt;
elif &lt;条件判断3&gt;:
    &lt;执行3&gt;
else:
    &lt;执行4&gt;
</code></pre>
<p>例子：</p>
<pre><code>age = 20
if age &gt;= 18:
    print('your age is', age)
    print('adult')
</code></pre>
<p>根据Python的缩进规则，如果if语句判断是True，就把缩进的两行print语句执行了，否则，什么也不做。</p>
<p>也可以给if添加一个<strong>else语句</strong>，意思是，如果if判断是False，不要执行if的内容，去把else执行了：</p>
<pre><code>age = 3
if age &gt;= 18:
    print('your age is', age)
    print('adult')
else:
    print('your age is', age)
    print('teenager')
</code></pre>
<p>注意<strong>不要少写了冒号:</strong>。</p>
<p>当然上面的判断是很粗略的，完全可以<strong>用elif做更细致的判断</strong>：</p>
<pre><code>age = 3
if age &gt;= 18:
    print('adult')
elif age &gt;= 6:
    print('teenager')
else:
    print('kid')
</code></pre>
<p>elif是else if的缩写，完全可以有多个elif</p>
<p>if判断条件还可以简写，比如写：</p>
<pre><code>if x:
    print('True')
</code></pre>
<p>只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False。</p>
<h3 id="if中的input与类型转换">if中的input与类型转换</h3>
<p>当我们希望用input()读取用户的输入，再进行判断时，容易出现类型问题：</p>
<pre><code>birth = input('birth: ')
if birth &lt; 2000:
    print('00前')
else:
    print('00后')
</code></pre>
<p>输入1982，结果报错：</p>
<pre><code>Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: unorderable types: str() &gt; int()
</code></pre>
<p>这是<strong>因为input()返回的数据类型是str</strong>，<strong>str不能直接和整数比较</strong></p>
<p>必须先把str转换成整数。Python提供了<strong>int()函数</strong>来完成这件事情：</p>
<pre><code>s = input('birth: ')
birth = int(s)
if birth &lt; 2000:
    print('00前')
else:
    print('00后')
</code></pre>
<p>再次运行，就可以得到正确地结果。但是，如果输入abc呢？又会得到一个错误信息：</p>
<pre><code>Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
ValueError: invalid literal for int() with base 10: 'abc'
</code></pre>
<p>int()函数发现一个字符串并不是合法的数字时就会报错，程序就退出了。</p>
<h2 id="循环">循环</h2>
<h3 id="for-x-in">for x in ...</h3>
<p>for x in ...循环就是把每个元素代入变量x，然后执行缩进块的语句。</p>
<pre><code>比如我们想计算1-100的整数之和，可以用一个sum变量做累加，Python提供一个range()函数，可以生成一个整数序列，：
</code></pre>
<pre><code>sum = 0
# for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ..., 100]:
for x in range(100):
    sum = sum + x
print(sum)
</code></pre>
<p>range()函数再通过list()函数可以转换为list。比如range(5)生成的序列是从0开始小于5的整数</p>
<pre><code>&gt;&gt;&gt; list(range(5))
[0, 1, 2, 3, 4]
</code></pre>
<h3 id="while循环">while循环</h3>
<p>只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：</p>
<pre><code>sum = 0
n = 99
while n &gt; 0:
    sum = sum + n
    n = n - 2
print(sum)
</code></pre>
<p>在循环内部变量n不断自减，直到变为-1时，不再满足while条件，循环退出。</p>
<h3 id="break">break</h3>
<p>在循环中，break语句可以提前退出循环。</p>
<pre><code>n = 1
while n &lt;= 100:
    if n &gt; 10: # 当n = 11时，条件满足，执行break语句
        break # break语句会结束当前循环
    print(n)
    n = n + 1
print('END')
</code></pre>
<h3 id="continue">continue</h3>
<p>在循环过程中，也可以通过continue语句，跳过当前的这次循环，直接开始下一次循环。</p>
<pre><code>n = 0
while n &lt; 10:
    n = n + 1
    if n % 2 == 0: # 如果n是偶数，执行continue语句
        continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行
    print(n)
</code></pre>
<h3 id="小结">小结</h3>
<p>循环是让计算机做重复任务的有效的方法。</p>
<p>break语句可以在循环过程中直接退出循环，而continue语句可以提前结束本轮循环，并直接开始下一轮循环。这两个语句通常都必须配合if语句使用。</p>
<p>要特别注意，<strong>不要滥用break和continue语句</strong>。break和continue会造成代码执行逻辑分叉过多，容易出错。<strong>大多数循环并不需要用到break和continue语句</strong>，上面的两个例子，都可以<strong>通过改写循环条件或者修改循环逻辑，去掉break和continue语句</strong>。</p>
<p>有些时候，如果代码写得有问题，会让程序陷入“死循环”，也就是永远循环下去。这时可以用Ctrl+C退出程序，或者强制结束Python进程。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Python-使用list和tuple]]></title>
        <id>https://lixin-scut.github.io//post/python-shi-yong-list-he-tuple</id>
        <link href="https://lixin-scut.github.io//post/python-shi-yong-list-he-tuple">
        </link>
        <updated>2020-05-08T02:32:29.000Z</updated>
        <content type="html"><![CDATA[<h2 id="list">list</h2>
<p>Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。</p>
<h3 id="list初始化与赋值"><strong>list初始化与赋值</strong></h3>
<p>比如，列出班里所有同学的名字，就可以用一个list表示：</p>
<pre><code>&gt;&gt;&gt; classmates = ['Michael', 'Bob', 'Tracy']
&gt;&gt;&gt; classmates
['Michael', 'Bob', 'Tracy']
</code></pre>
<h3 id="list长度len"><strong>list长度：len()</strong></h3>
<p>变量classmates就是一个list。<strong>用len()函数可以获得list元素的个数</strong>：</p>
<pre><code>&gt;&gt;&gt; len(classmates)
3
</code></pre>
<h3 id="元素增删查改">元素增删查改</h3>
<p><strong>list的索引访问</strong><br>
用索引来访问list中每一个位置的元素，记得索引是从0开始的：</p>
<pre><code>&gt;&gt;&gt; classmates[0]
'Michael'
&gt;&gt;&gt; classmates[1]
'Bob'
&gt;&gt;&gt; classmates[2]
'Tracy'
&gt;&gt;&gt; classmates[3]
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
IndexError: list index out of range
</code></pre>
<p>当索引超出了范围时，Python会报一个IndexError错误，所以，要确保索引不要越界，<br>
最后一个元素的索引是len(classmates) - 1。</p>
<h3 id="负数索引"><strong>负数索引</strong></h3>
<p>如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素：</p>
<pre><code>&gt;&gt;&gt; classmates[-1]
'Tracy'
</code></pre>
<p>以此类推，可以获取倒数第2个、倒数第3个：</p>
<pre><code>&gt;&gt;&gt; classmates[-2]
'Bob'
&gt;&gt;&gt; classmates[-3]
'Michael'
&gt;&gt;&gt; classmates[-4]
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
IndexError: list index out of range
</code></pre>
<p>注意倒数索引也会越界</p>
<p><strong>append()</strong>:list是一个可变的有序表，所以，可以往list中追加元素到末尾：</p>
<pre><code>&gt;&gt;&gt; classmates.append('Adam')
&gt;&gt;&gt; classmates
['Michael', 'Bob', 'Tracy', 'Adam']
</code></pre>
<p><strong>insert()</strong>:也可以把元素插入到指定的位置，比如索引号为1的位置：</p>
<pre><code>&gt;&gt;&gt; classmates.insert(1, 'Jack')
&gt;&gt;&gt; classmates
['Michael', 'Jack', 'Bob', 'Tracy', 'Adam']
</code></pre>
<p><strong>pop()</strong>:要删除list末尾的元素，用pop()方法：</p>
<pre><code>&gt;&gt;&gt; classmates.pop()
'Adam'
&gt;&gt;&gt; classmates
['Michael', 'Jack', 'Bob', 'Tracy']
</code></pre>
<p><strong>pop(i)</strong>:要删除指定位置的元素，用pop(i)方法，其中i是索引位置：</p>
<pre><code>&gt;&gt;&gt; classmates.pop(1)
'Jack'
&gt;&gt;&gt; classmates
['Michael', 'Bob', 'Tracy']
</code></pre>
<p><strong>赋值</strong>：要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：</p>
<pre><code>&gt;&gt;&gt; classmates[1] = 'Sarah'
&gt;&gt;&gt; classmates
['Michael', 'Sarah', 'Tracy']
</code></pre>
<p>list里面的<strong>元素的数据类型也可以不同</strong>，比如：</p>
<pre><code>&gt;&gt;&gt; L = ['Apple', 123, True]
</code></pre>
<h3 id="list嵌套">list嵌套</h3>
<p>ist元素中可以嵌套另一个list，比如：</p>
<pre><code>&gt;&gt;&gt; s = ['python', 'java', ['asp', 'php'], 'scheme']
&gt;&gt;&gt; len(s)
4
</code></pre>
<p>要注意s只有4个元素，其中s[2]又是一个list</p>
<p><strong>同时注意可以直接用list名进行list嵌套</strong></p>
<pre><code>&gt;&gt;&gt; p = ['asp', 'php']
&gt;&gt;&gt; s = ['python', 'java', p, 'scheme'] 
</code></pre>
<p><strong>多维索引</strong><br>
要拿到'php'可以写p[1]或者s[2][1]，因此s可以看成是一个二维数组，类似的还有三维、四维……数组。</p>
<h3 id="空list"><strong>空list</strong></h3>
<p>如果一个list中一个元素也没有，就是一个空的list，它的长度为0：</p>
<pre><code>&gt;&gt;&gt; L = []
&gt;&gt;&gt; len(L)
0
</code></pre>
<h2 id="tuple">tuple</h2>
<p>另一种有序列表叫元组：tuple。tuple和list非常类似，<strong>但是tuple一旦初始化就不能修改</strong></p>
<p><strong>tuple使用小括号定义，list使用中括号定义</strong></p>
<p>tuple没有<strong>append()，insert()</strong> 这样的方法，但也不能赋值成另外的元素。<br>
其他获取元素的方法和list是一样的，可以正常地使用classmates[0]，classmates[-1]，但</p>
<p>不可变的tuple的意义：因为<strong>tuple不可变，所以代码更安全</strong>。<br>
<strong>如果可能，能用tuple代替list就尽量用tuple。</strong></p>
<p><strong>定义tuple</strong><br>
tuple的陷阱：当你定义一个tuple时，<strong>在定义的时候，tuple的元素就必须被确定下来，</strong> 比如：</p>
<pre><code>&gt;&gt;&gt; t = (1, 2)
&gt;&gt;&gt; t
(1, 2)
</code></pre>
<p><strong>定义一个空的tuple</strong><br>
如果要定义一个空的tuple，可以写成()：</p>
<pre><code>&gt;&gt;&gt; t = ()
&gt;&gt;&gt; t
()
</code></pre>
<p><strong>定义一个只有1个元素的tuple</strong><br>
但是，要定义一个只有1个元素的tuple，如果你这么定义：</p>
<pre><code>&gt;&gt;&gt; t = (1)
&gt;&gt;&gt; t
1
</code></pre>
<p><strong>定义的不是tuple，是1这个数！</strong><br>
<strong>注意，变成了一个整数！</strong></p>
<p>这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，<strong>Python规定，这种情况下，按小括号进行计算，计算结果自然是1</strong>。</p>
<p>所以，<strong>只有1个元素的tuple定义时必须加一个逗号<code>,</code>，来消除歧义</strong>：</p>
<pre><code>&gt;&gt;&gt; t = (1,)
&gt;&gt;&gt; t
(1,)
</code></pre>
<p>Python在显示只有1个元素的tuple时，也会加一个逗号,，以免你误解成数学计算意义上的括号。</p>
<p><strong>“可变的”tuple</strong></p>
<pre><code>&gt;&gt;&gt; t = ('a', 'b', ['A', 'B'])
&gt;&gt;&gt; t[2][0] = 'X'
&gt;&gt;&gt; t[2][1] = 'Y'
&gt;&gt;&gt; t
('a', 'b', ['X', 'Y'])
</code></pre>
<p>这个tuple定义的时候有3个元素，分别是'a'，'b'和一个list。</p>
<p>表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。tuple一开始指向的list并没有改成别的list<br>
<strong>所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变</strong>。即指向'a'，就不能改成指向'b'，指向一个list，就不能改成指向其他对象，<strong>但指向的这个list本身是可变的</strong>！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python-字符串和编码]]></title>
        <id>https://lixin-scut.github.io//post/python-zi-fu-chuan-he-bian-ma</id>
        <link href="https://lixin-scut.github.io//post/python-zi-fu-chuan-he-bian-ma">
        </link>
        <updated>2020-05-08T02:04:56.000Z</updated>
        <content type="html"><![CDATA[<h3 id="字符编码">字符编码</h3>
<p>字符串也是一种数据类型，但是，字符串比较特殊的是还有一个编码问题。</p>
<p>因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是65535，4个字节可以表示的最大整数是4294967295。</p>
<p>由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。</p>
<p>但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。</p>
<p>全世界有上百种语言，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。</p>
<p>因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。</p>
<h3 id="unicode">Unicode</h3>
<p>Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。</p>
<p>ASCII编码和Unicode编码的区别：<strong>ASCII编码是1个字节</strong>，而<strong>Unicode编码通常是2个字节</strong>。</p>
<p>新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。</p>
<p>所以又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。<strong>UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节</strong>，常用的<strong>英文字母被编码成1个字节</strong>，<strong>汉字通常是3个字节</strong>，只有<strong>很生僻的字符才会被编码成4-6个字节</strong>。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间</p>
<p>UTF-8编码有一个额外的好处，就是兼容性，<strong>ASCII编码实际上可以被看成是UTF-8编码的一部分</strong>，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作</p>
<p>现在计算机系统通用的字符编码工作方式：</p>
<ol>
<li>
<p>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。</p>
</li>
<li>
<p>用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件</p>
</li>
</ol>
<h3 id="python的字符串">Python的字符串</h3>
<p>在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言，可以直接print中文</p>
<p>对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符：</p>
<pre><code>&gt;&gt;&gt; ord('A')
65
&gt;&gt;&gt; ord('中')
20013
&gt;&gt;&gt; chr(66)
'B'
&gt;&gt;&gt; chr(25991)
'文'
</code></pre>
<p>如果知道字符的整数编码，还可以用十六进制这么写str：</p>
<pre><code>&gt;&gt;&gt; '\u4e2d\u6587'
'中文'
两种写法完全是等价的。
</code></pre>
<p>由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。</p>
<p>Python对bytes类型的数据用带b前缀的单引号或双引号表示：</p>
<pre><code>x = b'ABC'
</code></pre>
<p>要注意区分'ABC'和b'ABC'，前者是str，后者虽然内容显示得和前者一样，但<strong>bytes的每个字符都只占用一个字节</strong>。</p>
<p>以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如：</p>
<pre><code>&gt;&gt;&gt; 'ABC'.encode('ascii')
b'ABC'
&gt;&gt;&gt; '中文'.encode('utf-8')
b'\xe4\xb8\xad\xe6\x96\x87'
&gt;&gt;&gt; '中文'.encode('ascii')
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)
</code></pre>
<p>纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。</p>
<pre><code>&gt;&gt;&gt; b'ABC'.decode('ascii')
'ABC'
&gt;&gt;&gt; b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8')
'中文'
</code></pre>
<p>如果bytes中包含无法解码的字节，decode()方法会报错<br>
如果bytes中只有一小部分无效的字节，可以传入errors='ignore'忽略错误的字节</p>
<p>要计算<strong>str包含多少个字符</strong>，可以用<strong>len()函数</strong>：</p>
<pre><code>&gt;&gt;&gt; len('ABC')
3
&gt;&gt;&gt; len('中文')
2
</code></pre>
<p>len()函数计算的是str的字符数，如果<strong>换成bytes，len()函数就计算字节数</strong>：</p>
<pre><code>&gt;&gt;&gt; len(b'ABC')
3
&gt;&gt;&gt; len(b'\xe4\xb8\xad\xe6\x96\x87')
6
&gt;&gt;&gt; len('中文'.encode('utf-8'))
6
</code></pre>
<p>可见，1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。</p>
<p>在操作字符串时，我们经常遇到str和bytes的互相转换。为了避免乱码问题，应当<strong>始终坚持使用UTF-8编码对str和bytes进行转换</strong>。</p>
<p>由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，<strong>在保存源代码时，就需要务必指定保存为UTF-8编码</strong>。</p>
<p>当Python解释器读取源代码时，<strong>为了让它按UTF-8编码读取，我们通常在文件开头写上这两行</strong>：</p>
<pre><code>#!/usr/bin/env python3
# -*- coding: utf-8 -*-
</code></pre>
<p>第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；</p>
<p>第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。</p>
<p>申明了UTF-8编码<strong>并不意味着你的.py文件就是UTF-8编码的</strong>，必须并且<strong>要确保文本编辑器正在使用UTF-8 without BOM编码</strong></p>
<h3 id="字符串格式化">字符串格式化</h3>
<p>在Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下：</p>
<pre><code>&gt;&gt;&gt; 'Hello, %s' % 'world'
'Hello, world'
&gt;&gt;&gt; 'Hi, %s, you have $%d.' % ('Michael', 1000000)
'Hi, Michael, you have $1000000.'
</code></pre>
<p>在字符串内部，%s表示用字符串替换，%d表示用整数替换<br>
<strong>有几个%?占位符，后面就跟几个变量或者值</strong>，顺序要对应好。<br>
<strong>如果只有一个%?，括号可以省略</strong>。</p>
<p>常见的占位符有：</p>
<table>
<thead>
<tr>
<th style="text-align:center">占位符</th>
<th style="text-align:center">替换内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">%d</td>
<td style="text-align:center">整数</td>
</tr>
<tr>
<td style="text-align:center">%f</td>
<td style="text-align:center">浮点数</td>
</tr>
<tr>
<td style="text-align:center">%s</td>
<td style="text-align:center">字符串</td>
</tr>
<tr>
<td style="text-align:center">%x</td>
<td style="text-align:center">十六进制整数</td>
</tr>
</tbody>
</table>
<p>其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数</p>
<pre><code>&gt;&gt;&gt; print('%2d-%02d' % (3, 1))
3-01 
&gt;&gt;&gt; print('%.2f' % 3.1415926)
3.14 
</code></pre>
<p>%s永远起作用，它会把<strong>任何数据类型转换为字符串</strong>：</p>
<pre><code>&gt;&gt;&gt; 'Age: %s. Gender: %s' % (25, True)
'Age: 25. Gender: True'
</code></pre>
<p>如果字符串里面的%是一个普通字符就需要转义，<strong>用%%来表示一个%</strong>：</p>
<pre><code>&gt;&gt;&gt; 'growth rate: %d %%' % 7
'growth rate: 7 %'
</code></pre>
<p><strong>format()</strong></p>
<p>另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……，不过这种方式写起来比%要麻烦得多：</p>
<blockquote>
<blockquote>
<blockquote>
<p>'Hello, {0}, 成绩提升了 {1:.1f}%'.format('小明', 17.125)<br>
'Hello, 小明, 成绩提升了 17.1%'</p>
</blockquote>
</blockquote>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python-语法与数据类型]]></title>
        <id>https://lixin-scut.github.io//post/python-ji-chu</id>
        <link href="https://lixin-scut.github.io//post/python-ji-chu">
        </link>
        <updated>2020-05-08T01:11:19.000Z</updated>
        <content type="html"><![CDATA[<h3 id="python语法">Python语法</h3>
<p>Python的语法比较简单，采用缩进方式</p>
<pre><code># print absolute value of an integer:
a = 100
if a &gt;= 0:
    print(a)
else:
    print(-a)
</code></pre>
<p><strong>注释</strong><br>
以#开头的语句是注释，注释是给人看的，可以是任意内容，解释器会忽略掉注释。</p>
<p><strong>锁进</strong><br>
除注释外其他每一行都是一个语句，当语句以冒号:结尾时，缩进的语句视为代码块。</p>
<p>缩进有利有弊。好处是强迫你写出格式化的代码，但没有规定缩进是几个空格还是Tab。按照约定俗成的惯例，应该始终坚持使用<strong>4个空格的缩进</strong>。</p>
<p>在文本编辑器中，<strong>需要设置把Tab自动转换为4个空格</strong>，确保不混用Tab和空格。</p>
<p>缩进的另一个好处是强迫你写出缩进较少的代码，你会倾向于把一段很长的代码拆分成若干函数，从而得到缩进较少的代码。</p>
<p><strong>缩进的坏处就是“复制－粘贴”功能失效了</strong>，这是最坑爹的地方。当你重构代码时，粘贴过去的代码必须重新检查缩进是否正确。此外，IDE很难像格式化Java代码那样格式化Python代码。</p>
<p>最后，请务必注意，<strong>Python程序是大小写敏感的</strong>，如果写错了大小写，程序会报错。</p>
<h3 id="数据类型">数据类型</h3>
<p><strong>整数</strong></p>
<p>Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。</p>
<p>计算机由于使用二进制，所以，有时候<strong>用十六进制表示整数比较方便</strong>，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。</p>
<p><strong>浮点数</strong></p>
<p>浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，<strong>一个浮点数的小数点位置是可变的</strong>，比如，1.23x109和12.3x108是完全相等的。浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。<br>
整数和浮点数在计算机内部存储的方式是不同的，<strong>整数运算永远是精确的（除法也是精确的），而浮点数运算则可能会有四舍五入的误差</strong>。</p>
<p><strong>字符串</strong></p>
<p>字符串是以 <strong>单引号'</strong> 或 <strong>双引号&quot;</strong> 括起来的任意文本，比如'abc'，&quot;xyz&quot;等等。请注意，''或&quot;&quot;本身只是一种表示方式，不是字符串的一部分，因此，字符串'abc'只有a，b，c这3个字符。如果'本身也是一个字符，那就可以用&quot;&quot;括起来，比如&quot;I'm OK&quot;包含的字符是I，'，m，空格，O，K这6个字符。</p>
<p>如果字符串内部既包含'又包含&quot;怎么办？可以<strong>用转义字符\来标识</strong>，比如：</p>
<pre><code>'I\'m \&quot;OK\&quot;!'
</code></pre>
<p>表示的字符串内容是：</p>
<pre><code>I'm &quot;OK&quot;!
</code></pre>
<p>转义字符\可以转义很多字符，比如\n表示换行，\t表示制表符，字符\本身也要转义，所以\表示的字符就是\，可以在Python的交互式命令行用print()打印字符串看看：</p>
<pre><code>&gt;&gt;&gt; print('I\'m ok.')
I'm ok.
&gt;&gt;&gt; print('I\'m learning\nPython.')
I'm learning
Python.
&gt;&gt;&gt; print('\\\n\\')
\
\
</code></pre>
<p>如果字符串里面有很多字符都需要转义，就需要加很多\，为了简化，Python还允许<strong>用<code>r''</code>表示<code>''</code>内部的字符串默认不转义</strong></p>
<p>如果字符串内部有很多换行，用\n写在一行里不好阅读，为了简化，Python允许<strong>用'''和...配合的格式表示多行内容</strong></p>
<p>当输入完结束符 ``` 和括号)后，执行该语句并打印结果。</p>
<p>如果写成程序并存为.py文件，就是：</p>
<pre><code>print('''line1
line2
line3''')
</code></pre>
<p>多行字符串'''...'''还可以在前面加上r使用</p>
<p><strong>布尔值</strong></p>
<p>布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来：</p>
<pre><code>&gt;&gt;&gt; True
True
&gt;&gt;&gt; False
False
&gt;&gt;&gt; 3 &gt; 2
True
&gt;&gt;&gt; 3 &gt; 5
False
</code></pre>
<p>布尔值可以用and、or和not运算。</p>
<p>and运算是与运算，只有所有都为True，and运算结果才是True：</p>
<pre><code>&gt;&gt;&gt; True and True
True
&gt;&gt;&gt; True and False
False
&gt;&gt;&gt; False and False
False
&gt;&gt;&gt; 5 &gt; 3 and 3 &gt; 1
True
</code></pre>
<p>or运算是或运算，只要其中有一个为True，or运算结果就是True：</p>
<pre><code>&gt;&gt;&gt; True or True
True
&gt;&gt;&gt; True or False
True
&gt;&gt;&gt; False or False
False
&gt;&gt;&gt; 5 &gt; 3 or 1 &gt; 3
True
</code></pre>
<p>not运算是非运算，它是一个单目运算符，把True变成False，False变成True：</p>
<pre><code>&gt;&gt;&gt; not True
False
&gt;&gt;&gt; not False
True
&gt;&gt;&gt; not 1 &gt; 2
True
</code></pre>
<p>布尔值经常用在条件判断中，比如：</p>
<pre><code>if age &gt;= 18:
    print('adult')
else:
    print('teenager')
</code></pre>
<p><strong>空值</strong></p>
<p>空值是Python里一个特殊的值，用None表示。<strong>None不能理解为0</strong>，因为0是有意义的，<strong>而None是一个特殊的空值</strong>。</p>
<p><strong>变量</strong></p>
<p>变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。</p>
<p>变量在程序中就是用一个变量名表示了，变量名必须是<strong>大小写英文、数字和_的组合，且不能用数字开头</strong></p>
<pre><code>a = 1
</code></pre>
<p>变量a是一个整数。</p>
<pre><code>t_007 = 'T007'
</code></pre>
<p>变量t_007是一个<strong>字符串</strong>。</p>
<pre><code>Answer = True
</code></pre>
<p>变量Answer是一个<strong>布尔值True</strong>。</p>
<p>在Python中，等号=是赋值语句，可以把<strong>任意数据类型</strong>赋值给变量，同一个变量可以<strong>反复赋值</strong>，而且<strong>可以是不同类型的变量</strong></p>
<p>这种变量本身类型不固定的语言称之为<strong>动态语言</strong>，与之对应的是静态语言。<strong>静态语言在定义变量时必须指定变量类型</strong>，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 表示注释）：</p>
<pre><code>int a = 123; // a是整数类型变量
a = &quot;ABC&quot;; // 错误：不能把字符串赋给整型变量
</code></pre>
<p>和静态语言相比，动态语言更灵活，就是这个原因。</p>
<p>最后，理解变量在计算机内存中的表示也非常重要。当我们写：</p>
<pre><code>a = 'ABC'
</code></pre>
<p>时，Python解释器干了两件事情：</p>
<ol>
<li>
<p>在内存中<strong>创建了一个'ABC'的字符串</strong>；</p>
</li>
<li>
<p>在内存中<strong>创建了一个名为a的变量</strong>，并把它<strong>指向'ABC'</strong>。</p>
</li>
</ol>
<p>也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据</p>
<p><strong>常量</strong></p>
<p>所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。<strong>在Python中，通常用全部大写的变量名表示常量</strong>：</p>
<pre><code>PI = 3.14159265359
</code></pre>
<p>但<strong>事实上PI仍然是一个变量，Python根本没有任何机制保证PI不会被改变</strong>，所以，用全部大写的变量名表示常量只是一个习惯上的用法，如果你一定要改变变量PI的值，也没人能拦住你。</p>
<p>最后解释一下整数的除法为什么也是精确的。在Python中，有两种除法，一种除法是/：</p>
<pre><code>&gt;&gt;&gt; 10 / 3
3.3333333333333335
</code></pre>
<p>/除法计算结果是<strong>浮点数</strong>，<strong>即使是两个整数恰好整除，结果也是浮点数</strong>：</p>
<pre><code>&gt;&gt;&gt; 9 / 3
3.0
</code></pre>
<p>还有一种<strong>除法是//，称为floor除，两个整数的除法仍然是整数</strong>：</p>
<pre><code>&gt;&gt;&gt; 10 // 3
3
</code></pre>
<p>你没有看错，整数的地板除//<strong>永远是整数，即使除不尽</strong>。要做精确的除法，使用/就可以。</p>
<p>因为//除法只取结果的整数部分，所以Python还提供一个余数运算，可以得到两个整数相除的余数：</p>
<pre><code>&gt;&gt;&gt; 10 % 3
1
</code></pre>
<p>无论整数做//除法还是取余数，结果永远是整数，所以，整数运算结果永远是精确的。</p>
<pre><code>n = 123
print(&quot;n = &quot;, n)
f = 456.789
print(&quot;f = &quot;, f)
s1 = &quot;\'Hello, World\'&quot;
print(&quot;s1 = &quot;, s1)
s2 = &quot;'Hello, \'Adam\&quot;&quot;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL 178. 分数排名[中等][未做出]]]></title>
        <id>https://lixin-scut.github.io//post/mysql-178-fen-shu-pai-ming-zhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/mysql-178-fen-shu-pai-ming-zhong-deng-wei-zuo-chu">
        </link>
        <updated>2020-05-07T02:31:16.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>编写一个 SQL 查询来实现分数排名。<br>
如果两个分数相同，则两个分数排名（Rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。<br>
+----+-------+<br>
| Id | Score |<br>
+----+-------+<br>
| 1  | 3.50  |<br>
| 2  | 3.65  |<br>
| 3  | 4.00  |<br>
| 4  | 3.85  |<br>
| 5  | 4.00  |<br>
| 6  | 3.65  |<br>
+----+-------+<br>
例如，根据上述给定的 Scores 表，你的查询应该返回（按分数从高到低排列）：<br>
+-------+------+<br>
| Score | Rank |<br>
+-------+------+<br>
| 4.00  | 1    |<br>
| 4.00  | 1    |<br>
| 3.85  | 2    |<br>
| 3.65  | 3    |<br>
| 3.65  | 3    |<br>
| 3.50  | 4    |<br>
+-------+------+<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/rank-scores<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>第一步比较简单，只是将score进行一个逆序排序即可，用到ORDER BY和DESC<br>
第二个则比较难，不知道如何每行返回一个相应的树枝（注意同分数相同，并且不累加，就是1、1、2而不是1、1、3）</p>
<p>看一下网友题解：</p>
<blockquote>
<p>最后的结果包含两个部分，第一部分是降序排列的分数，第二部分是每个分数对应的排名。<br>
第一部分不难写：</p>
</blockquote>
<pre><code>select a.Score as Score
from Scores a
order by a.Score DESC
</code></pre>
<blockquote>
<p>比较难的是第二部分。假设现在给你一个分数X，如何算出它的排名Rank呢？<br>
我们可以先提取出大于等于X的所有分数集合H，将H去重后的元素个数就是X的排名。比如你考了99分，但最高的就只有99分，那么去重之后集合H里就只有99一个元素，个数为1，因此你的Rank为1。<br>
先提取集合H：</p>
</blockquote>
<pre><code>select b.Score from Scores b where b.Score &gt;= X;
</code></pre>
<blockquote>
<p>我们要的是集合H去重之后的元素个数，因此升级为：</p>
</blockquote>
<pre><code>select count(distinct b.Score) from Scores b where b.Score &gt;= X as Rank;
</code></pre>
<blockquote>
<p>而从结果的角度来看，第二部分的Rank是对应第一部分的分数来的，所以这里的X就是上面的a.Score，把两部分结合在一起为：</p>
</blockquote>
<pre><code>select a.Score as Score,
(select count(distinct b.Score) from Scores b where b.Score &gt;= a.Score) as Rank
from Scores a
order by a.Score DESC
</code></pre>
<p>我的复现：</p>
<pre><code>SELECT a.Score AS Score,
       (SELECT COUNT(DISTINCT b.Score) 
        FROM Scores AS b
        WHERE b.Score &gt;= a.Score) AS 'Rank'
FROM Scores AS a
ORDER BY Score DESC;
</code></pre>
<p>注意RANK是一个关键词，所以不能直接作为别名，必须加上单引号<br>
然后重点在于条件WHERE b.Score &gt;= a.Score和聚集函数COUNT(DISTINCT b.Score) 的配合</p>
<p>相关知识点：<br>
《MySQL必知必会》<br>
<strong>使用WHERE子句</strong><br>
只检索所需数据需要 指定搜索条件(search criteria)，搜索条件也称为过滤条件(filter condition)。<br>
在SELECT语句中，数据根据WHERE子句中指定的搜索条件进行过滤。 WHERE子句在表名(FROM子句)之后给出<br>
WHERE子句的位置：在同时使用ORDERBY和WHERE子句时，应 该让ORDER BY位于WHERE之后，否则将会产生错误<br>
WHERE子句的等于是 = 而不是 ==</p>
<p><strong>COUNT()函数</strong><br>
COUNT()函数进行计数。可利用COUNT()确定表中行的数目或符合特定条件的行的数目。<br>
COUNT()函数有两种使用方式。<br>
使用COUNT(*)对表中行的数目进行计数，不管表列中包含的是空 值(NULL)还是非空值。<br>
使用COUNT(column)对特定列中具有值的行进行计数，忽略 NULL值。<br>
NULL值：如果指定列名，则指定列的值为空的行被COUNT() 函数忽略，但如果COUNT()函数中用的是星号(*)，则不忽 略。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 128. 最长连续序列[困难][未做出]]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-128-zui-chang-lian-xu-xu-lie-kun-nan-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-128-zui-chang-lian-xu-xu-lie-kun-nan-wei-zuo-chu">
        </link>
        <updated>2020-05-07T01:05:43.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>给定一个未排序的整数数组，找出最长连续序列的长度。<br>
要求算法的时间复杂度为 O(n)。<br>
示例:<br>
输入: [100, 4, 200, 1, 3, 2]<br>
输出: 4<br>
解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/longest-consecutive-sequence<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>我是直接使用了官方题解中的hashset优化方法<br>
这个方法很妙的一点就是通过检测当前i-1是否在hashset中，如果在的话说明这个数字本身已经被检索或者等等之后就会被检索，所以当前元素就不需要考虑了。</p>
<pre><code>class Solution {
public:
    int longestConsecutive(vector&lt;int&gt;&amp; nums) {
        unordered_set&lt;int&gt; nums_set;
        for(int i : nums)
        {
            nums_set.insert(i);
        }
        
        int ans = 0;
        for(int i : nums)
        {
            int count = 0;
            if(nums_set.count(i - 1))
            {
                continue;
            }
            else
            {
                int temp = i;
                while(nums_set.count(temp))
                {
                    ++temp;
                    ++count;
                }
            }
            ans = max(ans, count);
        }
        return ans;
    }
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>方法 1：暴力<br>
想法<br>
因为一个序列可能在 nums 数组的任意一个数字开始，我们可以枚举每个数字作为序列的第一个数字，搜索所有的可能性。<br>
算法<br>
暴力算法没有任何思路或技巧上的优化，它仅仅将 nums 数组中的每一个数字，作为序列第一个数字，枚举后面的数字，直到有数字在原数组中没出现过。当枚举到数组中没有的数字时（即 currentNum 是一个数组中没出现过的数字），记录下序列的长度，如果比当前最优解大的话就更新。算法一定能找到最优解，因为它枚举了每一种可能性。</p>
</blockquote>
<pre><code>class Solution:
    def longestConsecutive(self, nums):
        longest_streak = 0

        for num in nums:
            current_num = num
            current_streak = 1

            while current_num + 1 in nums:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

        return longest_streak
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n^3) 外部循环运行恰好 n 次。同时，因为 currentNum 在 while 循环中每次增加 1 ，所以 while 循环会运行 O(n) 次。在每次 while 循环中，会有一个对数组 O(n) 的查找。所以暴力算法是一个嵌套三层 O(n) 的循环，总时间复杂度是 O(n^3) 。<br>
空间复杂度：O(1)<br>
暴力算法仅使用了有限的整数，所以它用了常数级别的额外空间。</p>
</blockquote>
<blockquote>
<p>方法 2：排序<br>
想法<br>
如果我们可以将数组中的数字升序迭代，找连续数字会变得十分容易。为了将数组变得有序，我们将数组进行排序。<br>
算法<br>
在我们开始算法之前，首先检查输入的数组是否为空数组，如果是，函数直接返回 0 。对于其他情况，我们将 nums 数组排序，并考虑除了第一个数字以外的每个数字与它前一个数字的关系。如果当前数字和前一个数字相等，那么我们当前的序列既不会增长也不会中断，我们只需要继续考虑下一个数字。如果不相等，我们必须要检查当前数字是否能延长答案序列（也就是 nums[i] == nums[i-1] + 1）。如果可以增长，那么我们将当前数字添加到当前序列并继续。否则，当前序列被中断，我们记录当前序列的长度并将序列长度重置为 1 。由于 nums 中的最后一个数字也可能是答案序列的一部分，所以我们将当前序列的长度和记录下来的最长序列的长度的较大值返回。</p>
</blockquote>
<pre><code>class Solution:
    def longestConsecutive(self, nums):
        if not nums:
            return 0

        nums.sort()

        longest_streak = 1
        current_streak = 1

        for i in range(1, len(nums)):
            if nums[i] != nums[i-1]:
                if nums[i] == nums[i-1]+1:
                    current_streak += 1
                else:
                    longest_streak = max(longest_streak, current_streak)
                    current_streak = 1

        return max(longest_streak, current_streak)
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(nlgn)<br>
算法核心的 for循环恰好运行 n 次，所以算法的时间复杂度由 sort 函数的调用决定，通常会采用 O(nlgn) 时间复杂度的算法。<br>
空间复杂度：O(1)（或者 O(n)）<br>
以上算法的具体实现中，由于我们将数组就低排序，所以额外的空间复杂度是常数级别的。如果不允许修改输入数组，我们需要额外的线性长度的空间来保存中间结果和排好序的数组。</p>
</blockquote>
<blockquote>
<p>方法 3：哈希表和线性空间的构造<br>
想法<br>
其实我们一开始的暴力解法的思路是正确的，但是需要进行一些优化，才能达到 O(n) 的时间复杂度。<br>
算法<br>
这个优化算法与暴力算法仅有两处不同：这些数字用一个 HashSet 保存（或者用 Python 里的 Set），实现 O(1) 时间的查询，同时，我们只对 当前数字 - 1 不在哈希表里的数字，作为连续序列的第一个数字去找对应的最长序列，这是因为其他数字一定已经出现在了某个序列里。</p>
</blockquote>
<pre><code>class Solution:
    def longestConsecutive(self, nums):
        longest_streak = 0
        num_set = set(nums)

        for num in num_set:
            if num - 1 not in num_set:
                current_num = num
                current_streak = 1

                while current_num + 1 in num_set:
                    current_num += 1
                    current_streak += 1

                longest_streak = max(longest_streak, current_streak)

        return longest_streak
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)<br>
尽管在 for 循环中嵌套了一个 while 循环，时间复杂度看起来像是二次方级别的。但其实它是线性的算法。因为只有当 currentNum 遇到了一个序列的开始， while 循环才会被执行（也就是 currentNum-1 不在数组 nums 里）， while 循环在整个运行过程中只会被迭代 n 次。这意味着尽管看起来时间复杂度为 O(n⋅n) ，实际这个嵌套循环只会运行 O(n+n)=O(n) 次。所有的计算都是线性时间的，所以总的时间复杂度是 O(n) 的。<br>
空间复杂度：O(n)<br>
为了实现 O(1) 的查询，我们对哈希表分配线性空间，以保存 nums 数组中的 O(n) 个数字。除此以外，所需空间与暴力解法一致。</p>
</blockquote>
<p>还有一类方法是并查集</p>
<blockquote>
<p>方法： 并查集<br>
将连续的数字作为一个集合<br>
那么扫描到一个数字，只要将它和它的下一个数字（假如存在）merge在一个集合即可。同时更新这个集合的元素个数<br>
如果当前经过merge的集合的元素个数比当前记录的最长序列的长度都长，则更新当前最长记录</p>
</blockquote>
<pre><code>class Solution {
public:
    // cnt用于记录当前集合的元素个数
    unordered_map&lt;int,int&gt; uf, cnt;

    int find(int i){
        return i == uf[i] ? i: uf[i] = find(uf[i]);
    }

    int merge(int x, int y){
        x = find(x); y = find(y);
        if(x == y) return cnt[x];
        uf[y] = x;
        //更新合并之后的连通分量的元素个数
        cnt[x] += cnt[y];
        return cnt[x];
    }

    int longestConsecutive(vector&lt;int&gt;&amp; nums) {
        if(nums.size() == 0) return 0;
        for(int i: nums) uf[i] = i, cnt[i] = 1;
        int ans = 1;
        for(int i: nums){
            if(i != INT_MAX &amp;&amp; uf.count(i+1)) ans = max(ans, merge(i, i+1));
        }
        return ans;
    }
};
</code></pre>
]]></content>
    </entry>
</feed>