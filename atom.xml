<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-11-16T08:06:12.322Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[树 111. 二叉树的最小深度[简单]]]></title>
        <id>https://lixin-ee.github.io//post/shu-111-er-cha-shu-de-zui-xiao-shen-du-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/shu-111-er-cha-shu-de-zui-xiao-shen-du-jian-dan">
        </link>
        <updated>2019-11-16T07:51:43.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个二叉树，找出其最小深度。<br>
最小深度是从根节点到最近叶子节点的最短路径上的节点数量。<br>
说明: 叶子节点是指没有子节点的节点。<br>
示例:<br>
给定二叉树 [3,9,20,null,null,15,7],<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7<br>
返回它的最小深度  2.<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/minimum-depth-of-binary-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题的要点在于累计当前节点到根节点的距离并检测是否是根节点<br>
和前面的题目还是非常相似的<br>
说实话这一题真的是蛮波折的，一开始不想用全局值了，以为利用min直接返回局部i值就好，结果遇到了++i这个小插曲，然后遇到了严重问题，遇到非叶节点的NULL节点时返回的值是无效的<br>
然后还是得老老实实学习前几题那样先放弃null节点，然后再判断叶子节点进行返回，<br>
同时全局值一开始必须设为int_max，然后必须判断root值是否为null（因为没法把res值设为0）<br>
代码如下：</p>
<pre><code>class Solution {
int res=INT_MAX;
public:
    int minDepth(TreeNode* root) {
        if(root==NULL)
            return 0;
        preorder(root,1);
        return res;
    }
    
    void preorder(TreeNode* cur,int i){
        if(cur==NULL)
            return; 
        if(cur-&gt;left==NULL&amp;&amp;cur-&gt;right==NULL) //这里又傻逼了，直接用了cur==null判断，明显会导致非叶节点的返回
        {
            res=res&lt;i?res:i;
            return;
        } 
        preorder(cur-&gt;left,i+1);
        preorder(cur-&gt;right,i+1);//这里傻逼了，用++i，导致第二个i疯狂增长
        return;
    }
};
</code></pre>
<p>然后来看一下网友题解：<br>
思路：</p>
<blockquote>
<p>很多人写出的代码都不符合 1,2 这个测试用例，是因为没搞清楚题意<br>
题目中说明:叶子节点是指没有子节点的节点，这句话的意思是 1 不是叶子节点<br>
题目问的是到叶子节点的最短距离，所以所有返回结果为 1 当然不是这个结果<br>
另外这道题的关键是搞清楚递归结束条件<br>
叶子节点的定义是左孩子和右孩子都为 null 时叫做叶子节点<br>
当 root 节点左右孩子都为空时，返回 1<br>
当 root 节点左右孩子有一个为空时，返回不为空的孩子节点的深度<br>
当 root 节点左右孩子都不为空时，返回左右孩子较小深度的节点值<br>
第一版代码:</p>
</blockquote>
<pre><code>class Solution {
public int minDepth(TreeNode root) {
if(root == null) return 0;
//这道题递归条件里分为三种情况
//1.左孩子和有孩子都为空的情况，说明到达了叶子节点，直接返回1即可
if(root.left == null &amp;&amp; root.right == null) return 1;
//2.如果左孩子和由孩子其中一个为空，那么需要返回比较大的那个孩子的深度        
int m1 = minDepth(root.left);
int m2 = minDepth(root.right);
//这里其中一个节点为空，说明m1和m2有一个必然为0，所以可以返回m1 + m2 + 1;
if(root.left == null || root.right == null) return m1 + m2 + 1;

//3.最后一种情况，也就是左右孩子都不为空，返回最小深度+1即可
return Math.min(m1,m2) + 1; 
}
}
</code></pre>
<blockquote>
<p>代码可以进行简化，当左右孩子为空时 m1 和 m2都为 0<br>
可以和情况 2 进行合并，即返回 m1+m2+1<br>
简化后代码如下:</p>
</blockquote>
<pre><code>class Solution {
    public int minDepth(TreeNode root) {
        if(root == null) return 0;
        int m1 = minDepth(root.left);
        int m2 = minDepth(root.right);
        //1.如果左孩子和右孩子有为空的情况，直接返回m1+m2+1
        //2.如果都不为空，返回较小深度+1
        return root.left == null || root.right == null ? m1 + m2 + 1 : Math.min(m1,m2) + 1;
    }
}
</code></pre>
<p>666呀比起我的代码简化了许多，我是一直累计下去，而他是利用递归从尾部到根结点不断地累计。</p>
<p>然后来看一下官方题解：</p>
<blockquote>
<p>方法 1：递归<br>
算法<br>
最直接的思路就是递归。<br>
我们用深度优先搜索来解决这个问题。</p>
</blockquote>
<pre><code>class Solution {
  public int minDepth(TreeNode root) {
    if (root == null) {
      return 0;
    }

    if ((root.left == null) &amp;&amp; (root.right == null)) {
      return 1;
    }

    int min_depth = Integer.MAX_VALUE;
    if (root.left != null) {
      min_depth = Math.min(minDepth(root.left), min_depth);
    }
    if (root.right != null) {
      min_depth = Math.min(minDepth(root.right), min_depth);
    }

    return min_depth + 1;
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：我们访问每个节点一次，时间复杂度为O(N) ，其中 NN 是节点个数。<br>
空间复杂度：最坏情况下，整棵树是非平衡的，例如每个节点都只有一个孩子，递归会调用 N （树的高度）次，因此栈的空间开销是O(N) 。但在最好情况下，树是完全平衡的，高度只有 log(N)，因此在这种情况下空间复杂度只有 O(log(N)) 。</p>
</blockquote>
<blockquote>
<p>方法 2：深度优先搜索迭代<br>
我们可以利用栈将上述解法中的递归变成迭代。<br>
想法是对于每个节点，按照深度优先搜索的策略访问，同时在访问到叶子节点时更新最小深度。<br>
我们从一个包含根节点的栈开始，当前深度为 1 。<br>
然后开始迭代：弹出当前栈顶元素，将它的孩子节点压入栈中。当遇到叶子节点时更新最小深度。</p>
</blockquote>
<pre><code>import javafx.util.Pair;
class Solution {
  public int minDepth(TreeNode root) {
    LinkedList&lt;Pair&lt;TreeNode, Integer&gt;&gt; stack = new LinkedList&lt;&gt;();
    if (root == null) {
      return 0;
    }
    else {
      stack.add(new Pair(root, 1));
    }

    int min_depth = Integer.MAX_VALUE;
    while (!stack.isEmpty()) {
      Pair&lt;TreeNode, Integer&gt; current = stack.pollLast();
      root = current.getKey();
      int current_depth = current.getValue();
      if ((root.left == null) &amp;&amp; (root.right == null)) {
        min_depth = Math.min(min_depth, current_depth);
      }
      if (root.left != null) {
        stack.add(new Pair(root.left, current_depth + 1));
      }
      if (root.right != null) {
        stack.add(new Pair(root.right, current_depth + 1));
      }
    }
    return min_depth;
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：每个节点恰好被访问一遍，复杂度为 O(N)。<br>
空间复杂度：最坏情况下我们会在栈中保存整棵树，此时空间复杂度为 O(N)。</p>
</blockquote>
<blockquote>
<p>方法 3：宽度优先搜索迭代<br>
深度优先搜索方法的缺陷是所有节点都必须访问到，以保证能够找到最小深度。因此复杂度是 O(N)。<br>
一个优化的方法是利用宽度优先搜索，我们按照树的层次去迭代，第一个访问到的叶子就是最小深度的节点，这样就不要遍历所有的节点了。</p>
</blockquote>
<pre><code>import javafx.util.Pair;
class Solution {
  public int minDepth(TreeNode root) {
    LinkedList&lt;Pair&lt;TreeNode, Integer&gt;&gt; stack = new LinkedList&lt;&gt;();
    if (root == null) {
      return 0;
    }
    else {
      stack.add(new Pair(root, 1));
    }

    int current_depth = 0;
    while (!stack.isEmpty()) {
      Pair&lt;TreeNode, Integer&gt; current = stack.poll();
      root = current.getKey();
      current_depth = current.getValue();
      if ((root.left == null) &amp;&amp; (root.right == null)) {
        break;
      }
      if (root.left != null) {
        stack.add(new Pair(root.left, current_depth + 1));
      }
      if (root.right != null) {
        stack.add(new Pair(root.right, current_depth + 1));
      }
    }
    return current_depth;
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：最坏情况下，这是一棵平衡树，我们需要按照树的层次一层一层的访问完所有节点，除去最后一层的节点。这样访问了 N/2 个节点，因此复杂度是 O(N)。<br>
空间复杂度：和时间复杂度相同，也是 O(N)。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于虚函数和纯虚函数]]></title>
        <id>https://lixin-ee.github.io//post/guan-yu-xu-han-shu-he-chun-xu-han-shu</id>
        <link href="https://lixin-ee.github.io//post/guan-yu-xu-han-shu-he-chun-xu-han-shu">
        </link>
        <updated>2019-11-15T08:16:03.000Z</updated>
        <content type="html"><![CDATA[<p>今天在做15.8的题的时候产生了一点疑问，如果隔代继承的话如果我不去覆盖虚函数会怎么样？还是使用基类的虚函数吗<br>
首先来看一下虚函数的定义</p>
<blockquote>
<p>对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成虚函数 (virtualfunction)</p>
</blockquote>
<p>但是同时</p>
<blockquote>
<p>如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接维承其在基类中的版本<br>
当我们在派生类中覆盖了某个虚函数时，可以再一次使用virtual 关键字指出该函数的性质。然而这么做并非必须，因为一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数。</p>
</blockquote>
<p>所以虚函数的覆盖定义仅仅是一种“希望”，最终的决定权还是在派生类上，不覆盖的话还是继续原封不动继承。而且覆盖的时候就算不加上virtual，都会继续有虚函数这个性质，所以后面的派生类照样可以选择覆盖或者不覆盖</p>
<p>而对于纯虚函数：</p>
<blockquote>
<p>可以将 net_price 定义成纯虚 (pure virtual )函数从而令程序实现我们的设计意图，这样做可以清晰明了地告诉用户当前这个 net_price 函数是没有实际意义的。<br>
含有（或者未经覆盖直接继承）纯虚函数的类是抽象基类 （abstractbaseclass )。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。我们不能（直接）创建一个抽象基类的对象。<br>
Disc_quote的派生类必须给出自己的net _ price定义，否则它们仍将是抽象基类</p>
</blockquote>
<p>所以纯虚函数是必须覆盖的。</p>
<p>所以一开始的问题的答案当然是肯定的<br>
测试代码如下：</p>
<pre><code>class B {
public:
	virtual void fcn1() { cout &lt;&lt; &quot;B-fcn1&quot; &lt;&lt; endl; };
	virtual void fcn2() { cout &lt;&lt; &quot;B-fcn1&quot; &lt;&lt; endl; };
};

class D1 :public B {
public:
	void fcn1() { cout &lt;&lt; &quot;D1-fcn1&quot; &lt;&lt; endl; }
};

class D2 :public D1 {
public:
	void fcn2() { cout &lt;&lt; &quot;D2-fcn2&quot; &lt;&lt; endl; }
};

int main()
{
	B b;
	D1 d1;
	D2 d2;
	b.fcn1();
	b.fcn2();
	d1.fcn1();
	d1.fcn2();
	d2.fcn1();
	d2.fcn2();
}
</code></pre>
<p>得到的答案如预料之中<br>
<img src="https://lixin-ee.github.io//post-images/1573806400737.png" alt=""></p>
<p>然后来测试一下纯虚函数</p>
<pre><code>class B {
public:
	virtual void fcn1() { cout &lt;&lt; &quot;B-fcn1&quot; &lt;&lt; endl; };
	virtual void fcn2() { cout &lt;&lt; &quot;B-fcn2&quot; &lt;&lt; endl; };
};

class V :public B{
public:
	virtual void fcn1() =0;
	virtual void fcn2() =0;
};

class D1 :public V {
public:
	void fcn1() { cout &lt;&lt; &quot;D1-fcn1&quot; &lt;&lt; endl; }
	void fcn2() { cout &lt;&lt; &quot;D1-fcn2&quot; &lt;&lt; endl; }
};

class D2 :public D1 {
public:
	void fcn1() { cout &lt;&lt; &quot;D2-fcn1&quot; &lt;&lt; endl; }
};

int main()
{
	B b;
	D1 d1;
	D2 d2;
	b.fcn1();
	b.fcn2();
	d1.fcn1();
	d1.fcn2();
	d2.fcn1();
	d2.fcn2();
}
</code></pre>
<p>结果如下：<br>
<img src="https://lixin-ee.github.io//post-images/1573806696185.png" alt=""></p>
<p>可以得出的结论有<br>
1.V中的纯虚函数=0直接覆盖了B中的定义，如果D1中不覆盖直接继承纯虚函数会被视为抽象基类，而覆盖后仍然保持虚函数性质，同时对于D2来说就是两个普通的虚函数了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 129. 求根到叶子节点数字之和[中等]]]></title>
        <id>https://lixin-ee.github.io//post/shu-129-qiu-gen-dao-xie-zi-jie-dian-shu-zi-zhi-he-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/shu-129-qiu-gen-dao-xie-zi-jie-dian-shu-zi-zhi-he-zhong-deng">
        </link>
        <updated>2019-11-15T01:37:13.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。<br>
例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。<br>
计算从根到叶子节点生成的所有数字之和。<br>
说明: 叶子节点是指没有子节点的节点。</p>
<p>示例 1:<br>
输入: [1,2,3]<br>
1<br>
/ <br>
2   3<br>
输出: 25<br>
解释:<br>
从根到叶子节点路径 1-&gt;2 代表数字 12.<br>
从根到叶子节点路径 1-&gt;3 代表数字 13.<br>
因此，数字总和 = 12 + 13 = 25.<br>
示例 2:<br>
输入: [4,9,0,5,1]<br>
4<br>
/ <br>
9   0<br>
 / <br>
5   1<br>
输出: 1026<br>
解释:<br>
从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495.<br>
从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491.<br>
从根到叶子节点路径 4-&gt;0 代表数字 40.<br>
因此，数字总和 = 495 + 491 + 40 = 1026.</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/sum-root-to-leaf-numbers<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题和之前的差别不大，主要是传递值并且传递一个vector引用进行存储</p>
<pre><code>class Solution {
public:
    int sumNumbers(TreeNode* root) {
        vector&lt;int&gt; vi;
        int res=0;
        preorder(root,res,vi);
        for(auto i:vi)
            res+=i;
        return res;
    }
    
    void preorder(TreeNode* cur,int res,vector&lt;int&gt; &amp;vi){
        if(cur==NULL)
            return;
        res=res*10+cur-&gt;val;
        if(cur-&gt;left==NULL&amp;&amp;cur-&gt;right==NULL){
            vi.push_back(res);
            return;
        }
        preorder(cur-&gt;left,res,vi);
        preorder(cur-&gt;right,res,vi);
        return;
    }
};
</code></pre>
<p>看下网友题解</p>
<blockquote>
<p>思路一:<br>
二叉树的题目我们首先想到的就是递归求解。递归的方式很简单，用先序遍历的变形。<br>
先遍历根节点；<br>
遍历左子树，遍历左子树的时候，把走当前路径的数字带到左子树的求解中；<br>
遍历右子树，遍历右子树的时候，把走当前路径的数字带到右子树的求解中；<br>
更新总的和。<br>
代码一:</p>
</blockquote>
<pre><code>Java
class Solution {
    private int sum = 0;
    private void helper(TreeNode node, int father) {
        if (node == null) return ;
        int current = father * 10 + node.val;
        if (node.left == null &amp;&amp; node.right == null) {
            sum += current;
            return;
        }
        helper(node.left, current);
        helper(node.right, current);
    }

    public int sumNumbers(TreeNode root) {
        if (root == null) return sum;
        helper(root, 0);
        return sum;
    }
}
</code></pre>
<blockquote>
<p>思路二:<br>
通常还可以用 stack 的思路来解递归的题目。先序非递归的代码我们知道是用 stack 来保存遍历过的元素。而因为本题要记录到叶节点的数字，所以需要一个额外的 stack 来记录数字。每次出 stack 之后，如果是叶子节点，那么加和；如果不是，那么就看左右子树，入 stack。<br>
代码二:</p>
</blockquote>
<pre><code>Java
class Solution {
    public int sumNumbers(TreeNode root) {
        int sum = 0;
        if (root == null) return sum;
        Stack&lt;TreeNode&gt; nodeStack = new Stack&lt;&gt;();
        Stack&lt;Integer&gt; numStack = new Stack&lt;&gt;();
        nodeStack.add(root);
        numStack.add(0);
        while (!nodeStack.isEmpty()) {
            TreeNode current = nodeStack.pop();
            Integer currentNum = numStack.pop() * 10 + current.val;
            if (current.left == null &amp;&amp; current.right == null) {
                sum += currentNum;
            }
            if (current.left != null) {
                nodeStack.add(current.left);
                numStack.add(currentNum);
            }
            if (current.right != null) {
                nodeStack.add(current.right);
                numStack.add(currentNum);
            }
        } 
        return sum;
    }
}
</code></pre>
<blockquote>
<p>思路三:<br>
其实，我们可以看到，最关键的是找到叶子节点，然后加和这个操作。叶子节点我们同样可以用层序遍历的方式来解这道题目。层序遍历用队列来解。<br>
代码三:</p>
</blockquote>
<pre><code>Java
public class Solution {
    public int sumNumbers(TreeNode root) {
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();
        Queue&lt;Integer&gt; numQueue = new LinkedList&lt;Integer&gt;();
        if(root == null) return 0;
        int res = 0;
        queue.add(root);
        numQueue.add(0);
        while(!queue.isEmpty()) {
            int size = queue.size();
            // 把该层的都入队，同时如果遇到叶节点，计算更新
            while(size-- &gt; 0) {
                root = queue.poll();
                int val = numQueue.poll() * 10 + root.val;
                if(root.left == null &amp;&amp; root.right == null)
                    res += val;
                if(root.left != null) {
                    queue.add(root.left);
                    numQueue.add(val);
                }
                if (root.right != null) {
                    queue.add(root.right);
                    numQueue.add(val);
                }
            }
        }
        return res;
    }
}
</code></pre>
<blockquote>
<p>总结，二叉树的题目，大多数都是遍历的变形，面试时候看用 bfs，还是 dfs，一般来说很快就能得出答案。写非递归代码的时候，注意判断一下非空，不要把 null 节点入队或者入栈。</p>
</blockquote>
<p>看了一下第一个递归的解答，发现用全局sum确实方便很多，毕竟也没要求返回每个值，用vector有点大材小用了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[error C4430: 缺少类型说明符 - 假定为 int。注意: C++ 不支持默认 int]]></title>
        <id>https://lixin-ee.github.io//post/error-c4430-que-shao-lei-xing-shuo-ming-fu-jia-ding-wei-int-zhu-yi-c-bu-zhi-chi-mo-ren-int</id>
        <link href="https://lixin-ee.github.io//post/error-c4430-que-shao-lei-xing-shuo-ming-fu-jia-ding-wei-int-zhu-yi-c-bu-zhi-chi-mo-ren-int">
        </link>
        <updated>2019-11-14T12:48:25.000Z</updated>
        <content type="html"><![CDATA[<p>这个错误是在编写类的时候出现的，主要问题在于类的实用出现在了声明和定义前面。最严重的程度就是两个类互相包含，或者两个头文件相互包含了（想起经典表情包hhh，-我要引用头文件2！-那你得先完成头文件1！！-我得引用头文件2才能完成头文件1！！！-那你先完成头文件1才能引用头文件2啊！！！！）<br>
主要原因还是c++不允许使用不完全类型，除了指针引用和参数类型返回类型<br>
原笔记：<br>
类可以先声明再定义，先声明未定义的时候称为前向声明，此时是一个不完全类型，只能用于1.定义指向这种类型的指针或者引用2.声明（不能定义）以不完全类型作为参数或者返回类型的函数</p>
<p>解决方法就是调整定义的位置或者增加声明。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Chrome下如何复制禁止复制网页上的文字]]></title>
        <id>https://lixin-ee.github.io//post/chrome-xia-ru-he-fu-zhi-jin-zhi-fu-zhi-wang-ye-shang-de-wen-zi</id>
        <link href="https://lixin-ee.github.io//post/chrome-xia-ru-he-fu-zhi-jin-zhi-fu-zhi-wang-ye-shang-de-wen-zi">
        </link>
        <updated>2019-11-14T12:42:42.000Z</updated>
        <content type="html"><![CDATA[<p>今天贴个和工作不太相关但是异常好用的东西<br>
起因是党支部最近很多写感想的操作，然后我发现网上真的因此衍生了一大堆 如何写相关感想 的网站hhh，当然天底下没有免费的午餐，现在都逐渐开始收费了。但是这些写手的质量实在堪忧啊，如果是高质量模板付费还好说，这种质量我觉得只适合Ctrl+CV了<br>
不多废话了，下面是方法</p>
<p>上网或工作的时候，看到一些文章大家可能想复制或是收藏起来，但是当你要复制的时候却发现,根本复制不了,被网站做复制限制了，右键也给禁了。这可怎么办呢?正所谓，万物皆可破，在这里给大家介绍一个简单的方法，因为本人用的是Chrome浏览器，所以在此介绍下Chrome下如何复制的方法。</p>
<p>1,在你要复制文字的页面，按F12，选择“ Console” 输入：document.body.innerText 然后按回车</p>
<p>2，红色矩形框中的文字就是你所获得的文字了。然后你就可以任意复制你需要的文字了。</p>
<p>非常简单 但是非常实用hhh</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ C++ primer 第十五章 笔记+习题 15.6-15.9]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-wu-zhang-bi-ji-xi-ti-156-159</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-wu-zhang-bi-ji-xi-ti-156-159">
        </link>
        <updated>2019-11-14T07:16:42.000Z</updated>
        <content type="html"><![CDATA[<p>15.6继承中的类作用域<br>
<strong>每个类定义</strong>自己的<strong>作用域</strong>（参见7.4节，第253页），在这个<strong>作用域内</strong>我们<strong>定义类的成员</strong>。<br>
当存在继承关系时，<strong>派生类</strong>的作用域<strong>嵌套</strong>（参见2.2.4节，第43页）在其<strong>基类</strong>的<strong>作用域之内</strong>。如果一个名字在派生类的作用域内无法正确解析，则编译器将<strong>继续</strong>在<strong>外层的基类作用域中寻找</strong>该名字的定义。</p>
<p>一个<strong>对象、引用或指针</strong>的<strong>静态类型</strong>（参见15.2.3节，第532页）<strong>决定</strong>了该对象的<strong>哪些成员是可见的</strong>。即使静态类型与动态类型可能<strong>不一致</strong>（当使用基类的引用或指针时会发生这种情况），但是我们<strong>能使用哪些成员</strong>仍然是由<strong>静态类型决定</strong>的。</p>
<p>quote不能用，disc_quote继承自quote</p>
<p>和其他作用域一样，派生类也能重用定义在其直接基类或间接基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字（参见2.2.4节，第43页）； //变量（手写的笔记）<br>
<strong>派生类的成员将隐藏同名的基类成员</strong>我们通过<strong>作用域运算符</strong>来使用一个<strong>被隐藏</strong>的基类成员;</p>
<p>除了覆盖继承而来的虚函数之外，派生类<strong>最好不要重用</strong>其他定义在基类中的名字。</p>
<p><strong>声明在内层作用域</strong>的函数并<strong>不会重载声明在外层作用域的函数</strong>（参化6.4.1节，第210页）。因此，定义<strong>派生类中的函数</strong>也<strong>不会重载</strong>其<strong>基类中的成员</strong>。<strong>（直接被隐藏掉）</strong><br>
如果派生类（即内层作用域）的成员与基类（即外层作用域）的某个成员同名，则<strong>派生类</strong>将在其作用域内<strong>隐藏该基类成员</strong>。<strong>即使</strong>派生类成员和基类成员的<strong>形参列表不一致</strong>，基类成员<strong>也仍然会被隐藏掉</strong>。</p>
<p>我们现在可以理解为什么基类与派生类中的<strong>虚函数必须有相同的形参列表</strong>了（参见15.3节，第537页）。<strong>假如</strong>基类与派生类的虚函数接受的<strong>实参不同</strong>.则我们就<strong>无法通过基类的引用或指针调用派生类的虚函数</strong>了。</p>
<p>因为 Base 类中没有 f 2（），所以第一条语句是非法的，即使当前的指针碰巧指向了一个派生类对象也无济于事。</p>
<p>在上面的每条调用语句中，指针都指向了D2类型的对象，但是由于我们调用的是<strong>非虚函数</strong>，所以<strong>不会发生动态绑定</strong>。实际调用的函数版本<strong>由指针的静态类型决定</strong>。</p>
<p>和其他函数一样，成员函数<strong>无论是否是虚函数都能被重载</strong>。派生类可以覆盖重载函数的0个或多个实例。如果派生类希望基类所有的重载版本对于它来说<strong>都是可见的</strong>，那么它就需要<strong>覆盖所有的版本，或者一个也不覆盖</strong>。<br>
一种好的解决方案是为<strong>重载的成员</strong>提供一条 <strong>using 声明语句</strong>（参见15.5节，第546页），这样我们就<strong>无须覆盖基类</strong>中的<strong>每一个重载版本</strong>了。 using Base::fcn;<br>
using 声明语句<strong>指定一个名字</strong>而<strong>不指定形参列表</strong>，所以—条基类成员函数的 using 声明语句就可以把该函数的<strong>所有重载实例</strong>添加到<strong>派生类作用域</strong>中。此时，派生类只需要定义其特有的函数就可以了，而<strong>无须为继承而来的其他函数重新定义</strong>。<br>
类内 using 声明的一般规则<strong>同样适用于重载函数的名字</strong>（参见15.5节，第546页）；基类函数的<strong>每个实例</strong>在派生类中都必须是<strong>可访问的</strong>。对派生类没有重新定义的重载版本的访问实际上是对 Using 声明点的访问。</p>
<p>习题15.23<br>
如果想要覆盖继承而来的虚函数，需要使形参数目一致或者使用using声明语句</p>
<p>15.7 构造函数与拷贝控制<br>
15.7.1 虚析构函数<br>
<strong>继承关系</strong>对<strong>基类拷贝控制</strong>最直接的影响是<strong>基类</strong>通常应该定义一个<strong>虚析构函数</strong>，样可以确保delete基类指针时将运行正确的虚构函数版本(动态绑定虚析构函数)<br>
当我们<strong>delete</strong> 一个<strong>动态分配的对象的指针</strong>时将执行析构函数(参化13.1.3节，第445页）。如果该指针指向<strong>继承体系中的某个类型</strong>，则有可能出现<strong>指针的静态类型</strong>与<strong>被删除对象的动态类型不符</strong>的情况（参见15.2.2节，第530页）。<br>
如果基类的<strong>析构函数不是虚函数</strong>，则 <strong>delete—个指向派生类对象的基类指针</strong>将产生未定义的行为。<br>
之前我们曾介绍过一条经验准则，即如果一个类需要析构函数，那么它也同样需要拷贝和赋值操作（参见13.1.4节，第447页）。<strong>基类的析构函数并不遵循上述准则</strong>，它是一个重要的例外。一个<strong>基类总是需要析构函数</strong>，而且它<strong>能将析构函数设定为虚函数</strong>。此时，该析构函数为了成为虚函数而<strong>令内容为空</strong>，我们显然无法由此推断该基类还需要赋值运算或拷贝构造函数。</p>
<p><strong>如果一个类定义了析构函数</strong>，即使它通过= default 的形式使用了合成的版本，<strong>编译器</strong>也<strong>不会为这个类合成移动操作</strong></p>
<p>习题15.24<br>
基类都需要虚析构函数，虚析构函数的函数体为空，需要动态销毁对象，这样可以确保delete基类指针时将运行正确的虚构函数版本(动态绑定虚析构函数)</p>
<p>15.7.2 合成拷贝控制与继承<br>
基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似：它们对类本身的成员依次进行初始化、赋值或销毁的操作。此外，这些合成的成员还<strong>负责使用直接基类中对应的操作</strong>对一个对象的<strong>直接基类部分</strong>进行初始化、赋值或销毁的操作：<br>
•合成的 Bulk _ quote 默认构造函数运行 Disc _ quote 的默认构造函数，后者又运<br>
行 Quote 的默认构造函数。<br>
•  Quote 的默认构造函数将 bookNo 成员默认初始化为空字符串，同时使用类内初始值将 price 初始化为0。<br>
•  Quote 的构造函数完成后，继续执行 Disc _ quote 的构造函数，它使用类内初始值初始化 qty 和 discount 。<br>
•  Disc _ quote 的构造函数完成后，继续执行 Bulk _ quote 的构造函数，但是它什么具体工作也不做。</p>
<p>值得注意的是，无论基类成员是合成的版本（如 Quote 继承体系的例子）还是自定义的版本都没有太大影响。<strong>唯一的要求</strong>是<strong>相应的成员应该可访问</strong>（参见15.5节，第542页）并且不是一个被删除的函数。<br>
<strong>派生类的析构函数</strong>来说，它除了销毁派生类自己的成员外，<strong>还负责销毁</strong>派生类的<strong>直接基类</strong>；该直接基类又销毁它自己的直接基类，<strong>以此类推直至继承链的顶端</strong>。<br>
如前所述， Quote因为定义了析构函数而不能拥有合成的移动操作，因此当我们<strong>移动 Quote对象</strong>时实际使用的是<strong>合成的拷贝操作</strong>（参见13.6.2节，第477页）。如我们即将看到的那样， <strong>Quote没有移动操作</strong>意味着它的<strong>派生类也没有</strong>。</p>
<p>基类或派生类也能出于同样的原因将其合成的默认构造函数或者任何一个拷贝控制成员<strong>定义成被删除的函数</strong><br>
•如果<strong>基类中的</strong>默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是<strong>被删除的函数或者不可访问</strong>（参见15.5节，第543页），则<strong>派生类中对应的成员将是被删除的</strong>，原因是编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值或销毁操作。<br>
•如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分。<br>
•和过去一样，编译器将不会合成一个删除掉的移动操作。当我们使用 =default请求一个移动操作时，如果基类中的对应操作是删除的或不可访问的，那么派生类中该函数将是被删除的，原因是派生类对象的基类部分不可移动。同样，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是被删除的。</p>
<p>在实际编程过程中，如果<strong>在基类中没有</strong>默认、拷贝或移动构造函数，则一般情况下<strong>派生类也不会定义相应的操作</strong>。</p>
<p>默认情况下，基类通常不含有<strong>合成</strong>的移动操作，而且在它的派生类中也没有合成的移动操作。<br>
因为<strong>基类缺少</strong>移动操作<strong>会阻止派生类拥有</strong>自己的合成移动操作，所以当我们确实需要执行移动操作时<strong>应该首先在基类中进行定义</strong>。</p>
<p><strong>一旦基类定义了移动操作，则它也必须同时显式定义拷贝操作。基类中定义了移动操作后派生类将会自动获得合成的移动操作</strong></p>
<p>习题15.25<br>
因为Bulk_quote的构造函数需要调用Disc_quote的构造函数，如果没有的话，Bulk_quote的构造函数会被定义为删除的</p>
<p>15.7.3 派生类的拷贝控制成员<br>
派生类的<strong>拷贝和移动构造函数</strong>在拷贝和移动自有成员的同时，也要<strong>拷贝和移动基类部分的成员</strong>。类似的，<strong>派生类赋值运算符</strong>也必须为其<strong>基类部分的成员赋值</strong>。<br>
当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。</p>
<p>在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝（或移动）基类部分，则必须在派生类的构造函数初始值列表中<strong>显式地使用基类的拷贝（或移动）构造函数</strong>。</p>
<p>与拷贝和移动构造函数一样，<strong>派生类的赋值运算符</strong>（参见13.1.2节，第443页和13.6.2节，第474页）也必须<strong>显式地为其基类部分赋值</strong>：</p>
<p>派生类<strong>析构函数只负责销毁</strong>由派生类<strong>自己分配的资源，基类析构函数会被自动调用执行</strong>：</p>
<p>对象<strong>销毁的顺序正好与其创建的顺序相反</strong>：派生类析构函数首先执行，然后是基类的析构函数，以此类推，沿着继承体系的反方向直至最后。</p>
<p>当我们构建一个对象时，需要把<strong>对象的类和构造函数的类看作是同一个</strong>；<strong>对虚函数的调用绑定正好符合</strong>这种把对象的类和构造函数的类看成同一个的要求；<strong>对于析构函数也是同样的道理</strong>。<br>
如果构造函数或析构函数<strong>调用了某个虚函数</strong>，则我们应该执行与构造函数或析构函数<strong>所属类型相对应的虚函数版本</strong>。</p>
<p>习题15.26</p>
<pre><code>class Quote {
public:
	Quote() = default;
	Quote(const string &amp;book,double sales_price):bookNo(book),price(sales_price){}
	string isbn() const { return bookNo;}
	virtual double net_price(size_t n)const { return n*price; }
	virtual ~Quote()=default;
	virtual void Debug();
	Quote(const Quote&amp;) = default;
	Quote(Quote&amp;&amp;) = default;
	Quote&amp; operator=(const Quote&amp;) = default;
	Quote&amp; operator=(Quote&amp;&amp;) = default;
private:
	string bookNo;
protected:
	double price = 0.0;
};

class Disc_quote :public Quote {
public:
	Disc_quote() = default;
	Disc_quote(const string &amp;book, double price, size_t qty, double disc) :Quote(book, price), quantity(qty), discount(disc) {};
	double net_price(size_t)const = 0;
	Disc_quote(const Disc_quote&amp;);
	Disc_quote(Disc_quote&amp;&amp;);
	Disc_quote&amp; operator=(const Disc_quote&amp;);
	Disc_quote&amp; operator=(Disc_quote&amp;&amp;);
	virtual ~Disc_quote() = default;
protected:
	size_t quantity = 0;
	double discount = 0.0;
};

Disc_quote::Disc_quote(const Disc_quote &amp;disc):Quote(disc),quantity(disc.quantity),discount(disc.discount) {
	cout &lt;&lt; &quot;This is disc's copy construct&quot; &lt;&lt; endl;
}

Disc_quote::Disc_quote(Disc_quote &amp;&amp;disc) : Quote(disc), quantity(disc.quantity), discount(disc.discount) {
	cout &lt;&lt; &quot;This is disc's move construct&quot; &lt;&lt; endl;
}

Disc_quote&amp; Disc_quote::operator=(const Disc_quote&amp; disc) {
	Quote::operator=(disc);
	quantity = disc.quantity;
	discount = disc.discount;
	cout &lt;&lt; &quot;This is disc's copy operator=&quot; &lt;&lt; endl;
	return *this;
}

Disc_quote&amp; Disc_quote::operator=(Disc_quote&amp;&amp; disc) {
	if (&amp;disc != this) {
		Quote::operator=(disc);
		quantity = disc.quantity;
		discount = disc.discount;
	}
	cout &lt;&lt; &quot;This is disc's move operator=&quot; &lt;&lt; endl;
	return *this;
}

class Bulk_quote :public Disc_quote {
public:
	Bulk_quote() = default;
	Bulk_quote(const string &amp;book, double price, size_t qty, double disc) :Disc_quote(book, price, qty, disc) {};
	double net_price(size_t)const override;
	void Debug();
	Bulk_quote(const Bulk_quote &amp;bulk) :Disc_quote(bulk) { cout &lt;&lt; &quot;This is disc's copy construct&quot; &lt;&lt; endl; };
	Bulk_quote(Bulk_quote &amp;&amp;bulk) :Disc_quote(bulk) { cout &lt;&lt; &quot;This is disc's move construct&quot; &lt;&lt; endl; };
	Bulk_quote&amp; operator=(const Bulk_quote &amp;bulk) { Disc_quote::operator=(bulk); cout &lt;&lt; &quot;This is disc's copy operator=&quot; &lt;&lt; endl; return *this; };
	Bulk_quote&amp; operator=(Bulk_quote &amp;&amp;bulk) { Disc_quote::operator=(bulk); cout &lt;&lt; &quot;This is disc's move operator=&quot; &lt;&lt; endl; return *this; };
	virtual ~Bulk_quote() = default;
};
</code></pre>
<p>注意：移动构造函数那一堆我还是蛮不确定的！</p>
<p>15.7.4继承的构造函数<br>
在 C ++11新标准中，派生类能够<strong>重用</strong>其<strong>直接基类定义的构造函数</strong>。<br>
一个类<strong>只初始化</strong>它的直接基类，出于同样的原因，一个类<strong>也只继承</strong>其直接基类的构造函数。<strong>类不能继承默认、拷贝和移动构造函数</strong>。<strong>如果派生类没有直接定义</strong>这些构造函数，则<strong>编译器</strong>将为派生类<strong>合成</strong>它们。<br>
派生类<strong>继承基类构造函数</strong>的方式是提供一条<strong>注明了（直接）基类名的 using 声明语句</strong>。</p>
<p><strong>通常情况下using 声明语句只是令某个名字在当前作用域内可见</strong>。而<strong>当作用于构造函数时， using 声明语句将令编译器产生代码</strong>。对于基类的<strong>毎个构造函数</strong>，编译器都<strong>生成一个与之对应的派生类构造函数</strong>。<br>
这些编译器生成的构造函数形如：<br>
derivec (parms) : base (args)  { }<br>
其中，derived是派生类的名字，base是基类的名字，parms是构造函数的形参列表，args将<strong>派生类构造函数的形参传递给基类的构造函数</strong>。<br>
<strong>如果派生类含有自己的数据成员，则这些成员将被默认初始化</strong><br>
和普通成员的 using 声明不一样，一个构造函数的 using 声明<strong>不会改变该构造函数的访问级别</strong>。<br>
一个 <strong>using 声明</strong>语句<strong>不能指定 explicit 或 constexpr</strong> 。如果<strong>基类的构造函数是 explicit</strong> (参见7.5.4节，第265页）<strong>或者 constexpr</strong>(参见7.5.6节，第267页），则<strong>继承的构造函数也拥有相同的属性</strong>。<br>
当一个基类构造函数含有<strong>默认实参</strong>（参见6.5.1节，第211页）时.这些实参<strong>并不会被继承</strong>。相反，<strong>派生类</strong>将获得<strong>多个继承的构造函数</strong>，<strong>其中每个构造函数分别省略掉一个含有默认实参的形参。</strong><br>
例如，如果基类有一个接受两个形参的构造函数.其中第二个形参含有默认实参，则派生类将获得两个构造函数：一个构造函数接受两个形参（没有默认实参），另一个构造函数只接受一个形参，它对应于基类中最左侧的没有默认值的那个形参。<br>
第一个例外是<strong>派生类</strong>可以<strong>继承一部分构造函数</strong>，而<strong>为其他构造函数定义自己的版本</strong>。如果派生类定义的构造函数与基类的构造函数<strong>具有相同的参数列表</strong>，则该构造函数<strong>将不会被继承</strong>。定义在派生类中的构造函数将替换继承而来的构造函数。<br>
第二个例外是默认、拷贝和移动构造函数不会被继承。这些构造函数按照正常规则<strong>被合成</strong>。<strong>继承的构造函数不会被作为用户定义的构造函数来使用</strong>，因此，如果一个类<strong>只含有继承的构造函数</strong>.则它也将拥有一个<strong>合成的默认构造函数</strong>。（不等同于自己定义的）</p>
<p>习题15.27</p>
<pre><code>class Bulk_quote :public Disc_quote {
public:
	//Bulk_quote() = default;
	//Bulk_quote(const string &amp;book, double price, size_t qty, double disc) :Disc_quote(book, price, qty, disc) {};
	using Disc_quote::Disc_quote;
｝
</code></pre>
<p>15.8 容器与继承<br>
当我们使用<strong>容器</strong>存放<strong>继承体系中的对象</strong>时，通常<strong>必须</strong>采取间接存储的方式。因为不允许在容器中保存<strong>不同类型</strong>的元素，所以我们不能把<strong>具有继承关系的多种类型</strong>的对象直接存放在容器当中</p>
<p>当派生类对象被赋值给基类对象时，其中的<strong>派生类部分将被切掉</strong>，因此<strong>容器</strong>和<strong>存在继承关系的类型无法兼容</strong>。</p>
<p>当我们希望在容器中存放具有继承关系的对象时，我们实际上<strong>存放的</strong>通常是<strong>基类的指针</strong>（<strong>更好的选择是智能指针</strong>（参见12.1节，第400页））。和往常一样，这些<strong>指针所指对象</strong>的<strong>动态类型</strong>可能是基类类型，也可能是派生类类型</p>
<p>我们可将一个派生类的普通指针转换成基类指针一样（参见15.2.2节，第言30页），我们也能把一个<strong>派生类的智能指针</strong>转换成<strong>基类的智能指针</strong>。<br>
当我们调<strong>用 push _ back 时</strong>该对象<strong>被转换成shared _ ptr &lt; Quote &gt;</strong> 。因此尽管在形式上有所差别，但实际上 basket 的<strong>所有元素的类型都是相同</strong>的。</p>
<p>15.8.1编写basket类<br>
习题15.30</p>
<pre><code>class Basket {
public:
	void add_item(const shared_ptr&lt;Quote&gt; &amp;sale) { items.insert(sale); }
	void add_item(const Quote&amp; sale) { items.insert(shared_ptr&lt;Quote&gt;(sale.clone())); }
	void add_item(Quote&amp;&amp; sale) { items.insert(shared_ptr&lt;Quote&gt;(std::move(sale).clone())); }
	double total_receipt(ostream&amp;) const;
private:
	static bool compare(const shared_ptr&lt;Quote&gt; &amp;lhs, const shared_ptr&lt;Quote&gt; &amp;rhs) { return lhs-&gt;isbn() &lt; rhs-&gt;isbn(); }
	multiset&lt;shared_ptr&lt;Quote&gt;, decltype(compare)*&gt; items{ compare };
};

double Basket::total_receipt(ostream &amp;os) const {
	double sum = 0.0;
	for (auto iter = items.begin(); iter != items.end(); iter = items.upper_bound(*iter)) {
		sum += print_total(os, **iter, items.count(*iter));
		os &lt;&lt; &quot;Total Sale:&quot; &lt;&lt; sum &lt;&lt; endl;
		return sum;
	}
}
</code></pre>
<p>15.9 文本查询程序再探<br>
15.9.1面向对象的解决方案<br>
习题15.31<br>
（a） OrQuery AndQuery NotQuery WordQuery<br>
（b）OrQuery AndQuery NotQuery WordQuery<br>
（c）OrQuery AndQuery-2  WordQuery<br>
15.9.2Query_base和Query类<br>
习题15.32<br>
都是使用默认的拷贝操作和析构函数（只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符，）（编译器不会为某些类合成移动操作，特别是当一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符，反而类会通过正常的函数匹配从而使用对应的拷贝操作来代替移动操作）<br>
习题15.32<br>
由于没有数据成员，所以合成的拷贝控制足以应付所有问题（能够构造Query_base类型的对象么？不是抽象基类吗？）</p>
<p>15.9.3  派生类</p>
<p>15.9.4 eval函数</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 113. 路径总和 II[中等]]]></title>
        <id>https://lixin-ee.github.io//post/shu-113-lu-jing-zong-he-iizhong-deng</id>
        <link href="https://lixin-ee.github.io//post/shu-113-lu-jing-zong-he-iizhong-deng">
        </link>
        <updated>2019-11-14T01:54:30.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。<br>
说明: 叶子节点是指没有子节点的节点。<br>
示例:<br>
给定如下二叉树，以及目标和 sum = 22，<br>
5<br>
/ <br>
4   8<br>
/   / <br>
11  13  4<br>
/  \    / <br>
7    2  5   1<br>
返回:</p>
<p>[<br>
[5,4,11,2],<br>
[5,8,4,5]<br>
]<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/path-sum-ii<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题其实和之前的差不多，只是需要额外地增加一个vector记录路径<br>
然后主要的点为<br>
1.改进了sum，直接将sum进行自身递减，省去了一定一个res变量<br>
2.但是我没想好如何处理vector的问题，既需要一个全局的<code>vector&lt;vector&lt;int&gt;&gt;</code>，又需要一个<code>vector&lt;int&gt;</code>，导致内存使用量很高</p>
<p>最终代码如下：</p>
<pre><code>class Solution {
     vector&lt;vector&lt;int&gt;&gt; vvi;

public:
    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) {
        vector&lt;int&gt; vi;
        preorder(root,sum,vi);
        return vvi;
    }
     void preorder(TreeNode* root, int sum,vector&lt;int&gt; vi) {
        if(root==NULL)
            return;
        sum-=root-&gt;val;
        vi.push_back(root-&gt;val);
        if(root-&gt;left==NULL&amp;&amp;root-&gt;right==NULL&amp;&amp;!sum)
            vvi.push_back(vi);
        preorder(root-&gt;left,sum,vi);
        preorder(root-&gt;right,sum,vi);
        return ;
    }
};
</code></pre>
<p>然后来看一下网友题解：</p>
<pre><code>class Solution {
    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) {
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        helper(root, sum, res, new ArrayList&lt;Integer&gt;());
        return res;
    }

    private void helper(TreeNode root, int sum, List&lt;List&lt;Integer&gt;&gt; res, ArrayList&lt;Integer&gt; tmp) {
        if (root == null) return;
        tmp.add(root.val);
        if (root.left == null &amp;&amp; root.right == null &amp;&amp; sum - root.val == 0) res.add(new ArrayList&lt;&gt;(tmp));
        helper(root.left, sum - root.val, res, tmp);
        helper(root.right, sum - root.val, res, tmp);
        tmp.remove(tmp.size() - 1);
    }
}
</code></pre>
<p>感觉这个和我的差不多呀。。。。所以好像没什么特别好的方法能降低空间复杂度了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 112. 路径总和[简单]]]></title>
        <id>https://lixin-ee.github.io//post/shu-112-lu-jing-zong-he-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/shu-112-lu-jing-zong-he-jian-dan">
        </link>
        <updated>2019-11-13T02:32:08.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。<br>
说明: 叶子节点是指没有子节点的节点。<br>
示例: <br>
给定如下二叉树，以及目标和 sum = 22，</p>
<pre><code>          5
         / \
        4   8
       /   / \
      11  13  4
     /  \      \
    7    2      1
</code></pre>
<p>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/path-sum<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题的和前面的无差，主要的难点在于返回值的处理，回忆<a href="https://lixin-ee.github.io/post/shu-100-xiang-tong-de-shu-jian-dan/">100.相同的树</a>中的方法，完全可以把递归放到return语句中，从而不需要额外的变量来存储返回结果。<br>
然后这一题中注意返回结果的处理必须是或逻辑而不是与逻辑<br>
然后提交过程中发现的小问题是我一开始以为全部数都是正数所以提前判断是否大于sum结果测试用例有负数直接翻车了只能删掉提前判断没错我就是一口气说这么多不带标点符号hhh<br>
最终代码如下</p>
<pre><code>class Solution {
public:
    bool hasPathSum(TreeNode* root, int sum) {
        int res=0;
        return preorder(root,res,sum);
    }
    bool preorder(TreeNode* cur, int res,const int sum){
        if(cur==NULL)
            return false;
        res+=cur-&gt;val;
        if(cur-&gt;left==NULL&amp;&amp;cur-&gt;right==NULL&amp;&amp;res==sum)
            return true;
        return preorder(cur-&gt;left, res,sum)||preorder(cur-&gt;right,res,sum);
    }
    
};
</code></pre>
<blockquote>
<p>官方题解：<br>
方法 1：递归<br>
最直接的方法就是利用递归，遍历整棵树：如果当前节点不是叶子，对它的所有孩子节点，递归调用 hasPathSum 函数，其中 sum 值减去当前节点的权值；如果当前节点是叶子，检查 sum 值是否为 0，也就是是否找到了给定的目标和。</p>
</blockquote>
<pre><code>Java
class Solution {
  public boolean hasPathSum(TreeNode root, int sum) {
    if (root == null)
      return false;

    sum -= root.val;
    if ((root.left == null) &amp;&amp; (root.right == null))
      return (sum == 0);
    return hasPathSum(root.left, sum) || hasPathSum(root.right, sum);
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：我们访问每个节点一次，时间复杂度为 O(N) ，其中 N 是节点个数。<br>
空间复杂度：最坏情况下，整棵树是非平衡的，例如每个节点都只有一个孩子，递归会调用 N 次（树的高度），因此栈的空间开销是 O(N) 。但在最好情况下，树是完全平衡的，高度只有 log(N)，因此在这种情况下空间复杂度只有 O(log(N)) 。</p>
</blockquote>
<blockquote>
<p>方法 2：迭代<br>
算法<br>
我们可以用栈将递归转成迭代的形式。深度优先搜索在除了最坏情况下都比广度优先搜索更快。最坏情况是指满足目标和的 root-&gt;leaf 路径是最后被考虑的，这种情况下深度优先搜索和广度优先搜索代价是相通的。<br>
利用深度优先策略访问每个节点，同时更新剩余的目标和。<br>
所以我们从包含根节点的栈开始模拟，剩余目标和为 sum - root.val。<br>
然后开始迭代：弹出当前元素，如果当前剩余目标和为 0 并且在叶子节点上返回 True；如果剩余和不为零并且还处在非叶子节点上，将当前节点的所有孩子以及对应的剩余和压入栈中。</p>
</blockquote>
<pre><code>class Solution {
  public boolean hasPathSum(TreeNode root, int sum) {
    if (root == null)
      return false;

    LinkedList&lt;TreeNode&gt; node_stack = new LinkedList();
    LinkedList&lt;Integer&gt; sum_stack = new LinkedList();
    node_stack.add(root);
    sum_stack.add(sum - root.val);

    TreeNode node;
    int curr_sum;
    while ( !node_stack.isEmpty() ) {
      node = node_stack.pollLast();
      curr_sum = sum_stack.pollLast();
      if ((node.right == null) &amp;&amp; (node.left == null) &amp;&amp; (curr_sum == 0))
        return true;

      if (node.right != null) {
        node_stack.add(node.right);
        sum_stack.add(curr_sum - node.right.val);
      }
      if (node.left != null) {
        node_stack.add(node.left);
        sum_stack.add(curr_sum - node.left.val);
      }
    }
    return false;
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：和递归方法相同是 O(N)。<br>
空间复杂度：当树不平衡的最坏情况下是 O(N) 。在最好情况（树是平衡的）下是 O(logN)。</p>
</blockquote>
<p>哈哈哈又被官方题解的优雅秀到了，我是用一个额外的参数res来计算值然后判断相等，从而额外地需要将sum传进去递归里面，但是官方是直接用sum递减来处理，省去了额外的参数负担，妙呀！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 257. 二叉树的所有路径[简单]]]></title>
        <id>https://lixin-ee.github.io//post/shu-257-er-cha-shu-de-suo-you-lu-jing-rong-yi</id>
        <link href="https://lixin-ee.github.io//post/shu-257-er-cha-shu-de-suo-you-lu-jing-rong-yi">
        </link>
        <updated>2019-11-12T02:55:03.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个二叉树，返回所有从根节点到叶子节点的路径。<br>
说明: 叶子节点是指没有子节点的节点。<br>
示例:<br>
输入:<br>
1<br>
/   <br>
2     3<br>
<br>
5<br>
输出: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]<br>
解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/binary-tree-paths<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>整体的架构肯定就是前序遍历的了，主要的点在于需要判断叶节点，我一开始只进行了null的判断，导致多了多余路径1-&gt;2，所以必须对叶节点进行判断，同时可以分离-&gt;这个讨厌的符号的写入<br>
最终代码如下：</p>
<pre><code>class Solution {
    vector&lt;string&gt; vs;
public:
    vector&lt;string&gt; binaryTreePaths(TreeNode* root) {
        if(root==NULL)
            return vs;
        //string s=to_string(root-&gt;val);
        string s;
        preorder(root,s);
        //preorder(root-&gt;left,s);
        //preorder(root-&gt;right,s);
        return vs;
    }
    void preorder(TreeNode* cur,string s){
        if(cur==NULL)
            return;
        if(cur-&gt;right==NULL&amp;&amp;cur-&gt;left==NULL){
            s=s+to_string(cur-&gt;val);
            vs.push_back(s);
            return;
        }
        s=s+to_string(cur-&gt;val)+&quot;-&gt;&quot;;
        preorder(cur-&gt;left,s);
        preorder(cur-&gt;right,s);
        return;
    }
};
</code></pre>
<p>老规矩官方题解：</p>
<blockquote>
<p>方法一：递归<br>
最直观的方法是使用递归。在递归遍历二叉树时，需要考虑当前的节点和它的孩子节点。如果当前的节点不是叶子节点，则在当前的路径末尾添加该节点，并递归遍历该节点的每一个孩子节点。如果当前的节点是叶子节点，则在当前的路径末尾添加该节点后，就得到了一条从根节点到叶子节点的路径，可以把该路径加入到答案中。<br>
Java</p>
</blockquote>
<pre><code>class Solution {
    public void construct_paths(TreeNode root, String path, LinkedList&lt;String&gt; paths) {
        if (root != null) {
            path += Integer.toString(root.val);
            if ((root.left == null) &amp;&amp; (root.right == null))  // 当前节点是叶子节点
                paths.add(path);  // 把路径加入到答案中
            else {
                path += &quot;-&gt;&quot;;  // 当前节点不是叶子节点，继续递归遍历
                construct_paths(root.left, path, paths);
                construct_paths(root.right, path, paths);
            }
        }
    }

    public List&lt;String&gt; binaryTreePaths(TreeNode root) {
        LinkedList&lt;String&gt; paths = new LinkedList();
        construct_paths(root, &quot;&quot;, paths);
        return paths;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：每个节点只会被访问一次，因此时间复杂度为 O(N)，其中 N 表示节点数目。<br>
空间复杂度：O(N)。这里不考虑存储答案 paths 使用的空间，仅考虑额外的空间复杂度。额外的空间复杂度为递归时使用的栈空间，在最坏情况下，当二叉树中每个节点只有一个孩子节点时，递归的层数为 N，此时空间复杂度为 O(N)。在最好情况下，当二叉树为平衡二叉树时，它的高度为log(N)，此时空间复杂度为 O(log(N))。</p>
</blockquote>
<blockquote>
<p>方法二：迭代<br>
上面的算法也可以使用迭代（宽度优先搜索）的方法实现。我们维护一个队列，存储节点以及根到该节点的路径。一开始这个队列里只有根节点。在每一步迭代中，我们取出队列中的首节点，如果它是一个叶子节点，则将它对应的路径加入到答案中。如果它不是一个叶子节点，则将它的所有孩子节点加入到队列的末尾。当队列为空时，迭代结束。</p>
</blockquote>
<pre><code>class Solution {
    public List&lt;String&gt; binaryTreePaths(TreeNode root) {
        LinkedList&lt;String&gt; paths = new LinkedList();
        if (root == null)
            return paths;

        LinkedList&lt;TreeNode&gt; node_stack = new LinkedList();
        LinkedList&lt;String&gt; path_stack = new LinkedList();
        node_stack.add(root);
        path_stack.add(Integer.toString(root.val));
        TreeNode node;
        String path;
        while (!node_stack.isEmpty()) {
            node = node_stack.pollLast();
            path = path_stack.pollLast();
            if ((node.left == null) &amp;&amp; (node.right == null))
                paths.add(path);
            if (node.left != null) {
                node_stack.add(node.left);
                path_stack.add(path + &quot;-&gt;&quot; + Integer.toString(node.left.val));
            }
            if (node.right != null) {
                node_stack.add(node.right);
                path_stack.add(path + &quot;-&gt;&quot; + Integer.toString(node.right.val));
            }
        }
        return paths;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(N)，每个节点只会被访问一次。<br>
空间复杂度：O(N)，在最坏情况下，队列中有 N 个节点。</p>
</blockquote>
<p>不出所料递归方法和官方的一样（甚至于空间复杂度还要低一点），迭代方法的话老样子还是得用队列deque</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ C++ primer 第十五章 笔记+习题 15.1-15.5]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-wu-zhang-bi-ji-xi-ti-151-155</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-wu-zhang-bi-ji-xi-ti-151-155">
        </link>
        <updated>2019-11-11T02:43:17.000Z</updated>
        <content type="html"><![CDATA[<p>15.1 oop：概述<br>
面向对象程序设计（object-orientedprogramming )的<strong>核心思想</strong>是<strong>数据抽象</strong><br>
通过<strong>继承( inheritance )</strong> 联系在一起的类构成一种层次关系。通常在层次关系的根部有一个基类 （baseclass ),其他类则直接或间接地从基类继承而来，这些继承得到的类称为派生类 （derivedclass )。<strong>基类</strong>负责定义在层次关系中所有类<strong>共同拥有的成员</strong>，而每个<strong>派生类</strong>定义各自<strong>特有的成员</strong>。<br>
对于某些函数，<strong>基类</strong>希望它的<strong>派生类各自定义</strong>适合自身的版本，此时基类就将这些函数声明成<strong>虚函数 (virtualfunction)</strong></p>
<p>派生类必须通过使用<strong>类派生列表</strong>（classderivationlist )明确指出它是<strong>从哪个（哪些）基类继承而来的。</strong><br>
类派生列表的形式是：首先是一个冒号，后面紧跟<strong>以逗号分隔</strong>的基类列表，其中每个基类前面可以有访问说明符：</p>
<p>因为 Bulk_quote 在它的派生列表中使用了 <strong>public 关键字</strong>，因此我们完全可以把Bulk _ quote 的对象<strong>当成 Quote 的对象</strong>来使用</p>
<p>派生类必须在其内部对所有重新定义的<strong>虚函数进行声明</strong>。派生类可以在这样的函数之前加上 virtual 关键字.但是并不是非得这么做。<br>
出于15.3节（第538页）将要解释的原因， C ++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，具体措施是在该函数的<strong>形参列表</strong>之后增加一个<strong>override 关键字</strong>。<br>
通过使用<strong>动态绑定（dynamicbinding )</strong> , 我们能用<strong>同一段代码</strong>分别处理 Quote 和Bulkjuote 的对象<br>
上述过程中函数的<strong>运行版本</strong>由<strong>实参</strong>决定，即在<strong>运行时选择函数的版本</strong>，所以动态绑定有时又被称为<strong>运行时绑定（ run-timebinding )</strong>。<br>
在C++语言中，当我们<strong>使用基类的引用（或指针）调用一个虚函数时将发生动态绑定</strong>。</p>
<p>15.2 定义基类和派生类<br>
15.2.1定义基类<br>
作为继承关系中<strong>根节点</strong>的<strong>类</strong>通常都会定义一个<strong>虚析构函数</strong>。<br>
<strong>基类</strong>通常都应该定义一个<strong>虚析构函数</strong>，即使该函数不执行任何实际操作也是如此。<br>
遇到<strong>与类型相关的操作</strong>时，派生类必须对其重新定义。换句话说，派生类需要对这些操作提供自己的新定义以覆盖( override )从基类继承而来的旧定义。<br>
<strong>基类</strong>必须将它的<strong>两种成员函数</strong>区分开来：一种是基类<strong>希望其派生类进行覆盖</strong>的函数；另一种是基类希望派生类<strong>直接维承而不要改变</strong>的函数。对于<strong>前者</strong>，基类通常将其定义为<strong>虚函数</strong>（ virtual )。<br>
基类通过在其成员函数的声明语句之前加上<strong>关键字virtual</strong>使得该函数执行<strong>动态绑定</strong>。任何<strong>构造函数之外</strong>的<strong>非静态函数</strong>都可以是<strong>虚函数</strong>。<strong>关键字virtual</strong>只能出现在<strong>类内部的声明语句</strong>之前而<strong>不能用于类外部的函数定义</strong>。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。<br>
成员函数如果没被声明为虚函数，则其解析过程发生在编译时而非运行时。</p>
<p><strong>派生类</strong>无法访问<strong>基类的私有成员</strong><br>
派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类<br>
继承而来的成员。和其他使用基类的代码一样.派生类能访问公有成员，而不能访问私有成员。<br>
不过在某些时候基类中还有这样一种成员，<strong>基类</strong>希望它的<strong>派生类有权访问</strong>该成员，同时<strong>禁止其他用户访问</strong>。我們用<strong>受保护的（protected )访问运算符</strong>说明这样的成员。</p>
<pre><code>class Quote {
public:
	Quote() = default;
	Quote(const string &amp;book,double sales_price):bookNo(book),price(sales_price){}
	string isbn() const { return bookNo;}
	virtual double net_price(size_t n)const { return n*price; }
	virtual ~Quote()=default;
private:
	string bookNo;
protected:
	double price = 0.0;
};

double print_total(ostream &amp;os, const Quote &amp;item, size_t n)
{
	double ret = item.net_price(n);
	os &lt;&lt; &quot;ISBN:&quot; &lt;&lt; item.isbn() &lt;&lt; &quot;#sold:&quot; &lt;&lt; n &lt;&lt; &quot;total due:&quot; &lt;&lt; ret &lt;&lt; endl;
	return ret;
}
</code></pre>
<p>习题15.1<br>
也就是虚函数，基类<strong>希望其派生类进行覆盖</strong>的函数，。任何<strong>构造函数之外</strong>的<strong>非静态函数</strong>都可以是<strong>虚函数</strong>。<br>
习题15.2<br>
基类的private成员不能被派生类和其他用户访问，protected成员不能被其他用户访问，但可以被派生类访问<br>
习题15.3</p>
<p>15.2.2 定义派生类<br>
派生类必须通过使用<strong>类派生列表（class derivation list )</strong> 明确指出它是从哪个（哪些）基类继承而来的。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中<strong>每个基类前面</strong>可以有以下三种访问说明符中的一个；<strong>public 、protected 或者private</strong>。<br>
访问说明符的作用是<strong>控制派生类从基类维承而来的成员是否对派生类的用户可见</strong>。<br>
如果一个<strong>派生是公有</strong>的，则<strong>基类的公有成员</strong>也是<strong>派生类接口的组成部分</strong>。此外，我们能将<strong>公有派生类型的对象绑定到基类的引用或指针上</strong>。<br>
大多数类都只继承自一个类，这种形式的维承被称作&quot;单继承&quot;，</p>
<p>如果派生类<strong>没有覆盖</strong>其基类中的某个<strong>虚函数</strong>，则该虚函数的行为类似于其他的普通成员，派生类会<strong>直接维承其在基类中的版本</strong>。<br>
派生类可以在它覆盖的函数前使用 virtual 关键字，单不是非得这么做。<br>
C ++11新标准允许派生类<strong>显式地注明</strong>它使用某个成员函数<strong>覆盖了它维承的虚函数</strong>。具体做法是在形参列表后面、或者在 const 成员函数（参见7。1.2节，第231页）的 <strong>const 关键字</strong>后面、或者在引用成员函数（参见13.6.3节，第483页）的<strong>引用限定符后面</strong>添加一个关键字 <strong>override</strong> 。<br>
因为在<strong>派生类对象中</strong>含有与其<strong>基类对应的组成部分</strong>，所以我们能把<strong>派生类的对象</strong>当成<strong>基类对象</strong>来使用，而且我们也能将<strong>基类的指针或引用</strong>绑定到<strong>派生类对象中的基类部分</strong>上</p>
<p>这种转换通常称为<strong>派生类到基类的（ derived - to - base )类型转换</strong>。和其他类型转换一样，编译器会<strong>隐式地执行</strong>派生类到基类的转换（参见4.11节，第141页）。<br>
这种隐式特性意味着我们可以把<strong>派生类对象或者派生类对象的引用</strong>用在<strong>需要基类引用的地方</strong>；同样的，我们也可以把派生类对象的<strong>指针</strong>用在需要基类指针的地方。<br>
尽管在派生类对象中含有从基类继承而来的成员，但是派生类并<strong>不能直接初始化</strong>这些成员。和其他创建了基类对象的代码一样，<strong>派生类也必须使用基类的构造函数</strong>来初始化它的基类部分。<br>
每个类控制<strong>它自己的成员初始化</strong>过程。</p>
<p>该函数将它的<strong>前两个参数</strong>（分别表示ISBN和价格）<strong>传递给Quote的构造函数</strong>，<strong>由Quote的构造函数</strong>负责初始化Bulk_quote的<strong>基类部分</strong>（即bookNo成员和price成员）。当(空的）Quote构造函数体结束后，我们构建的对象的基类部分也就完成初始化了。接下来初始化由派生类直接定义的min_qty成员和discount成员。最后运行Bulk_quote构造函数的（空的）函数体。<br>
首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。<br>
派生类可以访问<strong>基类</strong>的<strong>公有成员和受保护成员（protected），不能访问private</strong><br>
<strong>派生类的作用域</strong>嵌套在基类的作用域之内每个类负责定义各自的接口。要想与类的对象交互必须使用该类的接口，即使这个对象是派生类的基类部分也是如此。<br>
因此，派生类对象不能直接初始化基类的成员<br>
如果基类定义了一个<strong>静态成员</strong>（参见 7.6 节，第 268 页），则在<strong>整个继承体系中</strong>只存在该成员的<strong>唯一定义</strong>。不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在<strong>唯一的实例</strong>。<br>
静态成员遵循通用的访问控制规则，如果基类中的成员是 private 的，则派生类无权访问它。假设某<strong>静态成员是可访问的</strong>，则我们既<strong>能通过基类</strong>使用它<strong>也能通过派生类</strong>使用它：</p>
<p>派生类的<strong>声明</strong>与其他类差别不大（参见7.3.3节，第250页），声明中包含类名但是<strong>不包含它的派生列表</strong>：<br>
class Bulk_quote : public Quote;//** 错误：派生列表不能出现在这里<br>
class Bulk_quote;  // 正确：声明派生类的正确方式<br>
一条<strong>声明语句的目的</strong>是令<strong>程序</strong>知晓<strong>某个名字的存在</strong>以及<strong>该名字表示一个什么样的实体</strong>，如一个类、一个函数或一个变量等。派生列表以及与定义有关的<strong>其他细节</strong>必须与<strong>类的主体一起出现</strong>。</p>
<p>如果我们想将<strong>某个类用作基类</strong>，则该类<strong>必须己经定义</strong>而<strong>非仅仅声明</strong>该规定还有一层隐含的意思，即<strong>一个类不能派生它本身</strong>。<br>
一个类是<strong>基类</strong>，同时它<strong>也可以是一个派生类</strong>：</p>
<p>在这个继承关系中，Base是D 1的直接基类 (directbase ),同时是D 2的<strong>间接基类</strong>（indirect base )。直接基类出现在派生列表中，而间接基类由派生类通过其直接基类继承而来。<br>
最终的派生类将包含它的直接基类的子对象以及每个间接基类的子对象。</p>
<p>有时我们会定义这样一种类，我们<strong>不希望其他类继承它</strong>，或者不想考虑它是否适合作为一个基类。为了实现这一目的， C ++11新标准提供了一种防止继承发生的方法，即在类名后跟一个<strong>关键字 final</strong> ：<code>class NoDerived final { /* */} //NoDerive不能作为基类</code></p>
<p>习题15.4<br>
（a）错误，不能继承自身（或者说继承的基类不能只声明而未定义）<br>
（b）正确，但是是private定义，但从基类维承而来的成员对派生类的用户不可见<br>
（c）错误，类的声明中不可以带有派生列表<br>
习题15.5</p>
<pre><code>class Bulk_quote :public Quote {
public:
	Bulk_quote() = default;
	Bulk_quote(const string&amp; book, double p, size_t qty, double disc) :Quote(book, p), min_qty(qty), discount(disc) {};
	double net_price(size_t)const override;
private:
	size_t min_qty = 0;
	double discount = 0.0;
};

double Bulk_quote::net_price(size_t cnt)const {
	if (cnt &gt;= min_qty)
		return cnt*(1 - discount)*price;
	else
		return cnt*price;
}
</code></pre>
<p>习题15.6</p>
<pre><code>int main()
{
	Quote q(&quot;123&quot;,123);
	Bulk_quote bq(&quot;123&quot;, 123,5,0.5);
	print_total(cout, q, 10);
	print_total(cout, bq, 2);
	print_total(cout, bq, 10);
}
</code></pre>
<p>习题15.7<br>
其实可以直接利用Bulk_quote类，然后就是修改一下net_price函数</p>
<pre><code>double Bulk_quote::net_price(size_t cnt)const {
	if (cnt &lt;= min_qty)
		return cnt*(1 - discount)*price;
	else
		return  min_qty*(1 - discount)*price +(cnt-min_qty)*price;
}
</code></pre>
<p>15.2.3类型转换与继承<br>
我们可以将<strong>基类</strong>的<strong>指针或引用</strong>绑定到<strong>派生类对象</strong>上。<br>
当使用<strong>基类的引用（或指针）<strong>时，实际上我们</strong>并不清楚</strong>该引用（或指针）所绑定对象的<strong>真实类型</strong>。该对象<strong>可能是基类的对象，也可能是派生类的对象</strong>。<br>
和内置指针一样，<strong>智能指针类</strong>（参见12.1节，第400页）也<strong>支持派生类向基类</strong>的类型转换，这意味着我们可以将一个派生类对象的指针存储在一个基类的智能指针内:<br>
表达式的<strong>静态类型</strong>在<strong>编译时总是已知</strong>的，它是变量声明时的类型或表达式生成的类型：动态类型则是变量或表达式表示的内存中的对象的类型。<strong>动态类型直到运行时才可知</strong>。<br>
<strong>如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致</strong>。例如，Quote 类型的变量永远是一个 Quote 对象，我们无论如何都不能改变该变量对应的对象的类型。<br>
基类的<strong>指针和引用的静态类型可能与其动态类型不一致</strong>，读者一定要理解其中的原因<br>
之所以存在派生类向基类的类型转换<strong>是因为每个派生类对象都包含一个基类部分</strong>，而基类的引用或指针可以<strong>绑定到该基类部分上</strong>。<br>
因为一个基类的对象可能是派生类对象的一部分，<strong>也可能不是</strong>，所以<strong>不存在从基类向派生类</strong>的自动类型转换<br>
即使一个基类指针或引用绑定在一个派生类对象上，我们也不能执行从基类向派生类的转换：<br>
派生类向基类的自动类型转换<strong>只对指针或引用类型有效</strong>，在派生类类型和基类类型之间不存在这样的转换。<br>
请注意，当我们<strong>初始化或赋值</strong>一个类类型的对象时，实际上是在<strong>调用某个函数</strong>。当执行初始化时，我们调用构造函数（参见13.1.1节，第440页和13.6.2节，第473页）；而当执行赋值操作时，我们调用赋值运算符（参见13.1.2节，第443页和13.6.2节，第474页）。这些成员通常都包含一个参数，<strong>该参数的类型是类类型的 const 版本的引用（思考为什么是引用）</strong>。<br>
因为这些成员<strong>接受引用作为参数</strong>，所以派生类向基类的转换允许我们<strong>给基类的拷贝移动操作</strong>传递一个<strong>派生类的对象</strong>。这些操作不是虚函数。当我们给基类的构造函数传递一个派生类对象时，<strong>实际运行的构造函数是基类中定义的那个</strong>，显然该构造函数只能处理基类自己的成员。类似的，如果我们将一个<strong>派生类对象</strong>赋值给一个<strong>基类对象</strong>，则实际运行的赋值运算符也是<strong>基类中定义的那个</strong>，该运算符同样只<strong>能处理基类自己的成员<br>
**<br>
因为在上述过程中会</strong>忽略掉 bulk _ quote 部分**，所以我们可以说 bulk 的 Bulk_quot分<strong>被切掉 （sliced down )了</strong>。<br>
当我们用一个派生类对象为一个基类对象初始化或赋值时，<strong>只有该派生类对象的基类部分会被拷贝、移动或赋値，它的派生类部分将被忽略掉</strong><br>
关键概念：存在继承关系的类型之间的转换规则: :<br>
要想理解在具有继承关系的类之间发生的类型转换，有三点非常重要：<br>
•从派生类向基类的类型转换<strong>只对指针或引用类型</strong>有效。<br>
•<strong>基类向派生类不存在</strong>隐式类型转换。<br>
•和任何其他成员一样，派生类向基类的类型转换也<strong>可能会由于访问受限而变得不可行</strong>。我们将在15.5节（第544页）详细介绍可访问性的问题。<br>
尽管自动类型转换只对指针或引用类型有效，但是继承体系中的大多数类仍然（显式或隐式地）定义了拷贝控制成员（参见第13章）。因此，我们<strong>通常能够</strong>将一个<strong>派生类</strong>对象<strong>拷贝、移动或赋值</strong>给一个<strong>基类对象</strong>。不过需要注意的是，这种操作只<strong>处理派生类对象的基类部分</strong>。</p>
<p>习题15.8<br>
表达式的<strong>静态类型</strong>在<strong>编译时总是已知</strong>的，它是变量声明时的类型或表达式生成的类型：动态类型则是变量或表达式表示的内存中的对象的类型。<strong>动态类型直到运行时才可知</strong>。<br>
习题15.9<br>
基类的<strong>指针和引用的静态类型可能与其动态类型不一致</strong><br>
习题15.10<br>
read的形参参数为 istream的引用，所以可以将派生类ifstream的引用作为形参传给read</p>
<p>15.3虚函数<br>
因为我们<strong>直到运行时</strong>才能知道<strong>到底调用了哪个版本</strong>的虚函数，所以所有虚函数都<strong>必须有定义</strong>，因为连<strong>编译器也无法确定</strong>到底会使用哪个虚函数。<br>
<strong>动态绑定</strong>只有当我们<strong>通过指针或引用</strong>调用虚函数时才会发生。</p>
<p>当通过一个具有普通类型（非引用非指针）的表达式调用虚函数时，在编译时就会将调 用的版本确定下来。<br>
OOP的<strong>核心思想</strong>是<strong>多态性（polymorphism)</strong>。我们把<strong>具有继承关系的多个类型</strong>称为<strong>多态类型.</strong><br>
当我们在派生类中覆盖了某个虚函数时，可以再一次使用virtual 关键字指出该函数的性质。然而这么做并非必须，因为一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数。<br>
一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的<strong>形参类型</strong>必须与被它覆盖的<strong>基类函数完全一致</strong>。<br>
同样，派生类中虚函数的<strong>返回类型</strong>也必须<strong>与基类函数匹配</strong>该规则存在一个<strong>例外</strong>，当类的虚函数返回类型是<strong>类本身的指针或引用</strong>时，上述规则无效。<br>
派生类如果定义了一个函数与基类中虚函数的<strong>名字相同</strong>但是<strong>形参列表不同</strong>，这仍然是合法的行为。编译器将认为新定义的这个函数与基类中原有的函数是<strong>相互独立的</strong>。这时，派生类的函数并没有覆盖掉基类中的版本。就实际的编程习惯而言，这种声明往往意味着发生了错误，因为我们可能<strong>原本希望</strong>派生类<strong>能覆盖掉</strong>基类中的<strong>虚函数</strong>，但是<strong>一不小心把形参列表弄错了</strong>。要想调试并发现这样的错误显然非常团难。在 C ++11新标准中我们<strong>可以使用override 关键字来说明派生类中的虚函数</strong>。<br>
如果我们使用override 标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器将报错：<br>
我们还能把某个函数<strong>指定为 final</strong>,如果我们已经把函数定义成 final 了，则之后任何尝试覆盖该函数的操作都将引发错误<br>
final 和 override 说明符出现在形参列表（<strong>包括任何 const 或引用修饰符</strong>）以及<strong>尾置返回类型</strong>（参见6.3.3节，第206页）<strong>之后</strong><br>
<strong>虚函数</strong>也可以拥有<strong>默认实参</strong>（参见6.5.1节，第211页）。如果某次函数调用<strong>使用了默认实参</strong>，则该实参值由<strong>本次调用的静态类型决定</strong>。<br>
如果我们<strong>通过基类的引用或指针调用函数</strong>，则<strong>使用基类中</strong>定义的<strong>默认实参</strong>，即使实际运行的是<strong>派生类中</strong>的函数版本<strong>也是如此</strong>。此时，传入派生类函数的将是基类函数定义的默认实参。<br>
如果虚函数使用默认实参，则<strong>基类和派生类</strong>中定义的<strong>默认实参最好一致</strong>在某些情况下，我们希望对虚函数的调用<strong>不要进行动态绑定</strong>，而是<strong>强迫</strong>其执行虚函数的<strong>某个特定版本</strong>。使用<strong>作用域运算符</strong>可以实现这一目的，例如下面的代码：</p>
<p>通常情况下，<strong>只有成员函数（或友元</strong>中的代码才需要使用<strong>作用域运算符</strong>来<strong>回避虚函数机制</strong>通常是—个派生类的虚函数调用它<strong>覆盖的</strong>基类的虚函数版本时。在此情况下，<strong>基类的版本</strong>通常完成继承层次中<strong>所有类型都要做的共同任务</strong>，而<strong>派生类</strong>中定义的版本需要执行一些与<strong>派生类本身密切相关的操作</strong>。<br>
如果一个<strong>派生类虚函数</strong>需要调用它的<strong>基类版本</strong>，但是<strong>没有使用作用域运算符</strong>，则在运行时该调用将被<strong>解析为对派生类版本自身的调用</strong>，从而导致<strong>无限递归</strong></p>
<p>习题15.11</p>
<pre><code>void Quote::Debug() {
	cout &lt;&lt; &quot;bookNo is &quot; &lt;&lt; bookNo &lt;&lt; endl;
	cout &lt;&lt; &quot;price is &quot; &lt;&lt; price &lt;&lt; endl;
}

void Bulk_quote::Debug() {
	Quote::Debug();
	cout &lt;&lt; &quot;min_qty is &quot; &lt;&lt; min_qty &lt;&lt; endl;
	cout &lt;&lt; &quot;discount is &quot; &lt;&lt; discount &lt;&lt; endl;
}
</code></pre>
<p>注意：定义的时候不需要override符号，只需要在声明的时候加上去</p>
<p>习题15.12<br>
有，override是作为派生类针对基类虚函数的声明，而final是作为基类对派生类虚函数的声明<br>
习题15.13<br>
base的print是将自身的basename输出<br>
derived的print则是（希望）先调用了base的print在输出自身的i，但是没有使用作用域运算符会导致递归调用自身最后内存泄漏白给。<br>
习题15.14<br>
（a）调用base::print（b）调用derived::print（c）调用base::name（d）调用base::name 因为derived没有定义（e）调用base::print（f）调用derived::print</p>
<p>15.4抽象基类</p>
<p>我们根本就不希望用户创建一个新Disc_quote对象。我们可以将 net_price 定义成<strong>纯虚 (pure virtual )函数</strong>从而令程序实现我们的设计意图，这样做可以清晰明了地告诉用户当前这个 net_price 函数是没有实际意义的。和普通的虚函数不一样，一个纯虚函数无须定义。我们通过在函数体的位置（即在声明语句的分号之前）<strong>书写=0</strong>就可以将一个虚函数说明为纯虚函数。其中**，=0只能出现在类内部的虚函数声明语句处**：<br>
值得注意的是，我们也可以为纯虚函数提供定义，不过函数体<strong>必须定义在类的外部</strong>。 也就是说，我们不能在类的内部为一个=0的函数提供函数体。</p>
<p><strong>含有</strong>（或者<strong>未经覆盖</strong>直接继承）<strong>纯虚函数</strong>的类是<strong>抽象基类</strong> （abstractbaseclass )。抽象基类负责<strong>定义接口</strong>，而后续的其他类可以覆盖该接口。我们<strong>不能（直接）创建一个抽象基类的对象</strong>。<br>
Disc_quote的派生类<strong>必须给出自己的net _ price定义</strong>，否则它们<strong>仍将是抽象基类</strong>。<br>
这个版本的Bulk_quote的<strong>直接基类是Disc_quote</strong>,<strong>间接基类是Quote</strong>。每个Bulk_quote对象包含三个子对象：一个（空的）Bulk_quote部分、一个Disc_quote子对象和一个Quote子对象。</p>
<p><strong>重构</strong>负责重新设计类的体系以便将操作和/或数据从一个类移动到另一个类中。在Quote的继承体系中间增加Disc_quote类是重构的一个例子<br>
值得注意的是，即使我们<strong>改变了整个继承体系</strong>，那些使用了 Bulk_quote 或quote的代码也<strong>无须进行任何改动</strong>。不过<strong>一旦类被重构</strong>（或以其他方式被击变），说意味着我们<strong>必须重新编译含有这些类的代码了</strong>。</p>
<p>习题15.15</p>
<pre><code>class Disc_quote :public Quote {
public:
	Disc_quote() = default;
	Disc_quote(const string &amp;book, double price, size_t qty, double disc) :Quote(book, price), quantity(qty), discount(disc) {};
	double net_price(size_t)const = 0;
protected:
	size_t quantity = 0;
	double discount = 0.0;
};

class Bulk_quote :public Disc_quote {
public:
	Bulk_quote() = default;
	Bulk_quote(const string &amp;book, double price, size_t qty, double disc) :Disc_quote(book, price, qty, disc) {};
	double net_price(size_t)const override;
	void Debug();
};
</code></pre>
<p>习题15.16</p>
<pre><code>double Bulk_quote::net_price(size_t cnt)const {
	if (cnt &gt;= quantity)
		return cnt*(1 - discount)*price;
	else
		return cnt*price;
}
</code></pre>
<p>需要稍微修改一下参数<br>
习题15.17<br>
error C2259: “Disc_quote”: 不能实例化抽象类<br>
注意<strong>不能（直接）创建一个抽象基类的对象</strong>。</p>
<p>15.5访问控制与继承<br>
一个类使用 protected 关键字来声明那些它希望与<strong>派生类分享</strong>但是<strong>不想被其他公共访问使用的成员</strong>。 protected 说明符可以看做是** public 和 private 中和后<strong>的产物：<br>
•和私有成员类似，受保护的成员对于类的用户来说是不可访问的。</strong>（只能通过基类的非私有的成员函数来访问）**<br>
•和公有成员类似，受保护的成员对于<strong>派生类的成员和友元</strong>来说是可访问的。<br>
•派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权。</p>
<p>注意！！即派生类的成员和友元只能访问派生类对象中的<strong>基类部分（而不是指基类</strong>的受保护成员；对于普通的基类对象中的成员不具有特殊的访问权限。<br>
只能访问自己的protected</p>
<p>某个类对其继承而来的成员的<strong>访问权限</strong>受到两个因素影响：一是在<strong>基类</strong>中该成员的<strong>访问说明符</strong>，二是在派生类的<strong>派生列表</strong>中的<strong>访问说明符</strong>。</p>
<p><strong>派生访问说明符</strong>对于<strong>派生类的成员（及友元）<strong>能否访问其直接基类的成员</strong>没什么影响</strong>。<br>
派生访问说明符的<strong>目的</strong>是控<strong>制派生类用户</strong>（包括<strong>派生类的派生类</strong>在内）对于基类成员的访问权限：<br>
如果继承是公有的，则成员将遵循其原有的访问说明符，<br>
派生访问说明符还可以<strong>控制继承自派生类的新类</strong>的访问权限</p>
<p>假设我们之前还定义了一个名为Prot_Derv 的类，它采用<strong>受保护继承</strong>，则 Base 的所有公有成员在新定义的类中<strong>都是受保护的</strong>。</p>
<p>派生类向基类的转换（参见15.2.2节，第530页）是否可访问由使用<strong>该转换的代码决定</strong>，同时派生类的<strong>派生访问说明符也会有影响</strong>。假定 D 继承自 B :<br>
•只有当 D <strong>公有地继承</strong> B 时，用户代码<strong>才能使用派生类向基类的转换</strong>：如果 D 继承 B的方式是<strong>受保护的</strong>或者<strong>私有的</strong>，则用户代码<strong>不能使用该转</strong>换。<br>
•不论 D以什么方式继承 B ， D 的<strong>成员函数和友元</strong>都能使用<strong>派生类向基类的转换</strong>：派生类向其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的。<br>
•如果 D 继承 B 的方式是公有的或者受保护的，则 D 的派生类的成员和友元可以使用 D 向 B 的类型转换；反之，如果 D 维承 B 的方式是私有的，则不能使用。<br>
如果基类的公有成员是可访问的，则派生类向基类的类型转换也是可访问的；反之则不行。</p>
<p>就像友元关系不能传递一样（参见7.3.4节，第250页），<strong>友元关系同样也不能继承</strong>。<strong>基类的友元在访问派生类成员时不具有特殊性</strong>，类似的，派生类的友元也不能随意访问基类的成员：</p>
<p>J为Sneaky独有，prot_mem继承自Base，所以prot_mem是sneaky中的Base部分，可以被Base的友元访问<br>
当一个类将另一个类声明为友元时，这种<strong>友元关系只对做出声明的类有效</strong>。对于原來<br>
那个类来说，其友元的基类或者派生类不具有特殊的访问能力：<br>
<strong>不能继承友元关系</strong>；每个类负责控制<strong>各自成员</strong>的访问权限<br>
有时我们需要<strong>改变派生类继承的某个名字的访问级别</strong>，通过<strong>使用 using 声明</strong>（参见3.1节，第74页）可以达到这一目的：</p>
<p>通过在类的内部使用 using 声明语句，我们可以将该类的直接或间接基类中的任何可访问成员（例如，非私有成员）标记出来。</p>
<p>默认派生运算符（例如class derived：private base中的private）也由定义派生类所用的关键字来决定。默认情况下，使用 <strong>class 关键字</strong>定义的派生类是<strong>私有继承</strong>的；而使用 <strong>struct 关键字</strong>定义的派生类是<strong>公有继承</strong>的：<br>
在使用 struct 关键字和 class 关键字定义的类之间<strong>唯一的差别</strong>就是<strong>默认成员访问说明符</strong>及<strong>默认派生访问说明符</strong>;<br>
一个私有派生的类最好显式化将 private 指明出来，:而<strong>不要仅仅依赖于默认的设置</strong>。显式声明的好处是可以令私有继承关系清晰明了，不至于产生误会。</p>
<p>习题15.18<br>
第一句正确。第二句第三句不正确，只有公有继承才能进行转换，受保护或私有的继承不可以进行向基类的转换<br>
四五六同理<br>
习题15.19<br>
123句正确 46句正确 5句错误<br>
习题15.20</p>
<pre><code>class Base { public:void memfcn(Base &amp;b) { b = *this; } };
class Pub_Derv :public Base { public:void memfcn(Base &amp;b) { b = *this; } };
class Priv_Derv :private Base { public:void memfcn(Base &amp;b) { b = *this; } };
class Prot_Derv :protected Base { public:void memfcn(Base &amp;b) { b = *this; } };
class Derived_from_Public :public Pub_Derv { public:void memfcn(Base &amp;b) { b = *this; } };
class Derived_from_private :public Priv_Derv { public:void memfcn(Base &amp;b) { b = *this; } };
class Derived_from_protected :public Prot_Derv { public:void memfcn(Base &amp;b) { b = *this; } };

int main()
{
	Base d;
	Pub_Derv d1;
	Priv_Derv d2;
	Prot_Derv d3;
	Derived_from_Public dd1;
	Derived_from_private dd2;
	Derived_from_protected dd3;
	Base *p = &amp;d1;
	p = &amp;d2;
	p = &amp;d3;
	p = &amp;dd1;
	p = &amp;dd2;
	p = &amp;dd3;
	d.memfcn(d);
	d1.memfcn(d);
	d2.memfcn(d);
	d3.memfcn(d);
	dd1.memfcn(d);
	dd2.memfcn(d);
	dd3.memfcn(d);
}
</code></pre>
<p>习题15.21 15.22<br>
上面的题其实就是了</p>
<p>习题感悟<br>
注意：定义的时候不需要override符号，只需要在声明的时候加上去<br>
注意<strong>不能（直接）创建一个抽象基类的对象</strong>。同时：<strong>含有</strong>（或者<strong>未经覆盖</strong>直接继承）<strong>纯虚函数</strong>的类就是<strong>抽象基类</strong></p>
]]></content>
    </entry>
</feed>