<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-03-01T12:08:45.153Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>In the darkest night,Rising like a spire.</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[流量控制滑动窗口与MSS、MTU]]></title>
        <id>https://lixin-scut.github.io//post/liu-liang-kong-zhi-hua-dong-chuang-kou-yu-mssmtu</id>
        <link href="https://lixin-scut.github.io//post/liu-liang-kong-zhi-hua-dong-chuang-kou-yu-mssmtu">
        </link>
        <updated>2020-03-01T08:38:07.000Z</updated>
        <content type="html"><![CDATA[<h3 id="tcp接收窗口字段">TCP接收窗口字段</h3>
<p>每个TCP报文头部有16比特的接收窗口字段，表明接收端可用缓存空间的大小，报文段发送方在相反方向上可接受的最大序列号值为TCP头部中ACK号和窗口大小字段之和。<br>
可以通过窗口缩放因子(Window Scaling)选项增大窗口。</p>
<h3 id="tcp流量控制服务">TCP流量控制服务</h3>
<p>消除发送方使接收方缓存溢出的可能性，亦即速度匹配服务.即发送方的发送速率与接收方应用程序的读取速率相四配<br>
流量控制和拥塞控制采取的动作非常相似，但然是针对完全不同的原因而采取的措施<br>
TCP通过让发送方维护一个称为接收窗口的变量来提供流量控制<br>
接收窗口用于给发送方一个指示——该接收方还有多少可用的缓存空间<br>
<img src="https://lixin-scut.github.io//post-images/1583052025198.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1583052027872.png" alt=""><br>
空间是随着时间变化的.所以rwnd是动态的<br>
服务器通过把当前的rwnd值放入发给客户端的报文段接收窗口字段中，从而提供流量控制服务<br>
通过将未确认的数据铍控制在值rwnd以内，就可以保证主机A不会使主机B的接收缓存溢出，因此主机A在该连接的整个生命周期须保证<br>
LastByteSent-LastByteAcked&lt;=rwnd<br>
当主机B的接收窗口为0时.主机A继续发送只有一个字节数据的报文段，防止rwnd=0后，服务器有空闲却无法发送修改rwnd的回执（TCP规定服务器仅在它有数据或有确认要发时才会发送报文段给主机A）</p>
<h3 id="mss与mtu">MSS与MTU</h3>
<p>MSS:TCP报文的数据字段的最大长度（不包含TCP首部）<br>
MTU:IP首部+TCP报文<br>
MSS保证一个TCP报文段加上TCP/IP首部长度（通常40字节）将适合单个链路层帧<br>
TCP首部20字节，IP首部20字节，<br>
MTU一般为1500，所以MSS为1460.</p>
<p>MTU: 链路层帧能承载的最大数据量叫做最大传送单元（MaximumTransmissionUnit)，是OSI五层网络模型中链路层(datalink layer)对一次可以发送的最大数据的限制。</p>
<p>以太网帧的数据字段（46 -1500字节）承载了IP数据报，以太网的最大传输单元 (MTU)是1500 字节这意味符，如果IP数据报超过1500字节.则主机必须将该数据报分片，数据字段的最小长度是46字节：这意味着如果IP数据报小于46字节，数据报必须被填充到46字节，当采用填充时，传递到网络层的数据包括IP数据报和填充部分网络层使用IP数据报首部中的长度字段来去除填充部分</p>
<p>MSS: 是Maximum Segement Size缩写，表示TCP报文中data部分的最大长度，是TCP协议在OSI五层网络模型中传输层对一次可以发送的最大数据的限制。</p>
<p>当需要传输的数据大于MSS或者MTU时，数据会被拆分成多个包进行传输。由于MSS是根据MTU计算出来的，因此当发送的数据满足MSS时，必然满足MTU。</p>
<h3 id="糊涂窗口综合征">糊涂窗口综合征</h3>
<p>基于窗口的流量控制机制，尤其是不使用大小固定的报文段的情况,可能会出现称为糊涂窗口综合征（Silly Window Syndrome, SWS）的缺陷。当出现该问题时，交换数据段大小不是全长的而是一些较小的数据段。由于每个报文段中有用数据相对 于头部信息的比例较小，因此耗费的资源也更多，相应的传输效率也更低。<br>
TCP连接的两端都可能导致SWS的出现：接收端的通告窗口较小（没有等到窗口变大才通告），或者发送端发送的数据段较小（没有等待将其他数据组合成一个更大的报文段）。 要避免SWS问题，必须在发送端或接收端实现相关规则。TCP无法提前预知某一端的行为。<br>
需要遵循以下规则：</p>
<ol>
<li>对于接收端来说，不应通告小的窗口值。描述的接收算法中，在窗口可增 至一个全长的报文段（即接收端MSS）或者接收端缓存空间的一半（取两者中较小者）之前, 不能通告比当前窗口（可能为0）更大的窗口值。注意到可能有两种情况会用到该规则：当 应用程序处理接收到的数据后使得可用缓存增大，以及TCP接收端需要强制返回对窗口探 测的响应。</li>
<li>对于发送端来说，不应发送小的报文段，而且需由Nagle算法控制何时发送。为避免 SWS问题，只有至少满足以下条件之一时才能传输报文段：<br>
（a）	全长（发送MSS字节）的报文段可以发送。<br>
（b）	数据段长度N接收端通告过的最大窗口值的一半的，可以发送。<br>
（c）	满足以下任一条件的都可以发送：（i）某一 ACK不是目前期盼的（即没有未经确认的在传数据）;（ii）该连接禁用Nagle算法。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浏览器打开一个网页的全过程]]></title>
        <id>https://lixin-scut.github.io//post/liu-lan-qi-da-kai-yi-ge-wang-ye-de-quan-guo-cheng</id>
        <link href="https://lixin-scut.github.io//post/liu-lan-qi-da-kai-yi-ge-wang-ye-de-quan-guo-cheng">
        </link>
        <updated>2020-03-01T06:54:51.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>域名解析：浏览器获得URL地址，向操作系统请求该URL对应的IP地址，操作系统查询DNS获得对应的IP地址</li>
<li>确认好了IP和端口号，则可以向该IP地址对应的服务器的该端口号发起TCP连接请求</li>
<li>IP协议指定了出发地（客户端）和目的地（服务器），网络层的路由器选择算法决定了会经过那些路由器（OSPF与BGP），链路层的ARP协议负责求下一个节点的MAC地址（不止是要目的地，还要中间节点的地址）。</li>
<li>服务器接收到TCP连接请求后，回复可以连接请求，</li>
<li>浏览器收到回传的数据后，还会向服务器发送数据包，表示三次握手结束</li>
<li>三次握手成功后，开始通讯，根据HTTP协议的要求，组织一个请求的数据包，里面包含请求的资源路径、你的身份信息等，例如，<code>www.abc.com/images/1/</code>表示的资源路径是<code>images/1/</code>，发送后，服务器响应请求，将数据返回给浏览器，数据可以是根据HTML协议组织的网页，里面包含页面的布局、文字等等，也可以是图片或者脚本程序等，如果资源路径指定的资源不存在，服务器就会返回404错误，如果返回的是一个页面，则根据页面里的一些外链URL地址，重复上述步骤，再次获取</li>
<li>渲染页面，并开始响应用户的操作</li>
<li>窗口关闭时，通过四次挥手终止与服务器的连接</li>
</ol>
<p>关于1中的细节：<br>
  URL可分割成几个部分：协议、网络地址、资源路径<br>
  协议：指从该计算机获取资源的方式，常见的是HTTP、FTP<br>
  网络地址：可以是域名或者是IP地址，也可以包括端口号，如果不注明端口号，默认是80端口<br>
  如果地址不是一个IP地址，则需要通过DNS（域名系统）将该地址解析成IP地址，IP地址对应着网络上的一台计算机，DNS服务器本身也有IP，本机网络设置包含DNS服务器的IP。<br>
DNS查找过程：<br>
  首先主机会查询本地HOST文件，然后查询DNS的缓存，如果没有就给本地DNS发送查询请求。DNS查询分为两种方式，一种是递归查询，一种是迭代查询。如果是迭代查询，本地的DNS服务器，向根域名服务器发送查询请求，根域名服务器告知该域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到查询到该域名的IP地址。DNS服务器是基于UDP的，因此会用到UDP协议。<br>
  例如递归查询中，<code>www.abc.com</code>不是一个IP，则需要向DNS询问请求<code>www.abc.com</code>对应的IP，获得IP，在这个过程中，你的电脑直接询问DNS服务器可能没有发现<code>www.abc.com</code>对应的IP，就会向它的上级服务器询问，这样依次一层层向上级找，最高可达根节点，直到找到或者全部找不到为止<br>
  端口号不同的窗口负责不同的服务，如果输入<code>www.abc.com:8080/</code>，则表示不使用默认的80端口，而使用指定的8080端口</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[直接插入排序]]></title>
        <id>https://lixin-scut.github.io//post/zhi-jie-cha-ru-pai-xu</id>
        <link href="https://lixin-scut.github.io//post/zhi-jie-cha-ru-pai-xu">
        </link>
        <updated>2020-03-01T01:00:54.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://lixin-scut.github.io/post/pai-xu-suan-fa/">排序算法及其实现</a></p>
<p>  直接插入排序算法 直接插入排序(StraightInsertionSort)的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表。</p>
<pre><code>class StraightInsertionSort
{
public:
    void StraightInsertionSort0(vector&lt;int&gt; &amp;numbers);
};

void StraightInsertionSort::StraightInsertionSort0(vector&lt;int&gt; &amp;numbers) {
    int len = numbers.size();
    int i;
    int j;
    for (i = 1; i &lt; len; ++i)
    {
        if(numbers[i] &lt; numbers[i-1])
        {
            int temp = numbers[i];
            for (j = i - 1; j&gt;=0 &amp;&amp; numbers[j] &gt; temp; --j)
            {
                    numbers[j + 1] = numbers[j];
            }
            numbers[++j] = temp;
        }
    }
    print(numbers);
}
</code></pre>
<p>时间复杂度：<br>
<img src="https://lixin-scut.github.io//post-images/1583028460111.png" alt=""></p>
<p>我一开始的实现：</p>
<pre><code>    void StraightInsertionSort::StraightInsertionSort0(vector&lt;int&gt; &amp;numbers) {
        int len = numbers.size();
        for (int i = 1; i &lt; len; ++i) {  // i和j可以放到循环外定义
            int temp = numbers[i];   // 必须设置哨兵
            int j;
            for (j = i - 1; j &gt;= 0; --j) {
                if (numbers[j] &gt; temp)  // 这里其实可以放到循环头内，所见代码
                {
                    numbers[j + 1] = numbers[j];
                }
                else
                {
                    break; // 通过把前面的判断放到循环里，这一部分可以省略
                }
            }
            numbers[++j] = temp; // 记得递增
        }
        print(numbers);
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[简单选择排序]]></title>
        <id>https://lixin-scut.github.io//post/jian-dan-xuan-ze-pai-xu</id>
        <link href="https://lixin-scut.github.io//post/jian-dan-xuan-ze-pai-xu">
        </link>
        <updated>2020-03-01T00:57:43.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://lixin-scut.github.io/post/pai-xu-suan-fa/">排序算法及其实现</a></p>
<p>  排序时找到合适的关键字再做交换，并且只移动一次就完成相应关键字的排序定位工作，这就是选择排序法的初步思想。<br>
  选择排序的基本思想是毎一趟在n-i+1(i=1,2,...,n-1)个记录中选取关键字最小的记录作为有序序列的第i个记录。</p>
<pre><code>void SimpleSelectionSort::SimpleSelectionSort0(vector&lt;int&gt; &amp;numbers)
{
    int len = numbers.size();
    for (int i = 0; i &lt; len; ++i)
    {
        int min = i;
        for(int j = i+1; j &lt; len; ++j)
        {
            if(numbers[min] &gt; numbers[j]) // 注意为了保证稳定，一定不能包含等于
            {
                min = j;
            }
        }
        if(min != i)
						swap(numbers[min],numbers[i]);
    }
    print(numbers);
}
</code></pre>
<p>  简单选择排序法(SimpleSelectionSort) 就是通过 n-1次关键字间的比较,从n-i+1个记录中选出关键字最小的记录，并和第i(1 &lt;= i &lt;= n)个记录交换之。</p>
<p>复杂度分析：<br>
<img src="https://lixin-scut.github.io//post-images/1582940921126.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582940933596.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 交换排序&冒泡排序]]></title>
        <id>https://lixin-scut.github.io//post/jiao-huan-pai-xu-andmou-pao-pai-xu</id>
        <link href="https://lixin-scut.github.io//post/jiao-huan-pai-xu-andmou-pao-pai-xu">
        </link>
        <updated>2020-03-01T00:53:06.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://lixin-scut.github.io/post/pai-xu-suan-fa/">排序算法及其实现</a></p>
<p>  冒泡排序(BubbleSort)—种交换排序，它的基本思想是:两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止</p>
<pre><code>// SortFunc.h
class BubbleSort{
public:
    // 改进版冒泡排序
    void BubbleSort2(vector&lt;int&gt; &amp;numbers);

    // 最简单（正宗）的冒泡排序
    void BubbleSort1(vector&lt;int&gt; &amp;numbers);

    // 本质是交换排序
    void BubbleSort0(vector&lt;int&gt; &amp;numbers)
};
</code></pre>
<pre><code>// BubbleSort.cpp
// 交换排序
void BubbleSort::BubbleSort0(vector&lt;int&gt; &amp;numbers)
{
    int len = numbers.size();
    for (int i = 0; i &lt; len; ++i)
    {
        for(int j = i+1 ; j &lt; len; ++j)
        {
            if(numbers[i] &gt; numbers[j])
            {
                int temp = numbers[i];
                numbers[i] = numbers[j];
                numbers[j] = temp;
            }
        }
    }
    print(numbers);
}
</code></pre>
<p>  这段代码严格意义上说，不算是标准的冒泡排序算法，因为它不满足两两比较相邻记录的冒泡排序思想，它更应该是最最简单的交换排序而已。它的思路就是让每一个关 键字，都和它后面的每一个关键字比较，如果大则交换，这样第一位置的关键字在一次循环后一定变成最小值。<br>
  这个简单易懂的代码，却是有缺陷的。排序好位置的数字对其余关键字的排序没有什么帮助，甚至有可能将原本靠前的数字搬移到数组后面。</p>
<pre><code>// BubbleSort.cpp
// 最简单（正宗）的冒泡排序
void BubbleSort::BubbleSort1(vector&lt;int&gt; &amp;numbers)
{
    for(int i=0; i&lt;numbers.size(); ++i)
    {
        for(int j=numbers.size()-1; j&gt;i; --j)
        {
            if(numbers[j] &lt; numbers[j-1])
            { swap(numbers[j],numbers[j-1]); }
        }
    }
    print(numbers);
}
</code></pre>
<p>  对比交换排序，冒泡排序的排序好位置的数字对其余关键字的排序也有帮助，其他数字的位置也会相应上升。</p>
<pre><code>// 改进版冒泡排序
void BubbleSort::BubbleSort2(vector&lt;int&gt; &amp;numbers)
{
    bool flag = true;
    for(int i=0; i&lt;numbers.size(); ++i)
    {
        for(int j=numbers.size()-1; j&gt;i; --j)
        {
            if(numbers[j] &lt; numbers[j-1])
            {
                swap(numbers[j],numbers[j-1]);
                flag = false;
            }
        }
        if(flag)
        { break; }
    }
    print(numbers);
}
</code></pre>
<p>  代码改动的关键就是在i变量的for循环中，增加了对flag是否为true的判断。经过这样的改进，冒泡排序在性能上就有了一些提升，可以避免因已经有序的情况下的无意义循环判断。</p>
<p>复杂度分析<br>
<img src="https://lixin-scut.github.io//post-images/1582858448862.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 题37:序列化二叉树]]></title>
        <id>https://lixin-scut.github.io//post/shu-ti-37xu-lie-hua-er-cha-shu</id>
        <link href="https://lixin-scut.github.io//post/shu-ti-37xu-lie-hua-er-cha-shu">
        </link>
        <updated>2020-03-01T00:30:09.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>  请实现两个函数，分别用来序列化和反序列化二叉树<br>
  二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。<br>
  二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p>
</blockquote>
<p>这道题是leetcode有原题的 <a href="https://lixin-scut.github.io/post/shu-297-er-cha-shu-de-xu-lie-hua-yu-fan-xu-lie-hua-kun-nan/">树 297. 二叉树的序列化与反序列化[困难]</a>，所以来看一下书本的题解吧</p>
<p>书本题解：</p>
<blockquote>
<p> 我们知道可以从前序遍历序列 和中序遍历序列中构造出一棵二叉树。受此启发，我们可以先把一棵二叉树序列化成一个前序遍历序列和一个中序遍历序列，然后在反序列化时通过这两个序列重构出原二叉树。<br>
 这种思路有两个缺点：一是该方法要求二叉树中不能有数值重复的节点；二是只有当两个序列中所有数据都读出后才能开始反序列化。如果两 个遍历序列的数据是从一个流里读出来的，那么可能需要等待较长的时间。<br>
 实际上，如果二叉树的序列化是从根节点开始的，那么相应的反序列化在根节点的数值读出来的时候就可以开始了。因此，我们可以根据前序遍历的顺序来序列化二叉树，因为前序遍历是从根节点开始的。在遍历二叉树碰到nullptr指针时，这些nullptr指针序列化为一个特殊的字符（如'<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;&amp;&#039; at position 33: …个特殊字符(如&#039;,&#039;)隔开。
&amp;̲emsp;反序列化时，当下一个…'>&#039;）。 另外，节点的数值之间要用一个特殊字符(如&#039;,&#039;)隔开。
&amp;emsp;反序列化时，当下一个字符是</span>,这表明节点的右子节点为nullptr指针。这个节点的左、右子树都已经构建完毕，接下来回到根节点，反序列化根节点的右子树。</p>
</blockquote>
<pre><code>void Serialize(const BinaryTreeNode* pRoot, ostream&amp; stream)
{
    if(pRoot == nullptr)
    {
        stream &lt;&lt; &quot;$,&quot;;
        return;
    }

    stream &lt;&lt; pRoot-&gt;m_nValue &lt;&lt; ',';
    Serialize(pRoot-&gt;m_pLeft, stream);
    Serialize(pRoot-&gt;m_pRight, stream);
}

bool ReadStream(istream&amp; stream, int* number)
{
    if(stream.eof())
        return false;

    char buffer[32];
    buffer[0] = '\0';

    char ch;
    stream &gt;&gt; ch;
    int i = 0;
    while(!stream.eof() &amp;&amp; ch != ',')
    {
        buffer[i++] = ch;
        stream &gt;&gt; ch;
    }

    bool isNumeric = false;
    if(i &gt; 0 &amp;&amp; buffer[0] != '$')
    {
        *number = atoi(buffer);
        isNumeric = true;
    }

    return isNumeric;
}

void Deserialize(BinaryTreeNode** pRoot, istream&amp; stream)
{
    int number;
    if(ReadStream(stream, &amp;number))
    {
        *pRoot = new BinaryTreeNode();
        (*pRoot)-&gt;m_nValue = number;
        (*pRoot)-&gt;m_pLeft = nullptr;
        (*pRoot)-&gt;m_pRight = nullptr;

        Deserialize(&amp;((*pRoot)-&gt;m_pLeft), stream);
        Deserialize(&amp;((*pRoot)-&gt;m_pRight), stream);
    }
}
</code></pre>
<blockquote>
<p> 函数ReadStream每次从流中读出一个数字或者一个字符当从流中读出的是一个数字时，函数返回true：否则返回false。<br>
  如果总结前面序列化和反序列化的过程，就会发现我们都是把二义树分解成3部分：根节点、左子树和右子树。我们在处理(序列化或反序列化)它的根节点之后再分别处理它的左、右子树。这是典型的把问题递归分解然后逐个解决的过程。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 题36:二叉搜索树与双向链表[未做出]]]></title>
        <id>https://lixin-scut.github.io//post/shu-ti-36er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/shu-ti-36er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-wei-zuo-chu">
        </link>
        <updated>2020-02-29T23:57:21.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
</blockquote>
<pre><code>/*
struct TreeNode {
 int val;
 struct TreeNode *left;
 struct TreeNode *right;
 TreeNode(int x) :
   val(x), left(NULL), right(NULL) {
 }
};*/
</code></pre>
<p>第一想法是使用迭代的中序遍历法，但是这样需要额外的栈<br>
知道是中序遍历，但是没想好类似于叶子结点这些特殊结点应该怎么连接。</p>
<pre><code>class Solution {
public:
    //【未做出】
    TreeNode* Convert(TreeNode* pRootOfTree)
    {
        TreeNode *pLastNodeInList=NULL;
        ConvertNode(pRootOfTree,&amp;pLastNodeInList);
        
        TreeNode *pHeadOfList=pLastNodeInList;
        while(pHeadOfList!=NULL&amp;&amp;pHeadOfList-&gt;left!=NULL)
            pHeadOfList=pHeadOfList-&gt;left;
        
        return pHeadOfList;
    }
    
    void ConvertNode(TreeNode *pNode,TreeNode **pLastNodeInList){
        if(pNode==NULL)
            return;
        TreeNode *pCurrent=pNode;
        
        if(pCurrent-&gt;left!=NULL)
            ConvertNode(pCurrent-&gt;left,pLastNodeInList);
  
        pCurrent-&gt;left=*pLastNodeInList;
        if(*pLastNodeInList!=NULL)
          (*pLastNodeInList)-&gt;right=pCurrent;
        
        *pLastNodeInList=pCurrent;
        
        if(pCurrent-&gt;right!=NULL)
            ConvertNode(pCurrent-&gt;right,pLastNodeInList);
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>  在二叉树中，每个节点都有两个指向子节点的指针。在双向链表中，每个节点也有两个指针，分别指向前一个节点和后一个节点。由于这两种节点的结构相似，同时二义搜索树也是一种排序的数据结构，因此，在理论上有可能实现二义搜索树和排序双向链表的转换。在搜索二叉树中，左 子节点的值总是小于父节点的值，右子节点的值总是大于父节点的值。因此，我们在将二叉搜索树转换成排序双向链表时，原先指向左子节点的指针调整为链表中指向前一个节点的指针，原先指向右子节点的指针调整为链表中指向后一个节点的指针。接下来我们考虑该如何转换。<br>
  由于要求转换之后的链表是排好序的，我们可以中序遍历树中的每个节点，这是因为中序遍历算法的特点是按照从小到大的顺序遍历二叉树的每个节点。当遍历到根节点的时候，我们把树看成3部分：值为10的节点: 根节点值为6的左子树；根节点值为14的右子树。根据排序链表的定义, 值为10的节点将和它的左子树的最大一个节点（值为8的节点）链接起 来，同时它还将和右子树最小的节点（值为12的节点）链接起来。<br>
  在把左、右子树都转换成排序双向链表之后再和根节点链接起来，整棵二叉搜索树也就转换成了排序双向链表<br>
  按照中序遍历的顺序，当我们遍历转换到根节点(值为10的节点)时， 它的左子树已经转换成一个排序的链表了，并且处在链表中的最后一个节 点是当前值最大的节点。我们把值为8的节点和根节点链接起来，此时链 表中的最后一个节点就是10 了。接着我们去遍历转换右子树，并把根节点 和右子树中最小的节点链接起来。至于怎么去转换它的左子树和右子树， 由于遍历和转换过程是一样的，我们很自然地想到可以用递归。</p>
</blockquote>
<pre><code>BinaryTreeNode* Convert(BinaryTreeNode* pRootOfTree)
{
    BinaryTreeNode *pLastNodeInList = nullptr;
    ConvertNode(pRootOfTree, &amp;pLastNodeInList);

    // pLastNodeInList指向双向链表的尾结点，
    // 我们需要返回头结点
    BinaryTreeNode *pHeadOfList = pLastNodeInList;
    while(pHeadOfList != nullptr &amp;&amp; pHeadOfList-&gt;m_pLeft != nullptr)
        pHeadOfList = pHeadOfList-&gt;m_pLeft;

    return pHeadOfList;
}

void ConvertNode(BinaryTreeNode* pNode, BinaryTreeNode** pLastNodeInList)
{
    if(pNode == nullptr)
        return;

    BinaryTreeNode *pCurrent = pNode;

    if (pCurrent-&gt;m_pLeft != nullptr)
        ConvertNode(pCurrent-&gt;m_pLeft, pLastNodeInList);

    pCurrent-&gt;m_pLeft = *pLastNodeInList; 
    if(*pLastNodeInList != nullptr)
        (*pLastNodeInList)-&gt;m_pRight = pCurrent;

    *pLastNodeInList = pCurrent;

    if (pCurrent-&gt;m_pRight != nullptr)
        ConvertNode(pCurrent-&gt;m_pRight, pLastNodeInList);
}
</code></pre>
<blockquote>
<p>  代码中，我们用pLastNodelnList指向已经转换好的链表的最后一个节点（值最大的节点）。当我们遍历到值为10的节点的时候，它的左子树都已经转换好了，因此pLastNodelnList指向值为8的节点。接着把根节点链接到链表中之后，值为10的节点成了链表中的最后一个节点（新的值最大的节点），于是pLastNodelnList指向了这个值为10的节点。接下来把pLastNodelnList作为参数传入函数递归遍历右子树。我们找到右子树 中最左边的子节点（值为12的节点，在右子树中值最小），并把该节点和值为10的节点链接起来。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Connector]]></title>
        <id>https://lixin-scut.github.io//post/connector</id>
        <link href="https://lixin-scut.github.io//post/connector">
        </link>
        <updated>2020-02-29T12:39:19.000Z</updated>
        <content type="html"><![CDATA[<p>  主动发起连接比被动接受连接要复杂一些，一方面是错误处理麻烦，另一方面是要考虑重试。在非阻塞网络编程中，发起连接的基本方式是调用connect(2),当 socket变得可写时表明连接建立完毕。当然这其中要处理各种类型的错误，因此我们把它封装为Connector类。<br>
  Connector只负责建立socket连接，不负责创建TcpConnection,它的NewConnectionCallback 回调的参数是socket文件描述符。</p>
<p>Connector的实现有几个难点：<br>
  • socket是一次性的，一旦出错(比如对方拒绝连接)，就无法恢复，只能关闭重来。但Connector是可以反复使用的，因此每次尝试连接都要使用新的socket文件描述符和新的Channel对象。要留意Channel对象的生命期管理，并防止socket文件描述符泄漏。<br>
  •错误代码与accept(2)不同，EAGAIN是真的错误，表明本机ephemeral port 暂时用完，要关闭socket再延期重试。“正在连接”的返回码是EINPROGRESSo 另外，即便出现socket可写，也不一定意味着连接已成功建立，还需要用 getsockopt(sockfd, SOL_SOCKET, SO_ERROR, ...)再次确认一下。<br>
  •重试的间隔应该逐渐延长，例如0.5s、Is、2s、4s,直至30s,即back-off。这会造成对象生命期管理方面的困难，如果使用EventLoop:: runAfter()定时而 Connector在定时器到期之前可能会析构<br>
  •要处理自连接(self-connection )o出现这种状况的原因如下。在发起连接的时候，TCP/IP协议栈会先选择source IP和source port，在没有显式调用bind(2)的情况下，source IP由路由表确定，source port由TCP/IP协议栈从local port range 中选取尚未使用的port (即临时端口ephemeral port)。如果destination IP正好是本机，而destination port位于local port range,且没有服务程序监听的话,  临时端口可能正好选中了 destination port,这就出现(source IP, source port) = (destination IP, destination port)的情况，即发生了自连接。处理办法是断开连接再重试，否则原本侦听destinaHon port的服务进程也无法启动了。</p>
<p>TimerQueue::cancel()<br>
  为了防止Connector在定时器到期之前析构，TimerQueue使用cancel()注销定时器<br>
  一种实现是用shared_ptr来管理Timer对象，再将TimerId定义为<code>weak_ptr&lt;Timer&gt;</code>,但用shared_ptr来管理Timer对象似乎显得有点小题大做，而且这种做法也有一个小小的缺点，如果用户一直持有Timerld,会造成引用计数所占的内存无法释放。<br>
  最后采用更传统的方式，保持现有的设计，让Timerld包含Timer*。但这是不够的，因为无法区分地址相同的先后两个Timer对象。因此每个Timer对象有一个全局递增的序列号int64_t sequence.(用原子计数器(Atomiclnt64 )生成)，TimerId 同时保存 Timer* 和 sequence,这样 TimerQueue::cancel()就能根据 TimerId找到需要注销的Timer对象。</p>
<p>  cancel()有对应的 cancelInLoop()函数，因此 TimerQueue 不必用锁。TimerQueue新增了几个数据成员，activeTimers_存的是目前有效的Timer的指针，并 满足 invariant： timers., size。== activeTimers_.size(),因为这两个容器保存的是相同的数据，只不过timers_是按到期时间排序，activeTimers_是按对象地址排序。<br>
  由于TimerId不负责Timer的生命期，其中保存的Timer* 可能失效，因此不能直接dereference,只有在activeTimers_中找到了Timer时才能提领。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关键字extern]]></title>
        <id>https://lixin-scut.github.io//post/guan-jian-zi-extern</id>
        <link href="https://lixin-scut.github.io//post/guan-jian-zi-extern">
        </link>
        <updated>2020-02-29T00:34:08.000Z</updated>
        <content type="html"><![CDATA[<p>  分离式编译 将程序分割为若干个文件，每个文件可以被独立编译。.<br>
  声明 仅规定变量的类型和名字<br>
  定义 创建与名字关联的实体，申请存储空间 并赋初始值声明关键字 extern<br>
  如果含有初始化的话就等于定义，抵消了extern的作用，同时试图初始化由extern标记的已定义变量会引发错误<br>
  定义能且只能被定义一次，但可以被多次声明</p>
<pre><code>int j; // 声明并定义  
extern int j; // 声明  
extern int j=1; // 定义
</code></pre>
<p>  const 常量关键字，const对象一旦创建后就不能改变值，所以const对象必须初始化<br>
  默认状态下 const对象仅在文件内有效，添加extern关键字就可以分享使用，但共享const定义之前必须添加extern关键词，因为const必须在声明的同时被定义</p>
<pre><code>// file1.cc
extern const int Size = fcn();

// file2.cc
extern const int Size;
</code></pre>
<p>  当编译器遇到 extern 模板声明时，它不会在本文件中生成实例化代码。将一个实例化声明为 extern 就表示承诺在程序其他位置有该实例化的一个非 extern 声明（定义）。对于一个给定的实例化版本，可能有多个 extern 声明，但必须只有一个定义。<br>
  由编译器在使用一个模板时自动对其实例化，因此 extern 声明必须出现在任何使用此实例化版本的代码之前：</p>
<p>链接指示：extern&quot;C&quot;<br>
  C++使用链接指示（linkage directive)指出任意非C++函数所用的语言。<br>
  要想把C++代码和其他语言（包括C语言）编写的代码放在一起使用，要求我们必须有权访问该语言的编译器，并且这个编译器与当前的C++编译器是兼容的</p>
<p>声明一个非C++的函数<br>
  链接指示可以有两种形式：单个的或复合的。链接指示不能出现在类定义或函数定义的内部。同样的链接指示必须在函数的每个声明中都出现。<br>
  链接指示的第一种形式包含一个关键字extern.后面是一个字符串字面值常量以及一个 &quot;普通的&quot;函数声明。<br>
  其中的字符串字面值常量指出了编写函数所用的语言。编译器应该支持对C语言的链 接指示。此外，编译器也可能会支持其他语言的链接指示，如extern&quot;Ada&quot;、extern &quot;FORTRAN&quot;等。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 题35:复杂链表的复制]]></title>
        <id>https://lixin-scut.github.io//post/lian-biao-ti-35fu-za-lian-biao-de-fu-zhi</id>
        <link href="https://lixin-scut.github.io//post/lian-biao-ti-35fu-za-lian-biao-de-fu-zhi">
        </link>
        <updated>2020-02-28T23:56:18.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
</blockquote>
<pre><code>/*
struct RandomListNode {
    int label;
    struct RandomListNode *next, *random;
    RandomListNode(int x) :
            label(x), next(NULL), random(NULL) {
    }
};
</code></pre>
<p>  一开始我想着每次遇到未存在节点就都创建新节点（包括next和random）并存进hashmap里面去<br>
  但是后面发现这样很麻烦，每次都要对next和random判断是否存在，并且如果next已存在的话进一步又要特殊处理<br>
  所以不如先循环一次构造next，把所有节点构造出来，然后再循环利用hashmap链接random</p>
<pre><code>*/
class Solution {
public:
    //不需要额外空间的办法[未做出]
    RandomListNode* Clone(RandomListNode* pHead){
        if(pHead==NULL)
            return NULL;
        
        RandomListNode *cur=pHead;
        RandomListNode *temp;
        while(cur){
            temp=new RandomListNode(cur-&gt;label);
            temp-&gt;next=cur-&gt;next;
            cur-&gt;next=temp;
            cur=temp-&gt;next;
        }
        
        cur=pHead;
        while(cur){
            cur-&gt;next-&gt;random=cur-&gt;random-&gt;next;
            cur=cur-&gt;next-&gt;next;
        }
        
        cur=pHead;
        RandomListNode *CloneHead;
        RandomListNode *CloneNode;
        
        CloneHead=pHead-&gt;next;
        CloneNode=pHead-&gt;next;
        cur-&gt;next=CloneNode-&gt;next;
        cur=cur-&gt;next;
        
        while(cur){
            CloneNode-&gt;next=cur-&gt;next;
            CloneNode=CloneNode-&gt;next;
            cur-&gt;next=CloneNode-&gt;next;
            cur=cur-&gt;next;
        }
        return CloneHead;
    }
    /*
    // hashmap映射方法
    RandomListNode* Clone(RandomListNode* pHead)
    {
        
        if(pHead==NULL)
            return NULL;
        unordered_map&lt;RandomListNode*,RandomListNode*&gt; node_map;
        RandomListNode *pre=pHead-&gt;next;
        RandomListNode *cur=new RandomListNode(pHead-&gt;label);
        node_map.insert(make_pair(pHead,cur));
        RandomListNode *newnode;
        while(pre!=NULL){
            newnode = new RandomListNode(pre-&gt;label);
            cur-&gt;next=newnode;
            cur=cur-&gt;next;
            node_map.insert(make_pair(pre,cur));
            pre=pre-&gt;next;
        }
        pre=pHead;
        cur=node_map[pre];
        while(pre!=NULL){
            cur-&gt;random=node_map[pre-&gt;random];
            cur=cur-&gt;next;
            pre=pre-&gt;next;
        }
        return node_map[pHead];
    }
    */
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>  在复杂链表的节点中，除了有指向下一个节点的指针(实线箭头), 还有指向任意节点的指针<br>
  分为两步：第一步仍然是复制原始链表 上的每个节点N创建N'然后把这些创建出来的节点用m_pNext链接起来。 同时我们把＜N,N'＞的配对信息放到一个哈希表中；第二步还是设置复制链 表上每个节点的m_pSibling。如果在原始链表中节点N的m_pSibling指向节点S,那么在复制链表中，对应的N'，应该指向S'由于有了哈希表，我 们可以用O⑴的时间根据S找到S'。<br>
  相当于用空间换时间。对于有n个节点的链表，我们需要 一个大小为O(n)的哈希表，也就是说我们以O(n)的空间消耗把时间复杂度 由O(n^2)降低到O(n)<br>
  接下来我们再换一种思路，在不用辅助空间的情况下实现O(n)的时间效率。<br>
第三种方法的第一步仍然是根据原始链表的每个节点N创建对应的N'这一次，我们把N'链接在N的后面。<br>
  第二步设置复制出来的节点的m_pSibling。假设原始链表上的N的m_pSibling指向节点S,那么其对应复制出来的N，是N的m_pNext指向的节点，同样S'也是S的m_pNext指向的节点。<br>
  第三步把这个长链表拆分成两个链表：把奇数位置的节点用m_pNext 链接起来就是原始链表，把偶数位置的节点用m_pNext链接起来就是复制 出来的链表。</p>
</blockquote>
<pre><code>ComplexListNode* Clone(ComplexListNode* pHead)
{
    CloneNodes(pHead);
    ConnectSiblingNodes(pHead);
    return ReconnectNodes(pHead);
}

void CloneNodes(ComplexListNode* pHead)
{
    ComplexListNode* pNode = pHead;
    while(pNode != nullptr)
    {
        ComplexListNode* pCloned = new ComplexListNode();
        pCloned-&gt;m_nValue = pNode-&gt;m_nValue;
        pCloned-&gt;m_pNext = pNode-&gt;m_pNext;
        pCloned-&gt;m_pSibling = nullptr;
 
        pNode-&gt;m_pNext = pCloned;
 
        pNode = pCloned-&gt;m_pNext;
    }
}

void ConnectSiblingNodes(ComplexListNode* pHead)
{
    ComplexListNode* pNode = pHead;
    while(pNode != nullptr)
    {
        ComplexListNode* pCloned = pNode-&gt;m_pNext;
        if(pNode-&gt;m_pSibling != nullptr)
        {
            pCloned-&gt;m_pSibling = pNode-&gt;m_pSibling-&gt;m_pNext;
        }
 
        pNode = pCloned-&gt;m_pNext;
    }
}

ComplexListNode* ReconnectNodes(ComplexListNode* pHead)
{
    ComplexListNode* pNode = pHead;
    ComplexListNode* pClonedHead = nullptr;
    ComplexListNode* pClonedNode = nullptr;
 
    if(pNode != nullptr)
    {
        pClonedHead = pClonedNode = pNode-&gt;m_pNext;
        pNode-&gt;m_pNext = pClonedNode-&gt;m_pNext;
        pNode = pNode-&gt;m_pNext;
    }
 
    while(pNode != nullptr)
    {
        pClonedNode-&gt;m_pNext = pNode-&gt;m_pNext;
        pClonedNode = pClonedNode-&gt;m_pNext;
 
        pNode-&gt;m_pNext = pClonedNode-&gt;m_pNext;
        pNode = pNode-&gt;m_pNext;
    }
 
    return pClonedHead;
}
</code></pre>
]]></content>
    </entry>
</feed>