<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2020-02-13T10:05:47.085Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[位运算 题15:二进制中1的个数[未做出]]]></title>
        <id>https://lixin-scut.github.io//post/wei-yun-suan-ti-15er-jin-zhi-zhong-1-de-ge-shu-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/wei-yun-suan-ti-15er-jin-zhi-zhong-1-de-ge-shu-wei-zuo-chu">
        </link>
        <updated>2020-02-13T03:13:14.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
</blockquote>
<p>重点就在于不要把n直接右移，因为负数的右移会自动补1，同时把1往左移其实也是固定循环次数的，用4字节的int只会循环32次。<br>
然后就是书本题解中的减1相与法很值得学习。</p>
<pre><code>class Solution {
public:
     int  NumberOf1(int n) {
         //【未做出】
         int count=0;
         
         while(n){
             ++count;
             n=(n-1)&amp;n;
         }
         return count;
         /*
         //注意位运算符返回右值，必须再赋值。。。和算术符号一样的
         //然后判断条件比较有趣，如果将数字视为二进制的话那么位数一定是固定的（int的位数）
         //而不是说数字越大位数越大，所以不需要将判断条件改为i和n的大小判断，直接等i左移到变为0即可
         int count=0;
         int i=1;
         while(i){
             if(n&amp;i)
                 ++count;
             i=i&lt;&lt;1;
         }
         return count;
         */
     }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>只要把整数和1做位与运算看结果是不是0就知道了<br>
如果直接将目标数字n进行右移，当输入一个负数，比如0x80000000,则运行的时候当把负数 0x80000000右移一位的时候，并不是简单地把最高位的1移到第二位变成 0x40000000,而是0xC0000000。这是因为移位前是一个负数，仍然要保证 移位后是一个负数，因此移位后的最高位会设为1。如果一直做右移运算， 那么最终这个数字就会变成0xFFFFFFFF而陷入死循环。<br>
为了避免死循环，我们可以不右移输入的数字n。首先把n和1做与运算，判断n的最低位是不是为1。接着把1左移一位得到2,再和n做与运算，就能判断n的次低位是不是1……这样反复左移，每次都能判断n的其中一位是不是1。</p>
</blockquote>
<pre><code>int NumberOf1_Solution1(int n)
{
    int count = 0;
    unsigned int flag = 1;
    while (flag)
    {
        if (n &amp; flag)
            count++;

        flag = flag &lt;&lt; 1;
    }

    return count;
}
</code></pre>
<blockquote>
<p>同时我们发现把一个整数减去1，都是把最右边的1变成0。如果它的右边还有0,则所有的0都变成1，而它左边的所有位都保 持不变。接下来我们把一个整数和它减去1的结果做位与运算，相当于把它最右边的1变成0。<br>
把上面的分析总结起来就是：把一个整数减去1,再和原整数做与运 算，会把该整数最右边的1变成0。那么一个整数的二进制表示中有多少个1， 就可以进行多少次这样的操作。</p>
</blockquote>
<pre><code>int NumberOf1_Solution2(int n)
{
    int count = 0;

    while (n)
    {
        ++count;
        n = (n - 1) &amp; n;
    }

    return count;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[哈希表hash table]]></title>
        <id>https://lixin-scut.github.io//post/ha-xi-biao</id>
        <link href="https://lixin-scut.github.io//post/ha-xi-biao">
        </link>
        <updated>2020-02-12T11:39:23.000Z</updated>
        <content type="html"><![CDATA[<p>《C++ primer》<br>
新标准定义了4个无序关联容器，无序容器不是使用比较运算符来组织元素，而是使用一个哈希函数，和关键字类型的<mark>运算符<br>
如果关键字类型固有就是无序的，或者性能测试发现问题可以用哈希技术解决，就可以使用无序容器<br>
无序容器提供了与有序容器相同的操作（find、insert等），所以unordered_map和unordered_set也可以使用这些操作<br>
无序容器也有允许重复关键字的版本<br>
通常可以用一个无序容器替换对相应的有序容器，反之亦然<br>
无序容器在存储组织上为一组桶，每个桶保存零个或多个元素，无序容器使用一个哈希函数将元素映射到桶，容器首先计算元素的哈希值，并将具有一个特定哈希值的所有元素都保存在相同的桶中，所有具有相同关键字的元素都会在同一个桶中，因此无序容器的性能依赖于哈希函数的质量和桶的数量和大小<br>
对于相同的参数，哈希函数总是产生相同的结果<br>
将不同关键字映射到相同的桶也是允许的，当一个桶保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个<br>
<img src="https://lixin-scut.github.io//post-images/1581507740082.png" alt=""><br>
默认情况下无序容器使用关键字类型的</mark>运算符来比较元素，还是用一个hash&lt;key_type&gt;类型来生成每个元素的哈希值，标准库为内置类型包括指针提供了hash模板</p>
<p>《STL源码剖析》<br>
C++的STL中set和map使用了红黑树作为基层机制<br>
而unordered_set unordered_map使用了hashtable作为底层机制，初始化时可以向hashtable定义equal函数<br>
hashtable可以视为一种键值的字典结构，使用hash function散列函数来进行映射<br>
负载系数（loading factor）：元素的个数除以表格大小<br>
当单个位置空间满载，只能进行循环向下查找和惰性删除<br>
hashtable的buckets聚合体以vector完成，以利动态扩充，同时hashtable使用28个质数来设计表格大小<br>
然后bucket中不是使用STL的list，而是自己维护一个hashtable node，类似于forward_list，有value和next指针<br>
hashtable自定义了迭代器，只有++和==等操作，没有后退的操作，也没有逆向迭代器<br>
在++递增操作中，如果当前节点恰巧是链表最后一个节点，就通过buk_num寻找下一个bucket<br>
hashtable的bkt_num()定义了hash function来计算元素位置<br>
每个bucket的最大容量和buckets_vector的大小相同<br>
新节点在链表的头部插入<br>
注意hashtable并没有自动排序功能，所以hash表内的元素并无特定顺序<br>
有些元素无法直接拿来对hashtable的大小进行模运算，就需要bkt_num函数进行预处理，<br>
hash set 和 hash multiset的区别在于前者使用insert_unique，后者使用insert_equal。</p>
<p>解决哈希冲突<br>
1.线性探测<br>
2.二次探测<br>
3.开链</p>
<p>一致性哈希了解吗<br>
一致性哈希算法将整个哈希值空间映射成一个虚拟的圆环，整个哈希空间的取值范围为0<sub>2^32-1。整个空间按顺时针方向组织。0</sub>2^32-1在零点中方向重合。接下来使用如下算法对服务请求进行映射，将服务请求使用哈希算法算出对应的hash值，然后根据hash值的位置沿圆环顺时针查找，第一台遇到的服务器就是所对应的处理请求服务器。当增加一台新的服务器，受影响的数据仅仅是新添加的服务器到其环空间中前一台的服务器（也就是顺着逆时针方向遇到的第一台服务器）之间的数据，其他都不会受到影响。综上所述，一致性哈希算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性</p>
<p>3.哈希表实现<br>
知道哈希表吗，怎么解决冲突，如果只有 32 个槽，怎么存放几千个数据。<br>
开链</p>
<p>哈希表?怎么进行查找数据?<br>
首先转化键值，然后计算哈希值，再在相应的bucket中顺序查找（哈希冲突 开拉链法 也可以把链表换成红黑树）<br>
注意char* const char* 都是通过h=5 * h+* s转化为size_t 其他数值类型也是转化为size_t</p>
<p>哈希数据结构?如何 rehash?<br>
STL的rehash比较简单，就是判断每个bucket的元素数量和vector的大小对比，如果前者大于后者的话就需要resize（rehash），rehash也比较简单，直接重新计算每个元素的落点然后头部插入<br>
比较有趣的是redis的渐进式hash</p>
<p>hash 冲突，写拉链法代码</p>
<pre><code>pair&lt;hashtable::iterator,bool&gt; insert_unique_noresize(const value_type&amp; obj){
const size_type n=bkt_num(obj)
for(node* cur=first;cur;cur=cur-&gt;next)
	if(equal(get_key(cur-&gt;val),get_key(obj)))
		return pair&lt;iterator,bool&gt;(iterator(cur,this),false);
node* tmp=new_node(obj);
tmp-&gt;next=first;
buckets[n]=tmp;
++num_elements;
return pair&lt;iterator,bool&gt;(iterator(tmp,this),true);
}
</code></pre>
<p>如果是unordered_multiset，则先寻找有没有相同值，有的话立即插入，如果没有的话就回到头部插入</p>
<p>如何解决 Hash 表碰撞问题<br>
Hash碰撞冲突<br>
我们知道，对象Hash的前提是实现equals()和hashCode()两个方法，那么HashCode()的作用就是保证对象返回唯一hash值，但当两个对象计算值一样时，这就发生了碰撞冲突。</p>
<p>1.开放地址法<br>
开放地执法有一个公式:Hi=(H(key)+di) MOD m i=1,2,…,k(k&lt;=m-1)<br>
其中，m为哈希表的表长。di 是产生冲突的时候的增量序列。如果di值可能为1,2,3,…m-1，称线性探测再散列。<br>
如果di取1，则每次冲突之后，向后移动1个位置.如果di取值可能为1,-1,2,-2,4,-4,9,-9,16,-16,…k<em>k,-k</em>k(k&lt;=m/2)，称二次探测再散列。<br>
如果di取值可能为伪随机数列。称伪随机探测再散列。</p>
<p>2.再哈希法<br>
当发生冲突时，使用第二个、第三个、哈希函数计算地址，直到无冲突时。缺点：计算时间增加。<br>
比如上面第一次按照姓首字母进行哈希，如果产生冲突可以按照姓字母首字母第二位进行哈希，再冲突，第三位，直到不冲突为止</p>
<p>3.链地址法（拉链法）<br>
将所有关键字为同义词的记录存储在同一线性链表中。</p>
<p>4.建立一个公共溢出区<br>
假设哈希函数的值域为[0,m-1],则设向量HashTable[0..m-1]为基本表，另外设立存储空间向量OverTable[0..v]用以存储发生冲突的记录。</p>
<p>如何改善 Hash 表性能<br>
哈希表性能优化的方法有很多，比如：<br>
使用双 hash 检索冲突<br>
使用开放+封闭混合寻址法组织哈希表<br>
使用跳表快速定位冲突<br>
使用 LRU 缓存最近访问过的键值，不管表内数据多大，短时内访问的总是那么几个<br>
使用更好的分配器来管理 key_value_pair 这个节点对象<br>
封闭寻址+平衡二叉树</p>
<p>load factor较小时，添加元素时很容易找到空的bucket，hash冲突少（因为可用的空bucket很多），存储性能较高；已装元素的bucket少，很容易从中找到指定的元素，查找性能较高；但遍历集合（hash表）时，要过滤掉大量的空bucket，很花时间，所以遍历时比较慢。<br>
当load factor达到设置的负载极限时，会发生rehashing（重哈希/再散列），hash表会自动成倍地增加容量（capacity），将原有的元素都移到新的hash表中（会重新分配存储位置），而此时原有的元素是极多的，这会增加很大的开销。<br>
负载极限设置较高时，节省内存（空桶较少），但添加、查找元素效率较低，时间开销会增大；负载极限较低时，添加、查找元素效率较高，但会增加内存开销。默认为0.75，是时间、空间的折中，我们可根据需要自行设置。<br>
如果我们一开始就知道要存储的元素个数，可以在创建hash表时就指定容量：元素总数/负载极限。这样避免了rehashing，节省了时间开销。且前中期hash表负载会很低，添加、查询效率极高。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++中的关键字 static ]]></title>
        <id>https://lixin-scut.github.io//post/czhong-de-guan-jian-zi-static</id>
        <link href="https://lixin-scut.github.io//post/czhong-de-guan-jian-zi-static">
        </link>
        <updated>2020-02-12T10:55:19.000Z</updated>
        <content type="html"><![CDATA[<p>《C++ primer》<br>
局部静态对象 static 直到程序终止时才被销毁，在此期间就算函数执行结束也不会对它产生影响（可以用来计算函数调用次数）<br>
值初始化除了在值初始化过程中可能进行之外，也可以单独作用于静态（或者线程局部）变量： static T object;</p>
<p>类的静态成员<br>
static 静态成员 与类关联，而与特定的对象无关（等于每个对象都可以通用的成员）所以静态成员应该在类外定义，否则每创建一个对象就会被定义一次<br>
静态成员可以是private或者public，静态数据成员的类型可以是常量、引用、指针、类类型等等。<br>
类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据，同时静态成员函数也不与任何对象绑定在一起，不包含this 指针，不能被声明为const<br>
使用作用域运算符来直接访问静态成员，也可以使用类的对象、引用或者指针来访问<br>
成员函数不用通过作用域运算符就能直接使用静态成员<br>
静态成员函数也可以在类外部进行定义，但不能重复static关键字，static只出现在类内部的声明语句<br>
静态成员不是由类的构造函数初始化的，不能在类的内部初始化静态成员，必须在类的外部定义和初始化每个静态成员<br>
一个静态数据成员只能定义一次<br>
静态数据成员定义在任何函数之外，因此存在于程序的整个生命周期中<br>
把静态数据成员的定义和其他非内联函数的定义放在同一个文件中，确保对象只定义一次<br>
例外：可以在类内部初始化constexpr的静态成员，但必须提供const整数类型的类内初始值（常量表达式） 例如 static constexpr int i =10;//必须是constexpr，不能是const<br>
如果仅仅用于类内，则在类内已经初始化的const或者constexpr static不需要分别定义，否则必须有一条定义语句<br>
特别地，静态数据成员的类型可以是它所属的类类型（等于不完全类型），而非静态数据成员只能声明成它所属的类的指针或引用<br>
静态成员可以作为默认实参，非静态数据成员则不能。</p>
<p>静态内存用于保存局部static对象、类static数据成员以及定义在任何函数之外的变量</p>
<p>模板所有实例类型都共享相同的static成员（包括数据成员和函数乘以）<br>
类似任何其他成员函数，一个 static 成员函数只有在使用时才会实例化。</p>
<p>static_cast 只要不包含底层const都能用 例如把void*指针的值找回来</p>
<p>博客：<br>
全局静态变量<br>
　　在全局变量前加上关键字static，全局变量就定义成一个全局静态变量.<br>
　　静态存储区，在整个程序运行期间一直存在。<br>
　　初始化：未经初始化的全局静态变量会被自动初始化为0(自动对象的值是任意的，除非他被显式初始化);<br>
　　作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。</p>
<p>局部静态变量<br>
　　在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。<br>
　　内存中的位置：静态存储区<br>
　　初始化：未经初始化的全局静态变量会被自动初始化为0(自动对象的值是任意的，除非他被显式初始化);<br>
　　作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变;</p>
<p>静态函数<br>
　　在函数返回类型前加static，函数就定义为静态函数。普通函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。<br>
　　函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突;<br>
　　warning：不要在头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰;</p>
<p>类的静态成员<br>
　　在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用</p>
<p>类的静态函数<br>
　　静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名，只需要类名。<br>
　　在静态成员函数的实现中不能直接引用类中说明的非静态成员（因为类可能都还没有对象，自然也无法对非静态成员进行构造），可以引用类中说明的静态成员(这点非常重要)。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;);<br>
如果函数调用的结果不会访问或者修改任何对象（非static）数据成员，这样的成员声明为静态成员函数比较好</p>
<p>static 变量初始化<br>
未经初始化的全局静态变量和局部静态变量都会被自动初始化为0</p>
<p>static与const和extern的关系<br>
这两个关键字可以一起使用,当一起使用时,它们的先后顺序是没有限制的,谁在前面都一样,const是指常量,static则表示静态变量,它们一起使用时则表示一个静态常量.<br>
当你声明一个变量并初始化后,你不想在后面的程序中对该变量进行修改的话,你就可以用const修饰符来修饰它,它告诉编译器这是一个常量,如果你对常量作了修改,编译的时候就会通不过,而静态变量则是在你声明之后,这个变量就一直常驻内存,直到程序结束它才会被销毁,例如你在一个自定义函数中定义了一个静态变量,当这个函数被调用结束,它里的静态变量依然存在,当第二次调用该函数时,这个变量并不会重新被分配内存,它的值则是上一次调用后它的值.</p>
<p>在全局范围和局部范围声明时在内存的分布情况<br>
int i=1024<br>
static int i=1024<br>
都是定义在静态存储区</p>
<p>static 和全局变量<br>
全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。</p>
<p>Static 关键字，可以在头文件中声明吗<br>
可以，但是不应该，#include的话，展开之后相当于static在main中仍然是可见的。你把static放在.h文件中是无意义的，且很容易被重复引用而形成重复定义。正确的做法是在.c中定义全局变量，而在.h中用extern引出全局变量，当然static变量是无法extern的。</p>
<p>如何在另一个文件里面使用本文件中的 static 变量或函数?<br>
利用可在本文件调用的属性，另加一个函数fun，fun调用该static函数；其他文件调用fun即可</p>
<p>Static 和 extern 的优先级谁高<br>
static更高，不可以对static的变量或者函数使用extern关键词，先出现 extern 后出现 static 是不行的，先出现 static 后出现 extern 则为 static</p>
<p>2.const static 用法<br>
static<br>
    作用：修饰变量、函数<br>
    变量<br>
     全局变量：修饰的全局变量，指定其内部链接，也就是只能本文件使用。<br>
     局部变量：修饰的局部变量，改变其生命周期，并不会修改其作用域。<br>
     成员变量：只属于类，不属于对象。使用的适合可以通过类名或者对象引用。修饰的成员变量必须在类外单独初始化，如果同时被const 修饰则可以在定义的适合进行初始化。<br>
    函数<br>
      普通函数：修饰的普通函数，指定其内部链接，也就是只能本文可见。<br>
     类成员函数：静态成员函数只属于类，不属于对象。没有this指针，所以它不能访问非静态成员函数 ，和非静态成员变量。 它是用来处理静态成员数据，如果我们非要使用静态成员函数访问非静态成员函数或者非静态成员变量，我们可以间接使用类进行引用。</p>
<p>const<br>
     用法：修饰变量，参数，返回值。 C++中的const关键字的用法非常灵活，而使用const将大大改善程序的健壮性。const 允许指定语义约束，告诉编译器哪些变量是不可以改变的。<br>
     修饰变量：C语言中const将一个变量转化为常变量，存储在静态文本段，只有读取权限，C++中同样会将一个变量转化成常量，C++会对其进行优化，将其放入寄存器中，如果想去内存中读取该数据时，我们可以使用volatile关键字进行修饰，保证其可见性。<br>
     修饰指针变量： 如果const位于* 左侧时，不能修改指针所指的对象<br>
                               如果const位于* 右侧时，不能修改指针的指向，所以必须初始化。<br>
     修饰参数：作用是原参数在该函数中不可被改变。<br>
     修饰的返回值：也是用const来修饰返回的指针或引用，保护指针指向的内容或引用的内容不被修改，也常用于运算符重载。归根究底就是使得函数调用表达式不能作为左值。<br>
     修饰成员变量：该变量只能在初始化列表里初始化。<br>
     修饰成员函数：在成员函数后面加上const,const修饰this指针所指的的对象，也就是保证调用该成员函数的对象，在成员函数内部不会改变。（改变权限，权限可缩小，但是不可扩大）</p>
<p>3.在头文件里面声明一个 static 变量，在两个不同的 cpp 里面#include 这个变量有没有问题<br>
在一个头文件中声明static 类对象， 会为所有include该头文件的cpp都创建一个同名的全局对象，只不过它们是相互独立的。<br>
但是普通全局变量的话就只能有一个定义，否则会引发重复定义</p>
<p>自己做的小实验：</p>
<pre><code>//static_data.h
static int si;
extern int i;


//func.cpp
#include &quot;static_data.h&quot;
void func(){

    ++si;
    cout&lt;&lt;si&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;endl;
}

//main.cpp
#include &quot;static_data.h&quot;

void func();

int i=0;// i must be modified here and modified once;
int main() {
    //int i=10;//this will cover i 
    //++si;
    ++i;
    cout&lt;&lt;si&lt;&lt;&quot; &quot;&lt;&lt;i++&lt;&lt;endl;
    func();
}
</code></pre>
<p>输出结果：</p>
<pre><code>0 1
1 2
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[排序算法]]></title>
        <id>https://lixin-scut.github.io//post/pai-xu-suan-fa</id>
        <link href="https://lixin-scut.github.io//post/pai-xu-suan-fa">
        </link>
        <updated>2020-02-12T05:13:04.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://lixin-scut.github.io//post-images/1581492677786.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 题14:剪绳子[未做出][贪心]]]></title>
        <id>https://lixin-scut.github.io//post/dong-tai-gui-hua-ti-14jian-sheng-zi-wei-zuo-chu-tan-xin</id>
        <link href="https://lixin-scut.github.io//post/dong-tai-gui-hua-ti-14jian-sheng-zi-wei-zuo-chu-tan-xin">
        </link>
        <updated>2020-02-12T04:05:22.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],...,k[m]。请问k[0]xk[1]x...xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
</blockquote>
<p>我一开始用的是贪心法，就是单纯地不断取3<br>
但是这是有问题的，因为如果最后剩余的是4的话，应该取2x2而不是3x1<br>
然后动态规划就是要注意特殊例子，因为动态规划把两边都是为一个整体，但是题目要求必须剪一刀，比如3取1和2的时候，2在动态规划数组中是1，就会导致结果等于1</p>
<pre><code>class Solution {
public:
    int cutRope(int number) {
        //动态规划；
        if(number&lt;2)
            return 0;
        //注意着两个特殊例子无法去除，因为动态规划中这两个特殊例子应视为一个整体
        if(number==2)
            return 1;
        if(number==3)
            return 2;
        vector&lt;int&gt; count(number+1,0);
        count[1]=1;
        count[2]=2;
        count[3]=3;
        for(int i=4;i&lt;number+1;++i)
            for(int j=1;j&lt;=i/2;++j)
                count[i]=max(count[i],count[j]*count[i-j]);
        return count.back();
        /*
        //贪心算法
        if(number&lt;1)
            return 0;
        if(number==2)
            return 1;
        if(number==3)
            return 2;
        
        //注意可以直接*4，但是可读性有点差
        if(number%3==1)
            return pow(3,(number/3)-1)*2*2;
        else 
            return pow(3,(number/3))*(number%3);
            
        //这里其实是错误的，如果剪完3之后剩下的是4，不应该再剪3了，应该剪2+2，不知道为何通过了
        //return pow(3,(number/3))*(number%3);
        */
    }
};
</code></pre>
<p>书本题解:</p>
<blockquote>
<p>动态规划<br>
首先定义函数f(n)为把长度为n的绳子剪成若干段后各段长度乘积的最 大值。在剪第一刀的时候，我们有n-1种可能的选择，也就是剪出来的第 一段绳子的可能长度分别为1,2,...,n-1因此f(n)=max(f(i)xf(n-i)),其中 0&lt;i&lt;n。<br>
这是一个从上至下的递归公式。由于递归会有很多重复的子问题，从 而有大量不必要的重复计算。一个更好的办法是按照从卜而上的顺序计算, 也就是说我们先得到f(2)、f(3),再得到f(4)、f(5),直到得到f(n)。<br>
当绳子的长度为2时，只可能剪成长度都为1的两段，因此f(2)等于1 当绳子的长度为3时，可能把绳子剪成长度分别为1和2的两段或者长度都为1的三段，由于1x2&gt;1x1x1,因此f(3)=2<br>
在上述代码中，产问题的最优解存储在数组products里。<br>
为了求解f(i)，我们需要求 出所有可能的并比较得出它们的最大值。这就是代码中第二个for循环的功能。</p>
</blockquote>
<pre><code>int maxProductAfterCutting_solution1(int length)
{
    if(length &lt; 2)
        return 0;
    if(length == 2)
        return 1;
    if(length == 3)
        return 2;

    int* products = new int[length + 1];
    products[0] = 0;
    products[1] = 1;
    products[2] = 2;
    products[3] = 3;

    int max = 0;
    for(int i = 4; i &lt;= length; ++i)
    {
        max = 0;
        for(int j = 1; j &lt;= i / 2; ++j)
        {
            int product = products[j] * products[i - j];
            if(max &lt; product)
                max = product;

            products[i] = max;
        }
    }

    max = products[length];
    delete[] products;

    return max;
}
</code></pre>
<blockquote>
<p>贪婪算法<br>
如果我们按照如下的策略来剪绳子，则得到的各段绳子的长度的乘积将最大：当n&gt;=5时，我们尽可能多地剪长度为3的绳子；当剩下的绳子长度为4时，把绳子剪成两段长度为2的绳子。<br>
这种思路的正确性证明：首先，当n&gt;=5的时候，我们可以 证明2(n-2)&gt;n并且3(n-3)&gt;n。也就是说，当绳子剩下的长度大于或者等于 5的时候，我们就把它剪成长度为3或者2的绳子段。另外，当n&gt;=5时， 3(n-3)&gt;=2(n-2),因此我们应该尽可能地多剪长度为3的绳子段。<br>
前面证明的前提是n&gt;=5。那么当绳子的长度为4呢？在长度为4的绳子上剪一刀，有两种可能的结果：剪成长度分别为1和3的两根绳子，或 者两根长度都为2的绳子。注意到2X2&gt;1X3,同时2X2=4,也就是说，当绳子长度为4时其实没有必要剪，只是题目的要求是至少要剪一刀。</p>
</blockquote>
<pre><code>int maxProductAfterCutting_solution2(int length)
{
    if(length &lt; 2)
        return 0;
    if(length == 2)
        return 1;
    if(length == 3)
        return 2;

    // 尽可能多地减去长度为3的绳子段
    int timesOf3 = length / 3;

    // 当绳子最后剩下的长度为4的时候，不能再剪去长度为3的绳子段。
    // 此时更好的方法是把绳子剪成长度为2的两段，因为2*2 &gt; 3*1。
    if(length - timesOf3 * 3 == 1)
        timesOf3 -= 1;

    int timesOf2 = (length - timesOf3 * 3) / 2;

    return (int) (pow(3, timesOf3)) * (int) (pow(2, timesOf2));
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[网络库：事件EventLoop]]></title>
        <id>https://lixin-scut.github.io//post/wang-luo-ku-eventloop</id>
        <link href="https://lixin-scut.github.io//post/wang-luo-ku-eventloop">
        </link>
        <updated>2020-02-11T13:39:35.000Z</updated>
        <content type="html"><![CDATA[<p>网络库，其核心是事件循环和事件分发器Eventloop<br>
每个线程只能有一个EventLoop实体，负责IO和定时器事件的分派，用eventfd来异步唤醒。用TimerQueue来作为计时器管理，用Poller作为IO multiplexing</p>
<p>与EventLoop相关的类<br>
1.EventLoopThread：新建一个专门用于EventLoop的线程，在其中运行EventLoop::loop()<br>
2.EventLoopThreadPool：muduo默认多线程IO模型，新到的连接会按round-robin方式分配到线程池</p>
<p>EventLoop包含的成员：Channel、Poller、TimerQueue</p>
<p>同时用户是可以看到EventLoop的</p>
<p>实现过程中需要注意的点<br>
1.EventLoop是不可拷贝的，继承了boost::noncopyable<br>
2.构造函数会记住本对象所属的线程<br>
3.创建了EventLoop对象的线程是IO线程，主要功能是运行事件循环EventLoop::loop()。<br>
4.EventLoop对象的生命期和其所属线程一样长，所以不必是动态创建的heap对象<br>
5.EventLoop的static成员函数getEventLoopOfCurrentThread()返回EventLoop对象<br>
6.EventLoop提供了isInLoopThread()和assertInLoopThread()等函数，用于运行时检查成员函数是否是线程安全的（可以跨线程调用），哪些成员函数只能在某个特定线程调用（主要是IO线程），而事件循环必须在IO线程执行</p>
<p>我的代码和muduo的代码差异：<br>
1.isInLoopThread()和assertInLoopThread()是public的，同时额外需要privare的abortNotInLoopThread进行线程终止<br>
2.然后额外需要bool looping_和threadId_两个数据成员<br>
3.ifndef 预编译<br>
4.头文件缺失，同时头文件中需要包含路径 例如#include &quot;main/base/Mutex.h&quot;<br>
5.命名空间<br>
6.前向声明 Channel Poller Timerqueue等</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 题13:机器人的运动范围]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-ti-13ji-qi-ren-de-yun-dong-fan-wei</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-ti-13ji-qi-ren-de-yun-dong-fan-wei">
        </link>
        <updated>2020-02-10T15:41:35.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
</blockquote>
<p>第一想法还是用bool二位矩阵记录是否计算了某个点<br>
然后突然想着说不能直接循环行和列吗？<br>
然后突然发现一个问题，就是不是所有符合条件的格子都能到达的，<br>
比如（100，100）看起来只有1+1=2，但是不可能从（99，99）到达这个点</p>
<p>其实我这个方法只能算递归，而且使用引用的递归，可以看看书中返回非引用的方法<br>
其中对于范围的判断可以交给不同的地方，我这里是借用了visited的size来进行判断，所以无法像书中在check中进行判断<br>
然后利用关系运算符的判断顺序很重要，一定要先判断范围是否越界了，否则下标运算符会报错</p>
<pre><code>class Solution {
public:
    int movingCount(int threshold, int rows, int cols)
    {
        int count=0;
        vector&lt;vector&lt;bool&gt;&gt; visited(rows,vector&lt;bool&gt;(cols,false));
        visitCount(threshold,0,0,count,visited);
        return count;
    }
    
    void visitCount(int threshold,int rows,int cols,int &amp;count,vector&lt;vector&lt;bool&gt;&gt; &amp;visited){
        if(rows&gt;=visited.size()
           ||cols&gt;=visited[0].size()
           ||visited[rows][cols]
           ||!CheckThre(threshold,rows,cols))
            return;
        ++count;
        visited[rows][cols]=true;
        visitCount(threshold,rows-1,cols,count,visited);
        visitCount(threshold,rows,cols-1,count,visited);
        visitCount(threshold,rows+1,cols,count,visited);
        visitCount(threshold,rows,cols+1,count,visited);
        return;
    }
    
    bool CheckThre(int threshold,int rows,int cols){
        int res=0;
        while(rows)
            res+=rows%10,rows/=10;
        while(cols)
            res+=cols%10,cols/=10;
        return res&lt;=threshold;
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>机器人从坐标(0.0)开始移动。当它准备进入坐标为(i,j)的格子时，通过 检查坐标的数位和来判断机器人是否能够进入。如果机器人能够进入坐标 为(i,j)的格子,则再判断它能否进入4个相邻的格子(i-1,j)、(i,j-1)、(i,j+1) 和(i+1,j),因此，我们可以用如下的代码来实现回溯算法：</p>
</blockquote>
<pre><code>int movingCount(int threshold, int rows, int cols)
{
    if(threshold &lt; 0 || rows &lt;= 0 || cols &lt;= 0)
        return 0;

    bool *visited = new bool[rows * cols];
    for(int i = 0; i &lt; rows * cols; ++i)
        visited[i] = false;

    int count = movingCountCore(threshold, rows, cols,
        0, 0, visited);

    delete[] visited;

    return count;
}

int movingCountCore(int threshold, int rows, int cols, int row,
    int col, bool* visited)
{
    int count = 0;
    if(check(threshold, rows, cols, row, col, visited))
    {
        visited[row * cols + col] = true;

        count = 1 + movingCountCore(threshold, rows, cols,
            row - 1, col, visited)
            + movingCountCore(threshold, rows, cols,
                row, col - 1, visited)
            + movingCountCore(threshold, rows, cols,
                row + 1, col, visited)
            + movingCountCore(threshold, rows, cols,
                row, col + 1, visited);
    }

    return count;
}

bool check(int threshold, int rows, int cols, int row, int col,
    bool* visited)
{
    if(row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; cols
        &amp;&amp; getDigitSum(row) + getDigitSum(col) &lt;= threshold
        &amp;&amp; !visited[row* cols + col])
        return true;

    return false;
}

int getDigitSum(int number)
{
    int sum = 0;
    while(number &gt; 0)
    {
        sum += number % 10;
        number /= 10;
    }

    return sum;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 题12:矩阵中的路径]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-ti-12ju-zhen-zhong-de-lu-jing</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-ti-12ju-zhen-zhong-de-lu-jing">
        </link>
        <updated>2020-02-10T02:43:05.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串&quot;bcced&quot;的路径，但是矩阵中不包含&quot;abcb&quot;路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
</blockquote>
<p>这道题在牛客网上挺恶心的，char *是一位数组，它把矩阵首尾相连了。。。我强行化为了二维vector</p>
<pre><code>class Solution {
public:
    bool hasPath(char* matrix, int rows, int cols, char* str){
        vector&lt;vector&lt;char&gt;&gt; matrixv(rows,vector&lt;char&gt;(cols,' '));
        for(int i=0;i&lt;rows;++i)
            for(int j=0;j&lt;cols;++j)
                matrixv[i][j]=matrix[i*cols+j];
        vector&lt;vector&lt;bool&gt;&gt; bool_matrix(rows,vector&lt;bool&gt;(cols,true));
        for(int i=0;i&lt;rows;++i)
            for(int j=0;j&lt;cols;++j)
                if(FindPath(matrixv,i,j,str,0,bool_matrix))
                   return true;
        return false;
    }

    bool FindPath(vector&lt;vector&lt;char&gt;&gt; &amp;matrix,int rows,int cols,char *str,int count,vector&lt;vector&lt;bool&gt;&gt; &amp;bool_matrix){
        if(matrix[rows][cols]!=str[count])
            return false;
        if(count==strlen(str)-1)
            return true;
        bool_matrix[rows][cols]=false;
        if(rows&gt;0&amp;&amp;bool_matrix[rows-1][cols]&amp;&amp;FindPath(matrix,rows-1,cols,str,count+1,bool_matrix))
           return true;
        if(cols&gt;0&amp;&amp;bool_matrix[rows][cols-1]&amp;&amp;FindPath(matrix,rows,cols-1,str,count+1,bool_matrix))
           return true;
        if(rows&lt;matrix.size()-1&amp;&amp;bool_matrix[rows+1][cols]&amp;&amp;FindPath(matrix,rows+1,cols,str,count+1,bool_matrix))
           return true;
        if(cols&lt;matrix[0].size()-1&amp;&amp;bool_matrix[rows][cols+1]&amp;&amp;FindPath(matrix,rows,cols+1,str,count+1,bool_matrix))
           return true;
        bool_matrix[rows][cols]=true;
        return false;
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>由于回溯法的递归特性，路径可以被看成一个栈。当在矩阵中定位了路径中前n个字符的位置之后，在与第n个字符对应的格子的周围都没有 找到第n+1个字符，这时候只好在路径上回到第n-1个字符，重新定位第n个字符。<br>
由于路径不能重复进入矩阵的格子，所以还需要定义和字符矩阵大小一样的布尔值矩阵，用来标识路径是否己经进入了每个格子。</p>
</blockquote>
<pre><code>bool hasPathCore(const char* matrix, int rows, int cols, int row, int col, const char* str, int&amp; pathLength, bool* visited);

bool hasPath(const char* matrix, int rows, int cols, const char* str)
{
    if(matrix == nullptr || rows &lt; 1 || cols &lt; 1 || str == nullptr)
        return false;

    bool *visited = new bool[rows * cols];
    memset(visited, 0, rows * cols);

    int pathLength = 0;
    for(int row = 0; row &lt; rows; ++row)
    {
        for(int col = 0; col &lt; cols; ++col)
        {
            if(hasPathCore(matrix, rows, cols, row, col, str,
                pathLength, visited))
            {
                return true;
            }
        }
    }

    delete[] visited;

    return false;
}

bool hasPathCore(const char* matrix, int rows, int cols, int row,
    int col, const char* str, int&amp; pathLength, bool* visited)
{
    if(str[pathLength] == '\0')
        return true;

    bool hasPath = false;
    if(row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; cols
        &amp;&amp; matrix[row * cols + col] == str[pathLength]
        &amp;&amp; !visited[row * cols + col])
    {
        ++pathLength;
        visited[row * cols + col] = true;

        hasPath = hasPathCore(matrix, rows, cols, row, col - 1,
            str, pathLength, visited)
            || hasPathCore(matrix, rows, cols, row - 1, col,
                str, pathLength, visited)
            || hasPathCore(matrix, rows, cols, row, col + 1,
                str, pathLength, visited)
            || hasPathCore(matrix, rows, cols, row + 1, col,
                str, pathLength, visited);

        if(!hasPath)
        {
            --pathLength;
            visited[row * cols + col] = false;
        }
    }

    return hasPath;
}
</code></pre>
<blockquote>
<p>当矩阵中坐标为(row, col)的格子和路径字符串中下标为pathLength的 字符一样时，从 4 个相邻的格子(row, col-1)、(row-1, col)、 (row, col+1)和 (row+1, col)中去定位路径字符串中下标为pathLength+1的字符。<br>
如果4个相邻的格子都没有匹配字符串中下标为pathLength+1的字符， 则表明当前路径字符串中下标为pathLength的字符在矩阵中的定位不正确， 我们需要回到前一个字符(pathLength-1),然后重新定位。<br>
一直重复这个过程，直到路径字符串上的所有字符都在矩阵中找到合 适的位置(此时 str[pathLength]=='\0')。</p>
</blockquote>
<p>书中的代码比我简介很多，特别是把递归结果利用或逻辑运算符||来组合，不像我分成了很多判断语句，但是相应地就必须把判断条件放在前面了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[阅读总结-《Linux多线程服务端编程：使用muduo C++网络库》]]></title>
        <id>https://lixin-scut.github.io//post/yue-du-zong-jie-lesslesslinux-duo-xian-cheng-fu-wu-duan-bian-cheng-shi-yong-muduo-cwang-luo-ku-greatergreater</id>
        <link href="https://lixin-scut.github.io//post/yue-du-zong-jie-lesslesslinux-duo-xian-cheng-fu-wu-duan-bian-cheng-shi-yong-muduo-cwang-luo-ku-greatergreater">
        </link>
        <updated>2020-02-09T12:13:48.000Z</updated>
        <content type="html"><![CDATA[<p>第一部分<br>
1.在多线程的环境中，使用RAII handle机制来管理可能出现竞态条件（race condition）的对象，并且能够通过handle对象的构造函数和析构函数避免出现内存泄漏的情况<br>
具体就是使用shared_ptr和weak_ptr来管理对象，并且通过定制析构函数来保证不会出现任何内存泄漏的情况<br>
调用时尝试提升weak_ptr 为shared_ptr,如果失败则说明对象已经被析构。</p>
<p>2.线程同步方法及其对象<br>
只是用互斥锁mutex和条件变量condition variable<br>
使用RAII机制封装mutex，防止出现遇到异常而无法解锁的情况<br>
只是用TCP socket进行进程间通信</p>
<p>3.多线程服务器模型及适用场合<br>
基于事件驱动的编程模型<br>
Reactor模式 no-blocking IO+IO multiplexing<br>
one loop one thread（Reactor）<br>
线程池 TaskQueue<br>
总结：one loop one thread+thread pool<br>
这正是muduo网络可以提供的服务器程序服务，亦即不用用户去操心底层系统调用，而是提供调用的接口<br>
进程间通信只使用TCP</p>
<p>4.多线程系统编程<br>
多个线程安全的函数组合起来就容易丧失线程安全性<br>
尽量不要用共享变量，用的话最好保证是只读read-only<br>
不要用pthread_self的pthread_t 而用gettid,并使用__thread变量来缓存，不要每次都执行系统调用<br>
线程的创建与销毁-安全地退出一个多线程的程序并不是一件容易的事情，需要精心设计共享对象的析构顺序，防止各个线程在退出时访问已失效对象，可以不必追求安全地推出，而是让进程进入拒绝服务状态，然后直接杀掉<br>
exit不是线程安全的<br>
善用__thread关键字<br>
每个文件描述符只由一个线程操作，亦即一个线程可以操作多个文件描述符，但是不可以操作其他线程的操作描述符<br>
用socket对象通过RAII机制管理文件描述符<br>
为了防止访问失效对象和网络串话，使用shared_ptr来管理tcpconnection的生命期，这是唯一采用引用计数方式来管理生命期的对象<br>
fork可能会导致RAII失效，使用多线程时尽量不要用fork了，唯一安全的方法就是fork后立即调用exec<br>
多线程中不要使用signal<br>
不主动处理各种异常信号，直接默认结束进程<br>
linux新增了部分系统调用 比如文件描述符的非阻塞IO、exec后强制关闭文件描述符</p>
<p>5.多线程日志<br>
故障诊断和追踪<br>
日志库是单例模式<br>
muduo日志库是C++ stream风格，但没用iostream，而是自己写了logstream class<br>
日志需要有设置级别的功能<br>
日志的目的地只有本地，不要往网络传日志<br>
日志应该有rolling功能，主要由文件大小和时间来区分<br>
日志文件名：进程名+时间+机器名+进程id+后缀.log<br>
防止程序崩溃1.定期flush 2.在内存中的日志消息都有cookie，值为某个函数地址<br>
日志消息格式是固定的，不需要通过运行时配置<br>
要点 1.每条日志只占1行 2.时间戳精确到微妙 gettimeofday 3.保证同一时区 4.打印线程id 5.打印日志级别 6.打印源文件名和行号<br>
每行日志的前四个字段的宽度是固定的 以空格分隔 便于分析，避免出现正则表达式的元字符<br>
优化：1.日期和时间都是缓存的 2.前四个字段是定长的，避免运行时求长度<br>
3.线程id预先格式化为字符串 4.源文件名部分采用编译器计算<br>
多线程异步日志：使用一个背景线程来收集日志信息，其他业务线程往这个线程发送日志消息<br>
双缓冲技术 使用两个buffer 分为前段接收和后端写入<br>
实际上有四个缓冲区</p>
<p>6.muduo网络库简介<br>
主体目录主要部分为base和net<br>
base目录下主要使一些基础库，基本都是用户可见的类<br>
比较重点的有异步日志、阻塞队列、条件变量、互斥锁、进程信息、线程对象和线程池等<br>
而net目录则是muduo的核心部分，主要体现了其<br>
1.基于Reactor模式的网络库，其核心是个事件循环Eventloop<br>
2.采用基于对象（object-based）而非面向对象（object-oriented）的设计风格<br>
3.事件回调接口多以boost::fuction + boost::bind表达<br>
2、3点使得用户使用muduo的时候不需要继承其中的class</p>
<p>net中的都是比较重要的部分<br>
其中相对更重要的是<br>
1.Acceptor 用于服务端接受tcp连接<br>
2.Connector 连接器，用于客户端发起连接<br>
3.EventLoop 事件分发器<br>
4.EventLoopThread 新建一个专门用于EventLoop的线程<br>
5.EventLoopThreadPool muduo默认多线程IO模型<br>
6.Poller IO multiplexing的基类接口<br>
7.Poller IO multiplexing的实现<br>
8.Socket 封装Socket描述符 负责关闭连接<br>
9.SocketOps 封装底层的Socket API<br>
10.TcpConnection  管理tcp连接<br>
11.TcpClient和TcpServer 客户端和服务端<br>
12.Timer 定时器</p>
<p>从用户角度：<br>
使用muduo网络库提供的服务需要掌握五个类：Buffer、EventLoop、TcpConnection、TcpClient、TcpServer<br>
<img src="https://lixin-scut.github.io//post-images/1581341726910.png" alt=""><br>
muduo头文件中使用了前向声明，大大简化了头文件之间的依赖关系。避免包含有文件，或者暴露用户不应接触的类等。</p>
<p>公开接口：<br>
Buffer：数据的读写通过buffer进行，用户不需要调用read/write等<br>
InetAddress：封装IPv4地址，不进行DNS解析域名，只认IP地址，因为用gethostbyname解析域名会阻塞IO线程<br>
EventLoop：反应器Reactor，每个线程只能有一个EventLoop实体，负责IO和定时器事件的分派，用eventfd来异步唤醒。用TimerQueue来作为计时器管理，用Poller作为IO multiplexing<br>
EventLoopThread：启动一个线程，在其中运行EventLoop::loop()<br>
TcpConnection：整个网络库的核心，封装一次TCP连接，注意它不能发起连接<br>
TcpClient和TcpServer：网络客户端和网络服务端<br>
上述类中，TcpConnection的生命期依靠shared_ptr管理，Buffer的生命期由TcpConnection控制。其余类的生命期由用户控制<br>
Buffer和InetAddress具有值语义，可以拷贝，其他class对象都是对象语义，不可以拷贝</p>
<p>内部实现<br>
Channel：负责注册与响应IO事件，但不拥有文件描述符，属于Acceptor、Connector、EventLoop、TimerQueue、TcpConnection的成员，生命期由后者控制<br>
Socket：RAII handle，封装一个描述符fd，并在析构时关闭fd，是Acceptor、TcpConnection的成员，EventLoop、TimerQueue也拥有fd，但不封装为Socket class。<br>
Poller：PollPoller和EPollPoller的基类，采用LT触发，是Eventloop的成员<br>
Connector：发起TCP连接，是TcpClient的成员<br>
Acceptor：接受TCP连接，它是TcpServer的成员，生命期由后者控制<br>
TimerQueue：用timefd实现定时，使用map来管理Timer，是EventLoop的成员<br>
EventLoopThreadPool：用于创建IO线程池，用于把TcpConnection分派到某个EventLoop线程上，它是TcpServer的成员<br>
<img src="https://lixin-scut.github.io//post-images/1581346971439.png" alt=""></p>
<p>线程模型：<br>
每个线程最多只有一个EventLoop，每个TcpConnection必须归某个EventLoop管理，所有的IO会转移到这个线程<br>
一个描述符fd只能由一个线程读写<br>
TcpConnection所在的线程由EventLoop决定<br>
TcpConnection和EventLoop是线程安全的<br>
TcpServer直接支持多线程，有两种模式分别为单线程和多线程，主要的区别是后者创建一个EventLoopThreadPool，新到的连接会按round-robin方式分配到线程池</p>
<p>Buffer类的设计与使用<br>
非阻塞IO总是与IO复用函数（select/poll/epoll）一起使用，所以应用层的buffer是必需的<br>
TcpConnection必须要有output buffer，并且当输出缓冲中还有待发送的数据时，程序希望关闭连接的话，此时网络库必须等待数据发送完毕，而不能立即关闭连接<br>
因为使用的是Epoll的LT电平触发，所以网络库在处理socket可读事件的时候必须一次性把socket中的数据读完（从内核buffer到应用层buffer），否则会一直触发POLLIN事件<br>
此时就会出现“粘包”现象，亦即buffer中有部分数据不完整的情况，需要使用codec分包，等待构成一条完整的信息再通知程序的业务逻辑<br>
为什么不用边缘触发edge trigger 一是与传统的poll兼容，二是电平触发编程更容易，三是读写的时候不必等候出现EAGAIN，可以节省系统调用，降低延迟<br>
一般不需要直接操作buffer<br>
buffer内部是vector&lt; char &gt; ，是一块连续的内存<br>
分为三个部分：prependable、readable、writable<br>
buffer使用下标而不是迭代器，因为vector是自增长的，重新分配内存之后会使得原来的指针失效<br>
prepend前方添加：有时候readIndex比较靠后，buffer前半部分有一定的空间，可以先序列化消息，然后再在序列化数据的前面添加消息的长度</p>
<p>codec编解码器：LengthHeaderCodec<br>
codec的基本功能之一就是做TCP分包，使得不完整的信息不会触发消息事件回调，而是先停留在buffer中<br>
所以同时也承接了将send发送的信息进行编码</p>
<p>Dispatcher分发器：<br>
在传递多种Protobuf消息的过程中对收到的消息按类型分发</p>
<p>限制服务器的最大并发连接数：<br>
防止客户端连接数过多导致文件描述符fd耗尽<br>
优雅地断开新连接：准备一个空闲的文件描述符，当剩余的fd耗尽时，就立即使用这个文件描述符，但是注意accept新连接后立即close，然后重新打开一个空闲文件继续把空闲的文件描述符占住，当再次出现这种情况的时候使用<br>
但是注意只有一个空闲的文件描述符的时候容易造成race condition，最好是指一个缓冲，当fd数量进入这个缓冲区的时候就要进行主动关闭新连接的优雅断开连接了<br>
muduo中直接是使用一个int成员来表示当前的活动连接数，在onConnection中判断当前活动连接数，如果超过了最大允许数就踢掉连接。<br>
如果有业务逻辑的服务可以在shutdown前发送一个简单的响应，表明本服务程序<br>
的负载能力已经饱和</p>
<p>定时器<br>
计时只使用gettimeofday来获取当前事件，因为它不是系统调用，而是在用户态实现的，没有上下文切换和陷入内核等开销<br>
定时只使用timerfd_* 系列函数来完成处理定时任务，timefd_create可以把时间变成一个文件描述符，当定时器超时时变为可读，可以和epoll等IO复用函数配合使用，符合Reactor模式中利用统一的方法处理IO事件和超时事件的思想<br>
muduo的定时器接口有四个：<br>
runAt：在指定时间调用TimerCallback<br>
runAfter：等一段时间再调用TimerCallback；<br>
runEvery：以固定的时间间隔反复调用TimerCallback<br>
cancel：取消timer<br>
muduo的TimerQueue采用平衡二叉树来管理未到期的timers，时间复杂度是O(logN)</p>
<p>利用timing wheel踢掉空闲连接<br>
一个连接如果若干秒都没有收到数据，就被认为是空闲连接<br>
muduo使用循环队列来处理连接超时，每个节点保存n秒后将要超时的连接的hash set<br>
实现中hash set中放的不是连接，而是一个特制的Entry struct，包含TcpConnection的weak_ptr，Entry的析构函数会判断连接是否还存在，如果提升弱引用失败的话就等于已经不存在了<br>
用shared_ptr来管理Entry，如果引用计数变为0则自动析构，把Entry放到格子里时会递增它的引用计数<br>
在连接建立时，创建一个Entry对象，把它放到timing wheel的队尾，还需要把Entry的弱引用保存到TcpConnection的context里，收到数据时从context中取出弱引用，提升为强引用EntryPtr，放到队尾，同时circular_buffer会自动弹出队首的Bucket并析构<br>
注意连接Entry可以存在多个set中，只有析构set时引用计数变为0的连接才会被析构</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[虚函数与纯虚函数]]></title>
        <id>https://lixin-scut.github.io//post/xu-han-shu-yu-chun-xu-han-shu</id>
        <link href="https://lixin-scut.github.io//post/xu-han-shu-yu-chun-xu-han-shu">
        </link>
        <updated>2020-02-09T08:31:07.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://lixin-scut.github.io/post/guan-yu-xu-han-shu-he-chun-xu-han-shu/">关于虚函数和纯虚函数</a></p>
<p>书中概念：</p>
<h2 id="虚函数">虚函数</h2>
<p>对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成虚函数 (virtual function)<br>
派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以在这样的函数之前加上 virtual 关键字.但是并不是非得这么做。<br>
C ++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，具体措施是在该函数的形参列表之后增加一个 override 关键字。<br>
当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。<br>
基类必须将它的两种成员函数区分开来：一种是基类希望其派生类进行覆盖的函数；另一种是基类希望派生类直接维承而不要改变的函数。对于前者，基类通常将其定义为虚函数（ virtual )。<br>
基类通过在其成员函数的声明语句之前加上关键字virtual使得该函数执行动态绑定。任何构造函数之外的非静态函数都可以是虚函数。关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。<br>
成员函数如果没被声明为虚函数，则其解析过程发生在编译时而非运行时。<br>
如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接维承其在基类中的版本。<br>
C ++11新标准允许派生类显式地注明它使用某个成员函数覆盖了它维承的虚函数。具体做法是在形参列表后面、或者在 const 成员函数（参见7。1.2节，第231页）的 const 关键字后面、或者在引用成员函数（参见13.6.3节，第483页）的引用限定符后面添加一个关键字 override 。</p>
<p>因为我们直到运行时才能知道到底调用了哪个版本的虚函数，所以所有虚函数都必须有定义<br>
因为连编译器也无法确定到底会使用哪个虚函数。<br>
动态绑定只有当我们通过指针或引用调用虚函数时才会发生。<br>
当通过一个具有普通类型（非引用非指针）的表达式调用虚函数时，在编译时就会将调 用的版本确定下来。<br>
OOP的核心思想是多态性（polymorphism)。我们把具有继承关系的多个类型称为多态类型.<br>
当我们在派生类中覆盖了某个虚函数时，可以再一次使用virtual 关键字指出该函数的性质。然而这么做并非必须，因为一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数。<br>
一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致。<br>
同样，派生类中虚函数的返回类型也必须与基类函数匹配。该规则存在一个例外，当类的虚函数返回类型是类本身的指针或引用时，上述规则无效。<br>
派生类如果定义了一个函数与基类中虚函数的名字相同但是形参列表不同，这仍然是合法的行为。编译器将认为新定义的这个函数与基类中原有的函数是相互独立的。这时，派生类的函数并没有覆盖掉基类中的版本。就实际的编程习惯而言，这种声明往往意味着发生了错误，因为我们可能原本希望派生类能覆盖掉基类中的虚函数，但是一不小心把形参列表弄错了。要想调试并发现这样的错误显然非常团难。在 C ++11新标准中我们可以使用override 关键字来说明派生类中的虚函数。<br>
如果我们使用override 标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器将报错：<br>
我们还能把某个函数指定为 final ,如果我们已经把函数定义成 final 了，则之后任何尝试覆盖该函数的操作都将引发错误<br>
final 和 override 说明符出现在形参列表（包括任何 const 或引用修饰符）以及尾置<br>
返回类型（参见6.3.3节，第206页）之后<br>
虚函数也可以拥有默认实参（参见6.5.1节，第211页）。如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定。<br>
如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。此时，传入派生类函数的将是基类函数定义的默认实参。<br>
如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致<br>
在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。使用作用域运算符可以实现这一目的，例如下面的代码：</p>
<p>通常情况下，只有成员函数（或友元）中的代码才需要使用作用域运算符来回避虚函数机制<br>
通常是—个派生类的虚函数调用它覆盖的基类的虚函数版本时。在此情况下，基类的版本通常完成继承层次中所有类型都要做的共同任务，而派生类中定义的版本需要执行一些与派生类本身密切相关的操作。<br>
如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本自身的调用，从而导致无限递归</p>
<p>除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字</p>
<p>为什么基类与派生类中的虚函数必须有相同的形参列表了（参见15.3节，第537页）。假如基类与派生类的虚函数接受的实参不同.则我们就无法通过基类的引用或指针调用派生类的虚函数了。</p>
<p>如果基类的析构函数不是虚函数，则 delete —个指向派生类对象的基类指针将产生未定义的行为。<br>
之前我们曾介绍过一条经验准则，即如果一个类需要析构函数，那么它也同样需要拷贝和赋值操作（参见13.1.4节，第447页）。基类的析构函数并不遵循上述准则，它是一个重要的例外。一个基类总是需要析构函数，而且它能将析构函数设定为虚函数。此时，该析构函数为了成为虚函数而令内容为空，我们显然无法由此推断该基类还需要赋值运算或拷贝构造函数。</p>
<p>当我们构建一个对象时，需要把对象的类和构造函数的类看作是同一个；对虚函数的调用绑定正好符合这种把对象的类和构造函数的类看成同一个的要求；对于析构函数也是同样的道理。<br>
如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。</p>
<p>一个类（无论是普通类还是类模板）可以包含本身是模板的成员函数。这种成员被称为成员模板 (member template )。成员模板不能是虚函数。</p>
<p>如果一个虚函数承诺了它不会抛出异常，则后续派生出来的虚函数也必须做出同样的承诺；与之相反，如果基类的虚函数允许抛出异常，则派生类的对应函数既可以允许抛出异常，也可以不允许抛出异常</p>
<p>运行时类型识别（run-time type identification,RTTI)的功能由两个运算符实现：<br>
• typeid运算符，用于返回表达式的类型。<br>
• dynamic_cast运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用。<br>
这两个运算符特别适用于以下情况：我们想使用基类对象的指针或引用执行某个派生 类操作并且该操作不是虚函数。一般来说，只要有可能我们应该尽量使用虚函数。当操作被定义成虚函数时，编译器将根据对象的动态类型自动地选择正确的函数版本。<br>
然而，并非任何时候都能定义一个虚函数。假设我们无法使用虚函数，则可以使用一个RTTI运算符。另一方面，与虚成员函数相比，使用RTTI运算符蕴含着更多潜在的风险：程序员必须清楚地知道转换的目标类型并且必须检查类型转换是否被成功执行。<br>
使用RTTI必须要加倍小心。在可能的情况下，最好定义虚函数而非直接接管类型管理的重任。<br>
当运算对象不属于类类型或者是一个不包含任何虚函数的类时，typeid运算符指示的是运算对象的静态类型。而当运算对象是定义了至少一个虚函数的类的左值时，typeid的结果直到运行时才会求得。<br>
typeid是否需要运行时检查决定了表达式是否会被求值。只有当类型含有虚函数时，编译器才会对表达式求值。反之，如果类型不含有虚函数，则typeid返回表达式的静态类型；编译器无须对表达式求值也能知道表达式的静态类型。</p>
<p>union可以定义包括构造函数和析构函数在内的成员函数。但是由于union既不能继承自其他类，也不能作为基类使用，所以在union中不能含有虚函数。</p>
<h2 id="纯虚函数">纯虚函数</h2>
<p>和普通的虚函数不一样，一个纯虚函数无须定义。我们通过在函数体的位置（即在声明语句的分号之前）书写=0就可以将一个虚函数说明为纯虚函数。其中，=0只能出现在类内部的虚函数声明语句处：<br>
值得注意的是，我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。 也就是说，我们不能在类的内部为一个=0的函数提供函数体。</p>
<p>含有（或者未经覆盖直接继承）纯虚函数的类是抽象基类 （abstractbaseclass )。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。我们不能（直接）创建一个抽象基类的对象。</p>
<p>我们竟然可以为纯虚函数提供定义，但调用它的唯一途径是调用时明确指出其class的名称。（effective c++ ）</p>
<p>网上博客：<br>
纯虚函数更多地希望声明有一个这样的统一接口，具体的实现留到子类里去实现</p>
<p>虚函数和纯虚函数都不能有static表示服，被static修饰的函数在编译时候要求前期bind，然而虚函数却是动态绑定，而且被两者修饰的函数生命周期也不一样。</p>
<p>假设Bulk_quote的直接基类是Disc_quote,间接基类是Quote。每个Bulk_quote对象包含三个子对象：一个（空的）Bulk_quote部分、一个Disc_quote子对象和一个Quote子对象。如果Disc_quote中对Quote的纯虚函数提供了实现，则纯虚函数变为虚函数，Bulk_quote中可以选择直接继承或者override<br>
（注意这里的分部分思想，对于理解多层派生很有用）</p>
<p>虚函数是实现多态的机制，核心理念就是通过基类的指针或引用来访问派生类定义的函数</p>
<p>多态：<br>
编译多态：通过重载函数实现<br>
运行多态：通过虚函数实现</p>
<p>虚函数和纯虚函数有以下所示方面的区别。</p>
<p>类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖，这样的话，这样编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。<br>
虚函数在子类里面也可以不重载的；但纯虚函数必须在子类去实现，这就像 Java 的接口一样。通常把很多函数加上 virtual，是一个好的习惯，虽然牺牲了一些性能，但是增加了面向对象的多态性，因为很难预料到父类里面的这个函数不在子类里面不去修改它的实现。<br>
虚函数的类用于“实作继承”，继承接口的同时也继承了父类的实现。当然大家也可以完成自己的实现。纯虚函数关注的是接口的统一性，实现由子类完成。<br>
带纯虚函数的类叫虚基类，这种基类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。这样的类也叫抽象类。抽象类和大家口头常说的虚基类还是有区别的，在 C# 中用 abstract 定义抽象类，而在 C++ 中有抽象类的概念，但是没有这个关键字。抽象类被继承后，子类可以继续是抽象类，也可以是普通类，而虚基类，是含有纯虚函数的类，它如果被继承，那么子类就必须实现虚基类里面的所有纯虚函数，其子类不能是抽象类。<br>
纯虚函数</p>
<p>声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。</p>
<p>纯虚函数最显著的特征是：它们必须在继承类中重新声明函数（不要后面的＝0，否则该派生类也不能实例化），而且它们在抽象类中往往没有定义。</p>
<p>定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。</p>
<p>纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。</p>
<p>顺便说一句，为一个纯虚函数提供定义也是可能的。也就是说，你可以为纯虚函数提供实现，C++ 编译器也不会阻拦（DEV_CPP 中 G++(gcc 3.4.2) 编译器并不支持为纯虚函数定义缺省行为；在 VC6.0 支持为纯虚函数定义缺省的实现，派生类的虚函数 override 基类的纯虚函数），但调用它的唯一方式是通过类名完整地指明是哪个调用（如：pb-&gt;Base:: pureVirtual()）。</p>
<p>有时，声明一个除纯虚函数外什么也不包含的类很有用。这样的类叫协议类（Protocol class），它为派生类仅提供函数接口，完全没有实现。</p>
<p>虚函数（在此指的是非纯虚函数）</p>
<p>虚函数的情况和纯虚函数有点不一样。照例，派生类继承了函数的接口，但简单虚函数一般还提供了实现，派生类可以选择改写（override）它们或不改写它们。</p>
<p>声明虚函数的目的在于，使派生类继承函数的接口和缺省实现。</p>
<p>虚函数的意义，每个类必须提供一个可以被调用的虚函数，但每个类可以按它们认为合适的任何方式处理。如果某个类不想做什么特别的事，可以借助于基类中提供的缺省处理函数。也就是说，虚函数的声明是在告诉子类的设计者，”你必须支持虚函数，但如果你不想写自己的版本，可以借助基类中的缺省版本。”</p>
<p>实际上，为虚函数同时提供函数声明和缺省实现是很危险的。(当你增加一个派生类继承基类时,必须小心使用虚函数,满足派生类特有的需求，否则就是调用基类的虚函数，可能引起错误)</p>
<p>非虚函数</p>
<p>最后，来谈谈类的非虚函数，当一个成员函数为非虚函数时，它在派生类中的行为就不应该不同。实际上，非虚成员函数表明了一种特殊性上的不变性，因为它表示的是不会改变的行为――不管一个派生类有多特殊。</p>
<p>声明非虚函数的目的在于，使派生类继承函数的接口和强制性实现。（所有的派生类都应该完成的使用该函数完成某一个功能）</p>
<p>建议</p>
<p>结合前面的学过的，再次强调一下，如果你没有为类设计虚函数（纯虚函数），该类一般来说应该不具有继承特性（除非确实的存在 IS-A 关系，即便存在，派生类也没有了特殊性，这种情况一般是设计中抽象的不合理）。当然除了 Protocol class 也不应该把类的成员函数全部设计成虚函数（纯虚函数），这也说明了类设计的不合理（不能正确的抽象出基类、派生类之间不变的部分）。</p>
<p>c++ 中没有接口的概念，与之对应的是纯虚类，即只含有纯虚函数的类，c++ 抽象类的概念是含有纯虚函数成员的类。这是因为 c++ 提供多继承，而像 java、c# 这些只提供单继承（避免多继承的复杂性和低效性）的语言为了模拟多继承功能就提供了接口概念，接口可以继承多个。</p>
<p>abstract class 是抽象类，至少包含一个纯虚函数的类就叫做抽象类。</p>
<p>但是如果一个类，所有的成员都是纯虚函数，那么它和一般的抽象类在用法上是有区别的。至少 Microsoft 给的 COM 接口定义全部都是仅由纯虚函数构成的类。因此把这样的类定义叫做纯虚类也不算错。</p>
<p>纯虚函数和虚函数的区别在于前者不包含定义，而后者包含函数体。</p>
<p>那么纯虚类就是不包含任何实现（包括成员函数定义和成员变量定义。前者代表算法，后者代表结构）。不包含任何算法和结构的类叫做纯虚类，应该没有问题。</p>
<p>在 Java 里面的确没有纯虚类的概念，因为 Java 里没有纯虚函数这个概念。Java 管虚函数叫做 abstract function，管抽象类叫做 abstract class，直接说来，Java 根本没有 virtual 这个关键字，都用 abstract 代替，因此 Java 里面根本就没有 Pure 这个概念。有那就是 interface。在 interface 里面定义的函数都不能有函数体，这个在 Java 里面叫做接口。那么 C++ 里面与 interface 等同的概念就是纯虚类了，C++ 用纯虚类来模拟 interface 这个抽象概念，因此这里说的“纯虚类”与 Java 的 abstract class 不同，与 C++ 的一般抽象类也不同。“纯虚类”与 C++ 一般抽象类的区别就好比 Java 里面 interface 和 abstract class 的区别。</p>
<p>抽象类：</p>
<p>抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的，它处于继承层次结构的较上层。</p>
<p>抽象类的定义：</p>
<p>称带有纯虚函数的类为抽象类。称带有纯虚函数的类为抽象类。</p>
<p>抽象类的作用：</p>
<p>抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。所 以派生类实际上刻画了一组子类的操作接口的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。</p>
<p>使用抽象类时注意：</p>
<p>• 抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。</p>
<p>• 抽象类是不能定义对象的。</p>
<h3 id="虚函数的实现">虚函数的实现</h3>
<p>《深度探索c++模型》<br>
1.声明的类导入一个virtual table，存放它所声明的每一个虚函数地址，再加上一个或两个slots（用以支持runtime type identification）<br>
2.类每个对象都导入一个vptr，提供执行期的链接<br>
3.加强constructor，使他能够为vptr提供初值<br>
4.加强deconstructor 能够抹消vptr</p>
<p>为了兼容c语言，早期vptr放在class尾端<br>
现在一般把vptr放在前端，对于在多重继承之下，通过指向class members的指针调用 virtual function有帮助</p>
<p>多重继承：派生类继承了多个基类，基类又各自有自己的虚函数<br>
如果基类没有虚函数而派生类有，则把一个派生类对象转化为基类对象就需要编译器介入以调整地址<br>
对于第一个基类情况和单一继承时相同，之后的基类则需要修改地址，加上（活着减去）介于中间的基类大小（编译器一半按照声明的次序来排列它们）<br>
此时会有多个vptr</p>
<p>虚拟继承：适用于菱形继承<br>
如果class内包含一个或多个虚继承的基类，将分为两个部分：一个不变局部和共享局部<br>
共享局部就是虚继承的基类所在，其位置会因为每次的派生操作而有变化，所以它们只能被间接存取</p>
<p>博客：<br>
<a href="https://blog.csdn.net/weixin_40237626/article/details/82313339">虚函数实现原理</a><br>
带有虚函数的类，编译器会为其额外分配一个虚函数表，里面记录的使虚函数的地址，当此类被继承时，子类如果也写了虚函数就在子类的虚函数表中将父类的函数地址覆盖，否则继承父类的虚函数地址。</p>
<p>实例化之后，对象有一个虚函数指针，虚函数指针指向虚函数表，这样程序运行的时候，通过虚函数指针找到的虚函数表就是根据对象的类型来指向的了。</p>
<h3 id="虚函数和内联">虚函数和内联：</h3>
<p>如果函数已经被声明为inline, 内联函数已经在编译期间它的调用点上就被展开，内联不是强制性的，你只是向编译器提出这个建议，允许它在可以内联的时候采取内联形式;<br>
虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。<br>
内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。<br>
inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</p>
<pre><code>	#include &lt;iostream&gt;
	using namespace std;
	// 基类
	class Base{
		public:
			inline virtual void who(){
				cout &lt;&lt; &quot;I am Base\n&quot;;
			}
			virtual ~Base(){}
	};
	// 派生类
	class Derived:public Base{
		public:
			inline void who(){   // 不写inline时隐式内联
				cout &lt;&lt; &quot;I am Derived\n&quot;;
			}
	};
int  main(){
	// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。
	Base b;
	b.who();
	// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。
	Base *bptr = new Derived();
	bptr-&gt;who();
	// 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。
</code></pre>
<h3 id="构造函数与虚函数">构造函数与虚函数</h3>
<p>1.虚函数对应一个虚指针，虚指针其实是存储在对象的内存空间的。如果构造函数是虚的，就需要通过 虚指针执行那个虚函数表（编译期间生成属于类）来调用，可是对象还没有实例化，也就是内存空间还没有，就没有虚指针，所以构造函数不能是虚函数。</p>
<p>2.虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。</p>
<p>C++ 中哪些函数不能被声明为虚函数?<br>
(普通、内联、构造、友元、静态)</p>
<p>重载与override<br>
注意override和重载不同，重载是针对普通成员函数，override针对虚函数</p>
<p>求虚函数表地址的代码</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
class Base{
	public: 
	virtual void fun()
	{
		cout&lt;&lt;&quot;This is Base Class&quot;&lt;&lt;endl;
	}
};
class Derived:public Base{
	public:
	void fun()
	{
		cout&lt;&lt;&quot;This is Derived Class&quot;&lt;&lt;endl;
	}
};
int main()
{
	Base B;
	Derived D; 
	int **p=(int**)&amp;B;
	cout&lt;&lt;&quot;基类的虚函数表地址:&quot;&lt;&lt;p[0]&lt;&lt;endl;
	cout&lt;&lt;&quot;基类的虚函数表中虚函数的地址:0x&quot;&lt;&lt;hex&lt;&lt;p[0][0]&lt;&lt;endl;
	p=(int**)&amp;D;
	cout&lt;&lt;&quot;派生类的虚函数表地址:&quot;&lt;&lt;p[0]&lt;&lt;endl;
	cout&lt;&lt;&quot;派生类的虚函数表中虚函数的地址:0x&quot;&lt;&lt;hex&lt;&lt;p[0][0]&lt;&lt;endl;
	
	return 0;
	}
</code></pre>
<p>析构函数可以是纯虚函数吗<br>
可以，但不常用，而且需要在类外提供析构函数的定义<br>
这个定义是必需的，因为虚析构函数工作的方式是：最底层的派生类的析构函数最先被调用，然后各个基类的析构函数被调用。这就是说，即使是抽象类，编译器也要产生对~awov的调用，所以要保证为它提供函数体。如果不这么做，链接器就会检测出来，最后还是得回去把它添上。<br>
虽然抽象类的析构函数可以是纯虚函数，但要实例化其派生类对象，仍必须提供抽象基类中析构函数的函数体。<br>
但是继承一个有纯虚析构函数的类的时候，在派生类中可以不给出析构函数的定义，并且这个类也不是抽象类，这是与其它函数不同的地方（其它纯虚函数没有给出定义的话，这个类也是抽象类）。因为编译器自动帮我们生成了一个定义，所以也可以认为重写了父类的纯虚函数。</p>
<p>同理引出 虽然抽象类不能被实例化，但可以有构造函数由于抽象类的构造函数在实例化派生类之前发生，所以，可以在这个阶段初始化抽象类字段或执行其它与子类相关的代码。</p>
<p>可以在构造函数析构函数中调用虚函数吗<br>
可以，虚函数底层实现原理(但是最好不要在构造和析构函数中调用) 可以，但是没有动态绑定的效果，父类构造函数中调用的仍然是父类版本的函数，子类中调用的仍然是子类版本的函数。 effictive c++第九条，绝不在构造和析构过程中调用virtual,因为构造函数中的base的虚函数不会下降到derived上。而是直接调用base类的虚函数。绝不在构造和析构函数中调用virtual函数</p>
<p>虚函数会占用存储空间嘛?是占类的空间大小?<br>
计算一个类对象的大小时的规律：<br>
1、空类、单一继承的空类、多重继承的空类所占空间大小为：1（字节，下同）；<br>
2、一个类中，虚函数本身、成员函数（包括静态与非静态）和静态数据成员都是不占用类对象的存储空间的；<br>
3、因此一个对象的大小≥所有非静态成员大小的总和；<br>
4、当类中声明了虚函数（不管是1个还是多个），那么在实例化对象时，编译器会自动在对象里安插一个指针vptr指向虚函数表；<br>
5、虚承继的情况：由于涉及到虚函数表和虚基表，会同时增加一个（多重虚继承下对应多个）vptr指针指向虚函数表和一个vbptr指针指向虚基表vbtable，这两者所占的空间大小为：8（或8乘以多继承时父类的个数）；<br>
6、在考虑以上内容所占空间的大小时，还要注意编译器下的“补齐”padding的影响，即编译器会插入多余的字节补齐；<br>
7、类对象的大小=各非静态数据成员（包括父类的非静态数据成员但都不包括所有的成员函数）的总和+ vptr指针(多重继承下可能不止一个)+vbptr指针(多重虚继承下可能不止一个)+编译器补齐额外增加的字节。</p>
<p>虚函数表存放在哪里<br>
这个根据编译器的不同而不用，但是统一的性质是虚函数表是全局共享的元素,即全局仅有一个.（注意这里是指每个类的多个实例化对象共享一个虚函数表，而不是指 整个派生链都共享一个虚函数表）<br>
虚函数表vtable在Linux/Unix中存放在可执行文件的只读数据段中(rodata)，这与微软的编译器将虚函数表存放在常量段存在一些差别。<br>
<a href="https://www.cnblogs.com/laiqun/p/5887372.html">关于C++中虚函数表存放位置的思考</a></p>
<p>ABC链式继承，问最后一共有多少个虚函数表?<br>
三个虚函数表，每个类使用自己的虚函数表，但没被override的虚函数的地址是一样的<br>
C++中虚函数表位于只读数据段（.rodata），也就是C++内存模型中的常量区；而虚函数则位于代码段（.text），也就是C++内存模型中的代码区。<br>
<a href="%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8">基类和派生类的虚函数表</a><br>
<a href="https://blog.csdn.net/qq_28114615/article/details/98041319">C++中的虚函数表和虚函数在内存中的位置</a></p>
<p>虚函数表是谁维护的<br>
虚函数表是由编译器自动生成与维护的</p>
<p>虚函数表创建时期<br>
编译时期</p>
]]></content>
    </entry>
</feed>