<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-03-17T09:11:00.953Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>In the darkest night,rising like a spire.</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[链表的环问题]]></title>
        <id>https://lixin-scut.github.io//post/lian-biao-de-huan-wen-ti</id>
        <link href="https://lixin-scut.github.io//post/lian-biao-de-huan-wen-ti">
        </link>
        <updated>2020-03-17T02:16:14.000Z</updated>
        <content type="html"><![CDATA[<p>因为链表的环问题比较多，我直接整理为一个博文，方便查阅</p>
<p>相关博文传送门<br>
<a href="https://lixin-scut.github.io/post/lian-biao-142-huan-xing-lian-biao-iizhong-deng-wei-zuo-chu/">链表 142. 环形链表 II[中等]</a><br>
<a href="https://lixin-scut.github.io/post/lian-biao-141-huan-xing-lian-biao-nan-du-jian-dan/">链表 141. 环形链表 难度：简单</a><br>
<a href="https://lixin-scut.github.io/post/lian-biao-ti-23lian-biao-zhong-huan-de-ru-kou-jie-dian/">链表 题23:链表中环的入口节点</a></p>
<p>链表的环问题主要可以分为下面几个部分：</p>
<ol>
<li>链表长度</li>
<li>链表是否有环</li>
<li>链表环入口</li>
<li>链表环长度<br>
下面就逐一解决</li>
</ol>
<h3 id="单链表长度">单链表长度</h3>
<p><strong>思路：</strong><br>
这个比较简单，直接遍历一次并计数即可<br>
<strong>代码：</strong></p>
<pre><code>//计算单链表长度
int lengthNode(Node *node)
{
	if (nullptr == node) // 防止漏写= 变为 赋值node为空指针
	{
		cout &lt;&lt; &quot;error&quot; &lt;&lt; endl;
		return 0;
	}
	int length= 0;
	Node *pTmp = node;
	while (pTmp-&gt;next) //从头到尾遍历链表，计数器依次累加
	{
		pTmp = pTmp-&gt;next;
		++length;
	}
	return length;
}
</code></pre>
<h3 id="单链表是否有环">单链表是否有环</h3>
<p><strong>思路：</strong><br>
  设置两个指针，都指向头结点，一个走的快，一个走的慢，<br>
  如果有环，那么若干步以后，快指针总会超过慢的指针一圈；<br>
  如果没有，那么若干步以后，快指针指向NULL。</p>
<p><strong>数学证明：</strong></p>
<blockquote>
<p>根据floyd判圈办法，一个快指针一个慢指针，二者一定在环上相遇，设相遇点为M点，<br>
快是慢的速度的2倍，时间相同，设慢的距离为s，那么快的距离为2s<br>
m为链表头距离环开始位置的距离，k为环开始位置到M点的距离, N为环长度<br>
s = m + aN +k, 2s = m + bN +k，二者相减，s = (a-b)*N<br>
由此可见，慢指针走过的距离是环长的整数倍，即链表头到M点是环长的整数倍<br>
如果是1倍的话，把m截距离旋转到环上，跟环融合，那么链表头一定落在M点，<br>
即fast和slow都落在M点，那么二者到环开始位置距离相同，必然在此处相遇。<br>
如果是N倍（N&gt;1）时，只不过slow指针多转几圈而已，后二者仍在此处相遇</p>
</blockquote>
<p><strong>代码</strong></p>
<pre><code>bool hasCycle(ListNode *head) {
        if(!head)
            return false;
        ListNode *fast=head-&gt;next;
        ListNode *slow=head;
        while(fast!=slow){
            if(fast==NULL||fast-&gt;next==NULL)
                return false;
            fast=fast-&gt;next-&gt;next;
            slow=slow-&gt;next;
        }
        return true;
    }
</code></pre>
<h3 id="单链表环入口">单链表环入口</h3>
<p><strong>思路</strong><br>
  依然使用双指针法。首先使得两个指针相遇<br>
  然后slow指针位置不变 ，将fast指针重新指向链表头部节点 ；slow和fast同时每轮向前走 1 步；<br>
  两指针重合时指向链表环入口 。<br>
  返回slow指针指向的节点。</p>
<p><strong>数学证明</strong></p>
<blockquote>
<p>双指针第一次相遇： 设两指针 fast，slow 指向链表头部 head，fast 每轮走 2 步，slow 每轮走 1 步；<br>
当fast == slow时， 两指针在环中 第一次相遇 。<br>
下面分析此时fast 与 slow走过的 步数关系 ：<br>
设链表共有 a+b 个节点，其中 链表头部到链表入口 有 a 个节点（不计链表入口节点）， 链表环 有 b 个节点（这里需要注意，a 和 b 是未知数）；设两指针分别走了f，s 步，则有：<br>
fast 走的步数是slow步数的 2 倍，即 f=2s；（解析： fast 每轮走 2 步）<br>
fast 比 slow多走了 n 个环的长度，即f=s+nb；（ 解析： 双指针都走过 a 步，然后在环内绕圈直到重合，重合时 fast 比 slow 多走 环的长度整数倍 ）；<br>
以上两式相减得：f=2nb，s=nb，即fast和slow 指针分别走了 2n，n个环的周长 （注意： n 是未知数，不同链表的情况不同）。<br>
目前情况分析：<br>
如果让指针从链表头部一直向前走并统计步数k，那么所有 走到链表入口节点时的步数 是：k=a+nb（先走 a 步到入口节点，之后每绕 1 圈环（ b 步）都会再次到入口节点）。<br>
而目前，slow 指针走过的步数为 nb 步。因此，我们只要想办法让 slow 再走 a 步停下来，就可以到环的入口。<br>
但是我们不知道 a 的值，该怎么办？依然是使用双指针法。我们构建一个指针，此指针需要有以下性质：此指针和slow 一起向前走 a 步后，两者在入口节点重合。那么从哪里走到入口节点需要 a 步？答案是链表头部head。<br>
双指针第二次相遇：<br>
slow指针位置不变 ，将fast指针重新 指向链表头部节点 ；slow和fast同时每轮向前走 1 步；<br>
TIPS：此时 f=0，s=nb ；<br>
当 fast 指针走到f=a 步时，slow 指针走到步s=a+nb，此时 两指针重合，并同时指向链表环入口 。<br>
返回slow指针指向的节点。</p>
</blockquote>
<p><strong>代码</strong></p>
<pre><code>ListNode *detectCycle(ListNode *head)
{
        if(nullptr == head) 
				{ return NULL; }
        ListNode *fast = head-&gt;next,*slow=head;
        while(fast != slow)
				{
            if(nullptr != fast &amp;&amp; nullptr != fast-&gt;next)
						{
                fast = fast-&gt;next-&gt;next; //注意判断条件和两次连续next，没必要分开两次判断next
						}
            else
             {   return NULL; }
            slow = slow-&gt;next;
        }
        fast = head;
        slow = slow-&gt;next;//注意这里，因为fast=head;相当于提前走了一步
        while(fast != slow)
       {     
						 fast = fast-&gt;next;
						 slow = slow-&gt;next;
				 }
        return slow;     
}
</code></pre>
<h3 id="单链表环长度">单链表环长度</h3>
<p><strong>思路</strong><br>
  快慢指针第一次相遇（超一圈）时开始计数，计数器累加，第二次相遇时停止计数<br>
  第二次相遇的时候快指针比慢指针正好又多走了一圈，也就是多走的距离等于环长</p>
<p><strong>代码：</strong></p>
<pre><code>//计算单链表环的长度  
int loopLength(pNode pHead)  
{  
	//首先通过上面的借口判断，链表是否有环
	if(isLoop(pHead) == false) 
	{
		return 0;  //没有环，则直接返回
	}
	pNode fast = pHead;  
	pNode slow = pHead;  
	int length = 0;  //环的长度
	bool begin = false;  //第一次相遇的 flag
	bool agian = false;  //第二次相遇的 flag
	while( fast != NULL &amp;&amp; fast-&gt;next != NULL)  
	{  
		fast = fast-&gt;next-&gt;next;  
		slow = slow-&gt;next;  
		//超两圈后停止计数，挑出循环  
		if(fast == slow &amp;&amp; agian == true)  
		{
			break;  
		}
		
		//超一圈后开始计数  
		if(fast == slow &amp;&amp; agian == false)  
		{             
			begin = true;  
			agian = true;  
		}  
		
		//计数 +1  
		if(begin == true)  
		{
			++length;
		}
	}  
	
	return length;  
} 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[volatile关键字]]></title>
        <id>https://lixin-scut.github.io//post/volatile-guan-jian-zi</id>
        <link href="https://lixin-scut.github.io//post/volatile-guan-jian-zi">
        </link>
        <updated>2020-03-16T10:32:07.000Z</updated>
        <content type="html"><![CDATA[<p>  volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。<br>
  遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，比如<br>
  <code>int num1 = numConst; int num2 = numConst;</code><br>
  由于编译器认为num2和num1所需赋的值一致，可能会把寄存器中num1的值直接给num2，但是多线程中很可能numConst已经被另一个线程改变了，从而导致num2的值不正确。<br>
  如果使用volatile来限定numConst，则可以提供对特殊地址的稳定访问。声明时语法：<br>
  <code>int volatile vInt;</code><br>
  当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。<br>
volatile用在如下的几个地方：</p>
<ol>
<li>中断服务程序中修改的供其它程序检测的变量需要加volatile；</li>
<li>多进程或多线程的并行并发环境下各任务间共享的标志应该加volatile；</li>
<li>存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；</li>
</ol>
<p>详细用法可参考<a href="https://www.cnblogs.com/god-of-death/p/7852394.html">C/C++ Volatile关键词深度剖析</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Effective C++摘录]]></title>
        <id>https://lixin-scut.github.io//post/effective-czhai-lu</id>
        <link href="https://lixin-scut.github.io//post/effective-czhai-lu">
        </link>
        <updated>2020-03-16T10:04:08.000Z</updated>
        <content type="html"><![CDATA[<p>今天遇到一道题：</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

class A {
public:
    virtual void foo(int a = 0) {
        cout &lt;&lt; a &lt;&lt; endl;
    }
};

class B : public A {
public:
    virtual void foo(int a = 1) {
        cout &lt;&lt; a &lt;&lt; endl;
    }
};

int main() {
    A* p = new B();
    p-&gt;foo();
}
</code></pre>
<p>问输出是啥？<br>
很明显问题在于默认值<br>
根据条款37:绝不重新定义继承而来的缺省参数值，因为缺省参数值是静态的，所以输出为0.<br>
感受到了Effective C++的强大，所以特地整合一下Effective的大概条款，方便以后扩充</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[网络状态分析工具]]></title>
        <id>https://lixin-scut.github.io//post/wang-luo-zhuang-tai-fen-xi-gong-ju</id>
        <link href="https://lixin-scut.github.io//post/wang-luo-zhuang-tai-fen-xi-gong-ju">
        </link>
        <updated>2020-03-16T08:50:37.000Z</updated>
        <content type="html"><![CDATA[<h3 id="ping">ping</h3>
<p>  ping （ Packet Internet Groper,因特网包探索器）是 Windows、UNIX 和 Linux 系统下的 一个命令。ping也属于一个通信协议，是TCP/IP协议的一部分。利用ping命令可以检查网 络是否连通，可以很好地帮助分析和判定网络故障。应用格式：<code>ping IPAddress</code>，该命令还可以加许多参数使用<br>
<img src="https://lixin-scut.github.io//post-images/1584348819311.png" alt=""><br>
  ping 发送一个 ICMP （Internet Control Messages Protocol,因特网信报控制协议），请求 消息给目的地并报告是否收到所希望的ICMP echo （ICMP回声应答），它是用来检查网络是否通畅或者网络连接速度的命令。<br>
  ping所利用的原理是这样的：利用网络上机器IP地址的唯一性，给目标IP地址发送一个数据包，再要求对方返回一个同样大小的数据包来确定两台网络机器是否连接相通以及时延是 多少。<br>
  ping指的是端对端连通，通常用来作为可用性的检查，</p>
<p>  Ping程序使用的是ICMP协议，并不具有通常所说的 TCP/UDP 端口<br>
  ICMP不像TCP或UDP有端口，但它确实含有两个域：类型(type)和代码(code)。而且这些域的作用和端口也完全不同<br>
  ping没有指定端口这个选项，它是网络层的，端口是传输层的概念。</p>
<p><strong>ping的使用</strong><br>
使用ping检查连通性有以下6个步骤。<br>
(1)使用ipconfig/all观察本地网络设置是否正确。<br>
(2) ping 127.0.0.1,来检查本地的TCP/IP协议有没有设置好。<br>
(3) ping本机IP地址，这样是为了检查本机的IP地址是否设置有误。<br>
(4) ping本网网关或本网IP地址，这样的是为了检查硬件设备是否有问题，也可以检 查本机与本地网络连接是否正常。(在非局域网中这一步骤可以忽略)<br>
(5) ping本地DNS地址，这样做是为了检查本地DNS服务器是否工作正常。<br>
(6) ping远程IP地址，这主要是检查本网或本机与外部的连接是否正常。ping远程IP 地址还可以用来测试网络延时。比如输入“pingwww.baidu.com”(百度域名)之后屏幕会显示<br>
  Linux的ping语法和Windows的差不多，但是Linux的ping数据包是64Byte,而 Windows的是32Byte, Windows下默认发送4次数据包后结束，Linux下的ping程序默认不停发送数据包，直到用户手动停止（停止指令是Ctrl+c）</p>
<h3 id="tcpdump">tcpdump</h3>
<p>  tcpdump可以将网络中传送的数据包的“头”完全截获下来提供分析。<br>
  它支持针 对协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助去掉无用 的信息。<br>
  由于它需要将网络界面设置为混杂模式，普通 用户不能正常执行，但具备root权限的用户可以直接执行它来获取网络上的信息。因此 系统中存在网络分析工具主要不会对本机安全产生威胁，而是会对网络上的其他计算机 的安全产生威胁。</p>
<p>  tcpdump根据使用者的定义对网络上的数据包进行截获和分析。<br>
  tcpdump支持相当多的不同参数，如使用-i参数指定tcpdump监听的网络界面，这在计 算机具有多个网络界面时非常有用；使用-c参数指定要监听的数据包数量，使用-w参数指 定将监听到的数据包写入文件中保存，等等。<br>
  tcpdump使用参数指定要监视数据包的类型、地址、端口等</p>
<p><strong>tcpdump使用</strong><br>
tcpdump采用命令行方式，它的命令格式为：</p>
<pre><code>tcpdump [ -adefInNOpqStvx ] [ -c 数量][-F 文件名]
[-i 网络接口 ] [ -r 文件名][-s snaplen ]
[-T类型][-w文件名][表达式]
</code></pre>
<p>  表达式是一个正则表达式，tcpdump利用它作为过滤报文的条件，如果一个报文满足表 达式的条件，则这个报文将会被捕获。如果没有给出任何条件，则网络上所有的信息包将会 被截获。在表达式中一般包含如下几种类型的关键字。<br>
1	）关于类型的关键字，主要包括host、net、port等，例如host 指明 一台主机，net 指明一个网络地址，port 指明端口号。如果没有指定类型，默认的类型是host。<br>
2	）确定传输方向的关键字，主要包括src、dst、dstorsrc、dst、src等，这些关键字 指明了传输的方向。举例说明，src指明IP包中源地址, dst net指明目的网络地址。如果没有指明方向关键字，则默认是src or dst关键字。<br>
3	）协议的关键字，主要包括fddi、ip、arp、rarp、tcp、udp等类型。如果没有指定任何协议，则tcpdump将会监听 所有协议的信息包。<br>
除了这3种类型的关键字之外，其他重要的关键字如下：gateway、broadcast、less、 greater等，还有3种逻辑运算：取非运算not/!,与运算and/&amp;&amp; ；或运算or/| | ；这些关键字可以组合起来构成强大的组合条件</p>
<p><strong>常用命令</strong><br>
1 ）截取某主机相关的包。<br>
a.	想要截获所有210.27.48.1的主机收到的和发出的所有的数据包，使用如下命令：<br>
<code>tcpdump host 210.27.48.1</code><br>
b.	想要截获主机210.27.48.1和主机210.27.48.2或210.27.48.3的通信，使用如下命令： （在命令行中使用括号时，一定要添加“\”）<br>
<code>tcpdump host 210.27.48.1 and \ (210.27.48.2 or 210.27.48.3 \）</code><br>
C.如果想要获取主机210.27.48.1除了和主机210.27.48.2之外所有主机通信的ip包，使 用如下命令：<br>
<code>tcpdump ip host 210.27.48.1 and ! 210.27.48.2</code><br>
d.如果想要获取主机210.27.48.1接收或发出的telnet包，使用如下命令：<br>
<code>tcpdump tcp port 23 host 210.27.48.1</code></p>
<p>2）	截取某端口相关的包。<br>
如果想要获取在端口 6666上通过的包，使用如下命令：<br>
<code>tcpdump port 6666</code></p>
<p>3）	截取某网卡的包。<br>
如果想要获取在网卡ethl上通过的包，使用如下命令：<br>
<code>tcpdump -iethl</code></p>
<h3 id="netstat">netstat</h3>
<p>  netstat命令用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本 机各端口的网络连接情况。netstat是在内核中访问网络及相关信息的程序，它能提供TCP连 接、对TCP和UDP的监听及获取进程内存管理的相关报告。</p>
<p>netstat的命令格式如下所示：<br>
netstat [-acCeFghilMnNoprstuvVwx] [-A&lt; 网络类型 &gt;][--ip]</p>
<p>  ①Active Internet connections, 称为有源TCP连接，其中Recv-Q和Send-Q指的是接收队列和发送队列，这些数字一般都 应该是0,如果不是则表示请求包和回包正在队列中堆积；<br>
  ②Active UNIX domain sockets, 称为有源UNIX域套接口<br>
  Proto显示连接使用的协议，RefCnt表示连接到本套接口上的进程号，Types显示套接口 的类型，State显示套接口当前的状态，Path表示连接到套接口的其他进程使用的路径名。<br>
常见参数如下所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-a</td>
<td style="text-align:center">(all)显示所有选项，默认不显示LISTEN相关</td>
</tr>
<tr>
<td style="text-align:center">-t</td>
<td style="text-align:center">(tcp)仅显示tcp相关选项</td>
</tr>
<tr>
<td style="text-align:center">-u</td>
<td style="text-align:center">(udp)仅显示udp相关选项</td>
</tr>
<tr>
<td style="text-align:center">-n</td>
<td style="text-align:center">拒绝显示别名，能显示数字的全部转化成数字。</td>
</tr>
<tr>
<td style="text-align:center">-l</td>
<td style="text-align:center">仅列出有在Listen (监听)的服务状态</td>
</tr>
<tr>
<td style="text-align:center">-P</td>
<td style="text-align:center">显示建立相关链接的程序名</td>
</tr>
<tr>
<td style="text-align:center">-r</td>
<td style="text-align:center">显示路由信息，路由表</td>
</tr>
<tr>
<td style="text-align:center">-e</td>
<td style="text-align:center">显示扩展信息，例如uid等</td>
</tr>
<tr>
<td style="text-align:center">-s</td>
<td style="text-align:center">按各个协议进行统计</td>
</tr>
<tr>
<td style="text-align:center">-c</td>
<td style="text-align:center">每隔一个固定时间，执行该netstat命令。</td>
</tr>
</tbody>
</table>
<p>提示：LISTEN和LISTENING的状态只有用-a或者才能看到</p>
<p>使用例子</p>
<table>
<thead>
<tr>
<th style="text-align:center">功能</th>
<th style="text-align:center">命令</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">(1)列出所有端口(包括监听和未监听的)：</td>
<td style="text-align:center">netstat -ao</td>
</tr>
<tr>
<td style="text-align:center">(2)列出所有 TCP 端 口:</td>
<td style="text-align:center">netstat -ato</td>
</tr>
<tr>
<td style="text-align:center">(3)列出所有 UDP 端口 :</td>
<td style="text-align:center">netstat -auo</td>
</tr>
<tr>
<td style="text-align:center">(4)列出所有处于监听状态的socket：</td>
<td style="text-align:center">netstat -lo</td>
</tr>
<tr>
<td style="text-align:center">(5)列出所有监听 TCP 端口的 socket：</td>
<td style="text-align:center">netstat -lto</td>
</tr>
<tr>
<td style="text-align:center">(6)列出所有监听 UDP 端口的 socket:</td>
<td style="text-align:center">netstat -luo</td>
</tr>
<tr>
<td style="text-align:center">(7)歹！J 出所有监听 UNIX 端口的 socket:</td>
<td style="text-align:center">netstat -lx。</td>
</tr>
<tr>
<td style="text-align:center">(8)在netstat输出中显示PID和进程名称：</td>
<td style="text-align:center">netstat -po</td>
</tr>
<tr>
<td style="text-align:center">(9)当你不想让主机，端口和用户名显示，使用数字代替那些名称。</td>
<td style="text-align:center">netstat-n</td>
</tr>
<tr>
<td style="text-align:center">(10)持续输出 netsta 信息:</td>
<td style="text-align:center">netstat -co</td>
</tr>
<tr>
<td style="text-align:center">(11)找出程序运行的端口 ：</td>
<td style="text-align:center">netstat -ap</td>
</tr>
<tr>
<td style="text-align:center">(12)找出运行在指定端口的进程，如</td>
<td style="text-align:center">netstat -an</td>
</tr>
<tr>
<td style="text-align:center">(13)显式网络接口列表：</td>
<td style="text-align:center">netstat -io</td>
</tr>
</tbody>
</table>
<p>(14) IP和TCP的分析，如查看链接某服务端口最多的IP地址命令是：<br>
<code>netstat -nat | grep &quot;192.168.1.15:22&quot; |awk '{print $5}'|awk -F: '(print $1 }'|sort|uniq -c|sort -nr|head -20</code><br>
(15) TCP 各自状态列表： <code>netstat -nat |awk '{print $6}'</code><br>
(16)先把各种TCP状态全都取出来，然后使用uniq -c统计，之后再进行排序：  <code>netstat -nat |awk'{print $6}'|sort|uniq -c</code></p>
<p><strong>netstat 常用命令详解</strong><br>
netstat 命令：用于显示各种网络相关信息，如网络连接，路由表，接口状态，无效连接，组播成员 等等。<br>
netstat命令是net-tools软件包中的一员<br>
<img src="https://lixin-scut.github.io//post-images/1583486844848.png" alt=""></p>
<p><strong>命令行选项：</strong><br>
-a:　　列出系统中所有网络连接，包括已经连接的网络服务、监听的网络服务和Socket套接字<br>
-t：　　列出TCP数据<br>
-u：　　列出UDP数据<br>
-l：　　列出正在监听的网络服务（不包含已经连接的网路服务）<br>
-n：　　用端口显示服务，而不用服务名<br>
-p：　　列出该服务的进程ID(PID)</p>
<p><strong>互联网联机字段:</strong><br>
 Proto :网络的封包协议，主要分为 TCP 与 UDP 封包，相关资料请参考服务器篇;<br>
 Recv-Q:非由用户程序链接到此 socket 的复制的总 bytes 数;<br>
 Send-Q:非由远程主机传送过来的 acknowledged 总 bytes 数;<br>
 Local Address :本地端的 IP:port 情况<br>
 Foreign Address:远程主机的 IP:port 情况<br>
 State :联机状态，主要有建立(ESTABLISED)及监听(LISTEN);</p>
<p><strong>本地socket file 的字段:</strong><br>
 Proto :一般就是 unix ;<br>
 RefCnt:连接到此 socket 的进程数量;<br>
 Flags :联机的旗标;<br>
 Type :socket 存取的类型。主要有确认联机的 STREAM 与不需确认的 DGRAM 两种;<br>
 State :若为 CONNECTED 表示多个进程之间已经联机建立。<br>
 Path :连接到此 socket 的相关程序的路径!或者是相关数据输出的路径。</p>
<p>例子：netstat -tlunp<br>
除了可以列出监听网络的接口与状态之外，最后一个字段还能够显示此服务的PID 号码以及进程的指令名称<br>
<img src="https://lixin-scut.github.io//post-images/1583487282316.png" alt=""><br>
使用netstat -an<br>
<img src="https://lixin-scut.github.io//post-images/1583487403214.png" alt=""></p>
<p><strong>完整选项</strong></p>
<pre><code>usage: netstat [-vWeenNcCF] [&lt;Af&gt;] -r         netstat {-V|--version|-h|--help}
       netstat [-vWnNcaeol] [&lt;Socket&gt; ...]
       netstat { [-vWeenNac] -i | [-cnNe] -M | -s [-6tuw] }

      -r, --route              display routing table
        -i, --interfaces         display interface table
        -g, --groups             display multicast group memberships
        -s, --statistics         display networking statistics (like SNMP)
        -M, --masquerade         display masqueraded connections

        -v, --verbose            be verbose
        -W, --wide               don't truncate IP addresses
        -n, --numeric            don't resolve names
        --numeric-hosts          don't resolve host names
        --numeric-ports          don't resolve port names
        --numeric-users          don't resolve user names
        -N, --symbolic           resolve hardware names
        -e, --extend             display other/more information
        -p, --programs           display PID/Program name for sockets
        -o, --timers             display timers
        -c, --continuous         continuous listing

        -l, --listening          display listening server sockets
        -a, --all                display all sockets (default: connected)
        -F, --fib                display Forwarding Information Base (default)
        -C, --cache              display routing cache instead of FIB
        -Z, --context            display SELinux security context for sockets

  &lt;Socket&gt;={-t|--tcp} {-u|--udp} {-U|--udplite} {-S|--sctp} {-w|--raw}
           {-x|--unix} --ax25 --ipx --netrom
  &lt;AF&gt;=Use '-6|-4' or '-A &lt;af&gt;' or '--&lt;af&gt;'; default: inet
</code></pre>
<p><strong>例子</strong><br>
(1)已知进程名，使用命令查看当前进程打开的文件句柄?<br>
执行命令“ulimit -a”,其中oepn files 对应的即为本机文件句柄数<br>
lsof -n |awk '{print $2}'|sort|uniq -c |sort -nr|more</p>
<p>[root@study ~]# lsof [-aUu] [+d]<br>
选项与参数:<br>
-a :多项数据需要『同时成立』才显示出结果时!<br>
-U :仅列出 Unix like 系统的 socket 文件类型;<br>
-u :后面接 username，列出该使用者相关进程所开启的文件; +d :后面接目录，亦即找出某个目录底下已经被开启的文件!</p>
<p>(2)已知进程名，使用命令查看当前进程的网络连接状态?<br>
netstat -tlunp<br>
(3)已知进程名，查看 eth0 网卡与 ip10.10.10.10:10653 之间的 TCP 数据包?<br>
tcpdump -i eth0 -nn 'tcp and port 10653 and host 10.1.1.180'</p>
<h3 id="lsof">lsof</h3>
<p>  lsof (list open file)是一个列出当前系统打开文件的工具。在Linux环境下，任何事物都 以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。所以 如传输控制协议(TCP)和用户数据报协议(UDP)套接字等，系统在后台都为该应用程序分 配了一个文件描述符，无论这个文件的本质如何，该文件描述符为应用程序与基础操作系统 之间的交互提供了通用接口。因为应用程序打开文件的描述符列表提供了大量关于这个应用 程序本身的信息，因此通过lsof工具能够查看这个列表对系统监测以及排错将是很有帮助的。<br>
  在终端下输入lsof即可显示系统打开的文件，因为lsof需要访问核心内存和各种文件, 所以必须以root用户的身份运行才能够充分地发挥其功能。</p>
<p><strong>输出结果</strong><br>
(1)每行显示一个打开的文件，若不指定条件默认将显示所有进程打开的所有文件。<br>
lsof输出各列信息的意义如下所述。</p>
<ol>
<li>COMMAND：进程的名称。</li>
<li>PlD：进程标识符。</li>
<li>USER：进程所有者。</li>
<li>FD：文件描述符，应用程序通过文件描述符识别该文件如cwd、txt等。</li>
<li>TYPE：文件类型，如DlR、REG等。</li>
<li>DEVlCE：指定磁盘的名称。</li>
<li>SIZE:文件的大小。</li>
<li>NODE：索引节点(文件在磁盘上的标识)。</li>
<li>NAME：打开文件的确切名称。</li>
</ol>
<p>(2)lsof语法格式是：<br>
lsof [ options ] filename</p>
<p>(3)	常用的参数列表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">lsof filename</td>
<td style="text-align:center">显示打开指定文件的所有进程</td>
</tr>
<tr>
<td style="text-align:center">lsof -a</td>
<td style="text-align:center">表示两个参数都必须满足时才显示结果</td>
</tr>
<tr>
<td style="text-align:center">lsof -c strlng</td>
<td style="text-align:center">显示COMMAND列中包含指定字符的进程所有打开的文件</td>
</tr>
<tr>
<td style="text-align:center">lsof -u username</td>
<td style="text-align:center">显示所属user进程打开的文件</td>
</tr>
<tr>
<td style="text-align:center">lsof -g gld</td>
<td style="text-align:center">显示归属gld的进程情况</td>
</tr>
<tr>
<td style="text-align:center">lsof +d /DlR/</td>
<td style="text-align:center">显示目录下被进程打开的文件</td>
</tr>
<tr>
<td style="text-align:center">lsof +D /DlR/</td>
<td style="text-align:center">同上，但是会搜索目录下的所有目录，时间相对较长</td>
</tr>
<tr>
<td style="text-align:center">lsof -d FD</td>
<td style="text-align:center">显示指定文件描述符的进程</td>
</tr>
<tr>
<td style="text-align:center">lsof -n</td>
<td style="text-align:center">不将工P转换为hostname,缺省是不加上-n参数</td>
</tr>
<tr>
<td style="text-align:center">lsof -i</td>
<td style="text-align:center">用以显示符合条件的进程情况</td>
</tr>
</tbody>
</table>
<p>(4)常用命令如下所述。<br>
1 )查看6666端口现在运行情况,命令：<br>
<code>lsof -i :6666</code><br>
2)查看所属root用户进程所打开的文件，文件类型为.txt：<br>
<code>lsof -a -u root-d txt</code><br>
3)监控打开的文件和设备。查看设备/dev/ttyl被哪些进程占用的命令是:<br>
<code>lsof /dev/tty1</code><br>
4）监控程序。如查看指定程序server打开的文件：<br>
<code>lsof -c server</code><br>
5）监控用户。比如查看指定用户sharexu打开的文件：<br>
<code>lsof -u sharexu</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux调试工具]]></title>
        <id>https://lixin-scut.github.io//post/linux-diao-shi-gong-ju</id>
        <link href="https://lixin-scut.github.io//post/linux-diao-shi-gong-ju">
        </link>
        <updated>2020-03-16T07:45:38.000Z</updated>
        <content type="html"><![CDATA[<p>这几天专门看了一下Linux下的调试工具，为项目测试作准备</p>
<p>  应用程序必须和操作系统之间进行交互。但是，应用程序是不能直接访问Linux内核的。它既不能访问内核所占内 存空间，也不能调用内核函数。不过，应用程序可以跳转到system_call的内核位置，内核会检查系统调用号，这个号码会告诉内核进程正在请求哪种服务。然后，它查看系统调用表, 找到所调用的内核函数入口地址，调用该函数，然后返回到进程。<br>
  所有操作系统在其内核都有一些内建的函数，这些函数可以用来完成一些系统级别的功能，一般称Linux系统上的这些函数为“系统调用”(system call)。这些函数代表了用户空间到内核空间的一种转换，例如，在用户空间调用open函数，在内核空间则会调用sys_open</p>
<p>  系统调用的错误码：系统调用并不直接返回错误码，而是将错误码放入一个名为errno的全局变量中。如果一个系统调用失败，你可以读出errno的值来确定问题的所在。ermo不同数值所代表的错误消息定义在errno.h中，你也可以通过命令&quot;man 3 ermo&quot;来查看它们。<br>
  需要注意的是，errno的值只在函数发生错误时设置，如果函数不发生错误，errno的值就无定义，并不会被置为0。另外，在处理errno前最好先把它的值存入另一个变量，因为在错误处理过程中，即使像printf()这样的函数出错时也会改变ermo的值。</p>
<h3 id="strace">strace</h3>
<p>  strace就是一个通过跟踪系统调用来让开发者知道一个程序在后台所做事情的工具。</p>
<p><strong>strace执行</strong><br>
首先用strace调用可执行文件<br>
每一行都是一次系统调用，等号左边是系统调用的函数名及其参数，右边是该调用的返回值。</p>
<p>  对于命令行下执行的程序，execve (或exec系列调用中的某一个)均为strace输出系统 调用中的第一个。strace首先调用fork或clone函数新建一个子进程，然后在子进程中调用 exec载入需要执行的程序<br>
  调用过程中会使用mmap来进行匿名内存映射，就是为了不涉及具体的文件名，避免了文件的创建及打开，这种只能用于具有亲缘关系的进程间通信。<br>
  真正能与源码对应上的只有少部分系统调用，其他系统调用几乎都用于进行进程初始化工作：装载被执行程序、载入libc函数库、设置内存映射等。</p>
<p><strong>可以用strace来跟踪信号传递</strong><br>
  在strace调用可执行文件的时候，可以打开另外一个窗口，输入命令&quot;killall test&quot;,<br>
strace 中的结果会显示 test 进程 “+++ killed by SIGTERM +++”。（命令 killall test, 就是杀死所有名为test的进程。）</p>
<p><strong>统计系统调用</strong><br>
<code>strace -c ./test</code><br>
  通过使用参数-c,它还能将进程所有的系统调用做一个统 计分析并返回。<br>
  程序调用的函数、调用函数的次数，各个系统函数，调用次数多少、消耗了多少时间等这些信息都清晰可见。</p>
<p><strong>其他常用选项</strong><br>
  除了-c参数之外，strace还提供了其他有用的参数，能很方便地得到自己想要的信息,<br>
  参数-o：用在将strace的结果输出到文件中，如果不指定-o参数的话，默认的输出设备是STDERR<br>
  参数-T：strace可以使用参数-T将每个系统调用所花费的时间打印出来，每个调用的时间花销都体现在调用行最右边的尖括号里面<br>
  strace的-t、-tt、-ttt参数则是记录每次系统调用发生的时间，分别精确到秒、微秒和UNIX时间戳的微秒。<br>
  strace不光能自己初始化一个进程进行strace,还能追踪现有的进程，参数-p就是取这 个作用的，<br>
<code>strace -p pid</code><br>
pid是指进程id。</p>
<p><strong>用strace调试程序</strong><br>
当程序存在无法执行的问题时，<code>strace ./test</code>可以用于定位问题语句的位置。</p>
<h3 id="gdb">GDB</h3>
<p>  gdb是gcc的调试工具，主要用于C和C++这两种语言编写的程序。它的功能很强大, 主要体现在以下4点：<br>
①启动程序，可以按照用户自定义的要求随心所欲地运行程序；<br>
②可让被调试的程序在指定的断点处停住；<br>
③当程序被停住时，可以检查此时程序中运行的状态;<br>
④动态地改变程序的执行环境。</p>
<p>  要调试C/C++的程序，首先在编译时，必须要把调试信息加到可执行文件中。使用编译器(cc/gcc/g++)的-g参数可以做到这一点，如下代码：</p>
<pre><code>gcc -g hello.c -o hello	
g++ -g hello.cpp -o hello	
</code></pre>
<p>  如果没有-g,你将看不见程序的函数名、变量名，所代替的全是运行时的内存地址。 当用-g把调试信息加入之后，并成功编译目标代码以后，让我们来看看如何用gdb来调试它。<br>
启动gdb的方法：<br>
1	) gdb program<br>
program也就是你的执行文件，一般在当前目录下。<br>
2	) gdb program core<br>
用gdb同时调试一个运行程序和core文件，core是程序非法执行后core dump后产生的 文件。<br>
3	) gdb program 1234<br>
如果程序是一个服务程序，那么可以指定这个服务程序运行时的进程ID, gdb会自动进行attach操作，并调试这个程序。并且program应该在PATH环境变量中搜索 得到。</p>
<p><strong>gdb常用用法</strong><br>
输入gdb test命令， 启动gdb<br>
输入” 1 “后（1命令相当于list）,从第一行开始列出源码<br>
执行“bl5”，表示设置在源码15行处设置断点<br>
执行“b func”，表示设置断点在函数 func入口处<br>
执行“ info break ”，表示查看断点的信息，<br>
执行r命令，表示运行程序，run命令简写<br>
输入“n”,表示单条语句执行，next命令简写<br>
输入“p i” “p arr[i]” ，分别打印变量i和变量arr[i]的值<br>
输入“bt”，查看函数堆栈<br>
输入“finish”，退出函数<br>
输入“q”，结束调试</p>
<p><strong>用gdb分析coredump文件</strong><br>
  gdb还可以用于分析coredump文件。core,又称之为coredump文件，是UNIX/Linux操 作系统的一种机制，对于线上服务而言，core令人闻之色变，因为出core的过程意味着服务 暂时不能正常响应，需要恢复，<br>
  coredump文件含有当进程被终止时内存、CPU寄存器和各种函数调用堆栈信息等，可 以供后续开发人员进行调试。</p>
<p><strong>coredump文件的存储路径</strong><br>
有时候在执行程序时，会出现提示Segmentation fault，但在当前目录下却没有找到 coredump文件，可以通过下面的命令看到core文件的存在位置：<br>
<code>cat /proc/sys/kernel/core_pattern</code><br>
默认值是core,也就是当前目录，如果不是core,则是在指定的目录下。<br>
<strong>注意这里是指在进程当前工作目录的下创建。通常与程序在相同的路径下。但如果程序中 应 调用了 chdir函数，则有可能改变了当前工作目录。这时core文件创建在chdir指定的路径下。</strong> 有好多程序即使崩溃了，也找不到core文件放在什么位置，这和chdir函 数就有关系。当然程序崩溃了不一定都产生core文件。</p>
<p>剩下的我之前的博文已经介绍过了，详情可看：</p>
<h3 id="top">top</h3>
<p>  top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状 况，类似于Windows的任务管理器。</p>
<p>  第1行分别显示：系统当前时间、系统运行时间、当前用户登录数和系统负载。系统负载（load average）,这里有3个数值，分别是系统最近1min、5min、15min的平均负载。一般对于单个处理器来说，负载在0~1.00是正常的，超过1.00就要引起注意了。在多核处理 器中，系统均值不应该高于处理器核心的总数。</p>
<p>  第2行分别显示：total（进程总数）、running（正在运行的进程数）,sleeping（睡眠的进程数）、 stopped （停止的进程数）和zombie （僵尸进程数）。</p>
<p>  第3行分别显示：％us（用户空间占用CPU百分比）、％sy（内核空间占用CPU百分比）、％ni （用户进程空间内改变过优先级的进程占用CPU百分比）、％id （空闲CPU百分比）、％wa （等 待输入输出（I/O）的CPU时间百分比）、%hi （ cpu处理硬件中断的时间）、%si （ cpu处理软 中断的时间）、％st （用于有虚拟cpu的情况）。通常id%值可以反映一个系统cpu的闲忙程度。</p>
<p>  第4行则显示内存MEM的数据：total （物理内存总量）、used （使用的物理内存总量）、free （空闲内存总量）、buffers （用作内核缓存的内存量）</p>
<p>  第5行则显示交换器SWAP的数据：total（交换区总量）、used（使用的交换区总量）,free（空 闲交换区总量）.cached （缓冲的交换区总量）<br>
  buffers和cached的区别需要说明一下，buffers指的是块设备的读写缓冲区，cached指 的是文件系统本身的页面缓存。它们都是Linux操作系统底层的机制，目的就是为了加速对磁盘的访问。</p>
<p>  第6行则显示PID （进程号）、USER （运行用户）、PR （优先级）、NI （任务nice值）、VIRT （虚 拟内存用量）VIRT=SWAP+RES、RES（物理内存用量）、SHR（共享内存用量）、S（进程状态）、％CPU （CPU占用比）、%MEM （物理内存占用比）、TIME+ （累计CPU占用时间）、COMMAND命令名/命令行。<br>
  top命令显示系统当前的进程和其他状况，top是一个动态显示过程，即可以通过用户 按键来不断刷新当前状态。如果在前台执行该命令，它将独占前台，直到用户终止该程序为止。比较准确地说，top命令提供了实时地对系统处理器的状态监视。它将显示系统中CPU 最“敏感”的任务列表。该命令可以按CPU使用、内存使用和执行时间对任务进行排序；而 且该命令的很多特性都可以通过交互式命令或者在个人定制文件中进行设定。<br>
  输入“q”,则退出top命令。</p>
<h3 id="ps">ps</h3>
<p>  Linux中的ps （ process status）命令列出的是当前在运行的进程的快照，就是执行ps命 令的那个时刻的那些进程，如果想要动态地显示进程信息，就可以使用top命令。<br>
  要对进程进行监测和控制，首先必须要了解当前进程的情况，也就是需要查看当前进 程，而ps命令就是最基本同时也是非常强大的进程查看命令。使用该命令可以确定有哪些进 程正在运行及其运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源 等。总之大部分信息都是可以通过执行该命令得到的。<br>
  ps命令提供进程的一次性的查看，它所提供的查看结果并不动态连续的；如果想对进程时间监控，应该用top命令。<br>
kill命令用于杀死进程</p>
<p>（1 ） Linux上进程有5种状态，如下所述。<br>
1	）运行（正在运行或在运行队列中等待）。<br>
2）	中断（休眠中，受阻，在等待某个条件的形成或接受到信号）。<br>
3）	不可中断（收到信号不唤醒和不可运行，进程必须等待直到有中断发生）。<br>
1	）僵死（进程已终止，但进程描述符存在，直到父进程调用wait4（）系统调用后释放）。<br>
2	）停止（进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行）。</p>
<p>（2）	ps工具标识进程的5种状态码，如下所述。<br>
1	) D 不可中断：uninterruptible sleep (usually IO)o<br>
2	) R 运行:runnable (on run queue) 0<br>
3	) S 中断：sleepingo<br>
4	) T 停止:traced or stopped o<br>
5	) Z 僵死:a defunct (&quot;zombien) process o<br>
命令格式是：ps[参数]。命令功能是用来显示当前进程的状态。<br>
表5-1 ps命令常用参数</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">功 能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a</td>
<td style="text-align:center">显示所有进程</td>
</tr>
<tr>
<td style="text-align:center">-a</td>
<td style="text-align:center">显示同一终端下的所有程序</td>
</tr>
<tr>
<td style="text-align:center">-A</td>
<td style="text-align:center">显示所有进程</td>
</tr>
<tr>
<td style="text-align:center">c</td>
<td style="text-align:center">显示进程的真实名称</td>
</tr>
<tr>
<td style="text-align:center">-e</td>
<td style="text-align:center">-e等于“-A”</td>
</tr>
<tr>
<td style="text-align:center">e</td>
<td style="text-align:center">显示环境变量</td>
</tr>
<tr>
<td style="text-align:center">f</td>
<td style="text-align:center">显示程序间的关系</td>
</tr>
<tr>
<td style="text-align:center">-H</td>
<td style="text-align:center">显示树状结构</td>
</tr>
<tr>
<td style="text-align:center">r</td>
<td style="text-align:center">显示当前终端的进程</td>
</tr>
<tr>
<td style="text-align:center">T</td>
<td style="text-align:center">显示当前终端的所有程序</td>
</tr>
<tr>
<td style="text-align:center">u</td>
<td style="text-align:center">指定用户的所有进程</td>
</tr>
<tr>
<td style="text-align:center">-au</td>
<td style="text-align:center">显示较详细的资讯</td>
</tr>
<tr>
<td style="text-align:center">-aux</td>
<td style="text-align:center">显示所有包含其他使用者的行程</td>
</tr>
<tr>
<td style="text-align:center">-C</td>
<td style="text-align:center">列出指定命令的状况</td>
</tr>
<tr>
<td style="text-align:center">-help</td>
<td style="text-align:center">显示帮助信息</td>
</tr>
<tr>
<td style="text-align:center">-version</td>
<td style="text-align:center">显示版本</td>
</tr>
</tbody>
</table>
<p><strong>显示指定用户信息。</strong><br>
命令:ps -u sharexu<br>
<strong>显示所有进程信息，连同命令行。</strong><br>
命令:ps -ef</p>
<p><strong>ps与grep常用组合用法，查找特定进程。</strong><br>
命令：ps -ef | grep test</p>
<p><strong>将目前登入的PID与相关信息列示出来。</strong><br>
命令：ps -l<br>
各相关信息的意义如下所述。</p>
<ol>
<li>F代表这个程序的旗标(flag), 4代表使用者为super user0</li>
<li>S代表这个程序的状态(STAT),关于各STAT的意义将在下文中介绍。</li>
<li>UID程序被该UID所拥有。</li>
<li>PID就是这个程序的进程ido</li>
<li>PPID则是其父进程的进程ido</li>
<li>C是使用的CPU资源百分比。</li>
<li>PRI是Priority (优先执行序)的缩写。</li>
<li>NI 是 Nice 值。</li>
<li>ADDR是kernel function,指出该程序在内存的那个部分。如果是个running的程序, 一般就是&quot;-&quot;o</li>
<li>SZ使用掉的内存大小。</li>
<li>WCHAN目前这个程序是否正在运作当中，若为-表示正在运作。</li>
<li>TTY登入者的终端机位置。</li>
<li>TIME使用掉的CPU时间。</li>
<li>CMD所下达的指令内容。<br>
在预设的情况下，ps仅会列出与目前所在的bash shell有关的PID而已，所以，当使用 ps -l的时候，只有2个PID。</li>
</ol>
<p><strong>列出目前所有的正在内存当中的程序。</strong><br>
命令:ps aux</p>
<ol>
<li>USER：该进程属于那个使用者账号的。</li>
<li>PID：该进程的号码。</li>
<li>%CPU：该进程使用掉的CPU资源百分比。</li>
<li>%MEM：该进程所占用的物理内存百分比。</li>
<li>VSZ：该进程使用掉的虚拟内存量(KBytes)。</li>
<li>RSS：该进程占用的固定的内存量(KBytes)o</li>
<li>TTY ：该进程是在那个终端机上面运作，若与终端机无关，则显示“？”，另外, ttyl-tty6是本机上面的登入者程序，若为pts/O等，则表示为由网络连接进主机的程序。</li>
<li>STAT：该程序目前的状态，主要的状态有以下几种。<br>
R：该程序目前正在运作，或者是可被运作。<br>
S：该程序目前正在睡眠当中(可说是idle状态)，但可被某些信号(signal)唤醒。<br>
T：该程序目前正在侦测或者是停止了。<br>
Z：该程序应该已经终止，但是其父程序却无法正常地终止它，造成zombie (僵死)程 序的状态。<br>
START：该process被触发启动的时间。<br>
TIME：该process实际使用CPU运作的时间。<br>
COMMAND：该程序的实际指令。</li>
</ol>
<h3 id="valgrind">Valgrind</h3>
<p>Valgrind由内核以及基于内核的其他调试工具组成。内核类似于一个框 架，它模拟了一个CPU环境，并提供服务给其他工具；而其他工具则类似于插件，利用内核 提供的服务完成各种特定的内存调试任务。<br>
Valgrind包括如下一些工具。<br>
  (1 ) Memcheck :这是Valgrind应用最广泛的工具，一个重量级的内存检查器，能够发现开 发中绝大多数内存错误使用情况，<br>
  (2) Callgrind：和gprof类似的分析工具，但它对程序的运行观察更是入微，能提供更多的 信息。和gprof不同，它不需要在编译源代码时附加特殊选项，但推荐加上调试选项。Callgrind 收集程序运行时的一些数据，建立函数调用关系图，还可以有选择地进行Cache模拟。在运行 结束时，它会把分析数据写入一个文件。callgrind_annotate可以把这个文件的内容转化成可读 的形式。<br>
  (3 ) Cachegrind：它主要用来检查程序中缓存使用出现的问题。Cache分析器，它模拟CPU 中的一级缓存II、D1和二级缓存，能够精确地指出程序中Cache的丢失和命中。如果需要，它 还能够为用户提供Cache丢失次数、内存引用次数以及每行代码、每个函数、每个模块及整个 程序产生的指令数，这对优化程序有很大的帮助。<br>
  (4)	Helgrind：它主要用来检查多线程程序中出现的竞争问题。Helgrind寻找内存中被多个 线程访问，而又没有一贯加锁的区域，这些区域往往是线程之间失去同步的地方，而且会导致 难以发掘的错误。Helgrind实现了名为Eraser的竞争检测算法，并做了进一步改进，减少了报 告错误的次数。<br>
  (5)	Massif：堆栈分析器，它能测量程序在堆栈中使用了多少内存，告诉我们堆块、堆管 理块和栈的大小。Massif能帮助我们减少内存的使用，在带有虚拟内存的现代系统中，它还能 够加速程序的运行，减少程序停留在交换区中的几率。<br>
  (6 ) Extension：可以利用Core提供的功能，自己编写特定的内存调试工具。</p>
<p><strong>Linux程序内存空间布局</strong><br>
一个典型的Linux下的C程序内存空间由如下几部分组成。<br>
  (1)	代码段(-text segment):代码段通常是指用来存放程序执行代码的一块内存区域。 这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读，某些架构也允许 代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字 符串常量等。程序段是程序代码在内存中的映射，一个程序可以在内存中有多个副本。<br>
  (2 )初始化数据段(.data segment):通常是指用来存放程序中已初始化的全局变量的一 块内存区域，例如，位于所有函数之外的全局变量：intval=100。需要强调的是，以上内容 都是位于程序的可执行文件中，内核在调用ex乩函数启动该程序时从源程序文件中读入。数 据段属于静态内存分配。<br>
  (3 )未初始化数据段(.bss segment):通常是指用来存放程序中未初始化的全局变量的 一块内存区域。BSS是Block Started by Symbol的简称。<br>
(4)堆(heap)：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可 动态地扩张或缩减。当进程调用malloc/什ee等函数分配内存时，新分配的内存就被动态添加 到堆上(堆被扩张)或释放的内存从堆中被剔除(堆被缩减)。<br>
  栈(stack)：栈又称堆栈，存放程序的局部变量(但不包括static声明的变量，static 意味着在数据段中存放变量)。除此以外，在函数被调用时，栈用来传递参数和返回值。由 于栈的先进后出特点，所以栈特别方便用来保存/恢复调用现场。而动态内存分配，需要程序员手工分配，手工释放。</p>
<p><strong>堆栈的区别</strong><br>
由于堆、栈尤为重要，这里讲下堆栈之间的区别。<br>
(1)	申请方式不同。<br>
栈：由系统自动分配。<br>
堆：需要程序员自己申请，并指明大小<br>
(2)	申请后系统的响应不同。<br>
  栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常， 提示栈溢出。<br>
  堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申 请时，会遍历该链表，寻找第一个空间中大于所申请空间的堆结点，然后将该结点从空闲结 点链表中删除，并将该结点的空间分配给程序。<br>
  其次，对于大多数系统，会在这块内存空间 中的首地址处记录本次分配的大小，这样代码中的delete语句才能正确的释放本内存空间。 最后，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动地将多余的那部分 重新放入空闲链表中。<br>
(3)	申请大小的限制不同<br>
  栈：栈是向低地址扩展的数据结构，是一块连续的内存的区域。<br>
  栈顶的地址和栈的最大容量是系统预先规定好的，在Linux下，栈的大小是一个常数(虽然可 以设置，但它是一个编译时就确定的常数)，如果申请的空间超过栈的剩余空间时，将提示 overflow,因此，能从栈获得的空间较小。用ulimit -a命令可以看到栈大小的限制<br>
  堆：堆是向高地址扩展的数据结构，是不连续的内存区域。<br>
  这是由于系统是用链表来存储的空闲 内存地址的，自然是不连续的，而链表的遍历方向是 由低地址向高地址。堆的大小受限于计算机系统中有 效的虚拟内存。<br>
(4)	申请效率不同。<br>
  栈由系统自动分配，速度较快；但程序员是 无法控制的。<br>
  堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片；不过用起来最 方便。<br>
(5)	堆和栈中的存储内容不同。<br>
  栈：在函数调用时，第一个进栈的是主函数中后的下一条指令(函数调用语句的下一 条可执行语句)的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左 入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局 部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条 指令，程序由该点继续运行。<br>
  堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。</p>
<p>分配情况，有以下2个特点。<br>
  (1)	传入的参数，局部变量，都是在栈顶分布，随着子函数的增多而向下增长。<br>
  (2)	函数的调用地址(函数运行代码)，全局变量，静态变量都是在分配内存的底部存在，而malloc分配的堆则存在于这些内存之上，并向上生长。</p>
<p><strong>内存检查原理</strong><br>
Memcheck能够检测出内存问题，关键在于其建立了两个全局表<br>
  1 ) Valid-Value表：对于进程的整个地址空间中的每一个字节(Byte),都有与之对应的 8 bit；对于CPU的每个寄存器，也有一个与之对应的bit向量。这些bit负责记录该字节或者 寄存器值是否具有有效的、已初始化的值。<br>
  2 ) Valid-Address表：对于进程整个地址空间中的每一个字节(Byte),还有与之对应的 1 bit,负责记录该地址是否能够被读写。<br>
  检测原理：当要读写内存中某个字节时，首先检查这个字节对应的A bit。如果该A bit 显示该位置是无效位置，Memcheck则报告读写错误。<br>
  内核(core)类似于一个虚拟的CPU环境，这样当内存中的某个字节被加载到真实的 CPU中时，该字节对应的V bit也被加载到虚拟的CPU环境中。一旦寄存器中的值，被用来 产生内存地址，或者该值能够影响程序输出，则Memcheck会检查对应的Vbit,如果该值尚 未初始化，则会报告使用未初始化内存错误。</p>
<p><strong>Valgrind 安装</strong><br>
建议直接brew或者apt哈哈哈</p>
<p><strong>Valgrind 使用</strong><br>
  Valgrind的参数分为两类，一类是core的参数，它对所有的工具都适用；另外一类就是具体某个工具如Memcheck的参数。Valgrind 默认的工具就是Memcheck,也可以通过--tool=tool name指令指定其他的工具。</p>
<p><strong>使用Memcheck的输入命令如下：</strong><br>
<code>/home/sharexu/software/valgrind/bin/valgrind ./test</code></p>
<p><strong>Memcheck能够检测的情况</strong><br>
<strong>使用未初始化的内存</strong><br>
  对于位于程序中不同段的变量，其初始值是不同的，全局变量和静态变量初始值为0, 而局部变量和动态申请的变量，其初始值为随机值。如果程序使用了为随机值的变量，那么 程序的行为就变得不可预期。</p>
<p><strong>内存读写越界</strong><br>
  内存读写越界是指访问了没有权限访问的内存地址空间，比如访问数组时越界、对动态 内存访问时超出了申请的内存大小范围。</p>
<p><strong>内存覆盖</strong><br>
  C语言的强大和可怕之处在于其可以直接操作内存，C标准库中提供了大量这样的函数, 比如strcpy、stmcpy、memcpy、strcat等，这些函数有一个共同的特点就是需要设置源地址(src) 和目标地址(dst),且src和dst指向的地址不能发生重叠，否则结果将不可预期。</p>
<p><strong>动态内存管理错误</strong><br>
  常见的内存分配方式分3种：静态存储、栈上分配、堆上分配。全局变量属于静态存储, 它们是在编译时就被分配了存储空间；函数内的局部变量属于栈上分配；而最灵活的内存使 用方式当属堆上分配，也叫作内存动态分配。常用的内存动态分配函数包括：malloc、alloc、realloc、new等，动态释放函数包括ftee和delete等。<br>
一旦成功申请了动态内存，就需要自己对其进行内存管理</p>
<p>(1 )申请和释放不一致。<br>
  由于C++兼容C,而C与C++的内存申请和释放函数是不同的，因此在C++程序 中，就有两套动态内存管理函数。一条不变的规则就是采用C方式申请的内存就用C方式 释放；用C++方式申请的内存，用C++方式释放。也就是用malloc/alloc/realloc方式申请 的内存，用free释放；用new方式申请的内存用delete释放。但在上述程序第11行中，用 malloc方式申请了内存却用delete来释放，虽然这在很多情况下不会有问题，但这绝对是 潜在的问题。<br>
(2)	申请和释放不匹配。<br>
  申请了多少内存，在使用完成后就要释放多少。如果没有释放，或者少释放了就是内存 泄露；多释放了也会产生问题。上述程序中，指针p和pt指向的是同一块内存，却被先后释 放两次。<br>
(3)	释放后仍然读写。<br>
  本质上说，系统会在堆上维护一个动态内存链表，如果被释放，就意味着该块内存可以 继续被分配给其他部分，如果内存被释放后再访问，就可能覆盖其他部分的信息，这是一种 严重的错误，</p>
<p>  程序非法读写内存都不一定会出现coredump,但释放无效内存则一定会出现coredump</p>
<p><strong>内存泄漏</strong><br>
  内存泄露(memory leak)指的是，在程序中动态申请的内存，在使用完后既没有释放, 又无法被程序的其他部分访问。内存泄露是在开发大型程序中最令人头疼的问题之一，以至 于有人说，内存泄露是无法避免的。其实不然，防止内存泄露要从良好的编程习惯做起，另外重要的一点就是要加强单元测试(unit test),而Memcheck就是这样一款优秀的工具。<br>
  在一个单独的函数中，每个人的内存泄露意识都是比较强的。但很多情况下，我们都会 对malloc/free或new/delete做一些包装，以符合特定的需要，无法做到在一个函数中进行既使用又释放的操作。<br>
  所以内存泄露最容易发生的地方：即两个部分的接口部分, 一个函数申请内存，一个函数释放内存。并且这些函数由不同的人开发、使用，这样造成内 存泄露的可能性就比较大了。这需要养成良好的单元测试习惯，将内存泄露问题消灭在初始 阶段。<br>
  Memcheck将内存泄露分为两种，一种是可能的内存泄露(possibly lost),另外一种是确定的内存泄露(definitely lost)<br>
  可能的内存泄露是指仍然存在某个指针能够访问某块内存，但该指针指向的已经不是该内存 首地址。确定的内存泄露是指已经不能够访问这块内存。<br>
  而确定的内存泄露又分为两种：间接的（direct）和间接的（indirect）。直接和间接的区别就是，直接是没有任何指针指向 该内存；间接是指指向该内存的指针都位于内存泄露处。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[REUSEADDR和REUSEPORT]]></title>
        <id>https://lixin-scut.github.io//post/reuseaddr-he-reuseport</id>
        <link href="https://lixin-scut.github.io//post/reuseaddr-he-reuseport">
        </link>
        <updated>2020-03-16T02:16:38.000Z</updated>
        <content type="html"><![CDATA[<p>首先讲个基本知识<br>
一个TCP/UDP连接(Connection)的socket，就是由下面五个值组成元组。</p>
<pre><code>{&lt;protocol&gt;, &lt;src addr&gt;, &lt;src port&gt;, &lt;dest addr&gt;, &lt;dest port&gt;}
</code></pre>
<p>socketfd是套接字描述符，本身只指定了协议，需要bind到socket上。</p>
<p>SO_REUSEADDR<br>
SO_REUSEADDR是很早就出现的socket选项<br>
  作用1：在为Socketfd设置了SO_REUSEADDR以后，判断冲突的方式就变了。<br>
  只要地址不是正好相同，那么多个socketFd就能绑定到同一ip上。比如0.0.0.0和192.168.0.100，虽然逻辑意义上前者包含了后者，但是0.0.0.0泛指所有本地ip，而192.168.0.100特指某一ip，两者并不是完全相同，所以socketFd尝试绑定的时候，不会再报EADDRINUSE，而是绑定成功。<br>
  作用2:避免TIME_WAIT长时间等待<br>
  服务器可以设置SO_REUSEADDR套接字选项来通知内核，如果端口忙，但TCP连接位于TIME_WAIT状态时可以重用端口。在一个非常有用的场景就是，如果你的服务器程序停止后想立即重启，而新的套接字依旧希望使用同一端口，此时SO_REUSEADDR选项就可以避免TIME_WAIT状态。</p>
<p>SO_REUSEPORT<br>
SO_REUSEPORT是新出的socket选项<br>
  首先明确一点：accept不会产生新的端口号，所以只要socket中的addr不同，就能够使用同一端口并正确识别。<br>
  在以前的情况中，只能有一个进程或线程socket的套接字描述符bind一个端口。<br>
  使用SO_REUSEPORT后，就可以达到多进程或多线程socket了多个套接字fd后bind同一个端口并listen（甚至addr相同也可以，让多进程监听同一个端口，各个进程中listen和accept的socketFd不一样，有新连接建立时，内核只会唤醒一个进程来accept，并且保证唤醒的均衡性。<br>
  同样地，客户端使用SO_REUSEPORT之后可以bind到同一addr+port进行连接。</p>
<p>总结：</p>
<ol>
<li>这两者特别相似，主要是在时空上有区别</li>
<li>SO_REUSEADDR是针对不同时间的重用，主要作用是避免TIME_WAIT状态，但是无法做到相同端口的同时listen，必须关闭后再重新bind并listen</li>
<li>SO_REUSEPORT主要是针对同一时间的重用，主要作用是使得多个socketFd可以同时绑定到同一个socket并listen或者connect</li>
</ol>
<p>最后必须说的是，我对这个结果存疑，还是必须等有时间后亲手验证。<br>
参考博客：<a href="https://www.cnblogs.com/xybaby/p/7341579.html">SO_REUSEADDR与SO_REUSEPORT平台差异性与测试</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[STL迭代器]]></title>
        <id>https://lixin-scut.github.io//post/stl-die-dai-qi</id>
        <link href="https://lixin-scut.github.io//post/stl-die-dai-qi">
        </link>
        <updated>2020-03-15T09:33:45.000Z</updated>
        <content type="html"><![CDATA[<h3 id="实现">实现</h3>
<ol>
<li>迭代器是一种抽象的设计理念，通过迭代器可以在不了解容器内部原理的情况下遍历容器，除此之外，STL中迭代器一个最重要的作用就是作为容器与STL算法的粘合剂。</li>
<li>迭代器的作用就是提供一个遍历容器内部所有元素的接口，因此迭代器内部必须保存一个与容器相关联的指针，然后重载各种运算操作来遍历，其中最重要的是*运算符与-&gt;运算符，以及++、--等可能需要重载的运算符重载。这和C++中的智能指针很像，智能指针也是将一个指针封装，然后通过引用计数或是其他方法完成自动释放内存的功能。</li>
<li>最常用的迭代器的相应型别有五种：value type、difference type、pointer、reference、iterator catagoly;</li>
</ol>
<p>关于迭代器的戏份类型我在以前的博文中介绍过<a href="https://lixin-scut.github.io/post/c-die-dai-qi-lei-xing/">C++ 迭代器类型</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CountDownLatch]]></title>
        <id>https://lixin-scut.github.io//post/countdownlatch</id>
        <link href="https://lixin-scut.github.io//post/countdownlatch">
        </link>
        <updated>2020-03-15T08:42:30.000Z</updated>
        <content type="html"><![CDATA[<p>这个是在今天做题的时候想起来的，在网络库中也实现了，主要用于线程池的生成</p>
<p>原理<br>
  CountDownLatch,本质上来说,类似于信号量，但是又有所不同，具体可看实现，是一个thread safe的计数器,用于主线程和工作线程的同步.<br>
用法主要有有两种:<br>
  第一种:在初始化时,需要指定主线程需要等待的任务的个数(count),当工作线程完成 Task Callback后对计数器减1，而主线程通过wait()调用阻塞等待技术器减到0为止.<br>
  第二种:初始化计数器值为1,在程序结尾将创建一个线程执行countDown操作并wait()当程序执行到最后会阻塞直到计数器减为0,这可以保证线程池中的线程都start了线程池对象才完成构造,这是一个坑,我在实现ThreadPool的过程中遇到过。</p>
<p>实现<br>
CountDownLatch的底层是mutex和condition<br>
CountDownLatch是一个Thread Safe的Couter,它支持的方法主要是两个countDown()和wait()<br>
countDown就是对counter原子的执行减1操作<br>
wait就使用条件变量等待counter减到0然后notify.</p>
<pre><code>// CountDownLatch.h
// Created by Lixin on 2020.03.07

#pragma once

#include &quot;Condition.h&quot;
#include &quot;MutexLock.h&quot;
#include &quot;noncopyable.h&quot;

// CountDownLatch的主要作用是确保Thread中传进去的func真的启动了以后
// 外层的start才返回
class CountDownLatch : noncopyable 
{
public:
	explicit CountDownLatch(int count);
	void wait();
	void countDown();

private:
	mutable MutexLock mutex_;
	Condition condition_;
	int count_;
};

// CountDownLatch.cc
// Created by Lixin on 2020.03.07

#include &quot;CountDownLatch.h&quot;

CountDownLatch::CountDownLatch(int count)
	: mutex_(), 
	  condition_(mutex_), 
	  count_(count) 
{ }

void CountDownLatch::wait() 
{
	MutexLockGuard lock(mutex_);
	while (count_ &gt; 0) condition_.wait();
}

void CountDownLatch::countDown() 
{
	MutexLockGuard lock(mutex_);
	--count_;
	if (count_ == 0) 
	{
		condition_.notifyAll();
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[多线程 题1114:按序打印]]></title>
        <id>https://lixin-scut.github.io//post/duo-xian-cheng-ti-1114an-xu-da-yin</id>
        <link href="https://lixin-scut.github.io//post/duo-xian-cheng-ti-1114an-xu-da-yin">
        </link>
        <updated>2020-03-15T07:23:21.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>我们提供了一个类：<br>
public class Foo {<br>
  public void one() { print(&quot;one&quot;); }<br>
  public void two() { print(&quot;two&quot;); }<br>
  public void three() { print(&quot;three&quot;); }<br>
}<br>
三个不同的线程将会共用一个 Foo 实例。<br>
线程 A 将会调用 one() 方法<br>
线程 B 将会调用 two() 方法<br>
线程 C 将会调用 three() 方法<br>
请设计修改程序，以确保 two() 方法在 one() 方法之后被执行，three() 方法在 two() 方法之后被执行。<br>
示例 1:<br>
输入: [1,2,3]<br>
输出: &quot;onetwothree&quot;<br>
解释:<br>
有三个线程会被异步启动。<br>
输入 [1,2,3] 表示线程 A 将会调用 one() 方法，线程 B 将会调用 two() 方法，线程 C 将会调用 three() 方法。<br>
正确的输出是 &quot;onetwothree&quot;。<br>
示例 2:<br>
输入: [1,3,2]<br>
输出: &quot;onetwothree&quot;<br>
解释:<br>
输入 [1,3,2] 表示线程 A 将会调用 one() 方法，线程 B 将会调用 three() 方法，线程 C 将会调用 two() 方法。<br>
正确的输出是 &quot;onetwothree&quot;。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/print-in-order<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>  首先读懂题目，线程启动的顺序可能是不一致的，所以我们必须让它们就算在不一致的情况下也能按序输出<br>
这一次我依旧使用了mutex+condtion<br>
然后引发了以下问题：</p>
<ol>
<li>一开始我用的是signal，通知其他线程，我本以为signal会不断通知直至有一个线程运行成功，其实不是的，signal只会通知等待condition中多个线程中的一个，而后面的线程继续保持wait（我在测试过程中一直是唤醒线程3，所以一致超时），必须用broadcast</li>
<li>我在ubuntu下测试的时候发现无法打印，后来发现是主线程的main函数会默认执行exit函数，导致所有程序被退出，此时主线程必须用pthread_exit，避免进入exit</li>
<li>经过以上分析，可以发现其实用两个condition可以更好地避免使用broadcast导致惊群效应，可以直接用signal。</li>
</ol>
<p>最后代码：</p>
<pre><code>class Foo {
public:
    Foo() {
        pthread_mutex_init(&amp;mutex,nullptr);
        pthread_cond_init(&amp;cond,nullptr);
        printOne = true;
        printTwo = false;
        printThree = false;
    }

    void first(function&lt;void()&gt; printFirst) {
        pthread_mutex_lock(&amp;mutex);
        while(!printOne)
        {
            pthread_cond_wait(&amp;cond, &amp;mutex);
        }
        // printFirst() outputs &quot;first&quot;. Do not change or remove this line.
        printFirst();
        printOne = false;
        printTwo = true;
        pthread_cond_broadcast(&amp;cond);
        pthread_mutex_unlock(&amp;mutex);
    }

    void second(function&lt;void()&gt; printSecond) {
        pthread_mutex_lock(&amp;mutex);
        while(!printTwo)
        {
            pthread_cond_wait(&amp;cond, &amp;mutex);
        }
        // printSecond() outputs &quot;second&quot;. Do not change or remove this line.
        printSecond();
        printTwo = false;
        printThree = true;
        pthread_cond_broadcast(&amp;cond);
        pthread_mutex_unlock(&amp;mutex);
    }

    void third(function&lt;void()&gt; printThird) {
        pthread_mutex_lock(&amp;mutex);
        while(!printThree)
        {
            pthread_cond_wait(&amp;cond, &amp;mutex);
        }
        // printThird() outputs &quot;third&quot;. Do not change or remove this line.
        printThird();
        printThree = false;
        printOne = true;
        pthread_cond_broadcast(&amp;cond);
        pthread_mutex_unlock(&amp;mutex);
    }
    
private:
    pthread_mutex_t mutex;
    pthread_cond_t cond;
    bool printOne,printTwo,printThree;
};
</code></pre>
<p>网友题解：<br>
双互斥锁</p>
<blockquote>
<p>由于需要two()在one()之前执行，所以two()必须等待one()执行后的某个条件达成，使用锁来实现同步。</p>
</blockquote>
<pre><code>class Foo {
public:
    mutex smx;
    mutex tmx;
    Foo() {
     smx.lock();
     tmx.lock();
    }

    void first(function&lt;void()&gt; printFirst) {
        // printFirst() outputs &quot;first&quot;. Do not change or remove this line.
        printFirst();
        smx.unlock();
    }

    void second(function&lt;void()&gt; printSecond) {
        lock_guard&lt;mutex&gt; lg(smx);
        // printSecond() outputs &quot;second&quot;. Do not change or remove this line.
        printSecond();
        tmx.unlock();
    }

    void third(function&lt;void()&gt; printThird) {
        lock_guard&lt;mutex&gt; lg(tmx);
        // printThird() outputs &quot;third&quot;. Do not change or remove this line.
        printThird();
    }
};
</code></pre>
<blockquote>
<p>可以这么理解，每个线程相当于一个人，执行代码相当于需要进到房间，执行one()这个人A房间对他不设防，可以直接进去，而执行two()的这个人B需要打开smx这个锁才能进去，而执行three()的这个人C需要打开两把锁才能进入。一开始门上是有两把锁的，所以一开始只有A能进入，出来之后想让B可以进入C不能进去，怎么办呢？可以让A出来之前把smx锁打开，然后B就可以进去了，C不能进去，然后B出来之前把smx和tmx都打开，然后C才能进去。<br>
要注意的是，C尝试获得锁的时候顺序一定要是先获得tmx这个锁再获得smx这个锁，因为smx这个锁同时被B和C需要，否则A在打开了smx锁后立刻被C获得了后，由于没有B给C打开tmx这个锁，C会挂在lock(tmx)上，而后到来的B因为不能获得smx锁，会挂在lock(smx)上，于是就发生了死锁。</p>
</blockquote>
<blockquote>
<p>成员变量<br>
用一个全局变量flag，标示当前是什么状态，状态1只能执行one()，状态2只能执行two()，状态3执行three()，然后到每个函数下改变状态即可。</p>
</blockquote>
<pre><code>class Foo {
public:
    volatile int flag;
    Foo() {
     flag = 1;
    }

    void first(function&lt;void()&gt; printFirst) {
        while (flag != 1);
        // printFirst() outputs &quot;first&quot;. Do not change or remove this line.
        printFirst();
        flag = 2;
    }

    void second(function&lt;void()&gt; printSecond) {
        while (flag != 2);
        // printSecond() outputs &quot;second&quot;. Do not change or remove this line.
        printSecond();
        flag = 3;
    }

    void third(function&lt;void()&gt; printThird) {
        while(flag != 3);
        // printThird() outputs &quot;third&quot;. Do not change or remove this line.
        printThird();
    }
};
</code></pre>
<blockquote>
<p>成员变量-处理非期望输入<br>
由于上面的使用成员变量作为状态标记的方法只适用于输入是[1,2,3]的全排列的情况，一旦输入出现重复数字的情况（如[1,2,1,3]），那么就会死循环。<br>
和使用mutex的方法对比我们可以找出原因，使用mutex时，A出去之后“门”允许A和B都能进入，因为“门”不会因为A进去之后而改变A的访问权限，；而使用状态表示时，A进入之后就不能再进去了，因为状态变成了只能B才能进入，而根据题意显然进入过“门”的“人”可以再次进入。造成如此的原因是!=符号只能确定一个状态，而不能确定一个集合的状态，我们需要记录的状态是此时“哪些人”可以进入“门”而不是此时“哪个人”可以进入“门”。<br>
我们可以使用set&lt; int &gt;记录谁被允许访问，通过在每个函数返回前加入下一个被允许进入的“人”。当然这个题直接用&lt;作为set.count()的简化版本，使用++替代set.add(next_id)。<br>
要注意的是，thrid(...)函数最后是否复原状态（就是set.clear()或flag = 0）决定了在A、B、C每个人都经过一次之后是重新开始按1、2、3的顺序打印还是按线程调度的先后顺序打印。</p>
</blockquote>
<pre><code>class Foo {
public:
    volatile int flag;
    Foo() {
     flag = 1;
    }

    void first(function&lt;void()&gt; printFirst) {
        while (flag &lt; 1);
        // printFirst() outputs &quot;first&quot;. Do not change or remove this line.
        printFirst();
        flag = 2;
    }

    void second(function&lt;void()&gt; printSecond) {
        while (flag &lt; 2);
        // printSecond() outputs &quot;second&quot;. Do not change or remove this line.
        printSecond();
        flag = 3;
    }

    void third(function&lt;void()&gt; printThird) {
        while(flag &lt; 3);
        // printThird() outputs &quot;third&quot;. Do not change or remove this line.
        printThird();
    }
};
</code></pre>
<p>注意这里其实flag必须声明为volatile，否则在其他题目下如果多线程修改flag就会出现问题<br>
注意这里直接while会陷入自旋直到时间片用光再线程调度，比较空耗cpu<br>
但是多线程不一定能提高执行的速度，需要考虑线程的创建消耗，以及同步数据的消耗</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[condition中的signal与broadcast]]></title>
        <id>https://lixin-scut.github.io//post/condition-zhong-de-signal-yu-broadcast-zheng-li-cao-gao</id>
        <link href="https://lixin-scut.github.io//post/condition-zhong-de-signal-yu-broadcast-zheng-li-cao-gao">
        </link>
        <updated>2020-03-15T05:37:37.000Z</updated>
        <content type="html"><![CDATA[<p>问题起源于我今天早上做的线程题：<a href="https://lixin-scut.github.io/post/duo-xian-cheng-ti-1114an-xu-da-yin/">多线程 题1114:按序打印</a></p>
<p>  在线程1执行完成后，我使用了pthread_cond_signal来通知线程2，我本以为signal会不断通知直至有一个线程运行成功，其实不是的，signal只会通知等待condition中多个线程中的一个，而后面的线程继续保持wait（我在测试过程中一直是唤醒线程3，所以一致超时），必须用broadcast</p>
<p>结合以前的博文：<a href="https://lixin-scut.github.io/post/liang-qun-xiao-ying-yu-xu-jia-huan-xing/">惊群效应与虚假唤醒</a><br>
可以得出以下结论</p>
<ol>
<li>pthread_cond_broadcast会通知所有订阅了同一condition并wait的线程，如果他们想要不同的mutex的话就能继续执行，争抢同一mutex则只有一个线程最后能执行下去，间接导致惊群效应</li>
<li>pthread_cond_signal可以说是为了解决这个惊群效应而生，内核会随机选择符合条件的线程，使得最终只有一个线程被唤醒，其他线程就算符合条件也必须保持wait</li>
<li>但是pthread_cond_signal可能会导致虚假唤醒，所以必须使用while来判断条件，而不能是if</li>
</ol>
<p>参考资料：<br>
pthread_cond_broadcast的man page：</p>
<p>条件信号的多次唤醒<br>
  在多处理器上，pthread_cond_signal的实现可能无法避免解除对一个条件变量阻塞的多个线程的阻塞。例如，考虑以下pthread_cond_wait和pthread_cond_signal的部分实现，该实现由两个线程按给定的顺序执行。一个线程正在尝试等待条件变量，另一个线程正在同时执行pthread_cond_signal，而第三线程已经在等待。<br>
  结果一个调用pthread_cond_signal的结果是多个线程可以从其调用pthread_cond_wait或pthread_cond_timedwait返回。这种效应称为虚假唤醒。请注意，这种情况是自我纠正的，因为唤醒的线程数是有限的。例如，在块上方的事件序列之后，下一个调用pthread_cond_wait的线程。<br>
  尽管可以解决此问题，但是对于仅很少发生的边缘条件造成的效率损失是不可接受的，尤其是考虑到无论如何必须检查与条件变量关联的谓词。对于所有更高级别的同步操作，更正此问题将不必要地降低此基本构建块中的并发程度。<br>
  允许虚假唤醒的另一个好处是，应用程序被迫围绕条件等待编写谓词测试循环。这也使应用程序可以在应用程序的某些其他部分中编码的相同条件变量上容忍多余的条件广播或信号。因此，所得的应用程序更加健壮。因此，POSIX.1-2008明确记录了可能会发生虚假唤醒。</p>
]]></content>
    </entry>
</feed>