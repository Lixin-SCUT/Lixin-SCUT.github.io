<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-04-24T09:36:50.752Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>千里之行，始于足下。不积跬步，无以至千里。</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[2.作用域 -Google C++编程规范]]></title>
        <id>https://lixin-scut.github.io//post/2zuo-yong-yu-google-cbian-cheng-gui-fan</id>
        <link href="https://lixin-scut.github.io//post/2zuo-yong-yu-google-cbian-cheng-gui-fan">
        </link>
        <updated>2020-04-24T08:27:03.000Z</updated>
        <content type="html"><![CDATA[<h3 id="命名空间">命名空间</h3>
<ol>
<li>鼓励在 .cc 文件内使用匿名命名空间或 static 声明. 使用具名的命名空间时, 其名称可基于项目名或相对路径.</li>
<li><strong>禁止使用 using 指示（using-directive）。禁止使用内联命名空间（inline namespace）。</strong></li>
</ol>
<p><strong>命名空间定义:</strong><br>
  命名空间将全局作用域细分为独立的, 具名的作用域, 可<strong>有效防止全局作用域的命名冲突.</strong><br>
  举例来说, 两个不同项目的全局作用域都有一个类 Foo, 这样在编译或运行时造成冲突. 如果每个项目将代码置于不同命名空间中, project1::Foo 和 project2::Foo 作为不同符号自然不会冲突.</p>
<p><strong>内联命名空间</strong><br>
内联命名空间会自动把内部的标识符放到外层作用域</p>
<pre><code>namespace X {
inline namespace Y {
void foo();
}  // namespace Y
}  // namespace X
</code></pre>
<p>X::Y::foo() 与 X::foo() 彼此可代替。<strong>内联命名空间主要用来保持跨版本的 ABI 兼容性。</strong><br>
<strong>但是，在头文件中使用匿名空间导致违背 C++ 的唯一定义原则 (One Definition Rule (ODR)).</strong></p>
<p>使用命名空间的守则：</p>
<ul>
<li>遵守 命名空间命名 中的规则。</li>
<li>像之前的几个例子中一样，在命名空间的最后注释出命名空间的名字。</li>
<li>用命名空间把文件包含, gflags 的声明/定义, 以及类的前置声明以外的整个源文件封装起来, 以区别于其它命名空间:</li>
</ul>
<pre><code>// .h 文件
namespace mynamespace {

// 所有声明都置于命名空间中
// 注意不要使用缩进
class MyClass {
    public:
    ...
    void Foo();
};

} // namespace mynamespace
</code></pre>
<pre><code>// .cc 文件
namespace mynamespace {

// 函数定义都置于命名空间中
void MyClass::Foo() {
    ...
}

} // namespace mynamespace
</code></pre>
<p>更复杂的 .cc 文件包含更多, 更复杂的细节, 比如 gflags 或 using 声明。</p>
<pre><code>#include &quot;a.h&quot;

DEFINE_FLAG(bool, someflag, false, &quot;dummy flag&quot;);

namespace a {

...code for a...                // 左对齐

} // namespace a
</code></pre>
<ul>
<li>不要在命名空间 std 内声明任何东西, 包括标准库的类前置声明. 在 std 命名空间声明实体是未定义的行为, 会导致如不可移植. 声明标准库下的实体, 需要包含对应的头文件.</li>
<li><strong>不应该使用 using 指示 引入整个命名空间的标识符号</strong>。</li>
</ul>
<pre><code>// 禁止 —— 污染命名空间
using namespace foo;
</code></pre>
<ul>
<li><strong>不要在头文件中使用 命名空间别名 除非显式标记内部命名空间使用</strong>。因为任何在头文件中引入的命名空间都会成为公开API的一部分。</li>
</ul>
<pre><code>// 在 .cc 中使用别名缩短常用的命名空间
namespace baz = ::foo::bar::baz;
</code></pre>
<pre><code>// 在 .h 中使用别名缩短常用的命名空间
namespace librarian {
namespace impl {  // 仅限内部使用
namespace sidetable = ::pipeline_diagnostics::sidetable;
}  // namespace impl

inline void my_inline_function() {
  // 限制在一个函数中的命名空间别名
  namespace baz = ::foo::bar::baz;
  ...
}
}  // namespace librarian
</code></pre>
<ul>
<li><strong>禁止用内联命名空间</strong></li>
</ul>
<h3 id="匿名命名空间和静态变量">匿名命名空间和静态变量</h3>
<p>  在 .cc 文件中定义一个<strong>不需要被外部引用的变量时</strong>，可以将它们放在<strong>匿名命名空间或声明为 static</strong> 。但是<strong>不要在 .h 文件中这么做</strong>。</p>
<p>定义:</p>
<p>  所有置于匿名命名空间的声明都具有<strong>内部链接性（仅在文件内有效）</strong>，<strong>函数和变量可以经由声明为 static 拥有内部链接性</strong>，这意味着你在这个文件中声明的这些标识符都不能在另一个文件中被访问。即使两个文件声明了完全一样名字的标识符，它们所指向的实体实际上是完全不同的。</p>
<p>结论:</p>
<p>  <strong>推荐、鼓励在 .cc 中对于不需要在其他地方引用的标识符使用内部链接性声明，但是不要在 .h 中使用。</strong></p>
<p>匿名命名空间的声明和具名的格式相同，在最后注释上 namespace :</p>
<pre><code>namespace {
...
}  // namespace
</code></pre>
<h3 id="非成员函数-静态成员函数和全局函数">非成员函数、静态成员函数和全局函数</h3>
<p>  使用<strong>静态成员函数</strong>或<strong>命名空间内的非成员函数</strong>, <strong>尽量不要用裸的全局函数</strong>. 将一系列函数直接置于命名空间中，<strong>不要用类的静态方法模拟出命名空间的效果</strong>，类的静态方法应当和类的实例或静态数据紧密相关.</p>
<p>优点:</p>
<p>  某些情况下, 非成员函数和静态成员函数是非常有用的, <strong>将非成员函数放在命名空间内可避免污染全局作用域</strong>.</p>
<p>缺点:</p>
<p>  <strong>将非成员函数和静态成员函数作为新类的成员或许更有意义</strong>, 当它们<strong>需要访问外部资源或具有重要的依赖关系时</strong>更是如此.</p>
<p>结论:</p>
<p>  有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的. 这样的函数可以被定义成静态成员, 或是非成员函数. 非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内. <strong>相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类, 不如使用命名空间</strong> 。</p>
<p>  <strong>定义在同一编译单元的函数, 被其他编译单元直接调用可能会引入不必要的耦合和链接时依赖; 静态成员函数对此尤其敏感.</strong> 可以考虑提取到新类中, 或者将函数置于独立库的命名空间内.</p>
<p>  <strong>如果你必须定义非成员函数, 又只是在 .cc 文件中使用它, 可使用匿名命名空间 或 static 链接关键字 (如 static int Foo() {...}) 限定其作用域.</strong></p>
<h3 id="局部变量">局部变量</h3>
<p>  <strong>将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化.</strong></p>
<p>  C++ 允许在函数的任何位置声明变量. 我们<strong>提倡在尽可能小的作用域中声明变量, 离第一次使用越近越好</strong>. 这使得代码浏览者更容易定位变量声明的位置, 了解变量的类型和初始值. 特别是，<strong>应使用初始化的方式替代声明再赋值</strong>, 比如:</p>
<p>  <strong>有一个例外, 如果变量是一个对象, 每次进入作用域都要调用其构造函数, 每次退出作用域都要调用其析构函数. 这会导致效率降低.</strong></p>
<pre><code>// 低效的实现
for (int i = 0; i &lt; 1000000; ++i) {
    Foo f;                  // 构造函数和析构函数分别调用 1000000 次!
    f.DoSomething(i);
}
</code></pre>
<p>在循环作用域外面声明这类变量要高效的多:</p>
<pre><code>Foo f;                      // 构造函数和析构函数只调用 1 次
for (int i = 0; i &lt; 1000000; ++i) {
    f.DoSomething(i);
}
</code></pre>
<h3 id="静态和全局变量">静态和全局变量</h3>
<p>  禁止定义静态储存周期<strong>非POD变量</strong>，禁止使用<strong>含有副作用的函数初始化POD全局变量</strong>，因为<strong>多编译单元中的静态变量执行时的构造和析构顺序是未明确的，这将导致代码的不可移植</strong>。</p>
<p>  <strong>禁止使用类的 静态储存周期 变量：由于构造和析构函数调用顺序的不确定性，它们会导致难以发现的 bug</strong> 。不过 constexpr 变量除外，毕竟它们又不涉及动态初始化或析构。</p>
<p><strong>静态生存周期的对象，即包括了全局变量，静态变量，静态类成员变量和函数静态变量，都必须是原生数据类型</strong> (POD : Plain Old Data): 即 int, char 和 float, 以及 POD 类型的指针、数组和结构体。</p>
<p>  <strong>静态变量的构造函数、析构函数和初始化的顺序在 C++ 中是只有部分明确的，甚至随着构建变化而变化，导致难以发现的 bug</strong>. 所以除了禁用类类型的全局变量，我们<strong>也不允许用函数返回值来初始化 POD 变量</strong>，除非该函数（比如 getenv() 或 getpid() ）不涉及任何全局变量。<strong>函数作用域里的静态变量除外，毕竟它的初始化顺序是有明确定义的，而且只会在指令执行到它的声明那里才会发生。</strong></p>
<p>  <strong>同一个编译单元内是明确的</strong>，静态初始化优先于动态初始化，初始化顺序按照声明顺序进行，销毁则逆序。<strong>不同的编译单元之间初始化和销毁顺序属于未明确行为 (unspecified behaviour)</strong>。</p>
<p>  同理，<strong>全局和静态变量在程序中断时会被析构</strong>，无论所谓中断是从 main() 返回还是对 exit() 的调用。析构顺序正好与构造函数调用的顺序相反。但既然<strong>构造顺序未定义，那么析构顺序当然也就不定了。</strong> 比如，在程序结束时某静态变量已经被析构了，但代码还在跑——比如其它线程——并试图访问它且失败；再比如，一个静态 string 变量也许会在一个引用了前者的其它变量析构之前被析构掉。</p>
<p>  改善以上析构问题的办法之一是<strong>用 quick_exit() 来代替 exit() 并中断程序</strong>。它们的不同之处是<strong>前者不会执行任何析构，也不会执行 atexit() 所绑定的任何 handlers</strong>. 如果您想在执行 quick_exit() 来中断时执行某 handler（比如刷新 log），您可以把它绑定到 _at_quick_exit(). 如果您想在 exit() 和 quick_exit() 都用上该 handler, 都绑定上去。</p>
<p>  综上所述，<strong>我们只允许 POD 类型的静态变量，即完全禁用 vector (使用 C 数组替代) 和 string (使用 const char [])</strong>。</p>
<p>  如果<strong>您确实需要一个 class 类型的静态或全局变量</strong>，可以考虑在 main() 函数或 pthread_once() 内<strong>初始化一个指针且永不回收</strong>。注意<strong>只能用 raw 指针，别用智能指针，毕竟后者的析构函数涉及到上文指出的不定顺序问题</strong>。<br>
（疑惑： 这个解决方法的目的是？）</p>
<p>  上文提及的静态变量泛指静态生存周期的对象, 包括: <strong>全局变量, 静态变量, 静态类成员变量, 以及函数静态变量.</strong></p>
<p>注意事项：</p>
<ol>
<li><strong>cc 中的匿名命名空间可避免命名冲突, 限定作用域</strong>, 避免直接使用 using 关键字污染命名空间;</li>
<li>嵌套类符合局部使用原则, 只是不能在其他头文件中前置声明, 尽量不要 public;</li>
<li><strong>尽量不用全局函数和全局变量, 考虑作用域和命名空间限制, 尽量单独形成编译单元;</strong></li>
<li><strong>多线程中的全局变量 (含静态成员变量) 不要使用 class 类型 (含 STL 容器), 避免不明确行为导致的 bug.</strong></li>
<li>作用域的使用, 除了考虑名称污染, 可读性之外, 主要是为<strong>降低耦合, 提高编译/执行效率.</strong></li>
<li>注意「using 指示（using-directive）」和「using 声明（using-declaration）」的区别。</li>
<li>匿名命名空间说白了就是文件作用域，就像<strong>C static 声明的作用域一样，后者已经被 C++ 标准提倡弃用。</strong></li>
<li>局部变量在声明的同时进行显式值初始化，比起隐式初始化再赋值的两步过程要高效，同时也贯彻了计算机体系结构重要的概念「局部性（locality）」。</li>
<li>注意<strong>别在循环犯大量构造和析构的低级错误。</strong></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 79. 单词搜索[中等][回溯]]]></title>
        <id>https://lixin-scut.github.io//post/zi-fu-chuan-79-dan-ci-sou-suo-zhong-deng-hui-su</id>
        <link href="https://lixin-scut.github.io//post/zi-fu-chuan-79-dan-ci-sou-suo-zhong-deng-hui-su">
        </link>
        <updated>2020-04-24T08:03:39.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。<br>
单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。<br>
示例:<br>
board =<br>
[<br>
['A','B','C','E'],<br>
['S','F','C','S'],<br>
['A','D','E','E']<br>
]<br>
给定 word = &quot;ABCCED&quot;, 返回 true<br>
给定 word = &quot;SEE&quot;, 返回 true<br>
给定 word = &quot;ABCB&quot;, 返回 false<br>
提示：<br>
board 和 word 中只包含大写和小写英文字母。<br>
1 &lt;= board.length &lt;= 200<br>
1 &lt;= board[i].length &lt;= 200<br>
1 &lt;= word.length &lt;= 10^3<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/word-search<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>我似乎使用的比较暴力的方法，就是直接每个格子作为起点惊醒深度遍历+回溯来完成<br>
主要是通过传引用来达成节省空间的。</p>
<pre><code>class Solution {
public:
    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) {
        if(board.empty() &amp;&amp; word.empty())
        {   return true; }
        if(word.empty())
        {   return true; }
        
        int row = board.size();
        int col = board[0].size();
        
        vector&lt;vector&lt;bool&gt;&gt; visited(row, vector&lt;bool&gt;(col, false));
        
        for(int i = 0; i &lt; row; ++i)
        {
            for(int j = 0; j &lt; col; ++j)
            {
                if(exist(board, word, i, j, 0, visited))
                {   return true; }
            }
        }
        return false;
    }
    
    bool exist(const vector&lt;vector&lt;char&gt;&gt;&amp; board, const string&amp; word, int i, int j, int index, vector&lt;vector&lt;bool&gt;&gt;&amp; visited)
    {
        if(index == word.size())
        {   return true; }
        if(i &lt; 0 || i &gt;= board.size() || j &lt; 0 || j &gt;= board[0].size() || visited[i][j])
        {   return false; }
        if(word[index] != board[i][j])
        {   return false; }
        
        visited[i][j] = true;
        return visited[i][j] = (exist(board, word, i, j+1, index+1, visited)
               || exist(board, word, i, j-1, index+1, visited)
               || exist(board, word, i+1, j, index+1, visited)
               || exist(board, word, i-1, j, index+1, visited));
    }
};
</code></pre>
<p>网友题解：</p>
<pre><code>public class Solution {

    private boolean[][] marked;

    //        x-1,y
    // x,y-1  x,y    x,y+1
    //        x+1,y
    private int[][] direction = {{-1, 0}, {0, -1}, {0, 1}, {1, 0}};
    // 盘面上有多少行
    private int m;
    // 盘面上有多少列
    private int n;
    private String word;
    private char[][] board;

    public boolean exist(char[][] board, String word) {
        m = board.length;
        if (m == 0) {
            return false;
        }
        n = board[0].length;
        marked = new boolean[m][n];
        this.word = word;
        this.board = board;

        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt; n; j++) {
                if (dfs(i, j, 0)) {
                    return true;
                }
            }
        }
        return false;
    }

    private boolean dfs(int i, int j, int start) {
        if (start == word.length() - 1) {
            return board[i][j] == word.charAt(start);
        }
        if (board[i][j] == word.charAt(start)) {
            marked[i][j] = true;
            for (int k = 0; k &lt; 4; k++) {
                int newX = i + direction[k][0];
                int newY = j + direction[k][1];
                if (inArea(newX, newY) &amp;&amp; !marked[newX][newY]) {
                    if (dfs(newX, newY, start + 1)) {
                        return true;
                    }
                }
            }
            marked[i][j] = false;
        }
        return false;
    }

    private boolean inArea(int x, int y) {
        return x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n;
    }

    public static void main(String[] args) {

//        char[][] board =
//                {
//                        {'A', 'B', 'C', 'E'},
//                        {'S', 'F', 'C', 'S'},
//                        {'A', 'D', 'E', 'E'}
//                };
//
//        String word = &quot;ABCCED&quot;;


        char[][] board = {{'a', 'b'}};
        String word = &quot;ba&quot;;
        Solution solution = new Solution();
        boolean exist = solution.exist(board, word);
        System.out.println(exist);
    }
}
</code></pre>
<p>说明：<br>
偏移量数组在二维平面内是经常使用的，可以把它的设置当做一个技巧，并且在这个问题中，偏移量数组内的 4 个偏移的顺序无关紧要；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1.头文件 -Google C++编程规范]]></title>
        <id>https://lixin-scut.github.io//post/1tou-wen-jian-google-cbian-cheng-gui-fan</id>
        <link href="https://lixin-scut.github.io//post/1tou-wen-jian-google-cbian-cheng-gui-fan">
        </link>
        <updated>2020-04-23T09:21:18.000Z</updated>
        <content type="html"><![CDATA[<h3 id="define-保护">#define 保护</h3>
<p>所有头文件都应该使用 #define 来防止头文件被多重包含, 命名格式当是: <code>&lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H_ .</code></p>
<p>  为保证唯一性, 头文件的命名应该基于所在项目源代码树的全路径. 例如, 项目 foo 中的头文件 foo/src/bar/baz.h 可按如下方式保护:</p>
<pre><code>#ifndef FOO_BAR_BAZ_H_
#define FOO_BAR_BAZ_H_
...
#endif // FOO_BAR_BAZ_H_
</code></pre>
<p>  <strong>注意： 命名并非必须是路径+文件名，完全可以用其他格式甚至其他意义的名字，只要不冲突就好</strong></p>
<h3 id="前置声明">前置声明</h3>
<p>尽可能地<strong>避免使用前置声明</strong>。使用 #include 包含需要的头文件即可。</p>
<p>  前置声明的类是不完全类型（incomplete type），我们只能定义指向该类型的指针或引用，或者声明（但不能定义）以不完全类型作为参数或者返回类型的函数。毕竟编译器不知道不完全类型的定义，我们不能创建其类的任何对象，也不能声明成类内部的数据成员。</p>
<p>优点：</p>
<ol>
<li>前置声明能够<strong>节省编译时间</strong>，多余的 #include 会迫使编译器展开更多的文件，处理更多的输入。</li>
<li>前置声明能够<strong>节省不必要的重新编译的时间</strong>。 #include 使代码因为头文件中无关的改动而被重新编译多次。</li>
</ol>
<p>缺点：</p>
<ol>
<li>前置声明<strong>隐藏了依赖关系</strong>，头文件改动时，用户的代码会跳过必要的重新编译过程。</li>
<li>前置声明<strong>可能会被库的后续更改所破坏</strong>。前置声明函数或模板有时会妨碍头文件开发者变动其 API. 例如扩大形参类型，加个自带默认参数的模板形参等等。</li>
<li>前置声明来自命名空间 std:: 的 symbol 时，其行为未定义。</li>
<li>很难判断什么时候该用前置声明，什么时候该用 #include 。极端情况下，用前置声明代替 includes 甚至都会<strong>暗暗地改变代码的含义：</strong></li>
</ol>
<pre><code>// b.h:
struct B {};
struct D : B {};

// good_user.cc:
#include &quot;b.h&quot;
void f(B*);
void f(void*);
void test(D* x) { f(x); }  // calls f(B*)
</code></pre>
<p><em><em>如果 #include 被 B 和 D 的前置声明替代， test() 就会调用 f(void</em>) .</em>*<br>
5. 前置声明了不少来自头文件的 symbol 时，就会比单单一行的 include 冗长。<br>
6. <strong>仅仅为了能前置声明而重构代码（比如用指针成员代替对象成员）</strong> 会使代码变得更慢更复杂.</p>
<h3 id="内联函数">内联函数</h3>
<p>只有当函数只有 10 行甚至更少时才将其定义为内联函数.</p>
<p>  有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要; 比如虚函数和递归函数就不会被正常内联.</p>
<ol>
<li>通常, 递归函数不应该声明成内联函数.（YuleFox 注: 递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的, 大多数编译器都不支持内联递归函数).</li>
<li>虚函数内联的主要原因则是想把它的函数体放在类定义内, 为了图个方便, 抑或是当作文档描述其行为, 比如精短的存取函数.</li>
</ol>
<h3 id="include-的路径及顺序">#include 的路径及顺序</h3>
<p>  使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖: 相关头文件, C 库, C++ 库, 其他库的 .h, 本项目内的 .h.<br>
  项目内头文件应按照项目源代码目录树结构排列, 避免使用 UNIX 特殊的快捷目录 . (当前目录) 或 .. (上级目录).</p>
<p>  如, dir/foo.cc 或 dir/foo_test.cc 的主要作用是实现或测试 dir2/foo2.h 的功能, foo.cc 中包含头文件的次序如下:</p>
<ol>
<li>dir2/foo2.h (优先位置, 详情如下)</li>
<li>C 系统文件</li>
<li>C++ 系统文件</li>
<li>其他库的 .h 文件</li>
<li>本项目内 .h 文件</li>
</ol>
<p>  这种优先的顺序排序保证当 dir2/foo2.h 遗漏某些必要的库时， dir/foo.cc 或 dir/foo_test.cc 的构建会立刻中止。<br>
  <strong>因此这一条规则保证维护这些文件的人们首先看到构建中止的消息而不是维护其他包的人们。</strong></p>
<p>  您所依赖的符号 (symbols) 被哪些头文件所定义，您就应该包含（include）哪些头文件，前置声明 (forward declarations) 情况除外。<br>
  比如您要用到 bar.h 中的某个符号, <strong>哪怕您所包含的 foo.h 已经包含了 bar.h, 也照样得包含 bar.h</strong>, 除非 foo.h 有明确说明它会自动向您提供 bar.h 中的 symbol. 不过，<strong>凡是 cc 文件所对应的「相关头文件」已经包含的，就不用再重复包含进其 cc 文件里面了</strong>，就像 foo.cc 只包含 foo.h 就够了，不用再管后者所包含的其它内容。</p>
<p>例外：<br>
  有时，平台特定（system-specific）代码需要<strong>条件编译（conditional includes），这些代码可以放到其它 includes 之后</strong>。当然，您的平台特定代码也要够简练且独立，比如：</p>
<pre><code>#include &quot;foo/public/fooserver.h&quot;

#include &quot;base/port.h&quot;  // For LANG_CXX11.

#ifdef LANG_CXX11
#include &lt;initializer_list&gt;
#endif  // LANG_CXX11
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库：锁]]></title>
        <id>https://lixin-scut.github.io//post/shu-ju-ku-suo</id>
        <link href="https://lixin-scut.github.io//post/shu-ju-ku-suo">
        </link>
        <updated>2020-04-23T08:19:42.000Z</updated>
        <content type="html"><![CDATA[<h3 id="mysql都有什么锁死锁判定原理和具体场景死锁怎么解决">mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决?</h3>
<p>MySQL有三种锁的级别：页级、表级、行级。</p>
<ol>
<li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</li>
<li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</li>
<li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</li>
</ol>
<p><strong>死锁</strong><br>
  死锁: 是指两个或两个以上的进程在执行过程中。因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等竺的进程称为死锁进程。</p>
<p>  表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB。<br>
  死锁的关键在于：两个(或以上)的Session加锁的顺序不一致。<br>
  那么对应的解决死锁问题的关键就是：让不同的session加锁有次序。</p>
<p><strong>死锁的解决办法</strong></p>
<ol>
<li>查出的线程杀死 kill<br>
SELECT trx_MySQL_thread_id FROM information_schema.INNODB_TRX;</li>
<li>设置锁的超时时间<br>
  Innodb 行锁的等待时间，单位秒。可在会话级别设置，RDS 实例该参数的默认值为 50（秒）。<br>
  生产环境不推荐使用过大的 innodb_lock_wait_timeout参数值<br>
  该参数支持在会话级别修改，方便应用在会话级别单独设置某些特殊操作的行锁等待超时时间，如下：<br>
  set innodb_lock_wait_timeout=1000; —设置当前会话 Innodb 行锁等待超时时间，单位秒。</li>
<li>指定获取锁的顺序</li>
</ol>
<p><strong>锁的种类</strong></p>
<ul>
<li>悲观锁（Pessimistic Lock）<br>
  悲观锁特点:先获取锁，再进行业务操作。<br>
  即“悲观”的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作。通常所说的“一锁二查三更新”即指的是使用悲观锁。通常来讲在数据库上的悲观锁需要数据库本身提供支持，即通过常用的select … for update操作来实现悲观锁。当数据库执行select for update时会获取被select中的数据行的行锁，因此其他并发执行的select for update如果试图选中同一行则会发生排斥（需要等待行锁被释放），因此达到锁的效果。select for update获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。</li>
</ul>
<p>补充：<br>
不同的数据库对select for update的实现和支持都是有所区别的，</p>
<ol>
<li>oracle支持select for update no wait，表示如果拿不到锁立刻报错，而不是等待，MySQL就没有no wait这个选项。</li>
<li>MySQL还有个问题是select for update语句执行中所有扫描过的行都会被锁上，这一点很容易造成问题。因此如果在MySQL中用悲观锁务必要确定走了索引，而不是全表扫描。</li>
</ol>
<ul>
<li>乐观锁（Optimistic Lock）:<br>
  乐观锁，也叫乐观并发控制，它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，那么当前正在提交的事务会进行回滚。<br>
  乐观锁的特点先进行业务操作，不到万不得已不去拿锁。即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好。<br>
  乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。<br>
  一般的做法是在需要锁的数据上增加一个版本号，或者时间戳，</li>
</ul>
<p>实现方式举例如下：<br>
  乐观锁（给表加一个版本号字段） 这个并不是乐观锁的定义，给表加版本号，是数据库实现乐观锁的一种方式。</p>
<ol>
<li>SELECT data AS old_data, version AS old_version FROM …;</li>
<li>根据获取的数据进行业务操作，得到new_data和new_version</li>
<li>UPDATE SET data = new_data, version = new_version WHERE version = old_version<br>
if (updated row &gt; 0) {<br>
// 乐观锁获取成功，操作完成<br>
} else {<br>
// 乐观锁获取失败，回滚并重试<br>
}</li>
</ol>
<p>注意：</p>
<ol>
<li>乐观锁在不发生取锁失败的情况下开销比悲观锁小，但是一旦发生失败回滚开销则比较大，因此适合用在取锁失败概率比较小的场景，可以提升系统并发性能</li>
<li>乐观锁还适用于一些比较特殊的场景，例如在业务操作过程中无法和数据库保持连接等悲观锁无法适用的地方。</li>
</ol>
<h3 id="总结">总结</h3>
<p>  悲观锁和乐观锁是数据库用来保证数据并发安全防止更新丢失的两种方法，例子在select ... for update前加个事务就可以防止更新丢失。悲观锁和乐观锁大部分场景下差异不大，一些独特场景下有一些差别，一般我们可以从如下几个方面来判断。</p>
<ol>
<li>
<p>响应速度： 如果需要非常高的响应速度，建议采用乐观锁方案，成功就执行，不成功就失败，不需要等待其他并发去释放锁。'</p>
</li>
<li>
<p>冲突频率： 如果冲突频率非常高，建议采用悲观锁，保证成功率，如果冲突频率大，乐观锁会需要多次重试才能成功，代价比较大。</p>
</li>
<li>
<p>重试代价： 如果重试代价大，建议采用悲观锁。</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库：事务]]></title>
        <id>https://lixin-scut.github.io//post/shu-ju-ku-shi-wu</id>
        <link href="https://lixin-scut.github.io//post/shu-ju-ku-shi-wu">
        </link>
        <updated>2020-04-23T07:29:04.000Z</updated>
        <content type="html"><![CDATA[<h3 id="事务">事务</h3>
<p>  事务是对数据库中一系列操作进行统一的回滚或者提交的操作，主要用来保证数据的完整性和一致性。</p>
<h3 id="事务四大特性acid">事务四大特性（ACID）</h3>
<p>原子性、一致性、隔离性、持久性</p>
<p><strong>原子性（Atomicity）:</strong><br>
  原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p>
<p><strong>一致性（Consistency）:</strong><br>
  事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没收到。</p>
<p><strong>隔离性（Isolation）:</strong><br>
  隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</p>
<p><strong>持久性（Durability）:</strong><br>
  持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>
<h2 id="事务的并发与事务隔离级别">事务的并发与事务隔离级别</h2>
<p>每个级别会引发什么问题，MySQL默认是哪个级别?</p>
<p><img src="https://lixin-scut.github.io//post-images/1587627485392.png" alt=""><br>
  从理论上来说, 事务应该彼此完全隔离, 以避免并发事务所导致的问题，然而, 那样会对性能产生极大的影响, 因为事务必须按顺序运行， 在实际开发中, 为了提升性能, 事务会以较低的隔离级别运行， 事务的隔离级别可以通过隔离事务属性指定。</p>
<p><strong>事务的并发问题</strong></p>
<ol>
<li>脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</li>
<li>不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。</li>
<li>幻读：幻读解决了不可重复读，保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）。<br>
<img src="https://lixin-scut.github.io//post-images/1587627503240.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1587627525081.png" alt=""></li>
</ol>
<p>  例如：事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作 这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。 而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有跟没有修改一样，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。<br>
  小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。</p>
<p><strong>事务的隔离级别</strong><br>
<img src="https://lixin-scut.github.io//post-images/1587627552072.png" alt=""></p>
<ol>
<li>读未提交：另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据脏读</li>
<li>不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。</li>
<li>可重复读：在同一个事务里，SELECT的结果是事务开始时时间点的状态，因此，同样的SELECT操作读到的结果会是一致的。但是，会有幻读现象</li>
<li>串行化：最高的隔离级别，在这个隔离级别下，不会产生任何异常。并发的事务，就像事务是在一个个按照顺序执行一样</li>
</ol>
<p>特别注意：</p>
<ol>
<li>MySQL默认的事务隔离级别为repeatable-read</li>
<li>MySQL 支持 四种事务隔离级别.</li>
<li>事务的隔离级别要得到底层数据库引擎的支持, 而不是应用程序或者框架的支持.</li>
<li>Oracle 支持的 2 种事务隔离级别：READ_COMMITED , SERIALIZABLE</li>
<li>SQL规范所规定的标准，不同的数据库具体的实现可能会有些差异</li>
<li>MySQL中默认事务隔离级别是“可重复读”时并不会锁住读取到的行<br>
  事务隔离级别：未提交读时，写数据只会锁住相应的行。<br>
  事务隔离级别为：可重复读时，写数据会锁住整张表。<br>
  事务隔离级别为：串行化时，读写数据都会锁住整张表。</li>
<li>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大，鱼和熊掌不可兼得啊。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed，它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。<br>
<img src="https://lixin-scut.github.io//post-images/1587627572153.png" alt=""></li>
</ol>
<p><strong>事务传播行为</strong></p>
<ol>
<li>PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</li>
<li>PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</li>
<li>PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</li>
<li>PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。</li>
<li>PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li>
<li>PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。</li>
<li>PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</li>
</ol>
<p><strong>嵌套事务</strong></p>
<p>  嵌套是子事务套在父事务中执行，子事务是父事务的一部分，在进入子事务之前，父事务建立一个回滚点，叫save point，然后执行子事务，这个子事务的执行也算是父事务的一部分，然后子事务执行结束，父事务继续执行。重点就在于那个save point。<br>
  如果子事务回滚，会发生什么？<br>
  父事务会回滚到进入子事务前建立的save point，然后尝试其他的事务或者其他的业务逻辑，父事务之前的操作不会受到影响，更不会自动回滚。<br>
  如果父事务回滚，会发生什么？<br>
  父事务回滚，子事务也会跟着回滚！为什么呢，因为父事务结束之前，子事务是不会提交的，我们说子事务是父事务的一部分，正是这个道理。那么：<br>
  事务的提交，是什么情况？<br>
  是父事务先提交，然后子事务提交，还是子事务先提交，父事务再提交？答案是第二种情况，还是那句话，子事务是父事务的一部分，由父事务统一提交。<br>
参考文章：<a href="https://blog.csdn.net/liangxw1/article/details/51197560">关于Spring事务的面试题</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 76. 最小覆盖子串[困难][未做出]]]></title>
        <id>https://lixin-scut.github.io//post/zi-fu-chuan-76-zui-xiao-fu-gai-zi-chuan-kun-nan-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/zi-fu-chuan-76-zui-xiao-fu-gai-zi-chuan-kun-nan-wei-zuo-chu">
        </link>
        <updated>2020-04-23T07:07:05.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。<br>
示例：<br>
输入: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot;<br>
输出: &quot;BANC&quot;<br>
说明：<br>
如果 S 中不存这样的子串，则返回空字符串 &quot;&quot;。<br>
如果 S 中存在这样的子串，我们保证它是唯一的答案。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/minimum-window-substring<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>第一想法是维持一个队列，不断地把所需的字母+其所处的位置 放入队列 ，然后每当遇到和队列头相同的元素的时候就出队列<br>
但是同时也需要更新队内的元素的下标，</p>
<p>然后第二想法就是记录更新每个所需字母的位置，然后用最大值减去最小值，但是同时需要检查是否已经满足条件 重复字符很麻烦。</p>
<p>最后第三个想法就是记录所有所需字母的下标，然后再按需计算（递归回溯等）</p>
<p>最后看了题解发现是hashmap + 双指针，确实把我的方法中的可行的部分提取出来+不可行的地方去除了。</p>
<pre><code>class Solution {
public:
    string minWindow(string s, string t) {
        
        unordered_map&lt;char, int&gt; letter_need;
        unordered_map&lt;char, int&gt; letter_get;
        for(auto c : t)
        {            
            ++letter_need[c];
        }
        
        int match = 0;
        int left = 0;
        int right = 0;
        char c = '\0';
        string ans = &quot;&quot;;
        while(right &lt; s.size())
        {     
            c = s[right];
            if(letter_need.count(c) == 1)
            {
                ++letter_get[c];
                if(letter_need[c] == letter_get[c])
                {
                    ++match;
                }
            }
            
            
            while(match == letter_need.size())
            {
                c = s[left];
                if(letter_need.count(c) == 1)
                {
                    --letter_get[c];
                    if(letter_get[c] &lt; letter_need[c])
                    {
                        --match;
                        string temp = s.substr(left, right - left + 1);
                        ans = (ans != &quot;&quot; &amp;&amp; ans.size() &lt; temp.size()) ? ans : temp;
                    }
                }
                ++left;
            }
            ++right;
        }
        
        return ans;
    }
};
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>题目不难理解，就是说要在 S(source) 中找到包含 T(target) 中全部字母的一个子串，顺序无所谓，但这个子串一定是所有可能子串中最短的。<br>
如果我们使用暴力解法，代码大概是这样的：</p>
</blockquote>
<pre><code>for (int i = 0; i &lt; s.size(); i++)
    for (int j = i + 1; j &lt; s.size(); j++)
        if s[i:j] 包含 t 的所有字母:
            更新答案
</code></pre>
<blockquote>
<p>思路很直接吧，但是显然，这个算法的复杂度肯定大于 O(N^2)了，不好。<br>
滑动窗口算法的思路是这样：<br>
1、我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引闭区间 [left, right] 称为一个「窗口」。<br>
2、我们先不断地增加 right 指针扩大窗口 [left, right]，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。<br>
3、此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。<br>
4、重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。<br>
这个思路其实也不难，第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。<br>
上述过程可以简单地写出如下伪码框架：</p>
</blockquote>
<pre><code>string s, t;
// 在 s 中寻找 t 的「最小覆盖子串」
int left = 0, right = 0;
string res = s;

while(right &lt; s.size()) {
    window.add(s[right]);
    right++;
    // 如果符合要求，移动 left 缩小窗口
    while (window 符合要求) {
        // 如果这个窗口的子串更短，则更新 res
        res = minLen(res, window);
        window.remove(s[left]);
        left++;
    }
}
return res;
</code></pre>
<blockquote>
<p>如果上述代码你也能够理解，那么你离解题更近了一步。现在就剩下一个比较棘手的问题：如何判断 window 即子串 s[left...right] 是否符合要求，是否包含 t 的所有字符呢？<br>
可以用两个哈希表当作计数器解决。用一个哈希表 needs 记录字符串 t 中包含的字符及出现次数，用另一个哈希表 window 记录当前「窗口」中包含的字符及出现的次数，如果 window 包含所有 needs 中的键，且这些键对应的值都大于等于 needs 中的值，那么就可以知道当前「窗口」符合要求了，可以开始移动 left 指针了。</p>
</blockquote>
<pre><code>string minWindow(string s, string t) {
    // 记录最短子串的开始位置和长度
    int start = 0, minLen = INT_MAX;
    int left = 0, right = 0;
    
    unordered_map&lt;char, int&gt; window;
    unordered_map&lt;char, int&gt; needs;
    for (char c : t) needs[c]++;
    
    int match = 0;
    
    while (right &lt; s.size()) {
        char c1 = s[right];
        if (needs.count(c1)) {
            window[c1]++;
            if (window[c1] == needs[c1]) 
                match++;
        }
        right++;
        
        while (match == needs.size()) {
            if (right - left &lt; minLen) {
                // 更新最小子串的位置和长度
                start = left;
                minLen = right - left;
            }
            char c2 = s[left];
            if (needs.count(c2)) {
                window[c2]--;
                if (window[c2] &lt; needs[c2])
                    match--;
            }
            left++;
        }
    }
    return minLen == INT_MAX ?
                &quot;&quot; : s.substr(start, minLen);
}

作者：labuladong
链接：https://leetcode-cn.com/problems/minimum-window-substring/solution/hua-dong-chuang-kou-suan-fa-tong-yong-si-xiang-by-/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<blockquote>
<p>这个算法的时间复杂度是 O(M+N)，M 和 N 分别是字符串 S 和 T 的长度。因为我们先用 for 循环遍历了字符串 T 来初始化 needs，时间 O(N)，之后的两个 while 循环最多执行2M 次，时间O(M)。<br>
读者也许认为嵌套的 while 循环复杂度应该是平方级，但是你这样想，while 执行的次数就是双指针 left 和 right 走的总路程，最多是 2M 嘛。</p>
</blockquote>
<blockquote>
<p>最后总结<br>
通过上面三道题，我们可以总结出滑动窗口算法的抽象思想：</p>
</blockquote>
<pre><code>int left = 0, right = 0;

while (right &lt; s.size()) {
    window.add(s[right]);
    right++;
    
    while (valid) {
        window.remove(s[left]);
        left++;
    }
}
</code></pre>
<blockquote>
<p>其中 window 的数据类型可以视具体情况而定，比如上述题目都使用哈希表充当计数器，当然你也可以用一个数组实现同样效果，因为我们只处理英文字母。<br>
稍微麻烦的地方就是这个 valid 条件，为了实现这个条件的实时更新，我们可能会写很多代码。比如前两道题，看起来解法篇幅那么长，实际上思想还是很简单，只是大多数代码都在处理这个问题而已。</p>
</blockquote>
<p>官方题解：</p>
<blockquote>
<p>方法一：滑动窗口<br>
思路<br>
本问题要求我们返回字符串 S 中包含字符串 T 的全部字符的最小窗口。我们称包含 T 的全部字母的窗口为 可行 窗口。<br>
可以用简单的滑动窗口法来解决本问题。<br>
在滑动窗口类型的问题中都会有两个指针。一个用于延伸现有窗口的 right 指针，和一个用于收缩窗口的 left 指针。在任意时刻，只有一个指针运动，而另一个保持静止。<br>
本题的解法很符合直觉。我们通过移动 right 指针不断扩张窗口。当窗口包含全部所需的字符后，如果能收缩，我们就收缩窗口直到得到最小窗口。<br>
答案就是最小的可行窗口。<br>
算法<br>
初始，left 指针和 right 指针都指向 S 的第一个元素.<br>
将 right 指针右移，扩张窗口，直到得到一个可行窗口，亦即包含 T 的全部字母的窗口。<br>
得到可行的窗口后，将 left 指针逐个右移，若得到的窗口依然可行，则更新最小窗口大小。<br>
若窗口不再可行，则跳转至 2 。</p>
</blockquote>
<pre><code>class Solution {
  public String minWindow(String s, String t) {

      if (s.length() == 0 || t.length() == 0) {
          return &quot;&quot;;
      }

      // Dictionary which keeps a count of all the unique characters in t.
      Map&lt;Character, Integer&gt; dictT = new HashMap&lt;Character, Integer&gt;();
      for (int i = 0; i &lt; t.length(); i++) {
          int count = dictT.getOrDefault(t.charAt(i), 0);
          dictT.put(t.charAt(i), count + 1);
      }

      // Number of unique characters in t, which need to be present in the desired window.
      int required = dictT.size();

      // Left and Right pointer
      int l = 0, r = 0;

      // formed is used to keep track of how many unique characters in t
      // are present in the current window in its desired frequency.
      // e.g. if t is &quot;AABC&quot; then the window must have two A's, one B and one C.
      // Thus formed would be = 3 when all these conditions are met.
      int formed = 0;

      // Dictionary which keeps a count of all the unique characters in the current window.
      Map&lt;Character, Integer&gt; windowCounts = new HashMap&lt;Character, Integer&gt;();

      // ans list of the form (window length, left, right)
      int[] ans = {-1, 0, 0};

      while (r &lt; s.length()) {
          // Add one character from the right to the window
          char c = s.charAt(r);
          int count = windowCounts.getOrDefault(c, 0);
          windowCounts.put(c, count + 1);

          // If the frequency of the current character added equals to the
          // desired count in t then increment the formed count by 1.
          if (dictT.containsKey(c) &amp;&amp; windowCounts.get(c).intValue() == dictT.get(c).intValue()) {
              formed++;
          }

          // Try and contract the window till the point where it ceases to be 'desirable'.
          while (l &lt;= r &amp;&amp; formed == required) {
              c = s.charAt(l);
              // Save the smallest window until now.
              if (ans[0] == -1 || r - l + 1 &lt; ans[0]) {
                  ans[0] = r - l + 1;
                  ans[1] = l;
                  ans[2] = r;
              }

              // The character at the position pointed by the
              // `Left` pointer is no longer a part of the window.
              windowCounts.put(c, windowCounts.get(c) - 1);
              if (dictT.containsKey(c) &amp;&amp; windowCounts.get(c).intValue() &lt; dictT.get(c).intValue()) {
                  formed--;
              }

              // Move the left pointer ahead, this would help to look for a new window.
              l++;
          }

          // Keep expanding the window once we are done contracting.
          r++;   
      }

      return ans[0] == -1 ? &quot;&quot; : s.substring(ans[1], ans[2] + 1);
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度: O(∣S∣+∣T∣)，其中 ∣S∣ 和 ∣T∣ 代表字符串 S 和 T 的长度。在最坏的情况下，可能会对 S 中的每个元素遍历两遍，左指针和右指针各一遍。<br>
空间复杂度: O(∣S∣+∣T∣)。当窗口大小等于 ∣S∣ 时为S 。当 ∣T∣ 包括全部唯一字符时为 T 。</p>
</blockquote>
<blockquote>
<p>方法二：优化滑动窗口<br>
思路<br>
对上一方法进行改进，可以将时间复杂度下降到 O(2∗∣filtered_S∣+∣S∣+∣T∣) ，其中 filtered_S 是从 S 中去除所有在 T 中不存在的元素后，得到的字符串。<br>
当 ∣filtered_S∣&lt;&lt;&lt;∣S∣ 时，优化效果显著。这种情况可能是由于 T 的长度远远小于 S ，因此 S 中包括大量 T 中不存在的字符。<br>
算法<br>
我们建立一个 filtered_S 列表，其中包括 S 中的全部字符以及它们在 S 的下标，但这些字符必须在 T 中出现。<br>
S = &quot;ABCDDDDDDEEAFFBC&quot; T = &quot;ABC&quot;<br>
filtered_S = [(0, 'A'), (1, 'B'), (2, 'C'), (11, 'A'), (14, 'B'), (15, 'C')]<br>
此处的 (0, 'A') 表示字符 'A' 在字符串 S 中的下标为 0 。<br>
现在我们可以在更短的字符串filtered_S 中使用滑动窗口法。</p>
</blockquote>
<pre><code>class Solution {
    public String minWindow(String s, String t) {

        if (s.length() == 0 || t.length() == 0) {
            return &quot;&quot;;
        }

        Map&lt;Character, Integer&gt; dictT = new HashMap&lt;Character, Integer&gt;();

        for (int i = 0; i &lt; t.length(); i++) {
            int count = dictT.getOrDefault(t.charAt(i), 0);
            dictT.put(t.charAt(i), count + 1);
        }

        int required = dictT.size();

        // Filter all the characters from s into a new list along with their index.
        // The filtering criteria is that the character should be present in t.
        List&lt;Pair&lt;Integer, Character&gt;&gt; filteredS = new ArrayList&lt;Pair&lt;Integer, Character&gt;&gt;();
        for (int i = 0; i &lt; s.length(); i++) {
            char c = s.charAt(i);
            if (dictT.containsKey(c)) {
                filteredS.add(new Pair&lt;Integer, Character&gt;(i, c));
            }
        }

        int l = 0, r = 0, formed = 0;
        Map&lt;Character, Integer&gt; windowCounts = new HashMap&lt;Character, Integer&gt;();  
        int[] ans = {-1, 0, 0};

        // Look for the characters only in the filtered list instead of entire s.
        // This helps to reduce our search.
        // Hence, we follow the sliding window approach on as small list.
        while (r &lt; filteredS.size()) {
            char c = filteredS.get(r).getValue();
            int count = windowCounts.getOrDefault(c, 0);
            windowCounts.put(c, count + 1);

            if (dictT.containsKey(c) &amp;&amp; windowCounts.get(c).intValue() == dictT.get(c).intValue()) {
                formed++;
            }

            // Try and contract the window till the point where it ceases to be 'desirable'.
            while (l &lt;= r &amp;&amp; formed == required) {
                c = filteredS.get(l).getValue();

                // Save the smallest window until now.
                int end = filteredS.get(r).getKey();
                int start = filteredS.get(l).getKey();
                if (ans[0] == -1 || end - start + 1 &lt; ans[0]) {
                    ans[0] = end - start + 1;
                    ans[1] = start;
                    ans[2] = end;
                }

                windowCounts.put(c, windowCounts.get(c) - 1);
                if (dictT.containsKey(c) &amp;&amp; windowCounts.get(c).intValue() &lt; dictT.get(c).intValue()) {
                    formed--;
                }
                l++;
            }
            r++;
        }
        return ans[0] == -1 ? &quot;&quot; : s.substring(ans[1], ans[2] + 1);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 : O(∣S∣+∣T∣)， 其中 ∣S∣ 和 ∣T∣ 分别代表字符串 S 和T 的长度。 本方法时间复杂度与方法一相同，但当 ∣filtered_S∣ &lt;&lt;&lt; ∣S∣ 时，复杂度会下降，因为此时迭代次数是 2∗∣filtered_S∣+∣S∣+∣T∣。<br>
空间复杂度 : O(∣S∣+∣T∣)。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 688. “马”在棋盘上的概率[中等]]]></title>
        <id>https://lixin-scut.github.io//post/dong-tai-gui-hua-688-ma-zai-qi-pan-shang-de-gai-lu-zhong-deng</id>
        <link href="https://lixin-scut.github.io//post/dong-tai-gui-hua-688-ma-zai-qi-pan-shang-de-gai-lu-zhong-deng">
        </link>
        <updated>2020-04-23T01:39:40.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>已知一个 NxN 的国际象棋棋盘，棋盘的行号和列号都是从 0 开始。即最左上角的格子记为 (0, 0)，最右下角的记为 (N-1, N-1)。 <br>
现有一个 “马”（也译作 “骑士”）位于 (r, c) ，并打算进行 K 次移动。 <br>
如下图所示，国际象棋的 “马” 每一步先沿水平或垂直方向移动 2 个格子，然后向与之相垂直的方向再移动 1 个格子，共有 8 个可选的位置。<br>
现在 “马” 每一步都从可选的位置（包括棋盘外部的）中独立随机地选择一个进行移动，直到移动了 K 次或跳到了棋盘外面。<br>
求移动结束后，“马” 仍留在棋盘上的概率。<br>
示例：<br>
输入: 3, 2, 0, 0<br>
输出: 0.0625<br>
解释:<br>
输入的数据依次为 N, K, r, c<br>
第 1 步时，有且只有 2 种走法令 “马” 可以留在棋盘上（跳到（1,2）或（2,1））。对于以上的两种情况，各自在第2步均有且只有2种走法令 “马” 仍然留在棋盘上。<br>
所以 “马” 在结束后仍在棋盘上的概率为 0.0625。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/knight-probability-in-chessboard<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>一开始的想法是存储每个格子的走K次的可能性,比如第一次、第二次、第三次每个格子的可能性<br>
然后实现中需要注意的点</p>
<ol>
<li>一开始很明显是用三维数组，但是我为了压缩空间+更明显地表现状态的变化，所以用上了二位数组</li>
<li>增加了4个外围概率，一定要初始化为0，并且不能计算概率</li>
<li>受第二点影响，所以循环应该起始于2，终止于N+2而不是N+4</li>
<li>概率之和要除以8</li>
</ol>
<pre><code>class Solution {
public:
    double knightProbability(int N, int K, int r, int c) {
        double ans = 0;
        
        vector&lt;vector&lt;double&gt;&gt; probability(N + 4, vector&lt;double&gt;(N + 4, 0));
        vector&lt;vector&lt;double&gt;&gt; temp(N + 4, vector&lt;double&gt;(N + 4, 0));
        probability[r + 2][c + 2] = 1;
        
        for(int k = 0; k &lt; K; ++k)
        {
            for(int i = 2; i &lt; N + 2; ++i)  // 注意限定范围是 N + 2
            {
                for(int j = 2; j &lt; N + 2; ++j)
                {
                    temp[i][j] = (probability[i - 1][j - 2] + probability[i - 2][j - 1]
                                + probability[i - 2][j + 1] + probability[i - 1][j + 2]
                                + probability[i + 1][j - 2] + probability[i + 2][j - 1]
                                + probability[i + 2][j + 1] + probability[i + 1][j + 2]) / 8;
                }
            }
            probability = temp;
        }
        for(int i = 2; i &lt; N + 2; ++i)
        {
                for(int j = 2; j &lt; N + 2; ++j)
                {
                    ans += probability[i][j];
                }
        }
        return ans;
    }
};
</code></pre>
<p>复杂度分析<br>
时间复杂度：<br>
O(KN^2)。其中 N,K 为题目中的定义。我们对 N^2 元素的每一层 dp 进行 O(1) 工作，并且考虑了 K 层。<br>
空间复杂度：O(N^2)，二维矩阵。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 56. 合并区间[中等]]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-56-he-bing-qu-jian-zhong-deng</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-56-he-bing-qu-jian-zhong-deng">
        </link>
        <updated>2020-04-22T02:08:49.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>给出一个区间的集合，请合并所有重叠的区间。<br>
示例 1:<br>
输入: [[1,3],[2,6],[8,10],[15,18]]<br>
输出: [[1,6],[8,10],[15,18]]<br>
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].<br>
示例 2:<br>
输入: [[1,4],[4,5]]<br>
输出: [[1,5]]<br>
解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/merge-intervals<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>看起来似乎是先排序后合并，只要前一个区间的右区间大于后一个区间的左区间，就需要合并</p>
<p>忽略了一个包含问题了</p>
<p>排序超时了hhh<br>
所以必须是一次遍历的？</p>
<p>看了题解发现不是的<br>
只是两个点</p>
<ol>
<li>sort可以进行vector的排序。。。就是类似于优先级排序</li>
<li>我一开始的循环符合条件，但是有重复的情况存在，加上排序就超时了</li>
</ol>
<p>实现中需要注意的点</p>
<ol>
<li>用空间换时间，一开始用vector的erase，需要进行元素搬移，很费时间</li>
<li>注意j的判断和大于等于的判断</li>
<li>注意i=j，而不能直接++i</li>
<li>最后我去掉了j，用temp来暂存</li>
</ol>
<pre><code>class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {
        if(intervals.empty())
        {   return intervals; }
        
        /*
        // out of time
        sort(intervals.begin(), intervals.end(), Solution());
        auto cur_vec = intervals.begin();
        while(cur_vec != intervals.end())
        {
            auto next_vec = cur_vec + 1;
            if(next_vec == intervals.end() || (*cur_vec)[1] &lt; (*next_vec)[0])
            {
                ++cur_vec;
            }
            else 
            {
                if((*cur_vec)[1] &lt; (*next_vec)[1])
                {
                    (*cur_vec)[1] = (*next_vec)[1];
                }
                intervals.erase(next_vec);
            }
        }
        */
        
        sort(intervals.begin(), intervals.end());
        vector&lt;vector&lt;int&gt;&gt; ans;
        for(int i = 0; i &lt;  intervals.size();)
        {
            vector&lt;int&gt; temp =  intervals[i];
            ++i;
            while(i &lt; intervals.size() &amp;&amp; temp[1] &gt;= intervals[i][0])
            {
                temp[1] = temp[1] &gt; intervals[i][1] ? temp[1] : intervals[i][1];
                ++i;
            }
            ans.push_back(temp);
        }
        
        return ans;
    }
    
    bool operator()(const vector&lt;int&gt;&amp; lhs, const vector&lt;int&gt;&amp; rhs) const
    {
        if(lhs[0] == rhs[0])
        {
            return lhs[1] &lt; rhs[1];
        }
        return lhs[0] &lt; rhs[0];
    }
};
</code></pre>
<p>官方题解</p>
<blockquote>
<p>方法：排序<br>
思路<br>
如果我们按照区间的左端点排序，那么在排完序的列表中，可以合并的区间一定是连续的。如下图所示，标记为蓝色、黄色和绿色的区间分别可以合并成一个大区间，它们在排完序的列表中是连续的：<br>
算法<br>
我们用数组 merged 存储最终的答案。<br>
首先，我们将列表中的区间按照左端点升序排序。然后我们将第一个区间加入 merged 数组中，并按顺序依次考虑之后的每个区间：<br>
如果当前区间的左端点在数组 merged 中最后一个区间的右端点之后，那么它们不会重合，我们可以直接将这个区间加入数组 merged 的末尾；<br>
否则，它们重合，我们需要用当前区间的右端点更新数组 merged 中最后一个区间的右端点，将其置为二者的较大值。</p>
</blockquote>
<pre><code>class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {
        if (intervals.size() == 0) {
            return {};
        }
        sort(intervals.begin(), intervals.end());
        vector&lt;vector&lt;int&gt;&gt; merged;
        for (int i = 0; i &lt; intervals.size(); ++i) {
            int L = intervals[i][0], R = intervals[i][1];
            if (!merged.size() || merged.back()[1] &lt; L) {
                merged.push_back({L, R});
            }
            else {
                merged.back()[1] = max(merged.back()[1], R);
            }
        }
        return merged;
    }
};

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/merge-intervals/solution/he-bing-qu-jian-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(nlogn)，其中 n 为区间的数量。除去排序的开销，我们只需要一次线性扫描，所以主要的时间开销是排序的 O(nlogn)。<br>
空间复杂度：O(logn)，其中 n 为区间的数量。这里计算的是存储答案之外，使用的额外空间。O(logn) 即为排序所需要的空间复杂度。</p>
</blockquote>
<p>网友题解</p>
<blockquote>
<p>解题思路<br>
我的方法思路很简单，很容易理解，一句话概括就是把这道题当成一个括号匹配的题：<br>
定义一个数组(box)，初始化每个元素为0用来记录匹配情况<br>
首先遍历输入，每个区间开始的值，在box下标对应的位置+1，每个区间结束的值，在box下标对应的地方-1<br>
然后遍历box(从0到区间所能到达的最大值，这个最大值可以在开始遍历的时候记录一下)，累加box[i]不是0的值，记录在cnt里面。如果到某个位置i的时候cnt为0，而box[i]不为0，这说明这是合并之后的区间中的一个开始的位置，用l记录这个位置，然后知道cnt有恢复到0，说明这个区间结束，用r记录当前位置，然后把l，r加到结果数组中。<br>
然后可能会有疑问，首尾相接的话，box里面对应的值不就是0了吗？对于这种情况，首尾相接的肯定要合并，对应的地方是0正合心意<br>
到这里，忽略了一种情况，区间里只有一个值的情况，即首尾相同的，如[[1,3][0,0]]<br>
这时候[0,0]这个区间就丢掉了…………<br>
迫不得已，又加了一个数组keng，来记录只有一个值的区间，然后，可算是通过了<br>
此方法的优缺点分析：<br>
优点：容易理解，不用排序，自带升序序列，速度在区间范围较小的情况下，要比排序快<br>
缺点：如果区间范围很大，如[0,10000]酱紫的，那可能就慢了。当然，辅助空间用的确实多…………</p>
</blockquote>
<pre><code>/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** merge(int** intervals, int intervalsSize, int* intervalsColSize, int* returnSize, int** returnColumnSizes){
    int box[10005];
    int keng[10005];
    int maxNum = 0;
    int l, r, cnt;
    returnSize[0] = 0;
    int **returnArr = (int**)calloc(intervalsSize, sizeof(int*));
    returnColumnSizes[0] = (int*)calloc(intervalsSize, sizeof(int));
    for(int i = 0; i &lt; intervalsSize; ++i) {
        returnArr[i] = (int*)calloc(2, sizeof(int));
        returnColumnSizes[0][i] = 2;
    }
    memset(box, 0, sizeof(box));
    memset(keng, 0, sizeof(keng));
    for(int i = 0; i &lt; intervalsSize; ++i) {
        if(box[intervals[i][0]] == box[intervals[i][1]]) {
            keng[intervals[i][0]] = 1;
        }
        ++box[intervals[i][0]];
        --box[intervals[i][1]];
        maxNum = maxNum &lt; intervals[i][1] ? intervals[i][1] : maxNum;
    }
    for(int i = 0; i &lt;= maxNum; ++i) {
        if(!box[i] &amp;&amp; keng[i] &amp;&amp; cnt == 0) {
            returnArr[returnSize[0]][0] = i;
            returnArr[returnSize[0]++][1] = i;
        }
        if(box[i]) {
            if(cnt == 0) {
                l = i;
            }
            cnt += box[i];
            if(cnt == 0) {
                r = i;
                returnArr[returnSize[0]][0] = l;
                returnArr[returnSize[0]++][1] = r;
            }
        }
    }
    return returnArr;
}

作者：hamiguaex163com
链接：https://leetcode-cn.com/problems/merge-intervals/solution/na-kong-jian-huan-shi-jian-er-qie-wo-mei-pai-xu-_-/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[哈希表 36. 有效的数独[中等][未做出]]]></title>
        <id>https://lixin-scut.github.io//post/ha-xi-biao-36-you-xiao-de-shu-du-zhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/ha-xi-biao-36-you-xiao-de-shu-du-zhong-deng-wei-zuo-chu">
        </link>
        <updated>2020-04-21T05:12:01.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。<br>
数字 1-9 在每一行只能出现一次。<br>
数字 1-9 在每一列只能出现一次。<br>
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。<br>
上图是一个部分填充的有效的数独。<br>
数独部分空格内已填入了数字，空白格用 '.' 表示。<br>
示例 1:<br>
输入:<br>
[<br>
[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],<br>
[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],<br>
[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],<br>
[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],<br>
[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],<br>
[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],<br>
[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],<br>
[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],<br>
[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]<br>
]<br>
输出: true<br>
示例 2:<br>
输入:<br>
[<br>
  [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],<br>
  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],<br>
  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],<br>
  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],<br>
  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],<br>
  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],<br>
  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],<br>
  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],<br>
  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]<br>
]<br>
输出: false<br>
解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。<br>
但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。<br>
说明:<br>
一个有效的数独（部分已被填充）不一定是可解的。<br>
只需要根据以上规则，验证已经填入的数字是否有效即可。<br>
给定数独序列只包含数字 1-9 和字符 '.' 。<br>
给定数独永远是 9x9 形式的。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/valid-sudoku<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>只想到了暴力法。。。<br>
然后发现官方题解也是优化版的暴力法。。。用空间换时间<br>
然后发现对3 * 3的格子定序号比较麻烦，首先要把行数化为3的倍数，然后再把列化为0、1、2，再相加<br>
实现需要注意的点</p>
<ol>
<li>非数字可以直接跳过</li>
<li>先使用相与判断是否有重复</li>
<li>然后可以直接插入</li>
</ol>
<p>最后的话还可以用bitset来降低空间复杂度</p>
<pre><code>class Solution {
public:
    // 数组版
    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) 
    {
        vector&lt;vector&lt;char&gt;&gt; row(9,vector&lt;char&gt;(9, 0));
        vector&lt;vector&lt;char&gt;&gt; col(9,vector&lt;char&gt;(9, 0));
        vector&lt;vector&lt;char&gt;&gt; box(9,vector&lt;char&gt;(9, 0));
        
        for(int i = 0; i &lt; 9; ++i)
        {
            for(int j = 0; j &lt; 9; ++j)
            {
                if(board[i][j] == '.')
                {   continue; }
                if(row[i][board[i][j] - '1'] == 1
                   || col[j][board[i][j] - '1'] == 1
                   || box[(i/3)*3 + j/3][board[i][j] - '1'] == 1)
                {   return false; }
                row[i][board[i][j] - '1'] = 1;
                col[j][board[i][j] - '1'] = 1;
                box[(i/3)*3 + j/3][board[i][j] - '1'] = 1;
            }
        }
        return true;
    }
    /*
    // 哈希表版
    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {
        vector&lt;set&lt;char&gt;&gt; row(9);
        vector&lt;set&lt;char&gt;&gt; col(9);
        vector&lt;set&lt;char&gt;&gt; box(9);
        
        for(int i = 0; i &lt; 9; ++i)
        {
            for(int j = 0; j &lt; 9; ++j)
            {
                if(board[i][j] == '.')
                {   continue; }
                if(row[i].count(board[i][j]) == 1
                   || col[j].count(board[i][j]) == 1
                   || box[(i/3)*3 + j/3].count(board[i][j]) == 1)
                {   return false; }
                row[i].insert(board[i][j]);
                col[j].insert(board[i][j]);
                box[(i/3)*3 + j/3].insert(board[i][j]);
            }
        }
        return true;
    }
    */
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>思路<br>
一个简单的解决方案是遍历该 9 x 9 数独 三 次，以确保：<br>
行中没有重复的数字。<br>
列中没有重复的数字。<br>
3 x 3 子数独内没有重复的数字。<br>
实际上，所有这一切都可以在一次迭代中完成。<br>
方法：一次迭代<br>
首先，让我们来讨论下面两个问题：<br>
如何枚举子数独？<br>
可以使用 box_index = (row / 3) * 3 + columns / 3，其中 / 是整数除法。<br>
如何确保行 / 列 / 子数独中没有重复项？<br>
可以利用 value -&gt; count 哈希映射来跟踪所有已经遇到的值。<br>
现在，我们完成了这个算法的所有准备工作：<br>
遍历数独。<br>
检查看到每个单元格值是否已经在当前的行 / 列 / 子数独中出现过：<br>
如果出现重复，返回 false。<br>
如果没有，则保留此值以进行进一步跟踪。<br>
返回 true。</p>
</blockquote>
<pre><code>class Solution {
  public boolean isValidSudoku(char[][] board) {
    // init data
    HashMap&lt;Integer, Integer&gt; [] rows = new HashMap[9];
    HashMap&lt;Integer, Integer&gt; [] columns = new HashMap[9];
    HashMap&lt;Integer, Integer&gt; [] boxes = new HashMap[9];
    for (int i = 0; i &lt; 9; i++) {
      rows[i] = new HashMap&lt;Integer, Integer&gt;();
      columns[i] = new HashMap&lt;Integer, Integer&gt;();
      boxes[i] = new HashMap&lt;Integer, Integer&gt;();
    }

    // validate a board
    for (int i = 0; i &lt; 9; i++) {
      for (int j = 0; j &lt; 9; j++) {
        char num = board[i][j];
        if (num != '.') {
          int n = (int)num;
          int box_index = (i / 3 ) * 3 + j / 3;

          // keep the current cell value
          rows[i].put(n, rows[i].getOrDefault(n, 0) + 1);
          columns[j].put(n, columns[j].getOrDefault(n, 0) + 1);
          boxes[box_index].put(n, boxes[box_index].getOrDefault(n, 0) + 1);

          // check if this value has been already seen before
          if (rows[i].get(n) &gt; 1 || columns[j].get(n) &gt; 1 || boxes[box_index].get(n) &gt; 1)
            return false;
        }
      }
    }

    return true;
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(1)，因为我们只对 81 个单元格进行了一次迭代。<br>
空间复杂度：O(1)。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 17. 电话号码的字母组合[中等]]]></title>
        <id>https://lixin-scut.github.io//post/zi-fu-chuan-17-dian-hua-hao-ma-de-zi-mu-zu-he-zhong-deng</id>
        <link href="https://lixin-scut.github.io//post/zi-fu-chuan-17-dian-hua-hao-ma-de-zi-mu-zu-he-zhong-deng">
        </link>
        <updated>2020-04-20T12:11:35.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。<br>
给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。<br>
示例:<br>
输入：&quot;23&quot;<br>
输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].<br>
说明:<br>
尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p>
</blockquote>
<p>首先的想法是回溯+递归<br>
实现中需要注意的点</p>
<ol>
<li>字符的转换很重要</li>
<li>本来以为每个字符循环三次，才发现7和9这两个奇葩，还是得好好看题。</li>
<li>所以必须用字符表了。。。。</li>
</ol>
<pre><code>class Solution {
public:
    vector&lt;string&gt; letterCombinations(string digits) {
        vector&lt;string&gt; res;
        if(digits.empty())
        {    return res; }
        
        string temp;
        letterCombinations(digits, 0, temp, res);
        return res;
    }
    
    void letterCombinations(const string&amp; digits, int num, string temp, vector&lt;string&gt;&amp; res)
    {
        if(num == digits.size())
        {
            res.push_back(temp);
            return;
        }
        string letter = letters[digits[num] - '2'];
        
        for(int i = 0; i &lt; letter.size(); ++i)
        {
            char c = letter[i];
            temp.push_back(c);
            letterCombinations(digits, num + 1, temp, res);
            temp.pop_back();
        }
        
    }
private:
    vector&lt;string&gt; letters {&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;};
    
};
</code></pre>
]]></content>
    </entry>
</feed>