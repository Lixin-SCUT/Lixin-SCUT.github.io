<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-03-10T00:51:47.706Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>In the darkest night,Rising like a spire.</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[Math 题60:n个骰子的点数]]></title>
        <id>https://lixin-scut.github.io//post/math-ti-60n-ge-tou-zi-de-dian-shu</id>
        <link href="https://lixin-scut.github.io//post/math-ti-60n-ge-tou-zi-de-dian-shu">
        </link>
        <updated>2020-03-10T00:21:50.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p>
<p>书本题解：</p>
<blockquote>
<p>一共有 6 个面，每个面上都有一个点数, 对应的 是1〜6之间的一个数字。所以n个骰子的点数和的最小值为n，最大值为6n。另外，根据排列组合的知识，我们还知道n个骰子的所有点数 的排列数为 6^n。要解决这个问题，我们需要先统计出每个点数出现的次数，然后把每个点数出现的次数除以 6^n,就能求出每个点数出现的概率。</p>
</blockquote>
<blockquote>
<p>解法一:基于递归求骰子点数,时间效率不够高<br>
要想求出n个骰子的点数和，可以先把n个骰子分为两堆:第一堆只有一个;另一堆有n-1个。单独的那一个有可能出现1〜6的点数。我们需要计算1〜6的每一种点数和剩下的n-1个骰子来计算点数和。接下来把剩下的n-1个骰子仍然分成两堆:第一堆只有一个;第二堆有n-2个。我们把上一轮那个单独骰子的点数和这一轮单独骰子的点数相加，再和剩下的个骰子来计算点数和。分析到这里，我们不难发现这是一种递归的思路，递归结束的条件就是最后只剩下一个骰子。<br>
我们可以定义一个长度为6n-n+1的数组，将和为s的点数出现的次数保存到数组的第s-n个元素里。</p>
</blockquote>
<pre><code>int g_maxValue = 6;

void PrintProbability_Solution1(int number)
{
    if(number &lt; 1)
        return;
 
    int maxSum = number * g_maxValue;
    int* pProbabilities = new int[maxSum - number + 1];
    for(int i = number; i &lt;= maxSum; ++i)
        pProbabilities[i - number] = 0;
 
    Probability(number, pProbabilities);
 
    int total = pow((double)g_maxValue, number);
    for(int i = number; i &lt;= maxSum; ++i)
    {
        double ratio = (double)pProbabilities[i - number] / total;
        printf(&quot;%d: %e\n&quot;, i, ratio);
    }
 
    delete[] pProbabilities;
}
 
void Probability(int number, int* pProbabilities)
{
    for(int i = 1; i &lt;= g_maxValue; ++i)
        Probability(number, number, i, pProbabilities);
}
 
void Probability(int original, int current, int sum, 
                 int* pProbabilities)
{
    if(current == 1)
    {
        pProbabilities[sum - original]++;
    }
    else
    {
        for(int i = 1; i &lt;= g_maxValue; ++i)
        {
            Probability(original, current - 1, i + sum, pProbabilities);
        }
    }
} 
</code></pre>
<blockquote>
<p>上述思路很简洁，实现起来也容易。但由于是基于递归的实现，它有很多计算是重复的，从而导致当 number 变大时性能慢得让人不能接受。</p>
</blockquote>
<blockquote>
<p>解法二:基于循环求骰子点数，时间性能好<br>
可以换一种思路来解决这个问题。我们可以考虑用两个数组来存储骰子点数的每个总数出现的次数。在一轮循环中，第一个数组中的第 n 个数 字表示骰子和为n<br>
出现的次数。在下一轮循环中，我们加上一个新的骰子, 此时和为 n 的骰子出现的次数应该等于上一轮循环中骰子点数和为n-1、 n-2、n-3、n-4、n-5与 n-6的次 数的总和，所以我们把另一个数组的第 n 个数字设为前一个数组对应的第n-1、 n-2、n-3、n-4、n-5与 n-6 个数字之和。<br>
(需要两个数组的原因：比如第一次得到123456.第二次则是234567...12,注意23456会重复，而且这五个没有n-6，会超出数组范围)</p>
</blockquote>
<pre><code>void PrintProbability_Solution2(int number)
{
    if(number &lt; 1)
        return;

    int* pProbabilities[2];
    pProbabilities[0] = new int[g_maxValue * number + 1];
    pProbabilities[1] = new int[g_maxValue * number + 1];
    for(int i = 0; i &lt; g_maxValue * number + 1; ++i)
    {
        pProbabilities[0][i] = 0;
        pProbabilities[1][i] = 0;
    }
 
    int flag = 0;
    for (int i = 1; i &lt;= g_maxValue; ++i) 
        pProbabilities[flag][i] = 1; 
    
    for (int k = 2; k &lt;= number; ++k) 
    {
        for(int i = 0; i &lt; k; ++i)
            pProbabilities[1 - flag][i] = 0;

        for (int i = k; i &lt;= g_maxValue * k; ++i) 
        {
            pProbabilities[1 - flag][i] = 0;
            for(int j = 1; j &lt;= i &amp;&amp; j &lt;= g_maxValue; ++j) 
                pProbabilities[1 - flag][i] += pProbabilities[flag][i - j];
        }
 
        flag = 1 - flag;
    }
 
    double total = pow((double)g_maxValue, number);
    for(int i = number; i &lt;= g_maxValue * number; ++i)
    {
        double ratio = (double)pProbabilities[flag][i] / total;
        printf(&quot;%d: %e\n&quot;, i, ratio);
    }
 
    delete[] pProbabilities[0];
    delete[] pProbabilities[1];
}
</code></pre>
<blockquote>
<p>上述代码中，我们定义了两个数组 pProbabilities[0]和 pProbabilities[l] 来存储骰 子的点数之和。在一轮循环中，一个数组的第 n 项等于另一个数组的第n-1、 n-2、n-3、n-4、n-5与 n-6项的和。在下一轮循环中，我们交换这两个数组(通过改变变量 flag 实现)再 重复这一计算过程。<br>
值得注意的是，上述代码没有在函数里把一个骰子的最大点数硬编码 (HardCode) 为 6,而是用一个变量 g maxValue 来表示。</p>
</blockquote>
<p>书本题解确实很巧妙<br>
1.从k开始外循环，不用考虑k之前的数，内循环则循环递增n-1至n-6的新骰子数<br>
2.利用两个数组轮流存储，并且利用bool隐式转换数组下标，精简了代码</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 题 59:队列的最大值[未做出]]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-ti-59dui-lie-de-zui-da-zhi-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-ti-59dui-lie-de-zui-da-zhi-wei-zuo-chu">
        </link>
        <updated>2020-03-09T23:39:06.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题目一">题目一</h3>
<blockquote>
<p>滑动窗口的最大值。给定一个数组和滑动窗口的大小，请找出所有滑动窗口里的最大值。例如，如果输入数组{2, 3, 4, 2, 6, 2, 5, 1}及滑动窗口的大小 3,那么一共存 在 6个滑动窗口，它们的最大值分别为{4,4,6,6,6,5}</p>
</blockquote>
<p>【未做出】<br>
我一开始想到的方法比较直接，就是用大顶堆来始终保证获得当前的最大值，并使用pair保存下标值，去除已经过期的元素<br>
实现的时候遇到一个问题，我在for循环头中不小心把loc重新定义了一次，导致覆盖了外部的loc<br>
时间复杂度比较高，建堆时间复杂度为 O(size) 插入和删除都是 O(logn)<br>
然后还是书本的队列法比较简单，就是在队列保存当前的下标值，然后保存所有小于当前最大值的数，直至遇到一个比当前值更大的数，就不断从头部推出。<br>
实现过程中发现必须是双端队列，比如{6,2,5,1}如果只是队列，那么5无法替代2，就会出错<br>
所以要使用deque,同时记得pop之前一定要检查size()</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size)
    {
        vector&lt;int&gt; res;
        int len(num.size());
        if(size == 0 || len &lt; size)
            return res;
        deque&lt;int&gt; maxnum;
        int loc;
        for(loc = 0;loc &lt; size;++loc)
        {
            if(maxnum.empty())
                maxnum.push_back(loc);
            while(maxnum.size() &amp;&amp; num[loc] &gt;= num[maxnum.front()])
                maxnum.pop_front();
            while(maxnum.size() &amp;&amp; num[loc] &gt;= num[maxnum.back()])
                maxnum.pop_back();
            maxnum.push_back(loc);
        }
        res.push_back(num[maxnum.front()]);
        for(;loc &lt; len;++loc)
        {
            if(loc - maxnum.front() &gt;= size)
                maxnum.pop_front();
            while(maxnum.size() &amp;&amp; num[loc] &gt;= num[maxnum.front()])
                maxnum.pop_front();
            while(maxnum.size() &amp;&amp; num[loc] &gt;= num[maxnum.back()])
                maxnum.pop_back();
            maxnum.push_back(loc);
            res.push_back(num[maxnum.front()]);
        }
        return res;
    }
		
    /*
    vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size)
    {
        int len(num.size());
        vector&lt;int&gt; res;
        if(size == 0 || len &lt; size)
            return res;
        priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;,compare&gt; maxnum;
        int loc;
        for(loc = 0; loc &lt; size; ++loc)
        {
            maxnum.push(make_pair(num[loc],loc));
        }
        res.push_back(maxnum.top().first);
        for( ; loc &lt; len ; ++loc)
        {
            maxnum.push(make_pair(num[loc],loc));
            while(loc - maxnum.top().second &gt;= size)
            {
                maxnum.pop();
            }
            res.push_back(maxnum.top().first);
        }
        return res;
    }
    
    struct compare{
        bool operator()(pair&lt;int,int&gt; numPair1,pair&lt;int,int&gt; numPair2)
        {
            return numPair1.first &lt;= numPair2.first;
        }
    };
    */
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>如果采用蛮力法，那么这个问题似乎不难解决:可以扫描每个滑动窗口的所有数字并找出其中的最大值。如果滑动窗口的大小为k，则需要 O(n)时间才能找出滑动窗口 里的最大值。对于长度为 n 的输入数组，这种算法的总时间复杂度是 O(nk)。<br>
实际上，一个滑动窗口可以看成一个队列。当窗口滑动时，处于窗口的第一个数字被删除，同时在窗口的末尾添加一个新的数字。这符合队列 的''先进先出”特性。如果能从队列中找出它的最大数，那么这个问题也 就解决了。<br>
如果 把队列用两个栈实现，由于可以用 O(1)时间得到栈中的最大值，那么也就可 以用O(1)时间 得到队列的最大值，因此总的时间复杂度也就降到了O(n)。<br>
下面换一种思路。我们并不把滑动窗口的每个数值都存入队列，而是 只把 有可能成为滑动窗口最大值的数值存入一个两端开口的队列deque.怎么知道滑动窗口是否包括一个数字? 应该在队列里存入数字在数组里的下标，而不是数值。当一个数字的下标 与当前处理的数字的下标之差大于或者等于滑动窗口的大小时，这个数字 已经从窗口中滑出，可以从队列中删除了。<br>
重点在于保证队列头部的数字一定是当前的最大值，保存有可能是滑动窗口最大值的数字的下标。在存入一个数字的下标之前，首先要判断队列里已有数字是 否小于待存入的数字。如果已有的数字小于待存入的数字，那么这些数字已经不可能是滑动窗口的最大值，因此它们将会被依次从队列的尾部 删除(调用函数 pop_back)。同时，如果队列头部的数字已经从窗口里滑出， 那么滑出的数字也需要从队列的头部删除(调用函数pop_front)。由于队列的头部和尾部都有可能删除数字，这也是需要两端开口的队列的原因。</p>
</blockquote>
<pre><code>vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size)
{
    vector&lt;int&gt; maxInWindows;
    if(num.size() &gt;= size &amp;&amp; size &gt;= 1)
    {
        deque&lt;int&gt; index;

        for(unsigned int i = 0; i &lt; size; ++i)
        {
            while(!index.empty() &amp;&amp; num[i] &gt;= num[index.back()])
                index.pop_back();

            index.push_back(i);
        }

        for(unsigned int i = size; i &lt; num.size(); ++i)
        {
            maxInWindows.push_back(num[index.front()]);

            while(!index.empty() &amp;&amp; num[i] &gt;= num[index.back()])
                index.pop_back();
            if(!index.empty() &amp;&amp; index.front() &lt;= (int) (i - size))
                index.pop_front();

            index.push_back(i);
        }
        maxInWindows.push_back(num[index.front()]);
    }

    return maxInWindows;
}
</code></pre>
<h3 id="题目二">题目二</h3>
<p>题目描述：</p>
<blockquote>
<p>队列的最大值。<br>
请定义一个队列并实现函数 max 得到队列里的最大值，要求函数 max、 push back 和 pop front 的时间复杂度都是 O(1)</p>
</blockquote>
<p>书本题解：</p>
<blockquote>
<p>滑动窗口可以看成一个队列，由于该解法和上题找滑动窗口的最大值类似，</p>
</blockquote>
<pre><code>template&lt;typename T&gt; class QueueWithMax
{
public:
    QueueWithMax() : currentIndex(0)
    {
    }

    void push_back(T number)
    {
        while(!maximums.empty() &amp;&amp; number &gt;= maximums.back().number)
            maximums.pop_back();

        InternalData internalData = { number, currentIndex };
        data.push_back(internalData);
        maximums.push_back(internalData);

        ++currentIndex;
    }

    void pop_front()
    {
        if(maximums.empty())
            throw new exception(&quot;queue is empty&quot;);

        if(maximums.front().index == data.front().index)
            maximums.pop_front();

        data.pop_front();
    }

    T max() const
    {
        if(maximums.empty())
            throw new exception(&quot;queue is empty&quot;);

        return maximums.front().number;
    }

private:
    struct InternalData
    {
        T number;
        int index;
    };

    deque&lt;InternalData&gt; data;
    deque&lt;InternalData&gt; maximums;
    int currentIndex;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 题58:翻转字符串]]></title>
        <id>https://lixin-scut.github.io//post/zi-fu-chuan-ti-58fan-zhuan-zi-fu-chuan</id>
        <link href="https://lixin-scut.github.io//post/zi-fu-chuan-ti-58fan-zhuan-zi-fu-chuan">
        </link>
        <updated>2020-03-09T23:22:42.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题目一">题目一</h3>
<p>题目描述：</p>
<blockquote>
<p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。 为简单起见，标点符号和普通字母一样处理。例如输入字符串&quot;I am a student. &quot;，则输出&quot;student. a am I&quot;。</p>
</blockquote>
<p>  第一想法就是定义一个reverse函数，先把整个字符串翻转，再以空格为标志，把单词逐个翻转<br>
  当然我的题解还是比较简单的版本，没有考虑字符串前面都是0的情况</p>
<pre><code>class Solution {
public:
    string ReverseSentence(string str) {
        if(str.empty())
            return str;
        Reverse(str,0,str.size()-1);
        int locSpace;
        locSpace = -1;
        for(int i=0;i &lt;= str.size();++i)
        {
            if(str[i] == ' ' || i == str.size())
            {
                Reverse(str,locSpace+1,i-1);
                locSpace = i;
            }
        }
        return str;
    }
    
    void  Reverse(string &amp;str,int beg,int end)
    {
        while(beg &lt; end)
        {
            char temp = str[beg];
            str[beg] = str[end];
            str[end] = temp;
            ++beg;
            --end;
        }
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>解题思路:第一步翻转句子中所有的字符。比如翻转 &quot;I am a student.&quot;中所 有的字符得到&quot;.tneduts a ma I&quot;,此时不但翻转了句子中单词的顺序，连单词内的字符顺序也被翻转了。第二步再翻转每个单词中字符的顺序，就得到了 &quot;student, a ami&quot;。这正是符合题目要求的输出。<br>
这种思路的关键在于实现一个函数以翻转字符串中的一段。在英语句子中，单词被空格符号分隔，因此我们可以通过扫描空格来 确定每 个单词的起始和终止位置。</p>
</blockquote>
<pre><code>char* ReverseSentence(char *pData)
{
    if(pData == nullptr)
        return nullptr;

    char *pBegin = pData;

    char *pEnd = pData;
    while(*pEnd != '\0')
        pEnd ++;
    pEnd--;

    // 翻转整个句子
    Reverse(pBegin, pEnd);

    // 翻转句子中的每个单词
    pBegin = pEnd = pData;
    while(*pBegin != '\0')
    {
        if(*pBegin == ' ')
        {
            pBegin ++;
            pEnd ++;
        }
        else if(*pEnd == ' ' || *pEnd == '\0')
        {
            Reverse(pBegin, --pEnd);
            pBegin = ++pEnd;
        }
        else
            pEnd ++;
    }

    return pData;
}
</code></pre>
<h3 id="题目二">题目二</h3>
<p>题目描述：</p>
<blockquote>
<p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如输入字符串&quot;abcdefg&quot;和数字2，该函数将返回左旋转2位得到的结果&quot;cdefgab&quot;。</p>
</blockquote>
<p>这个参考上一题的旋转<br>
先整体旋转，然后根据循环左移的位置再分别做两次旋转<br>
需要注意的就是左移的位数和字符串的长度的关系，如果恰好成倍数的话就不需要翻转<br>
不知道为什么，缺少return一直在报访问溢出。。。</p>
<pre><code>class Solution {
public:
    string LeftRotateString(string str, int n) {
        int len = str.size();
        if(str.empty() || len == 1 || n%len == 0)
            return str;
        n %= len;
        Reverse(str,0,len-1);
        Reverse(str,0,len-n-1);
        Reverse(str,len-n,len-1);
        return str;
    }
    
    void Reverse(string &amp;str,int beg,int end)
    {
        while(beg &lt; end)
        {
            swap(str[beg++],str[end--]);
        }
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>我们可以把字符串分为两部分。由于想把它的前两个字符移到后面， 我们就把前两个字符分到第一部分，把后面的所有字符分到第二部分。我们先分别翻转这两部分，接下来翻转 整个字符串，得到的刚好就是把原始字符串左旋转两位的结果。<br>
通过前面的分析，我们发现只需要调用 3 次前面的 Reverse 函数就可以实现字符 串的左旋转功能。<br>
字符串相关的代码时经常会发现两种问题:一是输入 空指针 nullptr 时程 序会崩溃;二是内存访问越界的问题，也就是试图访问不属于字符串的内存。</p>
</blockquote>
<pre><code>char* LeftRotateString(char* pStr, int n)
{
    if(pStr != nullptr)
    {
        int nLength = static_cast&lt;int&gt;(strlen(pStr));
        if(nLength &gt; 0 &amp;&amp; n &gt; 0 &amp;&amp; n &lt; nLength)
        {
            char* pFirstStart = pStr;
            char* pFirstEnd = pStr + n - 1;
            char* pSecondStart = pStr + n;
            char* pSecondEnd = pStr + nLength - 1;

            // 翻转字符串的前面n个字符
            Reverse(pFirstStart, pFirstEnd);
            // 翻转字符串的后面部分
            Reverse(pSecondStart, pSecondEnd);
            // 翻转整个字符串
            Reverse(pFirstStart, pSecondEnd);
        }
    }

    return pStr;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[malloc函数]]></title>
        <id>https://lixin-scut.github.io//post/malloc-han-shu</id>
        <link href="https://lixin-scut.github.io//post/malloc-han-shu">
        </link>
        <updated>2020-03-09T07:48:06.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/maokelong95/article/details/51989081">理解 glibc malloc - CSDN博客<br>
</a><br>
<a href="https://blog.csdn.net/eroswang/article/details/4130972">glibc中malloc的详细解释 - CSDN博客</a><br>
<a href="https://blog.csdn.net/caishenfans/article/details/44779797">浅析基于glibc的malloc - CSDN博客</a><br>
<a href="http://www.cnblogs.com/Commence/p/5785912.html">malloc 函数详解 - Commence - 博客园</a><br>
<a href="https://blog.csdn.net/qq_25072517/article/details/89852643">malloc 函数详解,虚拟内存与物理内存的联系与区别</a><br>
<a href="https://blog.csdn.net/gfgdsg/article/details/42709943">Linux内存分配机制</a></p>
<p>new和malloc的区别<br>
1、	new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持；<br>
2、	使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。<br>
3、	new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。<br>
4、	new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。<br>
5、	new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。</p>
<ol>
<li>malloc与free的实现原理？<br>
1、	在标准C库中，提供了malloc/free函数分配释放内存，这两个函数底层是由brk、mmap、，munmap这些系统调用实现的;<br>
2、	brk是将数据段(.data)的最高地址指针_edata往高地址推,mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系；<br>
3、	malloc小于128k的内存，使用brk分配内存，将_edata往高地址推；malloc大于128k的内存，使用mmap分配内存，在堆和栈之间找一块空闲内存分配；brk分配的内存需要等到高地址内存释放以后才能释放，而mmap分配的内存可以单独释放。当最高地址空间的空闲内存超过128K（可由M_TRIM_THRESHOLD选项调节）时，执行内存紧缩操作（trim）。在上一个步骤free的时候，发现最高地址空闲内存超过128K，于是内存紧缩。<br>
4、	malloc是从堆里面申请内存，也就是说函数返回的指针是指向堆里面的一块内存。操作系统中有一个记录空闲内存地址的链表。当操作系统收到程序的申请时，就会遍历该链表，然后就寻找第一个空间大于所申请空间的堆结点，然后就将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。</li>
<li>malloc、realloc、calloc的区别</li>
</ol>
<ol>
<li>malloc函数<br>
void* malloc(unsigned int num_size);<br>
int <em>p = malloc(20</em>sizeof(int));申请20个int类型的空间；</li>
<li>calloc函数<br>
void* calloc(size_t n,size_t size);<br>
int *p = calloc(20, sizeof(int));<br>
省去了人为空间计算；malloc申请的空间的值是随机初始化的，calloc申请的空间的值是初始化为0的；</li>
<li>realloc函数<br>
void realloc(void *p, size_t new_size);<br>
给动态分配的空间分配额外的空间，用于扩充容量。</li>
</ol>
<p>《深入理解计算机系统》<br>
C 标准库提供了一个称为 malloc 程序包的显式分配器。程序通过调用 malloc 函数来从堆中分配块。</p>
<pre><code>#include &lt;stdlib.h&gt;
void *malloc(size_t size);
返回:若成功则为已分配块的指针，若出错则为 NULL。
</code></pre>
<p>malloc 函数返回一个指针，指向大小为至少 size 字节的内存块，这个块会为可能包 含在这个块 内的任何数据对象类型做对齐。实际中，对齐依赖于编译代码在32位模式 (gcc-m32)还是64位 模式(默认的)中运行。在 32 位模式中，malloc 返回的块的地址总 是 8 的倍数。在 64 位模式中， 该地址总是 16 的倍数。<br>
如果 malloc 遇到问题(例如，程序要求的内存块比可用的虚拟内存还要大)，那么它 就返回 NULL,并设置 errnoc malloc 不初始化它返回的内存。那些想要已初始化的动 态内存的应用程序可以 使用 calloc, calloc 是一个基于 malloc 的瘦包装函数，它将分 配的内存初始化为零。想要改变一个以 前已分配块的大小，可以使用 realloc 函数。</p>
<p>动态内存分配器，例如 malloc,可以通过使用 mmap 和 munmap 函数，显式地分配和 释放堆内 存，或者还可以使用 sbrk 函数:</p>
<pre><code>#include &lt;unistd.h&gt;
void *sbrk(intptr_t incr);
返回:若成功则为旧的 brk 指针，若出错则为-1。
</code></pre>
<p>sbrk 函数通过将内核的 brk 指针增加 incr 来扩展和收缩堆。如果成功，它就返回 brk 的旧值， 否则，它就返回一 1,并将 errno 设置为 ENOMEM。如果 incr 为零，那么 sbrk 就返回 brk 的当前值。 用一个为负的 incr 来调用 sbrk 是合法的，而且很巧妙，因 为返回值(brk 的旧值)指向距新堆顶向 上 abs(incr)字节处。<br>
程序是通过调用 free 函数来释放已分配的堆块。<br>
#include &lt;stdlib.h&gt;<br>
void free(void *ptr);<br>
返回:无。</p>
<p>ptr 参数必须指向一个从 malloc、calloc 或者 realloc 获得的已分配块的起始位 置。如果不是， 那么 free 的行为就是未定义的。更糟的是，既然它什么都不返回，free 就不会告诉应用出现了错误。 就像我们将在 9. 11 节里看到的，这会产生一些令人迷惑的 运行时错误。<br>
图 9-34 展示了一个 malloc 和 free 的实现是如何管理一个 C 程序的 16 字的(非常)小 的堆的。 每个方框代表了一个 4 字节的字。粗线标出的矩形对应于已分配块(有阴影的)和 空闲块(无阴影 的)。初始时，堆是由一个大小为 16 个字的、双字对齐的、空闲块组成的。 (本节中，我们假设分 配器返回的块是 8 字节双字边界对齐的。)<br>
<img src="https://lixin-scut.github.io//post-images/1583742463502.png" alt=""></p>
<p>情况一、malloc小于128k的内存，使用brk分配内存，将_edata往高地址推(只分配虚拟空间，不对应物理内存(因此没有初始化)，第一次读/写数据时，引起内核缺页中断，内核才分配对应的物理内存，然后虚拟地址空间建立映射关系)，<br>
1、进程启动的时候，其（虚拟）内存空间的初始布局如图1所示。<br>
其中，mmap内存映射文件是在堆和栈的中间（例如libc-2.2.93.so，其它数据文件等），为了简单起见，省略了内存映射文件。<br>
_edata指针（glibc里面定义）指向数据段的最高地址。<br>
2、进程调用A=malloc(30K)以后，内存空间如图2：<br>
malloc函数会调用brk系统调用，将_edata指针往高地址推30K，就完成虚拟内存分配。<br>
你可能会问：只要把_edata+30K就完成内存分配了？<br>
事实是这样的，_edata+30K只是完成虚拟地址的分配，A这块内存现在还是没有物理页与之对应的，等到进程第一次读写A这块内存的时候，发生缺页中断，这个时候，内核才分配A这块内存对应的物理页。也就是说，如果用malloc分配了A这块内容，然后从来不访问它，那么，A对应的物理页是不会被分配的。<br>
3、进程调用B=malloc(40K)以后，内存空间如图3。</p>
<p>使用brk分配内存，将_edata往高地址推(只分配虚拟空间，不对应物理内存(因此没有初始化)，第一次读/写数据时，引起内核缺页中断，内核才分配对应的物理内存，然后虚拟地址空间建立映射关系)<br>
所以malloc()后一定要初始化(memset)，否则会引发段错误<br>
<a href="https://blog.csdn.net/weixin_42263483/article/details/80890150">论malloc()后忘记初始化(memset)的后果</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[原子性atomic与线程安全]]></title>
        <id>https://lixin-scut.github.io//post/yuan-zi-xing-atomic</id>
        <link href="https://lixin-scut.github.io//post/yuan-zi-xing-atomic">
        </link>
        <updated>2020-03-09T04:08:04.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</li>
<li>线程安全问题都是由全局变量及静态变量引起的。</li>
<li>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</li>
<li>对于线程不安全的对象我们可以通过如下方法来实现线程安全：<br>
①	加锁 利用Synchronized或者ReenTrantLock来对不安全对象进行加锁，来实现线程执行的串行化，从而保证多线程同时操作对象的安全性，一个是语法层面的互斥锁，一个是API层面的互斥锁.<br>
②	非阻塞同步来实现线程安全。原理就是：通俗点讲，就是先进性操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生冲突，那就再采取其他措施(最常见的措施就是不断地重试，知道成功为止)。这种方法需要硬件的支持，因为我们需要操作和冲突检测这两个步骤具备原子性。通常这种指令包括CAS SC,FAI TAS等。<br>
③	线程本地化，一种无同步的方案，就是利用Threadlocal来为每一个线程创造一个共享变量的副本来（副本之间是无关的）避免几个线程同时操作一个对象时发生线程安全问题。</li>
</ol>
<p><a href="https://blog.csdn.net/lg1259156776/article/details/52732879">对于可重入、线程安全、异步信号安全几个概念的理解</a></p>
<p><a href="https://github.com/luohaha/MyBlog/issues/3">原子操作是如何实现的</a><br>
原子操作对于我们来说，是非常熟悉的概念。在某些场景下，可以用原子操作来替换重量级的锁同步，从而提高程序性能。原子操作可以保障多个线程或进程在更新某块共享内存区时，可以避免同步原语。</p>
<p>对于原子操作的实现来说，需要分开考虑单处理器单核系统，和多处理器系统，多核系统。</p>
<p>对于单处理器单核系统来说，只要保证操作指令序列不被打断即可实现原子操作。对于简单的原子操作，cpu实现上会提供单条指令，比如INC和XCHG。对于复杂的原子操作，需要包含多条指令。执行过程中，出现上下文切换行为，比如任务切换，中断处理等。这里的行为会影响原子操作的原子性。因此需要自旋锁spinlock[1]来保证操作指令序列不会在执行的中途受干扰。</p>
<p>但是如果对于多处理器或者多核的系统，原子操作的实现除了需要spinlock来保证外，还需要保证不会受到同处理器上其他核，或者其他处理器的影响。当其他核上执行的指令访问的内存空间，与当前原子操作需要访问的内存空间存在冲突时，就会破坏原子操作的正确性。</p>
<p>在x86架构中，提供了指令前缀LOCK。LOCK保证了指令不会受其他处理器或cpu核的影响。在PentiumPro之前，LOCK的实现，是通过锁住bus（总线），从而阻止其他cpu核的内存访问。可想而知，这种实现是非常低效的。从PentiumPro开始，LOCK只会阻塞其他cpu核对相关内存的缓存块的访问。</p>
<p>现在，大多数的x86处理器都支持了CAS的硬件实现，保证了多处理器多核系统下的原子操作的正确性。CAS的实现同样无需锁住总线，只会阻塞其他cpu核对相关内存的缓存块的访问。同样的，在MIPS和ARM架构下，还支持了LL/SC的实现。LL/SC不会出现CAS中的ABA问题。</p>
<p>在继续深入以前，需要了解MESI缓存协议。当然，还存在其他的MESI变种，不过这里只会简单解释下MESI。每个cache line存在四种状态，Modified代表该cache line为该cpu核独有，且尚未写回（write back）到内存（对缓存一致性不了解的看这里）。Exclusive代表该cache line为该cpu核独有，且与内存一致。Shared代表该cache line为多核共享，且与内存一致。Invalid代表缓存失效。系统中多个核之间通过快速通道直接通信，比如intel家的QPI，amd家的Hypertransport。cpu核之间通信的消息包括读消息，以及读消息的响应消息。使无效消息，以及使无效消息的响应消息。当运行在某个cpu核的线程准备读取某个cache line的内容时，如果状态处于M,E,S，直接读取即可。如果状态处于I，则需要向其他cpu核广播读消息，在接受到其他cpu核的读响应后，更新cache line，并将状态设置为S。而当线程准备写入某个cache line时，如果处于M状态，直接写入。如果处于E状态，写入并将cache line状态改为M。如果处于S，则需要向其他cpu核广播使无效消息，并进入E状态，写入修改，后进入M状态。如果处于I，则需要向其他cpu核广播读消息核使无效消息，在收集到读响应后，更新cache line。在收集到使无效响应后，进入E状态，写入修改，后进入M状态。</p>
<p>从上面的说明可知，LOCK的实现，只需要保持cache line的M状态即可，此时就可以阻止其他cpu核对该块内存的修改，而不用去锁住整个总线。</p>
<p><a href="https://www.jianshu.com/p/c6e8ae5c0e8e">C++11编程底层知识：无锁数据结构：原子性、原子性原语</a></p>
<p><a href="https://blog.csdn.net/xuxile/article/details/73739536">JAVA基础篇-原子操作的实现原理</a><br>
<a href="https://www.infoq.cn/article/atomic-operation/">聊聊并发（五）——原子操作的实现原理</a></p>
<h3 id="自增i是否是原子操作">自增++i是否是原子操作</h3>
<p>i++的操作分三步：<br>
（1）栈中取出i<br>
（2）i自增1<br>
（3）将i存到栈<br>
所以i++不是原子操作，上面的三个步骤中任何一个步骤同时操作，都可能导致i的值不正确自增</p>
<h3 id="volatile关键字">Volatile关键字</h3>
<p><a href="https://www.cnblogs.com/god-of-death/p/7852394.html">C/C++ Volatile关键词深度剖析</a><br>
<a href="https://www.cnblogs.com/whutao/p/10516107.html">volatile关键字的学习</a></p>
<h3 id="stl容器的线程安全性">STL容器的线程安全性</h3>
<p><a href="https://blog.csdn.net/u012730075/article/details/14168351">STL容器的线程安全</a><br>
<a href="https://www.cnblogs.com/ztteng/archive/2013/11/07/3411738.html">STL容器是否是线程安全的</a></p>
<h3 id="内存池">内存池</h3>
<p>内存池对象不是线程安全的，在多线程编程中，创建一个对象时必须加锁。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[无锁队列]]></title>
        <id>https://lixin-scut.github.io//post/wu-suo-dui-lie</id>
        <link href="https://lixin-scut.github.io//post/wu-suo-dui-lie">
        </link>
        <updated>2020-03-09T04:04:18.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/syzcch/article/details/8075830">利用CAS操作（Compare &amp; Set）实现无锁队列</a><br>
<a href="https://coolshell.cn/articles/8239.html">无锁队列的实现</a><br>
<a href="https://www.cnblogs.com/lidabo/p/9767068.html">基于无锁队列和c++11的高性能线程池</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 1143: 最长公共子序列LCS[未做出]]]></title>
        <id>https://lixin-scut.github.io//post/zi-fu-chuan-1143-zui-chang-gong-gong-zi-xu-lie-lcswei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/zi-fu-chuan-1143-zui-chang-gong-gong-zi-xu-lie-lcswei-zuo-chu">
        </link>
        <updated>2020-03-09T02:57:23.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列。<br>
一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>
例如，&quot;ace&quot; 是 &quot;abcde&quot; 的子序列，但 &quot;aec&quot; 不是 &quot;abcde&quot; 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。<br>
若这两个字符串没有公共子序列，则返回 0。<br>
示例 1:<br>
输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot;<br>
输出：3<br>
解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。<br>
示例 2:<br>
输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;<br>
输出：3<br>
解释：最长公共子序列是 &quot;abc&quot;，它的长度为 3。<br>
示例 3:<br>
输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;<br>
输出：0<br>
解释：两个字符串没有公共子序列，返回 0。<br>
提示:<br>
1 &lt;= text1.length &lt;= 1000<br>
1 &lt;= text2.length &lt;= 1000<br>
输入的字符串只含有小写英文字符。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/longest-common-subsequence<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<ol>
<li>第一想法是从编辑距离那里想到的，就是固定text1的一位然后和text2每一位的每一位对比，而text1的下一位的结果就等于之前的情况的取最大值再+1或不+1</li>
<li>然后实现中出现coredump，用gdb调试发现是忘了初始值定义为1而不是0</li>
<li>然后测试结果过大，一开始我以为是col的初始值不能定义为1，而应该定义为row，但是作图发现这个想法是错误的，完全可能从1开始</li>
<li>看题解发现其实是状态转移错误了，如果当前字符相等，应该直接从上一字符串res[col-1][row-1]来+1，而如果不相等，应该从max(res[col-1][row], res[col][row-1])中找最大值，可以从递归的思想出发理解这个思路</li>
<li>最后按惯例做了空间优化，用一维空间替代二维空间，注意空间优化的时候最好也保持从1开始。</li>
</ol>
<p><strong>最后代码</strong></p>
<pre><code>class Solution {
public:
    /*
    // 动态规划
    int longestCommonSubsequence(string text1, string text2) {
        int length1 = text1.size();
        int length2 = text2.size();
        if(length1 == 0 &amp;&amp; length2 == 0)
        {   return 0; }
        vector&lt;vector&lt;int&gt;&gt; res(length1+1, vector&lt;int&gt;(length2+1, 0));
        
        for(int col = 0; col &lt; length1 + 1; ++col)
        {   res[col][0] = 0; }
        for(int row = 0; row &lt; length2 + 1; ++row)
        {   res[0][row] = 0; }
        
        for(int row = 1; row &lt; length2 + 1; ++row) // 注意不要初始化为0
        {
            for(int col = 1; col &lt; length1 + 1; ++col) 
            {
                // 想清楚为啥max中没有res[col-1][row-1]
                res[col][row] = (text1[col - 1] == text2[row - 1]) ? 
                                    res[col-1][row-1] + 1 : max(res[col-1][row], res[col][row-1]);
            }
        }
        return res[length1][length2];
    }
    */
    
    //优化空间
     int longestCommonSubsequence(string text1, string text2) {
        int length1 = text1.size();
        int length2 = text2.size();
        if(length1 == 0 &amp;&amp; length2 == 0)
        {   return 0; }
        vector&lt;int&gt; res(length1+1, 0);  
        vector&lt;int&gt; temp(length1+1, 0);
        
        for(int row = 1; row &lt; length2 + 1 ; ++row) // 注意不要初始化为0
        {
            for(int col = 1; col &lt; length1 + 1; ++col)  
            {
                res[col] = (text1[col - 1] == text2[row - 1]) ? 
                                    temp[col-1] + 1 : max(res[col-1], temp[col]);
            }
            temp = res;
        }
        return res.back();
    }
};
</code></pre>
<p>网友题解<br>
<a href="https://leetcode-cn.com/problems/longest-common-subsequence/solution/dong-tai-gui-hua-zhi-zui-chang-gong-gong-zi-xu-lie/">动态规划之最长公共子序列（LCS）</a></p>
<blockquote>
<p>状态转移方程：<br>
这是动态规划最难的一步，不过好在这种字符串问题的套路都差不多，权且借这道题来聊聊处理这类问题的思路。<br>
状态转移说简单些就是做选择，比如说这个问题，是求 s1 和 s2 的最长公共子序列，不妨称这个子序列为 lcs。那么对于 s1 和 s2 中的每个字符，有什么选择？很简单，两种选择，要么在 lcs 中，要么不在。<br>
这个「在」和「不在」就是选择，关键是，应该如何选择呢？这个需要动点脑筋：如果某个字符应该在 lcs 中，那么这个字符肯定同时存在于 s1 和 s2 中，因为 lcs 是最长公共子序列嘛。所以本题的思路是这样：<br>
用两个指针 i 和 j 从后往前遍历 s1 和 s2，如果 s1[i]==s2[j]，那么这个字符一定在 lcs 中；否则的话，s1[i] 和 s2[j] 这两个字符至少有一个不在 lcs 中，需要丢弃一个。先看一下递归解法，比较容易理解：</p>
</blockquote>
<pre><code>def longestCommonSubsequence(str1, str2) -&gt; int:
    def dp(i, j):
        # 空串的 base case
        if i == -1 or j == -1:
            return 0
        if str1[i] == str2[j]:
            # 这边找到一个 lcs 的元素，继续往前找
            return dp(i - 1, j - 1) + 1
        else:
            # 谁能让 lcs 最长，就听谁的
            return max(dp(i-1, j), dp(i, j-1))
        
    # i 和 j 初始化为最后一个索引
    return dp(len(str1)-1, len(str2)-1)
</code></pre>
<blockquote>
<p>对于第一种情况，找到一个 lcs 中的字符，同时将 i j 向前移动一位，并给 lcs 的长度加一；对于后者，则尝试两种情况，取更大的结果。<br>
对于 s1[i] 和 s2[j] 不相等的情况，至少有一个字符不在 lcs 中，会不会两个字符都不在呢？所以代码是不是应该考虑这种情况，改成这样：</p>
</blockquote>
<pre><code>if str1[i - 1] == str2[j - 1]:
    # ...
else:
    dp[i][j] = max(dp[i-1][j], 
                   dp[i][j-1],
                   dp[i-1][j-1])
</code></pre>
<blockquote>
<p>我一开始也有这种怀疑，其实可以这样改，也能得到正确答案，但是多此一举，因为 dp[i-1][j-1] 永远是三者中最小的，max 根本不可能取到它。<br>
原因在于我们对 dp 数组的定义：对于 s1[1..i] 和 s2[1..j]，它们的 LCS 长度是 dp[i][j]。<br>
这样一看，显然 dp[i-1][j-1] 对应的 lcs 长度不可能比前两种情况大，所以没有必要参与比较。<br>
<img src="https://lixin-scut.github.io//post-images/1583723078015.png" alt=""></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 题57:和为s的两个数字]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-ti-57he-wei-s-de-liang-ge-shu-zi</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-ti-57he-wei-s-de-liang-ge-shu-zi">
        </link>
        <updated>2020-03-09T00:20:50.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题目一">题目一</h3>
<p>题目描述</p>
<blockquote>
<p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p>
</blockquote>
<p>【未做出】<br>
因为数组是排序的，我的想法是从数组中间出发，用双指针不断往两边移动<br>
从中间出发的原因是因为数组中间的数的乘积肯定大于两边的数的乘积<br>
每当找到符合条件的数的时候，就先用一个变量存储下来，然后先移动左边的指针使得当前的和值缩小</p>
<p>突然发现一个问题 比如{1,1,1,1,10,90}<br>
那么符合答案100的就是10+90，从中间开始往两边移动肯定就不行了</p>
<p>然后就是leetcode上面的解法了<br>
每个元素都遍历后面的元素 但是我感觉似乎找到第一个就可以结束了，毕竟后面的乘积肯定比前面的大<br>
等等！！！负数呢？！！！如果是 {-2,-1,1,2}的话，-2 和 2 是不是比 -1 和 1 小呢,确认还是第一个遇到的符合结果的就可以直接返回了</p>
<p>看完书才发现我之前的思想是正确的。。。只是必须从两边到中间而已。。。。就是没多思考一步</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum)
    {
        vector&lt;int&gt; res;
        int length = array.size();
        if(length&lt;2)
            return res;
        int left = 0;
        int right = length - 1;
        while(left &lt; right)
        {
            if(array[left] + array[right] == sum)
            {
                res.push_back(array[left]);
                res.push_back(array[right]);
                return res;
            }
            if(array[left] + array[right] &gt; sum)
                --right;
            else
                ++left;
        }
        return res;
    }
    
    /*时间复杂度O(n^2)
    vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum) 
    {
        vector&lt;int&gt; res;
        int length = array.size();
        if(length&lt;2)
            return res;
        for(int i = 0;i &lt; length;++i)
            for(int j = i + 1;j &lt; length;++j)
            {
                if(array[i]+array[j] == sum)
                {
                    res.push_back(array[i]);
                    res.push_back(array[j]);
                    return res;
                }
                if(array[i]+array[j] &gt; sum)
                    break;
            }
        return res;
    }
    */
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>首先定义两个指针，第一个指针指向数组的第一个(最小的)数字 , 第二个指针 指向数组的最后一个(最大的)数字 ，当前和大于给出值的时候右指针向前移，当前和小于给出值的时候左指针向后移，从两端向中间 扫描数组，因此这种算法的时间复杂度是 O(n)。</p>
</blockquote>
<pre><code>bool FindNumbersWithSum(int data[], int length, int sum, 
                        int* num1, int* num2)
{
    bool found = false;
    if(length &lt; 1 || num1 == nullptr || num2 == nullptr)
        return found;

    int ahead = length - 1;
    int behind = 0;

    while(ahead &gt; behind)
    {
        long long curSum = data[ahead] + data[behind];

        if(curSum == sum)
        {
            *num1 = data[behind];
            *num2 = data[ahead];
            found = true;
            break;
        }
        else if(curSum &gt; sum)
            ahead --;
        else
            behind ++;
    }

    return found;
}
</code></pre>
<h3 id="题目二">题目二</h3>
<p>题目描述：</p>
<blockquote>
<p>输入一个正数s，打印出所有和为s的连续正数序列（至少含有两个数）。</p>
</blockquote>
<p>【未做出】<br>
连续序列的和可以靠等差数列的求和公式解决<br>
然后就是注意题目中并没有说明序列的个数（只是至少包含两个数，而不是固定数目）<br>
然后就是双指针法了,两个指针不断前进<br>
需要注意的点<br>
1.beg和end分别初始化为1和2，所以初始判断条件为&lt;3<br>
2.等差数列求和公式<br>
3.插入完成后一定要递增beg<br>
4.beg和end的递增条件和时机</p>
<pre><code>class Solution {
public:
    vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) {
        vector&lt;vector&lt;int&gt;&gt; res;
        if(sum &lt; 3)
            return res;
        int beg;
        int end;
        int curSum;
        beg = 1;
        end = 2;
        while(beg &lt; end)
        {
            curSum = (beg + end)*(end - beg + 1)/2;
            if(curSum == sum){
                insertRes(res,beg,end);
                ++beg;
            }
            else if(curSum &lt;= sum)
                ++end;
            else
                ++beg;
        }
        return res;
    }
    
    void insertRes(vector&lt;vector&lt;int&gt;&gt; &amp;res,int beg,int end)
    {
        res.push_back(vector&lt;int&gt;());
        for(int i = beg;i &lt;= end; ++i)
            res.back().push_back(i);
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>用两个数 small 和 big 分别表示 序列 的最小值和最大值。首先把 small 初始化为 1, big 初始化为 2。如果从 small 到 big 的序列的和大于 s,则可以从序列中去掉较小的值，也就是增大 small 的值。如果 从 small 到 big 的序列的和小于 s,则可以增大 big,让这 个序列包含更多的数字。 因为这个序列至少要有两个数字，我们一直增加 small到(1+s)/2 为止。</p>
</blockquote>
<pre><code>void FindContinuousSequence(int sum)
{
    if(sum &lt; 3)
        return;

    int small = 1; 
    int big = 2;
    int middle = (1 + sum) / 2;
    int curSum = small + big;

    while(small &lt; middle)
    {
        if(curSum == sum)
            PrintContinuousSequence(small, big);

        while(curSum &gt; sum &amp;&amp; small &lt; middle)
        {
            curSum -= small;
            small ++;

            if(curSum == sum)
                PrintContinuousSequence(small, big);
        }

        big ++;
        curSum += big;
    }
}

void PrintContinuousSequence(int small, int big)
{
    for(int i = small; i &lt;= big; ++ i)
        printf(&quot;%d &quot;, i);

    printf(&quot;\n&quot;);
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 题56:数组中数字出现的次数[未做出]]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-ti-56shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-ti-56shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-wei-zuo-chu">
        </link>
        <updated>2020-03-08T23:53:24.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题目一">题目一</h3>
<p>题目描述</p>
<blockquote>
<p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
</blockquote>
<p>【未做出】<br>
一开始看错题目了，以为是只有一个数，结果发现是两个数<br>
书本的题解很巧妙，全部的数相与后，按照某一位是否为1把数组分为两个部分，因为对于那两个数来说，这一位肯定是不同的<br>
而对剩下的数来说，肯定会被分到不同的数组中。<br>
实现的时候只需要两次遍历，第二次遍历中检查相应的位数，然后执行相与就行，不用真的分成两个数组再相与<br>
代码中出现了两个很细节的问题<br>
1.位运算符&lt;&lt;返回的是右值，和加减乘除没有什么区别，所以必须要赋值带上赋值操作 bit=bit&lt;&lt;1<br>
2.==运算符的优先级高于位运算符，所以与操作&amp;必须加上括号</p>
<pre><code>class Solution {
public:
    void FindNumsAppearOnce(vector&lt;int&gt; data,int* num1,int *num2) {
        int res = 0;
        for(int i:data)
            res ^= i;
        int bit = diffBit(res);
        *num1 = 0;
        *num2 = 0;
        for(int i:data)
            if(bit &amp; i)
                *num1 ^= i;
            else
                *num2 ^= i;
    }
    
    int diffBit(int res){
        int bit = 1;
        while((bit &amp; res) == 0)
            bit = bit &lt;&lt; 1;
        return bit;
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>数组中只有一个数字只出现了一次，其他数字都出现了两次，我们想到异或运算的一个性质:任何一个数字异 或它自己都等于0。试着把原数组分成两个子数组，使得每个子数组包含一个只出现一次的数字，而其他数字都成对出现两次。<br>
我们还是从头到尾依次异或数组中的每个数字，那么最终得到的结果就是两个只出现一次的数字的异或结果，因为其他数字都出现了两次，在异或中全部抵消了。由于这两个数字肯定不一样，那么异或的结果肯定不为 0,也就是说，在这个结果数字的二进制表示中至少有一位为1。我们在结果数字中找到第一个为1的位的位置，记为第n位。现在我们以第位是不是1为标准把原数组中的数字分成两个子数组，第-个子数组中每个 数字的第n位都是1,而第二个子数组中每个数字的第n位都是0。由于我们分组的标准是数字中的某一位是1还是0, 那么出现了两次的数字肯定被分配到同一个子数组。</p>
</blockquote>
<pre><code>void FindNumsAppearOnce(int data[], int length, int* num1, int* num2)
{
    if(data == nullptr || length &lt; 2)
        return;

    int resultExclusiveOR = 0;
    for(int i = 0; i &lt; length; ++i)
        resultExclusiveOR ^= data[i];

    unsigned int indexOf1 = FindFirstBitIs1(resultExclusiveOR);

    *num1 = *num2 = 0;
    for(int j = 0; j &lt; length; ++j)
    {
        if(IsBit1(data[j], indexOf1))
            *num1 ^= data[j];
        else
            *num2 ^= data[j];
    }
}

// 找到num从右边数起第一个是1的位
unsigned int FindFirstBitIs1(int num)
{
    int indexBit = 0;
    while(((num &amp; 1) == 0) &amp;&amp; (indexBit &lt; 8 * sizeof(int)))
    {
        num = num &gt;&gt; 1;
        ++indexBit;
    }

    return indexBit;
}

// 判断数字num的第indexBit位是不是1
bool IsBit1(int num, unsigned int indexBit)
{
    num = num &gt;&gt; indexBit;
    return (num &amp; 1);
}
</code></pre>
<h3 id="题目二">题目二</h3>
<p>题目描述</p>
<blockquote>
<p>在一个数组中除了一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p>
</blockquote>
<p>书本题解：</p>
<blockquote>
<p>为三个相同的数字的异或结果还是该数字。尽管我们这里不能应用异或运算，我们还是可以沿用位运算的思路。 如果一个数字出现三次，那么它的二进制表示的每一位(0 或者 1) 也出现三次。如果把所有出现三次的数字的二进制表示的每一位都分别加起来，那么每一位的和都能被3整除。<br>
我们把数组中所有数字的二进制表示的每一位都加起来。如果某一位的和能被 3 整除，那么那个只出现一次的数字二进制表示中对应的那一位是 0;否则就是1。</p>
</blockquote>
<pre><code>int FindNumberAppearingOnce(int numbers[], int length)
{
    if(numbers == nullptr || length &lt;= 0)
        throw new std::exception(&quot;Invalid input.&quot;);

    int bitSum[32] = {0};
    for(int i = 0; i &lt; length; ++i)
    {
        int bitMask = 1;
        for(int j = 31; j &gt;= 0; --j)
        {
            int bit = numbers[i] &amp; bitMask;
            if(bit != 0)
                bitSum[j] += 1;

            bitMask = bitMask &lt;&lt; 1;
        }
    }

    int result = 0;
    for(int i = 0; i &lt; 32; ++i)
    {
        result = result &lt;&lt; 1;
        result += bitSum[i] % 3;
    }

    return result;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 题55:二叉树的深度[未做出]]]></title>
        <id>https://lixin-scut.github.io//post/shu-ti-55er-cha-shu-de-shen-du-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/shu-ti-55er-cha-shu-de-shen-du-wei-zuo-chu">
        </link>
        <updated>2020-03-08T23:33:33.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题目一">题目一</h3>
<p>题目描述</p>
<blockquote>
<p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
</blockquote>
<p>我一开始想到的就是递归的先序遍历和迭代的层次遍历<br>
但是书本的题解明显更加简洁</p>
<pre><code>class Solution {
public:
    int TreeDepth(TreeNode* pRoot)
    {
        if(pRoot == nullptr)
            return 0;
        
        int left = TreeDepth(pRoot-&gt;left);
        int right = TreeDepth(pRoot-&gt;right);
        
        return left &gt; right ? left+1 : right+1;
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>我们还可以从另外一个角度来理解树的深度。如果一棵树只有一个节点，那么它的深度为1。如果根节点只有左子树而没有右子树，那么树的深度应该是其 左子树的深度加 1;同样，如果根节点只有右子树而没有左子 树，那么树的深度应该是其右子树的深度加1。如果既有右子树又有左子树, 那么该树的深度就是其左、右子树深度的较大值再加1。<br>
这种思路用递归的方法很容易实现</p>
</blockquote>
<pre><code>int TreeDepth(const BinaryTreeNode* pRoot)
{
    if(pRoot == nullptr)
        return 0;

    int nLeft = TreeDepth(pRoot-&gt;m_pLeft);
    int nRight = TreeDepth(pRoot-&gt;m_pRight);

    return (nLeft &gt; nRight) ? (nLeft + 1) : (nRight + 1);
}
</code></pre>
<h3 id="题目二">题目二</h3>
<p>题目描述</p>
<blockquote>
<p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
</blockquote>
<p>这一题利用了二叉树深度返回int的思想，但是因为主函数必须返回bool，所以重载了函数<br>
然后传引用一个bool记录，顺带可以根据bool的取值提前结束函数。</p>
<pre><code>class Solution {
public:
    bool IsBalanced_Solution(TreeNode* pRoot) {
        if(pRoot == nullptr)
            return true;
        bool flag;
        flag = false;
        IsBalanced_Solution(pRoot,flag);
        return !flag;
    }
    
    int IsBalanced_Solution(TreeNode* curNode,bool&amp; flag){
        if(flag)
            return 0;
        if(curNode == nullptr)
            return 0;
        int nleft = IsBalanced_Solution(curNode-&gt;left,flag);
        int nright = IsBalanced_Solution(curNode-&gt;right,flag);
        flag = (nleft - nright &gt; 1) || (nright - nleft &gt; 1);
        return nleft &gt; nright ? nleft+1 : nright+1 ;
    }
};
</code></pre>
<p>书本题解：<br>
每个节点只遍历一次的解法：如果我们用后序遍历的方式遍历二叉树的每个节点，那么在遍历到一个节点之前我们就已经遍历了它的左、右子树。只要在遍历每个节点的时候记录它的深度(某一节点的深度等于它到叶节点的路径的长度)，我们就可以一边遍历一边判断每个节点是不是平衡的。</p>
<pre><code>bool IsBalanced_Solution2(const BinaryTreeNode* pRoot)
{
    int depth = 0;
    return IsBalanced(pRoot, &amp;depth);
}

bool IsBalanced(const BinaryTreeNode* pRoot, int* pDepth)
{
    if(pRoot == nullptr)
    {
        *pDepth = 0;
        return true;
    }

    int left, right;
    if(IsBalanced(pRoot-&gt;m_pLeft, &amp;left) 
        &amp;&amp; IsBalanced(pRoot-&gt;m_pRight, &amp;right))
    {
        int diff = left - right;
        if(diff &lt;= 1 &amp;&amp; diff &gt;= -1)
        {
            *pDepth = 1 + (left &gt; right ? left : right);
            return true;
        }
    }

    return false;
}
</code></pre>
]]></content>
    </entry>
</feed>