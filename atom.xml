<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2020-02-04T00:39:36.128Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[字符串 题5:替换空格[未做出]]]></title>
        <id>https://lixin-ee.github.io//post/zi-fu-chuan-ti-5ti-huan-kong-ge-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/zi-fu-chuan-ti-5ti-huan-kong-ge-wei-zuo-chu">
        </link>
        <updated>2020-02-03T00:04:40.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
</blockquote>
<p>这道题的难点在于这是个char* ，而不是string，所以不能简单地一次循环把空格直接替换<br>
否则因为是把一个字符换成三个字符，而char* 的空间是固定的，直接空间就炸裂了<br>
所以必须先循环一遍，统计空格的数量，再分配新的空间<br>
为什么返回是void???原来是因为早已安排了额外的空间length...所以不能用sizeof....<br>
提交之后一直没通过，原来是'\0'这个家伙，所以书中的int cur=new_len;而不是int cur=new_len-1;<br>
我有个想法，平时可以将char* 中的'\0'类比string的尾后位置，因为它既不会算入size()，又可以有这个位置（str[end]）</p>
<pre><code>class Solution {
public:
	void replaceSpace(char *str,int length) {
        int ori_len=0;//记得size不会统计'\0'
        int count_space=0;
        int i=0;
        while(str[i]!='\0'){
            ++ori_len;
            if(str[i]==' ')
                ++count_space;
            ++i;
        }
        int new_len=ori_len+2*count_space;
        if(length&lt;=new_len)//注意length参数
            return;
        int cur=new_len;
        int pre=ori_len;//注意！！！这里不可以忽略'\0'这个家伙
        //重点是从后往前降低时间复杂度，不要从前往后
        while(pre&gt;=0&amp;&amp;cur&gt;pre) //注意 不是必须去到pre==0，当cur和pre重合就说明没有空格了，可以提前结束
        {
            if(str[pre]==' '){
                str[cur--]='0';
                str[cur--]='2';
                str[cur--]='%';
            }else
                str[cur--]=str[pre];
            --pre;
        }
	}
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>看到这个题目，我们首先应该想到的是原来一个空格字符，替换之后变成，％、2和0这3个字符，因此字符串会变长。如果是在原来的字符串 上进行替换，就有可能覆盖修改在该字符串后面的内存。如果是创建新的字符串并在新的字符串上进行替换，那么我们可以自己分配足够多的内存。 由于有两种不同的解决方案，我们应该向面试官问清楚，让他明确告诉我们他的需求。<br>
暴力法：<br>
最直观的做法是从头到尾扫描字符 串，每次碰到空格字符的时候进行替换。由于是把1个字符替换成3个字 符，我们必须要把空格后面所有的字符都后移2字节，否则就有两个字符 被覆盖了。<br>
假设字符串的长度是如 对每个空格字符，需要移动后面O(n)个字符, 因此对于含有O(n)个空格字符的字符串而言，总的时间效率是O(n^2)<br>
时间复杂度为O(n)的解法:<br>
先遍历一次字符串，统计出字符串中空格的总数， 并可以由此计算出替换之后的字符串的总长度。<br>
从字符串的后面开始复制和替换。首先准备两个指针：P1和P2。 P1指向原始字符串的末尾，而P2指向替换之后的字符串的末尾。接下来向前移动指针R1,逐个把它指向的字符复制到P2指向的位置，直到碰到第一个空格为止。<br>
碰到第一个空格之后， 把P1向前移动1格，在已之前插入字符串&quot;%20&quot;„由于&quot;％20&quot;的长度为3, 同时也要把P2向前移动3格<br>
当P1和P2指向同一位置，表明所有空格都已经替换完毕。（可以提前终止，不必走完整个字符串）<br>
从上面的分析中我们可以看出，所有的字符都只复制（移动）一次， 因此这个算法的时间效率是O(n),比第一个思路要快。</p>
</blockquote>
<pre><code>/*length 为字符数组str的总容量，大于或等于字符串str的实际长度*/
void ReplaceBlank(char str[], int length)
{
    if(str == nullptr &amp;&amp; length &lt;= 0)
        return;

    /*originalLength 为字符串str的实际长度*/
    int originalLength = 0;
    int numberOfBlank = 0;
    int i = 0;
    while(str[i] != '\0')
    {
        ++ originalLength;

        if(str[i] == ' ')
            ++ numberOfBlank;

        ++ i;
    }

    /*newLength 为把空格替换成'%20'之后的长度*/
    int newLength = originalLength + numberOfBlank * 2;
    if(newLength &gt; length)
        return;

    int indexOfOriginal = originalLength;
    int indexOfNew = newLength;
    while(indexOfOriginal &gt;= 0 &amp;&amp; indexOfNew &gt; indexOfOriginal)
    {
        if(str[indexOfOriginal] == ' ')
        {
            str[indexOfNew --] = '0';
            str[indexOfNew --] = '2';
            str[indexOfNew --] = '%';
        }
        else
        {
            str[indexOfNew --] = str[indexOfOriginal];
        }

        -- indexOfOriginal;
    }
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 题4:二维数组中的查找]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-er-wei-shu-zu-zhong-de-cha-zhao</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-er-wei-shu-zu-zhong-de-cha-zhao">
        </link>
        <updated>2020-02-02T00:59:11.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述<br>
在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<pre><code>class Solution {
public:
    bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) {
        if(array.empty())
               return false;
        int row,col;
        row=array.size();
        col=array[0].size();
        int cur_row,cur_col;
        cur_row=0,cur_col=col-1;
        while(cur_row&lt;row&amp;&amp;cur_col&gt;=0){
            if(target==array[cur_row][cur_col])
                return true;
            if(target&lt;array[cur_row][cur_col])
                --cur_col;
            else 
                ++cur_row;
        }
        return false;
    }
};
</code></pre>
<p>书本题解：<br>
难题是因为我们在二维数组的中间选取一个数字来和要查找的数字进行比较，这就导致下一次要查找的是两个相互重叠的区域。<br>
我们发现如下规律：首先选取数组中右上角的数字。如果该数字等于要查找的数字，则查找过程结束；如果该数字大于要查找的数字，则剔除这个数字所在的列；如果该数字小于要查找的数字, 则剔除这个数字所在的行。也就是说，如果要查找的数字不在数组的右上 角，则每一次都在数组的查找范围中剔除一行或者一列，这样每一步都可 以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。</p>
<pre><code>#include &lt;cstdio&gt;

bool Find(int* matrix, int rows, int columns, int number)
{
    bool found = false;

    if(matrix != nullptr &amp;&amp; rows &gt; 0 &amp;&amp; columns &gt; 0)
    {
        int row = 0;
        int column = columns - 1;
        while(row &lt; rows &amp;&amp; column &gt;=0)
        {
            if(matrix[row * columns + column] == number)
            {
                found = true;
                break;
            }
            else if(matrix[row * columns + column] &gt; number)
                -- column;
            else
                ++ row;
        }
    }

    return found;
}
</code></pre>
<p>我们每次都选取数组查找范围内的右上角数字。同样，我们也可以选取左下角的数字。感兴趣的读者不妨自己分析一下每次 都选取左下角数字的查找过程。但我们不能选择左上角数字或者右下角数字。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 题3:数组中重复的数字[未做出]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-shu-zu-zhong-chong-fu-de-shu-zi</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-shu-zu-zhong-chong-fu-de-shu-zi">
        </link>
        <updated>2020-02-01T03:26:23.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
</blockquote>
<p>因为数组的条件比较苛刻，所以其实有很多巧妙的解法，不修改原数组的方法是对数字的范围进行二分法，修改原数组的方法是利用数组下表一一对应的方法，上述两者都需要额外的空间，如果有额外的空间的话可以很方便地利用hashset解决问题</p>
<pre><code>class Solution {
public:
    // Parameters:
    //        numbers:     an array of integers
    //        length:      the length of array numbers
    //        duplication: (Output) the duplicated number in the array number
    // Return value:       true if the input is valid, and there are some duplications in the array number
    //                     otherwise false
    //不修改原数组的方法
    bool duplicate(int numbers[], int length, int* duplication){
        if(length==0) return -1;
        int left=0,right=length-1;
        while(left&lt;right){
            int mid=left+(right-left)/2;
            int count=0;
            for(int i=0;i&lt;length;++i)
                if(numbers[i]&gt;=left&amp;&amp;numbers[i]&lt;=mid)
                    ++count;
            if(count&gt;mid-left+1)
                right=mid;
            else
                left=mid+1;
        }
        if(left==right)
            return left;
        return -1;
    }
    
    /*
    //修改原数组的方法
    bool duplicate(int numbers[], int length, int* duplication){
        for(int i=0;i&lt;length;++i){
            while(i!=numbers[i]){
                if(numbers[i]==numbers[numbers[i]])
                    return true;
                swap(numbers[i],numbers[numbers[i]]);
            }
        }
        return false;
    }
    
    //hashset方法
    bool duplicate(int numbers[], int length, int* duplication) {
        unordered_set&lt;int&gt; num_set;
        for(int i=0;i&lt;length;++i){
            if(num_set.count(numbers[i]))
                return true;
            num_set.insert(numbers[i]);
        }
        return false;
    }
    */
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>解决这个问题的一个简单的方法是先把输入的数组排序。从排序的数组中找出重复的数字只需要从头到尾扫描排序后的数组。排序一个长度为n的数组需要O(nlogn)的时间。<br>
还可以利用哈希表来解决这个问题。从头到尾按顺序扫描数组的每个 数字，每扫描到一个数字的时候，都可以用0(1)的时间来判断哈希表里是否已经包含了该数字。如果哈希表里还没有这个数字，就把它加入哈希表。 如果哈希表里已经存在该数字，就找到一个重复的数字。这个算法的时间 复杂度是O(n)，但它提高时间效率是以一个大小为O(n)的哈希表为代价的。<br>
空间复杂度是0(1)的算法：我们注意到数组中的数字都在0〜n-1的范围内。如果这个数组中没有 重复的数字，那么当数组排序之后数字i将出现在下标为i的位置。由于数组中有重复的数字，有些位置可能存在多个数字，同时有些位置可能没有数字。<br>
现在让我们重排这个数组。从头到尾依次扫描这个数组中的每个数字。 当扫描到下标为i的数字时，首先比较这个数字(用〃，表示)是不是等于i. 如果是，则接着扫描下一个数字；如果不是，则再拿它和第加个数字进行 比较。如果它和第彻个数字相等，就找到了一个重复的数字(该数字在下 标为，和m的位置都出现了)；如果它和第m个数字不相等，就把第i个数字和第m个数字交换，把m放到属于它的位置。接下来再重复这个比较、 交换的过程，直到我们发现一个重复的数字。</p>
</blockquote>
<pre><code>bool duplicate(int numbers[], int length, int* duplication)
{
    if(numbers == nullptr || length &lt;= 0)
        return false;

    for(int i = 0; i &lt; length; ++i)
    {
        if(numbers[i] &lt; 0 || numbers[i] &gt; length - 1)
            return false;
    }

    for(int i = 0; i &lt; length; ++i)
    {
        while(numbers[i] != i)
        {
            if(numbers[i] == numbers[numbers[i]])
            {
                *duplication = numbers[i];
                return true;
            }

            // 交换numbers[i]和numbers[numbers[i]]             
            int temp = numbers[i];
            numbers[i] = numbers[temp];
            numbers[temp] = temp;
        }
    }

    return false;
}
</code></pre>
<blockquote>
<p>代码中尽管有一个两重循环，但每个数字最多只要交换两次就能找到 属于它自己的位置，因此总的时间复杂度是O(n).另外，所有的操作步骤 都是在输入数组上进行的，不需要额外分配内存，因此空间复杂度为O(1)。</p>
</blockquote>
<blockquote>
<p>接下来我们尝试避免使用O(n)的辅助空间并且不修改原数组的方法。为什么数组中会有重复的数字？假如没有重复的数字，那么在从1〜〃的范围里只有&quot;个数字。由于 数组里包含超过n个数字，所以一定包含了重复的数字。看起来在某范围 里数字的个数对解决这个问题很重要。<br>
我们把从1〜n的数字从中间的数字m分为两部分，前面一半为1〜m， 后面一半为m+1〜n。如果1〜m的数字的数目超过m,那么这一半的区间 里一定包含重复的数字；否则，另一半m+1〜n的区间里一定包含重复的数 字。我们可以继续把包含重复数字的区间一分为二，直到找到一个重复的 数字。这个过程和二分查找算法很类似，只是多了一步统计区间里数字的数目。<br>
注意是利用某个数字去对比数组中的元素，而不是用数组的元素去对比数字</p>
</blockquote>
<pre><code>int getDuplication(const int* numbers, int length)
{
    if(numbers == nullptr || length &lt;= 0)
        return -1;

    int start = 1;
    int end = length - 1;
    while(end &gt;= start)
    {
        int middle = ((end - start) &gt;&gt; 1) + start;
        int count = countRange(numbers, length, start, middle);
        if(end == start)
        {
            if(count &gt; 1)
                return start;
            else
                break;
        }

        if(count &gt; (middle - start + 1))
            end = middle;
        else
            start = middle + 1;
    }
    return -1;
}

int countRange(const int* numbers, int length, int start, int end)
{
    if(numbers == nullptr)
        return 0;

    int count = 0;
    for(int i = 0; i &lt; length; i++)
        if(numbers[i] &gt;= start &amp;&amp; numbers[i] &lt;= end)
            ++count;
    return count;
}
</code></pre>
<blockquote>
<p>上述代码按照二分查找的思路，如果输入长度为n的数组，那么函数 countRange将被调用O(logn)次，每次需要O(n)的时间，因此总的时间复杂 度是O(nlogn)，空间复杂度为O(1)。和最前面提到的需要O(n)的辅助空间 的算法相比，这种算法相当于以时间换空间。<br>
需要指出的是，这种算法不能保证找出所有重复的数字。</p>
</blockquote>
<blockquote>
<p>从上述分析中我们可以看出，如果面试官提出不同的功能要求(找出任意一个重复的数字、找出所有重复的数字)或者性能要求(时间效率优先、空间效率优先)，那么我们最终选取的算法也将不同。这也说明在面试中和面试官交流的重要性，我们一定要在动手写代码之前弄清楚面试官的需求。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math 172. 阶乘后的零[简单]]]></title>
        <id>https://lixin-ee.github.io//post/math-172-jie-cheng-hou-de-ling-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/math-172-jie-cheng-hou-de-ling-jian-dan">
        </link>
        <updated>2020-01-31T02:23:41.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个整数 n，返回 n! 结果尾数中零的数量。<br>
示例 1:<br>
输入: 3<br>
输出: 0<br>
解释: 3! = 6, 尾数中没有零。<br>
示例 2:<br>
输入: 5<br>
输出: 1<br>
解释: 5! = 120, 尾数中有 1 个零.<br>
说明: 你算法的时间复杂度应为 O(log n) 。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/factorial-trailing-zeroes<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>唯有 5的倍数* 偶数 能导致出现0<br>
一开始我是直接统计5的倍数的数字有多少个，因为偶数肯定比5的倍数的数字多，所以不用担心找不到偶数，所以直接res=n/5;<br>
然后提交错误，发现需要注意的是 5的次方会导致0增加 比如25有两个5，125有三个5.<br>
然后我发现一个特点，n/5之后如果大于5，那就等于说肯定有一个数是5的幂次，因为比如5，10，15，20，25，30除以5得到的结果分别是1，2，3，4，5，6，可以看到大于5的话说明还有5的倍数，大于125同理，除以两次5之后还是有个5，所以就继续除以5并将个数加到res里面<br>
这个就相当于计算n最接近的5的次方，那刚好时间复杂度就是O（logn）了，和题目暗示的一致<br>
题解说得比我更清楚，可以仔细看看</p>
<pre><code>class Solution {
public:
    int trailingZeroes(int n) {
        int res=0;
        while(n&gt;=5){
            res+=n/5;
            n/=5;
        }
        return res;
    }
};
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>解法一<br>
之前小红书面试的时候碰到的一道题，没想到又是 leetcode 的原题。这种没有通用解法的题，完全依靠于对题目的分析理解了，自己当时也是在面试官的提示下慢慢出来的，要是想不到题目的点，还是比较难做的。<br>
首先肯定不能依赖于把阶乘算出来再去判断有多少个零了，因为阶乘很容易就溢出了，所以先一步一步理一下思路吧。<br>
首先末尾有多少个 0 ，只需要给当前数乘以一个 10 就可以加一个 0。<br>
再具体对于 5!，也就是 5 * 4 * 3 * 2 * 1 = 120，我们发现结果会有一个 0，原因就是 2 和 5 相乘构成了一个 10。而对于 10 的话，其实也只有 2 * 5 可以构成，所以我们只需要找有多少对 2/5。<br>
把每个乘数再稍微分解下，看一个例子。<br>
11! = 11 * 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1 = 11 * (2 * 5) * 9 * (4 * 2) * 7 * (3 * 2) * (1 * 5) * (2 * 2) * 3 * (1 * 2) * 1<br>
对于含有 2 的因子的话是 1 * 2, 2 * 2, 3 * 2, 4 * 2 ...<br>
对于含有 5 的因子的话是 1 * 5, 2 * 5...<br>
含有 2 的因子每两个出现一次，含有 5 的因子每 5 个出现一次，所有 2 出现的个数远远多于 5，换言之找到一个 5，一定能找到一个 2 与之配对。所以我们只需要找有多少个 5。<br>
直接的，我们只需要判断每个累乘的数有多少个 5 的因子即可。</p>
</blockquote>
<pre><code>public int trailingZeroes(int n) {
    int count = 0;
    for (int i = 1; i &lt;= n; i++) {
        int N = i;
        while (N &gt; 0) {
            if (N % 5 == 0) {
                count++;
                N /= 5;
            } else {
                break;
            }
        }
    }
    return count;

}
</code></pre>
<blockquote>
<p>但发生了超时，我们继续分析。<br>
对于一个数的阶乘，就如之前分析的，5 的因子一定是每隔 5 个数出现一次，也就是下边的样子。<br>
n! = 1 * 2 * 3 * 4 * (1 * 5) * ... * (2 * 5) * ... * (3 * 5) *... * n<br>
因为每隔 5 个数出现一个 5，所以计算出现了多少个 5，我们只需要用 n/5 就可以算出来。<br>
但还没有结束，继续分析。<br>
... * (1 * 5) * ... * (1 * 5 * 5) * ... * (2 * 5 * 5) * ... * (3 * 5 * 5) * ... * n<br>
每隔 25 个数字，出现的是两个 5，所以除了每隔 5 个数算作一个 5，每隔 25 个数，还需要多算一个 5。<br>
也就是我们需要再加上 n / 25 个 5。<br>
同理我们还会发现每隔 5 * 5 * 5 = 125 个数字，会出现 3 个 5，所以我们还需要再加上 n / 125 。<br>
综上，规律就是每隔 5 个数，出现一个 5，每隔 25 个数，出现 2 个 5，每隔 125 个数，出现 3 个 5... 以此类推。<br>
最终 5 的个数就是 n / 5 + n / 25 + n / 125 ...<br>
写程序的话，如果直接按照上边的式子计算，分母可能会造成溢出。所以算 n / 25 的时候，我们先把 n 更新，n = n / 5，然后再计算 n / 5 即可。后边的同理。</p>
</blockquote>
<pre><code>public int trailingZeroes(int n) {
    int count = 0;
    while (n &gt; 0) {
        count += n / 5;
        n = n / 5;
    }
    return count;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 167. 两数之和 II - 输入有序数组[简单]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-167-liang-shu-zhi-he-ii-shu-ru-you-xu-shu-zu-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-167-liang-shu-zhi-he-ii-shu-ru-you-xu-shu-zu-jian-dan">
        </link>
        <updated>2020-01-30T07:14:53.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。<br>
函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。<br>
说明:<br>
返回的下标值（index1 和 index2）不是从零开始的。<br>
你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。<br>
示例:<br>
输入: numbers = [2, 7, 11, 15], target = 9<br>
输出: [1,2]<br>
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题其实没什么特别的，无非就是双指针移动<br>
但是重点在于从这题开始，要使用所学到的注意事项了，特别是muduo和effective c++中的建议和要求，比如变量命名，又比如使用const变量</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) {
        vector&lt;int&gt;::const_iterator min=numbers.cbegin();//注意指向常量的迭代器const_iterator和常量迭代器的区别const iterator ，同时还要注意cbegin cend 和 begin end 的区别
        vector&lt;int&gt;::const_iterator max=numbers.cend()-1;//又忘了end指向尾后位置了，还是得每天练练手
        while(min&lt;max){  //注意只有随机迭代器可以用关系运算符
           //if(*max+*min==target) //这里其实可以做减法，防止溢出
             if(target-*max==*min)   
                return vector&lt;int&gt;({min-numbers.cbegin()+1,max-numbers.cbegin()+1});
            //else if(*max+*min&lt;target)
            else if(target-*max&gt;*min)
                ++min;
            else
                --max;
        }
        return vector&lt;int&gt;();
    }
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>方法 1：双指针<br>
算法<br>
我们可以使用 两数之和 的解法在 O(n^2)时间 O(1) 空间暴力解决，也可以用哈希表在 O(n) 时间和O(n) 空间内解决。然而，这两种方法都没有用到输入数组已经排序的性质，我们可以做得更好。<br>
我们使用两个指针，初始分别位于第一个元素和最后一个元素位置，比较这两个元素之和与目标值的大小。如果和等于目标值，我们发现了这个唯一解。如果比目标值小，我们将较小元素指针增加一。如果比目标值大，我们将较大指针减小一。移动指针后重复上述比较知道找到答案。<br>
假设 [... , a, b, c, ... , d, e, f, …]是已经升序排列的输入数组，并且元素 b,e 是唯一解。因为我们从左到右移动较小指针，从右到左移动较大指针，总有某个时刻存在一个指针移动到b 或 e 的位置。不妨假设小指针先移动到了元素 b ，这是两个元素的和一定比目标值大，根据我们的算法，我们会向左移动较大指针直至获得结果。<br>
C++</p>
</blockquote>
<pre><code>class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) {
        int low = 0, high = numbers.size() - 1;
        while (low &lt; high) {
            int sum = numbers[low] + numbers[high];
            if (sum == target)
                return {low + 1, high + 1};
            else if (sum &lt; target)
                ++low;
            else
                --high;
        }
        return {-1, -1};
    }
};
</code></pre>
<blockquote>
<p>是否需要考虑 numbers[low] + numbers[high]numbers[low]+numbers[high] 溢出呢？答案是不需要。因为即使两个元素之和溢出了，因为只存在唯一解，所以一定会先访问到答案。<br>
复杂度分析<br>
时间复杂度：O(n)。每个元素最多被访问一次，共有 n 个元素。<br>
空间复杂度：O(1)。只是用了两个指针。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 1.两数之和[简单][未做出]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-1liang-shu-zhi-he-jian-dan-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-1liang-shu-zhi-he-jian-dan-wei-zuo-chu">
        </link>
        <updated>2020-01-29T07:47:55.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<br>
你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。<br>
示例:<br>
给定 nums = [2, 7, 11, 15], target = 9<br>
因为 nums[0] + nums[1] = 2 + 7 = 9<br>
所以返回 [0, 1]<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/two-sum<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>手贱去翻评论看到用map，然后想到一个不错的方法，就是用哈希表存储一对值，key是target-nums[i]或者nums[i]，value则是i，那么如果在后面遇到适合的key时就可以直接返回了<br>
hhh还真就是最佳题解</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        unordered_map&lt;int,int&gt; res_val;
        int len=nums.size();
        for(int i=0;i&lt;len;++i){
            int res= target-nums[i];
            if(res_val.count(res))
                return vector&lt;int&gt;({res_val[res],i});
            res_val.insert({nums[i],i});   
        }
        return vector&lt;int&gt;();
    }
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>方法一：暴力法<br>
暴力法很简单，遍历每个元素 x，并查找是否存在一个值与target−x 相等的目标元素。</p>
</blockquote>
<pre><code>Java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        for (int i = 0; i &lt; nums.length; i++) {
            for (int j = i + 1; j &lt; nums.length; j++) {
                if (nums[j] == target - nums[i]) {
                    return new int[] { i, j };
                }
            }
        }
        throw new IllegalArgumentException(&quot;No two sum solution&quot;);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(n^2)<br>
对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费O(n) 的时间。因此时间复杂度为 O(n^2)。<br>
空间复杂度：O(1)。</p>
</blockquote>
<blockquote>
<p>方法二：两遍哈希表<br>
为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。<br>
通过以空间换取速度的方式，我们可以将查找时间从 O(n) 降低到 O(1)。哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)。<br>
一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i] 本身！</p>
</blockquote>
<pre><code>Java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; nums.length; i++) {
            map.put(nums[i], i);
        }
        for (int i = 0; i &lt; nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) {
                return new int[] { i, map.get(complement) };
            }
        }
        throw new IllegalArgumentException(&quot;No two sum solution&quot;);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(n)，<br>
我们把包含有 n 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1) ，所以时间复杂度为 O(n)。<br>
空间复杂度：O(n)，<br>
所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 nn 个元素。</p>
</blockquote>
<blockquote>
<p>方法三：一遍哈希表<br>
事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。</p>
</blockquote>
<pre><code>Java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement)) {
                return new int[] { map.get(complement), i };
            }
            map.put(nums[i], i);
        }
        throw new IllegalArgumentException(&quot;No two sum solution&quot;);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(n)，<br>
我们只遍历了包含有 nn 个元素的列表一次。在表中进行的每次查找只花费 O(1) 的时间。<br>
空间复杂度：O(n)，<br>
所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 n 个元素。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 86. 分隔链表[中等]]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-86-fen-ge-lian-biao-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-86-fen-ge-lian-biao-zhong-deng">
        </link>
        <updated>2020-01-28T02:35:39.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。<br>
你应当保留两个分区中每个节点的初始相对位置。<br>
示例:<br>
输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3<br>
输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/partition-list<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题描述的意思还是挺有趣的<br>
我想到的方法是类似于归并排序，不过反过来把一个链表分成两个链表</p>
<p>实现过程中不断地超时，但是我用了断点也没发现问题<br>
后来发现是return的问题，似乎打印节点时超时了，才发现原来是larger链表没有收尾，导致形成了一个环，5-&gt;2-&gt;4-&gt;3-&gt;5、<br>
所以链表题一定要注意收尾！！！</p>
<pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        ListNode *smaller=new ListNode(0);
        ListNode *larger=new ListNode(0);
        ListNode *cur=head,*cur_s=smaller,*cur_l=larger;
        while(cur){
            if(cur-&gt;val&lt;x){
                cur_s-&gt;next=cur;
                cur=cur-&gt;next;
                cur_s=cur_s-&gt;next;
            }else{
                cur_l-&gt;next=cur;
                cur=cur-&gt;next;
                cur_l=cur_l-&gt;next;
            }
        }
        cur_l-&gt;next=NULL;//链表题一定要注意收尾！！
        cur_s-&gt;next=larger-&gt;next;
        return smaller-&gt;next;
    }
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>本题要求我们改变链表结构，使得值小于 x的元素，位于值大于等于x元素的前面。这实质上意味着在改变后的链表中有某个点，在该点之前的元素全部小于x ，该点之后的元素全部 大于等于x。<br>
我们将这个点记为JOINT。<br>
对该问题的逆向工程告诉我们，如果我们在JOINT将改后链表拆分，我们会得到两个更小的链表，其中一个包括全部值小于x的元素，另一个包括全部值大于x的元素。在解法中，我们的主要目的是创建这两个链表，并将它们连接。</p>
</blockquote>
<blockquote>
<p>双指针法：<br>
直觉<br>
我们可以用两个指针before 和 after 来追踪上述的两个链表。两个指针可以用于分别创建两个链表，然后将这两个链表连接即可获得所需的链表。<br>
算法<br>
1.初始化两个指针 before 和 after。在实现中，我们将两个指针初始化为哑 ListNode。这有助于减少条件判断。<br>
2.利用head指针遍历原链表。<br>
3.若head 指针指向的元素值小于 x，该节点应当是 before 链表的一部分。因此我们将其移到 before 中。<br>
4.否则，该节点应当是after 链表的一部分。因此我们将其移到 after 中<br>
5.遍历完原有链表的全部元素之后，我们得到了两个链表 before 和 after。原有链表的元素或者在before 中或者在 after 中，这取决于它们的值。<br>
<em><code>注意:</code> 由于我们从左到右遍历了原有链表，故两个链表中元素的相对顺序不会发生变化。另外值得注意的是，在图中我们完好地保留了原有链表。事实上，在算法实现中，我们将节点从原有链表中移除，并将它们添加到别的链表中。我们没有使用任何额外的空间，只是将原有的链表元素进行移动。</em><br>
6.现在，可以将 before 和 after 连接，组成所求的链表。<br>
为了算法实现更容易，我们使用了哑结点初始化。不能让哑结点成为返回链表中的一部分，因此在组合两个链表时需要向前移动一个节点。</p>
</blockquote>
<pre><code>class Solution {
    public ListNode partition(ListNode head, int x) {

        // before and after are the two pointers used to create the two list
        // before_head and after_head are used to save the heads of the two lists.
        // All of these are initialized with the dummy nodes created.
        ListNode before_head = new ListNode(0);
        ListNode before = before_head;
        ListNode after_head = new ListNode(0);
        ListNode after = after_head;

        while (head != null) {

            // If the original list node is lesser than the given x,
            // assign it to the before list.
            if (head.val &lt; x) {
                before.next = head;
                before = before.next;
            } else {
                // If the original list node is greater or equal to the given x,
                // assign it to the after list.
                after.next = head;
                after = after.next;
            }

            // move ahead in the original list
            head = head.next;
        }

        // Last node of &quot;after&quot; list would also be ending node of the reformed list
        after.next = null;

        // Once all the nodes are correctly assigned to the two lists,
        // combine them to form a single list which would be returned.
        before.next = after_head.next;

        return before_head.next;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度: O(N)，其中NN是原链表的长度，我们对该链表进行了遍历。<br>
空间复杂度: O(1)，我们没有申请任何新空间。值得注意的是，我们只移动了原有的结点，因此没有使用任何额外空间。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 221. 最大正方形[中等][未做出]]]></title>
        <id>https://lixin-ee.github.io//post/dong-tai-gui-hua-221-zui-da-zheng-fang-xing-zhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/dong-tai-gui-hua-221-zui-da-zheng-fang-xing-zhong-deng-wei-zuo-chu">
        </link>
        <updated>2020-01-27T03:27:38.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。<br>
示例:<br>
输入:<br>
1 0 1 0 0<br>
1 0 1 1 1<br>
1 1 1 1 1<br>
1 0 0 1 0<br>
输出: 4<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/maximal-square<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>【未做出】<br>
偷看标签是动态规划hhh 实在是太累了</p>
<p>实现的过程中一开始我想着用matrix直接初始化squares，结果！才发现matrix是char不是int，太6了吧<br>
然后记得是必须取三者最小值（本来想用&amp;&amp;的，发现必须累加。。。）</p>
<p>然后优化一下空间，因为只用到了上一列和当前列的元素<br>
实现过程中犯了一些小错误 1.忘了判断matrix[i][j]<mark>'1'和</mark>'0'来更新值，前者导致完全错误，后者导致cur残留错误 2。pre_squares=cur_squares;的更新差点放在j的内循环了，必须放在外循环！！！</p>
<pre><code>class Solution {
public:
    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) {
        if(matrix.empty()) return 0;
        int len=matrix.size(),wid=matrix[0].size();
        vector&lt;int&gt; cur_squares(wid,0),pre_squares(wid,0);
        int max_square=0;
        for(int i=0;i&lt;len;++i){
            for(int j=0;j&lt;wid;++j){
                if(i==0||j==0)
                    cur_squares[j]=matrix[i][j]-'0';
                else if(matrix[i][j]=='1')//别漏了判断是否等于1
                    cur_squares[j]=min(min(pre_squares[j],pre_squares[j-1]),cur_squares[j-1])+1;
                else
                    cur_squares[j]=0;
                max_square=max(max_square,cur_squares[j]); 
                
            }
            pre_squares=cur_squares;//这个的位置很重要，别放在内循环里面了
            //cur_squares=vector&lt;int&gt;(wid,0);//没有判断matrix[i][j]=='0'的情况来更新cur_squares[j]=0;的话必须更新cur，否则残留的cur=1会影响结果
        }
        return max_square*max_square;
    }    
    /*
    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) {
        if(matrix.size()==0) return 0;
        int len=matrix.size(),wid=matrix[0].size();
        vector&lt;vector&lt;int&gt;&gt; squares(len,vector&lt;int&gt;(wid,0));
        int max_square=0;
        for(int i=0;i&lt;len;++i)
            for(int j=0;j&lt;wid;++j){
                if(i==0||j==0)
                    squares[i][j]=matrix[i][j]-'0';
                else if(matrix[i][j]=='1')
                    squares[i][j]=min(min(squares[i-1][j],squares[i][j-1]),squares[i-1][j-1])+1;
                max_square=max(max_square,squares[i][j]);       
            }
        return max_square*max_square;     
    }
    */
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>概要<br>
在给定m×n 的矩阵中，我们需要找到在矩阵中由 1 组成的最大正方形。<br>
换句话说，我们需要在矩阵中找到由 1 组成最大连通的正方形，并返回其面积。<br>
解决方法<br>
方法一：暴力法<br>
最简单的方法是找出矩阵中所有可以形成的 1 正方形。现在的问题是如何做到这一点？<br>
我们用一个变量去来记录迄今为止发现的最大正方形的边长，以及用一个变量记录当前正方形的大小，两个变量都初始化为 0；<br>
从矩阵的左上角开始搜索 1，找到 0 不需要做任何操作，只要找到 1 我们就试图找到由 1 组成的最大正方形；<br>
为此我们向右和向下移动，临时增加列索引和行索引，然后用标志标记该行列是否全都为 1；<br>
如果全都为 1，则继续检索行列，如果找到 0，便停止移动，更新最大正方形的边长。然后从最初发现 1 的元素旁边遍历矩阵，直到矩阵的所有元素都被遍历。<br>
Java</p>
</blockquote>
<pre><code>public class Solution {
    public int maximalSquare(char[][] matrix) {
        int rows = matrix.length, cols = rows &gt; 0 ? matrix[0].length : 0;
        int maxsqlen = 0;
        for (int i = 0; i &lt; rows; i++) {
            for (int j = 0; j &lt; cols; j++) {
                if (matrix[i][j] == '1') {
                    int sqlen = 1;
                    boolean flag = true;
                    while (sqlen + i &lt; rows &amp;&amp; sqlen + j &lt; cols &amp;&amp; flag) {
                        for (int k = j; k &lt;= sqlen + j; k++) {
                            if (matrix[i + sqlen][k] == '0') {
                                flag = false;
                                break;
                            }
                        }
                        for (int k = i; k &lt;= sqlen + i; k++) {
                            if (matrix[k][j + sqlen] == '0') {
                                flag = false;
                                break;
                            }
                        }
                        if (flag)
                            sqlen++;
                    }
                    if (maxsqlen &lt; sqlen) {
                        maxsqlen = sqlen;
                    }
                }
            }
        }
        return maxsqlen * maxsqlen;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O((mn) ^2)，最坏情况下，我们需要遍历整个矩阵寻找每个 1。<br>
空间复杂度：O(1)，没有使用额外的空间。</p>
</blockquote>
<blockquote>
<p>方法二：动态规划<br>
我们用一个例子来解释这个方法：<br>
0 1 1 1 0<br>
1 1 1 1 1<br>
0 1 1 1 1<br>
0 1 1 1 1<br>
0 0 1 1 1<br>
我们用 0 初始化另一个矩阵 dp，维数和原始矩阵维数相同；<br>
dp(i,j) 表示的是由 1 组成的最大正方形的边长；<br>
从 (0,0) 开始，对原始矩阵中的每一个 1，我们将当前元素的值更新为<br>
dp(i, j)=min(dp(i−1, j), dp(i−1, j−1), dp(i, j−1))+1<br>
我们还用一个变量记录当前出现的最大边长，这样遍历一次，找到最大的正方形边长maxsqlen，那么结果就是 maxsqlen^2 。</p>
</blockquote>
<pre><code>public class Solution {
    public int maximalSquare(char[][] matrix) {
        int rows = matrix.length, cols = rows &gt; 0 ? matrix[0].length : 0;
        int[][] dp = new int[rows + 1][cols + 1];
        int maxsqlen = 0;
        for (int i = 1; i &lt;= rows; i++) {
            for (int j = 1; j &lt;= cols; j++) {
                if (matrix[i-1][j-1] == '1'){
                    dp[i][j] = Math.min(Math.min(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1]) + 1;
                    maxsqlen = Math.max(maxsqlen, dp[i][j]);
                }
            }
        }
        return maxsqlen * maxsqlen;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(mn)。<br>
空间复杂度：O(mn)，用了一个大小相同的矩阵 dp。</p>
</blockquote>
<blockquote>
<p>方法三：动态规划优化<br>
在前面的动态规划解法中，计算第i行（row）的 dp 方法中，我们只使用了上一个元素和第 (i-1) 行，因此我们不需要二维 dp 矩阵，因为一维 dp 足以满足此要求。<br>
我们扫描一行原始矩阵元素时，我们根据公式：dp[j]=min(dp[j-1],dp[j],prev) 更新数组 dp，其中 prev 指的是 dp[j-1]，对于每一行，我们重复相同过程并在 dp 矩阵中更新元素。</p>
</blockquote>
<pre><code>public class Solution {
    public int maximalSquare(char[][] matrix) {
        int rows = matrix.length, cols = rows &gt; 0 ? matrix[0].length : 0;
        int[] dp = new int[cols + 1];
        int maxsqlen = 0, prev = 0;
        for (int i = 1; i &lt;= rows; i++) {
            for (int j = 1; j &lt;= cols; j++) {
                int temp = dp[j];
                if (matrix[i - 1][j - 1] == '1') {
                    dp[j] = Math.min(Math.min(dp[j - 1], prev), dp[j]) + 1;
                    maxsqlen = Math.max(maxsqlen, dp[j]);
                } else {
                    dp[j] = 0;
                }
                prev = temp;
            }
        }
        return maxsqlen * maxsqlen;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(mn)。<br>
空间复杂度：O(n)，使用了一个一维数组 dp。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 968. 监控二叉树 [困难][未做出]]]></title>
        <id>https://lixin-ee.github.io//post/shu-968-jian-kong-er-cha-shu-kun-nan-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/shu-968-jian-kong-er-cha-shu-kun-nan-wei-zuo-chu">
        </link>
        <updated>2020-01-26T01:43:07.000Z</updated>
        <content type="html"><![CDATA[<p>示例 1：<br>
<img src="https://lixin-ee.github.io//post-images/1580003119532.png" alt=""><br>
示例 2：<br>
<img src="https://lixin-ee.github.io//post-images/1580003651384.png" alt=""></p>
<blockquote>
<p>给定一个二叉树，我们在树的节点上安装摄像头。<br>
节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。<br>
计算监控树的所有节点所需的最小摄像头数量。<br>
示例 1：<br>
输入：[0,0,null,0,0]<br>
输出：1<br>
解释：如图所示，一台摄像头足以监控所有节点。<br>
示例 2：<br>
输入：[0,0,null,0,null,0,null,null,0]<br>
输出：2<br>
解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。<br>
提示：<br>
给定树的节点数的范围是 [1, 1000]。<br>
每个节点的值都是 0。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/binary-tree-cameras<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>一开始用的是迭代的奇偶层次法，提交了才发现挺笨的，因为如果是6层，每层1个节点的话，其实只需要在2和5层装就行了，不需要136或者245<br>
思考了一下 还是得靠动态规划</p>
<p>一开始以为是类似入室盗窃那道题的两种状态，看了题解发现三种状态更加好，然后注意这种父节点的值依赖于子节点的题是无法使用迭代法的</p>
<p>实现过程中发现头节点需要单独处理，因为它没有父节点可以监控他，看了题解 发现可以装载一个虚拟头节点（注意 我们所需要的只是监控的数量而不是节点，所以ehead的监控可以算到root的头上，比如root是0，需要ehead是1，此时虽然root是被监控，但是实际上ehead的监控算到cur头上，所以最终返回的数量是一致的）</p>
<p>我的实现用了三种状态 1-监控态 0-未被监控态 -1-被监控态 其中NULL节点为-1态，意味着不需要处理 叶子节点为0，因为我们总是希望叶子节点的父节点来监控以取得最大收益（父节点至少可以监控两个，叶子节点只能监控一个），当然这也是导致root需要ehead的原因 否则root自身就是叶节点返回0的话就木大了</p>
<p>递归逻辑中，必须优先处理的就是子节点为0的情况，此时必须监控。然后就是如果叶节点都不为0而且有个监控的话，当前节点就可以返回-1了，其他情况统统返回0（比如叶子节点都是被监控的，此时自己加监控收益低，还是给父节点去考虑），注意此处不能判断叶子节点都为-1，否则会因为情况判断不完全而产生不返回的错误</p>
<p>然后在实现的时候遇到一个啼笑皆非的问题，int right=preorder(cur-&gt;right,res);这行代码中cur-&gt;right写成了cur-right，本来应该报错符号的，但是恰好定义了int的right，导致识别为减号，报错内存溢出。。。</p>
<pre><code>class Solution {
public:
    int minCameraCover(TreeNode* root) {
        if(root==NULL) return 0;
        int res=0;
        TreeNode* ehead=new TreeNode(0);
        ehead-&gt;left=root;
        preorder(ehead,res);
        return res;
    }
    
    int preorder(TreeNode *cur,int &amp;res){
        if(cur==NULL)
            return -1;
        if(cur-&gt;left==NULL&amp;&amp;cur-&gt;right==NULL){
            return 0;
        }
        int left=preorder(cur-&gt;left,res);
        int right=preorder(cur-&gt;right,res);
        if(left==0||right==0){
            ++res;
            return 1;
        }
        if(left==1||right==1)
            return -1;
        //if(left==-1&amp;&amp;right==-1)
            return 0;    
    }
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>当遍历到一个节点时，我们可以定义三种状态：<br>
0 ： 初始状态，如果节点为null可以返回，也就是不影响其他节点，当两个节点都是0时，我们直接设置当前节点为未监控状态<br>
1： 未监控状态，如果子节点含有该状态，则此节点必须添加摄像头，同时返回当前状态为监控态<br>
2： 监控态，表明此节点已经被监控，当子节点为此状态时，父节点不需要添加摄像头，可以返回初始态</p>
</blockquote>
<pre><code>private int dfs(TreeNode node){
        if (node == null) return 0;

        int l = dfs(node.left);
        int r = dfs(node.right);

        if (l + r == 0)  
            return 1;
        else if (l == 1 || r == 1) {
            cameras ++; return 2;
        } else  
            return 0;
    }
</code></pre>
<blockquote>
<p>当调用时，有一个小技巧，我们需要为传入的根节点添加一个虚拟的头，因为向上遍历时，根节点的监控状态我们无法保证，所以添加一个虚拟头可以简化编程。</p>
</blockquote>
<pre><code>public int minCameraCover(TreeNode root) {
        TreeNode dummyHead = new TreeNode(0);
        dummyHead.left = root;
        dfs(dummyHead);
        return cameras;
    }
</code></pre>
<blockquote>
<p>时间复杂度O(N)<br>
空间复杂度如果不算递归的隐式调用栈，为O(1),否则为O(h),h为树的高度。</p>
</blockquote>
<p>网友题解里面的判断条件用了加法，虽然不太直观，但是非常巧妙</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 628. 三个数的最大乘积[简单]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-628-san-ge-shu-de-zui-da-cheng-ji-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-628-san-ge-shu-de-zui-da-cheng-ji-jian-dan">
        </link>
        <updated>2020-01-25T03:02:35.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。<br>
示例 1:<br>
输入: [1,2,3]<br>
输出: 6<br>
示例 2:<br>
输入: [1,2,3,4]<br>
输出: 24<br>
注意:<br>
给定的整型数组长度范围是[3,104]，数组中所有的元素范围是[-1000, 1000]。<br>
输入的数组中任意三个数的乘积不会超出32位有符号整数的范围。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/maximum-product-of-three-numbers<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>比较棘手的就是负数了，如果负数纳入考虑的话，就必须是两个负数。。。<br>
比较智障的方法就是保存五个数，用贪心法来更新hhh<br>
突然发现不太对劲，因为每次更新都要去除一个最小值，那么就得不断排序更新</p>
<p>我一开始还是实现比较笨的方法<br>
另外一个问题就是如何确定有没有被初始化，如果是数组全是负数的话结果还是负数，但是我一开始返回的结果是0，因为值都初始化为0了<br>
于是打算改成用set来管理 让set自动排序<br>
算了直接用sort吧</p>
<p>看了题解后发现第一个方法还是最优解，只是赋值不能是0，必须是最大最小值，然后判断起来比较麻烦 而且不能像我那样区分开负数和正数，比如1，2，3中，1应该也付给min_1</p>
<pre><code>class Solution {
public:
    int maximumProduct(vector&lt;int&gt;&amp; nums){
        int max_1=INT_MIN,max_2=INT_MIN,max_3=INT_MIN;
        int min_1=INT_MAX,min_2=INT_MAX;
        for(auto i:nums){
            if(i&gt;max_1)
                swap(max_3,max_2),swap(max_2,max_1),max_1=i;
            else if(i&gt;max_2)
                swap(max_3,max_2),max_2=i;
            else if(i&gt;max_3)
                max_3=i;
            if(i&lt;min_1)
                swap(min_2,min_1),min_1=i;
            else if(i&lt;min_2)
                min_2=i;
        }
        return max_1*max_2*max_3&gt;max_1*min_1*min_2?max_1*max_2*max_3:max_1*min_1*min_2;
    }
		/*//排序法
    int maximumProduct(vector&lt;int&gt;&amp; nums) {
        int len=nums.size();
        sort(nums.begin(),nums.end());
        return nums[len-1]*nums[len-2]*nums[len-3]&gt;nums[len-1]*nums[0]*nums[1]?nums[len-1]*nums[len-2]*nums[len-3]:nums[len-1]*nums[0]*nums[1];

    }
    */
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>方法一：排序<br>
我们将数组进行升序排序，如果数组中所有的元素都是非负数，那么答案即为最后三个元素的乘积。<br>
如果数组中出现了负数，那么我们还需要考虑乘积中包含负数的情况，显然选择最小的两个负数和最大的一个正数是最优的，即为前两个元素与最后一个元素的乘积。<br>
上述两个结果中的较大值就是答案。注意我们可以不用判断数组中到底有没有正数，0 或者负数，因为上述两个结果实际上已经包含了所有情况，最大值一定在其中。</p>
</blockquote>
<pre><code>Java
public class Solution {
    public int maximumProduct(int[] nums) {
        Arrays.sort(nums);
        return Math.max(nums[0] * nums[1] * nums[nums.length - 1], nums[nums.length - 1] * nums[nums.length - 2] * nums[nums.length - 3]);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(NlogN)，其中 N 是数组的长度。<br>
空间复杂度：O(logN)，为排序使用的空间。</p>
</blockquote>
<blockquote>
<p>方法二：线性扫描<br>
在方法一中，我们实际上只要求出数组中最大的三个数以及最小的两个数，因此我们可以不用排序，用线性扫描直接得出这五个数。</p>
</blockquote>
<pre><code>Java
public class Solution {
    public int maximumProduct(int[] nums) {
        int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;
        int max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE, max3 = Integer.MIN_VALUE;
        for (int n: nums) {
            if (n &lt;= min1) {
                min2 = min1;
                min1 = n;
            } else if (n &lt;= min2) {     // n lies between min1 and min2
                min2 = n;
            }
            if (n &gt;= max1) {            // n is greater than max1, max2 and max3
                max3 = max2;
                max2 = max1;
                max1 = n;
            } else if (n &gt;= max2) {     // n lies betweeen max1 and max2
                max3 = max2;
                max2 = n;
            } else if (n &gt;= max3) {     // n lies betwen max2 and max3
                max3 = n;
            }
        }
        return Math.max(min1 * min2 * max1, max1 * max2 * max3);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(N)。<br>
空间复杂度：O(1)。</p>
</blockquote>
]]></content>
    </entry>
</feed>