<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2020-01-31T03:15:01.462Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[Math 172. 阶乘后的零[简单]]]></title>
        <id>https://lixin-ee.github.io//post/math-172-jie-cheng-hou-de-ling-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/math-172-jie-cheng-hou-de-ling-jian-dan">
        </link>
        <updated>2020-01-31T02:23:41.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个整数 n，返回 n! 结果尾数中零的数量。<br>
示例 1:<br>
输入: 3<br>
输出: 0<br>
解释: 3! = 6, 尾数中没有零。<br>
示例 2:<br>
输入: 5<br>
输出: 1<br>
解释: 5! = 120, 尾数中有 1 个零.<br>
说明: 你算法的时间复杂度应为 O(log n) 。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/factorial-trailing-zeroes<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>唯有 5的倍数* 偶数 能导致出现0<br>
一开始我是直接统计5的倍数的数字有多少个，因为偶数肯定比5的倍数的数字多，所以不用担心找不到偶数，所以直接res=n/5;<br>
然后提交错误，发现需要注意的是 5的次方会导致0增加 比如25有两个5，125有三个5.<br>
然后我发现一个特点，n/5之后如果大于5，那就等于说肯定有一个数是5的幂次，因为比如5，10，15，20，25，30除以5得到的结果分别是1，2，3，4，5，6，可以看到大于5的话说明还有5的倍数，大于125同理，除以两次5之后还是有个5，所以就继续除以5并将个数加到res里面<br>
这个就相当于计算n最接近的5的次方，那刚好时间复杂度就是O（logn）了，和题目暗示的一致<br>
题解说得比我更清楚，可以仔细看看</p>
<pre><code>class Solution {
public:
    int trailingZeroes(int n) {
        int res=0;
        while(n&gt;=5){
            res+=n/5;
            n/=5;
        }
        return res;
    }
};
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>解法一<br>
之前小红书面试的时候碰到的一道题，没想到又是 leetcode 的原题。这种没有通用解法的题，完全依靠于对题目的分析理解了，自己当时也是在面试官的提示下慢慢出来的，要是想不到题目的点，还是比较难做的。<br>
首先肯定不能依赖于把阶乘算出来再去判断有多少个零了，因为阶乘很容易就溢出了，所以先一步一步理一下思路吧。<br>
首先末尾有多少个 0 ，只需要给当前数乘以一个 10 就可以加一个 0。<br>
再具体对于 5!，也就是 5 * 4 * 3 * 2 * 1 = 120，我们发现结果会有一个 0，原因就是 2 和 5 相乘构成了一个 10。而对于 10 的话，其实也只有 2 * 5 可以构成，所以我们只需要找有多少对 2/5。<br>
把每个乘数再稍微分解下，看一个例子。<br>
11! = 11 * 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1 = 11 * (2 * 5) * 9 * (4 * 2) * 7 * (3 * 2) * (1 * 5) * (2 * 2) * 3 * (1 * 2) * 1<br>
对于含有 2 的因子的话是 1 * 2, 2 * 2, 3 * 2, 4 * 2 ...<br>
对于含有 5 的因子的话是 1 * 5, 2 * 5...<br>
含有 2 的因子每两个出现一次，含有 5 的因子每 5 个出现一次，所有 2 出现的个数远远多于 5，换言之找到一个 5，一定能找到一个 2 与之配对。所以我们只需要找有多少个 5。<br>
直接的，我们只需要判断每个累乘的数有多少个 5 的因子即可。</p>
</blockquote>
<pre><code>public int trailingZeroes(int n) {
    int count = 0;
    for (int i = 1; i &lt;= n; i++) {
        int N = i;
        while (N &gt; 0) {
            if (N % 5 == 0) {
                count++;
                N /= 5;
            } else {
                break;
            }
        }
    }
    return count;

}
</code></pre>
<blockquote>
<p>但发生了超时，我们继续分析。<br>
对于一个数的阶乘，就如之前分析的，5 的因子一定是每隔 5 个数出现一次，也就是下边的样子。<br>
n! = 1 * 2 * 3 * 4 * (1 * 5) * ... * (2 * 5) * ... * (3 * 5) *... * n<br>
因为每隔 5 个数出现一个 5，所以计算出现了多少个 5，我们只需要用 n/5 就可以算出来。<br>
但还没有结束，继续分析。<br>
... * (1 * 5) * ... * (1 * 5 * 5) * ... * (2 * 5 * 5) * ... * (3 * 5 * 5) * ... * n<br>
每隔 25 个数字，出现的是两个 5，所以除了每隔 5 个数算作一个 5，每隔 25 个数，还需要多算一个 5。<br>
也就是我们需要再加上 n / 25 个 5。<br>
同理我们还会发现每隔 5 * 5 * 5 = 125 个数字，会出现 3 个 5，所以我们还需要再加上 n / 125 。<br>
综上，规律就是每隔 5 个数，出现一个 5，每隔 25 个数，出现 2 个 5，每隔 125 个数，出现 3 个 5... 以此类推。<br>
最终 5 的个数就是 n / 5 + n / 25 + n / 125 ...<br>
写程序的话，如果直接按照上边的式子计算，分母可能会造成溢出。所以算 n / 25 的时候，我们先把 n 更新，n = n / 5，然后再计算 n / 5 即可。后边的同理。</p>
</blockquote>
<pre><code>public int trailingZeroes(int n) {
    int count = 0;
    while (n &gt; 0) {
        count += n / 5;
        n = n / 5;
    }
    return count;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 167. 两数之和 II - 输入有序数组[简单]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-167-liang-shu-zhi-he-ii-shu-ru-you-xu-shu-zu-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-167-liang-shu-zhi-he-ii-shu-ru-you-xu-shu-zu-jian-dan">
        </link>
        <updated>2020-01-30T07:14:53.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。<br>
函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。<br>
说明:<br>
返回的下标值（index1 和 index2）不是从零开始的。<br>
你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。<br>
示例:<br>
输入: numbers = [2, 7, 11, 15], target = 9<br>
输出: [1,2]<br>
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题其实没什么特别的，无非就是双指针移动<br>
但是重点在于从这题开始，要使用所学到的注意事项了，特别是muduo和effective c++中的建议和要求，比如变量命名，又比如使用const变量</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) {
        vector&lt;int&gt;::const_iterator min=numbers.cbegin();//注意指向常量的迭代器const_iterator和常量迭代器的区别const iterator ，同时还要注意cbegin cend 和 begin end 的区别
        vector&lt;int&gt;::const_iterator max=numbers.cend()-1;//又忘了end指向尾后位置了，还是得每天练练手
        while(min&lt;max){  //注意只有随机迭代器可以用关系运算符
           //if(*max+*min==target) //这里其实可以做减法，防止溢出
             if(target-*max==*min)   
                return vector&lt;int&gt;({min-numbers.cbegin()+1,max-numbers.cbegin()+1});
            //else if(*max+*min&lt;target)
            else if(target-*max&gt;*min)
                ++min;
            else
                --max;
        }
        return vector&lt;int&gt;();
    }
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>方法 1：双指针<br>
算法<br>
我们可以使用 两数之和 的解法在 O(n^2)时间 O(1) 空间暴力解决，也可以用哈希表在 O(n) 时间和O(n) 空间内解决。然而，这两种方法都没有用到输入数组已经排序的性质，我们可以做得更好。<br>
我们使用两个指针，初始分别位于第一个元素和最后一个元素位置，比较这两个元素之和与目标值的大小。如果和等于目标值，我们发现了这个唯一解。如果比目标值小，我们将较小元素指针增加一。如果比目标值大，我们将较大指针减小一。移动指针后重复上述比较知道找到答案。<br>
假设 [... , a, b, c, ... , d, e, f, …]是已经升序排列的输入数组，并且元素 b,e 是唯一解。因为我们从左到右移动较小指针，从右到左移动较大指针，总有某个时刻存在一个指针移动到b 或 e 的位置。不妨假设小指针先移动到了元素 b ，这是两个元素的和一定比目标值大，根据我们的算法，我们会向左移动较大指针直至获得结果。<br>
C++</p>
</blockquote>
<pre><code>class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) {
        int low = 0, high = numbers.size() - 1;
        while (low &lt; high) {
            int sum = numbers[low] + numbers[high];
            if (sum == target)
                return {low + 1, high + 1};
            else if (sum &lt; target)
                ++low;
            else
                --high;
        }
        return {-1, -1};
    }
};
</code></pre>
<blockquote>
<p>是否需要考虑 numbers[low] + numbers[high]numbers[low]+numbers[high] 溢出呢？答案是不需要。因为即使两个元素之和溢出了，因为只存在唯一解，所以一定会先访问到答案。<br>
复杂度分析<br>
时间复杂度：O(n)。每个元素最多被访问一次，共有 n 个元素。<br>
空间复杂度：O(1)。只是用了两个指针。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 1.两数之和[简单][未做出]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-1liang-shu-zhi-he-jian-dan-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-1liang-shu-zhi-he-jian-dan-wei-zuo-chu">
        </link>
        <updated>2020-01-29T07:47:55.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<br>
你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。<br>
示例:<br>
给定 nums = [2, 7, 11, 15], target = 9<br>
因为 nums[0] + nums[1] = 2 + 7 = 9<br>
所以返回 [0, 1]<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/two-sum<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>手贱去翻评论看到用map，然后想到一个不错的方法，就是用哈希表存储一对值，key是target-nums[i]或者nums[i]，value则是i，那么如果在后面遇到适合的key时就可以直接返回了<br>
hhh还真就是最佳题解</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        unordered_map&lt;int,int&gt; res_val;
        int len=nums.size();
        for(int i=0;i&lt;len;++i){
            int res= target-nums[i];
            if(res_val.count(res))
                return vector&lt;int&gt;({res_val[res],i});
            res_val.insert({nums[i],i});   
        }
        return vector&lt;int&gt;();
    }
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>方法一：暴力法<br>
暴力法很简单，遍历每个元素 x，并查找是否存在一个值与target−x 相等的目标元素。</p>
</blockquote>
<pre><code>Java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        for (int i = 0; i &lt; nums.length; i++) {
            for (int j = i + 1; j &lt; nums.length; j++) {
                if (nums[j] == target - nums[i]) {
                    return new int[] { i, j };
                }
            }
        }
        throw new IllegalArgumentException(&quot;No two sum solution&quot;);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(n^2)<br>
对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费O(n) 的时间。因此时间复杂度为 O(n^2)。<br>
空间复杂度：O(1)。</p>
</blockquote>
<blockquote>
<p>方法二：两遍哈希表<br>
为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。<br>
通过以空间换取速度的方式，我们可以将查找时间从 O(n) 降低到 O(1)。哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)。<br>
一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i] 本身！</p>
</blockquote>
<pre><code>Java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; nums.length; i++) {
            map.put(nums[i], i);
        }
        for (int i = 0; i &lt; nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) {
                return new int[] { i, map.get(complement) };
            }
        }
        throw new IllegalArgumentException(&quot;No two sum solution&quot;);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(n)，<br>
我们把包含有 n 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1) ，所以时间复杂度为 O(n)。<br>
空间复杂度：O(n)，<br>
所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 nn 个元素。</p>
</blockquote>
<blockquote>
<p>方法三：一遍哈希表<br>
事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。</p>
</blockquote>
<pre><code>Java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement)) {
                return new int[] { map.get(complement), i };
            }
            map.put(nums[i], i);
        }
        throw new IllegalArgumentException(&quot;No two sum solution&quot;);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(n)，<br>
我们只遍历了包含有 nn 个元素的列表一次。在表中进行的每次查找只花费 O(1) 的时间。<br>
空间复杂度：O(n)，<br>
所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 n 个元素。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 86. 分隔链表[中等]]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-86-fen-ge-lian-biao-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-86-fen-ge-lian-biao-zhong-deng">
        </link>
        <updated>2020-01-28T02:35:39.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。<br>
你应当保留两个分区中每个节点的初始相对位置。<br>
示例:<br>
输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3<br>
输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/partition-list<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题描述的意思还是挺有趣的<br>
我想到的方法是类似于归并排序，不过反过来把一个链表分成两个链表</p>
<p>实现过程中不断地超时，但是我用了断点也没发现问题<br>
后来发现是return的问题，似乎打印节点时超时了，才发现原来是larger链表没有收尾，导致形成了一个环，5-&gt;2-&gt;4-&gt;3-&gt;5、<br>
所以链表题一定要注意收尾！！！</p>
<pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        ListNode *smaller=new ListNode(0);
        ListNode *larger=new ListNode(0);
        ListNode *cur=head,*cur_s=smaller,*cur_l=larger;
        while(cur){
            if(cur-&gt;val&lt;x){
                cur_s-&gt;next=cur;
                cur=cur-&gt;next;
                cur_s=cur_s-&gt;next;
            }else{
                cur_l-&gt;next=cur;
                cur=cur-&gt;next;
                cur_l=cur_l-&gt;next;
            }
        }
        cur_l-&gt;next=NULL;//链表题一定要注意收尾！！
        cur_s-&gt;next=larger-&gt;next;
        return smaller-&gt;next;
    }
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>本题要求我们改变链表结构，使得值小于 x的元素，位于值大于等于x元素的前面。这实质上意味着在改变后的链表中有某个点，在该点之前的元素全部小于x ，该点之后的元素全部 大于等于x。<br>
我们将这个点记为JOINT。<br>
对该问题的逆向工程告诉我们，如果我们在JOINT将改后链表拆分，我们会得到两个更小的链表，其中一个包括全部值小于x的元素，另一个包括全部值大于x的元素。在解法中，我们的主要目的是创建这两个链表，并将它们连接。</p>
</blockquote>
<blockquote>
<p>双指针法：<br>
直觉<br>
我们可以用两个指针before 和 after 来追踪上述的两个链表。两个指针可以用于分别创建两个链表，然后将这两个链表连接即可获得所需的链表。<br>
算法<br>
1.初始化两个指针 before 和 after。在实现中，我们将两个指针初始化为哑 ListNode。这有助于减少条件判断。<br>
2.利用head指针遍历原链表。<br>
3.若head 指针指向的元素值小于 x，该节点应当是 before 链表的一部分。因此我们将其移到 before 中。<br>
4.否则，该节点应当是after 链表的一部分。因此我们将其移到 after 中<br>
5.遍历完原有链表的全部元素之后，我们得到了两个链表 before 和 after。原有链表的元素或者在before 中或者在 after 中，这取决于它们的值。<br>
<em><code>注意:</code> 由于我们从左到右遍历了原有链表，故两个链表中元素的相对顺序不会发生变化。另外值得注意的是，在图中我们完好地保留了原有链表。事实上，在算法实现中，我们将节点从原有链表中移除，并将它们添加到别的链表中。我们没有使用任何额外的空间，只是将原有的链表元素进行移动。</em><br>
6.现在，可以将 before 和 after 连接，组成所求的链表。<br>
为了算法实现更容易，我们使用了哑结点初始化。不能让哑结点成为返回链表中的一部分，因此在组合两个链表时需要向前移动一个节点。</p>
</blockquote>
<pre><code>class Solution {
    public ListNode partition(ListNode head, int x) {

        // before and after are the two pointers used to create the two list
        // before_head and after_head are used to save the heads of the two lists.
        // All of these are initialized with the dummy nodes created.
        ListNode before_head = new ListNode(0);
        ListNode before = before_head;
        ListNode after_head = new ListNode(0);
        ListNode after = after_head;

        while (head != null) {

            // If the original list node is lesser than the given x,
            // assign it to the before list.
            if (head.val &lt; x) {
                before.next = head;
                before = before.next;
            } else {
                // If the original list node is greater or equal to the given x,
                // assign it to the after list.
                after.next = head;
                after = after.next;
            }

            // move ahead in the original list
            head = head.next;
        }

        // Last node of &quot;after&quot; list would also be ending node of the reformed list
        after.next = null;

        // Once all the nodes are correctly assigned to the two lists,
        // combine them to form a single list which would be returned.
        before.next = after_head.next;

        return before_head.next;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度: O(N)，其中NN是原链表的长度，我们对该链表进行了遍历。<br>
空间复杂度: O(1)，我们没有申请任何新空间。值得注意的是，我们只移动了原有的结点，因此没有使用任何额外空间。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 221. 最大正方形[中等][未做出]]]></title>
        <id>https://lixin-ee.github.io//post/dong-tai-gui-hua-221-zui-da-zheng-fang-xing-zhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/dong-tai-gui-hua-221-zui-da-zheng-fang-xing-zhong-deng-wei-zuo-chu">
        </link>
        <updated>2020-01-27T03:27:38.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。<br>
示例:<br>
输入:<br>
1 0 1 0 0<br>
1 0 1 1 1<br>
1 1 1 1 1<br>
1 0 0 1 0<br>
输出: 4<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/maximal-square<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>【未做出】<br>
偷看标签是动态规划hhh 实在是太累了</p>
<p>实现的过程中一开始我想着用matrix直接初始化squares，结果！才发现matrix是char不是int，太6了吧<br>
然后记得是必须取三者最小值（本来想用&amp;&amp;的，发现必须累加。。。）</p>
<p>然后优化一下空间，因为只用到了上一列和当前列的元素<br>
实现过程中犯了一些小错误 1.忘了判断matrix[i][j]<mark>'1'和</mark>'0'来更新值，前者导致完全错误，后者导致cur残留错误 2。pre_squares=cur_squares;的更新差点放在j的内循环了，必须放在外循环！！！</p>
<pre><code>class Solution {
public:
    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) {
        if(matrix.empty()) return 0;
        int len=matrix.size(),wid=matrix[0].size();
        vector&lt;int&gt; cur_squares(wid,0),pre_squares(wid,0);
        int max_square=0;
        for(int i=0;i&lt;len;++i){
            for(int j=0;j&lt;wid;++j){
                if(i==0||j==0)
                    cur_squares[j]=matrix[i][j]-'0';
                else if(matrix[i][j]=='1')//别漏了判断是否等于1
                    cur_squares[j]=min(min(pre_squares[j],pre_squares[j-1]),cur_squares[j-1])+1;
                else
                    cur_squares[j]=0;
                max_square=max(max_square,cur_squares[j]); 
                
            }
            pre_squares=cur_squares;//这个的位置很重要，别放在内循环里面了
            //cur_squares=vector&lt;int&gt;(wid,0);//没有判断matrix[i][j]=='0'的情况来更新cur_squares[j]=0;的话必须更新cur，否则残留的cur=1会影响结果
        }
        return max_square*max_square;
    }    
    /*
    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) {
        if(matrix.size()==0) return 0;
        int len=matrix.size(),wid=matrix[0].size();
        vector&lt;vector&lt;int&gt;&gt; squares(len,vector&lt;int&gt;(wid,0));
        int max_square=0;
        for(int i=0;i&lt;len;++i)
            for(int j=0;j&lt;wid;++j){
                if(i==0||j==0)
                    squares[i][j]=matrix[i][j]-'0';
                else if(matrix[i][j]=='1')
                    squares[i][j]=min(min(squares[i-1][j],squares[i][j-1]),squares[i-1][j-1])+1;
                max_square=max(max_square,squares[i][j]);       
            }
        return max_square*max_square;     
    }
    */
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>概要<br>
在给定m×n 的矩阵中，我们需要找到在矩阵中由 1 组成的最大正方形。<br>
换句话说，我们需要在矩阵中找到由 1 组成最大连通的正方形，并返回其面积。<br>
解决方法<br>
方法一：暴力法<br>
最简单的方法是找出矩阵中所有可以形成的 1 正方形。现在的问题是如何做到这一点？<br>
我们用一个变量去来记录迄今为止发现的最大正方形的边长，以及用一个变量记录当前正方形的大小，两个变量都初始化为 0；<br>
从矩阵的左上角开始搜索 1，找到 0 不需要做任何操作，只要找到 1 我们就试图找到由 1 组成的最大正方形；<br>
为此我们向右和向下移动，临时增加列索引和行索引，然后用标志标记该行列是否全都为 1；<br>
如果全都为 1，则继续检索行列，如果找到 0，便停止移动，更新最大正方形的边长。然后从最初发现 1 的元素旁边遍历矩阵，直到矩阵的所有元素都被遍历。<br>
Java</p>
</blockquote>
<pre><code>public class Solution {
    public int maximalSquare(char[][] matrix) {
        int rows = matrix.length, cols = rows &gt; 0 ? matrix[0].length : 0;
        int maxsqlen = 0;
        for (int i = 0; i &lt; rows; i++) {
            for (int j = 0; j &lt; cols; j++) {
                if (matrix[i][j] == '1') {
                    int sqlen = 1;
                    boolean flag = true;
                    while (sqlen + i &lt; rows &amp;&amp; sqlen + j &lt; cols &amp;&amp; flag) {
                        for (int k = j; k &lt;= sqlen + j; k++) {
                            if (matrix[i + sqlen][k] == '0') {
                                flag = false;
                                break;
                            }
                        }
                        for (int k = i; k &lt;= sqlen + i; k++) {
                            if (matrix[k][j + sqlen] == '0') {
                                flag = false;
                                break;
                            }
                        }
                        if (flag)
                            sqlen++;
                    }
                    if (maxsqlen &lt; sqlen) {
                        maxsqlen = sqlen;
                    }
                }
            }
        }
        return maxsqlen * maxsqlen;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O((mn) ^2)，最坏情况下，我们需要遍历整个矩阵寻找每个 1。<br>
空间复杂度：O(1)，没有使用额外的空间。</p>
</blockquote>
<blockquote>
<p>方法二：动态规划<br>
我们用一个例子来解释这个方法：<br>
0 1 1 1 0<br>
1 1 1 1 1<br>
0 1 1 1 1<br>
0 1 1 1 1<br>
0 0 1 1 1<br>
我们用 0 初始化另一个矩阵 dp，维数和原始矩阵维数相同；<br>
dp(i,j) 表示的是由 1 组成的最大正方形的边长；<br>
从 (0,0) 开始，对原始矩阵中的每一个 1，我们将当前元素的值更新为<br>
dp(i, j)=min(dp(i−1, j), dp(i−1, j−1), dp(i, j−1))+1<br>
我们还用一个变量记录当前出现的最大边长，这样遍历一次，找到最大的正方形边长maxsqlen，那么结果就是 maxsqlen^2 。</p>
</blockquote>
<pre><code>public class Solution {
    public int maximalSquare(char[][] matrix) {
        int rows = matrix.length, cols = rows &gt; 0 ? matrix[0].length : 0;
        int[][] dp = new int[rows + 1][cols + 1];
        int maxsqlen = 0;
        for (int i = 1; i &lt;= rows; i++) {
            for (int j = 1; j &lt;= cols; j++) {
                if (matrix[i-1][j-1] == '1'){
                    dp[i][j] = Math.min(Math.min(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1]) + 1;
                    maxsqlen = Math.max(maxsqlen, dp[i][j]);
                }
            }
        }
        return maxsqlen * maxsqlen;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(mn)。<br>
空间复杂度：O(mn)，用了一个大小相同的矩阵 dp。</p>
</blockquote>
<blockquote>
<p>方法三：动态规划优化<br>
在前面的动态规划解法中，计算第i行（row）的 dp 方法中，我们只使用了上一个元素和第 (i-1) 行，因此我们不需要二维 dp 矩阵，因为一维 dp 足以满足此要求。<br>
我们扫描一行原始矩阵元素时，我们根据公式：dp[j]=min(dp[j-1],dp[j],prev) 更新数组 dp，其中 prev 指的是 dp[j-1]，对于每一行，我们重复相同过程并在 dp 矩阵中更新元素。</p>
</blockquote>
<pre><code>public class Solution {
    public int maximalSquare(char[][] matrix) {
        int rows = matrix.length, cols = rows &gt; 0 ? matrix[0].length : 0;
        int[] dp = new int[cols + 1];
        int maxsqlen = 0, prev = 0;
        for (int i = 1; i &lt;= rows; i++) {
            for (int j = 1; j &lt;= cols; j++) {
                int temp = dp[j];
                if (matrix[i - 1][j - 1] == '1') {
                    dp[j] = Math.min(Math.min(dp[j - 1], prev), dp[j]) + 1;
                    maxsqlen = Math.max(maxsqlen, dp[j]);
                } else {
                    dp[j] = 0;
                }
                prev = temp;
            }
        }
        return maxsqlen * maxsqlen;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(mn)。<br>
空间复杂度：O(n)，使用了一个一维数组 dp。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 968. 监控二叉树 [困难][未做出]]]></title>
        <id>https://lixin-ee.github.io//post/shu-968-jian-kong-er-cha-shu-kun-nan-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/shu-968-jian-kong-er-cha-shu-kun-nan-wei-zuo-chu">
        </link>
        <updated>2020-01-26T01:43:07.000Z</updated>
        <content type="html"><![CDATA[<p>示例 1：<br>
<img src="https://lixin-ee.github.io//post-images/1580003119532.png" alt=""><br>
示例 2：<br>
<img src="https://lixin-ee.github.io//post-images/1580003651384.png" alt=""></p>
<blockquote>
<p>给定一个二叉树，我们在树的节点上安装摄像头。<br>
节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。<br>
计算监控树的所有节点所需的最小摄像头数量。<br>
示例 1：<br>
输入：[0,0,null,0,0]<br>
输出：1<br>
解释：如图所示，一台摄像头足以监控所有节点。<br>
示例 2：<br>
输入：[0,0,null,0,null,0,null,null,0]<br>
输出：2<br>
解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。<br>
提示：<br>
给定树的节点数的范围是 [1, 1000]。<br>
每个节点的值都是 0。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/binary-tree-cameras<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>一开始用的是迭代的奇偶层次法，提交了才发现挺笨的，因为如果是6层，每层1个节点的话，其实只需要在2和5层装就行了，不需要136或者245<br>
思考了一下 还是得靠动态规划</p>
<p>一开始以为是类似入室盗窃那道题的两种状态，看了题解发现三种状态更加好，然后注意这种父节点的值依赖于子节点的题是无法使用迭代法的</p>
<p>实现过程中发现头节点需要单独处理，因为它没有父节点可以监控他，看了题解 发现可以装载一个虚拟头节点（注意 我们所需要的只是监控的数量而不是节点，所以ehead的监控可以算到root的头上，比如root是0，需要ehead是1，此时虽然root是被监控，但是实际上ehead的监控算到cur头上，所以最终返回的数量是一致的）</p>
<p>我的实现用了三种状态 1-监控态 0-未被监控态 -1-被监控态 其中NULL节点为-1态，意味着不需要处理 叶子节点为0，因为我们总是希望叶子节点的父节点来监控以取得最大收益（父节点至少可以监控两个，叶子节点只能监控一个），当然这也是导致root需要ehead的原因 否则root自身就是叶节点返回0的话就木大了</p>
<p>递归逻辑中，必须优先处理的就是子节点为0的情况，此时必须监控。然后就是如果叶节点都不为0而且有个监控的话，当前节点就可以返回-1了，其他情况统统返回0（比如叶子节点都是被监控的，此时自己加监控收益低，还是给父节点去考虑），注意此处不能判断叶子节点都为-1，否则会因为情况判断不完全而产生不返回的错误</p>
<p>然后在实现的时候遇到一个啼笑皆非的问题，int right=preorder(cur-&gt;right,res);这行代码中cur-&gt;right写成了cur-right，本来应该报错符号的，但是恰好定义了int的right，导致识别为减号，报错内存溢出。。。</p>
<pre><code>class Solution {
public:
    int minCameraCover(TreeNode* root) {
        if(root==NULL) return 0;
        int res=0;
        TreeNode* ehead=new TreeNode(0);
        ehead-&gt;left=root;
        preorder(ehead,res);
        return res;
    }
    
    int preorder(TreeNode *cur,int &amp;res){
        if(cur==NULL)
            return -1;
        if(cur-&gt;left==NULL&amp;&amp;cur-&gt;right==NULL){
            return 0;
        }
        int left=preorder(cur-&gt;left,res);
        int right=preorder(cur-&gt;right,res);
        if(left==0||right==0){
            ++res;
            return 1;
        }
        if(left==1||right==1)
            return -1;
        //if(left==-1&amp;&amp;right==-1)
            return 0;    
    }
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>当遍历到一个节点时，我们可以定义三种状态：<br>
0 ： 初始状态，如果节点为null可以返回，也就是不影响其他节点，当两个节点都是0时，我们直接设置当前节点为未监控状态<br>
1： 未监控状态，如果子节点含有该状态，则此节点必须添加摄像头，同时返回当前状态为监控态<br>
2： 监控态，表明此节点已经被监控，当子节点为此状态时，父节点不需要添加摄像头，可以返回初始态</p>
</blockquote>
<pre><code>private int dfs(TreeNode node){
        if (node == null) return 0;

        int l = dfs(node.left);
        int r = dfs(node.right);

        if (l + r == 0)  
            return 1;
        else if (l == 1 || r == 1) {
            cameras ++; return 2;
        } else  
            return 0;
    }
</code></pre>
<blockquote>
<p>当调用时，有一个小技巧，我们需要为传入的根节点添加一个虚拟的头，因为向上遍历时，根节点的监控状态我们无法保证，所以添加一个虚拟头可以简化编程。</p>
</blockquote>
<pre><code>public int minCameraCover(TreeNode root) {
        TreeNode dummyHead = new TreeNode(0);
        dummyHead.left = root;
        dfs(dummyHead);
        return cameras;
    }
</code></pre>
<blockquote>
<p>时间复杂度O(N)<br>
空间复杂度如果不算递归的隐式调用栈，为O(1),否则为O(h),h为树的高度。</p>
</blockquote>
<p>网友题解里面的判断条件用了加法，虽然不太直观，但是非常巧妙</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 628. 三个数的最大乘积[简单]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-628-san-ge-shu-de-zui-da-cheng-ji-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-628-san-ge-shu-de-zui-da-cheng-ji-jian-dan">
        </link>
        <updated>2020-01-25T03:02:35.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。<br>
示例 1:<br>
输入: [1,2,3]<br>
输出: 6<br>
示例 2:<br>
输入: [1,2,3,4]<br>
输出: 24<br>
注意:<br>
给定的整型数组长度范围是[3,104]，数组中所有的元素范围是[-1000, 1000]。<br>
输入的数组中任意三个数的乘积不会超出32位有符号整数的范围。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/maximum-product-of-three-numbers<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>比较棘手的就是负数了，如果负数纳入考虑的话，就必须是两个负数。。。<br>
比较智障的方法就是保存五个数，用贪心法来更新hhh<br>
突然发现不太对劲，因为每次更新都要去除一个最小值，那么就得不断排序更新</p>
<p>我一开始还是实现比较笨的方法<br>
另外一个问题就是如何确定有没有被初始化，如果是数组全是负数的话结果还是负数，但是我一开始返回的结果是0，因为值都初始化为0了<br>
于是打算改成用set来管理 让set自动排序<br>
算了直接用sort吧</p>
<p>看了题解后发现第一个方法还是最优解，只是赋值不能是0，必须是最大最小值，然后判断起来比较麻烦 而且不能像我那样区分开负数和正数，比如1，2，3中，1应该也付给min_1</p>
<pre><code>class Solution {
public:
    int maximumProduct(vector&lt;int&gt;&amp; nums){
        int max_1=INT_MIN,max_2=INT_MIN,max_3=INT_MIN;
        int min_1=INT_MAX,min_2=INT_MAX;
        for(auto i:nums){
            if(i&gt;max_1)
                swap(max_3,max_2),swap(max_2,max_1),max_1=i;
            else if(i&gt;max_2)
                swap(max_3,max_2),max_2=i;
            else if(i&gt;max_3)
                max_3=i;
            if(i&lt;min_1)
                swap(min_2,min_1),min_1=i;
            else if(i&lt;min_2)
                min_2=i;
        }
        return max_1*max_2*max_3&gt;max_1*min_1*min_2?max_1*max_2*max_3:max_1*min_1*min_2;
    }
		/*//排序法
    int maximumProduct(vector&lt;int&gt;&amp; nums) {
        int len=nums.size();
        sort(nums.begin(),nums.end());
        return nums[len-1]*nums[len-2]*nums[len-3]&gt;nums[len-1]*nums[0]*nums[1]?nums[len-1]*nums[len-2]*nums[len-3]:nums[len-1]*nums[0]*nums[1];

    }
    */
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>方法一：排序<br>
我们将数组进行升序排序，如果数组中所有的元素都是非负数，那么答案即为最后三个元素的乘积。<br>
如果数组中出现了负数，那么我们还需要考虑乘积中包含负数的情况，显然选择最小的两个负数和最大的一个正数是最优的，即为前两个元素与最后一个元素的乘积。<br>
上述两个结果中的较大值就是答案。注意我们可以不用判断数组中到底有没有正数，0 或者负数，因为上述两个结果实际上已经包含了所有情况，最大值一定在其中。</p>
</blockquote>
<pre><code>Java
public class Solution {
    public int maximumProduct(int[] nums) {
        Arrays.sort(nums);
        return Math.max(nums[0] * nums[1] * nums[nums.length - 1], nums[nums.length - 1] * nums[nums.length - 2] * nums[nums.length - 3]);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(NlogN)，其中 N 是数组的长度。<br>
空间复杂度：O(logN)，为排序使用的空间。</p>
</blockquote>
<blockquote>
<p>方法二：线性扫描<br>
在方法一中，我们实际上只要求出数组中最大的三个数以及最小的两个数，因此我们可以不用排序，用线性扫描直接得出这五个数。</p>
</blockquote>
<pre><code>Java
public class Solution {
    public int maximumProduct(int[] nums) {
        int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;
        int max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE, max3 = Integer.MIN_VALUE;
        for (int n: nums) {
            if (n &lt;= min1) {
                min2 = min1;
                min1 = n;
            } else if (n &lt;= min2) {     // n lies between min1 and min2
                min2 = n;
            }
            if (n &gt;= max1) {            // n is greater than max1, max2 and max3
                max3 = max2;
                max2 = max1;
                max1 = n;
            } else if (n &gt;= max2) {     // n lies betweeen max1 and max2
                max3 = max2;
                max2 = n;
            } else if (n &gt;= max3) {     // n lies betwen max2 and max3
                max3 = n;
            }
        }
        return Math.max(min1 * min2 * max1, max1 * max2 * max3);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(N)。<br>
空间复杂度：O(1)。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 543. 二叉树的直径[简单]]]></title>
        <id>https://lixin-ee.github.io//post/shu-543-er-cha-shu-de-zhi-jing-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/shu-543-er-cha-shu-de-zhi-jing-jian-dan">
        </link>
        <updated>2020-01-24T02:37:32.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。<br>
示例 :<br>
给定二叉树<br>
1<br>
/ <br>
2   3<br>
/ \<br>
4   5<br>
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。<br>
注意：两结点之间的路径长度是以它们之间边的数目表示。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/diameter-of-binary-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这个问题可以转化为找某个节点的左右子树的深度之和（注意不一定就是根节点，有可能没有左右子树之一）<br>
递归倒是很简单，直接从叶子节点的1开始算起，每个非叶节点就计算左子树和右子树之和，再取两者的较大者+1返回<br>
迭代比较难，我想到的是先存入父节点、右子树和左子树，但是不知道怎么把层数回传给父节点<br>
后来想到用map来存,还是没法从叶节点开始回溯啊。。。</p>
<pre><code>class Solution {
public:        
    // 递归版
    int diameterOfBinaryTree(TreeNode* root) {
        if(root==NULL) return 0;
        int max_res=0;
        tree_deep(root,max_res);
        return max_res;
    }
    
    int tree_deep(TreeNode *cur,int &amp;max_res){
        int deep=0;
        if(cur-&gt;left==NULL&amp;&amp;cur-&gt;right==NULL)
            return 1;
        int left_deep,right_deep;
        if(cur-&gt;left)
            left_deep=tree_deep(cur-&gt;left,max_res);
        else
            left_deep=0;
        if(cur-&gt;right)
            right_deep=tree_deep(cur-&gt;right,max_res);
        else
            right_deep=0;
        max_res=max_res&gt;left_deep+right_deep?max_res:left_deep+right_deep;
        return left_deep&gt;right_deep?left_deep+1:right_deep+1;
    }
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>方法 1：深度优先搜索<br>
想法<br>
任意一条路径可以被写成两个 箭头（不同方向），每个箭头代表一条从某些点向下遍历到孩子节点的路径。<br>
假设我们知道对于每个节点最长箭头距离分别为 L, R，那么最优路径经过 L + R + 1 个节点。<br>
算法<br>
按照常用方法计算一个节点的深度：max(depth of node.left, depth of node.right) + 1。在计算的同时，经过这个节点的路径长度为 1 + (depth of node.left) + (depth of node.right) 。搜索每个节点并记录这些路径经过的点数最大值，期望长度是结果 - 1。</p>
</blockquote>
<pre><code>java
class Solution {
    int ans;
    public int diameterOfBinaryTree(TreeNode root) {
        ans = 1;
        depth(root);
        return ans - 1;
    }
    public int depth(TreeNode node) {
        if (node == null) return 0;
        int L = depth(node.left);
        int R = depth(node.right);
        ans = Math.max(ans, L+R+1);
        return Math.max(L, R) + 1;
    }
}
</code></pre>
<p>复杂度分析<br>
时间复杂度：O(N)，每个节点只访问一次。<br>
空间复杂度：O(N)，深度优先搜索的栈开销。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[队列 232. 用栈实现队列[简单]]]></title>
        <id>https://lixin-ee.github.io//post/dui-lie-232-yong-zhan-shi-xian-dui-lie-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/dui-lie-232-yong-zhan-shi-xian-dui-lie-jian-dan">
        </link>
        <updated>2020-01-23T01:25:01.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>使用栈实现队列的下列操作：<br>
push(x) -- 将一个元素放入队列的尾部。<br>
pop() -- 从队列首部移除元素。<br>
peek() -- 返回队列首部的元素。<br>
empty() -- 返回队列是否为空。<br>
示例:<br>
MyQueue queue = new MyQueue();<br>
queue.push(1);<br>
queue.push(2);<br>
queue.peek();  // 返回 1<br>
queue.pop();   // 返回 1<br>
queue.empty(); // 返回 false<br>
说明:<br>
你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。<br>
你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。<br>
假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/implement-queue-using-stacks<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>和队列模拟栈一样，我利用两个stack，因为每次插入需要在后面插入，所以需要一个temp来存储cur的已有值，插入后再将temp值返回到cur中</p>
<p>题解中显示无法用一个栈来实现，但是官方题解有一个比较巧妙的双栈，一个用来push，一个用来pop，摊还分析复杂度是常数分析<br>
这里可以单独详细看看摊还分析</p>
<pre><code>class MyQueue {
public:
    /** Initialize your data structure here. */
    MyQueue() {
        
    }
    stack&lt;int&gt; cur,temp;
    /** Push element x to the back of queue. */
    void push(int x) {
        temp.push(x);
   /*
        if(cur.size())
            while(cur.size())
                temp.push(cur.top()),cur.pop();
        cur.push(x);
        while(temp.size())
            cur.push(temp.top()),temp.pop();
  */
    }
    
    /** Removes the element from in front of queue and returns that element. */
    int pop() {
        if(cur.empty())
          while(temp.size())
              cur.push(temp.top()),temp.pop();
        int temp_i=cur.top();
        cur.pop();
        return temp_i;
        /*
        int temp_i=cur.top();
        cur.pop();
        return temp_i;
        */
    }
    
    /** Get the front element. */
    int peek() {
        if(cur.empty())
          while(temp.size())
              cur.push(temp.top()),temp.pop();
        return cur.top();
    }
    
    /** Returns whether the queue is empty. */
    bool empty() {
        return !(cur.size()||temp.size());
    }
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>题解<br>
队列是一种 先进先出（first in - first out， FIFO）的数据结构，队列中的元素都从后端（rear）入队（push），从前端（front）出队（pop）。<br>
实现队列最直观的方法是用链表，但在这篇文章里我会介绍另一个方法 - 使用栈。<br>
栈是一种 后进先出（last in - first out， LIFO）的数据结构，栈中元素从栈顶（top）压入（push)，也从栈顶弹出（pop）。<br>
为了满足队列的 FIFO 的特性，我们需要用到两个栈，用它们其中一个来反转元素的入队顺序，用另一个来存储元素的最终顺序。</p>
</blockquote>
<blockquote>
<p>方法一（使用两个栈 入队 - O(n)， 出队 - O(1)）<br>
算法<br>
入队（push）<br>
一个队列是 FIFO 的，但一个栈是 LIFO 的。这就意味着最新压入的元素必须得放在栈底。为了实现这个目的，我们首先需要把 s1 中所有的元素移到 s2 中，接着把新元素压入 s2。最后把 s2 中所有的元素弹出，再把弹出的元素压入 s1。</p>
</blockquote>
<pre><code>private int front;

public void push(int x) {
    if (s1.empty())
        front = x;
    while (!s1.isEmpty())
        s2.push(s1.pop());
    s2.push(x);
    while (!s2.isEmpty())
        s1.push(s2.pop());
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)<br>
对于除了新元素之外的所有元素，它们都会被压入两次，弹出两次。新元素只被压入一次，弹出一次。这个过程产生了 4n+2 次操作，其中 n 是队列的大小。由于 压入 操作和 弹出 操作的时间复杂度为O(1)， 所以时间复杂度为O(n)。<br>
空间复杂度：O(n)<br>
需要额外的内存来存储队列中的元素。</p>
</blockquote>
<blockquote>
<p>出队（pop）<br>
直接从 s1 弹出就可以了，因为 s1 的栈顶元素就是队列的队首元素。同时我们把弹出之后 s1 的栈顶元素赋值给代表队首元素的 front 变量。</p>
</blockquote>
<pre><code>// Removes the element from the front of queue.
public void pop() {
    s1.pop();
    if (!s1.empty())
        front = s1.peek();
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(1)<br>
空间复杂度：O(1)<br>
判断空（empty）<br>
s1 存储了队列所有的元素，所以只需要检查 s1 的是否为空就可以了。</p>
</blockquote>
<pre><code>Java
// Return whether the queue is empty.
public boolean empty() {
    return s1.isEmpty();
}
</code></pre>
<blockquote>
<p>时间复杂度：O(1)<br>
空间复杂度：O(1)<br>
取队首元素（peek）<br>
在我们的算法中，用了 front 变量来存储队首元素，在每次 入队 操作或者 出队 操作之后这个变量都会随之更新。</p>
</blockquote>
<pre><code>Java
// Get the front element.
public int peek() {
  return front;
}
</code></pre>
<blockquote>
<p>时间复杂度：O(1)<br>
队首元素（front）已经被提前计算出来了，同时也只有 peek 操作可以得到它的值。<br>
空间复杂度：O(1)</p>
</blockquote>
<blockquote>
<p>方法二（使用两个栈 入队 - O(1)，出队 - 摊还复杂度 O(1)）<br>
算法<br>
入队（push）<br>
新元素总是压入 s1 的栈顶，同时我们会把 s1 中压入的第一个元素赋值给作为队首元素的 front 变量。</p>
</blockquote>
<pre><code>private Stack&lt;Integer&gt; s1 = new Stack&lt;&gt;();
private Stack&lt;Integer&gt; s2 = new Stack&lt;&gt;();

// Push element x to the back of queue.
public void push(int x) {
    if (s1.empty())
        front = x;
    s1.push(x);
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(1)<br>
向栈压入元素的时间复杂度为O(1)<br>
空间复杂度：O(n)<br>
需要额外的内存来存储队列元素</p>
</blockquote>
<blockquote>
<p>出队（pop）<br>
根据栈 LIFO 的特性，s1 中第一个压入的元素在栈底。为了弹出 s1 的栈底元素，我们得把 s1 中所有的元素全部弹出，再把它们压入到另一个栈 s2 中，这个操作会让元素的入栈顺序反转过来。通过这样的方式，s1 中栈底元素就变成了 s2 的栈顶元素，这样就可以直接从 s2 将它弹出了。一旦 s2 变空了，我们只需把 s1 中的元素再一次转移到 s2 就可以了。</p>
</blockquote>
<pre><code>// Removes the element from in front of queue.
public void pop() {
    if (s2.isEmpty()) {
        while (!s1.isEmpty())
            s2.push(s1.pop());
    }
    s2.pop();    
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度： 摊还复杂度 O(1)，最坏情况下的时间复杂度 O(n)<br>
在最坏情况下，s2 为空，算法需要从 s1 中弹出 n 个元素，然后再把这 n 个元素压入 s2，在这里n代表队列的大小。这个过程产生了 2n 步操作，时间复杂度为 O(n)。但当 s2 非空时，算法就只有 O(1) 的时间复杂度。所以为什么叫做摊还复杂度 O(1) 呢？ 读了下一章你就知道了。<br>
空间复杂度 ：O(1)</p>
</blockquote>
<blockquote>
<p>摊还分析<br>
摊还分析给出了所有操作的平均性能。摊还分析的核心在于，最坏情况下的操作一旦发生了一次，那么在未来很长一段时间都不会再次发生，这样就会均摊每次操作的代价。<br>
来看下面这个例子，从一个空队列开始，依次执行下面这些操作：<br>
push 1 ,push 2 ,…,push n ,pop 1 ,pop 2	 …,pop n<br>
单次 出队 操作最坏情况下的时间复杂度为 O(n)。考虑到我们要做 n 次出队操作，如果我们用最坏情况下的时间复杂度来计算的话，那么所有操作的时间复杂度为 O(n^2)。<br>
然而，在一系列的操作中，最坏情况不可能每次都发生，可能一些操作代价很小，另一些代价很高。因此，如果用传统的最坏情况分析，那么给出的时间复杂度是远远大于实际的复杂度的。例如，在一个动态数组里面只有一些插入操作需要花费线性的时间，而其余的一些插入操作只需花费常量的时间。<br>
在上面的例子中，出队 操作最多可以执行的次数跟它之前执行过 入队 操作的次数有关。虽然一次 出队 操作代价可能很大，但是每 n 次 入队 才能产生这么一次代价为 n 的 出队 操作。因此所有操作的总时间复杂度为：n(所有的入队操作产生） + 2 * n(第一次出队操作产生） + n - 1(剩下的出队操作产生）， 所以实际时间复杂度为 O(2*n)。于是我们可以得到每次操作的平均时间复杂度为 O(2n/2n)=O(1)。</p>
</blockquote>
<blockquote>
<p>判断空（empty）<br>
s1 和 s2 都存有队列的元素，所以只需要检查 s1 和 s2 是否都为空就可以了。</p>
</blockquote>
<pre><code>Java
// Return whether the queue is empty.
public boolean empty() {
    return s1.isEmpty() &amp;&amp; s2.isEmpty();
}
</code></pre>
<blockquote>
<p>时间复杂度：O(1)<br>
空间复杂度：O(1)</p>
</blockquote>
<blockquote>
<p>取队首元素（peek)<br>
我们定义了 front 变量来保存队首元素，每次 入队 操作我们都会随之更新这个变量。当 s2 为空，front 变量就是对首元素，当 s2 非空，s2 的栈顶元素就是队首元素。</p>
</blockquote>
<pre><code>Java
// Get the front element.
public int peek() {
    if (!s2.isEmpty()) {
        return s2.peek();
    }
    return front;
}
</code></pre>
<blockquote>
<p>时间复杂度：O(1)<br>
队首元素要么是之前就被计算出来的，要么就是 s2 栈顶元素。因此时间复杂度为 O(1)。<br>
空间复杂度：O(1)</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[栈 225. 用队列实现栈[简单]]]></title>
        <id>https://lixin-ee.github.io//post/zhan-225-yong-dui-lie-shi-xian-zhan-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/zhan-225-yong-dui-lie-shi-xian-zhan-jian-dan">
        </link>
        <updated>2020-01-21T12:08:13.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>使用队列实现栈的下列操作：<br>
push(x) -- 元素 x 入栈<br>
pop() -- 移除栈顶元素<br>
top() -- 获取栈顶元素<br>
empty() -- 返回栈是否为空<br>
注意:<br>
你只能使用队列的基本操作-- 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。<br>
你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。<br>
你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/implement-stack-using-queues<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>我一开始只想到比较笨的方法，就是用两个队列来实现，每次push只放入cur中，并且保持cur只有一个元素，亦即栈顶元素，多余的元素push进另一个队列storage中<br>
然后就是pop的问题，如果pop使得cur为空，就需要把storage的元素push进cur里面，使得storage只剩一个栈顶元素，此时再将两者交换<br>
然后题目给的模板好坑，和c++的类似乎不相同，我在MyStack()里面定义队列是会报错的</p>
<p>题解中给的一个队列的题解不错，还是c++实现的</p>
<p>为了防止两者强行拷贝赋值，我使用了指针，然后在这一题我想探讨一下swap、move和移动赋值的问题<br>
很可惜leetcode似乎对内存的判断并不准确，又或者是queue自动触发了移动赋值，在这里的测试的内存一直不变</p>
<pre><code>class MyStack {
public:
    /** Initialize your data structure here. */

    //MyStack() {
        queue&lt;int&gt; cur,storage;

    //}

    /** Push element x onto stack. */
    void push(int x) {
        if((cur).size()){
            (storage).push((cur).front());
            (cur).pop();
        }
         (cur).push(x);     
    }
    
    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        int temp=(cur).front();
        (cur).pop();
        while((storage).size()&gt;1){
            (cur).push((storage).front());
            (storage).pop();
        }
        /*
        auto tempqueue=cur;
        cur=storage;
        storage=tempqueue;
        */
        swap(cur,storage);
        return temp;
    }
    
    /** Get the top element. */
    int top() {
        return (cur).front();
    }
    
    /** Returns whether the stack is empty. */
    bool empty() {
        if((cur).size())
            return false;
        else
            return true;
    }
};
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>因为原始的queue是先进先出，所以要通过queue实现栈，在每一次push进新元素x时，需将前面的元素移到x的后面，可以巧妙地使用q.push(q.front()); q.pop(); 代码实现如下：</p>
</blockquote>
<pre><code>class MyStack {
    queue&lt;int&gt; nums;
public:
    /** Initialize your data structure here. */
    MyStack() {
        //nothing to do
    }
    
    /** Push element x onto stack. */
    void push(int x) {
        nums.push(x);
        //将前面的size-1个元素放到后面去
        for(int i = 0; i &lt; nums.size() - 1; i++){
            nums.push(nums.front());
            nums.pop();
        }
    }
    
    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        int num = nums.front();
        nums.pop();
        return num;
    }
    
    /** Get the top element. */
    int top() {
        return nums.front();
    }
    
    /** Returns whether the stack is empty. */
    bool empty() {
        return nums.empty();
    }
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>绪论<br>
这篇文章是为初级读者准备的，文章中介绍栈和队列这两种数据结构。<br>
方法一 （两个队列，压入 -O(1)， 弹出 -O(n)）<br>
思路<br>
栈是一种 后进先出（last in - first out， LIFO）的数据结构，栈内元素从顶端压入（push），从顶端弹出（pop）。一般我们用数组或者链表来实现栈，但是这篇文章会来介绍如何用队列来实现栈。队列是一种与栈相反的 先进先出（first in - first out， FIFO）的数据结构，队列中元素只能从 后端（rear）入队（push），然后从 前端（front）端出队（pop）。为了满足栈的特性，我们需要维护两个队列 q1 和 q2。同时，我们用一个额外的变量来保存栈顶元素。<br>
算法<br>
压入（push）<br>
新元素永远从 q1 的后端入队，同时 q1 的后端也是栈的 栈顶（top）元素。</p>
</blockquote>
<pre><code>private Queue&lt;Integer&gt; q1 = new LinkedList&lt;&gt;();
private Queue&lt;Integer&gt; q2 = new LinkedList&lt;&gt;();
private int top;

// Push element x onto stack.
public void push(int x) {
    q1.add(x);
    top = x;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(1)<br>
队列是通过链表来实现的，入队（add）操作的时间复杂度为 O(1)。<br>
空间复杂度：O(1)</p>
</blockquote>
<blockquote>
<p>弹出（pop）<br>
我们需要把栈顶元素弹出，就是 q1 中最后入队的元素。<br>
考虑到队列是一种 FIFO 的数据结构，最后入队的元素应该在最后被出队。因此我们需要维护另外一个队列 q2，这个队列用作临时存储 q1 中出队的元素。q2 中最后入队的元素将作为新的栈顶元素。接着将 q1 中最后剩下的元素出队。我们通过把 q1 和 q2 互相交换的方式来避免把 q2 中的元素往 q1 中拷贝。</p>
</blockquote>
<pre><code>// Removes the element on top of the stack.
public void pop() {
    while (q1.size() &gt; 1) {
        top = q1.remove();
        q2.add(top);
    }
    q1.remove();
    Queue&lt;Integer&gt; temp = q1;
    q1 = q2;
    q2 = temp;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)<br>
算法让 q1 中的 n 个元素出队，让 nn−1 个元素从 q2 入队，在这里 n 是栈的大小。这个过程总共产生了2n−1 次操作，时间复杂度为 O(n)。</p>
</blockquote>
<blockquote>
<p>方法二 （两个队列， 压入 - O(n)， 弹出 - O(1)）<br>
算法<br>
压入（push)<br>
接下来介绍的算法让每一个新元素从 q2 入队，同时把这个元素作为栈顶元素保存。当 q1 非空（也就是栈非空），我们让 q1 中所有的元素全部出队，再将出队的元素从 q2 入队。通过这样的方式，新元素（栈中的栈顶元素）将会在 q2 的前端。我们通过将 q1， q2 互相交换的方式来避免把 q2 中的元素往 q1 中拷贝。</p>
</blockquote>
<pre><code>public void push(int x) {
    q2.add(x);
    top = x;
    while (!q1.isEmpty()) {                
        q2.add(q1.remove());
    }
    Queue&lt;Integer&gt; temp = q1;
    q1 = q2;
    q2 = temp;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)<br>
算法会让 q1 出队 n 个元素，同时入队 n+1 个元素到 q2。这个过程会产生2n+1 步操作，同时链表中 插入 操作和 移除 操作的时间复杂度为 O(1)，因此时间复杂度为 O(n)。<br>
空间复杂度：O(1)</p>
</blockquote>
<blockquote>
<p>弹出（pop）<br>
直接让 q1 中元素出队，同时将出队后的 q1 中的队首元素作为栈顶元素保存。</p>
</blockquote>
<pre><code>// Removes the element on top of the stack.
public void pop() {
    q1.remove();
    if (!q1.isEmpty()) {
    	top = q1.peek();
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(1)<br>
空间复杂度：O(1)</p>
</blockquote>
<blockquote>
<p>判断空（empty）和 取栈顶元素（top）是同样的实现方式。<br>
判断空（empty）<br>
q1 里包含了栈中所有的元素，所以只需要检查 q1 是否为空就可以了。</p>
</blockquote>
<pre><code>Java
// Removes the element on top of the stack.
public void pop() {
    q1.remove();
    if (!q1.isEmpty()) {
    	top = q1.peek();
    }
}
</code></pre>
<blockquote>
<p>时间复杂度：O(1)<br>
空间复杂度：O(1)</p>
</blockquote>
<blockquote>
<p>取栈顶元素（top）<br>
栈顶元素被保存在 top 变量里，每次我们 压入 或者 弹出 一个元素的时候都会随之更新这个变量。</p>
</blockquote>
<pre><code>Java
// Get the top element.
public int top() {
    return top;
}
</code></pre>
<blockquote>
<p>时间复杂度：O(1)<br>
栈顶元素每次都是被提前计算出来的，同时只有 top 操作可以得到它的值。<br>
空间复杂度：O(1)</p>
</blockquote>
<blockquote>
<p>方法三 （一个队列， 压入-O(n)， 弹出-O(1)）<br>
上面介绍的两个方法都有一个缺点，它们都用到了两个队列。下面介绍的方法只需要使用一个队列。<br>
算法<br>
压入（push）<br>
当我们将一个元素从队列入队的时候，根据队列的性质这个元素会存在队列的后端。<br>
但当我们实现一个栈的时候，最后入队的元素应该在前端，而不是在后端。为了实现这个目的，每当入队一个新元素的时候，我们可以把队列的顺序反转过来。</p>
</blockquote>
<pre><code>private LinkedList&lt;Integer&gt; q1 = new LinkedList&lt;&gt;();

// Push element x onto stack.
public void push(int x) {
    q1.add(x);
    int sz = q1.size();
    while (sz &gt; 1) {
        q1.add(q1.remove());
        sz--;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)<br>
这个算法需要从 q1 中出队 n 个元素，同时还需要入队 n 个元素到 q1，其中 n 是栈的大小。这个过程总共产生了2n+1 步操作。链表中 插入 操作和 移除 操作的时间复杂度为 O(1)，因此时间复杂度为 O(n)。<br>
空间复杂度：O(1)</p>
</blockquote>
<blockquote>
<p>弹出（pop）<br>
最后一个压入的元素永远在 q1 的前端，这样的话我们就能在常数时间内让它 出队。</p>
</blockquote>
<pre><code>Java
// Removes the element on top of the stack.
public void pop() {
    q1.remove();
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(1)<br>
空间复杂度：O(1)</p>
</blockquote>
<blockquote>
<p>判断空（empty）<br>
q1 中包含了栈中所有的元素，所以只需要检查 q1 是否为空就可以了。</p>
</blockquote>
<pre><code>Java
// Return whether the stack is empty.
public boolean empty() {
    return q1.isEmpty();
}
</code></pre>
<blockquote>
<p>时间复杂度：O(1)<br>
空间复杂度：O(1)</p>
</blockquote>
<blockquote>
<p>取栈顶（top）<br>
栈顶元素永远在 q1 的前端，直接返回就可以了。<br>
时间复杂度：O(1)<br>
空间复杂度：O(1)</p>
</blockquote>
]]></content>
    </entry>
</feed>