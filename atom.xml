<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-10-02T11:04:07.647Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[字符串 151. 翻转字符串里的单词]]></title>
        <id>https://lixin-ee.github.io//post/zi-fu-chuan-151-fan-zhuan-zi-fu-chuan-li-de-dan-ci</id>
        <link href="https://lixin-ee.github.io//post/zi-fu-chuan-151-fan-zhuan-zi-fu-chuan-li-de-dan-ci">
        </link>
        <updated>2019-10-02T10:28:28.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个字符串，逐个翻转字符串中的每个单词。</p>
<p>示例 1：<br>
输入: &quot;the sky is blue&quot;<br>
输出: &quot;blue is sky the&quot;<br>
示例 2：<br>
输入: &quot;  hello world!  &quot;<br>
输出: &quot;world! hello&quot;<br>
解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<br>
示例 3：<br>
输入: &quot;a good   example&quot;<br>
输出: &quot;example good a&quot;<br>
解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/reverse-words-in-a-string<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题一开始没看清楚，上来就是想直接reverse，结果输出一直很奇怪，才发现是将单词的位置进行翻转，而单词内部不需要进行翻转（当然输出错误的主要原因也在于我一直把s当作space拿去匹配了...）<br>
这个整体还是和前一题一样，对元素进行翻转，但是这一次需要自己进行元素的搜索，所以可以看作<a href="https://lixin-ee.github.io/post/zi-fu-chuan-344fan-zhuan-zi-fu-chuan/">反转字符串</a>和<a href="https://lixin-ee.github.io/post/zi-fu-chuan-58-zui-hou-yi-ge-dan-ci-de-chang-du/">最后一个单词的长度</a>这两道题的结合吧。<br>
但是因为这一次没有对空间复杂度作出要求，所以我直接使用了额外的字符串进行保存。一开始老是没想起来怎么插入比较好，然后翻阅了笔记发现append这个函数最适合，比较类似可以设置范围的push_back，注意string的push_back只能以单个字符char作为参数的！然后还需要注意的是append参数的迭代器范围都是左闭右开的，所以右边的迭代器还需要额外+1.剩下的就是判断和空格插入的世纪问题了。<br>
最后结果如下：</p>
<pre><code>class Solution {
public:
    string reverseWords(string s) {
        int len=s.size();
        string space=&quot; &quot;;
        if(len==0)
            return s;
        string s_copy;
        int beg=s.find_last_not_of(space);
        int end=s.find_last_of(space,beg);
        while(beg!=string::npos){
            cout&lt;&lt;beg&lt;&lt;&quot; &quot;&lt;&lt;end&lt;&lt;endl;
            if(end==string::npos){
                s_copy.append(s.begin(),s.begin()+beg+1);
                break;
            }
            else
                 s_copy.append(s.begin()+end+1,s.begin()+beg+1);
            beg=s.find_last_not_of(space,end);
            end=s.find_last_of(space,beg);
            if(beg!=string::npos)
                s_copy.push_back(' ');
        }
        return s_copy;
    } 
};
</code></pre>
<p>然后来考虑原地算法，原地算法的难点不在反转，反转其实可以考虑<a href="https://lixin-ee.github.io/post/shu-zu-189xuan-zhuan-shu-zu/">数组189 旋转数组</a>，先对数组整体进行reverse，再对单个单词进行reverse。难点在于如何检测并去除多余的空格，我看了一下网友题解，基本是将元素进行移动或者将首尾的空格无视掉（使用substr），还是牺牲一点空间舒服一点啊hhh</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 344.反转字符串]]></title>
        <id>https://lixin-ee.github.io//post/zi-fu-chuan-344fan-zhuan-zi-fu-chuan</id>
        <link href="https://lixin-ee.github.io//post/zi-fu-chuan-344fan-zhuan-zi-fu-chuan">
        </link>
        <updated>2019-10-02T04:02:45.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。<br>
不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。<br>
你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p>
<p>示例 1：<br>
输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]<br>
输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]<br>
示例 2：<br>
输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]<br>
输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/reverse-string<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题还是简单题，其实就是按照下标进行互换，主要点在于对下标的判断条件，最好还是使用beg&lt;end这个判断条件比较方便。<br>
我的做法也比较简单，因为没有插入操作或者让迭代器失效的操作，所以直接用迭代器来判断，然后因为题目说可以默认容器中的元素全部都是小写字母，所以可以使用原地互换的方法而不用担心溢出问题，最后结果如下：</p>
<pre><code>class Solution {
public:
    void reverseString(vector&lt;char&gt;&amp; s) {
        if(!s.size())
            return;
        auto beg=s.begin();
        auto end=s.end()-1;
        while(beg&lt;end){
            *beg=*beg+*end;
            *end=*beg-*end;
            *beg=*beg-*end;
            ++beg,--end;
        }
    }
};
</code></pre>
<p>然后主要还是复习一STL源码，因为这么常用的算法肯定已经被库内实现的了。<br>
库内的翻转函数名字叫reverse 主要的要点在于<br>
1.首先区分容器迭代器的内容，因为非random_accesss_iterator的话是没法进行&lt;小于号判断的（但是可以++和--），如果是bidiretional的话就进行first<mark>last||first</mark>--last的判断<br>
2.进行iter_swap(first,last)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 383. 赎金信]]></title>
        <id>https://lixin-ee.github.io//post/zi-fu-chuan-383-shu-jin-xin</id>
        <link href="https://lixin-ee.github.io//post/zi-fu-chuan-383-shu-jin-xin">
        </link>
        <updated>2019-10-01T11:29:08.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串ransom能不能由第二个字符串magazines里面的字符构成。如果可以构成，返回 true ；否则返回 false。<br>
(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。)</p>
<p>注意：<br>
你可以假设两个字符串均只含有小写字母。</p>
<p>canConstruct(&quot;a&quot;, &quot;b&quot;) -&gt; false<br>
canConstruct(&quot;aa&quot;, &quot;ab&quot;) -&gt; false<br>
canConstruct(&quot;aa&quot;, &quot;aab&quot;) -&gt; true</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/ransom-note<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这一次是我第一次正式吐槽题目，其实题目的出发点是好的，但是题目描述非常烂，第一次我以为是在第二个字符串中只要包含了第一字符串的字母就vans了，上来就是一个set，结果发现第二个例程无法通过。本来以为是必须按要求的顺序，百思不得其解就看了网友题解，才明白原来是第二个数组中的每个字母只能用一次，wtf写个赎金信还要求字母不得重复的吗？<br>
算了算了，其实方法和上一题重复字符的官方题解就很相似，使用map并记录次数，对于第一个字符串中的相应字符进行递减，低于0的就返回false<br>
题解如下，这一次第一次没有官方题解也没有比较好的网友题解，然后leetcode日常歧视关联容器，耗费时间永远不低。</p>
<pre><code>class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        map&lt;char,int&gt; alpha;
        for(auto c:magazine){
            if(!alpha.insert(make_pair(c,1)).second)
                ++alpha[c];
        }        
        for(auto c:ransomNote)
            if(!alpha.count(c))
                return false;
            else if(alpha[c]&gt;0)
                --alpha[c];
            else
                return false;
        return true;
        
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 387. 字符串中的第一个唯一字符]]></title>
        <id>https://lixin-ee.github.io//post/zi-fu-chuan-387-zi-fu-chuan-zhong-de-di-yi-ge-wei-yi-zi-fu</id>
        <link href="https://lixin-ee.github.io//post/zi-fu-chuan-387-zi-fu-chuan-zhong-de-di-yi-ge-wei-yi-zi-fu">
        </link>
        <updated>2019-09-30T15:42:40.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p>
<p>案例:<br>
s = &quot;leetcode&quot;<br>
返回 0.<br>
s = &quot;loveleetcode&quot;,<br>
返回 2.</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/first-unique-character-in-a-string<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>面对重复元素的问题，一方面如果必须是常数空间复杂度的话，可以用暴力法或者排序法进行解决，另一方面如果对空间复杂度没要求或者要求线性时间复杂度的话，那最好就是用关联容器map或者set了。<br>
首先我用暴力法解决一下，主要就是对每个元素进行一次遍历，如果没有重复的话就返回其位置。需要注意的是j的取值也是从0开始，而且必须跳过i，否则会只对身后的元素进行判断。</p>
<pre><code>class Solution {
public:
    int firstUniqChar(string s) {
        int len = s.size();
        if(!len)
            return -1;
        if(len==1)
            return 0;
        for(int i=0;i&lt;len;++i)
            for(int j=0;j&lt;len;++j)
                if(s[i]==s[j]&amp;&amp;i!=j)
                    break;
                else if(j==len-1)
                    return i;
        return -1;
        
    }
};
</code></pre>
<p>暴力法实现完了，第二个自然就是关联容器了，因为需要返回值的位置，所以需要的位置来保存值的位置，所以使用map或者multi，然后我首先想到的是map，map的实现如下，主要需要注意的1.我一开始的想法是如果插入失败就等于有重复的值在map里面了，就使用erase去除，但是这样会导致一个问题就是只能检测偶数的重复，如果遇到奇数的重复反而变不重复了（因为我们最后是检测不重复，而不是重复）所以后面改成如果插入失败就把下标搜索将second改为n+1。3.map的下标是直接返回second值的，不需要再调用second 3. 需要再遍历一遍map，因为map不会按照插入顺序进行保存的，而是根据关键字的有序来保存的，比如例子中的leetcode，<code>(*map.begin()).second</code> 返回的反而是c的位置（同时注意调用的括号所在，调用运算符的优先级高于解引用运算符）。<br>
代码如下：</p>
<pre><code>class Solution {
public:
    int firstUniqChar(string s) {
        int len = s.size();
        if(!len)
            return -1;
        if(len==1)
            return 0;
        map&lt;char,int&gt; maps;
        int i=0;
        for(auto c:s){
            if(!maps.insert(make_pair(c,i)).second)
                maps[c]=len+1;
            ++i;          
        }
        
        if(maps.empty())
            return -1;
        int min=len+1;
        for(auto m:maps)
            if(m.second!=-1)
            min=min&lt;m.second?min:m.second;
        if(min==len+1)
            return -1;
        return min;
    }
};
</code></pre>
<p>然后我突然觉得可能multimap更加适合这种情况，第二次的时候不需要遍历map，而是直接遍历字符串，用count来计算字符在multimap的数量（注意不可以使用下标运算符了，只能使用find），但是很遗憾，在面对超长字符串的时候会导致超时。</p>
<pre><code>class Solution {
public:
    int firstUniqChar(string s) {
        int len = s.size();
        if(!len)
            return -1;
        if(len==1)
            return 0;
        multimap&lt;char,int&gt; maps;
        int i=0;
        for(auto c:s){
            maps.insert(make_pair(c,i));
            ++i;          
        }
        for(auto c:s){
            int j=maps.count(c);   
            if(j==1)
                return maps.find(c)-&gt;second;
        }
        return -1;
       
    }
};
</code></pre>
<p>看一下官方题解：</p>
<blockquote>
<p>方法一： 线性时间复杂度解法<br>
这道题最优的解法就是线性复杂度了，为了保证每个元素是唯一的，至少得把每个字符都遍历一遍。</p>
<p>算法的思路就是遍历一遍字符串，然后把字符串中每个字符出现的次数保存在一个散列表中。这个过程的时间复杂度为 O(N)，其中 N 为字符串的长度。</p>
<p>接下来需要再遍历一次字符串，这一次利用散列表来检查遍历的每个字符是不是唯一的。如果当前字符唯一，直接返回当前下标就可以了。第二次遍历的时间复杂度也是 O(N)。</p>
</blockquote>
<pre><code>class Solution {
    public int firstUniqChar(String s) {
        HashMap&lt;Character, Integer&gt; count = new HashMap&lt;Character, Integer&gt;();
        int n = s.length();
        // build hash map : character and how often it appears
        for (int i = 0; i &lt; n; i++) {
            char c = s.charAt(i);
            count.put(c, count.getOrDefault(c, 0) + 1);
        }
        
        // find the index
        for (int i = 0; i &lt; n; i++) {
            if (count.get(s.charAt(i)) == 1) 
                return i;
        }
        return -1;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度： O(N)<br>
只遍历了两遍字符串，同时散列表中查找操作是常数时间复杂度的。<br>
空间复杂度： O(N)<br>
用到了散列表来存储字符串中每个元素出现的次数。</p>
</blockquote>
<p>其实和我的想法一致，就是map的键值和第二次搜索的处理不同，值得向官方题解学习一下</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[三种线性排序算法 计数排序、桶排序与基数排序]]></title>
        <id>https://lixin-ee.github.io//post/san-chong-xian-xing-pai-xu-suan-fa-ji-shu-pai-xu-tong-pai-xu-yu-ji-shu-pai-xu</id>
        <link href="https://lixin-ee.github.io//post/san-chong-xian-xing-pai-xu-suan-fa-ji-shu-pai-xu-tong-pai-xu-yu-ji-shu-pai-xu">
        </link>
        <updated>2019-09-30T13:00:57.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章对应的就是前面的算法题 <a href="https://lixin-ee.github.io/post/shu-zu-164-zui-da-jian-ju/">数组164.最大间距</a>，今天在地铁上特地重新复习了一下排序算法<br>
本文主要参考了<a href="https://www.byvoid.com/zhs/blog/sort-radix">BYVoid 原创讲解</a><br>
其实比较常用的算法是基于比较的算法，因为在面对超长数组的时候内存是最大的制掣因素。<br>
众所周知，基于比较的排序算法是不能突破O(NlogN)的。简单证明如下：<br>
N个数有N!个可能的排列情况，也就是说基于比较的排序算法的判定树有N!个叶子结点，比较次数至少为log(N!)=O(NlogN)(斯特林公式)。</p>
<p>但有趣的事，非基于比较的排序，如计数排序，桶排序，和在此基础上的基数排序，则可以突破O(NlogN)时间下限。<strong>但要注意的是，非基于比较的排序算法的使用都是有条件限制的，例如元素的大小限制</strong>，相反，基于比较的排序则没有这种限制(在一定范围内)。但并非因为有条件限制就会使非基于比较的排序算法变得无用，对于特定场合有着特殊的性质数据，非基于比较的排序算法则能够非常巧妙地解决。</p>
<p>[计数排序]<br>
首先从计数排序(Counting Sort)开始介绍起，假设我们有一个待排序的整数序列A，其中元素的最小值不小于0，最大值不超过K。建立一个长度为K的线性表C，用来记录不大于每个值的元素的个数。</p>
<p>算法思路如下：</p>
<p>扫描序列A，以A中的每个元素的值为索引，把出现的个数填入C中。此时C[i]可以表示A中值为i的元素的个数。<br>
对于C从头开始累加，使C[i]&lt;-C[i]+C[i-1]。这样，C[i]就表示A中值不大于i的元素的个数。<br>
按照统计出的值，输出结果。<br>
由线性表C我们可以很方便地求出排序后的数据，定义B为目标的序列，Order[i]为排名第i的元素在A中的位置，则可以用以下方法统计。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
using namespace std;
void CountingSort(int *A,int *B,int *Order,int N,int K)
{
    int *C=new int[K+1];
    int i;
    memset(C,0,sizeof(int)*(K+1));
    for (i=1;i&lt;=N;i++) //把A中的每个元素分配
        C[A[i]]++;
    for (i=2;i&lt;=K;i++) //统计不大于i的元素的个数
        C[i]+=C[i-1];
    for (i=N;i&gt;=1;i--)
    {
        B[C[A[i]]]=A[i]; //按照统计的位置，将值输出到B中，将顺序输出到Order中
        Order[C[A[i]]]=i;
        C[A[i]]--;
    }
}
int main()
{
    int *A,*B,*Order,N=15,K=10,i;
    A=new int[N+1];
    B=new int[N+1];
    Order=new int[N+1];
    for (i=1;i&lt;=N;i++)
        A[i]=rand()%K+1; //生成1..K的随机数
    printf(&quot;Before CS:\n&quot;);
    for (i=1;i&lt;=N;i++)
        printf(&quot;%d &quot;,A[i]);
    CountingSort(A,B,Order,N,K);
    printf(&quot;\nAfter CS:\n&quot;);
    for (i=1;i&lt;=N;i++)
        printf(&quot;%d &quot;,B[i]);
    printf(&quot;\nOrder:\n&quot;);
    for (i=1;i&lt;=N;i++)
        printf(&quot;%d &quot;,Order[i]);
    return 0;
}
程序运行效果如下：

Before CS:
2 8 5 1 10 5 9 9 3 5 6 6 2 8 2
After CS:
1 2 2 2 3 5 5 5 6 6 8 8 9 9 10
Order:
4 1 13 15 9 3 6 10 11 12 2 14 7 8 5
</code></pre>
<p>我们可以看到，计数排序的要点在于1.提前知道数组的取值范围 2.取值范围K在内存能够接受的范围内。3.通过反向操作保证其为稳定排序算法。<br>
计数排序的时间复杂度为O(N+K)，空间复杂度为O(N+K)。当K不是很大时，这是一个很有效的线性排序算法。更重要的是，它是一种<strong>稳定排序算法</strong>，即排序后的相同值的元素原有的相对位置不会发生改变(表现在Order上)，这是计数排序很重要的一个性质，就是根据这个性质，我们才能把它应用到基数排序。</p>
<p>[桶排序]<br>
在读计数排序的代码时我发现了一个问题，一是如果重复的元素越多，浪费的空间就越多，比如有很多个2的时候。二是计数排序似乎饶了点弯子，比如当我们刚刚统计出C，C[i]可以表示A中值为i的元素的个数，此时我们直接顺序地扫描C，就可以求出排序后的结果。的确是这样，不过这种方法不再是计数排序，而是桶排序(Bucket Sort)，确切地说，是桶排序的一种特殊情况，但是直接顺序搜索c得到的的桶排序是不稳定的，同时也需要占到太多的额外空间。（不要小看稳定，单个数组看不出来问题所在，如果是map这种分为key-value和map-value的，把key-value弄乱了就出大事了）<br>
正式的桶排序如下：<br>
首先定义桶，桶为一个数据容器，每个桶存储一个区间内的数。依然有一个待排序的整数序列A，元素的最小值不小于0，最大值不超过K。假设我们有M个桶，第i个桶Bucket[i]存储i*K/M至(i+1)K/M之间的数，有如下桶排序的一般方法：</p>
<p>扫描序列A，根据每个元素的值所属的区间，放入指定的桶中(顺序放置)。<br>
对每个桶中的元素进行排序，什么排序算法都可以，例如快速排序。<br>
依次收集每个桶中的元素，顺序放置到输出序列中。<br>
对该算法简单分析，如果数据是期望平均分布的，则每个桶中的元素平均个数为N/M。如果对每个桶中的元素排序使用的算法是快速排序，每次排序的时间复杂度为O(N/Mlog(N/M))。则总的时间复杂度为O(N)+O(M)O(N/Mlog(N/M)) = O(N+ Nlog(N/M)) = O(N + NlogN - NlogM)。当M接近于N是，桶排序的时间复杂度就可以近似认为是O(N)的。就是桶越多，时间效率就越高，而桶越多，空间却就越大，由此可见时间和空间是一个矛盾的两个方面。</p>
<p>桶中元素的顺序放入和顺序取出是有必要的，因为这样可以确定桶排序是一种稳定排序算法，配合基数排序是很好用的。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
using namespace std;
struct linklist
{
    linklist *next;
    int value;
    linklist(int v,linklist *n):value(v),next(n){}
    ~linklist() {if (next) delete next;}
};
inline int cmp(const void *a,const void *b)
{
    return *(int *)a-*(int *)b;
}
</code></pre>
<p>为了方便，我把A中元素加入桶中时是倒序放入的，而收集取出时也是倒序放入序列的，所以不违背稳定排序。</p>
<pre><code>void BucketSort(int *A,int *B,int N,int K)
{
    linklist *Bucket[101],*p;//建立桶
    int i,j,k,M;
    M=K/100;
    memset(Bucket,0,sizeof(Bucket));
    for (i=1;i&lt;=N;i++)
    {
        k=A[i]/M; //把A中的每个元素按照的范围值放入对应桶中
        Bucket[k]=new linklist(A[i],Bucket[k]);
    }
    for (k=j=0;k&lt;=100;k++)
    {
        i=j;
        for (p=Bucket[k];p;p=p-&gt;next)
            B[++j]=p-&gt;value; //把桶中每个元素取出，排序并加入B
        delete Bucket[k];
        qsort(B+i+1,j-i,sizeof(B[0]),cmp);
    }
}
int main()
{
    int *A,*B,N=100,K=10000,i;
    A=new int[N+1];
    B=new int[N+1];
    for (i=1;i&lt;=N;i++)
        A[i]=rand()%K+1; //生成1..K的随机数
    BucketSort(A,B,N,K);
    for (i=1;i&lt;=N;i++)
        printf(&quot;%d &quot;,B[i]);
    return 0;
}
</code></pre>
<p>[基数排序]<br>
下面说到我们的重头戏，基数排序(Radix Sort)。上述的基数排序和桶排序都只是在研究一个关键字的排序，现在我们来讨论有多个关键字的排序问题。</p>
<p>假设我们有一些二元组(a,b)，要对它们进行以a为首要关键字，b的次要关键字的排序。我们可以先把它们先按照首要关键字排序，分成首要关键字相同的若干堆。然后，在按照次要关键值分别对每一堆进行单独排序。最后再把这些堆串连到一起，使首要关键字较小的一堆排在上面。按这种方式的基数排序称为MSD(Most Significant Dight)排序。</p>
<p>第二种方式是从最低有效关键字开始排序，称为LSD(Least Significant Dight)排序。首先对所有的数据按照次要关键字排序，然后对所有的数据按照首要关键字排序。要注意的是，使用的排序算法必须是稳定的，否则就会取消前一次排序的结果。由于不需要分堆对每堆单独排序，LSD方法往往比MSD简单而开销小。下文介绍的方法全部是基于LSD的。</p>
<p>通常，基数排序要用到计数排序或者桶排序。使用计数排序时，需要的是Order数组。使用桶排序时，可以用链表的方法直接求出排序后的顺序。下面是一段用桶排序对二元组基数排序的程序：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
using namespace std;
struct data
{
    int key[2];
};
struct linklist
{
    linklist *next;
    data value;
    linklist(data v,linklist *n):value(v),next(n){}
    ~linklist() {if (next) delete next;}
};
void BucketSort(data *A,int N,int K,int y)
{
    linklist *Bucket[101],*p;//建立桶
    int i,j,k,M;
    M=K/100+1;
    memset(Bucket,0,sizeof(Bucket));
    for (i=1;i&lt;=N;i++)
    {
        k=A[i].key[y]/M; //把A中的每个元素按照的范围值放入对应桶中
        Bucket[k]=new linklist(A[i],Bucket[k]);
    }
    for (k=j=0;k&lt;=100;k++)
    {
        for (p=Bucket[k];p;p=p-&gt;next) j++;
        for (p=Bucket[k],i=1;p;p=p-&gt;next,i++)
            A[j-i+1]=p-&gt;value; //把桶中每个元素取出
        delete Bucket[k];
    }
}
void RadixSort(data *A,int N,int K)
{
    for (int j=1;j&gt;=0;j--) //从低优先到高优先 LSD
        BucketSort(A,N,K,j);
}
int main()
{
    int N=100,K=1000,i;
    data *A=new data[N+1];
    for (i=1;i&lt;=N;i++)
    {
        A[i].key[0]=rand()%K+1;
        A[i].key[1]=rand()%K+1;
    }
    RadixSort(A,N,K);
    for (i=1;i&lt;=N;i++)
        printf(&quot;(%d,%d) &quot;,A[i].key[0],A[i].key[1]);
    printf(&quot;\n&quot;);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 58. 最后一个单词的长度]]></title>
        <id>https://lixin-ee.github.io//post/zi-fu-chuan-58-zui-hou-yi-ge-dan-ci-de-chang-du</id>
        <link href="https://lixin-ee.github.io//post/zi-fu-chuan-58-zui-hou-yi-ge-dan-ci-de-chang-du">
        </link>
        <updated>2019-09-29T10:05:17.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个仅包含大小写字母和空格 ' ' 的字符串，返回其最后一个单词的长度。<br>
如果不存在最后一个单词，请返回 0 。</p>
<p>说明：一个单词是指由字母组成，但不包含任何空格的字符串。<br>
示例:<br>
输入: &quot;Hello World&quot;<br>
输出: 5</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/length-of-last-word<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题也是简单题，其中主要的要点在于特殊例子。我一开始的想法是单纯地检测空格<br>
1.首先考虑最简单的情况，那就是正常的字符串，比如&quot;hallo world&quot;最后一个空格肯定是在最后一个单词前面，所以可以使用string的搜索算法 find_last_of(&quot; &quot;),然后用length减去返回的下标再减去1，同时适用于空格在字符串一开头的地方，比如&quot; hallo&quot;<br>
2.然后考虑特例之空格符出现在最后并且有单词，此时需要检测两个空格（因为 find_last_of是使用反向迭代器进行搜索的，所以后面所述的第一个对应最后一个）首先对第一个空格的位置进行检测证明loc=len-1，然后注意从第一个空格的位置loc-1开始搜索第二个空格，将第二个空格的位置与第一个空格的位置相减再减1就得到了返回值。与此种情况适用于最后一个单词被一对空格包住或者仅仅是单词+空格的情况，比如&quot;hallo &quot;<br>
3.但是上述情况都无法解决空格重复的情况，比如&quot;hallo     &quot;（后面带有多个空格），仔细思考后发现其实第一次检测可以把find_last_of(&quot; &quot;)改为更好的find_last_not_of(&quot; &quot;)这样子也保证了最后一个单词的存在，结合对单词前面的空格的检测，就能很轻松地得到最后一个单词了。但是注意有一个暗坑：如果没有空格，并且只有一个字母时，返回的下标是0，这个时候如果使用find_last_of(space, i - 1);进行空格探测是会因为-1而从最后一个位置开始检测的（注意在容器下标中是不可以使用-1的，但是此处应该是对size进行取模了），所以必须加上一个if检测。<br>
最后代码如下：</p>
<pre><code>class Solution {
public:
    int lengthOfLastWord(string s) {
		int len = s.size();
		if (len == 0)
			return 0;
		string space = &quot; &quot;;
		int i = s.find_last_not_of(space);
		if (i == string::npos)
			return 0;
		else if (!i)
			return 1;
		int j = s.find_last_of(space, i - 1);
		cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;
		if (j == string::npos)
			return i + 1;
		else
			return i - j; 
    }
};
</code></pre>
<p>其实细节还是蛮多的，比如如果找不到的时候，返回的下标可不是0或者-1，而是string::npos，这个值最好不要直接进行输出，用于比较就好，然后名字域是在string而不是std</p>
<p>然后贴一个网友题解，其实现是和我的想法一致的，只是我用的是封装好的string库函数，而网友的是完整的实现：</p>
<blockquote>
<p>思路<br>
标签：字符串遍历<br>
从字符串末尾开始向前遍历，其中主要有两种情况<br>
第一种情况，以字符串&quot;Hello World&quot;为例，从后向前遍历直到遍历到头或者遇到空格为止，即为最后一个单词&quot;World&quot;的长度5<br>
第二种情况，以字符串&quot;Hello World &quot;为例，需要先将末尾的空格过滤掉，再进行第一种情况的操作，即认为最后一个单词为&quot;World&quot;，长度为5<br>
所以完整过程为先从后过滤掉空格找到单词尾部，再从尾部向前遍历，找到单词头部，最后两者相减，即为单词的长度<br>
时间复杂度：O(n)，n为结尾空格和结尾单词总体长度<br>
代码</p>
</blockquote>
<pre><code>Java
class Solution {
    public int lengthOfLastWord(String s) {
        int end = s.length() - 1;
        while(end &gt;= 0 &amp;&amp; s.charAt(end) == ' ') end--;
        if(end &lt; 0) return 0;
        int start = end;
        while(start &gt;= 0 &amp;&amp; s.charAt(start) != ' ') start--;
        return end - start;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 14. 最长公共前缀]]></title>
        <id>https://lixin-ee.github.io//post/zi-fu-chuan-14-zui-chang-gong-gong-qian-zhui</id>
        <link href="https://lixin-ee.github.io//post/zi-fu-chuan-14-zui-chang-gong-gong-qian-zhui">
        </link>
        <updated>2019-09-28T10:07:52.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>编写一个函数来查找字符串数组中的最长公共前缀。<br>
如果不存在公共前缀，返回空字符串 &quot;&quot;。</p>
<p>示例 1:<br>
输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]<br>
输出: &quot;fl&quot;<br>
示例 2:<br>
输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]<br>
输出: &quot;&quot;<br>
解释: 输入不存在公共前缀。<br>
说明:<br>
所有输入只包含小写字母 a-z 。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/longest-common-prefix<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>嗯既然没什么要求的话我们就来实现一下暴力法吧hhhh，暴力法还是很简单的，首先比较前两个字符串的最长前缀，然后再利用这个最长前缀来比较剩下的字符串，通过比较字符串来缩减最长前缀。要点主要是注意判断条件</p>
<pre><code>class Solution {
public:
    string longestCommonPrefix(vector&lt;string&gt;&amp; strs) {
        int len = strs.size();
        if(len==0)
            return &quot;&quot;;
        if(len == 1)
            return strs[0];
        int share = 0;
        int flen = strs[0].size()&lt;strs[1].size()?strs[0].size():strs[1].size();
        for(int i=0;i&lt;flen;++i,++share)
            if(strs[0][i]!=strs[1][i])
                break;
        if(!share)
            return &quot;&quot;;
        for(int i=2;i&lt;len;++i){
            for(int j=0;j&lt;share;++j)
                if(strs[i][j]!=strs[0][j]){
                    share=j;
                    break;
                }
            if(!share)
            return &quot;&quot;;
        }
        string s(strs[0],0,share);
        return s;      
    }
};
</code></pre>
<p>然后来看一下官方题解：<br>
<img src="https://lixin-ee.github.io//post-images/1569856376903.png" alt=""></p>
<pre><code>public String longestCommonPrefix(String[] strs) {
   if (strs.length == 0) return &quot;&quot;;
   String prefix = strs[0];
   for (int i = 1; i &lt; strs.length; i++)
       while (strs[i].indexOf(prefix) != 0) {
           prefix = prefix.substring(0, prefix.length() - 1);
           if (prefix.isEmpty()) return &quot;&quot;;
       }        
   return prefix;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(S)，S 是所有字符串中字符数量的总和<br>
最坏的情况下，nnn 个字符串都是相同的。算法会将 S1 与其他字符串 [S2…Sn] 都做一次比较。这样就会进行 S 次字符比较，其中 S 是输入数据中所有字符数量。<br>
空间复杂度：O(1)，我们只需要使用常数级别的额外空间。</p>
</blockquote>
<p>算法二：水平扫描<br>
算法<br>
想象数组的末尾有一个非常短的字符串，使用上述方法依旧会进行 S 次比较。优化这类情况的一种方法就是水平扫描。我们从前往后枚举字符串的每一列，先比较每个字符串相同列上的字符（即不同字符串相同下标的字符）然后再进行对下一列的比较。</p>
<pre><code>public String longestCommonPrefix(String[] strs) {
    if (strs == null || strs.length == 0) return &quot;&quot;;
    for (int i = 0; i &lt; strs[0].length() ; i++){
        char c = strs[0].charAt(i);
        for (int j = 1; j &lt; strs.length; j ++) {
            if (i == strs[j].length() || strs[j].charAt(i) != c)
                return strs[0].substring(0, i);             
        }
    }
    return strs[0];
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(S)，S 是所有字符串中字符数量的总和。<br>
最坏情况下，输入数据为 n 个长度为 m 的相同字符串，算法会进行 S=m∗n 次比较。可以看到最坏情况下，本算法的效率与算法一相同，但是最好的情况下，算法只需要进行n∗minLen 次比较，其中 minLen 是数组中最短字符串的长度。<br>
空间复杂度：O(1)，我们只需要使用常数级别的额外空间。<br>
<img src="https://lixin-ee.github.io//post-images/1569856568555.png" alt=""></p>
</blockquote>
<pre><code>public String longestCommonPrefix(String[] strs) {
    if (strs == null || strs.length == 0) return &quot;&quot;;    
        return longestCommonPrefix(strs, 0 , strs.length - 1);
}

private String longestCommonPrefix(String[] strs, int l, int r) {
    if (l == r) {
        return strs[l];
    }
    else {
        int mid = (l + r)/2;
        String lcpLeft =   longestCommonPrefix(strs, l , mid);
        String lcpRight =  longestCommonPrefix(strs, mid + 1,r);
        return commonPrefix(lcpLeft, lcpRight);
   }
}

String commonPrefix(String left,String right) {
    int min = Math.min(left.length(), right.length());       
    for (int i = 0; i &lt; min; i++) {
        if ( left.charAt(i) != right.charAt(i) )
            return left.substring(0, i);
    }
    return left.substring(0, min);
}
</code></pre>
<p><img src="https://lixin-ee.github.io//post-images/1569856685845.png" alt=""><br>
<img src="https://lixin-ee.github.io//post-images/1569856691186.png" alt=""></p>
<pre><code>public String longestCommonPrefix(String[] strs) {
    if (strs == null || strs.length == 0)
        return &quot;&quot;;
    int minLen = Integer.MAX_VALUE;
    for (String str : strs)
        minLen = Math.min(minLen, str.length());
    int low = 1;
    int high = minLen;
    while (low &lt;= high) {
        int middle = (low + high) / 2;
        if (isCommonPrefix(strs, middle))
            low = middle + 1;
        else
            high = middle - 1;
    }
    return strs[0].substring(0, (low + high) / 2);
}

private boolean isCommonPrefix(String[] strs, int len){
    String str1 = strs[0].substring(0,len);
    for (int i = 1; i &lt; strs.length; i++)
        if (!strs[i].startsWith(str1))
            return false;
    return true;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
最坏情况下，我们有n 个长度为 m 的相同字符串。<br>
时间复杂度：O(S⋅log(n))，其中 S 所有字符串中字符数量的总和。<br>
算法一共会进行 log(n) 次迭代，每次一都会进行S=m∗n 次比较，所以总时间复杂度为O(S⋅log(n))。<br>
空间复杂度：O(1)，我们只需要使用常数级别的额外空间。<br>
<img src="https://lixin-ee.github.io//post-images/1569856806624.png" alt=""><br>
class TrieNode {</p>
</blockquote>
<pre><code>class TrieNode {
    // 子节点的链接数组
    private TrieNode[] links;

    private final int R = 26;

    private boolean isEnd;

    // 非空子节点的数量
    private int size;    
    public void put(char ch, TrieNode node) {
        links[ch -'a'] = node;
        size++;
    }

    public int getLinks() {
        return size;
    }
    // 假设方法 containsKey、isEnd、get、put 都已经实现了
    // 可以参考文章：https://leetcode.com/articles/implement-trie-prefix-tree/
}

public class Trie {

    private TrieNode root;

    public Trie() {
        root = new TrieNode();
    }

// 假设方法 insert、search、searchPrefix 都已经实现了
// 可以参考文章：https://leetcode.com/articles/implement-trie-prefix-tree/
    private String searchLongestPrefix(String word) {
        TrieNode node = root;
        StringBuilder prefix = new StringBuilder();
        for (int i = 0; i &lt; word.length(); i++) {
            char curLetter = word.charAt(i);
            if (node.containsKey(curLetter) &amp;&amp; (node.getLinks() == 1) &amp;&amp; (!node.isEnd())) {
                prefix.append(curLetter);
                node = node.get(curLetter);
            }
            else
                return prefix.toString();

         }
         return prefix.toString();
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
最坏情况下查询字符串 q 的长度为 m 并且它与数组中 n 个字符串均相同。<br>
时间复杂度：预处理过程 O(S)，其中 S 数组里所有字符串中字符数量的总和，最长公共前缀查询操作的复杂度为 O(m)。<br>
建立字典树的时间复杂度为 O(S)。在字典树中查找字符串 q 的最长公共前缀在最坏情况下需要 O(m) 的时间。<br>
空间复杂度：O(S)，我们只需要使用额外的 S 空间建立字典树。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 28. 实现 strStr()]]></title>
        <id>https://lixin-ee.github.io//post/zi-fu-chuan-28-shi-xian-strstr</id>
        <link href="https://lixin-ee.github.io//post/zi-fu-chuan-28-shi-xian-strstr">
        </link>
        <updated>2019-09-27T14:50:52.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>实现 strStr() 函数。</p>
<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。<br>
示例 1:<br>
输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;<br>
输出: 2<br>
示例 2:<br>
输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;<br>
输出: -1<br>
说明:</p>
<p>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。<br>
对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p>
</blockquote>
<p>这道题刚好是《大话数据结构》中串章节介绍的KMP模式匹配算法，首先我来实现一下最简单的暴力逐位匹配法：</p>
<pre><code>class Solution {
public:
    int strStr(string haystack, string needle) {
        int lenh=haystack.size();
        int lenn=needle.size();
        if(lenh&lt;lenn)
            return -1;
        if(!lenn)
            return 0;
        for(int i=0;i&lt;lenh-lenn+1;++i)
            for(int j=0;j&lt;lenn;++j){
                if(haystack[i+j]!=needle[j])
                    break;
                if(j==lenn-1)
                    return i;
            }
        return -1;    
    }
};
</code></pre>
<p>暴力法没啥可以担心的，基本测试用例过了，整个都可以通过了，有趣的是leetcode居然显示0ms击败了100%hhh（C++天下第一！）<br>
然后后面来看一下KMP模式匹配算法吧</p>
<pre><code>class Solution {
public:
  
void get_nextval(string &amp;t, vector&lt;int&gt; &amp;nextval) {
	int i, j;
	i = 0;
	j = -1;
	nextval[0] = -1;
	while (i &lt; t.size()-1) {
		if (j == -1 || t[i] == t[j]) {
			++i, ++j;
			if (t[i] != t[j])
				nextval[i] = j;
			else
				nextval[i] = nextval[j];
		}
		else
			j = nextval[j] ;
	}
}

int Index_KPM(string s, string t) {
	int i = 0;
	int j = 0;
	vector&lt;int&gt; nextval(t.size());
	get_nextval(t, nextval);
	while (i&lt;s.size() &amp;&amp; j&lt;int(t.size())) {
		if (j == -1 || s[i] == t[j]) {
			++j, ++i;
		}
		else {
			j = nextval[j];
		}
	}
	if (j &gt;= t.size())
		return i - t.size();
	else
		return -1;
}

    
    int strStr(string haystack, string needle) {
        int lenh=haystack.size();
        int lenn=needle.size();
        if(lenh&lt;lenn)
            return -1;
        if(!lenn)
            return 0;
        return Index_KPM(haystack,needle);
    }
};
</code></pre>
<p>这里有一个比较蛋疼的地方，大话数据结构中字符串下标0用于存储字符串的长度，所以上述的0相应地换成-1的话是处于一个不合法的状态，而因为j可能处于负数的状态，所以是不可以直接和字符串的size（）返回值进行比较的，因为size返回的是无符号数，和负数强行比较的话会隐式转换把负数变成很大的正数，从而导致一直无法进入循环，但是此时编译器是不会报任何错误的。<br>
这里的话建议结合大话数据结构和leetcode上的题解来理解，大话的问题在于很抽象，对用于回退的next数组的含义解释得比较抽象，但是非常好的是循序渐进，先说了next再说nextval这两种递进的情况。然后leetcode题解的好处在与利用有限状态机这个概念解释清楚了next数组直接跳转的含义，比如 ababaaaba对应于011234224（注意大话原文中的下标0用于存储数组长度，所以这里的0其实应该对应于-1），第三个a如果不匹配的话就跳回到3的状态，结合大话的解释就解决了题解中的概念不清晰的问题，两者刚好相辅相成。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 287. 寻找重复数]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-287-xun-zhao-chong-fu-shu</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-287-xun-zhao-chong-fu-shu">
        </link>
        <updated>2019-09-26T08:09:57.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p>
<p>示例 1:<br>
输入: [1,3,4,2,2]<br>
输出: 2<br>
示例 2:<br>
输入: [3,1,3,4,2]<br>
输出: 3<br>
说明：<br>
不能更改原数组（假设数组是只读的）。<br>
只能使用额外的 O(1) 的空间。<br>
时间复杂度小于 O(n2) 。<br>
数组中只有一个重复的数字，但它可能不止重复出现一次。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/find-the-duplicate-number<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这个的话和昨天的相比的话也是比较明显的，普通的方法就是排序加遍历，排序可以分为快速排序和桶排序为主的两种原地排序和非原地排序之分，这两者主要的区别在于空间和时间上的取舍，但是明显地都不符合本题目的要求，所以应该是使用了非排序的方法。<br>
我一开始的时候想过使用每个位置的数组和来检测重复值，但是明显地如果重复数字出现多次的话就无法适用了，所以还是先看官方题解吧</p>
<blockquote>
<p>注释 ：<br>
前面的两种方法不满足提示中给出的约束条件，但它们是您在技术面试中可能会想到的解决方案。作为一名面试官，我个人不希望有人提出循环解决方案。<br>
证明：<br>
证明 nums 中存在至少一个副本是鸽子洞原理的简单应用。这里，nums 中的每个数字都是一个 “鸽子”，nums 中可以出现的每个不同的数字都是一个 “鸽子洞”。因为有 n+1个数是 n 个不同的可能数，鸽子洞原理意味着至少有一个数是重复的。<br>
方法一：排序<br>
如果对数字进行排序，则任何重复的数字都将与排序后的数组相邻。<br>
算法：<br>
算法相当简单。首先，我们对数组进行排序，然后将每个元素与前一个元素进行比较。因为数组中只有一个重复的元素，所以我们知道数组的长度至少为 2，一旦找到重复的元素，我们就可以返回它。</p>
</blockquote>
<pre><code>JavaPython
class Solution {
    public int findDuplicate(int[] nums) {
        Arrays.sort(nums);
        for (int i = 1; i &lt; nums.length; i++) {
            if (nums[i] == nums[i-1]) {
                return nums[i];
            }
        }

        return -1;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(nlgn)。排序调用在 Python 和 Java 中花费 O(nlgn) 时间，因此它支配后续的线性扫描。<br>
空间复杂度：O(1) (or O(n))，在这里，我们对 nums 进行排序，因此内存大小是恒定的。如果我们不能修改输入数组，那么我们必须为 nums 的副本分配线性空间，并对其进行排序。<br>
方法二：集合<br>
如果我们在数组上迭代时存储每个元素，我们可以在数组上迭代时简单地检查每个元素。</p>
<p>算法：<br>
为了实现线性时间复杂性，我们需要能够在恒定时间内将元素插入数据结构（并查找它们）。set 很好地满足这些约束，所以我们迭代数组并将每个元素插入 seen 中。在插入之前，我们检查它是否已经存在。如果是，那么我们找到了我们的副本，所以我们返回它。</p>
</blockquote>
<pre><code>JavaPython
class Solution {
    public int findDuplicate(int[] nums) {
        Set&lt;Integer&gt; seen = new HashSet&lt;Integer&gt;();
        for (int num : nums) {
            if (seen.contains(num)) {
                return num;
            }
            seen.add(num);
        }

        return -1;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)。Python 和 Java 都依赖于底层的哈希表，所以插入和查找有固定的时间复杂度。因此，该算法是线性的，因为它由一个执行 N 次恒定工作的 for 循环组成。<br>
空间复杂度：O(n)，在最坏的情况下，重复元素出现两次，其中一次出现在数组索引 n-1 处。在这种情况下，seen 将包含 n−1 不同的值，因此将占用 O(n) 空间。</p>
<p>方法三：弗洛伊德的乌龟和兔子（循环检测）<br>
如果我们对 nums 进行这样的解释，即对于每对索引 i 和值 v_i而言，“下一个” v_j位于索引 v_i处，我们可以将此问题减少到循环检测。</p>
<p>算法：<br>
首先，我们可以很容易地证明问题的约束意味着必须存在一个循环。因为 nums 中的每个数字都在 1 和 n 之间，所以它必须指向存在的索引。此外，由于 0 不能作为 nums 中的值出现，nums[0] 不能作为循环的一部分。</p>
</blockquote>
<pre><code>class Solution {
    public int findDuplicate(int[] nums) {
        // Find the intersection point of the two runners.
        int tortoise = nums[0];
        int hare = nums[0];
        do {
            tortoise = nums[tortoise];
            hare = nums[nums[hare]];
        } while (tortoise != hare);

        // Find the &quot;entrance&quot; to the cycle.
        int ptr1 = nums[0];
        int ptr2 = tortoise;
        while (ptr1 != ptr2) {
            ptr1 = nums[ptr1];
            ptr2 = nums[ptr2];
        }

        return ptr1;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)。<br>
空间复杂度：O(1)。</p>
</blockquote>
<p>题解一比较简单，我打算自己实现以下快速排序</p>
<pre><code>void QuickSort(vector&lt;int&gt; &amp;vi, vector&lt;int&gt;::iterator low, vector&lt;int&gt;::iterator high) {
	vector&lt;int&gt;::iterator middle;
	if (low &lt; high) {
		middle = partition(vi,low,high);
		QuickSort(vi, low, middle);
		QuickSort(vi, ++middle, high);
	}
}

vector&lt;int&gt;::iterator partition(vector&lt;int&gt; &amp;vi, vector&lt;int&gt;::iterator low, vector&lt;int&gt;::iterator high) {
	int pivotkey;
	if (low &lt; high)
		pivotkey = *low;
	while (low &lt; high) {
	while (low &lt; high&amp;&amp;pivotkey &lt;= *high) 
			--high;
	iter_swap(low, high);
		while (low &lt; high&amp;&amp;*low &lt;= pivotkey) 
			++low;
		iter_swap(low, high);	
	}
	return low;
}
</code></pre>
<p>哇居然被这个弄得有点焦头烂额，因为主要的槽点在于迭代器上，为了提高算法的泛型能力我用了迭代器（bidiretional iterator，支持++和--）而不是数组下标。书里的方法对于middle的两分法是分为 <code>[low,middle-1]、 [middle+1,high]</code> 对于数组下标来说这是小菜一碟，但是对于迭代器来说就不一样了，比如{1，0}这种情况当middle去到了边缘处，如果middle是迭代器，middle+1是没问题的，毕竟还有尾后迭代器，但是middle-1就8行了，所以只能用<code>[low,middle]、 [middle+1,high]</code>算是为了通用性牺牲了一点计算量吧。</p>
<p>题解二是一个集合，最简单的明显就是我一开始想到的set大法啦hhh，因为set的insert会返回一对pair，pair的second就用了bool值反映插入的成功与否，也太方便了吧hhh，当然set的底层是RB-tree，所以其中的操作可不简单，有时间得好好复习stl源码剖析。</p>
<p>第三个题解就是目标解了，不过就好像评论中所说，这个方法实在是太取巧了，颇有一种打哪指哪的感觉hhh<br>
这个方法重点在于把数组视为一个链表，其中的元素值就是指针，如果n+1个元素中有重复的，必然会形成一个内循环。<br>
贴一个网友给的其中的数学原理</p>
<pre><code> #此题转换为链表找环的开始位置，前提条件告诉我们是一定有环
 # 根据floyd判圈办法，一个快指针一个慢指针，二者一定在环上相遇，设相遇点为M点，
 # 快是慢的速度的2倍，时间相同，设慢的距离为s，那么快的距离为2s
 # m为链表头距离环开始位置的距离，k为环开始位置到M点的距离, N为环长度
 # s = m + a*N +k, 2s = m + b*N +k，二者相减，s = (a-b)*N
 # 由此可见，慢指针走过的距离是环长的整数倍，即链表头到M点是环长的整数倍
 # 如果是1倍的话，把m截距离旋转到环上，跟环融合，那么链表头一定落在M点，
# 即fast和slow都落在M点，那么二者到环开始位置距离相同，必然在此处相遇。
# 如果是N倍（N&gt;1）时，只不过slow指针多转几圈而已，后二者仍在此处相遇
</code></pre>
<pre><code>class Solution {
public:
    int findDuplicate(vector&lt;int&gt;&amp; nums) {
        int len=nums.size();
        if(len&lt;2)
            return 0;
        if(len==2)
            return nums[0];
        int fast=nums[0],slow=nums[0];
        do{
            slow=nums[slow];
            fast=nums[nums[fast]];
        }while(fast!=slow);
        fast=nums[0];
        while(slow!=fast){
            slow=nums[slow];
            fast=nums[fast];
        }
        return fast;
    }
};
</code></pre>
<p>比较难理解的就在于这一段了，这一段增速都是一致的，但是最后的落点只是值相同，而不是同一个点 比如{1，2，3，4，5，2}，m为2 M为5 环长度为4 5-2+1=4，此时slow从5出发，fast从1出发，大家都是只需一步就去到了2，但是并不是同一个2</p>
<pre><code>fast=nums[0];
        while(slow!=fast){
						slow=nums[slow];
						fast=nums[fast];
        }
</code></pre>
<p>然后网友给出了更有趣的一个重复数二分法，既符合了条件，又不会有太针对性的感觉。</p>
<blockquote>
<p>方法：二分法<br>
关键：这道题的关键是对要定位的“数”做二分，而不是对数组的索引做二分。要定位的“数”根据题意在 11 和 nn 之间，每一次二分都可以将搜索区间缩小一半。</p>
<p>以 <code>[1, 2, 2, 3, 4, 5, 6, 7]</code> 为例，一共有 8 个数，每个数都在 1 和 7 之间。1 和 7 的中位数是 4，遍历整个数组，统计小于 4 的整数的个数，至多应该为 3 个，如果超过 3 个就说明重复的数存在于区间 <code>[1,4)</code>（注意：左闭右开）中；否则，重复的数存在于区间 [4,7]（注意：左右都是闭）中。这里小于 4 的整数有 4 个（它们是 1, 2, 2, 3），因此砍掉右半区间，连中位数也砍掉。以此类推，最后区间越来越小，直到变成 1 个整数，这个整数就是我们要找的重复的数。</p>
</blockquote>
<p>参考代码 1：</p>
<pre><code>C++
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

class Solution {
public:
    int findDuplicate(vector&lt;int&gt; &amp;nums) {
        int len = nums.size();
        int left = 0;
        int right = len - 1;

        while (left &lt; right) {
            int mid = (left + right) &gt;&gt; 1;
            int counter = 0;
            for (int num:nums) {
                if (num &lt;= mid) {
                    counter++;
                }
            }

            if (counter &gt; mid) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
};
</code></pre>
<blockquote>
<p>说明：1、在 Python 中，整除使用 // ，如果使用 / ，在不能整除的时候，会返回一个小数；<br>
2、之所以写成 mid = left + (right - left + 1) // 2 ，是因为下面的分支条件是：left = mid 和 right = mid - 1，如果写成 mid = left + (right - left) // 2 就会陷入死循环。我们还是以具体例子为例。<br>
当一个整数数组（按升序排列）的个数为奇数时，不论 mid = left + (right - left) // 2 和 mid = left + (right - left + 1) // 2 都落在了相同的一个数，大家不妨拿 [1,2,3,4,5] 做验证；</p>
<p>当一个整数数组（按升序排列）的个数为偶数时：<br>
（1） mid = left + (right - left) // 2 找到的是中间位置偏左的元素；<br>
（2） mid = left + (right - left + 1) // 2 找到的是中间位置偏右的元素。<br>
可以拿 [1,2,3,4] 验证。<br>
因此如果分支是：left = mid 和 right = mid - 1，说明，当只有 2 个元素的时候，中位数不能取左边，否则会出现死循环，因此中位数的取法是 mid = left + (right - left + 1) // 2。<br>
如果分支是：left = mid + 1 和 right = mid，说明，当只有 2 个元素的时候，中位数不能取右边，否则会出现死循环，因此中位数的取法是 mid = left + (right - left) // 2。</p>
<p>3、<code>while left &lt; right</code> 一定是严格小于，这样退出循环的时候就一定有 l==r 成立，就不必纠结该返回 l 还是 r 了。</p>
<p>总结一下：while left &lt; right 一定是严格小于，最后把一个区间“夹逼”成一个数，二分法先写两个分支，再根据分支的情况，调整如何取中点。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 164. 最大间距]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-164-zui-da-jian-ju</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-164-zui-da-jian-ju">
        </link>
        <updated>2019-09-25T14:44:26.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。<br>
如果数组元素个数小于 2，则返回 0。</p>
<p>示例 1:<br>
输入: [3,6,9,1]<br>
输出: 3<br>
解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。<br>
示例 2:<br>
输入: [10]<br>
输出: 0<br>
解释: 数组元素个数小于 2，因此返回 0。<br>
说明:<br>
你可以假设数组中所有元素都是非负整数，且数值在 32 位有符号整数范围内。<br>
请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/maximum-gap<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这一题的话比较特殊吧，因为题目其实很明显了，如果用最显眼的方法那就无非是快速排序+遍历相减了，时间复杂度明显是o(nlogn+n)，但是题目又明显地让我们用线性的空间复杂度来换线性的时间复杂度，很明显应该用桶排序了，所以先来看一下题解吧：</p>
<blockquote>
<p>方法 1：比较排序<br>
想法<br>
按照题意实现。</p>
<p>算法<br>
将整个数组排序后，遍历数组找到相邻元素间的最大间距。</p>
</blockquote>
<pre><code>C++
int maximumGap(vector&lt;int&gt;&amp; nums)
{
    if (nums.empty() || nums.size() &lt; 2)            // check if array is empty or small sized
        return 0;
    sort(nums.begin(), nums.end());                 // sort the array
    int maxGap = 0;
    for (int i = 0; i &lt; nums.size() - 1; i++)
        maxGap = max(nums[i + 1] - nums[i], maxGap);
    return maxGap;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(nlogn)。排序的复杂度是 O(nlogn)，遍历的复杂度是 O(n)，总复杂度是O(nlogn)。<br>
空间复杂度：除去输入数组之外，不需要额外空间（因为大多数都是原地排序）。</p>
<p>方法 2：基数排序<br>
算法<br>
这个方法与第一种方法相似，不过我们基于基数排序而非传统的比较排序。</p>
</blockquote>
<pre><code>c++
int maximumGap(vector&lt;int&gt;&amp; nums)
{
    if (nums.empty() || nums.size() &lt; 2)
        return 0;

    int maxVal = *max_element(nums.begin(), nums.end());

    int exp = 1;                                 // 1, 10, 100, 1000 ...
    int radix = 10;                              // base 10 system

    vector&lt;int&gt; aux(nums.size());

    /* LSD Radix Sort */
    while (maxVal / exp &gt; 0) {                   // Go through all digits from LSD to MSD
        vector&lt;int&gt; count(radix, 0);

        for (int i = 0; i &lt; nums.size(); i++)    // Counting sort
            count[(nums[i] / exp) % 10]++;

        for (int i = 1; i &lt; count.size(); i++)   // you could also use partial_sum()
            count[i] += count[i - 1];

        for (int i = nums.size() - 1; i &gt;= 0; i--)
            aux[--count[(nums[i] / exp) % 10]] = nums[i];

        for (int i = 0; i &lt; nums.size(); i++)
            nums[i] = aux[i];

        exp *= 10;
    }

    int maxGap = 0;

    for (int i = 0; i &lt; nums.size() - 1; i++)
        maxGap = max(nums[i + 1] - nums[i], maxGap);

    return maxGap;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(d⋅(n+k))≈O(n)<br>
由于在数组上的线性迭代是接近线性复杂度，所以方法的时间性能瓶颈主要是基数排序。<br>
基数排序以计数排序为基础。</p>
<p>计数排序时间复杂度是 O(n+k)，其中 k 是数组 n个元素的基数（数字个数）。如果 k≤O(n)，计数排序可以在线性时间内完成。在我们的例子中，基数是固定的（比如，k = 10），因此计数排序运行时间是线性的 O(n)。<br>
基数排序运行 d 轮计数排序（其中每个元素由最多 d 个数字组成）。因此有效运行时间是 O(d⋅(n+k))，但在我们的例子中，最大可能的 32 位有符号是 2147483647，因此d≤10 是常数。<br>
因此基数排序的时间效率是 O(n)。<br>
空间复杂度：O(n+k)≈O(n)额外空间。</p>
<p>计数排序需要额外 O(k) 空间，基数排序需要一个和输入数组相同大小的辅助数组。然而给定的 k 是一个固定小常数，所以在大输入情况下计数排序的额外空间是可以被忽略的。</p>
</blockquote>
<blockquote>
<p>方法 3：桶和鸽笼原理<br>
想法</p>
<p>对整个数组排序的代价很大，最坏情况下需要让每个元素都和其他所有元素比较。</p>
<p>如果我们不需要比较所有元素对呢？如果我们将元素分类，比如说用桶，这个想法将是可能的。我们只需要比较这些桶即可。</p>
<p>题外话：鸽笼原理</p>
<p>鸽笼原理描述说，n 个物品放入 m个容器中，如果 n&gt;m 那么一定有一个容器装有至少两个物品。</p>
<p>假设对于数组中的任意一个元素都有一个桶，那么每个元素恰好占据一个桶。现在减少桶的个数，必然会有一些桶包含超过一个元素。</p>
<p>现在讨论元素之间的间距。考虑最好情况，假设元素排好序且两两之间间距相同。这意味着任意相邻元素都有恒定的差值。所以 n 个元素有 n−1 个间距，假设为 t，显然可以得到 t=(max−min)/(n−1)，其中 max 和 min 是数组中最大和最小的元素。这个间距就是相邻元素间最大间距，也就是我们要的答案。</p>
<p>显然，t 是具有相同数量（n）和相同区间（max−min）的数组中，都可以满足的最小值。证明：假设从一个相等间距的数组出发，改变相邻量元素的间距，假设将 arr[i−1] 和arr[i] 之间的间距变成 t−p，那么 arr[i] 和 arr[i+1] 之间的间距就增长为 t+p。因此最大间距就从 t 变成了t+p，因此最大间距 t只会增加。</p>
<p>桶！</p>
<p>回到我们的问题，我们已经了解了鸽笼原理的应用，那么如果我们用桶来代替单独元素作比较，比较的次数会减小，因为桶中可能有多个元素。这并不能马上解决完这个问题。如果在桶中比较元素？那问题将会得到很好解决。</p>
<p>所以现在的想法是：如果我们只需要在桶之间相互比较，而不用比较桶内的元素，看起来会非常理想。这也将解决排序问题：只需要将元素分配到合适的桶中，因为桶已经有序，所以我们只需要比较桶，不需要将所有元素排序并比较了。</p>
<p>说明</p>
<p>以下是一些说明：</p>
<p>桶的大小是相同的嘛？<br>
是的，他们大小都为 bb。</p>
<p>那么桶之间的间距也是固定的嘛？<br>
是的，桶之间的间距是 1。这意味着两个大小为 3 的相邻桶分别代表的区间是 3 - 63−6 和 4 - 74−7。不会出现重叠。</p>
<p>为什么说两个相邻桶之间可能出现最大间距？<br>
桶的大小也就是桶的容积，是桶可以容纳的最大区间范围。然而桶内的区间范围取决于桶内最大元素和最小元素的差值。例如一个大小为 55 的桶包含值域 6-106−10，它保存了元素 7,8,97,8,9 那么实际容积就是 (9 - 7) + 1 = 3(9−7)+1=3 与桶的大小不相等。</p>
<p>如何比较相邻两个桶？<br>
我们比较实际范围，也就是前一个桶的最大元素和后一个桶的最小元素。比如说，两个大小为 55 的桶，分别保存元素 [1,2,3][1,2,3] 和 [9,10][9,10]，那么桶之间的间距就是 9-3=69−3=6（大于任意一个桶的大小）。</p>
<p>是否还要再比较一次元素？！<br>
是的，需要！但只需要比较两倍桶个数的元素（每个桶的最大最小元素）。如果按照上面的做法，你会发现当选择了合适的桶大小时，比较次数远远小于数组中实际元素个数。</p>
<p>算法</p>
<p>选择合适的桶大小 bb 满足 1&lt;b≤(max−min)/(n−1)。设 b=⌊(max−min)/(n−1)⌋。<br>
所有 n 个元素被分为 k=⌈(max−min)/b⌉ 个桶。<br>
因此第 i 个桶保存的值区间为：[min+(i−1)∗b, min+i∗b)（下标从 1 开始）。<br>
显然很容易计算出每个元素属于哪个桶，floor⌊(num−min)/b⌋（下标从 0 开始）其中 num 是元素的值。<br>
当所有 n 个元素都遍历过后，比较 k−1 个相邻桶找到最大间距。</p>
</blockquote>
<pre><code>c++
class Bucket {
public:
    bool used = false;
    int minval = numeric_limits&lt;int&gt;::max();        // same as INT_MAX
    int maxval = numeric_limits&lt;int&gt;::min();        // same as INT_MIN
};

int maximumGap(vector&lt;int&gt;&amp; nums)
{
    if (nums.empty() || nums.size() &lt; 2)
        return 0;

    int mini = *min_element(nums.begin(), nums.end()),
        maxi = *max_element(nums.begin(), nums.end());

    int bucketSize = max(1, (maxi - mini) / ((int)nums.size() - 1));        // bucket size or capacity
    int bucketNum = (maxi - mini) / bucketSize + 1;                         // number of buckets
    vector&lt;Bucket&gt; buckets(bucketNum);

    for (auto&amp;&amp; num : nums) {
        int bucketIdx = (num - mini) / bucketSize;                          // locating correct bucket
        buckets[bucketIdx].used = true;
        buckets[bucketIdx].minval = min(num, buckets[bucketIdx].minval);
        buckets[bucketIdx].maxval = max(num, buckets[bucketIdx].maxval);
    }

    int prevBucketMax = mini, maxGap = 0;
    for (auto&amp;&amp; bucket : buckets) {
        if (!bucket.used)
            continue;

        maxGap = max(maxGap, bucket.minval - prevBucketMax);
        prevBucketMax = bucket.maxval;
    }

    return maxGap;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n+b)≈O(n)。<br>
线性遍历一遍数组中的元素，复杂度为 O(n)。找到桶之间的最大间距需要线性遍历一遍所有的桶，复杂度为 O(b)。所以总复杂度是线性的。<br>
空间复杂度：O(2⋅b)≈O(b) 的额外空间。<br>
每个桶只需要存储最大和最小元素，因此额外空间和桶个数线性相关。</p>
</blockquote>
<p>第一个题解就没啥好说的啦，第二个题解也是为了引出第三个题解，第三个题解的重点在于如何分配桶的容量和桶的个数，然后细节之处就在于桶的容量个数的计算和某个元素落入哪个桶的取值计算（floor和ceil的取舍），以及最后如何遍历桶（只保留每个桶的最大最小值，然后对比每个桶的差），我在细节处栽了很多跟头，即使知道了题解，还是得细心啊，而且得回去重新看一遍计数排序、基数排序和桶排序的那个线性时间复杂度的算法！<br>
最后代码如下：</p>
<pre><code>class Solution {
public:
    int maximumGap(vector&lt;int&gt;&amp; nums) {
        int len = nums.size();
	if (len==0||len==1)
		return 0;
	vector&lt;vector&lt;int&gt;&gt; bucket(len, vector&lt;int&gt;(2, -1));
	int max_ele = *max_element(nums.begin(), nums.end()), min_lel = *min_element(nums.begin(), nums.end());
	int cap = ceil((double)(max_ele - min_lel) / (double)(len - 1));
        if(!cap)
            return 0;
	for (auto i : nums) {
		int n = (i - min_lel) / cap;
		if (bucket[n][0] == -1)
			bucket[n][0] = i, bucket[n][1] = i;
		else {
			bucket[n][0] = bucket[n][0] &lt; i ? bucket[n][0] : i;
			bucket[n][1] = bucket[n][1] &gt; i ? bucket[n][1] : i;
		}
	}
	int diff = 0;
	int temp = bucket[0][1];
	for (int i = 1; i &lt; len ; ++i) {
		if (bucket[i][0] != -1)
			diff = bucket[i][0] - temp&gt;diff? bucket[i][0] - temp:diff , temp = bucket[i][1];
	}
	return diff;
    }
};
</code></pre>
]]></content>
    </entry>
</feed>