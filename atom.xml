<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-12-28T15:16:18.092Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[[Linux基础] 系统登录与关机（鸟哥Linux第四章）]]></title>
        <id>https://lixin-ee.github.io//post/linux-ji-chu-xi-tong-deng-lu-yu-guan-ji-niao-ge-linux-di-si-zhang</id>
        <link href="https://lixin-ee.github.io//post/linux-ji-chu-xi-tong-deng-lu-yu-guan-ji-niao-ge-linux-di-si-zhang">
        </link>
        <updated>2019-12-28T13:51:28.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>X window<br>
文本模式为终端机接口, terminal 或 console<br>
Linux 预设的情况下会提供六个 Terminal 来让使用者登入， 切换的方式为使用：[Ctrl] + [Alt] + [F1]~[F6]的组合按钮。<br>
系统会将[F1] ~ [F6]命名为 tty1 ~ tty6 的操作接口环境。</li>
</ul>
<ul>
<li>[Ctrl] + [Alt] + [F2] ~ [F6] ：文字接口登入 tty2 ~ tty6 终端机；</li>
<li>[Ctrl] + [Alt] + [F1] ：图形接口桌面。</li>
</ul>
<p>文本模式登入后所取得的程序被称为壳(Shell)，这是因为这 支程序负责最外面跟使用者(我们)沟通，所以才被戏称为壳程序</p>
<p>个人体会：<br>
这一点对于我没装图形界面的centos来说非常重要，毕竟没有鼠标，纯靠键盘操作<br>
6个terminal或者说shell就相当于6个进程，如果一个阻塞了就需要切换到另外一个继续进行工作</p>
<ul>
<li>开始下达指令<br>
command [-options] parameter1 parameter2</li>
</ul>
<ol>
<li>一行指令中第一个输入的部分绝对是『指令(command)』或『可执行文件案(例如批次脚本,script)』</li>
<li>command 为指令的名称，例如变换工作目录的指令为 cd 等等；</li>
<li>中刮号[]并不存在于实际的指令中，而加入选项设定时，通常选项前会带号，例如 -h；有时候会使用选项的完整全名，则选项前带有 -- 符号，例如 --help；</li>
<li>parameter1 parameter2.. 为依附在选项后面的参数，或者是 command 的参数；</li>
<li>指令, 选项, 参数等中间以空格来区分，不论空几格 shell 都视为一格。所以空格是很重要的特殊字符；</li>
<li>按下[Enter]按键后，该指令就立即执行。[Enter]按键代表着一行指令的开始启动。</li>
<li>指令太长的时候，可以使用反斜杠 () 来跳脱[Enter]符号，使指令连续到下一行。注意！反斜杠后就立刻接特殊字符，才能跳脱！</li>
<li>其他：在 Linux 系统中，英文大小写字母是不一样的。举例来说， cd 与 CD 并不同。</li>
</ol>
<p>locale 显示目前支持的语系<br>
修改语系成为英文语系LANG=en_US.utf8   export LC_ALL=en_US.utf8</p>
<p>郁闷，貌似文本模式默认是英文语系</p>
<ul>
<li>基础指令的操作<br>
1.显示日期与时间的指令： date<br>
『+%Y%m%d』就是 date 指令的一些参数功能<br>
从上面的例子当中我们也可以知道，指令之后的选项除了前面带有减号『-』之外，某些特殊情况下，选项或参数前面也会带有正号『+』的情况</li>
</ul>
<p>2.显示日历的指令： cal [month] [year]</p>
<p>3.简单好用的计算器： bc<br>
bc命令进入到 bc 这个软件的工作环境当中，输入的数据当然就得要符合 bc 的要求才行</p>
<ul>
<li>加法 减法 * 乘法  / 除法  ^ 指数  % 余数<br>
因为 bc 预设仅输出整数，如果要输出小数点下位数，那么就 必须要执行 scale=number ，那个 number 就是小数点位数，<br>
输入『quit』来离开 bc 的软件环境</li>
</ul>
<p>小插曲：<br>
尴尬，我的centos居然没有默认安装bc，必须通过sudo  yum -y install bc来在线安装</p>
<ul>
<li>重要的几个热键</li>
</ul>
<p>[Tab] 具有『命令补全』与『文件补齐』的功 能<br>
1.[Tab] 接在一串指令的第一个字的后面，则为『命令补全』； 2. [Tab] 接在一串指令的第二个字以后时，则为『文件补齐』！<br>
3.若安装 bash-completion 软件，则在某些指令后面使用 [tab] 按键时，可以进行『选项/参数的补齐』功能！</p>
<p>[Ctrl]-c 中断目前程序 将正在运作中的指令中断</p>
<p>[Ctrl]-d<br>
1.键盘输入结束(End Of File, EOF 或 End Of Input)』2. 可以用来取代 exit 的输入，想要直接 离开文字接口，可以直接按下[Ctrl]-d 就能够直接离开了(相当于输入 exit 啊！)</p>
<p>[shift]+{[PageUP]|[Page Down]} 按键<br>
纯文本的画面中执行某些指令，当这个指令的输出讯息相当长导致前面的部份已经不 在目前的屏幕画面中，可以使用 [Shift]+[Page Up] 来往前翻页，也能够使用 [Shift]+[Page Down] 来往后翻页<br>
这条命令超重要！！！我一开始以为是直接{[PageUP]|[Page Down]} 就能翻页了，结果发现是历史命令的切换。。。</p>
<ul>
<li>
<p>错误讯息的察看<br>
下达了错误的指令，可以藉由屏幕上面显示的错误讯息来了解你的问题点，</p>
</li>
<li>
<p>指令的 –help<br>
开发者会将可以使用的指令语法与参数写入指令 操作过程中<br>
通常 --help 用在协助你查询『你曾经用过的指令所 具备的选项与参数』</p>
</li>
<li>
<p>man page<br>
如果你要使用的是从来没有用过得指令，或者是你要查询的根本就不是 指令，而是文件的『格式』时，那就得要透过 man page<br>
man 是 manual(操作说明)的简写</p>
</li>
<li>
<p>命令后面的数字(num)<br>
在表格的第一行，你可以看到的是：『DATE(1)』，DATE是指令的名称， (1) 代表查询数据的后面的数字是有意义</p>
</li>
</ul>
<p>这里也是很重要啊，虽然说区别不是很大，但是有时候还是需要对着表查找的<br>
<img src="https://lixin-ee.github.io//post-images/1577542417254.png" alt=""><br>
例如下达了『man null』时，会出现的第一行是：『NULL(4)』，对照一下上面的数字意义， 原来 null是一个『装置文件』</p>
<p>查询某个数据时是这样来查阅的：</p>
<ol>
<li>先察看 NAME 的项目，约略看一下这个资料的意思；</li>
<li>再详看一下 DESCRIPTION，这个部分会提到很多相关的资料与使用时机，从这个地方可以学到很多小细节 呢；</li>
<li>而如果这个指令其实很熟悉了(例如上面的 date)，那么鸟哥主要就是查询关于 OPTIONS 的部分了！ 可以知 道每个选项的意义，这样就可以下达比较细部的指令内容呢！</li>
<li>最后，鸟哥会再看一下，跟这个资料有关的还有哪些东西可以使用的？举例来说，上面的 SEE ALSO 就告 知我们还可以利用『info coreutils date』来进一步查阅数据；</li>
<li>某些说明内容还会列举有关的文件(FILES 部分)</li>
</ol>
<p>搜寻字符串：在man page，当你按下『/』之后，光标就会移动到屏幕的最下面一行， 并等待你输入搜寻的字符串</p>
<p>在 man page 的画面当中能使用的按键<br>
<img src="https://lixin-ee.github.io//post-images/1577542615324.png" alt=""></p>
<p>man -f command 搜索与command这个指令有关的说明文件（亦即不同的数字后缀）</p>
<p>man -k keywords<br>
在某些情况下忘记了 该指令的完整名称，或者只记得该指令的部分关键词，使用 –k选项，利用关键词将说明文件里面只要含有关键词的(不见得是完整字符串) 就 将他取出来</p>
<p>whatis [ 指令或者是 数 据 ] &lt;==相当于 man -f [指令或者是数据]<br>
apropos [ 指令或者是 数 据 ] &lt;==相当于 man -k [指令或者是数据]<br>
这两个特殊指令必须要有建立 whatis 数据库才行，需要使用root 的身份下达mandb指令</p>
<ul>
<li>info page<br>
info 与 man 的用途其实差不多，都是用来查询指令的用法或者是文件的格式。<br>
与 man page 一口气输出一堆信息不同的是，info page 则是将文件数据拆成一个一个的段落，每个段落用自己的页 面来撰写， 并且在各个页面中还有类似网页的『超链接』来跳到各不同的页面中，每个独立的页面 也被称为一个节点(node)。</li>
</ul>
<p>info page第一行里面的数据意义为：</p>
<ul>
<li>File：代表这个 info page 的资料是来自 info.info 文件所提供的；</li>
<li>Node：代表目前的这个页面是属于 Top 节点。 意思是 info.info 内含有很多信息，而 Top 仅是 info.info 文件 内的一个节点内容而已；</li>
<li>Next：下一个节点的名称为 Getting Started，你也可以按『N』到下个节点去；</li>
<li>Up：回到上一层的节点总揽画面，你也可以按下『U』回到上一层；</li>
<li>Prev：前一个节点。但由于 Top 是 info.info 的第一个节点，所以上面没有前一个节点的信息。</li>
</ul>
<p>info 的说明文件将内容分成多个 node，并且每个 node 都有定位与连结。 在各连结之 间还可以具有类似『超链接』的快速按钮，可以透过[tab]键在各个超链接间移动。</p>
<p>你可以透过直接按 下 N, P, U 来去到下一个、上一个与上一层的节点(node)<br>
『Menu』底下共分为四小节，分别是 Getting Started 等等的，我们 可以使用上下左右按键来将光标移动到该文字或者『 * 』上面，按下 Enter， 就可以前往该小节了！ 另外，也可以按下[Tab]按键，就可以快速的将光标在上表的画面中的 node 间移动，</p>
<ul>
<li>总结</li>
</ul>
<ul>
<li>在终端机模式中，如果你知道某个指令，但却忘记了相关选项与参数，请先善用 --help 的功能来查询相关 信息；</li>
<li>当有任何你不知道的指令或文件格式这种玩意儿，但是你想要了解他，请赶快使用 man 或者是 info 来查询！</li>
</ul>
<ul>
<li>超简单文书编辑器： nano<br>
nano text.txt开启一个名为 text.txt 的档名<br>
比较重要的几个组合按键：</li>
</ul>
<ul>
<li>[ctrl]-G：取得联机帮助(help)，很有用的！</li>
<li>[ctrl]-X：离开 naon 软件，若有修改过文件会提示是否需要储存喔！</li>
<li>[ctrl]-O：储存文件，若你有权限的话就能够储存文件了；</li>
<li>[ctrl]-R：从其他文件读入资料，可以将某个文件的内容贴在本文件中；</li>
<li>[ctrl]-W：搜寻字符串，这个也是很有帮助的指令喔！</li>
<li>[ctrl]-C：说明目前光标所在处的行数与列数等信息；</li>
<li>[ctrl]-_：可以直接输入行号，让光标快速移动到该行；</li>
<li>[alt]-Y：校正语法功能开启或关闭(单击开、再单击关)</li>
<li>[alt]-M：可以支持鼠标来移动光标的功能</li>
</ul>
<ul>
<li>正确的关机方法<br>
<strong>这个非常重要！！！就算是虚拟机也要好好关机！！！</strong><br>
若不正常关机，则可能造成文件系统的毁损<br>
-观察系统的使用状态： 如果要看目前有谁在在线，可以下达『who』这个指令，而如果要看网络的联机状态，可以下达 『 netstat -a 』 这个指令，而要看背景执行的程序可以执行『 ps -aux 』这个指令。使用这些指令可以让你稍微了解主机 目前的使用状态！当然啰，就可以让你判断是否可以关机了 （这些指令在后面 Linux 常用指令中会提及喔！）</li>
</ul>
<ul>
<li>通知在线使用者关机的时刻： 要关机前总得给在线的使用者一些时间来结束他们的工作，所以，这个时候你可以使用 shutdown 的特别指 令来达到此一功能。</li>
<li>正确的关机指令使用： 例如 shutdown 与 reboot 两个指令！</li>
</ul>
<p>几个与关机/重新启动相关的指令啰</p>
<ul>
<li>将数据同步写入硬盘中的指令： sync</li>
<li>惯用的关机指令： shutdown</li>
<li>重新启动，关机： reboot, halt, poweroff</li>
</ul>
<p>由于 Linux 系统的关机/重新启动是很重大的系统运作，因此只有 root 才能够进行例如 shutdown, reboot 等指令</p>
<p>数据同步写入磁盘： sync<br>
直接在文字接口下 输入 sync，那么在内存中尚未被更新的数据，就会被写入硬盘中<br>
shutdown/reboot/halt 等等指令均已经在关机前进行了 sync 这个工具的呼叫<br>
sync 也可以被一般账号使用,只不过一般账号用户所更新的硬盘数据就仅有 自己的数据，不像 root 可以更新整个系统中的数据了。</p>
<p>惯用的关机指令： shutdown<br>
就只有 root 有权力而已<br>
shutdown 可以达成如下的工作：</p>
<ul>
<li>可以自由选择关机模式：是要关机或重新启动均可；</li>
<li>可以设定关机时间: 可以设定成现在立刻关机, 也可以设定某一个特定的时间才关机。</li>
<li>可以自定义关机讯息：在关机之前，可以将自己设定的讯息传送给在线 user 。</li>
<li>可以仅发出警告讯息：有时有可能你要进行一些测试，而不想让其他的使用者干扰，或者是明白的告诉使 用者某段时间要注意一下！这个时候可以使用 shutdown 来吓一吓使用者，但却不是真的要关机啦！</li>
</ul>
<p>/sbin/shutdown [-- krhc] [ 时间 ] [ 警告讯息 ]<br>
选项与参数：<br>
-k ： 不要真的关机，只是发送警告讯息出去！<br>
-r ： 在将系统的服务停掉之后就重新启动(常用)<br>
-h ： 将系统的服务停掉后，立即关机。 (常用)<br>
-c ： 取消已经在进行的 shutdown 指令内容。<br>
时间 ： 指定系统关机的时间！时间的范例底下会说明。若没有这个项目，则默认 1 分钟后自动进行。<br>
范例： [root@study ~]# /sbin/shutdown -h 10 'I will shutdown after 10 mins’</p>
<p>可以输入『 shutdown -c 』来取消关机指令</p>
<p>新版的shutdown可省略时间参数 会以 1 分钟为限，进行自动关机的任务<br>
[root@study ~]# shutdown- h now<br>
立刻关机，其中 now 相当于时间为 0 的状态<br>
[root@study ~]# shutdown- h 20:25<br>
系统在今天的 20:25 分会关机，若在 21:25 才下达此指令，则隔天才关机<br>
[root@study ~]# shutdown- h +10<br>
系统再过十分钟后自动关机<br>
[root@study ~]# shutdown- r now<br>
系统立刻重新启动<br>
[root@study ~]# shutdown- r +30 'The system will reboot'<br>
再过三十分钟系统会重新启动，并显示后面的讯息给所有在在线的使用者<br>
[root@study ~]# shutdown- k now 'This system will reboot'<br>
仅发出警告信件的参数！系统并不会关机啦！吓唬人！</p>
<p>重新启动，关机： reboot, halt, poweroff<br>
有三个指令可以进行重新启动与关机的任务，那就是 reboot, halt, poweroff<br>
基本上，在预设的情况下， 这几个 指令都会完成一样的工作</p>
<p>实际使用管理工具 systemctl 关机<br>
systemctl：系统中所有服务的管理<br>
上面谈到的 halt, poweroff, reboot, shutdown 等等，其实都是呼叫这个 systemctl 指令<br>
这 个指令跟关机有关的语法如下：<br>
[root@study ~]# systemctl [ 指令]<br>
指令项目包括如下：<br>
halt 进入系统停止的模式，屏幕可能会保留一些讯息，这与你的电源管理模式有关<br>
poweroff 		进入系统关机模式，直接关机没有提供电力喔！<br>
reboot 			直接重新启动<br>
suspend 		进入休眠模式<br>
[root@study ~]# systemctl reboot # 系统重新启动<br>
[root@study ~]# systemctl poweroff # 系统关机</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 9. 回文数[简单][未做出]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-9-hui-wen-shu-jian-dan-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-9-hui-wen-shu-jian-dan-wei-zuo-chu">
        </link>
        <updated>2019-12-28T02:18:26.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。<br>
示例 1:<br>
输入: 121<br>
输出: true<br>
示例 2:<br>
输入: -121<br>
输出: false<br>
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。<br>
示例 3:<br>
输入: 10<br>
输出: false<br>
解释: 从右向左读, 为 01 。因此它不是一个回文数。<br>
进阶:<br>
你能不将整数转为字符串来解决这个问题吗？<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/palindrome-number<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>第一想法肯定是转化为string然后双指针了<br>
然后想一下怎么对int处理吧，比较难的就是怎么判断int的位数了<br>
考虑使用位运算符<br>
傻了想复杂了。。。其实完全就是可以把数字取余本身翻转再比较是否相等的嘛 但是这个方法有溢出的风险（但是其实int的特性决定了不会溢出，因为INT_MAX是2147483647，要对称只能个位是2，所以溢出的回文数根本不能存在int里面）<br>
然后官方题解更加6，直接判断一半就行了，值得学习<br>
自己实现官方题解的时候，发现问题是121这种奇数位的数怎么处理<br>
傻逼了写成temp+=10* remain;了<br>
在100这种数上面遇到难题了<br>
看了题解发现自己还是自作聪明了 根本不需要中间的判断 但是需要在前面加上判断</p>
<pre><code>class Solution {
public:
    bool isPalindrome(int x) {
       if(x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) {
            return false;
        }

        int temp=0;
        while(temp&lt;x){
            temp=temp*10+x%10;  
            x/=10;        
        }
        return temp==x||temp/10==x;
    }
    /*
    //转string解法
    bool isPalindrome(int x) {
        if(x&lt;0) return false;
        string s=to_string(x);
        auto beg=s.begin(),end=s.end()-1;
        while(beg&lt;end){
            if(*beg!=*end)
                return false;
            ++beg,--end;
        }
        return true;
    }
    */
};
</code></pre>
<p>我参照的官方题解</p>
<blockquote>
<p>方法：反转一半数字<br>
思路<br>
映入脑海的第一个想法是将数字转换为字符串，并检查字符串是否为回文。但是，这需要额外的非常量空间来创建问题描述中所不允许的字符串。<br>
第二个想法是将数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。<br>
但是，如果反转后的数字大于 int.MAX，我们将遇到整数溢出问题。<br>
按照第二个想法，为了避免数字反转可能导致的溢出问题，为什么不考虑只反转 int 数字的一半？毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。<br>
例如，输入 1221，我们可以将数字 “1221” 的后半部分从 “21” 反转为 “12”，并将其与前半部分 “12” 进行比较，因为二者相同，我们得知数字 1221 是回文。<br>
让我们看看如何将这个想法转化为一个算法。<br>
算法<br>
首先，我们应该处理一些临界情况。所有负数都不可能是回文，例如：-123 不是回文，因为 - 不等于 3。所以我们可以对所有负数返回 false。<br>
现在，让我们来考虑如何反转后半部分的数字。<br>
对于数字 1221，如果执行 1221 % 10，我们将得到最后一位数字 1，要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 1221 中移除，1221 / 10 = 122，再求出上一步结果除以 10 的余数，122 % 10 = 2，就可以得到倒数第二位数字。如果我们把最后一位数字乘以 10，再加上倒数第二位数字，1 * 10 + 2 = 12，就得到了我们想要的反转后的数字。如果继续这个过程，我们将得到更多位数的反转数字。<br>
现在的问题是，我们如何知道反转数字的位数已经达到原始数字位数的一半？<br>
我们将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于反转后的数字时，就意味着我们已经处理了一半位数的数字。</p>
</blockquote>
<pre><code>C#
public class Solution {
    public bool IsPalindrome(int x) {
        // 特殊情况：
        // 如上所述，当 x &lt; 0 时，x 不是回文数。
        // 同样地，如果数字的最后一位是 0，为了使该数字为回文，
        // 则其第一位数字也应该是 0
        // 只有 0 满足这一属性
        if(x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) {
            return false;
        }

        int revertedNumber = 0;
        while(x &gt; revertedNumber) {
            revertedNumber = revertedNumber * 10 + x % 10;
            x /= 10;
        }

        // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。
        // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，
        // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。
        return x == revertedNumber || x == revertedNumber/10;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(log_{10}(n))，对于每次迭代，我们会将输入除以10，因此时间复杂度为 O(log_{10}(n))。<br>
空间复杂度：O(1)。</p>
</blockquote>
<p>需要注意的就是对10的整数倍数字这个特例进行处理了</p>
<pre><code>if(x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) {
            return false;
        }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Linux多线程服务端编程] 第一章读书笔记]]></title>
        <id>https://lixin-ee.github.io//post/linux-duo-xian-cheng-fu-wu-duan-bian-cheng-di-yi-zhang-du-shu-bi-ji</id>
        <link href="https://lixin-ee.github.io//post/linux-duo-xian-cheng-fu-wu-duan-bian-cheng-di-yi-zhang-du-shu-bi-ji">
        </link>
        <updated>2019-12-27T12:07:18.000Z</updated>
        <content type="html"><![CDATA[<p>这本书是师兄以及牛客网大神强烈推荐我阅读的，在阅读完《UNP-unix网络编程》后我就迫不及待地开始读这本书了</p>
<p>经过这几天的阅读，我的体会如下：<br>
这本书主要还是环绕muduo这个网络库来进行讲解，着重点主要是讲解muduo库、作者在设计库的思路以及在基于c++的网络编程方面的经验<br>
（我个人感觉这本书难能可贵之处在于后两者，网上源码成百上千，书籍更是千千万，直接端出源码或者列出知识点只是抬手的功夫，但如能了解一样事物的诞生及其过程中的发展与修正，那对于了解这项事物肯定是大有裨益的，我个人感觉美国与中国之间的IT、教育等差距很大便在于此）<br>
（注意，我的读书笔记并非当天读当天记，而是过几天再记录，因为在前面几本书的阅读中我发现一个体系网络的知识很难分个先后，往往是交织在一起，所以看到往后的章节往往有新的理解与感受）</p>
<p>本书第一部分先以c++下多线程编程作为铺垫<br>
第一章主要讲述线程安全的对象生命期管理</p>
<p>与linux书籍如apue和unp等中讲述的不太相符的是。类对象的生与死不能由对象自身拥有的mutex（互斥器）来保护，同时与我们的传统观念不同，最容易出现竞态条件（race condition）的时间点反而是对象析构</p>
<h1 id="析构函数遇到多线程">析构函数遇到多线程</h1>
<p>和Java不同，C++要求程序员自己管理对象的生命期<br>
当一个对象能被多个线程同时看到时，对象的销毁时机变得模糊不清，可能出现多种竞态条件（race condition）：</p>
<ol>
<li>
<p>在即将析构一个对象时，从何而知此刻是否有别的线程正在执行该对象的成员函数？</p>
</li>
<li>
<p>如何保证在执行成员函数期间，对象不会在另一个线程被析构？</p>
</li>
<li>
<p>在调用某个对象的成员函数之前，如何得知这个对象还活着？它的析构函数会不会碰巧执行到一半？</p>
<p>作者提出使用shared_ptr来解决C++多线程编程中的竞态问题</p>
</li>
</ol>
<h1 id="线程安全的定义">线程安全的定义</h1>
<p>依据[JCP]，一个线程安全的class应当满足以下三个条件：<br>
1.多个线程同时访问时，其表现出正确的行为。<br>
2.无论操作系统如何调度这些线程，无论这些线程的执行顺序如何交织。<br>
3.调用端代码无须额外的同步或其他协调动作。<br>
依据这个定义，C++标准库里大多数class不是线程安全的，包括std::string、std::vector、std::map等，这些class通常需要在外部加锁才能供多个线程同时访问。</p>
<p>注意：<br>
对于const成员函数，如果希望使用mutex时，必须把mutex成员定义为mutable，是的const成员函数也能直接使用non-const的mutex</p>
<p>mutable 可变数据成员 永远不会是const，即使它是const对象的成员<br>
引入 mutable 之后，C++ 可以有逻辑层面的 const，也就是对一个常量实例来说，从外部观察，它是常量而不可修改；但是内部可以有非常量的状态。<br>
默认情况下lambda不能改变值捕获的变量的值，如果想要改变值捕获的变量的值，则需要在参数列表首加上关键字mutable<br>
注意：mutable是指在lambda内改变值捕获变量的值，而不是指改变外层变量的值！值捕获是无法改变变量的值的，改变外层变量的值应该用引用捕获</p>
<h1 id="对象的构造">对象的构造</h1>
<p>对象构造要做到线程安全，唯一的要求就是在构造期间不要泄露this指针，即：</p>
<p>不要在构造函数中注册任何回调。（即在构造函数中使用this指针作为形参调用其他函数进行初始化等）<br>
不要在构造函数中把this传给跨线程的对象。<br>
即便在构造函数的最后一行也不行。</p>
<p>因为在构造函数执行期间对象还没有完成初始化，如果this被泄露给了其他对象，那么别的线程就有可能访问到这个半成品对象，从而造成难以预料的后果。</p>
<p>作者推荐分裂为二段式构造-构造函数+初始化函数initialize()，此时构造函数不必主动抛出异常，靠initialize的返回值来判断构造成功与否就好</p>
<p>关于“即便是最后一行也不行”，是因为如果该类是一个基类，由于基类先于派生类构造，所以执行完该类的构造函数最后一行代码后，还会继续执行派生类的构造函数。</p>
<h1 id="析构存在的问题">析构存在的问题</h1>
<p>主要就是析构时需要保护临界区的互斥器，但是析构函数本身又会销毁mutex成员变量<br>
导致作为类数据成员的MutexLock只能用于保护读写操作，而不能保护析构<br>
而且对于继承类，调用基类析构函数时派生类对象那部分早就被析构了，基类对象的MutexLock也无法保护析构过程</p>
<p>而且同时读写一个类的两个对象也有潜在的死锁可能<br>
比如swap(a,b)和swap(b,a)<br>
一个函数要锁住相同类型的多个对象，就必须保证始终按相同顺序加锁<br>
可以比较mutex对象的地址，然后保证始终优先加锁地址较小的mutex</p>
<p>一个动态创建的对象是否还活着，无法依靠原始指针来指示<br>
C++的指针有个根本问题是没有高效判断指针合法与否的方法<br>
原始指针极其容易造成空悬指针的情况</p>
<p>一个万能的解决方案——引入另外一层间接性，用对象来管理共享资源。</p>
<h1 id="神器shared_ptrweak_ptr">神器shared_ptr/weak_ptr</h1>
<p>shared_ptr是引用计数型智能指针，引用计数降为0时，对象（资源）即被销毁。它是强引用，控制对象的生命期，只要有一个指向x对象的shared_ptr存在，该x对象就不会析构。当指向对象x的最后一个shared_ptr析构或者reset()的时候，x保证会被销毁。</p>
<p>weak_ptr也是一个引用计数型智能指针，但是它不增加或减少对象的引用次数，即弱引用，它不控制对象的生命期，但是可以知道对象是否还活着。（举个例子，假设有5个shared_ptr引用了对象A，则A的引用计数是5，这个时候如果有一个weak_ptr也引用了A，那么A的引用计数还是5，也就是说，weak_ptr并不增加引用计数，但是由于它指向了A，所以可以知道A的引用计数从而判断它是否还活着。）它没有重载* 和-&gt;但可以使用lock获得一个可用的shared_ptr对象——对象如果还活着，那么它可以提升(promote)为有效的shared_ptr，如果对象已经死了，提升会失败，返回一个空的shared_ptr。“提升/lock()”行为是线程安全的。</p>
<p>shared_ptr/weak_ptr的“计数”在主流平台上是原子操作，没有用锁，性能不俗，它们的线程安全级别与std::string和STL容器一样。</p>
<h1 id="raii资源获取即初始化">RAII（资源获取即初始化）</h1>
<p>初学C++的教条是“new和delete要配对，new了之后要记得delete”；如果使用RAII（《Effective C++》条款13），要改成“每一个明确的资源配置动作（例如new）都应该在单一语句（《Effective C++》条款17）中执行，并在该语句中立刻将配置获得的资源交给handle对象（如shared_ptr），程序中一般不出现delete”。</p>
<p>shared_ptr是管理共享资源的利器，需要注意避免循环引用，通常的做法是，owner持有指向child的shared_ptr，child持有指向owner的weak_ptr。</p>
<h1 id="多线程编程的建议">多线程编程的建议</h1>
<p>用流水线、生产者消费者、任务队列这些有规律的机制，最低限度地共享数据。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Linux基础] 磁盘分区（鸟哥Linux第二章） ]]></title>
        <id>https://lixin-ee.github.io//post/linux-ji-chu-ci-pan-fen-qu-niao-ge-linux-di-er-zhang</id>
        <link href="https://lixin-ee.github.io//post/linux-ji-chu-ci-pan-fen-qu-niao-ge-linux-di-er-zhang">
        </link>
        <updated>2019-12-27T11:49:01.000Z</updated>
        <content type="html"><![CDATA[<p>其实很早之前就看完了鸟哥的Linux基础篇，但是当时忙于敲了代码没做笔记<br>
这系列的博客就像c++primer那样重新复习一遍吧</p>
<p>这一张还是概念为主，需要敲代码的地方比较少，但是这些设计硬盘的概念比较重要</p>
<h1 id="在-linux-系统中每个装置都被当成一个文件来对待">在 Linux 系统中，每个装置都被当成一个文件来对待</h1>
<p>IDE 接口 的硬盘的文件名即为/dev/sd[a-d]，其中， 括号内的字母为a-d当中的任意一个，亦即有/dev/sda, /dev/sdb, /dev/sdc, 及 /dev/sdd 这四个文件的意思<br>
在 Linux 这个系统当中，几乎所有的硬件装置文件都<strong>挂载</strong>在/dev 这个目录内</p>
<p>虚拟机使用 VirtIO 界面时，磁盘文件名应该是 /dev/vda<br>
我装在virtualbox上的文件名就是这个，很神奇，能够识别为virtual<br>
磁盘盘上面又可细分出扇区(Sector)与磁道(Track)两种单位， 其中扇 区的物理量设计有两种大小，分别是 512bytes 与 4Kbytes。<br>
整颗磁盘的第一个扇区特别的重要，因为他记录了整颗磁盘的 重要信息</p>
<h1 id="msdosmbr-与-gpt-磁盘分区表partition-table">MSDOS(MBR) 与 GPT 磁盘分区表(partition table)</h1>
<p>分区表其实目前有两种格式</p>
<p>MBR(Master Boot Record, 主要开机纪录区)：<br>
早期的 Linux 系统为了兼容于 Windows 的磁盘，因此使用的是支持 Windows 的 MBR(Master Boot Record, 主要开机纪录区) 的方式来处理开机管理程序与分区表<br>
开机管理程序纪录区与分区表则通通放在磁盘的第一个扇区，第一个扇区512bytes 会有这两个数据：<br>
-主要启动记录区(Master Boot Record, MBR)：可以安装开机管理程序的地方，有 446 bytes<br>
-分区表(partition table)：记录整颗硬盘分区的状态，有 64 bytes</p>
<p>由于分区表所在区块仅有 64 bytes 容量，因此最多仅能有四组记录区，每组记录区记录了该区段的启 始与结束的磁柱号码。<br>
例子：假设上面的硬盘装置文件名为/dev/sda时，那么这四个分区槽在Linux系统中的装置文件名如下所示， 重点在于档名后面会再接一个数字，这个数字与该分区槽所在的位置有关</p>
<ul>
<li>P1:/dev/sda1</li>
<li>P2:/dev/sda2</li>
<li>P3:/dev/sda3</li>
<li>P4:/dev/sda4</li>
</ul>
<p>在过去 MBR 分区表的限制中经常可以发现如下 的问题：<br>
操作系统无法抓取到 2.2T 以上的磁盘容量<br>
MBR 仅有一个区块，若被破坏后，经常无法或很难救援<br>
MBR 内的存放开机管理程序的区块仅 446bytes，无法容纳较多的程序代码。</p>
<p>GUID partition table, GPT 磁盘分区表：<br>
因为过去一个扇区大小就是 512bytes 而已，不过目前已经有 4K 的扇区设计出现！为了兼容于所有的磁盘，因此在扇区的定义上面， 大多会使用所谓的逻辑区块地址(Logical Block Address, LBA)来处理。GPT 将磁盘所有区块以此 LBA(预设为 512bytes 喔！) 来规划，而第一个 LBA 称为 LBA0 (从 0 开始编号)。<br>
与 MBR 仅使用第一个 512bytes 区块来纪录不同， GPT 使用了 34 个 LBA 区块来纪录分区信息</p>
<p>这里有挺深的体会，老板曾经买了个4T的移动硬盘回来拷贝服务器上的数据库，硬盘上写着三平台通用，结果插上去却无法当作固定硬盘使用，后来发现果然是这个分区表的问题，服务器用了MBR后无法转去2.2T以上的磁盘容量了</p>
<h1 id="linux-安装模式下磁盘分区的选择极重要">Linux 安装模式下，磁盘分区的选择(极重要)</h1>
<ul>
<li>-目录树结构 (directory tree)<br>
目录树架构(directory tree)就是以根目录为主，然后向下呈现分支状的目录结构的一种文件架构。<br>
整个目录树架构最重要的就是那个根目录(root directory)，这个根目录的表示方法为一条斜线『/』</li>
<li>-文件系统与目录树的关系( 挂载)<br>
所谓的『挂载』就是利用一个目录当成进入点，将磁盘分区槽的数据放置在该目录下； 也就是说， 进入该目录就可以读取该分区槽<br>
由于整个 Linux 系统最重要的是根目录，因此根目录一定需要挂载到某个分区槽的。 至于 其他的目录则可依用户自己的需求来给予挂载到不同的分区槽。</li>
</ul>
<p><img src="https://lixin-ee.github.io//post-images/1577448228560.png" alt=""></p>
<p>读书体会：总得来说，这个就是Linux系统关于硬盘等IP设备的基础知识，也许和编程关系不算特别大，但是不会修电脑的程序员 不是一个好程序员hhh，所以硬件这方面的知识也需要有所了解，日后遇到相关的问题时也能及时解决</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 169. 多数元素[简单][分治法][位运算]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-169-duo-shu-yuan-su-jian-dan-fen-zhi-fa-wei-yun-suan</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-169-duo-shu-yuan-su-jian-dan-fen-zhi-fa-wei-yun-suan">
        </link>
        <updated>2019-12-27T03:51:24.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。<br>
你可以假设数组是非空的，并且给定的数组总是存在多数元素。<br>
示例 1:<br>
输入: [3,2,3]<br>
输出: 3<br>
示例 2:<br>
输入: [2,2,1,1,1,2,2]<br>
输出: 2<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/majority-element<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>第一想法还是哈希表，但是这次是必须用map存储次数，而且我不希望最后再遍历map来找最大次数，所以希望用一个额外的pair来存储max值<br>
在判断i是否存在于map的时候可以用find和count，我突然在想这两者会不会遍历？<br>
c++的hash set和map都是基于hashtable，在hashtable的find和count都是基于bky_num_key的hash运算后再在桶内遍历，不接受multi的话就只会有一个元素，所以时间复杂度还是O(1)<br>
需要注意的点就是pair的初始化。。。否则只有一个元素的话就输出错误了。</p>
<pre><code>class Solution {
public:
    int majorityElement(vector&lt;int&gt;&amp; nums) {
        unordered_map&lt;int,int&gt; resm;
        pair&lt;int,int&gt; resp={1,nums.front()};
        for(auto i:nums)
        {
            if(resm.count(i)){
                 ++resm[i];
                if(resm[i]&gt;resp.first)
                    resp.first=resm[i],resp.second=i;
            }else
                resm.insert({i,1});   
        }
        return resp.second;
    }
};
</code></pre>
<p>然后来看看官方题解:</p>
<blockquote>
<p>方法 1：暴力<br>
想法<br>
我们可以在平方级的时间里穷举所有情况，来检测每个数是不是众数。<br>
算法<br>
暴力算法遍历整个数组，然后用另一重循环统计每个数字出现的次数。将出现次数比其他数字加起来出现次数还多的元素返回。</p>
</blockquote>
<pre><code>Java
class Solution {
    public int majorityElement(int[] nums) {
        int majorityCount = nums.length/2;

        for (int num : nums) {
            int count = 0;
            for (int elem : nums) {
                if (elem == num) {
                    count += 1;
                }
            }

            if (count &gt; majorityCount) {
                return num;
            }

        }

        return -1;    
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n^2)<br>
暴力算法包含两重嵌套的 for 循环，每一层 n次迭代，所以总的是平方级的时间复杂度。<br>
空间复杂度：O(1)<br>
暴力方法没有分配任何与输入规模成比例的额外的空间</p>
</blockquote>
<p>方法 2：哈希表<br>
想法</p>
<blockquote>
<p>我们知道出现次数最多的元素大于 ⌊ n/2 ⌋  次，所以可以用哈希表来快速统计每个元素出现的次数。<br>
算法<br>
我们使用哈希表来存储每个元素，然后用一个循环在线性时间内遍历 nums ，然后我们只需要返回有最大值的键。</p>
</blockquote>
<pre><code>Java
class Solution {
    private Map&lt;Integer, Integer&gt; countNums(int[] nums) {
        Map&lt;Integer, Integer&gt; counts = new HashMap&lt;Integer, Integer&gt;();
        for (int num : nums) {
            if (!counts.containsKey(num)) {
                counts.put(num, 1);
            }
            else {
                counts.put(num, counts.get(num)+1);
            }
        }
        return counts;
    }

    public int majorityElement(int[] nums) {
        Map&lt;Integer, Integer&gt; counts = countNums(nums);

        Map.E***y&lt;Integer, Integer&gt; majorityE***y = null;
        for (Map.E***y&lt;Integer, Integer&gt; e***y : counts.e***ySet()) {
            if (majorityE***y == null || e***y.getValue() &gt; majorityE***y.getValue()) {
                majorityE***y = e***y;
            }
        }

        return majorityE***y.getKey();
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)<br>
我们将 nums 迭代一次，哈希表的插入是常数时间的。所以总时间复杂度为 O(n) 时间的。<br>
空间复杂度：O(n)<br>
哈希表最多包含 n -  ⌊ n/2 ⌋  个关系，所以占用的空间为 O(n) 。这是因为任意一个长度为 n 的数组最多只能包含 n 个不同的值，但题中保证 nums 一定有一个众数，会占用（最少） ⌊ n/2 ⌋ +1 个数字。因此最多有 n - ( ⌊ n/2 ⌋ +1) 个不同的其他数字，所以最多有 n -  ⌊ n/2 ⌋  个不同的元素。</p>
</blockquote>
<blockquote>
<p>方法 3：排序<br>
想法<br>
如果所有数字被单调递增或者单调递减的顺序排了序，那么众数的下标为 ⌊ n/2 ⌋ （当 n 是偶数时，下标为  ⌊ n/2 ⌋ +1 ）<br>
算法<br>
对于这种算法，我们先将 nums 数组排序，然后返回上面所说的数字。下面解释了为什么这种策略是有效的。考虑下图（上面的例子是一个可能的奇数的情况，下面的例子是一个可能的偶数的情况）：</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1577419466553.png" alt=""></p>
<blockquote>
<p>对于每种情况，数组下面的线表示如果众数是数组中最小值的情况下覆盖的下标。数组上面的线是数组中最大值的情况。其他情况，这条线会在这两种极端情况的中间。但我们看到即使是这两种极端情况，它们也会在下标为  ⌊ n/2 ⌋  的地方有重叠。因此，无论众数是多少，返回  ⌊ n/2 ⌋ 下标对应的值都是正确的。</p>
</blockquote>
<pre><code>Java
class Solution {
    public int majorityElement(int[] nums) {
        Arrays.sort(nums);
        return nums[nums.length/2];
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(nlgn)<br>
用 Python 和 Java 将数组排序开销都为 O(nlgn)，它占据了运行的主要时间。<br>
空间复杂度：O(1)或者 O(n)<br>
我们将 nums 就地排序，如果不能就低排序，我们必须使用线性空间将 nums 数组拷贝，然后再排序。</p>
</blockquote>
<blockquote>
<p>方法 4：随机化<br>
想法<br>
因为超过 ⌊ n/2 ⌋ 的数组下标被众数占据了，一个随机的下标很有可能存有众数。<br>
算法<br>
由于一个给定的下标对应的数字很有可能是众数，我们随机挑选一个下标，检查它的值是否是众数，如果是就返回，否则继续随机挑选。</p>
</blockquote>
<pre><code>Java
class Solution {
    private int randRange(Random rand, int min, int max) {
        return rand.nextInt(max - min) + min;
    }

    private int countOccurences(int[] nums, int num) {
        int count = 0;
        for (int i = 0; i &lt; nums.length; i++) {
            if (nums[i] == num) {
                count++;
            }
        }
        return count;
    }

    public int majorityElement(int[] nums) {
        Random rand = new Random();

        int majorityCount = nums.length/2;

        while (true) {
            int candidate = nums[randRange(rand, 0, nums.length)];
            if (countOccurences(nums, candidate) &gt; majorityCount) {
                return candidate;
            }
        }
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(∞)<br>
理论上这个算法有可能跑无穷次（如果我们一直无法随机到众数），所以最坏时间复杂度是没有上限的。然而，运行的期望时间远小于无限次的 - 线性时间即可。为了更简单地分析，先说服你自己：由于众数占据 超过 数组一半的位置，期望的迭代次数会小于众数占据数组恰好一半的情况。因此，我们可以计算迭代的期望次数（下标为 prob 为原问题， mod 为众数恰好占据数组一半数目的问题）：</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1577419557632.png" alt=""></p>
<blockquote>
<p>因为级数会收敛，修改后问题的迭代期望次数是个常数。所以修改后问题的运行时间为线性的。因此，原问题期望运行时间也是线性的。<br>
空间复杂度：O(1)<br>
就像暴力解，随机方法只需要常数级别的额外空间。</p>
</blockquote>
<blockquote>
<p>方法 5：分治<br>
想法<br>
如果我们知道数组左边一半和右边一半的众数，我们就可以用线性时间知道全局的众数是哪个。<br>
算法<br>
这里我们使用经典的分治算法递归求解，直到所有的子问题都是长度为 1 的数组。由于传输子数组需要额外的时间和空间，所以我们实际上只传输子区间的左右指针 lo 和 hi 表示相应区间的左右下标。长度为 1 的子数组中唯一的数显然是众数，直接返回即可。如果回溯后某区间的长度大于 1 ，我们必须将左右子区间的值合并。如果它们的众数相同，那么显然这一段区间的众数是它们相同的值。否则，我们需要比较两个众数在整个区间内出现的次数来决定该区间的众数。原问题的答案就是下标为 0 和 n 之间的众数这一子问题。</p>
</blockquote>
<pre><code>class Solution {
    private int countInRange(int[] nums, int num, int lo, int hi) {
        int count = 0;
        for (int i = lo; i &lt;= hi; i++) {
            if (nums[i] == num) {
                count++;
            }
        }
        return count;
    }

    private int majorityEleme***ec(int[] nums, int lo, int hi) {
        // base case; the only element in an array of size 1 is the majority
        // element.
        if (lo == hi) {
            return nums[lo];
        }

        // recurse on left and right halves of this slice.
        int mid = (hi-lo)/2 + lo;
        int left = majorityEleme***ec(nums, lo, mid);
        int right = majorityEleme***ec(nums, mid+1, hi);

        // if the two halves agree on the majority element, return it.
        if (left == right) {
            return left;
        }

        // otherwise, count each element and return the &quot;winner&quot;.
        int leftCount = countInRange(nums, left, lo, hi);
        int rightCount = countInRange(nums, right, lo, hi);

        return leftCount &gt; rightCount ? left : right;
    }

    public int majorityElement(int[] nums) {
        return majorityEleme***ec(nums, 0, nums.length-1);
    }
}
</code></pre>
<p><img src="https://lixin-ee.github.io//post-images/1577419632622.png" alt=""></p>
<blockquote>
<p>方法 6：Boyer-Moore 投票算法<br>
想法<br>
如果我们把众数记为 +1 ，把其他数记为 −1 ，将它们全部加起来，显然和大于 0 ，从结果本身我们可以看出众数比其他数多。<br>
算法<br>
本质上， Boyer-Moore 算法就是找 nums 的一个后缀 suf ，其中 suf[0] 就是后缀中的众数。我们维护一个计数器，如果遇到一个我们目前的候选众数，就将计数器加一，否则减一。只要计数器等于 0 ，我们就将 nums 中之前访问的数字全部 忘记 ，并把下一个数字当做候选的众数。直观上这个算法不是特别明显为何是对的，我们先看下面这个例子（竖线用来划分每次计数器归零的情况）<br>
[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]<br>
首先，下标为 0 的 7 被当做众数的第一个候选。在下标为 5 处，计数器会变回0 。所以下标为 6 的 5 是下一个众数的候选者。由于这个例子中 7 是真正的众数，所以通过忽略掉前面的数字，我们忽略掉了同样多数目的众数和非众数。因此， 7 仍然是剩下数字中的众数。<br>
[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 5, 5, 5, 5]<br>
现在，众数是 5 （在计数器归零的时候我们把候选从 7 变成了 5）。此时，我们的候选者并不是真正的众数，但是我们在 遗忘 前面的数字的时候，要去掉相同数目的众数和非众数（如果遗忘更多的非众数，会导致计数器变成负数）。<br>
因此，上面的过程说明了我们可以放心地遗忘前面的数字，并继续求解剩下数字中的众数。最后，总有一个后缀满足计数器是大于 0 的，此时这个后缀的众数就是整个数组的众数。</p>
</blockquote>
<pre><code>Java
class Solution {
    public int majorityElement(int[] nums) {
        int count = 0;
        Integer candidate = null;

        for (int num : nums) {
            if (count == 0) {
                candidate = num;
            }
            count += (num == candidate) ? 1 : -1;
        }

        return candidate;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)<br>
Boyer-Moore 算法严格执行了 n 次循环，所以时间复杂度是线性时间的。<br>
空间复杂度：O(1)<br>
Boyer-Moore 只需要常数级别的额外空间。</p>
</blockquote>
<p>投票法真的很6hhh，虽然是简单题，但是考验的就是思路的广阔，有时间全部复现一遍</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于priority的自定义比较]]></title>
        <id>https://lixin-ee.github.io//post/guan-yu-priority-de-zi-ding-yi-bi-jiao</id>
        <link href="https://lixin-ee.github.io//post/guan-yu-priority-de-zi-ding-yi-bi-jiao">
        </link>
        <updated>2019-12-27T03:44:47.000Z</updated>
        <content type="html"><![CDATA[<p>在做<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/submissions/">23. 合并K个排序链表</a>的时候需要使用优先队列priority_queue，但是这题是链表题，没法直接用小于等于，所以必须用自定义的compare</p>
<p>一开始我以为和泛型函数sort一样，只需要传入自定义compare类型即可（就像multimap那样）<br>
于是传入<br>
<code>priority_queue&lt;ListNode*,decltype(compare)*&gt; list_queue(compare)；</code></p>
<p>然后报错了。。。</p>
<p>观察错误才发现是<br>
priority_queue&lt;class Type,class Container,class Compare&gt;<br>
于是回想起<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a>中也用到了priority_queue的自定义比较<br>
所以参考一下<br>
<code>priority_queue&lt;int,vector&lt;int&gt;,great&lt;int&gt;&gt; res; //底层数据结构是大顶堆，注意每次会弹出最大值</code><br>
加上了 vector&lt;ListNode*&gt;</p>
<p>还是报错，看来问题在于class Compare了</p>
<p>果然 看了博客<a href="https://blog.csdn.net/AAMahone/article/details/82787184">C++ priority_queue的自定义比较方式</a><br>
才发现问题所在<br>
这是一个类！！！<br>
和sort等泛型函数不同，compare传入的不是简单的函数类型，而是一个类！并且类中重载了调用运算符<br>
当然其自身有<code>great&lt;T&gt;</code>和<code>less&lt;T&gt;</code>两个定义，默认less</p>
<pre><code>    struct compare
    {
        bool operator()(ListNode* node1,ListNode* node2)
        {
            return node1-&gt;val&gt;=node2-&gt;val;
        }
    };
</code></pre>
<pre><code>而且注意大于小于的返回判断，如果使用 &lt;= ，返回的反而是大顶堆。。。
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[哈希表/位运算 136. 只出现一次的数字 ]]></title>
        <id>https://lixin-ee.github.io//post/ha-xi-biao-wei-yun-suan-136-zhi-chu-xian-yi-ci-de-shu-zi</id>
        <link href="https://lixin-ee.github.io//post/ha-xi-biao-wei-yun-suan-136-zhi-chu-xian-yi-ci-de-shu-zi">
        </link>
        <updated>2019-12-26T03:05:05.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。<br>
说明：<br>
你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？<br>
示例 1:<br>
输入: [2,2,1]<br>
输出: 1<br>
示例 2:<br>
输入: [4,1,2,1,2]<br>
输出: 4<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/single-number<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>最简单的肯定就是无序哈希表的增删了 注意无序是unordered而不是unorder<br>
然后就是思考如何不使用额外的空间<br>
想过双指针的解答，但是似乎不是很行<br>
艹，题解就是数学法</p>
<pre><code>class Solution {
public:
    int singleNumber(vector&lt;int&gt;&amp; nums) {
        unordered_set&lt;int&gt; res;
        for(auto i:nums){
            if(res.count(i))
                res.erase(i);
            else
                res.insert(i);
        }
        return *res.begin();
    }
};
</code></pre>
<p>然后来看看官方题解</p>
<blockquote>
<p>方法 1：列表操作<br>
算法<br>
遍历 nums 中的每一个元素<br>
如果某个nums 中的数字是新出现的，则将它添加到列表中<br>
如果某个数字已经在列表中，删除它</p>
</blockquote>
<pre><code>Python
class Solution(object):
    def singleNumber(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        no_duplicate_list = []
        for i in nums:
            if i not in no_duplicate_list:
                no_duplicate_list.append(i)
            else:
                no_duplicate_list.remove(i)
        return no_duplicate_list.pop()
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n^2) 。我们遍历nums 花费 O(n) 的时间。我们还要在列表中遍历判断是否存在这个数字，花费 O(n) 的时间，所以总循环时间为 O(n^2) 。<br>
空间复杂度：O(n) 。我们需要一个大小为 n 的列表保存所有的 nums 中元素。</p>
</blockquote>
<blockquote>
<p>方法 2：哈希表<br>
算法<br>
我们用哈希表避免每次查找元素是否存在需要的 O(n) 时间。<br>
遍历 nums 中的每一个元素<br>
查找 hash_table 中是否有当前元素的键<br>
如果没有，将当前元素作为键插入 hash_table<br>
最后， hash_table 中仅有一个元素，用 popitem 获得它</p>
</blockquote>
<pre><code>Python
class Solution(object):
    def singleNumber(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        hash_table = {}
        for i in nums:
            try:
                hash_table.pop(i)
            except:
                hash_table[i] = 1
        return hash_table.popitem()[0]
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度： =O(n) 。for 循环的时间复杂度是 O(n) 的。Python 中哈希表的 pop 操作时间复杂度为O(1) 。<br>
空间复杂度： O(n) 。hash_table 需要的空间与nums 中元素个数相等。</p>
</blockquote>
<p>方法 3：数学<br>
概念<br>
2 * (a + b + c) - (a + a + b + b + c) = c2∗(a+b+c)−(a+a+b+b+c)=c</p>
<pre><code>Python
class Solution(object):
    def singleNumber(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        return 2 * sum(set(nums)) - sum(nums)
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n+n)=O(n) 。sum 会调用 next 将nums 中的元素遍历一遍。我们可以把上述代码看成 sum(list(i, for i in nums)) ，这意味着时间复杂度为 O(n) ，因为nums 中的元素个数是 nn 个。<br>
空间复杂度：O(n+n)=O(n) 。 set 需要的空间跟 nums 中元素个数相等。</p>
</blockquote>
<blockquote>
<p>方法 4：位操作<br>
概念<br>
如果我们对 0 和二进制位做 XOR 运算，得到的仍然是这个二进制位<br>
a⊕0=a<br>
如果我们对相同的二进制位做 XOR 运算，返回的结果是 0<br>
a⊕a=0<br>
XOR 满足交换律和结合律<br>
a⊕b⊕a=(a⊕a)⊕b=0⊕b=b<br>
所以我们只需要将所有的数进行 XOR 操作，得到那个唯一的数字。</p>
</blockquote>
<pre><code>Python
class Solution(object):
    def singleNumber(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        a = 0
        for i in nums:
            a ^= i
        return a
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度： O(n) 。我们只需要将nums 中的元素遍历一遍，所以时间复杂度就是nums 中的元素个数。<br>
空间复杂度：O(1) 。</p>
</blockquote>
<p>我对异或的复现</p>
<pre><code>    int singleNumber(vector&lt;int&gt;&amp; nums){
        int res=0;
        for(auto i:nums)
            res^=i;
        return res;
    }      
</code></pre>
<p>对比方法三，异或还是很6的，都不需要考虑溢出的问题</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于非阻塞IO、Reactor和one thread one loop]]></title>
        <id>https://lixin-ee.github.io//post/guan-yu-fei-zu-sai-ioreactor-he-one-thread-one-loop</id>
        <link href="https://lixin-ee.github.io//post/guan-yu-fei-zu-sai-ioreactor-he-one-thread-one-loop">
        </link>
        <updated>2019-12-26T02:11:42.000Z</updated>
        <content type="html"><![CDATA[<p>今天早上在阅读陈硕的高性能多线程服务器第三章时产生了很大的疑惑<br>
那就是Reactor和one thread one loop之间的区别<br>
书中说后者其实就是把前者复制实现了，也就是把reactor在每个线程中复现了并且加上了线程池以处理那些纯计算不IO的工作</p>
<p>然后我就疑惑在于reactor本身或者说非阻塞IO本身不是多线程或者多进程的吗</p>
<p>答案还真不是<br>
先放一篇比较好的博客<br>
<a href="http://gao-xiao-long.github.io/2017/04/20/network-io/">Linux下多线程服务器Reactor模式总结</a><br>
然后结合UNP<br>
我才发现原来非阻塞IO并非是select/poll响应之后不断地fork或者thread的<br>
而是在【单线程里面不断执行】</p>
<p>那为何不会阻塞在执行函数里面呢？比如read和write？<br>
这就是UNP 16章一开始介绍缓冲区的原因<br>
非阻塞IO中必须用缓冲区缓存IO内容，也就是说我管你发不发得出去（阻塞IO一般也是阻塞在不够长度发送或者接收的问题上），发不出去就存起来下次再发，赶紧给我返回到select（接收同理），只能阻塞在select上</p>
<p>这也就是reactor的event loop和select/poll分离、以及其缺点的由来</p>
<p>缺点就是非抢占：由于只有一个线程，因此事件是顺序处理的，一个线程同时只能做一件事情，事件的优先级得不到保证。因为”从select/poll返回后” 到”下一次调用select/poll进入等待之前”这段时间内，线程不会被其他连接上的数据或者事件抢占。所以在使用这种模式时，需要避免业务逻辑阻塞当前IO线程。比如事件a的优先级高于事件b，但是只要事件b早到那么一点，后到的事件a只能等待事件b完成返回到select/poll（注意不是阻塞）</p>
<p>当然Reactor其实有很多版本的，并非必须是单线程的，只是陈硕作者在第三章中引出来所需，Reactor可以有单进程多线程的版本</p>
<p>最后Reactor和基于它的lighttpd、Niginx都是值得阅读的源码</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于读书笔记]]></title>
        <id>https://lixin-ee.github.io//post/guan-yu-du-shu-bi-ji</id>
        <link href="https://lixin-ee.github.io//post/guan-yu-du-shu-bi-ji">
        </link>
        <updated>2019-12-25T12:40:41.000Z</updated>
        <content type="html"><![CDATA[<p>谁能想到这是我为数不多的随心感想之一<br>
起源是某天打开自己的博客和github，发现空空如也<br>
hhh也没有啦 但十一月底之前的博文里除了leetcode和C++ primer之外好像就没有其他的了，看起来我好像什么都没做一样<br>
但是真相是什么呢，其实一直在看书<br>
除去C++ primer，我整理了一下如下<br>
C++：《STL源码剖析》《深度探索C++对象模型》<br>
算法：《大话数据结构》<br>
计算机网络：《计算机网络：自顶向下方法》《TCP/IP详解 卷1》<br>
操作系统：《深入理解计算机系统》<br>
Linux：《鸟哥的 Linux 私房菜 基础篇》《APUE-UNIX 环境高级编程》《UNP-UNIX网络编程》<br>
还算不少吧hhh<br>
然而虽然开了博客，但是自己多多少少还是不太习惯用吧，笔记基本都在iPad里面，然后自己习惯转化成成word笔记方便查阅。<br>
但是一周前看了一位中大师兄的博客，看到他一路以来做的笔记，才发现自己还是不够啊<br>
然后又开始陷入无限懊悔。。。<br>
但是看了一下同时期师兄的博客，其实也是差不多的起点吧<br>
所以种一棵树最好的时机，一个是三年前，一个是今天<br>
毕竟我也用了太多时间来后悔了</p>
<p>所以从今天起尽量写一下读书笔记<br>
对于已经读过的书，除了转化为word，更添加和面试题相关的解答和思考<br>
对于正在读的树，肯定有读不懂的地方，那就把笔记和感想结合起来，感想为主吧。</p>
<p>然后发现一个小技巧，博客上有很多人会手工搬运书中的内容，这样我说不定可以省下很多工作呢hhh</p>
<p>一眨眼已经19.12.25了，学期初完成的计划显然是太难达成了（一个月两本书），未来的路也还很远，刚刚拿到地图（面经），做好了晚点回家的准备，但今天有点懈怠了，还是得继续努力啊！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树的前中后序遍历+层次遍历 [迭代版]]]></title>
        <id>https://lixin-ee.github.io//post/er-cha-shu-de-qian-zhong-hou-xu-bian-li-ceng-ci-bian-li-die-dai-ban</id>
        <link href="https://lixin-ee.github.io//post/er-cha-shu-de-qian-zhong-hou-xu-bian-li-ceng-ci-bian-li-die-dai-ban">
        </link>
        <updated>2019-12-25T08:00:54.000Z</updated>
        <content type="html"><![CDATA[<p>前序</p>
<pre><code>class Solution {
public:
    //迭代版
    vector&lt;int&gt; preorderTraversal(TreeNode* root) {
        stack&lt;TreeNode*&gt; rNode;
        vector&lt;int&gt; res;
        TreeNode* cur;
        rNode.push(root);
        while(rNode.size()){
            cur=rNode.top();
            rNode.pop();
            if(cur==NULL)
                continue;
            res.push_back(cur-&gt;val);
            rNode.push(cur-&gt;right);
            rNode.push(cur-&gt;left);
        }
        return res;
    }
｝
</code></pre>
<p>需要注意的点<br>
1.先压入root结点<br>
2.对cur进行NULL判断<br>
3.因为栈是先进后出，所以一定要先压入右子树再压入左子树</p>
<p>中序</p>
<pre><code>class Solution {
public:   
    vector&lt;int&gt; inorderTraversal(TreeNode* root){
        stack&lt;TreeNode*&gt; NodeStack;
        TreeNode *cur=root;
        vector&lt;int&gt; res;
        while(cur||NodeStack.size()){
            while(cur){
                NodeStack.push(cur);
                cur=cur-&gt;left;
            }
            cur=NodeStack.top();
            NodeStack.pop();
            res.push_back(cur-&gt;val);
            cur=cur-&gt;right;
            
        }
        return res;
    }
   ｝;
</code></pre>
<pre><code>注意点
1.判断条件和处理和前序遍历不同，先压入所有左子树再返回再压入右子树
</code></pre>
<p>二叉树的后序遍历</p>
<pre><code>class Solution {   
public:
    vector&lt;int&gt; postorderTraversal(TreeNode* root) {
        deque&lt;int&gt; res;
        stack&lt;TreeNode*&gt; nodestack;
        TreeNode *cur;
        nodestack.push(root);
        while(nodestack.size()){
            cur=nodestack.top();
            nodestack.pop();
            if(!cur)
                continue;
            res.push_front(cur-&gt;val);
            nodestack.push(cur-&gt;left);
            nodestack.push(cur-&gt;right);
        }
        return vector&lt;int&gt;(res.begin(),res.end());
    }
	};
</code></pre>
<p>注意点：<br>
1.这个题解时逆序输出，先输出靠后的元素，比如12345的输出顺序是5-45-345-2345-12345，因此我使用了deque，因为需要push_front，用vector的话很费时（当然用deque的话很费空间）<br>
2.注意必须先压入left再压入righjt，原因是因为逆序输出，所以配合stack先进后出的话需要右子树后入栈</p>
<p>层次遍历</p>
<pre><code>class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {
        vector&lt;vector&lt;int&gt;&gt; res;
        vector&lt;TreeNode*&gt; cur,next;
        if(!root) return res;
        cur.push_back(root);
        while(cur.size()||next.size()){
            res.push_back(vector&lt;int&gt;({}));
            for(auto i:cur){
                res.back().push_back(i-&gt;val);
                if(i-&gt;left)
                    next.push_back(i-&gt;left);
                if(i-&gt;right)
                    next.push_back(i-&gt;right);               
            }
            cur=next;
            next.clear();
        }
        return res;
    }
		};
</code></pre>
<p>需要注意的点：<br>
1.其实可以在空间和记录层次之间选择，我选择了前者，因为比较省工<br>
2.res需要先push_back一个空数组<br>
3.注意back()返回的是引用，这也解释了为啥很多函数习惯返回引用，否则的话连续调用就全部木大了</p>
]]></content>
    </entry>
</feed>