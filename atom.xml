<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2020-02-16T12:20:19.895Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[对象模型：普通继承、多重继承与菱形继承]]></title>
        <id>https://lixin-scut.github.io//post/dui-xiang-mo-xing-pu-tong-ji-cheng-duo-chong-ji-cheng-yu-ling-xing-ji-cheng</id>
        <link href="https://lixin-scut.github.io//post/dui-xiang-mo-xing-pu-tong-ji-cheng-duo-chong-ji-cheng-yu-ling-xing-ji-cheng">
        </link>
        <updated>2020-02-16T09:28:05.000Z</updated>
        <content type="html"><![CDATA[<p>对象模型受三点影响：</p>
<ol>
<li>语言本身提供的特性，比如虚拟继承</li>
<li>编译器带来的优化（比如空类插入的char）</li>
<li>编译器要求的字节对齐</li>
</ol>
<h3 id="普通继承">普通继承</h3>
<p>空类的对象模型中有一个编译器安插进去的char，使得sizeof为1，使得空类的两个不同对象在内存中也有独一无二的地址，能够区分开来</p>
<p>静态数据成员只有一个实体，存放在全局数据段中（静态内存），对静态成员取指针只会获得一个指向其数据类型的指针，其类型和class类型无关，不会内含在class类型内<br>
编译器会对不同类中的静态数据成员进行编码，以及name-mangling</p>
<p>因为对形参类型的决议早于整个类声明的完成，所以typedef一定要放在类的开头<br>
而对成员函数的决议会等到整个类声明的完整出现再开始，所以数据成员可以放在后面<br>
非静态成员在对象模型中的顺序和声明顺序一致，和构造函数的构造列表顺序无关</p>
<p>普通数据成员都需要利用类对象来存取，在成员函数中暗中使用了this指针进行提取，使用类对象的起始地址加上offset进行提取</p>
<p>虚拟继承对普通数据成员的存取只是加上了一层间接性</p>
<p>在没有虚函数的情况下，类并没有什么特别</p>
<p>不要随便将类分层，否则容易出现强行padding增大size的情况（如果不padding的话用基类向派生类赋值会导致错误覆盖）<br>
<img src="https://lixin-scut.github.io//post-images/1581851687596.png" alt=""></p>
<p>虚拟继承就是在类对象模型前加上vptr（就算基类没有虚函数而派生类有，vptr也是放在对象模型头部，当然此时把一个派生类对象转换成基类对象就需要编译器介入）<br>
<img src="https://lixin-scut.github.io//post-images/1581852068371.png" alt=""></p>
<h3 id="多重继承">多重继承</h3>
<p>多重继承按照继承的顺序来搭建对象模型<br>
<img src="https://lixin-scut.github.io//post-images/1581852180064.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1581852133439.png" alt=""></p>
<h3 id="虚拟继承">虚拟继承</h3>
<p>虚拟继承中的空虚拟基类的派生类不需要插入char了，只需要一个指针</p>
<p>虚拟继承会将对象模型分割为两个部分：不变局部和共享局部，后者就是虚继承基类对象部分的体现，它们的位置会因为每次派生操作而变化，只可以被简洁存取</p>
<p>一般的布局策略是先安排好派生类的不变部分，然后再建立共享部分<br>
编译器会1.在派生类对象部分分配指向共享部分的指针 2.使用virtual base class table 3.在vtable中分配负的offset使得指向共享部分<br>
<img src="https://lixin-scut.github.io//post-images/1581852581219.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1581852655079.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1581852745780.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[红黑树与二叉平衡树]]></title>
        <id>https://lixin-scut.github.io//post/hong-hei-shu-yu-er-cha-ping-heng-shu</id>
        <link href="https://lixin-scut.github.io//post/hong-hei-shu-yu-er-cha-ping-heng-shu">
        </link>
        <updated>2020-02-16T08:23:39.000Z</updated>
        <content type="html"><![CDATA[<p>#红黑树的时间复杂度<br>
一棵含有n个节点的红黑树的高度至多为2log(n+1)<br>
红黑树能够以O(logn) 的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在三次旋转之内解决。<br>
而迭代器遍历是O(N)</p>
<p>非递归遍历一棵红黑树的时间复杂度和遍历数组的时间复杂度是一样的，多么令人惊奇的结果。<br>
       我们将分析得出这一结果。采用迭代器遍历红黑树的算法主要在迭代器增1操作：<br>
1. 判断右子树是不是空，如果不为空，找到右子树的最小值begin(right(tree))，结束。如果右子树为空，如果右子树为空，转2；<br>
2. 往根节点爬，直到父节点为空或者本节点是父节点的左子节点，然后取父节点的值。<br>
因此红黑树的一条边最多被访问两次：一条边最多只能被从父节点到子节点访问一次和从子节点到父节点访问一次。如果有第三次访问，注意到我们的遍历过程是完全无状态的（步骤1和2判断的唯一是根据当前节点，没有任何其余状态变量）。那么必然会导致至少一个访问的重复，与现实矛盾。证明出一条边最多被访问两次。另外一条边最小要被访问一次，原因是很显然的。因此二叉树的遍历是O(E)的，其中E为树的边数，我们知道一个节点的节点数和边数的关系为N = E + 1，故得出迭代器遍历一棵红黑树的时间复杂度是O(N)。</p>
<p>#红黑树和二叉平衡树（AVL树）的区别</p>
<ol>
<li>红黑树不追求&quot;完全平衡&quot;，即不像AVL那样要求节点的 |balFact| &lt;= 1，它只要求部分达到平衡，但是提出了为节点增加颜色，<strong>红黑是用非严格的平衡来换取增删节点时候旋转次数的降低</strong>，<strong>任何不平衡都会在三次旋转之内解决</strong>，而AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，<strong>旋转的次数比红黑树要多。</strong></li>
<li>就插入节点导致树失衡的情况，AVL和RB-Tree都是最多两次树旋转来实现复衡rebalance，旋转的量级是O(1)<br>
删除节点导致失衡，AVL需要维护从被删除节点到根节点root这条路径上所有节点的平衡，<strong>旋转的量级为O(logN)</strong>，而<strong>RB-Tree最多只需要旋转3次实现复衡</strong>，只需O(1)，所以说RB-Tree删除节点的rebalance的效率更高，开销更小！</li>
<li>AVL的结构相较于RB-Tree更为平衡，插入和删除引起失衡，如2所述，RB-Tree复衡效率更高；当然，由于AVL高度平衡，因此AVL的Search效率更高啦。</li>
<li>针对插入和删除节点导致失衡后的rebalance操作，红黑树能够提供一个比较&quot;便宜&quot;的解决方案，降低开销，是对search，insert ，以及delete效率的折衷，总体来说，RB-Tree的统计性能高于AVL.</li>
<li>故引入RB-Tree是功能、性能、空间开销的折中结果。<br>
5.1 AVL更平衡，结构上更加直观，时间效能针对读取而言更高；维护稍慢，空间开销较大。<br>
5.2 红黑树，读取略逊于AVL，维护强于AVL，空间开销与AVL类似，内容极多时略优于AVL，维护优于AVL。<br>
红黑树的查询性能略微逊色于AVL树，因为其比AVL树会稍微不平衡最多一层，也就是说红黑树的查询性能只比相同内容的AVL树最多多一次比较，但是，红黑树在插入和删除上优于AVL树，AVL树每次插入删除会进行大量的平衡度计算，而红黑树为了维持红黑性质所做的红黑变换和旋转的开销，相较于AVL树为了维持平衡的开销要小得多<br>
总结：红黑树有着良好的稳定性和完整的功能，性能表现也很不错，综合实力强，在诸如STL的场景中需要稳定表现。实际应用中，若搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。</li>
</ol>
<p>epoll 底层是什么实现(红黑树)<br>
epoll 底层实现原理 在内核中维护红黑树以及 callback 回掉函数</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 题19:正则表达式匹配[未做出]]]></title>
        <id>https://lixin-scut.github.io//post/zi-fu-chuan-ti-19zheng-ze-biao-da-shi-pi-pei-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/zi-fu-chuan-ti-19zheng-ze-biao-da-shi-pi-pei-wei-zuo-chu">
        </link>
        <updated>2020-02-16T01:23:08.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
请实现一个函数用来匹配包括'.'和'<em>'的正则表达式。模式中的字符'.'表示任意一个字符，而'</em>'表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;ab<em>ac</em>a&quot;匹配，但是与&quot;aa.a&quot;和&quot;ab*a&quot;均不匹配</p>
</blockquote>
<p>【未做出】<br>
本来我的想法是从pattern入手，然后分别判断'.'和'*'<br>
可惜在盘点'*'的时候发现一个问题，b*b和bbbbb怎么匹配呢。。。因为必须留下一个b和最后一个b匹配，所以不能直接使用while直接判断</p>
<p>直接看书中题解<br>
注意第二个判断条件中if(*str!='\0'&amp;&amp;*pattern=='\0')不可以改为if(*str=='\0'||*pattern=='\0')<br>
因为测试用例 “”和 “.*” 这两者中明显str可以到尾后位置，而pattern肯定不会先到尾后位置<br>
书中答案相当于递归调用所有的三种可能性（甚至把“.*”都揉合在一起进行判断了）<br>
总之三种判断就是对应了状态机中的状态转移，非常巧妙<br>
最好就是注意和string不同，字符串变量有'\0'兜尾，不用担心if( *(pattern+1)=='*')溢出</p>
<pre><code>class Solution {
public:
    bool match(char* str, char* pattern)
    {
        if(str==nullptr||pattern==nullptr)
                return false;
        return matchCore(str,pattern);
    }
    
    bool matchCore(char *str,char *pattern)
    {
        if(*str=='\0'&amp;&amp;*pattern=='\0')
            return true;
        if(*str!='\0'&amp;&amp;*pattern=='\0')
            return false;
        if(*(pattern+1)=='*')
        {
            if(*(pattern)==*str||(*pattern=='.'&amp;&amp;*str!='\0'))
                return matchCore(str+1,pattern+2)
                ||matchCore(str+1,pattern)
                ||matchCore(str,pattern+2);
            else
                return matchCore(str,pattern+2);
        }
        if(*str==*pattern||(*pattern=='.'&amp;&amp;*str!='\0'))
            return matchCore(str+1,pattern+1);
        
        return false;
    }
};
</code></pre>
<p>书本题解：<br>
每次从字符串里拿出一个字符和模式中的字符去匹配。先来分析如何匹配一个字符。如果模式中的字符ch是'.'，那么它可以匹配字符串中的任意字符。如果模式中的字符ch不是而且字符串中的字符也是ch,那么它们相互匹配。当字符串中的字符和模式中的字符相匹配时，接着匹配后面的字符。<br>
相对而言，当模式中的第二个字符不是'*'时，问题要简单很多。如果字符串中的第一个字符和模式中的第一个字符相匹配，那么在字符串和模式上都向后移动一个字符，然后匹配剩余的字符串和模式。如果字符串中的第一个字符和模式中的第一个字符不相匹配，则直接返回false。<br>
当模式中的第二个字符是'*'时，问题要复杂一些，因为可能有多种不同的匹配方式。一种选择是在模式上向后移动两个字符。这相当于'*'和它前面的字符被忽略了，因为'*'可以匹配字符串中的0个字符。如果模式中的第一个字符和字符串中的第一个字符相匹配，则在字符串上向后移动一个字符, 而在模式上有两种选择：可以在模式上向后移动两个字符，也可以保持模式不变。</p>
<pre><code>bool match(const char* str, const char* pattern)
{
    if(str == nullptr || pattern == nullptr)
        return false;

    return matchCore(str, pattern);
}

bool matchCore(const char* str, const char* pattern)
{
    if(*str == '\0' &amp;&amp; *pattern == '\0')
        return true;

    if(*str != '\0' &amp;&amp; *pattern == '\0')
        return false;

    if(*(pattern + 1) == '*')
    {
        if(*pattern == *str || (*pattern == '.' &amp;&amp; *str != '\0'))
            // 进入有限状态机的下一个状态
            return matchCore(str + 1, pattern + 2)
            // 继续留在有限状态机的当前状态 
            || matchCore(str + 1, pattern)
            // 略过一个'*' 
            || matchCore(str, pattern + 2);
        else
            // 略过一个'*'
            return matchCore(str, pattern + 2);
    }

    if(*str == *pattern || (*pattern == '.' &amp;&amp; *str != '\0'))
        return matchCore(str + 1, pattern + 1);

    return false;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[红黑树--set与map的 底层实现]]></title>
        <id>https://lixin-scut.github.io//post/hong-hei-shu-map-di-ceng-shi-xian</id>
        <link href="https://lixin-scut.github.io//post/hong-hei-shu-map-di-ceng-shi-xian">
        </link>
        <updated>2020-02-15T08:30:36.000Z</updated>
        <content type="html"><![CDATA[<h3 id="二叉搜索树binary-search-tree">二叉搜索树(binary search tree)</h3>
<p>二叉搜索树,可提供对数时间的元素插入和访问.二叉搜索树的节点放置规则是：任何节点的键值一定大于其左子树中的每一个节点的键值，并小于其右子树中的每一个节点的键值。因此，从根节点一直往左走，直至无左路可走，即得最小元素；从根节点一直往右走，直至无 右路可走，即得最大元素。<br>
插入新元素时，可从根节点开始，遇键值较大 者就向左，遇键值较小者就向右，一直到尾端，即为插入点。<br>
欲删除旧节点A,情况可分两种。<br>
如果A只有一个子节点，我们就直接将A的子节点连至A的父节点，并将A删除。如果A有两个子节点，我们就以右子树内的最小节点取代A。注意，右子树的最小节点极易获得：从右子节点开始(视为右子树的根节点)，一直向左走至底即是。</p>
<h3 id="平衡二叉搜索树balanced-binary-search-tree">平衡二叉搜索树(balanced binary search tree )</h3>
<p>因为输入值不够随机，也许因为经过某些插入或删除操作，二叉搜索树可能会失去平衡，造成搜寻效率低落的情况</p>
<p>所谓树形平衡与否，并没有一个绝对的测量标准。大概定义为没有任何一个节点过深（深度过大）</p>
<h3 id="avl-tree-adelson-velskii-landis-tree">AVL tree （ Adelson-Velskii-Landis tree ）</h3>
<p>AVLtree是一个“加上了额外平衡条件”的二叉搜索树。其平衡条件的建立是为了确保整棵树的深度为O(logN)。<br>
直观上的最佳平衡条件是每个节点的左右子树有着相同的高度，但AVLtree退而求其次，只要求任何节点的左右子树高度相差最多1<br>
只要修改最深的失去平衡的节点就能使整棵树重新获得平衡<br>
只要调整“插入点至根节点”路径上，平衡状态被破坏之各节点 中最深的那一个，便可使整棵树重新获得平衡。假设该最深节点为X,由于节点最 多拥有两个子节点，而所谓“平衡被破坏”意味着X的左右两棵子树的高度相差 2,因此我们可以轻易将情况分为四种：</p>
<ol>
<li>插入点位于X的左子节点的左子树——左左。</li>
<li>插入点位于X的左子节点的右子树——左右。</li>
<li>插入点位于X的右子节点的左子树——右左。</li>
<li>插入点位于X的右子节点的右子树——右右。<br>
情况1,4彼此对称，称为外侧(outside)插入，可以采用单旋转操作(single rotation)调整解决。<br>
情况2, 3彼此对称，称为内侧(inside)插入，可以采用双旋 转操作(double rotation)调整解决。</li>
</ol>
<h3 id="rb-tree-红黑树">RB-tree (红黑树)</h3>
<p>RB-tree,不仅是一个二叉搜索树，而且必须满足以下规则:</p>
<ol>
<li>每个节点不是红色就是黑色(图中深色底纹代表黑色，浅色底纹代表红色,</li>
<li>根节点为黑色。</li>
<li>如果节点为红，其子节点必须为黑。</li>
<li>任一节点至NULL (树尾端)的任何路径，所含之黑节点数必须相同。<br>
（注意上述四点中并无一点要求深度，仅仅对颜色作出了要求，使用二叉搜索树的插入方法，然后主要通过第四点进行控制）<br>
根据规则4,新增节点必须为红(注意，这里不是指所有业节点都是红的，叶节点也可以是黑的)；<br>
根据规则3,新增节点之父节点必须为黑。<br>
当新节点根据二叉搜索树的规则到达其插入点，却未能符合上述条件时，就必须调 整颜色并旋转树形。</li>
</ol>
<p>假设新节点为X,其父节点为P,祖父节点为G,伯父节点（父节点之兄弟节点）为S,曾祖父节点为GG。现在，根据二叉搜索树的规则，新节点X必为叶节点。根据红黑树规则4, X必为红。若P亦为红（这就违反了规则3,必须调整树形）,则G必为黑（因为原为RB-tree,必须遵循规则3）。于是、根据X的插入位置及外围节点（S和GG）的颜色，有以下四种情况<br>
<img src="https://lixin-scut.github.io//post-images/1581758953264.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1581758969684.png" alt=""><br>
注意，红黑树可能会产生不平衡的状态（高度相差1以上），但是无所谓，红黑树的平衡性就是比ACL树弱，但红黑树的搜索平均效率和AVL树几乎相等<br>
<img src="https://lixin-scut.github.io//post-images/1581768019234.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1581768036420.png" alt=""></p>
<p>RB-tree有红黑二色，并且拥有左右子节点，其结构为了有更大的弹性，节点分为两层，下图显示节点双层结构和迭代器双层结构的关系。<br>
<img src="https://lixin-scut.github.io//post-images/1581768119608.png" alt=""><br>
RB-tree迭代器属于双向迭代器，但不具备随机定位能力，其提领操作和成员<br>
访问操作与list十分近似，较为特殊的是其前进和后退操作。</p>
<p><img src="https://lixin-scut.github.io//post-images/1581768212987.png" alt=""><br>
每当插入新节点时，不但要依照RB-tree的规则来调整，并且维护 header 的正确性，使其父节点指向根节点，左子节点指向最小节点，右子节点指向最大节点。</p>
<p>insert_unique() 和 insert_equal() 前者表示被插入节点的键值（key）在整棵树中必须独一无二（因此，如果树中已存在相同的键值，插入操作就不会真正进 行），后者表示被插入节点的键值在整棵树中可以重复，因此，无论如何插入都会 成功（除非空间不足导致配置失败）<br>
insert_equal中，遇到相同的节点继续往右走<br>
insert_unique的返回值是个pair，第一元素是个RB-tree迭代器，指向新增节点，第二元素表示插入成功与否</p>
<h3 id="set">set</h3>
<p>set&lt;T&gt;::iterator 被定义为底层 RB-tree 的 const_iterator, 杜绝写入操作。<br>
set拥有与list相同的某些性质：当客户端对它进行元素新增操作 （insert）或删除操作（erase） 时，操作之前的所有迭代器，在操作完成之后都 依然有效。当然，被删除的那个元素的迭代器必然是个例外。</p>
<h3 id="map">map</h3>
<p>如果想要修正元素的键值，答案是不行，因为map元素的键值关系到map元素的排列规则。任意改变map 元素键值将会严重破坏map组织。但如果想要修正元素的实值，答案是可以，因为map元素的实值并不影响map元素的排列规则。因此，map iterators既不是一种 constant iterators 也不是一种 mutable iterators</p>
<p>map拥有和list相同的某些性质：当客户端对它进行元素新增操作 (insert) 或删除操作 (erase) 时，操作之前的所有迭代器，在操作完成之后都 依然有效,当然，被删除的那个元素的迭代器必然是个例外。<br>
插入操作返回一个pair,其第一元素是个迭代器，指向插入妥当的新元素， 或指向插入失败点（键值重复）的旧元素。</p>
<p>附录：红黑树的代码<br>
<img src="https://lixin-scut.github.io//post-images/1581840657808.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1581840674954.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1581840695332.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1581840708526.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1581840722636.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1581840745694.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1581840779069.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1581840797319.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[事务管理四要素 ACID]]></title>
        <id>https://lixin-scut.github.io//post/shi-wu-guan-li-si-yao-su-acid</id>
        <link href="https://lixin-scut.github.io//post/shi-wu-guan-li-si-yao-su-acid">
        </link>
        <updated>2020-02-15T08:15:54.000Z</updated>
        <content type="html"><![CDATA[<p>原子性（Atomicity）<br>
原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。<br>
一致性（Consistency）<br>
事务前后数据的完整性必须保持一致。<br>
隔离性（Isolation）<br>
事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。<br>
持久性（Durability）<br>
持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[B 树和 B+树的区别]]></title>
        <id>https://lixin-scut.github.io//post/b-shu-he-bshu-de-qu-bie</id>
        <link href="https://lixin-scut.github.io//post/b-shu-he-bshu-de-qu-bie">
        </link>
        <updated>2020-02-15T07:49:47.000Z</updated>
        <content type="html"><![CDATA[<p>一，b树<br>
b树（balance tree）和b+树应用在数据库索引，可以认为是m叉的多路平衡查找树，但是从理论上讲，二叉树查找速度和比较次数都是最小的，为什么不用二叉树呢？<br>
因为我们要考虑磁盘IO的影响，它相对于内存来说是很慢的。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。所以我们要减少IO次数，对于树来说，IO次数就是树的高度，而“矮胖”就是b树的特征之一，它的每个节点最多包含m个孩子，m称为b树的阶，m的大小取决于磁盘页的大小。</p>
<p>█一个M阶的b树具有如下几个特征：<br>
定义任意非叶子结点最多只有M个儿子，且M&gt;2；<br>
根结点的儿子数为[2, M]；<br>
除根结点以外的非叶子结点的儿子数为[M/2, M]，向上取整；<br>
非叶子结点的关键字个数=儿子数-1；<br>
所有叶子结点位于同一层；<br>
k个关键字把节点拆成k+1段，分别指向k+1个儿子，同时满足查找树的大小关系。</p>
<p>█有关b树的一些特性，注意与后面的b+树区分：<br>
关键字集合分布在整颗树中；<br>
任何一个关键字出现且只出现在一个结点中；<br>
搜索有可能在非叶子结点结束；<br>
其搜索性能等价于在关键字全集内做一次二分查找；</p>
<p>b树在查询时的比较次数并不比二叉树少，尤其是节点中的数非常多时，但是内存的比较速度非常快，耗时可以忽略，所以只要树的高度低，IO少，就可以提高查询性能，这是b树的优势之一。</p>
<p>二，b+树<br>
b+树，是b树的一种变体，查询性能更好。m阶的b+树的特征：<br>
有n棵子树的非叶子结点中含有n个关键字（b树是n-1个），这些关键字不保存数据，只用来索引，所有数据都保存在叶子节点（b树是每个关键字都保存数据）。<br>
所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。<br>
所有的非叶子结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。<br>
通常在b+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。<br>
同一个数字会在不同节点中重复出现，根节点的最大元素就是b+树的最大元素。</p>
<p>█b+树相比于b树的查询优势：<br>
b+树的中间节点不保存数据，所以磁盘页能容纳更多节点元素，更“矮胖”；（B树的每个结点都存储了key和data，B+树的data存储在叶子节点上。）<br>
b+树查询必须查找到叶子节点，b树只要匹配到即可不用管元素位置，因此b+树查找更稳定（并不慢）；<br>
对于范围查找来说，b+树只需遍历叶子节点链表即可，b树却需要重复地中序遍历</p>
<p><a href="https://www.cnblogs.com/20189223cjt/p/11262450.html">B-树与B+树的区别</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[lambda]]></title>
        <id>https://lixin-scut.github.io//post/lambda</id>
        <link href="https://lixin-scut.github.io//post/lambda">
        </link>
        <updated>2020-02-15T07:40:21.000Z</updated>
        <content type="html"><![CDATA[<ol start="7">
<li>Lambda 表达式</li>
</ol>
<p>Lambda 表达式，实际上就是提供了一个类似匿名函数的特性，而匿名函数则是在需要一个函数，但是又不想费力去命名一个函数的情况下去使用的。</p>
<p>Lambda 表达式的基本语法如下：</p>
<p>[ caputrue ] ( params ) opt -&gt; ret { body; };<br>
1</p>
<ol>
<li>capture是捕获列表；</li>
<li>params是参数表；(选填)</li>
<li>opt是函数选项；可以填mutable,exception,attribute（选填）<br>
mutable说明lambda表达式体内的代码可以修改被捕获的变量，并且可以访问被捕获的对象的non-const方法。<br>
exception说明lambda表达式是否抛出异常以及何种异常。<br>
attribute用来声明属性。</li>
<li>ret是返回值类型（拖尾返回类型）。(选填)</li>
<li>body是函数体。</li>
</ol>
<p>捕获列表：lambda表达式的捕获列表精细控制了lambda表达式能够访问的外部变量，以及如何访问这些变量。</p>
<ol>
<li>[]不捕获任何变量。</li>
<li>[&amp;]捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）。</li>
<li>[=]捕获外部作用域中所有变量，并作为副本在函数体中使用(按值捕获)。注意值捕获的前提是变量可以拷贝，且被捕获的变量在 lambda 表达式被创建时拷贝，而非调用时才拷贝。如果希望lambda表达式在调用时能即时访问外部变量，我们应当使用引用方式捕获。</li>
</ol>
<p>int a = 0;<br>
auto f = [=] { return a; };</p>
<p>a+=1;</p>
<p>cout &lt;&lt; f() &lt;&lt; endl;       //输出0</p>
<p>int a = 0;<br>
auto f = [&amp;a] { return a; };</p>
<p>a+=1;</p>
<p>cout &lt;&lt; f() &lt;&lt;endl;       //输出1<br>
1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
10<br>
11<br>
12<br>
13<br>
4) [=,&amp;foo]按值捕获外部作用域中所有变量，并按引用捕获foo变量。<br>
5) [bar]按值捕获bar变量，同时不捕获其他变量。<br>
6) [this]捕获当前类中的this指针，让lambda表达式拥有和当前类成员函数同样的访问权限。如果已经使用了&amp;或者=，就默认添加此选项。捕获this的目的是可以在lamda中使用当前类的成员函数和成员变量。</p>
<p>class A<br>
{<br>
public:<br>
int i_ = 0;</p>
<pre><code> void func(int x,int y){
     auto x1 = [] { return i_; };                   //error,没有捕获外部变量
     auto x2 = [=] { return i_ + x + y; };          //OK
     auto x3 = [&amp;] { return i_ + x + y; };        //OK
     auto x4 = [this] { return i_; };               //OK
     auto x5 = [this] { return i_ + x + y; };       //error,没有捕获x,y
     auto x6 = [this, x, y] { return i_ + x + y; };     //OK
     auto x7 = [this] { return i_++; };             //OK
</code></pre>
<p>};</p>
<p>int a=0 , b=1;<br>
auto f1 = [] { return a; };                         //error,没有捕获外部变量<br>
auto f2 = [&amp;] { return a++ };                      //OK<br>
auto f3 = [=] { return a; };                        //OK<br>
auto f4 = [=] {return a++; };                       //error,a是以复制方式捕获的，无法修改<br>
auto f5 = [a] { return a+b; };                      //error,没有捕获变量b<br>
auto f6 = [a, &amp;b] { return a + (b++); };                //OK<br>
auto f7 = [=, &amp;b] { return a + (b++); };                //OK<br>
1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
10<br>
11<br>
12<br>
13<br>
14<br>
15<br>
16<br>
17<br>
18<br>
19<br>
20<br>
21<br>
22<br>
23<br>
注意f4，虽然按值捕获的变量值均复制一份存储在lambda表达式变量中，修改他们也并不会真正影响到外部，但我们却仍然无法修改它们。如果希望去修改按值捕获的外部变量，需要显示指明lambda表达式为mutable。被mutable修饰的lambda表达式就算没有参数也要写明参数列表。</p>
<p>原因：lambda表达式可以说是就地定义仿函数闭包的“语法糖”。它的捕获列表捕获住的任何外部变量，最终会变为闭包类型的成员变量。按照C++标准，lambda表达式的operator()默认是const的，一个const成员函数是无法修改成员变量的值的。而mutable的作用，就在于取消operator()的const。</p>
<p>int a = 0;<br>
auto f1 = [=] { return a++; };                //error<br>
auto f2 = [=] () mutable { return a++; };       //OK<br>
1<br>
2<br>
3<br>
lambda表达式的大致原理：每当你定义一个lambda表达式后，编译器会自动生成一个匿名类（这个类重载了()运算符），我们称为闭包类型（closure type）。那么在运行时，这个lambda表达式就会返回一个匿名的闭包实例，是一个右值。所以，我们上面的lambda表达式的结果就是一个个闭包。对于复制传值捕捉方式，类中会相应添加对应类型的非静态数据成员。在运行时，会用复制的值初始化这些成员变量，从而生成闭包。对于引用捕获方式，无论是否标记mutable，都可以在lambda表达式中修改捕获的值。至于闭包类中是否有对应成员，C++标准中给出的答案是：不清楚的，与具体实现有关。</p>
<p>lambda表达式是不能被赋值的：</p>
<p>auto a = [] { cout &lt;&lt; &quot;A&quot; &lt;&lt; endl; };<br>
auto b = [] { cout &lt;&lt; &quot;B&quot; &lt;&lt; endl; };</p>
<p>a = b;   // 非法，lambda无法赋值<br>
auto c = a;   // 合法，生成一个副本<br>
1<br>
2<br>
3<br>
4<br>
5<br>
闭包类型禁用了赋值操作符，但是没有禁用复制构造函数，所以你仍然可以用一个lambda表达式去初始化另外一个lambda表达式而产生副本。</p>
<p>在多种捕获方式中，最好不要使用[=]和[&amp;]默认捕获所有变量。</p>
<p>默认引用捕获所有变量，你有很大可能会出现悬挂引用（Dangling references），因为引用捕获不会延长引用的变量的生命周期：</p>
<p>std::function&lt;int(int)&gt; add_x(int x)<br>
{<br>
return [&amp;](int a) { return x + a; };<br>
}<br>
1<br>
2<br>
3<br>
4<br>
上面函数返回了一个lambda表达式，参数x仅是一个临时变量，函数add_x调用后就被销毁了，但是返回的lambda表达式却引用了该变量，当调用这个表达式时，引用的是一个垃圾值，会产生没有意义的结果。上面这种情况，使用默认传值方式可以避免悬挂引用问题。</p>
<p>但是采用默认值捕获所有变量仍然有风险，看下面的例子：</p>
<p>class Filter<br>
{<br>
public:<br>
Filter(int divisorVal):<br>
divisor{divisorVal}<br>
{}</p>
<pre><code>std::function&lt;bool(int)&gt; getFilter() 
{
    return [=](int value) {return value % divisor == 0; };
}
</code></pre>
<p>private:<br>
int divisor;<br>
};<br>
1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
10<br>
11<br>
12<br>
13<br>
14<br>
15<br>
这个类中有一个成员方法，可以返回一个lambda表达式，这个表达式使用了类的数据成员divisor。而且采用默认值方式捕捉所有变量。你可能认为这个lambda表达式也捕捉了divisor的一份副本，但是实际上并没有。因为数据成员divisor对lambda表达式并不可见，你可以用下面的代码验证：</p>
<p>// 类的方法，下面无法编译，因为divisor并不在lambda捕捉的范围<br>
std::function&lt;bool(int)&gt; getFilter()<br>
{<br>
return [divisor](int value) {return value % divisor == 0; };<br>
}<br>
1<br>
2<br>
3<br>
4<br>
5<br>
原代码中，lambda表达式实际上捕捉的是this指针的副本，所以原来的代码等价于：</p>
<p>std::function&lt;bool(int)&gt; getFilter()<br>
{<br>
return [this](int value) {return value % this-&gt;divisor == 0; };<br>
}<br>
1<br>
2<br>
3<br>
4<br>
尽管还是以值方式捕获，但是捕获的是指针，其实相当于以引用的方式捕获了当前类对象，所以lambda表达式的闭包与一个类对象绑定在一起了，这很危险，因为你仍然有可能在类对象析构后使用这个lambda表达式，那么类似“悬挂引用”的问题也会产生。所以，采用默认值捕捉所有变量仍然是不安全的，主要是由于指针变量的复制，实际上还是按引用传值。</p>
<p>lambda表达式可以赋值给对应类型的函数指针。但是使用函数指针并不是那么方便。所以STL定义在&lt; functional &gt;头文件提供了一个多态的函数对象封装std::function，其类似于函数指针。它可以绑定任何类函数对象，只要参数与返回类型相同。如下面的返回一个bool且接收两个int的函数包装器：</p>
<p>std::function&lt;bool(int, int)&gt; wrapper = [](int x, int y) { return x &lt; y; };<br>
1<br>
lambda表达式一个更重要的应用是其可以用于函数的参数，通过这种方式可以实现回调函数。</p>
<p>最常用的是在STL算法中，比如你要统计一个数组中满足特定条件的元素数量，通过lambda表达式给出条件，传递给count_if函数：</p>
<p>int value = 3;<br>
vector<int> v {1, 3, 5, 2, 6, 10};<br>
int count = std::count_if(v.beigin(), v.end(), [value](int x) { return x &gt; value; });<br>
1<br>
2<br>
3<br>
再比如你想生成斐波那契数列，然后保存在数组中，此时你可以使用generate函数，并辅助lambda表达式：</p>
<p>vector<int> v(10);<br>
int a = 0;<br>
int b = 1;<br>
std::generate(v.begin(), v.end(), [&amp;a, &amp;b] { int value = b; b = b + a; a = value; return value; });<br>
// 此时v {1, 1, 2, 3, 5, 8, 13, 21, 34, 55}<br>
1<br>
2<br>
3<br>
4<br>
5<br>
当需要遍历容器并对每个元素进行操作时：</p>
<p>std::vector<int> v = { 1, 2, 3, 4, 5, 6 };<br>
int even_count = 0;<br>
for_each(v.begin(), v.end(), [&amp;even_count](int val){<br>
if(!(val &amp; 1)){<br>
++ even_count;<br>
}<br>
});<br>
std::cout &lt;&lt; &quot;The number of even is &quot; &lt;&lt; even_count &lt;&lt; std::endl;<br>
1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
大部分STL算法，可以非常灵活地搭配lambda表达式来实现想要的效果。</p>
<p>————————————————<br>
版权声明：本文为CSDN博主「jiange_zh」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/jiange_zh/article/details/79356417</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11新特性]]></title>
        <id>https://lixin-scut.github.io//post/c11-xin-te-xing</id>
        <link href="https://lixin-scut.github.io//post/c11-xin-te-xing">
        </link>
        <updated>2020-02-15T07:26:37.000Z</updated>
        <content type="html"><![CDATA[<p>C++11的新特性</p>
<p>常用：<br>
列表初始化（vector对象的列表初始化）<br>
嵌套vector（之前因为&gt;&gt;会被视为右移运算符所以不允许）<br>
auto类型类型指示符、decltype类型指示符<br>
范围for语句<br>
使用=default生成默认构造函数<br>
虚函数的override指示符<br>
标准库begin和end函数<br>
Lambda表达式<br>
定义尾置返回类型<br>
无序容器<br>
智能指针<br>
右值引用<br>
虚函数的override指示符</p>
<p>汇总<br>
2.1.1  long long类型	57<br>
2.2.1  列表初始化	65<br>
2.3.2  nullptr常量	74<br>
2.4.4  constexpr变量	85<br>
2.5.1  类型别名声明	86<br>
2.5.2  auto类型指示符	87<br>
2.5.3  decltype类型指示符	88<br>
2.6.1  类内初始化	91<br>
3.2.2  使用auto或decltype缩写类型	105<br>
3.2.3  范围for语句	108<br>
3.3  定义vector对象的vector（向量的向量）	113<br>
3.3.1  vector对象的列表初始化	114<br>
3.4.1  容器的cbegin和cend函数	124<br>
3.5.3  标准库begin和end函数	132<br>
3.6  使用auto和decltype简化声明	141<br>
4.2  除法的舍入规则	151<br>
4.4  用大括号包围的值列表赋值	155<br>
4.9  将sizeof用于类成员	165<br>
5.4.3  范围for语句	194<br>
6.2.6  标准库initializer_list类	223<br>
6.3.2  列表初始化返回值	229<br>
6.3.3  定义尾置返回类型	232<br>
6.3.3  使用decltype简化返回类型定义	232<br>
6.5.2  constexpr函数	240<br>
7.1.4  使用=default生成默认构造函数	263<br>
7.3.1  类对象成员的类内初始化	272<br>
7.5.2  委托构造函数	287<br>
7.5.6  constexpr构造函数	294<br>
8.2.1  用string对象处理文件名	310<br>
9.1  array和forward_list容器	319<br>
9.2.3  容器的cbegin和cend函数	324<br>
9.2.4  容器的列表初始化	326<br>
9.2.5  容器的非成员函数swap	329<br>
9.3.1  容器insert成员的返回类型	334<br>
9.3.1  容器的emplace成员的返回类型	334<br>
9.4  shrink_to_fit	344<br>
9.5.5  string的数值转换函数	353<br>
10.3.2  Lambda表达式	372<br>
10.3.3  Lambda表达式中的尾置返回类型	379<br>
10.3.4  标准库bind函数	380<br>
11.2.1  关联容器的列表初始化	403<br>
11.2.3  列表初始化pair的返回类型	406<br>
11.3.2  pair的列表初始化	410<br>
11.4  无序容器	420<br>
12.1  智能指针	426<br>
12.1.1  shared_ptr类<br>
12.1.2  动态分配对象的列表初始化	433<br>
12.1.2  auto和动态分配	434<br>
12.1.5  unique_ptr类	443<br>
12.1.6  weak_ptr类	446<br>
12.2.1  范围for语句不能应用于动态分配数组	450<br>
12.2.1  动态分配数组的列表初始化	450<br>
12.2.1  auto不能用于分配数组	450<br>
12.2.2  allocator::construct可使用任意构造函数	454<br>
13.1.5  将=default用于拷贝控制成员	475<br>
13.1.6  使用=default阻止拷贝类对象	475<br>
13.5  用移动类对象代替拷贝类对象	495<br>
13.6.1  右值引用	497<br>
13.6.1  标准库move函数	498<br>
13.6.2  移动构造函数和移动赋值	499<br>
13.6.2  移动构造函数通常应该是noexcept	499<br>
13.6.2  移动迭代器	506<br>
13.6.3  引用限定成员函数	509<br>
14.8.3  function类模板	538<br>
14.9.1  explicit类型转换运算符	542<br>
15.2.2  虚函数的override指示符	556<br>
15.2.2  通过定义类为final来阻止继承	559<br>
15.3  虚函数的override和final指示符	564<br>
15.7.2  删除的拷贝控制和继承	579<br>
15.7.4  继承的构造函数	583<br>
16.1.2  声明模板类型形参为友元	616<br>
16.1.2  模板类型别名	616<br>
16.1.3  模板函数的默认模板参数	620<br>
16.1.5  实例化的显式控制	623<br>
16.2.3  模板函数与尾置返回类型	631<br>
16.2.5  引用折叠规则	635<br>
16.2.6  用static_cast将左值转换为右值	638<br>
16.2.7  标准库forward函数	640<br>
16.4  可变参数模板	644<br>
16.4  sizeof...运算符	645<br>
16.4.3  可变参数模板与转发	648<br>
17.1  标准库Tuple类模板	662<br>
17.2.2  新的bitset运算	669<br>
17.3  正则表达式库	671<br>
17.4  随机数库	685<br>
17.5.1  浮点数格式控制	696<br>
18.1.4  noexcept异常指示符	716<br>
18.1.4  noexcept运算符	717<br>
18.2.1  内联名字空间	725<br>
18.3.1  继承的构造函数和多重继承	738<br>
19.3  有作用域的enum	762<br>
19.3  说明类型用于保存enum对象	764<br>
19.3  enum的提前声明	764<br>
19.4.3  标准库mem_fn类模板	772<br>
19.6  类类型的联合成员	777</p>
<p>参考博文<a href="https://blog.csdn.net/jiange_zh/article/details/79356417">C++11常用新特性快速一览</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[struct 和 union ]]></title>
        <id>https://lixin-scut.github.io//post/struct-he-union</id>
        <link href="https://lixin-scut.github.io//post/struct-he-union">
        </link>
        <updated>2020-02-15T02:40:06.000Z</updated>
        <content type="html"><![CDATA[<p>《C++ primer》<br>
<strong>struct 关键词</strong><br>
类体的花括号形成一个新的作用域  表示结束的花括号后必须写一个分号，因为类体后面可以紧跟变量名，以示对该类型对象的定义<br>
struct 聚合类<br>
聚合类使得用户可以直接访问其成员，并且具有特殊的初始化语法<br>
聚合类的特性：1.所有成员都是public的2.没有定义任何构造函数3，没有类内初始值4.没有基类，也没有virtual函数<br>
对聚合类进行初始化的初始值的顺序必须与声明的顺序一致，且初始值列表的元素个数不能超过类的成员数量 例如 struct Data{int ival; string s}   Data val={0,”Anna”};//这里的顺序不可以反过来<br>
如果初始值列表中的元素个数少于类的成员数量，则靠后的成员被值初始化</p>
<p><strong>union:一种节省空间的类</strong><br>
联合（union)是一种特殊的类。一个union可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当我们给union的某个成员赋值之后，该union的其他成员就变成未定义的状态了。分配给一个union对象的存储空间至少要能容纳它的最大的数据成员。和其他类一样，一个union定义了一种新类型。<br>
union不能含有引用类型的成员<br>
含有构造函数 或析构函数的类类型也可以作为union的成员类型。union可以为其成员指定public、 protected和private等保护标记。默认情况下，union的成员都是公有的，这一点与struct相同。<br>
union可以定义包括构造函数和析构函数在内的成员函数。但是由于union既不能继承自其他类，也不能作为基类使用，所以在union中不能含有虚函数。</p>
<p>使用union类型<br>
union的名字是一个类型名。和其他内置类型一样，默认情况下union是未初始化的。我们可以像显式地初始化聚合类一样使用一对花括号内的初始值显式地初始化一个union：</p>
<p>我们使用通用的成员访问运算符（. 或者 -&gt;）访问一个union对象的成员：<br>
last_token.cval = ‘z’;<br>
pt-&gt;ival = 42;<br>
为union的一个数据成员赋值会令其他数据成员变成未定义的状态。因此，当我们使用 union时，必须淸楚地知道当前存储在union中的值到底是什么类型</p>
<p>匿名union<br>
匿名union(anonymous union)是一个未命名的union,并且在右花括号和分号之间没有任何声明（参见2.6.1节，第65页）。一旦我们定义了一个匿名union，编译器就自动地为该union创建一个未命名的对象<br>
在匿名union的定义所在的作用域内该union的成员都是可以直接访问的。<br>
匿名union不能包含受保护的成员或私有成员，也不能定义成员函数。</p>
<p>含有类类型的union<br>
如果union的成员类型定义了自己的构造函数和/或拷贝控制成员，则该union的用法要比只含有内置类型成员的union复杂得多。</p>
<p>使用类管理union成员<br>
对于union来说，要想构造或销毁类类型的成员必须执行非常复杂的操作，因此我们通常把含有类类型成员的union内嵌在另一个类当中。这个类可以管理并控制与union的类类型成员有关的状态转换。<br>
为了追踪union中到底存储了什么类型的值，我们通常会定义一个独立的对象，该对象称为union的判别式（discriminant)。我们可以使用判别式辨认union存储的值。为了保持union与其判别式同步，我们将判别式也作为Token的成员。我们的类将定义一个枚举类型（参见19.3节，第736页）的成员来追踪其union成员的状态。</p>
<p>问题：<br>
#struct 和 union 的区别</p>
<blockquote>
<p>一、Struct 和 Union有下列区别：<br>
1.在存储多个成员信息时，编译器会自动给struct第n个成员分配存储空间，struct 可以存储多个成员信息，而Union每个成员会用同一个存储空间，只能存储最后一个成员的信息。<br>
2.都是由多个不同的数据类型成员组成，但在任何同一时刻，Union只存放了一个被先选中的成员，而结构体的所有成员都存在。<br>
3.对于Union的不同成员赋值，将会对其他成员重写，原来成员的值就不存在了，而对于struct 的不同成员赋值 是互不影响的。</p>
</blockquote>
<blockquote>
<p>1：共用体和结构体都是由多个不同的数据类型成员组成， 但在任何同一时刻， 共用体只存放一个被选中的成员， 而结构体则存放所有的成员变量。<br>
2：对于共用体的不同成员赋值，将会对其他成员重写， 原来成员的值就不存在了， 而对于结构体的不同成员赋值是互不影响的<br>
3：内存分配不同<br>
union的大小为其内部所有变量的最大值，按照最大类型的倍数进行分配大小<br>
结构体struct分配方法类似，也是按照最大类型的倍数进行分配大小,但是还与顺序有关</p>
</blockquote>
<p>#struct 和 union 的字节对齐</p>
<blockquote>
<p>union的大小为其内部所有变量的最大值，按照最大类型的倍数进行分配大小<br>
如：<br>
typedef Union<br>
{<br>
char c[10];<br>
char cc1;<br>
}u11;<br>
typedef union<br>
{<br>
char c[10];<br>
int i;<br>
}u22;<br>
typedef union<br>
{<br>
char c[10];<br>
double d;<br>
}u33;<br>
sizeof(u11)结果是10<br>
sizeof(u22)结果是12，按照sizeof(int)*3分配空间<br>
sizeof(u33)结果是16，按照sizeof(double)*2分配空间。</p>
</blockquote>
<blockquote>
<p>结构体struct非配方法类似，也是按照最大类型的倍数进行分配大小,但是还与顺序有关<br>
如：<br>
typedef struct s1<br>
{<br>
char c;<br>
double d;<br>
}s11;<br>
typedef struct s2<br>
{<br>
char c;<br>
char cc;<br>
double d;<br>
}s22;<br>
typedef struct s3<br>
{<br>
char c;<br>
double d;<br>
char cc;<br>
}s33;<br>
sizeof(s11)结果是应该是9，但是系统按照sizeof(double)*2分配，所以大小是16<br>
sizeof(s22)结果是应该是10，但是系统按照sizeof(double)*2分配，所以大小是16，先分配8字节给c，c占用一个字节，剩余7字节可以存储cc，所以系统没有额外给cc分配内存。cc有了内存后剩余6字节无法存储d，系统就额外为d分配8字节，整个分配浪费内存6字节。<br>
sizeof(s22)结果是应该是10，但是系统按照sizeof(double)*3分配，所以大小是24，因为和定义顺序有关，所以当给c分配8个字节之后，剩余7个字节无法存储d，所以系统又分配了8个字节给d，之后又分配8个自己给cc，分配完后浪费了14个字节的空间。所以，在定义结构体struct 的时候按照s33的顺序分配可以节省内存</p>
</blockquote>
<p><strong>注意！！！数组在分配内存时不会视为一个整体，而是视为一个个元素！！！</strong></p>
<pre><code>struct data{
    char c;
    char c2[4];
    int i;
}test;
int main() {
    //test={'c',0};
    cout&lt;&lt;&amp;test&lt;&lt;&quot; &quot;&lt;&lt;&amp;(test.c2)&lt;&lt;&quot; &quot;&lt;&lt;&amp;(test.i)&lt;&lt;endl;
    cout&lt;&lt;sizeof(test);
}
//输出结果为
//0x1017ce0e8 0x1017ce0e9 0x105d860f0
//12
//说明c2并没有单独占一个4个空间,空洞出现在c2和i之间，而不是c和c2之间
</code></pre>
<p>注意！！！short（2字节）跟在char（1字节）后面的时候,也不是紧跟着的，会把4字节分为2字节，从第三个字节开始存储</p>
<pre><code>struct data{
    double d;
    char c;
    short s;
    int i;

}test;
int main() {
    //test={'c',0};
    cout&lt;&lt;(void *)&amp;(test.c)&lt;&lt;&quot; &quot;&lt;&lt;&amp;(test.s)&lt;&lt;endl;
    cout&lt;&lt;sizeof(test)&lt;&lt;endl;
    cout&lt;&lt;sizeof(test.c)&lt;&lt;endl;
}
//结果为
//0x10a7c90f0 0x10a7c90f2
//16
//1
</code></pre>
<p>#结构体 struct{char c;int a} 假设存储首地址是 0x00000,则 c 的存储地址为，a 的地址为， struct 的大小是?<br>
依据上一题，这道题的答案是<br>
c的存储地址为 0x00000，a的地址为0x00004，struct的大小为8<br>
代码验证得到同样的结果（因为地址无法一致就不贴上来了）</p>
<p>#sizeof(A)的结果是什么?</p>
<pre><code>struct Example{
char a;
int b;
short c;
} A;
</code></pre>
<p>根据上面的结论 大小为12<br>
注意如果把short换成double，char和int的起始地址分别为0x10dba90e8 0x10dba90ec，也就是说编译器还是以4字节为一个单位而不是double的8字节，int不能直接跟在char后面的，保证int不会被割裂</p>
<p>#c 的 struct 和 c++struct 的区别<br>
在c语言中，不能直接用结构体名来声明变量。<br>
在c++中，可以直接用结构体名来声明变量。<br>
如果想在c语言中直接用结构体名定义变量，需要用到 typedef</p>
<p>C语言中：<br>
Struct是用户自定义数据类型（UDT）。<br>
C++语言中：<br>
Struct是抽象数据类型（ADT），支持成员函数的定义。<br>
在C++中，struct的成员的默认访问说明符为public，class为private。<br>
c中的struct是没有权限设置的。<br>
C++中struct增加了访问权限,且可以和类一样有成员函数。<br>
C++中的struct等同于class,只是class默认成员权限是private,而struct默认成员权限是public。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 题18:删除链表中的重复节点]]></title>
        <id>https://lixin-scut.github.io//post/lian-biao-ti-18shan-chu-lian-biao-zhong-de-chong-fu-jie-dian</id>
        <link href="https://lixin-scut.github.io//post/lian-biao-ti-18shan-chu-lian-biao-zhong-de-chong-fu-jie-dian">
        </link>
        <updated>2020-02-15T01:55:06.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
</blockquote>
<p>注意和leetcode不同，这里必须delete节点，而不是仅仅连接起来就行<br>
这道题其实可以只使用一个curnode就完成的了，但是用了pre更加直观<br>
中途忘了把pre和cur接上了，然后又搞混了while的嵌套，还是得细心一点</p>
<pre><code>class Solution {
public:
    ListNode* deleteDuplication(ListNode* pHead)
    {
        if(pHead==NULL)return NULL;
        ListNode *virHead=new ListNode(0);
        virHead-&gt;next=pHead;
        ListNode *preNode=virHead;

        while(preNode){
            ListNode *curNode=preNode-&gt;next;
            int value;
            while(curNode&amp;&amp;curNode-&gt;next&amp;&amp;curNode-&gt;val==curNode-&gt;next-&gt;val){
                value=curNode-&gt;val;
                while(curNode&amp;&amp;curNode-&gt;val==value){
                    ListNode *temp=curNode;
                    curNode=curNode-&gt;next;
                    delete temp;
                }
            }
             preNode-&gt;next=curNode;
             preNode=curNode;
        }
        return virHead-&gt;next;
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>头节点可能与后面的节点重复，也就是说头节 点也可能被删除<br>
从头遍历整个链表。如果当前节点(代码中的pNode)的 值与下一个节点的值相同，那么它们就是重复的节点，都可以被删除。为 了保证删除之后的链表仍然是相连的，我们要把当前节点的前一个节点(代 码中的pPreNode)和后面值比当前节点的值大的节点相连。我们要确保 pPreNode始终与下一个没有重复的节点连接在一起。</p>
</blockquote>
<pre><code>void DeleteDuplication(ListNode** pHead)
{
    if(pHead == nullptr || *pHead == nullptr)
        return;

    ListNode* pPreNode = nullptr;
    ListNode* pNode = *pHead;
    while(pNode != nullptr)
    {
        ListNode *pNext = pNode-&gt;m_pNext;
        bool needDelete = false;
        if(pNext != nullptr &amp;&amp; pNext-&gt;m_nValue == pNode-&gt;m_nValue)
            needDelete = true;

        if(!needDelete)
        {
            pPreNode = pNode;
            pNode = pNode-&gt;m_pNext;
        }
        else
        {
            int value = pNode-&gt;m_nValue;
            ListNode* pToBeDel = pNode;
            while(pToBeDel != nullptr &amp;&amp; pToBeDel-&gt;m_nValue == value)
            {
                pNext = pToBeDel-&gt;m_pNext;

                delete pToBeDel;
                pToBeDel = nullptr;

                pToBeDel = pNext;
            }

            if(pPreNode == nullptr)
                *pHead = pNext;
            else
                pPreNode-&gt;m_pNext = pNext;
            pNode = pNext;
        }
    }
}
</code></pre>
<p>注意必须一个一个节点删除，不能像leetcode那样直接接上next，因为动态内存需要手动delete</p>
]]></content>
    </entry>
</feed>