<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-04-10T02:14:32.799Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>千里之行，始于足下。不积跬步，无以至千里。</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[无锁队列的实现]]></title>
        <id>https://lixin-scut.github.io//post/wu-suo-dui-lie-de-shi-xian</id>
        <link href="https://lixin-scut.github.io//post/wu-suo-dui-lie-de-shi-xian">
        </link>
        <updated>2020-04-10T01:28:29.000Z</updated>
        <content type="html"><![CDATA[<p>  总体思想就是基于CAS保证操作的原子性，然后在入队和出队时分别通过对队列的尾节点和头节点进行判断，仅仅在符合条件的时候进行插入和删除，从而达到不需要加锁的目的。</p>
<p>详细：<br>
  转载自陈皓的<a href="https://coolshell.cn/articles/8239.html">无锁队列的实现</a>，但是其中有一些细节的错误，我特意进行了修正或注释</p>
<h3 id="关于cas等原子操作">关于CAS等原子操作</h3>
<p>  在开始说无锁队列之前，我们需要知道一个很重要的技术就是CAS操作——Compare &amp; Set，或是 Compare &amp; Swap，现在几乎所有的CPU指令都支持CAS的原子操作，X86下对应的是 CMPXCHG 汇编指令。有了这个原子操作，我们就可以用其来实现各种无锁（lock free）的数据结构。</p>
<p>  这个操作用C语言来描述就是下面这个样子：（代码来自Wikipedia的Compare And Swap词条）意思就是说，看一看内存reg里的值<code>*reg</code>是不是<code>oldval</code>，如果是的话，则对其赋值<code>newval</code>。</p>
<pre><code>int compare_and_swap (int* reg, int oldval, int newval)
{
  int old_reg_val = *reg;
  if (old_reg_val == oldval) {
     *reg = newval;
  }
  return old_reg_val;
}
</code></pre>
<p>  我们可以看到，<code>old_reg_val</code> 总是返回，于是，我们可以在 <code>compare_and_swap</code> 操作之后对其进行测试，以查看它是否与 <code>oldval</code>相匹配，因为它可能有所不同，这意味着<strong>另一个并发线程已成功地竞争</strong>到 <code>compare_and_swap</code> 并成功将<code>reg</code>值从<code>oldval</code>更改为别的值了。</p>
<p>  这个操作可以变种为返回bool值的形式（返回 bool值的好处在于，可以调用者直接知道有没有更新成功）：</p>
<pre><code>bool compare_and_swap (int *addr, int oldval, int newval)
{
  if ( *addr != oldval ) {
      return false;
  }
  *addr = newval;
  return true;
}
</code></pre>
<p>与CAS相似的还有下面的原子操作：</p>
<ol>
<li>Fetch And Add，一般用来对变量做 +1 的原子操作</li>
<li>Test-and-set，写值到某个内存位置并传回其旧值。汇编指令BST</li>
<li>Test and Test-and-set，用来低低Test-and-Set的资源争夺情况</li>
</ol>
<p>注：在实际的C/C++程序中，CAS的各种实现版本如下：</p>
<ol>
<li>GCC的CAS</li>
</ol>
<p>GCC4.1+版本中支持CAS的原子操作（完整的原子操作可参看 GCC Atomic Builtins）</p>
<pre><code>bool __sync_bool_compare_and_swap (type *ptr, type oldval type newval, ...)
type __sync_val_compare_and_swap (type *ptr, type oldval type newval, ...)
</code></pre>
<ol start="2">
<li>Windows的CAS</li>
</ol>
<p>  在Windows下，你可以使用下面的Windows API来完成CAS：（完整的Windows原子操作可参看MSDN的InterLocked Functions）</p>
<pre><code> InterlockedCompareExchange ( __inout LONG volatile *Target,
                                 __in LONG Exchange,
                                 __in LONG Comperand);
</code></pre>
<ol start="3">
<li>C++11中的CAS</li>
</ol>
<p>  C++11中的STL中的atomic类的函数可以让你跨平台。（完整的C++11的原子操作可参看 Atomic Operation Library）</p>
<pre><code>template&lt; class T &gt;
bool atomic_compare_exchange_weak( std::atomic* obj,
                                   T* expected, T desired );
template&lt; class T &gt;
bool atomic_compare_exchange_weak( volatile std::atomic* obj,
                                   T* expected, T desired );
</code></pre>
<p><code>atomic_compare_exchange_weak</code><br>
  比较并交换被封装的值(weak)与参数 expected 所指定的值是否相等，如果：</p>
<ol>
<li>相等，则用 val 替换原子对象的旧值。</li>
<li>不相等，则用原子对象的旧值替换 expected ，因此调用该函数之后，如果被该原子对象封装的值与参数 expected 所指定的值不相等，expected 中的内容就是原子对象的旧值。<br>
  该函数通常会读取原子对象封装的值，如果比较为 true(即原子对象的值等于 expected)，则替换原子对象的旧值，但整个操作是原子的，在某个线程读取和修改该原子对象时，另外的线程不能对读取和修改该原子对象。</li>
</ol>
<p>  注意，该函数直接比较原子对象所封装的值与参数 expected 的物理内容，所以某些情况下，对象的比较操作在使用 operator==() 判断时相等，但 compare_exchange_weak 判断时却可能失败，因为对象底层的物理内容中可能存在位对齐或其他逻辑表示相同但是物理表示不同的值(比如 true 和 2 或 3，它们在逻辑上都表示&quot;真&quot;，但在物理上两者的表示并不相同)。</p>
<p>  与compare_exchange_strong 相比, weak 版本的 compare-and-exchange 操作允许(spuriously 地)返回 false(即原子对象所封装的值与参数 expected 的物理内容相同，但却仍然返回 false)，不过在某些需要循环操作的算法下这是可以接受的，并且在一些平台下 compare_exchange_weak 的性能更好 。如果 compare_exchange_weak 的判断确实发生了伪失败(spurious failures)——即使原子对象所封装的值与参数 expected 的物理内容相同，但判断操作的结果却为 false，compare_exchange_weak函数返回 false，并且参数 expected 的值不会改变。<br>
  与compare_exchange_weak 相比, strong版本的 compare-and-exchange 操作不允许(spuriously 地)返回 false，即原子对象所封装的值与参数 expected 的物理内容相同，比较操作一定会为 true。不过在某些平台下，如果算法本身需要循环操作来做检查， compare_exchange_weak 的性能会更好。</p>
<p>  所以对于某些不需要采用循环操作的算法而言, 通常采用compare_exchange_strong 更好。</p>
<h3 id="无锁队列的链表实现">无锁队列的链表实现</h3>
<p>下面的代码主要参考于两篇论文：</p>
<p>  John D. Valois 1994年10月在拉斯维加斯的并行和分布系统系统国际大会上的一篇论文——《Implementing Lock-Free Queues》<br>
  美国纽约罗切斯特大学 Maged M. Michael 和 Michael L. Scott 在1996年3月发表的一篇论文 《Simple, Fast, and Practical Non-Blocking and Blocking ConcurrentQueue Algorithms》<br>
（注：下面的代码并不完全与这篇论文相同）</p>
<p>  初始化一个队列的代码很简，初始化一个dummy结点（注：在链表操作中，使用一个dummy结点，可以少掉很多边界条件的判断），如下所示：</p>
<pre><code>InitQueue(Q)
{
    node = new node()
    node-&gt;next = NULL;
    Q-&gt;head = Q-&gt;tail = node;
}
</code></pre>
<p>我们先来看一下进队列用CAS实现的方式，基本上来说就是链表的两步操作：</p>
<p>第一步，把tail指针的next指向要加入的结点。 tail-&gt;next = p;<br>
第二步，把tail指针移到队尾。 tail = p;</p>
<pre><code>EnQueue(Q, data) //进队列
{
    //准备新加入的结点数据
    n = new node();
    n-&gt;value = data;
    n-&gt;next = NULL;
    do {
        p = Q-&gt;tail; //取链表尾指针的快照
    } while( CAS(p-&gt;next, NULL, n) != TRUE); 
    //while条件注释：如果没有把结点链在尾指针上，再试
    CAS(Q-&gt;tail, p, n); //置尾结点 tail = n;
}
</code></pre>
<p>  我们可以看到，程序中的那个 do-while 的 Retry-Loop 中的 CAS 操作：如果 p-&gt;next 是 NULL，那么，把新结点 n 加到队尾。如果不成功，则重新再来一次！</p>
<p>  就是说，很有可能我在准备在队列尾加入结点时，别的线程已经加成功了，于是tail指针就变了，于是我的CAS返回了false，于是程序再试，直到试成功为止。这个很像我们的抢电话热线的不停重播的情况。</p>
<p>  但是你会看到，为什么我们的“置尾结点”的操作（第13行）不判断是否成功，因为：</p>
<p>  如果有一个线程T1，它的while中的CAS如果成功的话，那么其它所有的 随后线程的CAS都会失败，然后就会再循环，<br>
  此时，如果T1 线程还没有更新tail指针，其它的线程继续失败，因为tail-&gt;next不是NULL了。<br>
  直到T1线程更新完 tail 指针，于是其它的线程中的某个线程就可以得到新的 tail 指针，继续往下走了。<br>
  所以，只要线程能从 while 循环中退出来，意味着，它已经“独占”了，tail 指针必然可以被更新。<br>
  这里有一个潜在的问题——<strong>如果T1线程在用CAS更新tail指针的之前，线程停掉或是挂掉了，那么其它线程就进入死循环了。</strong> 下面是改良版的EnQueue()</p>
<pre><code>EnQueue(Q, data) //进队列改良版 v1
{
    n = new node();
    n-&gt;value = data;
    n-&gt;next = NULL;
    p = Q-&gt;tail;
    oldp = p
    do {
        while (p-&gt;next != NULL)
            p = p-&gt;next;
    } while( CAS(p.next, NULL, n) != TRUE); //如果没有把结点链在尾上，再试
    CAS(Q-&gt;tail, oldp, n); //置尾结点
}
</code></pre>
<p>  我们让每个线程，自己fetch 指针 p 到链表尾。但是这样的fetch会很影响性能。而且，如果一个线程不断的EnQueue，会导致所有的其它线程都去 fetch 他们的 p 指针到队尾，能不能不要所有的线程都干同一个事？这样可以节省整体的时间？</p>
<p>  比如：直接 fetch Q-&gt;tail 到队尾？因为，所有的线程都共享着 Q-&gt;tail，所以，一旦有人动了它后，相当于其它的线程也跟着动了，于是，我们的代码可以改进成如下的实现：</p>
<pre><code>EnQueue(Q, data) //进队列改良版 v2 
{
    n = new node();
    n-&gt;value = data;
    n-&gt;next = NULL;
    while(TRUE) {
        //先取一下尾指针和尾指针的next
        tail = Q-&gt;tail;
        next = tail-&gt;next;
        //如果尾指针已经被移动了，则重新开始
        if ( tail != Q-&gt;tail ) continue;
        //如果尾指针的 next 不为NULL，则 fetch 全局尾指针到next
        if ( next != NULL ) {
            CAS(Q-&gt;tail, tail, next);
            continue;
        }
        //如果加入结点成功，则退出
        if ( CAS(tail-&gt;next, next, n) == TRUE ) break;
    }
    CAS(Q-&gt;tail, tail, n); //置尾结点
}
</code></pre>
<p>  上述的代码还是很清楚的，相信你一定能看懂，而且，这也是 Java 中的 ConcurrentLinkedQueue 的实现逻辑，当然，我上面的这个版本比 Java 的好一点，因为没有 if 嵌套，嘿嘿。</p>
<p>  好了，我们解决了EnQueue，我们再来看看DeQueue的代码：（很简单，我就不解释了）</p>
<pre><code>DeQueue(Q) //出队列
{
    do{
        p = Q-&gt;head;
        if (p-&gt;next == NULL){
            return ERR_EMPTY_QUEUE;
        }
    while( CAS(Q-&gt;head, p, p-&gt;next) != TRUE );
    return p-&gt;next-&gt;value;
}
</code></pre>
<p>  <strong>我们可以看到，DeQueue的代码操作的是 head-&gt;next，而不是 head 本身。这样考虑是因为一个边界条件，我们需要一个dummy的头指针来解决链表中如果只有一个元素，head 和 tail 都指向同一个结点的问题，这样 EnQueue 和 DeQueue 要互相排斥了。</strong></p>
<p>  但是，如果 head 和 tail 都指向同一个结点，这意味着队列为空，应该返回 ERR_EMPTY_QUEUE，但是，在判断 p-&gt;next == NULL 时，另外一个EnQueue操作做了一半，此时的 p-&gt;next 不为 NULL了，但是 tail 指针还差最后一步，没有更新到新加的结点，这个时候就会出现，在 EnQueue 并没有完成的时候， DeQueue 已经把新增加的结点给取走了，此时，队列为空，但是，head 与 tail 并没有指向同一个结点。如下所示：<br>
<img src="https://lixin-scut.github.io//post-images/1586482257913.png" alt=""><br>
  虽然，EnQueue的函数会把 tail 指针置对，但是，这种情况可能还是会导致一些并发问题，所以，严谨来说，我们需要避免这种情况。于是，我们需要加入更多的判断条件，还确保这个问题。下面是相关的改进代码：</p>
<pre><code>DeQueue(Q) //出队列，改进版
{
    while(TRUE) {
        //取出头指针，尾指针，和第一个元素的指针
        head = Q-&gt;head;
        tail = Q-&gt;tail;
        next = head-&gt;next;
        // Q-&gt;head 指针已移动，重新取 head指针
        if ( head != Q-&gt;head ) continue;
        
        // 如果是空队列
        if ( head == tail &amp;&amp; next == NULL ) {
            return ERR_EMPTY_QUEUE;
        }
        
        //如果 tail 指针落后了
        if ( head == tail &amp;&amp; next == NULL ) {
            CAS(Q-&gt;tail, tail, next);
            continue;
        }
        //移动 head 指针成功后，取出数据
        if ( CAS( Q-&gt;head, head, next) == TRUE){
            value = next-&gt;value;
            break;
        }
    }
    free(head); //释放老的dummy结点
    return value;
}
</code></pre>
<p>  上面这段代码的逻辑和 Java 的 ConcurrentLinkedQueue 的 poll 方法很一致了。也是《Simple, Fast, and Practical Non-Blocking and Blocking ConcurrentQueue Algorithms》这篇论文中的实现。</p>
<h3 id="cas的aba问题">CAS的ABA问题</h3>
<p>所谓ABA问题基本是这个样子：</p>
<ol>
<li>进程P1在共享变量中读到值为A</li>
<li>P1被抢占了，进程P2执行</li>
<li>P2把共享变量里的值从A改成了B，再改回到A，此时被P1抢占。</li>
<li>P1回来看到共享变量里的值没有被改变，于是继续执行。<br>
  虽然P1以为变量值没有改变，继续执行了，但是这个会引发一些潜在的问题。<strong>ABA问题最容易发生在lock free 的算法中的，CAS首当其冲，因为CAS判断的是指针的值。很明显，值是很容易又变成原样的。</strong></li>
</ol>
<p>  比如上述的DeQueue()函数，因为我们要让head和tail分开，所以我们引入了一个dummy指针给head，当我们做CAS的之前，如果head的那块内存被回收并被重用了，而重用的内存又被EnQueue()进来了，这会有很大的问题。（<strong>内存管理中重用内存基本上是一种很常见的行为</strong>）</p>
<p>这个例子你可能没有看懂，维基百科上给了一个活生生的例子——</p>
<blockquote>
<p>你拿着一个装满钱的手提箱在飞机场，此时过来了一个火辣性感的美女，然后她很暖昧地挑逗着你，并趁你不注意的时候，把用一个一模一样的手提箱和你那装满钱的箱子调了个包，然后就离开了，你看到你的手提箱还在那，于是就提着手提箱去赶飞机去了。</p>
</blockquote>
<p>这就是ABA的问题。</p>
<h3 id="解决aba的问题">解决ABA的问题</h3>
<p>  维基百科上给了一个解——使用double-CAS（双保险的CAS），例如，在32位系统上，我们要检查64位的内容</p>
<ol>
<li>
<p>一次用CAS检查双倍长度的值，前半部是值，后半部分是一个计数器。</p>
</li>
<li>
<p>只有这两个都一样，才算通过检查，要吧赋新的值。并把计数器累加1。</p>
</li>
</ol>
<p>  这样一来，ABA发生时，虽然值一样，但是计数器就不一样（但是在32位的系统上，这个计数器会溢出回来又从1开始的，这还是会有ABA的问题）</p>
<p>  当然，我们这个队列的问题就是不想让那个内存重用，这样明确的业务问题比较好解决，论文《Implementing Lock-Free Queues》给出一这么一个方法——<strong>使用结点内存引用计数refcnt</strong>！（论文《Simple, Fast, and Practical Non-Blocking and Blocking ConcurrentQueue Algorithms》中的实现方法也基本上是一样的，用到的是增加一个计数，可以理解为版本号）</p>
<p>）</p>
<pre><code>SafeRead(q)
{
    loop:
        p = q-&gt;next;
        if (p == NULL){
            return p;
        }
        Fetch&amp;Add(p-&gt;refcnt, 1);
        if (p == q-&gt;next){
            return p;
        }else{
            Release(p);
        }
    goto loop;
}
</code></pre>
<p>  其中的 Fetch&amp;Add和Release分是是加引用计数和减引用计数，都是原子操作，这样就可以阻止内存被回收了。</p>
<h3 id="用数组实现无锁队列">用数组实现无锁队列</h3>
<p>本实现来自论文《Implementing Lock-Free Queues》</p>
<p>  使用数组来实现队列是很常见的方法，因为没有内存的分部和释放，一切都会变得简单，实现的思路如下：</p>
<ol>
<li>
<p>数组队列应该是一个ring buffer形式的数组（环形数组）</p>
</li>
<li>
<p>数组的元素应该有三个可能的值：HEAD，TAIL，EMPTY（当然，还有实际的数据）</p>
</li>
<li>
<p>数组一开始全部初始化成EMPTY，有两个相邻的元素要初始化成HEAD和TAIL，这代表空队列。</p>
</li>
<li>
<p>EnQueue操作。假设数据x要入队列，定位TAIL的位置，使用double-CAS方法把(TAIL, EMPTY) 更新成 (x, TAIL)。需要注意，如果找不到(TAIL, EMPTY)，则说明队列满了。</p>
</li>
<li>
<p>DeQueue操作。定位HEAD的位置，把(HEAD, x)更新成(EMPTY, HEAD)，并把x返回。同样需要注意，如果x是TAIL，则说明队列为空。</p>
</li>
</ol>
<p>算法的一个关键是——如何定位HEAD或TAIL？</p>
<ol>
<li>
<p>我们可以声明两个计数器，一个用来计数EnQueue的次数，一个用来计数DeQueue的次数。</p>
</li>
<li>
<p>这两个计算器使用使用Fetch&amp;ADD来进行原子累加，在EnQueue或DeQueue完成的时候累加就好了。</p>
</li>
<li>
<p>累加后求个模什么的就可以知道TAIL和HEAD的位置了。</p>
</li>
</ol>
<p>如下图所示：<br>
<img src="https://lixin-scut.github.io//post-images/1586482291190.png" alt=""></p>
<h3 id="小结">小结</h3>
<p>以上基本上就是所有的无锁队列的技术细节，这些技术都可以用在其它的无锁数据结构上。</p>
<ol>
<li>
<p>无锁队列主要是通过CAS、FAA这些原子操作，和Retry-Loop实现。</p>
</li>
<li>
<p>对于Retry-Loop，我个人感觉其实和锁什么什么两样。只是这种“锁”的粒度变小了，主要是“锁”HEAD和TAIL这两个关键资源。而不是整个数据结构。</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 849. 到最近的人的最大距离[简单]]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-849-dao-zui-jin-de-ren-de-zui-da-ju-chi-jian-dan</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-849-dao-zui-jin-de-ren-de-zui-da-ju-chi-jian-dan">
        </link>
        <updated>2020-04-08T08:22:49.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>在一排座位（ seats）中，1 代表有人坐在座位上，0 代表座位上是空的。<br>
至少有一个空座位，且至少有一人坐在座位上。<br>
亚历克斯希望坐在一个能够使他与离他最近的人之间的距离达到最大化的座位上。<br>
返回他到离他最近的人的最大距离。<br>
示例 1：<br>
输入：[1,0,0,0,1,0,1]<br>
输出：2<br>
解释：<br>
如果亚历克斯坐在第二个空位（seats[2]）上，他到离他最近的人的距离为 2 。<br>
如果亚历克斯坐在其它任何一个空位上，他到离他最近的人的距离为 1 。<br>
因此，他到离他最近的人的最大距离是 2 。<br>
示例 2：<br>
输入：[1,0,0,0]<br>
输出：3<br>
解释：<br>
如果亚历克斯坐在最后一个座位上，他离最近的人有 3 个座位远。<br>
这是可能的最大距离，所以答案是 3 。<br>
提示：<br>
1 &lt;= seats.length &lt;= 20000<br>
seats 中只含有 0 和 1，至少有一个 0，且至少有一个 1。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/maximize-distance-to-closest-person<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>第一想法就是寻找最大的连续0的数量，然后取其中点吧</p>
<p>然后发现不对劲啊，比如示例二，在边缘的0没必要取中点啊。<br>
所以我针对边缘进行单独提取，使用left和right两个下标先检测两边的连续0的数量，再检测中间的连续0的数量</p>
<p>实现过程中需要注意的事项</p>
<ol>
<li>注意好初始化和重新赋值</li>
<li>中间的连续0的数量对于maxZeros的更新的规律为(zeroCounts + 1) / 2</li>
</ol>
<p>时间复杂度是O(n)，因为每个元素最多只被访问一次。</p>
<pre><code>class Solution {
public:
    int maxDistToClosest(vector&lt;int&gt;&amp; seats) {
        if(seats.empty())
        {   return 0;}
        
        int maxZeros = 0;
        int zeroCounts = 0;
        
        int left = 0;
        int right = seats.size() - 1;
        while(seats[left] == 0)
        {
            ++zeroCounts;
            maxZeros = maxZeros &gt; zeroCounts ? maxZeros : zeroCounts; 
            ++left;
        }
        
        zeroCounts = 0;
        while(seats[right] == 0)
        {
            ++zeroCounts;
            maxZeros = maxZeros &gt; zeroCounts ? maxZeros : zeroCounts; 
            --right;
        }
        
        for(int i = left; i &lt; right; ++i)
        {
            if(seats[i] == 1)
            {
                zeroCounts = 0;
            }
            if(seats[i] == 0)
            {
                ++zeroCounts;
                maxZeros = maxZeros &gt; (zeroCounts + 1) / 2 ? maxZeros : (zeroCounts + 1) / 2;
            }
        }
        return maxZeros;
    }
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>方法一：计算座位到最近的人的最大距离【通过】<br>
思路<br>
令 left[i] 为座位 i 到坐在 i 左边的人的最近距离。同理 right[i] 为座位 i 到坐在 i 右边的人的最近距离。那么该座位到最近的人的距离为 min(left[i], right[i])。<br>
算法<br>
如果 i 左边的位置是空的，那么 left[i] = left[i - 1] + 1；否则 left[i] = 0。right[i] 的计算方法类似。</p>
</blockquote>
<pre><code>class Solution {
    public int maxDistToClosest(int[] seats) {
        int N = seats.length;
        int[] left = new int[N], right = new int[N];
        Arrays.fill(left, N);
        Arrays.fill(right, N);

        for (int i = 0; i &lt; N; ++i) {
            if (seats[i] == 1) left[i] = 0;
            else if (i &gt; 0) left[i] = left[i-1] + 1;
        }

        for (int i = N-1; i &gt;= 0; --i) {
            if (seats[i] == 1) right[i] = 0;
            else if (i &lt; N-1) right[i] = right[i+1] + 1;
        }

        int ans = 0;
        for (int i = 0; i &lt; N; ++i)
            if (seats[i] == 0)
                ans = Math.max(ans, Math.min(left[i], right[i]));
        return ans;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(N)，其中 N 是 seats 的长度。<br>
空间复杂度：O(N)，存储 left 和 right 的空间。</p>
</blockquote>
<blockquote>
<p>方法二：双指针【通过】<br>
思路<br>
遍历所有座位 seats，找出每个空位左边最近的人和右边最近的人，更新当前空位到最近的人的距离。<br>
算法<br>
使用 prev 记录 i 最左边第一个有人的位置，future 记录 i 最右边第一个有人的位置。<br>
座位 i 到最近的人的距离为 min(i - prev, future - i)。另外有一种特殊情况，如果座位 i 左边没有人，则认为到左边第一个人的距离是无限大，右边同理。</p>
</blockquote>
<pre><code>class Solution {
    public int maxDistToClosest(int[] seats) {
        int N = seats.length;
        int prev = -1, future = 0;
        int ans = 0;

        for (int i = 0; i &lt; N; ++i) {
            if (seats[i] == 1) {
                prev = i;
            } else {
                while (future &lt; N &amp;&amp; seats[future] == 0 || future &lt; i)
                    future++;

                int left = prev == -1 ? N : i - prev;
                int right = future == N ? N : future - i;
                ans = Math.max(ans, Math.min(left, right));
            }
        }

        return ans;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(N)，其中 N 是 seats 的长度。<br>
空间复杂度：O(1)。</p>
</blockquote>
<blockquote>
<p>方法三：按零分组【通过】<br>
思路<br>
如果两人之间有连续 K 个空座位，那么其中存在至少一个座位到两边最近的人的距离为 (K+1) / 2。<br>
算法<br>
假设两个人之间有 K 个空座位，则存在座位到最近的人的距离为 (K+1) / 2。<br>
对于边缘的座位，它们的一侧没有人，那么认为它们到该侧最近的人的距离为 K。</p>
</blockquote>
<pre><code>class Solution {
    public int maxDistToClosest(int[] seats) {
        int N = seats.length;
        int K = 0; //current longest group of empty seats
        int ans = 0;

        for (int i = 0; i &lt; N; ++i) {
            if (seats[i] == 1) {
                K = 0;
            } else {
                K++;
                ans = Math.max(ans, (K + 1) / 2);
            }
        }

        for (int i = 0; i &lt; N; ++i)  if (seats[i] == 1) {
            ans = Math.max(ans, i);
            break;
        }

        for (int i = N-1; i &gt;= 0; --i)  if (seats[i] == 1) {
            ans = Math.max(ans, N - 1 - i);
            break;
        }

        return ans;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(N)，其中 N 是 seats 的长度。<br>
空间复杂度：O(1)。在 Python中 seats[::-1] 的空间为 O(N)，但它可以被省略。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 174:地下城游戏[困难][未做出]]]></title>
        <id>https://lixin-scut.github.io//post/dong-tai-gui-hua-174di-xia-cheng-you-xi-kun-nan-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/dong-tai-gui-hua-174di-xia-cheng-you-xi-kun-nan-wei-zuo-chu">
        </link>
        <updated>2020-04-07T09:50:08.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。<br>
骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。<br>
有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。<br>
为了尽快到达公主，骑士决定每次只向右或向下移动一步。<br>
编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。<br>
例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -&gt; 右 -&gt; 下 -&gt; 下，则骑士的初始健康点数至少为 7。</p>
</blockquote>
<table>
<thead>
<tr>
<th>-</th>
<th>-</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>-2 (K)</td>
<td>-3</td>
<td>3</td>
</tr>
<tr>
<td>-5</td>
<td>-10</td>
<td>1</td>
</tr>
<tr>
<td>10</td>
<td>30</td>
<td>-5 (P)</td>
</tr>
</tbody>
</table>
<blockquote>
<p>说明:<br>
骑士的健康点数没有上限。<br>
任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/dungeon-game<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>解题思路：<br>
很明显的动态规划<br>
而且规定了每次只向右或向下移动一步<br>
这个状态转移比较有趣，选的是top和left两者最大的值，而不是最小值，再倒推健康点数<br>
然后按照上次的官方题解，可以原地修改值，而不用新建一个容器</p>
<p>做完我才发现我理解错题意了。。。其实是记录每条路径的负数的最小值。。。再从中选出最大值<br>
我暂时的想法是用一个pair记录每个格子当前值和曾经的最小值，因为动态规划需要当前值，最终结果则需要最小值<br>
状态方程改为 判断最小值的最大者，而不是当前值的最大者<br>
后来修改了注意，不用pair，而是使用修改原vector+记录最小值的vector的模式</p>
<p>然后发现这个方法是错误的<br>
一个比较极端的情况是 {{0, -100, 200}, {0,0,0}} 和 {{0, -100, 200}, {0, -1, -100}}。<br>
很明显前者需要比较最小值（hpMap），而后者需要比较当前值（dungeon）</p>
<p>直接看题解吧<br>
发现问题所在了，应该逆向思维，从后往前推<br>
然后每个点根据当前的值来确定，如果当前值为正数，则置为0，为负数则直接翻转<br>
然后每个值的当前值等于right和bottom的最小值（注意此时是正值），再减去当前值（注意是减去，等于翻转）<br>
得到的就是正的血量<br>
记得最后要+1.</p>
<pre><code>class Solution {
public:
    int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon)
    {
        if(dungeon.empty())
        {   return 0;}
        
        //vector&lt;vector&lt;int&gt;&gt; hpMap(dungeon.begin(), dungeon.end());
        
        for(int row = dungeon.size() - 1; row &gt;= 0; --row)
        {
            for(int col = dungeon[0].size() - 1; col &gt;= 0; --col)
            {
                if(row == dungeon.size() - 1 &amp;&amp; col == dungeon[0].size() - 1)
                {
                    dungeon[row][col] = max(0, -dungeon[row][col]);
                    continue;
                }
                
                if(row == dungeon.size() - 1)
                {
                    int hpMin = dungeon[row][col + 1] - dungeon[row][col];
                    dungeon[row][col] = max(0, hpMin);
                    continue;
                }
                if(col == dungeon[0].size() - 1)
                {
                    int hpMin = dungeon[row + 1][col] - dungeon[row][col];
                    dungeon[row][col] = max(0, hpMin);
                    continue;
                }
                
                int hpMin = min(dungeon[row][col + 1], dungeon[row + 1][col]) - dungeon[row][col];
                dungeon[row][col] = max(0, hpMin);
            }
        }
        return dungeon[0][0] + 1;
    }
    
    /*
    错误代码
    int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon) {
        if(dungeon.empty())
        {   return 0;}
        
        vector&lt;vector&lt;int&gt;&gt; hpMap(dungeon.begin(), dungeon.end());
        
        for(int row = 0; row &lt; dungeon.size(); ++row)
        {
            for(int col = 0; col &lt; dungeon[0].size(); ++col)
            {
                if(row == 0 &amp;&amp; col == 0)
                {
                    continue;
                }               
                else if(row == 0)
                {
                    dungeon[row][col] += dungeon[row][col - 1];
                    hpMap[row][col] = hpMap[row][col - 1];
                    hpMap[row][col] = hpMap[row][col] &lt; dungeon[row][col] ? hpMap[row][col] : dungeon[row][col];
                    continue;
                }
                else if(col == 0)
                {
                    dungeon[row][col] += dungeon[row - 1][col];
                    hpMap[row][col] = hpMap[row - 1][col];
                    hpMap[row][col] = hpMap[row][col] &lt; dungeon[row][col] ? hpMap[row][col] : dungeon[row][col];
                    continue;
                }
                else
                {
                    
                    if(hpMap[row][col - 1]  ==  hpMap[row - 1][col])
                    {
                         dungeon[row][col] += dungeon[row][col - 1] &gt; dungeon[row - 1][col] ? dungeon[row][col - 1] : dungeon[row - 1][col];
                         hpMap[row][col] = hpMap[row][col - 1] &lt; dungeon[row][col] ? hpMap[row][col - 1] : dungeon[row][col];
                    }
                    else
                    {
                        dungeon[row][col] += hpMap[row][col - 1] &gt; hpMap[row - 1][col] ? dungeon[row][col - 1] : dungeon[row - 1][col];
                        hpMap[row][col] = hpMap[row][col - 1] &gt; hpMap[row - 1][col] ? hpMap[row][col - 1] : hpMap[row - 1][col];
                        hpMap[row][col] = hpMap[row][col] &lt; dungeon[row][col] ? hpMap[row][col] : dungeon[row][col];
                    }
                }
            }
        }
        
        return hpMap.back().back() &gt;= 0 ? 1 : -hpMap.back().back() + 1;
    }
    */
};
</code></pre>
<p>网友题解：<br>
<a href="https://leetcode-cn.com/problems/dungeon-game/solution/cong-hui-su-dao-ji-yi-hua-sou-suo-dao-dong-tai-gui/">从回溯 到 记忆化搜索 到 动态规划</a></p>
<p>动态规划</p>
<blockquote>
<p>我们的动态规划是从最后一个开始走的，每走一步，出来就记录一下，然后不断复用。<br>
其实核心的公式我们已经知道了，也就是最优子结构：<br>
<code>needMin + globalDun[i][j] = Math.min(dp[i + 1][j], dp[i][j + 1])</code><br>
其实这段代码：</p>
</blockquote>
<pre><code>if (needMin &lt; 0) {  
	res =  0;
} else {
	res =  needMin;
}
</code></pre>
<blockquote>
<p>可以等价于下面这段：<br>
<code>dp[i][j] = Math.max(0, needMin);</code><br>
所以我们可以来看下这个代码：</p>
</blockquote>
<pre><code>public int calculateMinimumHPBest(int[][] dungeon) {
    if (dungeon == null || dungeon.length == 0 || dungeon[0].length == 0) {
        return 0;
    }
    int rowSize = dungeon.length;
    int colSize = dungeon[0].length;
    int[][] dp = new int[rowSize][colSize];
    // 设置最后一个值。
  	dp[rowSize - 1][colSize -1] = Math.max(0, -dungeon[rowSize - 1][colSize - 1]);

    // 设置最后一列的值
  	for (int i = rowSize - 2; i &gt;= 0; --i) {
        int needMin = dp[i + 1][colSize - 1] - dungeon[i][colSize - 1];
        dp[i][colSize -1] = Math.max(0, needMin);
    }

    // 设置最后一行的值
  	for (int i = colSize - 2; i &gt;= 0; --i) {
        int needMin = dp[rowSize - 1][i + 1] - dungeon[rowSize - 1][i];
        dp[rowSize - 1][i] = Math.max(0, needMin);
    }

    for (int i = rowSize - 2; i &gt;= 0; --i) {
        for (int j = colSize - 2; j &gt;= 0; --j) {
			// 从右边和下边选择一个最小值，然后减去当前的 dungeon 值
            int needMin = Math.min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j];
            dp[i][j] = Math.max(0, needMin);
        }
    }
    return dp[0][0] + 1;
}
</code></pre>
<blockquote>
<p>时间复杂度O(N),空间复杂度O(N)。</p>
</blockquote>
<p>网友题解可以进一步压缩空间复杂度，首先可以改为一维数组暂存，然后对比网友题解，我直接使用了原数组进行修改，所以空间复杂度为O(1)。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[atomic类型]]></title>
        <id>https://lixin-scut.github.io//post/atomic-lei-xing</id>
        <link href="https://lixin-scut.github.io//post/atomic-lei-xing">
        </link>
        <updated>2020-04-07T02:50:32.000Z</updated>
        <content type="html"><![CDATA[<p>首先从一个问题开始：</p>
<blockquote>
<p>自增++i是否是原子操作<br>
两种解释：<br>
1.++i的操作分三步：<br>
（1）栈中取出i<br>
（2）i自增1<br>
（3）将i存到栈<br>
2.++i分为三个阶段：<br>
（1）内存读入到寄存器<br>
（2）寄存器自增<br>
（3）存入内存<br>
这三个阶段中间都可以被中断分离开.<br>
所以i++不是原子操作，上面的三个步骤中任何一个步骤同时操作，都可能导致i的值不正确自增</p>
</blockquote>
<p>  所以++i明显是线程不安全的，所以对于共享的变量（全局变量、静态变量）都需要加锁才能安全地进行自增等操作，但这未免效率太低了，而且可移植性差，到了别的系统可能锁就白给了，所以C++为了追求极致，C++11中开发了自己的atomic类型，本质是一个模板，主要根据不同的编译器和系统来确定可以使用的互斥器等类型，然后封装了高效的同步或互斥操作，并提供了相对应的复制、读取和递增递减等线程安全的操作。</p>
<p>下面是详细介绍</p>
<p>  C++11 标准中，相当大的一个变化就是引入了多线程的支持，这使得用C/C++进行线程编程时，不必依赖第三方库和标准。<br>
  而C++11对多线程的支持，最为重要的部分，就是在原子操作中引入了原子类型的概念。</p>
<h3 id="原子操作">原子操作</h3>
<p>  所谓原子操作，就是多线程程序中“最小的且不可并行化的”操作。对于在多个线程间共享的一个资源而言，这意味着同一时刻，多个线程中有且仅有一个线程在对这个资源进行操作，即互斥访问。提到“互斥”访问，熟悉多线程开发的同学可能立即想到Windows平台下使用的临界区/CRITICAL_SECTION、互斥体/Mutex。实现互斥通常需要平台相关的特殊指令，在C++11标准之前，这意味着需要在C/C++代码中嵌入平台相关的内联汇编代码。 平台相关意味着：1.你必须了解平台相关的编译器扩展；2.无法跨平台运行你的多线程程序。</p>
<pre><code>#include ＜pthread.h＞
#include ＜iostream＞
using namespace std;
static long long total=0;
pthread_mutex_t m=PTHREAD_MUTEX_INITIALIZER;
void*func(void*){
long long i;
for(i=0;i＜100000000LL;i++){
pthread_mutex_lock(＆m);
total+=i;
pthread_mutex_unlock(＆m);
}
}
int main(){
pthread_t thread1,thread2;
if(pthread_create(＆thread1,NULL,＆func,NULL)){
throw;
}
if(pthread_create(＆thread2,NULL,＆func,NULL)){
throw;
}
pthread_join(thread1,NULL);
pthread_join(thread2,NULL);
cout＜＜total＜＜endl;//9999999900000000
return 0;
}
//编译选项:g++6-3-1.cpp-lpthread
</code></pre>
<p>  代码中，我们启动两个线程来更新变量total的值，为了防止数据竞争问题，我们需要使用pthread_mutex_t类型的互斥锁，来保证两个线程互斥地访问total，从而得到total的正确结果。这个例子演示了多线程开发的基本问题：</p>
<p>  找到多个线程共享的资源/数据(飞机上洗手间里的马桶)。操作这些资源/数据的代码称之为临界区（洗手间）。<br>
  线程进入临界区并加锁，防止其他线程进入临界区(进房间后立即锁门，其他人排队)。<br>
  更新/操作共享的资源/数据(…………)<br>
  线程离开临界区，独享权让给其他等待的线程(解锁，开门。下一位……)。<br>
  如果多个线程各干各的活，没有共享的资源/数据，老死不相往来，那就没有临界区、互斥锁等所有这些破事了，完美！</p>
<p>但是！</p>
<p>  对于熟悉单线程开发的同学来说，互斥锁的管理无疑是个负担。需要说明的是，上述代码仅仅演示最基本、最简单的情形。复杂、特殊情况下，这个管理负担还是挺重的，这里就不展开讨论。</p>
<p>  “就两个线程就共享了一个数据，需要承担互斥锁的管理负担？！”相较于单线程程序，虽然只多写了两行代码，但是程序员都是懒惰的——能不写的代码坚决不写，能少写的坚决不多写(在保证代码可读性的前提下)，这也是优秀程序员的标准做法。</p>
<p>  另外一个问题是跨平台——上述代码在LINUX平台下用g++编译运行的，但是在Windows平台上，得做一番改动/重写才能运行起来。Once for all? ! No way!</p>
<p>  C++11标准从不同的视角看待这个问题：需要同步的总是资源/数据，而不是代码。因此C++11对数据进行了更为良好的抽象，引入&quot;原子数据类型&quot;/atomic类型，以达到对开发者掩盖互斥锁、临界区的目的。要知道，这些临界区、互斥锁才是平台相关的东西。来看下面的示例代码。</p>
<pre><code>#include&lt;atomic&gt;
#include&lt;thread&gt;
#include&lt;iostream&gt;

using namespace std;
std::atomic_llong total{ 0 };//原子数据类型

void func(int)
{
    for (long long i = 0; i&lt;100000000LL; ++i)
    {
        total += i;
    }
}

int main()
{
    thread t1(func, 0);
    thread t2(func, 0);
    t1.join();
    t2.join();
    cout&lt;&lt;total&lt;&lt;endl;//9999999900000000
    return 0;
}
//编译选项:g++ -std=c++11 6-3-2.cpp-lpthread
</code></pre>
<p>  代码中，将total定义为“原子数据类型”：atomic_llong, 该数据类型长度等于C++11中内置数据类型long long。可以看到，程序员不需要为原子数据类型显示地调用加锁、解锁的API，线程就能够对共享数据total进行互斥地访问。太容易了，又可以“偷懒”了！</p>
<p>  上述代码，书1作者在Linux系统下开发，用g++编译器编译运行的。代码不做任何改动，我在Windows系统下使用Visual Studio 2015编译运行也OK的。</p>
<p>  那么问题来了：既然原子操作都是平台相关的，那么atomic数据类型又如何帮助我们“掩盖”这种平台相关性呢？C++11 对常见的原子操作进行了抽象，定义出统一的接口，并根据编译选项/环境产生平台相关的实现。新标准将原子操作定义为atomic模板类的成员函数，囊括了绝大多数典型的操作——读、写、比较、交换等。</p>
<h3 id="原子数据类型atomic类型">原子数据类型/atomic类型</h3>
<p>让我们先来看一下atomic模板类:</p>
<pre><code>template &lt;class T&gt; struct atomic

//example
#include&lt;atomic&gt;

void test()
{
    std::atomic_int nThreadData; // std::atomic_int  &lt;----&gt; std::atomic&lt;int&gt;
    nThreadData = 10;
    nThreadData.store(10);
    //TODO: use nThreadData here;
}
</code></pre>
<p>  对于内置型数据类型，C11和C++11标准中都已经提供了实例化原子类型，如下表所示：<br>
<img src="https://lixin-scut.github.io//post-images/1586228285225.png" alt=""></p>
<p>atomic类型原子操作接口如下：<br>
<img src="https://lixin-scut.github.io//post-images/1586228358118.png" alt=""><br>
这些接口函数的说明和示例代码，可参考如下链接：<br>
https://en.cppreference.com/<br>
http://www.cplusplus.com/</p>
<p>  更详细的接口介绍可以查看：<a href="https://www.cnblogs.com/haippy/p/3304556.html">C++11 并发指南六(atomic 类型详解三 std::atomic (续))</a>，该作者针对atomic有四篇文章，详细介绍了相关的接口。</p>
<p>  总体而言，在多线程程序中使用这些内置数据类型对应的atomic类型，还是不难的，应付一般的多线程问题还是得心应手的。有的同学会立即想到，线程间需要交互好多数据？用自定义数据类型/UDT去实例化atomic模板类, 岂不是可以大大缩减开发的工作量？请注意表#2最后一列，class-type就是指自定义数据类型/UDT.</p>
<p>  但是！UDT要满足以下5个条件，才可作为模板参数去实例化atomic模板：</p>
<pre><code>#include &lt;atomic&gt;
#include &lt;type_traits&gt;

using namespace std;

struct MY_UDT
{
    //TODO:data member here
};

int main()
{
    auto ret = std::is_trivially_copyable&lt;MY_UDT&gt;::value;
    ret = std::is_copy_constructible&lt;MY_UDT&gt;::value;
    ret = std::is_move_constructible&lt;MY_UDT&gt;::value;
    ret = std::is_copy_assignable&lt;MY_UDT&gt;::value;
    ret = std::is_move_assignable&lt;MY_UDT&gt;::value;

    return 0;
}
</code></pre>
<p>  MY_UDT是用户自定义数据类型，上述代码中，5个ret值必须都为true。也就是说对UDT的拷贝构造、赋值构造、移动赋值等各方面都提出了要求……“要求这么高！？”用了atomic模板类，既不劳烦你写加锁/解锁代码，又不用你考虑跨平台那档子事，多好！ 哪有无缘无故的好事？总要付出一定代价的。</p>
<h3 id="内存模型">内存模型</h3>
<p>  通常情况下，内存模型是一个硬件上的概念，表示的是机器指令（或者将其视为汇编指令也可以）是以什么样的顺序被处理器执行的。现代的处理器并不是逐条处理机器指令的。<br>
<img src="https://lixin-scut.github.io//post-images/1586228634335.png" alt=""></p>
<h4 id="顺序一致内存顺序memory_order_seq_cst">顺序一致内存顺序/memory_order_seq_cst</h4>
<p>  定义规则：全部存取都按照顺序执行。</p>
<p>  memory_order_seq_cst 表示该原子操作必须顺序一致的，这是C++11中所有atomic原子操作的默认值。这样来理解“顺序一致”：即代码在线程中运行的顺序与程序员看到的代码顺序一致。也就是说，用此值提示编译器“不要给我重排序指令，不要整什么指令乱序执行，就按照我代码的先后顺序执行机器指令”。在示例代码中，a的赋值语句先于b的赋值语句执行，这种称之为”先于发生(happens-before)“关系。用memory_order_seq_cst 可以确保这种happens_before关系。</p>
<h4 id="松散内存顺序memory_order_relaxed">松散内存顺序/memory_order_relaxed</h4>
<p>  定义规则：不对执行顺序做任何保证。</p>
<p>  表示该原子操作指令可以任由编译器重排或者由处理器乱序执行。就是说”想怎么乱就怎么乱吧，不管了，只要能提高指令执行效率“。代码清单6-23中使用的就是松散内存模型，在Observer中打印出(0,2)这样的结果也是合理的——把我代码中的顺序都彻底整反了！</p>
<h4 id="release-acquire内存顺序">Release-acquire内存顺序</h4>
<p><strong>memory_orderacquire</strong></p>
<p>  规则定义：本线程中，所有后续的读操作，必须在本条原子操作完成后执行。(本线程中，我先读，你们后读……)</p>
<p><strong>memory_order_release</strong></p>
<p>  规则定义：本线程中，所有之前的写操作完成后，才能执行本原子操作。（在本线程中，你们先写，我最后写……）</p>
<p>  上面讲的顺序一致和松散方式对应着两个极端——一个是严格禁止”乱“，一个是允许随便”乱“。但是现实的问题是：严格禁止”乱“，指令执行不够快；允许随便”乱“，又得不到正确结果。</p>
<h4 id="release-consume内存顺序">Release-consume内存顺序</h4>
<p><strong>memory_order_consume</strong></p>
<p>  规则定义：本线程中，所有后续的有关本算子类型的操作，必须在本条原子操作完成之后执行。(本线程中，我只关心我自己，当我用memory_order_consume时，后面所有对我的读写操作都不能被提前执行……)</p>
<p>  相比于memory_order__acquire，memory_order_consume进一步放松了依赖关系。大家发现没有，前面讲的几种内存顺序都是在操控/安排多个atomic数据之间的读写顺序，而memory_order_consume仅仅考虑对一个atomic数据的读写顺序。</p>
<h3 id="参考资料">参考资料：</h3>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/107092432?utm_source=wechat_timeline">C++11 - atomic类型和内存模型</a></li>
<li><a href="https://www.cnblogs.com/haippy/p/3252056.html">C++11 并发指南六(atomic 类型详解一 atomic_flag 介绍)</a>，该作者针对atomic有四篇文章，详细介绍了相关的接口。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[布隆过滤器]]></title>
        <id>https://lixin-scut.github.io//post/bu-long-guo-lu-qi</id>
        <link href="https://lixin-scut.github.io//post/bu-long-guo-lu-qi">
        </link>
        <updated>2020-04-07T02:07:18.000Z</updated>
        <content type="html"><![CDATA[<h3 id="个人总结">个人总结：</h3>
<p><strong>概念</strong></p>
<p>  布隆过滤器是一种概率型数据结构，利用了位图的思想来节省空间，通过使用多个不同的哈希函数生成多个哈希值，并对每个生成的哈希值指向的 bit 位置 1。从而达到高效的插入和查询。需要注意的是由于插入存在覆盖，查询的结果是具有失败概率的，同时覆盖的存在也导致传统的布隆过滤器并不支持删除操作。</p>
<p><strong>优缺点与用途</strong></p>
<p>优点：</p>
<ol>
<li>不需要存储数据本身，只用比特表示，因此空间占用相对于传统方式有巨大的优势，并且能够保密数据；</li>
<li>时间效率也较高，插入和查询的时间复杂度均为O(k)；</li>
<li>哈希函数之间相互独立，可以在硬件指令层面并行计算。</li>
</ol>
<p>缺点：</p>
<ol>
<li>存在假阳性的概率，不适用于任何要求100%准确率的情境；</li>
<li>只能插入和查询元素，不能删除元素，这与产生假阳性的原因是相同的。可以简单地通过计数（即将一个比特扩展为计数值）来记录元素数，但仍然无法保证删除的元素一定在集合中。</li>
</ol>
<p>  所以，在对查准度要求没有那么苛刻，而对时间、空间效率要求较高的场合非常合适布隆过滤器，例如利用布隆过滤器减少磁盘 IO 或者网络请求，因为一旦一个值必定不存在的话，我们可以不用进行后续昂贵的查询请求。所以，由于布隆过滤器不存在假阴性问题，所以用作“不存在”逻辑的处理时有奇效，比如可以用来作为缓存系统（如Redis）的缓冲，防止缓存穿透。</p>
<p>下面为详细内容，主要转载 YoungChen__ 的<a href="https://www.jianshu.com/p/2104d11ee0a2">详解布隆过滤器的原理、使用场景和注意事项</a></p>
<h3 id="什么是布隆过滤器">什么是布隆过滤器</h3>
<p>  本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。</p>
<p>  相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</p>
<h3 id="实现原理">实现原理</h3>
<p><strong>HashMap 的问题</strong></p>
<p>  讲述布隆过滤器的原理之前，我们先思考一下，通常你判断某个元素是否存在用的是什么？应该蛮多人回答 HashMap 吧，确实可以将值映射到 HashMap 的 Key，然后可以在 O(1) 的时间复杂度内返回结果，效率奇高。但是 HashMap 的实现也有缺点，例如存储容量占比高，考虑到负载因子的存在，通常空间是不能被用满的，而一旦你的值很多例如上亿的时候，那 HashMap 占据的内存大小就变得很可观了。</p>
<p>  还比如说你的数据集存储在远程服务器上，本地服务接受输入，而数据集非常大不可能一次性读进内存构建 HashMap 的时候，也会存在问题。</p>
<p><strong>布隆过滤器数据结构</strong></p>
<p>  布隆过滤器是一个 bit 向量或者说 bit 数组，长这样：</p>
<p><img src="https://lixin-scut.github.io//post-images/1586225925249.png" alt=""></p>
<p>  如果我们要映射一个值到布隆过滤器中，我们需要使用多个不同的哈希函数生成多个哈希值，并对每个生成的哈希值指向的 bit 位置 1，例如针对值 “baidu” 和三个不同的哈希函数分别生成了哈希值 1、4、7，则上图转变为：</p>
<p><img src="https://lixin-scut.github.io//post-images/1586225949536.png" alt=""></p>
<p>  Ok，我们现在再存一个值 “tencent”，如果哈希函数返回 3、4、8 的话，图继续变为：</p>
<p><img src="https://lixin-scut.github.io//post-images/1586225970063.png" alt=""></p>
<p>  值得注意的是，4 这个 bit 位由于两个值的哈希函数都返回了这个 bit 位，因此它被覆盖了。现在我们如果想查询 “dianping” 这个值是否存在，哈希函数返回了 1、5、8三个值，结果我们发现 5 这个 bit 位上的值为 0，说明没有任何一个值映射到这个 bit 位上，因此我们可以很确定地说 “dianping” 这个值不存在。而当我们需要查询 “baidu” 这个值是否存在的话，那么哈希函数必然会返回 1、4、7，然后我们检查发现这三个 bit 位上的值均为 1，那么我们可以说 “baidu” 存在了么？答案是不可以，只能是 “baidu” 这个值可能存在。</p>
<p>  这是为什么呢？答案跟简单，因为随着增加的值越来越多，被置为 1 的 bit 位也会越来越多，这样某个值 “taobao” 即使没有被存储过，但是万一哈希函数返回的三个 bit 位都被其他值置位了 1 ，那么程序还是会判断 “taobao” 这个值存在。</p>
<h3 id="支持删除么">支持删除么</h3>
<p>  传统的布隆过滤器并不支持删除操作。但是名为 Counting Bloom filter 的变种可以用来测试元素计数个数是否绝对小于某个阈值，它支持元素删除。可以参考文章 <a href="https://cloud.tencent.com/developer/article/1136056">Counting Bloom Filter</a> 的原理和实现</p>
<h3 id="如何选择哈希函数个数和布隆过滤器长度">如何选择哈希函数个数和布隆过滤器长度</h3>
<p>  很显然，过小的布隆过滤器很快所有的 bit 位均为 1，那么查询任何值都会返回“可能存在”，起不到过滤的目的了。布隆过滤器的长度会直接影响误报率，布隆过滤器越长其误报率越小。</p>
<p>  另外，哈希函数的个数也需要权衡，个数越多则布隆过滤器 bit 位置位 1 的速度越快，且布隆过滤器的效率越低；但是如果太少的话，那我们的误报率会变高。</p>
<p><img src="https://lixin-scut.github.io//post-images/1586226067467.png" alt=""></p>
<p>  如何选择适合业务的 k 和 m 值呢，这里直接贴一个公式：</p>
<p><img src="https://lixin-scut.github.io//post-images/1586226081707.png" alt=""></p>
<p>  k 为哈希函数个数，m 为布隆过滤器长度，n 为插入的元素个数，p 为误报率。<br>
  至于如何推导这个公式，我在知乎发布的<a href="https://zhuanlan.zhihu.com/p/43263751">文章</a>有涉及，感兴趣可以看看，不感兴趣的话记住上面这个公式就行了。</p>
<h3 id="最佳实践">最佳实践</h3>
<p>  常见的适用常见有，利用布隆过滤器减少磁盘 IO 或者网络请求，因为一旦一个值必定不存在的话，我们可以不用进行后续昂贵的查询请求。</p>
<p>  另外，既然你使用布隆过滤器来加速查找和判断是否存在，那么性能很低的哈希函数不是个好选择，推荐 MurmurHash、Fnv 这些。</p>
<h3 id="大value拆分">大Value拆分</h3>
<p>  Redis 因其支持 setbit 和 getbit 操作，且纯内存性能高等特点，因此天然就可以作为布隆过滤器来使用。但是布隆过滤器的不当使用极易产生大 Value，增加 Redis 阻塞风险，因此生成环境中建议对体积庞大的布隆过滤器进行拆分。</p>
<p>  拆分的形式方法多种多样，但是本质是不要将 Hash(Key) 之后的请求分散在多个节点的多个小 bitmap 上，而是应该拆分成多个小 bitmap 之后，对一个 Key 的所有哈希函数都落在这一个小 bitmap 上。</p>
<p>参考资料：</p>
<ol>
<li><a href="https://www.jianshu.com/p/2104d11ee0a2">详解布隆过滤器的原理、使用场景和注意事项</a></li>
<li><a href="https://www.jianshu.com/p/bef2ec1c361f">布隆过滤器（Bloom Filter）原理及Guava中的具体实现</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/72378274">数学之美：布隆过滤器</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[回溯法 51. N皇后（全排列）[困难]]]></title>
        <id>https://lixin-scut.github.io//post/hui-su-fa-51-n-huang-hou-quan-pai-lie-kun-nan</id>
        <link href="https://lixin-scut.github.io//post/hui-su-fa-51-n-huang-hou-quan-pai-lie-kun-nan">
        </link>
        <updated>2020-04-06T08:59:26.000Z</updated>
        <content type="html"><![CDATA[<p>题目</p>
<blockquote>
<p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。<br>
给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。<br>
每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。<br>
示例:<br>
输入: 4<br>
输出: [<br>
[&quot;.Q..&quot;,  // 解法 1<br>
&quot;...Q&quot;,<br>
&quot;Q...&quot;,<br>
&quot;..Q.&quot;],<br>
[&quot;..Q.&quot;,  // 解法 2<br>
&quot;Q...&quot;,<br>
&quot;...Q&quot;,<br>
&quot;.Q..&quot;]<br>
]<br>
解释: 4 皇后问题存在两个不同的解法。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/n-queens<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>解题思考：<br>
这道题其实在剑指offer里面出现过<br>
需要把题目的本质抽象出来：全排列问题<br>
建立一个数组，将其下标视为棋盘的行，将下标对应的元素视为棋盘的列<br>
判断条件：当两个棋在同一个对角线上时，一定会有 x2 - x1 = y2 - y1;或者x2 - x1 = -（y2 - y1）; (亦即判断两者的斜率是否等于1或者 -1)</p>
<p>然后因为复杂度有点高，我突然在想可不可以用动态规划hhh</p>
<p>实现注意：</p>
<ol>
<li>我一开始老是想着在递归的过程中（也就是非叶子结点）来处理已有的序列，导致了check的位置很尴尬（因为也要考虑当前序列），最后发现还是不如直接在叶子节点进行处理</li>
<li>回溯法一定要记得状态恢复，同时因为使用了状态恢复，可以传引用调用，以免内存消耗过高（从98M降低到8M）</li>
</ol>
<pre><code>class Solution {
public:
    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) {
        if(n &lt;= 0)
        {   return vector&lt;vector&lt;string&gt;&gt;{}; }
        if(n == 1)
        {   return vector&lt;vector&lt;string&gt;&gt;{{&quot;Q&quot;}}; }
        
        vector&lt;int&gt; queensLocate(n);
        for(int i = 0; i &lt; n; ++i)
        {
            queensLocate[i] = i;
        }
        
        int counts = 0;
        vector&lt;vector&lt;string&gt;&gt; res;
        solveNQueens(queensLocate, 0, res);
        
        return res;
    }
    
    // 注意此处使用了DFS+回溯法进行状态还原，所以完全queensLocate可以使用传引用
    void solveNQueens(vector&lt;int&gt;&amp; queensLocate, int level, vector&lt;vector&lt;string&gt;&gt;&amp; res)
    {
        int length = queensLocate.size();
        
        // 一开始我钻了牛角尖，其实完全可以使用DFS，每个数字和自身交换一次，等到叶子结点再进行checkLocate
        if(level &gt;= length)
        {     
            if(checkLocate(queensLocate))
                {
                string strTemp(length, '.'); // 记得是char
                vector&lt;string&gt; resTemp(length, strTemp);
                for(int i = 0; i &lt; length; ++i)
                {
                    resTemp[i][queensLocate[i]] = 'Q'; // 记得是char
                }
                res.push_back(resTemp);
            }
            return;
        }
        
        for(int i = level ; i &lt; length; ++i) // 注意int i = level，先和自身交换一次
        {
            swap(queensLocate[level],queensLocate[i]);
            solveNQueens(queensLocate, level + 1, res); // 思考level的变化
						// 此处其实可以检查 0 - level 的值是否符合要求，进行剪枝。
            swap(queensLocate[level],queensLocate[i]); // 状态还原很重要
        }
        
    }
    
    bool checkLocate(vector&lt;int&gt;&amp; queensLocate)
    {
        for(int i = 0; i &lt; queensLocate.size(); ++i)
        {
            for(int j = i + 1; j &lt; queensLocate.size(); ++j)
            {
                if(i - j == queensLocate[i] - queensLocate[j] || - i + j == queensLocate[i] - queensLocate[j]) // 注意是并的关系 ||
                {
                    return false;
                }
            }
        }
        return true;
    }
};
</code></pre>
<p><a href="https://leetcode-cn.com/problems/n-queens/solution/hui-su-suan-fa-xiang-jie-by-labuladong/">网友题解</a><br>
网友题解有很多图，我就不强行转过来了<br>
注意我们的核心思想一致，都是转化为全排列问题，但是实现细节不一致<br>
我使用的方法是实现确定好位置，然后不断地交换他们的位置，注意我没有进行剪枝的（其实可以判断0- level 的节点是否已经冲突，已经冲突的话就剪枝）<br>
然后网友题解和我以前做全排列的方法比较像，也就是视为一棵树不断地进行选择，并记录哪些元素已经被选择过了，因此可以进行剪枝，并且把剪枝操作和最终判断合为一起（如果达到长度后直接push_back）。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[extern C ]]></title>
        <id>https://lixin-scut.github.io//post/extern-c</id>
        <link href="https://lixin-scut.github.io//post/extern-c">
        </link>
        <updated>2020-04-05T09:18:32.000Z</updated>
        <content type="html"><![CDATA[<h3 id="链接指示externc">链接指示：extern&quot;C&quot;</h3>
<p>  C++使用链接指示（linkage directive)指出任意非C++函数所用的语言。<br>
  要想把C++代码和其他语言（包括C语言）编写的代码放在一起使用，要求我们必须有权访问该语言的编译器，并且这个编译器与当前的C++编译器是兼容的</p>
<h3 id="声明一个非c的函数">声明一个非C++的函数</h3>
<p>  链接指示可以有两种形式：单个的或复合的。链接指示不能出现在类定义或函数定义的内部。同样的链接指示必须在函数的每个声明中都出现。<br>
  链接指示的第一种形式包含一个关键字extern.后面是一个字符串字面值常量以及一个 &quot;普通的&quot;函数声明。<br>
  其中的字符串字面值常量指出了编写函数所用的语言。编译器应该支持对C语言的链 接指示。此外，编译器也可能会支持其他语言的链接指示，如extern&quot;Ada&quot;、extern &quot;FORTRAN&quot;等。</p>
<h3 id="链接指示与头文件">链接指示与头文件</h3>
<p>  我们可以令链接指示后面跟上花括号括起来的若干函数的声明，从而一次性建立多个 链接。花括号的作用是将适用于该链接指示的多个声明聚合在一起，否则花括号就会被忽 略，花括号中声明的函数名字就是可见的，就好像在花括号之外声明的一样。<br>
<img src="https://lixin-scut.github.io//post-images/1586079345046.png" alt=""><br>
  当一个#include指示被放置在复合链接指示的花括号中时，头文件中的所有普通函数声明都被认为是由链接指示的语言编写的。链接指示可以嵌套，因此如果头文件包含带自带链接指示的函数，则该函数的链接不受影响。<br>
  C++从C语言继承的标准库函数可定义成C函数，但并非必须：决定使用还是C++实现C标准库，是毎个C++实现的事情。</p>
<h3 id="指向externc函数的指针">指向extern&quot;C&quot;函数的指针</h3>
<p>  编写函数所用的语言是函数类型的一部分。因此，对于使用链接指示定义的函数来说，它的每个声明都必须使用相同的链接指示。而且，指向其他语言编写的函数的指针必须与函数本身使用相同的链接指示：</p>
<pre><code>//pf指向一个C函数，该函数接受一个int返回void 
extern&quot;C&quot;void(*pf)(int); 
</code></pre>
<p>  当我们使用pf调用函数时，编详器认定当前调用的是一个c函数。<br>
  <strong>指向C函数的指针与指向C++函数的指针是不一样的类型</strong>。一个指向C函数的指针不能用在执行初始化或赋值操作后指向C++函数，反之亦然。就像其他类型不匹配的问题一样，如果我们试图在两个链接指示不同的指针之间进行赋值操作，则程序将发生错误：</p>
<h3 id="链接指示对整个声明都有效">链接指示对整个声明都有效</h3>
<p>  当我们使用链接指示时，它不仅对函数有效，而且<strong>对作为返回类型或形参类型的函数指针也有效</strong>：<br>
<img src="https://lixin-scut.github.io//post-images/1586079363829.png" alt=""><br>
  因为链接指示同时作用于声明语句中的所有函数，所以如果我们希望给C++函数传入 一个指向C函数的指针，则<strong>必须使用类型别名</strong></p>
<h3 id="导出c函数到其他语言">导出C++函数到其他语言</h3>
<p>  通过使用链接指示对函数进行<strong>定义</strong>，我们可以令一个C++函数在其他语言编写的程序 中可用：</p>
<pre><code>//calc函数可以被C程序调用 
extern &quot;C&quot; double calc(double dparm){/*...*/} 
</code></pre>
<p>  编译器将为该函数生成适合于指定语言的代码。<br>
  值得注意的是，可被多种语言共享的函数的返回类型或形参类型受到很多限制。<br>
<img src="https://lixin-scut.github.io//post-images/1586079379457.png" alt=""></p>
<h3 id="重载函数与链接指示">重载函数与链接指示</h3>
<p>  链接指示与重载函数的相互作用依赖于目标语言。如果目标语言支持重载函数，则为 该语言实现链接指示的编译很可能也支持重载这些C++的函数。<br>
  C语言不支持函数重载，因此也就不难理解为什么一个C链接指示只能用于说明一组重载函数中的某一个了：<br>
<img src="https://lixin-scut.github.io//post-images/1586079386823.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 64. 最小路径和[中等]]]></title>
        <id>https://lixin-scut.github.io//post/dong-tai-gui-hua-64-zui-xiao-lu-jing-he-zhong-deng</id>
        <link href="https://lixin-scut.github.io//post/dong-tai-gui-hua-64-zui-xiao-lu-jing-he-zhong-deng">
        </link>
        <updated>2020-04-05T05:44:10.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。<br>
说明：每次只能向下或者向右移动一步。<br>
示例:<br>
输入:<br>
[<br>
  [1,3,1],<br>
[1,5,1],<br>
[4,2,1]<br>
]<br>
输出: 7<br>
解释: 因为路径 1→3→1→1→1 的总和最小。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/minimum-path-sum<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>一开始我觉得可以用动态规划，因为限制了只能向下或者向右<br>
亦即 每个点只有两种情况，考虑左边和上边转移到当前节点<br>
然后就是状态转移方程<br>
<code>steps[col][row] = grid[i][j] + min(steps[col - 1][row], steps[col][row + 1])</code></p>
<p>注意判断边界条件</p>
<p>实现过程：</p>
<ol>
<li>用grid直接初始化steps，两者维度一致，可以省略逐个初始化</li>
<li>我使用INT_MAX来赋值边界值，但是始终没法逃避col == 0 &amp;&amp; row == 0的单独判断。</li>
<li>注意好条件运算符中的判断条件的对应关系。</li>
</ol>
<p>题目扩展：不限制向下或向右，怎么设计（我一个考虑是用图的最短路径来做，但是转化为图连通矩阵相对比较麻烦）</p>
<pre><code>class Solution {
public:
    int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        if(grid.empty())
        {   return 0; }
        vector&lt;vector&lt;int&gt;&gt; steps(grid.begin(), grid.end());
        for(int col = 0; col &lt; steps.size(); ++col)
        {
            for(int row = 0; row &lt; steps[0].size(); ++row)
            {
                if(col == 0 &amp;&amp; row == 0)
                {
                    continue;
                }
                
                int up = col &gt; 0 ? steps[col - 1][row] : INT_MAX;
                int left = row &gt; 0 ? steps[col][row - 1] : INT_MAX;
                
                steps[col][row] = grid[col][row] + min(up, left);
            }
        }
        return steps.back().back();
    }
};

/*
一开始我觉得可以用动态规划，因为限制了只能向下或者向右
亦即 每个点只有两种情况，考虑左边和上边转移到当前节点
然后就是状态转移方程
steps[col][row] = grid[i][j] + min(steps[col - 1][row], steps[col][row + 1]) 

注意判断边界条件

扩展：不限制向下或向右，怎么设计
*/
</code></pre>
<p>官方题解</p>
<blockquote></blockquote>
<p>方法 1： 暴力<br>
暴力就是利用递归，对于每个元素我们考虑两条路径，向右走和向下走，在这两条路径中挑选路径权值和较小的一个。<br>
<code>cost(i,j)=grid[i][j]+min(cost(i+1,j),cost(i,j+1))</code></p>
<pre><code>Java
public class Solution {
    public int calculate(int[][] grid, int i, int j) {
        if (i == grid.length || j == grid[0].length) return Integer.MAX_VALUE;
        if (i == grid.length - 1 &amp;&amp; j == grid[0].length - 1) return grid[i][j];
        return grid[i][j] + Math.min(calculate(grid, i + 1, j), calculate(grid, i, j + 1));
    }
    public int minPathSum(int[][] grid) {
        return calculate(grid, 0, 0);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 ：O(2^(m+n) )。每次移动最多可以有两种选择。<br>
空间复杂度 ：O(m+n)。递归的深度是 m+n。</p>
</blockquote>
<blockquote>
<p>方法 2：二维动态规划<br>
算法<br>
我们新建一个额外的 dp 数组，与原矩阵大小相同。在这个矩阵中，dp(i,j) 表示从坐标 (i,j) 到右下角的最小路径权值。我们初始化右下角的 dp 值为对应的原矩阵值，然后去填整个矩阵，对于每个元素考虑移动到右边或者下面，因此获得最小路径和我们有如下递推公式：<code>dp(i,j)=grid(i,j)+min(dp(i+1,j),dp(i,j+1))</code><br>
注意边界情况。下图描述了这个过程：</p>
</blockquote>
<pre><code>Java
public class Solution {
    public int minPathSum(int[][] grid) {
        int[][] dp = new int[grid.length][grid[0].length];
        for (int i = grid.length - 1; i &gt;= 0; i--) {
            for (int j = grid[0].length - 1; j &gt;= 0; j--) {
                if(i == grid.length - 1 &amp;&amp; j != grid[0].length - 1)
                    dp[i][j] = grid[i][j] +  dp[i][j + 1];
                else if(j == grid[0].length - 1 &amp;&amp; i != grid.length - 1)
                    dp[i][j] = grid[i][j] + dp[i + 1][j];
                else if(j != grid[0].length - 1 &amp;&amp; i != grid.length - 1)
                    dp[i][j] = grid[i][j] + Math.min(dp[i + 1][j], dp[i][j + 1]);
                else
                    dp[i][j] = grid[i][j];
            }
        }
        return dp[0][0];
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 ：O(mn)。遍历整个矩阵恰好一次。<br>
空间复杂度 ：O(mn)。额外的一个同大小矩阵。</p>
</blockquote>
<blockquote>
<p>方法 3：一维动态规划<br>
算法<br>
在上个解法中，我们可以用一个一维数组来代替二维数组，dp 数组的大小和行大小相同。这是因为对于某个固定状态，只需要考虑下方和右侧的节点。首先初始化 dp 数组最后一个元素是右下角的元素值，然后我们向左移更新每个 dp(j) 为：dp(j)=grid(i,j)+min(dp(j),dp(j+1))<br>
我们对于每一行都重复这个过程，然后向上一行移动，计算完成后 dp(0) 就是最后的结果。</p>
</blockquote>
<p>Java<br>
public class Solution {<br>
public int minPathSum(int[][] grid) {<br>
int[] dp = new int[grid[0].length];<br>
for (int i = grid.length - 1; i &gt;= 0; i--) {<br>
for (int j = grid[0].length - 1; j &gt;= 0; j--) {<br>
if(i == grid.length - 1 &amp;&amp; j != grid[0].length - 1)<br>
dp[j] = grid[i][j] +  dp[j + 1];<br>
else if(j == grid[0].length - 1 &amp;&amp; i != grid.length - 1)<br>
dp[j] = grid[i][j] + dp[j];<br>
else if(j != grid[0].length - 1 &amp;&amp; i != grid.length - 1)<br>
dp[j] = grid[i][j] + Math.min(dp[j], dp[j + 1]);<br>
else<br>
dp[j] = grid[i][j];<br>
}<br>
}<br>
return dp[0];<br>
}<br>
}</p>
<blockquote>
<p>复杂度分析<br>
时间复杂度 ：O(mn)。遍历整个矩阵恰好一次。<br>
空间复杂度 ：O(n)。额外的一维数组，和一行大小相同。</p>
</blockquote>
<blockquote>
<p>方法 4：动态规划（不需要额外存储空间）<br>
算法<br>
和方法 2 相同，惟一的区别是，不需要用额外的 dp 数组，而是在原数组上存储，这样就不需要额外的存储空间。递推公式如下：<br>
grid(i,j)=grid(i,j)+min(grid(i+1,j),grid(i,j+1))</p>
</blockquote>
<pre><code>Java
public class Solution {
    public int minPathSum(int[][] grid) {
        for (int i = grid.length - 1; i &gt;= 0; i--) {
            for (int j = grid[0].length - 1; j &gt;= 0; j--) {
                if(i == grid.length - 1 &amp;&amp; j != grid[0].length - 1)
                    grid[i][j] = grid[i][j] +  grid[i][j + 1];
                else if(j == grid[0].length - 1 &amp;&amp; i != grid.length - 1)
                    grid[i][j] = grid[i][j] + grid[i + 1][j];
                else if(j != grid[0].length - 1 &amp;&amp; i != grid.length - 1)
                    grid[i][j] = grid[i][j] + Math.min(grid[i + 1][j],grid[i][j + 1]);
            }
        }
        return grid[0][0];
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 ：O(mn)。遍历整个矩阵恰好一次。<br>
空间复杂度 ：O(1)。不需要额外空间。</p>
</blockquote>
<p>官方的空间压缩很值得学习。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[随机概率p转化为等概率]]></title>
        <id>https://lixin-scut.github.io//post/sui-ji-gai-lu-p-zhuan-hua-wei-deng-gai-lu</id>
        <link href="https://lixin-scut.github.io//post/sui-ji-gai-lu-p-zhuan-hua-wei-deng-gai-lu">
        </link>
        <updated>2020-04-05T02:22:55.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>有一个随机数发生器random函数，可以以概率P产生0，概率(1-P)产生1，请问能否利用这个随机数发生器，构造出新的发生器，以1/2的概率产生0和1。</p>
</blockquote>
<p>题解一：<br>
等概率产生0、1，就需要找到两个独立事件，当这两个独立事件发生的概率相同，就得到所求<br>
两次调用该randon函数，如果其概率为P(x)，调用2次<br>
P(1) = p       P(0) = 1-p<br>
P'(1) =p      P'(0) = 1-p<br>
则不同结果的概率如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">情况</th>
<th style="text-align:center">概率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">p*p</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">p*(1-p)</td>
</tr>
<tr>
<td style="text-align:center">01</td>
<td style="text-align:center">(1-p)*p</td>
</tr>
<tr>
<td style="text-align:center">00</td>
<td style="text-align:center">(1-p)*(1-p)</td>
</tr>
</tbody>
</table>
<p>用随机数生成器产生<code>00，01，10，11</code>，各自的概率分别为<code>p*p，p*(1-p)，(1-p)*p，(1-p)*(1-p)</code>可以发现生成01，10的概率相同，因此只保留这两种情况，其他的舍弃，然后将01映射为0，10映射为1，则得到等概率生成器。</p>
<pre><code>int random_equal()  
{  
    int i = random();  
    int j = random();  
    int result;  
  
    while (true)  
    {  
        if (i == 0 &amp;&amp; j == 1)  
        {  
            result = 0;  
            break;  
        }  
        else if (i == 1 &amp;&amp; j == 0)  
        {  
            result = 1;  
            break;  
        }  
        else  
            continue;  
    }  
  
    return result;  
}  
</code></pre>
<p>题解二：<br>
思路是叠加多个原始构造器，通过每次叠加的和与期望值对比，来决定是0和1，具体如下：<br>
迭代N次，则期望<code>E=( (1-p)*1 + p*0) * N</code> 。比较累加N次的和Sum和E，Sum大则返回0，Sum小则返回1。</p>
<p>拓展1：用等概率生成（0,1）的构造器等概率生成（0,1,2,3）。<br>
假设，原始构造器为Rand2()，则Rand2() * 2为（0,2），Rand2()* 2 + Rand2()则可以生成（0,1,2,3）。注意Rand2()* 2 + Rand2()不等于Rand2()* 3，后者等于（0,3），只用了一次构造器。前者由part1:（0,2）和part2:（0,1）构成。最终结果（0,1,2,3）任何一个数字都由part1和part2中唯一的数字相加得到。<br>
用Rand4（等概率生成0,1,2,3）可以进一步生成Rand16。方法为：Rand4()* 4 + Rand4()</p>
<p>拓展2：用等概率生成（0,1）的构造器等概率生成（0,1,2,3，...，N）。<br>
思路同上相似。由（0,1）的构造器可以生成（0，...，2^n ） 的构造器，其中每次构造生成的随机数个数是<code>上一次的平方</code>。只需要构造到保证2^n&gt;N即可。当得到的随机数处于[ N, 2^n ）时，递归生成一次，直到构造数为[0,N)时，退出本次随机数生成。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 子序列最小差]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-zi-xu-lie-zui-xiao-chai</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-zi-xu-lie-zui-xiao-chai">
        </link>
        <updated>2020-04-05T02:14:59.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>将一个数组分成两部分，不要求两部分所包含的元素个数相等，要求使得这两个部分的和的差值最小。比如对于数组{1,0,1,7,2,4}，可以分成{1,0,1,2,4}和{7}，使得这两部分的差值最小。</p>
</blockquote>
<p>思路：<br>
这个问题可以转化为求数组的一个子集，使得这个子集中的元素的和尽可能接近sum/2，其中sum为数组中所有元素的和。这样转换之后这个问题就很类似0-1背包问题了：在n件物品中找到m件物品，他们的可以装入背包中，且总价值最大不过这里不考虑价值，就考虑使得这些元素的和尽量接近sum/2。</p>
<p>下面列状态方程：<br>
<code>dp[i][j]</code>表示前i件物品中，总和最接近j的所有物品的总和，其中包括两种情况：</p>
<ol>
<li>第i件物品没有包括在其中</li>
<li>第i件物品包括在其中<br>
如果第i件物品没有包括在其中，则<code>dp[i][j] = dp[i-1][j]</code><br>
如果第i件物品包括在其中，则<code>dp[i][j] = dp[i-1][j-vec[i]]</code><br>
当然，这里要确保<code>j-vec[i] &gt;= 0</code>。</li>
</ol>
<p>所以状态转移方程为：<br>
<code>dp[i][j] = max(dp[i-1][j],dp[i-1][j-vec[i]]+vec[i]);</code></p>
<pre><code>using namespace std;
//返回两部分的差值
int diff(vector&lt;int&gt;&amp; vec)
{
    int len = vec.size();
 
    int sum = 0;
    for (int i = 0; i &lt; len; ++i) {
        sum += vec[i];
    }
 
    vector&lt;vector&lt;int&gt;&gt; dp;
    for (int i = 0; i &lt;= len; i++) {
        vector&lt;int&gt;tmp;
        for (int j = 0; j &lt;= sum / 2; ++j) {
            tmp.push_back(0);
        }
        dp.push_back(tmp);
    }
    for (int i = 1; i &lt;= len; ++i) {
        for (int j = 1; j &lt;= sum / 2; ++j) {
            if(j&gt;=vec[i-1])dp[i][j] = max(dp[i-1][j],dp[i-1][j-vec[i-1]]+vec[i-1]);
            else dp[i][j] = dp[i - 1][j];
        }
    }
 
    return sum - 2*dp[len][sum / 2];
}
 
int main()
{
    vector&lt;int&gt; vec = { 1,2,3,4,5};
 
    cout &lt;&lt; diff(vec) &lt;&lt; endl;
    system(&quot;pause&quot;);
    return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>