<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2020-02-15T16:24:41.680Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[红黑树--map 底层实现]]></title>
        <id>https://lixin-scut.github.io//post/hong-hei-shu-map-di-ceng-shi-xian</id>
        <link href="https://lixin-scut.github.io//post/hong-hei-shu-map-di-ceng-shi-xian">
        </link>
        <updated>2020-02-15T08:30:36.000Z</updated>
        <content type="html"><![CDATA[<h3 id="二叉搜索树binary-search-tree">二叉搜索树(binary search tree)</h3>
<p>二叉搜索树,可提供对数时间的元素插入和访问.二叉搜索树的节点放置规则是：任何节点的键值一定大于其左子树中的每一个节点的键值，并小于其右子树中的每一个节点的键值。因此，从根节点一直往左走，直至无左路可走，即得最小元素；从根节点一直往右走，直至无 右路可走，即得最大元素。<br>
插入新元素时，可从根节点开始，遇键值较大 者就向左，遇键值较小者就向右，一直到尾端，即为插入点。<br>
欲删除旧节点A,情况可分两种。<br>
如果A只有一个子节点，我们就直接将A的子节点连至A的父节点，并将A删除。如果A有两个子节点，我们就以右子树内的最小节点取代A。注意，右子树的最小节点极易获得：从右子节点开始(视为右子树的根节点)，一直向左走至底即是。</p>
<h3 id="平衡二叉搜索树balanced-binary-search-tree">平衡二叉搜索树(balanced binary search tree )</h3>
<p>因为输入值不够随机，也许因为经过某些插入或删除操作，二叉搜索树可能会失去平衡，造成搜寻效率低落的情况</p>
<p>所谓树形平衡与否，并没有一个绝对的测量标准。大概定义为没有任何一个节点过深（深度过大）</p>
<h3 id="avl-tree-adelson-velskii-landis-tree">AVL tree （ Adelson-Velskii-Landis tree ）</h3>
<p>AVLtree是一个“加上了额外平衡条件”的二叉搜索树。其平衡条件的建立是为了确保整棵树的深度为O(logN)。<br>
直观上的最佳平衡条件是每个节点的左右子树有着相同的高度，但AVLtree退而求其次，只要求任何节点的左右子树高度相差最多1<br>
只要修改最深的失去平衡的节点就能使整棵树重新获得平衡<br>
只要调整“插入点至根节点”路径上，平衡状态被破坏之各节点 中最深的那一个，便可使整棵树重新获得平衡。假设该最深节点为X,由于节点最 多拥有两个子节点，而所谓“平衡被破坏”意味着X的左右两棵子树的高度相差 2,因此我们可以轻易将情况分为四种：</p>
<ol>
<li>插入点位于X的左子节点的左子树——左左。</li>
<li>插入点位于X的左子节点的右子树——左右。</li>
<li>插入点位于X的右子节点的左子树——右左。</li>
<li>插入点位于X的右子节点的右子树——右右。<br>
情况1,4彼此对称，称为外侧(outside)插入，可以采用单旋转操作(single rotation)调整解决。<br>
情况2, 3彼此对称，称为内侧(inside)插入，可以采用双旋 转操作(double rotation)调整解决。</li>
</ol>
<h3 id="rb-tree-红黑树">RB-tree (红黑树)</h3>
<p>RB-tree,不仅是一个二叉搜索树，而且必须满足以下规则:</p>
<ol>
<li>每个节点不是红色就是黑色(图中深色底纹代表黑色，浅色底纹代表红色,</li>
<li>根节点为黑色。</li>
<li>如果节点为红，其子节点必须为黑。</li>
<li>任一节点至NULL (树尾端)的任何路径，所含之黑节点数必须相同。<br>
（注意上述四点中并无一点要求深度，仅仅对颜色作出了要求，使用二叉搜索树的插入方法，然后主要通过第四点进行控制）<br>
根据规则4,新增节点必须为红(注意，这里不是指所有业节点都是红的，叶节点也可以是黑的)；<br>
根据规则3,新增节点之父节点必须为黑。<br>
当新节点根据二叉搜索树的规则到达其插入点，却未能符合上述条件时，就必须调 整颜色并旋转树形。</li>
</ol>
<p>假设新节点为X,其父节点为P,祖父节点为G,伯父节点（父节点之兄弟节点）为S,曾祖父节点为GG。现在，根据二叉搜索树的规则，新节点X必为叶节点。根据红黑树规则4, X必为红。若P亦为红（这就违反了规则3,必须调整树形）,则G必为黑（因为原为RB-tree,必须遵循规则3）。于是、根据X的插入位置及外围节点（S和GG）的颜色，有以下四种情况<br>
<img src="https://lixin-scut.github.io//post-images/1581758953264.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1581758969684.png" alt=""><br>
注意，红黑树可能会产生不平衡的状态（高度相差1以上），但是无所谓，红黑树的平衡性就是比ACL树弱，但红黑树的搜索平均效率和AVL树几乎相等<br>
<img src="https://lixin-scut.github.io//post-images/1581768019234.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1581768036420.png" alt=""></p>
<p>RB-tree有红黑二色，并且拥有左右子节点，其结构为了有更大的弹性，节点分为两层，下图显示节点双层结构和迭代器双层结构的关系。<br>
<img src="https://lixin-scut.github.io//post-images/1581768119608.png" alt=""><br>
RB-tree迭代器属于双向迭代器，但不具备随机定位能力，其提领操作和成员<br>
访问操作与list十分近似，较为特殊的是其前进和后退操作。</p>
<p><img src="https://lixin-scut.github.io//post-images/1581768212987.png" alt=""><br>
每当插入新节点时，不但要依照RB-tree的规则来调整，并且维护 header 的正确性，使其父节点指向根节点，左子节点指向最小节点，右子节点指向最大节点。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[事务管理四要素 ACID]]></title>
        <id>https://lixin-scut.github.io//post/shi-wu-guan-li-si-yao-su-acid</id>
        <link href="https://lixin-scut.github.io//post/shi-wu-guan-li-si-yao-su-acid">
        </link>
        <updated>2020-02-15T08:15:54.000Z</updated>
        <content type="html"><![CDATA[<p>原子性（Atomicity）<br>
原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。<br>
一致性（Consistency）<br>
事务前后数据的完整性必须保持一致。<br>
隔离性（Isolation）<br>
事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。<br>
持久性（Durability）<br>
持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[B 树和 B+树的区别]]></title>
        <id>https://lixin-scut.github.io//post/b-shu-he-bshu-de-qu-bie</id>
        <link href="https://lixin-scut.github.io//post/b-shu-he-bshu-de-qu-bie">
        </link>
        <updated>2020-02-15T07:49:47.000Z</updated>
        <content type="html"><![CDATA[<p>一，b树<br>
b树（balance tree）和b+树应用在数据库索引，可以认为是m叉的多路平衡查找树，但是从理论上讲，二叉树查找速度和比较次数都是最小的，为什么不用二叉树呢？<br>
因为我们要考虑磁盘IO的影响，它相对于内存来说是很慢的。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。所以我们要减少IO次数，对于树来说，IO次数就是树的高度，而“矮胖”就是b树的特征之一，它的每个节点最多包含m个孩子，m称为b树的阶，m的大小取决于磁盘页的大小。</p>
<p>█一个M阶的b树具有如下几个特征：<br>
定义任意非叶子结点最多只有M个儿子，且M&gt;2；<br>
根结点的儿子数为[2, M]；<br>
除根结点以外的非叶子结点的儿子数为[M/2, M]，向上取整；<br>
非叶子结点的关键字个数=儿子数-1；<br>
所有叶子结点位于同一层；<br>
k个关键字把节点拆成k+1段，分别指向k+1个儿子，同时满足查找树的大小关系。</p>
<p>█有关b树的一些特性，注意与后面的b+树区分：<br>
关键字集合分布在整颗树中；<br>
任何一个关键字出现且只出现在一个结点中；<br>
搜索有可能在非叶子结点结束；<br>
其搜索性能等价于在关键字全集内做一次二分查找；</p>
<p>b树在查询时的比较次数并不比二叉树少，尤其是节点中的数非常多时，但是内存的比较速度非常快，耗时可以忽略，所以只要树的高度低，IO少，就可以提高查询性能，这是b树的优势之一。</p>
<p>二，b+树<br>
b+树，是b树的一种变体，查询性能更好。m阶的b+树的特征：<br>
有n棵子树的非叶子结点中含有n个关键字（b树是n-1个），这些关键字不保存数据，只用来索引，所有数据都保存在叶子节点（b树是每个关键字都保存数据）。<br>
所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。<br>
所有的非叶子结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。<br>
通常在b+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。<br>
同一个数字会在不同节点中重复出现，根节点的最大元素就是b+树的最大元素。</p>
<p>█b+树相比于b树的查询优势：<br>
b+树的中间节点不保存数据，所以磁盘页能容纳更多节点元素，更“矮胖”；（B树的每个结点都存储了key和data，B+树的data存储在叶子节点上。）<br>
b+树查询必须查找到叶子节点，b树只要匹配到即可不用管元素位置，因此b+树查找更稳定（并不慢）；<br>
对于范围查找来说，b+树只需遍历叶子节点链表即可，b树却需要重复地中序遍历</p>
<p><a href="https://www.cnblogs.com/20189223cjt/p/11262450.html">B-树与B+树的区别</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[lambda]]></title>
        <id>https://lixin-scut.github.io//post/lambda</id>
        <link href="https://lixin-scut.github.io//post/lambda">
        </link>
        <updated>2020-02-15T07:40:21.000Z</updated>
        <content type="html"><![CDATA[<ol start="7">
<li>Lambda 表达式</li>
</ol>
<p>Lambda 表达式，实际上就是提供了一个类似匿名函数的特性，而匿名函数则是在需要一个函数，但是又不想费力去命名一个函数的情况下去使用的。</p>
<p>Lambda 表达式的基本语法如下：</p>
<p>[ caputrue ] ( params ) opt -&gt; ret { body; };<br>
1</p>
<ol>
<li>capture是捕获列表；</li>
<li>params是参数表；(选填)</li>
<li>opt是函数选项；可以填mutable,exception,attribute（选填）<br>
mutable说明lambda表达式体内的代码可以修改被捕获的变量，并且可以访问被捕获的对象的non-const方法。<br>
exception说明lambda表达式是否抛出异常以及何种异常。<br>
attribute用来声明属性。</li>
<li>ret是返回值类型（拖尾返回类型）。(选填)</li>
<li>body是函数体。</li>
</ol>
<p>捕获列表：lambda表达式的捕获列表精细控制了lambda表达式能够访问的外部变量，以及如何访问这些变量。</p>
<ol>
<li>[]不捕获任何变量。</li>
<li>[&amp;]捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）。</li>
<li>[=]捕获外部作用域中所有变量，并作为副本在函数体中使用(按值捕获)。注意值捕获的前提是变量可以拷贝，且被捕获的变量在 lambda 表达式被创建时拷贝，而非调用时才拷贝。如果希望lambda表达式在调用时能即时访问外部变量，我们应当使用引用方式捕获。</li>
</ol>
<p>int a = 0;<br>
auto f = [=] { return a; };</p>
<p>a+=1;</p>
<p>cout &lt;&lt; f() &lt;&lt; endl;       //输出0</p>
<p>int a = 0;<br>
auto f = [&amp;a] { return a; };</p>
<p>a+=1;</p>
<p>cout &lt;&lt; f() &lt;&lt;endl;       //输出1<br>
1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
10<br>
11<br>
12<br>
13<br>
4) [=,&amp;foo]按值捕获外部作用域中所有变量，并按引用捕获foo变量。<br>
5) [bar]按值捕获bar变量，同时不捕获其他变量。<br>
6) [this]捕获当前类中的this指针，让lambda表达式拥有和当前类成员函数同样的访问权限。如果已经使用了&amp;或者=，就默认添加此选项。捕获this的目的是可以在lamda中使用当前类的成员函数和成员变量。</p>
<p>class A<br>
{<br>
public:<br>
int i_ = 0;</p>
<pre><code> void func(int x,int y){
     auto x1 = [] { return i_; };                   //error,没有捕获外部变量
     auto x2 = [=] { return i_ + x + y; };          //OK
     auto x3 = [&amp;] { return i_ + x + y; };        //OK
     auto x4 = [this] { return i_; };               //OK
     auto x5 = [this] { return i_ + x + y; };       //error,没有捕获x,y
     auto x6 = [this, x, y] { return i_ + x + y; };     //OK
     auto x7 = [this] { return i_++; };             //OK
</code></pre>
<p>};</p>
<p>int a=0 , b=1;<br>
auto f1 = [] { return a; };                         //error,没有捕获外部变量<br>
auto f2 = [&amp;] { return a++ };                      //OK<br>
auto f3 = [=] { return a; };                        //OK<br>
auto f4 = [=] {return a++; };                       //error,a是以复制方式捕获的，无法修改<br>
auto f5 = [a] { return a+b; };                      //error,没有捕获变量b<br>
auto f6 = [a, &amp;b] { return a + (b++); };                //OK<br>
auto f7 = [=, &amp;b] { return a + (b++); };                //OK<br>
1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
10<br>
11<br>
12<br>
13<br>
14<br>
15<br>
16<br>
17<br>
18<br>
19<br>
20<br>
21<br>
22<br>
23<br>
注意f4，虽然按值捕获的变量值均复制一份存储在lambda表达式变量中，修改他们也并不会真正影响到外部，但我们却仍然无法修改它们。如果希望去修改按值捕获的外部变量，需要显示指明lambda表达式为mutable。被mutable修饰的lambda表达式就算没有参数也要写明参数列表。</p>
<p>原因：lambda表达式可以说是就地定义仿函数闭包的“语法糖”。它的捕获列表捕获住的任何外部变量，最终会变为闭包类型的成员变量。按照C++标准，lambda表达式的operator()默认是const的，一个const成员函数是无法修改成员变量的值的。而mutable的作用，就在于取消operator()的const。</p>
<p>int a = 0;<br>
auto f1 = [=] { return a++; };                //error<br>
auto f2 = [=] () mutable { return a++; };       //OK<br>
1<br>
2<br>
3<br>
lambda表达式的大致原理：每当你定义一个lambda表达式后，编译器会自动生成一个匿名类（这个类重载了()运算符），我们称为闭包类型（closure type）。那么在运行时，这个lambda表达式就会返回一个匿名的闭包实例，是一个右值。所以，我们上面的lambda表达式的结果就是一个个闭包。对于复制传值捕捉方式，类中会相应添加对应类型的非静态数据成员。在运行时，会用复制的值初始化这些成员变量，从而生成闭包。对于引用捕获方式，无论是否标记mutable，都可以在lambda表达式中修改捕获的值。至于闭包类中是否有对应成员，C++标准中给出的答案是：不清楚的，与具体实现有关。</p>
<p>lambda表达式是不能被赋值的：</p>
<p>auto a = [] { cout &lt;&lt; &quot;A&quot; &lt;&lt; endl; };<br>
auto b = [] { cout &lt;&lt; &quot;B&quot; &lt;&lt; endl; };</p>
<p>a = b;   // 非法，lambda无法赋值<br>
auto c = a;   // 合法，生成一个副本<br>
1<br>
2<br>
3<br>
4<br>
5<br>
闭包类型禁用了赋值操作符，但是没有禁用复制构造函数，所以你仍然可以用一个lambda表达式去初始化另外一个lambda表达式而产生副本。</p>
<p>在多种捕获方式中，最好不要使用[=]和[&amp;]默认捕获所有变量。</p>
<p>默认引用捕获所有变量，你有很大可能会出现悬挂引用（Dangling references），因为引用捕获不会延长引用的变量的生命周期：</p>
<p>std::function&lt;int(int)&gt; add_x(int x)<br>
{<br>
return [&amp;](int a) { return x + a; };<br>
}<br>
1<br>
2<br>
3<br>
4<br>
上面函数返回了一个lambda表达式，参数x仅是一个临时变量，函数add_x调用后就被销毁了，但是返回的lambda表达式却引用了该变量，当调用这个表达式时，引用的是一个垃圾值，会产生没有意义的结果。上面这种情况，使用默认传值方式可以避免悬挂引用问题。</p>
<p>但是采用默认值捕获所有变量仍然有风险，看下面的例子：</p>
<p>class Filter<br>
{<br>
public:<br>
Filter(int divisorVal):<br>
divisor{divisorVal}<br>
{}</p>
<pre><code>std::function&lt;bool(int)&gt; getFilter() 
{
    return [=](int value) {return value % divisor == 0; };
}
</code></pre>
<p>private:<br>
int divisor;<br>
};<br>
1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
10<br>
11<br>
12<br>
13<br>
14<br>
15<br>
这个类中有一个成员方法，可以返回一个lambda表达式，这个表达式使用了类的数据成员divisor。而且采用默认值方式捕捉所有变量。你可能认为这个lambda表达式也捕捉了divisor的一份副本，但是实际上并没有。因为数据成员divisor对lambda表达式并不可见，你可以用下面的代码验证：</p>
<p>// 类的方法，下面无法编译，因为divisor并不在lambda捕捉的范围<br>
std::function&lt;bool(int)&gt; getFilter()<br>
{<br>
return [divisor](int value) {return value % divisor == 0; };<br>
}<br>
1<br>
2<br>
3<br>
4<br>
5<br>
原代码中，lambda表达式实际上捕捉的是this指针的副本，所以原来的代码等价于：</p>
<p>std::function&lt;bool(int)&gt; getFilter()<br>
{<br>
return [this](int value) {return value % this-&gt;divisor == 0; };<br>
}<br>
1<br>
2<br>
3<br>
4<br>
尽管还是以值方式捕获，但是捕获的是指针，其实相当于以引用的方式捕获了当前类对象，所以lambda表达式的闭包与一个类对象绑定在一起了，这很危险，因为你仍然有可能在类对象析构后使用这个lambda表达式，那么类似“悬挂引用”的问题也会产生。所以，采用默认值捕捉所有变量仍然是不安全的，主要是由于指针变量的复制，实际上还是按引用传值。</p>
<p>lambda表达式可以赋值给对应类型的函数指针。但是使用函数指针并不是那么方便。所以STL定义在&lt; functional &gt;头文件提供了一个多态的函数对象封装std::function，其类似于函数指针。它可以绑定任何类函数对象，只要参数与返回类型相同。如下面的返回一个bool且接收两个int的函数包装器：</p>
<p>std::function&lt;bool(int, int)&gt; wrapper = [](int x, int y) { return x &lt; y; };<br>
1<br>
lambda表达式一个更重要的应用是其可以用于函数的参数，通过这种方式可以实现回调函数。</p>
<p>最常用的是在STL算法中，比如你要统计一个数组中满足特定条件的元素数量，通过lambda表达式给出条件，传递给count_if函数：</p>
<p>int value = 3;<br>
vector<int> v {1, 3, 5, 2, 6, 10};<br>
int count = std::count_if(v.beigin(), v.end(), [value](int x) { return x &gt; value; });<br>
1<br>
2<br>
3<br>
再比如你想生成斐波那契数列，然后保存在数组中，此时你可以使用generate函数，并辅助lambda表达式：</p>
<p>vector<int> v(10);<br>
int a = 0;<br>
int b = 1;<br>
std::generate(v.begin(), v.end(), [&amp;a, &amp;b] { int value = b; b = b + a; a = value; return value; });<br>
// 此时v {1, 1, 2, 3, 5, 8, 13, 21, 34, 55}<br>
1<br>
2<br>
3<br>
4<br>
5<br>
当需要遍历容器并对每个元素进行操作时：</p>
<p>std::vector<int> v = { 1, 2, 3, 4, 5, 6 };<br>
int even_count = 0;<br>
for_each(v.begin(), v.end(), [&amp;even_count](int val){<br>
if(!(val &amp; 1)){<br>
++ even_count;<br>
}<br>
});<br>
std::cout &lt;&lt; &quot;The number of even is &quot; &lt;&lt; even_count &lt;&lt; std::endl;<br>
1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
大部分STL算法，可以非常灵活地搭配lambda表达式来实现想要的效果。</p>
<p>————————————————<br>
版权声明：本文为CSDN博主「jiange_zh」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/jiange_zh/article/details/79356417</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11新特性]]></title>
        <id>https://lixin-scut.github.io//post/c11-xin-te-xing</id>
        <link href="https://lixin-scut.github.io//post/c11-xin-te-xing">
        </link>
        <updated>2020-02-15T07:26:37.000Z</updated>
        <content type="html"><![CDATA[<p>C++11的新特性</p>
<p>常用：<br>
列表初始化（vector对象的列表初始化）<br>
嵌套vector（之前因为&gt;&gt;会被视为右移运算符所以不允许）<br>
auto类型类型指示符、decltype类型指示符<br>
范围for语句<br>
使用=default生成默认构造函数<br>
虚函数的override指示符<br>
标准库begin和end函数<br>
Lambda表达式<br>
定义尾置返回类型<br>
无序容器<br>
智能指针<br>
右值引用<br>
虚函数的override指示符</p>
<p>汇总<br>
2.1.1  long long类型	57<br>
2.2.1  列表初始化	65<br>
2.3.2  nullptr常量	74<br>
2.4.4  constexpr变量	85<br>
2.5.1  类型别名声明	86<br>
2.5.2  auto类型指示符	87<br>
2.5.3  decltype类型指示符	88<br>
2.6.1  类内初始化	91<br>
3.2.2  使用auto或decltype缩写类型	105<br>
3.2.3  范围for语句	108<br>
3.3  定义vector对象的vector（向量的向量）	113<br>
3.3.1  vector对象的列表初始化	114<br>
3.4.1  容器的cbegin和cend函数	124<br>
3.5.3  标准库begin和end函数	132<br>
3.6  使用auto和decltype简化声明	141<br>
4.2  除法的舍入规则	151<br>
4.4  用大括号包围的值列表赋值	155<br>
4.9  将sizeof用于类成员	165<br>
5.4.3  范围for语句	194<br>
6.2.6  标准库initializer_list类	223<br>
6.3.2  列表初始化返回值	229<br>
6.3.3  定义尾置返回类型	232<br>
6.3.3  使用decltype简化返回类型定义	232<br>
6.5.2  constexpr函数	240<br>
7.1.4  使用=default生成默认构造函数	263<br>
7.3.1  类对象成员的类内初始化	272<br>
7.5.2  委托构造函数	287<br>
7.5.6  constexpr构造函数	294<br>
8.2.1  用string对象处理文件名	310<br>
9.1  array和forward_list容器	319<br>
9.2.3  容器的cbegin和cend函数	324<br>
9.2.4  容器的列表初始化	326<br>
9.2.5  容器的非成员函数swap	329<br>
9.3.1  容器insert成员的返回类型	334<br>
9.3.1  容器的emplace成员的返回类型	334<br>
9.4  shrink_to_fit	344<br>
9.5.5  string的数值转换函数	353<br>
10.3.2  Lambda表达式	372<br>
10.3.3  Lambda表达式中的尾置返回类型	379<br>
10.3.4  标准库bind函数	380<br>
11.2.1  关联容器的列表初始化	403<br>
11.2.3  列表初始化pair的返回类型	406<br>
11.3.2  pair的列表初始化	410<br>
11.4  无序容器	420<br>
12.1  智能指针	426<br>
12.1.1  shared_ptr类<br>
12.1.2  动态分配对象的列表初始化	433<br>
12.1.2  auto和动态分配	434<br>
12.1.5  unique_ptr类	443<br>
12.1.6  weak_ptr类	446<br>
12.2.1  范围for语句不能应用于动态分配数组	450<br>
12.2.1  动态分配数组的列表初始化	450<br>
12.2.1  auto不能用于分配数组	450<br>
12.2.2  allocator::construct可使用任意构造函数	454<br>
13.1.5  将=default用于拷贝控制成员	475<br>
13.1.6  使用=default阻止拷贝类对象	475<br>
13.5  用移动类对象代替拷贝类对象	495<br>
13.6.1  右值引用	497<br>
13.6.1  标准库move函数	498<br>
13.6.2  移动构造函数和移动赋值	499<br>
13.6.2  移动构造函数通常应该是noexcept	499<br>
13.6.2  移动迭代器	506<br>
13.6.3  引用限定成员函数	509<br>
14.8.3  function类模板	538<br>
14.9.1  explicit类型转换运算符	542<br>
15.2.2  虚函数的override指示符	556<br>
15.2.2  通过定义类为final来阻止继承	559<br>
15.3  虚函数的override和final指示符	564<br>
15.7.2  删除的拷贝控制和继承	579<br>
15.7.4  继承的构造函数	583<br>
16.1.2  声明模板类型形参为友元	616<br>
16.1.2  模板类型别名	616<br>
16.1.3  模板函数的默认模板参数	620<br>
16.1.5  实例化的显式控制	623<br>
16.2.3  模板函数与尾置返回类型	631<br>
16.2.5  引用折叠规则	635<br>
16.2.6  用static_cast将左值转换为右值	638<br>
16.2.7  标准库forward函数	640<br>
16.4  可变参数模板	644<br>
16.4  sizeof...运算符	645<br>
16.4.3  可变参数模板与转发	648<br>
17.1  标准库Tuple类模板	662<br>
17.2.2  新的bitset运算	669<br>
17.3  正则表达式库	671<br>
17.4  随机数库	685<br>
17.5.1  浮点数格式控制	696<br>
18.1.4  noexcept异常指示符	716<br>
18.1.4  noexcept运算符	717<br>
18.2.1  内联名字空间	725<br>
18.3.1  继承的构造函数和多重继承	738<br>
19.3  有作用域的enum	762<br>
19.3  说明类型用于保存enum对象	764<br>
19.3  enum的提前声明	764<br>
19.4.3  标准库mem_fn类模板	772<br>
19.6  类类型的联合成员	777</p>
<p>参考博文<a href="https://blog.csdn.net/jiange_zh/article/details/79356417">C++11常用新特性快速一览</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[struct 和 union ]]></title>
        <id>https://lixin-scut.github.io//post/struct-he-union</id>
        <link href="https://lixin-scut.github.io//post/struct-he-union">
        </link>
        <updated>2020-02-15T02:40:06.000Z</updated>
        <content type="html"><![CDATA[<p>《C++ primer》<br>
<strong>struct 关键词</strong><br>
类体的花括号形成一个新的作用域  表示结束的花括号后必须写一个分号，因为类体后面可以紧跟变量名，以示对该类型对象的定义<br>
struct 聚合类<br>
聚合类使得用户可以直接访问其成员，并且具有特殊的初始化语法<br>
聚合类的特性：1.所有成员都是public的2.没有定义任何构造函数3，没有类内初始值4.没有基类，也没有virtual函数<br>
对聚合类进行初始化的初始值的顺序必须与声明的顺序一致，且初始值列表的元素个数不能超过类的成员数量 例如 struct Data{int ival; string s}   Data val={0,”Anna”};//这里的顺序不可以反过来<br>
如果初始值列表中的元素个数少于类的成员数量，则靠后的成员被值初始化</p>
<p><strong>union:一种节省空间的类</strong><br>
联合（union)是一种特殊的类。一个union可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当我们给union的某个成员赋值之后，该union的其他成员就变成未定义的状态了。分配给一个union对象的存储空间至少要能容纳它的最大的数据成员。和其他类一样，一个union定义了一种新类型。<br>
union不能含有引用类型的成员<br>
含有构造函数 或析构函数的类类型也可以作为union的成员类型。union可以为其成员指定public、 protected和private等保护标记。默认情况下，union的成员都是公有的，这一点与struct相同。<br>
union可以定义包括构造函数和析构函数在内的成员函数。但是由于union既不能继承自其他类，也不能作为基类使用，所以在union中不能含有虚函数。</p>
<p>使用union类型<br>
union的名字是一个类型名。和其他内置类型一样，默认情况下union是未初始化的。我们可以像显式地初始化聚合类一样使用一对花括号内的初始值显式地初始化一个union：</p>
<p>我们使用通用的成员访问运算符（. 或者 -&gt;）访问一个union对象的成员：<br>
last_token.cval = ‘z’;<br>
pt-&gt;ival = 42;<br>
为union的一个数据成员赋值会令其他数据成员变成未定义的状态。因此，当我们使用 union时，必须淸楚地知道当前存储在union中的值到底是什么类型</p>
<p>匿名union<br>
匿名union(anonymous union)是一个未命名的union,并且在右花括号和分号之间没有任何声明（参见2.6.1节，第65页）。一旦我们定义了一个匿名union，编译器就自动地为该union创建一个未命名的对象<br>
在匿名union的定义所在的作用域内该union的成员都是可以直接访问的。<br>
匿名union不能包含受保护的成员或私有成员，也不能定义成员函数。</p>
<p>含有类类型的union<br>
如果union的成员类型定义了自己的构造函数和/或拷贝控制成员，则该union的用法要比只含有内置类型成员的union复杂得多。</p>
<p>使用类管理union成员<br>
对于union来说，要想构造或销毁类类型的成员必须执行非常复杂的操作，因此我们通常把含有类类型成员的union内嵌在另一个类当中。这个类可以管理并控制与union的类类型成员有关的状态转换。<br>
为了追踪union中到底存储了什么类型的值，我们通常会定义一个独立的对象，该对象称为union的判别式（discriminant)。我们可以使用判别式辨认union存储的值。为了保持union与其判别式同步，我们将判别式也作为Token的成员。我们的类将定义一个枚举类型（参见19.3节，第736页）的成员来追踪其union成员的状态。</p>
<p>问题：<br>
#struct 和 union 的区别</p>
<blockquote>
<p>一、Struct 和 Union有下列区别：<br>
1.在存储多个成员信息时，编译器会自动给struct第n个成员分配存储空间，struct 可以存储多个成员信息，而Union每个成员会用同一个存储空间，只能存储最后一个成员的信息。<br>
2.都是由多个不同的数据类型成员组成，但在任何同一时刻，Union只存放了一个被先选中的成员，而结构体的所有成员都存在。<br>
3.对于Union的不同成员赋值，将会对其他成员重写，原来成员的值就不存在了，而对于struct 的不同成员赋值 是互不影响的。</p>
</blockquote>
<blockquote>
<p>1：共用体和结构体都是由多个不同的数据类型成员组成， 但在任何同一时刻， 共用体只存放一个被选中的成员， 而结构体则存放所有的成员变量。<br>
2：对于共用体的不同成员赋值，将会对其他成员重写， 原来成员的值就不存在了， 而对于结构体的不同成员赋值是互不影响的<br>
3：内存分配不同<br>
union的大小为其内部所有变量的最大值，按照最大类型的倍数进行分配大小<br>
结构体struct分配方法类似，也是按照最大类型的倍数进行分配大小,但是还与顺序有关</p>
</blockquote>
<p>#struct 和 union 的字节对齐</p>
<blockquote>
<p>union的大小为其内部所有变量的最大值，按照最大类型的倍数进行分配大小<br>
如：<br>
typedef Union<br>
{<br>
char c[10];<br>
char cc1;<br>
}u11;<br>
typedef union<br>
{<br>
char c[10];<br>
int i;<br>
}u22;<br>
typedef union<br>
{<br>
char c[10];<br>
double d;<br>
}u33;<br>
sizeof(u11)结果是10<br>
sizeof(u22)结果是12，按照sizeof(int)*3分配空间<br>
sizeof(u33)结果是16，按照sizeof(double)*2分配空间。</p>
</blockquote>
<blockquote>
<p>结构体struct非配方法类似，也是按照最大类型的倍数进行分配大小,但是还与顺序有关<br>
如：<br>
typedef struct s1<br>
{<br>
char c;<br>
double d;<br>
}s11;<br>
typedef struct s2<br>
{<br>
char c;<br>
char cc;<br>
double d;<br>
}s22;<br>
typedef struct s3<br>
{<br>
char c;<br>
double d;<br>
char cc;<br>
}s33;<br>
sizeof(s11)结果是应该是9，但是系统按照sizeof(double)*2分配，所以大小是16<br>
sizeof(s22)结果是应该是10，但是系统按照sizeof(double)*2分配，所以大小是16，先分配8字节给c，c占用一个字节，剩余7字节可以存储cc，所以系统没有额外给cc分配内存。cc有了内存后剩余6字节无法存储d，系统就额外为d分配8字节，整个分配浪费内存6字节。<br>
sizeof(s22)结果是应该是10，但是系统按照sizeof(double)*3分配，所以大小是24，因为和定义顺序有关，所以当给c分配8个字节之后，剩余7个字节无法存储d，所以系统又分配了8个字节给d，之后又分配8个自己给cc，分配完后浪费了14个字节的空间。所以，在定义结构体struct 的时候按照s33的顺序分配可以节省内存</p>
</blockquote>
<p><strong>注意！！！数组在分配内存时不会视为一个整体，而是视为一个个元素！！！</strong></p>
<pre><code>struct data{
    char c;
    char c2[4];
    int i;
}test;
int main() {
    //test={'c',0};
    cout&lt;&lt;&amp;test&lt;&lt;&quot; &quot;&lt;&lt;&amp;(test.c2)&lt;&lt;&quot; &quot;&lt;&lt;&amp;(test.i)&lt;&lt;endl;
    cout&lt;&lt;sizeof(test);
}
//输出结果为
//0x1017ce0e8 0x1017ce0e9 0x105d860f0
//12
//说明c2并没有单独占一个4个空间,空洞出现在c2和i之间，而不是c和c2之间
</code></pre>
<p>注意！！！short（2字节）跟在char（1字节）后面的时候,也不是紧跟着的，会把4字节分为2字节，从第三个字节开始存储</p>
<pre><code>struct data{
    double d;
    char c;
    short s;
    int i;

}test;
int main() {
    //test={'c',0};
    cout&lt;&lt;(void *)&amp;(test.c)&lt;&lt;&quot; &quot;&lt;&lt;&amp;(test.s)&lt;&lt;endl;
    cout&lt;&lt;sizeof(test)&lt;&lt;endl;
    cout&lt;&lt;sizeof(test.c)&lt;&lt;endl;
}
//结果为
//0x10a7c90f0 0x10a7c90f2
//16
//1
</code></pre>
<p>#结构体 struct{char c;int a} 假设存储首地址是 0x00000,则 c 的存储地址为，a 的地址为， struct 的大小是?<br>
依据上一题，这道题的答案是<br>
c的存储地址为 0x00000，a的地址为0x00004，struct的大小为8<br>
代码验证得到同样的结果（因为地址无法一致就不贴上来了）</p>
<p>#sizeof(A)的结果是什么?</p>
<pre><code>struct Example{
char a;
int b;
short c;
} A;
</code></pre>
<p>根据上面的结论 大小为12<br>
注意如果把short换成double，char和int的起始地址分别为0x10dba90e8 0x10dba90ec，也就是说编译器还是以4字节为一个单位而不是double的8字节，int不能直接跟在char后面的，保证int不会被割裂</p>
<p>#c 的 struct 和 c++struct 的区别<br>
在c语言中，不能直接用结构体名来声明变量。<br>
在c++中，可以直接用结构体名来声明变量。<br>
如果想在c语言中直接用结构体名定义变量，需要用到 typedef</p>
<p>C语言中：<br>
Struct是用户自定义数据类型（UDT）。<br>
C++语言中：<br>
Struct是抽象数据类型（ADT），支持成员函数的定义。<br>
在C++中，struct的成员的默认访问说明符为public，class为private。<br>
c中的struct是没有权限设置的。<br>
C++中struct增加了访问权限,且可以和类一样有成员函数。<br>
C++中的struct等同于class,只是class默认成员权限是private,而struct默认成员权限是public。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 题18:删除链表中的重复节点]]></title>
        <id>https://lixin-scut.github.io//post/lian-biao-ti-18shan-chu-lian-biao-zhong-de-chong-fu-jie-dian</id>
        <link href="https://lixin-scut.github.io//post/lian-biao-ti-18shan-chu-lian-biao-zhong-de-chong-fu-jie-dian">
        </link>
        <updated>2020-02-15T01:55:06.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
</blockquote>
<p>注意和leetcode不同，这里必须delete节点，而不是仅仅连接起来就行<br>
这道题其实可以只使用一个curnode就完成的了，但是用了pre更加直观<br>
中途忘了把pre和cur接上了，然后又搞混了while的嵌套，还是得细心一点</p>
<pre><code>class Solution {
public:
    ListNode* deleteDuplication(ListNode* pHead)
    {
        if(pHead==NULL)return NULL;
        ListNode *virHead=new ListNode(0);
        virHead-&gt;next=pHead;
        ListNode *preNode=virHead;

        while(preNode){
            ListNode *curNode=preNode-&gt;next;
            int value;
            while(curNode&amp;&amp;curNode-&gt;next&amp;&amp;curNode-&gt;val==curNode-&gt;next-&gt;val){
                value=curNode-&gt;val;
                while(curNode&amp;&amp;curNode-&gt;val==value){
                    ListNode *temp=curNode;
                    curNode=curNode-&gt;next;
                    delete temp;
                }
            }
             preNode-&gt;next=curNode;
             preNode=curNode;
        }
        return virHead-&gt;next;
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>头节点可能与后面的节点重复，也就是说头节 点也可能被删除<br>
从头遍历整个链表。如果当前节点(代码中的pNode)的 值与下一个节点的值相同，那么它们就是重复的节点，都可以被删除。为 了保证删除之后的链表仍然是相连的，我们要把当前节点的前一个节点(代 码中的pPreNode)和后面值比当前节点的值大的节点相连。我们要确保 pPreNode始终与下一个没有重复的节点连接在一起。</p>
</blockquote>
<pre><code>void DeleteDuplication(ListNode** pHead)
{
    if(pHead == nullptr || *pHead == nullptr)
        return;

    ListNode* pPreNode = nullptr;
    ListNode* pNode = *pHead;
    while(pNode != nullptr)
    {
        ListNode *pNext = pNode-&gt;m_pNext;
        bool needDelete = false;
        if(pNext != nullptr &amp;&amp; pNext-&gt;m_nValue == pNode-&gt;m_nValue)
            needDelete = true;

        if(!needDelete)
        {
            pPreNode = pNode;
            pNode = pNode-&gt;m_pNext;
        }
        else
        {
            int value = pNode-&gt;m_nValue;
            ListNode* pToBeDel = pNode;
            while(pToBeDel != nullptr &amp;&amp; pToBeDel-&gt;m_nValue == value)
            {
                pNext = pToBeDel-&gt;m_pNext;

                delete pToBeDel;
                pToBeDel = nullptr;

                pToBeDel = pNext;
            }

            if(pPreNode == nullptr)
                *pHead = pNext;
            else
                pPreNode-&gt;m_pNext = pNext;
            pNode = pNext;
        }
    }
}
</code></pre>
<p>注意必须一个一个节点删除，不能像leetcode那样直接接上next，因为动态内存需要手动delete</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Channel 与 Poller --Reactor的关键结构]]></title>
        <id>https://lixin-scut.github.io//post/channel-yu-poller-reactor-de-guan-jian-jie-gou</id>
        <link href="https://lixin-scut.github.io//post/channel-yu-poller-reactor-de-guan-jian-jie-gou">
        </link>
        <updated>2020-02-14T11:40:22.000Z</updated>
        <content type="html"><![CDATA[<p>Reactor最核心的事件分发机制，是将IO multiplexing拿到的IO事件分发给各个文件描述符fd的事件处理函数。</p>
<h3 id="channel-class">Channel class</h3>
<p>每个Channel对象：<br>
1.只属于一个EventLoop<br>
2.都只属于某一个IO线程，<br>
3.只负责一个文件描述符fd，但它并不拥有这个fd，也不会在析构时关闭fd<br>
Channel会把不同的IO事件分发为不同的回调，回调用boost::funciton表示，用户无须继承Channel<br>
muduo用户一般不直接使用Channel，而会使用更上层的封装，如TcpConnection。<br>
Channel的生命期由其owner class负责管理，它一般是其他class的直接或简介成员<br>
Channel的成员函数都只能在IO线程调用，因此更新数据成员都不必加锁<br>
events_是其关心的IO事件，由用户设置，revents_是目前活动的事件，由EventLoop/Poller设置，这两个字段都是bit pattern<br>
Channel.h没有包含任何POSIX头文件，因此kReadEvent和kWriteEvent等常量的定义要放到源文件中<br>
Channel::update() 会调用EventLoop::updateChannel() ，然后后者会转而调用Poller::updateChannel()，由于头文件中没有包含EventLoop.h，所以必须在源文件中定义<br>
Channel::handleEvent()是Channel的核心，由EventLoop::loop()调用，它的功能是根据revents_的值分别调用不同的用户回调</p>
<h3 id="poller-class">Poller class</h3>
<p>Poller class是IO multiplexing的封装，在muduo中是个抽象基类，因为muduo同时支持poll和epoll两种IO multiplexing机制。<br>
Poller是EventLoop的间接成员，只供其owner EventLoop在IO线程中调用，因此无须加锁，生命期与EventLoop相等<br>
Poller并不拥有不了Channel，Channel在析构之前必须自己unregister（EventLoop::removeChannel()）避免空悬指针。<br>
poll()是Poller的核心功能，它调用poll或者epoll获得当前活动的IO事件，然后填充调用方的activeChannels，并返回poll return的时刻<br>
fillActiveChannels()遍历pollfds_,找出有活动事件的fd,把它对应的Channel填入activeChannels。<br>
当前活动事件revents 会保存在 Channel中，供 Channel::handleEvent()使用<br>
注意这里我们不能一边遍历pollfds_, 一边调用Channel::handleEvent(),因 为后者会添加或删除Channel,从而造成pollfds.在遍历期间改变大小，这是非常危 险的。另外一个原因是简化Poller的职责，它只负责IO multiplexing,不负责事件 分发(dispatching)这样将来可以方便地替换为其他更高效的IO multiplexing机 制，如 epoll<br>
Poller::updateChannel()的主要功能是负责维护和更新pollfds_数组。<br>
如果某个Channel暂时不关心任何事件，就把pollfd.fd设为-1,让 poll忽略此项，这里不能改为把pollfd.events设为0,这样无法屏蔽 POLLERR事件，改进的做法是把pollfd.fd设为channel-&gt;fd()的相反数减一（因为fd从0开始，0的相反数还是0），这样可以进一步检查invariant</p>
<h3 id="eventloop-的改动">EventLoop 的改动</h3>
<p>EventLoop class新增了 quit()成员函数，还加了几个数据成员，并在构造函数 里初始化它们。注意EventLoop通过scoped_ptr来间接持有Poller,因此EventLoop.h 不必包含Poller.h,只需前向声明Poller class,为此，EventLoop的析构函数必须在 EventLoop.cc中显式定义。<br>
EventLoop: :loop()有了真正的工作内容，它调用Poller::poll()获得当前活动事件的Channel列表，然后依次调用每个Channel的handleEvent()函数。<br>
<img src="https://lixin-scut.github.io//post-images/1581682950739.png" alt=""><br>
以上几个class构成了 Reactor模式的核心内容<br>
终止事件循环只要将quit_设为true即可，但是quit()不是立刻 发生的，它会在EventLoop: :loop()下一次检查while (!quit_)的时候起效。 如果在非当前IO线程调用quit()，延迟可以长达数秒，将来我们可以唤醒EventLoop 以缩小延时。但是quit()不是中断或signal,而是设标志，如果EventLoop:: loop() 正阻塞在某个调用中，quit()不会立刻生效。<br>
EventLoop::updateChannel()在检查断言之后调用 Poller::updateChannel(), EventLoop不关心Poller是如何管理Channel列表的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ C++中的关键字 inline]]></title>
        <id>https://lixin-scut.github.io//post/czhong-de-guan-jian-zi-inline</id>
        <link href="https://lixin-scut.github.io//post/czhong-de-guan-jian-zi-inline">
        </link>
        <updated>2020-02-14T08:24:42.000Z</updated>
        <content type="html"><![CDATA[<p>《C++ primer》<br>
内联函数关键字inline 适用于规模小频繁调用的函数<br>
内联函数 在调用点上召开为一段程序 避免函数调用的开销<br>
内联函数关键字inline 适用于规模小频繁调用的函数<br>
Constexpr函数返回类型和形参类型都是字面值类型（引用 指针 算术类型）（自定义类、IO库、string类等就不是字面值类型），函数体内有且只有一条return语句，被隐式地指定为内联函数<br>
比如 constexpr int func() { return 42; }<br>
Constexpr函数允许返回值并非一个常量，所以不一定返回常量表达式(传入常量表达式，返回常量表达式，反之则返回非常量表达式)<br>
与其他函数不同，内联函数和Constexpr函数 可以多次定义，但需要保持一致，所以通常定义在头文件中</p>
<p>定义在类内部的函数是隐式的inline函数</p>
<p>当我们使用=default时，合成的成员函数会隐式地声明为内联函数，如果不希望其定义为内联，则应该只在成员的类外定义使用=default<br>
如果 = default 在类的内部，则默认构造函数是内联函数，可以直接展开，在类的外部则默认情况下不是内联的</p>
<p>内联成员函数可以声明与定义分离，直接在函数前面加上inline就好，声明定义、内部外部都可以<br>
关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用。</p>
<p>一个lambda表达式表示一个可调用的代码单元，可以将其理解为一个未命名的内联函数</p>
<p>函数模板可声明为 inline 或 constexpr 的，如同非模板函数一样。 inline 或constexpr 说明符放在模板参数列表之后，返回类型之前：</p>
<p>内联命名空间<br>
内联命名空间中的名字可以被外层命名空间直接使用。也就是说，我们无须在内联命名空间的名字前添加表示该命名空问的前缀，通过外层命名空间的名字就可以直接访问它。    定义内联命名空间的方式是在关键字namespace前添加关键字inline：    inline namespace FifthEd{<br>
/ /该命名空间表示本书第5版的代码<br>
关键字inline必须出现在命名空间第一次定义的地方，后续再打开命名空间的时候可以写inline.也可以不写。<br>
当应用程序的代码在一次发布和另一次发布之间发生了改变时，常常会用到内联命名空间。<br>
新发布的可以直接用，旧发布的需要加上前缀</p>
<p>#C 中 inline 的作用<br>
1.c/c++中的inline，使用在函数声明处，表示程序员请求编译器在此函数的被调用处将此函数实现插入，而不是像普通函数那样生成调用代码(申请是否有效取决于编译器)。一般地说，这样做的优点是省掉了调用函数的开销；缺点则是可能会增加代所生成目标代码的尺寸<br>
实际上，即使没有手工指定inline函数，编译器一般还会选择一些代码量较小但使用频繁的函数作为inline函数，以此作为性能优化的途径之一。<br>
2.在C语言中，如果一些函数被频繁调用，不断地有函数入栈，即函数栈，会造成栈空间或栈内存的大量消耗。<br>
为了解决这个问题，特别的引入了inline修饰符，表示为内联函数。<br>
栈空间就是指放置程式的局部数据也就是函数内数据的内存空间，在系统下，栈空间是有限的，假如频繁大量的使用就会造成因栈空间不足所造成的程式出错的问题，函数的死循环递归调用的最终结果就是导致栈内存空间枯竭。<br>
3.inline （内联函数）：在函数调用点把函数代码展开<br>
这里的展开是给编译器的一个建议，建议编译器将内联函数展开，具体会不会展开，还是要看编译器的处理，比如如果在内联函<br>
数中有递归的使用，编译器就不会将它展开，因为编译器只是进行语法，语义分析，并不知道运行的时候递归会有多少层。在编<br>
译期间，复制代码到函数调用处，不会产生符号表，也不存在函数堆栈的开辟和栈帧回收。<br>
一般在函数的代码量比较少，函数的执行开销小于函数的调用开销时，才会使用内联函数。</p>
<p>#inline如果代码过长会怎么样?<br>
内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。<br>
以下情况不宜使用内联：<br>
（1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。<br>
（2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。<br>
一个好的编译器将会根据函数的定义体，自动地取消不值得的内联（这进一步说明了inline 不应该出现在函数的声明中）。</p>
<p>#inline、define、普通函数的区别<br>
内联函数与普通函数的区别：<br>
1.普通函数调用需要开辟栈帧和回收栈帧，内联函数不开辟和回收栈帧，在调用出展开代码<br>
2.普通函数会在编译完生成函数名对应的符号，链接的时候在符号表上可以找到，内联函数不生成符号<br>
3.内联函数可以放在头文件中，方便调用，但是普通函数放在头文件中，多个文件编译用到一个头文件，可能会产生函数的重定义</p>
<p>注意：内联函数在release版本中是这样，在debug版本中除了不生成符号表，和普通的函数无差别，也需要栈帧开辟(方便调试)<br>
缺点：函数展开可能会产生大量的冗余，效率也并不高<br>
宏：字符替换，在预编译阶段进行</p>
<p>内联函数与宏的区别：<br>
1.宏在预编译阶段进行字符替换，没有安全检查，内联函数在编译阶段展开，编译阶段有安全检查，内联函数相对宏更安全<br>
2.宏无法调试，内联函数可以调试<br>
3.内联是一种更安全的宏</p>
<p>static：静态关键字，可以修饰<br>
1)局部静态变量<br>
(2)外部静态变量/函数<br>
(3)静态数据成员/成员函数<br>
static与auto类型(普通)局部变量相比, static局部变量有三点不同</p>
<ol>
<li>存储空间分配不同<br>
auto类型分配在栈上, 属于动态存储类别, 占动态存储区空间, 函数调用结束后自动释放, 而static分配在静态存储区, 在程序整个运行期间都不释放. 两者之间的作用域相同, 但生存期不同.</li>
<li>static局部变量在所处模块在初次运行时进行初始化工作, 且只操作一次</li>
<li>对于局部静态变量, 如果不赋初值, 编译期会自动赋初值0或空字符, 而auto类型的初值是不确定的. (对于C++中的class对象例外, class的对象实例如果不初始化, 则会自动调用默认构造函数, 不管是否是static类型)<br>
特点: static局部变量的”记忆性”与生存期的”全局性”<br>
所谓”记忆性”是指在两次函数调用时, 在第二次调用进入时, 能保持第一次调用退出时的值.</li>
</ol>
<p>static函数与普通函数的区别：<br>
1.普通函数是整个工程可见的，static只是本文件可见<br>
2.static函数形成的符号是局部的，local，链接器不可见，普通函数生成的符号是全局的，global，链接器可见。</p>
<p>注意 inline函数和static的差异也在于inline函数可以跨文件使用</p>
<pre><code>//main.cpp
inline int getval(){
    return 7;
}
int func();
int main() {
    cout&lt;&lt;getval()&lt;&lt;endl;
    cout&lt;&lt;func()&lt;&lt;endl;
}
</code></pre>
<pre><code>//inlineTest.cpp
inline int getval();

int func(){
    return getval();
}
</code></pre>
<p>最终都输出7</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vector与list]]></title>
        <id>https://lixin-scut.github.io//post/stl-zhong-ge-chong-rong-qi-de-di-ceng-shi-xian-yuan-li</id>
        <link href="https://lixin-scut.github.io//post/stl-zhong-ge-chong-rong-qi-de-di-ceng-shi-xian-yuan-li">
        </link>
        <updated>2020-02-14T03:04:05.000Z</updated>
        <content type="html"><![CDATA[<p>vector：<br>
vector底层是一个只能从尾部增删的连续线性空间的动态数组，会自行扩充空间以容纳新元素<br>
提供random iterator，最基本的三个迭代器为start、finish和end_of_storage ，然后分为size和capacity<br>
每当size需要等于capacity时需要重新分配当前capacity两倍的空间进行扩增<br>
必须经历 重新分配空间、元素移动、释放原空间，其中元素移动使用的是uninitialized_copy函数<br>
每当重新分配内存都会使迭代器失效（迭代器本质是一个指针）<br>
vector默认使用alloc作为空间配置器，并据此另外定义了一个data_allocator，为的是更方便以元素大小作为配置单位<br>
同时使用全局函数construct来构造新元素</p>
<p>list：<br>
非连续线性空间的双向链表，节点中有一个prev指针一个next指针和一个data值</p>
<pre><code>template &lt;class T&gt;
struct _list_node{
	typedef void* void_pointer;
	void_pointer prev;
	void_pointer next;
	T data;
}
</code></pre>
<p>迭代器是bidirectional iterator 具备前移后移的能力，而无法随机提取<br>
因为不需要考虑分配内存的问题，所以迭代器不会失效，只有指向被删除的元素的迭代器等情况会失效<br>
默认使用alloc作为空间配置器，另外定义一个list_node_allocator<br>
list实际上是一个环形链表，为了能够在尾部插入，尾部有一个end节点，这个节点的next指针指向list的头部，同时头节点的pre也指向尾节点</p>
<p>vector 和 list 中，删除末尾的元素，其指针和迭代器如何变化?若删除的是中间的元素呢?<br>
<img src="https://lixin-scut.github.io//post-images/1581656581131.png" alt=""><br>
注意这里的失效不是指迭代器不能用，而是我们已经无法掌控确定迭代器指向的确定值了，因为本质上都是连续内存和指针，除了尾后位置其他的其实都一样</p>
<pre><code>//Lixin
int main() {
    vector&lt;int&gt; vi{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    vector&lt;int&gt;::iterator beg = vi.begin();
    vector&lt;int&gt;::iterator num8 = beg + 8;
    vector&lt;int&gt;::iterator num2 = beg + 2;
    vector&lt;int&gt;::iterator num5 = beg + 5;
    vector&lt;int&gt;::iterator num9 = beg + 9;

    cout&lt;&lt;*num2&lt;&lt;*num5&lt;&lt;*num8&lt;&lt;endl;
    vi.erase(num5);
    cout&lt;&lt;*num2&lt;&lt;endl;
    cout&lt;&lt;*num5&lt;&lt;endl;
    cout&lt;&lt;*num9&lt;&lt;endl;
}
</code></pre>
<p>vector 和 list 的区别<br>
stl 里 vector 和 list 区别，vector 怎么实现的，什么时候用 vector，什么时候用 list</p>
<blockquote>
<p>#底层结构<br>
  vector的底层结构是动态顺序表，在内存中是一段连续的空间。<br>
  list的底层结构是带头节点的双向循环链表，在内存中不是一段连续的空间。<br>
#随机访问<br>
  vector支持随机访问，可以利用下标精准定位到一个元素上，访问某个元素的时间复杂度是O(1)。<br>
  list不支持随机访问，要想访问list中的某个元素只能是从前向后或从后向前依次遍历，时间复杂度是O(N)。<br>
#插入和删除<br>
 vector任意位置插入和删除的效率低，因为它每插入一个元素（尾插除外），都需要搬移数据，时间复杂度是O(N)，而且插入还有可能要增容，这样一来还要开辟新空间，拷贝元素，是旧空间，效率会更低。<br>
  list任意位置插入和删除的效率高，他不需要搬移元素，只需要改变插入或删除位置的前后两个节点的指向即可，时间复杂度为O(1)。<br>
#空间利用率<br>
  vector由于底层是动态顺序表，在内存中是一段连续的空间，所以不容易造成内存碎片，空间利用率高，缓存利用率高。<br>
  list的底层节点动态开辟空间，小姐点容易造成内存碎片，空间利用率低，缓存利用率低。<br>
#迭代器<br>
  vector的迭代器是原生态指针。<br>
  list对原生态指针（节点的指针）进行了封装。<br>
#迭代器失效<br>
  vector在插入元素时的时候，要重新给所有的迭代器赋值，因为插入元素有可能导致扩容，只是原来的迭代器失效，删除元素时当前迭代器同样需要重新赋值，否则会失效。<br>
  list在插入元素的时候不会导致迭代器失效，删除元素的时候指挥导致当前迭代器失效，其他的迭代器不会受到影响。<br>
#使用场景<br>
  vector适合需要高效率存储，需要随机访问，并且不管行插入和删除效率的场景。<br>
  list适合有大量的插入和删除操作，并且不关心随机访问的场景</p>
</blockquote>
<p>Vector 的内存分配、底层的实现，如果数据量很多扩容会怎么样，怎么设计更好的<br>
#新增元素：Vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素；<br>
#对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了 ；<br>
#初始时刻vector的capacity为0，塞入第一个元素后capacity增加为1；<br>
#不同的编译器实现的扩容方式不一样，VS2015中以1.5倍扩容，GCC以2倍扩容。</p>
<p>stl vector push_back() 的复杂度?扩容机制?为什么要 2 倍扩容?<br>
n 个元素，n 次操作，每一次操作需要花费时间为 m / (m - 1)，这是一个常量.<br>
所以，我们采用均摊分析的方法可知，vector 中 push_back 操作的时间复杂度为常量时间.<br>
在STL中，vector的每次扩容都是2倍，也就是m=2.这样，n次总的时间约为n*2/(2-1) = 2n；那么每一操作要花的时间就是2,因此是常量级。</p>
<p>list 和 vector 实现有什么区别?讲讲 vector 的 resize 操作<br>
1.resize函数首先判断新的size和原size的大小，如果小于的话就直接用erase截断，否则调用insert<br>
2.在insert里面首先判断是否需要扩容<br>
3.无须扩容的话再判断插入点后现有元素和新增元素个数，如果需要插入的个数比现有元素还多的话，就先使用uninitiated_fill_n来插入新元素，然后剩下的就直接uninitialized_copy复制</p>
<p>定义一个类 T，使得 vector<T>和 T a[10]这两个定义，一个成功，一个失败。</p>
<p>现在循环往一个 vector 里面插入 10000 个数据，一次插入一个，怎么高效，用 resize() 还是 reserve()，为什么<br>
resize(n,t) reserve(n)<br>
vector 的reserve增加了vector的capacity，但是它的size没有改变，而resize改变了vector的capacity同时也增加了它的size，resize把重新分配的剩余空间用存储元素的默认构造函数填充新分配的空间。<br>
所以如果是插入相同值，可以直接resize，如果是不同值，reserve 避免多次拷贝</p>
<p>手撕 vector 的 push_back(),不准用 insert 方法;</p>
<pre><code>void push_back(const T&amp; value){
	if(finish! = end_of_storage){
			construct(finish,x);
			++finish;
	}
	else{
	}
	const size_type old_size = size();
	const size_type len = old_size!=0?2*old_size:1;
	
	iterator new_start = data_allocator::allocate(len);
	iterator new_finish = new_start;
	try{
		new_finish = uninitialized_copy(start,finish,new_start);
		construct(new_finish,x);
		++new_finish;
		cath(){
				destroy(new_start,new_finish);
				data_allocator::deallocate(new_start,len);
				throw;
		}
	destroy(start,finish);
	deallocate();
	
	start = new_start;
	finish = new_finish;
	end_of_storage = start + len;
	}
}
</code></pre>
]]></content>
    </entry>
</feed>