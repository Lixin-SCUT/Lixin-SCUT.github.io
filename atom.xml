<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-05-12T15:35:59.736Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>千里之行，始于足下。不积跬步，无以至千里。</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[ Python - IO编程]]></title>
        <id>https://lixin-scut.github.io//post/python-io-bian-cheng</id>
        <link href="https://lixin-scut.github.io//post/python-io-bian-cheng">
        </link>
        <updated>2020-05-12T14:17:38.000Z</updated>
        <content type="html"><![CDATA[<p>O在计算机中指Input/Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。</p>
<p>比如你打开浏览器，浏览器这个程序就需要通过网络IO获取网页。浏览器首先会发送数据给服务器，告诉它我想要的HTML，这个动作是往外发数据，叫Output，随后服务器把网页发过来，这个动作是从外面接收数据，叫Input。</p>
<p>所以，通常，程序完成IO操作会有Input和Output两个数据流。当然也有只用一个的情况，比如，从磁盘读取文件到内存，就只有Input操作，反过来，把数据写到磁盘文件里，就只是一个Output操作。</p>
<p>IO编程中，Stream（流）是一个很重要的概念，可以把流想象成一个水管，数据就是水管里的水，但是只能单向流动。Input Stream就是数据从外面（磁盘、网络）流进内存，Output Stream就是数据从内存流到外面去。对于浏览网页来说，浏览器和服务器之间至少需要建立两根水管，才可以既能发数据，又能收数据。</p>
<p>由于CPU和内存的速度远远高于外设的速度，所以，在IO编程中，就存在速度严重不匹配的问题。举个例子来说，比如要把100M的数据写入磁盘，CPU输出100M的数据只需要0.01秒，可是磁盘要接收这100M数据可能需要10秒，怎么办呢？有两种办法：</p>
<p>第一种是CPU等着，也就是程序暂停执行后续代码，等100M的数据在10秒后写入磁盘，再接着往下执行，这种模式称为同步IO；</p>
<p>另一种方法是CPU不等待，只是告诉磁盘继续读写，于是，后续代码可以立刻接着执行，这种模式称为异步IO。</p>
<p>同步和异步的区别就在于是否等待IO执行的结果</p>
<p>很明显，使用异步IO来编写程序性能会远远高于同步IO，但是异步IO的缺点是编程模型复杂，而通知你的方法也各不相同。比如回调模式和轮询模式。总之，异步IO的复杂度远远高于同步IO。</p>
<p>操作IO的能力都是由操作系统提供的，每一种编程语言都会把操作系统提供的低级C接口封装起来方便使用，Python也不例外。我们后面会详细讨论Python的IO编程接口。</p>
<p>注意，<strong>本章的IO编程都是同步模式</strong>，异步IO由于复杂度太高，后续涉及到服务器端程序开发时我们再讨论。</p>
<h2 id="文件读写">文件读写</h2>
<p>读写文件是最常见的IO操作。Python内置了读写文件的函数，用法和C是兼容的。</p>
<p>读写文件前，我们先必须了解一下，<strong>在磁盘上读写文件的功能都是由操作系统提供的，现代操作系统不允许普通的程序直接操作磁盘</strong>，所以，读写文件就是<strong>请求操作系统打开一个文件对象（通常称为文件描述符）</strong>，然后，<strong>通过操作系统提供的接口</strong>从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。</p>
<h3 id="读文件">读文件</h3>
<p>要以读文件的模式打开一个文件对象，使用Python内置的<strong>open()函数，传入文件名和标示符</strong>：</p>
<pre><code>&gt;&gt;&gt; f = open('/Users/michael/test.txt', 'r')
</code></pre>
<p><strong>标示符'r'表示读</strong>，这样，我们就成功地打开了一个文件。</p>
<p>如果<strong>文件不存在，open()函数就会抛出一个IOError的错误</strong>，并且给出错误码和详细的信息告诉你文件不存在：</p>
<pre><code>&gt;&gt;&gt; f=open('/Users/michael/notfound.txt', 'r')
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
FileNotFoundError: [Errno 2] No such file or directory: '/Users/michael/notfound.txt'
</code></pre>
<p>如果文件打开成功，接下来，<strong>调用read()方法可以一次读取文件的全部内容</strong>，Python把内容读到内存，<strong>用一个str对象表示</strong>：</p>
<pre><code>&gt;&gt;&gt; f.read()
'Hello, world!'
</code></pre>
<p>最后一步是调用close()方法关闭文件。<strong>文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的</strong>：</p>
<pre><code>&gt;&gt;&gt; f.close()
</code></pre>
<p>由于文件读写时都有可能产生IOError，<strong>一旦出错，后面的f.close()就不会调用</strong>。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try ... finally来实现：</p>
<pre><code>try:
    f = open('/path/to/file', 'r')
    print(f.read())
finally:
    if f:
        f.close()
</code></pre>
<p>但是每次都这么写实在太繁琐，所以，Python<strong>引入了with语句来自动帮我们调用close()方法</strong>：</p>
<pre><code>with open('/path/to/file', 'r') as f:
    print(f.read())
</code></pre>
<p>这和前面的try ... finally是一样的，但是<strong>代码更简洁，并且不必调用f.close()方法。</strong></p>
<ol>
<li><strong>调用read()会一次性读取文件的全部内容</strong>，如果文件有10G，内存就爆了，</li>
<li>所以，要保险起见，<strong>可以反复调用read(size)方法</strong>，每次<strong>最多读取</strong>size个字节的内容。</li>
<li>另外，<strong>调用readline()可以每次读取一行内容</strong></li>
<li>调用<strong>readlines()一次读取所有内容并按行返回list</strong>。<br>
因此，要根据需要决定怎么调用。</li>
</ol>
<p>如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便：</p>
<pre><code>for line in f.readlines():
    print(line.strip()) # 把末尾的'\n'删掉
</code></pre>
<h3 id="file-like-object">file-like Object</h3>
<p>像open()函数返回的这种有个read()方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。<strong>file-like Object不要求从特定类继承，只要写个read()方法就行</strong>。</p>
<p><strong>StringIO就是在内存中创建的file-like Object，常用作临时缓冲</strong>。</p>
<h3 id="二进制文件">二进制文件</h3>
<p>前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要<strong>读取二进制文件</strong>，比如图片、视频等等，<strong>用'rb'模式</strong>打开文件即可：</p>
<pre><code>&gt;&gt;&gt; f = open('/Users/michael/test.jpg', 'rb')
&gt;&gt;&gt; f.read()
b'\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...' # 十六进制表示的字节
字符编码
</code></pre>
<p>要读取<strong>非UTF-8编码</strong>的文本文件，需要<strong>给open()函数传入encoding参数</strong>，例如，读取GBK编码的文件：</p>
<pre><code>&gt;&gt;&gt; f = open('/Users/michael/gbk.txt', 'r', encoding='gbk')
&gt;&gt;&gt; f.read()
'测试'
</code></pre>
<p>遇到有些编码不规范的文件，你可能会遇到UnicodeDecodeError，因为在文本文件中可能<strong>夹杂了一些非法编码的字符</strong>。遇到这种情况，open()函数还接收一个<strong>errors参数</strong>，表示如果<strong>遇到编码错误后如何处理</strong>。最简单的方式是直接忽略：</p>
<pre><code>&gt;&gt;&gt; f = open('/Users/michael/gbk.txt', 'r', encoding='gbk', errors='ignore')

</code></pre>
<h3 id="写文件">写文件</h3>
<p>写文件和读文件是一样的，唯一区别是<strong>调用open()函数时，传入标识符'w'或者'wb'表示写文本文件或写二进制文件</strong>：</p>
<pre><code>&gt;&gt;&gt; f = open('/Users/michael/test.txt', 'w')
&gt;&gt;&gt; f.write('Hello, world!')
&gt;&gt;&gt; f.close()
</code></pre>
<p>你可以反复调用write()来写入文件，但是<strong>务必要调用f.close()来关闭文件</strong>。当我们<strong>写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入</strong>。<br>
<strong>只有调用close()方法时，操作系统才保证把没有写入的数据全部写入磁盘</strong>。<strong>忘记调用close()的后果是数据可能只写了一部分到磁盘，剩下的丢失了</strong>。所以，<strong>还是用with语句来得保险</strong>：</p>
<pre><code>with open('/Users/michael/test.txt', 'w') as f:
    f.write('Hello, world!')
</code></pre>
<p>要<strong>写入特定编码的文本文件</strong>，请给open()函数传入<strong>encoding参数</strong>，将字符串自动转换成指定编码。</p>
<p>细心的童鞋会发现，<strong>以'w'模式写入文件时，如果文件已存在，会直接覆盖</strong>（相当于删掉后新写入一个文件）。如果我们希望追加到文件末尾怎么办？可以<strong>传入'a'以追加（append）模式写入</strong>。</p>
<pre><code>with open('/Users/michael/test.txt', 'a') as f:
    f.write('Hello, world!')
</code></pre>
<p>所有模式的定义及含义可以参考Python的官方文档。</p>
<h3 id="windows路径问题">windows路径问题</h3>
<p>文件路径不能用反斜杠‘\’。举个例子，如果我传入的文件路径是这样的：</p>
<p><code>sys.path.append('c:\Users\mshacxiang\VScode_project\web_ddt')</code></p>
<p>则会报错<code>SyntaxError: (unicode error) 'unicodeescape' codec can't decode bytes in position 2-3: tr</code></p>
<p>原因分析：在windows系统当中读取文件路径可以使用,但是在python字符串中\有转义的含义，如\t可代表TAB，\n代表换行，所以我们需要采取一些方式使得\不被解读为转义字符。目前有3个解决方案</p>
<p>1、在路径前面加r，即保持字符原始值的意思。</p>
<p><code>sys.path.append(r'c:\Users\mshacxiang\VScode_project\web_ddt')</code></p>
<p>2、替换为双反斜杠</p>
<p><code>sys.path.append('c:\\Users\\mshacxiang\\VScode_project\\web_ddt')</code></p>
<p>3、替换为正斜杠</p>
<p><code>sys.path.append('c:/Users/mshacxiang/VScode_project/web_ddt')</code></p>
<h2 id="stringio和bytesio">StringIO和BytesIO</h2>
<h3 id="stringio">StringIO</h3>
<p>很多时候，数据读写不一定是文件，也可以在内存中读写。</p>
<p><strong>StringIO顾名思义就是在内存中读写str。类似于C++的iostringstream</strong></p>
<p>要把str写入StringIO，我们需要先创建一个StringIO，然后，像文件一样写入即可：</p>
<pre><code>&gt;&gt;&gt; from io import StringIO

&gt;&gt;&gt; f = StringIO()
&gt;&gt;&gt; f.write('hello')
5
&gt;&gt;&gt; f.write(' ')
1
&gt;&gt;&gt; f.write('world!')
6
&gt;&gt;&gt; print(f.getvalue())
hello world!
</code></pre>
<p><strong>getvalue()方法用于获得写入后的str</strong>。</p>
<p>要读取StringIO，可以用一个str初始化StringIO，然后，像读文件一样读取：</p>
<pre><code>&gt;&gt;&gt; from io import StringIO

&gt;&gt;&gt; f = StringIO('Hello!\nHi!\nGoodbye!')
&gt;&gt;&gt; while True:
...     s = f.readline()
...     if s == '':
...         break
...     print(s.strip())
...
Hello!
Hi!
Goodbye!

</code></pre>
<h3 id="bytesio">BytesIO</h3>
<p>StringIO操作的只能是str，如果要操作<strong>二进制数据，就需要使用BytesIO</strong>。</p>
<p>BytesIO实现了在内存中读写bytes，我们创建一个BytesIO，然后写入一些bytes：</p>
<pre><code>&gt;&gt;&gt; from io import BytesIO
&gt;&gt;&gt; f = BytesIO()
&gt;&gt;&gt; f.write('中文'.encode('utf-8'))
6
&gt;&gt;&gt; print(f.getvalue())
b'\xe4\xb8\xad\xe6\x96\x87'
</code></pre>
<p>请注意，<strong>写入的不是str，而是经过UTF-8编码的bytes</strong>。</p>
<p>和StringIO类似，可以用一个bytes初始化BytesIO，然后，像读文件一样读取：</p>
<pre><code>&gt;&gt;&gt; from io import BytesIO
&gt;&gt;&gt; f = BytesIO(b'\xe4\xb8\xad\xe6\x96\x87')
&gt;&gt;&gt; f.read()
b'\xe4\xb8\xad\xe6\x96\x87'
</code></pre>
<h3 id="小结">小结</h3>
<p>StringIO和BytesIO是在内存中操作str和bytes的方法，使得和读写文件具有一致的接口。</p>
<h2 id="操作文件和目录">操作文件和目录</h2>
<p>如果我们要操作文件、目录，可以在命令行下面输入操作系统提供的各种命令来完成。比如dir、cp等命令。</p>
<p>如果要在Python程序中执行这些目录和文件的操作怎么办？其实<strong>操作系统提供的命令只是简单地调用了操作系统提供的接口函数，Python内置的os模块也可以直接调用操作系统提供的接口函数。</strong></p>
<p>打开Python交互式命令行，我们来看看如何使用os模块的基本功能：</p>
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; os.name # 操作系统类型
'posix'
</code></pre>
<p>如果是posix，说明系统是Linux、Unix或Mac OS X，如果是nt，就是Windows系统。</p>
<p>要获取详细的系统信息，可以调用uname()函数：</p>
<pre><code>&gt;&gt;&gt; os.uname()
posix.uname_result(sysname='Darwin', nodename='MichaelMacPro.local', release='14.3.0', version='Darwin Kernel Version 14.3.0: Mon Mar 23 11:59:05 PDT 2015; root:xnu-2782.20.48~5/RELEASE_X86_64', machine='x86_64')
</code></pre>
<p>注意不要漏掉括号，否则就是返回函数类型<br>
注意uname()函数在Windows上不提供，也就是说，os模块的某些函数是跟操作系统相关的。</p>
<h3 id="环境变量">环境变量</h3>
<p>在操作系统中定义的<strong>环境变量，全部保存在os.environ这个变量中</strong>，可以直接查看：</p>
<pre><code>&gt;&gt;&gt; os.environ
environ({'VERSIONER_PYTHON_PREFER_32_BIT': 'no', 'TERM_PROGRAM_VERSION': '326', 'LOGNAME': 'michael', 'USER': 'michael', 'PATH': '/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/X11/bin:/usr/local/mysql/bin', ...})
</code></pre>
<p>要获取某个环境变量的值，可以调用os.environ.get('key')：</p>
<pre><code>&gt;&gt;&gt; os.environ.get('PATH')
'/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/X11/bin:/usr/local/mysql/bin'
&gt;&gt;&gt; os.environ.get('x', 'default')
'default'
</code></pre>
<h3 id="操作文件和目录-2">操作文件和目录</h3>
<p>操作文件和目录的函数一部分放在<strong>os模块中</strong>，一部分放在<strong>os.path模块</strong>中，这一点要注意一下。</p>
<p>查看、创建和删除目录可以这么调用：</p>
<pre><code># 查看当前目录的绝对路径:
&gt;&gt;&gt; os.path.abspath('.')
'/Users/michael'

# 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:
&gt;&gt;&gt; os.path.join('/Users/michael', 'testdir')
'/Users/michael/testdir'

# 然后创建一个目录:
&gt;&gt;&gt; os.mkdir('/Users/michael/testdir')

# 删掉一个目录:
&gt;&gt;&gt; os.rmdir('/Users/michael/testdir')
</code></pre>
<p><strong>把两个路径合成一个时，不要直接拼字符串，而要通过os.path.join()函数</strong>，这样可以<strong>正确处理不同操作系统的路径分隔符</strong>。</p>
<p>在Linux/Unix/Mac下，os.path.join()返回这样的字符串：</p>
<pre><code>part-1/part-2
</code></pre>
<p>而Windows下会返回这样的字符串：</p>
<pre><code>part-1\part-2
</code></pre>
<p>同样的道理，要<strong>拆分路径</strong>时，也不要直接去拆字符串，而要<strong>通过os.path.split()函数</strong>，这样可以把一个路径拆分为两部分，<strong>后一部分总是最后级别的目录或文件名</strong>：</p>
<pre><code>&gt;&gt;&gt; os.path.split('/Users/michael/testdir/file.txt')
('/Users/michael/testdir', 'file.txt')
</code></pre>
<p><strong>os.path.splitext()可以直接让你得到文件扩展名</strong>，很多时候非常方便：</p>
<pre><code>&gt;&gt;&gt; os.path.splitext('/path/to/file.txt')
('/path/to/file', '.txt')
</code></pre>
<p>这些合并、拆分路径的函数<strong>并不要求目录和文件要真实存在</strong>，它们<strong>只对字符串进行操作</strong>。</p>
<p>文件操作使用下面的函数。假定当前目录下有一个test.txt文件：</p>
<pre><code># 对文件重命名:
&gt;&gt;&gt; os.rename('test.txt', 'test.py')
# 删掉文件:
&gt;&gt;&gt; os.remove('test.py')
</code></pre>
<p>但是<strong>复制文件的函数居然在os模块中不存在</strong>！原因是<strong>复制文件并非由操作系统提供的系统调用</strong>。理论上讲，我们通过上一节的读写文件可以完成文件复制，只不过要多写很多代码。</p>
<p>幸运的是<strong>shutil模块提供了copyfile()的函数</strong>，你还可以在shutil模块中找到很多实用函数，它们可以看做是os模块的补充。</p>
<p>最后看看如何利用Python的特性来过滤文件。比如我们要列出当前目录下的所有目录，只需要一行代码：</p>
<pre><code>&gt;&gt;&gt; [x for x in os.listdir('.') if os.path.isdir(x)]
['.lein', '.local', '.m2', '.npm', '.ssh', '.Trash', '.vim', 'Applications', 'Desktop', ...]
</code></pre>
<p>要列出所有的.py文件，也只需一行代码：</p>
<pre><code>&gt;&gt;&gt; [x for x in os.listdir('.') if os.path.isfile(x) and os.path.splitext(x)[1]=='.py']
['apis.py', 'config.py', 'models.py', 'pymonitor.py', 'test_db.py', 'urls.py', 'wsgiapp.py']
</code></pre>
<h3 id="小结-2">小结</h3>
<p>Python的os模块封装了操作系统的目录和文件操作，要注意这些函数有的在os模块中，有的在os.path模块中。</p>
<h2 id="序列化">序列化</h2>
<p>在程序运行的过程中，所有的变量都是在内存中，比如，定义一个dict：</p>
<pre><code>d = dict(name='Bob', age=20, score=88)
</code></pre>
<p>可以随时修改变量，比如把name改成'Bill'，但是一旦程序结束，变量所占用的内存就被操作系统全部回收。如果没有把修改后的'Bill'存储到磁盘上，下次重新运行程序，变量又被初始化为'Bob'。</p>
<p>我们<strong>把变量从内存中变成可存储或传输的过程称之为序列化</strong>，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。</p>
<p><strong>序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。</strong></p>
<p>反过来，<strong>把变量内容从序列化的对象重新读到内存里称之为反序列化</strong>，即unpickling。</p>
<p>Python提供了pickle模块来实现序列化。</p>
<p>首先，我们尝试把一个对象序列化并写入文件：</p>
<pre><code>&gt;&gt;&gt; import pickle
&gt;&gt;&gt; d = dict(name='Bob', age=20, score=88)
&gt;&gt;&gt; pickle.dumps(d)
b'\x80\x03}q\x00(X\x03\x00\x00\x00ageq\x01K\x14X\x05\x00\x00\x00scoreq\x02KXX\x04\x00\x00\x00nameq\x03X\x03\x00\x00\x00Bobq\x04u.'
</code></pre>
<p><strong>pickle.dumps()方法把任意对象序列化成一个bytes</strong>，然后，就可以把这个<strong>bytes写入文件</strong>。或者用另一个方法pickle.dump()直接把对象序列化后<strong>写入一个file-like Object</strong>：</p>
<pre><code>&gt;&gt;&gt; f = open('dump.txt', 'wb')
&gt;&gt;&gt; pickle.dump(d, f)
&gt;&gt;&gt; f.close()
</code></pre>
<p>当我们要把对象从磁盘读到内存时，可以<strong>先把内容读到一个bytes</strong>，然后<strong>用pickle.loads()方法反序列化出对象</strong>，也可以<strong>直接用pickle.load()方法从一个file-like Object中直接反序列化出对象</strong>。</p>
<p>打开另一个Python命令行来反序列化刚才保存的对象：</p>
<pre><code>&gt;&gt;&gt; f = open('dump.txt', 'rb')
&gt;&gt;&gt; d = pickle.load(f)
&gt;&gt;&gt; f.close()
&gt;&gt;&gt; d
{'age': 20, 'score': 88, 'name': 'Bob'}
变量的内容又回来了！
</code></pre>
<p>当然，这个变量和原来的变量是<strong>完全不相干的对象</strong>，它们<strong>只是内容相同而已。</strong></p>
<p>Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它<strong>只能用于Python，并且可能不同版本的Python彼此都不兼容</strong>，因此，<strong>只能用Pickle保存那些不重要的数据</strong>，不能成功地反序列化也没关系。</p>
<h3 id="json">JSON</h3>
<p>如果我们要在不同的编程语言之间传递对象，就<strong>必须把对象序列化为标准格式</strong>，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。</p>
<p>JSON表示的对象就是标准的JavaScript语言的对象，JSON和Python内置的数据类型对应如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">JSON类型</th>
<th style="text-align:center">Python类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">{}</td>
<td style="text-align:center">dict</td>
</tr>
<tr>
<td style="text-align:center">[]</td>
<td style="text-align:center">list</td>
</tr>
<tr>
<td style="text-align:center">&quot;string&quot;</td>
<td style="text-align:center">str</td>
</tr>
<tr>
<td style="text-align:center">1234.56</td>
<td style="text-align:center">int或float</td>
</tr>
<tr>
<td style="text-align:center">true/false</td>
<td style="text-align:center">True/False</td>
</tr>
<tr>
<td style="text-align:center">null</td>
<td style="text-align:center">None</td>
</tr>
</tbody>
</table>
<p>Python<strong>内置的json模块</strong>提供了非常完善的Python对象到JSON格式的转换。我们先看看如何把Python对象变成一个JSON：</p>
<pre><code>&gt;&gt;&gt; import json
&gt;&gt;&gt; d = dict(name='Bob', age=20, score=88)
&gt;&gt;&gt; json.dumps(d)
'{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}'
</code></pre>
<p><strong>dumps()方法返回一个str，内容就是标准的JSON</strong>。类似的，<strong>dump()方法可以直接把JSON写入一个file-like Object</strong>。</p>
<p>要把JSON<strong>反序列化为Python对象，用loads()或者对应的load()方法</strong>，前者把<strong>JSON的字符串</strong>反序列化，后者从<strong>file-like Object中读取字符串</strong>并反序列化：</p>
<pre><code>&gt;&gt;&gt; json_str = '{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}'
&gt;&gt;&gt; json.loads(json_str)
{'age': 20, 'score': 88, 'name': 'Bob'}
</code></pre>
<p>由于JSON标准规定JSON编码是UTF-8，所以我们总是能正确地在Python的str与JSON的字符串之间转换。</p>
<h3 id="json进阶">JSON进阶</h3>
<p>Python的dict对象可以直接序列化为JSON的{}，不过，很多时候，我们更喜欢用class表示对象，比如定义Student类，然后序列化：</p>
<pre><code>import json

class Student(object):
    def __init__(self, name, age, score):
        self.name = name
        self.age = age
        self.score = score

s = Student('Bob', 20, 88)
print(json.dumps(s))
</code></pre>
<p>运行代码，毫不留情地得到一个TypeError：</p>
<pre><code>Traceback (most recent call last):
  ...
TypeError: &lt;__main__.Student object at 0x10603cc50&gt; is not JSON serializable
</code></pre>
<p>错误的原因是<strong>Student对象不是一个可序列化为JSON的对象</strong>。</p>
<p>仔细看看dumps()方法的参数列表，可以发现，除了第一个必须的obj参数外，dumps()方法还提供了一大堆的可选参数：</p>
<p>https://docs.python.org/3/library/json.html#json.dumps</p>
<p>这些<strong>可选参数就是让我们来定制JSON序列化</strong>。前面的代码之所以无法把Student类实例序列化为JSON，是因为<strong>默认情况下，dumps()方法不知道如何将Student实例变为一个JSON的{}对象</strong>。</p>
<p><strong>可选参数default就是把任意一个对象变成一个可序列为JSON的对象</strong>，我们只需要<strong>为Student专门写一个转换函数，再把函数传进去即可</strong>：</p>
<pre><code>def student2dict(std):
    return {
        'name': std.name,
        'age': std.age,
        'score': std.score
    }
</code></pre>
<p>这样，Student实例首先被student2dict()函数转换成dict，然后再被顺利序列化为JSON：</p>
<pre><code>&gt;&gt;&gt; print(json.dumps(s, default=student2dict))
{&quot;age&quot;: 20, &quot;name&quot;: &quot;Bob&quot;, &quot;score&quot;: 88}
</code></pre>
<p>不过，下次如果遇到一个Teacher类的实例，照样无法序列化为JSON。我们可以把任意class的实例变为dict：</p>
<pre><code>print(json.dumps(s, default=lambda obj: obj.__dict__))
</code></pre>
<p>因为<strong>通常class的实例都有一个dict属性</strong>，它就是一个dict，用来存储实例变量。也有<strong>少数例外，比如定义了slots的class</strong>。</p>
<p>同样的道理，如果我们要把JSON反序列化为一个Student对象实例，loads()方法首先转换出一个dict对象，然后，我们传入的object_hook函数负责把dict转换为Student实例：</p>
<pre><code>def dict2student(d):
    return Student(d['name'], d['age'], d['score'])
</code></pre>
<p>运行结果如下：</p>
<pre><code>&gt;&gt;&gt; json_str = '{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}'
&gt;&gt;&gt; print(json.loads(json_str, object_hook=dict2student))
&lt;__main__.Student object at 0x10cd3c190&gt;
</code></pre>
<p>打印出的是反序列化的Student实例对象。</p>
<h3 id="小结-3">小结</h3>
<p>Python语言特定的序列化模块是pickle，但如果要把序列化搞得更通用、更符合Web标准，就可以使用json模块。</p>
<p>json模块的dumps()和loads()函数是定义得非常好的接口的典范。当我们使用时，只需要传入一个必须的参数。但是，当默认的序列化或反序列机制不满足我们的要求时，我们又可以传入更多的参数来定制序列化或反序列化的规则，既做到了接口简单易用，又做到了充分的扩展性和灵活性。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python - 错误、调试和测试]]></title>
        <id>https://lixin-scut.github.io//post/python-cuo-wu-diao-shi-he-ce-shi</id>
        <link href="https://lixin-scut.github.io//post/python-cuo-wu-diao-shi-he-ce-shi">
        </link>
        <updated>2020-05-12T12:08:36.000Z</updated>
        <content type="html"><![CDATA[<p>在程序运行过程中，总会遇到各种各样的错误。</p>
<p>有的错误是程序编写有问题造成的，比如本来应该输出整数结果输出了字符串，这种错误我们通常称之为bug，bug是必须修复的。</p>
<p>有的错误是用户输入造成的，比如让用户输入email地址，结果得到一个空字符串，这种错误可以通过检查用户输入来做相应的处理。</p>
<p>还有一类错误是完全无法在程序运行过程中预测的，比如写入文件的时候，磁盘满了，写不进去了，或者从网络抓取数据，网络突然断掉了。这类错误也称为异常，在程序中通常是必须处理的，否则，程序会因为各种问题终止并退出。</p>
<p>Python内置了一套异常处理机制，来帮助我们进行错误处理。</p>
<p>此外，我们也需要跟踪程序的执行，查看变量的值是否正确，这个过程称为调试。Python的pdb可以让我们以单步方式执行代码。</p>
<p>最后，编写测试也很重要。有了良好的测试，就可以在程序修改后反复运行，确保程序输出符合我们编写的测试。</p>
<h2 id="错误处理">错误处理</h2>
<p>在程序运行的过程中，如果发生了错误，可以事先约定返回一个错误代码，这样，就可以知道是否有错，以及出错的原因。在操作系统提供的调用中，返回错误码非常常见。比如打开文件的函数open()，成功时返回文件描述符（就是一个整数），出错时返回-1。</p>
<p>用错误码来表示是否出错十分不便，因为函数本身应该返回的正常结果和错误码混在一起，造成调用者必须用大量的代码来判断是否出错：</p>
<pre><code>def foo():
    r = some_function()
    if r==(-1):
        return (-1)
    # do something
    return r

def bar():
    r = foo()
    if r==(-1):
        print('Error')
    else:
        pass
</code></pre>
<p>一旦出错，还要一级一级上报，直到某个函数可以处理该错误（比如，给用户输出一个错误信息）。</p>
<h3 id="tryexceptfinally">try...except...finally...</h3>
<p>所以高级语言通常都内置了一套try...except...finally...的错误处理机制，Python也不例外。</p>
<h3 id="try">try</h3>
<p>让我们用一个例子来看看try的机制：</p>
<pre><code>try:
    print('try...')
    r = 10 / 0
    print('result:', r)
except ZeroDivisionError as e:
    print('except:', e)
finally:
    print('finally...')
print('END')
</code></pre>
<p>当我们认为某些代码可能会出错时，就可以用try来运行这段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即except语句块，<strong>执行完except后，如果有finally语句块，则执行finally语句块</strong>，至此，执行完毕。</p>
<p>上面的代码在计算10 / 0时会产生一个除法运算错误：</p>
<pre><code>try...
except: division by zero
finally...
END
</code></pre>
<p>从输出可以看到，当错误发生时，后续语句print('result:', r)不会被执行，except由于捕获到ZeroDivisionError，因此被执行。最后，finally语句被执行。然后，程序继续按照流程往下走。</p>
<p>如果把除数0改成2，则执行结果如下：</p>
<pre><code>try...
result: 5
finally...
END
</code></pre>
<p>由于没有错误发生，所以except语句块不会被执行，但是finally如果有，则一定会被执行（可以没有finally语句）。</p>
<p>你还可以猜测，错误应该有很多种类，如果发生了不同类型的错误，应该由不同的except语句块处理。没错，可以<strong>有多个except来捕获不同类型的错误</strong>：</p>
<pre><code>try:
    print('try...')
    r = 10 / int('a')
    print('result:', r)
except ValueError as e:
    print('ValueError:', e)
except ZeroDivisionError as e:
    print('ZeroDivisionError:', e)
finally:
    print('finally...')
print('END')
</code></pre>
<p>int()函数可能会抛出ValueError，所以我们用一个except捕获ValueError，用另一个except捕获ZeroDivisionError。</p>
<h3 id="else">else</h3>
<p>此外，如果没有错误发生，可以<strong>在except语句块后面加一个else，当没有错误发生时，会自动执行else语句</strong>：</p>
<pre><code>try:
    print('try...')
    r = 10 / int('2')
    print('result:', r)
except ValueError as e:
    print('ValueError:', e)
except ZeroDivisionError as e:
    print('ZeroDivisionError:', e)
else:
    print('no error!')
finally:
    print('finally...')
print('END')
</code></pre>
<h3 id="错误类">错误类</h3>
<p>Python的<strong>错误其实也是class</strong>，<strong>所有的错误类型都继承自BaseException</strong>，所以在使用except时需要注意的是，它<strong>不但捕获该类型的错误，还把其子类也“一网打尽”</strong>。比如：</p>
<pre><code>try:
    foo()
except ValueError as e:
    print('ValueError')
except UnicodeError as e:
    print('UnicodeError')
</code></pre>
<p>第二个except<strong>永远也捕获不到UnicodeError</strong>，<strong>因为UnicodeError是ValueError的子类，如果有，也被第一个except给捕获了</strong>。</p>
<p><strong>Python所有的错误都是从BaseException类派生</strong>的，常见的错误类型和继承关系看这里：</p>
<p><a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy">错误类型和继承关系</a></p>
<h3 id="跨越多层调用">跨越多层调用</h3>
<p>使用try...except捕获错误还有一个巨大的好处，就是可以<strong>跨越多层调用</strong>，比如函数main()调用bar()，bar()调用foo()，结果foo()出错了，这时，<strong>只要main()捕获到了，就可以处理</strong>：</p>
<pre><code>def foo(s):
    return 10 / int(s)

def bar(s):
    return foo(s) * 2

def main():
    try:
        bar('0')
    except Exception as e:
        print('Error:', e)
    finally:
        print('finally...')
</code></pre>
<p>也就是说，<strong>不需要在每个可能出错的地方去捕获错误，只要在合适的层次去捕获错误就可以了</strong>。这样一来，就大大减少了写try...except...finally的麻烦。</p>
<h3 id="调用栈">调用栈</h3>
<p><strong>如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出</strong>。</p>
<p>来看看err.py：</p>
<pre><code># err.py:
def foo(s):
    return 10 / int(s)

def bar(s):
    return foo(s) * 2

def main():
    bar('0')

main()
</code></pre>
<p>执行，结果如下：</p>
<pre><code>$ python3 err.py
Traceback (most recent call last):
  File &quot;err.py&quot;, line 11, in &lt;module&gt;
    main()
  File &quot;err.py&quot;, line 9, in main
    bar('0')
  File &quot;err.py&quot;, line 6, in bar
    return foo(s) * 2
  File &quot;err.py&quot;, line 3, in foo
    return 10 / int(s)
ZeroDivisionError: division by zero
</code></pre>
<p>解读错误信息是定位错误的关键。我们从上往下可以看到整个错误的调用函数链：</p>
<p>错误信息第1行：</p>
<pre><code>Traceback (most recent call last):
</code></pre>
<p>告诉我们这是错误的跟踪信息。</p>
<p>第2~3行：</p>
<pre><code>  File &quot;err.py&quot;, line 11, in &lt;module&gt;
    main()
</code></pre>
<p>调用main()出错了，在代码文件err.py的第11行代码，但原因是第9行：</p>
<pre><code>  File &quot;err.py&quot;, line 9, in main
    bar('0')
</code></pre>
<p>调用bar('0')出错了，在代码文件err.py的第9行代码，但原因是第6行：</p>
<pre><code>  File &quot;err.py&quot;, line 6, in bar
    return foo(s) * 2
</code></pre>
<p>原因是return foo(s) * 2这个语句出错了，但这还不是最终原因，继续往下看：</p>
<pre><code>File &quot;err.py&quot;, line 3, in foo
   return 10 / int(s)
</code></pre>
<p>原因是return 10 / int(s)这个语句出错了，这是错误产生的源头，因为下面打印了：</p>
<pre><code>ZeroDivisionError: integer division or modulo by zero
</code></pre>
<p>根据错误类型ZeroDivisionError，我们判断，int(s)本身并没有出错，但是int(s)返回0，在计算10 / 0时出错，至此，找到错误源头。</p>
<p>出错的时候，一定要分析错误的调用栈信息，才能定位错误的位置。</p>
<h3 id="记录错误logging">记录错误logging</h3>
<p>如果不捕获错误，自然可以让Python解释器来打印出错误堆栈，但程序也被结束了。既然我们能捕获错误，就可以<strong>把错误堆栈打印出来，然后分析错误原因，同时，让程序继续执行下去</strong>。</p>
<p>Python内置的logging模块可以非常容易地记录错误信息：</p>
<pre><code>
# err_logging.py

import logging

def foo(s):
    return 10 / int(s)

def bar(s):
    return foo(s) * 2

def main():
    try:
        bar('0')
    except Exception as e:
        logging.exception(e)

main()
print('END')

</code></pre>
<p>同样是出错，但<strong>程序打印完错误信息后会继续执行，并正常退出</strong>：</p>
<pre><code>$ python3 err_logging.py
ERROR:root:division by zero
Traceback (most recent call last):
  File &quot;err_logging.py&quot;, line 13, in main
    bar('0')
  File &quot;err_logging.py&quot;, line 9, in bar
    return foo(s) * 2
  File &quot;err_logging.py&quot;, line 6, in foo
    return 10 / int(s)
ZeroDivisionError: division by zero
END
</code></pre>
<p><strong>通过配置，logging还可以把错误记录到日志文件里，方便事后排查。</strong></p>
<h3 id="抛出错误">抛出错误</h3>
<p>因为错误是class，捕获一个错误就是捕获到该class的一个实例。因此，<strong>错误并不是凭空产生的，而是有意创建并抛出的</strong>。Python的内置函数会抛出很多类型的错误，我们自己编写的函数也可以抛出错误。</p>
<p>如果要抛出错误，首先根据需要，<strong>可以定义一个错误的class，选择好继承关系</strong>，然后，用<strong>raise语句抛出一个错误的实例</strong>：</p>
<pre><code>
# err_raise.py
class FooError(ValueError):
    pass

def foo(s):
    n = int(s)
    if n==0:
        raise FooError('invalid value: %s' % s)
    return 10 / n

foo('0')
</code></pre>
<p>执行，可以最后跟踪到我们自己定义的错误：</p>
<pre><code>$ python3 err_raise.py 
Traceback (most recent call last):
  File &quot;err_throw.py&quot;, line 11, in &lt;module&gt;
    foo('0')
  File &quot;err_throw.py&quot;, line 8, in foo
    raise FooError('invalid value: %s' % s)
__main__.FooError: invalid value: 0

</code></pre>
<p><strong>只有在必要的时候才定义我们自己的错误类型。如果可以选择Python已有的内置的错误类型（比如ValueError，TypeError），尽量使用Python内置的错误类型。</strong></p>
<p>最后，我们来看另一种错误处理的方式：</p>
<pre><code>
# err_reraise.py

def foo(s):
    n = int(s)
    if n==0:
        raise ValueError('invalid value: %s' % s)
    return 10 / n

def bar():
    try:
        foo('0')
    except ValueError as e:
        print('ValueError!')
        raise

bar()

</code></pre>
<p>在bar()函数中，我们明明已经捕获了错误，但是，<strong>打印一个ValueError!后，又把错误通过raise语句抛出去了</strong></p>
<p>其实这种错误处理方式相当常见。捕获错误目的只是记录一下，便于后续追踪。但是，<strong>由于当前函数不知道应该怎么处理该错误</strong>，所以，<strong>最恰当的方式是继续往上抛，让顶层调用者去处理</strong>。好比一个员工处理不了一个问题时，就把问题抛给他的老板，如果他的老板也处理不了，就一直往上抛，最终会抛给CEO去处理。</p>
<p><strong>raise语句如果不带参数，就会把当前错误原样抛出</strong>。</p>
<p>此外，<strong>在except中raise一个Error，还可以把一种类型的错误转化成另一种类型</strong>：</p>
<pre><code>try:
    10 / 0
except ZeroDivisionError:
    raise ValueError('input error!')
</code></pre>
<p>只要是<strong>合理的转换逻辑</strong>就可以，但是，<strong>决不应该把一个IOError转换成毫不相干的ValueError</strong>。</p>
<h3 id="小结">小结</h3>
<p>Python内置的try...except...finally用来处理错误十分方便。出错时，会分析错误信息并定位错误发生的代码位置才是最关键的。</p>
<p>程序也可以主动抛出错误，让调用者来处理相应的错误。但是，<strong>应该在文档中写清楚可能会抛出哪些错误，以及错误产生的原因</strong>。</p>
<p><strong>个人代码练习</strong><br>
运行下面的代码，根据异常信息进行分析，定位出错误源头，并修复：</p>
<pre><code>
# -*- coding: utf-8 -*-
from functools import reduce

def str2num(s):
    # return int(s)
    try:
        return int(s)
    except ValueError:
        return float(s)

def calc(exp):
    ss = exp.split('+')
    ns = map(str2num, ss)
    return reduce(lambda acc, x: acc + x, ns)

def main():
    r = calc('100 + 200 + 345')
    print('100 + 200 + 345 =', r)
    r = calc('99 + 88 + 7.6')
    print('99 + 88 + 7.6 =', r)

main()

</code></pre>
<h2 id="调试">调试</h2>
<p>程序能一次写完并正常运行的概率很小，总会有各种各样的bug需要修正。有的bug很简单，看看错误信息就知道，有的bug很复杂，我们需要知道出错时，哪些变量的值是正确的，哪些变量的值是错误的，因此，需要<strong>一整套调试程序的手段来修复bug</strong>。</p>
<h3 id="打印变量">打印变量</h3>
<p>第一种方法简单直接粗暴有效，就是用print()把可能有问题的变量打印出来看看：</p>
<pre><code>def foo(s):
    n = int(s)
    print('&gt;&gt;&gt; n = %d' % n)
    return 10 / n

def main():
    foo('0')

main()
</code></pre>
<p>执行后在输出中查找打印的变量值：</p>
<pre><code>$ python err.py
&gt;&gt;&gt; n = 0
Traceback (most recent call last):
  ...
ZeroDivisionError: integer division or modulo by zero
</code></pre>
<p><strong>用print()最大的坏处是将来还得删掉它</strong>，想想程序里到处都是print()，运行结果也会包含很多垃圾信息。所以，我们又有第二种方法。</p>
<h3 id="断言">断言</h3>
<p><strong>凡是用print()来辅助查看的地方，都可以用断言（assert）来替代</strong>：</p>
<pre><code>def foo(s):
    n = int(s)
    assert n != 0, 'n is zero!'
    return 10 / n

def main():
    foo('0')
</code></pre>
<p><strong>assert的意思是，表达式n != 0应该是True，否则，根据程序运行的逻辑，后面的代码肯定会出错</strong>。</p>
<p><strong>如果断言失败，assert语句本身就会抛出AssertionError</strong>：</p>
<pre><code>$ python err.py
Traceback (most recent call last):
  ...
AssertionError: n is zero!
</code></pre>
<p>程序中如果到处充斥着assert，和print()相比也好不到哪去。<br>
不过，启<strong>动Python解释器时可以用-O参数来关闭assert</strong>：</p>
<pre><code>$ python -O err.py
Traceback (most recent call last):
  ...
ZeroDivisionError: division by zero
</code></pre>
<p><strong>注意：断言的开关“-O”是英文大写字母O，不是数字0。</strong><br>
<strong>关闭后，你可以把所有的assert语句当成pass来看</strong>。</p>
<h3 id="logging">logging</h3>
<p>把print()替换为logging是第3种方式，和assert比，<strong>logging不会抛出错误，而且可以输出到文件</strong>：</p>
<pre><code>import logging

s = '0'
n = int(s)
logging.info('n = %d' % n)
print(10 / n)
</code></pre>
<p>logging.info()就可以输出一段文本。运行，发现除了ZeroDivisionError，没有任何输出信息。</p>
<p>然后再在import logging之后添加一行配置再试试：</p>
<pre><code>import logging
logging.basicConfig(level=logging.INFO)
</code></pre>
<p>可以看到输出了：</p>
<pre><code>$ python err.py
INFO:root:n = 0
Traceback (most recent call last):
  File &quot;err.py&quot;, line 8, in &lt;module&gt;
    print(10 / n)
ZeroDivisionError: division by zero
</code></pre>
<p><strong>信息级别</strong><br>
这就是logging的好处，它<strong>允许你指定记录信息的级别，有debug，info，warning，error等几个级别</strong>，<strong>当我们指定level=INFO时，logging.debug就不起作用了。同理，指定level=WARNING后，debug和info就不起作用了</strong>。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。</p>
<p>logging的另一个好处是通过简单的配置，<strong>一条语句可以同时输出到不同的地方</strong>，比如console和文件。</p>
<h3 id="pdb">pdb</h3>
<p>第4种方式是启动Python的<strong>调试器pdb</strong>，<strong>让程序以单步方式运行，可以随时查看运行状态</strong>。</p>
<p>准备好程序：</p>
<pre><code># err.py
s = '0'
n = int(s)
print(10 / n)
</code></pre>
<p>然后启动：</p>
<pre><code>$ python -m pdb err.py
&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(2)&lt;module&gt;()
-&gt; s = '0'
</code></pre>
<p>以<strong>参数-m pdb</strong>启动后，pdb定位到下一步要执行的代码-&gt; s = '0'。</p>
<p><strong>输入命令l来查看代码</strong>：</p>
<pre><code>(Pdb) l
  1     # err.py
  2  -&gt; s = '0'
  3     n = int(s)
  4     print(10 / n)
</code></pre>
<p><strong>输入命令n可以单步执行代码</strong>：</p>
<pre><code>(Pdb) n
&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(3)&lt;module&gt;()
-&gt; n = int(s)
(Pdb) n
&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(4)&lt;module&gt;()
-&gt; print(10 / n)
</code></pre>
<p>任何时候都可以<strong>输入命令p 变量名来查看变量</strong>：</p>
<pre><code>(Pdb) p s
'0'
(Pdb) p n
0
</code></pre>
<p><strong>输入命令q结束调试</strong>，退出程序：</p>
<pre><code>(Pdb) q
</code></pre>
<p>这种通过pdb在命令行调试的方法理论上是万能的，但实在是太麻烦了，如果有一千行代码，要运行到第999行得敲许多重复命令命令啊。还好，我们还有另一种调试方法。</p>
<h3 id="断点-pdbset_trace">断点 pdb.set_trace()</h3>
<p>这个方法也是用pdb，但是不需要单步执行，我们<strong>只需要import pdb</strong>，然后，<strong>在可能出错的地方放一个pdb.set_trace()</strong>，就可以设置一个断点：</p>
<pre><code># err.py
import pdb

s = '0'
n = int(s)
pdb.set_trace() # 运行到这里会自动暂停
print(10 / n)
</code></pre>
<p>运行代码，<strong>程序会自动在pdb.set_trace()暂停并进入pdb调试环境</strong>，可以用命令p查看变量，或者<strong>用命令c继续运行</strong>：</p>
<pre><code>$ python err.py 
&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(7)&lt;module&gt;()
-&gt; print(10 / n)
(Pdb) p n
0
(Pdb) c
Traceback (most recent call last):
  File &quot;err.py&quot;, line 7, in &lt;module&gt;
    print(10 / n)
ZeroDivisionError: division by zero
</code></pre>
<p>这个方式比直接启动pdb单步调试效率要高很多，但也高不到哪去。</p>
<h3 id="ide">IDE</h3>
<p>如果要比较快捷地设置断点、单步执行，就需要一个支持调试功能的IDE。目前比较好的Python IDE有：</p>
<p><a href="https://code.visualstudio.com/">Visual Studio Code</a> 注意需要安装Python插件。</p>
<p><a href="http://www.jetbrains.com/pycharm/">PyCharm</a></p>
<p>另外，Eclipse加上pydev插件也可以调试Python程序。</p>
<p>虽然用IDE调试起来比较方便，但是最后你会发现，logging才是终极武器。</p>
<h2 id="单元测试">单元测试</h2>
<p>如果你听说过“测试驱动开发”（TDD：Test-Driven Development），单元测试就不陌生。</p>
<p><strong>单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作</strong>。</p>
<p>比如对函数abs()，我们可以编写出以下几个测试用例：</p>
<p>输入正数，比如1、1.2、0.99，期待返回值与输入相同；</p>
<p>输入负数，比如-1、-1.2、-0.99，期待返回值与输入相反；</p>
<p>输入0，期待返回0；</p>
<p>输入非数值类型，比如None、[]、{}，期待抛出TypeError。</p>
<p>把上面的测试用例放到一个测试模块里，就是一个完整的单元测试。</p>
<p>如果单元测试通过，说明我们测试的这个函数能够正常工作。如果单元测试不通过，要么函数有bug，要么测试条件输入不正确，总之，需要修复使单元测试能够通过。</p>
<p>单元测试通过后有什么意义呢？如果我们对abs()函数代码做了修改，只需要再跑一遍单元测试，如果通过，说明我们的修改不会对abs()函数原有的行为造成影响，如果测试不通过，说明我们的修改与原有行为不一致，要么修改代码，要么修改测试。</p>
<p>这种以测试为驱动的开发模式最大的好处就是<strong>确保一个程序模块的行为符合我们设计的测试用例</strong>。在将来修改的时候，可以极大程度地保证该模块行为仍然是正确的。</p>
<p>编写一个Dict类，这个类的行为和dict一致，但是可以通过属性来访问，用起来就像下面这样：</p>
<pre><code>&gt;&gt;&gt; d = Dict(a=1, b=2)
&gt;&gt;&gt; d['a']
1
&gt;&gt;&gt; d.a
1
</code></pre>
<p>mydict.py代码如下：</p>
<pre><code>class Dict(dict):

    def __init__(self, **kw):
        super().__init__(**kw)

    def __getattr__(self, key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(r&quot;'Dict' object has no attribute '%s'&quot; % key)

    def __setattr__(self, key, value):
        self[key] = value
</code></pre>
<h3 id="unittest模块">unittest模块</h3>
<p>为了编写单元测试，我们需要引入Python自带的unittest模块，编写mydict_test.py如下：</p>
<pre><code>import unittest

from mydict import Dict

class TestDict(unittest.TestCase):

    def test_init(self):
        d = Dict(a=1, b='test')
        self.assertEqual(d.a, 1)
        self.assertEqual(d.b, 'test')
        self.assertTrue(isinstance(d, dict))

    def test_key(self):
        d = Dict()
        d['key'] = 'value'
        self.assertEqual(d.key, 'value')

    def test_attr(self):
        d = Dict()
        d.key = 'value'
        self.assertTrue('key' in d)
        self.assertEqual(d['key'], 'value')

    def test_keyerror(self):
        d = Dict()
        with self.assertRaises(KeyError):
            value = d['empty']

    def test_attrerror(self):
        d = Dict()
        with self.assertRaises(AttributeError):
            value = d.empty
</code></pre>
<p>编写单元测试时，我们<strong>需要编写一个测试类，从unittest.TestCase继承</strong>。</p>
<p><strong>以test开头的方法就是测试方法，不以test开头的方法不被认为是测试方法，测试的时候不会被执行。</strong></p>
<p>对每一类测试都需要编写一个test_xxx()方法。由于<strong>unittest.TestCase提供了很多内置的条件判断</strong>，我们只需要调用这些方法就可以断言输出是否是我们所期望的。<strong>最常用的断言就是assertEqual()</strong>：</p>
<pre><code>self.assertEqual(abs(-1), 1) # 断言函数返回的结果与1相等
</code></pre>
<p>另一种重要的断言就是assertRaises，期待抛出指定类型的Error，比如通过d['empty']访问不存在的key时，断言会抛出KeyError：</p>
<pre><code>with self.assertRaises(KeyError):
    value = d['empty']
</code></pre>
<p>而通过d.empty访问不存在的key时，我们期待抛出AttributeError：</p>
<pre><code>with self.assertRaises(AttributeError):
    value = d.empty
</code></pre>
<h3 id="运行单元测试">运行单元测试</h3>
<p>一旦编写好单元测试，我们就可以运行单元测试。最简单的运行方式是在<code>mydict_test.py</code>的最后加上两行代码：</p>
<pre><code>if __name__ == '__main__':
    unittest.main()
</code></pre>
<p>这样就可以把<code>mydict_test.py</code>当做正常的python脚本运行：</p>
<pre><code>$ python mydict_test.py
</code></pre>
<p>另一种方法是在命令行通过参数<code>-m unittest</code>直接运行单元测试：</p>
<pre><code>$ python -m unittest mydict_test
.....
----------------------------------------------------------------------
Ran 5 tests in 0.000s

OK
</code></pre>
<p>这是推荐的做法，因为这样<strong>可以一次批量运行很多单元测试</strong>，并且，<strong>有很多工具可以自动来运行这些单元测试</strong>。</p>
<h3 id="setup与teardown">setUp与tearDown</h3>
<p>可以在单元测试中编写两个特殊的setUp()和tearDown()方法。这两个方法会分别<strong>在每调用一个测试方法的前后</strong>分别被执行。</p>
<p>设想你的测试需要启动一个数据库，这时，<strong>就可以在setUp()方法中连接数据库，在tearDown()方法中关闭数据库</strong>，这样，不必在每个测试方法中重复相同的代码：</p>
<pre><code>class TestDict(unittest.TestCase):

    def setUp(self):
        print('setUp...')

    def tearDown(self):
        print('tearDown...')
</code></pre>
<p>再次运行测试看看每个测试方法调用前后是否会打印出setUp...和tearDown...。</p>
<p><strong>个人练习代码</strong><br>
对Student类编写单元测试，结果发现测试不通过，请修改Student类，让测试通过：</p>
<pre><code># -*- coding: utf-8 -*-
import unittest

class Student(object):
    def __init__(self, name, score):
        self.name = name
        self.score = score
    def get_grade(self):
        if self.score &lt; 0 or self.score &gt; 100:
            raise ValueError
        if self.score &gt;= 80:
            return 'A'
        if self.score &gt;= 60:
            return 'B'
        return 'C'
				
		class TestStudent(unittest.TestCase):

    def test_80_to_100(self):
        s1 = Student('Bart', 80)
        s2 = Student('Lisa', 100)
        self.assertEqual(s1.get_grade(), 'A')
        self.assertEqual(s2.get_grade(), 'A')

    def test_60_to_80(self):
        s1 = Student('Bart', 60)
        s2 = Student('Lisa', 79)
        self.assertEqual(s1.get_grade(), 'B')
        self.assertEqual(s2.get_grade(), 'B')

    def test_0_to_60(self):
        s1 = Student('Bart', 0)
        s2 = Student('Lisa', 59)
        self.assertEqual(s1.get_grade(), 'C')
        self.assertEqual(s2.get_grade(), 'C')

    def test_invalid(self):
        s1 = Student('Bart', -1)
        s2 = Student('Lisa', 101)
        with self.assertRaises(ValueError):
            s1.get_grade()
        with self.assertRaises(ValueError):
            s2.get_grade()

if __name__ == '__main__':
    unittest.main()
</code></pre>
<h2 id="文档测试">文档测试</h2>
<p>如果你经常阅读Python的官方文档，可以看到很多文档都有示例代码。比如re模块就带了很多示例代码：</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; m = re.search('(?&lt;=abc)def', 'abcdef')
&gt;&gt;&gt; m.group(0)
'def'
</code></pre>
<p>可以把这些示例代码在Python的交互式环境下输入并执行，结果与文档中的示例代码显示的一致。</p>
<p>这些代码与其他说明可以写在注释中，然后，由一些工具来自动生成文档。既然这些代码本身就可以粘贴出来直接运行，那么，可不可以自动执行写在注释中的这些代码呢？</p>
<p>答案是肯定的。</p>
<p>当我们编写注释时，如果写上这样的注释：</p>
<pre><code>def abs(n):
    '''
    Function to get absolute value of number.
    
    Example:
    
    &gt;&gt;&gt; abs(1)
    1
    &gt;&gt;&gt; abs(-1)
    1
    &gt;&gt;&gt; abs(0)
    0
    '''
    return n if n &gt;= 0 else (-n)
</code></pre>
<p>无疑更明确地告诉函数的调用者该函数的期望输入和输出。</p>
<p><strong>Python内置的“文档测试”（doctest）模块可以直接提取注释中的代码并执行测试</strong>。</p>
<p>doctest严格按照Python交互式命令行的输入和输出来判断测试结果是否正确。只有测试异常的时候，可以用...表示中间一大段烦人的输出。</p>
<p>让我们用doctest来测试上次编写的Dict类：</p>
<pre><code># mydict2.py
class Dict(dict):
    # 注意在class内部
    '''
    Simple dict but also support access as x.y style.

    &gt;&gt;&gt; d1 = Dict()
    &gt;&gt;&gt; d1['x'] = 100
    &gt;&gt;&gt; d1.x
    100
    &gt;&gt;&gt; d1.y = 200
    &gt;&gt;&gt; d1['y']
    200
    &gt;&gt;&gt; d2 = Dict(a=1, b=2, c='3')
    &gt;&gt;&gt; d2.c
    '3'
    &gt;&gt;&gt; d2['empty']
    Traceback (most recent call last):
        ...
    KeyError: 'empty'
    &gt;&gt;&gt; d2.empty
    Traceback (most recent call last):
        ...
    AttributeError: 'Dict' object has no attribute 'empty'
    '''
    def __init__(self, **kw):
        super(Dict, self).__init__(**kw)

    def __getattr__(self, key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(r&quot;'Dict' object has no attribute '%s'&quot; % key)

    def __setattr__(self, key, value):
        self[key] = value

if __name__=='__main__':
    import doctest
    doctest.testmod()
</code></pre>
<p>运行<code>python mydict2.py</code>：</p>
<pre><code>$ python mydict2.py
</code></pre>
<p>什么输出也没有。<strong>这说明我们编写的doctest运行都是正确的。如果程序有问题，比如把getattr()方法注释掉，再运行就会报错</strong>：</p>
<pre><code>$ python mydict2.py
**********************************************************************
File &quot;/Users/michael/Github/learn-python3/samples/debug/mydict2.py&quot;, line 10, in __main__.Dict
Failed example:
    d1.x
Exception raised:
    Traceback (most recent call last):
      ...
    AttributeError: 'Dict' object has no attribute 'x'
**********************************************************************
File &quot;/Users/michael/Github/learn-python3/samples/debug/mydict2.py&quot;, line 16, in __main__.Dict
Failed example:
    d2.c
Exception raised:
    Traceback (most recent call last):
      ...
    AttributeError: 'Dict' object has no attribute 'c'
**********************************************************************
1 items had failures:
   2 of   9 in __main__.Dict
***Test Failed*** 2 failures.
</code></pre>
<p><strong>注意到最后3行代码。当模块正常导入时，doctest不会被执行。只有在命令行直接运行时，才执行doctest。所以，不必担心doctest会在非测试环境下执行。</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git - 自定义Git]]></title>
        <id>https://lixin-scut.github.io//post/git-zi-ding-yi-git</id>
        <link href="https://lixin-scut.github.io//post/git-zi-ding-yi-git">
        </link>
        <updated>2020-05-12T07:39:26.000Z</updated>
        <content type="html"><![CDATA[<p>在安装Git一节中，我们已经配置了user.name和user.email，实际上，Git还有很多可配置项。</p>
<p>比如，让Git显示颜色，会让命令输出看起来更醒目：</p>
<pre><code>$ git config --global color.ui true
</code></pre>
<p>这样，Git会适当地显示不同的颜色，比如git status命令中会根据不同的状态给文件名标上不同颜色。</p>
<h2 id="忽略特殊文件">忽略特殊文件</h2>
<p>有些时候，必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件、文件夹自动生成的隐藏文件等等，每次git status都会显示Untracked files 等</p>
<h3 id="gitignore文件">.gitignore文件</h3>
<p>在Git工作区的根目录下创建一个<strong>特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件</strong>。</p>
<p>不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：<a href="https://github.com/github/gitignore">配置文件</a></p>
<p>忽略文件的原则是：</p>
<ol>
<li>忽略<strong>操作系统自动生成的文件</strong>，比如缩略图等；</li>
<li>忽略<strong>编译生成的中间文件、可执行文件</strong>等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；</li>
<li>忽略你自己的<strong>带有敏感信息的配置文件</strong>，比如存放口令的配置文件。<br>
举个例子：</li>
</ol>
<p>假设你在Windows下进行Python开发，Windows会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有Desktop.ini文件，因此你需要忽略Windows自动生成的垃圾文件：</p>
<pre><code># Windows:
Thumbs.db
ehthumbs.db
Desktop.ini
</code></pre>
<p>然后，继续忽略Python编译产生的.pyc、.pyo、dist等文件或目录：</p>
<pre><code># Python:
*.py[cod]
*.so
*.egg
*.egg-info
dist
build
</code></pre>
<p>加上你自己定义的文件，最终得到一个完整的.gitignore文件，内容如下：</p>
<pre><code># Windows:
Thumbs.db
ehthumbs.db
Desktop.ini

# Python:
*.py[cod]
*.so
*.egg
*.egg-info
dist
build

# My configurations:
db.ini
deploy_key_rsa
</code></pre>
<p>最后一步就是把.gitignore也提交到Git，就完成了！当然<strong>检验.gitignore的标准是git status命令是不是说working directory clean</strong>。</p>
<p>使用Windows的注意：如果你在资源管理器里新建一个.gitignore文件，它会提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为.gitignore了。</p>
<h3 id="强制添加git-add-f">强制添加git add -f</h3>
<p>有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个<strong>文件被.gitignore忽略了</strong>：</p>
<pre><code>$ git add App.class
The following paths are ignored by one of your .gitignore files:
App.class
Use -f if you really want to add them.
</code></pre>
<p>如果你确实想添加该文件，<strong>可以用-f强制添加到Git</strong>：</p>
<pre><code>$ git add -f App.class
</code></pre>
<h3 id="git-check-ignore命令检查">git check-ignore命令检查</h3>
<p>或者你发现，可能是.gitignore写得有问题，需要找出来到底哪个规则写错了，可以用<strong>git check-ignore命令检查</strong>：</p>
<pre><code>$ git check-ignore -v App.class
.gitignore:3:*.class	App.class
</code></pre>
<p><strong>Git会告诉我们，.gitignore的第3行规则忽略了该文件，于是我们就可以知道应该修订哪个规则</strong>。</p>
<h3 id="小结">小结</h3>
<p>忽略某些文件时，需要编写.gitignore；</p>
<p>.gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理</p>
<h3 id="配置别名">配置别名</h3>
<p>有没有经常敲错命令？比如git status？status这个单词真心不好记。</p>
<p>如果敲git st就表示git status那就简单多了，当然这种偷懒的办法我们是极力赞成的。</p>
<p>我们只需要敲一行命令，告诉Git，以后st就表示status：</p>
<pre><code>$ git config --global alias.st status
</code></pre>
<p>好了，现在敲git st看看效果。</p>
<p>当然还有别的命令可以简写，很多人都用co表示checkout，ci表示commit，br表示branch：</p>
<pre><code>$ git config --global alias.co checkout
$ git config --global alias.ci commit
$ git config --global alias.br branch
</code></pre>
<p>以后提交就可以简写成：</p>
<pre><code>$ git ci -m &quot;bala bala bala...&quot;
</code></pre>
<p><strong>--global参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。</strong></p>
<p>在撤销修改一节中，我们知道，命令<code>git reset HEAD file</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个unstage操作，就可以配置一个unstage别名：</p>
<pre><code>$ git config --global alias.unstage 'reset HEAD'
</code></pre>
<p>当你敲入命令：</p>
<pre><code>$ git unstage test.py
</code></pre>
<p>实际上Git执行的是：</p>
<pre><code>$ git reset HEAD test.py
</code></pre>
<p>配置一个git last，让其显示最后一次提交信息：</p>
<pre><code>$ git config --global alias.last 'log -1'
</code></pre>
<p>这样，用git last就能显示最近一次的提交：</p>
<pre><code>$ git last
commit adca45d317e6d8a4b23f9811c3d7b7f0f180bfe2
Merge: bd6ae48 291bea8
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Thu Aug 22 22:49:22 2013 +0800

    merge &amp; fix hello.py
</code></pre>
<p>加入颜色和参数等</p>
<pre><code>git config --global alias.lg &quot;log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit&quot;
</code></pre>
<h3 id="配置文件">配置文件</h3>
<p>配置Git的时候，<strong>加上--global是针对当前用户起作用</strong>的，如果<strong>不加，那只针对当前的仓库起作用</strong>。</p>
<p><strong>每个仓库的Git配置文件都放在<code>.git/config</code>文件中：</strong></p>
<pre><code>$ cat .git/config 
[core]
    repositoryformatversion = 0
    filemode = true
    bare = false
    logallrefupdates = true
    ignorecase = true
    precomposeunicode = true
[remote &quot;origin&quot;]
    url = git@github.com:michaelliao/learngit.git
    fetch = +refs/heads/*:refs/remotes/origin/*
[branch &quot;master&quot;]
    remote = origin
    merge = refs/heads/master
[alias]
    last = log -1
</code></pre>
<p>别名就在<code>[alias]</code>后面，要删除别名，直接把对应的行删掉即可。</p>
<p>而当前用户的Git配置文件放在<strong>用户主目录下的一个隐藏文件<code>.gitconfig</code>中</strong>：</p>
<pre><code>$ cat .gitconfig
[alias]
    co = checkout
    ci = commit
    br = branch
    st = status
[user]
    name = Your Name
    email = your@email.com
</code></pre>
<p>配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。</p>
<h2 id="搭建git服务器">搭建Git服务器</h2>
<p>在远程仓库一节中，我们讲了远程仓库实际上和本地仓库没啥不同，纯粹为了7x24小时开机并交换大家的修改。</p>
<p>GitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。</p>
<p>搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的apt命令就可以完成安装。</p>
<p>假设你已经有sudo权限的用户账号，下面，正式开始安装。</p>
<p>第一步，安装git：</p>
<pre><code>$ sudo apt-get install git
</code></pre>
<p>第二步，创建一个git用户，用来运行git服务：</p>
<pre><code>$ sudo adduser git
</code></pre>
<p>第三步，创建证书登录：</p>
<p>收集所有需要登录的用户的公钥，就是他们自己的<code>id_rsa.pub</code>文件，把所有公钥导入到<code>/home/git/.ssh/authorized_keys</code>文件里，一行一个。</p>
<p>第四步，初始化Git仓库：</p>
<p>先选定一个目录作为Git仓库，假定是<code>/srv/sample.git</code>，在<code>/srv</code>目录下输入命令：</p>
<pre><code>$ sudo git init --bare sample.git
</code></pre>
<p>Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git：</p>
<pre><code>$ sudo chown -R git:git sample.git
</code></pre>
<p>第五步，禁用shell登录：</p>
<p>出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：</p>
<pre><code>git:x:1001:1001:,,,:/home/git:/bin/bash
</code></pre>
<p>改为：</p>
<pre><code>git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell
</code></pre>
<p>这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。</p>
<p>第六步，克隆远程仓库：</p>
<p>现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行：</p>
<pre><code>$ git clone git@server:/srv/sample.git
Cloning into 'sample'...
warning: You appear to have cloned an empty repository.
</code></pre>
<p>剩下的推送就简单了。</p>
<h2 id="管理公钥">管理公钥</h2>
<p>如果团队很小，把每个人的公钥收集起来放到服务器的<code>/home/git/.ssh/authorized_keys</code>文件里就是可行的。</p>
<h3 id="管理权限">管理权限</h3>
<p>版本控制系统里可以设置一套完善的权限控制，每个人是否有读写权限会精确到每个分支甚至每个目录下。因为Git是为Linux源代码托管而开发的，所以Git也继承了开源社区的精神，不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。Gitolite就是这个工具。</p>
<h3 id="小结-2">小结</h3>
<p>搭建Git服务器非常简单，通常10分钟即可完成；</p>
<p>要方便管理公钥，用Gitosis；</p>
<p>要像SVN那样控制权限，用Gitolite。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Git - 远程代码仓库、代码托管网站]]></title>
        <id>https://lixin-scut.github.io//post/git-yuan-cheng-dai-ma-cang-ku-dai-ma-tuo-guan-wang-zhan</id>
        <link href="https://lixin-scut.github.io//post/git-yuan-cheng-dai-ma-cang-ku-dai-ma-tuo-guan-wang-zhan">
        </link>
        <updated>2020-05-12T02:56:37.000Z</updated>
        <content type="html"><![CDATA[<h2 id="github">GitHub</h2>
<p>我们一直用GitHub作为免费的远程仓库，如果是个人的开源项目，放到GitHub上是完全没有问题的。其实GitHub还是一个开源协作社区，通过GitHub，既可以让别人参与你的开源项目，也可以参与别人的开源项目。</p>
<p>在GitHub出现以前，开源项目开源容易，但让广大人民群众参与进来比较困难，因为要参与，就要提交代码，而给每个想提交代码的群众都开一个账号那是不现实的，因此，群众也仅限于报个bug，即使能改掉bug，也只能把diff文件用邮件发过去，很不方便。</p>
<p>但是在GitHub上，<strong>利用Git极其强大的克隆和分支功能</strong>，广大人民群众真正可以第一次自由参与各种开源项目了。</p>
<p>如何参与一个开源项目呢？比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，你可以访问它的<a href="https://github.com/twbs/bootstrap">项目主页</a>，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：</p>
<pre><code>git clone git@github.com:michaelliao/bootstrap.git
</code></pre>
<p>一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址git@github.com:twbs/bootstrap.git克隆，因为没有权限，你将不能推送修改。</p>
<p>Bootstrap的官方仓库twbs/bootstrap、你在GitHub上克隆的仓库my/bootstrap，以及你自己克隆到本地电脑的仓库，他们的关系就像下图显示的那样：</p>
<pre><code>
┌─ GitHub ────────────────────────────────────┐
│                                             │
│ ┌─────────────────┐     ┌─────────────────┐ │
│ │ twbs/bootstrap  │────&gt;│  my/bootstrap   │ │
│ └─────────────────┘     └─────────────────┘ │
│                                  ▲          │
└──────────────────────────────────┼──────────┘
                                   ▼
                          ┌─────────────────┐
                          │ local/bootstrap │
                          └─────────────────┘
</code></pre>
<p>如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。</p>
<p><strong>如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request</strong>。当然，对方是否接受你的pull request就不一定了。</p>
<h3 id="小结">小结</h3>
<p>在GitHub上，可以任意Fork开源仓库；</p>
<p>自己拥有Fork后的仓库的读写权限；</p>
<p>可以推送pull request给官方仓库来贡献代码。</p>
<h2 id="gitee">Gitee</h2>
<p>使用GitHub时，国内的用户经常遇到的问题是访问速度太慢，有时候还会出现无法连接的情况。</p>
<p>如果我们希望体验Git飞一般的速度，可以使用国内的Git托管服务——Gitee（gitee.com）。</p>
<p>和GitHub相比，Gitee也提供免费的Git仓库。此外，还集成了代码质量检测、项目演示等功能。对于团队协作开发，Gitee还提供了项目管理、代码托管、文档管理的服务，5人以下小团队免费。</p>
<p>Gitee的免费版本也提供私有库功能，只是有5人的成员上限。<br>
使用Gitee和使用GitHub类似，我们在Gitee上注册账号并登录后，需要先上传自己的SSH公钥。选择右上角用户头像 -&gt; 菜单“修改资料”，然后选择“SSH公钥”，填写一个便于识别的标题，然后把用户主目录下的.ssh/id_rsa.pub文件的内容粘贴进去：</p>
<pre><code>gitee-add-ssh-key
</code></pre>
<p>点击“确定”即可完成并看到刚才添加的Key：</p>
<pre><code>gitee-key
</code></pre>
<p>如果我们已经有了一个本地的git仓库（例如，一个名为learngit的本地库），如何把它关联到Gitee的远程库上呢？</p>
<p>首先，我们在Gitee上创建一个新的项目，选择右上角用户头像 -&gt; 菜单“控制面板”，然后点击“创建项目”：</p>
<pre><code>gitee-new-repo
</code></pre>
<p>项目名称最好与本地库保持一致：</p>
<p>然后，我们在本地库上使用命令git remote add把它和Gitee的远程库关联：</p>
<pre><code>git remote add origin git@gitee.com:&lt;user-name&gt;/learngit.git
</code></pre>
<p>之后，就可以正常地用git push和git pull推送了！</p>
<p>如果在使用命令git remote add时报错：</p>
<pre><code>git remote add origin git@gitee.com:&lt;user-name&gt;/learngit.git
fatal: remote origin already exists.
</code></pre>
<p>这说明本地库已经关联了一个名叫origin的远程库，此时，可以先用git remote -v查看远程库信息：</p>
<pre><code>git remote -v
origin	git@github.com:&lt;user-name&gt;/learngit.git (fetch)
origin	git@github.com:&lt;user-name&gt;/learngit.git (push)
</code></pre>
<p>可以看到，本地库已经关联了origin的远程库，并且，该远程库指向GitHub。</p>
<p>我们可以删除已有的GitHub远程库：</p>
<pre><code>git remote rm origin
</code></pre>
<p>再关联Gitee的远程库（注意路径中需要填写正确的用户名）：</p>
<pre><code>git remote add origin git@gitee.com:&lt;user-name&gt;/learngit.git
</code></pre>
<p>此时，我们再查看远程库信息：</p>
<pre><code>git remote -v
origin	git@gitee.com:&lt;user-name&gt;/learngit.git (fetch)
origin	git@gitee.com:&lt;user-name&gt;/learngit.git (push)
</code></pre>
<p>现在可以看到，origin已经被关联到Gitee的远程库了。通过git push命令就可以把本地库推送到Gitee上。</p>
<p>有的小伙伴又要问了，一个本地库能不能既关联GitHub，又关联Gitee呢？</p>
<p>答案是肯定的，因为git本身是分布式版本控制系统，可以同步到另外一个远程库，当然也可以同步到另外两个远程库。</p>
<p>使用多个远程库时，我们要注意，git给远程库起的默认名称是origin，如果有多个远程库，我们需要用不同的名称来标识不同的远程库。</p>
<p>仍然以learngit本地库为例，我们先删除已关联的名为origin的远程库：</p>
<pre><code>git remote rm origin
</code></pre>
<p>然后，先关联GitHub的远程库：</p>
<pre><code>git remote add github git@github.com:&lt;user-name&gt;/learngit.git
</code></pre>
<p>注意，远程库的名称叫github，不叫origin了。</p>
<p>接着，再关联Gitee的远程库：</p>
<pre><code>git remote add gitee git@gitee.com:&lt;user-name&gt;/learngit.git
</code></pre>
<p>同样注意，远程库的名称叫gitee，不叫origin。</p>
<p>现在，我们用git remote -v查看远程库信息，可以看到两个远程库：</p>
<pre><code>git remote -v
gitee	git@gitee.com:&lt;user-name&gt;/learngit.git (fetch)
gitee	git@gitee.com:&lt;user-name&gt;/learngit.git (push)
github	git@github.com:&lt;user-name&gt;/learngit.git (fetch)
github	git@github.com:&lt;user-name&gt;/learngit.git (push)
</code></pre>
<p>如果要推送到GitHub，使用命令：</p>
<pre><code>git push github master
</code></pre>
<p>如果要推送到Gitee，使用命令：</p>
<pre><code>git push gitee master
</code></pre>
<p>这样一来，我们的本地库就可以同时与多个远程库互相同步：</p>
<pre><code>
┌─────────┐ ┌─────────┐
│ GitHub  │ │  Gitee  │
└─────────┘ └─────────┘
     ▲           ▲
     └─────┬─────┘
           │
    ┌─────────────┐
    │ Local Repo  │
    └─────────────┘
</code></pre>
<p>Gitee也同样提供了Pull request功能，可以让其他小伙伴参与到开源项目中来。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git - 标签管理]]></title>
        <id>https://lixin-scut.github.io//post/git-biao-qian-guan-li</id>
        <link href="https://lixin-scut.github.io//post/git-biao-qian-guan-li">
        </link>
        <updated>2020-05-12T02:28:53.000Z</updated>
        <content type="html"><![CDATA[<p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，<strong>标签也是版本库的一个快照</strong>。</p>
<p>Git的标签虽然是版本库的快照，但<strong>其实它就是指向某个commit的指针</strong>（跟分支很像对不对？但是<strong>分支可以移动，标签不能移动</strong>），所以，创建和删除标签都是瞬间完成的。</p>
<p>Git有commit，为什么还要引入tag？</p>
<p>Git有commit，为什么还要引入tag？</p>
<p>“请把上周一的那个版本打包发布，commit号是6a5819e...”</p>
<p>“一串乱七八糟的数字不好找！”</p>
<p>如果换一个办法：</p>
<p>“请把上周一的那个版本打包发布，版本号是v1.2”</p>
<p>“好的，按照tag v1.2查找commit就行！”</p>
<p>所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p>
<h3 id="创建标签">创建标签</h3>
<p>在Git中打标签非常简单，首先，切换到需要打标签的分支上：</p>
<pre><code>$ git branch
* dev
  master
$ git checkout master
Switched to branch 'master'
</code></pre>
<p>然后，敲命令<code>git tag &lt;name&gt;</code>就可以打一个新标签：</p>
<pre><code>$ git tag v1.0
</code></pre>
<p>可以用命令git tag查看所有标签：</p>
<pre><code>$ git tag
v1.0
</code></pre>
<p>默认标签是打在最新提交的commit上的。</p>
<p>有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p>
<p>方法是找到历史提交的commit id，然后打上就可以了：</p>
<pre><code>$ git log --pretty=oneline --abbrev-commit
12a631b (HEAD -&gt; master, tag: v1.0, origin/master) merged bug fix 101
4c805e2 fix bug 101
e1e9c68 merge with no-ff
f52c633 add merge
cf810e4 conflict fixed
5dc6824 &amp; simple
14096d0 AND simple
b17d20e branch test
d46f35e remove test.txt
b84166e add test.txt
519219b git tracks changes
e43a48b understand how stage works
1094adb append GPL
e475afc add distributed
eaadf4e wrote a readme file
</code></pre>
<p>比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令：</p>
<pre><code>$ git tag v0.9 f52c633
</code></pre>
<p>再用命令git tag查看标签：</p>
<pre><code>$ git tag
v0.9
v1.0
</code></pre>
<p>注意，<strong>标签不是按时间顺序列出，而是按字母排序的</strong>。</p>
<p>可以用<code>git show &lt;tagname&gt;</code>查看标签信息：</p>
<pre><code>$ git show v0.9
commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9)
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Fri May 18 21:56:54 2018 +0800

    add merge

diff --git a/readme.txt b/readme.txt
...
</code></pre>
<p>可以看到，v0.9确实打在add merge这次提交上。</p>
<p>还可以创建<strong>带有说明</strong>的标签，<strong>用-a指定标签名，-m指定说明文字</strong>：</p>
<pre><code>$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb
用命令git show &lt;tagname&gt;可以看到说明文字：

$ git show v0.1
tag v0.1
Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Fri May 18 22:48:43 2018 +0800

version 0.1 released

commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (tag: v0.1)
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Fri May 18 21:06:15 2018 +0800

    append GPL

diff --git a/readme.txt b/readme.txt
...
</code></pre>
<p>注意：<strong>标签总是和某个commit挂钩</strong>。如果这个commit既出现在master分支，又出现在dev分支，那么在这<strong>两个分支上都可以看到这个标签</strong>。</p>
<h3 id="操作标签">操作标签</h3>
<p>如果标签打错了，也可以删除：</p>
<pre><code>$ git tag -d v0.1
Deleted tag 'v0.1' (was f15b0dd)
</code></pre>
<p>因为<strong>创建的标签都只存储在本地，不会自动推送到远程</strong>。所以，打错的标签可以在本地安全删除。</p>
<p>如果要推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code>：</p>
<pre><code>$ git push origin v1.0
Total 0 (delta 0), reused 0 (delta 0)
To github.com:michaelliao/learngit.git
 * [new tag]         v1.0 -&gt; v1.0
</code></pre>
<p>或者，一次性推送全部尚未推送到远程的本地标签：</p>
<pre><code>$ git push origin --tags
Total 0 (delta 0), reused 0 (delta 0)
To github.com:michaelliao/learngit.git
 * [new tag]         v0.9 -&gt; v0.9
</code></pre>
<p>如果标签已经推送到远程，要删除远程标签就麻烦一点，<strong>先从本地删除</strong>：</p>
<pre><code>$ git tag -d v0.9
Deleted tag 'v0.9' (was f52c633)
</code></pre>
<p><strong>然后，从远程删除。删除命令也是push</strong>，但是<strong>格式如下</strong>：</p>
<pre><code>git push origin :refs/tags/&lt;tagname&gt;
</code></pre>
<pre><code>$ git push origin :refs/tags/v0.9
To github.com:michaelliao/learngit.git
 - [deleted]         v0.9
</code></pre>
<p>要看看是否真的从远程库删除了标签，可以登陆GitHub查看。</p>
<h3 id="小结">小结</h3>
<p>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</p>
<p>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</p>
<p>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</p>
<p>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git - 分支管理]]></title>
        <id>https://lixin-scut.github.io//post/git-fen-zhi-guan-li</id>
        <link href="https://lixin-scut.github.io//post/git-fen-zhi-guan-li">
        </link>
        <updated>2020-05-11T13:27:55.000Z</updated>
        <content type="html"><![CDATA[<p>分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p>
<p>现在有了分支，就不用怕了。你<strong>创建了一个属于你自己的分支</strong>，别人看不到，还<strong>继续在原来的分支上正常工作</strong>，而你在自己的分支上干活，想提交就提交，直到<strong>开发完毕后，再一次性合并到原来的分支上</strong>，这样，既安全，又不影响别人工作。</p>
<p>其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支慢，结果分支功能成了摆设，大家都不去用。</p>
<p>但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。</p>
<h2 id="创建与合并分支">创建与合并分支</h2>
<h3 id="分支概念">分支概念</h3>
<p>在版本回退里，每次提交Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫<strong>主分支，即master分支</strong>。<strong>HEAD严格来说不是指向提交，而是指向master</strong>，master才是指向提交的，所以，HEAD指向的就是当前分支。</p>
<p>一开始的时候，<strong>master分支是一条线</strong>，Git<strong>用master指向最新的提交</strong>，<strong>再用HEAD指向master</strong>，就能确定当前分支，以及当前分支的提交点：<br>
<img src="https://lixin-scut.github.io//post-images/1589204783529.png" alt=""></p>
<p><strong>每次提交，master分支都会向前移动一步</strong>，这样，随着你不断提交，master分支的线也越来越长。</p>
<p>当我们<strong>创建新的分支，例如dev时</strong>，Git<strong>新建了一个指针叫dev</strong>，指向master相同的提交，<strong>再把HEAD指向dev</strong>，就表示当前分支在dev上：<br>
<img src="https://lixin-scut.github.io//post-images/1589204824262.png" alt=""></p>
<p>你看，Git创建一个分支很快，因为<strong>除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化</strong>！</p>
<p>不过，<strong>从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变</strong>：</p>
<p><img src="https://lixin-scut.github.io//post-images/1589204958791.png" alt=""></p>
<p>假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：<br>
<img src="https://lixin-scut.github.io//post-images/1589204995130.png" alt=""></p>
<p><strong>所以Git合并分支也很快！就改改指针，工作区内容也不变！</strong></p>
<p>合并完分支后，甚至可以删除dev分支。<strong>删除dev分支就是把dev指针给删掉</strong>，删掉后，我们就剩下了一条master分支：</p>
<p><img src="https://lixin-scut.github.io//post-images/1589205086707.png" alt=""></p>
<h3 id="创建分支">创建分支</h3>
<p>首先，我们创建dev分支，然后切换到dev分支：</p>
<pre><code>$ git checkout -b dev

Switched to a new branch 'dev'
</code></pre>
<p><strong>git checkout命令加上-b参数表示创建并切换</strong>，相当于以下两条命令：</p>
<pre><code>$ git branch dev
$ git checkout dev
Switched to branch 'dev'
</code></pre>
<p>然后，用git branch命令查看当前分支：</p>
<pre><code>$ git branch
* dev
  master
</code></pre>
<p>git branch命令会列出所有分支，当前分支前面会标一个*号。</p>
<p>然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行：</p>
<pre><code>Creating a new branch is quick.
</code></pre>
<p>然后提交：</p>
<pre><code>$ git add readme.txt 
$ git commit -m &quot;branch test&quot;
[dev b17d20e] branch test
 1 file changed, 1 insertion(+)
</code></pre>
<p>现在，dev分支的工作完成，我们就可以切换回master分支：</p>
<pre><code>$ git checkout master
Switched to branch 'master'
</code></pre>
<p><strong>切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了</strong>！因为那个提交是在dev分支上，而<strong>master分支此刻的提交点并没有变</strong>：<br>
<img src="https://lixin-scut.github.io//post-images/1589205993805.png" alt=""></p>
<h3 id="合并分支">合并分支</h3>
<p>现在，我们把dev分支的工作成果合并到master分支上：</p>
<pre><code>$ git merge dev
Updating d46f35e..b17d20e
Fast-forward
 readme.txt | 1 +
 1 file changed, 1 insertion(+)
</code></pre>
<p><strong>git merge命令用于合并指定分支到当前分支</strong>。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。</p>
<p>注意到上面的<strong>Fast-forward信息</strong>，Git告诉我们，这次<strong>合并是“快进模式”</strong>，也就是<strong>直接把master指向dev的当前提交，所以合并速度非常快</strong>。</p>
<p>当然，<strong>也不是每次合并都能Fast-forward</strong>，我们后面会讲其他方式的合并。</p>
<h3 id="删除分支">删除分支</h3>
<p>合并完成后，就可以放心地<strong>删除dev分支</strong>了：</p>
<pre><code>$ git branch -d dev
Deleted branch dev (was b17d20e).
</code></pre>
<p>删除后，查看branch，就只剩下master分支了：</p>
<pre><code>$ git branch
* master
</code></pre>
<p>因为<strong>创建、合并和删除分支非常快</strong>，所以Git<strong>鼓励你使用分支完成某个任务，合并后再删掉分支</strong>，这和直接在master分支上工作效果是一样的，但<strong>过程更安全</strong>。</p>
<h3 id="switch">switch</h3>
<p>我们注意到切换分支使用<code>git checkout &lt;branch&gt;</code>，而前面讲过的撤销修改则是<code>git checkout -- &lt;file&gt;</code>，同一个命令，有两种作用，确实有点令人迷惑。</p>
<p>实际上，<strong>切换分支这个动作，用switch更科学</strong>。因此，最新版本的Git提供了新的git switch命令来切换分支：</p>
<p>创建并切换到新的dev分支，可以使用：</p>
<pre><code>$ git switch -c dev
</code></pre>
<p>直接切换到已有的master分支，可以使用：</p>
<pre><code>$ git switch master
</code></pre>
<p>使用新的git switch命令，比git checkout要更容易理解。</p>
<h3 id="小结">小结</h3>
<p>Git鼓励大量使用分支：</p>
<p>查看分支：<code>git branch</code></p>
<p>创建分支：<code>git branch &lt;name&gt;</code></p>
<p>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code></p>
<p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code></p>
<p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p>
<p>删除分支：<code>git branch -d &lt;name&gt;</code></p>
<h2 id="解决冲突">解决冲突</h2>
<p>准备新的feature1分支，继续我们的新分支开发：</p>
<pre><code>$ git switch -c feature1
Switched to a new branch 'feature1'
</code></pre>
<p>修改readme.txt最后一行，改为：</p>
<pre><code>Creating a new branch is quick AND simple.
</code></pre>
<p>在feature1分支上提交：</p>
<pre><code>$ git add readme.txt

$ git commit -m &quot;AND simple&quot;
[feature1 14096d0] AND simple
 1 file changed, 1 insertion(+), 1 deletion(-)
</code></pre>
<p>切换到master分支：</p>
<pre><code>$ git switch master
Switched to branch 'master'
Your branch is ahead of 'origin/master' by 1 commit.
  (use &quot;git push&quot; to publish your local commits)
</code></pre>
<p>Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。</p>
<p>在master分支上把readme.txt文件的最后一行改为：</p>
<pre><code>Creating a new branch is quick &amp; simple.
</code></pre>
<p>提交：</p>
<pre><code>$ git add readme.txt 
$ git commit -m &quot;&amp; simple&quot;
[master 5dc6824] &amp; simple
 1 file changed, 1 insertion(+), 1 deletion(-)
</code></pre>
<p>现在，<strong>master分支和feature1分支各自都分别有新的提交</strong>，变成了这样：</p>
<p><img src="https://lixin-scut.github.io//post-images/1589242371935.png" alt=""></p>
<p>这种情况下，<strong>Git无法执行“快速合并”，只能试图把各自的修改合并起来</strong>，但这种合并就可能会有冲突，我们试试看：</p>
<pre><code>$ git merge feature1
Auto-merging readme.txt
CONFLICT (content): Merge conflict in readme.txt
Automatic merge failed; fix conflicts and then commit the result.
</code></pre>
<p>Git告诉我们，readme.txt文件存在冲突，<strong>必须手动解决冲突后再提交</strong>。</p>
<p><strong>git status</strong>也可以告诉我们冲突的文件：</p>
<pre><code>$ git status
On branch master
Your branch is ahead of 'origin/master' by 2 commits.
  (use &quot;git push&quot; to publish your local commits)

You have unmerged paths.
  (fix conflicts and run &quot;git commit&quot;)
  (use &quot;git merge --abort&quot; to abort the merge)

Unmerged paths:
  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)

	both modified:   readme.txt

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre>
<p><strong>git diff</strong>也可以显示不同</p>
<p>vim直接查看readme.txt的内容：</p>
<pre><code>Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
Creating a new branch is quick &amp; simple.
=======
Creating a new branch is quick AND simple.
&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1
</code></pre>
<p>Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存：</p>
<pre><code>Creating a new branch is quick and simple.
</code></pre>
<p>再提交：</p>
<pre><code>$ git add readme.txt 
$ git commit -m &quot;conflict fixed&quot;
[master cf810e4] conflict fixed
</code></pre>
<p>现在，master分支和feature1分支变成了下图所示：</p>
<p><img src="https://lixin-scut.github.io//post-images/1589242393606.png" alt=""></p>
<pre><code>用带参数的git log也可以看到分支的合并情况：
</code></pre>
<pre><code>$ git log --graph --pretty=oneline --abbrev-commit
*   cf810e4 (HEAD -&gt; master) conflict fixed
|\  
| * 14096d0 (feature1) AND simple
* | 5dc6824 &amp; simple
|/  
* b17d20e branch test
* d46f35e (origin/master) remove test.txt
* b84166e add test.txt
* 519219b git tracks changes
* e43a48b understand how stage works
* 1094adb append GPL
* e475afc add distributed
* eaadf4e wrote a readme file
</code></pre>
<p>最后，删除feature1分支：</p>
<p>$ git branch -d feature1<br>
Deleted branch feature1 (was 14096d0).</p>
<h3 id="小结-2">小结</h3>
<p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p>
<p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p>
<p>用<strong>git log --graph</strong>命令可以看到分支合并图。</p>
<h2 id="分支管理策略">分支管理策略</h2>
<p>通常，合并分支时，如果可能，Git会用<strong>Fast forward模式</strong>，但这种模式下，<strong>删除分支后，会丢掉分支信息</strong>。</p>
<p>如果要<strong>强制禁用Fast forward模式</strong>，Git就会<strong>在merge时生成一个新的commit</strong>，这样，<strong>从分支历史上就可以看出分支信息</strong>。</p>
<p>下面实战一下禁用Fast forward模式 --no-ff方式的git merge：</p>
<p>首先，仍然创建并切换dev分支：</p>
<pre><code>$ git switch -c dev
Switched to a new branch 'dev'
</code></pre>
<p>修改readme.txt文件，并提交一个新的commit：</p>
<pre><code>$ git add readme.txt 
$ git commit -m &quot;add merge&quot;
[dev f52c633] add merge
 1 file changed, 1 insertion(+)
</code></pre>
<p>现在，我们切换回master：</p>
<pre><code>$ git switch master
Switched to branch 'master'
</code></pre>
<p>准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward：</p>
<pre><code>$ git merge --no-ff -m &quot;merge with no-ff&quot; dev
Merge made by the 'recursive' strategy.
 readme.txt | 1 +
 1 file changed, 1 insertion(+)
</code></pre>
<p>因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。</p>
<p>合并后，我们用git log看看分支历史：</p>
<pre><code>$ git log --graph --pretty=oneline --abbrev-commit
*   e1e9c68 (HEAD -&gt; master) merge with no-ff
|\  
| * f52c633 (dev) add merge
|/  
*   cf810e4 conflict fixed
...
</code></pre>
<p>可以看到，不使用Fast forward模式，merge后就像这样：</p>
<p><img src="https://lixin-scut.github.io//post-images/1589243365392.png" alt=""></p>
<h3 id="分支策略">分支策略</h3>
<p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p>
<p>首先，<strong>master分支应该是非常稳定</strong>的，也就是仅用来发布新版本，<strong>平时不能在上面干活</strong>；</p>
<p>那在哪干活呢？<strong>干活都在dev分支上</strong>，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，<strong>再把dev分支合并到master上</strong>，在master分支发布1.0版本；</p>
<p>你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，<strong>时不时地往dev分支上合并就可以了</strong>。</p>
<p>所以，团队合作的分支看起来就像这样：<br>
<img src="https://lixin-scut.github.io//post-images/1589243389105.png" alt=""></p>
<h3 id="小结-3">小结</h3>
<p>Git分支十分强大，在团队开发中应该充分应用。</p>
<p>合并分支时，<strong>加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并</strong>。</p>
<h2 id="bug分支">Bug分支</h2>
<p>软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，<strong>每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除</strong>。</p>
<p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是当前正在dev上进行的工作还没有提交：</p>
<pre><code>$ git status
On branch dev
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

	new file:   hello.py

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

	modified:   readme.txt
</code></pre>
<p>并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？</p>
<h3 id="stash暂存工作现场">stash暂存工作现场</h3>
<p>幸好，Git还提供了一个<strong>stash功能</strong>，可以把当前<strong>工作现场</strong>“储藏”起来，等以后<strong>恢复现场后继续工作</strong>：</p>
<pre><code>$ git stash
Saved working directory and index state WIP on dev: f52c633 add merge
</code></pre>
<p>现在，<strong>用git status查看工作区，就是干净的</strong>（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。</p>
<p>首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支：</p>
<pre><code>$ git checkout master
Switched to branch 'master'
Your branch is ahead of 'origin/master' by 6 commits.
  (use &quot;git push&quot; to publish your local commits)

$ git checkout -b issue-101
Switched to a new branch 'issue-101'
</code></pre>
<p>现在修复bug，需要把“Git is free software ...”改为“Git is a free software ...”，然后提交：</p>
<pre><code>$ git add readme.txt 
$ git commit -m &quot;fix bug 101&quot;
[issue-101 4c805e2] fix bug 101
 1 file changed, 1 insertion(+), 1 deletion(-)
</code></pre>
<p>修复完成后，切换到master分支，并完成合并，最后删除issue-101分支：</p>
<pre><code>$ git switch master
Switched to branch 'master'
Your branch is ahead of 'origin/master' by 6 commits.
  (use &quot;git push&quot; to publish your local commits)

$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101
Merge made by the 'recursive' strategy.
 readme.txt | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
</code></pre>
<p>太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到dev分支干活了！</p>
<pre><code>$ git switch dev
Switched to branch 'dev'

$ git status
On branch dev
nothing to commit, working tree clean
</code></pre>
<h3 id="恢复现场">恢复现场</h3>
<p>工作区是干净的，刚才的工作现场存到哪去了？用<strong>git stash list命令</strong>看看：</p>
<pre><code>$ git stash list
stash@{0}: WIP on dev: f52c633 add merge
</code></pre>
<p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p>
<p>一是用<strong>git stash apply恢复</strong>，但是恢复后，<strong>stash内容并不删除</strong>，你需要用<strong>git stash drop来删除</strong>；</p>
<p>另一种方式是用<strong>git stash pop，恢复的同时把stash内容也删了</strong>：</p>
<pre><code>$ git stash pop
On branch dev
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

	new file:   hello.py

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

	modified:   readme.txt

Dropped refs/stash@{0} (5d677e2ee266f39ea296182fb2354265b91b3b2a)
</code></pre>
<p>再用git stash list查看，就看不到任何stash内容了：</p>
<pre><code>$ git stash list
</code></pre>
<p>你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：</p>
<pre><code>$ git stash apply stash@{0}
</code></pre>
<p>注意使用的是stash的序号</p>
<h3 id="dev分支修改bug">dev分支修改bug</h3>
<p>在master分支上修复了bug后，我们要想一想，dev分支是早期从master分支分出来的，所以，这个<strong>bug其实在当前dev分支上也存在</strong>。</p>
<p><strong>同样的bug，要在dev上修复，我们只需要把4c805e2 fix bug 101这个提交所做的修改“复制”到dev分支</strong>。<br>
注意：我们只想复制4c805e2 fix bug 101这个提交所做的修改，<strong>并不是把整个master分支merge过来</strong>。</p>
<p>为了方便操作，Git专门提供了一个<strong>cherry-pick命令</strong>，让我们能复制一个特定的提交到当前分支：</p>
<pre><code>$ git branch
* dev
  master
$ git cherry-pick 4c805e2
[master 1d4b803] fix bug 101
 1 file changed, 1 insertion(+), 1 deletion(-)
</code></pre>
<p>Git自动给dev分支做了一次提交，注意这次提交的commit是1d4b803，它并不同于master的4c805e2，因为<strong>这两个commit只是改动相同，但确实是两个不同的commit</strong>。</p>
<p><strong>用git cherry-pick，我们就不需要在dev分支上手动再把修bug的过程重复一遍。</strong></p>
<p>既然可以在master分支上修复bug后，在dev分支上可以“重放”这个修复过程，那么<strong>直接在dev分支上修复bug，然后在master分支上“重放”行不行</strong>？当然可以，不过你<strong>仍然需要git stash命令保存现场，才能从dev分支切换到master分支</strong>。</p>
<h3 id="小结-4">小结</h3>
<p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p>
<p>当手头工作没有完成时，先<strong>把工作现场git stash一下</strong>，然后去修复bug，修复后，<strong>再git stash pop，回到工作现场</strong>；</p>
<p>在master分支上修复的bug，想要合并到当前dev分支，可以用<code>git cherry-pick &lt;commit&gt;</code>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</p>
<h2 id="强制删除分支">强制删除分支</h2>
<p>软件开发中，添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，<strong>每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</strong></p>
<p>使用新的分支进行开发：</p>
<pre><code>$ git switch -c feature-vulcan
Switched to a new branch 'feature-vulcan'
</code></pre>
<p>开发完毕后提交：</p>
<pre><code>$ git add vulcan.py

$ git status
On branch feature-vulcan
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

	new file:   vulcan.py

$ git commit -m &quot;add feature vulcan&quot;
[feature-vulcan 287773e] add feature vulcan
 1 file changed, 2 insertions(+)
 create mode 100644 vulcan.py
</code></pre>
<p>切回dev，准备合并：</p>
<pre><code>$ git switch dev
</code></pre>
<p>一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。</p>
<p>假设在合并分支前我们希望取消这个功能，就需要删除分支，先尝试-d删除分支：</p>
<pre><code>$ git branch -d feature-vulcan
error: The branch 'feature-vulcan' is not fully merged.
If you are sure you want to delete it, run 'git branch -D feature-vulcan'.
</code></pre>
<p>但此时会销毁失败。Git友情提醒，<strong>feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的-D参数</strong>。</p>
<p>现在我们强行删除：</p>
<pre><code>$ git branch -D feature-vulcan
Deleted branch feature-vulcan (was 287773e).
</code></pre>
<p>终于删除成功</p>
<h3 id="小结-5">小结</h3>
<p>开发一个新feature，最好新建一个分支；</p>
<p>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p>
<h2 id="多人协作">多人协作</h2>
<p>当你从远程仓库克隆时，实际上Git<strong>自动把本地的master分支和远程的master分支对应起来了</strong>，并且，<strong>远程仓库的默认名称是origin</strong>。</p>
<p>要查看远程库的信息，用git remote：</p>
<pre><code>$ git remote
origin
</code></pre>
<p>或者，用git remote -v显示更详细的信息：</p>
<pre><code>$ git remote -v
origin  git@github.com:user/learngit.git (fetch)
origin  git@github.com:user/learngit.git (push)
</code></pre>
<p>上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。</p>
<h3 id="推送分支">推送分支</h3>
<p>推送分支，就是<strong>把该分支上的所有本地提交推送到远程库</strong>。推送时，<strong>要指定本地分支</strong>，这样，Git就会把该分支推送到远程库对应的远程分支上：</p>
<pre><code>$ git push origin master
</code></pre>
<p>如果要推送其他分支，比如dev，就改成：</p>
<pre><code>$ git push origin dev
</code></pre>
<p>但是，<strong>并不是一定要把本地分支往远程推送</strong>，那么，哪些分支需要推送，哪些不需要呢？</p>
<ol>
<li>
<p><strong>master分支</strong>是主分支，因此要<strong>时刻与远程同步</strong>；</p>
</li>
<li>
<p><strong>dev分支</strong>是开发分支，团队所有成员都需要在上面工作，所以<strong>也需要与远程同步</strong>；</p>
</li>
<li>
<p><strong>bug分支</strong>只用于在本地修复bug，就<strong>没必要推到远程了</strong>，除非老板要看看你每周到底修复了几个bug；</p>
</li>
<li>
<p><strong>feature分支</strong>是新功能分支，是否推到远程，<strong>取决于你是否和同事合作在上面开发</strong>。</p>
</li>
</ol>
<p>总之，就是在Git中，分支完全可以在本地保存，是否推送，视个人输球而定！</p>
<h3 id="抓取分支">抓取分支</h3>
<p>多人协作时，大家都会往master和dev分支上推送各自的修改。</p>
<p>现在，模拟一个你的同事，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：</p>
<pre><code>$ git clone git@github.com:michaelliao/learngit.git
Cloning into 'learngit'...
remote: Counting objects: 40, done.
remote: Compressing objects: 100% (21/21), done.
remote: Total 40 (delta 14), reused 40 (delta 14), pack-reused 0
Receiving objects: 100% (40/40), done.
Resolving deltas: 100% (14/14), done.
</code></pre>
<p>当你的小伙伴从远程库clone时，默认情况下，你的小伙伴<strong>只能看到本地的master分支</strong>。</p>
<p>可以用git branch命令看看：</p>
<pre><code>$ git branch
* master
</code></pre>
<p>现在，你的小伙伴<strong>要在dev分支上开发，就必须创建远程origin的dev分支到本地</strong>，于是他用这个命令创建本地dev分支：</p>
<pre><code>$ git checkout -b dev origin/dev
</code></pre>
<p>现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程：</p>
<pre><code>$ git add env.txt

$ git commit -m &quot;add env&quot;
[dev 7a5e5dd] add env
 1 file changed, 1 insertion(+)
 create mode 100644 env.txt

$ git push origin dev
Counting objects: 3, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 308 bytes | 308.00 KiB/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To github.com:michaelliao/learngit.git
   f52c633..7a5e5dd  dev -&gt; dev
</code></pre>
<p>你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：</p>
<pre><code>$ cat env.txt
env

$ git add env.txt

$ git commit -m &quot;add new env&quot;
[dev 7bd91f1] add new env
 1 file changed, 1 insertion(+)
 create mode 100644 env.txt

$ git push origin dev
To github.com:michaelliao/learngit.git
 ! [rejected]        dev -&gt; dev (non-fast-forward)
error: failed to push some refs to 'git@github.com:michaelliao/learngit.git'
hint: Updates were rejected because the tip of your current branch is behind
hint: its remote counterpart. Integrate the remote changes (e.g.
hint: 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
</code></pre>
<p><strong>推送失败</strong>，因为你的小伙伴的<strong>最新提交和你试图推送的提交有冲突</strong>，解决办法也很简单，Git已经提示我们，<strong>先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送</strong>：</p>
<pre><code>$ git pull
There is no tracking information for the current branch.
Please specify which branch you want to merge with.
See git-pull(1) for details.

    git pull &lt;remote&gt; &lt;branch&gt;

If you wish to set tracking information for this branch you can do so with:

    git branch --set-upstream-to=origin/&lt;branch&gt; dev
</code></pre>
<p>git pull也失败了，原因是<strong>没有指定本地dev分支与远程origin/dev分支的链接</strong>，根据提示，设置dev和origin/dev的链接：</p>
<pre><code>$ git branch --set-upstream-to=origin/dev dev
Branch 'dev' set up to track remote branch 'dev' from 'origin'.
</code></pre>
<p>再pull：</p>
<pre><code>$ git pull
Auto-merging env.txt
CONFLICT (add/add): Merge conflict in env.txt
Automatic merge failed; fix conflicts and then commit the result.
</code></pre>
<p>这回git pull成功，但是<strong>合并有冲突，需要手动解决</strong>，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push：</p>
<pre><code>$ git commit -m &quot;fix env conflict&quot;
[dev 57c53ab] fix env conflict

$ git push origin dev
Counting objects: 6, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (4/4), done.
Writing objects: 100% (6/6), 621 bytes | 621.00 KiB/s, done.
Total 6 (delta 0), reused 0 (delta 0)
To github.com:michaelliao/learngit.git
   7a5e5dd..57c53ab  dev -&gt; dev
</code></pre>
<h3 id="多人协作的工作模式">多人协作的工作模式</h3>
<p>多人协作的工作模式通常是这样：</p>
<ol>
<li>
<p>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</p>
</li>
<li>
<p>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</p>
</li>
<li>
<p>如果合并有冲突，则解决冲突，并在本地提交；</p>
</li>
<li>
<p>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</p>
</li>
<li>
<p>如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p>
</li>
</ol>
<h3 id="小结-6">小结</h3>
<p>查看远程库信息，使用<code>git remote -v</code>；</p>
<p>本地新建的分支如果不推送到远程，对其他人就是不可见的；</p>
<p>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用git pull抓取远程的新提交；</p>
<p>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</p>
<p>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</p>
<p>从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。</p>
<h2 id="rebase">Rebase</h2>
<p>在上一节中，多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，<strong>后push的童鞋不得不先pull，在本地合并，然后才能push成功。</strong></p>
<p>每次合并再push后，分支变成了这样：</p>
<pre><code>$ git log --graph --pretty=oneline --abbrev-commit
* d1be385 (HEAD -&gt; master, origin/master) init hello
*   e5e69f1 Merge branch 'dev'
|\  
| *   57c53ab (origin/dev, dev) fix env conflict
| |\  
| | * 7a5e5dd add env
| * | 7bd91f1 add new env
| |/  
* |   12a631b merged bug fix 101
|\ \  
| * | 4c805e2 fix bug 101
|/ /  
* |   e1e9c68 merge with no-ff
|\ \  
| |/  
| * f52c633 add merge
|/  
*   cf810e4 conflict fixed
</code></pre>
<p>总之看上去很乱，Git的提交历史能否是一条干净的直线？其实是可以做到的</p>
<p>Git有一种称为rebase的操作</p>
<p>在和远程分支同步后，我们对hello.py这个文件做了两次提交。用git log命令看看：</p>
<pre><code>$ git log --graph --pretty=oneline --abbrev-commit
* 582d922 (HEAD -&gt; master) add author
* 8875536 add comment
* d1be385 (origin/master) init hello
*   e5e69f1 Merge branch 'dev'
|\  
| *   57c53ab (origin/dev, dev) fix env conflict
| |\  
| | * 7a5e5dd add env
| * | 7bd91f1 add new env
...
</code></pre>
<p>注意到Git用(HEAD -&gt; master)和(origin/master)标识出当前分支的HEAD和远程origin的位置分别是582d922 add author和d1be385 init hello，本地分支比远程分支快两个提交。</p>
<p>现在我们尝试推送本地分支：</p>
<pre><code>$ git push origin master
To github.com:michaelliao/learngit.git
 ! [rejected]        master -&gt; master (fetch first)
error: failed to push some refs to 'git@github.com:michaelliao/learngit.git'
hint: Updates were rejected because the remote contains work that you do
hint: not have locally. This is usually caused by another repository pushing
hint: to the same ref. You may want to first integrate the remote changes
hint: (e.g., 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
</code></pre>
<p>很不幸，失败了，这<strong>说明有人先于我们推送了远程分支</strong>。按照经验，先pull一下：</p>
<pre><code>$ git pull
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (1/1), done.
remote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0
Unpacking objects: 100% (3/3), done.
From github.com:michaelliao/learngit
   d1be385..f005ed4  master     -&gt; origin/master
 * [new tag]         v1.0       -&gt; v1.0
Auto-merging hello.py
Merge made by the 'recursive' strategy.
 hello.py | 1 +
 1 file changed, 1 insertion(+)
</code></pre>
<p>再用git status看看状态：</p>
<pre><code>$ git status
On branch master
Your branch is ahead of 'origin/master' by 3 commits.
  (use &quot;git push&quot; to publish your local commits)

nothing to commit, working tree clean
</code></pre>
<p>加上刚才合并的提交，现在我们本地分支比远程分支超前3个提交。</p>
<p>用git log看看：</p>
<pre><code>$ git log --graph --pretty=oneline --abbrev-commit
*   e0ea545 (HEAD -&gt; master) Merge branch 'master' of github.com:michaelliao/learngit
|\  
| * f005ed4 (origin/master) set exit=1
* | 582d922 add author
* | 8875536 add comment
|/  
* d1be385 init hello
...
</code></pre>
<p>现在事情有点不对头，提交历史分叉了。如果现在把本地分支push到远程，容易出现分叉<br>
这个时候，rebase就派上了用场。我们输入命令git rebase试试：</p>
<pre><code>$ git rebase
First, rewinding head to replay your work on top of it...
Applying: add comment
Using index info to reconstruct a base tree...
M	hello.py
Falling back to patching base and 3-way merge...
Auto-merging hello.py
Applying: add author
Using index info to reconstruct a base tree...
M	hello.py
Falling back to patching base and 3-way merge...
Auto-merging hello.py
</code></pre>
<p>再用git log看看：</p>
<pre><code>$ git log --graph --pretty=oneline --abbrev-commit
* 7e61ed4 (HEAD -&gt; master) add author
* 3611cfe add comment
* f005ed4 (origin/master) set exit=1
* d1be385 init hello
...
</code></pre>
<p>原本分叉的提交现在变成一条直线了，其实原理非常简单。我们注意观察，发现<strong>Git把我们本地的提交“挪动”了位置</strong>，放到了f005ed4 (origin/master) set exit=1之后，这样，整个提交历史就成了一条直线。</p>
<p><strong>rebase操作前后，最终的提交内容是一致的</strong>，但是，我们本地的commit修改内容已经变化了，它们的<strong>修改不再基于</strong>d1be385 init hello，<strong>而是基于</strong>f005ed4 (origin/master) set exit=1，但<strong>最后的提交7e61ed4内容是一致的</strong>。</p>
<p>这就是rebase操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。<strong>缺点是本地的分叉提交已经被修改过了</strong>。</p>
<p>最后，通过push操作把本地分支推送到远程：</p>
<pre><code>Mac:~/learngit michael$ git push origin master
Counting objects: 6, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (5/5), done.
Writing objects: 100% (6/6), 576 bytes | 576.00 KiB/s, done.
Total 6 (delta 2), reused 0 (delta 0)
remote: Resolving deltas: 100% (2/2), completed with 1 local object.
To github.com:michaelliao/learngit.git
   f005ed4..7e61ed4  master -&gt; master
</code></pre>
<p>再用git log看看效果：</p>
<pre><code>$ git log --graph --pretty=oneline --abbrev-commit
* 7e61ed4 (HEAD -&gt; master, origin/master) add author
* 3611cfe add comment
* f005ed4 set exit=1
* d1be385 init hello
...
</code></pre>
<p><strong>远程分支的提交历史也是一条直线</strong>。</p>
<h3 id="小结-7">小结</h3>
<p>rebase操作可以把本地未push的分叉提交历史整理成直线；</p>
<p>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p>
<p>网友评论：<br>
作者这个教程中,省略了一堆操作,前面至少要有一个人先提交同一个文件,造成此时要操作的本地git库与远程不符,再在本地git进行提交操作.<br>
并且,重要的是作者并没有写出git rebase处理过程,使用git rebase之后,只是返回冲突出现的提交处的commit,之后要在这个commit中进行解决冲突;再使用git add操作添加好要解决冲突后的文件,之后还要再执行一次git rebase --continu,到此git rebase衍合过程才真正结束;<br>
推荐阅读：<a href="https://www.cnblogs.com/pinefantasy/articles/6287147.html">【Git系列】git rebase详解</a><br>
就使用过程来说： ===只对尚未推送或分享给别人的本地修改执行变基操作清理历史； ===从不对已推送至别处的提交执行变基操作</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git - 远程仓库]]></title>
        <id>https://lixin-scut.github.io//post/git-yuan-cheng-cang-ku</id>
        <link href="https://lixin-scut.github.io//post/git-yuan-cheng-cang-ku">
        </link>
        <updated>2020-05-11T09:30:24.000Z</updated>
        <content type="html"><![CDATA[<h2 id="远程仓库">远程仓库</h2>
<p>到目前为止，我们已经掌握了如何在Git仓库里对一个文件进行版本更换，你再也不用担心文件备份或者丢失的问题了。</p>
<p>但对于集中式版本控制系统SVN来说，这些功能在SVN里早就有了，没看出Git有什么特别的地方。</p>
<p>如果只是在一个仓库里管理文件历史，Git和SVN真没啥区别。本章开始介绍Git的杀手级功能之一：远程仓库。</p>
<p>Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且<strong>每台机器的版本库其实都是一样的，并没有主次之分</strong>。</p>
<p>同时同一台电脑上也是可以克隆多个版本库的，只要不在同一个目录下。不过，现实生活中是不会有人在一台电脑上搞几个远程库，因为一台电脑上搞几个远程库完全没有意义，而且硬盘挂了会导致所有库都挂掉。</p>
<p>实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。</p>
<p>完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫<strong>GitHub</strong>的神奇的网站，从名字就可以看出，这个网站就是<strong>提供Git仓库托管服务</strong>的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。</p>
<p>在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：</p>
<p>第1步：<strong>创建SSH Key</strong>。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p>
<pre><code>$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;
</code></pre>
<p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于特殊目的，所以也无需设置密码。</p>
<p>如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p>
<p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：</p>
<p>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容：</p>
<p>点“Add Key”，你就应该看到已经添加的Key：</p>
<p><strong>为什么GitHub需要SSH Key</strong>呢？因为<strong>GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议</strong>，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p>
<p>当然，<strong>GitHub允许你添加多个Key</strong>。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p>
<p>最后友情提示，<strong>在GitHub上免费托管的Git仓库，任何人都可以看到喔</strong>（但只有你自己才能改）。所以，不要把敏感信息放进去。</p>
<p>如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。<strong>另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。</strong> 这个方法我们后面会讲到的，相当简单，公司内部开发必备。</p>
<h2 id="添加远程库">添加远程库</h2>
<p>经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。</p>
<ol>
<li>
<p>首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库</p>
</li>
<li>
<p>在Repository name填入本地电脑上相应的文件夹名，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库</p>
</li>
<li>
<p>目前，在GitHub上的这个仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p>
</li>
</ol>
<p>根据GitHub的提示，在本地的仓库下运行命令：</p>
<pre><code>$ git remote add origin git@server-name:path/repo-name.git
</code></pre>
<p>请千万注意，把上面的user_name替换成自己的GitHub账户名，否则，你在本地关联的就是其他人的远程库，关联没有问题，但是以后推送是推不上去的，因为SSH Key公钥不在他人的账户列表中。</p>
<p>添加后，<strong>远程库的名字就是origin，这是Git默认的叫法</strong>，也可以改成别的，但是origin这个名字一看就知道是远程库。</p>
<p>下一步，就可以<strong>把本地库的所有内容推送到远程库上</strong>：</p>
<pre><code>$ git push -u origin master

Counting objects: 20, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (15/15), done.
Writing objects: 100% (20/20), 1.64 KiB | 560.00 KiB/s, done.
Total 20 (delta 5), reused 0 (delta 0)
remote: Resolving deltas: 100% (5/5), done.
To github.com:michaelliao/learngit.git
 * [new branch]      master -&gt; master
Branch 'master' set up to track remote branch 'master' from 'origin'.
</code></pre>
<pre><code>$ git push -u origin master
</code></pre>
<p>把本地库的内容推送到远程，用<strong>git push命令</strong>，实际上是把<strong>当前分支master</strong>推送到<strong>远程</strong>。</p>
<p>由于远程库是空的，我们第一次推送master分支时，<strong>加上了-u参数</strong>，Git不但会把本地的master分支内容推送的远程新的master分支，还会把<strong>本地的master分支和远程的master分支关联起来</strong>，<strong>在以后的推送或者拉取时就可以简化命令</strong>。</p>
<p>从现在起，只要本地作了提交，就可以通过命令：</p>
<pre><code>$ git push origin master
</code></pre>
<p>把本地master分支的最新修改推送至GitHub，现在就拥有了真正的分布式版本库</p>
<p>SSH警告</p>
<p>当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告：</p>
<pre><code>The authenticity of host 'github.com (xx.xx.xx.xx)' can't be established.
RSA key fingerprint is xx.xx.xx.xx.xx.
Are you sure you want to continue connecting (yes/no)?
</code></pre>
<p>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。</p>
<p>Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：</p>
<pre><code>Warning: Permanently added 'github.com' (RSA) to the list of known hosts.
</code></pre>
<p>这个警告只会出现一次，后面的操作就不会有任何警告了。</p>
<p>如果你实在担心有人冒充GitHub服务器，<strong>输入yes前可以对照GitHub的RSA Key的指纹信息是否与SSH连接给出的一致</strong>。</p>
<h3 id="小结">小结</h3>
<p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code></p>
<p>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p>
<p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p>
<p>分布式版本系统的最大好处之一是<strong>在本地工作完全不需要考虑远程库的存在</strong>，也就是有<strong>没有联网都可以正常工作</strong>，而<strong>SVN在没有联网的时候是拒绝干活的</strong>！当有网络的时候，再把本地提交推送一下就完成了同步</p>
<h2 id="从远程库克隆">从远程库克隆</h2>
<p>现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。</p>
<p>首先，登陆GitHub，创建一个新的仓库，名字叫gitskills</p>
<p>勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件</p>
<p>现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库：</p>
<pre><code>$ git clone git@github.com:server-name:path/gitskills.git

Cloning into 'gitskills'...
remote: Counting objects: 3, done.
remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3
Receiving objects: 100% (3/3), done.
</code></pre>
<p>注意把Git库的地址server-name:path换成你自己的用户名，然后进入gitskills目录看看，已经有README.md文件了：</p>
<pre><code>$ cd gitskills
$ ls
README.md
</code></pre>
<p>如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。</p>
<p>你也许还注意到，<strong>GitHub给出的地址不止一个</strong>，还可以用https://github.com/server-name:path/gitskills.git 这样的地址。实际上，<strong>Git支持多种协议，默认的git:// 使用ssh，但也可以使用https等其他协议。</strong></p>
<p><strong>使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令</strong>，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。</p>
<h3 id="小结-2">小结</h3>
<p>要克隆一个仓库，<strong>首先必须知道仓库的地址，然后使用git clone命令克隆</strong>。</p>
<p><strong>Git支持多种协议</strong>，包括https，但ssh协议速度最快。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git - 版本管理]]></title>
        <id>https://lixin-scut.github.io//post/git-ban-ben-guan-li</id>
        <link href="https://lixin-scut.github.io//post/git-ban-ben-guan-li">
        </link>
        <updated>2020-05-11T06:52:38.000Z</updated>
        <content type="html"><![CDATA[<h2 id="版本管理">版本管理</h2>
<p>我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件，改成如下内容：</p>
<pre><code>Git is a distributed version control system.
Git is free software.
</code></pre>
<h3 id="git-status">git status</h3>
<p>现在，运行git status命令看看结果：</p>
<pre><code>$ git status
On branch master
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

	modified:   readme.txt

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre>
<p><strong>git status命令</strong>可以让我们<strong>时刻掌握仓库当前的状态</strong></p>
<p>上面的命令输出告诉我们，<strong>readme.txt的字体是红色的！</strong> 被修改过了，但还没有准备提交的修改。</p>
<p>虽然<strong>Git告诉我们readme.txt被修改了，但并不能看看具体修改了什么内容</strong>。<br>
比如你休假回来上班时，已经记不清上次怎么修改的readme.txt，所以，需要用git diff这个命令看看：</p>
<h3 id="git-diff">git diff</h3>
<pre><code>$ git diff readme.txt 
diff --git a/readme.txt b/readme.txt
index 46d49bf..9247db6 100644
--- a/readme.txt
+++ b/readme.txt
@@ -1,2 +1,2 @@
-Git is a version control system.
+Git is a distributed version control system.
 Git is free software.
</code></pre>
<p>git diff顾名思义就是<strong>查看difference</strong>，显示的格式正是<strong>Unix通用的diff格式</strong>，可以从上面的命令输出看到，我们在第一行添加了一个distributed单词。</p>
<h3 id="再次提交">再次提交</h3>
<p>知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是git add</p>
<pre><code>$ git add readme.txt
</code></pre>
<p>同样没有任何输出。在执行第二步git commit之前，我们再运行git status看看当前仓库的状态：</p>
<pre><code>$ git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

	modified:   readme.txt
</code></pre>
<p>git status告诉我们，将要被提交的修改包括readme.txt，<strong>readme.txt的字体变为了绿色的！</strong> ，下一步，就可以放心地提交了：</p>
<pre><code>$ git commit -m &quot;add distributed&quot;
[master e475afc] add distributed
 1 file changed, 1 insertion(+), 1 deletion(-)
</code></pre>
<p>提交后，我们再用git status命令看看仓库的当前状态：</p>
<pre><code>$ git status
On branch master
nothing to commit, working tree clean
</code></pre>
<p>Git告诉我们当前没有需要提交的修改，而且，<strong>工作目录是干净（working tree clean）的</strong>。</p>
<h3 id="小结">小结</h3>
<p>要随时掌握工作区的状态，使用git status命令。</p>
<p>如果git status告诉你有文件被修改过，用git diff可以查看修改内容。</p>
<h2 id="版本回退">版本回退</h2>
<p>现在已经学会了修改文件，然后把修改提交到Git版本库，现在，再一次修改readme.txt文件如下：</p>
<pre><code>Git is a distributed version control system.
Git is free software distributed under the GPL.
</code></pre>
<p>然后尝试提交：</p>
<pre><code>$ git add readme.txt
$ git commit -m &quot;append GPL&quot;
[master 1094adb] append GPL
 1 file changed, 1 insertion(+), 1 deletion(-)
</code></pre>
<p>像这样，可以不断对文件进行修改，然后不断提交修改到版本库里。<br>
每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，<strong>这个快照在Git中被称为commit</strong>。<br>
一旦你把文件改乱了，或者误删了文件，还可以<strong>从最近的一个commit恢复</strong>，然后继续工作，而不是把几个月的工作成果全部丢失。</p>
<h3 id="git-log">git log</h3>
<p>现在，我们回顾一下readme.txt文件一共有几个版本被提交到Git仓库里了：</p>
<p>版本1：wrote a readme file</p>
<pre><code>Git is a version control system.
Git is free software.
</code></pre>
<p>版本2：add distributed</p>
<pre><code>Git is a distributed version control system.
Git is free software.
</code></pre>
<p>版本3：append GPL</p>
<pre><code>Git is a distributed version control system.
Git is free software distributed under the GPL.
</code></pre>
<p>当然了，在实际工作中版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看：</p>
<pre><code>$ git log
commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Fri May 18 21:06:15 2018 +0800

    append GPL

commit e475afc93c209a690c39c13a46716e8fa000c366
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Fri May 18 21:03:36 2018 +0800

    add distributed

commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Fri May 18 20:59:18 2018 +0800

    wrote a readme file
</code></pre>
<p>git log命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是append GPL，上一次是add distributed，最早的一次是wrote a readme file。</p>
<p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数：</p>
<pre><code>$ git log --pretty=oneline
1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPL
e475afc93c209a690c39c13a46716e8fa000c366 add distributed
eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file
</code></pre>
<p>提示：看到的一大串类似1094adb...的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p>
<p>每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线</p>
<h3 id="git-reset">git reset</h3>
<h4 id="回退到上一个版本">回退到上一个版本</h4>
<p>现在准备把readme.txt回退到上一个版本，也就是add distributed的那个版本</p>
<p>首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交，<strong>上一个版本就是HEAD<sup>**，**上上一个版本就是HEAD</sup><sup>**，当然往上100个版本写100个</sup>比较容易数不过来，所以写成</strong>HEAD~100**。</p>
<p>要把当前版本append GPL回退到上一个版本add distributed，就可以使用git reset命令：</p>
<pre><code>$ git reset --hard HEAD^
HEAD is now at e475afc add distributed
</code></pre>
<p>还可以继续回退到上一个版本wrote a readme file，<br>
不过我们先用git log再看看现在版本库的状态：</p>
<pre><code>$ git log
commit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -&gt; master)
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Fri May 18 21:03:36 2018 +0800

    add distributed

commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Fri May 18 20:59:18 2018 +0800

    wrote a readme file
</code></pre>
<p>最新的那个版本append GPL已经看不到了</p>
<h4 id="回退到后一个版本">回退到后一个版本</h4>
<p>如果git reset是误操作，如何向后复原呢？</p>
<p>只要上面的命令行窗口还没有被关掉，可以找到那个append GPL的commit id1094adb...，于是就可以根据commit id来指定回到未来的某个版本：</p>
<pre><code>$ git reset --hard 1094a
HEAD is now at 83b0afe append GPL
</code></pre>
<p><strong>版本号没必要写全，前几位就可以了，Git会自动去找</strong>。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p>
<p>再查看readme.txt的内容：</p>
<pre><code>$ cat readme.txt
Git is a distributed version control system.
Git is free software distributed under the GPL.
</code></pre>
<p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你<strong>回退版本的时候，Git仅仅是把HEAD从指向append GPL</strong>：</p>
<pre><code>
┌────┐
│HEAD│
└────┘
   │
   └──&gt; ○ append GPL
        │
        ○ add distributed
        │
        ○ wrote a readme file
</code></pre>
<p>改为指向add distributed：</p>
<pre><code>
┌────┐
│HEAD│
└────┘
   │
   │    ○ append GPL
   │    │
   └──&gt; ○ add distributed
        │
        ○ wrote a readme file
</code></pre>
<p>然后顺便把<strong>工作区</strong>的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。</p>
<h3 id="git-reflog-命令记录">git reflog-命令记录</h3>
<p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？</p>
<p>在Git中，总是有后悔药可以吃的。当你用$ git reset --hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令：</p>
<pre><code>$ git reflog
e475afc HEAD@{1}: reset: moving to HEAD^
1094adb (HEAD -&gt; master) HEAD@{2}: commit: append GPL
e475afc HEAD@{3}: commit: add distributed
eaadf4e HEAD@{4}: commit (initial): wrote a readme file
</code></pre>
<p>从输出可知，append GPL的commit id是1094adb。</p>
<h3 id="小结-2">小结</h3>
<p>现在总结一下：</p>
<ol>
<li>
<p>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。</p>
</li>
<li>
<p>穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。</p>
</li>
<li>
<p>要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</p>
</li>
</ol>
<h2 id="工作区和暂存区">工作区和暂存区</h2>
<p>Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。</p>
<p><strong>工作区（Working Directory）</strong>：就是你在电脑里能看到的目录，比如git init的文件夹就是一个工作区：</p>
<p><strong>版本库（Repository）</strong></p>
<p>工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。</p>
<p>Git的版本库里存了很多东西</p>
<ol>
<li>其中最重要的就是称为<strong>stage（或者叫index）的暂存区</strong></li>
<li>还有Git为我们<strong>自动创建的第一个分支master</strong></li>
<li>以及<strong>指向master的一个指针叫HEAD</strong>。<br>
<img src="https://lixin-scut.github.io//post-images/1589181011272.png" alt=""></li>
</ol>
<p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p>
<p>第一步是用<strong>git add</strong>把文件添加进去，实际上就是把<strong>文件修改添加到暂存区</strong>；</p>
<p>第二步是用<strong>git commit</strong>提交更改，实际上就是把<strong>暂存区的所有内容提交到当前分支</strong>。</p>
<p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。</p>
<p>你可以简单理解为，需<strong>要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改</strong>。</p>
<p>俗话说，实践出真知。现在，我们再练习一遍，先对readme.txt做个修改，比如加上一行内容：</p>
<pre><code>Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
</code></pre>
<p>然后，在工作区新增一个LICENSE文本文件（内容随便写）。</p>
<p>先用git status查看一下状态：</p>
<pre><code>$ git status
On branch master
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

	modified:   readme.txt

Untracked files:
  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)

	LICENSE

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre>
<p>Git非常清楚地告诉我们，readme.txt被修改了，而LICENSE还从来没有被添加过，所以它的状态是Untracked，<strong>两者都是红色字体</strong>。</p>
<p>现在，使用两次命令git add，把readme.txt和LICENSE都添加后，用git status再查看一下：</p>
<pre><code>$ git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

	new file:   LICENSE
	modified:   readme.txt
</code></pre>
<p>可以看到两者被成功添加，两者都变为绿色字体<br>
现在，暂存区的状态就变成这样了：<br>
<img src="https://lixin-scut.github.io//post-images/1589181355793.png" alt=""></p>
<p>所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。</p>
<pre><code>$ git commit -m &quot;understand how stage works&quot;
[master e43a48b] understand how stage works
 2 files changed, 2 insertions(+)
 create mode 100644 LICENSE
</code></pre>
<p>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：</p>
<pre><code>$ git status
On branch master
nothing to commit, working tree clean
</code></pre>
<p><img src="https://lixin-scut.github.io//post-images/1589181551641.png" alt=""></p>
<h2 id="管理修改">管理修改</h2>
<p><strong>Git跟踪并管理的是修改，而非文件。</strong></p>
<p>什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。</p>
<p>为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容：</p>
<pre><code>$ cat readme.txt
Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes.
</code></pre>
<p>然后，添加：</p>
<pre><code>$ git add readme.txt
$ git status
# On branch master
# Changes to be committed:
#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
#
#       modified:   readme.txt
#
</code></pre>
<p>然后，再修改readme.txt：</p>
<pre><code>$ cat readme.txt 
Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
</code></pre>
<p>提交：</p>
<pre><code>$ git commit -m &quot;git tracks changes&quot;
[master 519219b] git tracks changes
 1 file changed, 1 insertion(+)
</code></pre>
<p>提交后，再看看状态：</p>
<pre><code>$ git status
On branch master
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

	modified:   readme.txt

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre>
<p>可以看到，<strong>第二次的修改并没有被提交！</strong></p>
<p>回顾一下操作过程：</p>
<p>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit</p>
<p>前面讲了Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的<strong>第二次修改并没有放入暂存区</strong>，所以，git commit<strong>只负责把暂存区的修改提交了</strong>，也就是<strong>第一次的修改被提交了，第二次的修改不会被提交</strong>。</p>
<p>提交后，用<code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别：</p>
<pre><code>$ git diff HEAD -- readme.txt 
diff --git a/readme.txt b/readme.txt
index 76d770f..a9c5755 100644
--- a/readme.txt
+++ b/readme.txt
@@ -1,4 +1,4 @@
 Git is a distributed version control system.
 Git is free software distributed under the GPL.
 Git has a mutable index called stage.
-Git tracks changes.
+Git tracks changes of files.
</code></pre>
<p>可见，第二次修改确实没有被提交。</p>
<p>那怎么提交第二次修改呢？可以继续git add再git commit，也<strong>可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了</strong>：</p>
<p>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit</p>
<h2 id="撤销修改">撤销修改</h2>
<h3 id="撤销git-add-之前的修改">撤销git add 之前的修改</h3>
<p>如果错误发现得很及时，可以在<strong>提交(git add)</strong> 之前修正，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用git status查看一下：</p>
<pre><code>$ git status
On branch master
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

	modified:   readme.txt

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre>
<p>同时也可以<strong>使用git checkout -- file丢弃工作区的修改</strong>：</p>
<pre><code>$ git checkout -- readme.txt
</code></pre>
<p>命令git checkout -- readme.txt意思就是，把readme.txt文件在<strong>工作区的修改全部撤销</strong>，这里有两种情况：</p>
<ol>
<li>
<p>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
</li>
<li>
<p>一种是readme.txt已经添加到暂存区后，又作了修改，现在，<strong>撤销修改就回到添加到暂存区后的状态</strong>。</p>
</li>
</ol>
<p>总之，就是让这个文件回到<strong>最近一次git commit或git add</strong>时的状态。</p>
<p><strong>git checkout -- file命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令</strong>，我们在后面的分支管理中会再次遇到git checkout命令。</p>
<h3 id="撤销git-add-之后的修改">撤销git add 之后的修改</h3>
<p>如果git add到暂存区了，在commit之前，你发现了这个问题。用git status查看一下，修改只是添加到了暂存区，还没有提交：</p>
<p>Git同样告诉我们，用命令<code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），<strong>重新放回工作区</strong>：</p>
<pre><code>$ git reset HEAD readme.txt
Unstaged changes after reset:
M	readme.txt
</code></pre>
<p><strong>注意！！此时修改还在！！！只是回到了工作区的修改！！！并不是说回到上一次最近一次git commit或git add时的状态，如果想要彻底回到修改前的状态，还需要调用git checkout</strong></p>
<p>git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们<strong>用HEAD时，表示最新的版本</strong>。</p>
<p>再用git status查看一下，<strong>现在暂存区是干净的，工作区有修改</strong>：</p>
<pre><code>$ git status
On branch master
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

	modified:   readme.txt
</code></pre>
<p>进一步丢弃工作区的修改：git checkout</p>
<pre><code>$ git checkout -- readme.txt

$ git status
On branch master
nothing to commit, working tree clean
</code></pre>
<h3 id="小结-3">小结</h3>
<p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p>
<p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了<strong>暂存区</strong>时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p>
<p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p>
<p>现在，假设不但改错了东西，还从暂存区提交到了版本库，此时就必须使用版本回退回退到上一个版本。不过，这是有条件的，就是还没有把自己的本地版本库推送到远程。因为Git是分布式版本控制系统，具有相关的远程版本库</p>
<h2 id="删除文件">删除文件</h2>
<p>在Git中，删除也是一个修改操作，先添加一个新文件test.txt到Git并且提交：</p>
<pre><code>$ git add test.txt

$ git commit -m &quot;add test.txt&quot;
[master b84166e] add test.txt
 1 file changed, 1 insertion(+)
 create mode 100644 test.txt
</code></pre>
<p>一般情况下，可以直接在文件管理器中把没用的文件删了，或者用rm命令删了：</p>
<pre><code>$ rm test.txt
</code></pre>
<p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了：</p>
<pre><code>$ git status
On branch master
Changes not staged for commit:
  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

	deleted:    test.txt

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre>
<p>现在你有两个选择，一是确实要从版本库中删除该文件，那就<strong>用命令git rm删掉</strong>，并且<strong>git commit</strong>：</p>
<pre><code>$ git rm test.txt
rm 'test.txt'

$ git commit -m &quot;remove test.txt&quot;
[master d46f35e] remove test.txt
 1 file changed, 1 deletion(-)
 delete mode 100644 test.txt
</code></pre>
<p>现在，文件就从版本库中被删除了。</p>
<p>小提示：先手动删除文件，然后使用<code>git rm &lt;file&gt;</code>和<code>git add&lt;file&gt;</code>效果是一样的。</p>
<h3 id="恢复删除文件">恢复删除文件</h3>
<p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p>
<p>注意此处是只是add，而没有commit！</p>
<pre><code>$ git checkout -- test.txt
</code></pre>
<p>git checkout其实是<strong>用版本库里的版本替换工作区的版本</strong>，无论工作区是修改还是删除，都可以“一键还原”。</p>
<p>注意：<strong>从来没有被添加到版本库就被删除的文件，是无法恢复的</strong>！</p>
<h3 id="小结-4">小结</h3>
<p>命令git rm用于删除一个文件。<strong>如果一个文件已经被提交到版本库，那么你永远不用担心误删</strong>，但是要小心，你只能恢复文件到最新版本，你<strong>会丢失最近一次提交后你修改的内容</strong>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git - 简介]]></title>
        <id>https://lixin-scut.github.io//post/git-jian-jie</id>
        <link href="https://lixin-scut.github.io//post/git-jian-jie">
        </link>
        <updated>2020-05-11T06:26:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="集中式vs分布式">集中式vs分布式</h2>
<p>CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统</p>
<h3 id="集中式版本控制系统">集中式版本控制系统</h3>
<p>集中式版本控制系统的版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。</p>
<p>集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟</p>
<h3 id="分布式版本控制系统">分布式版本控制系统</h3>
<p>首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。</p>
<p>既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p>
<p>和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。</p>
<p>在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，<strong>分布式版本控制系统通常也有一台充当“中央服务器”的电脑</strong>，但这个服务器的作用<strong>仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已</strong>。</p>
<h2 id="安装git">安装Git</h2>
<p><strong>在Linux上安装Git</strong></p>
<p>首先，你可以试着输入git，看看系统有没有安装Git：</p>
<pre><code>$ git
The program 'git' is currently not installed. You can install it by typing:
sudo apt-get install git
</code></pre>
<p>像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。</p>
<p>如果你碰巧用Debian或Ubuntu Linux，通过一条sudo apt-get install git就可以直接完成Git的安装，非常简单。</p>
<p><strong>在Mac OS X上安装Git</strong></p>
<p>如果你正在使用Mac做开发，有两种安装Git的方法。</p>
<p>一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：http://brew.sh/。</p>
<p>第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。</p>
<p><strong>在Windows上安装Git</strong></p>
<p>在Windows上使用Git，可以从Git官网直接下载安装程序，然后按默认选项安装即可。</p>
<p>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</p>
<p>安装完成后，还需要最后一步设置，在命令行输入：</p>
<pre><code>$ git config --global user.name &quot;Your Name&quot;
$ git config --global user.email &quot;email@example.com&quot;
</code></pre>
<p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。</p>
<p>注意git config命令的--global参数，用了这个参数，<strong>表示你这台机器上所有的Git仓库都会使用这个配置</strong>，当然也可以对某个仓库指定不同的用户名和Email地址。</p>
<h2 id="创建版本库">创建版本库</h2>
<p>版本库又名仓库，英文名repository，你可以<strong>简单理解成一个目录</strong>，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>
<p>创建一个版本库：</p>
<ol>
<li>首先，选择一个合适的地方，创建一个空目录：</li>
</ol>
<pre><code>$ mkdir learngit
$ cd learngit
$ pwd
/Users/michael/learngit
</code></pre>
<p>pwd命令用于显示当前目录。</p>
<ol start="2">
<li>第二步，通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：</li>
</ol>
<pre><code>$ git init
Initialized empty Git repository in /Users/michael/learngit/.git/
</code></pre>
<p>瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository）<br>
可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，<strong>没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</strong></p>
<p>如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用<code>ls -ah</code>命令就可以看见。</p>
<h3 id="把文件添加到版本库">把文件添加到版本库</h3>
<p>首先这里再明确一下，所有的版本控制系统，其实<strong>只能跟踪文本文件的改动</strong>，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统<strong>可以告诉你每次的改动</strong>，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，<strong>虽然也能由版本控制系统管理，但没法跟踪文件的变化</strong>，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p>
<p>不幸的是，Microsoft的Word格式是<strong>二进制格式</strong>，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示<br>
<strong>如果要真正使用版本控制系统，就要以纯文本方式编写文件</strong>。</p>
<p>因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用<strong>标准的UTF-8编码</strong>，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</p>
<p><strong>使用Windows要特别注意：</strong></p>
<p>千万不要使用Windows自带的记事本编辑任何文本文件。原因是Microsoft开发记事本的团队在每个文件开头添加了0xefbbbf（十六进制）的字符来保存UTF-8编码的文件，会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，建议下载Notepad++代替记事本，并把Notepad++的默认编码设置为UTF-8 without BOM</p>
<p>现在编写一个readme.txt文件，放到learngit目录下（子目录也行），因为这是一个Git仓库。</p>
<p><strong>把一个文件放到Git仓库只需要两步</strong></p>
<ol>
<li>第一步，用<strong>命令git add</strong>告诉Git，把文件添加到仓库：</li>
</ol>
<pre><code>$ git add readme.txt
</code></pre>
<p>执行上面的命令，没有任何显示，这就对了，<strong>Unix的哲学是“没有消息就是好消息”</strong>，说明添加成功。</p>
<ol start="2">
<li>第二步，用<strong>命令git commit</strong>告诉Git，把文件提交到仓库：</li>
</ol>
<pre><code>$ git commit -m &quot;wrote a readme file&quot;
[master (root-commit) eaadf4e] wrote a readme file
 1 file changed, 2 insertions(+)
 create mode 100644 readme.txt
</code></pre>
<p>简单解释一下git commit命令，<strong>-m后面输入的是本次提交的说明</strong>，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p>
<p>嫌麻烦不想输入-m &quot;xxx&quot;行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。</p>
<p>git commit命令执行成功后会告诉你，<br>
<code>1 file changed</code>：1个文件被改动（我们新添加的readme.txt文件）；<br>
<code>2 insertions</code>：插入了两行内容（readme.txt有两行内容）。</p>
<p>为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：</p>
<pre><code>$ git add file1.txt
$ git add file2.txt file3.txt
$ git commit -m &quot;add 3 files.&quot;
</code></pre>
<h3 id="小结">小结</h3>
<p>初始化一个Git仓库，使用git init命令。</p>
<p>添加文件到Git仓库，分两步：</p>
<ol>
<li>使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；</li>
<li>使用命令<code>git commit -m &lt;message&gt;</code>，完成。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Python - 面向对象高级编程]]></title>
        <id>https://lixin-scut.github.io//post/python-mian-xiang-dui-xiang-gao-ji-bian-cheng</id>
        <link href="https://lixin-scut.github.io//post/python-mian-xiang-dui-xiang-gao-ji-bian-cheng">
        </link>
        <updated>2020-05-10T12:48:52.000Z</updated>
        <content type="html"><![CDATA[<h2 id="__slots__"><code>__slots__</code></h2>
<p>正常情况下，当我们定义了一个class，创建了一个class的实例后，我们可以给该实例绑定任何属性和方法，这就是动态语言的灵活性。先定义class：</p>
<pre><code>class Student(object):
    pass
</code></pre>
<p>然后，尝试<strong>给实例绑定一个属性</strong>：</p>
<pre><code>&gt;&gt;&gt; s = Student()
&gt;&gt;&gt; s.name = 'Michael' # 动态给实例绑定一个属性
&gt;&gt;&gt; print(s.name)
Michael
</code></pre>
<p>还可以尝试<strong>给实例绑定一个方法</strong>：</p>
<pre><code>&gt;&gt;&gt; def set_age(self, age): # 定义一个函数作为实例方法
...     self.age = age
...
&gt;&gt;&gt; from types import MethodType
&gt;&gt;&gt; s.set_age = MethodType(set_age, s) # 给实例绑定一个方法
&gt;&gt;&gt; s.set_age(25) # 调用实例方法
&gt;&gt;&gt; s.age # 测试结果
25
</code></pre>
<p>但是明显地，<strong>给一个实例绑定的方法，对另一个实例是不起作用的</strong>：</p>
<pre><code>&gt;&gt;&gt; s2 = Student() # 创建新的实例
&gt;&gt;&gt; s2.set_age(25) # 尝试调用方法
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'Student' object has no attribute 'set_age'
</code></pre>
<p><strong>为了给所有实例都绑定方法，可以给class绑定方法</strong>：</p>
<pre><code>&gt;&gt;&gt; def set_score(self, score):
...     self.score = score
...
&gt;&gt;&gt; Student.set_score = set_score
</code></pre>
<p><strong>给class绑定方法后，所有实例均可调用</strong>：</p>
<pre><code>&gt;&gt;&gt; s.set_score(100)
&gt;&gt;&gt; s.score
100
&gt;&gt;&gt; s2.set_score(99)
&gt;&gt;&gt; s2.score
99
</code></pre>
<p>通常情况下，上面的set_score方法可以直接定义在class中，但<strong>动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言中很难实现</strong>。</p>
<h3 id="使用__slots__">使用__slots__</h3>
<p>但是，如果我们想要限制实例的属性，比如只允许对Student实例添加name和age属性。</p>
<p>为了达到限制的目的，Python允许在定义class的时候，<strong>定义一个特殊的slots变量，来限制该class实例能添加的属性</strong>：</p>
<pre><code>class Student(object):
    __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称
</code></pre>
<p>用tuple定义允许绑定的属性名称<br>
然后，我们试试：</p>
<pre><code>&gt;&gt;&gt; s = Student() # 创建新的实例
&gt;&gt;&gt; s.name = 'Michael' # 绑定属性'name'
&gt;&gt;&gt; s.age = 25 # 绑定属性'age'
&gt;&gt;&gt; s.score = 99 # 绑定属性'score'
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'Student' object has no attribute 'score'
</code></pre>
<p><strong>由于'score'没有被放到slots中，所以不能绑定score属性，试图绑定score将得到AttributeError的错误。</strong></p>
<p>使用__slots__要注意，<code>__slots__</code>定义的属性<strong>仅对当前类的实例起作用</strong>，<strong>对继承的子类是不起作用的</strong>：</p>
<pre><code>&gt;&gt;&gt; class GraduateStudent(Student):
...     pass
...
&gt;&gt;&gt; g = GraduateStudent()
&gt;&gt;&gt; g.score = 9999
</code></pre>
<p><strong>除非在子类中也定义__slots__</strong>，这样，子类实例允许定义的属性就是<strong>自身的__slots__加上父类的__slots__</strong>。</p>
<h2 id="使用property">使用@property</h2>
<p>在绑定属性时，如果直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数，导致可以把成绩随便改：</p>
<pre><code>s = Student()
s.score = 9999
</code></pre>
<p>这显然不合逻辑。为了限制score的范围，可以通过一个set_score()方法来设置成绩，再通过一个get_score()来获取成绩，这样，在set_score()方法里，就可以检查参数：</p>
<pre><code>class Student(object):

    def get_score(self):
         return self._score

    def set_score(self, value):
        if not isinstance(value, int):
            raise ValueError('score must be an integer!')
        if value &lt; 0 or value &gt; 100:
            raise ValueError('score must between 0 ~ 100!')
        self._score = value
</code></pre>
<p>现在，对任意的Student实例进行操作，就不能随心所欲地设置score了：</p>
<pre><code>&gt;&gt;&gt; s = Student()
&gt;&gt;&gt; s.set_score(60) # ok!
&gt;&gt;&gt; s.get_score()
60
&gt;&gt;&gt; s.set_score(9999)
Traceback (most recent call last):
  ...
ValueError: score must between 0 ~ 100!
</code></pre>
<p>但是，上面的调用方法又略显复杂，没有直接用属性这么直接简单。</p>
<p>有没有既能检查参数，又可以用类似属性这样简单的方式来访问类的变量？</p>
<p>还记得装饰器（decorator）可以给函数动态加上功能吗？<strong>对于类的方法，装饰器一样起作用</strong>。Python内置的**@property装饰器<strong>就是</strong>负责把一个方法变成属性调用**的：</p>
<pre><code>class Student(object):

    @property
    def score(self):
        return self._score

    @score.setter
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError('score must be an integer!')
        if value &lt; 0 or value &gt; 100:
            raise ValueError('score must between 0 ~ 100!')
        self._score = value
</code></pre>
<p>@property的实现比较复杂，我们先考察如何使用。<strong>把一个getter方法变成属性，只需要加上@property就可以了</strong>，此时，<strong>@property本身又创建了另一个装饰器@score.setter</strong>，负责把一个<strong>setter方法变成属性赋值</strong>，于是，我们就拥有一个可控的属性操作：</p>
<pre><code>&gt;&gt;&gt; s = Student()
&gt;&gt;&gt; s.score = 60 # OK，实际转化为s.set_score(60)
&gt;&gt;&gt; s.score # OK，实际转化为s.get_score()
60
&gt;&gt;&gt; s.score = 9999
Traceback (most recent call last):
  ...
ValueError: score must between 0 ~ 100!
</code></pre>
<p>注意到这个神奇的@property，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过getter和setter方法来实现的。</p>
<p>还可以定义<strong>只读属性，只定义getter方法，不定义setter方法就是一个只读属性</strong>：</p>
<pre><code>class Student(object):

    @property
    def birth(self):
        return self._birth

    @birth.setter
    def birth(self, value):
        self._birth = value

    @property
    def age(self):
        return 2015 - self._birth
</code></pre>
<p>上面的birth是可读写属性，而<strong>age就是一个只读属性，因为age可以根据birth和当前时间计算出来</strong>。</p>
<h3 id="小结">小结</h3>
<p>@property广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性。</p>
<h2 id="多重继承">多重继承</h2>
<p>继承是面向对象编程的一个重要的方式，因为通过继承，子类就可以扩展父类的功能。</p>
<p>回忆一下Animal类层次的设计，假设我们要实现以下4种动物：</p>
<p>Dog - 狗狗；<br>
Bat - 蝙蝠；<br>
Parrot - 鹦鹉；<br>
Ostrich - 鸵鸟。<br>
如果按照哺乳动物和鸟类归类，我们可以设计出这样的类的层次：</p>
<pre><code>
                ┌───────────────┐
                │    Animal     │
                └───────────────┘
                        │
           ┌────────────┴────────────┐
           │                         │
           ▼                         ▼
    ┌─────────────┐           ┌─────────────┐
    │   Mammal    │           │    Bird     │
    └─────────────┘           └─────────────┘
           │                         │
     ┌─────┴──────┐            ┌─────┴──────┐
     │            │            │            │
     ▼            ▼            ▼            ▼
┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
│   Dog   │  │   Bat   │  │ Parrot  │  │ Ostrich │
└─────────┘  └─────────┘  └─────────┘  └─────────┘
</code></pre>
<p>但是如果按照“能跑”和“能飞”来归类，我们就应该设计出这样的类的层次：</p>
<pre><code>
                ┌───────────────┐
                │    Animal     │
                └───────────────┘
                        │
           ┌────────────┴────────────┐
           │                         │
           ▼                         ▼
    ┌─────────────┐           ┌─────────────┐
    │  Runnable   │           │   Flyable   │
    └─────────────┘           └─────────────┘
           │                         │
     ┌─────┴──────┐            ┌─────┴──────┐
     │            │            │            │
     ▼            ▼            ▼            ▼
┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
│   Dog   │  │ Ostrich │  │ Parrot  │  │   Bat   │
└─────────┘  └─────────┘  └─────────┘  └─────────┘
</code></pre>
<p>如果要把上面的两种分类都包含进来，我们就得设计更多的层次：</p>
<p>哺乳类：能跑的哺乳类，能飞的哺乳类；<br>
鸟类：能跑的鸟类，能飞的鸟类。<br>
这么一来，类的层次就复杂了：</p>
<pre><code>
                ┌───────────────┐
                │    Animal     │
                └───────────────┘
                        │
           ┌────────────┴────────────┐
           │                         │
           ▼                         ▼
    ┌─────────────┐           ┌─────────────┐
    │   Mammal    │           │    Bird     │
    └─────────────┘           └─────────────┘
           │                         │
     ┌─────┴──────┐            ┌─────┴──────┐
     │            │            │            │
     ▼            ▼            ▼            ▼
┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
│  MRun   │  │  MFly   │  │  BRun   │  │  BFly   │
└─────────┘  └─────────┘  └─────────┘  └─────────┘
     │            │            │            │
     │            │            │            │
     ▼            ▼            ▼            ▼
┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
│   Dog   │  │   Bat   │  │ Ostrich │  │ Parrot  │
└─────────┘  └─────────┘  └─────────┘  └─────────┘

</code></pre>
<p>如果要再增加“宠物类”和“非宠物类”，这么搞下去，类的数量会呈指数增长，很明显这样设计是不行的。</p>
<p>正确的做法是采用多重继承。首先，主要的类层次仍按照哺乳类和鸟类设计：</p>
<pre><code>class Animal(object):
    pass

# 大类:
class Mammal(Animal):
    pass

class Bird(Animal):
    pass

# 各种动物:
class Dog(Mammal):
    pass

class Bat(Mammal):
    pass

class Parrot(Bird):
    pass

class Ostrich(Bird):
    pass
</code></pre>
<p>现在，我们要给动物再加上Runnable和Flyable的功能，只需要先定义好Runnable和Flyable的类：</p>
<pre><code>class Runnable(object):
    def run(self):
        print('Running...')

class Flyable(object):
    def fly(self):
        print('Flying...')
</code></pre>
<p>对于需要Runnable功能的动物，就多继承一个Runnable，例如Dog：</p>
<pre><code>class Dog(Mammal, Runnable):
    pass
</code></pre>
<p>对于需要Flyable功能的动物，就多继承一个Flyable，例如Bat：</p>
<pre><code>class Bat(Mammal, Flyable):
    pass
</code></pre>
<p><strong>通过多重继承，一个子类就可以同时获得多个父类的所有功能</strong>。</p>
<h3 id="mixin">MixIn</h3>
<p>自己的理解：</p>
<ol>
<li><strong>多继承是多继承，MixIn 是 MixIn，为啥要放一块比较，MixIn 是基于多继承实现的一种设计模式，一般是将复杂类的一些功能拆分出来，不用__init__初始化方法，不让其单独工作，只用作混入其他类使用</strong></li>
<li><strong>最后得出的结论继承和MixIn之间的关系就像，一颗大树，继承就好比树干一直到最粗的那一根树枝的末梢，然后MixIn就像那些小的枝丫，给这根最粗的树枝和树干做装饰用的，觉得少了什么东西就可以写一个mixin，然后让子类“继承”它，不过这个后写的东西它里面装的始终是装饰（比如写一个常用的函数，然后一旦需要调用这个函数了就直接在子类里面把它加上就好啦），主要继承的父类还和单继承没啥区别</strong></li>
</ol>
<p>在设计类的继承关系时，通常，主线都是单一继承下来的，例如，Ostrich继承自Bird。但是，<strong>如果需要“混入”额外的功能，通过多重继承就可以实现</strong>，比如，让Ostrich除了继承自Bird外，再同时继承Runnable。<strong>这种设计通常称之为MixIn</strong>。</p>
<p>为了更好地看出继承关系，我们把Runnable和Flyable改为RunnableMixIn和FlyableMixIn。类似的，你还可以定义出肉食动物CarnivorousMixIn和植食动物HerbivoresMixIn，让某个动物同时拥有好几个MixIn：</p>
<pre><code>class Dog(Mammal, RunnableMixIn, CarnivorousMixIn):
    pass
</code></pre>
<p><strong>MixIn的目的就是给一个类增加多个功能</strong>，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。</p>
<p>Python自带的很多库也使用了MixIn。举个例子，Python自带了TCPServer和UDPServer这两类网络服务，而要同时服务多个用户就必须使用多进程或多线程模型，这两种模型由ForkingMixIn和ThreadingMixIn提供。通过组合，我们就可以创造出合适的服务来。</p>
<p>比如，编写一个多进程模式的TCP服务，定义如下：</p>
<pre><code>class MyTCPServer(TCPServer, ForkingMixIn):
    pass
</code></pre>
<p>编写一个多线程模式的UDP服务，定义如下：</p>
<pre><code>class MyUDPServer(UDPServer, ThreadingMixIn):
    pass
</code></pre>
<p>如果你打算搞一个更先进的协程模型，可以编写一个CoroutineMixIn：</p>
<pre><code>class MyTCPServer(TCPServer, CoroutineMixIn):
    pass
</code></pre>
<p>这样一来，我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类。</p>
<h3 id="小结-2">小结</h3>
<p>由于Python允许使用多重继承，因此，MixIn就是一种常见的设计。</p>
<p><strong>只允许单一继承的语言（如Java）不能使用MixIn的设计</strong>。</p>
<p>C++也允许单一继承，但是存在菱形继承的问题</p>
<h2 id="定制类">定制类</h2>
<p>看到<strong>类似__slots__这种形如__xxx__的变量或者函数名</strong>就要注意，这些在Python中是有<strong>特殊用途</strong>的。</p>
<p><code>__slots__</code>我们已经知道怎么用了，<code>__len__()</code>方法我们也知道是为了能让class作用于len()函数。</p>
<p>除此之外，Python的class中还有许多这样有特殊用途的函数，可以帮助我们定制类。</p>
<h3 id="__str__"><code>__str__</code></h3>
<p>我们先定义一个Student类，打印一个实例：</p>
<pre><code>&gt;&gt;&gt; class Student(object):
...     def __init__(self, name):
...         self.name = name
...
&gt;&gt;&gt; print(Student('Michael'))
&lt;__main__.Student object at 0x109afb190&gt;
</code></pre>
<p>打印出一堆<code>&lt;__main__.Student object at 0x109afb190&gt;</code>，不好看。</p>
<p>怎么才能打印得好看呢？只需要定义好__str__()方法，返回一个好看的字符串就可以了：</p>
<pre><code>&gt;&gt;&gt; class Student(object):
...     def __init__(self, name):
...         self.name = name
...     def __str__(self):
...         return 'Student object (name: %s)' % self.name
...
&gt;&gt;&gt; print(Student('Michael'))
Student object (name: Michael)
</code></pre>
<p>这样打印出来的实例，不但好看，而且容易看出实例内部重要的数据。</p>
<p>但如果直接输出变量而不用print，打印出来的实例还是不好看：</p>
<pre><code>&gt;&gt;&gt; s = Student('Michael')
&gt;&gt;&gt; s
&lt;__main__.Student object at 0x109afb310&gt;
</code></pre>
<p>这是因为直接显示变量调用的不是<code>__str__()</code>，而是<code>__repr__()</code>，两者的区别是<code>__str__()</code>返回<strong>用户</strong>看到的字符串，而<code>__repr__()</code>返回<strong>程序开发者</strong>看到的字符串，也就是说，<code>__repr__()</code>是为<strong>调试服务的</strong>。</p>
<p>解决办法是再定义一个__repr__()。但是通常__str__()和__repr__()代码都是一样的，所以，有个偷懒的写法：</p>
<pre><code>class Student(object):
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return 'Student object (name=%s)' % self.name
    __repr__ = __str__
</code></pre>
<h3 id="__iter__"><code>__iter__</code></h3>
<p>如果<strong>一个类想被用于for ... in循环</strong>，类似list或tuple那样，就必须实现一个__iter__()方法<br>
<code>__iter__()</code>方法返回一个迭代对象，然后，Python的for循环就会<strong>不断调用该迭代对象的__next__()方法</strong>拿到循环的下一个值，直到遇到StopIteration错误时退出循环。</p>
<p>我们以斐波那契数列为例，写一个Fib类，可以作用于for循环：</p>
<pre><code>class Fib(object):
    def __init__(self):
        self.a, self.b = 0, 1 # 初始化两个计数器a，b

    def __iter__(self):
        return self # 实例本身就是迭代对象，故返回自己

    def __next__(self):
        self.a, self.b = self.b, self.a + self.b # 计算下一个值
        if self.a &gt; 100000: # 退出循环的条件
            raise StopIteration()
        return self.a # 返回下一个值
</code></pre>
<p>现在，试试把Fib实例作用于for循环：</p>
<pre><code>&gt;&gt;&gt; for n in Fib():
...     print(n)
...
1
1
2
3
5
...
46368
75025
</code></pre>
<h3 id="__getitem__"><code>__getitem__</code></h3>
<p>Fib实例虽然能作用于for循环，看起来和list有点像，但是，把它当成list来使用还是不行，比如，取第5个元素：</p>
<pre><code>&gt;&gt;&gt; Fib()[5]
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: 'Fib' object does not support indexing
</code></pre>
<p>要表现得像list那样按照下标取出元素，需要实现__getitem__()方法：</p>
<pre><code>class Fib(object):
    def __getitem__(self, n):
        a, b = 1, 1
        for x in range(n):
            a, b = b, a + b
        return a
</code></pre>
<p>现在，就可以按下标访问数列的任意一项了：</p>
<pre><code>&gt;&gt;&gt; f = Fib()
&gt;&gt;&gt; f[0]
1
&gt;&gt;&gt; f[1]
1
&gt;&gt;&gt; f[2]
2
&gt;&gt;&gt; f[3]
3
&gt;&gt;&gt; f[10]
89
&gt;&gt;&gt; f[100]
573147844013817084101
</code></pre>
<p>但是list有个神奇的切片方法：</p>
<pre><code>&gt;&gt;&gt; list(range(100))[5:10]
[5, 6, 7, 8, 9]
</code></pre>
<p>对于Fib却报错。原因是__getitem__()传入的参数可能是一个int，也可能是一个切片对象slice，所以要做判断：</p>
<pre><code>class Fib(object):
    def __getitem__(self, n):
        if isinstance(n, int): # n是索引
            a, b = 1, 1
            for x in range(n):
                a, b = b, a + b
            return a
        if isinstance(n, slice): # n是切片
            start = n.start
            stop = n.stop
						# 如果start为空，则默认为0
            if start is None:
                start = 0
            a, b = 1, 1
            L = []
            for x in range(stop):
                if x &gt;= start:
                    L.append(a)
                a, b = b, a + b
            return L
</code></pre>
<p>现在试试Fib的切片：</p>
<pre><code>&gt;&gt;&gt; f = Fib()
&gt;&gt;&gt; f[0:5]
[1, 1, 2, 3, 5]
&gt;&gt;&gt; f[:10]
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
</code></pre>
<p>但是没有对step参数作处理：</p>
<pre><code>&gt;&gt;&gt; f[:10:2]
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
</code></pre>
<p>也没有对负数作处理，所以，要正确实现一个<code>__getitem__()</code>还是有很多工作要做的。</p>
<p>此外，如果把对象看成dict，<code>__getitem__()</code>的参数也可能是一个可以作key的object，例如str。</p>
<p>与之对应的是<code>__setitem__()</code>方法，把对象视作list或dict来对集合赋值。最后，还有一个<code>__delitem__()</code>方法，用于删除某个元素。</p>
<p>总之，<strong>通过上面的方法，我们自己定义的类表现得和Python自带的list、tuple、dict没什么区别</strong>，这完全归功于<strong>动态语言的“鸭子类型”</strong>，不需要强制继承某个接口。</p>
<h3 id="__getattr__"><code>__getattr__</code></h3>
<p>正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。比如定义Student类：</p>
<pre><code>class Student(object):
    
    def __init__(self):
        self.name = 'Michael'
</code></pre>
<p>调用name属性正常，但是，调用不存在的score属性，就有问题了：</p>
<pre><code>&gt;&gt;&gt; s = Student()
&gt;&gt;&gt; print(s.name)
Michael
&gt;&gt;&gt; print(s.score)
Traceback (most recent call last):
  ...
AttributeError: 'Student' object has no attribute 'score'
</code></pre>
<p>错误信息很清楚地告诉我们，没有找到score这个attribute。</p>
<p>要避免这个错误，除了可以加上一个score属性外，Python还有另一个机制，那就是<strong>写一个<code>__getattr__()</code>方法，动态返回一个属性</strong>。修改如下：</p>
<pre><code>class Student(object):

    def __init__(self):
        self.name = 'Michael'

    def __getattr__(self, attr):
        if attr=='score':
            return 99
</code></pre>
<p>当调用不存在的属性时，比如score，Python解释器会试图调用__getattr__(self, 'score')来尝试获得属性，这样，我们就有机会返回score的值：</p>
<pre><code>&gt;&gt;&gt; s = Student()
&gt;&gt;&gt; s.name
'Michael'
&gt;&gt;&gt; s.score
99
</code></pre>
<p>返回函数也是完全可以的：</p>
<pre><code>class Student(object):

    def __getattr__(self, attr):
        if attr=='age':
            return lambda: 25
</code></pre>
<p>只是调用方式要变为：</p>
<pre><code>&gt;&gt;&gt; s.age()
25
</code></pre>
<p>注意，<strong>只有在没有找到属性的情况下，才调用__getattr__，已有的属性，比如name，不会在__getattr__中查找</strong>。</p>
<p>此外，<strong>如果定义了__getattr__，那么如果调用没有在__getattr__中找到相应的属性</strong>，如s.abc都会返回None，这是<strong>因为我们定义的__getattr__默认返回就是None</strong>。要让class只响应特定的几个属性，我们就要按照约定，抛出AttributeError的错误：</p>
<pre><code>class Student(object):

    def __getattr__(self, attr):
        if attr=='age':
            return lambda: 25
        raise AttributeError('\'Student\' object has no attribute \'%s\'' % attr)
</code></pre>
<p>这实际上可以<strong>把一个类的所有属性和方法调用全部动态化处理</strong>了，不需要任何特殊手段。</p>
<p>这种完全动态调用的特性有什么实际作用呢？作用就是，可以针对完全动态的情况作调用。</p>
<p>举个例子：</p>
<p>现在很多网站都搞REST API，比如新浪微博、豆瓣啥的，调用API的URL类似：</p>
<p>http://api.server/user/friends<br>
http://api.server/user/timeline/list<br>
如果要写SDK，给每个URL对应的API都写一个方法，那得累死，而且，API一旦改动，SDK也要改。</p>
<p><strong>利用完全动态的__getattr__，我们可以写出一个链式调用</strong>：</p>
<pre><code>class Chain(object):

    def __init__(self, path=''):
        self._path = path

    def __getattr__(self, path):
        return Chain('%s/%s' % (self._path, path))

    def __str__(self):
        return self._path

    __repr__ = __str__

&gt;&gt;&gt; Chain().status.user.timeline.list
'/status/user/timeline/list'
</code></pre>
<p>这样，无论API怎么变，SDK都可以根据URL实现完全动态的调用，而且，不随API的增加而改变！</p>
<p>还有些REST API会把参数放到URL中，比如GitHub的API：</p>
<pre><code>GET /users/:user/repos
</code></pre>
<p>调用时，需要把:user替换为实际用户名。如果我们能写出这样的链式调用：</p>
<pre><code>Chain().users('michael').repos
</code></pre>
<pre><code># 实现代码
class Chain(object):
    def __init__(self, path=''):
       self.__path = path

   def __getattr__(self, path):
       return Chain('%s/%s' % (self.__path, path))

   def __call__(self, path):
       return Chain('%s/%s' % (self.__path, path))

   def __str__(self):
       return self.__path

   __repr__ = __str__

print(Chain().users('michael').repos)
/users/michael/repos
</code></pre>
<p>就可以非常方便地调用API了。</p>
<h3 id="__call__"><code>__call__</code></h3>
<p>一个对象实例可以有自己的属性和方法，当我们调用实例方法时，我们用instance.method()来调用。但同时也能直接在实例本身上调用</p>
<p><strong>任何类，只需要定义一个__call__()方法，就可以直接对实例进行调用</strong>。请看示例：</p>
<pre><code>class Student(object):
    def __init__(self, name):
        self.name = name

    def __call__(self):
        print('My name is %s.' % self.name)
</code></pre>
<p>调用方式如下：</p>
<pre><code>&gt;&gt;&gt; s = Student('Michael')
&gt;&gt;&gt; s() # self参数不要传入
My name is Michael.
</code></pre>
<p><code>__call__()</code><strong>还可以定义参数</strong>。对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。</p>
<p>如果你把<strong>对象看成函数</strong>，那么函数本身其实也可以<strong>在运行期动态创建出来</strong>，因为类的实例都是运行期创建出来的，这么一来，我们就模糊了对象和函数的界限。</p>
<p>那么，<strong>怎么判断一个变量是对象还是函数</strong>呢？其实，更多的时候，我们需要判断一个对象是否能被调用，<strong>能被调用的对象就是一个Callable对象</strong>，比如函数和我们上面定义的带有__call__()的类实例：</p>
<pre><code>&gt;&gt;&gt; callable(Student())
True
&gt;&gt;&gt; callable(max)
True
&gt;&gt;&gt; callable([1, 2, 3])
False
&gt;&gt;&gt; callable(None)
False
&gt;&gt;&gt; callable('str')
False
</code></pre>
<p><strong>通过callable()函数，我们就可以判断一个对象是否是“可调用”对象。</strong></p>
<h2 id="枚举类">枚举类</h2>
<p>当我们<strong>需要定义常量时，一个办法是用大写变量通过整数来定义</strong>，例如月份：</p>
<pre><code>JAN = 1
FEB = 2
MAR = 3
...
NOV = 11
DEC = 12
</code></pre>
<p>好处是简单，缺点是类型是int，并且仍然是变量。</p>
<p>更好的方法是为这样的<strong>枚举类型定义一个class类型</strong>，然后，每个常量都是class的一个唯一实例。Python提供了<strong>Enum类</strong>来实现这个功能：</p>
<pre><code>from enum import Enum

Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))
</code></pre>
<p>这样我们就获得了Month类型的枚举类，可以直接使用Month.Jan来引用一个常量，或者枚举它的所有成员：</p>
<pre><code>for name, member in Month.__members__.items():
    print(name, '=&gt;', member, ',', member.value)
</code></pre>
<p>特殊属性<code>__members__</code>是一个将名称映射到成员的有序字典，也可以通过它来完成遍历</p>
<p>value属性则是自动赋给成员的int常量，<strong>默认从1开始计数</strong>。<br>
<strong>注意不是从0开始！！！</strong></p>
<p>如果需要<strong>更精确地控制枚举类型</strong>，可以<strong>从Enum派生出自定义类</strong>：</p>
<pre><code>from enum import Enum, unique

@unique
class Weekday(Enum):
    Sun = 0 # Sun的value被设定为0
    Mon = 1
    Tue = 2
    Wed = 3
    Thu = 4
    Fri = 5
    Sat = 6
</code></pre>
<p>@unique装饰器可以帮助我们检查保证没有重复值。</p>
<p>访问这些枚举类型可以有若干种方法：</p>
<pre><code>
&gt;&gt;&gt; day1 = Weekday.Mon
&gt;&gt;&gt; print(day1)
Weekday.Mon
&gt;&gt;&gt; print(Weekday.Tue)
Weekday.Tue
&gt;&gt;&gt; print(Weekday['Tue'])
Weekday.Tue

&gt;&gt;&gt; print(Weekday.Tue.value)
2

&gt;&gt;&gt; print(day1 == Weekday.Mon)
True
&gt;&gt;&gt; print(day1 == Weekday.Tue)
False

&gt;&gt;&gt; print(Weekday(1))
Weekday.Mon
&gt;&gt;&gt; print(day1 == Weekday(1))
True

&gt;&gt;&gt; Weekday(7)
Traceback (most recent call last):
  ...
ValueError: 7 is not a valid Weekday

&gt;&gt;&gt; for name, member in Weekday.__members__.items():
...     print(name, '=&gt;', member)
...
Sun =&gt; Weekday.Sun
Mon =&gt; Weekday.Mon
Tue =&gt; Weekday.Tue
Wed =&gt; Weekday.Wed
Thu =&gt; Weekday.Thu
Fri =&gt; Weekday.Fri
Sat =&gt; Weekday.Sat
</code></pre>
<p>可见，既可以<strong>用成员名称引用枚举常量</strong>，又可以<strong>直接根据value的值获得枚举常量</strong>。</p>
<p>网友评论：推荐直接看这个讲解枚举的链接https://segmentfault.com/a/1190000017327003</p>
<h3 id="使用-enum">使用 Enum</h3>
<p>更好的方式是使用标准库提供的 Enum 类型，官方库值得信赖。3.4 之前的版本也可以通过 pip install enum 下载支持的库。简单的示例：</p>
<pre><code>from enum import Enum
class Color(Enum):
    red = 1
    green = 2
    blue = 3
</code></pre>
<p>枚举成员有值（默认可重复），枚举成员具有友好的字符串表示：</p>
<pre><code>&gt;&gt;&gt; print(Color.red)
Color.red
&gt;&gt;&gt; print(repr(Color.red))
&lt;Color.red: 1&gt;
&gt;&gt;&gt; type(Color.red)
&lt;Enum 'Color'&gt;
&gt;&gt;&gt; isinstance(Color.green, Color)
True
</code></pre>
<p><strong>枚举类型不可实例化，不可更改</strong>。</p>
<h3 id="定义枚举">定义枚举</h3>
<p><strong>定义枚举时，成员名不允许重复</strong></p>
<pre><code>class Color(Enum):
    red = 1
    green = 2
    red = 3    # TypeError: Attempted to reuse key: 'red'
</code></pre>
<p><strong>成员值允许相同</strong>，<strong>第二个成员的名称被视作第一个成员的别名</strong></p>
<pre><code>class Color(Enum):
    red   = 1
    green = 2
    blue  = 1

print(Color.red)              # Color.red
print(Color.blue)             # Color.red
print(Color.red is Color.blue)# True
print(Color(1))               # Color.red  在通过值获取枚举成员时，只能获取到第一个成员
</code></pre>
<p><strong>若要不能定义相同的成员值，可以通过 unique 装饰</strong></p>
<pre><code>from enum import Enum, unique
@unique
class Color(Enum):
    red   = 1
    green = 2
    blue  = 1  # ValueError: duplicate values found in &lt;enum 'Color'&gt;: blue -&gt; red
</code></pre>
<h3 id="枚举取值">枚举取值</h3>
<p>可以通过成员名来获取成员也可以通过成员值来获取成员:</p>
<pre><code>print(Color['red'])  # Color.red  通过成员名来获取成员

print(Color(1))      # Color.red  通过成员值来获取成员
</code></pre>
<p>每个成员都有<strong>名称属性和值属性</strong>：</p>
<pre><code>member = Color.red
print(member.name)   # red
print(member.value)  # 1
</code></pre>
<p>支持迭代的方式遍历成员，按定义的顺序，如果有值重复的成员，只获取重复的第一个成员：</p>
<pre><code>for color in Color:
    print(color)
</code></pre>
<p>特殊属性<code>__members__</code>是一个<strong>将名称映射到成员的有序字典</strong>，也可以通过它来完成遍历：</p>
<pre><code>for color in Color.__members__.items():
    print(color)          # ('red', &lt;Color.red: 1&gt;)
</code></pre>
<h3 id="枚举比较">枚举比较</h3>
<p>枚举的成员可以通过<strong>is 同一性</strong>比较或<strong>通过 == 等值</strong>比较：</p>
<pre><code>Color.red is Color.red
Color.red is not Color.blue

Color.blue == Color.red
Color.blue != Color.red
</code></pre>
<p>枚举成员<strong>不能进行大小比较</strong>：</p>
<pre><code>
Color.red &lt; Color.blue 
# TypeError: unorderable types: Color() &lt; Color()
</code></pre>
<h3 id="扩展枚举-intenum">扩展枚举 IntEnum</h3>
<p>IntEnum 是 Enum 的扩展，<strong>不同类型的整数枚举也可以相互比较</strong>：</p>
<pre><code>from enum import IntEnum
class Shape(IntEnum):
    circle = 1
    square = 2

class Request(IntEnum):
    post = 1
    get = 2

print(Shape.circle == 1)            # True
print(Shape.circle &lt; 3)             # True
print(Shape.circle == Request.post) # True
print(Shape.circle &gt;= Request.post) # True
</code></pre>
<h2 id="使用元类">使用元类</h2>
<h3 id="type">type()</h3>
<p>动态语言和静态语言最大的不同，就是<strong>函数和类的定义</strong>，<strong>不是编译时定义的，而是运行时动态创建的</strong>。</p>
<p>比方说我们要定义一个Hello的class，就写一个hello.py模块：</p>
<pre><code>class Hello(object):
    def hello(self, name='world'):
        print('Hello, %s.' % name)
</code></pre>
<p>当Python解释器载入hello模块时，就会<strong>依次执行该模块的所有语句</strong>，执行结果就是<strong>动态创建出一个Hello的class对象</strong>，测试如下：</p>
<pre><code>&gt;&gt;&gt; from hello import Hello
&gt;&gt;&gt; h = Hello()
&gt;&gt;&gt; h.hello()
Hello, world.
&gt;&gt;&gt; print(type(Hello))
&lt;class 'type'&gt;
&gt;&gt;&gt; print(type(h))
&lt;class 'hello.Hello'&gt;
</code></pre>
<p>type()函数可以<strong>查看一个类型或变量的类型</strong>，Hello是一个<strong>class，它的类型就是type</strong>，而h是一个<strong>实例，它的类型就是class Hello</strong>。</p>
<p>我们说class的定义是运行时动态创建的，而<strong>创建class的方法就是使用type()函数</strong>。</p>
<p>type()函数既可以<strong>返回一个对象的类型</strong>，又可以<strong>创建出新的类型</strong>，比如，我们可以通过type()函数创建出Hello类，而<strong>无需通过class Hello(object)...的定义</strong>：</p>
<pre><code>&gt;&gt;&gt; def fn(self, name='world'): # 先定义函数
...     print('Hello, %s.' % name)
...
&gt;&gt;&gt; Hello = type('Hello', (object,), dict(hello=fn)) # 创建Hello class
&gt;&gt;&gt; h = Hello()
&gt;&gt;&gt; h.hello()
Hello, world.
&gt;&gt;&gt; print(type(Hello))
&lt;class 'type'&gt;
&gt;&gt;&gt; print(type(h))
&lt;class '__main__.Hello'&gt;
</code></pre>
<p>要创建一个class对象，type()函数依次传入3个参数：</p>
<ol>
<li>class的名称；</li>
<li>继承的父类集合，注意Python支持多重继承，如果<strong>只有一个父类，别忘了tuple的单元素写法</strong>；</li>
<li><strong>class的方法名称与函数绑定</strong>，这里我们把函数fn绑定到方法名hello上。</li>
</ol>
<p>通过type()函数创建的类和直接写class是完全一样的，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用type()函数创建出class。</p>
<p>正常情况下，我们都用class Xxx...来定义类，但是，<strong>type()函数也允许我们动态创建出类来</strong>，也就是说，<strong>动态语言本身支持运行期动态创建类</strong>，这和静态语言有非常大的不同，要在静态语言运行期创建类，必须构造源代码字符串再调用编译器，或者借助一些工具生成字节码实现，本质上都是动态编译，会非常复杂。</p>
<h3 id="metaclass">metaclass</h3>
<p>除了使用type()动态创建类以外，要<strong>控制类的创建行为</strong>，还可以使用metaclass。</p>
<p>metaclass，直译为元类，简单的解释就是：</p>
<p>当我们定义了类以后，就可以根据这个类创建出实例，所以：先定义类，然后创建实例。</p>
<p>但是如果我们<strong>想创建出类</strong>，那就必须根据metaclass创建出类，所以：<strong>先定义metaclass，然后创建类</strong>。</p>
<p>连接起来就是：先定义metaclass，就可以创建类，最后创建实例。</p>
<p>所以，metaclass允许你创建类或者修改类。换句话说，你<strong>可以把类看成是metaclass创建出来的“实例”</strong>。</p>
<p>metaclass是Python面向对象里最难理解，也是最难使用的魔术代码。正常情况下，你不会碰到需要使用metaclass的情况，所以，以下内容看不懂也没关系，因为基本上你不会用到。</p>
<p>我们先看一个简单的例子，这个metaclass可以给我们自定义的MyList增加一个add方法：</p>
<p>定义ListMetaclass，按照默认习惯，metaclass的类名总是以Metaclass结尾，以便清楚地表示这是一个metaclass：</p>
<pre><code>#metaclass是类的模板，所以必须从`type`类型派生：
class ListMetaclass(type):
    def __new__(cls, name, bases, attrs):
        attrs['add'] = lambda self, value: self.append(value)
        return type.__new__(cls, name, bases, attrs)
</code></pre>
<p>有了ListMetaclass，我们<strong>在定义类的时候还要指示使用ListMetaclass来定制类，传入关键字参数metaclass</strong>：</p>
<pre><code>class MyList(list, metaclass=ListMetaclass):
    pass
</code></pre>
<p>当我们传入关键字参数metaclass时，魔术就生效了，它指示Python解释器在<strong>创建MyList时，要通过<code>ListMetaclass. __new__()</code>来创建</strong><br>
在此之上，我们可以修改类的定义，比如，加上新的方法，然后，返回修改后的定义。</p>
<p><code>__new__()</code>方法接收到的参数依次是：</p>
<ol>
<li>
<p>当前准备创建的类的对象；</p>
</li>
<li>
<p>类的名字；</p>
</li>
<li>
<p>类继承的父类集合；</p>
</li>
<li>
<p>类的方法集合。</p>
</li>
</ol>
<p>测试一下MyList是否可以调用add()方法：</p>
<pre><code>&gt;&gt;&gt; L = MyList()
&gt;&gt;&gt; L.add(1)
&gt;&gt; L
[1]
</code></pre>
<p>而普通的list没有add()方法：</p>
<pre><code>&gt;&gt;&gt; L2 = list()
&gt;&gt;&gt; L2.add(1)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
	AttributeError: 'list' object has no attribute 'add'
</code></pre>
<p><strong>动态修改</strong>有什么意义？直接在MyList定义中写上add()方法不是更简单吗？正常情况下，确实应该直接写，通过metaclass修改纯属变态。</p>
<p>但是，<strong>总会遇到需要通过metaclass修改类定义的。ORM就是一个典型的例子</strong>。</p>
<p>ORM全称“Object Relational Mapping”，即<strong>对象-关系映射，就是把关系数据库的一行映射为一个对象，也就是一个类对应一个表</strong>，这样，写代码更简单，<strong>不用直接操作SQL语句</strong>。</p>
<p>要编写一个ORM框架，<strong>所有的类都只能动态定义，因为只有使用者才能根据表的结构定义出对应的类来</strong>。</p>
<p>让我们来尝试编写一个ORM框架。</p>
<p>编写底层模块的第一步，就是先把调用接口写出来。比如，使用者如果使用这个ORM框架，想定义一个User类来操作对应的数据库表User，我们期待他写出这样的代码：</p>
<pre><code>class User(Model):
    # 定义类的属性到列的映射：
    id = IntegerField('id')
    name = StringField('username')
    email = StringField('email')
    password = StringField('password')


# 创建一个实例：
u = User(id=12345, name='Michael', email='test@orm.org', password='my-pwd')
# 保存到数据库：
u.save()
</code></pre>
<p>其中，父类Model和属性类型StringField、IntegerField是由ORM框架提供的，剩下的魔术方法比如save()全部由metaclass自动完成。虽然metaclass的编写会比较复杂，但ORM的使用者用起来却异常简单。</p>
<p>现在，我们就按上面的接口来实现该ORM。</p>
<p>首先来定义Field类，它负责保存数据库表的字段名和字段类型：</p>
<pre><code>class Field(object):

    def __init__(self, name, column_type):
        self.name = name
        self.column_type = column_type

    def __str__(self):
        return '&lt;%s:%s&gt;' % (self.__class__.__name__, self.name)
</code></pre>
<p>在Field的基础上，进一步定义各种类型的Field，比如StringField，IntegerField等等：</p>
<pre><code>class StringField(Field):

    def __init__(self, name):
        super(StringField, self).__init__(name, 'varchar(100)')

class IntegerField(Field):

    def __init__(self, name):
        super(IntegerField, self).__init__(name, 'bigint')
</code></pre>
<p>下一步，就是编写最复杂的ModelMetaclass了：</p>
<pre><code>class ModelMetaclass(type):

    def __new__(cls, name, bases, attrs):
        if name=='Model':
            return type.__new__(cls, name, bases, attrs)
        print('Found model: %s' % name)
        mappings = dict()
        for k, v in attrs.items():
            if isinstance(v, Field):
                print('Found mapping: %s ==&gt; %s' % (k, v))
                mappings[k] = v
        for k in mappings.keys():
            attrs.pop(k)
        attrs['__mappings__'] = mappings # 保存属性和列的映射关系
        attrs['__table__'] = name # 假设表名和类名一致
        return type.__new__(cls, name, bases, attrs)
</code></pre>
<p>以及基类Model：</p>
<pre><code>class Model(dict, metaclass=ModelMetaclass):

    def __init__(self, **kw):
        super(Model, self).__init__(**kw)

    def __getattr__(self, key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(r&quot;'Model' object has no attribute '%s'&quot; % key)

    def __setattr__(self, key, value):
        self[key] = value

    def save(self):
        fields = []
        params = []
        args = []
        for k, v in self.__mappings__.items():
            fields.append(v.name)
            params.append('?')
            args.append(getattr(self, k, None))
        sql = 'insert into %s (%s) values (%s)' % (self.__table__, ','.join(fields), ','.join(params))
        print('SQL: %s' % sql)
        print('ARGS: %s' % str(args))
</code></pre>
<p>当用户定义一个class User(Model)时，Python解释器首先在当前类User的定义中查找metaclass，如果没有找到，就继续在父类Model中查找metaclass，找到了，就使用Model中定义的metaclass的ModelMetaclass来创建User类，也就是说，<strong>metaclass可以隐式地继承到子类，但子类自己却感觉不到</strong>。</p>
<p>在ModelMetaclass中，一共做了几件事情：</p>
<ol>
<li>
<p>排除掉对Model类的修改；</p>
</li>
<li>
<p>在当前类（比如User）中查找定义的类的所有属性，如果找到一个Field属性，就把它保存到一个__mappings__的dict中，同时从类属性中删除该Field属性，否则，容易造成运行时错误（实例的属性会遮盖类的同名属性）；</p>
</li>
<li>
<p>把表名保存到__table__中，这里简化为表名默认为类名。</p>
</li>
</ol>
<p>在Model类中，就可以定义各种操作数据库的方法，比如save()，delete()，find()，update等等。</p>
<p>我们实现了save()方法，把一个实例保存到数据库中。因为有表名，属性到字段的映射和属性值的集合，就可以构造出INSERT语句。</p>
<p>编写代码试试：</p>
<pre><code>u = User(id=12345, name='Michael', email='test@orm.org', password='my-pwd')
u.save()
输出如下：

Found model: User
Found mapping: email ==&gt; &lt;StringField:email&gt;
Found mapping: password ==&gt; &lt;StringField:password&gt;
Found mapping: id ==&gt; &lt;IntegerField:uid&gt;
Found mapping: name ==&gt; &lt;StringField:username&gt;
SQL: insert into User (password,email,username,id) values (?,?,?,?)
ARGS: ['my-pwd', 'test@orm.org', 'Michael', 12345]
</code></pre>
<p>可以看到，save()方法已经打印出了可执行的SQL语句，以及参数列表，只需要真正连接到数据库，执行该SQL语句，就可以完成真正的功能。</p>
<p>不到100行代码，我们就通过metaclass实现了一个精简的ORM框架</p>
<h3 id="小结-3">小结</h3>
<p>metaclass是Python中非常具有魔术性的对象，它可以改变类创建时的行为。这种强大的功能使用起来务必小心。</p>
]]></content>
    </entry>
</feed>