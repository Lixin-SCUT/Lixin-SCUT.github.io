<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-02-25T08:50:36.255Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>In the darkest night,Rising like a spire.</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[const 关键字]]></title>
        <id>https://lixin-scut.github.io//post/const-guan-jian-zi</id>
        <link href="https://lixin-scut.github.io//post/const-guan-jian-zi">
        </link>
        <updated>2020-02-25T08:27:19.000Z</updated>
        <content type="html"><![CDATA[<p>const是一个常量关键字，主要是为了防止所修饰对象被修改。我们在定义一个变量时，如果想要防止这个变量被修改，可以用const来修饰这个变量。也就是说，被const修饰过的变量或者函数，不能对其进行修改，否则，编译器就会报错</p>
<h3 id="修饰全局变量">修饰全局变量</h3>
<pre><code>#define PI1 3.14
const double PI2 = 3.14;
</code></pre>
<p>两种方式都可以用来定义全局变量。不过，第二种要比第一种方式要好，使用宏定义的变量，其信息一般以表格的形式储存在系统中，当我们在调试程序时，就有可能使得这个宏定义的变量反复出现在符号表中。而const修饰的变量会一直出现在符号表，使得我们调试方便许多。</p>
<h3 id="修饰指针">修饰指针</h3>
<pre><code>const int *p1 = 100;   //常量整形指针
int *const p2 = 200;   //整形常量指针
</code></pre>
<p>常量整形指针，不能通过这个指针修改它所指向的变量，指针本身是可变的。整形变量指针，指针不可修改，但是指向的变量可以修改</p>
<h3 id="用于表示函数的输入输出">用于表示函数的输入，输出</h3>
<p><code>char *strcpy(char *buf,const char *str) //将str拷贝给buf</code><br>
由于buf是需要修改的,所以不用const修饰，而str是传递数据进来的，并不希望进行改变，所以可以用const修饰</p>
<h3 id="修饰类成员函数">修饰类成员函数</h3>
<pre><code>class student {
public:
	student(int age) :_age(age) {}
	void getAge()const {      //不希望通过函数来改变类的数据成员
		_age = 100;       //错误，编译器会报警
		cout &lt;&lt; _age &lt;&lt; endl;
	}
private:
	int _age;
};
</code></pre>
<p>如果我们在定义一个类的成员函数时，并不希望这个函数能够改变类的数据成员，这时我们可以使用const将这个成员函数定义为常量函数，这样这个函数就不能修改数据成员了。</p>
<h3 id="mutable">mutable</h3>
<p>mutable 可变数据成员 永远不会是const，即使它是const对象的成员</p>
<pre><code>mutable int acess_num;
void func() const{ ++acess_num;} //记录函数调用次数
</code></pre>
<ol>
<li>如果需要在const成员方法中修改一个成员变量的值，那么需要将这个成员变量修饰为mutable。即用mutable修饰的成员变量不受const成员方法的限制;</li>
<li>可以认为mutable的变量是类的辅助状态，但是只是起到类的一些方面表述的功能，修改他的内容我们可以认为对象的状态本身并没有改变的。实际上由于const_cast的存在，这个概念很多时候用处不是很到了。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 整数、指针、布尔变量、浮点数值如何与 0 比较大小]]></title>
        <id>https://lixin-scut.github.io//post/zheng-shu-zhi-zhen-bu-er-bian-liang-fu-dian-shu-zhi-ru-he-yu-0-bi-jiao-da-xiao</id>
        <link href="https://lixin-scut.github.io//post/zheng-shu-zhi-zhen-bu-er-bian-liang-fu-dian-shu-zhi-ru-he-yu-0-bi-jiao-da-xiao">
        </link>
        <updated>2020-02-25T08:03:40.000Z</updated>
        <content type="html"><![CDATA[<h3 id="布尔变量与零值比较">布尔变量与零值比较</h3>
<p><strong>不可将布尔变量直接与TRUE、FALSE或者1、0进行比较。</strong><br>
根据布尔类型的语义，零值为“假”（记为FALSE），任何非零值都是“真”（记为TRUE）。TRUE的值究竟是什么并没有统一的标准。<br>
例如Visual C++ 将TRUE定义为1，而Visual Basic则将TRUE定义为-1。</p>
<p>假设布尔变量名字为flag，它与零值比较的标准if语句如下：</p>
<pre><code>if (flag) // 表示flag为真
if (!flag) // 表示flag为假
</code></pre>
<p>其它的用法都属于不良风格，例如：</p>
<pre><code>if (flag == TRUE)
if (flag == 1 )
if (flag == FALSE)
if (flag == 0)
</code></pre>
<h3 id="整型变量与零值比较">整型变量与零值比较</h3>
<p><strong>应当将整型变量用“==”或“！=”直接与0比较。</strong><br>
假设整型变量的名字为value，它与零值比较的标准if语句如下：</p>
<pre><code>if (value == 0)
if (value != 0)
</code></pre>
<p>不可模仿布尔变量的风格而写成</p>
<pre><code>if (value) // 会让人误解 value是布尔变量
if (!value)
</code></pre>
<h3 id="浮点变量与零值比较">浮点变量与零值比较</h3>
<p><strong>不可将浮点变量用“==”或“！=”与任何数字比较。</strong><br>
千万要留意，无论是float还是double类型的变量，都有精度限制。所以一定要避免将浮点变量用“==”或“！=”与数字比较，应该设法转化成“&gt; =”或“ &lt;=”形式。<br>
假设浮点变量的名字为x，应当将<br>
<code>if (x == 0.0) // 隐含错误的比较</code><br>
转化为<br>
<code>if ((x&gt; =-EPSINON) &amp;&amp; (x &lt;=EPSINON))</code><br>
其中EPSINON是允许的误差（即精度）。</p>
<h3 id="指针变量与零值比较">指针变量与零值比较</h3>
<p>注意：C++11中已经抛弃了NULL这个模糊的定义，指针有专门的nullptr<br>
<strong>应当将指针变量用“==”或“！=”与NULL比较。</strong><br>
指针变量的零值是“空”（记为NULL）。尽管NULL的值与0相同，但是两者意义不同。假设指针变量的名字为p，它与零值比较的标准if语句如下：</p>
<pre><code>if (p == NULL) // p与NULL显式比较，强调p是指针变量
if (p != NULL)
</code></pre>
<p>不要写成</p>
<pre><code>if (p == 0) // 容易让人误解p是整型变量
if (p != 0)
</code></pre>
<p>或者</p>
<pre><code>if (p) // 容易让人误解p是布尔变量
if (!p)
</code></pre>
<h3 id="对if语句的补充说明重要">对if语句的补充说明（重要）</h3>
<p>有时候我们可能会看到 if (NULL == p) 这样古怪的格式。不是程序写错了，是程序员为了防止将 if (p == NULL) 误写成 if (p = NULL)，而有意把p和NULL颠倒。编译器认为 if (p = NULL) 是合法的，但是会指出 if (NULL = p)是错误的，因为NULL不能被赋值。<br>
程序中有时会遇到if/else/return的组合，应该将如下不良风格的程序</p>
<pre><code>if (condition)
return x;
return y;
</code></pre>
<p>改写为</p>
<pre><code>if (condition)
{
	return x;
}
else
{
	return y;
}
</code></pre>
<p>或者改写成更加简练的<br>
<code>return (condition ? x : y);</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++内存]]></title>
        <id>https://lixin-scut.github.io//post/cnei-cun</id>
        <link href="https://lixin-scut.github.io//post/cnei-cun">
        </link>
        <updated>2020-02-25T07:06:27.000Z</updated>
        <content type="html"><![CDATA[<p>在《C++primer》中没有过多地介绍内存的详情，在《CSAPP》和《现代操作系统》上倒是说得挺多的，然后找到一篇博文概述得特别好特别简洁，一目了然，我就不画蛇添足了。<br>
<a href="https://blog.csdn.net/cherrydreamsover/article/details/81627855">C/C++程序内存的分配</a><br>
另外有一个关于自由存储区的争议，可以参考博文<br>
<a href="https://www.cnblogs.com/QG-whz/p/5060894.html">C++ 自由存储区是否等价于堆？</a></p>
<h3 id="一-一个cc编译的程序占用内存分为以下几个部分">一、一个C/C++编译的程序占用内存分为以下几个部分：</h3>
<ul>
<li>栈区（stack）：由编译器自动分配与释放，存放为运行时函数分配的局部变量、函数参数、返回数据、返回地址等。其操作类似于数据结构中的栈。</li>
<li>堆区（heap）：一般由程序员自动分配，如果程序员没有释放，程序结束时可能有OS回收。其分配类似于链表。</li>
<li>全局区（静态区static）：存放全局变量、静态数据、常量。程序结束后由系统释放。全局区分为已初始化全局区（data）和未初始化全局区（bss）。</li>
<li>常量区（文字常量区）：存放常量字符串，程序结束后有系统释放。</li>
<li>代码区：存放函数体（类成员函数和全局区）的二进制代码。</li>
</ul>
<h3 id="二-三种内存分配方式">二、三种内存分配方式</h3>
<ul>
<li>从静态存储区分配<br>
内存在程序编译的时候已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。</li>
<li>在栈上创建<br>
在执行函数时，函数内局部变量的存储单元可以在栈上创建，函数执行结束时，这些内存单元会自动被释放。<br>
栈内存分配运算内置于处理器的指令集，效率高，但是分配的内存容量有限。</li>
<li>从堆上分配<br>
亦称为动态内存分配。<br>
程序在运行的时候使用malloc或者new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。<br>
动态内存的生命周期有程序员决定，使用非常灵活，但如果在堆上分配了空间，既有责任回收它，否则运行的程序会出现内存泄漏，频繁的分配和释放不同大小的堆空间将会产生内存碎片。</li>
</ul>
<h3 id="三-内存分配简易图">三、内存分配简易图</h3>
<p><img src="https://lixin-scut.github.io//post-images/1582614891622.png" alt=""></p>
<ul>
<li>补充：<br>
在 C 语言中，全局变量又分为初始化的和未初始化的（未被初始化的对象存储区可以通过 void* 来访问和操纵，程序结束后由系统自行释放），在 C++ 里面没有这个区分了，他们共同占用同一块内存区。</li>
</ul>
<h3 id="四-堆和栈的区别">四、堆和栈的区别</h3>
<ul>
<li>管理方式不同：栈是由编译器自动申请和释放空间，堆是需要程序员手动申请和释放；</li>
<li>空间大小不同：栈的空间是有限的，在32位平台下，VC6下默认为1M，堆最大可以到4G；</li>
<li>能否产生碎片：栈和数据结构中的栈原理相同，在弹出一个元素之前，上一个已经弹出了，不会产生碎片，如果不停地调用malloc、free对造成内存碎片很多；<br>
生长方向不同：堆生长方向是向上的，也就是向着内存地址增加的方向，栈刚好相反，向着内存减小的方向生长。</li>
<li>分配方式不同：堆都是动态分配的，没有静态分配的堆。栈有静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由 malloc 函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无需我们手工实现。</li>
<li>分配效率不同：栈的效率比堆高很多。栈是机器系统提供的数据结构，计算机在底层提供栈的支持，分配专门的寄存器来存放栈的地址，压栈出栈都有相应的指令，因此比较快。堆是由库函数提供的，机制很复杂，库函数会按照一定的算法进行搜索内存，因此比较慢。</li>
</ul>
<h3 id="六-静态全局变量-全局变量-静态局部变量-局部变量的区别">六、静态全局变量、全局变量、静态局部变量、局部变量的区别</h3>
<ul>
<li>
<p>静态全局变量、全局变量区别<br>
（1）静态全局变量和全局变量都属于常量区<br>
（2）静态全局区只在本文件中有效，别的文件想调用该变量，是调不了的，而全局变量在别的文件中可以调用<br>
（3）如果别的文件中定义了一个该全局变量相同的变量名，是会出错的。</p>
</li>
<li>
<p>静态局部变量、局部变量的区别<br>
（1）静态局部变量是属于常量区的，而函数内部的局部变量属于栈区；<br>
（2）静态局部变量在该函数调用结束时，不会销毁，而是随整个程序结束而结束，但是别的函数调用不了该变量，局部变量随该函数的结束而结束；<br>
（3）如果定义这两个变量的时候没有初始值时，静态局部变量会自动定义为0，而局部变量就是一个随机值；<br>
（4）静态局部变量在编译期间只赋值一次，以后每次函数调用时，不在赋值，调用上次的函数调用结束时的值。局部变量在调用期间，每调用一次，赋一次值。</p>
</li>
</ul>
<p>关于空闲存储区：</p>
<blockquote>
<p>Free Store<br>
The free store is one of the two dynamic memory areas, allocated/freed by new/delete. Object lifetime can be less than the time the storage is allocated; that is, free store objects can have memory allocated without being immediately initialized, and can be destroyed without the memory being immediately deallocated. During the period when the storage is allocated but outside the object's lifetime, the storage may be accessed and manipulated through a void* but none of the proto-object's nonstatic members or member functions may be accessed, have their addresses taken, or be otherwise manipulated.<br>
Heap<br>
The heap is the other dynamic memory area, allocated/freed by malloc/free and their variants. Note that while the default global new and delete might be implemented in terms of malloc and free by a particular compiler, the heap is not the same as free store and memory allocated in one area cannot be safely deallocated in the other. Memory allocated from the heap can be used for objects of class type by placement-new construction and explicit destruction. If so used, the notes about free store object lifetime apply similarly here.</p>
</blockquote>
<p>从技术上来说，堆（heap）是C语言和操作系统的术语。堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当运行程序调用malloc()时就会从中分配，稍后调用free可把内存交还。而自由存储是C++中通过new和delete动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区。基本上，所有的C++编译器默认使用堆来实现自由存储，也即是缺省的全局运算符new和delete也许会按照malloc和free的方式来被实现，这时藉由new运算符分配的对象，说它在堆上也对，说它在自由存储区上也正确。但程序员也可以通过重载操作符，改用其他内存来实现自由存储，例如全局变量做的对象池，这时自由存储区就区别于堆了。我们所需要记住的就是：<br>
堆是操作系统维护的一块内存，而自由存储是C++中通过new与delete动态分配和释放对象的抽象概念。堆与自由存储区并不等价。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 题28:对称的二叉树]]></title>
        <id>https://lixin-scut.github.io//post/shu-ti-28dui-cheng-de-er-cha-shu</id>
        <link href="https://lixin-scut.github.io//post/shu-ti-28dui-cheng-de-er-cha-shu">
        </link>
        <updated>2020-02-24T15:26:21.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。<br>
/*<br>
struct TreeNode {<br>
int val;<br>
struct TreeNode *left;<br>
struct TreeNode *right;<br>
TreeNode(int x) :<br>
val(x), left(NULL), right(NULL) {<br>
}<br>
};<br>
*/</p>
</blockquote>
<p>需要注意的点是其实可以重载原函数，提高代码的可读性</p>
<pre><code>class Solution {
public:
    bool isSymmetrical(TreeNode* pRoot)
    {
        if(pRoot==NULL)
            return true;
        return isSymmetrical(pRoot-&gt;left,pRoot-&gt;right);
    }
    
    bool isSymmetrical(TreeNode* cur1,TreeNode* cur2)
    {
        if(cur1==NULL&amp;&amp;cur2==NULL)
            return true;
        if(cur1==NULL||cur2==NULL)
            return false;
        if(cur1-&gt;val!=cur2-&gt;val)
            return false;
        return isSymmetrical(cur1-&gt;left,cur2-&gt;right)&amp;&amp;isSymmetrical(cur1-&gt;right,cur2-&gt;left);
    }
};
</code></pre>
<p>书本题解：<br>
通常我们有3种不同的二叉树遍历算法，即前序遍历、中序遍历和后 序遍历。在这3种遍历算法中，都是先遍历左子节点再遍历右子节点。我 们是否可以定义一种遍历算法，先遍历右子节点再遍历左子节点？比如我 们针对前序遍历定义一种对称的遍历算法，即先遍历父节点，再遍历它的 右子节点，最后遍历它的左子节点。<br>
我们发现可以通过比较二叉树的前序遍历序列和对称前序遍历序列 来判断二叉树是不是对称的。如果两个序列是一样的，那么二叉树就是对称的。</p>
<pre><code>bool isSymmetrical(BinaryTreeNode* pRoot)
{
    return isSymmetrical(pRoot, pRoot);
}

bool isSymmetrical(BinaryTreeNode* pRoot1, BinaryTreeNode* pRoot2)
{
    if(pRoot1 == nullptr &amp;&amp; pRoot2 == nullptr)
        return true;

    if(pRoot1 == nullptr || pRoot2 == nullptr)
        return false;

    if(pRoot1-&gt;m_nValue != pRoot2-&gt;m_nValue)
        return false;

    return isSymmetrical(pRoot1-&gt;m_pLeft, pRoot2-&gt;m_pRight)
        &amp;&amp; isSymmetrical(pRoot1-&gt;m_pRight, pRoot2-&gt;m_pLeft);
}
</code></pre>
<p>我的思路和书本的一致，但是需要将NULL改为nullptr，这样符合C++11标准</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 指针和引用的区别]]></title>
        <id>https://lixin-scut.github.io//post/zhi-zhen-he-yin-yong-de-qu-bie</id>
        <link href="https://lixin-scut.github.io//post/zhi-zhen-he-yin-yong-de-qu-bie">
        </link>
        <updated>2020-02-24T13:07:58.000Z</updated>
        <content type="html"><![CDATA[<p>首先先贴上以前的博文：<br>
<a href="https://lixin-scut.github.io/post/cyin-yong-de-ben-zhi/">C++引用的本质</a><br>
这篇博文还是比较乱的，图和源代码都找不到了，不过中心思想很简洁，就是<br>
引用就是一个常量指针</p>
<p>但是因为缺乏源代码，所以还是显得比较模糊，还是找博客了解一下</p>
<p>摘自：<a href="https://blog.csdn.net/lyd_253261362/article/details/4323691">指针和引用的联系与区别</a><br>
★ 相同点：</p>
<ol>
<li>都是地址的概念；<br>
指针指向一块内存，它的内容是所指内存的地址；引用是某块内存的别名。<br>
★ 区别：</li>
<li>指针是一个实体，而引用仅是个别名；</li>
<li>引用使用时无需解引用(*)，指针需要解引用；</li>
<li>引用只能在定义时被初始化一次，之后不可变；指针可变；</li>
<li>引用没有 const，指针有 const；</li>
<li>引用不能为空，指针可以为空；</li>
<li>“sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身(所指向的变量或对象的地址)的大小；</li>
<li>指针和引用的自增(++)运算意义不一样；</li>
<li>从内存分配上看：程序为指针变量分配内存区域，而引用不需要分配内存区域。<br>
★ 联系
<ol>
<li>引用在语言内部用指针实现（如何实现？）。</li>
<li>对一般应用而言，把引用理解为指针，不会犯严重语义错误。引用是操作受限了的指针（仅容许取内容操作）。<br>
★ 总结<br>
总的来说，在以下情况下你应该使用指针，一是你考虑到存在不指向任何对象的可能（在这种情况下，你能够设置指针为空），二是你需要能够在不同的时刻指向不同的对象（在这种情况下，你能改变指针的指向）。<br>
如果总是指向一个对象并且一旦指向一个对象后就不会改变指向，那么你应该使用引用。<br>
还有一种情况，就是当你重载某个操作符时，你应该使用引用。最普通的例子是操作符[].这个操作符典型的用法是返回一个目标对象，其能被赋值。<br>
尽可能使用引用，不得已时使用指针。<br>
当你不需要“重新指向”时，引用一般优先于指针被选用。这通常意味着引用用于类的公有接口时更有用。引用出现的典型场合是对象的表面，而指针用于对象内部。<br>
上述的例外情况是函数的参数或返回值需要一个“临界”的引用时。这时通常最好返回/获取一个指针，并使用 NULL 指针来完成这个特殊的使命。（引用应该总是对象的别名，而不是被解除引用的 NULL 指针。</li>
</ol>
</li>
</ol>
<p>但是我个人有一个疑惑：引用到底占不占空间？仅仅是一个别名吗？</p>
<p>然后读取了下面的博客<br>
<a href="https://blog.csdn.net/k346k346/article/details/46805159">C++ 引用的本质</a><br>
<a href="https://www.cnblogs.com/karottc/p/cpp-reference.html">C++的引用类型的变量到底占不占用内存空间？</a><br>
可以看出引用确实是一个指针，而且是一个常量指针，只是我们无法直接获得这个指针，导致它似乎是不存在的</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 题27:二叉树的镜像]]></title>
        <id>https://lixin-scut.github.io//post/shu-ti-27er-cha-shu-de-jing-xiang</id>
        <link href="https://lixin-scut.github.io//post/shu-ti-27er-cha-shu-de-jing-xiang">
        </link>
        <updated>2020-02-23T15:50:11.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
操作给定的二叉树，将其变换为源二叉树的镜像。<br>
输入描述:<br>
二叉树的镜像定义：源二叉树</p>
</blockquote>
<pre><code>    	    8
    	   /  \
    	  6   10
    	 / \  / \
    	5  7  9 11
    	镜像二叉树
    	    8
    	   /  \
    	  10   6
    	 / \  / \
    	11 9  7  5
			
/*
struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :
			val(x), left(NULL), right(NULL) {
	}
};*/
</code></pre>
<p>这道题是常见题目了，主要还是通过递归来解决比较简洁<br>
但是同时也要考虑迭代怎么处理-使用一个队列或者栈，把pop的节点交换左右子树后再push进队列尾端直到队列为空<br>
需要注意的就是交换，最好还是用swap吧</p>
<pre><code>class Solution {
public:
    void Mirror(TreeNode *pRoot) {
        if(pRoot==NULL)
            return;
        TreeNode *temp=pRoot-&gt;left;
        pRoot-&gt;left=pRoot-&gt;right;
        pRoot-&gt;right=temp;
        Mirror(pRoot-&gt;left);
        Mirror(pRoot-&gt;right);
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>求一棵树的镜像的过程：先前序遍历这棵 树的每个节点，如果遍历到的节点有子节点，就交换它的两个子节点。当 交换完所有非叶节点的左、右子节点之后，就得到了树的镜像。</p>
</blockquote>
<pre><code>void MirrorRecursively(BinaryTreeNode *pNode)
{
    if((pNode == nullptr) || (pNode-&gt;m_pLeft == nullptr &amp;&amp; pNode-&gt;m_pRight))
        return;

    BinaryTreeNode *pTemp = pNode-&gt;m_pLeft;
    pNode-&gt;m_pLeft = pNode-&gt;m_pRight;
    pNode-&gt;m_pRight = pTemp;
    
    if(pNode-&gt;m_pLeft)
        MirrorRecursively(pNode-&gt;m_pLeft);  

    if(pNode-&gt;m_pRight)
        MirrorRecursively(pNode-&gt;m_pRight); 
}

void MirrorIteratively(BinaryTreeNode* pRoot)
{
    if(pRoot == nullptr)
        return;

    std::stack&lt;BinaryTreeNode*&gt; stackTreeNode;
    stackTreeNode.push(pRoot);

    while(stackTreeNode.size() &gt; 0)
    {
        BinaryTreeNode *pNode = stackTreeNode.top();
        stackTreeNode.pop();

        BinaryTreeNode *pTemp = pNode-&gt;m_pLeft;
        pNode-&gt;m_pLeft = pNode-&gt;m_pRight;
        pNode-&gt;m_pRight = pTemp;

        if(pNode-&gt;m_pLeft)
            stackTreeNode.push(pNode-&gt;m_pLeft);

        if(pNode-&gt;m_pRight)
            stackTreeNode.push(pNode-&gt;m_pRight);
    }
}
</code></pre>
<p>然后发现我的想法和书本的一致，我倾向于用队列来做迭代（BFS），书本的解法使用栈来做迭代（DFS），基本就是BFS和DFS的区别。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TcpConnection]]></title>
        <id>https://lixin-scut.github.io//post/tcpconnection</id>
        <link href="https://lixin-scut.github.io//post/tcpconnection">
        </link>
        <updated>2020-02-23T13:25:52.000Z</updated>
        <content type="html"><![CDATA[<p>TcpConnection是唯一默认使用shared_ptr来管理的class,也是唯一继承enable_shared_from_this的class,这源于其模糊的生命期</p>
<p>TcpConnection的状态有两个，kConnecting和kConnected</p>
<p>TcpConnection使用Channel来获得socket上的IO事件，它<em>会自己处理writable事件</em>，而把readable事件通过Messagecallback传达给用户<br>
TcpConnection拥有TCP socket,它的析构函数会close(fd)(在Socket的析构函数 中发生)</p>
<p>注意TcpConnection表示的是“一次TCP连接”，它是不可再生的，一旦连接断 开，这个TcpConnection对象就没啥用了。<br>
另外TcpConnection没有发起连接的功能, 其构造函数的参数是已经建立好连接的socketfd (无论是TcpServer被动接受还是 TcpClient主动发起),因此其初始状态是kConnecting。</p>
<p>只接受一种关闭连接的方式：被动关闭，即对方先关闭连接，本地read(2)返回0,触发关闭逻辑。<br>
也可以给TcpConnection新增 forceClose()成员函数，用于主动关闭连接，实现很简单，调用handleClose()<br>
<img src="https://lixin-scut.github.io//post-images/1582467842700.png" alt=""></p>
<p><strong>channel的改动</strong><br>
Channel class新增了 CloseCallback事件回调，并且断言(assert)在事件处理期间Channel对象不会析构，Channel 的 CloseCallback 会调用 handleClose(),</p>
<p>TcpConnection也同步需要增加 CloseCallback事件回调，<em>但是这个回调是给TcpServer和TcpClient用的</em>，用于通知它们移除所持有的TcpConnectionPtr,这不是给普通用户用的，普通用户继续使用ConnectionCallback</p>
<p>handleRead()会检查read(2)的返回值，根据返回值分别调用 messagecallback_,handleClose(),handleError()</p>
<p>handleClose()的主要功能是调用 closeCallback_,这个回调绑定到 removeConnection()</p>
<p>handleError()并没有进一步的行动，只是在日志中输出错误消息，这不影响连接的正常关闭。</p>
<p>connectDestroyed()是 TcpConnection 析构前最后调用的一个成员函数，它通知用户连接已断开。</p>
<p><strong>TcpServer</strong><br>
TcpServer向TcpConnection注册CloseCallback,用于接收连接断开的消息。<br>
通常TcpServer的生命期长于它建立的TcpConnection,因此不用担心TcpServer 对象失效。<br>
TcpServer::removeConnection()把 conn 从 ConnectionMap 中移除。这时 TcpConnection 已经快要被销毁：如果用户不持有TcpConnectionPtr的话，conn的引用计数已降到1。注意这里一定要用EventLoop::queuelnLoop <strong>（unknown）</strong>,否则就会出现对象生命期管理问题，即Channel::handleEvent()<strong>（unknown）</strong> 有可能引发TcpConnection析构，继而把当前Channel对象也析构了，导致程序崩溃。<br>
另外注意这里用boost:: bind让TcpConnection的生命期 长到调用connectDestroyed()的时刻。</p>
<p><strong>EventLoop 和 Poller</strong><br>
TcpConnection不再是只生不灭，因此要求EventLoop也提供unregister功能。EventLoop 新增了 removeChannel()成员函数，它会调用 Poller::removeChannel(),复杂度为O(logN)。<br>
注意其中从数组pollfds_中删除元素是0(1)复杂度，办法是将待删除的元素与最后一个元素交换，再pollfds_.pop_back()</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[STL 内存配置器与内存管理]]></title>
        <id>https://lixin-scut.github.io//post/stl-nei-cun-pei-zhi-qi-yu-nei-cun-guan-li</id>
        <link href="https://lixin-scut.github.io//post/stl-nei-cun-pei-zhi-qi-yu-nei-cun-guan-li">
        </link>
        <updated>2020-02-23T07:22:23.000Z</updated>
        <content type="html"><![CDATA[<p>注意，《STL源码剖析》原文中的是空间配置器</p>
<blockquote>
<p>为什么不说allocator是内存配置器而说它是空间配置器呢？因为空间不一定 是内存，空间也可以是磁盘或其它辅助存储介质。是的，你可以写一个allocator, 直接向硬盘取空间L以下介绍的是SGISTL提供的配置器，配置的对象，呃，是 的，是内存</p>
</blockquote>
<p>但是因为绝大部分时间操作对象都是内存，所以我还是把它叫做内存配置器了。</p>
<p>预备知识：<br>
new对应delete，这两者既包含了内存的分配（释放）和对象的构造（析构）<br>
而malloc和free、allocate和deallocate则仅仅包含内存的分配（释放），需要配合construct和destroy来完成对象的构造（析构）</p>
<p>为了精密分工，STL allocator将内存配置操作和对象构造操作这两阶段操作区分开来。内存分配由alloc::allocate ()负责，内存释放操作由 alloc::deallocate () 负责； 对象构造由::construct ()负责，对象析构操作由 ::destroy ()负责</p>
<p>我们主要考虑内存配置操作：<br>
•	向system heap要求空间。<br>
•	考虑内存不足时的应变措施。<br>
•	考虑过多“小型区块”可能造成的内存碎片(fragment)问题。<br>
SGI正是以malloc ()和 free() 完成内存的配置与释放，这对组合可以解决第一第二点问题（通过类似与new-handle的机制不断尝试释放、配置直到成功分配或者bad_alloc）。<br>
考虑到第三点：小型区块所可能造成的内存破碎问题，SGI设计了双层级配置器，第一级配置器如上述直接使用malloc()和free(),第二级配置器则视情况采用不同的策略</p>
<p>其中第二级配置器为默认配置器<br>
当配置区块超过128 bytes 时,视之为“足够大”，便调用第一级配置器；<br>
当配置区块小于128 bytes时，视之为“过小”，直接使用第二级配置器<br>
为了降低额外负担(overhead)，便采用复杂的memory pool整理方式，而不再求助于第一级配置器。</p>
<p>第二级配置器的具体做法是，如果区块够大，超过128 bytes时，就移交第一级配置器处理。当区块小于128 bytes时，则以内存池(memory pool)管理，</p>
<p>此法又称为次层配置(sub-allocation):每次配置一大块内存，并维护对应之自由链表 (free-list)。下次若再有相同大小的内存需求，就直接从free-lists中拨出。如果客端释还小额区块，就由配置器回收到free-lists中<br>
为了方便管理，SGI第二级配置器会主动将任何小额区块的内存需求量上调至8的倍数(例如客端要求30 bytes,就自动调整为32 bytes) , 并维护 16 个free-lists.各自管理大小分别为 8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 96, 104, 112, 120, 128 bytes的小额区块。<br>
其中为了节省空间，链表节点使用union，第一字段观obj可被视为一个指针，指向相同形式的另一个。第二字段可被视为一个指针，指向实际区块，</p>
<p>空间配置函数allocate()首先判断区块大小，大于128 bytes就调用第一级配置器，小于128 bytes就检查对应的free list。如果free list之内有可用的区块，就直接拿来 用，如果没有可用区块，就将区块大小上调至8倍数边界，然后调用refill(), 准备为free list重新填充空间。新的空间将取自内存池(经由 chunk_alloc()完成)。缺省取得20个新节点(新区块)，但万一内存池空间不足，获得的节点数(区块数)可能小于20</p>
<p>从内存池中取空间给free_list使用，是chunk_alloc()的工作：</p>
<ol>
<li>chunk_alloc() 函数判断内存池的余量。如果余量充足，就直接调出20个区块返回给freelist。</li>
<li>如果余量不足以提供20个区块，但还足够供应一个以上的区块，就拨出这不足20个区块的空间出去。同时参数将被修改为实际能够供应的区块数。</li>
<li>如果 内存池连一个区块空间都无法供应，对客端显然无法交待，此时便需利用malloc() 从heap中配置内存。新余量的大小为需求量的两倍，再加上一个随着配置次数增加而愈来愈大的附加量。</li>
<li>万一整个system heap空间都不够了，malloc ()行动失败，chunk_alloc ()就四处寻找有无尚有未用区块,且区块够大之free lists.找到了就挖一块交出</li>
<li>最后找不到就调用第一级配置器。第一级配置器其实也是使用 malloc() 来配置内存，但它有out-of-memory处理机制 (类似new-handler机制)，或许有机会释放其它的内存拿来此处使用。如果可以,就成功，否则发出bad_alloc异常。</li>
</ol>
<p>空间释放函数deallocate()首先判断区块大小，大于128 bytes就调用第一级配置器， 小于128 bytes就找出对应的free_list,将区块回收。</p>
<p>所以最终STL内存配置的流程为:</p>
<ol>
<li>
<p>使用allocate向内存池请求size大小的内存空间, 如果需要请求的内存大小大于128bytes, 直接使用malloc.</p>
</li>
<li>
<p>如果需要的内存大小小于128bytes, allocate根据size找到最适合的自由链表.<br>
　　1) 如果链表不为空, 返回第一个node, 链表头改为第二个node.<br>
　　2) 如果链表为空, 使用blockAlloc请求分配node.<br>
　　　　x. 如果内存池中有大于一个node的空间, 分配竟可能多的node(但是最多20个), 将一个node返回, 其他的node添加到链表中.<br>
　　　　y. 如果内存池只有一个node的空间, 直接返回给用户.<br>
　　　　z. 若果如果连一个node都没有, 再次向操作系统请求分配内存.<br>
　　　　　　①分配成功, 再次进行b过程<br>
②分配失败, 循环各个自由链表, 寻找空间<br>
I. 找到空间, 再次进行过程b<br>
II. 找不到空间, 抛出异常(代码中并未给出, 只是给出了注释)</p>
</li>
<li>
<p>用户调用deallocate释放内存空间, 如果要求释放的内存空间大于128bytes, 直接调用free.</p>
</li>
<li>
<p>否则按照其大小找到合适的自由链表, 并将其插入.</p>
</li>
</ol>
<p>注意：</p>
<ol>
<li>刚开始初始化内存池的时候, 其实内存池中并没有内存, 同时所有的自由链表都为空链表.</li>
<li>只有用户第一次向内存池请求内存时, 内存池会依次执行上述过程的 1-&gt;2-&gt;b-&gt;z来完成内存池以及链表的首次填充, 而此时, 其他未使用链表仍然是空的.</li>
<li>所有已经分配的内存在内存池中没有任何记录, 释放与否完全靠程序员自觉.</li>
<li>释放内存时, 如果大于128bytes, 则直接free, 否则加入相应的自由链表中而不是直接返还给操作系统.</li>
</ol>
<p>参考资料：<br>
《STL源码剖析》<br>
allocator的必要接口：</p>
<pre><code>//以下各种type的设计原由，第3章详述
allocator::value_type
allocator：:pointer
allocator::const_pointer
allocator：:reference
allocator：:const_reference
allocator::size_type
allocator::di f ference_type
allocator::rebind
</code></pre>
<ul>
<li>allocator::rebind<br>
一个嵌套的(nested) class template。<code>classrebind&lt;U&gt;</code>拥有唯一成员 other,那是一个typedef,代表 <code>allocator&lt;U&gt;</code></li>
<li>allocator::allocator()<br>
default constructor默认构造函数（注意不是construct）</li>
<li>allocator::allocator(const allocator&amp;)<br>
copy constructor拷贝构造函数</li>
<li><code>template &lt;class U&gt;allocator::allocator(const allocator&lt;U&gt;&amp;)</code><br>
泛化的 copy constructor拷贝构造函数</li>
<li>allocator::-allocator()<br>
default constructor</li>
<li>pointer allocator::address(reference x) const<br>
返回某个对象的地址。算式 a.address(x) 等同于&amp;x</li>
<li>const pointer allocator::address(const_reference x) const<br>
返回某个 const 对象的地址。算式a.address (x)等同于&amp;x</li>
<li>pointer allocator::allocate (size_type n,cosnt void* = 0)<br>
配置空间，足以存储n个T对象.第二参数是个提示。实现上可能会利用它来增进区域性(locality),或完全忽略之</li>
<li>void allocator::deallocate(pointer p,size_type n)<br>
归还先前配置的空间</li>
<li>size_type allocato::max_size() const<br>
返回可成功配置的最大量</li>
<li>void allocator::construct(pointer p,const T&amp; x)<br>
等同于 new(const void*) p) T(x)</li>
<li>void allocator::destroy(pointer p)<br>
等同于 p-&gt;~T()</li>
</ul>
<p><img src="https://lixin-scut.github.io//post-images/1582443665448.png" alt=""></p>
<p>虽然SGI也定义有一个符合部分标准、名为allocator的配置器，但SGI 自己从未用过，也不建议我们使用，主要原因是效率不佳，只把C++的::operator new和::operator delete做一层薄薄的包装而已。</p>
<p>2.2.2	SGI特殊的空间配置器，std::alloc<br>
<img src="https://lixin-scut.github.io//post-images/1582444320205.png" alt=""><br>
这其中的new 算式内含两阶段操作：<br>
(1)调用::operator new 配置内存;<br>
(2)调用Foo::Foo()构造对象内容。<br>
delete算式也内含两阶段操作：<br>
(1)调用Foo::~Foo() 将对象析构；<br>
(2)调用 ::operator delete 释放内存。</p>
<p>为了精密分工，STL allocator决定将这两阶段操作区分开来。<br>
内存配置操 作由alloc::allocate ()负责，内存释放操作由 alloc::deallocate () 负责；<br>
对象构造操作由::construct ()负责，对象析构操作由 ::destroy ()负责</p>
<pre><code>STL标准规格告诉我们，配置器定义于 &lt;memory&gt;之中 ,SGI &lt;memory&gt; 内 含以下两个文件：
#include &lt;stl_alloc .h&gt;	//负责内存空间的配置与释放
#include &lt;stl_construct. h&gt;	/ /负责对象内容的构造与析构
</code></pre>
<p><img src="https://lixin-scut.github.io//post-images/1582444604245.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582444619328.png" alt=""></p>
<p>2.2.3	构造和析构基本工具：construct()和destroy()<br>
<img src="https://lixin-scut.github.io//post-images/1582444781513.png" alt=""><br>
construct() 接受一个指针P和一个初值 value, 该函数的用途就是将初值设定到指针所指的空间上。<br>
destroy() 有两个版本，第一版本接受一个指针，准备将该指针所指之物析构掉。这很简单，直接调用该对象的析构函数即可。第二版本接受 first 和 last 两个迭代器(所谓迭代器，第3章有详细介绍)，准备将<code>[first, last)</code>范围内的所有对象析构掉。我们不知道这个范围有多大，万一很大，而每个对象的析构函数都无关痛痒(所谓trivial destructor),那么一次次调用这些无关痛痒的析构函数, 对效率是一种伤害。因此，这里首先利用 value_type() 获得迭代器所指对象的型别，再利用 <code>_type_traits&lt;T&gt;</code>判断该型别的析构函数是否无关痛痒。若是 (<code>_true_type</code>),则什么也不做就结束；若否(<code>_false_type</code>),这才以循环方式巡访整个范围，并在循环中每经历一个对象就调用第一个版本的destroy()。</p>
<p>2.2.4	空间的配置与释放，std::alloc<br>
对象构造前的空间配置和对象析构后的空间释放，由 &lt;stl_alloc.h&gt; 负责， SGI对此的设计哲学如下：<br>
•	向system heap要求空间。<br>
•	考虑多线程(multi-threads)状态。(书中暂不考虑多线程的复杂情况)<br>
•	考虑内存不足时的应变措施。<br>
•	考虑过多“小型区块”可能造成的内存碎片(fragment)问题。<br>
C++的内存配置基本操作是 ::operator new(), 内存释放基本操作 是 ::operator delete()。 这两个全局函数相当于C的malloc ()和 free()函 数。<br>
SGI正是以malloc ()和 free() 完成内存的配置与释放。<br>
考虑到小型区块所可能造成的内存破碎问题，SGI设计了双层级配置器，第一级配置器直接使用malloc()和free(),第二级配置器则视情况采用不同的策略<br>
当配置区块超过128 bytes 时,视之为“足够大”，便调用第一级配置器；<br>
当配 置区块小于128 bytes时，视之为“过小”<br>
为了降低额外负担(overhead)，便采用复杂的memory pool整理方式，而不再求助于第一级配置器。<br>
整个设计究竟只开放第一级配置器，或是同时开放第二级配置器，取决于__USE_MALLOC 是否被定义(唔，我们可以轻易测试出来，SGI STL并未定义__USE_MALLOC，亦即同时开放第二级配置器 ):<br>
<img src="https://lixin-scut.github.io//post-images/1582446124190.png" alt=""><br>
其中 <code>__malloc_alloc_template</code> 就是第一级配置器，<code>__default_alloc_ template</code>就是第二级配置器。注意，alloc并不接受任何template型别参数。<br>
无论alloc被定义为第一级或第二级配置器，SGI还为它再包装一个接口如<br>
下，使配置器的接口能够符合STL规格<br>
<img src="https://lixin-scut.github.io//post-images/1582446468140.png" alt=""><br>
其内部四个成员函数其实都是单纯的转调用，调用传递给配置器(可能是第一级，也可能是第二级)的成员函数。<br>
这个接口使配置器的配置单位从bytes转为个别元素的大小(sizeof (T) ) ，SGI STL容器全都使用这个 simple_alloc 接口<br>
<img src="https://lixin-scut.github.io//post-images/1582446536993.png" alt=""><br>
一、二级配置器的关系，接口包装，及实际运用方式<br>
<img src="https://lixin-scut.github.io//post-images/1582446613792.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582446938165.png" alt=""></p>
<p>2.2.5 第一级配置器<code>__malloc_alloc_template</code><br>
第一级配置器以 malloc(), free(), realloc() 等c函数执行实际的内存 配置、释放、重配置操作，并实现出类似C++new-handle的机制。是的，它不能直接运用C++new-handler机制，因为它并非使用 ::operator new 来配置内存.<br>
所谓C++ new handler机制是你可以要求系统在内存配置需求无法被满足时，调用一个你所指定的函数。换句话说，一旦:operator new 无法完成任务,在丢出std::bad_elloc异常状态之前，会先调用由客端指定的处理例程，该处理例程通常即被称为new-handiero new-handier解决内存不足的做法有特定的模式</p>
<p>请注意，SGI第一级配置器的 allocate() 和 realloc() 都是在调用 malloc()和 realloc() 不成功后，改调用 oom_malloc() 和 oom_realloc()。 后两者都有内循环，不断调用“内存不足处理例程”，期望在某次调用之后，获得足够的内存而圆满完成任务。但如果“内存不足处理例程”并未被客端设定， oom_malloc() 和 oom_realloc() 便老实不客气地调用 <code>_THROW_BAD_ALLOC</code>, 丢出bad_alloc异常信息，或利用exit(1)硬生生中止程序。</p>
<p>2.2.6	第二级配置器<code>__default_alloc_template</code>剖析<br>
第二级配置器多了一些机制，避免太多小额区块造成内存的碎片。小额区块带<br>
来的其实不仅是内存碎片，配置时的额外负担(overhead)也是一个大问题。额外<br>
负担永远无法避免，毕竟系统要靠这多出来的空间来管理内存，如图2-3所示。但 是区块愈小，额外负担所占的比例就愈大，愈显得浪费。</p>
<p>SGI第二级配置器的做法是，如果区块够大，超过128 bytes时，就移交第一级配置器处理。当区块小于128 bytes时，则以内存池(memory pool)管理，<br>
此法又称为次层配置(sub-allocation):每次配置一大块内存，并维护对应之自由链表 (free-list)。下次若再有相同大小的内存需求，就直接从free-lists中拨出。如果客端释还小额区块，就由配置器回收到free-lists中——是的，别忘了，配置器除了负责配置，也负责回收。<br>
为了方便管理，SGI第二级配置器会主动将任何小额区块的内存需求量上调至8的倍数(例如客端要求30 bytes,就自动调整为32 bytes) , 并维护 16 个free-lists.各自管理大小分别为 8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 96, 104, 112, 120, 128 bytes的小额区块。free-lists的节点结构如下：</p>
<pre><code>union obj {
union obj * free_list_link;
char client_data[1];	 /* The client sees this, */
};
</code></pre>
<p>诸君或许会想，为了维护链表(lists),每个节点需要额外的指针(指向下一 个节点)，这不又造成另一种额外负担吗？你的顾虑是对的，但早已有好的解决办<br>
法。注意，上述obj所用的是union, 由于 union 之故，从其第一字段观之,<br>
obj可被视为一个指针，指向相同形式的另一个。从其第二字段观之，可被视为一个指针，指向实际区块，如图2-4所示。一物二用的结果是，不会为了维<br>
护链表所必须的指针而造成内存的另一种浪费(我们正在努力节省内存的开销呢)。<br>
这种技巧在强型(strongly typed)语言如Java中行不通，但是在非强型语言如C+十<br>
中十分普遍<br>
<img src="https://lixin-scut.github.io//post-images/1582447931963.png" alt=""></p>
<p>2.2.7 空间配置函数allocate()<br>
身为一个配置器，<code>__default_alloc_template</code>拥有配置器的标准接口函数<br>
allocate()。 此函数首先判断区块大小，大于128 bytes就调用第一级配置器，小于128 bytes就检查对应的free list。如果free list之内有可用的区块，就直接拿来 用，如果没有可用区块，就将区块大小上调至8倍数边界，然后调用refill(), 准备为free list重新填充空间。<br>
<img src="https://lixin-scut.github.io//post-images/1582448121791.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582448143766.png" alt=""><br>
<strong>备注</strong>：注意其实result-&gt;free_list_link;这里等于是next指针，相当于把头节点指向下一个节点，可在下一节得证</p>
<p>2.2.8 空间释放函数deallocate()<br>
身为一个配置器，<code>__default_alloc_template</code>拥有配置器标准接口函数 deallocate()。 该函数首先判断区块大小，大于128 bytes就调用第一级配置器， 小于128 bytes就找出对应的free list,将区块回收。<br>
<img src="https://lixin-scut.github.io//post-images/1582448357314.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582448420144.png" alt=""></p>
<p>2.2.9	重新填充free lists<br>
回头讨论先前说过的allocate()。当它发现free list中没有可用区块了时， 就调用refill()，准备为freelist重新填充空间。新的空间将取自内存池(经由 chunk_alloc()完成)。缺省取得20个新节点(新区块)，但万一内存池空间不足，获得的节点数(区块数)可能小于20：<br>
<img src="https://lixin-scut.github.io//post-images/1582448504177.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582448521568.png" alt=""><br>
voliate变量是随时变化的，用voliate修饰的运算，编译器不进行优化，以免出错</p>
<p>2.2.10 内存池( memory pool)<br>
从内存池中取空间给free list使用，是chunk_alloc()的工作：<br>
<img src="https://lixin-scut.github.io//post-images/1582449342167.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582449365595.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582449383349.png" alt=""><br>
上述的 chunk_alloc() 函数以 end_free - start_free 来判断内存池的水量。如果水量充足，就直接调出20个区块返回给freelist.如果水量不足以提供20个区块，但还足够供应一个以上的区块，就拨出这不足20个区块的空间出去。这时候其pass by reference的nobjs参数将被修改为实际能够供应的区块数。如果 内存池连一个区块空间都无法供应，对客端显然无法交待，此时便需利用malloc() 从heap中配置内存，为内存池注入活水源头以应付需求。新水量的大小为需求量的两倍，再加上一个随着配置次数增加而愈来愈大的附加量。<br>
万一山穷水尽，整个system heap空间都不够了(以至无法为内存池注入活水 源头)，malloc ()行动失败，chunk_alloc ()就四处寻找有无尚有未用区块,<br>
且区块够大之free lists.找到了就挖一块交出，找不到就调用第一级配置器。第一级配置器其实也是使用 malloc() 来配置内存，但它有out-of-memory处理机制 (类似new-handler机制)，或许有机会释放其它的内存拿来此处使用。如果可以, 就成功，否则发出bad.alloc异常。<br>
<img src="https://lixin-scut.github.io//post-images/1582449531828.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582449557765.png" alt=""><br>
STL的容器都可以设置配置器，并默认设置为第二级配置器</p>
<p>2.3	内存基本处理工具<br>
STL定义有五个全局函数，作用于未初始化空间上。这样的功能对于容器的实 现很有帮助，我们会在第4章容器实现代码中，看到它们肩负的重任。前两个函数是 2.2.3节说过的、用于构造的 construct() 和用于析构的destroy(),另三个函数是 uninitialized_copy () / uninitialized_fill () / uninitialized_fill_n () 分别对应于高层次函数 copy () 、fill () 、fill_n ()	这些都是 STL 算法，将<br>
如果你要使用本节的三个低层次函数，应该包含 <code>&lt;memory&gt;</code>, 不过 SGI把它们实际定义于 <code>&lt;stl_uninitialized&gt;</code>。</p>
<p>2.3.1	uninitialized_copy</p>
<pre><code>template &lt;class InputIterator, class ForwardIterator&gt;
ForwardIterator
uninitialized_copy(InputIterator first, InputIterator last,
															ForwardIterator result);
</code></pre>
<p>uninitialized_copy() 使我们能够将内存的配置与对象的构造行为分离开来。如果作为输出目的地的<code>[result, result+(last-first))</code>范围内的每一个迭代器都指向未初始化区域，则 uninitialized_copy () 会使用 copy constructor, 给身为输入来源之<code>[first,last)</code>范围内的每一个对象产生一份复制品，放进输出范围中。换句话说，针对输入范围内的每一个迭代器i，该函数会调用 <code>construct (&amp;* (results- (i-first)) , *i)</code>,产生*i的复制品，放置于输出范围的相对位置上<br>
如果你需要实现一个容器， uninitialized_copy() 这样的函数会为你带来 很大的帮助，因为容器的全区间构造函数(range constructor)通常以两个步骤完成：<br>
•配置内存区块，足以包含范围内的所有元素.<br>
•使用 uninitiali zed_copy(), 在该内存区块上构造元素.</p>
<p>uninitialized_copy具有 ucommit or rollback 语意，要么“构造出所有必要元素”，要么(当有任何一个copy constructor失败时)“不构造任何东西”.</p>
<p>2 3.2 uninitialized_fill</p>
<pre><code>template &lt;class ForwardIterator, class T&gt;
void uninitialized_fill(Forwarditerator first, ForwardIterator last, 
																const T&amp; x)；
</code></pre>
<p>uninitialized_fill() 也能够使我们将内存配置与对象的构造行为分离开 来。如果 <code>[first,last )</code>范围内的每个迭代器都指向未初始化的内存，那么 uninitialized_fill() 会在该范围内产生x (上式第三参数)的复制品。换句话 说，uninitialized_fill ()会针对操作范围内的每个迭代器i,调用 <code>construct(&amp;*i, x)</code>, 在i所指之处产生x的复制品.式中的 construct() 已 于2.2.3节讨论过。<br>
与 uninitialized_copy() 一样，uninitialized_fill() 必须具备&quot;commit or rollback语意，换句话说，它要么产生出所有必要元素，要么不产生任何元素。 如果有任何一个copy constructor丢出异常(exception) ,uninitialized_fill()必须能够将已产生的所有元素析构掉。</p>
<p>2.3.3	uninitialized_fill_n</p>
<pre><code>template &lt;class ForwardIterator, class Size, class T&gt; 
ForwardIterator
uninitialized_fill_n(ForwardIterator first, Size nz, const T&amp; x)；
</code></pre>
<p>uninitialized_fill_n ()能够使我们将内存配置与对象构造行为分离开来。 它会为指定范围内的所有元素设定相同的初值。<br>
如果<code>[first, first+n)</code>范围内的每一个迭代器都指向未初始化的内存，那么uninitialized_f ill_n ()会调用 copy constructor,在该范围内产生x (上式第三参数)的复制品。也就是说，面对<code>[first z first+n)</code> 范围内的每个迭代器i， uninitialized_fill_n ()会调用 <code>construct(&amp;*i, x)</code>,在对应位置处产生 x 的复制品。<br>
uninitialized_fill_n ()也具有 commit or rollback语意：要么产生所有必要的元素，否则就不产生任何元素。如果任何一个copy constructor丢出异常 (exception) &gt; uninitialized_fill_n()必须析构已产生的所有元素。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 题26:树的子结构[未做出]]]></title>
        <id>https://lixin-scut.github.io//post/shu-ti-26shu-de-zi-jie-gou-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/shu-ti-26shu-de-zi-jie-gou-wei-zuo-chu">
        </link>
        <updated>2020-02-23T01:25:18.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
</blockquote>
<p>【未做出】<br>
首先一定要注意递归和判断中使用的函数和顺序（这一点其实已经做得很好了）HasSubtree函数负责确定根结点，isSubTree负责遍历每个结点是否相符<br>
我犯的致命错误就是忘记了isSubTree中判断的是子结构，cur2出现NULL的时候cur1完全有可能不是NULL<br>
一定要理解先判断cur2为NULL再判断cur1为NULL的原因</p>
<pre><code>class Solution {
public:
    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)
    {
        if(pRoot1==NULL||pRoot2==NULL)
             return false;
        return isSubTree(pRoot1,pRoot2)||HasSubtree(pRoot1-&gt;left,pRoot2)||HasSubtree(pRoot1-&gt;right,pRoot2);
    }
        
    bool isSubTree(TreeNode* cur1, TreeNode* cur2){
        if(cur2==NULL)
            return true;
        if(cur1==NULL)
            return false;
        if(cur1-&gt;val!=cur2-&gt;val)
            return false;
        return isSubTree(cur1-&gt;left,cur2-&gt;left)&amp;&amp;isSubTree(cur1-&gt;right,cur2-&gt;right);
    }
};
</code></pre>
<p>书本题解：<br>
要查找树A中是否存在和树B结构一样的子树，我们可以分成两步：第一步，在树A中找到和树B的根节点的值一样的节点R;第二步，判断树A中以R为根节点的子树是不是包含和树B一样的结构。<br>
第一步在树A中查找与根节点的值一样的节点，这实际上就是树的遍历。对二叉树这种数据结构熟悉的读者自然知道可以用递归的方法去遍历, 也可以用循环的方法去遍历。由于递归的代码实现比较简洁，如果没有特别要求，那么我们通常会采用递归的方式。<br>
一定要注意边界条件的检查，即检查空指针。当树A或树B为空的时候，定义相应的输出。<br>
我们递归调用HasSubtree遍历二叉树A。如果发现某一节点的值和树B的头节点的值相同，则调用DoesTreelHaveTree2,进行第二步判断。<br>
第二步是判断树A中以R为根节点的子树是不是和树B具有相同的结构。同样，我们也可以用递归的思路来考虑：如果节点R的值和树B的根节点不相同，则以R为根节点的子树和树B肯定不具有相同的节点；如果它们的值相同，则递归地判断它们各自的左右节点的值是不是相同。递归的终止条件是我们到达了树A或者树B的叶节点<br>
需要多处判断一个指针是不是nullptr,这样做是为了避免试图访问空指针而造成程序崩溃，同时也设置了递归调用的退出条件。在写遍历树的代码的时候一定要高度警惕，在每一处需要访问地址的时候都要问自己这个地址有没有可能是nullptr、如果是nullptr则该怎么处理。<br>
一个细节值得我们注意：本题中节点中值的类型为double，由于计算机表示小数(包括float和double型小数)都有误差，我们不能直接用等号(==)判断两个小数是否相等。如果两个小数的差的绝对值 很小，如小于0.0000001,就可以认为它们相等<br>
所以在判断两个节点的值是不是相等时，不能直接写pRoot1-&gt;m_dbValue == pRoot2-&gt;m_ dbValue,这是因为在计算机内表示小数时(包括float和double型小数)都有误差。判断两个小数是否相等，只能判断它们之差的绝对值是不是在一个很小的范围内。如果两个数相差很小，就可以认为它们相等。这就是我 们定义函数Equal的原因。</p>
<pre><code>bool HasSubtree(BinaryTreeNode* pRoot1, BinaryTreeNode* pRoot2)
{
    bool result = false;

    if(pRoot1 != nullptr &amp;&amp; pRoot2 != nullptr)
    {
        if(Equal(pRoot1-&gt;m_dbValue, pRoot2-&gt;m_dbValue))
            result = DoesTree1HaveTree2(pRoot1, pRoot2);
        if(!result)
            result = HasSubtree(pRoot1-&gt;m_pLeft, pRoot2);
        if(!result)
            result = HasSubtree(pRoot1-&gt;m_pRight, pRoot2);
    }

    return result;
}

bool DoesTree1HaveTree2(BinaryTreeNode* pRoot1, BinaryTreeNode* pRoot2)
{
    if(pRoot2 == nullptr)
        return true;

    if(pRoot1 == nullptr)
        return false;

    if(!Equal(pRoot1-&gt;m_dbValue, pRoot2-&gt;m_dbValue))
        return false;

    return DoesTree1HaveTree2(pRoot1-&gt;m_pLeft, pRoot2-&gt;m_pLeft) &amp;&amp;
        DoesTree1HaveTree2(pRoot1-&gt;m_pRight, pRoot2-&gt;m_pRight);
}

bool Equal(double num1, double num2)
{
    if((num1 - num2 &gt; -0.0000001) &amp;&amp; (num1 - num2 &lt; 0.0000001))
        return true;
    else
        return false;
}
</code></pre>
<p>书中思路分析很清楚，包括对函数的分割和返回值的设置，以及对nullptr的检测。<br>
然后最重点的就是对double和float的相等判断条件。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[空指针、野指针与空悬指针]]></title>
        <id>https://lixin-scut.github.io//post/kong-zhi-zhen-ye-zhi-zhen-yu-kong-xuan-zhi-zhen</id>
        <link href="https://lixin-scut.github.io//post/kong-zhi-zhen-ye-zhi-zhen-yu-kong-xuan-zhi-zhen">
        </link>
        <updated>2020-02-22T10:09:54.000Z</updated>
        <content type="html"><![CDATA[<h3 id="空指针">空指针</h3>
<p>被初始化或赋值为nullptr、NULL或者0的指针</p>
<h3 id="野指针">野指针</h3>
<p>就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）指针变量在定义时如果未初始化，其值是随机的，指针变量的值是别的变量的地址，意味着指针指向了一个地址是不确定的变量，此时去解引用就是去访问了一个不确定的地址，所以结果是不可知的。</p>
<h3 id="空悬指针">空悬指针</h3>
<p>当指针所指向的对象已经被销毁或者被析构之后，指针对象本身还是存在的，但是已经成为了空悬指针。</p>
<pre><code>int * func ( void )
{
    int num = 123;
    /* ... */
    return &amp;num; //返回一个空悬指针
}
</code></pre>
<p>实验：</p>
<pre><code>int main() {
    int* nullPtr = nullptr;
    int* unknowPtr ;
    int* emptyPtr = new int(100);
    delete emptyPtr;
    cout &lt;&lt; nullPtr &lt;&lt; &quot; &quot; &lt;&lt; unknowPtr &lt;&lt; &quot; &quot; &lt;&lt; emptyPtr &lt;&lt; endl;
    cout&lt;&lt; *emptyPtr &lt;&lt; endl; //cannot *nullPtr,*unknowPtr,*emptyPtr
}
</code></pre>
<p>环境：Clion<br>
编译器：clang-902.0.39.2</p>
<p>结果</p>
<pre><code>0x0 0x0 0x7fcfe4400370
100
</code></pre>
<p>可以看到这个编译器下，空指针和野指针都是指向了同一个地址，所以都不能解引用，而emptyPtr还有趣，解引用后还是同一个值，查阅之后发现原来delete也不是立马把内存中的对象清除，而是先保留，等到有对象需要堆内存的时候可以直接清除。</p>
]]></content>
    </entry>
</feed>