<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2020-02-07T04:29:11.537Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[队列 题9:用两个栈实现队列]]></title>
        <id>https://lixin-ee.github.io//post/dui-lie-ti-9yong-liang-ge-zhan-shi-xian-dui-lie</id>
        <link href="https://lixin-ee.github.io//post/dui-lie-ti-9yong-liang-ge-zhan-shi-xian-dui-lie">
        </link>
        <updated>2020-02-07T03:33:50.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
</blockquote>
<pre><code>class Solution
{
public:
    void push(int node) {
        stack1.push(node);
    }

    int pop() {
        if(stack2.empty()){
            while(stack1.size()){
                stack2.push(stack1.top());
                stack1.pop();
            }
        }
				//补充
				 if(stack2.empty())
					 throw new exception(&quot;queue is empty&quot;);
					 
        int res=stack2.top();
        stack2.pop();
        return res;
    }

private:
    stack&lt;int&gt; stack1;
    stack&lt;int&gt; stack2;
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>1插入一个元素,先把它插入stack<br>
2删除一个元素的步骤：当stack2不为空时，在stack2中的栈顶元素是最先进入队列的元素，可以弹出。当stack2 为空时，我们把stack1中的元素逐个弹出并压入stack2。由于先进入队列的元素被压到stackl的底端，经过弹出和压入操作之后就处于stack2的顶端, 又可以直接弹出。</p>
</blockquote>
<pre><code>template &lt;typename T&gt; class CQueue
{
public:
    CQueue(void);
    ~CQueue(void);
    
    // 在队列末尾添加一个结点
    void appendTail(const T&amp; node);

    // 删除队列的头结点
    T deleteHead();

private:
    stack&lt;T&gt; stack1;
    stack&lt;T&gt; stack2;
};

template &lt;typename T&gt; CQueue&lt;T&gt;::CQueue(void)
{
}

template &lt;typename T&gt; CQueue&lt;T&gt;::~CQueue(void)
{
}

template&lt;typename T&gt; void CQueue&lt;T&gt;::appendTail(const T&amp; element)
{
    stack1.push(element);
} 

template&lt;typename T&gt; T CQueue&lt;T&gt;::deleteHead()
{
    if(stack2.size()&lt;= 0)
    {
        while(stack1.size()&gt;0)
        {
            T&amp; data = stack1.top();
            stack1.pop();
            stack2.push(data);
        }
    }

    if(stack2.size() == 0)
        throw new exception(&quot;queue is empty&quot;);

    T head = stack2.top();
    stack2.pop();

    return head;
}
</code></pre>
<p>注意我的代码中存在鲁棒性不强的问题，在判断stack2为空之后可能stack1还是可能为空，所以需要再次检查一次stack2是否为空</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 题8:二叉树的下一个节点]]></title>
        <id>https://lixin-ee.github.io//post/shu-ti-8er-cha-shu-de-xia-yi-ge-jie-dian</id>
        <link href="https://lixin-ee.github.io//post/shu-ti-8er-cha-shu-de-xia-yi-ge-jie-dian">
        </link>
        <updated>2020-02-05T10:36:13.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
</blockquote>
<p>主要是要注意我把两种情况合在一起计算了，一是 目标节点是其父节点的左子节点，二是 目标是其父节点的右子节点。循环的条件很重要，本来我用的是判断当前节点和父节点的关系，但是后来发现要先判断父节点是否为空，就改了，最后的判断也相应地需要修改</p>
<pre><code>class Solution {
public:
    TreeLinkNode* GetNext(TreeLinkNode* pNode)
    {
        TreeLinkNode *cur;
        if(pNode-&gt;right!=NULL){
            cur=pNode-&gt;right;
            while(cur-&gt;left!=NULL)
                cur=cur-&gt;left;
            return cur;
        }
        cur=pNode;
        while(cur-&gt;next!=NULL)
            if(cur!=cur-&gt;next-&gt;left)
                cur=cur-&gt;next;
            else
                break;
        if(cur-&gt;next!=NULL)
            return cur-&gt;next;
        return NULL;
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>1.如果一个节点有右了树，那么它的下一个节点就是它的右子树中的最 左子节点。<br>
2.一个节点没有右子树的情形：<br>
a.如果节点是它父节点的左子节点，那么它的下一个节点就是它的父节点。<br>
b.如果一个节点既没有右子树，并且它还是它父节点的右子节点，那么 这种情形就比较复杂。我们可以沿着指向父节点的指针一直向上遍历，直 到找到一个是它父节点的左子节点的节点。如果这样的节点存在，那么这 个节点的父节点就是我们要找的下一个节点。</p>
</blockquote>
<pre><code>struct BinaryTreeNode
{
    int                    m_nValue;
    BinaryTreeNode*        m_pLeft;
    BinaryTreeNode*        m_pRight;
    BinaryTreeNode*        m_pParent;
};

BinaryTreeNode* GetNext(BinaryTreeNode* pNode)
{
    if(pNode == nullptr)
        return nullptr;

    BinaryTreeNode* pNext = nullptr;
    if(pNode-&gt;m_pRight != nullptr)
    {
        BinaryTreeNode* pRight = pNode-&gt;m_pRight;
        while(pRight-&gt;m_pLeft != nullptr)
            pRight = pRight-&gt;m_pLeft;

        pNext = pRight;
    }
    else if(pNode-&gt;m_pParent != nullptr)
    {
        BinaryTreeNode* pCurrent = pNode;
        BinaryTreeNode* pParent = pNode-&gt;m_pParent;
        while(pParent != nullptr &amp;&amp; pCurrent == pParent-&gt;m_pRight)
        {
            pCurrent = pParent;
            pParent = pParent-&gt;m_pParent;
        }

        pNext = pParent;
    }

    return pNext;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 题7:重建二叉树[未做出][待阅读]]]></title>
        <id>https://lixin-ee.github.io//post/shu-ti-7chong-jian-er-cha-shu-wei-zuo-chu-dai-yue-du</id>
        <link href="https://lixin-ee.github.io//post/shu-ti-7chong-jian-er-cha-shu-wei-zuo-chu-dai-yue-du">
        </link>
        <updated>2020-02-05T01:13:45.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回</p>
</blockquote>
<p>这道题的要点主要在于前序遍历和中序遍历的要点关联，难点在于两个数组的范围是不一致的，所以必须要两对下标（或者两对迭代器）来处理<br>
然后在迭代的时候需要中间变量来处理好在两个数组中左右子树的节点范围变化</p>
<pre><code>class Solution {
public:
    //TreeNode* buildTree(vector&lt;int&gt; &amp;pre,int pre_beg,int pre_end,vector&lt;int&gt; &amp;vin,int vin_beg,int vin_end);
    TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) {
        if(pre.empty()||vin.empty())
            return NULL;
        return buildTree(pre,0,pre.size()-1,vin,0,vin.size()-1);
    }
    
    TreeNode* buildTree(vector&lt;int&gt; &amp;pre,int pre_beg,int pre_end,vector&lt;int&gt; &amp;vin,int vin_beg,int vin_end)
    {
        int rootValue=pre[pre_beg];
        TreeNode *cur=new TreeNode(rootValue);
        
        if(pre_beg==pre_end){
            if(vin_beg==vin_end&amp;&amp;pre[pre_beg]==vin[vin_beg])
                return cur;
        }
        int vin_cur;
        for(int i=vin_beg;i&lt;=vin_end;++i)
            if(vin[i]==rootValue){
                vin_cur=i;
                break;
            }
        
        int leftLength=vin_cur-vin_beg;
        int left_pre_end=pre_beg+leftLength;
        if(leftLength&gt;0){
            cur-&gt;left=buildTree(pre,pre_beg+1,left_pre_end,vin,vin_beg,vin_cur-1);
        }
        if(leftLength&lt;pre_end-pre_beg)
            cur-&gt;right=buildTree(pre,left_pre_end+1,pre_end,vin,vin_cur+1,vin_end);
        return cur;
    }
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>在二叉树的前序遍历序列中，第一个数字总是树的根节点的值。但在 中序遍历序列中，根节点的值在序列的中间，左子树的节点的值位于根节 点的值的左边，而右子树的节点的值位于根节点的值的右边。因此我们需 要扫描中序遍历序列，才能找到根节点的值。<br>
我们已经分别找到了左、右子树的前序遍历序列和中序遍历序列, 我们可以用同样的方法分别构建左、右子树。也就是说，接下来的事情可以用递归的方法去完成。</p>
</blockquote>
<pre><code>BinaryTreeNode* Construct(int* preorder, int* inorder, int length)
{
    if(preorder == nullptr || inorder == nullptr || length &lt;= 0)
        return nullptr;

    return ConstructCore(preorder, preorder + length - 1,
        inorder, inorder + length - 1);
}

BinaryTreeNode* ConstructCore
(
    int* startPreorder, int* endPreorder, 
    int* startInorder, int* endInorder
)
{
    // 前序遍历序列的第一个数字是根结点的值
    int rootValue = startPreorder[0];
    BinaryTreeNode* root = new BinaryTreeNode();
    root-&gt;m_nValue = rootValue;
    root-&gt;m_pLeft = root-&gt;m_pRight = nullptr;

    if(startPreorder == endPreorder)
    {
        if(startInorder == endInorder &amp;&amp; *startPreorder == *startInorder)
            return root;
        else
            throw std::exception(&quot;Invalid input.&quot;);
    }

    // 在中序遍历中找到根结点的值
    int* rootInorder = startInorder;
    while(rootInorder &lt;= endInorder &amp;&amp; *rootInorder != rootValue)
        ++ rootInorder;

    if(rootInorder == endInorder &amp;&amp; *rootInorder != rootValue)
        throw std::exception(&quot;Invalid input.&quot;);

    int leftLength = rootInorder - startInorder;
    int* leftPreorderEnd = startPreorder + leftLength;
    if(leftLength &gt; 0)
    {
        // 构建左子树
        root-&gt;m_pLeft = ConstructCore(startPreorder + 1, leftPreorderEnd, 
            startInorder, rootInorder - 1);
    }
    if(leftLength &lt; endPreorder - startPreorder)
    {
        // 构建右子树
        root-&gt;m_pRight = ConstructCore(leftPreorderEnd + 1, endPreorder,
            rootInorder + 1, endInorder);
    }

    return root;
}

</code></pre>
<blockquote>
<p>在函数ConstructCore中，我们先根据前序遍历序列的第一个数字创建 根节点，接卜来在中序遍历序列中找到根节点的位置，这样就能确定左、 右子树节点的数量。在前序遍历和中序遍历序列中划分了左、右子树节点 的值之后，我们就可以递归地调用函数ConstructCore去分别构建它的左、 右子树</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 题6:从尾到头打印链表[未做出]]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-ti-6cong-wei-dao-tou-da-yin-lian-biao-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-ti-6cong-wei-dao-tou-da-yin-lian-biao-wei-zuo-chu">
        </link>
        <updated>2020-02-04T00:43:41.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p>
</blockquote>
<p>这道题一开始我只想到了deque的push_front和vector强行插入头节点 以及 将链表翻转<br>
但是这三种方式都不是很好，翻转链表还会改变链表的结构，需要和面试官商量<br>
然后看了书之后才发现书的方法是特别简洁而巧妙，所以但看书还是不够的，得老老实实动手</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; printListFromTailToHead(ListNode* head) {
        //【未做出】
        /*
        //首先就是可以用栈存储
        stack&lt;int&gt; node_val;
        ListNode *cur=head;
        vector&lt;int&gt; res;
        while(cur!=NULL){
            node_val.push(cur-&gt;val);
            cur=cur-&gt;next;
        }
        while(node_val.size()){
            res.push_back(node_val.top());
            node_val.pop();
        }
        return res;
        */
        //然后通过栈联想到递归（这个思维很重要，不要仅仅限制于递归到栈）
        vector&lt;int&gt; res;
        if(head==NULL)
            return res;
        add_value(head,res);
        return res;
    }
    
    void add_value(ListNode* cur,vector&lt;int&gt; &amp;res){
        if(cur-&gt;next!=NULL)
            add_value(cur-&gt;next,res);
        res.push_back(cur-&gt;val);
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>解决这个问题肯定是要遍历链表<br>
遍历的顺序是从头到尾，可输出的顺序却是从尾到头。第一个遍历的节点最后一个输出，而最后一个遍历到的节点第一个输出。这就是典型的“后进先出”，我们可以用栈实现这种顺序。</p>
</blockquote>
<pre><code>void PrintListReversingly_Iteratively(ListNode* pHead)
{
    std::stack&lt;ListNode*&gt; nodes;

    ListNode* pNode = pHead;
    while(pNode != nullptr)
    {
        nodes.push(pNode);
        pNode = pNode-&gt;m_pNext;
    }

    while(!nodes.empty())
    {
        pNode = nodes.top();
        printf(&quot;%d\t&quot;, pNode-&gt;m_nValue);
        nodes.pop();
    }
}
</code></pre>
<blockquote>
<p>既然想到了用栈来实现这个函数，而递归在本质上就是一个栈结构， 于是很自然地又想到了用递归来实现。要实现反过来输出链表，我们每访 问到一个节点的时候，先递归输出它后面的节点，再输出该节点自身，这 样链表的输出结果就反过来了。</p>
</blockquote>
<pre><code>void PrintListReversingly_Recursively(ListNode* pHead)
{
    if(pHead != nullptr)
    {
        if (pHead-&gt;m_pNext != nullptr)
        {
            PrintListReversingly_Recursively(pHead-&gt;m_pNext);
        }
 
        printf(&quot;%d\t&quot;, pHead-&gt;m_nValue);
    }
}
</code></pre>
<blockquote>
<p>上面的基于递归的代码看起来很简洁，但有一个问题：当链表非常长的时候，就会导致函数调用的层级很深，从而有可能导致函数调用栈溢出。显然用栈基于循环实现的代码的鲁棒性要好一点。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 题5:替换空格[未做出]]]></title>
        <id>https://lixin-ee.github.io//post/zi-fu-chuan-ti-5ti-huan-kong-ge-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/zi-fu-chuan-ti-5ti-huan-kong-ge-wei-zuo-chu">
        </link>
        <updated>2020-02-03T00:04:40.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
</blockquote>
<p>这道题的难点在于这是个char* ，而不是string，所以不能简单地一次循环把空格直接替换<br>
否则因为是把一个字符换成三个字符，而char* 的空间是固定的，直接空间就炸裂了<br>
所以必须先循环一遍，统计空格的数量，再分配新的空间<br>
为什么返回是void???原来是因为早已安排了额外的空间length...所以不能用sizeof....<br>
提交之后一直没通过，原来是'\0'这个家伙，所以书中的int cur=new_len;而不是int cur=new_len-1;<br>
我有个想法，平时可以将char* 中的'\0'类比string的尾后位置，因为它既不会算入size()，又可以有这个位置（str[end]）</p>
<pre><code>class Solution {
public:
	void replaceSpace(char *str,int length) {
        int ori_len=0;//记得size不会统计'\0'
        int count_space=0;
        int i=0;
        while(str[i]!='\0'){
            ++ori_len;
            if(str[i]==' ')
                ++count_space;
            ++i;
        }
        int new_len=ori_len+2*count_space;
        if(length&lt;=new_len)//注意length参数
            return;
        int cur=new_len;
        int pre=ori_len;//注意！！！这里不可以忽略'\0'这个家伙
        //重点是从后往前降低时间复杂度，不要从前往后
        while(pre&gt;=0&amp;&amp;cur&gt;pre) //注意 不是必须去到pre==0，当cur和pre重合就说明没有空格了，可以提前结束
        {
            if(str[pre]==' '){
                str[cur--]='0';
                str[cur--]='2';
                str[cur--]='%';
            }else
                str[cur--]=str[pre];
            --pre;
        }
	}
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>看到这个题目，我们首先应该想到的是原来一个空格字符，替换之后变成，％、2和0这3个字符，因此字符串会变长。如果是在原来的字符串 上进行替换，就有可能覆盖修改在该字符串后面的内存。如果是创建新的字符串并在新的字符串上进行替换，那么我们可以自己分配足够多的内存。 由于有两种不同的解决方案，我们应该向面试官问清楚，让他明确告诉我们他的需求。<br>
暴力法：<br>
最直观的做法是从头到尾扫描字符 串，每次碰到空格字符的时候进行替换。由于是把1个字符替换成3个字 符，我们必须要把空格后面所有的字符都后移2字节，否则就有两个字符 被覆盖了。<br>
假设字符串的长度是如 对每个空格字符，需要移动后面O(n)个字符, 因此对于含有O(n)个空格字符的字符串而言，总的时间效率是O(n^2)<br>
时间复杂度为O(n)的解法:<br>
先遍历一次字符串，统计出字符串中空格的总数， 并可以由此计算出替换之后的字符串的总长度。<br>
从字符串的后面开始复制和替换。首先准备两个指针：P1和P2。 P1指向原始字符串的末尾，而P2指向替换之后的字符串的末尾。接下来向前移动指针R1,逐个把它指向的字符复制到P2指向的位置，直到碰到第一个空格为止。<br>
碰到第一个空格之后， 把P1向前移动1格，在已之前插入字符串&quot;%20&quot;„由于&quot;％20&quot;的长度为3, 同时也要把P2向前移动3格<br>
当P1和P2指向同一位置，表明所有空格都已经替换完毕。（可以提前终止，不必走完整个字符串）<br>
从上面的分析中我们可以看出，所有的字符都只复制（移动）一次， 因此这个算法的时间效率是O(n),比第一个思路要快。</p>
</blockquote>
<pre><code>/*length 为字符数组str的总容量，大于或等于字符串str的实际长度*/
void ReplaceBlank(char str[], int length)
{
    if(str == nullptr &amp;&amp; length &lt;= 0)
        return;

    /*originalLength 为字符串str的实际长度*/
    int originalLength = 0;
    int numberOfBlank = 0;
    int i = 0;
    while(str[i] != '\0')
    {
        ++ originalLength;

        if(str[i] == ' ')
            ++ numberOfBlank;

        ++ i;
    }

    /*newLength 为把空格替换成'%20'之后的长度*/
    int newLength = originalLength + numberOfBlank * 2;
    if(newLength &gt; length)
        return;

    int indexOfOriginal = originalLength;
    int indexOfNew = newLength;
    while(indexOfOriginal &gt;= 0 &amp;&amp; indexOfNew &gt; indexOfOriginal)
    {
        if(str[indexOfOriginal] == ' ')
        {
            str[indexOfNew --] = '0';
            str[indexOfNew --] = '2';
            str[indexOfNew --] = '%';
        }
        else
        {
            str[indexOfNew --] = str[indexOfOriginal];
        }

        -- indexOfOriginal;
    }
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 题4:二维数组中的查找]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-er-wei-shu-zu-zhong-de-cha-zhao</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-er-wei-shu-zu-zhong-de-cha-zhao">
        </link>
        <updated>2020-02-02T00:59:11.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述<br>
在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<pre><code>class Solution {
public:
    bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) {
        if(array.empty())
               return false;
        int row,col;
        row=array.size();
        col=array[0].size();
        int cur_row,cur_col;
        cur_row=0,cur_col=col-1;
        while(cur_row&lt;row&amp;&amp;cur_col&gt;=0){
            if(target==array[cur_row][cur_col])
                return true;
            if(target&lt;array[cur_row][cur_col])
                --cur_col;
            else 
                ++cur_row;
        }
        return false;
    }
};
</code></pre>
<p>书本题解：<br>
难题是因为我们在二维数组的中间选取一个数字来和要查找的数字进行比较，这就导致下一次要查找的是两个相互重叠的区域。<br>
我们发现如下规律：首先选取数组中右上角的数字。如果该数字等于要查找的数字，则查找过程结束；如果该数字大于要查找的数字，则剔除这个数字所在的列；如果该数字小于要查找的数字, 则剔除这个数字所在的行。也就是说，如果要查找的数字不在数组的右上 角，则每一次都在数组的查找范围中剔除一行或者一列，这样每一步都可 以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。</p>
<pre><code>#include &lt;cstdio&gt;

bool Find(int* matrix, int rows, int columns, int number)
{
    bool found = false;

    if(matrix != nullptr &amp;&amp; rows &gt; 0 &amp;&amp; columns &gt; 0)
    {
        int row = 0;
        int column = columns - 1;
        while(row &lt; rows &amp;&amp; column &gt;=0)
        {
            if(matrix[row * columns + column] == number)
            {
                found = true;
                break;
            }
            else if(matrix[row * columns + column] &gt; number)
                -- column;
            else
                ++ row;
        }
    }

    return found;
}
</code></pre>
<p>我们每次都选取数组查找范围内的右上角数字。同样，我们也可以选取左下角的数字。感兴趣的读者不妨自己分析一下每次 都选取左下角数字的查找过程。但我们不能选择左上角数字或者右下角数字。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 题3:数组中重复的数字[未做出]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-shu-zu-zhong-chong-fu-de-shu-zi</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-shu-zu-zhong-chong-fu-de-shu-zi">
        </link>
        <updated>2020-02-01T03:26:23.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
</blockquote>
<p>因为数组的条件比较苛刻，所以其实有很多巧妙的解法，不修改原数组的方法是对数字的范围进行二分法，修改原数组的方法是利用数组下表一一对应的方法，上述两者都需要额外的空间，如果有额外的空间的话可以很方便地利用hashset解决问题</p>
<pre><code>class Solution {
public:
    // Parameters:
    //        numbers:     an array of integers
    //        length:      the length of array numbers
    //        duplication: (Output) the duplicated number in the array number
    // Return value:       true if the input is valid, and there are some duplications in the array number
    //                     otherwise false
    //不修改原数组的方法
    bool duplicate(int numbers[], int length, int* duplication){
        if(length==0) return -1;
        int left=0,right=length-1;
        while(left&lt;right){
            int mid=left+(right-left)/2;
            int count=0;
            for(int i=0;i&lt;length;++i)
                if(numbers[i]&gt;=left&amp;&amp;numbers[i]&lt;=mid)
                    ++count;
            if(count&gt;mid-left+1)
                right=mid;
            else
                left=mid+1;
        }
        if(left==right)
            return left;
        return -1;
    }
    
    /*
    //修改原数组的方法
    bool duplicate(int numbers[], int length, int* duplication){
        for(int i=0;i&lt;length;++i){
            while(i!=numbers[i]){
                if(numbers[i]==numbers[numbers[i]])
                    return true;
                swap(numbers[i],numbers[numbers[i]]);
            }
        }
        return false;
    }
    
    //hashset方法
    bool duplicate(int numbers[], int length, int* duplication) {
        unordered_set&lt;int&gt; num_set;
        for(int i=0;i&lt;length;++i){
            if(num_set.count(numbers[i]))
                return true;
            num_set.insert(numbers[i]);
        }
        return false;
    }
    */
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>解决这个问题的一个简单的方法是先把输入的数组排序。从排序的数组中找出重复的数字只需要从头到尾扫描排序后的数组。排序一个长度为n的数组需要O(nlogn)的时间。<br>
还可以利用哈希表来解决这个问题。从头到尾按顺序扫描数组的每个 数字，每扫描到一个数字的时候，都可以用0(1)的时间来判断哈希表里是否已经包含了该数字。如果哈希表里还没有这个数字，就把它加入哈希表。 如果哈希表里已经存在该数字，就找到一个重复的数字。这个算法的时间 复杂度是O(n)，但它提高时间效率是以一个大小为O(n)的哈希表为代价的。<br>
空间复杂度是0(1)的算法：我们注意到数组中的数字都在0〜n-1的范围内。如果这个数组中没有 重复的数字，那么当数组排序之后数字i将出现在下标为i的位置。由于数组中有重复的数字，有些位置可能存在多个数字，同时有些位置可能没有数字。<br>
现在让我们重排这个数组。从头到尾依次扫描这个数组中的每个数字。 当扫描到下标为i的数字时，首先比较这个数字(用〃，表示)是不是等于i. 如果是，则接着扫描下一个数字；如果不是，则再拿它和第加个数字进行 比较。如果它和第彻个数字相等，就找到了一个重复的数字(该数字在下 标为，和m的位置都出现了)；如果它和第m个数字不相等，就把第i个数字和第m个数字交换，把m放到属于它的位置。接下来再重复这个比较、 交换的过程，直到我们发现一个重复的数字。</p>
</blockquote>
<pre><code>bool duplicate(int numbers[], int length, int* duplication)
{
    if(numbers == nullptr || length &lt;= 0)
        return false;

    for(int i = 0; i &lt; length; ++i)
    {
        if(numbers[i] &lt; 0 || numbers[i] &gt; length - 1)
            return false;
    }

    for(int i = 0; i &lt; length; ++i)
    {
        while(numbers[i] != i)
        {
            if(numbers[i] == numbers[numbers[i]])
            {
                *duplication = numbers[i];
                return true;
            }

            // 交换numbers[i]和numbers[numbers[i]]             
            int temp = numbers[i];
            numbers[i] = numbers[temp];
            numbers[temp] = temp;
        }
    }

    return false;
}
</code></pre>
<blockquote>
<p>代码中尽管有一个两重循环，但每个数字最多只要交换两次就能找到 属于它自己的位置，因此总的时间复杂度是O(n).另外，所有的操作步骤 都是在输入数组上进行的，不需要额外分配内存，因此空间复杂度为O(1)。</p>
</blockquote>
<blockquote>
<p>接下来我们尝试避免使用O(n)的辅助空间并且不修改原数组的方法。为什么数组中会有重复的数字？假如没有重复的数字，那么在从1〜〃的范围里只有&quot;个数字。由于 数组里包含超过n个数字，所以一定包含了重复的数字。看起来在某范围 里数字的个数对解决这个问题很重要。<br>
我们把从1〜n的数字从中间的数字m分为两部分，前面一半为1〜m， 后面一半为m+1〜n。如果1〜m的数字的数目超过m,那么这一半的区间 里一定包含重复的数字；否则，另一半m+1〜n的区间里一定包含重复的数 字。我们可以继续把包含重复数字的区间一分为二，直到找到一个重复的 数字。这个过程和二分查找算法很类似，只是多了一步统计区间里数字的数目。<br>
注意是利用某个数字去对比数组中的元素，而不是用数组的元素去对比数字</p>
</blockquote>
<pre><code>int getDuplication(const int* numbers, int length)
{
    if(numbers == nullptr || length &lt;= 0)
        return -1;

    int start = 1;
    int end = length - 1;
    while(end &gt;= start)
    {
        int middle = ((end - start) &gt;&gt; 1) + start;
        int count = countRange(numbers, length, start, middle);
        if(end == start)
        {
            if(count &gt; 1)
                return start;
            else
                break;
        }

        if(count &gt; (middle - start + 1))
            end = middle;
        else
            start = middle + 1;
    }
    return -1;
}

int countRange(const int* numbers, int length, int start, int end)
{
    if(numbers == nullptr)
        return 0;

    int count = 0;
    for(int i = 0; i &lt; length; i++)
        if(numbers[i] &gt;= start &amp;&amp; numbers[i] &lt;= end)
            ++count;
    return count;
}
</code></pre>
<blockquote>
<p>上述代码按照二分查找的思路，如果输入长度为n的数组，那么函数 countRange将被调用O(logn)次，每次需要O(n)的时间，因此总的时间复杂 度是O(nlogn)，空间复杂度为O(1)。和最前面提到的需要O(n)的辅助空间 的算法相比，这种算法相当于以时间换空间。<br>
需要指出的是，这种算法不能保证找出所有重复的数字。</p>
</blockquote>
<blockquote>
<p>从上述分析中我们可以看出，如果面试官提出不同的功能要求(找出任意一个重复的数字、找出所有重复的数字)或者性能要求(时间效率优先、空间效率优先)，那么我们最终选取的算法也将不同。这也说明在面试中和面试官交流的重要性，我们一定要在动手写代码之前弄清楚面试官的需求。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math 172. 阶乘后的零[简单]]]></title>
        <id>https://lixin-ee.github.io//post/math-172-jie-cheng-hou-de-ling-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/math-172-jie-cheng-hou-de-ling-jian-dan">
        </link>
        <updated>2020-01-31T02:23:41.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个整数 n，返回 n! 结果尾数中零的数量。<br>
示例 1:<br>
输入: 3<br>
输出: 0<br>
解释: 3! = 6, 尾数中没有零。<br>
示例 2:<br>
输入: 5<br>
输出: 1<br>
解释: 5! = 120, 尾数中有 1 个零.<br>
说明: 你算法的时间复杂度应为 O(log n) 。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/factorial-trailing-zeroes<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>唯有 5的倍数* 偶数 能导致出现0<br>
一开始我是直接统计5的倍数的数字有多少个，因为偶数肯定比5的倍数的数字多，所以不用担心找不到偶数，所以直接res=n/5;<br>
然后提交错误，发现需要注意的是 5的次方会导致0增加 比如25有两个5，125有三个5.<br>
然后我发现一个特点，n/5之后如果大于5，那就等于说肯定有一个数是5的幂次，因为比如5，10，15，20，25，30除以5得到的结果分别是1，2，3，4，5，6，可以看到大于5的话说明还有5的倍数，大于125同理，除以两次5之后还是有个5，所以就继续除以5并将个数加到res里面<br>
这个就相当于计算n最接近的5的次方，那刚好时间复杂度就是O（logn）了，和题目暗示的一致<br>
题解说得比我更清楚，可以仔细看看</p>
<pre><code>class Solution {
public:
    int trailingZeroes(int n) {
        int res=0;
        while(n&gt;=5){
            res+=n/5;
            n/=5;
        }
        return res;
    }
};
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>解法一<br>
之前小红书面试的时候碰到的一道题，没想到又是 leetcode 的原题。这种没有通用解法的题，完全依靠于对题目的分析理解了，自己当时也是在面试官的提示下慢慢出来的，要是想不到题目的点，还是比较难做的。<br>
首先肯定不能依赖于把阶乘算出来再去判断有多少个零了，因为阶乘很容易就溢出了，所以先一步一步理一下思路吧。<br>
首先末尾有多少个 0 ，只需要给当前数乘以一个 10 就可以加一个 0。<br>
再具体对于 5!，也就是 5 * 4 * 3 * 2 * 1 = 120，我们发现结果会有一个 0，原因就是 2 和 5 相乘构成了一个 10。而对于 10 的话，其实也只有 2 * 5 可以构成，所以我们只需要找有多少对 2/5。<br>
把每个乘数再稍微分解下，看一个例子。<br>
11! = 11 * 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1 = 11 * (2 * 5) * 9 * (4 * 2) * 7 * (3 * 2) * (1 * 5) * (2 * 2) * 3 * (1 * 2) * 1<br>
对于含有 2 的因子的话是 1 * 2, 2 * 2, 3 * 2, 4 * 2 ...<br>
对于含有 5 的因子的话是 1 * 5, 2 * 5...<br>
含有 2 的因子每两个出现一次，含有 5 的因子每 5 个出现一次，所有 2 出现的个数远远多于 5，换言之找到一个 5，一定能找到一个 2 与之配对。所以我们只需要找有多少个 5。<br>
直接的，我们只需要判断每个累乘的数有多少个 5 的因子即可。</p>
</blockquote>
<pre><code>public int trailingZeroes(int n) {
    int count = 0;
    for (int i = 1; i &lt;= n; i++) {
        int N = i;
        while (N &gt; 0) {
            if (N % 5 == 0) {
                count++;
                N /= 5;
            } else {
                break;
            }
        }
    }
    return count;

}
</code></pre>
<blockquote>
<p>但发生了超时，我们继续分析。<br>
对于一个数的阶乘，就如之前分析的，5 的因子一定是每隔 5 个数出现一次，也就是下边的样子。<br>
n! = 1 * 2 * 3 * 4 * (1 * 5) * ... * (2 * 5) * ... * (3 * 5) *... * n<br>
因为每隔 5 个数出现一个 5，所以计算出现了多少个 5，我们只需要用 n/5 就可以算出来。<br>
但还没有结束，继续分析。<br>
... * (1 * 5) * ... * (1 * 5 * 5) * ... * (2 * 5 * 5) * ... * (3 * 5 * 5) * ... * n<br>
每隔 25 个数字，出现的是两个 5，所以除了每隔 5 个数算作一个 5，每隔 25 个数，还需要多算一个 5。<br>
也就是我们需要再加上 n / 25 个 5。<br>
同理我们还会发现每隔 5 * 5 * 5 = 125 个数字，会出现 3 个 5，所以我们还需要再加上 n / 125 。<br>
综上，规律就是每隔 5 个数，出现一个 5，每隔 25 个数，出现 2 个 5，每隔 125 个数，出现 3 个 5... 以此类推。<br>
最终 5 的个数就是 n / 5 + n / 25 + n / 125 ...<br>
写程序的话，如果直接按照上边的式子计算，分母可能会造成溢出。所以算 n / 25 的时候，我们先把 n 更新，n = n / 5，然后再计算 n / 5 即可。后边的同理。</p>
</blockquote>
<pre><code>public int trailingZeroes(int n) {
    int count = 0;
    while (n &gt; 0) {
        count += n / 5;
        n = n / 5;
    }
    return count;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 167. 两数之和 II - 输入有序数组[简单]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-167-liang-shu-zhi-he-ii-shu-ru-you-xu-shu-zu-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-167-liang-shu-zhi-he-ii-shu-ru-you-xu-shu-zu-jian-dan">
        </link>
        <updated>2020-01-30T07:14:53.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。<br>
函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。<br>
说明:<br>
返回的下标值（index1 和 index2）不是从零开始的。<br>
你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。<br>
示例:<br>
输入: numbers = [2, 7, 11, 15], target = 9<br>
输出: [1,2]<br>
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题其实没什么特别的，无非就是双指针移动<br>
但是重点在于从这题开始，要使用所学到的注意事项了，特别是muduo和effective c++中的建议和要求，比如变量命名，又比如使用const变量</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) {
        vector&lt;int&gt;::const_iterator min=numbers.cbegin();//注意指向常量的迭代器const_iterator和常量迭代器的区别const iterator ，同时还要注意cbegin cend 和 begin end 的区别
        vector&lt;int&gt;::const_iterator max=numbers.cend()-1;//又忘了end指向尾后位置了，还是得每天练练手
        while(min&lt;max){  //注意只有随机迭代器可以用关系运算符
           //if(*max+*min==target) //这里其实可以做减法，防止溢出
             if(target-*max==*min)   
                return vector&lt;int&gt;({min-numbers.cbegin()+1,max-numbers.cbegin()+1});
            //else if(*max+*min&lt;target)
            else if(target-*max&gt;*min)
                ++min;
            else
                --max;
        }
        return vector&lt;int&gt;();
    }
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>方法 1：双指针<br>
算法<br>
我们可以使用 两数之和 的解法在 O(n^2)时间 O(1) 空间暴力解决，也可以用哈希表在 O(n) 时间和O(n) 空间内解决。然而，这两种方法都没有用到输入数组已经排序的性质，我们可以做得更好。<br>
我们使用两个指针，初始分别位于第一个元素和最后一个元素位置，比较这两个元素之和与目标值的大小。如果和等于目标值，我们发现了这个唯一解。如果比目标值小，我们将较小元素指针增加一。如果比目标值大，我们将较大指针减小一。移动指针后重复上述比较知道找到答案。<br>
假设 [... , a, b, c, ... , d, e, f, …]是已经升序排列的输入数组，并且元素 b,e 是唯一解。因为我们从左到右移动较小指针，从右到左移动较大指针，总有某个时刻存在一个指针移动到b 或 e 的位置。不妨假设小指针先移动到了元素 b ，这是两个元素的和一定比目标值大，根据我们的算法，我们会向左移动较大指针直至获得结果。<br>
C++</p>
</blockquote>
<pre><code>class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) {
        int low = 0, high = numbers.size() - 1;
        while (low &lt; high) {
            int sum = numbers[low] + numbers[high];
            if (sum == target)
                return {low + 1, high + 1};
            else if (sum &lt; target)
                ++low;
            else
                --high;
        }
        return {-1, -1};
    }
};
</code></pre>
<blockquote>
<p>是否需要考虑 numbers[low] + numbers[high]numbers[low]+numbers[high] 溢出呢？答案是不需要。因为即使两个元素之和溢出了，因为只存在唯一解，所以一定会先访问到答案。<br>
复杂度分析<br>
时间复杂度：O(n)。每个元素最多被访问一次，共有 n 个元素。<br>
空间复杂度：O(1)。只是用了两个指针。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 1.两数之和[简单][未做出]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-1liang-shu-zhi-he-jian-dan-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-1liang-shu-zhi-he-jian-dan-wei-zuo-chu">
        </link>
        <updated>2020-01-29T07:47:55.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<br>
你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。<br>
示例:<br>
给定 nums = [2, 7, 11, 15], target = 9<br>
因为 nums[0] + nums[1] = 2 + 7 = 9<br>
所以返回 [0, 1]<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/two-sum<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>手贱去翻评论看到用map，然后想到一个不错的方法，就是用哈希表存储一对值，key是target-nums[i]或者nums[i]，value则是i，那么如果在后面遇到适合的key时就可以直接返回了<br>
hhh还真就是最佳题解</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        unordered_map&lt;int,int&gt; res_val;
        int len=nums.size();
        for(int i=0;i&lt;len;++i){
            int res= target-nums[i];
            if(res_val.count(res))
                return vector&lt;int&gt;({res_val[res],i});
            res_val.insert({nums[i],i});   
        }
        return vector&lt;int&gt;();
    }
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>方法一：暴力法<br>
暴力法很简单，遍历每个元素 x，并查找是否存在一个值与target−x 相等的目标元素。</p>
</blockquote>
<pre><code>Java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        for (int i = 0; i &lt; nums.length; i++) {
            for (int j = i + 1; j &lt; nums.length; j++) {
                if (nums[j] == target - nums[i]) {
                    return new int[] { i, j };
                }
            }
        }
        throw new IllegalArgumentException(&quot;No two sum solution&quot;);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(n^2)<br>
对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费O(n) 的时间。因此时间复杂度为 O(n^2)。<br>
空间复杂度：O(1)。</p>
</blockquote>
<blockquote>
<p>方法二：两遍哈希表<br>
为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。<br>
通过以空间换取速度的方式，我们可以将查找时间从 O(n) 降低到 O(1)。哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)。<br>
一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i] 本身！</p>
</blockquote>
<pre><code>Java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; nums.length; i++) {
            map.put(nums[i], i);
        }
        for (int i = 0; i &lt; nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) {
                return new int[] { i, map.get(complement) };
            }
        }
        throw new IllegalArgumentException(&quot;No two sum solution&quot;);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(n)，<br>
我们把包含有 n 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1) ，所以时间复杂度为 O(n)。<br>
空间复杂度：O(n)，<br>
所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 nn 个元素。</p>
</blockquote>
<blockquote>
<p>方法三：一遍哈希表<br>
事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。</p>
</blockquote>
<pre><code>Java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement)) {
                return new int[] { map.get(complement), i };
            }
            map.put(nums[i], i);
        }
        throw new IllegalArgumentException(&quot;No two sum solution&quot;);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(n)，<br>
我们只遍历了包含有 nn 个元素的列表一次。在表中进行的每次查找只花费 O(1) 的时间。<br>
空间复杂度：O(n)，<br>
所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 n 个元素。</p>
</blockquote>
]]></content>
    </entry>
</feed>