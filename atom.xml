<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-02-21T02:33:38.563Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>In the darkest night,Rising like a spire.</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[链表 题24:反转链表]]></title>
        <id>https://lixin-scut.github.io//post/lian-biao-ti-24fan-zhuan-lian-biao</id>
        <link href="https://lixin-scut.github.io//post/lian-biao-ti-24fan-zhuan-lian-biao">
        </link>
        <updated>2020-02-21T02:24:11.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
输入一个链表，反转链表后，输出新链表的表头。链表节点定义如下：<br>
/*<br>
struct ListNode {<br>
int val;<br>
struct ListNode <em>next;<br>
ListNode(int x) :<br>
val(x), next(NULL) {<br>
}<br>
};</em>/</p>
</blockquote>
<p>同样地需要三个指针，注意一定要记得<code>ListNode *pre,*cur,*cur_next;</code>是每个变量都需要*号，否则的话就等于ListNode了<br>
然后其实这一题不需要虚拟头节点，完全可以pre声明为NULL，配合while(cur!=NULL)甚至可以省略掉判断头节点是否为NULL</p>
<pre><code>class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
        ListNode *pre,*cur,*cur_next;
        pre=NULL;
        cur=pHead;
        while(cur!=NULL){
            cur_next=cur-&gt;next;
            cur-&gt;next=pre;
            pre=cur;
            cur=cur_next;
        }
        return pre;
    }
};
</code></pre>
<p>书本题解：<br>
由于节点i的m_pNext指向了它的前一个节点，导致我们无法在链表中遍历到节点j。为了避免链表在节点i处断开，我们需要在调整节点i的m_pNext之前，把节点j保存下来。<br>
也就是说，我们在调整节点i的m_pNext指针时，除了需要知道节点i 本身，还需要知道i的前一个节点h,因为我们需要把节点i的m_pNext指向节点h。同时，我们还需要事先保存i的一个节点j，以防止链表断开。 因此，相应地我们需要定义3个指针，分别指向当前遍历到的节点、它的 前一个节点及后一个节点。<br>
最后我们试着找到反转后链表的头节点。不难分析出反转后链表的头节点是原始链表的尾节点。什么节点是尾节点？自然是m_pNext为nullptr 的节点。<br>
需要避免的问题：<br>
•	输入的链表头指针为nullptr或者整个链表只有一个节点时，程序立即崩溃。<br>
•	反转后的链表出现断裂。<br>
•	返回的反转之后的头节点不是原始链表的尾节点。<br>
至少应该想到以下几类测试用例对代码进行功能测试：<br>
•	输入的链表头指针是nullptr。<br>
•	输入的链表只有一个节点。<br>
•	输入的链表有多个节点。</p>
<pre><code>ListNode* ReverseList(ListNode* pHead)
{
    ListNode* pReversedHead = nullptr;
    ListNode* pNode = pHead;
    ListNode* pPrev = nullptr;
    while(pNode != nullptr)
    {
        ListNode* pNext = pNode-&gt;m_pNext;

        if(pNext == nullptr)
            pReversedHead = pNode;

        pNode-&gt;m_pNext = pPrev;

        pPrev = pNode;
        pNode = pNext;
    }

    return pReversedHead;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Buffer类]]></title>
        <id>https://lixin-scut.github.io//post/buffer-lei</id>
        <link href="https://lixin-scut.github.io//post/buffer-lei">
        </link>
        <updated>2020-02-20T11:34:36.000Z</updated>
        <content type="html"><![CDATA[<p>Buffer是非阻塞TCP网络编程必不可少的东西，需要用Buffer来处理数据输入和数据输出。<br>
Buffer和Timestamp是唯独两个具有值语义的对象。<br>
其中Timestamp是poll(2)返回的时刻，即消息到达的时刻，这个时刻早于读到 数据的时刻(read(2)调用或返回)。因此如果要比较准确地测量程序处理消息的内 部延迟，应该以此时刻为起点，否则测出来的结果偏小，特别是处理并发连接时效果 更明显。</p>
<p>Buffer类的设计与使用<br>
非阻塞IO总是与IO复用函数（select/poll/epoll）一起使用，所以应用层的buffer是必需的。non-blocking IO的核心思想是避免阻塞在read或write或其他IO系统调 用上，这样可以最大限度地复用thread-of-control,让一个线程能服务于多个socket 连接。IO线程只能阻塞在IO multiplexing函数上，select/poll/epoll_wait。同时应用层的缓冲是必需的，每个TCP socket都要有input buffer和 output buffer</p>
<p>对于应用程序而言，它只管生成数据，它不应该关心到底数据是一次性发送还是 分成几次发送，这些应该由网络库来操心，程序只要调用TcpConnection::send()就 行了，网络库会负责到底。网络库应该接管这剩余数据，把它保存在该TCP connection的output buffer里，然后注册ROLLOUT事件，一旦socket变得可写就立 刻发送数据。如果还有剩余，网络库应该继续关注ROLLOUT事件；如果写完了数据,网络库应该停止关注ROLLOUT, 以免造成 busy loopo</p>
<p>TcpConnection必须要有output buffer，并且当输出缓冲中还有待发送的数据时，程序希望关闭连接的话，此时网络库必须等待数据发送完毕，而不能立即关闭连接</p>
<p>因为使用的是Epoll的LT电平触发，所以网络库在处理socket可读事件的时候必须一次性把socket中的数据读完（从内核buffer到应用层buffer），否则会一直触发POLLIN事件</p>
<p>此时就会出现“粘包”现象，亦即buffer中有部分数据不完整的情况，需要使用codec分包，等待构成一条完整的信息再通知程序的业务逻辑</p>
<p>为什么不用边缘触发edge trigger 一是与传统的poll兼容，二是电平触发编程更容易，三是读写的时候不必等候出现EAGAIN，可以节省系统调用，降低延迟<br>
事件触发采用level trigger,因此并不会反复调用read()直到其返回EAGAIN,从而可以降低消息处理的延迟。</p>
<p>Buffer类的实现细节<br>
Buffer不是线程安全的<br>
•对于input buffer, onMessage()回调始终发生在该TcpConnection所属的那个 IO线程，应用程序应该在onMessage()完成对input buffer的操作，并且不要 把input buffer暴露给其他线程。这样所有对input buffer的操作都在同一个线 程，Buffer class不必是线程安全的。<br>
•对于output buffer,应用程序不会直接操作它，而是调用TcpConnection::send ()来发送数据，后者是线程安全的。<br>
如果TcpConnection:: send()调用发生在该TcpConnection所属的那个IO线程, 那么它会转而调用TcpConnection:: sendlnLoop , sendlnLoop()会在当前线程(也 就是IO线程)操作output buffer；如果TcpConnection::send()调用发生在别的 线程，它不会在当前线程调用sendlnLoopO, rfl］是通过EventLoop: : runlnLoop ()把 sendlnLoop函数调用转移到IO线程</p>
<p>首先需要给 TcpConnection 添加 inputBuffer_ 成员变量。<br>
然后TcpConnection:: handleRead()成员函数会使用Buffer来读取数据。</p>
<p>一般不需要直接操作buffer<br>
buffer内部是vector&lt; char &gt; ，是一块连续的内存,同时buffer准备了一块额外的65536栈上内存extrabuf，利用readv来读取内存，既避免了需要一个很大的出事buffer，也避免了反复调用read造成的系统开销</p>
<p>主buffer分为三个部分：prependable、readable、writable<br>
<img src="https://lixin-scut.github.io//post-images/1582201221076.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582201289610.png" alt=""><br>
buffer使用下标而不是迭代器，因为vector是自增长的，重新分配内存之后会使得原来的指针失效</p>
<p>Buffer 里有两个常数 kCheapPrepend 和 klnitialSize,定义了 prependable的初始大小和writable的初始大小，readable的初始大小为0。</p>
<p>每当全部数据读完了，readindex == writeindex，readindex和writeindex返回原位以备新一轮使用</p>
<p>vector的capacity() 以指数方式自动动态增长，让push_back()的平均复杂度是常数。</p>
<p>内部腾挪<br>
有时候，经过若干次读写，readindex移到了比较靠后的位置，留下了巨大的 prependable空间，Buffer在这种情况下不会重新分配内存，而是先把已有的数据移到前面去，腾出 writable空间</p>
<p>prepend前方添加：有时候readIndex比较靠后，buffer前半部分有一定的空间，可以先序列化消息，然后再在序列化数据的前面添加消息的长度</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[移动语义和完美转发]]></title>
        <id>https://lixin-scut.github.io//post/yi-dong-yu-yi-he-wan-mei-zhuan-fa</id>
        <link href="https://lixin-scut.github.io//post/yi-dong-yu-yi-he-wan-mei-zhuan-fa">
        </link>
        <updated>2020-02-20T10:33:14.000Z</updated>
        <content type="html"><![CDATA[<p>loading...</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 题23:链表中环的入口节点]]></title>
        <id>https://lixin-scut.github.io//post/lian-biao-ti-23lian-biao-zhong-huan-de-ru-kou-jie-dian</id>
        <link href="https://lixin-scut.github.io//post/lian-biao-ti-23lian-biao-zhong-huan-de-ru-kou-jie-dian">
        </link>
        <updated>2020-02-20T01:29:07.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述<br>
给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p>
<p>这道题一个就是hashset，一个就是双指针法<br>
我并没有参考书本的双指针法，而是使用了leetcode的方法，但是需要注意赋新值给快指针时需要slow也前进一步，因为相当于fast先走一步，所以slow也必须next一次（需要复习一下leetcode上的数学证明）</p>
<pre><code>class Solution {
public:
    //双指针
    ListNode* EntryNodeOfLoop(ListNode* pHead){
        if(pHead==NULL)
            return NULL;
        ListNode *fast,*slow;
        fast=pHead-&gt;next;
        slow=pHead;
        while(fast!=slow){
            if(fast==NULL||fast-&gt;next==NULL)
                return NULL;
            fast=fast-&gt;next-&gt;next;
            slow=slow-&gt;next;
        }
        slow=slow-&gt;next;
        fast=pHead; //注意因为这一步相当于fast先走一步，所以slow也必须next一次
        while(slow!=fast){
            slow=slow-&gt;next;
            fast=fast-&gt;next;
        }
        return slow;
    }
    /*
    //使用hashset
    ListNode* EntryNodeOfLoop(ListNode* pHead)
    {
        unordered_set&lt;ListNode*&gt; Node_set;
        if(pHead==NULL)
              return NULL;
        while(pHead!=NULL){
            if(Node_set.count(pHead))
                return pHead;
            Node_set.insert(pHead);
            pHead=pHead-&gt;next;
        }
        return NULL;
    }
    */
};
</code></pre>
<p>书本题解：<br>
解决这个问题的第一步是如何确定一个链表中包含环。受到面试题22 的启发，我们可以用两个指针来解决这个问题。和前面的问题一样，定义 两个指针，同时从链表的头节点出发，一个指针一次走一步，另一个指针 一次走两步。如果走得快的指针追上了走得慢的指针，那么链表就包含环； 如果走得快的指针走到了链表的末尾(m_pNext指向NULL)都没有追上第 一个指针，那么链表就不包含环。<br>
第二步是如何找到环的入口。我们还是可以用两个指针来解决这个问 题。先定义两个指针P|和P2指向链表的头节点。如果链表中的环有n个节 点，则指针Pi先在链表上向前移动n步，然后两个指针以相同的速度向前 移动。当第二个指针指向环的入口节点时，第一个指针已经围绕着环走了 一圈，又回到了入口节点。<br>
剩下的问题是如何得到环中节点的数目。我们在前面提到判断一个链 表里是否有环时用到了一快一慢两个指针。如果两个指针相遇，则表明链 表中存在环。两个指针相遇的节点一定是在环中。可以从这个节点出发， 一边继续向前移动一边计数，当再次回到这个节点时，就可以得到环中节 点数了。</p>
<pre><code>ListNode* MeetingNode(ListNode* pHead)
{
    if(pHead == nullptr)
        return nullptr;

    ListNode* pSlow = pHead-&gt;m_pNext;
    if(pSlow == nullptr)
        return nullptr;

    ListNode* pFast = pSlow-&gt;m_pNext;
    while(pFast != nullptr &amp;&amp; pSlow != nullptr)
    {
        if(pFast == pSlow)
            return pFast;

        pSlow = pSlow-&gt;m_pNext;

        pFast = pFast-&gt;m_pNext;
        if(pFast != nullptr)
            pFast = pFast-&gt;m_pNext;
    }
    return nullptr;
}

ListNode* EntryNodeOfLoop(ListNode* pHead)
{
    ListNode* meetingNode = MeetingNode(pHead);
    if(meetingNode == nullptr)
        return nullptr;

    // 得到环中结点的数目
    int nodesInLoop = 1;
    ListNode* pNode1 = meetingNode;
    while(pNode1-&gt;m_pNext != meetingNode)
    {
        pNode1 = pNode1-&gt;m_pNext;
        ++nodesInLoop;
    }

    // 先移动pNode1，次数为环中结点的数目
    pNode1 = pHead;
    for(int i = 0; i &lt; nodesInLoop; ++i)
        pNode1 = pNode1-&gt;m_pNext;

    // 再移动pNode1和pNode2
    ListNode* pNode2 = pHead;
    while(pNode1 != pNode2)
    {
        pNode1 = pNode1-&gt;m_pNext;
        pNode2 = pNode2-&gt;m_pNext;
    }

    return pNode1;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TcpServer]]></title>
        <id>https://lixin-scut.github.io//post/tcpserver-jie-shou-xin-lian-jie</id>
        <link href="https://lixin-scut.github.io//post/tcpserver-jie-shou-xin-lian-jie">
        </link>
        <updated>2020-02-19T13:43:22.000Z</updated>
        <content type="html"><![CDATA[<p>TcpServer新建连接的相关函数调用顺序见图8(有的函数名是简写，省略了 poll(2)调用)。其中 Channel::handleEvent()的触发条件是 listening socket 可读, 表明有新连接到达。TcpServer会为新连接创建对应的TcpConnection对象。<br>
<img src="https://lixin-scut.github.io//post-images/1582119932027.png" alt=""></p>
<h3 id="tcpserver-class">TcpServer class</h3>
<p>TcpServer class 的功能是管理 accept(2)获得的 TcpConnection。TcpServer 是供用户直接使用的，生命期由用户控制。TcpServer的接口如下，用户只需要设置好 callback,再调用 start()即可。</p>
<p>TcpServer内部使用Acceptor来获得新连接的fd。它保存用户提供的Connection- Callback 和Messagecallback,在新建TcpConnection的时候会原样传给后者。TcpServer 持有目前存活的 TcpConnection 的 shared_ptr (定义为 TcpConnectionPtr),因为 TcpConnection对象的生命期是模糊的，用户也可以持有TcpConnectionPtr。</p>
<p>每个TcpConnection对象有一个名字，这个名字是由其所属的TcpServer在创建 TcpConnection 对象时生成，名字是 ConnectionMap 的 key.<br>
在新连接到达时，Acceptor会回调newConnection(),后者会创建TcpConnection对象conn,把它加入ConnectionMap,设置好callback,再调用 conn-&gt;connectEstablished(), 其中会回调用户提供的ConnectionCallback代码<br>
<strong>练习：给TcpServer的构造函数增加string参数，用于初始化name_成员变量。</strong><br>
注意muduo尽量让依赖是单向的，TcpServer会用到Acceptor,但Acceptor并不知道 TcpServer 的存在。TcpServer 会创建 TcpConnection,但 TcpConnection 并 不知道TcpServer的存在。<br>
<strong>优化点：£64可以考虑改用make_shared()以节约一次new。</strong></p>
<p>TcpServer向TcpConnection注册CloseCallback,用于接收连接断开的消息。<br>
通常TcpServer的生命期长于它建立的TcpConnection,因此不用担心TcpServer 对象失效。<br>
TcpServer::removeConnection()把 conn 从 ConnectionMap 中移除。这时 TcpConnection 已经快要被销毁：如果用户不持有TcpConnectionPtr的话，conn的引用计数已降到1。注意这里一定要用EventLoop::queuelnLoop <strong>（unknown）</strong>,否则就会出现对象生命期管理问题，即Channel::handleEvent()<strong>（unknown）</strong> 有可能引发TcpConnection析构，继而把当前Channel对象也析构了，导致程序崩溃。<br>
另外注意这里用boost:: bind让TcpConnection的生命期 长到调用connectDestroyed()的时刻。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[模板的实现]]></title>
        <id>https://lixin-scut.github.io//post/mo-ban-de-shi-xian</id>
        <link href="https://lixin-scut.github.io//post/mo-ban-de-shi-xian">
        </link>
        <updated>2020-02-19T08:43:21.000Z</updated>
        <content type="html"><![CDATA[<p>模板这个东西，是C++里可以独当一面的领域，STL的基础和核心就是它了，但是侯捷大神的《STL源码剖析》并没有把模板的原理作为核型概念，而更多地讲它的应用，所以还是得到《深度探索C++对象模型》中去了解一下</p>
<p>个人总结：<br>
对于声明：</p>
<ol>
<li>对于模板的声明，程序什么反应都不做，哪怕是类模板中的static类型这种与类对象无关的对象都必须等到模板的实例化，所有的类型和成员都必须通过模板的某个实体来存取和操作</li>
<li>从1出发，我们可以发现模板不能直接通过类型提取static对象，同时通过前向声明来声明定义的指针都不会触发实例化，但例外是引用会触发实例化，因为实例的初始化必须指向一个对象，而指针完全可以指向nullptr</li>
<li>从2出发，我们惊讶地发现编译器对于模板的巨大的宽容，比如2中定义的引用实例化时才会对类型进行转化，如果没有转换的可能，这个定义就是错误的，才会在编译时被挑出来。</li>
<li>但是，哪怕模板被引用或者定义之类的实例化了，类中的成员函数还是会顽强地保持模板状态，直至被调用的时候才会实例化</li>
<li>从4出发就会引出一个大问题：并不是一个template具现出来的所有类型就一定能够完整支持一组member functions所需要的所有运算符。比如以某些类类型<br>
作为T，但是这个类类型根本没有定义==符号的话，如果类模板的成员函数用到了<br>
相等判断直接gg。</li>
<li>类模板的成员函数的具现时机：<br>
■在编译时候。那么函数将“具现”于它存在的那个文件中，<br>
■在链接时候.那么编译器会被一些辅助工具重新激活。template函数实体可能被放在这个文件中、别的文件中，或一个分离的储存位置上。</li>
</ol>
<p>关于编译：</p>
<ol>
<li>目前的编译器，面对一个template声明，在它被一组实际参数具现之前，只能施行以有限的错误检查。template中那些与语法无关的十分明显的错误，编译器却会让它通过</li>
<li>所有与类型有关的检验，如果牵涉到 template参数、都必须延迟到真正的实例化操作才发生</li>
<li>所有语汇(lexing)错误和解析(parsing)错误都会被通过，但同时都会在处理template声明的过程中被标示出来</li>
<li>每当遇到模板的具例化，这组标记就被推往解析器,然后调用类型检验等等</li>
</ol>
<p>模板中的名称决议方式</p>
<ol>
<li>首先必须能够区分以下两种意义:<br>
一种是C++ Standard所谓的uscope of the template definition ,也就是“定义出 template” 的程序。<br>
另一种是 C++ Standard 所谓的scope of the template instantiation，也就是“具现出 template” 的程序.</li>
<li>对于一个nonmember name的决议结果是根据这个name的使用是否与“用以具现出该template的参数类型”有关而决定的.<br>
<strong>如果其使用互不相关，那么就以scope of the template declaration来决定name</strong><br>
<strong>如果其使用互有关联，那么就以scope of the template instantiation来决定name</strong></li>
<li>函数的决议结果只和函数的原型(signature)有关</li>
<li><strong>这意味着一个编译器必须保持两个scope contexts：</strong><br>
1)scope of the template declaration,用以专注于一般的 template class.<br>
2)scope of the template instantiation，用以专注于特定的实体。<br>
<strong>编译器的决议(resolution)算法必须决定哪一个才是适当的scope,然后在 其中搜寻适当的name.</strong></li>
</ol>
<p>模板的具现行为</p>
<ol>
<li>不同编译器的模板实例化策略可以分为编译时策略和链接时期策略</li>
<li>不论编译时期或链接时期的实例化策略，其弱点就是当template实体被产生出来时，有时候会大量增加编译时间</li>
<li>模板实例化的定义位置，一种是放在类似头文件的文件中在引用，例外一种就是在头文件中找到的模板实例化就把实例化相应地放到源文件中</li>
<li>对于类模板成员函数的按需实例化：一种方法是忽略它，全部都给实例化出来。另一种策略就是仿照链接操作，检测看看哪一个函数真正需要，然后再为它们产生实体</li>
<li>阻止同一类型的多次实例化：产生多个实体，然后从链接器中提供支持，只留下其中一个实体，其余都忽略。另一个办法就是由使用者来导引“仿真链接阶段”的具现 策略，决定哪些实体才是需要的的。</li>
<li>最接近我们需求的模板自动实例化方法：<br>
a.	<strong>一个程序的程序代码被编译时，最初并不会产生任何“template实例体”。然而，相关信息已经被产生于object files之中。</strong><br>
b.	<strong>当object files被链接在一块儿时，会有一个prelinker程序被执行起来。它会检查object files,寻找template实体的相互参考以及对应的定义。</strong><br>
c.	<strong>对于每一个“参考到template实体”而“该实体却没有定义”的情况,prelinker将该文件视为与另一个文件（含有实例化）同类。 以这种方法，就可以将必要的程序具现操作指定给特定的文件。</strong> 这些都会注册在prelinker所产生的.ii文件中（放在磁盘目录ii_file）。<br>
d.	prelinker重新执行编译器，重新编译每一个&quot;.ii文件曾被改变过”的文 件。这个过程不断重复，直到所有必要的具现操作都已完成。<br>
e.	所有的object files被链接成一个可执行文件。</li>
<li>上述机制的缺陷在于虚函数，<strong>如果一个virtual function被具现(instantiated)出来，其具现点紧跟在其class 的具现点之后</strong>，<strong>导致具现(instantiated )出Point class的一个float实体及其 virtual_func().由于每一个virtual function的地址被放置于table之中</strong>，<strong>如果 virtual table 被产生出来,每一个 virtual function 也都必须被具现(instantiated)</strong> ,<strong>然而，如果编译器遵循cfront的virtual table实现体制，那么在Point的 float实体有一个virtual destructor定义被具现出来”之前，这个table不会被产生</strong></li>
<li>C++ Standard也已经扩充了对template的支持，允许程序员明确地要求在一个文件中将整个class template具现出来，以手动方式先在个别的object module中完成预先具现操作 （pre-instantiation）,虽然沉闷，却是唯一保证效率的方法</li>
</ol>
<p>《Effective C++》<br>
template的三个主要方向：<br>
1.template的声明<br>
2.如何具现（instantiates）出class object以及inline nonmember，以及 member template functions，这些是每一个编译单位都会拥有一份实体<br>
3.如何具现（instantiates）出nonmenber以及member template functions，以及static template class members，这些都是每一个可执行文件只需要一个实体的东西<br>
具现（instantiates）：表示行程将真正的类型和表达式绑定到template相关形式参数（formal parameters）上头</p>
<p><img src="https://lixin-scut.github.io//post-images/1582184776039.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582184916822.png" alt=""><br>
当编译器看到template class声明时，它会做出什么反应？<strong>在实际程序中，什么反应也没有</strong>，也就是说，与普通情况下不同，模板的static data members并不可用。nested enum 或其 enumerators 也一样。他们<strong>都需要通过模板的某个实体来存取和操作。</strong></p>
<p>所以不能这样写：</p>
<pre><code>// error :
Point::Status s;
</code></pre>
<p>同样的道理，freeList和chunkSize对程序而言也还不可用。我们不能够写:</p>
<pre><code>// error :
Point::freeList;
</code></pre>
<p>我们必须明确地指定类型，才能使用freeList <strong>（注意此处已经实例化了一个匹配float类型的类）</strong></p>
<pre><code>// ok :
Point&lt; float &gt;::freeList;
</code></pre>
<p>像上面这样使用static member,会使其一份实体与Point class的float instantiation在程序中产生关联。如果我们写:</p>
<pre><code>// ok :另一个实体(instance) 
Point&lt; double &gt;::freeList;
</code></pre>
<p>就会出现第二个JreeList实体，与Point class的double instantiation产生关联<br>
如果我们定义一个指针，指向特定的实体，像这样:<br>
<code>Point&lt; float &gt; *ptr = 0;</code><br>
这一次，程序中什么也没有发生.为什么呢？<strong>因为一个指向class object的指针, 本身并不是一个class object,编译器不需要知道与该class有关的任何members的数据或object布局数据</strong>，所以将Point的一个float实体具现也就没有必要 <strong>（重点：前向声明并不需要知晓类的实现）</strong></p>
<p>如果不是pointer而是reference,又如何？假设：<br>
const Point&lt; float &gt; &amp;ref = 0;<br>
是的，<strong>reference真的会具现出一个&quot;Point的float实体”来</strong>,这个定义的真正语意 会被扩展为：<br>
//内部扩展<br>
Point&lt; float &gt; temporary( float (0));<br>
const Point&lt; float &gt; &amp;ref = temporary;<br>
<strong>因为reference并不是无物(no object)的代名词。0被视为整数</strong>,必须被转换为以下类型的一个对象:Point&lt; float &gt;<br>
<strong>如果没有转换的可能，这个定义就是错误的，会在编译时被挑出来</strong>,<br>
所以，一个<strong>class object的定义</strong>，不论是由编译器暗中地做(像稍早程序代码中出现过的temporary),或是由程序员像下面这样明确地做：<br>
const Point&lt; float &gt; origin;<br>
都会<strong>导致template class的“具现”</strong>，也就是说，float instantiation的真正对象布局会被产生出来。回顾先前的template声明，我们看到Point有三个nonstatic members,每一个的类型都是Type^ Type现在被绑定为float,所以origin的配 置空间必须足够容纳三个float成员，<br>
<strong>然而，member functions (至少对于那些未被使用过的)不应该被&quot;实体&quot;化,<br>
只有在member functions被使用的时候，C++ Standard才要求它们被“具现”出来。</strong><br>
当前的编译器并不精确遵循这项要求.之所以由使用者来主导“具现'<br>
(instantiantion)规则，有两个主要原因:<br>
1.空间和时间效率的考虑°如果class中有100个member functions,但你的程序只针对某个类型使用其中两个，针对另一个类型使用其中五个，那么将其它193个函数都“具现”将会花费大量的时间和空间:<br>
2.尚未实现的机能。<strong>并不是一个template具现出来的所有类型就一定能够完整支持一组member functions所需要的所有运算符。</strong> 如果只“具现&quot; 那些真正用到的member functions, template就能够支持那些原本可能会 造成编译时期错误的类型(types)</p>
<p><strong>函数在什么时候“具现”出来呢？当前流行两种策略：</strong><br>
■在编译时候。那么函数将“具现”于origin和p存在的那个文件中，<br>
■在链接时候.那么编译器会被一些辅助工具重新激活。template函数实体可能被放在这个文件中、别的文件中，或一个分离的储存位置上。</p>
<p>Template 的错误报告(Error Reporting within a Template)<br>
<img src="https://lixin-scut.github.io//post-images/1582107028746.png" alt=""></p>
<ol>
<li>L4：使用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">字</mi><mi mathvariant="normal">符</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">对</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">这</mi><mi mathvariant="normal">项</mi><mi mathvariant="normal">错</mi><mi mathvariant="normal">误</mi><mi mathvariant="normal">有</mi><mi mathvariant="normal">两</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">面</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">第</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">，</mi></mrow><annotation encoding="application/x-tex">字符是不对的，这项错误有两方面.第一，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.10556em;vertical-align:0em;"></span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">符</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">项</span><span class="mord cjk_fallback">错</span><span class="mord cjk_fallback">误</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">两</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">面</span><span class="mord">.</span><span class="mord cjk_fallback">第</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">，</span></span></span></span>并不是一个 可以合法用于标识符的字符；第二，class声明中只允许有public, protected, private 三 个卷标(labels) , $ 的出现使 public$ 不成为 public .第一点是语汇(lexical)上的错误，第二点则是造句/解析(syntactic/parsing)上的错误。</li>
<li>L5： t被初始化为整数常量1024,或许可以，也或许不可以，视T的真实类型而定。一般而言，只有template的各个实体才诊断得出来</li>
<li>L6： _t并不是哪一个member的名称，tt才是。这种错误一般会在“类型检验”这个阶段被找出来.是的，每一个名称必须绑定于一个定义身上，要不就会产生错误.</li>
<li>L8： !=运算符可能已定义好，但也可能还没有，视T的真正类型而定。 和第2点一样，只有template的各个实体才诊断得出来.</li>
<li>L9：我们意外地键入ex两次.这个错误会在编译时期的解析(parsing) 阶段被发现,C++语言中一个合法的句子不允许一个标识符紧跟在另一个标识符之后。</li>
<li>L13：我们忘记以一个分号作为class声明的结束，这项错误也会在编译时期的语句分析(parsing)阶段被发现。<br>
在一个nontempiate class声明中，这六个既露骨又潜沉的错误会被编译器挑 出来.<strong>但templa class却不同，举个例子，所有与类型有关的检验，如果牵涉到 template参数、都必须延迟到真正的具现操作(instantiation)发生，才得为之。</strong></li>
</ol>
<p>那么，什么样的错误会在编译器处理template声明时被标示出来？这里有一<br>
部分和template的处理策略有关。cfront对template的处理是完全解析(parse) 所以在一个parsing策略之下，<strong>所有语汇(lexing)错误和解析(parsing)错误都 会在处理template声明的过程中被标示出来。</strong></p>
<p>语汇分析器(lexical analyzer)会在L4捕捉到一个不合法的字符，解析器 (parser)会这样标示它：<br>
<code>public$:	// caught</code><br>
表示这是一个不合法的卷标(label)，解析器(parser)不会把&quot;对一个未命名的 member做出参考操作”视为错误：<br>
<code>_t ( t ) // not caught</code><br>
但它会抓出L9腿 出现两次”以及L13 “缺少一个分号”这两种错误。</p>
<p>在一个十分普遍的替代策略中(例如［BALL92a］中所记录)，template的声明被收集成为一系列的lexical tokens ,而parsing操作延迟，直到真正有具现操作(instantiation)发生时才开始。<strong>每当看到一个instantiation发生，这组token 就被推往parser,然后调用类型检验等等</strong>。面对先前出现的那个template声明， lexical tokenizing会指出什么错误吗？事实上很少，只有L4所使用的不合法 字符会被指出。其余的template声明都被解析为合法的tokens并被收集起来。</p>
<p><strong>目前的编译器，面对一个template声明，在它被一组实际参数具现之前，只 能施行以有限的错误检查.template中那些与语法无关的错误，程序员可能认为 十分明显，编译器却让它通过了，只有在特定实体被定义之后，才会发出抱怨。</strong> 这是目前实现技术上的一个大问题。<br>
<strong>Nonmember 和 member template functions 在具现行为(instantiation)发生之前也一样没有做到完全的类型检验.这导致某些十分露骨的template错误声明竟然得以通过编译。</strong><br>
例如下面的template声明:</p>
<pre><code>template &lt;class type&gt; 
class Foo
{
public:
		Foo();
		type val ();
		void val( type v );
private:
		type _val;
	};
</code></pre>
<p>不论是efront或Sun编译器或Borland编译器，都不会对以下程序代码产生怨言：</p>
<pre><code>//目前各家编译器都不会显示出以下定义的语句合法而语意错误：
//	(a) bogus_meinber 不是 class 的一个 member function
//	(b) dbx 不是 class 的一个 data member
template &lt;class type&gt;
double Foo&lt; type &gt;::bogus_member() ( return this-&gt;dbx; }
</code></pre>
<p>Template中的名称决议方式 (Name Resolution within a Template)<br>
你必须能够区分以下两种意义:<br>
一种是C++ Standard所谓的uscope of the template definition ,也就是“定义出 template” 的程序。<br>
另一种是 C++ Standard 所谓的scope of the template instantiation，也就是“具现出 template” 的程序.<br>
<img src="https://lixin-scut.github.io//post-images/1582186451379.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582186477895.png" alt=""></p>
<p>Template之中，对于一个nonmember name的决议结果是根据这个name的使用是否与“用以具现出该template的参数类型”有关而决定的.<br>
<strong>如果其使用互不相关，那么就以scope of the template declaration来决定name</strong><br>
<strong>如果其使用互有关联，那么就以scope of the template instantiation来决定name</strong></p>
<p>在第一个例子中，foo()与用以具现ScopeRules的参数类型无关:</p>
<pre><code>// the resolution of foo() is not
// dependent on the template argument 
member = foo( _val );
</code></pre>
<p>这是因为_val的类型是int； _val是一个“类型不会变动”的template class<br>
membero也就是说，被用来具现出这个template的真正类型，对于val的类型<br>
并没有影响,此外，<strong>函数的决议结果只和函数的原型(signature)有关</strong>，和函数的_member的类型并不会影响哪一个foo()实体被选中<br>
foo()的调用与template参数毫无关联！所以调用操作必须根据scope of the template declaration来决议，在此scope中，只有一个foo()候选者(注意，这种行为不能够以一个简单的宏扩展——比如使用一个#define宏——重现之)</p>
<p>让我们另外看看&quot;与类型相关” (type-dependent)的用法:<br>
<code>sr0.type_dependent ();</code><br>
这个函数的内容如下:<br>
<code>return foo( _member )；</code><br>
它究竟会调用哪一个foo呢？<br>
这个例子很清楚地与template参数有关，因为该参数将决定member的真 正类型.所以这一次foo必须在scope of the template instantiation中决议，本例中这个scope有两个foo函数声明。由于member的类型在本例中为int, 所以应该是int版的foo出线，如果ScopeRules是以double类型具现出来, 那么就应该是double版的foo出线，如果ScopeRules是以unsigned int或 long类型具现出来，那么foo调用操作就暧昧不明.最后，如果ScopeRules是以某一个class类型具现出来，而该class没有针对int或double实现出 convertion运算符，那么调用操作会被标示为错误。不管如何改变，都是由 scope of the template instantiation 来决定，而不是由 scope of the template declaration 决定。<br>
<strong>这意味着一个编译器必须保持两个scope contexts：</strong></p>
<ol>
<li>scope of the template declaration,用以专注于一般的 template class.</li>
<li>scope of the template instantiation，用以专注于特定的实体。<br>
<strong>编译器的决议(resolution)算法必须决定哪一个才是适当的scope,然后在 其中搜寻适当的name.</strong></li>
</ol>
<p>Member Function 的具现行为(Member Function Instantiation)<br>
对于template的支持，最困难莫过于template function的具现(instantiation)，目前的编译器提供了两个策略：<br>
一个是编译时期策略，程序代码必须在program text file中备妥可用；<br>
另一个是链接时期策略，有一些meta compilation 工具可以导引编译器的具现行为(instantiation)<br>
下面是编译器设计者必须回答的三个主要问题:</p>
<ol>
<li>编译器如何找出函数的定义？<br>
答案之一是包含template program text file ,就好像它是个header文件一样. Borland编译器就是遵循这个策略,另一种方法是要求一个文件命名规则，例如, 我们可以要求，在Point.h文件中发现的函数声明，其template program text —定 要放置于文件PointC或Point.cpp中，依此类推。efront就是遵循这个策略。 Edison Design Group编译器对此两种策略都支持，</li>
<li>编译器如何能够只具现出程序中用到的member functions?<br>
解决办法之一就是，根本忽略这项要求，把一个已经具现出来的class的所有member functions都产生出来。Borland就是这么做的	虽然它也提供#pragmas让你压制(或具现出)特定实体。另一种策略就是仿真链接操作，检测 看看哪一个函数真正需要，然后只为它(们)产生实体。cfront就是这么做的’ Edison Design Group编译器对此两种策略都支持。</li>
<li>编译器如何阻止member definitions在多个.o文件中都被具现呢？<br>
解决办法之一就是产生多个实体，然后从链接器中提供支持，只留下其中一个实体，其余都忽略。另一个办法就是由使用者来导引“仿真链接阶段”的具现 策略，决定哪些实体(instances)才是所需求的。</li>
</ol>
<p><strong>目前，不论编译时期或链接时期的具现(instantiation)策略，其弱点就是，当template实体被产生出来时，有时候会大量增加编译时间</strong>，很显然，这将是template functions第一次具现时的必要条件。然而当那些函数被非必要地再次具现，或是当“决定那些函数是否需要再具现”所花的代价太大时，编译器的表现令人失望!</p>
<p>C++支持template的原始意图可以想见是一个由使用者导引的自动具现机 制(use-directed automatic instantiation mechanism),既不需要使用者的介入，也 不需要相同文件有多次的具现行为。但是这已被证明是非常难以达成的任务，比 任何人此刻所能想象的还要难(请参考[STROUP94])。ptlink,随着cfront 3.0版 所附的原始具现工具，提供了 一个由使用者执行的自动具现机制(use-driven automatic instantiation mechanism)，但它实在太复杂了，即使是久经世故的人也 没法一下子了解.</p>
<p>Edison Design Group 开发出一套第二代的 directed-instantiation 机制，非常接 近于(我所知的)template facility原始涵义。它的主要过程如下：</p>
<ol>
<li><strong>一个程序的程序代码被编译时，最初并不会产生任何“template具现 体”。然而，相关信息已经被产生于object files之中。</strong></li>
<li><strong>当object files被链接在一块儿时，会有一个prelinker程序被执行起来. 它会检查object files,寻找template实体的相互参考以及对应的定义。</strong></li>
<li><strong>对于每一个“参考到template实体”而“该实体却没有定义”的情况,prelinker将该文件视为与另一个文件（在其中，实体已经具现）同类。 以这种方法，就可以将必要的程序具现操作指定给特定的文件。</strong> 这些都会注册在prelinker所产生的.ii文件中（放在磁盘目录ii_file）。</li>
<li>prelinker重新执行编译器，重新编译每一个&quot;.ii文件曾被改变过”的文 件。这个过程不断重复，直到所有必要的具现操作都已完成。</li>
<li>所有的object files被链接成一个可执行文件。</li>
</ol>
<p>这种directed-instantiation体制的主要成本在于，程序第一次被编译时的.ii 文件设定时间，次要成本则是必须针对每一个“compile afterwards&quot;执行 prelinker,以确保所有被参考到的templates都存在有定义.在最初的设定以及成 功地第一次链接之后，重新编译操作包含以下程序：</p>
<ol>
<li>对于每一个将被重新编译的program text file,编译器检查其对应的,ii 文件。</li>
<li>如果对应的.ii文件列出一组要被具现（instantiated）的templates,那 些templates （而且也只有那些templates）会在此次编译时被具现。</li>
<li>prelinker必须执行起来，确保所有被参考到的templates已经被定义妥当。<br>
以我的观点，出现某种形式的automated template机制，是“对程序员友善 的C++编译系统”的一个必要组件.虽然大家也公认，目前没有任何一个系统 是完美的。作为一个程序开发者，我不会使用（也不会推荐）一个没有这种机制 的编译系统。<br>
不幸的是，没有任何一个机制是没有bugs的。Edison Design Group的编译 器使用了一个由cfront2,0引人的算法。对程序中的每一个class 自动产生virtual table的单一实体（在大部分情况下）.例如下面的class声明：</li>
</ol>
<pre><code>class Primitiveobject : public Geometry 
{
public:
		virtual ～Primitiveobject(); 
		virtual void draw();
...
}
</code></pre>
<p>如果它被含入于15个或45个程序源码中，编译器如何能够确保只有一个virtual table实体被产生出来呢？产生15份或45份实体倒还容易些!</p>
<p>Andy Koenig以下面的方法解决这个问题：每一个virtual function的地址都 被放置于active classes的virtual table中，如果取得函数地址，则表示virtual<br>
function的定义必定出现在程序的某个地点；否则程序就无法链接成功。此外,<br>
该函数只能有一个实体，否则也是链接不成功•那么，就把virtual table放在定<br>
义了该class之第一个non-inline nonpure virtual function的文件中吧。以我们的 例子而言，编译器会将virtual table产生在储存着virtual destructor的文件之中。</p>
<p>不幸的是，在template之中，这种单一定义并不一定为真,在template所支持的“将模块中的每一样东西都编译”的模型下，不只是多个定义可能被产生,而且链接器也放任让多个定义同时出现，它只要选择其中一个而将其余都忽略也 就是了。</p>
<p>好吧，真是有趣，但Edison Design Gro叩的automatic instantiation机制做什 么事呢？考虑下面这个library函数：</p>
<pre><code>void foo ( const Point&lt; float &gt; *ptr )
{
ptr-&gt;virtual func();
}
</code></pre>
<p>virtual function call被转换为类似这样的东西:</p>
<pre><code>// C + +伪码
// ptr-&gt;virtual__func ();
(*ptr-&gt;vtbl_Point&lt; float &gt;[ 2 ] ) ( ptr );
</code></pre>
<p>于是<strong>导致具现(instantiated )出Point class的一个float实体及其 virtual_func().由于每一个virtual function的地址被放置于table之中</strong>，<strong>如果 virtual table 被产生出来,每一个 virtual function 也都必须被具现(instantiated)</strong> , 这就是为什么C++ Standard有下面的文字说明的缘故：</p>
<p><strong>如果一个virtual function被具现(instantiated)出来，其具现点紧跟在其class 的具现点之后。</strong></p>
<p><strong>然而，如果编译器遵循cfront的virtual table实现体制，那么在Point的 float实体有一个virtual destructor定义被具现出来”之前，这个table不会被产生</strong>。除非在这一点上，并没有明确使用virtual destructor以担保其具现行为 (instantiation)<br>
EdisCii Design Group的automatic template机制并不明确它自己的编译器对 于第一个non inline、 nonpure virtual function的隐晦使用，所以并没有把它标示 于.ii文件中。结果，链接器反而回头抱怨_vtbl_point&lt; float &gt;符号没有出现<br>
并拒绝产生一个可执行文件。噢，真是麻烦！ Automatic instantiation在此失效!<br>
程序员必须明确地强迫将destructor具现出来.目前的编译系统是以pragma 指令来支持此需求<br>
<strong>然而C++ Standard也已经扩充了对template的支持，允许程序员明确地要求在一个文件中将整个class template具现出来:</strong><br>
<code>template class Point3d&lt; float &gt;;</code><br>
<strong>或是针对一个 template class 的个别 member function：</strong><br>
<code>template float Point3d&lt;float&gt;::X() const;</code><br>
<strong>或是针对某个个别template function：</strong><br>
<code>template Point3d&lt;float&gt; operator+（ const Point3d&lt;float&gt;&amp;r const Point3d&lt;float&gt;&amp; ）;</code><br>
<strong>在实现层面上，template instantiation似乎拒绝全面自动化。甚至虽然每一件 工作都做对了，产生出来的object files的重新编译成本仍然可能太高——如果程序十分巨大的话！以手动方式先在个别的object module中完成预先具现操作 （pre-instantiation）,虽然沉闷，却是唯一有效率的方法。</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于宏的问题]]></title>
        <id>https://lixin-scut.github.io//post/guan-yu-hong-de-wen-ti</id>
        <link href="https://lixin-scut.github.io//post/guan-yu-hong-de-wen-ti">
        </link>
        <updated>2020-02-19T03:31:50.000Z</updated>
        <content type="html"><![CDATA[<p>关于宏在<a href="https://lixin-scut.github.io/post/czhong-de-guan-jian-zi-inline/">C++中的关键字 inline</a>有提及过<br>
在《C++primer》中宏已经极少提及了，毕竟这东西真的是看起来很好用，但是一旦出现问题真的是后患无穷，现在更建议使用内联函数。<br>
但是在旧教材中还是能够看到非常多地方使用了宏，比如返回打印错误信息，总会用宏来定制消息格式。</p>
<p>宏：字符替换，在预编译阶段进行</p>
<p>内联函数与宏的区别：<br>
1.宏在预编译阶段进行字符替换，没有安全检查，内联函数在编译阶段展开，编译阶段有安全检查，内联函数相对宏更安全<br>
2.宏无法调试，内联函数可以调试<br>
3.内联是一种更安全的宏</p>
<p>但inline仍未出现的时代，还能看到很多地方用了宏，而Linux内核和其它一些著名的C库中有许多使用do{...}while(0)的宏定义。那么为什么要宏定义中使用do{}while(0)呢？</p>
<p>简要贴一下这个解答，挺不错的<br>
Google的Robert Love（先前从事Linux内核开发）给我们解答如下：</p>
<blockquote>
<p>do{...}while(0)在C中是唯一的构造程序，让你定义的宏总是以相同的方式工作，这样不管怎么使用宏（尤其在没有用大括号包围调用宏的语句），宏后面的分号也是相同的效果。</p>
</blockquote>
<p>用一句话概括就是：使用do{...}while(0)构造后的宏定义不会受到大括号、分号等的影响，总是会按你期望的方式调用运行。</p>
<p>特别是在希望宏包含多个语句的情况下<br>
例子：</p>
<pre><code>#define funcDef(x)  func1(x); func2(x)
funcDef(param);
</code></pre>
<p>这将被宏扩展为：<br>
<code>func1(param); func2(param);</code><br>
这的确是我们期望的正确输出。下面看看如果我们这样调用：</p>
<pre><code>if (flag)
    funcDef(param);
</code></pre>
<p>那么扩展后可能就不是你所期望的结果。上面语句将扩展为:</p>
<pre><code>if (flag)
		func1(param);
func2(param); //并没有被包含在if里面
</code></pre>
<p>显而易见，这是错误的，也是大家经常易犯的错误之一。<br>
do能确保大括号里的逻辑能被执行，而while(0)能确保该逻辑只被执行一次，即与没有循环时一样。<br>
那么为什么不直接用打括号呢？为什么非得使用do/while(0)逻辑呢？<br>
这次轮到分号;来捣乱了</p>
<p>那么第二个例子：</p>
<pre><code>#define funcDef(x)  {func1(x); func2(x);}  //注意分号还是在大括号内

if(flag)
		funcDef(x);
else
		otherFunc();
</code></pre>
<p>这将被宏扩展为：</p>
<pre><code>if(flag)
	{
		func1(x); 
		func2(x);
	};    //注意这个分号
else
		otherFunc();
</code></pre>
<p>可以看到else就是硬生生被多余的分号截断了<br>
而如果用do/while(0)，while(0)刚好需要一个分号结尾，就避免了出现这种强行分割的情况</p>
<p>总结：宏在现在基本已经失去了用途，我写这篇博文主要也是为了参考其中的思想：良好的编程习惯和思维，能够完成代码主体功能当然是主要任务，但是保证代码能够具有较好的鲁棒性和可移植性，这是前辈们在开荒拓野路上流传下来的宝贵经验</p>
<p>例子：<br>
定义宏函数 a * b<br>
写一个宏实现 min 函数</p>
<p>这里如果可以用一个变量保存结果，就可以用到do while<br>
不能的话就记得一定要尽可能加上括号,</p>
<pre><code>#define multi(x,y) ( x * y )
#define min(x,y) ( (x &lt; y) ? (x) : (y) )

#define multi(x,y) do{ x *= y; } while(0)
#define min(x,y) do{ x = x &lt; y ? x : y; } while(0)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 题22:链表中倒数第k个节点]]></title>
        <id>https://lixin-scut.github.io//post/lian-biao-ti-22lian-biao-zhong-dao-shu-di-k-ge-jie-dian</id>
        <link href="https://lixin-scut.github.io//post/lian-biao-ti-22lian-biao-zhong-dao-shu-di-k-ge-jie-dian">
        </link>
        <updated>2020-02-19T02:58:16.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
输入一个链表，输出该链表中倒数第k个结点。</p>
</blockquote>
<p>第一想法是遍历第一次找出数组长度（记得判断k是否大于N），然后第二次遍历时返回所需的值<br>
第二想法就是双指针，一个指针先走k步，另一个指针再同步向前走，然后第一个指针走到终点时第二个指针所指的位置就是所求</p>
<pre><code>class Solution {
public:
    //相隔k的快慢指针法
    ListNode* FindKthToTail(ListNode* pListHead, unsigned int k){
        if(k==0||pListHead==NULL)
            return NULL;
        ListNode *fast_k;
        ListNode *slow_k;
        fast_k=pListHead;
        
        while(k){
            if(fast_k!=NULL)
                fast_k=fast_k-&gt;next,--k;
            else
                return NULL;
        }
        slow_k=pListHead;
        while(fast_k!=NULL)
            fast_k=fast_k-&gt;next,slow_k=slow_k-&gt;next;
        return slow_k;
    }
    /*
    //两次遍历求长度法
    ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) {
        int len=0;
        ListNode *cur=pListHead;
        while(cur!=NULL){
            ++len;
            cur=cur-&gt;next;
        }
        if(k&gt;len||k==0||len==0)
            return NULL;
        int tar=len-k;
        cur=pListHead;
        while(tar)
            cur=cur-&gt;next,--tar;
        return cur;
    }
    */
};
</code></pre>
<p>书本解法：<br>
假设整个链表有n个节点，那么倒数第k个节点就是从头节点开始的 第n-k+1个节点。<br>
如果我们能够得到链表中节点的个数n，那么只要从头节点开始往后走n-k+1步就可以了。如何得到节点数n？这个不难，只需要从头开始遍历链表，每经过一个节点，计数器加1就行了。也就是说我们需要遍历链表两次，第一次统计出链表中节点的个数， 第二次就能找到倒数第k个节点。但是当我们把这种思路解释给面试官之后，他会告诉我们他期待的解法只需要遍历链表一次。<br>
为了实现只遍历链表一次就能找到倒数第k个节点，我们可以定义两个指针。第一个指针从链表的头指针开始遍历向前走k-1步，第二个指针 保持不动；从第k步开始，第二个指针也开始从链表的头指针开始遍历。 由于两个指针的距离保持在k-1，当第一个(走在前面的)指针到达链表的尾节点时，第二个(走在后面的)指针正好指向倒数第k个节点。<br>
需要注意的鲁棒性问题：<br>
（1）	输入的pListHead为空指针。由于代码会试图访问空指针指向的内存，从而造成程序崩溃。<br>
（2）	输入的以pListHead为头节点的链表的节点总数少于k。由于在for循环中会在链表上向前走k-1步，仍然会由于空指针而造成程序崩溃。<br>
（3）	输入的参数k为0。由于k是一个无符号整数，那么在for循环中 k-1得到的将不是-1,而是4294967295 （无符号的OxFFFFFFFF）。因此， for循环执行的次数远远超出我们的预计，同样也会造成程序崩溃。</p>
<pre><code>ListNode* FindKthToTail(ListNode* pListHead, unsigned int k)
{
    if(pListHead == nullptr || k == 0)
        return nullptr;

    ListNode *pAhead = pListHead;
    ListNode *pBehind = nullptr;

    for(unsigned int i = 0; i &lt; k - 1; ++ i)
    {
        if(pAhead-&gt;m_pNext != nullptr)
            pAhead = pAhead-&gt;m_pNext;
        else
        {
            return nullptr;
        }
    }

    pBehind = pListHead;
    while(pAhead-&gt;m_pNext != nullptr)
    {
        pAhead = pAhead-&gt;m_pNext;
        pBehind = pBehind-&gt;m_pNext;
    }

    return pBehind;
</code></pre>
<p>扩展：<br>
1.求链表的中间节点。如果链表中的节点总数为奇数，则返回中间节点； 如果节点总数是偶数，则返回中间两个节点的任意一个。为了解决这个问 题，我们也可以定义两个指针，同时从链表的头节点出发，一个指针一次走一步，另一个指针一次走两步。当走得快的指针走到链表的末尾时，走 得慢的指针正好在链表的中间。<br>
2.当我们用一个指针遍历链表不能解决问题的时候，可以尝试用两个指针来遍历链表 可以让其中一个指针遍历的速度快一些（比如一次在链表上走两步），或者让它先在链表上走若干步。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[function与bind]]></title>
        <id>https://lixin-scut.github.io//post/function-yu-bind</id>
        <link href="https://lixin-scut.github.io//post/function-yu-bind">
        </link>
        <updated>2020-02-18T09:15:09.000Z</updated>
        <content type="html"><![CDATA[<p>在muduo网络库项目中大量使用了boost的function与bind这对组合来取代虚函数为代表的多态，在C++11中已经把boost的function和bind（还有lambda）纳入C++库中了，所以可以直接引用头文件<code>#include &lt;functional&gt;</code>来使用</p>
<p>需要查看lambda的话可以跳转<a href="https://lixin-scut.github.io/post/lambda/">lambda</a><br>
首先来看看《C++ primer》中的描述：</p>
<h3 id="bind">bind</h3>
<p>标准库函数，定义在头文件functional中，可将bind函数看作一个通用的函数适配器<br>
它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表<br>
调用bind 的一般形式：<br>
<img src="https://lixin-scut.github.io//post-images/1582018106682.png" alt=""><br>
arg_list中参数可能包含形如_n的名字，这些参数是占位符，表示newCallable的参数，数值n表示生成的可调用对象中参数的位置，_1为newCallable的第一个参数 _2为第二个参数<br>
使用placeholders名字：占位符_n都定义在名为placeholders的命名空间中，而这个命名空间又定义在std命名空间中，但是两个命名空间都需要声明 <code>using std::placeholders::_1</code><br>
using namespace namespace_name;更加方便，所有来自namespace_name的名字都可以在程序中直接使用  using namespace std::placeholders;</p>
<p>例子：<br>
<img src="https://lixin-scut.github.io//post-images/1582018131956.png" alt=""><br>
此bind调用只有一个占位符，表示check6只接受单一参数。占位符出现在arg_list的第一个位置，代表check6的此参数对应check_size的第一个参数，因此调用check6时需要给他传递一个参数，然后check6将此参数传递给check_size<br>
<img src="https://lixin-scut.github.io//post-images/1582018238659.png" alt=""></p>
<p>同时bind可以将调用对象中的参数进行顺序调整 比如 <code>auto g = bind(f,a,b,_2,c,_1)</code>调用时等于<code>g(_1,_2)</code><br>
不能用bind来代替对os的捕获，bind只能拷贝参数<br>
使用标准库函数ref（）来传递引用对象 比如ref（ostream）普通应用和 cref（）const引用<br>
例子： <code>for_each(words.begin(),words.end(),bind(print,ref(os),_1,' '));</code><br>
旧标准中的bind1st和bind2nd已经被弃用(STL源码剖析中的已经不适用了)</p>
<h3 id="function">function</h3>
<p>如果类定义了调用运算符，则<strong>该类的对象称作函数对象（function object）</strong>。因为可以调用这种对象，所以我们说这些对象的&quot;行为像函数一样&quot;。<br>
14.8.1 lambda是<strong>函数对象</strong><br>
当我们编写了一个 lambda 后，编译器将该表达式<strong>翻译成一个未命名类的未命名对象</strong>（参见10.3.3节，第349页）。在<strong>lambda 表达式产生的类</strong>中<strong>含有一个重载的函数调用运算符</strong><br>
默认情况下 lambda <strong>不能改变它捕获的变量</strong>。因此在默认情况下，<strong>由 lambda 产生的类当中的函数调用运算符是一个 const 成员函数</strong>。如果 lambda 被声明为可变的，则调用运算符就不是 const 的了。<br>
如我们所知，当一个 lambda 表达式通过<strong>引用捕获</strong>变量时，将由程序负责确保lambda执行时引用所引的对象确实存在（参见10.3.3节，第350页）。因此，<strong>编译器可以直接使用该引用而无须在 lambda 产生的类中将其存储为数据成员。</strong><br>
相反，通过<strong>值捕获</strong>的变量被拷贝到 lambda 中（参见10.3.3节，第350页）。因此，这种 lambda 产生的类<strong>必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数，令其使用捕获的变量的值来初始化数据成员。</strong><br>
<img src="https://lixin-scut.github.io//post-images/1582024662330.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582024668206.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582024672065.png" alt=""></p>
<p>lambda 表达式产生的类不含<strong>默认构造函数</strong>、赋值运算符及<strong>默认析构函数</strong>；它是否含有默认的拷贝/移动构造函数则通常要视捕获的数据成员类型而定</p>
<p>14.8.2标准库定义的函数对象<br>
标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，<strong>每个类分别定义了一个执行命名操作的调用运算符。</strong><br>
这些类都被定义成模板的形式，我们可为其指定具体的应用类型，这里的类型即调用运算符的形参类型</p>
<p>表14.2所列的类型定文在 functional 头文件中。</p>
<p><strong>表示运算符的函数对象类常用来替换算法中的默认运算符（比如for_each等等的泛型算法）</strong><br>
需要特别注意的是，标准库规定其<strong>函数对象对于指针同样适用</strong>。我们之前曾经介绍过<strong>比较两个无关指针将产生未定义的行为</strong>（参见3.5.3节，第107页），然而我们可能会希望通过比较指针的内存地址来 sort 指针的 vector 。直接这么做将产生未定义的行为，因此我们<strong>可以使用一个标准库函数对象来实现该目的</strong>：<br>
<img src="https://lixin-scut.github.io//post-images/1582024817861.png" alt=""><br>
<strong>关联容器使用 less &lt; key _ type &gt;对元素排序</strong>，因此我们可以定义一个<strong>指针的 set 或者在map 中使用指针作为关键值而无须直接声明 less 。</strong></p>
<p>14.8.3可调用对象与function<br>
C ++语言中有几种可调用的对象：函数、函数指针、 lambda 表达式（参见10.3.2节，第346页)、 bind 创建的对象（参见10.3.4节，第354页）以及重载了函数调用运算符类。<br>
和其他对象一样，<strong>可调用的对象也有类型</strong>。<br>
然而，两个<strong>不同类型</strong>的可调用对象却可能<strong>共享同一种调用形式</strong>（call signature ),调用形式<strong>指明了调用返回的类型以及传递给调用的实参类型</strong>，<strong>一种调用形式对应一个函数类型</strong>，<br>
例如 int（int，int）<br>
对于<strong>几个可调用对象共享同一种调用形式</strong>的情况，有时我们会希望把它们<strong>看成具有相同的类型。</strong><br>
<strong>函数表（functiontable)</strong> <strong>用于存储指向这些可调用对象的&quot;指针&quot;</strong>。当程序需要执行某个特定的操作时，从表中查找该调用的函数。<br>
在 C++语言中，函数表很容易通过<strong>map</strong>来实现<br>
<img src="https://lixin-scut.github.io//post-images/1582024948923.png" alt=""><br>
// 构建从<strong>运算符到函数指针的映射关系</strong>，其中函数接受两个 int 、运回一个 int<br>
<code>map&lt;string, int (*) (int,int)&gt; binops;</code><br>
我们可以按照下面的形式将 add 的指针添加到 binops 中：</p>
<pre><code>// 正确； add 是一个指向正确类型函数的指针
binops.insert({&quot; + &quot;, add}) ;  //  {“+”，add} 是一个 pair  (参见 11.2.3 节， 379 ）
但是我们不能将 mod 或者 divide 存入 binops
binops . insert ({“%”, mod}) ;  //  错误： mod  不是一个函数指针
</code></pre>
<p>问题在于<strong>mod是个 lambda 表达式，而每个 lambda 有它自己的类类型，该类型与存储在binops 中的值的类型不匹配</strong>。<br>
<strong>注意此处就解释了我当初将greater函数代入堆priority_queue希望得到小顶堆时遇到的问题，和泛型函数不同，容器接受的是类类型的可调用对象。</strong></p>
<p>我们可以使用一个名为<strong>function 的新的标准库类型</strong>解决上述问题， function 定义在<strong>functional 头文件</strong>中，表14.3列举出了  function 定义的操作</p>
<p>function是一个<strong>模板</strong>，和我们使用过的其他模板一样，当创建一个具体的function类型时我们必须提供额外的信息。在此例中，所谓额外的信息是指该function类型能够表示的<strong>对象的调用形式</strong>。参考其他模板，我们在一对尖括号内指定类型：<br>
<img src="https://lixin-scut.github.io//post-images/1582025881216.png" alt=""><br>
我们<strong>不能（直接）将重载函数的名字存入</strong>function 类型的对象中：<br>
<img src="https://lixin-scut.github.io//post-images/1582025886464.png" alt=""><br>
解决上述二义性问题的一条途径是<strong>存储函数指针</strong><br>
<img src="https://lixin-scut.github.io//post-images/1582025890302.png" alt=""><br>
同样，我们也能使用 lambda 来消除二义性：<br>
<img src="https://lixin-scut.github.io//post-images/1582025893317.png" alt=""><br>
新版本标准库中的function类与旧版本中的<strong>unary_function和binary_function没有关联，后两个类已经被更通用的bind函数替代了</strong>（参见10.3.4节，第357页）。</p>
<p>自己的代码：</p>
<pre><code>typedef function&lt;bool(int,int)&gt; Func;

bool LessThen(int,int);

void coutLess(Func,int);


int main() {
    vector&lt;int&gt; vi { 1,2,3,4,5,6,7,8,9};
    for(auto i : vi)
        coutLess(bind(&amp;LessThen,_1,_2),i); //记得不要忘了取地址符
}

bool LessThen(int value,int standard)
{
    return value &lt; standard;
}

void coutLess(Func func,int value)
{
    if(func(value,5))
    {
        cout &lt;&lt; value &lt;&lt; endl;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[头文件中的声明与定义]]></title>
        <id>https://lixin-scut.github.io//post/tou-wen-jian-zhong-de-sheng-ming-yu-ding-yi</id>
        <link href="https://lixin-scut.github.io//post/tou-wen-jian-zhong-de-sheng-ming-yu-ding-yi">
        </link>
        <updated>2020-02-18T08:07:18.000Z</updated>
        <content type="html"><![CDATA[<h3 id="头文件与源文件的关系">头文件与源文件的关系：</h3>
<p>建议函数和变量在头文件中声明，在源文件中定义,<br>
含有函数声明的头文件应该被包含到定义函数的源文件中，<br>
通过以上的配合，其实就是将所有用到该函数的cpp文件中的声明移动到头文件中，编译器会自动在包含了头文件的cpp文件中搜索函数定义，从而以后可以很方便地修改函数的声明（比如修改形参数量），不需要一个一个地在使用了该函数的cpp文件中修改。</p>
<h3 id="注意点或例外">注意点或例外：</h3>
<p><strong>头文件中不应：</strong></p>
<ol>
<li>头文件不应包含using声明<br>
否则会影响到所有使用该头文件的程序：头文件如果在其顶层作用域中含有using指示或using声明，则会将名字注入到所有包含了该头文件的文件中。通常情况下，头文件应该只负责定义接口部分的名字，而不定义实现部分的名字。因此，头文件最多只能在它的函数或命名空间内使用using指示或using声明</li>
</ol>
<p><strong>头文件中应该加入：</strong></p>
<ol>
<li>通常应该在函数声明中指定默认实参，并将该声明放在合适的头文件中</li>
<li>与其他函数不同，内联函数和Constexpr函数可以多次定义，但需要保持一致，所以通常定义在头文件中</li>
<li>如果非成员函数是类接口的组成部分，则这些函数的声明应该与类（的声明）在同一个头文件内</li>
<li>友元的声明仅仅指定了访问的权限，并非一个通常意义上的函数声明，所以如果希望类的用户能够调用某个友元的函数，那么就必须在友元声明之外专门对函数进行一次声明，通常会把友元的声明和类本身放置在同一个头文件中（类的外部）</li>
<li>在一个构造函数中，noexcept出现在参数列表和初始化列表开始的冒号之间，同时我们必须在类头文件的声明和定义中（定义在类外时）都指定noexcept</li>
<li>函数模板和类模板成员函数的定义通常放在头文件中：<br>
为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义。因此，与非模板代码不同，模板的头文件通常既包括声明也包括定定义。</li>
<li>模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明应该放在前面，然后是这些模板的特例化版本。</li>
<li>命名空间的定义可以不连续的特性使得我们可以将几个独立的接口和实现文件（头文件+源文件）组成一个命名空间。此时，命名空间的组织方式类似于我们管理自定义类及函数的方式：<br>
• 命名空间的一部分成员的作用是定义类，以及声明作为类接口的函数及对象，则这些成员应该置于头文件中，这些头文件将被包含在使用了这些成员的文件中。<br>
• 命名空间成员的定义部分则置于另外的源文件中。<br>
在程序中某些实体只能定义一次：如非内联函数、静态数据成员、变量等，命名空间中定义的名字也需要满足这一要求，我们可以通过上面的方式组织命名空间并达到目的。这种接口和实现分离的机制确保我们所需的函数和其他名字只定义一次，而只要是用到这些实体的地方都能看到对于实体名字的声明</li>
<li>如果一个头文件定义了未命名的命名空间，则该命名空间中定义的名字将在毎个包含了该头文件的文件中对应不同实体。</li>
</ol>
<p>#头文件中可以写类的实现吗<br>
可以，但是不建议，因为除了内联函数和Constexpr函数等函数，其他大部分类成员函数必须遵守唯一定义的规则，因为编译器不让你重复定义一个函数两次。如果有两个cpp文件都包含一个h文件，而那个h文件里有函数的定义的话，就相当于定义了那个函数两次，编译器就会报错。</p>
<p>#编译库文件的话可以把类的实现写在头文件中吗<br>
不应该，库只对用户开放有限的说明，目的是让用户可以使用库，但却不知道库的具体实现。典型的就是提供给用户头文件和.lib二进制文件。头文件通常包含数据结构声明或定义和函数的原型声明以及常量宏定义，而库文件则是实际的数据结构和函数功能实现。（注：对于动态链接的库，只是把链接放到了运行阶段，原理类似）。这种方式下，用户只知道有限的使用信息，对于库的实现对用户是不可见的。这就起到了隐藏实现的作用，</p>
<p>#头文件中#ifdef，#endif 有什么作用。<br>
预处理变量之头文件保护符：预处理器看到#include标记时就会用指定的头文件的内容代替#include，使用头文件保护符以防止头文件被某个文件重复包含。<br>
#define 将一个名字设定为预处理变量 #ifdef 当且仅当变量已定义时为真 #ifndef当且仅当变量未定义时时为真   遇到#endif指令停止<br>
预处理变量无视作用域的规则<br>
预处理变量 包括头文件保护符必须唯一 使用头文件中类的名字来构建保护符的名字，同时大写预处理变量的名字</p>
<p>#Static 关键字可以在头文件中声明吗<br>
可以，在头文件里面声明一个 static 变量，在两个不同的 cpp 里面#include 这个变量有没有问题<br>
但是因为static变量只能在当前文件中使用，所以在不同的源文件中有不同的实体，彼此是相互独立的<br>
<a href="https://lixin-scut.github.io/post/czhong-de-guan-jian-zi-static/">C++中的关键字 static</a></p>
]]></content>
    </entry>
</feed>