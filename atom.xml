<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-04-05T03:13:49.968Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>千里之行，始于足下。不积跬步，无以至千里。</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[随机概率p转化为等概率]]></title>
        <id>https://lixin-scut.github.io//post/sui-ji-gai-lu-p-zhuan-hua-wei-deng-gai-lu</id>
        <link href="https://lixin-scut.github.io//post/sui-ji-gai-lu-p-zhuan-hua-wei-deng-gai-lu">
        </link>
        <updated>2020-04-05T02:22:55.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>有一个随机数发生器random函数，可以以概率P产生0，概率(1-P)产生1，请问能否利用这个随机数发生器，构造出新的发生器，以1/2的概率产生0和1。</p>
</blockquote>
<p>题解一：<br>
等概率产生0、1，就需要找到两个独立事件，当这两个独立事件发生的概率相同，就得到所求<br>
两次调用该randon函数，如果其概率为P(x)，调用2次<br>
P(1) = p       P(0) = 1-p<br>
P'(1) =p      P'(0) = 1-p<br>
则不同结果的概率如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">情况</th>
<th style="text-align:center">概率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">p*p</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">p*(1-p)</td>
</tr>
<tr>
<td style="text-align:center">01</td>
<td style="text-align:center">(1-p)*p</td>
</tr>
<tr>
<td style="text-align:center">00</td>
<td style="text-align:center">(1-p)*(1-p)</td>
</tr>
</tbody>
</table>
<p>用随机数生成器产生<code>00，01，10，11</code>，各自的概率分别为<code>p*p，p*(1-p)，(1-p)*p，(1-p)*(1-p)</code>可以发现生成01，10的概率相同，因此只保留这两种情况，其他的舍弃，然后将01映射为0，10映射为1，则得到等概率生成器。</p>
<pre><code>int random_equal()  
{  
    int i = random();  
    int j = random();  
    int result;  
  
    while (true)  
    {  
        if (i == 0 &amp;&amp; j == 1)  
        {  
            result = 0;  
            break;  
        }  
        else if (i == 1 &amp;&amp; j == 0)  
        {  
            result = 1;  
            break;  
        }  
        else  
            continue;  
    }  
  
    return result;  
}  
</code></pre>
<p>题解二：<br>
思路是叠加多个原始构造器，通过每次叠加的和与期望值对比，来决定是0和1，具体如下：<br>
迭代N次，则期望<code>E=( (1-p)*1 + p*0) * N</code> 。比较累加N次的和Sum和E，Sum大则返回0，Sum小则返回1。</p>
<p>拓展1：用等概率生成（0,1）的构造器等概率生成（0,1,2,3）。<br>
假设，原始构造器为Rand2()，则Rand2() * 2为（0,2），Rand2()* 2 + Rand2()则可以生成（0,1,2,3）。注意Rand2()* 2 + Rand2()不等于Rand2()* 3，后者等于（0,3），只用了一次构造器。前者由part1:（0,2）和part2:（0,1）构成。最终结果（0,1,2,3）任何一个数字都由part1和part2中唯一的数字相加得到。<br>
用Rand4（等概率生成0,1,2,3）可以进一步生成Rand16。方法为：Rand4()* 4 + Rand4()</p>
<p>拓展2：用等概率生成（0,1）的构造器等概率生成（0,1,2,3，...，N）。<br>
思路同上相似。由（0,1）的构造器可以生成（0，...，2^n ） 的构造器，其中每次构造生成的随机数个数是<code>上一次的平方</code>。只需要构造到保证2^n&gt;N即可。当得到的随机数处于[ N, 2^n ）时，递归生成一次，直到构造数为[0,N)时，退出本次随机数生成。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 子序列最小差]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-zi-xu-lie-zui-xiao-chai</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-zi-xu-lie-zui-xiao-chai">
        </link>
        <updated>2020-04-05T02:14:59.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>将一个数组分成两部分，不要求两部分所包含的元素个数相等，要求使得这两个部分的和的差值最小。比如对于数组{1,0,1,7,2,4}，可以分成{1,0,1,2,4}和{7}，使得这两部分的差值最小。</p>
</blockquote>
<p>思路：<br>
这个问题可以转化为求数组的一个子集，使得这个子集中的元素的和尽可能接近sum/2，其中sum为数组中所有元素的和。这样转换之后这个问题就很类似0-1背包问题了：在n件物品中找到m件物品，他们的可以装入背包中，且总价值最大不过这里不考虑价值，就考虑使得这些元素的和尽量接近sum/2。</p>
<p>下面列状态方程：<br>
<code>dp[i][j]</code>表示前i件物品中，总和最接近j的所有物品的总和，其中包括两种情况：</p>
<ol>
<li>第i件物品没有包括在其中</li>
<li>第i件物品包括在其中<br>
如果第i件物品没有包括在其中，则<code>dp[i][j] = dp[i-1][j]</code><br>
如果第i件物品包括在其中，则<code>dp[i][j] = dp[i-1][j-vec[i]]</code><br>
当然，这里要确保<code>j-vec[i] &gt;= 0</code>。</li>
</ol>
<p>所以状态转移方程为：<br>
<code>dp[i][j] = max(dp[i-1][j],dp[i-1][j-vec[i]]+vec[i]);</code></p>
<pre><code>using namespace std;
//返回两部分的差值
int diff(vector&lt;int&gt;&amp; vec)
{
    int len = vec.size();
 
    int sum = 0;
    for (int i = 0; i &lt; len; ++i) {
        sum += vec[i];
    }
 
    vector&lt;vector&lt;int&gt;&gt; dp;
    for (int i = 0; i &lt;= len; i++) {
        vector&lt;int&gt;tmp;
        for (int j = 0; j &lt;= sum / 2; ++j) {
            tmp.push_back(0);
        }
        dp.push_back(tmp);
    }
    for (int i = 1; i &lt;= len; ++i) {
        for (int j = 1; j &lt;= sum / 2; ++j) {
            if(j&gt;=vec[i-1])dp[i][j] = max(dp[i-1][j],dp[i-1][j-vec[i-1]]+vec[i-1]);
            else dp[i][j] = dp[i - 1][j];
        }
    }
 
    return sum - 2*dp[len][sum / 2];
}
 
int main()
{
    vector&lt;int&gt; vec = { 1,2,3,4,5};
 
    cout &lt;&lt; diff(vec) &lt;&lt; endl;
    system(&quot;pause&quot;);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[公有继承，保护继承，私有继承]]></title>
        <id>https://lixin-scut.github.io//post/gong-you-ji-cheng-bao-hu-ji-cheng-si-you-ji-cheng</id>
        <link href="https://lixin-scut.github.io//post/gong-you-ji-cheng-bao-hu-ji-cheng-si-you-ji-cheng">
        </link>
        <updated>2020-04-04T08:34:07.000Z</updated>
        <content type="html"><![CDATA[<p>总结：</p>
<pre><code>//公有继承                      对象访问    成员访问
public    --&gt;  public              Y         Y
protected --&gt;  protected           N         Y
private   --&gt;  private             N         N
 
//保护继承                      对象访问    成员访问
public    --&gt;  protected           N         Y
protected --&gt;  protected           N         Y
private   --&gt;  protected           N         N
 
//私有继承                      对象访问    成员访问
public    --&gt;  private             N         Y
protected --&gt;  private             N         Y
private   --&gt;  private             N         N
</code></pre>
<h3 id="预备知识">预备知识</h3>
<p>  首先有一个很重要的概念：类和类的用户<br>
  类就不用说了，就是类的本身，类的用户则很广，其中最典型的就是类的对象，对！对象自身也被视为类的用户，而不能被视为类。同时！派生类的派生类也视为用户！（注意不是对象），它也被视为使用派生类的用户。只有接受这一点才能继续下去。<br>
  但是同时也有个例外，友元视为类的成员的一部分，所以友元的访问权限和成员一致（所以友元并非被视为友元）。</p>
<p>  某个类对其继承而来的成员的访问权限受到两个因素影响：一是在基类中该成员的访问说明符，二是在派生类的派生列表中的访问说明符。</p>
<h3 id="类的成员的关键字">类的成员的关键字</h3>
<p>  派生类无法访问基类的私有成员（private）<br>
  派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。和其他使用基类的代码一样.派生类能访问公有成员，而不能访问私有成员。<br>
  不过在某些时候基类中还有这样一种成员，基类希望它的派生类有权访问该成员，同时禁止其他用户访问。我們用受保护的(protected)访问运算符说明这样的成员。<br>
  一个类使用 protected 关键字来声明那些它希望与派生类分享但是不想被其他用户访问使用的成员。 protected 说明符可以看做是 public 和 private 中和后的产物：<br>
•和私有成员类似，受保护的成员对于类的用户来说是不可访问的。（只能通过基类的非私有的成员函数来访问）<br>
•和公有成员类似，受保护的成员对于<strong>派生类的成员和友元</strong>来说是可访问的。<br>
•派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权。</p>
<h3 id="访问控制与继承">访问控制与继承</h3>
<p>  派生访问说明符对于<strong>派生类的成员（及友元）</strong> 能否访问其直接基类的成员没什么影响。<br>
  派生访问说明符的目的是控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限：<br>
  如果继承是公有的，则成员将遵循其原有的访问说明符，<br>
  派生访问说明符还可以控制继承自派生类的新类的访问权限</p>
<p>  派生类采用受保护继承，则基类的所有公有成员在新定义的类中都是受保护的。</p>
<p>  派生类向基类的转换是否可访问由使用该转换的代码决定，同时派生类的派生访问说明符也会有影响。假定 D 继承自 B :<br>
  •只有当 D 公有地继承 B 时，<strong>用户代码</strong>（对象、用户）才能使用派生类向基类的转换：如果 D 继承 B的方式是受保护的或者私有的，则用户代码不能使用该转换。<br>
  •不论 D以什么方式继承 B ， D 的<strong>成员函数和友元</strong>都能使用派生类向基类的转换：派生类向其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的。<br>
  •如果 D 继承 B 的方式是公有的或者受保护的，则 <strong>继承自D 的派生类</strong>的成员和友元可以使用 D 向 B 的类型转换；反之，如果 D 维承 B 的方式是私有的，则不能使用。<br>
  如果基类的公有成员是可访问的，则派生类向基类的类型转换也是可访问的；反之则不行。</p>
<h3 id="区别">区别</h3>
<p>  公有继承的区别就很明显了<br>
  主要就是保护继承和私有继承的区别<br>
  这两者的区别就在于继续继承下去的时候，私有继承依然保持private，而保护继承则为protected，说明再次派生的派生类的成员可以继续访问，而private已经不能再访问了。</p>
<h3 id="友元">友元</h3>
<p>  就像友元关系不能传递一样（参见7.3.4节，第250页），友元关系同样也不能继承。基类的友元在访问派生类成员时不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员：</p>
<p>  当一个类将另一个类声明为友元时，这种友元关系只对做出声明的类有效。对于原來<br>
  那个类来说，其友元的基类或者派生类不具有特殊的访问能力：<br>
  不能继承友元关系；每个类负责控制各自成员的访问权限<br>
  有时我们需要改变派生类继承的某个名字的访问级别，通过使用 using 声明可以达到这一目的：<br>
  通过在类的内部使用 using 声明语句，我们可以将该类的直接或间接基类中的任何可访问成员（例如，非私有成员）标记出来。</p>
<h3 id="默认派生运算符">默认派生运算符</h3>
<p>  默认派生运算符（例如class derived：private base中的private）也由定义派生类所用的关键字来决定。默认情况下，使用 class 关键字定义的派生类是私有继承的；而使用 struct 关键字定义的派生类是公有继承的：<br>
  在使用 struct 关键字和 class 关键字定义的类之间唯一的差别就是默认成员访问说明符及默认派生访问说明符;<br>
  一个私有派生的类最好显式化将 private 指明出来，:而不要仅仅依赖于默认的设置。显式声明的好处是可以令私有继承关系清晰明了，不至于产生误会。</p>
<h3 id="final">final</h3>
<p>  有时我们会定义这样一种类，我们不希望其他类继承它，或者不想考虑它是否适合作为一个基类。为了实现这一目的， C ++11新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字 final ：<br>
<code>class NoDerived final { /* */} //NoDerive不能作为基类</code></p>
<h3 id="例子">例子</h3>
<p>一个比较有趣的解释例子<br>
<a href="https://www.cnblogs.com/feng-qing-yang/p/5962312.html">C++公有继承，私有继承和保护继承的区别</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++类型兼容性]]></title>
        <id>https://lixin-scut.github.io//post/clei-xing-jian-rong-xing</id>
        <link href="https://lixin-scut.github.io//post/clei-xing-jian-rong-xing">
        </link>
        <updated>2020-04-04T07:04:44.000Z</updated>
        <content type="html"><![CDATA[<p>  类型兼容规则是指在需要基类对象的任何地方，都可以使用公有派生类的对象来替代。通过公有继承，派生类得到了基类中除构造函数、析构函数之外的所有成员。这样，公有派生类实际就具备了基类的所有功能，凡是基类能解决的问题，公有派生类都可以解决。类型兼容规则所指的替代包括以下情况：</p>
<ol>
<li>
<p>派生类对象可以当作父类对象使用</p>
</li>
<li>
<p>派生类对象可以直接赋值给父类对象</p>
</li>
<li>
<p>派生类对象可以直接初始化父类对象</p>
</li>
<li>
<p>派生类对象的地址可以赋给指向基类的指针</p>
</li>
<li>
<p>派生类的对象可以初始化基类的引用</p>
</li>
</ol>
<p>  在替代之后，派生类对象就可以作为基类的对象使用，但是只能使用从基类继承的成员。</p>
<p>类型兼容规则是多态性的重要基础之一。</p>
<p>总结：子类就是特殊的父类 （派生类就是特殊的基类）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 198. 打家劫舍[简单]（不连续的元素最大和）]]></title>
        <id>https://lixin-scut.github.io//post/dong-tai-gui-hua-198-da-jia-jie-she-jian-dan</id>
        <link href="https://lixin-scut.github.io//post/dong-tai-gui-hua-198-da-jia-jie-she-jian-dan">
        </link>
        <updated>2020-04-04T04:35:51.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>
给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。<br>
示例 1:<br>
输入: [1,2,3,1]<br>
输出: 4<br>
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>
     偷窃到的最高金额 = 1 + 3 = 4 。<br>
示例 2:<br>
输入: [2,7,9,3,1]<br>
输出: 12<br>
解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。<br>
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/house-robber<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这个就是比较明显的一维动态规划了，和股票题比较像，<br>
状态主要有两种，1代表选择偷窃，0选择不偷窃<br>
然后状态转移<br>
如果选择偷窃，只能从前一天的不偷中累加<br>
如果选择不偷窃，则可以选择前一天的偷和不偷的最大值。</p>
<p>当然最后，最重要的还是题目的转化，这道题其实等同于 数组中不连续的元素的最大和，而不是题目中的故事，这种思维的转化值得学习</p>
<p>实现注意点</p>
<ol>
<li>为了压缩容器的维数，我使用了pair的vector，利用first代替不偷窃，second代替偷窃。</li>
<li>关于初始化，我选择的方法是初始化第一个元素，实际上也可以考虑把sums的纬度设为nums.size()+1，设置一个0号房屋，可以避开初始化。</li>
</ol>
<pre><code>class Solution {
public:
    int rob(vector&lt;int&gt;&amp; nums) {
        if(nums.empty())
        {   return 0; }
        vector&lt;pair&lt;int, int&gt;&gt; sums(nums.size(),make_pair(0,0));
        sums[0].second = nums[0];
        for(int i = 1; i &lt; nums.size(); ++i)
        {
            sums[i].first = max(sums[i - 1].first, sums[i - 1].second);
            sums[i].second = sums[i - 1].first + nums[i];
        }
        return max(sums.back().first, sums.back().second);
    }
};
</code></pre>
<p>这道题还是比较明显的，网友的题解一致<br>
网友题解：</p>
<blockquote>
<p>思路<br>
标签：动态规划</p>
<ol>
<li>动态规划方程：dp[n] = MAX( dp[n-1], dp[n-2] + num )</li>
<li>由于不可以在相邻的房屋闯入，所以在当前位置 n 房屋可盗窃的最大值，要么就是 n-1 房屋可盗窃的最大值，要么就是 n-2 房屋可盗窃的最大值加上当前房屋的值，二者之间取最大值</li>
<li>举例来说：1 号房间可盗窃最大值为 3 即为 dp[1]=3，2 号房间可盗窃最大值为 4 即为 dp[2]=4，3 号房间自身的值为 2 即为 num=2，那么 dp[3] = MAX( dp[2], dp[1] + num ) = MAX(4, 3+2) = 5，3 号房间可盗窃最大值为 5时间复杂度：O(n)，n 为数组长度</li>
</ol>
</blockquote>
<pre><code>class Solution {
    public int rob(int[] nums) {
        int len = nums.length;
        if(len == 0)
            return 0;
        int[] dp = new int[len + 1];
        dp[0] = 0;
        dp[1] = nums[0];
        for(int i = 2; i &lt;= len; i++) {
            dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i-1]);
        }
        return dp[len];
    }
}
作者：guanpengchn
链接：https://leetcode-cn.com/problems/house-robber/solution/hua-jie-suan-fa-198-da-jia-jie-she-by-guanpengchn/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图的最短路径]]></title>
        <id>https://lixin-scut.github.io//post/tu-de-zui-duan-lu-jing</id>
        <link href="https://lixin-scut.github.io//post/tu-de-zui-duan-lu-jing">
        </link>
        <updated>2020-04-03T09:13:14.000Z</updated>
        <content type="html"><![CDATA[<p>求图的最短路径主要有两种方法：迪杰斯特拉（Dijkstra)算法 和 弗洛伊德（Floyd）算法</p>
<h3 id="最短路径">最短路径</h3>
<p>对于网图来说，最短路径，是指两顶点之间经过的边上<strong>权值之和最少</strong>的路径，并且我们称路径上的第—个顶点是源点，最后一个顶点是终点。</p>
<h3 id="迪杰斯特拉dijkstra算法">迪杰斯特拉（Dijkstra)算法</h3>
<p>按路径长度递增的次序产生最短路径的算法<br>
迪杰斯特拉（Dijkstra)算法：并不是一下子就求出了最短路径，而是一步步求出它们之间顶点的最短路径，过程中都 是基于已经求出的最短路径的基础上，求得更远顶点的最短路径，最终得到你要的结果。<br>
邻接矩阵MGraph：</p>
<pre><code>#define MAXVEX 9
#define INFINITY 65535
typedef int Pathmatirx[MAXVEX]; // 用于存储最短路径下标的数组
typedef int ShortPathTable[MAXVEX]; // 用于存储到各点最短路径的权值和
// Dijkstra算法 ， 求有向网G的V0顶点到其余顶点V最短路径P[v]及带权长度D[v]
// P[V]的值为前驱顶点下标，D[V]表示V0到V的最短路径长度和。

void ShortestPath_Dijkstra(MGraph G, 
                                            int v0, 
																						PathMatirx *P, 
																						ShortPathTable *D)
{
	int v, w, k, min;
	int final[MAXVEX]; // final[w] = 1 表示求得顶点V0到Vw的最短路径
	for(v = 0; v &lt; G.numVertexex; ++v)  // 初始化数据
	{
		final[v] = 0; // 全部顶点初始化为未知最短路径状态
		(*D)[v] = G.matirx[v0][v]; // 将与V0点有连线的顶点机上权值
		(*P)[v] = 0; // 初始化路径数组P为0
	}
	(*D)[v0] = 0; // V0到V0路径为0
	final[v0] = 1; // V0到V0不需要求路径
	// 开始主循环，每次求得V0到某个v顶点的最短路径
	for( v = 1; v &lt; G.numVertexex; ++v)
	{
		min = INFINITY; // 当前所知离V0顶点的最近距离
		for(w = 0; w &lt; G.numVertexex; ++w) // 寻找离V0最近的顶点
		{
			if(!final[w] &amp;&amp; (*D)[w] &lt; min)
			{
				k = w;
				min = (*D)[w]; // w顶点离V0顶点更近
			}
		}
		final[k] = 1; // 将目前找到的最近的顶点置为1
		for(w = 0; w &lt; G.numVertexex; ++w) // 修正当前最短路径及距离
		{
			// 如果经过V顶点的路径比现在这条路径的长度短的话
			if(!final[w] &amp;&amp; (min + G.matirx[k][w] &lt; (*D)[w]))
			{ // 说明找到了更短的路径，修改D[w] 和 P[w]
				(*D)[w] = min + G.matirx[k][w]; // 修改当前路径changed
				(*P)[w] = k; // 前驱顶点下标
			}
		}
	}
}
</code></pre>
<p><img src="https://lixin-scut.github.io//post-images/1585921461798.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1585921481678.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1585921500561.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1585921522817.png" alt=""><br>
通过迪杰斯特拉（Dijkstra)算法解决了从某个源点到其余各顶点的最 短路径问题。从循环嵌套可以很容易得到此算法的时间复杂度为O(n^2)<br>
可不可以只找到从源点到某一个特定终点的最短路径，其实这个问题和求源点到其他所有 顶点的最短路径一样复杂，时间复杂度依然是O(n^2)（要考虑整体）<br>
任一顶点到其余所有顶点的最短路径：对每个顶点当作源点运行一次迪杰斯特拉(Dijkstra)算法，等于在 原有算法的基础上，再来一次循环，此时整个算法的时间复杂度就成了O(n^3)</p>
<h3 id="弗洛伊德floyd算法">弗洛伊德（Floyd）算法</h3>
<p><img src="https://lixin-scut.github.io//post-images/1585921596616.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1585921624861.png" alt=""></p>
<pre><code>typedef int Pathmatirx[MAXVEX][MAXVEX]; 
typedef int ShortPathTable[MAXVEX][MAXVEX];
// Floyd算法，求网图G中各顶点V到其余顶点w最短路径P[v][w]及带权长度D[v][w]

void ShortestPath_Floyd(MGraph G, PathMatirx *P, ShortPathTable *D)
{
	int v, w, k;
	for(v = 0; v &lt; G.numVertexes; ++v) // 初始化D与P
	{
			for(w = 0; w &lt; G.numVertexes; ++w)
			{
				(*D)[v][w] = G.matirx[v][w]; // D[v][w]值即为对应点间的权值
				(*P)[v][w] = w; // 初始化P
			}
	}
	for(k = 0; k &lt; G.numVertexes; ++k)
	{
		for(v = 0; v &lt; G.numVertexes; ++v)
		{
			for(w = 0; w &lt; G.numVertexes; ++w)
			{
				if((*D)[v][w] &gt; (*D)[v][k] + (*D)[k][w])
				{ 
					// 如果经过下标为k顶点路径比原两点间的路径更短
					// 将当前两点间权值设为更小的一个
					(*D)[v][w] = (*D)[v][k] + (*D)[k][w];
					(*P)[v][w] = (*P)[v][k];
				}
			}
		}
	}
}
</code></pre>
<p><img src="https://lixin-scut.github.io//post-images/1585922753839.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1585922776967.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1585922814727.png" alt=""><br>
弗洛伊德（Floyd）时间复杂度也是O(n^3) 算法非常简洁优雅<br>
由于它的三重循环，因此也是了O(n^3)时间 复杂度。如果你面临需要求所有顶点至所有顶点的最短路径问题时，弗洛伊德（Floyd)算法 应该是不错的选择。<br>
对求最短路径的两个算法举例都是无向图，但它们对有向图依然有效， 因为二者的差异仅仅是邻接矩阵是否对称而已。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[回溯 679. 24 点游戏[困难][未做出]]]></title>
        <id>https://lixin-scut.github.io//post/hui-su-679-24-dian-you-xi-kun-nan-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/hui-su-679-24-dian-you-xi-kun-nan-wei-zuo-chu">
        </link>
        <updated>2020-04-03T02:12:42.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 *，/，+，-，(，) 的运算得到 24。<br>
示例 1:<br>
输入: [4, 1, 8, 7]<br>
输出: True<br>
解释: (8-4) * (7-1) = 24<br>
示例 2:<br>
输入: [1, 2, 1, 2]<br>
输出: False<br>
注意:<br>
除法运算符 / 表示实数除法，而不是整数除法。例如 4 / (1 - 2/3) = 12 。<br>
每个运算符对两个数进行运算。特别是我们不能用 - 作为一元运算符。例如，[1, 1, 1, 1] 作为输入时，表达式 -1 - 1 - 1 - 1 是不允许的。<br>
你不能将数字连接在一起。例如，输入为 [1, 2, 1, 2] 时，不能写成 12 + 12 。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/24-game<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>从注意事项中得出的难点：</p>
<ol>
<li>实数除法，这个实在是太棘手了，也就是说不能用整型类型来保存，必须用浮点数。</li>
<li>第一个数前面的符号只能是括号，然后运算符必须在括号之前，防止出现(-1+1)的情况（这里我的理解出现了点偏差，其实不是必须四个数按顺序，可以任意组合顺序）</li>
<li>除第一个数字外，每个数字之前必须插入运算符，且只有一个运算符（不包含括号）</li>
</ol>
<p>解题思路：<br>
1.第一点最棘手的就是括号问题，想到的一个方法就是既然有不确定的括号，那还不如都加上括号，或者都去掉括号。<br>
2.从都加上括号出发，就必须预留足够的空间加上括号（最极端的情况有4个）<br>
3.从都去掉括号出发，直接忽略括号，可以把数字进行组合运算，然后将得到的结果视为一个新数字，比如 4，1，8，7组合为4，6 再组合为24<br>
这样子其实就是暗中消除掉了括号，有点像归并法吧</p>
<p>但是有一个问题，就是一开始我想着是两两组合<br>
但是明显（1 + 2 + 3）* 4的情况是无法两两组合的<br>
还是必须逐个相加<br>
本来想着动态规划保存每个状态，但是很明显状态特别多。。。。以至于可能要构造一个很高维的数组并且进行很深的循环<br>
还是先看一下官方题解吧<br>
官方题解使用的是回溯法，直接对所有情况进行递归遍历<br>
实现中需要注意的点：</p>
<ol>
<li>double不能直接和0比较，只能判断精度</li>
<li>加法和乘法有可交换性，可能会造成重复，可以剪枝</li>
<li>记得一定要回溯消除最后一个元素恢复状态</li>
<li>默认返回false</li>
</ol>
<pre><code>class Solution {
public:
    bool judgePoint24(vector&lt;int&gt;&amp; nums) {
        vector&lt;double&gt; numsD;
        for(int num : nums)
        {
            numsD.push_back(static_cast&lt;double&gt;(num));
        }
        return judgePoint24(numsD);
        
    }
    
    bool judgePoint24(vector&lt;double&gt;&amp; numsD)
    {
        if(0 == numsD.size())
        {   return false; }
        if(1 == numsD.size())
        {   return abs(numsD[0] - 24) &lt; pow(0.1, 6); } // 这里的abs取绝对值不能去掉
        
        for(int i = 0; i &lt; numsD.size(); ++i)
        {
            for(int j = 0; j &lt; numsD.size(); ++j)
            {
                if(i != j)
                {
                    vector&lt;double&gt; numsTemp;
                    for(int k = 0; k &lt; numsD.size(); ++k)
                    {
                        if(k != i &amp;&amp; k != j) // i、j为两个选定进行运算的数字，剩下的加入numsTemp等待下一次运算
                        {
                            numsTemp.push_back(numsD[k]);
                        }
                    }
                    for(int k = 0; k &lt; 4; k++)
                    {
                        if(k &lt; 2 &amp;&amp; j &gt; i) { continue; } // 加法和乘法有可交换性，可能会造成重复，直接剪枝
                        if(0 == k) { numsTemp.push_back(numsD[i] + numsD[j]); }
                        if(1 == k) { numsTemp.push_back(numsD[i] * numsD[j]); }
                        if(2 == k) { numsTemp.push_back(numsD[i] - numsD[j]); }
                        if(3 == k)
                        {
                            if(numsD[j] != 0)
                            {
                                numsTemp.push_back(numsD[i] / numsD[j]);
                            }
                            else
                            {
                                continue;
                            }
                        }
                        if(judgePoint24(numsTemp))
                        {
                            return true;
                        }
                        numsTemp.pop_back(); // 记得一定要回溯消除最后一个元素恢复状态
                    }
                }
            }
        }
        return false; // 默认返回false
    }
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>方法：回溯<br>
思路和算法<br>
只有 4 张牌，且只能执行 4 种操作。即使所有运算符都不进行交换，最多也只有 12∗6∗2∗4∗4∗4=9216 种可能性，这使得我们可以尝试所有这些可能。<br>
具体来说，我们有 12 种方式先选出两个数字（有序），并执行 4 种操作之一（12 * 4）。然后，剩下 3 个数字，我们从中选择 2 个并执行 4 种操作之一（6 * 4）。<br>
最后我们剩下两个数字，并在 2 * 4 种可能之中作出最终选择。<br>
我们将对我们的数字或结果数字执行 3 次二元运算（+，-，*，/ 是运算）。因为 - 和 / 不满足交换律，我们必须仔细考虑 a / b 和 b / a。<br>
对于在我们的列表中移除 a, b 这两个数字的每一种方法，以及它们可能产生的每种结果，如 a + b、a / b等，我们将采用递归的方法解决这个较小的数字列表上的问题。</p>
</blockquote>
<pre><code>class Solution {
    public boolean judgePoint24(int[] nums) {
        ArrayList A = new ArrayList&lt;Double&gt;();
        for (int v: nums) A.add((double) v);
        return solve(A);
    }
    private boolean solve(ArrayList&lt;Double&gt; nums) {
        if (nums.size() == 0) return false;
        if (nums.size() == 1) return Math.abs(nums.get(0) - 24) &lt; 1e-6;

        for (int i = 0; i &lt; nums.size(); i++) {
            for (int j = 0; j &lt; nums.size(); j++) {
                if (i != j) {
                    ArrayList&lt;Double&gt; nums2 = new ArrayList&lt;Double&gt;();
                    for (int k = 0; k &lt; nums.size(); k++) if (k != i &amp;&amp; k != j) {
                        nums2.add(nums.get(k));
                    }
                    for (int k = 0; k &lt; 4; k++) {
                        if (k &lt; 2 &amp;&amp; j &gt; i) continue;
                        if (k == 0) nums2.add(nums.get(i) + nums.get(j));
                        if (k == 1) nums2.add(nums.get(i) * nums.get(j));
                        if (k == 2) nums2.add(nums.get(i) - nums.get(j));
                        if (k == 3) {
                            if (nums.get(j) != 0) {
                                nums2.add(nums.get(i) / nums.get(j));
                            } else {
                                continue;
                            }
                        }
                        if (solve(nums2)) return true;
                        nums2.remove(nums2.size() - 1);
                    }
                }
            }
        }
        return false;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(1)，总计 9216 种可能的硬性限制，对于每种可能，我们执行操作的复杂度为O(1)。<br>
空间复杂度：O(1)，我们的中间数组最多有 4 个元素，所生成的数字由复杂度 O(1) 的因子限定。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 887. 鸡蛋掉落[困难][未做出]]]></title>
        <id>https://lixin-scut.github.io//post/dong-tai-gui-hua-887-ji-dan-diao-luo-kun-nan-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/dong-tai-gui-hua-887-ji-dan-diao-luo-kun-nan-wei-zuo-chu">
        </link>
        <updated>2020-04-02T02:26:53.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。<br>
每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。<br>
你知道存在楼层 F ，满足 0 &lt;= F &lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。<br>
每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &lt;= X &lt;= N）。<br>
你的目标是确切地知道 F 的值是多少。<br>
示例 1：<br>
输入：K = 1, N = 2<br>
输出：2<br>
解释：<br>
鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。<br>
否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。<br>
如果它没碎，那么我们肯定知道 F = 2 。<br>
因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。<br>
示例 2：<br>
输入：K = 2, N = 6<br>
输出：3<br>
示例 3：<br>
输入：K = 3, N = 14<br>
输出：4<br>
提示：<br>
1 &lt;= K &lt;= 100<br>
1 &lt;= N &lt;= 10000<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/super-egg-drop<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题算是比较经典的面试题了，题目的思想和解题方法都相对比较反常规思路，值得慢慢琢磨。<br>
1.题目思想：最坏情况的最少次数，这个比较绕，<br>
首先必须注意最坏情况是对于<strong>特定的策略</strong>来说，比如采用线性扫描的话，最坏情况就是第N层才摔坏，必须试N次（注意此处不考虑排除法）。然后如果采用二分法的话，最坏情况就是最边缘嘛，转化过来也就是二叉树走到叶节点才发现目标值，也就是logn。<br>
此时，我们希望得到的最少次数也就是总楼层确定、针对特定策略定下摔坏层数的情况下，<strong>不同的策略</strong>之间比较能够得到的最小次数<br>
这样才能解析为什么状态转移公式中既有min（最小次数），也有max（最坏情况）<br>
2.鸡蛋个数的限制<br>
鸡蛋个数的限制其实会直接废弃很多策略，最典型的就是最快的二分法。</p>
<pre><code>class Solution {
public:
    int superEggDrop(int K, int N) {
        vector&lt;vector&lt;int&gt;&gt; counts(K + 1, vector&lt;int&gt;(N + 1, -1));
        return superEggDrop(K, N, counts) ;
    }
    
		// 动态规划-线性遍历
    int superEggDrop(int K, int N, vector&lt;vector&lt;int&gt;&gt;&amp; counts)
    {
        if(K == 1)
        {
            return N;
        }
        if(N == 0)
        {
            return 0;
        }
        
        if(counts[K][N] != -1)
        {
            return counts[K][N];
        }
        
        int res = INT_MAX;
        for(int i = 1;i &lt; N + 1; ++i)
        {
            res = min(res, 1 + max(superEggDrop(K, N - i, counts), superEggDrop(K - 1, i - 1, counts)));
        }
        counts[K][N] = res;
        return res;
    }
		
		// 动态规划-二分查找
		int superEggDrop(int K, int N, vector&lt;vector&lt;int&gt;&gt;&amp; counts)
    {
        if(K == 1)
        {
            return N;
        }
        if(N == 0)
        {
            return 0;
        }
        
        if(counts[K][N] != -1)
        {
            return counts[K][N];
        }
        
        int res = INT_MAX;
        int low, high;
        low = 1;
        high = N;
        while(low &lt;= high)
        {
            int mid = low + (high - low) / 2;
            int unbroken = superEggDrop(K, N - mid, counts);
            int broken = superEggDrop(K - 1, mid - 1, counts);
            
            if(unbroken &gt; broken)
            {
                low = mid + 1;
                res = min(res, unbroken + 1);
            }
            else
            {
                high = mid - 1;
                res = min(res, broken + 1);
            }
        }
        
        counts[K][N] = res;
        return res;
    }
};
</code></pre>
<p>网友题解：<br>
一、解析题目<br>
题目是这样：你面前有一栋从 1 到 N 共 N 层的楼，然后给你 K 个鸡蛋（K 至少为 1）。现在确定这栋楼存在楼层 0 &lt;= F &lt;= N，在这层楼将鸡蛋扔下去，鸡蛋恰好没摔碎（高于 F 的楼层都会碎，低于 F 的楼层都不会碎）。现在问你，最坏情况下，你至少要扔几次鸡蛋，才能确定这个楼层 F 呢？<br>
也就是让你找摔不碎鸡蛋的最高楼层 F，但什么叫「最坏情况」下「至少」要扔几次呢？我们分别举个例子就明白了。<br>
比方说现在先不管鸡蛋个数的限制，有 7 层楼，你怎么去找鸡蛋恰好摔碎的那层楼？<br>
最原始的方式就是线性扫描：我先在 1 楼扔一下，没碎，我再去 2 楼扔一下，没碎，我再去 3 楼……<br>
以这种策略，最坏情况应该就是我试到第 7 层鸡蛋也没碎（F = 7），也就是我扔了 7 次鸡蛋。<br>
先在你应该理解什么叫做「最坏情况」下了，鸡蛋破碎一定发生在搜索区间穷尽时，不会说你在第 1 层摔一下鸡蛋就碎了，这是你运气好，不是最坏情况。<br>
现在再来理解一下什么叫「至少」要扔几次。依然不考虑鸡蛋个数限制，同样是 7 层楼，我们可以优化策略。<br>
最好的策略是使用二分查找思路，我先去第 (1 + 7) / 2 = 4 层扔一下：<br>
如果碎了说明 F 小于 4，我就去第 (1 + 3) / 2 = 2 层试……<br>
如果没碎说明 F 大于等于 4，我就去第 (5 + 7) / 2 = 6 层试……<br>
以这种策略，最坏情况应该是试到第 7 层鸡蛋还没碎（F = 7），或者鸡蛋一直碎到第 1 层（F = 0）。然而无论那种最坏情况，只需要试 log7 向上取整等于 3 次，比刚才尝试 7 次要少，这就是所谓的至少要扔几次。<br>
PS：这有点像 Big O 表示法计算算法的复杂度。<br>
实际上，如果不限制鸡蛋个数的话，二分思路显然可以得到最少尝试的次数，但问题是，现在给你了鸡蛋个数的限制 K，直接使用二分思路就不行了。<br>
比如说只给你 1 个鸡蛋，7 层楼，你敢用二分吗？你直接去第 4 层扔一下，如果鸡蛋没碎还好，但如果碎了你就没有鸡蛋继续测试了，无法确定鸡蛋恰好摔不碎的楼层 F 了。这种情况下只能用线性扫描的方法，算法返回结果应该是 7。<br>
有的读者也许会有这种想法：二分查找排除楼层的速度无疑是最快的，那干脆先用二分查找，等到只剩 1 个鸡蛋的时候再执行线性扫描，这样得到的结果是不是就是最少的扔鸡蛋次数呢？<br>
很遗憾，并不是，比如说把楼层变高一些，100 层，给你 2 个鸡蛋，你在 50 层扔一下，碎了，那就只能线性扫描 1～49 层了，最坏情况下要扔 50 次。<br>
如果不要「二分」，变成「五分」「十分」都会大幅减少最坏情况下的尝试次数。比方说第一个鸡蛋每隔十层楼扔，在哪里碎了第二个鸡蛋一个个线性扫描，总共不会超过 20 次。<br>
最优解其实是 14 次。最优策略非常多，而且并没有什么规律可言。<br>
说了这么多废话，就是确保大家理解了题目的意思，而且认识到这个题目确实复杂，就连我们手算都不容易，如何用算法解决呢？</p>
<p>二、思路分析<br>
对动态规划问题，直接套我们以前多次强调的框架即可：这个问题有什么「状态」，有什么「选择」，然后穷举。<br>
「状态」很明显，就是当前拥有的鸡蛋数 K 和需要测试的楼层数 N。随着测试的进行，鸡蛋个数可能减少，楼层的搜索范围会减小，这就是状态的变化。<br>
「选择」其实就是去选择哪层楼扔鸡蛋。回顾刚才的线性扫描和二分思路，二分查找每次选择到楼层区间的中间去扔鸡蛋，而线性扫描选择一层层向上测试。不同的选择会造成状态的转移。<br>
现在明确了「状态」和「选择」，动态规划的基本思路就形成了：肯定是个二维的 dp 数组或者带有两个状态参数的 dp 函数来表示状态转移；外加一个 for 循环来遍历所有选择，择最优的选择更新状态：</p>
<h1 id="当前状态为-k-个鸡蛋面对-n-层楼">当前状态为 K 个鸡蛋，面对 N 层楼</h1>
<h1 id="返回这个状态下的最优结果">返回这个状态下的最优结果</h1>
<pre><code>def dp(K, N):
    int res
    for 1 &lt;= i &lt;= N:
        res = min(res, 这次在第 i 层楼扔鸡蛋)
    return res
</code></pre>
<p>这段伪码还没有展示递归和状态转移，不过大致的算法框架已经完成了。<br>
我们选择在第 i 层楼扔了鸡蛋之后，可能出现两种情况：鸡蛋碎了，鸡蛋没碎。注意，这时候状态转移就来了：</p>
<p>如果鸡蛋碎了，那么鸡蛋的个数 K 应该减一，搜索的楼层区间应该从 [1..N] 变为 [1..i-1] 共 i-1 层楼；</p>
<p>如果鸡蛋没碎，那么鸡蛋的个数 K 不变，搜索的楼层区间应该从 [1..N] 变为 [i+1..N] 共 N-i 层楼。<br>
<img src="https://lixin-scut.github.io//post-images/1585795304992.png" alt=""><br>
PS：细心的读者可能会问，在第i层楼扔鸡蛋如果没碎，楼层的搜索区间缩小至上面的楼层，是不是应该包含第i层楼呀？不必，因为已经包含了。开头说了 F 是可以等于 0 的，向上递归后，第i层楼其实就相当于第 0 层，可以被取到，所以说并没有错误。</p>
<p>因为我们要求的是最坏情况下扔鸡蛋的次数，所以鸡蛋在第 i 层楼碎没碎，取决于那种情况的结果更大：</p>
<pre><code>def dp(K, N):
    for 1 &lt;= i &lt;= N:
        # 最坏情况下的最少扔鸡蛋次数
        res = min(res, 
                  max( 
                        dp(K - 1, i - 1), # 碎
                        dp(K, N - i)      # 没碎
                     ) + 1 # 在第 i 楼扔了一次
                 )
    return res
</code></pre>
<p>递归的 base case 很容易理解：当楼层数 N 等于 0 时，显然不需要扔鸡蛋；当鸡蛋数 K 为 1 时，显然只能线性扫描所有楼层：</p>
<pre><code>def dp(K, N):
    if K == 1: return N
    if N == 0: return 0
    ...
</code></pre>
<p>至此，其实这道题就解决了！只要添加一个备忘录消除重叠子问题即可：</p>
<pre><code>def superEggDrop(K: int, N: int):

    memo = dict()
    def dp(K, N) -&gt; int:
        # base case
        if K == 1: return N
        if N == 0: return 0
        # 避免重复计算
        if (K, N) in memo:
            return memo[(K, N)]

        res = float('INF')
        # 穷举所有可能的选择
        for i in range(1, N + 1):
            res = min(res, 
                      max(
                            dp(K, N - i), 
                            dp(K - 1, i - 1)
                         ) + 1
                  )
        # 记入备忘录
        memo[(K, N)] = res
        return res
    
    return dp(K, N)
</code></pre>
<p>这个算法的时间复杂度是多少呢？动态规划算法的时间复杂度就是子问题个数 × 函数本身的复杂度。<br>
函数本身的复杂度就是忽略递归部分的复杂度，这里 dp 函数中有一个 for 循环，所以函数本身的复杂度是 O(N)。<br>
子问题个数也就是不同状态组合的总数，显然是两个状态的乘积，也就是 O(KN)。<br>
所以算法的总时间复杂度是 O(K*N^2), 空间复杂度 O(KN)。</p>
<p>三、疑难解答</p>
<p>这个问题很复杂，但是算法代码却十分简洁，这就是动态规划的特性，穷举加备忘录/DP table 优化，真的没啥新意。<br>
首先，有读者可能不理解代码中为什么用一个 for 循环遍历楼层 [1..N]，也许会把这个逻辑和之前探讨的线性扫描混为一谈。其实不是的，这只是在做一次「选择」。<br>
比方说你有 2 个鸡蛋，面对 10 层楼，你这次选择去哪一层楼扔呢？不知道，那就把这 10 层楼全试一遍。至于下次怎么选择不用你操心，有正确的状态转移，递归会算出每个选择的代价，我们取最优的那个就是最优解。<br>
另外，这个问题还有更好的解法，比如修改代码中的 for 循环为二分搜索，可以将时间复杂度降为 O(K*N*logN)；再改进动态规划解法可以进一步降为 O(KN)；使用数学方法解决，时间复杂度达到最优 O(K*logN)，空间复杂度达到 O(1)。<br>
二分的解法也有点误导性，你很可能以为它跟我们之前讨论的二分思路扔鸡蛋有关系，实际上没有半毛钱关系。能用二分搜索是因为状态转移方程的函数图像具有单调性，这里就不展开以上解法了。我觉得吧，我们这种解法就够了：找状态，做选择，足够清晰易懂，可流程化，可举一反三。掌握这套框架学有余力的话，再去考虑那些奇技淫巧也不迟。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++中各种类型表示范围测试代码（最大最小值）]]></title>
        <id>https://lixin-scut.github.io//post/czhong-ge-chong-lei-xing-biao-shi-fan-wei-ce-shi-dai-ma-zui-da-zui-xiao-zhi</id>
        <link href="https://lixin-scut.github.io//post/czhong-ge-chong-lei-xing-biao-shi-fan-wei-ce-shi-dai-ma-zui-da-zui-xiao-zhi">
        </link>
        <updated>2020-03-29T03:00:43.000Z</updated>
        <content type="html"><![CDATA[<p>不同的机器上可以所占的字节数和可以表示的范围不尽相同<br>
特别是32位和64位之差。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include &lt;limits&gt;
using namespace std;

int main()
{
    cout &lt;&lt; &quot;type: \t\t&quot; &lt;&lt; &quot;************size**************&quot;&lt;&lt; endl;
    cout &lt;&lt; &quot;bool: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(bool);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;bool&gt;::max)();
    cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;bool&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;char: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(char);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;char&gt;::max)();
    cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;char&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;signed char: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(signed char);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;signed char&gt;::max)();
    cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;signed char&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;unsigned char: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(unsigned char);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;unsigned char&gt;::max)();
    cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;unsigned char&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;wchar_t: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(wchar_t);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;wchar_t&gt;::max)();
    cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;wchar_t&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;short: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(short);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;short&gt;::max)();
    cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;short&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;int: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(int);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;int&gt;::max)();
    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;int&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;unsigned: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(unsigned);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;unsigned&gt;::max)();
    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;unsigned&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;long: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(long);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;long&gt;::max)();
    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;long&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;unsigned long: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(unsigned long);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;unsigned long&gt;::max)();
    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;unsigned long&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;double: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(double);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;double&gt;::max)();
    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;double&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;long double: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(long double);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;long double&gt;::max)();
    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;long double&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;float: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(float);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;float&gt;::max)();
    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;float&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;size_t: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(size_t);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;size_t&gt;::max)();
    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;size_t&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;string: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(string) &lt;&lt; endl;
    // &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;string&gt;::max)() &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;string&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;type: \t\t&quot; &lt;&lt; &quot;************size**************&quot;&lt;&lt; endl;
    return 0;
}
</code></pre>
<p>64位macOS下Clion输出结果</p>
<pre><code>type: 		************size**************
bool: 		所占字节数：1	最大值：1		最小值：0
char: 		所占字节数：1	最大值：		最小值：�
signed char: 	所占字节数：1	最大值：		最小值：�
unsigned char: 	所占字节数：1	最大值：�		最小值：�
wchar_t: 	所占字节数：4	最大值：2147483647		最小值：-2147483648
short: 		所占字节数：2	最大值：32767		最小值：-32768
int: 		所占字节数：4	最大值：2147483647	最小值：-2147483648
unsigned: 	所占字节数：4	最大值：4294967295	最小值：0
long: 		所占字节数：8	最大值：9223372036854775807	最小值：-9223372036854775808
unsigned long: 	所占字节数：8	最大值：18446744073709551615	最小值：0
double: 	所占字节数：8	最大值：1.79769e+308	最小值：2.22507e-308
long double: 	所占字节数：16	最大值：1.18973e+4932	最小值：3.3621e-4932
float: 		所占字节数：4	最大值：3.40282e+38	最小值：1.17549e-38
size_t: 	所占字节数：8	最大值：18446744073709551615	最小值：0
string: 	所占字节数：32
type: 		************size**************

Process finished with exit code 0

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 377. 组合总和 Ⅳ[中等]]]></title>
        <id>https://lixin-scut.github.io//post/dong-tai-gui-hua-377-zu-he-zong-he-ivzhong-deng</id>
        <link href="https://lixin-scut.github.io//post/dong-tai-gui-hua-377-zu-he-zong-he-ivzhong-deng">
        </link>
        <updated>2020-03-29T02:46:17.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。<br>
示例:<br>
nums = [1, 2, 3]<br>
target = 4<br>
所有可能的组合为：<br>
(1, 1, 1, 1)<br>
(1, 1, 2)<br>
(1, 2, 1)<br>
(1, 3)<br>
(2, 1, 1)<br>
(2, 2)<br>
(3, 1)<br>
请注意，顺序不同的序列被视作不同的组合。<br>
因此输出为 7。<br>
进阶：<br>
如果给定的数组中含有负数会怎么样？<br>
问题会产生什么变化？<br>
我们需要在题目中添加什么限制来允许负数的出现？</p>
</blockquote>
<p>这道题也好像斐波那契<br>
就是把每个数存在的情况加起来<br>
重点就在于顺序不同的序列被当成不同的组合<br>
它的类似题目是<br>
<a href="https://lixin-scut.github.io/post/dong-tai-gui-hua-322-ling-qian-dui-huan-zhong-deng/">动态规划 322. 零钱兑换[中等]</a><br>
这里的区别是计算可以凑成目标值所需的最少的数字个数<br>
<a href="https://lixin-scut.github.io/post/dong-tai-gui-hua-518-ling-qian-dui-huan-iizhong-deng-wei-zuo-chu/">动态规划 518. 零钱兑换 II[中等][未做出]</a><br>
这里的区别是只考虑组合不考虑排列，顺序不同的序列被当成相同的组合</p>
<p>尴尬，超时了。。。<br>
有一个问题是有些情况根本达不到的，但是却会导致超级大的数。<br>
然后必须用unsigned int来定义容器类型<br>
但是我用long就还是会爆炸。。。以后得找一下原因</p>
<pre><code>class Solution {
public:
    int combinationSum4(vector&lt;int&gt;&amp; nums, int target) {
        if(0 == target)
        {   return 1;}
        if(nums.empty())
        {   return 0;}
        
        vector&lt;unsigned int&gt; counts(target + 1, 0);
        counts[0] = 1;
        for(int i = 1; i &lt; target + 1; ++i)
        {
            for(auto num : nums)
            {
                if(num &lt;= i)
                {
                     counts[i] +=  counts[i - num]; 
                    //counts[i] = (counts[i] &gt;= INT_MAX - counts[i - num])? 
                    //    INT_MAX : counts[i] + counts[i - num];
                }
            }
        }
        return counts.back();
    }
};
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>题意分析：<br>
输入数组的每个元素可以使用多次，这一点和「完全背包」问题有点像；<br>
顺序不同的序列被视作不同的组合，这一点和所有的「背包问题」都不同，与 518. 零钱兑换 II 问题不同的地方就在这一点。<br>
思路分析：<br>
遇到这一类问题，做一件事情有很多种做法，每一种做法有若干个步骤，脑子里能想到的常规思路大概有「回溯搜索」、「动态规划」；<br>
由于不用得到具体的组合表示，因此考虑使用「动态规划」来解。<br>
https://pic.leetcode-cn.com/fa278029267fedeb06686b784bd322f16b2abf6b61987dc3b5257630570cd38f-377-1.png<br>
很容易发现「重复问题」，因此，我们可以使用「动态规划」来做，如果题目问具体的解，那么用「回溯搜索」做（「力扣」第 39 题：组合之和）。<br>
递归求解：由于有大量「重复子问题」，因此必须使用缓存，以避免相同问题重复求解，这个方法叫「记忆化搜索」，在《算法导论》这本书上也把它归入到「动态规划」的定义中。这种思考问题的方式是「从上到下」的，直接面对问题求解，遇到什么问题，就解决什么问题，同时记住结果；<br>
「动态规划」告诉了我们另一种思考问题的方式：「从底向上」，可以不直接面对问题求解，从这个问题最小的样子开始，通过逐步递推，至到得到所求的问题的答案。<br>
虽然这个问题没有明显的「最优子结构」，但这种「从底向上」递推的思路是很深刻的，我们也把它归纳到「动态规划」的解法中。</p>
</blockquote>
<blockquote>
<p>方法：动态规划<br>
“动态规划”的两个步骤是思考“状态”以及“状态转移方程”。<br>
1、状态<br>
对于“状态”，我们首先思考能不能就用问题当中问的方式定义状态，上面递归树都画出来了。当然就用问题问的方式。<br>
dp[i] ：对于给定的由正整数组成且不存在重复数字的数组，和为 i 的组合的个数。<br>
思考输出什么？因为状态就是问题当中问的方式而定义的，因此输出就是最后一个状态 dp[n]。<br>
2、状态转移方程<br>
由上面的树形图，可以很容易地写出状态转移方程：<br>
dp[i] = sum{dp[i - num] for num in nums and if i &gt;= num}<br>
注意：在 0 这一点，我们定义 dp[0] = 1 的，它表示如果 nums 里有一个数恰好等于 target，它单独成为 1 种可能。<br>
参考代码：</p>
</blockquote>
<pre><code>Java
public class Solution {

    /**
     * 这里状态定义就是题目要求的，并不难，状态转移方程要动点脑子，也不难：
     * 状态转移方程：dp[i]= dp[i - nums[0]] + dp[i - nums[1]] + dp[i - nums[2]] + ... （当 [] 里面的数 &gt;= 0）
     * 特别注意：dp[0] = 1，表示，如果那个硬币的面值刚刚好等于需要凑出的价值，这个就成为 1 种组合方案
     * 再举一个具体的例子：nums=[1, 3, 4], target=7;
     * dp[7] = dp[6] + dp[4] + dp[3]
     * 即：7 的组合数可以由三部分组成，1 和 dp[6]，3 和 dp[4], 4 和dp[3];
     *
     * @param nums
     * @param target
     * @return
     */
    public int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target + 1];
        // 这个值被其它状态参考，设置为 1 是合理的
        dp[0] = 1;

        for (int i = 1; i &lt;= target; i++) {
            for (int num : nums) {
                if (num &lt;= i) {
                    dp[i] += dp[i - num];
                }
            }
        }
        return dp[target];
    }
}
</code></pre>
<blockquote>
<p>对于进阶问题的思考<br>
1、如果给定的数组中含有负数会怎么样？问题会产生什么变化？<br>
如果有负数，相当于给定数组中的元素有了更多的组合，特别是出现了一对相反数的时候，例如题目中的示例 [-4, 1, 2, 3, 4]，target = 4 的时候，-4 和 4 可以无限次地、成对添加到题目中的示例中，成为新的组合，那么这道问题就没有什么意义了。<br>
仔细思考，负数我只要不选它就行了。但由于这道问题的问法是“组合”，因此我们要保证有负数参与进来，不能够与已有的正数的组合之和为 0 即可。<br>
2、我们需要在题目中添加什么限制来允许负数的出现？<br>
如果有负数参与进来，不能够与已有的正数的组合之和为 0 ；<br>
或者限制负数的使用次数，设计成类似 0-1 背包问题的样子。</p>
</blockquote>
]]></content>
    </entry>
</feed>