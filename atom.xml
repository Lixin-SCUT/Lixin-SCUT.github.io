<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-11-30T01:18:35.316Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[ C++ primer 第十八章 笔记+习题 19.3-19.4]]></title>
        <id>https://lixin-ee.github.io//post/c</id>
        <link href="https://lixin-ee.github.io//post/c">
        </link>
        <updated>2019-11-29T07:58:35.000Z</updated>
        <content type="html"><![CDATA[<p>19.3 枚举类型<br>
<strong>枚举类型</strong>（enumeration)使我们可以将一组<strong>整型常量</strong>组织在一起。和类一样，每个枚 举类型定义了一种新的类型。<strong>枚举属于字面值常量类型</strong>（参见7.5.6节，第267页）<br>
定义<strong>限定作用域</strong>的枚举类型的一般形式是：首先是<strong>关键字enum class</strong>(或者等价地使用<strong>enum struct</strong>),随后是<strong>枚举类型名字</strong>以及用<strong>花括号括起来</strong>的以<strong>逗号分隔</strong>的<strong>枚举成员</strong>（enumerator)列表，最后是一个<strong>分号</strong>：<br>
enum class open_modes{input,output,append};<br>
定义<strong>不限定作用域</strong>的枚举类型（unscoped enumeration)时<strong>省略掉关键字class</strong>(或struct)，枚举类型的<strong>名字是可选的</strong>：</p>
<p>枚举成员<br>
在<strong>限定作用域</strong>的枚举类型中，枚举成员的名字<strong>遵循常规的作用域准则</strong>，并且在枚举类型的<strong>作用域外是不可访问</strong>的。与之相反，在<strong>不限定作用域</strong>的枚举类型中，<strong>枚举成员的作用域</strong>与<strong>枚举类型本身的作用域相同</strong>：<strong>相当于类的成员</strong></p>
<p>有效的作用域：需要加peppers::</p>
<p><strong>默认情况</strong>下，<strong>枚举值从0开始</strong>，<strong>依次加1</strong>。不过我们也能为一个或几个枚举成员指定专门的值：<br>
<strong>枚举值不一定唯一</strong>。<br>
<strong>如果我们没有显式提供初始值，那么当前枚举对象的值等于之前枚举对象的值+1</strong><br>
<strong>枚举成员是const</strong>,因此在<strong>初始化</strong>枚举成员时<strong>提供的初始值</strong>必须是<strong>常量表达式</strong>（参见 2.4.4节，第58页）。也就是说，<strong>每个枚举成员本身就是一条常量表达式</strong>，我们可以<strong>在任何 需要常量表达式</strong>的地方使用<strong>枚举成员</strong>。例如，我们<strong>可以定义枚举类型的constexpr变量</strong>;<br>
constexprintTypescharbits=intTypes:;charTyp;<br>
类似的，我们也可以将一个enum作为switch语句的表达式，而将<strong>枚举值作为case标 签</strong>（参见5.3.2节，第160页）。出于同样的原因，我们还能将枚举类型作为一个非类型模 板形参使用（参见16.1.1节.第580页）；或者在类的定义中初始化枚举类型的静态数据成员（参见7.6节，第270页）。switch(color){case red: case green:}</p>
<p><strong>和类一样，枚举也定义新的类型</strong>只要enum有名字，我们就能定义并初始化该类型的成员。要想<strong>初始化</strong>enum对象或者为enum对象<strong>赋值 (区分enum对象和enum成员)</strong>，必须<strong>使用该类型的一个枚举成员</strong>或者<strong>该类型的另一个对象</strong>：<br>
一个<strong>不限定作用域</strong>的枚举类型的对象或枚举成员<strong>自动地转换成整型</strong>。因此，我们可以在任何需要整型值的地方使用它们. <strong>限定作用域的enum无法进行隐式转换</strong></p>
<p>指定enum的大小<br>
尽管每个enum都定义了唯一的类型，但实际上enum是由某种整数类型表示的。在 C++11新标准中，我们可以在<strong>enum的名字后加上冒号</strong>以及我们<strong>想在该enum中使用的类型</strong>：<br>
如果我们没有指定enum的潜在类型，则默认情况下限定作用域的enum成员类型是int。对于不限定作用域的枚举类型来说，其枚举成员不存在默认类型，我们只知道成员的潜在类型足够大，肯定能够容纳枚举值。<strong>如果我们指定了</strong>枚举成员的<strong>潜在类型</strong>（包括对限定作 用域的enum的隐式指定），则<strong>一旦</strong>某个枚举成员的值<strong>超出了该类型所能容纳的范围，将引发程序错误。</strong><br>
<strong>指定enum潜在类型</strong>的能力使得我们可以<strong>控制不同实现环境中使用的类型</strong>.我们将可以确保在一种实现环境中编译通过的程序所生成的代码与其他实现环境中生成的代码一致。</p>
<p>枚举类型的前置声明<br>
在C++11新标准中，我们可以<strong>提前声明enum</strong>。enum的前置声明（无论隐式地还是显式地）<strong>必须指定其成员的大小</strong>：<br>
//不限定指用域的枚举类型intValues的前置声明<br>
enum intValues : unsigned long long;	//<strong>不限定作用域的，必须指定成员类型</strong><br>
enum class open_inodes;	//<strong>限定作用域</strong>的枚举类型可以<strong>使用默认成员类型int</strong><br>
因为<strong>不限定作用域</strong>的enum<strong>未指定成员的默认大小</strong>，因此<strong>每个声明必须指定成员的大小</strong>。对于<strong>限定作用域的enum</strong>来说，我们可以<strong>不指定其成员的大小</strong>，这个值被<strong>隐式地定义</strong>为int。<br>
和其他声明语句一样，<strong>enum的声明和定义必须匹配</strong>，这意味着在该enum的所有声明和定义中成员的<strong>大小必须一致</strong>。而且，我们不能在问一个上下文中先声明一个不限定作用域的enum名字，然后再声明一个同名的限定作用域的enum;<strong>（作用域也必须一致）</strong></p>
<p>形参匹配与枚举类型<br>
要想<strong>初始化一个enum对象</strong>，<strong>必须使用该enum类型的另一个对象或者它的一个枚举成员</strong>（参化19.3节，第737页）。因此，即使某个整型值恰好与枚举成员的值相等，它也不能作为函数的enum实参使用：<br>
尽管我们<strong>不能直接将整型值传给enum形参</strong>，但是<strong>可将一个不限定作用域的枚举类型的对象或枚举成员传给整型形参</strong>。此时，enum的值<strong>提升成int或更大的整型</strong>，实际提升的结果由枚举类型的潜在类型决定：<br>
枚举成员<strong>永远不会提升成unsigned char</strong>,即使枚举值可以用unsigned char存储也是如此。</p>
<p>19.4 类成员指针<br>
<strong>成员指针(pointer to member)</strong> 是指可以<strong>指向类的非静态成员</strong>的指针<br>
<strong>一般情况</strong>下，指针<strong>指向一个对象</strong>，但是<strong>成员指针</strong>指示的是<strong>类的成员</strong>，<strong>而非类的对象</strong>。<strong>类的静态成员不属于任何对象</strong>，因此无须特殊的指向静态成员的指针，<strong>指向静态成员的指针与普通指针没有什么区别</strong>。<br>
<strong>成员指针的类型</strong>囊括了<strong>类的类型以及成员的类型</strong>。当<strong>初始化</strong>一个这样的指针时，我们令其<strong>指向类的某个成员</strong>，<strong>但是不指定该成员所属的对象</strong>：<strong>直到使用</strong>成员指针时，<strong>才提供</strong>成员<strong>所属的对象</strong>。</p>
<p>19.4.1 数据成员指针<br>
和其他指针一样，在声明成员指针时我们也使用*来表示当前声明的名字是一个指针。 与普通指针不同的是，<strong>成员指针还必须包含成员所属的类</strong>。因此，我们必须<strong>在*之前添加 classname::</strong> 表示当前定义的指针可以指向classname的成员。例如：<br>
//pdata可以指向一个常量（非常量）Screen对象的string成员<br>
const string <strong>Screen::*pdata</strong>;</p>
<p>当我们初始化一个成员指针（或者向它赋值）时，需<strong>指定它所指的成员</strong>（<strong>但不需要指定对象</strong>）。例如，我们可令pdata指向某个非特定Screen对象的contents成员：<br>
pdata = &amp;Screen::contents;<br>
其中，我们将取地址运算符作用于<strong>Screen类的成员</strong>而<strong>非内存中的一个该类对象</strong>。<br>
当然，在C++11新标准中声明成员指针<strong>最简单的方法是使用auto或decltype</strong>：<br>
auto pdata = &amp;Screen::contents;</p>
<p>使用数据成员指针<br>
当我们<strong>初始化</strong>一个成员指针或为成员指针<strong>赋值</strong>时，该指针<strong>并没有指向任何数据</strong>。成员指针<strong>指定了成员</strong>而<strong>非该成员所属的对象</strong>，只有<strong>当解引用成员指针时我们才提供对象的信息</strong>。<br>
与成员访问运算符.和-&gt;类似，也有两种成员指针访问运算符：<strong>.*和-&gt;*（注意是带*号的）</strong>，这两个运算符使得我们可以解引用指针并获得该对象的成员：</p>
<pre><code>Screen myScreen,*pScreen=&amp;myScreen; 
//.*解引用pdata以获得myScreen对象的contents成员 
auto s = myScreen.*pdata; 
//-&gt;*解引用pdata以获得pScreen所指对象的contents成员 
s = pScreen**—&gt;*pdata**; 
</code></pre>
<p>从概念上来说，这些运算符<strong>执行两步操作</strong>：它们<strong>首先解引用</strong>成员指针以得到所需的成员. <strong>然后像成员访问运算符</strong>一样，通过对象(.*)或指针(-&gt;*)获取成员。</p>
<p>返回数据成员指针的函数<br>
<strong>常规的访问控制规则对成员指针同样有效</strong>。例如，Screen的contents成员是私有的，因此之前对于pdata的使用必须位于Screen类的成员或友元内部，否则程序将发生错误。<br>
因为<strong>数据成员</strong>一般情况下是<strong>私有的</strong>，所以我们通常<strong>不能直接获得</strong>数据成员的<strong>指针</strong>。如 一个像Screen这样的类希望我们可以访问它的contents成员，<strong>最好定义一个函数</strong>，<strong>令其返回值是指向该成员的指针</strong>：</p>
<p>一如往常，<strong>pdata指向Screen类的成员而非实际数据</strong>。<strong>要想使用pdata,必须把它绑定到Screen类型的对象上</strong>：<br>
//获得myScreen对象的contents成员<br>
<code>auto S = myScreen.*pdata;</code><br>
<strong>（直接解引用就会绑定到特定的对象上）</strong></p>
<p>习题19.11<br>
普通的数据指针一定是指向一个对象的，但是指向数据成员的指针只会指向一个成员类型而非实际数据，需要绑定到特定类型的对象上才能调用。<br>
知识点8：成员指针是指可以指向类的非静态成员的指针，由于类的静态成员不属于任何对象，所以无需特殊的指向该成员的指针，成员指针的类型需要包括类的类型和成员的类型<br>
知识点9：在给成员指针赋值时，我们将取址运算符作用域screen的成员而不是内存中的一个类的对象的成员<br>
知识点10：我们需要注意，当我们初始化一个成员指针或为成员指针赋值时，该指针并没有指向任何数据，成员指针只指定了成员而非该成员所属的对象，只有解引用成员指针时我们才提供对象的信息<br>
知识点11：成员指针的访问运算符：.*或者-&gt;*，可以获得对象的指定成员<br>
习题19.12</p>
<pre><code>const string::size_type Screen::* p;

static cosnt pos Screen::*data() { 
        return &amp;Screen::cursor;  
    }
</code></pre>
<p>习题19.13<br>
<code>const string Sales_data::*</code></p>
<p>19.4.2 成员函数指针<br>
我们也可以<strong>定义指向类的成员函数的指针</strong>。与指向数据成员的指针类似，对于我们来<br>
说要想创建一个指向成员函数的指针，最简单的方法是使用auto来推断类型</p>
<p>和指向数据成员的指针一样，我们使用<strong>classname::*</strong> 的形式<strong>声明</strong>一个指向成员函数的指针。类似于任何其他函数指针（参见6.7节，第221页），<strong>指向成员函数的指针</strong>也需要<strong>指定目标函数</strong>的<strong>返回类型</strong>和<strong>形参列表</strong>。如果成员函数是const成员（参见7.1.2节，第231页）或者引用成员（参见13.6.3节，第483页)，则我们必须将const限定符或引用限定符包含进来。<br>
和普通的函数指针类似，如果成员存在<strong>重载的问题</strong>，则我们<strong>必须显式地声明函数类型</strong>以<strong>明确指出我们想要使用的是哪个函数</strong><br>
<strong>char (Screen::*pmf2)(Screen::pos,Screen::pos)const;</strong><br>
pmf2 = &amp;Screen::get;<br>
出于优先级的考虑，上述声明中<strong>screen::*两端的括号必不可少</strong>。如果没有这对括号的话，编译器将<strong>认为该声明是一个（无效的）函数声明</strong>：<br>
和<strong>普通函数指针</strong>不同的是，在<strong>成员函数</strong>和<strong>指向该成员的指针</strong>之间<strong>不存在自动转换规则</strong>：</p>
<p>使用成员函数指针<br>
和使用指向数据成员的指针一样，我们使用 <strong>.*或者-&gt;*运算符</strong>作用于指向成员函数的指针，以调用类的成员函数：</p>
<p>使用成员指针的类型别名<br>
使用<strong>类型别名或typedef</strong>(参见2.5.1节，第60页）可以让成员指针<strong>更容易理解</strong>。<br>
和其他函数指针类似，我们可将<strong>指向成员函数的指针</strong>作为<strong>某个函数</strong>的<strong>返回类型</strong>或<strong>形参类型</strong>。其中，指向成员的<strong>指针形参也可以拥有默认实参</strong>：<br>
<strong>using Action = char(Screen::*)(Screen::pos) const;</strong><br>
通过使用类型别名，可以令含有成员指针的代码更易读写。</p>
<p>对于普通函数指针和指向成员函数的指针来说，一种常见的用法是<strong>将其存入一个函数 表当中</strong>（参见14.8.3节，第511页）。如果一个类含有几个相同类型的成员，则这样一张 表可以帮助我们从这些成员中选择一个。<br>
<strong>函数表：存储指向可调用对象的“指针”，一般通过map实现</strong></p>
<p>习题19.14<br>
如果两者函数类型一致就合法，不一致就不合法<br>
习题19.15<br>
<strong>在成员函数和指向该成员的指针之间不存在自动转换的规则（必须使用&amp;符号，显示的取地址）</strong><br>
知识点8：成员指针是指可以指向类的非静态成员的指针，由于类的静态成员不属于任何对象，所以无需特殊的指向该成员的指针，成员指针的类型需要包括类的类型和成员的类型<br>
知识点9：在给成员指针赋值时，我们将取址运算符作用域screen的成员而不是内存中的一个类的对象的成员<br>
知识点10：我们需要注意，当我们初始化一个成员指针或为成员指针赋值时，该指针并没有指向任何数据，成员指针只指定了成员而非该成员所属的对象，只有解引用成员指针时我们才提供对象的信息<br>
知识点11：成员指针的访问运算符：.*或者-&gt;*，可以获得对象的指定成员<br>
习题19.16<br>
<code>typedef avg double （Sales_data::*）()const;</code><br>
习题19.17</p>
<pre><code>char get() const { return contents[cursor]; }//using Action_c_v = char (Screen::*)()const;  
char get_cursor() const { return contents[cursor]; }//同上  
inline char get(pos ht, pos wd) const;//using Action_c_uu = char (Screen::*)(pos,pos)const;  
Screen &amp;move(pos r, pos c);//using Action_Screen_uu = Screen &amp;(Screen::*)(pos,pos); 
</code></pre>
<p>19.4.3 将成员函数用作可调用对象<br>
如我们所知，要想通过一个指向成员函数的指针进行函数调用，<strong>必须</strong>首先<strong>利用.*运算符或-&gt;*运算符</strong>将该指针<strong>绑定到特定的对象上</strong>。因此<strong>与普通的函数指针不同</strong>，<strong>成员指针不是一个可调用对象</strong>，这样的指针<strong>不支持函数调用运算符</strong>（参见10.3.2节，第346页）。<br>
因为成员指针不是可调用对象，所以我们<strong>不能直接将一个指向成员函数的指针传递给算法。</strong></p>
<p>使用function生成一个可调用对象<br>
<strong>从指向成员函数的指针获取可调用对象</strong>的一种方法是<strong>使用标准库模板function</strong><br>
当一个function对象包含有一个指向成员函数的指针时，<strong>function类知道它必须使用正确的指向成员的指针运算符来执行函数调用</strong>。也就是说我们可以认为在find_if当中含有类似于如下形式的代码：</p>
<p>当我们<strong>定义一个function对象</strong>时，必须指定该对象所能表示的函数类型，即可调用对象的形式。如果可调用对象是一个成员函数，则<strong>第一个形参</strong>必须<strong>表示该成员是在哪个(一般是隐式的）对象上执行</strong>的。同时我们提供给function的形式中还<strong>必须指明对象是否以指针或引用的形式传入的</strong>。</p>
<p>使用mem_fn生成一个可调用对象<br>
通过使用标准库功能<strong>mem_fn</strong>来让编译器负责<strong>推断成员的类型</strong>。和function一样，mem_fn也定义在<strong>functional头文件中</strong>，并且可以从成员指针生成一个可调用对象；和function不同的是，mem_fn可以根据<strong>成员指针的类型</strong>推断<strong>可调用对象的类型</strong>，而无须用户显式地指定（<strong>引用或者指针</strong>）：</p>
<p>使用bind生成一个可调用对象<br>
出于完整性的考虑，我们还可以<strong>使用bind</strong>(参见10.3.4节，第354页）从成员函数生成一个可调用对象：</p>
<p>和function类似的地方是，当我们使用bind时，<strong>必须将函数中用于表示执行对象的隐式形参转换成显式的</strong>。和mem_fn类似的地方是，bind生成的可调用对象的<strong>第一个实参</strong>既可以是string的<strong>指针</strong>，也可以是string的<strong>引用</strong>：</p>
<p>习题19.18</p>
<pre><code>class vector{
public:
	bool if_empty(vector&lt;string&gt;::iterator i){
			if((*i).empty())
					return true;
			return false;
}
}

vector&lt;string&gt; vs;
functional&lt;bool(const string&amp;)&gt; ifem=&amp;vector::if_empty;//注意是functional中是&lt;bool(const string&amp;)&gt;而不是&lt;bool(vector&lt;string&gt;::iterator)&gt; ，用于指明对象是否以指针或引用的形式传入
count_if(vs,begin,vs.end,ifem)
count_if(vs,begin,vs.end,men_fn(&amp;vector::if_empty))
count_if(vs,begin,vs.end,bind(&amp;vector::if_empty,_1))
</code></pre>
<p>注意是functional中是<code>&lt;bool(const string&amp;)&gt;</code>而不是<code>&lt;bool(vector&lt;string&gt;::iterator)&gt;</code>，用于指明对象是否以指针<code>（&lt;bool(const string*)&gt;）</code>或引用的形式传入<br>
习题19.19<br>
使用find_first_of就行</p>
<p>19.5 嵌套类<br>
<strong>一个类</strong>可以<strong>定义</strong>在<strong>另一个类的内部</strong>，前者称为嵌套类（nested class)或嵌套类型（nested type)。<strong>嵌套类</strong>常用于<strong>定义作为实现部分的类</strong>，<br>
嵌套类是一个<strong>独立的类</strong>，<strong>与外层类基本没什么关系</strong>。特别是，外层类的对象和嵌套类的<strong>对象是相互独立的</strong>。在嵌套类的对象中不包含任何外层类定义的成员，类似的，在外层类的对象中也不包含任何嵌套类定义的成员。<br>
<strong>嵌套类的名字在外层类作用域中是可见的</strong>，在<strong>外层类作用域之外不可见</strong>。和其他嵌套的名字一样，嵌査类的名字不会和别的作用域中的同一个名字冲突。</p>
<p>声明一个嵌套类</p>
<p>在外层类之外定义一个嵌套类<br>
我们在TextQuery内声明了Query Result,但是没有给出它的定义。和成员函数一样，嵌套类必须<strong>声明在类的内部</strong>，但是可<strong>定义在类的内部或者外部</strong>。</p>
<p>定义嵌套类的成员<br>
在这个版本的QueryResult类中，我们并没有在类的内部<strong>定义其构造函数</strong>。要想为其定义构造函数，必须指明如QueryResult是嵌套在TextQuery的作用域之内的。具体做法是使<strong>用外层类的名字限定嵌套类的名字</strong>；</p>
<p>嵌套类的静态成员定义<br>
<strong>静态成员的定义必须为于类之外，因为静态成语属于类，而不属于某个对象，如果在类内定义，则每个对象定义时也会重新定义一次，不符合静态成员的要求</strong><br>
如果QueryResult<strong>声明了一个静态成员</strong>，则该成员的<strong>定义</strong>将位于TextQuery的<strong>作用域之外</strong></p>
<p>嵌套类作用域中的名字查找<br>
名字查找的一般规则（参见7.4.1节，第254页）在嵌套类中同样适用。当然，因为嵌套类本身是一个嵌套作用域，所以<strong>还必须查找嵌套类的外层作用域</strong>。这种作用域嵌套的性质正好可以说明为什么我们不在QueryResult的嵌套版本中定义line_no.<br>
如我们所知，嵌套类是其外层类的一个类型成员，因此<strong>外层类的成员</strong>可以像<strong>使用任何其他类型成员一样使用嵌套类的名字</strong>。</p>
<p>和过去一样，<strong>返回类型不在类的作用域中</strong>（参见7.4节，第253页）因此我们<strong>必须指明函数的返回值是TextQuery::QueryResult类型</strong>。不过在函数体内部我们可以直接访问QueryResult，比如上面的return语句就是这样。</p>
<p>嵌套类和外层类是相互独立的<br>
尽管嵌套类定义在其外层类的作用域中，但是读者必须谨记<strong>外层类的对象和嵌套类的对象没有任何关系</strong>。嵌套类的<strong>对象只包含嵌套类定义的成员</strong>：同样，外层类的<strong>对象只包含外层类定义的成员</strong>，在外层类对象中不会有任何嵌套类的成员。</p>
<p>习题19.20<br>
嵌套之后记得要在QueryResult的定义中加上TextQuery::</p>
<p>19.6 union:<strong>一种节省空间的类</strong><br>
联合（union)是一种特殊的类。一个union可以有多个数据成员，但是<strong>在任意时刻只有一个数据成员可以有值</strong>。当我们<strong>给union的某个成员赋值</strong>之后，该union的<strong>其他成员就变成未定义的状态</strong>了。分配给一个union对象的<strong>存储空间</strong>至少要<strong>能容纳它的最大的数据成员</strong>。和<strong>其他类一样</strong>，<strong>一个union定义了一种新类型</strong>。<br>
union<strong>不能含有引用类型的成员</strong><br>
<strong>含有构造函数 或析构函数的类类型</strong>也可以作为union的<strong>成员类型</strong>。union可以为其成员<strong>指定public、 protected和private等保护标记</strong>。默认情况下，<strong>union的成员都是公有的</strong>，这一点<strong>与struct相同</strong>。<br>
<strong>union可以定义</strong>包括构造函数和析构函数在内的<strong>成员函数</strong>。但是由于union<strong>既不能继承自其他类</strong>，<strong>也不能作为基类使用</strong>，所以<strong>在union中不能含有虚函数</strong>。</p>
<p>定义union<br>
union提供了一种有效的途径使得我们可以<strong>方便地表示一组类型不同的互斥值</strong>。</p>
<p>使用union类型<br>
union的名字是一个<strong>类型名</strong>。和其他内置类型一样，<strong>默认情况下union是未初始化的</strong>。我们可以像显式地初始化聚合类（参见7.5.5节，第266页）一样使用一对<strong>花括号</strong>内的<strong>初始值</strong>显式地<strong>初始化一个union</strong>：</p>
<p>我们使用通用的<strong>成员访问运算符（. 或者 -&gt;）</strong> 访问一个union对象的成员：<br>
last_token.cval = ‘z’;<br>
pt-&gt;ival = 42;<br>
为union的<strong>一个数据成员赋值</strong>会令<strong>其他数据成员变成未定义</strong>的状态。因此，当我们使用 union时，<strong>必须淸楚地知道当前存储在union中的值到底是什么类型</strong></p>
<p>匿名union<br>
<strong>匿名union</strong>(anonymous union)是一个<strong>未命名的union</strong>,并且在<strong>右花括号和分号之间没有任何声明</strong>（参见2.6.1节，第65页）。一旦我们<strong>定义了一个匿名union</strong>，编译器就<strong>自动地为该union创建一个未命名的对象</strong><br>
在匿名union的定义<strong>所在的作用域</strong>内该union的<strong>成员都是可以直接访问的</strong>。<br>
匿名union不<strong>能包含受保护的成员</strong>或<strong>私有成员</strong>，<strong>也不能定义成员函数</strong>。</p>
<p>含有类类型的union<br>
如果union的成员类型<strong>定义了自己</strong>的<strong>构造函数</strong>和/或<strong>拷贝控制成员</strong>，则该union的用法要比只含有内置类型成员的union<strong>复杂得多</strong>。</p>
<p><strong>例如string</strong><br>
使用类管理union成员<br>
对于union来说，要想构造或销毁类类型的成员必须执行非常复杂的操作，因此我们通常把<strong>含有类类型成员的union内嵌在另一个类当中</strong>。<strong>这个类</strong>可以<strong>管理并控制</strong>与<strong>union的类类型成员有关的状态转换</strong>。<br>
为了<strong>追踪union中</strong>到底<strong>存储了什么类型</strong>的值，我们通常会<strong>定义一个独立的对象</strong>，该对象称为<strong>union的判别式</strong>（discriminant)。我们可以使用判别式辨认union存储的值。为了保持union-与其判别式同步，我们将判别式也作为Token的成员。我们的类将定义一个<strong>枚举类型</strong>（参见19.3节，第736页）的成员来追踪其union成员的状态。<br>
<strong>string不是内置类型，所以要有自己的析构函数</strong></p>
<p>管理判别式并销毁string</p>
<p>管理需要拷贝控制的联合成员<br>
和依赖于类型的赋值运算符一样，<strong>拷贝构造函数</strong>和<strong>赋值运算符</strong>也需要<strong>先检验判别式</strong>以 <strong>明确拷贝所采用的方式</strong></p>
<p>赋值运算符必须处理string成员的三种可能情况：左侧运算对象和右侧运算对象都是string、两个运算对象都不是string、只有一个运算对象是string：</p>
<p>习题19.21</p>
<pre><code>class Token {
public:
	Token() :tok(INT), ival(0) {}
	Token(const Token &amp;t) :tok(t.tok) { copyUnion(t); }
	Token &amp;operator=(const Token&amp;);
	~Token() { if (tok == STR) sval.~string(); }
	Token &amp;operator=(const std::string&amp;);
	Token &amp;operator=(char);
	Token &amp;operator=(int);
	Token &amp;operator=(double);

private:
	enum {INT,CHAR,DBL,STR} tok;
	union {
		char cval;
		int ival;
		double dval;
		std::string sval;
	};
	void copyUnion(const Token&amp;);
};

Token &amp;Token::operator=(int i) {
	if (tok == STR)
		sval.~string();
	ival = i;
	tok = INT;
	return *this;
}

Token &amp;Token::operator=(const std::string &amp;s) {
	if (tok == STR) 
		sval=s;
	else 
		new(&amp;sval) std::string(s);
	tok = STR;
	return *this;
}

void Token::copyUnion(const Token &amp;t) {
	switch (t.tok)
	{
	case Token::INT: ival = t.ival; break;
	case Token::CHAR: cval = t.ival; break;
	case Token::DBL: dval = t.ival; break;
	case Token::STR: new(&amp;sval) std::string(t.sval);
	default:
		break;
	}
}

Token &amp;Token::operator=(const Token &amp;t) {
	if (tok == STR&amp;&amp;t.tok != STR) sval.~string();
	if (tok == STR&amp;&amp;t.tok == STR)
		sval = t.sval;
	else
		copyUnion(t);
	tok = t.tok;
	return *this;
}
</code></pre>
<p>习题感悟：<br>
注意是functional中是<code>&lt;bool(const string&amp;)&gt;</code>而不是<code>&lt;bool(vector&lt;string&gt;::iterator)&gt;</code>，用于指明对象是否以指针<code>（&lt;bool(const string*)&gt;）</code>或引用的形式传入</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 173. 二叉搜索树迭代器[中等]]]></title>
        <id>https://lixin-ee.github.io//post/shu-173-er-cha-sou-suo-shu-die-dai-qi-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/shu-173-er-cha-sou-suo-shu-die-dai-qi-zhong-deng">
        </link>
        <updated>2019-11-29T01:39:23.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。<br>
调用 next() 将返回二叉搜索树中的下一个最小的数。<br>
示例：<br>
<img src="https://lixin-ee.github.io//post-images/1574991600961.png" alt=""><br>
BSTIterator iterator = new BSTIterator(root);<br>
iterator.next();    // 返回 3<br>
iterator.next();    // 返回 7<br>
iterator.hasNext(); // 返回 true<br>
iterator.next();    // 返回 9<br>
iterator.hasNext(); // 返回 true<br>
iterator.next();    // 返回 15<br>
iterator.hasNext(); // 返回 true<br>
iterator.next();    // 返回 20<br>
iterator.hasNext(); // 返回 false<br>
提示：<br>
next() 和 hasNext() 操作的时间复杂度是 O(1)，并使用 O(h) 内存，其中 h 是树的高度。<br>
你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 中至少存在一个下一个最小的数。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/binary-search-tree-iterator<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>一开始不是很明白题目的意思，我第一想法还是二叉搜索树的中序遍历的结果就是顺序数组</p>
<pre><code>class BSTIterator {
public:
    vector&lt;int&gt; res;
    vector&lt;int&gt;::iterator cur_i;
    BSTIterator(TreeNode* root) {
        inorder(root);
        cur_i=res.begin();
    }
    void inorder(TreeNode* cur){
        if(cur==NULL)
            return;
        inorder(cur-&gt;left);
        res.push_back(cur-&gt;val);
        inorder(cur-&gt;right);
        return;    
    }
    /** @return the next smallest number */
    int next() {
        return *(cur_i++);
    }
    
    /** @return whether we have a next smallest number */
    bool hasNext() {
        if(cur_i==res.end())
            return false;
        return true;
    }
};
</code></pre>
<p>但是这个解法是很有问题的，因为不符合空间复杂度o(h)</p>
<p>然后网友的题解比较好，就是使用栈来模仿中序遍历，中序遍历的思想就是1先不断地往左子树走 2.遇到最左后就看看有没有右子树 3.检测该右子树的左子树，重复1和2.<br>
然后在初始化中先执行一次1，将最左边的左子树入栈，然后next中先pop出栈的栈顶值，然后循环执行2和1，然后返回当前结点值。 hasnext最简单，直接判断栈是否为空就ok了</p>
<p>看看网友题解：</p>
<blockquote>
<p>做这道题， 先把树的中序遍历的迭代写法了解一下<br>
94. 二叉树的中序遍历 | 题解链接<br>
对，这道题就是用栈解决，模拟中序遍历过程！<br>
使用栈模拟的过程是很清晰的，通过next()在栈中缓存当前左子树的节点，空间复杂度为O(h)。</p>
</blockquote>
<pre><code>from collections import deque
class BSTIterator:

    def __init__(self, root: TreeNode):
        self.head = root
        self.stack = deque()
        
        while root:
            self.stack.append(root)
            root = root.left

    def next(self) -&gt; int:
        &quot;&quot;&quot;
        @return the next smallest number
        &quot;&quot;&quot;       

        cur = self.stack.pop()
        root = cur.right
        while root:   # 使用了循环，复杂度不应该为O(1)?
            self.stack.append(root)
            root = root.left
        
        return cur.val


    def hasNext(self) -&gt; bool:
        &quot;&quot;&quot;
        @return whether we have a next smallest number
        &quot;&quot;&quot;
        return len(self.stack) &gt; 0
</code></pre>
<blockquote>
<p>但是很多小伙伴会对next()中的循环操作的复杂度感到疑惑，认为既然加入了循环在里面，那时间复杂度肯定是大于O(1)不满足题目要求的。<br>
仔细分析一下，该循环只有在节点有右子树的时候才需要进行，也就是不是每一次操作都需要循环的，循环的次数加上初始化的循环总共会有O(n)次操作，均摊到每一次next()的话平均时间复杂度则是O(n)/n=O(1)，因此可以确定该实现方式满足O(1)的要求。<br>
这种分析方式称为摊还分析，详细的学习可以看看**《算法导论》- 第17章 摊还分析**</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ C++ primer 第十八章 笔记+习题 19.1-19.2]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-ba-zhang-bi-ji-xi-ti-191-192</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-ba-zhang-bi-ji-xi-ti-191-192">
        </link>
        <updated>2019-11-28T13:21:24.000Z</updated>
        <content type="html"><![CDATA[<p>19.1 控制内存分配<br>
19.1.1 重载new和delete<br>
当我们使用一条<strong>new表达式</strong>时：<br>
<strong>实际执行了三步操作</strong>。第一步，new表达式调用一个名为<strong>operator new（或者operator new[ ]）</strong> 的<strong>标准库函数</strong>。该函数分配一块足够大、原始的、未命名的内存空间以便存储特定类型的对象（或者对象的数据）。第二部，编译器运行<strong>相应的构造函数</strong>以构造这些对象，并为其传入<strong>初始值</strong>。第三步，对象被分配了空间并构造完成，<strong>返回</strong>一个指向该对象的<strong>指针</strong>。</p>
<p>当我们使用一条<strong>delete表达式</strong>删除一个动态分配的对象时：<br>
<strong>实际执行了两步操作</strong>，第一步，对sp所指的对象或者arr所指的数组中的元素执行对应的<strong>析构函数</strong>。第二步，编译器调用名为<strong>operator delete（或者operator delete[]）</strong> 的标准库<strong>函数释放内存空间</strong>。<br>
如果应用程序<strong>希望控制内存分配</strong>的过程，则它们需要<strong>定义自己的operator new函数和operator delete函数</strong>。即使在标准库中已经存在这两个函数的定义，我们仍旧可以定义自己的版本。编译器不会对这种重复的定义提出异议，相反，<strong>编译器将使用</strong>我们<strong>自定义的版本</strong>替换标准库定义的版本<br>
当<strong>自定义了全局</strong>的 operator new 函数和 operator delete 函数后，我们就<strong>担负起了控制动态内存分配的职责</strong>。这两个函数必须是正确的；因为它们是程序整个处理过程中至关重要的一部分。<br>
应用程序<strong>可以在全局作用域</strong>中定义 operator new 函数和 operator delete 函数，也可将它们<strong>定义为成员函数</strong>。当编译器发现一条 <strong>new 表达式</strong>或 <strong>delete 表达式</strong>后，将在程序中<strong>查找可供调用的 operator 函数</strong>。<br>
如果<strong>被分配（释放）的对象是类类型</strong>，则编译器<strong>首先在类及其基类的作用域中查找</strong>。此时如果该类含有 operator new 成员或operator delete 成员，则相应的表达式将调用这些成员。<strong>否则，编译器在全局作用域查找匹配的函数</strong>。此时如果编译器找到了用户自定义的版本，则使用该版本执行 new 表达式或 delete 表达式；如果<strong>没找到，则使用标准库定定义的版本。</strong>		<br>
我们可以使用<strong>作用域运算符</strong>令 new 表达式或 delete 表达式忽略定义在类中的函数，<br>
直接执行全局作用域中的版本。 <strong>::new 或 ::delete</strong></p>
<p>operator new接口和operator delete接口<br>
<strong>标准库</strong>定义了 operator new 函数和 operator delete 函数的<strong>8个重载版本</strong>。其中<strong>前4个</strong>版本<strong>可能抛出 bad _ alloc 异常，后4个版本则不会抛出异常</strong><br>
类型 <strong>nothrow _ t</strong> 是定义在<strong>new 头文件中的一个 struct</strong> ,在这个类型中<strong>不包含任何成员</strong>。new 头文件还定义了一个名为 <strong>nothrow 的 const 对象</strong>，用户可以通过这个对象请求 new的非抛出版本<br>
应用程序可以自定义上面函数版本中的任意一个，前提是<strong>自定义的版本必须位于全局作用域或者类作用域中</strong>。当我们将上述运算符函数定义成<strong>类的成员</strong>时，它们是<strong>隐式静态（static）</strong> 的<br>
我们无须显式地声明 static ,当然这么做也不会引发错误。<strong>因为 operatornew 用在对象构造之前</strong>而 <strong>operatordelete 用在对象销毁之后</strong>，所这两个成员（ new 和 delete )必须是静态的，而且它们<strong>不能操纵类的任何数据成员</strong>。<br>
对于operator new函数或者operator new[ ]函数来说，它的<strong>返回类型必须是void</strong>*,第一个形参的类型必须是size_t并且该形参<strong>不能含有默认实参</strong>。<br>
当编译器调用 operator new 时，把<strong>存储指定类型对象所需的字节数</strong>传给 size_t 形参；当调用 operator new []时，传入函数的则是<strong>存储数组中所有元素所需的空间</strong>。如果我们想自定义operator new函数，则可以为它提供额外参数<br>
但是<strong>下面这个函数</strong>却<strong>无论如何不能被用户重载</strong>：<br>
<em><em>void</em> operator new(size_t,void</em> );  //不允许重新定义这个版本**<br>
这种形式<strong>只供标准库使用</strong>，<strong>不能被用户重新定义</strong>。<br>
对于 operator delete 函数或者 operator delete []函数来说，它们的<strong>返回类型必须是 void</strong> ,第一个形参的类型必须是 void * 。执行一条 delete 表达式将调用相应的 operator 函数，并用<strong>指向待释放内存的指针来初始化 void * 形参</strong>。<br>
当我们将 operator delete 或 operator delete []<strong>定义成类的成员</strong>时，该函数<strong>可以包含另外一个类型为 size _ t 的形参</strong>。此时，该形参的初始值是第一个形参<strong>所指对象的字节数</strong>。<strong>size _ t形参可用于删除继承体系中的对象</strong>。如果基类有一个虚析构函数（参见15.7.1节，第552页），则传递给 operator delete 的<strong>字节数</strong>将<strong>因待删除指针所指对象的动态类型不同而有所区别</strong>。而且，实际运行的<strong>operator delete 函数版本</strong>也由<strong>对象的动态类型决定</strong>。<br>
和其他operator 函数不同（比如 operator=），这两个函数（operator new和operator delete）并没有重载 new 表达式或 delete表达式。实际上，我们根本无法自定义 new 表达式或 delete 表达式的行为。<br>
我们提供新的 operator new 函数和 operator delete 函数的<strong>目的在于改变内存分配的方式</strong>.但是不管怎样，我们<strong>都不能改变 new 运算符和 delete 运算符的基本含义</strong>。</p>
<p>当你定义了自己的全局 operator new 和 operator delete 后，这两个函数<strong>必须以某种方式执行分配内存与释放内存的操作</strong>。也许你的初衷仅仅是使用一个特殊定制的內存分配器，但是这两个函数还应该同时满足某些测试的目的，即<strong>检验其分配内存的方式是否与常规方式类似</strong>。<br>
为此，我们可以使用名为<strong>malloc 和 free</strong> 的函数， C++ 从 C 语言中继承了这些函数，并将其定义在 <strong>cstdlib 头文件</strong>中。<br>
<strong>malloc 函数</strong>接受一个表示<strong>待分配字节数的 size _ t</strong> ,<strong>返回</strong>指向<strong>分配空间的指针</strong>或者返回<strong>0表示分配失败</strong>。<strong>free 函数</strong>接受一个 <strong>void*</strong> , 它 是 malloc 返回的指针的副本，free 将相关<strong>内存返回给系统</strong>。<strong>调用 free (0)没有任何意义</strong>。</p>
<p>习题19.1+19.2</p>
<pre><code>void* operator new(size_t size) {
	if (void *mem = malloc(size))
		return mem;
	else
		throw bad_alloc();
}

void operator delete(void *mem) noexcept {
	free(mem);
}
</code></pre>
<p>19.1.2 定位new表达式<br>
尽管operator new函数和operator delete函数一般用于new表达式，然而它们毕竟是标准库的两个普通函数，因此<strong>普通的代码也可以直接调用</strong>它们。<br>
在C++的早期版本中，allocator类（参见12.2.2节，第427页）还不是标准库的一部分。应用程序如果想把内存分配与初始化分离开来的话，需要调用operator new和operator delete。这两个函数的行为与allocator的allocate成员和deallocate成员非常类似，它们负责分配或释放内存空间，但是不会构造或销毁对象。<br>
<strong>与allocator不同</strong>的是，对于<strong>operator new分配的内存空间</strong>来说我们<strong>无法使用construct函数构造对象</strong>。相反，我们<strong>应该使用new的定位new</strong>(placement new)形式(参见12.1.2节，第409页）<strong>构造对象</strong>。如我们所知，new的这种形式为<strong>分配函数提供了额外的信息</strong>。我们<strong>可以使用定位new传递一个地址</strong>，此时定位new的形式如下所示：</p>
<p>其中<strong>place_address必须是一个指针</strong>，同时在<strong>initializers</strong>中提供一个（可能为空的）以逗号分隔的<strong>初始值列表</strong>，该初始值列表将<strong>用于构造新分配的对象</strong>。<br>
当<strong>仅通过一个地址值调用</strong>时，定位new使用<strong>operator new(size_t,void*)&quot;分配&quot;它的内存</strong>。这是一个我们<strong>无法自定义的operator new版本</strong>（参见19.1.1节，第727页）。该函数<strong>不分配任何内存</strong>，它只是<strong>简单地返回指针实参</strong>；<strong>然后由new表达式负责</strong>在<strong>指定的地址初始化对象</strong>以完成整个工作。事实上，定位new允许我们在一个<strong>特定的、预先分配的内存地址上构造对象</strong>。<br>
尽管在很多时候使用<strong>定位new</strong>与<strong>allocator的construct</strong>成员<strong>非常相似</strong>，但在它们之间也有一个<strong>重要的区别</strong>。我们<strong>传给construct的指针</strong>必须<strong>指向同一个allocator对象分配的空间</strong>，但是<strong>传给定位new的指针无须指向operator new分配的内存</strong>。实际上如我们将在19.6节（第753页）介绍的，传给定位new表达式的指针<strong>甚至不需要指向动态内存</strong>。</p>
<p>显示的析构函数调用<br>
<strong>对析构函数的显式调用</strong>也与<strong>使用destroy很类似</strong>。我们<strong>既可以通过对象调用</strong>析构函数，<strong>也可以通过对象的指针或引用调用</strong>析构函数，这与调用其他成员函数没什么区别</p>
<pre><code>string *sp = new string(&quot;avalue&quot;);		//分配并初始化一个string对象 
sp-&gt;~string(); //等于(*sp).~string()
</code></pre>
<p>和<strong>调用destroy类似</strong>，调用析构函数可以<strong>清除给定的对象</strong>但是<strong>不会释放该对象所在的空间</strong>。如果需要的话，我们<strong>可以重新使用该空间</strong>。<br>
<strong>调用析构函数会销毁对象，但是不会释放内存</strong>。</p>
<p>19.2 运行时类型识别<br>
<strong>运行时类型识别</strong>（run-time type identification,RTTI)的功能由两个运算符实现：<br>
• <strong>typeid运算符</strong>，用于<strong>返回表达式的类型</strong>。<br>
• <strong>dynamic_cast运算符</strong>，用于将<strong>基类的指针或引用</strong>安全地<strong>转换成派生类的指针或引用</strong>。</p>
<p>这两个运算符特别适用于以下情况：我们想<strong>使用基类对象的指针或引用执行某个派生 类操作</strong>并且<strong>该操作不是虚函数</strong>。一般来说，只要有可能我们<strong>应该尽量使用虚函数</strong>。当操作被定义成虚函数时，<strong>编译器</strong>将根据对象的<strong>动态类型自动地选择</strong>正确的函数版本。<br>
然而，<strong>并非任何时候都能定义一个虚函数。</strong> 假设我们<strong>无法使用虚函数</strong>，则可以使用一个<strong>RTTI运算符</strong>。另一方面，与虚成员函数相比，使用RTTI运算符<strong>蕴含着更多潜在的风险</strong>：<strong>程序员必须清楚地知道</strong>转换的目标类型并且必须检查类型转换是否被成功执行。<br>
<strong>使用RTTI必须要加倍小心</strong>。在可能的情况下，最好定义虚函数而非直接接管类型管理的重任。</p>
<p>19.2.1 dynamic_cast运算符</p>
<p>其中，<strong>type必须是一个类类型</strong>，并且通常情况下<strong>该类型应该含有虚函数</strong>。在<strong>第一种形式</strong>中，e必须是一个<strong>有效的指针</strong>（参见2.3.2节，第47页）；在<strong>第二种形式</strong>中，e必须是一个<strong>左值</strong>；在<strong>第三种形式中</strong>，<strong>e不能是左值</strong>。<br>
在上面的所有形式中，e的类型<strong>必须符合以下三个条件中的任意一个</strong>：<br>
1.e的类型是目标type的<strong>公有派生类</strong>、<br>
2.e的类型是目标化type的公有基类或者<br>
3.e的类型就是目标type的<strong>类型</strong>。<br>
如果符合，则类型转换可以成功。否则，转换失败。如果一条dynamic_cast语句的转换目标是<strong>指针类型并且失败了</strong>，<strong>则结果为0</strong>。如果<strong>转换目标是引用类型并且失败了</strong>，则dynamic_cast运算符将<strong>抛出一个bad_cast异常</strong>。（公有是什么意思）<br>
<strong>注意！符合上面三个条件不等于就能转换成功，程序不会报错但是会转换失败</strong></p>
<p>指针类型的dynamic_cast</p>
<p>我们可以<strong>对一个空针执行dynamic_cast</strong>,结果是<strong>所需类型的空指针</strong>。<br>
值得注意的一点是，我们在<strong>条件部分定义了dp</strong>,这样做的好处是可以<strong>在一个操作中同时</strong>完成<strong>类型转换</strong>和<strong>条件检查</strong>两项任务。而且，<strong>指针dp</strong>在if语句<strong>外部是不可访问的</strong>。一旦转换失败，即使后续的代码忘了做相应判断，也不会接触到逐个未绑定的指针，从而确保程序是安全的。（<strong>if条件部分定义的变量只能在if内部使用，外部不可访问！</strong>）<br>
<strong>在条件部分执行dynamic_cast操作可以确保类型转换和结果检查在同一条表达式中完成。</strong><br>
引用类型的dynamic_cast<br>
引用类型的dynamic_cast与指针类型的dynamic_cast在表示错误发生的方式上略有不同。因为<strong>不存在所谓的空引用</strong>，所以对于引用类型来说无法使用与指针类型完全相同的错误报告策略。当对<strong>引用的类型转换失败</strong>时，程序<strong>抛出一个名为std::bad_cast的异常</strong>，该异常定义在<strong>typeinfo标准库头文件</strong>中。</p>
<p>习题19.3<br>
b失败，因为pb无法转化为pc<br>
习题19.4</p>
<pre><code>if(C &amp;pc=dynamic_cast&lt;C&amp;&gt;(pa)){
}else{
}
</code></pre>
<p><strong>注意！符合上面三个条件不等于就能转换成功，程序不会报错但是会转换失败</strong><br>
习题19.5<br>
前面有说到并非任何时候都能有虚函数，假设有一个基类的指针指向其派生类，派生类中有一个成员基类中没有，这时候想通过这个基类的指针来调用这个成员就是不可以的，此时可以用dynamic_cast</p>
<p>19.2.2 typeid运算符<br>
为RTTI提供的第二个运算符是<strong>typeid运算符</strong>（typeid operator)，它允许程序向表达式提问：<strong>你的对象是什么类型</strong>？<br>
typeid表达式的形式是<strong>typeid(e)</strong>.其中<strong>e</strong>可以是<strong>任意表达式或类型的名字</strong>。typeid操作的<strong>结果是一个常量对象的引用</strong>，<strong>该对象的类型</strong>是标准库类型<strong>type_info</strong>或者<strong>typeinfo的公有派生类型</strong>。typeinfo类<strong>定义在typeinfo头文件</strong>中<br>
typeid运算符可以<strong>作用于任意类型的表达式</strong>。和往常一样，<strong>顶层const</strong>(参见2.4.3节，第57页）<strong>被忽略</strong>，如果表达式是一个<strong>引用</strong>，则typeid返<strong>回该引用所引对象的类型</strong>。不过当typeid<strong>作用于数组或函数时</strong>，<strong>并不会执行向指针的标准类型转换</strong>（参见4.11.2节，第143页）。也就是说，如果我们对数组a执行typeid(a),则<strong>所得的结果是数组类型而非指针类型</strong>。<br>
当运算对象<strong>不属于类类型</strong>或者是一个<strong>不包含任何虚函数的类</strong>时，typeid运算符指示的是运算对象的<strong>静态类型</strong>。而当运算对象是<strong>定义了至少一个虚函数的类的左值</strong>时，typeid的结果<strong>直到运行时才会求得</strong>。</p>
<p>使用typeid运算符<br>
通常情况下，我们<strong>使用typeid比较</strong>两条表达式的<strong>类型是否相同</strong>，<strong>或者比较</strong>一条表达式的类型<strong>是否与指定类型相同</strong>：<br>
注意，<strong>typeid应该作用于对象</strong>，因此我们<strong>使用*bp而非bp:</strong><br>
当<strong>typeid作用于指针</strong>时（<strong>而非指针所指的对象</strong>），<strong>返回的结果</strong>是该<strong>指针的静态编译时类型</strong>。<br>
<strong>typeid是否需要运行时检查</strong>决定了<strong>表达式是否会被求值</strong>。<strong>只有当类型含有虚函数时</strong>，编译器<strong>才会对表达式求值</strong>。反之，如果类型不含有虚函数，则typeid返回表达式的静态类型；编译器无须对表达式求值也能知道表达式的静态类型。<br>
如果表达式的动态类型可能与静态类型不同，则必须在运行时对表达式求值以确定返 回的类型。这条规则<strong>适用于typeid(*p)的情况</strong>。</p>
<p>习题19.6</p>
<pre><code>int main() {
	Base b,*pb=&amp;b;
	D1 d,*pd=&amp;d;
	auto pd2 = dynamic_cast&lt;D1*&gt;(pb);
	if (typeid(*pd2) == typeid(*pd))
		cout &lt;&lt; &quot;finished&quot; &lt;&lt; endl;
	else
		cout &lt;&lt; &quot;wrong&quot; &lt;&lt; endl;
}
</code></pre>
<p>结果不相等 调用了abort<br>
注意不能漏掉 typeid(* pd)的 解引用符，否则就是比较指针的静态类型，肯定会相等</p>
<p>习题19.7</p>
<pre><code>	Base b,&amp;pb=b;
	D1 d,&amp;pd=d;
auto pd2 = dynamic_cast&lt;D1&amp;&gt;(pb);
</code></pre>
<p>习题19.8</p>
<pre><code> if (typeid(*pb1) == typeid(*pb2))  
        cout &lt;&lt; &quot;pd1与pd2指向的对象类型相同&quot; &lt;&lt; endl;  
    else  
        cout &lt;&lt; &quot;pd1与pd2的动态类型不相同&quot; &lt;&lt; endl;  
    if (typeid(*pb1) == typeid(AndQuery))  
        cout &lt;&lt; &quot;pd1的动态类型是AndQuery&quot; &lt;&lt; endl;  
    else  
        cout &lt;&lt; &quot;pd1的动态类型并非是AndQuery&quot; &lt;&lt; endl; 
</code></pre>
<p>19.2.3 使用RTTI<br>
在某些情况下RTTI非常有用，比如当我们想为<strong>具有继承关系的类实现相等运算符时</strong>参见14.3.1节，第497页）。对于两个对象来说，如果它们的类型相同并且对应的数据成员取值相同，则我们说送两个对象是相等的。在类的继承体系中，每个派生类负责添加自己的数据成员，因此<strong>派生类的相等运算符必须把派生类的新成员考虑进来</strong>。<br>
基于上述推论，我们就可以使用RTTI解决问题了。我们定义的相等运算符的形参是基类的引用，然后<strong>使用typeid检查</strong>两个运算对象的类型<strong>是否一致</strong>。如果运算对象的类型不一致，则==返回false；<strong>类型一致才调用equal函数</strong>。每个类定义的<strong>equal函数负责比较</strong>类型<strong>自己的成员</strong>。这些运算符接受Base&amp;形参，但是在进行比较操作前先把运算对象转换成运算符所属的类类型。</p>
<p>虚equal函数<br>
继承体系中的每个类<strong>必须定义自己的equal函数</strong>。派生类的<strong>所有函数要做的第一件事</strong>都是相同的，那就是将<strong>实参的类型转换为派生类类型</strong>；<br>
<strong>注意，类型相同后还是必须将实参转化为派生类类型！！！，否则静态类型还是基类类型</strong></p>
<p>19.2.4 type_info类<br>
<strong>typeid的结果是一个常量的引用，该常量的类型是type_info或者其公有派生类类型</strong><br>
<strong>type_info类的精确定义</strong>随着<strong>编译器的不同而略有差异</strong>。不过，C++标准规定type_info类<strong>必须定义在typeinfo头文件中</strong>，并且至少提供表19.1所列的操作。</p>
<p>除此之外，因为type_info类<strong>一般是作为一个基类出现</strong>，所以它还应该<strong>提供一个公有的虚析构函数</strong>。当编译器希望提供<strong>额外的类型信息</strong>时，通常在<strong>type_info的派生类中完成</strong>。<br>
<strong>type_info类没有默认构造函数</strong>，而且它的<strong>拷贝和移动构造函数</strong>以及<strong>赋值运算符</strong>都被<strong>定义</strong>成<strong>删除的</strong>（参化13.1.6节，第450页）。因此，我们<strong>无法定义或拷贝type_info类型的对象</strong>，也<strong>不能为type_info类型的对象赋值</strong>。<strong>创建type_info对象</strong>的<strong>唯一途径</strong>是使用<strong>typeid运算符</strong>。<br>
对于<strong>name返回值</strong>的<strong>唯一要求</strong>是，<strong>类型不同</strong>则<strong>返回的字符串必须有所区别</strong>。</p>
<p>习题19.9</p>
<pre><code>class Base { virtual void func() {}; };
class D1:public Base{ virtual void func() {}; };
class D2 :public D1 { virtual void func() {}; };
class D3 :public D1, public Base { virtual void func() {}; };
int main() {
	int arr[10];
	D1 d;
	Base *p = &amp;d;
	cout &lt;&lt; typeid(42).name() &lt;&lt; endl;
	cout &lt;&lt; typeid(arr).name() &lt;&lt; endl;
	cout &lt;&lt; typeid(string).name() &lt;&lt; endl;
	cout &lt;&lt; typeid(p).name() &lt;&lt; endl;
	cout &lt;&lt; typeid(*p).name() &lt;&lt; endl;
}
</code></pre>
<p>习题19.10<br>
（a）打印A*<br>
（b）应该是C的指针？ 正确答案 A的指针 A*<br>
（c）B的引用？ 正确答案 B本身（而不是引用）</p>
<pre><code>int main() {
	Base *b1 = new D2;
	D2 d1;
	Base &amp;b2 = d1;
	D1 *d2 = new D1;
	Base&amp; b3 = *d2;
	cout &lt;&lt; typeid(b1).name() &lt;&lt; endl;
	cout &lt;&lt; typeid(&amp;b2).name() &lt;&lt; endl;
	cout &lt;&lt; typeid(b3).name() &lt;&lt; endl;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ C++ primer 第十八章 笔记+习题 18.3]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-ba-zhang-bi-ji-xi-ti-183</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-ba-zhang-bi-ji-xi-ti-183">
        </link>
        <updated>2019-11-28T02:03:50.000Z</updated>
        <content type="html"><![CDATA[<p>18.3 多重继承与虚继承<br>
多重继承（multiple inheritance)是指从<strong>多个直接基类</strong>（参见15.2.2节，第533页）中产生派生类的能力。多重继承的派生类<strong>继承了所有父类的属性</strong>。</p>
<p>18.3.1 多重继承<br>
在派生类的派生列表中可以包含多个基类：<br>
class Bear : public ZooAnimal{<br>
class Panda : <strong>public Bear, public Endangered</strong><code>{/*...*/};</code><br>
每个基类包含一个可选的访问说明符（参见15.5节，第543页）。一如往常，如果访问说明符被忽略掉了，则关键字<strong>class</strong>对应的默认访问说明符是<strong>private</strong>,关键字<strong>struct</strong>对应的是<strong>public</strong>(参见15.5节，第546巧:）。     和只有一个基类的继承一样，多重继承的<strong>派生列表</strong>也只能包含<strong>已经被定义过的类</strong>，而且这些类<strong>不能final的</strong>（参见15.2.2节，第533页）。对于派生类能够继承的基类个数，C++没有进行特殊规定；但是在某个给定的派生列表中，<strong>同一个基类只能出现一次</strong>。<br>
多重继承的派生类从每个基类中继承状态<br>
在多重继承关系中，<strong>派生类的对象</strong>包含有<strong>每个基类的子对象</strong>（参见15.2.2节，第530页）。</p>
<p>派生类构造函数初始化所有基类<br>
构造函数<strong>从上而下构造</strong><br>
构造一个派生类的对象将<strong>同时构造并初始化</strong>它的<strong>所有基类子对象</strong>。与从一个基类进行的派生一样（参见15.2.2节，第531页），多重继承的派生类的构造函数初始值<strong>也只能初始化它的直接基类</strong>：	<br>
派生类的构造函数初始值列表将实参分别传递给每个直接基类。其中<strong>基类的构造顺序与派生列表中基类的出现顺序保持一致</strong>，而与<strong>派生类构造函数初始值列表中基类的顺序无关</strong>。<br>
继承的构造函数与多重继承<br>
在C++11新标准中，<strong>允许</strong>派生类从它的<strong>一个或几个基类中继承构造函数</strong>（参见15.7.4节，第557页）。但是如果从多个基类中<strong>继承了相同的构造函数</strong>（即<strong>形参列表完全相同</strong>），则程序<strong>将产生错误</strong>：     <strong>如果</strong>一个类从它的多个基类中<strong>继承了相同的构造函数</strong>，则这个类<strong>必须为该构造函数定义它自己的版本</strong>：</p>
<p>析构函数与多重继承<br>
和往常一样，派生类的析构函数只负责清除派生类本身分配的资源，<strong>派生类的成员及基类都是自动销毁的。合成的析构函数体为空</strong>。<br>
<strong>析构函数的调用顺序正好与构造函数相反（派生列表逆序）</strong></p>
<p>多重继承的派生类的拷贝与移动操作<br>
多重继承的派生类如果<strong>定义了自己的拷贝/赋值构造函数和赋值运算符</strong>，则<strong>必须在完整的对象上执行</strong>拷贝、移动或赋值操作<strong>指对基类也要拷贝等</strong>（参见15.7.2节，第553页）。<strong>只有</strong>当派生类使用的是<strong>合成版本</strong>的拷贝、移动或赋值成员时，<strong>才会自动对其基类部分执行</strong>这些操作。在<strong>合成的拷贝控制成员中</strong>，<strong>每个基类分别使用自己的对应</strong>成员<strong>隐式地完成</strong>构造、赋值或销毁等工作。</p>
<p>习题18.21<br>
（a）正确，没有关键词的话 class默认为private<br>
（b）错误，同一个基类不能出现两次<br>
（c）正确<br>
习题18.22<br>
A-B-C-X-Y-Z-MI<br>
不要忘了MI本身</p>
<p>18.3.2 类型转换与多个基类<br>
在<strong>只有一个基类</strong>的情况下，派生类的指针或引用<strong>能自动转换成一个可访问基类</strong>的<strong>指针或引用</strong>（参见15.2.2节，第530页；参见15.5节，第544页）。<strong>多个基类的情况与之类似</strong>。我们可以<strong>令某个可访问基类的指针或引用</strong>直接<strong>指向一个派生类对象</strong>。例如，一个ZooAnimal、Bear或Endangered类型的指针或引用可以绑定到Panda对象上：</p>
<p>编译器<strong>不会在派生类向基类的几种转换中进行比较和选择</strong>，因为在它看来<strong>转换到任意 一种基类都一样好</strong>。<strong>容易产生二义性</strong></p>
<p><strong>对象、指针和引用的静态类型决定了我们能够使用哪些成员</strong>（参见15.6节，第547页）。如果我们使用一个ZooAnimal指针，则只有定义在 ZooAnimal中的操作是可以使用的，Panda接口中的Bear、Panda和Endangered 特有的部分都不可见。类似的，一个Bear类型的指针或引用只能访问Bear及 ZooAnimal的成员，一个Endangered的指针或引用只能访问Endangered的成员。<br>
通过Bear指针访问Panda对象：</p>
<p>习题18.23<br>
应该都是允许的<br>
习题18.24<br>
pirnt可行，用的是panda的print<br>
cuddle不可行<br>
highlight不可行<br>
delete调用的也是panda的析构函数<br>
习题18.25<br>
全都调用了mi的print<br>
然后析构顺序和构造顺序相反<br>
MI-D2-B2-D1-B1</p>
<p>18.3.3 多重继承下的类作用域<br>
在只有一个基类的情况下，派生类的作用域嵌套在直接基类和间接基类的作用域中 (参见15.6节，第547页）。查找过程沿着继承体系自底向上进行，直到找到所需的名字。 派生类的名字将隐藏基类的同名成员。<br>
在<strong>多重继承</strong>的情况下，相同的查找过程在<strong>所有直接基类</strong>中<strong>同时进行</strong>。如果<strong>名字在多个 基类中都被找到</strong>，则对该名字的使用将<strong>具有二义性</strong>。<br>
对于一个派生类来说，从它的几个基类中分别<strong>继承名字相同的成员</strong>是<strong>完全合法</strong>的，只不过在<strong>使用这个名字</strong>时<strong>必须明确指出它的版本</strong>。<br>
当一个类拥有多个基类时，有可能出现派生类从两个或更多基类中继承了同名成员的情况。此时，<strong>不加前缀限定符直接使用</strong>该名字将<strong>引发二义性</strong></p>
<p>有时即使派生类继承的<strong>两个函数形参列表不同</strong>也可能发生错误。此外，即使max_weight在<strong>一个类中是私有的</strong>，而在<strong>另一个类中是公有的或受保护的</strong>同样 <strong>也可能发生错误</strong>。最后一种情况，假如max_weight定义在Bear中而非ZooAnimal 中，上面的程序仍然是错误的。<br>
要想<strong>避免潜在的二义性</strong>，最好的办法是<strong>在派生类中为该函数定义一个新版本</strong>。</p>
<p>习题18.26<br>
错误观点：Base1中的print和Base2中的print都符合条件，具有二义性<br>
正确观点：编译出错的原因并不是由于二义性的原型，因为MI类也定义了<code>print(vector&lt;double&gt;)</code>函数，所以原因是该类的该函数名因此了其基类的函数名，而找到该名字后，进行类型检查由于无法将double转换为<code>vector&lt;double&gt;</code>类型，所以编译器报错。<br>
<strong>因为派生类的作用域嵌套在直接基类和间接基类中，所以基类的同名成员会被隐藏</strong><br>
直接使用Base1::print(42)<br>
习题18.27<br>
因为派生类会隐藏基类中同名对象所以<br>
（a）<br>
MI：ival print dvec<br>
Derived：sval dval<br>
Base2：fval dval<br>
Base1 无（注意被形参中的cval隐藏了）<br>
外层作用域 dval<br>
（b）dval有三个 外层作用域和derived、base2的（注意base2的虽然是private，但是也是可见的）<br>
（c）使用Base1::dval+Derived::dval<br>
（d）fval=dvec.back()<br>
（e）sval[0]=cval</p>
<p>注意的点：Base1的cval注意被形参中的cval隐藏了，base2的虽然是private，但是也是可见的）<br>
重点：<strong>因为派生类的作用域嵌套在直接基类和间接基类中，所以基类的同名成员会被隐藏</strong>，所以要想<strong>避免潜在的二义性</strong>，最好的办法是<strong>在派生类中为该函数定义一个新版本</strong>。</p>
<p>18.3.4 虚继承<br>
尽管在派生列表中同一个基类只能出现一次，但实际上派生类<strong>可以多次继承同一个类</strong>。派生类可以通过它的<strong>两个直接基类分别继承同一个间接基类</strong>，也可以直接继承某个基类，然后通过另一个基类再一次间接继承该类。<br>
在默认情况下，派生类中<strong>含有继承链上每个类对应的子部分</strong>。如果某个类在派生过程中出现了多次，则派生类中<strong>将包含该类的多个子对象</strong>。<strong>但会影响派生类的操作</strong><br>
在C++语言中我们通过<strong>虚继承（virtual inheritance)</strong> 的机制<strong>解决上述问题。</strong> 虚继承的目的是<strong>令某个类做出声明</strong>，<strong>承诺愿意共享它的基类</strong>。其中，<strong>共享的基类子对象</strong>称为<strong>虚基类</strong> (virtual base class)。在这种机制下，不论虚基类在继承体系中<strong>出现了多少次</strong>，在<strong>派生类</strong>中都<strong>只包含唯一一个共享的虚基类子对象</strong>。</p>
<p>另一个Panda类</p>
<p>观察这个新的继承体系，我们将发现虚继承的一个不太直观的特征：<strong>必须在虚派生的真实需求出现前就已经完成虚派生的操作</strong>。例如在我们的类中，当我们定义Panda时才出现了对虚派生的需求，但是如果Bear和Raccoon不是从ZooAnimal虚派生得到的，那么Panda的设计者就显得不太幸运了。<br>
在实际的编程过程中，位于中间层次的基类将其继承声明为虚继承一般不会带来什么 问题。通常情况下，使用虚继承的类层次是由一个人或一个项目组一次性设计完成的。对于一个独立开发的类来说，很少需要基类中的某一个是虚基类，况且新基类的开发者也无法改变己存在的类体系。<br>
<strong>虚派生只影响从指定了虚基类的派生类中进一步派生出的类，它不会影响派生类本身</strong><br>
使用虚基类<br>
我们指定虚基类的方式是<strong>在派生列表中添加关键字virtual</strong><br>
virtual说明符<strong>表明了一种愿望</strong>，即在<strong>后续的派生类</strong>当中共享虚基类的同一份实例。至于什么样的类能够作为虚基类并没有特殊规定。<br>
如果某个类指定了虚基类，则该类的派生仍按常规方式进行：<br>
<strong>不论基类是不是虚基类</strong>，<strong>派生类对象</strong>都能<strong>被可访问基类</strong>的<strong>指针或引用</strong>操作。</p>
<p>虚基类成员的可见性<br>
因为在每个共享的虚基类中<strong>只有唯一一个共享的子对象</strong>，所以该基类的成员<strong>可以被直 接访问</strong>，并且<strong>不会产生二义性</strong>。此外，如果<strong>虚基类的成员</strong>只被<strong>一条派生路径覆盖</strong>.则我们仍然可<strong>直接访问</strong>这个被覆盖的成员。但是如果成员被<strong>多于一个基类（派生？）覆盖</strong>，则一般情况下派生类必须<strong>为该成员自定义一个新的版本</strong>。<br>
<strong>覆盖：D1 D2重新定义了基类的成员</strong></p>
<p>习题18.28<br>
derived1的 bar和 derived2的ival都是可以直接访问的，剩下的都需要限定符来区分</p>
<p>18.3.5 构造函数与虚继承<br>
在虚派生中，<strong>虚基类</strong>是由<strong>最低层的派生类初始化</strong>的。以我们的程序为例，当创建Panda 对象时，由<strong>Panda的构造函数独自控制ZooAnimal的初始化过程</strong>。<br>
为了理解这一规则，我们不妨假设当以<strong>普通规则处理初始化</strong>任务时会发生什么情况。 在此例中，<strong>虚基类</strong>将会在<strong>多条继承路径上被重复初始化</strong>。<br>
当然，继承体系中的<strong>每个类</strong>都可能在<strong>某个时刻</strong>成为&quot;<strong>最低层的派生类</strong>&quot;。只要我们能创建<strong>虚基类的派生类对象</strong>，该派生类的<strong>构造函数就必须初始化它的虚基类</strong>。</p>
<p>虚继承的对象的构造方式<br>
<strong>含有虚基类</strong>的对象的<strong>构造顺序</strong>与<strong>一般的顺序稍有区别</strong>：<strong>首先</strong>使用提供给<strong>最低层派生类 构造函数</strong>的初始值初始化该对象的<strong>虚基类子部分</strong>，接下来按照直接基类在<strong>派生列表中出现的次序依次</strong>对其<strong>进行初始化</strong>。</p>
<p><strong>虚基类总是先于非虚基类构造</strong>，与它们在继承体系中的次序和位置无关（假设bear是虚继承，它也是先于zooanimal？）</p>
<p>构造函数与析构函数的次序<br>
一个类可以有<strong>多个虚基类</strong>。此时，这些<strong>虚的子对象</strong>按照它们在<strong>派生列表中出现的顺序<br>
从左向右依次构造</strong>。</p>
<p><strong>编译器按照</strong>直接基类的<strong>声明顺序</strong>对其<strong>依次进行检査</strong>，以<strong>确定其中是否含有虚基类</strong>。如果有，则<strong>先构造虚基类</strong>，然后<strong>按照声明的顺序</strong>逐一<strong>构造其他非虚基类</strong>。</p>
<p><strong>合成的拷贝和移动构造函数</strong>按照<strong>完全相同的顺序</strong>执行，<strong>合成的赋值运算符</strong>中的成员也<strong>按照该顺序赋值</strong>。和往常一样，对象的<strong>销毁顺序</strong>与<strong>构造顺序正好相反</strong>，首先销毁TeddyBear部分，最后销毁ZooAnimal部分。</p>
<p>习题18.29<br>
（a）构造顺序：Class、Base、D1、D2、MI、Class、Final，析构函数相反<br>
（b）有一个Base两个Class<br>
（c）（a）class 是base的基类（b）具有两个基类，不明确 （c）base是mi的间接基类<br>
注意：1.如果虚基类有基类的话，也需要提前构造 比如Base的Class<br>
2.非虚基类的话会导致重复构造，相应地用一个基类指针或引用去指向的话会导致二义性</p>
<pre><code>struct Base { int i = 0; };
struct D1 :public Base { int i1 = 0; };
struct D2 : public Base { int i2 = 0; };
struct MI :public D1, public D2 { int i3 = 0; };
int main() {
	MI mi1, *mi = &amp;mi1;
	Base *b = mi;//基类Base不明确
}
</code></pre>
<p>习题18.30</p>
<pre><code>class Class {};  
class Base :public Class {  
  
protected:  
    int ival;  
public:  
    Base() :ival(0),Class() {};  
    Base(const Base &amp;b) = default;  
    Base(int a) :ival(a),Class() {}  
};  
class D1 :public virtual Base {  
public:  
    D1() :Base() {}  
    D1(const D1 &amp;b) = default;  
    D1(int a) :Base(a) {}  
};  
class D2 :public virtual Base {  
public:  
    D2() :Base() {}  
    D2(const D2 &amp;b) = default;  
    D2(int a) :Base(a) {}  
};  
class MI :public D1, public D2 {  
public:  
    MI() {}  
    MI(const MI &amp;m) :Base(m), D1(m), D2(m) {}  
    MI(int i) :Base(i), D1(i), D2(i) {}  
};  
class Final :public MI, public Class {  
public:  
    Final() {}  
    Final(const Final &amp;f) : Base(f), MI(f), Class() {}  
    Final(int i) : Base(i), Class() {}  
};  
</code></pre>
<p>习题感悟：<br>
构造顺序不要忘了派生类MI本身<br>
<strong>因为派生类的作用域嵌套在直接基类和间接基类中，所以基类的同名成员会被隐藏</strong>，所以要想<strong>避免潜在的二义性</strong>，最好的办法是<strong>在派生类中为该函数定义一个新版本</strong>。<br>
注意：1.如果虚基类有基类的话，也需要提前构造 比如Base的Class<br>
2.非虚基类的话会导致重复构造，相应地用一个基类指针或引用去指向的话会导致二义性</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Word查找的通配符和特殊字符]]></title>
        <id>https://lixin-ee.github.io//post/word-cha-zhao-de-tong-pei-fu-he-te-shu-zi-fu</id>
        <link href="https://lixin-ee.github.io//post/word-cha-zhao-de-tong-pei-fu-he-te-shu-zi-fu">
        </link>
        <updated>2019-11-28T02:01:38.000Z</updated>
        <content type="html"><![CDATA[<p>通配符主要有：</p>
<p>*代表0至任意个字符；</p>
<p>^?代表任意字符；</p>
<p>^#代表任意数字；</p>
<p>^$代表任意字母；</p>
<p>^&amp;代表查找内容（在替换时使用）。</p>
<p>其他段落标记、人工换行符、制表符等等应该称为特殊字符。</p>
<p>所谓通配就是随意的，如我知道一个单词的第一个字母是B，第三个C，但第二个不知道了，那就搜索B?C</p>
<p>任意单个字符</p>
<p>键入?</p>
<p>例如，s?t可查找“sat”和“set”。</p>
<p>任意字符串</p>
<p>键入*</p>
<p>例如，s*d可查找“sad”和“started”。</p>
<p>单词的开头</p>
<p>键入&lt;</p>
<p>例如，&lt;(inter)查找“interesting”和“intercept”，但不查找“splintered”。</p>
<p>单词的结尾</p>
<p>键入&gt;</p>
<p>例如，(in)&gt;查找“in”和“within”，但不查找“interesting”。</p>
<p>指定字符之一</p>
<p>键入[]</p>
<p>例如，w[io]n查找“win”和“won”。</p>
<p>指定范围内任意单个字符</p>
<p>键入[-]</p>
<p>例如，[r-t]ight查找“right”和“sight”。必须用升序来表示该范围。</p>
<p>中括号内指定字符范围以外的任意单个字符</p>
<p>键入[!x-z]</p>
<p>例如，t[!a-m]ck查找“tock”和“tuck”，但不查找“tack”和“tick”。</p>
<p>n个重复的前一字符或表达式</p>
<p>键入{n}</p>
<p>例如，fe{2}d查找“feed”，但不查找“fed”。</p>
<p>至少n个前一字符或表达式</p>
<p>键入{n,}</p>
<p>例如，fe{1,}d查找“fed”和“feed”。</p>
<p>n到m个前一字符或表达式</p>
<p>键入{n,m}</p>
<p>例如，10{1,3}查找“10”、“100”和“1000”。</p>
<p>一个以上的前一字符或表达式</p>
<p>键入@</p>
<p>例如，lo@t查找“lot”和“loot”。<br>
<img src="https://lixin-ee.github.io//post-images/1574906600032.jpeg" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 109. 有序链表转换二叉搜索树[中等]]]></title>
        <id>https://lixin-ee.github.io//post/shu-109-you-xu-lian-biao-zhuan-huan-er-cha-sou-suo-shu-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/shu-109-you-xu-lian-biao-zhuan-huan-er-cha-sou-suo-shu-zhong-deng">
        </link>
        <updated>2019-11-28T01:38:10.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。<br>
本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。<br>
示例:<br>
给定的有序链表： [-10, -3, 0, 5, 9],<br>
一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：<br>
0<br>
/ <br>
-3   9<br>
/   /<br>
-10  5<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这是错误的代码</p>
<pre><code>class Solution {
public:
    TreeNode* sortedListToBST(ListNode* head) {
        
    }    
    void bulidTree(TreeNode *cur,ListNode *head){
        if(head==NULL)
            return;
        cur-&gt;val=head-&gt;val;
        head=head-&gt;next;
        if(cur-&gt;left==NULL&amp;&amp;cur-&gt;right==NULL){
            TreeNode *parent=new TreeNode(0);
            bulidTree(patent,head);
        }
        if(cur-&gt;left!=NULL)
    }
};
</code></pre>
<p>//偷偷看到了108的题解中有人用中序遍历来构建顺序二叉树，觉得挺靠谱的的，gogogo<br>
//发现中序遍历还是很不熟悉啊 准备看题解了，实在不行就用一般方法中那种疯狂左旋右旋的方法吧hhh<br>
//看了题解。。。发现和前一题差不多呀，强行对链表进行二分法hhh 需要一堆临时变量来存。第二个更绝，直接用数组存链表hhh</p>
<p>最后参考题解的代码如下</p>
<pre><code>class Solution {
public:
    TreeNode* sortedListToBST(ListNode* head) {
        vector&lt;int&gt; nums;
        while(head!=NULL){
            nums.push_back(head-&gt;val);
            head=head-&gt;next;
        }
        if(nums.empty())
            return NULL;
        TreeNode *root=new TreeNode(0);
        genTree(root,0,nums.size()-1,nums);
        return root;

    }
       
    void genTree(TreeNode *cur,int beg,int end,vector&lt;int&gt;&amp; nums){
        if(beg==end){
            cur-&gt;val=nums[beg];
            cur-&gt;left==NULL;
            cur-&gt;right==NULL;
            return;
        }
      int mid=(end-beg+1)/2+beg;
        cur-&gt;val=nums[mid];
        if(mid&gt;beg){
            //TreeNode *left=new TreeNode(0);
            //cur-&gt;left=left;
            cur-&gt;left=new TreeNode(0);
            genTree(cur-&gt;left,beg,mid-1,nums);
        }else
        {
            cur-&gt;left=NULL;
            return;
        }
        
        if(mid&lt;end){
            cur-&gt;right=new TreeNode(0);
            genTree(cur-&gt;right,mid+1,end,nums);
        }else
        {
            cur-&gt;right=NULL;
            return;
        }
        return;  
            }
};
</code></pre>
<p>//本来想用vector(list.begin(),list.end())初始化vector，结果发现list给的是头节点，没找到方法要怎么调用begin和end的</p>
<p>然后来看一下官方题解：</p>
<blockquote>
<p>方法 1：递归<br>
想法<br>
题目中最重要的要求是需要利用链表中的节点，构建一颗高度平衡的二叉搜索树，好消息是链表中的元素是升序的。<br>
众所周知，一棵二叉搜索树是一棵有根二叉树并且对于所有节点满足特殊的性质：对于树中任意一个点，它的权值必然 \geq≥ 所有左子树节点的权值，\leq≤ 所有右子树节点的权值。因为二叉树具有递归的子结构，二叉搜索树也同理：所有子树也是二叉搜索树。<br>
当前方法和下一个方法的主要思路是：<br>
给定列表中的中间元素将会作为二叉搜索树的根，该点左侧的所有元素递归的去构造左子树，同理右侧的元素构造右子树。这必然能够保证最后构造出的二叉搜索树是平衡的。<br>
算法<br>
由于我们得到的是一个有序链表而不是数组，我们不能直接使用下标来访问元素。我们需要知道链表中的中间元素。<br>
我们可以利用两个指针来访问链表中的中间元素。假设我们有两个指针 slow_ptr 和 fast_ptr。slow_ptr 每次向后移动一个节点而 fast_ptr 每次移动两个节点。当 fast_ptr 到链表的末尾时 slow_ptr 就访问到链表的中间元素。对于一个偶数长度的数组，中间两个元素都可用来作二叉搜索树的根。<br>
当找到链表中的中间元素后，我们将链表从中间元素的左侧断开，做法是使用一个 prev_ptr 的指针记录 slow_ptr 之前的元素，也就是满足 prev_ptr.next = slow_ptr。断开左侧部分就是让 prev_ptr.next = None。<br>
我们只需要将链表的头指针传递给转换函数，进行高度平衡二叉搜索树的转换。所以递归调用的时候，左半部分我们传递原始的头指针；右半部分传递 slow_ptr.next 作为头指针。</p>
</blockquote>
<pre><code>class Solution {
  private ListNode findMiddleElement(ListNode head) {
    // The pointer used to disconnect the left half from the mid node.
    ListNode prevPtr = null;
    ListNode slowPtr = head;
    ListNode fastPtr = head;

    // Iterate until fastPr doesn't reach the end of the linked list.
    while (fastPtr != null &amp;&amp; fastPtr.next != null) {
      prevPtr = slowPtr;
      slowPtr = slowPtr.next;
      fastPtr = fastPtr.next.next;
    }

    // Handling the case when slowPtr was equal to head.
    if (prevPtr != null) {
      prevPtr.next = null;
    }

    return slowPtr;
  }

  public TreeNode sortedListToBST(ListNode head) {

    // If the head doesn't exist, then the linked list is empty
    if (head == null) {
      return null;
    }

    // Find the middle element for the list.
    ListNode mid = this.findMiddleElement(head);

    // The mid becomes the root of the BST.
    TreeNode node = new TreeNode(mid.val);

    // Base case when there is just one element in the linked list
    if (head == mid) {
      return node;
    }

    // Recursively form balanced BSTs using the left and right halves of the original list.
    node.left = this.sortedListToBST(head);
    node.right = this.sortedListToBST(mid.next);
    return node;
  }
}
</code></pre>
<p><img src="https://lixin-ee.github.io//post-images/1574905972042.png" alt=""></p>
<blockquote>
<p>方法 2：递归 + 转成数组<br>
这个方法是空间换时间的经典案例。<br>
你可以通过使用更多空间来降低时间复杂度。<br>
在这个方法中，我们将给定的链表转成数组并利用数组来构建二叉搜索树。数组找中间元素只需要 O(1) 的时间，所以会降低整个算法的时间复杂度开销。<br>
算法<br>
将给定链表转成数组，将数组的头和尾记成 left 和 right 。<br>
找到中间元素 (left + right) / 2，记为 mid。这需要 O(1) 时间开销，也是与上面算法主要改进的地方。<br>
将中间元素作为二叉搜索树的根。<br>
递归构造二叉搜索树的左右两棵子树，两个子数组分别是 (left, mid - 1) 和 (mid + 1, right)。</p>
</blockquote>
<pre><code>class Solution {

  private List&lt;Integer&gt; values;

  public Solution() {
    this.values = new ArrayList&lt;Integer&gt;();
  }

  private void mapListToValues(ListNode head) {
    while (head != null) {
      this.values.add(head.val);
      head = head.next;
    }
  }

  private TreeNode convertListToBST(int left, int right) {
    // Invalid case
    if (left &gt; right) {
      return null;
    }

    // Middle element forms the root.
    int mid = (left + right) / 2;
    TreeNode node = new TreeNode(this.values.get(mid));

    // Base case for when there is only one element left in the array
    if (left == right) {
      return node;
    }

    // Recursively form BST on the two halves
    node.left = convertListToBST(left, mid - 1);
    node.right = convertListToBST(mid + 1, right);
    return node;
  }

  public TreeNode sortedListToBST(ListNode head) {

    // Form an array out of the given linked list and then
    // use the array to form the BST.
    this.mapListToValues(head);

    // Convert the array to
    return convertListToBST(0, this.values.size() - 1);
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：时间复杂度降到了 O(N) ，因为需要将链表转成数组。而取中间元素的开销变成了 O(1) 所以整体的时间复杂度降低了。<br>
空间复杂度：因为我们利用额外空间换取了时间复杂度的降低，空间复杂度变成了 O(N)，相较于之前算法的O(logN)有所提升，因为创建数组的开销。</p>
</blockquote>
<blockquote>
<p>方法 3：中序遍历模拟<br>
想法<br>
我们知道，二叉树有三种不同的遍历方法：<br>
前序遍历<br>
中序遍历 和<br>
后序遍历。<br>
中序遍历一棵二叉搜索树会有一个非常有趣的结论。<br>
中序遍历一棵二叉搜索树的结果是得到一个升序序列。<br>
这个方法模拟了二叉搜索树的构造过程，因为我们已经获得有序的链表，所以自然的产生了这样的想法。<br>
在描述算法之前，先看一下中序遍历是如何获得有序值的。<br>
基于解决这个问题的中序遍历的思想：<br>
我们知道中序遍历最左边的元素一定是给定链表的头部，类似地下一个元素一定是链表的下一个元素，以此类推。这是肯定的因为给定的初始链表保证了升序排列。<br>
在了解了中序遍历二叉搜索树和有序数组的关系之后，让我们来看看算法。<br>
算法<br>
首先用伪代码来理解一下算法。<br>
➔ function formBst(start, end)<br>
➔      mid = (start + end) / 2<br>
➔      formBst(start, mid - 1)<br>
➔<br>
➔      TreeNode(head.val)<br>
➔      head = head.next<br>
➔<br>
➔      formBst(mid + 1, end)<br>
➔<br>
遍历整个链表获得它的长度，我们用两个指针标记结果数组的开始和结束，记为 start 和 end，他们的初始值分别为 0 和 length - 1。<br>
记住，我们当前需要模拟中序遍历，找到中间元素 (start + end) / 2。注意这里并不需要在链表中找到确定的元素是哪个，只需要用一个变量告诉我们中间元素的下标。我们只需要递归调用这两侧。<br>
递归左半边，其中开始和结束的值分别为 start, mid - 1。<br>
在这个算法中，每当我们构建完二叉搜索树的左半部分时，链表中的头指针将指向根节点或中间节点（它成为根节点）。 因此，我们只需使用头指针指向的当前值作为根节点，并将指针后移一位，即 head = head.next。<br>
我们在递归右半部分 mid + 1, end。</p>
</blockquote>
<pre><code>class Solution {

  private ListNode head;

  private int findSize(ListNode head) {
    ListNode ptr = head;
    int c = 0;
    while (ptr != null) {
      ptr = ptr.next;  
      c += 1;
    }
    return c;
  }

  private TreeNode convertListToBST(int l, int r) {
    // Invalid case
    if (l &gt; r) {
      return null;
    }

    int mid = (l + r) / 2;

    // First step of simulated inorder traversal. Recursively form
    // the left half
    TreeNode left = this.convertListToBST(l, mid - 1);

    // Once left half is traversed, process the current node
    TreeNode node = new TreeNode(this.head.val);
    node.left = left;

    // Maintain the invariance mentioned in the algorithm
    this.head = this.head.next;

    // Recurse on the right hand side and form BST out of them
    node.right = this.convertListToBST(mid + 1, r);
    return node;
  }

  public TreeNode sortedListToBST(ListNode head) {
    // Get the size of the linked list first
    int size = this.findSize(head);

    this.head = head;

    // Form the BST now that we know the size
    return convertListToBST(0, size - 1);
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：时间复杂度仍然为 O(N) 因为我们需要遍历链表中所有的顶点一次并构造相应的二叉搜索树节点。<br>
空间复杂度：O(logN) ，额外空间只有一个递归栈，由于是一棵高度平衡的二叉搜索树，所以高度上界为logN。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[0视为空指针]]></title>
        <id>https://lixin-ee.github.io//post/0-shi-wei-kong-zhi-zhen</id>
        <link href="https://lixin-ee.github.io//post/0-shi-wei-kong-zhi-zhen">
        </link>
        <updated>2019-11-27T15:25:24.000Z</updated>
        <content type="html"><![CDATA[<p>在做习题18.20的时候发现一个函数匹配的问题<br>
题目为</p>
<pre><code>void f()
{
	compute(0);
}
</code></pre>
<p>解答为</p>
<p>五个compute全部是候选函数，除了空函数都可行，0视为NULL<br>
如果<strong>using声明</strong>出现在<strong>局部作用域</strong>中，则引入的名字将<strong>隐藏外层作用域的相关声明</strong>。<br>
只有using声明中的两个compute候选，</p>
<pre><code>namespace p  
{  
    void compute();//不可行  
    void compute(const void *);//可行,0-&gt;NULL  
}  
using p::compute;  
void compute(int);//可行,最佳匹配  
void compute(double, double = 1.1);//可行,int-&gt;double  
void compute(char*, char* = 0);//可行,0-&gt;NULL  
  
void f()  
{  
    compute(0);//与compute(int)版本最佳匹配  
}  


namespace p{  
    void compute();//不可行，可见  
    void compute(const void *);//可行,0-&gt;NULL，可见  
}  
void compute(int);//可行,不可见，被隐藏
void compute(double, double = 1.1);//可行,int-&gt;double,被隐藏 
void compute(char*, char* = 0);//可行,0-&gt;NULL，被隐藏
void f(){  
    using p::compute;  
    compute(0);
} 
</code></pre>
<p>然后网友答案中说0可以视为NULL 也就是空指针<br>
翻阅了一下笔记，确实如此：<br>
空指针生成方法 <code>int *p1 = nullptr; int *p2 = 0; int *p3 = NULL;（需要引用#include cstdlib）</code></p>
<p>C++空指针表示NULL、0、nullptr</p>
<p>空指针在之前可以用Null和0(在很多头文件中，NULL是一个被定义为0的符号常量)来表示。</p>
<p>C程序员通常使用NULL以指出这是一个指针（就像使用'\0'而不是0来表示空字符，以指出这是一个字符一样）</p>
<p>C++传统上更喜欢用简单的0，而不是等价的NULL</p>
<p>C++11提供了关键字nullptr</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第十八章 笔记+习题 18.2]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-ba-zhang-bi-ji-xi-ti-182</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-ba-zhang-bi-ji-xi-ti-182">
        </link>
        <updated>2019-11-27T13:32:34.000Z</updated>
        <content type="html"><![CDATA[<p>18.2命名空间<br>
<strong>多个库</strong>将名字放置在<strong>全局命名空间</strong>中将引发<strong>命名空间污染</strong>（namespace pollution)。<br>
命名空间(namespace)为防止名字冲突提供了更加可控的机制。命名空间分割了全局命名空间，其中<strong>每个命名空间是一个作用域</strong>。通过<strong>在某个命名空间中定义库的名字</strong>，库的作者及用户）可以避免全局名字固有的限制。<br>
18.2.1命名空间定义<br>
一个命名空间的<strong>定义</strong>包含<strong>两部分</strong>：首先是<strong>关键字namespace</strong>，随后是<strong>命名空间的名字</strong>。在命名空间名字后面是一系列由<strong>花括号括起來的声明和定义</strong>。只要能出现在全局作用域中的声明就能置于命名空间内，主要包括：<strong>类</strong>、<strong>变量</strong>（及其构始化操作）、<strong>函数</strong>（及其定义）、<strong>模板</strong>和<strong>其他命名空间</strong>：  	和其他名字一样，<strong>命名空间的名字</strong>也必须在定义它的<strong>作用域内保持唯一</strong>。命名空间既可以定义在全局作用域内，也可以定义在其他命名空间中，但是<strong>不能定义在函数或类的內部</strong>。     命名空间<strong>作用域后面无须分号</strong>。</p>
<p>和其他作用域类似，命名空间中的<strong>每个名字</strong>都必须表示<strong>该空间内的唯一实体</strong>。因为不同命名空间的作用域不同，所以在<strong>不同命名空间</strong>内可以有<strong>相同名字的成员</strong>。<br>
定义在某个命名空间中的名字可以被该<strong>命名空间内的其他成员直接访问</strong>，也可以被这些成员内嵌作用域中的任何单位访问。位于该<strong>命名空间之外</strong>的代码则必须<strong>明确指出</strong>所用的名字<strong>属于哪个命名空间</strong>：</p>
<p>命名空间可以<strong>定义在几个不同的部分</strong>，这一点与其他作用域不太一样。</p>
<p>可能是<strong>定义</strong>了一个名为nsp的<strong>新命名空间</strong>，<strong>也可能</strong>是为<strong>已经存在</strong>的命名空间<strong>添加一些新成员</strong>。<br>
命名空间的定义<strong>可以不连续的特性</strong>使得我们可以将<strong>几个独立的接口和实现文件（头文件+源文件）组成一个命名空间</strong>。此时，命名空间的组织方式<strong>类似于我们管理自定义类及函数</strong>的方式：<br>
•命名空间的一部分成员的<strong>作用是定义类，以及声明作为类接口的函数及对象</strong>，则这些成员应该<strong>置于头文件</strong>中，这些头文件将被<strong>包含在使用了这些成员的文件</strong>中。<br>
•命名空间成员的<strong>定义部分</strong>则置于<strong>另外的源文件中</strong>。</p>
<p>在程序中<strong>某些实体只能定义一次</strong>：如<strong>非内联函数</strong>、<strong>静态数据成员</strong>、<strong>变量</strong>等，<strong>命名空间中定义的名字也需要满足这一要求</strong>，我们可以通过上面的方式组织命名空间并达到目的。这种接口和实现分离的机制确保我们所需的函数和其他名字只定义一次，而只要是用到这些实体的地方都能看到对于实体名字的声明<br>
定义<strong>多个类型不相关的命名空间</strong>应该使用<strong>单独的文件</strong>分别表示<strong>每个类型</strong>（或关联类型构成的集合)。</p>
<p>假定作用域中存在合适的声明语句，则命名空间中的代码<strong>可以使用同一命名空间定义的名字的简写形式</strong>：<br>
也可以在命名空间定义的<strong>外部定义</strong>该命名空间的成员。命名空间对于<strong>名字的声明必须在作用域内</strong>，同时该<strong>名字的定义</strong>需要<strong>明确指出其所属的命名空间</strong>；<br>
尽管命名空间的成员<strong>可以定义在命名空间外部</strong>，但是这样的定义<strong>必须出现在所属命名空间的外层空间（还是需要加前缀）中</strong>。换句话说，我们可以在cplusplus_primer或<strong>全局作用域</strong>中定义Sales_data operator+,但是<strong>不能在一个不相关的作用域中定义这个运算符</strong>。</p>
<p>模块特例化<br>
<strong>模板特例化必须定义在原始模板所属的命名空间中</strong>（参见16.5节，第626页）。和其 他命名空间名字类似，<strong>只要</strong>我们<strong>在命名空间中声明了特例化，就能在命名空间外部定义它了</strong>！</p>
<p>全局命名空间<br>
全局作用域中定义的名字（即在所有类、函数及命名空间之外定义的名字）也就是定<br>
义在<strong>全局命名空间（global namespace)（不是std）<strong>中。<strong>全局命名空间以隐式的方式声明</strong>，并且在所有程序中都存在。<strong>全局作用域中定义的名字被隐式地添加到全局命名空间中</strong>。<br>
作用域运算符同样可以用于全局作用域的成员，因为</strong>全局作用域是隐式</strong>的，<strong>所以它并没有名字</strong>。下面的形式<br>
<strong>: :member_ name表示全局命名空间中的一个成员。</strong></p>
<p>嵌套的命名空间<br>
<strong>嵌套的命名空间</strong>是指<strong>定义在其他命名空间中的命名空间</strong><br>
嵌套的命名空间同时是<strong>一个嵌套的作用域</strong>，它<strong>嵌套在外层命名空间的作用域中</strong>。嵌套的命名空间中的名字遵循的规则与往常类似：<strong>内层命名空间声明的名字</strong>将<strong>隐藏外层命名空间声明的同名成员</strong>。在嵌套的命名空间中定义的名字<strong>只在内层命名空间中有效</strong>，<strong>外层命名空间</strong>中的代码要<strong>想访问它</strong>必须在名字前<strong>添加限定符</strong>。</p>
<p>内联命名空间<br>
<strong>内联命名空间中的名字</strong>可以<strong>被外层命名空间直接使用</strong>。也就是说，我们无须在内联命名空间的名字前添加表示该命名空问的前缀，通过外层命名空间的名字就可以直接访问它。     <strong>定义内联命名空间</strong>的方式是在关键字namespace前<strong>添加关键字inline</strong>：     inline namespace FifthEd{<br>
/ /该命名空间表示本书第5版的代码<br>
关键字inline<strong>必须出现在命名空间第一次定义的地方</strong>，<strong>后续再打开</strong>命名空间的时候<strong>可以写inline.也可以不写</strong>。<br>
当应用程序的代码在<strong>一次发布和另一次发布之间发生了改变</strong>时，<strong>常常会用到内联命名空间</strong>。<br>
<strong>新发布的可以直接用，旧发布的需要加上前缀</strong></p>
<p>未命名的命名空间<br>
<strong>未命名的命名空间</strong>（unnamed namespace)是指<strong>关键字namespace后紧跟花括号</strong>括起来的一系列声明语句。未命名的命名空间中定义的变量<strong>拥有静态生命周期</strong>：它们在第一次使用前创建，并且<strong>直到程序结束才销毁</strong>。<br>
一个未命名的命名空间可以在<strong>某个给定的文件内不连续</strong>，但是<strong>不能跨越多个文件</strong>。<strong>每个文件定义自己的未命名的命名空间</strong>，如果<strong>两个文件</strong>都含有未命名的<strong>命名空间</strong>，则这两个空间<strong>互相无关</strong>。在这两个未命名的命名空间中可以定义相同的名字，并且这些定义表示的是不同实体。<strong>如果一个头文件定义了未命名的命名空间</strong>，则该命名空间中定义的名字<strong>将在毎个包含了该头文件的文件中对应不同实体</strong>。<br>
和其他命名空间不同，<strong>未命名的命名空间仅在特定的文件内部有效</strong>，其作用范围不会橫跨多个不同的文件。     <strong>定义在未命名的命名空间中的名字可以直接使用(区分全局命名空间)</strong>，毕竟我们找不到什么命名空间的名宇来限定它们；同样的，<strong>我们也不能对未命名的命名空间的成员使用作用域运算符</strong>。<br>
<strong>未命名的命名空间</strong>中定义的<strong>名字的作用域</strong>与<strong>该命名空间所在的作用域相同</strong>。<strong>如果未命名的命名空间定义</strong>在文件的<strong>最外层作用域</strong>中，则该命名空间中的名字<strong>一定要与全局作用域中的名字有所区别</strong>：<br>
一个未命名的命名空间<strong>也能嵌套在其他命名空间</strong>当中。此时，未命名的命名空间中的成员<strong>可以通过外层命名空间的名字</strong>来访问：<br>
<strong>在文件中进行静态声明</strong>的做法已经被C++标准<strong>取消</strong>了，现在的做法是<strong>使用未命名的命名空间</strong>。</p>
<p>习题18.12<br>
只要在include的后面加上 namespace chapter{}就好<br>
习题18.13<br>
希望使用全局变量的时候<br>
命名的命名空间中定义的变量<strong>拥有静态生命周期</strong>：它们在第一次使用前创建，并且<strong>直到程序结束才销毁</strong><br>
或者希望减少命名空间冲突<br>
和其他命名空间不同，<strong>未命名的命名空间仅在特定的文件内部有效</strong>，其作用范围不会橫跨多个不同的文件。<br>
习题18.14<br>
<code>mathLib::MatrixLib::matrix mathLib::MatrixLib::operator*(const matrix &amp;,const matrix&amp;)</code><br>
注意返回类型不在作用域内，所以需要叫上作用域运算符</p>
<p>18.2.2使用命名空间成员<br>
像namespace_name::member_name这样使用命名空间的成员显然非常烦琐<br>
命名空间的别名<br>
<strong>命名空间的别名(name space alias)<strong>使得我们可以为命名空间的名字</strong>设定一个短得多的同义词</strong>。例如，一个很长的命名空间的名字形如<br>
namespace cplusplus_primer {/<em>...</em>/};<br>
我们可以为其设定一个短得多的同义词：<br>
<strong>namespace primer = cplusplus_primer;<br>
<strong>命名空间的别名声明以</strong>关键字namespace开始</strong>，后面是<strong>别名</strong>所用的名字、<strong>=符号</strong>、命名<br>
空间<strong>原来的名字</strong>以及一个分号。<strong>不能在命名空间还没有定义前就声明别名.否则将产生错误</strong>。<br>
命名空间的别名<strong>也可以指向一个嵌套的命名空间</strong>：<br>
namespace Qlib = cplusplus_primer::QueryLib;<br>
Qlib::Query q;</p>
<p>Using声明：扼要概述<br>
<strong>注意！！！using声明不是针对命名空间的！是针对作用域的，类也能用的！</strong>	一条using声明（using declaration)语句<strong>一次只引入命名空间的一个成员</strong>。它使得我们可以清楚地知道程序中所用的到底是哪个名字。 	using声明引入的名字遵守与过去一样的作用域规则：它的<strong>有效范围从using声明的地方开始，一直到using声明所在的作用域结束为止</strong>。在此过程中，<strong>外层作用域的同名实体</strong>将<strong>被隐藏</strong>。未加限定的名字只能在<strong>using声明所在的作用域</strong>以及其<strong>内层作用域</strong>中使用。在有效作用域结束后，我们就必须使用完整的经过限定的名字了。     一条using声明语句可出现在全局作用域、局部作用域、命名空间作用域从及类的作用域中。在<strong>类的作用域中</strong>，这样的声明语句<strong>只能指向基类成员</strong>（参见15.5节，第546页)。<br>
例如using Base::param;</p>
<p>using指示<br>
using指示(using directive)和using声明类似的地方是，我们可以使用命名空间名字的简写形式；<strong>和using声明不同的地方</strong>是，我们<strong>无法控制哪些名字是可见的</strong>，<strong>因为所有名字都是可见的</strong>。<br>
using指示以关键字using开始，后面是关键字namespace以及命名空间的名字。如果这里所用的名字不是一个己经定义好的命名空间的名字，则程序将发生错误。using指示可以出现在全局作用域、局部作用域和命名空间作用域中，但是<strong>不能出现在类的作用域中</strong>。<br>
using指示<strong>使得某个特定的命名空间中所有的名字都可见</strong>，这样我们就无须再为它们添加任何前缀限定符了。简写的名字从using指示开始，一直到using指示所在的作用域结束都能使用。     如果我们提供一个<strong>对std等命名空间</strong>的using指示而<strong>未做任何特殊控制</strong>的话，将<strong>重新引入</strong>由于使用了多个库而造成的<strong>名字冲突问题</strong>。</p>
<p>using指示与作用域<br>
<strong>using 指示</strong>引入的名字的作用域远比<strong>using 声明</strong>引入的名字的作用域<strong>复杂</strong>。如我们所知，<strong>using 声明的名字的作用域与using 声明语句本身的作用域一致</strong>，<br>
<strong>using指示</strong>所做的绝非声明别名这么简单。相反，它<strong>具有将命名空间成员提升到包含命名空间本身和using指示的最近作用域的能力</strong>。     using 声明和using 指示在作用域上的区别<strong>直接决定了它们工作方式的不同</strong>。对于<strong>using 声明来说</strong>，我们只是<strong>简单地令名字在局部作用域内有效</strong>。相反，<strong>using 指示</strong>是<strong>令整个命名空间的所有内容变得有效</strong>。通常情况下，<strong>命名空间中会含有一些不能出现在局部作用域中的定义</strong>，因此，using指示<strong>一般被看作是出现在最近的外层作用域中</strong>。</p>
<p>当命名空间被注入到它的外层作用域之后，<strong>很有可能该命名空间中定义的名字会与其外层作用域中的成员冲突</strong>。例如在manip中，blip的成员j就与全局作用域中的j产生了冲突。这种<strong>冲突是允许存在的</strong>，但是要想使用冲突的名字.我们<strong>就必须明确指出名字的版本</strong>。manip中所有未加限定的j都会产生二义性错误。</p>
<p>头文件与using声明或指示<br>
<strong>头文件</strong>如果在其<strong>顶层作用域</strong>中<strong>含有using指示或using声明</strong>，则会将名字<strong>注入到所有包含了该头文件的文件</strong>中。通常情况下，头文件应该只负责定义接口部分的名字，而不定义实现部分的名字。因此，<strong>头文件最多只能在它的函数或命名空间内使用using指示或using声明</strong>（参见3.1节，第75页）。</p>
<p>习题18.15<br>
<strong>using 指示</strong>引入的名字的作用域远比<strong>using 声明</strong>引入的名字的作用域<strong>复杂</strong>。如我们所知，<strong>using 声明的名字的作用域与using 声明语句本身的作用域一致</strong>，<br>
<strong>using指示</strong>所做的绝非声明别名这么简单。相反，它<strong>具有将命名空间成员提升到包含命名空间本身和using指示的最近作用域的能力</strong>。     using 声明和using 指示在作用域上的区别<strong>直接决定了它们工作方式的不同</strong>。对于<strong>using 声明来说</strong>，我们只是<strong>简单地令名字在局部作用域内有效</strong>。相反，<strong>using 指示</strong>是<strong>令整个命名空间的所有内容变得有效</strong>。通常情况下，<strong>命名空间中会含有一些不能出现在局部作用域中的定义</strong>，因此，using指示<strong>一般被看作是出现在最近的外层作用域中</strong>。</p>
<p>习题18.16+17<br>
位置1：相当于把exercise中的名字引入到外层作用域中<br>
位置2：相当于把exercise中的名字引入到函数的作用域中，会影响dvar的定义和ivar的使用<br>
如果是using指示，那么位置1和位置2差别不大，<strong>具有将命名空间成员提升到包含命名空间本身和using指示的最近作用域的能力</strong></p>
<pre><code>//1.1  
//using exercise::ivar;//错误，与全局变量ivar冲突，多次声明  
//using exercise::dvar;  
//using exercise::limi;  
//  
//void manip()  
//{  
//  double dvar = 3.1416;//覆盖using声明的dvar  
//  int iobj = limi + 1;  
//  ++ivar;  
//  ++::ivar;  
//}  
  
  
//1.2  
//void manip()  
//{  
//  using exercise::ivar;//隐藏全局变量  
//  using exercise::dvar;  
//  using exercise::limi;  
//  double dvar = 3.1416;//错误，多重定义，多次初始化，当前dvar对象已经可见  
//  int iobj = limi + 1;  
//  ++ivar;//exercise的ivar  
//  ++::ivar;//全局变量  
//}  
  
//2.1  
//using namespace exercise;  
//void manip()  
//{  
//  double dvar = 3.1416;//覆盖using声明的dvar  
//  int iobj = limi + 1;  
//  ++ivar;//错误，不明确,二义性,二者都可见  
//  ++::ivar;  
//}  
  
//2.2  
//void manip()  
//{  
//  using namespace exercise;  
//  double dvar = 3.1416;//覆盖using声明的dvar  
//  int iobj = limi + 1;  
//  ++ivar;//错误，不明确,二义性,二者都可见  
//  ++::ivar;  
//} 
</code></pre>
<p>18.2.3 类、命名空间与作用域<br>
对<strong>命名空间内部名字</strong>的查找遵循常规的查找规则：即<strong>由内向外</strong>依次査找每个外层作用域。外层作用域也可能是一个或多个嵌套的命名空间，直到最外层的全局命名空间査找过程终止。只有位于开放的块中且在<strong>使用点之前声明的名字才被考虑</strong>：     对于位于<strong>命名空间中的类</strong>来说，常规的查找规则仍然适用：当成员函数使用某个名字时，首先在该成员中进行查找，然后在类中查找（包括基类），<strong>接着在外层作用域中查找</strong>，这时一个或几个外层作用域可能就是命名空间</p>
<p>可以从<strong>函数的限定名推断出查找名字时检查作用域的次序</strong>，限定名以相反次序,指出被査找的作用域。</p>
<p>实参相关的查找与类类型形参</p>
<p>对于命名空间中名字的隐藏规则来说有一个重要的例外，它使得我们可以<strong>直接访问输出运算符</strong>。这个<strong>例外是</strong>，当我们给函数<strong>传递一个类类型的对象</strong>时，<strong>除了在常规的作用域查找</strong>外<strong>还会查找实参类（比如cin和string的std）所属的命名空间</strong>。这一例外对于<strong>传递类的引用或指针</strong>的调用<strong>同样有效</strong>。</p>
<p>查找规则的这个例外允许概念上<strong>作为类接口一部分的非成员函数无须单独的using<br>
声明就能被程序使用</strong>。<br>
不需要using std::operator&gt;&gt;或者std::operator&gt;&gt;()</p>
<p>查找与std：：move 和 std::forward<br>
接下来考虑标准库<strong>move和forward</strong>函数。送两个都是模板函数，在标准库的定义中它们都<strong>接受一个右值引用的函数形参</strong>。如我们所知，在函数模板中，<strong>右值引用形参可以匹配任何类型</strong>（参见16.2.6节，第611页）。<strong>如果我们的应用程序也定义</strong>了一个<strong>接受单一形参</strong>的<strong>move函数</strong>，则<strong>不管该形参是什么类型</strong>，应用程序的move函数<strong>都将与标准库的版本冲突</strong>。<strong>forward函数也是如此</strong>。<br>
因此，move(以及forward)的名字冲突要比其他标准库函数的冲突频繁得多。而且，因为move和forward执行的是非常特殊的类型操作，所以应用程序专口修改函数原有行为的概率非常小。<br>
对于move和forward来说，冲突很多但是大多数是无意的，这一特点<strong>解释了为什么我们建议最好使用它们的带限定语的完整版本的原因</strong>（参见12.1.5节，第417页）。通过<strong>书写std::move而非move</strong>，我们就能明确地知道想要使用的是函数的标准库版本。</p>
<p>友元声明与实参相关的查找<br>
当类声明了一个友元时，<strong>该友元声明并没有使得友元本身可见</strong>（参见7.2.1节，第242页）。然而，一个<strong>另外的未声明的类或函数</strong>如果<strong>第一次出现在友元声明中</strong>，则我们认为它是<strong>最近的外层命名空间的成员</strong>。这条规则与实参相关的查找规则结合在一起将产生意想不到的效果：</p>
<p>习题18.18<br>
会首先在当前作用域中查找，然后查找参数的类所属的命名空间，所以<br>
当参数为string时，会使用string类中查找到的swap函数，找到则不使用std版本的。若未int类型，则直接使用标准库版本的swap<br>
习题18.19<br>
会强制使用std的swap</p>
<p>18.2.4 重载与命名空间<br>
命名空间对<strong>函数的匹配过程</strong>有<strong>两方面的影响</strong>（参见6.4节，第209页）。其中<strong>一个影响非常明显</strong>：using声明或using指示能<strong>将某些函数添加到候选函数集</strong>。另外一个影响则比较微妙。<br>
与实参相关的查找与重载<br>
对于接受类类型实参的函数来说，其名字查找将在实参类所属的命名空间中进行。这条规则对于我们如何确定候选函数集同样也有影响。我们<strong>将在每个实参类</strong>（以及实参类的<strong>基类</strong>）<strong>所属的命名空间中搜寻候选函数</strong>。在这些命名空间中所有与被调用函数<strong>同名的函数都将被添加到候选集</strong>当中，即使其中某些函数在调用语句处不可见也是如此：</p>
<p>重载与using声明<br>
要想理解using声明与重载之间的交互关系，必须首先明确一条：<strong>using声明语句声明的是一个名字</strong>，<strong>而非一个特定的函数</strong>（参见15.6节，第551页）：<br>
using <strong>NS::print(int)</strong>;		//<strong>错误：不能指定形参列表</strong><br>
using NS::print;	//正确：using声明只弄明一个名字<br>
当我们<strong>为函数书写using声明</strong>时，该函数的<strong>所有版本</strong>都被引入到当前作用域中。<br>
比如using std::operator&gt;&gt;<br>
一个using声明囊括了<strong>重载函数的所有版本</strong>以确保<strong>不违反命名空间的接口</strong>。<br>
一个using声明引入的函数将<strong>重载</strong>该声明语句<strong>所属作用域中已有的其他同名函数</strong>。如果<strong>using声明</strong>出现在<strong>局部作用域</strong>中，则引入的名字将<strong>隐藏外层作用域的相关声明</strong>。如果using声明所在的作用域中己经有一个函数与新引入的函数<strong>同名且形参列表相同</strong>，则该using声明将<strong>引发错误</strong>。除此之外，using声明将为引入的名字添加额外的重载实例，并最终扩充候选函数集的规模。</p>
<p>重载与using指示<br>
如果命名空间的某个函数与该命名空间所属作用域的函数同名，则命名空间的函数将被添加到重载集合中：<br>
与using 声明不同的是，对于<strong>using 指示</strong>来说，<strong>引入</strong>一个与<strong>已有函数形参列表完全相同<br>
的函数并不会产生错误</strong>。此时，<strong>只要</strong>我们<strong>指明</strong>调用的是命名空间中的<strong>函数版本</strong>还是当前作用域的<strong>版本</strong>即可。</p>
<p>习题18.20<br>
五个compute全部是候选函数，除了空函数都可行，0视为NULL<br>
如果<strong>using声明</strong>出现在<strong>局部作用域</strong>中，则引入的名字将<strong>隐藏外层作用域的相关声明</strong>。<br>
只有using声明中的两个compute候选，</p>
<pre><code>namespace p  
{  
    void compute();//不可行  
    void compute(const void *);//可行,0-&gt;NULL  
}  
using p::compute;  
void compute(int);//可行,最佳匹配  
void compute(double, double = 1.1);//可行,int-&gt;double  
void compute(char*, char* = 0);//可行,0-&gt;NULL  
  
void f()  
{  
    compute(0);//与compute(int)版本最佳匹配  
}  


namespace p{  
    void compute();//不可行，可见  
    void compute(const void *);//可行,0-&gt;NULL，可见  
}  
void compute(int);//可行,不可见，被隐藏
void compute(double, double = 1.1);//可行,int-&gt;double,被隐藏 
void compute(char*, char* = 0);//可行,0-&gt;NULL，被隐藏
void f(){  
    using p::compute;  
    compute(0);
} 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第十八章 笔记+习题 18.1]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-ba-zhang-bi-ji-xi-ti-181</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-ba-zhang-bi-ji-xi-ti-181">
        </link>
        <updated>2019-11-27T02:23:35.000Z</updated>
        <content type="html"><![CDATA[<p>18.1异常处理<br>
异常处理 (exceptionhandling )机制允许程序中独立开发的部分能够在<strong>运行时就出现的问题进行通信并做出相应的处理</strong>。异常使得我们能够将<strong>问题的检测与解决过程分离开来</strong>。</p>
<p>18.1.1 抛出异常<br>
我们通过<strong>抛出( throwing )一条表达式来引发（raised )—个异常</strong>。被抛出的表达式的<strong>类型</strong>以及当前的<strong>调用链</strong>共同<strong>决定了哪段处理代码( handler )</strong> 将被用来处理该异常。被选中的处理代码是在调用链中与抛出对象类型匹配的最近的处理代码。其中，根据抛出对象的类型和内巧，程净的异常抛出部分将会告知异常处理部分到底发生了什么错误。<br>
当执行一个 throw 时，跟在 <strong>throw 后面的语句将不再被执行</strong>。.相反，程序的控制权从 throw 转移到与之匹配的 <strong>catch 模块</strong>。<br>
•沿着调用链的函数可能会提早退出。<br>
•一旦程序<strong>开始执行异常处理代码</strong>，则沿着<strong>调用链创建的对象将被销毁</strong>。<br>
因为跟在 throw 后面的语句将<strong>不再被执行</strong>，所以<strong>throw 语句的用法有点类似于 return语句</strong>：它通常作为<strong>条件语句的一部分</strong>或者作为某个<strong>函数的最后（或者唯一）一条语句</strong>。</p>
<p>当 throw 出现在一个try 语句块（try block )内时，检查与该 try 块关联的 catch 子句。如果找到了匹配的 catch ,就使用该 catch 处理异常。如果这一步没找到匹配的 catch 且该 try 语句嵌套在其他 try 块中，则继续检查与<strong>外层 try</strong> 匹配的catch 子句。如果还是找不到匹配的 catch ,则退出当前的函数，在<strong>调用当前函数的外层函数中</strong>继续寻找。<br>
如果对抛出异常的函数的调用语句位于一个 try 语句块内，则检查与该 try 块关联的 catch 子句。如果找到了匹配的 catch ,就使用该 catch 处理异常。否则，如果该try 语句嵌套在其他 try 块中，则继续检查与外层 try 匹配的 catch 子句。如果仍然没有找到匹配的 catch ,则退出当前这个主调函数，维续在调用了刚刚退出的这个函数的其他函数中寻找，以此类推。<br>
上述过程被称为 <strong>栈展开 （stack unwinding )过程</strong>。栈展开过程<strong>沿着嵌套函数的调用链</strong><br>
不断查找，直到找到了与异常匹配的 catch 子句为止；或者也可能一直没找到匹配的catch ,则退出主函数后查找过程终止。<br>
假设<strong>找到了一个匹配的 catch 子句</strong>，则程序进入该子句并执行其中的代码。当<strong>执行完这个 catch 子句后</strong>，找到与 try 块关联的<strong>最后一个 <strong>catch <strong>子句之后的点</strong>，并从这里</strong>继续执行</strong>。<br>
<strong>如果没找到匹配的 catch 子句，程序将退出</strong>。因为异常通常被认为是妨碍程序正常执行的事件，所以—旦引发了某个异常，就<strong>不能对它置之不理</strong>。当<strong>找不到匹配的 catch</strong>时，程序将<strong>调用标准库函数 terminate,</strong> 顾名思义， terminate 负责终止程序的执行过程。</p>
<p>在栈展开过程中，位于调用链上的语句块可能会提前退出。通常情况下，程序在这些块中创建了一些局部对象。我们已经知道，<strong>块退出后它的局部对象也将随之销毁</strong>，这条规则对于栈展开过程同样适用。如果在找展开过程中退出了某个块，<strong>编译器将负责确保在这个块中创建的对象能被正确地销毁。</strong> 如果某个局部对象的类型是类类型，则该对象的析构函数将被自动调用。与往常一样，编译器在销毁内置类型的对象时不需要做任何事情。<br>
<strong>析构函数总是会被执行的</strong>，但是函数中<strong>负责释放资源的代码却可能被跳过</strong><br>
如果一个块分配了资源，并且在<strong>负责释放这些资源的代码前面发生了异常</strong>，则<strong>释放资源的代码将不会被执行</strong>。另一方面，类对象分配的资源将由类的析构函数负责释放。因此，如果我们<strong>使用类来控制资源的分配</strong>，就能确保无论函数正常结果还是遭遇异常，<strong>资源都能被正确地释放</strong>。<br>
出于<strong>栈展开可能使用析构函数</strong>的考虑，<strong>析构函数不应该抛出不能被它自身处理的异常</strong>。换句话说，如果析构函数需要执行某个可能抛出异常的操作，则该操作应该被放置在一个 try 语句块当中，并且在析构函数内部得到处理。<br>
在实际的编程过程中，因为析构函数<strong>仅仅是释放资源，所以它不太可能抛出异常</strong>。所有<strong>标准库类型都能确保它们的析构函数不会引发异常</strong>。<br>
在栈展开的过程中，运行类类型的局部对象的析构函数。因为这些析构函数是自动执行的，所以它们不应该抛出异常。<strong>一旦在栈展开的过程中析构函数拋出了异常</strong>，并且析构函数<strong>自身没能捕获到该异常，则程序将被终止</strong>。</p>
<p><strong>异常对象( exceptionobject )<strong>是一种特殊的对象，编译器使用 <strong>异常抛出表达式来对异常对象进行拷贝初始化</strong>（参见13.1.1节，第441页）。因此， <strong>throw 语句中的表达式必须拥有完全类型</strong>  而且如果该表达式是</strong>类类型</strong>的话，则相应的类必须含有一个<strong>可访问的析构函数</strong>和一个<strong>可访问的拷贝或移动构造函数</strong>。如果该表达式是<strong>数组类型或函数类型</strong>，则表达式将被转换成与之<strong>对应的指针类型</strong>。<br>
<strong>异常对象位于由编译器管理的空间中</strong>，编译器确保无论最终调用的是哪个 catch 子句都能访问该空间。当异常处理完带后，异常对象被销毁。<br>
如果退出了某个块，则同时释放块中局部对象使用的内存。因此.<strong>抛出一个指向局部对象的指针几乎肯定是一种错误的行为</strong>。出于同样的原因，<strong>从函数中返回指向局部对象的指针也是错误的</strong><br>
我们抛出一条表达式时，该表达式的<strong>静态编译时类型</strong>（参见15.2.3节，第534页）<strong>决定</strong>了<strong>异常对象的类型</strong>。读者必须牢记这一点，因为很多情况下程序抛出的表达式类型来自于某个继承体系。如果一条 throw 表达式<strong>解引用</strong>一个基类指针，而该指针实际指向的是派生类对象，则抛出的对象将被切掉一部分（参见15.2.3节，第535页），<strong>只有基类部分被抛出</strong>。<br>
<strong>拋出指针</strong>要求在任何对应的<strong>处理代码存在的地方</strong>，指针<strong>所指的对象都必须存在</strong>。</p>
<p>习题18.1<br>
（a）range error的类类型<br>
（b）p指向error的指针类型，为exception类型，range error是它的派生类，，但异常对象的类型取决于静态类型，所以是exception类型<br>
改成指针会引发错误，如果退出了某个块，则同时释放块中局部对象使用的内存。因此.<strong>抛出一个指向局部对象的指针几乎肯定是一种错误的行为</strong>。出于同样的原因，<strong>从函数中返回指向局部对象的指针也是错误的</strong><br>
习题18.2<br>
程序会查找catch语句，如果在内外层作用域都找不到的话就销毁所有局部对象然后调用terminate的abort()<br>
发生异常，所在块之前的临时变量皆会被销毁，V会调用vector类的析构函数进行销毁，并释放相关内存，P指针会被销毁，<strong>但是P指针指向的内存由于是动态分配的，所以该内存不会被释放</strong>，造成内存泄漏。输入流对象会调用ifstream类的析构函数销毁，最后程序被终止<br>
习题18.3<br>
1.使用try catch，在catch语句中销毁局部变量和动态内存<br>
2.使用throw catch<br>
3.使用智能指针类<br>
4.使用类类型，在析构函数中delete指向动态内存的指针</p>
<p>18.1.2 捕获异常<br>
catch 子句（ catchclause )中的异常声明( exceptiondeclaration )看起来像是只包含一个形参的函数形参列表。像在形参列表中一样，如果 catch 无须访问抛出的表达式的话，则我们可以忽略捕获形参的名字。<br>
<strong>声明的类型</strong>决定了<strong>处理代码</strong>所能<strong>捕获的异常类型</strong>。这个类型<strong>必须是完全类型</strong>（参见7.3.3节，第250页），它可以是左值引用，但不能是右值引用（参见13.6.1节，第471页）。<br>
当进入一个 catch 语句后，通过<strong>异常对象初始化异常声明中的参数</strong>。和函数的参数类似，如果 catch 的参数类型是非引用类型，则该参数是异常对象的一个副本，在 catch语句内改变该参数实际上改变的是局部副本而非异常对象本身；相反，如果参数是引用类型，则和其他引用参数一样，该参数是异常对象的一个别名，此时改变参数也就是改变异常对象。<br>
catch 的参数还有一个特性也与函数的参数非常类似：如果 catch 的参数是基类类型，则我们可以使用其派生类类型的异常对象对其进行初始化。此时，如果 catch 的参数是<strong>非引用类型</strong>，则异常对象将<strong>被切掉一部分</strong>（参见15.2.3节，第535页），这与将派生类对象以值传递的方式传给一个普通函数差不多。另一方面，如果 catch 的参数是<strong>基类的引用</strong>，则该参数将<strong>以常规方式绑定</strong>到异常对象上。<br>
最后一点需要注意的是，<strong>异常声明的静态类型将决定 catch 语句所能执行的操作</strong>。如果 catch 的参数是基类类型，则 catch 无法使用派生类特有的任何成员。<br>
通常情况下，如果catch接受的异常与<strong>某个继承体系有关</strong>，则最好将该catch的参数<strong>定义成引用类型</strong>。</p>
<p>在搜寻 catch 语句的过程中，我们最终找到的 catch <strong>未必是异常的最佳匹配</strong>。相反，<strong>挑选出来的应该是第一个与异常匹配的</strong> catch 语句。因此，<strong>越是专门的 catch 越应该置于整个 catch 列表的前端。</strong>（<strong>并不像函数匹配那样</strong>）<br>
因为 catch 语句是<strong>按照其出现的顺序逐一进行匹配的</strong>，所以当程序使用具有继承关系的多个异常时必须对 catch 语句的顺序进行组织和管理，使得<strong>派生类异常</strong>的处理代码出现在<strong>基类异常</strong>的处理代码<strong>之前</strong>。<br>
与实参和形参的匹配规则相比，异常和 catch 异常声明的匹配规则受到更多限制。此时，<strong>绝大多数类型转换都不被允许</strong>，除了一些极细小的差别之外，要求异常的类型和catch 声明的类型是精确匹配的：<br>
•允许<strong>从非常量向常量的类型转换</strong>，也就是说，一条非常量对象的 throw 语句可以匹配一个接受常量引用的 catch 语句。<br>
•允许从<strong>派生类向基类</strong>的类型转换。<br>
•<strong>数组</strong>被转换化<strong>指向数组（元素）类型的指针</strong>，<strong>函数</strong>被转换成<strong>指向该函数类型的指针</strong>。<br>
除此之外，包括准算术类型转换和类类型转换在内，其他所有转换规则都不能在匹配catch 的过程中使用。<br>
如果在多个catch语句的类型之间存在着继承关系，则我们应该把<strong>继承链最底端</strong>的类（mos tderived type)<strong>放在前面</strong>，而将<strong>继承链最顶端</strong>的类（least derived type)<strong>放在后面</strong>。</p>
<p>有时，一个单独的 catch 语句不能完整地处理某个异常。在执行了某些校正操作之后，<strong>当前的 catch</strong> 可能会决定由<strong>调用链更上一层的函数</strong>接着处理异常。一条 catch 语句通过<strong>重 新抛出 （ rethrowing )<strong>的操作</strong>将异常传递</strong>给<strong>另外一个 catch 语句</strong>。这里的重新抛出仍然是一条 throw 语句，只不过<strong>不包含任何表达式</strong>：<br>
<strong>throw;<br>
空的 throw 语句只能出现</strong>在** catch 语句<strong>或</strong> catch 语句直接或间接调用的函数之内**。如果在<strong>处理代码之外的区域</strong>遇到了空 throw 语句，<strong>编译器将调用 terminate</strong> 。<br>
一个重新抛出语句<strong>并不指定新的表达式</strong>，而是将当前的异常对象<strong>沿着调用链向上传递</strong>。<br>
很多时候， catch 语句<strong>会改变其参数的内容</strong>。如果在改变了参数的内容后 catch 语句重新抛出异常，则只有当 catch <strong>异常声明是引用类型时</strong>我们<strong>对参数所做的改变才会被保留</strong>并继续传播：</p>
<p>为了<strong>一次性捕获所有异常</strong>.我们使用<strong>省略号</strong>作为<strong>异常声明</strong>，这样的处理代码称为**捕获所有异常( catch - all )**的处理代码，形如 <strong>catch (...)</strong>。一条捕获所有异常的语句可以与任意类型的异常匹配。<br>
<strong>catch (...)通常与重新抛出语句一起使用</strong>，其中 catch <strong>执行当前局部能完成的工作（处理收尾）</strong>，随后重新抛出异常：</p>
<p>catch (...)既能单独出现，也能与其他几个 catch 语句一起出现<br>
如果 catch (...) 与其他几个 catch 语句一起出现，<strong>则 catch {…) 必须在最后的位置</strong>。出现在捕获所有异常语句后面的 catch 语句将永远不会被匹配。</p>
<p>习题18.4<br>
exception是基类，能够接纳一切的派生类对象，下面派生类对象的catch就没意义了<br>
应该顺序倒过来<br>
习题18.5</p>
<pre><code>int main() {
	try {
	
	}
	catch (overflow_error err) { cout&lt;&lt;err.what(); abort(); }
	catch(underflow_error err) { cout &lt;&lt; err.what(); abort(); }
	catch (range_error err) { cout &lt;&lt; err.what(); abort(); }
	catch(domain_error err) { cout &lt;&lt; err.what(); abort(); }
	catch (invalid_argument err) { cout &lt;&lt; err.what(); abort(); }
	catch (out_of_range err) { cout &lt;&lt; err.what(); abort(); }
	catch (length_error err) { cout &lt;&lt; err.what(); abort(); }
	catch(runtime_error err) { cout &lt;&lt; .what(); abort(); }
	catch(logic_error err) { cout &lt;&lt; .what(); abort(); }
	catch(bad_cast err) { cout &lt;&lt; .what(); abort(); }
	catch(bad_alloc err) { cout &lt;&lt; .what(); abort(); }
}
</code></pre>
<p>习题18.6<br>
(a)：throw &amp;exceptionType()<br>
(b)：任何异常皆可<br>
(c)：throw int()</p>
<p>18.1.3 函数try语句块与构造函数<br>
<strong>构造函数</strong>在进入其函数体之前<strong>首先执行初始值列表</strong>。因为在初始值列表抛出异常时构造函数体内的** try 语句块还未生效**，所以构造函数体内的 catch 语句<strong>无法处理构造函数初始值列表抛出的异常</strong>。<br>
要想处理构造函数初始值抛出的异常，我们<strong>必须将构造函数写成函数 try 语句块</strong>（也称为<strong>函数测试块(function try block )<strong>的形式。<strong>函数 try 语句块</strong>使得一组 catch 语句</strong>既能处理构造函数体</strong>（或析构函数体)，<strong>也能处理</strong>构造函数的<strong>初始化过程</strong>（或析构函数的<strong>析构过程完全隐式的）)</strong>。</p>
<p>注意：关键字 try 出现在表示构造函数初始值列表的冒号以及表示构造函数体（此例为空）的花括号之前。与这个 try 关联的 catch 既能处理构造函数化抛出的异常，也能处理成员初始化列表抛出的异常。<br>
还有一种情况值得读者注意，在<strong>初始化构造函数的参数</strong>时<strong>也可能发生异常</strong>，这样的异常<strong>不属于函数 try 语句块</strong>的一部分。函数 try 语句块只能处理构造函数开始执行后发生的异常。和其他函数调用一样，如果在参数初始化的过程中发生了异常.则该异常<strong>属于调用表达式的一部分</strong>，并将<strong>在调用者所在的上下文中处理</strong>。<br>
<strong>处理构造函数初始值异常的唯一方法是将构造函数写成函数 try 语句块</strong>。</p>
<p>习题18.7</p>
<pre><code>template &lt;typename&gt;
	Blob&lt;T&gt;::Blob() try:data(std::make_shared&lt;std::vector&lt;T&gt;)){ } catch(const std::bad_alloc &amp;e){handle_out_of_memory(e);}
</code></pre>
<p>18.1.4 noexcept异常说明<br>
对于用户及编译器来说，预先知道某个函数不会抛出异常显然大有裨益。首先，知道函数不会抛出异常有助于简化调用该函数的化码；其次，如果编译器确认函数不会抛出异常，它就能执行某些特殊的优化操作，而这些优化操作并不适用于可能出错的代码<br>
我们可以通过提供 <strong>noexcept说明</strong> （ noexcept specification )<strong>指定某个函数不会抛出异常</strong>。<br>
void recoup(int) <strong>noexcept</strong>;  //不会抛出异常   <strong>注意noexcept的位置</strong>void alloc(int);  //可能抛出异常<br>
recoup 做了不抛出说明 （ nonthrowing specification )。</p>
<p><strong>noexcept 说明要么出现在该函数的所有声明语句和定义语句中，要么一次也不出现。</strong> 该说明应该在函数的尾置返回类型（参见6.3.3节，第206页）之前。<br>
我们也可以在<strong>函数指针的声明和定义中指定 noexcept</strong> 。<br>
在 <strong>typedef 或类型别名</strong>中则<strong>不能出现 noexcept</strong> 。<br>
在成员函数中， noexcept 说明符需要跟在 <strong>const 及引用限定符之后</strong>,而在 <strong>final</strong> 、<strong>override 或虚函数的=0之前</strong>。</p>
<p>读者需要请楚的一个事实是<strong>编译器并不会在编译时检查 noexcept 说明</strong>。实际上，如果一个函数在说明了 noexcept 的同时又含有 throw 语句或者调用了可能抛出异常的其他函数，编译器将顺利编译通过，并不会因为这种违反异常说明的情况而报错（不排除个别编译器会对这种用法提出警告）：<br>
尽管函数声明了它不会抛出异常，但实际上还是抛出了。<strong>一旦一个 noexcept 函数抛出了异常</strong>，程序就会<strong>调用 terminate</strong>以确保遵守不在运行时抛出异常的承诺。上述过程对是否执行栈展开未作约定，因此 <strong>noexcept 可以用在两种情况下</strong>：一是我们<strong>确认函数不会抛出异常</strong>，二是我们<strong>根本不知道该如何处理异常</strong>。<br>
指明某个函数不会抛出异常可以令该函数的调用者不必再考虑如何处理异常。无论是函数确实不抛出异常，还是程序被终止，调用者都无须为此负责。<br>
通常情况下，编译器不能也不必在编译时验证异常说明。</p>
<p>noexcept 说明符的实参常常与 <strong>noexcept 运算符 (noexcept operator )</strong> 混合使用。 noexcept 运算符是一个一元运算符，它的<strong>返回值是一个 bool 类型的右值常量表达式</strong>，用于<strong>表示给定的表达式是否会抛出异常</strong>。<br>
noexcept(recoup(i))  //如果recoup不抛出异常则结果为true;否则结果为false<br>
noexcept(e)<br>
当 e 调用的所有函数<strong>都做了不抛出说明</strong>且 e <strong>本身不含有 throw 语句</strong>时，上述表达式为true ；否则 noexcept ( e )返回 false 。<br>
我们可以使用 noexcept 运算符得到如下的异常说明：<br>
void f() noexcept (noexcept (g ()));  //<strong>f和g的异常说明一致<br>
注意后面的不是函数体，而是noexcept说明符</strong><br>
如果函数 g 承诺了不会抛出异常，则 f 也不会抛出异常；如果 g 没有异常说明符，或者 g虽然有异常说明符巧是允许抛出异常，则 f 也可能抛出异常。<br>
noexcept 有两层含义；当跟在函数参数列表后面时它是<strong>异常说明符</strong>；而当作为 noexcept 异常说明的 bool 实参出现时，它是一个<strong>运算符</strong>。void f() noexcept (noexcept (g ())); //第一个noexcept是异常说明符，第二个noexcept是运算符。</p>
<p>尽管 noexcept 说明符<strong>不属于函数类型的一部分</strong>，但是函数的<strong>异常说明仍然会影响函数的使用。</strong><br>
<strong>函数指针</strong>及该指针<strong>所指的函数必须具有一致的异常说明</strong>。也就是说，如果我们为某个<strong>指针做了不抛出异常的声明</strong>，则该指针将<strong>只能指向不抛出异常的函数</strong>。相反，如果我们<strong>显式或隐式</strong>地<strong>说明</strong>了指针<strong>可能抛出异常</strong>，则该指针<strong>可以指向任何函数</strong>，<strong>即使是承诺了不抛出异常</strong>的**函数也可以（不同于const，const指针也可以指向非常量）<br>
区分<code>(*func)(int)</code>和 <code>*fun(int)</code> 前者是一个指针，后者是一个函数，调用运算符优先级高于解引用运算符 **</p>
<p>如果一个<strong>虚函数</strong>承诺了它<strong>不会抛出异常</strong>，则后续<strong>派生出来的虚函数</strong>也<strong>必须做出同样的承诺</strong>；与之相反，如果<strong>基类的虚函数允许抛出异常</strong>，则<strong>派生类</strong>的对应函数<strong>既可以允许</strong>抛出异常，<strong>也可以不允许</strong>抛出异常</p>
<p>当编译器<strong>合成拷贝控制成员</strong>时，同时也<strong>生成一个异常说明</strong>。如果对<strong>所有成员</strong>和<strong>基类的所有操作</strong>都承诺了<strong>不会抛出异常</strong>，则<strong>合成的成员是 noexcept</strong> 的。如果合成成员调用的<strong>任意一个函数可能抛出异常</strong>，则合成的成员是<strong>noexcept ( false )</strong>。而且，如果我们定义了一个<strong>析构函数</strong>但是<strong>没有为它提供异常说明</strong>，则<strong>编译器将合成一个</strong>。合成的异常说明将与假设由编译器为类合成析构函数时所得的异常说明一致。</p>
<p>习题18.8<br>
noexcep异常说明可以用来指定某个函数不会抛出异常（C++11新特性），声明和定义时皆需要出现在函数之后，但在final、override、=0之前</p>
<p>18.1.5异常类层次</p>
<p><strong>类型 exception</strong> 仅仅定义了<strong>拷贝构造函数、拷贝赋值运算符、一个虚析构函数和一个名为 what 的虚成员</strong>其中 what 函数返回一个<code>const char *</code>,该指针指向一个以null结尾的字符数组，并且确保不会抛出任何异常。<br>
类exception、bad_cast和bad_alloc定义了默认构造函数。类runtime_error和logic_error没有默认构造函数，但是有一个可以接受C风格字符串或者标准库string类型实参的构造函数，这些实参负责提供关于错误的更多信息。<br>
由上可知，我们的面向应用的异常类继承自标准异常类。和其他继承体系一样，异常类也可以看作按照层次关系组织的。<strong>层次越低.表示的异常情况就越特殊</strong>。例如，在异常类继承体系中位于最顶层的通常是 exception , exception 表示的含义是某处出错了，至于错误的细节则未作描述。<br>
继承体系的第二层将 exception 划分为两个大的类别：<strong>运行时错误</strong>和<strong>逻辑错误</strong>。运行时错误表示的是<strong>只有在程序运行时才能检测到的错误</strong>；而逻辑错误一般指的是我们可以<strong>在程序代码中发现的错误</strong>。<br>
实际的应用程序通常会自定义exception（或者exception的标准库派⽣类）的派⽣类以扩展其继承体系。这些⾯向应⽤的异常类表示了与应⽤相关的异常条件<br>
我们使用自定义异常类的方式与使用标准异常类的方式完全一样。程序在某处抛出异常类型的对象，在另外的地方捕获并处理这些出现的问题。</p>
<p>习题18.9</p>
<pre><code>class out_of_stock :public std::runtime_error {
public:
	explicit out_of_stock(const std::string &amp;s) :std::runtime_error(s) {}
};

class isbn_mismatch :public std::logic_error {
public:
	explicit isbn_mismatch(const std::string &amp;s): std::logic_error(s){}
	isbn_mismatch(const std::string &amp;s, const std::string &amp;lhs, const std::string &amp;rhs) :std::logic_error(s), left(lhs), right(rhs) {}
	const std::string left, right;
};
Sales_Data&amp; Sales_Data::operator+=(const Sales_Data&amp; rhs) {
	if (isbn() != rhs.isbn())
		throw isbn_mismatch(&quot;wrong isbns&quot;, isbn(), rhs.isbn());
	units_sold += rhs.units_sold;
	ave += rhs.ave;
	return *this;
}
</code></pre>
<p>习题18.10<br>
自己定义的异常类型和标准库的异常类处理方式完全一样，一处抛出一处捕获<br>
主要差异在于自己定义的可以添加说明string 更加清晰，容易定位错误<br>
习题18.11<br>
what 函数返回一个<code>const char *</code>，该指针指向一个以null结尾的字符数组，并且确保不会抛出任何异常。<br>
<strong>noexcept 可以用在两种情况下</strong>：一是我们<strong>确认函数不会抛出异常</strong>，二是我们<strong>根本不知道该如何处理异常</strong>。<br>
what其实两种情况都有，一是不可能发生异常，而是如果发生了异常也无法处理，一旦处理反而会导致递归调用自身。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 108. 将有序数组转换为二叉搜索树[简单]]]></title>
        <id>https://lixin-ee.github.io//post/shu-108-jiang-you-xu-shu-zu-zhuan-huan-wei-er-cha-sou-suo-shu-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/shu-108-jiang-you-xu-shu-zu-zhuan-huan-wei-er-cha-sou-suo-shu-jian-dan">
        </link>
        <updated>2019-11-27T01:50:52.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。<br>
本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。<br>
示例:<br>
给定有序数组: [-10,-3,0,5,9],<br>
一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：<br>
0<br>
/ <br>
-3   9<br>
/   /<br>
-10  5<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>108</p>
<pre><code>class Solution {
public:
    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) {
        if(nums.empty())
            return NULL;
        TreeNode *root=new TreeNode(0);
        genTree(root,0,nums.size()-1,nums);
        return root;
    }
    
    void genTree(TreeNode *cur,int beg,int end,vector&lt;int&gt;&amp; nums){
        if(beg==end){
            cur-&gt;val=nums[beg];
            cur-&gt;left==NULL;
            cur-&gt;right==NULL;
            return;
        }
        int mid=(end-beg+1)/2+beg;
        cur-&gt;val=nums[mid];
        if(mid&gt;beg){
            //TreeNode *left=new TreeNode(0);
            //cur-&gt;left=left;
            cur-&gt;left=new TreeNode(0);
            genTree(cur-&gt;left,beg,mid-1,nums);
        }else
        {
            cur-&gt;left=NULL;
            return;
        }
        
        if(mid&lt;end){
            cur-&gt;right=new TreeNode(0);
            genTree(cur-&gt;right,mid+1,end,nums);
        }else
        {
            cur-&gt;right=NULL;
            return;
        }
        return;            
    }
};
</code></pre>
<p>//似曾相识，回去翻看了一下发现不是在大话数据结构或者算法，而是在算法导论<br>
//果然开卷有益，看到第一幅图就有思路了，发现重点在于高度平衡，这意味着高度不能超过log2（n）<br>
//然后联想到二分查找法，它的时间复杂度也是log2（n）<br>
//所以当前节点应该为数组的中间值，哪到底是取ceil还是floor呢？示例中是取了ceil<br>
//然后就发现自己坑了自己，一直输出不对，调试了才发现ceil是多此一举了。。。因为beg和end本来就是int啊。。。。自动向下取整问你怕不怕<br>
//所以之前那么多人用复杂得多的mid=(end-beg+1)/2+beg;还是有原因的<br>
//cur-&gt;val<mark>nums[beg];<br>
//日常哈皮把=写成</mark>，还巨难发现<br>
//又忘了空树的情况了。。。面向测试用例编程，哭唧唧</p>
<p>然后来看一下网友题解<br>
首先是简洁的代码</p>
<pre><code>class Solution {
public:
    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) {
        if(nums.empty()) return nullptr;
        return helper(nums,0,nums.size()-1);
    }

    TreeNode* helper(vector&lt;int&gt;&amp; nums, int left, int right){
        if(left &gt; right)
            return nullptr;
        int mid = (left+ right) /2;
        TreeNode *root = new TreeNode(nums[mid]);
        root-&gt;left = helper(nums, left,mid -1);
        root-&gt;right = helper(nums,mid+1, right);
        return root;
    }
};
</code></pre>
<p>然后是解释和多种解法：</p>
<blockquote>
<p>解法一 递归<br>
如果做了 98 题 和 99 题，那么又看到这里的升序数组，然后应该会想到一个点，二叉搜索树的中序遍历刚好可以输出一个升序数组。<br>
所以题目给出的升序数组就是二叉搜索树的中序遍历。<br>
根据中序遍历还原一颗树，又想到了 105 题 和 106 题，通过中序遍历加前序遍历或者中序遍历加后序遍历来还原一棵树。前序（后序）遍历的作用呢？提供根节点！然后根据根节点，就可以递归的生成左右子树。<br>
这里的话怎么知道根节点呢？平衡二叉树，既然要做到平衡，我们只要把根节点选为数组的中点即可。<br>
综上，和之前一样，找到了根节点，然后把数组一分为二，进入递归即可。注意这里的边界情况，包括左边界，不包括右边界。</p>
</blockquote>
<pre><code>public TreeNode sortedArrayToBST(int[] nums) {
    return sortedArrayToBST(nums, 0, nums.length);
}

private TreeNode sortedArrayToBST(int[] nums, int start, int end) {
    if (start == end) {
        return null;
    }
    int mid = (start + end) &gt;&gt;&gt; 1;
    TreeNode root = new TreeNode(nums[mid]);
    root.left = sortedArrayToBST(nums, start, mid);
    root.right = sortedArrayToBST(nums, mid + 1, end);

    return root;
}
</code></pre>
<blockquote>
<p>解法二 栈 DFS<br>
递归都可以转为迭代的形式。<br>
一部分递归算法，可以转成动态规划，实现空间换时间，例如 5题，10题，53题，72题，从自顶向下再向顶改为了自底向上。<br>
一部分递归算法，只是可以用栈去模仿递归的过程，对于时间或空间的复杂度没有任何好处，比如这道题，唯一好处可能就是能让我们更清楚的了解递归的过程吧。<br>
自己之前对于这种完全模仿递归思路写成迭代，一直也没写过，今天也就试试吧。<br>
思路的话，我们本质上就是在模拟递归，递归其实就是压栈出栈的过程，我们需要用一个栈去把递归的参数存起来。这里的话，就是函数的参数 start，end，以及内部定义的 root。为了方便，我们就定义一个类。</p>
</blockquote>
<pre><code>class MyTreeNode {
    TreeNode root;
    int start;
    int end 
    MyTreeNode(TreeNode r, int s, int e) {
        this.root = r;
        this.start = s;
        this.end = e;
    }
}
</code></pre>
<blockquote>
<p>第一步，我们把根节点存起来。</p>
</blockquote>
<pre><code>Stack&lt;MyTreeNode&gt; rootStack = new Stack&lt;&gt;();
int start = 0;
int end = nums.length;
int mid = (start + end) &gt;&gt;&gt; 1;
TreeNode root = new TreeNode(nums[mid]);
TreeNode curRoot = root;
rootStack.push(new MyTreeNode(root, start, end));
</code></pre>
<blockquote>
<p>然后开始递归的过程，就是不停的生成左子树。因为要生成左子树，end - start 表示当前树的可用数字的个数，因为根节点已经用去 1 个了，所以为了生成左子树，个数肯定需要大于 1。</p>
</blockquote>
<pre><code>while (end - start &gt; 1) {
    mid = (start + end) &gt;&gt;&gt; 1; //当前根节点
    end = mid;//左子树的结尾
    mid = (start + end) &gt;&gt;&gt; 1;//左子树的中点
    curRoot.left = new TreeNode(nums[mid]);
    curRoot = curRoot.left;
    rootStack.push(new MyTreeNode(curRoot, start, end));
}
</code></pre>
<blockquote>
<p>在递归中，返回 null 以后，开始生成右子树。这里的话，当 end - start &lt;= 1 ，也就是无法生成左子树了，我们就可以出栈，来生成右子树。</p>
</blockquote>
<pre><code>MyTreeNode myNode = rootStack.pop();
//当前作为根节点的 start end 以及 mid
start = myNode.start;
end = myNode.end;
mid = (start + end) &gt;&gt;&gt; 1;
start = mid + 1; //右子树的 start
curRoot = myNode.root; //当前根节点
if (start &lt; end) { //判断当前范围内是否有数
    mid = (start + end) &gt;&gt;&gt; 1; //右子树的 mid
    curRoot.right = new TreeNode(nums[mid]);
    curRoot = curRoot.right;
    rootStack.push(new MyTreeNode(curRoot, start, end));
}
</code></pre>
<blockquote>
<p>然后把上边几块内容组合起来就可以了。</p>
</blockquote>
<pre><code>class MyTreeNode {
    TreeNode root;
    int start;
    int end;

    MyTreeNode(TreeNode r, int s, int e) {
        this.root = r;
        this.start = s;
        this.end = e;
    }
}
public TreeNode sortedArrayToBST(int[] nums) {
    if (nums.length == 0) {
        return null;
    }
    Stack&lt;MyTreeNode&gt; rootStack = new Stack&lt;&gt;();
    int start = 0;
    int end = nums.length;
    int mid = (start + end) &gt;&gt;&gt; 1;
    TreeNode root = new TreeNode(nums[mid]);
    TreeNode curRoot = root;
    rootStack.push(new MyTreeNode(root, start, end));
    while (end - start &gt; 1 || !rootStack.isEmpty()) {
        //考虑左子树
        while (end - start &gt; 1) {
            mid = (start + end) &gt;&gt;&gt; 1; //当前根节点
            end = mid;//左子树的结尾
            mid = (start + end) &gt;&gt;&gt; 1;//左子树的中点
            curRoot.left = new TreeNode(nums[mid]);
            curRoot = curRoot.left;
            rootStack.push(new MyTreeNode(curRoot, start, end));
        }
        //出栈考虑右子树
        MyTreeNode myNode = rootStack.pop();
        //当前作为根节点的 start end 以及 mid
        start = myNode.start;
        end = myNode.end;
        mid = (start + end) &gt;&gt;&gt; 1;
        start = mid + 1; //右子树的 start
        curRoot = myNode.root; //当前根节点
        if (start &lt; end) { //判断当前范围内是否有数
            mid = (start + end) &gt;&gt;&gt; 1; //右子树的 mid
            curRoot.right = new TreeNode(nums[mid]);
            curRoot = curRoot.right;
            rootStack.push(new MyTreeNode(curRoot, start, end));
        }

    }

    return root;
}
</code></pre>
<blockquote>
<p>解法三 队列 BFS<br>
参考 这里。 和递归的思路基本一样，不停的划分范围。</p>
</blockquote>
<pre><code>class MyTreeNode {
    TreeNode root;
    int start;
    int end;

    MyTreeNode(TreeNode r, int s, int e) {
        this.root = r;
        this.start = s;
        this.end = e;
    }
}
public TreeNode sortedArrayToBST3(int[] nums) {
    if (nums.length == 0) {
        return null;
    }
    Queue&lt;MyTreeNode&gt; rootQueue = new LinkedList&lt;&gt;();
    TreeNode root = new TreeNode(0);
    rootQueue.offer(new MyTreeNode(root, 0, nums.length));
    while (!rootQueue.isEmpty()) {
        MyTreeNode myRoot = rootQueue.poll();
        int start = myRoot.start;
        int end = myRoot.end;
        int mid = (start + end) &gt;&gt;&gt; 1;
        TreeNode curRoot = myRoot.root;
        curRoot.val = nums[mid];
        if (start &lt; mid) {
            curRoot.left = new TreeNode(0);
            rootQueue.offer(new MyTreeNode(curRoot.left, start, mid));
        }
        if (mid + 1 &lt; end) {
            curRoot.right = new TreeNode(0);
            rootQueue.offer(new MyTreeNode(curRoot.right, mid + 1, end));
        }
    }

    return root;
}
</code></pre>
<blockquote>
<p>最巧妙的地方是它先生成 left 和 right 但不进行赋值，只是把范围传过去，然后出队的时候再进行赋值。这样最开始的根节点也无需单独考虑了。</p>
</blockquote>
<blockquote>
<p>扩展 求中点<br>
前几天和同学发现个有趣的事情，分享一下。<br>
首先假设我们的变量都是 int 值。<br>
二分查找中我们需要根据 start 和 end 求中点，正常情况下加起来除以 2 即可。<br>
int mid = (start + end) / 2<br>
但这样有一个缺点，我们知道int的最大值是 Integer.MAX_VALUE ，也就是2147483647。那么有一个问题，如果 start = 2147483645，end = = 2147483645，虽然 start 和 end都没有超出最大值，但是如果利用上边的公式，加起来的话就会造成溢出，从而导致mid计算错误。<br>
解决的一个方案就是利用数学上的技巧，我们可以加一个 start 再减一个 start 将公式变形。<br>
(start + end) / 2 = (start + end + start - start) / 2 = start + (end - start) / 2<br>
这样的话，就解决了上边的问题。<br>
然后当时和同学看到jdk源码中，求mid的方法如下<br>
int mid = (start + end) &gt;&gt;&gt; 1<br>
它通过移位实现了除以 2，但。。。这样难道不会导致溢出吗？<br>
首先大家可以补一下 补码 的知识。<br>
其实问题的关键就是这里了&gt;&gt;&gt; ，我们知道还有一种右移是&gt;&gt;。区别在于&gt;&gt;为有符号右移，右移以后最高位保持原来的最高位。而&gt;&gt;&gt;这个右移的话最高位补 0。<br>
所以这里其实利用到了整数的补码形式，最高位其实是符号位，所以当 start + end溢出的时候，其实本质上只是符号位收到了进位，而&gt;&gt;&gt;这个右移可以带着符号位右移，所以之前的信息没有丢掉。<br>
但&gt;&gt;有符号右移就会出现问题了，事实上 JDK6 之前都用的&gt;&gt;，这个 BUG 在 java 里竟然隐藏了十年之久。</p>
</blockquote>
]]></content>
    </entry>
</feed>