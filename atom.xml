<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2020-01-11T02:08:51.655Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[动态规划 62. 不同路径[中等][未做出]]]></title>
        <id>https://lixin-ee.github.io//post/dong-tai-gui-hua-62-bu-tong-lu-jing-zhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/dong-tai-gui-hua-62-bu-tong-lu-jing-zhong-deng-wei-zuo-chu">
        </link>
        <updated>2020-01-11T01:11:27.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。<br>
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。<br>
问总共有多少条不同的路径？<br>
例如，上图是一个7 x 3 的网格。有多少可能的路径？<br>
说明：m 和 n 的值均不超过 100。<br>
示例 1:<br>
输入: m = 3, n = 2<br>
输出: 3<br>
解释:<br>
从左上角开始，总共有 3 条路径可以到达右下角。<br>
1.向右 -&gt; 向右 -&gt; 向下<br>
2.向右 -&gt; 向下 -&gt; 向右<br>
3.向下 -&gt; 向右 -&gt; 向右<br>
示例 2:<br>
输入: m = 7, n = 3<br>
输出: 28<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/unique-paths<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>其实这道题挺像回溯法的，但是我看了一眼tag其实是动态规划？<br>
一开始用的就是类似于回溯法的递归，然后又被自己坑了，递归调用中慎重用++i，只能用i+1,两次递归调用中会出现第二次递归i已经又增大了1的情况<br>
然后暴力递归果断爆炸了</p>
<p>然后我发现一个问题是似乎每个路径的长度是确定的</p>
<p>只能想一下动态规划了<br>
一开始实在没什么头绪，只能牺牲空间复杂度了，然后发现无论是vecotr还是unordered_map都很复杂<br>
还是老老实实看题解吧，没那么时间可以浪费了</p>
<p>看了题解才发现其实是70题提过的方法，只是当时没好好记录和复现，唉<br>
然后题目还提到了有化为一维数组的方法</p>
<p>复现过程中的点<br>
1.将m* n数组初始化为1<br>
2.循环标志i和j从1开始，因为边界点的可能性都是为1的，这一点和第一点相互照应。<br>
3.一维数组的压缩就是利用当前行只需要上一列的内容来压缩（可以先考虑压缩到两行cur和pre，然后在考虑cur本身也是pre）</p>
<p>最后就是排列组合的问题了，步骤确定，那么只要选定步骤中任意m次向右或者n次向下就行了，等于C上m或n,C下的len为m+n-2，有时间的话可以了解一下C上m或n都是结果相同的</p>
<p>所以从今天起，每道题只花少量时间去思考，想不出来就看题解的思路，然后按照思路来自己复现（不能照抄代码）</p>
<p>实现代码</p>
<pre><code>    /*自己弄的蹩脚的递归法
    void move(int i,int j,int m, int n,int &amp;res){
        if(i==m&amp;&amp;j==n){
            ++res;
            return;
        }
        if(i&lt;m)
            move(i+1,j,m,n,res);
        if(j&lt;n)
            move(i,j+1,m,n,res);
        return;
    }
    */
</code></pre>
<pre><code>    /*二维数组动态递归
        int uniquePaths(int m, int n) {
        vector&lt;vector&lt;int&gt;&gt; status(m,vector&lt;int&gt;(n,1));
        for(int i=1;i&lt;m;++i)
            for(int j=1;j&lt;n;++j)
                status[i][j]=status[i-1][j]+status[i][j-1];
        return status[m-1][n-1];
    }
</code></pre>
<pre><code>//单维数组存储
    int uniquePaths(int m, int n) {
        vector&lt;int&gt; status(m,1);
        for(int j=1;j&lt;n;++j)
            for(int i=1;i&lt;m;++i)
                status[i]+=status[i-1];
        return status[m-1];
    }
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>思路<br>
思路一：排列组合<br>
因为机器到底右下角，向下几步，向右几步都是固定的，<br>
比如，m=3, n=2，我们只要向下 1 步，向右 2 步就一定能到达终点。<br>
所以有 C{m+n-2} {m-1}</p>
</blockquote>
<pre><code>def uniquePaths(self, m: int, n: int) -&gt; int:
        return int(math.factorial(m+n-2)/math.factorial(m-1)/math.factorial(n-1))
</code></pre>
<blockquote>
<p>思路二：动态规划<br>
我们令 dp[i][j] 是到达 i, j 最多路径<br>
动态方程：dp[i][j] = dp[i-1][j] + dp[i][j-1]<br>
注意，对于第一行 dp[0][j]，或者第一列 dp[i][0]，由于都是在边界，所以只能为 1<br>
时间复杂度：O(m*n)<br>
空间复杂度：O(m * n))<br>
优化：因为我们每次只需要 dp[i-1][j],dp[i][j-1]<br>
所以我们只要记录这两个数，直接看代码吧！<br>
代码<br>
思路二：</p>
</blockquote>
<pre><code>Java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for (int i = 0; i &lt; n; i++) dp[0][i] = 1;
        for (int i = 0; i &lt; m; i++) dp[i][0] = 1;
        for (int i = 1; i &lt; m; i++) {
            for (int j = 1; j &lt; n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];  
    }
}
</code></pre>
<blockquote>
<p>优化1：空间复杂度 O(2n)</p>
</blockquote>
<pre><code>Java
class Solution {
    public int uniquePaths(int m, int n) {
        int[] pre = new int[n];
        int[] cur = new int[n];
        Arrays.fill(pre, 1);
        Arrays.fill(cur,1);
        for (int i = 1; i &lt; m;i++){
            for (int j = 1; j &lt; n; j++){
                cur[j] = cur[j-1] + pre[j];
            }
            pre = cur.clone();
        }
        return pre[n-1]; 
    }
}
</code></pre>
<blockquote>
<p>优化2：空间复杂度 O(n)</p>
</blockquote>
<pre><code>Java
class Solution {
    public int uniquePaths(int m, int n) {
        int[] cur = new int[n];
        Arrays.fill(cur,1);
        for (int i = 1; i &lt; m;i++){
            for (int j = 1; j &lt; n; j++){
                cur[j] += cur[j-1] ;
            }
        }
        return cur[n-1];
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 215. 数组中的第K个最大元素[中等]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-215-shu-zu-zhong-de-di-k-ge-zui-da-yuan-su-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-215-shu-zu-zhong-de-di-k-ge-zui-da-yuan-su-zhong-deng">
        </link>
        <updated>2020-01-10T01:25:57.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br>
示例 1:<br>
输入: [3,2,1,5,6,4] 和 k = 2<br>
输出: 5<br>
示例 2:<br>
输入: [3,2,3,1,2,4,5,5,6] 和 k = 4<br>
输出: 4<br>
说明:<br>
你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/kth-largest-element-in-an-array<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>一开始我想的是用空间换时间，创建一个k大小的数组，然后不断插入到合适的位置（等等，这不就是插入排序吗？插入需要查找感觉也没简化多少啊）<br>
然后发现其实可以转化为为堆排序，然后返回下标<br>
然后就是tag中的分治法 我只想到了分治排序（也就是归并排序）（注意别和快速排序搞混了）<br>
然后有一个想法分治分成多个部分然后合并成k份或者分成k份，但是后来发现有问题</p>
<p>插入排序的时间复杂度是平方，放弃<br>
先实现堆排序,我在复现的过程中犯了一个错误，HeapAdjust应该只有一个循环，每次处理一个非子节点，而不是一次把所有节点放进去，否则的话后面排序的时候会很麻烦<br>
此时其实和快速排序没啥子区别的了</p>
<p>然后题解中其实提到我想到的k大小数组和分治法的方法，分别是K大小的堆和快速选择</p>
<p>实现的代码：<br>
堆排序</p>
<pre><code>/*
    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {
        int len=nums.size();
        for(int i=(len-1)/2;i&gt;=0;--i)
            HeapAdjust(nums,i,len);
        
        for(int i=len-1;i&gt;0;--i){
            swap(nums[0],nums[i]);
            HeapAdjust(nums,0,i);
        }
        return nums[len-k];  
    }
    
    void HeapAdjust(vector&lt;int&gt; &amp;nums,int s,int len){
            int temp=nums[s];
            for(int j=2*s+1;j&lt;len;j=2*j+1){
                if(j&lt;len-1&amp;&amp;nums[j+1]&gt;nums[j])
                    ++j;
                if(temp&gt;nums[j])
                    break;
                nums[s]=nums[j];
                s=j;
            }
            nums[s]=temp;
    }
*/
</code></pre>
<p>快速排序随机切实现</p>
<pre><code>/*
    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {
        int target;
        int len=nums.size();
        int left=0,right=len-1;
        while(true){
            target=binartselect(nums,left,right);
            if(target==len-k)
                return nums[target];
            else if(target&lt;len-k)
                left=target+1;
            else
                right=target-1;
        }
    }
    
    int binartselect(vector&lt;int&gt;&amp; nums,int left,int right){
        int pivotkey=nums[left];  
        
        //C++的随机数实现 加到标题上方便搜索
        if(right&gt;left){
            default_random_engine e;
            uniform_int_distribution&lt;unsigned&gt; u(left,right);
            pivotkey=nums[u(e)];
        }
        while(left&lt;right){
            while(left&lt;right&amp;&amp;nums[right]&gt;=pivotkey) //这里一定要是&gt;=否则遇上重复数会导致无限循环
                --right;
            nums[left]=nums[right];
            while(left&lt;right&amp;&amp;nums[left]&lt;=pivotkey) //这里一定要是&lt;=否则遇上重复数会导致无限循环
                ++left;
            nums[right]=nums[left];           
        }
        nums[left]=pivotkey;
        return left;
    }
*/
</code></pre>
<p>优先队列实现：</p>
<pre><code>class Solution {
public:
    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {
        priority_queue&lt;int,vector&lt;int&gt;,great&lt;int&gt;&gt; res; //底层数据结构是大顶堆，注意每次会弹出最大值
        for(auto i:nums){
            res.push(i);
            if(res.size()&gt;k)
                res.pop();
        }
        return res.top();
    }
  
};
</code></pre>
<p>然后来看看网友题解</p>
<blockquote>
<p>方法一：暴力解法<br>
题目要求我们找到“数组排序后的第 k 个最大的元素，而不是第 kk 个不同的元素” ，<br>
语义是从右边往左边数第 k 个元素（从 1 开始），那么从左向右数是第几个呢，我们列出几个找找规律就好了。<br>
一共 6 个元素，找第 2 大，索引是 4；<br>
一共 6 个元素，找第 4 大，索引是 2。<br>
因此，升序排序以后，目标元素的索引是 len - k。这是最简单的思路，如果只答这个方法，面试官可能并不会满意，但是在我们平时的开发工作中，还是不能忽视这种思路简单的方法，理由如下：<br>
最简单同时也一定是最容易编码的，编码成功的几率最高，可以用这个最简单思路编码的结果和其它思路编码的结果进行比对，验证高级算法的正确性；<br>
在数据规模小、对时间复杂度、空间复杂度要求不高的时候，简单问题简单做；<br>
思路简单的算法考虑清楚了，有些时候能为实现高级算法铺路，这道题也是如此；<br>
低级算法往往容错性最好，即在输入不满足题目条件的时候，往往还能得到正确的答案，而高级算法对输入数据的要求就非常苛刻，这一点可以参考 「力扣」第 4 题：“寻找两个有序数组的中位数”。</p>
</blockquote>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

class Solution {
public:
    int findKthLargest(vector&lt;int&gt; &amp;nums, int k) {
        int size = nums.size();
        sort(begin(nums), end(nums));
        return nums[size - k];
    }
};
</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(NlogN)，这里 N 是数组的长度，算法的性能消耗主要在排序，JDK 默认使用快速排序，因此时间复杂度为O(NlogN)。<br>
空间复杂度：O(1)，这里是原地排序，没有借助额外的辅助空间。<br>
到这里，我们已经分析出了：<br>
1、我们应该返回最终排定以后位于 len - k 的那个元素；<br>
2、性能消耗主要在排序，JDK 默认使用快速排序。<br>
学习过 “快速排序” 的朋友，一定知道一个操作叫 partition，它是 “分而治之” 思想当中 “分” 的那一步。经过 partition 操作以后，每一次都能排定一个元素，并且这个元素左边的数都不大于它，这个元素右边的数都不小于它，并且我们还能知道排定以后的元素的索引。于是可以应用 “减而治之”（分治思想的特例）的思想，把问题规模转化到一个更小的范围里。</p>
</blockquote>
<blockquote>
<p>于是得到方法二。<br>
方法二：借助 partition 操作定位到最终排定以后索引为 len - k 的那个元素（特别注意：随机化切分元素）<br>
以下是注意事项，因为很重要，所以放在前面说：<br>
快速排序虽然快，但是如果实现得不好，在遇到特殊测试用例的时候，时间复杂度会变得很高。如果你使用 partition 的方法完成这道题，时间排名不太理想，可以考虑一下是什么问题，这个问题很常见。<br>
以下的描述基于 “快速排序” 算法知识的学习，如果忘记的朋友们可以翻一翻自己的《数据结构与算法》教材，复习一下，partition 过程、分治思想和 “快速排序” 算法的优化。<br>
分析：我们在学习 “快速排序” 的时候，接触的第 1 个操作就是 partition（切分），简单介绍如下：<br>
partition（切分）操作，使得：<br>
对于某个索引 j，nums[j] 已经排定，即 nums[j] 经过 partition（切分）操作以后会放置在它 “最终应该放置的地方”；<br>
nums[left] 到 nums[j - 1] 中的所有元素都不大于 nums[j]；<br>
nums[j + 1] 到 nums[right] 中的所有元素都不小于 nums[j]。<br>
partition（切分）操作总能排定一个元素，还能够知道这个元素它最终所在的位置，这样每经过一次 partition（切分）操作就能缩小搜索的范围，这样的思想叫做 “减而治之”（是 “分而治之” 思想的特例）。<br>
切分过程可以不借助额外的数组空间，仅通过交换数组元素实现。下面是参考代码：</p>
</blockquote>
<pre><code>public class Solution {

    public int findKthLargest(int[] nums, int k) {
        int len = nums.length;
        int left = 0;
        int right = len - 1;

        // 转换一下，第 k 大元素的索引是 len - k
        int target = len - k;

        while (true) {
            int index = partition(nums, left, right);
            if (index == target) {
                return nums[index];
            } else if (index &lt; target) {
                left = index + 1;
            } else {
                right = index - 1;
            }
        }
    }

    /**
     * 在数组 nums 的子区间 [left, right] 执行 partition 操作，返回 nums[left] 排序以后应该在的位置
     * 在遍历过程中保持循环不变量的语义
     * 1、[left + 1, j] &lt; nums[left]
     * 2、(j, i] &gt;= nums[left]
     *
     * @param nums
     * @param left
     * @param right
     * @return
     */
    public int partition(int[] nums, int left, int right) {
        int pivot = nums[left];
        int j = left;
        for (int i = left + 1; i &lt;= right; i++) {
            if (nums[i] &lt; pivot) {
                // 小于 pivot 的元素都被交换到前面
                j++;
                swap(nums, j, i);
            }
        }
        // 在之前遍历的过程中，满足 [left + 1, j] &lt; pivot，并且 (j, i] &gt;= pivot
        swap(nums, j, left);
        // 交换以后 [left, j - 1] &lt; pivot, nums[j] = pivot, [j + 1, right] &gt;= pivot
        return j;
    }

    private void swap(int[] nums, int index1, int index2) {
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(N)，这里 N 是数组的长度，理由可以参考本题解下用户 @ZLW 的评论，需要使用主定理进行分析。<br>
空间复杂度：O(1)，原地排序，没有借助额外的辅助空间。<br>
注意：本题必须随机初始化 pivot 元素，否则通过时间会很慢，因为测试用例中有极端测试用例。<br>
为了应对极端测试用例，使得递归树加深，可以在循环一开始的时候，随机交换第 1 个元素与它后面的任意 1 个元素的位置；<br>
说明：最极端的是顺序数组与倒序数组，此时递归树画出来是链表，时间复杂度是 O(N^2)，根本达不到减治的效果。</p>
</blockquote>
<p>参考代码 3：<br>
随机选取元素</p>
<pre><code>import java.util.Random;

public class Solution {

    private static Random random = new Random(System.currentTimeMillis());

    public int findKthLargest(int[] nums, int k) {
        int len = nums.length;
        int target = len - k;
        int left = 0;
        int right = len - 1;
        while (true) {
            int index = partition(nums, left, right);
            if (index &lt; target) {
                left = index + 1;
            } else if (index &gt; target) {
                right = index - 1;
            } else {
                return nums[index];
            }
        }
    }

    // 在区间 [left, right] 这个区间执行 partition 操作

    private int partition(int[] nums, int left, int right) {
        // 在区间随机选择一个元素作为标定点
        if (right &gt; left) {
            int randomIndex = left + 1 + random.nextInt(right - left);
            swap(nums, left, randomIndex);
        }

        int pivot = nums[left];
        int j = left;
        for (int i = left + 1; i &lt;= right; i++) {
            if (nums[i] &lt; pivot) {
                j++;
                swap(nums, j, i);
            }
        }
        swap(nums, left, j);
        return j;
    }

    private void swap(int[] nums, int index1, int index2) {
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp;
    }
} 
</code></pre>
<blockquote>
<p>2、使用双指针，将与 pivot 相等的元素等概论地分到 pivot 最终排定位置的两边。<br>
参考代码 4：使用双指针的办法找到切分元素的位置。</p>
</blockquote>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

class Solution {
private:
    int partition(vector&lt;int&gt; &amp;nums, int left, int right) {
        // 随机在 [left, right] 中, 选择一个数值作为标定点 pivot
        swap(nums[left], nums[rand() % (right - left + 1) + left]);

        int pivot = nums[left];
        while (left &lt; right) {
            while (left &lt; right &amp; nums[right] &gt;= pivot) {
                right--;
            }
            nums[left] = nums[right];
            while (left &lt; right &amp; nums[left] &lt; pivot) {
                left++;
            }
            nums[right] = nums[left];
        }
        nums[left] = pivot;
        return left;
    }

public:
    int findKthLargest(vector&lt;int&gt; &amp;nums, int k) {
        int size = nums.size();
        int target = size - k;

        int left = 0;
        int right = size - 1;
        while (true) {
            int p = partition(nums, left, right);
            if (p == target) {
                return nums[p];
            } else if (target &lt; p) {
                right = p - 1;
            } else {
                left = p + 1;
            }
        }
    }
};

</code></pre>
<blockquote>
<p>方法三：优先队列<br>
优先队列的思路是很朴素的。因为第 K 大元素，其实就是整个数组排序以后后半部分最小的那个元素。因此，我们可以维护一个有 K 个元素的最小堆：<br>
1、如果当前堆不满，直接添加；<br>
2、堆满的时候，如果新读到的数小于等于堆顶，肯定不是我们要找的元素，只有新都到的数大于堆顶的时候，才将堆顶拿出，然后放入新读到的数，进而让堆自己去调整内部结构。<br>
说明：这里最合适的操作其实是 replace，即直接把新读进来的元素放在堆顶，然后执行下沉（siftDown）操作。Java 当中的 PriorityQueue 没有提供这个操作，只好先 poll() 再 offer()。<br>
优先队列的写法就很多了，这里例举一下我能想到的（以下的写法大同小异，没有本质差别）。<br>
假设数组有 len 个元素。<br>
思路1：把 len 个元素都放入一个最小堆中，然后再 pop() 出 len - k 个元素，此时最小堆只剩下 k 个元素，堆顶元素就是数组中的第 k 个最大元素。<br>
思路2：把 len 个元素都放入一个最大堆中，然后再 pop() 出 k - 1 个元素，因为前 k - 1 大的元素都被弹出了，此时最大堆的堆顶元素就是数组中的第 k 个最大元素。<br>
根据以上思路，分别写出下面的代码：<br>
参考代码 5：</p>
</blockquote>
<pre><code>Java
import java.util.PriorityQueue;

public class Solution {

    public int findKthLargest(int[] nums, int k) {
        int len = nums.length;
        // 使用一个含有 len 个元素的最小堆，默认是最小堆，可以不写 lambda 表达式：(a, b) -&gt; a - b
        PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;(len, (a, b) -&gt; a - b);
        for (int i = 0; i &lt; len; i++) {
            minHeap.add(nums[i]);
        }
        for (int i = 0; i &lt; len - k; i++) {
            minHeap.poll();
        }
        return minHeap.peek();
    }
}
</code></pre>
<blockquote>
<p>参考代码 6：</p>
</blockquote>
<pre><code>Java
import java.util.PriorityQueue;

public class Solution {

    public int findKthLargest(int[] nums, int k) {
        int len = nums.length;
        // 使用一个含有 len 个元素的最大堆，lambda 表达式应写成：(a, b) -&gt; b - a
        PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;(len, (a, b) -&gt; b - a);
        for (int i = 0; i &lt; len; i++) {
            maxHeap.add(nums[i]);
        }
        for (int i = 0; i &lt; k - 1; i++) {
            maxHeap.poll();
        }
        return maxHeap.peek();
    }
}
</code></pre>
<blockquote>
<p>思路 3：只用 k 个容量的优先队列，而不用全部 len 个容量。<br>
参考代码 7：</p>
</blockquote>
<pre><code>import java.util.PriorityQueue;

public class Solution {

    public int findKthLargest(int[] nums, int k) {
        int len = nums.length;
        // 使用一个含有 k 个元素的最小堆
        PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;(k, (a, b) -&gt; a - b);
        for (int i = 0; i &lt; k; i++) {
            minHeap.add(nums[i]);
        }
        for (int i = k; i &lt; len; i++) {
            // 看一眼，不拿出，因为有可能没有必要替换
            Integer topEle = minHeap.peek();
            // 只要当前遍历的元素比堆顶元素大，堆顶弹出，遍历的元素进去
            if (nums[i] &gt; topEle) {
                minHeap.poll();
                minHeap.add(nums[i]);
            }
        }
        return minHeap.peek();
    }
}
</code></pre>
<blockquote>
<p>思路 4：用 k + 1 个容量的优先队列，使得上面的过程更“连贯”一些，到了 k 个以后的元素，就进来一个，出去一个，让优先队列自己去维护大小关系。</p>
</blockquote>
<pre><code>import java.util.PriorityQueue;

public class Solution5 {
    public int findKthLargest(int[] nums, int k) {
        int len = nums.length;
        // 最小堆
        PriorityQueue&lt;Integer&gt; priorityQueue = new PriorityQueue&lt;&gt;(k + 1, (a, b) -&gt; (a - b));
        for (int num : nums) {
            priorityQueue.add(num);
            if (priorityQueue.size() == k + 1) {
                priorityQueue.poll();
            }
        }
        return priorityQueue.peek();
    }
}
</code></pre>
<blockquote>
<p>思路 5：综合考虑以上两种情况，总之都是为了节约空间复杂度。即 k 较小的时候使用最小堆，k 较大的时候使用最大堆。、</p>
</blockquote>
<pre><code>import java.util.PriorityQueue;

public class Solution {

    // 根据 k 的不同，选最大堆和最小堆，目的是让堆中的元素更小
    // 思路 1：k 要是更靠近 0 的话，此时 k 是一个较大的数，用最大堆
    // 例如在一个有 6 个元素的数组里找第 5 大的元素
    // 思路 2：k 要是更靠近 len 的话，用最小堆

    // 所以分界点就是 k = len - k

    public int findKthLargest(int[] nums, int k) {
        int len = nums.length;
        if (k &lt;= len - k) {
            // System.out.println(&quot;使用最小堆&quot;);
            // 特例：k = 1，用容量为 k 的最小堆
            // 使用一个含有 k 个元素的最小堆
            PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;(k, (a, b) -&gt; a - b);
            for (int i = 0; i &lt; k; i++) {
                minHeap.add(nums[i]);
            }
            for (int i = k; i &lt; len; i++) {
                // 看一眼，不拿出，因为有可能没有必要替换
                Integer topEle = minHeap.peek();
                // 只要当前遍历的元素比堆顶元素大，堆顶弹出，遍历的元素进去
                if (nums[i] &gt; topEle) {
                    minHeap.poll();
                    minHeap.add(nums[i]);
                }
            }
            return minHeap.peek();

        } else {
            // System.out.println(&quot;使用最大堆&quot;);
            assert k &gt; len - k;
            // 特例：k = 100，用容量为 len - k + 1 的最大堆
            int capacity = len - k + 1;
            PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;(capacity, (a, b) -&gt; b - a);
            for (int i = 0; i &lt; capacity; i++) {
                maxHeap.add(nums[i]);
            }
            for (int i = capacity; i &lt; len; i++) {
                // 看一眼，不拿出，因为有可能没有必要替换
                Integer topEle = maxHeap.peek();
                // 只要当前遍历的元素比堆顶元素大，堆顶弹出，遍历的元素进去
                if (nums[i] &lt; topEle) {
                    maxHeap.poll();
                    maxHeap.add(nums[i]);
                }
            }
            return maxHeap.peek();
        }
    }
}
</code></pre>
<p>思路五降低空间复杂度的思维很值得学习，我本来以为大顶堆不适用，但是其实找第k大的数字也就是找第len-k+1小的数，此时如果len-k+1小于k的话完全可以用大顶堆来降低空间复杂度</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ [Linux基础] 系统服务 (daemons) （鸟哥Linux第十七章）]]></title>
        <id>https://lixin-ee.github.io//post/linux-ji-chu-xi-tong-fu-wu-daemons-niao-ge-linux-di-shi-qi-zhang</id>
        <link href="https://lixin-ee.github.io//post/linux-ji-chu-xi-tong-fu-wu-daemons-niao-ge-linux-di-shi-qi-zhang">
        </link>
        <updated>2020-01-09T13:15:09.000Z</updated>
        <content type="html"><![CDATA[<p>这个题目我纠结了许久，最后还是用的系统服务<br>
虽然鸟哥这本书的用词用语和大陆差得太远了，但是daemons翻译成系统服务确实比守护进程略微好一点，一开始我还以为守护进程是保证安全的函数。。。</p>
<ul>
<li>系统服务 (daemons)简介<br>
『常驻在记体体中的程序，且可以提供一些系统或网络功能，那就是服务』<br>
系统为了某些功能必须要提供一些服务 (不论是系统本身还是网络方面)，这个服务就称为service 。<br>
达成这个service的<strong>程序</strong>我们就称呼他为 daemon</li>
</ul>
<p>早期的Unix系统核心第一个启动的程序是 init ， 然后 init 去唤起所有的系统所需要的服务<br>
后来改用 systemd 启动服务管理机制</p>
<p>systemd 将过去所谓的 daemon 执行脚本通通称为一个服务单位 (unit)，而每种服务单位 依据功能来区分时，就分类为不同的类型 (type)。<br>
基本的类型有包括系统服务、数据监听与交换的插槽档服务 (socket)、储存系统状态的快照类型、提供不同类似执行等级分类的操作环境 (target) 等</p>
<p>配置文件都放置在底下的目录中：<br>
/usr/lib/systemd/system/：每个服务最主要的启动脚本设定，有点类似以前的 /etc/init.d 底下的文件；<br>
/run/systemd/system/：系统执行过程中所产生的服务脚本，这些脚本的优先序要比 /usr/lib/systemd/system/ 高<br>
/etc/systemd/system/：管理员依据主机系统的需求所建立的执行脚本</p>
<p>systemd 的 unit 类型分类：主要靠扩展 名来区分上述所谓的不同的类型 (type)</p>
<ul>
<li>透过 systemctl 管理服务<br>
systemd 这个启动服务的机制，主要是透过一只名为 systemctl 的指令来处理，注意， systemd 就是仅有 systemctl 这个处理指令<br>
一般来说，服务的启动有两个阶段，一 个是『开机的时候设定要不要启动这个服务』， 以及『你现在要不要启动这个服务』<br>
<code>[root@study ~]# systemctl [command] [unit]</code><br>
command 主要有：<br>
start ：立刻启动后面接的 unit<br>
stop ：立刻关闭后面接的 unit<br>
restart ：立刻关闭后启动后面接的 unit，亦即执行 stop 再 start 的意思<br>
reload ：不关闭后面接的 unit 的情况下，重载配置文件，让设定生效<br>
enable ：设定下次开机时，后面接的 unit 会被启动<br>
disable ：设定下次开机时，后面接的 unit 不会被启动<br>
status ：目前后面接的这个 unit 的状态，会列出有没有正在执行、开机预设执行否、登录等信息等！<br>
is-active ：目前有没有正在运作中<br>
is-enable ：开机时有没有预设要启用这个 unit<br>
mask：注销服务<br>
unmask：取消注销</li>
</ul>
<p>注意不应该使用 kill 的方式来关掉一个正常的服务！否则 systemctl 会无法继续监控该服务的</p>
<p>status 的Active除了running 跟 dead 之外，基本上还有几个常见的状态：<br>
active (running)：正有一只或多只程序正在系统中执行的<br>
active (exited)：仅执行一次就正常结束的服务，目前并没有任何程序在系统中执行。 通常用 bash shell 写的小型服务，大多是属于这种类型 (无须常驻内存)。<br>
active (waiting)：正在执行当中，不过还再等待其他的事件才能继续处理。举例来说，打印的队列相关服务就是这种状态<br>
inactive：这个服务目前没有运作的意思。</p>
<p>status 的Load状态除了 enable/disable之外，还有：<br>
enabled：这个 daemon 将在开机时被执行<br>
disabled：这个 daemon 在开机时不会被执行<br>
static：这个 daemon 不可以自己启动 (enable 不可)，不过可能会被其他的 enabled 的服务来唤醒 (相依属性的服务)<br>
mask：这个 daemon 无论如何都无法被启动！因为已经被强制注销 (非删除)</p>
<p>很多服务彼此之间是有相依性的,所以关闭一个服务可能会连带着关闭多个服务</p>
<ul>
<li>透过 systemctl 观察系统上所有的服务<br>
上一小节谈到的是单一服务的启动/关闭/观察，以及相依服务要注销的功能。那系统上面有多少的服务存在等任务就得要透过 list-units 及 list-unit-files 来观察了<br>
<code>[root@study ~]# systemctl [command] [ [--type=TYPE] [ --all]</code><br>
command:<br>
list-units ：依据 unit 列出目前有启动的 unit。若加上 --all 才会列出没启动的。<br>
list-unit-files ：依据 /usr/lib/systemd/system/ 内的文件，将所有文件列表说明。<br>
--type=TYPE：就是之前提到的 unit type，主要有 service, socket, target 等</li>
</ul>
<p>list-units（默认） 输出列表中各项主要的意义是：<br>
UNIT ：项目的名称，包括各个 unit 的类别 (看扩展名)<br>
LOAD ：开机时是否会被加载，默认 systemctl 显示的是有加载的项目而已<br>
ACTIVE ：目前的状态，须与后续的 SUB 搭配，就是我们用 systemctl status 观察时active 的项目<br>
DESCRIPTION ：详细描述啰</p>
<p>systemctl list-unit-files 会将系统上所有的服务通通列出来～而不像 list-units 仅以 unit 分类作大致的说明。列表中的 STATE 状态就是前两个小节谈到的开机是否会加载的那个状态项目，主要有enabled / disabled / mask / static 等等。</p>
<ul>
<li>透过 systemctl  管理不同的操作环境 (target unit)<br>
<code>[root@study ~]# systemctl [command] [unit.target]</code><br>
选项与参数：<br>
command:<br>
get-default ：取得目前的 target<br>
set-default ：设定后面接的 target 成为默认的操作模式<br>
isolate       ：切换到后面接的模式</li>
</ul>
<p>CentOS 7.1 的预设情况下，就有 26 个 target unit，而跟操作界面相关性比较高的target 主要有底下几个：<br>
graphical.target：就是文字加上图形界面，这个项目已经包含了底下的 multi-user.target 项目<br>
multi-user.target：纯文本模式<br>
rescue.target：在无法使用 root 登入的情况下，systemd 在开机时会多加一个额外的暂时系统，与你原本的系统无关。这时你可以取得 root 的权限来维护你的系统。 但是这是额外系统，因此可能需要动到 chroot 的方式来取得你原有的系统喔<br>
emergency.target：紧急处理系统的错误，还是需要使用 root 登入的情况，在无法使用 rescue.target 时，可以尝试使用这种模式<br>
shutdown.target：就是关机的流程。<br>
getty.target：可以设定你需要几个 tty 之类的，如果想要降低 tty 的项目，可以修改这个东西的配置文件</p>
<p>在正常的切换情况下，使用上述 isolate 的方式即可。不过为了方便起见，systemd 也提供了数个简单的指令给我们切换操作模式之用<br>
systemctl poweroff 系统关机<br>
systemctl reboot 重新启动<br>
systemctl suspend 进入暂停模式<br>
systemctl hibernate 进入休眠模式<br>
systemctl rescue 强制进入救援模式<br>
systemctl emergency 强制进入紧急救援模式</p>
<ul>
<li>
<p>透过 systemctl  分析各服务之间的相依<br>
<code>[root@study ~]# systemctl list-dependencies [unit] [ --reverse]</code><br>
选项与参数：<br>
--reverse ：反向追踪谁使用这个 unit</p>
</li>
<li>
<p>与 systemd  的 daemon 运作过程相关的目录简介<br>
/usr/lib/systemd/system/：<br>
默认的启动脚本配置文件都放在这里，这里的数据尽量不要修改<br>
/run/systemd/system/：<br>
系统执行过程中所产生的服务脚本<br>
/etc/systemd/system/：<br>
管理员依据主机系统的需求所建立的执行脚本<br>
/etc/sysconfig/* ：<br>
几乎所有的服务都会将初始化的一些选项设定写入到这个目录下<br>
/var/lib/：<br>
一些会产生数据的服务都会将他的数据写入到 /var/lib/ 目录中。<br>
/run/：<br>
放置了好多 daemon 的暂存档，包括 lock file 以及 PID file 等等。</p>
</li>
</ul>
<p>通过<code>[root@study ~]# systemctl list-socket</code>查询 socket file 放置在哪里</p>
<ul>
<li>
<p>网络服务与端口口对应简介<br>
主机是透过端口号 (port number) 分辨不同的服务要求<br>
/etc/services 指定了服务与哪个端口对应，可以直接用<code>cat /etc/services</code>查询</p>
</li>
<li>
<p>关闭网络服务<br>
会产生一个网络监听端口 (port) 的程序，就可以称为网络服务<br>
可以通过  <code>systemctl stop[unit]</code>或者<code>systemctl disable [unit]</code> 来关闭</p>
</li>
<li>
<p>systemctl  针对 service 类型的配置文件<br>
systemctl 配置文件的设定项目简介<br>
整个设定分为三个部份，就是：<br>
[Unit]： unit 本身的说明，以及与其他相依 daemon 的设定，包括在什么服务之后才启动此 unit 之类的设<br>
定值；<br>
[Service], [Socket], [Timer], [Mount], [Path]..：不同的 unit type 就得要使用相对应的设定项目。我们拿的是<br>
sshd.service 来当模板，所以这边就使用 [Service] 来设定。 这个项目内主要在规范服务启动的脚本、环境<br>
配置文件档名、重新启动的方式等等。<br>
[Install]：这个项目就是将此 unit 安装到哪个 target 里面去</p>
</li>
</ul>
<p>配置文件内有些设定规则还是得要说明一下：<br>
设定项目通常是可以重复的，例如我可以重复设定两个 After 在配置文件中，不过，后面的设定会取代前面，因此，如果你想要将设定值归零， 可以使用类似『 After= 』的设定，亦即该项目的等号后面什么都没有，就将该设定归零了 (reset)。<br>
如果设定参数需要有『是/否』的项目 (布尔值, boolean)，你可以使用 1, yes, true, on 代表启动，用 0, no, false,off 代表关闭<br>
空白行、开头为 # 或 ; 的那一行，都代表批注</p>
<p>systemctl  针对 timer   的配置文件</p>
<p>CentOS 7.x 预设启动的服务简易说明<br>
使用 systemctl list-unit-files--type=service 查询<br>
部分服务上简易说明<br>
dovecot<br>
( 网络)可以设定 POP3/IMAP 等收受信件的服务，如果你的 Linux 主机是 email server 才需要这个服务，否则不需要启动<br>
httpd ( 网络)<br>
这个服务可以让你的 Linux 服务器成为 www server 喔！<br>
named<br>
( 网络)这是领域名服务器 (Domain Name System) 的服务， 这个服务非常重要，但是设定非常困难，目前应该不需要这个服务<br>
nfs nfs-server<br>
( 网络)这就是 Network Filesystem，是 Unix-Like 之间互相作为网络驱动器机的一个功能。<br>
smb<br>
nmb<br>
( 网络)这个服务可以让 Linux 仿真成为 Windows 上面的网络上的芳邻。 如果你的 Linux 主机想要<br>
做为 Windows 客户端的网络驱动器机服务器，这玩意儿得要好好玩一玩。<br>
vsftpd ( 网络)作为文件传输服务器 (FTP) 的服务。<br>
sshd<br>
( 网络)这个是远程联机服务器的软件功能， 这个通讯协议比 telnet 好的地方在于 sshd 在传送资料时可以进行加密，这个服务不要关闭<br>
rpcbind ( 网络)达成 RPC 协议的重要服务，包括 NFS, NIS 等等都需要这东西的协助<br>
postfix<br>
( 网络)寄件的邮件主机～因为系统还是会产生很多 email 讯息，例如 crond / atd 就会传送 email给本机用户！ 所以这个服务千万不能关，即使你不是 mail server 也是要启用这服务才行</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UNP-UNIX网络编程 第四章]]></title>
        <id>https://lixin-ee.github.io//post/unp-unix-wang-luo-bian-cheng-di-si-zhang</id>
        <link href="https://lixin-ee.github.io//post/unp-unix-wang-luo-bian-cheng-di-si-zhang">
        </link>
        <updated>2020-01-09T12:45:33.000Z</updated>
        <content type="html"><![CDATA[<p>主要讲述编写一个完整的TCP客户/服务器程序所需要的基本套接字函数<br>
并发服务器：它是在同时有大量的客户连接到同一服务器上时用于提供并发性的一种常用Unix技术。每个客户连接都迫使服务器为它派生（fork） 一个新的进程。</p>
<p><img src="https://lixin-ee.github.io//post-images/1578574785629.png" alt=""></p>
<ul>
<li>socket 函数<br>
为了执行网络I/O, 一个进程必须做的第一件事情就是调用socket函数，指定期望的通信协议类型</li>
</ul>
<pre><code>#include &lt;sys/socket.h&gt;
int socket （int family, int type, int protocol）;
</code></pre>
<p>返回：若成功则为非负描述符，若出错则为-1<br>
family参数指明协议族，type 参数指明套接字类型，protocol参数应设为图4-4所示的某个协议 类型常值，或者设为0,以选择所给定family和type组合的系统默认值。<br>
<img src="https://lixin-ee.github.io//post-images/1578574917564.png" alt=""><br>
<img src="https://lixin-ee.github.io//post-images/1578574720688.png" alt=""><br>
socket函数在成功时返回一个小的非负整数值，它与文件描述符类似，我们把它称为套接字描述符（socket descriptor）,简称sockfd。<br>
我们并没有指定本地协议地址或远程协议地址<br>
AF_XXX 和 PF_XXX，AF_前缀表示地址族，PF一前缀表示协议族</p>
<ul>
<li>connect 函数<br>
TCP客户用connect函数来建立与TCP服务器的连接。</li>
</ul>
<pre><code>#include &lt;sys/socket.h&gt;
int connect （int sockfd, const struct sockaddr *servaddr, socklen_t addrlen）;
</code></pre>
<p>sockfd是由socket函数返回的套接字描述符，第二个、第三个参数分别是一个指向套接字地址结构的指针和该结构的大小<br>
套接字地址结构必须含有服务器的IP地址和端口号。<br>
<strong>客户</strong>在调用函数connect前不必非得调用bind函数，因为如果 需要的话，内核会确定源IP地址，并选择一个临时端口作为源端口。<br>
如果是TCP套接字，调用connect函数将激发TCP的三路握手过程<br>
其中连接出错返回可能有以下几种情况<br>
（1）	若TCP客户没有收到SYN分节的响应，则返回ETIMEDOUT错误。<br>
（2）	若对客户的SYN的响应是RST （表示复位），则表明该服务器主机在我们指定的端口上 没有进程在等待与之连接（例如服务器进程也许没在运行）。这是一种硬错误（hard error）.客户一接收到RST就马上返回ECONNREFUSED错误。<br>
RST是TCP在发生错误时发送的一种TCP分节。产生RST的三个条件是：目的地为某端口的 SYN到达，然而该端口上没有正在监听的服务器（如前所述）；TCP想取消一个己有连接；TCP 接收到一个根本不存在的连接上的分节。<br>
（3）若客户发出的SYN在中间的某个路由器上引发了一个“destination unreachable &quot;（目的地 不可达）ICMP错误，则认为是一种软错误（soft error）<br>
客户主机内核保存该消息，并按第一种情况中所述的时间间隔继续发送SYN。若在某个规定的时间（4.4BSD规定75s）后仍未收到响应，则把保存的消息（即ICMP错误）作为EHOSTUNREACH或ENETUNREACH错误返回给进程。<br>
以下两种情形也是有可能的：一是按照本地系统的转发表，根本没有到达远程系统的路径；二是 connect调用根本不等待就返回。</p>
<p>注意区分情况2和情况3，一个是到达了目的地址，但是不存在相应的端口，一个是根本没法到达目的地址</p>
<p><strong>注意！！！</strong><br>
若connect失败则该<strong>套接字不再可用，必须关闭</strong>，我们<strong>不能对这样的套接字再次调用connect函数</strong>。当循环调用函数connect为给定主机尝试 各个IP地址直到有一个成功时，在每次connect失败后，都必须close当前的套接字描述符并重新调用socket。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 148. 排序链表[中等][未做出][值得手撕]]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-148-pai-xu-lian-biao-zhong-deng-wei-zuo-chu-zhi-de-shou-si</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-148-pai-xu-lian-biao-zhong-deng-wei-zuo-chu-zhi-de-shou-si">
        </link>
        <updated>2020-01-09T01:19:20.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。<br>
示例 1:<br>
输入: 4-&gt;2-&gt;1-&gt;3<br>
输出: 1-&gt;2-&gt;3-&gt;4<br>
示例 2:<br>
输入: -1-&gt;5-&gt;3-&gt;4-&gt;0<br>
输出: -1-&gt;0-&gt;3-&gt;4-&gt;5<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/sort-list<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>【未做出】【值得手撕】<br>
主要难点在于常数空间复杂度和时间复杂度之间的制约吧<br>
一开始甚至想交换val hhh<br>
nlogn的排序算法有堆排序 归并排序和快速排序<br>
堆排序虽然显示无需额外的空间，但是实际上只有在完全二叉树能够满足随机访问的情况下才能实现，也就是必须要数组下标 在链表中反而需要一次循环<br>
然后就是归并排序 归并排序的核心在于把两个序列合成一个序列 数组中需要额外的空间进行合并，但是链表的特性却可以省略这一部分，所以打算实现一下链表的归并排序<br>
首先我想到的难点在于需要一个保留一个头结点，然后因为无法使用随机下标，所以迭代的归并排序比递归的好</p>
<p>实现的过程中遇到了比较多细节问题，所以打算先参考一下网友题解的实现方法。主要就是分开merge 和 cut 两个函数进行合并和切割<br>
我一开始比较困惑tail的作用，一开始以为是没用的，但是后来才发现是大大的用处，因为cut切断后，merge创建一个ehead来自成一个链表，后面得串回来，就是利用tail-&gt;next串回来的<br>
注意tail虽然全程看起来只是对自身进行操作，但是链表的next指针特性决定了其当前值，所以并非所看到的的那么简单，一定动手画图了解<br>
然后merge返回值和cut返回值需要额外注意，merge返回值是一个头结点，需要和tail配合，这里的话其实可以优化返回一个尾节点直接串起来，但是相应地需要循环去找尾节点，其实差不多。cur的返回值是尾节点的下一节点，所以需要提前保存，因为要切断。<br>
然后就是对空节点的判断，代码中没有针对right为空的情况进行判断，而是主要利用不同位置的while进行间接判断，所以代码的整体性也很重要。</p>
<p>题解实现代码</p>
<pre><code>class Solution {
public:
    ListNode* sortList(ListNode* head) {
        ListNode *ehead=new ListNode(0);
        ehead-&gt;next=head;
        int step=1;
        int len=0;
        for(ListNode *p=head;p!=NULL;p=p-&gt;next)
            ++len;
        ListNode *cur=ehead-&gt;next,*tail=ehead;;
        while(step&lt;len){
            while(cur!=NULL){
                ListNode *left=cur;
                cur=cut(left,step);
                ListNode *right=cur;
                cur=cut(right,step);
                tail-&gt;next=merge(left,right);
                while (tail-&gt;next!=NULL) {
                    tail = tail-&gt;next;
                }
            }
            cur=ehead-&gt;next;
            tail=ehead;
            step*=2;
        }
        return ehead-&gt;next;
    }
		
	ListNode* cut(ListNode *cur,int step){
        while(--step&amp;&amp;cur)
            cur=cur-&gt;next;
        if(!cur) return cur;
        
        ListNode *temp=cur-&gt;next;
        cur-&gt;next=NULL;
        return temp;
    }
    
    ListNode* merge(ListNode *left,ListNode *right){
        ListNode *ehead=new ListNode(0);
        ListNode *cur=ehead;
        while(left&amp;&amp;right){
            if(left-&gt;val&lt;=right-&gt;val){
                cur-&gt;next=left;
                left=left-&gt;next;
            }else{
                cur-&gt;next=right;
                right=right-&gt;next;
            }
            cur=cur-&gt;next;         
        }
        cur-&gt;next=left?left:right;
        return ehead-&gt;next;
    }
</code></pre>
<p>然后来看看详细的网友题解：</p>
<blockquote>
<p>bottom-to-up 的归并思路是这样的：先两个两个的 merge，完成一趟后，再 4 个4个的 merge，直到结束。举个简单的例子：[4,3,1,7,8,9,2,11,5,6].<br>
step=1: (3-&gt;4)-&gt;(1-&gt;7)-&gt;(8-&gt;9)-&gt;(2-&gt;11)-&gt;(5-&gt;6)<br>
step=2: (1-&gt;3-&gt;4-&gt;7)-&gt;(2-&gt;8-&gt;9-&gt;11)-&gt;(5-&gt;6)<br>
step=4: (1-&gt;2-&gt;3-&gt;4-&gt;7-&gt;8-&gt;9-&gt;11)-&gt;5-&gt;6<br>
step=8: (1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;9-&gt;11)<br>
链表里操作最难掌握的应该就是各种断链啊，然后再挂接啊。在这里，我们主要用到链表操作的两个技术：<br>
merge(l1, l2)，双路归并，我相信这个操作大家已经非常熟练的，就不做介绍了。<br>
cut(l, n)，可能有些同学没有听说过，它其实就是一种 split 操作，即断链操作。不过我感觉使用 cut 更准确一些，它表示，将链表 l 切掉前 n 个节点，并返回后半部分的链表头。<br>
额外再补充一个 dummyHead 大法，已经讲过无数次了，仔细体会吧。<br>
希望同学们能把双路归并和 cut 断链的代码烂记于心，以后看到类似的题目能够刷到手软。<br>
掌握了这三大神器后，我们的 bottom-to-up 算法伪代码就十分清晰了：</p>
</blockquote>
<pre><code>current = dummy.next;
tail = dummy;
for (step = 1; step &lt; length; step *= 2) {
	while (current) {
		// left-&gt;@-&gt;@-&gt;@-&gt;@-&gt;@-&gt;@-&gt;null
		left = current;

		// left-&gt;@-&gt;@-&gt;null   right-&gt;@-&gt;@-&gt;@-&gt;@-&gt;null
		right = cut(current, step); // 将 current 切掉前 step 个头切下来。

		// left-&gt;@-&gt;@-&gt;null   right-&gt;@-&gt;@-&gt;null   current-&gt;@-&gt;@-&gt;null
		current = cut(right, step); // 将 right 切掉前 step 个头切下来。
		
		// dummy.next -&gt; @-&gt;@-&gt;@-&gt;@-&gt;null，最后一个节点是 tail，始终记录
		//                        ^
		//                        tail
		tail.next = merge(left, right);
		while (tail-&gt;next) tail = tail-&gt;next; // 保持 tail 为尾部
	}
}
</code></pre>
<blockquote>
<p>下面是比较正式的代码。</p>
</blockquote>
<pre><code>class Solution {
public:
    ListNode* sortList(ListNode* head) {
        ListNode dummyHead(0);
        dummyHead.next = head;
        auto p = head;
        int length = 0;
        while (p) {
            ++length;
            p = p-&gt;next;
        }
        
        for (int size = 1; size &lt; length; size &lt;&lt;= 1) {
            auto cur = dummyHead.next;
            auto tail = &amp;dummyHead;
            
            while (cur) {
                auto left = cur;
                auto right = cut(left, size); // left-&gt;@-&gt;@ right-&gt;@-&gt;@-&gt;@...
                cur = cut(right, size); // left-&gt;@-&gt;@ right-&gt;@-&gt;@  cur-&gt;@-&gt;...
                
                tail-&gt;next = merge(left, right);
                while (tail-&gt;next) {
                    tail = tail-&gt;next;
                }
            }
        }
        return dummyHead.next;
    }
    
    ListNode* cut(ListNode* head, int n) {
        auto p = head;
        while (--n &amp;&amp; p) {
            p = p-&gt;next;
        }
        
        if (!p) return nullptr;
        
        auto next = p-&gt;next;
        p-&gt;next = nullptr;
        return next;
    }
    
    ListNode* merge(ListNode* l1, ListNode* l2) {
        ListNode dummyHead(0);
        auto p = &amp;dummyHead;
        while (l1 &amp;&amp; l2) {
            if (l1-&gt;val &lt; l2-&gt;val) {
                p-&gt;next = l1;
                p = l1;
                l1 = l1-&gt;next;       
            } else {
                p-&gt;next = l2;
                p = l2;
                l2 = l2-&gt;next;
            }
        }
        p-&gt;next = l1 ? l1 : l2;
        return dummyHead.next;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[接口和函数的区别]]></title>
        <id>https://lixin-ee.github.io//post/jie-kou-he-han-shu-de-qu-bie</id>
        <link href="https://lixin-ee.github.io//post/jie-kou-he-han-shu-de-qu-bie">
        </link>
        <updated>2020-01-08T23:56:06.000Z</updated>
        <content type="html"><![CDATA[<p>以前我以为接口就是给客户调用的函数，看了muduo和设计模式后才发现不是这样的<br>
以简单工厂模式为例子，接口就可以是算法派生出来的加减乘除法这个都是给客户调用的接口，实现了特定的功能<br>
而muduo中提出不要用设计模式中使用虚函数提供接口的方法，因为虚函数的正确调用完全依赖与virtual table的offset，一改动二进制兼容就木大了<br>
然后注意虚函数不是纯虚函数，不用子类必须override，而是子类可以选择性根据自身实现的功能进行override</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ UNP-UNIX网络编程 第三章]]></title>
        <id>https://lixin-ee.github.io//post/unp-unix-wang-luo-bian-cheng-di-san-zhang</id>
        <link href="https://lixin-ee.github.io//post/unp-unix-wang-luo-bian-cheng-di-san-zhang">
        </link>
        <updated>2020-01-08T12:57:36.000Z</updated>
        <content type="html"><![CDATA[<p>套接字地址结构从进程到内核和从内核到进程。<br>
地址转换函数在地址的文本表达和它们存放在套接字地址结构中的二进制值之间进行转换。<br>
地址转换函数在地址的文本表达和它们存放在套接字地址结构中的二进制值之间进行转换。多数现存的IPv4代码使用inet_addr和inet_ntoa这两个函数，不过两个新函数inet_pton 和i net_ntop同时适用于IPv4和IPv6两种代码。</p>
<p>注意 本书中为了克服函数对于IPv4和IPv6两种协议的协议相关问题，开发了一组名字以sock_开头的函数，它们以协议无关方式使用套接字地址结构。并贯穿全书使用这组函数。</p>
<ul>
<li>IPv4套接字地址结构<br>
IPv4套接字地址结构通常也称为&quot;网际套接字地址结构”，它以sockaddr_in命名，定义在 &lt;netinet/in.h&gt;头文件中。<br>
<img src="https://lixin-ee.github.io//post-images/1578488858968.png" alt=""><br>
POSIX规范只需要设置这个结构中的3个字段：<strong>sin_family, sin_addr和sin_port。</strong><br>
相对应地，他们的类型是：<br>
sa_family_t可以是任何无符号整数类型，通常是一个8位的无符号整数<br>
in_addr_t数据 类型必须是一个至少32位的无符号整数类型<br>
in_port_t必须是-个至少16位的无符号 整数类型<br>
<img src="https://lixin-ee.github.io//post-images/1578489062325.png" alt=""></li>
</ul>
<p>注意！IPv4地址和TCP或UDP端口号在套接字地址结构中总是以<strong>网络字节序（大端序）</strong> 来存储。<br>
32位IPv4地址存在<strong>两种不同的访问方法</strong>。<br>
举例来说，如果serv定义为某个网际套接字地址结构，那么serv. sin_addr将按<strong>in_addr结构</strong>引用其中的32位IPv4地址，而serv.sin_addr.s_addr将按<strong>in_addr_t整数</strong>（通常是一个无符号的32位整数）引用同—个32位IPv4地址。因此，我们必须正确地使用IPv4地址，尤其是在将它作为函数的参数时， 因为编译器对<strong>传递结构</strong>和<strong>传递整数</strong>的处理是完全不同的。<br>
套接字地址结构仅在给定主机上使用：虽然结构中的某些字段（例如IP地址和端口号） 用在不同主机之间的通信中，但是结构本身并不在主机之间传递。</p>
<ul>
<li>
<p>值-结果参数<br>
当往一个套接字<strong>函数</strong>传递一个套接字地址<strong>结构</strong>时，该结构总是以<strong>引用</strong>形式来 传递，也就是说传递的是指向该结构的一个<strong>指针</strong>。该结构的长度也作为一个参数来传递，不过其传递方式取决于该结构的<strong>传递方向</strong>：是从进程到内核，还是从内核到进程。<br>
(1)	从进程到内核传递套接字地址结构的函数有3个：bind、connect和sendto。这些函数 的一个参数是指向某个套接字地址结构的指针，另一个参数是该结构的整数大小（套接字地址结构大小的数据类型实际上是socklen.t,而不是int）<br>
(2)	从内核到进程传递套接字地址结构的函数有4个：accepts、recvfrom、getsockname 和getpeernameo。这4个函数的其中两个参数是指向某个套接字地址结构的指针和指向表示该结构大小的整数变量的指针。<br>
<img src="https://lixin-ee.github.io//post-images/1578489792892.png" alt=""><br>
注意！！！函数调用时，结构大小<strong>只是一个希望的值</strong>，当函数返回时，结构大小又是一个<strong>实际大小的结果(result)</strong>,它告诉进程内核在该结构中<strong>究竞存储了多少信息</strong>。这种类型的参数称为值-结果(value-result)参数。</p>
</li>
<li>
<p>字节排序函数、大端序、小端序<br>
小端 和 大端 表示多个字节值的哪一端(小端或大端)存储在该值的起始 地址.<br>
低序字节存储在起始地址，这称为小端（little-endian）字节序；<br>
另一种方法是将高序字节存储在起 始地址，这称为大端（big-endian）字节序。<br>
<strong>记忆方法</strong>：大端序就是我们日常的<strong>书写顺序</strong>（在纸上（内存）写一个数字，先写高位再写地位），小端序则是反过来</p>
</li>
</ul>
<p>当前系统所用的字节序称为主机字节序(host byte order)<br>
<img src="https://lixin-ee.github.io//post-images/1578490222230.png" alt=""><br>
网络协议必须指定一个网络字节序（network byte order），网际协议使用<strong>大端字节序</strong>来传送这些多字节整数。<br>
套接字地址结构中的某些字 段必须按照网络字节序进行维护。<br>
两种字节序之间的转换使用以下4个函数。<br>
<img src="https://lixin-ee.github.io//post-images/1578490503887.png" alt=""><br>
h代表host, n代表network, s代表short, l代表long</p>
<p>注意：当使用这些函数时，我们并不关心主机字节序和网络字节序的真实值（或为大端，或为小端）。我们所要做的只是调用适当的函数在主机和网络字节序之间转换某个给定值。在那些与网际协议所用字节序（大端）相同的系统中，这四个函数通常被定义为空宏。（一句话，为求保险（优雅地说是提高可移植性），默认调用转换就完事了）</p>
<ul>
<li>
<p>字节操纵函数<br>
操纵多字节字段的函数有两组，主要用于处理套接字地址<strong>结构</strong>（原因是结构并不全是字符串）<br>
<img src="https://lixin-ee.github.io//post-images/1578490776599.png" alt=""><br>
本书中我们只使用bzero，bzero把目标字节串中指定数目的字节置为0。我们经常使用该函数来把一个<strong>套接字地址结构</strong>初始化为0。<br>
bcopy将指定数目的字节从源字节串移到目标字节串。bcmp比较两个任意的字节 串，若相同则返回值为0,否则返回值为非0。<br>
<img src="https://lixin-ee.github.io//post-images/1578490880005.png" alt=""><br>
memset把目标字节串指定数目的字节置为值c。memcpy类似bcopy,不过两个指针参数的顺序是相反的。<br>
memcmp比较两个任意的字节串，若相同则返回0,否则返回一个非0值，是大于0还是小于0 则取决于第一个不等的字节</p>
</li>
<li>
<p>inet_aton、inet_addr 和 inet_ntoa 函数<br>
函数名中a和n分别代表ASCII和数值(numeric)<br>
地址转换函数：在ASCII字符串与网络字节序的二进制值之间转换网际地址。<br>
（1）inet_aton、inet_addr 和 inet_ntoa在点分十进制数组（例如&quot;206.168. 112.96&quot;） 与它长度为32位的网络字节序二进制值间转换IPv4地址。<br>
（2）	两个较新的函数inet_pton和inet_ntop对于IPv4地址和IPv6地址都适用。<br>
<img src="https://lixin-ee.github.io//post-images/1578491193169.png" alt=""><br>
inet_aton将strptr所指C字符串转换成一个32位的网络字节序二进制值，并通过指针addrptr来存储。若成功返回1,否则返回0。（如果addrptr指针为空，那么该函数仍 然对输入的字符串执行有效性检查，但是不存储任何结果）<br>
inet_ntoa函数将一个32位的网络字节序二进制IPv4地址转换成相应的点分十进制数串。 由该函数的返回值所指向的字符串驻留在静态内存中。这意味着该函数是<strong>不可重入</strong>的<br>
<strong>（inet_addr已被废弃，新的代码应该改用inet_aton函数）</strong> inet_addr进行相同的转换，返回值为32位的网络字节序二进制值。当出错时该函 数返回INADDR_NONE常值（通常是一个<strong>32位均为1的值</strong>）。这意味着点分十进制数串 255.255.255.255 （这是IPv4的有限广播地址）不能由该函数处理，因为它的二进制值被用来指示该函数失败。</p>
</li>
<li>
<p>inet pton 和 inet ntop 函数<br>
函数名中p和n分别代表表达(presentation)和数值(numeric)<br>
地址的表达格式通常是ASCII字符串，数值格式则是存放到套接字地址结构中的二进制值。<br>
<img src="https://lixin-ee.github.io//post-images/1578491510912.png" alt=""><br>
这两个函数family参数既可以是AF_INET,也可以是AF_INET6。如果以不被支持的地址族作为family参数,这两个函数就都返回一个错误，并将errno置为EAFNOSUPPORT。<br>
第一个函数尝试转换由strptr指针所指的字符串，并通过odd中addrptr指针存放二进制结果。成 功则返回值为1,否则返回 值为0。<br>
inet_ntop进行相反的转换，从数值格式(addrptr)转换到表达格式(strptr)。<br>
len参数是目标存储单元的大小，以免该函数溢出其调用者的缓冲区。如果len太小，不足以容纳表达格式结果(包括结尾的空字符)，那么返回一个空指针，并置errno为ENOSPC。<br>
inet_ntop函数的strptr参数不可以是一个空指针。调用者必须为目标存储单元分配内存并指定其大小。调用成功时，这个指针就是该函数的返回值。<br>
<img src="https://lixin-ee.github.io//post-images/1578491749818.png" alt=""></p>
</li>
<li>
<p>sock_ntop和相关函数<br>
inet_ntop的一个基本问题是：它要求调用者传递一个指向某个二进制地址的指针，而该 地址通常包含在一个套接字地址结构中，这就要求调用者必须知道这个结构的格式和地址族。这就使得我们的代码与协议相关了。<br>
为了解决这个问题，我们将自行编写一个名为sockntop的函数，它以指向某个套接字地 址结构的指针为参数，查看该结构的内部，然后调用适当的函数返回该地址的表达格式。<br>
<img src="https://lixin-ee.github.io//post-images/1578491955024.png" alt=""><br>
sockaddr指向一个长度为addrlen的套接字地址结构，本函数用它自己的静态缓冲区来保存 结果，而指向该缓冲区的一个指针就是它的返回值。<br>
<strong>对结果进行静态存储导致该函数不可重入且非线程安全.</strong></p>
</li>
</ul>
<p>书中还为操作套接字地址结构定义了其他几个函数，它们将简化我们的代码在IPv4与IPv6 之间的移植。<br>
<img src="https://lixin-ee.github.io//post-images/1578492138671.png" alt=""><br>
<img src="https://lixin-ee.github.io//post-images/1578492154760.png" alt=""></p>
<ul>
<li>readn, writen 和 readline 函数<br>
字节流套接字（例如TCP套接字）上的read和write函数所表现的行为不同于通常的文件 I/O。经常会出现输入或输出的字节数可能<strong>比请求的数量少</strong>，原因在于内核中用于套接字的缓冲区可能已达到了极限。此时所需的 是调用者<strong>多次调用</strong>read或write函数，以输入或输出剩余的字节。<br>
这个现象在read一个字节流套接字时很常 见，但是在write 一个字节流套接字时只能在该套接字为<strong>非阻塞</strong>的前提下才出现。（阻塞情况下一直阻塞知道发送完成）<br>
书中为了防止出现这种情况 ，不让实现返回一个不足的字节计数值，编写了writen函数来取代write函数。<br>
当出现输入或输出的字节数少于请求字节数时，会产生ETNTR错误（表示系统调用被一个捕获的信号中断） ，如果发生该错误则继续进行readn, writen 的读或写操作。<br>
注意，如果每读一个字节的数据就调用一次系统的read函数。这是非常低效 率的，但是不能因此改用标准I/O函数库（称为stdio），究其原因在于stdio提供的默认缓冲区的状态是不可见 的</li>
</ul>
<p>良好的防御 性编程（defensiveprogramming）技术要求这些程序不仅能够期望它们的对端程序也遵循相同的 网络协议，而且能够检查出未预期的网络数据传送并加以修正（恶意企图自然也被检查出来）， 这样使得网络应用能够从存在问题的网络数据传送中恢复，可能的话还会继续工作。</p>
<p>所以在readn中使用stdio来缓冲数据提升 性能违背了这些目标，这样的应用进程在任何时刻都没有办法分辨 stdio缓冲区中是否持有未预期的数据。<br>
所以！<strong>依照缓冲区而不是文本行的要求来考虑编程</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 238. 除自身以外数组的乘积 [中等][未做出]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-238-chu-zi-shen-yi-wai-shu-zu-de-cheng-ji-zhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-238-chu-zi-shen-yi-wai-shu-zu-de-cheng-ji-zhong-deng-wei-zuo-chu">
        </link>
        <updated>2020-01-07T14:34:36.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。<br>
示例:<br>
输入: [1,2,3,4]<br>
输出: [24,12,8,6]<br>
说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。<br>
进阶：<br>
你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/product-of-array-except-self<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>【未做出】<br>
第一眼：很简单嘛，利用前一个的值不就行了嘛！然后突然发现不能用除法hhh<br>
然后第二个难点在于线性时间复杂度，那就说明不能每个元素单独进行计算，比如1的时候算2x3x4 2的时候算1x3x4。必须把计算结果重复利用起来</p>
<p>完全没思路啊！！！时间复杂度一直没想好是怎么降低到线性，而且也没有常数空间复杂度的想法，好菜啊！！！<br>
偷看题解发现是左积和右积？<br>
不是很懂<br>
看完题解后才发现太秀了吧<br>
我有一个问题是忘了使用输出数组这个空间和线性时间复杂度不一定是一次n，可以多次n的嘛<br>
不过题解的思想确实是很巧妙<br>
然后我在复现题解的时候用了for范围语句和for+迭代器，结果忘了要同时读取res和nums，结果全部木大hhh。下标发看起来很复杂但还是最通用的</p>
<p>网友题解实现</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) {
        int len=nums.size();
        vector&lt;int&gt; res(len,1);
        int k=1;
        for(auto i=0;i&lt;len;++i){
            res[i]=res[i]*k;
            k*=nums[i];
        }
        k=1;
        for(auto i=len-1;i&gt;=0;--i){
            res[i]=res[i]*k;
            k*=nums[i];
        }
        return res;
    }
};
</code></pre>
<p>网友题解<br>
乘积 = 当前数左边的乘积 * 当前数右边的乘积</p>
<pre><code>class Solution {
    public int[] productExceptSelf(int[] nums) {
        int[] res = new int[nums.length];
        int k = 1;
        for(int i = 0; i &lt; res.length; i++){
            res[i] = k;
            k = k * nums[i]; // 此时数组存储的是除去当前元素左边的元素乘积
        }
        k = 1;
        for(int i = res.length - 1; i &gt;= 0; i--){
            res[i] *= k; // k为该数右边的乘积。
            k *= nums[i]; // 此时数组等于左边的 * 该数右边的。
        }
        return res;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ UNP-UNIX网络编程 第二章]]></title>
        <id>https://lixin-ee.github.io//post/unp-unix-wang-luo-bian-cheng-di-er-zhang</id>
        <link href="https://lixin-ee.github.io//post/unp-unix-wang-luo-bian-cheng-di-er-zhang">
        </link>
        <updated>2020-01-07T13:21:19.000Z</updated>
        <content type="html"><![CDATA[<p>传输层：TCP、UDP<br>
出于工程实用性考虑，不考虑SCTP</p>
<ul>
<li>
<p>网络协议示例<br>
IPv4 网际协议版本4 (Internet Protocol version 4).：IPv4 (通常称之为IP)，一直是网际协议族的主力协议。它使用32位地址。 IPv4给TCP、UDP, SCTPs ICMP和IGMP提供分组递送服务。<br>
TCP 传输控制协议(Transmission Control Protocol)：TCP是一个面向连接的协议， 为用户进程提供可靠的全双工字节流。TCP套接字是一种流套接字(stream socket)。TCP关心确认、超时和重传之类的细节。大多数因特网应用程序使用 TCP。注意，TCP既可以使用IPv4,也可以使用IPv6.<br>
UDP 用户数据报协议(User Datagram Protocol) ：UDP是一个无连接协议。UDP套接字是一种数据报套接字(datagram socket)。 UDP数据报不能保证最终到达它们 的目的地。与TCP一样，UDP既可以使用IPv4,也可以使用IPv6。<br>
ICMP 网际控制消息协议(Internet Control Message Protocol)：ICMP处理在路由器和 主机之间流通的错误和控制消息。这些消息通常由TCP/IP网络支持软件本身</p>
</li>
<li>
<p>用户数据报协议(UDP)<br>
应用进程往一个 UDP套接字写入一个消息，该消息随后被封装(encapsulating)到一个UDP数据报，该UDP数据报进而又被封装到一个IP数据报，然后发送到目的地。<br>
UDP不保证UDP数据报会到达其最终目的地，不保证各个数据报的先后顺序跨网络后保持不变，也不保证每个数据报只到达一次。<br>
每个UDP数据报都有一个长度。如果一个数据报正确地到达其目的地，那么该数据报的长度将随数据一道传递给接收端应用进程。我们巳经提到过TCP是一个字节流(byte-stream)协议， 没有任何记录边界，这一点不同于UDP。（关于粘包与分包）<br>
UDP提供无连接的(connectionless)服务</p>
</li>
<li>
<p>传输控制协议(TCP)<br>
TCP提供客户与服务器之间的连接(connection)。TCP客户先与某个给定服务器建立一个连接，再跨该连接与那个服务器交换数据，然后终止这个连接。<br>
TCP还提供了可靠性(reliability)。当TCP向另一端发送数据时，它要求对端返回一 个确认.如果没有收到确认，TCP就自动重传数据并等待更长时间。在数次重传失败后，TCP才放弃。<br>
TCP含有用于动态估算客户和服务器之间的往返时间(round-trip time, RTT)的算法，以便它知道等待一个确认需要多少时间。<br>
TCP通过给其中每个字节关联一个序列号对所发送的数据进行排序(sequencing)接收端TCP将先根据它们的序列号重新排序，再把结果数据传递给接收应用。(注意粘包分包是指TCP报文段除去首部后交给应用层后应用层无法正确分包！所以本质上和TCP无关，TCP是也可以按序列号排序组合好所有报文段的，所以粘包分包是应用层的问题！)<br>
TCP提供流量控制(flow control)，TCP拥有通告窗口(advertised window)，确保发送端发送的数据不会使接收缓冲区溢出<br>
TCP连接是全双工的(full-d叩lex)。这意味着在一个给定的连接上应用可以在任何 时刻在进出两个方向上既发送数据又接收数据。<br>
UDP不提供流量控制，但UDP可以是全双工的.</p>
</li>
<li>
<p>TCP连接的建立和终止<br>
建立个TCP连接时会发生下述情形。<br>
(1) 服务器必须准备好接受外来的连接。这通常通过调用socket、bind和listen这3个函 数来完成，我们称之为被动打开(passiveopen)。<br>
(2) 客户通过调用connect发起主动打开(activeopen),这导致客户TCP发送一个SYN (同 步)分节，它告诉服务器客户将在(待建立的)连接中发送的数据的初始序列号。通常SYN分节不携带数据，其所在IP数据报只含有一个IP首部、一个TCP首部及可能有的TCP选项。<br>
(3) 服务器必须确认(ACK)客户的SYN,同时自己也得发送一个SYN分节，它含有服务 器将在同一连接中发送的数据的初始序列号。服务器在单个分节中发送SYN和对客户SYN的 ACK (确认)。<br>
(4) 客户必须确认服务器的SYN。</p>
</li>
</ul>
<p>连接建立至少需要3个分组，因此称之为TCP的三路握手(three-way handshake).<br>
<img src="https://lixin-ee.github.io//post-images/1578405307478.png" alt=""><br>
因为SYN占据一个字节的序列号空间，所以每一个SYN 的ACK中的确认号就是该SYN的初始序列号加1。类似地，每一个FIN (表示结束)的ACK中的 确认号为该FIN的序列号加1。<br>
<strong>ACK不占序列号</strong></p>
<p>与网络连接相关的系统调用函数的意义：<br>
如果将建立TCP连接类比于一个电话系统<br>
socket函数等同于有电话可用.<br>
bind函数是在告诉别人你的电话号码，这样他们可以呼叫你<br>
listen函效是打开电话振铃， 这样当有一个外来呼叫到达时，你就可以听到.<br>
connect函数要求我们知道对方的电话号码 并拨打它.<br>
accept函数发生在被呼叫的人应答电话之时<br>
不同之处在于accept只在连接建立之后返回客户的标识</p>
<p>域名系统DNS提供了 一种类似于电话薄的服务<br>
getaddrinfo类似于在电话簿中查找某个人的电话号 码<br>
getnameinfo则类似于有一本按照电话号码而不是按照用户名排序的电话簿。</p>
<ul>
<li>TCP 选项<br>
<strong>MSS选项</strong>：通告对端它的最大分节大小(maximum segment size),也就是它在本连接的每个TCP分节中愿意接受的最大数据量。<br>
<strong>窗口规模选项</strong>:能够通告对端的最大窗口大小是65535,因为在TCP 首部中相应的字段占16位,在一个TCP连接上使用窗口规模的前提是它的两个端系统必须都支持这个选项。<br>
<strong>时间戳选项</strong>：对于高速网络连接是必要的，它可以防止由失而复现的分组05可 能造成的数据损坏	<br>
后两个选项有时称为&quot;RFC 1323选项&quot;，高带宽或长延迟的网络被 称为&quot;长胖管道&quot;(longfhtpipe),这两个选项也称为&quot;长胖管道选项&quot;</li>
</ul>
<p><strong>失而复现的分组</strong>，并不是超时重传的分组，而是由暂时的路由原因造成的迷途的分组。当路由稳定后，它们又会正常到达目的地，其前提是它们在此前尚未被路由器丢弃.高速网络中32位的序列号短时间内就可能循环一轮重新使用，若不用时间戳选项，失而复现的分组所承载的分节可能与再次使用相同序列号的真正 分节发生混淆。</p>
<ul>
<li>TCP连接终止<br>
TCP建立一个连接需3个分节，终止一个连接则需4个分节。<br>
(1) 某个应用进程首先调用close,我们称该端执行<strong>主动关闭</strong>(active close)。该端的TCP 于是发送个FIN分节，表示数据发送完毕。<br>
(2) 接收到这个FIN的对端执行<strong>被动关闭</strong>(passive close)。这个FIN由TCP确认。它的接收也作为一个<strong>文件结束符</strong>(end-of-file)传递给接收端应用进程(放在已排队等候该应用进程接收 的任何其他数据之后)，因为FIN的接收意味着接收端应用进程在相应连接上再无额外数据可 接收。<br>
(3) 一段时间后，接收到这个文件结束符的应用进程将调用close关闭它的套接字。这导致 它的TCP也发送一个FIN.<br>
(4) 接收这个最终FIN的原发送端TCP (即执行主动关闭的那一端)确认这个FIN。<br>
步骤2和步骤3发送的分节都出自执行被动关闭那一端，有可能被合并成一个分节。<br>
<img src="https://lixin-ee.github.io//post-images/1578406215415.png" alt=""><br>
类似SYN, 一个FIN也占据1个字节的序列号空间。因此，每个FIN的ACK确认号就是这个 FIN的序列号加1。</li>
</ul>
<p>在步骤2与步骤3之间，从执行被动关闭一端到执行主动关闭一端流动数据是可能的。这称 为半关闭（half-close) ，与shutdown函数有关<br>
当一个Unix<strong>进程</strong>无论自愿地（调用exit或从main函数返 回）还是非自愿地（收到一个终止本进程的信号）终止时，<strong>所有打开的描述符</strong>都被关闭，这也 导致仍然打开的<strong>任何TCP连接</strong>上也发出一个<strong>FIN</strong>。</p>
<p>TCP状态转换图<br>
理解状态转换图是使用netstat命令诊断网络问题的基础<br>
状态转换图给出11种TCP状态的名称。这些状态可使用netstat显示， 它是一个在调试客户/服务器应用时很有用的工具。（第5章中使用netstat去监视状态的 变化。)<br>
<img src="https://lixin-ee.github.io//post-images/1578406476029.png" alt=""></p>
<p>一个完整的TCP连接所发生的实际分组交换情况，包括连接建立、数据传送和连接终止3个阶段。图中还展示了每个端点所历经的TCP状态。<br>
<img src="https://lixin-ee.github.io//post-images/1578406540777.png" alt=""><br>
客户通告一个值为536字节的MSS （表明该客户只实现了最小重组缓冲区大小），服务 器通告一个值为1460字节的MSS （以太网上IPv4的典型值）。不同方向上MSS值不相同不成问题(全双工，只需要遵守对方的发送规则就好)<br>
服务器对客户请求的确认是伴随其应答发送的。这种做法称为捎带（piggy backing）<br>
如果该连接的整个目的仅仅是发送一个单分节的请求和接收一个单分节的应答，那么使用TCP有8个分节的开销。如果改用UDP,那么只需交换两个分组：一个承载请求，一个承载应答。UDP避免了TCP连接建立和终止所需的开销，然而从TCP切换到UDP将丧失TCP提供给应用进程的全部可靠性</p>
<ul>
<li>
<p>TIME WAIT 状态<br>
TIME_WAIT状态：执行主动关闭的那端经历了这个状态。该端点停留在这个状态的持续时间是最长分节生命期(maximum segment lifetime, MSL)的两倍，有时候称之为<strong>2MSL</strong>。<br>
MSL是任何<strong>IP数据报</strong>能够在因特网中存活的最长时间，因为每个数据报含有一个称为跳限(hop limit)的8位字段，最大值为255。<br>
所以可以假设：具有最大跳限(255)的分组在网络中存在的时间不可能超过MSL秒。<br>
&quot;迷途”：路由异常的结果，某个路由器崩溃或某两个路由器之间的某 个链路断开时，路由协议需花数秒钟到数分钟的时间才能稳定并找出另一条通路。<br>
TCP必须正确处理这些迷途的重复分组<br>
所以TIME_WAIT状态有两个存在的理由：<br>
(1)	可靠地实现TCP全双工连接的终止；<br>
假设最终的ACK丢失了来解释。被动关闭端将重新发送它的最终那个FIN,因此主动关闭端必须维护状态信息，以允许它重新发送最终那个ACK<br>
执行主动关闭的那一端必须保持处于TIME_WAIT：因为可能不得不重传最终那个ACK。<br>
(2)	允许迷途的重复分节在网络中消逝。<br>
关闭这个连接后过一段时间后很有可能在相同的IP 地址和端口之间建立另一个连接。后一个连接称为前一个连接的化身(incarnation),因为它们 的IP地址和端口号都相同<br>
TCP必须防止来自某个连接的老的重复分组在该连接已终止后再现， 从而被误解成属于同一连接的某个新的化身。<br>
既然TIME_WAIT状态的持续时间是MSL的2倍，这就足以让某个方向上的分组最多存活MSL秒即被丢弃，另一个方向上的应答最多存活MSL秒也被丢弃。<br>
进一步地，能够保证每成功建立一个TCP连接时，来自该连接先前化身的老的重复分组都已在网络中消逝了。</p>
</li>
<li>
<p>端口号<br>
多个进程可能同时使用TCP、UDP和SCTP这3种传输层协议中的任何一种。这3 种协议都使用16位整数的端口号(port number)来区分这些进程。<br>
当一个客户想要跟一个服务器联系并使用服务时，需要获得用于标识众所周知的服务的众所周知的端口 (well-known port)<br>
而客户自身通常使用短期存活的临时端口(ephemeral port)。<br>
端口号被划分成以下3段：<br>
(1)	众所周知的端口为0-1023。<br>
(2)	已登记的端口(registered port)为1024-49151<br>
(3)	49152~65535是动态的(dynamic)或私用的(private)端口，也是临时端口。<br>
同时在UNIX中需要额外注意的是<br>
Unix系统有保留端口 (reserved port)的概念，指的是小于1024的任何端口。这些端口只能赋予特权用户（root）进程的套接字。</p>
</li>
</ul>
<p>套接字对<br>
一个TCP连接的套接字对（socket pair）是一个定义该连接的两个端点的四元组：本地IP地址、本地TCP端口号、外地IP地址、外地TCP端口号。<br>
标识每个端点的两个值（IP地址和端口号）通常称为一个套接字。</p>
<ul>
<li>
<p>TCP端口号与并发服务器<br>
套接字中的星号*代表通配（wildcard）符<br>
服务器的监听套接字（listening socket）经常使用｛*:port, *:*}，代表服务器在任意本地接口（第一个星号） 的特定端口port上等待连接请求，外地IP地址和外地端口都没有指定。<br>
必须在服务器主机上区分监听套接字和已连接套接字（connected socket）， 己连接套接字使用与监听套接字相同的本地端口，连接一旦建立，已连接套接字的特定本地地址随即填入。<br>
有时可能存在多个服务使用同一端口的情况，此时TCP无法仅仅通过查看目的端口号来分离外来的分节到不同的端点。它必须查看套接字对的所有4个元素才能确定由哪个端点接收某个到达的分节。</p>
</li>
<li>
<p>缓冲区大小及限制<br>
影响IP数据报大小的限制：<br>
•	IPv4数据报的最大大小是65 535字节，包括IPv4首部（因为总长度字 段占据16位。）<br>
•许多网络有一个可由硬件规定的MTU。举例来说，以太网的MTU是1500字节。（进一步导致TCP报文段数据段的最大长度MSS等于1460字节，TCP首部都是20个字节，但IPv4首部是20字节）<br>
同时，IPv4要求的最小链路MTU是68字节.这允许最大的IPv4首部（包括20字节的固定长度部 分和最多40字节的选项部分）拼接最小的片段（IPv4首部中片段偏移字段以8个字节为 单位）<br>
•	在两个主机之间的路径中最小的MTU称为<strong>路径MTU</strong>（path MTU）。1500字节的以太网 MTU是当今常见的路径MTU。两个主机之间相反的两个方向上路径MTU可以不一致<br>
•	当一个IP数据报将从某个接口送出时，如果它的大小超过相应链路的MTU, IPv4将执行分片（fragmentation）。这些片段在到达最终目的地之前通常不会被重组 （reassembling）, <strong>IPv4主机</strong>对其产生的数据报执行分片，<strong>IPv4路由器</strong>则对其转发的数据报执行分片。<br>
•	但是，IPv4首部的“不分片（don,tfragment）&quot;位（即DF位）若被设置，那么不管是 发送这些数据报的主机还是转发它们的路山器，都不允许对它们分片。当路由器接收到一个超过其外出链路MTU大小且设置了DF位的IPv4数据报时，它将产生一个ICMPv4的“目的地不可达，需分片但DF位已设置”的出错消息<br>
•	IPv4定义了最小重组缓冲区大小（minimum reassembly buffer size）,它是IPv4 必须保证支持的最小数据报大小，其值为576字节。<br>
•	TCP有一个MSS （maximum segment size,最大分节大小），用于向对端TCP通告对端在每个 分节中能发送的最大TCP数据量。MSS的目的是告诉对端其重组缓冲区大小的实际值，从而试图避免分片。MSS经常设置成MTU 减去IP和TCP首部的固定长度。在以太网中使用IPv4的MSS值为1460, （TCP首部都是20个字节，但IPv4首部是20字节）。</p>
</li>
<li>
<p>TCP 输出<br>
<img src="https://lixin-ee.github.io//post-images/1578486758834.png" alt=""><br>
每一个TCP套接字有一个发送缓冲区，我们可以使用SO_SNDBUF套接字选项来更改该缓冲区的大小。当某个应用进程调用write时，内核从该<strong>应用进程的缓冲区</strong>中复制所有数据到所写<strong>套接字的发送缓冲区</strong>。<br>
因此，从写一个TCP套接字的write调用成功返回仅仅表示我们 可以重新使用原来的<strong>应用进程缓冲区</strong>，并不表明对端的TCP或应用进程己接收到数据。<br>
伴随来自对端的 ACK的不断到达，本端TCP至此才能从<strong>套接字发送缓冲区</strong>中丢弃己确认的数据。TCP必须为已发送的数据保留一个副本，直到它被对端确认为止。</p>
</li>
<li>
<p>UDP 输出<br>
<img src="https://lixin-ee.github.io//post-images/1578486946325.png" alt=""><br>
以虚线框展示套接字发送缓冲区，因为它实际上并不存在。<br>
任何UDP套接字都有<strong>发送缓冲区大小</strong>（我们可以使用SO_SNDBUF套接字选项更改它，见7.5节），不过它<strong>仅仅是</strong>可写到该套接字的UDP数据报的<strong>大小上限。</strong>（只是用于判断单个UDP数据报的大小）<br>
如果一个应用进程写一个大于套接字发送缓冲区大小的数据报，内核将返回该进程一个EMSGSIZE错误。<br>
既然UDP是不可靠的，它不必保存应用进程数据的一个副本，因此无需一个真正的发送缓冲区。<br>
UDP简单地给来自用户的数据报安上它的8字节的首部以构成UDP数据报，然后传 递给IP。<br>
如果某个UDP应用进程发送大数据报（譬如说2000字节的数据报），那么它们相比TCP应用数据更有可能被<strong>分片</strong>，因为TCP会把应用数据划分成MSS大小的块，而UDP却没有对等的手段。</p>
</li>
<li>
<p>标准因特网服务<br>
<img src="https://lixin-ee.github.io//post-images/1578487266054.png" alt=""><br>
上图TCP/IP多数实现都提供的若干标准服务<br>
这些服务通常由Unix主机的inetd守护进程提供<br>
注意，当我们连接到daytime服务器时，服务器执行主动关闭，然而当连接到echo服务器时，客户执行主动关闭。<br>
拒绝服务攻击和其他资源使用攻击，在如今的系统中，这些简单的服 务通常被禁用。</p>
</li>
</ul>
<p>常见因特网应用的协议使用<br>
<img src="https://lixin-ee.github.io//post-images/1578487587325.png" alt=""><br>
前两个因特网应用ping和traceroute是使用ICMP协议实现的网络诊断应用<br>
紧接着是3个流行的路由协议<br>
接下来5个是基于UDP的网络应用</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Linux基础] 进程 （鸟哥Linux第十六章）]]></title>
        <id>https://lixin-ee.github.io//post/linux-ji-chu-jin-cheng-niao-ge-linux-di-shi-liu-zhang</id>
        <link href="https://lixin-ee.github.io//post/linux-ji-chu-jin-cheng-niao-ge-linux-di-shi-liu-zhang">
        </link>
        <updated>2020-01-07T11:40:57.000Z</updated>
        <content type="html"><![CDATA[<p>在 Linux 系统当中：『触发任何一个事件时，系统都会将他定义成为一个进程，并且给予这个进程一个 ID ，称为 PID，同时依据启发这个进程的用户与相关属性关系，给予这个 PID 一组有效的权限设定。』</p>
<ul>
<li>进程与程序 (process &amp; program)<br>
『执行一个程序或指令』就可以触发一个事件而取得一个 PID<br>
『不同的使用者身份执行同一个 program 时，系统给予的权限也都不相同』</li>
</ul>
<p>当 root 执行这个 touch 指令时，他取得的是 UID/GID = 0/0 的权限，而当普通用户 (假设UID/GID=501/501) 执行这个 touch 时，他的权限就跟 root 不同<br>
当我们登入并执行 bash 时，系统已经给我们一个 PID 了，这个 PID 就是依据登入者的 UID/GID (/etc/passwd) 来的</p>
<p>父进程衍生出来的子进程在一般状态下，也会沿用这个进程的相关权限</p>
<p>程序 (program)：通常为 binary program ，放置在储存媒体中 (如硬盘、光盘、软盘、磁带等)， 为实体文件的型态存在；<br>
进程 (process)：程序被触发后，执行者的权限与属性、程序的程序代码与所需数据等都会被加载内存中， 操 作系统并给予这个内存内的单元一个标识符 (PID)，可以说，进程就是一个正在运作中的程序。</p>
<ul>
<li>子进程与父进程<br>
当我们登 入系统后，会取得一个 bash的shell ，然后，我们用这个 bash 提供的接口去执行另一个指令，例如/usr/bin/passwd 或者是 touch 等等，那些另外执行的指令也会被触发得到新PID成『子进程』，原本的 bash 环境下，就称为『父进程』了<br>
<img src="https://lixin-ee.github.io//post-images/1578397893602.png" alt=""></li>
</ul>
<p>每个进程都有一个 PID ，那某个进程的父进程就透过 Parent PID (PPID) 来判断</p>
<ul>
<li>
<p>fork and exec进程呼叫的流程<br>
在 Linux 的 进程呼叫通常称为 fork-and-exec 的流程<br>
进程都会藉由父进程以复制 (fork) 的方式产生一个 一模一样的子进程， 然后被复制出来的子进程再以 exec 的方式来执行实际要进行的程序，最终就 成为一个子进程的存在。<br>
<img src="https://lixin-ee.github.io//post-images/1578398079861.png" alt=""></p>
</li>
<li>
<p>系统或网络服务：常驻在内存的进程<br>
常驻在内存当中，在后台当中一直持续不断运作的进程通常都是负责一些系统所提供的功能以服务用户各项任务，因此这些常驻程序就会被我们称为：服务 （守护进程）(daemon)。</p>
</li>
<li>
<p>工作管理 (job control)<br>
『当我们登入系统取得 bash shell 之 后，在<strong>单一终端机接口</strong>下同时进行多个工作的行为管理 』<br>
因为进行工作管理的行为中， 其实每个工作都是目前 bash 的子进程，亦即彼此之间是有相关性的。 我们无法以 job control 的方式由 tty1 的环境去管理 tty2 的 bash</p>
</li>
</ul>
<p>由于假设我们只有一个终端接口，因此在可以出现提示字符让你操作的环境就称为前端 (foreground)， 至于其他工作就可以让你放入后台 (background) 去暂停或运作。</p>
<p>放入背景的工作想要运作时， 无法与使用者互动。所以类似于 vim 绝对不可能在背景里面执行 (running) 的<br>
放入背景的工作是不可以使用 [ctrl]+c 来终止的</p>
<p>总结：<br>
这些工作所触发的进程必须来自于你 shell 的子进程(只管理自己的 bash)；<br>
前景：你可以控制与下达指令的这个环境称为前景的工作 (foreground)；<br>
背景：可以自行运作的工作，你无法使用 [ctrl]+c 终止他，可使用 bg/fg 呼叫该工作；<br>
背景中『执行』的进程不能等待 terminal/shell 的输入(input)</p>
<ul>
<li>job control 的管理命令</li>
</ul>
<ol>
<li>
<p>直接将指令丢到背景中『执行』的 &amp; 命令<br>
在该指令的最后面加上一个『 &amp; 』代表将该指令丢到背景中， 此时 bash 会给予这个指令一个『工作号码(job number)』，至于后面那个则是该指令所触发的『 PID 』了<br>
进程完成后将会显示Done，后台任务不怕被 [ctrl]+c 中断</p>
</li>
<li>
<p>将『目前』的工作丢到背景中『暂停』：[ctrl]-z<br>
在 vim 的一般模式下，按下 [ctrl] 及 z 这两个按键，屏幕上会出现 [1] ，表示这是第一个工作， 而 那个 + 代表最近一个被丢进背景的工作，且目前在背景下预设会被取用的那个工作 (与 fg 这个指 令有关 )，而那个 Stopped 则代表目前这个工作的状态。在预设的情况下，使用 [ctrl]-z 丢到背景当 中的工作都是『暂停』的状态</p>
</li>
<li>
<p>观察目前的背景工作状态： jobs<br>
<code>[root@study ~]# jobs [-lrs] 选项与参数：</code><br>
-l ：除了列出 job number 与指令串之外，同时列出 PID 的号码；<br>
-r ：仅列出正在背景 run 的工作；<br>
-s ：仅列出正在背景当中暂停 (stop) 的工作。<br>
+代表最近被放到背景的工作号码， - 代表最近最后第二个被放置到背景中的工作号码</p>
</li>
<li>
<p>将背景工作拿到前景来处理：fg<br>
<code>[root@study ~]# fg %jobnumber</code><br>
选项与参数：<br>
%jobnumber ：jobnumber 为工作号码(数字)。注意这个命令中那个 % 是可有可无的（KILL中则必须有）<br>
如果输入『 fg - 』 则代表将 - 号的那个工作号码拿出来</p>
</li>
<li>
<p>让工作在背景下的状态变成运作中： bg<br>
[ctrl]-z 可以将目前的工作丢到背景底下去『暂停』，bg让一个工作在 背景底下『 Run 』<br>
指令列最后方多了一个 &amp; 的符号啰！ 代表该工作被启动在背景当中了</p>
</li>
<li>
<p>管理背景当中的工作： kill</p>
</li>
</ol>
<pre><code>[root@study ~]#  kill -signal %jobnumber
[root@study ~]#  kill -l 
</code></pre>
<p>选项与参数：<br>
-l ：这个是 L 的小写，列出目前 kill 能够使用的讯号 (signal) 有哪些<br>
signal ：代表给予后面接的那个工作什么样的指示啰！用 man 7 signal 可知：<br>
-1 ：重新读取一次参数的配置文件 (类似 reload)；<br>
-2 ：代表与由键盘输入 [ctrl]-c 同样的动作；<br>
-9 ：立刻强制删除一个工作；<br>
-15：以正常的进程方式终止一项工作。与 -9 是不一样的。</p>
<p>-9 这个 signal 通常是用在『强制删除一个不正常的工作』时所使用的， -15 则是<br>
以正常步骤结束一项工作(<strong>15 也是默认值</strong>)</p>
<p>kill 后面接的数字默认会是 PID ，如果想要管理 bash 的工作控制，就必须要加上 %数字 了</p>
<ul>
<li>脱机管理问题<br>
工作管理当中提到的『背景』指的是 bash 的背景，并不是放到系统的背景，所以，工作管理的背景依旧与终端机有关</li>
</ul>
<p>在工作尚未结束的情况下你脱机了，该工作不会继续进行，而是会被中断掉。<br>
at 是将工作放置到系统背景， 而与终端机无关。<br>
也可以尝试使用 nohup 这个指令来处理，这个 nohup 可以让你在脱机或<br>
注销系统后，还能够让工作继续进行<br>
在终端机前景中工作[root@study ~]#  nohup [ 指令与 参数 ]<br>
在终端机背景中工作[root@study ~]#  nohup [ 指令与 参数 ] &amp;<br>
nohup 并不支持 bash 内建的指令，因此必须要是外部指令才行</p>
<ul>
<li>进程管理</li>
</ul>
<p>进程的观察</p>
<ol>
<li>ps 将某个时间点的进程运作情况撷取下来<br>
选项与参数：<br>
-A ：所有的 process 均显示出来，与 -e 具有同样的效用；<br>
-a ：不与 terminal 有关的所有 process ；<br>
-u ：有效使用者 (effective user) 相关的 process ；<br>
x ：通常与 a 这个参数一起使用，可列出较完整信息。<br>
输出格式规划：<br>
l ：较长、较详细的将该 PID 的的信息列出；<br>
j ：工作的格式 (jobs format)<br>
-f ：做一个更为完整的输出。</li>
</ol>
<p>观察系统所有的进程数据[root@study ~]#  ps aux<br>
也是能够观察所有系统的数据[root@study ~]#  ps -lA<br>
连同部分进程树状态[root@study ~]#  ps axjf</p>
<p>重点：<br>
只能查阅自己 bash 进程的『 ps -l 』<br>
可以查阅所有系统运作的进程『 ps aux 』</p>
<p>但是ps -l 与 ps aux 显示的项目<strong>并不相同</strong></p>
<p>仅观察自己的 bash 相关进程： ps -l<br>
F：代表这个进程旗标 (process flags)，说明这个进程的总结权限，常见号码有：<br>
若为 4 表示此进程的权限为 root ；<br>
若为 1 则表示此子进程仅进行复制(fork)而没有实际执行(exec)。<br>
  S：代表这个进程的状态 (STAT)，主要的状态有：<br>
R (Running)：该程序正在运作中；<br>
S (Sleep)：该程序目前正在睡眠状态(idle)，但可以被唤醒(signal)。<br>
D ：不可被唤醒的睡眠状态，通常这支程序可能在等待 I/O 的情况(ex&gt;打印)<br>
T ：停止状态(stop)，可能是在工作控制(背景暂停)或除错 (traced) 状态；<br>
Z (Zombie)：僵尸状态，进程已经终止但却无法被移除至内存外。<br>
  UID/PID/PPID：代表『此进程被该 UID 所拥有/进程的 PID 号码/此进程的父进程 PID 号码』<br>
  C：代表 CPU 使用率，单位为百分比；<br>
  PRI/NI：Priority/Nice 的缩写，代表此进程被 CPU 所执行的优先级，数值越小代表该进程越快被 CPU 执行。详细的 PRI 与 NI 将在下一小节说明。<br>
  ADDR/SZ/WCHAN：都与内存有关，ADDR 是 kernel function，指出该进程在内存的哪个部分，如果是个running 的进程，一般就会显示『 - 』 / SZ 代表此进程用掉多少内存 / WCHAN 表示目前进程是否运作中，同样的， 若为 - 表示正在运作中。<br>
  TTY：登入者的终端机位置，若为远程登录则使用动态终端接口 (pts/n)；<br>
  TIME：使用掉的 CPU 时间，注意，是此进程实际花费 CPU 运作的时间，而不是系统时间；<br>
  CMD：就是 command 的缩写，造成此进程的触发程序之指令为何。</p>
<p>观察系统所有进程： ps aux<br>
各字段的意义为：<br>
  USER：该 process 属于那个使用者账号的？<br>
  PID ：该 process 的进程标识符。<br>
  %CPU：该 process 使用掉的 CPU 资源百分比；<br>
  %MEM：该 process 所占用的物理内存百分比；<br>
  VSZ ：该 process 使用掉的虚拟内存量 (Kbytes)<br>
  RSS ：该 process 占用的固定的内存量 (Kbytes)<br>
  TTY ：该 process 是在那个终端机上面运作，若与终端机无关则显示 ?，另外， tty1-tty6 是本机上面的登<br>
入者进程，若为 pts/0 等等的，则表示为由网络连接进主机的进程。<br>
  STAT：该进程目前的状态，状态显示与 ps -l 的 S 旗标相同 (R/S/T/Z)<br>
  START：该 process 被触发启动的时间；<br>
  TIME ：该 process 实际使用 CPU 运作的时间。<br>
  COMMAND：该进程的实际指令为何？</p>
<p><strong>『僵尸 (zombie) 』进程</strong><br>
造成僵尸进程的成因是因为该进程应该已经执行完毕，或者是因故应该要终止了， 但是该进程的父进程却无法完整的将该进程结束掉，而造成那个进程一直存在内存当中。<br>
如果你发现在某个进程的 CMD 后面还接上<code>&lt;defunct&gt;</code> 时，就代表该进程是僵尸进程</p>
<p>重点<br>
不要仅仅将僵尸进程 kill 掉而已，要找出该进程的父进程</p>
<ol start="2">
<li>top：动态观察进程的变化<br>
<code>[root@study ~]# top [-d 数 字 ] | top [-bnp]</code><br>
选项与参数：<br>
-d ：后面可以接秒数，就是整个进程画面更新的秒数。预设是 5 秒；<br>
-b ：以批次的方式执行 top ，还有更多的参数可以使用喔！<br>
通常会搭配数据流重导向来将批次的结果输出成为文件。<br>
-n ：与 -b 搭配，意义是，需要进行几次 top 的输出结果。<br>
-p ：指定某些个 PID 来进行观察监测而已。</li>
</ol>
<p>在 top 执行过程当中可以使用的按键指令：<br>
? ：显示在 top 当中可以输入的按键指令；<br>
P ：以 CPU 的使用资源排序显示；<br>
M ：以 Memory 的使用资源排序显示；<br>
N ：以 PID 来排序喔！<br>
T ：由该 Process 使用的 CPU 时间累积 (TIME+) 排序。<br>
k ：给予某个 PID 一个讯号 (signal)<br>
r ：给予某个 PID 重新制订一个 nice 值。<br>
q ：离开 top 软件的按键。</p>
<ol start="3">
<li>pstree进程之间的相关性<br>
<code>[root@study ~]#pstree [-A|U] [-up]</code><br>
选项与参数：<br>
-A ：各进程树之间的连接以 ASCII 字符来连接；<br>
-U ：各进程树之间的连接以万国码的字符来连接。在某些终端接口下可能会有错误；<br>
-p ：并同时列出每个 process 的 PID；<br>
-u ：并同时列出每个 process 的所属账号名称。</li>
</ol>
<p>由 pstree 的输出我们也可以很清楚的知道，所有的进程都是依附在<strong>systemd</strong>这支进程底下的，这支进程的 PID 是1，因为他是由 Linux 核心所主动呼叫的第一支程序，所以 PID就是一号了。 这也是我们刚刚提到僵尸进程时有提到，为啥发生僵尸进程需要重新启动？ 因为僵尸进程挂载systemd名下，要消灭这些僵尸进程就需要重新启动，而重新启动systemd就是reboot</p>
<ul>
<li>进程相互之间的管理<br>
进程的互相管理：透过给予该进程一个讯号 (signal) 去告知该进程下一步的行为</li>
</ul>
<p>常见的 signal<br>
1 SIGHUP 启动被终止的进程，可让该 PID 重新读取自己的配置文件，类似重新启动<br>
2 SIGINT 相当于用键盘输入 [ctrl]-c 来中断一个进程的进行<br>
9 SIGKILL代表强制中断一个进程的进行，如果该进程进行到一半， 那么尚未完成的部分可能会有『半产品』产生，类似 vim 会有 .filename.swp 保留下来。<br>
15 SIGTERM 以正常的结束进程来终止该进程。由于是正常的终止， 所以后续的动作会将他完成。不过，如果该进程已经发生问题，就是无法使用正常的方法终止时， 输入这个 signal 也是没有用的。<br>
19 SIGSTOP 相当于用键盘输入 [ctrl]-z 来暂停一个进程的进行</p>
<p>只要记得『1,9,15』这三个号码的意义即可更多的讯号信息请自行 man 7 signal</p>
<ol>
<li>
<p>kill -signal PID<br>
kill 可以帮我们将这个 signal 传送给<strong>某个工作</strong> (%jobnumber) 或者是<strong>某个 PID</strong> (直接输入数字)。<br>
要再次强调的是： kill 后面<strong>直接加数字</strong>与<strong>加上 %number</strong> 的情况是不同的<br>
想要将某个进程删除的话，就可以透过使用pstree -p 找到相关进程， 然后再以 kill -9 将该进程删除</p>
</li>
<li>
<p>killall -signal  指令名称<br>
<code>[root@study ~]# killall [-iIe] [command name]</code><br>
选项与参数：<br>
-i ：interactive 的意思，交互式的，若需要删除时，会出现提示字符给用户；<br>
-e ：exact 的意思，表示『后面接的 command name 要一致』，但整个完整的指令不能超过 15 个字符。<br>
-I ：指令名称(可能含参数)忽略大小写。</p>
</li>
</ol>
<p>注意会强制终止所有以 [command name] 启动的进程，所以最好加上-i</p>
<ul>
<li>关于进程的执行顺序<br>
由 top 的输出结果我们也发现， 系统同时间有非常多的进程在运行中，只是绝大部分的进程都在休眠 (sleeping) 状态而已。 想一想，如果所有的进程同时被唤醒，那么 CPU 应该要先处理那个进程呢？也就是说，那个进程被执行的优先序比较高？ 这就得要考虑到进程的优先执行序 (Priority) 与 CPU 排程</li>
</ul>
<p>Priority  与 Nice<br>
PRI 值越低代表越优先的意思。不过这个 PRI 值是由核心动态调整的， 用户无法直接调整 PRI值的。<br>
ps -l命令可以看到当前进程的PRI 值和Nice 值（NI）<br>
PRI 与 NI 的相关性如下：<br>
PRI(new) = PRI(old) + nice<br>
当 nice 值为负值时，那么该进程就会降低 PRI 值，亦即会变的较优先被处理。</p>
<p>要调整某个进程的优先执行序，就是『调整该进程的 nice 值』 调整某个进程 nice 值有两种方式，分别是：<br>
  一开始执行程序就立即给予一个特定的 nice 值：用 nice 指令；<br>
  调整某个已经存在的 PID 的 nice 值：用 renice 指令。</p>
<p>nice  ：新执行的指令即给予新的 nice  值<br>
<code>[root@study ~]# nice [-n 数 字 ] command</code><br>
选项与参数：<br>
-n ：后面接一个数值，数值的范围 -20 ~ 19。</p>
<p>renice  ：已存在进程的 nice  重新调整<br>
<code>[root@study ~]# renice [number] PID</code><br>
选项与参数：<br>
PID ：某个进程的 ID 啊！</p>
<p>renice 后面接上数值及 PID 即可。因为后面接的是 PID ，所以你务必要以 ps 或者其他进程观察的指令去找出 PID 才行</p>
<ul>
<li>系统资源的观察<br>
free 观察内存使用情况<br>
<code>[root@study ~]# free [ [-b|-k|-m|-g|-h] [-t] [-s N -c N]</code><br>
选项与参数：<br>
-b ：直接输入 free 时，显示的单位是 Kbytes，我们可以使用 b(bytes), m(Mbytes)<br>
k(Kbytes), 及 g(Gbytes) 来显示单位喔！也可以直接让系统自己指定单位 (-h)<br>
-t ：在输出的最终结果，显示物理内存与 swap 的总量。<br>
-s ：可以让系统每几秒钟输出一次，不间断的一直输出的意思！对于系统观察挺有效！<br>
-c ：与 -s 同时处理～让 free 列出几次的意思</li>
</ul>
<p>uname ：查阅系统与LINUX内核相关信息<br>
<code>[root@study ~]# uname [-asrmpi]</code><br>
选项与参数：<br>
-a ：所有系统相关的信息，包括底下的数据都会被列出来；<br>
-s ：系统核心名称<br>
-r ：核心的版本<br>
-m ：本系统的硬件名称，例如 i686 或 x86_64 等；<br>
-p ：CPU 的类型，与 -m 类似，只是显示的是 CPU 的类型！<br>
-i ：硬件的平台 (ix86)</p>
<p>uptime：观察系统启动时间与工作负载<br>
显示出目前系统已经开机多久的时间，以及 1, 5, 15 分钟的平均负载。</p>
<p><strong>netstat  ：追踪网络或插槽文件</strong><br>
这个指令比较常被用在网络的监控方面，但也可以用于进程<br>
netstat 的输出分为两大部分，分别是网络<br>
与系统自己的进程相关性部分<br>
<code>[root@study ~]# netstat -[atunlp]</code><br>
选项与参数：<br>
-a ：将目前系统上所有的联机、监听、Socket 数据都列出来<br>
<strong>-t ：列出 tcp 网络封包的数据</strong><br>
-u ：列出 udp 网络封包的数据<br>
-n ：不以进程的服务名称，以端口号 (port number) 来显示；<br>
-l ：列出目前正在网络监听 (listen) 的服务；<br>
-p ：列出该网络服务的进程 PID</p>
<p>目前系统上已在监听的网络联机及其 PID<br>
<code>[root@study ~]# netstat -tulnp</code></p>
<p>显示内容可分为connections 和sockets文件</p>
<p>connections 输出字段有：<br>
Proto ：网络的封包协议，主要分为 TCP 与 UDP 封包，相关资料请参考服务器篇；<br>
Recv-Q：非由用户程序链接到此 socket 的复制的总 bytes 数；<br>
Send-Q：非由远程主机传送过来的 acknowledged 总 bytes 数；<br>
Local Address ：本地端的 IP:port 情况<br>
Foreign Address：远程主机的 IP:port 情况<br>
State ：联机状态，主要有建立(ESTABLISED)及监听(LISTEN)；</p>
<p>socket file 可以沟通两个进程之间的信息，因此进程可以取得对方传送过来的资料。<br>
socket file 的输出字段有：<br>
Proto ：一般就是 unix 啦；<br>
RefCnt：连接到此 socket 的进程数量；<br>
Flags ：联机的旗标；<br>
Type ：socket 存取的类型。主要有确认联机的 STREAM 与不需确认的 DGRAM 两种；<br>
State ：若为 CONNECTED 表示多个进程之间已经联机建立。<br>
Path ：连接到此 socket 的相关程序的路径！或者是相关数据输出的路径。</p>
<p>dmesg  分析核心产生的讯息</p>
<p>vmstat 侦测系统资源变化<br>
可以动态侦测『 CPU / 内存 / 磁盘输入输出状态 』</p>
<pre><code>[root@study ~]#  vmstat [-a] [ 延迟 [总计侦测次数 ]] &lt;==CPU/内存等信息
[root@study ~]#  vmstat [-fs] &lt;==内存相关
[root@study ~]#  vmstat [-S  单位 ] &lt;==设定显示数据的单位
[root@study ~]#  vmstat [-d] &lt;==与磁盘有关
[root@study ~]#  vmstat [-p  分区槽] &lt;==与磁盘有关
</code></pre>
<p>选项与参数：<br>
-a ：使用 inactive/active(活跃与否) 取代 buffer/cache 的内存输出信息；<br>
-f ：开机到目前为止，系统复制 (fork) 的进程数；<br>
-s ：将一些事件 (开机至目前为止) 导致的内存变化情况列表说明；<br>
-S ：后面可以接单位，让显示的数据有单位。例如 K/M 取代 bytes 的容量；<br>
-d ：列出磁盘的读写总量统计表<br>
-p ：后面列出分区槽，可显示该分区槽的读写总量统计表</p>
<p>统计目前主机 CPU 状态，每秒一次，共计三次<br>
[root@study ~]# vmstat 1 3</p>
<p>进程字段 (procs) 的项目分别为：<br>
r ：等待运作中的进程数量；b：不可被唤醒的进程数量。这两个项目越多，代表系统越忙碌 (因为系统太<br>
忙，所以很多进程就无法被执行或一直在等待而无法被唤醒之故)。<br>
内存字段 (memory) 项目分别为：<br>
swpd：虚拟内存被使用的容量； free：未被使用的内存容量； buff：用于缓冲存储器； cache：用于高速<br>
缓存。 这部份则与 free 是相同的。<br>
内存置换空间 (swap) 的项目分别为：<br>
si：由磁盘中将进程取出的量； so：由于内存不足而将没用到的进程写入到磁盘的 swap 的容量。 如果 si/so<br>
的数值太大，表示内存内的数据常常得在磁盘与主存储器之间传来传去，系统效能会很差！<br>
磁盘读写 (io) 的项目分别为：<br>
bi：由磁盘读入的区块数量； bo：写入到磁盘去的区块数量。如果这部份的值越高，代表系统的 I/O 非常<br>
忙碌！<br>
系统 (system) 的项目分别为：<br>
in：每秒被中断的进程次数； cs：每秒钟进行的事件切换次数；这两个数值越大，代表系统与接口设备的<br>
沟通非常频繁！ 这些接口设备当然包括磁盘、网络卡、时间钟等。<br>
CPU 的项目分别为：<br>
us：非核心层的 CPU 使用状态； sy：核心层所使用的 CPU 状态； id：闲置的状态； wa：等待 I/O 所<br>
耗费的 CPU 状态； st：被虚拟机 (virtual machine) 所盗用的 CPU 使用状态 (2.6.11 以后才支持)。</p>
<ul>
<li>特殊文件与进程</li>
</ul>
<p>具有 SUID/SGID 权限的指令执行状态<br>
SUID 的权限与进程的相关性：<br>
1 SUID 权限仅对二进制程序(binary program)有效；<br>
2 执行者对于该程序需要具有 x 的可执行权限；<br>
3 本权限仅在执行该程序的过程中有效 (run-time)；<br>
4 执行者将具有该程序拥有者 (owner) 的权限。</p>
<p>所以整个 SUID 的权限会生效是由于『具有该权限的程序被触发』<br>
例如在触发 passwd 后，会取得一个新的进程与 PID，该 PID 产生时透过 SUID 来给予该 PID 特殊的权限设定（root）</p>
<p>查询整个系统的 SUID/SGID 的文件 find / -perm /6000</p>
<p>/proc/*  代表的意义<br>
内存当中的数据又都是写入到 /proc/* 这个目录下的<br>
目前主机上面的各个进程的 PID 都是以目录的型态存在于 /proc 当中<br>
比如开机所执行的第一支程序 systemd 他的 PID 是 1 ， 这个 PID 的所有相关信息都写入在 /proc/1/* 当中<br>
可以使用 ll /proc/1 来观察，目录下主要有两个文件<br>
cmdline：这个进程被启动的指令串；<br>
environ：这个进程的环境变量内容</p>
<p>查询已开启文件或已执行进程开启之文件<br>
fuser ：藉由文件( 或文件系统) 找出正在使用该文件<br>
<code>[root@study ~]# fuser [-umv] [-k [i] [-signal]] file/dir</code><br>
选项与参数：<br>
-u ：除了进程的 PID 之外，同时列出该进程的拥有者；<br>
-m ：后面接的那个档名会主动的上提到该文件系统的最顶层，对 umount 不成功很有效<br>
-v ：可以列出每个文件与进程还有指令的完整相关性<br>
-k ：找出使用该文件/目录的 PID ，并试图以 SIGKILL 这个讯号给予该 PID；<br>
-i ：必须与 -k 配合，在删除 PID 之前会先询问使用者意愿<br>
-signal：例如 -1 -15 等等，若不加的话，预设是 SIGKILL (-9)</p>
<p>如果卸除硬盘时发现系统通知：『 device is busy 』，那表示这个文件系统正在忙碌中， 表示有某支进程有利用到该文件系统，那么你就可以利用 fuser 来追踪</p>
<p>lsof  ：列出被进程所开启的文件档名<br>
fuser 是由文件或者装置去找出使用该文件或装置的进程，lsof 反过来查出某个进程开启或者使用的文件与装置<br>
<code>[root@study ~]# lsof [-aUu] [+d]</code><br>
选项与参数：<br>
-a ：多项数据需要『同时成立』才显示出结果时！<br>
-U ：仅列出 Unix like 系统的 socket 文件类型；<br>
-u ：后面接 username，列出该使用者相关进程所开启的文件；<br>
+d ：后面接目录，亦即找出某个目录底下已经被开启的文件！</p>
<p>pidof  ：通过正在执行的程序找出其相应的的 PID<br>
<code>[root@study ~]# pidof [-sx] program_name</code><br>
选项与参数：<br>
-s ：仅列出一个 PID 而不列出所有的 PID<br>
-x ：同时列出该 program name 可能的 PPID 那个进程的 PID<br>
例如如果要找的是 bash ，那就 pidof bash ，立刻列出相应的 PID 号码</p>
]]></content>
    </entry>
</feed>