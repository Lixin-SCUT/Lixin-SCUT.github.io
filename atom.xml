<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-04-30T15:26:49.475Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>千里之行，始于足下。不积跬步，无以至千里。</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[8. 注释 -Google C++编程规范]]></title>
        <id>https://lixin-scut.github.io//post/8-zhu-shi-google-cbian-cheng-gui-fan</id>
        <link href="https://lixin-scut.github.io//post/8-zhu-shi-google-cbian-cheng-gui-fan">
        </link>
        <updated>2020-04-30T15:11:17.000Z</updated>
        <content type="html"><![CDATA[<p>  注释虽然写起来很痛苦, 但对保证代码可读性至关重要. 下面的规则描述了如何注释以及在哪儿注释. <strong>当然也要记住: 注释固然很重要, 但最好的代码应当本身就是文档. 有意义的类型名和变量名, 要远胜过要用注释解释的含糊不清的名字.</strong></p>
<p>  <strong>你写的注释是给代码读者看的, 也就是下一个需要理解你的代码的人. 所以慷慨些吧, 下一个读者可能就是你!</strong></p>
<h3 id="81-注释风格">8.1. 注释风格</h3>
<p><strong>总述</strong></p>
<p>  使用 // 或<code>/* */</code>, 统一就好.</p>
<p><strong>说明</strong></p>
<p>  // 或 <code>/* */</code> 都可以; <strong>但 // 更 常用</strong>. 要在如何注释及注释风格上确保统一.</p>
<h3 id="82-文件注释">8.2. 文件注释</h3>
<p><strong>总述</strong></p>
<p>  <strong>在每一个文件开头加入版权公告.</strong></p>
<p>  <strong>文件注释描述了该文件的内容</strong>. 如果一个文件<strong>只声明, 或实现, 或测试</strong>了一个对象, 并且这个对象已经在它的声明处进行了详细的注释, 那么<strong>就没必要再加上文件注释</strong>. 除此之外的其他文件都需要文件注释.</p>
<p><strong>说明</strong></p>
<p>  法律公告和作者信息</p>
<p>  <strong>每个文件都应该包含许可证引用. 为项目选择合适的许可证版本.(比如, Apache 2.0, BSD, LGPL, GPL)</strong></p>
<p>  如果你对原始作者的文件做了重大修改, 请考虑删除原作者信息.</p>
<p><strong>文件内容</strong></p>
<p>  <strong>如果一个 .h 文件声明了多个概念, 则文件注释应当对文件的内容做一个大致的说明, 同时说明各概念之间的联系</strong>. 一个一到两行的文件注释就足够了, <strong>对于每个概念的详细文档应当放在各个概念中, 而不是文件注释中</strong>.</p>
<p>  不要在 .h 和 .cc 之间复制注释, 这样的注释偏离了注释的实际意义.</p>
<h3 id="83-类注释">8.3. 类注释</h3>
<p><strong>总述</strong></p>
<p>  <strong>每个类的定义都要附带一份注释, 描述类的功能和用法, 除非它的功能相当明显.</strong></p>
<pre><code>// Iterates over the contents of a GargantuanTable.
// Example:
//    GargantuanTableIterator* iter = table-&gt;NewIterator();
//    for (iter-&gt;Seek(&quot;foo&quot;); !iter-&gt;done(); iter-&gt;Next()) {
//      process(iter-&gt;key(), iter-&gt;value());
//    }
//    delete iter;
class GargantuanTableIterator {
  ...
};
</code></pre>
<p><strong>说明</strong></p>
<p>  类注释应当为读者理解<strong>如何使用与何时使用类</strong>提供足够的信息, 同时应当提醒读者<strong>在正确使用此类时应当考虑的因素</strong>. 如果类<strong>有任何同步前提</strong>, 请用文档说明. 如果该类的实例可被多线程访问, 要特别注意文档说明<strong>多线程环境下相关的规则和常量使用</strong>.</p>
<p>  如果你想<strong>用一小段代码演示这个类的基本用法或通常用法</strong>, 放在类注释里也非常合适.</p>
<p>  如果类的声明和定义分开了(例如分别放在了 .h 和 .cc 文件中), 此时, <strong>描述类用法的注释应当和接口定义放在一起</strong>,<strong>描述类的操作和实现的注释应当和实现放在一起.</strong></p>
<h3 id="84-函数注释">8.4. 函数注释</h3>
<p><strong>总述</strong></p>
<p>  <strong>函数声明处的注释描述函数功能; 定义处的注释描述函数实现.</strong></p>
<p><strong>说明</strong></p>
<p>函数声明</p>
<p>  基本上每个函数<strong>声明处</strong>前都应当加上注释, 描述函数的<strong>功能和用途</strong>. 只有在函数的功能简单而明显时才能省略这些注释(例如, 简单的取值和设值函数). <strong>注释使用叙述式 (“Opens the file”) 而非指令式 (“Open the file”); 注释只是为了描述函数, 而不是命令函数做什么</strong>. 通常, <strong>注释不会描述函数如何工作. 那是函数定义部分的事情.</strong></p>
<p>函数声明处注释的内容:</p>
<ol>
<li>函数的输入输出.</li>
<li>对类成员函数而言: 函数调用期间对象是否需要保持引用参数, 是否会释放这些参数.</li>
<li>函数是否分配了必须由调用者释放的空间.</li>
<li>参数是否可以为空指针.</li>
<li>是否存在函数使用上的性能隐患.</li>
<li>如果函数是可重入的, 其同步前提是什么?</li>
</ol>
<p>举例如下:</p>
<pre><code>// Returns an iterator for this table.  It is the client's
// responsibility to delete the iterator when it is done with it,
// and it must not use the iterator once the GargantuanTable object
// on which the iterator was created has been deleted.
//
// The iterator is initially positioned at the beginning of the table.
//
// This method is equivalent to:
//    Iterator* iter = table-&gt;NewIterator();
//    iter-&gt;Seek(&quot;&quot;);
//    return iter;
// If you are going to immediately seek to another place in the
// returned iterator, it will be faster to use NewIterator()
// and avoid the extra seek.
Iterator* GetIterator() const;
</code></pre>
<p>  但也要避免罗罗嗦嗦, 或者对显而易见的内容进行说明. 下面的注释就没有必要加上 “否则返回 false”, 因为已经暗含其中了:</p>
<pre><code>// Returns true if the table cannot hold any more entries.
bool IsTableFull();
</code></pre>
<p>  <strong>注释函数重载时, 注释的重点应该是函数中被重载的部分, 而不是简单的重复被重载的函数的注释</strong>. <strong>多数情况下, 函数重载不需要额外的文档, 因此也没有必要加上注释.</strong></p>
<p>  注释构造/析构函数时, 切记读代码的人知道构造/析构函数的功能, 所以 “销毁这一对象” 这样的注释是没有意义的. 你<strong>应当注明的是注明构造函数对参数做了什么 (例如, 是否取得指针所有权) 以及析构函数清理了什么</strong>. 如果都是些无关紧要的内容, 直接省掉注释. 析构函数前没有注释是很正常的.</p>
<p><strong>函数定义</strong></p>
<p>  <strong>如果函数的实现过程中用到了很巧妙的方式, 那么在函数定义处应当加上解释性的注释</strong>. 例如, 你所使用的编程技巧, 实现的大致步骤, 或解释如此实现的理由. 举个例子, 你可以说明为什么函数的前半部分要加锁而后半部分不需要.</p>
<p>  不要 从 .h 文件或其他地方的函数声明处直接复制注释. <strong>简要重述函数功能是可以的, 但注释重点要放在如何实现上.</strong></p>
<h3 id="85-变量注释">8.5. 变量注释</h3>
<p><strong>总述</strong></p>
<p>  通常变量名本身足以很好说明变量用途. 某些情况下, 也需要额外的注释说明.</p>
<p><strong>说明</strong></p>
<p><strong>类数据成员</strong></p>
<p>  <strong>每个类数据成员 (也叫实例变量或成员变量) 都应该用注释说明用途</strong>. 如果有非变量的参数(例如特殊值, 数据成员之间的关系, 生命周期等)不能够用类型与变量名明确表达, 则应当加上注释. 然而, 如果变量类型与变量名已经足以描述一个变量, 那么就不再需要加上注释.</p>
<p><strong>特别地, 如果变量可以接受 NULL 或 -1 等警戒值, 须加以说明</strong>. 比如:</p>
<pre><code>private:
 // Used to bounds-check table accesses. -1 means
 // that we don't yet know how many entries the table has.
 int num_total_entries_;
</code></pre>
<p><strong>全局变量</strong></p>
<p>  <strong>和数据成员一样, 所有全局变量也要注释说明含义及用途, 以及作为全局变量的原因</strong>. 比如:</p>
<pre><code>// The total number of tests cases that we run through in this regression test.
const int kNumTestCases = 6;
</code></pre>
<h3 id="86-实现注释">8.6. 实现注释</h3>
<p><strong>总述</strong></p>
<p>对于代码中巧妙的, 晦涩的, 有趣的, 重要的地方加以注释.</p>
<p><strong>说明</strong></p>
<p><strong>代码前注释</strong></p>
<p>巧妙或复杂的代码段前要加注释. 比如:</p>
<pre><code>// Divide result by two, taking into account that x
// contains the carry from the add.
for (int i = 0; i &lt; result-&gt;size(); i++) {
  x = (x &lt;&lt; 8) + (*result)[i];
  (*result)[i] = x &gt;&gt; 1;
  x &amp;= 1;
}
</code></pre>
<p><strong>行注释</strong></p>
<p>比较隐晦的地方要在行尾加入注释. 在行尾空两格进行注释. 比如:</p>
<pre><code>// If we have enough memory, mmap the data portion too.
mmap_budget = max&lt;int64&gt;(0, mmap_budget - index_-&gt;length());
if (mmap_budget &gt;= data_size_ &amp;&amp; !MmapData(mmap_chunk_bytes, mlock))
  return;  // Error already logged.
</code></pre>
<p>注意, 这里用了两段注释分别描述这段代码的作用, 和提示函数返回时错误已经被记入日志.</p>
<p><strong>如果你需要连续进行多行注释, 可以使之对齐获得更好的可读性:</strong></p>
<pre><code>DoSomething();                  // Comment here so the comments line up.
DoSomethingElseThatIsLonger();  // Two spaces between the code and the comment.
{ // One space before comment when opening a new scope is allowed,
  // thus the comment lines up with the following comments and code.
  DoSomethingElse();  // Two spaces before line comments normally.
}
std::vector&lt;string&gt; list{
                    // Comments in braced lists describe the next element...
                    &quot;First item&quot;,
                    // .. and should be aligned appropriately.
&quot;Second item&quot;};
DoSomething(); /* For trailing block comments, one space is fine. */
</code></pre>
<p><strong>函数参数注释</strong></p>
<p><strong>如果函数参数的意义不明显</strong>, 考虑用下面的方式进行弥补:</p>
<ol>
<li>如果参数是一个字面常量, 并且这一常量在多处函数调用中被使用, 用以推断它们一致, 你应当用一个常量名让这一约定变得更明显, 并且保证这一约定不会被打破.</li>
<li><strong>考虑更改函数的签名, 让某个 bool 类型的参数变为 enum 类型, 这样可以让这个参数的值表达其意义</strong>.</li>
<li><strong>如果某个函数有多个配置选项, 你可以考虑定义一个类或结构体以保存所有的选项, 并传入类或结构体的实例</strong>. 这样的方法有许多优点, 例如这样的选项可以在调用处用变量名引用, 这样就能清晰地表明其意义. 同时也减少了函数参数的数量, 使得函数调用更易读也易写. 除此之外, 以这样的方式, 如果你使用其他的选项, 就无需对调用点进行更改.</li>
<li>用具名变量代替大段而复杂的嵌套表达式.</li>
<li>万不得已时, 才考虑在调用点用注释阐明参数的意义.</li>
</ol>
<p>比如下面的示例的对比:</p>
<pre><code>// What are these arguments?
const DecimalNumber product = CalculateProduct(values, 7, false, nullptr);
</code></pre>
<p>和</p>
<pre><code>ProductOptions options;
options.set_precision_decimals(7);
options.set_use_cache(ProductOptions::kDontUseCache);
const DecimalNumber product =
    CalculateProduct(values, options, /*completion_callback=*/nullptr);
</code></pre>
<p>哪个更清晰一目了然.</p>
<p><strong>不允许的行为</strong></p>
<p>  <strong>不要描述显而易见的现象, 永远不要 用自然语言翻译代码作为注释</strong>, 除非即使对深入理解 C++ 的读者来说代码的行为都是不明显的. <strong>要假设读代码的人 C++ 水平比你高, 即便他/她可能不知道你的用意</strong>:</p>
<p>  <strong>你所提供的注释应当解释代码 为什么 要这么做和代码的目的, 或者最好是让代码自文档化</strong>.</p>
<p>比较这样的注释:</p>
<pre><code>// Find the element in the vector.  &lt;-- 差: 这太明显了!
auto iter = std::find(v.begin(), v.end(), element);
if (iter != v.end()) {
  Process(element);
}
</code></pre>
<p>和这样的注释:</p>
<pre><code>// Process &quot;element&quot; unless it was already processed.
auto iter = std::find(v.begin(), v.end(), element);
if (iter != v.end()) {
  Process(element);
}
</code></pre>
<p>  自文档化的代码根本就不需要注释. 上面例子中的注释对下面的代码来说就是毫无必要的:</p>
<pre><code>if (!IsAlreadyProcessed(element)) {
  Process(element);
}
</code></pre>
<h3 id="87-标点-拼写和语法">8.7. 标点, 拼写和语法</h3>
<p><strong>总述</strong></p>
<p>  注意标点, 拼写和语法; 写的好的注释比差的要易读的多.</p>
<p><strong>说明</strong></p>
<p>  注释的通常写法是包含正确大小写和结尾句号的完整叙述性语句. 大多数情况下, 完整的句子比句子片段可读性更高. 短一点的注释, 比如代码行尾注释, 可以随意点, 但依然要注意风格的一致性.</p>
<p>  虽然被别人指出该用分号时却用了逗号多少有些尴尬, 但清晰易读的代码还是很重要的. 正确的标点, 拼写和语法对此会有很大帮助.</p>
<h3 id="88-todo-注释">8.8. TODO 注释</h3>
<p><strong>总述</strong></p>
<p>  <strong>对那些临时的, 短期的解决方案, 或已经够好但仍不完美的代码使用 TODO 注释</strong>.</p>
<p>  TODO 注释要使用<strong>全大写的字符串 TODO, 在随后的圆括号里写上你的名字, 邮件地址, bug ID, 或其它身份标识和与这一 TODO 相关的 issue</strong>. 主要目的是让添加注释的人 (也是可以请求提供更多细节的人) 可根据规范的 TODO 格式进行查找. 添加 TODO 注释并不意味着你要自己来修正, 因此当你加上带有姓名的 TODO 时, 一般都是写上自己的名字.</p>
<pre><code>// TODO(kl@gmail.com): Use a &quot;*&quot; here for concatenation operator.
// TODO(Zeke) change this to use relations.
// TODO(bug 12345): remove the &quot;Last visitors&quot; feature
</code></pre>
<p>  如果加 TODO 是为了在 “将来某一天做某事”, 可以附上一个非常明确的时间 “Fix by November 2005”), 或者一个明确的事项 (“Remove this code when all clients can handle XML responses.”).</p>
<h3 id="89-弃用注释">8.9. 弃用注释</h3>
<p><strong>总述</strong></p>
<p>  <strong>通过弃用注释（DEPRECATED comments）以标记某接口点已弃用.</strong></p>
<p>  您可以写上包含全大写的 DEPRECATED 的注释, 以标记某接口为弃用状态. 注释可以放在接口声明前, 或者同一行.</p>
<p>  在 DEPRECATED 一词后, 在括号中留下您的名字, 邮箱地址以及其他身份标识.</p>
<p>  <strong>弃用注释应当包涵简短而清晰的指引, 以帮助其他人修复其调用点</strong>. 在 C++ 中, <strong>你可以将一个弃用函数改造成一个内联函数, 这一函数将调用新的接口</strong>.</p>
<p>  仅仅标记接口为 DEPRECATED 并不会让大家不约而同地弃用, 您还得亲自主动修正调用点（callsites）, 或是找个帮手.</p>
<p>  修正好的代码应该不会再涉及弃用接口点了, 着实改用新接口点. 如果您不知从何下手, 可以找标记弃用注释的当事人一起商量.</p>
<h3 id="译者笔记">译者笔记</h3>
<ol>
<li>关于注释风格, 很多 C++ 的 coders 更喜欢行注释, C coders 或许对块注释依然情有独钟, 或者在文件头大段大段的注释时使用块注释;</li>
<li>文件注释可以炫耀你的成就, 也是为了捅了篓子别人可以找你;</li>
<li>注释要言简意赅, 不要拖沓冗余, 复杂的东西简单化和简单的东西复杂化都是要被鄙视的;</li>
<li>对于 Chinese coders 来说, 用英文注释还是用中文注释, it is a problem, 但不管怎样, 注释是为了让别人看懂, 难道是为了炫耀编程语言之外的你的母语或外语水平吗；</li>
<li>注释不要太乱, 适当的缩进才会让人乐意看. 但也没有必要规定注释从第几列开始 (我自己写代码的时候总喜欢这样), UNIX/LINUX 下还可以约定是使用 tab 还是 space, 个人倾向于 space;</li>
<li>TODO 很不错, 有时候, 注释确实是为了标记一些未完成的或完成的不尽如人意的地方, 这样一搜索, 就知道还有哪些活要干, 日志都省了.</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[7. 命名约定 -Google C++编程规范]]></title>
        <id>https://lixin-scut.github.io//post/7-ming-ming-yue-ding-google-cbian-cheng-gui-fan</id>
        <link href="https://lixin-scut.github.io//post/7-ming-ming-yue-ding-google-cbian-cheng-gui-fan">
        </link>
        <updated>2020-04-30T14:54:12.000Z</updated>
        <content type="html"><![CDATA[<h3 id="71-通用命名规则">7.1. 通用命名规则</h3>
<p><strong>总述</strong></p>
<p>  函数命名, 变量命名, 文件命名要有描述性; 少用缩写.</p>
<p><strong>说明</strong></p>
<p>  尽可能使用描述性的命名, 别心疼空间, 毕竟相比之下让代码易于新读者理解更重要. 不要用只有项目开发者能理解的缩写, 也不要通过砍掉几个字母来缩写单词.</p>
<pre><code>int price_count_reader;    // 无缩写
int num_errors;            // &quot;num&quot; 是一个常见的写法
int num_dns_connections;   // 人人都知道 &quot;DNS&quot; 是什么
</code></pre>
<pre><code>int n;                     // 毫无意义.
int nerr;                  // 含糊不清的缩写.
int n_comp_conns;          // 含糊不清的缩写.
int wgc_connections;       // 只有贵团队知道是什么意思.
int pc_reader;             // &quot;pc&quot; 有太多可能的解释了.
int cstmr_id;              // 删减了若干字母.
</code></pre>
<p>  注意, 一些特定的广为人知的缩写是允许的, 例如<strong>用 i 表示迭代变量和用 T 表示模板参数.</strong></p>
<p>  模板参数的命名应当遵循对应的分类: <strong>类型模板参数</strong>应当遵循 <strong>类型命名 的规则</strong>, 而<strong>非类型模板</strong>应当遵循 <strong>变量命名 的规则</strong>.</p>
<h3 id="72-文件命名">7.2. 文件命名</h3>
<p><strong>总述</strong></p>
<p>  <strong>文件名要全部小写</strong>, 可以包含下划线 (<code>_</code>) 或连字符 (<code>-</code>), 依照项目的约定. 如果没有约定, 那么 “<code>_</code>” 更好.</p>
<p><strong>说明</strong></p>
<p>可接受的文件命名示例:</p>
<ol>
<li>my_useful_class.cc</li>
<li>my-useful-class.cc</li>
<li>myusefulclass.cc</li>
<li>myusefulclass_test.cc // <code>_unittest</code> 和 <code>_regtest</code> 已弃用.</li>
</ol>
<p>  C++ 文件要以 .cc 结尾, 头文件以 .h 结尾. 专门插入文本的文件则以 .inc 结尾, 参见 头文件自足.</p>
<p>  不要使用已经存在于 /usr/include 下的文件名 (Yang.Y 注: 即编译器搜索系统头文件的路径), 如 db.h.</p>
<p>  通常应尽量让文件名更加明确. http_server_logs.h 就比 logs.h 要好. 定义类时文件名一般成对出现, 如 foo_bar.h 和 foo_bar.cc, 对应于类 FooBar.</p>
<p>  内联函数必须放在 .h 文件中. 如果内联函数比较短, 就直接放在 .h 中.</p>
<h3 id="73-类型命名">7.3. 类型命名</h3>
<p><strong>总述</strong></p>
<p>  <strong>类型名称的每个单词首字母均大写（最典型就是类）</strong>, 不包含下划线: <code>MyExcitingClass</code>,<code>MyExcitingEnum</code>.</p>
<p><strong>说明</strong></p>
<p>  所有类型命名 —— 类, 结构体, 类型定义 (typedef), 枚举, 类型模板参数 —— 均使用相同约定, 即以大写字母开始, 每个单词首字母均大写, 不包含下划线. 例如:</p>
<pre><code>// 类和结构体
class UrlTable { ...
class UrlTableTester { ...
struct UrlTableProperties { ...

// 类型定义
typedef hash_map&lt;UrlTableProperties *, string&gt; PropertiesMap;

// using 别名
using PropertiesMap = hash_map&lt;UrlTableProperties *, string&gt;;

// 枚举
enum UrlTableErrors { ...
</code></pre>
<h3 id="74-变量命名">7.4. 变量命名</h3>
<p><strong>总述</strong></p>
<p>  变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾, 但结构体的就不用, 如: a_local_variable, a_struct_data_member, a_class_data_member_.</p>
<p><strong>说明</strong></p>
<p><strong>普通变量命名</strong></p>
<p>举例:</p>
<pre><code>string table_name;  // 好 - 用下划线.
string tablename;   // 好 - 全小写.

string tableName;  // 差 - 混合大小写
</code></pre>
<p><strong>类数据成员</strong></p>
<p>  不管是静态的还是非静态的, <strong>类数据成员都可以和普通变量一样, 但要接下划线.</strong></p>
<pre><code>class TableInfo {
  ...
 private:
  string table_name_;  // 好 - 后加下划线.
  string tablename_;   // 好.
  static Pool&lt;TableInfo&gt;* pool_;  // 好.
};
</code></pre>
<p><strong>结构体变量</strong></p>
<p>  不管是静态的还是非静态的, <strong>结构体数据成员都可以和普通变量一样, 不用像类那样接下划线:</strong></p>
<pre><code>struct UrlTableProperties {
  string name;
  int num_entries;
  static Pool&lt;UrlTableProperties&gt;* pool;
};
</code></pre>
<p>  结构体与类的使用讨论, 参考 结构体 vs. 类.</p>
<h3 id="75-常量命名">7.5. 常量命名</h3>
<p><strong>总述</strong></p>
<p>  声明为 <code>constexpr</code> 或 <code>const</code> 的变量, 或在程序运行期间其值始终保持不变的, <strong>命名时以 “k” 开头, 大小写混合</strong>. 例如:</p>
<p><code>const int kDaysInAWeek = 7;</code></p>
<p><strong>说明</strong></p>
<p>  所有具有静态存储类型的变量 (例如<strong>静态变量或全局变量</strong>, 参见 存储类型) <strong>都应当以此方式命名</strong>. 对于其他存储类型的变量, 如自动变量等, 这条规则是可选的. 如果不采用这条规则, 就按照一般的变量命名规则.</p>
<h3 id="76-函数命名">7.6. 函数命名</h3>
<p><strong>总述</strong></p>
<p>  <strong>常规函数使用大小写混合, 取值和设值函数则要求与变量名匹配:</strong></p>
<pre><code>MyExcitingFunction();
MyExcitingMethod();
my_exciting_member_variable(); 
set_my_exciting_member_variable();
</code></pre>
<p><strong>说明</strong></p>
<p>  一般来说, 函数名的<strong>每个单词首字母大写</strong> (即 “驼峰变量名” 或 “帕斯卡变量名”), <strong>没有下划线</strong>. 对于首字母缩写的单词, 更倾向于将它们视作一个单词进行首字母大写 (例如, 写作 StartRpc() 而非 StartRPC()).</p>
<pre><code>AddTableEntry()
DeleteUrl()
OpenFileOrDie()
</code></pre>
<p>(同样的命名规则<strong>同时适用于类作用域与命名空间作用域的常量</strong>, 因为它们是作为 API 的一部分暴露对外的, 因此应当让它们看起来像是一个函数, 因为在这时, 它们实际上是一个对象而非函数的这一事实对外不过是一个无关紧要的实现细节.)</p>
<p>  <strong>取值和设值函数的命名与变量一致. 一般来说它们的名称与实际的成员变量对应</strong>, 但并不强制要求. 例如 int count() 与 void set_count(int count).</p>
<h3 id="77-命名空间命名">7.7. 命名空间命名</h3>
<p><strong>总述</strong></p>
<p>  命名空间以小写字母命名. 最高级命名空间的名字取决于项目名称. 要注意避免嵌套命名空间的名字之间和常见的顶级命名空间的名字之间发生冲突.</p>
<p>  顶级命名空间的名称应当是项目名或者是该命名空间中的代码所属的团队的名字. 命名空间中的代码, 应当存放于和命名空间的名字匹配的文件夹或其子文件夹中.</p>
<p>  注意 不使用缩写作为名称 的规则同样适用于命名空间. 命名空间中的代码极少需要涉及命名空间的名称, 因此没有必要在命名空间中使用缩写.</p>
<p>  要避免嵌套的命名空间与常见的顶级命名空间发生名称冲突. 由于名称查找规则的存在, 命名空间之间的冲突完全有可能导致编译失败. 尤其是, 不要创建嵌套的 std 命名空间. 建议使用更独特的项目标识符 (websearch::index, websearch::index_util) 而非常见的极易发生冲突的名称 (比如 websearch::util).</p>
<p>  对于 internal 命名空间, 要当心加入到同一 internal 命名空间的代码之间发生冲突 (由于内部维护人员通常来自同一团队, 因此常有可能导致冲突). 在这种情况下, 请使用文件名以使得内部名称独一无二 (例如对于 frobber.h, 使用 websearch::index::frobber_internal).</p>
<h3 id="78-枚举命名">7.8. 枚举命名</h3>
<p><strong>总述</strong></p>
<p>  <strong>枚举的命名应当和 常量 或 宏 一致: kEnumName 或是 ENUM_NAME.</strong></p>
<p><strong>说明</strong></p>
<p>  <strong>单独的枚举值应该优先采用 常量 的命名方式</strong>. 但 宏 方式的命名也可以接受. 枚举名 UrlTableErrors (以及 AlternateUrlTableErrors) 是类型, 所以要用大小写混合的方式.</p>
<pre><code>enum UrlTableErrors {
    kOK = 0,
    kErrorOutOfMemory,
    kErrorMalformedInput,
};
enum AlternateUrlTableErrors {
    OK = 0,
    OUT_OF_MEMORY = 1,
    MALFORMED_INPUT = 2,
};
</code></pre>
<p>  2009 年 1 月之前, 我们一直建议采用 宏 的方式命名枚举值. 由于枚举值和宏之间的命名冲突, 直接导致了很多问题. 由此, 这里改为<strong>优先选择常量风格的命名方式. 新代码应该尽可能优先使用常量风格</strong>. 但是老代码没必要切换到常量风格, 除非宏风格确实会产生编译期问题.</p>
<h3 id="79-宏命名">7.9. 宏命名</h3>
<p><strong>总述</strong></p>
<p>  你并不打算 使用宏, 对吧? 如果你一定要用, 像这样命名: <strong>MY_MACRO_THAT_SCARES_SMALL_CHILDREN.</strong></p>
<p><strong>说明</strong></p>
<p>  参考 预处理宏; <strong>通常 不应该 使用宏. 如果不得不用, 其命名像枚举命名一样全部大写, 使用下划线</strong>:</p>
<pre><code>#define ROUND(x) ...
#define PI_ROUNDED 3.0
</code></pre>
<h3 id="710-命名规则的特例">7.10. 命名规则的特例</h3>
<p><strong>总述</strong></p>
<p>如果你命名的实体与已有 C/C++ 实体相似, 可参考现有命名策略.</p>
<p>bigopen(): 函数名, 参照 open() 的形式</p>
<p>uint: typedef</p>
<p>bigpos: struct 或 class, 参照 pos 的形式</p>
<p>sparse_hash_map: STL 型实体; 参照 STL 命名约定</p>
<p>LONGLONG_MAX: 常量, 如同 INT_MAX</p>
<p>译者笔记</p>
<ol>
<li>感觉 Google 的命名约定很高明, 比如写了简单的类 QueryResult, 接着又可以直接定义一个变量 query_result, 区分度很好; 再次, 类内变量以下划线结尾, 那么就可以直接传入同名的形参, 比如 TextQuery::TextQuery(std::string word) : word_(word) {} , 其中 word_ 自然是类内私有成员.</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[并查集 547. 朋友圈[中等]]]></title>
        <id>https://lixin-scut.github.io//post/bing-cha-ji-547-peng-you-quan-zhong-deng</id>
        <link href="https://lixin-scut.github.io//post/bing-cha-ji-547-peng-you-quan-zhong-deng">
        </link>
        <updated>2020-04-29T15:23:01.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。<br>
给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。<br>
示例 1:<br>
输入:<br>
[[1,1,0],<br>
[1,1,0],<br>
[0,0,1]]<br>
输出: 2<br>
说明：已知学生0和学生1互为朋友，他们在一个朋友圈。<br>
第2个学生自己在一个朋友圈。所以返回2。<br>
示例 2:<br>
输入:<br>
[[1,1,0],<br>
[1,1,1],<br>
[0,1,1]]<br>
输出: 1<br>
说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。<br>
注意：<br>
N 在[1,200]的范围内。<br>
对于所有学生，有M[i][i] = 1。<br>
如果有M[i][j] = 1，则有M[j][i] = 1。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/friend-circles<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>一开始我的想法比较秀<br>
直接用一个栈保存当前所有“朋友”下标，然后把相应的列全部置0，每个大循环才把ans加一。缺点就是会导致很多没必要的重复循环，改进的方法可以用一个bool的vector保存状态，直接置false的话避免没必要的循环。</p>
<p>然后看了题解发现是并查集，刚好借助这一题来学习一下并查集吧<br>
核心API就是 union()、find()、connect()和count()这三个成员函数和counts、parents[n]、sizes[n]这三个数据成员</p>
<pre><code>class Solution {
public:
		// 并查集
    int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M)
    {
        counts = M.size();
        for(int i = 0; i &lt; M.size(); ++i)
        {
            parents.push_back(i);
            sizes.push_back(1);
        }
        
        for(int i = 0; i &lt; M.size(); ++i)
        {
            for(int j = i+1; j &lt; M.size(); ++j)
            {
                if(M[i][j] == 1)
                {
                    unionM(i,j);
                }
            }
        }
        return counts;
    }
    
    void unionM(int p, int q)
    {
        int rootP = find(p);
        int rootQ = find(q);
        if(rootP == rootQ)
        {   return ; }
        
        if(sizes[rootP] &lt; sizes[rootQ])
        {
            parents[rootP] = rootQ;
            sizes[rootQ] += sizes[rootP];
        }
        else
        {
            parents[rootQ] = rootP;
            sizes[rootP] += sizes[rootQ];
        }
              
        --counts;
        return;    
    }
    
    int find(int x)
    {
        while(x != parents[x])
        {
            parents[x] = parents[parents[x]];
            x= parents[x];
        }
        return x;
    }
    
    bool connected(int p ,int q)
    {
        int rootP = find(p);
        int rootQ = find(q);
        return (rootP == rootQ);
    }
    
    int count()
    {
        return counts;
    }
    
private:
    int counts;
    vector&lt;int&gt; parents;
    vector&lt;int&gt; sizes;
    
    // DFS
    /*
    int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) {
        int ans = 0;
        stack&lt;int&gt; friends;
        for(int i = 0; i &lt; M.size(); ++i)
        {
            if(M[i][i] == 1)
            {
                ++ans;
                M[i][i] = 0;
            }
            friends.push(i);
            while(!friends.empty())
            {
                int index = friends.top();
                friends.pop();
                for(int j = 0; j &lt; M.size(); ++j)
                {
                    if(index != j)
                    {
                        if(M[index][j] == 1)
                        {
                            friends.push(j);  
                        }
                    }
                    M[index][j] = 0;
                }
            }

        }
        return ans;
    }
    */
};
</code></pre>
<p>题解比较长，就不强行贴上来了，可直接查看<a href="https://leetcode-cn.com/problems/friend-circles/solution/union-find-suan-fa-xiang-jie-by-labuladong/">Union-Find 算法详解</a></p>
<p>核心思想：<br>
我们的 Union-Find 算法主要需要实现这两个 API：</p>
<pre><code>class UF {
    /* 将 p 和 q 连接 */
    public void union(int p, int q);
    /* 判断 p 和 q 是否连通 */
    public boolean connected(int p, int q);
    /* 返回图中有多少个连通分量 */
    public int count();
		
		// 记录连通分量
    private int count;
    // 节点 x 的节点是 parent[x]
    private int[] parent;

    /* 构造函数，n 为图的节点总数 */
    public UF(int n) {
        // 一开始互不连通
        this.count = n;
        // 父节点指针初始指向自己
        parent = new int[n];
        for (int i = 0; i &lt; n; i++)
            parent[i] = i;
    }

}
</code></pre>
<p>如果某两个节点被连通，则让其中的（任意）一个节点的根节点接到另一个节点的根节点上：</p>
<pre><code>public void union(int p, int q) {
    int rootP = find(p);
    int rootQ = find(q);
    if (rootP == rootQ)
        return;
    // 将两棵树合并为一棵
    parent[rootP] = rootQ;
    // parent[rootQ] = rootP 也一样
    count--; // 两个分量合二为一
}

/* 返回某个节点 x 的根节点 */
private int find(int x) {
    // 根节点的 parent[x] == x
    while (parent[x] != x)
        x = parent[x];
    return x;
}

/* 返回当前的连通分量个数 */
public int count() { 
    return count;
}
</code></pre>
<p>这样，如果节点p和q连通的话，它们一定拥有相同的根节点：</p>
<pre><code>public boolean connected(int p, int q) {
    int rootP = find(p);
    int rootQ = find(q);
    return rootP == rootQ;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math 60. 第k个排列[中等]]]></title>
        <id>https://lixin-scut.github.io//post/math-60-di-k-ge-pai-lie-zhong-deng</id>
        <link href="https://lixin-scut.github.io//post/math-60-di-k-ge-pai-lie-zhong-deng">
        </link>
        <updated>2020-04-29T12:57:12.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。<br>
按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：<br>
&quot;123&quot;<br>
&quot;132&quot;<br>
&quot;213&quot;<br>
&quot;231&quot;<br>
&quot;312&quot;<br>
&quot;321&quot;<br>
给定 n 和 k，返回第 k 个排列。<br>
说明：<br>
给定 n 的范围是 [1, 9]。<br>
给定 k 的范围是[1,  n!]。<br>
示例 1:<br>
输入: n = 3, k = 3<br>
输出: &quot;213&quot;<br>
示例 2:<br>
输入: n = 4, k = 9<br>
输出: &quot;2314&quot;<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/permutation-sequence<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>最简单的话就是回溯穷举法了，但是很明显应该是有规律的</p>
<p>首先我们将其视为一个迭代的选择过程，有n层迭代，每层选择上一层没选择过的数字，所以我引入了used的bool数组<br>
然后可以固定每一位上数字的时候，它所处的范围都是固定的，<br>
比如123中 如果选定首位为2，那它至少是3起步的，最多为4的，因为选定首位为1的时候可能的数有两个</p>
<p>然后每一层的可能性数量刚好是<code>(n-1)*(n-2)*...*1</code>,所以流程如下</p>
<ol>
<li>int num = (k - 1) / counts ; counts为当前位数的可能性个数（比如第一位可能性共有6个）算出第一位所需的used的第num+1个数字</li>
<li>然后注意index初始化为-1（受num+1影响），然后记得将j赋给index</li>
<li>赋值并修改used状态</li>
<li>k -= num * counts;减去当前位数所占的数字，然后重复上述步骤计算剩余位</li>
<li>最后一位比较特殊，因为k=0的时候k-1得不到我们想要的结果，所以直接寻找used数组中唯一为true的位数，赋值即可</li>
</ol>
<p>其实很多地方可以优化的，很明显的一个就是我完全可以用vector保存1234...n，然后每次取出然后erase，但是erase存在内存搬移，本质上时间复杂度变化，主要还是代码更加简洁，但是暂时无头绪如何优化，先看看题解</p>
<pre><code>class Solution {
public:
    string getPermutation(int n, int k) {
        string ans ;
        vector&lt;bool&gt; used(n, true);
        int counts = 1;
        for(int i = 1; i &lt; n; ++i)
        {
            counts *= i;
        }
        
        
        
        for(int i = 0; i &lt; n; ++i)
        {
            if(i &lt; n - 1)
            {
                int num = (k - 1) / counts ;
                int index = -1;
                for(int j = 0;j &lt; n; ++j)
                {
                    if(used[j])
                    {
                        ++index;
                        if(index == num)
                        {
                            index = j;
                            break;
                        }
                    }   
                }
                ans.push_back('1' + index);
                used[index] = false;
            
                k -= num * counts;
                
                counts /= (n - i - 1);
            }
            else
            {
                int j = 0;
                for(; j &lt; n ; ++j)
                {
                    if(used[j])
                    {
                        break;
                    }
                }       
                ans.push_back('1' + j);
            }
        }
        
        return ans;
    }
};
</code></pre>
<p>网友题解比较精彩， 不过主体也是利用容器保存123...n，然后逐步erase，然后就是回溯法吧</p>
<blockquote>
<p>深度优先遍历 + 剪枝、双链表模拟<br>
思路分析：<br>
比较容易想到的是，使用同「力扣」第 46 题： “全排列” ，即使用回溯搜索的思想，依次得到全排列，输出所求的第 k 个全排列即可。但事实上，我们不必求出所有的全排列。基于以下几点考虑：<br>
1、我们知道所求排列一定在叶子结点处得到。事实上，进入每一个分支的时候，我们都可以通过递归的层数，直接计算这一分支可以得到的叶子结点的个数；<br>
这是因为：进入一个分支的时候，我们可以根据已经选定的数的个数，进而确定还未选定的数的个数，然后计算阶乘，就知道这一个分支的叶子结点有多少个。<br>
2、如果 k 大于这一个分支将要产生的叶子结点数，直接跳过这个分支，这个操作叫“剪枝”；<br>
3、如果k 小于等于这一个分支将要产生的叶子结点数，那说明所求的全排列一定在这一个分支将要产生的叶子结点里，需要递归求解；<br>
4、计算阶乘的时候，你可以使用循环计算，特别注意：0!=1，它表示了没有数可选的时候，即表示到达叶子结点了，排列数只剩下 1 个；<br>
又因为题目中说“给定 n 的范围是 [1,9]，故可以实现把从 0 到 9 的阶乘计算好，放在一个数组里，可以根据索引直接获得阶乘值，见文后“代码 2”。<br>
方法一：借助“回溯”方法中的“剪枝”技巧</p>
</blockquote>
<pre><code>import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Solution {

    /**
     * 记录数字是否使用过
     */
    private boolean[] used;

    /**
     * 阶乘数组
     */
    private int[] factorial;

    private int n;
    private int k;
    /**
     * 从根结点到叶子结点的路径
     */
    private List&lt;Integer&gt; path;

    public String getPermutation(int n, int k) {
        this.n = n;
        this.k = k;
        used = new boolean[n + 1];
        Arrays.fill(used, false);

        // 计算阶乘数组
        factorial = new int[n + 1];
        factorial[0] = 1;
        for (int i = 1; i &lt;= n; i++) {
            factorial[i] = factorial[i - 1] * i;
        }

        path = new ArrayList&lt;&gt;(n);
        dfs(0);

        StringBuilder stringBuilder = new StringBuilder();
        for (Integer c : path) {
            stringBuilder.append(c);
        }
        return stringBuilder.toString();
    }

    /**
     * @param index 在这一步之前已经选择了几个数字，其值恰好等于这一步需要确定的索引位置
     * @return
     */
    private void dfs(int index) {
        if (index == n) {
            return;
        }

        // 还未确定的数字的全排列的个数，第 1 次进入的时候是 n - 1
        int cnt = factorial[n - 1 - index];
        for (int i = 1; i &lt;= n; i++) {
            if (used[i]) {
                continue;
            }
            if (cnt &lt; k) {
                k -= cnt;
                continue;
            }
            path.add(i);
            used[i] = true;
            dfs(index + 1);
        }
    }
}
</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(N<sup>2)，最坏肯定是要找到第N！个，但是第1层只需要比较N-1次，第2层比较N-2次，以此类推，所以最坏是O(N</sup>2)。<br>
空间复杂度：O(N)，nums、used、pre 都与 N 等长，factorial 数组就 10 个数，是常数级别的。</p>
</blockquote>
<blockquote>
<p>方法二：双链表模拟<br>
事实上，上面的过程也可以循环实现，只不过需要借助一个列表，每次选出一个数，就将这个数从列表里面拿出。因为这个列表要支持频繁的删除操作，因此使用双链表，在 Java 中 LinkedList 就是使用双链表实现的。</p>
</blockquote>
<pre><code>import java.util.LinkedList;
import java.util.List;

public class Solution {

    public String getPermutation(int n, int k) {
        // 注意：相当于在 n 个数字的全排列中找到索引为 k - 1 的那个数，因此 k 先减 1
        k --;

        int[] factorial = new int[n];
        factorial[0] = 1;
        // 先算出所有的阶乘值
				//  {0,1,2,6,24,120,720,5040,40320,362880,3628800};
        for (int i = 1; i &lt; n; i++) {
            factorial[i] = factorial[i - 1] * i;
        }

        // 因为要频繁做删除，使用链表
        List&lt;Integer&gt; nums = new LinkedList&lt;&gt;();
        for (int i = 1; i &lt;= n; i++) {
            nums.add(i);
        }

        StringBuilder stringBuilder = new StringBuilder();

        // i 表示剩余的数字个数，初始化为 n - 1
        for (int i = n - 1; i &gt;= 0; i--) {
            int index = k / factorial[i] ;
            stringBuilder.append(nums.remove(index));
            k -= index * factorial[i];
        }
        return stringBuilder.toString();
    }
}
</code></pre>
<p>贴一个C++版</p>
<pre><code>class Solution {
    static const vector&lt;int&gt; fac;
public:
    string getPermutation(int n, int k) {
        string res;
        string s = string(&quot;123456789&quot;).substr(0, n);
        --k;
        while(k &gt; 0)
        {
            size_t i = k/fac[n - 1];
            res.push_back(s[i]);
            s.erase(s.begin() + i);
            k %= fac[n - 1];
            --n;
        }
        return res + s;
    }
};
const vector&lt;int&gt; Solution::fac = {0,1,2,6,24,120,720,5040,40320,362880,3628800};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL 175. 组合两个表[简单]]]></title>
        <id>https://lixin-scut.github.io//post/mysql-175-zu-he-liang-ge-biao-jian-dan</id>
        <link href="https://lixin-scut.github.io//post/mysql-175-zu-he-liang-ge-biao-jian-dan">
        </link>
        <updated>2020-04-29T07:26:44.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>表1: Person<br>
+-------------+---------+<br>
| 列名         | 类型     |<br>
+-------------+---------+<br>
| PersonId    | int     |<br>
| FirstName   | varchar |<br>
| LastName    | varchar |<br>
+-------------+---------+<br>
PersonId 是上表主键<br>
表2: Address<br>
+-------------+---------+<br>
| 列名         | 类型    |<br>
+-------------+---------+<br>
| AddressId   | int     |<br>
| PersonId    | int     |<br>
| City        | varchar |<br>
| State       | varchar |<br>
+-------------+---------+<br>
AddressId 是上表主键<br>
 编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：<br>
FirstName, LastName, City, State<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/combine-two-tables<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题比较简单，重点在于“无论 person 是否有地址信息”，主要就是默认的inner join和outer join的区别，并且还有on和where的区别</p>
<pre><code>SELECT FirstName, LastName, City, State
FROM Person LEFT OUTER JOIN Address
ON Person.PersonId = Address.PersonId
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>方法：使用 outer join<br>
算法<br>
因为表 Address 中的 personId 是表 Person 的外关键字，所以我们可以连接这两个表来获取一个人的地址信息。<br>
考虑到可能不是每个人都有地址信息，我们应该使用 outer join 而不是默认的 inner join。</p>
</blockquote>
<pre><code>MySQL
select FirstName, LastName, City, State
from Person left join Address
on Person.PersonId = Address.PersonId
;
</code></pre>
<p><strong>注意：如果没有某个人的地址信息，使用 where 子句过滤记录将失败，因为它不会显示姓名信息。</strong></p>
<p><strong>《MySQL必知必会》相关知识点</strong><br>
  MySQL的联结表默认为内部联结或等值联结(equijoin)的简单联结，另外三种联结分别是自联结、自然联结和外部联结。</p>
<p><strong>自联结</strong><br>
  自联结就是同一个表联结起来，需要配合表别名使用，使用表别名的主要原因之一是能在单条SELECT语句中不止一次引用相同的表</p>
<p>  自联结可以解决子查询的问题： 自联结通常作为外部语句用来替代 从相同表中检索数据时使用的子查询语句。虽然最终的结果是 相同的，但有时候处理联结远比处理子查询快得多。应该试一 下两种方法，以确定哪一种的性能更好</p>
<p><strong>自然联结</strong><br>
  标准的联结(前一章中介绍的内部联结)返回所有数据，甚 至相同的列多次出现。自然联结排除多次出现，使每个列只返回一次。<br>
  但是系统不完成这项工作，由你自己完成它。自然联结是这样一种联结，其中你只能选择那些唯一的列。这一 般是通过对表使用通配符(SELECT * )，对所有其他表的列使用明确的子 集来完成的。</p>
<p>  事实上，迄今为止我们默认建立的每个内部联结都是自然联结，很可能我们永远都不会用到不是自然联结的内部联结。</p>
<p><strong>外部联结</strong><br>
  联结包含了那些在相关表中没有关联行的行。这种 类型的联结称为外部联结。<br>
  许多联结将一个表中的行与另一个表中的行相关联。但有时候会需要包含没有关联行的那些行。<br>
  在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字 指定包括其所有行的表(RIGHT指出的是OUTER JOIN右边的表，而LEFT 指出的是OUTER JOIN左边的表)。</p>
<p><strong>外部联结的类型</strong><br>
  存在两种基本的外部联结形式:左外部联结 和右外部联结。它们之间的唯一差别是所关联的表的顺序不 同。换句话说，左外部联结可通过颠倒FROM或WHERE子句中表的顺序转换为右外部联结。因此，两种类型的外部联结可互 换使用，而究竟使用哪一种纯粹是根据方便而定。</p>
<p>  使用LEFT OUTER JOIN从FROM子句的左边表中选择所有行。为了从右边的表中选择所有行，应该使用RIGHT OUTER JOIN</p>
<p>注意<br>
  没有<code>*=</code>操作符 MySQL不支持简化字符<code>*=</code>和<code>=*</code>的使用，这两 种操作符在其他DBMS中是很流行的。</p>
<p><strong>使用带聚集函数的联结</strong><br>
  聚集函数用来汇总数据。虽然至今为止聚集函数，但这些函数也可以与联结一起使用。<br>
  聚集函数也可以方便地与其他联结一起使用</p>
<p><strong>使用联结和联结条件</strong></p>
<ul>
<li><strong>注意所使用的联结类型。一般我们使用内部联结，但使用外部联结也是有效的。</strong></li>
<li>保证使用正确的联结条件，否则将返回不正确的数据。</li>
<li><strong>应该总是提供联结条件，否则会得出笛卡儿积。</strong></li>
<li>在一个联结中可以包含多个表，甚至对于每个联结可以采用不同的联结类型。虽然这样做是合法的，一般也很有用，但应该在一 起测试它们前，分别测试每个联结。这将使故障排除更为简单。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 71. 简化路径[中等]]]></title>
        <id>https://lixin-scut.github.io//post/zi-fu-chuan-71-jian-hua-lu-jing</id>
        <link href="https://lixin-scut.github.io//post/zi-fu-chuan-71-jian-hua-lu-jing">
        </link>
        <updated>2020-04-29T05:00:24.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。<br>
在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径<br>
请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。<br>
示例 1：<br>
输入：&quot;/home/&quot;<br>
输出：&quot;/home&quot;<br>
解释：注意，最后一个目录名后面没有斜杠。<br>
示例 2：<br>
输入：&quot;/../&quot;<br>
输出：&quot;/&quot;<br>
解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。<br>
示例 3：<br>
输入：&quot;/home//foo/&quot;<br>
输出：&quot;/home/foo&quot;<br>
解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。<br>
示例 4：<br>
输入：&quot;/a/./b/../../c/&quot;<br>
输出：&quot;/c&quot;<br>
示例 5：<br>
输入：&quot;/a/../../b/../c//.//&quot;<br>
输出：&quot;/c&quot;<br>
示例 6：<br>
输入：&quot;/a//b////c/d//././/..&quot;<br>
输出：&quot;/a/b/c&quot;<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/simplify-path<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>首先题意就是<br>
1.遇到/./直接消除<br>
2.遇到/../消除上一级</p>
<p>我想到一个比较便捷的方法hhh，直接用栈来保存，不管斜杠，直接保存文件目录名和.、..两种，遇到..就pop一下，.可以直接忽略，其他的直接入栈</p>
<p>实现中需要注意的问题</p>
<ol>
<li>所有判断条件都需要加上范围判断，防止访问到非法区域</li>
<li>先找到第一个非斜杠，再找第一个斜杠或者尾后区域</li>
<li>pop之前记得要先判断栈是否为空</li>
<li>因为不需要用到栈的特性加上需要从头访问，所以我用了vector而不是stack或者deque</li>
<li>最后的字符串很麻烦，首先如果是空的路径或者只有&quot;/../&quot;，就只能返回&quot;/&quot;</li>
<li>然后最后还必须把&quot;/&quot;去掉，所以只能按照i的位置来判断是否需要加。。。</li>
</ol>
<pre><code>class Solution {
public:
    string simplifyPath(string path) {
        vector&lt;string&gt; result;
        
        string folder;
        int beg = 0;
        int end = 0;
        int i = 0;
        while(i &lt; path.size())
        {
            while(i &lt; path.size() &amp;&amp; path[i] == '/')
            {
                ++i;
            }
            beg = i;
            while(i &lt; path.size() &amp;&amp; path[i] != '/')
            {
                ++i;
            }
            end = i;
            if(beg &lt; path.size() &amp;&amp; beg &lt; end)
            {
                folder = path.substr(beg, end - beg );
                if(folder == &quot;.&quot;)
                {  continue; }
                else if(folder == &quot;..&quot;)
                {
                    if(!result.empty())
                    {
                        result.pop_back();
                    }
                }
                else
                {
                    result.push_back(folder);
                }
            }
        }
        
        string ans = &quot;/&quot;;
        for(int i = 0; i &lt; result.size(); ++i)
        {
            ans += result[i] ;
            if(i != result.size() - 1)
            {   ans += &quot;/&quot;; } 
        }
        return ans;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 25. K 个一组翻转链表[困难]]]></title>
        <id>https://lixin-scut.github.io//post/lian-biao-25-k-ge-yi-zu-fan-zhuan-lian-biao-kun-nan</id>
        <link href="https://lixin-scut.github.io//post/lian-biao-25-k-ge-yi-zu-fan-zhuan-lian-biao-kun-nan">
        </link>
        <updated>2020-04-29T04:42:52.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。<br>
k 是一个正整数，它的值小于或等于链表的长度。<br>
如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。<br>
示例：<br>
给你这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5<br>
当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5<br>
当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5<br>
说明：<br>
你的算法只能使用常数的额外空间。<br>
你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/reverse-nodes-in-k-group<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>首先想到的是链表反转，这个不难<br>
困难点在于传入函数的两个节点，因为链表反转后必须和前后两个节点进行一个重新链接，所以必须保存好前后两个节点。<br>
最后我是用的是辅助头节点+左开右闭的方式，亦即例如1-2-3-4-5，要反转3-4的时候，传入2和4作为辅助节点<br>
因为pre_node初始化的原因，我们可以把pre_node初始化为5，在循环中直接连接起来<br>
然后2的话必须手动和4连接起来<br>
注意我们必须提前保存3的节点，而不是cur_node节点4，因为反转后变为1-2-4-3，所以3刚好就是下一个需要传入的辅助节点</p>
<p>实现中需要注意的：</p>
<ol>
<li>注意函数中，结点值的指向的变化，最好是保留temp值用于赋值</li>
<li>防止出现循环链表</li>
</ol>
<pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        if(head == nullptr)
        {
            return head;
        }
        ListNode* virHead = new ListNode(-1);
        virHead-&gt;next = head;
        
        ListNode* begin = virHead;
        ListNode* cur_node = begin;
        int index = 0;
        
        while(cur_node != nullptr)
        {
            cur_node = cur_node -&gt;next;
            ++index;
            if(cur_node != nullptr &amp;&amp; index == k)
            {
                ListNode* temp = begin-&gt;next;
                reverseList(begin, cur_node);
                begin = temp;
                cur_node = temp;
                index = 0;
            }
        }
        return virHead-&gt;next;
    }
    
    void reverseList(ListNode* begin, ListNode* end)
    {
        ListNode* pre_node = end-&gt;next;
        ListNode* cur_node = begin-&gt;next;
        ListNode* next_node = end;
        
        ListNode* last = end-&gt;next;
        
        while(cur_node != last)
        {
            next_node = cur_node-&gt;next;
            cur_node-&gt;next = pre_node;
            pre_node = cur_node;
            cur_node = next_node;
        }
        
        begin-&gt;next = pre_node;
    }
};
</code></pre>
<p>然后贴一个网友题解，他的是断开再重连，但是他说的时间复杂度我不是很赞同<br>
，我认为是O(2n)</p>
<blockquote>
<p>步骤分解:<br>
1.链表分区为已翻转部分+待翻转部分+未翻转部分<br>
2.每次翻转前，要确定翻转链表的范围，这个必须通过 k 此循环来确定<br>
3.需记录翻转链表前驱和后继，方便翻转完成后把已翻转部分和未翻转部分连接起来<br>
4.初始需要两个变量 pre 和 end，pre 代表待翻转链表的前驱，end 代表待翻转链表的末尾<br>
5.经过k此循环，end 到达末尾，记录待翻转链表的后继 next = end.next<br>
6.翻转链表，然后将三部分链表连接起来，然后重置 pre 和 end 指针，然后进入下一次循环<br>
7.特殊情况，当翻转部分长度不足 k 时，在定位 end 完成后，end==null，已经到达末尾，说明题目已完成，直接返回即可</p>
</blockquote>
<pre><code>public ListNode reverseKGroup(ListNode head, int k) {
    ListNode dummy = new ListNode(0);
    dummy.next = head;

    ListNode pre = dummy;
    ListNode end = dummy;

    while (end.next != null) {
        for (int i = 0; i &lt; k &amp;&amp; end != null; i++) end = end.next;
        if (end == null) break;
        ListNode start = pre.next;
        ListNode next = end.next;
        end.next = null;
        pre.next = reverse(start);
        start.next = next;
        pre = start;

        end = pre;
    }
    return dummy.next;
}

private ListNode reverse(ListNode head) {
    ListNode pre = null;
    ListNode curr = head;
    while (curr != null) {
        ListNode next = curr.next;
        curr.next = pre;
        pre = curr;
        curr = next;
    }
    return pre;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[shared_ptr与weak_ptr的底层实现]]></title>
        <id>https://lixin-scut.github.io//post/shared_ptr-yu-weak_ptr-de-di-ceng-shi-xian</id>
        <link href="https://lixin-scut.github.io//post/shared_ptr-yu-weak_ptr-de-di-ceng-shi-xian">
        </link>
        <updated>2020-04-28T08:41:54.000Z</updated>
        <content type="html"><![CDATA[<p>面试的时候遇到一个问题：weak_ptr怎么去感知shared_ptr已经被析构呢？</p>
<p>先贴一下我的思考过程吧：</p>
<h3 id="面试回答">面试回答</h3>
<p>在面试的过程中我参考了引用计数的方式</p>
<ol>
<li>认为在shared_ptr里面应该有一个弱引用计数</li>
<li>在shared_ptr赋值给weak_ptr的时候就会相应地增加这个弱引用计数</li>
<li>然后在weak_ptr析构的时候自动提升为shared_ptr然后减少弱引用计数。</li>
<li>最后在shared_ptr析构的时候，如果普通计数达到了就析构所指对象，但是  如果此时弱引用计数不为0的话就先不用析构shared_ptr，使得weak_ptr可以继续访问shared_ptr的弱引用计数</li>
</ol>
<p>  但是这个答案有个问题就是如果由shared_ptr来保存弱引用计数的话，如果shared_ptr析构后怎么保存这个弱引用计数呢？后来面试结束后我去寻找这个问题的答案</p>
<h3 id="官方文档">官方文档</h3>
<p>  c++的官方文档中中并没有给出函数的具体代码，但是从成员函数的描述中我们可以发现一些蛛丝马迹</p>
<p>首先是lock()：</p>
<blockquote>
<p>Returns a shared_ptr with the information preserved by the weak_ptr object if it is not <strong>expired</strong>.<br>
说明和expired成员函数有关（虽然有点强行hhh）</p>
</blockquote>
<p>然后再看expired()：</p>
<blockquote>
<p>Returns whether the weak_ptr object is either empty or there are no more shared_ptr in the owner group it belongs to.<br>
Expired pointers act as empty weak_ptr objects when locked, and thus can no longer be used to restore an owning shared_ptr.<br>
This function <strong>shall return the same as (use_count()==0)</strong>, although it may do so in a more efficient way.</p>
</blockquote>
<p>这里就说明expired内部很可能是调用了use_count来作为返回判断结果</p>
<p>最后看一下use_count()</p>
<blockquote>
<p>Returns the number of shared_ptr objects that share ownership over the same pointer as this object.<br>
Notice that weak_ptr objects in the owning group are not counted.<br>
If this is an empty weak_ptr, the function <strong>returns zero</strong>.<br>
Library implementations are not required to keep a count of any particular set of owners, and thus it may not be efficient to call this function. To check specifically <strong>whether use_count is 0</strong>, you can use member expired instead, which may be faster.</p>
</blockquote>
<p>这里就说明会返回一个0，那这个0是怎么来的呢？</p>
<p>代码实验</p>
<pre><code>weak_ptr&lt;int&gt; weak_ptr1;

void setptr()
{
    shared_ptr&lt;int&gt; shared_ptr1(new int(10));
    weak_ptr1 = shared_ptr1;
    cout&lt;&lt;weak_ptr1.use_count()&lt;&lt;endl;
}

int main() {
    setptr();
    cout&lt;&lt;weak_ptr1.use_count()&lt;&lt;endl;
}
// 输出 1 与 0
</code></pre>
<p>  注意此时shared_ptr应该已经是被析构的了，说明我在面试中的答案确实无法完全解释这个问题，应该是从某处继续保留了这个0值</p>
<h3 id="boost源码">boost源码</h3>
<p>智能指针都是起源于boost库<br>
所以最后还是探索一下源码</p>
<p>这篇文章<a href="https://blog.csdn.net/ithiker/article/details/51532484?utm_source=blogxgwz1">C++ 智能指针（shared_ptr/weak_ptr）源码分析</a>总结得比较好，值得学习<br>
源码有一千行+，就不直接贴上来了</p>
<p>首先上个人总结：</p>
<ol>
<li>两种智能指针内部都包含两个部分，一个是指向动态分配对象的裸指针，另一个是对象__shared_count或者__weak_count，两者都是包含指向一个管理对象的指针</li>
<li>指向动态分配对象的裸指针主要用于重载原生指针的操作，进行访问等</li>
<li>对象__shared_count或者__weak_count指向同一个管理对象，其中包括use_count、weak_count、指向动态分配对象的裸指针和删除器</li>
<li>注意__shared_ptr直接包含的裸指针是为了实现一般指针的<code>-&gt;,*</code>等操作，通过__shared_count间接包含的指针是为了管理对象的生命周期，回收相关资源。</li>
<li>然后注意use_count达到0的时候就会析构被管理的动态分配对象和shared_ptr，但是如果weak_ptr还存在的话，那_M_weak_count必不为1，所以管理对象_Sp_counted_base_impl不会被析构，所以就可以让weak_ptr的use_count()操作返回0，但是注意_M_weak_count是无法返回的</li>
<li>注意除了循环引用，还有一个问题就是多个不相关的shared_ptr指向同一个对象造成二次析构，所以此时就要使用enable_shared_from_this，基本思想是通过M继承模板类enable_shared_from_this，这样对象M内部将会有一个__weak_ptr指针_M_weak_this，在第一次创建指向M的shared_ptr Pt时，通过模板特化，将会初始化_M_weak_this;这样M内部也会产生一个指向自身的weak_ptr，并且该weak_ptr内部的管理对象与Pt的管理对象是相同的。这样，在M内部，当需要传递指向M的智能指针时，可以通过继承而来的shared_from_this方法获取到指向M的智能指针而不会发生内存泄漏。</li>
<li>在采用<code>shared_ptr&lt;M&gt; p(new M);</code>形式创建p来管理M时，我们实际发现这中间有两次的动态内存分配：一次为创建被管理对象M，一次为创建管理对象；采用<code>shared_ptr&lt;M&gt; p(make_shared&lt;M&gt;);</code>的方式，采用这种方式系统将会分配一大块内存同时存放管理对象和被管理对象，这就避免了上面所说的二次内存分配的问题，同时程序中也不会出现new操作符，符合&quot;no naked new!&quot;的编程倡导。</li>
</ol>
<h3 id="主要分析">主要分析</h3>
<p>主要的类关系<br>
<img src="https://lixin-scut.github.io//post-images/1588074947135.png" alt=""><br>
  从上面的类图可以清楚的看出shared_ptr内部含有一个指向<strong>被管理对象(managed object)</strong> T的指针以及一个<code>__shared_count</code>对象，  <code>__shared_count</code>对象包含一个指向<strong>管理对象(manager object)</strong> 的基类指针，管理对象(manager object)由具有原子属性的use_count和weak_count、指向被管理对象(managed object)T的指针、以及用来销毁被管理对象的deleter组成，以下均将用new创建后托管给shared_ptr等智能指针管理的对象叫做<strong>被管理对象（managed object)</strong>；shared_ptr等智能指针内部创建的用来维护被管理对象生命周期的实例叫做<strong>管理对象(manager object)</strong>：<br>
<img src="https://lixin-scut.github.io//post-images/1588075047344.png" alt=""></p>
<p>  weak_ptr内部组成与shared_ptr类似，内部同样含有一个指向被管理对象T的指针以及一个__weak_count对象：<br>
<img src="https://lixin-scut.github.io//post-images/1588075070650.png" alt=""></p>
<p>  从图对比可以看出，shared_ptr与weak_ptr的差异主要是由__shared_ptr与__weak_ptr体现出来的，而__shared_ptr与__weak_ptr的差异则主要是由__shared_count与__weak_count体现出来。</p>
<p>  通过shared_ptr的构造函数，可以发现，在创建一个shared_ptr的时候需要一个new 操作符返回被管理对象的地址来初始化shared_ptr, shared_ptr在内部会构建一个_shared_count对象，由_shared_count对象的构造函数可知，创建shared_ptr的时候也动态的创建了一个管理对象_Sp_counted_base_impl:</p>
<pre><code>template&lt;typename _Tp1&gt; explicit __shared_ptr(_Tp1* __p)
: _M_ptr(__p), _M_refcount(__p) {
    __glibcxx_function_requires(_ConvertibleConcept&lt;_Tp1*, _Tp*&gt;)
    typedef int _IsComplete[sizeof(_Tp1)];
    __enable_shared_from_this_helper(_M_refcount, __p, __p);
}
 
template&lt;typename _Ptr&gt;
__shared_count(_Ptr __p) : _M_pi(0)
{
    __try
   {
	  typedef typename std::tr1::remove_pointer&lt;_Ptr&gt;::type _Tp;
	  _M_pi = new _Sp_counted_base_impl&lt;_Ptr, _Sp_deleter&lt;_Tp&gt;, _Lp&gt;(__p, _Sp_deleter&lt;_Tp&gt;());
    }
    __catch(...)
    {
        delete __p;
	__throw_exception_again;
    }
</code></pre>
<p>  <strong>shared_ptr内部包含一个指向被管理对象的指针_M_ptr, <code>_Sp_counted_base_impl</code>内部也含有一个指向被管理对象的指针_M_ptr， 它们是不是重复多余了呢？</strong></p>
<p>  实际上不多余，它们有各自的功能。这首先要从shared_ptr的拷贝构造或者赋值构造说起，当一个shared_ptr对象sp2是由sp1拷贝构造或者赋值构造得来的时候，实际上构造完成后sp1内部的__shared_count对象包含的指向管理对象的指针与sp2内部的__shared_count对象包含的指向管理对象的指针是相等的，也就是说当<strong>多个shared_ptr对象来管理同一个对象时，它们共同使用同一个动态分配的管理对象。</strong> 这可以从下面的__share_ptr的构造函数和__shared_count的构造函数清楚的看出。</p>
<pre><code>template&lt;typename _Tp1&gt;
 __shared_ptr(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __r)
 : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) // never throws
{__glibcxx_function_requires(_ConvertibleConcept&lt;_Tp1*, _Tp*&gt;)}
 
 
__shared_count&amp;
operator=(const __shared_count&amp; __r) // nothrow
{
    _Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;
    if (__tmp != _M_pi)
    {
        if (__tmp != 0)
            __tmp-&gt;_M_add_ref_copy();
	if (_M_pi != 0)
	    _M_pi-&gt;_M_release();
	
        _M_pi = __tmp;
    }
}
</code></pre>
<p>  上面说说当多个shared_ptr对象来管理同一个对象时，它们共同使用同一个动态分配的管理对象，为什么上面给出的_shared_count的构造函数中出现了<code>__tmp != _M_pi</code>的情形呢？这在sp2未初始化时（<code>_M_pi</code>为0，<code>_r._M_pi</code>非0）便是这样的情形。</p>
<p>  更一般的，也可以考虑这样的情形：shared_ptr实例sp1开始指向类A的实例对象a1, 另外一个shared_ptr实例sp2指向类A的实例对象a2（a1 != a2)，当把sp2赋值给sp1时便会出现上面的情形。假设初始时有且仅有一个sp1指向a1, 有且仅有一个sp2指向a2; 则赋值结束时sp1与sp2均指向a2, 没有指针指向a1, sp1指向的a1以及其对应的管理对象均应该被析构。这在上面的代码中我们可以很清楚的看到：因为<code>__tmp != _M_pi</code>,  <code>__tmp-&gt;_M_add_ref_copy()</code>将会增加a2的use_count的引用计数；由于a1内部的_M_pi != 0, 将会调用其_M_release()函数：</p>
<pre><code>//************_Sp_counted_base*****************//
void
_M_add_ref_copy()
{ __gnu_cxx::__atomic_add_dispatch(&amp;_M_use_count, 1); }
 
 
//************_Sp_counted_base*****************//
void
_M_release() // nothrow
{
    // Be race-detector-friendly.  For more info see bits/c++config.
    _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_use_count);
	if (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_use_count, -1) == 1)
	{
            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_use_count);
	    _M_dispose();
	    // There must be a memory barrier between dispose() and destroy()
	    // to ensure that the effects of dispose() are observed in the
	    // thread that runs destroy().
	    // See http://gcc.gnu.org/ml/libstdc++/2005-11/msg00136.html
	    if (_Mutex_base&lt;_Lp&gt;::_S_need_barriers)
	    {
		    __atomic_thread_fence (__ATOMIC_ACQ_REL);
	    }
 
            // Be race-detector-friendly.  For more info see bits/c++config.
            _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_weak_count);
	    if (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_weak_count, -1) == 1)
            {
		_GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_weak_count);
	        _M_destroy();
             }
	}
}
 
//************_Sp_counted_base*****************//
// Called when _M_use_count drops to zero, to release the resources
// managed by *this.
virtual void
_M_dispose() = 0; // nothrow
 
// Called when _M_weak_count drops to zero.
virtual void
_M_destroy() // nothrow
{ delete this; }
 
//************_Sp_counted_base_impl*************//
virtual void
_M_dispose() // nothrow
{ _M_del(_M_ptr); }
</code></pre>
<p>  <code>_M_release()</code>函数首先对a1的use_count减去1，并对比减操作之前的值，如果减之前是1，说明减后是0，a1没有任何shared_ptr指针指向它了，应该将a1对象销毁，于是调用_M_dispose()函数销毁a1; 同时对a1的weak_count减去1，也对比减操作之前的值，如果减之前是1，说明减后是0，a1没有weak_ptr指向它了，应该将管理对象销毁，于是调用_M_destroy()销毁了管理对象。这就可以解答为什么图2所示中shared_ptr内部含有两个指向被管理对象的指针了：<strong><code>shared_ptr</code>直接包含的裸指针是为了实现一般指针的<code>-&gt;,*</code>等操作，通过<code>shared_count</code>间接包含的指针是为了管理对象的生命周期，回收相关资源。</strong></p>
<p>  换句话说，<strong><code>shared_count</code>内部的<code>use_count</code>主要用来标记被管理对象的生命周期，<code>weak_count</code>主要用来标记管理对象的生命周期。</strong></p>
<p>  当一个shared_ptr超出作用域被销毁时，它会调用其_share_count的_M_release()对use_count和weak_count进行自减并判断是否需要释放管理对象和被管理对象，这是RAII原理的核心体现：</p>
<pre><code>~__shared_count() // nothrow
 {
	 if (_M_pi != 0)
	  _M_pi-&gt;_M_release();
 }
</code></pre>
<p>对于weak_ptr, 其对应的__weak_count的拷贝构造函数如下:</p>
<pre><code>//************_Sp_counted_base*****************//
 void
 _M_weak_add_ref() // nothrow
{ __gnu_cxx::__atomic_add_dispatch(&amp;_M_weak_count, 1); }
 
//************_Sp_counted_base*****************//
void
_M_weak_release() // nothrow
{
    // Be race-detector-friendly. For more info see bits/c++config.
    _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_weak_count);
    if (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_weak_count, -1) == 1)
    {
        _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_weak_count);
	if (_Mutex_base&lt;_Lp&gt;::_S_need_barriers)
	{
	    // See _M_release(),
	    // destroy() must observe results of dispose()
            __atomic_thread_fence (__ATOMIC_ACQ_REL);
	}
	_M_destroy();
    }
}
 
__weak_count&lt;_Lp&gt;&amp;
operator=(const __shared_count&lt;_Lp&gt;&amp; __r) // nothrow
{
    _Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;
    if (__tmp != 0)
        __tmp-&gt;_M_weak_add_ref();
  
    if (_M_pi != 0)
        _M_pi-&gt;_M_weak_release();
  
    _M_pi = __tmp;  
	
    return *this;
}
      
__weak_count&lt;_Lp&gt;&amp;
operator=(const __weak_count&lt;_Lp&gt;&amp; __r) // nothrow
{
    _Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;
    if (__tmp != 0)
        __tmp-&gt;_M_weak_add_ref();
    if (_M_pi != 0)
        _M_pi-&gt;_M_weak_release();
    _M_pi = __tmp;
	
    return *this;
}
 
__weak_count&lt;_Lp&gt;&amp;
operator=(const __shared_count&lt;_Lp&gt;&amp; __r) // nothrow
{
    _Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;
    if (__tmp != 0)
      __tmp-&gt;_M_weak_add_ref();
    if (_M_pi != 0)
      _M_pi-&gt;_M_weak_release();
    _M_pi = __tmp;  
    return *this;
}
 
~__weak_count() // nothrow
{
    if (_M_pi != 0)
        _M_pi-&gt;_M_weak_release();
}
</code></pre>
<p>从上面可以看出:</p>
<p>  <code>__weak_count</code>相关的赋值拷贝以及析构函数均只会影响到weak_count的值，对use_count没有影响；当weak_count为0时，释放管理对象。也就是说__weak_ptr不影响被管理对象的生命周期。同时<strong>由于weak_ptr没有像shared_ptr那样实现*，-&gt;等常见指针相关操作符，weak_ptr不能直接操作被管理对象；</strong><br>
  <code>__weak_count</code>自身间的赋值以及<code>__shared_count</code>对<code>__weak_count</code>的赋值时，它们都具有同样的指向管理对象的指针；也就是说<strong>当多个<code>weak_ptr</code>和<code>shared_ptr</code>指向同一个被管理对象时，它们共享同一个管理对象</strong>，这就保证了可以通过<code>__weak_ptr</code>可以判断<code>__shared_ptr</code>指向的被管理对象是否存在以及获取到被管理对象的指针。<br>
 <br>
<code>__shared_ptr</code>与<code>__weak_ptr</code>在管理同一对象时，它们间的关系如下图4所示：<br>
<img src="https://lixin-scut.github.io//post-images/1588075449346.png" alt=""></p>
<p>  由于weak_ptr不能直接操作被管理对象但其仍然持有指向被管理对象的指针（用来初始化内部的__weak_count对象），weak_ptr与被管理对象用虚线联接。</p>
<p>  <code>_weak_ptr</code>有几个重要的成员函数：通过expired()方法来判断对象是否过期（已经被释放）；通过use_count()方法返回目前有多少个<code>__shared_ptr</code>对象指向被管理对象；通过lock()方法返回一个指向被管理对象的<code>__shared_ptr</code>指针，调用者可以通过这个<code>__shared_ptr</code>指针来操纵被管理对象而不用担心资源泄漏；</p>
<pre><code>/*************_weak_ptr*************************/
long
use_count() const // never throws
{ return _M_refcount._M_get_use_count(); }
 
bool
expired() const // never throws
{ return _M_refcount._M_get_use_count() == 0; }
 
__shared_ptr&lt;_Tp, _Lp&gt;
lock() const // never throws
{
#ifdef __GTHREADS
       // Optimization: avoid throw overhead.
    if (expired())
              return __shared_ptr&lt;element_type, _Lp&gt;();
 
    __try
    {
            return __shared_ptr&lt;element_type, _Lp&gt;(*this);
    }
    __catch(const bad_weak_ptr&amp;)
    {
        // Q: How can we get here?
       // A: Another thread may have invalidated r after the
       //    use_count test above.
       return __shared_ptr&lt;element_type, _Lp&gt;();
     }
    
#else
    // Optimization: avoid try/catch overhead when single threaded.
    return expired() ? __shared_ptr&lt;element_type, _Lp&gt;()
                     : __shared_ptr&lt;element_type, _Lp&gt;(*this);
 
#endif
} // XXX MT
</code></pre>
<p>  当然shared_ptr也不是万能的，使用的时候也要注意到它给程序员挖的一个大坑：shared_ptr能够管理对象的生命周期，负责对象资源释放，其前提条件是所有shared_ptr共用同一个管理对象。如果多个shared_ptr使用多个管理对象来管理同一个被管理对象，这些管理对象在use_count为0时均会释放被管理对象，将会造成多个管理对象多次释放被管理对象，造成twice delete的堆错误。下面的例子在单独使用裸指针的时候没有问题，采用shared_ptr将会出现twice delete的问题：</p>
<pre><code>class Thing {
public:
	void foo();
	void defrangulate();
};
void transmogrify(Thing *);
int main()
{
	Thing * t1 = new Thing;
	t1-&gt;foo();
	...
	delete t1; // done with the object
}
...
void Thing::foo()
{
	// we need to transmogrify this object
	transmogrify(this);
}
void transmogrify(Thing * ptr)
{
	ptr-&gt;defrangulate();
	/* etc. */
}
//***** Use shared_ptr***************************//
class Thing {
public:
	void foo();
	void defrangulate();
};
void transmogrify(shared_ptr&lt;Thing&gt;);
int main()
{
	shared_ptr&lt;Thing&gt; t1(new Thing); // create manager object A for the Thing
	t1-&gt;foo();
	...
	// Thing is supposed to get deleted when t1 goes out of scope
}
void Thing::foo()
{
	// we need to transmogrify this object
	shared_ptr&lt;Thing&gt; sp_for_this(this); //  create manager object B for the Thing
	transmogrify(sp_for_this);
	
	// Thing is supposed to get deleted when sp_for_this and other shared_ptr goes out of scope
}
void transmogrify(shared_ptr&lt;Thing&gt; ptr)
{
	ptr-&gt;defrangulate();
	/* etc. */
}
</code></pre>
<p>  上面注释处分别创建了两个shared_ptr指针t1，sp_for_this, 它们各自有自己的管理对象，但被管理的堆内存却是一样的，这就导致在t1和sp_for_this析构时，它们各自的管理对象均会析构被管理对象，造成twice delete。</p>
<p>  怎样解决上面这一广泛存在问题：当一个对象M创建后，如果一个函数f（另一个类的成员函数或是其它自由函数）的形参为M类型的智能指针，如何在对象M内部将对象M的指针作为实参传递给该函数f ? C++引入了enable_shared_from_this利用weak_ptr的特性解决了这一问题。其基本思想是通过M继承模板类enable_shared_from_this，这样对象M内部将会有一个__weak_ptr指针_M_weak_this，在第一次创建指向M的shared_ptr Pt时，通过模板特化，将会初始化_M_weak_this;这样M内部也会产生一个指向自身的weak_ptr，并且该weak_ptr内部的管理对象与Pt的管理对象是相同的（这可以从weak_ptr内部的_M_assign函数看出）。</p>
<pre><code>// Friend of enable_shared_from_this.
template&lt;typename _Tp1, typename _Tp2&gt;
void __enable_shared_from_this_helper(const __shared_count&lt;&gt;&amp;, const enable_shared_from_this&lt;_Tp1&gt;*, const _Tp2*);
 
 
template&lt;typename _Tp1&gt;
explicit __shared_ptr(_Tp1* __p)
: _M_ptr(__p), _M_refcount(__p)
{
	__glibcxx_function_requires(_ConvertibleConcept&lt;_Tp1*, _Tp*&gt;) typedef int _IsComplete[sizeof(_Tp1)];
	__enable_shared_from_this_helper(_M_refcount, __p, __p);
 
} 
 
template&lt;typename _Tp&gt;
class enable_shared_from_this
{
protected:
	enable_shared_from_this() { }
      
    enable_shared_from_this(const enable_shared_from_this&amp;) { }
 
    enable_shared_from_this&amp;
    operator=(const enable_shared_from_this&amp;)
    { return *this; }
 
    ~enable_shared_from_this() { }
 
public:
    shared_ptr&lt;_Tp&gt;
    shared_from_this()
    { return shared_ptr&lt;_Tp&gt;(this-&gt;_M_weak_this); }
 
    shared_ptr&lt;const _Tp&gt;
    shared_from_this() const
    { return shared_ptr&lt;const _Tp&gt;(this-&gt;_M_weak_this); }
 
    private:
    template&lt;typename _Tp1&gt;
    void
    _M_weak_assign(_Tp1* __p, const __shared_count&lt;&gt;&amp; __n) const
    { _M_weak_this._M_assign(__p, __n); }
 
    template&lt;typename _Tp1&gt;
    friend void
    __enable_shared_from_this_helper(const __shared_count&lt;&gt;&amp; __pn, const enable_shared_from_this* __pe, const _Tp1* __px)
    {
	if (__pe != 0)
	 __pe-&gt;_M_weak_assign(const_cast&lt;_Tp1*&gt;(__px), __pn);
    }
    
    mutable weak_ptr&lt;_Tp&gt;  _M_weak_this;
};
 
_M_assign(_Tp* __ptr, const __shared_count&lt;_Lp&gt;&amp; __refcount)
{
    _M_ptr = __ptr;
   _M_refcount = __refcount;
}
</code></pre>
<p>  这样，在M内部，当需要传递指向M的智能指针时，可以通过继承而来的shared_from_this方法获取到指向M的智能指针而不会发生内存泄漏。上面示例中改写后的正确代码为：</p>
<pre><code>class Thing : public enable_shared_from_this&lt;Thing&gt; {
public:
	void foo();
	void defrangulate();
};
int main()
{
	// The following starts a manager object for the Thing and also
	// initializes the weak_ptr member that is now part of the Thing and share same manager object.
	shared_ptr&lt;Thing&gt; t1(new Thing);
	t1-&gt;foo();
	...
}
void Thing::foo()
{
	// get a shared_ptr from the weak_ptr in this object
	shared_ptr&lt;Thing&gt; sp_this = shared_from_this();
	transmogrify(sp_this);
}
void transmogrify(shared_ptr&lt;Thing&gt; ptr)
{
	ptr-&gt;defrangulate();
	/* etc. */
}
</code></pre>
<p>  解决了所有的坑，shared_ptr是不是就十全十美了呢？当然不是，shared_ptr也存在不足：在采用<code>shared_ptr&lt;M&gt; p(new M);</code>形式创建p来管理M时，我们实际发现这中间有两次的动态内存分配：一次为创建被管理对象M，一次为创建管理对象；而内存分配通常是比较昂贵的操作。</p>
<p>  如果频繁的需要创建指向多个不同对象的智能指针，可以采用<code>shared_ptr&lt;M&gt; p(make_shared&lt;M&gt;);</code>的方式，采用这种方式系统将会分配一大块内存同时存放管理对象和被管理对象，这就避免了上面所说的二次内存分配的问题，同时程序中也不会出现new操作符，符合&quot;no naked new!&quot;的编程倡导。当然这也有缺点，如果所有指向该对象的智能指针都销毁了，尽管对象的析构函数会被调用，析构被管理对象，但是如果还有weak_ptr指向该块对象所在的内存，存放管理对象的部分内存仍将不会被释放，因而导致在所有其他weak_ptr销毁前整块内存（尽管被管理对象已经析构了）将不会进入系统的内存池循环使用。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 93. 复原IP地址[中等]]]></title>
        <id>https://lixin-scut.github.io//post/zi-fu-chuan-93-fu-yuan-ip-di-zhi-zhong-deng</id>
        <link href="https://lixin-scut.github.io//post/zi-fu-chuan-93-fu-yuan-ip-di-zhi-zhong-deng">
        </link>
        <updated>2020-04-28T02:38:52.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。<br>
示例:<br>
输入: &quot;25525511135&quot;<br>
输出: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/restore-ip-addresses<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>第一想法是首先列出IP地址的限制</p>
<ol>
<li>长度不小于4，不超过12</li>
<li>每个位置可能的数字为0-255</li>
</ol>
<p>然后打算采用递归的方法<br>
然后分割为4部分， 然后不断地检测剩余的长度是否符合要求</p>
<p>然后发现一个0的问题。。。比如01和010这种<br>
必须判断合理性</p>
<pre><code>class Solution {
public:
    vector&lt;string&gt; restoreIpAddresses(string s) 
    {
        vector&lt;string&gt; res;
        restoreIpAddresses(s,&quot;&quot;, 0, 0, res);
        return res;
    }
    
    void restoreIpAddresses(string s,string ip, int beg, int level, vector&lt;string&gt;&amp; res)
    {
        if(level == 4 )
        {   
            if(beg == s.size())
            {   res.push_back(ip.substr(1)); }
            return;
        }
        if(s.size() - beg &lt; (4 - level)
           || s.size() - beg &gt; (4 - level)*3)
        {
            return;
        }
        
        
        string temp = &quot;&quot;;
        
        temp = ip + &quot;.&quot; + s.substr(beg, 1);
        restoreIpAddresses(s, temp, beg+1, level+1, res);
        if(s.size() - beg &gt; 1 &amp;&amp; stoi(s.substr(beg,2)) &gt; 9)
        {
            temp = ip + &quot;.&quot; + s.substr(beg, 2);
            restoreIpAddresses(s, temp, beg+2, level+1, res);
        }
        
        if(s.size() - beg &gt; 2 &amp;&amp; stoi(s.substr(beg,3)) &lt; 256 &amp;&amp; stoi(s.substr(beg,3)) &gt; 99)
        {
            temp = ip + &quot;.&quot; + s.substr(beg, 3);
            restoreIpAddresses(s, temp, beg+3, level+1, res);
        }        
    }
};
</code></pre>
<p>比较好的网友题解：</p>
<pre><code>class Solution {
public:
    vector&lt;string&gt; restoreIpAddresses(string s) {
        vector&lt;string&gt; res;
       // string out = &quot;&quot;;
        helper(res,s,&quot;&quot;,4);
        return res;
    }
    
    void helper(vector&lt;string&gt;&amp; res,string s,string out,int k)
    {
        if(k==0)
        {
            if(s.empty())     //注意点一，原字符串s应该要为空了
                res.push_back(out);
        }
        else
        {
            for(int i = 1;i&lt;=3;i++)
            {
                //截取某部分进行判断，如果合法则进入下一个递归
                if(s.size()&gt;=i&amp;&amp;isValid(s.substr(0,i)))  //注意点二，越界判断
                {
                    if(k==1)  //k==1代表当前ip再添加多一个结点就够四个了
                        helper(res,s.substr(i),out+s.substr(0,i),k-1);
                    else
                        helper(res,s.substr(i),out+s.substr(0,i)+'.',k-1);
                }
            }
        }
    }
    
    //判断是否合法
    bool isValid(string s)
    {
        if(s.empty()||s.size()&gt;3||(s.size()&gt;1&amp;&amp;s[0]=='0'))
            return false;
        int num = atoi(s.c_str());
        return num&gt;=0&amp;&amp;num&lt;=255;
    }
};
</code></pre>
<p>网友题解整洁很多，值得学习</p>
<blockquote>
<p>官方题解：<br>
直觉<br>
最朴素的解法是暴力法,<br>
换而言之，检查点可能的所有位置，并只保留有效的部分。在最坏的情况下，有11个可能的位置，因此需要11×10×9=990 次检查。<br>
可以通过以下两个概念来优化。<br>
第一个概念是 约束规划。<br>
这意味着对每个点的放置设置一些限制。若已经放置了一个点，下一个点只有 3 种可能：1/2/3个数字之后。<br>
这样做传播了_约束_ ，且减少了需要考虑的情况。我们只需要检测 3×3×3=27种情况，而非990 种。<br>
第二个概念是 回溯。<br>
我们假设已经放置了一或两个点使得无法摆放其他点来生成有效IP地址。这时应该做什么？ 回溯。T也就是说，回到之前，改变上一个摆放点的位置。并试着继续。如果依然不行，则继续 回溯。<br>
方法： 回溯(DFS)<br>
这是一个回溯函数backtrack(prev_pos = -1, dots = 3) 的算法，该函数使用上一个放置的点 prev_pos<br>
和待放置点的数量 dots 两个参数 :<br>
遍历三个有效位置curr_pos 以放置点。<br>
 检查从上一个点到现在点中间的部分是否有效 :<br>
  是 :<br>
   放置该点。<br>
   检查全部 3个点是否放好:<br>
    是 :<br>
     将结果添加到输出列表中。<br>
    否 :<br>
     继续放下一个点 backtrack(curr_pos, dots - 1)。<br>
   回溯，移除最后一个点。</p>
</blockquote>
<pre><code>class Solution {
  int n;
  String s;
  LinkedList&lt;String&gt; segments = new LinkedList&lt;String&gt;();
  ArrayList&lt;String&gt; output = new ArrayList&lt;String&gt;();

  public boolean valid(String segment) {
    /*
    Check if the current segment is valid :
    1. less or equal to 255      
    2. the first character could be '0' 
    only if the segment is equal to '0'
    */
    int m = segment.length();
    if (m &gt; 3)
      return false;
    return (segment.charAt(0) != '0') ? (Integer.valueOf(segment) &lt;= 255) : (m == 1);
  }

  public void update_output(int curr_pos) {
    /*
    Append the current list of segments 
    to the list of solutions
    */
    String segment = s.substring(curr_pos + 1, n);
    if (valid(segment)) {
      segments.add(segment);
      output.add(String.join(&quot;.&quot;, segments));
      segments.removeLast();
    }
  }

  public void backtrack(int prev_pos, int dots) {
    /*
    prev_pos : the position of the previously placed dot
    dots : number of dots to place
    */
    // The current dot curr_pos could be placed 
    // in a range from prev_pos + 1 to prev_pos + 4.
    // The dot couldn't be placed 
    // after the last character in the string.
    int max_pos = Math.min(n - 1, prev_pos + 4);
    for (int curr_pos = prev_pos + 1; curr_pos &lt; max_pos; curr_pos++) {
      String segment = s.substring(prev_pos + 1, curr_pos + 1);
      if (valid(segment)) {
        segments.add(segment);  // place dot
        if (dots - 1 == 0)      // if all 3 dots are placed
          update_output(curr_pos);  // add the solution to output
        else
          backtrack(curr_pos, dots - 1);  // continue to place dots
        segments.removeLast();  // remove the last placed dot 
      }
    }
  }

  public List&lt;String&gt; restoreIpAddresses(String s) {
    n = s.length();
    this.s = s;
    backtrack(-1, 3);
    return output;
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 : 如上文所述，需要检查的组合不多于27个。<br>
空间复杂度 : 常数空间存储解，不多于19 个有效IP地址。</p>
</blockquote>
<p>hhh这个时间复杂度和空间复杂度非常有趣</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 567. 字符串的排列[中等]]]></title>
        <id>https://lixin-scut.github.io//post/zi-fu-chuan-567-zi-fu-chuan-de-pai-lie-zhong-deng</id>
        <link href="https://lixin-scut.github.io//post/zi-fu-chuan-567-zi-fu-chuan-de-pai-lie-zhong-deng">
        </link>
        <updated>2020-04-28T01:18:40.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。<br>
换句话说，第一个字符串的排列之一是第二个字符串的子串。<br>
示例1:<br>
输入: s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;<br>
输出: True<br>
解释: s2 包含 s1 的排列之一 (&quot;ba&quot;).<br>
 示例2:<br>
输入: s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;<br>
输出: False<br>
 注意：<br>
输入的字符串只包含小写字母<br>
两个字符串的长度都在 [1, 10,000] 之间<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/permutation-in-string<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>第一想法的话是保存s1的字符数量，然后在s2中探测是否有符合数量的字符串,但是发现行不通，错误例子&quot;adc&quot;-&quot;dcda&quot;<br>
然后想到滑动窗口+固定数组，亦即使用26个元素的数组，然后模仿滑动窗口，在递增某个字符的同时递减某个字符，然后比较两个数组是否相等。</p>
<p>最后官方题解的优化很值得学习，记录match的数量，当match的数量达到26的时候就说明匹配成功了</p>
<pre><code>class Solution {
public:
    bool checkInclusion(string s1, string s2) {    
        if(s2.size() &lt; s1.size())
        {   return false; }
        
        vector&lt;int&gt; letters(26, 0);
        
        for(char c : s1)
        {
            ++letters[c - 'a'];
        }
        
        vector&lt;int&gt; letters_temp(26, 0);
        for(int i = 0; i &lt; s2.size(); ++i)
        {
            if(i &lt; s1.size())
            {
                ++letters_temp[s2[i] - 'a'];
            }
            else
            {
                --letters_temp[s2[i-s1.size()] - 'a'];
                ++letters_temp[s2[i] - 'a'];
            }
            if(i &gt;= s1.size() - 1)
            {
                if(letters_temp == letters)
                {   
                    return true;
                }
            }
        }
        return false;
    }
};
</code></pre>
<blockquote>
<p>方法一 暴力 [超过时间限制]<br>
算法<br>
最简单的方法是生成短字符串的所有排列，并检查生成的排列是否是较长字符串的子字符串。<br>
为了生成所有可能的配对，我们使用函数permute（string_1，string_2，current_index）。此函数创建短字符串 s1 的所有可能排列。<br>
为此，permute将当前元素 currentindex 的索引作为参数之一。然后，它将当前元素与数组中的每个其他元素交换，向右移动，以便生成数组元素的新排序。完成交换后，它会再次调用置换，但这次使用数组中下一个元素的索引。返回时，我们反转当前函数调用中的交换。<br>
因此，当我们到达数组的末尾时，会生成数组元素的新排序。以下动画描述了生成排列的过程。</p>
</blockquote>
<pre><code>public class Solution {
    boolean flag = false;
    public boolean checkInclusion(String s1, String s2) {
        permute(s1, s2, 0);
        return flag;
    }
    public String swap(String s, int i0, int i1) {
        if (i0 == i1)
            return s;
        String s1 = s.substring(0, i0);
        String s2 = s.substring(i0 + 1, i1);
        String s3 = s.substring(i1 + 1);
        return s1 + s.charAt(i1) + s2 + s.charAt(i0) + s3;
    }
    void permute(String s1, String s2, int l) {
        if (l == s1.length()) {
            if (s2.indexOf(s1) &gt;= 0)
                flag = true;
        } else {
            for (int i = l; i &lt; s1.length(); i++) {
                s1 = swap(s1, l, i);
                permute(s1, s2, l + 1);
                s1 = swap(s1, l, i);
            }
        }
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n!)。我们将 s1 的短字符串 s1 的所有排列与 s2 匹配。这里，n 指的是 s1 的长度。<br>
空间复杂度：O(n^2)。递归树的深度是 n（n 是指短字符串 s1 的长度）。递归树的每个节点都包含一个 max 的字符串。长度 n。</p>
</blockquote>
<blockquote>
<p>方法二 排序 [超过时间限制]:<br>
算法<br>
这种方法背后的想法是，只有当两个字符串包含相同次数的相同字符时，一个字符串才是另一个字符串的排列。只有sorted(x)=sorted(y)时，一个字符串x才是其他字符串 y 的排列。<br>
为了检查这一点，我们可以对两个字符串进行排序并进行比较。我们对短字符串 s1 和 s2 的所有子字符串进行排序，对它们进行排序并将它们与排序的 s1 字符串进行比较。如果两者完全匹配，s1 的排列是 s2 的子字符串，否则不是。</p>
</blockquote>
<pre><code>public class Solution {

    public boolean checkInclusion(String s1, String s2) {
        s1 = sort(s1);
        for (int i = 0; i &lt;= s2.length() - s1.length(); i++) {
            if (s1.equals(sort(s2.substring(i, i + s1.length()))))
                return true;
        }
        return false;
    }
    public String sort(String s) {
        char[] t = s.toCharArray();
        Arrays.sort(t);
        return new String(t);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(l1log(l1)+(l2−l1)l1log(l1))。其中 l1是字符串 l1 的长度，l2是字符串 l2的长度。<br>
空间复杂度：O(l1)。使用了 t 数组。</p>
</blockquote>
<blockquote>
<p>方法三 使用哈希表 [超过时间限制]<br>
算法<br>
如上所述，只有当两个字符串包含具有相同频率的相同字符时，一个字符串才是另一个字符串的排列。我们可以考虑与 s1 长度相同的长字符串 s2 中的每个可能的子字符串，并检查出现在两者中的字符出现的频率。如果每个字母的频率完全匹配，则只有 s1 的排列可以是 s2 的子字符串。<br>
为了实现这种方法，我们不使用排序然后比较元素的相等性，而是使用一个哈希表 s1map来存储短字符串 s1 中所有字符的出现频率。我们考虑 s2 的每个可能的子串，其长度与 s1 的长度相同，也可以找到相应的哈希表，即 s2map。因此，所考虑的子字符串可以被视为一个长度窗口，如 s1 迭代超过 s2。如果获得的两个哈希表对于任何这样的窗口是相同的，我们可以得出结论 s1 的排列是 s2 的子字符串，否则不是。<br>
复杂度分析<br>
时间复杂度：O(l+26∗l1∗(l2−l1))。这个哈希表包含最多26个键。其中l1是字符串 l1的长度，l2是字符串 l2的长度。<br>
空间复杂度：O(1)。表包含最多 26 个键值对。</p>
</blockquote>
<blockquote>
<p>方法四 使用数组 [通过]<br>
算法<br>
我们可以使用更简单的数组数据结构来存储频率，而不是仅使用特殊的哈希表数据结构来存储字符出现的频率。给定字符串仅包含小写字母（'a'到'z'）。因此我们需要采用大小为 26 的数组。其余过程与最后一种方法保持一致。</p>
</blockquote>
<pre><code>public class Solution {
    public boolean checkInclusion(String s1, String s2) {
        if (s1.length() &gt; s2.length())
            return false;
        int[] s1map = new int[26];
        for (int i = 0; i &lt; s1.length(); i++)
            s1map[s1.charAt(i) - 'a']++;
        for (int i = 0; i &lt;= s2.length() - s1.length(); i++) {
            int[] s2map = new int[26];
            for (int j = 0; j &lt; s1.length(); j++) {
                s2map[s2.charAt(i + j) - 'a']++;
            }
            if (matches(s1map, s2map))
                return true;
        }
        return false;
    }
    public boolean matches(int[] s1map, int[] s2map) {
        for (int i = 0; i &lt; 26; i++) {
            if (s1map[i] != s2map[i])
                return false;
        }
        return true;
    }
}
</code></pre>
<blockquote>
<p>时间复杂度：O(l+26∗l1∗(l2−l1))。这个哈希表包含最多26个键。其中l1是字符串 l1的长度，l2是字符串 l2的长度。<br>
空间复杂度：O(1)。使用 s1map 和 s2map，大小为 26。</p>
</blockquote>
<blockquote>
<p>方法五 滑动窗口 [通过]:<br>
算法<br>
我们可以为 s2 中的第一个窗口创建一次哈希表，而不是为 s2 中考虑的每个窗口重新生成哈希表。然后，稍后当我们滑动窗口时，我们知道我们添加了一个前面的字符并将新的后续字符添加到所考虑的新窗口中。因此，我们可以通过仅更新与这两个字符相关联的索引来更新哈希表。同样，对于每个更新的哈希表，我们将哈希表的所有元素进行比较以获得所需的结果。</p>
</blockquote>
<pre><code>public class Solution {
    public boolean checkInclusion(String s1, String s2) {
        if (s1.length() &gt; s2.length())
            return false;
        int[] s1map = new int[26];
        int[] s2map = new int[26];
        for (int i = 0; i &lt; s1.length(); i++) {
            s1map[s1.charAt(i) - 'a']++;
            s2map[s2.charAt(i) - 'a']++;
        }
        for (int i = 0; i &lt; s2.length() - s1.length(); i++) {
            if (matches(s1map, s2map))
                return true;
            s2map[s2.charAt(i + s1.length()) - 'a']++;
            s2map[s2.charAt(i) - 'a']--;
        }
        return matches(s1map, s2map);
    }
    public boolean matches(int[] s1map, int[] s2map) {
        for (int i = 0; i &lt; 26; i++) {
            if (s1map[i] != s2map[i])
                return false;
        }
        return true;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(l+26∗l1∗(l2−l1))。这个哈希表包含最多26个键。其中l1是字符串 l1的长度，l2是字符串 l2的长度。<br>
空间复杂度：O(1)</p>
</blockquote>
<blockquote>
<p>方法六 优化的滑动窗口 [通过]:<br>
算法<br>
上一种方法可以优化，如果不是比较每个更新的 s2map 的哈希表的所有元素，而是对应于 s2 考虑的每个窗口，我们会跟踪先前哈希表中已经匹配的元素数量当我们向右移动窗口时，只更新匹配元素的数量。<br>
为此，我们维护一个 count 变量，该变量存储字符数（26个字母表中的数字），这些字符在 s1 中具有相同的出现频率，当前窗口在 s2 中。当我们滑动窗口时，如果扣除最后一个元素并添加新元素导致任何字符的新频率匹配，我们将 count 递增1.如果不是，我们保持 count 完整。但是，如果添加频率相同的字符（添加和删除之前）相同的字符，现在会导致频率不匹配，这会通过递减相同的 count 变量来考虑。如果在移动窗口后，count 的计算结果为26，则表示所有字符的频率完全匹配。所以，我们立即返回一个True。</p>
</blockquote>
<pre><code>public class Solution {
    public boolean checkInclusion(String s1, String s2) {
        if (s1.length() &gt; s2.length())
            return false;
        int[] s1map = new int[26];
        int[] s2map = new int[26];
        for (int i = 0; i &lt; s1.length(); i++) {
            s1map[s1.charAt(i) - 'a']++;
            s2map[s2.charAt(i) - 'a']++;
        }
        int count = 0;
        for (int i = 0; i &lt; 26; i++)
            if (s1map[i] == s2map[i])
                count++;
        for (int i = 0; i &lt; s2.length() - s1.length(); i++) {
            int r = s2.charAt(i + s1.length()) - 'a', l = s2.charAt(i) - 'a';
            if (count == 26)
                return true;
            s2map[r]++;
            if (s2map[r] == s1map[r])
                count++;
            else if (s2map[r] == s1map[r] + 1)
                count--;
            s2map[l]--;
            if (s2map[l] == s1map[l])
                count++;
            else if (s2map[l] == s1map[l] - 1)
                count--;
        }
        return count == 26;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(l1+(l2−l1))O(l1 +(l2−l1))。其中 l1是字符串 l1的长度，l2是字符串 l2 的长度。<br>
空间复杂度：O(1)。常数级的空间。</p>
</blockquote>
]]></content>
    </entry>
</feed>