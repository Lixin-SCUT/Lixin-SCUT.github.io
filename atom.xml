<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-09-08T23:36:03.589Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[数组 41. 缺失的第一个正数[困难]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-41-que-shi-de-di-yi-ge-zheng-shu-kun-nan</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-41-que-shi-de-di-yi-ge-zheng-shu-kun-nan">
        </link>
        <updated>2019-09-08T13:24:52.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个未排序的整数数组，找出其中没有出现的最小的正整数。<br>
示例 1:<br>
输入: [1,2,0]<br>
输出: 3<br>
示例 2:<br>
输入: [3,4,-1,1]<br>
输出: 2<br>
示例 3:<br>
输入: [7,8,9,11,12]<br>
输出: 1<br>
说明:<br>
你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/first-missing-positive<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>第一次做困难的题，还是比较紧张的<br>
下意识想到的办法是建立另外一个数组，利用这个数组的下标来存储已经有的数值（此时其实已经犯了一个错误，常数级别的空间就意味着必须原地操作）<br>
然后考虑需要处理的情况有<br>
1.把负值全部变为0；<br>
2.取最大值作为另外一个数组的大小值；<br>
因为昨天回家了，所以是在平板上做题的，没有保存好代码，只保存了最后的代码</p>
<pre><code>public:
    int firstMissingPositive(vector&lt;int&gt;&amp; nums) {
        if(nums.size()==0)
            return 1;
        for (int i=0;i&lt;nums.size();++i)
            if(nums[i]&gt;nums.size())
                nums[i] = 0; 
        vector&lt;int&gt; norm(nums.size(),0);
        for(auto i : nums)
            if(i&gt;0){
                norm[i-1]=1;
            }
        for(int i = 0;i&lt;nums.size();++i)
            if(norm[i]!=1)
                return i+1;
        return nums.size()+1;     
    }

</code></pre>
<p>最后提交还是毫无疑问地出错了。。。系统给我安排一个过亿的数值能不出错嘛。。。<br>
这个时候不小心瞄到一眼答案，发现必须把大于数组长度的值置为0，hhh修改后就通过啦！（当然此时已经不符合常数级别空间的要求）</p>
<p>官方题解如下（图比较多，比较麻烦）</p>
<blockquote>
<p>方法 1：索引作为哈希表。<br>
数据预处理</p>
<p>首先我们可以不考虑负数和零，因为不需要考虑。同样可以不考虑大于 n 的数字，<br>
因为首次缺失的正数一定小于或等于 n + 1 。<br>
缺失的正数为 n + 1 的情况会单独考虑。<br>
为了不考虑这些数，又要保证时间复杂度为O(N) ，因此<br>
不能将这些元素弹出。我们可以将这些数用 1 替换。<br>
为了确保缺失的第一个正数不是 1，先要在这步操作前确定 1 是否存在。</p>
<p>如何实现就地算法<br>
现在我们有一个只包含正数的数组，范围为 1 到 n，<br>
现在的问题是在 \mathcal{O}(N)O(N) 的时间和常数空间内找出首次缺失的正数。<br>
如果可以使用哈希表，且哈希表的映射是 正数 -&gt; 是否存在 的话，这其实很简单。<br>
&quot;脏工作环境&quot; 的解决方法是将一个字符串 hash_str 分配 n 个 0，并且用类似于哈希表的方法，如果在数组中出现数字 i 则将字符串中 hash_str[i] 修改为 1 。</p>
<p>我们不使用这种方法，但是借鉴这种 使用索引作为哈希键值 的想法。<br>
最终的想法是 使用索引作为哈希键 以及 元素的符号作为哈希值 来实现是否存在的检测。<br>
例如，nums[2] 元素的负号意味着数字 2 出现在 nums 中。nums[3]元素的正号表示 3 没有出现在 nums 中。<br>
为了完成此操作，我们遍历一遍数组（该操作在数据预处理使得数组中只有正数的操作后），检查每个元素值 elem 以及将nums[elem] 元素的符号变为符号来表示数字 elem 出现在 nums 中。注意，当数字出现多次时需要保证符号只会变化 1 次。<br>
算法</p>
<p>现在可以开始写算法了。</p>
<p>检查 1 是否存在于数组中。如果没有，则已经完成，1 即为答案。<br>
如果 nums = [1]，答案即为 2 。<br>
将负数，零，和大于 n 的数替换为 1 。<br>
遍历数组。当读到数字 a 时，替换第 a 个元素的符号。<br>
注意重复元素：只能改变一次符号。由于没有下标 n ，使用下标 0 的元素保存是否存在数字 n。<br>
再次遍历数组。返回第一个正数元素的下标。<br>
如果 nums[0] &gt; 0，则返回 n 。<br>
如果之前的步骤中没有发现 nums 中有正数元素，则返回n + 1。<br>
代码</p>
<p>JavaPython<br>
class Solution {<br>
public int firstMissingPositive(int[] nums) {<br>
int n = nums.length;</p>
<pre><code>// 基本情况
int contains = 0;
for (int i = 0; i &lt; n; i++)
  if (nums[i] == 1) {
    contains++;
    break;
  }

if (contains == 0)
  return 1;

// nums = [1]
if (n == 1)
  return 2;

// 用 1 替换负数，0，
// 和大于 n 的数
// 在转换以后，nums 只会包含
// 正数
for (int i = 0; i &lt; n; i++)
  if ((nums[i] &lt;= 0) || (nums[i] &gt; n))
    nums[i] = 1;

// 使用索引和数字符号作为检查器
// 例如，如果 nums[1] 是负数表示在数组中出现了数字 `1`
// 如果 nums[2] 是正数 表示数字 2 没有出现
for (int i = 0; i &lt; n; i++) {
  int a = Math.abs(nums[i]);
  // 如果发现了一个数字 a - 改变第 a 个元素的符号
  // 注意重复元素只需操作一次
  if (a == n)
    nums[0] = - Math.abs(nums[0]);
  else
    nums[a] = - Math.abs(nums[a]);
}

// 现在第一个正数的下标
// 就是第一个缺失的数
for (int i = 1; i &lt; n; i++) {
  if (nums[i] &gt; 0)
    return i;
}

if (nums[0] &gt; 0)
  return n;

return n + 1;
</code></pre>
<p>}<br>
}<br>
复杂性分析<br>
时间复杂度： O(N) 由于所有的操作一共只会遍历长度为 N 的数组 4 次。<br>
空间复杂度： O(1) 由于只使用了常数的空间。</p>
</blockquote>
<p>最后还是很精妙的，当然前期处理非常重要，然后还有一点很重要，只有当当前下标的值处理好后，才会进行下标递增！（可以参考题解中的桶排序，其中精妙的思想还有如下：</p>
<blockquote>
<p>补充内容：<br>
交换两个整数，有两种比较 tricky 的做法。下面给出结论。<br>
“基于异或运算”是因为利用了“异或运算”是不进位的二进制加法。它有如下性质：<br>
如果 a ^ b = c ，那么 a ^ c = b 与 b ^ c = a 同时成立，利用这一条，可以用于交换两个变量的值。<br>
于是，交换两个变量的值，例如 a 和 b，不使用第三个变量，有两种不同的方法：<br>
基于异或运算	<br>
a = a ^ b<br>
b = a ^ b<br>
a = a ^ b<br>
基于加减法<br>
a = a + b<br>
b = a - b<br>
a = a - b<br>
我理解的方式就是自己在纸上写几个例子，并且记住这个结论。个人觉得“基于异或运算”交换两个变量的值好记一些，因为右边都一样，左边依次是 a、b、a。</p>
<p>在这里特别感谢用户 @davidlaid 给出的意见：<br>
对于异或运算实现的交换方法，如果调用 swap(nums, i, i)，那么最终的结果会变为 0。<br>
对于加减法实现的交换方法，有可能发生溢出。<br>
调用 swap(nums, i, i)，那么最终的结果会变为 0 这是因为，如果是在数组中，自己和自己交换，只有 1 个空间，这个数会在异或运算的过程中变为 0，因此单独判断一下就好了。我个人还是比价少用这个技巧的，如果题目中限制了不能使用额外的存储空间，才用“基于异或运算实现的交换方法”。</p>
<p>参考代码 2：基于异或运算交换两个变量的值。<br>
PythonPythonJava<br>
from typing import List<br>
class Solution:<br>
def firstMissingPositive(self, nums: List[int]) -&gt; int:<br>
size = len(nums)<br>
for i in range(size):<br>
while 1 &lt;= nums[i] &lt;= size and nums[i] != nums[nums[i] - 1]:<br>
self.__swap(nums, i, nums[i] - 1)<br>
for i in range(size):<br>
if i + 1 != nums[i]:<br>
return i + 1<br>
return size + 1</p>
<pre><code>def __swap(self, nums, index1, index2):
    if index1 == index2:
        return
    nums[index1] = nums[index1] ^ nums[index2]
    nums[index2] = nums[index1] ^ nums[index2]
    nums[index1] = nums[index1] ^ nums[index2]
</code></pre>
<p>作者：liweiwei1419<br>
链接：https://leetcode-cn.com/problems/first-missing-positive/solution/tong-pai-xu-python-dai-ma-by-liweiwei1419/<br>
来源：力扣（LeetCode）<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<p>异或互换和加法互换都很神奇，实现了两个对象之间的互换而不需要额外的参数！所以从别人身上学到了很多有趣的东西啊，也同时验证了我之前的随心感想，在leetcode还是可以学到很多知识的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 189.旋转数组]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-189xuan-zhuan-shu-zu</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-189xuan-zhuan-shu-zu">
        </link>
        <updated>2019-09-06T13:27:51.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p>
<p>示例 1:</p>
<p>输入: [1,2,3,4,5,6,7] 和 k = 3<br>
输出: [5,6,7,1,2,3,4]<br>
解释:<br>
向右旋转 1 步: [7,1,2,3,4,5,6]<br>
向右旋转 2 步: [6,7,1,2,3,4,5]<br>
向右旋转 3 步: [5,6,7,1,2,3,4]</p>
<p>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。<br>
要求使用空间复杂度为 O(1) 的 原地 算法。</p>
</blockquote>
<blockquote>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/rotate-array<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>按照昨天学习到的思想，对题目进行分解：<br>
首先是特殊情况：k == 0 || nums.size() == 0 || nums.size() == 1 || nums.size() == k，直接白给return<br>
然后是两种情况<br>
第一种 k大于size 第二种k小于size<br>
其实第一种可以通过k%size转化为第二种（发现自己居然忘了c++的取余数为%）<br>
但是最后被旋转原地移动难住了，最后只能暴力出奇迹，一位一位地移动了：</p>
<pre><code>class Solution {
	public:
		void rotate(vector&lt;int&gt;&amp; nums, int k) {
			if (k == 0 || nums.size() == 0 || nums.size() == 1 || nums.size() == k)
				return;
			else if (nums.size()&lt;k)
				k = k%nums.size();
			while (k&gt;0) {
				int temp = nums[nums.size() - 1];
				for (int j = nums.size() - 1; j&gt;0; --j)
					nums[j] = nums[j - 1];
				nums[0] = temp;
				--k;
			}
			return;
		}
	};
</code></pre>
<p>最后提交居然超过了时间限制？<br>
一看题解，what？第一个就是暴力解啊？？？我的还是做了情况优化的，把Java代码转化为C++，还是白给了。。。C++无人权啊！！！<br>
题解明天再看吧，剩下的时间处理一下c++，星期一还得报告呢<br>
今天很无语，遇到很奇葩的事情了，详情看随心感想吧，<br>
第一次无法按时完成任务...好无力啊</p>
<p>9.8补充：<br>
官方题解<br>
第一个就是暴力题解了，只是c++铁定会超时，就算进行情况优化和把官方java题解照搬过来也是全部木大，后来才发现leetcode会对c++严格很多</p>
<blockquote>
<p>题解二：<br>
方法 2：使用额外的数组<br>
算法<br>
我们可以用一个额外的数组来将每个元素放到正确的位置上，也就是原本数组里下标为 ii 的我们把它放到 (i+k)%数组长度(i+k)%数组长度 的位置。然后把新的数组拷贝到原数组中。<br>
Java<br>
public class Solution {<br>
public void rotate(int[] nums, int k) {<br>
int[] a = new int[nums.length];<br>
for (int i = 0; i &lt; nums.length; i++) {<br>
a[(i + k) % nums.length] = nums[i];<br>
}<br>
for (int i = 0; i &lt; nums.length; i++) {<br>
nums[i] = a[i];<br>
}<br>
}<br>
}<br>
复杂度分析<br>
时间复杂度： O(n) 。将数字放到新的数组中需要一遍遍历，另一边来把新数组的元素拷贝回原数组。<br>
空间复杂度： O(n)。另一个数组需要原数组长度的空间。</p>
</blockquote>
<p>题解二比较简单，但是空间复杂度比较高，在常数空间复杂度的情况下并不适用</p>
<blockquote>
<p>题解三：<br>
方法 3：使用环状替换<br>
算法<br>
如果我们直接把每一个数字放到它最后的位置，但这样的后果是遗失原来的元素。因此，我们需要把被替换的数字保存在变量 temp 里面。然后，我们将被替换数字（temp）放到它正确的位置，并继续这个过程 n 次， n 是数组的长度。这是因为我们需要将数组里所有的元素都移动。但是，这种方法可能会有个问题，如果 n%k==0，其中 k=k%n （因为如果 k 大于 n ，移动 k 次实际上相当于移动 k%n 次）。这种情况下，我们会发现在没有遍历所有数字的情况下回到出发数字。此时，我们应该从下一个数字开始再重复相同的过程。</p>
<p>现在，我们看看上面方法的证明。假设，数组里我们有 n 个元素并且 k 是要求移动的次数。更进一步，假设 n%k=0 。第一轮中，所有移动数字的下标 i满足 i%k<mark>0。这是因为我们每跳 k 步，我们只会到达相距为 k 个位置下标的数。每一轮，我们都会移动n/k个元素。下一轮中，我们会移动满足 i%k</mark>1的位置的数。这样的轮次会一直持续到我们再次遇到i%k==0 的地方为止，此时 i=k 。此时在正确位置上的数字共有k*n/k 	 =n 个。因此所有数字都在正确位置上。<br>
让我们看一下接下来的例子，以更好地说明这个过程：<br>
nums: [1, 2, 3, 4, 5, 6]<br>
k: 2<br>
Java<br>
public class Solution {<br>
public void rotate(int[] nums, int k) {<br>
k = k % nums.length;<br>
int count = 0;<br>
for (int start = 0; count &lt; nums.length; start++) {<br>
int current = start;<br>
int prev = nums[start];<br>
do {<br>
int next = (current + k) % nums.length;<br>
int temp = nums[next];<br>
nums[next] = prev;<br>
prev = temp;<br>
current = next;<br>
count++;<br>
} while (start != current);<br>
}<br>
}<br>
}<br>
复杂度分析</p>
<p>时间复杂度：O(n) 。只遍历了每个元素一次。<br>
空间复杂度：O(1) 。使用了常数个额外空间。</p>
</blockquote>
<p>第三个就是我一开始想到的操作了，但是还是算是比较复杂，我更喜欢第四个：</p>
<blockquote>
<p>方法 4：使用反转<br>
算法<br>
这个方法基于这个事实：当我们旋转数组 k 次， k%n 个尾部元素会被移动到头部，剩下的元素会被向后移动。<br>
在这个方法中，我们首先将所有元素反转。然后反转前 k 个元素，再反转后面 n-k 个元素，就能得到想要的结果。<br>
假设 n=7 且k=3 。</p>
<p>原始数组                  : 1 2 3 4 5 6 7<br>
反转所有数字后             : 7 6 5 4 3 2 1<br>
反转前 k 个数字后          : 5 6 7 4 3 2 1<br>
反转后 n-k 个数字后        : 5 6 7 1 2 3 4 --&gt; 结果<br>
Java<br>
public class Solution {<br>
public void rotate(int[] nums, int k) {<br>
k %= nums.length;<br>
reverse(nums, 0, nums.length - 1);<br>
reverse(nums, 0, k - 1);<br>
reverse(nums, k, nums.length - 1);<br>
}<br>
public void reverse(int[] nums, int start, int end) {<br>
while (start &lt; end) {<br>
int temp = nums[start];<br>
nums[start] = nums[end];<br>
nums[end] = temp;<br>
start++;<br>
end--;<br>
}<br>
}<br>
}<br>
复杂度分析</p>
<p>时间复杂度：O(n)。 nn 个元素被反转了总共 3 次。<br>
空间复杂度：O(1) 。 没有使用额外的空间。</p>
</blockquote>
<p>哈哈哈可以说是非常优雅了，一开始我也想到翻转，但是却没想到可以翻转两次！666！<br>
后面是我的代码：</p>
<pre><code>class Solution {
public:
    void rotate(vector&lt;int&gt;&amp; nums, int k) {
        if (k == 0 || nums.size() == 0 || nums.size() == 1 || nums.size() == k)
			return;
		else if (nums.size()&lt;k)
			k = k%nums.size();
        swap_num(nums,0,nums.size()-1);
        swap_num(nums,0,k-1);
        swap_num(nums,k,nums.size()-1);
        
    }
    void swap_num(vector&lt;int&gt;&amp; nums,int first,int last){
        while(first&lt;last){
            int temp = nums[first];
            nums[first] = nums[last];
            nums[last] = temp;
            ++first;--last;
        }
    }
};
</code></pre>
<p>总体来说这一次还是有不小的进步的，开始学会思考情况了，但是解决问题的能力还是有待提高啊！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第三章 笔记+习题 3.5-3.6]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-san-zhang-bi-ji-xi-ti-35-36</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-san-zhang-bi-ji-xi-ti-35-36">
        </link>
        <updated>2019-09-06T07:17:15.000Z</updated>
        <content type="html"><![CDATA[<p>3.5<br>
数组大小固定 如果元素个数不确定，就是用vector<br>
数组声明 a[d] 其中d必须是一个常量字面值或者是一个<strong>常量表达式</strong><br>
非内置的数据类型默认初始化为空<br>
函数内部定义的数组 默认初始化会含有未定义的值<br>
数组定义时必须指定数组的类型，<strong>不允许用auto关键字</strong><br>
引用无法组成数组<br>
<strong>列表初始化可以缺省数组的维度</strong><br>
使用字符串字面值初始化字符数组时，需要保留空间给结尾的<strong>空字符‘\0’</strong><br>
数组<strong>不允许拷贝初始化和赋值</strong> 但vector可以进行拷贝<br>
数组声明阅读由内向外<br>
指向数组的指针 int (*Parray)[10] = &amp;arr;  数组的应用 int (&amp;Rarra)[10] = arr; 注意不能漏掉括号 去掉括号就成了 指针数组和非法定义<br>
int *(&amp;Rarra) [10] = arr; 一个含有10个int指针的数组的引用<br>
<strong>int *ptrs[10];//指针的数组  int (*ptrs)[10];//数组的指针</strong></p>
<p>习题3.27<br>
a c 非法 不是一个常量值啊 d 非法 还有结尾空字符放不进去<br>
习题3.28<br>
string[] 为空 外部int[]为0 内部int[]为空未定值<br>
知识点：不同作用域的定义的默认值<br>
习题3.29<br>
缺点：固定大小，初始化的方式不同</p>
<p>3.5.2<br>
数组下标类型为 size_t<br>
数组元素可以通过范围for语句以及下标运算符访问<br>
注意数组可以使用范围for语句，但是！调用的形式是：<br>
int a[10]; for(auto i : <strong>a</strong> ) i++;</p>
<p>习题3.30<br>
ix最后会等于size，ia[10]是不存在的，强行调用会导致内存出错<br>
习题3.31</p>
<pre><code>int main() {
	int a[10];
	for (int i = 0; i &lt; 10; ++i) {
		a[i] = i;
		cout &lt;&lt; a[i] &lt;&lt; ' ';
	}
};
</code></pre>
<p>知识点：数组的初始化<br>
习题3.31</p>
<pre><code>int main() {
	int a[10];
	for (int i = 0; i &lt; 10; ++i) {
		a[i] = i;
		cout &lt;&lt; a[i] &lt;&lt; ' ';
	}
	int b[10] ;
	for (int i = 0; i &lt; 10; ++i) 
		b[i] = a[i];	
	vector&lt;int&gt; v1(10, 10);
	vector&lt;int&gt; v2 = v1;
	for (auto i : v2)
		cout &lt;&lt; i &lt;&lt; ' ';
}
</code></pre>
<p>知识点：数组和vector的差异，初始化、拷贝等<br>
习题3.33<br>
将会强行调用未定义的值，出现难以预料的结果。<br>
知识点：数组默认初始化</p>
<p>3.5.3<br>
数组的每个元素都有地址，可以对特定元素使用取地址符<br>
<strong>数组名字本身就是一个指向数组首元素的指针</strong> int *b = arr;<br>
使用数组的时候实质上真正使用的是指向数组某元素的指针<br>
所以涉及数组<strong>的auto会定义为指针 而非数组  但decltype 返回的类型是同等维度的数组</strong><br>
<strong>指向数组的指针就等于一个迭代器</strong> 支持++等运算符<br>
标准库函数begin和end 将数组作为参数 int *beg = begin(ia); int *last = end(ia); 定义在iterator头文件内<br>
<strong>指针支持所有迭代器运算</strong><br>
两个指针相减得到的值类型为ptrdiff_t 带符号类型 定义在cstddef头文件中<br>
如果含有点运算符和解引用符 最好在必要的地方加上括号<br>
<strong>指针也可以进行下标运算</strong><br>
对数组执行下标运算其实就是对指向数组元素的指针执行下标运算<br>
int *p = &amp;ia[2]; int j =p[1]; //等价于*p(1)<br>
标准库类型的下标必须是无符号类型 例如string和vector  内置的下标无此要求 比如指针和数组<br>
<strong>下标[-1]就是指最后一个值</strong></p>
<p>习题3.34<br>
将p1指针移动到p2<br>
习题3.35</p>
<pre><code>int main() {
	int a[10];
	for (int i = 0; i &lt; 10; ++i) {
		a[i] = i;
		cout &lt;&lt; a[i] &lt;&lt; ' ';
	}
	for (int *i = begin(a); i != end(a); ++i) {
		*i = 0;
		cout &lt;&lt; *i &lt;&lt; ' ';
	}
};
</code></pre>
<p>知识点：数组指针的定义与调用<br>
习题3.36</p>
<pre><code>int main() {
	int a[3] = {1,2,3};
	int b[3] = {1,2,3};
	if (sizeof(a) == sizeof(b)) {
		int i = 0;
		int length = sizeof(a) / sizeof(a[0]);
		while (i&lt;length&amp;&amp;a[i] == b[i])
			++i;
		if (i == length)
			cout &lt;&lt; &quot;they are equal!&quot; &lt;&lt; endl;
		else 
			cout &lt;&lt; &quot;they are difference!&quot; &lt;&lt; endl;
	}
	else
		cout &lt;&lt; &quot;they are difference!&quot; &lt;&lt; endl;
	vector&lt;int&gt; i = { 1,2,3 };
	vector&lt;int&gt; j = { 1,2,3 };
	if (i == j)
		cout &lt;&lt; &quot;they are equal!&quot; &lt;&lt; endl;
	else
		cout &lt;&lt; &quot;they are difference!&quot; &lt;&lt; endl;
};
</code></pre>
<p>知识点：数组的比较、<strong>数组的长度</strong>，vector的比较</p>
<p>3.5.4<br>
c风格字符串必须以空字符结束 char ca[ ]<br>
上述函数皆以空字符为监测点<br>
c风格字符串实际上是一个数组直接 使用时等于使用指针<br>
c风格字符串函数使用时需要不断判断空间问题，所以string比其安全高效<br>
strcmp（参数1，参数2）比较参数1和参数（1、若参数1&gt;参数2，返回正数；2、若参数1&lt;参数2，返回负数；3、若参数1=参数2，返回0；）</p>
<p>习题3.37<br>
输出hello'\0'注意空字符<br>
习题3.38<br>
两个指针相加的值最后是未知的，使用一个未知地址值的指针是非常危险的事。<br>
习题3.39</p>
<pre><code>int main() {
	char a[6] = &quot;hallo&quot;;
	char b[6] = &quot;abcde&quot;;
	if (!strcmp(a,b))
		cout &lt;&lt; &quot;they are equal!&quot; &lt;&lt; endl;
	else
		cout &lt;&lt; &quot;they are difference!&quot; &lt;&lt; endl;

	string i = { &quot;hello&quot; };
	string j = { &quot;hallo&quot; };
	if (i == j)
		cout &lt;&lt; &quot;they are equal!&quot; &lt;&lt; endl;
	else
		cout &lt;&lt; &quot;they are difference!&quot; &lt;&lt; endl;
};
</code></pre>
<p>知识点：string比较、C风格字符串比较<br>
习题3.40</p>
<pre><code>int main() {
	char a[6] = &quot;hallo&quot;;
	char b[6] = &quot;abcde&quot;;
	char c[12];
	strcat(a, b);
	strcpy(c, a);
};
</code></pre>
<p>知识点：C风格字符串函数的运用</p>
<p>3.5.5<br>
为了兼容旧代码</p>
<ol>
<li>任何出现字符串字面值都可以用以空字符结束的字符数组来代替 比如用来初始化string对象</li>
<li>string中有c_str成员函数用于处理c风格字符串</li>
<li>可以用数组初始化vector对象<br>
习题3.41</li>
</ol>
<pre><code>int main() {
	int a[10] = { 1,2,3,4,5,6,7,8,9,10 };
	vector&lt;int&gt; i (begin(a),end(a));
	for (auto x : i)
		cout &lt;&lt; x &lt;&lt; ' ';
};
</code></pre>
<p>知识点：用整形数组初始化vector<br>
习题3.42</p>
<pre><code>int main() {
	int a[10] ;
	vector&lt;int&gt; i = { 1,2,3,4,5,6,7,8,9,10 };
	int e = 0;
	for (auto x : i)
		a[e++] = x;
	for (auto x : a)
		cout &lt;&lt; x &lt;&lt; ' ';
};
</code></pre>
<p>知识点：整型数组的循环与初始化</p>
<p>3.6<br>
严格来说c++并没有多维数组 而是<strong>数组的数组</strong> 所以<strong>对数组名是指针的指针</strong>，对数组名ia的<strong>第一次解引用*ia得到还是指针</strong>，第二次解引用**ia才获得数组第一个元素<br>
当表达式提供的下标运算符数量和数组维度相同时 访问的是特定元素。如果下标运算符数量比数组维度小，则结是给定索引处的一个内层数组<br>
用范围for语句处理多维数组，除了<strong>最内层的循环外，其他所有循环的控制变量都应该是引用类型</strong><br>
在声明指向数组的指针时必须要注意括号，建议使用auto 或者类型别名（using、typedef）<br>
（题目3.43）</p>
<p>习题3.43</p>
<pre><code>int main() {
	int ia[3][3] = { {1,2,3},{ 4,5,6 } ,{ 7,8,9 } };
	for (int (&amp;x)[3] : ia)
		for (int y : x)
			cout &lt;&lt; y &lt;&lt; ' ';
	for (int x = 0; x &lt; 3; ++x)
		for (int y = 0; y &lt; 3; ++y)
			cout &lt;&lt; ia[x][y] &lt;&lt; ' ';
	for (int (*x)[3] = begin(ia); x != end(ia); ++x)
		for (int * y = *x;y != *x+3; ++y)
			cout &lt;&lt; *y &lt;&lt; ' ';	
};
</code></pre>
<p>知识点：多维数组中范围for语句、指针和下标的运用<br>
习题3.44</p>
<pre><code>//typedef int a[3];
using a = int[3];
int main() {
	
	int ia[3][3] = { {1,2,3},{ 4,5,6 } ,{ 7,8,9 } };
	for (auto &amp;x : ia)
		for (auto y : x)
			cout &lt;&lt; y &lt;&lt; ' ';
	for (int x = 0; x &lt; 3; ++x)
		for (int y = 0; y &lt; 3; ++y)
			cout &lt;&lt; ia[x][y] &lt;&lt; ' ';
	for (a *x = begin(ia); x != end(ia); ++x)
		for (int*  y = *x;y != *x+3; ++y)
			cout &lt;&lt; *y &lt;&lt; ' ';	
};
</code></pre>
<p>知识点：typedef的运用<br>
习题3.55</p>
<pre><code>int main() {
	int ia[3][3] = { {1,2,3},{ 4,5,6 } ,{ 7,8,9 } };
	for (auto &amp;x : ia)
		for (auto y : x)
			cout &lt;&lt; y &lt;&lt; ' ';
	for (int x = 0; x &lt; 3; ++x)
		for (int y = 0; y &lt; 3; ++y)
			cout &lt;&lt; ia[x][y] &lt;&lt; ' ';
	for (auto x = begin(ia); x != end(ia); ++x)
		for (auto  y = *x;y != *x+3; ++y)
			cout &lt;&lt; *y &lt;&lt; ' ';	
};
</code></pre>
<p>知识点：auto的应用</p>
<p>习题感悟、<br>
数组在不同作用域的定义的默认值受类型影响<br>
数组指针可以使用begin（ia）和end（ia）<br>
数组的长度计算得用	int length = sizeof(a) / sizeof(a[0]);<br>
c风格字符数组有很多自定义函数<br>
可以用整形数组初始化vector<br>
注意！！！！！！<br>
typedef 定义数组是这样子的 typedef int a[4] 把a定义为int[4]的类型别名！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于leetcode的小感想]]></title>
        <id>https://lixin-ee.github.io//post/guan-yu-leetcode-de-xiao-gan-xiang</id>
        <link href="https://lixin-ee.github.io//post/guan-yu-leetcode-de-xiao-gan-xiang">
        </link>
        <updated>2019-09-05T12:25:03.000Z</updated>
        <content type="html"><![CDATA[<p>  昨天查询leetcode经验时，在知乎上看到一个高赞答案说leetcode是程序员的八股文，对此我是十分不赞成的。<br>
  倘若只是依靠死记硬背来应付面试，是十分可笑的，就好像华工的游泳考试，你依靠憋着一口气，或许可以应付50米，但绝不可能应付更长的距离。<br>
  回想起一直以来健身房的经历，我觉得leetcode是一个健身房，同时算法与数据结构是程序员强壮的肌肉，但凡有力量、有速度、有技巧的运动员，哪个是瘦骨嶙峋的？当然没有强壮的肌肉你仍可跑步、游泳、打球，毕竟再普通的程序员也知道能用乘法不用加法、能用指数不用乘法的道理吧，但是没有算法与数据结构这一强壮的肌肉，你便无法做出很多漂亮的动作（比如自重引体向上）和理想的成绩，leetcode无疑是现今最好的健身房，虽然有些困难的题目确实很困难，但是我们总不能一开始无法自重引体向上就对健身房避而远之吧？<br>
   就我自己而言，仅仅五天五道题，便觉得受益良多，仿佛在与一位大师交流。非常  庆幸我能早一点遇到leetcode，而不是等到明年三月份再临时抱佛脚便咒骂这是“八股文”。我想哪怕以后不从事算法相关的工作，我现在学到的东西所带来的对思维的影响，都会在以后带来无穷的益处。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 80. 删除排序数组中的重复项 II]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-80-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang-ii</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-80-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang-ii">
        </link>
        <updated>2019-09-05T11:42:44.000Z</updated>
        <content type="html"><![CDATA[<p>题目如下：</p>
<blockquote>
<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p>示例 1:</p>
<p>给定 nums = [1,1,1,2,2,3],</p>
<p>函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。</p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>老样子，还是想用快慢指针（知道迭代器本身其实就是个指针后，还是改名了。。。），但是这一次比较麻烦，需要对重复的次数进行计算，还好是有序数组，省去很多麻烦，但是码代码的过程可不轻松，还是对暂时量和快指针的变化掌握得很差，中途多次错误都是因为没有掌握好快指针的位置变化，但是可喜可贺的是，这一次专门针对特殊情况作了考虑（包括万恶的空数组！！！）所以第二次提交就通过了，但是执行用时不理想啊，用了28ms（不知道是不是leetcode的问题呢）<br>
我的代码如下：</p>
<pre><code>class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        int i = 0;
        if(nums.size()!=0)
         for(int j=0;j&lt;nums.size();){
            int temp = nums[j];
            nums[i++]=nums[j];
            int cal = 1;
            ++j;
            while(j&lt;nums.size()&amp;&amp;nums[j]==temp){
                ++cal;
                if (cal&lt;3)
                    nums[i++]=nums[j];
                    ++j;
            }
          }              
         else
          return i;
        return i;
    }
};
</code></pre>
<p>然后看一下官方题解：</p>
<p>你以为我要贴官方题解吗？其实没有哒！<br>
好吧这次quo实没有官方题解，只有网友讨论，不过幸运的是有个非常好的高赞题解：</p>
<blockquote>
<p>原地删除肯定是双指针，一个指向遍历的元素，一个指向可以写入的位置，后者的大小是小于等于前者的，关键在于题目条件的转化，如何实现限制最多两次的重复出现。<br>
我们先不考虑边界情况，只考虑中间的情况，假设当前遍历位置为i，写指针的可写入位置为current+1，对于i处的值，其写入的条件是重复小于等于2次，我们考虑已经写入的最后两位current和current-1，这两个位置的情况有两个，相等和不相等，首先考虑相等的情况，此时若i处的值和current-1或者说current处的值相同，那么，i处的值肯定不能加入；然后考虑不相等的情况，即current-1和current处值不相等，那么i处的值无论为什么，都满足题意的，即可以加入，综上所述，当i处的值与current-1处的值不相等时，i处的值可以加入，其他情况均不能加入。<br>
接着考虑边界情况，我们只需要考虑开始即可，开始时，前两个值无论等还是不等，都要原封不动的挪到新数组里，由于新数组就是在原数组上进行修改的，因此前两位直接不动即可，只需要修改遍历指针和写入指针就行。<br>
以上算法只需要进行一次遍历即可，时间复杂度O(n)，空间复杂度O(1)。</p>
</blockquote>
<pre><code>int removeDuplicates(vector&lt;int&gt;&amp; nums) 
{
	if (nums.size() &lt;= 1)
		return nums.size();
	int current = 1;           //新数组中有效位置的最后一位，新加入的数据应当写到current+1
	for (int i = 2; i &lt; nums.size();i++) //从第三位开始循环，前两位无论如何都是要加入新数组的
	{
		if (nums[i] != nums[current - 1])  //符合条件，加入新数组
		{
			current += 1;
			nums[current] = nums[i];
		}
	}
	return current+1;
}
</code></pre>
<blockquote>
<p>作者：luo-ben-zhu-xiao-man-tou<br>
链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/solution/zhi-jie-bian-li-yi-ci-ji-ke-by-luo-ben-zhu-xiao-ma/<br>
来源：力扣（LeetCode）<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<p>好强哒！！！最让我佩服的不是代码，而是这清晰的思路，我就是缺乏这种对全局的考虑，老是想到哪写到哪，总是觉得写算法是冒出一个问题处理一个，其实正应该像他这样，把问题细化为大分类，再把特殊的情况慢慢细化为小分类，这样才能概括到尽可能多（甚至是全部）的答案啊！<br>
我提交的代码（先只看他的思想不看代码的好习惯下码出来的！！！）：<br>
class Solution {<br>
public:<br>
int removeDuplicates(vector<int>&amp; nums) {<br>
if(nums.size()&lt;3)<br>
return nums.size();<br>
else{<br>
int i=2;<br>
for(int j=2;j&lt;nums.size();j++)<br>
if(nums[j]!=nums[i-2])<br>
nums[i++]=nums[j];</p>
<pre><code>        return i;
    }    
}
</code></pre>
<p>};<br>
然后和他的代码对比一下，还是很多地方值得改进的，比如变量名，可以大大提高可读性的嘛！<br>
最后感想有点多，就写成一篇文章吧。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ C++ primer 第三章 笔记+习题 3.1-3.4]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-san-zhang-bi-ji-xi-ti-31-24</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-san-zhang-bi-ji-xi-ti-31-24">
        </link>
        <updated>2019-09-05T07:07:06.000Z</updated>
        <content type="html"><![CDATA[<p>3.1<br>
using声明 无须专门的前缀 using std::cin;<br>
每个名字都需要独立的using声明<br>
头文件不应包含using声明 否则会影响到所有使用该头文件的程序<br>
区分using指示和using声明</p>
<p>习题3.1<br>
由于是复习，所以一直有用using声明和using指示hhh<br>
但是必须说明using指示并不是好东西，多处引入using指示容易造成命名域污染</p>
<p>3.2<br>
string 表示可变长的字符序列 头文件 #include <string>  string定义在命名空间std中 最好在文件头加上using std::string <strong>始终要记得string不是内置类型</strong><br>
string empty； 默认初始化为空字符串<br>
string定义字符串末尾不含有空字符，长度不需要+1<br>
string初始化方式 string s1;string s2(s1); string s2 = s1; string s3(“value”); string s(5,’a’) = aaaaa;<br>
初始化的方式： 拷贝初始化 等号= ，直接初始化 括号（），列表初始化 花括号{ }<br>
！！！不一定有括号的就是直接初始化，拷贝初始化也可以用括号<br>
例如 int p(1);//直接初始化  int p1(p2);//拷贝初始化<br>
3.2.2<br>
一个类要定义各种运算符在该类对象上的新含义<br>
使用cin读取string对象时，会自动忽略开头的空白（空格符换行符制表符等） 然后<strong>遇到下一处空白停止读取，所以cin无法读取空格</strong><br>
如果<strong>需要保留输入的空白符，使用getline函数 遇到换行符为止</strong>（注意<strong>换行符也会被读进来，但换行符不会被存进string对象</strong>）<br>
如果输入一开始为换行符 则getline得到空string<br>
empty函数返回布尔值<br>
size函数返回值并非int，<strong>而是一个string::size_type类型的值</strong>，它是一个无符号类型的值unsigned，能够存放下任何string对象的大小<br>
注意size函数调用<strong>必须有括号size（）</strong><br>
所以不能将size函数的返回值<strong>与负值进行比较或其他操作 否则会触发强制转换</strong><br>
string <strong>相加为串接两个运算对象</strong><br>
标准库允许将字符字面值和字符串字面值转化为string对象 但混用时必须保证+加号两侧至少有一个string对象 例子 s = “hello” + “,” + s2 ; 错误 第一个加号无string对象<br>
所以 <strong>字符串字面值并非是string类型 而是array数组</strong></p>
<p>习题3.2</p>
<pre><code>	int main() {
	string s;
	//while (getline(cin, s))
		while(cin&gt;&gt;s)
		cout &lt;&lt; s &lt;&lt; endl;
};
</code></pre>
<p>习题3.3<br>
输入运算符自动忽略开头的空白，并且遇到下一处空白时停止读取，所以无法读取空白，但是getline不同，可以读取空白字符，包括<strong>换行符</strong>，只是读取后抛弃，不存入string中。<br>
习题3.4<br>
<code>int main() { 	string s1,s2; 	cout &lt;&lt; &quot;please input the first one:&quot;; 	getline(cin, s1); 	cout &lt;&lt; &quot;please input anothor one:&quot;; 	getline(cin, s2); 	if (s1 == s2) 		cout &lt;&lt; &quot;they are equal.&quot; &lt;&lt; endl; 	//else if (s1 &gt; s2) 	//	cout &lt;&lt; s1 &lt;&lt; endl; 	//else 	//	cout &lt;&lt; s2 &lt;&lt; endl; 	else if (s1.size() == s2.size()) 		cout &lt;&lt; &quot;they have same length.&quot; &lt;&lt; endl; 	else if (s1.size() &gt; s2.size()) 		cout &lt;&lt; s1 &lt;&lt; endl; 	else 		cout &lt;&lt; s2 &lt;&lt; endl; };</code><br>
习题3.5</p>
<pre><code>	int main() {
	string s,temp;
	cin &gt;&gt; s;
	while (cin &gt;&gt; temp) {
		//s = s + temp;
		s = s + &quot; &quot; + temp;
		cout &lt;&lt; s &lt;&lt;endl;
	}
};
</code></pre>
<p>3.2.3<br>
cctype 头文件中的函数可以用于处理string对象<br>
c中的标准库可以再c++中使用，name.h 变为 cname<br>
处理每个字符 使用基于范围for语句<br>
for (declaration : expression) {statement;} 其中declaration负责定义一个变量用于访问序列中的基础元素，expression为一个循环对象<br>
上述语句可以<strong>配合 auto 和 decltype</strong>来使用 比如 for (auto char1 : string1 )<br>
如果想改变string对象中字符的值，必须把循环变量expression设为<strong>引用类型</strong><br>
只处理一部分字符，使用迭代器或下标运算符[]<br>
string对象的下标<strong>从0计起</strong> s[s.size()-1]为最后一个字符<br>
下标运算符接受的输入参数是string::size_type 会将带符号类型值自动转化为该类型<br>
使用下标运算符前必须检验string对象是否为空 if(!s.empty())</p>
<p>习题3.6</p>
<pre><code>	int main() {
	string s;
	getline(cin,s);
	if (!s.empty())
	for (auto &amp;c : s) {
		c = 'X';
	}
	cout &lt;&lt; s &lt;&lt; endl;
};
</code></pre>
<pre><code>习题3.7
单纯的char是值拷贝传递，无法对原string进行改动，但是char&amp;可以
习题3.8
循环for更好用，操作起来更加方便，避免了while循环条件的寻找和阅读for循环头的复杂性，可读性更高
习题3.9
不合法，必须检查是否为空string 但是是能够正常输出，但size（）等于0
习题3.10
</code></pre>
<pre><code>	int main() {
	string s;
	getline(cin,s);
	if (!s.empty())
		for (char &amp;c : s) {
			if (!ispunct(c))
				cout &lt;&lt; c;
		}
};
</code></pre>
<pre><code>习题3.11
合法，c为const char &amp;
</code></pre>
<p>3.3<br>
vector表示对象的集合，其中所有对象的类型都相同 其中每个对象都有一个与之对应的索引<br>
头文件声明 #include<vector>   using std::vector;<br>
<strong>vector 是一个类模板 不是一个类型</strong><br>
vector能容纳大多数类型的对象作为元素，包括vector，<strong>唯独引用例外</strong>，因为引用不是对象<br>
vector对象默认初始化为空vector  vector<string> sver;<br>
vector对象之间可以互相赋值拷贝 但类型必须相同<br>
初始化的三个例外 1.拷贝初始化 = ，只能提供一个初始值 2.类内初始值只能用<strong>拷贝初始化=或者花括号初始化{ }</strong> 3.初始元素值的列表只能放在<strong>花括号</strong>内，所以称为列表初始化，而不能放在圆括号内<br>
可以使用 (元素数量，元素统一初始值) 进行初始化 元素统一初始值可以缺省（除非有些元素比如类明确要求提供初始值）<br>
所以vector<int> v1{10，1}和vector<int> v1（10，1）意思完全不一样<br>
圆括号不能用于列表初始化，但是花括号也可以进行直接初始化 vector<string> v1{10} vector<string> v1{10，“hi”}都是<strong>合法</strong>的 因为10无法作为元素初始值<br>
可以使用数组来初始化vector，需提供首元素地址和尾后地址，比如vecor<int> i (begin(arr),end(arr));<br>
vector<T> v(n)值初始化：**只提供对象容纳的元素数量而不用略去初始值，**此时库会创建一个值初始化的元素处置，并赋给容器中的所有元素，元素初值由元素类型决定</p>
<pre><code>习题3.12
a合法，空vector；b不合法，类型不匹配；c合法，10个“null”
习题3.13
</code></pre>
<p>（a）0<br>
（b）10,0<br>
（c）10,42<br>
（d）1,10<br>
（e）2,10和42<br>
（f）10，空<br>
（g）10，“hi”</p>
<p>3.3.2<br>
vector对象使用直接初始化的情况 1.初始值已知并较少 2.初始值是另外一个vector的副本 3.所有元素的初始值一样<br>
一般先创建一个空vector对象，再用<strong>push_back</strong>向其中添加元素<br>
重点知识：上述初始化的原因是vector对象能够高效增长，<strong>不需要提前定义长度</strong><br>
不能使用** 范围for 循环语句**对vector对象添加元素<br>
原因：范围for语句预先预定了迭代器end的位置，添加元素会导致end不断变化（STL剖析的解释：vector扩展空间并不是单纯地在内存下一段继续添加，而是必须alloc新的内存，再把原来的vector元素全部搬过去）</p>
<pre><code>习题3.14
</code></pre>
<pre><code>	int main() {
int i;
	vector&lt;int&gt; v_i;
	while (cin &gt;&gt;i)
		v_i.push_back(i);
	for (auto i : v_i)
		cout &lt;&lt; i &lt;&lt; ' ';
};
</code></pre>
<pre><code>习题3.15
</code></pre>
<pre><code>int main() {
	string s;
	vector&lt;string&gt; v_s;
	while (cin &gt;&gt; s)
		v_s.push_back(s);
	for (auto s : v_s)
		cout &lt;&lt; s &lt;&lt; ' ';
};
</code></pre>
<p>3.3.3<br>
vector.size() 返回的类型是** vectot<int>::size_type** 与string有区别<br>
vector对象能否比较决定于元素的类型 如类类型不一定能比较<br>
vector<strong>不能用下标形式向空vector添加元素 只能用push_back</strong><br>
缓冲区溢出：编译器无法发现通过下标访问不存在元素的错误 避免方法”：尽可能使用 范围for语句</p>
<pre><code>习题3.16
</code></pre>
<pre><code>	int main() {
	vector&lt;string&gt; v;
	cout &lt;&lt; v.size() &lt;&lt; endl;
	for (auto s : v)
		cout &lt;&lt; s &lt;&lt; ' ';
};
</code></pre>
<pre><code>习题3.17
</code></pre>
<pre><code>	int main() {
	vector&lt;string&gt; v_s ;
	string s;
	while (cin &gt;&gt; s)
		v_s.push_back(s);
	for (auto &amp;s : v_s)
		for (auto &amp;e : s)
			if (islower(e))
				e = toupper(e);
	for (auto s : v_s)
			cout &lt;&lt; s &lt;&lt; ' ';
};
</code></pre>
<pre><code>习题3.18
错误的，汇报运行时错误，必须用push_back添加元素
习题3.19
```
</code></pre>
<p>vector<int>i1{42,42,42,42,42,42,42,42,42,42};<br>
vector<int>i2(10,42);<br>
vector<int>i3=i2;</p>
<pre><code>	习题3.20
</code></pre>
<pre><code>int main() {
vector&lt;int&gt; v_i;
int i;
while (cin &gt;&gt; i)
	v_i.push_back(i);
for (int x = 0; x &lt; v_i.size()-1; ++x)
	cout &lt;&lt; v_i[x] + v_i[x + 1] &lt;&lt; ' ';
cout &lt;&lt; endl;
for (int x = 0,l = v_i.size(); x &lt;  (v_i.size()+1)/2; ++x)
	cout &lt;&lt; v_i[x] + v_i[l-1-x] &lt;&lt; ' ';
</code></pre>
<p>};</p>
<pre><code>	
3.4.1
具有迭代器的类型同时拥有返回迭代器的成员 例如begin 和 end
迭代器是容器所用，不是模板
begin 负责返回指向第一个元素的迭代器 end 负责返回指向容器“**尾元素的下一位置**”的迭代器 等于指向一个本不存在的“尾后”元素 称尾后迭代器
如果容器为空 begin和end返回统一迭代器 尾后迭代器
我们并不知道迭代器的准确类型 所以**定义时应该使用auto**
对于end不能++或—
迭代器类型 iterator或const_iterator 后者只能读不能写
begin 和 end 返回的迭代器类型取决于是否是常量
用cbegin和cend可以强行返回const_iterator
通过解引用访问迭代器指向的类的成员时 (*it).empty() 圆括号必不可少
或者使用it-&gt;empty（）
vector的push_back功能可能会使迭代器失效（stl的解释：vector的扩增capacity需要在新内存中进行复制粘贴，而迭代器本质是一个特定地址的指针）

习题3.21
	`
	int main() {
	vector&lt;int&gt; v{1,2,3,4,5,6};
	cout &lt;&lt; v.size() &lt;&lt; endl;
	for (auto i = v.begin();i!=v.end();++i)
		cout &lt;&lt; *i &lt;&lt; ' ';
};
`
	习题3.22
	`int main(){
	string text{ &quot;AbdGGasjd&quot; };
	for (auto &amp;i = text.begin(); i != text.end(); ++i)
	{
		*i = toupper(*i);
		cout &lt;&lt; *i ;
	}
};`
	习题3.23
</code></pre>
<pre><code>int main(){
vector&lt;int&gt; vi(10, 10);
for (auto &amp;i = vi.begin(); i != vi.end(); ++i)
	*i = *i * 2;
for (auto &amp;i = vi.begin(); i != vi.end(); ++i)
cout &lt;&lt; *i &lt;&lt;endl;
</code></pre>
<p>};</p>
<pre><code>	
3.4.2
	注意不能iter1+iter1
注意迭代器向前移动的概念 也就是向右移动
两个迭代器相减 得到类型为difference_type的带符号整型数
**交换两个迭代器的元素 iter_swap!!!**
习题3.24
	`int main() {
	vector&lt;int&gt; v_i;
	int i;
	while (cin &gt;&gt; i)
		v_i.push_back(i);
	for(auto ib=v_i.begin() ; ib!= v_i.end()-1; ++ib)
		cout &lt;&lt; *ib + *(ib+1) &lt;&lt; ' ';
	cout &lt;&lt; endl;
	for (auto ib = v_i.begin(),ie = v_i.end(); ie - ib&gt;0; ++ib)
		cout &lt;&lt; *ib + *(--ie) &lt;&lt; ' ';
};
`
	习题3.25
</code></pre>
<pre><code>int main() {
vector&lt;unsigned&gt; scores(11,0);
unsigned grade;
auto i = scores.begin();
while (cin &gt;&gt; grade) 
	if (grade &lt;= 100)
		++*(i + grade / 10);
for (auto i : scores)
	cout &lt;&lt; i &lt;&lt; ' ';
</code></pre>
<p>};</p>
<pre><code>								 
	习题3.26
	迭代器虽然支持相减，但是是不支持相加的！
	

	

习题感悟：
	string.size（）必须有括号
	必须检查string是否为空
	可以多看看自带的函数表（比如string的标点判断ispunct）
	c++中eof的键盘输入为windows Ctrl+Z linux  Ctrl+d（似乎是受编译器影响），用于结束while（cin&gt;&gt;string）
toupper(e) 返回char e的大写形式
迭代器是容器所用，不是模板
	字符串数组char text[]
迭代器向中间靠拢时，可以用 v_i.end()-v_i.begin()&gt;0来判断是否到了中位值</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux（Ubuntu）避坑]]></title>
        <id>https://lixin-ee.github.io//post/linuxubuntubi-keng</id>
        <link href="https://lixin-ee.github.io//post/linuxubuntubi-keng">
        </link>
        <updated>2019-09-05T01:48:18.000Z</updated>
        <content type="html"><![CDATA[<p>用su - 切换到root，输入密码提示认证失败。经查阅原来Ubuntu安装后，root用户默认是被锁定了的，不允许登录，也不允许 su 到 root<br>
终端下</p>
<p>lixin@lixin:~$ sudo passwd<br>
Password: &lt;--- 输入安装时那个用户的密码<br>
Enter new UNIX password: &lt;--- 新的Root用户密码<br>
Retype new UNIX password: &lt;--- 重复新的Root用户密码<br>
passwd：已成功更新密码</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 26. 删除排序数组中的重复项]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-26-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-26-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang">
        </link>
        <updated>2019-09-04T11:53:01.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p>示例 1:</p>
<p>给定数组 nums = [1,1,2],</p>
<p>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。</p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>嗯？题目似曾相识呀！完全可以用昨天的快慢双迭代器（我自己形容为新旧双迭代器）来解决嘛<br>
于是迅速脑海复习一遍，给出代码：</p>
<pre><code>int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        int i = 1;
        for(int j=1;j&lt;nums.size();j++)
            if(nums[j]!=nums[j-1])
                nums[i++]=nums[j];
        return i;

    }
</code></pre>
<p>其实中途还是给自己挖了坑，比如把i放进循环头里面定义了...太低级的错误啦，循环头定义的变量作用域只在循环体内。然后就是后置++这个点，其实并不好，只是为了代码简洁才这样，但是写程序时还是得老老实实前置++，即节省内存又增加可读性（并不是代码越少可读性越高！）<br>
然后激动地提交，期望一次过，当然还是标准结局：嗯？怎么又错了？<br>
一看到空数组...无语了，其实一开始是考虑过空数组的，但是看题目说有序数组就默认是非空数组了...还是得学习贾诩的算无遗策啊hhhh<br>
最后的代码：</p>
<pre><code>public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        if(nums.size()&gt;0){
        int i = 1;
        for(int j=1;j&lt;nums.size();j++)
            if(nums[j]!=nums[j-1])
                nums[i++]=nums[j];
        return i;
        }
        else
            return 0;
    }
</code></pre>
<p>感想：<br>
这一次还是很激动的，毕竟利用了昨天学习到的知识这么快就做出来了！而且本来打算今晚去剪头发的，如果写题写到九点多就尴尬了。本来还想着回到宿舍再写题，但是咬咬牙还是坚持下来了，果然越努力越幸运呀hhh</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第二章 笔记+习题 2.4-2.6]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-er-zhang-bi-ji-xi-ti-24</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-er-zhang-bi-ji-xi-ti-24">
        </link>
        <updated>2019-09-04T03:06:42.000Z</updated>
        <content type="html"><![CDATA[<p>2.4<br>
const 常量关键字，const对象一旦创建后就不能改变值，所以const对象必须初始化<br>
默认状态下 const对象仅在文件内有效，添加extern关键字就可以分享使用，只需要定义一次，在其他文件直接用extern声明就好<br>
声明和定义是不一样的</p>
<p>习题2.26<br>
（a）不合法，const必须初始化（b）合法（c）合法（d）</p>
<p>2.4.1<br>
对const的引用 const int ci = 1024; const int &amp;r1 = ci;<br>
引用的例外：初始化常量引用允许用任意表达式作为初始值 甚至是不同类型的值,只要该表达式的结果能转换成引用的类型即可，尤其是允许为一个常量引用绑定一个非常量的<br>
的对象、字面值，甚至一个一般表达式<br>
当 执行 double dval = 3.14; const int &amp;r1 = dval;时，实际编译时是 const int temp = dval; const int &amp;ri = temp; 将ri绑定到一个不会变化的临时量temp上，所以合法。<br>
<strong>常量应用仅对引用可参与的操作做出了界限，对引用对象本身是否是常量并未限定<br>
指向常量对象的引用必须是常量引用，不能是普通引用，但常量引用可以绑定到普通对象上。</strong></p>
<p>2.4.2<br>
存放常量的地址只能是 指向常量的指针（区分常量指针，同时指向常量的指针也没有规定必须指向常量对象）<br>
常量指针 必须初始化的固定值指针<br>
从右向左阅读，离变量名最近的符号决定变量的自身类型 一开始的符号决定指向的类型<br>
注意*的位置<br>
int errnumb = 0；int *const curerr = &amp;errnumb； 指向int变量的常量指针<br>
const double pi=3.1415；const double *const pip = &amp;pi；指向double常量（第一个const）的常量指针（第二个const）</p>
<p>习题2.27<br>
（a）不合法，指向常量的必须是常量引用<br>
（b）合法，常量指针可以指向非常量（c）合法（d）合法（e）合法<br>
（f）不合法，常量指针必须初始化<br>
（g）合法，指向常量的指针可以指向非常量，只是操作受到限制<br>
习题2.28<br>
（a）不合法，常量指针必须初始化<br>
（b）不合法，常量指针必须初始化<br>
（c）不合法，常量和常量引用必须初始化<br>
（d）不合法，常量指针必须初始化<br>
（e）指向常量的指针<br>
习题2.29<br>
（a）合法，常量可以赋值给非常量<br>
（b）不合法，不能把指向常量的指针直接赋给普通指针<br>
（c）不合法，不能用普通指针指向常量<br>
（d）如果是初始化，合法，如果是赋值，不合法<br>
（e）不合法，常量指针不能被赋值<br>
（f）不合法，常量不可以赋值</p>
<p>2.4.3<br>
顶层const 指针本身就是个常量 底层const 指针所指对象是个常量<br>
const int ci = 42；const int *const p3 = &amp;ci; 时 int *p = p3；为错误操作，因为p3为底层const 指向常量，只能由指向常量的指针<br>
习题2.30<br>
v2：顶层const          p2：底层const          p3:顶层const<br>
习题2.31<br>
合法；<br>
不合法 ；合法 ；<br>
不合法；合法</p>
<p>2.4.4<br>
常量表达式：值不会改变并且在编译过程中就能得到计算结果的表达式<br>
用常量表达式初始化的const对象也是常量表达式</p>
<p>声明为constexpr的变量一定是一个常量，而且必须用常量表达式进行初始化<br>
如果你认定变量是一个常量表达式，那就把它声明成constexpr类型</p>
<p>字面值类型：算数类型（int、double）、引用、指针<br>
非字面值类型：自定义类、IO库、string类 不能被定义成constexpr<br>
constexpr指针的值不能改标 相当于常量指针但位置与const不同<br>
int const *p 等同于 constexpr int *p<br>
constexpr const int *p 指向整形常量的常量指针<br>
定义在函数体之外的对象的地址固定不变，可用于初始化constexpr指针</p>
<p>习题2.32<br>
非法，null是保留字 修改变量名并最好使用nullptr</p>
<p>2.5.1<br>
类型别名 某种类型的同义词<br>
定义类型别名（1）typedef （2）别名声明 关键词 using<br>
类型别名可以间接使用 typedef double a； using b = a； 则b也是double类型<br>
地址的类型别名 typedef int *pint；<br>
**但注意 const pint *ps 等于指向int的常量指针，而非指向int常量的指针，**因为使用了类型别名后不等同于直接展开的。</p>
<p>2.5.2<br>
auto类型说明符 让编译器分析表达式所属的类型<br>
auto类型的变量必须有初始值<br>
如果在一条auto语句中声明多个变量，则语句中所有变量的初始基本类型都必须一样<br>
auto i = 0,*p = &amp;i;//正确，初始基本类型都是int（声明符号*不算在基本类型内）<br>
auto 会以引用对象的类型作为auto的类型，而不是把它视为引用，如果想定义为引用 必须使用auto &amp;<br>
auto会忽略顶层const 保留底层const 所以顶层const需要明确指出 const auto<br>
常量引用可以绑定字面值</p>
<p>习题2.33<br>
a = 42;<br>
b = 42;<br>
c = 42；<br>
e:error；<br>
f:error；<br>
g:error；<br>
习题2.35<br>
第一个auto  j  类型为int<br>
第二个auto  &amp;k 类型为const int &amp;<br>
第三个auto *p类型为const int *<br>
第四个auto j2类型为const int<br>
第五个auto &amp;k2 类型为const int&amp;</p>
<p>2.5.3<br>
decltype 选择并返回操作数的数据类型<br>
使用方法 decltype（f（）） sum = x；<br>
引用从来都作为其所指对象的同义词出现，只有用在decltype处是一个例外：decltype并不管引用的对象是谁，只返回引用类型<br>
int i = 1，*p = &amp;i；&amp;r = i； 其中decltype（r）返回引用类型，decltype（r+0）返回int<br>
decltype（i=i1）返回引用 而当表达式的内容是解引用操作，则decltype将得到引用类型 所以decltype（*p）返回int&amp; 而不是int<br>
decltype的括号数量影响返回值 decltype（（变量））双层括号永远返回引用类型 decltype（变量） 单层括号就返回变量的类型。双层括号会被当做一个可作为赋值语句左值的表达式<br>
先执行decltype中的表达式再计算定义的表达式 decltype(a=b) c = a;//结果c = b</p>
<p>习题2.36<br>
decltype(())双层括号表示引用（注意引用必须初始化）<br>
a是int类型   4<br>
b是int类型   4<br>
c是int类型   4<br>
d是int &amp;类型    4<br>
全是4！！！！！！！！！！！<br>
习题2.37<br>
a int 3;<br>
b int 4;<br>
c int 3;<br>
d int &amp; 3;<br>
习题2.38<br>
1：如果使用引用类型，auto会识别为其所指对象的类型，decltype则会识别为引用的类型。<br>
2：decltype(())双括号的差别。</p>
<p>2.6<br>
类类型 相当于以类的形式自定义数据类型<br>
struct 关键词<br>
类体的花括号形成一个新的作用域  表示结束的花括号后必须写一个分号，因为类体后面可以紧跟变量名，以示对该类型对象的定义<br>
类体内定义类的成员<br>
没有初始值的成员将被默认初始化<br>
类内初始值可以用花括号和等号，不能用圆括号</p>
<p>习题2.39<br>
error C2628: “example”后面接“int”是非法的(是否忘记了“;”?)<br>
error C3874: “main”的返回类型应为“int”而非“example”<br>
非常有趣，第二个错误显示编译器试图把类声明视为返回类型</p>
<p>2.6.3<br>
类一般定义在头文件中<br>
头文件改变后需要重新编译源文件获取更新过的声明<br>
预处理器 看到#include标记就会使用指定的头文件的内容代替#include<br>
另外一项预处理功能是头文件保护符 依赖于预处理变量<br>
#define 将一个名字设定为预处理变量 #ifdef 当且仅当变量已定义时为真 #ifndef当且仅当变量未定义时时为真   遇到#endif指令停止<br>
预处理变量无视作用域的规则<br>
预处理变量 包括头文件保护符必须唯一 使用头文件中类的名字来构建保护符的名字，同时大写预处理变量的名字<br>
头文件保护符是给头文件用在其自身的！！！</p>
<p>习题2.40 2.41 2.42<br>
struct Sales_Data {<br>
public:<br>
string ISBN;<br>
int units_sold = 0;<br>
double price = 0.00;<br>
double ave = 0.00;</p>
<pre><code>	int input_data(istream &amp;in) {
		in &gt;&gt; ISBN &gt;&gt; units_sold &gt;&gt; price;
		ave = price*ave / ave;
	}
	
	Sales_Data&amp; add_data(Sales_Data&amp; data1,Sales_Data&amp; data2) {
		if (data1.equal_isbn(data2)) {
			Sales_Data sum;
			sum.units_sold = data1.units_sold + data2.units_sold;

			sum.ave = (data1.units_sold*data1.price + data2.units_sold*data2.price) / sum.units_sold;
			sum.price = sum.ave;
			return sum;
		}
		else
		{
			std::cerr &lt;&lt; &quot;Data must have same ISBN&quot; &lt;&lt; std::endl;
		}

		
	}

	bool equal_isbn(Sales_Data exam)const {
		return ((*this).ISBN == exam.ISBN);
	}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组-27. 移除元素]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-27-yi-chu-yuan-su</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-27-yi-chu-yuan-su">
        </link>
        <updated>2019-09-03T14:44:56.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目要求<br>
给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p>示例 1:</p>
<p>给定 nums = [3,2,2,3], val = 3,</p>
<p>函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</p>
<p>你不需要考虑数组中超出新长度后面的元素。<br>
示例 2:</p>
<p>给定 nums = [0,1,2,2,3,0,4,2], val = 2,</p>
<p>函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p>
<p>注意这五个元素可为任意顺序。</p>
<p>你不需要考虑数组中超出新长度后面的元素。<br>
说明:</p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<p>// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝<br>
int len = removeElement(nums, val);</p>
<p>// 在函数里修改输入数组对于调用者是可见的。<br>
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。<br>
for (int i = 0; i &lt; len; i++) {<br>
    print(nums[i]);<br>
}</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/remove-element<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>我第一次给出的答案为下：</p>
<pre><code>class Solution {
public:
    int removeElement(vector&lt;int&gt;&amp; nums, int val) {
        int cut_len = 0 ;
        for(int i = 0;i&lt;nums.size();i++)
            if(nums[i]==val){
                ++cut_len;
                for (int j=i;j&lt;nums.size()-2;j++)
                    nums[j]=nums[j+1];
            }
         
         return nums.size()-cut_len;
    }
   
};
</code></pre>
<p>一提交，可以说是惨不忍睹了，算法有一个特点：解决办法和使用范围是同等重要的！<br>
我这个解法很明显没有考虑连续的val的情况 比如{3，2，2，3}去除2，第二个2很明显被前移略过了，想了一下应该是受算法书的“后面的元素往前移动”的惯性思维的影响，问题是算法书是去掉固定位置的值呢。。。<br>
修改了几次，还是有不少问题<br>
比如一开始j&lt;nums.size()-2处如果size为1，那么无符号的负数直接变成一个怪物，直接内存爆炸。<br>
最后深感这种方法的缺陷，于是观看官方答案：</p>
<blockquote>
<p>方法一：双指针<br>
思路</p>
<p>既然问题要求我们就地删除给定值的所有元素，我们就必须用 O(1)O(1) 的额外空间来处理它。如何解决？我们可以保留两个指针 i 和j，其中 i 是慢指针，j 是快指针。</p>
<p>算法</p>
<p>当 nums[j] 与给定的值相等时，递增 jj 以跳过该元素。只要 nums[j] 不等于nums[j] 我们就复制 nums[j] 到 nums[i]并同时递增两个索引。重复这一过程，直到 jj到达数组的末尾，该数组的新长度为 i。</p>
<p>该与 删除排序数组中的重复项 的解法十分相似。</p>
<pre><code>Java
public int removeElement(int[] nums, int val) {
    int i = 0;
    for (int j = 0; j &lt; nums.length; j++) {
        if (nums[j] != val) {
            nums[i] = nums[j];
            i++;
        }
    }
    return i;
}
</code></pre>
<p>复杂度分析</p>
<p>时间复杂度：O(n)，<br>
假设数组总共有 n 个元素，i 和 j 至少遍历 2n 步。</p>
<p>空间复杂度：O(1)。</p>
</blockquote>
<p>不禁感叹：妙啊！！！（第二种官方解法略坑，不考虑原数组顺序，就不贴上来了）<br>
主要思想就是使用两个指针（迭代器）,一个作为新数组的迭代器，一个作为旧数组的迭代器，旧数组有不同的就交给新数组，目标值的就跳过，既实现了原地修改，又避免了处理目标值这种棘手的问题，真的妙啊！<br>
复现如下：</p>
<pre><code>class Solution {
public:
    int removeElement(vector&lt;int&gt;&amp; nums, int val) {
        int i = 0;
        for(int j= 0;j&lt;nums.size();++j)
            if(nums[j]!=val)
               nums[i++]=nums[j];
         return i;
    
    }
};
</code></pre>
<p>其实复现中还是遇到了不少问题，一开始非常自大，看一眼就开始复现了，结果错漏百出，所以还是得老老实实分析出官方解法的算法思想，而不是流于代码表面，这样才可以在其他题目中轻轻松松复现出来！</p>
]]></content>
    </entry>
</feed>