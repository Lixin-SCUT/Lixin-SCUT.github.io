<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2020-01-15T01:30:23.798Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[链表 61. 旋转链表[中等]]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-61-xuan-zhuan-lian-biao-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-61-xuan-zhuan-lian-biao-zhong-deng">
        </link>
        <updated>2020-01-14T14:02:39.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。<br>
示例 1:<br>
输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2<br>
输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br>
解释:<br>
向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL<br>
向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br>
示例 2:<br>
输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4<br>
输出: 2-&gt;0-&gt;1-&gt;NULL<br>
解释:<br>
向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL<br>
向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL<br>
向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL<br>
向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/rotate-list<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>和数组 189.旋转数组比较像<br>
首先一个指针判断长度len<br>
然后把k和len取余数<br>
然后找到倒数第k个节点<br>
弄一个ehead，截断放到前面，和原head连接起来</p>
<p>细节问题比较重要 比如k=0的情况 还有循环的判断条件等，比如后面应该是找到倒数k+1个数，比如12345，要找到3而不是4，因为需要把ehead接到4</p>
<pre><code>class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        ListNode *ehead=new ListNode(0);
        ehead-&gt;next=head;
        ListNode* cur=ehead;
        int len=0;
        while(cur-&gt;next){
            ++len;
            cur=cur-&gt;next;
        }     
        if(len==0||len==1) return head;
        k=k%len;
        if(!k) return head;
        int count=len-k;
        ListNode* end=cur;
        cur=ehead;
        while(count--)
            cur=cur-&gt;next;
        ehead-&gt;next=cur-&gt;next;
        cur-&gt;next=NULL;
        end-&gt;next=head;
        return ehead-&gt;next;
    }
};
</code></pre>
<p>官方题解还是比较有趣的，在计算长度的过程中顺带连接成环，再在相应的位置断开，免去了后面的操作。同时一定要记得设置尾节点的next为null，否则输出时会无限循环打印<br>
官方题解：<br>
方法 1：<br>
直觉<br>
链表中的点已经相连，一次旋转操作意味着：<br>
先将链表闭合成环<br>
找到相应的位置断开这个环，确定新的链表头和链表尾<br>
新的链表头在哪里？<br>
在位置 n-k 处，其中 n 是链表中点的个数，新的链表尾就在头的前面，位于位置 n-k-1。<br>
我们这里假设 k &lt; n<br>
如果 k &gt;= n 怎么处理？<br>
k 可以被写成 k = (k // n) * n + k % n 两者加和的形式，其中前面的部分不影响最终的结果，因此只需要考虑 k%n 的部分，这个值一定比 n 小。<br>
算法<br>
算法实现很直接：<br>
找到旧的尾部并将其与链表头相连 old_tail.next = head，整个链表闭合成环，同时计算出链表的长度 n。<br>
找到新的尾部，第 (n - k % n - 1) 个节点 ，新的链表头是第 (n - k % n) 个节点。<br>
断开环 new_tail.next = None，并返回新的链表头 new_head。<br>
实现</p>
<pre><code>class Solution {
  public ListNode rotateRight(ListNode head, int k) {
    // base cases
    if (head == null) return null;
    if (head.next == null) return head;

    // close the linked list into the ring
    ListNode old_tail = head;
    int n;
    for(n = 1; old_tail.next != null; n++)
      old_tail = old_tail.next;
    old_tail.next = head;

    // find new tail : (n - k % n - 1)th node
    // and new head : (n - k % n)th node
    ListNode new_tail = head;
    for (int i = 0; i &lt; n - k % n - 1; i++)
      new_tail = new_tail.next;
    ListNode new_head = new_tail.next;

    // break the ring
    new_tail.next = null;

    return new_head;
  }
}
</code></pre>
<p>复杂度分析<br>
时间复杂度：O(N)，其中 N 是链表中的元素个数<br>
空间复杂度：O(1)，因为只需要常数的空间</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 16. 最接近的三数之和[中等][未做出][双指针]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-16-zui-jie-jin-de-san-shu-zhi-he-zhong-deng-wei-zuo-chu-shuang-zhi-zhen</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-16-zui-jie-jin-de-san-shu-zhi-he-zhong-deng-wei-zuo-chu-shuang-zhi-zhen">
        </link>
        <updated>2020-01-14T01:27:41.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。<br>
例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.<br>
与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/3sum-closest<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>【未做出】<br>
一开始我想的是贪心算法，三个位置各选其一，不断比较当前值和三个位置的值的和来决定要不要更换、和哪一位更换<br>
但是例如[-10,1,1,1,10]和target=0的情况下，最后选出[1,1,1]肯定不是我们想要的结果</p>
<p>tag是双指针，暂时没啥帮助</p>
<p>我想到的第一个是先排序，然后寻找和target最接近的数，然后再使得剩下两个数之和尽可能小（但是如果target远大于nums中的最大值，我们反而希望是两数之和越大越好）</p>
<p>没思路 看题解<br>
题解的思路主要是线排序，然后固定一个值，然后把该值后面的数组通过双指针进行缩减判断</p>
<p>题解中有个优化挺不错的，值得参考</p>
<pre><code>class Solution {
public:
    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) {
        int len=nums.size();
        int ans=nums[0]+nums[1]+nums[len-1];
        quicksort(nums,0,len-1);
        for(int i=0;i&lt;len;++i){
            int res;
            for(int j=i+1,k=len-1;j&lt;k;){
                res=nums[i]+nums[j]+nums[k];
                ans=abs(ans-target)&lt;abs(res-target)?ans:res;
                if(ans==target) return ans;
                if(res&gt;target)
                    --k;
                else
                    ++j;
            }
        }
        return ans;
    }
    
    void quicksort(vector&lt;int&gt; &amp;nums,int beg,int end){
        if(beg&lt;end){
            int mid=partition(nums,beg,end);
            quicksort(nums,beg,mid-1);
            quicksort(nums,mid+1,end);
        }
    }
    
    int partition(vector&lt;int&gt; &amp;nums,int beg,int end){
        int pivotkey=nums[beg];
        while(beg&lt;end){
            while(beg&lt;end&amp;&amp;pivotkey&lt;=nums[end])
                --end;
            nums[beg]=nums[end];
            while(beg&lt;end&amp;&amp;pivotkey&gt;=nums[beg])
                ++beg;
            nums[end]=nums[beg];
        }
        nums[beg]=pivotkey;
        return beg;
    }
};
</code></pre>
<p>看看网友的高赞题解和优化题解：<br>
解题方案</p>
<blockquote>
<p>思路<br>
标签：排序和双指针<br>
本题目因为要计算三个数，如果靠暴力枚举的话时间复杂度会到 O(n^3)，需要降低时间复杂度<br>
首先进行数组排序，时间复杂度 O(nlogn)<br>
在数组 nums 中，进行遍历，每遍历一个值利用其下标i，形成一个固定值 nums[i]<br>
再使用前指针指向 start = i + 1 处，后指针指向 end = nums.length - 1 处，也就是结尾处<br>
根据 sum = nums[i] + nums[start] + nums[end] 的结果，判断 sum 与目标 target 的距离，如果更近则更新结果 ans<br>
同时判断 sum 与 target 的大小关系，因为数组有序，如果 sum &gt; target 则 end--，如果 sum &lt; target 则 start++，如果 sum == target 则说明距离为 0 直接返回结果<br>
整个遍历过程，固定值为 n 次，双指针为 n 次，时间复杂度为 O(n^2)<br>
总时间复杂度：O(nlogn) + O(n^2) = O(n^2)</p>
</blockquote>
<pre><code>class Solution {
    public int threeSumClosest(int[] nums, int target) {
        Arrays.sort(nums);
        int ans = nums[0] + nums[1] + nums[2];
        for(int i=0;i&lt;nums.length;i++) {
            int start = i+1, end = nums.length - 1;
            while(start &lt; end) {
                int sum = nums[start] + nums[end] + nums[i];
                if(Math.abs(target - sum) &lt; Math.abs(target - ans))
                    ans = sum;
                if(sum &gt; target)
                    end--;
                else if(sum &lt; target)
                    start++;
                else
                    return ans;
            }
        }
        return ans;
    }
}
</code></pre>
<p>优化题解：<br>
双指针法的解题思路<br>
先让数组有序，也就是需要先对数组进行排序<br>
然后每次固定一个元素，再去寻找另外两个元素，也就是双指针<br>
双指针法的代码实现<br>
利用 Arrays.sort(nums) 对数组进行排序。<br>
初始化一个用于保存结果的值 result = nusm[0] + nums[1] + nums[2] （不要自己设初值，直接从数组中抽取三个元素，假设这是最接近的三数之和，然后再更新就是了）。<br>
利用下标 i 对数组进行遍历，此时就是在固定第一个元素，注意，下标 i 的边界为 i &lt; nums.length-2，否则设置指针的时候会出现数组越界。<br>
每次遍历的过程中设置两个指针，分别是 left = i + 1、right = nums.length - 1。<br>
检查 sum = nums[i] + nums[left] + nums[right]与 target 的距离，如果该距离比之前保存的 result 与 target 的距离更小，就更新 result。<br>
然后就是移动双指针。<br>
如果 sum 的值比 target 大，那么我们让 right--，因为数组是有序的，right --会使得下一次的 sum 更小，也就更接近 target 的值<br>
同理，如果 sum 的值 target 小，那么我们让 left++。·<br>
left++ 和 right-- 的界限自然是 left != right，如果 left == right，说明我们已经将所有的元素都遍历过一遍了。<br>
重复上面的操作，直到i循环结束为止，返回 result。<br>
下面是具体的代码实现，简单，但是效率也不高，还可以进行一些优化</p>
<pre><code>class Solution {
    public int threeSumClosest(int[] nums, int target) {
        Arrays.sort(nums);
        int result = nums[0] + nums[1] + nums[2];
        for(int i=0;i&lt;nums.length-2;i++){
            int left = i+1;
            int right = nums.length - 1;
            while(left != right){
                int sum = nums[i] + nums[left] + nums[right];
                if(Math.abs(sum - target) &lt; Math.abs(result - target))
                    result = sum;
                if(sum &gt; target){
                    right--;
                }
                else{
                    left++;
                }
            }
        }
        return result;
    }
｝
</code></pre>
<p>双指针法的优化<br>
元素重复的问题<br>
举个例子，nums = [1,1,1,2,3] target = 7，那么最终的结果应该是 6 (1 + 2 + 3)。<br>
但是按照上面的代码，在遍历的时候 nums[i]会重复的等于 1 这个数，但是其实之前 nums[i] 等于 1 已经遍历过了，后面的遍历都属于无用的遍历。<br>
所以可以添加去重的操作</p>
<pre><code>class Solution {
    public int threeSumClosest(int[] nums, int target) {
        Arrays.sort(nums);
        int result = nums[0] + nums[1] + nums[2];
        for(int i=0;i&lt;nums.length-2;i++){
            int left = i+1;
            int right = nums.length - 1;
            while(left != right){
                int sum = nums[i] + nums[left] + nums[right];
                if(Math.abs(sum - target) &lt; Math.abs(result - target))
                    result = sum;
                if(sum &gt; target){
                    right--;
                    // 解决nums[right]重复
                    while(left != right &amp;&amp; nums[right] == nums[right+1])
                        right--;
                }
                else{
                    left++;
                    // 解决nums[left]重复
                    while(left != right &amp;&amp; nums[left] == nums[left-1])
                        left++;
                }
            }
            // 解决nums[i]重复
            while(i&lt;nums.length-2 &amp;&amp; nums[i] == nums[i+1])
                i++;
        }
        return result;
    }
}
</code></pre>
<p>超越界限的问题<br>
举个例子，nums = [-3,-1,3,4,5]。<br>
假设 i = 0，left = 1，right = 4，那么每次 left 和 right 之间都有许多元素，那么 left 和 right 之间的元素之和肯定也有一个最小值和一个最大值。<br>
就如同 left = 1，right = 4，那么移动指针的情况下，nums[left] + nums[right] 的最小值肯定为 nums[left] + nums[left + 1]，因为这两个元素是 left 和 right 范围内能取到的最小的两个元素，同理可证最大值。<br>
如果 target 的值比 nums[i] + nums[left] + nums[left + 1] 的值还小，那么双指针无论怎么取，最后都会取到 nums[i] + nums[left] + nums[left + 1]。<br>
同理可证 target 的值比nums[i] + nums[right] + nums[right - 1] 的值还大的情况。<br>
所以可以增加一个判断，满足条件的情况下就可以直接取值，而不需要双指针一步步的判断来进行取值，减少了双指针的移动。</p>
<pre><code>class Solution {
    public int threeSumClosest(int[] nums, int target) {
        Arrays.sort(nums);
        int result = nums[0] + nums[1] + nums[2];
        for(int i=0;i&lt;nums.length-2;i++){
            int left = i+1;
            int right = nums.length - 1;
            while(left != right){
                // 判断最小值
                int min = nums[i] + nums[left] + nums[left + 1];
                if(target &lt; min){
                    if(Math.abs(result - target) &gt; Math.abs(min - target))
                        result = min;
                    break;
                }
                //判断最大值
                int max = nums[i] + nums[right] + nums[right - 1];
                if(target &gt; max){
                    if(Math.abs(result - target) &gt; Math.abs(max - target))
                        result = max;
                    break;  
                }
                int sum = nums[i] + nums[left] + nums[right];
                if(Math.abs(sum - target) &lt; Math.abs(result - target))
                    result = sum;
                if(sum &gt; target){
                    right--;
                    while(left != right &amp;&amp; nums[right] == nums[right+1])
                        right--;
                }
                else{
                    left++;
                    while(left != right &amp;&amp; nums[left] == nums[left-1])
                        left++;
                }
            }
            while(i&lt;nums.length-2 &amp;&amp; nums[i] == nums[i+1])
                i++;
        }
        return result;
    }
}
</code></pre>
<p>三数之和等于 target 的问题<br>
举个例子，nums = [1,1,2,3,4,5,6,10] target = 12，那么最终的结果应该是 12 (1 + 1 + 10)。<br>
有些时候，可能会直接找到三数之和等于 target 的情况，此时直接返回结果即可，不需要在进行之后的循环，因为不可能有数比他自己更接近自己了。</p>
<pre><code>class Solution {
    public int threeSumClosest(int[] nums, int target) {
        Arrays.sort(nums);
        int result = nums[0] + nums[1] + nums[2];
        for(int i=0;i&lt;nums.length-2;i++){
            int left = i+1;
            int right = nums.length - 1;
            while(left != right){
                int min = nums[i] + nums[left] + nums[left + 1];
                if(target &lt; min){
                    if(Math.abs(result - target) &gt; Math.abs(min - target))
                        result = min;
                    break;
                }
                int max = nums[i] + nums[right] + nums[right - 1];
                if(target &gt; max){
                    if(Math.abs(result - target) &gt; Math.abs(max - target))
                        result = max;
                    break;  
                }
                int sum = nums[i] + nums[left] + nums[right];
                // 判断三数之和是否等于target
                if(sum == target)
                    return sum;
                if(Math.abs(sum - target) &lt; Math.abs(result - target))
                    result = sum;
                if(sum &gt; target){
                    right--;
                    while(left != right &amp;&amp; nums[right] == nums[right+1])
                        right--;
                }
                else{
                    left++;
                    while(left != right &amp;&amp; nums[left] == nums[left-1])
                        left++;
                }
            }
            while(i&lt;nums.length-2 &amp;&amp; nums[i] == nums[i+1])
                i++;
        }
        return result;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ UNP-UNIX网络编程 第五章 echo程序]]></title>
        <id>https://lixin-ee.github.io//post/unp-unix-wang-luo-bian-cheng-di-wu-zhang-echo-cheng-xu</id>
        <link href="https://lixin-ee.github.io//post/unp-unix-wang-luo-bian-cheng-di-wu-zhang-echo-cheng-xu">
        </link>
        <updated>2020-01-13T08:34:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="回显echo服务器">回显（echo）服务器：</h1>
<p>(1)	客户从标准输入读入一行文本，并写给服务器；<br>
(2)	服务器从网络输入读入这行文本，并回射给客户；<br>
(3)	客户从网络输入读入这行回射文本，并显示在标准输出上。<br>
<img src="https://lixin-ee.github.io//post-images/1578904558967.png" alt=""></p>
<ul>
<li>服务器程序</li>
</ul>
<pre><code>//tcpserv01.c
//Code by Lixin on 2020/01/13

#include &quot;unp.h&quot;

int main(int argc,char **argv){
	int listenfd,connfd;
	pid_t childpid;
	socklen_t clilen;
	struct sockaddr_in cliaddr,servaddr;
	listenfd=socket(AF_INET,SOCK_STREAM,0);

	bzero(&amp;servaddr,sizeof(servaddr));
	servaddr.sin_family=AF_INET;
	servaddr.sin_addr.s_addr=htonl(INADDR_ANY);
	servaddr.sin_port=htons(SERV_PORT);

	bind(listenfd,(SA *)&amp;servaddr,sizeof(servaddr));
	listen(listenfd,LISTENQ);
	for(;;){
		clilen=sizeof(cliaddr);
		connfd=accept(listenfd,(SA *)&amp;cliaddr,&amp;clilen);
		if((childpid=fork())==0){
			close(listenfd);
			str_echo(connfd);
			exit(0);
		}
		close(connfd);
	}
}
</code></pre>
<p>创建一个TCP套接字。在待捆绑到该TCP套接字的网际网套接字地址结构中填入通配地址（INADDR_ANY）和服务器的众所周知端口（SERV_PORT,在头文件unp.h中其值定 义为9877）。</p>
<ul>
<li>TCP回射服务器程序：str_echo函数</li>
</ul>
<pre><code>//str_echo.c
//Code by Lixin on 2020/01/13

#include &quot;unp.h&quot;

void str_echo(int sockfd){
	ssize_t n;
	char buf[MAXLINE];

	while((n=read(sockfd,buf,MAXLINE))){
		if(n&gt;0)
			Writen(sockfd,buf,n);
		else if(n&lt;0&amp;&amp;errno==EINTR)
			continue;
		else if(n&lt;0)
			err_sys(&quot;str_echo:read error&quot;);
	}
}
</code></pre>
<ul>
<li>客户端程序：</li>
</ul>
<pre><code>//tcpcli01.c
//Code by Lixin on 2020/01/13

#include &quot;unp.h&quot;
int main(int argc,char** argv){
	int sockfd;
	struct sockaddr_in servaddr;

	if(argc!=2)
		err_quit(&quot;usage:tcpcli&lt;IPaddress&gt;&quot;);
	
	sockfd=socket(AF_INET,SOCK_STREAM,0);

	bzero(&amp;servaddr,sizeof(servaddr));
	servaddr.sin_family=AF_INET;
	servaddr.sin_port=htons(SERV_PORT);
	inet_pton(AF_INET,argv[1],&amp;servaddr.sin_addr);
	connect(sockfd,(SA *)&amp;servaddr,sizeof(servaddr));
	str_cli(stdin,sockfd);
	exit(0);
}
</code></pre>
<ul>
<li>TCP回射客户程序：str_cli函数</li>
</ul>
<pre><code>//str_cli.c
//Code by Lixin on 2020/01/13

#include &quot;unp.h&quot;

void str_cli(FILE *fp,int sockfd)
{
	char sendline[MAXLINE],recvline[MAXLINE];

	while(fgets(sendline,MAXLINE,fp)!=NULL){
		writen(sockfd,sendline,strlen(sendline));
		if(readline(sockfd,recvline,MAXLINE)==0)
			err_quit(&quot;str_cli:server terminated prematurely&quot;);
		fputs(recvline,stdout);
	}
}
</code></pre>
<h1 id="正常启动">正常启动</h1>
<p>服务器启动后，它调用socketbind、listen和accept,并阻塞于accept调用。<br>
运行netstat -a命令来检查服务器监听套接字的状态<br>
netstat用星号“*&quot;来表示一个为0的IP地址（INADDR_ANY,通配地址）或为0的端口号。<br>
在同一个主机上启动客户，并指定服务器主机的IP地址为127.0.0.1 （环回地址）<br>
客户调用socket和connect,后者引起TCP的三路握手过程。当三路握手完成后，客户中 的connect和服务器中的accept均返回，连接于是建立。接着发生的步骤如下：<br>
⑴客户调用str_cli函数，该函数将阻塞于fgets调用，因为我们还未曾键入过一行文本。<br>
（2）	当服务器中的accept返回时，服务器调用fork,再由子进程调用str_echo.该函数调 用readline, readline调用read,而read在等待客户送入一行文本期间阻塞。<br>
（3）	另一方面，服务器父进程再次调用accept并阻塞，等待下一个客户连接。</p>
<p>客户接收到三路握手的第二个分节时，connect返回，而服务器要直到接收到 三路握手的第三个分节才返回，即在connect返回之后再过一半RTT才返回.</p>
<p>可以用ps查看后台进程的状态和关系</p>
<h1 id="正常终止">正常终止</h1>
<p>&lt;Ctrl+D&gt;是我们的终端EOF字符，键入终端EOF字符（Control-D）以终止客户<br>
当前连接的客户端发送fin和ack后会进入了TIME_WAIT状态</p>
<p>我们可以总结出正常终止客户和服务器的步骤。<br>
⑴当我们键入EOF字符时，fgets返回一个空指针，于是str_cli函数返回。<br>
(2)	当str_cli返回到客户的main函数时，main通过调用exit终止。<br>
(3)	进程终止处理的部分工作是<strong>关闭所有打开的描述符</strong>，因此客户打开的套接字由内核关闭。这导致客户TCP发送一个FIN给服务器，服务器TCP则以ACK响应，这就是TCP连接终止序 列的前半部分。至此，<strong>限务器套接字处于CLOSE_WAIT状态，客户套接字则处于FIN_WAIT_2 状态</strong><br>
(4)	当服务器TCP接收FIN时，服务器子进程阻塞于readline调用，于是readline 返回0。这导致str_echo函数返回服务器子进程的main函数。<br>
(5)	服务器子进程通过调用exit来终止。<br>
(6)	服务器子进程中打开的所有描述符随之关闭。由<strong>子进程</strong>来关闭已连接套接字会引发TCP 连接终止序列的最后两个分节：一个从服务器到客户的FIN和一个从客户到服务器的ACK 。至此，连接完全终止，客户套接字进入TIME_WAIT状态。<br>
(7)	进程终止处理的另一部分内容是：在服务器子进程终止时，给<strong>父进程</strong>发送一个SIGCHLD 信号。，但是我们没有在代码中捕获该信号，而该信号的默认行为是被回 忽略。既然父进程未加处理，子进程于是<strong>进入僵死状态</strong>。可以使用ps命令验证这--点。如果stat列为Z，且command列后面带有＜defunct＞字样，就属于僵死进程<br>
进程的状态是Z (表示僵死)。我们必须清理僵死进程，这就涉及Unix信号的处理。</p>
<h1 id="posix信号处理">POSIX信号处理</h1>
<p>信号(signal)就是告知某个进程发生了某个事件的通知，有时也称为软件中断(software interrupt),信号通常是异步发生的<br>
信号可以：<br>
・由一个进程发给另一个进程(或自身)；<br>
・由内核发给某个进程，SIGCHLD信号就是由内核在任何一个进程终止时发给它的父进程的一个信号。</p>
<p>每个信号都有一个与之关联的处置(disposition),也称为行为(action)。我们通过调用 sigaction函数(稍后讨论)来设定一个信号的处置，并有三种选择<br>
(1)	我们可以提供一个函数，只要有特定信号发生它就被调用。这样的函数称为信号处理函 数(signal handler),这种行为称为捕获(catching)信号<br>
有两个信号有绝对权限，不能被捕获（亦即不能忽略或者用其他函数处理），它们是SIGKILL 和STGSTOP，一般用于防止一个程序忽略了所有信号但又无法终止。<br>
信号处理函数由信号值这个单一的整数参数来调用，且没有返回值，其函数原型 因此如下：<br>
void handler (int signo);<br>
(2)	我们可以把某个信号的处置设定为SIG-IGN来忽略(ignore)它。SIGKILL和SIGSTOP 这两个信号不能被忽略。<br>
(3)	我们可以把某个信号的处置设定为SIG_DFL来启用它的默认(default)处置。<br>
默认处置 网通常是在收到信号后终止进程，其中某些信号还在当前工作目录产生一个进程的核心映像(coreimage,也称为内存影像)。另有个别信号的默认处置是忽略，SIGCHLD和SIGURG (带外数据到 达时发送，见第24章)就是本书中出现的默认处置为忽略的两个信号。</p>
<p>POSIX信号语义<br>
POSIX的系统上的信号处理总结为以下几点。<br>
•—旦安装了信号处理函数，它便一直安装着(较早期的系统是每执行一次就将其拆除)。<br>
•在一个信号处理函数运行期间，正被递交的信号是阻塞的。而且，安装处理函数时在传递给sigact_ion函数的sa_mask信号集中指定的任何额外信号也被阻塞。，我 们将sa_mask置为空集，意味着除了被捕获的信号外，没有额外信号被阻塞。<br>
•如果一个信号在被阻塞期间产生了一次或多次，那么该信号被解阻塞之后通常<strong>只递交一次</strong>，也就是说Unix信号默认是<strong>不排队的</strong>。<br>
•利用sigprocmask函数选择性地阻塞或解阻塞一组信号是可能的。这使得我们可以做到 在一段临界区代码执行期间，防止捕获某些信号，以此保护这段代码。</p>
<h1 id="处理sigchld信号">处理SIGCHLD信号</h1>
<p>设置僵死（zombie）状态的目的是维护子进程的信息，以便父进程在以后某个时候获取。 这些信息包括子进程的进程ID、终止状态以及资源利用信息（CPU时间、内存使用量等等）。<br>
如果一个进程终止，而该进程有子进程处于僵死状态，那么它的所有僵死子进程的父进程ID将被重置为1（init进程）。继承这些子进程的init让进程将清理它们（也就是说init进程将wait它们，从而去除它们的僵死状态）。<br>
僵死占用内核中的空间，最终可能导致我们耗尽进程资源<br>
无论何时我们fork子进程都得wait它们，以防它们变成偶死进程。为此我们建立一个俘获 SIGCHLD信号的信号处理函数，在函数体中我们调用wait.</p>
<pre><code>Signal（SIGCHLD, sig_chld）;

1	#include	&quot;unp.h&quot;	.
2	void
3	sig_chld（int signo）
4	{
5	pid_t	pid;
6	int	stat;
7	pid = wait（&amp;stat）;
8	printf（&quot;child %d terminated\n&quot;, pid）；
9	return；
10	}
</code></pre>
<p>具体的各个步骤如下：<br>
（1）	我们键入EOF字符来终止客户。客户TCP发送一个FIN给服务器，服务器响应以一个 ACK。<br>
（2）	收到客户的FIN导致服务器TCP递送一个EOF给<strong>子进程阻塞中的readline</strong>,从而<strong>子进程终止</strong>。<br>
（3）	当SIGCHLD信号递交时，<strong>父进程阻塞于accept调用</strong>。sig_chld函数（信号处理函数） 执行，其wait调用取到子进程的PID和终止状态，随后是printf调用，最后返回。<br>
（4）	既然该信号是在父进程阻塞于慢系统调用（accept）时由父进程捕获的，内核就会使<strong>accept返回一个EINTR错误（被中断的系统调用）。而父进程不处理该错误,于是中止。</strong></p>
<p>本书使用的编程约定之一，我们总是在信号处理函数中显式给出return语句，这么一来，当某个系统调用被我们编写的某个信号处理函数中断时，我们就可以得知该系统调用具体是被哪个信号处理函数的哪个return语句中断的。</p>
<ul>
<li>处理被中断的系统调用<br>
慢系统调用（slow system call）：适用于那些可能 永远阻塞的系统调用。永远阻塞的系统调用是指调用有可能永远无法返回，多数网络支持函数都属于这一类，例如accept。<br>
一个值得注意的例外是磁盘I/O,它们一般都会返回到调用者（假设没有灾难性的硬件故障）。<br>
适用于慢系统调用的基本规则是：当阻塞于某个慢系统调用的一个进程捕获某个信号且相应信号处理函数返回时，该系统调用可能返回一个<strong>EINTR错误</strong>。<br>
设置SA_RESTART标志可以使得内核自动重启调用<br>
了处理被中断的accept,我们把对accept的调用从for循环开始改起</li>
</ul>
<pre><code>for ( ; ; ) (
	clilen = sizeof(cliaddr);
	if ( (connfd =accept(listenfd, (SA *) &amp;cliaddr, &amp;clilen)) &lt; 0) { 
		if (errno == EINTR) 
				continue;	/* back to for() */
		else
				err_sys(&quot;accept error&quot;);
}
</code></pre>
<p>注意！<strong>有一个函数我们不能重启：connect</strong>。如果该函数返回EINTR,我们就不能再次调用它，否则将立即返回一个错误。当connect被一个捕获的 信号中断而且不自动重启时，我们必须调用select来等待连接完成</p>
<h1 id="wait-和-waitpid-函数">wait 和 waitpid 函数</h1>
<p>调用了函数wait:来处理己终止的子进程。</p>
<pre><code>#include &lt;sys/wait.h&gt;
		pid_t wait (int *statloc)；
		pid_t waitpid(pid_t pid, int *statloc, int options);
均返回：若成功则为进程ID,若出错则为。或-1
</code></pre>
<p>函数wait和waitpid均返回两个值：已终止子进程的进程ID号，以及通过指针返回 的子进程终止状态(一个整数)。<br>
我们可以调用三个宏来检查终止状态，并辨别子进程是正常终止、由某个信号杀死还是仅仅由作业控制停止而已。<br>
如果调用wait的进程没有已终止的子进程，不过有一个或多个子进程仍在执行，那么wait 将阻塞到现有子进程第一个终止为止。<br>
waitpid函数就等待哪个进程以及是否阻塞给了我们更多的控制。首先，pid参数允许我们<strong>指定想等待的进程ID</strong>,值-1表示等待第一个终止的子进程。<br>
options参数允许我们指定附加选项。最常用的选项是WNOHANG,它告知内核在<strong>没有已终止子进程时不要阻塞</strong></p>
<ul>
<li>函数wait和waitpid的区别<br>
使用wait的情况下：<br>
假设有5个客户连接到服务器，当客户终止时，所有打开的描述符由内核自动关闭(我们不调用close,仅调用exit),且所有5个<strong>连接基本在同一时刻终止</strong>。这就引发了5个FIN,每个连接一个，它们反过来使服务器 的5个子进程基本在同一时刻终止。这导致差不多在同一时刻有<strong>5个SIGCHLD信号递交给父进程</strong><br>
这是按照预期所有5个子进程都终止了， 如果运行ps,我们将发现其他4个子进程仍然作为<strong>僵死进程</strong>存在着。<br>
原因：同一Unix信号一般是不重复排队的，建立一个信号处理函数并在其中调用wait并不足以防止出现僵死进程。本问题在于：所有5个信号都在信号处理函数执行之前产生，而<strong>信号处理函数只执行一次</strong>。<br>
更严重的是，本问题是不确定的，信号处理函数的执行次数依赖于FIN到达服务器主机的时机，</li>
</ul>
<p>正确的解决办法是调用waitpid而不是wait：<br>
这个版本管用的原因在于：我们在一个循环内调用waitpid,以获取所有已终止于进程的状态。<br>
我们必须指定WNOHANG选项，它告知waitpid在有尚未终止的子进程在运行时<strong>不要阻塞</strong>。<strong>不能在循环内调用wait</strong>,因为没有办法防止wait在正运行的子进程尚有未终止时阻塞。</p>
<p>关于<strong>wait和SIGCHLD信号</strong>注意事项：<br>
其实不一定要在SIGCHLD里调用wait，也可以直接wait<br>
注意！！！wait和信号之间没有关联，我们是捕获到sigchild信号就进行wait处理，而不是说wait本身等待信号进行调用，所以就算不排队，接收到一个信号后就能进行waitpid处理当前所有的僵死进程，而wait只能处理已个，并且不能通过循环wait解决因为会阻塞。<br>
<strong>所以！！！wait和信号无关！哪怕没有信号我也能调用wait和waitpid循环来<br>
清除僵死进程</strong></p>
<pre><code>
</code></pre>
<p>我们的服务器程序的最终版本。它正确处理accept返回的EINTR,并建立一个给所有己终止子进程调用waitpid的信号处理函数<br>
本节的目的是示范我们在网络编程时可能会遇到的三种情况：<br>
(1)	当fork子进程时，必须捕获SIGCHLD信号；<br>
(2)	当捕获信号时，必须处理被中断的系统调用；<br>
(3)	S1GCHLD的信号处理函数必须正确编写，应使用waitpid函数以免留下僵死进程。</p>
<h1 id="accept返回前连接中止">accept返回前连接中止</h1>
<p>accept返回一个非致命的错误，在这种情况下，只需要再次调用accept，典型的是较忙的Web服务器。<br>
三路握手完成从而连接建立之后，客户TCP却发送了一个RST （复位）。在服务器端看来，就在该连接已由TCP排队，等着服务器进程调用accept的时候RST到达。<br>
如何处理这种中止的连接依赖于不同的实现，POSIX 指出返回的 errno 值必须是ECONNABORTED<br>
POSIX作出修改的理由在于：流子系统(streams subsystem)中发生某些致命的协议相关事件时，也会返回EPROTO。要是对于由客户引起的一个 已建立连接的非致命中止也返回同样的错误，那么服务器就不知道该再次调用accept还是不该 了。换成ECONNABORTED错误，服务器就可以忽略它，再次调用accept就行。</p>
<h1 id="服务器进程终止">服务器进程终止</h1>
<p>模拟服务器已连接的子进程终止：<br>
1.找到服务器子进程的进程ID,并执行kill命令杀死它。作为进程终止处理的部分工作， 子进程中所有打开着的描述符都被关闭。这就导致<strong>向客户发送一个FIN</strong>,<br>
2.客户段传输层TCP接收FIN此时响应以一个ACK，同时按照预设客户端应用层应当读入套接字的FIN准备关闭程序并发送客户端的FIN给服务端，但是！！此时进程<strong>拥塞在fgets</strong>上，等待从<strong>终端（也就是键盘！）</strong> 接收一行文本，导致<strong>没法去读取套接字的FIN！</strong><br>
<strong>（这里注意区分有两个流，一个是键盘，一个是网络套接字）</strong><br>
<strong>（但是此时客户端传输层TCP已经收到FIN了并向服务端发送ACK了，同时把状态转化为CLOSE_WAIT，可以用netstat查询，这一切都不需要应用层插手）</strong><br>
3.假设此时客户端接收到键盘的输入文本并发送给服务端，当服务器TCP接收到来自客户的数据时，既然先前打开那个套接字的进程已经终止，于是 响应以一个RST。<br>
4.然而客户进程看不到这个RST,因为它在调用writen后立即调用readline,并且由于接收的FIN,所调用的readline立即返回0 （表示EOF）。我们的客户此时<strong>并未预期收到 EOF</strong>，于是以出错信息&quot;server terminated prematurely”（服务器过早终止）退出。当客户终止时（通过调用err_quit）,它所有打开着的描述符都被关闭。<br>
<strong>（注意这里为什么说未预期收到EOF呢？因为ECHO服务器是假设只能由客户端关闭的，所以客户端一开始没加上接收FIN的处理，比如微信，总不能让腾讯来先发送FIN关闭我手机上的微信吧？）</strong></p>
<p>根本原因：当FIN到达套接字时，客户正阻塞在fgets调用上。客户实际上<strong>在应对两个描述符</strong>--套接字（网络）和用户输入（键盘），它不能单纯阻塞在这两个源中某个特定源的输入上（正如 目前编写的str.cli函数所为），而是应<strong>该阻塞在其中任何一个源的输入上</strong>。事实上这正是 <strong>select和poll这两个函数的目的之一</strong></p>
<p>关于RST：<br>
上述讨论还取决于本例子的时序，客户调用readline既可能发生在服务器的RST 被客户收到之前，也可能发生在收到之后，如果readline发生在<strong>收到RST之前</strong>（如本例子所 示），那么结果是客户得到一个未预期的EOF；如果readline发生在<strong>收到RST之后</strong>，否则结果是由readline返回一个ECONNRESET （connection reset by peer，对方复位连接错误）.<br>
猜测原因：服务端发送RST会导致任何排队的数据都被抛弃，RST优先级最高，会被立即发出去，所以可能导致FIN还在排队的时候就已经被抛弃了<br>
疑惑：那如果FIN比RST先到达接收方会怎么样？</p>
<h1 id="sigpipe-信号">SIGPIPE 信号</h1>
<p>要是客户不理会readline函数返回的错误，反而写入更多的数据到服务器上，那又会发生什么呢？<br>
当一个进程向某个己收到RST的套接字执行写操作时，<strong>（客户端的）内核</strong>向该进程发送一个SIGPIPE信号.该信号的默认行为是终止进程，因此进程必须捕获它以免不情愿地被终止，同时写操作都将返回EPTPE错误。<br>
第一次写操作引发RST,第二次写引发SIGPIPE信号.写一个已接收了FIN的套接字不成问题，但是写一个已接收了 RST的套接字则是一个<strong>错误</strong>.<br>
处理SIGPIPE的建议方法取决于它发生时应用进程想做什么（比如写入log日志）<br>
但是必须意识到，如果使用 了多个套接字，该信号的递交无法告诉我们是哪个套接字出的错。如果我们确实需要知 道是哪个write出了错，那么必须要么不理会该信号，要么从信号处理函数返回后再处 理来自write的EPIPE。</p>
<h1 id="服务器主机崩溃">服务器主机崩溃</h1>
<p>注意区分进程终止和崩溃，模拟前者一般是使用kill信号，模拟后者则需要从网络上断开服务器主机，这样同时也模拟了当客户发送数据时服务器主机不可达的情形(即建立连接后某些中间路由器不工作)。</p>
<p>客户端发送数据后，等待服务器的ACK，因而阻塞在readline调用上，假设服务器主机己崩溃，从而对客户的数据分节根本没有响应，那么所返回的错误是 ETIMEDOUT（从readline调用返回的）<br>
然而如果某个中间路由器判定服务器主机已不可达，从而响应以一个“destination unreachable&quot;(目的地不可达)ICMP消息，那么所返回的错误是EHOSTUNREACH或ENETUNREACH。</p>
<p>如果希望更快地检测出这种情况，可以对readline调用设置一个超时</p>
<p>上述情形只有在我们向服务器主机发送数据时才能检测出它已经崩溃。如果希望不主动向它发送数据也能检测出服务器主机的崩溃，那么需要采用另外一个技术--SO_KEEPALIVE套接字选项。</p>
<h1 id="服务器主机崩溃后重启">服务器主机崩溃后重启</h1>
<p>模拟这种情形的最简单方法就是：先建立连接，再从网络上 函 断开服务器主机，将它关机后再重新启动，最后把它重新连接到网络中。<br>
处理方法重点在于：我们<strong>不想客户知道服务器主机的关机</strong></p>
<p>普通情况下：<br>
(1)	当服务器主机崩溃后重启时，它的TCP丢失了崩溃前的所有连接倍息，因此服务器TCP 对于所收到的来自客户的数据分节响应以一个RST。<br>
(2)	当客户TCP收到该RST时，客户正阻塞于readline调用，导致该调用返回ECONNRESET 错误。</p>
<h1 id="服务器主机关机">服务器主机关机</h1>
<p>当服务器子进程终止时，它的所 有打开着的描述符都被关闭，随后发生的步骤与服务器进程终止那一节一样，我们必须在客户中使用select或poll函数，使得服务器进程的终止一经发生，客户就能检测到。</p>
<h1 id="tcp程序例子小结">TCP程序例子小结</h1>
<p>在TCP客户和服务器可以彼此通信之前，每一端都得指定连接的<strong>套接字对：本地IP地址、 本地端口、外地IP地址、外地端口。</strong><br>
<img src="https://lixin-ee.github.io//post-images/1579005277140.png" alt=""><br>
<img src="https://lixin-ee.github.io//post-images/1579005290499.png" alt=""><br>
如果服务器在一个多宿主机上绑定通配IP地址，那么它可以在连接建立后通过调用getsockname来确定本地IP地址。两个外地值则由accept调用返回给服务器。</p>
<h1 id="数据格式粘包与分包">数据格式（粘包与分包）</h1>
<p>在我们的例子中，服务器从不检查来自客户的请求。它只管读入直到换行符（包括换行符） 的所有数据，把它发回给客户，所搜索的仅仅是换行符<br>
这只是一个例外，而不是通常规则， 一般来说，我们必须关心在客广和服务器之间进行<strong>交换的数据的格式</strong>。</p>
<p><strong>注意！</strong><br>
这个格式<strong>和TCP无关</strong>，是<strong>应用层的格式</strong>，TCP和IP的分片操作应用层是看不到的，TCP是<strong>数据流</strong>，保证交给应用层的数据是<strong>连续</strong>且无误的，但是应用层需要<strong>自己切分读到的数据</strong>，比如一个聊天软件，一个人说的话是长度不一并且连续到达的，应用层必须自己制定好格式使得能够区分数据直接的间隔并能够重新组装语句。</p>
<p>数据格式需要考虑字节序，，特别是二进制结构数据，网络字节序默认是大端序<br>
二进制结构容易存在以下问题<br>
(1)	不同的实现以不同的格式存储二进制数。例如大端字节序 与小端字节序。<br>
(2)	不同的实现在存储相同的C数据类型上可能存在差异。举例来说，大多数32位Unix系统 使用32位表示长整数，而64位系统却典型地使用64位来表示同样的数据类型，对于 short, int或long等整数类型，它们各自的大小没有确定的保证。<br>
(3)	不同的实现给结构打包的方式存在差异，取决于各种数据类型所用的位数以及机器的<strong>对齐限制</strong>。因此，穿越套接字传送二进制结构绝不是明智的。</p>
<p>解决这种数据格式问题有两个常用方法。<br>
(1)	把所有的<strong>数值数据作为文本串</strong>来传递，当然这里假设客广和服务 器主机具有相同的字符集。<br>
(2)	<strong>显式定义</strong>所支持数据类型的二进制格式(位数、大端或小端字节序)，并以这样的格式 在客户与服务器之间传递所有数据。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Design 146. LRU缓存机制[中等][未做出]]]></title>
        <id>https://lixin-ee.github.io//post/design-146-lru-huan-cun-ji-zhi-zhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/design-146-lru-huan-cun-ji-zhi-zhong-deng-wei-zuo-chu">
        </link>
        <updated>2020-01-13T01:08:00.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。<br>
获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>
写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。<br>
进阶:<br>
你是否可以在 O(1) 时间复杂度内完成这两种操作？<br>
示例:<br>
LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );<br>
cache.put(1, 1);<br>
cache.put(2, 2);<br>
cache.get(1);       // 返回  1<br>
cache.put(3, 3);    // 该操作会使得密钥 2 作废<br>
cache.get(2);       // 返回 -1 (未找到)<br>
cache.put(4, 4);    // 该操作会使得密钥 1 作废<br>
cache.get(1);       // 返回 -1 (未找到)<br>
cache.get(3);       // 返回  3<br>
cache.get(4);       // 返回  4<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/lru-cache<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>【未做出】<br>
最难的肯定就是选定一个基础数据结构了<br>
1.首先必须存储一对pair，然后最重要的是必须得存储某个值或者保持某个顺序，使得容量达到上限时能够删除最少使用的数据<br>
2.然后看进阶，难点在于两个操作都要常数时间，常数时间的查找只能用哈希表，然后难点就在于常数时间的插入，这个似乎也只能用哈希表<br>
3.对于最少使用这个问题，我打算先使用两个哈希表来初步解决这个问题，一个属于历史使用表，一个属于插入表。优先牺牲插入表的元素，但是我没想好全部都在历史使用表后怎么判断最少使用的元素。<br>
艹了，理解错了，是删除掉最老的元素？</p>
<p>看题解：<br>
1.其实我实在是很疑惑示例中为何4插入时为何删除1而不是删除3？<br>
2.我忘了判断key是否存在了，已存在的话需要删除再重新添加<br>
3.list是双向链表，forward_list才是单向链表<br>
4.理解erase很重要，不需要自己接驳前后元素，函数会自动删除元素后接驳<br>
5.erase等函数只接受迭代器，主要list等链表的迭代器不会失效，但是vector、deque的会失效，原因就在于是否是连续存储，所以这道题里很适合用list的迭代器</p>
<pre><code>class LRUCache {
public:
    int cap;
    list&lt;pair&lt;int,int&gt;&gt; cache;
    unordered_map&lt;int,list&lt;pair&lt;int,int&gt;&gt;::iterator&gt; cache_map;
    LRUCache(int capacity) {
        this-&gt;cap=capacity;
    }
    
    int get(int key) {
        if(cache_map.count(key)==0)
            return -1;
        auto temp=*cache_map[key];
        cache.erase(cache_map[key]);
        cache.push_front(temp);
        cache_map[key]=cache.begin();
        return temp.second;
    }
    
    void put(int key, int value) {
        //注意旧有数据也必须先判断是否存在，存在的话要提到链表链首
        if(cache_map.count(key)){   
            cache.erase(cache_map[key]);
            cache_map.erase(key);
        }
        //先判断容量
        if(getSize()&gt;=cap){
            auto del=cache.back();
            cache_map.erase(del.first);
            cache.pop_back();
        }
        cache.push_front({key,value});
        cache_map[key]=cache.begin();
        return;      
    }
    
    int getSize(){
       return cache.size(); 
    }
};
</code></pre>
<p>来看看网友题解详解：<br>
三、LRU 算法设计<br>
分析上面的操作过程，要让 put 和 get 方法的时间复杂度为 O(1)，我们可以总结出 cache 这个数据结构必要的条件：查找快，插入快，删除快，有顺序之分。<br>
因为显然 cache 必须有顺序之分，以区分最近使用的和久未使用的数据；而且我们要在 cache 中查找键是否已存在；如果容量满了要删除最后一个数据；每次访问还要把数据插入到队头。<br>
那么，什么数据结构同时符合上述条件呢？哈希表查找快，但是数据无固定顺序；链表有顺序之分，插入删除快，但是查找慢。所以结合一下，形成一种新的数据结构：哈希链表。<br>
LRU 缓存算法的核心数据结构就是哈希链表，双向链表和哈希表的结合体。这个数据结构长这样：<br>
<img src="https://lixin-ee.github.io//post-images/1578878403164.png" alt=""><br>
思想很简单，就是借助哈希表赋予了链表快速查找的特性嘛：可以快速查找某个 key 是否存在缓存（链表）中，同时可以快速删除、添加节点。回想刚才的例子，这种数据结构是不是完美解决了 LRU 缓存的需求<br>
也许读者会问，为什么要是双向链表，单链表行不行？另外，既然哈希表中已经存了 key，为什么链表中还要存键值对呢，只存值不就行了<br>
想的时候都是问题，只有做的时候才有答案。这样设计的原因，必须等我们亲自实现 LRU 算法之后才能理解，所以我们开始看代码吧<br>
四、代码实现<br>
很多编程语言都有内置的哈希链表或者类似 LRU 功能的库函数，但是为了帮大家理解算法的细节，我们用 Java 自己造轮子实现一遍 LRU 算法。<br>
首先，我们把双链表的节点类写出来，为了简化，key 和 val 都认为是 int 类型：</p>
<pre><code>Java
class Node {
    public int key, val;
    public Node next, prev;
    public Node(int k, int v) {
        this.key = k;
        this.val = v;
    }
}
</code></pre>
<p>然后依靠我们的 Node 类型构建一个双链表，实现几个需要的 API（这些操作的时间复杂度均为 O(1))：</p>
<pre><code>class DoubleList {  
    private Node head, tail; // 头尾虚节点
    private int size; // 链表元素数

    public DoubleList() {
        head = new Node(0, 0);
        tail = new Node(0, 0);
        head.next = tail;
        tail.prev = head;
        size = 0;
    }

    // 在链表头部添加节点 x
    public void addFirst(Node x) {
        x.next = head.next;
        x.prev = head;
        head.next.prev = x;
        head.next = x;
        size++;
    }

    // 删除链表中的 x 节点（x 一定存在）
    public void remove(Node x) {
        x.prev.next = x.next;
        x.next.prev = x.prev;
        size--;
    }
    
    // 删除链表中最后一个节点，并返回该节点
    public Node removeLast() {
        if (tail.prev == head)
            return null;
        Node last = tail.prev;
        remove(last);
        return last;
    }
    
    // 返回链表长度
    public int size() { return size; }
}
</code></pre>
<p>到这里就能回答刚才“为什么必须要用双向链表”的问题了，因为我们需要删除操作。删除一个节点不光要得到该节点本身的指针，也需要操作其前驱节点的指针，而双向链表才能支持直接查找前驱，保证操作的时间复杂度 O(1)。<br>
有了双向链表的实现，我们只需要在 LRU 算法中把它和哈希表结合起来即可。我们先把逻辑理清楚：</p>
<pre><code>// key 映射到 Node(key, val)
HashMap&lt;Integer, Node&gt; map;
// Node(k1, v1) &lt;-&gt; Node(k2, v2)...
DoubleList cache;

int get(int key) {
    if (key 不存在) {
        return -1;
    } else {        
        将数据 (key, val) 提到开头；
        return val;
    }
}

void put(int key, int val) {
    Node x = new Node(key, val);
    if (key 已存在) {
        把旧的数据删除；
        将新节点 x 插入到开头；
    } else {
        if (cache 已满) {
            删除链表的最后一个数据腾位置；
            删除 map 中映射到该数据的键；
        } 
        将新节点 x 插入到开头；
        map 中新建 key 对新节点 x 的映射；
    }
}
</code></pre>
<p>如果能够看懂上述逻辑，翻译成代码就很容易理解了：</p>
<pre><code>class LRUCache {
    // key -&gt; Node(key, val)
    private HashMap&lt;Integer, Node&gt; map;
    // Node(k1, v1) &lt;-&gt; Node(k2, v2)...
    private DoubleList cache;
    // 最大容量
    private int cap;
    
    public LRUCache(int capacity) {
        this.cap = capacity;
        map = new HashMap&lt;&gt;();
        cache = new DoubleList();
    }
    
    public int get(int key) {
        if (!map.containsKey(key))
            return -1;
        int val = map.get(key).val;
        // 利用 put 方法把该数据提前
        put(key, val);
        return val;
    }
    
    public void put(int key, int val) {
        // 先把新节点 x 做出来
        Node x = new Node(key, val);
        
        if (map.containsKey(key)) {
            // 删除旧的节点，新的插到头部
            cache.remove(map.get(key));
            cache.addFirst(x);
            // 更新 map 中对应的数据
            map.put(key, x);
        } else {
            if (cap == cache.size()) {
                // 删除链表最后一个数据
                Node last = cache.removeLast();
                map.remove(last.key);
            }
            // 直接添加到头部
            cache.addFirst(x);
            map.put(key, x);
        }
    }
}
</code></pre>
<p>这里就能回答之前的问答题“为什么要在链表中同时存储 key 和 val，而不是只存储 val”，注意这段代码：</p>
<pre><code>
if (cap == cache.size()) {
    // 删除链表最后一个数据
    Node last = cache.removeLast();
    map.remove(last.key);
}
</code></pre>
<p>当缓存容量已满，我们不仅仅要删除最后一个 Node 节点，还要把 map 中映射到该节点的 key 同时删除，而这个 key 只能由 Node 得到。如果 Node 结构中只存储 val，那么我们就无法得知 key 是什么，就无法删除 map 中的键，造成错误。</p>
<p>另外，C++ 可以利用迭代器更方便实现 LRU 算法，有兴趣的读者可以看看代码：</p>
<pre><code>class LRUCache {
private:
    int cap;
    // 双链表：装着 (key, value) 元组
    list&lt;pair&lt;int, int&gt;&gt; cache;
    // 哈希表：key 映射到 (key, value) 在 cache 中的位置
    unordered_map&lt;int, list&lt;pair&lt;int, int&gt;&gt;::iterator&gt; map;
public:
    LRUCache(int capacity) {
        this-&gt;cap = capacity; 
    }
    
    int get(int key) {
        auto it = map.find(key);
        // 访问的 key 不存在
        if (it == map.end()) return -1;
        // key 存在，把 (k, v) 换到队头
        pair&lt;int, int&gt; kv = *map[key];
        cache.erase(map[key]);
        cache.push_front(kv);
        // 更新 (key, value) 在 cache 中的位置
        map[key] = cache.begin();
        return kv.second; // value
    }
    
    void put(int key, int value) {

        /* 要先判断 key 是否已经存在 */ 
        auto it = map.find(key);
        if (it == map.end()) {
            /* key 不存在，判断 cache 是否已满 */ 
            if (cache.size() == cap) {
                // cache 已满，删除尾部的键值对腾位置
                // cache 和 map 中的数据都要删除
                auto lastPair = cache.back();
                int lastKey = lastPair.first;
                map.erase(lastKey);
                cache.pop_back();
            }
            // cache 没满，可以直接添加
            cache.push_front(make_pair(key, value));
            map[key] = cache.begin();
        } else {
            /* key 存在，更改 value 并换到队头 */
            cache.erase(map[key]);
            cache.push_front(make_pair(key, value));
            map[key] = cache.begin();
        }
    }
};
</code></pre>
<p>至此，你应该已经掌握 LRU 算法的思想和实现了，很容易犯错的一点是：处理链表节点的同时不要忘了更新哈希表中对节点的映射。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 142. 环形链表 II[中等][未做出]]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-142-huan-xing-lian-biao-iizhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-142-huan-xing-lian-biao-iizhong-deng-wei-zuo-chu">
        </link>
        <updated>2020-01-11T11:51:18.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<br>
为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。<br>
说明：不允许修改给定的链表。<br>
示例 1：<br>
输入：head = [3,2,0,-4], pos = 1<br>
输出：tail connects to node index 1<br>
解释：链表中有一个环，其尾部连接到第二个节点。<br>
示例 2：<br>
输入：head = [1,2], pos = 0<br>
输出：tail connects to node index 0<br>
解释：链表中有一个环，其尾部连接到第一个节点。<br>
示例 3：<br>
输入：head = [1], pos = -1<br>
输出：no cycle<br>
解释：链表中没有环。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/linked-list-cycle-ii<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>最简单的就是用哈希表了 然后用hash表的时候有点翻车，把指针类型写成了*ListNode了，应该是ListNode*<br>
然后就是考虑双指针法了，检查是否有环是很简单，但是最后停留的位置是未知的。我觉得应该引入第三个指针<br>
看题解去！<br>
哇好心痛，其实就差一步我就做出来的了，就主要是没了解到一个重点 入环点在的位置一定是 m+aN，此时快指针和慢指针的差刚好（b-a）N，同时也是慢指针的值，等于慢指针总共走的路程还是环长（虽然此时不在环上），离入环点还差m步（理解一下m+aN和（b-a）N之间的差别），那么我引入的第三个指针（也可以用fast代替）刚好可以从头指针走m步<br>
好气啊！</p>
<p>实现注意点：<br>
1.两个指针应该从一个虚拟头节点开始而不是从head开始，否则一开始走过的路程就是1了，所以一般定义fast是head-&gt;next，slow就是head，等于预先走了一步<br>
2.fast的判断和两次连续next很重要<br>
2.又忘了判断空链表了。。。</p>
<pre><code>class Solution {
public:

    ListNode *detectCycle(ListNode *head) {
        if(head==NULL)return NULL;
        ListNode *fast=head-&gt;next,*slow=head;
        while(fast!=slow){
            if(fast!=NULL&amp;&amp;fast-&gt;next!=NULL)
                fast=fast-&gt;next-&gt;next; //注意判断条件和两次连续next，没必要分开两次判断next
            else
                return NULL;
            slow=slow-&gt;next;
        }
        fast=head;
        slow=slow-&gt;next;//注意这里，因为fast=head;相当于提前走了一步
        while(fast!=slow)
            fast=fast-&gt;next,slow=slow-&gt;next;
        return slow;     
				/*哈希表解法
        unordered_set&lt;ListNode*&gt; List_set;
        ListNode *cur=head;
        while(true)
            if(cur==NULL)
                return NULL;
            else if(List_set.count(cur))
                return cur;
            else{
                List_set.insert(cur);
                cur=cur-&gt;next;
            }
        */
    }
};
</code></pre>
<p>然后来看看官方题解和网友题解：</p>
<blockquote>
<p>方法 1：哈希表<br>
想法<br>
如果我们用一个 Set 保存已经访问过的节点，我们可以遍历整个列表并返回第一个出现重复的节点。<br>
算法<br>
首先，我们分配一个 Set 去保存所有的列表节点。我们逐一遍历列表，检查当前节点是否出现过，如果节点已经出现过，那么一定形成了环且它是环的入口。否则如果有其他点是环的入口，我们应该先访问到其他节点而不是这个节点。其他情况，没有成环则直接返回 null 。<br>
算法会在遍历有限个节点后终止，这是因为输入列表会被分成两类：成环的和不成环的。一个不成欢的列表在遍历完所有节点后会到达 null - 即链表的最后一个元素后停止。一个成环列表可以想象成是一个不成环列表将最后一个 null 元素换成环的入口。<br>
如果 while 循环终止，我们返回 null 因为我们已经将所有的节点遍历了一遍且没有遇到重复的节点，这种情况下，列表是不成环的。对于循环列表， while 循环永远不会停止，但在某个节点上， if 条件会被满足并导致函数的退出。</p>
</blockquote>
<pre><code>public class Solution {
    public ListNode detectCycle(ListNode head) {
        Set&lt;ListNode&gt; visited = new HashSet&lt;ListNode&gt;();

        ListNode node = head;
        while (node != null) {
            if (visited.contains(node)) {
                return node;
            }
            visited.add(node);
            node = node.next;
        }

        return null;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)<br>
不管是成环还是不成环的输入，算法肯定都只会访问每个节点一次。对于非成环列表这是显而易见的，因为第 n 个节点指向 null ，这会让循环退出。对于循环列表， if 条件满足时会导致函数的退出，因为它指向了某个已经访问过的节点。两种情况下，访问的节点数最多都是 n 个，所以运行时间跟节点数目成线性关系。<br>
空间复杂度：O(n)<br>
不管成环或者不成欢的输入，我们都需要将每个节点插入 Set 中一次。两者唯一的区别是最后访问的节点后是 null 还是一个已经访问过的节点。因此，由于 Set 包含 n 个不同的节点，所需空间与节点数目也是线性关系的。</p>
</blockquote>
<blockquote>
<p>方法 1：Floyd<br>
解题思路：<br>
这类链表题目一般都是使用双指针法解决的，例如寻找距离尾部第K个节点、寻找环入口、寻找公共尾部入口等。<br>
算法流程：<br>
双指针第一次相遇： 设两指针 fast，slow 指向链表头部 head，fast 每轮走 22 步，slow 每轮走 11 步；</p>
</blockquote>
<blockquote>
<p>第一种结果： fast 指针走过链表末端，说明链表无环，直接返回 null；<br>
TIPS: 若有环，两指针一定会相遇。因为每走 1 轮，fast 与 slow 的间距 +1，fast 终会追上 slow；<br>
第二种结果： 当fast == slow时， 两指针在环中 第一次相遇 。下面分析此时fast 与 slow走过的 步数关系 ：<br>
设链表共有 a+b 个节点，其中 链表头部到链表入口 有 a 个节点（不计链表入口节点）， 链表环 有 b 个节点（这里需要注意，a 和 b 是未知数，例如图解上链表 a=4 , b=5）；设两指针分别走了f，s 步，则有：<br>
fast 走的步数是slow步数的 2 倍，即 f=2s；（解析： fast 每轮走 2 步）<br>
fast 比 slow多走了 n 个环的长度，即f=s+nb；（ 解析： 双指针都走过 a 步，然后在环内绕圈直到重合，重合时 fast 比 slow 多走 环的长度整数倍 ）；<br>
以上两式相减得：f=2nb，s=nb，即fast和slow 指针分别走了 2n，n个环的周长 （注意： n 是未知数，不同链表的情况不同）。<br>
目前情况分析：<br>
如果让指针从链表头部一直向前走并统计步数k，那么所有 走到链表入口节点时的步数 是：k=a+nb（先走 a 步到入口节点，之后每绕 1 圈环（ b 步）都会再次到入口节点）。<br>
而目前，slow 指针走过的步数为 nb 步。因此，我们只要想办法让 slow 再走 a 步停下来，就可以到环的入口。<br>
但是我们不知道 a 的值，该怎么办？依然是使用双指针法。我们构建一个指针，此指针需要有以下性质：此指针和slow 一起向前走 a 步后，两者在入口节点重合。那么从哪里走到入口节点需要 a 步？答案是链表头部head。<br>
双指针第二次相遇：<br>
slow指针位置不变 ，将fast指针重新 指向链表头部节点 ；slow和fast同时每轮向前走 1 步；<br>
TIPS：此时 f=0，s=nb ；<br>
当 fast 指针走到f=a 步时，slow 指针走到步s=a+nb，此时 两指针重合，并同时指向链表环入口 。<br>
返回slow指针指向的节点。<br>
复杂度分析：<br>
时间复杂度 O(N) ：第二次相遇中，慢指针须走步数 a&lt;a+b；第一次相遇中，慢指针须走步数a+b−x&lt;a+b，其中 x 为双指针重合点与环入口距离；因此总体为线性复杂度；<br>
空间复杂度 O(1) ：双指针使用常数大小的额外空间。</p>
</blockquote>
<pre><code>public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast = head, slow = head;
        while (true) {
            if (fast == null || fast.next == null) return null;
            fast = fast.next.next;
            slow = slow.next;
            if (fast == slow) break;
        }
        fast = head;
        while (slow != fast) {
            slow = slow.next;
            fast = fast.next;
        }
        return fast;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Linux基础] 源码编译与链接 （鸟哥Linux第二十一章）]]></title>
        <id>https://lixin-ee.github.io//post/linux-ji-chu-ruan-jian-an-zhuang-yuan-shi-ma-yu-tarball-niao-ge-linux-di-er-shi-yi-zhang</id>
        <link href="https://lixin-ee.github.io//post/linux-ji-chu-ruan-jian-an-zhuang-yuan-shi-ma-yu-tarball-niao-ge-linux-di-er-shi-yi-zhang">
        </link>
        <updated>2020-01-11T07:11:12.000Z</updated>
        <content type="html"><![CDATA[<p>了解如何将开放源码的程序设计、加入函式库的原理、透过编译而成为可以执行 的 binary program，最后使用该执行档</p>
<p>注意，与Windows不同，Linux 上面的软件几乎都是经过 GPL 的授权，所以每个软件几乎均提供源代码， 并且你可以自行修改该程序代码，以符合你个人的需求</p>
<p>Linux 系统上真正认识的可执行文件其实是二进制文件 ( binary program)<br>
例如，shell scripts 只是利用 shell (例如 bash) 这支程序的功能进行一些判断式，而最终执行的除了 bash 提供的功能外，仍是呼叫一些已经编译好的二进制程序来执行<br>
可以用file命令来判断，如果是 binary 而且是可以执行的时候，他就会显示执行文件类别 (ELF 64-bit LSB executable)， 同时会说明是否使用<strong>动态函式库 (shared libs)</strong>，而如果是一般的 script ，那他就会显示 出 text executables 之类的字样</p>
<p>vim编写的程序代码文件其实就是一般的纯 文本档。 在完成这个原始码文件的编写之后，再来就是要将这个文件『编译』成为操作系统看的懂 得 binary program 啰，而要编译自然就需要『编译程序』来动作， 经过编译程序的编译与连结之后， 就会产生一支可以执行的 binary program</p>
<p>编译的过程当中还会产生所谓的目标文件 (Object file)<br>
程序当中『引用、呼叫』 其他的外部子程序，或者是利用其他软件库提供的『函数功能』，这个时候，我们就必须要在编译的过程当中， 将该函式库加进去<br>
最后编译程序就可以将所有的程序代码与函式库作一个<strong>连结 (Link)</strong> 以产生正确的执行档</p>
<p>开放源码：就是程序代码，写给人类看的程序语言，但机器并不认识，所以无法执行；<br>
编译程序：将程序代码转译成为机器看得懂的语言，就类似翻译者的角色；<br>
可执行文件：经过编译程序变成二进制程序后，机器可以执行的文件。</p>
<ul>
<li>make 与 configure<br>
使用类似 gcc 的编译程序来进行编译的过程并不简单，大型项目可能会有成百上千个源文件和头文件，需要使用 make 这个指令的相关功能来进行编译过程的指令简化<br>
当执行 make 时，make 会在当时的目录下搜寻 Makefile(or makefile) 这个文本文件<br>
Makefile 里面则记录了原始码<strong>如何编译</strong>的详细信息， make 会自动的判别原始码<strong>是否经过变动</strong>了，而自动更新执行档<br>
通常软件开发商都会写一支<strong>侦测程序configure或者是config</strong>来侦测用户的作业环境， 以及该作业环境是否有软件开发商所需要的其他功能，该侦测程序侦 测完毕后，就会主动的建立这个Makefile的规则文件</li>
</ul>
<p>侦测程序会侦测的数据大约有底下这些：<br>
是否有适合的编译程序可以编译本软件的程序代码；<br>
是否已经存在本软件所需要的函式库，或其他需要的相依软件；<br>
操作系统平台是否适合本软件，包括 Linux 的核心版本；<br>
核心的表头定义档 (header include) 是否存在 (驱动程序必须要的侦测)。<br>
<img src="https://lixin-ee.github.io//post-images/1578728268148.png" alt=""></p>
<p>所以，我们无法在 CentOS 7.x 上面编译出 binary program 后，还将他拿到 SuSE 上面执行，这个动作通常是不可能成功</p>
<ul>
<li>Tarball<br>
所谓的 Tarball 文件，其实就是将软件的所有原始码文件先以 tar 打包（注意不是压缩），然后再以压缩技术来压缩<br>
通常最常见的就是以 gzip 来压缩了。因为利用了 tar 与 gzip 的功能，所以 tarball 文件一般的扩展 名就会写成 * .tar.gz 或者是简写为 * .tgz，相应地 bzip2 与 xz 的后缀名也会变成 * .tar.bz2, * .tar.xz 之类</li>
</ul>
<p>安装压缩包通常就会有：<br>
源代码文件；<br>
侦测程序文件 (可能是 configure 或 config 等檔名)；<br>
本软件的简易说明与安装说明 (INSTALL 或 README)。</p>
<ul>
<li>编译简单范例<br>
<code>[root@study ~]# gcc hello.c</code><br>
如果我们直接以 gcc 编译原始码，并且没有加上任何参数，则执行档的档名会被 自动设定为 a.out 这个文件名<br>
<code>[root@study ~]# ./a.out</code><br>
执行文件时在文件名前面一定要加上./</li>
</ul>
<pre><code>[root@study ~]# gcc -c hello.c
[root@study ~]# gcc -o hello hello.o
</code></pre>
<p>利用 hello.o 这个目标文件制作出一个名为 hello 的执行文件</p>
<p>当我们有多个.c源文件的时候</p>
<pre><code>[root@study ~]# gcc - c thanks.c thanks_2.c
[root@study ~]# gcc -o thanks thanks.o thanks_2.o
</code></pre>
<p>制作目标文件的原因，源文件一般并非仅只有一个文件，无法直接进行编译，需要先产生目标文件，然后再以连结制作成为<strong>单个 binary 可执行文件</strong>。另外， 如果有一天，你更新了 thanks_2.c 这个文件的内容，则你只要<strong>重新编译</strong>thanks_2.c 来产生新的 thanks_2.o ，然后再以连结制作出新的 binary 可执行文件即可，而<strong>不必重新编译</strong>其他没有更动过的源文件。</p>
<p>-O选项： 产生优化的参数<br>
-Wall 为产生更详细的编译过程信息。警告讯息 (warning) 不用理会也没有关系</p>
<ul>
<li>呼叫外部函式库：加入连结的函式库<br>
.h头文件都可以看作是外部库library<br>
对于.h头文件，gcc会直接抓取，只需要在源文件中声明，不需要在命令行中加上</li>
</ul>
<p>而对于非.h头文件的数据库<br>
编译时加入额外函式库连结的方式</p>
<pre><code>[root@study ~]# gcc sin.c -lm -L/lib -L/lib64  #重点在 -lm 
[root@study ~]# ./a.out 
</code></pre>
<p>-lm参数：<br>
-l ：是『加入某个函式库(library)』的意思，<br>
-m ：则是 libm.so 这个函式库，其中， lib 与扩展名(.a 或 .so)不需要写<br>
所以 -lm 表示使用 libm.so (或 libm.a) 这个函式库的意思～至于那个 -L 后面接的路径表示： 『函式库 libm.so 请到 /lib 或 /lib64 里面搜寻』</p>
<p>[root@study ~]# gcc sin.c -lm -I/usr/include<br>
定义出要 include 文件放置的目录，-I/path后面接的路径( Path )就是设定要去搜寻相关的 include 文件的目录</p>
<ul>
<li>gcc 的简易用法 ( 编译、参数与链结)<br>
仅将原始码编译成为目标文件，并不制作链接等功能：<br>
<code>[root@study ~]# gcc -c hello.c</code><br>
会自动的产生 hello.o 这个文件，但是并不会产生 binary 执行档。</li>
</ul>
<p>在编译的时候，依据作业环境给予优化执行速度<br>
<code>[root@study ~]# gcc -O hello.c -c</code><br>
会自动的产生 hello.o 这个文件，并且进行优化</p>
<p>在进行 binary file 制作时，将连结的函式库与相关的路径填入<br>
<code>[root@study ~]# gcc sin.c -lm -L/lib -I/usr/include</code><br>
这个指令较常下达在最终连结成 binary file 的时候，<br>
-lm 指的是 libm.so 或 libm.a 这个函式库文件；<br>
-L 后面接的路径是刚刚上面那个函式库的搜寻目录；<br>
-I 后面接的是原始码内的 include 文件之所在目录。</p>
<p>将编译的结果输出成某个特定档名<br>
<code>[root@study ~]# gcc -o hello hello.c</code><br>
-o 后面接的是要输出的 binary file 檔名</p>
<p>在编译的时候，输出较多的讯息说明<br>
<code>[root@study ~]# gcc -o hello hello.c -Wall</code><br>
加入 -Wall 之后，程序的编译会变的较为严谨一点，所以警告讯息也会显示出来！</p>
<p>另外，我们通常称 -Wall 或者 -O 这些非必要的参数为旗标 (FLAGS)，使用的是 C 程序语言时也会简称这些旗标为 CFLAGS</p>
<ul>
<li>用 make  进行宏编译<br>
makefile 一次性完成编译和链接等工作</li>
</ul>
<p>[root@study ~]#  vim makefile<br>
main: main.o haha.o sin_value.o cos_value.o<br>
gcc -o main main.o haha.o sin_value.o cos_value.o -lm<br>
注意，第二行前面有一个tab缩进</p>
<p>疑惑：『如果建立一个 shell script 来将上面的所有动作都按顺序集结在一起，不是具有同样的效果吗』<br>
<strong>注意！效果当然不一样</strong>，以上面的测试为例，我们仅写出 main 需要的目标文件，结果 make会主动的去判断每个目标文件相关的原始码文件，并直接予以编译，最后再直接进行连结的动作，<strong>同时！</strong> 如果我们更动过某些原始码文件，则 make 也可以<strong>主动判断</strong>哪一个原始码与相关的目标文件文件有更新过， 并仅更新该文件，可大大的节省编译时间</p>
<p>make有这些好处：<br>
简化编译时所需要下达的指令；<br>
若在编译完成之后，修改了某个原始码文件，则 make <strong>仅会针对被修改</strong>了的文件进行编译，其他的object file不会被更动；<br>
最后可以依照<strong>相依性</strong>来更新 (update) 执行档。</p>
<ul>
<li>makefile的基本语法与变量</li>
</ul>
<pre><code>目标(target): 目标文件 1 目标文件 2
&lt;tab&gt; gcc -o 欲建立的执行文件 目标文件 1 目标文件 2
</code></pre>
<p>目标 (target) 就是我们想要建立的信息，而目标文件就是具有相关性的 object files ，那建立执行文件的语法就是以 tab按键开头的那一行！特别留意，『命令行必须要以 tab 按键作为开头』才行<br>
在 makefile 当中的 # 代表批注；<br>
tab 需要在命令行 (例如 gcc 这个编译程序指令) 的第一个字符；<br>
目标 (target) 与相依文件(就是目标文件)之间需以『:』隔开。</p>
<p>Makefile里面可以有多个动作<br>
例如</p>
<pre><code>main: main.o haha.o sin_value.o cos_value.o
		gcc -o main main.o haha.o sin_value.o cos_value.o -lm
clean:
		rm -f main main.o haha.o sin_value.o cos_value.o
</code></pre>
<p><code>[root@study ~]# make clean &lt;==就是这里！透过 make 以 clean 为目标</code><br>
我们的 makefile 里面就具有至少两个目标，分别是 main 与 clean ，如果我们想要建立main 的话，输入『make main』，如果想要清除有的没的，输入『make clean』即可，而如果想要<strong>先清除目标文件再编译 main 这</strong>个程序的话，就可以这样输入：『make clean main』</p>
<p>Makefile中可以使用变量<br>
例如：</p>
<pre><code>[root@study ~]#  vi makefile
LIBS = -lm
OBJS = main.o haha.o sin_value.o cos_value.o
main: ${OBJS}
		gcc -o main ${OBJS} ${LIBS}
clean:
		rm -f main ${OBJS}
</code></pre>
<p>与 bash shell script 的语法有点不太相同，变量的基本语法为：</p>
<ol>
<li>变量与变量内容以『=』隔开，同时两边可以具有空格；</li>
<li>变量左边不可以有 tab ，例如上面范例的第一行 LIBS 左边不可以是tab；</li>
<li>变量与变量内容在『=』两边不能具有『:』；</li>
<li>在习惯上，变数最好是以『大写字母』为主；</li>
<li>运用变量时，以 ${变量} 或 $(变量) 使用；</li>
<li>在该 shell 的<strong>环境变量</strong>是可以被套用的，例如提到的 CFLAGS 这个变数！</li>
<li>在指令列模式也可以给予变量。<br>
由于 gcc 在进行编译的行为时，会主动的去读取 CFLAGS 这个环境变量，所以，你可以直接在 shell定义出这个环境变量，也可以在 makefile 文件里面去定义，更可以在指令列当中给出<br>
<code>[root@study ~]# CFLAGS=&quot;-Wall&quot; make clean main</code><br>
这个动作在上 make 进行编译时，会去取用 CFLAGS 的变量内容<br>
万一这个CFLAGS 的内容在指令列与 makefile 里面并不相同，即出现同名变量的时候，环境变量取用的规则是这样的：</li>
<li>make 指令列后面加上的环境变量为优先；</li>
<li>makefile 里面指定的环境变量第二；</li>
<li>shell 原本具有的环境变量第三。<br>
此外，还有一些特殊的变量需要了解的喔：<br>
$@：代表目前的目标(target)<br>
例如</li>
</ol>
<pre><code>[root@study ~]#  vi makefile
LIBS = -lm
OBJS = main.o haha.o sin_value.o cos_value.o
CFLAGS = -Wall
main: ${OBJS}
		gcc -o $@ ${OBJS} ${LIBS} &lt;==那个 $@ 就是 main ！
clean:
		rm -f main ${OBJS}
</code></pre>
<ul>
<li>函式库管理<br>
很多的软件之间都会互相取用彼此提供的函式库来进行特殊功能的运作<br>
依据函式库被使用的类型而分为两大类，分别是静态(Static) 与动态 (Dynamic) 函式库两类</li>
</ul>
<p>静态函式库的特色：<br>
扩展名：<strong>(扩展名为 .a)</strong><br>
这类的函式库通常扩展名为<strong>libxxx.a 的类型</strong>；<br>
编译行为：<br>
这类函式库在编<strong>译的时候会直接整合到执行程序</strong>当中，所以利用静态函式库编译成的<strong>文件会比较大一些</strong>；<br>
独立执行的状态：<br>
这类函式库最大的优点，就是<strong>编译成功的可执行文件可以独立执行</strong>，而不需要再向外部要求读取函式库的内容 (请参照动态函式库的说明)。<br>
升级难易度：<br>
虽然执行档可以独立执行，但因为函式库是直接整合到执行档中， 因此<strong>若函式库升级时，整个执行档必须要重新编译</strong>才能将新版的函式库整合到程序当中。 也就是说，在升级方面，只要函式库升级了，所有将此函式库纳入的程序都需要重新编译</p>
<p>动态函式库的特色：<br>
<strong>扩展名：(扩展名为 .so)</strong><br>
这类函式库通常扩展名为<strong>libxxx.so 的类型</strong>；<br>
编译行为：<br>
动态函式库与静态函式库的编译行为差异挺大的。 与静态函式库被整个捉到程序中不同的，动态函式库在编译的时候，<strong>在程序里面只有一个『指向 (Pointer)』的位置而已</strong>。也就是说，动态函式库的内容<strong>并没有被整合到执行档当中</strong>，而是当执行档要使用到函式库的机制时， 程序才会去读<strong>取函式库来使用</strong>。由于执行文件当中仅具有指向动态函式库所在的指标而已， 并不包含函式库的内容，所以他的文件会比较小一点。<br>
独立执行的状态：<br>
这类型的函式库所编译出来的程序<strong>不能被独立执行</strong>， 因为当我们使用到函式库的机制时，程序才会去读取函式库，所以函式库文件『必须要存在』才行，而且，函式库的<strong>所在目录也不能改变</strong>，因为我们的可执行文件里面仅有『指标』亦即当要取用该动态函式库时， 程序会主动去某个路径下读取，呵呵！所以动态函式库<strong>不能随意移动或删除</strong>，会影响很多相依的程序软件喔！<br>
升级难易度：<br>
虽然这类型的执行档无法独立运作，然而由于是具有指向的功能， 所以，当函式库<strong>升级后，执行档根本不需要进行重新编译的行为</strong>，因为执行档会直接指向新的函式库文件 (前提是函式库新旧版本的档名相同)。</p>
<p>目前的 Linux distribution 比较倾向于使用动态函式库，因为如同上面提到的最重要的一点， 就是函式库的升级方便</p>
<p>ldconfig  与 /etc/ld.so.conf<br>
如果我们将常用到的动态函式库先加载内存当中 (快取, cache)，如此一来，当软件要取用动态函式库时，就不需要从头由硬盘里面读出，这样就可以增进动态函式库的读取速度</p>
<p>将动态函式库加载高速缓存当中：</p>
<ol>
<li>首先，我们必须要在 /etc/ld.so.conf 里面写下『 想要读入高速缓存当中的动态函式库所在的目录』，注意是目录而不是文件；</li>
<li>接下来则是利用 ldconfig 这个执行档将 /etc/ld.so.conf 的资料读入快取当中；</li>
<li>同时也将数据记录一份在 /etc/ld.so.cache 这个文件当中</li>
</ol>
<p>ldconfig 还可以用来判断动态函式库的链接信息。想要将目前系统下函式库加入到快取当中时，可以这样做：</p>
<pre><code>[root@study ~]#  ldconfig [-f conf] [ -C cache]
[root@study ~]#  ldconfig [-p]
</code></pre>
<p>选项与参数：<br>
-f conf ：那个 conf 指的是某个文件名，也就是说，使用 conf 作为 libarary<br>
函式库的取得路径，而不以 /etc/ld.so.conf 为默认值<br>
-C cache：那个 cache 指的是某个文件名，也就是说，使用 cache 作为快取暂存<br>
的函式库资料，而不以 /etc/ld.so.cache 为默认值<br>
-p  ：列出目前有的所有函式库资料内容 (在 /etc/ld.so.cache 内的资料)</p>
<p>范例一：假设我的 Mariadb 数据库函式库在 /usr/lib64/mysql 当中，如何读进 cache ？<br>
<code>[root@study ~]# vim /etc/ld.so.conf.d/vbird.conf</code><br>
/usr/lib64/mysql &lt;==这一行新增的啦！<br>
<code>[root@study ~]# ldconfig &lt;==画面上不会显示任何的信息，不要太紧张！正常的！</code><br>
<code>[root@study ~]# ldconfig -p</code></p>
<ul>
<li>程序的动态函式库解析： ldd<br>
判断某个可执行的 binary 文件含有什么动态函式库<br>
<code>[root@study ~]# ldd [-vdr] [filename]</code><br>
选项与参数：<br>
-v ：列出所有内容信息；<br>
-d ：重新将资料有遗失的 link 点显示出来<br>
-r ：将 ELF 有关的错误内容显示出来</li>
</ul>
<p>安装文件时，可以先以 ldd 来视察『相依函式库』之间的相关性，亦即『 相依属性』</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 62. 不同路径[中等][未做出]]]></title>
        <id>https://lixin-ee.github.io//post/dong-tai-gui-hua-62-bu-tong-lu-jing-zhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/dong-tai-gui-hua-62-bu-tong-lu-jing-zhong-deng-wei-zuo-chu">
        </link>
        <updated>2020-01-11T01:11:27.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。<br>
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。<br>
问总共有多少条不同的路径？<br>
例如，上图是一个7 x 3 的网格。有多少可能的路径？<br>
说明：m 和 n 的值均不超过 100。<br>
示例 1:<br>
输入: m = 3, n = 2<br>
输出: 3<br>
解释:<br>
从左上角开始，总共有 3 条路径可以到达右下角。<br>
1.向右 -&gt; 向右 -&gt; 向下<br>
2.向右 -&gt; 向下 -&gt; 向右<br>
3.向下 -&gt; 向右 -&gt; 向右<br>
示例 2:<br>
输入: m = 7, n = 3<br>
输出: 28<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/unique-paths<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>其实这道题挺像回溯法的，但是我看了一眼tag其实是动态规划？<br>
一开始用的就是类似于回溯法的递归，然后又被自己坑了，递归调用中慎重用++i，只能用i+1,两次递归调用中会出现第二次递归i已经又增大了1的情况<br>
然后暴力递归果断爆炸了</p>
<p>然后我发现一个问题是似乎每个路径的长度是确定的</p>
<p>只能想一下动态规划了<br>
一开始实在没什么头绪，只能牺牲空间复杂度了，然后发现无论是vecotr还是unordered_map都很复杂<br>
还是老老实实看题解吧，没那么时间可以浪费了</p>
<p>看了题解才发现其实是70题提过的方法，只是当时没好好记录和复现，唉<br>
然后题目还提到了有化为一维数组的方法</p>
<p>复现过程中的点<br>
1.将m* n数组初始化为1<br>
2.循环标志i和j从1开始，因为边界点的可能性都是为1的，这一点和第一点相互照应。<br>
3.一维数组的压缩就是利用当前行只需要上一列的内容来压缩（可以先考虑压缩到两行cur和pre，然后在考虑cur本身也是pre）</p>
<p>最后就是排列组合的问题了，步骤确定，那么只要选定步骤中任意m次向右或者n次向下就行了，等于C上m或n,C下的len为m+n-2，有时间的话可以了解一下C上m或n都是结果相同的</p>
<p>所以从今天起，每道题只花少量时间去思考，想不出来就看题解的思路，然后按照思路来自己复现（不能照抄代码）</p>
<p>实现代码</p>
<pre><code>    /*自己弄的蹩脚的递归法
    void move(int i,int j,int m, int n,int &amp;res){
        if(i==m&amp;&amp;j==n){
            ++res;
            return;
        }
        if(i&lt;m)
            move(i+1,j,m,n,res);
        if(j&lt;n)
            move(i,j+1,m,n,res);
        return;
    }
    */
</code></pre>
<pre><code>    /*二维数组动态递归
        int uniquePaths(int m, int n) {
        vector&lt;vector&lt;int&gt;&gt; status(m,vector&lt;int&gt;(n,1));
        for(int i=1;i&lt;m;++i)
            for(int j=1;j&lt;n;++j)
                status[i][j]=status[i-1][j]+status[i][j-1];
        return status[m-1][n-1];
    }
</code></pre>
<pre><code>//单维数组存储
    int uniquePaths(int m, int n) {
        vector&lt;int&gt; status(m,1);
        for(int j=1;j&lt;n;++j)
            for(int i=1;i&lt;m;++i)
                status[i]+=status[i-1];
        return status[m-1];
    }
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>思路<br>
思路一：排列组合<br>
因为机器到底右下角，向下几步，向右几步都是固定的，<br>
比如，m=3, n=2，我们只要向下 1 步，向右 2 步就一定能到达终点。<br>
所以有 C{m+n-2} {m-1}</p>
</blockquote>
<pre><code>def uniquePaths(self, m: int, n: int) -&gt; int:
        return int(math.factorial(m+n-2)/math.factorial(m-1)/math.factorial(n-1))
</code></pre>
<blockquote>
<p>思路二：动态规划<br>
我们令 dp[i][j] 是到达 i, j 最多路径<br>
动态方程：dp[i][j] = dp[i-1][j] + dp[i][j-1]<br>
注意，对于第一行 dp[0][j]，或者第一列 dp[i][0]，由于都是在边界，所以只能为 1<br>
时间复杂度：O(m*n)<br>
空间复杂度：O(m * n))<br>
优化：因为我们每次只需要 dp[i-1][j],dp[i][j-1]<br>
所以我们只要记录这两个数，直接看代码吧！<br>
代码<br>
思路二：</p>
</blockquote>
<pre><code>Java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for (int i = 0; i &lt; n; i++) dp[0][i] = 1;
        for (int i = 0; i &lt; m; i++) dp[i][0] = 1;
        for (int i = 1; i &lt; m; i++) {
            for (int j = 1; j &lt; n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];  
    }
}
</code></pre>
<blockquote>
<p>优化1：空间复杂度 O(2n)</p>
</blockquote>
<pre><code>Java
class Solution {
    public int uniquePaths(int m, int n) {
        int[] pre = new int[n];
        int[] cur = new int[n];
        Arrays.fill(pre, 1);
        Arrays.fill(cur,1);
        for (int i = 1; i &lt; m;i++){
            for (int j = 1; j &lt; n; j++){
                cur[j] = cur[j-1] + pre[j];
            }
            pre = cur.clone();
        }
        return pre[n-1]; 
    }
}
</code></pre>
<blockquote>
<p>优化2：空间复杂度 O(n)</p>
</blockquote>
<pre><code>Java
class Solution {
    public int uniquePaths(int m, int n) {
        int[] cur = new int[n];
        Arrays.fill(cur,1);
        for (int i = 1; i &lt; m;i++){
            for (int j = 1; j &lt; n; j++){
                cur[j] += cur[j-1] ;
            }
        }
        return cur[n-1];
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 215. 数组中的第K个最大元素[中等]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-215-shu-zu-zhong-de-di-k-ge-zui-da-yuan-su-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-215-shu-zu-zhong-de-di-k-ge-zui-da-yuan-su-zhong-deng">
        </link>
        <updated>2020-01-10T01:25:57.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br>
示例 1:<br>
输入: [3,2,1,5,6,4] 和 k = 2<br>
输出: 5<br>
示例 2:<br>
输入: [3,2,3,1,2,4,5,5,6] 和 k = 4<br>
输出: 4<br>
说明:<br>
你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/kth-largest-element-in-an-array<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>一开始我想的是用空间换时间，创建一个k大小的数组，然后不断插入到合适的位置（等等，这不就是插入排序吗？插入需要查找感觉也没简化多少啊）<br>
然后发现其实可以转化为为堆排序，然后返回下标<br>
然后就是tag中的分治法 我只想到了分治排序（也就是归并排序）（注意别和快速排序搞混了）<br>
然后有一个想法分治分成多个部分然后合并成k份或者分成k份，但是后来发现有问题</p>
<p>插入排序的时间复杂度是平方，放弃<br>
先实现堆排序,我在复现的过程中犯了一个错误，HeapAdjust应该只有一个循环，每次处理一个非子节点，而不是一次把所有节点放进去，否则的话后面排序的时候会很麻烦<br>
此时其实和快速排序没啥子区别的了</p>
<p>然后题解中其实提到我想到的k大小数组和分治法的方法，分别是K大小的堆和快速选择</p>
<p>实现的代码：<br>
堆排序</p>
<pre><code>/*
    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {
        int len=nums.size();
        for(int i=(len-1)/2;i&gt;=0;--i)
            HeapAdjust(nums,i,len);
        
        for(int i=len-1;i&gt;0;--i){
            swap(nums[0],nums[i]);
            HeapAdjust(nums,0,i);
        }
        return nums[len-k];  
    }
    
    void HeapAdjust(vector&lt;int&gt; &amp;nums,int s,int len){
            int temp=nums[s];
            for(int j=2*s+1;j&lt;len;j=2*j+1){
                if(j&lt;len-1&amp;&amp;nums[j+1]&gt;nums[j])
                    ++j;
                if(temp&gt;nums[j])
                    break;
                nums[s]=nums[j];
                s=j;
            }
            nums[s]=temp;
    }
*/
</code></pre>
<p>快速排序随机切实现</p>
<pre><code>/*
    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {
        int target;
        int len=nums.size();
        int left=0,right=len-1;
        while(true){
            target=binartselect(nums,left,right);
            if(target==len-k)
                return nums[target];
            else if(target&lt;len-k)
                left=target+1;
            else
                right=target-1;
        }
    }
    
    int binartselect(vector&lt;int&gt;&amp; nums,int left,int right){
        int pivotkey=nums[left];  
        
        //C++的随机数实现 加到标题上方便搜索
        if(right&gt;left){
            default_random_engine e;
            uniform_int_distribution&lt;unsigned&gt; u(left,right);
            pivotkey=nums[u(e)];
        }
        while(left&lt;right){
            while(left&lt;right&amp;&amp;nums[right]&gt;=pivotkey) //这里一定要是&gt;=否则遇上重复数会导致无限循环
                --right;
            nums[left]=nums[right];
            while(left&lt;right&amp;&amp;nums[left]&lt;=pivotkey) //这里一定要是&lt;=否则遇上重复数会导致无限循环
                ++left;
            nums[right]=nums[left];           
        }
        nums[left]=pivotkey;
        return left;
    }
*/
</code></pre>
<p>优先队列实现：</p>
<pre><code>class Solution {
public:
    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {
        priority_queue&lt;int,vector&lt;int&gt;,great&lt;int&gt;&gt; res; //底层数据结构是大顶堆，注意每次会弹出最大值
        for(auto i:nums){
            res.push(i);
            if(res.size()&gt;k)
                res.pop();
        }
        return res.top();
    }
  
};
</code></pre>
<p>然后来看看网友题解</p>
<blockquote>
<p>方法一：暴力解法<br>
题目要求我们找到“数组排序后的第 k 个最大的元素，而不是第 kk 个不同的元素” ，<br>
语义是从右边往左边数第 k 个元素（从 1 开始），那么从左向右数是第几个呢，我们列出几个找找规律就好了。<br>
一共 6 个元素，找第 2 大，索引是 4；<br>
一共 6 个元素，找第 4 大，索引是 2。<br>
因此，升序排序以后，目标元素的索引是 len - k。这是最简单的思路，如果只答这个方法，面试官可能并不会满意，但是在我们平时的开发工作中，还是不能忽视这种思路简单的方法，理由如下：<br>
最简单同时也一定是最容易编码的，编码成功的几率最高，可以用这个最简单思路编码的结果和其它思路编码的结果进行比对，验证高级算法的正确性；<br>
在数据规模小、对时间复杂度、空间复杂度要求不高的时候，简单问题简单做；<br>
思路简单的算法考虑清楚了，有些时候能为实现高级算法铺路，这道题也是如此；<br>
低级算法往往容错性最好，即在输入不满足题目条件的时候，往往还能得到正确的答案，而高级算法对输入数据的要求就非常苛刻，这一点可以参考 「力扣」第 4 题：“寻找两个有序数组的中位数”。</p>
</blockquote>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

class Solution {
public:
    int findKthLargest(vector&lt;int&gt; &amp;nums, int k) {
        int size = nums.size();
        sort(begin(nums), end(nums));
        return nums[size - k];
    }
};
</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(NlogN)，这里 N 是数组的长度，算法的性能消耗主要在排序，JDK 默认使用快速排序，因此时间复杂度为O(NlogN)。<br>
空间复杂度：O(1)，这里是原地排序，没有借助额外的辅助空间。<br>
到这里，我们已经分析出了：<br>
1、我们应该返回最终排定以后位于 len - k 的那个元素；<br>
2、性能消耗主要在排序，JDK 默认使用快速排序。<br>
学习过 “快速排序” 的朋友，一定知道一个操作叫 partition，它是 “分而治之” 思想当中 “分” 的那一步。经过 partition 操作以后，每一次都能排定一个元素，并且这个元素左边的数都不大于它，这个元素右边的数都不小于它，并且我们还能知道排定以后的元素的索引。于是可以应用 “减而治之”（分治思想的特例）的思想，把问题规模转化到一个更小的范围里。</p>
</blockquote>
<blockquote>
<p>于是得到方法二。<br>
方法二：借助 partition 操作定位到最终排定以后索引为 len - k 的那个元素（特别注意：随机化切分元素）<br>
以下是注意事项，因为很重要，所以放在前面说：<br>
快速排序虽然快，但是如果实现得不好，在遇到特殊测试用例的时候，时间复杂度会变得很高。如果你使用 partition 的方法完成这道题，时间排名不太理想，可以考虑一下是什么问题，这个问题很常见。<br>
以下的描述基于 “快速排序” 算法知识的学习，如果忘记的朋友们可以翻一翻自己的《数据结构与算法》教材，复习一下，partition 过程、分治思想和 “快速排序” 算法的优化。<br>
分析：我们在学习 “快速排序” 的时候，接触的第 1 个操作就是 partition（切分），简单介绍如下：<br>
partition（切分）操作，使得：<br>
对于某个索引 j，nums[j] 已经排定，即 nums[j] 经过 partition（切分）操作以后会放置在它 “最终应该放置的地方”；<br>
nums[left] 到 nums[j - 1] 中的所有元素都不大于 nums[j]；<br>
nums[j + 1] 到 nums[right] 中的所有元素都不小于 nums[j]。<br>
partition（切分）操作总能排定一个元素，还能够知道这个元素它最终所在的位置，这样每经过一次 partition（切分）操作就能缩小搜索的范围，这样的思想叫做 “减而治之”（是 “分而治之” 思想的特例）。<br>
切分过程可以不借助额外的数组空间，仅通过交换数组元素实现。下面是参考代码：</p>
</blockquote>
<pre><code>public class Solution {

    public int findKthLargest(int[] nums, int k) {
        int len = nums.length;
        int left = 0;
        int right = len - 1;

        // 转换一下，第 k 大元素的索引是 len - k
        int target = len - k;

        while (true) {
            int index = partition(nums, left, right);
            if (index == target) {
                return nums[index];
            } else if (index &lt; target) {
                left = index + 1;
            } else {
                right = index - 1;
            }
        }
    }

    /**
     * 在数组 nums 的子区间 [left, right] 执行 partition 操作，返回 nums[left] 排序以后应该在的位置
     * 在遍历过程中保持循环不变量的语义
     * 1、[left + 1, j] &lt; nums[left]
     * 2、(j, i] &gt;= nums[left]
     *
     * @param nums
     * @param left
     * @param right
     * @return
     */
    public int partition(int[] nums, int left, int right) {
        int pivot = nums[left];
        int j = left;
        for (int i = left + 1; i &lt;= right; i++) {
            if (nums[i] &lt; pivot) {
                // 小于 pivot 的元素都被交换到前面
                j++;
                swap(nums, j, i);
            }
        }
        // 在之前遍历的过程中，满足 [left + 1, j] &lt; pivot，并且 (j, i] &gt;= pivot
        swap(nums, j, left);
        // 交换以后 [left, j - 1] &lt; pivot, nums[j] = pivot, [j + 1, right] &gt;= pivot
        return j;
    }

    private void swap(int[] nums, int index1, int index2) {
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(N)，这里 N 是数组的长度，理由可以参考本题解下用户 @ZLW 的评论，需要使用主定理进行分析。<br>
空间复杂度：O(1)，原地排序，没有借助额外的辅助空间。<br>
注意：本题必须随机初始化 pivot 元素，否则通过时间会很慢，因为测试用例中有极端测试用例。<br>
为了应对极端测试用例，使得递归树加深，可以在循环一开始的时候，随机交换第 1 个元素与它后面的任意 1 个元素的位置；<br>
说明：最极端的是顺序数组与倒序数组，此时递归树画出来是链表，时间复杂度是 O(N^2)，根本达不到减治的效果。</p>
</blockquote>
<p>参考代码 3：<br>
随机选取元素</p>
<pre><code>import java.util.Random;

public class Solution {

    private static Random random = new Random(System.currentTimeMillis());

    public int findKthLargest(int[] nums, int k) {
        int len = nums.length;
        int target = len - k;
        int left = 0;
        int right = len - 1;
        while (true) {
            int index = partition(nums, left, right);
            if (index &lt; target) {
                left = index + 1;
            } else if (index &gt; target) {
                right = index - 1;
            } else {
                return nums[index];
            }
        }
    }

    // 在区间 [left, right] 这个区间执行 partition 操作

    private int partition(int[] nums, int left, int right) {
        // 在区间随机选择一个元素作为标定点
        if (right &gt; left) {
            int randomIndex = left + 1 + random.nextInt(right - left);
            swap(nums, left, randomIndex);
        }

        int pivot = nums[left];
        int j = left;
        for (int i = left + 1; i &lt;= right; i++) {
            if (nums[i] &lt; pivot) {
                j++;
                swap(nums, j, i);
            }
        }
        swap(nums, left, j);
        return j;
    }

    private void swap(int[] nums, int index1, int index2) {
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp;
    }
} 
</code></pre>
<blockquote>
<p>2、使用双指针，将与 pivot 相等的元素等概论地分到 pivot 最终排定位置的两边。<br>
参考代码 4：使用双指针的办法找到切分元素的位置。</p>
</blockquote>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

class Solution {
private:
    int partition(vector&lt;int&gt; &amp;nums, int left, int right) {
        // 随机在 [left, right] 中, 选择一个数值作为标定点 pivot
        swap(nums[left], nums[rand() % (right - left + 1) + left]);

        int pivot = nums[left];
        while (left &lt; right) {
            while (left &lt; right &amp; nums[right] &gt;= pivot) {
                right--;
            }
            nums[left] = nums[right];
            while (left &lt; right &amp; nums[left] &lt; pivot) {
                left++;
            }
            nums[right] = nums[left];
        }
        nums[left] = pivot;
        return left;
    }

public:
    int findKthLargest(vector&lt;int&gt; &amp;nums, int k) {
        int size = nums.size();
        int target = size - k;

        int left = 0;
        int right = size - 1;
        while (true) {
            int p = partition(nums, left, right);
            if (p == target) {
                return nums[p];
            } else if (target &lt; p) {
                right = p - 1;
            } else {
                left = p + 1;
            }
        }
    }
};

</code></pre>
<blockquote>
<p>方法三：优先队列<br>
优先队列的思路是很朴素的。因为第 K 大元素，其实就是整个数组排序以后后半部分最小的那个元素。因此，我们可以维护一个有 K 个元素的最小堆：<br>
1、如果当前堆不满，直接添加；<br>
2、堆满的时候，如果新读到的数小于等于堆顶，肯定不是我们要找的元素，只有新都到的数大于堆顶的时候，才将堆顶拿出，然后放入新读到的数，进而让堆自己去调整内部结构。<br>
说明：这里最合适的操作其实是 replace，即直接把新读进来的元素放在堆顶，然后执行下沉（siftDown）操作。Java 当中的 PriorityQueue 没有提供这个操作，只好先 poll() 再 offer()。<br>
优先队列的写法就很多了，这里例举一下我能想到的（以下的写法大同小异，没有本质差别）。<br>
假设数组有 len 个元素。<br>
思路1：把 len 个元素都放入一个最小堆中，然后再 pop() 出 len - k 个元素，此时最小堆只剩下 k 个元素，堆顶元素就是数组中的第 k 个最大元素。<br>
思路2：把 len 个元素都放入一个最大堆中，然后再 pop() 出 k - 1 个元素，因为前 k - 1 大的元素都被弹出了，此时最大堆的堆顶元素就是数组中的第 k 个最大元素。<br>
根据以上思路，分别写出下面的代码：<br>
参考代码 5：</p>
</blockquote>
<pre><code>Java
import java.util.PriorityQueue;

public class Solution {

    public int findKthLargest(int[] nums, int k) {
        int len = nums.length;
        // 使用一个含有 len 个元素的最小堆，默认是最小堆，可以不写 lambda 表达式：(a, b) -&gt; a - b
        PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;(len, (a, b) -&gt; a - b);
        for (int i = 0; i &lt; len; i++) {
            minHeap.add(nums[i]);
        }
        for (int i = 0; i &lt; len - k; i++) {
            minHeap.poll();
        }
        return minHeap.peek();
    }
}
</code></pre>
<blockquote>
<p>参考代码 6：</p>
</blockquote>
<pre><code>Java
import java.util.PriorityQueue;

public class Solution {

    public int findKthLargest(int[] nums, int k) {
        int len = nums.length;
        // 使用一个含有 len 个元素的最大堆，lambda 表达式应写成：(a, b) -&gt; b - a
        PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;(len, (a, b) -&gt; b - a);
        for (int i = 0; i &lt; len; i++) {
            maxHeap.add(nums[i]);
        }
        for (int i = 0; i &lt; k - 1; i++) {
            maxHeap.poll();
        }
        return maxHeap.peek();
    }
}
</code></pre>
<blockquote>
<p>思路 3：只用 k 个容量的优先队列，而不用全部 len 个容量。<br>
参考代码 7：</p>
</blockquote>
<pre><code>import java.util.PriorityQueue;

public class Solution {

    public int findKthLargest(int[] nums, int k) {
        int len = nums.length;
        // 使用一个含有 k 个元素的最小堆
        PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;(k, (a, b) -&gt; a - b);
        for (int i = 0; i &lt; k; i++) {
            minHeap.add(nums[i]);
        }
        for (int i = k; i &lt; len; i++) {
            // 看一眼，不拿出，因为有可能没有必要替换
            Integer topEle = minHeap.peek();
            // 只要当前遍历的元素比堆顶元素大，堆顶弹出，遍历的元素进去
            if (nums[i] &gt; topEle) {
                minHeap.poll();
                minHeap.add(nums[i]);
            }
        }
        return minHeap.peek();
    }
}
</code></pre>
<blockquote>
<p>思路 4：用 k + 1 个容量的优先队列，使得上面的过程更“连贯”一些，到了 k 个以后的元素，就进来一个，出去一个，让优先队列自己去维护大小关系。</p>
</blockquote>
<pre><code>import java.util.PriorityQueue;

public class Solution5 {
    public int findKthLargest(int[] nums, int k) {
        int len = nums.length;
        // 最小堆
        PriorityQueue&lt;Integer&gt; priorityQueue = new PriorityQueue&lt;&gt;(k + 1, (a, b) -&gt; (a - b));
        for (int num : nums) {
            priorityQueue.add(num);
            if (priorityQueue.size() == k + 1) {
                priorityQueue.poll();
            }
        }
        return priorityQueue.peek();
    }
}
</code></pre>
<blockquote>
<p>思路 5：综合考虑以上两种情况，总之都是为了节约空间复杂度。即 k 较小的时候使用最小堆，k 较大的时候使用最大堆。、</p>
</blockquote>
<pre><code>import java.util.PriorityQueue;

public class Solution {

    // 根据 k 的不同，选最大堆和最小堆，目的是让堆中的元素更小
    // 思路 1：k 要是更靠近 0 的话，此时 k 是一个较大的数，用最大堆
    // 例如在一个有 6 个元素的数组里找第 5 大的元素
    // 思路 2：k 要是更靠近 len 的话，用最小堆

    // 所以分界点就是 k = len - k

    public int findKthLargest(int[] nums, int k) {
        int len = nums.length;
        if (k &lt;= len - k) {
            // System.out.println(&quot;使用最小堆&quot;);
            // 特例：k = 1，用容量为 k 的最小堆
            // 使用一个含有 k 个元素的最小堆
            PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;(k, (a, b) -&gt; a - b);
            for (int i = 0; i &lt; k; i++) {
                minHeap.add(nums[i]);
            }
            for (int i = k; i &lt; len; i++) {
                // 看一眼，不拿出，因为有可能没有必要替换
                Integer topEle = minHeap.peek();
                // 只要当前遍历的元素比堆顶元素大，堆顶弹出，遍历的元素进去
                if (nums[i] &gt; topEle) {
                    minHeap.poll();
                    minHeap.add(nums[i]);
                }
            }
            return minHeap.peek();

        } else {
            // System.out.println(&quot;使用最大堆&quot;);
            assert k &gt; len - k;
            // 特例：k = 100，用容量为 len - k + 1 的最大堆
            int capacity = len - k + 1;
            PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;(capacity, (a, b) -&gt; b - a);
            for (int i = 0; i &lt; capacity; i++) {
                maxHeap.add(nums[i]);
            }
            for (int i = capacity; i &lt; len; i++) {
                // 看一眼，不拿出，因为有可能没有必要替换
                Integer topEle = maxHeap.peek();
                // 只要当前遍历的元素比堆顶元素大，堆顶弹出，遍历的元素进去
                if (nums[i] &lt; topEle) {
                    maxHeap.poll();
                    maxHeap.add(nums[i]);
                }
            }
            return maxHeap.peek();
        }
    }
}
</code></pre>
<p>思路五降低空间复杂度的思维很值得学习，我本来以为大顶堆不适用，但是其实找第k大的数字也就是找第len-k+1小的数，此时如果len-k+1小于k的话完全可以用大顶堆来降低空间复杂度</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ [Linux基础] 系统服务 (daemons) （鸟哥Linux第十七章）]]></title>
        <id>https://lixin-ee.github.io//post/linux-ji-chu-xi-tong-fu-wu-daemons-niao-ge-linux-di-shi-qi-zhang</id>
        <link href="https://lixin-ee.github.io//post/linux-ji-chu-xi-tong-fu-wu-daemons-niao-ge-linux-di-shi-qi-zhang">
        </link>
        <updated>2020-01-09T13:15:09.000Z</updated>
        <content type="html"><![CDATA[<p>这个题目我纠结了许久，最后还是用的系统服务<br>
虽然鸟哥这本书的用词用语和大陆差得太远了，但是daemons翻译成系统服务确实比守护进程略微好一点，一开始我还以为守护进程是保证安全的函数。。。</p>
<ul>
<li>系统服务 (daemons)简介<br>
『常驻在记体体中的程序，且可以提供一些系统或网络功能，那就是服务』<br>
系统为了某些功能必须要提供一些服务 (不论是系统本身还是网络方面)，这个服务就称为service 。<br>
达成这个service的<strong>程序</strong>我们就称呼他为 daemon</li>
</ul>
<p>早期的Unix系统核心第一个启动的程序是 init ， 然后 init 去唤起所有的系统所需要的服务<br>
后来改用 systemd 启动服务管理机制</p>
<p>systemd 将过去所谓的 daemon 执行脚本通通称为一个服务单位 (unit)，而每种服务单位 依据功能来区分时，就分类为不同的类型 (type)。<br>
基本的类型有包括系统服务、数据监听与交换的插槽档服务 (socket)、储存系统状态的快照类型、提供不同类似执行等级分类的操作环境 (target) 等</p>
<p>配置文件都放置在底下的目录中：<br>
/usr/lib/systemd/system/：每个服务最主要的启动脚本设定，有点类似以前的 /etc/init.d 底下的文件；<br>
/run/systemd/system/：系统执行过程中所产生的服务脚本，这些脚本的优先序要比 /usr/lib/systemd/system/ 高<br>
/etc/systemd/system/：管理员依据主机系统的需求所建立的执行脚本</p>
<p>systemd 的 unit 类型分类：主要靠扩展 名来区分上述所谓的不同的类型 (type)</p>
<ul>
<li>透过 systemctl 管理服务<br>
systemd 这个启动服务的机制，主要是透过一只名为 systemctl 的指令来处理，注意， systemd 就是仅有 systemctl 这个处理指令<br>
一般来说，服务的启动有两个阶段，一 个是『开机的时候设定要不要启动这个服务』， 以及『你现在要不要启动这个服务』<br>
<code>[root@study ~]# systemctl [command] [unit]</code><br>
command 主要有：<br>
start ：立刻启动后面接的 unit<br>
stop ：立刻关闭后面接的 unit<br>
restart ：立刻关闭后启动后面接的 unit，亦即执行 stop 再 start 的意思<br>
reload ：不关闭后面接的 unit 的情况下，重载配置文件，让设定生效<br>
enable ：设定下次开机时，后面接的 unit 会被启动<br>
disable ：设定下次开机时，后面接的 unit 不会被启动<br>
status ：目前后面接的这个 unit 的状态，会列出有没有正在执行、开机预设执行否、登录等信息等！<br>
is-active ：目前有没有正在运作中<br>
is-enable ：开机时有没有预设要启用这个 unit<br>
mask：注销服务<br>
unmask：取消注销</li>
</ul>
<p>注意不应该使用 kill 的方式来关掉一个正常的服务！否则 systemctl 会无法继续监控该服务的</p>
<p>status 的Active除了running 跟 dead 之外，基本上还有几个常见的状态：<br>
active (running)：正有一只或多只程序正在系统中执行的<br>
active (exited)：仅执行一次就正常结束的服务，目前并没有任何程序在系统中执行。 通常用 bash shell 写的小型服务，大多是属于这种类型 (无须常驻内存)。<br>
active (waiting)：正在执行当中，不过还再等待其他的事件才能继续处理。举例来说，打印的队列相关服务就是这种状态<br>
inactive：这个服务目前没有运作的意思。</p>
<p>status 的Load状态除了 enable/disable之外，还有：<br>
enabled：这个 daemon 将在开机时被执行<br>
disabled：这个 daemon 在开机时不会被执行<br>
static：这个 daemon 不可以自己启动 (enable 不可)，不过可能会被其他的 enabled 的服务来唤醒 (相依属性的服务)<br>
mask：这个 daemon 无论如何都无法被启动！因为已经被强制注销 (非删除)</p>
<p>很多服务彼此之间是有相依性的,所以关闭一个服务可能会连带着关闭多个服务</p>
<ul>
<li>透过 systemctl 观察系统上所有的服务<br>
上一小节谈到的是单一服务的启动/关闭/观察，以及相依服务要注销的功能。那系统上面有多少的服务存在等任务就得要透过 list-units 及 list-unit-files 来观察了<br>
<code>[root@study ~]# systemctl [command] [ [--type=TYPE] [ --all]</code><br>
command:<br>
list-units ：依据 unit 列出目前有启动的 unit。若加上 --all 才会列出没启动的。<br>
list-unit-files ：依据 /usr/lib/systemd/system/ 内的文件，将所有文件列表说明。<br>
--type=TYPE：就是之前提到的 unit type，主要有 service, socket, target 等</li>
</ul>
<p>list-units（默认） 输出列表中各项主要的意义是：<br>
UNIT ：项目的名称，包括各个 unit 的类别 (看扩展名)<br>
LOAD ：开机时是否会被加载，默认 systemctl 显示的是有加载的项目而已<br>
ACTIVE ：目前的状态，须与后续的 SUB 搭配，就是我们用 systemctl status 观察时active 的项目<br>
DESCRIPTION ：详细描述啰</p>
<p>systemctl list-unit-files 会将系统上所有的服务通通列出来～而不像 list-units 仅以 unit 分类作大致的说明。列表中的 STATE 状态就是前两个小节谈到的开机是否会加载的那个状态项目，主要有enabled / disabled / mask / static 等等。</p>
<ul>
<li>透过 systemctl  管理不同的操作环境 (target unit)<br>
<code>[root@study ~]# systemctl [command] [unit.target]</code><br>
选项与参数：<br>
command:<br>
get-default ：取得目前的 target<br>
set-default ：设定后面接的 target 成为默认的操作模式<br>
isolate       ：切换到后面接的模式</li>
</ul>
<p>CentOS 7.1 的预设情况下，就有 26 个 target unit，而跟操作界面相关性比较高的target 主要有底下几个：<br>
graphical.target：就是文字加上图形界面，这个项目已经包含了底下的 multi-user.target 项目<br>
multi-user.target：纯文本模式<br>
rescue.target：在无法使用 root 登入的情况下，systemd 在开机时会多加一个额外的暂时系统，与你原本的系统无关。这时你可以取得 root 的权限来维护你的系统。 但是这是额外系统，因此可能需要动到 chroot 的方式来取得你原有的系统喔<br>
emergency.target：紧急处理系统的错误，还是需要使用 root 登入的情况，在无法使用 rescue.target 时，可以尝试使用这种模式<br>
shutdown.target：就是关机的流程。<br>
getty.target：可以设定你需要几个 tty 之类的，如果想要降低 tty 的项目，可以修改这个东西的配置文件</p>
<p>在正常的切换情况下，使用上述 isolate 的方式即可。不过为了方便起见，systemd 也提供了数个简单的指令给我们切换操作模式之用<br>
systemctl poweroff 系统关机<br>
systemctl reboot 重新启动<br>
systemctl suspend 进入暂停模式<br>
systemctl hibernate 进入休眠模式<br>
systemctl rescue 强制进入救援模式<br>
systemctl emergency 强制进入紧急救援模式</p>
<ul>
<li>
<p>透过 systemctl  分析各服务之间的相依<br>
<code>[root@study ~]# systemctl list-dependencies [unit] [ --reverse]</code><br>
选项与参数：<br>
--reverse ：反向追踪谁使用这个 unit</p>
</li>
<li>
<p>与 systemd  的 daemon 运作过程相关的目录简介<br>
/usr/lib/systemd/system/：<br>
默认的启动脚本配置文件都放在这里，这里的数据尽量不要修改<br>
/run/systemd/system/：<br>
系统执行过程中所产生的服务脚本<br>
/etc/systemd/system/：<br>
管理员依据主机系统的需求所建立的执行脚本<br>
/etc/sysconfig/* ：<br>
几乎所有的服务都会将初始化的一些选项设定写入到这个目录下<br>
/var/lib/：<br>
一些会产生数据的服务都会将他的数据写入到 /var/lib/ 目录中。<br>
/run/：<br>
放置了好多 daemon 的暂存档，包括 lock file 以及 PID file 等等。</p>
</li>
</ul>
<p>通过<code>[root@study ~]# systemctl list-socket</code>查询 socket file 放置在哪里</p>
<ul>
<li>
<p>网络服务与端口口对应简介<br>
主机是透过端口号 (port number) 分辨不同的服务要求<br>
/etc/services 指定了服务与哪个端口对应，可以直接用<code>cat /etc/services</code>查询</p>
</li>
<li>
<p>关闭网络服务<br>
会产生一个网络监听端口 (port) 的程序，就可以称为网络服务<br>
可以通过  <code>systemctl stop[unit]</code>或者<code>systemctl disable [unit]</code> 来关闭</p>
</li>
<li>
<p>systemctl  针对 service 类型的配置文件<br>
systemctl 配置文件的设定项目简介<br>
整个设定分为三个部份，就是：<br>
[Unit]： unit 本身的说明，以及与其他相依 daemon 的设定，包括在什么服务之后才启动此 unit 之类的设<br>
定值；<br>
[Service], [Socket], [Timer], [Mount], [Path]..：不同的 unit type 就得要使用相对应的设定项目。我们拿的是<br>
sshd.service 来当模板，所以这边就使用 [Service] 来设定。 这个项目内主要在规范服务启动的脚本、环境<br>
配置文件档名、重新启动的方式等等。<br>
[Install]：这个项目就是将此 unit 安装到哪个 target 里面去</p>
</li>
</ul>
<p>配置文件内有些设定规则还是得要说明一下：<br>
设定项目通常是可以重复的，例如我可以重复设定两个 After 在配置文件中，不过，后面的设定会取代前面，因此，如果你想要将设定值归零， 可以使用类似『 After= 』的设定，亦即该项目的等号后面什么都没有，就将该设定归零了 (reset)。<br>
如果设定参数需要有『是/否』的项目 (布尔值, boolean)，你可以使用 1, yes, true, on 代表启动，用 0, no, false,off 代表关闭<br>
空白行、开头为 # 或 ; 的那一行，都代表批注</p>
<p>systemctl  针对 timer   的配置文件</p>
<p>CentOS 7.x 预设启动的服务简易说明<br>
使用 systemctl list-unit-files--type=service 查询<br>
部分服务上简易说明<br>
dovecot<br>
( 网络)可以设定 POP3/IMAP 等收受信件的服务，如果你的 Linux 主机是 email server 才需要这个服务，否则不需要启动<br>
httpd ( 网络)<br>
这个服务可以让你的 Linux 服务器成为 www server 喔！<br>
named<br>
( 网络)这是领域名服务器 (Domain Name System) 的服务， 这个服务非常重要，但是设定非常困难，目前应该不需要这个服务<br>
nfs nfs-server<br>
( 网络)这就是 Network Filesystem，是 Unix-Like 之间互相作为网络驱动器机的一个功能。<br>
smb<br>
nmb<br>
( 网络)这个服务可以让 Linux 仿真成为 Windows 上面的网络上的芳邻。 如果你的 Linux 主机想要<br>
做为 Windows 客户端的网络驱动器机服务器，这玩意儿得要好好玩一玩。<br>
vsftpd ( 网络)作为文件传输服务器 (FTP) 的服务。<br>
sshd<br>
( 网络)这个是远程联机服务器的软件功能， 这个通讯协议比 telnet 好的地方在于 sshd 在传送资料时可以进行加密，这个服务不要关闭<br>
rpcbind ( 网络)达成 RPC 协议的重要服务，包括 NFS, NIS 等等都需要这东西的协助<br>
postfix<br>
( 网络)寄件的邮件主机～因为系统还是会产生很多 email 讯息，例如 crond / atd 就会传送 email给本机用户！ 所以这个服务千万不能关，即使你不是 mail server 也是要启用这服务才行</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UNP-UNIX网络编程 第四章]]></title>
        <id>https://lixin-ee.github.io//post/unp-unix-wang-luo-bian-cheng-di-si-zhang</id>
        <link href="https://lixin-ee.github.io//post/unp-unix-wang-luo-bian-cheng-di-si-zhang">
        </link>
        <updated>2020-01-09T12:45:33.000Z</updated>
        <content type="html"><![CDATA[<p>主要讲述编写一个完整的TCP客户/服务器程序所需要的基本套接字函数<br>
并发服务器：它是在同时有大量的客户连接到同一服务器上时用于提供并发性的一种常用Unix技术。每个客户连接都迫使服务器为它派生（fork） 一个新的进程。</p>
<p><img src="https://lixin-ee.github.io//post-images/1578574785629.png" alt=""></p>
<ul>
<li>socket 函数<br>
为了执行网络I/O, 一个进程必须做的第一件事情就是调用socket函数，指定期望的通信协议类型</li>
</ul>
<pre><code>#include &lt;sys/socket.h&gt;
int socket （int family, int type, int protocol）;
</code></pre>
<p>返回：若成功则为非负描述符，若出错则为-1<br>
family参数指明协议族，type 参数指明套接字类型，protocol参数应设为图4-4所示的某个协议 类型常值，或者设为0,以选择所给定family和type组合的系统默认值。<br>
<img src="https://lixin-ee.github.io//post-images/1578574917564.png" alt=""><br>
<img src="https://lixin-ee.github.io//post-images/1578574720688.png" alt=""><br>
socket函数在成功时返回一个小的非负整数值，它与文件描述符类似，我们把它称为套接字描述符（socket descriptor）,简称sockfd。<br>
我们并没有指定本地协议地址或远程协议地址<br>
AF_XXX 和 PF_XXX，AF_前缀表示地址族，PF一前缀表示协议族</p>
<ul>
<li>connect 函数<br>
TCP客户用connect函数来建立与TCP服务器的连接。</li>
</ul>
<pre><code>#include &lt;sys/socket.h&gt;
int connect （int sockfd, const struct sockaddr *servaddr, socklen_t addrlen）;
</code></pre>
<p>sockfd是由socket函数返回的套接字描述符，第二个、第三个参数分别是一个指向套接字地址结构的指针和该结构的大小<br>
套接字地址结构必须含有服务器的IP地址和端口号。<br>
<strong>客户</strong>在调用函数connect前不必非得调用bind函数，因为如果 需要的话，内核会确定源IP地址，并选择一个临时端口作为源端口。<br>
如果是TCP套接字，调用connect函数将激发TCP的三路握手过程<br>
其中连接出错返回可能有以下几种情况<br>
（1）	若TCP客户没有收到SYN分节的响应，则返回ETIMEDOUT错误。<br>
（2）	若对客户的SYN的响应是RST （表示复位），则表明该服务器主机在我们指定的端口上 没有进程在等待与之连接（例如服务器进程也许没在运行）。这是一种硬错误（hard error）.客户一接收到RST就马上返回ECONNREFUSED错误。<br>
RST是TCP在发生错误时发送的一种TCP分节。产生RST的三个条件是：目的地为某端口的 SYN到达，然而该端口上没有正在监听的服务器（如前所述）；TCP想取消一个己有连接；TCP 接收到一个根本不存在的连接上的分节。<br>
（3）若客户发出的SYN在中间的某个路由器上引发了一个“destination unreachable &quot;（目的地 不可达）ICMP错误，则认为是一种软错误（soft error）<br>
客户主机内核保存该消息，并按第一种情况中所述的时间间隔继续发送SYN。若在某个规定的时间（4.4BSD规定75s）后仍未收到响应，则把保存的消息（即ICMP错误）作为EHOSTUNREACH或ENETUNREACH错误返回给进程。<br>
以下两种情形也是有可能的：一是按照本地系统的转发表，根本没有到达远程系统的路径；二是 connect调用根本不等待就返回。</p>
<p>注意区分情况2和情况3，一个是到达了目的地址，但是不存在相应的端口，一个是根本没法到达目的地址</p>
<p><strong>注意！！！</strong><br>
若connect失败则该<strong>套接字不再可用，必须关闭</strong>，我们<strong>不能对这样的套接字再次调用connect函数</strong>。当循环调用函数connect为给定主机尝试 各个IP地址直到有一个成功时，在每次connect失败后，都必须close当前的套接字描述符并重新调用socket。</p>
<ul>
<li>bind 函数<br>
bind函数把一个本地协议地址赋予一个套接字，其中协议地址是32位的IPv4地址与16位的TCP或UDP端口号的组合。</li>
</ul>
<pre><code>#include &lt;sys/socket.h&gt;
int bind（int sockfd, const struct sockaddr *myaddr, socklen_t addrlen）；
返回：若成功则为0,若出错则为-1
</code></pre>
<p>第二个参数是一个指向特定于协议的地址结构的指针，第三个参数是该地址结构的长度。 对于TCP,调用bind函数可以指定一个端口号，或指定一个IP地址，也可以两者都指定，还可以都不指定。</p>
<p>1.服务器在启动时捆绑它们的众所周知端口<br>
2.如果一个TCP客户或服务器未曾调用bind捆绑一个端口，当调用connect或listen时，内核就要为相应的 套接字选择一个临时端口。让内核来选择临时端口对于TCP客户来说是正常的，对于TCP服务器来说却极为罕见。<br>
3.进程可以把一个特定的IP地址捆绑到它的套接字上，不过这个IP地址必须属于其所在主机的网络接口之一。<br>
4.客户通常不把IP地址捆绑到它的套接字上。当连接套接字时，内核将根据所用外出网络 接口来选择源IP地址，而所用外出接口则取决于到达服务器所需的路径。<br>
5.如果TCP服务器没有把IP地址捆绑到它的套接字上，内核就把客户发送的SYN的目的IP 地址作为服务器的源IP地址</p>
<p>调用bind可以指定IP地址或端口，可以两者都指定，也可以都不指定。图<br>
4-6汇总了如何根据预期的结果，设置sin_addr和sin_port的值。<br>
<img src="https://lixin-ee.github.io//post-images/1578746168950.png" alt=""><br>
如果指定端口号为0,那么内核就在bind被调用时选择一个临时端口。然而如果指定IP地 址为通配地址，那么内核将等到套接字<strong>已连接</strong>（TCP）或己在套接字上<strong>发出数据报</strong>（UDP）时 才选择一个本地IP地址。<br>
对于IPv4来说，通配地址由常值INADDR_ANY来指定，其值一般为0。它告知内核去选择IP地址。<br>
struct sockaddr_in servaddr；<br>
servaddr.sin_addr.s_addr = htonl（INADDR_ANY）;	/* wildcard*/<br>
如果让内核来为套接字选择一个临时端口号，那么必须注意，函数bind<strong>并不返回所选择的值</strong>。实际上，由于bind函数的第二个参数有const限定词，它无法返回所选之值。为了得到内核所选择的这个临时端口值，必须调用<strong>函数getsockname</strong>来返回协议地址。</p>
<ul>
<li>listen 函数<br>
listen函数仅由TCP服务器调用，它做两件事情。<br>
(1)	当<strong>socket函数</strong>创建一个套接字时，它被假设为一个<strong>主动套接字</strong>，也就是说，它是一个将调用connect发起连接的客户套接字。<strong>listen函数</strong>把一个未连接的套接字转换成一个<strong>被动套接字</strong>，指示内核应接受指向该套接字的<strong>连接请求</strong>。根据TCP状态转换图〈图2-4),调用listen 导致套接字从CLOSED状态转换到LISTEN状态。<br>
(2)	本函数的第二个参数规定了内核应该为相应套接字<strong>排队</strong>的最大连接个数。</li>
</ul>
<pre><code>#include &lt;sys/socket.h&gt;
int listen (int sockfd, int backlog)；
	返回：若成功则为0,若出错则为-1
</code></pre>
<p>在调用socket和bind这两个函数<strong>之后</strong>，并在调用accept函数之前<strong>调用</strong>。</p>
<p>backlog参数并非任意设置，必须认识到内核为任何一个给定的监听套接字维护两个 队列：<br>
(1)	未完成连接队列(incomplete connection queue),每个这样的SYN分节对应其中一项： 已由某个客户发出并到达服务器，而服务器正在等待完成相应的TCP三路握手过程。这些套接字处于SYN_RCVD状态(图2-4)。<br>
(2)	已完成连接队列(completed connection queue),每个已完成TCP三路握手过程的客户对 应其中一项。这些套接字处于ESTABLISHED状态(图2-4)。<br>
<img src="https://lixin-ee.github.io//post-images/1578746600887.png" alt=""><br>
<img src="https://lixin-ee.github.io//post-images/1578746644512.png" alt=""><br>
当来自客户的<strong>SYN</strong>到达时，TCP在<strong>未完成连接队列</strong>中创建一个新项，然后响应以三路握手的第二个分节：服务器的SYN响应，其中捎带对客户SYN的ACK 。这一项一直保留在未完成连接队列中，直到三路握手的第三个分节（客户对服务器<strong>SYN的ACK</strong>）到达或者该项超时为止。<br>
如果三路握手正常 完成，该项就从未完成连接队列移到已完成连接队列的队尾。当进程调用accept时（该函数在 下一节讲解），已完成连接队列中的队头项将返回给进程，或者如果该队列为空，那么进程将被投入睡眠，直到TCP在该队列中放入一项才唤醒它。</p>
<p>关于backlog的注意事项<br>
• listen函数的backlog参数曾被规定为这两个队列总和的最大值。<br>
• 不要把由backlog定义为0,因为不同的实现对此有不同的解释。如果你不想让任 何客户连接到你的监听套接字上，那就关掉该监听套接字。<br>
• 在三路握手正常完成的前提下（也就是说没有丢失分节，从而没有重传），未完成连接 队列中的任何一项在其中的存留时间就是一个RTT,<br>
• 当一个客户SYN到达时，若这些队列是满的，TCP就忽略该分节， 也就是不发送RST。这么做是因为：这种情况是暂时的，客户TCP将重发SYN,期望不久就能在这些队列中找到可用空间。<br>
要是服务器TCP立即响应以一个RST,客户的 connect调用就会立即返回一个错误，强制应用进程处理这种情况，而不是让TCP的正 常重传机制来处理。另外，客户<strong>无法区别响应SYN的RST</strong>究竟意味着“该端口没有服务器在监听”，还是意味着“该端口有服务器在监听，不过它的队列满了”<br>
•在三路握手完成之后，但在服务器调用accept之前到达的<strong>数据</strong>应由服务器TCP排队，最 大数据量为相应已连接套接字的<strong>接收缓冲区</strong>大小。</p>
<p>SYN泛滥（SYN flooding）：以高速率给受害主机发送SYN的程序，用以强行塞爆一个或多个TCP端口的未完成连接队列</p>
<ul>
<li>accept 函数<br>
accept函数由TCP服务器调用，用于从已完成连接队列队头返回下一个己完成连接。如果已完成连接队列为空，那么进程被投入睡眠（假定套接字为默认的阻塞方式）。</li>
</ul>
<pre><code>#include &lt;sys/socket.h&gt;
int accept （int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen）；
返回：若成功则为非负描述符，若出错则为-1
</code></pre>
<p>参数cloaddr和addrlen用来返回已连接的对端进程（客户）的协议地址。addrlen是值-结果参数：调用前，我们将由* addrlen所引用的整数值置为由<strong>cliaddr所指的套接字地址结构的长度</strong>，返回时，该整数值即为由内核存放在该套接字地址结构内的<strong>确切字节数</strong>。<br>
如果accept成功，那么其返回值是由内核自动生成的一个<strong>全新描述符</strong>，代表与所返回客户的TCP连接。在讨论accept函数时，我们称它的第一个参数为<strong>监听套接字（listening socket）描 述符</strong>（由socket创建，随后用作bind和listen的第一个参数的描述符），称它的返回值为<strong>已连接套接字（connected socket）描述符</strong>。区分这两个套接字非常重要。一个服务器通常<strong>仅仅创建一个监听套接字</strong>，它在该服务器的<strong>生命期内一直存在</strong>。内核为<strong>每个</strong>由服务器进程接受的客户连接创建一个<strong>已连接套接字</strong>（也就是说对于它的TCP三路握手过程已经完成）。当服务器完成对某个给定客户的服务时，相应的<strong>已连接套接字就被关闭</strong>。</p>
<p>注意，虽然是形参，但本函数最多返回三个值：一个既可能是新套接字描述符也可能是出错指示的整数、客户进程的协议地址（由cliaddr指针所指）以及该地址的大小（由addrlen指针所指）。如果我们对返回客户协议地址不感兴趣，那么可以把cliaddr和addrlen均置为空指针.</p>
<ul>
<li>fork 和 exec 函数<br>
fork函数是Unix中派生新进程的唯-方法</li>
</ul>
<pre><code>#include &lt;unistd.h&gt;
pid_t fork（void）;
返回:在子进程中为0,在父进程中为于进程ID,若出错则为-1
</code></pre>
<p>理解fork最困难之处在于调用它一次，它却返回两次。 它在调用进程（称为父进程）中返回一次，返回值是新派生进程（称为子进程）的进程ID号 <strong>(亦即子进程的ID)</strong>； 在子进程又返回一次，返回值为0<br>
因此，<strong>返回值本身告知当前进程是子进程还是父进程</strong>。<br>
fork具有返回值的原因：子进程总是可以通过调用getppid取得父进程的进程ID。相反，父进程可以有许多子进程， 而且无法获取各个子进程的进程ID。如果父进程想要跟踪所有子进程的进程ID,那么它必须记 录每次调用fork的返回值。<br>
父进程中调用下fork之前打开的<strong>所有描述符</strong>在fork返回之后由子进程<strong>分享</strong>。<br>
网络 服务器利用了这个特性：父进程调用accept之后调用fork所接受的已连接套接字随后就在父进程与子进程之间共享。通常情况下，子进程接着读写这个己连接套接字，父进程<strong>则关闭</strong>这个已连接套接字。</p>
<p>fork有两个典型用法。<br>
（1）一个进程创建一个自身的副本，这样每个副本都可以在另一个副本执行其他任务的同时处理各自的某个操作。这是<strong>网络服务器</strong>的典型用法<br>
（2）一个进程想要执行<strong>另一个程序</strong>。既然创建新进程的唯一办法是调用fork,该进程于是首先调用fork创建一个自身的副本，然后其中一个副本（通常为子进程）调用exec把自身替换成新的程序。这是诸如<strong>shell</strong>之类程序的典型用法。</p>
<p>存放在硬盘上的可执行程序文件能够被Unix执行的唯一方法是：由一个现有进程调用六个exec函数中的某一个。exec把当前进程映像替换成新的程序文件，而且该新程序通常从main函数开始执行。<strong>进程ID并不改变</strong>。我们称调用exec的进程为调用进程（calling process）,称新执行的程序为新程序（new program）。<br>
这6个exec函数之间的区别在于：（a）待执行的程序文件是由文件名（filename）还是由路径名（pathname）指定；（b）新程序的参数是一一列出还是由一个指针数组来引用；（c）把调用进程的环境传递给新程序还是给新程序指定新的环境。</p>
<pre><code>#include &lt;unistd.h&gt;
int execl （const char *pathname, const char *arg0, ... /* （char *） 0 */ ）;
int execv (const char *pathname, char *const *argv [])；
int execle (const char *pathname, const char *arg0,.../* (char *) 0, char *const envp{} */ );
int execve (const char *pathname, char * const argvl], char *const envp [])；
int execlp(const char *filename, const char *arg0 ... /* (char *) 0 */ );
int execvp (const char filename, char *const argv[]);
均返回：若成功则不返回，若出错则为-1
</code></pre>
<p>这些函数只在出错时才返回到调用者。否则，控制将被传递给新程序的起始点，通常就是 main函数。<br>
这6个函数间的关系如图所示。一般来说，只有execve是内核中的系统调用，其他5个 都是调用execve的库函数。<br>
<img src="https://lixin-ee.github.io//post-images/1578885030620.png" alt=""><br>
进程在调用exec之前打开着的描述符通常跨exec继续保持打开，可以使用fcntl设置FD_CLOEXEC描述符标志禁止掉。</p>
<ul>
<li>
<p>并发服务器<br>
编写并发服务器程序最简单的办法就 是fork一个子进程来服务每个客户。<br>
大概思路：当一个连接建立时，accept返回，服务器接着<strong>调用fork</strong>,然后由子进程服务客户（通过己连接套接字connfd）,父进程则等待另一个连接（通过监听套接字listened）。既然新的客户由子进程提供服务，<strong>父进程就关闭已连接套接字</strong>。<br>
进程终止处理的部分工作就是关闭所有由内核打开的描述符。<br>
注意父进程对connfd调用close并没有终止它与客户的连接，每个文件或套接字都有一个引用计数。<br>
fork返回后，描述符在父进程与子进程间共享（也就是被复制），套接字相关联的文件表项各自的访问计数值均+1，当父进程关闭connfd时，它只是把相应的引用计数值-1。该套接字真正的清理和资源释放要等到其引用计数值到达0时才发生。这会在稍后子进程也关闭connfd时发生。</p>
</li>
<li>
<p>close 函数</p>
</li>
</ul>
<pre><code>#include &lt;unistd.h&gt;
int close(int sockfd)；	
返回：若成功则为0,若出错则为-1
</code></pre>
<p>close一个TCP套接字的默认行为是把<strong>该套接字标记成己关闭</strong>，然后<strong>立即返回到调用进程</strong>。 该套接字描述符<strong>不能再由调用进程使用</strong>，也就是说它不能再作为read或write的第一个参数。<br>
注意close只是应用层的，TCP将继续尝试发送已排队等待发送到对端的任何数据，发送完毕后发生的是正常的TCP连接终止序列。</p>
<p>描述符引用计数<br>
close调用并不引发TCP的四分组连接终止序列，如果我们确实想在某个TCP连接上发送一个FIN,那么可以改用shutdown函数以代替close.<br>
父进程必须调用close，如果父进程对每个由accept返回的已连接套接字都不调用close，父进程最终将耗尽可用描述符，因为没有一个客户连接会被终止。当子进程关闭已连接套接字时，它的引用计数值将由2递减为1且保持为1,因为父进程永不关闭任何己连接套接字。这将妨碍TCP连接终止序列的发生，导致连接一直打开看。</p>
<ul>
<li>getsockname 和 getpeername 函数<br>
这两个函数或者返回与某个套接字关联的本地协议地址（getsockname）,或者返回与某个套接字关联的外地协议地址（getpeername）。</li>
</ul>
<pre><code>#include &lt;sys/socket.h&gt;
int getsockname （int sockfd, struct sockaddr *localaddr, socklen_t *addrlen）； 
int getpeername （int sockfd, struct sockaddr *peeraddr, socklen_t *addrlen）；
均返回：若成功则为0,若出错则为-1
</code></pre>
<p>两个函数的最后一个参数都是值-结果参数。这就是说，这两个函数都得装填由 localaddr或peeraddr指针所指的套接字地址结构。</p>
<p>需要这两个函数的理由如下所述。<br>
•在一个<strong>没有调用bind的TCP客户</strong>上，connect成功返回后，getsockname用于返回由内核赋予该连接的<strong>本地IP地址和本地端口号</strong>。<br>
•在以端口号0调用bind （告知内核去选择本地端口号）后，getsockname用于返回由内核赋予的<strong>本地端口号</strong>。<br>
• getsockname可用于获取某个<strong>套接字</strong>的地址族<br>
•在一个以通配IP地址调用bind的TCP服务器上，getsockname就可以用于返回由内核赋予该连接的本地IP地址。在 这样的调用中，套接字描述符参数必须是<strong>已连接套接字的描述符</strong>，<strong>而不是监听套接字的 描述符</strong>。<br>
•当一个服务器是由<strong>调用过accept</strong>的某个进程通过<strong>调用exec</strong>执行程序时，它能够<strong>获取客户身份</strong>的<strong>唯一途径</strong>便是调用<strong>getpeername</strong>。<br>
当子进程调用exec执行真正的服务器程序（譬如说Telnet服务器程序）时，子进程的内存映像被替换成新的Telnet服务器的程序文件（也就是说包含对端地址的那个套接字地址结构就此丢失），不过那个<strong>已连接套接字描述符 跨exec继续保持开放。</strong><br>
<img src="https://lixin-ee.github.io//post-images/1578886496011.png" alt=""></p>
<p>最后一个例子中的Telnet服务器必须在启动之后获取connfd的值。获取该值有两个 常用方法。第一种方法是，调用exec的进程可以把这个描述符号格式化成-个字符串，再把它 作为一个命令行参数传递给新程序。第二种方法是，约定在调用exec之前，总是把某个特定描 述符置为所接受的已连接套接字的描述符。inetd采用的是第二种方法，它总是把描述符0、1 和2置为所接受的已连接套接字的描述符。</p>
<p>在调用getsockname的时候，因为不知道要分配的套接字地址结构的类型，我们于是采用sockaddr_storage这个通 用结构，因为它能够承载系统支持的任何套接字地址结构。</p>
]]></content>
    </entry>
</feed>