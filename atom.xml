<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2020-01-03T13:07:20.941Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[UNP-UNIX网络编程  配置开发环境]]></title>
        <id>https://lixin-ee.github.io//post/unp-unix-wang-luo-bian-cheng-pei-zhi-kai-fa-huan-jing</id>
        <link href="https://lixin-ee.github.io//post/unp-unix-wang-luo-bian-cheng-pei-zhi-kai-fa-huan-jing">
        </link>
        <updated>2020-01-03T12:59:57.000Z</updated>
        <content type="html"><![CDATA[<p>在读完UNIX后，在实现自己的项目之前打算把UNP里面的代码实现一遍<br>
因为看完30章之后觉得太经典了，而且目前来说把apue里面的函数从头到尾手工敲一遍不太合适（代码太散，容易遗忘），不如在实现UNP的过程中把APUE当作字典来参照，在使用函数的过程中了解函数</p>
<p>UNP第一步就是配置开发环境<br>
一开始我把作者的源代码下下来以为直接用unp.h头文件就完事了<br>
后来报错后谷歌了一下才发现原来是需要先make编译的，所以还是得先配置好环境，不用以后每次都要导入一堆头文件或者编写makefile<br>
然后作者的代码还是有一些小瑕疵，需要对照着网上的指引教程来逐步避坑和处理系统环境</p>
<p>原文是<a href="https://lightsing.github.io/2016/07/22/unp-v1-day01/">Unix网络编程 - V1 - Day 01</a></p>
<p>配置开发环境<br>
在这本书中，作者给出了大量的例程，为了方便后续的学习，我们要把一些书中引用的库编译出来并配置好编译环境。</p>
<p>这本经典之作的官网是 Unix Network Programming ，我们可以在Sorce Code页面下载到本书所用到的所有源码 点我下载</p>
<p>编译所需的库<br>
本例中的编译环境： gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.1) 建议编译前更新软件</p>
<p>下载并解压之后我们能看到非常多的文件，但是我们只需要编译其中的两个文件夹。</p>
<ol>
<li>
<p>使用 ./configure 配置并生成必要的头文件 config.h</p>
</li>
<li>
<p>进入 lib 目录，执行 make 编译。 这条命令会在上层目录下生成 libunp.a 库，此时的库还是不完整的，有一些函数在第二个文件夹中。</p>
</li>
<li>
<p>进入 ../libfree 目录，执行 make 编译，不出意外会出现如下提示：</p>
</li>
</ol>
<pre><code>gcc -I../lib -g -O2 -D_REENTRANT -Wall   -c -o in_cksum.o in_cksum.c
gcc -I../lib -g -O2 -D_REENTRANT -Wall   -c -o inet_ntop.o inet_ntop.c
inet_ntop.c: In function ‘inet_ntop’:
inet_ntop.c:60:9: error: argument ‘size’ doesn’t match prototype
  size_t size;
         ^
In file included from inet_ntop.c:27:0:
/usr/include/arpa/inet.h:64:20: error: prototype declaration
 extern const char *inet_ntop (int __af, const void *__restrict __cp,
                    ^
&lt;builtin&gt;: recipe for target 'inet_ntop.o' failed
make: *** [inet_ntop.o] Error 1
</code></pre>
<p>出错原因是数据类型错误，解决方法很简单：</p>
<p>打开 inet_ntop.c ，向其中添加一行，将本程序当中的 size_t 替换为 socklen_t<br>
<code>#define size_t socklen_t</code></p>
<p>重新执行 make ，输出结果如下，编译成功：</p>
<pre><code>gcc -I../lib -g -O2 -D_REENTRANT -Wall   -c -o inet_ntop.o inet_ntop.c
/usr/include/arpa/inet.h: In function ‘inet_ntop’:
inet_ntop.c:152:23: warning: ‘best.len’ may be used uninitialized in this function [-Wmaybe-uninitialized]
   if (best.base == -1 || cur.len &gt; best.len)
                       ^
inet_ntop.c:123:28: note: ‘best.len’ was declared here
  struct { int base, len; } best, cur;
                            ^
gcc -I../lib -g -O2 -D_REENTRANT -Wall   -c -o inet_pton.o inet_pton.c
ar rv ../libunp.a in_cksum.o inet_ntop.o inet_pton.o
a - in_cksum.o
a - inet_ntop.o
a - inet_pton.o
ranlib ../libunp.a
</code></pre>
<ol start="4">
<li>配置环境<br>
将编译好的 libunp.a （在上层目录）复制到 /usr/lib 和 /usr/lib64 中：</li>
</ol>
<pre><code>sudo cp libunp.a /usr/lib
sudo cp libunp.a /usr/lib64
</code></pre>
<p>修改 unp.h 中的 #include &quot;../config.h&quot; 修改为 #include &quot;config.h&quot; 并将 unp.h 和 config.h 拷贝至 /usr/include，方便日后引用</p>
<pre><code>sudo cp lib/unp.h /usr/include
sudo cp config.h /usr/include
</code></pre>
<ol start="5">
<li>到这里我们的环境就配置好了，如果你不准备使用IDE，那么下面一段内容可以跳过，编译调用 gcc 的方法如下：</li>
</ol>
<p><code>gcc example.c -o example -lunp</code><br>
-lunp 指的是调用库 unp ，即我们之前所编译的出的 libunp.a</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Linux基础] BASH（鸟哥Linux第九章）]]></title>
        <id>https://lixin-ee.github.io//post/linux-ji-chu-bashniao-ge-linux-di-jiu-zhang</id>
        <link href="https://lixin-ee.github.io//post/linux-ji-chu-bashniao-ge-linux-di-jiu-zhang">
        </link>
        <updated>2020-01-03T05:43:12.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>bash基础概念<br>
透过『 Shell 』将我们输入的指令与 Kernel 沟通，好让 Kernel 可以 控制硬件来正确无误的工作<br>
操作系统其实是一组软件，这组软件在控制整个 硬件与管理系统的活动监测<br>
应用程序其实是在最外层，就如同鸡蛋的外壳一样，因此这个咚咚也就 被称呼为壳程序 (shell)<br>
包括 man, chmod, chown, vi, fdisk, mkfs 等等指令，这些指 令都是独立的应用程序， 但是我们可以透过壳程序 (就是指令列模式) 来操作这些应用程序<br>
Bourne Again SHell (简称 bash) ，这个 Shell 是 Bourne Shell 的增强版本，也是基准于 GNU 的架构下发展出来的</li>
</ul>
<p>命令记忆 (history)<br>
~/.bash_history 记录的是前一次登入以前所执行过的指令， 而至于这一次登入所执行的指令都被暂 存在内存中，当你成功的注销系统后，该指令记忆才会记录到 .bash_history 当中</p>
<p>命令与 文件 补全功能： ([tab] 按键的好处)<br>
[Tab] 接在一串指令的第一个字的后面，则为命令补全；<br>
[Tab] 接在一串指令的第二个字以后时，则为『文件补齐』！</p>
<p>命令别名设定功能： (alias)</p>
<p>工作控制、前景背景控制： (job control, foreground, background)</p>
<p>程序化脚本： (shell scripts)</p>
<p>通配符： (Wildcard)</p>
<p>查询指令是否为 Bash shell 的内建命令： type<br>
file ：表示为外部指令；<br>
alias ：表示该指令为命令别名所设定的名称；<br>
builtin ：表示该指令为 bash 内建的指令功能；</p>
<p>指令的下达与快速编辑按钮<br>
跳脱：[Enter] 按键是紧接着反斜杠 () 的，两者 中间没有其他字符。 因为 \ 仅跳脱『紧接着的下一个字符』而已，顺利跳脱 [Enter] 后，下一行最前面就会主动出现 &gt; 的符号</p>
<p>[ctrl]+u/[ctrl]+k 分别是从光标处向前删除指令串 ([ctrl]+u) 及向后删除指令串 ([ctrl]+k)。  （同时会删除历史记录！！！）<br>
[ctrl]+a/[ctrl]+e 分别是让光标移动到整个指令串的最前面 ([ctrl]+a) 或最后面 ([ctrl]+e)。</p>
<ul>
<li>
<p>Shell 的变量功能<br>
变量：变量就是以一组文字或符号等，来取代 一些设定或者是一串保留的数据<br>
PATH环境变量就是一个变量，搜寻完 PATH 变量内的路径还找不到指令时， 就会在屏幕上显示『 command not found 』的错误 讯息了。</p>
</li>
<li>
<p>变量的取用与设定echo、变量设定规则 unset<br>
echo 这个指令来取用变量（<strong>不等同于新建变量</strong>）， 但是，变量在被取用时，前面 必须要加上钱字号『 $ 』，否则就是直接显示变量名</p>
</li>
</ul>
<p>『设定』（<strong>亦即新建</strong>）或者是『修改』，直接用『等号(=)』连接变量与他的内容<br>
在 bash 当中，当一个变量名称尚未被设定时，预设的内容是『空』的（亦即强心echo）<br>
但每一种 shell 的语法都不相同，在变量的使用上，bash 在你没有设定的变量中强迫去 echo 时，它会显示出空的值。 在其他某些 shell 中，随便去echo一个不存在的变量，它是会出现错误讯息的</p>
<ul>
<li>变量的设定规则</li>
</ul>
<ol>
<li>变量与变量内容以一个等号『=』来连结</li>
<li>等号两边不能直接接空格符</li>
<li>变量名称只能是英文字母与数字，但是开头字符不能是数字</li>
<li>变量内容若有空格符可使用双引号『&quot;』或单引号『'』将变量内容结合起来<br>
例外：1 双引号内的特殊字符如 $ 等，可以保有原本的特性<br>
2 单引号内的特殊字符则仅为一般字符 (纯文本)</li>
<li>可用跳脱字符『 \ 』将特殊符号(如 [Enter], $, , 空格符, '等)变成一般字符</li>
<li>在一串指令的执行中，还需要藉由其他额外的指令所提供的信息时，可以使用反单引号『<code>指令</code>』或 『$(指 令)』。特别注意，那个 ` 是键盘上方的数字键 1 左边那个按键，而不是单引号</li>
<li>若该变量为扩增变量内容时，则可用 &quot;$变量名称&quot; 或 ${变量} 累加内容</li>
<li>若该变量需要在其他子程序执行，则需要以 export 来使变量变成环境变量</li>
<li>通常大写字符为系统默认变量，自行设定变量可以使用小写字符</li>
<li>取消变量的方法为使用 unset</li>
</ol>
<ul>
<li>环境变量的功能<br>
shell 环境的环境变量查询分别是 env 与 export</li>
</ul>
<p>用 env 观察环境变量与常见环境变量说明，env 是 environment (环境) 的简写</p>
<p>用 set 观察所有变量 (含环境变量与自定义变量)<br>
set 除了环境变量之外， 还 会将其他在 bash 内的变量通通显示出来（自己设置的变量也会显示出来）<br>
基本上，在 Linux 预设的情况中，使用{大写的字母}来设定的变量 一般为系统内定需要的变量</p>
<p>$：(关于本 shell 的 PID) 钱字号本身也是个变量，代表的是『目前这个 Shell 的线程代号』，亦即是所谓的 PID (Process ID)，『 echo $$ 』出现的数字就是你的 PID 号码</p>
<p>?：(关于上个执行指令的回传值)『上 一个执行的指令所回传的值』，当我们执行某些指令时， 这些指令都会回传一个执行后的代码。一般来说，如果成功的执行该指令， 则会回传一个 0 值</p>
<p>export ： 自定义变量转成环境变量，分享自己的变量设定给后来呼叫的文件或其他程序<br>
环境变量与自定义变量这两 者的差异在于『 该变量是否会被子程序所继续引用』<br>
子程序仅会继承父程序的环境变量， 子程序不 会继承父程序的自定义变量<br>
仅下达 export 而没有接变量时，那么此时将会把所有的『环境变量』显示出来</p>
<ul>
<li>
<p>影响显示结果的语系变量 (locale)</p>
</li>
<li>
<p>变量的有效范围<br>
环境变量=全局变量<br>
自定义变数=局部变量</p>
</li>
</ul>
<ol>
<li>当启动一个 shell，操作系统会分配一记忆区块给 shell 使用，此内存内之变量可让子程序取用</li>
<li>若在父程序利用 export 功能，可以让自定义变量的内容写到上述的记忆区块当中(环境变量)；</li>
<li>当加载另一个 shell 时 (亦即启动子程序，而离开原本的父程序了)，子 shell 可以将父 shell 的环境变量所 在的记忆区块导入自己的环境变量区块当中。</li>
</ol>
<ul>
<li>变量键盘读取、数组与宣告： read, array, declare</li>
</ul>
<ol>
<li>
<p>read<br>
读取来自键盘输入的变量<br>
[dmtsai@study ~]$ read [- - pt] variable<br>
选项与参数：<br>
-p ：后面可以接提示字符！<br>
-t ：后面可以接等待的『秒数！』</p>
</li>
<li>
<p>declare / typeset<br>
declare 或 typeset 是一样的功能，就是在『宣告变量的类型』<br>
如果使用 declare 后面并没有接任何 参数，那么 bash 就会主动的将所有的变量名称与内容通通叫出来<br>
[dmtsai@study ~]$ declare [- - aixr] variable<br>
选项与参数：<br>
-a ：将后面名为 variable 的变量定义成为数组 (array) 类型<br>
-i ：将后面名为 variable 的变量定义成为整数数字 (integer) 类型<br>
-x ：用法与 export 一样，就是将后面的 variable 变成环境变量；<br>
-r ：将变量设定成为 readonly 类型，该变量不可被更改内容，也不能 unset</p>
</li>
</ol>
<p>变量类型默认为『字符串』，所以若不指定变量类型，<strong>则 1+2 为一个『字符串』</strong> 而不是『计算式』。 所以 上述第一个执行的结果才会出现那个情况的；<br>
bash 环境中的数值运算，预设最多仅能到达整数形态，所以 1/3 结果是 0；</p>
<ul>
<li>
<p>ulimit文件系统及程序的限制关系<br>
bash 是可以『限制用户的某些系统资源』的，包括可以开启的文件数量， 可 以使用的 CPU 时间，可以使用的内存总量等等</p>
</li>
<li>
<p>变量内容的删除、取代与替换 (Optional)<br>
<img src="https://lixin-ee.github.io//post-images/1578042049345.png" alt=""></p>
</li>
<li>
<p>变量的测试与内容替换<br>
需要『判断』某个变量是否存在，若变量存在则使用既有的设定，若变量不存在<br>
则给予一个常用的设定<br>
<img src="https://lixin-ee.github.io//post-images/1578042065695.png" alt=""><br>
<img src="https://lixin-ee.github.io//post-images/1578042077141.png" alt=""></p>
</li>
<li>
<p>命令别名设定： alias, unalias<br>
适用于惯用指令特别长 例如  alias lm='ls -al | more '<br>
『alias 的定义规则与变量定义规则几乎相同</p>
</li>
<li>
<p>历史命令：history<br>
执行上一个指令， 除了使用上下键之外，我可以直接以『 !! 』 来下达上个指令的内容<br>
同一账号同时多次登入的 history，最后注销的那个 bash 才会是最后写入的数据。如此一来其他 bash 的指令操作就不会被记录下来了 (其实有被记录，只是被后来的最后一个 bash 所覆盖更新了)</p>
</li>
<li>
<p>路径与指令搜寻顺序<br>
指令运作的顺序可以这样看：</p>
</li>
</ul>
<ol>
<li>以相对/绝对路径执行指令，例如『 /bin/ls 』或『 ./ls 』；</li>
<li>由 alias 找到该指令来执行；</li>
<li>由 bash 内建的 (builtin) 指令来执行；</li>
<li>透过 $PATH 这个变量的顺序搜寻到的第一个指令来执行。</li>
</ol>
<ul>
<li>
<p>bash  的进站与欢迎讯息： /etc/issue, /etc/motd</p>
</li>
<li>
<p>bash<br>
统有一些环境配置文件案的存在，又可以分为全体系统的配置文件以及用户个人偏好配置文<br>
login shell 其实只会读取这两个配置文件：</p>
</li>
</ul>
<ol>
<li>/etc/profile：这是系统整体的设定，你最好不要修改这个文件；</li>
<li>~/.bash_profile 或 ~/.bash_login 或 ~/.profile：属于使用者个人设定，你要改自己的数据，就写入这里</li>
</ol>
<p>source 读入环境配置文件的指令</p>
<ul>
<li>终端机的环境设定： stty, set<br>
查阅目前的一些按键内容（其实就是发送给进程的信号）：stty -a(setting tty 终端机的意思)<br>
intr : 送出一个 interrupt (中断) 的讯号给目前正在 run 的程序 (就是终止啰！)；<br>
quit : 送出一个 quit 的讯号给目前正在 run 的程序；<br>
erase : 向后删除字符，<br>
kill : 删除在目前指令列上的所有文字；<br>
eof : End of file 的意思，代表『结束输入』。<br>
start : 在某个程序停止后，重新启动他的 output<br>
stop : 停止目前屏幕的输出；<br>
susp : 送出一个 terminal stop 的讯号给正在 run 的程序</li>
</ul>
<p>利用 set 来设定自己的一些bash终端机设定值</p>
<p>bash 默认的组合键<br>
Ctrl + C 终止目前的命令<br>
Ctrl + D 输入结束 (EOF)，例如邮件结束的时候；<br>
Ctrl + M 就是 Enter 啦！<br>
Ctrl + S 暂停屏幕的输出<br>
Ctrl + Q 恢复屏幕的输出<br>
Ctrl + U 在提示字符下，将整列命令删除<br>
Ctrl + Z 『暂停』目前的命令</p>
<ul>
<li>
<p>通配符与特殊符号<br>
<img src="https://lixin-ee.github.io//post-images/1578043210202.png" alt=""><br>
<img src="https://lixin-ee.github.io//post-images/1578043240777.png" alt=""></p>
</li>
<li>
<p>数据流重导向<br>
标准输出指的是『指令执行所回传的正确的讯息』，而标准错误输出可理解为『 指令执行失败后，所回传的错误讯息』<br>
数据流重导向可以将 standard output(简称 stdout) 与 standard error output (简称 stderr) 分别传送到其他的文件或装置去</p>
</li>
</ul>
<ol>
<li>标准输入 (stdin) ：代码为 0 ，使用 &lt; 或 &lt;&lt; ；</li>
<li>标准输出 (stdout)：代码为 1 ，使用 &gt; 或 &gt;&gt; ；</li>
<li>标准错误输出(stderr)：代码为 2 ，使用 2&gt; 或 2&gt;&gt; ；</li>
</ol>
<p>注意：</p>
<ol>
<li>该文件 (本例中是 ~/rootfile) 若不存在，系统会自动的将他建立起来，但是</li>
<li>当这个文件存在的时候，那么系统就会先将这个文件内容清空，然后再将数据写入！</li>
<li>也就是若以 &gt; 输出到一个已存在的文件中，那个文件就会被覆盖掉，用&gt;&gt;才是累加</li>
</ol>
<p>1&gt; ：以覆盖的方法将『正确的数据』输出到指定的文件或装置上；<br>
1&gt;&gt;：以累加的方法将『正确的数据』输出到指定的文件或装置上；<br>
2&gt; ：以覆盖的方法将『错误的数据』输出到指定的文件或装置上；<br>
2&gt;&gt;：以累加的方法将『错误的数据』输出到指定的文件或装置上；</p>
<ul>
<li>/dev/null 垃圾桶黑洞装置与特殊写法<br>
/dev/null 可以吃掉任何导向这个装置的信息，适用于要将讯息忽略掉而不显示或储存</li>
</ul>
<p>由于两股数据同时写入一个文件，又没有使用特殊的语法， 此时两 股数据可能会交叉写入该文件内，造成次序的错乱 写入同一个文件可以使用 2&gt;&amp;1 也可以使用 &amp;&gt;</p>
<ul>
<li>
<p>standard input ： &lt; 与 &lt;&lt;<br>
&lt;  将原本需要由键盘输入的数据，改由文件内容来取代<br>
&lt;&lt; 这个连续两个小于的符号了。 他代表的是『结束的输入字符』的意思</p>
</li>
<li>
<p>命令执行的判断依据： ; , &amp;&amp;, ||<br>
一次执行多个指令，在指令与指令中间利用分号 (;) 来隔开<br>
如果这两个指令彼 此之间是有相关性的， 前一个指令是否成功的执行与后一个指令是否要执行有关！那就得动用到 &amp;&amp; 或 ||<br>
若前一个指令执行的结果为正确，在 Linux 底下会回传一个 $? = 0 的值<br>
<img src="https://lixin-ee.github.io//post-images/1578044192091.png" alt=""><br>
由于指令是一个接着一个去执行的，因此，如果真要使用判断， 那么这个 &amp;&amp; 与 || 的顺序就不能搞错<br>
条件易变的判断放在前面，结果比较肯定的可以放在后面</p>
</li>
<li>
<p>管线命令 (pipe)<br>
管线命令使用的是『 | 』这个界定符号！ 另外，管线命令与『连续下达命令』是不一样的<br>
这个管 线命令『 | 』<strong>仅能处理经由前面一个指令传来的正确信息</strong>，也就是standard output 的信息，对于 stdandard error 并没有直接处理的能力。<br>
每个管线后面接的第一个数据必定是『指令』！而且这个指令必须要能够接受 standard input 的 数据才行，这样的指令才可以是为 <strong>『管线命令』</strong></p>
</li>
</ul>
<p>管线命令仅会处理 standard output，对于 standard error output 会予以忽略<br>
管线命令必须要能够接受来自前一个指令的数据成为 standard input 继续处理才行。</p>
<p>如果硬要让 standard error 可以被管线命令所使用，那得用上一小节的数据流重导向， 让 2&gt;&amp;1 加入指令中～就可以让 2&gt; 变成 1&gt;</p>
<ul>
<li>
<p>撷取命令： cut, grep<br>
cut将一段讯息的某一段给他『切』出来，主要的用途在于将『同一行里面的数据进行分解！』最常使用在分析一些数据或文字数据<br>
grep则是分析一行讯息， 若当中有我 们所需要的信息，就将该行拿出来</p>
</li>
<li>
<p>排序命令： sort, wc, uniq<br>
sort 可以依据不同的数据型态来排序<br>
uniq将重复的资料仅列出一个显示<br>
wc 计算里面有多少字、多少行、多少字符的话</p>
</li>
<li>
<p>双向重导向： tee<br>
将这个数据流的处理过程中将某段讯息存下来，tee 会同时将数据流分送到文件去与屏幕 (screen)</p>
</li>
<li>
<p>字符转换命令： tr, col, join, paste, expand<br>
tr 可以用来删除一段讯息当中的文字，或者是进行文字讯息的替<br>
col  可以用来简单的处理将 [tab] 按键取代成为空格键<br>
join 处理两个文件之间的数据，『两个文件当中，有 &quot; 相同数据&quot; 的那一行，才将他加在一起』，但在使用 join 之前，所需要处理的文件应该要事先经过排序 (sort) 处理<br>
paste 就直接 『将两行贴在一起，且中间以 [tab] 键隔开』<br>
expand 将 [tab] 按键转成空格键</p>
</li>
<li>
<p>分区 命令： split<br>
将一个大文件，依据文件大小或行数来分区，就可以将大文件分区成为小文件了</p>
</li>
<li>
<p>参数代换： xargs<br>
产生某个指令的参数，xargs 可以读入 stdin 的数据，并 且以空格符或断行字符作为分辨，将 stdin 分隔成为 arguments<br>
很多指令其实并不支持管 线命令，因此可以透过 xargs 来提供该指令引用standard input</p>
</li>
<li>
<p>关于减号 - 的用途<br>
在管线命令当中，常常会使用到前一个指令的 stdout 作为这次的 stdin ， 某些指令需要用到文件名 (例如 tar) 来进行处理时，该 stdin 与 stdout 可以利用减号 &quot;-&quot; 来替代</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 20. 有效的括号[字符串][栈]]]></title>
        <id>https://lixin-ee.github.io//post/zi-fu-chuan-20-you-xiao-de-gua-hao-zi-fu-chuan-zhan</id>
        <link href="https://lixin-ee.github.io//post/zi-fu-chuan-20-you-xiao-de-gua-hao-zi-fu-chuan-zhan">
        </link>
        <updated>2020-01-03T02:03:35.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。<br>
有效字符串需满足：<br>
左括号必须用相同类型的右括号闭合。<br>
左括号必须以正确的顺序闭合。<br>
注意空字符串可被认为是有效字符串。<br>
示例 1:<br>
输入: &quot;()&quot;<br>
输出: true<br>
示例 2:<br>
输入: &quot;()[]{}&quot;<br>
输出: true<br>
示例 3:<br>
输入: &quot;(]&quot;<br>
输出: false<br>
示例 4:<br>
输入: &quot;([)]&quot;<br>
输出: false<br>
示例 5:<br>
输入: &quot;{[]}&quot;<br>
输出: true<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/valid-parentheses<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>第一想法就是单栈hhh<br>
然后想用istringstream来试一下<br>
首先判断s的size 如果是奇数的话可以直接木大了<br>
istringstream翻车了，没有找到能从字符串流读取单个字符的函数<br>
然后最后必须判断栈是否为空，因为可能有&quot;((&quot;的情况存在<br>
然后就是&quot;){&quot;这种鬼情况 所以在右括号中的switch中也必须判断栈是否为空，注意一定要优先判断empty ||关系运算符是先左后右，否则先temp.top()还是会报错<br>
运行结果很差，得好好看看题解的优化</p>
<pre><code>class Solution {
public:
    bool isValid(string s) {
        if(s.empty()) return true;
        if(s.size()%2) return false;
        stack&lt;char&gt; temp;
        //istringstream is(s);
        //char c;
        for(auto cr=s.begin();cr&lt;s.end();++cr){
            char c=*cr;
            if(c=='('||c=='{'||c=='['){
                temp.push(c);
                continue;
            }
            switch (c){
                    case')':
                    if(temp.empty()||temp.top()!='(') return false; else temp.pop(); break;
                    case'}':
                    if(temp.empty()||temp.top()!='{') return false; else temp.pop(); break;
                    case']':
                    if(temp.empty()||temp.top()!='[') return false; else temp.pop(); break;
            }    
        }
        if(temp.empty())
            return true;
        else
            return false;
    }
};
</code></pre>
<p>来看官方题解</p>
<blockquote>
<p>思路<br>
想象一下，你正在为你的大学课设编写一个小型编译器，编译器的任务之一（或称子任务）将检测括号是否匹配。<br>
我们本文中看到的算法可用于处理编译器正在编译的程序中的所有括号，并检查是否所有括号都已配对。这将检查给定的括号字符串是否有效，是一个重要的编程问题。<br>
我们这个问题中将要处理的表达式可以包含以下三种不同类型的括号：<br>
()，<br>
{} 以及<br>
[]<br>
在查看如何检查由这些括号组成的给定表达式是否有效之前，让我们看一下该问题的简化版本，在简化后的问题中，只含一种类型的括号。这么一来，我们将会遇到的表达式是<br>
(((((()))))) -- VALID<br>
()()()()     -- VALID<br>
(((((((()    -- INVALID<br>
((()(())))   -- VALID<br>
上我们试着用一个简单的算法来解决这一问题。<br>
我们从表达式的左侧开始，每次只处理一个括号。<br>
假设我们遇到一个开括号（即 (），表达式是否无效取决于在该表达式的其余部分的某处是否有相匹配的闭括号（即 )）。此时，我们只是增加计数器的值保持跟踪现在为止开括号的数目。left += 1<br>
如果我们遇到一个闭括号，这可能意味着这样两种情况：<br>
此闭括号没有与与之对应的开括号，在这种情况下，我们的表达式无效。当 left == 0，也就是没有未配对的左括号可用时就是这种情况。<br>
我们有一些未配对的开括号可以与该闭括号配对。当 left &gt; 0，也就是有未配对的左括号可用时就是这种情况。<br>
如果我们在 left == 0 时遇到一个闭括号（例如 )），那么当前的表达式无效。否则，我们会减少 left 的值，也就是减少了可用的未配对的左括号的数量。<br>
继续处理字符串，直到处理完所有括号。<br>
如果最后我们仍然有未配对的左括号，这意味着表达式无效。<br>
如果我们只是尝试对原始问题采用相同的办法，这是根本就行不通的。基于简单计数器的方法能够在上面完美运行是因为所有括号都具有相同的类型。因此，当我们遇到一个闭括号时，我们只需要假设有一个对应匹配的开括号是可用的，即假设 left &gt; 0。<br>
但是，在我们的问题中，如果我们遇到 ]，我们真的不知道是否有相应的<code>[</code>可用。你可能会问：<br>
为什么不为不同类型的括号分别维护一个单独的计数器？<br>
这可能不起作用，因为括号的相对位置在这里也很重要。例如：<br>
[{]<br>
如果我们只是在这里维持计数器，那么只要我们遇到闭合方括号，我们就会知道此处有一个可用的未配对的开口方括号。但是，最近的未配对的开括号是一个花括号，而不是一个方括号，因此计数方法在这里被打破了。<br>
方法：栈<br>
关于有效括号表达式的一个有趣属性是有效表达式的子表达式也应该是有效表达式。（不是每个子表达式）例如</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1578017270229.png" alt=""></p>
<blockquote>
<p>此外，如果仔细查看上述结构，颜色标识的单元格将标记开闭的括号对。整个表达式是有效的，而它的子表达式本身也是有效的。这为问题提供了一种递归结构。例如，考虑上图中两个绿色括号内的表达式。开括号位于索引 1，相应闭括号位于索引 6。<br>
如果每当我们在表达式中遇到一对匹配的括号时，我们只是从表达式中删除它，会发生什么？<br>
让我们看看下面的这个想法，从整体表达式中一次删除一个较小的表达式，因为这是一个有效的表达式，我们最后剩留下一个空字符串。<br>
在表示问题的递归结构时，栈数据结构可以派上用场。我们无法真正地从内到外处理这个问题，因为我们对整体结构一无所知。但是，栈可以帮助我们递归地处理这种情况，即从外部到内部。<br>
让我们看看使用栈作为该问题的中间数据结构的算法。</p>
</blockquote>
<blockquote>
<p>算法<br>
初始化栈 S。<br>
一次处理表达式的每个括号。<br>
如果遇到开括号，我们只需将其推到栈上即可。这意味着我们将稍后处理它，让我们简单地转到前面的 子表达式。<br>
如果我们遇到一个闭括号，那么我们检查栈顶的元素。如果栈顶的元素是一个 相同类型的 左括号，那么我们将它从栈中弹出并继续处理。否则，这意味着表达式无效。<br>
如果到最后我们剩下的栈中仍然有元素，那么这意味着表达式无效。</p>
</blockquote>
<pre><code>class Solution {

  // Hash table that takes care of the mappings.
  private HashMap&lt;Character, Character&gt; mappings;

  // Initialize hash map with mappings. This simply makes the code easier to read.
  public Solution() {
    this.mappings = new HashMap&lt;Character, Character&gt;();
    this.mappings.put(')', '(');
    this.mappings.put('}', '{');
    this.mappings.put(']', '[');
  }

  public boolean isValid(String s) {

    // Initialize a stack to be used in the algorithm.
    Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();

    for (int i = 0; i &lt; s.length(); i++) {
      char c = s.charAt(i);

      // If the current character is a closing bracket.
      if (this.mappings.containsKey(c)) {

        // Get the top element of the stack. If the stack is empty, set a dummy value of '#'
        char topElement = stack.empty() ? '#' : stack.pop();

        // If the mapping for this bracket doesn't match the stack's top element, return false.
        if (topElement != this.mappings.get(c)) {
          return false;
        }
      } else {
        // If it was an opening bracket, push to the stack.
        stack.push(c);
      }
    }

    // If the stack still contains elements, then it is an invalid expression.
    return stack.isEmpty();
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)，因为我们一次只遍历给定的字符串中的一个字符并在栈上进行 O(1) 的推入和弹出操作。<br>
空间复杂度：O(n)，当我们将所有的开括号都推到栈上时以及在最糟糕的情况下，我们最终要把所有括号推到栈上。例如 ((((((((((。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Linux基础] vim  程序编辑器（鸟哥Linux第八章）]]></title>
        <id>https://lixin-ee.github.io//post/linux-ji-chu-vim-cheng-xu-bian-ji-qi-niao-ge-linux-di-ba-zhang</id>
        <link href="https://lixin-ee.github.io//post/linux-ji-chu-vim-cheng-xu-bian-ji-qi-niao-ge-linux-di-ba-zhang">
        </link>
        <updated>2020-01-02T08:16:24.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p>vim 是『程序编辑器』<br>
vim 会依据文件的扩展名或者是文件内的开头信息， 判断该文件的内容而自动的呼叫该程序的语法判断式，再以颜色来显示程序代码与一般信息。</p>
</li>
<li>
<p>vi 的使用<br>
o 一般指令模式 (command mode)<br>
以 vi 打开一个文件就直接进入一般指令模式了(这是默认的模式，也简称为一般模式)。在这个模 式中， 你可以使用『上下左右』按键来移动光标，你可以使用『删除字符』或『删除整列』来处 理文件内容， 也可以使用『复制、贴上』来处理你的文件数据。<br>
o 编辑模式 (insert mode)<br>
在一般指令模式中可以进行删除、复制、贴上等等的动作，但是却无法编辑文件内容的！ 要等到 你按下『i, I, o, O, a, A, r, R』等任何一个字母之后才会进入编辑模式。注意了！通常在 Linux 中，按下这些按键时，在画面的左下方会出现『 INSERT 或 REPLACE 』的字样，此时才可以进 行编辑。而如果要回到一般指令模式时， 则必须要按下『Esc』这个按键即可退出编辑模式。<br>
o 指令列命令模式 (command-line mode)<br>
在一般模式当中，输入『 : / ? 』三个中的任何一个按钮，就可以将光标移动到最底下那一列。在 这个模式当中， 可以提供你『搜寻资料』的动作，而读取、存盘、大量取代字符、离开 vi 、显 示行号等等的动作则是在此模式中达成的<br>
<img src="https://lixin-ee.github.io//post-images/1577953264909.png" alt=""><br>
一般指令模式可与编辑模式及指令列模式切换， 但编辑模式与指令列模式之间不可互相切换</p>
</li>
</ul>
<p>使用过程<br>
1.使用『 vi filename 』进入一般指令模式<br>
2.按下 i 进入编辑模式，开始编辑文字<br>
一般指令模式之中，只要按下 i, o, a 等字符就可以进入编辑模式，左下角状态栏中会出现 –INSERT-<br>
3.按下 [ESC] 按钮回到一般指令模式<br>
4.进入指令列模式，文件储存并离开 vi 环境<br>
输入『:wq』即可存档离开</p>
<ul>
<li>
<p>按键说明</p>
</li>
<li>
<p>一般指令模式可用的按钮说明<br>
常用指令如下，完全版指令查看9.2.2按键说明<br>
[Ctrl] + [f] 屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)<br>
[Ctrl] + [b] 屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)<br>
0 或功能键[Home] 这是数字『 0 』：移动到这一列的最前面字符处 (常用)<br>
$ 或功能键[End] 移动到这一列的最后面字符处(常用)<br>
G 移动到这个文件的最后一列(常用)<br>
gg 移动到这个文件的第一列，相当于 1G 啊！ (常用)<br>
<code>n&lt;Enter&gt;n</code> 为数字。光标向下移动 n 列(常用)<br>
/word 向光标之下寻找一个名称为 word 的字符串。例如要在文件内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用)<br>
:n1,n2s/word1/word2/g   n1 与 n2 为数字。在第 n1 与 n2 列之间寻找 word1 这个字符串，并将该字符串取代 为 word2 ！举例来说，在 100 到 200 列之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s/vbird/VBIRD/g』。(常用)<br>
:1,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi mathvariant="normal">/</mi><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi><mn>1</mn><mi mathvariant="normal">/</mi><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi><mn>2</mn><mi mathvariant="normal">/</mi><mi>g</mi><mi mathvariant="normal">从</mi><mi mathvariant="normal">第</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">列</mi><mi mathvariant="normal">到</mi><mi mathvariant="normal">最</mi><mi mathvariant="normal">后</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">列</mi><mi mathvariant="normal">寻</mi><mi mathvariant="normal">找</mi><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi><mn>1</mn><mi mathvariant="normal">字</mi><mi mathvariant="normal">符</mi><mi mathvariant="normal">串</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">并</mi><mi mathvariant="normal">将</mi><mi mathvariant="normal">该</mi><mi mathvariant="normal">字</mi><mi mathvariant="normal">符</mi><mi mathvariant="normal">串</mi><mi mathvariant="normal">取</mi><mi mathvariant="normal">代</mi><mi mathvariant="normal">为</mi><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi><mn>2</mn><mi mathvariant="normal">！</mi><mo>(</mo><mi mathvariant="normal">常</mi><mi mathvariant="normal">用</mi><mo>)</mo><mo>:</mo><mn>1</mn><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">s/word1/word2/g  从第一列到最后一列寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)
:1,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord">2</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord cjk_fallback">从</span><span class="mord cjk_fallback">第</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">列</span><span class="mord cjk_fallback">到</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">列</span><span class="mord cjk_fallback">寻</span><span class="mord cjk_fallback">找</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord">1</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">符</span><span class="mord cjk_fallback">串</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">并</span><span class="mord cjk_fallback">将</span><span class="mord cjk_fallback">该</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">符</span><span class="mord cjk_fallback">串</span><span class="mord cjk_fallback">取</span><span class="mord cjk_fallback">代</span><span class="mord cjk_fallback">为</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord">2</span><span class="mord cjk_fallback">！</span><span class="mopen">(</span><span class="mord cjk_fallback">常</span><span class="mord cjk_fallback">用</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span></span></span></span>s/word1/word2/gc  从第一列到最后一列寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显 示提示字符给用户确认 (confirm) 是否需要取代！(常用)<br>
x, X 在一列字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字 符(相当于 [backspace] 亦即是退格键) (常用)<br>
dd 删除游标所在的那一整列(常用)<br>
ndd n 为数字。删除光标所在的向下 n 列，例如 20dd 则是删除 20 列 (常用)<br>
yy 复制游标所在的那一列(常用)<br>
nyy n 为数字。复制光标所在的向下 n 列，例如 20yy 则是复制 20 列(常用)<br>
p, P p 为将已复制的数据在光标下一列贴上，P 则为贴在游标上一列！ 举例来说，我目前 光标在第 20 列，且已经复制了 10 列数据。则按下 p 后， 那 10 列数据会贴在原本 的 20 列之后，亦即由 21 列开始贴。但如果是按下 P 呢？ 那么原本的第 20 列会被 推到变成 30 列。 (常用)<br>
u 复原前一个动作。(常用)<br>
[Ctrl]+r 重做上一个动作。(常用)<br>
. 不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重 复贴上等等动作，按下小数点『.』就好了！ (常用)</p>
</li>
<li>
<p>进入插入或取代的编辑模式<br>
i, I 进入插入模式(Insert mode)： i 为『从目前光标所在处插入』， I 为『在目前所在列的第一个非空格符处开始插入』。 (常用)<br>
a, A 进入插入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始插入』， A 为『从光标所在列的最后一个 字符处开始插入』。(常用)<br>
o, O 进入插入模式(Insert mode)： 这是英文字母 o 的大小写。o 为『在目前光标所在的下一列处插入新的一列』； O 为 在目前光标所在处的上一列插入新的一列！(常用)<br>
r, R 进入取代模式(Replace mode)： r 只会取代光标所在的那一个字符一次；R 会一直取代光标所在的文字，直到按下 ESC 为止；(常用)<br>
上面这些按键中，在 vi 画面的左下角处会出现『--INSERT--』或『--REPLACE--』的字样。 由名称就知道该动作了 吧！！特别注意的是，我们上面也提过了，你想要在文件里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入<br>
[Esc] 退出编辑模式，回到一般指令模式中(常用)</p>
</li>
<li>
<p>指令列模式的可用按钮说明<br>
:w 将编辑的数据写入硬盘文件中(常用)<br>
:q 离开 vi (常用)<br>
:wq 储存后离开，若为 :wq! 则为强制储存后离开 (常用)</p>
</li>
</ul>
<p>在 vi 中，『数字』是很有意义的！数字通常代表重复做几次的意思！ 也有可能是代表 去到第几个什么什么的意思</p>
<ul>
<li>暂存档、救援回复与开启时的警告讯息<br>
在使用 vim 编辑时， vim 会在与被编辑的文件的目录下，再建立一个名为 .filename.swp 的 文件。</li>
</ul>
<p>发现暂存盘警告讯息的画面中，有出现六个可用按钮，各按钮的说明如下：<br>
(O)pen Read-Only：打开此文件成为只读档， 可以用在你只是想要查阅该文件内容并不想要进行编辑行为 时。一般来说，在上课时，如果你是登入到同学的计算机去看他的配置文件， 结果发现其实同学他自己也 在编辑时，可以使用这个模式；<br>
(E)dit anyway：还是用正常的方式打开你要编辑的那个文件， 并不会载入暂存盘的内容。不过很容易出现 两个使用者互相改变对方的文件等问题！不好不好！<br>
(R)ecover：就是加载暂存盘的内容，用在你要救回之前未储存的工作。 不过当你救回来并且储存离开 vim 后，还是要手动自行删除那个暂存档喔！<br>
(D)elete it：你确定那个暂存档是无用的！那么开启文件前会先将这个暂存盘删除！ 这个动作其实是比较常 做的！因为你可能不确定这个暂存档是怎么来的，所以就删除掉他吧！<br>
(Q)uit：按下 q 就离开 vim ，不会进行任何动作回到命令提示字符。<br>
(A)bort：忽略这个编辑行为，感觉上与 quit 非常类似！ 也会送你回到命令提示字符就是啰！</p>
<ul>
<li>
<p>vim 的额外功能（相较于vi）</p>
</li>
<li>
<p>区块选择(Visual Block)<br>
区块选择的按键意义<br>
v 字符选择，会将光标经过的地方反白选择！<br>
V 列选择，会将光标经过的列反白选择！<br>
[Ctrl]+v 区块选择，可以用长方形的方式选择资料<br>
y 将反白的地方复制起来<br>
d 将反白的地方删除掉<br>
p 将刚刚复制的区块，在游标所在处贴上！</p>
</li>
<li>
<p>多文件编辑<br>
多文件编辑的按键<br>
vim file1 file2 file3...<br>
:n 编辑下一个文件<br>
:N 编辑上一个文件<br>
:files 列出目前这个 vim 的开启的所有文件</p>
</li>
<li>
<p>多窗口功能<br>
在指令列模式输入『:sp {filename}』<br>
如果想要在新窗口启动另一个文件，就加入档名，否则仅输入 :sp 时， 出现的则是同一个文件在两个窗口间</p>
</li>
</ul>
<p>多窗口情况下的按键功能 :<br>
sp [filename] 开启一个新窗口，如果有加 filename， 表示在新窗口开启一个新文件，否则表示两个窗口 为同一个文件内容(同步显示)。<br>
[ctrl]+w+ j [ctrl]+w+↓ 按键的按法是：先按下 [ctrl] 不放， 再按下 w 后放开所有的按键，然后再按下 j (或向 下箭头键)，则光标可移动到下方的窗口。 [ctrl]+w+ k [ctrl]+w+↑ 同上，不过光标移动到上面的窗口。 [ctrl]+w+ q 其实就是 :q 结束离开啦！ 举例来说，如果我想要结束下方的窗口，那么利用 [ctrl]+w+ ↓ 移动到下方窗口后，按下 :q 即可离开， 也可以按下 [ctrl]+w+q 啊</p>
<ul>
<li>
<p>挑字补全功能<br>
[ctrl]+x -&gt; [ctrl]+n 透过目前正在编辑的这个『文件的内容文字』作为关键词，予以补齐<br>
[ctrl]+x -&gt; [ctrl]+f 以当前目录内的『文件名』作为关键词，予以补齐<br>
[ctrl]+x -&gt; [ctrl]+o 以扩展名作为语法补充，以 vim 内建的关键词，予以补齐</p>
</li>
<li>
<p>环境设定与记录： ~/.vimrc, ~/.viminfo<br>
vim 会主动的将你曾经做过的行为登录下来，好让你下次可以轻松的作业啊！ 那个 记录动作的文件就是： ~/.viminfo<br>
整体 vim 的设定值一般是放置在 /etc/vimrc 这个文件，不过，不建议你修改他！ 你可以修改 ~/.vimrc 这 个文件<br>
set hlsearch &quot;高亮度反白<br>
set backspace=2 &quot;可随时用退格键删除<br>
set autoindent &quot;自动缩排<br>
set ruler &quot;可显示最后一列的状态<br>
set showmode &quot;左下角那一列的状态<br>
set nu &quot;可以在每一列的最前面显示行号啦！<br>
set bg=dark &quot;显示不同的底色色调<br>
syntax on &quot;进行语法检验，颜色显示。</p>
</li>
<li>
<p>vim 常用指令示意图<br>
<img src="https://lixin-ee.github.io//post-images/1577955542874.png" alt=""></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 88. 合并两个有序数组[简单][双指针]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-88-he-bing-liang-ge-you-xu-shu-zu-jian-dan-shuang-zhi-zhen</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-88-he-bing-liang-ge-you-xu-shu-zu-jian-dan-shuang-zhi-zhen">
        </link>
        <updated>2020-01-02T01:40:13.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。<br>
说明:<br>
初始化 nums1 和 nums2 的元素数量分别为 m 和 n。<br>
你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。<br>
示例:<br>
输入:<br>
nums1 = [1,2,3,0,0,0], m = 3<br>
nums2 = [2,5,6],       n = 3<br>
输出: [1,2,2,3,5,6]<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/merge-sorted-array<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>和stl中的merge相比主要是没有额外的空间，如果强行双指针的话会导致被覆盖的问题。<br>
我的第一想法居然是copy过去然后排序hhh 但是时间复杂度估计会爆炸<br>
第二想法是把nums1后移n位，然后merge<br>
第三想法就是希望避免后移,本来以为交换就好，但是似乎[2,5,6,0,0,0]和[1,2,3]这种就很麻烦，所以没想好<br>
卧槽！！！原来是从后往前合并！！！666啊 所以还是差一步没想到啊<br>
然后复现官方题解时发现一个坑是判断条件中必须是&gt;=begin而不能是!=begin，因为从前往后是有last这个尾后位置兜底，但是begin可没法再退一位了<br>
然后同样是begin的问题，在复现官方的从后往前时遇到一个挺恶心的点，就是如果nums2为空，官网用下标的话会指向-1下标值，而相对应地我的迭代器指向了begin之前，就必须额外先判断nums2是否为空</p>
<p>自己实现的代码：</p>
<pre><code>    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {
        for(int i=m-1;i&gt;=0;--i)
            nums1[i+n]=nums1[i];
        auto p=nums1.begin(),p1=nums1.begin()+n,p2=nums2.begin();
        while(p1!=nums1.end()&amp;&amp;p2!=nums2.end()){
            if(*p2&lt;=*p1)
                *(p++)=*(p2++);
            else
                *(p++)=*(p1++);          
        }
        if(p2!=nums2.end())
            while(p2!=nums2.end())
                *(p++)=*(p2++);
    }
</code></pre>
<p>参考官方题解实现的代码：</p>
<pre><code>class Solution {
public:
    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {
        if(nums2.empty()) return;
        auto p=nums1.end()-1,p1=p-n,p2=nums2.end()-1;   
        while(p1&gt;=nums1.begin()&amp;&amp;p2&gt;=nums2.begin()){
            if(*p1&gt;=*p2){
                *p=*p1;
                --p1;
            }else{
                *p=*p2;
                --p2;  
            }
           --p;
        }

        if(p2&gt;=nums2.begin()){
            while(p2&gt;=nums2.begin()){
            *p=*p2;
            --p2; 
            --p;
            }
        }
    }
   
};
</code></pre>
<p>然后是官方题解</p>
<blockquote>
<p>方法一 : 合并后排序<br>
最朴素的解法就是将两个数组合并之后再排序。该算法只需要一行(Java是2行)，时间复杂度较差，为O((n+m)log(n+m))。这是由于这种方法没有利用两个数组本身已经有序这一点。<br>
实现</p>
</blockquote>
<pre><code>Java
class Solution {
  public void merge(int[] nums1, int m, int[] nums2, int n) {
    System.arraycopy(nums2, 0, nums1, m, n);
    Arrays.sort(nums1);
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 : O((n+m)log(n+m))。<br>
空间复杂度 : O(1)。</p>
</blockquote>
<blockquote>
<p>方法二 : 双指针 / 从前往后<br>
一般而言，对于有序数组可以通过双指针法 达到O(n+m)的时间复杂度。<br>
最直接的算法实现是将指针p1 置为 nums1的开头， p2为 nums2的开头，在每一步将最小值放入输出数组中。<br>
由于 nums1 是用于输出的数组，需要将nums1中的前m个元素放在其他地方，也就需要 O(m) 的空间复杂度。</p>
</blockquote>
<pre><code>class Solution {
  public void merge(int[] nums1, int m, int[] nums2, int n) {
    // Make a copy of nums1.
    int [] nums1_copy = new int[m];
    System.arraycopy(nums1, 0, nums1_copy, 0, m);

    // Two get pointers for nums1_copy and nums2.
    int p1 = 0;
    int p2 = 0;

    // Set pointer for nums1
    int p = 0;

    // Compare elements from nums1_copy and nums2
    // and add the smallest one into nums1.
    while ((p1 &lt; m) &amp;&amp; (p2 &lt; n))
      nums1[p++] = (nums1_copy[p1] &lt; nums2[p2]) ? nums1_copy[p1++] : nums2[p2++];

    // if there are still elements to add
    if (p1 &lt; m)
      System.arraycopy(nums1_copy, p1, nums1, p1 + p2, m + n - p1 - p2);
    if (p2 &lt; n)
      System.arraycopy(nums2, p2, nums1, p1 + p2, m + n - p1 - p2);
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 : O(n+m)。<br>
空间复杂度 : O(m)。</p>
</blockquote>
<blockquote>
<p>方法三 : 双指针 / 从后往前<br>
方法二已经取得了最优的时间复杂度O(n+m)，但需要使用额外空间。这是由于在从头改变nums1的值时，需要把nums1中的元素存放在其他位置。<br>
如果我们从结尾开始改写 nums1 的值又会如何呢？这里没有信息，因此不需要额外空间。<br>
这里的指针 p 用于追踪添加元素的位置。<br>
实现</p>
</blockquote>
<pre><code>Java
class Solution {
  public void merge(int[] nums1, int m, int[] nums2, int n) {
    // two get pointers for nums1 and nums2
    int p1 = m - 1;
    int p2 = n - 1;
    // set pointer for nums1
    int p = m + n - 1;

    // while there are still elements to compare
    while ((p1 &gt;= 0) &amp;&amp; (p2 &gt;= 0))
      // compare two elements from nums1 and nums2 
      // and add the largest one in nums1 
      nums1[p--] = (nums1[p1] &lt; nums2[p2]) ? nums2[p2--] : nums1[p1--];

    // add missing elements from nums2
    System.arraycopy(nums2, 0, nums1, 0, p2 + 1);
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 : O(n+m)。<br>
空间复杂度 : O(1)。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ [Linux基础] 文件与文件系统的压缩, 打包与备份（鸟哥Linux第八章）]]></title>
        <id>https://lixin-ee.github.io//post/linux-ji-chu-wen-jian-yu-wen-jian-xi-tong-de-ya-suo-da-bao-yu-bei-fen-niao-ge-linux-di-ba-zhang</id>
        <link href="https://lixin-ee.github.io//post/linux-ji-chu-wen-jian-yu-wen-jian-xi-tong-de-ya-suo-da-bao-yu-bei-fen-niao-ge-linux-di-ba-zhang">
        </link>
        <updated>2020-01-01T07:23:17.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p>压缩文件的用途与技术<br>
压缩后与压缩的文件所占用的磁盘空间大小， 就可以被称为是『压缩比』</p>
</li>
<li>
<p>Linux系统常见的压缩指令<br>
在 Linux 的环境中，压缩文件案的扩展名大多是： 『* .tar, * .tar.gz, * .tgz, * .gz, * .Z, * .bz2, * .xz』，<strong>Linux 的扩展名没有什么作用，仅用于指示压缩指令</strong>，这是因为 Linux 支持的压缩指令非常多，且不同的指令所用的压缩技术并不相同，当然彼此之间可能就无法互通压缩/解压缩文件案<br>
.Z       compress 程序压缩的文件；<br>
.zip    zip 程序压缩的文件；<br>
.gz     gzip 程序压缩的文件；<br>
.bz2   bzip2 程序压缩的文件；<br>
.xz     xz 程序压缩的文件；<br>
.tar    tar 程序打包的数据，并没有压缩过；<br>
.tar.gz    tar 程序打包的文件，其中并且经过 gzip 的压缩<br>
.tar.bz2   tar 程序打包的文件，其中并且经过 bzip2 的压缩<br>
.tar.xz      tar 程序打包的文件，其中并且经过 xz 的压缩</p>
</li>
</ul>
<p>注意tar程序只是打包，而不压缩</p>
<ul>
<li>gzip, zcat/zmore/zless/zgrep<br>
[dmtsai@study ~]$  gzip [-cdtv#]  檔名<br>
[dmtsai@study ~]$  zcat  檔名 .gz<br>
选项与参数：<br>
-c ：将压缩的数据输出到屏幕上，可透过数据流重导向来处理；<br>
-d ：解压缩的参数；<br>
-t ：可以用来检验一个压缩文件的一致性～看看文件有无错误；<br>
-v ：可以显示出原文件/压缩文件案的压缩比等信息；<br>
-# ：# 为数字的意思，代表压缩等级，-1 最快，但是压缩比最差、-9 最慢，但是压缩比最好！预设是 -6</li>
</ul>
<p>使用 gzip 进行压缩时，在预设的状态下原本的文件会被压缩成为 .gz 的档名，源文件就不再存在了，这点与一般习惯使用 windows 做压缩所熟悉的情况不同、</p>
<ul>
<li>
<p>bzip2, bzcat/bzmore/bzless/bzgrep<br>
[dmtsai@study ~]$  bzip2 [-cdkzv#]  檔名<br>
[dmtsai@study ~]$  bzcat  檔名 .bz2<br>
选项与参数：<br>
-c ：将压缩的过程产生的数据输出到屏幕上！<br>
-d ：解压缩的参数<br>
-k ：保留源文件，而不会删除原始的文件喔！<br>
-z ：压缩的参数 (默认值，可以不加)<br>
-v ：可以显示出原文件/压缩文件案的压缩比等信息；<br>
-# ：与 gzip 同样的，都是在计算压缩比的参数， -9 最佳， -1 最快！</p>
</li>
<li>
<p>xz, xzcat/xzmore/xzless/xzgrep<br>
[dmtsai@study ~]$  xz [-dtlkc#]  檔名<br>
[dmtsai@study ~]$  xcat  檔名 .xz<br>
选项与参数：<br>
-d ：就是解压缩啊！<br>
-t ：测试压缩文件的完整性，看有没有错误<br>
-l ：列出压缩文件的相关信息<br>
-k ：保留原本的文件不删除～<br>
-c ：同样的，就是将数据由屏幕上输出的意思！<br>
-# ：同样的，也有较佳的压缩比的意思！</p>
</li>
<li>
<p>打包指令： tar<br>
打包与压缩<br>
[dmtsai@study ~]$  tar [-z|-j|-J] [cv] [-f  待建立的新檔名 ] filename...<br>
察看檔名<br>
[dmtsai@study ~]$  tar [-z|-j|-J] [tv] [-f  既有的 r tar  檔名 ]<br>
解压缩<br>
[dmtsai@study ~]$  tar [-z|-j|-J] [xv] [-f  既有的 r tar  檔名 ] [-C  目 录 ]</p>
</li>
</ul>
<p>其实最简单的使用 tar 就只要记忆底下的方式即可：<br>
•  压 缩：tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称<br>
•  查 询：tar -jtv -f filename.tar.bz2<br>
•  解压缩：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录</p>
<p>仅解开单一文件的方法</p>
<ol>
<li>
<p>先找到我们要的档名，假设解开 shadow 文件好了：<br>
[root@study ~]#  tar- jtv- f /root/etc.tar.bz2 | grep 'shadow'<br>
先搜寻档名，其中那个 grep 是『撷取』关键词的功能</p>
</li>
<li>
<p>将该文件解开！语法与实际作法如下：<br>
[root@study ~]#  tar-jxv -f  打包檔 .tar.bz2  待解 开档 名<br>
[root@study ~]#  tar-jxv -f /root/etc.tar.bz2 etc/shadow</p>
</li>
</ol>
<h1 id="此时只会解开一个文件而已不过重点是那个档名你要找到正确的档名">此时只会解开一个文件而已！不过，重点是那个档名！你要找到正确的档名。</h1>
<h1 id="在本例中你不能写成-etcshadow-因为记录在-etctarbz2-内的并没有-之故">在本例中，你不能写成 /etc/shadow ！因为记录在 etc.tar.bz2 内的并没有 / 之故！</h1>
<p>打包某目录，但不含该目录下的某些 文件<br>
可以透过 --exclude的帮忙！ 那个 exclude 就是不包含的意思<br>
[root@study ~]#  tar -jcv - /root/system.tar.bz2  --exclude=/root/etc*   --exclude=/root/system.tar.bz2 /etc /root</p>
<ul>
<li>其他常见的压缩与备份工具<br>
dd<br>
dd 可以读取磁盘装置的内容，dd 指令最大的功效应该是在于『备份』<br>
[root@study ~]# dd if=&quot;input_file&quot; of=&quot;output_file&quot; bs=&quot;block_size&quot; count=&quot;number&quot;<br>
选项与参数：<br>
if ：就是 input file 啰～也可以是装置喔！<br>
of ：就是 output file 喔～也可以是装置；<br>
bs ：规划的一个 block 的大小，若未指定则预设是 512 bytes(一个 sector 的大小)<br>
count：多少个 bs 的意思。</li>
</ul>
<p>cpio<br>
cpio 可以备份任何东西，包括装置设备文件。不过 cpio 有个大问题， 那 就是 cpio 不会主动的去找文件来备份， cpio 得要配合类似 find 等 可以找到文件名的指令来告知 cpio 该被备份的数据在哪里<br>
备份[root@study ~]# cpio - - ovcB &gt; [file|device]<br>
还原[root@study ~]# cpio - - ivcdu &lt; [file|device]<br>
察看[root@study ~]# cpio - - ivct &lt; [file|device]</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于树的递归与迭代]]></title>
        <id>https://lixin-ee.github.io//post/guan-yu-shu-de-di-gui-yu-die-dai</id>
        <link href="https://lixin-ee.github.io//post/guan-yu-shu-de-di-gui-yu-die-dai">
        </link>
        <updated>2020-01-01T03:08:38.000Z</updated>
        <content type="html"><![CDATA[<p>关于树的算法题可以有很多分类<br>
比如按遍历顺序是前中后序+层次遍历<br>
然后按层次又可以分为深度优先（DFS）和广度优先（BFS）</p>
<p>那做题的时候最明显的分类就是递归法和迭代法了<br>
我本来以为所有题目都是可以有递归法和迭代法的<br>
但是今天碰到的题目却颠覆了我的认知</p>
<p><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543. 二叉树的直径</a><br>
题目要求求节点中的最长路径（亦即直径）<br>
我的思考过程如下：<br>
这个问题可以转化为找某个节点的左右子树的深度之和（注意不一定就是根节点，有可能没有左右子树之一）<br>
递归倒是很简单，直接从叶子节点的1开始算起，每个非叶节点就计算左子树和右子树之和，再取两者的较大者+1返回<br>
迭代比较难，我想到的是先存入父节点、右子树和左子树，但是不知道怎么把层数回传给父节点<br>
后来想到用map来存,还是没法从叶节点开始回溯啊。。。</p>
<p>后来看了很多题解，发现确实就是无法使用迭代法，因为无法从叶子节点回溯到父节点<br>
类似的题目还有<br>
<a href="https://leetcode-cn.com/problems/balanced-binary-tree/solution/balanced-binary-tree-di-gui-fang-fa-by-jin40789108/">110. 平衡二叉树</a><br>
<a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a><br>
<a href="https://leetcode-cn.com/problems/house-robber-iii/">337. 打家劫舍 III</a></p>
<p>这些题有共同的特点是，当前节点的需要计算的值依赖于子节点返回的值<br>
（别和树的深度题搞混了，111.树的最小深度和104.树的最大深度还是可以用迭代的）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math 231. 2的幂[简单][位运算]]]></title>
        <id>https://lixin-ee.github.io//post/math-231-2-de-mi-jian-dan-wei-yun-suan</id>
        <link href="https://lixin-ee.github.io//post/math-231-2-de-mi-jian-dan-wei-yun-suan">
        </link>
        <updated>2020-01-01T01:44:14.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个整数，编写一个函数来判断它是否是 2 的幂次方。<br>
示例 1:<br>
输入: 1<br>
输出: true<br>
解释: 20 = 1<br>
示例 2:<br>
输入: 16<br>
输出: true<br>
解释: 24 = 16<br>
示例 3:<br>
输入: 218<br>
输出: false<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/power-of-two<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题让我想起了除法 把除数不断递增就好 主要难点就是在于除数和商的控制<br>
突然发现一个问题，如果不是2的幂的话肯定最后会变成奇数<br>
第一版代码里面，n%2、n/2和n<mark>1的位置很重要，一开始我把n/=2;放在了n%2前面，导致3就错误了；<br>
然后希望改进一下看看能不能递增2，判断条件很重要<br>
艹艹艹，忘了位这个东西啦！！！很明显按位处理更方便 只需要判断是否大于0和(n&amp;(n-1))是否</mark>0了<br>
因为如果n是二次幂，一定只有最高位是1，也就是1000...，则n-1是0111...如果不是二次幂，这两者的交集一定不等于0<br>
注意注意！！！！一开始写成了n&amp;(n-1)==0; 注意外括号必不可少，否则就等同于 n &amp; ((n-1)==0) <mark>的优先级可是高于&amp;的 可以类比 n&amp;&amp;n</mark>0</p>
<p>然后就是网友题解：</p>
<blockquote>
<p>解题思路：<br>
若 n = 2^x<br>
且 x 为自然数（即 n 为 2 的幂），则一定满足以下条件：<br>
恒有 n &amp; (n - 1) == 0，这是因为：<br>
n 二进制最高位为 1，其余所有位为 0；<br>
n - 1 二进制最高位为 0，其余所有位为 1；<br>
一定满足 n &gt; 0。<br>
因此，通过 n &gt; 0 且 n &amp; (n - 1) == 0 即可判定是否满足 n = 2^x</p>
</blockquote>
<pre><code>class Solution {
    public boolean isPowerOfTwo(int n) {
        return n &gt; 0 &amp;&amp; (n &amp; (n - 1)) == 0;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[  [Linux基础] 磁盘与文件系统管理（鸟哥Linux第七章）]]></title>
        <id>https://lixin-ee.github.io//post/linux-ji-chu-ci-pan-yu-wen-jian-xi-tong-guan-li-niao-ge-linux-di-qi-zhang</id>
        <link href="https://lixin-ee.github.io//post/linux-ji-chu-ci-pan-yu-wen-jian-xi-tong-guan-li-niao-ge-linux-di-qi-zhang">
        </link>
        <updated>2019-12-31T07:10:40.000Z</updated>
        <content type="html"><![CDATA[<p>这一章概念居多，命令很少用得上（比如查看磁盘和文件系统）<br>
磁盘盘上的物理组成则为<br>
•  扇区(Sector)为最小的物理储存单位，且依据磁盘设计的不同，目前主要有 512bytes 与 4K 两种格式；<br>
•  将扇区组成一个圆，那就是磁柱(Cylinder)；<br>
早期的分区主要以磁柱为最小分区单位，现在的分区通常使用扇区为最小分区单位</p>
<p>/dev/sd[a-p][1-128]：为实体磁盘的磁盘文件名；<br>
/dev/vd[a-d][1-128]：为虚拟磁盘的磁盘文件名；</p>
<ul>
<li>文件系统特性<br>
磁盘分区完毕后还需要进行格式化(format)，之后操作系统才能够使用这个文件系统。为什么需要进行『格式化』呢？这是因为每种操作系统所设定的文件属性/权限并不相同。为了存放这些文件所需的数据，因此就需要将分区槽进行格式化，以成为操作系统能够利用的『文件系统格式(filesystem)』<br>
Linux 的正统文件系统则为 Ext2</li>
</ul>
<p>文件系统通常会将这两部份的数据（文件权限(rwx)与文件属性(拥有者、 群组、时间参数等)）分别存放在不同的区块，权限与属性放置到 inode 中，至于实际数据则放置到 data block 区块中</p>
<p>每个 inode 与 block 都有编号，至于这三个数据的意义可以简略说明如下：</p>
<ul>
<li>superblock：记录此 filesystem 的整体信息，包括 inode/block 的总量、使用量、剩余量， 以及文件系统的 格式与相关信息等；</li>
<li>inode：记录文件的属性，一个文件占用一个 inode，同时记录此文件的数据所在的 block 号码；</li>
</ul>
<p>每个文件都会占用一个 inode ，inode 内则有文件数据放置 的 block 号码。<br>
一个incode可能会拥有（占用）多个block，这种数据存取的方法我们称为索引式文件系统(indexed allocation)</p>
<p>FAT 这种格式的文件系统并没有 inode 存在，每个 block 号码都记录在前一个 block 当中</p>
<p>『碎片整理』： 需要碎片整理的原因就是文件写入的 block 太过于离散了，此 时文件读取的效能将会变的很差所致。 这个时候可以透过碎片整理将同一个文件所属的 blocks 汇整 在一起</p>
<p>inode table (inode 表格)<br>
inode 记录的文件数据至少有底下这些</p>
<ul>
<li>
<p>该文件的存取模式(read/write/excute)；</p>
</li>
<li>
<p>该文件的拥有者与群组(owner/group)；</p>
</li>
<li>
<p>该文件的容量；</p>
</li>
<li>
<p>该文件建立或状态改变的时间(ctime)；</p>
</li>
<li>
<p>最近一次的读取时间(atime)；</p>
</li>
<li>
<p>最近修改的时间(mtime)；</p>
</li>
<li>
<p>定义文件特性的旗标(flag)，如 SetUID...；</p>
</li>
<li>
<p>该文件真正内容的指向 (pointer)；</p>
</li>
<li>
<p>每个 inode 大小均固定为 128 bytes (新的 ext4 与 xfs 可设定到 256 bytes)；</p>
</li>
<li>
<p>每个文件都仅会占用一个 inode 而已；</p>
</li>
<li>
<p>承上，因此文件系统能够建立的文件数量与 inode 的数量有关；</p>
</li>
<li>
<p>系统读取文件时需要先找到 inode，并分析 inode 所记录的权限与用户是否符合，若符合才能够开始实际 读取 block 的内容。</p>
</li>
</ul>
<ul>
<li>与目录树的关系<br>
1.目录<br>
当我们在 Linux 下的文件系统建立一个目录时，<strong>文件系统会分配一个 inode 与至少一块 block 给该目录</strong>。其中，<strong>inode 记录该目录的相关权限与属性</strong>，并可记录分配到的那块 block 号码； 而<strong>block 则是记录在这个目录下的文件名与该文件名占用的 inode 号码数据。</strong><br>
2.文件<br>
当我们在 Linux 下的 ext2 建立一个一般文件时， ext2 会分配一个 inode 与相对于该文件大小的 block 数量给该文件，由于 inode 仅 有 12 个直接指向，因此还要多一个 block 来作为区块号码的记录<br>
3.目录树读取<br>
inode 本身并不记录文件名，文件名的记录是在目 录的 block 当中<br>
因为『新增/删除/更名文件名 与目录的 w 权限有关』，那么因为文件名是记录在目录的 block 当中， 因此当我们要读取 某个文件时，就务必会经过目录的 inode 与 block ，然后才能够找到那个待读取文件的 inode 号码， 最终才会读到正确的文件的 block 内的数据。</li>
</ul>
<p>日志式文件系统：<br>
在 filesystem 当中规划出一个区块，该区块专门在记录写入或修订文件时的步骤</p>
<ol>
<li>预备：当系统要写入一个文件时，会先在日志记录区块中纪录某个文件准备要写入的信息；</li>
<li>实际写入：开始写入文件的权限与数据；开始更新 metadata 的数据；</li>
<li>结束：完成数据与 metadata 的更新后，在日志记录区块当中完成该文件的纪录。</li>
</ol>
<p>数据的不一致 (Inconsistent) 状态：metadata 的内容与实际数据存放区产生不一致 (Inconsistent)</p>
<p>Linux 文件系统的运作：<br>
1.当系统加载一个文件到内存后，如果该文件没有被更动过，则在内存区段的文件数据会被设定为干净 (clean)的。<br>
2.但如果内存中的文件数据被更改过了(例如你用 nano 去编辑过这个文件)，此时该内存中 的数据会被设定为脏的 (Dirty)。此时所有的动作都还在内存中执行，并没有写入到磁盘中<br>
3.系统会 不定时的将内存中设定为『Dirty』的数据写回磁盘，以保持磁盘与内存数据的一致性。<br>
如果能够将常用的文件放置到内存当中，就会增加系 统性能</p>
<ul>
<li>系统会将常用的文件数据放置到主存储器的缓冲区，以加速文件系统的读/写；</li>
<li>承上，因此 Linux 的物理内存最后都会被用光！这是正常的情况！可加速系统效能；</li>
<li>你可以手动使用 sync 来强迫内存中设定为 Dirty 的文件回写到磁盘中；</li>
</ul>
<ul>
<li>
<p>挂载点的意义 (mount point)<br>
将文件系统与目录树结合的动作我们称为『挂载』<br>
<strong>挂载点一定是目录</strong>，该目录为进入该文件系统的入口。 因此并不是你有任 何文件系统都能使用，<strong>必须要『挂载』到目录树的某个目录后，才能够使用该文件系统的。</strong><br>
<strong>同一个 filesystem 的某个 inode 只会对应到一个文件内容</strong>而 已(因为一个文件占用一个 inode 之故)， 因此我们可以透过判断 inode 号码来确认不同文件名是否 为相同的文件</p>
</li>
<li>
<p>文件系统的简单操作</p>
</li>
</ul>
<ul>
<li>
<p>df：列出文件系统的整体磁盘使用量；<br>
-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；<br>
-i ：不用磁盘容量，而以 inode 的数量来显示</p>
<pre><code>  	 **通常 inode 的数量剩余都比 block 还要多**
</code></pre>
</li>
<li>
<p>du：评估文件系统的磁盘使用量(常用在推估目录所占容量)<br>
-s ：列出总量而已，而不列出每个各别的目录占用容量；</p>
</li>
</ul>
<p>直接输入 du 没有加任何选项时，则 du 会分析『目前所在目录』的文件与目录所占用的磁盘空间。但是，实际显示时，仅会显示目录容量(不含文件)，<br>
与 df 不一样的是，du 这个指令其实会直接到文件系统内去搜寻所有的文件数据<br>
如果你只想要知道该目录占了多少容量的话，使用 -s 就可以</p>
<ul>
<li>
<p>实体链接与符号链接： ln（重点）<br>
Linux 底下的连结档有两种，一种是类似 Windows 的<strong>快捷方式功能</strong>的文件，可以让你快速的链 接到目标文件(或目录)； 另一种则是透过文件系统的 inode 连结来产生<strong>新档名</strong>，而<strong>不是产生新文件</strong>！ 这种称为实体链接 (hard link)。</p>
</li>
<li>
<p>Hard Link ( 实体链接, 硬式连结或实际连结)<br>
前提：</p>
</li>
</ul>
<ul>
<li><strong>每个文件都会占用一个 inode</strong> ，文件内容由 inode 的记录来指向；</li>
<li>想要读取该文件，必须要<strong>经过目录记录的文件名来指向到正确的 inode 号码才能读取。</strong></li>
</ul>
<p>hard link ：<strong>多个档名对应到同一个 inode 号码</strong><br>
hard link <strong>只是在某个目录下新增一笔档名链接到某 inode 号码的关连记录而已</strong><br>
硬链接hard link最大的好处就是 『安全』，<strong>如果你将任何一个『档名』删除，其实 inode 与 block 都还是存在的</strong><br>
<strong>使用 hard link 设定链接文件时，磁盘的空间与 inode 的数目都不会改变</strong><br>
hard link 的制作中，<strong>其实还是可能会改变系统的 block 的</strong>，那就是当你<strong>新增这笔数据却刚好将目录的 block 填满时，就可能会新加一个 block 来记录文件名关连性</strong>，而导致磁盘空间的变化！不过， 一般 hard link 所用掉的关连数据量很小，所以<strong>通常不会改变 inode 与磁盘空间的大小</strong><br>
hard link 是有限制的：</p>
<ul>
<li>不能跨 Filesystem；</li>
<li><strong>不能 link 目录</strong>。<br>
<strong>如果使用 hard link 链接到目录时， 链接的数据需要连同被链接目录底下的所有数据都建立链接</strong></li>
</ul>
<ul>
<li>Symbolic Link (符号链接，亦即是快捷方式)<br>
Symbolic link 就是在建立一个<strong>独立的 文件</strong>，而这个文件会让<strong>数据的读取指向他它link 的那个文件的档名</strong>！由于只是利用文件来做为指向的 动作， 所以，当<strong>来源档被删除</strong>之后，<strong>symbolic link</strong> 的文件会『开不了』，<br>
符号链接可以<strong>跨越文件系统</strong>！！！也可以链接项目，因为只看文件名不看inode</li>
</ul>
<p><strong>两个文件指向不同的 inode 号码，当然就是两个独立的文件存在！</strong> 而且 连结档的<strong>重要内容就是他会写上目标文件的『文件名』</strong></p>
<p>Symbolic Link 与 Windows 的快捷方式可以给他划上等号，由 Symbolic link 所建立的文件为一个<strong>独立的新的文件</strong>，所以<strong>会占用掉 inode 与 block</strong></p>
<p><strong>个人测试</strong>：Symbolic Link之后删除源文件，会显示No such file 但是！！！！我重建源文件后（用vim重建不同内容的同名文件或者用ln硬链接同名文件），会自动连接上！！！<br>
stat对于软连接不会寻找源文件，lstat才会获取原始文件</p>
<p>要制作连结档就必须要使用 ln 这个指令<br>
[root@study ~]# ln [-sf] 来源文件 目标文件<br>
选项与参数：<br>
-s ：如果不加任何参数就进行连结，那就是 hard link，至于 -s 就是 symbolic link<br>
-f ：如果 目标文件 存在时，就主动的将目标文件直接移除后再建立</p>
<p><strong>使用 ln 如果不加任何参数的话，那么就是 Hard Link</strong></p>
<p>关于目录的 link 数量<br>
以 hard link 进行『文件的连结』时，可以发现，在 ls -l 所显 示的第二字段会增加一才对<br>
当我们建立一个新目录名称为 /tmp/testing 时，基本上会有三个东西，那就是：</p>
<ul>
<li>/tmp/testing</li>
<li>/tmp/testing/.</li>
<li>/tmp/testing/..<br>
所以<strong>新的目录的 link 数为 2 ，而上层目录的 link 数则会增加 1</strong></li>
</ul>
<ul>
<li>磁盘的分区、格式化、检验与挂载<br>
想要在系统里面新增一颗磁盘时，应该有哪些动作需要做：</li>
</ul>
<ol>
<li>对磁盘进行<strong>分区</strong>，以建立可用的 partition ；</li>
<li>对该 partition 进行<strong>格式化 (format)</strong>，以建立系统可用的 filesystem；</li>
<li>若想要仔细一点，则可对刚刚建立好的 filesystem 进行检验；</li>
<li>在 Linux 系统上，需要<strong>建立挂载点 (亦即是目录)</strong>，并将他挂载上来；</li>
</ol>
<ul>
<li>观察磁盘分区状态</li>
</ul>
<ol>
<li>lsblk列出系统上的所有磁盘列表</li>
<li>blkid  列出装置的UUID 等参数</li>
<li>parted 列出磁盘的 分区 表类型与 分区 信息</li>
<li>磁盘分区： gdisk/fdisk</li>
</ol>
<ul>
<li>磁盘格式化( 建置文件系统)</li>
</ul>
<ol>
<li>XFS  文件系统 mkfs.xfs</li>
<li>XFS  文件系统 for RAID  效能优化 (Optional)</li>
<li>EXT4  文件系统 mkfs.ext4</li>
<li>其他文件系统 mkfs</li>
</ol>
<ul>
<li>文件系统检验</li>
</ul>
<ol>
<li>xfs_repair  处理 XFS文件系统</li>
<li>fsck.ext4  处理 EXT4  文件系统</li>
</ol>
<ul>
<li>文件系统挂载与卸除  (相当于插入u盘后显示的载入点)<br>
载点的意义：挂载点是目录， 而这个目录是进入磁盘分区槽(其实是 文件系统)的入口</li>
</ul>
<ul>
<li>单一文件系统不应该被重复挂载在不同的挂载点(目录)中；</li>
<li>单一目录不应该重复挂载多个文件系统；</li>
<li>要作为挂载点的目录，理论上应该都是空目录才是<br>
挂载了文件系统之后，原目录 下的东西就会暂时的消失。等 到新分区槽被卸除之后，原本的内容就会再次的跑出来</li>
</ul>
<p>挂载指令 -mount<br>
[root@study ~]#  mount<br>
-t ：可以加上文件系统种类来指定欲挂载的类型</p>
<p>将装置文件卸除 -umount<br>
[root@study ~]# umount [-fn] 装置文件名或挂载点</p>
<p>-f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下；<br>
-l ：立刻卸除文件系统，比 -f 还强！</p>
<p>由于通通卸除了，此时你才可以退出光盘片、软盘片、USB 随身碟等设备<br>
由于你目前正在目录内，也就是说其实『你正在使用该文件系统！所以自然无法卸除这个装置！那该如何是好？就『离开该文件系统的挂载点』即可</p>
<ul>
<li>
<p>磁盘/ 文件系统参数修订<br>
修改目前文件系统的一些相关信息<br>
1.mknod 手动处理装置文件<br>
2.xfs_admin  修改 XFS  文件系统的 UUID  与 Label name<br>
3.tune2fs  修改 ext4  的 label name  与 UUID</p>
</li>
<li>
<p>设定开机挂载<br>
开机挂载 /etc/fstab  及 /etc/mtab<br>
/etc/fstab 可设置开机自动挂载文件系统<br>
系统挂载的一些限制：<br>
•  根目录 / 是必须挂载的﹐而且一定要先于其它 mount point 被挂载进来。<br>
•  其它 mount point 必须为已建立的目录﹐可任意指定﹐但一定要遵守必须的系统目录架构原则 (FHS)<br>
•  所有 mount point 在同一时间之内﹐只能挂载一次。<br>
•  所有 partition 在同一时间之内﹐只能挂载一次。<br>
•  如若进行卸除﹐您必须先将工作目录移到 mount point(及其子目录) 之外。</p>
</li>
<li>
<p>建立大 文件 以制作 loop  装置 文件<br>
将这个文件格式化后挂载：制作出一个大文件，然后将这个文件挂载！如此一来感觉上你就多了一个分区槽啰<br>
o  建立大型文件<br>
程序 dd可以用来建立空的文件<br>
[root@study ~]#  dd if=/dev/zero of=/srv/loopdev bs=1M count=512<br>
512+0 records in &lt;==读入 512 笔资料<br>
512+0 records out &lt;==输出 512 笔数据<br>
536870912 bytes (537 MB) copied, 12.3484 seconds, 43.5 MB/s</p>
</li>
</ul>
<h1 id="这个指令的简单意义如下">这个指令的简单意义如下：</h1>
<h1 id="if-是-input-file-输入文件-那个-devzero-是会一直输出-0-的装置">if 是 input file ，输入文件。那个 /dev/zero 是会一直输出 0 的装置！</h1>
<h1 id="of-是-output-file-将一堆零写入到后面接的文件中">of 是 output file ，将一堆零写入到后面接的文件中。</h1>
<h1 id="bs-是每个-block-大小就像文件系统那样的-block-意义">bs 是每个 block 大小，就像文件系统那样的 block 意义；</h1>
<h1 id="count-则是总共几个-bs-的意思-所以-bscount-就是这个文件的容量了">count 则是总共几个 bs 的意思。所以 bs*count 就是这个文件的容量了！</h1>
<p>dd 就好像在迭砖块一样，将 512 块，每块 1MB 的砖块堆栈成为一个大文件 (/srv/loopdev) ！ 最终就会出现一个 512MB 的文件！</p>
<p>o  大型文件的格式化<br>
o  挂载<br>
可以在原本的分区槽在不更动原有的环境下制作出你想要的分区槽</p>
<ul>
<li>内存置换空间(swap)<br>
可以暂时将内存的程序拿到硬盘中暂放的内存置换空间 (swap)<br>
安装时一定需要的两个 partition ，一个是根目录，另外一个就是 swap(内存置换空间)<br>
那当内存不足的时候，为了让后续的程序可以顺利的运作，因此在内存中暂不使用的程序与数据就会被挪到 swap 中</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 70. 爬楼梯[简单][未做出]]]></title>
        <id>https://lixin-ee.github.io//post/dong-tai-gui-hua-70-pa-lou-ti-jian-dan-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/dong-tai-gui-hua-70-pa-lou-ti-jian-dan-wei-zuo-chu">
        </link>
        <updated>2019-12-31T01:45:17.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br>
注意：给定 n 是一个正整数。<br>
示例 1：<br>
输入： 2<br>
输出： 2<br>
解释： 有两种方法可以爬到楼顶。<br>
1.1 阶 + 1 阶<br>
2.2 阶<br>
示例 2：<br>
输入： 3<br>
输出： 3<br>
解释： 有三种方法可以爬到楼顶。<br>
1.1 阶 + 1 阶 + 1 阶<br>
2.1 阶 + 2 阶<br>
3.2 阶 + 1 阶<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/climbing-stairs<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>有点像动态规划<br>
等等！怎么那么像排列组合？！<br>
列出全部为1的情况，然后随机对1进行组合<br>
不对，首先我将其视为一棵树，左子树+1，右子树+2，当叶节点大于等于n的时候就将次数增加1<br>
尴尬，代码是对的，但是超出时间限制了<br>
然后想想对称地用队列的方法 继续翻车超出时间限制<br>
接下来就是动态规划了，我的想法是对于一个全为1的序列，如果前一个1没选择组合为2的话，当前的1就可以选择组合成2或者保持为1，否则只能保持1<br>
动态规划也翻车了<br>
还是好好看看题解吧，其实是斐波那契的问题，但是树的优化也很值得看看</p>
<p>注意实现动态规划时，初始状态是0步而不是1步，所以n=2是是level[0]+level[1]所以需要数组n+1</p>
<pre><code>class Solution {
public:
    int climbStairs(int n) {
        vector&lt;int&gt; level(n+1,1);
        for(int i=2;i&lt;n+1;++i)
            level[i]=level[i-1]+level[i-2];
        return level.back();
    }
};
</code></pre>
<p>超时代码：</p>
<pre><code>/*
class Solution {
public:
    int count=0;
    int climbStairs(int n) {
        add1(0,n);
        add2(0,n); 
        return count;
    }
    
    void add1(int i,int n){
        ++i;
        if(i==n){
            ++count;
            return;
        }
        if(i&gt;n)
            return;
        add1(i,n);
        add2(i,n);
    }
    
    void add2(int i,int n){
        i+=2;
        if(i==n){
            ++count;
            return;
        }
        if(i&gt;n)
            return;
        add1(i,n);
        add2(i,n);          
    }
};
*/
 /*
    int climbStairs(int n) {
        int count=0;
        queue&lt;int&gt; nums;
        nums.push(n);
        while(!nums.empty()){
            int temp=nums.front();
            nums.pop();
            if(temp-1==0)
                ++count;
            if(temp-2==0)
                ++count;
            if(temp-1&gt;0)
                nums.push(temp-1);
            if(temp-2&gt;0)
                nums.push(temp-2);
        }
        return count;  
    }
    */
</code></pre>
<p>然后是题解：</p>
<blockquote>
<p>摘要<br>
假设你正在爬楼梯，需要 n 阶你才能到达楼顶。<br>
每次你可以爬 1 或 2 个台阶，你有多少种不同的方法可以爬到楼顶呢？<br>
解决方案</p>
</blockquote>
<blockquote>
<p>方法一：暴力法<br>
算法<br>
在暴力法中，我们将会把所有可能爬的阶数进行组合，也就是 1 和 2 。而在每一步中我们都会继续调用 climbStairs这个函数模拟爬 1 阶和 2 阶的情形，并返回两个函数的返回值之和。<br>
climbStairs(i,n)=(i + 1, n) + climbStairs(i + 2, n)<br>
其中 i 定义了当前阶数，而 n 定义了目标阶数。</p>
</blockquote>
<pre><code>Java
public class Solution {
    public int climbStairs(int n) {
        climb_Stairs(0, n);
    }
    public int climb_Stairs(int i, int n) {
        if (i &gt; n) {
            return 0;
        }
        if (i == n) {
            return 1;
        }
        return climb_Stairs(i + 1, n) + climb_Stairs(i + 2, n);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(2^n )，树形递归的大小为 2^n2<br>
空间复杂度：O(n)，递归树的深度可以达到 n 。</p>
</blockquote>
<blockquote>
<p>方法二：记忆化递归<br>
算法<br>
在上一种方法中，我们计算每一步的结果时出现了冗余。另一种思路是，我们可以把每一步的结果存储在 memo 数组之中，每当函数再次被调用，我们就直接从 memo 数组返回结果。<br>
在 memo 数组的帮助下，我们得到了一个修复的递归树，其大小减少到 n。</p>
</blockquote>
<pre><code>Java
public class Solution {
    public int climbStairs(int n) {
        int memo[] = new int[n + 1];
        return climb_Stairs(0, n, memo);
    }
    public int climb_Stairs(int i, int n, int memo[]) {
        if (i &gt; n) {
            return 0;
        }
        if (i == n) {
            return 1;
        }
        if (memo[i] &gt; 0) {
            return memo[i];
        }
        memo[i] = climb_Stairs(i + 1, n, memo) + climb_Stairs(i + 2, n, memo);
        return memo[i];
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)，树形递归的大小可以达到 n。<br>
空间复杂度：O(n)，递归树的深度可以达到 n。</p>
</blockquote>
<blockquote>
<p>方法三：动态规划<br>
算法<br>
不难发现，这个问题可以被分解为一些包含最优子结构的子问题，即它的最优解可以从其子问题的最优解来有效地构建，我们可以使用动态规划来解决这一问题。<br>
第 i 阶可以由以下两种方法得到：<br>
在第 (i−1) 阶后向上爬一阶。<br>
在第 (i−2) 阶后向上爬 2 阶。<br>
所以到达第 i 阶的方法总数就是到第(i−1) 阶和第 (i−2) 阶的方法数之和。<br>
令 dp[i] 表示能到达第 i 阶的方法总数：<br>
dp[i]=dp[i−1]+dp[i−2]</p>
</blockquote>
<pre><code>public class Solution {
    public int climbStairs(int n) {
        if (n == 1) {
            return 1;
        }
        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i &lt;= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)，单循环到 n 。<br>
空间复杂度：O(n)，dp 数组用了 n 的空间。</p>
</blockquote>
<blockquote>
<p>方法四：斐波那契数<br>
算法<br>
在上述方法中，我们使用 dp 数组，其中 dp[i]=dp[i-1]+dp[i-2]。可以很容易通过分析得出dp[i] 其实就是第 ii 个斐波那契数。<br>
Fib(n)=Fib(n−1)+Fib(n−2)<br>
现在我们必须找出以 1 和 2 作为第一项和第二项的斐波那契数列中的第 n 个数，也就是说 Fib(1)=1Fib(1)=1 且 Fib(2)=2Fib(2)=2。</p>
</blockquote>
<pre><code>Java
public class Solution {
    public int climbStairs(int n) {
        if (n == 1) {
            return 1;
        }
        int first = 1;
        int second = 2;
        for (int i = 3; i &lt;= n; i++) {
            int third = first + second;
            first = second;
            second = third;
        }
        return second;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)，单循环到 n，需要计算第 n 个斐波那契数。<br>
空间复杂度：O(1)，使用常量级空间。</p>
</blockquote>
<p>下面的就很数学了，在面试中说出来就明显是刷题的了，所以就不贴了</p>
]]></content>
    </entry>
</feed>