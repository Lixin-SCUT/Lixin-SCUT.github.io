<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-02-25T02:08:39.730Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>In the darkest night,Rising like a spire.</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[树 题28:对称的二叉树]]></title>
        <id>https://lixin-scut.github.io//post/shu-ti-28dui-cheng-de-er-cha-shu</id>
        <link href="https://lixin-scut.github.io//post/shu-ti-28dui-cheng-de-er-cha-shu">
        </link>
        <updated>2020-02-24T15:26:21.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。<br>
/*<br>
struct TreeNode {<br>
int val;<br>
struct TreeNode *left;<br>
struct TreeNode *right;<br>
TreeNode(int x) :<br>
val(x), left(NULL), right(NULL) {<br>
}<br>
};<br>
*/</p>
</blockquote>
<p>需要注意的点是其实可以重载原函数，提高代码的可读性</p>
<pre><code>class Solution {
public:
    bool isSymmetrical(TreeNode* pRoot)
    {
        if(pRoot==NULL)
            return true;
        return isSymmetrical(pRoot-&gt;left,pRoot-&gt;right);
    }
    
    bool isSymmetrical(TreeNode* cur1,TreeNode* cur2)
    {
        if(cur1==NULL&amp;&amp;cur2==NULL)
            return true;
        if(cur1==NULL||cur2==NULL)
            return false;
        if(cur1-&gt;val!=cur2-&gt;val)
            return false;
        return isSymmetrical(cur1-&gt;left,cur2-&gt;right)&amp;&amp;isSymmetrical(cur1-&gt;right,cur2-&gt;left);
    }
};
</code></pre>
<p>书本题解：<br>
通常我们有3种不同的二叉树遍历算法，即前序遍历、中序遍历和后 序遍历。在这3种遍历算法中，都是先遍历左子节点再遍历右子节点。我 们是否可以定义一种遍历算法，先遍历右子节点再遍历左子节点？比如我 们针对前序遍历定义一种对称的遍历算法，即先遍历父节点，再遍历它的 右子节点，最后遍历它的左子节点。<br>
我们发现可以通过比较二叉树的前序遍历序列和对称前序遍历序列 来判断二叉树是不是对称的。如果两个序列是一样的，那么二叉树就是对称的。</p>
<pre><code>bool isSymmetrical(BinaryTreeNode* pRoot)
{
    return isSymmetrical(pRoot, pRoot);
}

bool isSymmetrical(BinaryTreeNode* pRoot1, BinaryTreeNode* pRoot2)
{
    if(pRoot1 == nullptr &amp;&amp; pRoot2 == nullptr)
        return true;

    if(pRoot1 == nullptr || pRoot2 == nullptr)
        return false;

    if(pRoot1-&gt;m_nValue != pRoot2-&gt;m_nValue)
        return false;

    return isSymmetrical(pRoot1-&gt;m_pLeft, pRoot2-&gt;m_pRight)
        &amp;&amp; isSymmetrical(pRoot1-&gt;m_pRight, pRoot2-&gt;m_pLeft);
}
</code></pre>
<p>我的思路和书本的一致，但是需要将NULL改为nullptr，这样符合C++11标准</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 指针和引用的区别]]></title>
        <id>https://lixin-scut.github.io//post/zhi-zhen-he-yin-yong-de-qu-bie</id>
        <link href="https://lixin-scut.github.io//post/zhi-zhen-he-yin-yong-de-qu-bie">
        </link>
        <updated>2020-02-24T13:07:58.000Z</updated>
        <content type="html"><![CDATA[<p>首先先贴上以前的博文：<br>
<a href="https://lixin-scut.github.io/post/cyin-yong-de-ben-zhi/">C++引用的本质</a><br>
这篇博文还是比较乱的，图和源代码都找不到了，不过中心思想很简洁，就是<br>
引用就是一个常量指针</p>
<p>但是因为缺乏源代码，所以还是显得比较模糊，还是找博客了解一下</p>
<p>摘自：<a href="https://blog.csdn.net/lyd_253261362/article/details/4323691">指针和引用的联系与区别</a><br>
★ 相同点：</p>
<ol>
<li>都是地址的概念；<br>
指针指向一块内存，它的内容是所指内存的地址；引用是某块内存的别名。<br>
★ 区别：</li>
<li>指针是一个实体，而引用仅是个别名；</li>
<li>引用使用时无需解引用(*)，指针需要解引用；</li>
<li>引用只能在定义时被初始化一次，之后不可变；指针可变；</li>
<li>引用没有 const，指针有 const；</li>
<li>引用不能为空，指针可以为空；</li>
<li>“sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身(所指向的变量或对象的地址)的大小；</li>
<li>指针和引用的自增(++)运算意义不一样；</li>
<li>从内存分配上看：程序为指针变量分配内存区域，而引用不需要分配内存区域。<br>
★ 联系
<ol>
<li>引用在语言内部用指针实现（如何实现？）。</li>
<li>对一般应用而言，把引用理解为指针，不会犯严重语义错误。引用是操作受限了的指针（仅容许取内容操作）。<br>
★ 总结<br>
总的来说，在以下情况下你应该使用指针，一是你考虑到存在不指向任何对象的可能（在这种情况下，你能够设置指针为空），二是你需要能够在不同的时刻指向不同的对象（在这种情况下，你能改变指针的指向）。<br>
如果总是指向一个对象并且一旦指向一个对象后就不会改变指向，那么你应该使用引用。<br>
还有一种情况，就是当你重载某个操作符时，你应该使用引用。最普通的例子是操作符[].这个操作符典型的用法是返回一个目标对象，其能被赋值。<br>
尽可能使用引用，不得已时使用指针。<br>
当你不需要“重新指向”时，引用一般优先于指针被选用。这通常意味着引用用于类的公有接口时更有用。引用出现的典型场合是对象的表面，而指针用于对象内部。<br>
上述的例外情况是函数的参数或返回值需要一个“临界”的引用时。这时通常最好返回/获取一个指针，并使用 NULL 指针来完成这个特殊的使命。（引用应该总是对象的别名，而不是被解除引用的 NULL 指针。</li>
</ol>
</li>
</ol>
<p>但是我个人有一个疑惑：引用到底占不占空间？仅仅是一个别名吗？</p>
<p>然后读取了下面的博客<br>
<a href="https://blog.csdn.net/k346k346/article/details/46805159">C++ 引用的本质</a><br>
<a href="https://www.cnblogs.com/karottc/p/cpp-reference.html">C++的引用类型的变量到底占不占用内存空间？</a><br>
可以看出引用确实是一个指针，而且是一个常量指针，只是我们无法直接获得这个指针，导致它似乎是不存在的</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 题27:二叉树的镜像]]></title>
        <id>https://lixin-scut.github.io//post/shu-ti-27er-cha-shu-de-jing-xiang</id>
        <link href="https://lixin-scut.github.io//post/shu-ti-27er-cha-shu-de-jing-xiang">
        </link>
        <updated>2020-02-23T15:50:11.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
操作给定的二叉树，将其变换为源二叉树的镜像。<br>
输入描述:<br>
二叉树的镜像定义：源二叉树</p>
</blockquote>
<pre><code>    	    8
    	   /  \
    	  6   10
    	 / \  / \
    	5  7  9 11
    	镜像二叉树
    	    8
    	   /  \
    	  10   6
    	 / \  / \
    	11 9  7  5
			
/*
struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :
			val(x), left(NULL), right(NULL) {
	}
};*/
</code></pre>
<p>这道题是常见题目了，主要还是通过递归来解决比较简洁<br>
但是同时也要考虑迭代怎么处理-使用一个队列或者栈，把pop的节点交换左右子树后再push进队列尾端直到队列为空<br>
需要注意的就是交换，最好还是用swap吧</p>
<pre><code>class Solution {
public:
    void Mirror(TreeNode *pRoot) {
        if(pRoot==NULL)
            return;
        TreeNode *temp=pRoot-&gt;left;
        pRoot-&gt;left=pRoot-&gt;right;
        pRoot-&gt;right=temp;
        Mirror(pRoot-&gt;left);
        Mirror(pRoot-&gt;right);
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>求一棵树的镜像的过程：先前序遍历这棵 树的每个节点，如果遍历到的节点有子节点，就交换它的两个子节点。当 交换完所有非叶节点的左、右子节点之后，就得到了树的镜像。</p>
</blockquote>
<pre><code>void MirrorRecursively(BinaryTreeNode *pNode)
{
    if((pNode == nullptr) || (pNode-&gt;m_pLeft == nullptr &amp;&amp; pNode-&gt;m_pRight))
        return;

    BinaryTreeNode *pTemp = pNode-&gt;m_pLeft;
    pNode-&gt;m_pLeft = pNode-&gt;m_pRight;
    pNode-&gt;m_pRight = pTemp;
    
    if(pNode-&gt;m_pLeft)
        MirrorRecursively(pNode-&gt;m_pLeft);  

    if(pNode-&gt;m_pRight)
        MirrorRecursively(pNode-&gt;m_pRight); 
}

void MirrorIteratively(BinaryTreeNode* pRoot)
{
    if(pRoot == nullptr)
        return;

    std::stack&lt;BinaryTreeNode*&gt; stackTreeNode;
    stackTreeNode.push(pRoot);

    while(stackTreeNode.size() &gt; 0)
    {
        BinaryTreeNode *pNode = stackTreeNode.top();
        stackTreeNode.pop();

        BinaryTreeNode *pTemp = pNode-&gt;m_pLeft;
        pNode-&gt;m_pLeft = pNode-&gt;m_pRight;
        pNode-&gt;m_pRight = pTemp;

        if(pNode-&gt;m_pLeft)
            stackTreeNode.push(pNode-&gt;m_pLeft);

        if(pNode-&gt;m_pRight)
            stackTreeNode.push(pNode-&gt;m_pRight);
    }
}
</code></pre>
<p>然后发现我的想法和书本的一致，我倾向于用队列来做迭代（BFS），书本的解法使用栈来做迭代（DFS），基本就是BFS和DFS的区别。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TcpConnection]]></title>
        <id>https://lixin-scut.github.io//post/tcpconnection</id>
        <link href="https://lixin-scut.github.io//post/tcpconnection">
        </link>
        <updated>2020-02-23T13:25:52.000Z</updated>
        <content type="html"><![CDATA[<p>TcpConnection是唯一默认使用shared_ptr来管理的class,也是唯一继承enable_shared_from_this的class,这源于其模糊的生命期</p>
<p>TcpConnection的状态有两个，kConnecting和kConnected</p>
<p>TcpConnection使用Channel来获得socket上的IO事件，它<em>会自己处理writable事件</em>，而把readable事件通过Messagecallback传达给用户<br>
TcpConnection拥有TCP socket,它的析构函数会close(fd)(在Socket的析构函数 中发生)</p>
<p>注意TcpConnection表示的是“一次TCP连接”，它是不可再生的，一旦连接断 开，这个TcpConnection对象就没啥用了。<br>
另外TcpConnection没有发起连接的功能, 其构造函数的参数是已经建立好连接的socketfd (无论是TcpServer被动接受还是 TcpClient主动发起),因此其初始状态是kConnecting。</p>
<p>只接受一种关闭连接的方式：被动关闭，即对方先关闭连接，本地read(2)返回0,触发关闭逻辑。<br>
也可以给TcpConnection新增 forceClose()成员函数，用于主动关闭连接，实现很简单，调用handleClose()<br>
<img src="https://lixin-scut.github.io//post-images/1582467842700.png" alt=""></p>
<p><strong>channel的改动</strong><br>
Channel class新增了 CloseCallback事件回调，并且断言(assert)在事件处理期间Channel对象不会析构，Channel 的 CloseCallback 会调用 handleClose(),</p>
<p>TcpConnection也同步需要增加 CloseCallback事件回调，<em>但是这个回调是给TcpServer和TcpClient用的</em>，用于通知它们移除所持有的TcpConnectionPtr,这不是给普通用户用的，普通用户继续使用ConnectionCallback</p>
<p>handleRead()会检查read(2)的返回值，根据返回值分别调用 messagecallback_,handleClose(),handleError()</p>
<p>handleClose()的主要功能是调用 closeCallback_,这个回调绑定到 removeConnection()</p>
<p>handleError()并没有进一步的行动，只是在日志中输出错误消息，这不影响连接的正常关闭。</p>
<p>connectDestroyed()是 TcpConnection 析构前最后调用的一个成员函数，它通知用户连接已断开。</p>
<p><strong>TcpServer</strong><br>
TcpServer向TcpConnection注册CloseCallback,用于接收连接断开的消息。<br>
通常TcpServer的生命期长于它建立的TcpConnection,因此不用担心TcpServer 对象失效。<br>
TcpServer::removeConnection()把 conn 从 ConnectionMap 中移除。这时 TcpConnection 已经快要被销毁：如果用户不持有TcpConnectionPtr的话，conn的引用计数已降到1。注意这里一定要用EventLoop::queuelnLoop <strong>（unknown）</strong>,否则就会出现对象生命期管理问题，即Channel::handleEvent()<strong>（unknown）</strong> 有可能引发TcpConnection析构，继而把当前Channel对象也析构了，导致程序崩溃。<br>
另外注意这里用boost:: bind让TcpConnection的生命期 长到调用connectDestroyed()的时刻。</p>
<p><strong>EventLoop 和 Poller</strong><br>
TcpConnection不再是只生不灭，因此要求EventLoop也提供unregister功能。EventLoop 新增了 removeChannel()成员函数，它会调用 Poller::removeChannel(),复杂度为O(logN)。<br>
注意其中从数组pollfds_中删除元素是0(1)复杂度，办法是将待删除的元素与最后一个元素交换，再pollfds_.pop_back()</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[STL 内存配置器与内存管理]]></title>
        <id>https://lixin-scut.github.io//post/stl-nei-cun-pei-zhi-qi-yu-nei-cun-guan-li</id>
        <link href="https://lixin-scut.github.io//post/stl-nei-cun-pei-zhi-qi-yu-nei-cun-guan-li">
        </link>
        <updated>2020-02-23T07:22:23.000Z</updated>
        <content type="html"><![CDATA[<p>注意，《STL源码剖析》原文中的是空间配置器</p>
<blockquote>
<p>为什么不说allocator是内存配置器而说它是空间配置器呢？因为空间不一定 是内存，空间也可以是磁盘或其它辅助存储介质。是的，你可以写一个allocator, 直接向硬盘取空间L以下介绍的是SGISTL提供的配置器，配置的对象，呃，是 的，是内存</p>
</blockquote>
<p>但是因为绝大部分时间操作对象都是内存，所以我还是把它叫做内存配置器了。</p>
<p>预备知识：<br>
new对应delete，这两者既包含了内存的分配（释放）和对象的构造（析构）<br>
而malloc和free、allocate和deallocate则仅仅包含内存的分配（释放），需要配合construct和destroy来完成对象的构造（析构）</p>
<p>为了精密分工，STL allocator将内存配置操作和对象构造操作这两阶段操作区分开来。内存分配由alloc::allocate ()负责，内存释放操作由 alloc::deallocate () 负责； 对象构造由::construct ()负责，对象析构操作由 ::destroy ()负责</p>
<p>我们主要考虑内存配置操作：<br>
•	向system heap要求空间。<br>
•	考虑内存不足时的应变措施。<br>
•	考虑过多“小型区块”可能造成的内存碎片(fragment)问题。<br>
SGI正是以malloc ()和 free() 完成内存的配置与释放，这对组合可以解决第一第二点问题（通过类似与new-handle的机制不断尝试释放、配置直到成功分配或者bad_alloc）。<br>
考虑到第三点：小型区块所可能造成的内存破碎问题，SGI设计了双层级配置器，第一级配置器如上述直接使用malloc()和free(),第二级配置器则视情况采用不同的策略</p>
<p>其中第二级配置器为默认配置器<br>
当配置区块超过128 bytes 时,视之为“足够大”，便调用第一级配置器；<br>
当配置区块小于128 bytes时，视之为“过小”，直接使用第二级配置器<br>
为了降低额外负担(overhead)，便采用复杂的memory pool整理方式，而不再求助于第一级配置器。</p>
<p>第二级配置器的具体做法是，如果区块够大，超过128 bytes时，就移交第一级配置器处理。当区块小于128 bytes时，则以内存池(memory pool)管理，</p>
<p>此法又称为次层配置(sub-allocation):每次配置一大块内存，并维护对应之自由链表 (free-list)。下次若再有相同大小的内存需求，就直接从free-lists中拨出。如果客端释还小额区块，就由配置器回收到free-lists中<br>
为了方便管理，SGI第二级配置器会主动将任何小额区块的内存需求量上调至8的倍数(例如客端要求30 bytes,就自动调整为32 bytes) , 并维护 16 个free-lists.各自管理大小分别为 8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 96, 104, 112, 120, 128 bytes的小额区块。<br>
其中为了节省空间，链表节点使用union，第一字段观obj可被视为一个指针，指向相同形式的另一个。第二字段可被视为一个指针，指向实际区块，</p>
<p>空间配置函数allocate()首先判断区块大小，大于128 bytes就调用第一级配置器，小于128 bytes就检查对应的free list。如果free list之内有可用的区块，就直接拿来 用，如果没有可用区块，就将区块大小上调至8倍数边界，然后调用refill(), 准备为free list重新填充空间。新的空间将取自内存池(经由 chunk_alloc()完成)。缺省取得20个新节点(新区块)，但万一内存池空间不足，获得的节点数(区块数)可能小于20</p>
<p>从内存池中取空间给free_list使用，是chunk_alloc()的工作：</p>
<ol>
<li>chunk_alloc() 函数判断内存池的余量。如果余量充足，就直接调出20个区块返回给freelist。</li>
<li>如果余量不足以提供20个区块，但还足够供应一个以上的区块，就拨出这不足20个区块的空间出去。同时参数将被修改为实际能够供应的区块数。</li>
<li>如果 内存池连一个区块空间都无法供应，对客端显然无法交待，此时便需利用malloc() 从heap中配置内存。新余量的大小为需求量的两倍，再加上一个随着配置次数增加而愈来愈大的附加量。</li>
<li>万一整个system heap空间都不够了，malloc ()行动失败，chunk_alloc ()就四处寻找有无尚有未用区块,且区块够大之free lists.找到了就挖一块交出</li>
<li>最后找不到就调用第一级配置器。第一级配置器其实也是使用 malloc() 来配置内存，但它有out-of-memory处理机制 (类似new-handler机制)，或许有机会释放其它的内存拿来此处使用。如果可以,就成功，否则发出bad_alloc异常。</li>
</ol>
<p>空间释放函数deallocate()首先判断区块大小，大于128 bytes就调用第一级配置器， 小于128 bytes就找出对应的free_list,将区块回收。</p>
<p>所以最终STL内存配置的流程为:</p>
<ol>
<li>
<p>使用allocate向内存池请求size大小的内存空间, 如果需要请求的内存大小大于128bytes, 直接使用malloc.</p>
</li>
<li>
<p>如果需要的内存大小小于128bytes, allocate根据size找到最适合的自由链表.<br>
　　1) 如果链表不为空, 返回第一个node, 链表头改为第二个node.<br>
　　2) 如果链表为空, 使用blockAlloc请求分配node.<br>
　　　　x. 如果内存池中有大于一个node的空间, 分配竟可能多的node(但是最多20个), 将一个node返回, 其他的node添加到链表中.<br>
　　　　y. 如果内存池只有一个node的空间, 直接返回给用户.<br>
　　　　z. 若果如果连一个node都没有, 再次向操作系统请求分配内存.<br>
　　　　　　①分配成功, 再次进行b过程<br>
②分配失败, 循环各个自由链表, 寻找空间<br>
I. 找到空间, 再次进行过程b<br>
II. 找不到空间, 抛出异常(代码中并未给出, 只是给出了注释)</p>
</li>
<li>
<p>用户调用deallocate释放内存空间, 如果要求释放的内存空间大于128bytes, 直接调用free.</p>
</li>
<li>
<p>否则按照其大小找到合适的自由链表, 并将其插入.</p>
</li>
</ol>
<p>注意：</p>
<ol>
<li>刚开始初始化内存池的时候, 其实内存池中并没有内存, 同时所有的自由链表都为空链表.</li>
<li>只有用户第一次向内存池请求内存时, 内存池会依次执行上述过程的 1-&gt;2-&gt;b-&gt;z来完成内存池以及链表的首次填充, 而此时, 其他未使用链表仍然是空的.</li>
<li>所有已经分配的内存在内存池中没有任何记录, 释放与否完全靠程序员自觉.</li>
<li>释放内存时, 如果大于128bytes, 则直接free, 否则加入相应的自由链表中而不是直接返还给操作系统.</li>
</ol>
<p>参考资料：<br>
《STL源码剖析》<br>
allocator的必要接口：</p>
<pre><code>//以下各种type的设计原由，第3章详述
allocator::value_type
allocator：:pointer
allocator::const_pointer
allocator：:reference
allocator：:const_reference
allocator::size_type
allocator::di f ference_type
allocator::rebind
</code></pre>
<ul>
<li>allocator::rebind<br>
一个嵌套的(nested) class template。<code>classrebind&lt;U&gt;</code>拥有唯一成员 other,那是一个typedef,代表 <code>allocator&lt;U&gt;</code></li>
<li>allocator::allocator()<br>
default constructor默认构造函数（注意不是construct）</li>
<li>allocator::allocator(const allocator&amp;)<br>
copy constructor拷贝构造函数</li>
<li><code>template &lt;class U&gt;allocator::allocator(const allocator&lt;U&gt;&amp;)</code><br>
泛化的 copy constructor拷贝构造函数</li>
<li>allocator::-allocator()<br>
default constructor</li>
<li>pointer allocator::address(reference x) const<br>
返回某个对象的地址。算式 a.address(x) 等同于&amp;x</li>
<li>const pointer allocator::address(const_reference x) const<br>
返回某个 const 对象的地址。算式a.address (x)等同于&amp;x</li>
<li>pointer allocator::allocate (size_type n,cosnt void* = 0)<br>
配置空间，足以存储n个T对象.第二参数是个提示。实现上可能会利用它来增进区域性(locality),或完全忽略之</li>
<li>void allocator::deallocate(pointer p,size_type n)<br>
归还先前配置的空间</li>
<li>size_type allocato::max_size() const<br>
返回可成功配置的最大量</li>
<li>void allocator::construct(pointer p,const T&amp; x)<br>
等同于 new(const void*) p) T(x)</li>
<li>void allocator::destroy(pointer p)<br>
等同于 p-&gt;~T()</li>
</ul>
<p><img src="https://lixin-scut.github.io//post-images/1582443665448.png" alt=""></p>
<p>虽然SGI也定义有一个符合部分标准、名为allocator的配置器，但SGI 自己从未用过，也不建议我们使用，主要原因是效率不佳，只把C++的::operator new和::operator delete做一层薄薄的包装而已。</p>
<p>2.2.2	SGI特殊的空间配置器，std::alloc<br>
<img src="https://lixin-scut.github.io//post-images/1582444320205.png" alt=""><br>
这其中的new 算式内含两阶段操作：<br>
(1)调用::operator new 配置内存;<br>
(2)调用Foo::Foo()构造对象内容。<br>
delete算式也内含两阶段操作：<br>
(1)调用Foo::~Foo() 将对象析构；<br>
(2)调用 ::operator delete 释放内存。</p>
<p>为了精密分工，STL allocator决定将这两阶段操作区分开来。<br>
内存配置操 作由alloc::allocate ()负责，内存释放操作由 alloc::deallocate () 负责；<br>
对象构造操作由::construct ()负责，对象析构操作由 ::destroy ()负责</p>
<pre><code>STL标准规格告诉我们，配置器定义于 &lt;memory&gt;之中 ,SGI &lt;memory&gt; 内 含以下两个文件：
#include &lt;stl_alloc .h&gt;	//负责内存空间的配置与释放
#include &lt;stl_construct. h&gt;	/ /负责对象内容的构造与析构
</code></pre>
<p><img src="https://lixin-scut.github.io//post-images/1582444604245.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582444619328.png" alt=""></p>
<p>2.2.3	构造和析构基本工具：construct()和destroy()<br>
<img src="https://lixin-scut.github.io//post-images/1582444781513.png" alt=""><br>
construct() 接受一个指针P和一个初值 value, 该函数的用途就是将初值设定到指针所指的空间上。<br>
destroy() 有两个版本，第一版本接受一个指针，准备将该指针所指之物析构掉。这很简单，直接调用该对象的析构函数即可。第二版本接受 first 和 last 两个迭代器(所谓迭代器，第3章有详细介绍)，准备将<code>[first, last)</code>范围内的所有对象析构掉。我们不知道这个范围有多大，万一很大，而每个对象的析构函数都无关痛痒(所谓trivial destructor),那么一次次调用这些无关痛痒的析构函数, 对效率是一种伤害。因此，这里首先利用 value_type() 获得迭代器所指对象的型别，再利用 <code>_type_traits&lt;T&gt;</code>判断该型别的析构函数是否无关痛痒。若是 (<code>_true_type</code>),则什么也不做就结束；若否(<code>_false_type</code>),这才以循环方式巡访整个范围，并在循环中每经历一个对象就调用第一个版本的destroy()。</p>
<p>2.2.4	空间的配置与释放，std::alloc<br>
对象构造前的空间配置和对象析构后的空间释放，由 &lt;stl_alloc.h&gt; 负责， SGI对此的设计哲学如下：<br>
•	向system heap要求空间。<br>
•	考虑多线程(multi-threads)状态。(书中暂不考虑多线程的复杂情况)<br>
•	考虑内存不足时的应变措施。<br>
•	考虑过多“小型区块”可能造成的内存碎片(fragment)问题。<br>
C++的内存配置基本操作是 ::operator new(), 内存释放基本操作 是 ::operator delete()。 这两个全局函数相当于C的malloc ()和 free()函 数。<br>
SGI正是以malloc ()和 free() 完成内存的配置与释放。<br>
考虑到小型区块所可能造成的内存破碎问题，SGI设计了双层级配置器，第一级配置器直接使用malloc()和free(),第二级配置器则视情况采用不同的策略<br>
当配置区块超过128 bytes 时,视之为“足够大”，便调用第一级配置器；<br>
当配 置区块小于128 bytes时，视之为“过小”<br>
为了降低额外负担(overhead)，便采用复杂的memory pool整理方式，而不再求助于第一级配置器。<br>
整个设计究竟只开放第一级配置器，或是同时开放第二级配置器，取决于__USE_MALLOC 是否被定义(唔，我们可以轻易测试出来，SGI STL并未定义__USE_MALLOC，亦即同时开放第二级配置器 ):<br>
<img src="https://lixin-scut.github.io//post-images/1582446124190.png" alt=""><br>
其中 <code>__malloc_alloc_template</code> 就是第一级配置器，<code>__default_alloc_ template</code>就是第二级配置器。注意，alloc并不接受任何template型别参数。<br>
无论alloc被定义为第一级或第二级配置器，SGI还为它再包装一个接口如<br>
下，使配置器的接口能够符合STL规格<br>
<img src="https://lixin-scut.github.io//post-images/1582446468140.png" alt=""><br>
其内部四个成员函数其实都是单纯的转调用，调用传递给配置器(可能是第一级，也可能是第二级)的成员函数。<br>
这个接口使配置器的配置单位从bytes转为个别元素的大小(sizeof (T) ) ，SGI STL容器全都使用这个 simple_alloc 接口<br>
<img src="https://lixin-scut.github.io//post-images/1582446536993.png" alt=""><br>
一、二级配置器的关系，接口包装，及实际运用方式<br>
<img src="https://lixin-scut.github.io//post-images/1582446613792.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582446938165.png" alt=""></p>
<p>2.2.5 第一级配置器<code>__malloc_alloc_template</code><br>
第一级配置器以 malloc(), free(), realloc() 等c函数执行实际的内存 配置、释放、重配置操作，并实现出类似C++new-handle的机制。是的，它不能直接运用C++new-handler机制，因为它并非使用 ::operator new 来配置内存.<br>
所谓C++ new handler机制是你可以要求系统在内存配置需求无法被满足时，调用一个你所指定的函数。换句话说，一旦:operator new 无法完成任务,在丢出std::bad_elloc异常状态之前，会先调用由客端指定的处理例程，该处理例程通常即被称为new-handiero new-handier解决内存不足的做法有特定的模式</p>
<p>请注意，SGI第一级配置器的 allocate() 和 realloc() 都是在调用 malloc()和 realloc() 不成功后，改调用 oom_malloc() 和 oom_realloc()。 后两者都有内循环，不断调用“内存不足处理例程”，期望在某次调用之后，获得足够的内存而圆满完成任务。但如果“内存不足处理例程”并未被客端设定， oom_malloc() 和 oom_realloc() 便老实不客气地调用 <code>_THROW_BAD_ALLOC</code>, 丢出bad_alloc异常信息，或利用exit(1)硬生生中止程序。</p>
<p>2.2.6	第二级配置器<code>__default_alloc_template</code>剖析<br>
第二级配置器多了一些机制，避免太多小额区块造成内存的碎片。小额区块带<br>
来的其实不仅是内存碎片，配置时的额外负担(overhead)也是一个大问题。额外<br>
负担永远无法避免，毕竟系统要靠这多出来的空间来管理内存，如图2-3所示。但 是区块愈小，额外负担所占的比例就愈大，愈显得浪费。</p>
<p>SGI第二级配置器的做法是，如果区块够大，超过128 bytes时，就移交第一级配置器处理。当区块小于128 bytes时，则以内存池(memory pool)管理，<br>
此法又称为次层配置(sub-allocation):每次配置一大块内存，并维护对应之自由链表 (free-list)。下次若再有相同大小的内存需求，就直接从free-lists中拨出。如果客端释还小额区块，就由配置器回收到free-lists中——是的，别忘了，配置器除了负责配置，也负责回收。<br>
为了方便管理，SGI第二级配置器会主动将任何小额区块的内存需求量上调至8的倍数(例如客端要求30 bytes,就自动调整为32 bytes) , 并维护 16 个free-lists.各自管理大小分别为 8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 96, 104, 112, 120, 128 bytes的小额区块。free-lists的节点结构如下：</p>
<pre><code>union obj {
union obj * free_list_link;
char client_data[1];	 /* The client sees this, */
};
</code></pre>
<p>诸君或许会想，为了维护链表(lists),每个节点需要额外的指针(指向下一 个节点)，这不又造成另一种额外负担吗？你的顾虑是对的，但早已有好的解决办<br>
法。注意，上述obj所用的是union, 由于 union 之故，从其第一字段观之,<br>
obj可被视为一个指针，指向相同形式的另一个。从其第二字段观之，可被视为一个指针，指向实际区块，如图2-4所示。一物二用的结果是，不会为了维<br>
护链表所必须的指针而造成内存的另一种浪费(我们正在努力节省内存的开销呢)。<br>
这种技巧在强型(strongly typed)语言如Java中行不通，但是在非强型语言如C+十<br>
中十分普遍<br>
<img src="https://lixin-scut.github.io//post-images/1582447931963.png" alt=""></p>
<p>2.2.7 空间配置函数allocate()<br>
身为一个配置器，<code>__default_alloc_template</code>拥有配置器的标准接口函数<br>
allocate()。 此函数首先判断区块大小，大于128 bytes就调用第一级配置器，小于128 bytes就检查对应的free list。如果free list之内有可用的区块，就直接拿来 用，如果没有可用区块，就将区块大小上调至8倍数边界，然后调用refill(), 准备为free list重新填充空间。<br>
<img src="https://lixin-scut.github.io//post-images/1582448121791.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582448143766.png" alt=""><br>
<strong>备注</strong>：注意其实result-&gt;free_list_link;这里等于是next指针，相当于把头节点指向下一个节点，可在下一节得证</p>
<p>2.2.8 空间释放函数deallocate()<br>
身为一个配置器，<code>__default_alloc_template</code>拥有配置器标准接口函数 deallocate()。 该函数首先判断区块大小，大于128 bytes就调用第一级配置器， 小于128 bytes就找出对应的free list,将区块回收。<br>
<img src="https://lixin-scut.github.io//post-images/1582448357314.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582448420144.png" alt=""></p>
<p>2.2.9	重新填充free lists<br>
回头讨论先前说过的allocate()。当它发现free list中没有可用区块了时， 就调用refill()，准备为freelist重新填充空间。新的空间将取自内存池(经由 chunk_alloc()完成)。缺省取得20个新节点(新区块)，但万一内存池空间不足，获得的节点数(区块数)可能小于20：<br>
<img src="https://lixin-scut.github.io//post-images/1582448504177.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582448521568.png" alt=""><br>
voliate变量是随时变化的，用voliate修饰的运算，编译器不进行优化，以免出错</p>
<p>2.2.10 内存池( memory pool)<br>
从内存池中取空间给free list使用，是chunk_alloc()的工作：<br>
<img src="https://lixin-scut.github.io//post-images/1582449342167.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582449365595.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582449383349.png" alt=""><br>
上述的 chunk_alloc() 函数以 end_free - start_free 来判断内存池的水量。如果水量充足，就直接调出20个区块返回给freelist.如果水量不足以提供20个区块，但还足够供应一个以上的区块，就拨出这不足20个区块的空间出去。这时候其pass by reference的nobjs参数将被修改为实际能够供应的区块数。如果 内存池连一个区块空间都无法供应，对客端显然无法交待，此时便需利用malloc() 从heap中配置内存，为内存池注入活水源头以应付需求。新水量的大小为需求量的两倍，再加上一个随着配置次数增加而愈来愈大的附加量。<br>
万一山穷水尽，整个system heap空间都不够了(以至无法为内存池注入活水 源头)，malloc ()行动失败，chunk_alloc ()就四处寻找有无尚有未用区块,<br>
且区块够大之free lists.找到了就挖一块交出，找不到就调用第一级配置器。第一级配置器其实也是使用 malloc() 来配置内存，但它有out-of-memory处理机制 (类似new-handler机制)，或许有机会释放其它的内存拿来此处使用。如果可以, 就成功，否则发出bad.alloc异常。<br>
<img src="https://lixin-scut.github.io//post-images/1582449531828.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582449557765.png" alt=""><br>
STL的容器都可以设置配置器，并默认设置为第二级配置器</p>
<p>2.3	内存基本处理工具<br>
STL定义有五个全局函数，作用于未初始化空间上。这样的功能对于容器的实 现很有帮助，我们会在第4章容器实现代码中，看到它们肩负的重任。前两个函数是 2.2.3节说过的、用于构造的 construct() 和用于析构的destroy(),另三个函数是 uninitialized_copy () / uninitialized_fill () / uninitialized_fill_n () 分别对应于高层次函数 copy () 、fill () 、fill_n ()	这些都是 STL 算法，将<br>
如果你要使用本节的三个低层次函数，应该包含 <code>&lt;memory&gt;</code>, 不过 SGI把它们实际定义于 <code>&lt;stl_uninitialized&gt;</code>。</p>
<p>2.3.1	uninitialized_copy</p>
<pre><code>template &lt;class InputIterator, class ForwardIterator&gt;
ForwardIterator
uninitialized_copy(InputIterator first, InputIterator last,
															ForwardIterator result);
</code></pre>
<p>uninitialized_copy() 使我们能够将内存的配置与对象的构造行为分离开来。如果作为输出目的地的<code>[result, result+(last-first))</code>范围内的每一个迭代器都指向未初始化区域，则 uninitialized_copy () 会使用 copy constructor, 给身为输入来源之<code>[first,last)</code>范围内的每一个对象产生一份复制品，放进输出范围中。换句话说，针对输入范围内的每一个迭代器i，该函数会调用 <code>construct (&amp;* (results- (i-first)) , *i)</code>,产生*i的复制品，放置于输出范围的相对位置上<br>
如果你需要实现一个容器， uninitialized_copy() 这样的函数会为你带来 很大的帮助，因为容器的全区间构造函数(range constructor)通常以两个步骤完成：<br>
•配置内存区块，足以包含范围内的所有元素.<br>
•使用 uninitiali zed_copy(), 在该内存区块上构造元素.</p>
<p>uninitialized_copy具有 ucommit or rollback 语意，要么“构造出所有必要元素”，要么(当有任何一个copy constructor失败时)“不构造任何东西”.</p>
<p>2 3.2 uninitialized_fill</p>
<pre><code>template &lt;class ForwardIterator, class T&gt;
void uninitialized_fill(Forwarditerator first, ForwardIterator last, 
																const T&amp; x)；
</code></pre>
<p>uninitialized_fill() 也能够使我们将内存配置与对象的构造行为分离开 来。如果 <code>[first,last )</code>范围内的每个迭代器都指向未初始化的内存，那么 uninitialized_fill() 会在该范围内产生x (上式第三参数)的复制品。换句话 说，uninitialized_fill ()会针对操作范围内的每个迭代器i,调用 <code>construct(&amp;*i, x)</code>, 在i所指之处产生x的复制品.式中的 construct() 已 于2.2.3节讨论过。<br>
与 uninitialized_copy() 一样，uninitialized_fill() 必须具备&quot;commit or rollback语意，换句话说，它要么产生出所有必要元素，要么不产生任何元素。 如果有任何一个copy constructor丢出异常(exception) ,uninitialized_fill()必须能够将已产生的所有元素析构掉。</p>
<p>2.3.3	uninitialized_fill_n</p>
<pre><code>template &lt;class ForwardIterator, class Size, class T&gt; 
ForwardIterator
uninitialized_fill_n(ForwardIterator first, Size nz, const T&amp; x)；
</code></pre>
<p>uninitialized_fill_n ()能够使我们将内存配置与对象构造行为分离开来。 它会为指定范围内的所有元素设定相同的初值。<br>
如果<code>[first, first+n)</code>范围内的每一个迭代器都指向未初始化的内存，那么uninitialized_f ill_n ()会调用 copy constructor,在该范围内产生x (上式第三参数)的复制品。也就是说，面对<code>[first z first+n)</code> 范围内的每个迭代器i， uninitialized_fill_n ()会调用 <code>construct(&amp;*i, x)</code>,在对应位置处产生 x 的复制品。<br>
uninitialized_fill_n ()也具有 commit or rollback语意：要么产生所有必要的元素，否则就不产生任何元素。如果任何一个copy constructor丢出异常 (exception) &gt; uninitialized_fill_n()必须析构已产生的所有元素。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 题26:树的子结构[未做出]]]></title>
        <id>https://lixin-scut.github.io//post/shu-ti-26shu-de-zi-jie-gou-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/shu-ti-26shu-de-zi-jie-gou-wei-zuo-chu">
        </link>
        <updated>2020-02-23T01:25:18.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
</blockquote>
<p>【未做出】<br>
首先一定要注意递归和判断中使用的函数和顺序（这一点其实已经做得很好了）HasSubtree函数负责确定根结点，isSubTree负责遍历每个结点是否相符<br>
我犯的致命错误就是忘记了isSubTree中判断的是子结构，cur2出现NULL的时候cur1完全有可能不是NULL<br>
一定要理解先判断cur2为NULL再判断cur1为NULL的原因</p>
<pre><code>class Solution {
public:
    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)
    {
        if(pRoot1==NULL||pRoot2==NULL)
             return false;
        return isSubTree(pRoot1,pRoot2)||HasSubtree(pRoot1-&gt;left,pRoot2)||HasSubtree(pRoot1-&gt;right,pRoot2);
    }
        
    bool isSubTree(TreeNode* cur1, TreeNode* cur2){
        if(cur2==NULL)
            return true;
        if(cur1==NULL)
            return false;
        if(cur1-&gt;val!=cur2-&gt;val)
            return false;
        return isSubTree(cur1-&gt;left,cur2-&gt;left)&amp;&amp;isSubTree(cur1-&gt;right,cur2-&gt;right);
    }
};
</code></pre>
<p>书本题解：<br>
要查找树A中是否存在和树B结构一样的子树，我们可以分成两步：第一步，在树A中找到和树B的根节点的值一样的节点R;第二步，判断树A中以R为根节点的子树是不是包含和树B一样的结构。<br>
第一步在树A中查找与根节点的值一样的节点，这实际上就是树的遍历。对二叉树这种数据结构熟悉的读者自然知道可以用递归的方法去遍历, 也可以用循环的方法去遍历。由于递归的代码实现比较简洁，如果没有特别要求，那么我们通常会采用递归的方式。<br>
一定要注意边界条件的检查，即检查空指针。当树A或树B为空的时候，定义相应的输出。<br>
我们递归调用HasSubtree遍历二叉树A。如果发现某一节点的值和树B的头节点的值相同，则调用DoesTreelHaveTree2,进行第二步判断。<br>
第二步是判断树A中以R为根节点的子树是不是和树B具有相同的结构。同样，我们也可以用递归的思路来考虑：如果节点R的值和树B的根节点不相同，则以R为根节点的子树和树B肯定不具有相同的节点；如果它们的值相同，则递归地判断它们各自的左右节点的值是不是相同。递归的终止条件是我们到达了树A或者树B的叶节点<br>
需要多处判断一个指针是不是nullptr,这样做是为了避免试图访问空指针而造成程序崩溃，同时也设置了递归调用的退出条件。在写遍历树的代码的时候一定要高度警惕，在每一处需要访问地址的时候都要问自己这个地址有没有可能是nullptr、如果是nullptr则该怎么处理。<br>
一个细节值得我们注意：本题中节点中值的类型为double，由于计算机表示小数(包括float和double型小数)都有误差，我们不能直接用等号(==)判断两个小数是否相等。如果两个小数的差的绝对值 很小，如小于0.0000001,就可以认为它们相等<br>
所以在判断两个节点的值是不是相等时，不能直接写pRoot1-&gt;m_dbValue == pRoot2-&gt;m_ dbValue,这是因为在计算机内表示小数时(包括float和double型小数)都有误差。判断两个小数是否相等，只能判断它们之差的绝对值是不是在一个很小的范围内。如果两个数相差很小，就可以认为它们相等。这就是我 们定义函数Equal的原因。</p>
<pre><code>bool HasSubtree(BinaryTreeNode* pRoot1, BinaryTreeNode* pRoot2)
{
    bool result = false;

    if(pRoot1 != nullptr &amp;&amp; pRoot2 != nullptr)
    {
        if(Equal(pRoot1-&gt;m_dbValue, pRoot2-&gt;m_dbValue))
            result = DoesTree1HaveTree2(pRoot1, pRoot2);
        if(!result)
            result = HasSubtree(pRoot1-&gt;m_pLeft, pRoot2);
        if(!result)
            result = HasSubtree(pRoot1-&gt;m_pRight, pRoot2);
    }

    return result;
}

bool DoesTree1HaveTree2(BinaryTreeNode* pRoot1, BinaryTreeNode* pRoot2)
{
    if(pRoot2 == nullptr)
        return true;

    if(pRoot1 == nullptr)
        return false;

    if(!Equal(pRoot1-&gt;m_dbValue, pRoot2-&gt;m_dbValue))
        return false;

    return DoesTree1HaveTree2(pRoot1-&gt;m_pLeft, pRoot2-&gt;m_pLeft) &amp;&amp;
        DoesTree1HaveTree2(pRoot1-&gt;m_pRight, pRoot2-&gt;m_pRight);
}

bool Equal(double num1, double num2)
{
    if((num1 - num2 &gt; -0.0000001) &amp;&amp; (num1 - num2 &lt; 0.0000001))
        return true;
    else
        return false;
}
</code></pre>
<p>书中思路分析很清楚，包括对函数的分割和返回值的设置，以及对nullptr的检测。<br>
然后最重点的就是对double和float的相等判断条件。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[空指针、野指针与空悬指针]]></title>
        <id>https://lixin-scut.github.io//post/kong-zhi-zhen-ye-zhi-zhen-yu-kong-xuan-zhi-zhen</id>
        <link href="https://lixin-scut.github.io//post/kong-zhi-zhen-ye-zhi-zhen-yu-kong-xuan-zhi-zhen">
        </link>
        <updated>2020-02-22T10:09:54.000Z</updated>
        <content type="html"><![CDATA[<h3 id="空指针">空指针</h3>
<p>被初始化或赋值为nullptr、NULL或者0的指针</p>
<h3 id="野指针">野指针</h3>
<p>就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）指针变量在定义时如果未初始化，其值是随机的，指针变量的值是别的变量的地址，意味着指针指向了一个地址是不确定的变量，此时去解引用就是去访问了一个不确定的地址，所以结果是不可知的。</p>
<h3 id="空悬指针">空悬指针</h3>
<p>当指针所指向的对象已经被销毁或者被析构之后，指针对象本身还是存在的，但是已经成为了空悬指针。</p>
<pre><code>int * func ( void )
{
    int num = 123;
    /* ... */
    return &amp;num; //返回一个空悬指针
}
</code></pre>
<p>实验：</p>
<pre><code>int main() {
    int* nullPtr = nullptr;
    int* unknowPtr ;
    int* emptyPtr = new int(100);
    delete emptyPtr;
    cout &lt;&lt; nullPtr &lt;&lt; &quot; &quot; &lt;&lt; unknowPtr &lt;&lt; &quot; &quot; &lt;&lt; emptyPtr &lt;&lt; endl;
    cout&lt;&lt; *emptyPtr &lt;&lt; endl; //cannot *nullPtr,*unknowPtr,*emptyPtr
}
</code></pre>
<p>环境：Clion<br>
编译器：clang-902.0.39.2</p>
<p>结果</p>
<pre><code>0x0 0x0 0x7fcfe4400370
100
</code></pre>
<p>可以看到这个编译器下，空指针和野指针都是指向了同一个地址，所以都不能解引用，而emptyPtr还有趣，解引用后还是同一个值，查阅之后发现原来delete也不是立马把内存中的对象清除，而是先保留，等到有对象需要堆内存的时候可以直接清除。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ C++ 11 智能指针]]></title>
        <id>https://lixin-scut.github.io//post/c-11-zhi-neng-zhi-zhen</id>
        <link href="https://lixin-scut.github.io//post/c-11-zhi-neng-zhi-zhen">
        </link>
        <updated>2020-02-22T08:02:42.000Z</updated>
        <content type="html"><![CDATA[<p>需要注意的点：</p>
<ol>
<li>shared_ptr：允许多个指针指向同一个对象；</li>
<li>unique_ptr独占所指向的对象</li>
<li>weak_ptr 弱引用，指向shared_ptr管理的对象 。</li>
<li>这三种都定义在memory头文件</li>
<li>智能指针也是模板，创建时必须提供指针指向的类型</li>
<li>默认初始化的智能指针保存一个空指针</li>
<li>智能指针并不支持指针算术操作</li>
<li>使用get时，若智能指针释放了其对象，返回的指针所指向的对象也就消失了</li>
<li>将shared_ptr放在容器中容易因重新排序等因素忘记进行销毁</li>
<li>使用动态内存的原因：1.不知道需要使用多少对象2.不知道所需对象的准确类型3.！！程序需要在多个对象间共享数据，使用动态内存的一个常见原因就是允许多个对象共享相同的状态（亦即如果进行拷贝操作，实际上还是只有一个对象在内存中，而不是真的复制多个对象）</li>
<li>默认情况下动态分配的对象是默认初始化的，所以内置类型或组合类型（类中包含的类）的对象的值将是未定义的，而类类型对象将用默认构造函数进行初始化（值初始化的内置类型有着良好定义的值，而默认初始化的值则是未定义的）</li>
<li>传递给delete的指针必须指向动态分配的内存，或者是一个空指针，释放一块并非new分配的内存，或者将相同的指针值释放多次，其行为都是未定义的（能通过编译，但是编译器会自动delete栈内存，智能指针又delete一次，所以造成二次delete）。</li>
<li>通常情况下编译器不能分辨一个指针指向静态还是动态分配的对象，同样也不能分辨指针指向的内存是否已被释放，所以错误的delete表达式都会被通过</li>
<li>单接受指针参数的智能指针构造函数explicit的，所以我们不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化的形式来初始化一个智能指针，同样地一个返回shared_ptr的函数不能在其返回语句中隐式转换一个普通指针<br>
使用get返回的指针的代码不能delete此指针</li>
<li>永远不要用get初始化另一个智能指针或者为另一个智能指针赋值（因为不知道对象何时会被销毁）</li>
<li>当发生异常时，内置指针直接管理的内存是不会自动释放（但是智能指针的会检查引用计数并销毁）</li>
<li>不能拷贝unique_ptr的规则有一个例外，我们可以拷贝或赋值一个将要被销毁的unique_ptr</li>
<li>当我们创建一个weak_ptr时，要用一个shared_ptr来初始化它</li>
<li>由于对象可能不存在，我们不能使用weak_ptr直接访问对象，而必须调用lock，此函数检查weak_ptr指向的对象是否仍存在并返回相应的shared_ptr。</li>
<li>小心造成shared_ptr循环引用的问题：循环引用就是：两个对象互相使用一个shared_ptr成员变量指向对方。</li>
<li>弱指针用于专门解决shared_ptr循环引用的问题，weak_ptr不会修改引用计数，即其存在与否并不影响对象的引用计数器。</li>
</ol>
<p>补充：<br>
scoped_ptr是一个类似于auto_ptr的智能指针，它包装了new操作符在堆上分配的动态对象，能够保证动态创建的对象在任何时候都可以被正确的删除。但是scoped_ptr的所有权更加严格，不能转让，一旦scoped_pstr获取了对象的管理权，你就无法再从它那里取回来。<br>
scoped_str的构造函数接受一个类型为T* 的指针p，创建出一个scoped_ptr对象，并在内部保存指针参数p。p必须是一个new表达式动态分配的结果，或者是一个空指针(0)。当scoped_ptr对象的生命周期结束时，析构函数~scoped_ptr()会使用delete操作自动销毁所保存的指针对象，从而正确的回收资源。<br>
scoped_ptr同时把拷贝构造函数和赋值操作都声明为私有的，禁止对智能指针的复制操作，保证了被它管理的指针不能被转让所有权。</p>
<p>enable_shared_from_this ：这是一个以其派生类为模板类型实参的 基类模板，当类继承自它时，this指针就能变身为shared_ptr<br>
为了使用 shared_from_this()，类的对象 不能是 stack object,必须是 heap object且由shared_ptr管理其生命期<br>
注意一点，shared_from_this()不能在构造函数里调用，因为在构造StockFactory 的时候，它还没有被交给shared_ptr接管。</p>
<p>但为了防止拷贝shared_ptr造成生命期延长，可以使用weak_ptr，在回调的时候先尝试提升为shared_ptr,如果提升成功，说明接受回调的对象还健在，那么就执行回调；如果提升失败，就说明对象已经被销毁了。</p>
<p>参考资料：<br>
《C++primer》<br>
12动态内存<br>
<strong>静态内存</strong>用于保存局部static对象、类static数据成员以及定义在任何函数之外的变量<br>
<strong>栈内存</strong>用于保存定义在函数内的非static对象<br>
分配在静态内存和栈内存中的对象由<strong>编译器自动创建和销毁</strong>，栈对象在程序运行时才存在，static对象在使用前分配，程序结束时销毁<br>
除了静态内存和栈内存，每个程序还有一个<strong>内存池，称为自由空间或堆</strong>，程序用堆来存储动态分配的对象</p>
<p>12.1动态内存和智能指针<br>
动态内存的管理，new：在动态内存中为对象分配空间并返回一个指向该对象的指针，可以对其进行初始化；delete：接受一个动态对象的指针，销毁该对象，并释放与之关联的内存<br>
新的标准库为了使用动态内存提供了两种智能指针，与常规指针相比重要的区别在于它负责<strong>自动释放</strong>所指对象，<br>
shared_ptr：允许多个指针指向同一个对象；unique_ptr独占所指向的对象 weak_ptr 弱引用，指向shared_ptr管理的对象 。这三种都定义在memory头文件中</p>
<p>12.1.1shared_ptr<br>
智能指针也是模板，创建时必须提供指针指向的类型<br>
默认初始化的智能指针保存一个空指针<br>
智能指针并不支持指针算术操作<br>
<img src="https://lixin-scut.github.io//post-images/1582359705706.png" alt=""></p>
<p>！！使用get时，若智能指针释放了其对象，返回的指针所指向的对象也就消失了<br>
最安全的分配和使用动态内存的方法是调用一个名为make_shared的标准库函数，此函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr，make_shared定义在头文件memory中<br>
make_shared用其参数来构造给定类型的对象，比如调用<code>make_shared&lt;string&gt;</code>必须传递与string某个构造函数相匹配的参数。如果不传递任何参数，对象就会进行值初始化<br>
当进行拷贝赋值操作时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象<br>
我们可以认为每个shared_ptr都有一个关联计数器，通常称其为引用计数。无论何时我们拷贝一个shared_ptr都会递增计数器<br>
递增计数器的情况1.用一个shared_ptr初始化另外一个shared_ptr2.将shared_ptr作为参数传递给一个函数3. shared_ptr作为函数的返回值<br>
递减计数器 1.给shared_ptr赋一个新值2. shared_ptr被销毁3. 局部的shared_ptr离开其作用域（在函数中定义的shared_ptr都是局部变量，在函数执行结束后都会被销毁）<br>
一旦shared_ptr的计数器变为0，就会自动释放所管理的对象，可以确保分配的对象在恰当的时刻被释放<br>
每个类都有一个析构函数，控制此类型的对象销毁时会做什么操作<br>
将shared_ptr放在容器中容易因重新排序等因素忘记进行销毁，导致内存浪费，所以要记得用erase删除容器中不需要的shared_ptr元素<br>
使用动态内存的原因：1.不知道需要使用多少对象2.不知道所需对象的准确类型3.！！程序需要在多个对象间共享数据</p>
<p>当两个对象共享底层的数据时，当某个对象被销毁，不能单方面地销毁底层数据<br>
使用动态内存的一个常见原因就是允许多个对象共享相同的状态<br>
<code>initializer_list&lt;string&gt;</code>类型参数接受一个初始化器的花括号列表</p>
<p>12.1.2直接管理内存<br>
运算符new分配内存，delete释放new分配的内存<br>
相对于智能指针，使用这两个运算符管理内存非常容易出错，它们不能依赖类对象拷贝、赋值和销毁操作的任何默认定义<br>
使用智能指针的程序更容易编写和调试<br>
在自由空间分配的内存时无名的，所以new无法为其分配的对象命名，而是返回一个指向该对象的指针<br>
<code>int *pi = new int;	//pi指向一个动态分配的，未初始化的无名对象；</code><br>
默认情况下动态分配的对象是默认初始化的，所以内置类型或组合类型（类中包含的类）的对象的值将是未定义的，而类类型对象将用默认构造函数进行初始化<br>
我们可以用直接初始化的方式来初始化一个动态分配的对象，新标准下也可以用花括号</p>
<p>（注意第二个为拷贝初始化而非直接初始化）<br>
也可以对动态分配的对象进行值初始化，只需在类型名后面加上一对空括号<br>
对于类类型来说，由于有构造函数所以值初始化意义不大，但是对于内置类型，两种类型的差别很大，值初始化的内置类型有着良好定义的值，而默认初始化的值则是未定义的<br>
最好对动态分配的对象进行初始化，原因与初始化变量相同，防止调用未定义值的对象<br>
如果我们提供了一个括号包围的初始化器就可以auto，从此初始化器来推断我们想要分配的对象的类型，但是只有当括号中仅有单一初始化器时才可以使用auto</p>
<p>用new 分配const 对象时合法的，但是必须对const对象进行初始化，然后new返回的指针是一个指向const 的指针<br>
一旦内存耗尽，new表达式就会失败，默认情况下会抛出一个类型为bad_alloc的异常，<br>
使用定位new 的方式阻止它抛出异常：<code>int *p2 = new (nothrow) int;</code>如果分配失败，返回一个空指针<br>
定位new表达式允许我们向new传递额外的参数，例子中我们传递给它一个由标准库定义的名为nothrow的对象，如果将nothrow传递给new，就是告诉他不能抛出异常</p>
<p>delete也是销毁给定指针指向的对象，释放相应的内存<br>
传递给delete的指针必须指向动态分配的内存，或者是一个空指针，释放一块并非new分配的内存，或者将相同的指针值释放多次，其行为都是未定义的<br>
释放一个空指针总是没有错误的<br>
通常情况下编译器不能分辨一个指针指向静态还是动态分配的对象，同样也不能分辨指针指向的内存是否已被释放，所以错误的delete表达式都会被通过<br>
const对象的值不能被改变，但是它本身是可以被销毁的<br>
对于一个由内置指针管理的动态对象，直到被delete显式释放之前它都是存在的<br>
所以调用者必须记得释放内存<br>
与类类型不同，内置类型的对象被销毁时什么也不会发生，特别是一个指针离开其作用域时其指向的对象什么也不会发生，如果这个指针指向的是动态内存，那么内存将不会被自动释放，所以由内置指针管理的动态内存在被显式释放之前一直都会存在<br>
忘记delete释放动态内存就会导致内存泄漏问题<br>
当我们delete一个指针后指针值就变为无效，虽然指针已经无效，但是该指针仍然保存着（已经释放后）动态内存的地址，在delete后指针变成空悬指针<br>
避免空悬指针需要在指针离开其作用域之前释放掉它所关联的内存 重制指针值为nullptr<br>
但上述方法对于指向同一内存的多个指针无效，只能作用于单一指针</p>
<p>12.1.3 shared_ptr和new结合使用<br>
我们可以用new返回的指针来初始化智能指针<br>
单接受指针参数的智能指针构造函数explicit的，所以我们不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化的形式来初始化一个智能指针<br>
一个返回shared_ptr的函数不能在其返回语句中隐式转换一个普通指针</p>
<p>默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，但我们可以将智能指针绑定到一个指向其他类型的资源（例如类类型）的指针上，但是这样做必须提供自己的操作来代替默认delete<br>
shared_ptr可以协调对象的析构，但这仅限于自身的拷贝（也就是shared_ptr之间）<br>
当临时shared_ptr对象被销毁时，它所指向的内存会被释放<br>
当将一个shared_ptr绑定到一个普通指针时，我们就将内存的管理责任交给了这个shared_ptr，一旦这样做了，我们就不应该再使用内置指针来访问shared_ptr所指向的内存了<br>
使用内置指针来访问智能指针所负责的对象是很危险的，因为我们<strong>无法知道对象何时会被销毁。</strong><br>
智能指针类型定义了一个名为get的函数，它返回一个内置指针，指向智能指针管理的对象，get函数主要是为了向不能使用智能指针的代码传递一个内置指针。<strong>使用get返回的指针的代码不能delete此指针</strong><br>
只有在确定代码不会delete指针的情况下才能使用get，永远不要用get初始化另一个智能指针或者为另一个智能指针赋值（因为不知道对象何时会被销毁）</p>
<p>我们可以用reset来将一个指向相同值的新的指针（一个新的对象的指针）赋予一个shared_ptr（相当于复制其值然后创建一个新的指针）</p>
<p>习题12.10<br>
正确，其实就是将p的指针值进行拷贝，注意会引发指针计数值+1<br>
习题12.11<br>
编译器不会报错，但是get返回的指针是普通指针，此时不会引发计数值+1，导致可能get返回指针指向的对象可能被销毁而process继续调用。<br>
习题11.12<br>
(a)合法，首先复制sp，将sp的引用计数+1，然后程序结束再-1<br>
(b)不合法，智能指针的构造函数是explicit的，不能进行隐式的转换<br>
(c)错误，同上<br>
(d)合法！但是程序结束后会释放内存，p变成空悬指针。<br>
注意<code>process(shared_ptr&lt;int&gt;(p))</code>虽然是复制，但是指向的对象相同，智能指针照样会计数+1然后计数-1销毁内存，而因为两者指向相同的对象，导致原来的普通指针p变成空悬指针。<br>
相同12.13<br>
删除p之后，会导致p指向的内存被释放，此时sp就会变成空悬指针，在sp指针被销毁时，该块内存会被二次delete，执行后产生错误：double free</p>
<p>12.1.4智能指针和异常<br>
当发生异常时，内置指针直接管理的内存是不会自动释放（但是智能指针的会检查引用计数并销毁）<br>
类需要用户显式地释放所使用的任何资源<br>
可以使用shared_ptr来管理其他对象（比如类），但是需要定义一个对应的函数来代替delete<br>
<img src="https://lixin-scut.github.io//post-images/1571232741628.png" alt=""></p>
<p>12.1.5unique_ptr<br>
一个unique_ptr拥有它所指向的对象，与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时，它所指向的对象也会被销毁<br>
unique_ptr与shared_ptr不同，没有类似make_shared的标准库函数，当我们定义一个unique_ptr时，需要将其绑定到一个new返回的指针上，初始化unique_ptr必须采用直接初始化的形式<br>
unique_ptr不支持普通的拷贝或赋值操作<br>
1.unique_ptr不允许拷贝是指不能用一个unique_ptr拷贝到另一个unique_ptr，但是如果使用new出来的普通指针初始化unique_ptr是可以的，<br>
例如</p>
<pre><code>int *pi =new int(42);
unique_ptr&lt;int&gt; p1(pi);
</code></pre>
<p>2.并非是new出来的指针，在栈内存而不是动态内存，所以不应使用智能指针（通过编译，但是编译器会自动delete栈内存，智能指针又delete一次，所以造成二次delete）<br>
虽然我们不能拷贝或赋值unique_ptr,但可以通过调用release或reset将指针的所有权从一个（非const）unique_ptr转移给另一个unique_ptr<br>
release成员返回unique_ptr当前保存的指针并将其置为空<br>
reset成员接受一个可选的指针参数，令unique_ptr重新指向给定的指针。如果unique_ptr不为空，它原来指向的对象就会被释放<br>
调用release会切断unique_ptr和它原来管理的对象间的联系，release返回的指针通常被用来初始化另一个智能指针或给另一个智能指针赋值。如果我们不用另一个智能指针来保存release返回的指针，我们的程序就要负责资源的释放（注意此时对象还没被销毁）<br>
不能拷贝unique_ptr的规则有一个例外，我们可以拷贝或赋值一个将要被销毁的unique_ptr<br>
unique_ptr默认情况下使用delete释放它指向的对象，但同时我们可以重载unique_ptr中默认的删除器<br>
我们必须在尖括号中unique_ptr指向类型之后提供删除器类型</p>
<p>由于decltype(end_connection)返回一个函数类型，所以我们必须添加一个*来指出我们正在使用该类型的一个指针</p>
<p>12.1.6weak_ptr<br>
weak_ptr是一种不控制所指向对象生存期的智能指针，它指向由一个shared_str管理的对象。将一个weak_ptr绑定到一个shared_ptr，<strong>不会改变shared_ptr的引用计数</strong><br>
当shared_ptr引用计数为0时，即使有weak_ptr指向对象，对象也还是会被释放</p>
<p>当我们创建一个weak_ptr时，<strong>要用一个shared_ptr来初始化它</strong><br>
由于对象可能不存在，我们<strong>不能使用weak_ptr直接访问对象，而必须调用lock</strong>，此函数检查weak_ptr指向的对象是否仍存在<br>
通过weak_ptr，<strong>不会影响</strong>一个给定的StrBlob所指向的vector的<strong>生存期</strong>，但是可以阻止用户访问一个不再存在的vector的企图。<strong>（强制使用lock返回shared_ptr）</strong></p>
<p>习题感悟<br>
私有函数private相比于public公有函数的好处在于某些时候可以不用考虑判断条件，比如不用担心会向size_type传入负数<br>
q指针赋给r,如果释放了q，则此时的r指针为空悬指针。<br>
注意<code>process(shared_ptr&lt;int&gt;(p))</code>虽然是复制，但是指向的对象相同，智能指针照样会计数+1然后计数-1销毁内存，而因为两者指向相同的对象，导致原来的普通指针p变成空悬指针。<br>
删除p之后，会导致p指向的内存被释放，此时sp就会变成空悬指针，在sp指针被销毁时，该块内存会被二次delete，执行后产生错误：double free<br>
1.unique_ptr不允许拷贝是指不能用一个unique_ptr拷贝到另一个unique_ptr，但是如果使用new出来的普通指针初始化unique_ptr是可以的，<br>
例如</p>
<pre><code>int *pi =new int(42);
unique_ptr&lt;int&gt; p1(pi);
</code></pre>
<p>2.并非是new出来的指针，在栈内存而不是动态内存，所以不应使用智能指针（通过编译，但是编译器会自动delete栈内存，智能指针又delete一次，所以造成二次delete）<br>
注意对于友元的声明，等于声明加上一个friend，类的声明必须带上class或者struct，但是友元声明不等同于普通声明<br>
涉及了两个class相互引用的问题<br>
一：2个类需要在一个文件中 二：这2个函数必须先声明不定义 三: 函数的定义必须放到StrBlobPtr定义的后面</p>
<p>博客：<a href="https://blog.csdn.net/yishizuofei/article/details/79136733">C++智能指针scoped_ptr的原理和使用</a></p>
<p>《muduo》<br>
<img src="https://lixin-scut.github.io//post-images/1582467419298.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582467471811.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582467490986.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[内存泄漏]]></title>
        <id>https://lixin-scut.github.io//post/nei-cun-xie-lou</id>
        <link href="https://lixin-scut.github.io//post/nei-cun-xie-lou">
        </link>
        <updated>2020-02-22T07:39:45.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>内存泄漏的定义<br>
内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制；</li>
<li>内存泄露的原因和后果</li>
</ol>
<p>总结下来，内存泄露常见的有几个原因：</p>
<p>1、编码错误：malloc、realloc、new申请的内存在堆上，需要手动显示释放，调用free或delete。申请和释放必须成对出现malloc/realloc对应free，new对应delete。前者不会运行构造/析构函数，后者会。对于C++内置数据类型可能没差别，但是对于自己构造的类，可能在析构函数中释放系统资源或释放内存，所以要对应使用。</p>
<p>2、“无主”内存：申请内存后，指针指向内存的起始地址，若丢失或修改这个指针，那么申请的内存将丢失且没有释放。</p>
<p>3、异常分支导致资源未释放：程序正常执行没有问题，但是如果遇到异常，正常执行的顺序或分支会被打断，得不到执行。所以在异常处理的代码中，要确保系统资源的释放。</p>
<p>4、隐式内存泄露：程序运行中不断申请内存，但是直到程序结束才释放。有些服务器会申请大量内存作为缓存，或申请大量资源作为线程池，这些资源一直占用直到程序退出。服务器运行起来一般持续几个月，不及时释放可能会导致内存耗尽。</p>
<p>5、类的析构函数为非虚函数：析构函数必须为虚函数才能利用多态来调用指针指向对象的析构函数，而不是基类的析构函数。</p>
<p>只发生一次小的内存泄漏可能不被注意，但泄漏大量内存的程序将会性能下降到内存逐渐用完，导致程序崩溃；</p>
<ol start="3">
<li>如何排除<br>
使用工具软件BoundsChecker，BoundsChecker是一个运行时错误检测工具，它主要定位程序运行时期发生的各种错误；<br>
调试运行DEBUG版程序，运用以下技术：CRT(C run-time libraries)、运行时函数调用堆栈、内存泄漏时提示的内存分配序号(集成开发环境OUTPUT窗口)，综合分析内存泄漏的原因，排除内存泄漏。</li>
</ol>
<p>检测内存泄漏的办法：<br>
一、<br>
在Linux平台上 有valgrind可以非常方便的帮助我们定位内存泄漏，因为Linux在开发领域的使用场景大多是跑服务器，再加上它的开源属性，相对而言，处理问题容 易形成“统一”的标准。而在Windows平台，服务器和客户端开发人员惯用的调试方法有很大不同。下面结合我的实际经验，整理下常见定位内存泄漏的方 法。<br>
注意：我们的分析前提是Release版本，因为在Debug环境下，通过VLD这个库或者CRT库本身的内存泄漏检测函数能够分析出内存泄漏，相对而言比较简单。而服务器有很多问题需要在线上并发压力情况下才出现，因此讨论Debug版调试方法意义不大。</p>
<p>二、对象计数<br>
方法：在对象构造时计数++，析构时–，每隔一段时间打印对象的数量<br>
优点：没有性能开销，几乎不占用额外内存。定位结果精确。<br>
缺点：侵入式方法，需修改现有代码，而且对于第三方库、STL容器、脚本泄漏等因无法修改代码而无法定位。</p>
<p>三、重载new和delete<br>
方法：重载new/delete，记录分配点（甚至是调用堆栈），定期打印。<br>
优点：没有看出<br>
缺点：侵入式方法，需将头文件加入到大量源文件的头部，以确保重载的宏能够覆盖所有的new/delete。记录分配点需要加锁（如果你的程序是多线程），而且记录分配要占用大量内存（也是占用的程序内存）。</p>
<p>四、Hook Windows系统API<br>
方法：使用微软的detours库，hook分配内存的系统Api：HeapAlloc/HeapRealloc/HeapFree（new/malloc的底层调用）,记录分配点，定期打印。<br>
优点：非侵入式方法，无需修改现有文件（hook api后，分配和释放走到自己的钩子函数中），检查全面，对第三方库、脚本库等等都能统计到。<br>
缺点：记录内存需要占用大量内存，而且多线程环境需要加锁。</p>
<p>五、使用DiagLeak检测<br>
微软出品的内存泄漏分析工具，原理同hookapi方式。配合LDGraph可视化展示内存分配数据，更方便查找泄漏。<br>
1.在IDE工程选项里面配置Release版本也生成调试信息，发布时，将pdb文件和exe文件一起发布。<br>
2.程序运行后，打开LeakDiag，设置Symbol path<br>
3.定期Log下目标进程的内存分配情况，通过LDGraph打印分配增长情况，来发现内存泄漏。<br>
优点：同hookapi方法，非侵入式修改，无需做任何代码改动。跟踪全面。可视化分析堆栈一览无余！<br>
缺点：对性能有影响，hook分配加锁，遍历堆栈。但是不会占用目标进程的自身内存。</p>
<ol start="4">
<li>
<p>解决方法<br>
少用堆内存多用栈内存，RAII与智能指针（正好对应两种检测方法）<br>
a)	RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”，也就是说在构造函数中申请分配资源，在析构函数中释放资源。因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。<br>
b)	智能指针（std::shared_ptr和std::unique_ptr）即RAII最具代表的实现，使用智能指针，可以实现自动的内存管理，再也不需要担心忘记delete造成的内存泄漏。毫不夸张的来讲，有了智能指针，代码中几乎不需要再出现delete了。</p>
</li>
<li>
<p>检查、定位内存泄漏<br>
在Debug环境下，通过VLD这个库或者CRT库本身的内存泄漏检测函数能够分析出内存泄漏，相对而言比较简单。<br>
内存泄露的关键就是记录分配的内存和释放内存的操作，看看能不能匹配。跟踪每一块内存的声明周期，例如：每当申请一块内存后，把指向它的指针加入到List中，当释放时，再把对应的指针从List中删除，到程序最后检查List就可以知道有没有内存泄露了。Window平台下的Visual Studio调试器和C运行时（CRT）就是用这个原理来检测内存泄露。</p>
</li>
</ol>
<p>在VS中使用时，需加上</p>
<pre><code>#define _CRTDBG_MAP_ALLOC
#include &lt;crtdbg.h&gt;
</code></pre>
<p>crtdbg.h的作用是将malloc和free函数映射到它们的调试版本_malloc_dbg和_free_dbg，这两个函数将跟踪内存分配和释放（在Debug版本中有效）<br>
<code>_CrtDumpMemoryLeaks();</code><br>
函数将显示当前内存泄露，也就是说程序运行到此行代码时的内存泄露，所有未销毁的对象都会报出内存泄露，因此要让这个函数尽量放到最后。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 题25:合并两个排序的链表]]></title>
        <id>https://lixin-scut.github.io//post/lian-biao-ti-25he-bing-liang-ge-pai-xu-de-lian-biao</id>
        <link href="https://lixin-scut.github.io//post/lian-biao-ti-25he-bing-liang-ge-pai-xu-de-lian-biao">
        </link>
        <updated>2020-02-21T16:07:34.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
</blockquote>
<pre><code>class Solution {
public:
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2)
    {
        ListNode *virHead=new ListNode(-1);
        ListNode *cur=virHead;
        while(pHead1&amp;&amp;pHead2){
            if(pHead1-&gt;val&lt;=pHead2-&gt;val)
                cur-&gt;next=pHead1,pHead1=pHead1-&gt;next;
            else
                cur-&gt;next=pHead2,pHead2=pHead2-&gt;next;
            cur=cur-&gt;next;
        }
        cur-&gt;next=pHead1?pHead1:pHead2;//这里很重要，配合判断条件能够避免输入NULL指针的情况
        return virHead-&gt;next;
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>最容易犯两种错误：一是在写代码之前没有想清楚合并的过程，最终合并出来的链表要么中间断开了、要么并没有做到递增排序；二是代码在鲁棒性方面存在问题，程序一旦有特殊的输入（如空链表）就会崩溃。<br>
首先分析合并两个链表的过程。我们的分析从合并两个链表的头节点 开始。链表1的头节点的值小于链表2的头节点的值，因此链表1的头节点将是合并后链表的头节点<br>
我们继续合并两个链表中剩余的节点。在 两个链表中剩下的节点依然是排序的，因此合并这两个链表的步骤和前面 的步骤是一样的。我们还是比较两个头节点的值。此时链表2的头节点的 值小于链表1的头节点的值，因此链表2的头节点的值将是合并剩余节点 得到的链表的头节点。我们把这个节点和前面合并链表时得到的链表的尾节点<br>
当我们得到两个链表中值较小的头节点并把它链接到已经合并的链表 之后，两个链表剩余的节点依然是排序的，因此合并的步骤和之前的步骤是一样的。这就是典型的递归过程，我们可以定义递归函数完成这一合并过程<br>
每当代码试图访问空指针指向的内 存时程序就会崩溃，从而导致鲁棒性问题。在本题中一旦输入空的链表就 会引入空的指针，因此我们要对空链表单独处理。当第一个链表是空链表, 也就是它的头节点是一个空指针时，那么把它和第二个链表合并，显然合 并的结果就是第二个链表。同样，当输入的第二个链表的头节点是空指针 的时候，我们把它和第一个链表合并得到的结果就是第一个链表。如果两个链表都是空链表，则合并的结果是得到一个空链表。</p>
</blockquote>
<pre><code>ListNode* Merge(ListNode* pHead1, ListNode* pHead2)
{
    if(pHead1 == nullptr)
        return pHead2;
    else if(pHead2 == nullptr)
        return pHead1;

    ListNode* pMergedHead = nullptr;

    if(pHead1-&gt;m_nValue &lt; pHead2-&gt;m_nValue)
    {
        pMergedHead = pHead1;
        pMergedHead-&gt;m_pNext = Merge(pHead1-&gt;m_pNext, pHead2);
    }
    else
    {
        pMergedHead = pHead2;
        pMergedHead-&gt;m_pNext = Merge(pHead1, pHead2-&gt;m_pNext);
    }

    return pMergedHead;
}
</code></pre>
<p>我感觉我的程序更加精简，同时兼顾了鲁棒性，然后书本的题解使用了递归思想，非常巧妙，但是需要额外的判断条件。</p>
]]></content>
    </entry>
</feed>