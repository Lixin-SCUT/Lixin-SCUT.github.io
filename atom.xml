<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2020-02-14T02:53:49.206Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[Math 题16:数值的整数次方]]></title>
        <id>https://lixin-scut.github.io//post/math-ti-16shu-zhi-de-zheng-shu-ci-fang</id>
        <link href="https://lixin-scut.github.io//post/math-ti-16shu-zhi-de-zheng-shu-ci-fang">
        </link>
        <updated>2020-02-14T02:31:51.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。<br>
保证base和exponent不同时为0</p>
</blockquote>
<pre><code>class Solution {
public:
    double Power(double base, int exponent) {
        if(exponent==0)
            return 1;
        double res;
        bool flag=false;
        if(exponent&lt;0){
            flag=true;
            exponent=-exponent;
        }
        res=base;
        if(exponent%2)
            res=Power(base*base,exponent/2)*base;
        else
            res=Power(base*base,exponent/2);
        if(flag)
            res=1.0/res;
        return res;
    }
};
</code></pre>
<p>值得改进的点：除以2改为右移，求余运算符改为位与运算符，提高效率</p>
<blockquote>
<p>书本题解：<br>
首先需要考虑输入的指数(exponent)小于1 (零和负数)的情况<br>
当指数为负数的时候，可以先对指数求绝对值，算出次方的结果之后再取倒数。<br>
当底数(base)是零且指数是负数的时候，如果不进行特殊处理，就会出现对0求倒数，从而导致程序运行出错。<br>
最后需要指出的是，由于0的0次方在数学上是没有意义的，因此无论输出是0还是1都是可以接受的，但这都需要和面试官说清楚，表明我 们己经考虑到这个边界值了。<br>
采用全局变量来标识是否出错<br>
同时可以用如下公式求a的n次方<br>
<img src="https://lixin-scut.github.io//post-images/1581648186725.png" alt=""></p>
</blockquote>
<pre><code>double PowerWithUnsignedExponent(double base, unsigned int exponent)
{
    if (exponent == 0)
        return 1;
    if (exponent == 1)
        return base;

    double result = PowerWithUnsignedExponent(base, exponent &gt;&gt; 1);
    result *= result;
    if ((exponent &amp; 0x1) == 1)
        result *= base;

    return result;
}

bool equal(double num1, double num2)
{
    if ((num1 - num2 &gt; -0.0000001) &amp;&amp; (num1 - num2 &lt; 0.0000001))
        return true;
    else
        return false;
}
</code></pre>
<blockquote>
<p>最后一个细节：位运算的效率比乘除法以及求余运算的效率高很多，可以使用右移运算符代替除以2，用位与代替了求余运算符（%）来判断一个数是奇数还是偶数。<br>
M%N:当N是2的次方时，M%N=M&amp;(N-1)<br>
另外需要注意如果是double，无法直接比较是否相等，需要使用它们的差值进行判断</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[位运算 题15:二进制中1的个数[未做出]]]></title>
        <id>https://lixin-scut.github.io//post/wei-yun-suan-ti-15er-jin-zhi-zhong-1-de-ge-shu-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/wei-yun-suan-ti-15er-jin-zhi-zhong-1-de-ge-shu-wei-zuo-chu">
        </link>
        <updated>2020-02-13T03:13:14.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
</blockquote>
<p>重点就在于不要把n直接右移，因为负数的右移会自动补1，同时把1往左移其实也是固定循环次数的，用4字节的int只会循环32次。<br>
然后就是书本题解中的减1相与法很值得学习。</p>
<pre><code>class Solution {
public:
     int  NumberOf1(int n) {
         //【未做出】
         int count=0;
         
         while(n){
             ++count;
             n=(n-1)&amp;n;
         }
         return count;
         /*
         //注意位运算符返回右值，必须再赋值。。。和算术符号一样的
         //然后判断条件比较有趣，如果将数字视为二进制的话那么位数一定是固定的（int的位数）
         //而不是说数字越大位数越大，所以不需要将判断条件改为i和n的大小判断，直接等i左移到变为0即可
         int count=0;
         int i=1;
         while(i){
             if(n&amp;i)
                 ++count;
             i=i&lt;&lt;1;
         }
         return count;
         */
     }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>只要把整数和1做位与运算看结果是不是0就知道了<br>
如果直接将目标数字n进行右移，当输入一个负数，比如0x80000000,则运行的时候当把负数 0x80000000右移一位的时候，并不是简单地把最高位的1移到第二位变成 0x40000000,而是0xC0000000。这是因为移位前是一个负数，仍然要保证 移位后是一个负数，因此移位后的最高位会设为1。如果一直做右移运算， 那么最终这个数字就会变成0xFFFFFFFF而陷入死循环。<br>
为了避免死循环，我们可以不右移输入的数字n。首先把n和1做与运算，判断n的最低位是不是为1。接着把1左移一位得到2,再和n做与运算，就能判断n的次低位是不是1……这样反复左移，每次都能判断n的其中一位是不是1。</p>
</blockquote>
<pre><code>int NumberOf1_Solution1(int n)
{
    int count = 0;
    unsigned int flag = 1;
    while (flag)
    {
        if (n &amp; flag)
            count++;

        flag = flag &lt;&lt; 1;
    }

    return count;
}
</code></pre>
<blockquote>
<p>同时我们发现把一个整数减去1，都是把最右边的1变成0。如果它的右边还有0,则所有的0都变成1，而它左边的所有位都保 持不变。接下来我们把一个整数和它减去1的结果做位与运算，相当于把它最右边的1变成0。<br>
把上面的分析总结起来就是：把一个整数减去1,再和原整数做与运 算，会把该整数最右边的1变成0。那么一个整数的二进制表示中有多少个1， 就可以进行多少次这样的操作。</p>
</blockquote>
<pre><code>int NumberOf1_Solution2(int n)
{
    int count = 0;

    while (n)
    {
        ++count;
        n = (n - 1) &amp; n;
    }

    return count;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[哈希表hash table]]></title>
        <id>https://lixin-scut.github.io//post/ha-xi-biao</id>
        <link href="https://lixin-scut.github.io//post/ha-xi-biao">
        </link>
        <updated>2020-02-12T11:39:23.000Z</updated>
        <content type="html"><![CDATA[<p>《C++ primer》<br>
新标准定义了4个无序关联容器，无序容器不是使用比较运算符来组织元素，而是使用一个哈希函数，和关键字类型的<mark>运算符<br>
如果关键字类型固有就是无序的，或者性能测试发现问题可以用哈希技术解决，就可以使用无序容器<br>
无序容器提供了与有序容器相同的操作（find、insert等），所以unordered_map和unordered_set也可以使用这些操作<br>
无序容器也有允许重复关键字的版本<br>
通常可以用一个无序容器替换对相应的有序容器，反之亦然<br>
无序容器在存储组织上为一组桶，每个桶保存零个或多个元素，无序容器使用一个哈希函数将元素映射到桶，容器首先计算元素的哈希值，并将具有一个特定哈希值的所有元素都保存在相同的桶中，所有具有相同关键字的元素都会在同一个桶中，因此无序容器的性能依赖于哈希函数的质量和桶的数量和大小<br>
对于相同的参数，哈希函数总是产生相同的结果<br>
将不同关键字映射到相同的桶也是允许的，当一个桶保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个<br>
<img src="https://lixin-scut.github.io//post-images/1581507740082.png" alt=""><br>
默认情况下无序容器使用关键字类型的</mark>运算符来比较元素，还是用一个hash&lt;key_type&gt;类型来生成每个元素的哈希值，标准库为内置类型包括指针提供了hash模板</p>
<p>《STL源码剖析》<br>
C++的STL中set和map使用了红黑树作为基层机制<br>
而unordered_set unordered_map使用了hashtable作为底层机制，初始化时可以向hashtable定义equal函数<br>
hashtable可以视为一种键值的字典结构，使用hash function散列函数来进行映射<br>
负载系数（loading factor）：元素的个数除以表格大小<br>
当单个位置空间满载，只能进行循环向下查找和惰性删除<br>
hashtable的buckets聚合体以vector完成，以利动态扩充，同时hashtable使用28个质数来设计表格大小<br>
然后bucket中不是使用STL的list，而是自己维护一个hashtable node，类似于forward_list，有value和next指针<br>
hashtable自定义了迭代器，只有++和==等操作，没有后退的操作，也没有逆向迭代器<br>
在++递增操作中，如果当前节点恰巧是链表最后一个节点，就通过buk_num寻找下一个bucket<br>
hashtable的bkt_num()定义了hash function来计算元素位置<br>
每个bucket的最大容量和buckets_vector的大小相同<br>
新节点在链表的头部插入<br>
注意hashtable并没有自动排序功能，所以hash表内的元素并无特定顺序<br>
有些元素无法直接拿来对hashtable的大小进行模运算，就需要bkt_num函数进行预处理，<br>
hash set 和 hash multiset的区别在于前者使用insert_unique，后者使用insert_equal。</p>
<p>解决哈希冲突<br>
1.线性探测<br>
2.二次探测<br>
3.开链</p>
<p>一致性哈希了解吗<br>
一致性哈希算法将整个哈希值空间映射成一个虚拟的圆环，整个哈希空间的取值范围为0<sub>2^32-1。整个空间按顺时针方向组织。0</sub>2^32-1在零点中方向重合。接下来使用如下算法对服务请求进行映射，将服务请求使用哈希算法算出对应的hash值，然后根据hash值的位置沿圆环顺时针查找，第一台遇到的服务器就是所对应的处理请求服务器。当增加一台新的服务器，受影响的数据仅仅是新添加的服务器到其环空间中前一台的服务器（也就是顺着逆时针方向遇到的第一台服务器）之间的数据，其他都不会受到影响。综上所述，一致性哈希算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性</p>
<p>3.哈希表实现<br>
知道哈希表吗，怎么解决冲突，如果只有 32 个槽，怎么存放几千个数据。<br>
开链</p>
<p>哈希表?怎么进行查找数据?<br>
首先转化键值，然后计算哈希值，再在相应的bucket中顺序查找（哈希冲突 开拉链法 也可以把链表换成红黑树）<br>
注意char* const char* 都是通过h=5 * h+* s转化为size_t 其他数值类型也是转化为size_t</p>
<p>哈希数据结构?如何 rehash?<br>
STL的rehash比较简单，就是判断每个bucket的元素数量和vector的大小对比，如果前者大于后者的话就需要resize（rehash），rehash也比较简单，直接重新计算每个元素的落点然后头部插入<br>
比较有趣的是redis的渐进式hash</p>
<p>hash 冲突，写拉链法代码</p>
<pre><code>pair&lt;hashtable::iterator,bool&gt; insert_unique_noresize(const value_type&amp; obj){
const size_type n=bkt_num(obj)
for(node* cur=first;cur;cur=cur-&gt;next)
	if(equal(get_key(cur-&gt;val),get_key(obj)))
		return pair&lt;iterator,bool&gt;(iterator(cur,this),false);
node* tmp=new_node(obj);
tmp-&gt;next=first;
buckets[n]=tmp;
++num_elements;
return pair&lt;iterator,bool&gt;(iterator(tmp,this),true);
}
</code></pre>
<p>如果是unordered_multiset，则先寻找有没有相同值，有的话立即插入，如果没有的话就回到头部插入</p>
<p>如何解决 Hash 表碰撞问题<br>
Hash碰撞冲突<br>
我们知道，对象Hash的前提是实现equals()和hashCode()两个方法，那么HashCode()的作用就是保证对象返回唯一hash值，但当两个对象计算值一样时，这就发生了碰撞冲突。</p>
<p>1.开放地址法<br>
开放地执法有一个公式:Hi=(H(key)+di) MOD m i=1,2,…,k(k&lt;=m-1)<br>
其中，m为哈希表的表长。di 是产生冲突的时候的增量序列。如果di值可能为1,2,3,…m-1，称线性探测再散列。<br>
如果di取1，则每次冲突之后，向后移动1个位置.如果di取值可能为1,-1,2,-2,4,-4,9,-9,16,-16,…k<em>k,-k</em>k(k&lt;=m/2)，称二次探测再散列。<br>
如果di取值可能为伪随机数列。称伪随机探测再散列。</p>
<p>2.再哈希法<br>
当发生冲突时，使用第二个、第三个、哈希函数计算地址，直到无冲突时。缺点：计算时间增加。<br>
比如上面第一次按照姓首字母进行哈希，如果产生冲突可以按照姓字母首字母第二位进行哈希，再冲突，第三位，直到不冲突为止</p>
<p>3.链地址法（拉链法）<br>
将所有关键字为同义词的记录存储在同一线性链表中。</p>
<p>4.建立一个公共溢出区<br>
假设哈希函数的值域为[0,m-1],则设向量HashTable[0..m-1]为基本表，另外设立存储空间向量OverTable[0..v]用以存储发生冲突的记录。</p>
<p>如何改善 Hash 表性能<br>
哈希表性能优化的方法有很多，比如：<br>
使用双 hash 检索冲突<br>
使用开放+封闭混合寻址法组织哈希表<br>
使用跳表快速定位冲突<br>
使用 LRU 缓存最近访问过的键值，不管表内数据多大，短时内访问的总是那么几个<br>
使用更好的分配器来管理 key_value_pair 这个节点对象<br>
封闭寻址+平衡二叉树</p>
<p>load factor较小时，添加元素时很容易找到空的bucket，hash冲突少（因为可用的空bucket很多），存储性能较高；已装元素的bucket少，很容易从中找到指定的元素，查找性能较高；但遍历集合（hash表）时，要过滤掉大量的空bucket，很花时间，所以遍历时比较慢。<br>
当load factor达到设置的负载极限时，会发生rehashing（重哈希/再散列），hash表会自动成倍地增加容量（capacity），将原有的元素都移到新的hash表中（会重新分配存储位置），而此时原有的元素是极多的，这会增加很大的开销。<br>
负载极限设置较高时，节省内存（空桶较少），但添加、查找元素效率较低，时间开销会增大；负载极限较低时，添加、查找元素效率较高，但会增加内存开销。默认为0.75，是时间、空间的折中，我们可根据需要自行设置。<br>
如果我们一开始就知道要存储的元素个数，可以在创建hash表时就指定容量：元素总数/负载极限。这样避免了rehashing，节省了时间开销。且前中期hash表负载会很低，添加、查询效率极高。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++中的关键字 static ]]></title>
        <id>https://lixin-scut.github.io//post/czhong-de-guan-jian-zi-static</id>
        <link href="https://lixin-scut.github.io//post/czhong-de-guan-jian-zi-static">
        </link>
        <updated>2020-02-12T10:55:19.000Z</updated>
        <content type="html"><![CDATA[<p>《C++ primer》<br>
局部静态对象 static 直到程序终止时才被销毁，在此期间就算函数执行结束也不会对它产生影响（可以用来计算函数调用次数）<br>
值初始化除了在值初始化过程中可能进行之外，也可以单独作用于静态（或者线程局部）变量： static T object;</p>
<p>类的静态成员<br>
static 静态成员 与类关联，而与特定的对象无关（等于每个对象都可以通用的成员）所以静态成员应该在类外定义，否则每创建一个对象就会被定义一次<br>
静态成员可以是private或者public，静态数据成员的类型可以是常量、引用、指针、类类型等等。<br>
类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据，同时静态成员函数也不与任何对象绑定在一起，不包含this 指针，不能被声明为const<br>
使用作用域运算符来直接访问静态成员，也可以使用类的对象、引用或者指针来访问<br>
成员函数不用通过作用域运算符就能直接使用静态成员<br>
静态成员函数也可以在类外部进行定义，但不能重复static关键字，static只出现在类内部的声明语句<br>
静态成员不是由类的构造函数初始化的，不能在类的内部初始化静态成员，必须在类的外部定义和初始化每个静态成员<br>
一个静态数据成员只能定义一次<br>
静态数据成员定义在任何函数之外，因此存在于程序的整个生命周期中<br>
把静态数据成员的定义和其他非内联函数的定义放在同一个文件中，确保对象只定义一次<br>
例外：可以在类内部初始化constexpr的静态成员，但必须提供const整数类型的类内初始值（常量表达式） 例如 static constexpr int i =10;//必须是constexpr，不能是const<br>
如果仅仅用于类内，则在类内已经初始化的const或者constexpr static不需要分别定义，否则必须有一条定义语句<br>
特别地，静态数据成员的类型可以是它所属的类类型（等于不完全类型），而非静态数据成员只能声明成它所属的类的指针或引用<br>
静态成员可以作为默认实参，非静态数据成员则不能。</p>
<p>静态内存用于保存局部static对象、类static数据成员以及定义在任何函数之外的变量</p>
<p>模板所有实例类型都共享相同的static成员（包括数据成员和函数乘以）<br>
类似任何其他成员函数，一个 static 成员函数只有在使用时才会实例化。</p>
<p>static_cast 只要不包含底层const都能用 例如把void*指针的值找回来</p>
<p>博客：<br>
全局静态变量<br>
　　在全局变量前加上关键字static，全局变量就定义成一个全局静态变量.<br>
　　静态存储区，在整个程序运行期间一直存在。<br>
　　初始化：未经初始化的全局静态变量会被自动初始化为0(自动对象的值是任意的，除非他被显式初始化);<br>
　　作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。</p>
<p>局部静态变量<br>
　　在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。<br>
　　内存中的位置：静态存储区<br>
　　初始化：未经初始化的全局静态变量会被自动初始化为0(自动对象的值是任意的，除非他被显式初始化);<br>
　　作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变;</p>
<p>静态函数<br>
　　在函数返回类型前加static，函数就定义为静态函数。普通函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。<br>
　　函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突;<br>
　　warning：不要在头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰;</p>
<p>类的静态成员<br>
　　在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用</p>
<p>类的静态函数<br>
　　静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名，只需要类名。<br>
　　在静态成员函数的实现中不能直接引用类中说明的非静态成员（因为类可能都还没有对象，自然也无法对非静态成员进行构造），可以引用类中说明的静态成员(这点非常重要)。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;);<br>
如果函数调用的结果不会访问或者修改任何对象（非static）数据成员，这样的成员声明为静态成员函数比较好</p>
<p>static 变量初始化<br>
未经初始化的全局静态变量和局部静态变量都会被自动初始化为0</p>
<p>static与const和extern的关系<br>
这两个关键字可以一起使用,当一起使用时,它们的先后顺序是没有限制的,谁在前面都一样,const是指常量,static则表示静态变量,它们一起使用时则表示一个静态常量.<br>
当你声明一个变量并初始化后,你不想在后面的程序中对该变量进行修改的话,你就可以用const修饰符来修饰它,它告诉编译器这是一个常量,如果你对常量作了修改,编译的时候就会通不过,而静态变量则是在你声明之后,这个变量就一直常驻内存,直到程序结束它才会被销毁,例如你在一个自定义函数中定义了一个静态变量,当这个函数被调用结束,它里的静态变量依然存在,当第二次调用该函数时,这个变量并不会重新被分配内存,它的值则是上一次调用后它的值.</p>
<p>在全局范围和局部范围声明时在内存的分布情况<br>
int i=1024<br>
static int i=1024<br>
都是定义在静态存储区</p>
<p>static 和全局变量<br>
全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。</p>
<p>Static 关键字，可以在头文件中声明吗<br>
可以，但是不应该，#include的话，展开之后相当于static在main中仍然是可见的。你把static放在.h文件中是无意义的，且很容易被重复引用而形成重复定义。正确的做法是在.c中定义全局变量，而在.h中用extern引出全局变量，当然static变量是无法extern的。</p>
<p>如何在另一个文件里面使用本文件中的 static 变量或函数?<br>
利用可在本文件调用的属性，另加一个函数fun，fun调用该static函数；其他文件调用fun即可</p>
<p>Static 和 extern 的优先级谁高<br>
static更高，不可以对static的变量或者函数使用extern关键词，先出现 extern 后出现 static 是不行的，先出现 static 后出现 extern 则为 static</p>
<p>2.const static 用法<br>
static<br>
    作用：修饰变量、函数<br>
    变量<br>
     全局变量：修饰的全局变量，指定其内部链接，也就是只能本文件使用。<br>
     局部变量：修饰的局部变量，改变其生命周期，并不会修改其作用域。<br>
     成员变量：只属于类，不属于对象。使用的适合可以通过类名或者对象引用。修饰的成员变量必须在类外单独初始化，如果同时被const 修饰则可以在定义的适合进行初始化。<br>
    函数<br>
      普通函数：修饰的普通函数，指定其内部链接，也就是只能本文可见。<br>
     类成员函数：静态成员函数只属于类，不属于对象。没有this指针，所以它不能访问非静态成员函数 ，和非静态成员变量。 它是用来处理静态成员数据，如果我们非要使用静态成员函数访问非静态成员函数或者非静态成员变量，我们可以间接使用类进行引用。</p>
<p>const<br>
     用法：修饰变量，参数，返回值。 C++中的const关键字的用法非常灵活，而使用const将大大改善程序的健壮性。const 允许指定语义约束，告诉编译器哪些变量是不可以改变的。<br>
     修饰变量：C语言中const将一个变量转化为常变量，存储在静态文本段，只有读取权限，C++中同样会将一个变量转化成常量，C++会对其进行优化，将其放入寄存器中，如果想去内存中读取该数据时，我们可以使用volatile关键字进行修饰，保证其可见性。<br>
     修饰指针变量： 如果const位于* 左侧时，不能修改指针所指的对象<br>
                               如果const位于* 右侧时，不能修改指针的指向，所以必须初始化。<br>
     修饰参数：作用是原参数在该函数中不可被改变。<br>
     修饰的返回值：也是用const来修饰返回的指针或引用，保护指针指向的内容或引用的内容不被修改，也常用于运算符重载。归根究底就是使得函数调用表达式不能作为左值。<br>
     修饰成员变量：该变量只能在初始化列表里初始化。<br>
     修饰成员函数：在成员函数后面加上const,const修饰this指针所指的的对象，也就是保证调用该成员函数的对象，在成员函数内部不会改变。（改变权限，权限可缩小，但是不可扩大）</p>
<p>3.在头文件里面声明一个 static 变量，在两个不同的 cpp 里面#include 这个变量有没有问题<br>
在一个头文件中声明static 类对象， 会为所有include该头文件的cpp都创建一个同名的全局对象，只不过它们是相互独立的。<br>
但是普通全局变量的话就只能有一个定义，否则会引发重复定义</p>
<p>自己做的小实验：</p>
<pre><code>//static_data.h
static int si;
extern int i;


//func.cpp
#include &quot;static_data.h&quot;
void func(){

    ++si;
    cout&lt;&lt;si&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;endl;
}

//main.cpp
#include &quot;static_data.h&quot;

void func();

int i=0;// i must be modified here and modified once;
int main() {
    //int i=10;//this will cover i 
    //++si;
    ++i;
    cout&lt;&lt;si&lt;&lt;&quot; &quot;&lt;&lt;i++&lt;&lt;endl;
    func();
}
</code></pre>
<p>输出结果：</p>
<pre><code>0 1
1 2
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[排序算法]]></title>
        <id>https://lixin-scut.github.io//post/pai-xu-suan-fa</id>
        <link href="https://lixin-scut.github.io//post/pai-xu-suan-fa">
        </link>
        <updated>2020-02-12T05:13:04.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://lixin-scut.github.io//post-images/1581492677786.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 题14:剪绳子[未做出][贪心]]]></title>
        <id>https://lixin-scut.github.io//post/dong-tai-gui-hua-ti-14jian-sheng-zi-wei-zuo-chu-tan-xin</id>
        <link href="https://lixin-scut.github.io//post/dong-tai-gui-hua-ti-14jian-sheng-zi-wei-zuo-chu-tan-xin">
        </link>
        <updated>2020-02-12T04:05:22.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],...,k[m]。请问k[0]xk[1]x...xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
</blockquote>
<p>我一开始用的是贪心法，就是单纯地不断取3<br>
但是这是有问题的，因为如果最后剩余的是4的话，应该取2x2而不是3x1<br>
然后动态规划就是要注意特殊例子，因为动态规划把两边都是为一个整体，但是题目要求必须剪一刀，比如3取1和2的时候，2在动态规划数组中是1，就会导致结果等于1</p>
<pre><code>class Solution {
public:
    int cutRope(int number) {
        //动态规划；
        if(number&lt;2)
            return 0;
        //注意着两个特殊例子无法去除，因为动态规划中这两个特殊例子应视为一个整体
        if(number==2)
            return 1;
        if(number==3)
            return 2;
        vector&lt;int&gt; count(number+1,0);
        count[1]=1;
        count[2]=2;
        count[3]=3;
        for(int i=4;i&lt;number+1;++i)
            for(int j=1;j&lt;=i/2;++j)
                count[i]=max(count[i],count[j]*count[i-j]);
        return count.back();
        /*
        //贪心算法
        if(number&lt;1)
            return 0;
        if(number==2)
            return 1;
        if(number==3)
            return 2;
        
        //注意可以直接*4，但是可读性有点差
        if(number%3==1)
            return pow(3,(number/3)-1)*2*2;
        else 
            return pow(3,(number/3))*(number%3);
            
        //这里其实是错误的，如果剪完3之后剩下的是4，不应该再剪3了，应该剪2+2，不知道为何通过了
        //return pow(3,(number/3))*(number%3);
        */
    }
};
</code></pre>
<p>书本题解:</p>
<blockquote>
<p>动态规划<br>
首先定义函数f(n)为把长度为n的绳子剪成若干段后各段长度乘积的最 大值。在剪第一刀的时候，我们有n-1种可能的选择，也就是剪出来的第 一段绳子的可能长度分别为1,2,...,n-1因此f(n)=max(f(i)xf(n-i)),其中 0&lt;i&lt;n。<br>
这是一个从上至下的递归公式。由于递归会有很多重复的子问题，从 而有大量不必要的重复计算。一个更好的办法是按照从卜而上的顺序计算, 也就是说我们先得到f(2)、f(3),再得到f(4)、f(5),直到得到f(n)。<br>
当绳子的长度为2时，只可能剪成长度都为1的两段，因此f(2)等于1 当绳子的长度为3时，可能把绳子剪成长度分别为1和2的两段或者长度都为1的三段，由于1x2&gt;1x1x1,因此f(3)=2<br>
在上述代码中，产问题的最优解存储在数组products里。<br>
为了求解f(i)，我们需要求 出所有可能的并比较得出它们的最大值。这就是代码中第二个for循环的功能。</p>
</blockquote>
<pre><code>int maxProductAfterCutting_solution1(int length)
{
    if(length &lt; 2)
        return 0;
    if(length == 2)
        return 1;
    if(length == 3)
        return 2;

    int* products = new int[length + 1];
    products[0] = 0;
    products[1] = 1;
    products[2] = 2;
    products[3] = 3;

    int max = 0;
    for(int i = 4; i &lt;= length; ++i)
    {
        max = 0;
        for(int j = 1; j &lt;= i / 2; ++j)
        {
            int product = products[j] * products[i - j];
            if(max &lt; product)
                max = product;

            products[i] = max;
        }
    }

    max = products[length];
    delete[] products;

    return max;
}
</code></pre>
<blockquote>
<p>贪婪算法<br>
如果我们按照如下的策略来剪绳子，则得到的各段绳子的长度的乘积将最大：当n&gt;=5时，我们尽可能多地剪长度为3的绳子；当剩下的绳子长度为4时，把绳子剪成两段长度为2的绳子。<br>
这种思路的正确性证明：首先，当n&gt;=5的时候，我们可以 证明2(n-2)&gt;n并且3(n-3)&gt;n。也就是说，当绳子剩下的长度大于或者等于 5的时候，我们就把它剪成长度为3或者2的绳子段。另外，当n&gt;=5时， 3(n-3)&gt;=2(n-2),因此我们应该尽可能地多剪长度为3的绳子段。<br>
前面证明的前提是n&gt;=5。那么当绳子的长度为4呢？在长度为4的绳子上剪一刀，有两种可能的结果：剪成长度分别为1和3的两根绳子，或 者两根长度都为2的绳子。注意到2X2&gt;1X3,同时2X2=4,也就是说，当绳子长度为4时其实没有必要剪，只是题目的要求是至少要剪一刀。</p>
</blockquote>
<pre><code>int maxProductAfterCutting_solution2(int length)
{
    if(length &lt; 2)
        return 0;
    if(length == 2)
        return 1;
    if(length == 3)
        return 2;

    // 尽可能多地减去长度为3的绳子段
    int timesOf3 = length / 3;

    // 当绳子最后剩下的长度为4的时候，不能再剪去长度为3的绳子段。
    // 此时更好的方法是把绳子剪成长度为2的两段，因为2*2 &gt; 3*1。
    if(length - timesOf3 * 3 == 1)
        timesOf3 -= 1;

    int timesOf2 = (length - timesOf3 * 3) / 2;

    return (int) (pow(3, timesOf3)) * (int) (pow(2, timesOf2));
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[网络库：事件EventLoop]]></title>
        <id>https://lixin-scut.github.io//post/wang-luo-ku-eventloop</id>
        <link href="https://lixin-scut.github.io//post/wang-luo-ku-eventloop">
        </link>
        <updated>2020-02-11T13:39:35.000Z</updated>
        <content type="html"><![CDATA[<p>网络库，其核心是事件循环和事件分发器Eventloop<br>
每个线程只能有一个EventLoop实体，负责IO和定时器事件的分派，用eventfd来异步唤醒。用TimerQueue来作为计时器管理，用Poller作为IO multiplexing</p>
<p>与EventLoop相关的类<br>
1.EventLoopThread：新建一个专门用于EventLoop的线程，在其中运行EventLoop::loop()<br>
2.EventLoopThreadPool：muduo默认多线程IO模型，新到的连接会按round-robin方式分配到线程池</p>
<p>EventLoop包含的成员：Channel、Poller、TimerQueue</p>
<p>同时用户是可以看到EventLoop的</p>
<p>实现过程中需要注意的点<br>
1.EventLoop是不可拷贝的，继承了boost::noncopyable<br>
2.构造函数会记住本对象所属的线程<br>
3.创建了EventLoop对象的线程是IO线程，主要功能是运行事件循环EventLoop::loop()。<br>
4.EventLoop对象的生命期和其所属线程一样长，所以不必是动态创建的heap对象<br>
5.EventLoop的static成员函数getEventLoopOfCurrentThread()返回EventLoop对象<br>
6.EventLoop提供了isInLoopThread()和assertInLoopThread()等函数，用于运行时检查成员函数是否是线程安全的（可以跨线程调用），哪些成员函数只能在某个特定线程调用（主要是IO线程），而事件循环必须在IO线程执行</p>
<p>我的代码和muduo的代码差异：<br>
1.isInLoopThread()和assertInLoopThread()是public的，同时额外需要privare的abortNotInLoopThread进行线程终止<br>
2.然后额外需要bool looping_和threadId_两个数据成员<br>
3.ifndef 预编译<br>
4.头文件缺失，同时头文件中需要包含路径 例如#include &quot;main/base/Mutex.h&quot;<br>
5.命名空间<br>
6.前向声明 Channel Poller Timerqueue等</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 题13:机器人的运动范围]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-ti-13ji-qi-ren-de-yun-dong-fan-wei</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-ti-13ji-qi-ren-de-yun-dong-fan-wei">
        </link>
        <updated>2020-02-10T15:41:35.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
</blockquote>
<p>第一想法还是用bool二位矩阵记录是否计算了某个点<br>
然后突然想着说不能直接循环行和列吗？<br>
然后突然发现一个问题，就是不是所有符合条件的格子都能到达的，<br>
比如（100，100）看起来只有1+1=2，但是不可能从（99，99）到达这个点</p>
<p>其实我这个方法只能算递归，而且使用引用的递归，可以看看书中返回非引用的方法<br>
其中对于范围的判断可以交给不同的地方，我这里是借用了visited的size来进行判断，所以无法像书中在check中进行判断<br>
然后利用关系运算符的判断顺序很重要，一定要先判断范围是否越界了，否则下标运算符会报错</p>
<pre><code>class Solution {
public:
    int movingCount(int threshold, int rows, int cols)
    {
        int count=0;
        vector&lt;vector&lt;bool&gt;&gt; visited(rows,vector&lt;bool&gt;(cols,false));
        visitCount(threshold,0,0,count,visited);
        return count;
    }
    
    void visitCount(int threshold,int rows,int cols,int &amp;count,vector&lt;vector&lt;bool&gt;&gt; &amp;visited){
        if(rows&gt;=visited.size()
           ||cols&gt;=visited[0].size()
           ||visited[rows][cols]
           ||!CheckThre(threshold,rows,cols))
            return;
        ++count;
        visited[rows][cols]=true;
        visitCount(threshold,rows-1,cols,count,visited);
        visitCount(threshold,rows,cols-1,count,visited);
        visitCount(threshold,rows+1,cols,count,visited);
        visitCount(threshold,rows,cols+1,count,visited);
        return;
    }
    
    bool CheckThre(int threshold,int rows,int cols){
        int res=0;
        while(rows)
            res+=rows%10,rows/=10;
        while(cols)
            res+=cols%10,cols/=10;
        return res&lt;=threshold;
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>机器人从坐标(0.0)开始移动。当它准备进入坐标为(i,j)的格子时，通过 检查坐标的数位和来判断机器人是否能够进入。如果机器人能够进入坐标 为(i,j)的格子,则再判断它能否进入4个相邻的格子(i-1,j)、(i,j-1)、(i,j+1) 和(i+1,j),因此，我们可以用如下的代码来实现回溯算法：</p>
</blockquote>
<pre><code>int movingCount(int threshold, int rows, int cols)
{
    if(threshold &lt; 0 || rows &lt;= 0 || cols &lt;= 0)
        return 0;

    bool *visited = new bool[rows * cols];
    for(int i = 0; i &lt; rows * cols; ++i)
        visited[i] = false;

    int count = movingCountCore(threshold, rows, cols,
        0, 0, visited);

    delete[] visited;

    return count;
}

int movingCountCore(int threshold, int rows, int cols, int row,
    int col, bool* visited)
{
    int count = 0;
    if(check(threshold, rows, cols, row, col, visited))
    {
        visited[row * cols + col] = true;

        count = 1 + movingCountCore(threshold, rows, cols,
            row - 1, col, visited)
            + movingCountCore(threshold, rows, cols,
                row, col - 1, visited)
            + movingCountCore(threshold, rows, cols,
                row + 1, col, visited)
            + movingCountCore(threshold, rows, cols,
                row, col + 1, visited);
    }

    return count;
}

bool check(int threshold, int rows, int cols, int row, int col,
    bool* visited)
{
    if(row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; cols
        &amp;&amp; getDigitSum(row) + getDigitSum(col) &lt;= threshold
        &amp;&amp; !visited[row* cols + col])
        return true;

    return false;
}

int getDigitSum(int number)
{
    int sum = 0;
    while(number &gt; 0)
    {
        sum += number % 10;
        number /= 10;
    }

    return sum;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 题12:矩阵中的路径]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-ti-12ju-zhen-zhong-de-lu-jing</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-ti-12ju-zhen-zhong-de-lu-jing">
        </link>
        <updated>2020-02-10T02:43:05.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串&quot;bcced&quot;的路径，但是矩阵中不包含&quot;abcb&quot;路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
</blockquote>
<p>这道题在牛客网上挺恶心的，char *是一位数组，它把矩阵首尾相连了。。。我强行化为了二维vector</p>
<pre><code>class Solution {
public:
    bool hasPath(char* matrix, int rows, int cols, char* str){
        vector&lt;vector&lt;char&gt;&gt; matrixv(rows,vector&lt;char&gt;(cols,' '));
        for(int i=0;i&lt;rows;++i)
            for(int j=0;j&lt;cols;++j)
                matrixv[i][j]=matrix[i*cols+j];
        vector&lt;vector&lt;bool&gt;&gt; bool_matrix(rows,vector&lt;bool&gt;(cols,true));
        for(int i=0;i&lt;rows;++i)
            for(int j=0;j&lt;cols;++j)
                if(FindPath(matrixv,i,j,str,0,bool_matrix))
                   return true;
        return false;
    }

    bool FindPath(vector&lt;vector&lt;char&gt;&gt; &amp;matrix,int rows,int cols,char *str,int count,vector&lt;vector&lt;bool&gt;&gt; &amp;bool_matrix){
        if(matrix[rows][cols]!=str[count])
            return false;
        if(count==strlen(str)-1)
            return true;
        bool_matrix[rows][cols]=false;
        if(rows&gt;0&amp;&amp;bool_matrix[rows-1][cols]&amp;&amp;FindPath(matrix,rows-1,cols,str,count+1,bool_matrix))
           return true;
        if(cols&gt;0&amp;&amp;bool_matrix[rows][cols-1]&amp;&amp;FindPath(matrix,rows,cols-1,str,count+1,bool_matrix))
           return true;
        if(rows&lt;matrix.size()-1&amp;&amp;bool_matrix[rows+1][cols]&amp;&amp;FindPath(matrix,rows+1,cols,str,count+1,bool_matrix))
           return true;
        if(cols&lt;matrix[0].size()-1&amp;&amp;bool_matrix[rows][cols+1]&amp;&amp;FindPath(matrix,rows,cols+1,str,count+1,bool_matrix))
           return true;
        bool_matrix[rows][cols]=true;
        return false;
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>由于回溯法的递归特性，路径可以被看成一个栈。当在矩阵中定位了路径中前n个字符的位置之后，在与第n个字符对应的格子的周围都没有 找到第n+1个字符，这时候只好在路径上回到第n-1个字符，重新定位第n个字符。<br>
由于路径不能重复进入矩阵的格子，所以还需要定义和字符矩阵大小一样的布尔值矩阵，用来标识路径是否己经进入了每个格子。</p>
</blockquote>
<pre><code>bool hasPathCore(const char* matrix, int rows, int cols, int row, int col, const char* str, int&amp; pathLength, bool* visited);

bool hasPath(const char* matrix, int rows, int cols, const char* str)
{
    if(matrix == nullptr || rows &lt; 1 || cols &lt; 1 || str == nullptr)
        return false;

    bool *visited = new bool[rows * cols];
    memset(visited, 0, rows * cols);

    int pathLength = 0;
    for(int row = 0; row &lt; rows; ++row)
    {
        for(int col = 0; col &lt; cols; ++col)
        {
            if(hasPathCore(matrix, rows, cols, row, col, str,
                pathLength, visited))
            {
                return true;
            }
        }
    }

    delete[] visited;

    return false;
}

bool hasPathCore(const char* matrix, int rows, int cols, int row,
    int col, const char* str, int&amp; pathLength, bool* visited)
{
    if(str[pathLength] == '\0')
        return true;

    bool hasPath = false;
    if(row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; cols
        &amp;&amp; matrix[row * cols + col] == str[pathLength]
        &amp;&amp; !visited[row * cols + col])
    {
        ++pathLength;
        visited[row * cols + col] = true;

        hasPath = hasPathCore(matrix, rows, cols, row, col - 1,
            str, pathLength, visited)
            || hasPathCore(matrix, rows, cols, row - 1, col,
                str, pathLength, visited)
            || hasPathCore(matrix, rows, cols, row, col + 1,
                str, pathLength, visited)
            || hasPathCore(matrix, rows, cols, row + 1, col,
                str, pathLength, visited);

        if(!hasPath)
        {
            --pathLength;
            visited[row * cols + col] = false;
        }
    }

    return hasPath;
}
</code></pre>
<blockquote>
<p>当矩阵中坐标为(row, col)的格子和路径字符串中下标为pathLength的 字符一样时，从 4 个相邻的格子(row, col-1)、(row-1, col)、 (row, col+1)和 (row+1, col)中去定位路径字符串中下标为pathLength+1的字符。<br>
如果4个相邻的格子都没有匹配字符串中下标为pathLength+1的字符， 则表明当前路径字符串中下标为pathLength的字符在矩阵中的定位不正确， 我们需要回到前一个字符(pathLength-1),然后重新定位。<br>
一直重复这个过程，直到路径字符串上的所有字符都在矩阵中找到合 适的位置(此时 str[pathLength]=='\0')。</p>
</blockquote>
<p>书中的代码比我简介很多，特别是把递归结果利用或逻辑运算符||来组合，不像我分成了很多判断语句，但是相应地就必须把判断条件放在前面了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[阅读总结-《Linux多线程服务端编程：使用muduo C++网络库》]]></title>
        <id>https://lixin-scut.github.io//post/yue-du-zong-jie-lesslesslinux-duo-xian-cheng-fu-wu-duan-bian-cheng-shi-yong-muduo-cwang-luo-ku-greatergreater</id>
        <link href="https://lixin-scut.github.io//post/yue-du-zong-jie-lesslesslinux-duo-xian-cheng-fu-wu-duan-bian-cheng-shi-yong-muduo-cwang-luo-ku-greatergreater">
        </link>
        <updated>2020-02-09T12:13:48.000Z</updated>
        <content type="html"><![CDATA[<p>第一部分<br>
1.在多线程的环境中，使用RAII handle机制来管理可能出现竞态条件（race condition）的对象，并且能够通过handle对象的构造函数和析构函数避免出现内存泄漏的情况<br>
具体就是使用shared_ptr和weak_ptr来管理对象，并且通过定制析构函数来保证不会出现任何内存泄漏的情况<br>
调用时尝试提升weak_ptr 为shared_ptr,如果失败则说明对象已经被析构。</p>
<p>2.线程同步方法及其对象<br>
只是用互斥锁mutex和条件变量condition variable<br>
使用RAII机制封装mutex，防止出现遇到异常而无法解锁的情况<br>
只是用TCP socket进行进程间通信</p>
<p>3.多线程服务器模型及适用场合<br>
基于事件驱动的编程模型<br>
Reactor模式 no-blocking IO+IO multiplexing<br>
one loop one thread（Reactor）<br>
线程池 TaskQueue<br>
总结：one loop one thread+thread pool<br>
这正是muduo网络可以提供的服务器程序服务，亦即不用用户去操心底层系统调用，而是提供调用的接口<br>
进程间通信只使用TCP</p>
<p>4.多线程系统编程<br>
多个线程安全的函数组合起来就容易丧失线程安全性<br>
尽量不要用共享变量，用的话最好保证是只读read-only<br>
不要用pthread_self的pthread_t 而用gettid,并使用__thread变量来缓存，不要每次都执行系统调用<br>
线程的创建与销毁-安全地退出一个多线程的程序并不是一件容易的事情，需要精心设计共享对象的析构顺序，防止各个线程在退出时访问已失效对象，可以不必追求安全地推出，而是让进程进入拒绝服务状态，然后直接杀掉<br>
exit不是线程安全的<br>
善用__thread关键字<br>
每个文件描述符只由一个线程操作，亦即一个线程可以操作多个文件描述符，但是不可以操作其他线程的操作描述符<br>
用socket对象通过RAII机制管理文件描述符<br>
为了防止访问失效对象和网络串话，使用shared_ptr来管理tcpconnection的生命期，这是唯一采用引用计数方式来管理生命期的对象<br>
fork可能会导致RAII失效，使用多线程时尽量不要用fork了，唯一安全的方法就是fork后立即调用exec<br>
多线程中不要使用signal<br>
不主动处理各种异常信号，直接默认结束进程<br>
linux新增了部分系统调用 比如文件描述符的非阻塞IO、exec后强制关闭文件描述符</p>
<p>5.多线程日志<br>
故障诊断和追踪<br>
日志库是单例模式<br>
muduo日志库是C++ stream风格，但没用iostream，而是自己写了logstream class<br>
日志需要有设置级别的功能<br>
日志的目的地只有本地，不要往网络传日志<br>
日志应该有rolling功能，主要由文件大小和时间来区分<br>
日志文件名：进程名+时间+机器名+进程id+后缀.log<br>
防止程序崩溃1.定期flush 2.在内存中的日志消息都有cookie，值为某个函数地址<br>
日志消息格式是固定的，不需要通过运行时配置<br>
要点 1.每条日志只占1行 2.时间戳精确到微妙 gettimeofday 3.保证同一时区 4.打印线程id 5.打印日志级别 6.打印源文件名和行号<br>
每行日志的前四个字段的宽度是固定的 以空格分隔 便于分析，避免出现正则表达式的元字符<br>
优化：1.日期和时间都是缓存的 2.前四个字段是定长的，避免运行时求长度<br>
3.线程id预先格式化为字符串 4.源文件名部分采用编译器计算<br>
多线程异步日志：使用一个背景线程来收集日志信息，其他业务线程往这个线程发送日志消息<br>
双缓冲技术 使用两个buffer 分为前段接收和后端写入<br>
实际上有四个缓冲区</p>
<p>6.muduo网络库简介<br>
主体目录主要部分为base和net<br>
base目录下主要使一些基础库，基本都是用户可见的类<br>
比较重点的有异步日志、阻塞队列、条件变量、互斥锁、进程信息、线程对象和线程池等<br>
而net目录则是muduo的核心部分，主要体现了其<br>
1.基于Reactor模式的网络库，其核心是个事件循环Eventloop<br>
2.采用基于对象（object-based）而非面向对象（object-oriented）的设计风格<br>
3.事件回调接口多以boost::fuction + boost::bind表达<br>
2、3点使得用户使用muduo的时候不需要继承其中的class</p>
<p>net中的都是比较重要的部分<br>
其中相对更重要的是<br>
1.Acceptor 用于服务端接受tcp连接<br>
2.Connector 连接器，用于客户端发起连接<br>
3.EventLoop 事件分发器<br>
4.EventLoopThread 新建一个专门用于EventLoop的线程<br>
5.EventLoopThreadPool muduo默认多线程IO模型<br>
6.Poller IO multiplexing的基类接口<br>
7.Poller IO multiplexing的实现<br>
8.Socket 封装Socket描述符 负责关闭连接<br>
9.SocketOps 封装底层的Socket API<br>
10.TcpConnection  管理tcp连接<br>
11.TcpClient和TcpServer 客户端和服务端<br>
12.Timer 定时器</p>
<p>从用户角度：<br>
使用muduo网络库提供的服务需要掌握五个类：Buffer、EventLoop、TcpConnection、TcpClient、TcpServer<br>
<img src="https://lixin-scut.github.io//post-images/1581341726910.png" alt=""><br>
muduo头文件中使用了前向声明，大大简化了头文件之间的依赖关系。避免包含有文件，或者暴露用户不应接触的类等。</p>
<p>公开接口：<br>
Buffer：数据的读写通过buffer进行，用户不需要调用read/write等<br>
InetAddress：封装IPv4地址，不进行DNS解析域名，只认IP地址，因为用gethostbyname解析域名会阻塞IO线程<br>
EventLoop：反应器Reactor，每个线程只能有一个EventLoop实体，负责IO和定时器事件的分派，用eventfd来异步唤醒。用TimerQueue来作为计时器管理，用Poller作为IO multiplexing<br>
EventLoopThread：启动一个线程，在其中运行EventLoop::loop()<br>
TcpConnection：整个网络库的核心，封装一次TCP连接，注意它不能发起连接<br>
TcpClient和TcpServer：网络客户端和网络服务端<br>
上述类中，TcpConnection的生命期依靠shared_ptr管理，Buffer的生命期由TcpConnection控制。其余类的生命期由用户控制<br>
Buffer和InetAddress具有值语义，可以拷贝，其他class对象都是对象语义，不可以拷贝</p>
<p>内部实现<br>
Channel：负责注册与响应IO事件，但不拥有文件描述符，属于Acceptor、Connector、EventLoop、TimerQueue、TcpConnection的成员，生命期由后者控制<br>
Socket：RAII handle，封装一个描述符fd，并在析构时关闭fd，是Acceptor、TcpConnection的成员，EventLoop、TimerQueue也拥有fd，但不封装为Socket class。<br>
Poller：PollPoller和EPollPoller的基类，采用LT触发，是Eventloop的成员<br>
Connector：发起TCP连接，是TcpClient的成员<br>
Acceptor：接受TCP连接，它是TcpServer的成员，生命期由后者控制<br>
TimerQueue：用timefd实现定时，使用map来管理Timer，是EventLoop的成员<br>
EventLoopThreadPool：用于创建IO线程池，用于把TcpConnection分派到某个EventLoop线程上，它是TcpServer的成员<br>
<img src="https://lixin-scut.github.io//post-images/1581346971439.png" alt=""></p>
<p>线程模型：<br>
每个线程最多只有一个EventLoop，每个TcpConnection必须归某个EventLoop管理，所有的IO会转移到这个线程<br>
一个描述符fd只能由一个线程读写<br>
TcpConnection所在的线程由EventLoop决定<br>
TcpConnection和EventLoop是线程安全的<br>
TcpServer直接支持多线程，有两种模式分别为单线程和多线程，主要的区别是后者创建一个EventLoopThreadPool，新到的连接会按round-robin方式分配到线程池</p>
<p>Buffer类的设计与使用<br>
非阻塞IO总是与IO复用函数（select/poll/epoll）一起使用，所以应用层的buffer是必需的<br>
TcpConnection必须要有output buffer，并且当输出缓冲中还有待发送的数据时，程序希望关闭连接的话，此时网络库必须等待数据发送完毕，而不能立即关闭连接<br>
因为使用的是Epoll的LT电平触发，所以网络库在处理socket可读事件的时候必须一次性把socket中的数据读完（从内核buffer到应用层buffer），否则会一直触发POLLIN事件<br>
此时就会出现“粘包”现象，亦即buffer中有部分数据不完整的情况，需要使用codec分包，等待构成一条完整的信息再通知程序的业务逻辑<br>
为什么不用边缘触发edge trigger 一是与传统的poll兼容，二是电平触发编程更容易，三是读写的时候不必等候出现EAGAIN，可以节省系统调用，降低延迟<br>
一般不需要直接操作buffer<br>
buffer内部是vector&lt; char &gt; ，是一块连续的内存<br>
分为三个部分：prependable、readable、writable<br>
buffer使用下标而不是迭代器，因为vector是自增长的，重新分配内存之后会使得原来的指针失效<br>
prepend前方添加：有时候readIndex比较靠后，buffer前半部分有一定的空间，可以先序列化消息，然后再在序列化数据的前面添加消息的长度</p>
<p>codec编解码器：LengthHeaderCodec<br>
codec的基本功能之一就是做TCP分包，使得不完整的信息不会触发消息事件回调，而是先停留在buffer中<br>
所以同时也承接了将send发送的信息进行编码</p>
<p>Dispatcher分发器：<br>
在传递多种Protobuf消息的过程中对收到的消息按类型分发</p>
<p>限制服务器的最大并发连接数：<br>
防止客户端连接数过多导致文件描述符fd耗尽<br>
优雅地断开新连接：准备一个空闲的文件描述符，当剩余的fd耗尽时，就立即使用这个文件描述符，但是注意accept新连接后立即close，然后重新打开一个空闲文件继续把空闲的文件描述符占住，当再次出现这种情况的时候使用<br>
但是注意只有一个空闲的文件描述符的时候容易造成race condition，最好是指一个缓冲，当fd数量进入这个缓冲区的时候就要进行主动关闭新连接的优雅断开连接了<br>
muduo中直接是使用一个int成员来表示当前的活动连接数，在onConnection中判断当前活动连接数，如果超过了最大允许数就踢掉连接。<br>
如果有业务逻辑的服务可以在shutdown前发送一个简单的响应，表明本服务程序<br>
的负载能力已经饱和</p>
<p>定时器<br>
计时只使用gettimeofday来获取当前事件，因为它不是系统调用，而是在用户态实现的，没有上下文切换和陷入内核等开销<br>
定时只使用timerfd_* 系列函数来完成处理定时任务，timefd_create可以把时间变成一个文件描述符，当定时器超时时变为可读，可以和epoll等IO复用函数配合使用，符合Reactor模式中利用统一的方法处理IO事件和超时事件的思想<br>
muduo的定时器接口有四个：<br>
runAt：在指定时间调用TimerCallback<br>
runAfter：等一段时间再调用TimerCallback；<br>
runEvery：以固定的时间间隔反复调用TimerCallback<br>
cancel：取消timer<br>
muduo的TimerQueue采用平衡二叉树来管理未到期的timers，时间复杂度是O(logN)</p>
<p>利用timing wheel踢掉空闲连接<br>
一个连接如果若干秒都没有收到数据，就被认为是空闲连接<br>
muduo使用循环队列来处理连接超时，每个节点保存n秒后将要超时的连接的hash set<br>
实现中hash set中放的不是连接，而是一个特制的Entry struct，包含TcpConnection的weak_ptr，Entry的析构函数会判断连接是否还存在，如果提升弱引用失败的话就等于已经不存在了<br>
用shared_ptr来管理Entry，如果引用计数变为0则自动析构，把Entry放到格子里时会递增它的引用计数<br>
在连接建立时，创建一个Entry对象，把它放到timing wheel的队尾，还需要把Entry的弱引用保存到TcpConnection的context里，收到数据时从context中取出弱引用，提升为强引用EntryPtr，放到队尾，同时circular_buffer会自动弹出队首的Bucket并析构<br>
注意连接Entry可以存在多个set中，只有析构set时引用计数变为0的连接才会被析构</p>
]]></content>
    </entry>
</feed>