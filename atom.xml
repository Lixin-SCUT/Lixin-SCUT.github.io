<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-05-01T03:34:27.598Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>千里之行，始于足下。不积跬步，无以至千里。</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[MySQL 176. 第二高的薪水[简单]]]></title>
        <id>https://lixin-scut.github.io//post/mysql-176-di-er-gao-de-xin-shui-jian-dan</id>
        <link href="https://lixin-scut.github.io//post/mysql-176-di-er-gao-de-xin-shui-jian-dan">
        </link>
        <updated>2020-05-01T03:16:06.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>编写一个 SQL 查询，获取 Employee 表中第二高的薪水（Salary） 。<br>
+----+--------+<br>
| Id | Salary |<br>
+----+--------+<br>
| 1  | 100    |<br>
| 2  | 200    |<br>
| 3  | 300    |<br>
+----+--------+<br>
例如上述 Employee 表，SQL查询应该返回 200 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 null。<br>
+---------------------+<br>
| SecondHighestSalary |<br>
+---------------------+<br>
| 200                 |<br>
+---------------------+<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/second-highest-salary<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>主要是下面几个点<br>
1.列别名， AS SecondHighestSalary<br>
2. 降序排序，使用ORDER BY +DESC<br>
3. 限制行数  LIMIT 1,1，注意行数从0开始，第一行为0<br>
4. 去重， 使用DISTINCT<br>
5. 返回NULL，使用子查询</p>
<pre><code>SELECT (SELECT DISTINCT Salary 
        FROM Employee
        ORDER BY Salary DESC
        LIMIT 1,1) AS SecondHighestSalary;
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>方法一：使用子查询和 LIMIT 子句<br>
算法<br>
将不同的薪资按降序排序，然后使用 LIMIT 子句获得第二高的薪资。</p>
</blockquote>
<pre><code>MySQL
SELECT DISTINCT
    Salary AS SecondHighestSalary
FROM
    Employee
ORDER BY Salary DESC
LIMIT 1 OFFSET 1
</code></pre>
<blockquote>
<p>然而，如果没有这样的第二最高工资，这个解决方案将被判断为 “错误答案”，因为本表可能只有一项记录。为了克服这个问题，我们可以将其作为临时表。</p>
</blockquote>
<pre><code>MySQL
SELECT
    (SELECT DISTINCT
            Salary
        FROM
            Employee
        ORDER BY Salary DESC
        LIMIT 1 OFFSET 1) AS SecondHighestSalary
;
</code></pre>
<blockquote>
<p>方法二：使用 IFNULL 和 LIMIT 子句<br>
解决 “NULL” 问题的另一种方法是使用 “IFNULL” 函数，如下所示。</p>
</blockquote>
<pre><code>MySQL
SELECT
    IFNULL(
      (SELECT DISTINCT Salary
       FROM Employee
       ORDER BY Salary DESC
        LIMIT 1 OFFSET 1),
    NULL) AS SecondHighestSalary
</code></pre>
<p>《MySQL知识点》<br>
<strong>排序检索数据</strong><br>
  检索出的数据并不是以纯粹的随机顺序显示的。如果不排 序，数据一般将以它在底层表中出现的顺序显示。这可以是数据最初添加到表中的顺序。但是，如果数据后来进行过更新或删除，则此顺 序将会受到MySQL重用回收存储空间的影响。因此，如果不明确控 制的话，不能(也不应该)依赖该排序顺序。关系数据库设计理论认 为，如果不明确规定排序顺序，则不应该假定检索出的数据的顺序有 意义。<br>
  为了明确地排序用SELECT语句检索出的数据，可使用ORDER BY子句。 ORDER BY子句取一个或多个列的名字，据此对输出进行排序<br>
  通常，ORDERBY子句中使用的列将 是为显示所选择的列。但是，实际上并不一定要这样，用非 检索的列排序数据是完全合法的。<br>
  在按多个列排序时，排序完全按所规定的顺序进行。<br>
  数据排序不限于升序排序(从A到Z)。这只是默认的排序顺序，还可 以使用ORDER BY子句以降序(从Z到A)顺序排序。为了进行降序排序， 必须指定DESC关键字。<br>
  DESC关键字只应用到直接位于其前面的列名。如果想在多个列上进行降序排序，必须 对每个列指定DESC关键字。</p>
<p><strong>LIMIT关键字</strong><br>
  使用ORDER BY和LIMIT的组合，能够找出一个列中最高或最低的值。<br>
  SELECT语句返回所有匹配的行，它们可能是指定表中的每个行。为了返回第一行或前几行，可使用LIMIT子句<br>
  带一个值的LIMIT总是从第一行开始，给出的数为返回的行数。 带两个值的LIMIT可以指定从行号为第一个值的位置开始。<br>
  检索出来的第一行为行0而不是行1。因此，LIMIT1,1 将检索出第二行而不是第一行。<br>
  在行数不够时 LIMIT中指定要检索的行数为检索的最大行 数。如果没有足够的行(例如，给出LIMIT 10, 5，但只有13 行)，MySQL将只返回它能返回的那么多行。<br>
  MySQL 5的LIMIT语法 LIMIT 3, 4的含义是从行4开始的3 行还是从行3开始的4行?如前所述，它的意思是从行3开始的4 行，这容易把人搞糊涂。<br>
  由于这个原因，MySQL 5支持LIMIT的另一种替代语法。LIMIT 4 OFFSET 3意为从行3开始取4行，就像LIMIT 3, 4一样。</p>
<p><strong>DISTINCT关键字</strong><br>
  使用DISTINCT关键字检索出有不同值的列表，此关键字指示MySQL 只返回不同的值。<br>
  不能部分使用DISTINCT DISTINCT关键字应用于所有列而 不仅是前置它的列。如果给出SELECT DISTINCT vend_id, prod_price，除非指定的两个列都不同，否则所有行都将被 检索出来。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 31. 下一个排列[中等][未做出]]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-31-xia-yi-ge-pai-lie-zhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-31-xia-yi-ge-pai-lie-zhong-deng-wei-zuo-chu">
        </link>
        <updated>2020-05-01T02:30:07.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。<br>
如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。<br>
必须原地修改，只允许使用额外常数空间。<br>
以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br>
1,2,3 → 1,3,2<br>
3,2,1 → 1,2,3<br>
1,1,5 → 1,5,1<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/next-permutation<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>第一感觉是从后往前找到第一个顺序（相对于逆序）的两个数字进行交换<br>
如果一直找到头部都还是逆序的话直接反转整个vector<br>
然后翻车了hhh，确实没那么简单， 比如 1，3，2 交换为3，1，2的话不符合2，1，3</p>
<p>最后还是看了题解</p>
<ol>
<li>首先从后往前找出第一个顺序点</li>
<li>寻找可以交换的大于交换点的第一个数字</li>
<li>交换后对交换点后进行转换（亦即逆序变为顺序）</li>
</ol>
<p>确实比较有趣</p>
<pre><code>class Solution {
public:
    void nextPermutation(vector&lt;int&gt;&amp; nums) {
        int i = nums.size() - 2;
        while(i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i+1])
        {
            --i;
        }
        if(i &gt;=0)
        {
            int j = nums.size() - 1;
            while(j &gt;= 0 &amp;&amp; nums[j] &lt;= nums[i])
            {
                --j;
            }
            swap(nums[i], nums[j]);
        }
        reverse(nums.begin() + i + 1, nums.end());
    }
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>概要<br>
我们需要找到给定数字列表的下一个字典排列，而不是由给定数组形成的数字。<br>
解决方案<br>
方法一：暴力法<br>
算法<br>
在这种方法中，我们找出由给定数组的元素形成的列表的每个可能的排列，并找出比给定的排列更大的排列。<br>
但是这个方法是一种非常天真的方法，因为它要求我们找出所有可能的排列<br>
这需要很长时间，实施起来也很复杂。<br>
因此，这种方法根本无法通过。 所以，我们直接采用正确的方法。<br>
复杂度分析<br>
时间复杂度：O(n!)，可能的排列总计有 n! 个。<br>
空间复杂度：O(n)，因为数组将用于存储排列。<br>
方法二：一遍扫描<br>
算法<br>
首先，我们观察到对于任何给定序列的降序，没有可能的下一个更大的排列。<br>
例如，以下数组不可能有下一个排列：<br>
[9, 5, 4, 3, 1]<br>
我们需要从右边找到第一对两个连续的数字 a[i] 和 a[i−1]，它们满足 a[i]&gt;a[i−1]。现在，没有对 a[i−1] 右侧的重新排列可以创建更大的排列，因为该子数组由数字按降序组成。因此，我们需要重新排列 a[i−1] 右边的数字，包括它自己。<br>
现在，什么样子的重新排列将产生下一个更大的数字呢？我们想要创建比当前更大的排列。因此，我们需要将数字 a[i−1] 替换为位于其右侧区域的数字中比它更大的数字，例如 a[j]。<br>
我们交换数字 a[i−1] 和 a[j]。我们现在在索引 i−1 处有正确的数字。 但目前的排列仍然不是我们正在寻找的排列。我们需要通过仅使用 a[i−1]右边的数字来形成最小的排列。 因此，我们需要放置那些按升序排列的数字，以获得最小的排列。<br>
但是，请记住，在从右侧扫描数字时，我们只是继续递减索引直到我们找到 a[i] 和 a[i−1] 这对数。其中，a[i]&gt;a[i−1]。因此，a[i−1] 右边的所有数字都已按降序排序。此外，交换 a[i−1] 和 a[j] 并未改变该顺序。因此，我们只需要反转<br>
a[i−1] 之后的数字，以获得下一个最小的字典排列。</p>
</blockquote>
<pre><code>public class Solution {
    public void nextPermutation(int[] nums) {
        int i = nums.length - 2;
        while (i &gt;= 0 &amp;&amp; nums[i + 1] &lt;= nums[i]) {
            i--;
        }
        if (i &gt;= 0) {
            int j = nums.length - 1;
            while (j &gt;= 0 &amp;&amp; nums[j] &lt;= nums[i]) {
                j--;
            }
            swap(nums, i, j);
        }
        reverse(nums, i + 1);
    }

    private void reverse(int[] nums, int start) {
        int i = start, j = nums.length - 1;
        while (i &lt; j) {
            swap(nums, i, j);
            i++;
            j--;
        }
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)，在最坏的情况下，只需要对整个数组进行两次扫描。<br>
空间复杂度：O(1)，没有使用额外的空间，原地替换足以做到。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 120. 三角形最小路径和[中等]]]></title>
        <id>https://lixin-scut.github.io//post/dong-tai-gui-hua-120-san-jiao-xing-zui-xiao-lu-jing-he-zhong-deng</id>
        <link href="https://lixin-scut.github.io//post/dong-tai-gui-hua-120-san-jiao-xing-zui-xiao-lu-jing-he-zhong-deng">
        </link>
        <updated>2020-05-01T01:16:01.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。<br>
例如，给定三角形：<br>
[<br>
[2],<br>
[3,4],<br>
[6,5,7],<br>
[4,1,8,3]<br>
]<br>
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。<br>
说明：<br>
如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/triangle<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>第一反应是每层选择最小的数字，但是很明显这样子是不行的<br>
比如 [0]、[10，0]、[0, 99, 99] 明显第二层应该选10而不是0<br>
偷看标签知道是动态规划<br>
面对题目编程的话，普通方法应该是n^2的复杂度<br>
然后突然就来灵感了<br>
用一个容量为n的容器保存每一层每一个格子的路径和<br>
状态转移方程就是上一层两个可能的转移的节点的最小值加上当前节点的和，比如5这个节点就只需要考虑3和4<br>
然后如果不可能的位置就置为0吧<br>
本质上应该用一个容量为n*n的容器，n是层数，我的方法是直接进行了空间压缩</p>
<p>hhh实现的时候有个问题，我一开始从前到后更新，发现这样会被覆盖啊。。。比如0依赖于-1和0，但是1依赖于0和1，0已经被覆盖了</p>
<p>实现中注意的问题</p>
<ol>
<li>我把数组的长度修改为n+1，这样第一个数就不要单独判断了，但是相应地内循环需要修改判断条件和下标</li>
<li>因为我选择了初始化为INT_MAX，所以必须手动导入第一行，另外导致必须手动判断空数组</li>
<li>从后到前更新，原因前面有说</li>
</ol>
<pre><code>class Solution {
public:
    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) {
        int n = triangle.size();
        if(n == 0)
        {   return 0; }
        vector&lt;int&gt; counts(n + 1, INT_MAX);
        
        counts[1] = triangle[0][0];
        for(int i = 1; i &lt; n; ++i)
        {
            for(int j = i+1; j &gt; 0; --j)
            {
                counts[j] = min(counts[j - 1], counts[j]) + triangle[i][j - 1];
            }
        }
        
        int ans = INT_MAX;
        for(int i : counts)
        {
            ans = min(ans, i);
        }
        return ans;
    }
};
</code></pre>
<p>然后看了网友题解发现一个很有趣的事，就是外循环可以从底向上，这样子的话确实初始化方便一点。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[8. 注释 -Google C++编程规范]]></title>
        <id>https://lixin-scut.github.io//post/8-zhu-shi-google-cbian-cheng-gui-fan</id>
        <link href="https://lixin-scut.github.io//post/8-zhu-shi-google-cbian-cheng-gui-fan">
        </link>
        <updated>2020-04-30T15:11:17.000Z</updated>
        <content type="html"><![CDATA[<p>  注释虽然写起来很痛苦, 但对保证代码可读性至关重要. 下面的规则描述了如何注释以及在哪儿注释. <strong>当然也要记住: 注释固然很重要, 但最好的代码应当本身就是文档. 有意义的类型名和变量名, 要远胜过要用注释解释的含糊不清的名字.</strong></p>
<p>  <strong>你写的注释是给代码读者看的, 也就是下一个需要理解你的代码的人. 所以慷慨些吧, 下一个读者可能就是你!</strong></p>
<h3 id="81-注释风格">8.1. 注释风格</h3>
<p><strong>总述</strong></p>
<p>  使用 // 或<code>/* */</code>, 统一就好.</p>
<p><strong>说明</strong></p>
<p>  // 或 <code>/* */</code> 都可以; <strong>但 // 更 常用</strong>. 要在如何注释及注释风格上确保统一.</p>
<h3 id="82-文件注释">8.2. 文件注释</h3>
<p><strong>总述</strong></p>
<p>  <strong>在每一个文件开头加入版权公告.</strong></p>
<p>  <strong>文件注释描述了该文件的内容</strong>. 如果一个文件<strong>只声明, 或实现, 或测试</strong>了一个对象, 并且这个对象已经在它的声明处进行了详细的注释, 那么<strong>就没必要再加上文件注释</strong>. 除此之外的其他文件都需要文件注释.</p>
<p><strong>说明</strong></p>
<p>  法律公告和作者信息</p>
<p>  <strong>每个文件都应该包含许可证引用. 为项目选择合适的许可证版本.(比如, Apache 2.0, BSD, LGPL, GPL)</strong></p>
<p>  如果你对原始作者的文件做了重大修改, 请考虑删除原作者信息.</p>
<p><strong>文件内容</strong></p>
<p>  <strong>如果一个 .h 文件声明了多个概念, 则文件注释应当对文件的内容做一个大致的说明, 同时说明各概念之间的联系</strong>. 一个一到两行的文件注释就足够了, <strong>对于每个概念的详细文档应当放在各个概念中, 而不是文件注释中</strong>.</p>
<p>  不要在 .h 和 .cc 之间复制注释, 这样的注释偏离了注释的实际意义.</p>
<h3 id="83-类注释">8.3. 类注释</h3>
<p><strong>总述</strong></p>
<p>  <strong>每个类的定义都要附带一份注释, 描述类的功能和用法, 除非它的功能相当明显.</strong></p>
<pre><code>// Iterates over the contents of a GargantuanTable.
// Example:
//    GargantuanTableIterator* iter = table-&gt;NewIterator();
//    for (iter-&gt;Seek(&quot;foo&quot;); !iter-&gt;done(); iter-&gt;Next()) {
//      process(iter-&gt;key(), iter-&gt;value());
//    }
//    delete iter;
class GargantuanTableIterator {
  ...
};
</code></pre>
<p><strong>说明</strong></p>
<p>  类注释应当为读者理解<strong>如何使用与何时使用类</strong>提供足够的信息, 同时应当提醒读者<strong>在正确使用此类时应当考虑的因素</strong>. 如果类<strong>有任何同步前提</strong>, 请用文档说明. 如果该类的实例可被多线程访问, 要特别注意文档说明<strong>多线程环境下相关的规则和常量使用</strong>.</p>
<p>  如果你想<strong>用一小段代码演示这个类的基本用法或通常用法</strong>, 放在类注释里也非常合适.</p>
<p>  如果类的声明和定义分开了(例如分别放在了 .h 和 .cc 文件中), 此时, <strong>描述类用法的注释应当和接口定义放在一起</strong>,<strong>描述类的操作和实现的注释应当和实现放在一起.</strong></p>
<h3 id="84-函数注释">8.4. 函数注释</h3>
<p><strong>总述</strong></p>
<p>  <strong>函数声明处的注释描述函数功能; 定义处的注释描述函数实现.</strong></p>
<p><strong>说明</strong></p>
<p>函数声明</p>
<p>  基本上每个函数<strong>声明处</strong>前都应当加上注释, 描述函数的<strong>功能和用途</strong>. 只有在函数的功能简单而明显时才能省略这些注释(例如, 简单的取值和设值函数). <strong>注释使用叙述式 (“Opens the file”) 而非指令式 (“Open the file”); 注释只是为了描述函数, 而不是命令函数做什么</strong>. 通常, <strong>注释不会描述函数如何工作. 那是函数定义部分的事情.</strong></p>
<p>函数声明处注释的内容:</p>
<ol>
<li>函数的输入输出.</li>
<li>对类成员函数而言: 函数调用期间对象是否需要保持引用参数, 是否会释放这些参数.</li>
<li>函数是否分配了必须由调用者释放的空间.</li>
<li>参数是否可以为空指针.</li>
<li>是否存在函数使用上的性能隐患.</li>
<li>如果函数是可重入的, 其同步前提是什么?</li>
</ol>
<p>举例如下:</p>
<pre><code>// Returns an iterator for this table.  It is the client's
// responsibility to delete the iterator when it is done with it,
// and it must not use the iterator once the GargantuanTable object
// on which the iterator was created has been deleted.
//
// The iterator is initially positioned at the beginning of the table.
//
// This method is equivalent to:
//    Iterator* iter = table-&gt;NewIterator();
//    iter-&gt;Seek(&quot;&quot;);
//    return iter;
// If you are going to immediately seek to another place in the
// returned iterator, it will be faster to use NewIterator()
// and avoid the extra seek.
Iterator* GetIterator() const;
</code></pre>
<p>  但也要避免罗罗嗦嗦, 或者对显而易见的内容进行说明. 下面的注释就没有必要加上 “否则返回 false”, 因为已经暗含其中了:</p>
<pre><code>// Returns true if the table cannot hold any more entries.
bool IsTableFull();
</code></pre>
<p>  <strong>注释函数重载时, 注释的重点应该是函数中被重载的部分, 而不是简单的重复被重载的函数的注释</strong>. <strong>多数情况下, 函数重载不需要额外的文档, 因此也没有必要加上注释.</strong></p>
<p>  注释构造/析构函数时, 切记读代码的人知道构造/析构函数的功能, 所以 “销毁这一对象” 这样的注释是没有意义的. 你<strong>应当注明的是注明构造函数对参数做了什么 (例如, 是否取得指针所有权) 以及析构函数清理了什么</strong>. 如果都是些无关紧要的内容, 直接省掉注释. 析构函数前没有注释是很正常的.</p>
<p><strong>函数定义</strong></p>
<p>  <strong>如果函数的实现过程中用到了很巧妙的方式, 那么在函数定义处应当加上解释性的注释</strong>. 例如, 你所使用的编程技巧, 实现的大致步骤, 或解释如此实现的理由. 举个例子, 你可以说明为什么函数的前半部分要加锁而后半部分不需要.</p>
<p>  不要 从 .h 文件或其他地方的函数声明处直接复制注释. <strong>简要重述函数功能是可以的, 但注释重点要放在如何实现上.</strong></p>
<h3 id="85-变量注释">8.5. 变量注释</h3>
<p><strong>总述</strong></p>
<p>  通常变量名本身足以很好说明变量用途. 某些情况下, 也需要额外的注释说明.</p>
<p><strong>说明</strong></p>
<p><strong>类数据成员</strong></p>
<p>  <strong>每个类数据成员 (也叫实例变量或成员变量) 都应该用注释说明用途</strong>. 如果有非变量的参数(例如特殊值, 数据成员之间的关系, 生命周期等)不能够用类型与变量名明确表达, 则应当加上注释. 然而, 如果变量类型与变量名已经足以描述一个变量, 那么就不再需要加上注释.</p>
<p><strong>特别地, 如果变量可以接受 NULL 或 -1 等警戒值, 须加以说明</strong>. 比如:</p>
<pre><code>private:
 // Used to bounds-check table accesses. -1 means
 // that we don't yet know how many entries the table has.
 int num_total_entries_;
</code></pre>
<p><strong>全局变量</strong></p>
<p>  <strong>和数据成员一样, 所有全局变量也要注释说明含义及用途, 以及作为全局变量的原因</strong>. 比如:</p>
<pre><code>// The total number of tests cases that we run through in this regression test.
const int kNumTestCases = 6;
</code></pre>
<h3 id="86-实现注释">8.6. 实现注释</h3>
<p><strong>总述</strong></p>
<p>对于代码中巧妙的, 晦涩的, 有趣的, 重要的地方加以注释.</p>
<p><strong>说明</strong></p>
<p><strong>代码前注释</strong></p>
<p>巧妙或复杂的代码段前要加注释. 比如:</p>
<pre><code>// Divide result by two, taking into account that x
// contains the carry from the add.
for (int i = 0; i &lt; result-&gt;size(); i++) {
  x = (x &lt;&lt; 8) + (*result)[i];
  (*result)[i] = x &gt;&gt; 1;
  x &amp;= 1;
}
</code></pre>
<p><strong>行注释</strong></p>
<p>比较隐晦的地方要在行尾加入注释. 在行尾空两格进行注释. 比如:</p>
<pre><code>// If we have enough memory, mmap the data portion too.
mmap_budget = max&lt;int64&gt;(0, mmap_budget - index_-&gt;length());
if (mmap_budget &gt;= data_size_ &amp;&amp; !MmapData(mmap_chunk_bytes, mlock))
  return;  // Error already logged.
</code></pre>
<p>注意, 这里用了两段注释分别描述这段代码的作用, 和提示函数返回时错误已经被记入日志.</p>
<p><strong>如果你需要连续进行多行注释, 可以使之对齐获得更好的可读性:</strong></p>
<pre><code>DoSomething();                  // Comment here so the comments line up.
DoSomethingElseThatIsLonger();  // Two spaces between the code and the comment.
{ // One space before comment when opening a new scope is allowed,
  // thus the comment lines up with the following comments and code.
  DoSomethingElse();  // Two spaces before line comments normally.
}
std::vector&lt;string&gt; list{
                    // Comments in braced lists describe the next element...
                    &quot;First item&quot;,
                    // .. and should be aligned appropriately.
&quot;Second item&quot;};
DoSomething(); /* For trailing block comments, one space is fine. */
</code></pre>
<p><strong>函数参数注释</strong></p>
<p><strong>如果函数参数的意义不明显</strong>, 考虑用下面的方式进行弥补:</p>
<ol>
<li>如果参数是一个字面常量, 并且这一常量在多处函数调用中被使用, 用以推断它们一致, 你应当用一个常量名让这一约定变得更明显, 并且保证这一约定不会被打破.</li>
<li><strong>考虑更改函数的签名, 让某个 bool 类型的参数变为 enum 类型, 这样可以让这个参数的值表达其意义</strong>.</li>
<li><strong>如果某个函数有多个配置选项, 你可以考虑定义一个类或结构体以保存所有的选项, 并传入类或结构体的实例</strong>. 这样的方法有许多优点, 例如这样的选项可以在调用处用变量名引用, 这样就能清晰地表明其意义. 同时也减少了函数参数的数量, 使得函数调用更易读也易写. 除此之外, 以这样的方式, 如果你使用其他的选项, 就无需对调用点进行更改.</li>
<li>用具名变量代替大段而复杂的嵌套表达式.</li>
<li>万不得已时, 才考虑在调用点用注释阐明参数的意义.</li>
</ol>
<p>比如下面的示例的对比:</p>
<pre><code>// What are these arguments?
const DecimalNumber product = CalculateProduct(values, 7, false, nullptr);
</code></pre>
<p>和</p>
<pre><code>ProductOptions options;
options.set_precision_decimals(7);
options.set_use_cache(ProductOptions::kDontUseCache);
const DecimalNumber product =
    CalculateProduct(values, options, /*completion_callback=*/nullptr);
</code></pre>
<p>哪个更清晰一目了然.</p>
<p><strong>不允许的行为</strong></p>
<p>  <strong>不要描述显而易见的现象, 永远不要 用自然语言翻译代码作为注释</strong>, 除非即使对深入理解 C++ 的读者来说代码的行为都是不明显的. <strong>要假设读代码的人 C++ 水平比你高, 即便他/她可能不知道你的用意</strong>:</p>
<p>  <strong>你所提供的注释应当解释代码 为什么 要这么做和代码的目的, 或者最好是让代码自文档化</strong>.</p>
<p>比较这样的注释:</p>
<pre><code>// Find the element in the vector.  &lt;-- 差: 这太明显了!
auto iter = std::find(v.begin(), v.end(), element);
if (iter != v.end()) {
  Process(element);
}
</code></pre>
<p>和这样的注释:</p>
<pre><code>// Process &quot;element&quot; unless it was already processed.
auto iter = std::find(v.begin(), v.end(), element);
if (iter != v.end()) {
  Process(element);
}
</code></pre>
<p>  自文档化的代码根本就不需要注释. 上面例子中的注释对下面的代码来说就是毫无必要的:</p>
<pre><code>if (!IsAlreadyProcessed(element)) {
  Process(element);
}
</code></pre>
<h3 id="87-标点-拼写和语法">8.7. 标点, 拼写和语法</h3>
<p><strong>总述</strong></p>
<p>  注意标点, 拼写和语法; 写的好的注释比差的要易读的多.</p>
<p><strong>说明</strong></p>
<p>  注释的通常写法是包含正确大小写和结尾句号的完整叙述性语句. 大多数情况下, 完整的句子比句子片段可读性更高. 短一点的注释, 比如代码行尾注释, 可以随意点, 但依然要注意风格的一致性.</p>
<p>  虽然被别人指出该用分号时却用了逗号多少有些尴尬, 但清晰易读的代码还是很重要的. 正确的标点, 拼写和语法对此会有很大帮助.</p>
<h3 id="88-todo-注释">8.8. TODO 注释</h3>
<p><strong>总述</strong></p>
<p>  <strong>对那些临时的, 短期的解决方案, 或已经够好但仍不完美的代码使用 TODO 注释</strong>.</p>
<p>  TODO 注释要使用<strong>全大写的字符串 TODO, 在随后的圆括号里写上你的名字, 邮件地址, bug ID, 或其它身份标识和与这一 TODO 相关的 issue</strong>. 主要目的是让添加注释的人 (也是可以请求提供更多细节的人) 可根据规范的 TODO 格式进行查找. 添加 TODO 注释并不意味着你要自己来修正, 因此当你加上带有姓名的 TODO 时, 一般都是写上自己的名字.</p>
<pre><code>// TODO(kl@gmail.com): Use a &quot;*&quot; here for concatenation operator.
// TODO(Zeke) change this to use relations.
// TODO(bug 12345): remove the &quot;Last visitors&quot; feature
</code></pre>
<p>  如果加 TODO 是为了在 “将来某一天做某事”, 可以附上一个非常明确的时间 “Fix by November 2005”), 或者一个明确的事项 (“Remove this code when all clients can handle XML responses.”).</p>
<h3 id="89-弃用注释">8.9. 弃用注释</h3>
<p><strong>总述</strong></p>
<p>  <strong>通过弃用注释（DEPRECATED comments）以标记某接口点已弃用.</strong></p>
<p>  您可以写上包含全大写的 DEPRECATED 的注释, 以标记某接口为弃用状态. 注释可以放在接口声明前, 或者同一行.</p>
<p>  在 DEPRECATED 一词后, 在括号中留下您的名字, 邮箱地址以及其他身份标识.</p>
<p>  <strong>弃用注释应当包涵简短而清晰的指引, 以帮助其他人修复其调用点</strong>. 在 C++ 中, <strong>你可以将一个弃用函数改造成一个内联函数, 这一函数将调用新的接口</strong>.</p>
<p>  仅仅标记接口为 DEPRECATED 并不会让大家不约而同地弃用, 您还得亲自主动修正调用点（callsites）, 或是找个帮手.</p>
<p>  修正好的代码应该不会再涉及弃用接口点了, 着实改用新接口点. 如果您不知从何下手, 可以找标记弃用注释的当事人一起商量.</p>
<h3 id="译者笔记">译者笔记</h3>
<ol>
<li>关于注释风格, 很多 C++ 的 coders 更喜欢行注释, C coders 或许对块注释依然情有独钟, 或者在文件头大段大段的注释时使用块注释;</li>
<li>文件注释可以炫耀你的成就, 也是为了捅了篓子别人可以找你;</li>
<li>注释要言简意赅, 不要拖沓冗余, 复杂的东西简单化和简单的东西复杂化都是要被鄙视的;</li>
<li>对于 Chinese coders 来说, 用英文注释还是用中文注释, it is a problem, 但不管怎样, 注释是为了让别人看懂, 难道是为了炫耀编程语言之外的你的母语或外语水平吗；</li>
<li>注释不要太乱, 适当的缩进才会让人乐意看. 但也没有必要规定注释从第几列开始 (我自己写代码的时候总喜欢这样), UNIX/LINUX 下还可以约定是使用 tab 还是 space, 个人倾向于 space;</li>
<li>TODO 很不错, 有时候, 注释确实是为了标记一些未完成的或完成的不尽如人意的地方, 这样一搜索, 就知道还有哪些活要干, 日志都省了.</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[7. 命名约定 -Google C++编程规范]]></title>
        <id>https://lixin-scut.github.io//post/7-ming-ming-yue-ding-google-cbian-cheng-gui-fan</id>
        <link href="https://lixin-scut.github.io//post/7-ming-ming-yue-ding-google-cbian-cheng-gui-fan">
        </link>
        <updated>2020-04-30T14:54:12.000Z</updated>
        <content type="html"><![CDATA[<h3 id="71-通用命名规则">7.1. 通用命名规则</h3>
<p><strong>总述</strong></p>
<p>  函数命名, 变量命名, 文件命名要有描述性; 少用缩写.</p>
<p><strong>说明</strong></p>
<p>  尽可能使用描述性的命名, 别心疼空间, 毕竟相比之下让代码易于新读者理解更重要. 不要用只有项目开发者能理解的缩写, 也不要通过砍掉几个字母来缩写单词.</p>
<pre><code>int price_count_reader;    // 无缩写
int num_errors;            // &quot;num&quot; 是一个常见的写法
int num_dns_connections;   // 人人都知道 &quot;DNS&quot; 是什么
</code></pre>
<pre><code>int n;                     // 毫无意义.
int nerr;                  // 含糊不清的缩写.
int n_comp_conns;          // 含糊不清的缩写.
int wgc_connections;       // 只有贵团队知道是什么意思.
int pc_reader;             // &quot;pc&quot; 有太多可能的解释了.
int cstmr_id;              // 删减了若干字母.
</code></pre>
<p>  注意, 一些特定的广为人知的缩写是允许的, 例如<strong>用 i 表示迭代变量和用 T 表示模板参数.</strong></p>
<p>  模板参数的命名应当遵循对应的分类: <strong>类型模板参数</strong>应当遵循 <strong>类型命名 的规则</strong>, 而<strong>非类型模板</strong>应当遵循 <strong>变量命名 的规则</strong>.</p>
<h3 id="72-文件命名">7.2. 文件命名</h3>
<p><strong>总述</strong></p>
<p>  <strong>文件名要全部小写</strong>, 可以包含下划线 (<code>_</code>) 或连字符 (<code>-</code>), 依照项目的约定. 如果没有约定, 那么 “<code>_</code>” 更好.</p>
<p><strong>说明</strong></p>
<p>可接受的文件命名示例:</p>
<ol>
<li>my_useful_class.cc</li>
<li>my-useful-class.cc</li>
<li>myusefulclass.cc</li>
<li>myusefulclass_test.cc // <code>_unittest</code> 和 <code>_regtest</code> 已弃用.</li>
</ol>
<p>  C++ 文件要以 .cc 结尾, 头文件以 .h 结尾. 专门插入文本的文件则以 .inc 结尾, 参见 头文件自足.</p>
<p>  不要使用已经存在于 /usr/include 下的文件名 (Yang.Y 注: 即编译器搜索系统头文件的路径), 如 db.h.</p>
<p>  通常应尽量让文件名更加明确. http_server_logs.h 就比 logs.h 要好. 定义类时文件名一般成对出现, 如 foo_bar.h 和 foo_bar.cc, 对应于类 FooBar.</p>
<p>  内联函数必须放在 .h 文件中. 如果内联函数比较短, 就直接放在 .h 中.</p>
<h3 id="73-类型命名">7.3. 类型命名</h3>
<p><strong>总述</strong></p>
<p>  <strong>类型名称的每个单词首字母均大写（最典型就是类）</strong>, 不包含下划线: <code>MyExcitingClass</code>,<code>MyExcitingEnum</code>.</p>
<p><strong>说明</strong></p>
<p>  所有类型命名 —— 类, 结构体, 类型定义 (typedef), 枚举, 类型模板参数 —— 均使用相同约定, 即以大写字母开始, 每个单词首字母均大写, 不包含下划线. 例如:</p>
<pre><code>// 类和结构体
class UrlTable { ...
class UrlTableTester { ...
struct UrlTableProperties { ...

// 类型定义
typedef hash_map&lt;UrlTableProperties *, string&gt; PropertiesMap;

// using 别名
using PropertiesMap = hash_map&lt;UrlTableProperties *, string&gt;;

// 枚举
enum UrlTableErrors { ...
</code></pre>
<h3 id="74-变量命名">7.4. 变量命名</h3>
<p><strong>总述</strong></p>
<p>  变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾, 但结构体的就不用, 如: a_local_variable, a_struct_data_member, a_class_data_member_.</p>
<p><strong>说明</strong></p>
<p><strong>普通变量命名</strong></p>
<p>举例:</p>
<pre><code>string table_name;  // 好 - 用下划线.
string tablename;   // 好 - 全小写.

string tableName;  // 差 - 混合大小写
</code></pre>
<p><strong>类数据成员</strong></p>
<p>  不管是静态的还是非静态的, <strong>类数据成员都可以和普通变量一样, 但要接下划线.</strong></p>
<pre><code>class TableInfo {
  ...
 private:
  string table_name_;  // 好 - 后加下划线.
  string tablename_;   // 好.
  static Pool&lt;TableInfo&gt;* pool_;  // 好.
};
</code></pre>
<p><strong>结构体变量</strong></p>
<p>  不管是静态的还是非静态的, <strong>结构体数据成员都可以和普通变量一样, 不用像类那样接下划线:</strong></p>
<pre><code>struct UrlTableProperties {
  string name;
  int num_entries;
  static Pool&lt;UrlTableProperties&gt;* pool;
};
</code></pre>
<p>  结构体与类的使用讨论, 参考 结构体 vs. 类.</p>
<h3 id="75-常量命名">7.5. 常量命名</h3>
<p><strong>总述</strong></p>
<p>  声明为 <code>constexpr</code> 或 <code>const</code> 的变量, 或在程序运行期间其值始终保持不变的, <strong>命名时以 “k” 开头, 大小写混合</strong>. 例如:</p>
<p><code>const int kDaysInAWeek = 7;</code></p>
<p><strong>说明</strong></p>
<p>  所有具有静态存储类型的变量 (例如<strong>静态变量或全局变量</strong>, 参见 存储类型) <strong>都应当以此方式命名</strong>. 对于其他存储类型的变量, 如自动变量等, 这条规则是可选的. 如果不采用这条规则, 就按照一般的变量命名规则.</p>
<h3 id="76-函数命名">7.6. 函数命名</h3>
<p><strong>总述</strong></p>
<p>  <strong>常规函数使用大小写混合, 取值和设值函数则要求与变量名匹配:</strong></p>
<pre><code>MyExcitingFunction();
MyExcitingMethod();
my_exciting_member_variable(); 
set_my_exciting_member_variable();
</code></pre>
<p><strong>说明</strong></p>
<p>  一般来说, 函数名的<strong>每个单词首字母大写</strong> (即 “驼峰变量名” 或 “帕斯卡变量名”), <strong>没有下划线</strong>. 对于首字母缩写的单词, 更倾向于将它们视作一个单词进行首字母大写 (例如, 写作 StartRpc() 而非 StartRPC()).</p>
<pre><code>AddTableEntry()
DeleteUrl()
OpenFileOrDie()
</code></pre>
<p>(同样的命名规则<strong>同时适用于类作用域与命名空间作用域的常量</strong>, 因为它们是作为 API 的一部分暴露对外的, 因此应当让它们看起来像是一个函数, 因为在这时, 它们实际上是一个对象而非函数的这一事实对外不过是一个无关紧要的实现细节.)</p>
<p>  <strong>取值和设值函数的命名与变量一致. 一般来说它们的名称与实际的成员变量对应</strong>, 但并不强制要求. 例如 int count() 与 void set_count(int count).</p>
<h3 id="77-命名空间命名">7.7. 命名空间命名</h3>
<p><strong>总述</strong></p>
<p>  命名空间以小写字母命名. 最高级命名空间的名字取决于项目名称. 要注意避免嵌套命名空间的名字之间和常见的顶级命名空间的名字之间发生冲突.</p>
<p>  顶级命名空间的名称应当是项目名或者是该命名空间中的代码所属的团队的名字. 命名空间中的代码, 应当存放于和命名空间的名字匹配的文件夹或其子文件夹中.</p>
<p>  注意 不使用缩写作为名称 的规则同样适用于命名空间. 命名空间中的代码极少需要涉及命名空间的名称, 因此没有必要在命名空间中使用缩写.</p>
<p>  要避免嵌套的命名空间与常见的顶级命名空间发生名称冲突. 由于名称查找规则的存在, 命名空间之间的冲突完全有可能导致编译失败. 尤其是, 不要创建嵌套的 std 命名空间. 建议使用更独特的项目标识符 (websearch::index, websearch::index_util) 而非常见的极易发生冲突的名称 (比如 websearch::util).</p>
<p>  对于 internal 命名空间, 要当心加入到同一 internal 命名空间的代码之间发生冲突 (由于内部维护人员通常来自同一团队, 因此常有可能导致冲突). 在这种情况下, 请使用文件名以使得内部名称独一无二 (例如对于 frobber.h, 使用 websearch::index::frobber_internal).</p>
<h3 id="78-枚举命名">7.8. 枚举命名</h3>
<p><strong>总述</strong></p>
<p>  <strong>枚举的命名应当和 常量 或 宏 一致: kEnumName 或是 ENUM_NAME.</strong></p>
<p><strong>说明</strong></p>
<p>  <strong>单独的枚举值应该优先采用 常量 的命名方式</strong>. 但 宏 方式的命名也可以接受. 枚举名 UrlTableErrors (以及 AlternateUrlTableErrors) 是类型, 所以要用大小写混合的方式.</p>
<pre><code>enum UrlTableErrors {
    kOK = 0,
    kErrorOutOfMemory,
    kErrorMalformedInput,
};
enum AlternateUrlTableErrors {
    OK = 0,
    OUT_OF_MEMORY = 1,
    MALFORMED_INPUT = 2,
};
</code></pre>
<p>  2009 年 1 月之前, 我们一直建议采用 宏 的方式命名枚举值. 由于枚举值和宏之间的命名冲突, 直接导致了很多问题. 由此, 这里改为<strong>优先选择常量风格的命名方式. 新代码应该尽可能优先使用常量风格</strong>. 但是老代码没必要切换到常量风格, 除非宏风格确实会产生编译期问题.</p>
<h3 id="79-宏命名">7.9. 宏命名</h3>
<p><strong>总述</strong></p>
<p>  你并不打算 使用宏, 对吧? 如果你一定要用, 像这样命名: <strong>MY_MACRO_THAT_SCARES_SMALL_CHILDREN.</strong></p>
<p><strong>说明</strong></p>
<p>  参考 预处理宏; <strong>通常 不应该 使用宏. 如果不得不用, 其命名像枚举命名一样全部大写, 使用下划线</strong>:</p>
<pre><code>#define ROUND(x) ...
#define PI_ROUNDED 3.0
</code></pre>
<h3 id="710-命名规则的特例">7.10. 命名规则的特例</h3>
<p><strong>总述</strong></p>
<p>如果你命名的实体与已有 C/C++ 实体相似, 可参考现有命名策略.</p>
<p>bigopen(): 函数名, 参照 open() 的形式</p>
<p>uint: typedef</p>
<p>bigpos: struct 或 class, 参照 pos 的形式</p>
<p>sparse_hash_map: STL 型实体; 参照 STL 命名约定</p>
<p>LONGLONG_MAX: 常量, 如同 INT_MAX</p>
<p>译者笔记</p>
<ol>
<li>感觉 Google 的命名约定很高明, 比如写了简单的类 QueryResult, 接着又可以直接定义一个变量 query_result, 区分度很好; 再次, 类内变量以下划线结尾, 那么就可以直接传入同名的形参, 比如 TextQuery::TextQuery(std::string word) : word_(word) {} , 其中 word_ 自然是类内私有成员.</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[并查集 547. 朋友圈[中等]]]></title>
        <id>https://lixin-scut.github.io//post/bing-cha-ji-547-peng-you-quan-zhong-deng</id>
        <link href="https://lixin-scut.github.io//post/bing-cha-ji-547-peng-you-quan-zhong-deng">
        </link>
        <updated>2020-04-29T15:23:01.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。<br>
给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。<br>
示例 1:<br>
输入:<br>
[[1,1,0],<br>
[1,1,0],<br>
[0,0,1]]<br>
输出: 2<br>
说明：已知学生0和学生1互为朋友，他们在一个朋友圈。<br>
第2个学生自己在一个朋友圈。所以返回2。<br>
示例 2:<br>
输入:<br>
[[1,1,0],<br>
[1,1,1],<br>
[0,1,1]]<br>
输出: 1<br>
说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。<br>
注意：<br>
N 在[1,200]的范围内。<br>
对于所有学生，有M[i][i] = 1。<br>
如果有M[i][j] = 1，则有M[j][i] = 1。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/friend-circles<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>一开始我的想法比较秀<br>
直接用一个栈保存当前所有“朋友”下标，然后把相应的列全部置0，每个大循环才把ans加一。缺点就是会导致很多没必要的重复循环，改进的方法可以用一个bool的vector保存状态，直接置false的话避免没必要的循环。</p>
<p>然后看了题解发现是并查集，刚好借助这一题来学习一下并查集吧<br>
核心API就是 union()、find()、connect()和count()这三个成员函数和counts、parents[n]、sizes[n]这三个数据成员</p>
<pre><code>class Solution {
public:
		// 并查集
    int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M)
    {
        counts = M.size();
        for(int i = 0; i &lt; M.size(); ++i)
        {
            parents.push_back(i);
            sizes.push_back(1);
        }
        
        for(int i = 0; i &lt; M.size(); ++i)
        {
            for(int j = i+1; j &lt; M.size(); ++j)
            {
                if(M[i][j] == 1)
                {
                    unionM(i,j);
                }
            }
        }
        return counts;
    }
    
    void unionM(int p, int q)
    {
        int rootP = find(p);
        int rootQ = find(q);
        if(rootP == rootQ)
        {   return ; }
        
        if(sizes[rootP] &lt; sizes[rootQ])
        {
            parents[rootP] = rootQ;
            sizes[rootQ] += sizes[rootP];
        }
        else
        {
            parents[rootQ] = rootP;
            sizes[rootP] += sizes[rootQ];
        }
              
        --counts;
        return;    
    }
    
    int find(int x)
    {
        while(x != parents[x])
        {
            parents[x] = parents[parents[x]];
            x= parents[x];
        }
        return x;
    }
    
    bool connected(int p ,int q)
    {
        int rootP = find(p);
        int rootQ = find(q);
        return (rootP == rootQ);
    }
    
    int count()
    {
        return counts;
    }
    
private:
    int counts;
    vector&lt;int&gt; parents;
    vector&lt;int&gt; sizes;
    
    // DFS
    /*
    int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) {
        int ans = 0;
        stack&lt;int&gt; friends;
        for(int i = 0; i &lt; M.size(); ++i)
        {
            if(M[i][i] == 1)
            {
                ++ans;
                M[i][i] = 0;
            }
            friends.push(i);
            while(!friends.empty())
            {
                int index = friends.top();
                friends.pop();
                for(int j = 0; j &lt; M.size(); ++j)
                {
                    if(index != j)
                    {
                        if(M[index][j] == 1)
                        {
                            friends.push(j);  
                        }
                    }
                    M[index][j] = 0;
                }
            }

        }
        return ans;
    }
    */
};
</code></pre>
<p>题解比较长，就不强行贴上来了，可直接查看<a href="https://leetcode-cn.com/problems/friend-circles/solution/union-find-suan-fa-xiang-jie-by-labuladong/">Union-Find 算法详解</a></p>
<p>核心思想：<br>
我们的 Union-Find 算法主要需要实现这两个 API：</p>
<pre><code>class UF {
    /* 将 p 和 q 连接 */
    public void union(int p, int q);
    /* 判断 p 和 q 是否连通 */
    public boolean connected(int p, int q);
    /* 返回图中有多少个连通分量 */
    public int count();
		
		// 记录连通分量
    private int count;
    // 节点 x 的节点是 parent[x]
    private int[] parent;

    /* 构造函数，n 为图的节点总数 */
    public UF(int n) {
        // 一开始互不连通
        this.count = n;
        // 父节点指针初始指向自己
        parent = new int[n];
        for (int i = 0; i &lt; n; i++)
            parent[i] = i;
    }

}
</code></pre>
<p>如果某两个节点被连通，则让其中的（任意）一个节点的根节点接到另一个节点的根节点上：</p>
<pre><code>public void union(int p, int q) {
    int rootP = find(p);
    int rootQ = find(q);
    if (rootP == rootQ)
        return;
    // 将两棵树合并为一棵
    parent[rootP] = rootQ;
    // parent[rootQ] = rootP 也一样
    count--; // 两个分量合二为一
}

/* 返回某个节点 x 的根节点 */
private int find(int x) {
    // 根节点的 parent[x] == x
    while (parent[x] != x)
        x = parent[x];
    return x;
}

/* 返回当前的连通分量个数 */
public int count() { 
    return count;
}
</code></pre>
<p>这样，如果节点p和q连通的话，它们一定拥有相同的根节点：</p>
<pre><code>public boolean connected(int p, int q) {
    int rootP = find(p);
    int rootQ = find(q);
    return rootP == rootQ;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math 60. 第k个排列[中等]]]></title>
        <id>https://lixin-scut.github.io//post/math-60-di-k-ge-pai-lie-zhong-deng</id>
        <link href="https://lixin-scut.github.io//post/math-60-di-k-ge-pai-lie-zhong-deng">
        </link>
        <updated>2020-04-29T12:57:12.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。<br>
按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：<br>
&quot;123&quot;<br>
&quot;132&quot;<br>
&quot;213&quot;<br>
&quot;231&quot;<br>
&quot;312&quot;<br>
&quot;321&quot;<br>
给定 n 和 k，返回第 k 个排列。<br>
说明：<br>
给定 n 的范围是 [1, 9]。<br>
给定 k 的范围是[1,  n!]。<br>
示例 1:<br>
输入: n = 3, k = 3<br>
输出: &quot;213&quot;<br>
示例 2:<br>
输入: n = 4, k = 9<br>
输出: &quot;2314&quot;<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/permutation-sequence<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>最简单的话就是回溯穷举法了，但是很明显应该是有规律的</p>
<p>首先我们将其视为一个迭代的选择过程，有n层迭代，每层选择上一层没选择过的数字，所以我引入了used的bool数组<br>
然后可以固定每一位上数字的时候，它所处的范围都是固定的，<br>
比如123中 如果选定首位为2，那它至少是3起步的，最多为4的，因为选定首位为1的时候可能的数有两个</p>
<p>然后每一层的可能性数量刚好是<code>(n-1)*(n-2)*...*1</code>,所以流程如下</p>
<ol>
<li>int num = (k - 1) / counts ; counts为当前位数的可能性个数（比如第一位可能性共有6个）算出第一位所需的used的第num+1个数字</li>
<li>然后注意index初始化为-1（受num+1影响），然后记得将j赋给index</li>
<li>赋值并修改used状态</li>
<li>k -= num * counts;减去当前位数所占的数字，然后重复上述步骤计算剩余位</li>
<li>最后一位比较特殊，因为k=0的时候k-1得不到我们想要的结果，所以直接寻找used数组中唯一为true的位数，赋值即可</li>
</ol>
<p>其实很多地方可以优化的，很明显的一个就是我完全可以用vector保存1234...n，然后每次取出然后erase，但是erase存在内存搬移，本质上时间复杂度变化，主要还是代码更加简洁，但是暂时无头绪如何优化，先看看题解</p>
<pre><code>class Solution {
public:
    string getPermutation(int n, int k) {
        string ans ;
        vector&lt;bool&gt; used(n, true);
        int counts = 1;
        for(int i = 1; i &lt; n; ++i)
        {
            counts *= i;
        }
        
        
        
        for(int i = 0; i &lt; n; ++i)
        {
            if(i &lt; n - 1)
            {
                int num = (k - 1) / counts ;
                int index = -1;
                for(int j = 0;j &lt; n; ++j)
                {
                    if(used[j])
                    {
                        ++index;
                        if(index == num)
                        {
                            index = j;
                            break;
                        }
                    }   
                }
                ans.push_back('1' + index);
                used[index] = false;
            
                k -= num * counts;
                
                counts /= (n - i - 1);
            }
            else
            {
                int j = 0;
                for(; j &lt; n ; ++j)
                {
                    if(used[j])
                    {
                        break;
                    }
                }       
                ans.push_back('1' + j);
            }
        }
        
        return ans;
    }
};
</code></pre>
<p>网友题解比较精彩， 不过主体也是利用容器保存123...n，然后逐步erase，然后就是回溯法吧</p>
<blockquote>
<p>深度优先遍历 + 剪枝、双链表模拟<br>
思路分析：<br>
比较容易想到的是，使用同「力扣」第 46 题： “全排列” ，即使用回溯搜索的思想，依次得到全排列，输出所求的第 k 个全排列即可。但事实上，我们不必求出所有的全排列。基于以下几点考虑：<br>
1、我们知道所求排列一定在叶子结点处得到。事实上，进入每一个分支的时候，我们都可以通过递归的层数，直接计算这一分支可以得到的叶子结点的个数；<br>
这是因为：进入一个分支的时候，我们可以根据已经选定的数的个数，进而确定还未选定的数的个数，然后计算阶乘，就知道这一个分支的叶子结点有多少个。<br>
2、如果 k 大于这一个分支将要产生的叶子结点数，直接跳过这个分支，这个操作叫“剪枝”；<br>
3、如果k 小于等于这一个分支将要产生的叶子结点数，那说明所求的全排列一定在这一个分支将要产生的叶子结点里，需要递归求解；<br>
4、计算阶乘的时候，你可以使用循环计算，特别注意：0!=1，它表示了没有数可选的时候，即表示到达叶子结点了，排列数只剩下 1 个；<br>
又因为题目中说“给定 n 的范围是 [1,9]，故可以实现把从 0 到 9 的阶乘计算好，放在一个数组里，可以根据索引直接获得阶乘值，见文后“代码 2”。<br>
方法一：借助“回溯”方法中的“剪枝”技巧</p>
</blockquote>
<pre><code>import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Solution {

    /**
     * 记录数字是否使用过
     */
    private boolean[] used;

    /**
     * 阶乘数组
     */
    private int[] factorial;

    private int n;
    private int k;
    /**
     * 从根结点到叶子结点的路径
     */
    private List&lt;Integer&gt; path;

    public String getPermutation(int n, int k) {
        this.n = n;
        this.k = k;
        used = new boolean[n + 1];
        Arrays.fill(used, false);

        // 计算阶乘数组
        factorial = new int[n + 1];
        factorial[0] = 1;
        for (int i = 1; i &lt;= n; i++) {
            factorial[i] = factorial[i - 1] * i;
        }

        path = new ArrayList&lt;&gt;(n);
        dfs(0);

        StringBuilder stringBuilder = new StringBuilder();
        for (Integer c : path) {
            stringBuilder.append(c);
        }
        return stringBuilder.toString();
    }

    /**
     * @param index 在这一步之前已经选择了几个数字，其值恰好等于这一步需要确定的索引位置
     * @return
     */
    private void dfs(int index) {
        if (index == n) {
            return;
        }

        // 还未确定的数字的全排列的个数，第 1 次进入的时候是 n - 1
        int cnt = factorial[n - 1 - index];
        for (int i = 1; i &lt;= n; i++) {
            if (used[i]) {
                continue;
            }
            if (cnt &lt; k) {
                k -= cnt;
                continue;
            }
            path.add(i);
            used[i] = true;
            dfs(index + 1);
        }
    }
}
</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(N<sup>2)，最坏肯定是要找到第N！个，但是第1层只需要比较N-1次，第2层比较N-2次，以此类推，所以最坏是O(N</sup>2)。<br>
空间复杂度：O(N)，nums、used、pre 都与 N 等长，factorial 数组就 10 个数，是常数级别的。</p>
</blockquote>
<blockquote>
<p>方法二：双链表模拟<br>
事实上，上面的过程也可以循环实现，只不过需要借助一个列表，每次选出一个数，就将这个数从列表里面拿出。因为这个列表要支持频繁的删除操作，因此使用双链表，在 Java 中 LinkedList 就是使用双链表实现的。</p>
</blockquote>
<pre><code>import java.util.LinkedList;
import java.util.List;

public class Solution {

    public String getPermutation(int n, int k) {
        // 注意：相当于在 n 个数字的全排列中找到索引为 k - 1 的那个数，因此 k 先减 1
        k --;

        int[] factorial = new int[n];
        factorial[0] = 1;
        // 先算出所有的阶乘值
				//  {0,1,2,6,24,120,720,5040,40320,362880,3628800};
        for (int i = 1; i &lt; n; i++) {
            factorial[i] = factorial[i - 1] * i;
        }

        // 因为要频繁做删除，使用链表
        List&lt;Integer&gt; nums = new LinkedList&lt;&gt;();
        for (int i = 1; i &lt;= n; i++) {
            nums.add(i);
        }

        StringBuilder stringBuilder = new StringBuilder();

        // i 表示剩余的数字个数，初始化为 n - 1
        for (int i = n - 1; i &gt;= 0; i--) {
            int index = k / factorial[i] ;
            stringBuilder.append(nums.remove(index));
            k -= index * factorial[i];
        }
        return stringBuilder.toString();
    }
}
</code></pre>
<p>贴一个C++版</p>
<pre><code>class Solution {
    static const vector&lt;int&gt; fac;
public:
    string getPermutation(int n, int k) {
        string res;
        string s = string(&quot;123456789&quot;).substr(0, n);
        --k;
        while(k &gt; 0)
        {
            size_t i = k/fac[n - 1];
            res.push_back(s[i]);
            s.erase(s.begin() + i);
            k %= fac[n - 1];
            --n;
        }
        return res + s;
    }
};
const vector&lt;int&gt; Solution::fac = {0,1,2,6,24,120,720,5040,40320,362880,3628800};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL 175. 组合两个表[简单]]]></title>
        <id>https://lixin-scut.github.io//post/mysql-175-zu-he-liang-ge-biao-jian-dan</id>
        <link href="https://lixin-scut.github.io//post/mysql-175-zu-he-liang-ge-biao-jian-dan">
        </link>
        <updated>2020-04-29T07:26:44.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>表1: Person<br>
+-------------+---------+<br>
| 列名         | 类型     |<br>
+-------------+---------+<br>
| PersonId    | int     |<br>
| FirstName   | varchar |<br>
| LastName    | varchar |<br>
+-------------+---------+<br>
PersonId 是上表主键<br>
表2: Address<br>
+-------------+---------+<br>
| 列名         | 类型    |<br>
+-------------+---------+<br>
| AddressId   | int     |<br>
| PersonId    | int     |<br>
| City        | varchar |<br>
| State       | varchar |<br>
+-------------+---------+<br>
AddressId 是上表主键<br>
 编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：<br>
FirstName, LastName, City, State<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/combine-two-tables<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题比较简单，重点在于“无论 person 是否有地址信息”，主要就是默认的inner join和outer join的区别，并且还有on和where的区别</p>
<pre><code>SELECT FirstName, LastName, City, State
FROM Person LEFT OUTER JOIN Address
ON Person.PersonId = Address.PersonId
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>方法：使用 outer join<br>
算法<br>
因为表 Address 中的 personId 是表 Person 的外关键字，所以我们可以连接这两个表来获取一个人的地址信息。<br>
考虑到可能不是每个人都有地址信息，我们应该使用 outer join 而不是默认的 inner join。</p>
</blockquote>
<pre><code>MySQL
select FirstName, LastName, City, State
from Person left join Address
on Person.PersonId = Address.PersonId
;
</code></pre>
<p><strong>注意：如果没有某个人的地址信息，使用 where 子句过滤记录将失败，因为它不会显示姓名信息。</strong></p>
<p><strong>《MySQL必知必会》相关知识点</strong><br>
  MySQL的联结表默认为内部联结或等值联结(equijoin)的简单联结，另外三种联结分别是自联结、自然联结和外部联结。</p>
<p><strong>自联结</strong><br>
  自联结就是同一个表联结起来，需要配合表别名使用，使用表别名的主要原因之一是能在单条SELECT语句中不止一次引用相同的表</p>
<p>  自联结可以解决子查询的问题： 自联结通常作为外部语句用来替代 从相同表中检索数据时使用的子查询语句。虽然最终的结果是 相同的，但有时候处理联结远比处理子查询快得多。应该试一 下两种方法，以确定哪一种的性能更好</p>
<p><strong>自然联结</strong><br>
  标准的联结(前一章中介绍的内部联结)返回所有数据，甚 至相同的列多次出现。自然联结排除多次出现，使每个列只返回一次。<br>
  但是系统不完成这项工作，由你自己完成它。自然联结是这样一种联结，其中你只能选择那些唯一的列。这一 般是通过对表使用通配符(SELECT * )，对所有其他表的列使用明确的子 集来完成的。</p>
<p>  事实上，迄今为止我们默认建立的每个内部联结都是自然联结，很可能我们永远都不会用到不是自然联结的内部联结。</p>
<p><strong>外部联结</strong><br>
  联结包含了那些在相关表中没有关联行的行。这种 类型的联结称为外部联结。<br>
  许多联结将一个表中的行与另一个表中的行相关联。但有时候会需要包含没有关联行的那些行。<br>
  在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字 指定包括其所有行的表(RIGHT指出的是OUTER JOIN右边的表，而LEFT 指出的是OUTER JOIN左边的表)。</p>
<p><strong>外部联结的类型</strong><br>
  存在两种基本的外部联结形式:左外部联结 和右外部联结。它们之间的唯一差别是所关联的表的顺序不 同。换句话说，左外部联结可通过颠倒FROM或WHERE子句中表的顺序转换为右外部联结。因此，两种类型的外部联结可互 换使用，而究竟使用哪一种纯粹是根据方便而定。</p>
<p>  使用LEFT OUTER JOIN从FROM子句的左边表中选择所有行。为了从右边的表中选择所有行，应该使用RIGHT OUTER JOIN</p>
<p>注意<br>
  没有<code>*=</code>操作符 MySQL不支持简化字符<code>*=</code>和<code>=*</code>的使用，这两 种操作符在其他DBMS中是很流行的。</p>
<p><strong>使用带聚集函数的联结</strong><br>
  聚集函数用来汇总数据。虽然至今为止聚集函数，但这些函数也可以与联结一起使用。<br>
  聚集函数也可以方便地与其他联结一起使用</p>
<p><strong>使用联结和联结条件</strong></p>
<ul>
<li><strong>注意所使用的联结类型。一般我们使用内部联结，但使用外部联结也是有效的。</strong></li>
<li>保证使用正确的联结条件，否则将返回不正确的数据。</li>
<li><strong>应该总是提供联结条件，否则会得出笛卡儿积。</strong></li>
<li>在一个联结中可以包含多个表，甚至对于每个联结可以采用不同的联结类型。虽然这样做是合法的，一般也很有用，但应该在一 起测试它们前，分别测试每个联结。这将使故障排除更为简单。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 71. 简化路径[中等]]]></title>
        <id>https://lixin-scut.github.io//post/zi-fu-chuan-71-jian-hua-lu-jing</id>
        <link href="https://lixin-scut.github.io//post/zi-fu-chuan-71-jian-hua-lu-jing">
        </link>
        <updated>2020-04-29T05:00:24.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。<br>
在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径<br>
请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。<br>
示例 1：<br>
输入：&quot;/home/&quot;<br>
输出：&quot;/home&quot;<br>
解释：注意，最后一个目录名后面没有斜杠。<br>
示例 2：<br>
输入：&quot;/../&quot;<br>
输出：&quot;/&quot;<br>
解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。<br>
示例 3：<br>
输入：&quot;/home//foo/&quot;<br>
输出：&quot;/home/foo&quot;<br>
解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。<br>
示例 4：<br>
输入：&quot;/a/./b/../../c/&quot;<br>
输出：&quot;/c&quot;<br>
示例 5：<br>
输入：&quot;/a/../../b/../c//.//&quot;<br>
输出：&quot;/c&quot;<br>
示例 6：<br>
输入：&quot;/a//b////c/d//././/..&quot;<br>
输出：&quot;/a/b/c&quot;<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/simplify-path<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>首先题意就是<br>
1.遇到/./直接消除<br>
2.遇到/../消除上一级</p>
<p>我想到一个比较便捷的方法hhh，直接用栈来保存，不管斜杠，直接保存文件目录名和.、..两种，遇到..就pop一下，.可以直接忽略，其他的直接入栈</p>
<p>实现中需要注意的问题</p>
<ol>
<li>所有判断条件都需要加上范围判断，防止访问到非法区域</li>
<li>先找到第一个非斜杠，再找第一个斜杠或者尾后区域</li>
<li>pop之前记得要先判断栈是否为空</li>
<li>因为不需要用到栈的特性加上需要从头访问，所以我用了vector而不是stack或者deque</li>
<li>最后的字符串很麻烦，首先如果是空的路径或者只有&quot;/../&quot;，就只能返回&quot;/&quot;</li>
<li>然后最后还必须把&quot;/&quot;去掉，所以只能按照i的位置来判断是否需要加。。。</li>
</ol>
<pre><code>class Solution {
public:
    string simplifyPath(string path) {
        vector&lt;string&gt; result;
        
        string folder;
        int beg = 0;
        int end = 0;
        int i = 0;
        while(i &lt; path.size())
        {
            while(i &lt; path.size() &amp;&amp; path[i] == '/')
            {
                ++i;
            }
            beg = i;
            while(i &lt; path.size() &amp;&amp; path[i] != '/')
            {
                ++i;
            }
            end = i;
            if(beg &lt; path.size() &amp;&amp; beg &lt; end)
            {
                folder = path.substr(beg, end - beg );
                if(folder == &quot;.&quot;)
                {  continue; }
                else if(folder == &quot;..&quot;)
                {
                    if(!result.empty())
                    {
                        result.pop_back();
                    }
                }
                else
                {
                    result.push_back(folder);
                }
            }
        }
        
        string ans = &quot;/&quot;;
        for(int i = 0; i &lt; result.size(); ++i)
        {
            ans += result[i] ;
            if(i != result.size() - 1)
            {   ans += &quot;/&quot;; } 
        }
        return ans;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 25. K 个一组翻转链表[困难]]]></title>
        <id>https://lixin-scut.github.io//post/lian-biao-25-k-ge-yi-zu-fan-zhuan-lian-biao-kun-nan</id>
        <link href="https://lixin-scut.github.io//post/lian-biao-25-k-ge-yi-zu-fan-zhuan-lian-biao-kun-nan">
        </link>
        <updated>2020-04-29T04:42:52.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。<br>
k 是一个正整数，它的值小于或等于链表的长度。<br>
如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。<br>
示例：<br>
给你这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5<br>
当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5<br>
当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5<br>
说明：<br>
你的算法只能使用常数的额外空间。<br>
你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/reverse-nodes-in-k-group<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>首先想到的是链表反转，这个不难<br>
困难点在于传入函数的两个节点，因为链表反转后必须和前后两个节点进行一个重新链接，所以必须保存好前后两个节点。<br>
最后我是用的是辅助头节点+左开右闭的方式，亦即例如1-2-3-4-5，要反转3-4的时候，传入2和4作为辅助节点<br>
因为pre_node初始化的原因，我们可以把pre_node初始化为5，在循环中直接连接起来<br>
然后2的话必须手动和4连接起来<br>
注意我们必须提前保存3的节点，而不是cur_node节点4，因为反转后变为1-2-4-3，所以3刚好就是下一个需要传入的辅助节点</p>
<p>实现中需要注意的：</p>
<ol>
<li>注意函数中，结点值的指向的变化，最好是保留temp值用于赋值</li>
<li>防止出现循环链表</li>
</ol>
<pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        if(head == nullptr)
        {
            return head;
        }
        ListNode* virHead = new ListNode(-1);
        virHead-&gt;next = head;
        
        ListNode* begin = virHead;
        ListNode* cur_node = begin;
        int index = 0;
        
        while(cur_node != nullptr)
        {
            cur_node = cur_node -&gt;next;
            ++index;
            if(cur_node != nullptr &amp;&amp; index == k)
            {
                ListNode* temp = begin-&gt;next;
                reverseList(begin, cur_node);
                begin = temp;
                cur_node = temp;
                index = 0;
            }
        }
        return virHead-&gt;next;
    }
    
    void reverseList(ListNode* begin, ListNode* end)
    {
        ListNode* pre_node = end-&gt;next;
        ListNode* cur_node = begin-&gt;next;
        ListNode* next_node = end;
        
        ListNode* last = end-&gt;next;
        
        while(cur_node != last)
        {
            next_node = cur_node-&gt;next;
            cur_node-&gt;next = pre_node;
            pre_node = cur_node;
            cur_node = next_node;
        }
        
        begin-&gt;next = pre_node;
    }
};
</code></pre>
<p>然后贴一个网友题解，他的是断开再重连，但是他说的时间复杂度我不是很赞同<br>
，我认为是O(2n)</p>
<blockquote>
<p>步骤分解:<br>
1.链表分区为已翻转部分+待翻转部分+未翻转部分<br>
2.每次翻转前，要确定翻转链表的范围，这个必须通过 k 此循环来确定<br>
3.需记录翻转链表前驱和后继，方便翻转完成后把已翻转部分和未翻转部分连接起来<br>
4.初始需要两个变量 pre 和 end，pre 代表待翻转链表的前驱，end 代表待翻转链表的末尾<br>
5.经过k此循环，end 到达末尾，记录待翻转链表的后继 next = end.next<br>
6.翻转链表，然后将三部分链表连接起来，然后重置 pre 和 end 指针，然后进入下一次循环<br>
7.特殊情况，当翻转部分长度不足 k 时，在定位 end 完成后，end==null，已经到达末尾，说明题目已完成，直接返回即可</p>
</blockquote>
<pre><code>public ListNode reverseKGroup(ListNode head, int k) {
    ListNode dummy = new ListNode(0);
    dummy.next = head;

    ListNode pre = dummy;
    ListNode end = dummy;

    while (end.next != null) {
        for (int i = 0; i &lt; k &amp;&amp; end != null; i++) end = end.next;
        if (end == null) break;
        ListNode start = pre.next;
        ListNode next = end.next;
        end.next = null;
        pre.next = reverse(start);
        start.next = next;
        pre = start;

        end = pre;
    }
    return dummy.next;
}

private ListNode reverse(ListNode head) {
    ListNode pre = null;
    ListNode curr = head;
    while (curr != null) {
        ListNode next = curr.next;
        curr.next = pre;
        pre = curr;
        curr = next;
    }
    return pre;
}
</code></pre>
]]></content>
    </entry>
</feed>