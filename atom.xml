<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-05-19T15:19:12.721Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>千里之行，始于足下。不积跬步，无以至千里。</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[链表 面试题 02.04. 分割链表[中等]]]></title>
        <id>https://lixin-scut.github.io//post/lian-biao-mian-shi-ti-0204-fen-ge-lian-biao-zhong-deng</id>
        <link href="https://lixin-scut.github.io//post/lian-biao-mian-shi-ti-0204-fen-ge-lian-biao-zhong-deng">
        </link>
        <updated>2020-05-19T00:45:04.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>编写程序以 x 为基准分割链表，使得所有小于 x 的节点排在大于或等于 x 的节点之前。如果链表中包含 x，x 只需出现在小于 x 的元素之后(如下所示)。分割元素 x 只需处于“右半部分”即可，其不需要被置于左右两部分之间。<br>
示例:<br>
输入: head = 3-&gt;5-&gt;8-&gt;5-&gt;10-&gt;2-&gt;1, x = 5<br>
输出: 3-&gt;1-&gt;2-&gt;10-&gt;5-&gt;5-&gt;8<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/partition-list-lcci<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题主要利用双头节点的做法，分别接上小于和大于等于的数字<br>
实现中需要注意的是</p>
<ol>
<li>既需要两个头节点，也需要两个当前节点</li>
<li>当前节点在最后一定要把next置为空节点，否则会造成无限循环</li>
</ol>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def partition(self, head: ListNode, x: int) -&gt; ListNode:
        less_than = ListNode(-1)
        larg_than = ListNode(-1)
        cur_less = less_than
        cur_larg = larg_than
        cur_node = head
        while cur_node != None:
            if cur_node.val &lt; x:
                cur_less.next = cur_node
                cur_less = cur_less.next
            else:
                cur_larg.next = cur_node
                cur_larg = cur_larg.next
            cur_node = cur_node.next
        cur_larg.next = None
        cur_less.next = None
        if less_than.next == None:
            return larg_than.next
        else:
            cur_less.next = larg_than.next
            return less_than.next
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 面试题 02.03 删除中间节点[简单]]]></title>
        <id>https://lixin-scut.github.io//post/lian-biao-mian-shi-ti-0203-shan-chu-zhong-jian-jie-dian-jian-dan</id>
        <link href="https://lixin-scut.github.io//post/lian-biao-mian-shi-ti-0203-shan-chu-zhong-jian-jie-dian-jian-dan">
        </link>
        <updated>2020-05-18T01:09:28.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>实现一种算法，删除单向链表中间的某个节点（即不是第一个或最后一个节点），假定你只能访问该节点。<br>
示例：<br>
输入：单向链表a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f中的节点c<br>
结果：不返回任何数据，但该链表变为a-&gt;b-&gt;d-&gt;e-&gt;f<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/delete-middle-node-lcci<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>看到这道题还是很感触的hhh，因为这道题就是我当年做leetcode遇到的第一道题，结果大半年过去了，我遇到这道题还是没看懂题意hhh，我还是想用的双指针，写完了才发现不对劲，怎么给的node，不是head呢？然后幡然醒悟hhh，然后就是比较简单了，直接把next的值给node，然后就可以删除next节点了，惯例记得判断node.next == None的情况</p>
<p>然后就是python的注释，可以用'''也可以用&quot;&quot;&quot;，似乎后者更加通用</p>
<pre><code>class Solution:
    def deleteNode(self, node):
        &quot;&quot;&quot;
        :type node: ListNode
        :rtype: void Do not return anything, modify node in-place instead.
        &quot;&quot;&quot;
        if node.next == None:
            return Node
        node.val = node.next.val
        node.next = node.next.next
        
        &quot;&quot;&quot;
        slow = node
        fast = node.next
        while fast != None and fast.next != None:
            slow = slow.next
            fast = fast.next.next
        if slow.next == None:
            return slow
        else:
            slow.next = slow.next.next
        return node
        &quot;&quot;&quot;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 面试题 02.02. 返回倒数第 k 个节点[简单]]]></title>
        <id>https://lixin-scut.github.io//post/lian-biao-mian-shi-ti-0202-fan-hui-dao-shu-di-k-ge-jie-dian-jian-dan</id>
        <link href="https://lixin-scut.github.io//post/lian-biao-mian-shi-ti-0202-fan-hui-dao-shu-di-k-ge-jie-dian-jian-dan">
        </link>
        <updated>2020-05-18T00:34:19.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。<br>
注意：本题相对原题稍作改动<br>
示例：<br>
输入： 1-&gt;2-&gt;3-&gt;4-&gt;5 和 k = 2<br>
输出： 4<br>
说明：<br>
给定的 k 保证是有效的。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>复习题，主要练习如何用python刷题吧<br>
核心思想比较简单，就是使用双指针的思想<br>
然后快指针先走k步，然后慢指针再从起点和快指针一起出发，直到快指针到了末尾，慢指针所在的位置就是所求</p>
<p>实现中需要注意的点：</p>
<ol>
<li>这里题目保证k有效，如果加上k无效的考虑的话就会相应地复杂一点</li>
<li>然后就是快指针的最后位置的问题，我选择了让它留在尾节点而不是尾后位置</li>
<li>相应地判断需要做出改动，注意是判断fast还是fast.next</li>
</ol>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def kthToLast(self, head: ListNode, k: int) -&gt; int:
        index = 1
        fast = head
        while index &lt; k:
            if fast == None:
                return fast
            fast = fast.next
            index += 1
        slow = head
        while fast.next != None:
            fast = fast.next
            slow = slow.next
        return slow.val
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OpenWrt使用SSH登陆]]></title>
        <id>https://lixin-scut.github.io//post/openwrt-shi-yong-ssh-deng-lu</id>
        <link href="https://lixin-scut.github.io//post/openwrt-shi-yong-ssh-deng-lu">
        </link>
        <updated>2020-05-17T13:56:30.000Z</updated>
        <content type="html"><![CDATA[<p>今晚在捣鼓电脑的时候发现网速突然非常慢了，就想看看连接到的每个设备的网速，OpenWrt的web后台管理界面中没有继承网速查看的软件包，必须通过SSH连接到路由器才能观看，所以只能先用终端连接路由器了<br>
命令非常简单：</p>
<pre><code>ssh -p 22 root@192.168.2.1
</code></pre>
<p>密码还是默认密码</p>
<p>但是报错：</p>
<pre><code>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the RSA key sent by the remote host is
SHA256:i4j9TxqQwiMWyaUIINlKARG4W/lBnxQv6KJ2y7cB5Sg.
Please contact your system administrator.
Add correct host key in /Users/lixin/.ssh/known_hosts to get rid of this message.
Offending ECDSA key in /Users/lixin/.ssh/known_hosts:5
RSA host key for 192.168.2.1 has changed and you have requested strict checking.
Host key verification failed.
</code></pre>
<p>一开始没有仔细看，以为是终端的问题<br>
查看了登陆OpenWrt的指南以为是必须要使用Putty等工具才能登陆<br>
查了好一阵子都没有结果<br>
然后看了一下路由器web后端有dropbear<br>
查阅dropbear相关博文<a href="http://blog.chinaunix.net/uid-11707862-id-5732715.html">无密码登陆ssh服务器(openwrt dropbear)笔记</a></p>
<blockquote>
<p>我用的平台是win32上的cygwin。<br>
先运行用ssh-keygen生成一对公密钥，密钥和公钥默认保存为</p>
</blockquote>
<pre><code>~/.ssh/id_rsa
~/.ssh/id_rsa.pub
</code></pre>
<blockquote>
<p>生成公密钥后，密钥不用动，放在原位置就可以，但要保管好（锁的钥匙要保管好呀.....)<br>
把密钥添加到openwrt的/ect/dropbear/authorized_keys就可以。<br>
之后在cygwin运行ssh root@openwrt.local就可以不用密码登陆了。<br>
密钥可以复制到手机上，之后导入connectbot中，之后设置好，connectbot同样不用密码就可以登陆openwrt了</p>
</blockquote>
<p>突然发现涉及到秘钥的问题，赶紧回头看一下<br>
仔细看了一下才发现是RSAkey的问题！<br>
所以赶紧查了一下错误，果然如此<br>
参考博文：<a href="https://www.xuebuyuan.com/602989.html">SSH连接时出现Host key verification failed的原因及解决方法</a></p>
<blockquote>
<p>用OpenSSH的人都知ssh会把你每个你访问过计算机的公钥(public key)都记录在~/.ssh/known_hosts。当下次访问相同计算机时，OpenSSH会核对公钥。如果公钥不同，OpenSSH会发出警告，避免你受到DNS Hijack之类的攻击。<br>
SSH对主机的public_key的检查等级是根据<br>
StrictHostKeyChecking变量来配置的。默认情况下，<br>
StrictHostKeyChecking=ask。简单所下它的三种配置值：</p>
</blockquote>
<ol>
<li></li>
</ol>
<p>StrictHostKeyChecking=no<br>
#最不安全的级别，当然也没有那么多烦人的提示了，相对安全的内网测试时建议使用。如果连接server的key在本地不存在，那么就自动添加到文件中（默认是known_hosts），并且给出一个警告。<br>
2.<br>
StrictHostKeyChecking=ask  #默认的级别，就是出现刚才的提示了。如果连接和key不匹配，给出提示，并拒绝登录。<br>
3.<br>
StrictHostKeyChecking=yes  #<br>
最安全的级别，如果连接与key不匹配，就拒绝连接，不会提示详细信息。</p>
<blockquote>
<p>－－－－－－－－－－－－－<br>
解决方法 1<br>
－－－－－－－－－－－－－<br>
对于我来说，在内网的进行的一些测试，为了方便，选择最低的安全级别。在.ssh/config（或者/etc/ssh/ssh_config）中配置：<br>
StrictHostKeyChecking no<br>
UserKnownHostsFile /dev/null<br>
（注：这里为了简便，将knownhostfile设为/dev/null，就不保存在known_hosts中了）</p>
</blockquote>
<blockquote>
<p>－－－－－－－－－－－－－－－<br>
解决方法 2<br>
－－－－－－－－－－－－－－－<br>
vi ~/.ssh/known_hosts<br>
删除对应ip的相关rsa信息</p>
</blockquote>
<blockquote>
<p>－－－－－－－－－－－－－－－<br>
解决方法 3<br>
－－－－－－－－－－－－－－－<br>
rm known_hosts</p>
</blockquote>
<p>作为一个学习过linux的人，当然是应该选择方法2了<br>
打开文件发现果然有四个默认秘钥，而且192.168.2.1赫然在目<br>
然后此时才想来，之前帮家里的k3路由器刷系统的时候就是用了SSH<br>
当时还登陆了SSH开启webUI中心，所以这个秘钥肯定就是k3遗留下来的历史问题了<br>
删除之后在进行SSH登陆OpenWrt，成功登陆！</p>
<p>然后就是安装网速查看软件，也是有小坑的，需要先更新软件列表</p>
<p>在openwrt安装iftop命令：</p>
<pre><code>#首先得更新软件清单才能安装软件，略蛋疼
opkg update
#安装iftop
opkg install iftop
</code></pre>
<p>然后运行命令</p>
<pre><code>iftop -i br-lan
</code></pre>
<p>大功告成！下次就可以看看是不是舍友的ipad占了过量的网速了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python - 异步IO]]></title>
        <id>https://lixin-scut.github.io//post/python-yi-bu-io</id>
        <link href="https://lixin-scut.github.io//post/python-yi-bu-io">
        </link>
        <updated>2020-05-13T14:20:50.000Z</updated>
        <content type="html"><![CDATA[<p>在IO编程一节中，我们已经知道，CPU的速度远远快于磁盘、网络等IO。在一个线程中，CPU执行代码的速度极快，然而，一旦遇到IO操作，如读写文件、发送网络数据时，就需要等待IO操作完成，才能继续进行下一步操作。这种情况称为同步IO。</p>
<p>在IO操作的过程中，当前线程被挂起，而其他需要CPU执行的代码就无法被当前线程执行了。</p>
<p>因为一个IO操作就阻塞了当前线程，导致其他代码无法执行，所以我们必须使用多线程或者多进程来并发执行代码，为多个用户服务。每个用户都会分配一个线程，如果遇到IO导致线程被挂起，其他用户的线程不受影响。</p>
<p>多线程和多进程的模型虽然解决了并发问题，但是系统不能无上限地增加线程。由于系统切换线程的开销也很大，所以，一旦线程数量过多，CPU的时间就花在线程切换上了，真正运行代码的时间就少了，结果导致性能严重下降。</p>
<p>由于我们要解决的问题是<strong>CPU高速执行能力和IO设备的龟速严重不匹配</strong>，多线程和多进程只是解决这一问题的一种方法。</p>
<p>另一种解决IO问题的方法是<strong>异步IO。当代码需要执行一个耗时的IO操作时，它只发出IO指令，并不等待IO结果，然后就去执行其他代码了</strong>。一段时间后，当<strong>IO返回结果时，再通知CPU进行处理</strong>。</p>
<p>可以想象如果按普通顺序写出的代码实际上是没法完成异步IO的：</p>
<pre><code>
do_some_code()
f = open('/path/to/file', 'r')
r = f.read() # &lt;== 线程停在此处等待IO操作结果
# IO操作完成后线程才能继续执行:
do_some_code(r)

</code></pre>
<p>所以，同步IO模型的代码是无法实现异步IO模型的。</p>
<p><strong>异步IO模型需要一个消息循环</strong>，在消息循环中，主线程<strong>不断地重复“读取消息-处理消息”这一过程</strong>：</p>
<pre><code>loop = get_event_loop()
while True:
    event = loop.get_event()
    process_event(event)
</code></pre>
<p>消息模型其实早在应用在桌面应用程序中了。一个GUI程序的主线程就负责不停地读取消息并处理消息。所有的键盘、鼠标等消息都被发送到GUI程序的消息队列中，然后由GUI程序的主线程处理。</p>
<p>由于GUI线程处理键盘、鼠标等消息的速度非常快，所以用户感觉不到延迟。某些时候，GUI线程在一个消息处理的过程中遇到问题导致一次消息处理时间过长，此时，用户会感觉到整个GUI程序停止响应了，敲键盘、点鼠标都没有反应。这种情况说明在消息模型中，处理一个消息必须非常迅速，否则，主线程将无法及时处理消息队列中的其他消息，导致程序看上去停止响应。</p>
<p>消息模型是如何解决同步IO必须等待IO操作这一问题的呢？</p>
<ol>
<li>当遇到IO操作时，代码<strong>只负责发出IO请求</strong>，不等待IO结果，然后<strong>直接结束本轮消息处理，进入下一轮消息处理过程</strong>。</li>
<li>当IO操作完成后，将<strong>收到一条“IO完成”的消息</strong>，<strong>处理该消息时就可以直接获取IO操作结果</strong>。</li>
</ol>
<p>在“发出IO请求”到收到“IO完成”的这段时间里，<strong>同步IO模型下，主线程只能挂起</strong>，但<strong>异步IO模型下，主线程并没有休息</strong>，而是在消息循环中继续处理其他消息。这样，在异步IO模型下，<strong>一个线程就可以同时处理多个IO请求</strong>，并且没有切换线程的操作。对于大多数IO密集型的应用程序，使用异步IO将大大提升系统的多任务处理能力。</p>
<h2 id="协程">协程</h2>
<p>在学习异步IO模型前，我们先来了解协程。</p>
<p>协程，又称微线程，纤程。英文名Coroutine。</p>
<p>协程的概念很早就提出来了，但直到最近几年才在某些语言（如Lua）中得到广泛应用。</p>
<p>子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。</p>
<p>所以<strong>子程序调用是通过栈实现的</strong>，一个线程就是执行一个子程序。</p>
<p>子程序调用总是一个入口，一次返回，<strong>调用顺序是明确的</strong>。</p>
<p>而<strong>协程的调用和子程序不同</strong>。</p>
<p>协程看上去也是子程序，但<strong>执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行</strong>。</p>
<p>注意，<strong>在一个子程序中中断，去执行其他子程序，不是函数调用，有点类似CPU的中断</strong>。比如子程序A、B：</p>
<pre><code>def A():
    print('1')
    print('2')
    print('3')

def B():
    print('x')
    print('y')
    print('z')
</code></pre>
<p>假设由协程执行，在执行A的过程中，可以随时中断，去执行B，B也可能在执行过程中中断再去执行A，结果可能是：</p>
<pre><code>1
2
x
y
3
z
</code></pre>
<p>但是在A中是没有调用B的，所以协程的调用比函数调用理解起来要难一些。</p>
<p>看起来A、B的执行有点像多线程，但<strong>协程的特点在于是一个线程执行</strong>，那和多线程比，协程有何优势？</p>
<p>最大的优势就是<strong>协程极高的执行效率</strong>。因为<strong>子程序切换不是线程切换</strong>，而是<strong>由程序自身控制</strong>，因此，<strong>没有线程切换的开销</strong>，和多线程比，线程<strong>数量越多，协程的性能优势就越明显</strong>。</p>
<p>第二大优势就是<strong>不需要多线程的锁机制</strong>，因为只有一个线程，也<strong>不存在同时写变量冲突</strong>，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p>
<p>因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是<strong>多进程+协程，既充分利用多核，又充分发挥协程的高效率</strong>，可获得极高的性能。</p>
<p>Python<strong>对协程的支持是通过generator实现的</strong>。</p>
<p>在generator中，我们不但可以<strong>通过for循环来迭代</strong>，还可以不断<strong>调用next()函数获取</strong>由<strong>yield语句返回的下一个值</strong>。</p>
<p>但是Python的<strong>yield不仅可以返回一个值</strong>，它<strong>还可以接收调用者发出的参数</strong>。</p>
<p>来看例子：</p>
<p>传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但一不小心就可能死锁。</p>
<p>如果改用协程，生产者生产消息后，直接通过yield跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高：</p>
<pre><code>def consumer():
    r = ''
    while True:
        n = yield r
        if not n:
            return
        print('[CONSUMER] Consuming %s...' % n)
        r = '200 OK'

def produce(c):
    c.send(None)
    n = 0
    while n &lt; 5:
        n = n + 1
        print('[PRODUCER] Producing %s...' % n)
        r = c.send(n)
        print('[PRODUCER] Consumer return: %s' % r)
    c.close()

c = consumer()
produce(c)
</code></pre>
<p>执行结果：</p>
<pre><code>[PRODUCER] Producing 1...
[CONSUMER] Consuming 1...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 2...
[CONSUMER] Consuming 2...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 3...
[CONSUMER] Consuming 3...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 4...
[CONSUMER] Consuming 4...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 5...
[CONSUMER] Consuming 5...
[PRODUCER] Consumer return: 200 OK
</code></pre>
<p>注意到<strong>consumer函数是一个generator</strong>，把一个consumer传入produce后：</p>
<ol>
<li>
<p>首先调用<strong>c.send(None)</strong> 启动生成器；</p>
</li>
<li>
<p>然后，一旦生产了东西，通过<strong>c.send(n)切换到consumer</strong>执行；</p>
</li>
<li>
<p><strong>consumer通过yield拿到消息</strong>，处理，<strong>又通过yield把结果传回</strong>；</p>
</li>
<li>
<p>produce拿到consumer处理的结果，<strong>继续生产下一条消息</strong>；</p>
</li>
<li>
<p>produce决定不生产了，<strong>通过c.close()关闭consumer</strong>，整个过程结束。</p>
</li>
</ol>
<p><strong>整个流程无锁，由一个线程执行，produce和consumer协作完成任务，所以称为“协程”，而非线程的抢占式多任务</strong>。</p>
<p>最后套用Donald Knuth的一句话总结协程的特点：</p>
<p><strong>“子程序就是协程的一种特例。”</strong></p>
<h2 id="asyncio-消息循环模型">asyncio-消息循环模型</h2>
<p>asyncio是Python 3.4版本引入的标准库，直接内置了对异步IO的支持。</p>
<p>asyncio的编程模型就是一个消息循环。我们从asyncio模块中直接获取一个EventLoop的引用，然后把需要执行的协程扔到EventLoop中执行，就实现了异步IO。</p>
<p>用asyncio实现Hello world代码如下：</p>
<pre><code>
import asyncio

@asyncio.coroutine
def hello():
    print(&quot;Hello world!&quot;)
    # 异步调用asyncio.sleep(1):
    r = yield from asyncio.sleep(1)
    print(&quot;Hello again!&quot;)

# 获取EventLoop:
loop = asyncio.get_event_loop()
# 执行coroutine
loop.run_until_complete(hello())
loop.close()

</code></pre>
<p>@asyncio.coroutine把一个generator标记为coroutine类型，然后，我们就把这个coroutine扔到EventLoop中执行。</p>
<p>hello()会首先打印出Hello world!，然后，yield from语法可以让我们方便地调用另一个generator。由于asyncio.sleep()也是一个coroutine，所以线程不会等待asyncio.sleep()，而是直接中断并执行下一个消息循环。当asyncio.sleep()返回时，线程就可以从yield from拿到返回值（此处是None），然后接着执行下一行语句。</p>
<p>把asyncio.sleep(1)看成是一个耗时1秒的IO操作，在此期间，主线程并未等待，而是去执行EventLoop中其他可以执行的coroutine了，因此可以实现并发执行。</p>
<p>我们用Task封装两个coroutine试试：</p>
<pre><code>
import threading
import asyncio

@asyncio.coroutine
def hello():
    print('Hello world! (%s)' % threading.currentThread())
    yield from asyncio.sleep(1)
    print('Hello again! (%s)' % threading.currentThread())

loop = asyncio.get_event_loop()
tasks = [hello(), hello()]
loop.run_until_complete(asyncio.wait(tasks))
loop.close()

</code></pre>
<p>观察执行过程：</p>
<pre><code>
Hello world! (&lt;_MainThread(MainThread, started 140735195337472)&gt;)
Hello world! (&lt;_MainThread(MainThread, started 140735195337472)&gt;)
(暂停约1秒)
Hello again! (&lt;_MainThread(MainThread, started 140735195337472)&gt;)
Hello again! (&lt;_MainThread(MainThread, started 140735195337472)&gt;)

</code></pre>
<p>由打印的当前线程名称可以看出，两个coroutine是由同一个线程并发执行的。</p>
<p>如果把asyncio.sleep()换成真正的IO操作，则多个coroutine就可以由一个线程并发执行。</p>
<p>我们用asyncio的异步网络连接来获取sina、sohu和163的网站首页：</p>
<pre><code>import asyncio

@asyncio.coroutine
def wget(host):
    print('wget %s...' % host)
    connect = asyncio.open_connection(host, 80)
    reader, writer = yield from connect
    header = 'GET / HTTP/1.0\r\nHost: %s\r\n\r\n' % host
    writer.write(header.encode('utf-8'))
    yield from writer.drain()
    while True:
        line = yield from reader.readline()
        if line == b'\r\n':
            break
        print('%s header &gt; %s' % (host, line.decode('utf-8').rstrip()))
    # Ignore the body, close the socket
    writer.close()

loop = asyncio.get_event_loop()
tasks = [wget(host) for host in ['www.sina.com.cn', 'www.sohu.com', 'www.163.com']]
loop.run_until_complete(asyncio.wait(tasks))
loop.close()
</code></pre>
<p>执行结果如下：</p>
<pre><code>wget www.sohu.com...
wget www.sina.com.cn...
wget www.163.com...
(等待一段时间)
(打印出sohu的header)
www.sohu.com header &gt; HTTP/1.1 200 OK
www.sohu.com header &gt; Content-Type: text/html
...
(打印出sina的header)
www.sina.com.cn header &gt; HTTP/1.1 200 OK
www.sina.com.cn header &gt; Date: Wed, 20 May 2015 04:56:33 GMT
...
(打印出163的header)
www.163.com header &gt; HTTP/1.0 302 Moved Temporarily
www.163.com header &gt; Server: Cdn Cache Server V2.0
...
</code></pre>
<p>可见3个连接由一个线程通过coroutine并发完成。</p>
<p><strong>小结</strong></p>
<p>asyncio提供了完善的异步IO支持；</p>
<p>异步操作需要在coroutine中通过yield from完成；</p>
<p>多个coroutine可以封装成一组Task然后并发执行。</p>
<h2 id="asyncawait">async/await</h2>
<p>用asyncio提供的@asyncio.coroutine可以把一个generator标记为coroutine类型，然后在coroutine内部用yield from调用另一个coroutine实现异步操作。</p>
<p>为了简化并更好地标识异步IO，从Python 3.5开始引入了新的语法async和await，可以让coroutine的代码更简洁易读。</p>
<p>请注意，async和await是针对coroutine的新语法，要使用新的语法，只需要做两步简单的替换：</p>
<p>把@asyncio.coroutine替换为async；<br>
把yield from替换为await。<br>
让我们对比一下上一节的代码：</p>
<pre><code>@asyncio.coroutine
def hello():
    print(&quot;Hello world!&quot;)
    r = yield from asyncio.sleep(1)
    print(&quot;Hello again!&quot;)
</code></pre>
<p>用新语法重新编写如下：</p>
<pre><code>async def hello():
    print(&quot;Hello world!&quot;)
    r = await asyncio.sleep(1)
    print(&quot;Hello again!&quot;)
</code></pre>
<p>剩下的代码保持不变。</p>
<p><strong>小结</strong></p>
<p>Python从3.5版本开始为asyncio提供了async和await的新语法；</p>
<p>注意新语法只能用在Python 3.5以及后续版本，如果使用3.4版本，则仍需使用上一节的方案。</p>
<h2 id="aiohttp">aiohttp</h2>
<p>asyncio可以实现单线程并发IO操作。如果仅用在客户端，发挥的威力不大。如果把asyncio用在服务器端，例如Web服务器，由于HTTP连接就是IO操作，因此可以用单线程+coroutine实现多用户的高并发支持。</p>
<p>asyncio实现了TCP、UDP、SSL等协议，aiohttp则是基于asyncio实现的HTTP框架。</p>
<p>我们先安装aiohttp：</p>
<pre><code>pip install aiohttp
</code></pre>
<p>然后编写一个HTTP服务器，分别处理以下URL：</p>
<ul>
<li>
<p><code>/</code> - 首页返回<code>b'&lt;h1&gt;Index&lt;/h1&gt;'</code>；</p>
</li>
<li>
<p><code>/hello/{name}</code>- 根据URL参数返回文本<code>hello, %s!</code>。</p>
</li>
</ul>
<p>代码如下：</p>
<pre><code>import asyncio

from aiohttp import web

async def index(request):
    await asyncio.sleep(0.5)
    return web.Response(body=b'&lt;h1&gt;Index&lt;/h1&gt;')

async def hello(request):
    await asyncio.sleep(0.5)
    text = '&lt;h1&gt;hello, %s!&lt;/h1&gt;' % request.match_info['name']
    return web.Response(body=text.encode('utf-8'))

async def init(loop):
    app = web.Application(loop=loop)
    app.router.add_route('GET', '/', index)
    app.router.add_route('GET', '/hello/{name}', hello)
    srv = await loop.create_server(app.make_handler(), '127.0.0.1', 8000)
    print('Server started at http://127.0.0.1:8000...')
    return srv

loop = asyncio.get_event_loop()
loop.run_until_complete(init(loop))
loop.run_forever()
</code></pre>
<p>注意aiohttp的初始化函数init()也是一个coroutine，loop.create_server()则利用asyncio创建TCP服务。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python - Web开发]]></title>
        <id>https://lixin-scut.github.io//post/python-web-kai-fa</id>
        <link href="https://lixin-scut.github.io//post/python-web-kai-fa">
        </link>
        <updated>2020-05-13T10:05:00.000Z</updated>
        <content type="html"><![CDATA[<p>最早的软件都是运行在大型机上的，软件使用者通过“哑终端”登陆到大型机上去运行软件。后来随着PC机的兴起，软件开始主要运行在桌面上，而数据库这样的软件运行在服务器端，这种<strong>Client/Server模式简称CS架构</strong>。</p>
<p>随着互联网的兴起，人们发现，CS架构不适合Web，最大的原因是Web应用程序的修改和升级非常迅速，而<strong>CS架构需要每个客户端逐个升级桌面App</strong>，因此，<strong>Browser/Server模式开始流行，简称BS架构</strong>。</p>
<p>在BS架构下，<strong>客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端</strong>。浏览器只需要请求服务器，获取Web页面，并把Web页面展示给用户即可。</p>
<p>当然，Web页面也具有极强的交互性。由于Web页面是用HTML编写的，而HTML具备超强的表现力，并且，<strong>服务器端升级后，客户端无需任何部署就可以使用到新的版本</strong>，因此，BS架构迅速流行起来。</p>
<p>今天，除了重量级的软件如Office，Photoshop等，大部分软件都以Web形式提供。比如，新浪提供的新闻、博客、微博等服务，均是Web应用。</p>
<p>Web应用开发可以说是目前软件开发中最重要的部分。Web开发也经历了好几个阶段：</p>
<p>静态Web页面：由文本编辑器直接编辑并生成静态的HTML页面，如果要修改Web页面的内容，就需要再次编辑HTML源文件，早期的互联网Web页面就是静态的；</p>
<p>CGI：由于静态Web页面无法与用户交互，比如用户填写了一个注册表单，静态Web页面就无法处理。要处理用户发送的动态数据，出现了Common Gateway Interface，简称CGI，用C/C++编写。</p>
<p>ASP/JSP/PHP：由于Web应用特点是修改频繁，用C/C++这样的低级语言非常不适合Web开发，而脚本语言由于开发效率高，与HTML结合紧密，因此，迅速取代了CGI模式。ASP是微软推出的用VBScript脚本编程的Web开发技术，而JSP用Java来编写脚本，PHP本身则是开源的脚本语言。</p>
<p>MVC：为了解决直接用脚本语言嵌入HTML导致的可维护性差的问题，Web应用也引入了<strong>Model-View-Controller的模式</strong>，来简化Web开发。ASP发展为ASP.Net，JSP和PHP也有一大堆MVC框架。</p>
<p>目前，Web开发技术仍在快速发展中，异步开发、新的MVVM前端技术层出不穷。</p>
<p>Python的诞生历史比Web还要早，由于Python是一种解释型的脚本语言，开发效率高，所以非常适合用来做Web开发。</p>
<p>Python有上百种Web开发框架，有很多成熟的模板技术，选择Python开发Web应用，不但开发效率高，而且运行速度快。</p>
<h2 id="http协议简介">HTTP协议简介</h2>
<p>在Web应用中，服务器把网页传给浏览器，实际上就是把网页的HTML代码发送给浏览器，让浏览器显示出来。而浏览器和服务器之间的传输协议是HTTP，所以：</p>
<ol>
<li>
<p><strong>HTML是一种用来定义网页的文本</strong>，会HTML，就可以<strong>编写网页</strong>；</p>
</li>
<li>
<p><strong>HTTP是在网络上传输HTML的协议</strong>，用于<strong>浏览器和服务器的通信</strong>。</p>
</li>
</ol>
<p>我们需要在浏览器很方便地调试我们的Web应用，而Chrome提供了一套完整地调试工具，非常适合Web开发。</p>
<p>安装好Chrome浏览器后，打开Chrome，在菜单中选择“视图”，“开发者”，“开发者工具”，就可以显示开发者工具<br>
Elements显示网页的结构，Network显示浏览器和服务器的通信。我们点Network，确保第一个小红灯亮着，Chrome就会记录所有浏览器和服务器之间的通信：<br>
当我们在地址栏输入<code>www.sina.com.cn</code>时，浏览器将显示新浪的首页。在这个过程中，浏览器都干了哪些事情呢？通过Network的记录，我们就可以知道。在Network中，定位到第一条记录，点击，右侧将显示Request Headers，点击右侧的view source，我们就可以看到浏览器发给新浪服务器的请求<br>
最主要的头两行分析如下，第一行：</p>
<pre><code>GET / HTTP/1.1
</code></pre>
<p>GET表示一个读取请求，将从服务器获得网页数据，/表示URL的路径，URL总是以/开头，/就表示首页，最后的HTTP/1.1指示采用的HTTP协议版本是1.1。目前HTTP协议的版本就是1.1，但是大部分服务器也支持1.0版本，主要区别在于1.1版本允许多个HTTP请求复用一个TCP连接，以加快传输速度。</p>
<p>从第二行开始，每一行都类似于<code>Xxx: abcdefg</code>：</p>
<pre><code>Host: www.sina.com.cn
</code></pre>
<p>表示请求的域名是<code>www.sina.com.cn</code>。如果一台服务器有多个网站，服务器就需要通过Host来区分浏览器请求的是哪个网站。</p>
<p>继续往下找到Response Headers，点击view source，显示服务器返回的原始响应数据</p>
<p>HTTP响应分为Header和Body两部分（Body是可选项），我们在Network中看到的Header最重要的几行如下：</p>
<pre><code>200 OK
</code></pre>
<p>200表示一个成功的响应，后面的OK是说明。失败的响应有404 Not Found：网页不存在，500 Internal Server Error：服务器内部出错，等等。</p>
<pre><code>Content-Type: text/html
</code></pre>
<p>Content-Type指示响应的内容，这里是text/html表示HTML网页。请注意，<strong>浏览器就是依靠Content-Type来判断响应的内容是网页还是图片，是视频还是音乐。</strong> 浏览器并不靠URL来判断响应的内容，所以，即使URL是<code>http://example.com/abc.jpg</code>，它也不一定就是图片。</p>
<p>HTTP响应的Body就是HTML源码，我们在菜单栏选择“视图”，“开发者”，“查看网页源码”就可以在浏览器中直接查看HTML源码</p>
<p>当浏览器读取到新浪首页的HTML源码后，它会解析HTML，显示页面，然后，根据HTML里面的各种链接，再发送HTTP请求给新浪服务器，拿到相应的图片、视频、Flash、JavaScript脚本、CSS等各种资源，最终显示出一个完整的页面。所以我们在Network下面能看到很多额外的HTTP请求。</p>
<h3 id="http请求">HTTP请求</h3>
<p>跟踪了新浪的首页，我们来总结一下HTTP请求的流程：</p>
<p>步骤1：浏览器首先向服务器发送HTTP请求，请求包括：</p>
<p>方法：GET还是POST，<strong>GET仅请求资源</strong>，<strong>POST会附带用户数据</strong>；</p>
<p>路径：<code>/full/url/path</code>；</p>
<p>域名：由Host头指定：<code>Host: www.sina.com.cn</code></p>
<p>以及其他相关的Header；</p>
<p>如果是POST，那么请求还包括一个Body，包含用户数据。</p>
<p>步骤2：服务器向浏览器返回HTTP响应，响应包括：</p>
<p>响应代码：200表示成功，3xx表示重定向，4xx表示客户端发送的请求有错误，5xx表示服务器端处理时发生了错误；</p>
<p>响应类型：<strong>由Content-Type指定</strong>，例如：Content-Type: text/html;charset=utf-8表示响应类型是HTML文本，并且编码是UTF-8，Content-Type: image/jpeg表示响应类型是JPEG格式的图片；</p>
<p>以及其他相关的Header；</p>
<p>通常服务器的HTTP响应会携带内容，也就是有一个<strong>Body，包含响应的内容，网页的HTML源码就在Body中</strong>。</p>
<p>步骤3：如果浏览器还需要继续向服务器请求其他资源，比如图片，就再次发出HTTP请求，重复步骤1、2。</p>
<p>Web采用的HTTP协议采用了非常简单的请求-响应模式，从而大大简化了开发。当我们编写一个页面时，我们只需要在HTTP响应中把HTML发送出去，不需要考虑如何附带图片、视频等，浏览器如果需要请求图片和视频，它会发送另一个HTTP请求，因此，一个HTTP请求只处理一个资源。</p>
<p>HTTP协议同时具备极强的扩展性，虽然<strong>浏览器请求</strong>的是<code>http://www.sina.com.cn/</code>的首页，但是新浪<strong>在HTML中可以链入其他服务器的资源（反向代理）</strong>，比如<code>&lt;img src=&quot;http://i1.sinaimg.cn/home/2013/1008/U8455P30DT20131008135420.png&quot;&gt;</code>，从而将请求压力分散到各个服务器上，并且，一个站点可以链接到其他站点，无数个站点互相链接起来，就形成了World Wide Web，简称“三达不溜”（WWW）。</p>
<h3 id="http格式">HTTP格式</h3>
<p>每个HTTP请求和响应都遵循相同的格式，一个HTTP包含Header和Body两部分，其中Body是可选的。</p>
<p>HTTP协议是一种文本协议，所以，它的格式也非常简单。HTTP GET请求的格式：</p>
<pre><code>GET /path HTTP/1.1
Header1: Value1
Header2: Value2
Header3: Value3
</code></pre>
<p><strong>每个Header一行一个，换行符是\r\n</strong>。</p>
<p>HTTP POST请求的格式：</p>
<pre><code>POST /path HTTP/1.1
Header1: Value1
Header2: Value2
Header3: Value3

body data goes here...
</code></pre>
<p>当<strong>遇到连续两个\r\n时，Header部分结束，后面的数据全部是Body</strong>。</p>
<p>HTTP响应的格式：</p>
<pre><code>200 OK
Header1: Value1
Header2: Value2
Header3: Value3

body data goes here...
</code></pre>
<p>HTTP响应<strong>如果包含body，也是通过\r\n\r\n来分隔的</strong>。请再次注意，<strong>Body的数据类型由Content-Type头来确定</strong>，如果是网页，Body就是文本，如果是图片，Body就是图片的二进制数据。</p>
<p><strong>当存在Content-Encoding时，Body数据是被压缩的，最常见的压缩方式是gzip</strong>，所以，看到Content-Encoding: gzip时，需要将Body数据先解压缩，才能得到真正的数据。压缩的目的在于减少Body的大小，加快网络传输。</p>
<h2 id="html简介">HTML简介</h2>
<p>网页就是HTML？这么理解大概没错。因为网页中不但包含文字，还有图片、视频、Flash小游戏，有复杂的排版、动画效果，所以，HTML定义了一套语法规则，来告诉浏览器如何把一个丰富多彩的页面显示出来。</p>
<p>最简单的HTML：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Hello&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1&gt;Hello, world!&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>可以用文本编辑器编写HTML，然后保存为hello.html，双击或者把文件拖到浏览器中</p>
<p>HTML文档就是一系列的Tag组成，最外层的Tag是<code>&lt;html&gt;</code>。规范的HTML也包含<code>&lt;head&gt;...&lt;/head&gt;</code>和<code>&lt;body&gt;...&lt;/body&gt;</code>（注意不要和HTTP的Header、Body搞混了），由于HTML是富文档模型，所以，还有一系列的Tag用来表示链接、图片、表格、表单等等。</p>
<h3 id="css简介">CSS简介</h3>
<p>CSS是<strong>Cascading Style Sheets（层叠样式表）</strong> 的简称，CSS用来<strong>控制HTML里的所有元素如何展现</strong>，比如，给标题元素<code>&lt;h1&gt;</code>加一个样式，变成48号字体，灰色，带阴影：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Hello&lt;/title&gt;
  &lt;style&gt;
    h1 {
      color: #333333;
      font-size: 48px;
      text-shadow: 3px 3px 3px #666666;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1&gt;Hello, world!&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="javascript简介">JavaScript简介</h3>
<p>JavaScript虽然名称有个Java，但它和Java真的一点关系没有。JavaScript是为了<strong>让HTML具有交互性而作为脚本语言添加的</strong>，JavaScript既可以内嵌到HTML中，也可以从外部链接到HTML中。如果我们希望当用户点击标题时把标题变成红色，就必须通过JavaScript来实现：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Hello&lt;/title&gt;
  &lt;style&gt;
    h1 {
      color: #333333;
      font-size: 48px;
      text-shadow: 3px 3px 3px #666666;
    }
  &lt;/style&gt;
  &lt;script&gt;
    function change() {
      document.getElementsByTagName('h1')[0].style.color = '#ff0000';
    }
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1 onclick=&quot;change()&quot;&gt;Hello, world!&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>小结</strong></p>
<p>如果要学习Web开发，首先要对HTML、CSS和JavaScript作一定的了解。HTML定义了页面的内容，CSS来控制页面元素的样式，而JavaScript负责页面的交互逻辑。</p>
<h2 id="wsgi接口">WSGI接口</h2>
<p>了解了HTTP协议和HTML文档，我们其实就明白了一个Web应用的本质就是：</p>
<ol>
<li>
<p>浏览器发送一个HTTP请求；</p>
</li>
<li>
<p>服务器收到请求，生成一个HTML文档；</p>
</li>
<li>
<p>服务器把HTML文档作为HTTP响应的Body发送给浏览器；</p>
</li>
<li>
<p>浏览器收到HTTP响应，从HTTP Body取出HTML文档并显示。</p>
</li>
</ol>
<p>所以，<strong>最简单的Web应用就是先把HTML用文件保存好，用一个现成的HTTP服务器软件，接收用户请求，从文件中读取HTML</strong>，返回。<strong>Apache、Nginx、Lighttpd</strong>等这些常见的<strong>静态服务器</strong>就是干这件事情的。</p>
<p>如果要动态生成HTML，就需要把上述步骤自己来实现。不过，接受HTTP请求、解析HTTP请求、发送HTTP响应都是苦力活，如果我们自己来写这些底层代码，还没开始写动态HTML呢，就得花个把月去读HTTP规范。</p>
<p>正确的做法是<strong>底层代码由专门的服务器软件实现，我们用Python专注于生成HTML文档</strong>。因为我们不希望接触到TCP连接、HTTP原始请求和响应格式，所以，<strong>需要一个统一的接口，让我们专心用Python编写Web业务</strong>。</p>
<p>这个接口就是<strong>WSGI：Web Server Gateway Interface</strong>。</p>
<p>WSGI接口定义非常简单，它只要求Web开发者<strong>实现一个函数，就可以响应HTTP请求</strong>。我们来看一个最简单的Web版本的“Hello, web!”：</p>
<pre><code>def application(environ, start_response):
    start_response('200 OK', [('Content-Type', 'text/html')])
    return [b'&lt;h1&gt;Hello, web!&lt;/h1&gt;']
</code></pre>
<p>上面的application()函数就是符合WSGI标准的一个HTTP处理函数，它接收两个参数：</p>
<ol>
<li>
<p>environ：一个<strong>包含所有HTTP请求信息的dict对象</strong>；</p>
</li>
<li>
<p>start_response：一个<strong>发送HTTP响应的函数</strong>。</p>
</li>
</ol>
<p>在application()函数中，调用：</p>
<pre><code>start_response('200 OK', [('Content-Type', 'text/html')])
</code></pre>
<p>就<strong>发送了HTTP响应的Header</strong>，注意Header只能发送一次，也就是只能调用一次start_response()函数。start_response()函数接收两个参数，一个是<strong>HTTP响应码</strong>，一个是一组list表示的<strong>HTTP Header</strong>，每个Header用一个包含两个str的tuple表示。</p>
<p>通常情况下，都应该把<strong>Content-Type头</strong>发送给浏览器。其他很多常用的HTTP Header也应该发送。</p>
<p>然后，函数的返回值<code>b'&lt;h1&gt;Hello, web!&lt;/h1&gt;'</code>将作为<strong>HTTP响应的Body</strong>发送给浏览器。</p>
<p>有了WSGI，我们关心的就是如何从environ这个dict对象拿到HTTP请求信息，然后构造HTML，通过start_response()发送Header，最后返回Body。</p>
<p>整个application()函数本身没有涉及到任何解析HTTP的部分，也就是说，底层代码不需要我们自己编写，我们只负责在更高层次上考虑如何响应请求就可以了。</p>
<p>不过这个application()函数怎么调用？如果我们自己调用，<strong>两个参数environ和start_response我们没法提供，返回的bytes也没法发给浏览器</strong>。</p>
<p>所以<strong>application()函数必须由WSGI服务器来调用</strong>。有很多符合WSGI规范的服务器，我们可以挑选一个来用。但是现在，我们只想尽快测试一下我们编写的application()函数真的可以把HTML输出到浏览器，所以需要赶紧找一个最简单的WSGI服务器，把我们的Web应用程序跑起来。</p>
<p>好消息是<strong>Python内置了一个WSGI服务器，这个模块叫wsgiref</strong>，它是用纯Python编写的WSGI服务器的参考实现。所谓“参考实现”是指该实现完全符合WSGI标准，但是<strong>不考虑任何运行效率，仅供开发和测试使用</strong>。</p>
<h3 id="运行wsgi服务">运行WSGI服务</h3>
<p>我们先编写hello.py，<strong>实现Web应用程序的WSGI处理函数</strong>：</p>
<pre><code>
# hello.py

def application(environ, start_response):
    start_response('200 OK', [('Content-Type', 'text/html')])
    return [b'&lt;h1&gt;Hello, web!&lt;/h1&gt;']
		
</code></pre>
<p>然后，再编写一个server.py，<strong>负责启动WSGI服务器，加载application()函数</strong>：</p>
<pre><code>
# server.py
# 从wsgiref模块导入:
from wsgiref.simple_server import make_server
# 导入我们自己编写的application函数:
from hello import application

# 创建一个服务器，IP地址为空，端口是8000，处理函数是application:
httpd = make_server('', 8000, application)
print('Serving HTTP on port 8000...')
# 开始监听HTTP请求:
httpd.serve_forever()

</code></pre>
<p>注意：如果8000端口已被其他程序占用，启动将失败，请修改成其他端口。</p>
<p>启动成功后，打开浏览器，输入<code>http://localhost:8000/</code>，就可以看到结果了：</p>
<p>在命令行可以看到wsgiref打印的log信息</p>
<p>按Ctrl+C终止服务器。</p>
<p>如果你觉得这个Web应用太简单了，可以稍微改造一下，从environ里读取PATH_INFO，这样可以显示更加动态的内容：</p>
<pre><code>
# hello.py

def application(environ, start_response):
    start_response('200 OK', [('Content-Type', 'text/html')])
    body = '&lt;h1&gt;Hello, %s!&lt;/h1&gt;' % (environ['PATH_INFO'][1:] or 'web')
    return [body.encode('utf-8')]
		
</code></pre>
<p>你可以在地址栏输入用户名作为URL的一部分，将返回Hello, xxx!：</p>
<h3 id="小结">小结</h3>
<p>无论多么复杂的Web应用程序，入口都是一个WSGI处理函数。HTTP请求的所有输入信息都可以通过environ获得，HTTP响应的输出都可以通过start_response()加上函数返回值作为Body。</p>
<p>复杂的Web应用程序，光靠一个WSGI函数来处理还是太底层了，我们需要在WSGI之上再抽象出Web框架，进一步简化Web开发。</p>
<h2 id="web框架">Web框架</h2>
<p>解了WSGI框架，我们发现：其实一个Web App，就是写一个WSGI的处理函数，针对每个HTTP请求进行响应。</p>
<p>但是如何处理HTTP请求不是问题，问题是如何处理100个不同的URL。</p>
<p><strong>每一个URL可以对应GET和POST请求，当然还有PUT、DELETE等请求</strong>，但是我们通常只考虑最常见的GET和POST请求。</p>
<p>一个最简单的想法是从environ变量里取出HTTP请求的信息，然后逐个判断：</p>
<pre><code>def application(environ, start_response):
    method = environ['REQUEST_METHOD']
    path = environ['PATH_INFO']
    if method=='GET' and path=='/':
        return handle_home(environ, start_response)
    if method=='POST' and path='/signin':
        return handle_signin(environ, start_response)
    ...
</code></pre>
<p>只是这么写下去代码是肯定没法维护了。</p>
<p>代码这么写没法维护的原因是因为WSGI提供的接口虽然比HTTP接口高级了不少，但和Web App的处理逻辑比，还是比较低级，我们<strong>需要在WSGI接口之上能进一步抽象，让我们专注于用一个函数处理一个URL，至于URL到函数的映射，就交给Web框架来做</strong>。</p>
<p>由于用Python开发一个Web框架十分容易，所以Python有上百个开源的Web框架。这里我们先不讨论各种Web框架的优缺点，直接选择一个<strong>比较流行的Web框架——Flask</strong>来使用。</p>
<p>用Flask框架编写Web App比WSGI接口简单，我们先用pip安装Flask：</p>
<pre><code>$ pip install flask
</code></pre>
<p>然后写一个app.py，<strong>处理3个URL</strong>，分别是：</p>
<ul>
<li>
<p>GET /：首页，返回Home；</p>
</li>
<li>
<p>GET /signin：登录页，显示登录表单；</p>
</li>
<li>
<p>POST /signin：处理登录表单，显示登录结果。</p>
</li>
</ul>
<p>注意噢，<strong>同一个URL/signin分别有GET和POST两种请求</strong>，映射到两个处理函数中。</p>
<p>Flask通过<strong>Python的装饰器</strong>在内部<strong>自动地把URL和函数给关联起来</strong>，所以，我们写出来的代码就像这样：</p>
<pre><code>from flask import Flask
from flask import request

app = Flask(__name__)

@app.route('/', methods=['GET', 'POST'])
def home():
    return '&lt;h1&gt;Home&lt;/h1&gt;'

@app.route('/signin', methods=['GET'])
def signin_form():
    return '''&lt;form action=&quot;/signin&quot; method=&quot;post&quot;&gt;
              &lt;p&gt;&lt;input name=&quot;username&quot;&gt;&lt;/p&gt;
              &lt;p&gt;&lt;input name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/p&gt;
              &lt;p&gt;&lt;button type=&quot;submit&quot;&gt;Sign In&lt;/button&gt;&lt;/p&gt;
              &lt;/form&gt;'''

@app.route('/signin', methods=['POST'])
def signin():
    # 需要从request对象读取表单内容：
    if request.form['username']=='admin' and request.form['password']=='password':
        return '&lt;h3&gt;Hello, admin!&lt;/h3&gt;'
    return '&lt;h3&gt;Bad username or password.&lt;/h3&gt;'

if __name__ == '__main__':
    app.run()
</code></pre>
<p>运行python app.py，Flask自带的Server在端口5000上监听：</p>
<pre><code>$ python app.py 
 * Running on http://127.0.0.1:5000/
</code></pre>
<p>GET /：打开浏览器，输入首页地址<code>http://localhost:5000/：</code><br>
首页显示Home则正确</p>
<p>GET /signin：再在浏览器地址栏输入<code>http://localhost:5000/signin</code>，会显示登录表单：</p>
<p>POST /signin：输入预设的用户名admin和口令password，登录成功：<br>
输入其他错误的用户名和口令，登录失败</p>
<p>实际的Web App应该拿到用户名和口令后，去数据库查询再比对，来判断用户是否能登录成功。</p>
<p>除了Flask，常见的Python Web框架还有：</p>
<ul>
<li>
<p>Django：全能型Web框架；</p>
</li>
<li>
<p>web.py：一个小巧的Web框架；</p>
</li>
<li>
<p>Bottle：和Flask类似的Web框架；</p>
</li>
<li>
<p>Tornado：Facebook的开源异步Web框架。</p>
</li>
</ul>
<p><strong>小结：</strong><br>
有了Web框架，我们在编写Web应用时，注意力就从WSGI处理函数转移到URL+对应的处理函数，这样，编写Web App就更加简单了。</p>
<p>在编写URL处理函数时，除了配置URL外，从HTTP请求拿到用户数据也是非常重要的。Web框架都提供了自己的API来实现这些功能。Flask通过<code>request.form['name']</code>来获取表单的内容。</p>
<h2 id="使用模板">使用模板</h2>
<p>Web框架把我们从WSGI中拯救出来了。现在，我们只需要不断地编写函数，带上URL，就可以继续Web App的开发了。</p>
<p>但是，Web App不仅仅是处理逻辑，展示给用户的页面也非常重要。在函数中返回一个包含HTML的字符串，简单的页面还可以，但是，想想新浪首页的6000多行的HTML</p>
<p>俗话说得好，不懂前端的Python工程师不是好的产品经理。有Web开发经验的同学都明白，Web App最复杂的部分就在HTML页面。HTML不仅要正确，还要通过CSS美化，再加上复杂的JavaScript脚本来实现各种交互和动画效果。总之，生成HTML页面的难度很大。</p>
<p>由于在Python代码里拼字符串是不现实的，所以，模板技术出现了。</p>
<h2 id="mvcmodel-view-controller">MVC：Model-View-Controller</h2>
<p>使用模板，我们需要预先准备一个HTML文档，这个HTML文档不是普通的HTML，而是嵌入了一些变量和指令，然后，根据我们传入的数据，替换后，得到最终的HTML，发送给用户：<br>
<img src="https://lixin-scut.github.io//post-images/1589379121294.png" alt=""></p>
<p>这就是传说中的<strong>MVC：Model-View-Controller，中文名“模型-视图-控制器”</strong>。</p>
<p><strong>Python处理URL的函数就是C：Controller</strong>，Controller负责<strong>业务逻辑</strong>，比如检查用户名是否存在，取出用户信息等等；</p>
<p><strong>包含变量{{ name }}的模板就是V：View</strong>，View负责<strong>显示逻辑</strong>，通过简单地替换一些变量，View最终输出的就是用户看到的HTML。</p>
<p>MVC中的Model在哪？<strong>Model是用来传给View的，这样View在替换变量的时候，就可以从Model中取出相应的数据。</strong></p>
<p>上面的例子中，Model就是一个dict：</p>
<pre><code>{ 'name': 'Michael' }
</code></pre>
<p>只是因为Python支持关键字参数，很多Web框架允许<strong>传入关键字参数，然后，在框架内部组装出一个dict作为Model</strong>。</p>
<p>现在，我们把上次直接输出字符串作为HTML的例子用高端大气上档次的MVC模式改写一下：</p>
<pre><code>from flask import Flask, request, render_template

app = Flask(__name__)

@app.route('/', methods=['GET', 'POST'])
def home():
    return render_template('home.html')

@app.route('/signin', methods=['GET'])
def signin_form():
    return render_template('form.html')

@app.route('/signin', methods=['POST'])
def signin():
    username = request.form['username']
    password = request.form['password']
    if username=='admin' and password=='password':
        return render_template('signin-ok.html', username=username)
    return render_template('form.html', message='Bad username or password', username=username)

if __name__ == '__main__':
    app.run()
</code></pre>
<p>Flask<strong>通过render_template()函数来实现模板的渲染</strong>。和Web框架类似，Python的模板也有很多种。Flask默认支持的模板是jinja2，所以我们先直接安装jinja2：</p>
<pre><code>$ pip install jinja2
</code></pre>
<p>然后，开始编写jinja2模板：</p>
<h3 id="homehtml">home.html</h3>
<p>用来显示首页的模板：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Home&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1 style=&quot;font-style:italic&quot;&gt;Home&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="formhtml">form.html</h3>
<p>用来显示登录表单的模板：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Please Sign In&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  {% if message %}
  &lt;p style=&quot;color:red&quot;&gt;{{ message }}&lt;/p&gt;
  {% endif %}
  &lt;form action=&quot;/signin&quot; method=&quot;post&quot;&gt;
    &lt;legend&gt;Please sign in:&lt;/legend&gt;
    &lt;p&gt;&lt;input name=&quot;username&quot; placeholder=&quot;Username&quot; value=&quot;{{ username }}&quot;&gt;&lt;/p&gt;
    &lt;p&gt;&lt;input name=&quot;password&quot; placeholder=&quot;Password&quot; type=&quot;password&quot;&gt;&lt;/p&gt;
    &lt;p&gt;&lt;button type=&quot;submit&quot;&gt;Sign In&lt;/button&gt;&lt;/p&gt;
  &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="signin-okhtml">signin-ok.html</h3>
<p>登录成功的模板：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Welcome, {{ username }}&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;p&gt;Welcome, {{ username }}!&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>登录失败的模板呢？我们在form.html中加了一点条件判断，把form.html重用为登录失败的模板。</p>
<p>最后，一定要把模板放到正确的templates目录下，templates和app.py在同级目录下，然后启动python app.py</p>
<p>通过MVC，我们<strong>在Python代码中处理M：Model和C：Controller</strong>，而V：View是通过模板处理的，这样，我们就成功地把Python代码和HTML代码最大限度地分离了。</p>
<p>使用模板的另一大好处是，<strong>模板改起来很方便</strong>，而且，改完保存后，刷新浏览器就能看到最新的效果，这对于调试HTML、CSS和JavaScript的前端工程师来说实在是太重要了。</p>
<p>在Jinja2模板中，我们<strong>用{{ name }}表示一个需要替换的变量。很多时候，还需要循环、条件判断等指令语句，在Jinja2中，用{% ... %}表示指令</strong>。</p>
<p>比如循环输出页码：</p>
<pre><code>{% for i in page_list %}
    &lt;a href=&quot;/page/{{ i }}&quot;&gt;{{ i }}&lt;/a&gt;
{% endfor %}
</code></pre>
<p>如果page_list是一个list：[1, 2, 3, 4, 5]，上面的模板将输出5个超链接。</p>
<p>除了Jinja2，常见的模板还有：</p>
<ul>
<li>
<p>Mako：用<code>&lt;% ... %&gt;</code>和<code>${xxx}</code>的一个模板；</p>
</li>
<li>
<p>Cheetah：也是用<code>&lt;% ... %&gt;</code>和<code>${xxx}</code>的一个模板；</p>
</li>
<li>
<p>Django：Django是一站式框架，内置一个用<code>{% ... %}</code>和<code>{{ xxx }}</code>的模板。</p>
</li>
</ul>
<p><strong>小结</strong></p>
<p>有了MVC，我们就分离了Python代码和HTML代码。HTML代码全部放到模板里，写起来更有效率。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python - 数据库]]></title>
        <id>https://lixin-scut.github.io//post/python-shu-ju-ku</id>
        <link href="https://lixin-scut.github.io//post/python-shu-ju-ku">
        </link>
        <updated>2020-05-13T08:56:56.000Z</updated>
        <content type="html"><![CDATA[<p>为了便于程序保存和读取数据，而且，能直接通过条件快速查询到指定的数据，就出现了数据库（Database）这种专门用于集中存储和查询的软件。</p>
<p>关系型数据库：两个表格有个映射关系，比如假设有两个表：Class表和Student表，根据班级idGrade_ID可以在班级表中查找到对应的所有班级，从而查询到这个班的所有学生信息，也就是Grade表的每一行对应Class表的多行，在关系数据库中，这种基于表（Table）的一对多的关系就是关系数据库的基础。</p>
<p>根据某个年级的ID就可以查找所有班级的行，这种查询语句在关系数据库中称为SQL语句，可以写成：</p>
<pre><code>SELECT * FROM classes WHERE grade_id = '1';
</code></pre>
<p>类似的，Class表的一行记录又可以关联到Student表的多行记录</p>
<h2 id="sqlite">SQLite</h2>
<p>SQLite是一种<strong>嵌入式数据库</strong>，它的<strong>数据库就是一个文件</strong>。由于SQLite本身是C写的，而且体积很小，所以，经常被集成到各种应用程序中，甚至在iOS和Android的App中都可以集成。</p>
<p><strong>Python就内置了SQLite3</strong>，所以，在Python中使用SQLite，不需要安装任何东西，直接使用。</p>
<p>在使用SQLite前，我们先要搞清楚几个概念：</p>
<p>表是数据库中<strong>存放关系数据的集合</strong>，一个数据库里面通常都包含多个表，比如学生的表，班级的表，学校的表，等等。<strong>表和表之间通过外键关联</strong>。</p>
<p>要操作<strong>关系数据库</strong>，首先需要连接到数据库，<strong>一个数据库连接称为Connection</strong>；</p>
<p>连接到数据库后，需要打开游标，称之为Cursor，通过Cursor执行SQL语句，然后，获得执行结果。</p>
<p>Python定义了一套操作数据库的API接口，任何数据库要连接到Python，只需要提供符合Python标准的数据库驱动即可。</p>
<p>由于SQLite的驱动内置在Python标准库中，所以我们可以直接来操作SQLite数据库。</p>
<p>我们在Python交互式命令行实践一下：</p>
<pre><code># 导入SQLite驱动:
&gt;&gt;&gt; import sqlite3
# 连接到SQLite数据库
# 数据库文件是test.db
# 如果文件不存在，会自动在当前目录创建:
&gt;&gt;&gt; conn = sqlite3.connect('test.db')
# 创建一个Cursor:
&gt;&gt;&gt; cursor = conn.cursor()
# 执行一条SQL语句，创建user表:
&gt;&gt;&gt; cursor.execute('create table user (id varchar(20) primary key, name varchar(20))')
&lt;sqlite3.Cursor object at 0x10f8aa260&gt;
# 继续执行一条SQL语句，插入一条记录:
&gt;&gt;&gt; cursor.execute('insert into user (id, name) values (\'1\', \'Michael\')')
&lt;sqlite3.Cursor object at 0x10f8aa260&gt;
# 通过rowcount获得插入的行数:
&gt;&gt;&gt; cursor.rowcount
1
# 关闭Cursor:
&gt;&gt;&gt; cursor.close()
# 提交事务:
&gt;&gt;&gt; conn.commit()
# 关闭Connection:
&gt;&gt;&gt; conn.close()
</code></pre>
<p>我们再试试查询记录：</p>
<pre><code>&gt;&gt;&gt; conn = sqlite3.connect('test.db')
&gt;&gt;&gt; cursor = conn.cursor()
# 执行查询语句:
&gt;&gt;&gt; cursor.execute('select * from user where id=?', ('1',))
&lt;sqlite3.Cursor object at 0x10f8aa340&gt;
# 获得查询结果集:
&gt;&gt;&gt; values = cursor.fetchall()
&gt;&gt;&gt; values
[('1', 'Michael')]
&gt;&gt;&gt; cursor.close()
&gt;&gt;&gt; conn.close()
</code></pre>
<p>使用Python的DB-API时，<strong>只要搞清楚Connection和Cursor对象，打开后一定记得关闭，就可以放心地使用</strong>。</p>
<p>使用Cursor对象执行<strong>insert，update，delete</strong>语句时，<strong>执行结果由rowcount返回影响的行数</strong>，就可以拿到执行结果。</p>
<p>使用Cursor对象执行<strong>select</strong>语句时，<strong>通过featchall()可以拿到结果集</strong>。结果集是一个<strong>list</strong>，每个元素都是一个<strong>tuple</strong>，对应一行记录。</p>
<p>如果SQL语句带有参数，那么需要<strong>把参数按照位置传递给execute()方法</strong>，有几个?占位符就必须对应几个参数，例如：</p>
<pre><code>cursor.execute('select * from user where name=? and pwd=?', ('abc', 'password'))
</code></pre>
<p>SQLite支持常见的标准SQL语句以及几种常见的数据类型。具体文档请参阅SQLite官方网站。</p>
<p><strong>小结</strong></p>
<p>在Python中操作数据库时，要<strong>先导入数据库对应的驱动</strong>，然后，<strong>通过Connection对象和Cursor对象操作数据</strong>。</p>
<p><strong>要确保打开的Connection对象和Cursor对象都正确地被关闭，否则，资源就会泄露。</strong></p>
<p>如何才能确保出错的情况下也关闭掉Connection对象和Cursor对象呢？请回忆try:...except:...finally:...的用法。</p>
<h2 id="mysql">MySQL</h2>
<p>MySQL是Web世界中使用最广泛的数据库服务器。SQLite的特点是轻量级、可嵌入，但<strong>不能承受高并发访问，适合桌面和移动应用</strong>。而MySQL是<strong>为服务器端设计的数据库，能承受高并发访问</strong>，同时占用的内存也远远大于SQLite。</p>
<p>此外，MySQL内部有多种数据库引擎，最常用的引擎是<strong>支持数据库事务</strong>的InnoDB。</p>
<h3 id="安装mysql">安装MySQL</h3>
<p>可以直接从MySQL官方网站下载最新的Community Server 5.6.x版本。MySQL是跨平台的，选择对应的平台下载安装文件，安装即可。</p>
<p>安装时，MySQL会提示输入root用户的口令，请务必记清楚。如果怕记不住，就把口令设置为password。</p>
<p>在Windows上，安装时请选择UTF-8编码，以便正确地处理中文。</p>
<p>在Mac或Linux上，需要编辑MySQL的配置文件，把数据库默认的编码全部改为UTF-8。MySQL的配置文件默认存放在<code>/etc/my.cnf</code>或者<code>/etc/mysql/my.cnf</code>：</p>
<pre><code>[client]
default-character-set = utf8

[mysqld]
default-storage-engine = INNODB
character-set-server = utf8
collation-server = utf8_general_ci
</code></pre>
<p>重启MySQL后，可以通过MySQL的客户端命令行检查编码：</p>
<pre><code>
$ mysql -u root -p
Enter password: 
Welcome to the MySQL monitor...
...

mysql&gt; show variables like '%char%';
+--------------------------+--------------------------------------------------------+
| Variable_name            | Value                                                  |
+--------------------------+--------------------------------------------------------+
| character_set_client     | utf8                                                   |
| character_set_connection | utf8                                                   |
| character_set_database   | utf8                                                   |
| character_set_filesystem | binary                                                 |
| character_set_results    | utf8                                                   |
| character_set_server     | utf8                                                   |
| character_set_system     | utf8                                                   |
| character_sets_dir       | /usr/local/mysql-5.1.65-osx10.6-x86_64/share/charsets/ |
+--------------------------+--------------------------------------------------------+
8 rows in set (0.00 sec)
</code></pre>
<p>看到utf8字样就表示编码设置正确。</p>
<p>注：如果MySQL的版本≥5.5.3，可以把编码设置为utf8mb4，utf8mb4和utf8完全兼容，但它支持最新的Unicode标准，可以显示emoji字符。</p>
<h3 id="安装mysql驱动">安装MySQL驱动</h3>
<p>由于MySQL服务器以独立的进程运行，并通过网络对外服务，所以，需要支持Python的MySQL驱动来连接到MySQL服务器。MySQL官方提供了mysql-connector-python驱动，但是安装的时候需要给pip命令加上参数<code>--allow-external</code>：</p>
<pre><code>$ pip install mysql-connector-python --allow-external mysql-connector-python
</code></pre>
<p>如果上面的命令安装失败，可以试试另一个驱动：</p>
<pre><code>$ pip install mysql-connector
</code></pre>
<p>我们演示如何连接到MySQL服务器的test数据库：</p>
<pre><code>
# 导入MySQL驱动:
&gt;&gt;&gt; import mysql.connector
# 注意把password设为你的root口令:
&gt;&gt;&gt; conn = mysql.connector.connect(user='root', password='password', database='test')
&gt;&gt;&gt; cursor = conn.cursor()
# 创建user表:
&gt;&gt;&gt; cursor.execute('create table user (id varchar(20) primary key, name varchar(20))')
# 插入一行记录，注意MySQL的占位符是%s:
&gt;&gt;&gt; cursor.execute('insert into user (id, name) values (%s, %s)', ['1', 'Michael'])
&gt;&gt;&gt; cursor.rowcount
1
# 提交事务:
&gt;&gt;&gt; conn.commit()
&gt;&gt;&gt; cursor.close()
# 运行查询:
&gt;&gt;&gt; cursor = conn.cursor()
&gt;&gt;&gt; cursor.execute('select * from user where id = %s', ('1',))
&gt;&gt;&gt; values = cursor.fetchall()
&gt;&gt;&gt; values
[('1', 'Michael')]
# 关闭Cursor和Connection:
&gt;&gt;&gt; cursor.close()
True
&gt;&gt;&gt; conn.close()
由于Python的DB-API定义都是通用的，所以，操作MySQL的数据库代码和SQLite类似。
</code></pre>
<p><strong>小结</strong></p>
<ol>
<li>
<p>执行INSERT等操作后要调用<code>commit()</code>提交事务；</p>
</li>
<li>
<p>MySQL的SQL占位符是<code>%s</code>。</p>
</li>
</ol>
<h2 id="sqlalchemy">SQLAlchemy</h2>
<p>数据库表是一个二维表，包含多行多列。把一个表的内容用Python的数据结构表示出来的话，可以<strong>用一个list表示多行</strong>，<strong>list的每一个元素是tuple</strong>，表示一行记录，比如，包含id和name的user表：</p>
<pre><code>[
    ('1', 'Michael'),
    ('2', 'Bob'),
    ('3', 'Adam')
]
</code></pre>
<p>Python的DB-API返回的数据结构就是像上面这样表示的。</p>
<p><strong>但是用tuple表示一行很难看出表的结构</strong>。如果把一个tupl<strong>e用class实例来表示</strong>，就可以更容易地看出表的结构来：</p>
<pre><code>class User(object):
    def __init__(self, id, name):
        self.id = id
        self.name = name

[
    User('1', 'Michael'),
    User('2', 'Bob'),
    User('3', 'Adam')
]
</code></pre>
<p>这就是传说中的ORM技术：Object-Relational Mapping，把关系数据库的表结构映射到对象上。是不是很简单？</p>
<p>但是由谁来做这个转换呢？所以ORM框架应运而生。</p>
<p>在Python中，最有名的ORM框架是SQLAlchemy。我们来看看SQLAlchemy的用法。</p>
<p>首先通过pip安装SQLAlchemy：</p>
<pre><code>$ pip install sqlalchemy
</code></pre>
<p>然后，利用上次我们在MySQL的test数据库中创建的user表，用SQLAlchemy来试试：</p>
<p>第一步，导入SQLAlchemy，并初始化DBSession：</p>
<pre><code>
# 导入:
from sqlalchemy import Column, String, create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base

# 创建对象的基类:
Base = declarative_base()

# 定义User对象:
class User(Base):
    # 表的名字:
    __tablename__ = 'user'

    # 表的结构:
    id = Column(String(20), primary_key=True)
    name = Column(String(20))

# 初始化数据库连接:
engine = create_engine('mysql+mysqlconnector://root:password@localhost:3306/test')
# 创建DBSession类型:
DBSession = sessionmaker(bind=engine)

</code></pre>
<p>以上代码完成SQLAlchemy的初始化和具体每个表的class定义。如果有多个表，就继续定义其他class，例如School：</p>
<pre><code>class School(Base):
    __tablename__ = 'school'
    id = ...
    name = ...
</code></pre>
<p>create_engine()用来初始化数据库连接。SQLAlchemy用一个字符串表示连接信息：</p>
<pre><code>'数据库类型+数据库驱动名称://用户名:口令@机器地址:端口号/数据库名'
</code></pre>
<p>你只需要根据需要替换掉用户名、口令等信息即可。</p>
<p>下面，我们看看如何向数据库表中添加一行记录。</p>
<p>由于有了ORM，我们向数据库表中添加一行记录，可以视为添加一个User对象：</p>
<pre><code>
# 创建session对象:
session = DBSession()
# 创建新User对象:
new_user = User(id='5', name='Bob')
# 添加到session:
session.add(new_user)
# 提交即保存到数据库:
session.commit()
# 关闭session:
session.close()

</code></pre>
<p>可见，关<strong>键是获取session，然后把对象添加到session，最后提交并关闭。DBSession对象可视为当前数据库连接</strong>。</p>
<p>如何从数据库表中查询数据呢？<strong>有了ORM，查询出来的可以不再是tuple，而是User对象</strong>。SQLAlchemy提供的查询接口如下：</p>
<pre><code># 创建Session:
session = DBSession()
# 创建Query查询，filter是where条件，最后调用one()返回唯一行，如果调用all()则返回所有行:
user = session.query(User).filter(User.id=='5').one()
# 打印类型和对象的name属性:
print('type:', type(user))
print('name:', user.name)
# 关闭Session:
session.close()
</code></pre>
<p>运行结果如下：</p>
<pre><code>type: &lt;class '__main__.User'&gt;
name: Bob
</code></pre>
<p>可见，ORM就是把数据库表的行与相应的对象建立关联，互相转换。</p>
<p>由于关系数据库的<strong>多个表还可以用外键实现一对多、多对多等关联</strong>，相应地，ORM框架也可以<strong>提供两个对象之间的一对多、多对多等功能</strong>。</p>
<p>例如，如果一个User拥有多个Book，就可以定义一对多关系如下：</p>
<pre><code>class User(Base):
    __tablename__ = 'user'

    id = Column(String(20), primary_key=True)
    name = Column(String(20))
    # 一对多:
    books = relationship('Book')

class Book(Base):
    __tablename__ = 'book'

    id = Column(String(20), primary_key=True)
    name = Column(String(20))
    # “多”的一方的book表是通过外键关联到user表的:
    user_id = Column(String(20), ForeignKey('user.id'))
</code></pre>
<p>当我们<strong>查询一个User对象时，该对象的books属性将返回一个包含若干个Book对象的list</strong>。</p>
<p><strong>小结</strong></p>
<p>ORM框架的作用就是把数据库表的一行记录与一个对象互相做自动转换。</p>
<p>正确使用ORM的前提是了解关系数据库的原理。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python - 网络编程	]]></title>
        <id>https://lixin-scut.github.io//post/python-wang-luo-bian-cheng</id>
        <link href="https://lixin-scut.github.io//post/python-wang-luo-bian-cheng">
        </link>
        <updated>2020-05-13T08:21:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="tcpip简介">TCP/IP简介</h2>
<p>虽然大家现在对互联网很熟悉，但是计算机网络的出现比互联网要早很多。</p>
<p>计算机为了联网，就必须规定通信协议，早期的计算机网络，都是由各厂商自己规定一套协议，IBM、Apple和Microsoft都有各自的网络协议，互不兼容，这就好比一群人有的说英语，有的说中文，有的说德语，说同一种语言的人可以交流，不同的语言之间就不行了。</p>
<p>为了把全世界的所有不同类型的计算机都连接起来，就必须规定一套全球通用的协议，为了实现互联网这个目标，互联网协议簇（Internet Protocol Suite）就是通用协议标准。Internet是由inter和net两个单词组合起来的，原意就是连接“网络”的网络，有了Internet，任何私有网络，只要支持这个协议，就可以联入互联网。</p>
<p>因为互联网协议包含了上百种协议标准，但是最重要的两个协议是TCP和IP协议，所以，大家把互联网的协议简称TCP/IP协议。</p>
<p>通信的时候，双方必须知道对方的标识，好比发邮件必须知道对方的邮件地址。互联网上每个计算机的唯一标识就是IP地址，类似123.123.123.123。如果一台计算机同时接入到两个或更多的网络，比如路由器，它就会有两个或多个IP地址，所以，IP地址对应的实际上是计算机的网络接口，通常是网卡。</p>
<p>IP协议负责把数据从一台计算机通过网络发送到另一台计算机。数据被分割成一小块一小块，然后通过IP包发送出去。由于互联网链路复杂，两台计算机之间经常有多条线路，因此，路由器就负责决定如何把一个IP包转发出去。IP包的特点是按块发送，途径多个路由，但不保证能到达，也不保证顺序到达。</p>
<p>P地址实际上是一个32位整数（称为IPv4），以字符串表示的IP地址如192.168.0.1实际上是把32位整数按8位分组后的数字表示，目的是便于阅读。</p>
<p>IPv6地址实际上是一个128位整数，它是目前使用的IPv4的升级版，以字符串表示类似于<code>2001:0db8:85a3:0042:1000:8a2e:0370:7334</code>。</p>
<p>TCP协议则是建立在IP协议之上的。TCP协议负责在两台计算机之间建立可靠连接，保证数据包按顺序到达。TCP协议会通过握手建立连接，然后，对每个IP包编号，确保对方按顺序收到，如果包丢掉了，就自动重发。</p>
<p>许多常用的更高级的协议都是建立在TCP协议基础上的，比如用于浏览器的HTTP协议、发送邮件的SMTP协议等。</p>
<p>一个TCP报文除了包含要传输的数据外，还包含源IP地址和目标IP地址，源端口和目标端口。</p>
<p>端口有什么作用？在两台计算机通信时，只发IP地址是不够的，因为同一台计算机上跑着多个网络程序。一个TCP报文来了之后，到底是交给浏览器还是QQ，就需要端口号来区分。每个网络程序都向操作系统申请唯一的端口号，这样，两个进程在两台计算机之间建立网络连接就需要各自的IP地址和各自的端口号。</p>
<p>一个进程也可能同时与多个计算机建立链接，因此它会申请很多端口。</p>
<h2 id="tcp编程">TCP编程</h2>
<p>Socket是网络编程的一个抽象概念。通常我们用一个Socket表示“打开了一个网络链接”，而打开一个Socket需要知道目标计算机的IP地址和端口号，再指定协议类型即可。</p>
<h3 id="客户端">客户端</h3>
<p>大多数连接都是可靠的TCP连接。创建TCP连接时，主动发起连接的叫客户端，被动响应连接的叫服务器。</p>
<p>举个例子，当我们在浏览器中访问新浪时，我们自己的计算机就是客户端，浏览器会主动向新浪的服务器发起连接。如果一切顺利，新浪的服务器接受了我们的连接，一个TCP连接就建立起来的，后面的通信就是发送网页内容了。</p>
<p>所以，我们要创建一个基于TCP连接的Socket，可以这样做：</p>
<pre><code>
# 导入socket库:
import socket

# 创建一个socket:
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# 建立连接:
s.connect(('www.sina.com.cn', 80))

</code></pre>
<p>创建Socket时，AF_INET指定使用IPv4协议，如果要用更先进的IPv6，就指定为AF_INET6。SOCK_STREAM指定使用面向流的TCP协议，这样，一个Socket对象就创建成功，但是还没有建立连接。</p>
<p>客户端要主动发起TCP连接，必须知道服务器的IP地址和端口号。新浪网站的IP地址可以用域名<code>www.sina.com.cn</code>自动转换到IP地址，但是怎么知道新浪服务器的端口号呢？</p>
<p>答案是作为服务器，提供什么样的服务，端口号就必须固定下来。由于我们想要访问网页，因此新浪提供网页服务的服务器必须把端口号固定在80端口，因为80端口是Web服务的标准端口。其他服务都有对应的标准端口号，例如SMTP服务是25端口，FTP服务是21端口，等等。端口号小于1024的是Internet标准服务的端口，端口号大于1024的，可以任意使用。</p>
<p>因此，我们连接新浪服务器的代码如下：</p>
<pre><code>s.connect(('www.sina.com.cn', 80))
</code></pre>
<p>注意<strong>参数是一个tuple</strong>，<strong>包含地址和端口号</strong>。</p>
<p>建立TCP连接后，我们就可以向新浪服务器发送请求，要求返回首页的内容：</p>
<pre><code>
# 发送数据:
s.send(b'GET / HTTP/1.1\r\nHost: www.sina.com.cn\r\nConnection: close\r\n\r\n')

</code></pre>
<p>TCP连接创建的是双向通道，双方都可以同时给对方发数据。但是谁先发谁后发，怎么协调，要根据具体的协议来决定。例如，HTTP协议规定客户端必须先发请求给服务器，服务器收到后才发数据给客户端。</p>
<p>发送的文本格式必须符合HTTP标准，如果格式没问题，接下来就可以接收新浪服务器返回的数据了：</p>
<pre><code>
# 接收数据:
buffer = []
while True:
    # 每次最多接收1k字节:
    d = s.recv(1024)
    if d:
        buffer.append(d)
    else:
        break
data = b''.join(buffer)

</code></pre>
<p>接收数据时，调用recv(max)方法，一次最多接收指定的字节数，因此，在一个while循环中反复接收，直到recv()返回空数据，表示接收完毕，退出循环。</p>
<p>当我们接收完数据后，调用close()方法关闭Socket，这样，一次完整的网络通信就结束了：</p>
<pre><code>
# 关闭连接:
s.close()

</code></pre>
<p>接收到的数据包括HTTP头和网页本身，我们只需要把HTTP头和网页分离一下，把HTTP头打印出来，网页内容保存到文件：</p>
<pre><code>
header, html = data.split(b'\r\n\r\n', 1)
print(header.decode('utf-8'))
# 把接收的数据写入文件:
with open('sina.html', 'wb') as f:
    f.write(html)
		
</code></pre>
<p>现在，只需要在浏览器中打开这个sina.html文件，就可以看到新浪的首页了。</p>
<h3 id="服务器">服务器</h3>
<p>和客户端编程相比，服务器编程就要复杂一些。</p>
<p>服务器进程首先要绑定一个端口并监听来自其他客户端的连接。如果某个客户端连接过来了，服务器就与该客户端建立Socket连接，随后的通信就靠这个Socket连接了。</p>
<p>所以，服务器会打开固定端口（比如80）监听，每来一个客户端连接，就创建该Socket连接。由于服务器会有大量来自客户端的连接，所以，服务器要能够区分一个Socket连接是和哪个客户端绑定的。一个Socket依赖4项：服务器地址、服务器端口、客户端地址、客户端端口来唯一确定一个Socket。</p>
<p>但是服务器还需要同时响应多个客户端的请求，所以，每个连接都需要一个新的进程或者新的线程来处理，否则，服务器一次就只能服务一个客户端了。</p>
<p>我们来编写一个简单的服务器程序，它接收客户端连接，把客户端发过来的字符串加上Hello再发回去。</p>
<p>首先，创建一个基于IPv4和TCP协议的Socket：</p>
<pre><code>s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
</code></pre>
<p>然后，我们要绑定监听的地址和端口。服务器可能有多块网卡，可以绑定到某一块网卡的IP地址上，也可以用0.0.0.0绑定到所有的网络地址，还可以用127.0.0.1绑定到本机地址。127.0.0.1是一个特殊的IP地址，表示本机地址，如果绑定到这个地址，客户端必须同时在本机运行才能连接，也就是说，外部的计算机无法连接进来。</p>
<p>端口号需要预先指定。因为我们写的这个服务不是标准服务，所以用9999这个端口号。请注意，<strong>小于1024的端口号必须要有管理员权限才能绑定</strong>：</p>
<pre><code># 监听端口:
s.bind(('127.0.0.1', 9999))
</code></pre>
<p>紧接着，调用listen()方法开始监听端口，传入的参数指定等待连接的最大数量：</p>
<pre><code>s.listen(5)
print('Waiting for connection...')
</code></pre>
<p>接下来，服务器程序通过一个永久循环来接受来自客户端的连接，accept()会等待并返回一个客户端的连接:</p>
<pre><code>while True:
    # 接受一个新连接:
    sock, addr = s.accept()
    # 创建新线程来处理TCP连接:
    t = threading.Thread(target=tcplink, args=(sock, addr))
    t.start()
</code></pre>
<p><strong>每个连接都必须创建新线程（或进程）来处理，否则，单线程在处理连接的过程中，无法接受其他客户端的连接</strong>：</p>
<pre><code>def tcplink(sock, addr):
    print('Accept new connection from %s:%s...' % addr)
    sock.send(b'Welcome!')
    while True:
        data = sock.recv(1024)
        time.sleep(1)
        if not data or data.decode('utf-8') == 'exit':
            break
        sock.send(('Hello, %s!' % data.decode('utf-8')).encode('utf-8'))
    sock.close()
    print('Connection from %s:%s closed.' % addr)
</code></pre>
<p>连接建立后，服务器首先发一条欢迎消息，然后等待客户端数据，并加上Hello再发送给客户端。如果客户端发送了exit字符串，就直接关闭连接。</p>
<p>要测试这个服务器程序，我们还需要编写一个客户端程序：</p>
<pre><code>
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# 建立连接:
s.connect(('127.0.0.1', 9999))
# 接收欢迎消息:
print(s.recv(1024).decode('utf-8'))
for data in [b'Michael', b'Tracy', b'Sarah']:
    # 发送数据:
    s.send(data)
    print(s.recv(1024).decode('utf-8'))
s.send(b'exit')
s.close()

</code></pre>
<p>我们需要打开两个命令行窗口，一个运行服务器程序，另一个运行客户端程序，就可以看到效果了：</p>
<pre><code>
┌────────────────────────────────────────────────────────┐
│Command Prompt                                    - □ x │
├────────────────────────────────────────────────────────┤
│$ python echo_server.py                                 │
│Waiting for connection...                               │
│Accept new connection from 127.0.0.1:64398...           │
│Connection from 127.0.0.1:64398 closed.                 │
│                                                        │
│       ┌────────────────────────────────────────────────┴───────┐
│       │Command Prompt                                    - □ x │
│       ├────────────────────────────────────────────────────────┤
│       │$ python echo_client.py                                 │
│       │Welcome!                                                │
│       │Hello, Michael!                                         │
└───────┤Hello, Tracy!                                           │
        │Hello, Sarah!                                           │
        │$                                                       │
        │                                                        │
        │                                                        │
        └────────────────────────────────────────────────────────┘
				
</code></pre>
<p>需要注意的是，客户端程序运行完毕就退出了，而服务器程序会永远运行下去，必须按Ctrl+C退出程序。</p>
<p><strong>小结</strong></p>
<p>用TCP协议进行Socket编程在Python中十分简单，对于客户端，要主动连接服务器的IP和指定端口，对于服务器，要首先监听指定端口，然后，对每一个新的连接，创建一个线程或进程来处理。通常，服务器程序会无限运行下去。</p>
<p>同一个端口，被一个Socket绑定了以后，就不能被别的Socket绑定了。</p>
<h2 id="udp编程">UDP编程</h2>
<p>TCP是建立可靠连接，并且通信双方都可以以流的形式发送数据。相对TCP，UDP则是面向无连接的协议。</p>
<p>使用UDP协议时，不需要建立连接，只需要知道对方的IP地址和端口号，就可以直接发数据包。但是，能不能到达就不知道了。</p>
<p>虽然用UDP传输数据不可靠，但它的优点是和TCP比，速度快，对于不要求可靠到达的数据，就可以使用UDP协议。</p>
<p>我们来看看如何通过UDP协议传输数据。和TCP类似，使用UDP的通信双方也分为客户端和服务器。服务器首先需要绑定端口：</p>
<pre><code>
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
# 绑定端口:
s.bind(('127.0.0.1', 9999))

</code></pre>
<p>创建Socket时，SOCK_DGRAM指定了这个Socket的类型是UDP。绑定端口和TCP一样，但是<strong>不需要调用listen()方法，而是直接接收来自任何客户端的数据</strong>：</p>
<pre><code>
print('Bind UDP on 9999...')
while True:
    # 接收数据:
    data, addr = s.recvfrom(1024)
    print('Received from %s:%s.' % addr)
    s.sendto(b'Hello, %s!' % data, addr)
		
</code></pre>
<p>recvfrom()方法返回数据和客户端的地址与端口，这样，服务器收到数据后，直接调用sendto()就可以把数据用UDP发给客户端。</p>
<p>注意这里省掉了多线程，因为这个例子很简单。</p>
<p>客户端使用UDP时，首先仍然创建基于UDP的Socket，然后，不需要调用connect()，直接通过sendto()给服务器发数据：</p>
<pre><code>s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
for data in [b'Michael', b'Tracy', b'Sarah']:
    # 发送数据:
    s.sendto(data, ('127.0.0.1', 9999))
    # 接收数据:
    print(s.recv(1024).decode('utf-8'))
s.close()
</code></pre>
<p>从服务器接收数据仍然调用recv()方法。</p>
<p>仍然用两个命令行分别启动服务器和客户端测试，结果如下：</p>
<pre><code>
┌────────────────────────────────────────────────────────┐
│Command Prompt                                    - □ x │
├────────────────────────────────────────────────────────┤
│$ python udp_server.py                                  │
│Bind UDP on 9999...                                     │
│Received from 127.0.0.1:63823...                        │
│Received from 127.0.0.1:63823...                        │
│Received from 127.0.0.1:63823...                        │
│       ┌────────────────────────────────────────────────┴───────┐
│       │Command Prompt                                    - □ x │
│       ├────────────────────────────────────────────────────────┤
│       │$ python udp_client.py                                  │
│       │Welcome!                                                │
│       │Hello, Michael!                                         │
└───────┤Hello, Tracy!                                           │
        │Hello, Sarah!                                           │
        │$                                                       │
        │                                                        │
        │                                                        │
        └────────────────────────────────────────────────────────┘
</code></pre>
<p><strong>小结</strong></p>
<p>UDP的使用与TCP类似，但是不需要建立连接。此外，服务器绑定UDP端口和TCP端口互不冲突，也就是说，UDP的9999端口与TCP的9999端口可以各自绑定。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python - 常用第三方模块]]></title>
        <id>https://lixin-scut.github.io//post/python-chang-yong-di-san-fang-mo-kuai</id>
        <link href="https://lixin-scut.github.io//post/python-chang-yong-di-san-fang-mo-kuai">
        </link>
        <updated>2020-05-13T07:24:22.000Z</updated>
        <content type="html"><![CDATA[<p>除了内建的模块外，Python还有大量的第三方模块。</p>
<p>基本上，所有的第三方模块都会在PyPI - the Python Package Index上注册，只要找到对应的模块名字，即可用pip安装。</p>
<p>此外，在安装第三方模块一节中，我们强烈推荐安装Anaconda，安装后，数十个常用的第三方模块就已经就绪，不用pip手动安装。</p>
<h2 id="pillow-图像处理">Pillow - 图像处理</h2>
<p>PIL：Python Imaging Library，已经是Python平台事实上的图像处理标准库了。PIL功能非常强大，但API却非常简单易用。</p>
<p>由于PIL仅支持到Python 2.7，加上年久失修，于是一群志愿者在PIL的基础上创建了兼容的版本，名字叫Pillow，支持最新Python 3.x，又加入了许多新特性，因此，我们可以直接安装使用Pillow。</p>
<h3 id="安装pillow">安装Pillow</h3>
<p>如果安装了Anaconda，Pillow就已经可用了。否则，需要在命令行下通过pip安装：</p>
<pre><code>$ pip install pillow
</code></pre>
<p>如果遇到Permission denied安装失败，请加上sudo重试。</p>
<h3 id="操作图像">操作图像</h3>
<p>来看看最常见的图像缩放操作，只需三四行代码：</p>
<pre><code>
from PIL import Image

# 打开一个jpg图像文件，注意是当前路径:
im = Image.open('test.jpg')
# 获得图像尺寸:
w, h = im.size
print('Original image size: %sx%s' % (w, h))
# 缩放到50%:
im.thumbnail((w//2, h//2))
print('Resize image to: %sx%s' % (w//2, h//2))
# 把缩放后的图像用jpeg格式保存:
im.save('thumbnail.jpg', 'jpeg')

</code></pre>
<p>其他功能如切片、旋转、滤镜、输出文字、调色板等一应俱全。</p>
<p>比如，模糊效果也只需几行代码：</p>
<pre><code>from PIL import Image, ImageFilter

# 打开一个jpg图像文件，注意是当前路径:
im = Image.open('test.jpg')
# 应用模糊滤镜:
im2 = im.filter(ImageFilter.BLUR)
im2.save('blur.jpg', 'jpeg')

</code></pre>
<p>PIL的ImageDraw提供了一系列绘图方法，让我们可以直接绘图。比如要生成字母验证码图片：</p>
<pre><code>from PIL import Image, ImageDraw, ImageFont, ImageFilter

import random

# 随机字母:
def rndChar():
    return chr(random.randint(65, 90))

# 随机颜色1:
def rndColor():
    return (random.randint(64, 255), random.randint(64, 255), random.randint(64, 255))

# 随机颜色2:
def rndColor2():
    return (random.randint(32, 127), random.randint(32, 127), random.randint(32, 127))

# 240 x 60:
width = 60 * 4
height = 60
image = Image.new('RGB', (width, height), (255, 255, 255))
# 创建Font对象:
font = ImageFont.truetype('Arial.ttf', 36)
# 创建Draw对象:
draw = ImageDraw.Draw(image)
# 填充每个像素:
for x in range(width):
    for y in range(height):
        draw.point((x, y), fill=rndColor())
# 输出文字:
for t in range(4):
    draw.text((60 * t + 10, 10), rndChar(), font=font, fill=rndColor2())
# 模糊:
image = image.filter(ImageFilter.BLUR)
image.save('code.jpg', 'jpeg')

</code></pre>
<p>如果运行的时候报错：<br>
<code>IOError: cannot open resource</code><br>
这是因为PIL无法定位到字体文件的位置，可以根据操作系统提供绝对路径，比如：<br>
<code>'/Library/Fonts/Arial.ttf'</code><br>
要详细了解PIL的强大功能，请请参考Pillow官方文档：</p>
<p><code>https://pillow.readthedocs.org/</code></p>
<h3 id="小结">小结</h3>
<p>PIL提供了操作图像的强大功能，可以通过简单的代码完成复杂的图像处理。</p>
<h2 id="requests-处理url资源">requests - 处理URL资源</h2>
<p>我们已经讲解了Python内置的urllib模块，用于访问网络资源。但是，它用起来比较麻烦，而且，缺少很多实用的高级功能。</p>
<p>更好的方案是使用requests。它是一个Python第三方库，处理URL资源特别方便。</p>
<h3 id="安装requests">安装requests</h3>
<p>如果安装了Anaconda，requests就已经可用了。否则，需要在命令行下通过pip安装：</p>
<pre><code>$ pip install requests
</code></pre>
<p>如果遇到Permission denied安装失败，请加上sudo重试。</p>
<h3 id="使用requests">使用requests</h3>
<p>要通过GET访问一个页面，只需要几行代码：</p>
<pre><code>&gt;&gt;&gt; import requests
&gt;&gt;&gt; r = requests.get('https://www.douban.com/') # 豆瓣首页
&gt;&gt;&gt; r.status_code
200
&gt;&gt;&gt; r.text
r.text
'&lt;!DOCTYPE HTML&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta name=&quot;description&quot; content=&quot;提供图书、电影、音乐唱片的推荐、评论和...'
</code></pre>
<p>对于带参数的URL，传入一个dict作为params参数：</p>
<pre><code>&gt;&gt;&gt; r = requests.get('https://www.douban.com/search', params={'q': 'python', 'cat': '1001'})
&gt;&gt;&gt; r.url # 实际请求的URL
'https://www.douban.com/search?q=python&amp;cat=1001'
</code></pre>
<p>requests自动检测编码，可以使用encoding属性查看：</p>
<pre><code>&gt;&gt;&gt; r.encoding
'utf-8'
</code></pre>
<p>无论响应是文本还是二进制内容，我们都可以用content属性获得bytes对象：</p>
<pre><code>&gt;&gt;&gt; r.content
b'&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;\n...'
</code></pre>
<p>requests的方便之处还在于，对于特定类型的响应，例如JSON，可以直接获取：</p>
<pre><code>&gt;&gt;&gt; r = requests.get('https://query.yahooapis.com/v1/public/yql?q=select%20*%20from%20weather.forecast%20where%20woeid%20%3D%202151330&amp;format=json')
&gt;&gt;&gt; r.json()
{'query': {'count': 1, 'created': '2017-11-17T07:14:12Z', ...
</code></pre>
<p>需要传入HTTP Header时，我们传入一个dict作为headers参数：</p>
<pre><code>&gt;&gt;&gt; r = requests.get('https://www.douban.com/', headers={'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit'})
&gt;&gt;&gt; r.text
'&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;UTF-8&quot;&gt;\n &lt;title&gt;豆瓣(手机版)&lt;/title&gt;...'
</code></pre>
<p>要发送POST请求，只需要把get()方法变成post()，然后传入data参数作为POST请求的数据：</p>
<pre><code>&gt;&gt;&gt; r = requests.post('https://accounts.douban.com/login', data={'form_email': 'abc@example.com', 'form_password': '123456'})
</code></pre>
<p>requests默认使用<code>application/x-www-form-urlencoded</code>对POST数据编码。如果要传递JSON数据，可以直接传入json参数：</p>
<pre><code>params = {'key': 'value'}
r = requests.post(url, json=params) # 内部自动序列化为JSON
</code></pre>
<p>类似的，上传文件需要更复杂的编码格式，但是requests把它简化成files参数：</p>
<pre><code>&gt;&gt;&gt; upload_files = {'file': open('report.xls', 'rb')}
&gt;&gt;&gt; r = requests.post(url, files=upload_files)
</code></pre>
<p>在读取文件时，注意务必使用'rb'即二进制模式读取，这样获取的bytes长度才是文件的长度。</p>
<p>把post()方法替换为put()，delete()等，就可以以PUT或DELETE方式请求资源。</p>
<p>除了能轻松获取响应内容外，requests对获取HTTP响应的其他信息也非常简单。例如，获取响应头：</p>
<pre><code>&gt;&gt;&gt; r.headers
{Content-Type': 'text/html; charset=utf-8', 'Transfer-Encoding': 'chunked', 'Content-Encoding': 'gzip', ...}
&gt;&gt;&gt; r.headers['Content-Type']
'text/html; charset=utf-8'
</code></pre>
<p>requests对Cookie做了特殊处理，使得我们不必解析Cookie就可以轻松获取指定的Cookie：</p>
<pre><code>&gt;&gt;&gt; r.cookies['ts']
'example_cookie_12345'
</code></pre>
<p>要在请求中传入Cookie，只需准备一个dict传入cookies参数：</p>
<pre><code>&gt;&gt;&gt; cs = {'token': '12345', 'status': 'working'}
&gt;&gt;&gt; r = requests.get(url, cookies=cs)
</code></pre>
<p>最后，要指定超时，传入以秒为单位的timeout参数：</p>
<pre><code>&gt;&gt;&gt; r = requests.get(url, timeout=2.5) # 2.5秒后超时
</code></pre>
<h2 id="chardet-字符串编码检测">chardet - 字符串编码检测</h2>
<p>字符串编码一直是令人非常头疼的问题，尤其是我们在处理一些不规范的第三方网页的时候。虽然Python提供了Unicode表示的str和bytes两种数据类型，并且可以通过encode()和decode()方法转换，但是，在不知道编码的情况下，对bytes做decode()不好做。</p>
<p>对于未知编码的bytes，要把它转换成str，需要先“猜测”编码。猜测的方式是先收集各种编码的特征字符，根据特征字符判断，就能有很大概率“猜对”。</p>
<p>当然，我们肯定不能从头自己写这个检测编码的功能，这样做费时费力。chardet这个第三方库正好就派上了用场。用它来检测编码，简单易用。</p>
<h3 id="安装chardet">安装chardet</h3>
<p>如果安装了Anaconda，chardet就已经可用了。否则，需要在命令行下通过pip安装：</p>
<pre><code>$ pip install chardet
</code></pre>
<p>如果遇到Permission denied安装失败，请加上sudo重试。</p>
<h3 id="使用chardet">使用chardet</h3>
<p>当我们拿到一个bytes时，就可以对其检测编码。用chardet检测编码，只需要一行代码：</p>
<pre><code>&gt;&gt;&gt; chardet.detect(b'Hello, world!')
{'encoding': 'ascii', 'confidence': 1.0, 'language': ''}
</code></pre>
<p>检测出的编码是ascii，注意到还有个confidence字段，表示检测的概率是1.0（即100%）。</p>
<p>我们来试试检测GBK编码的中文：</p>
<pre><code>&gt;&gt;&gt; data = '离离原上草，一岁一枯荣'.encode('gbk')
&gt;&gt;&gt; chardet.detect(data)
{'encoding': 'GB2312', 'confidence': 0.7407407407407407, 'language': 'Chinese'}
</code></pre>
<p>检测的编码是GB2312，注意到GBK是GB2312的超集，两者是同一种编码，检测正确的概率是74%，language字段指出的语言是'Chinese'。</p>
<p>对UTF-8编码进行检测：</p>
<pre><code>&gt;&gt;&gt; data = '离离原上草，一岁一枯荣'.encode('utf-8')
&gt;&gt;&gt; chardet.detect(data)
{'encoding': 'utf-8', 'confidence': 0.99, 'language': ''}
</code></pre>
<p>我们再试试对日文进行检测：</p>
<pre><code>&gt;&gt;&gt; data = '最新の主要ニュース'.encode('euc-jp')
&gt;&gt;&gt; chardet.detect(data)
{'encoding': 'EUC-JP', 'confidence': 0.99, 'language': 'Japanese'}
</code></pre>
<p>可见，用chardet检测编码，使用简单。获取到编码后，再转换为str，就可以方便后续处理。</p>
<p>chardet支持检测的编码列表请参考官方文档Supported encodings。</p>
<h2 id="psutil">psutil</h2>
<p>用Python来编写脚本简化日常的运维工作是Python的一个重要用途。在Linux下，有许多系统命令可以让我们时刻监控系统运行的状态，如ps，top，free等等。要获取这些系统信息，Python可以通过subprocess模块调用并获取结果。但这样做显得很麻烦，尤其是要写很多解析代码。</p>
<p>在Python中获取系统信息的另一个好办法是使用psutil这个第三方模块。顾名思义，psutil = process and system utilities，它不仅可以通过一两行代码实现系统监控，还可以跨平台使用，支持Linux／UNIX／OSX／Windows等，是系统管理员和运维小伙伴不可或缺的必备模块。</p>
<h3 id="安装psutil-系统监控">安装psutil - 系统监控</h3>
<p>如果安装了Anaconda，psutil就已经可用了。否则，需要在命令行下通过pip安装：</p>
<pre><code>$ pip install psutil
</code></pre>
<p>如果遇到Permission denied安装失败，请加上sudo重试。</p>
<h3 id="获取cpu信息">获取CPU信息</h3>
<p>我们先来获取CPU的信息：</p>
<pre><code>&gt;&gt;&gt; import psutil
&gt;&gt;&gt; psutil.cpu_count() # CPU逻辑数量
4
&gt;&gt;&gt; psutil.cpu_count(logical=False) # CPU物理核心
2
# 2说明是双核超线程, 4则是4核非超线程
</code></pre>
<p>统计CPU的用户／系统／空闲时间：</p>
<pre><code>&gt;&gt;&gt; psutil.cpu_times()
scputimes(user=10963.31, nice=0.0, system=5138.67, idle=356102.45)
</code></pre>
<p>再实现类似top命令的CPU使用率，每秒刷新一次，累计10次：</p>
<pre><code>&gt;&gt;&gt; for x in range(10):
...     print(psutil.cpu_percent(interval=1, percpu=True))
... 
[14.0, 4.0, 4.0, 4.0]
[12.0, 3.0, 4.0, 3.0]
[8.0, 4.0, 3.0, 4.0]
[12.0, 3.0, 3.0, 3.0]
[18.8, 5.1, 5.9, 5.0]
[10.9, 5.0, 4.0, 3.0]
[12.0, 5.0, 4.0, 5.0]
[15.0, 5.0, 4.0, 4.0]
[19.0, 5.0, 5.0, 4.0]
[9.0, 3.0, 2.0, 3.0]
</code></pre>
<h3 id="获取内存信息">获取内存信息</h3>
<p>使用psutil获取物理内存和交换内存信息，分别使用：</p>
<pre><code>&gt;&gt;&gt; psutil.virtual_memory()
svmem(total=8589934592, available=2866520064, percent=66.6, used=7201386496, free=216178688, active=3342192640, inactive=2650341376, wired=1208852480)
&gt;&gt;&gt; psutil.swap_memory()
sswap(total=1073741824, used=150732800, free=923009024, percent=14.0, sin=10705981440, sout=40353792)
</code></pre>
<p>返回的是字节为单位的整数，可以看到，总内存大小是8589934592 = 8 GB，已用7201386496 = 6.7 GB，使用了66.6%。</p>
<p>而交换区大小是1073741824 = 1 GB。</p>
<h3 id="获取磁盘信息">获取磁盘信息</h3>
<p>可以通过psutil获取磁盘分区、磁盘使用率和磁盘IO信息：</p>
<pre><code>&gt;&gt;&gt; psutil.disk_partitions() # 磁盘分区信息
[sdiskpart(device='/dev/disk1', mountpoint='/', fstype='hfs', opts='rw,local,rootfs,dovolfs,journaled,multilabel')]
&gt;&gt;&gt; psutil.disk_usage('/') # 磁盘使用情况
sdiskusage(total=998982549504, used=390880133120, free=607840272384, percent=39.1)
&gt;&gt;&gt; psutil.disk_io_counters() # 磁盘IO
sdiskio(read_count=988513, write_count=274457, read_bytes=14856830464, write_bytes=17509420032, read_time=2228966, write_time=1618405)
可以看到，磁盘'/'的总容量是998982549504 = 930 GB，使用了39.1%。文件格式是HFS，opts中包含rw表示可读写，journaled表示支持日志。
</code></pre>
<h3 id="获取网络信息">获取网络信息</h3>
<p>psutil可以获取网络接口和网络连接信息：</p>
<pre><code>&gt;&gt;&gt; psutil.net_io_counters() # 获取网络读写字节／包的个数
snetio(bytes_sent=3885744870, bytes_recv=10357676702, packets_sent=10613069, packets_recv=10423357, errin=0, errout=0, dropin=0, dropout=0)
&gt;&gt;&gt; psutil.net_if_addrs() # 获取网络接口信息
{
  'lo0': [snic(family=&lt;AddressFamily.AF_INET: 2&gt;, address='127.0.0.1', netmask='255.0.0.0'), ...],
  'en1': [snic(family=&lt;AddressFamily.AF_INET: 2&gt;, address='10.0.1.80', netmask='255.255.255.0'), ...],
  'en0': [...],
  'en2': [...],
  'bridge0': [...]
}
&gt;&gt;&gt; psutil.net_if_stats() # 获取网络接口状态
{
  'lo0': snicstats(isup=True, duplex=&lt;NicDuplex.NIC_DUPLEX_UNKNOWN: 0&gt;, speed=0, mtu=16384),
  'en0': snicstats(isup=True, duplex=&lt;NicDuplex.NIC_DUPLEX_UNKNOWN: 0&gt;, speed=0, mtu=1500),
  'en1': snicstats(...),
  'en2': snicstats(...),
  'bridge0': snicstats(...)
}
</code></pre>
<p>要获取当前网络连接信息，使用net_connections()：</p>
<pre><code>&gt;&gt;&gt; psutil.net_connections()
Traceback (most recent call last):
  ...
PermissionError: [Errno 1] Operation not permitted

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  ...
psutil.AccessDenied: psutil.AccessDenied (pid=3847)
</code></pre>
<p>你可能会得到一个AccessDenied错误，原因是<strong>psutil获取信息也是要走系统接口，而获取网络连接信息需要root权限</strong>，这种情况下，可以退出Python交互环境，用sudo重新启动：</p>
<pre><code>$ sudo python3
Password: ******
Python 3.8 ... on darwin
Type &quot;help&quot;, ... for more information.
&gt;&gt;&gt; import psutil
&gt;&gt;&gt; psutil.net_connections()
[
    sconn(fd=83, family=&lt;AddressFamily.AF_INET6: 30&gt;, type=1, laddr=addr(ip='::127.0.0.1', port=62911), raddr=addr(ip='::127.0.0.1', port=3306), status='ESTABLISHED', pid=3725),
    sconn(fd=84, family=&lt;AddressFamily.AF_INET6: 30&gt;, type=1, laddr=addr(ip='::127.0.0.1', port=62905), raddr=addr(ip='::127.0.0.1', port=3306), status='ESTABLISHED', pid=3725),
    sconn(fd=93, family=&lt;AddressFamily.AF_INET6: 30&gt;, type=1, laddr=addr(ip='::', port=8080), raddr=(), status='LISTEN', pid=3725),
    sconn(fd=103, family=&lt;AddressFamily.AF_INET6: 30&gt;, type=1, laddr=addr(ip='::127.0.0.1', port=62918), raddr=addr(ip='::127.0.0.1', port=3306), status='ESTABLISHED', pid=3725),
    sconn(fd=105, family=&lt;AddressFamily.AF_INET6: 30&gt;, type=1, ..., pid=3725),
    sconn(fd=106, family=&lt;AddressFamily.AF_INET6: 30&gt;, type=1, ..., pid=3725),
    sconn(fd=107, family=&lt;AddressFamily.AF_INET6: 30&gt;, type=1, ..., pid=3725),
    ...
    sconn(fd=27, family=&lt;AddressFamily.AF_INET: 2&gt;, type=2, ..., pid=1)
]
</code></pre>
<h3 id="获取进程信息">获取进程信息</h3>
<p>通过psutil可以获取到所有进程的详细信息：</p>
<pre><code>&gt;&gt;&gt; psutil.pids() # 所有进程ID
[3865, 3864, 3863, 3856, 3855, 3853, 3776, ..., 45, 44, 1, 0]
&gt;&gt;&gt; p = psutil.Process(3776) # 获取指定进程ID=3776，其实就是当前Python交互环境
&gt;&gt;&gt; p.name() # 进程名称
'python3.6'
&gt;&gt;&gt; p.exe() # 进程exe路径
'/Users/michael/anaconda3/bin/python3.6'
&gt;&gt;&gt; p.cwd() # 进程工作目录
'/Users/michael'
&gt;&gt;&gt; p.cmdline() # 进程启动的命令行
['python3']
&gt;&gt;&gt; p.ppid() # 父进程ID
3765
&gt;&gt;&gt; p.parent() # 父进程
&lt;psutil.Process(pid=3765, name='bash') at 4503144040&gt;
&gt;&gt;&gt; p.children() # 子进程列表
[]
&gt;&gt;&gt; p.status() # 进程状态
'running'
&gt;&gt;&gt; p.username() # 进程用户名
'michael'
&gt;&gt;&gt; p.create_time() # 进程创建时间
1511052731.120333
&gt;&gt;&gt; p.terminal() # 进程终端
'/dev/ttys002'
&gt;&gt;&gt; p.cpu_times() # 进程使用的CPU时间
pcputimes(user=0.081150144, system=0.053269812, children_user=0.0, children_system=0.0)
&gt;&gt;&gt; p.memory_info() # 进程使用的内存
pmem(rss=8310784, vms=2481725440, pfaults=3207, pageins=18)
&gt;&gt;&gt; p.open_files() # 进程打开的文件
[]
&gt;&gt;&gt; p.connections() # 进程相关网络连接
[]
&gt;&gt;&gt; p.num_threads() # 进程的线程数量
1
&gt;&gt;&gt; p.threads() # 所有线程信息
[pthread(id=1, user_time=0.090318, system_time=0.062736)]
&gt;&gt;&gt; p.environ() # 进程环境变量
{'SHELL': '/bin/bash', 'PATH': '/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:...', 'PWD': '/Users/michael', 'LANG': 'zh_CN.UTF-8', ...}
&gt;&gt;&gt; p.terminate() # 结束进程
Terminated: 15 &lt;-- 自己把自己结束了
</code></pre>
<p>和获取网络连接类似，获取一个root用户的进程需要root权限，启动Python交互环境或者.py文件时，需要sudo权限。</p>
<p>psutil还提供了一个test()函数，可以模拟出ps命令的效果：</p>
<pre><code>$ sudo python3
Password: ******
Python 3.6.3 ... on darwin
Type &quot;help&quot;, ... for more information.
&gt;&gt;&gt; import psutil
&gt;&gt;&gt; psutil.test()
USER         PID %MEM     VSZ     RSS TTY           START    TIME  COMMAND
root           0 24.0 74270628 2016380 ?             Nov18   40:51  kernel_task
root           1  0.1 2494140    9484 ?             Nov18   01:39  launchd
root          44  0.4 2519872   36404 ?             Nov18   02:02  UserEventAgent
root          45    ? 2474032    1516 ?             Nov18   00:14  syslogd
root          47  0.1 2504768    8912 ?             Nov18   00:03  kextd
root          48  0.1 2505544    4720 ?             Nov18   00:19  fseventsd
_appleeven    52  0.1 2499748    5024 ?             Nov18   00:00  appleeventsd
root          53  0.1 2500592    6132 ?             Nov18   00:02  configd
...
</code></pre>
<p>psutil还可以获取用户信息、Windows服务等很多有用的系统信息，具体请参考psutil的官网：https://github.com/giampaolo/psutil</p>
<h2 id="virtualenv">virtualenv</h2>
<p>virtualenv为应用提供了<strong>隔离的Python运行环境</strong>，解决了<strong>不同应用间多版本</strong>的冲突问题。</p>
<p>在开发Python应用程序的时候，系统安装的Python3只有一个版本：3.4。所有第三方的包都会被pip安装到Python3的site-packages目录下。</p>
<p>如果我们要同时开发多个应用程序，那这些应用程序都会共用一个Python，就是安装在系统的Python 3。如果应用A需要jinja 2.7，而应用B需要jinja 2.6怎么办？</p>
<p>这种情况下，每个应用可能需要各自拥有<strong>一套“独立”的Python运行环境</strong>。virtualenv就是用来为一个应用创建一套“隔离”的Python运行环境。</p>
<p>首先，我们用pip安装virtualenv：</p>
<pre><code>$ pip3 install virtualenv
</code></pre>
<p>然后，假定我们要开发一个新的项目，需要一套独立的Python运行环境，可以这么做：</p>
<p>第一步，创建目录：</p>
<pre><code>Mac:~ michael$ mkdir myproject
Mac:~ michael$ cd myproject/
Mac:myproject michael$
</code></pre>
<p>第二步，创建一个独立的Python运行环境，命名为venv：</p>
<pre><code>Mac:myproject michael$ virtualenv --no-site-packages venv
Using base prefix '/usr/local/.../Python.framework/Versions/3.4'
New python executable in venv/bin/python3.4
Also creating executable in venv/bin/python
Installing setuptools, pip, wheel...done.
</code></pre>
<p>命令virtualenv就可以创建一个独立的Python运行环境，我们还加上了参数--no-site-packages，这样，已经安装到系统Python环境中的所有第三方包都不会复制过来，这样，我们就得到了一个不带任何第三方包的“干净”的Python运行环境。</p>
<p>新建的Python环境被放到当前目录下的venv目录。有了venv这个Python环境，可以用source进入该环境：</p>
<pre><code>Mac:myproject michael$ source venv/bin/activate
(venv)Mac:myproject michael$
</code></pre>
<p>注意到命令提示符变了，有个(venv)前缀，表示当前环境是一个名为venv的Python环境。</p>
<p>下面正常安装各种第三方包，并运行python命令：</p>
<pre><code>(venv)Mac:myproject michael$ pip install jinja2
...
Successfully installed jinja2-2.7.3 markupsafe-0.23
(venv)Mac:myproject michael$ python myapp.py
...
</code></pre>
<p><strong>在venv环境下，用pip安装的包都被安装到venv这个环境下，系统Python环境不受任何影响</strong>。也就是说，venv环境是专门针对myproject这个应用创建的。</p>
<p>退出当前的venv环境，使用deactivate命令：</p>
<pre><code>(venv)Mac:myproject michael$ deactivate 
Mac:myproject michael$ 
</code></pre>
<p>此时就回到了正常的环境，现在pip或python均是在系统Python环境下执行。</p>
<p>完全可以针对每个应用创建独立的Python运行环境，这样就可以对每个应用的Python环境进行隔离。</p>
<p>virtualenv是如何创建“独立”的Python运行环境的呢？原理很简单，就是把系统Python复制一份到virtualenv的环境，用命令source venv/bin/activate进入一个virtualenv环境时，virtualenv会修改相关环境变量，让命令python和pip均指向当前的virtualenv环境。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Python - 常用内建模块]]></title>
        <id>https://lixin-scut.github.io//post/python-chang-yong-nei-jian-mo-kuai</id>
        <link href="https://lixin-scut.github.io//post/python-chang-yong-nei-jian-mo-kuai">
        </link>
        <updated>2020-05-13T02:36:20.000Z</updated>
        <content type="html"><![CDATA[<h2 id="datetime">datetime</h2>
<p>datetime是Python处理日期和时间的标准库。</p>
<h3 id="获取当前日期和时间">获取当前日期和时间</h3>
<p>获取当前日期和时间：</p>
<pre><code>&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; now = datetime.now() # 获取当前datetime
&gt;&gt;&gt; print(now)
2015-05-18 16:28:07.198690
&gt;&gt;&gt; print(type(now))
&lt;class 'datetime.datetime'&gt;
</code></pre>
<p>注意到<strong>datetime是模块，datetime模块还包含一个datetime类</strong>，通过from datetime import datetime导入的才是datetime这个类。</p>
<p><strong>如果仅导入import datetime，则必须引用全名datetime.datetime</strong>。</p>
<p><strong>datetime.now()返回当前日期和时间，其类型是datetime。</strong></p>
<h3 id="获取指定日期和时间">获取指定日期和时间</h3>
<p>要指定某个日期和时间，我们直接用参数构造一个datetime：</p>
<pre><code>&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; dt = datetime(2015, 4, 19, 12, 20) # 用指定日期时间创建datetime
&gt;&gt;&gt; print(dt)

2015-04-19 12:20:00
</code></pre>
<h3 id="datetime转换为timestamp">datetime转换为timestamp</h3>
<p>在计算机中，时间实际上是用数字表示的。我们把1970年1月1日 00:00:00 UTC+00:00时区的时刻称为epoch time，记为0（1970年以前的时间timestamp为负数），当前<strong>时间就是相对于epoch time的秒数，称为timestamp</strong>。</p>
<p>你可以认为：</p>
<pre><code>timestamp = 0 = 1970-1-1 00:00:00 UTC+0:00
</code></pre>
<p>对应的北京时间是：</p>
<pre><code>timestamp = 0 = 1970-1-1 08:00:00 UTC+8:00
</code></pre>
<p>可见<strong>timestamp的值与时区毫无关系，因为timestamp一旦确定，其UTC时间就确定了</strong>，转换到任意时区的时间也是完全确定的，这就是为什么计算机存储的当前时间是以timestamp表示的，因为<strong>全球各地的计算机在任意时刻的timestamp都是完全相同的（假定时间已校准）</strong>。</p>
<p>把一个datetime类型转换为timestamp只需要简单调用<strong>timestamp()方法</strong>：</p>
<pre><code>&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; dt = datetime(2015, 4, 19, 12, 20) # 用指定日期时间创建datetime
&gt;&gt;&gt; dt.timestamp() # 把datetime转换为timestamp
1429417200.0
</code></pre>
<p>注意Python的<strong>timestamp是一个浮点数</strong>。如果<strong>有小数位，小数位表示毫秒数。</strong></p>
<p><strong>某些编程语言（如Java和JavaScript）的timestamp使用整数表示毫秒数</strong>，这种情况下<strong>只需要把timestamp除以1000</strong>就得到Python的浮点表示方法。</p>
<h3 id="timestamp转换为datetime">timestamp转换为datetime</h3>
<p>要把timestamp转换为datetime，使用datetime提供的<strong>fromtimestamp()方法</strong>：</p>
<pre><code>&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; t = 1429417200.0
&gt;&gt;&gt; print(datetime.fromtimestamp(t))
2015-04-19 12:20:00
</code></pre>
<p>注意到timestamp是一个浮点数，它没有时区的概念，而<strong>datetime是有时区的。上述转换是在timestamp和本地时间做转换。</strong></p>
<p>本地时间是指当前操作系统设定的时区。例如北京时区是东8区，则本地时间：</p>
<pre><code>2015-04-19 12:20:00
</code></pre>
<p>实际上就是UTC+8:00时区的时间：</p>
<pre><code>2015-04-19 12:20:00 UTC+8:00
</code></pre>
<p>而此刻的格林威治标准时间与北京时间差了8小时，也就是UTC+0:00时区的时间应该是：</p>
<pre><code>2015-04-19 04:20:00 UTC+0:00
</code></pre>
<p>timestamp也可以直接被转换到UTC标准时区的时间：</p>
<pre><code>&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; t = 1429417200.0
&gt;&gt;&gt; print(datetime.fromtimestamp(t)) # 本地时间
2015-04-19 12:20:00
&gt;&gt;&gt; print(datetime.utcfromtimestamp(t)) # UTC时间
2015-04-19 04:20:00
</code></pre>
<h3 id="str转换为datetime">str转换为datetime</h3>
<p>很多时候，用户输入的日期和时间是字符串，要处理日期和时间，首先必须把str转换为datetime。转换方法是通过<strong>datetime.strptime()</strong> 实现，需要一个日期和时间的格式化字符串：</p>
<pre><code>&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; cday = datetime.strptime('2015-6-1 18:19:59', '%Y-%m-%d %H:%M:%S')
&gt;&gt;&gt; print(cday)
2015-06-01 18:19:59
</code></pre>
<p><strong>字符串<code>'%Y-%m-%d %H:%M:%S'</code>规定了日期和时间部分的格式</strong>。详细的说明请参考Python文档。</p>
<p>注意转换后的datetime是没有时区信息的。</p>
<h3 id="datetime转换为str">datetime转换为str</h3>
<p>如果已经有了datetime对象，要把它格式化为字符串显示给用户，就需要转换为str，转换方法是通过<strong>strftime()</strong> 实现的，<strong>同样需要一个日期和时间的格式化字符串</strong>：</p>
<pre><code>&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; now = datetime.now()
&gt;&gt;&gt; print(now.strftime('%a, %b %d %H:%M'))
Mon, May 05 16:28
</code></pre>
<h3 id="datetime加减">datetime加减</h3>
<p>对日期和时间进行加减实际上就是把datetime往后或往前计算，得到新的datetime。加减可以直接用+和-运算符，不过需要导入timedelta这个类：</p>
<pre><code>&gt;&gt;&gt; from datetime import datetime, timedelta
&gt;&gt;&gt; now = datetime.now()
&gt;&gt;&gt; now
datetime.datetime(2015, 5, 18, 16, 57, 3, 540997)
&gt;&gt;&gt; now + timedelta(hours=10)
datetime.datetime(2015, 5, 19, 2, 57, 3, 540997)
&gt;&gt;&gt; now - timedelta(days=1)
datetime.datetime(2015, 5, 17, 16, 57, 3, 540997)
&gt;&gt;&gt; now + timedelta(days=2, hours=12)
datetime.datetime(2015, 5, 21, 4, 57, 3, 540997)
</code></pre>
<p>可见，使用timedelta你可以很容易地算出前几天和后几天的时刻。</p>
<h3 id="本地时间转换为utc时间">本地时间转换为UTC时间</h3>
<p>本地时间是指系统设定时区的时间，例如北京时间是UTC+8:00时区的时间，而UTC时间指UTC+0:00时区的时间。</p>
<p>一个datetime类型有一个<strong>时区属性tzinfo，但是默认为None</strong>，所以无法区分这个datetime到底是哪个时区，除非强行给datetime设置一个时区：</p>
<pre><code>&gt;&gt;&gt; from datetime import datetime, timedelta, timezone
&gt;&gt;&gt; tz_utc_8 = timezone(timedelta(hours=8)) # 创建时区UTC+8:00
&gt;&gt;&gt; now = datetime.now()
&gt;&gt;&gt; now
datetime.datetime(2015, 5, 18, 17, 2, 10, 871012)

&gt;&gt;&gt; dt = now.replace(tzinfo=tz_utc_8) # 强制设置为UTC+8:00
&gt;&gt;&gt; dt
datetime.datetime(2015, 5, 18, 17, 2, 10, 871012, tzinfo=datetime.timezone(datetime.timedelta(0, 28800)))
</code></pre>
<p>如果系统时区恰好是UTC+8:00，那么上述代码就是正确的，否则，不能强制设置为UTC+8:00时区。</p>
<h3 id="时区转换">时区转换</h3>
<p>我们可以先通过utcnow()拿到当前的UTC时间，再转换为任意时区的时间：</p>
<pre><code>

# 拿到UTC时间，并强制设置时区为UTC+0:00:
&gt;&gt;&gt; utc_dt = datetime.utcnow().replace(tzinfo=timezone.utc)
&gt;&gt;&gt; print(utc_dt)
2015-05-18 09:05:12.377316+00:00

# astimezone()将转换时区为北京时间:
&gt;&gt;&gt; bj_dt = utc_dt.astimezone(timezone(timedelta(hours=8)))
&gt;&gt;&gt; print(bj_dt)
2015-05-18 17:05:12.377316+08:00

# astimezone()将转换时区为东京时间:
&gt;&gt;&gt; tokyo_dt = utc_dt.astimezone(timezone(timedelta(hours=9)))
&gt;&gt;&gt; print(tokyo_dt)
2015-05-18 18:05:12.377316+09:00

# astimezone()将bj_dt转换时区为东京时间:
&gt;&gt;&gt; tokyo_dt2 = bj_dt.astimezone(timezone(timedelta(hours=9)))
&gt;&gt;&gt; print(tokyo_dt2)
2015-05-18 18:05:12.377316+09:00

</code></pre>
<p>时区转换的关键在于，拿到一个datetime时，要获知其正确的时区，然后强制设置时区，作为基准时间。</p>
<p>利用带时区的datetime，通过astimezone()方法，可以转换到任意时区。</p>
<p>注：不是必须从UTC+0:00时区转换到其他时区，任何带时区的datetime都可以正确转换，例如上述bj_dt到tokyo_dt的转换。</p>
<h3 id="小结">小结</h3>
<p>datetime表示的时间需要时区信息才能确定一个特定的时间，否则只能视为本地时间。</p>
<p>如果要存储datetime，最佳方法是将其转换为timestamp再存储，因为timestamp的值与时区完全无关。</p>
<h2 id="collections">collections</h2>
<p>collections是Python内建的一个集合模块，提供了许多有用的集合类。</p>
<h3 id="namedtuple">namedtuple</h3>
<p>我们知道tuple可以表示不变集合，例如，一个点的二维坐标就可以表示成：</p>
<pre><code>&gt;&gt;&gt; p = (1, 2)
</code></pre>
<p>但是，看到(1, 2)，<strong>很难看出这个tuple是用来表示一个坐标的</strong>。</p>
<p>定义一个class又小题大做了，这时，namedtuple就派上了用场：</p>
<pre><code>&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; Point = namedtuple('Point', ['x', 'y'])
&gt;&gt;&gt; p = Point(1, 2)
&gt;&gt;&gt; p.x
1
&gt;&gt;&gt; p.y
2
</code></pre>
<p>namedtuple<strong>是一个函数</strong>，它用来<strong>创建一个自定义的tuple对象</strong>，并且<strong>规定了tuple元素的个数</strong>，并可以<strong>用属性而不是索引来引用tuple的某个元素</strong>。</p>
<p>这样一来，我们用namedtuple可以很方便地定义一种数据类型，它具备tuple的不变性，又可以根据属性来引用，使用十分方便。</p>
<p>可以验证<strong>创建的Point对象是tuple的一种子类</strong>：</p>
<pre><code>&gt;&gt;&gt; isinstance(p, Point)
True
&gt;&gt;&gt; isinstance(p, tuple)
True
</code></pre>
<p>类似的，如果要用坐标和半径表示一个圆，也可以用namedtuple定义：</p>
<pre><code>
# namedtuple('名称', [属性list]):
Circle = namedtuple('Circle', ['x', 'y', 'r'])

</code></pre>
<h3 id="deque">deque</h3>
<p>使用list存储数据时，按索引访问元素很快，但是插入和删除元素就很慢了，因为list是线性存储，数据量大的时候，插入和删除效率很低。</p>
<p>deque是为了高效实现<strong>插入和删除操作的双向列表</strong>，<strong>适合用于队列和栈</strong>：</p>
<pre><code>&gt;&gt;&gt; from collections import deque
&gt;&gt;&gt; q = deque(['a', 'b', 'c'])
&gt;&gt;&gt; q.append('x')
&gt;&gt;&gt; q.appendleft('y')
&gt;&gt;&gt; q
deque(['y', 'a', 'b', 'c', 'x'])
</code></pre>
<p>deque除了实现list的<strong>append()和pop()</strong> 外，还支持<strong>appendleft()和popleft()</strong>，这样就可以非常高效地往头部添加或删除元素。</p>
<h3 id="defaultdict">defaultdict</h3>
<p>使用dict时，如果引用的Key不存在，就会抛出KeyError。<strong>如果希望key不存在时，返回一个默认值，就可以用defaultdict</strong>：</p>
<pre><code>&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; dd = defaultdict(lambda: 'N/A')
&gt;&gt;&gt; dd['key1'] = 'abc'
&gt;&gt;&gt; dd['key1'] # key1存在
'abc'
&gt;&gt;&gt; dd['key2'] # key2不存在，返回默认值
'N/A'
</code></pre>
<p>注意默认值是<strong>调用函数返回</strong>的，而函数在创建defaultdict对象时传入。</p>
<p>除了在Key不存在时返回默认值，defaultdict的其他行为跟dict是完全一样的。</p>
<h3 id="ordereddict">OrderedDict</h3>
<p>使用<strong>dict时，Key是无序的</strong>。在对dict做迭代时，我们无法确定Key的顺序。</p>
<p>如果要<strong>保持Key的顺序，可以用OrderedDict</strong>：</p>
<pre><code>&gt;&gt;&gt; from collections import OrderedDict
&gt;&gt;&gt; d = dict([('a', 1), ('b', 2), ('c', 3)])
&gt;&gt;&gt; d # dict的Key是无序的
{'a': 1, 'c': 3, 'b': 2}
&gt;&gt;&gt; od = OrderedDict([('a', 1), ('b', 2), ('c', 3)])
&gt;&gt;&gt; od # OrderedDict的Key是有序的
OrderedDict([('a', 1), ('b', 2), ('c', 3)])
</code></pre>
<p>注意，OrderedDict的Key会<strong>按照插入的顺序排列，不是Key本身排序</strong>：</p>
<pre><code>&gt;&gt;&gt; od = OrderedDict()
&gt;&gt;&gt; od['z'] = 1
&gt;&gt;&gt; od['y'] = 2
&gt;&gt;&gt; od['x'] = 3
&gt;&gt;&gt; list(od.keys()) # 按照插入的Key的顺序返回
['z', 'y', 'x']
</code></pre>
<p>OrderedDict可以实现一个<strong>FIFO（先进先出）的dict</strong>，当<strong>容量超出限制时，先删除最早添加的Key</strong>：</p>
<pre><code>from collections import OrderedDict

class LastUpdatedOrderedDict(OrderedDict):

    def __init__(self, capacity):
        super(LastUpdatedOrderedDict, self).__init__()
        self._capacity = capacity

    def __setitem__(self, key, value):
        containsKey = 1 if key in self else 0
        if len(self) - containsKey &gt;= self._capacity:
            last = self.popitem(last=False)
            print('remove:', last)
        if containsKey:
            del self[key]
            print('set:', (key, value))
        else:
            print('add:', (key, value))
        OrderedDict.__setitem__(self, key, value)
</code></pre>
<h3 id="chainmap">ChainMap</h3>
<p>ChainMap可以把<strong>一组dict</strong>串起来并组成一个<strong>逻辑上的dict</strong>。ChainMap<strong>本身也是一个dict</strong>，但是查找的时候，会<strong>按照顺序在内部的dict依次查找</strong>。</p>
<p>什么时候使用ChainMap最合适？举个例子：应用程序往往都需要传入参数，参数可以通过命令行传入，可以通过环境变量传入，还可以有默认参数。我们可以<strong>用ChainMap实现参数的优先级查找</strong>，即先查命令行参数，如果没有传入，再查环境变量，如果没有，就使用默认参数。</p>
<p>下面的代码演示了如何查找user和color这两个参数：</p>
<pre><code>
from collections import ChainMap
import os, argparse

# 构造缺省参数:
defaults = {
    'color': 'red',
    'user': 'guest'
}

# 构造命令行参数:
parser = argparse.ArgumentParser()
parser.add_argument('-u', '--user')
parser.add_argument('-c', '--color')
namespace = parser.parse_args()
command_line_args = { k: v for k, v in vars(namespace).items() if v }

# 组合成ChainMap:
combined = ChainMap(command_line_args, os.environ, defaults)

# 打印参数:
print('color=%s' % combined['color'])
print('user=%s' % combined['user'])
没有任何参数时，打印出默认参数：

$ python3 use_chainmap.py 
color=red
user=guest

</code></pre>
<p>当传入命令行参数时，优先使用命令行参数：</p>
<pre><code>$ python3 use_chainmap.py -u bob
color=red
user=bob
</code></pre>
<p>同时传入命令行参数和<strong>环境变量</strong>，命令行参数的优先级较高：</p>
<pre><code># python3 前面的都是环境变量
$ user=admin color=green python3 use_chainmap.py -u bob
color=green
user=bob
</code></pre>
<h3 id="counter">Counter</h3>
<p>Counter是一个简单的计数器，例如，统计字符出现的个数：</p>
<pre><code>&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; c = Counter()
&gt;&gt;&gt; for ch in 'programming':
...     c[ch] = c[ch] + 1
...
&gt;&gt;&gt; c
Counter({'g': 2, 'm': 2, 'r': 2, 'a': 1, 'i': 1, 'o': 1, 'n': 1, 'p': 1})
&gt;&gt;&gt; c.update('hello') # 也可以一次性update
&gt;&gt;&gt; c
Counter({'r': 2, 'o': 2, 'g': 2, 'm': 2, 'l': 2, 'p': 1, 'a': 1, 'i': 1, 'n': 1, 'h': 1, 'e': 1})
</code></pre>
<p><strong>Counter实际上也是dict的一个子类</strong>，上面的结果可以看出每个字符出现的次数。</p>
<h2 id="base64">base64</h2>
<p>Base64是一种<strong>用64个字符来表示任意二进制数据</strong>的方法。</p>
<p>用记事本打开exe、jpg、pdf这些文件时，我们都会看到一大堆乱码，因为二进制文件包含很多无法显示和打印的字符，所以，如果要让记事本这样的文本处理软件能处理二进制数据，就需要一个二进制到字符串的转换方法。Base64是一种最常见的二进制编码方法。</p>
<p>Base64的原理很简单，首先，准备一个包含64个字符的数组：</p>
<pre><code>['A', 'B', 'C', ... 'a', 'b', 'c', ... '0', '1', ... '+', '/']
</code></pre>
<p>然后，对二进制数据进行处理，每3个字节一组，一共是3x8=24bit，划为4组，每组正好6个bit：</p>
<p><img src="https://lixin-scut.github.io//post-images/1589339175185.png" alt=""></p>
<p>这样我们得到4个数字作为索引，然后查表，获得相应的4个字符，就是编码后的字符串。</p>
<p>所以，Base64编码会把3字节的二进制数据编码为4字节的文本数据，长度增加33%，好处是编码后的文本数据可以在邮件正文、网页等直接显示。</p>
<p>如果要编码的二进制数据不是3的倍数，最后会剩下1个或2个字节怎么办？Base64用\x00字节在末尾补足后，再在编码的末尾加上1个或2个=号，表示补了多少字节，解码的时候，会自动去掉。</p>
<p>Python内置的base64可以直接进行base64的编解码：</p>
<pre><code>&gt;&gt;&gt; import base64
&gt;&gt;&gt; base64.b64encode(b'binary\x00string')
b'YmluYXJ5AHN0cmluZw=='
&gt;&gt;&gt; base64.b64decode(b'YmluYXJ5AHN0cmluZw==')
b'binary\x00string'
</code></pre>
<p>由于标准的Base64编码后可能出现字符+和/，在URL中就不能直接作为参数，所以又有一种&quot;url safe&quot;的base64编码，其实就是把字符+和/分别变成-和_：</p>
<pre><code>&gt;&gt;&gt; base64.b64encode(b'i\xb7\x1d\xfb\xef\xff')
b'abcd++//'
&gt;&gt;&gt; base64.urlsafe_b64encode(b'i\xb7\x1d\xfb\xef\xff')
b'abcd--__'
&gt;&gt;&gt; base64.urlsafe_b64decode('abcd--__')
b'i\xb7\x1d\xfb\xef\xff'
</code></pre>
<p>还可以自己定义64个字符的排列顺序，这样就可以自定义Base64编码，不过，通常情况下完全没有必要。</p>
<p>Base64是一种通过查表的编码方法，不能用于加密，即使使用自定义的编码表也不行。</p>
<p>Base64适用于小段内容的编码，比如数字证书签名、Cookie的内容等。</p>
<p>由于=字符也可能出现在Base64编码中，但=用在URL、Cookie里面会造成歧义，所以，很多Base64编码后会把=去掉：</p>
<pre><code>
# 标准Base64:
'abcd' -&gt; 'YWJjZA=='
# 自动去掉=:
'abcd' -&gt; 'YWJjZA'

</code></pre>
<p>去掉=后怎么解码呢？因为Base64是把3个字节变为4个字节，所以，Base64编码的长度永远是4的倍数，因此，需要加上=把Base64字符串的长度变为4的倍数，就可以正常解码了。</p>
<h2 id="struct">struct</h2>
<p>准确地讲，Python没有专门处理字节的数据类型。但由于b'str'可以表示字节，所以，字节数组＝二进制str。而在C语言中，我们可以很方便地用struct、union来处理字节，以及字节和int，float的转换。</p>
<p>在Python中，比方说要把一个32位无符号整数变成字节，也就是4个长度的bytes，你得配合位运算符这么写：</p>
<pre><code>&gt;&gt;&gt; n = 10240099
&gt;&gt;&gt; b1 = (n &amp; 0xff000000) &gt;&gt; 24
&gt;&gt;&gt; b2 = (n &amp; 0xff0000) &gt;&gt; 16
&gt;&gt;&gt; b3 = (n &amp; 0xff00) &gt;&gt; 8
&gt;&gt;&gt; b4 = n &amp; 0xff
&gt;&gt;&gt; bs = bytes([b1, b2, b3, b4])
&gt;&gt;&gt; bs
b'\x00\x9c@c'
</code></pre>
<p>非常麻烦。如果换成浮点数就无能为力了。</p>
<p>好在Python提供了一个struct模块来<strong>解决bytes和其他二进制数据类型的转换</strong>。</p>
<p>struct的pack函数把任意数据类型变成bytes：</p>
<pre><code>&gt;&gt;&gt; import struct
&gt;&gt;&gt; struct.pack('&gt;I', 10240099)
b'\x00\x9c@c'
</code></pre>
<p>pack的第一个参数是处理指令，'&gt;I'的意思是：</p>
<p><code>&gt;</code>表示字节顺序是big-endian，也就是网络序，I表示4字节无符号整数。</p>
<p>后面的参数个数要和处理指令一致。</p>
<p>unpack把bytes变成相应的数据类型：</p>
<pre><code>&gt;&gt;&gt; struct.unpack('&gt;IH', b'\xf0\xf0\xf0\xf0\x80\x80')
(4042322160, 32896)
</code></pre>
<p>根据&gt;IH的说明，后面的bytes依次变为I：4字节无符号整数和H：2字节无符号整数。</p>
<p>所以，尽管Python不适合编写底层操作字节流的代码，但在对性能要求不高的地方，利用struct就方便多了。</p>
<p>struct模块定义的数据类型可以参考Python官方文档：</p>
<p>https://docs.python.org/3/library/struct.html#format-characters</p>
<p>Windows的位图文件（.bmp）是一种非常简单的文件格式，我们来用struct分析一下。</p>
<p>首先找一个bmp文件。</p>
<p>读入前30个字节来分析：</p>
<pre><code>
&gt;&gt;&gt; s = b'\x42\x4d\x38\x8c\x0a\x00\x00\x00\x00\x00\x36\x00\x00\x00\x28\x00\x00\x00\x80\x02\x00\x00\x68\x01\x00\x00\x01\x00\x18\x00'

</code></pre>
<p>BMP格式采用小端方式存储数据，文件头的结构按顺序如下：</p>
<p>两个字节：'BM'表示Windows位图，'BA'表示OS/2位图； 一个4字节整数：表示位图大小； 一个4字节整数：保留位，始终为0； 一个4字节整数：实际图像的偏移量； 一个4字节整数：Header的字节数； 一个4字节整数：图像宽度； 一个4字节整数：图像高度； 一个2字节整数：始终为1； 一个2字节整数：颜色数。</p>
<p>所以，组合起来用unpack读取：</p>
<pre><code>&gt;&gt;&gt; struct.unpack('&lt;ccIIIIIIHH', s)
</code></pre>
<p>(b'B', b'M', 691256, 0, 54, 40, 640, 360, 1, 24)<br>
结果显示，b'B'、b'M'说明是Windows位图，位图大小为640x360，颜色数为24。</p>
<h2 id="hashlib">hashlib</h2>
<p>摘要算法简介</p>
<p>摘要算法在很多地方都有广泛的应用。要注意摘要算法不是加密算法，不能用于加密（因为无法通过摘要反推明文），只能用于防篡改，但是它的单向计算特性决定了可以在不存储明文口令的情况下验证用户口令。</p>
<p>Python的<strong>hashlib提供了常见的摘要算法，如MD5，SHA1等等</strong>。</p>
<p>什么是摘要算法呢？摘要算法又称<strong>哈希算法、散列算法</strong>。它通过一个函数，把<strong>任意长度的数据转换为一个长度固定的数据串</strong>（通常用16进制的字符串表示）。</p>
<p>举个例子，你写了一篇文章，内容是一个字符串'how to use python hashlib - by Michael'，并附上这篇文章的摘要是'2d73d4f15c0db7f5ecb321b6a65e5d6d'。如果有人篡改了你的文章，并发表为'how to use python hashlib - by Bob'，你可以一下子指出Bob篡改了你的文章，因为根据'how to use python hashlib - by Bob'计算出的摘要不同于原始文章的摘要。</p>
<p>可见，<strong>摘要算法就是通过摘要函数f()对任意长度的数据data计算出固定长度的摘要digest，目的是为了发现原始数据是否被人篡改过</strong>。</p>
<p>摘要算法之所以能指出数据是否被篡改过，就是因为<strong>摘要函数是一个单向函数，计算f(data)很容易，但通过digest反推data却非常困难</strong>。而且，<strong>对原始数据做一个bit的修改，都会导致计算出的摘要完全不同</strong>。</p>
<p>我们以常见的摘要算法MD5为例，计算出一个字符串的MD5值：</p>
<pre><code>import hashlib

md5 = hashlib.md5()
md5.update('how to use md5 in python hashlib?'.encode('utf-8'))
print(md5.hexdigest())
</code></pre>
<p>计算结果如下：</p>
<pre><code>d26a53750bc40b38b65a520292f69306
</code></pre>
<p>如果数据量很大，可以分块多次调用update()，最后计算的结果是一样的：</p>
<pre><code>import hashlib

md5 = hashlib.md5()
md5.update('how to use md5 in '.encode('utf-8'))
md5.update('python hashlib?'.encode('utf-8'))
print(md5.hexdigest())
</code></pre>
<p>改动一个字母，计算的结果完全不同。</p>
<p>MD5是最常见的摘要算法，速度很快，生成结果是固定的128 bit字节，通常用一个32位的16进制字符串表示。</p>
<p>另一种常见的摘要算法是SHA1，调用SHA1和调用MD5完全类似：</p>
<pre><code>import hashlib

sha1 = hashlib.sha1()
sha1.update('how to use sha1 in '.encode('utf-8'))
sha1.update('python hashlib?'.encode('utf-8'))
print(sha1.hexdigest())
</code></pre>
<p>SHA1的结果是160 bit字节，通常用一个40位的16进制字符串表示。</p>
<p>比SHA1更安全的算法是SHA256和SHA512，不过越安全的算法不仅越慢，而且摘要长度更长。</p>
<p>有没有可能<strong>两个不同的数据通过某个摘要算法得到了相同的摘要</strong>？完全有可能，因为任何摘要算法都是<strong>把无限多的数据集合映射到一个有限的集合中</strong>。这种情况称为碰撞，比如Bob试图根据你的摘要反推出一篇文章'how to learn hashlib in python - by Bob'，并且这篇文章的摘要恰好和你的文章完全一致，这种情况也并非不可能出现，但是非常非常困难。</p>
<p>摘要算法应用</p>
<p>摘要算法能应用到什么地方？举个常用例子：</p>
<p>任何允许用户登录的网站都会存储用户登录的用户名和口令。如何存储用户名和口令呢？方法是存到数据库表中：</p>
<table>
<thead>
<tr>
<th style="text-align:center">name</th>
<th style="text-align:center">password</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">michael</td>
<td style="text-align:center">123456</td>
</tr>
<tr>
<td style="text-align:center">bob</td>
<td style="text-align:center">abc999</td>
</tr>
<tr>
<td style="text-align:center">alice</td>
<td style="text-align:center">alice2008</td>
</tr>
</tbody>
</table>
<p>如果以明文保存用户口令，如果数据库泄露，所有用户的口令就落入黑客的手里。此外，网站运维人员是可以访问数据库的，也就是能获取到所有用户的口令。</p>
<p>正确的保存口令的方式是<strong>不存储用户的明文口令，而是存储用户口令的摘要</strong>，比如MD5：</p>
<table>
<thead>
<tr>
<th style="text-align:center">username</th>
<th style="text-align:center">password</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">michael</td>
<td style="text-align:center">e10adc3949ba59abbe56e057f20f883e</td>
</tr>
<tr>
<td style="text-align:center">bob</td>
<td style="text-align:center">878ef96e86145580c38c87f0410ad153</td>
</tr>
<tr>
<td style="text-align:center">alice</td>
<td style="text-align:center">99b1c2188db85afee403b1536010c2c9</td>
</tr>
</tbody>
</table>
<p>当用户登录时，首先<strong>计算用户输入的明文口令的MD5，然后和数据库存储的MD5对比，如果一致，说明口令输入正确，如果不一致，口令肯定错误</strong>。</p>
<p>存储MD5的好处是即使运维人员能访问数据库，也无法获知用户的明文口令。</p>
<p>采用MD5存储口令是否就一定安全呢？也不一定。假设你是一个黑客，已经拿到了存储MD5口令的数据库，如何通过MD5反推用户的明文口令呢？暴力破解费事费力</p>
<p>考虑这么个情况，很多用户喜欢用123456，888888，password这些简单的口令，于是，黑客可以事先计算出这些常用口令的MD5值，得到一个反推表：</p>
<p>'e10adc3949ba59abbe56e057f20f883e': '123456'<br>
'21218cca77804d2ba1922c33e0151105': '888888'<br>
'5f4dcc3b5aa765d61d8327deb882cf99': 'password'<br>
这样，无需破解，只需要对比数据库的MD5，黑客就获得了使用常用口令的用户账号。</p>
<p>对于用户来讲，当然不要使用过于简单的口令。但是，我们能否在程序设计上对简单口令加强保护呢？</p>
<p>由于常用口令的MD5值很容易被计算出来，所以，要确保存储的用户口令不是那些已经被计算出来的常用口令的MD5，这一方法<strong>通过对原始口令加一个复杂字符串来实现，俗称“加盐”：</strong></p>
<pre><code>def calc_md5(password):
    return get_md5(password + 'the-Salt')
</code></pre>
<p>经过Salt处理的MD5口令，<strong>只要Salt不被黑客知道，即使用户输入简单口令，也很难通过MD5反推明文口令</strong>。</p>
<p>但是如果有两个用户都使用了相同的简单口令比如123456，在数据库中，将存储两条相同的MD5值，这说明这两个用户的口令是一样的。有没有办法让使用相同口令的用户存储不同的MD5呢--如果假定用户无法修改登录名，就可以通过把登录名作为Salt的一部分来计算MD5，从而实现相同口令的用户也存储不同的MD5。</p>
<h2 id="hmac">hmac</h2>
<p>通过哈希算法，我们可以验证一段数据是否有效，方法就是对比该数据的哈希值，例如，判断用户口令是否正确，我们用保存在数据库中的password_md5对比计算md5(password)的结果，如果一致，用户输入的口令就是正确的。</p>
<p>为了防止黑客通过彩虹表根据哈希值反推原始口令，在计算哈希的时候，不能仅针对原始输入计算，需要增加一个salt来使得相同的输入也能得到不同的哈希，这样，大大增加了黑客破解的难度。</p>
<p>如果salt是我们自己随机生成的，通常我们计算MD5时采用md5(message + salt)。但实际上，把salt看做一个“口令”，加salt的哈希就是：计算一段message的哈希时，根据不通口令计算出不同的哈希。<strong>要验证哈希值，必须同时提供正确的口令。</strong></p>
<p><strong>这实际上就是Hmac算法：Keyed-Hashing for Message Authentication</strong>。它通过一个标准算法，在计算哈希的过程中，<strong>把key混入计算过程中。</strong></p>
<p>和我们自定义的加salt算法不同，Hmac算法针对所有哈希算法都通用，无论是MD5还是SHA-1。采用Hmac替代我们自己的salt算法，可以使程序算法更标准化，也更安全。</p>
<p>Python自带的hmac模块实现了标准的Hmac算法。我们来看看如何使用hmac实现带key的哈希。</p>
<p>我们首先需要准备待计算的原始消息message，随机key，哈希算法，这里采用MD5，使用hmac的代码如下：</p>
<pre><code>&gt;&gt;&gt; import hmac
&gt;&gt;&gt; message = b'Hello, world!'
&gt;&gt;&gt; key = b'secret'
&gt;&gt;&gt; h = hmac.new(key, message, digestmod='MD5')
&gt;&gt;&gt; # 如果消息很长，可以多次调用h.update(msg)
&gt;&gt;&gt; h.hexdigest()
'fa4ee7d173f2d97ee79022d1a7355bcf'
</code></pre>
<p>可见使用hmac和普通hash算法非常类似。hmac输出的长度和原始哈希算法的长度一致。需要注意<strong>传入的key和message都是bytes类型，str类型需要首先编码为bytes。</strong></p>
<h2 id="itertools">itertools</h2>
<p>Python的内建模块itertools提供了非常有用的用于<strong>操作迭代对象</strong>的函数。</p>
<p>itertools模块提供的全部是<strong>处理迭代功能的函数</strong>，它们的<strong>返回值不是list，而是Iterator</strong>，<strong>只有用for循环迭代的时候才真正计算</strong>。</p>
<p>首先，我们看看itertools提供的几个“无限”迭代器：</p>
<p><strong>count()</strong></p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; natuals = itertools.count(1)
&gt;&gt;&gt; for n in natuals:
...     print(n)
...
1
2
3
...
</code></pre>
<p>因为count()会创建一个<strong>无限的迭代器</strong>，所以上述代码会打印出自然数序列，根本停不下来，<strong>只能按Ctrl+C退出</strong>。</p>
<p><strong>cycle()</strong> 会把传入的一个序列无限重复下去：</p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; cs = itertools.cycle('ABC') # 注意字符串也是序列的一种
&gt;&gt;&gt; for c in cs:
...     print(c)
...
'A'
'B'
'C'
'A'
'B'
'C'
...
</code></pre>
<p>同样停不下来。</p>
<p><strong>repeat()</strong> 负责把一个元素无限重复下去，不过<strong>如果提供第二个参数就可以限定重复次数</strong>：</p>
<pre><code>&gt;&gt;&gt; ns = itertools.repeat('A', 3)
&gt;&gt;&gt; for n in ns:
...     print(n)
...
A
A
A
</code></pre>
<p>**无限序列只有在for迭代时才会无限地迭代下去，如果只是创建了一个迭代对象，它不会事先把无限个元素生成出来，**事实上也不可能在内存中创建无限多个元素。</p>
<p>无限序列虽然可以无限迭代下去，但是通常我们会<strong>通过takewhile()等函数根据条件判断来截取出一个有限的序列</strong>：</p>
<pre><code>&gt;&gt;&gt; natuals = itertools.count(1)
&gt;&gt;&gt; ns = itertools.takewhile(lambda x: x &lt;= 10, natuals)
&gt;&gt;&gt; list(ns)
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
</code></pre>
<p>itertools提供的几个迭代器操作函数更加有用：</p>
<h3 id="chain">chain()</h3>
<p>chain()可以把一组迭代对象串联起来，形成一个更大的迭代器：</p>
<pre><code>
&gt;&gt;&gt; for c in itertools.chain('ABC', 'XYZ'):
...     print(c)
# 迭代效果：'A' 'B' 'C' 'X' 'Y' 'Z'
</code></pre>
<h3 id="groupby">groupby()</h3>
<p>groupby()把迭代器中相邻的重复元素挑出来放在一起：</p>
<pre><code>&gt;&gt;&gt; for key, group in itertools.groupby('AAABBBCCAAA'):
...     print(key, list(group))
...
A ['A', 'A', 'A']
B ['B', 'B', 'B']
C ['C', 'C']
A ['A', 'A', 'A']
</code></pre>
<p>实际上<strong>挑选规则是通过函数完成的</strong>，只要作用于函数的两个元素返回的值相等，这两个元素就被认为是在一组的，而<strong>函数返回值作为组的key</strong>。如果我们要忽略大小写分组，就可以让元素'A'和'a'都返回相同的key：</p>
<pre><code>&gt;&gt;&gt; for key, group in itertools.groupby('AaaBBbcCAAa', lambda c: c.upper()):
...     print(key, list(group))
...

A ['A', 'a', 'a']
B ['B', 'B', 'b']
C ['c', 'C']
A ['A', 'A', 'a']
</code></pre>
<h2 id="contextlib">contextlib</h2>
<p>在Python中，读写文件这样的资源要特别注意，必须在使用完毕后正确关闭它们。正确关闭文件资源的一个方法是使用try...finally：</p>
<pre><code>try:
    f = open('/path/to/file', 'r')
    f.read()
finally:
    if f:
        f.close()
</code></pre>
<p>写try...finally非常繁琐。Python的with语句允许我们非常方便地使用资源，而不必担心资源没有关闭，所以上面的代码可以简化为：</p>
<pre><code>with open('/path/to/file', 'r') as f:
    f.read()
</code></pre>
<p>并不是只有open()函数返回的fp对象才能使用with语句。<strong>实际上，任何对象，只要正确实现了上下文管理，就可以用于with语句</strong>。</p>
<p>实现<strong>上下文管理</strong>是通过<code>__enter__和__exit__</code>这两个方法实现的。例如，下面的class实现了这两个方法：</p>
<pre><code>class Query(object):

    def __init__(self, name):
        self.name = name

    def __enter__(self):
        print('Begin')
        return self
    
    def __exit__(self, exc_type, exc_value, traceback):
        if exc_type:
            print('Error')
        else:
            print('End')
    
    def query(self):
        print('Query info about %s...' % self.name)
</code></pre>
<p>这样我们就可以把自己写的资源对象用于with语句：</p>
<pre><code>with Query('Bob') as q:
    q.query()
</code></pre>
<h3 id="contextmanager">@contextmanager</h3>
<p>编写__enter__和__exit__仍然很繁琐，因此Python的标准库contextlib提供了更简单的写法，上面的代码可以改写如下：</p>
<pre><code>from contextlib import contextmanager

class Query(object):

    def __init__(self, name):
        self.name = name

    def query(self):
        print('Query info about %s...' % self.name)

@contextmanager
def create_query(name):
    print('Begin')
    q = Query(name)
    yield q
    print('End')
</code></pre>
<p>@contextmanager这个decorator接受一个generator，用yield语句把<code>with ... as var</code>把变量输出出去，然后，with语句就可以正常地工作了：</p>
<pre><code>with create_query('Bob') as q:
    q.query()
</code></pre>
<p>很多时候，我们希望在某段代码执行前后自动执行特定代码，也可以用@contextmanager实现。例如：</p>
<pre><code>@contextmanager
def tag(name):
    print(&quot;&lt;%s&gt;&quot; % name)
    yield
    print(&quot;&lt;/%s&gt;&quot; % name)

with tag(&quot;h1&quot;):
    print(&quot;hello&quot;)
    print(&quot;world&quot;)
</code></pre>
<p>上述代码执行结果为：</p>
<pre><code>&lt;h1&gt;
hello
world
&lt;/h1&gt;
</code></pre>
<p>代码的执行顺序是：</p>
<ol>
<li>with语句首先执行yield之前的语句，因此打印出<code>&lt;h1&gt;</code>；</li>
<li>yield调用会执行with语句内部的所有语句，因此打印出hello和world；</li>
<li>最后执行yield之后的语句，打印出<code>&lt;/h1&gt;</code>。<br>
因此，@contextmanager让我们通过编写generator来简化上下文管理。</li>
</ol>
<h3 id="closing">@closing</h3>
<p>如果一个对象没有实现上下文，我们就不能把它用于with语句。这个时候，可以用<strong>closing()来把该对象变为上下文对象</strong>。例如，用with语句使用urlopen()：</p>
<pre><code>from contextlib import closing
from urllib.request import urlopen

with closing(urlopen('https://www.python.org')) as page:
    for line in page:
        print(line)
</code></pre>
<p><strong>closing也是一个经过@contextmanager装饰的generator</strong>，这个generator编写起来其实非常简单：</p>
<pre><code>@contextmanager
def closing(thing):
    try:
        yield thing
    finally:
        thing.close()
</code></pre>
<p>它的作用就是把任意对象变为上下文对象，并支持with语句。</p>
<h2 id="urllib">urllib</h2>
<p>urllib提供了一系列用于<strong>操作URL的功能</strong>。</p>
<h3 id="get">Get</h3>
<p>urllib的request模块可以非常方便地抓取URL内容，也就是<strong>发送一个GET请求到指定的页面，然后返回HTTP的响应</strong>：</p>
<p>例如，对豆瓣的一个URLhttps://api.douban.com/v2/book/2129650进行抓取，并返回响应：</p>
<pre><code>from urllib import request

with request.urlopen('https://api.douban.com/v2/book/2129650') as f:
    data = f.read()
    print('Status:', f.status, f.reason)
    for k, v in f.getheaders():
        print('%s: %s' % (k, v))
    print('Data:', data.decode('utf-8'))
</code></pre>
<p>可以看到HTTP响应的头和JSON数据：</p>
<pre><code>Status: 200 OK
Server: nginx
Date: Tue, 26 May 2015 10:02:27 GMT
Content-Type: application/json; charset=utf-8
Content-Length: 2049
Connection: close
Expires: Sun, 1 Jan 2006 01:00:00 GMT
Pragma: no-cache
Cache-Control: must-revalidate, no-cache, private
X-DAE-Node: pidl1
Data: {&quot;rating&quot;:{&quot;max&quot;:10,&quot;numRaters&quot;:16,&quot;average&quot;:&quot;7.4&quot;,&quot;min&quot;:0},&quot;subtitle&quot;:&quot;&quot;,&quot;author&quot;:[&quot;廖雪峰编著&quot;],&quot;pubdate&quot;:&quot;2007-6&quot;,...}
</code></pre>
<p>如果我们要想模拟浏览器发送GET请求，就需要使用Request对象，通过往Request对象添加HTTP头，我们就可以把请求伪装成浏览器。例如，模拟iPhone 6去请求豆瓣首页：</p>
<pre><code>from urllib import request

req = request.Request('http://www.douban.com/')
req.add_header('User-Agent', 'Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25')
with request.urlopen(req) as f:
    print('Status:', f.status, f.reason)
    for k, v in f.getheaders():
        print('%s: %s' % (k, v))
    print('Data:', f.read().decode('utf-8'))
</code></pre>
<p>这样豆瓣会返回适合iPhone的移动版网页：</p>
<pre><code>...
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0&quot;&gt;
    &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;
    &lt;link rel=&quot;apple-touch-icon&quot; sizes=&quot;57x57&quot; href=&quot;http://img4.douban.com/pics/cardkit/launcher/57.png&quot; /&gt;
...
</code></pre>
<h3 id="post">Post</h3>
<p>如果要以POST发送一个请求，<strong>只需要把参数data以bytes形式传入</strong>。</p>
<p>我们模拟一个微博登录，先读取登录的邮箱和口令，然后按照weibo.cn的登录页的格式以username=xxx&amp;password=xxx的编码传入：</p>
<pre><code>from urllib import request, parse

print('Login to weibo.cn...')
email = input('Email: ')
passwd = input('Password: ')
login_data = parse.urlencode([
    ('username', email),
    ('password', passwd),
    ('entry', 'mweibo'),
    ('client_id', ''),
    ('savestate', '1'),
    ('ec', ''),
    ('pagerefer', 'https://passport.weibo.cn/signin/welcome?entry=mweibo&amp;r=http%3A%2F%2Fm.weibo.cn%2F')
])

req = request.Request('https://passport.weibo.cn/sso/login')
req.add_header('Origin', 'https://passport.weibo.cn')
req.add_header('User-Agent', 'Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25')
req.add_header('Referer', 'https://passport.weibo.cn/signin/login?entry=mweibo&amp;res=wel&amp;wm=3349&amp;r=http%3A%2F%2Fm.weibo.cn%2F')

with request.urlopen(req, data=login_data.encode('utf-8')) as f:
    print('Status:', f.status, f.reason)
    for k, v in f.getheaders():
        print('%s: %s' % (k, v))
    print('Data:', f.read().decode('utf-8'))
</code></pre>
<p>如果登录成功，我们获得的响应如下：</p>
<pre><code>Status: 200 OK
Server: nginx/1.2.0
...
Set-Cookie: SSOLoginState=1432620126; path=/; domain=weibo.cn
...
Data: {&quot;retcode&quot;:20000000,&quot;msg&quot;:&quot;&quot;,&quot;data&quot;:{...,&quot;uid&quot;:&quot;1658384301&quot;}}
</code></pre>
<p>如果登录失败，我们获得的响应如下：</p>
<pre><code>...
Data: {&quot;retcode&quot;:50011015,&quot;msg&quot;:&quot;\u7528\u6237\u540d\u6216\u5bc6\u7801\u9519\u8bef&quot;,&quot;data&quot;:{&quot;username&quot;:&quot;example@python.org&quot;,&quot;errline&quot;:536}}
Handler
</code></pre>
<p>如果还需要更复杂的控制，比如<strong>通过一个Proxy去访问网站，我们需要利用ProxyHandler来处理</strong>，示例代码如下：</p>
<pre><code>proxy_handler = urllib.request.ProxyHandler({'http': 'http://www.example.com:3128/'})
proxy_auth_handler = urllib.request.ProxyBasicAuthHandler()
proxy_auth_handler.add_password('realm', 'host', 'username', 'password')
opener = urllib.request.build_opener(proxy_handler, proxy_auth_handler)
with opener.open('http://www.example.com/login.html') as f:
    pass
</code></pre>
<p><strong>小结</strong></p>
<p>urllib提供的功能就是利用程序去执行各种HTTP请求。<strong>如果要模拟浏览器完成特定功能，需要把请求伪装成浏览器。伪装的方法是先监控浏览器发出的请求，再根据浏览器的请求头来伪装，User-Agent头就是用来标识浏览器的</strong>。</p>
<h2 id="xml">XML</h2>
<p>ML虽然比JSON复杂，在Web中应用也不如以前多了，不过仍有很多地方在用，所以，有必要了解如何操作XML。</p>
<p>DOM vs SAX</p>
<p>操作XML有两种方法：DOM和SAX。</p>
<ol>
<li>DOM会把整个XML读入内存，解析为树，因此占用内存大，解析慢，优点是可以任意遍历树的节点。</li>
<li>SAX是流模式，边读边解析，占用内存小，解析快，缺点是我们需要自己处理事件。</li>
</ol>
<p>正常情况下，<strong>优先考虑SAX，因为DOM实在太占内存</strong>。</p>
<p>在Python中使用SAX解析XML非常简洁，通常我们关心的事件是start_element，end_element和char_data，准备好这3个函数，然后就可以解析xml了。</p>
<p>举个例子，当SAX解析器读到一个节点时：</p>
<pre><code>&lt;a href=&quot;/&quot;&gt;python&lt;/a&gt;
</code></pre>
<p>会产生3个事件：</p>
<ol>
<li>
<p>start_element事件，在读取<code>&lt;a href=&quot;/&quot;&gt;</code>时；</p>
</li>
<li>
<p>char_data事件，在读取python时；</p>
</li>
<li>
<p>end_element事件，在读取<code>&lt;/a&gt;</code>时。</p>
</li>
</ol>
<p>用代码实验一下：</p>
<pre><code>from xml.parsers.expat import ParserCreate

class DefaultSaxHandler(object):
    def start_element(self, name, attrs):
        print('sax:start_element: %s, attrs: %s' % (name, str(attrs)))

    def end_element(self, name):
        print('sax:end_element: %s' % name)

    def char_data(self, text):
        print('sax:char_data: %s' % text)

xml = r'''&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;ol&gt;
    &lt;li&gt;&lt;a href=&quot;/python&quot;&gt;Python&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;/ruby&quot;&gt;Ruby&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
'''

handler = DefaultSaxHandler()
parser = ParserCreate()
parser.StartElementHandler = handler.start_element
parser.EndElementHandler = handler.end_element
parser.CharacterDataHandler = handler.char_data
parser.Parse(xml)
</code></pre>
<p>需要注意的是读取一大段字符串时，CharacterDataHandler可能被多次调用，所以需要自己保存起来，在EndElementHandler里面再合并。</p>
<p>除了解析XML外，如何生成XML呢？99%的情况下需要生成的XML结构都是非常简单的，因此，最简单也是最有效的生成XML的方法是拼接字符串：</p>
<pre><code>L = []
L.append(r'&lt;?xml version=&quot;1.0&quot;?&gt;')
L.append(r'&lt;root&gt;')
L.append(encode('some &amp; data'))
L.append(r'&lt;/root&gt;')
return ''.join(L)
</code></pre>
<p>如果要生成复杂的XML呢，此时建议不要用XML，改成JSON。</p>
<p><strong>小结</strong></p>
<p>解析XML时，注意找出自己感兴趣的节点，响应事件时，把节点数据保存起来。解析完毕后，就可以处理数据。</p>
<h2 id="htmlparser">HTMLParser</h2>
<p>如果我们要编写一个搜索引擎，第一步是用爬虫把目标网站的页面抓下来，第二步就是解析该HTML页面，看看里面的内容到底是新闻、图片还是视频。</p>
<p>假设第一步已经完成了，第二步解析HTML</p>
<p>HTML本质上是XML的子集，但是HTML的语法没有XML那么严格，所以<strong>不能用标准的DOM或SAX来解析HTML</strong>。</p>
<p>好在Python提供了HTMLParser来非常方便地解析HTML，只需简单几行代码：</p>
<pre><code>from html.parser import HTMLParser
from html.entities import name2codepoint

class MyHTMLParser(HTMLParser):

    def handle_starttag(self, tag, attrs):
        print('&lt;%s&gt;' % tag)

    def handle_endtag(self, tag):
        print('&lt;/%s&gt;' % tag)

    def handle_startendtag(self, tag, attrs):
        print('&lt;%s/&gt;' % tag)

    def handle_data(self, data):
        print(data)

    def handle_comment(self, data):
        print('&lt;!--', data, '--&gt;')

    def handle_entityref(self, name):
        print('&amp;%s;' % name)

    def handle_charref(self, name):
        print('&amp;#%s;' % name)

parser = MyHTMLParser()
parser.feed('''&lt;html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
&lt;!-- test html parser --&gt;
    &lt;p&gt;Some &lt;a href=\&quot;#\&quot;&gt;html&lt;/a&gt; HTML&amp;nbsp;tutorial...&lt;br&gt;END&lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;''')
</code></pre>
<p>feed()方法可以多次调用，也就是不一定一次把整个HTML字符串都塞进去，可以一部分一部分塞进去。</p>
<p>特殊字符有两种，一种是英文表示的<code>&amp;nbsp</code>;，一种是数字表示的<code>&amp;#1234;</code>，这两种字符都可以通过Parser解析出来。</p>
<p><strong>小结</strong></p>
<p>利用HTMLParser，可以把网页中的文本、图像等解析出来。</p>
]]></content>
    </entry>
</feed>