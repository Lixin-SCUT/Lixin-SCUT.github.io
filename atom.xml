<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-09-03T15:27:43.170Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[数组-27. 移除元素]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-27-yi-chu-yuan-su</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-27-yi-chu-yuan-su">
        </link>
        <updated>2019-09-03T14:44:56.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目要求<br>
给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p>示例 1:</p>
<p>给定 nums = [3,2,2,3], val = 3,</p>
<p>函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</p>
<p>你不需要考虑数组中超出新长度后面的元素。<br>
示例 2:</p>
<p>给定 nums = [0,1,2,2,3,0,4,2], val = 2,</p>
<p>函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p>
<p>注意这五个元素可为任意顺序。</p>
<p>你不需要考虑数组中超出新长度后面的元素。<br>
说明:</p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<p>// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝<br>
int len = removeElement(nums, val);</p>
<p>// 在函数里修改输入数组对于调用者是可见的。<br>
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。<br>
for (int i = 0; i &lt; len; i++) {<br>
    print(nums[i]);<br>
}</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/remove-element<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>我第一次给出的答案为下：</p>
<pre><code>class Solution {
public:
    int removeElement(vector&lt;int&gt;&amp; nums, int val) {
        int cut_len = 0 ;
        for(int i = 0;i&lt;nums.size();i++)
            if(nums[i]==val){
                ++cut_len;
                for (int j=i;j&lt;nums.size()-2;j++)
                    nums[j]=nums[j+1];
            }
         
         return nums.size()-cut_len;
    }
   
};
</code></pre>
<p>一提交，可以说是惨不忍睹了，算法有一个特点：解决办法和使用范围是同等重要的！<br>
我这个解法很明显没有考虑连续的val的情况 比如{3，2，2，3}去除2，第二个2很明显被前移略过了，想了一下应该是受算法书的“后面的元素往前移动”的惯性思维的影响，问题是算法书是去掉固定位置的值呢。。。<br>
修改了几次，还是有不少问题<br>
比如一开始j&lt;nums.size()-2处如果size为1，那么无符号的负数直接变成一个怪物，直接内存爆炸。<br>
最后深感这种方法的缺陷，于是观看官方答案：</p>
<blockquote>
<p>方法一：双指针<br>
思路</p>
<p>既然问题要求我们就地删除给定值的所有元素，我们就必须用 O(1)O(1) 的额外空间来处理它。如何解决？我们可以保留两个指针 i 和j，其中 i 是慢指针，j 是快指针。</p>
<p>算法</p>
<p>当 nums[j] 与给定的值相等时，递增 jj 以跳过该元素。只要 nums[j] 不等于nums[j] 我们就复制 nums[j] 到 nums[i]并同时递增两个索引。重复这一过程，直到 jj到达数组的末尾，该数组的新长度为 i。</p>
<p>该与 删除排序数组中的重复项 的解法十分相似。</p>
<pre><code>Java
public int removeElement(int[] nums, int val) {
    int i = 0;
    for (int j = 0; j &lt; nums.length; j++) {
        if (nums[j] != val) {
            nums[i] = nums[j];
            i++;
        }
    }
    return i;
}
</code></pre>
<p>复杂度分析</p>
<p>时间复杂度：O(n)，<br>
假设数组总共有 n 个元素，i 和 j 至少遍历 2n 步。</p>
<p>空间复杂度：O(1)。</p>
</blockquote>
<p>不禁感叹：妙啊！！！（第二种官方解法略坑，不考虑原数组顺序，就不贴上来了）<br>
主要思想就是使用两个指针（迭代器）,一个作为新数组的迭代器，一个作为旧数组的迭代器，旧数组有不同的就交给新数组，目标值的就跳过，既实现了原地修改，又避免了处理目标值这种棘手的问题，真的妙啊！<br>
复现如下：</p>
<pre><code>class Solution {
public:
    int removeElement(vector&lt;int&gt;&amp; nums, int val) {
        int i = 0;
        for(int j= 0;j&lt;nums.size();++j)
            if(nums[j]!=val)
               nums[i++]=nums[j];
         return i;
    
    }
};
</code></pre>
<p>其实复现中还是遇到了不少问题，一开始非常自大，看一眼就开始复现了，结果错漏百出，所以还是得老老实实分析出官方解法的算法思想，而不是流于代码表面，这样才可以在其他题目中轻轻松松复现出来！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第二章 笔记+习题]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-er-zhang-xi-ti-bi-ji</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-er-zhang-xi-ti-bi-ji">
        </link>
        <updated>2019-09-03T12:02:35.000Z</updated>
        <content type="html"><![CDATA[<p>2.1.1<br>
char 可以表示的范围-128-127 其中-128的表示为1000 0000 而0的表示为0000 0000（无负0）<br>
习题2.1<br>
区别在于类型数据所占的比特（16、32、64、16） 以及 含义（整型、长整型、长整型、和短整型）；无符号类型所有比特都是用来存储值，无法表示负数，带符号类型则可以表示负数，用一位来表示符号；float是单精度浮点数，只有6位有效数字，double是双精度浮点数，有10位有效数字<br>
练习2.2 利率应该使用float，本金使用int，付款使用double，因为一般利率为0.0xx，本金为10的倍数的正整数，付款容易出现小数。</p>
<p>2.1.2<br>
注意 不仅仅是等号=才会触发强制转换 所有符号包括&lt; &lt;= &gt; &gt;=都会触发强制转换，所以负值的int永远大于无符号数<br>
对无符号类型赋一个超出表示范围的值，初始值是对无符号类型表示数值总数取模后的余数 例如8比特大小的unsigned char可以表示0-255（256个数）则强行赋值-1的话，结果就是对-1取模256所得的余数255<br>
取模方法<br>
-17 % 10 的计算结果如下：r = (-17) - (-17 / 10) x 10 = (-17) - (-1 x 10) = -7<br>
17 % -10 的计算结果如下：r = 17 - (17 / -10) x (-10) = (17) - (-1 x -10) = 7<br>
-17 % -10 的计算结果如下：r = (-17) - (-17 / -10) x (-10) = (-17) - (1 x -10) = -7<br>
注意 -1%256=（-1）-（-1/256）x 256=255<br>
对带符号类型赋一个超出表示范围的值，结果是未定义的。<br>
unsigned符号默认忽略int 所以unsigned a；和unsigned int a；是一样的</p>
<p>习题2.3<br>
u2 - u = 32； u - u2 = -32 mod 2^32 = 4294967264；<br>
i2 - i = 32 i - i2=-32 i - u=0 u - i = 0</p>
<p>2.1.3<br>
严格来说十进制字面值不会是负值，负号并不在字面值之内，它的作用仅仅是对字面值取负值而已<br>
小数默认为double<br>
十进制字面值的类型：int、long、long long<br>
八进制和十六进制：int、unsigned int、long、unsigned long、long long和unsigned long long（输出不加规范的话还是十进制）<br>
自动选择能够容纳字面值的最小范围<br>
单引号‘a’ char型字面值 双引号“abc” 字符串型字面值<br>
字符串型字面值的类型实际上是由常量字符构成的数组<br>
编译器在每个字符串的结尾处添加一个空字符，因此字符串字面值的实际长度要比内容多1<br>
两个字符串字面值位置紧邻或仅由空格、缩进和换行符分隔，则它们实际上视为一个整体<br>
两类字符程序员不能直接使用：1.不可打印字符：退格等控制字符 2.特殊含义字符，需要使用转义序列<br>
true false 是布尔类型的字面值 nullptr是指针字面值</p>
<p>习题2.5<br>
（a）char型、wchar_t、字符串、宽字符串<br>
（b）int、unsigned int、long、unsigned long、八进制int、十六进制int<br>
（c）double、float、long double<br>
（d）int、unsigned int、double、double<br>
习题2.6<br>
第一组为十进制，输出为可见，第二组为八进制，输出还是可见，但是第一个0代表的就是八进制<br>
习题2.7<br>
（a）字符串常量，其中\145为八进制数，转化为e，\012转义为换行符 Latin1字符集<br>
(b)long double<br>
(c)float<br>
(d)long double<br>
习题2.8</p>
<pre><code>	cout &lt;&lt; &quot;2\115\0122\t\115&quot; &lt;&lt; endl;
</code></pre>
<p>2.2.1<br>
对象 是指一块能存储数据并具有某种类型的内存空间<br>
变量初始化不等于赋值<br>
花括号列表初始化会因为存在信息丢失（精确度丢失的问题）而拒绝初始化请求，编译器报错 等号初始化和括号初始化能够直接执行转换（直接丢弃部分值）<br>
默认初始化：1.定义在任何函数体之外的内置类型变量会初始化为0 2.定义在函数体内部的内置类型变量将不被初始化，此时变量的值是未定义的（undefined）<br>
std::string  empty;初始化为空串**（不可以输出）**<br>
注意</p>
<p>习题2.9<br>
(a)定义不正确，应该在函数调用外定义<br>
(b)列表赋值不允许精度丢失<br>
(c)错误，从左到右，所以b等于未定义（第一种情况<br>
(d)正确，但是会丢失精度 最后等于3<br>
习题2.10<br>
string不是内置类型，所以全部为空，int在函数外的为0，函数内部的是未定义的</p>
<p>2.2.2<br>
分离式编译 将程序分割为若干个文件，每个文件可以被独立编译。.<br>
声明 仅规定变量的类型和名字 定义 创建与名字关联的实体，申请存储空间 并赋初始值声明关键字 extern<br>
如果含有初始化的话就等于定义，抵消了extern的作用，同时试图初始化由extern标记的已定义变量会引发错误<br>
定义能且只能被定义一次，但可以被多次声明<br>
int j； 声明并定义  extern int j；声明  extern int j=1；定义</p>
<p>习题2.11<br>
(a)定义，因为已经初始化了(b)声明(c)声明</p>
<p>2.2.3标识符<br>
标识符对大小写字母敏感<br>
命名规范 1.体现实际含义 2.使用小写字母 3.用户自定义的类名一般以大写字母开头 4.多个单词组成时应有明显区分</p>
<p>习题2.12<br>
（a）非法 double是关键词<br>
（b）合法<br>
（c）符号-非法<br>
（d）非法，应该字母或下划线开头<br>
（e）合法，因为大小写敏感，Double不属于关键字</p>
<p>2.2.4<br>
全局作用域：函数体外定义 块作用域：定义在函数块内<br>
内层作用域中可以重新定义外层作用域已有的名字 但是不建议</p>
<p>习题2.13<br>
j=100，因为内层作用域中的同名向量会覆盖外层的名字<br>
习题2.14<br>
输出i=100 sum=45，for循环头定义的i作用域只能在循环体内，且会覆盖外层作用域的参数。</p>
<p>2.3复合类型<br>
一个声明语句：基本数据类型+声明符（例如&amp; *） 每个声明符命名了一个变量，并且指定该变量为与基本数据类型有关的某种类型（引用或指针）<br>
2.3.1<br>
引用  int i = 1024； int &amp;refer = i;  //refer指向i<br>
<strong>引用必须被初始化，不能只声明不定义</strong><br>
引用 是把变量和它的初始值绑定（bind）在一起，而不是把初始值拷贝给应用，<br>
引用将和它的初始值对象一直绑定在一起，而无法将应用重新绑定到另外一个对象，因引用必须初始化。<br>
可以给引用赋值（区分初始化） 赋值和初始化的区别。<br>
引用可以复引用 int &amp;refer2 = refer; 但是无法定义引用的引用，因为引用本身不是一个对象<br>
引用可以用于赋值或初始化 int i2 = refer;<br>
引用类型的初始值必须是一个对象，不可以是字面值或者某个表达式</p>
<p>习题2.15<br>
（b） 不合法，不能用普通引用指向字面值常量（d）不合法，引用必须初始化<br>
习题2.16<br>
都合法，只是c、d会损失精度<br>
习题2.17<br>
两个都为10</p>
<p>2.3.2<br>
指针与引用的区别：1.指针是一个对象，可以对其进行赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象（引用只能指向一个对象）2.指针无须在定义时赋初值<br>
定义指针类型 int *ip1<br>
获取指针的地址 &amp; 取地址符 int *ip2 = &amp;ip1；<br>
<strong>不能定义指向引用的指针 因为引用不是对象</strong><br>
所有指针的类型都要和它所指向的对象严格匹配<br>
指针的四个状态1.指向一个对象2.指向紧邻对象所占空间的下一位置 3.空指针 4.无效指针<br>
就算指向的对象为初始化，指针也不为空<br>
无效指针不能访问，否则引发错误<br>
* 解引用符<br>
空指针生成方法 int *p1 = nullptr;   int *p2 = 0;   int *p3 = NULL;（需要引用#include cstdlib）<br>
nullptr 通用的特殊类型字面值 更推荐使用<br>
NULL 预处理变量 值为0<br>
一个指针指向某对象，而另一指针指向另外对象的下一地址，指针值可能相同<br>
void* 指针 可以存放任何类型的对象的地址 但只能进行指针比较，作为函数输入输出或者赋给另外一个void*指针，<strong>不能直接操作所指对象，不能赋给其他特定类型的指针对象</strong><br>
<em><em>不能用int初始int</em>，就是int中可能是地址的值也不行</em>*</p>
<p>习题2.18</p>
<pre><code>	int x,y= 10;
	int *x_p = &amp;x;
	*x_p = 20;
	cout &lt;&lt; *x_p &lt;&lt; endl;  //20
	x_p = &amp;y;
	cout &lt;&lt; *x_p &lt;&lt; endl; //10
</code></pre>
<p>习题2.19<br>
指针是一个对象，引用不是一个对象，所以有指针的引用，没有引用的指针。<br>
习题2.20<br>
将i的值进行平方<br>
习题2.21<br>
（a）非法，指针的类型应该和其指向的对象的类型一致，不会执行默认类型转换（b）非法，<em><em>不能用int初始int</em>，就是int中可能是地址的值也不行</em>*<br>
习题2.22<br>
if(p)判断p是否为空指针  if(*p)判断p指向的值是否为0 <strong>就算指向的对象为初始化，指针也不为空</strong><br>
习题2.23<br>
只能通过if进行空指针判断，对象的有效性是必需由程序员保证的<br>
习题2.24<br>
void*指针可以指向任何类型的指针，只是不能进行直接的操作。</p>
<p>2.3.3<br>
声明符应该靠近变量而不是类型，<em><em>比如int</em> p1,p2;//其实等同于int *p1;int p2;</em>*<br>
根据*的个数可以判断指针的级别 同时也等于解引用次数<br>
存在指向指针的引用 int *i = 42; int *p ;<strong>int *&amp;r=p;</strong><br>
使用从右向左阅读，离变量名最近的符号对变量的类型有最直接的影响 例如int *&amp;r<br>
习题2.25<br>
(a)ip是int指针，i是int，r是int引用<br>
(b)i是int，ip是int指针<br>
(c)ip是int指针，ip2是int<br>
<strong>声明符应该靠近变量而不是类型的原因</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组-翻转图像]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-fan-zhuan-tu-xiang</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-fan-zhuan-tu-xiang">
        </link>
        <updated>2019-09-03T01:32:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题目">题目</h1>
<p>给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。</p>
<p>水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 [1, 1, 0] 的结果是 [0, 1, 1]。</p>
<p>反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。例如，反转 [0, 1, 1] 的结果是 [1, 0, 0]。</p>
<p>示例 1:</p>
<p>输入: [[1,1,0],[1,0,1],[0,0,0]]<br>
输出: [[1,0,0],[0,1,0],[1,1,1]]<br>
解释: 首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；<br>
然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]<br>
示例 2:</p>
<p>输入: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]<br>
输出: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]<br>
解释: 首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；<br>
然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]<br>
说明:</p>
<p>1 &lt;= A.length = A[0].length &lt;= 20<br>
0 &lt;= A[i][j] &lt;= 1</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/flipping-an-image</p>
<pre><code>class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; flipAndInvertImage(vector&lt;vector&lt;int&gt;&gt;&amp; A) {
   	}
}
</code></pre>
<p>刚刚看到题目的时候还是首先下意识看形参了（后来发现这样并不是一个好习惯）看到嵌套的vector，思考了一会，首先必须打开第一层，于是想使用模板具有的迭代器配合for范围语句进行翻转，然后考虑如果使得0、1反转，发现简单的1-temp就可以实现反转了。于是得到下面代码：</p>
<pre><code>for (auto &amp;vec : A) {
		auto head = vec.begin();
		auto last = vec.end();
		last = last - 1;
           if(last == head){
               auto only = *head;
				*head = 1 - only;}
           else{
        while (head != last) {
			swap(head,last)；
			++head;
			if (head == last)
				break;
			else if ((--last) == head) {
				auto mid = *head;
				*head = 1 - mid;
		  	}
		  }
  	}
  }
        return A;
				}
</code></pre>
<p>这段代码一看过去就知道有许多值得优化的地方了，说一下遇到的<strong>坑点</strong>吧：<br>
1.for范围语句定义的参数是值拷贝的，必须改为引用拷贝，否则后面的工作全都是在一个副本上操作的（全部木大！）<br>
2.vec.end()返回的是尾后迭代器！！！不是指向最后一个值！！！<br>
3.由于存在一个值的情况，必须先判断迭代器指向的位置是否相等。<br>
4.迭代器的解引用似乎出现了问题，既不能赋值，也不能作为swap的形参进行传递，只能通过temp进行传递（解决方法：迭代器有专用的swap，iter_swap)<br>
5.两个迭代器同时向中间移动，重合判断会比较麻烦。（第一次bug居然是尾后迭代器进行递增了...）</p>
<p>终于完成后看了一下评论，果然发现自己的思考思路有问题，官方给出的题解如下（基于JAVA)</p>
<pre><code>class Solution {
    public int[][] flipAndInvertImage(int[][] A) {
        int C = A[0].length;
        for (int[] row: A)
            for (int i = 0; i &lt; (C + 1) / 2; ++i) {
                int tmp = row[i] ^ 1;
                row[i] = row[C - 1 - i] ^ 1;
                row[C - 1 - i] = tmp;
            }

        return A;
    }
}
</code></pre>
<p>不得不说解答还是挺精妙的，当我还在想奇数个元素时如何修改中位数时，解答就已经用【保存temp变量再交换】的思想解决了，省去了一个if判断，非常精妙。<br>
问题很明显：这是个数组问题，不是vector问题！！！应该从数组出发，那么最简单的方法就应该是下标嘛！唉又把简单的问题复杂化了。不过这样也有个好处，就是让自己能够多点把学到的东西用起来，主动去查找bug背后的原因<br>
修改后的代码如下：</p>
<pre><code>class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; flipAndInvertImage(vector&lt;vector&lt;int&gt;&gt;&amp; A) {
       for (auto &amp;vec :A)
	{
		int len = vec.size();
		for(int i = 0;i&lt;=len-i-1;++i){
				int temp = 1 - vec[i];
				swap(vec[i], vec[len - i - 1]);
				vec[i] = 1 - vec[i];
				vec[len - i - 1] = temp;
		}

	}
        return A;
    }
};
</code></pre>
<p>另外吐槽一点，leetcode的运算时间很迷，第一次提交最后代码居然是28ms，不服后再次提交变成了12ms...</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub远程提交代码]]></title>
        <id>https://lixin-ee.github.io//post/github-yuan-cheng-ti-jiao-dai-ma</id>
        <link href="https://lixin-ee.github.io//post/github-yuan-cheng-ti-jiao-dai-ma">
        </link>
        <updated>2019-09-02T12:27:19.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1下载git工具">1.下载git工具</h1>
<h1 id="2在将要上传的文件文件夹中右键-git-bash-here">2.在将要上传的文件/文件夹中右键 git bash here</h1>
<p>注意，例如我要提交 cpp-primer中的chapter1文件夹，就应该在cpp-primer文件夹中打开git工具</p>
<h1 id="3绑定用户">3.绑定用户</h1>
<pre><code>git config --global user.name &quot;Lixin-ee&quot;
git config --global user.email &quot;im_lixin@foxmail.com&quot;
</code></pre>
<h1 id="4生成ssh-key">4.生成ssh key</h1>
<p><code>cd ~/.ssh</code><br>
检查是否已生成密钥，如果返回的ls有3个文件,则密钥已经生成。<br>
如果没有密钥，则通过下面命令生成<br>
<code>ssh-keygen -t rsa -C &quot;im_lixin@foxmail.com&quot;</code><br>
生成成功后，去对应目录C:\Users\你的电脑名.ssh里用记事本打开id_rsa.pub，得到ssh key公钥。</p>
<h1 id="5为github账号配置ssh-key">5.为github账号配置ssh key</h1>
<p>切换到github-settings-SSH key-Add SSH key-填上标题（最好跟本地仓库保持一致）。</p>
<h1 id="6建立本地仓库">6.建立本地仓库</h1>
<p>执行指令：<br>
<code>git init</code><br>
初始化成功后你会发现项目里多了一个隐藏文件夹.git<br>
执行指令：<br>
<code>git add .</code><br>
将所有文件添加到仓库<br>
执行指令：<br>
<code>git commit -m &quot;提交文件&quot;</code><br>
注意双引号内是github仓库中文件的注释！！！一定要修改，比如我的可以改成chapter1.</p>
<h1 id="7到github-text仓库复制仓库地址">7.到github text仓库复制仓库地址</h1>
<p>执行指令：<br>
<code>git remote add origin https://github.com/Lixin-ee/cpp-primer.git</code></p>
<h1 id="8上传本地代码">8.上传本地代码</h1>
<p>执行指令：<br>
<code>git push -u origin master</code></p>
<h1 id="9刷新github">9.刷新github</h1>
<p>完成！</p>
<p>参考：https://www.jianshu.com/p/191d1e21f7ed</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第一章 笔记+习题]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-yi-zhang-bi-ji-xi-ti</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-yi-zhang-bi-ji-xi-ti">
        </link>
        <updated>2019-09-02T07:30:37.000Z</updated>
        <content type="html"><![CDATA[<p>1.1<br>
c++程序必须有一个函数命名为main<br>
函数定义包括四部分：返回类型，函数名，函数主题，形参列表<br>
main函数的返回类型必须为int<br>
main的返回值用于指示状态，返回值0表明成功，非0用于指出错误类型</p>
<p>习题1.2</p>
<pre><code>int main() {
	return -1;
}
</code></pre>
<p>//程序“[45476] cpphomework.exe”已退出，返回值为 -1 (0xffffffff)。</p>
<p>1.2<br>
iostream 分为 istream和ostream<br>
cin 标准输入 cout 标准输出 cerr 标准错误 clog 输出程序运行的一般信息<br>
#include&lt;头文件&gt;<br>
输出运算符 &lt;&lt; 左侧的运算对象必须是一个ostream对象，右侧运算对象就是要打印的值<br>
endl 操纵符 结束当前行，并将缓冲区的内容刷到设备中<br>
st::指出cout和endl是定义在名为std的命名空间中<br>
标准库所有名字都在命名空间std中<br>
命名空间 避免名字相同冲突<br>
::作用域运算符<br>
输入运算符&gt;&gt;</p>
<p>习题1.3</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;

int main() {
	cout &lt;&lt; &quot;Hello,World&quot; &lt;&lt; endl;
}
</code></pre>
<p>习题1.4</p>
<pre><code>int main() {
	int a = 1, b = 3;
	cout &lt;&lt; &quot;a+b=&quot;&lt;&lt;a+b&lt;&lt; endl;
	cout &lt;&lt; &quot;a*b=&quot; &lt;&lt; a*b &lt;&lt; endl;
}
</code></pre>
<p>习题1.5</p>
<pre><code>int main() {
	int a = 1, b = 3;
	cout &lt;&lt; &quot;a+b=&quot;;
	cout &lt;&lt; a + b &lt;&lt; endl;
	cout &lt;&lt; &quot;a*b=&quot; ;
	cout &lt;&lt;  a*b &lt;&lt; endl;
	while (1);
}
</code></pre>
<p>注意此处为了维持格式一致，endl的使用时机要把握好。</p>
<p>习题1.6<br>
非常明显的不合法，因为一句代码的结束是以分号为标志的，如果没有遇到分号，则程序会自动读取第二行，所以需要把多余的分号去除。</p>
<p>1.3注释简介<br>
// 双斜线注释 用于半行和单行附注<br>
/* */注释界定符 用于多行注释<br>
/* */注释界定符 不能嵌套在另外一个注释界定符内</p>
<p>习题1.7<br>
warning C4138: 在注释外找到“*/”<br>
习题1.8<br>
第一句 合法 输出*  实际输出/*<br>
第二句 合法 输出*/  实际输出*/<br>
第三句 不合法  实际不合法<br>
第四句 不合法 实际不合法</p>
<p>1.4 控制流<br>
习题 1.9</p>
<pre><code>int main() {
	int i = 50;
	int sum = 0;
	while (i &lt;= 100) {
		sum += i;
		++i;
	}
	cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl;
}
</code></pre>
<p>习题1.10<br>
int main() {<br>
int i = 10;<br>
while (i &gt;=0) {<br>
cout &lt;&lt; i-- &lt;&lt; endl;<br>
}<br>
}<br>
习题1.11</p>
<pre><code>int main() {
	int begin,end;
	cout &lt;&lt; &quot;Please input one number:&quot;;
	cin &gt;&gt; begin;
	cout &lt;&lt; &quot;Please input another number:&quot;;
	cin &gt;&gt; end;
	if (end &lt; begin)
		swap(begin, end);
	while (end &gt;= begin) 
	  cout &lt;&lt; begin++ &lt;&lt; endl;
}
</code></pre>
<p>1.4.2<br>
for循环头中定义的变量在循环结束后不能再使用<br>
while同理，循环条件中定义的变量作用范围仅仅在循环体内</p>
<p>习题 1.12<br>
完成了从-100到100的整数的相加和，sum终值为0<br>
习题1.13<br>
本题比较简单，主要需要注意的是for循环头的特性（1）循环头可以定义多个变量，但所有变量都只能是同一个类型，同时变量作用域只在循环内（2）表达式也可以有多个，但是一般来说都是用来改变判断条件的，太复杂反而适得其反。<br>
习题1.14<br>
for循环的循环起始很确定，通过循环头就一览无遗，适合于确定次数的循环（但是同时要求对循环头有良好的书写习惯）。while适用于只知道判断条件的不确定次数循环，并且需要阅读循环体确认循环变化。<br>
习题1.15<br>
如今许多IDE都为我们提供了自动补全、自动监测等功能，我们甚至无须编译就可以知道错误所在，但是在手写灵感、工作交流当中，避免形式错误还是很重要的。</p>
<p>1.4.3<br>
while(std::cin&gt;&gt;value) 此循环条件实际上检测的是std::cin<br>
习题 1.16</p>
<pre><code>int main() {
	int i = 0,sum = 0;//i的定义必不可少！
	while (cin &gt;&gt; i)//当遇到的输入不为int整数时结束输入
		sum += i;
	cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl;
}
</code></pre>
<p>1.5 类简介<br>
1.5.1	<br>
每一个类都定义了一个新类型 其类型名就是类名<br>
每个对象可以1编写函数调用参数 2用输入运算符&gt;&gt;和输出运算符&lt;&lt;进行读写 3用赋值运算符=进行赋值 4.用加法运算符进行相加？ 5用复合赋值运算符+=进行运算<br>
头文件定义 不属于标准库的头文件 #include “Class_type.h”</p>
<p>习题1.20</p>
<pre><code>int main() {
	Sales_item item_t;
	while (cin &gt;&gt; item_t)
		cout &lt;&lt; item_t&lt;&lt;endl;
}
</code></pre>
<p>习题1.21</p>
<pre><code>int main() {
	Sales_item item_1,item_2;
	cin &gt;&gt; item_1 &gt;&gt; item_2;
	cout &lt;&lt; item_1 + item_2 &lt;&lt; endl;
}
</code></pre>
<p>习题1.22<br>
int main() {<br>
Sales_item item_s;<br>
Sales_item item_t;<br>
while (cin &gt;&gt; item_t) {<br>
item_s += item_t;<br>
cout &lt;&lt; item_s &lt;&lt; endl;<br>
}<br>
}<br>
习题1.23<br>
int main() {<br>
Sales_item item_last, item_curr;<br>
int sum = 1;<br>
if(cin &gt;&gt; item_curr) {<br>
item_last = item_curr;<br>
while (cin &gt;&gt; item_curr) {<br>
if (item_curr.isbn == item_last.isbn) {<br>
item_last += item_curr;<br>
++sum;<br>
}<br>
else<br>
{<br>
cout &lt;&lt; item_last &lt;&lt; '\t' &lt;&lt; sum &lt;&lt; endl;<br>
item_last = item_curr;<br>
sum = 1;<br>
}<br>
}<br>
cout &lt;&lt; item_last &lt;&lt; endl;<br>
}<br>
}</p>
<h1 id="总结">总结</h1>
<p>第一章比较基础，但是从练习中我们可以体会到很多细节，例如for循环头的隐藏设定，参数应该设定为局部变量还是全局变量，参数的作用域影响函数的运行以及输出输入，仔细阅读类定义的头文件再使用类的功能会事半功倍。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表-删除指定节点]]></title>
        <id>https://lixin-ee.github.io//post/leetcode-shua-ti-gan-xiang-0902</id>
        <link href="https://lixin-ee.github.io//post/leetcode-shua-ti-gan-xiang-0902">
        </link>
        <updated>2019-09-02T02:49:37.000Z</updated>
        <content type="html"><![CDATA[<p>今天第一次开始刷leetcode，遵循前辈们的意见从容易开始刷，第一次选择了一个链表题，题目如下</p>
<p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。<br>
现有一个链表 -- head = [4,5,1,9]，它可以表示为:<br>
输入: head = [4,5,1,9], node = 5<br>
输出: [4,1,9]<br>
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p>
<p>非常基础的一个链表结点删除，但是看到代码后我却无从下手了</p>
<pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void deleteNode(ListNode* node) {
        }
};
</code></pre>
<p>what？只给了一个形参？不是应该给出链表的吗？<br>
但是还是立即开始思考如何遍历链表，这个过程中就暴露自己对遍历记得不牢固了，一直纠结判断条件到底是先判断结点值是否相等还是当前节点是否已经到达尾结点，翻查书籍后发现也不对啊，书中描述至少应该给出链表和删除标记（删除位置或删除值）<br>
心灰意冷下打开评论才发现是自己读题错误了，题目给出的条件是删除【给定的】节点！<br>
然后瞬间就想出答案了</p>
<pre><code>class Solution {
public:
    void deleteNode(ListNode* node) {
        node-&gt;val = node-&gt;next-&gt;val;
        node-&gt;next =  node-&gt;next-&gt;next;
        }
};
</code></pre>
<p>同时发现一个小问题，一开始在调用val数据成员时想按老习惯进行解引用(*)和调用符（.），由于解引用符的优先级低于调用符，所以是必需在解引用指针时加上括号的，于是就出现了下面的情况：</p>
<pre><code>class Solution {
public:
    void deleteNode(ListNode* node) {
        (*node).val = (*((*node).next)).val;
        (*node).next = (*((*node).next)).next;
        }
};
</code></pre>
<p>代码是自己写的自己还能懂，但是如果和同事交接时，这可读性可以说是惨不忍睹了...所以老习惯不一定是好习惯啊。<br>
这一次的心得体会：还是得好好看题！看清楚题目要求比一切都重要！同时基础要扎实！培养良好的代码风格！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[开始我的博客之路]]></title>
        <id>https://lixin-ee.github.io//post/kai-shi-wo-de-bo-ke-zhi-lu</id>
        <link href="https://lixin-ee.github.io//post/kai-shi-wo-de-bo-ke-zhi-lu">
        </link>
        <updated>2019-09-01T12:13:05.000Z</updated>
        <content type="html"><![CDATA[<p>在今天正式开始我的博客之路<br>
说来惭愧，其实早就知道博客的存在，并从中获取到了非常多的知识以及问题的解决方案，只是一直没有把时间分配出来写博客。但在学习的过程中，越发感觉到编写技术博客的便利之处，例如将书中的笔记整理上传到博客中，方便在手机随时查看，同时可以把相关的文件和完成的项目上传到github，与博客相辅相成，对学习有很大帮助。在与参加实习和秋招的师兄师姐的交流中得到很多令人醍醐灌顶的指点，其中之一便是一个技术博客对一位普通大学学生转化成合格的程序员的重要性，决定从今天起，也就是研二的第一天起坚持更新博客。</p>
<p>初步的构想是为来年的实习打好坚实的基础，目标岗位是C++后台开发与机器学习算法岗。首先开始复习C++与算法数据结构，将C++ primer的笔记重新整理一遍，并将相应的课后题重新做一遍巩固基础知识点。开始LeetCode刷题，将重难点与感想更新到博客上。</p>
<p>千里之行始于足下，但更重要的是看清自己的目标、自己的能力以及自己走过的路。这几天放慢学习的脚步，细细看了很多秋招面经，也与很多师兄师姐谈心，感叹自己之前还是不够拼搏，没有将许多宝贵的时间进行充分的利用，但种下一棵树最好的时间一个是十年前，一个便是现在，虽未必能在一年后的秋招中获得最理想的结果，但我相信踏实走过的路，总会回报以相应的美景。<br>
-2019.09.01</p>
]]></content>
    </entry>
</feed>