<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-03-07T00:19:40.580Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>In the darkest night,Rising like a spire.</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[链表 题52:两个链表的第一个公共结点]]></title>
        <id>https://lixin-scut.github.io//post/lian-biao-ti-52liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian</id>
        <link href="https://lixin-scut.github.io//post/lian-biao-ti-52liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian">
        </link>
        <updated>2020-03-07T00:11:59.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>输入两个链表，找出它们的第一个公共结点。</p>
</blockquote>
<p>最简单的就是hash set了，两次循环<br>
然后就是leetcode的方法，走到结尾后再从另一链表的头节点开始，两者会在目标节点相遇<br>
最后就是书中判断长度的方法，三次循环，先判断长度差，较长者先走n-m步</p>
<pre><code>/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
</code></pre>
<p>最简单的就是hash set了，两次循环<br>
然后就是leetcode的方法，走到结尾后再从另一链表的头节点开始，两者会在目标节点相遇<br>
最后就是书中判断长度的方法，三次循环，先判断长度差，较长者先走n-m步</p>
<p>实现注意事项<br>
哈希表：首先用逻辑或判断是否有节点为空，记得当前节点的next操作不要忘了<br>
长度差：可以用两个while来让程序自动判断长度差的正负，然后可以只判断一个节点是否为空，因为此时长度相同，就算没有公共节点也会同时到达尾节点<br>
leetcode方法：需要注意的就是两个链表没有公共节点的情况，此时最后两者会同时到达NULL，需要加上这个额外的条件</p>
<pre><code>class Solution {
public:
    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2){
        if(pHead1==NULL||pHead2==NULL)
            return NULL;
        
        ListNode *curNode1,*curNode2;
        curNode1=pHead1;
        curNode2=pHead2;
        while(curNode1!=curNode2){
            if(curNode1-&gt;next==NULL&amp;&amp;curNode2-&gt;next==NULL)
                return NULL;
            if(curNode1-&gt;next==NULL)
                curNode1=pHead2;
            else 
                curNode1=curNode1-&gt;next;
            if(curNode2-&gt;next==NULL)
                curNode2=pHead1;
            else 
                curNode2=curNode2-&gt;next;
        }
        return curNode1;
    }
    /*
    //长度差法
    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2){
        if(pHead1==NULL||pHead2==NULL)
            return NULL;
        
        int len1,len2;
        ListNode *curNode1,*curNode2;
        
        len1=0;
        curNode1=pHead1;
        while(curNode1){
            ++len1;
            curNode1=curNode1-&gt;next;
        }
        
        len2=0;
        curNode2=pHead2;
        while(curNode2){
            ++len2;
            curNode2=curNode2-&gt;next;
        }
        
        curNode1=pHead1;
        curNode2=pHead2;
        while(len1&gt;len2){
            curNode1=curNode1-&gt;next;
            --len1;
        }
        while(len2&gt;len1){
            curNode2=curNode2-&gt;next;
            --len1;
        }
        
        while(curNode1&amp;&amp;curNode1!=curNode2){
            curNode1=curNode1-&gt;next;
            curNode2=curNode2-&gt;next;
        }
        
        return curNode1;
    }
    
    //hashset
    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) {
        if(pHead1==NULL||pHead2==NULL)
            return NULL;
        unordered_set&lt;ListNode*&gt; nodeSet;
        ListNode* curNode=pHead1;
        while(curNode){
            nodeSet.insert(curNode);
            curNode=curNode-&gt;next;
        }
        curNode=pHead2;
        while(curNode){
            if(nodeSet.count(curNode))
                return curNode;
            curNode=curNode-&gt;next;
        }
        return NULL;
    }
    */
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>如果两个链表有公共节点，那么公共节点出现在两个链表的尾部。如果我们从两个链表的尾部开始往前比较，那么最后一个相同的节点就是我们要找的节点。可问题是，在单向链表中，我们只能从头节点开始按顺序遍历， 最后才能到达尾节点。最后到达的尾节点却要最先被比较，这听起来是不是像“后进先出”？于是我们就能想到用栈的特点来解决这个问题:分别把两个链表的节点放入两个栈里，这样两个链表的尾节点就位于两个栈的栈顶，接下来比较两个栈顶的节点是否相同。如果相同， 则把栈顶弹出接着比较下一个栈顶，直到找到最后一个相同的节点。空间复杂度是O(m+n)，这种思路的时间复杂度也是O(m+n)<br>
其实解决这个问题还有一种更简单的办法:首先遍历两个链 表得到它们的长度， 就能知道哪个链表比较长，以及长的链表比短的链表多 几个节点。在第二次遍历 的时候，在较长的链表上先走若干步，接着同时在 两个链表上遍历，找到的第一 个相同的节点就是它们的第一个公共节点。</p>
</blockquote>
<pre><code>ListNode* FindFirstCommonNode(ListNode *pHead1, ListNode *pHead2)
{
    // 得到两个链表的长度
    unsigned int nLength1 = GetListLength(pHead1);
    unsigned int nLength2 = GetListLength(pHead2);
    int nLengthDif = nLength1 - nLength2;

    ListNode* pListHeadLong = pHead1;
    ListNode* pListHeadShort = pHead2;
    if(nLength2 &gt; nLength1)
    {
        pListHeadLong = pHead2;
        pListHeadShort = pHead1;
        nLengthDif = nLength2 - nLength1;
    }

    // 先在长链表上走几步，再同时在两个链表上遍历
    for(int i = 0; i &lt; nLengthDif; ++i)
        pListHeadLong = pListHeadLong-&gt;m_pNext;

    while((pListHeadLong != nullptr) &amp;&amp;
        (pListHeadShort != nullptr) &amp;&amp;
        (pListHeadLong != pListHeadShort))
    {
        pListHeadLong = pListHeadLong-&gt;m_pNext;
        pListHeadShort = pListHeadShort-&gt;m_pNext;
    }

    // 得到第一个公共结点
    ListNode* pFisrtCommonNode = pListHeadLong;

    return pFisrtCommonNode;
}

unsigned int GetListLength(ListNode* pHead)
{
    unsigned int nLength = 0;
    ListNode* pNode = pHead;
    while(pNode != nullptr)
    {
        ++nLength;
        pNode = pNode-&gt;m_pNext;
    }

    return nLength;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 题51:数组中的逆序对]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-ti-51shu-zu-zhong-de-ni-xu-dui</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-ti-51shu-zu-zhong-de-ni-xu-dui">
        </link>
        <updated>2020-03-07T00:05:23.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p>
</blockquote>
<p>【未做出】<br>
一开始并没有什么思路，只能先从暴力法寻找思路<br>
实现暴力法的时候不小心把小于号打成大于号了。。。<br>
不知道为啥显示不通过一个用例，但是这个用例非常长，估计就是超时了<br>
然后就是希望往时间复杂度O(n)努力，同时肯定需要牺牲空间复杂度<br>
第一个想法是保存排序已经循环的数组，然后判断新的元素的位置，这样利用二分法可以将复杂度压低到O(nlogn)（注意插入还是导致时间复杂度为O（n））<br>
还是看了书本答案 发现是归并排序法</p>
<pre><code>class Solution {
public:
    //我fo了，不知道牛客网哪里出错了，超长用例就是通过不了
    /*
    int InversePairs(vector&lt;int&gt; data){
        if(data.empty())
            return 0;
        vector&lt;int&gt; temp(data.begin(),data.end());
        
        return InversePairs(data,temp,0,data.size()-1)%1000000007;
    }
    
    int InversePairs(vector&lt;int&gt; &amp;data,vector&lt;int&gt; &amp;temp,int beg,int end){
        if(beg==end){
            temp[beg]=data[beg];
            return 0;
        }
        int mid=beg+(end-beg)/2;
        int left=InversePairs(temp,data,beg,mid);
        int right=InversePairs(temp,data,mid+1,end);
        int minP,maxP,locate,count;
        minP=mid;
        maxP=end;
        locate=end;
        count=0;
        while(minP&gt;=beg&amp;&amp;maxP&gt;=mid+1){
            if(data[minP]&lt;=data[maxP]){
                temp[locate]=data[maxP];
                --maxP;
                --locate;
            }else{
                count+=maxP-mid;
                temp[locate]=data[minP];
                --minP;
                --locate;
            }
        }
        while(maxP&gt;=mid+1){
            temp[locate]=data[maxP];
            --maxP;
            --locate;
        }
        while(minP&gt;=beg){
            temp[locate]=data[minP];
            --minP;
            --locate;
        }
        return left+right+count;
    }
    */
    
    
    /*
    //暴力法【超时】
    int InversePairs(vector&lt;int&gt; data) {
        if(data.empty())
            return 0;
        int len=data.size();
        int count=0;
        for(int i=0;i&lt;len-1;++i)
            for(int j=i+1;j&lt;len;++j){
                if(data[j]&lt;data[i])
                    ++count;
            }
        return count%1000000007;
    }
    */
};
</code></pre>
<p>书本题解<br>
<img src="https://lixin-scut.github.io//post-images/1583539828823.png" alt=""></p>
<blockquote>
<p>我们先用两个指针分别指向两个子数组的末尾，并每次比较两个指针指向的数 字。如果第一个子数组中的数字大于第二个子数组中的数字，则构成逆序对，并且逆序对的数目等于第二个子数组中剩余数字的个数。如果第一个数组中的数字小于或等于第二个 数组中的数字，则不构成逆序对。每次比较的时候， 我们都把较大的数字从后往前复制到一 个辅助数组，确保辅助数组中的数字是递增排序的。在把较大的数字复制到辅助数组之后，把对应的指针向 前移动一位，接下来进行下一轮比较。</p>
</blockquote>
<pre><code>int InversePairs(int* data, int length)
{
    if(data == nullptr || length &lt; 0)
        return 0;

    int* copy = new int[length];
    for(int i = 0; i &lt; length; ++i)
        copy[i] = data[i];

    int count = InversePairsCore(data, copy, 0, length - 1);
    delete[] copy;

    return count;
}

int InversePairsCore(int* data, int* copy, int start, int end)
{
    if(start == end)
    {
        copy[start] = data[start];
        return 0;
    }

    int length = (end - start) / 2;

    int left = InversePairsCore(copy, data, start, start + length);
    int right = InversePairsCore(copy, data, start + length + 1, end);

    // i初始化为前半段最后一个数字的下标
    int i = start + length;
    // j初始化为后半段最后一个数字的下标
    int j = end;
    int indexCopy = end;
    int count = 0;
    while(i &gt;= start &amp;&amp; j &gt;= start + length + 1)
    {
        if(data[i] &gt; data[j])
        {
            copy[indexCopy--] = data[i--];
            count += j - start - length;
        }
        else
        {
            copy[indexCopy--] = data[j--];
        }
    }

    for(; i &gt;= start; --i)
        copy[indexCopy--] = data[i];

    for(; j &gt;= start + length + 1; --j)
        copy[indexCopy--] = data[j];

    return left + right + count;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 题50:第一个只出现一次的字符位置]]></title>
        <id>https://lixin-scut.github.io//post/zi-fu-chuan-ti-50di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-wei-zhi</id>
        <link href="https://lixin-scut.github.io//post/zi-fu-chuan-ti-50di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-wei-zhi">
        </link>
        <updated>2020-03-06T23:32:04.000Z</updated>
        <content type="html"><![CDATA[<p>题目1描述</p>
<blockquote>
<p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.</p>
</blockquote>
<p>本来想说用相与，但是注意是第一个，说明可以含有多个只出现一次的字符，这时相与法就失效了<br>
然后第一个想到的就是26字母数组，循环两次，第一次计算次数，第二次寻找第一个次数为1的字母，因为字母的个数是确定的，所以相当于常数空间复杂度<br>
突然发现要分大小写，本来想设置52的数组然后减去‘A’就好，然后发现ASCII码中A和a的距离不是26而是32，把数组增加6就通过了<br>
然后发现书本题解是伪哈希表hhh，其实思路也一致，也是固定大小的数组</p>
<pre><code>class Solution {
public:
    int FirstNotRepeatingChar(string str) {
        if(str.empty())
            return -1;
        vector&lt;int&gt; alpha_count(58,0);
        for(auto alpha:str){
                ++alpha_count[(alpha-'A')];
        }
        int locate=0;
        for(locate=0;locate&lt;52;++locate){
            if(alpha_count[(str[locate]-'A')]==1)
                return locate;
        }
        return 0;
    }
};
</code></pre>
<p>书本题解：<br>
(注意牛客网的题目和书本的略有不同)</p>
<blockquote>
<p>由于题目与字符出现的次数相关，那么我们可以统计每个字符 在该字符串中出现的次数，需要一个数据容器来存放每个字符的出现次数。在这个数据容器中，可以根据字符来查找它出现次数，也就是说这个容器的作用是把一个字符映射成一个数字。在常用的数据容器中，哈希表正是这个用途。<br>
我们可以定义哈希表的键值(Key)是字符，而值 (Value) 是该字符出现的次数。同时我们还需要从头开始扫描字符串两次。 第一次扫描 字符串时，每扫描到一个字符，就在哈希表的对应项中把次数 加 lo 接下来第二 次扫描时，每扫描到一个字符，就能从哈希表中得到该字符出现的次数。<br>
字符(char)是-个长度为 8 的数据类型， 因此总共有 256 种可能。 于是我们创建一个长度为 256 的数组，每个字母 根据其 ASCII 码值作为数组的 下标对应数组的-个数字，而数组中存储的是每个字符出现的次数。这样我们就 创建了一个大小为 256、以字符 ASCII 码为键值的哈希表。<br>
第一次扫描时，在哈希表中更新一个字符出现的次数的时间是 O(1)。 如果 字符串长度为n，那么第一次扫描的时间复杂度是O(n)。第二次扫描时， 同样 在O(1)时间内能读出一个字符出现的次数，所以时间复杂度仍然是O(n)。这样算起来，总的时间复杂度是O(n)。同时，我们需要一个包含 256 个字符的辅助数组，它的大小是 1KB。由于这个数组的大小是一个常数， 因此可以认为这种 算法的空间复杂度是 O(1)。</p>
</blockquote>
<pre><code>char FirstNotRepeatingChar(const char* pString)
{
    if(pString == nullptr)
        return '\0';

    const int tableSize = 256;
    unsigned int hashTable[tableSize];
    for(unsigned int i = 0; i &lt; tableSize; ++i)
        hashTable[i] = 0;

    const char* pHashKey = pString;
    while(*(pHashKey) != '\0')
        hashTable[*(pHashKey++)] ++;

    pHashKey = pString;
    while(*pHashKey != '\0')
    {
        if(hashTable[*pHashKey] == 1)
            return *pHashKey;

        pHashKey++;
    }

    return '\0';
}
</code></pre>
<p>题目2描述</p>
<blockquote>
<p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符&quot;go&quot;时，第一个只出现一次的字符是&quot;g&quot;。当从该字符流中读出前六个字符“google&quot;时，第一个只出现一次的字符是&quot;l&quot;。<br>
输出描述:<br>
如果当前字符流没有存在出现一次的字符，返回#字符。</p>
</blockquote>
<p>【未做出】<br>
这道题我本来是考虑哈希表的，但是不知道怎么权衡出现次数和出现位置的关系<br>
后来发现这两者确实不好平衡，然后书中的点很好，先全部置为-1，<br>
然后就记录每个字母出现的最后位置，而不用管它们出现的次数<br>
然后又发现我会错题意了，必须重复出现的字符置为-1的<br>
注意hashmap的for范围循环语句中的每个元素是pair而不是键值的值</p>
<pre><code>class Solution
{
public:
  //Insert one char from stringstream
    void Insert(char ch)
    {
        ++locate;
        if(alpha_count.count(ch))
            alpha_count[ch]=-1;
        else
            alpha_count[ch]=locate;
    }
  //return the first appearence once char in current stringstream
    char FirstAppearingOnce()
    {
        char res='#';
        int min_count=INT_MAX;
        for(auto i:alpha_count){
            if(i.second&gt;0&amp;&amp;i.second&lt;min_count){
                min_count=i.second;
                res=i.first;
            }
        }
        return res;
    }
private:
    unordered_map&lt;char,int&gt; alpha_count;
    int locate=0;
};
</code></pre>
<p>书本题解：<br>
字符只能一个接着一个从字符流中读出来。可以定义一个数据容器来 保存字符在 字符流中的位置。当一个字符第一次从字符流中读出来时，把它在字符流中的位置 保存到数据容器里。当这个字符再次从字符流中读出来时，那么它就不是只出现一 次的字符，也就可以被忽略了。这时把它在 数据容器里保存的值更新成一个特殊的 值(如负数值)。<br>
为了尽可能高效地解决这个问题，需要在O(1)时间内往数据容器里插入一个 字符，以及更新一个字符对应的值。这个数据容器可以用哈希表来实现。用字符的ASCII码作为哈希表的键值，而把字 符对应的位置作为哈希表的值。<br>
在上述代码中，哈希表用数组 occurrence 实现。数组中的元素 occurrence和 ASCII码的值为 i 的字符相对应。最开始的时候，数组中的所有元素都初始化为 T。当一个 ASCII 码为 i 的字符第一次从字符流中读出时，occurrence的值更新为它在字符流中的位置。当这个字符再次从字符流中读出时occurrence 大于或者等于 0, occurrenc的值更新为-2<br>
当我们需要找出到目前为止从字符流里读出的所有字符中第一个不重复的字符时，只需要扫描整个数组，并从中找出最小的大于等于0的值对应的字符即可。这就是函数 FirstAppearingOnce的功能。</p>
<pre><code>class CharStatistics
{
public:
    CharStatistics() : index(0)
    {
        for(int i = 0; i &lt; 256; ++i)
            occurrence[i] = -1;
    }

    void Insert(char ch)
    {
        if(occurrence[ch] == -1)
            occurrence[ch] = index;
        else if(occurrence[ch] &gt;= 0)
            occurrence[ch] = -2;

        index++;
    }

    char FirstAppearingOnce()
    {
        char ch = '\0';
        int minIndex = numeric_limits&lt;int&gt;::max();
        for(int i = 0; i &lt; 256; ++i)
        {
            if(occurrence[i] &gt;= 0 &amp;&amp; occurrence[i] &lt; minIndex)
            {
                ch = (char) i;
                minIndex = occurrence[i];
            }
        }

        return ch;
    }

private:
    // occurrence[i]: A character with ASCII value i;
    // occurrence[i] = -1: The character has not found;
    // occurrence[i] = -2: The character has been found for mutlple times
    // occurrence[i] &gt;= 0: The character has been found only once
    int occurrence[256];
    int index;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[coreDump 与GDB调试]]></title>
        <id>https://lixin-scut.github.io//post/coredump-yu-gdb-diao-shi</id>
        <link href="https://lixin-scut.github.io//post/coredump-yu-gdb-diao-shi">
        </link>
        <updated>2020-03-06T11:57:02.000Z</updated>
        <content type="html"><![CDATA[<p>昨天在复习测试字节序的时候因为不小心char写成了char*，导致了segmentation fault ，并且产生了coreDump文件，刚好趁此机会学习一下coreDump分析和初步的GDB调试</p>
<p>首先贴上代码</p>
<pre><code>void func()
{
		test.s = 0x0102;
		if(test.c[0] == 1 &amp;&amp; test.c[1] == 2)
		{ cout &lt;&lt; &quot;This PC is BigEndian.&quot; &lt;&lt; endl; }
		else
		{ cout &lt;&lt; &quot;This PC is LittleEndian.&quot; &lt;&lt; endl; }
}
</code></pre>
<p>使用编译<br>
<code>g++ testCore.cc -o testCore</code><br>
运行后得到报错<br>
<code>Segmentation fault (core dumped)</code></p>
<h3 id="段错误">段错误</h3>
<p>“ 段错误(segmentation fault)”是指程序尝试访问不允许访问的内存地址的情况。</p>
<p>这可能是由于：<br>
试图解引用空指针（访问内存地址 0）；<br>
试图解引用其他一些不在合法的内存地址区间内中的指针；<br>
一个已被破坏并且指向错误的地方的 C++ 虚表指针(C++ vtable pointer)，这导致程序尝试执行没有执行权限的内存中的指令；<br>
其他一些比如问未对齐的内存地址也可能会导致段错误（在要求自然边界对齐的体系结构）。</p>
<p>我们在博文中找到的一个更简单的方法</p>
<h3 id="运行-valgrind">运行 valgrind</h3>
<p>运行<br>
<code>valgrind -v your-program</code><br>
将会输出一个故障时的堆栈调用序列</p>
<pre><code>==6647== Process terminating with default action of signal 11 (SIGSEGV): dumping core
==6647==  Access not within mapped region at address 0x102
==6647==    at 0x1088CE: func() (testCore.cc:18)
==6647==    by 0x108944: main (testCore.cc:25)
==6647==  If you believe this happened as a result of a stack
==6647==  overflow in your program's main thread (unlikely but
==6647==  possible), you can try to increase the size of the
==6647==  main thread stack using the --main-stacksize= flag.
==6647==  The main thread stack size used in this run was 8388608.
--6647-- REDIR: 0x525c950 (libc.so.6:free) redirected to 0x4c30cd0 (free)
==6647== 
==6647== HEAP SUMMARY:
==6647==     in use at exit: 0 bytes in 0 blocks
==6647==   total heap usage: 1 allocs, 1 frees, 72,704 bytes allocated
==6647== 
==6647== All heap blocks were freed -- no leaks are possible
==6647== 
==6647== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
==6647== 
==6647== 1 errors in context 1 of 1:
==6647== Invalid read of size 1
==6647==    at 0x1088CE: func() (testCore.cc:18)
==6647==    by 0x108944: main (testCore.cc:25)
==6647==  Address 0x102 is not stack'd, malloc'd or (recently) free'd
==6647== 
==6647== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
Segmentation fault (core dumped)
</code></pre>
<p>valgrind 没利用到coreDump的信息（更像是一次重新运行分析）</p>
<h3 id="coredump">coreDump</h3>
<p>coreDump 叫做核心转储，它是进程运行时在突然崩溃的那一刻的一个内存快照。操作系统在程序发生异常而异常在进程内部又没有被捕获的情况下，会把进程此刻内存、寄存器状态、运行堆栈等信息转储保存在一个文件里。<br>
   该文件也是二进制文件，可以使用gdb、elfdump、objdump或者windows下的windebug、solaris下的mdb进行打开分析里面的具体内容。</p>
<p>但是coreDump这个东西并不是系统自带的，我们需要先非常麻烦地设置一波，但是详细的设置还是直接看博文吧，就不水篇幅了</p>
<h3 id="必须设置">必须设置</h3>
<p><code>ulimit -c unlimited</code><br>
否则默认输出的coreDump文件为空<br>
但是本设置开关机后会重置，必须修改配置文件设置永久保存，顺带修改一下coreDump输出文件的文件名和存储位置等，防止重名覆盖，详细参考博文</p>
<p><strong>-g选项</strong><br>
<code>g++ testCore.cc -g -o testCore</code><br>
然后就是编译设置，如果gdb打开core文件时，没有显示调试信息，就是因为之前编译的时候没有带上-g选项，没有调试信息是正常的，实际上它也不影响调试core文件。因为调试core文件时，符号信息都来自符号表，用不到调试信息。如下为加上调试信息的效果。</p>
<h3 id="利用gdb进行coredump的定位">利用gdb进行coredump的定位</h3>
<p>首先注意命令</p>
<pre><code>gdb /root/Codes/testCore core
</code></pre>
<p>第二部分是我们的可运行文件，而不是路径，第三部分是coreDump文件<br>
此时就会显示</p>
<pre><code>Core was generated by `./testCore'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00005643dd4a68ce in func () at testCore.cc:18
18		if(test.c[0] == 1 &amp;&amp; test.c[1] == 2)
</code></pre>
<p>直接就定位到了错误发生的函数和位置</p>
<p>然后查看堆栈可以使用bt或者where命令</p>
<h3 id="几个常用的gdb命令">几个常用的gdb命令：</h3>
<p>l(list) ，显示源代码，并且可以看到对应的行号；<br>
b(break)x, x是行号，表示在对应的行号位置设置断点；<br>
p(print)x, x是变量名，表示打印变量x的值<br>
r(run), 表示继续执行到断点的位置<br>
n(next),表示执行下一步<br>
c(continue),表示继续执行<br>
q(quit)，表示退出gdb</p>
<h3 id="常用signal的含义">常用signal的含义</h3>
<p>SIGABRT：调用abort函数时产生此信号。进程异常终止。</p>
<p>SIGBUS：指示一个实现定义的硬件故障。</p>
<p>SIGEMT：指示一个实现定义的硬件故障。EMT这一名字来自PDP-11的emulator trap 指令。</p>
<p>SIGFPE：此信号表示一个算术运算异常，例如除以0，浮点溢出等。</p>
<p>SIGILL：此信号指示进程已执行一条非法硬件指令。4.3BSD由abort函数产生此信号。SIGABRT现在被用于此。</p>
<p>SIGIOT：这指示一个实现定义的硬件故障。IOT这个名字来自于PDP-11对于输入／输出TRAP(input/outputTRAP)指令的缩写。系统V的早期版本，由abort函数产生此信号。SIGABRT现在被用于此。</p>
<p>SIGQUIT：当用户在终端上按退出键（一般采用Ctrl-/）时，产生此信号，并送至前台进</p>
<p>程组中的所有进程。此信号不仅终止前台进程组（如SIGINT所做的那样），同时产生一个core文件。</p>
<p><strong>SIGSEGV：指示进程进行了一次无效的存储访问。名字SEGV表示“段违例（segmentationviolation）”。</strong></p>
<p>SIGSYS：指示一个无效的系统调用。由于某种未知原因，进程执行了一条系统调用指令，但其指示系统调用类型的参数却是无效的。</p>
<p>SIGTRAP：指示一个实现定义的硬件故障。此信号名来自于PDP-11的TRAP指令。</p>
<p>SIGXCPUSVR4和4.3+BSD支持资源限制的概念。如果进程超过了其软C P U时间限制，则产生此信号。</p>
<p>SIGXFSZ：如果进程超过了其软文件长度限制，则SVR4和4.3+BSD产生此信号。</p>
<h3 id="coredump产生的几种可能情况">coredump产生的几种可能情况</h3>
<p>造成程序coredump的原因有很多，这里总结一些比较常用的经验吧：<br>
 1，内存访问越界<br>
  a) 由于使用错误的下标，导致数组访问越界。<br>
  b) 搜索字符串时，依靠字符串结束符来判断字符串是否结束，但是字符串没有正常的使用结束符。<br>
  c) 使用strcpy, strcat, sprintf, strcmp,strcasecmp等字符串操作函数，将目标字符串读/写爆。应该使用strncpy, strlcpy, strncat, strlcat, snprintf, strncmp, strncasecmp等函数防止读写越界。</p>
<p>2，多线程程序使用了线程不安全的函数。<br>
应该使用下面这些可重入的函数，它们很容易被用错：<br>
asctime_r(3c) gethostbyname_r(3n) getservbyname_r(3n)ctermid_r(3s) gethostent_r(3n) getservbyport_r(3n) ctime_r(3c) getlogin_r(3c)getservent_r(3n) fgetgrent_r(3c) getnetbyaddr_r(3n) getspent_r(3c)fgetpwent_r(3c) getnetbyname_r(3n) getspnam_r(3c) fgetspent_r(3c)getnetent_r(3n) gmtime_r(3c) gamma_r(3m) getnetgrent_r(3n) lgamma_r(3m) getauclassent_r(3)getprotobyname_r(3n) localtime_r(3c) getauclassnam_r(3) etprotobynumber_r(3n)nis_sperror_r(3n) getauevent_r(3) getprotoent_r(3n) rand_r(3c) getauevnam_r(3)getpwent_r(3c) readdir_r(3c) getauevnum_r(3) getpwnam_r(3c) strtok_r(3c) getgrent_r(3c)getpwuid_r(3c) tmpnam_r(3s) getgrgid_r(3c) getrpcbyname_r(3n) ttyname_r(3c)getgrnam_r(3c) getrpcbynumber_r(3n) gethostbyaddr_r(3n) getrpcent_r(3n)</p>
<p>3，多线程读写的数据未加锁保护。<br>
对于会被多个线程同时访问的全局数据，应该注意加锁保护，否则很容易造成coredump</p>
<p>4，非法指针<br>
  a) 使用空指针<br>
  b) 随意使用指针转换。一个指向一段内存的指针，除非确定这段内存原先就分配为某种结构或类型，或者这种结构或类型的数组，否则不要将它转换为这种结构或类型的指针，而应该将这段内存拷贝到一个这种结构或类型中，再访问这个结构或类型。这是因为如果这段内存的开始地址不是按照这种结构或类型对齐的，那么访问它时就很容易因为bus error而core dump。</p>
<p>5，堆栈溢出<br>
不要使用大的局部变量（因为局部变量都分配在栈上），这样容易造成堆栈溢出，破坏系统的栈和堆结构，导致出现莫名其妙的错误。</p>
<p>参考博文：<br>
<a href="https://jvns.ca/blog/2018/04/28/debugging-a-segfault-on-linux/">How to get a core dump for a segfault on Linux</a><br>
<a href="https://blog.csdn.net/tenfyguo/article/details/8159176">详解coredump</a><br>
<a href="https://blog.csdn.net/u014403008/article/details/54174109">gdb调试coredump(使用篇)</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[网络状态查看命令]]></title>
        <id>https://lixin-scut.github.io//post/wang-luo-zhuang-tai-cha-kan-ming-ling</id>
        <link href="https://lixin-scut.github.io//post/wang-luo-zhuang-tai-cha-kan-ming-ling">
        </link>
        <updated>2020-03-06T09:26:26.000Z</updated>
        <content type="html"><![CDATA[<h3 id="netstat-常用命令详解">netstat 常用命令详解</h3>
<p>netstat 命令：用于显示各种网络相关信息，如网络连接，路由表，接口状态，无效连接，组播成员 等等。<br>
netstat命令是net-tools软件包中的一员<br>
<img src="https://lixin-scut.github.io//post-images/1583486844848.png" alt=""></p>
<h3 id="命令行选项">命令行选项：</h3>
<pre><code>-a:　　列出系统中所有网络连接，包括已经连接的网络服务、监听的网络服务和Socket套接字        
-t：　　列出TCP数据
-u：　　列出UDP数据
-l：　　列出正在监听的网络服务（不包含已经连接的网路服务）
-n：　　用端口显示服务，而不用服务名
-p：　　列出该服务的进程ID(PID)
</code></pre>
<h3 id="互联网联机字段">互联网联机字段:</h3>
<p> Proto :网络的封包协议，主要分为 TCP 与 UDP 封包，相关资料请参考服务器篇;<br>
 Recv-Q:非由用户程序链接到此 socket 的复制的总 bytes 数;<br>
 Send-Q:非由远程主机传送过来的 acknowledged 总 bytes 数;<br>
 Local Address :本地端的 IP:port 情况<br>
 Foreign Address:远程主机的 IP:port 情况<br>
 State :联机状态，主要有建立(ESTABLISED)及监听(LISTEN);</p>
<h3 id="本地socket-file-的字段">本地socket file 的字段:</h3>
<p> Proto :一般就是 unix ;<br>
 RefCnt:连接到此 socket 的进程数量;<br>
 Flags :联机的旗标;<br>
 Type :socket 存取的类型。主要有确认联机的 STREAM 与不需确认的 DGRAM 两种;<br>
 State :若为 CONNECTED 表示多个进程之间已经联机建立。<br>
 Path :连接到此 socket 的相关程序的路径!或者是相关数据输出的路径。</p>
<p>例子：netstat -tlunp<br>
除了可以列出监听网络的接口与状态之外，最后一个字段还能够显示此服务的PID 号码以及进程的指令名称<br>
<img src="https://lixin-scut.github.io//post-images/1583487282316.png" alt=""><br>
使用netstat -an<br>
<img src="https://lixin-scut.github.io//post-images/1583487403214.png" alt=""></p>
<h3 id="完整选项">完整选项</h3>
<pre><code>usage: netstat [-vWeenNcCF] [&lt;Af&gt;] -r         netstat {-V|--version|-h|--help}
       netstat [-vWnNcaeol] [&lt;Socket&gt; ...]
       netstat { [-vWeenNac] -i | [-cnNe] -M | -s [-6tuw] }

      -r, --route              display routing table
        -i, --interfaces         display interface table
        -g, --groups             display multicast group memberships
        -s, --statistics         display networking statistics (like SNMP)
        -M, --masquerade         display masqueraded connections

        -v, --verbose            be verbose
        -W, --wide               don't truncate IP addresses
        -n, --numeric            don't resolve names
        --numeric-hosts          don't resolve host names
        --numeric-ports          don't resolve port names
        --numeric-users          don't resolve user names
        -N, --symbolic           resolve hardware names
        -e, --extend             display other/more information
        -p, --programs           display PID/Program name for sockets
        -o, --timers             display timers
        -c, --continuous         continuous listing

        -l, --listening          display listening server sockets
        -a, --all                display all sockets (default: connected)
        -F, --fib                display Forwarding Information Base (default)
        -C, --cache              display routing cache instead of FIB
        -Z, --context            display SELinux security context for sockets

  &lt;Socket&gt;={-t|--tcp} {-u|--udp} {-U|--udplite} {-S|--sctp} {-w|--raw}
           {-x|--unix} --ax25 --ipx --netrom
  &lt;AF&gt;=Use '-6|-4' or '-A &lt;af&gt;' or '--&lt;af&gt;'; default: inet
</code></pre>
<h3 id="例子">例子</h3>
<p>(1)已知进程名，使用命令查看当前进程打开的文件句柄?<br>
执行命令“ulimit -a”,其中oepn files 对应的即为本机文件句柄数<br>
lsof -n |awk '{print $2}'|sort|uniq -c |sort -nr|more</p>
<p>[root@study ~]# lsof [-aUu] [+d]<br>
选项与参数:<br>
-a :多项数据需要『同时成立』才显示出结果时!<br>
-U :仅列出 Unix like 系统的 socket 文件类型;<br>
-u :后面接 username，列出该使用者相关进程所开启的文件; +d :后面接目录，亦即找出某个目录底下已经被开启的文件!</p>
<p>(2)已知进程名，使用命令查看当前进程的网络连接状态?<br>
netstat -tlunp<br>
(3)已知进程名，查看 eth0 网卡与 ip10.10.10.10:10653 之间的 TCP 数据包?<br>
tcpdump -i eth0 -nn 'tcp and port 10653 and host 10.1.1.180'</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 72:编辑距离[未做出]]]></title>
        <id>https://lixin-scut.github.io//post/dong-tai-gui-hua-72bian-ji-ju-chi-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/dong-tai-gui-hua-72bian-ji-ju-chi-wei-zuo-chu">
        </link>
        <updated>2020-03-06T02:31:23.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。<br>
你可以对一个单词进行如下三种操作：<br>
插入一个字符<br>
删除一个字符<br>
替换一个字符<br>
示例 1:<br>
输入: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;<br>
输出: 3<br>
解释:<br>
horse -&gt; rorse (将 'h' 替换为 'r')<br>
rorse -&gt; rose (删除 'r')<br>
rose -&gt; ros (删除 'e')<br>
示例 2:<br>
输入: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;<br>
输出: 5<br>
解释:<br>
intention -&gt; inention (删除 't')<br>
inention -&gt; enention (将 'i' 替换为 'e')<br>
enention -&gt; exention (将 'n' 替换为 'x')<br>
exention -&gt; exection (将 'n' 替换为 'c')<br>
exection -&gt; execution (插入 'u')<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/edit-distance<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<pre><code>class Solution {
public:
    int minDistance(string word1, string word2) {
        int length1 = word1.size();
        int length2 = word2.size();
        vector&lt;vector&lt;int&gt;&gt; countDistance(length1 + 1, vector&lt;int&gt;(length2 + 1));
				// 本来想着合并的，但是后来发现合并起来相对还麻烦一点
        for(int row = 0; row &lt; length1+1; ++row)
        { 
            countDistance[row][0] = row;
        }
        for(int col = 0; col &lt; length2+1; ++col)
        { 
            countDistance[0][col] = col;
        }
				// 一定要记得判断条件中的length + 1
        for(int row = 1; row &lt; length1 + 1; ++row)
        {
            for(int col = 1; col &lt; length2 + 1; ++col)
            {
                
                if(word1[row-1] == word2[col-1])
                {
                    countDistance[row][col] = countDistance[row-1][col-1];
                }
                else
                {
                    countDistance[row][col] = 1 + minDistance(countDistance[row-1][col], 
                                                              countDistance[row][col-1], 
                                                              countDistance[row-1][col-1]);
                }
            }
        }
        return countDistance.back().back();
    }
    
    int minDistance(const int&amp; i1, const int&amp; i2, const int&amp; i3) const
    {
        int res;
        res = i1 &lt; i2 ? i1 : i2;
        res = res &lt; i3 ? res : i3; // 这里注意必须是和res比较
        return res;    
    }
};
</code></pre>
<p>需要注意的点：<br>
1.弄清楚行和列的关系，一个是嵌套的vector中，第一个vector是列，第二个vector是行。然后对于要转化的字符串来说，word1应该是列，word2应该是行（当然这个并非定则）<br>
2.当前的字符相等时，应该直接取<code>countDistance[row][col] = countDistance[row-1][col-1];</code>而不是minDistance+1，而且必须是选择跳过，不能再选择其他方案<br>
3.细节问题，详看注释<br>
4.可以简化空间为一维</p>
<p>网友题解：<br>
<a href="https://leetcode-cn.com/problems/edit-distance/solution/bian-ji-ju-chi-mian-shi-ti-xiang-jie-by-labuladong/">编辑距离面试题详解</a><br>
因为题解很翔实，我就不弄巧成拙搬过来了，还是从头到尾看一遍比较好<br>
这里只搬运动态规划的</p>
<p>DP table 的解法：<br>
首先明确 dp 数组的含义，dp 数组是一个二维数组，长这样：<br>
<img src="https://lixin-scut.github.io//post-images/1583464478285.png" alt=""><br>
有了之前递归解法的铺垫，应该很容易理解。dp[..][0] 和 dp[0][..] 对应 base case，dp[i][j] 的含义和之前的 dp 函数类似：</p>
<pre><code>def dp(i, j) -&gt; int
# 返回 s1[0..i] 和 s2[0..j] 的最小编辑距离

dp[i-1][j-1]
# 存储 s1[0..i] 和 s2[0..j] 的最小编辑距离
</code></pre>
<p>dp 函数的 base case 是 i,j 等于 -1，而数组索引至少是 0，所以 dp 数组会偏移一位。<br>
既然 dp 数组和递归 dp 函数含义一样，也就可以直接套用之前的思路写代码，唯一不同的是，DP table 是自底向上求解，递归解法是自顶向下求解：</p>
<pre><code>int minDistance(String s1, String s2) {
    int m = s1.length(), n = s2.length();
    int[][] dp = new int[m + 1][n + 1];
    // base case 
    for (int i = 1; i &lt;= m; i++)
        dp[i][0] = i;
    for (int j = 1; j &lt;= n; j++)
        dp[0][j] = j;
    // 自底向上求解
    for (int i = 1; i &lt;= m; i++)
        for (int j = 1; j &lt;= n; j++)
            if (s1.charAt(i-1) == s2.charAt(j-1))
                dp[i][j] = dp[i - 1][j - 1];
            else               
                dp[i][j] = min(
                    dp[i - 1][j] + 1,
                    dp[i][j - 1] + 1,
                    dp[i-1][j-1] + 1
                );
    // 储存着整个 s1 和 s2 的最小编辑距离
    return dp[m][n];
}

int min(int a, int b, int c) {
    return Math.min(a, Math.min(b, c));
}
</code></pre>
<p>一般来说，处理两个字符串的动态规划问题，都是按本文的思路处理，建立 DP table。为什么呢，因为易于找出状态转移的关系，比如编辑距离的 DP table：<br>
<img src="https://lixin-scut.github.io//post-images/1583464576792.png" alt=""><br>
还有一个细节，既然每个 dp[i][j] 只和它附近的三个状态有关，空间复杂度是可以压缩成 O(min(M,N)) 的（M，N 是两个字符串的长度）。不难，但是可解释性大大降低，读者可以自己尝试优化一下。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math 题49:丑数[未做出]]]></title>
        <id>https://lixin-scut.github.io//post/math-ti-49chou-shu-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/math-ti-49chou-shu-wei-zuo-chu">
        </link>
        <updated>2020-03-06T00:17:23.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
</blockquote>
<p>  一开始我想着循环*2 *3 *5，但是突然发现不对啊，比如4，4应该优先*2而不是*3，<br>
也就是说得到的下一个值应该先*2，然后再考虑上一个值*3之类的<br>
当然马上发现也不是绝对，比如1*2后应该继续1*3而不是2*2<br>
似乎可以用一个大顶堆hhh</p>
<p>  然后就是书里的办法吧，类似于动态规划，首先从乘2 乘3 乘5的位置出发，比较三者的最小值，只有最小那个可以前进一步<br>
暴力循环法的话就是理解取余再除以的思想就行，然后超时了，但是ide中通过了数据比</p>
<pre><code>class Solution {
public:
    /*
    //暴力循环法，超时
    int GetUglyNumber_Solution(int index){
        if(index&lt;1)
            return 0;
        int count,res;
        count=1;
        res=1;
        while(count&lt;index){
            ++res;
            int temp=res;
            while(temp%2==0)
                temp/=2;
            while(temp%3==0)
                temp/=3;
            while(temp%5==0)
                temp/=5;
            if(temp==1)
                ++count;
        }
        return res;
    }
    */
    
    
    //动态规划
    int GetUglyNumber_Solution(int index) {
        if(index&lt;1)
            return 0;
        vector&lt;int&gt; uglynum(index,1);
        int multiby2,multiby3,multiby5,count;
        multiby2=0;
        multiby3=0;
        multiby5=0;
        count=1;
        while(count&lt;index){
            int cur_min=min(uglynum[multiby2]*2,uglynum[multiby3]*3,uglynum[multiby5]*5);
            uglynum[count]=cur_min;
            while(uglynum[multiby2]*2&lt;=cur_min)
                ++multiby2;
            while(uglynum[multiby3]*3&lt;=cur_min)
                ++multiby3;
            while(uglynum[multiby5]*5&lt;=cur_min)
                ++multiby5;
            ++count;
        }
        return uglynum[index-1];
    }
    
    int min(int multiby2,int multiby3,int multiby5){
        int temp=std::min(multiby2,multiby3);
        return std::min(temp,multiby5);
    } 
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>  逐个判断每个整数是不是丑数的解法,直观但不够高效<br>
  所谓一个数m是另一个数n的因子，是指n能被m整除 也就是n%m = 0。根据丑数的定义，丑数只能被2、3和5整除。也就是说，如果一个数能被2整除，就连续除以2；如果能被3整除，就连续除以3；如果能被5 整除，就除以连续5。如果最后得到的是1,那么这个数就是丑数；否则不是。</p>
</blockquote>
<pre><code>bool IsUgly(int number)
{
    while(number % 2 == 0)
        number /= 2;
    while(number % 3 == 0)
        number /= 3;
    while(number % 5 == 0)
        number /= 5;

    return (number == 1) ? true : false;
}

int GetUglyNumber_Solution1(int index)
{
    if(index &lt;= 0)
        return 0;

    int number = 0;
    int uglyFound = 0;
    while(uglyFound &lt; index)
    {
        ++number;

        if(IsUgly(number))
            ++uglyFound;
    }

    return number;
}
</code></pre>
<blockquote>
<p>创建数组保存已经找到的丑数，用空间换时间的解法<br>
  前面的算法之所以效率低，很大程度上是因为不管一个数是不是丑数， 我们都要对它进行计算。接下来我们试着找到一种只计算丑数的方法，而不在非丑数的整数上花费时间。根据丑数的定义，丑数应该是另一个丑数乘以2、3或者5的结果(1除外)。因此，我们可以创建一个数组，里面的数字是排好序的丑数，每个丑数都是前面的丑数乘以2、3或者5得到的。<br>
  这种思路的关键在于怎样确保数组里面的丑数是排好序的。假设数组中已经有若干个排好序的丑数，并且把已有最大的丑数记作M,接下来分析如何生成下一个丑数。该丑数肯定是前面某一个丑数乘以2、3或者5的 结果，所以我们首先考虑把已有的每个丑数乘以2。在乘以2的时候，能得到若干个小于或等于M的结果。由于是按照顺序生成的，小于或者等于M 肯定己经在数组中了，我们不需再次考虑；还会得到若干个大于M的结果， 但我们只需要第一个大于M的结果，因为我们希望丑数是按从小到大的顺序生成的，其他更大的结果以后再说。我们把得到的第一个乘以2后大 M的结果记为M2，同样，我们把已有的每个丑数乘以3和5,能得到第一 个大于M的结果M3和M5。那么下一个丑数应该是M2、M3和M5这3个数的最小者。<br>
  在前面分析的时候提到把已有的每个丑数分别乘以2、3和5。事实上这不是必需的，因为已有的丑数是按顺序存放在数组中的。对于乘以2而言，肯定存在某一个丑数T2，排在它之前的每个丑数乘以2得到的结果都会小于已有最大的丑数，在它之后的每个丑数乘以2得到的结果都会太大。 我们只需记下这个丑数的位置，同时每次生成新的丑数的时候去更新这个T2即可。对于乘以3和5而言，也存在同样的T3和T5。</p>
</blockquote>
<pre><code>int GetUglyNumber_Solution2(int index)
{
    if(index &lt;= 0)
        return 0;

    int *pUglyNumbers = new int[index];
    pUglyNumbers[0] = 1;
    int nextUglyIndex = 1;

    int *pMultiply2 = pUglyNumbers;
    int *pMultiply3 = pUglyNumbers;
    int *pMultiply5 = pUglyNumbers;

    while(nextUglyIndex &lt; index)
    {
        int min = Min(*pMultiply2 * 2, *pMultiply3 * 3, *pMultiply5 * 5);
        pUglyNumbers[nextUglyIndex] = min;

        while(*pMultiply2 * 2 &lt;= pUglyNumbers[nextUglyIndex])
            ++pMultiply2;
        while(*pMultiply3 * 3 &lt;= pUglyNumbers[nextUglyIndex])
            ++pMultiply3;
        while(*pMultiply5 * 5 &lt;= pUglyNumbers[nextUglyIndex])
            ++pMultiply5;

        ++nextUglyIndex;
    }

    int ugly = pUglyNumbers[nextUglyIndex - 1];
    delete[] pUglyNumbers;
    return ugly;
}

int Min(int number1, int number2, int number3)
{
    int min = (number1 &lt; number2) ? number1 : number2;
    min = (min &lt; number3) ? min : number3;

    return min;
}
</code></pre>
<blockquote>
<p>和第一种思路相比，第二种思路不需要在非丑数的整数上进行任何计算，因此时间效率有明显提升。但也需要指出，第二种算法由于需要保存已经生成的丑数，则因此需要一个数组，从而增加了空间消耗。如果是求第1500个丑数，则将创建一个能容纳1500个丑数的数组，这个数组占据 6KB的内容空间。而第一种思路没有这样的内存开销。总的来说，第二种思路相当于用较小的空间消耗换取了时间效率的提升。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 题48:最长不含重复字符的子字符串]]></title>
        <id>https://lixin-scut.github.io//post/zi-fu-chuan-ti-48zui-chang-bu-han-chong-fu-zi-fu-de-zi-zi-fu-chuan</id>
        <link href="https://lixin-scut.github.io//post/zi-fu-chuan-ti-48zui-chang-bu-han-chong-fu-zi-fu-de-zi-zi-fu-chuan">
        </link>
        <updated>2020-03-05T23:55:49.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子<br>
字符串的长度。假设字符串中只包含从'a'到'z'的字符。在字符串&quot;arabcacfr&quot;中，最长的不含重复字符的子字符串是&quot;acfr&quot;,长度为4。</p>
</blockquote>
<blockquote>
<p>  我们不难找出字符串的所有子字符串，然后就可以判断每个子字符串中是否包含重复的字符。这种蛮力法唯一的缺点就是效率。一个长度为n的字符串有O(n<sup>2)个子字符串，我们需要O(n)的时间判断一个子字符串中是否包含重复的字符，因此该解法的总的时间效率是O(n</sup>3)</p>
</blockquote>
<pre><code>int longestSubstringWithoutDuplication_1(const std::string&amp; str)
{
    int longest = 0;
    int* position = new int[26];
    for(int start = 0; start &lt; str.length(); ++start)
    {
        for(int end = start; end &lt; str.length(); ++end)
        {
            int count = end - start + 1;
            const std::string&amp; substring = str.substr(start, count);
            if(!hasDuplication(substring, position))
            {
                if(count &gt; longest)
                    longest = count;
            }
            else
                break;

        }
    }
		delete[] position;
    return longest;
}

bool hasDuplication(const std::string&amp; str, int position[])
{
    for(int i = 0; i &lt; 26; ++i)
        position[i] = -1;

    for(int i = 0; i &lt; str.length(); ++i)
    {
        int indexInPosition = str[i] - 'a';
        if(position[indexInPosition] &gt;= 0)
            return true;

        position[indexInPosition] = indexInPosition;
    }

    return false;
}
</code></pre>
<blockquote>
<p>  接下来我们用动态规划算法来提高效率。首先定义函数f(i)表示以第i个字符为结尾的不包含重复字符的字符串的最长长度。我们从左到右逐一扫描字符串中的每个字符。当我们计算以第i个字符为结尾的不包含重复字符的子字符串的最长长度f(i)时，我们已经知道f(i-1)。<br>
  如果第i个字符之前没有出现过，那么f(i)=f(i-1)+1.例如，在字符串&quot;arabcacfr&quot;中，显然f(0)等于1。在计算f(1)时，下标为1的字符‘r’之前没有出现过，因此f(1)等于2,即f(1)=f(0)+1。到目前为止，最长的不含重复字符的子字符串是&quot;ar&quot;.<br>
  如果第i个字符之前已经出现过，那情况就要复杂一点了。我们先计算第i个字符和它上次出现在字符串中的位置的距离，并记为d，接着分两种情形分析。第一种情形是d小于或者等于f(i-1),此时第i个字符上次出现在f(i-1)对应的最长子字符串之中，因此f(i)=d。同时这也意味着在第i个字符出现两次所夹的子字符串中再也没有其他重复的字符了。在前面的例子中，我们继续计算f(2),即以下标为2的字符a为结尾的不含重复字符的子字符串的最长长度。我们注意到字符a在之前出现过，该字符上一次出现在下标为0的位置，它们之间的距离d为2,也就是字符a出现在f(1)对应的最长不含重复字符的子字符串&quot;ar&quot;中，此时f(2)=d,即f(2)=2,对应的最长不含重复字符的子字符串是&quot;ra&quot;。<br>
  第二种情形是d大于f(i-1),此时第i个字符上次出现在f(i-1)对应的最长子字符串之前，因此仍然有f(i)=f(i-1)+1。我们接下来分析以字符串 &quot;arabcacfr&quot;最后一个字符r为结尾的最长不含重复字符的子字符串的长度， 即求f(8)。以它前一个字符f为结尾的最长不含重复字符的子字符串是acf, 因此f(7)=3。我们注意到最后一个字符r之前在字符&quot;arabcacfr&quot;中出现过, 上一次出现在下标为1的位置，因此两次出现的距离d等于7,大于f(7).这说明上一个字符r不在f(7)对应的最长不含重复字符的子字符串acf中， 此时把字符r拼接到acf的后面也不会出现重复字符。此,f(8)=f(7)+1,即 f(8)=4,对应的最长不含重复字符的子字符串是acfr<br>
  我们创建了一个长度为26的数组position用来存储每个字符上次出现在字符串中位置的下标。该数组所有元素的值都初始化为 -1.负数表示该元素对应的字符在字符串中还没有出现过。我们在扫描字符串时遇到某个字符，就把该字符在字符串中的位置存储到数组对应的元素中。</p>
</blockquote>
<pre><code>// 方法一：动态规划
int longestSubstringWithoutDuplication_2(const std::string&amp; str)
{
    int curLength = 0;
    int maxLength = 0;

    int* position = new int[26];
    for(int i = 0; i &lt; 26; ++i)
        position[i] = -1;

    for(int i = 0; i &lt; str.length(); ++i)
    {
        int prevIndex = position[str[i] - 'a'];
        if(prevIndex &lt; 0 || i - prevIndex &gt; curLength)
            ++curLength;
        else
        {
            if(curLength &gt; maxLength)
                maxLength = curLength;

            curLength = i - prevIndex;
        }
        position[str[i] - 'a'] = i;
    }

    if(curLength &gt; maxLength)
        maxLength = curLength;

    delete[] position;
    return maxLength;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 题47:礼物的最大价值]]></title>
        <id>https://lixin-scut.github.io//post/dong-tai-gui-hua-ti-47li-wu-de-zui-da-jie-zhi</id>
        <link href="https://lixin-scut.github.io//post/dong-tai-gui-hua-ti-47li-wu-de-zui-da-jie-zhi">
        </link>
        <updated>2020-03-05T23:42:51.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>在一个m×n的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向左或者向下移动一格直到到达棋盘的右下角。给定一个棋盘及其上面的礼物，请计算你最多能拿到多少价值的礼物？</p>
</blockquote>
<p>书本题解：</p>
<blockquote>
<p>  根据题目要求，我们有两种可能的途径到达坐标为（i,j）的格 子：通过格子(i-1,j)或者(i,j-1)。 所以f(i,j)= max(f(i-1,j),f((i,j-1)) + gift(i,j)= gift(i,j)表示坐标为(i,j)的格子里礼物的价值。<br>
  尽管我们用递归来分析问题，但由于有大量重复的计算，导致递归的代码并不是最优的。相对而言，基于循环的代码效率要高很多。为了缓存 中间计算结果，我们需要一个辅助的二维数组。数组中坐标为(i,j)的元素表 示到达坐标为(i,j)的格子时能拿到的礼物价值总和的最大值。</p>
</blockquote>
<pre><code>int getMaxValue_solution1(const int* values, int rows, int cols)
{
    if(values == nullptr || rows &lt;= 0 || cols &lt;= 0)
        return 0;

    int** maxValues = new int*[rows];
    for(int i = 0; i &lt; rows; ++i)
        maxValues[i] = new int[cols];

    for(int i = 0; i &lt; rows; ++i)
    {
        for(int j = 0; j &lt; cols; ++j)
        {
            int left = 0;
            int up = 0;

            if(i &gt; 0)
                up = maxValues[i - 1][j];

            if(j &gt; 0)
                left = maxValues[i][j - 1];

            maxValues[i][j] = std::max(left, up) + values[i * cols + j];
        }
    }

    int maxValue = maxValues[rows - 1][cols - 1];

    for(int i = 0; i &lt; rows; ++i)
        delete[] maxValues[i];
    delete[] maxValues;

    return maxValue;
}
</code></pre>
<blockquote>
<p>  接下来我们考虑进一步的优化。前面我们提到，到达坐标为（i,j）的格子 时能够拿到的礼物的最大价值只依赖坐标为（i-1,j）和（i,j-1）的两个格子，因此第i-2行及更上面的所有格子礼物的最大价值实际上没有必要保存下来。 我们可以用一个一维数组来替代前面代码中的二维矩阵maxvalues。</p>
</blockquote>
<pre><code>int getMaxValue_solution2(const int* values, int rows, int cols)
{
    if(values == nullptr || rows &lt;= 0 || cols &lt;= 0)
        return 0;

    int* maxValues = new int[cols];
    for(int i = 0; i &lt; rows; ++i)
    {
        for(int j = 0; j &lt; cols; ++j)
        {
            int left = 0;
            int up = 0;

            if(i &gt; 0)
                up = maxValues[j];

            if(j &gt; 0)
                left = maxValues[j - 1];

            maxValues[j] = std::max(left, up) + values[i * cols + j];
        }
    }

    int maxValue = maxValues[cols - 1];

    delete[] maxValues;

    return maxValue;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[服务端异常情况]]></title>
        <id>https://lixin-scut.github.io//post/fu-wu-duan-yi-chang-qing-kuang</id>
        <link href="https://lixin-scut.github.io//post/fu-wu-duan-yi-chang-qing-kuang">
        </link>
        <updated>2020-03-05T12:39:28.000Z</updated>
        <content type="html"><![CDATA[<p>正常终止<br>
&lt;Ctrl+D&gt;是我们的终端EOF字符，键入终端EOF字符（Control-D）以终止客户<br>
当前连接的客户端发送fin和ack后会进入了TIME_WAIT状态</p>
<p>我们可以总结出正常终止客户和服务器的步骤。<br>
⑴当我们键入EOF字符时，fgets返回一个空指针，于是str_cli函数返回。<br>
(2)	当str_cli返回到客户的main函数时，main通过调用exit终止。<br>
(3)	进程终止处理的部分工作是<strong>关闭所有打开的描述符</strong>，因此客户打开的套接字由内核关闭。这导致客户TCP发送一个FIN给服务器，服务器TCP则以ACK响应，这就是TCP连接终止序 列的前半部分。至此，<strong>限务器套接字处于CLOSE_WAIT状态，客户套接字则处于FIN_WAIT_2 状态</strong><br>
(4)	当服务器TCP接收FIN时，服务器子进程阻塞于readline调用，于是readline 返回0。这导致str_echo函数返回服务器子进程的main函数。<br>
(5)	服务器子进程通过调用exit来终止。<br>
(6)	服务器子进程中打开的所有描述符随之关闭。由<strong>子进程</strong>来关闭已连接套接字会引发TCP 连接终止序列的最后两个分节：一个从服务器到客户的FIN和一个从客户到服务器的ACK 。至此，连接完全终止，客户套接字进入TIME_WAIT状态。<br>
(7)	进程终止处理的另一部分内容是：在服务器子进程终止时，给<strong>父进程</strong>发送一个SIGCHLD 信号。，但是我们没有在代码中捕获该信号，而该信号的默认行为是被回 忽略。既然父进程未加处理，子进程于是<strong>进入僵死状态</strong>。可以使用ps命令验证这--点。如果stat列为Z，且command列后面带有＜defunct＞字样，就属于僵死进程<br>
进程的状态是Z (表示僵死)。我们必须清理僵死进程，这就涉及Unix信号的处理。</p>
<h1 id="处理sigchld信号">处理SIGCHLD信号</h1>
<p>设置僵死（zombie）状态的目的是维护子进程的信息，以便父进程在以后某个时候获取。 这些信息包括子进程的进程ID、终止状态以及资源利用信息（CPU时间、内存使用量等等）。<br>
如果一个进程终止，而该进程有子进程处于僵死状态，那么它的所有僵死子进程的父进程ID将被重置为1（init进程）。继承这些子进程的init让进程将清理它们（也就是说init进程将wait它们，从而去除它们的僵死状态）。<br>
僵死占用内核中的空间，最终可能导致我们耗尽进程资源<br>
无论何时我们fork子进程都得wait它们，以防它们变成偶死进程。为此我们建立一个俘获 SIGCHLD信号的信号处理函数，在函数体中我们调用wait.</p>
<pre><code>Signal（SIGCHLD, sig_chld）;

1	#include	&quot;unp.h&quot;	.
2	void
3	sig_chld（int signo）
4	{
5	pid_t	pid;
6	int	stat;
7	pid = wait（&amp;stat）;
8	printf（&quot;child %d terminated\n&quot;, pid）；
9	return；
10	}
</code></pre>
<p>具体的各个步骤如下：<br>
（1）	我们键入EOF字符来终止客户。客户TCP发送一个FIN给服务器，服务器响应以一个 ACK。<br>
（2）	收到客户的FIN导致服务器TCP递送一个EOF给<strong>子进程阻塞中的readline</strong>,从而<strong>子进程终止</strong>。<br>
（3）	当SIGCHLD信号递交时，<strong>父进程阻塞于accept调用</strong>。sig_chld函数（信号处理函数） 执行，其wait调用取到子进程的PID和终止状态，随后是printf调用，最后返回。<br>
（4）	既然该信号是在父进程阻塞于慢系统调用（accept）时由父进程捕获的，内核就会使<strong>accept返回一个EINTR错误（被中断的系统调用）。而父进程不处理该错误,于是中止。</strong></p>
<p>本书使用的编程约定之一，我们总是在信号处理函数中显式给出return语句，这么一来，当某个系统调用被我们编写的某个信号处理函数中断时，我们就可以得知该系统调用具体是被哪个信号处理函数的哪个return语句中断的。</p>
<ul>
<li>处理被中断的系统调用<br>
慢系统调用（slow system call）：适用于那些可能 永远阻塞的系统调用。永远阻塞的系统调用是指调用有可能永远无法返回，多数网络支持函数都属于这一类，例如accept。<br>
一个值得注意的例外是磁盘I/O,它们一般都会返回到调用者（假设没有灾难性的硬件故障）。<br>
适用于慢系统调用的基本规则是：当阻塞于某个慢系统调用的一个进程捕获某个信号且相应信号处理函数返回时，该系统调用可能返回一个<strong>EINTR错误</strong>。<br>
设置SA_RESTART标志可以使得内核自动重启调用<br>
了处理被中断的accept,我们把对accept的调用从for循环开始改起</li>
</ul>
<pre><code>for ( ; ; ) (
	clilen = sizeof(cliaddr);
	if ( (connfd =accept(listenfd, (SA *) &amp;cliaddr, &amp;clilen)) &lt; 0) { 
		if (errno == EINTR) 
				continue;	/* back to for() */
		else
				err_sys(&quot;accept error&quot;);
}
</code></pre>
<p>注意！<strong>有一个函数我们不能重启：connect</strong>。如果该函数返回EINTR,我们就不能再次调用它，否则将立即返回一个错误。当connect被一个捕获的 信号中断而且不自动重启时，我们必须调用select来等待连接完成</p>
<h1 id="wait-和-waitpid-函数">wait 和 waitpid 函数</h1>
<p>调用了函数wait:来处理己终止的子进程。</p>
<pre><code>#include &lt;sys/wait.h&gt;
		pid_t wait (int *statloc)；
		pid_t waitpid(pid_t pid, int *statloc, int options);
均返回：若成功则为进程ID,若出错则为。或-1
</code></pre>
<p>函数wait和waitpid均返回两个值：已终止子进程的进程ID号，以及通过指针返回 的子进程终止状态(一个整数)。<br>
我们可以调用三个宏来检查终止状态，并辨别子进程是正常终止、由某个信号杀死还是仅仅由作业控制停止而已。<br>
如果调用wait的进程没有已终止的子进程，不过有一个或多个子进程仍在执行，那么wait 将阻塞到现有子进程第一个终止为止。<br>
waitpid函数就等待哪个进程以及是否阻塞给了我们更多的控制。首先，pid参数允许我们<strong>指定想等待的进程ID</strong>,值-1表示等待第一个终止的子进程。<br>
options参数允许我们指定附加选项。最常用的选项是WNOHANG,它告知内核在<strong>没有已终止子进程时不要阻塞</strong></p>
<ul>
<li>函数wait和waitpid的区别<br>
使用wait的情况下：<br>
假设有5个客户连接到服务器，当客户终止时，所有打开的描述符由内核自动关闭(我们不调用close,仅调用exit),且所有5个<strong>连接基本在同一时刻终止</strong>。这就引发了5个FIN,每个连接一个，它们反过来使服务器 的5个子进程基本在同一时刻终止。这导致差不多在同一时刻有<strong>5个SIGCHLD信号递交给父进程</strong><br>
这是按照预期所有5个子进程都终止了， 如果运行ps,我们将发现其他4个子进程仍然作为<strong>僵死进程</strong>存在着。<br>
原因：同一Unix信号一般是不重复排队的，建立一个信号处理函数并在其中调用wait并不足以防止出现僵死进程。本问题在于：所有5个信号都在信号处理函数执行之前产生，而<strong>信号处理函数只执行一次</strong>。<br>
更严重的是，本问题是不确定的，信号处理函数的执行次数依赖于FIN到达服务器主机的时机，</li>
</ul>
<p>正确的解决办法是调用waitpid而不是wait：<br>
这个版本管用的原因在于：我们在一个循环内调用waitpid,以获取所有已终止于进程的状态。<br>
我们必须指定WNOHANG选项，它告知waitpid在有尚未终止的子进程在运行时<strong>不要阻塞</strong>。<strong>不能在循环内调用wait</strong>,因为没有办法防止wait在正运行的子进程尚有未终止时阻塞。</p>
<p>关于<strong>wait和SIGCHLD信号</strong>注意事项：<br>
其实不一定要在SIGCHLD里调用wait，也可以直接wait<br>
注意！！！wait和信号之间没有关联，我们是捕获到sigchild信号就进行wait处理，而不是说wait本身等待信号进行调用，所以就算不排队，接收到一个信号后就能进行waitpid处理当前所有的僵死进程，而wait只能处理已个，并且不能通过循环wait解决因为会阻塞。<br>
<strong>所以！！！wait和信号无关！哪怕没有信号我也能调用wait和waitpid循环来<br>
清除僵死进程</strong></p>
<pre><code>//tcpserv04.c
//Code by Lixin on 2020/01/14

#include &quot;unp.h&quot;

int 
main(int argc,char **argv){
	int listenfd,connfd;
	pid_t childpid;
	socklen_t clilen;
	struct sockaddr_in cliaddr,servaddr;
	void sig_chld(int);
	listenfd=socket(AF_INET,SOCK_STREAM,0);
	bzero(&amp;servaddr,sizeof(servaddr));
	servaddr.sin_family=AF_INET;
	servaddr.sin_port=htons(SERV_PORT);
	servaddr.sin_addr.s_addr=htonl(INADDR_ANY);

	bind(listenfd,(SA *)&amp;servaddr,sizeof(servaddr));
	listen(listenfd,LISTENQ);
	signal(SIGCHLD,sig_chld);
	for(;;){
		clilen=sizeof(cliaddr);
		if((connfd=accept(listenfd,(SA *)&amp;cliaddr,&amp;clilen))&lt;0){
			if(errno==EINTR)
				continue;
			else
				err_sys(&quot;accept error&quot;);
		}
		if((childpid=fork())==0){
			close(listenfd);
			str_echo(connfd);
			exit(0);
		}
		close(connfd);
	}
}
</code></pre>
<p>我们的服务器程序的最终版本。它正确处理accept返回的EINTR,并建立一个给所有己终止子进程调用waitpid的信号处理函数<br>
本节的目的是示范我们在网络编程时可能会遇到的三种情况：<br>
(1)	当fork子进程时，必须捕获SIGCHLD信号；<br>
(2)	当捕获信号时，必须处理被中断的系统调用；<br>
(3)	S1GCHLD的信号处理函数必须正确编写，应使用waitpid函数以免留下僵死进程。</p>
<h1 id="accept返回前连接中止">accept返回前连接中止</h1>
<p>accept返回一个非致命的错误，在这种情况下，只需要再次调用accept，典型的是较忙的Web服务器。<br>
三路握手完成从而连接建立之后，客户TCP却发送了一个RST （复位）。在服务器端看来，就在该连接已由TCP排队，等着服务器进程调用accept的时候RST到达。<br>
如何处理这种中止的连接依赖于不同的实现，POSIX 指出返回的 errno 值必须是ECONNABORTED<br>
POSIX作出修改的理由在于：流子系统(streams subsystem)中发生某些致命的协议相关事件时，也会返回EPROTO。要是对于由客户引起的一个 已建立连接的非致命中止也返回同样的错误，那么服务器就不知道该再次调用accept还是不该 了。换成ECONNABORTED错误，服务器就可以忽略它，再次调用accept就行。</p>
<h1 id="服务器进程终止">服务器进程终止</h1>
<p>模拟服务器已连接的子进程终止：<br>
1.找到服务器子进程的进程ID,并执行kill命令杀死它。作为进程终止处理的部分工作， 子进程中所有打开着的描述符都被关闭。这就导致<strong>向客户发送一个FIN</strong>,<br>
2.客户段传输层TCP接收FIN此时响应以一个ACK，同时按照预设客户端应用层应当读入套接字的FIN准备关闭程序并发送客户端的FIN给服务端，但是！！此时进程<strong>拥塞在fgets</strong>上，等待从<strong>终端（也就是键盘！）</strong> 接收一行文本，导致<strong>没法去读取套接字的FIN！</strong><br>
<strong>（这里注意区分有两个流，一个是键盘，一个是网络套接字）</strong><br>
<strong>（但是此时客户端传输层TCP已经收到FIN了并向服务端发送ACK了，同时把状态转化为CLOSE_WAIT，可以用netstat查询，这一切都不需要应用层插手）</strong><br>
3.假设此时客户端接收到键盘的输入文本并发送给服务端，当服务器TCP接收到来自客户的数据时，既然先前打开那个套接字的进程已经终止，于是 响应以一个RST。<br>
4.然而客户进程看不到这个RST,因为它在调用writen后立即调用readline,并且由于接收的FIN,所调用的readline立即返回0 （表示EOF）。我们的客户此时<strong>并未预期收到 EOF</strong>，于是以出错信息&quot;server terminated prematurely”（服务器过早终止）退出。当客户终止时（通过调用err_quit）,它所有打开着的描述符都被关闭。<br>
<strong>（注意这里为什么说未预期收到EOF呢？因为ECHO服务器是假设只能由客户端关闭的，所以客户端一开始没加上接收FIN的处理，比如微信，总不能让腾讯来先发送FIN关闭我手机上的微信吧？）</strong></p>
<p>根本原因：当FIN到达套接字时，客户正阻塞在fgets调用上。客户实际上<strong>在应对两个描述符</strong>--套接字（网络）和用户输入（键盘），它不能单纯阻塞在这两个源中某个特定源的输入上（正如 目前编写的str.cli函数所为），而是应<strong>该阻塞在其中任何一个源的输入上</strong>。事实上这正是 <strong>select和poll这两个函数的目的之一</strong></p>
<p>关于RST：<br>
上述讨论还取决于本例子的时序，客户调用readline既可能发生在服务器的RST 被客户收到之前，也可能发生在收到之后，如果readline发生在<strong>收到RST之前</strong>（如本例子所 示），那么结果是客户得到一个未预期的EOF；如果readline发生在<strong>收到RST之后</strong>，否则结果是由readline返回一个ECONNRESET （connection reset by peer，对方复位连接错误）.<br>
猜测原因：服务端发送RST会导致任何排队的数据都被抛弃，RST优先级最高，会被立即发出去，所以可能导致FIN还在排队的时候就已经被抛弃了<br>
疑惑：那如果FIN比RST先到达接收方会怎么样？</p>
<h1 id="sigpipe-信号">SIGPIPE 信号</h1>
<p>要是客户不理会readline函数返回的错误，反而写入更多的数据到服务器上，那又会发生什么呢？<br>
当一个进程向某个己收到RST的套接字执行写操作时，<strong>（客户端的）内核</strong>向该进程发送一个SIGPIPE信号.该信号的默认行为是终止进程，因此进程必须捕获它以免不情愿地被终止，同时写操作都将返回EPTPE错误。<br>
第一次写操作引发RST,第二次写引发SIGPIPE信号.写一个已接收了FIN的套接字不成问题，但是写一个已接收了 RST的套接字则是一个<strong>错误</strong>.<br>
处理SIGPIPE的建议方法取决于它发生时应用进程想做什么（比如写入log日志）<br>
但是必须意识到，如果使用 了多个套接字，该信号的递交无法告诉我们是哪个套接字出的错。如果我们确实需要知 道是哪个write出了错，那么必须要么不理会该信号，要么从信号处理函数返回后再处 理来自write的EPIPE。</p>
<h1 id="服务器主机崩溃">服务器主机崩溃</h1>
<p>注意区分进程终止和崩溃，模拟前者一般是使用kill信号，模拟后者则需要从网络上断开服务器主机，这样同时也模拟了当客户发送数据时服务器主机不可达的情形(即建立连接后某些中间路由器不工作)。</p>
<p>客户端发送数据后，等待服务器的ACK，因而阻塞在readline调用上，假设服务器主机己崩溃，从而对客户的数据分节根本没有响应，那么所返回的错误是 ETIMEDOUT（从readline调用返回的）<br>
然而如果某个中间路由器判定服务器主机已不可达，从而响应以一个“destination unreachable&quot;(目的地不可达)ICMP消息，那么所返回的错误是EHOSTUNREACH或ENETUNREACH。</p>
<p>如果希望更快地检测出这种情况，可以对readline调用设置一个超时</p>
<p>上述情形只有在我们向服务器主机发送数据时才能检测出它已经崩溃。如果希望不主动向它发送数据也能检测出服务器主机的崩溃，那么需要采用另外一个技术--SO_KEEPALIVE套接字选项。</p>
<h1 id="服务器主机崩溃后重启">服务器主机崩溃后重启</h1>
<p>模拟这种情形的最简单方法就是：先建立连接，再从网络上 函 断开服务器主机，将它关机后再重新启动，最后把它重新连接到网络中。<br>
处理方法重点在于：我们<strong>不想客户知道服务器主机的关机</strong></p>
<p>普通情况下：<br>
(1)	当服务器主机崩溃后重启时，它的TCP丢失了崩溃前的所有连接倍息，因此服务器TCP 对于所收到的来自客户的数据分节响应以一个RST。<br>
(2)	当客户TCP收到该RST时，客户正阻塞于readline调用，导致该调用返回ECONNRESET 错误。</p>
<h1 id="服务器主机关机">服务器主机关机</h1>
<p>当服务器子进程终止时，它的所 有打开着的描述符都被关闭，随后发生的步骤与服务器进程终止那一节一样，我们必须在客户中使用select或poll函数，使得服务器进程的终止一经发生，客户就能检测到。</p>
]]></content>
    </entry>
</feed>