<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-09-15T14:42:55.195Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[数组 122. 买卖股票的最佳时机 II]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-122-mai-mai-gu-piao-de-zui-jia-shi-ji-ii</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-122-mai-mai-gu-piao-de-zui-jia-shi-ji-ii">
        </link>
        <updated>2019-09-15T13:15:44.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>官方题目：<br>
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。<br>
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:<br>
输入: [7,1,5,3,6,4]<br>
输出: 7<br>
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。<br>
示例 2:<br>
输入: [1,2,3,4,5]<br>
输出: 4<br>
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。<br>
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题一开始还是有有点难倒我的，老是想着怎么找最大差值，但是转念一想，既然可以参加多次交易，那岂不是可以穿越到第二天发现升值了就马上回到前一天买下来？那就是非常简单的正差值相加了，代码如下：</p>
<pre><code>class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        int len=prices.size();
        int max=0;
        vector&lt;int&gt; profit(len,0);
        for(int i=1;i&lt;len;++i)
            profit[i]=prices[i]-prices[i-1];
        for(int i=0;i&lt;len;++i)
            if(profit[i]&gt;0)
                max +=profit[i];
        return max;
    }
};
</code></pre>
<p>这一题也是一次过，不过其实看了官方题解发现还是可以有很多可以提升的地方的，比如profit这个数组提高了空间复杂度，完全可以将差值作为判断条件。以下是官方题解：<br>
摘要<br>
我们必须确定通过交易能够获得的最大利润（对于交易次数没有限制）。为此，我们需要找出那些共同使得利润最大化的买入及卖出价格。</p>
<blockquote>
<p>解决方案<br>
方法一：暴力法<br>
这种情况下，我们只需要计算与所有可能的交易组合相对应的利润，并找出它们中的最大利润。</p>
</blockquote>
<pre><code>Java
class Solution {
    public int maxProfit(int[] prices) {
        return calculate(prices, 0);
    }

    public int calculate(int prices[], int s) {
        if (s &gt;= prices.length)
            return 0;
        int max = 0;
        for (int start = s; start &lt; prices.length; start++) {
            int maxprofit = 0;
            for (int i = start + 1; i &lt; prices.length; i++) {
                if (prices[start] &lt; prices[i]) {
                    int profit = calculate(prices, i + 1) + prices[i] - prices[start];
                    if (profit &gt; maxprofit)
                        maxprofit = profit;
                }
            }
            if (maxprofit &gt; max)
                max = maxprofit;
        }
        return max;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n^n)，调用递归函数 n^n次。<br>
空间复杂度：O(n)，递归的深度为 n。</p>
<p>方法二：峰谷法<br>
算法<br>
假设给定的数组为：<br>
[7, 1, 5, 3, 6, 4]<br>
如果我们在图表上绘制给定数组中的数字，我们将会得到<br>
如果我们分析图表，那么我们的兴趣点是连续的峰和谷。<br>
用数学语言描述为：<br>
TotalProfit= ∑ (height(peaki)−height(valleyi))<br>
关键是我们需要考虑到紧跟谷的每一个峰值以最大化利润。如果我们试图跳过其中一个峰值来获取更多利润，那么我们最终将失去其中一笔交易中获得的利润，从而导致总利润的降低。<br>
例如，在上述情况下，如果我们跳过 peak_i	 和 valley_j<br>
试图通过考虑差异较大的点以获取更多的利润，获得的净利润总是会小与包含它们而获得的静利润，因为 CC 总是小于 A+BA+B。</p>
</blockquote>
<pre><code>Java
class Solution {
    public int maxProfit(int[] prices) {
        int i = 0;
        int valley = prices[0];
        int peak = prices[0];
        int maxprofit = 0;
        while (i &lt; prices.length - 1) {
            while (i &lt; prices.length - 1 &amp;&amp; prices[i] &gt;= prices[i + 1])
                i++;
            valley = prices[i];
            while (i &lt; prices.length - 1 &amp;&amp; prices[i] &lt;= prices[i + 1])
                i++;
            peak = prices[i];
            maxprofit += peak - valley;
        }
        return maxprofit;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)。遍历一次。<br>
空间复杂度：O(1)。需要常量的空间。</p>
<p>方法三：简单的一次遍历<br>
算法<br>
该解决方案遵循 方法二 的本身使用的逻辑，但有一些轻微的变化。在这种情况下，我们可以简单地继续在斜坡上爬升并持续增加从连续交易中获得的利润，而不是在谷之后寻找每个峰值。最后，我们将有效地使用峰值和谷值，但我们不需要跟踪峰值和谷值对应的成本以及最大利润，但我们可以直接继续增加加数组的连续数字之间的差值，如果第二个数字大于第一个数字，我们获得的总和将是最大利润。这种方法将简化解决方案。<br>
这个例子可以更清楚地展现上述情况：<br>
[1, 7, 2, 3, 6, 7, 6, 7]<br>
与此数组对应的图形是：<br>
从上图中，我们可以观察到 A+B+CA+B+C 的和等于差值 DD 所对应的连续峰和谷的高度之差。</p>
</blockquote>
<pre><code>Java
class Solution {
    public int maxProfit(int[] prices) {
        int maxprofit = 0;
        for (int i = 1; i &lt; prices.length; i++) {
            if (prices[i] &gt; prices[i - 1])
                maxprofit += prices[i] - prices[i - 1];
        }
        return maxprofit;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)，遍历一次。<br>
空间复杂度：O(1)，需要常量的空间。</p>
</blockquote>
<p>暴力解就没啥好说的了，太暴力啦！，题解三就是和我给出的解一致，同时也给了我提示可以直接直接对差值进行判断，而不用再声明一个新的数组。然后题解二虽然过程比题解三复杂，但是它可以定位到最后取值的峰值和谷值所在，也算是一种取舍吧</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 121. 买卖股票的最佳时机]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-121-mai-mai-gu-piao-de-zui-jia-shi-ji</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-121-mai-mai-gu-piao-de-zui-jia-shi-ji">
        </link>
        <updated>2019-09-15T13:01:40.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目如下：<br>
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>
如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。<br>
注意你不能在买入股票前卖出股票。</p>
<p>示例 1:<br>
输入: [7,1,5,3,6,4]<br>
输出: 5<br>
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>
注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。<br>
示例 2:<br>
输入: [7,6,4,3,1]<br>
输出: 0<br>
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这一题还是相对简单很多的，一开始我的想法比较钻牛角尖，总是想着找出最小值再找相应的最大值，然后如果差值不是最大的话再找次小值，还得考虑先后blabla~然后突然发现其实值得大小其实和下标关系不大，完全可以记录一个最大值，然后不断地更新当前最小值和当前值的差，甚至于不管最小值是啥时候出现，反正你要是出现的时候能够推翻当前最大值，那之前出现的次小值也肯定比不上你呀，所以给出了如下题解，一次过！棒棒哒！：</p>
<pre><code>class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        int len=prices.size();
        if(len==0||len==1)
            return 0;
        int min=prices[0];
        int max=0;
        for(int i=0;i&lt;len;++i){
            min=prices[i]&lt;min?prices[i]:min;
            max=prices[i]-min&gt;max?prices[i]-min:max;
        }
        return max; 
    }
};
</code></pre>
<p>官方题解如下:</p>
<blockquote>
<p>解决方案<br>
我们需要找出给定数组中两个数字之间的最大差值（即，最大利润）。此外，第二个数字（卖出价格）必须大于第一个数字（买入价格）。<br>
形式上，对于每组 i 和 j（其中 j &gt; i）我们需要找出max(prices[j]−prices[i])。<br>
方法一：暴力法</p>
</blockquote>
<pre><code>Java
public class Solution {
    public int maxProfit(int prices[]) {
        int maxprofit = 0;
        for (int i = 0; i &lt; prices.length - 1; i++) {
            for (int j = i + 1; j &lt; prices.length; j++) {
                int profit = prices[j] - prices[i];
                if (profit &gt; maxprofit)
                    maxprofit = profit;
            }
        }
        return maxprofit;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n^2)。循环运行n(n−1)/2 次。<br>
空间复杂度：O(1)O(1)。只使用了两个变量 —— maxprofit 和profit。<br>
方法二：一次遍历<br>
算法<br>
假设给定的数组为：<br>
[7, 1, 5, 3, 6, 4]</p>
<p>如果我们在图表上绘制给定数组中的数字，我们将会得到：<br>
使我们感兴趣的点是上图中的峰和谷。我们需要找到最小的谷之后的最大的峰。<br>
我们可以维持两个变量——minprice 和 maxprofit，它们分别对应迄今为止所得到的最小的谷值和最大的利润（卖出价格与最低价格之间的最大差值）。</p>
</blockquote>
<pre><code>Java
public class Solution {
    public int maxProfit(int prices[]) {
        int minprice = Integer.MAX_VALUE;
        int maxprofit = 0;
        for (int i = 0; i &lt; prices.length; i++) {
            if (prices[i] &lt; minprice)
                minprice = prices[i];
            else if (prices[i] - minprice &gt; maxprofit)
                maxprofit = prices[i] - minprice;
        }
        return maxprofit;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)，只需要遍历一次。<br>
空间复杂度：O(1)，只使用了两个变量。</p>
</blockquote>
<p>暴力法就没啥好讲的了，我的方法和官方题解二吻合，然后比较有趣的是有个精选题解，从数学的角度分析了题解二的可行性，非常有趣，就是牛顿莱布尼茨公式666，有时间的话复习的时候应该看一下！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 45. 跳跃游戏 II]]></title>
        <id>https://lixin-ee.github.io//post/45-tiao-yue-you-xi-ii</id>
        <link href="https://lixin-ee.github.io//post/45-tiao-yue-you-xi-ii">
        </link>
        <updated>2019-09-15T12:44:57.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个非负整数数组，你最初位于数组的第一个位置。<br>
数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>
你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<p>示例:<br>
输入: [2,3,1,1,4]<br>
输出: 2<br>
解释: 跳到最后一个位置的最小跳跃数是 2。<br>
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。<br>
说明:<br>
假设你总是可以到达数组的最后一个位置。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/jump-game-ii<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>其实本来这道题应该蛮简单的，难点主要在于最小跳跃数这个限制，一开始我总想着从后往前推，但是一直无法把握好跳跃点增加的时机，所以一直是解答出错，加上一直被奇葩的特殊情况干扰，最终确定想法有比较大的缺陷，决定观看官方题解，首先给出最后的错解：</p>
<pre><code>int len = nums.size();
        int jump=0;
        if(len==0||nums[0]==0||len==1)
            return 0;
        for(int i=len-2;i&gt;0;--i){
            while(i&gt;=0&amp;&amp;nums[i]&gt;=len-i-1)
                --i;
            ++jump;
        }
        return jump;
</code></pre>
<p>我觉得我做题比较严重的一个问题就是老是从某些比较简单的解出发，所以总是会被例外的情况所击倒，现在回头看来代码还是很有问题的，更应该去寻找能够达到当前位置的最小值，而不是遇到不可达值就停下来。下面是官方题解：</p>
<blockquote>
<p>解题思路：<br>
从数组的第 0 个位置开始跳，跳的距离小于等于数组上对应的数。求出跳到最后个位置需要的最短步数。比如上图中的第 0 个位置是 2，那么可以跳 1 个距离，或者 2 个距离，我们选择跳 1 个距离，就跳到了第 1 个位置，也就是 3 上。然后我们可以跳 1，2，3 个距离，我们选择跳 3 个距离，就直接到最后了。所以总共需要 2 步。</p>
<p>解法一 ：顺藤摸瓜<br>
LeetCode 讨论里，大部分都是这个思路，贪婪算法，我们每次在可跳范围内选择可以使得跳的更远的位置。<br>
如下图，开始的位置是 2，可跳的范围是橙色的。然后因为 3 可以跳的更远，所以跳到 3 的位置。<br>
如下图，然后现在的位置就是 3 了，能跳的范围是橙色的，然后因为 4 可以跳的更远，所以下次跳到 4 的位置。<br>
写代码的话，我们用 end 表示当前能跳的边界，对于上边第一个图的橙色 1，第二个图中就是橙色的 4，遍历数组的时候，到了边界，我们就重新更新新的边界。</p>
</blockquote>
<pre><code>Java
public int jump(int[] nums) {
    int end = 0;
    int maxPosition = 0; 
    int steps = 0;
    for(int i = 0; i &lt; nums.length - 1; i++){
        //找能跳的最远的
        maxPosition = Math.max(maxPosition, nums[i] + i); 
        if( i == end){ //遇到边界，就更新边界，并且步数加一
            end = maxPosition;
            steps++;
        }
    }
    return steps;
}
</code></pre>
<blockquote>
<p>时间复杂度：O(n)。<br>
空间复杂度：O(1)。<br>
这里要注意一个细节，就是 for 循环中，i &lt; nums.length - 1，少了末尾。因为开始的时候边界是第 0 个位置，steps 已经加 1 了。如下图，如果最后一步刚好跳到了末尾，此时 steps 其实不用加 1 了。如果是 i &lt; nums.length，i 遍历到最后的时候，会进入 if 语句中，steps 会多加 1。</p>
<p>解法二：顺瓜摸藤<br>
我们知道最终要到达最后一个位置，然后我们找前一个位置，遍历数组，找到能到达它的位置，离它最远的就是要找的位置。然后继续找上上个位置，最后到了第 0 个位置就结束了。<br>
至于离它最远的位置，其实我们从左到右遍历数组，第一个满足的位置就是我们要找的。</p>
</blockquote>
<pre><code>Java
public int jump(int[] nums) {
    int position = nums.length - 1; //要找的位置
    int steps = 0;
    while (position != 0) { //是否到了第 0 个位置
        for (int i = 0; i &lt; position; i++) {
            if (nums[i] &gt;= position - i) {
                position = i; //更新要找的位置
                steps++;
                break;
            }
        }
    }
    return steps;
}
</code></pre>
<blockquote>
<p>时间复杂度：O(n²)，因为最坏的情况比如 1 1 1 1 1 ，position 会从 5 更新到 0，并且每次更新都会经历一个 for 循环。<br>
空间复杂度：O(1)。</p>
<p>这种想法看起来更简单了，为什么奏效呢？我们可以这样想。<br>
从左到右跳的话，2 -&gt; 3 -&gt; 4 -&gt; 1。<br>
从右到左的话，我们找能跳到 11 的最左边的位置，我们找的只能是 44 或者是 44 左边的。<br>
找到 4 的话，不用说，刚好完美。<br>
如果是中间范围 3 和 4 之间的第 2 个 1 变成了 3，那么这个位置也可以跳到末尾的 1，按我们的算法我们就找到了这个 3，也就是 4 左边的位置。但其实并不影响我们的 steps，因为这个数字是 3 到 4 中间范围的数，左边界 3 也可以到这个数，所以下次找的话，会找到边界 3，或者边界 3 左边的数。 会不会直接找到上个边界 2 呢？不会的，如果找到了上一个边界 2，那么意味着从 2 直接跳到 3 和 4 之间的那个数，再从这个数跳到末尾就只需 2 步了，但是其实是需要 3 步的。</p>
</blockquote>
<p>官方题解一这个最大范围end非常奇妙，其实和1中的非常相似，用end来作为标志递增steps刚刚好能够得到最小的steps，妙啊！（其实如果我能好好运用上一题<br>
的知识也能得到这个解，一种醍醐灌顶的感觉），题解二就是我一直在挣扎的倒推解题法了，还是那句话，找到最左边的能到达当前点的位置才是正解。最后给出解答：</p>
<pre><code>class Solution {
public:
    int jump(vector&lt;int&gt;&amp; nums) {
       int len = nums.size();
        if(len==0||nums[0]==0||len==1)
            return 0;
        int jump=0;
        int max_reach=0;
        int end=0;
        for(int i=0;i&lt;len-1;++i){
            max_reach= max_reach&gt;nums[i]+i?max_reach:nums[i]+i;
            if(i==end){
                ++jump;
                end=max_reach;
            }
        }
        return jump;
            
    }
};
</code></pre>
<p>最后感想还是得好好整理复习前面的题，这样后面的题才能把知识灵活应用起来！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第六章 笔记+习题 6.3-6.7]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-liu-zhang-bi-ji-xi-ti-63-67</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-liu-zhang-bi-ji-xi-ti-63-67">
        </link>
        <updated>2019-09-12T11:48:50.000Z</updated>
        <content type="html"><![CDATA[<p>6.3.1无返回值函数<br>
return语句终止当前正在执行的函数并将控制权返回到调用函数的地方<br>
void函数会在最后隐式执行return语句，<br>
void函数可以return另一个返回值为void的函数，不能返回其他类型的表达式<br>
6.3.2有返回值函数<br>
编译器不一定能发现漏掉return语句的错误<br>
返回值用于初始化调用点的一个临时量<br>
最好返回的是对象的引用，否则会返回返回值的拷贝副本<br>
不要返回局部对象的引用或指针<br>
如果返回类型是引用，不能返回局部对象的引用或者局部临时量如“abc”但可以直接返回对象（区分局部对象）而不是必须是引用（因为原则上引用就是一个别名）<br>
调用返回引用的函数得到左值，其他返回类型得到右值<br>
函数可以返回花括号包围的值的类型，比如vector，如果是内置类型则花括号包围的列表最多包含一个值，如果是类类型，由类本身定义。<br>
主函数main可以没有return语句，会在结尾隐式插入return 0；<br>
返回非0值的具体含义由机器决定，所以cstdlib 头文件中定义了两个通用的预处理变量 EXIT_FAILURE和EXIT_SUCCESS，其与机器无关，两者皆为预处理变量既不能加上std::，也不能用using声明<br>
递归 函数自己调用自己<br>
main函数不能调用自己</p>
<p>习题6.30<br>
error C2561: “str_subrange”: 函数必须返回值<br>
习题6.31<br>
返回的引用指向了函数中定义的局部变量或者局部常量<br>
习题6.32<br>
合法，将ia的每个元素赋值为相应的下标值<br>
习题6.33</p>
<pre><code>void print(vector&lt;int&gt; v, int index);

int main() {
	vector&lt;int&gt; ia = { 1,2,3,4,5,6,7,8,9,0 };
	print(ia, 0);
};
void print(vector&lt;int&gt; v,int index){
	if (index &lt; v.size())
		cout &lt;&lt; v[index] &lt;&lt; endl,print(v,++index);
}
</code></pre>
<p>习题6.34<br>
如果输入一个负数，将陷入死循环直至内存崩溃。<br>
习题6.35<br>
val--是对val递减后传入val原本值的副本，会造成无限循环</p>
<p>6.3.3 返回数组指针<br>
无法返回数组，但可以返回指向大小确定的数组的引用或指针<br>
返回数组指针的函数声明为 type （*函数名（形参列表））[数组维度]<br>
所以建议使用类型别名，decltype 或尾置返回类型<br>
<code>int array[10]; decltype(array) *func(int); auto func(int) -&gt;int(*)[10]；</code></p>
<p>习题6.36<br>
<code>string(&amp;func())[10]</code><br>
习题6.37</p>
<pre><code>typedef string re[10]; using re=string[10];re &amp;func();
decltype(string [10]) &amp;func();
auto func()-&gt;string(&amp;)[10]
</code></pre>
<p>声明时尾置返回最好，定义时类型别名和decltype最好，这样可读性高<br>
知识点：注意尾置返回中指针和引用必须加括号string(&amp;)[10] string(*)[10]<br>
习题6.38<br>
其实就是把*号换成&amp;号 函数体内的&amp;去除</p>
<p>6.4函数重载<br>
函数重载 名字相同形参列表不同（<strong>返回类型可以不同，但不能只有返回类型的不同</strong>）<br>
main函数不能重载<br>
不允许两个函数除了返回类型外其他要素都相同，如果其他要素都相同只有返回类型不同则后一个函数声明是错误的<br>
<strong>形参有无名字不影响判断，形参的名字不同类型相同的话，仍视为同一函数</strong><br>
如果仅仅是函数名不同，则视为类型别名，也视为与原名相同<br>
<strong>形参无视顶层const</strong> 所以有顶层const形参和没有顶层const的形参是<strong>等价的</strong><br>
所以func(int *param) 和func(int * const param) 是相同的，注意const的位置<br>
func(const int * param) 则是新函数<br>
指向常量的指针只能传递给底层const形参，<strong>不能传给普通指针形参</strong><br>
使用const_cast在重载中对变量进行强制转换，去除底层const</p>
<p>习题6.39<br>
（a）形参是顶层const 然而形参会无视const，所以等于重复声明<br>
（b）返回值改为double 但是仅仅有返回类型不同，所以等于重复声明<br>
（c）形参类型和返回类型改变了，是合法的</p>
<p>6.4.1重载与作用域<br>
在内层作用域中无法进行重载，只会隐藏外层作用域中声明的同名实体<br>
c++中 名字查找发生在类型检查之前，一旦在当前作用域找到了所需的名字，编译器就会忽略掉外层作用域的同名实体，再进行类型检测确认函数调用是否有效</p>
<p>6.5.1默认实参<br>
默认实参 就是缺省值<br>
通常应该在函数声明中指定默认实参，并将该声明放在合适的头文件中,例如：<br>
<code>void func(int param1=1,int param2=10,char param3 = 'p');</code><br>
注意一旦某个形参被赋予默认值，<strong>后面的所有形参都必须有默认值</strong><br>
如果想覆盖右侧的默认值，必须也覆盖前面的默认值<br>
在给定的作用域中一个形参<strong>只能被赋予一次</strong>默认实参，函数的后续声明只能为之前那些没有默认值的形参添加默认实参<br>
默认实参的<strong>初始化</strong>可以是表达式，不能是局部变量，变量的声明必须出现在函数之外<br>
用作默认实参的名字在函数声明的作用域内解析，<strong>可以通过实参名改变默认实参值，但是新定义的同名变量无法隐藏外层的默认实参变量</strong>，例如在另外一个函数中用于默认实参值的变量值a变化了，同时会改变默认实参的a，但是如果在内层作用域定义一个新的a，并不会影响外层声明中的a<br>
<strong>经常使用默认实参的变量放在后面，不常使用的放在前面</strong></p>
<p>习题6.40<br>
b是错误的，默认实参应该在后面，否则只要有实参就不能使用默认实参<br>
习题6.41<br>
a错误，至少需要一个参数，c合法但初衷不符，wd会被赋予'*'的ASCII码，不能越过某个默认实参改变后面的默认实参。<br>
习题6.42</p>
<pre><code>string make_plural(size_t ctr, const string &amp;word, const string &amp;ending = &quot;s&quot;);

int main() {
	cout &lt;&lt; &quot;两单词的单数形式：&quot; &lt;&lt; make_plural(1, &quot;success&quot;, &quot;es&quot;) &lt;&lt; &quot;  &quot; &lt;&lt; make_plural(1, &quot;failure&quot;) &lt;&lt; endl;
	cout &lt;&lt; &quot;两单词的复数形式：&quot; &lt;&lt; make_plural(2, &quot;success&quot;, &quot;es&quot;) &lt;&lt; &quot;  &quot; &lt;&lt; make_plural(2, &quot;failure&quot;) &lt;&lt; endl;
};

string make_plural(size_t ctr, const string &amp;word, const string &amp;ending) {
	return (ctr &gt; 1) ? word + ending : word;
}
</code></pre>
<p>知识点：默认实参定义在函数的声明，不需要定义在函数的定义！！！</p>
<p>6.5.2内联函数和constexpr函数<br>
内联函数 在调用点上召开为一段程序 避免函数调用的开销<br>
内联函数关键字inline 适用于规模小频繁调用的函数<br>
Constexpr函数<strong>返回类型和形参类型都是字面值类型</strong>（引用 指针 算术类型）（自定义类、IO库、string类等就不是字面值类型），函数体内有且只有一条return语句，被隐式地指定为内联函数<br>
比如 constexpr int func() { return 42; }<br>
Constexpr函数<strong>允许返回值并非一个常量</strong>，所以不一定返回常量表达式(传入常量表达式，返回常量表达式，反之则返回非常量表达式)<br>
与其他函数不同，内联函数和Constexpr函数 <strong>可以多次定义，但需要保持一致</strong>，所以通常定义在头文件中</p>
<p>习题6.43<br>
（a）声明和定义都在头文件<br>
（b）声明在头文件，定义在源文件<br>
知识点：因为内联函数可以定义多次，万一以后错手定义会很麻烦，为了保证一致最好定义在头文件，普通函数则只能定义一次，所以只需要放在源文件。<br>
习题6.44<br>
直接在返回类型前面加上inline就vans了<br>
习题6.45<br>
简短而且常用的函数可以定义为内联函数<br>
习题6.46<br>
不可以，string不是字面值类型</p>
<p>6.5.3调试帮助<br>
arrest 预处理宏 一个预处理变量，arrest宏定义在carrest头文件中<br>
arrest（expr），判断为假则输出信息终止程序，输出为真则什么都不做，用于检查不能发生的条件，例如<br>
assert(word.size() &gt; threshold)；<br>
宏名字在程序内必须唯一，所以不能定义与宏名字相同的变量、函数等<br>
NDEBUG决定了 arrest是否执行检查，是否开启调试状态，如果定义了就等于关闭，未定义就等于开启。<br>
详细例子可看笔记</p>
<p>习题6.47</p>
<pre><code>void print(vector&lt;int&gt; v, int index);

int main() {
	vector&lt;int&gt; ia = { 1,2,3,4,5,6,7,8,9,0 };
	print(ia, 0);
};
void print(vector&lt;int&gt; v, int index) {
	if (index &lt; v.size()) {
#ifndef NDEBUG
		cout &lt;&lt; v.size() &lt;&lt; endl;
#endif // !NDEBUG
		cout &lt;&lt; v[index] &lt;&lt; endl, print(v, ++index);
	}	
}
</code></pre>
<p>习题6.48<br>
不合理，while已经对cin进行判断了，并且只要cin有输入就为真，并非不能发生的条件</p>
<p>6.6 函数匹配<br>
第一步 候选函数（一与被调用函数同名，二其声明在调用点可见）<br>
第二步 考察本次调用提供的实参，选出能被实参调用的可行函数（一是形参与本次调用提供的实参数量相等，二是实参类型与对应的形参类型相同，或者能转换成形参的类型）<br>
第三步 最佳匹配<br>
实参类型和形参类型越接近匹配得越好<br>
该函数每个实参的匹配都不劣于其他可行函数需要的匹配<br>
至少有一个实参的匹配优于其他可行函数提供的匹配</p>
<p>习题6.49<br>
候选函数：本次调用对应的重载函数集 1.与被调用函数同名 2.其声明在调用点可见。<br>
可行函数，从候选函数中选出的能被实参调用的函数 1.实参形参数量匹配 2.类型匹配或可转换<br>
习题6.50<br>
（a）二义性了，可以选择转化为double或者int<br>
（b）f（int）<br>
（c）f（int，int）<br>
（d）f（double，double）<br>
习题6.51</p>
<pre><code>void f();
void f(int);
void f(int, int);
void f(double, double = 3.14);
int main() {
	//f(2.56, 42);//有多个重载函数示例与实参列表匹配
	f(42);
	f(42, 0);
	f(2.56, 3.14);
};
void f(){
	cout &lt;&lt; &quot;f()&quot; &lt;&lt; endl;
}
void f(int){
	cout &lt;&lt; &quot;f(int)&quot; &lt;&lt; endl;
}
void f(int, int){
	cout &lt;&lt; &quot;f(int, int)&quot; &lt;&lt; endl;
}
void f(double, double ){
	cout &lt;&lt; &quot;f(double,double = 3.14)&quot; &lt;&lt; endl;
}
</code></pre>
<p>6.6.1实参类型转换<br>
const转换:可以将指向类型T的指针或引用转换成指向const T的指针或引用，例如 int i; const int &amp;j=i;<br>
类型提升：也就是short、char等提升为int等<br>
算术类型转换：运算过程中 小对象的类型转化为另外一个大的对象的类型<br>
指针转换：0和nullptr能够转换成任意指针类型，指向任意非常量的指针可以转换成void*，指向任意常量的指针可以转换成const void*，派生继承关系中的派生类和基类的指针转换<br>
小整型short一般会提升到int类型，使用short类型的函数反而会导致类型转换<br>
所有算数类型转换的级别一样</p>
<p>习题6.52<br>
（a）3.类型提升匹配 （b）4.算术类型转换<br>
习题6.53<br>
（a）重载<br>
（b）重载<br>
（c）忽略顶层const，和第一句其实一样，不合法</p>
<p>6.7函数指针<br>
声明一个指向函数的指针，<strong>只需要用指针替换函数名即可（不要漏掉括号）</strong><br>
<code>void (*pointer)(int ,int);</code><br>
使用函数名时<strong>会自动转换成指针</strong><br>
可以直接使用指向函数的指针调用，<strong>无须提前解引用指针</strong><br>
函数指针可以赋<strong>nullptr或者值为0的常量表达式</strong><br>
函数指针之间不存在转换规则<br>
指针类型<strong>必须</strong>与重载函数中的某一个精确匹配<br>
形参<strong>不能是函数类型</strong>，但<strong>可以是指向函数的指针</strong>，此时形参看起来是函数类型，实际上是被当作指针来使用<br>
函数作为实参时会自动转换成指针<br>
Decltype 返回<strong>函数类型</strong>，而不是自动转换成指针类型<br>
返回指向函数的指针<code>int (*f1(int))(int*,int); 或者 using PF = int(*)(int*,int);PF</code> f1(int)或者用尾置返回 <code>auto f1(int)-&gt;int(*)(int*,int)</code><br>
明确知道返回函数时用decltype<br>
<code>decltype(func1) *func2();</code>//注意，func1为函数名</p>
<p>习题6.54</p>
<pre><code>int func(int, int);
int main() {
	vector&lt;int (*)(int,int)&gt; v;
};
int func(int, int) {
	return 1;
}
</code></pre>
<p>知识点：函数类型与函数名无任何关系，int func(int, int)的函数指针类型是int (*)(int,int)，换个名字也一样<br>
习题6.55</p>
<pre><code>int func(int, int);
int add(int a, int b);
int minuss(int a, int b);
int multi(int a, int b);
int divide(int a, int b);
int main() {
	vector&lt;int(*)(int, int)&gt; v{add,minuss,multi,divide};
};
int func(int, int) {
	return 1;
}
int add(int a, int b) {
	return a+b;
}
int minuss(int a, int b) {
	return a - b;
}
int multi(int a, int b) {
	return a * b;
}
int divide(int a, int b) {
	return a / b;
}
</code></pre>
<p>知识点：貌似minus不能用<br>
习题6.56</p>
<pre><code>int func(int, int);
int add(int a, int b);
int minuss(int a, int b);
int multi(int a, int b);
int divide(int a, int b);
int main() {
	vector&lt;int(*)(int, int)&gt; v{add,minuss,multi,divide};
	cout &lt;&lt; v[0](10, 2) &lt;&lt; endl;
	cout &lt;&lt; v[1](10, 2) &lt;&lt; endl;
	cout &lt;&lt; v[2](10, 2) &lt;&lt; endl;
	cout &lt;&lt; v[3](10, 2) &lt;&lt; endl;
};
int func(int, int) {
	return 1;
}
int add(int a, int b) {
	return a+b;
}
int minuss(int a, int b) {
	return a - b;
}
int multi(int a, int b) {
	return a * b;
}
int divide(int a, int b) {
	return a / b;
}
</code></pre>
<p>知识点:可以直接调用函数的指针 pointer（int，int）</p>
<p>习题感悟<br>
注意尾置返回中 指针和引用必须加括号string(&amp;)[10] string(*)[10]<br>
默认实参定义只能在函数的声明，不需要定义在函数的定义！！！<br>
因为内联函数可以定义多次，万一以后错手定义会很麻烦，为了保证一致最好定义在头文件，普通函数则只能定义一次，所以只需要放在源文件。<br>
返回类型和形参中包含字面值类型的函数不可以定义为constexpr<br>
实参类型转换是有等级差异的<br>
函数类型与函数名无任何关系，int func(int, int)的函数指针类型是int (*)(int,int)，换个名字也一样<br>
貌似minus不能用<br>
可以直接调用函数的指针 pointer（int，int）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 55. 跳跃游戏]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-55-tiao-yue-you-xi</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-55-tiao-yue-you-xi">
        </link>
        <updated>2019-09-12T11:43:10.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>官方题目：<br>
给定一个非负整数数组，你最初位于数组的第一个位置。<br>
数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>
判断你是否能够到达最后一个位置。</p>
<p>示例 1:<br>
输入: [2,3,1,1,4]<br>
输出: true<br>
解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。<br>
示例 2:<br>
输入: [3,2,1,0,4]<br>
输出: false<br>
解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/jump-game<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>对题目一开始的思考就是能够按某种顺序进行运算从而得出结果，一开始是想用逆推法，但是后来发现从前开始也是阔以的，具体思路就是判断每个点可以前进的值，并且维护一个最远可以达到的值reach，如果当前点大于reach就将reach的值改为当前点的值，最后能够去到的最大值和数组长度之间是否相等的判断值就是答案，代码如下：</p>
<pre><code>class Solution {
public:
    bool canJump(vector&lt;int&gt;&amp; nums) {
       int len=nums.size();
        if(len==0||len==1)
            return true;
        int reach=0;
        for(int i=0;i&lt;len-1;++i){
            int temp=reach;
            reach=i+nums[i];
            if(temp&gt;reach)
                swap(temp,reach);
            if(reach==i)
                return false;
        }
        if(reach&gt;=len-1)
         return true;
        else
        return false;    
    }
};
</code></pre>
<p>这一次由于找准了思路，所以一次通过，鼓掌！！hhh<br>
然后来看一下官方题解吧：</p>
<blockquote>
<p>定义<br>
如果我们可以从数组中的某个位置跳到最后的位置，就称这个位置是“好坐标”，否则称为“坏坐标”。问题可以简化为第 0 个位置是不是“好坐标”。<br>
题解<br>
这是一个动态规划问题，通常解决并理解一个动态规划问题需要以下 4 个步骤：<br>
利用递归回溯解决问题<br>
利用记忆表优化（自顶向下的动态规划）<br>
移除递归的部分（自底向上的动态规划）<br>
使用技巧减少时间和空间复杂度<br>
下面的所有解法都是正确的，但在时间和空间复杂度上有区别。</p>
<p>方法 1：回溯<br>
这是一个低效的解决方法。我们模拟从第一个位置跳到最后位置的所有方案。从第一个位置开始，模拟所有可以跳到的位置，然后从当前位置重复上述操作，当没有办法继续跳的时候，就回溯。</p>
</blockquote>
<pre><code>public class Solution {
    public boolean canJumpFromPosition(int position, int[] nums) {
        if (position == nums.length - 1) {
            return true;
        }

        int furthestJump = Math.min(position + nums[position], nums.length - 1);
        for (int nextPosition = position + 1; nextPosition &lt;= furthestJump; nextPosition++) {
            if (canJumpFromPosition(nextPosition, nums)) {
                return true;
            }
        }

        return false;
    }

    public boolean canJump(int[] nums) {
        return canJumpFromPosition(0, nums);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(2^n) ，最多有 2^n种从第一个位置到最后一个位置的跳跃方式，其中 n 是数组 nums 的元素个数，完整的证明见附录 A。<br>
空间复杂度：O(n)，回溯法只需要栈的额外空间。</p>
</blockquote>
<blockquote>
<p>方法 2：自顶向下的动态规划<br>
自顶向下的动态规划可以理解成回溯法的一种优化。我们发现当一个坐标已经被确定为好 / 坏之后，结果就不会改变了，这意味着我们可以记录这个结果，每次不用重新计算。<br>
因此，对于数组中的每个位置，我们记录当前坐标是好 / 坏，记录在数组 memo 中，定义元素取值为 GOOD ，BAD，UNKNOWN。这种方法被称为记忆化。<br>
例如，对于输入数组 nums = [2, 4, 2, 1, 0, 2, 0] 的记忆表如下，G 代表 GOOD，B 代表 BAD。我们发现不能从下标 2，3，4 到达最终坐标 6，但可以从 0，1，5 和 6 到达最终坐标 6。<br>
步骤<br>
初始化 memo 的所有元素为 UNKNOWN，除了最后一个显然是 GOOD （自己一定可以跳到自己）<br>
优化递归算法，每步回溯前先检查这个位置是否计算过（当前值为：GOOD / BAD）<br>
如果已知直接返回结果 True / False<br>
否则按照之前的回溯步骤计算<br>
计算完毕后，将结果存入memo表中</p>
</blockquote>
<pre><code>Java
enum Index {
    GOOD, BAD, UNKNOWN
}

public class Solution {
    Index[] memo;

    public boolean canJumpFromPosition(int position, int[] nums) {
        if (memo[position] != Index.UNKNOWN) {
            return memo[position] == Index.GOOD ? true : false;
        }

        int furthestJump = Math.min(position + nums[position], nums.length - 1);
        for (int nextPosition = position + 1; nextPosition &lt;= furthestJump; nextPosition++) {
            if (canJumpFromPosition(nextPosition, nums)) {
                memo[position] = Index.GOOD;
                return true;
            }
        }

        memo[position] = Index.BAD;
        return false;
    }

    public boolean canJump(int[] nums) {
        memo = new Index[nums.length];
        for (int i = 0; i &lt; memo.length; i++) {
            memo[i] = Index.UNKNOWN;
        }
        memo[memo.length - 1] = Index.GOOD;
        return canJumpFromPosition(0, nums);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n^2))，数组中的每个元素，假设为 i，需要搜索右边相邻的 nums[i] 个元素查找是否有 GOOD 的坐标。 nums[i] 最多为 n，n 是 nums 数组的大小。<br>
空间复杂度：O(2n)=O(n)，第一个 n 是栈空间的开销，第二个 n 是记忆表的开销。</p>
</blockquote>
<blockquote>
<p>方法 3：自底向上的动态规划<br>
底向上和自顶向下动态规划的区别就是消除了回溯，在实际使用中，自底向下的方法有更好的时间效率因为我们不再需要栈空间，可以节省很多缓存开销。更重要的事，这可以让之后更有优化的空间。回溯通常是通过反转动态规划的步骤来实现的。<br>
这是由于我们每次只会向右跳动，意味着如果我们从右边开始动态规划，每次查询右边节点的信息，都是已经计算过了的，不再需要额外的递归开销，因为我们每次在 memo 表中都可以找到结果。</p>
</blockquote>
<pre><code>Java
enum Index {
    GOOD, BAD, UNKNOWN
}

public class Solution {
    public boolean canJump(int[] nums) {
        Index[] memo = new Index[nums.length];
        for (int i = 0; i &lt; memo.length; i++) {
            memo[i] = Index.UNKNOWN;
        }
        memo[memo.length - 1] = Index.GOOD;

        for (int i = nums.length - 2; i &gt;= 0; i--) {
            int furthestJump = Math.min(i + nums[i], nums.length - 1);
            for (int j = i + 1; j &lt;= furthestJump; j++) {
                if (memo[j] == Index.GOOD) {
                    memo[i] = Index.GOOD;
                    break;
                }
            }
        }

        return memo[0] == Index.GOOD;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n^2)，数组中的每个元素，假设为 i，需要搜索右边相邻的 nums[i] 个元素查找是否有 GOOD 的坐标。 nums[i] 最多为 n，n 是 nums 数组的大小。<br>
空间复杂度：O(n)，记忆表的存储开销。</p>
</blockquote>
<blockquote>
<p>方法 4：贪心<br>
当我们把代码改成自底向上的模式，我们会有一个重要的发现，从某个位置出发，我们只需要找到第一个标记为 GOOD 的坐标（由跳出循环的条件可得），也就是说找到最左边的那个坐标。如果我们用一个单独的变量来记录最左边的 GOOD 位置，我们就可以避免搜索整个数组，进而可以省略整个 memo 数组。<br>
从右向左迭代，对于每个节点我们检查是否存在一步跳跃可以到达 GOOD 的位置（currPosition + nums[currPosition] &gt;= leftmostGoodIndex）。如果可以到达，当前位置也标记为 GOOD ，同时，这个位置将成为新的最左边的 GOOD 位置，一直重复到数组的开头，如果第一个坐标标记为 GOOD 意味着可以从第一个位置跳到最后的位置。<br>
模拟一下这个操作，对于输入数组 nums = [9, 4, 2, 1, 0, 2, 0]，我们用 G 表示 GOOD，用 B 表示 BAD 和 U 表示 UNKNOWN。我们需要考虑所有从 0 出发的情况并判断坐标 0 是否是好坐标。由于坐标 1 是 GOOD，我们可以从 0 跳到 1 并且 1 最终可以跳到坐标 6，所以尽管 nums[0] 可以直接跳到最后的位置，我们只需要一种方案就可以知道结果。</p>
</blockquote>
<pre><code>Index	0	1	2	3	4	5	6
nums	9	4	2	1	0	2	0
memo	U	G	B	B	B	G	G
Java
public class Solution {
    public boolean canJump(int[] nums) {
        int lastPos = nums.length - 1;
        for (int i = nums.length - 1; i &gt;= 0; i--) {
            if (i + nums[i] &gt;= lastPos) {
                lastPos = i;
            }
        }
        return lastPos == 0;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)，只需要访问 nums 数组一遍，共 n 个位置，n 是 nums 数组的长度。<br>
空间复杂度：O(1)，不需要额外的空间开销。</p>
</blockquote>
<blockquote>
<p>总结<br>
最后一个问题是，如何在面试场景中想到这个做法。我的建议是“酌情考虑”。最好的解法当然和别的解法相比更简单也更短，但是不那么容易直接想到。<br>
递归回溯的版本最容易想到，所以在思考更复杂解法的时候可以顺带提及一下这个解法，你的面试官实际上可能会想要看到这个解法。但如果没有，请提及可以使用动态规划的解法，并试想一下如何用记忆表来实现。如果你发现面试官希望你回答自顶向下的方法，那么就不太需要思考自底向上的版本，但我推荐在面试中提及一下自底向下的优点。</p>
</blockquote>
<p>其实官方解主要还是集中注意力在动态规划上，算是对动态规划的一个学习加深吧，特别是最后一个自底向上倒推的的方法，挺不错的，就是一开始我想解决的方向，当然我感觉我的方法也不错hhh（在题解中也是第一高赞题解hhh），所以就保留答案最为最理想答案吧，当然官方题解的总结很到位，以后复习的时候还是得好好看看动态规划的方法，毕竟动态规划才是更通用的做法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第六章 笔记+习题 6.1-6.2]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-liu-zhang-bi-ji-xi-ti-61-63</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-liu-zhang-bi-ji-xi-ti-61-63">
        </link>
        <updated>2019-09-12T01:09:34.000Z</updated>
        <content type="html"><![CDATA[<p>6.1函数基础<br>
一个函数定义包括：返回类型，函数名字，由0个或多个形参组成的列表以及函数体<br>
通过调用运算符来<strong>执行函数，调用运算符的形式是一对圆括号</strong>，作用于一个表达式，表达式是函数或者指向函数的指针，圆括号内为实参，实参初始化形参，调用表达式的类型就是函数的类型<br>
函数第一步是隐式地定义并初始化形参<br>
实参的类型和数量都必须与形参匹配，所以形参一定会被初始化<br>
空形参可以是隐式或者<strong>显式（void）</strong><br>
每个形参的类型都必须单独声明，不可以因为类型相同而忽略<br>
形参可以<strong>空名</strong>，但不可以同名，<strong>通常以空名代表不被使用，但也必须用实参初始化</strong><br>
函数的返回类型不可以是<strong>数组或者函数</strong>，但可以是指向数组的<strong>指针或引用</strong></p>
<p>习题6.1<br>
实参是形参的初始值，实参用于初始化对应位置的形参<br>
习题6.2<br>
（a）返回类型为int<br>
（b）没有定义返回类型<br>
（c）形参名字不可以相同<br>
（d）函数体不管语句数量多少，必须使用花括号<br>
习题6.3+6.4</p>
<pre><code>int factorial(int fact);
int main() {
	int i;
	while (cin) {
		cout &lt;&lt; &quot;please input one number:&quot;;
		cin &gt;&gt; i;
		cout &lt;&lt; factorial(i) &lt;&lt; endl;
	}
};

int factorial(int fact) {
	int sum=1;
	while (fact)
		sum *= fact--;
	return sum;
}
</code></pre>
<p>知识点：不要忽略了函数的声明！<br>
习题6.5</p>
<pre><code>int num_abs(int num);

int main() {
	int i;
	while (cin) {
		cout &lt;&lt; &quot;please input one number:&quot;;
		cin &gt;&gt; i;
		cout &lt;&lt; num_abs(i) &lt;&lt; endl;
	}
};

int num_abs(int num) {
	return num&gt;0?num:-num;
}
</code></pre>
<p>6.1.1局部对象<br>
名字有作用域，对象有生命周期<br>
形参和函数体内部定义的变量统称为局部变量<br>
自动对象 只存在于块执行期间的对象 块执行结束后，自动对象的值变为未定义<br>
形参是一种自动对象，内置类型的未初始化局部变量将产生未定义的值<br>
局部静态对象 static 直到程序终止时才被销毁，在此期间就算函数执行结束也不会对她产生影响（可以用来计算函数调用次数）<br>
内置类型的局部静态变量默认初始化为0，而不是未定义</p>
<p>习题6.6<br>
形参和局部静态变量都属于局部变量，只存在于块执行期间，但是局部静态变量的存在周期为整个程序执行期间，形参在块执行后的值变为未定义。代码见2.7<br>
习题6.7</p>
<pre><code>int formal_param(int f);

int main() {
	int i = 10;
	while(i)
		formal_param(i),--i;
};

int formal_param(int f) {
	int i=0;
	static int s_i=0;
	cout &lt;&lt; f&lt;&lt;' '&lt;&lt;++i &lt;&lt; ' ' &lt;&lt; ++s_i&lt;&lt;endl;
	return 0;
}
</code></pre>
<p>6.1.2<br>
函数只能定义一次，但可以声明多次。函数声明无须函数体，可以忽略形参的名字，用一个分号代替 例如 int add(int ,int);<br>
函数声明也称作函数原型<br>
建议函数和变量在<strong>头文件中声明，在源文件中定义,</strong><br>
含有函数声明的头文件应该被包含到定义函数的源文件中，<br>
<strong>通过以上的配合，其实就是将所有用到该函数的cpp文件中的声明移动到头文件中，编译器会自动在包含了头文件的cpp文件中搜索函数定义，从而以后可以很方便地修改函数的声明（比如修改形参数量），不需要一个一个地在使用了该函数的cpp文件中修改。</strong></p>
<p>习题6.8<br>
chapter6.h</p>
<pre><code>#pragma once
#ifndef CHAPTER6_H
#define CHAPTER6_H
int factorial(int fact);
#endif // !CHAPTER6_H
</code></pre>
<p>homework6.8.cpp</p>
<pre><code>#include &quot;chapter6.h&quot;

int factorial(int fact) {
	int sum = 1;
	while (fact)
		sum *= fact--;
	return sum;
}
</code></pre>
<p>6.1.3<br>
分离式编译允许我们把程序分割到几个文件中去，每个文件相互独立<br>
如果我们修改了某个源文件，只需要单独编译改动了的文件生成对象代码文件<br>
分离式编译会产生对象代码文件<br>
最后再把对象文件链接到一起形成可执行文件</p>
<p>习题6.9<br>
其实6.8中已经完成了这个任务，homework6.8对应于fact.cc 。</p>
<p>6.2参数传递<br>
如果形参是引用类型，实参被引用传递（传引用调用）。当形参非引用类型，实参的值拷贝给形参，实参被值传递（传值调用）<br>
6.2.1<br>
拷贝传递不会影响实参的值，但指针形参可以修改所指向的对象的值<br>
在c++语言中建议使用引用类型的形参</p>
<p>习题6.10</p>
<pre><code>int swap_p(int *p1, int *p2);

int main() {
	int i1 = 0, i2 = 1;
	cout &lt;&lt; i1 &lt;&lt; ' ' &lt;&lt; i2 &lt;&lt; endl;
	int *i1p = &amp;i1, *i2p = &amp;i2;
	swap_p(i1p, i2p);
	cout &lt;&lt; i1 &lt;&lt; ' ' &lt;&lt; i2 &lt;&lt; endl;
	return 0;
};

int swap_p(int *p1,int *p2) {
	 *p1 = *p1 + *p2;
	 *p2 = *p1 - *p2;
	 *p1 = *p1 - *p2;
	 return 1;
}
</code></pre>
<p>6.2.2<br>
<strong>使用引用可以避免对大的类或者容器对象进行拷贝</strong><br>
如果无需改变形参的值，<strong>最好将其声明为常量引用</strong><br>
可以使用引用类型的形参返回额外信息</p>
<p>习题6.11</p>
<pre><code>int main() {
	int i = 1;
	cout &lt;&lt; i &lt;&lt; endl;
	reset(i);
	cout &lt;&lt; i &lt;&lt; endl;
	return 0;
};

void reset(int &amp;p) {
	p = 0;
}
</code></pre>
<p>习题6.12</p>
<pre><code>int main() {
	int i1 = 0, i2 = 1;
	cout &lt;&lt; i1 &lt;&lt; ' ' &lt;&lt; i2 &lt;&lt; endl;
	int &amp;i1p = i1, &amp;i2p = i2;
	swap_p(i1p, i2p);
	cout &lt;&lt; i1 &lt;&lt; ' ' &lt;&lt; i2 &lt;&lt; endl;
	return 0;
};

int swap_p(int &amp;p1, int &amp;p2) {
	p1 = p1 + p2;
	p2 = p1 - p2;
	p1 = p1 - p2;
	return 1;
}
</code></pre>
<p>非常明显 引用更加好用。免去了*字符和&amp;字符的繁杂<br>
习题6.13<br>
一个是传值调用，一个是传引用调用，前者只是拷贝副本，后者可以通过引用更改原值<br>
习题6.14<br>
比如对两个矩阵进行比较，矩阵值特别大时再进行传值会导致内存不足，同时iostream等输入输出流是不可以拷贝的。如果不想修改原变量的值，就不应该使用引用。<br>
习题6.15<br>
我们不希望s被拷贝，也不希望s被修改，所以使用const &amp;，occur会被修改，所以用普通引用，我们不希望函数通过c的值来修改原值，所以不使用引用。否则s会被修改，occur无法递增</p>
<p>6.2.3<br>
指向常量的指针也可以指向非常量，只是不能解引用赋值，<strong>也不能赋值给普通指针</strong>。常量指针不能改变指针的值，<strong>但是可以解引用赋值</strong><br>
当实参初始化形参时会忽略顶层const，所以当形参有顶层const时，传给它常量对象或者非常量对象都可以（但实参的顶层const不会被忽略）<br>
在函数定义或者声明的过程中，因为顶层const被忽略了，所以形参中的const int和  int没有区别，编译器会认为重复了（<strong>但是在函数体中仍然不能改变const形参的值</strong>）<br>
非常量引用形参的<strong>两个问题</strong>：<br>
1.形参为<strong>int引用</strong>时，只能传入int类型的对象，不能用字面值、求值结果为int的表达式、需要转换的对象或者<strong>const int类型</strong>的对象，但** 常量引用可以使用字面值**，所以建议使用常量引用<br>
2.在函数内部使用形参作为另外一个函数的形参时，需要注意引用类型是否一致，例如：</p>
<pre><code>void fun1(const int &amp;param){
	fun2(param);//void fun2(int &amp; param)时错误，**int&amp;只接受普通引用 **
}
</code></pre>
<p>所以尽可能使用常量引用</p>
<p>习题6.18<br>
（a）<code>bool compare(matrix &amp;m1,matrix&amp;m2);</code><br>
（b）<code>vector&lt;int&gt;::iterator change_val(int i,vector&lt;int&gt;::iterator i_v);</code><br>
习题6.19<br>
（a）不合法，形参数目不对<br>
（b）合法<br>
（c）合法，有隐式转换<br>
（d）合法，有隐式转换<br>
习题6.20<br>
常量引用：不希望拷贝传值和被改动。普通引用的话原值可能会被改动。</p>
<p>6.2.4<br>
数组两个特殊性质，1.<strong>不允许拷贝数组</strong>2.使用数组名时通常会将其转换成指针<br>
所以函数传递数组时实际上传递的是指向数组首元素的指针<br>
1.Int* a   2.int a[]     3.int a[10]   这三个形参实际上是一样的，都等同于第一个<br>
管理指针形参<br>
1.使用结束标记间接指定数组长度，比如c风格字符串结尾的空字符 例如while(<em>cp)指向结尾空字符就会结束<br>
2.使用标准库规范 传递指向数组首尾元素的指针 int a[10];begin(a),end(a);<br>
3.显式传递一个表示数组大小的形参 end(a)-begin(a);<em><em>sizeof(a)/sizeof(<em>a)</em></em><br>
数组引用形参定义过程中，</em><em>&amp;arr两端的括号不可以少</em></em>，但数组引用形参一开始就需要确定数组大小 (&amp;arr)[10]；数组的引用 &amp;arr[10]；错误，没有数组的引用</p>
<p>习题6.21</p>
<pre><code>int compare(int p1, int *p2);

int main() {
	int i1,i2;
	cout &lt;&lt; &quot;please input two number:&quot;;
	cin &gt;&gt; i1 &gt;&gt; i2;
	cout &lt;&lt; &quot;the larger one is &quot;;
	int *i1p = &amp;i1, *i2p = &amp;i2;
	cout &lt;&lt; compare(i1, i2p) &lt;&lt; endl;
	return 0;
};

int compare(int p1, int *p2) {
	return p1&gt;*p2?p1:*p2;
}
</code></pre>
<p>习题6.22</p>
<pre><code>int main() {
	int i1,i2;
	cout &lt;&lt; &quot;please input two number:&quot;;
	cin &gt;&gt; i1 &gt;&gt; i2;
	int *i1p = &amp;i1, *i2p = &amp;i2;
	cout &lt;&lt; *i1p &lt;&lt; ' ' &lt;&lt; *i2p &lt;&lt; endl;
	swap_p(i1p, i2p);
	cout &lt;&lt; *i1p &lt;&lt; ' ' &lt;&lt; *i2p &lt;&lt; endl;
	return 0;
};

void swap_p(int *&amp;p1, int *&amp;p2) {
	int *temp = p1;
	p1 = p2;
	p2 = temp;
}
</code></pre>
<p>习题6.23</p>
<pre><code>int main() {
	int j[2] = { 0,1 };
	int i = 0;
	auto j_b = begin(j);
	auto j_e = end(j);
	print(i);
	print(j_b, j_e);
	return 0;
};

void print(const int&amp; i) {
	cout &lt;&lt; i &lt;&lt; endl;
}
void print(int *beg,int *end) {
	while (beg != end)
		cout &lt;&lt; *beg++ &lt;&lt; endl;

}
</code></pre>
<p>习题6.24<br>
程序希望逐个输出数组ia的元素，但是形参没有使用引用或指针，数组是无法直接拷贝给形参的！！！所以传递的仅仅是头指针</p>
<p>6.2.5<br>
int main(int argc,char *argv[]){….}<br>
main处理命令行选项，argc表示变量的数量，argv[0]保存程序的名字，可选实参从argv[1]开始</p>
<p>习题6.25&amp;.26</p>
<pre><code>int main(int argc,char* argv[]) {
	string s;
	for (int i = 1; i &lt; argc; ++i)
		s = s + argv[i];
	cout &lt;&lt; s &lt;&lt; endl;
};
</code></pre>
<p>知识点：string的向量可以用 string+=char，特别是string为空的时候，不能直接string=char+char，第一个必须是string。</p>
<p>6.2.6<br>
<strong>函数的实参数量未知但类型相同</strong>，可以使用initializer_list类型的形参，这是一种标准库类型，用于表示某种特定类型的值的数组，<strong>和vector一样也是一种模版类型，但其对象中的元素永远是常量值，无法改变元素的值</strong>（元素值是const）<br>
向initializer_list形参传递一个值的序列的时候，必须把序列放在<strong>一对花括号内</strong></p>
<p>习题6.27</p>
<pre><code>int add_list(initializer_list&lt;int&gt; i);

int main(int argc,char* argv[]) {
	initializer_list&lt;int&gt; i{ 1,2,3,4,5,6,7 };
	cout &lt;&lt; add_list(i) &lt;&lt; endl;
};

int add_list(initializer_list&lt;int&gt; i) {
	int sum = 0;
	for (auto num : i)
		sum += num;
	return sum;
}
</code></pre>
<p>习题6.28<br>
elem的类型为const string&amp;<br>
习题6.29<br>
应该，因为initailizer_list的对象都是const值，使用引用可以避免拷贝和修改，但是要注意配合auto使用（实测加了auto &amp;，会自动加上const）</p>
<p>习题感悟：<br>
不要忽略了函数的声明！<br>
数组是无法直接拷贝给形参的！！！<br>
string的向量可以用 string+=char，特别是string为空的时候，不能直接string=char+char，第一个必须是string。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组217. 存在重复元素]]></title>
        <id>https://lixin-ee.github.io//post/217-cun-zai-chong-fu-yuan-su</id>
        <link href="https://lixin-ee.github.io//post/217-cun-zai-chong-fu-yuan-su">
        </link>
        <updated>2019-09-11T15:30:24.000Z</updated>
        <content type="html"><![CDATA[<p>题目：</p>
<blockquote>
<p>给定一个整数数组，判断是否存在重复元素。<br>
如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</p>
<p>示例 1:<br>
输入: [1,2,3,1]<br>
输出: true<br>
示例 2:<br>
输入: [1,2,3,4]<br>
输出: false<br>
示例 3:<br>
输入: [1,1,1,3,3,4,3,2,4,2]<br>
输出: true<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/contains-duplicate<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>今天看了一天STL的hashtable，看得有点愣愣的，不过确实是牛逼，没想到这道题就用上了hhhh，非常适合用哈希map，把每个值作为key，再把出现次数作为mapped_value进行递增，第一次给出的代码如下：</p>
<pre><code>class Solution {
public:
    bool containsDuplicate(vector&lt;int&gt;&amp; nums) {
        int len = nums.size();
        if(len==0||len==1)
            return false;
        map&lt;int,int&gt; nums_map;
        for(auto i:nums)
            if(nums_map.find(i)==nums_map.end())
                nums_map.insert({i,1});
            else
                ++nums_map[i];
        for(auto i=nums_map.begin();i!=nums_map.end();++i)
            if(i-&gt;second&gt;1)
                return true;
        return false;
        
    }
};
</code></pre>
<p>依赖于STL的强大，毫无疑问地一次过啦hhh，但是花的时间比较长，所以打算看一下官方题解中hashmap的解答：</p>
<blockquote>
<p>方法三：哈希表 【通过】<br>
直觉<br>
利用支持快速搜索和插入操作的动态数据结构。<br>
算法<br>
从方法一中我们知道，对无序数组的查找操作的时间复杂度为 O(n)，而我们会重复调用查找操作。因此，使用搜索时间更快的数据结构将加快整个算法的速度。<br>
有许多数据结构常用作动态集合,如二进制搜索树和哈希表。这里我们需要的操作是 search 和 insert。对于平衡二叉搜索树（Java 中的 TreeSet 或 TreeMap），search 和 insert 的时间复杂度均为 O(logn)。对于哈希表（Java 中的 HashSet 或 HashMap），search 和 insert 的平均时间复杂度为 O(1)。因此，通过使用哈希表，我们可以达到在线性时间复杂度解决问题。</p>
</blockquote>
<pre><code>Java
public boolean containsDuplicate(int[] nums) {
    Set&lt;Integer&gt; set = new HashSet&lt;&gt;(nums.length);
    for (int x: nums) {
        if (set.contains(x)) return true;
        set.add(x);
    }
    return false;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 : O(n)。<br>
search() 和 insert() 各自使用 nn 次，每个操作耗费常数时间。<br>
空间复杂度 : O(n)。哈希表占用的空间与元素数量是线性关系。<br>
注意<br>
对于一些特定的 n 不太大的测试样例，本方法的运行速度可能会比方法二更慢。这是因为哈希表在维护其属性时有一些开销。要注意，程序的实际运行表现和 Big-O 符号表示可能有所不同。Big-O 只是告诉我们在 充分 大的输入下，算法的相对快慢。因此，在 nn 不够大的情况下， O(n) 的算法也可以比 O(nlogn)的更慢。</p>
</blockquote>
<p>看官方题解还是开卷有益的，我的源代码问题在于需要遍历两次，但是经过官方题解的指点获得了很好的灵感，c++的hashmap会返回一对pair，前者是迭代器，后者则是bool值，正好用于返回，所以在插入阶段只要出现插入失败（重复）就可以直接返回pair的second值作为结果了，非常简单暴力，结果也是一次通过，节省了很多时间。下面为修改后的最后代码：</p>
<pre><code>class Solution {
public:
    bool containsDuplicate(vector&lt;int&gt;&amp; nums) {
        int len = nums.size();
        if(len==0||len==1)
            return false;
        map&lt;int,int&gt; nums_map;
        for(auto i:nums)
            if(!nums_map.insert({i,1}).second)
                return true;
        return false;
        
    }
};
</code></pre>
<p>然后来看看剩下的两个官方题解吧，毕竟hashmap属于STL的拿来即用，属于前人栽树后人乘凉，面试的时候直接写个hashmap不知道会不会被打死，同时在前面我也说到过其实不太喜欢用hashmap，毕竟做算法就是要理解背后的原理，一个好算法应该是通用性高的泛型算法。</p>
<blockquote>
<p>方法一：朴素线性查找 【超时】<br>
直觉<br>
对于一个有 nn 个整数的数组，一共有n(n+1)/2 对整数。因此，我们可以对所有的<br>
对进行检测，看它们是否相同。<br>
算法<br>
为了实现这个思路，我们使用线性查找算法，这是最简单的查找算法。线性查找是一种检查特定值是否在列表中的算法，做法是依次逐个检查列表中的元素，直到找到满足的元素。<br>
对于本问题，我们循环遍历全部 n 个数。对于第 i 个整数 nums[i]，我们对前 i-1 个整数查找 nums[i] 的重复值。若找到，则返回 True; 否则继续。在程序最后，返回 False。<br>
为了证明算法的正确性，我们定义了循环不变式。循环不变式是指在每次迭代前和后均保持不变的性质。了解循环不变式对理解循环的意义十分重要。下面就是循环不变式:<br>
在下一次搜索之前,搜索过的整数中没有重复的整数。<br>
循环不变式在循环之前为真，因为还没有搜索过的整数。每次循环，我们查找当前元素的任何可能重复。如果发现重复项,则函数返回 True 退出；如果没有发现，则不变式仍然成立。<br>
因此，如果循环结束，循环不变式说明全部 nn 个整数中不存在重复元素。</p>
</blockquote>
<pre><code>Java
public boolean containsDuplicate(int[] nums) {
    for (int i = 0; i &lt; nums.length; ++i) {
        for (int j = 0; j &lt; i; ++j) {
            if (nums[j] == nums[i]) return true;  
        }
    }
    return false;
}
// Time Limit Exceeded
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 : O(n<sup>2)。最坏的情况下，需要检查n(n+1)/2对整数。因此，时间复杂度为O(n</sup>2 )。<br>
空间复杂度 : O(1)。只使用了常数额外空间。<br>
注意<br>
本方法在 Leetcode 上会超时。一般而言，如果一个算法的时间复杂度为 O(n<br>
^2 )，它最多能处理 n 大约为 10^4 的数据。当 n 接近 10^5时就会超时。</p>
<p>方法二：排序 【通过】<br>
直觉<br>
如果存在重复元素，排序后它们应该相邻。<br>
算法<br>
本方法使用排序算法。由于比较排序算法，如堆排序，可以在最坏情况下具有O(nlogn) 的时间复杂度。因此，排序经常是很好的预处理方法。排序之后，我们可以扫描已排序的数组,以查找是否有任何连续的重复元素。</p>
</blockquote>
<pre><code>Java
public boolean containsDuplicate(int[] nums) {
    Arrays.sort(nums);
    for (int i = 0; i &lt; nums.length - 1; ++i) {
        if (nums[i] == nums[i + 1]) return true;
    }
    return false;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 : O(nlogn)。<br>
排序的复杂度是 O(nlogn)，扫描的复杂度是 O(n)。整个算法主要由排序过程决定，因此是 O(nlogn)。<br>
空间复杂度 : O(1)。<br>
这取决于具体的排序算法实现，通常而言，使用 堆排序 的话，是 O(1)O(1)。<br>
注意<br>
此处的算法实现对原始数组进行排序，修改了原始数组。通常，除非调用方清楚输入数据将被修改，否则不应该随意修改输入数据。可以先复制 nums，然后对副本进行操作。</p>
</blockquote>
<p>嗯....这两个官方题解都只能说是差强人意呀，第一个直接是比较了，太暴力了吧...不过循环不变式的思想还是挺有趣的，第二个也仅仅是使用了快速排序、堆排序等时间复杂度下限的排序函数，代码也有点敷衍了，直接上了Java的函数，所以这一次就当做是hashmap的小试牛刀吧，hhh还真的是牛刀。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 275. H指数 II]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-275-h-zhi-shu-ii</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-275-h-zhi-shu-ii">
        </link>
        <updated>2019-09-11T11:13:27.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目如下：<br>
给定一位研究者论文被引用次数的数组（被引用次数是非负整数），数组已经按照升序排列。编写一个方法，计算出研究者的 h 指数。<br>
h 指数的定义: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）至多有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数不多于 h 次。）&quot;</p>
<p>示例:<br>
输入: citations = [0,1,3,5,6]<br>
输出: 3<br>
解释: 给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 0, 1, 3, 5, 6 次。<br>
     由于研究者有 3 篇论文每篇至少被引用了 3 次，其余两篇论文每篇被引用不多于 3 次，所以她的 h 指数是 3。<br>
说明:<br>
如果 h 有多有种可能的值 ，h 指数是其中最大的那个。<br>
进阶：<br>
这是 H指数 的延伸题目，本题中的 citations 数组是保证有序的。<br>
你可以优化你的算法到对数时间复杂度吗？<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/h-index-ii<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>其实这道题和昨天的一毛一样，重点在于给出的数组已经是有序数组，而且在题目中很明显暗示我们达到对数时间复杂度，所以需要在时间复杂度上下功夫，昨天的答案是不能用的了。<br>
一开始我的想法就是既然排好序了，数组的序号和数组的数值之间就有了相对应的关系，只需要比较（数组长度-序号)和数值就可以了，而且从示例中可以看出，答案一般都处于中段，或者是某部分的中段，同时对数时间复杂度，和二叉树的深度可以对应起来，所以第一时间就想到了二分法，下面是一开始的代码（注意，本次是未通过的代码！）</p>
<pre><code>class Solution {
public:
    int hIndex(vector&lt;int&gt;&amp; citations) {
        if(!citations.size())
            return 0;
        int sum=0;
        int h=0;
        bool flag=true;
        int beg=0,end=citations.size()-1;
        if (!end){
            return citations[0]?1:0;
        }
        do{
        int midd = (beg+end)/2;
        if(citations.size()-midd&gt;citations[midd]){
            beg = midd;
            h = midd+1;
        }
        else if(citations.size()-midd==citations[midd]){
            h = midd+1;
            flag=false;
        }else
            flag=false;            
        }while(flag); 
        return h;
    }
};
</code></pre>
<p>代码中有很多问题，不过主要的问题还是取中值和左半边的问题，取中值的时候一直在纠结是取右中值还是左中指，最后选择左中指后还需要对结果进行+1。然后就是对数组的判断，只考虑了左半边（长度大于数值）的问题，没有考虑到右半边的问题，所以导致结果一直错误（还有一开始的空数组、{0}零数组的问题没有考虑好）<br>
最后直接看了网友题解，为什么呢，因为一开始以为二分法错了...结果打开题解发现大家都是用的二分法啊...所以还是基础不够扎实，还是得老老实实做题，下面是网友题解：</p>
<blockquote>
<p>方法：二分查找<br>
思路分析：<br>
题目中说到：<br>
本题中的 citations 数组是保证有序的。<br>
并且还暗示<br>
你可以优化你的算法到对数时间复杂度吗？<br>
因此，可以使用二分查找法。二分查找这种非对即错的问题，我也经常栽跟头，我个人觉得根据示例分析应该是一个不错的方法。<br>
不知道大家有没有这种感觉，就是代码有的时候稀里糊涂就写对了，我想应该是方法对了，可能出错的地方就是一些边界条件吧。<br>
就根据示例 citations = [0, 1, 3, 5, 6]。<br>
中位数是 3 ，citations[3] 恰好也等于 3，这个 3 正好是边界，不太好分析 ，我把中位数改成了 2。<br>
即：citations = [0, 1, 2, 5, 6]。此时根据题目意思，此时索引为 2 的那篇论文就不能被记入 h 指数（因为，如果算进去，则有 3 篇论文，但是这篇最少被引用的文章才被引用 2 次）。<br>
因此，我们分析出 h 指数和以下两个指标有关：<br>
1、某个索引 i 的 citations 的数值；<br>
2、某个索引 i 到 citations 的末尾索引的长度，即区间 [i, len - 1] 的长度，即 len - 1 - i + 1 = len - i。<br>
根据被我把中位数改成 2 的示例，如果 nums[i] &lt; len - i ，索引 i 必须后移一位，因此候选区间为 [i + 1, len - 1]，根据“二分搜索模板”可知 left = i + 1，那 nums[i] &lt; len - i 的反面一定是 mid = right，看到 left = i + 1 可知分支排除了中位数，因此默认选择左中位数是对的（不会死循环）。<br>
提交以后，发现测试用例 [0] 不能通过，想想的确有可能出现这种情况，万一这一位学者的诸多文章还没有被人引用过，h 指数就为 0 了，所以单独判断一下即可。<br>
最后，返回的是区间的长度，根据刚才的分析，这个值是 len - i。因此，本题使用二分查找法，找到 i 即可。<br>
来自用户 @coder_hezi 的总结：<br>
要返回选取的区间的长度，而选取的区间要满足区间中的数大于等于所在区间的长度。<br>
参考代码：</p>
</blockquote>
<pre><code>Java
public class Solution {
    // 思路：看 nums[mid] 和区间 [mid, len - 1] 的长度，即 len - mid - 1 + 1 = len - mid
    // 要返回的是 nums 中的值
    // [0,1,2,5,6]，
    // 以下的代码注释是 coder_hezi 帮助添加的，在此表示感谢
    public int hIndex(int[] citations) {
        int len = citations.length;
        // 特判
        if (len == 0 || citations[len - 1] == 0) {
            return 0;
        }
        int left = 0;
        int right = len - 1;
        while (left &lt; right) {
            int mid = (left + right) &gt;&gt;&gt; 1;
            // 比长度小，就得去掉该值
            if (citations[mid] &lt; len - mid) {
                left = mid + 1;
            } else {
                // 比长度大是满足的，我们应该继续让 mid 往左走去尝试看有没有更小的 mid 值
                // 可以满足 mid 对应的值大于等于从 [mid, length - 1] 的长度
                right = mid;
            }
        }
        return len - left;
    }
    public static void main(String[] args) {
        int[] citations = {0, 1, 2, 5, 6};
        Solution solution = new Solution();
        int hIndex = solution.hIndex(citations);
        System.out.println(hIndex);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(logN)，这里 N是数组的长度。<br>
空间复杂度：O(1)，使用到的变量都只有常数个。</p>
</blockquote>
<p>解题思路还是很清晰的，最重要的还是在于中值的选择和mid的处理，本题目中中值选择左中指，mid赋予给right或者把mid+1赋予给left，从而使得特殊情况比如{0，1}能够得到正确答案，同时特殊情况的判断很重要，例如{0，0}这种极端情况， citations[len - 1] == 0能够很好地消除这种情况</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++避坑]]></title>
        <id>https://lixin-ee.github.io//post/cbi-keng</id>
        <link href="https://lixin-ee.github.io//post/cbi-keng">
        </link>
        <updated>2019-09-11T04:07:17.000Z</updated>
        <content type="html"><![CDATA[<p>cout不明确：<br>
将using namespace std; 删除后保存cpp文件，<br>
再加上using namespace std;保存cpp文件。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ C++ primer 第五章 笔记+习题]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-wu-zhang-bi-ji-xi-ti</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-wu-zhang-bi-ji-xi-ti">
        </link>
        <updated>2019-09-11T01:06:33.000Z</updated>
        <content type="html"><![CDATA[<p>5.1-5.3.1<br>
空语句 用在需要语法上需要的地方， 比如while ，空语句最好加上注释<br>
复合语句 也称作块，一个块就是一个作用域。<br>
复合语句用在语法上只能一条语句但是逻辑上需要多条语句的地方，比如while和for<br>
注意while和for本来只能容纳一条语句，所以要用 { }</p>
<p>习题5.1<br>
空语句就是只有一个单独的分号的语句，什么也不执行。主要是用于语法上需要一条语句但是逻辑上不需要的地方，比如while和for循环头完成了所有操作的话，循环体就需要一个空语句<br>
习题5.2<br>
块也就是复合语句，是指用花括号括起来的语句和声明的序列。如果在语法上只能容纳一条语句但是逻辑上需要多条语句的话，就应该使用块，例如while和for的循环体<br>
习题5.3<br>
while（val&lt;=10） sum+=val,++val;<br>
可读性提高了<br>
知识点：可以用逗号运算符使得比较简短的循环体变成一句话<br>
习题5.4<br>
（a）while循环头可以进行定义，但是不应该进行定义，否则每次循环都会定义一次，如果没有显式的break就会形成死循环<br>
（b）在while循环头进行定义的变量作用域只在while循环块内，if是无法使用status的<br>
习题5.5</p>
<pre><code>int main() {
	int grade;
	const vector&lt;string&gt; level{ &quot;A+&quot;,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot; };
	cin &gt;&gt; grade;
	if (grade == 100)
		cout &lt;&lt; level[0];
	else if (grade &gt;= 90)
		cout &lt;&lt; level[1];
	else if (grade &gt;= 80)
		cout &lt;&lt; level[2];
	else if (grade &gt;= 70)
		cout &lt;&lt; level[3];
	else if (grade &gt;= 60)
		cout &lt;&lt; level[4];
	else
		cout &lt;&lt; level[5];
};
</code></pre>
<p>习题5.6</p>
<pre><code>int main() {
	int grade;
	const vector&lt;string&gt; level{ &quot;A+&quot;,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot; };
	cin &gt;&gt; grade;
	cout &lt;&lt; ((grade &lt; 60) ? level[5] : (grade &lt; 70) ? level[4] : (grade &lt; 80) ? level[3] : (grade &lt; 90) ? level[2] : (grade &lt;100) ? level[1] : level[0]);
};
</code></pre>
<p>知识点:条件运算符的优先级实在是太低了。。。连&lt;&lt;都不如，一定要加括号<br>
习题5.7<br>
（a）没有加分号<br>
（b）没有加花括号，没法形成块<br>
（c）ival定义在while循环头，作用域只在while内部<br>
（d）==号和=号的差别特别大， 虽然合法，但是循环达不到预期效果。<br>
习题5.8<br>
悬垂else是指if的数量大于else的数量，容易造成二义性，从而规定else与离它最近的尚未匹配的if进行匹配。</p>
<p>5.3.2<br>
switch语句中case标签必须是<strong>整形</strong>常量表达式（3 或者 ‘a’） 3.14或者 int 型都不行，除了default<br>
任何两个<strong>case标签不能相同</strong><br>
两个case标签之间要有break语句，<strong>否则会连续执行</strong>接下来的case<br>
无break语句应该备注注释<br>
default语句就算为空也应该定义<br>
每个标签都应该跟上一条语句、空语句或者空块<br>
在case语句中 <strong>不能进行变量的初始化，但可以进行变量的定义</strong>。<br>
最好在case内定义一个块，再定义并初始化变量，保证其他case都在作用域外</p>
<p>习题5.9</p>
<pre><code>int main() {
	string s;
	while (cin &gt;&gt; s) {
		int num = 0;
		for (auto letter : s)
			switch (letter)
			{
			case 'a': {++num; break; }
			case 'i': {++num; break; }
			case 'o': {++num; break; }
			case 'u': {++num; break; }
			case 'e': {++num; break; }
			default:break;
			}
		cout &lt;&lt; &quot;num is &quot; &lt;&lt; num&lt;&lt;endl;
	}
};
</code></pre>
<p>习题5.10</p>
<pre><code>int main() {
	string s;
	while (cin &gt;&gt; s) {
		int num = 0;
		for (auto letter : s)
			switch (letter)
			{
			case'A': case 'a': {++num; break; }
			case'I': case 'i': {++num; break; }
			case'O': case 'o': {++num; break; }
			case'U': case 'u': {++num; break; }
			case'E': case 'e': {++num; break; }
			default:break;
			}
		cout &lt;&lt; &quot;num is &quot; &lt;&lt; num&lt;&lt;endl;
	}
};
</code></pre>
<p>习题5.11</p>
<pre><code>int main() {
	char s;
	int num = 0;
	int space = 0, tab = 0, enter = 0;
	while (cin&gt;&gt;noskipws&gt;&gt;s) {	
			switch (s)
			{
			case'A': case 'a': {++num; break; }
			case'I': case 'i': {++num; break; }
			case'O': case 'o': {++num; break; }
			case'U': case 'u': {++num; break; }
			case'E': case 'e': {++num; break; }
			case' ': {++space; break; }
			case'\t': {++tab; break; }
			case'\n': {++enter; break; }
			default:break;
			}
	}
	cout &lt;&lt; &quot;num is &quot; &lt;&lt; num &lt;&lt; endl;
	cout &lt;&lt; &quot;space is &quot; &lt;&lt; space &lt;&lt; endl;
	cout &lt;&lt; &quot;tab is &quot; &lt;&lt; tab &lt;&lt; endl;
	cout &lt;&lt; &quot;enter is &quot; &lt;&lt; enter &lt;&lt; endl;
};
</code></pre>
<p>知识点：注意此处不能再用string了 string的逐个字母判断遇到空格等字符就会停止。。。只能用char一个一个读入。<br>
习题5.12</p>
<pre><code>int main() {
	string s;
	int ff = 0, fl = 0, fi = 0;
	while (cin &gt;&gt; s) {
		for (int i = 0; i &lt; s.size() - 1; ++i) {
			auto letter = s[i];
			switch (letter)
			{
			case 'f': {
				switch (s[i + 1])
				{
				case 'f': {++ff; break; }
				case 'l': {++fl; break; }
				case 'i': {++fi; break; }
				default:
					break;
				}
			}
			default:break;
			}
		}
	}
	cout &lt;&lt; &quot;ff is &quot; &lt;&lt; ff &lt;&lt; endl;
	cout &lt;&lt; &quot;fl is &quot; &lt;&lt; fl &lt;&lt; endl;
	cout &lt;&lt; &quot;fi is &quot; &lt;&lt; fi &lt;&lt; endl;
};
</code></pre>
<p>习题5.13<br>
（a）case直接没有break，会连续执行<br>
（b）在case语句中 不能进行变量的初始化<br>
（c）不能在同一语句中定义多个case标签<br>
（d）case后面的ival、jval等并非常量</p>
<p>5.4.1<br>
while的条件语句中可以是表达式或者带初始化的变量声明<br>
while 内部的变量（条件部分或循环体内）<strong>每次迭代都会经历创建到销毁</strong><br>
while循环使用1.迭代次数<strong>不确定</strong> 2. <strong>需要在循环结束后访问循环控制变量</strong></p>
<p>习题5.14</p>
<pre><code>int main() {
	string s;
	string s_b;
	int num=0;
	int lab=0;
	cin &gt;&gt; s;
	s_b = s;
	while (cin &gt;&gt; s) {
		if (s_b == s)
			++num, ++lab;
		else if (num)
			cout &lt;&lt; s_b &lt;&lt; &quot; occur &quot; &lt;&lt; num+1 &lt;&lt; &quot; time &quot; &lt;&lt; endl, s_b = s, num = 0;
		else
			s_b = s, num = 0;
	}
	if (!lab)
		cout &lt;&lt; &quot;no same words occur&quot; &lt;&lt; endl;
};
</code></pre>
<p>5.4.2<br>
for语句中init-statement必须是声明语句、表达式语句或者空语句<br>
for语句开始循环时init-statement执行后i<strong>立即判断一次condition</strong><br>
<strong>init-statement中定义的对象只在for循环体内可见 **<br>
init-statemen 可以定义多个对象，但是只能有一条声明语句，所以</strong>所有变量的基础类型必须相同**<br>
for 语句头中的内容都能省略</p>
<p>习题5.15<br>
（a）循环头定义的变量的作用域只在循环体，if无法调用ix<br>
（b）循环判断可以省略，但是分号；不可以省略<br>
（c）两者同时在增长，除非循环体内部有其他控制，否则陷入死循环<br>
习题5.16<br>
其实前面用得很多，就得根据情况而定，甚至有时候使用do while都更加方便<br>
习题5.17</p>
<pre><code>int main() {
	vector&lt;int&gt; v1;
	vector&lt;int&gt; v2;
	int len = (v1.size() &lt; v2.size() ? v1.size() : v2.size());
	int i = 0;
	for (; i &lt; len; ++i)
		if (v1[i] != v2[i])
			return -1;
	return 1;	
};
</code></pre>
<p>5.4.3<br>
范围For 语句<br>
Expression 表示的必须是一个<strong>序列</strong><br>
比如花括号括起来的初始值列表、数组、vector 、string ，这些类型的共同特点是<strong>拥有能返回迭代器的begin和end成员</strong><br>
5.4.4<br>
do while语句 至少执行一次循环<br>
<strong>不允许在条件部分定义变量，否则变量使用出现在定义之前</strong><br>
do while在<strong>循环体内定义的变量也无法在条件部分使用</strong><br>
do while 的while<strong>条件部分后应该有；号</strong></p>
<p>习题5.18<br>
（a）do后面需要使用块语句<br>
（b）do while在循环判断中定义的变量是没有意义的<br>
（c）do while 在循环体中定义的变量也没法给循环判断使用<br>
习题5.19</p>
<pre><code>int main() {
	string s1, s2;
	do {
		cin &gt;&gt; s1 &gt;&gt; s2;
		string output = s1.size() &lt; s2.size() ? s1 : s2;
		cout &lt;&lt; &quot;the shorter is &quot; &lt;&lt; output &lt;&lt; endl;
	}
	while (cin);
};
</code></pre>
<p>5.5.1 break语句<br>
终止离它<strong>最近</strong>的while，do while，for，switch语句</p>
<p>习题5.20</p>
<pre><code>int main() {
	string s, s_b;
	int flag=0;
	cin &gt;&gt; s;
	s_b = s;
	do {
		cin &gt;&gt; s;
		if (s_b == s) {
			++flag; 
			break;
		}
		s_b = s;
	}
	while (cin);
	if (!flag)
		cout &lt;&lt; &quot;no same word&quot; &lt;&lt; endl;
	else
		cout &lt;&lt; s_b &lt;&lt; &quot; is the same word&quot;&lt;&lt;endl;
};
</code></pre>
<p>5.5.2 continue语句<br>
不能用于switch</p>
<p>习题5.21</p>
<pre><code>int main() {
	string s, s_b;
	int flag=0;
	cin &gt;&gt; s;
	s_b = s;
	do {
		cin &gt;&gt; s;
		if (s_b == s) 
			if(s[0]&gt;='A'&amp;&amp;s[0] &lt;= 'Z'){
			++flag; 
			break;
			}
			else
				continue;
		s_b = s;
	}
	while (cin);
	if (!flag)
		cout &lt;&lt; &quot;no same word&quot; &lt;&lt; endl;
	else
		cout &lt;&lt; s_b &lt;&lt; &quot; is the same word&quot;&lt;&lt;endl;
};

</code></pre>
<p>5.5.3goto语句<br>
不建议使用<br>
带标签语句<br>
标签标示符 独立于变量和其他标示符名字 可以和其他标示符使用同一个名字</p>
<p>习题5.22</p>
<pre><code>for（int sz =get_size()；sz&lt;=0；）
	sz =get_size()；
</code></pre>
<p>5.6<br>
throw表达式 表示异常检测部分遇到了无法处理的问题<br>
try语句块 用于处理异常 以一个或多个catch语句结束<br>
catch语句 异常处理代码<br>
异常类 用于在throw和catch语句之间传递异常的具体信息<br>
5.6.1<br>
标准库异常类型定义在stdexcept头文件中 需要添加std：：前缀<br>
throw表达式 throw errorstyle（）；<br>
例子 throw std::runtime_error(“错误信息”) //例如(“data must refer to same ISBN”)<br>
runtime_error对象需要使用string对象或者c风格字符串进行初始化<br>
5.6.2<br>
Try{ 正常逻辑<br>
}catch (异常声明){异常处理<br>
}<br>
每个标准库异常类都定义了名为what的成员函数，没有参数，返回值是c风格字符串, const char*,使用例子：</p>
<pre><code>try {
		if (j == 0)
			throw runtime_error(&quot;j cannot be zero&quot;);
		cout &lt;&lt; &quot;result is &quot; &lt;&lt; i / j &lt;&lt; endl;
	}
	catch (runtime_error error) {
		cout &lt;&lt; error.what() &lt;&lt; endl;
</code></pre>
<p>发生异常时,可能有多个try-catch语句的嵌套，Try语句从外到内执行，catch语句从内到外搜索，如果最终都没找到匹配的catch，程序转到terminate标准库函数<br>
5.6.3<br>
exception，bad_alloc，bad_cast异常类型的对象只能默认初始化不能提供初始值，其他的需要用string或c风格字符串初始化，不允许用默认初始化<br>
异常类型只定义了一个what成员函数，提供关于异常的文本信息</p>
<p>习题5.23</p>
<pre><code>int main() {
	int i, j;
	cin &gt;&gt; i &gt;&gt; j;
	if (j == 0)
		throw runtime_error(&quot;j cannot be zero&quot;);
	else
		cout &lt;&lt; &quot;result is &quot; &lt;&lt; i / j &lt;&lt; endl;
};
</code></pre>
<p>习题5.24<br>
vs 显示abort() has been called<br>
习题5.25</p>
<pre><code>int main() {
	int i, j;
	while(cin &gt;&gt; i &gt;&gt; j)
	try {
		if (j == 0)
			throw runtime_error(&quot;j cannot be zero&quot;);
		cout &lt;&lt; &quot;result is &quot; &lt;&lt; i / j &lt;&lt; endl;
	}
	catch (runtime_error error) {
		cout &lt;&lt; error.what() &lt;&lt; endl;
		cout &lt;&lt; &quot;whether you want to continue?[y/n]&quot;;
		string s;
		cin &gt;&gt; s;
		if (s[0] == 'y')
			continue;
		else
			break;
	}	
};
</code></pre>
<p>知识点：如果try-catch语句在循环体内，在catch 语句中也可以使用continue和break；</p>
<p>习题感悟<br>
可以用逗号运算符使得比较简短的循环体变成一句话<br>
cout &lt;&lt; ((grade &lt; 60) ? level[5] level[0]);条件运算符的优先级实在是太低了。。。连&lt;&lt;都不如，一定要加括号<br>
string的逐个字母判断遇到空格等字符就会停止。。。只能用char一个一个读入。<br>
do while 的while条件部分后应该有；号</p>
<pre><code>do
		cin &gt;&gt; v1 &gt;&gt; v2;
	while (cin);
</code></pre>
<p>是正确的<br>
do while在<strong>循环体内定义的变量也无法在条件部分使用</strong><br>
continue语句 不能用于switch<br>
what（）的使用方法：其中runtime_error等是一个类型，可以对其定义变量</p>
<pre><code>try {
		if (j == 0)
			throw runtime_error(&quot;j cannot be zero&quot;);
		cout &lt;&lt; &quot;result is &quot; &lt;&lt; i / j &lt;&lt; endl;
	}
	catch (runtime_error error) {
		cout &lt;&lt; error.what() &lt;&lt; endl;
</code></pre>
<p>如果try-catch语句在循环体内，在catch 语句中也可以使用continue和break；</p>
]]></content>
    </entry>
</feed>