<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2020-01-02T08:16:16.482Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[数组 88. 合并两个有序数组[简单][双指针]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-88-he-bing-liang-ge-you-xu-shu-zu-jian-dan-shuang-zhi-zhen</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-88-he-bing-liang-ge-you-xu-shu-zu-jian-dan-shuang-zhi-zhen">
        </link>
        <updated>2020-01-02T01:40:13.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。<br>
说明:<br>
初始化 nums1 和 nums2 的元素数量分别为 m 和 n。<br>
你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。<br>
示例:<br>
输入:<br>
nums1 = [1,2,3,0,0,0], m = 3<br>
nums2 = [2,5,6],       n = 3<br>
输出: [1,2,2,3,5,6]<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/merge-sorted-array<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>和stl中的merge相比主要是没有额外的空间，如果强行双指针的话会导致被覆盖的问题。<br>
我的第一想法居然是copy过去然后排序hhh 但是时间复杂度估计会爆炸<br>
第二想法是把nums1后移n位，然后merge<br>
第三想法就是希望避免后移,本来以为交换就好，但是似乎[2,5,6,0,0,0]和[1,2,3]这种就很麻烦，所以没想好<br>
卧槽！！！原来是从后往前合并！！！666啊 所以还是差一步没想到啊<br>
然后复现官方题解时发现一个坑是判断条件中必须是&gt;=begin而不能是!=begin，因为从前往后是有last这个尾后位置兜底，但是begin可没法再退一位了<br>
然后同样是begin的问题，在复现官方的从后往前时遇到一个挺恶心的点，就是如果nums2为空，官网用下标的话会指向-1下标值，而相对应地我的迭代器指向了begin之前，就必须额外先判断nums2是否为空</p>
<p>自己实现的代码：</p>
<pre><code>    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {
        for(int i=m-1;i&gt;=0;--i)
            nums1[i+n]=nums1[i];
        auto p=nums1.begin(),p1=nums1.begin()+n,p2=nums2.begin();
        while(p1!=nums1.end()&amp;&amp;p2!=nums2.end()){
            if(*p2&lt;=*p1)
                *(p++)=*(p2++);
            else
                *(p++)=*(p1++);          
        }
        if(p2!=nums2.end())
            while(p2!=nums2.end())
                *(p++)=*(p2++);
    }
</code></pre>
<p>参考官方题解实现的代码：</p>
<pre><code>class Solution {
public:
    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {
        if(nums2.empty()) return;
        auto p=nums1.end()-1,p1=p-n,p2=nums2.end()-1;   
        while(p1&gt;=nums1.begin()&amp;&amp;p2&gt;=nums2.begin()){
            if(*p1&gt;=*p2){
                *p=*p1;
                --p1;
            }else{
                *p=*p2;
                --p2;  
            }
           --p;
        }

        if(p2&gt;=nums2.begin()){
            while(p2&gt;=nums2.begin()){
            *p=*p2;
            --p2; 
            --p;
            }
        }
    }
   
};
</code></pre>
<p>然后是官方题解</p>
<blockquote>
<p>方法一 : 合并后排序<br>
最朴素的解法就是将两个数组合并之后再排序。该算法只需要一行(Java是2行)，时间复杂度较差，为O((n+m)log(n+m))。这是由于这种方法没有利用两个数组本身已经有序这一点。<br>
实现</p>
</blockquote>
<pre><code>Java
class Solution {
  public void merge(int[] nums1, int m, int[] nums2, int n) {
    System.arraycopy(nums2, 0, nums1, m, n);
    Arrays.sort(nums1);
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 : O((n+m)log(n+m))。<br>
空间复杂度 : O(1)。</p>
</blockquote>
<blockquote>
<p>方法二 : 双指针 / 从前往后<br>
一般而言，对于有序数组可以通过双指针法 达到O(n+m)的时间复杂度。<br>
最直接的算法实现是将指针p1 置为 nums1的开头， p2为 nums2的开头，在每一步将最小值放入输出数组中。<br>
由于 nums1 是用于输出的数组，需要将nums1中的前m个元素放在其他地方，也就需要 O(m) 的空间复杂度。</p>
</blockquote>
<pre><code>class Solution {
  public void merge(int[] nums1, int m, int[] nums2, int n) {
    // Make a copy of nums1.
    int [] nums1_copy = new int[m];
    System.arraycopy(nums1, 0, nums1_copy, 0, m);

    // Two get pointers for nums1_copy and nums2.
    int p1 = 0;
    int p2 = 0;

    // Set pointer for nums1
    int p = 0;

    // Compare elements from nums1_copy and nums2
    // and add the smallest one into nums1.
    while ((p1 &lt; m) &amp;&amp; (p2 &lt; n))
      nums1[p++] = (nums1_copy[p1] &lt; nums2[p2]) ? nums1_copy[p1++] : nums2[p2++];

    // if there are still elements to add
    if (p1 &lt; m)
      System.arraycopy(nums1_copy, p1, nums1, p1 + p2, m + n - p1 - p2);
    if (p2 &lt; n)
      System.arraycopy(nums2, p2, nums1, p1 + p2, m + n - p1 - p2);
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 : O(n+m)。<br>
空间复杂度 : O(m)。</p>
</blockquote>
<blockquote>
<p>方法三 : 双指针 / 从后往前<br>
方法二已经取得了最优的时间复杂度O(n+m)，但需要使用额外空间。这是由于在从头改变nums1的值时，需要把nums1中的元素存放在其他位置。<br>
如果我们从结尾开始改写 nums1 的值又会如何呢？这里没有信息，因此不需要额外空间。<br>
这里的指针 p 用于追踪添加元素的位置。<br>
实现</p>
</blockquote>
<pre><code>Java
class Solution {
  public void merge(int[] nums1, int m, int[] nums2, int n) {
    // two get pointers for nums1 and nums2
    int p1 = m - 1;
    int p2 = n - 1;
    // set pointer for nums1
    int p = m + n - 1;

    // while there are still elements to compare
    while ((p1 &gt;= 0) &amp;&amp; (p2 &gt;= 0))
      // compare two elements from nums1 and nums2 
      // and add the largest one in nums1 
      nums1[p--] = (nums1[p1] &lt; nums2[p2]) ? nums2[p2--] : nums1[p1--];

    // add missing elements from nums2
    System.arraycopy(nums2, 0, nums1, 0, p2 + 1);
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 : O(n+m)。<br>
空间复杂度 : O(1)。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ [Linux基础] 文件与文件系统的压缩, 打包与备份（鸟哥Linux第八章）]]></title>
        <id>https://lixin-ee.github.io//post/linux-ji-chu-wen-jian-yu-wen-jian-xi-tong-de-ya-suo-da-bao-yu-bei-fen-niao-ge-linux-di-ba-zhang</id>
        <link href="https://lixin-ee.github.io//post/linux-ji-chu-wen-jian-yu-wen-jian-xi-tong-de-ya-suo-da-bao-yu-bei-fen-niao-ge-linux-di-ba-zhang">
        </link>
        <updated>2020-01-01T07:23:17.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p>压缩文件的用途与技术<br>
压缩后与压缩的文件所占用的磁盘空间大小， 就可以被称为是『压缩比』</p>
</li>
<li>
<p>Linux系统常见的压缩指令<br>
在 Linux 的环境中，压缩文件案的扩展名大多是： 『* .tar, * .tar.gz, * .tgz, * .gz, * .Z, * .bz2, * .xz』，<strong>Linux 的扩展名没有什么作用，仅用于指示压缩指令</strong>，这是因为 Linux 支持的压缩指令非常多，且不同的指令所用的压缩技术并不相同，当然彼此之间可能就无法互通压缩/解压缩文件案<br>
.Z       compress 程序压缩的文件；<br>
.zip    zip 程序压缩的文件；<br>
.gz     gzip 程序压缩的文件；<br>
.bz2   bzip2 程序压缩的文件；<br>
.xz     xz 程序压缩的文件；<br>
.tar    tar 程序打包的数据，并没有压缩过；<br>
.tar.gz    tar 程序打包的文件，其中并且经过 gzip 的压缩<br>
.tar.bz2   tar 程序打包的文件，其中并且经过 bzip2 的压缩<br>
.tar.xz      tar 程序打包的文件，其中并且经过 xz 的压缩</p>
</li>
</ul>
<p>注意tar程序只是打包，而不压缩</p>
<ul>
<li>gzip, zcat/zmore/zless/zgrep<br>
[dmtsai@study ~]$  gzip [-cdtv#]  檔名<br>
[dmtsai@study ~]$  zcat  檔名 .gz<br>
选项与参数：<br>
-c ：将压缩的数据输出到屏幕上，可透过数据流重导向来处理；<br>
-d ：解压缩的参数；<br>
-t ：可以用来检验一个压缩文件的一致性～看看文件有无错误；<br>
-v ：可以显示出原文件/压缩文件案的压缩比等信息；<br>
-# ：# 为数字的意思，代表压缩等级，-1 最快，但是压缩比最差、-9 最慢，但是压缩比最好！预设是 -6</li>
</ul>
<p>使用 gzip 进行压缩时，在预设的状态下原本的文件会被压缩成为 .gz 的档名，源文件就不再存在了，这点与一般习惯使用 windows 做压缩所熟悉的情况不同、</p>
<ul>
<li>
<p>bzip2, bzcat/bzmore/bzless/bzgrep<br>
[dmtsai@study ~]$  bzip2 [-cdkzv#]  檔名<br>
[dmtsai@study ~]$  bzcat  檔名 .bz2<br>
选项与参数：<br>
-c ：将压缩的过程产生的数据输出到屏幕上！<br>
-d ：解压缩的参数<br>
-k ：保留源文件，而不会删除原始的文件喔！<br>
-z ：压缩的参数 (默认值，可以不加)<br>
-v ：可以显示出原文件/压缩文件案的压缩比等信息；<br>
-# ：与 gzip 同样的，都是在计算压缩比的参数， -9 最佳， -1 最快！</p>
</li>
<li>
<p>xz, xzcat/xzmore/xzless/xzgrep<br>
[dmtsai@study ~]$  xz [-dtlkc#]  檔名<br>
[dmtsai@study ~]$  xcat  檔名 .xz<br>
选项与参数：<br>
-d ：就是解压缩啊！<br>
-t ：测试压缩文件的完整性，看有没有错误<br>
-l ：列出压缩文件的相关信息<br>
-k ：保留原本的文件不删除～<br>
-c ：同样的，就是将数据由屏幕上输出的意思！<br>
-# ：同样的，也有较佳的压缩比的意思！</p>
</li>
<li>
<p>打包指令： tar<br>
打包与压缩<br>
[dmtsai@study ~]$  tar [-z|-j|-J] [cv] [-f  待建立的新檔名 ] filename...<br>
察看檔名<br>
[dmtsai@study ~]$  tar [-z|-j|-J] [tv] [-f  既有的 r tar  檔名 ]<br>
解压缩<br>
[dmtsai@study ~]$  tar [-z|-j|-J] [xv] [-f  既有的 r tar  檔名 ] [-C  目 录 ]</p>
</li>
</ul>
<p>其实最简单的使用 tar 就只要记忆底下的方式即可：<br>
•  压 缩：tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称<br>
•  查 询：tar -jtv -f filename.tar.bz2<br>
•  解压缩：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录</p>
<p>仅解开单一文件的方法</p>
<ol>
<li>
<p>先找到我们要的档名，假设解开 shadow 文件好了：<br>
[root@study ~]#  tar- jtv- f /root/etc.tar.bz2 | grep 'shadow'<br>
先搜寻档名，其中那个 grep 是『撷取』关键词的功能</p>
</li>
<li>
<p>将该文件解开！语法与实际作法如下：<br>
[root@study ~]#  tar-jxv -f  打包檔 .tar.bz2  待解 开档 名<br>
[root@study ~]#  tar-jxv -f /root/etc.tar.bz2 etc/shadow</p>
</li>
</ol>
<h1 id="此时只会解开一个文件而已不过重点是那个档名你要找到正确的档名">此时只会解开一个文件而已！不过，重点是那个档名！你要找到正确的档名。</h1>
<h1 id="在本例中你不能写成-etcshadow-因为记录在-etctarbz2-内的并没有-之故">在本例中，你不能写成 /etc/shadow ！因为记录在 etc.tar.bz2 内的并没有 / 之故！</h1>
<p>打包某目录，但不含该目录下的某些 文件<br>
可以透过 --exclude的帮忙！ 那个 exclude 就是不包含的意思<br>
[root@study ~]#  tar -jcv - /root/system.tar.bz2  --exclude=/root/etc*   --exclude=/root/system.tar.bz2 /etc /root</p>
<ul>
<li>其他常见的压缩与备份工具<br>
dd<br>
dd 可以读取磁盘装置的内容，dd 指令最大的功效应该是在于『备份』<br>
[root@study ~]# dd if=&quot;input_file&quot; of=&quot;output_file&quot; bs=&quot;block_size&quot; count=&quot;number&quot;<br>
选项与参数：<br>
if ：就是 input file 啰～也可以是装置喔！<br>
of ：就是 output file 喔～也可以是装置；<br>
bs ：规划的一个 block 的大小，若未指定则预设是 512 bytes(一个 sector 的大小)<br>
count：多少个 bs 的意思。</li>
</ul>
<p>cpio<br>
cpio 可以备份任何东西，包括装置设备文件。不过 cpio 有个大问题， 那 就是 cpio 不会主动的去找文件来备份， cpio 得要配合类似 find 等 可以找到文件名的指令来告知 cpio 该被备份的数据在哪里<br>
备份[root@study ~]# cpio - - ovcB &gt; [file|device]<br>
还原[root@study ~]# cpio - - ivcdu &lt; [file|device]<br>
察看[root@study ~]# cpio - - ivct &lt; [file|device]</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于树的递归与迭代]]></title>
        <id>https://lixin-ee.github.io//post/guan-yu-shu-de-di-gui-yu-die-dai</id>
        <link href="https://lixin-ee.github.io//post/guan-yu-shu-de-di-gui-yu-die-dai">
        </link>
        <updated>2020-01-01T03:08:38.000Z</updated>
        <content type="html"><![CDATA[<p>关于树的算法题可以有很多分类<br>
比如按遍历顺序是前中后序+层次遍历<br>
然后按层次又可以分为深度优先（DFS）和广度优先（BFS）</p>
<p>那做题的时候最明显的分类就是递归法和迭代法了<br>
我本来以为所有题目都是可以有递归法和迭代法的<br>
但是今天碰到的题目却颠覆了我的认知</p>
<p><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543. 二叉树的直径</a><br>
题目要求求节点中的最长路径（亦即直径）<br>
我的思考过程如下：<br>
这个问题可以转化为找某个节点的左右子树的深度之和（注意不一定就是根节点，有可能没有左右子树之一）<br>
递归倒是很简单，直接从叶子节点的1开始算起，每个非叶节点就计算左子树和右子树之和，再取两者的较大者+1返回<br>
迭代比较难，我想到的是先存入父节点、右子树和左子树，但是不知道怎么把层数回传给父节点<br>
后来想到用map来存,还是没法从叶节点开始回溯啊。。。</p>
<p>后来看了很多题解，发现确实就是无法使用迭代法，因为无法从叶子节点回溯到父节点<br>
类似的题目还有<br>
<a href="https://leetcode-cn.com/problems/balanced-binary-tree/solution/balanced-binary-tree-di-gui-fang-fa-by-jin40789108/">110. 平衡二叉树</a><br>
<a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a><br>
<a href="https://leetcode-cn.com/problems/house-robber-iii/">337. 打家劫舍 III</a></p>
<p>这些题有共同的特点是，当前节点的需要计算的值依赖于子节点返回的值<br>
（别和树的深度题搞混了，111.树的最小深度和104.树的最大深度还是可以用迭代的）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math 231. 2的幂[简单][位运算]]]></title>
        <id>https://lixin-ee.github.io//post/math-231-2-de-mi-jian-dan-wei-yun-suan</id>
        <link href="https://lixin-ee.github.io//post/math-231-2-de-mi-jian-dan-wei-yun-suan">
        </link>
        <updated>2020-01-01T01:44:14.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个整数，编写一个函数来判断它是否是 2 的幂次方。<br>
示例 1:<br>
输入: 1<br>
输出: true<br>
解释: 20 = 1<br>
示例 2:<br>
输入: 16<br>
输出: true<br>
解释: 24 = 16<br>
示例 3:<br>
输入: 218<br>
输出: false<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/power-of-two<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题让我想起了除法 把除数不断递增就好 主要难点就是在于除数和商的控制<br>
突然发现一个问题，如果不是2的幂的话肯定最后会变成奇数<br>
第一版代码里面，n%2、n/2和n<mark>1的位置很重要，一开始我把n/=2;放在了n%2前面，导致3就错误了；<br>
然后希望改进一下看看能不能递增2，判断条件很重要<br>
艹艹艹，忘了位这个东西啦！！！很明显按位处理更方便 只需要判断是否大于0和(n&amp;(n-1))是否</mark>0了<br>
因为如果n是二次幂，一定只有最高位是1，也就是1000...，则n-1是0111...如果不是二次幂，这两者的交集一定不等于0<br>
注意注意！！！！一开始写成了n&amp;(n-1)==0; 注意外括号必不可少，否则就等同于 n &amp; ((n-1)==0) <mark>的优先级可是高于&amp;的 可以类比 n&amp;&amp;n</mark>0</p>
<p>然后就是网友题解：</p>
<blockquote>
<p>解题思路：<br>
若 n = 2^x<br>
且 x 为自然数（即 n 为 2 的幂），则一定满足以下条件：<br>
恒有 n &amp; (n - 1) == 0，这是因为：<br>
n 二进制最高位为 1，其余所有位为 0；<br>
n - 1 二进制最高位为 0，其余所有位为 1；<br>
一定满足 n &gt; 0。<br>
因此，通过 n &gt; 0 且 n &amp; (n - 1) == 0 即可判定是否满足 n = 2^x</p>
</blockquote>
<pre><code>class Solution {
    public boolean isPowerOfTwo(int n) {
        return n &gt; 0 &amp;&amp; (n &amp; (n - 1)) == 0;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[  [Linux基础] 磁盘与文件系统管理（鸟哥Linux第七章）]]></title>
        <id>https://lixin-ee.github.io//post/linux-ji-chu-ci-pan-yu-wen-jian-xi-tong-guan-li-niao-ge-linux-di-qi-zhang</id>
        <link href="https://lixin-ee.github.io//post/linux-ji-chu-ci-pan-yu-wen-jian-xi-tong-guan-li-niao-ge-linux-di-qi-zhang">
        </link>
        <updated>2019-12-31T07:10:40.000Z</updated>
        <content type="html"><![CDATA[<p>这一章概念居多，命令很少用得上（比如查看磁盘和文件系统）<br>
磁盘盘上的物理组成则为<br>
•  扇区(Sector)为最小的物理储存单位，且依据磁盘设计的不同，目前主要有 512bytes 与 4K 两种格式；<br>
•  将扇区组成一个圆，那就是磁柱(Cylinder)；<br>
早期的分区主要以磁柱为最小分区单位，现在的分区通常使用扇区为最小分区单位</p>
<p>/dev/sd[a-p][1-128]：为实体磁盘的磁盘文件名；<br>
/dev/vd[a-d][1-128]：为虚拟磁盘的磁盘文件名；</p>
<ul>
<li>文件系统特性<br>
磁盘分区完毕后还需要进行格式化(format)，之后操作系统才能够使用这个文件系统。为什么需要进行『格式化』呢？这是因为每种操作系统所设定的文件属性/权限并不相同。为了存放这些文件所需的数据，因此就需要将分区槽进行格式化，以成为操作系统能够利用的『文件系统格式(filesystem)』<br>
Linux 的正统文件系统则为 Ext2</li>
</ul>
<p>文件系统通常会将这两部份的数据（文件权限(rwx)与文件属性(拥有者、 群组、时间参数等)）分别存放在不同的区块，权限与属性放置到 inode 中，至于实际数据则放置到 data block 区块中</p>
<p>每个 inode 与 block 都有编号，至于这三个数据的意义可以简略说明如下：</p>
<ul>
<li>superblock：记录此 filesystem 的整体信息，包括 inode/block 的总量、使用量、剩余量， 以及文件系统的 格式与相关信息等；</li>
<li>inode：记录文件的属性，一个文件占用一个 inode，同时记录此文件的数据所在的 block 号码；</li>
</ul>
<p>每个文件都会占用一个 inode ，inode 内则有文件数据放置 的 block 号码。<br>
一个incode可能会拥有（占用）多个block，这种数据存取的方法我们称为索引式文件系统(indexed allocation)</p>
<p>FAT 这种格式的文件系统并没有 inode 存在，每个 block 号码都记录在前一个 block 当中</p>
<p>『碎片整理』： 需要碎片整理的原因就是文件写入的 block 太过于离散了，此 时文件读取的效能将会变的很差所致。 这个时候可以透过碎片整理将同一个文件所属的 blocks 汇整 在一起</p>
<p>inode table (inode 表格)<br>
inode 记录的文件数据至少有底下这些</p>
<ul>
<li>
<p>该文件的存取模式(read/write/excute)；</p>
</li>
<li>
<p>该文件的拥有者与群组(owner/group)；</p>
</li>
<li>
<p>该文件的容量；</p>
</li>
<li>
<p>该文件建立或状态改变的时间(ctime)；</p>
</li>
<li>
<p>最近一次的读取时间(atime)；</p>
</li>
<li>
<p>最近修改的时间(mtime)；</p>
</li>
<li>
<p>定义文件特性的旗标(flag)，如 SetUID...；</p>
</li>
<li>
<p>该文件真正内容的指向 (pointer)；</p>
</li>
<li>
<p>每个 inode 大小均固定为 128 bytes (新的 ext4 与 xfs 可设定到 256 bytes)；</p>
</li>
<li>
<p>每个文件都仅会占用一个 inode 而已；</p>
</li>
<li>
<p>承上，因此文件系统能够建立的文件数量与 inode 的数量有关；</p>
</li>
<li>
<p>系统读取文件时需要先找到 inode，并分析 inode 所记录的权限与用户是否符合，若符合才能够开始实际 读取 block 的内容。</p>
</li>
</ul>
<ul>
<li>与目录树的关系<br>
1.目录<br>
当我们在 Linux 下的文件系统建立一个目录时，<strong>文件系统会分配一个 inode 与至少一块 block 给该目录</strong>。其中，<strong>inode 记录该目录的相关权限与属性</strong>，并可记录分配到的那块 block 号码； 而<strong>block 则是记录在这个目录下的文件名与该文件名占用的 inode 号码数据。</strong><br>
2.文件<br>
当我们在 Linux 下的 ext2 建立一个一般文件时， ext2 会分配一个 inode 与相对于该文件大小的 block 数量给该文件，由于 inode 仅 有 12 个直接指向，因此还要多一个 block 来作为区块号码的记录<br>
3.目录树读取<br>
inode 本身并不记录文件名，文件名的记录是在目 录的 block 当中<br>
因为『新增/删除/更名文件名 与目录的 w 权限有关』，那么因为文件名是记录在目录的 block 当中， 因此当我们要读取 某个文件时，就务必会经过目录的 inode 与 block ，然后才能够找到那个待读取文件的 inode 号码， 最终才会读到正确的文件的 block 内的数据。</li>
</ul>
<p>日志式文件系统：<br>
在 filesystem 当中规划出一个区块，该区块专门在记录写入或修订文件时的步骤</p>
<ol>
<li>预备：当系统要写入一个文件时，会先在日志记录区块中纪录某个文件准备要写入的信息；</li>
<li>实际写入：开始写入文件的权限与数据；开始更新 metadata 的数据；</li>
<li>结束：完成数据与 metadata 的更新后，在日志记录区块当中完成该文件的纪录。</li>
</ol>
<p>数据的不一致 (Inconsistent) 状态：metadata 的内容与实际数据存放区产生不一致 (Inconsistent)</p>
<p>Linux 文件系统的运作：<br>
1.当系统加载一个文件到内存后，如果该文件没有被更动过，则在内存区段的文件数据会被设定为干净 (clean)的。<br>
2.但如果内存中的文件数据被更改过了(例如你用 nano 去编辑过这个文件)，此时该内存中 的数据会被设定为脏的 (Dirty)。此时所有的动作都还在内存中执行，并没有写入到磁盘中<br>
3.系统会 不定时的将内存中设定为『Dirty』的数据写回磁盘，以保持磁盘与内存数据的一致性。<br>
如果能够将常用的文件放置到内存当中，就会增加系 统性能</p>
<ul>
<li>系统会将常用的文件数据放置到主存储器的缓冲区，以加速文件系统的读/写；</li>
<li>承上，因此 Linux 的物理内存最后都会被用光！这是正常的情况！可加速系统效能；</li>
<li>你可以手动使用 sync 来强迫内存中设定为 Dirty 的文件回写到磁盘中；</li>
</ul>
<ul>
<li>
<p>挂载点的意义 (mount point)<br>
将文件系统与目录树结合的动作我们称为『挂载』<br>
<strong>挂载点一定是目录</strong>，该目录为进入该文件系统的入口。 因此并不是你有任 何文件系统都能使用，<strong>必须要『挂载』到目录树的某个目录后，才能够使用该文件系统的。</strong><br>
<strong>同一个 filesystem 的某个 inode 只会对应到一个文件内容</strong>而 已(因为一个文件占用一个 inode 之故)， 因此我们可以透过判断 inode 号码来确认不同文件名是否 为相同的文件</p>
</li>
<li>
<p>文件系统的简单操作</p>
</li>
</ul>
<ul>
<li>
<p>df：列出文件系统的整体磁盘使用量；<br>
-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；<br>
-i ：不用磁盘容量，而以 inode 的数量来显示</p>
<pre><code>  	 **通常 inode 的数量剩余都比 block 还要多**
</code></pre>
</li>
<li>
<p>du：评估文件系统的磁盘使用量(常用在推估目录所占容量)<br>
-s ：列出总量而已，而不列出每个各别的目录占用容量；</p>
</li>
</ul>
<p>直接输入 du 没有加任何选项时，则 du 会分析『目前所在目录』的文件与目录所占用的磁盘空间。但是，实际显示时，仅会显示目录容量(不含文件)，<br>
与 df 不一样的是，du 这个指令其实会直接到文件系统内去搜寻所有的文件数据<br>
如果你只想要知道该目录占了多少容量的话，使用 -s 就可以</p>
<ul>
<li>
<p>实体链接与符号链接： ln（重点）<br>
Linux 底下的连结档有两种，一种是类似 Windows 的<strong>快捷方式功能</strong>的文件，可以让你快速的链 接到目标文件(或目录)； 另一种则是透过文件系统的 inode 连结来产生<strong>新档名</strong>，而<strong>不是产生新文件</strong>！ 这种称为实体链接 (hard link)。</p>
</li>
<li>
<p>Hard Link ( 实体链接, 硬式连结或实际连结)<br>
前提：</p>
</li>
</ul>
<ul>
<li><strong>每个文件都会占用一个 inode</strong> ，文件内容由 inode 的记录来指向；</li>
<li>想要读取该文件，必须要<strong>经过目录记录的文件名来指向到正确的 inode 号码才能读取。</strong></li>
</ul>
<p>hard link ：<strong>多个档名对应到同一个 inode 号码</strong><br>
hard link <strong>只是在某个目录下新增一笔档名链接到某 inode 号码的关连记录而已</strong><br>
硬链接hard link最大的好处就是 『安全』，<strong>如果你将任何一个『档名』删除，其实 inode 与 block 都还是存在的</strong><br>
<strong>使用 hard link 设定链接文件时，磁盘的空间与 inode 的数目都不会改变</strong><br>
hard link 的制作中，<strong>其实还是可能会改变系统的 block 的</strong>，那就是当你<strong>新增这笔数据却刚好将目录的 block 填满时，就可能会新加一个 block 来记录文件名关连性</strong>，而导致磁盘空间的变化！不过， 一般 hard link 所用掉的关连数据量很小，所以<strong>通常不会改变 inode 与磁盘空间的大小</strong><br>
hard link 是有限制的：</p>
<ul>
<li>不能跨 Filesystem；</li>
<li><strong>不能 link 目录</strong>。<br>
<strong>如果使用 hard link 链接到目录时， 链接的数据需要连同被链接目录底下的所有数据都建立链接</strong></li>
</ul>
<ul>
<li>Symbolic Link (符号链接，亦即是快捷方式)<br>
Symbolic link 就是在建立一个<strong>独立的 文件</strong>，而这个文件会让<strong>数据的读取指向他它link 的那个文件的档名</strong>！由于只是利用文件来做为指向的 动作， 所以，当<strong>来源档被删除</strong>之后，<strong>symbolic link</strong> 的文件会『开不了』，<br>
<strong>两个文件指向不同的 inode 号码，当然就是两个独立的文件存在！</strong> 而且 连结档的<strong>重要内容就是他会写上目标文件的『文件名』</strong></li>
</ul>
<p>Symbolic Link 与 Windows 的快捷方式可以给他划上等号，由 Symbolic link 所建立的文件为一个<strong>独立的新的文件</strong>，所以<strong>会占用掉 inode 与 block</strong></p>
<p><strong>个人测试</strong>：Symbolic Link之后删除源文件，会显示No such file 但是！！！！我重建源文件后（用vim重建不同内容的同名文件或者用ln硬链接同名文件），会自动连接上！！！</p>
<p>要制作连结档就必须要使用 ln 这个指令<br>
[root@study ~]# ln [-sf] 来源文件 目标文件<br>
选项与参数：<br>
-s ：如果不加任何参数就进行连结，那就是 hard link，至于 -s 就是 symbolic link<br>
-f ：如果 目标文件 存在时，就主动的将目标文件直接移除后再建立</p>
<p><strong>使用 ln 如果不加任何参数的话，那么就是 Hard Link</strong></p>
<p>关于目录的 link 数量<br>
以 hard link 进行『文件的连结』时，可以发现，在 ls -l 所显 示的第二字段会增加一才对<br>
当我们建立一个新目录名称为 /tmp/testing 时，基本上会有三个东西，那就是：</p>
<ul>
<li>/tmp/testing</li>
<li>/tmp/testing/.</li>
<li>/tmp/testing/..<br>
所以<strong>新的目录的 link 数为 2 ，而上层目录的 link 数则会增加 1</strong></li>
</ul>
<ul>
<li>磁盘的分区、格式化、检验与挂载<br>
想要在系统里面新增一颗磁盘时，应该有哪些动作需要做：</li>
</ul>
<ol>
<li>对磁盘进行<strong>分区</strong>，以建立可用的 partition ；</li>
<li>对该 partition 进行<strong>格式化 (format)</strong>，以建立系统可用的 filesystem；</li>
<li>若想要仔细一点，则可对刚刚建立好的 filesystem 进行检验；</li>
<li>在 Linux 系统上，需要<strong>建立挂载点 (亦即是目录)</strong>，并将他挂载上来；</li>
</ol>
<ul>
<li>观察磁盘分区状态</li>
</ul>
<ol>
<li>lsblk列出系统上的所有磁盘列表</li>
<li>blkid  列出装置的UUID 等参数</li>
<li>parted 列出磁盘的 分区 表类型与 分区 信息</li>
<li>磁盘分区： gdisk/fdisk</li>
</ol>
<ul>
<li>磁盘格式化( 建置文件系统)</li>
</ul>
<ol>
<li>XFS  文件系统 mkfs.xfs</li>
<li>XFS  文件系统 for RAID  效能优化 (Optional)</li>
<li>EXT4  文件系统 mkfs.ext4</li>
<li>其他文件系统 mkfs</li>
</ol>
<ul>
<li>文件系统检验</li>
</ul>
<ol>
<li>xfs_repair  处理 XFS文件系统</li>
<li>fsck.ext4  处理 EXT4  文件系统</li>
</ol>
<ul>
<li>文件系统挂载与卸除  (相当于插入u盘后显示的载入点)<br>
载点的意义：挂载点是目录， 而这个目录是进入磁盘分区槽(其实是 文件系统)的入口</li>
</ul>
<ul>
<li>单一文件系统不应该被重复挂载在不同的挂载点(目录)中；</li>
<li>单一目录不应该重复挂载多个文件系统；</li>
<li>要作为挂载点的目录，理论上应该都是空目录才是<br>
挂载了文件系统之后，原目录 下的东西就会暂时的消失。等 到新分区槽被卸除之后，原本的内容就会再次的跑出来</li>
</ul>
<p>挂载指令 -mount<br>
[root@study ~]#  mount<br>
-t ：可以加上文件系统种类来指定欲挂载的类型</p>
<p>将装置文件卸除 -umount<br>
[root@study ~]# umount [-fn] 装置文件名或挂载点</p>
<p>-f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下；<br>
-l ：立刻卸除文件系统，比 -f 还强！</p>
<p>由于通通卸除了，此时你才可以退出光盘片、软盘片、USB 随身碟等设备<br>
由于你目前正在目录内，也就是说其实『你正在使用该文件系统！所以自然无法卸除这个装置！那该如何是好？就『离开该文件系统的挂载点』即可</p>
<ul>
<li>
<p>磁盘/ 文件系统参数修订<br>
修改目前文件系统的一些相关信息<br>
1.mknod 手动处理装置文件<br>
2.xfs_admin  修改 XFS  文件系统的 UUID  与 Label name<br>
3.tune2fs  修改 ext4  的 label name  与 UUID</p>
</li>
<li>
<p>设定开机挂载<br>
开机挂载 /etc/fstab  及 /etc/mtab<br>
/etc/fstab 可设置开机自动挂载文件系统<br>
系统挂载的一些限制：<br>
•  根目录 / 是必须挂载的﹐而且一定要先于其它 mount point 被挂载进来。<br>
•  其它 mount point 必须为已建立的目录﹐可任意指定﹐但一定要遵守必须的系统目录架构原则 (FHS)<br>
•  所有 mount point 在同一时间之内﹐只能挂载一次。<br>
•  所有 partition 在同一时间之内﹐只能挂载一次。<br>
•  如若进行卸除﹐您必须先将工作目录移到 mount point(及其子目录) 之外。</p>
</li>
<li>
<p>建立大 文件 以制作 loop  装置 文件<br>
将这个文件格式化后挂载：制作出一个大文件，然后将这个文件挂载！如此一来感觉上你就多了一个分区槽啰<br>
o  建立大型文件<br>
程序 dd可以用来建立空的文件<br>
[root@study ~]#  dd if=/dev/zero of=/srv/loopdev bs=1M count=512<br>
512+0 records in &lt;==读入 512 笔资料<br>
512+0 records out &lt;==输出 512 笔数据<br>
536870912 bytes (537 MB) copied, 12.3484 seconds, 43.5 MB/s</p>
</li>
</ul>
<h1 id="这个指令的简单意义如下">这个指令的简单意义如下：</h1>
<h1 id="if-是-input-file-输入文件-那个-devzero-是会一直输出-0-的装置">if 是 input file ，输入文件。那个 /dev/zero 是会一直输出 0 的装置！</h1>
<h1 id="of-是-output-file-将一堆零写入到后面接的文件中">of 是 output file ，将一堆零写入到后面接的文件中。</h1>
<h1 id="bs-是每个-block-大小就像文件系统那样的-block-意义">bs 是每个 block 大小，就像文件系统那样的 block 意义；</h1>
<h1 id="count-则是总共几个-bs-的意思-所以-bscount-就是这个文件的容量了">count 则是总共几个 bs 的意思。所以 bs*count 就是这个文件的容量了！</h1>
<p>dd 就好像在迭砖块一样，将 512 块，每块 1MB 的砖块堆栈成为一个大文件 (/srv/loopdev) ！ 最终就会出现一个 512MB 的文件！</p>
<p>o  大型文件的格式化<br>
o  挂载<br>
可以在原本的分区槽在不更动原有的环境下制作出你想要的分区槽</p>
<ul>
<li>内存置换空间(swap)<br>
可以暂时将内存的程序拿到硬盘中暂放的内存置换空间 (swap)<br>
安装时一定需要的两个 partition ，一个是根目录，另外一个就是 swap(内存置换空间)<br>
那当内存不足的时候，为了让后续的程序可以顺利的运作，因此在内存中暂不使用的程序与数据就会被挪到 swap 中</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 70. 爬楼梯[简单][未做出]]]></title>
        <id>https://lixin-ee.github.io//post/dong-tai-gui-hua-70-pa-lou-ti-jian-dan-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/dong-tai-gui-hua-70-pa-lou-ti-jian-dan-wei-zuo-chu">
        </link>
        <updated>2019-12-31T01:45:17.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br>
注意：给定 n 是一个正整数。<br>
示例 1：<br>
输入： 2<br>
输出： 2<br>
解释： 有两种方法可以爬到楼顶。<br>
1.1 阶 + 1 阶<br>
2.2 阶<br>
示例 2：<br>
输入： 3<br>
输出： 3<br>
解释： 有三种方法可以爬到楼顶。<br>
1.1 阶 + 1 阶 + 1 阶<br>
2.1 阶 + 2 阶<br>
3.2 阶 + 1 阶<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/climbing-stairs<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>有点像动态规划<br>
等等！怎么那么像排列组合？！<br>
列出全部为1的情况，然后随机对1进行组合<br>
不对，首先我将其视为一棵树，左子树+1，右子树+2，当叶节点大于等于n的时候就将次数增加1<br>
尴尬，代码是对的，但是超出时间限制了<br>
然后想想对称地用队列的方法 继续翻车超出时间限制<br>
接下来就是动态规划了，我的想法是对于一个全为1的序列，如果前一个1没选择组合为2的话，当前的1就可以选择组合成2或者保持为1，否则只能保持1<br>
动态规划也翻车了<br>
还是好好看看题解吧，其实是斐波那契的问题，但是树的优化也很值得看看</p>
<p>注意实现动态规划时，初始状态是0步而不是1步，所以n=2是是level[0]+level[1]所以需要数组n+1</p>
<pre><code>class Solution {
public:
    int climbStairs(int n) {
        vector&lt;int&gt; level(n+1,1);
        for(int i=2;i&lt;n+1;++i)
            level[i]=level[i-1]+level[i-2];
        return level.back();
    }
};
</code></pre>
<p>超时代码：</p>
<pre><code>/*
class Solution {
public:
    int count=0;
    int climbStairs(int n) {
        add1(0,n);
        add2(0,n); 
        return count;
    }
    
    void add1(int i,int n){
        ++i;
        if(i==n){
            ++count;
            return;
        }
        if(i&gt;n)
            return;
        add1(i,n);
        add2(i,n);
    }
    
    void add2(int i,int n){
        i+=2;
        if(i==n){
            ++count;
            return;
        }
        if(i&gt;n)
            return;
        add1(i,n);
        add2(i,n);          
    }
};
*/
 /*
    int climbStairs(int n) {
        int count=0;
        queue&lt;int&gt; nums;
        nums.push(n);
        while(!nums.empty()){
            int temp=nums.front();
            nums.pop();
            if(temp-1==0)
                ++count;
            if(temp-2==0)
                ++count;
            if(temp-1&gt;0)
                nums.push(temp-1);
            if(temp-2&gt;0)
                nums.push(temp-2);
        }
        return count;  
    }
    */
</code></pre>
<p>然后是题解：</p>
<blockquote>
<p>摘要<br>
假设你正在爬楼梯，需要 n 阶你才能到达楼顶。<br>
每次你可以爬 1 或 2 个台阶，你有多少种不同的方法可以爬到楼顶呢？<br>
解决方案</p>
</blockquote>
<blockquote>
<p>方法一：暴力法<br>
算法<br>
在暴力法中，我们将会把所有可能爬的阶数进行组合，也就是 1 和 2 。而在每一步中我们都会继续调用 climbStairs这个函数模拟爬 1 阶和 2 阶的情形，并返回两个函数的返回值之和。<br>
climbStairs(i,n)=(i + 1, n) + climbStairs(i + 2, n)<br>
其中 i 定义了当前阶数，而 n 定义了目标阶数。</p>
</blockquote>
<pre><code>Java
public class Solution {
    public int climbStairs(int n) {
        climb_Stairs(0, n);
    }
    public int climb_Stairs(int i, int n) {
        if (i &gt; n) {
            return 0;
        }
        if (i == n) {
            return 1;
        }
        return climb_Stairs(i + 1, n) + climb_Stairs(i + 2, n);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(2^n )，树形递归的大小为 2^n2<br>
空间复杂度：O(n)，递归树的深度可以达到 n 。</p>
</blockquote>
<blockquote>
<p>方法二：记忆化递归<br>
算法<br>
在上一种方法中，我们计算每一步的结果时出现了冗余。另一种思路是，我们可以把每一步的结果存储在 memo 数组之中，每当函数再次被调用，我们就直接从 memo 数组返回结果。<br>
在 memo 数组的帮助下，我们得到了一个修复的递归树，其大小减少到 n。</p>
</blockquote>
<pre><code>Java
public class Solution {
    public int climbStairs(int n) {
        int memo[] = new int[n + 1];
        return climb_Stairs(0, n, memo);
    }
    public int climb_Stairs(int i, int n, int memo[]) {
        if (i &gt; n) {
            return 0;
        }
        if (i == n) {
            return 1;
        }
        if (memo[i] &gt; 0) {
            return memo[i];
        }
        memo[i] = climb_Stairs(i + 1, n, memo) + climb_Stairs(i + 2, n, memo);
        return memo[i];
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)，树形递归的大小可以达到 n。<br>
空间复杂度：O(n)，递归树的深度可以达到 n。</p>
</blockquote>
<blockquote>
<p>方法三：动态规划<br>
算法<br>
不难发现，这个问题可以被分解为一些包含最优子结构的子问题，即它的最优解可以从其子问题的最优解来有效地构建，我们可以使用动态规划来解决这一问题。<br>
第 i 阶可以由以下两种方法得到：<br>
在第 (i−1) 阶后向上爬一阶。<br>
在第 (i−2) 阶后向上爬 2 阶。<br>
所以到达第 i 阶的方法总数就是到第(i−1) 阶和第 (i−2) 阶的方法数之和。<br>
令 dp[i] 表示能到达第 i 阶的方法总数：<br>
dp[i]=dp[i−1]+dp[i−2]</p>
</blockquote>
<pre><code>public class Solution {
    public int climbStairs(int n) {
        if (n == 1) {
            return 1;
        }
        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i &lt;= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)，单循环到 n 。<br>
空间复杂度：O(n)，dp 数组用了 n 的空间。</p>
</blockquote>
<blockquote>
<p>方法四：斐波那契数<br>
算法<br>
在上述方法中，我们使用 dp 数组，其中 dp[i]=dp[i-1]+dp[i-2]。可以很容易通过分析得出dp[i] 其实就是第 ii 个斐波那契数。<br>
Fib(n)=Fib(n−1)+Fib(n−2)<br>
现在我们必须找出以 1 和 2 作为第一项和第二项的斐波那契数列中的第 n 个数，也就是说 Fib(1)=1Fib(1)=1 且 Fib(2)=2Fib(2)=2。</p>
</blockquote>
<pre><code>Java
public class Solution {
    public int climbStairs(int n) {
        if (n == 1) {
            return 1;
        }
        int first = 1;
        int second = 2;
        for (int i = 3; i &lt;= n; i++) {
            int third = first + second;
            first = second;
            second = third;
        }
        return second;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)，单循环到 n，需要计算第 n 个斐波那契数。<br>
空间复杂度：O(1)，使用常量级空间。</p>
</blockquote>
<p>下面的就很数学了，在面试中说出来就明显是刷题的了，所以就不贴了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ [Linux基础] 文件与目录管理（鸟哥Linux第六章）]]></title>
        <id>https://lixin-ee.github.io//post/linux-ji-chu-wen-jian-yu-mu-lu-guan-li-niao-ge-linux-di-liu-zhang</id>
        <link href="https://lixin-ee.github.io//post/linux-ji-chu-wen-jian-yu-mu-lu-guan-li-niao-ge-linux-di-liu-zhang">
        </link>
        <updated>2019-12-30T12:24:53.000Z</updated>
        <content type="html"><![CDATA[<p>绝对路径：路径的写法『一定由根目录 / 写起』<br>
相对路径：路径的写法『不是由 / 写起』</p>
<ul>
<li>目录的相关操作<br>
. 代表此层目录<br>
.. 代表上一层目录<br>
-代表前一个工作目录<br>
~ 代表『目前用户身份』所在的家目录<br>
~account 代表 account 这个用户的家目录(account 是个账号名称)</li>
</ul>
<p>在所有目录底下都会存在的两个目录，分别是『.』与『..』 分别代表此层与上层<br>
目录的意思。</p>
<p>几个常见的处理目录的指令：<br>
•  cd：变换目录<br>
cd 是 Change Directory 的缩写</p>
<p>•  pwd：显示当前目录<br>
-P ：显示出确实的路径，而非使用链接 (link) 路径。<br>
pwd 是 Print Working Directory 的缩写，也就是显示目前所在目录的指令</p>
<p>•  mkdir：建立一个新的目录<br>
-m ：配置文件案的权限喔！直接设定，不需要看预设权限 (umask) 的脸色<br>
-p ：帮助你直接将所需要的目录(包含上层目录)递归建立起来！</p>
<p>•  rmdir：删除一个空的目录<br>
-p ：连同『上层』『空的』目录也一起删除<br>
目录需要一层一层的删除才行！而且被删除的目录里面必定不能存在其他的目录或文 件<br>
那如果要将所有目录下的东西都杀掉就必须使用『 rm -r test 』</p>
<ul>
<li>关于执行文件路径的变量： $PATH<br>
echo <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mi>A</mi><mi>T</mi><mi>H</mi><mi mathvariant="normal">环</mi><mi mathvariant="normal">境</mi><mi mathvariant="normal">变</mi><mi mathvariant="normal">量</mi><mi mathvariant="normal">打</mi><mi mathvariant="normal">印</mi><mi mathvariant="normal">，</mi><mi>e</mi><mi>c</mi><mi>h</mi><mi>o</mi><mi mathvariant="normal">有</mi><mi mathvariant="normal">『</mi><mi mathvariant="normal">显</mi><mi mathvariant="normal">示</mi><mi mathvariant="normal">、</mi><mi mathvariant="normal">印</mi><mi mathvariant="normal">出</mi><mi mathvariant="normal">』</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">，</mi></mrow><annotation encoding="application/x-tex">PATH 环境变量打印，echo 有『显示、印出』的，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord cjk_fallback">环</span><span class="mord cjk_fallback">境</span><span class="mord cjk_fallback">变</span><span class="mord cjk_fallback">量</span><span class="mord cjk_fallback">打</span><span class="mord cjk_fallback">印</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">o</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">『</span><span class="mord cjk_fallback">显</span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">、</span><span class="mord cjk_fallback">印</span><span class="mord cjk_fallback">出</span><span class="mord cjk_fallback">』</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">，</span></span></span></span> 表示后面接的是变量<br>
PATH(一定是大写)这个变量的内容是由一堆目录所组成的，每个目录中间用冒号(:)来隔开， 每个目 录是有『顺序』之分的。</li>
</ul>
<p>修改PATH：[root@study ~]#PATH=&quot;${PATH}:/root&quot; (将/root 加入 PATH 当中)</p>
<p>为了安全起见，不建议将当前目录『.』加入 PATH 的搜寻目录中。</p>
<ul>
<li>
<p>文件与目录管理<br>
文件与目录的检视： ls<br>
选项与参数：<br>
<strong>-a ：全部的文件，连同隐藏档( 开头为 . 的文件) 一起列出来(常用)</strong><br>
-A ：全部的文件，连同隐藏档，但不包括 . 与 .. 这两个目录<br>
<strong>-d ：仅列出目录本身，而不是列出目录内的文件数据(常用)</strong><br>
-f ：直接列出结果，而不进行排序 (ls 预设会以档名排序！)<br>
-F ：根据文件、目录等信息，给予附加数据结构，例如：* :代表可执行文件； /:代表目录； =:代表 socket 文件； |:代表 FIFO 文件；<br>
-h ：将文件容量以人类较易读的方式(例如 GB, KB 等等)列出来；<br>
-i ：列出 inode 号码，inode 的意义下一章将会介绍；<br>
<strong>-l ：长数据串行出，包含文件的属性与权限等等数据；(常用)</strong><br>
-n ：列出 UID 与 GID 而非使用者与群组的名称 (UID 与 GID 会在账号管理提到！)<br>
-r ：将排序结果反向输出，例如：原本档名由小到大，反向则为由大到小；<br>
-R ：连同子目录内容一起列出来，等于该目录下的所有文件都会显示出来；<br>
-S ：以文件容量大小排序，而不是用档名排序；<br>
-t ：依时间排序，而不是用档名。<br>
--color=never ：不要依据文件特性给予颜色显示；<br>
--color=always ：显示颜色<br>
--color=auto ：让系统自行依据设定来判断是否给予颜色<br>
--full-time ：以完整时间模式 (包含年、月、日、时、分) 输出<br>
--time={atime,ctime} ：输出 access 时间或改变权限属性时间 (ctime)<br>
而非内容变更时间 (modification time)<br>
当你只有下达 ls 时，默认显示的只有：非隐藏档的档名、 以档名进行排序及文件名代表的颜色显示</p>
</li>
<li>
<p>复制、删除与移动： cp, rm, mv<br>
cp ( 复制 文件 或目录)<br>
<strong>-a ：相当于 -dr --preserve=all 的意思，至于 dr 请参考下列说明；(常用)</strong><br>
-d ：若来源文件为链接文件的属性(link file)，则复制链接文件属性而非文件本身；<br>
-f ：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；<br>
<strong>-i ：若目标文件(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</strong><br>
-l ：进行硬式连结(hard link)的连结档建立，而非复制文件本身；<br>
<strong>-p ：连同文件的属性(权限、用户、时间)一起复制过去，而非使用默认属性(备份常用)；</strong><br>
<strong>-r ：递归持续复制，用于目录的复制行为；(常用)</strong><br>
-s ：复制成为符号链接文件 (symbolic link)，亦即『快捷方式』文件；<br>
-u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制。（在目标文件与来源文件有差异时，才会复制，比较常被用于『备份』的工作）<br>
--preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links,xattr 等也复制了。</p>
</li>
</ul>
<p>如果来源档有两个以上，则最后一个目的文件一定要是『目录』<br>
在预设的条件中， cp 的来源档与目的档的权限是不同的，目的档的拥有者通常会是指令操作者本身。</p>
<p>使用 -l 及 -s 都会建立所谓的连结档(link file)，但是这两种连结档却有不一样的 情况。那个 -l 就是所谓的实体链接(hard link)，至于 -s 则是符号链接(symbolic link)，符号链接(symbolic link)是一个『快捷方式』，实体链接(hard link) 与 bashrc 的属性与权限完全一模一样，与尚未进行连结前的差异则是第二栏的 link 数由 1 变成 2</p>
<ul>
<li>rm ( 移除文件或目录)<br>
选项与参数：<br>
-f ：就是 force 的意思，忽略不存在的文件，不会出现警告讯息；<br>
-i ：互动模式，在删除前会询问使用者是否动作<br>
-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！</li>
</ul>
<p>使用『 rm -r 』这个指令之前，请千万注 意了，因为该目录或文件『肯定』会被 root 杀掉！</p>
<ul>
<li>
<p>mv ( 移动文件与目录，或更名)<br>
选项与参数：<br>
-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；<br>
-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！<br>
-u ：若目标文件已经存在，且 source 比较新，才会更新 (update)</p>
</li>
<li>
<p>取得路径的文件名与目录名称</p>
</li>
</ul>
<p>[root@study ~]#  basename /etc/sysconfig/network<br>
network &lt;== 很简单！就取得最后的档名～<br>
[root@study ~]#  dirname /etc/sysconfig/network<br>
/etc/sysconfig &lt;== 取得的变成目录名了！</p>
<ul>
<li>文件内容查阅<br>
查阅一个文件的内容：<br>
•  cat 由第一行开始显示文件内容<br>
•  tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！<br>
•  nl 显示的时候，顺道输出行号！<br>
•  more 一页一页的显示文件内容<br>
•  less 与 more 类似，但是比 more 更好的是，他可以往前翻页！<br>
•  head 只看头几行<br>
•  tail 只看尾巴几行<br>
•  od 以二进制的方式读取文件内容！</li>
</ul>
<p>在 more 的时候，我们并没有办法向前面翻， 只能往后面看，但若使用了 less 时，就可以使用 [pageup] [pagedown] 等按键的功能来往前往后翻看文件<br>
在 less 里头可以拥有更多的『搜寻』功能，不止可以向下搜寻，也可以向上搜寻<br>
man 这个指令就是呼叫 less 来显示说明文件的内容的</p>
<ul>
<li>修改文件时间或建置新档： touch</li>
</ul>
<ul>
<li>modification time (mtime)： 当该文件的『内容数据』变更时，就会更新这个时间！内容数据指的是文件的内容，而不是文件的属性或 权限喔！</li>
<li>status time (ctime)： 当该文件的『状态 (status)』改变时，就会更新这个时间，举例来说，像是权限与属性被更改了，都会更新 这个时间啊。</li>
<li>access time (atime)： 当『该文件的内容被取用』时，就会更新这个读取时间 (access)。举例来说，我们使用 cat 去读取 /etc/man_db.conf ， 就会更新该文件的 atime 了。<br>
在默认的情况下，ls 显示出来的是该文件的 mtime ，也就是这个文件的内容上次被更动 的时间。</li>
</ul>
<p>时间修改指令：<br>
[root@study ~]#  touch [-acdmt]  文件<br>
选项与参数：<br>
-a ：仅修订 access time；<br>
-c ：仅修改文件的时间，若该文件不存在则不建立新文件；<br>
-d ：后面可以接欲修订的日期而不用目前的日期，也可以使用 --date=&quot;日期或时间&quot;<br>
-m ：仅修改 mtime ；<br>
-t ：后面可以接欲修订的时间而不用目前的时间，格式为[YYYYMMDDhhmm]</p>
<p>如果 touch 后面有接文件，则该文件的三个时间 (atime/ctime/mtime) 都会更新为目前的时间。若该文件不存在， 则会主动的建立一个新的空的文件</p>
<p>touch 这个指令最常被使用的情况是：<br>
•  建立一个空的文件；<br>
•  将某个文件日期修订为目前 (mtime 与 atime)</p>
<ul>
<li>文件与目录的默认权限与隐藏权限<br>
新增一个文件或目录时，默认的权限</li>
</ul>
<p>文件预设权限：umask<br>
umask 就是指定 『目前用户在建立文件或目录时候的权限默认值』<br>
查阅的方式有两种，一种可以直接输入 umask ，就可以看到数字型态的权限设定分数， 一种则是加入 -S (Symbolic) 这个选项，就会以符号类型的方式来显示出权限</p>
<p><strong>umask 的分数指的是『该默认值需要减掉的权限！』</strong></p>
<p>设定 umask ：直接在 umask 后面输入 需要减去的权限值就好了</p>
<ul>
<li>文件隐藏属性<br>
chattr ( 配置文件案隐藏属性) chattr [+-=][ASacdistu]  文件 或目 录 名 称<br>
+：增加某一个特殊参数，其他原本存在参数则不动。<br>
-：移除某一个特殊参数，其他原本存在参数则不动。<br>
= ：设定一定，且仅有后面接的参数</li>
</ul>
<p>a ：当设定 a 之后，这个文件将只能增加数据，而不能删除也不能修改数据，只有 root 才能设定这属性<br>
i ：这个 i 可就很厉害了！他可以让一个文件『不能被删除、改名、设定连结也无法写入或新增数据！』对于系统安全性有相当大的帮助！只有 root 能设定此属性</p>
<p>lsattr ( 显示文件隐藏属性)</p>
<ul>
<li>文件特殊权限： SUID, SGID, SBIT</li>
</ul>
<ol>
<li>
<p>Set UID : s 这个标志会出现在文件拥有者的 x 权限上，被称为 Set UID，简称为 SUID 的特殊权限<br>
基本上 SUID 有这样的限制与功能：<br>
•  SUID 权限仅对二进制程序(binary program)有效；<br>
•  执行者对于该程序需要具有 x 的可执行权限；<br>
•  本权限仅在执行该程序的过程中有效 (run-time)；<br>
•  执行者将具有该<strong>程序拥有者 (owner) 的权限</strong>。<br>
<img src="https://lixin-ee.github.io//post-images/1577711413192.png" alt=""><br>
SUID 仅可用在 binary program 上， 不能够用在 shell script 上面<br>
SUID 对于目录也是无效的</p>
</li>
<li>
<p>Set GID<br>
s 在群组的 x 时则称为 Set GID, SGID<br>
与 SUID 不同的是，SGID 可以针对文件或目录来设定<br>
如果是对文件来说， SGID 有如下的功能：<br>
•  SGID 对二进制程序有用；<br>
•  程序执行者对于该程序来说，需具备 x 的权限；<br>
•  执行者在执行的过程中将会获得该程序群组的支持！</p>
</li>
</ol>
<p>当一个目录设定了 SGID 的权限后，他将具有如下的功能：<br>
•  用户若对于此目录具有 r 与 x 的权限时，该用户能够进入此目录；<br>
•  用户在此目录下的有效群组(effective group)将会变成该目录的群组；<br>
•  用途：若用户在此目录下具有 w 的权限(可以新建文件)，则使用者所建立的新文件，该新文件的群组与此目录的群组相同</p>
<ol start="3">
<li>Sticky Bit<br>
Sticky Bit, SBIT 目前只针对目录有效，对于文件已经没有效果了<br>
SBIT 对于目录的作用是：<br>
•  当用户对于此目录具有 w, x 权限，亦即具有写入的权限时；<br>
•  当用户在该目录下建立文件或目录时，仅有自己与 root 才有权力删除该文件</li>
</ol>
<ul>
<li>
<p>SUID/SGID/SBIT权限设定<br>
数字型态更改权限的方式为『三个数字』的组合， 那么如果在这三个数字之前再加上一个数字的话，最前面的那个数字就代表这几个权限了！<br>
•  4 为 SUID<br>
•  2 为 SGID<br>
•  1 为 SBIT<br>
假设要将一个文件权限改为『-rwsr-xr-x』时，由于 s 在用户权力中，所以是 SUID ，因此， 在原先的 755 之前还要加上 4 ，也就是：『 chmod 4755 filename 』来设定<br>
大写的 S 与 T ： 因为 s 与 t 都是取代 x 这个权限的，但是我们是下达 7666 ！也就是说， user, group 以及others 都没有 x 这个可执行的标志( 因为 666 嘛 )，所以这个 S, T 代表的就是『空的』。SUID 是表示『该文件在执行的时候，具有文件拥有者的权限』，但是文件 拥有者都无法执行了当然就是空的<br>
而除了数字法之外，也可以透过符号法来处理，其中 SUID 为 u+s ，而 SGID 为 g+s ，SBIT则是 o+t</p>
</li>
<li>
<p>观察文件类型：file<br>
想要知道某个文件的基本数据，例如是属于 ASCII 或者是 data 文件，或者是 binary ， 且其中有没有使用到动态函式库 (share library) 等等的信息，就可以利用 file 这个指令来检阅</p>
</li>
<li>
<p>指令与 文件 的搜寻</p>
</li>
</ul>
<p>脚本文件名的搜寻<br>
指令的完整文件名和位置，透过 which或 type 来找寻</p>
<p>which 指令是根据『PATH』这个环境变量所规范的路径，去搜寻『执行档』的档名，所以找不到history 等『bash 内建的指令』,若加上 -a 选项，则可以列出所有的可以找到的同名执行文件，而非仅显示第一个</p>
<ul>
<li>文件档名的搜寻<br>
Linux 的搜寻指令find 不很常用的，因为速度慢之外， 也很操硬盘！一般我们都是先使用 whereis 或者是 locate 来检查，如果真的找不到了，才以 find 来搜寻<br>
因为 whereis 只找系统中某些特定目录底下的文件而已，locate则是利用数据库来搜寻文件名，当然两者就相当的快速， 并且没有实际的搜寻硬盘内的文件系统状态，比较省时间</li>
</ul>
<p>如果你要找的文件是具有特殊属性的，例如 SUID 、文件拥有者、文件大小等等， 那么利用 locate是没有办法达成</p>
<p>搜寻系统中不属于任何人的文件<br>
find /- nouser<br>
透过这个指令，可以轻易的就找出那些不太正常的文件。如果有找到不属于系统任何人的文件时，</p>
<p>find 的特殊功能就是能够进行额外的动作(action)。<br>
<img src="https://lixin-ee.github.io//post-images/1577711985462.png" alt=""><br>
该范例中特殊的地方有 {} 以及 ; 还有 -exec 这个关键词，这些东西的意义为：<br>
•  {} 代表的是『由 find 找到的内容』，如上图所示，find 的结果会被放置到 {} 位置中；<br>
•  -exec 一直到 ; 是关键词，代表 find 额外动作的开始 (-exec) 到结束 (;) ，在这中间的就是 find 指令内的额外动作。 在本例中就是『 ls -l {} 』啰！<br>
•  因为『 ; 』在 bash 环境下是有特殊意义的，因此利用反斜杠来跳脱。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于右值与移动构造函数]]></title>
        <id>https://lixin-ee.github.io//post/guan-yu-you-zhi-yu-yi-dong-gou-zao-han-shu</id>
        <link href="https://lixin-ee.github.io//post/guan-yu-you-zhi-yu-yi-dong-gou-zao-han-shu">
        </link>
        <updated>2019-12-30T03:57:06.000Z</updated>
        <content type="html"><![CDATA[<p>loading</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 53. 最大子序和[简单][动态规划][分治法]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-53-zui-da-zi-xu-he-jian-dan-dong-tai-gui-hua-fen-zhi-fa</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-53-zui-da-zi-xu-he-jian-dan-dong-tai-gui-hua-fen-zhi-fa">
        </link>
        <updated>2019-12-30T02:14:20.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>
示例:<br>
输入: [-2,1,-3,4,-1,2,1,-5,4],<br>
输出: 6<br>
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。<br>
进阶:<br>
如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/maximum-subarray<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>很明显的动态规划，然后进阶提示分治法hhh<br>
首先实现一下动态规划，主要的障碍点在于连续这个点<br>
如果是用0和1代表选择和不选择 那么0这个点就不能保存状态 那么今天的状态就等于叠加前一天的值和今天的值之间的最大值了<br>
然后注意因为可能会抛弃前面的序列或者后面的序列 比如 [1,-10,2] [2,-10,1]这两种情况存在，所以不可以返回动态规划数组的最后一个值<br>
必须用一个maxv存放历史最大值</p>
<p>分治法的话我感觉就是先分割到每个数，然后两两结合 返回当[左值，右值，左值+右值]之间的最大值<br>
但是问题来了， 怎么保证连续呢？类似于归并排序，merge是关键<br>
分治法还是没有想到好的合并方法，所以直接看题解</p>
<pre><code>class Solution {
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) {
        int len=nums.size();
        int res=nums[0];
        vector&lt;int&gt; maxv(len);
        maxv[0]=nums[0];
        for(int i=1;i&lt;len;++i){
           maxv[i]=max(maxv[i-1]+nums[i],nums[i]);
            res=max(res,maxv[i]);
        }
        return res;
    }

};
</code></pre>
<p>然后来看看题解<br>
动态规划法没啥好说的了<br>
比较有趣的是高赞回答</p>
<blockquote>
<p>思路<br>
这道题用动态规划的思路并不难解决，比较难的是后文提出的用分治法求解，但由于其不是最优解法，所以先不列出来<br>
动态规划的是首先对数组进行遍历，当前最大连续子序列和为 sum，结果为 ans<br>
如果 sum &gt; 0，则说明 sum 对结果有增益效果，则 sum 保留并加上当前遍历数字<br>
如果 sum &lt;= 0，则说明 sum 对结果无增益效果，需要舍弃，则 sum 直接更新为当前遍历数字<br>
每次比较 sum 和 ans的大小，将最大值置为ans，遍历结束返回结果<br>
时间复杂度：O(n)<br>
代码</p>
</blockquote>
<pre><code>Java
class Solution {
    public int maxSubArray(int[] nums) {
        int ans = nums[0];
        int sum = 0;
        for(int num: nums) {
            if(sum &gt; 0) {
                sum += num;
            } else {
                sum = num;
            }
            ans = Math.max(ans, sum);
        }
        return ans;
    }
}
</code></pre>
<p>这个思路很有趣，我们一般会想当前元素nums[i]对sum有没有增益，而这个题解要点在于反过来考虑sum对当前元素nums[i]有没有增益</p>
<p>关于分治法我曾经看到一个比较好的题解。。。但是突然找不到了。。。难道是被删了？？？<br>
主要的要点就是</p>
<blockquote>
<p>分治法<br>
这个是使用分治法解决问题的典型的例子，并且可以用与合并排序相似的算法求解。下面是用分治法解决问题的模板：<br>
定义基本情况。<br>
将问题分解为子问题并递归地解决它们。<br>
合并子问题的解以获得原始问题的解。<br>
算法：<br>
当最大子数组有 n 个数字时：<br>
若 n==1，返回此元素。<br>
left_sum 为最大子数组前 n/2 个元素，在索引为 (left + right) / 2 的元素属于左子数组。<br>
right_sum 为最大子数组的右子数组，为最后 n/2 的元素。<br>
cross_sum 是包含左右子数组且含索引 (left + right) / 2 的最大值。</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1577674348344.png" alt=""></p>
<pre><code>class Solution
{
public:
    int maxSubArray(vector&lt;int&gt; &amp;nums)
    {
        //类似寻找最大最小值的题目，初始值一定要定义成理论上的最小最大值
        int result = INT_MIN;
        int numsSize = int(nums.size());
        result = maxSubArrayHelper(nums, 0, numsSize - 1);
        return result;
    }

    int maxSubArrayHelper(vector&lt;int&gt; &amp;nums, int left, int right)
    {
        if (left == right)
        {
            return nums[left];
        }
        int mid = (left + right) / 2;
        int leftSum = maxSubArrayHelper(nums, left, mid);
        //注意这里应是mid + 1，否则left + 1 = right时，会无线循环
        int rightSum = maxSubArrayHelper(nums, mid + 1, right);
        int midSum = findMaxCrossingSubarray(nums, left, mid, right);
        int result = max(leftSum, rightSum);
        result = max(result, midSum);
        return result;
    }

    int findMaxCrossingSubarray(vector&lt;int&gt; &amp;nums, int left, int mid, int right)
    {
        int leftSum = INT_MIN;
        int sum = 0;
        for (int i = mid; i &gt;= left; i--)
        {
            sum += nums[i];
            leftSum = max(leftSum, sum);
        }

        int rightSum = INT_MIN;
        sum = 0;
        //注意这里i = mid + 1，避免重复用到nums[i]
        for (int i = mid + 1; i &lt;= right; i++)
        {
            sum += nums[i];
            rightSum = max(rightSum, sum);
        }
        return (leftSum + rightSum);
    }
};
</code></pre>
<p>注意跨中心的情况需要用贪心法进行计算<br>
始终觉得在这里用分治法怪怪的</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[并发与并行、多核与多线程]]></title>
        <id>https://lixin-ee.github.io//post/bing-fa-yu-bing-xing</id>
        <link href="https://lixin-ee.github.io//post/bing-fa-yu-bing-xing">
        </link>
        <updated>2019-12-30T00:58:20.000Z</updated>
        <content type="html"><![CDATA[<p>今天早上在看muduo的方案介绍事产生了一点疑惑<br>
书中的描述：</p>
<blockquote>
<p>方案5：这间小银行有一个旋转门、一个柜台，每次只允许一名客户办理业务。而且当有人在办理业务时，旋转门是锁住的（计算和IO 在同一线程）。为了维持工作效率，银行要求客户应该尽快办理业务，最好不要在取款的时候打电话去问家里人密码，也不要在通过旋转门的时候停下来系鞋带，这都会阻塞其他堵在门外的客户。如果客户很少，这是很经济且高效的方案；但是如果场地较大（多核），则这种布局就浪费了不少资源，只能并发（concurrent）不能并行（parallel）。如果确实一次办不完，应该离开柜台，到门外等着，等银行通知再来继续办理（分阶段回调）</p>
</blockquote>
<p>我的疑惑就在于：但是如果场地较大（多核），则这种布局就浪费了不少资源，只能<strong>并发(concurrent)</strong> 不能<strong>并行（parallel）</strong>。如果确实一次办不完，应该离开柜台，到门外等着，等银行通知再来继续办理（分阶段回调）</p>
<p>一瞬间我发现我对并发和并行的定义有点模糊了，因为我记得并发不是一个进程分为多个部分或者多个进程或多个线程交替执行吗？但是Reactor执行不是顺序执行的吗？</p>
<p>于是我去查了一下<br>
参考<a href="https://www.zhihu.com/question/33515481">并发与并行的区别？</a></p>
<blockquote>
<p>如果某个系统支持两个或者多个动作（Action）同时存在，那么这个系统就是一个<strong>并发系统</strong>。<br>
如果某个系统支持两个或者多个动作同时执行，那么这个系统就是一个<strong>并行系统</strong>。并发系统与并行系统这两个定义之间的关键差异在于“存在”这个词。<br>
并发和并行都可以是很多个线程，就看这些线程能不能同时被（多个）cpu执行，如果可以就说明是并行，而并发是多个线程被（一个）cpu 轮流切换着执行。<br>
并发就是指代码<strong>逻辑上可以并行</strong>，有并行的潜力，但是<strong>不一定当前是真的</strong>以物理并行的方式运行<br>
并发指的是代码的性质，并行指的是<strong>物理运行状态</strong></p>
</blockquote>
<p>然后是翻查CSAPP中的解释：</p>
<blockquote>
<p>一个逻辑流的执行在时间上与另一个流重叠，称为<strong>并发流（concurrent flow）</strong>，这两个流并发地运行<br>
多个流并发地执行的一般现象称为并发（concurrency）。一个进程和其他进程轮流运行的概念称为多任务（multitasking）。一个进程执行它的控制流的一部分的每一时间段叫做时间片（time slice），因此多任务也叫作时间分片（time slicing）；<br>
并发流的思想与流运行的处理器核数或者计算机数无关。如果两个流在时间上重叠，那么它们就是并发的，它是并发流的一个真子集。如果两个流并发地运行在不同的处理器核或者计算机上，那么我们称它们为<strong>并行流（parallel flow）</strong>，它们并行地运行（running in parallel），且并行地执行。<br>
并行流是并发流的真子集，并行流一定是并发流，并发流不一定是并行流。</p>
</blockquote>
<p>看来我对并发和并行的理解并没有错误啊<br>
那就是对Reactor的理解出现了偏差</p>
<p>然后我回去看了方案6和方案7的描述，发现一个问题</p>
<blockquote>
<p>它为每个请求（而不是每个连接）创建了一个新线程（方案6）<br>
每个连接创建一个计算线程，每个连接上的请求固定发给同一个线程去算（方案7）</p>
</blockquote>
<p>注意 连接-请求-线程 这三者！！！特别是一个连接下可以有多个请求！！！而不是必须一个连接一个请求！！！</p>
<p>那么回到方案5的描述 我们可以看到</p>
<blockquote>
<p>如果确实一次办不完，应该离开柜台，到门外等着，等银行通知再来继续办理（分阶段回调）</p>
</blockquote>
<p>这里就是请求的问题了，注意是等待通知而不是重新排队，相当于在并发运行，所以方案5只能并发不能并行就是这么来的</p>
<p>然后另外一个疑惑就是</p>
<blockquote>
<p>方案7 与方案6 的另外一个区别是单个client 的最大CPU 占用率。在方案6 中，一个TCP 连接上发来的一长串突发请求（burst requests）可以占满全部8 个core；而在方案7 中，由于每个连接上的请求固定由同一个线程处理，那么它最多占用12.5%的CPU 资源。</p>
</blockquote>
<p>这里就确实是我的认知出现了偏差，把 一个cpu当前只能运行一个进程+进程是资源分配的最小单位，线程是CPU调度的最小单位 误理解为 一个进程只能在一个cpu上运行（以为它的多线程也只能分配到这个cpu上）（错误的）<br>
这个明显是错误的，一个进程可以在多个cpu上运行，比如一个进程的多个线程可以在多个cpu上运行，这也就是方案6收到突发性爆炸请求占满cpu和方案7只开了8个线程（注意这里假设8个core）每个只占12.5%的由来<br>
但注意！一个线程是只能在一个cpu上跑的，无法切割开来</p>
<p>参考资料<br>
<img src="https://lixin-ee.github.io//post-images/1577669961214.png" alt=""><br>
方案2 这是传统的Java 网络编程方案thread-per-connection，在Java 1.4 引入NIO 之前，Java 网络服务多采用这种方案。它的初始化开销比方案1 要小很多，但与求解Sudoku 的用时差不多，仍然不适合短连接服务。这种方案的伸缩性受到线程数的限制，一两百个还行，几千个的话对操作系统的scheduler 恐怕是个不小的负担。<br>
方案5 基本的单线程Reactor 方案。这种方案的优点是由网络库搞定数据收发，程序只关心业务逻辑；缺点：适合IO 密集的应用，不太适合CPU 密集的应用，因为较难发挥多核的威力。另外，与方案2 相比，方案5 处理网络消息的延迟可能要略大一些，因为方案2 直接一次read(2) 系统调用就能拿到请求数据，而方案5 要先poll(2) 再read(2)，多了一次系统调用。</p>
<p>方案6 这是一个过渡方案，收到Sudoku 请求之后，不在Reactor 线程计算，而是创建一个新线程去计算，以充分利用多核CPU。这是非常初级的多线程应用，因为它为每个请求（而不是每个连接）创建了一个新线程。这个开销可以用线程池来避免，即方案8。这个方案还有一个特点是out-of-order，即同时创建多个线程去计算同一个连接上收到的多个请求，那么算出结果的次序是不确定的，可能第2 个Sudoku 比较简单，比第1 个先算出结果。这也是我们在一开始设计协议的时候使用了id 的原因，以便客户端区分response 对应的是哪个request。</p>
<p>方案7 为了让返回结果的顺序确定，我们可以为每个连接创建一个计算线程，每个连接上的请求固定发给同一个线程去算，先到先得。这也是一个过渡方案，因为并发连接数受限于线程数目，这个方案或许还不如直接使用阻塞IO 的thread-per-connection 方案2。</p>
<p>方案7 与方案6 的另外一个区别是单个client 的最大CPU 占用率。在方案6 中，一个TCP 连接上发来的一长串突发请求（burst requests）可以占满全部8 个core；而在方案7 中，由于每个连接上的请求固定由同一个线程处理，那么它最多占用12.5%的CPU 资源。这两种方案各有优劣，取决于应用场景的需要（到底是公平性重要还是突发性能重要）。这个区别在方案8 和方案9 中同样存在，需要根据应用来取舍。</p>
<p>方案8 为了弥补方案6 中为每个请求创建线程的缺陷，我们使用固定大小线程池，程序结构如图6-12 所示。全部的IO 工作都在一个Reactor 线程完成，而计算任务交给thread pool。如果计算任务彼此独立，而且IO 的压力不大，那么这种方案是非常适用的。</p>
<p>方案9 这是muduo 内置的多线程方案，也是Netty 内置的多线程方案。这种方案的特点是one loop per thread，有一个main Reactor 负责accept(2) 连接，然后把连接挂在某个sub Reactor 中（muduo 采用round-robin 的方式来选择sub Reactor），这样该连接的所有操作都在那个sub Reactor 所处的线程中完成。多个连接可能被分派到多个线程中，以充分利用CPU。</p>
<p>muduo 采用的是固定大小的Reactor pool，池子的大小通常根据CPU 数目确定，也就是说线程数是固定的，这样程序的总体处理能力不会随连接数增加而下降。另外，由于一个连接完全由一个线程管理，那么请求的顺序性有保证，突发请求也不会占满全部8 个核（如果需要优化突发请求，可以考虑方案11）。这种方案把IO 分派给多个线程，防止出现一个Reactor 的处理能力饱和。</p>
<p>与方案8 的线程池相比，方案9 减少了进出thread pool 的两次上下文切换，在把多个连接分散到多个Reactor 线程之后，小规模计算可以在当前IO 线程完成并发回结果，从而降低响应的延迟。我认为这是一个适应性很强的多线程IO 模型，因此把它作为muduo 的默认线程模型（见图6-13）。</p>
]]></content>
    </entry>
</feed>