<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-02-26T23:45:50.624Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>In the darkest night,Rising like a spire.</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[栈 题30:包含min函数的栈]]></title>
        <id>https://lixin-scut.github.io//post/zhan-ti-30bao-han-min-han-shu-de-zhan</id>
        <link href="https://lixin-scut.github.io//post/zhan-ti-30bao-han-min-han-shu-de-zhan">
        </link>
        <updated>2020-02-26T15:58:57.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。<br>
注意：保证测试中不会当栈为空的时候，对栈调用pop()或者min()或者top()方法。</p>
</blockquote>
<pre><code>class Solution {
public:
    void push(int value) {
        norm_stack.push(value);
        if(min_stack.empty()||value&lt;=min_stack.top())
            min_stack.push(value);
        else if(value&gt;min_stack.top())
            min_stack.push(min_stack.top());
    }
    void pop() {
        if(norm_stack.empty())
            return;
        norm_stack.pop();
        min_stack.pop();
    }
    int top() {
        if(norm_stack.empty())
            return -1;
        return norm_stack.top();
    }
    int min() {
        if(min_stack.empty())
            return -1;
        return min_stack.top();
    }

private:
    stack&lt;int&gt; norm_stack;
    stack&lt;int&gt; min_stack;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 题29:顺时针打印矩阵]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-ti-29shun-shi-zhen-da-yin-ju-zhen</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-ti-29shun-shi-zhen-da-yin-ju-zhen">
        </link>
        <updated>2020-02-25T15:11:48.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述<br>
输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<p>注意要在循环条件中加上范围是否超标的判断</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt; matrix) {
        vector&lt;int&gt; res;
        if(matrix.empty())
               return res;
        int top,bottom,left,right,i;
        top=0,left=0;
        bottom=matrix.size()-1,right=matrix[0].size()-1;
        while(top&lt;=bottom&amp;&amp;left&lt;=right){

                for(i=left;i&lt;=right&amp;&amp;top&lt;=bottom;++i)
                    res.push_back(matrix[top][i]);
                ++top;


                for(i=top;i&lt;=bottom&amp;&amp;left&lt;=right;++i)
                    res.push_back(matrix[i][right]);
                --right;

                for(i=right;i&gt;=left&amp;&amp;top&lt;=bottom;--i)
                    res.push_back(matrix[bottom][i]);
                --bottom;

                for(i=bottom;i&gt;=top&amp;&amp;left&lt;=right;--i)
                    res.push_back(matrix[i][left]);
                ++left;
        }
        return res;
    }
};
</code></pre>
<p>书本题解：<br>
这道题完全没有涉及复杂的数据结构或者高级的算法，看起来是一个 很简单的问题。但实际上解决这个问题时会在代码中包含多个循环，并且 需要判断多个边界条件。<br>
假设这个矩阵的行数是rows,列数是 columns。我们注意到，左上角的坐标中行标和列标总是相同的，于是可 以在矩阵中选取左上角为(start, start)的一圈作为我们分析的目标。<br>
值得注意的是，最后一圈有可能退化成只有一行、只有一列，甚至只有一个数字。<br>
因此，我们要仔细分析打印时每一步的前提条件。第一步总是需要的， 因为打印一圈至少有一步。如果只有一行，那就不用第二步了。也就是需 要第二步的前提条件是终止行号大于起始行号。需要第三步打印的前提条 件是圈内至少有两行两列，也就是说，除了要求终止行号大于起始行号， 还要求终止列号大于起始列号。同理，需要打印第四步的前提条件是至少 有三行两列，因此要求终止行号比起始行号至少大2,同时终止列号大于起始列号。</p>
<pre><code>void PrintMatrixClockwisely(int** numbers, int columns, int rows)
{
    if(numbers == nullptr || columns &lt;= 0 || rows &lt;= 0)
        return;

    int start = 0;

    while(columns &gt; start * 2 &amp;&amp; rows &gt; start * 2)
    {
        PrintMatrixInCircle(numbers, columns, rows, start);

        ++start;
    }
}

void PrintMatrixInCircle(int** numbers, int columns, int rows, int start)
{
    int endX = columns - 1 - start;
    int endY = rows - 1 - start;

    // 从左到右打印一行
    for(int i = start; i &lt;= endX; ++i)
    {
        int number = numbers[start][i];
        printNumber(number);
    }

    // 从上到下打印一列
    if(start &lt; endY)
    {
        for(int i = start + 1; i &lt;= endY; ++i)
        {
            int number = numbers[i][endX];
            printNumber(number);
        }
    }

    // 从右到左打印一行
    if(start &lt; endX &amp;&amp; start &lt; endY)
    {
        for(int i = endX - 1; i &gt;= start; --i)
        {
            int number = numbers[endY][i];
            printNumber(number);
        }
    }

    // 从下到上打印一行
    if(start &lt; endX &amp;&amp; start &lt; endY - 1)
    {
        for(int i = endY - 1; i &gt;= start + 1; --i)
        {
            int number = numbers[i][start];
            printNumber(number);
        }
    }
}

void printNumber(int number)
{
    printf(&quot;%d\t&quot;, number);
}
</code></pre>
<p>对比书本的，我觉得还是我的方法更加简便，所以不能只以书为准，要多看看别人的做法</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[阻止拷贝]]></title>
        <id>https://lixin-scut.github.io//post/zu-zhi-kao-bei</id>
        <link href="https://lixin-scut.github.io//post/zu-zhi-kao-bei">
        </link>
        <updated>2020-02-25T09:32:10.000Z</updated>
        <content type="html"><![CDATA[<p>如何防止一个类被拷贝</p>
<p>1.继承boost::noncopyable<br>
2.将拷贝构造函数和拷贝赋值运算符定义为删除的函数来阻止拷贝<br>
3.在新标准发布前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为private来阻止拷贝的。声明但不定义一个成员函数是合法的，通过声明但不定义的private的拷贝构造函数，我们可以预先阻止任何拷贝该类型的企图，因为任何拷贝操作都会在编译阶段标记为错误的</p>
<p>参考资料：<br>
《C++ primer》<br>
13.1.6阻止拷贝<br>
（大多数类还是应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式地还是显式地）<br>
对于<strong>某些类来说拷贝构造和拷贝赋值是不合理的，比如iostream不应该拷贝</strong>，以避免多个对象写入或读取相同的IO缓冲<br>
在新标准下，我们可以通过将拷贝构造函数和拷贝赋值运算符<strong>定义为删除的函数 来阻止拷贝</strong><br>
删除的函数：虽然声明了它，但是<strong>不能以任何的方式使用它</strong>，在函数的参数列表后面加上=delete来指出我们希望将其定义为删除的<br>
与=default不同，<strong>=delete必须出现在函数第一次声明的时候</strong>，另外我们可以<strong>对任何函数指定=delete</strong>，但=default只能用于合成的默认构造函数或拷贝控制成员<br>
但注意，<strong>析构函数可以使用=delete，但不应该使用，否则就无法销毁此类型的对象了。</strong><br>
对于一个删除了析构函数的类型（或者一个类有某个成员的类型删除了析构函数），编译器将<strong>不允许定义</strong>该类型的变量或临时对象<br>
对于删除了析构函数的类型，我们不能定义变量或成员，但可以<strong>动态分配这种类型的对象，但同时也不能释放这些对象</strong><br>
<img src="https://lixin-scut.github.io//post-images/1582626069588.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582626074458.png" alt=""><br>
这些规则的含义是，<strong>如果类有不能默认构造、拷贝、复制或销毁的数据成员，则对应的成员函数将被定义为删除的</strong><br>
<img src="https://lixin-scut.github.io//post-images/1582626079323.png" alt=""><br>
本质上，当不可能拷贝、赋值或销毁类的成员时，类的合成拷贝控制成员就被定义删除的<br>
在新标准发布前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为private来阻止拷贝的<br>
声明但不定义一个成员函数是合法的，通过声明但不定义的private的拷贝构造函数，我们可以预先阻止任何拷贝该类型的企图，因为任何拷贝操作都会在编译阶段标记为错误的<br>
但在新标准下，应该使用=delete而不是声明为private</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[参数传递的方式]]></title>
        <id>https://lixin-scut.github.io//post/can-shu-chuan-di-de-fang-shi</id>
        <link href="https://lixin-scut.github.io//post/can-shu-chuan-di-de-fang-shi">
        </link>
        <updated>2020-02-25T09:10:50.000Z</updated>
        <content type="html"><![CDATA[<p>形参与实参<br>
形参即形式上的参数，对实参的一种抽象类型描述只是声明一个函数能够接受什么类型的实参，而不确定接受的实参的具体内容是什么<br>
实参即传递给函数对应形参的具体内容</p>
<p>在C++中调用函数时有三种参数传递方式：<br>
（1）传值调用；<br>
（2）传址调用（传指针）；<br>
（3）引用传递；<br>
总体上参数传递可分为两类，由形参的类别决定：值调用（call by value）和引用调用（call by reference）。</p>
<p>这里传址调用被归为值调用，因为指针传递也是值传递，只不过值传递的是地址，所以传址调用可以看作是传引用调用和传值调用的结合</p>
<p>引用，指针，传址使用指南<br>
如果数据对象较小，如内置数据类型或小型结构，则按值传递<br>
如果数据对象是数组，则使用指针，并将指针声明为指向const的指针<br>
如果数据对象是较大的结构，则使用const指针或const引用，以提高运行效率，以减少复制结构所需要的时间和空间<br>
如果数据对象是类对象，则使用const引用，传递类对象参数的标准方式是按引用传递。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[空类]]></title>
        <id>https://lixin-scut.github.io//post/kong-lei</id>
        <link href="https://lixin-scut.github.io//post/kong-lei">
        </link>
        <updated>2020-02-25T08:53:05.000Z</updated>
        <content type="html"><![CDATA[<p>对于空类，编译器不会生成任何的成员函数，只会生成1个字节的占位符（char）。<br>
当空基类被继承后派生类中会取消基类部分的占位符</p>
<ol>
<li>C++空类的大小不为0，不同编译器设置不一样，vs设置为1；</li>
<li>C++标准指出，不允许一个对象（当然包括类对象）的大小为0，不同的对象不能具有相同的地址；</li>
<li>带有虚函数的C++类大小不为1，因为每一个对象会有一个vptr指向虚函数表，具体大小根据指针大小确定；</li>
<li>C++中要求对于类的每个实例都必须有独一无二的地址,那么编译器自动为空类分配一个字节大小，这样便保证了每个实例均有独一无二的内存地址。</li>
</ol>
<p>编译器只会在<strong>需要的时候</strong>生成6个成员函数：<br>
一个构造函数<br>
一个拷贝构造函数<br>
一个析构函数<br>
一个赋值运算符<br>
一对取址运算符</p>
<pre><code>class Empty
{
  public:
    Empty();                            //缺省构造函数
    Empty(const Empty &amp;rhs);            //拷贝构造函数
    ~Empty();                           //析构函数 
    Empty&amp; operator=(const Empty &amp;rhs); //拷贝赋值运算符
    Empty* operator&amp;();                 //取址运算符
    const Empty* operator&amp;() const;     //取址运算符(const版本)
};
</code></pre>
<p>在C++标准中，一个类中即使不显示给出以上这六个成员函数，编译器也会自动合成，但是由于不同的编译器都会有不同程度的优化，他们不一定在任何情况下都会合成这些成员函数，若对于一个构造函数，它既没有参数，在函数内部也不进行任何操作，合成也无任何意义，因此编译器就只会在需要的时候来合成。</p>
<p>以构造函数为例，编译器在四种情况下才会合成默认的构造函数</p>
<ol>
<li>第一种<br>
类A中有自己的默认构造函数，类B中没有，但是类B中包含了类A的对象，这种情况下，为了初始化B类中的A对象，编译器会为B类合成一个默认的构造函数。</li>
<li>第二种<br>
若基类定义了构造函数，而派生类未定义构造函数，在创建派生类对象时，编译器会自动合成派生类的构造函数，目的是为了调用基类的构造函数。</li>
<li>第三种<br>
在虚拟继承体系中，编译器为了将虚基表指针（基类成员变量偏移量表指针）放入派生类对象的前四个字节中，会合成构造函数。</li>
<li>第四种<br>
若基类定义了虚函数，编译器会为其派生类合成构造函数，目的是将虚表指针放入派生类对象的前四个字节。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[const 关键字]]></title>
        <id>https://lixin-scut.github.io//post/const-guan-jian-zi</id>
        <link href="https://lixin-scut.github.io//post/const-guan-jian-zi">
        </link>
        <updated>2020-02-25T08:27:19.000Z</updated>
        <content type="html"><![CDATA[<p>const是一个常量关键字，主要是为了防止所修饰对象被修改。我们在定义一个变量时，如果想要防止这个变量被修改，可以用const来修饰这个变量。也就是说，被const修饰过的变量或者函数，不能对其进行修改，否则，编译器就会报错</p>
<h3 id="修饰全局变量">修饰全局变量</h3>
<pre><code>#define PI1 3.14
const double PI2 = 3.14;
</code></pre>
<p>两种方式都可以用来定义全局变量。不过，第二种要比第一种方式要好，使用宏定义的变量，其信息一般以表格的形式储存在系统中，当我们在调试程序时，就有可能使得这个宏定义的变量反复出现在符号表中。而const修饰的变量会一直出现在符号表，使得我们调试方便许多。</p>
<h3 id="修饰指针">修饰指针</h3>
<pre><code>const int *p1 = 100;   //常量整形指针
int *const p2 = 200;   //整形常量指针
</code></pre>
<p>常量整形指针，不能通过这个指针修改它所指向的变量，指针本身是可变的。整形变量指针，指针不可修改，但是指向的变量可以修改</p>
<h3 id="用于表示函数的输入输出">用于表示函数的输入，输出</h3>
<p><code>char *strcpy(char *buf,const char *str) //将str拷贝给buf</code><br>
由于buf是需要修改的,所以不用const修饰，而str是传递数据进来的，并不希望进行改变，所以可以用const修饰</p>
<h3 id="修饰类成员函数">修饰类成员函数</h3>
<pre><code>class student {
public:
	student(int age) :_age(age) {}
	void getAge()const {      //不希望通过函数来改变类的数据成员
		_age = 100;       //错误，编译器会报警
		cout &lt;&lt; _age &lt;&lt; endl;
	}
private:
	int _age;
};
</code></pre>
<p>如果我们在定义一个类的成员函数时，并不希望这个函数能够改变类的数据成员，这时我们可以使用const将这个成员函数定义为常量函数，这样这个函数就不能修改数据成员了。</p>
<h3 id="mutable">mutable</h3>
<p>mutable 可变数据成员 永远不会是const，即使它是const对象的成员</p>
<pre><code>mutable int acess_num;
void func() const{ ++acess_num;} //记录函数调用次数
</code></pre>
<ol>
<li>如果需要在const成员方法中修改一个成员变量的值，那么需要将这个成员变量修饰为mutable。即用mutable修饰的成员变量不受const成员方法的限制;</li>
<li>可以认为mutable的变量是类的辅助状态，但是只是起到类的一些方面表述的功能，修改他的内容我们可以认为对象的状态本身并没有改变的。实际上由于const_cast的存在，这个概念很多时候用处不是很到了。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 整数、指针、布尔变量、浮点数值如何与 0 比较大小]]></title>
        <id>https://lixin-scut.github.io//post/zheng-shu-zhi-zhen-bu-er-bian-liang-fu-dian-shu-zhi-ru-he-yu-0-bi-jiao-da-xiao</id>
        <link href="https://lixin-scut.github.io//post/zheng-shu-zhi-zhen-bu-er-bian-liang-fu-dian-shu-zhi-ru-he-yu-0-bi-jiao-da-xiao">
        </link>
        <updated>2020-02-25T08:03:40.000Z</updated>
        <content type="html"><![CDATA[<h3 id="布尔变量与零值比较">布尔变量与零值比较</h3>
<p><strong>不可将布尔变量直接与TRUE、FALSE或者1、0进行比较。</strong><br>
根据布尔类型的语义，零值为“假”（记为FALSE），任何非零值都是“真”（记为TRUE）。TRUE的值究竟是什么并没有统一的标准。<br>
例如Visual C++ 将TRUE定义为1，而Visual Basic则将TRUE定义为-1。</p>
<p>假设布尔变量名字为flag，它与零值比较的标准if语句如下：</p>
<pre><code>if (flag) // 表示flag为真
if (!flag) // 表示flag为假
</code></pre>
<p>其它的用法都属于不良风格，例如：</p>
<pre><code>if (flag == TRUE)
if (flag == 1 )
if (flag == FALSE)
if (flag == 0)
</code></pre>
<h3 id="整型变量与零值比较">整型变量与零值比较</h3>
<p><strong>应当将整型变量用“==”或“！=”直接与0比较。</strong><br>
假设整型变量的名字为value，它与零值比较的标准if语句如下：</p>
<pre><code>if (value == 0)
if (value != 0)
</code></pre>
<p>不可模仿布尔变量的风格而写成</p>
<pre><code>if (value) // 会让人误解 value是布尔变量
if (!value)
</code></pre>
<h3 id="浮点变量与零值比较">浮点变量与零值比较</h3>
<p><strong>不可将浮点变量用“==”或“！=”与任何数字比较。</strong><br>
千万要留意，无论是float还是double类型的变量，都有精度限制。所以一定要避免将浮点变量用“==”或“！=”与数字比较，应该设法转化成“&gt; =”或“ &lt;=”形式。<br>
假设浮点变量的名字为x，应当将<br>
<code>if (x == 0.0) // 隐含错误的比较</code><br>
转化为<br>
<code>if ((x&gt; =-EPSINON) &amp;&amp; (x &lt;=EPSINON))</code><br>
其中EPSINON是允许的误差（即精度）。</p>
<h3 id="指针变量与零值比较">指针变量与零值比较</h3>
<p>注意：C++11中已经抛弃了NULL这个模糊的定义，指针有专门的nullptr<br>
<strong>应当将指针变量用“==”或“！=”与NULL比较。</strong><br>
指针变量的零值是“空”（记为NULL）。尽管NULL的值与0相同，但是两者意义不同。假设指针变量的名字为p，它与零值比较的标准if语句如下：</p>
<pre><code>if (p == NULL) // p与NULL显式比较，强调p是指针变量
if (p != NULL)
</code></pre>
<p>不要写成</p>
<pre><code>if (p == 0) // 容易让人误解p是整型变量
if (p != 0)
</code></pre>
<p>或者</p>
<pre><code>if (p) // 容易让人误解p是布尔变量
if (!p)
</code></pre>
<h3 id="对if语句的补充说明重要">对if语句的补充说明（重要）</h3>
<p>有时候我们可能会看到 if (NULL == p) 这样古怪的格式。不是程序写错了，是程序员为了防止将 if (p == NULL) 误写成 if (p = NULL)，而有意把p和NULL颠倒。编译器认为 if (p = NULL) 是合法的，但是会指出 if (NULL = p)是错误的，因为NULL不能被赋值。<br>
程序中有时会遇到if/else/return的组合，应该将如下不良风格的程序</p>
<pre><code>if (condition)
return x;
return y;
</code></pre>
<p>改写为</p>
<pre><code>if (condition)
{
	return x;
}
else
{
	return y;
}
</code></pre>
<p>或者改写成更加简练的<br>
<code>return (condition ? x : y);</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++内存]]></title>
        <id>https://lixin-scut.github.io//post/cnei-cun</id>
        <link href="https://lixin-scut.github.io//post/cnei-cun">
        </link>
        <updated>2020-02-25T07:06:27.000Z</updated>
        <content type="html"><![CDATA[<p>在《C++primer》中没有过多地介绍内存的详情，在《CSAPP》和《现代操作系统》上倒是说得挺多的，然后找到一篇博文概述得特别好特别简洁，一目了然，我就不画蛇添足了。<br>
<a href="https://blog.csdn.net/cherrydreamsover/article/details/81627855">C/C++程序内存的分配</a><br>
另外有一个关于自由存储区的争议，可以参考博文<br>
<a href="https://www.cnblogs.com/QG-whz/p/5060894.html">C++ 自由存储区是否等价于堆？</a></p>
<h3 id="一-一个cc编译的程序占用内存分为以下几个部分">一、一个C/C++编译的程序占用内存分为以下几个部分：</h3>
<ul>
<li>栈区（stack）：由编译器自动分配与释放，存放为运行时函数分配的局部变量、函数参数、返回数据、返回地址等。其操作类似于数据结构中的栈。</li>
<li>堆区（heap）：一般由程序员自动分配，如果程序员没有释放，程序结束时可能有OS回收。其分配类似于链表。</li>
<li>全局区（静态区static）：存放全局变量、静态数据、常量。程序结束后由系统释放。全局区分为已初始化全局区（data）和未初始化全局区（bss）。</li>
<li>常量区（文字常量区）：存放常量字符串，程序结束后有系统释放。</li>
<li>代码区：存放函数体（类成员函数和全局区）的二进制代码。</li>
</ul>
<h3 id="二-三种内存分配方式">二、三种内存分配方式</h3>
<ul>
<li>从静态存储区分配<br>
内存在程序编译的时候已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。</li>
<li>在栈上创建<br>
在执行函数时，函数内局部变量的存储单元可以在栈上创建，函数执行结束时，这些内存单元会自动被释放。<br>
栈内存分配运算内置于处理器的指令集，效率高，但是分配的内存容量有限。</li>
<li>从堆上分配<br>
亦称为动态内存分配。<br>
程序在运行的时候使用malloc或者new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。<br>
动态内存的生命周期有程序员决定，使用非常灵活，但如果在堆上分配了空间，既有责任回收它，否则运行的程序会出现内存泄漏，频繁的分配和释放不同大小的堆空间将会产生内存碎片。</li>
</ul>
<h3 id="三-内存分配简易图">三、内存分配简易图</h3>
<p><img src="https://lixin-scut.github.io//post-images/1582614891622.png" alt=""></p>
<ul>
<li>补充：<br>
在 C 语言中，全局变量又分为初始化的和未初始化的（未被初始化的对象存储区可以通过 void* 来访问和操纵，程序结束后由系统自行释放），在 C++ 里面没有这个区分了，他们共同占用同一块内存区。</li>
</ul>
<h3 id="四-堆和栈的区别">四、堆和栈的区别</h3>
<ul>
<li>管理方式不同：栈是由编译器自动申请和释放空间，堆是需要程序员手动申请和释放；</li>
<li>空间大小不同：栈的空间是有限的，在32位平台下，VC6下默认为1M，堆最大可以到4G；</li>
<li>能否产生碎片：栈和数据结构中的栈原理相同，在弹出一个元素之前，上一个已经弹出了，不会产生碎片，如果不停地调用malloc、free对造成内存碎片很多；<br>
生长方向不同：堆生长方向是向上的，也就是向着内存地址增加的方向，栈刚好相反，向着内存减小的方向生长。</li>
<li>分配方式不同：堆都是动态分配的，没有静态分配的堆。栈有静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由 malloc 函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无需我们手工实现。</li>
<li>分配效率不同：栈的效率比堆高很多。栈是机器系统提供的数据结构，计算机在底层提供栈的支持，分配专门的寄存器来存放栈的地址，压栈出栈都有相应的指令，因此比较快。堆是由库函数提供的，机制很复杂，库函数会按照一定的算法进行搜索内存，因此比较慢。</li>
</ul>
<h3 id="六-静态全局变量-全局变量-静态局部变量-局部变量的区别">六、静态全局变量、全局变量、静态局部变量、局部变量的区别</h3>
<ul>
<li>
<p>静态全局变量、全局变量区别<br>
（1）静态全局变量和全局变量都属于常量区<br>
（2）静态全局区只在本文件中有效，别的文件想调用该变量，是调不了的，而全局变量在别的文件中可以调用<br>
（3）如果别的文件中定义了一个该全局变量相同的变量名，是会出错的。</p>
</li>
<li>
<p>静态局部变量、局部变量的区别<br>
（1）静态局部变量是属于常量区的，而函数内部的局部变量属于栈区；<br>
（2）静态局部变量在该函数调用结束时，不会销毁，而是随整个程序结束而结束，但是别的函数调用不了该变量，局部变量随该函数的结束而结束；<br>
（3）如果定义这两个变量的时候没有初始值时，静态局部变量会自动定义为0，而局部变量就是一个随机值；<br>
（4）静态局部变量在编译期间只赋值一次，以后每次函数调用时，不在赋值，调用上次的函数调用结束时的值。局部变量在调用期间，每调用一次，赋一次值。</p>
</li>
</ul>
<p>关于空闲存储区：</p>
<blockquote>
<p>Free Store<br>
The free store is one of the two dynamic memory areas, allocated/freed by new/delete. Object lifetime can be less than the time the storage is allocated; that is, free store objects can have memory allocated without being immediately initialized, and can be destroyed without the memory being immediately deallocated. During the period when the storage is allocated but outside the object's lifetime, the storage may be accessed and manipulated through a void* but none of the proto-object's nonstatic members or member functions may be accessed, have their addresses taken, or be otherwise manipulated.<br>
Heap<br>
The heap is the other dynamic memory area, allocated/freed by malloc/free and their variants. Note that while the default global new and delete might be implemented in terms of malloc and free by a particular compiler, the heap is not the same as free store and memory allocated in one area cannot be safely deallocated in the other. Memory allocated from the heap can be used for objects of class type by placement-new construction and explicit destruction. If so used, the notes about free store object lifetime apply similarly here.</p>
</blockquote>
<p>从技术上来说，堆（heap）是C语言和操作系统的术语。堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当运行程序调用malloc()时就会从中分配，稍后调用free可把内存交还。而自由存储是C++中通过new和delete动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区。基本上，所有的C++编译器默认使用堆来实现自由存储，也即是缺省的全局运算符new和delete也许会按照malloc和free的方式来被实现，这时藉由new运算符分配的对象，说它在堆上也对，说它在自由存储区上也正确。但程序员也可以通过重载操作符，改用其他内存来实现自由存储，例如全局变量做的对象池，这时自由存储区就区别于堆了。我们所需要记住的就是：<br>
堆是操作系统维护的一块内存，而自由存储是C++中通过new与delete动态分配和释放对象的抽象概念。堆与自由存储区并不等价。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 题28:对称的二叉树]]></title>
        <id>https://lixin-scut.github.io//post/shu-ti-28dui-cheng-de-er-cha-shu</id>
        <link href="https://lixin-scut.github.io//post/shu-ti-28dui-cheng-de-er-cha-shu">
        </link>
        <updated>2020-02-24T15:26:21.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。<br>
/*<br>
struct TreeNode {<br>
int val;<br>
struct TreeNode *left;<br>
struct TreeNode *right;<br>
TreeNode(int x) :<br>
val(x), left(NULL), right(NULL) {<br>
}<br>
};<br>
*/</p>
</blockquote>
<p>需要注意的点是其实可以重载原函数，提高代码的可读性</p>
<pre><code>class Solution {
public:
    bool isSymmetrical(TreeNode* pRoot)
    {
        if(pRoot==NULL)
            return true;
        return isSymmetrical(pRoot-&gt;left,pRoot-&gt;right);
    }
    
    bool isSymmetrical(TreeNode* cur1,TreeNode* cur2)
    {
        if(cur1==NULL&amp;&amp;cur2==NULL)
            return true;
        if(cur1==NULL||cur2==NULL)
            return false;
        if(cur1-&gt;val!=cur2-&gt;val)
            return false;
        return isSymmetrical(cur1-&gt;left,cur2-&gt;right)&amp;&amp;isSymmetrical(cur1-&gt;right,cur2-&gt;left);
    }
};
</code></pre>
<p>书本题解：<br>
通常我们有3种不同的二叉树遍历算法，即前序遍历、中序遍历和后 序遍历。在这3种遍历算法中，都是先遍历左子节点再遍历右子节点。我 们是否可以定义一种遍历算法，先遍历右子节点再遍历左子节点？比如我 们针对前序遍历定义一种对称的遍历算法，即先遍历父节点，再遍历它的 右子节点，最后遍历它的左子节点。<br>
我们发现可以通过比较二叉树的前序遍历序列和对称前序遍历序列 来判断二叉树是不是对称的。如果两个序列是一样的，那么二叉树就是对称的。</p>
<pre><code>bool isSymmetrical(BinaryTreeNode* pRoot)
{
    return isSymmetrical(pRoot, pRoot);
}

bool isSymmetrical(BinaryTreeNode* pRoot1, BinaryTreeNode* pRoot2)
{
    if(pRoot1 == nullptr &amp;&amp; pRoot2 == nullptr)
        return true;

    if(pRoot1 == nullptr || pRoot2 == nullptr)
        return false;

    if(pRoot1-&gt;m_nValue != pRoot2-&gt;m_nValue)
        return false;

    return isSymmetrical(pRoot1-&gt;m_pLeft, pRoot2-&gt;m_pRight)
        &amp;&amp; isSymmetrical(pRoot1-&gt;m_pRight, pRoot2-&gt;m_pLeft);
}
</code></pre>
<p>我的思路和书本的一致，但是需要将NULL改为nullptr，这样符合C++11标准</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 指针和引用的区别]]></title>
        <id>https://lixin-scut.github.io//post/zhi-zhen-he-yin-yong-de-qu-bie</id>
        <link href="https://lixin-scut.github.io//post/zhi-zhen-he-yin-yong-de-qu-bie">
        </link>
        <updated>2020-02-24T13:07:58.000Z</updated>
        <content type="html"><![CDATA[<p>首先先贴上以前的博文：<br>
<a href="https://lixin-scut.github.io/post/cyin-yong-de-ben-zhi/">C++引用的本质</a><br>
这篇博文还是比较乱的，图和源代码都找不到了，不过中心思想很简洁，就是<br>
引用就是一个常量指针</p>
<p>但是因为缺乏源代码，所以还是显得比较模糊，还是找博客了解一下</p>
<p>摘自：<a href="https://blog.csdn.net/lyd_253261362/article/details/4323691">指针和引用的联系与区别</a><br>
★ 相同点：</p>
<ol>
<li>都是地址的概念；<br>
指针指向一块内存，它的内容是所指内存的地址；引用是某块内存的别名。<br>
★ 区别：</li>
<li>指针是一个实体，而引用仅是个别名；</li>
<li>引用使用时无需解引用(*)，指针需要解引用；</li>
<li>引用只能在定义时被初始化一次，之后不可变；指针可变；</li>
<li>引用没有 const，指针有 const；</li>
<li>引用不能为空，指针可以为空；</li>
<li>“sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身(所指向的变量或对象的地址)的大小；</li>
<li>指针和引用的自增(++)运算意义不一样；</li>
<li>从内存分配上看：程序为指针变量分配内存区域，而引用不需要分配内存区域。<br>
★ 联系
<ol>
<li>引用在语言内部用指针实现（如何实现？）。</li>
<li>对一般应用而言，把引用理解为指针，不会犯严重语义错误。引用是操作受限了的指针（仅容许取内容操作）。<br>
★ 总结<br>
总的来说，在以下情况下你应该使用指针，一是你考虑到存在不指向任何对象的可能（在这种情况下，你能够设置指针为空），二是你需要能够在不同的时刻指向不同的对象（在这种情况下，你能改变指针的指向）。<br>
如果总是指向一个对象并且一旦指向一个对象后就不会改变指向，那么你应该使用引用。<br>
还有一种情况，就是当你重载某个操作符时，你应该使用引用。最普通的例子是操作符[].这个操作符典型的用法是返回一个目标对象，其能被赋值。<br>
尽可能使用引用，不得已时使用指针。<br>
当你不需要“重新指向”时，引用一般优先于指针被选用。这通常意味着引用用于类的公有接口时更有用。引用出现的典型场合是对象的表面，而指针用于对象内部。<br>
上述的例外情况是函数的参数或返回值需要一个“临界”的引用时。这时通常最好返回/获取一个指针，并使用 NULL 指针来完成这个特殊的使命。（引用应该总是对象的别名，而不是被解除引用的 NULL 指针。</li>
</ol>
</li>
</ol>
<p>但是我个人有一个疑惑：引用到底占不占空间？仅仅是一个别名吗？</p>
<p>然后读取了下面的博客<br>
<a href="https://blog.csdn.net/k346k346/article/details/46805159">C++ 引用的本质</a><br>
<a href="https://www.cnblogs.com/karottc/p/cpp-reference.html">C++的引用类型的变量到底占不占用内存空间？</a><br>
可以看出引用确实是一个指针，而且是一个常量指针，只是我们无法直接获得这个指针，导致它似乎是不存在的</p>
]]></content>
    </entry>
</feed>