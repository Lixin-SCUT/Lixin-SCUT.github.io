<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-10-15T11:37:48.395Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[关于istringstream等输入流]]></title>
        <id>https://lixin-ee.github.io//post/guan-yu-istringstream-deng-shu-ru-liu</id>
        <link href="https://lixin-ee.github.io//post/guan-yu-istringstream-deng-shu-ru-liu">
        </link>
        <updated>2019-10-15T11:32:18.000Z</updated>
        <content type="html"><![CDATA[<p>今天做题时<a href="https://lixin-ee.github.io/post/math-165-bi-jiao-ban-ben-hao/">版本号比较</a>遇到一个题解</p>
<pre><code>class Solution {
public:
    int compareVersion(string version1, string version2) {
        char c;
        int v1,v2;
        istringstream its1(version1);
        istringstream its2(version2);
        
        while(bool(its1&gt;&gt;v1) + bool(its2&gt;&gt;v2)){
            if(v1&gt;v2) return 1;
            if(v1&lt;v2) return -1;
            
            v1=0;
            v2=0;
            its1&gt;&gt;c;
            its2&gt;&gt;c;
            
        }
        
        return 0;
    }
};
</code></pre>
<p>输入是 输入: version1 = &quot;7.5.2.4&quot;, version2 = &quot;7.5.3&quot;<br>
一开始百思不得其解，为何会自动以点号为分割？同时为何会自动去掉前置0？<br>
受到评论指引，才发现原来v1和v2可是int类型！<br>
所以在这里可以看出，isrtringstream或者说输入流，都会按照赋值的类型来读取分割，比如如果是赋值给float，则会读入第一个点号，而忽略第二个点号。<br>
而istringstream的string意为将一个string作为读入字符串（类似于cin的缓冲区），而不是说istringstream只能赋值给string。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MATH 165. 比较版本号]]></title>
        <id>https://lixin-ee.github.io//post/math-165-bi-jiao-ban-ben-hao</id>
        <link href="https://lixin-ee.github.io//post/math-165-bi-jiao-ban-ben-hao">
        </link>
        <updated>2019-10-15T10:49:02.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>比较两个版本号 version1 和 version2。<br>
如果 version1 &gt; version2 返回 1，如果 version1 &lt; version2 返回 -1， 除此之外返回 0。<br>
你可以假设版本字符串非空，并且只包含数字和 . 字符。<br>
 &gt; . 字符不代表小数点，而是用于分隔数字序列。<br>
例如，2.5 不是“两个半”，也不是“差一半到三”，而是第二版中的第五个小版本。<br>
你可以假设版本号的每一级的默认修订版号为 0。例如，版本号 3.4 的第一级（大版本）和第二级（小版本）修订号分别为 3 和 4。其第三级和第四级修订号均为 0。</p>
<p>示例 1:<br>
输入: version1 = &quot;0.1&quot;, version2 = &quot;1.1&quot;<br>
输出: -1<br>
示例 2:<br>
输入: version1 = &quot;1.0.1&quot;, version2 = &quot;1&quot;<br>
输出: 1<br>
示例 3:<br>
输入: version1 = &quot;7.5.2.4&quot;, version2 = &quot;7.5.3&quot;<br>
输出: -1<br>
示例 4：<br>
输入：version1 = &quot;1.01&quot;, version2 = &quot;1.001&quot;<br>
输出：0<br>
解释：忽略前导零，“01” 和 “001” 表示相同的数字 “1”。<br>
示例 5：<br>
输入：version1 = &quot;1.0&quot;, version2 = &quot;1.0.0&quot;<br>
输出：0<br>
解释：version1 没有第三级修订号，这意味着它的第三级修订号默认为 “0”。<br>
 <br>
提示：<br>
版本字符串由以点 （.） 分隔的数字字符串组成。这个数字字符串可能有前导零。<br>
版本字符串不以点开始或结束，并且其中不会有两个连续的点。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/compare-version-numbers<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>一开始的想法是先分析一下难点<br>
1.靠点号分割的话，位数不同<br>
2.会有前导0<br>
然后思考一下处理方式<br>
1.利用find函数进行点号分割，分割之后可以当场进行对比，或者存进容器里面进行对比。前者需要对首先对长度进行对比，后者的话可以通过push_back来补充位数<br>
2.前导0的处理方法 一个是find函数检测并去掉多余的0，一个是转化为int自动去掉，最后一个则是在对应的数前面补0，比如02和1对比，就向1补0，使得02和01对比。<br>
最后为了代码的可读性，我选择了vector补位+补0</p>
<pre><code>class Solution {
public:
    int compareVersion(string version1, string version2) {
        vector&lt;string&gt; v1,v2;
        split(version1,v1);
        split(version2,v2);
        int len=0;
        if(v1.size()&gt;v2.size()){
            len=v1.size()-v2.size();
            while(len)
                --len,v2.push_back(&quot;0&quot;);
        }
        else{
            len=v2.size()-v1.size();
            while(len)
                --len,v1.push_back(&quot;0&quot;);
        }
        for(int i=0;i&lt;v1.size();++i ){
            if(v1[i].size()&gt;v2[i].size()){
                 len=v1[i].size()-v2[i].size();;
                 while(len)
                    --len,v2[i]=&quot;0&quot;+v2[i];
             }
              else{
                 len=v2[i].size()-v1[i].size();
                 while(len)
                    --len,v1[i]=&quot;0&quot;+v1[i];
             }
            if(v1[i]&gt;v2[i])
                return 1;
            else if (v1[i]&lt;v2[i])
                return -1;
        }
            
          return 0;        
    }
    
    void split(string &amp;version,vector&lt;string&gt; &amp;v){
        char comma='.';
        for(int i=0;i&lt;version.size();){
            int j=version.find(comma,i);
            if(j==string::npos){
                v.push_back(version.substr(i,version.size()-i));
                break;
            }              
            v.push_back(version.substr(i,j-i));
            i=j+1;
        }
    }   
};
</code></pre>
<p>这道题有个很明显的问题是代码比较臃肿，重复代码太多，所以我把分割操作合成一个函数了，可读性明显高了很多<br>
然后高赞网友题解都类似，都是点号分解<br>
最后是有个比较秀的操作：</p>
<pre><code>class Solution {
public:
    int compareVersion(string version1, string version2) {
        char c;
        int v1,v2;
        istringstream its1(version1);
        istringstream its2(version2);
        
        while(bool(its1&gt;&gt;v1) + bool(its2&gt;&gt;v2)){
            if(v1&gt;v2) return 1;
            if(v1&lt;v2) return -1;
            
            v1=0;
            v2=0;
            its1&gt;&gt;c;
            its2&gt;&gt;c;
            
        }
        
        return 0;
    }
};
</code></pre>
<p>注意是把 istringstream 强行输入赋值给int，此时输入流会强制读取一个符合int格式的string值，所以输入流会以点号为结束符，并且将其自动转化为int类型，也就同时完成了分割和去掉前置0两个任务，所以代码非常简单，只是需要仔细研究一下才好。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第十一章 笔记+习题 11.3-11.4]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-yi-zhang-bi-ji-xi-ti-113-114</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-yi-zhang-bi-ji-xi-ti-113-114">
        </link>
        <updated>2019-10-14T03:06:22.000Z</updated>
        <content type="html"><![CDATA[<p>11.3关联容器操作<br>
map的value_type为<code>pair&lt;const key_type,mapped_type&gt;</code><br>
我们不能改变pair中的关键字，因此这些pair的关键字部分是const的（set中的关键字也是const的）<br>
只有map类型才能定义mapped_type</p>
<p>11.3.1关联容器迭代器<br>
一个map 的value_type是一个pair，我们可以改变pair的值，但是不能改变关键字成员的值<br>
虽然map和set类型同时定义了iterator和const_iterator两种类型，但两种类型都只允许只读访问set中的元素，<strong>set的关键字是const的，set的迭代器也是const的</strong>。<br>
map和set类型都支持表9.2（p295）中的begin和end操作<br>
当时用一个迭代器遍历一个map、multimap、set或multiset时，迭代器按关键字升序遍历元素<br>
我们通常<strong>不对关联容器使用泛型算法</strong>，因为关键字是const，不能将关联容器传递给修改或重排容器元素的算法<br>
关联容器中的元素不<strong>能通过它们的关键字进行快速查找</strong>，所以使用关联容器定义的专用的find成员会比调用泛型find快得多<br>
在实际编程中，如果我们真要对一个关联容器使用算法，要么将它当做一个<strong>源序列</strong>，要么当做一个<strong>目的位置</strong><br>
迭代器的类型需要在iterator或者const_iterator加上类类型，比如map&lt;const string, size_t&gt;::const_iterator<br>
map和set中的 key_type其实都会自动加上const但是在声明类型时不需要加上，比如Sales_Data，除非是像map_it那样显式声明。只需要注意使用auto或者decltype时会自动加上const<br>
关联容器的迭代器时双向迭代器（由红黑树决定），只能进行相等不等的比较，无法进行小于的比较！！！</p>
<p>习题11.15<br>
value_type为 pair<code>&lt;int,vector&lt;int&gt;&gt;</code> key_type为int mapped_type为vector<br>
习题11.16</p>
<pre><code>	map&lt;string, int&gt; map_si{ {&quot;123&quot;,123} };
	(*map_si.begin()).second = 321;
</code></pre>
<p>注意的点：map的迭代器不能直接解引用就赋值，还是需要.second，然后第二个调用前的括号必不可少，第一个调用则不需要括号<br>
习题11.17<br>
（1）不合法，显示error type，因为关联容器的迭代器时const的，不能进行写操作<br>
（2）同上<br>
（3）（4）合法<br>
习题11.18<br>
注意不是<code>const_iterator&lt;map&lt;const string ,size_t&gt;&gt;</code>！<br>
而是<code>map&lt;const string, size_t&gt;::const_iterator</code><br>
需要在iterator或者const_iterator加上类类型， 比如string、map、vector等等<br>
习题11.19<br>
<code>multiset&lt;Sales_Data, bool(*)(const Sales_Data &amp;lhs, const Sales_Data &amp;rhs)&gt;::iterator mi=bookstore.begin();</code><br>
注意 map和set中的 key_type其实都会自动加上const但是在声明类型时不需要加上，比如Sales_Data，除非是像map_it那样显式声明。只需要注意使用decltype时会自动加上const，但是auto不会（auto忽略顶层const）</p>
<p>11.3.2添加元素<br>
向map和set插入一个已存在的元素没有任何影响<br>
insert有两个版本，分别接受一对迭代器，或是一个初始化器列表，对于一个给定的关键字，只有第一个带此关键字的元素才会被插入到容器中（<strong>对于map很重要</strong>，比如{{1,a}{1,b}}两者之间谁能插入）<br>
insert和emplace的返回值依赖于容器的类型和参数，对于不包含重复关键字的容器返回一个pair，告诉我们插入操作是否成功。返回的pair的first成员是一个迭代器，指向具有给定关键字（插入值）的元素，second成员是一个bool值，指出元素是插入成功还是已经存在于容器中。如果关键字插入失败，返回值为false，否则返回为true<br>
对于允许重复关键字的容器，接受单个元素的insert操作返回一个指向新元素的迭代器，这里无须返回一个bool值</p>
<p>习题11.20</p>
<pre><code>int main()
{
	map&lt;string, size_t&gt; word_count;
	string word;
	while (cin &gt;&gt; word)
		if (!word_count.insert(make_pair(word, 1)).second)
			++word_count[word];
}
</code></pre>
<p>insert更加容易编写阅读，因为下标运算符会强行将元素添加进去<br>
习题11.21<br>
将单词插入到map中，并在键值中记录单词出现的次数<br>
习题11.22<br>
参数类型<code>pair&lt;const string,vector&lt;int&gt;&gt;</code><br>
返回类型<code>pair&lt;map&lt;string,vector&lt;int&gt;&gt;::iterator,bool&gt;</code><br>
习题11.23</p>
<pre><code>int main()
{
	multimap&lt;string, vector&lt;string&gt;&gt; map_name;
	string first_name, last_name;
	while (cin) {
		cin &gt;&gt; first_name &gt;&gt; last_name;	
		map_name.insert({ first_name,{ last_name } });
	}
}
</code></pre>
<p>11.3.3删除新元素<br>
关联容器定义有三个版本的erase<br>
注意c.erase(b,e)不包括e 是左闭右开区间 insert中也是<br>
erase可以接受一个key_type参数，此版本删除所有匹配给定关键字的元素，返回实际删除的元素的数量</p>
<p>11.3.4map的下标操作<br>
map和unordered_map提供下标运算符和对应的at函数，返回的是second值<br>
set类型不支持下标和at()（或者说不需要）<br>
multimap和unordered_map不支持下标操作，因为有多个值与一个关键字相关联<br>
map下标运算符接受一个索引，获取与此关键字相关联的值，但是注意！！！如果关键字并不在map，会为它创建一个元素插入map中，并对关联值进行值初始化<br>
对关键字会强行加上顶层const<br>
由于下标运算符可能插入一个新元素，所以只可以对非const的map使用下标操作<br>
与vector和string不同，map下标运算符返回的类型与解引用map迭代器返回的类型不同，下标操作得到mapped_type对象，解引用迭代器得到一个value_type对象</p>
<p>习题11.24<br>
如果m中有关键字0，则将second改成1，否则向m插入{0，1}<br>
习题11.25<br>
vector的下标必须先构造，否则就是非法访问<br>
习题11.26<br>
map&lt;string,int&gt;中，下标操作的类型必须是string，返回类型是int，亦即key_type对其执行下标操作，mapped_type为其返回类型</p>
<p>11.3.5访问元素<br>
使用下标操作有一个严重的副作用，如果关键字还未在map中，下标操作会插入一个具有给定关键字的元素<br>
find bound都是返回迭代器<br>
使用find就可以值检查给定关键字是否在map中<br>
multimap和multiset中具有相同关键字的元素在容器中会相邻存储，需要配合cout和find使用（find一次只能找到一个！！！）<br>
lower_bound和upper_bound这两个操作都接受一个关键字，返回一个迭代器。lower_bound返回指向第一个给定关键字的迭代器，upper_bound返回指向最后一个匹配给定关键字的元素之后的位置的迭代器。如果寻找不到，则返回相同迭代器，指向不影响排序的关键字插入位置<br>
equal_range接受一个关键字，返回一个迭代器pair，若关键字存在，则第一个迭代器指向第一个匹配的元素，第二个迭代器指向最后一个匹配元素之后的位置。如果不存在，则指向相同位置（亦即返回左闭右开区间）</p>
<p>习题11.27<br>
需要计算相同元素的数量时使用count，需要判断元素是否存在时使用find<br>
习题11.28<br>
<code>map&lt;string,vector&lt;int&gt;&gt;::iterator ite;</code><br>
习题 11.29<br>
upper和lower返回同一个值，指向不影响排序的关键字插入位置<br>
equal_range如果不存在，则返回一对指向相同位置迭代器的pair<br>
习题11.30<br>
pos是一个pair 里面是一对迭代器，first是左边迭代器，second则是这个迭代器的值<br>
习题11.31</p>
<pre><code>int main()
{
	multimap&lt;string, string&gt; multim{ {&quot;123&quot;,&quot;456&quot;} ,{ &quot;123&quot;,&quot;456&quot; } ,{ &quot;123&quot;,&quot;456&quot; } ,{ &quot;123&quot;,&quot;456&quot; } };
	string name=&quot;123&quot;, product;
	if (multim.find(name) != multim.end())
		multim.erase(name);
	cout &lt;&lt; multim.empty();
}
</code></pre>
<p>习题11.32</p>
<pre><code>int main()
{
	multimap&lt;string, string&gt; multim{ {&quot;123&quot;,&quot;1&quot;} ,{ &quot;123&quot;,&quot;2&quot; } ,{ &quot;456&quot;,&quot;1&quot; } ,{ &quot;123&quot;,&quot;1&quot; } };
	string name=&quot;123&quot;, product;
	for (auto left = multim.begin(); left != multim.end();) {
		auto right = multim.upper_bound((*left).first);
		cout &lt;&lt; (*left).first &lt;&lt; &quot; &quot;;
		while (left != right) {
			cout &lt;&lt; (*left).second &lt;&lt; &quot; &quot;;
			++left;
		}
		cout &lt;&lt; endl;
	}
}
</code></pre>
<p>习题感悟：关联容器的迭代器时双向迭代器（由红黑树决定），只能进行相等不等的比较，无法进行小于的比较！！！</p>
<p>11.3.6一个单词转换map<br>
习题11.33<br>
直接仿真了书中代码hhh<br>
习题11.34<br>
如果没找到的话反而会将当前关键值插入map，并且值为空<br>
习题11.35<br>
如果有重复关键值，则只保存最早的一个，否则就不断更新，无重复关键值的话无差别<br>
习题11.36<br>
不影响，因为对value.size()进行了判断，如果只要空格的话是会报错的</p>
<p>11.4无序容器<br>
注意<strong>顺序容器对应无序容器，关联容器不等同于无序容器</strong><br>
新标准定义了4个无序关联容器，无序容器不是使用比较运算符来组织元素，而是使用一个哈希函数，和关键字类型的==运算符<br>
如果关键字类型固有就是无序的，或者性能测试发现问题可以用哈希技术解决，就可以使用无序容器<br>
无序容器提供了与有序容器相同的操作（find、insert等），所以unordered_map和unordered_set也可以使用这些操作<br>
无序容器也有允许重复关键字的版本<br>
<strong>通常可以用一个无序容器替换对相应的有序容器，反之亦然</strong><br>
无序容器在存储组织上为<strong>一组桶</strong>，每个桶保存零个或多个元素，无序容器使用一个哈希函数将元素映射到桶，容器首先计算元素的哈希值，并将<strong>具有一个特定哈希值的所有元素都保存在相同的桶中</strong>，所有具有相同关键字的元素都会在同一个桶中，因此无序容器的性能依赖于<strong>哈希函数的质量和桶的数量和大小</strong><br>
对于相同的参数，哈希函数总是产生相同的结果<br>
将不同关键字映射到相同的桶也是允许的，当一个桶保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个</p>
<p>默认情况下无序容器使用关键字类型的==运算符来比较元素，还是用一个hash&lt;key_type&gt;类型来生成每个元素的哈希值，标准库为内置类型包括指针提供了hash模板</p>
<p>习题11.37<br>
无序版本优势：当容器中key没有明显的顺序关系时更有用,且不需要耗费多余的时间来维护容器中的key序列<br>
有序版本优势：当容器中key有明显的顺序关系时更有用,且我们不需要考虑排序问题,容器自动维护序列(字典序)<br>
习题11.38</p>
<pre><code>int main()
{
	unordered_map&lt;string, size_t&gt; word_count;
	string word;
	while (cin &gt;&gt; word)
		if (!word_count.insert(make_pair(word, 1)).second)
			++word_count[word];
	for (const auto &amp;w : word_count)
		cout &lt;&lt; w.first &lt;&lt; &quot; &quot; &lt;&lt; w.second &lt;&lt; endl;
}
</code></pre>
<p>通常可以用一个无序容器替换对相应的有序容器，反之亦然，内部的处理方式不同，外部的操作还是大同小异</p>
<p>习题感悟<br>
迭代器的类型需要在iterator或者const_iterator加上类类型， 比如string、map、vector等等<br>
map和set中的 key_type其实都会自动加上const但是在声明类型时不需要加上，比如Sales_Data，除非是像map_it那样显式声明。只需要注意使用decltype时会自动加上const，但是auto不会（auto忽略顶层const）<br>
关联容器的迭代器时双向迭代器（由红黑树决定），只能进行相等不等的比较，无法进行小于的比较！！！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math 7. 整数反转]]></title>
        <id>https://lixin-ee.github.io//post/math-7-zheng-shu-fan-zhuan</id>
        <link href="https://lixin-ee.github.io//post/math-7-zheng-shu-fan-zhuan">
        </link>
        <updated>2019-10-14T02:40:28.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<p>示例 1:<br>
输入: 123<br>
输出: 321<br>
 示例 2:<br>
输入: -123<br>
输出: -321<br>
示例 3:<br>
输入: 120<br>
输出: 21<br>
注意:<br>
假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 <code>[−2^31,  2^31 − 1]</code>。请根据这个假设，如果反转后整数溢出那么就返回 0。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/reverse-integer<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题的难处在于<br>
1.负数的处理，并且负数能表示的位置比正数多一位<br>
2.末尾0的处理，反转后需要去除多余的0</p>
<p>其实主要就两种方法，一种是整数的整十除法，另一种就是转化为字符串进行操作。我偷懒就使用了字符串的方法，反转、判断溢出和对末尾0的处理方便很多，但是对于负数的处理比较麻烦，需要将-2^31单独判断一次。<br>
代码如下：</p>
<pre><code>class Solution {
public:
    int reverse(int x) {
        bool neg=false;
        if(x==-2147483648)
            return 0;
        if(x&lt;0){
            neg=true;
            x=-x;
        }
        string num_s=to_string(x);
        auto left=num_s.begin();
        auto right=num_s.end()-1;
        while(left&lt;right)
            iter_swap(left++,right--);
        if(num_s.size()==10){
            if(neg){
                 if(num_s&gt;&quot;2147483648&quot;)
                    return 0;
            }     
            else{
                if(num_s&gt;&quot;2147483647&quot;)
                    return 0;
            }           
        }        
        x=stoi(num_s);
        if(neg)
            x=-x;
        return x;
    }
};
</code></pre>
<p>可以看到代码不够优雅啊，而且其实字符串和整数的转换是需要比较多的库函数的。<br>
接下来看看官方题解：</p>
<blockquote>
<p>方法：弹出和推入数字 &amp; 溢出前进行检查<br>
思路<br>
我们可以一次构建反转整数的一位数字。在这样做的时候，我们可以预先检查向原整数附加另一位数字是否会导致溢出。</p>
<p>算法<br>
反转整数的方法可以与反转字符串进行类比。<br>
我们想重复“弹出” x 的最后一位数字，并将它“推入”到 rev 的后面。最后，rev 将与 x 相反。<br>
要在没有辅助堆栈 / 数组的帮助下 “弹出” 和 “推入” 数字，我们可以使用数学方法。</p>
</blockquote>
<pre><code>//pop operation:
pop = x % 10;
x /= 10;

//push operation:
temp = rev * 10 + pop;
rev = temp;
</code></pre>
<blockquote>
<p>但是，这种方法很危险，因为当 temp=rev⋅10+pop 时会导致溢出。<br>
幸运的是，事先检查这个语句是否会导致溢出很容易。<br>
为了便于解释，我们假设 rev 是正数。<br>
如果 temp=rev⋅10+pop 导致溢出，那么一定有rev≥ INTMAX/10<br>
如果 rev&gt; INTMAX/10，那么temp=rev⋅10+pop 一定会溢出。<br>
如果 rev== INTMAX/10，那么只要 pop&gt;7，temp=rev⋅10+pop 就会溢出。<br>
当 rev 为负时可以应用类似的逻辑。</p>
</blockquote>
<pre><code>class Solution {
public:
    int reverse(int x) {
        int rev = 0;
        while (x != 0) {
            int pop = x % 10;
            x /= 10;
            if (rev &gt; INT_MAX/10 || (rev == INT_MAX / 10 &amp;&amp; pop &gt; 7)) return 0;
            if (rev &lt; INT_MIN/10 || (rev == INT_MIN / 10 &amp;&amp; pop &lt; -8)) return 0;
            rev = rev * 10 + pop;
        }
        return rev;
    }
};
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(log(x))，x 中大约有log_10(x) 位数字。<br>
空间复杂度：O(1)</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 273. 整数转换英文表示]]></title>
        <id>https://lixin-ee.github.io//post/zi-fu-chuan-273-zheng-shu-zhuan-huan-ying-wen-biao-shi</id>
        <link href="https://lixin-ee.github.io//post/zi-fu-chuan-273-zheng-shu-zhuan-huan-ying-wen-biao-shi">
        </link>
        <updated>2019-10-13T13:01:49.000Z</updated>
        <content type="html"><![CDATA[<p>难度 困难</p>
<pre><code>将非负整数转换为其对应的英文表示。可以保证给定输入小于 2^31 - 1 。

示例 1:
输入: 123
输出: &quot;One Hundred Twenty Three&quot;
示例 2:
输入: 12345
输出: &quot;Twelve Thousand Three Hundred Forty Five&quot;
示例 3:
输入: 1234567
输出: &quot;One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven&quot;
示例 4:
输入: 1234567891
输出: &quot;One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One&quot;

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/integer-to-english-words
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
</code></pre>
<p>这道题一开始还是蛮难的，我的初步想法是依靠英文数字的特性，把数字切割为每三位的格式，再添加每三位之间的词。<br>
但是由于数字和字符串两者都不好从左到右处理位数的问题，所以我首先把数字转为字符串，然后补全到3的倍数，再进行切割，以逆序放入vector，比如123456789，最后得到{&quot;789&quot;,&quot;456&quot;,&quot;123&quot;}<br>
然后进行循环，对每个部分进行翻译和添加词汇<br>
先把最后代码放出来吧</p>
<pre><code>class Solution {
public:
#include &lt;iostream&gt;
    string numberToWords(int num) {
        if(!num)
            return &quot;Zero&quot;;
        string num_s=to_string(num);
        int len=num_s.size();
        vector&lt;string&gt; units{&quot;&quot;,&quot; Thousand&quot;,&quot; Million&quot;,&quot; Billion&quot;};
        vector&lt;string&gt; bits{&quot; One&quot;,&quot; Two&quot;,&quot; Three&quot;,&quot; Four&quot;,&quot; Five&quot;,&quot; Six&quot;,&quot; Seven&quot;,&quot; Eight&quot;,&quot; Nine&quot;};
        vector&lt;string&gt; tens_sp{&quot; Ten&quot;,&quot; Eleven&quot;,&quot; Twelve&quot;,&quot; Thirteen&quot;,&quot; Fourteen&quot;,&quot; Fifteen&quot;,&quot; Sixteen&quot;,&quot; Seventeen&quot;,&quot; Eighteen&quot;,&quot; Nineteen&quot;};
        vector&lt;string&gt; tens{&quot; Twenty&quot;,&quot; Thirty&quot;,&quot; Forty&quot;,&quot; Fifty&quot;,&quot; Sixty&quot;,&quot; Seventy&quot;,&quot; Eighty&quot;,&quot; Ninety&quot;};
        int time=len/3;
        if(time*3&lt;len){
            ++time;    
            while(len&lt;time*3)
                num_s=&quot;0&quot;+num_s,++len;    
        }
        vector&lt;string&gt; three_part;
        while(time&gt;0)
            three_part.push_back(num_s.substr(--time*3,3));
        string res;
        for(int i=0;i&lt;three_part.size();++i){
            string temp;
            if(stoi(three_part[i])==0)
                     continue;
             if(three_part[i][0]!='0'){
                temp+=bits[three_part[i][0]-'1']+&quot; Hundred&quot;;
             }
             if(three_part[i][1]!='0'){
                 if(three_part[i][1]=='1'){
                     temp+=tens_sp[three_part[i][2]-'0']+units[i];
                     res=temp+res;
                     continue;
                 } 
                 temp+=tens[three_part[i][1]-'2'];
             }
             if(three_part[i][2]!='0')
                 temp+=bits[three_part[i][2]-'1'];
            res=temp+units[i]+res;
        }   
        return res.substr(1,res.size()-1);
    }
};
</code></pre>
<p>然后说一下遇到的问题<br>
1.空格的问题，一开始被空格弄得有点头疼，因为一种情况是整十的数，可能会在最后面出现一个多余的空格。最后的处理办法是统一在前面或者后面添加空格，然后再去掉<br>
2.某段数字整体为空，此时需要加上一个判断<code>if(stoi(three_part[i])==0)</code>跳过这一整段，否则会添加多余的Thousand或者Billion</p>
<p>然后来看一下官方题解吧：</p>
<blockquote>
<p>方法：分治<br>
我们将这个问题分解成一系列子问题。例如，对于数字 1234567890，我们将它从低位开始每三个分成一组，得到 1,234,567,890，它的英文表示为 1 Billion 234 Million 567 Thousand 890。这样我们就将原问题分解成若干个三位整数转换为英文表示的问题了。</p>
<p>接下来，我们可以继续将三位整数分解，例如数字 234 可以分别成百位 2 和十位个位 34，它的英文表示为 2 Hundred 34。这样我们继续将原问题分解成一位整数和两位整数的英文表示。其中一位整数的表示是很容易的，而两位整数中除了 10 到 19 以外，其余整数的的表示可以分解成两个一位整数的表示，这样问题就被圆满地解决了。</p>
</blockquote>
<pre><code>class Solution {
    public String one(int num) {
        switch(num) {
            case 1: return &quot;One&quot;;
            case 2: return &quot;Two&quot;;
            case 3: return &quot;Three&quot;;
            case 4: return &quot;Four&quot;;
            case 5: return &quot;Five&quot;;
            case 6: return &quot;Six&quot;;
            case 7: return &quot;Seven&quot;;
            case 8: return &quot;Eight&quot;;
            case 9: return &quot;Nine&quot;;
        }
        return &quot;&quot;;
    }

    public String twoLessThan20(int num) {
        switch(num) {
            case 10: return &quot;Ten&quot;;
            case 11: return &quot;Eleven&quot;;
            case 12: return &quot;Twelve&quot;;
            case 13: return &quot;Thirteen&quot;;
            case 14: return &quot;Fourteen&quot;;
            case 15: return &quot;Fifteen&quot;;
            case 16: return &quot;Sixteen&quot;;
            case 17: return &quot;Seventeen&quot;;
            case 18: return &quot;Eighteen&quot;;
            case 19: return &quot;Nineteen&quot;;
        }
        return &quot;&quot;;
    }

    public String ten(int num) {
        switch(num) {
            case 2: return &quot;Twenty&quot;;
            case 3: return &quot;Thirty&quot;;
            case 4: return &quot;Forty&quot;;
            case 5: return &quot;Fifty&quot;;
            case 6: return &quot;Sixty&quot;;
            case 7: return &quot;Seventy&quot;;
            case 8: return &quot;Eighty&quot;;
            case 9: return &quot;Ninety&quot;;
        }
        return &quot;&quot;;
    }

    public String two(int num) {
        if (num == 0)
            return &quot;&quot;;
        else if (num &lt; 10)
            return one(num);
        else if (num &lt; 20)
            return twoLessThan20(num);
        else {
            int tenner = num / 10;
            int rest = num - tenner * 10;
            if (rest != 0)
              return ten(tenner) + &quot; &quot; + one(rest);
            else
              return ten(tenner);
        }
    }

    public String three(int num) {
        int hundred = num / 100;
        int rest = num - hundred * 100;
        String res = &quot;&quot;;
        if (hundred * rest != 0)
            res = one(hundred) + &quot; Hundred &quot; + two(rest);
        else if ((hundred == 0) &amp;&amp; (rest != 0))
            res = two(rest);
        else if ((hundred != 0) &amp;&amp; (rest == 0))
            res = one(hundred) + &quot; Hundred&quot;;
        return res;
    }

    public String numberToWords(int num) {
        if (num == 0)
            return &quot;Zero&quot;;

        int billion = num / 1000000000;
        int million = (num - billion * 1000000000) / 1000000;
        int thousand = (num - billion * 1000000000 - million * 1000000) / 1000;
        int rest = num - billion * 1000000000 - million * 1000000 - thousand * 1000;

        String result = &quot;&quot;;
        if (billion != 0)
            result = three(billion) + &quot; Billion&quot;;
        if (million != 0) {
            if (! result.isEmpty())
                result += &quot; &quot;;
            result += three(million) + &quot; Million&quot;;
        }
        if (thousand != 0) {
            if (! result.isEmpty())
                result += &quot; &quot;;
            result += three(thousand) + &quot; Thousand&quot;;
        }
        if (rest != 0) {
            if (! result.isEmpty())
                result += &quot; &quot;;
            result += three(rest);
        }
        return result;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析</p>
<p>时间复杂度：O(N)。其中 N 是输入整数的长度。由于输出的英文表示长度和输入整数的长度是成正比的，因此时间复杂度为 O(N)。<br>
空间复杂度：O(1)。</p>
</blockquote>
<p>hhh虽然我的也有分治法的影子，但是它的优雅好多啊，特别是把三位数字分开处理。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ C++ primer 第十一章 笔记+习题 11.1-11.2]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-yi-zhang-bi-ji-xi-ti-111-112</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-yi-zhang-bi-ji-xi-ti-111-112">
        </link>
        <updated>2019-10-13T01:45:38.000Z</updated>
        <content type="html"><![CDATA[<p>来到我最喜欢的一章啦hhh</p>
<p>11关联容器<br>
关联容器支持<strong>高效的关键字查找和访问</strong><br>
两个主要的关联容器类型是map和set<br>
map 关键字-值(key-value) 关键字起索引的作用，值则是与索引相关联的数据<br>
set中每个元素只包含一个关键字，set支持高效的关键字查询操作<br>
类型map和multimap定义在头文件map中；set和multiset定义在头文件set中，无序容器则定义在头文件unordered_map和unordered_set中</p>
<p>11.1使用关联容器<br>
map是关键字-值的集合，map称为关联数组，可以通过下标访问，但是其<strong>下标不必是整数类型</strong>，可以是其他类型<br>
类似于顺序容器，关联容器也是模板，定义一个map<strong>必须指定关键字和值的类型</strong><br>
当从map提取一个<strong>元素</strong>时（不是指提取一个值，是提取一个 <strong>关键字-值</strong> 元素），得到一个<strong>pair类型</strong>的对象<br>
pair是一个模板类型，保存两个名为<strong>first和second</strong>的（公有）数据成员<br>
set<br>
与顺序容器类似，可以对一个关联容器的元素进行列表初始化<br>
find调用返回一个迭代器，如果给定关键字在set中，迭代器指向该关键字，<strong>否则find返回尾后迭代器</strong></p>
<p>习题11.1<br>
首先一个是顺序容器一个是关联容器。map的元素必须是一个pair类型的值，可以指定pair之中的两个类型，然后map是会自动按照关键字顺序排序的，并且下标就是关键字，而不是必须是数字。<br>
习题11.2<br>
按照 增删查改 四个操作<br>
list：经常在头尾进行查改操作和任意位置进行增删操作的<br>
vector：只在尾部进行增删，而经常进行任意位置查改操作的<br>
deque：在头尾进行增删，和任意位置的查改操作。<br>
map：希望高效的关键字增删查改，并且关键字需要附带信息的<br>
set：希望高效的关键字增删查改<br>
习题11.3<br>
其实书里面的例题就很不错了，这里复现一下，主要是为了加深知识点</p>
<pre><code>int main()
{
	map&lt;string, int&gt; map_s;
	set&lt;string&gt; set_s{ &quot;123&quot;,&quot;456&quot;, &quot;789&quot; };
	string s;
	while (cin&gt;&gt;s)
	{
		if (set_s.find(s) != set_s.end())
			++map_s[s];
	}
	for (auto i : map_s)
		cout &lt;&lt; i.first&lt;&lt;&quot; &quot;&lt;&lt;i.second &lt;&lt; endl;
}
</code></pre>
<p>注意关联容器也是有顺序的，可以使用begin和end等关联容器<br>
习题11.4</p>
<pre><code>int main()
{
	map&lt;string, int&gt; map_s;
	set&lt;string&gt; set_s{ &quot;example&quot; };
	string s;
	while (cin&gt;&gt;s)
	{
		s.erase(remove_if(s.begin(), s.end(), ispunct),s.end());
		transform(s.begin(), s.end(), s.begin(), tolower);
		for (auto i : s)
			cout &lt;&lt; i;
		cout&lt;&lt; endl;
		if (set_s.find(s) != set_s.end())
			++map_s[s];
	}
	for (auto i : map_s)
		cout &lt;&lt; i.first&lt;&lt;&quot; &quot;&lt;&lt;i.second &lt;&lt; endl;
}
</code></pre>
<p>注意很多字符操作，比如ispunct和tolower等都可以配合_if后缀的泛型算法进行使用。注意for_each和transform的区别，前者其实是无法逐一改变容器元素值的，只有后者添加了参数进行结果复制。</p>
<p>11.2 关联容器概述<br>
关联容器都支持普通容器操作<br>
关联容器不支持顺序容器的位置相关操作，因为关联容器都是按关键字存储，也不支持构造函数或插入操作<br>
关联容器的迭代器都是<strong>双向的</strong></p>
<p>11.2.1定义关联容器<br>
1.每个关联容器都定义了一个默认构造函数，创建一个指定类型的空容器<br>
2.也可以将关联容器初始化为另一个同类型容器的拷贝(必须相同)，或是从一个范围来初始化关联容器（相容，只要这些值可以转化为所需类型）<br>
3.新标准下，也可以对关联容器进行值初始化</p>
<p>当初始化一个map时，必须提供关键字类型和值类型，我们将每个关键字-值对包围在花括号中 {key,value}<br>
一个map和set中的关键字必须是唯一的，multimap和multiset就可以重复<br>
用含有重复元素的容器或者列表初始化map或set，会自动忽略重复元素</p>
<p>习题11.5<br>
map的元素是一个pair，包含关键值和键值，而set只包含关键值，按需使用（但是算法题中明显map使用更多）<br>
习题11.6<br>
list是顺序容器，利用指针相连，而set是关联容器，其顺序是与添加顺序无关的。<br>
习题11.7</p>
<pre><code>int main()
{
	map&lt;string, vector&lt;string&gt;&gt; map_name;
	string first_name, last_name;
	while (cin) {
		cin &gt;&gt; first_name &gt;&gt; last_name;
		if (map_name.find(first_name) == map_name.end()) {
			map_name.insert({ first_name,{last_name} });
		}
		else
			map_name[first_name].push_back(last_name);
	}	
}
</code></pre>
<p>习题11.8</p>
<pre><code>int main()
{
	vector&lt;string&gt; vs;
	string s;
	while (cin &gt;&gt; s)
		if (find(vs.begin(), vs.end(), s) == vs.end())
			vs.push_back(s);
}
</code></pre>
<p>set的优点是对于重复的单词，会自动忽略，而不需要使用find遍历一遍。</p>
<p>11.2.2 关键字类型的要求<br>
对于有序容器map、multimap、set和multiset ，关键字类型必须定义元素比较方法， 默认情况下标准库使用关键字类型的&lt;运算符来比较两个关键字<br>
传递给排序算法的可调用对象必须满足与关联容器中关键字一样的类型要求<br>
自定义的比较操作必须在关键字类型上定义一个严格弱序（小于等于）：<br>
用来组织一个容器中元素的操作的类型也是该容器类型的一部分，必须在定义关联容器类型时提供此操作的类型，自定义的操作类型必须在尖括号中紧跟着元素类型给出 比如 <code>multiset&lt;Sales_data,decltype(compareIsbn)*&gt; bookstore(compareIsbn)</code><br>
当用decltype来获得一个函数指针类型时，必须加上一个*来指出我们要使用一个给定函数类型的指针。比如<code>decltype(compareISBN)*</code> <strong>因为虽然函数名本身是一个指针，但是decltype作用于函数名只会返回函数类型而不是一个指针</strong></p>
<p>习题11.9<br>
<code>map&lt;string,list&lt;size_t&gt;&gt; ;</code><br>
习题11.10<br>
vector可以，因为其迭代器是随机存取迭代器，定义了大小比较，list的是双向迭代器，无法进行大小比较。<br>
习题11.11</p>
<pre><code>multiset&lt;Sales_Data, bool(*)(const Sales_Data &amp;lhs, const Sales_Data &amp;rhs)&gt; bookstore(compareISBN);
</code></pre>
<p>注意点 如果不能使用decltype，就只能把函数类型完整写出来，主要是把函数名去掉，加上(*)注意括号必须有，指示是一个函数指针而不是一个返回指针的函数。<br>
然后注意const对象（比如形参）只能调用const函数，比如上述的const Sales_Data &amp;lhs和const Sales_Data &amp;rhs只能调用const的isbn( )</p>
<p>11.2.3 pair类型<br>
pair为标准库类型，定义在utility中<br>
一个pair保存两个数据成员，pair是一个用来生成特定类型的模板，当创建一个pair时，我们必须提供两个类型名<br>
pair的默认构造函数对数据成员进行<strong>值初始化</strong><br>
我们也可以为每个成员提供列表初始化<br>
pair的数据成员是public的，两个成员分别命名为<strong>first和second</strong><br>
如函数需返回一个pair，在新标准下，我们可以对返回值进行列表初始化<br>
若v不为空，我们返回一个由v中最后一个string及其大小组成的pair，否则隐式构造一个空pair并返回它 <code>return pair&lt;string,int&gt;( );</code><br>
在较早版本中中只能显式构造返回值<br>
同样还可以用make_pair生成pair对象</p>
<p>习题11.12</p>
<pre><code>int main()
{
	vector&lt;pair&lt;string, int&gt;&gt; vp;
	string s;
	int i;
	while (cin &gt;&gt; s&amp;&amp;cin &gt;&gt; i) {
		vp.push_back(make_pair(s, i));
	}
	for (auto p : vp)
		cout &lt;&lt; p.first&lt;&lt;&quot; &quot;&lt;&lt;p.second &lt;&lt; endl;
}
</code></pre>
<p>习题11.13</p>
<pre><code>int main()
{
	vector&lt;pair&lt;string, int&gt;&gt; vp;
	string s;
	int i;
	while (cin &gt;&gt; s&amp;&amp;cin &gt;&gt; i) {
		vp.push_back(make_pair(s, i));
		vp.push_back({ s,i });
		vp.push_back(pair&lt;string, int&gt;(s, i));
	}
	for (auto p : vp)
		cout &lt;&lt; p.first&lt;&lt;&quot; &quot;&lt;&lt;p.second &lt;&lt; endl;
}
</code></pre>
<p>第二种最易于编写，但是不容易理解，第三种最容易理解，但是不易于编写。所以第一种最适合最适中。<br>
习题11.14</p>
<pre><code>int main()
{
	map&lt;string, vector&lt;pair&lt;string,int&gt;&gt;&gt;map_name;
	string first_name, last_name;
	int birth;
	while (cin) {
		cin &gt;&gt; first_name &gt;&gt; last_name&gt;&gt;birth;
		if (map_name.find(first_name) == map_name.end()) {
			map_name.insert({ first_name,{ {last_name,birth} } });
		}
		else
			map_name[first_name].push_back({ last_name,birth });
	}
}
</code></pre>
<p>习题感悟：<br>
注意关联容器也是有顺序的，可以使用begin和end等关联容器<br>
很多字符操作，比如ispunct和tolower等都可以配合_if后缀的泛型算法进行使用。注意for_each和transform的区别，前者其实是无法逐一改变容器元素值的，只有后者添加了参数进行结果复制。<br>
因为虽然函数名本身是一个指针，但是decltype作用于函数名只会返回函数类型而不是一个指针<br>
注意点 如果不能使用decltype，就只能把函数类型完整写出来，主要是把函数名去掉，加上(*)注意括号必须有，指示是一个函数指针而不是一个返回指针的函数。<br>
然后注意const对象（比如形参）只能调用const函数，比如上述的const Sales_Data &amp;lhs和const Sales_Data &amp;rhs只能调用const的isbn( )</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 13. 罗马数字转整数 12. 整数转罗马数字]]></title>
        <id>https://lixin-ee.github.io//post/zi-fu-chuan-13-luo-ma-shu-zi-zhuan-zheng-shu</id>
        <link href="https://lixin-ee.github.io//post/zi-fu-chuan-13-luo-ma-shu-zi-zhuan-zheng-shu">
        </link>
        <updated>2019-10-12T01:38:42.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。<br>
字符          数值<br>
I             1<br>
V             5<br>
X             10<br>
L             50<br>
C             100<br>
D             500<br>
M             1000<br>
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。<br>
通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：<br>
I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 <br>
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>
给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<p>示例 1:<br>
输入: &quot;III&quot;<br>
输出: 3<br>
示例 2:<br>
输入: &quot;IV&quot;<br>
输出: 4<br>
示例 3:<br>
输入: &quot;IX&quot;<br>
输出: 9<br>
示例 4:<br>
输入: &quot;LVIII&quot;<br>
输出: 58<br>
解释: L = 50, V= 5, III = 3.<br>
示例 5:<br>
输入: &quot;MCMXCIV&quot;<br>
输出: 1994<br>
解释: M = 1000, CM = 900, XC = 90, IV = 4.</p>
</blockquote>
<p>这道题一开始还有蛮波折的，我一开始的想法是使用switch，然后两位两位地检测，但是每次只递增一位<br>
然后实现的时候发现会略麻烦，因为第一位和最后一位会比较难处理。<br>
然后突然想到一个问题，如果出现“IXL”这种情况怎么破？，既是IX又是XL？<br>
果断去评论区看看，结果被强行剧透了，可以直接使用map记录相应值，然后检测前一个值是否小于后一个值，如果是的话就需要减去。然后关于IXL这种情况的话，在罗马数字里面是不会出现这种情况的，然后测试用例中也都是正确的罗马数字案例。。。leetcode的题的质量还是有待提高啊。<br>
最后给出的代码如下：</p>
<pre><code>class Solution {
public:
    int romanToInt(string s) {
        int res=0;
        map&lt;char,int&gt; roman {{'I',1},{'V',5},{'X',10},{'L',50},{'C',100},{'D',500},{'M',1000}};
        int temp=0;
        for(int i=0;i&lt;s.size();++i){
            res+=roman[s[i]];
            if(roman[s[i]]&gt;temp)
                res-=2*temp;
            temp=roman[s[i]];
        }
        return res;     
    }
};
</code></pre>
<p>然后看一下网友代码，基本是和我前一种想法相符，使用switch或者map来进行两位字符的匹配，但是最简单还是上述的方法。</p>
<p>12.整数转罗马数字</p>
<blockquote>
<p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。<br>
字符          数值<br>
I             1<br>
V             5<br>
X             10<br>
L             50<br>
C             100<br>
D             500<br>
M             1000<br>
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 <br>
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>
给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p>
<p>示例 1:<br>
输入: 3<br>
输出: &quot;III&quot;<br>
示例 2:<br>
输入: 4<br>
输出: &quot;IV&quot;<br>
示例 3:<br>
输入: 9<br>
输出: &quot;IX&quot;<br>
示例 4:<br>
输入: 58<br>
输出: &quot;LVIII&quot;<br>
解释: L = 50, V = 5, III = 3.<br>
示例 5:<br>
输入: 1994<br>
输出: &quot;MCMXCIV&quot;<br>
解释: M = 1000, CM = 900, XC = 90, IV = 4.</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/integer-to-roman<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题相对简单一点，我的思路就是除以每个值，然后利用switch的case的特性，先把num转化为string得到位数，再根据相应的位数开始跳转到相应的case，并且case之间不需要break，从而从上至下执行一个完整的流程。</p>
<pre><code>class Solution {
public:
    string intToRoman(int num) {
        string s(to_string(num));
        int time=0;
        string res;
        switch(s.size()){
            case 4:
                time=num/1000;
                num=num%1000;
                while(time)
                    res+=&quot;M&quot;,--time;
            case 3:
                time=num/900;
                num=num%900;
                while(time)
                    res+=&quot;CM&quot;,--time;
                time=num/500;
                num=num%500;
                while(time)
                    res+=&quot;D&quot;,--time;
                time=num/400;
                num=num%400;
                while(time)
                    res+=&quot;CD&quot;,--time;
                time=num/100;
                num=num%100;
                while(time)
                    res+=&quot;C&quot;,--time;
            case 2:
                time=num/90;
                num=num%90;
                while(time)
                    res+=&quot;XC&quot;,--time;
                time=num/50;
                num=num%50;
                while(time)
                    res+=&quot;L&quot;,--time;
                time=num/40;
                num=num%40;
                while(time)
                    res+=&quot;XL&quot;,--time;
                time=num/10;
                num=num%10;
                while(time)
                    res+=&quot;X&quot;,--time;
            case 1:
                time=num/9;
                num=num%9;
                while(time)
                    res+=&quot;IX&quot;,--time;
                time=num/5;
                num=num%5;
                while(time)
                    res+=&quot;V&quot;,--time;
                time=num/4;
                num=num%4;
                while(time)
                    res+=&quot;IV&quot;,--time;
                while(num)
                    res+=&quot;I&quot;,--num;
                break;
            default:
                break;
        }
        return res;
    }
};
</code></pre>
<p>然后是网友题解，用到了贪心算法，代码量没那么大</p>
<pre><code>class Solution:
    def intToRoman(self, num: int) -&gt; str:
        # 把阿拉伯数字与罗马数字可能出现的所有情况和对应关系，放在两个数组中
        # 并且按照阿拉伯数字的大小降序排列，这是贪心选择思想
        nums = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
        romans = [&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;]

        index = 0
        res = ''
        while index &lt; 13:
            # 注意：这里是等于号，表示尽量使用大的&quot;面值&quot;
            while num &gt;= nums[index]:
                res += romans[index]
                num -= nums[index]
            index += 1
        return res
复杂度分析：
</code></pre>
<p>时间复杂度：O(1)，虽然看起来是两层循环，但是外层循环的次数最多 12，内层循环的此时其实也是有限次的，综合一下，时间复杂度是 O(1)。<br>
空间复杂度：O(1)，这里使用了两个辅助数字，空间都为 13，还有常数个变量，故空间复杂度是 O(1)。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ C++ primer 第十章 笔记+习题 10.3-10.6]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-zhang-bi-ji-xi-ti-103-106</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-zhang-bi-ji-xi-ti-103-106">
        </link>
        <updated>2019-10-11T09:04:57.000Z</updated>
        <content type="html"><![CDATA[<p>（艹忘了保存，再来一遍）快半个月没写c++了，因为国庆假期+不停地汇报</p>
<p>10.4 再探迭代器<br>
10.4.1插入迭代器<br>
只有在容器支持push_front（push_back）的情况下我们才可以使用front_inserter（back_inserter）。<br>
调用it = inserter（c，iter）得到一个插入迭代器it，然后通过*it = val；赋值<br>
front_inserter会把插入元素序列顺序颠倒过来，inserter和back_inserter就不会<br>
注意，insert返回指向新元素的迭代器，inserter则返回同一个迭代器</p>
<p>习题10.26<br>
inserter可以在特定位置插入，需要两个参数<br>
back_inserter只能在容器的尾部插入，只需要一个参数<br>
front_inserter只能在容器的首部插入，只需要一个参数<br>
习题10.27</p>
<pre><code>int main()
{
	vector&lt;int&gt; vi{ 1,1,2,3,3,4,5,6,7,8,9 };
	list&lt;int&gt; li;
	unique_copy(vi.begin(), vi.end(),inserter(li,li.begin()));
	for (auto i : li)
		cout &lt;&lt; i &lt;&lt; endl;
}
</code></pre>
<p>注意，copy后缀的函数都需要一个插入迭代器作为参数，而不是普通的迭代器。然后unique只能检测相邻的重复元素。<br>
习题10.28</p>
<pre><code>int main()
{
	vector&lt;int&gt; vi{ 1,2,3,4,5,6,7,8,9 };
	deque&lt;int&gt; vii;
	copy(vi.begin(), vi.end(), inserter(vii, vii.begin()));
	for (auto i : vii)
		cout &lt;&lt; i &lt;&lt;&quot; &quot;;
	cout &lt;&lt; endl;
	deque&lt;int&gt; vib;
	copy(vi.begin(), vi.end(), back_inserter(vib));
	for (auto i : vib)
		cout &lt;&lt; i &lt;&lt; &quot; &quot;;
	cout &lt;&lt; endl;
	deque&lt;int&gt; vif;
	copy(vi.begin(), vi.end(), front_inserter(vif));
	for (auto i : vif)
		cout &lt;&lt; i &lt;&lt; &quot; &quot;;
	cout &lt;&lt; endl;
}
</code></pre>
<p>vector、string等容器都无法使用 front_inserter</p>
<p>10.4.2iostream迭代器<br>
iostream类型不是容器，但也可以有流迭代器<br>
当创建一个流迭代器时，必须指定迭代器将要读写的对象类型<br>
当创建一个istream_iterator时，可以把它绑定到一个流，也可以让他默认初始化，创建一个可以用作尾后值的迭代器<br>
可以用已绑定流的istream_iterator和默认初始化的istream_iterator（<strong>尾后迭代器</strong>）对比用作判断流是否读取完成的条件<br>
对于一个绑定到流的迭代器，一旦遇到<strong>文件尾或者IO错误</strong>，迭代器的值就与<strong>尾后迭代器相等</strong><br>
当我们将istream_iterator绑定到一个流时，标准库并不保证迭代器立即从流读取数据，具体实现可以推迟从流中读取数据，直到我们使用迭代器时才真正读取<br>
与istream_iterator不同，ostream_iterator必须绑定到一个指定的流，不允许空的或表示尾后位置的ostream_iterator<br>
运算符*和++实际上对ostream_iterator对象不做任何事情</p>
<p>习题10.29</p>
<pre><code>int main()
{
	string file_name=&quot;test.txt&quot;;
	fstream fstrm(file_name);
	istream_iterator&lt;string&gt; in(fstrm),eof;
	vector&lt;string&gt; vs(in, eof);
	for (auto s : vs)
		cout &lt;&lt; s &lt;&lt; endl;
}
</code></pre>
<p>注意流迭代器的使用，就好像平时的迭代器一样，有开始和结尾<br>
习题10.30</p>
<pre><code>int main()
{
	istream_iterator&lt;int&gt; is(cin),eof;
	vector&lt;int&gt; vi(is, eof);
	sort(vi.begin(), vi.end());
	ostream_iterator&lt;int&gt; os(cout,&quot; &quot;);
	copy(vi.begin(), vi.end(), os);
	cout &lt;&lt; endl;
}
</code></pre>
<p>当copy到输出流迭代器的时候直接等于输出<br>
习题10.31</p>
<pre><code>int main()
{
	istream_iterator&lt;int&gt; is(cin), eof;
	vector&lt;int&gt; vi(is, eof);
	sort(vi.begin(), vi.end());
	ostream_iterator&lt;int&gt; os(cout, &quot; &quot;);
	unique_copy(vi.begin(), vi.end(), os);
	cout &lt;&lt; endl;
}
</code></pre>
<p>习题10.32</p>
<pre><code>int main()
{
	istream_iterator &lt; Sales_item &gt; is(cin),eof;
	vector&lt;Sales_item&gt; vs(is,eof);
	stable_sort(vs.begin(), vs.end(), compareISBN);
	for (auto i = vs.begin(); i &lt; vs.end(); ++i) {
		auto j = i;
		while (j&lt;vs.end()&amp;&amp;(*j).isbn == (*i).isbn)
			++j;
		Sales_item temp=*i;
		accumulate(i, j-1, temp);
		i = j;
	}
}

bool compareISBN(const Sales_item &amp;s1, const Sales_item &amp;s2) {
	int result = s1.isbn.compare(s2.isbn);
	if (result &lt; 0)
		return true;
	else
		return false;
}
</code></pre>
<p>不是很想得明白find 的用处（利用反向迭代器查找最后一个？）<br>
习题10.33</p>
<pre><code>int main()
{
	divid(&quot;input.txt&quot;, &quot;output1`.txt&quot;, &quot;output2.txt&quot;);
	
}

void divid(string input, string output_1, string output_2) {
	ifstream ifstr(input);
	ofstream ofstr1(output_1), ofstr2(output_2);
	istream_iterator&lt;int&gt; is(ifstr),eof;
	vector&lt;int&gt; vi(is, eof);
	ostream_iterator&lt;int&gt; os1(ofstr1,&quot; &quot;), os2(ofstr2,&quot;\n&quot;);
	for (auto i : vi) {
		if (i % 2)
			os1 = i;
		else
			os2 = i;
		cout &lt;&lt; i &lt;&lt; endl;
	}
}
</code></pre>
<p>一定要记得利用输出输入流来初始化istream_iterator、ostream_iterator</p>
<p>10.4.3反向迭代器<br>
除了<strong>forward_list</strong>之外，其他容器都支持反向迭代器<br>
可以通过向<strong>sort</strong>传递一对反向迭代器来将vector整理为<strong>递减序</strong><br>
不可能从一个<strong>forward_list</strong>或一个流迭代器创建反向迭代器<br>
注意cbegin和crend<strong>并不在同一位置</strong>cend和crbegin也同理<br>
auto rcomma = find(line.crbegin(),line.crend(),’,’) //查找最后一个逗号所在的位置<br>
cout&lt;&lt;string(line.crbegin(),rcomma)&lt;&lt;endl; //错误！！将会<strong>逆序输出字符</strong><br>
不能使用反向迭代器进行顺序打印，因为反向迭代器总会朝着string开始的位置移动，需要把反向迭代器通过调用reverse_iterator的<strong>base</strong>成员函数来进行转换，返回对应的普通迭代器<br>
但是注意！！反向迭代器转换为普通迭代器时，两个迭代器所指向的位置并不一样，它们是在<strong>相邻位置，而不是相同位置</strong></p>
<p>习题10.34</p>
<pre><code>int main()
{
	vector&lt;int&gt; vi{ 1,2,3,4,5,6,7,8,9,0 };
	for (auto i = vi.rbegin(); i &lt; vi.rend(); ++i)
		cout &lt;&lt; *i &lt;&lt; endl;
}
</code></pre>
<p>习题10.35</p>
<pre><code>int main()
{
	vector&lt;int&gt; vi{ 1,2,3,4,5,6,7,8,9,0 };
	for (auto i = vi.end()-1; i &gt;vi.begin(); --i)
		cout &lt;&lt; *i &lt;&lt; endl;
	cout &lt;&lt; *vi.begin() &lt;&lt; endl;
}
</code></pre>
<p>注意有些容器的迭代器是无法使用递减操作的<br>
习题10.36</p>
<pre><code>int main()
{
	list&lt;int&gt; li{ 1,2,3,4,5,6,7,8,9,0 };
	if (find(li.rbegin(), li.rend(), 0) != li.rend())
		cout &lt;&lt; *find(li.rbegin(), li.rend(), 0) &lt;&lt; endl;
	else
		cout &lt;&lt; &quot;not found&quot; &lt;&lt; endl;
}
</code></pre>
<p>注意find返回的是inputiterator，无法进行算法运算，只能递增<br>
习题10.37</p>
<pre><code>int main()
{
	vector&lt;int&gt; vi{ 1,2,3,4,5,6,7,8,9,0 };
	list&lt;int&gt; li(vi.rbegin()+3,vi.rend()-2);
	for (auto i : li)
		cout &lt;&lt; i &lt;&lt; endl;
}
</code></pre>
<p>注意区间是左开右合，反向迭代器也是</p>
<p>10.5.1  5类迭代器<br>
输入迭代器<br>
输入迭代器只能用于顺序访问，但递增输入迭代器可能导致所有其他指向流的迭代器失效，导致输入迭代器不能保证成功访问保存过的状态，因此，输入迭代器只能用于单遍扫描算法（注意！istream_iterator就是一种输入迭代器）<br>
输出迭代器<br>
<strong>解引用符*只能出现在赋值运算符=的左侧</strong>等于将值写入它所指向的元素<br>
<strong>用作目的位置参数的迭代器通常都是输出迭代器</strong>，比如copy的第三个参数，ostream_iterator也是输出迭代器</p>
<p>随机访问迭代器<br>
提供在常量时间内访问序列任意元素的能力<br>
用到随机访问迭代器的1.算法sort 2.array、deque、string和vector的迭代器 3.用于访问内置数组元素的指针</p>
<p>习题10.38<br>
<img src="https://lixin-ee.github.io//post-images/1570847767348.png" alt=""><br>
习题10.39<br>
list属于双向迭代器，vector属于随机访问迭代器<br>
习题10.40<br>
copy要求两个输入迭代器和一个输出迭代器，reverse要求两个双向迭代器，unique要求两个单向迭代器<br>
STL源码剖析中有很明确的定义了</p>
<p>10.5.2算法形参模式<br>
只接受单个目标迭代器dest参数的算法都假定目标空间具有足够容纳写入数据<br>
接收单独beg2假定从beg2开始的序列与beg和end所表示的范围至少一样大</p>
<p>10.5.3算法命名规范<br>
接收谓词来代替原来的比较操作（&lt;或==）或不接受额外参数的算法通常都是重载的函数（名字相同）<br>
接受一个元素值（作为基准值，比如find（beg，end，val）的val）的算法通常有另一个不同名的版本（不是重载），通常有附加的_if前缀，该版本接受一个谓词代替元素值<br>
默认情况下重排元素的算法将重排后的元素写回原序列，而写到其他序列的算法需要在名字后面加上_copy</p>
<p>习题10.41<br>
1.用new_val代替old_val<br>
2.当值符合pred，就用old_val代替<br>
3.用new_val代替old_val，并且将结果复制到dest的迭代器指向的容器位置中<br>
4.当值符合pred，就用old_val代替，并且将结果复制到dest的迭代器指向的容器位置中<br>
上述都是遍历 beg到end</p>
<p>10.6特定容器算法<br>
对于list和forward_list应该优先使用成员函数版本的算法而不是通用算法，例如通用版本的sort要求随机访问迭代器，所以list和forward_list只能使用自己定义的sort<br>
链表通过<strong>改变元素之间的链接</strong>而不是真的交换它们的值来快速交换元素<br>
merge操作需要比较两个list中的值大小再进行插入，所以必须是有序的<br>
splice成员，链表数据结构特有的<br>
链表特有版本和通用版本的算法之间的一个至关重要的区别是链表版本<strong>会改变底层的容器</strong>remove的链表版本会删除指定元素，unique会删除第二个和后续的重复元素</p>
<p>习题10.42</p>
<pre><code>void elimDups(list&lt;string&gt; &amp;words) {
	words.sort();
	words.unique();
	for (auto i : words)
		cout &lt;&lt; i &lt;&lt; &quot; &quot;;
	cout &lt;&lt; endl;
}
</code></pre>
<p>对比原来的</p>
<pre><code>void elimDups(vector&lt;string&gt; &amp;words) {
	sort(words.begin(), words.end());
	auto end_unique = unique(words.begin(), words.end());
	for (auto i : words)
		cout &lt;&lt; i &lt;&lt; &quot; &quot; ;
	cout &lt;&lt; endl;
	words.erase(end_unique, words.end());
	for (auto i : words)
		cout &lt;&lt; i &lt;&lt; &quot; &quot;;
	cout &lt;&lt; endl;
}
</code></pre>
<p>可以看出，list的特定操作比如sort、unique操作和普通的操作的区别在于1，参数的区别，list可以指定一个谓词，但是无法指定范围迭代器，list只能对整体进行操作 2.list是真的会删除元素（源码内部就调用了erase），而不像通用版本中还需要额外的erase。</p>
<p>习题感悟：<br>
copy后缀的函数都需要一个输出迭代器作为参数，而不是普通的迭代器。然后unique只能检测相邻的重复元素。<br>
vector、string等容器都无法使用 front_inserter<br>
注意流迭代器的使用，就好像平时的迭代器一样，有开始和结尾<br>
当copy到输出流迭代器的时候直接等于输出<br>
一定要记得利用输出输入流来初始化istream_iterator、ostream_iterator<br>
注意有些容器的迭代器是无法使用递减操作的<br>
<strong>注意find返回的是inputiterator，无法进行算法运算，只能递增</strong><br>
注意区间是左开右合，反向迭代器也是<br>
copy要求两个输入迭代器和一个输出迭代器，reverse要求两个双向迭代器，unique要求两个单向迭代器<br>
可以看出，list的特定操作比如sort、unique操作和普通的操作的区别在于1，参数的区别，list可以指定一个谓词，但是无法指定范围迭代器，list只能对整体进行操作 2.list是真的会删除元素（源码内部就调用了erase），而不像通用版本中还需要额外的erase。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 168. 字符串 171.Excel表列名称-序号转换]]></title>
        <id>https://lixin-ee.github.io//post/zi-fu-chuan-168-excel-biao-lie-ming-cheng</id>
        <link href="https://lixin-ee.github.io//post/zi-fu-chuan-168-excel-biao-lie-ming-cheng">
        </link>
        <updated>2019-10-11T03:18:03.000Z</updated>
        <content type="html"><![CDATA[<p>字符串 168.Excel表列名称</p>
<blockquote>
<p>给定一个正整数，返回它在 Excel 表中相对应的列名称。</p>
<p>例如，</p>
<pre><code>1 -&gt; A
2 -&gt; B
3 -&gt; C
...
26 -&gt; Z
27 -&gt; AA
28 -&gt; AB 
...
</code></pre>
<p>示例 1:</p>
<p>输入: 1<br>
输出: &quot;A&quot;<br>
示例 2:</p>
<p>输入: 28<br>
输出: &quot;AB&quot;<br>
示例 3:</p>
<p>输入: 701<br>
输出: &quot;ZY&quot;</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/excel-sheet-column-title<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题第一眼看上去很简单（而且本来标注的也是简单题），就是一道10进制转26进制的题，我本来是按照十进制转二进制的方法来写的（不断除以2，余数进行编码），但是写到最后就发现问题了：0跑哪去了？<br>
仔细看的话似乎题目很详细，但是十进制转X进制是0-9转换过去的，而不是1-10，所以这里是缺了一个0，所以我忙活了一个晚上需要对0进行额外的处理<br>
我忙活了一个晚上的原因也在于判断条件，一开始希望在一个循环内解决战斗，但是有一种特殊情况很烦人：商等于1，余数等于0的情况，这种情况需要借位等于Z<br>
所以最后打算先不管了，在结果字符串中保存0，然后再遍历一次进行借位操作<br>
然后发现借位操作也不简单啊...从前往后的话有一种很奇葩的特例是AAAAAA0，借到第一位，从后往前的话就有A0000000这种奇葩情况。最后使用的是从前往后，不断借位直到借到首位（首位肯定不为0）然后对首位进行判断截断字符串再输出<br>
结果如下：</p>
<pre><code>class Solution {
public:
string convertToTitle(int n) {
        string res;
        char temp;
        int i;
        do{
            i=n%26;
            n=n/26;
            if(!i)
                temp='0';
            else
                temp='A'+i-1;
            res= temp+res;
        }while(n);
        for(int c=1;c&lt;res.size();++c) {
            int num=0;
            while(res[c-num]=='0'&amp;&amp;c-num&gt;0){
                res[c-num]='Z';
                if(res[c-num-1]=='A')
                    res[c-num-1]='0';
                else
                    res[c-num-1]=res[c-num-1]-1;
                ++num;
            }        
        }   
        if(res[0]=='0')
            res=res.substr(1,res.size()-1);
        return res;
    }
};
</code></pre>
<p>终于通过了，前前后后大概花了三小时。<br>
然后看看网友题解</p>
<blockquote>
<p>思路<br>
做这道题要先了解一下, 十进制转二进制, 比如 6 转 成二进制多少?</p>
<p>2 |_ 6 _                       ^<br>
2|_ 3 _  ······ 0    |<br>
2|_ 1 _ ·······1    |<br>
|_ 0_ ·······1    |</p>
<p>所以， 我们能得到二进制为 110, 这道题换句话说是十进制转26进制的</p>
<p>但是有个难点: 如果 26 转成 字母是多少?</p>
<p>26|_ 26 _<br>
1   ··· 0<br>
这里出现了0, 但是我们26 字母 没有任何一个字母是表示0, 所以我们可以从 商 借一个给余数</p>
<p>26| _ 26 _<br>
0 ··· 26<br>
这样就可以表示出来了,所以代码如下</p>
</blockquote>
<pre><code>class Solution:
    def convertToTitle(self, n: int) -&gt; str:
        res = &quot;&quot;
        while n:
            n, y = divmod(n, 26) 
            if y == 0:
                n -= 1
                y = 26
            res = chr(y + 64) + res
        return res
</code></pre>
<blockquote>
<p>看了其他做法, 他们先让n 减一</p>
</blockquote>
<pre><code>class Solution:
    def convertToTitle(self, n: int) -&gt; str:
        res = &quot;&quot;
        while n:
            n -= 1
            n, y = divmod(n, 26) 
            res = chr(y + 65) + res
        return res
</code></pre>
<blockquote>
<p>还有一种递归写法:</p>
</blockquote>
<pre><code>class Solution:
    def convertToTitle(self, n: int) -&gt; str:
        return &quot;&quot; if n == 0 else self.convertToTitle((n - 1) // 26) + chr((n - 1) % 26 + 65
</code></pre>
<p>C++版</p>
<pre><code>class Solution {
public:
    string convertToTitle(int n) {
        char a[26]={'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'};//表
        string res;
        while(n)
        {
            n--;//要先减一才能找到对应的字母
            res=a[n%26]+res;
            n=n/26;
        }
        return res;
    }
};
</code></pre>
<blockquote>
<p>思路1：此题可以近似看成一个求26进制的题，但是值得注意的是对于26的整数倍，如果我们不加以限制的话就会造成A0的情况出现，而题目给出的条件中是不考虑这种情况的。所以我们只需要排除这种情况对于任何26的整数倍，我们就直接先插入‘Z’，同时还要对原数进行减一的操作。因为如果不进行减一的话对于26所对应的就是AZ（其实就是为了将A0映射为Z要对A0整体减一，由于0-1不够，所以要向A借一位，所以最后就得到了Z。所以我们要插入Z之后再对原数减1。）</p>
<p>思路2：上一种思路我们看到了为什么对于26的整数倍要进行减一的操作，同时对于1-25而言，我们应该映射到A-Y，但是对于1我们直接加上A的ascii码就会得到B，所以我们也要进行减一的操作，(char)(temp+'A'-1)。对于Z我们需要减一，对于A-Y也需要减一，如果我们可以减这两种减一统一起来事情就变得简单了。所以我们可以考虑在取余之前就整体减一。我们可以证明对于26的N倍（num%26 = N），我们整体减一在取余就会得到(num-1)%26 = N-1余25，所以25直接加上A的ASCII码就得Z，所以对于Z而言是可以提前减一的。对于A-Y而言num%26 = N余t，t属于1到25的范围。这个t减一在加上'A'的ASCII码就对于与A-Y（t+'A'-1），而如果我们提前减一的话这个表达式就变成了(num-1)%26 =N余t-1;最后我们的到的值就不用进行减一操作（t-1+'A'）。所以可以将Z和A-Y的操作统一起来了，提前减一，然后再正常取模即可。、</p>
</blockquote>
<p>卧槽！！！太简单了吧！！！我吐血了！！！<br>
其实本来也是有想到减1的思路的，但是当时没有好好思考应该在哪里进行减1操作，导致最后代码非常臃肿庞大。。。也有一个原因就是昨晚做题太赶了，看着是简单题就总是想赶出答案，所以做题还是得静下心来啊</p>
<p>171.Excel表列序号转换</p>
<blockquote>
<p>给定一个Excel表格中的列名称，返回其相应的列序号。<br>
例如，<br>
A -&gt; 1<br>
B -&gt; 2<br>
C -&gt; 3<br>
...<br>
Z -&gt; 26<br>
AA -&gt; 27<br>
AB -&gt; 28<br>
...<br>
示例 1:<br>
输入: &quot;A&quot;<br>
输出: 1<br>
示例 2:<br>
输入: &quot;AB&quot;<br>
输出: 28<br>
示例 3:<br>
输入: &quot;ZY&quot;<br>
输出: 701<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/excel-sheet-column-number<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题就是上一道题的翻转版，所以我就放在一起了<br>
这个的翻转相对简单一点，我一开始的做法是从后往前，主要的槽点在于如果使用一个变量来记录权值26^n,会有一个测试用例出现溢出的情况，导致我强行加了一个判断条件。</p>
<pre><code>class Solution {
public:
    int titleToNumber(string s) {
        int res=0;
        int num=1;
        for(auto i=s.rbegin();i&lt;s.rend();++i){
            res+=(*i-'A'+1)*num;
            if(i&lt;s.rend()-1)
                num*=26;
        }
        return res;   
    }
};
</code></pre>
<p>然后看了网友题解才想起来明明可以从前往后的啊。。。又傻了<br>
解题方案</p>
<blockquote>
<p>思路<br>
标签：字符串遍历，进制转换<br>
初始化结果ans = 0，遍历时将每个字母与A做减法，因为A表示1，所以减法后需要每个数加1，计算其代表的数值num = 字母 - ‘A’ + 1<br>
因为有26个字母，所以相当于26进制，每26个数则向前进一位<br>
所以每遍历一位则ans = ans * 26 + num<br>
以ZY为例，Z的值为26，Y的值为25，则结果为26 * 26 + 25=701<br>
时间复杂度：O(n)<br>
代码</p>
</blockquote>
<pre><code>class Solution {
    public int titleToNumber(String s) {
        int ans = 0;
        for(int i=0;i&lt;s.length();i++) {
            int num = s.charAt(i) - 'A' + 1;
            ans = ans * 26 + num;
        }
        return ans;
    }
}
</code></pre>
<p>这个的话就好很多了，至少不需要担心溢出的问题。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 316. 去除重复字母]]></title>
        <id>https://lixin-ee.github.io//post/316-qu-chu-chong-fu-zi-mu</id>
        <link href="https://lixin-ee.github.io//post/316-qu-chu-chong-fu-zi-mu">
        </link>
        <updated>2019-10-10T03:39:32.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个仅包含小写字母的字符串，去除字符串中重复的字母，使得每个字母只出现一次。需保证返回结果的字典序最小（要求不能打乱其他字符的相对位置）。</p>
<p>示例 1:<br>
输入: &quot;bcabc&quot;<br>
输出: &quot;abc&quot;<br>
示例 2:<br>
输入: &quot;cbacdcbc&quot;<br>
输出: &quot;acdb&quot;</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/remove-duplicate-letters<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>一开始我弄错题意了，以为是提取某个字母第一次出现的位置或者第二次出现的位置：</p>
<pre><code>class Solution {
public:
    string removeDuplicateLetters(string s) {
        map&lt;char,int&gt; s_map;
        for(auto c:s){
            if(!s_map.insert(make_pair(c,1)).second)
                ++s_map.at(c);
        }
        string res;
        for(auto i=s.rbegin();i&lt;s.rend();++i){
            if(s_map.at(*i)==1||s_map.at(*i)==2){
                res=*i+res;
                s_map.at(*i)=-1;
            }
            else if(s_map.at(*i)&gt;2)
                --s_map.at(*i);                
        }
        return res;
    }
};
</code></pre>
<p>其实是寻找一个区域，使得字典序（也就是字符串排序）最小，并且其中不能用重复的字母，比如dabccd，结果就是abcd，第一个d要去掉，第二个c也得去掉。<br>
然后这两天发生了蛮多的事情的，心情不太好，题目也没什么思路，就直接先看一下网友题解吧</p>
<pre><code>维护一个Stack&lt;char&gt;，对字符串进行正序遍历。对每个字符ch，首先判断stack内是否存在该字符，若stack顶端值比ch大且后续遍历中还能访问到同样的值则将该顶端值去除，最后将stack转化为Array，逆序后转化为字符串输出。

public class Solution {
    public string RemoveDuplicateLetters(string s)
    {
        Stack&lt;char&gt; stack = new Stack&lt;char&gt;();
        for (int i = 0; i &lt; s.Length; ++i)
        {
            char ch = s[i];
            if (stack.Contains(ch))
            {
                continue;
            }
            while (stack.Count &gt; 0 &amp;&amp; stack.Peek() &gt; ch &amp;&amp; s.LastIndexOf(stack.Peek()) &gt; i)
            {
                stack.Pop();
            }
            stack.Push(ch);
        }
        char[] res = stack.ToArray();
        Array.Reverse(res);
        return new string(res);
    }
}
</code></pre>
<pre><code>* 这道题呢，就是要想办法把最小的字母放在最前面
 * 例如：bcabc
 * 
 * 如果当前只有一个字母b，b就是升序的，没问题
 * 此时加入一个c，变成bc，OK，是升序的，没问题，继续
 * 再加入一个a，变成了bca，那么此时我要将a放在最前面，那么就需要a后面有b,和c能替换前面的bc。
 * 
 * 所以我这里遍历到a时，先判断后面有没有c，有的话，我将前面的c去掉，变成ba，
 * 然后我再判断后面有没有b，有的话，我将前面的b去掉，
 * 
 * 我们用stack来记录这种移位后的结果
 * 那么stack的变化顺序：
 * stack=[b]
 * stack=[b,c]
 * stack=[b,a]
 * stack=[a]
 * stack=[a,b]
 * stack=[a,b,c]
 */
</code></pre>
<p>描述比较简单，整体思路也算比较暴力了，但是操作起来可不简单，首先必须对栈进行遍历操作，其次需要对数组字母出现的位置进行遍历操作。第二个还好，第一个的话c++的栈是没有遍历接口的，只能对栈顶元素进行操作，所以还得找一下针对c++的方法。</p>
<blockquote>
<p>1.遍历字符串，用map记录字符出现的最后位置；<br>
2.第二次遍历字符串时，维护一个记录结果的栈，用vector实现；<br>
3.维护一个map记录当前字符是否在栈里（就不需要遍历数组，看是否存在），当在栈里时，继续遍历，不在转4；<br>
4.当栈不为空且字典序比当前元素大时，并且栈顶字符在原字符串中出现的位置比当前下标i更大，说明栈顶字符会在之后出现。弹出栈顶元素，并将栈顶元素是否在栈中的记录抹除；<br>
5.压栈当前字符；<br>
6.结果为vector数组中的字符顺序。</p>
</blockquote>
<pre><code>class Solution {
public:
    string removeDuplicateLetters(string s) {
        unordered_map&lt;char, int&gt; mp;
        unordered_map&lt;char, int&gt; in_st;
        for(int i = 0; i &lt; s.size(); ++i)
            mp[s[i]] = i;//记录某个字符出现的最后位置
        vector&lt;char&gt; st;//记录结果的栈
        for(int i = 0; i &lt; s.size(); ++i){
            if(in_st[s[i]])continue;//栈中有当前遍历的字符
            while(st.size() &amp;&amp; s[i] &lt; st.back() &amp;&amp; mp[st.back()] &gt; i){
            //栈顶元素会在之后的位置出现
                --in_st[st.back()];
                st.pop_back();
            //出栈并抹除记录
            }
            st.push_back(s[i]);
            ++in_st[s[i]];
        //压栈，并记录出现过
        }
        string res;
        for(auto&amp; i : st)res += i;    
        return res;
    }
};
</code></pre>
<p>这个方法就挺好的，利用两个map记录字符的情况，比遍历快很多，属于利用空间换时间。<br>
然后自己实现了一遍，需要注意的点在于一个是pop的判断可是有三部分的1.判断栈是否为空2.栈顶元素是否大于当前元素3.栈顶元素是否会在字符串后面再出现<br>
然后在pop的时候需要同时在栈的map里面删除相关元素（或者像原作者那样利用map的值进行操作）<br>
主要注意的点还是c++的栈操作pop是无法同时删除栈顶然后返回值的，必须top和pop配合</p>
<pre><code>class Solution {
public:
    string removeDuplicateLetters(string s) {
        map&lt;char,int&gt; s_map;
        for(int i=0;i&lt;s.size();++i)
               s_map[s[i]]=i;
        map&lt;char,int&gt; stack_map;
        stack&lt;char&gt; res;
        for(int i=0;i&lt;s.size();++i){
            if(!stack_map.insert({s[i],i}).second)
                continue;
            while(!res.empty()&amp;&amp;s[i]&lt;res.top()&amp;&amp;s_map[res.top()]&gt;i){
                stack_map.erase(res.top());
                res.pop();
            }
            res.push(s[i]);
        }
        string result;
        while(!res.empty()){
            result= res.top()+result;
            res.pop();
        }
        return result;
    }
};
</code></pre>
]]></content>
    </entry>
</feed>