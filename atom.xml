<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-03-06T00:33:01.446Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>In the darkest night,Rising like a spire.</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[Math 题49:丑数[未做出]]]></title>
        <id>https://lixin-scut.github.io//post/math-ti-49chou-shu-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/math-ti-49chou-shu-wei-zuo-chu">
        </link>
        <updated>2020-03-06T00:17:23.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
</blockquote>
<p>  一开始我想着循环*2 *3 *5，但是突然发现不对啊，比如4，4应该优先*2而不是*3，<br>
也就是说得到的下一个值应该先*2，然后再考虑上一个值*3之类的<br>
当然马上发现也不是绝对，比如1*2后应该继续1*3而不是2*2<br>
似乎可以用一个大顶堆hhh</p>
<p>  然后就是书里的办法吧，类似于动态规划，首先从乘2 乘3 乘5的位置出发，比较三者的最小值，只有最小那个可以前进一步<br>
暴力循环法的话就是理解取余再除以的思想就行，然后超时了，但是ide中通过了数据比</p>
<pre><code>class Solution {
public:
    /*
    //暴力循环法，超时
    int GetUglyNumber_Solution(int index){
        if(index&lt;1)
            return 0;
        int count,res;
        count=1;
        res=1;
        while(count&lt;index){
            ++res;
            int temp=res;
            while(temp%2==0)
                temp/=2;
            while(temp%3==0)
                temp/=3;
            while(temp%5==0)
                temp/=5;
            if(temp==1)
                ++count;
        }
        return res;
    }
    */
    
    
    //动态规划
    int GetUglyNumber_Solution(int index) {
        if(index&lt;1)
            return 0;
        vector&lt;int&gt; uglynum(index,1);
        int multiby2,multiby3,multiby5,count;
        multiby2=0;
        multiby3=0;
        multiby5=0;
        count=1;
        while(count&lt;index){
            int cur_min=min(uglynum[multiby2]*2,uglynum[multiby3]*3,uglynum[multiby5]*5);
            uglynum[count]=cur_min;
            while(uglynum[multiby2]*2&lt;=cur_min)
                ++multiby2;
            while(uglynum[multiby3]*3&lt;=cur_min)
                ++multiby3;
            while(uglynum[multiby5]*5&lt;=cur_min)
                ++multiby5;
            ++count;
        }
        return uglynum[index-1];
    }
    
    int min(int multiby2,int multiby3,int multiby5){
        int temp=std::min(multiby2,multiby3);
        return std::min(temp,multiby5);
    } 
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>  逐个判断每个整数是不是丑数的解法,直观但不够高效<br>
  所谓一个数m是另一个数n的因子，是指n能被m整除 也就是n%m = 0。根据丑数的定义，丑数只能被2、3和5整除。也就是说，如果一个数能被2整除，就连续除以2；如果能被3整除，就连续除以3；如果能被5 整除，就除以连续5。如果最后得到的是1,那么这个数就是丑数；否则不是。</p>
</blockquote>
<pre><code>bool IsUgly(int number)
{
    while(number % 2 == 0)
        number /= 2;
    while(number % 3 == 0)
        number /= 3;
    while(number % 5 == 0)
        number /= 5;

    return (number == 1) ? true : false;
}

int GetUglyNumber_Solution1(int index)
{
    if(index &lt;= 0)
        return 0;

    int number = 0;
    int uglyFound = 0;
    while(uglyFound &lt; index)
    {
        ++number;

        if(IsUgly(number))
            ++uglyFound;
    }

    return number;
}
</code></pre>
<blockquote>
<p>创建数组保存已经找到的丑数，用空间换时间的解法<br>
  前面的算法之所以效率低，很大程度上是因为不管一个数是不是丑数， 我们都要对它进行计算。接下来我们试着找到一种只计算丑数的方法，而不在非丑数的整数上花费时间。根据丑数的定义，丑数应该是另一个丑数乘以2、3或者5的结果(1除外)。因此，我们可以创建一个数组，里面的数字是排好序的丑数，每个丑数都是前面的丑数乘以2、3或者5得到的。<br>
  这种思路的关键在于怎样确保数组里面的丑数是排好序的。假设数组中已经有若干个排好序的丑数，并且把已有最大的丑数记作M,接下来分析如何生成下一个丑数。该丑数肯定是前面某一个丑数乘以2、3或者5的 结果，所以我们首先考虑把已有的每个丑数乘以2。在乘以2的时候，能得到若干个小于或等于M的结果。由于是按照顺序生成的，小于或者等于M 肯定己经在数组中了，我们不需再次考虑；还会得到若干个大于M的结果， 但我们只需要第一个大于M的结果，因为我们希望丑数是按从小到大的顺序生成的，其他更大的结果以后再说。我们把得到的第一个乘以2后大 M的结果记为M2，同样，我们把已有的每个丑数乘以3和5,能得到第一 个大于M的结果M3和M5。那么下一个丑数应该是M2、M3和M5这3个数的最小者。<br>
  在前面分析的时候提到把已有的每个丑数分别乘以2、3和5。事实上这不是必需的，因为已有的丑数是按顺序存放在数组中的。对于乘以2而言，肯定存在某一个丑数T2，排在它之前的每个丑数乘以2得到的结果都会小于已有最大的丑数，在它之后的每个丑数乘以2得到的结果都会太大。 我们只需记下这个丑数的位置，同时每次生成新的丑数的时候去更新这个T2即可。对于乘以3和5而言，也存在同样的T3和T5。</p>
</blockquote>
<pre><code>int GetUglyNumber_Solution2(int index)
{
    if(index &lt;= 0)
        return 0;

    int *pUglyNumbers = new int[index];
    pUglyNumbers[0] = 1;
    int nextUglyIndex = 1;

    int *pMultiply2 = pUglyNumbers;
    int *pMultiply3 = pUglyNumbers;
    int *pMultiply5 = pUglyNumbers;

    while(nextUglyIndex &lt; index)
    {
        int min = Min(*pMultiply2 * 2, *pMultiply3 * 3, *pMultiply5 * 5);
        pUglyNumbers[nextUglyIndex] = min;

        while(*pMultiply2 * 2 &lt;= pUglyNumbers[nextUglyIndex])
            ++pMultiply2;
        while(*pMultiply3 * 3 &lt;= pUglyNumbers[nextUglyIndex])
            ++pMultiply3;
        while(*pMultiply5 * 5 &lt;= pUglyNumbers[nextUglyIndex])
            ++pMultiply5;

        ++nextUglyIndex;
    }

    int ugly = pUglyNumbers[nextUglyIndex - 1];
    delete[] pUglyNumbers;
    return ugly;
}

int Min(int number1, int number2, int number3)
{
    int min = (number1 &lt; number2) ? number1 : number2;
    min = (min &lt; number3) ? min : number3;

    return min;
}
</code></pre>
<blockquote>
<p>和第一种思路相比，第二种思路不需要在非丑数的整数上进行任何计算，因此时间效率有明显提升。但也需要指出，第二种算法由于需要保存已经生成的丑数，则因此需要一个数组，从而增加了空间消耗。如果是求第1500个丑数，则将创建一个能容纳1500个丑数的数组，这个数组占据 6KB的内容空间。而第一种思路没有这样的内存开销。总的来说，第二种思路相当于用较小的空间消耗换取了时间效率的提升。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 题48:最长不含重复字符的子字符串]]></title>
        <id>https://lixin-scut.github.io//post/zi-fu-chuan-ti-48zui-chang-bu-han-chong-fu-zi-fu-de-zi-zi-fu-chuan</id>
        <link href="https://lixin-scut.github.io//post/zi-fu-chuan-ti-48zui-chang-bu-han-chong-fu-zi-fu-de-zi-zi-fu-chuan">
        </link>
        <updated>2020-03-05T23:55:49.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子<br>
字符串的长度。假设字符串中只包含从'a'到'z'的字符。在字符串&quot;arabcacfr&quot;中，最长的不含重复字符的子字符串是&quot;acfr&quot;,长度为4。</p>
</blockquote>
<blockquote>
<p>  我们不难找出字符串的所有子字符串，然后就可以判断每个子字符串中是否包含重复的字符。这种蛮力法唯一的缺点就是效率。一个长度为n的字符串有O(n<sup>2)个子字符串，我们需要O(n)的时间判断一个子字符串中是否包含重复的字符，因此该解法的总的时间效率是O(n</sup>3)</p>
</blockquote>
<pre><code>int longestSubstringWithoutDuplication_1(const std::string&amp; str)
{
    int longest = 0;
    int* position = new int[26];
    for(int start = 0; start &lt; str.length(); ++start)
    {
        for(int end = start; end &lt; str.length(); ++end)
        {
            int count = end - start + 1;
            const std::string&amp; substring = str.substr(start, count);
            if(!hasDuplication(substring, position))
            {
                if(count &gt; longest)
                    longest = count;
            }
            else
                break;

        }
    }
		delete[] position;
    return longest;
}

bool hasDuplication(const std::string&amp; str, int position[])
{
    for(int i = 0; i &lt; 26; ++i)
        position[i] = -1;

    for(int i = 0; i &lt; str.length(); ++i)
    {
        int indexInPosition = str[i] - 'a';
        if(position[indexInPosition] &gt;= 0)
            return true;

        position[indexInPosition] = indexInPosition;
    }

    return false;
}
</code></pre>
<blockquote>
<p>  接下来我们用动态规划算法来提高效率。首先定义函数f(i)表示以第i个字符为结尾的不包含重复字符的字符串的最长长度。我们从左到右逐一扫描字符串中的每个字符。当我们计算以第i个字符为结尾的不包含重复字符的子字符串的最长长度f(i)时，我们已经知道f(i-1)。<br>
  如果第i个字符之前没有出现过，那么f(i)=f(i-1)+1.例如，在字符串&quot;arabcacfr&quot;中，显然f(0)等于1。在计算f(1)时，下标为1的字符‘r’之前没有出现过，因此f(1)等于2,即f(1)=f(0)+1。到目前为止，最长的不含重复字符的子字符串是&quot;ar&quot;.<br>
  如果第i个字符之前已经出现过，那情况就要复杂一点了。我们先计算第i个字符和它上次出现在字符串中的位置的距离，并记为d，接着分两种情形分析。第一种情形是d小于或者等于f(i-1),此时第i个字符上次出现在f(i-1)对应的最长子字符串之中，因此f(i)=d。同时这也意味着在第i个字符出现两次所夹的子字符串中再也没有其他重复的字符了。在前面的例子中，我们继续计算f(2),即以下标为2的字符a为结尾的不含重复字符的子字符串的最长长度。我们注意到字符a在之前出现过，该字符上一次出现在下标为0的位置，它们之间的距离d为2,也就是字符a出现在f(1)对应的最长不含重复字符的子字符串&quot;ar&quot;中，此时f(2)=d,即f(2)=2,对应的最长不含重复字符的子字符串是&quot;ra&quot;。<br>
  第二种情形是d大于f(i-1),此时第i个字符上次出现在f(i-1)对应的最长子字符串之前，因此仍然有f(i)=f(i-1)+1。我们接下来分析以字符串 &quot;arabcacfr&quot;最后一个字符r为结尾的最长不含重复字符的子字符串的长度， 即求f(8)。以它前一个字符f为结尾的最长不含重复字符的子字符串是acf, 因此f(7)=3。我们注意到最后一个字符r之前在字符&quot;arabcacfr&quot;中出现过, 上一次出现在下标为1的位置，因此两次出现的距离d等于7,大于f(7).这说明上一个字符r不在f(7)对应的最长不含重复字符的子字符串acf中， 此时把字符r拼接到acf的后面也不会出现重复字符。此,f(8)=f(7)+1,即 f(8)=4,对应的最长不含重复字符的子字符串是acfr<br>
  我们创建了一个长度为26的数组position用来存储每个字符上次出现在字符串中位置的下标。该数组所有元素的值都初始化为 -1.负数表示该元素对应的字符在字符串中还没有出现过。我们在扫描字符串时遇到某个字符，就把该字符在字符串中的位置存储到数组对应的元素中。</p>
</blockquote>
<pre><code>// 方法一：动态规划
int longestSubstringWithoutDuplication_2(const std::string&amp; str)
{
    int curLength = 0;
    int maxLength = 0;

    int* position = new int[26];
    for(int i = 0; i &lt; 26; ++i)
        position[i] = -1;

    for(int i = 0; i &lt; str.length(); ++i)
    {
        int prevIndex = position[str[i] - 'a'];
        if(prevIndex &lt; 0 || i - prevIndex &gt; curLength)
            ++curLength;
        else
        {
            if(curLength &gt; maxLength)
                maxLength = curLength;

            curLength = i - prevIndex;
        }
        position[str[i] - 'a'] = i;
    }

    if(curLength &gt; maxLength)
        maxLength = curLength;

    delete[] position;
    return maxLength;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 题47:礼物的最大价值]]></title>
        <id>https://lixin-scut.github.io//post/dong-tai-gui-hua-ti-47li-wu-de-zui-da-jie-zhi</id>
        <link href="https://lixin-scut.github.io//post/dong-tai-gui-hua-ti-47li-wu-de-zui-da-jie-zhi">
        </link>
        <updated>2020-03-05T23:42:51.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>在一个m×n的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向左或者向下移动一格直到到达棋盘的右下角。给定一个棋盘及其上面的礼物，请计算你最多能拿到多少价值的礼物？</p>
</blockquote>
<p>书本题解：</p>
<blockquote>
<p>  根据题目要求，我们有两种可能的途径到达坐标为（i,j）的格 子：通过格子(i-1,j)或者(i,j-1)。 所以f(i,j)= max(f(i-1,j),f((i,j-1)) + gift(i,j)= gift(i,j)表示坐标为(i,j)的格子里礼物的价值。<br>
  尽管我们用递归来分析问题，但由于有大量重复的计算，导致递归的代码并不是最优的。相对而言，基于循环的代码效率要高很多。为了缓存 中间计算结果，我们需要一个辅助的二维数组。数组中坐标为(i,j)的元素表 示到达坐标为(i,j)的格子时能拿到的礼物价值总和的最大值。</p>
</blockquote>
<pre><code>int getMaxValue_solution1(const int* values, int rows, int cols)
{
    if(values == nullptr || rows &lt;= 0 || cols &lt;= 0)
        return 0;

    int** maxValues = new int*[rows];
    for(int i = 0; i &lt; rows; ++i)
        maxValues[i] = new int[cols];

    for(int i = 0; i &lt; rows; ++i)
    {
        for(int j = 0; j &lt; cols; ++j)
        {
            int left = 0;
            int up = 0;

            if(i &gt; 0)
                up = maxValues[i - 1][j];

            if(j &gt; 0)
                left = maxValues[i][j - 1];

            maxValues[i][j] = std::max(left, up) + values[i * cols + j];
        }
    }

    int maxValue = maxValues[rows - 1][cols - 1];

    for(int i = 0; i &lt; rows; ++i)
        delete[] maxValues[i];
    delete[] maxValues;

    return maxValue;
}
</code></pre>
<blockquote>
<p>  接下来我们考虑进一步的优化。前面我们提到，到达坐标为（i,j）的格子 时能够拿到的礼物的最大价值只依赖坐标为（i-1,j）和（i,j-1）的两个格子，因此第i-2行及更上面的所有格子礼物的最大价值实际上没有必要保存下来。 我们可以用一个一维数组来替代前面代码中的二维矩阵maxvalues。</p>
</blockquote>
<pre><code>int getMaxValue_solution2(const int* values, int rows, int cols)
{
    if(values == nullptr || rows &lt;= 0 || cols &lt;= 0)
        return 0;

    int* maxValues = new int[cols];
    for(int i = 0; i &lt; rows; ++i)
    {
        for(int j = 0; j &lt; cols; ++j)
        {
            int left = 0;
            int up = 0;

            if(i &gt; 0)
                up = maxValues[j];

            if(j &gt; 0)
                left = maxValues[j - 1];

            maxValues[j] = std::max(left, up) + values[i * cols + j];
        }
    }

    int maxValue = maxValues[cols - 1];

    delete[] maxValues;

    return maxValue;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[服务端异常情况]]></title>
        <id>https://lixin-scut.github.io//post/fu-wu-duan-yi-chang-qing-kuang</id>
        <link href="https://lixin-scut.github.io//post/fu-wu-duan-yi-chang-qing-kuang">
        </link>
        <updated>2020-03-05T12:39:28.000Z</updated>
        <content type="html"><![CDATA[<p>正常终止<br>
&lt;Ctrl+D&gt;是我们的终端EOF字符，键入终端EOF字符（Control-D）以终止客户<br>
当前连接的客户端发送fin和ack后会进入了TIME_WAIT状态</p>
<p>我们可以总结出正常终止客户和服务器的步骤。<br>
⑴当我们键入EOF字符时，fgets返回一个空指针，于是str_cli函数返回。<br>
(2)	当str_cli返回到客户的main函数时，main通过调用exit终止。<br>
(3)	进程终止处理的部分工作是<strong>关闭所有打开的描述符</strong>，因此客户打开的套接字由内核关闭。这导致客户TCP发送一个FIN给服务器，服务器TCP则以ACK响应，这就是TCP连接终止序 列的前半部分。至此，<strong>限务器套接字处于CLOSE_WAIT状态，客户套接字则处于FIN_WAIT_2 状态</strong><br>
(4)	当服务器TCP接收FIN时，服务器子进程阻塞于readline调用，于是readline 返回0。这导致str_echo函数返回服务器子进程的main函数。<br>
(5)	服务器子进程通过调用exit来终止。<br>
(6)	服务器子进程中打开的所有描述符随之关闭。由<strong>子进程</strong>来关闭已连接套接字会引发TCP 连接终止序列的最后两个分节：一个从服务器到客户的FIN和一个从客户到服务器的ACK 。至此，连接完全终止，客户套接字进入TIME_WAIT状态。<br>
(7)	进程终止处理的另一部分内容是：在服务器子进程终止时，给<strong>父进程</strong>发送一个SIGCHLD 信号。，但是我们没有在代码中捕获该信号，而该信号的默认行为是被回 忽略。既然父进程未加处理，子进程于是<strong>进入僵死状态</strong>。可以使用ps命令验证这--点。如果stat列为Z，且command列后面带有＜defunct＞字样，就属于僵死进程<br>
进程的状态是Z (表示僵死)。我们必须清理僵死进程，这就涉及Unix信号的处理。</p>
<h1 id="处理sigchld信号">处理SIGCHLD信号</h1>
<p>设置僵死（zombie）状态的目的是维护子进程的信息，以便父进程在以后某个时候获取。 这些信息包括子进程的进程ID、终止状态以及资源利用信息（CPU时间、内存使用量等等）。<br>
如果一个进程终止，而该进程有子进程处于僵死状态，那么它的所有僵死子进程的父进程ID将被重置为1（init进程）。继承这些子进程的init让进程将清理它们（也就是说init进程将wait它们，从而去除它们的僵死状态）。<br>
僵死占用内核中的空间，最终可能导致我们耗尽进程资源<br>
无论何时我们fork子进程都得wait它们，以防它们变成偶死进程。为此我们建立一个俘获 SIGCHLD信号的信号处理函数，在函数体中我们调用wait.</p>
<pre><code>Signal（SIGCHLD, sig_chld）;

1	#include	&quot;unp.h&quot;	.
2	void
3	sig_chld（int signo）
4	{
5	pid_t	pid;
6	int	stat;
7	pid = wait（&amp;stat）;
8	printf（&quot;child %d terminated\n&quot;, pid）；
9	return；
10	}
</code></pre>
<p>具体的各个步骤如下：<br>
（1）	我们键入EOF字符来终止客户。客户TCP发送一个FIN给服务器，服务器响应以一个 ACK。<br>
（2）	收到客户的FIN导致服务器TCP递送一个EOF给<strong>子进程阻塞中的readline</strong>,从而<strong>子进程终止</strong>。<br>
（3）	当SIGCHLD信号递交时，<strong>父进程阻塞于accept调用</strong>。sig_chld函数（信号处理函数） 执行，其wait调用取到子进程的PID和终止状态，随后是printf调用，最后返回。<br>
（4）	既然该信号是在父进程阻塞于慢系统调用（accept）时由父进程捕获的，内核就会使<strong>accept返回一个EINTR错误（被中断的系统调用）。而父进程不处理该错误,于是中止。</strong></p>
<p>本书使用的编程约定之一，我们总是在信号处理函数中显式给出return语句，这么一来，当某个系统调用被我们编写的某个信号处理函数中断时，我们就可以得知该系统调用具体是被哪个信号处理函数的哪个return语句中断的。</p>
<ul>
<li>处理被中断的系统调用<br>
慢系统调用（slow system call）：适用于那些可能 永远阻塞的系统调用。永远阻塞的系统调用是指调用有可能永远无法返回，多数网络支持函数都属于这一类，例如accept。<br>
一个值得注意的例外是磁盘I/O,它们一般都会返回到调用者（假设没有灾难性的硬件故障）。<br>
适用于慢系统调用的基本规则是：当阻塞于某个慢系统调用的一个进程捕获某个信号且相应信号处理函数返回时，该系统调用可能返回一个<strong>EINTR错误</strong>。<br>
设置SA_RESTART标志可以使得内核自动重启调用<br>
了处理被中断的accept,我们把对accept的调用从for循环开始改起</li>
</ul>
<pre><code>for ( ; ; ) (
	clilen = sizeof(cliaddr);
	if ( (connfd =accept(listenfd, (SA *) &amp;cliaddr, &amp;clilen)) &lt; 0) { 
		if (errno == EINTR) 
				continue;	/* back to for() */
		else
				err_sys(&quot;accept error&quot;);
}
</code></pre>
<p>注意！<strong>有一个函数我们不能重启：connect</strong>。如果该函数返回EINTR,我们就不能再次调用它，否则将立即返回一个错误。当connect被一个捕获的 信号中断而且不自动重启时，我们必须调用select来等待连接完成</p>
<h1 id="wait-和-waitpid-函数">wait 和 waitpid 函数</h1>
<p>调用了函数wait:来处理己终止的子进程。</p>
<pre><code>#include &lt;sys/wait.h&gt;
		pid_t wait (int *statloc)；
		pid_t waitpid(pid_t pid, int *statloc, int options);
均返回：若成功则为进程ID,若出错则为。或-1
</code></pre>
<p>函数wait和waitpid均返回两个值：已终止子进程的进程ID号，以及通过指针返回 的子进程终止状态(一个整数)。<br>
我们可以调用三个宏来检查终止状态，并辨别子进程是正常终止、由某个信号杀死还是仅仅由作业控制停止而已。<br>
如果调用wait的进程没有已终止的子进程，不过有一个或多个子进程仍在执行，那么wait 将阻塞到现有子进程第一个终止为止。<br>
waitpid函数就等待哪个进程以及是否阻塞给了我们更多的控制。首先，pid参数允许我们<strong>指定想等待的进程ID</strong>,值-1表示等待第一个终止的子进程。<br>
options参数允许我们指定附加选项。最常用的选项是WNOHANG,它告知内核在<strong>没有已终止子进程时不要阻塞</strong></p>
<ul>
<li>函数wait和waitpid的区别<br>
使用wait的情况下：<br>
假设有5个客户连接到服务器，当客户终止时，所有打开的描述符由内核自动关闭(我们不调用close,仅调用exit),且所有5个<strong>连接基本在同一时刻终止</strong>。这就引发了5个FIN,每个连接一个，它们反过来使服务器 的5个子进程基本在同一时刻终止。这导致差不多在同一时刻有<strong>5个SIGCHLD信号递交给父进程</strong><br>
这是按照预期所有5个子进程都终止了， 如果运行ps,我们将发现其他4个子进程仍然作为<strong>僵死进程</strong>存在着。<br>
原因：同一Unix信号一般是不重复排队的，建立一个信号处理函数并在其中调用wait并不足以防止出现僵死进程。本问题在于：所有5个信号都在信号处理函数执行之前产生，而<strong>信号处理函数只执行一次</strong>。<br>
更严重的是，本问题是不确定的，信号处理函数的执行次数依赖于FIN到达服务器主机的时机，</li>
</ul>
<p>正确的解决办法是调用waitpid而不是wait：<br>
这个版本管用的原因在于：我们在一个循环内调用waitpid,以获取所有已终止于进程的状态。<br>
我们必须指定WNOHANG选项，它告知waitpid在有尚未终止的子进程在运行时<strong>不要阻塞</strong>。<strong>不能在循环内调用wait</strong>,因为没有办法防止wait在正运行的子进程尚有未终止时阻塞。</p>
<p>关于<strong>wait和SIGCHLD信号</strong>注意事项：<br>
其实不一定要在SIGCHLD里调用wait，也可以直接wait<br>
注意！！！wait和信号之间没有关联，我们是捕获到sigchild信号就进行wait处理，而不是说wait本身等待信号进行调用，所以就算不排队，接收到一个信号后就能进行waitpid处理当前所有的僵死进程，而wait只能处理已个，并且不能通过循环wait解决因为会阻塞。<br>
<strong>所以！！！wait和信号无关！哪怕没有信号我也能调用wait和waitpid循环来<br>
清除僵死进程</strong></p>
<pre><code>//tcpserv04.c
//Code by Lixin on 2020/01/14

#include &quot;unp.h&quot;

int 
main(int argc,char **argv){
	int listenfd,connfd;
	pid_t childpid;
	socklen_t clilen;
	struct sockaddr_in cliaddr,servaddr;
	void sig_chld(int);
	listenfd=socket(AF_INET,SOCK_STREAM,0);
	bzero(&amp;servaddr,sizeof(servaddr));
	servaddr.sin_family=AF_INET;
	servaddr.sin_port=htons(SERV_PORT);
	servaddr.sin_addr.s_addr=htonl(INADDR_ANY);

	bind(listenfd,(SA *)&amp;servaddr,sizeof(servaddr));
	listen(listenfd,LISTENQ);
	signal(SIGCHLD,sig_chld);
	for(;;){
		clilen=sizeof(cliaddr);
		if((connfd=accept(listenfd,(SA *)&amp;cliaddr,&amp;clilen))&lt;0){
			if(errno==EINTR)
				continue;
			else
				err_sys(&quot;accept error&quot;);
		}
		if((childpid=fork())==0){
			close(listenfd);
			str_echo(connfd);
			exit(0);
		}
		close(connfd);
	}
}
</code></pre>
<p>我们的服务器程序的最终版本。它正确处理accept返回的EINTR,并建立一个给所有己终止子进程调用waitpid的信号处理函数<br>
本节的目的是示范我们在网络编程时可能会遇到的三种情况：<br>
(1)	当fork子进程时，必须捕获SIGCHLD信号；<br>
(2)	当捕获信号时，必须处理被中断的系统调用；<br>
(3)	S1GCHLD的信号处理函数必须正确编写，应使用waitpid函数以免留下僵死进程。</p>
<h1 id="accept返回前连接中止">accept返回前连接中止</h1>
<p>accept返回一个非致命的错误，在这种情况下，只需要再次调用accept，典型的是较忙的Web服务器。<br>
三路握手完成从而连接建立之后，客户TCP却发送了一个RST （复位）。在服务器端看来，就在该连接已由TCP排队，等着服务器进程调用accept的时候RST到达。<br>
如何处理这种中止的连接依赖于不同的实现，POSIX 指出返回的 errno 值必须是ECONNABORTED<br>
POSIX作出修改的理由在于：流子系统(streams subsystem)中发生某些致命的协议相关事件时，也会返回EPROTO。要是对于由客户引起的一个 已建立连接的非致命中止也返回同样的错误，那么服务器就不知道该再次调用accept还是不该 了。换成ECONNABORTED错误，服务器就可以忽略它，再次调用accept就行。</p>
<h1 id="服务器进程终止">服务器进程终止</h1>
<p>模拟服务器已连接的子进程终止：<br>
1.找到服务器子进程的进程ID,并执行kill命令杀死它。作为进程终止处理的部分工作， 子进程中所有打开着的描述符都被关闭。这就导致<strong>向客户发送一个FIN</strong>,<br>
2.客户段传输层TCP接收FIN此时响应以一个ACK，同时按照预设客户端应用层应当读入套接字的FIN准备关闭程序并发送客户端的FIN给服务端，但是！！此时进程<strong>拥塞在fgets</strong>上，等待从<strong>终端（也就是键盘！）</strong> 接收一行文本，导致<strong>没法去读取套接字的FIN！</strong><br>
<strong>（这里注意区分有两个流，一个是键盘，一个是网络套接字）</strong><br>
<strong>（但是此时客户端传输层TCP已经收到FIN了并向服务端发送ACK了，同时把状态转化为CLOSE_WAIT，可以用netstat查询，这一切都不需要应用层插手）</strong><br>
3.假设此时客户端接收到键盘的输入文本并发送给服务端，当服务器TCP接收到来自客户的数据时，既然先前打开那个套接字的进程已经终止，于是 响应以一个RST。<br>
4.然而客户进程看不到这个RST,因为它在调用writen后立即调用readline,并且由于接收的FIN,所调用的readline立即返回0 （表示EOF）。我们的客户此时<strong>并未预期收到 EOF</strong>，于是以出错信息&quot;server terminated prematurely”（服务器过早终止）退出。当客户终止时（通过调用err_quit）,它所有打开着的描述符都被关闭。<br>
<strong>（注意这里为什么说未预期收到EOF呢？因为ECHO服务器是假设只能由客户端关闭的，所以客户端一开始没加上接收FIN的处理，比如微信，总不能让腾讯来先发送FIN关闭我手机上的微信吧？）</strong></p>
<p>根本原因：当FIN到达套接字时，客户正阻塞在fgets调用上。客户实际上<strong>在应对两个描述符</strong>--套接字（网络）和用户输入（键盘），它不能单纯阻塞在这两个源中某个特定源的输入上（正如 目前编写的str.cli函数所为），而是应<strong>该阻塞在其中任何一个源的输入上</strong>。事实上这正是 <strong>select和poll这两个函数的目的之一</strong></p>
<p>关于RST：<br>
上述讨论还取决于本例子的时序，客户调用readline既可能发生在服务器的RST 被客户收到之前，也可能发生在收到之后，如果readline发生在<strong>收到RST之前</strong>（如本例子所 示），那么结果是客户得到一个未预期的EOF；如果readline发生在<strong>收到RST之后</strong>，否则结果是由readline返回一个ECONNRESET （connection reset by peer，对方复位连接错误）.<br>
猜测原因：服务端发送RST会导致任何排队的数据都被抛弃，RST优先级最高，会被立即发出去，所以可能导致FIN还在排队的时候就已经被抛弃了<br>
疑惑：那如果FIN比RST先到达接收方会怎么样？</p>
<h1 id="sigpipe-信号">SIGPIPE 信号</h1>
<p>要是客户不理会readline函数返回的错误，反而写入更多的数据到服务器上，那又会发生什么呢？<br>
当一个进程向某个己收到RST的套接字执行写操作时，<strong>（客户端的）内核</strong>向该进程发送一个SIGPIPE信号.该信号的默认行为是终止进程，因此进程必须捕获它以免不情愿地被终止，同时写操作都将返回EPTPE错误。<br>
第一次写操作引发RST,第二次写引发SIGPIPE信号.写一个已接收了FIN的套接字不成问题，但是写一个已接收了 RST的套接字则是一个<strong>错误</strong>.<br>
处理SIGPIPE的建议方法取决于它发生时应用进程想做什么（比如写入log日志）<br>
但是必须意识到，如果使用 了多个套接字，该信号的递交无法告诉我们是哪个套接字出的错。如果我们确实需要知 道是哪个write出了错，那么必须要么不理会该信号，要么从信号处理函数返回后再处 理来自write的EPIPE。</p>
<h1 id="服务器主机崩溃">服务器主机崩溃</h1>
<p>注意区分进程终止和崩溃，模拟前者一般是使用kill信号，模拟后者则需要从网络上断开服务器主机，这样同时也模拟了当客户发送数据时服务器主机不可达的情形(即建立连接后某些中间路由器不工作)。</p>
<p>客户端发送数据后，等待服务器的ACK，因而阻塞在readline调用上，假设服务器主机己崩溃，从而对客户的数据分节根本没有响应，那么所返回的错误是 ETIMEDOUT（从readline调用返回的）<br>
然而如果某个中间路由器判定服务器主机已不可达，从而响应以一个“destination unreachable&quot;(目的地不可达)ICMP消息，那么所返回的错误是EHOSTUNREACH或ENETUNREACH。</p>
<p>如果希望更快地检测出这种情况，可以对readline调用设置一个超时</p>
<p>上述情形只有在我们向服务器主机发送数据时才能检测出它已经崩溃。如果希望不主动向它发送数据也能检测出服务器主机的崩溃，那么需要采用另外一个技术--SO_KEEPALIVE套接字选项。</p>
<h1 id="服务器主机崩溃后重启">服务器主机崩溃后重启</h1>
<p>模拟这种情形的最简单方法就是：先建立连接，再从网络上 函 断开服务器主机，将它关机后再重新启动，最后把它重新连接到网络中。<br>
处理方法重点在于：我们<strong>不想客户知道服务器主机的关机</strong></p>
<p>普通情况下：<br>
(1)	当服务器主机崩溃后重启时，它的TCP丢失了崩溃前的所有连接倍息，因此服务器TCP 对于所收到的来自客户的数据分节响应以一个RST。<br>
(2)	当客户TCP收到该RST时，客户正阻塞于readline调用，导致该调用返回ECONNRESET 错误。</p>
<h1 id="服务器主机关机">服务器主机关机</h1>
<p>当服务器子进程终止时，它的所 有打开着的描述符都被关闭，随后发生的步骤与服务器进程终止那一节一样，我们必须在客户中使用select或poll函数，使得服务器进程的终止一经发生，客户就能检测到。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[优雅地关闭连接-shutdown() 和 close() 的区别]]></title>
        <id>https://lixin-scut.github.io//post/you-ya-di-guan-bi-lian-jie-shutdown-he-close-de-qu-bie</id>
        <link href="https://lixin-scut.github.io//post/you-ya-di-guan-bi-lian-jie-shutdown-he-close-de-qu-bie">
        </link>
        <updated>2020-03-05T12:03:13.000Z</updated>
        <content type="html"><![CDATA[<h3 id="close-函数">close 函数</h3>
<pre><code>#include &lt;unistd.h&gt;
int close(int sockfd)；	
返回：若成功则为0,若出错则为-1
</code></pre>
<p>close一个TCP套接字的默认行为是把该套接字标记成己关闭，然后立即返回到调用进程。 该套接字描述符不能再由调用进程使用，也就是说它不能再作为read或write的第一个参数。<br>
注意close只是应用层的，TCP将继续尝试发送已排队等待发送到对端的任何数据，发送完毕后发生的是正常的TCP连接终止序列。</p>
<p>描述符引用计数<br>
<strong>close调用并不引发TCP的四分组连接终止序列，如果我们确实想在某个TCP连接上发送一个FIN,那么可以改用shutdown函数以代替close！！！</strong><br>
父进程必须调用close，如果父进程对每个由accept返回的已连接套接字都不调用close，父进程最终将耗尽可用描述符，因为没有一个客户连接会被终止。当子进程关闭已连接套接字时，它的引用计数值将由2递减为1且保持为1,因为父进程永不关闭任何己连接套接字。这将妨碍TCP连接终止序列的发生，导致连接一直打开看。</p>
<h3 id="shutdown函数">shutdown函数</h3>
<p><img src="https://lixin-scut.github.io//post-images/1579097744777.png" alt=""><br>
终止网络连接的通常方法是调用close函数。不过close有两个限制，却可以使用shutdown 来避免。<br>
（1）	close把描述符的引用计数减1,仅在该计数变为0时才关闭套接字。使用shutdown可以不管引用计数就激发TCP的正常连接终止序列（图2-5中由FIN开始的4个分节）。<br>
（2）	close终止读和写两个方向的数据传送。<br>
shutdown可以指定关闭读端、写端还是读写端</p>
<pre><code>#include &lt;sys/socket.h&gt;
		int shutdown (int sockfd, int howto)；
				返回：若成功则为0,若出错则为-1
</code></pre>
<p>该函数的行为依赖于howto参数的值：<br>
SHUT_RD：关闭连接的读这一半——套接字中不再有数据可接收，而旦套接字接收缓冲区中的现有数据都被丢弃。进程不能再对这样的套接字调用任何读函数。对一个 TCP套接字这样调用shutdown函数后，由该套接字接收的来自对端的任何数据都被确认，然后悄然丢弃。<br>
SHUT_WR：关闭连接的写这一半——对于TCP套接字，这称为半关闭（half-close）。当前留在套接字发送缓冲区中的数据将被发送掉，后跟TCP的正常连接终止序列。不管套接字描述符的引用计数是否等于0,这样的写半部关闭照样执行。进程不能再对这样的套接字调用任何写函数。<br>
SHUT_RDWR：连接的读半部和写半部都关闭——这与调用shutdown两次等效：第一次调用指定SHUT_RD,第二次调用指定SHUT_WR。</p>
<h3 id="shutdown-和-close-的区别">shutdown() 和 close() 的区别</h3>
<p>从函数调用上来分析（msdn)：一旦完成了套接字的连接，应当将套接字关闭，并且释放其套接字句柄所占用的所有资源。真正释放一个已经打开的套接字句柄的资源直接调用closesocket即可，但要明白closesocket的调用可能会带来负面影响，具体的影响和如何调用有关，最明显的影响是数据丢失，因此一般都要在closesocket之前调用shutdown来关闭套接字。<br>
shutdown:为了保证通信双方都能够收到应用程序发出的所有数据，一个合格的应用程序的做法是通知接受双发都不在发送数据！这就是所谓的“正常关闭 ”套接字的方法，而这个方法就是由shutdown函数,传递给它的参数有SD_RECEIVE,SD_SEND,SD_BOTH三种，如果是 SD_RECEIVE就表示不允许再对此套接字调用接受函数。这对于协议层没有影响，另外对于tcp套接字来说，无论数据是在等候接受还是即将抵达，都要重置连接（注意对于udp协议来说，仍然接受并排列传入的数据，因此udp套接字而言shutdown毫无意义）。如果选择SE_SEND,则表示不允许再调用发送函数。对于tcp套接字来说，这意味着会在所有数据发送出并得到接受端确认后产生一个FIN包。如果指定SD_BOTH，答案不言而喻。<br>
closesocket:对此函数的调用会释放套接字的描述，这个道理众所周知（凡是经常翻阅msdn的程序员），因此，调用此函数后，再是用此套接字就会发生调用失败，通常返回的错误是WSAENOTSOCK。此时与被closesocket的套接字描述符相关联的资源都会被释放，包括丢弃传输队列中的数据！！！！对于当前进程中的线程来讲，所有被关起的操作，或者是被挂起的重叠操作以及与其关联的任何事件，完成例程或完成端口的执行都将调用失败！另外 SO_LINGER标志还影响着closesocket的行为，但对于传统的socket程序，这里不加解释<br>
因此可以可以看出shutdown对切断连接有着合理的完整性。<br>
下面从tcp协议上来分析shutdown和closesocket的行为（behavior)：closesocket或shutdown(使用 SD_SEND当作参数时）,会向通信对方发出一个fin包，而此时套接字的状态会由ESTABLISHED变成FIN_WAIT_1，然后对方发送一个 ACK包作为回应，套接字又变成FIN_WAIT_2，如果对方也关闭了连接则对方会发出FIN，我方会回应一个ACK并将套接字置为 TIME_WAIT。因此可以看出closesocket,shutdown所进行的TCP行为是一样的，所不同的是函数部分，shutdown会确保 windows建立的数据传输队列中的数据不被丢失，而closesocket会冒然的抛弃所有的数据，因此如果你愿意closesocket完全可以取代shutdown,然而在数据交互十分复杂的网络协议程序中，最好还是shutdown稳妥一些</p>
<h3 id="so_linger套接字选项">SO_LINGER套接字选项</h3>
<p>本选项指定close函数对面向连接的协议（例如TCP和SCTP,但不是UDP）如何操作。默 认操作是close立即返回，但是如果有数据残留在套接字发送缓冲区中，系统将试着把这些数据发送给对端。<br>
<img src="https://lixin-scut.github.io//post-images/1579433640262.png" alt=""><br>
SO_LINGER套接字选项使得我们可以改变这个默认设置。本选项要求在用户进程与内核间 传递如下结构，它在头文件＜sys/socket.h＞中定义：</p>
<pre><code>struct linger（
int	l_onoff;	/* ==off, nonzero=on */
int l_linger；	/* linger time, POSIX specifies units as seconds */
};
</code></pre>
<p>对setsockopt的调用将根据其中两个结构成员的值形成下列3种情形之一：<br>
（1）	如果l_onoff为0,那么关闭本选项。l_linger的值被忽略，先前讨论的TCP默认设置生效，即close立即返回。<br>
（2）	如果l_onoff为非0值且linger为0,那么当close某个连接时TCP将中止该连接 。这就是说TCP将丢弃保留在套接字发送缓冲区中的任何数据，并发送一个RST给对端，而没有通常的四分组连接终止序列。这么一来避免了TCP的TIME_WAIT状态，然而存在以下可能性：在2MSL秒内创建该连接的另一个化身，导致来自刚被终止的连接上的旧的重复分节被不正确地递送到新的化 身上。<br>
（3）如果l_onoff为非0值且linger也为非0值，那么当套接字关闭时内核将拖延一段时 间。这就是说如果在套接字发送缓冲区中仍残留有数据，那么进程将被投入睡眠，直到（a）所 有数据都已发送完且均被对方确认或（b）延滞时间到。如果套接字被设置为非阻塞型，那么它将不等待Close完成，即使延滞时间为非0也是如此。<br>
当使用SO_LINGER选项的这个 特性时，应用进程检查close的返回值是非常重要的，因为如果在数据发送完并被确认前延滞 时间到的话，close将返回EWOULDBLOCK错误，且套接字发送缓冲区中的任何残留数据都被丢弃。<br>
<img src="https://lixin-scut.github.io//post-images/1579433666835.png" alt=""><br>
默认情况下客户的close立即返回。 如图所示，客户的close可能在服务器读套接字接收缓区中的剩余数据之前就返回。对于服务 器主机来说，在服务器应用进程读这些剩余数据之前就崩溃是完全可能的，而且客户应用进程 永远不会知道。<br>
<img src="https://lixin-scut.github.io//post-images/1579433677337.png" alt=""><br>
客户可以设置SO_LINGER套接字选项，指定一个正的延滞时间。这种情况下客户的close 要到它的数据和FIN已被服务器主机的TCP确认后才返回<br>
然而我们仍然有与图7-7一样的问题：在服务器应用进程读这些剩余数据之前就崩溃是完全可能的，而且客户应用进程 永远不会知道。</p>
<p>更糟糕的是，图7-9展示了当给SO_LINGER选项设置偏低的延滞时间值时可能发生的现象。<br>
<img src="https://lixin-scut.github.io//post-images/1579433688864.png" alt=""><br>
这里有一个基本原则：设置SO_LINGER套接字选项后，close的成功返回只是告诉我们先 前发送的数据(和FIN)已由对端TCP确认，而不能告诉我们对端应用进程是否已读取数据。如 果不设置该套接字选项，那么我们连对端TCP是否确认了数据都不知道。<br>
让客户知道服务器己读取其数据的一个方法是改为调用shutdown (并设置它的第二个参数 为SHUT_WR)而不是调用close,并等待对端close连接的当地端(服务器端)<br>
<img src="https://lixin-scut.github.io//post-images/1579433700519.png" alt=""><br>
当关闭连接的本地端(客户端)时，根据所调用的函 数(close或shutdown)以及是否设置了SO_LINGER套接字选项，可在以下3个不同的时机返 回：<br>
(1)	close立即返回，根本不等待(默认状况，图7-7).<br>
(2)	close一直拖延到接收了对于客户端FIN的ACK才返回(图7-8).<br>
(3)后跟一个read调用的shutdown一直等到接收了对端的FIN才返回(图7-10).</p>
<p>获知对端应用进程已读取我们的数据的另外一个方法是使用应用级确认(application-level acknowledge),简称应用ACK (applicationACK)<br>
<img src="https://lixin-scut.github.io//post-images/1579433723131.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1579433736764.png" alt=""></p>
<p><img src="https://lixin-scut.github.io//post-images/1579433758408.png" alt=""></p>
<p><img src="https://lixin-scut.github.io//post-images/1579433770612.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Nagle 算法]]></title>
        <id>https://lixin-scut.github.io//post/nagle-suan-fa</id>
        <link href="https://lixin-scut.github.io//post/nagle-suan-fa">
        </link>
        <updated>2020-03-05T10:15:02.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>起因<br>
在ssh连接中，通常单次击键就会引发数据流的传输。如果使用IPv4, 一次按键会生成约88字节大小的TCP/IPV4包（使用加密和认证）：20字节的IP头部，20字节的TCP头部（假设没有选项），数据部分为48字节。这些小包（称为微型 报（tinygram））会造成相当高的网络传输代价。也就是说，与包的其他部分相比，有效的应 用数据所占比例甚微。该问题对于局域网不会有很大影响，因为大部分局域网不存在拥塞， 而且这些包无须传输很远。然而对于广域网来说则会加重拥塞，严重影响网络性能。</p>
</blockquote>
<h3 id="nagle算法">Nagle算法</h3>
<p>  Nagle算法要求，当一个TCP连接中有在传数据（即那些已发送但还未经确认的数据）， 小的报文段（长度小于SMSS）就不能被发送，直到所有的在传数据都收到ACK。并且，在收到ACK后，TCP需要收集这些小数据，将其整合到一个报文段中发送。这种方法迫使 TCP遵循停等（stop-and-wait）规程——只有等接收到所有在传数据的ACK后才能继续发 送。该算法的精妙之处在于它实现了自时钟（self.clocking）控制：ACK返回越快，数据传输也越快。在相对高延迟的广域网中，更需要减少微型报的数目，该算法使得单位时间内发送的报文段数目更少。也就是说，RTT控制着发包速率。</p>
<h3 id="延时ack与nagle算法结合">延时ACK与Nagle算法结合</h3>
<p>  若将延时ACK与Nagle算法直接结合使用，得到的效果可能不尽如人意。 考虑如下情形，客户端使用延时ACK方法发送一个对服务器的请求，而服务器端的响应数据并不适合在同一个包中传输<br>
  在接收到来自服 务器端的包以后，客户端并不立即 发送ACK,而是处于等待状态，希望有 数据一同捎带发送。通常情况下，TCP 在接收到数据包后就应返回 一个ACK,但这里并非如此。在服务器端，由于使用了 Nagle算法，直到收到ACK前都不能发送新数据新数据，因为任一时刻只允许至多一个包在传。因此延时 ACK与Nagle算法的结合导致了某种程度的死锁（两端互相等待对方做出行动。幸运的是，这种死锁并不是永久的，在延时ACK计时器超时后死锁会解除。客户 端即使仍然没有要发送的数据也无需再等待，而可以只发送ACK给服务器。然而，在死锁 期间整个传输连接处于空闲状态，使性能变差。在某些情况下，如这里的ssh传输，可以禁用Nagle算法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[桶排序]]></title>
        <id>https://lixin-scut.github.io//post/tong-pai-xu</id>
        <link href="https://lixin-scut.github.io//post/tong-pai-xu">
        </link>
        <updated>2020-03-05T02:27:20.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://lixin-scut.github.io/post/san-chong-xian-xing-pai-xu-suan-fa-ji-shu-pai-xu-tong-pai-xu-yu-ji-shu-pai-xu/">三种线性排序算法 计数排序、桶排序与基数排序</a><br>
之前我已经总结过一次了，所以这次直接以例题为例子引出代码吧<br>
<a href="https://lixin-scut.github.io/post/shu-zu-164-zui-da-jian-ju/">数组 164. 最大间距</a></p>
<p>首先定义桶，桶为一个数据容器，每个桶存储一个区间内的数。依然有一个待排序的整数序列A，元素的最小值不小于0，最大值不超过K。假设我们有M个桶，第i个桶Bucket[i]存储i*K/M至(i+1)K/M之间的数，<br>
扫描序列A，根据每个元素的值所属的区间，放入指定的桶中(顺序放置)。<br>
对每个桶中的元素进行排序，什么排序算法都可以，例如快速排序。<br>
依次收集每个桶中的元素，顺序放置到输出序列中。<br>
对该算法简单分析，如果数据是期望平均分布的，则每个桶中的元素平均个数为N/M。如果对每个桶中的元素排序使用的算法是快速排序，每次排序的时间复杂度为O(N/Mlog(N/M))。则总的时间复杂度为O(N)+O(M)O(N/Mlog(N/M)) = O(N+ Nlog(N/M)) = O(N + NlogN - NlogM)。当M接近于N是，桶排序的时间复杂度就可以近似认为是O(N)的。就是桶越多，时间效率就越高，而桶越多，空间却就越大，由此可见时间和空间是一个矛盾的两个方面。<br>
桶中元素的顺序放入和顺序取出是有必要的，因为这样可以确定桶排序是一种稳定排序算法</p>
<p>相关题目</p>
<blockquote>
<p>给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。<br>
如果数组元素个数小于 2，则返回 0。<br>
示例 1:<br>
输入: [3,6,9,1]<br>
输出: 3<br>
解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。<br>
示例 2:<br>
输入: [10]<br>
输出: 0<br>
解释: 数组元素个数小于 2，因此返回 0。<br>
说明:<br>
你可以假设数组中所有元素都是非负整数，且数值在 32 位有符号整数范围内。<br>
请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。</p>
</blockquote>
<p>实现：</p>
<pre><code>class Solution {
public:
    int maximumGap(vector&lt;int&gt;&amp; nums) {
        int length = nums.size();
        if(length &lt; 2)
            return 0;
        
        int maxNum,minNum;
        maxNum = INT_MIN;
        minNum = INT_MAX;
        for(auto i : nums)
        {
            maxNum = maxNum &gt; i ? maxNum : i;
            minNum = minNum &lt; i ? minNum : i;
        }
        
        if(maxNum - minNum == 0)
        { return 0; }
        
        int bucketStep = (maxNum - minNum) / (length - 1);
        if(bucketStep == 0)
        { bucketStep = 1; }
        int bucketSize = (maxNum - minNum) / bucketStep + 1;
        vector&lt;vector&lt;int&gt;&gt; buckets(bucketSize, vector&lt;int&gt;(2));
        vector&lt;bool&gt; usedBuckets(bucketSize, false);
        
        for(auto num : nums)
        {
            int loc = (num - minNum) / bucketStep;
            if(!usedBuckets[loc])
            {
                usedBuckets[loc] = true;
                buckets[loc][0] = num;
                buckets[loc][1] = num;
            }
            else
            {
                buckets[loc][0] = buckets[loc][0] &lt; num ? buckets[loc][0] : num;
                buckets[loc][1] = buckets[loc][1] &gt; num ? buckets[loc][1] : num;
            }
        }
        int maxTemp,minTemp,res;
        maxTemp = buckets[0][1];
        minTemp = buckets[0][0];
        res = INT_MIN;
        for(int loc = 1; loc &lt; bucketSize; ++loc)
        {
            if(usedBuckets[loc])
            {
                minTemp = buckets[loc][0];
                res = res &gt; (minTemp - maxTemp) ? res : (minTemp - maxTemp);
                maxTemp = buckets[loc][1];
            }
        }
        return res;
    }
}
</code></pre>
<p>实现过程中需要注意的点</p>
<ol>
<li>数组最大值和最小值可以在一个循环内同时求出，不必要分开。</li>
<li>要判断最大值与最小值是否相等</li>
<li>由于重复元素的存在，可能会因为元素的个数大于元素的间隔，导致bucketStep等于0，此时必须加上判断并将bucketStep置为1，否则bucketSize得不到正确的结果。</li>
<li>计算位置loc时不要忘了减去minNum，亦即<code>int loc = (num - minNum) / bucketStep;</code></li>
<li>最后遍历寻找最大间距时，可以先把临时值初始化为bucket[0]的值，由于桶排序的特性，bucket[0]不可能为空。</li>
<li>一定要注意每个对象的初始值，哪些是INT_MIN，哪些是INT_MAX</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 题46:把数字翻译成字符串]]></title>
        <id>https://lixin-scut.github.io//post/zi-fu-chuan-ti-46ba-shu-zi-fan-yi-cheng-zi-fu-chuan</id>
        <link href="https://lixin-scut.github.io//post/zi-fu-chuan-ti-46ba-shu-zi-fan-yi-cheng-zi-fu-chuan">
        </link>
        <updated>2020-03-05T00:35:15.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>给定一个数字，我们按照如下规则把它翻译为字符串：0翻译成&quot;a&quot;，1翻译成&quot;b&quot;，……，11翻译成&quot;l&quot;，……，25翻译成&quot;z&quot;。一个数字可能有多个翻译。例如12258有5种不同的翻译，它们是&quot;bccfi&quot;、&quot;bwfi&quot;、&quot;bczi&quot;、&quot;mcfi&quot;和&quot;mzi&quot;。请编程实现一个函数用来计算一个数字有多少种不同的翻译方法。</p>
</blockquote>
<p>书本题解：<br>
  当最开始的一个或者两个数字被翻译成一个字符之后，我们接着翻译后而剩下的数字。显然，我们可以写一个递归函数来计算翻译的数目。<br>
  我们定义函数f(i)表小从第i位数字开始的不同翻译的数目，那么f(i)=f(i+1)+g(i,i+1)xf(i+2)。当第i位和第i+1位两位数字拼接起来的数字在 10〜25的范围内时，函数g(i,i+1)的值为1；否则为0。<br>
  尽管我们用递归的思路来分析这个问题，但由于存在重复的子问题， 递归并不是解决这个问题的最佳方法。还是以12258为例。如前所述，翻译12258可以分解成两个子问题：翻译1和2258,以及翻译12和258。接 下来我们翻译第一个子问题中剩下的2258,同样也可以分解成两个自问题： 翻译2和258,以及翻译22和58。注意到子问题翻译258重复出现了。<br>
  递归从最大的问题开始自上而下解决问题。我们也可以从最小的子问题开始自下而上解决问题，这样就可以消除重复的子问题。也就是说，我 们从数字的末尾开始，然后从右到左翻译并计算不同翻译的数目。</p>
<pre><code>int GetTranslationCount(int number)
{
    if(number &lt; 0)
        return 0;

    string numberInString = to_string(number);
    return GetTranslationCount(numberInString);
}

int GetTranslationCount(const string&amp; number)
{
    int length = number.length();
    int* counts = new int[length];
    int count = 0;

    for(int i = length - 1; i &gt;= 0; --i)
    {
        count = 0;
         if(i &lt; length - 1)
               count = counts[i + 1];
         else
               count = 1;

        if(i &lt; length - 1)
        {
            int digit1 = number[i] - '0';
            int digit2 = number[i + 1] - '0';
            int converted = digit1 * 10 + digit2;
            if(converted &gt;= 10 &amp;&amp; converted &lt;= 25)
            {
                if(i &lt; length - 2)
                    count += counts[i + 2];
                else
                    count += 1;
            }
        }

        counts[i] = count;
    }

    count = counts[0];
    delete[] counts;

    return count;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math 题44:数字序列中某一位的数字]]></title>
        <id>https://lixin-scut.github.io//post/math-ti-44shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi</id>
        <link href="https://lixin-scut.github.io//post/math-ti-44shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi">
        </link>
        <updated>2020-03-05T00:23:47.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从0开始计数）是5，第13位是1，第19位是4，等等。请写一个函数求任意位对应的数字。</p>
</blockquote>
<p>书本题解：<br>
序列的第1001位是什么？<br>
序列的前10位是0〜9这10个只有一位的数字。显然第1001位在这 10个数字之后，因此这10个数字可以直接跳过。我们再从后面紧跟着的序列中找第991 (991=1001-10)位的数字。<br>
接下来180位数字是90个10-99的两位数。由于991&gt;180,所以第 991位在所有的两位数之后。我们再跳过90个两位数，继续从后面找881 (881=991-180)位。<br>
接下来的2700位是900个100-999的三位数。由于811&lt;2700,所以 第811位是某个三位数中的一位。由于811=270x3+1,这意味着第811位是 从100开始的第270个数字即370的中间一位，也就是7。</p>
<pre><code>int digitAtIndex(int index)
{
	if(index &lt; 0)
		return -1;

	int digits = 1;
	while(true)
	{
		int numbers = countOfIntegers(digits);
		if(index &lt; numbers * digits)
			return digitAtIndex(index, digits);

		index -= digits * numbers;
		digits++;
	}

	return -1;
}

int countOfIntegers(int digits)
{
	if(digits == 1)
		return 10;

	int count = (int) std::pow(10, digits - 1);
	return 9 * count;
}

int digitAtIndex(int index, int digits)
{
	int number = beginNumber(digits) + index / digits;
	int indexFromRight = digits - index % digits;
	for(int i = 1; i &lt; indexFromRight; ++i)
		number /= 10;
	return number % 10;
}

int beginNumber(int digits)
{
	if(digits == 1)
		return 0;

	return (int) std::pow(10, digits - 1);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math 题17:打印1到最大的n位数]]></title>
        <id>https://lixin-scut.github.io//post/math-ti-17da-yin-1-dao-zui-da-de-n-wei-shu</id>
        <link href="https://lixin-scut.github.io//post/math-ti-17da-yin-1-dao-zui-da-de-n-wei-shu">
        </link>
        <updated>2020-03-05T00:12:17.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>输入数字n，按顺序打印出从1最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数即999。</p>
</blockquote>
<p>书本题解：</p>
<blockquote>
<p>  如果面试题是关于n位的整数并且没有限定n的取值范围，或者输入任意大小的整数，那么这道题目很有可能是需要考虑大数问题的 字符串 是一种简单、有效地表示大数的方法<br>
  如果我们在数字前面补0,就会发现n位所有十进制数其实就是n个从0到9 的全排列。也就是说，我们把数字的每一位都从0到9排列一遍，就得到 了所有的十进制数。只是在打印的时候，排在前面的。不打印出来罢了。<br>
  全排列用递归很容易表达，数字的每一位都可能是0〜9中的一个数， 然后设置下一位。递归结束的条件是我们已经设置了数字的最后一位。<br>
  定义了函数PrintNumbur,在这个函数里，只有在碰到第一个非0的字符之后才开始打印，直至字符串的结尾。</p>
</blockquote>
<pre><code>void Print1ToMaxOfNDigits_2(int n)
{
    if (n &lt;= 0)
        return;

    char* number = new char[n + 1];
    number[n] = '\0';

    for (int i = 0; i &lt; 10; ++i)
    {
        number[0] = i + '0';
        Print1ToMaxOfNDigitsRecursively(number, n, 0);
    }

    delete[] number;
}

void Print1ToMaxOfNDigitsRecursively(char* number, int length, int index)
{
    if (index == length - 1)
    {
        PrintNumber(number);
        return;
    }

    for (int i = 0; i &lt; 10; ++i)
    {
        number[index + 1] = i + '0';
        Print1ToMaxOfNDigitsRecursively(number, length, index + 1);
    }
}

// 字符串number表示一个数字，数字有若干个0开头
// 打印出这个数字，并忽略开头的0
void PrintNumber(char* number)
{
    bool isBeginning0 = true;
    int nLength = strlen(number);

    for (int i = 0; i &lt; nLength; ++i)
    {
        if (isBeginning0 &amp;&amp; number[i] != '0')
            isBeginning0 = false;

        if (!isBeginning0)
        {
            printf(&quot;%c&quot;, number[i]);
        }
    }

    printf(&quot;\t&quot;);
}
</code></pre>
]]></content>
    </entry>
</feed>