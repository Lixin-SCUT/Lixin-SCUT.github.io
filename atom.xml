<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-04-06T09:24:09.762Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>千里之行，始于足下。不积跬步，无以至千里。</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[回溯法 51. N皇后（全排列）[困难]]]></title>
        <id>https://lixin-scut.github.io//post/hui-su-fa-51-n-huang-hou-quan-pai-lie-kun-nan</id>
        <link href="https://lixin-scut.github.io//post/hui-su-fa-51-n-huang-hou-quan-pai-lie-kun-nan">
        </link>
        <updated>2020-04-06T08:59:26.000Z</updated>
        <content type="html"><![CDATA[<p>题目</p>
<blockquote>
<p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。<br>
给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。<br>
每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。<br>
示例:<br>
输入: 4<br>
输出: [<br>
[&quot;.Q..&quot;,  // 解法 1<br>
&quot;...Q&quot;,<br>
&quot;Q...&quot;,<br>
&quot;..Q.&quot;],<br>
[&quot;..Q.&quot;,  // 解法 2<br>
&quot;Q...&quot;,<br>
&quot;...Q&quot;,<br>
&quot;.Q..&quot;]<br>
]<br>
解释: 4 皇后问题存在两个不同的解法。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/n-queens<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>解题思考：<br>
这道题其实在剑指offer里面出现过<br>
需要把题目的本质抽象出来：全排列问题<br>
建立一个数组，将其下标视为棋盘的行，将下标对应的元素视为棋盘的列<br>
判断条件：当两个棋在同一个对角线上时，一定会有 x2 - x1 = y2 - y1;或者x2 - x1 = -（y2 - y1）; (亦即判断两者的斜率是否等于1或者 -1)</p>
<p>然后因为复杂度有点高，我突然在想可不可以用动态规划hhh</p>
<p>实现注意：</p>
<ol>
<li>我一开始老是想着在递归的过程中（也就是非叶子结点）来处理已有的序列，导致了check的位置很尴尬（因为也要考虑当前序列），最后发现还是不如直接在叶子节点进行处理</li>
<li>回溯法一定要记得状态恢复，同时因为使用了状态恢复，可以传引用调用，以免内存消耗过高（从98M降低到8M）</li>
</ol>
<pre><code>class Solution {
public:
    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) {
        if(n &lt;= 0)
        {   return vector&lt;vector&lt;string&gt;&gt;{}; }
        if(n == 1)
        {   return vector&lt;vector&lt;string&gt;&gt;{{&quot;Q&quot;}}; }
        
        vector&lt;int&gt; queensLocate(n);
        for(int i = 0; i &lt; n; ++i)
        {
            queensLocate[i] = i;
        }
        
        int counts = 0;
        vector&lt;vector&lt;string&gt;&gt; res;
        solveNQueens(queensLocate, 0, res);
        
        return res;
    }
    
    // 注意此处使用了DFS+回溯法进行状态还原，所以完全queensLocate可以使用传引用
    void solveNQueens(vector&lt;int&gt;&amp; queensLocate, int level, vector&lt;vector&lt;string&gt;&gt;&amp; res)
    {
        int length = queensLocate.size();
        
        // 一开始我钻了牛角尖，其实完全可以使用DFS，每个数字和自身交换一次，等到叶子结点再进行checkLocate
        if(level &gt;= length)
        {     
            if(checkLocate(queensLocate))
                {
                string strTemp(length, '.'); // 记得是char
                vector&lt;string&gt; resTemp(length, strTemp);
                for(int i = 0; i &lt; length; ++i)
                {
                    resTemp[i][queensLocate[i]] = 'Q'; // 记得是char
                }
                res.push_back(resTemp);
            }
            return;
        }
        
        for(int i = level ; i &lt; length; ++i) // 注意int i = level，先和自身交换一次
        {
            swap(queensLocate[level],queensLocate[i]);
            solveNQueens(queensLocate, level + 1, res); // 思考level的变化
						// 此处其实可以检查 0 - level 的值是否符合要求，进行剪枝。
            swap(queensLocate[level],queensLocate[i]); // 状态还原很重要
        }
        
    }
    
    bool checkLocate(vector&lt;int&gt;&amp; queensLocate)
    {
        for(int i = 0; i &lt; queensLocate.size(); ++i)
        {
            for(int j = i + 1; j &lt; queensLocate.size(); ++j)
            {
                if(i - j == queensLocate[i] - queensLocate[j] || - i + j == queensLocate[i] - queensLocate[j]) // 注意是并的关系 ||
                {
                    return false;
                }
            }
        }
        return true;
    }
};
</code></pre>
<p><a href="https://leetcode-cn.com/problems/n-queens/solution/hui-su-suan-fa-xiang-jie-by-labuladong/">网友题解</a><br>
网友题解有很多图，我就不强行转过来了<br>
注意我们的核心思想一致，都是转化为全排列问题，但是实现细节不一致<br>
我使用的方法是实现确定好位置，然后不断地交换他们的位置，注意我没有进行剪枝的（其实可以判断0- level 的节点是否已经冲突，已经冲突的话就剪枝）<br>
然后网友题解和我以前做全排列的方法比较像，也就是视为一棵树不断地进行选择，并记录哪些元素已经被选择过了，因此可以进行剪枝，并且把剪枝操作和最终判断合为一起（如果达到长度后直接push_back）。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[extern C ]]></title>
        <id>https://lixin-scut.github.io//post/extern-c</id>
        <link href="https://lixin-scut.github.io//post/extern-c">
        </link>
        <updated>2020-04-05T09:18:32.000Z</updated>
        <content type="html"><![CDATA[<h3 id="链接指示externc">链接指示：extern&quot;C&quot;</h3>
<p>  C++使用链接指示（linkage directive)指出任意非C++函数所用的语言。<br>
  要想把C++代码和其他语言（包括C语言）编写的代码放在一起使用，要求我们必须有权访问该语言的编译器，并且这个编译器与当前的C++编译器是兼容的</p>
<h3 id="声明一个非c的函数">声明一个非C++的函数</h3>
<p>  链接指示可以有两种形式：单个的或复合的。链接指示不能出现在类定义或函数定义的内部。同样的链接指示必须在函数的每个声明中都出现。<br>
  链接指示的第一种形式包含一个关键字extern.后面是一个字符串字面值常量以及一个 &quot;普通的&quot;函数声明。<br>
  其中的字符串字面值常量指出了编写函数所用的语言。编译器应该支持对C语言的链 接指示。此外，编译器也可能会支持其他语言的链接指示，如extern&quot;Ada&quot;、extern &quot;FORTRAN&quot;等。</p>
<h3 id="链接指示与头文件">链接指示与头文件</h3>
<p>  我们可以令链接指示后面跟上花括号括起来的若干函数的声明，从而一次性建立多个 链接。花括号的作用是将适用于该链接指示的多个声明聚合在一起，否则花括号就会被忽 略，花括号中声明的函数名字就是可见的，就好像在花括号之外声明的一样。<br>
<img src="https://lixin-scut.github.io//post-images/1586079345046.png" alt=""><br>
  当一个#include指示被放置在复合链接指示的花括号中时，头文件中的所有普通函数声明都被认为是由链接指示的语言编写的。链接指示可以嵌套，因此如果头文件包含带自带链接指示的函数，则该函数的链接不受影响。<br>
  C++从C语言继承的标准库函数可定义成C函数，但并非必须：决定使用还是C++实现C标准库，是毎个C++实现的事情。</p>
<h3 id="指向externc函数的指针">指向extern&quot;C&quot;函数的指针</h3>
<p>  编写函数所用的语言是函数类型的一部分。因此，对于使用链接指示定义的函数来说，它的每个声明都必须使用相同的链接指示。而且，指向其他语言编写的函数的指针必须与函数本身使用相同的链接指示：</p>
<pre><code>//pf指向一个C函数，该函数接受一个int返回void 
extern&quot;C&quot;void(*pf)(int); 
</code></pre>
<p>  当我们使用pf调用函数时，编详器认定当前调用的是一个c函数。<br>
  <strong>指向C函数的指针与指向C++函数的指针是不一样的类型</strong>。一个指向C函数的指针不能用在执行初始化或赋值操作后指向C++函数，反之亦然。就像其他类型不匹配的问题一样，如果我们试图在两个链接指示不同的指针之间进行赋值操作，则程序将发生错误：</p>
<h3 id="链接指示对整个声明都有效">链接指示对整个声明都有效</h3>
<p>  当我们使用链接指示时，它不仅对函数有效，而且<strong>对作为返回类型或形参类型的函数指针也有效</strong>：<br>
<img src="https://lixin-scut.github.io//post-images/1586079363829.png" alt=""><br>
  因为链接指示同时作用于声明语句中的所有函数，所以如果我们希望给C++函数传入 一个指向C函数的指针，则<strong>必须使用类型别名</strong></p>
<h3 id="导出c函数到其他语言">导出C++函数到其他语言</h3>
<p>  通过使用链接指示对函数进行<strong>定义</strong>，我们可以令一个C++函数在其他语言编写的程序 中可用：</p>
<pre><code>//calc函数可以被C程序调用 
extern &quot;C&quot; double calc(double dparm){/*...*/} 
</code></pre>
<p>  编译器将为该函数生成适合于指定语言的代码。<br>
  值得注意的是，可被多种语言共享的函数的返回类型或形参类型受到很多限制。<br>
<img src="https://lixin-scut.github.io//post-images/1586079379457.png" alt=""></p>
<h3 id="重载函数与链接指示">重载函数与链接指示</h3>
<p>  链接指示与重载函数的相互作用依赖于目标语言。如果目标语言支持重载函数，则为 该语言实现链接指示的编译很可能也支持重载这些C++的函数。<br>
  C语言不支持函数重载，因此也就不难理解为什么一个C链接指示只能用于说明一组重载函数中的某一个了：<br>
<img src="https://lixin-scut.github.io//post-images/1586079386823.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 64. 最小路径和[中等]]]></title>
        <id>https://lixin-scut.github.io//post/dong-tai-gui-hua-64-zui-xiao-lu-jing-he-zhong-deng</id>
        <link href="https://lixin-scut.github.io//post/dong-tai-gui-hua-64-zui-xiao-lu-jing-he-zhong-deng">
        </link>
        <updated>2020-04-05T05:44:10.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。<br>
说明：每次只能向下或者向右移动一步。<br>
示例:<br>
输入:<br>
[<br>
  [1,3,1],<br>
[1,5,1],<br>
[4,2,1]<br>
]<br>
输出: 7<br>
解释: 因为路径 1→3→1→1→1 的总和最小。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/minimum-path-sum<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>一开始我觉得可以用动态规划，因为限制了只能向下或者向右<br>
亦即 每个点只有两种情况，考虑左边和上边转移到当前节点<br>
然后就是状态转移方程<br>
<code>steps[col][row] = grid[i][j] + min(steps[col - 1][row], steps[col][row + 1])</code></p>
<p>注意判断边界条件</p>
<p>实现过程：</p>
<ol>
<li>用grid直接初始化steps，两者维度一致，可以省略逐个初始化</li>
<li>我使用INT_MAX来赋值边界值，但是始终没法逃避col == 0 &amp;&amp; row == 0的单独判断。</li>
<li>注意好条件运算符中的判断条件的对应关系。</li>
</ol>
<p>题目扩展：不限制向下或向右，怎么设计（我一个考虑是用图的最短路径来做，但是转化为图连通矩阵相对比较麻烦）</p>
<pre><code>class Solution {
public:
    int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        if(grid.empty())
        {   return 0; }
        vector&lt;vector&lt;int&gt;&gt; steps(grid.begin(), grid.end());
        for(int col = 0; col &lt; steps.size(); ++col)
        {
            for(int row = 0; row &lt; steps[0].size(); ++row)
            {
                if(col == 0 &amp;&amp; row == 0)
                {
                    continue;
                }
                
                int up = col &gt; 0 ? steps[col - 1][row] : INT_MAX;
                int left = row &gt; 0 ? steps[col][row - 1] : INT_MAX;
                
                steps[col][row] = grid[col][row] + min(up, left);
            }
        }
        return steps.back().back();
    }
};

/*
一开始我觉得可以用动态规划，因为限制了只能向下或者向右
亦即 每个点只有两种情况，考虑左边和上边转移到当前节点
然后就是状态转移方程
steps[col][row] = grid[i][j] + min(steps[col - 1][row], steps[col][row + 1]) 

注意判断边界条件

扩展：不限制向下或向右，怎么设计
*/
</code></pre>
<p>官方题解</p>
<blockquote></blockquote>
<p>方法 1： 暴力<br>
暴力就是利用递归，对于每个元素我们考虑两条路径，向右走和向下走，在这两条路径中挑选路径权值和较小的一个。<br>
<code>cost(i,j)=grid[i][j]+min(cost(i+1,j),cost(i,j+1))</code></p>
<pre><code>Java
public class Solution {
    public int calculate(int[][] grid, int i, int j) {
        if (i == grid.length || j == grid[0].length) return Integer.MAX_VALUE;
        if (i == grid.length - 1 &amp;&amp; j == grid[0].length - 1) return grid[i][j];
        return grid[i][j] + Math.min(calculate(grid, i + 1, j), calculate(grid, i, j + 1));
    }
    public int minPathSum(int[][] grid) {
        return calculate(grid, 0, 0);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 ：O(2^(m+n) )。每次移动最多可以有两种选择。<br>
空间复杂度 ：O(m+n)。递归的深度是 m+n。</p>
</blockquote>
<blockquote>
<p>方法 2：二维动态规划<br>
算法<br>
我们新建一个额外的 dp 数组，与原矩阵大小相同。在这个矩阵中，dp(i,j) 表示从坐标 (i,j) 到右下角的最小路径权值。我们初始化右下角的 dp 值为对应的原矩阵值，然后去填整个矩阵，对于每个元素考虑移动到右边或者下面，因此获得最小路径和我们有如下递推公式：<code>dp(i,j)=grid(i,j)+min(dp(i+1,j),dp(i,j+1))</code><br>
注意边界情况。下图描述了这个过程：</p>
</blockquote>
<pre><code>Java
public class Solution {
    public int minPathSum(int[][] grid) {
        int[][] dp = new int[grid.length][grid[0].length];
        for (int i = grid.length - 1; i &gt;= 0; i--) {
            for (int j = grid[0].length - 1; j &gt;= 0; j--) {
                if(i == grid.length - 1 &amp;&amp; j != grid[0].length - 1)
                    dp[i][j] = grid[i][j] +  dp[i][j + 1];
                else if(j == grid[0].length - 1 &amp;&amp; i != grid.length - 1)
                    dp[i][j] = grid[i][j] + dp[i + 1][j];
                else if(j != grid[0].length - 1 &amp;&amp; i != grid.length - 1)
                    dp[i][j] = grid[i][j] + Math.min(dp[i + 1][j], dp[i][j + 1]);
                else
                    dp[i][j] = grid[i][j];
            }
        }
        return dp[0][0];
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 ：O(mn)。遍历整个矩阵恰好一次。<br>
空间复杂度 ：O(mn)。额外的一个同大小矩阵。</p>
</blockquote>
<blockquote>
<p>方法 3：一维动态规划<br>
算法<br>
在上个解法中，我们可以用一个一维数组来代替二维数组，dp 数组的大小和行大小相同。这是因为对于某个固定状态，只需要考虑下方和右侧的节点。首先初始化 dp 数组最后一个元素是右下角的元素值，然后我们向左移更新每个 dp(j) 为：dp(j)=grid(i,j)+min(dp(j),dp(j+1))<br>
我们对于每一行都重复这个过程，然后向上一行移动，计算完成后 dp(0) 就是最后的结果。</p>
</blockquote>
<p>Java<br>
public class Solution {<br>
public int minPathSum(int[][] grid) {<br>
int[] dp = new int[grid[0].length];<br>
for (int i = grid.length - 1; i &gt;= 0; i--) {<br>
for (int j = grid[0].length - 1; j &gt;= 0; j--) {<br>
if(i == grid.length - 1 &amp;&amp; j != grid[0].length - 1)<br>
dp[j] = grid[i][j] +  dp[j + 1];<br>
else if(j == grid[0].length - 1 &amp;&amp; i != grid.length - 1)<br>
dp[j] = grid[i][j] + dp[j];<br>
else if(j != grid[0].length - 1 &amp;&amp; i != grid.length - 1)<br>
dp[j] = grid[i][j] + Math.min(dp[j], dp[j + 1]);<br>
else<br>
dp[j] = grid[i][j];<br>
}<br>
}<br>
return dp[0];<br>
}<br>
}</p>
<blockquote>
<p>复杂度分析<br>
时间复杂度 ：O(mn)。遍历整个矩阵恰好一次。<br>
空间复杂度 ：O(n)。额外的一维数组，和一行大小相同。</p>
</blockquote>
<blockquote>
<p>方法 4：动态规划（不需要额外存储空间）<br>
算法<br>
和方法 2 相同，惟一的区别是，不需要用额外的 dp 数组，而是在原数组上存储，这样就不需要额外的存储空间。递推公式如下：<br>
grid(i,j)=grid(i,j)+min(grid(i+1,j),grid(i,j+1))</p>
</blockquote>
<pre><code>Java
public class Solution {
    public int minPathSum(int[][] grid) {
        for (int i = grid.length - 1; i &gt;= 0; i--) {
            for (int j = grid[0].length - 1; j &gt;= 0; j--) {
                if(i == grid.length - 1 &amp;&amp; j != grid[0].length - 1)
                    grid[i][j] = grid[i][j] +  grid[i][j + 1];
                else if(j == grid[0].length - 1 &amp;&amp; i != grid.length - 1)
                    grid[i][j] = grid[i][j] + grid[i + 1][j];
                else if(j != grid[0].length - 1 &amp;&amp; i != grid.length - 1)
                    grid[i][j] = grid[i][j] + Math.min(grid[i + 1][j],grid[i][j + 1]);
            }
        }
        return grid[0][0];
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 ：O(mn)。遍历整个矩阵恰好一次。<br>
空间复杂度 ：O(1)。不需要额外空间。</p>
</blockquote>
<p>官方的空间压缩很值得学习。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[随机概率p转化为等概率]]></title>
        <id>https://lixin-scut.github.io//post/sui-ji-gai-lu-p-zhuan-hua-wei-deng-gai-lu</id>
        <link href="https://lixin-scut.github.io//post/sui-ji-gai-lu-p-zhuan-hua-wei-deng-gai-lu">
        </link>
        <updated>2020-04-05T02:22:55.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>有一个随机数发生器random函数，可以以概率P产生0，概率(1-P)产生1，请问能否利用这个随机数发生器，构造出新的发生器，以1/2的概率产生0和1。</p>
</blockquote>
<p>题解一：<br>
等概率产生0、1，就需要找到两个独立事件，当这两个独立事件发生的概率相同，就得到所求<br>
两次调用该randon函数，如果其概率为P(x)，调用2次<br>
P(1) = p       P(0) = 1-p<br>
P'(1) =p      P'(0) = 1-p<br>
则不同结果的概率如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">情况</th>
<th style="text-align:center">概率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">p*p</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">p*(1-p)</td>
</tr>
<tr>
<td style="text-align:center">01</td>
<td style="text-align:center">(1-p)*p</td>
</tr>
<tr>
<td style="text-align:center">00</td>
<td style="text-align:center">(1-p)*(1-p)</td>
</tr>
</tbody>
</table>
<p>用随机数生成器产生<code>00，01，10，11</code>，各自的概率分别为<code>p*p，p*(1-p)，(1-p)*p，(1-p)*(1-p)</code>可以发现生成01，10的概率相同，因此只保留这两种情况，其他的舍弃，然后将01映射为0，10映射为1，则得到等概率生成器。</p>
<pre><code>int random_equal()  
{  
    int i = random();  
    int j = random();  
    int result;  
  
    while (true)  
    {  
        if (i == 0 &amp;&amp; j == 1)  
        {  
            result = 0;  
            break;  
        }  
        else if (i == 1 &amp;&amp; j == 0)  
        {  
            result = 1;  
            break;  
        }  
        else  
            continue;  
    }  
  
    return result;  
}  
</code></pre>
<p>题解二：<br>
思路是叠加多个原始构造器，通过每次叠加的和与期望值对比，来决定是0和1，具体如下：<br>
迭代N次，则期望<code>E=( (1-p)*1 + p*0) * N</code> 。比较累加N次的和Sum和E，Sum大则返回0，Sum小则返回1。</p>
<p>拓展1：用等概率生成（0,1）的构造器等概率生成（0,1,2,3）。<br>
假设，原始构造器为Rand2()，则Rand2() * 2为（0,2），Rand2()* 2 + Rand2()则可以生成（0,1,2,3）。注意Rand2()* 2 + Rand2()不等于Rand2()* 3，后者等于（0,3），只用了一次构造器。前者由part1:（0,2）和part2:（0,1）构成。最终结果（0,1,2,3）任何一个数字都由part1和part2中唯一的数字相加得到。<br>
用Rand4（等概率生成0,1,2,3）可以进一步生成Rand16。方法为：Rand4()* 4 + Rand4()</p>
<p>拓展2：用等概率生成（0,1）的构造器等概率生成（0,1,2,3，...，N）。<br>
思路同上相似。由（0,1）的构造器可以生成（0，...，2^n ） 的构造器，其中每次构造生成的随机数个数是<code>上一次的平方</code>。只需要构造到保证2^n&gt;N即可。当得到的随机数处于[ N, 2^n ）时，递归生成一次，直到构造数为[0,N)时，退出本次随机数生成。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 子序列最小差]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-zi-xu-lie-zui-xiao-chai</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-zi-xu-lie-zui-xiao-chai">
        </link>
        <updated>2020-04-05T02:14:59.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>将一个数组分成两部分，不要求两部分所包含的元素个数相等，要求使得这两个部分的和的差值最小。比如对于数组{1,0,1,7,2,4}，可以分成{1,0,1,2,4}和{7}，使得这两部分的差值最小。</p>
</blockquote>
<p>思路：<br>
这个问题可以转化为求数组的一个子集，使得这个子集中的元素的和尽可能接近sum/2，其中sum为数组中所有元素的和。这样转换之后这个问题就很类似0-1背包问题了：在n件物品中找到m件物品，他们的可以装入背包中，且总价值最大不过这里不考虑价值，就考虑使得这些元素的和尽量接近sum/2。</p>
<p>下面列状态方程：<br>
<code>dp[i][j]</code>表示前i件物品中，总和最接近j的所有物品的总和，其中包括两种情况：</p>
<ol>
<li>第i件物品没有包括在其中</li>
<li>第i件物品包括在其中<br>
如果第i件物品没有包括在其中，则<code>dp[i][j] = dp[i-1][j]</code><br>
如果第i件物品包括在其中，则<code>dp[i][j] = dp[i-1][j-vec[i]]</code><br>
当然，这里要确保<code>j-vec[i] &gt;= 0</code>。</li>
</ol>
<p>所以状态转移方程为：<br>
<code>dp[i][j] = max(dp[i-1][j],dp[i-1][j-vec[i]]+vec[i]);</code></p>
<pre><code>using namespace std;
//返回两部分的差值
int diff(vector&lt;int&gt;&amp; vec)
{
    int len = vec.size();
 
    int sum = 0;
    for (int i = 0; i &lt; len; ++i) {
        sum += vec[i];
    }
 
    vector&lt;vector&lt;int&gt;&gt; dp;
    for (int i = 0; i &lt;= len; i++) {
        vector&lt;int&gt;tmp;
        for (int j = 0; j &lt;= sum / 2; ++j) {
            tmp.push_back(0);
        }
        dp.push_back(tmp);
    }
    for (int i = 1; i &lt;= len; ++i) {
        for (int j = 1; j &lt;= sum / 2; ++j) {
            if(j&gt;=vec[i-1])dp[i][j] = max(dp[i-1][j],dp[i-1][j-vec[i-1]]+vec[i-1]);
            else dp[i][j] = dp[i - 1][j];
        }
    }
 
    return sum - 2*dp[len][sum / 2];
}
 
int main()
{
    vector&lt;int&gt; vec = { 1,2,3,4,5};
 
    cout &lt;&lt; diff(vec) &lt;&lt; endl;
    system(&quot;pause&quot;);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[公有继承，保护继承，私有继承]]></title>
        <id>https://lixin-scut.github.io//post/gong-you-ji-cheng-bao-hu-ji-cheng-si-you-ji-cheng</id>
        <link href="https://lixin-scut.github.io//post/gong-you-ji-cheng-bao-hu-ji-cheng-si-you-ji-cheng">
        </link>
        <updated>2020-04-04T08:34:07.000Z</updated>
        <content type="html"><![CDATA[<p>总结：</p>
<pre><code>//公有继承                      对象访问    成员访问
public    --&gt;  public              Y         Y
protected --&gt;  protected           N         Y
private   --&gt;  private             N         N
 
//保护继承                      对象访问    成员访问
public    --&gt;  protected           N         Y
protected --&gt;  protected           N         Y
private   --&gt;  protected           N         N
 
//私有继承                      对象访问    成员访问
public    --&gt;  private             N         Y
protected --&gt;  private             N         Y
private   --&gt;  private             N         N
</code></pre>
<h3 id="预备知识">预备知识</h3>
<p>  首先有一个很重要的概念：类和类的用户<br>
  类就不用说了，就是类的本身，类的用户则很广，其中最典型的就是类的对象，对！对象自身也被视为类的用户，而不能被视为类。同时！派生类的派生类也视为用户！（注意不是对象），它也被视为使用派生类的用户。只有接受这一点才能继续下去。<br>
  但是同时也有个例外，友元视为类的成员的一部分，所以友元的访问权限和成员一致（所以友元并非被视为友元）。</p>
<p>  某个类对其继承而来的成员的访问权限受到两个因素影响：一是在基类中该成员的访问说明符，二是在派生类的派生列表中的访问说明符。</p>
<h3 id="类的成员的关键字">类的成员的关键字</h3>
<p>  派生类无法访问基类的私有成员（private）<br>
  派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。和其他使用基类的代码一样.派生类能访问公有成员，而不能访问私有成员。<br>
  不过在某些时候基类中还有这样一种成员，基类希望它的派生类有权访问该成员，同时禁止其他用户访问。我們用受保护的(protected)访问运算符说明这样的成员。<br>
  一个类使用 protected 关键字来声明那些它希望与派生类分享但是不想被其他用户访问使用的成员。 protected 说明符可以看做是 public 和 private 中和后的产物：<br>
•和私有成员类似，受保护的成员对于类的用户来说是不可访问的。（只能通过基类的非私有的成员函数来访问）<br>
•和公有成员类似，受保护的成员对于<strong>派生类的成员和友元</strong>来说是可访问的。<br>
•派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权。</p>
<h3 id="访问控制与继承">访问控制与继承</h3>
<p>  派生访问说明符对于<strong>派生类的成员（及友元）</strong> 能否访问其直接基类的成员没什么影响。<br>
  派生访问说明符的目的是控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限：<br>
  如果继承是公有的，则成员将遵循其原有的访问说明符，<br>
  派生访问说明符还可以控制继承自派生类的新类的访问权限</p>
<p>  派生类采用受保护继承，则基类的所有公有成员在新定义的类中都是受保护的。</p>
<p>  派生类向基类的转换是否可访问由使用该转换的代码决定，同时派生类的派生访问说明符也会有影响。假定 D 继承自 B :<br>
  •只有当 D 公有地继承 B 时，<strong>用户代码</strong>（对象、用户）才能使用派生类向基类的转换：如果 D 继承 B的方式是受保护的或者私有的，则用户代码不能使用该转换。<br>
  •不论 D以什么方式继承 B ， D 的<strong>成员函数和友元</strong>都能使用派生类向基类的转换：派生类向其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的。<br>
  •如果 D 继承 B 的方式是公有的或者受保护的，则 <strong>继承自D 的派生类</strong>的成员和友元可以使用 D 向 B 的类型转换；反之，如果 D 维承 B 的方式是私有的，则不能使用。<br>
  如果基类的公有成员是可访问的，则派生类向基类的类型转换也是可访问的；反之则不行。</p>
<h3 id="区别">区别</h3>
<p>  公有继承的区别就很明显了<br>
  主要就是保护继承和私有继承的区别<br>
  这两者的区别就在于继续继承下去的时候，私有继承依然保持private，而保护继承则为protected，说明再次派生的派生类的成员可以继续访问，而private已经不能再访问了。</p>
<h3 id="友元">友元</h3>
<p>  就像友元关系不能传递一样（参见7.3.4节，第250页），友元关系同样也不能继承。基类的友元在访问派生类成员时不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员：</p>
<p>  当一个类将另一个类声明为友元时，这种友元关系只对做出声明的类有效。对于原來<br>
  那个类来说，其友元的基类或者派生类不具有特殊的访问能力：<br>
  不能继承友元关系；每个类负责控制各自成员的访问权限<br>
  有时我们需要改变派生类继承的某个名字的访问级别，通过使用 using 声明可以达到这一目的：<br>
  通过在类的内部使用 using 声明语句，我们可以将该类的直接或间接基类中的任何可访问成员（例如，非私有成员）标记出来。</p>
<h3 id="默认派生运算符">默认派生运算符</h3>
<p>  默认派生运算符（例如class derived：private base中的private）也由定义派生类所用的关键字来决定。默认情况下，使用 class 关键字定义的派生类是私有继承的；而使用 struct 关键字定义的派生类是公有继承的：<br>
  在使用 struct 关键字和 class 关键字定义的类之间唯一的差别就是默认成员访问说明符及默认派生访问说明符;<br>
  一个私有派生的类最好显式化将 private 指明出来，:而不要仅仅依赖于默认的设置。显式声明的好处是可以令私有继承关系清晰明了，不至于产生误会。</p>
<h3 id="final">final</h3>
<p>  有时我们会定义这样一种类，我们不希望其他类继承它，或者不想考虑它是否适合作为一个基类。为了实现这一目的， C ++11新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字 final ：<br>
<code>class NoDerived final { /* */} //NoDerive不能作为基类</code></p>
<h3 id="例子">例子</h3>
<p>一个比较有趣的解释例子<br>
<a href="https://www.cnblogs.com/feng-qing-yang/p/5962312.html">C++公有继承，私有继承和保护继承的区别</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++类型兼容性]]></title>
        <id>https://lixin-scut.github.io//post/clei-xing-jian-rong-xing</id>
        <link href="https://lixin-scut.github.io//post/clei-xing-jian-rong-xing">
        </link>
        <updated>2020-04-04T07:04:44.000Z</updated>
        <content type="html"><![CDATA[<p>  类型兼容规则是指在需要基类对象的任何地方，都可以使用公有派生类的对象来替代。通过公有继承，派生类得到了基类中除构造函数、析构函数之外的所有成员。这样，公有派生类实际就具备了基类的所有功能，凡是基类能解决的问题，公有派生类都可以解决。类型兼容规则所指的替代包括以下情况：</p>
<ol>
<li>
<p>派生类对象可以当作父类对象使用</p>
</li>
<li>
<p>派生类对象可以直接赋值给父类对象</p>
</li>
<li>
<p>派生类对象可以直接初始化父类对象</p>
</li>
<li>
<p>派生类对象的地址可以赋给指向基类的指针</p>
</li>
<li>
<p>派生类的对象可以初始化基类的引用</p>
</li>
</ol>
<p>  在替代之后，派生类对象就可以作为基类的对象使用，但是只能使用从基类继承的成员。</p>
<p>类型兼容规则是多态性的重要基础之一。</p>
<p>总结：子类就是特殊的父类 （派生类就是特殊的基类）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 198. 打家劫舍[简单]（不连续的元素最大和）]]></title>
        <id>https://lixin-scut.github.io//post/dong-tai-gui-hua-198-da-jia-jie-she-jian-dan</id>
        <link href="https://lixin-scut.github.io//post/dong-tai-gui-hua-198-da-jia-jie-she-jian-dan">
        </link>
        <updated>2020-04-04T04:35:51.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>
给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。<br>
示例 1:<br>
输入: [1,2,3,1]<br>
输出: 4<br>
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>
     偷窃到的最高金额 = 1 + 3 = 4 。<br>
示例 2:<br>
输入: [2,7,9,3,1]<br>
输出: 12<br>
解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。<br>
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/house-robber<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这个就是比较明显的一维动态规划了，和股票题比较像，<br>
状态主要有两种，1代表选择偷窃，0选择不偷窃<br>
然后状态转移<br>
如果选择偷窃，只能从前一天的不偷中累加<br>
如果选择不偷窃，则可以选择前一天的偷和不偷的最大值。</p>
<p>当然最后，最重要的还是题目的转化，这道题其实等同于 数组中不连续的元素的最大和，而不是题目中的故事，这种思维的转化值得学习</p>
<p>实现注意点</p>
<ol>
<li>为了压缩容器的维数，我使用了pair的vector，利用first代替不偷窃，second代替偷窃。</li>
<li>关于初始化，我选择的方法是初始化第一个元素，实际上也可以考虑把sums的纬度设为nums.size()+1，设置一个0号房屋，可以避开初始化。</li>
</ol>
<pre><code>class Solution {
public:
    int rob(vector&lt;int&gt;&amp; nums) {
        if(nums.empty())
        {   return 0; }
        vector&lt;pair&lt;int, int&gt;&gt; sums(nums.size(),make_pair(0,0));
        sums[0].second = nums[0];
        for(int i = 1; i &lt; nums.size(); ++i)
        {
            sums[i].first = max(sums[i - 1].first, sums[i - 1].second);
            sums[i].second = sums[i - 1].first + nums[i];
        }
        return max(sums.back().first, sums.back().second);
    }
};
</code></pre>
<p>这道题还是比较明显的，网友的题解一致<br>
网友题解：</p>
<blockquote>
<p>思路<br>
标签：动态规划</p>
<ol>
<li>动态规划方程：dp[n] = MAX( dp[n-1], dp[n-2] + num )</li>
<li>由于不可以在相邻的房屋闯入，所以在当前位置 n 房屋可盗窃的最大值，要么就是 n-1 房屋可盗窃的最大值，要么就是 n-2 房屋可盗窃的最大值加上当前房屋的值，二者之间取最大值</li>
<li>举例来说：1 号房间可盗窃最大值为 3 即为 dp[1]=3，2 号房间可盗窃最大值为 4 即为 dp[2]=4，3 号房间自身的值为 2 即为 num=2，那么 dp[3] = MAX( dp[2], dp[1] + num ) = MAX(4, 3+2) = 5，3 号房间可盗窃最大值为 5时间复杂度：O(n)，n 为数组长度</li>
</ol>
</blockquote>
<pre><code>class Solution {
    public int rob(int[] nums) {
        int len = nums.length;
        if(len == 0)
            return 0;
        int[] dp = new int[len + 1];
        dp[0] = 0;
        dp[1] = nums[0];
        for(int i = 2; i &lt;= len; i++) {
            dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i-1]);
        }
        return dp[len];
    }
}
作者：guanpengchn
链接：https://leetcode-cn.com/problems/house-robber/solution/hua-jie-suan-fa-198-da-jia-jie-she-by-guanpengchn/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图的最短路径]]></title>
        <id>https://lixin-scut.github.io//post/tu-de-zui-duan-lu-jing</id>
        <link href="https://lixin-scut.github.io//post/tu-de-zui-duan-lu-jing">
        </link>
        <updated>2020-04-03T09:13:14.000Z</updated>
        <content type="html"><![CDATA[<p>求图的最短路径主要有两种方法：迪杰斯特拉（Dijkstra)算法 和 弗洛伊德（Floyd）算法</p>
<h3 id="最短路径">最短路径</h3>
<p>对于网图来说，最短路径，是指两顶点之间经过的边上<strong>权值之和最少</strong>的路径，并且我们称路径上的第—个顶点是源点，最后一个顶点是终点。</p>
<h3 id="迪杰斯特拉dijkstra算法">迪杰斯特拉（Dijkstra)算法</h3>
<p>按路径长度递增的次序产生最短路径的算法<br>
迪杰斯特拉（Dijkstra)算法：并不是一下子就求出了最短路径，而是一步步求出它们之间顶点的最短路径，过程中都 是基于已经求出的最短路径的基础上，求得更远顶点的最短路径，最终得到你要的结果。<br>
邻接矩阵MGraph：</p>
<pre><code>#define MAXVEX 9
#define INFINITY 65535
typedef int Pathmatirx[MAXVEX]; // 用于存储最短路径下标的数组
typedef int ShortPathTable[MAXVEX]; // 用于存储到各点最短路径的权值和
// Dijkstra算法 ， 求有向网G的V0顶点到其余顶点V最短路径P[v]及带权长度D[v]
// P[V]的值为前驱顶点下标，D[V]表示V0到V的最短路径长度和。

void ShortestPath_Dijkstra(MGraph G, 
                                            int v0, 
																						PathMatirx *P, 
																						ShortPathTable *D)
{
	int v, w, k, min;
	int final[MAXVEX]; // final[w] = 1 表示求得顶点V0到Vw的最短路径
	for(v = 0; v &lt; G.numVertexex; ++v)  // 初始化数据
	{
		final[v] = 0; // 全部顶点初始化为未知最短路径状态
		(*D)[v] = G.matirx[v0][v]; // 将与V0点有连线的顶点机上权值
		(*P)[v] = 0; // 初始化路径数组P为0
	}
	(*D)[v0] = 0; // V0到V0路径为0
	final[v0] = 1; // V0到V0不需要求路径
	// 开始主循环，每次求得V0到某个v顶点的最短路径
	for( v = 1; v &lt; G.numVertexex; ++v)
	{
		min = INFINITY; // 当前所知离V0顶点的最近距离
		for(w = 0; w &lt; G.numVertexex; ++w) // 寻找离V0最近的顶点
		{
			if(!final[w] &amp;&amp; (*D)[w] &lt; min)
			{
				k = w;
				min = (*D)[w]; // w顶点离V0顶点更近
			}
		}
		final[k] = 1; // 将目前找到的最近的顶点置为1
		for(w = 0; w &lt; G.numVertexex; ++w) // 修正当前最短路径及距离
		{
			// 如果经过V顶点的路径比现在这条路径的长度短的话
			if(!final[w] &amp;&amp; (min + G.matirx[k][w] &lt; (*D)[w]))
			{ // 说明找到了更短的路径，修改D[w] 和 P[w]
				(*D)[w] = min + G.matirx[k][w]; // 修改当前路径changed
				(*P)[w] = k; // 前驱顶点下标
			}
		}
	}
}
</code></pre>
<p><img src="https://lixin-scut.github.io//post-images/1585921461798.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1585921481678.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1585921500561.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1585921522817.png" alt=""><br>
通过迪杰斯特拉（Dijkstra)算法解决了从某个源点到其余各顶点的最 短路径问题。从循环嵌套可以很容易得到此算法的时间复杂度为O(n^2)<br>
可不可以只找到从源点到某一个特定终点的最短路径，其实这个问题和求源点到其他所有 顶点的最短路径一样复杂，时间复杂度依然是O(n^2)（要考虑整体）<br>
任一顶点到其余所有顶点的最短路径：对每个顶点当作源点运行一次迪杰斯特拉(Dijkstra)算法，等于在 原有算法的基础上，再来一次循环，此时整个算法的时间复杂度就成了O(n^3)</p>
<h3 id="弗洛伊德floyd算法">弗洛伊德（Floyd）算法</h3>
<p><img src="https://lixin-scut.github.io//post-images/1585921596616.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1585921624861.png" alt=""></p>
<pre><code>typedef int Pathmatirx[MAXVEX][MAXVEX]; 
typedef int ShortPathTable[MAXVEX][MAXVEX];
// Floyd算法，求网图G中各顶点V到其余顶点w最短路径P[v][w]及带权长度D[v][w]

void ShortestPath_Floyd(MGraph G, PathMatirx *P, ShortPathTable *D)
{
	int v, w, k;
	for(v = 0; v &lt; G.numVertexes; ++v) // 初始化D与P
	{
			for(w = 0; w &lt; G.numVertexes; ++w)
			{
				(*D)[v][w] = G.matirx[v][w]; // D[v][w]值即为对应点间的权值
				(*P)[v][w] = w; // 初始化P
			}
	}
	for(k = 0; k &lt; G.numVertexes; ++k)
	{
		for(v = 0; v &lt; G.numVertexes; ++v)
		{
			for(w = 0; w &lt; G.numVertexes; ++w)
			{
				if((*D)[v][w] &gt; (*D)[v][k] + (*D)[k][w])
				{ 
					// 如果经过下标为k顶点路径比原两点间的路径更短
					// 将当前两点间权值设为更小的一个
					(*D)[v][w] = (*D)[v][k] + (*D)[k][w];
					(*P)[v][w] = (*P)[v][k];
				}
			}
		}
	}
}
</code></pre>
<p><img src="https://lixin-scut.github.io//post-images/1585922753839.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1585922776967.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1585922814727.png" alt=""><br>
弗洛伊德（Floyd）时间复杂度也是O(n^3) 算法非常简洁优雅<br>
由于它的三重循环，因此也是了O(n^3)时间 复杂度。如果你面临需要求所有顶点至所有顶点的最短路径问题时，弗洛伊德（Floyd)算法 应该是不错的选择。<br>
对求最短路径的两个算法举例都是无向图，但它们对有向图依然有效， 因为二者的差异仅仅是邻接矩阵是否对称而已。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[回溯 679. 24 点游戏[困难][未做出]]]></title>
        <id>https://lixin-scut.github.io//post/hui-su-679-24-dian-you-xi-kun-nan-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/hui-su-679-24-dian-you-xi-kun-nan-wei-zuo-chu">
        </link>
        <updated>2020-04-03T02:12:42.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 *，/，+，-，(，) 的运算得到 24。<br>
示例 1:<br>
输入: [4, 1, 8, 7]<br>
输出: True<br>
解释: (8-4) * (7-1) = 24<br>
示例 2:<br>
输入: [1, 2, 1, 2]<br>
输出: False<br>
注意:<br>
除法运算符 / 表示实数除法，而不是整数除法。例如 4 / (1 - 2/3) = 12 。<br>
每个运算符对两个数进行运算。特别是我们不能用 - 作为一元运算符。例如，[1, 1, 1, 1] 作为输入时，表达式 -1 - 1 - 1 - 1 是不允许的。<br>
你不能将数字连接在一起。例如，输入为 [1, 2, 1, 2] 时，不能写成 12 + 12 。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/24-game<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>从注意事项中得出的难点：</p>
<ol>
<li>实数除法，这个实在是太棘手了，也就是说不能用整型类型来保存，必须用浮点数。</li>
<li>第一个数前面的符号只能是括号，然后运算符必须在括号之前，防止出现(-1+1)的情况（这里我的理解出现了点偏差，其实不是必须四个数按顺序，可以任意组合顺序）</li>
<li>除第一个数字外，每个数字之前必须插入运算符，且只有一个运算符（不包含括号）</li>
</ol>
<p>解题思路：<br>
1.第一点最棘手的就是括号问题，想到的一个方法就是既然有不确定的括号，那还不如都加上括号，或者都去掉括号。<br>
2.从都加上括号出发，就必须预留足够的空间加上括号（最极端的情况有4个）<br>
3.从都去掉括号出发，直接忽略括号，可以把数字进行组合运算，然后将得到的结果视为一个新数字，比如 4，1，8，7组合为4，6 再组合为24<br>
这样子其实就是暗中消除掉了括号，有点像归并法吧</p>
<p>但是有一个问题，就是一开始我想着是两两组合<br>
但是明显（1 + 2 + 3）* 4的情况是无法两两组合的<br>
还是必须逐个相加<br>
本来想着动态规划保存每个状态，但是很明显状态特别多。。。。以至于可能要构造一个很高维的数组并且进行很深的循环<br>
还是先看一下官方题解吧<br>
官方题解使用的是回溯法，直接对所有情况进行递归遍历<br>
实现中需要注意的点：</p>
<ol>
<li>double不能直接和0比较，只能判断精度</li>
<li>加法和乘法有可交换性，可能会造成重复，可以剪枝</li>
<li>记得一定要回溯消除最后一个元素恢复状态</li>
<li>默认返回false</li>
</ol>
<pre><code>class Solution {
public:
    bool judgePoint24(vector&lt;int&gt;&amp; nums) {
        vector&lt;double&gt; numsD;
        for(int num : nums)
        {
            numsD.push_back(static_cast&lt;double&gt;(num));
        }
        return judgePoint24(numsD);
        
    }
    
    bool judgePoint24(vector&lt;double&gt;&amp; numsD)
    {
        if(0 == numsD.size())
        {   return false; }
        if(1 == numsD.size())
        {   return abs(numsD[0] - 24) &lt; pow(0.1, 6); } // 这里的abs取绝对值不能去掉
        
        for(int i = 0; i &lt; numsD.size(); ++i)
        {
            for(int j = 0; j &lt; numsD.size(); ++j)
            {
                if(i != j)
                {
                    vector&lt;double&gt; numsTemp;
                    for(int k = 0; k &lt; numsD.size(); ++k)
                    {
                        if(k != i &amp;&amp; k != j) // i、j为两个选定进行运算的数字，剩下的加入numsTemp等待下一次运算
                        {
                            numsTemp.push_back(numsD[k]);
                        }
                    }
                    for(int k = 0; k &lt; 4; k++)
                    {
                        if(k &lt; 2 &amp;&amp; j &gt; i) { continue; } // 加法和乘法有可交换性，可能会造成重复，直接剪枝
                        if(0 == k) { numsTemp.push_back(numsD[i] + numsD[j]); }
                        if(1 == k) { numsTemp.push_back(numsD[i] * numsD[j]); }
                        if(2 == k) { numsTemp.push_back(numsD[i] - numsD[j]); }
                        if(3 == k)
                        {
                            if(numsD[j] != 0)
                            {
                                numsTemp.push_back(numsD[i] / numsD[j]);
                            }
                            else
                            {
                                continue;
                            }
                        }
                        if(judgePoint24(numsTemp))
                        {
                            return true;
                        }
                        numsTemp.pop_back(); // 记得一定要回溯消除最后一个元素恢复状态
                    }
                }
            }
        }
        return false; // 默认返回false
    }
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>方法：回溯<br>
思路和算法<br>
只有 4 张牌，且只能执行 4 种操作。即使所有运算符都不进行交换，最多也只有 12∗6∗2∗4∗4∗4=9216 种可能性，这使得我们可以尝试所有这些可能。<br>
具体来说，我们有 12 种方式先选出两个数字（有序），并执行 4 种操作之一（12 * 4）。然后，剩下 3 个数字，我们从中选择 2 个并执行 4 种操作之一（6 * 4）。<br>
最后我们剩下两个数字，并在 2 * 4 种可能之中作出最终选择。<br>
我们将对我们的数字或结果数字执行 3 次二元运算（+，-，*，/ 是运算）。因为 - 和 / 不满足交换律，我们必须仔细考虑 a / b 和 b / a。<br>
对于在我们的列表中移除 a, b 这两个数字的每一种方法，以及它们可能产生的每种结果，如 a + b、a / b等，我们将采用递归的方法解决这个较小的数字列表上的问题。</p>
</blockquote>
<pre><code>class Solution {
    public boolean judgePoint24(int[] nums) {
        ArrayList A = new ArrayList&lt;Double&gt;();
        for (int v: nums) A.add((double) v);
        return solve(A);
    }
    private boolean solve(ArrayList&lt;Double&gt; nums) {
        if (nums.size() == 0) return false;
        if (nums.size() == 1) return Math.abs(nums.get(0) - 24) &lt; 1e-6;

        for (int i = 0; i &lt; nums.size(); i++) {
            for (int j = 0; j &lt; nums.size(); j++) {
                if (i != j) {
                    ArrayList&lt;Double&gt; nums2 = new ArrayList&lt;Double&gt;();
                    for (int k = 0; k &lt; nums.size(); k++) if (k != i &amp;&amp; k != j) {
                        nums2.add(nums.get(k));
                    }
                    for (int k = 0; k &lt; 4; k++) {
                        if (k &lt; 2 &amp;&amp; j &gt; i) continue;
                        if (k == 0) nums2.add(nums.get(i) + nums.get(j));
                        if (k == 1) nums2.add(nums.get(i) * nums.get(j));
                        if (k == 2) nums2.add(nums.get(i) - nums.get(j));
                        if (k == 3) {
                            if (nums.get(j) != 0) {
                                nums2.add(nums.get(i) / nums.get(j));
                            } else {
                                continue;
                            }
                        }
                        if (solve(nums2)) return true;
                        nums2.remove(nums2.size() - 1);
                    }
                }
            }
        }
        return false;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(1)，总计 9216 种可能的硬性限制，对于每种可能，我们执行操作的复杂度为O(1)。<br>
空间复杂度：O(1)，我们的中间数组最多有 4 个元素，所生成的数字由复杂度 O(1) 的因子限定。</p>
</blockquote>
]]></content>
    </entry>
</feed>