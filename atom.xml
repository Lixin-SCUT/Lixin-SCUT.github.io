<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2020-01-01T01:51:48.785Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[Math 231. 2的幂[简单][位运算]]]></title>
        <id>https://lixin-ee.github.io//post/math-231-2-de-mi-jian-dan-wei-yun-suan</id>
        <link href="https://lixin-ee.github.io//post/math-231-2-de-mi-jian-dan-wei-yun-suan">
        </link>
        <updated>2020-01-01T01:44:14.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个整数，编写一个函数来判断它是否是 2 的幂次方。<br>
示例 1:<br>
输入: 1<br>
输出: true<br>
解释: 20 = 1<br>
示例 2:<br>
输入: 16<br>
输出: true<br>
解释: 24 = 16<br>
示例 3:<br>
输入: 218<br>
输出: false<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/power-of-two<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题让我想起了除法 把除数不断递增就好 主要难点就是在于除数和商的控制<br>
突然发现一个问题，如果不是2的幂的话肯定最后会变成奇数<br>
第一版代码里面，n%2、n/2和n<mark>1的位置很重要，一开始我把n/=2;放在了n%2前面，导致3就错误了；<br>
然后希望改进一下看看能不能递增2，判断条件很重要<br>
艹艹艹，忘了位这个东西啦！！！很明显按位处理更方便 只需要判断是否大于0和(n&amp;(n-1))是否</mark>0了<br>
因为如果n是二次幂，一定只有最高位是1，也就是1000...，则n-1是0111...如果不是二次幂，这两者的交集一定不等于0<br>
注意注意！！！！一开始写成了n&amp;(n-1)==0; 注意外括号必不可少，否则就等同于 n &amp; ((n-1)==0) <mark>的优先级可是高于&amp;的 可以类比 n&amp;&amp;n</mark>0</p>
<p>然后就是网友题解：</p>
<blockquote>
<p>解题思路：<br>
若 n = 2^x<br>
且 x 为自然数（即 n 为 2 的幂），则一定满足以下条件：<br>
恒有 n &amp; (n - 1) == 0，这是因为：<br>
n 二进制最高位为 1，其余所有位为 0；<br>
n - 1 二进制最高位为 0，其余所有位为 1；<br>
一定满足 n &gt; 0。<br>
因此，通过 n &gt; 0 且 n &amp; (n - 1) == 0 即可判定是否满足 n = 2^x</p>
</blockquote>
<pre><code>class Solution {
    public boolean isPowerOfTwo(int n) {
        return n &gt; 0 &amp;&amp; (n &amp; (n - 1)) == 0;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[  [Linux基础] 磁盘与文件系统管理（鸟哥Linux第七章）]]></title>
        <id>https://lixin-ee.github.io//post/linux-ji-chu-ci-pan-yu-wen-jian-xi-tong-guan-li-niao-ge-linux-di-qi-zhang</id>
        <link href="https://lixin-ee.github.io//post/linux-ji-chu-ci-pan-yu-wen-jian-xi-tong-guan-li-niao-ge-linux-di-qi-zhang">
        </link>
        <updated>2019-12-31T07:10:40.000Z</updated>
        <content type="html"><![CDATA[<p>这一章概念居多，命令很少用得上（比如查看磁盘和文件系统）<br>
磁盘盘上的物理组成则为<br>
•  扇区(Sector)为最小的物理储存单位，且依据磁盘设计的不同，目前主要有 512bytes 与 4K 两种格式；<br>
•  将扇区组成一个圆，那就是磁柱(Cylinder)；<br>
早期的分区主要以磁柱为最小分区单位，现在的分区通常使用扇区为最小分区单位</p>
<p>/dev/sd[a-p][1-128]：为实体磁盘的磁盘文件名；<br>
/dev/vd[a-d][1-128]：为虚拟磁盘的磁盘文件名；</p>
<ul>
<li>文件系统特性<br>
磁盘分区完毕后还需要进行格式化(format)，之后操作系统才能够使用这个文件系统。为什么需要进行『格式化』呢？这是因为每种操作系统所设定的文件属性/权限并不相同。为了存放这些文件所需的数据，因此就需要将分区槽进行格式化，以成为操作系统能够利用的『文件系统格式(filesystem)』<br>
Linux 的正统文件系统则为 Ext2</li>
</ul>
<p>文件系统通常会将这两部份的数据（文件权限(rwx)与文件属性(拥有者、 群组、时间参数等)）分别存放在不同的区块，权限与属性放置到 inode 中，至于实际数据则放置到 data block 区块中</p>
<p>每个 inode 与 block 都有编号，至于这三个数据的意义可以简略说明如下：</p>
<ul>
<li>superblock：记录此 filesystem 的整体信息，包括 inode/block 的总量、使用量、剩余量， 以及文件系统的 格式与相关信息等；</li>
<li>inode：记录文件的属性，一个文件占用一个 inode，同时记录此文件的数据所在的 block 号码；</li>
</ul>
<p>每个文件都会占用一个 inode ，inode 内则有文件数据放置 的 block 号码。<br>
一个incode可能会拥有（占用）多个block，这种数据存取的方法我们称为索引式文件系统(indexed allocation)</p>
<p>FAT 这种格式的文件系统并没有 inode 存在，每个 block 号码都记录在前一个 block 当中</p>
<p>『碎片整理』： 需要碎片整理的原因就是文件写入的 block 太过于离散了，此 时文件读取的效能将会变的很差所致。 这个时候可以透过碎片整理将同一个文件所属的 blocks 汇整 在一起</p>
<p>inode table (inode 表格)<br>
inode 记录的文件数据至少有底下这些</p>
<ul>
<li>
<p>该文件的存取模式(read/write/excute)；</p>
</li>
<li>
<p>该文件的拥有者与群组(owner/group)；</p>
</li>
<li>
<p>该文件的容量；</p>
</li>
<li>
<p>该文件建立或状态改变的时间(ctime)；</p>
</li>
<li>
<p>最近一次的读取时间(atime)；</p>
</li>
<li>
<p>最近修改的时间(mtime)；</p>
</li>
<li>
<p>定义文件特性的旗标(flag)，如 SetUID...；</p>
</li>
<li>
<p>该文件真正内容的指向 (pointer)；</p>
</li>
<li>
<p>每个 inode 大小均固定为 128 bytes (新的 ext4 与 xfs 可设定到 256 bytes)；</p>
</li>
<li>
<p>每个文件都仅会占用一个 inode 而已；</p>
</li>
<li>
<p>承上，因此文件系统能够建立的文件数量与 inode 的数量有关；</p>
</li>
<li>
<p>系统读取文件时需要先找到 inode，并分析 inode 所记录的权限与用户是否符合，若符合才能够开始实际 读取 block 的内容。</p>
</li>
</ul>
<ul>
<li>与目录树的关系<br>
1.目录<br>
当我们在 Linux 下的文件系统建立一个目录时，<strong>文件系统会分配一个 inode 与至少一块 block 给该目录</strong>。其中，<strong>inode 记录该目录的相关权限与属性</strong>，并可记录分配到的那块 block 号码； 而<strong>block 则是记录在这个目录下的文件名与该文件名占用的 inode 号码数据。</strong><br>
2.文件<br>
当我们在 Linux 下的 ext2 建立一个一般文件时， ext2 会分配一个 inode 与相对于该文件大小的 block 数量给该文件，由于 inode 仅 有 12 个直接指向，因此还要多一个 block 来作为区块号码的记录<br>
3.目录树读取<br>
inode 本身并不记录文件名，文件名的记录是在目 录的 block 当中<br>
因为『新增/删除/更名文件名 与目录的 w 权限有关』，那么因为文件名是记录在目录的 block 当中， 因此当我们要读取 某个文件时，就务必会经过目录的 inode 与 block ，然后才能够找到那个待读取文件的 inode 号码， 最终才会读到正确的文件的 block 内的数据。</li>
</ul>
<p>日志式文件系统：<br>
在 filesystem 当中规划出一个区块，该区块专门在记录写入或修订文件时的步骤</p>
<ol>
<li>预备：当系统要写入一个文件时，会先在日志记录区块中纪录某个文件准备要写入的信息；</li>
<li>实际写入：开始写入文件的权限与数据；开始更新 metadata 的数据；</li>
<li>结束：完成数据与 metadata 的更新后，在日志记录区块当中完成该文件的纪录。</li>
</ol>
<p>数据的不一致 (Inconsistent) 状态：metadata 的内容与实际数据存放区产生不一致 (Inconsistent)</p>
<p>Linux 文件系统的运作：<br>
1.当系统加载一个文件到内存后，如果该文件没有被更动过，则在内存区段的文件数据会被设定为干净 (clean)的。<br>
2.但如果内存中的文件数据被更改过了(例如你用 nano 去编辑过这个文件)，此时该内存中 的数据会被设定为脏的 (Dirty)。此时所有的动作都还在内存中执行，并没有写入到磁盘中<br>
3.系统会 不定时的将内存中设定为『Dirty』的数据写回磁盘，以保持磁盘与内存数据的一致性。<br>
如果能够将常用的文件放置到内存当中，就会增加系 统性能</p>
<ul>
<li>系统会将常用的文件数据放置到主存储器的缓冲区，以加速文件系统的读/写；</li>
<li>承上，因此 Linux 的物理内存最后都会被用光！这是正常的情况！可加速系统效能；</li>
<li>你可以手动使用 sync 来强迫内存中设定为 Dirty 的文件回写到磁盘中；</li>
</ul>
<ul>
<li>
<p>挂载点的意义 (mount point)<br>
将文件系统与目录树结合的动作我们称为『挂载』<br>
<strong>挂载点一定是目录</strong>，该目录为进入该文件系统的入口。 因此并不是你有任 何文件系统都能使用，<strong>必须要『挂载』到目录树的某个目录后，才能够使用该文件系统的。</strong><br>
<strong>同一个 filesystem 的某个 inode 只会对应到一个文件内容</strong>而 已(因为一个文件占用一个 inode 之故)， 因此我们可以透过判断 inode 号码来确认不同文件名是否 为相同的文件</p>
</li>
<li>
<p>文件系统的简单操作</p>
</li>
</ul>
<ul>
<li>
<p>df：列出文件系统的整体磁盘使用量；<br>
-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；<br>
-i ：不用磁盘容量，而以 inode 的数量来显示</p>
<pre><code>  	 **通常 inode 的数量剩余都比 block 还要多**
</code></pre>
</li>
<li>
<p>du：评估文件系统的磁盘使用量(常用在推估目录所占容量)<br>
-s ：列出总量而已，而不列出每个各别的目录占用容量；</p>
</li>
</ul>
<p>直接输入 du 没有加任何选项时，则 du 会分析『目前所在目录』的文件与目录所占用的磁盘空间。但是，实际显示时，仅会显示目录容量(不含文件)，<br>
与 df 不一样的是，du 这个指令其实会直接到文件系统内去搜寻所有的文件数据<br>
如果你只想要知道该目录占了多少容量的话，使用 -s 就可以</p>
<ul>
<li>
<p>实体链接与符号链接： ln（重点）<br>
Linux 底下的连结档有两种，一种是类似 Windows 的<strong>快捷方式功能</strong>的文件，可以让你快速的链 接到目标文件(或目录)； 另一种则是透过文件系统的 inode 连结来产生<strong>新档名</strong>，而<strong>不是产生新文件</strong>！ 这种称为实体链接 (hard link)。</p>
</li>
<li>
<p>Hard Link ( 实体链接, 硬式连结或实际连结)<br>
前提：</p>
</li>
</ul>
<ul>
<li><strong>每个文件都会占用一个 inode</strong> ，文件内容由 inode 的记录来指向；</li>
<li>想要读取该文件，必须要<strong>经过目录记录的文件名来指向到正确的 inode 号码才能读取。</strong></li>
</ul>
<p>hard link ：<strong>多个档名对应到同一个 inode 号码</strong><br>
hard link <strong>只是在某个目录下新增一笔档名链接到某 inode 号码的关连记录而已</strong><br>
硬链接hard link最大的好处就是 『安全』，<strong>如果你将任何一个『档名』删除，其实 inode 与 block 都还是存在的</strong><br>
<strong>使用 hard link 设定链接文件时，磁盘的空间与 inode 的数目都不会改变</strong><br>
hard link 的制作中，<strong>其实还是可能会改变系统的 block 的</strong>，那就是当你<strong>新增这笔数据却刚好将目录的 block 填满时，就可能会新加一个 block 来记录文件名关连性</strong>，而导致磁盘空间的变化！不过， 一般 hard link 所用掉的关连数据量很小，所以<strong>通常不会改变 inode 与磁盘空间的大小</strong><br>
hard link 是有限制的：</p>
<ul>
<li>不能跨 Filesystem；</li>
<li><strong>不能 link 目录</strong>。<br>
<strong>如果使用 hard link 链接到目录时， 链接的数据需要连同被链接目录底下的所有数据都建立链接</strong></li>
</ul>
<ul>
<li>Symbolic Link (符号链接，亦即是快捷方式)<br>
Symbolic link 就是在建立一个<strong>独立的 文件</strong>，而这个文件会让<strong>数据的读取指向他它link 的那个文件的档名</strong>！由于只是利用文件来做为指向的 动作， 所以，当<strong>来源档被删除</strong>之后，<strong>symbolic link</strong> 的文件会『开不了』，<br>
<strong>两个文件指向不同的 inode 号码，当然就是两个独立的文件存在！</strong> 而且 连结档的<strong>重要内容就是他会写上目标文件的『文件名』</strong></li>
</ul>
<p>Symbolic Link 与 Windows 的快捷方式可以给他划上等号，由 Symbolic link 所建立的文件为一个<strong>独立的新的文件</strong>，所以<strong>会占用掉 inode 与 block</strong></p>
<p><strong>个人测试</strong>：Symbolic Link之后删除源文件，会显示No such file 但是！！！！我重建源文件后（用vim重建不同内容的同名文件或者用ln硬链接同名文件），会自动连接上！！！</p>
<p>要制作连结档就必须要使用 ln 这个指令<br>
[root@study ~]# ln [-sf] 来源文件 目标文件<br>
选项与参数：<br>
-s ：如果不加任何参数就进行连结，那就是 hard link，至于 -s 就是 symbolic link<br>
-f ：如果 目标文件 存在时，就主动的将目标文件直接移除后再建立</p>
<p><strong>使用 ln 如果不加任何参数的话，那么就是 Hard Link</strong></p>
<p>关于目录的 link 数量<br>
以 hard link 进行『文件的连结』时，可以发现，在 ls -l 所显 示的第二字段会增加一才对<br>
当我们建立一个新目录名称为 /tmp/testing 时，基本上会有三个东西，那就是：</p>
<ul>
<li>/tmp/testing</li>
<li>/tmp/testing/.</li>
<li>/tmp/testing/..<br>
所以<strong>新的目录的 link 数为 2 ，而上层目录的 link 数则会增加 1</strong></li>
</ul>
<ul>
<li>磁盘的分区、格式化、检验与挂载<br>
想要在系统里面新增一颗磁盘时，应该有哪些动作需要做：</li>
</ul>
<ol>
<li>对磁盘进行<strong>分区</strong>，以建立可用的 partition ；</li>
<li>对该 partition 进行<strong>格式化 (format)</strong>，以建立系统可用的 filesystem；</li>
<li>若想要仔细一点，则可对刚刚建立好的 filesystem 进行检验；</li>
<li>在 Linux 系统上，需要<strong>建立挂载点 (亦即是目录)</strong>，并将他挂载上来；</li>
</ol>
<ul>
<li>观察磁盘分区状态</li>
</ul>
<ol>
<li>lsblk列出系统上的所有磁盘列表</li>
<li>blkid  列出装置的UUID 等参数</li>
<li>parted 列出磁盘的 分区 表类型与 分区 信息</li>
<li>磁盘分区： gdisk/fdisk</li>
</ol>
<ul>
<li>磁盘格式化( 建置文件系统)</li>
</ul>
<ol>
<li>XFS  文件系统 mkfs.xfs</li>
<li>XFS  文件系统 for RAID  效能优化 (Optional)</li>
<li>EXT4  文件系统 mkfs.ext4</li>
<li>其他文件系统 mkfs</li>
</ol>
<ul>
<li>文件系统检验</li>
</ul>
<ol>
<li>xfs_repair  处理 XFS文件系统</li>
<li>fsck.ext4  处理 EXT4  文件系统</li>
</ol>
<ul>
<li>文件系统挂载与卸除  (相当于插入u盘后显示的载入点)<br>
载点的意义：挂载点是目录， 而这个目录是进入磁盘分区槽(其实是 文件系统)的入口</li>
</ul>
<ul>
<li>单一文件系统不应该被重复挂载在不同的挂载点(目录)中；</li>
<li>单一目录不应该重复挂载多个文件系统；</li>
<li>要作为挂载点的目录，理论上应该都是空目录才是<br>
挂载了文件系统之后，原目录 下的东西就会暂时的消失。等 到新分区槽被卸除之后，原本的内容就会再次的跑出来</li>
</ul>
<p>挂载指令 -mount<br>
[root@study ~]#  mount<br>
-t ：可以加上文件系统种类来指定欲挂载的类型</p>
<p>将装置文件卸除 -umount<br>
[root@study ~]# umount [-fn] 装置文件名或挂载点</p>
<p>-f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下；<br>
-l ：立刻卸除文件系统，比 -f 还强！</p>
<p>由于通通卸除了，此时你才可以退出光盘片、软盘片、USB 随身碟等设备<br>
由于你目前正在目录内，也就是说其实『你正在使用该文件系统！所以自然无法卸除这个装置！那该如何是好？就『离开该文件系统的挂载点』即可</p>
<ul>
<li>
<p>磁盘/ 文件系统参数修订<br>
修改目前文件系统的一些相关信息<br>
1.mknod 手动处理装置文件<br>
2.xfs_admin  修改 XFS  文件系统的 UUID  与 Label name<br>
3.tune2fs  修改 ext4  的 label name  与 UUID</p>
</li>
<li>
<p>设定开机挂载<br>
开机挂载 /etc/fstab  及 /etc/mtab<br>
/etc/fstab 可设置开机自动挂载文件系统<br>
系统挂载的一些限制：<br>
•  根目录 / 是必须挂载的﹐而且一定要先于其它 mount point 被挂载进来。<br>
•  其它 mount point 必须为已建立的目录﹐可任意指定﹐但一定要遵守必须的系统目录架构原则 (FHS)<br>
•  所有 mount point 在同一时间之内﹐只能挂载一次。<br>
•  所有 partition 在同一时间之内﹐只能挂载一次。<br>
•  如若进行卸除﹐您必须先将工作目录移到 mount point(及其子目录) 之外。</p>
</li>
<li>
<p>建立大 文件 以制作 loop  装置 文件<br>
将这个文件格式化后挂载：制作出一个大文件，然后将这个文件挂载！如此一来感觉上你就多了一个分区槽啰<br>
o  建立大型文件<br>
程序 dd可以用来建立空的文件<br>
[root@study ~]#  dd if=/dev/zero of=/srv/loopdev bs=1M count=512<br>
512+0 records in &lt;==读入 512 笔资料<br>
512+0 records out &lt;==输出 512 笔数据<br>
536870912 bytes (537 MB) copied, 12.3484 seconds, 43.5 MB/s</p>
</li>
</ul>
<h1 id="这个指令的简单意义如下">这个指令的简单意义如下：</h1>
<h1 id="if-是-input-file-输入文件-那个-devzero-是会一直输出-0-的装置">if 是 input file ，输入文件。那个 /dev/zero 是会一直输出 0 的装置！</h1>
<h1 id="of-是-output-file-将一堆零写入到后面接的文件中">of 是 output file ，将一堆零写入到后面接的文件中。</h1>
<h1 id="bs-是每个-block-大小就像文件系统那样的-block-意义">bs 是每个 block 大小，就像文件系统那样的 block 意义；</h1>
<h1 id="count-则是总共几个-bs-的意思-所以-bscount-就是这个文件的容量了">count 则是总共几个 bs 的意思。所以 bs*count 就是这个文件的容量了！</h1>
<p>dd 就好像在迭砖块一样，将 512 块，每块 1MB 的砖块堆栈成为一个大文件 (/srv/loopdev) ！ 最终就会出现一个 512MB 的文件！</p>
<p>o  大型文件的格式化<br>
o  挂载<br>
可以在原本的分区槽在不更动原有的环境下制作出你想要的分区槽</p>
<ul>
<li>内存置换空间(swap)<br>
可以暂时将内存的程序拿到硬盘中暂放的内存置换空间 (swap)<br>
安装时一定需要的两个 partition ，一个是根目录，另外一个就是 swap(内存置换空间)<br>
那当内存不足的时候，为了让后续的程序可以顺利的运作，因此在内存中暂不使用的程序与数据就会被挪到 swap 中</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 70. 爬楼梯[简单][未做出]]]></title>
        <id>https://lixin-ee.github.io//post/dong-tai-gui-hua-70-pa-lou-ti-jian-dan-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/dong-tai-gui-hua-70-pa-lou-ti-jian-dan-wei-zuo-chu">
        </link>
        <updated>2019-12-31T01:45:17.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br>
注意：给定 n 是一个正整数。<br>
示例 1：<br>
输入： 2<br>
输出： 2<br>
解释： 有两种方法可以爬到楼顶。<br>
1.1 阶 + 1 阶<br>
2.2 阶<br>
示例 2：<br>
输入： 3<br>
输出： 3<br>
解释： 有三种方法可以爬到楼顶。<br>
1.1 阶 + 1 阶 + 1 阶<br>
2.1 阶 + 2 阶<br>
3.2 阶 + 1 阶<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/climbing-stairs<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>有点像动态规划<br>
等等！怎么那么像排列组合？！<br>
列出全部为1的情况，然后随机对1进行组合<br>
不对，首先我将其视为一棵树，左子树+1，右子树+2，当叶节点大于等于n的时候就将次数增加1<br>
尴尬，代码是对的，但是超出时间限制了<br>
然后想想对称地用队列的方法 继续翻车超出时间限制<br>
接下来就是动态规划了，我的想法是对于一个全为1的序列，如果前一个1没选择组合为2的话，当前的1就可以选择组合成2或者保持为1，否则只能保持1<br>
动态规划也翻车了<br>
还是好好看看题解吧，其实是斐波那契的问题，但是树的优化也很值得看看</p>
<p>注意实现动态规划时，初始状态是0步而不是1步，所以n=2是是level[0]+level[1]所以需要数组n+1</p>
<pre><code>class Solution {
public:
    int climbStairs(int n) {
        vector&lt;int&gt; level(n+1,1);
        for(int i=2;i&lt;n+1;++i)
            level[i]=level[i-1]+level[i-2];
        return level.back();
    }
};
</code></pre>
<p>超时代码：</p>
<pre><code>/*
class Solution {
public:
    int count=0;
    int climbStairs(int n) {
        add1(0,n);
        add2(0,n); 
        return count;
    }
    
    void add1(int i,int n){
        ++i;
        if(i==n){
            ++count;
            return;
        }
        if(i&gt;n)
            return;
        add1(i,n);
        add2(i,n);
    }
    
    void add2(int i,int n){
        i+=2;
        if(i==n){
            ++count;
            return;
        }
        if(i&gt;n)
            return;
        add1(i,n);
        add2(i,n);          
    }
};
*/
 /*
    int climbStairs(int n) {
        int count=0;
        queue&lt;int&gt; nums;
        nums.push(n);
        while(!nums.empty()){
            int temp=nums.front();
            nums.pop();
            if(temp-1==0)
                ++count;
            if(temp-2==0)
                ++count;
            if(temp-1&gt;0)
                nums.push(temp-1);
            if(temp-2&gt;0)
                nums.push(temp-2);
        }
        return count;  
    }
    */
</code></pre>
<p>然后是题解：</p>
<blockquote>
<p>摘要<br>
假设你正在爬楼梯，需要 n 阶你才能到达楼顶。<br>
每次你可以爬 1 或 2 个台阶，你有多少种不同的方法可以爬到楼顶呢？<br>
解决方案</p>
</blockquote>
<blockquote>
<p>方法一：暴力法<br>
算法<br>
在暴力法中，我们将会把所有可能爬的阶数进行组合，也就是 1 和 2 。而在每一步中我们都会继续调用 climbStairs这个函数模拟爬 1 阶和 2 阶的情形，并返回两个函数的返回值之和。<br>
climbStairs(i,n)=(i + 1, n) + climbStairs(i + 2, n)<br>
其中 i 定义了当前阶数，而 n 定义了目标阶数。</p>
</blockquote>
<pre><code>Java
public class Solution {
    public int climbStairs(int n) {
        climb_Stairs(0, n);
    }
    public int climb_Stairs(int i, int n) {
        if (i &gt; n) {
            return 0;
        }
        if (i == n) {
            return 1;
        }
        return climb_Stairs(i + 1, n) + climb_Stairs(i + 2, n);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(2^n )，树形递归的大小为 2^n2<br>
空间复杂度：O(n)，递归树的深度可以达到 n 。</p>
</blockquote>
<blockquote>
<p>方法二：记忆化递归<br>
算法<br>
在上一种方法中，我们计算每一步的结果时出现了冗余。另一种思路是，我们可以把每一步的结果存储在 memo 数组之中，每当函数再次被调用，我们就直接从 memo 数组返回结果。<br>
在 memo 数组的帮助下，我们得到了一个修复的递归树，其大小减少到 n。</p>
</blockquote>
<pre><code>Java
public class Solution {
    public int climbStairs(int n) {
        int memo[] = new int[n + 1];
        return climb_Stairs(0, n, memo);
    }
    public int climb_Stairs(int i, int n, int memo[]) {
        if (i &gt; n) {
            return 0;
        }
        if (i == n) {
            return 1;
        }
        if (memo[i] &gt; 0) {
            return memo[i];
        }
        memo[i] = climb_Stairs(i + 1, n, memo) + climb_Stairs(i + 2, n, memo);
        return memo[i];
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)，树形递归的大小可以达到 n。<br>
空间复杂度：O(n)，递归树的深度可以达到 n。</p>
</blockquote>
<blockquote>
<p>方法三：动态规划<br>
算法<br>
不难发现，这个问题可以被分解为一些包含最优子结构的子问题，即它的最优解可以从其子问题的最优解来有效地构建，我们可以使用动态规划来解决这一问题。<br>
第 i 阶可以由以下两种方法得到：<br>
在第 (i−1) 阶后向上爬一阶。<br>
在第 (i−2) 阶后向上爬 2 阶。<br>
所以到达第 i 阶的方法总数就是到第(i−1) 阶和第 (i−2) 阶的方法数之和。<br>
令 dp[i] 表示能到达第 i 阶的方法总数：<br>
dp[i]=dp[i−1]+dp[i−2]</p>
</blockquote>
<pre><code>public class Solution {
    public int climbStairs(int n) {
        if (n == 1) {
            return 1;
        }
        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i &lt;= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)，单循环到 n 。<br>
空间复杂度：O(n)，dp 数组用了 n 的空间。</p>
</blockquote>
<blockquote>
<p>方法四：斐波那契数<br>
算法<br>
在上述方法中，我们使用 dp 数组，其中 dp[i]=dp[i-1]+dp[i-2]。可以很容易通过分析得出dp[i] 其实就是第 ii 个斐波那契数。<br>
Fib(n)=Fib(n−1)+Fib(n−2)<br>
现在我们必须找出以 1 和 2 作为第一项和第二项的斐波那契数列中的第 n 个数，也就是说 Fib(1)=1Fib(1)=1 且 Fib(2)=2Fib(2)=2。</p>
</blockquote>
<pre><code>Java
public class Solution {
    public int climbStairs(int n) {
        if (n == 1) {
            return 1;
        }
        int first = 1;
        int second = 2;
        for (int i = 3; i &lt;= n; i++) {
            int third = first + second;
            first = second;
            second = third;
        }
        return second;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)，单循环到 n，需要计算第 n 个斐波那契数。<br>
空间复杂度：O(1)，使用常量级空间。</p>
</blockquote>
<p>下面的就很数学了，在面试中说出来就明显是刷题的了，所以就不贴了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ [Linux基础] 文件与目录管理（鸟哥Linux第六章）]]></title>
        <id>https://lixin-ee.github.io//post/linux-ji-chu-wen-jian-yu-mu-lu-guan-li-niao-ge-linux-di-liu-zhang</id>
        <link href="https://lixin-ee.github.io//post/linux-ji-chu-wen-jian-yu-mu-lu-guan-li-niao-ge-linux-di-liu-zhang">
        </link>
        <updated>2019-12-30T12:24:53.000Z</updated>
        <content type="html"><![CDATA[<p>绝对路径：路径的写法『一定由根目录 / 写起』<br>
相对路径：路径的写法『不是由 / 写起』</p>
<ul>
<li>目录的相关操作<br>
. 代表此层目录<br>
.. 代表上一层目录<br>
-代表前一个工作目录<br>
~ 代表『目前用户身份』所在的家目录<br>
~account 代表 account 这个用户的家目录(account 是个账号名称)</li>
</ul>
<p>在所有目录底下都会存在的两个目录，分别是『.』与『..』 分别代表此层与上层<br>
目录的意思。</p>
<p>几个常见的处理目录的指令：<br>
•  cd：变换目录<br>
cd 是 Change Directory 的缩写</p>
<p>•  pwd：显示当前目录<br>
-P ：显示出确实的路径，而非使用链接 (link) 路径。<br>
pwd 是 Print Working Directory 的缩写，也就是显示目前所在目录的指令</p>
<p>•  mkdir：建立一个新的目录<br>
-m ：配置文件案的权限喔！直接设定，不需要看预设权限 (umask) 的脸色<br>
-p ：帮助你直接将所需要的目录(包含上层目录)递归建立起来！</p>
<p>•  rmdir：删除一个空的目录<br>
-p ：连同『上层』『空的』目录也一起删除<br>
目录需要一层一层的删除才行！而且被删除的目录里面必定不能存在其他的目录或文 件<br>
那如果要将所有目录下的东西都杀掉就必须使用『 rm -r test 』</p>
<ul>
<li>关于执行文件路径的变量： $PATH<br>
echo <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mi>A</mi><mi>T</mi><mi>H</mi><mi mathvariant="normal">环</mi><mi mathvariant="normal">境</mi><mi mathvariant="normal">变</mi><mi mathvariant="normal">量</mi><mi mathvariant="normal">打</mi><mi mathvariant="normal">印</mi><mi mathvariant="normal">，</mi><mi>e</mi><mi>c</mi><mi>h</mi><mi>o</mi><mi mathvariant="normal">有</mi><mi mathvariant="normal">『</mi><mi mathvariant="normal">显</mi><mi mathvariant="normal">示</mi><mi mathvariant="normal">、</mi><mi mathvariant="normal">印</mi><mi mathvariant="normal">出</mi><mi mathvariant="normal">』</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">，</mi></mrow><annotation encoding="application/x-tex">PATH 环境变量打印，echo 有『显示、印出』的，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord cjk_fallback">环</span><span class="mord cjk_fallback">境</span><span class="mord cjk_fallback">变</span><span class="mord cjk_fallback">量</span><span class="mord cjk_fallback">打</span><span class="mord cjk_fallback">印</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">o</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">『</span><span class="mord cjk_fallback">显</span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">、</span><span class="mord cjk_fallback">印</span><span class="mord cjk_fallback">出</span><span class="mord cjk_fallback">』</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">，</span></span></span></span> 表示后面接的是变量<br>
PATH(一定是大写)这个变量的内容是由一堆目录所组成的，每个目录中间用冒号(:)来隔开， 每个目 录是有『顺序』之分的。</li>
</ul>
<p>修改PATH：[root@study ~]#PATH=&quot;${PATH}:/root&quot; (将/root 加入 PATH 当中)</p>
<p>为了安全起见，不建议将当前目录『.』加入 PATH 的搜寻目录中。</p>
<ul>
<li>
<p>文件与目录管理<br>
文件与目录的检视： ls<br>
选项与参数：<br>
<strong>-a ：全部的文件，连同隐藏档( 开头为 . 的文件) 一起列出来(常用)</strong><br>
-A ：全部的文件，连同隐藏档，但不包括 . 与 .. 这两个目录<br>
<strong>-d ：仅列出目录本身，而不是列出目录内的文件数据(常用)</strong><br>
-f ：直接列出结果，而不进行排序 (ls 预设会以档名排序！)<br>
-F ：根据文件、目录等信息，给予附加数据结构，例如：* :代表可执行文件； /:代表目录； =:代表 socket 文件； |:代表 FIFO 文件；<br>
-h ：将文件容量以人类较易读的方式(例如 GB, KB 等等)列出来；<br>
-i ：列出 inode 号码，inode 的意义下一章将会介绍；<br>
<strong>-l ：长数据串行出，包含文件的属性与权限等等数据；(常用)</strong><br>
-n ：列出 UID 与 GID 而非使用者与群组的名称 (UID 与 GID 会在账号管理提到！)<br>
-r ：将排序结果反向输出，例如：原本档名由小到大，反向则为由大到小；<br>
-R ：连同子目录内容一起列出来，等于该目录下的所有文件都会显示出来；<br>
-S ：以文件容量大小排序，而不是用档名排序；<br>
-t ：依时间排序，而不是用档名。<br>
--color=never ：不要依据文件特性给予颜色显示；<br>
--color=always ：显示颜色<br>
--color=auto ：让系统自行依据设定来判断是否给予颜色<br>
--full-time ：以完整时间模式 (包含年、月、日、时、分) 输出<br>
--time={atime,ctime} ：输出 access 时间或改变权限属性时间 (ctime)<br>
而非内容变更时间 (modification time)<br>
当你只有下达 ls 时，默认显示的只有：非隐藏档的档名、 以档名进行排序及文件名代表的颜色显示</p>
</li>
<li>
<p>复制、删除与移动： cp, rm, mv<br>
cp ( 复制 文件 或目录)<br>
<strong>-a ：相当于 -dr --preserve=all 的意思，至于 dr 请参考下列说明；(常用)</strong><br>
-d ：若来源文件为链接文件的属性(link file)，则复制链接文件属性而非文件本身；<br>
-f ：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；<br>
<strong>-i ：若目标文件(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</strong><br>
-l ：进行硬式连结(hard link)的连结档建立，而非复制文件本身；<br>
<strong>-p ：连同文件的属性(权限、用户、时间)一起复制过去，而非使用默认属性(备份常用)；</strong><br>
<strong>-r ：递归持续复制，用于目录的复制行为；(常用)</strong><br>
-s ：复制成为符号链接文件 (symbolic link)，亦即『快捷方式』文件；<br>
-u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制。（在目标文件与来源文件有差异时，才会复制，比较常被用于『备份』的工作）<br>
--preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links,xattr 等也复制了。</p>
</li>
</ul>
<p>如果来源档有两个以上，则最后一个目的文件一定要是『目录』<br>
在预设的条件中， cp 的来源档与目的档的权限是不同的，目的档的拥有者通常会是指令操作者本身。</p>
<p>使用 -l 及 -s 都会建立所谓的连结档(link file)，但是这两种连结档却有不一样的 情况。那个 -l 就是所谓的实体链接(hard link)，至于 -s 则是符号链接(symbolic link)，符号链接(symbolic link)是一个『快捷方式』，实体链接(hard link) 与 bashrc 的属性与权限完全一模一样，与尚未进行连结前的差异则是第二栏的 link 数由 1 变成 2</p>
<ul>
<li>rm ( 移除文件或目录)<br>
选项与参数：<br>
-f ：就是 force 的意思，忽略不存在的文件，不会出现警告讯息；<br>
-i ：互动模式，在删除前会询问使用者是否动作<br>
-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！</li>
</ul>
<p>使用『 rm -r 』这个指令之前，请千万注 意了，因为该目录或文件『肯定』会被 root 杀掉！</p>
<ul>
<li>
<p>mv ( 移动文件与目录，或更名)<br>
选项与参数：<br>
-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；<br>
-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！<br>
-u ：若目标文件已经存在，且 source 比较新，才会更新 (update)</p>
</li>
<li>
<p>取得路径的文件名与目录名称</p>
</li>
</ul>
<p>[root@study ~]#  basename /etc/sysconfig/network<br>
network &lt;== 很简单！就取得最后的档名～<br>
[root@study ~]#  dirname /etc/sysconfig/network<br>
/etc/sysconfig &lt;== 取得的变成目录名了！</p>
<ul>
<li>文件内容查阅<br>
查阅一个文件的内容：<br>
•  cat 由第一行开始显示文件内容<br>
•  tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！<br>
•  nl 显示的时候，顺道输出行号！<br>
•  more 一页一页的显示文件内容<br>
•  less 与 more 类似，但是比 more 更好的是，他可以往前翻页！<br>
•  head 只看头几行<br>
•  tail 只看尾巴几行<br>
•  od 以二进制的方式读取文件内容！</li>
</ul>
<p>在 more 的时候，我们并没有办法向前面翻， 只能往后面看，但若使用了 less 时，就可以使用 [pageup] [pagedown] 等按键的功能来往前往后翻看文件<br>
在 less 里头可以拥有更多的『搜寻』功能，不止可以向下搜寻，也可以向上搜寻<br>
man 这个指令就是呼叫 less 来显示说明文件的内容的</p>
<ul>
<li>修改文件时间或建置新档： touch</li>
</ul>
<ul>
<li>modification time (mtime)： 当该文件的『内容数据』变更时，就会更新这个时间！内容数据指的是文件的内容，而不是文件的属性或 权限喔！</li>
<li>status time (ctime)： 当该文件的『状态 (status)』改变时，就会更新这个时间，举例来说，像是权限与属性被更改了，都会更新 这个时间啊。</li>
<li>access time (atime)： 当『该文件的内容被取用』时，就会更新这个读取时间 (access)。举例来说，我们使用 cat 去读取 /etc/man_db.conf ， 就会更新该文件的 atime 了。<br>
在默认的情况下，ls 显示出来的是该文件的 mtime ，也就是这个文件的内容上次被更动 的时间。</li>
</ul>
<p>时间修改指令：<br>
[root@study ~]#  touch [-acdmt]  文件<br>
选项与参数：<br>
-a ：仅修订 access time；<br>
-c ：仅修改文件的时间，若该文件不存在则不建立新文件；<br>
-d ：后面可以接欲修订的日期而不用目前的日期，也可以使用 --date=&quot;日期或时间&quot;<br>
-m ：仅修改 mtime ；<br>
-t ：后面可以接欲修订的时间而不用目前的时间，格式为[YYYYMMDDhhmm]</p>
<p>如果 touch 后面有接文件，则该文件的三个时间 (atime/ctime/mtime) 都会更新为目前的时间。若该文件不存在， 则会主动的建立一个新的空的文件</p>
<p>touch 这个指令最常被使用的情况是：<br>
•  建立一个空的文件；<br>
•  将某个文件日期修订为目前 (mtime 与 atime)</p>
<ul>
<li>文件与目录的默认权限与隐藏权限<br>
新增一个文件或目录时，默认的权限</li>
</ul>
<p>文件预设权限：umask<br>
umask 就是指定 『目前用户在建立文件或目录时候的权限默认值』<br>
查阅的方式有两种，一种可以直接输入 umask ，就可以看到数字型态的权限设定分数， 一种则是加入 -S (Symbolic) 这个选项，就会以符号类型的方式来显示出权限</p>
<p><strong>umask 的分数指的是『该默认值需要减掉的权限！』</strong></p>
<p>设定 umask ：直接在 umask 后面输入 需要减去的权限值就好了</p>
<ul>
<li>文件隐藏属性<br>
chattr ( 配置文件案隐藏属性) chattr [+-=][ASacdistu]  文件 或目 录 名 称<br>
+：增加某一个特殊参数，其他原本存在参数则不动。<br>
-：移除某一个特殊参数，其他原本存在参数则不动。<br>
= ：设定一定，且仅有后面接的参数</li>
</ul>
<p>a ：当设定 a 之后，这个文件将只能增加数据，而不能删除也不能修改数据，只有 root 才能设定这属性<br>
i ：这个 i 可就很厉害了！他可以让一个文件『不能被删除、改名、设定连结也无法写入或新增数据！』对于系统安全性有相当大的帮助！只有 root 能设定此属性</p>
<p>lsattr ( 显示文件隐藏属性)</p>
<ul>
<li>文件特殊权限： SUID, SGID, SBIT</li>
</ul>
<ol>
<li>
<p>Set UID : s 这个标志会出现在文件拥有者的 x 权限上，被称为 Set UID，简称为 SUID 的特殊权限<br>
基本上 SUID 有这样的限制与功能：<br>
•  SUID 权限仅对二进制程序(binary program)有效；<br>
•  执行者对于该程序需要具有 x 的可执行权限；<br>
•  本权限仅在执行该程序的过程中有效 (run-time)；<br>
•  执行者将具有该<strong>程序拥有者 (owner) 的权限</strong>。<br>
<img src="https://lixin-ee.github.io//post-images/1577711413192.png" alt=""><br>
SUID 仅可用在 binary program 上， 不能够用在 shell script 上面<br>
SUID 对于目录也是无效的</p>
</li>
<li>
<p>Set GID<br>
s 在群组的 x 时则称为 Set GID, SGID<br>
与 SUID 不同的是，SGID 可以针对文件或目录来设定<br>
如果是对文件来说， SGID 有如下的功能：<br>
•  SGID 对二进制程序有用；<br>
•  程序执行者对于该程序来说，需具备 x 的权限；<br>
•  执行者在执行的过程中将会获得该程序群组的支持！</p>
</li>
</ol>
<p>当一个目录设定了 SGID 的权限后，他将具有如下的功能：<br>
•  用户若对于此目录具有 r 与 x 的权限时，该用户能够进入此目录；<br>
•  用户在此目录下的有效群组(effective group)将会变成该目录的群组；<br>
•  用途：若用户在此目录下具有 w 的权限(可以新建文件)，则使用者所建立的新文件，该新文件的群组与此目录的群组相同</p>
<ol start="3">
<li>Sticky Bit<br>
Sticky Bit, SBIT 目前只针对目录有效，对于文件已经没有效果了<br>
SBIT 对于目录的作用是：<br>
•  当用户对于此目录具有 w, x 权限，亦即具有写入的权限时；<br>
•  当用户在该目录下建立文件或目录时，仅有自己与 root 才有权力删除该文件</li>
</ol>
<ul>
<li>
<p>SUID/SGID/SBIT权限设定<br>
数字型态更改权限的方式为『三个数字』的组合， 那么如果在这三个数字之前再加上一个数字的话，最前面的那个数字就代表这几个权限了！<br>
•  4 为 SUID<br>
•  2 为 SGID<br>
•  1 为 SBIT<br>
假设要将一个文件权限改为『-rwsr-xr-x』时，由于 s 在用户权力中，所以是 SUID ，因此， 在原先的 755 之前还要加上 4 ，也就是：『 chmod 4755 filename 』来设定<br>
大写的 S 与 T ： 因为 s 与 t 都是取代 x 这个权限的，但是我们是下达 7666 ！也就是说， user, group 以及others 都没有 x 这个可执行的标志( 因为 666 嘛 )，所以这个 S, T 代表的就是『空的』。SUID 是表示『该文件在执行的时候，具有文件拥有者的权限』，但是文件 拥有者都无法执行了当然就是空的<br>
而除了数字法之外，也可以透过符号法来处理，其中 SUID 为 u+s ，而 SGID 为 g+s ，SBIT则是 o+t</p>
</li>
<li>
<p>观察文件类型：file<br>
想要知道某个文件的基本数据，例如是属于 ASCII 或者是 data 文件，或者是 binary ， 且其中有没有使用到动态函式库 (share library) 等等的信息，就可以利用 file 这个指令来检阅</p>
</li>
<li>
<p>指令与 文件 的搜寻</p>
</li>
</ul>
<p>脚本文件名的搜寻<br>
指令的完整文件名和位置，透过 which或 type 来找寻</p>
<p>which 指令是根据『PATH』这个环境变量所规范的路径，去搜寻『执行档』的档名，所以找不到history 等『bash 内建的指令』,若加上 -a 选项，则可以列出所有的可以找到的同名执行文件，而非仅显示第一个</p>
<ul>
<li>文件档名的搜寻<br>
Linux 的搜寻指令find 不很常用的，因为速度慢之外， 也很操硬盘！一般我们都是先使用 whereis 或者是 locate 来检查，如果真的找不到了，才以 find 来搜寻<br>
因为 whereis 只找系统中某些特定目录底下的文件而已，locate则是利用数据库来搜寻文件名，当然两者就相当的快速， 并且没有实际的搜寻硬盘内的文件系统状态，比较省时间</li>
</ul>
<p>如果你要找的文件是具有特殊属性的，例如 SUID 、文件拥有者、文件大小等等， 那么利用 locate是没有办法达成</p>
<p>搜寻系统中不属于任何人的文件<br>
find /- nouser<br>
透过这个指令，可以轻易的就找出那些不太正常的文件。如果有找到不属于系统任何人的文件时，</p>
<p>find 的特殊功能就是能够进行额外的动作(action)。<br>
<img src="https://lixin-ee.github.io//post-images/1577711985462.png" alt=""><br>
该范例中特殊的地方有 {} 以及 ; 还有 -exec 这个关键词，这些东西的意义为：<br>
•  {} 代表的是『由 find 找到的内容』，如上图所示，find 的结果会被放置到 {} 位置中；<br>
•  -exec 一直到 ; 是关键词，代表 find 额外动作的开始 (-exec) 到结束 (;) ，在这中间的就是 find 指令内的额外动作。 在本例中就是『 ls -l {} 』啰！<br>
•  因为『 ; 』在 bash 环境下是有特殊意义的，因此利用反斜杠来跳脱。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于右值与移动构造函数]]></title>
        <id>https://lixin-ee.github.io//post/guan-yu-you-zhi-yu-yi-dong-gou-zao-han-shu</id>
        <link href="https://lixin-ee.github.io//post/guan-yu-you-zhi-yu-yi-dong-gou-zao-han-shu">
        </link>
        <updated>2019-12-30T03:57:06.000Z</updated>
        <content type="html"><![CDATA[<p>loading</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 53. 最大子序和[简单][动态规划][分治法]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-53-zui-da-zi-xu-he-jian-dan-dong-tai-gui-hua-fen-zhi-fa</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-53-zui-da-zi-xu-he-jian-dan-dong-tai-gui-hua-fen-zhi-fa">
        </link>
        <updated>2019-12-30T02:14:20.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>
示例:<br>
输入: [-2,1,-3,4,-1,2,1,-5,4],<br>
输出: 6<br>
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。<br>
进阶:<br>
如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/maximum-subarray<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>很明显的动态规划，然后进阶提示分治法hhh<br>
首先实现一下动态规划，主要的障碍点在于连续这个点<br>
如果是用0和1代表选择和不选择 那么0这个点就不能保存状态 那么今天的状态就等于叠加前一天的值和今天的值之间的最大值了<br>
然后注意因为可能会抛弃前面的序列或者后面的序列 比如 [1,-10,2] [2,-10,1]这两种情况存在，所以不可以返回动态规划数组的最后一个值<br>
必须用一个maxv存放历史最大值</p>
<p>分治法的话我感觉就是先分割到每个数，然后两两结合 返回当[左值，右值，左值+右值]之间的最大值<br>
但是问题来了， 怎么保证连续呢？类似于归并排序，merge是关键<br>
分治法还是没有想到好的合并方法，所以直接看题解</p>
<pre><code>class Solution {
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) {
        int len=nums.size();
        int res=nums[0];
        vector&lt;int&gt; maxv(len);
        maxv[0]=nums[0];
        for(int i=1;i&lt;len;++i){
           maxv[i]=max(maxv[i-1]+nums[i],nums[i]);
            res=max(res,maxv[i]);
        }
        return res;
    }

};
</code></pre>
<p>然后来看看题解<br>
动态规划法没啥好说的了<br>
比较有趣的是高赞回答</p>
<blockquote>
<p>思路<br>
这道题用动态规划的思路并不难解决，比较难的是后文提出的用分治法求解，但由于其不是最优解法，所以先不列出来<br>
动态规划的是首先对数组进行遍历，当前最大连续子序列和为 sum，结果为 ans<br>
如果 sum &gt; 0，则说明 sum 对结果有增益效果，则 sum 保留并加上当前遍历数字<br>
如果 sum &lt;= 0，则说明 sum 对结果无增益效果，需要舍弃，则 sum 直接更新为当前遍历数字<br>
每次比较 sum 和 ans的大小，将最大值置为ans，遍历结束返回结果<br>
时间复杂度：O(n)<br>
代码</p>
</blockquote>
<pre><code>Java
class Solution {
    public int maxSubArray(int[] nums) {
        int ans = nums[0];
        int sum = 0;
        for(int num: nums) {
            if(sum &gt; 0) {
                sum += num;
            } else {
                sum = num;
            }
            ans = Math.max(ans, sum);
        }
        return ans;
    }
}
</code></pre>
<p>这个思路很有趣，我们一般会想当前元素nums[i]对sum有没有增益，而这个题解要点在于反过来考虑sum对当前元素nums[i]有没有增益</p>
<p>关于分治法我曾经看到一个比较好的题解。。。但是突然找不到了。。。难道是被删了？？？<br>
主要的要点就是</p>
<blockquote>
<p>分治法<br>
这个是使用分治法解决问题的典型的例子，并且可以用与合并排序相似的算法求解。下面是用分治法解决问题的模板：<br>
定义基本情况。<br>
将问题分解为子问题并递归地解决它们。<br>
合并子问题的解以获得原始问题的解。<br>
算法：<br>
当最大子数组有 n 个数字时：<br>
若 n==1，返回此元素。<br>
left_sum 为最大子数组前 n/2 个元素，在索引为 (left + right) / 2 的元素属于左子数组。<br>
right_sum 为最大子数组的右子数组，为最后 n/2 的元素。<br>
cross_sum 是包含左右子数组且含索引 (left + right) / 2 的最大值。</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1577674348344.png" alt=""></p>
<pre><code>class Solution
{
public:
    int maxSubArray(vector&lt;int&gt; &amp;nums)
    {
        //类似寻找最大最小值的题目，初始值一定要定义成理论上的最小最大值
        int result = INT_MIN;
        int numsSize = int(nums.size());
        result = maxSubArrayHelper(nums, 0, numsSize - 1);
        return result;
    }

    int maxSubArrayHelper(vector&lt;int&gt; &amp;nums, int left, int right)
    {
        if (left == right)
        {
            return nums[left];
        }
        int mid = (left + right) / 2;
        int leftSum = maxSubArrayHelper(nums, left, mid);
        //注意这里应是mid + 1，否则left + 1 = right时，会无线循环
        int rightSum = maxSubArrayHelper(nums, mid + 1, right);
        int midSum = findMaxCrossingSubarray(nums, left, mid, right);
        int result = max(leftSum, rightSum);
        result = max(result, midSum);
        return result;
    }

    int findMaxCrossingSubarray(vector&lt;int&gt; &amp;nums, int left, int mid, int right)
    {
        int leftSum = INT_MIN;
        int sum = 0;
        for (int i = mid; i &gt;= left; i--)
        {
            sum += nums[i];
            leftSum = max(leftSum, sum);
        }

        int rightSum = INT_MIN;
        sum = 0;
        //注意这里i = mid + 1，避免重复用到nums[i]
        for (int i = mid + 1; i &lt;= right; i++)
        {
            sum += nums[i];
            rightSum = max(rightSum, sum);
        }
        return (leftSum + rightSum);
    }
};
</code></pre>
<p>注意跨中心的情况需要用贪心法进行计算<br>
始终觉得在这里用分治法怪怪的</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[并发与并行、多核与多线程]]></title>
        <id>https://lixin-ee.github.io//post/bing-fa-yu-bing-xing</id>
        <link href="https://lixin-ee.github.io//post/bing-fa-yu-bing-xing">
        </link>
        <updated>2019-12-30T00:58:20.000Z</updated>
        <content type="html"><![CDATA[<p>今天早上在看muduo的方案介绍事产生了一点疑惑<br>
书中的描述：</p>
<blockquote>
<p>方案5：这间小银行有一个旋转门、一个柜台，每次只允许一名客户办理业务。而且当有人在办理业务时，旋转门是锁住的（计算和IO 在同一线程）。为了维持工作效率，银行要求客户应该尽快办理业务，最好不要在取款的时候打电话去问家里人密码，也不要在通过旋转门的时候停下来系鞋带，这都会阻塞其他堵在门外的客户。如果客户很少，这是很经济且高效的方案；但是如果场地较大（多核），则这种布局就浪费了不少资源，只能并发（concurrent）不能并行（parallel）。如果确实一次办不完，应该离开柜台，到门外等着，等银行通知再来继续办理（分阶段回调）</p>
</blockquote>
<p>我的疑惑就在于：但是如果场地较大（多核），则这种布局就浪费了不少资源，只能<strong>并发(concurrent)</strong> 不能<strong>并行（parallel）</strong>。如果确实一次办不完，应该离开柜台，到门外等着，等银行通知再来继续办理（分阶段回调）</p>
<p>一瞬间我发现我对并发和并行的定义有点模糊了，因为我记得并发不是一个进程分为多个部分或者多个进程或多个线程交替执行吗？但是Reactor执行不是顺序执行的吗？</p>
<p>于是我去查了一下<br>
参考<a href="https://www.zhihu.com/question/33515481">并发与并行的区别？</a></p>
<blockquote>
<p>如果某个系统支持两个或者多个动作（Action）同时存在，那么这个系统就是一个<strong>并发系统</strong>。<br>
如果某个系统支持两个或者多个动作同时执行，那么这个系统就是一个<strong>并行系统</strong>。并发系统与并行系统这两个定义之间的关键差异在于“存在”这个词。<br>
并发和并行都可以是很多个线程，就看这些线程能不能同时被（多个）cpu执行，如果可以就说明是并行，而并发是多个线程被（一个）cpu 轮流切换着执行。<br>
并发就是指代码<strong>逻辑上可以并行</strong>，有并行的潜力，但是<strong>不一定当前是真的</strong>以物理并行的方式运行<br>
并发指的是代码的性质，并行指的是<strong>物理运行状态</strong></p>
</blockquote>
<p>然后是翻查CSAPP中的解释：</p>
<blockquote>
<p>一个逻辑流的执行在时间上与另一个流重叠，称为<strong>并发流（concurrent flow）</strong>，这两个流并发地运行<br>
多个流并发地执行的一般现象称为并发（concurrency）。一个进程和其他进程轮流运行的概念称为多任务（multitasking）。一个进程执行它的控制流的一部分的每一时间段叫做时间片（time slice），因此多任务也叫作时间分片（time slicing）；<br>
并发流的思想与流运行的处理器核数或者计算机数无关。如果两个流在时间上重叠，那么它们就是并发的，它是并发流的一个真子集。如果两个流并发地运行在不同的处理器核或者计算机上，那么我们称它们为<strong>并行流（parallel flow）</strong>，它们并行地运行（running in parallel），且并行地执行。<br>
并行流是并发流的真子集，并行流一定是并发流，并发流不一定是并行流。</p>
</blockquote>
<p>看来我对并发和并行的理解并没有错误啊<br>
那就是对Reactor的理解出现了偏差</p>
<p>然后我回去看了方案6和方案7的描述，发现一个问题</p>
<blockquote>
<p>它为每个请求（而不是每个连接）创建了一个新线程（方案6）<br>
每个连接创建一个计算线程，每个连接上的请求固定发给同一个线程去算（方案7）</p>
</blockquote>
<p>注意 连接-请求-线程 这三者！！！特别是一个连接下可以有多个请求！！！而不是必须一个连接一个请求！！！</p>
<p>那么回到方案5的描述 我们可以看到</p>
<blockquote>
<p>如果确实一次办不完，应该离开柜台，到门外等着，等银行通知再来继续办理（分阶段回调）</p>
</blockquote>
<p>这里就是请求的问题了，注意是等待通知而不是重新排队，相当于在并发运行，所以方案5只能并发不能并行就是这么来的</p>
<p>然后另外一个疑惑就是</p>
<blockquote>
<p>方案7 与方案6 的另外一个区别是单个client 的最大CPU 占用率。在方案6 中，一个TCP 连接上发来的一长串突发请求（burst requests）可以占满全部8 个core；而在方案7 中，由于每个连接上的请求固定由同一个线程处理，那么它最多占用12.5%的CPU 资源。</p>
</blockquote>
<p>这里就确实是我的认知出现了偏差，把 一个cpu当前只能运行一个进程+进程是资源分配的最小单位，线程是CPU调度的最小单位 误理解为 一个进程只能在一个cpu上运行（以为它的多线程也只能分配到这个cpu上）（错误的）<br>
这个明显是错误的，一个进程可以在多个cpu上运行，比如一个进程的多个线程可以在多个cpu上运行，这也就是方案6收到突发性爆炸请求占满cpu和方案7只开了8个线程（注意这里假设8个core）每个只占12.5%的由来<br>
但注意！一个线程是只能在一个cpu上跑的，无法切割开来</p>
<p>参考资料<br>
<img src="https://lixin-ee.github.io//post-images/1577669961214.png" alt=""><br>
方案2 这是传统的Java 网络编程方案thread-per-connection，在Java 1.4 引入NIO 之前，Java 网络服务多采用这种方案。它的初始化开销比方案1 要小很多，但与求解Sudoku 的用时差不多，仍然不适合短连接服务。这种方案的伸缩性受到线程数的限制，一两百个还行，几千个的话对操作系统的scheduler 恐怕是个不小的负担。<br>
方案5 基本的单线程Reactor 方案。这种方案的优点是由网络库搞定数据收发，程序只关心业务逻辑；缺点：适合IO 密集的应用，不太适合CPU 密集的应用，因为较难发挥多核的威力。另外，与方案2 相比，方案5 处理网络消息的延迟可能要略大一些，因为方案2 直接一次read(2) 系统调用就能拿到请求数据，而方案5 要先poll(2) 再read(2)，多了一次系统调用。</p>
<p>方案6 这是一个过渡方案，收到Sudoku 请求之后，不在Reactor 线程计算，而是创建一个新线程去计算，以充分利用多核CPU。这是非常初级的多线程应用，因为它为每个请求（而不是每个连接）创建了一个新线程。这个开销可以用线程池来避免，即方案8。这个方案还有一个特点是out-of-order，即同时创建多个线程去计算同一个连接上收到的多个请求，那么算出结果的次序是不确定的，可能第2 个Sudoku 比较简单，比第1 个先算出结果。这也是我们在一开始设计协议的时候使用了id 的原因，以便客户端区分response 对应的是哪个request。</p>
<p>方案7 为了让返回结果的顺序确定，我们可以为每个连接创建一个计算线程，每个连接上的请求固定发给同一个线程去算，先到先得。这也是一个过渡方案，因为并发连接数受限于线程数目，这个方案或许还不如直接使用阻塞IO 的thread-per-connection 方案2。</p>
<p>方案7 与方案6 的另外一个区别是单个client 的最大CPU 占用率。在方案6 中，一个TCP 连接上发来的一长串突发请求（burst requests）可以占满全部8 个core；而在方案7 中，由于每个连接上的请求固定由同一个线程处理，那么它最多占用12.5%的CPU 资源。这两种方案各有优劣，取决于应用场景的需要（到底是公平性重要还是突发性能重要）。这个区别在方案8 和方案9 中同样存在，需要根据应用来取舍。</p>
<p>方案8 为了弥补方案6 中为每个请求创建线程的缺陷，我们使用固定大小线程池，程序结构如图6-12 所示。全部的IO 工作都在一个Reactor 线程完成，而计算任务交给thread pool。如果计算任务彼此独立，而且IO 的压力不大，那么这种方案是非常适用的。</p>
<p>方案9 这是muduo 内置的多线程方案，也是Netty 内置的多线程方案。这种方案的特点是one loop per thread，有一个main Reactor 负责accept(2) 连接，然后把连接挂在某个sub Reactor 中（muduo 采用round-robin 的方式来选择sub Reactor），这样该连接的所有操作都在那个sub Reactor 所处的线程中完成。多个连接可能被分派到多个线程中，以充分利用CPU。</p>
<p>muduo 采用的是固定大小的Reactor pool，池子的大小通常根据CPU 数目确定，也就是说线程数是固定的，这样程序的总体处理能力不会随连接数增加而下降。另外，由于一个连接完全由一个线程管理，那么请求的顺序性有保证，突发请求也不会占满全部8 个核（如果需要优化突发请求，可以考虑方案11）。这种方案把IO 分派给多个线程，防止出现一个Reactor 的处理能力饱和。</p>
<p>与方案8 的线程池相比，方案9 减少了进出thread pool 的两次上下文切换，在把多个连接分散到多个Reactor 线程之后，小规模计算可以在当前IO 线程完成并发回结果，从而降低响应的延迟。我认为这是一个适应性很强的多线程IO 模型，因此把它作为muduo 的默认线程模型（见图6-13）。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Linux基础] 文件权限与目录配置（鸟哥Linux第五章）]]></title>
        <id>https://lixin-ee.github.io//post/linux-ji-chu-wen-jian-quan-xian-yu-mu-lu-pei-zhi-niao-ge-linux-di-wu-zhang</id>
        <link href="https://lixin-ee.github.io//post/linux-ji-chu-wen-jian-quan-xian-yu-mu-lu-pei-zhi-niao-ge-linux-di-wu-zhang">
        </link>
        <updated>2019-12-29T13:22:46.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>文件概览<br>
Linux 一般将文件可存取的身份分为三个类别，分别是 <code>owner/group/others</code><br>
且三种身份各有<code>read/write/execute</code> 等权限。</li>
</ul>
<p>『 ls -al 』察看文件的指令<br>
ls 是『list』的意思，重点在显示文件的文件名与相关属性，选项『-al』则表示列出所有的文件详 细的权限与属性<br>
<img src="https://lixin-ee.github.io//post-images/1577625881102.png" alt=""></p>
<p>第一栏代表这个文件的类型与权限(permission) ：<br>
第一个字符代表这个文件是『目录、文件或链接文件等等』：</p>
<ul>
<li>当为[ d ]则是目录，例如上表档名为『.config』的那一行；</li>
<li>当为[ ]则是文件，例如上表档名为『initial-setup-ks.cfg』那一行；</li>
<li>若是[ l ]则表示为连结档(link file)；</li>
<li>若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；</li>
<li>若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。</li>
</ul>
<p>[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)<br>
第一组为『文件拥有者可具备的权限』（<strong>而不是root</strong>）<br>
第二组为『加入此群组之账号的权限』；<br>
第三组为『非本人且没有加入本群组之其他账号的权限』</p>
<ul>
<li>第二栏表示有多少档名连结到此节点(i-node)</li>
<li>第三栏表示这个文件( 或目录) 的『拥有者账号』</li>
<li>第四栏表示这个文件在 Linux 系统下，你的账号会加入于一个或多个的群组中。</li>
<li>第五栏为这个文件的容量大小，默认单位为 bytes ；</li>
<li>第六栏为这个文件的建档日期或者是最近的修改日期</li>
<li>第七栏为这个文件的档名,如果档名之前多一个『 . 』，则代表这个文件为『隐藏档』</li>
</ul>
<ul>
<li>如何改变文件属性与权限</li>
</ul>
<ul>
<li>chgrp ：改变文件所属群组  chgrp [-R] dirname/filename ...</li>
<li>chown ：改变文件拥有者 chown [-R] 账号名称 文件或目录</li>
</ul>
<p>需要注意的地方<br>
-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件、目录 都更新成为这个群组之意。常常用在变更某一目录内所有的文件之情况<br>
chown还可以顺便直接修改群组的名称<br>
由于复制行为(cp)会复制执行者的属性与权限，必须要将这个文件的拥有者与群组修改一下</p>
<ul>
<li>chmod ：改变文件的权限, SUID, SGID, SBIT 等等的特性</li>
<li>chmod [- R] xyz 文件或目录</li>
</ul>
<p>权限的设定方法有两种， 分别可以使用数字或者 是符号来进行权限的变更</p>
<ul>
<li>数字类型改变文件权限<br>
文件的权限字符为：『-rwxrwxrwx』，可以使用数字来代表各个权限，各权限的分数对照表如下： r:4 w:2 x:1<br>
每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx---] 分数 则是：<br>
owner = rwx = 4+2+1 = 7<br>
group = rwx = 4+2+1 = 7<br>
others= --- = 0+0+0 = 0</li>
</ul>
<p>-符号类型改变文件<br>
<img src="https://lixin-ee.github.io//post-images/1577626483344.png" alt=""></p>
<ul>
<li>目录与文件<br>
这里很重要，虽然目录和文件都是拥有相同的权限模式，但是不同的权限之间的意义不同</li>
</ul>
<p>-权限对于文件来说</p>
<ul>
<li>r (read)：可读取此一文件的实际内容，如读取文本文件的文字内容等；</li>
<li>w (write)：可以编辑、新增或者是修改该文件的内容 <strong>(但不含删除该文件)</strong>；</li>
<li>x (execute)：该文件具有可以被系统执行的权限。<br>
对于文件的 rwx 来说， 主要都是针对『文件 的内容』而言，与文件档名的存在与否没有关系</li>
</ul>
<p>-权限对目录的重要性</p>
<ul>
<li>r (read contents in directory)： 表示具有读取目录结构列表的权限，所以当你具有读取(r)一个目录的权限时，表示你可以查询该目录下的 文件名数据。 所以你就可以利用 ls 这个指令将该目录的内容列表显示出来！</li>
<li>w (modify contents of directory)： 这个可写入的权限对目录来说，是很了不起的！ 因为他表示你具有异动该目录结构列表的权限，也就是底 下这些权限：</li>
<li>建立新的文件与目录；</li>
<li><strong>删除已经存在的文件与目录(不论该文件的权限为何！)</strong></li>
<li>将已存在的文件或目录进行更名；</li>
<li>搬移该目录内的文件、目录位置。<br>
总之，目录的 w 权限就与该目录底下的文件名异动有关</li>
<li>x (access directory)：目录不可以被执 行，目录的 x 代表的是用户能否进入该目录成为工作目录的用途！ 所谓的工作目录(work directory)就是你 目前所在的目录啦！举例来说，当你登入 Linux 时， 你所在的家目录就是你当下的工作目录。而变换目录 的指令是『cd』(change directory)！<br>
开放目录给任何人浏览时，应该至少也要给予 r 及 x 的权限，但 <strong>w 权限不可随便给</strong><br>
<img src="https://lixin-ee.github.io//post-images/1577626751407.png" alt=""><br>
<img src="https://lixin-ee.github.io//post-images/1577626845793.png" alt=""></li>
</ul>
<ul>
<li>绝对路径与相对路径<br>
绝对路径：由根目录(/)开始写起的文件名或目录名称， 例如 /home/dmtsai/.bashrc；<br>
相对路径：相对于目前路径的文件名写法。 例如 ./home/dmtsai 或 ../../home/dmtsai/ 等等。反正开头不是 /就属于相对路径的写法<br>
特别注意这两个特殊的目录：<br>
. ：代表当前的目录，也可以使用 ./ 来表示；<br>
.. ：代表上一层目录，也可以 ../ 来代表。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[信号、信号量、互斥量与条件变量]]></title>
        <id>https://lixin-ee.github.io//post/xin-hao-liang-yu-tiao-jian-bian-liang</id>
        <link href="https://lixin-ee.github.io//post/xin-hao-liang-yu-tiao-jian-bian-liang">
        </link>
        <updated>2019-12-29T09:48:08.000Z</updated>
        <content type="html"><![CDATA[<p>这几天在读《现代操作系统》的时候读到了信号量这一章，定义如下：</p>
<p>信号（signal）：是一种处理异步事件的方式。信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程外，还可以发送信号给进程本身。<br>
类似于软中断，如果进程接受到了信号，就相当于发生了中断，这时候进程会切换到内核态去执行信号处理函数，注意下，一个进程可能有两个执行序列，一个是main，另一个就是信号处理函数，信号处理函数有自己的栈空间的。当执行完了信号处理函数，才会再回到main函数中被抢占的代码上。不同的信号有不同的功能，比如可以让进程结束。</p>
<p>信号量(Semaphore) ：进程间通信处理同步互斥的机制。是在多线程环境下使用的一种设施, 它负责协调各个线程, 以保证它们能够正确、合理的使用公共资源<br>
使用一个整形变量（或者新的变量类型）来累计唤醒次数。其中检查数值、修改变量值亦即可能发生的睡眠操作均作为一个单一的、不可分割的<strong>原子操作</strong>完成，保证一旦一个信号量操作开始，则在改操作完成或阻塞之前，其他进程均不允许访问该信号量。</p>
<p>所以我们可以看出信号和信号量两者完全没有关联，只是翻译为中文时两者描述重合度有点高，导致我有点误会了。</p>
<p>下面才是重点。</p>
<p>我看完信号量的例子后，突然有点迷惑，这信号量难道不是互斥量（mutex）的多计数版吗？？？或者说互斥量（下称 锁）不就是信号量的二元版？？？<br>
但是感觉总有啥地方说不过去啊。。。<br>
所以上网查看了一番，得到以下分析：</p>
<blockquote>
<p>虽然 Mutex和Semaphore 在一定程度上可以互相替代，比如你可以把 值最大为1 的Semaphore当Mutex用，也可以用Mutex＋计数器当Semaphore。<br>
但是对于设计理念上还是有不同的，Mutex管理的是资源的使用权，而Semaphore管理的是资源的数量，有那么一点微妙的小区别。<br>
打个比方，在早餐餐厅，大家要喝咖啡。<br>
如果用Mutex的方式，同时只有一个人可以使用咖啡机，他获得了咖啡机的使用权后，开始做咖啡，其他人只能在旁边等着，直到他做好咖啡后，另外一个人才能获得咖啡机的使用权。<br>
如果用Semaphore的模式，服务员会把咖啡做好放到柜台上，谁想喝咖啡就拿走一杯，服务员会不断做咖啡，如果咖啡杯被拿光了，想喝咖啡的人就排队等着。<br>
Mutex管理的是咖啡机的使用权，而Semaphore管理的是做好的咖啡数量。</p>
</blockquote>
<blockquote>
<p>锁是服务于共享资源的；而semaphore是服务于多个线程间的执行的逻辑顺序的。<br>
semaphore的本质就是调度线程 ，如果你要对共享资源进行保护，请用mutex<br>
条件锁，是为了避免绝大多数情况下都是lock ---&gt; 判断条件 ----&gt; unlock的这种很占资源但又不干什么事情的线程。</p>
</blockquote>
<p>上述对信号量和锁的本质差别已经描述得很清楚了<br>
但是我还是有点疑惑，其实就像陈硕所说，其实锁使用起来好很多啊（甚至日常需求中完全可以取代信号量），为什么就用了大篇幅介绍呢</p>
<p>然后我看到这个回答</p>
<blockquote>
<p>我个人认为最重要的一点，优先级反转没有一个人提到。这难道不是最大的区别吗？这也应该是用户最关心的。</p>
</blockquote>
<p>对哦！醍醐灌顶啊！在书中本来信号量就是承接非得忙等待的自旋锁来介绍了，自旋锁的一个问题就是优先级反转（高优先级进程L必须等待低优先级进程L离开临界区）</p>
<p>然后摘抄书中对信号量的介绍</p>
<blockquote>
<p>up操作对信号量的值增1，如果一个或多个进程在该信号量上睡眠，无法完成一个先前的down操作，则由系统选择其中的一个（如随机挑选）并允许该进程完成它的down操作</p>
</blockquote>
<p>这样就能保证系统能够尽可能挑选高优先级的进程来执行，间接避免优先级反转的问题</p>
<p>参考链接<a href="https://www.zhihu.com/question/47704079">semaphore和mutex的区别？</a></p>
<p>然后又看到 条件变量这个东西<br>
它的函数调用都需要传入mutex形参，并且需要先mutex加锁？？？<br>
这个就很疑惑了，我本来的想法是条件变量是用来判断符合条件后才进行mutex加锁的，现在怎么反过来了？<br>
后来看了解析后才发现问题所在，原来是pthread_cond_wait函数内部的问题</p>
<pre><code>mutex.lock();

while (判断“条件”是否成立) {
    pthread_cond_wait 等待
}

mutext.unlock();
</code></pre>
<p>将 pthread_cond_wait 展开，内部实现中，会有下面的过程。</p>
<pre><code>mutext.unlock()
阻塞
唤醒
mutext.lock()
</code></pre>
<p>假如在线程 A中完全展开 pthread_cond_wait。</p>
<pre><code>mutex.lock();

while (判断“条件”是否成立) {
    做一些其它事情
    mutext.unlock()
    阻塞
    唤醒
    mutext.lock()
}

mutext.unlock();
</code></pre>
<p>所以得到结论</p>
<blockquote>
<p>传递的mutex并不是为了防止wait()函数内部的Race Condition！而是因为调用wait()之前你总是获得了某个mutex（例如用于解决此处pass变量的Race Condition的mutex），并且这个mutex在你调用wait()之前必须得释放掉，调用wait()之后必须得重新获取。</p>
</blockquote>
<p>我的结论 ：pthread_cond_wait内部有四个操作  解锁-wait-阻塞-唤醒-上锁 前两者是必须保证原子性的，否则阻塞之前唤醒信号就来了，再进入阻塞，会导致无法唤醒<br>
所以！！！传入mutex形参是为了保护while的条件判断，而不是循环内部要上锁</p>
<p>然后StackOverflow上的高赞回答：<br>
他们不是一回事。它们用于不同目的！<br>
虽然两种类型的信号量都具有full/empty状态并使用相同的API，但它们的用法却大不相同。<br>
Mutex<br>
Mutex用于保护共享资源（数据结构，文件等）。<br>
Mutex由执行该任务的任务“拥有”。如果任务B尝试给任务A当前持有的互斥锁赋值，则任务B的调用将返回错误并失败。<br>
互斥对象始终使用以下顺序：<br>
-SemTake-<br>
关键部分<br>
-SemGive<br>
这是一个简单的示例：<br>
Thread A                     Thread B<br>
Take Mutex<br>
access data<br>
...                        Take Mutex  &lt;== Will block<br>
...<br>
Give Mutex           access data  &lt;== Unblocks<br>
...<br>
Give Mutex																		<br>
二元Semaphore<br>
二元Semaphore解决了一个完全不同的问题：<br>
等待任务B等待某事发生（例如传感器触发）。<br>
传感器触发并运行中断服务程序。它需要通知行程任务。<br>
任务B应该运行并为传感器跳闸采取适当的措施。然后回到等待状态。<br>
Task A                                                          Task B<br>
...                                       Take BinSemaphore   &lt;== wait for something<br>
Do Something Noteworthy<br>
Give BinSemaphore                    do something    &lt;== unblocks<br>
请注意，对于二元信号量，B可以接收信号量，而A可以给出信号量。<br>
同样，二元信号量不能保护资源免受访问。发出信号量和采取信号量的行为从根本上是分离的。</p>
<p>附上一个例子 参考链接 <a href="https://www.zhihu.com/question/24116967">pthread_cond_wait 为什么需要传递 mutex 参数？</a></p>
<p>我在原来的答案中，有这样的代码：<br>
pthread_mutex_unlock(mtx);<br>
pthread_cond_just_wait(cv);<br>
pthread_mutex_lock(mtx);<br>
事实上，上面三行代码的并不是pthread_cond_wait(cv, mtx)的内联展开。其中第一行和第二行必须“原子化”，而第三行是可以分离出去的（之所以要把第三行放在里面的原因可以参见原来的答案）。</p>
<p>那么为什么第一行和第二行不能分离呢？这是因为必须得保证：如果线程A先进入wait函数（即使没有进入实际的等待状态，比如正在释放mtx），那么必须得保证其他线程在其之后调用的broadcast必须能够将线程A唤醒。</p>
<p>所以，把原来答案中的代码再贴一遍：<br>
// 线程A，条件测试<br>
pthread_mutex_lock(mtx);        // a1<br>
while(pass == 0) {              // a2<br>
pthread_mutex_unlock(mtx);  // a3<br>
pthread_cond_just_wait(cv); // a4<br>
pthread_mutex_lock(mtx);    // a5<br>
}<br>
pthread_mutex_unlock(mtx);</p>
<p>// 线程B，条件发生修改，对应的signal代码<br>
pthread_mutex_lock(mtx);   // b1<br>
pass = 1;                  // b2<br>
pthread_mutex_unlock(mtx); // b3<br>
pthread_cond_signal(cv);   // b4</p>
<p>如果执行序列是：a1, a2, a3, b1, b2, b3, b4, a4，那么线程A将不会被唤醒。而a3在线程B之前执行，这意味着wait函数是在signal之前调用的，所以不满足上文提到的保证。</p>
<p>解决办法：<br>
先将线程附加到等待队列<br>
释放mutex<br>
进入等待<br>
感兴趣的同学的可以看下源码（pthread_cond_wait.c），附加到等待队列这个操作是加锁的，所以可以保证之前发起的signal不会错误得唤醒本线程，而之后发起的signal必然唤醒本线程。</p>
<p>因此，下面的代码是绝对不会出错的：<br>
// 线程A，条件测试<br>
pthread_mutex_lock(mtx);        // a1<br>
while(pass == 0) {              // a2<br>
pthread_cond_wait(cv, mtx); // a3<br>
}<br>
pthread_mutex_unlock(mtx);      // a4</p>
<p>// 线程B，条件发生修改，对应的signal代码<br>
pthread_mutex_lock(mtx);   // b1<br>
pass = 1;                  // b2<br>
pthread_mutex_unlock(mtx); // b3<br>
pthread_cond_signal(cv);   // b4<br>
如果线程A先运行，那么执行序列必然是：a1, a2, a3, b1, b2, b3, b4, a4。<br>
如果线程B先运行，那么执行序列可能是：b1, b2, b3, b4, a1, a2, a4<br>
也可能是：b1, b2, b3, a1, a2, a3, b4, a4</p>
<p>所以，如果是我设计pthread API，那么我会添加一个pthread_cond_unlock_and_wait函数，伪代码如下：<br>
int pthread_cond_wait(cv, mtx) {<br>
int ret = pthread_cond_unlock_and_wait(cv, mtx);<br>
pthread_mutex_lock(mtx);<br>
return ret;<br>
}</p>
<p>// 线程A，条件测试<br>
pthread_mutex_lock(mtx);<br>
if (pass == 0)<br>
pthread_cond_unlock_and_wait(cv, mtx);<br>
else<br>
pthread_mutex_unlock(mtx);</p>
<p>// 线程B，条件发生修改，对应的signal代码<br>
pthread_mutex_lock(mtx);   // b1<br>
pass = 1;                  // b2<br>
pthread_mutex_unlock(mtx); // b3<br>
pthread_cond_signal(cv);   // b4</p>
<p>这样的好处在于：如果我们可以保证没有虚假唤醒（即不需要while循环测试条件），那么我们可以将线程A的代码改成上述形式，这样无论怎样都只需要执行一次pthread_mutex_unlock()函数，而之前的版本至少需要执行两次。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[栈 155. 最小栈[简单]]]></title>
        <id>https://lixin-ee.github.io//post/zhan-155-zui-xiao-zhan-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/zhan-155-zui-xiao-zhan-jian-dan">
        </link>
        <updated>2019-12-29T04:28:33.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。<br>
push(x) -- 将元素 x 推入栈中。<br>
pop() -- 删除栈顶的元素。<br>
top() -- 获取栈顶元素。<br>
getMin() -- 检索栈中的最小元素。<br>
示例:<br>
MinStack minStack = new MinStack();<br>
minStack.push(-2);<br>
minStack.push(0);<br>
minStack.push(-3);<br>
minStack.getMin();   --&gt; 返回 -3.<br>
minStack.pop();<br>
minStack.top();      --&gt; 返回 0.<br>
minStack.getMin();   --&gt; 返回 -2.<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/min-stack<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>怎么说好呢，其实stack是基于的deque的，唯一的问题就是删除元素和增加元素这些是真的增删还是伪增删，伪增删就等于用一个全局下标值来处理，增删操作知识对这个下标值进行处理，而不用每次都对元素进行处理<br>
但是这一题给得示例太少了，特别是没有错误用例<br>
卧槽，才发现是常数时间内检索到最小元素的栈<br>
那需要用到额外的空间来维护最小序列了 push和pop的时候都可能需要改动最小值<br>
这一题就用到了 二分查找 35. 搜索插入位置</p>
<pre><code>class MinStack {
public:
    /** initialize your data structure here. */
   // MinStack() {
        stack&lt;int&gt; sta;
        vector&lt;int&gt; minv;
        int min=INT_MAX; //忘了 设置成INT_MIN
   // }
    
    void push(int x) {
        sta.push(x);
        min=x&lt;min?x:min;
        minv.insert(minv.begin()+binarysearch(x),x);
        
    }
    
    void pop() {
        int x=sta.top();
        sta.pop();
        minv.erase(minv.begin()+binarysearch(x));
        if(minv.empty())
            min=INT_MAX;
        else
            min=minv[0];
    }
    
    int top() {
        return sta.top();
    }
    
    int getMin() {
        return min;
    }
    
    int binarysearch(int x){
        if(minv.empty()) return 0; //注意为空的情况
        if(x&gt;minv.back()) return minv.size();
        int first=0,last=minv.size()-1,mid;
        while(first&lt;last){
            mid=first+(last-first)/2;
            if(minv[mid]==x)
                return mid;
            if(minv[mid]&lt;x)
                first=mid+1;
            else
                last=mid;
            
        }
        return first;
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj-&gt;push(x);
 * obj-&gt;pop();
 * int param_3 = obj-&gt;top();
 * int param_4 = obj-&gt;getMin();
 */
</code></pre>
<p>网友题解</p>
<blockquote>
<p>这道题的思想很简单：“以空间换时间”，使用辅助栈是常见的做法。<br>
思路分析：<br>
在代码实现的时候有两种方式：<br>
1、辅助栈和数据栈同步<br>
特点：编码简单，不用考虑一些边界情况，就有一点不好：辅助栈可能会存一些“不必要”的元素。<br>
2、辅助栈和数据栈不同步<br>
特点：由“辅助栈和数据栈同步”的思想，我们知道，当数据栈进来的数越来越大的时候，我们要在辅助栈顶放置和当前辅助栈顶一样的元素，这样做有点“浪费”。基于这一点，我们做一些“优化”，但是在编码上就要注意一些边界条件。<br>
（1）辅助栈为空的时候，必须放入新进来的数；<br>
（2）新来的数小于或者等于辅助栈栈顶元素的时候，才放入，特别注意这里“等于”要考虑进去，因为出栈的时候，连续的、相等的并且是最小值的元素要同步出栈；<br>
（3）出栈的时候，辅助栈的栈顶元素等于数据栈的栈顶元素，才出栈。<br>
总结一下：出栈时，最小值出栈才同步；入栈时，最小值入栈才同步。<br>
对比：个人觉得“同步栈”的方式更好一些，因为思路清楚，因为所有操作都同步进行，所以调试代码、定位问题也简单。“不同步栈”，虽然减少了一些空间，但是在“出栈”、“入栈”的时候还要做判断，也有性能上的消耗。<br>
方法一：辅助栈和数据栈同步<br>
参考代码 1：</p>
</blockquote>
<pre><code>import java.util.Stack;

public class MinStack {

    // 数据栈
    private Stack&lt;Integer&gt; data;
    // 辅助栈
    private Stack&lt;Integer&gt; helper;

    /**
     * initialize your data structure here.
     */
    public MinStack() {
        data = new Stack&lt;&gt;();
        helper = new Stack&lt;&gt;();
    }

    // 思路 1：数据栈和辅助栈在任何时候都同步

    public void push(int x) {
        // 数据栈和辅助栈一定会增加元素
        data.add(x);
        if (helper.isEmpty() || helper.peek() &gt;= x) {
            helper.add(x);
        } else {
            helper.add(helper.peek());
        }
    }

    public void pop() {
        // 两个栈都得 pop
        if (!data.isEmpty()) {
            helper.pop();
            data.pop();
        }
    }

    public int top() {
        if(!data.isEmpty()){
            return data.peek();
        }
        throw new RuntimeException(&quot;栈中元素为空，此操作非法&quot;);
    }

    public int getMin() {
        if(!helper.isEmpty()){
            return helper.peek();
        }
        throw new RuntimeException(&quot;栈中元素为空，此操作非法&quot;);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(1)，“出栈”、“入栈”、“查看栈顶元素”的操作不论数据规模多大，都只是有限个步骤，因此时间复杂度是：O(1)。<br>
空间复杂度：O(N)，这里 N 是读出的数据的个数。</p>
</blockquote>
<blockquote>
<p>方法二：辅助栈和数据栈不同步</p>
</blockquote>
<pre><code>import java.util.Stack;

public class MinStack {

    // 数据栈
    private Stack&lt;Integer&gt; data;
    // 辅助栈
    private Stack&lt;Integer&gt; helper;

    /**
     * initialize your data structure here.
     */
    public MinStack() {
        data = new Stack&lt;&gt;();
        helper = new Stack&lt;&gt;();
    }

    // 思路 2：辅助栈和数据栈不同步
    // 关键 1：辅助栈的元素空的时候，必须放入新进来的数
    // 关键 2：新来的数小于或者等于辅助栈栈顶元素的时候，才放入（特别注意这里等于要考虑进去）
    // 关键 3：出栈的时候，辅助栈的栈顶元素等于数据栈的栈顶元素，才出栈，即&quot;出栈保持同步&quot;就可以了

    public void push(int x) {
        // 辅助栈在必要的时候才增加
        data.add(x);
        // 关键 1 和 关键 2
        if (helper.isEmpty() || helper.peek() &gt;= x) {
            helper.add(x);
        }
    }

    public void pop() {
        // 关键 3：data 一定得 pop()
        if (!data.isEmpty()) {
            // 注意：声明成 int 类型，这里完成了自动拆箱，从 Integer 转成了 int，因此下面的比较可以使用 &quot;==&quot; 运算符
            // 参考资料：https://www.cnblogs.com/GuoYaxiang/p/6931264.html
            // 如果把 top 变量声明成 Integer 类型，下面的比较就得使用 equals 方法
            int top = data.pop();
            if(top == helper.peek()){
                helper.pop();
            }
        }
    }

    public int top() {
        if(!data.isEmpty()){
            return data.peek();
        }
        throw new RuntimeException(&quot;栈中元素为空，此操作非法&quot;);
    }

    public int getMin() {
        if(!helper.isEmpty()){
            return helper.peek();
        }
        throw new RuntimeException(&quot;栈中元素为空，此操作非法&quot;);
    }

}
</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(1)，“出栈”、“入栈”、“查看栈顶元素”的操作不论数据规模多大，都只有有限个步骤，因此时间复杂度是：O(1)。<br>
空间复杂度：O(N)，这里 NN 是读出的数据的个数。</p>
</blockquote>
<p>用一个栈实现：</p>
<blockquote>
<p>解法1：用两个栈实现最小栈功能<br>
一个栈s存放数据，另一个栈min存放前栈中最小的数据</p>
</blockquote>
<pre><code>class MinStack {
public:
    stack&lt;int&gt; s;//数据栈
    stack&lt;int&gt; min;//辅助栈
    /** initialize your data structure here. */
    MinStack() {
        
    }
    
    void push(int x) {
        s.push(x);
        if(min.empty()||x&lt;=min.top())
        {
            min.push(x);
        }
    }
    
    void pop() {
        if(s.top()==min.top())
            min.pop();
        s.pop();
    }
    
    int top() {
        return s.top();
    }
    int getMin() {
        return min.top();
    }
};
</code></pre>
<blockquote>
<p>解法2：一个栈实现<br>
栈中两个数据位合成一个单元，第一个数据位存放当前数据到末尾的最小值，第二个数据位存放当前数据。</p>
</blockquote>
<pre><code>class MinStack {
public:
    /** initialize your data structure here. */
    stack&lt;int&gt; s;
    MinStack() {
        
    }
    
    void push(int x) {
        if(s.empty())
        {
            s.push(x);
            s.push(x);
        }
        else
        {
            int temp=s.top();
            s.push(x);
            if(x&lt;temp)
            {
                s.push(x);
            }
            else
            {
                s.push(temp);
            }
        }
    }
    
    void pop() {
        s.pop();
        s.pop();
    }
    
    int top() {
        int temp=s.top();
        s.pop();
        int top=s.top();
        s.push(temp);
        return top;
    }
    
    int getMin() {
        return s.top();
    }
};
</code></pre>
<p>之前说过简单题不能只满足于解决问题，而是要多看思路，这道题便是这样，有很多很不错的网友思路，值得回头不断查看。</p>
]]></content>
    </entry>
</feed>