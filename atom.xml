<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-10-16T02:25:29.842Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[反向迭代器的insert与erase （insert不能直接使用反向迭代器）]]></title>
        <id>https://lixin-ee.github.io//post/fan-xiang-die-dai-qi-shi-wu-fa-jin-xing-insert-cha-ru-cao-zuo</id>
        <link href="https://lixin-ee.github.io//post/fan-xiang-die-dai-qi-shi-wu-fa-jin-xing-insert-cha-ru-cao-zuo">
        </link>
        <updated>2019-10-16T02:06:24.000Z</updated>
        <content type="html"><![CDATA[<p>问题：<br>
做题时对容器进行逆序对比，再进行插入操作然后报错了。</p>
<pre><code>if
(i==digits.rend())  
                digits.insert(digits.rend(),1); 
</code></pre>
<p>原因：<br>
反向迭代器是无法进行insert插入操作的， digits.insert(digits.rend(),1);是无法通过编译的，reverse iterator并不属于五种迭代器类型之一<br>
有些容器的成员函数只接受iterator类型的参数，所以如果你想要在ri所指的位置插入一个新元素，你不能直接这么做，因为vector的insert函数不接受reverse_iterator。如果你想要删除ri 所指位置上的元素也会有同样的问题。erase成员函数会拒绝reverse_iterator，坚持要求iterator。为了完成删除和一些形式的插入操作，你必须先通过base函数将reverse_iterator转换成iterator，然后用iterator来完成工作。</p>
<p>然后展开说一下吧<br>
ri<br>
1 2 3 4<br>
i<br>
如上简图所示，如果ri指向2，那么ri.base()也就是i会指向3（同理如果ri指向4，那么i应该是end()）<br>
所以对于insert操作的话，使用ri.base()是正确的的<br>
但是对于erase来说，是删除当前迭代器指向的元素，那就不对劲了，需要将--i，也就是--ri.base()</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math 66. 加一]]></title>
        <id>https://lixin-ee.github.io//post/math-66-jia-yi</id>
        <link href="https://lixin-ee.github.io//post/math-66-jia-yi">
        </link>
        <updated>2019-10-16T01:52:22.000Z</updated>
        <content type="html"><![CDATA[<p>难度：简单</p>
<pre><code>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。
最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。
你可以假设除了整数 0 之外，这个整数不会以零开头。

示例 1:
输入: [1,2,3]
输出: [1,2,4]
解释: 输入数组表示数字 123。
示例 2:
输入: [4,3,2,1]
输出: [4,3,2,2]
解释: 输入数组表示数字 4321。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/plus-one
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
</code></pre>
<p>这道题的难点在于：如果遇到个位为9的情况，需要置为0并向前进位，同时如果遇到全部位数为9的情况，则需要全部位数置为0，并在vector前面新增一位1。<br>
解决思路：单独判断特殊情况，以个位为9作为判断条件，不断向前递推直到遇到不为9的数，如果全部为9，则插入1并返回，其他情况可直接返回<br>
代码如下</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; plusOne(vector&lt;int&gt; digits) {
        bool flag=false;
        int len=digits.size();
        if(digits[len-1]==9){
            auto i=digits.rbegin();
            while(i&lt;digits.rend()&amp;&amp;*i==9){
                *i=0;
                ++i;
            }
            if(i==digits.rend())  
                digits.insert(digits.begin(),1); 
            else
                ++*i;
            return digits;
        }
        digits[len-1]+=1;
        return digits;
    }
};
</code></pre>
<p>其中遇到的难点和注意点：<br>
1.反向迭代器是无法进行insert插入操作的， digits.insert(digits.rend(),1);是无法通过编译的，reverse iterator并不属于五种迭代器类型之一<br>
2.<code>(i&lt;digits.rend()&amp;&amp;*i==9)</code>判断条件的先后顺序很重要，如果反过来的话就会造成解引用未知指针的危险操作。<br>
3.临时对象的创建 是在类型后面加上括号，括号内再加入初始值调用构造函数，<code>plusOne(vector&lt;int&gt; ( {1,2,3,4} ))</code></p>
<p>最后是网友题解：</p>
<blockquote>
<p>根据题意加一，没错就是加一这很重要，因为它是只加一的所以有可能的情况就只有两种：<br>
1.除 9 之外的数字加一；<br>
2.数字 9<br>
加一得十进一位个位数为 0 加法运算如不出现进位就运算结束了且进位只会是一。</p>
<p>所以只需要判断有没有进位并模拟出它的进位方式，如十位数加 11 个位数置为 00，如此循环直到判断没有再进位就退出循环返回结果。</p>
<p>然后还有一些特殊情况就是当出现 9999、999999 之类的数字时，循环到最后也需要进位，出现这种情况时需要手动将它进一位。</p>
</blockquote>
<pre><code>Java
class Solution {
    public int[] plusOne(int[] digits) {
        for (int i = digits.length - 1; i &gt;= 0; i--) {
            digits[i]++;
            digits[i] = digits[i] % 10;
            if (digits[i] != 0) return digits;
        }
        digits = new int[digits.length + 1];
        digits[0] = 1;
        return digits;
    }
}
</code></pre>
<p>优雅很多hhh，值得学习</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ C++ primer 第十二章 笔记+习题 12.1]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-er-zhang-bi-ji-xi-ti-121</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-er-zhang-bi-ji-xi-ti-121">
        </link>
        <updated>2019-10-16T01:25:19.000Z</updated>
        <content type="html"><![CDATA[<p>loading</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vptr指针[未阅读]]]></title>
        <id>https://lixin-ee.github.io//post/vptr-zhi-zhen-wei-yue-du</id>
        <link href="https://lixin-ee.github.io//post/vptr-zhi-zhen-wei-yue-du">
        </link>
        <updated>2019-10-15T12:19:55.000Z</updated>
        <content type="html"><![CDATA[<p>原文<a href="https://www.cnblogs.com/yangguang-it/p/6547314.html">c++多态之——vptr指针</a><br>
之前做过一个测试，在一个类中定义一个virtual修饰的函数时，sizeof这个类，发现类的大小多了恰好一个指针的字节大小，当初不明白，只是记住有这么一个特性。后来，发现它就是c++编译器给我们添加的vptr指针。</p>
<p>当类中声明虚函数时，编译器会在类中生成一个虚函数表；</p>
<p>虚函数表是一个存储成员函数指针的数据结构；</p>
<p>虚函数表是由编译器自动生成与维护的；</p>
<p>virtual成员函数会被编译器放入虚函数表中；</p>
<p>存在虚函数时，每个对象都有一个指向虚函数的指针（vptr指针）</p>
<p>在实现多态的过程中，父类和派生类都有vptr指针。</p>
<p>对象中的vptr指针什么时候被初始化：</p>
<p>对象在创建时，由编译器对vptr指针进行初始化；</p>
<p>只有当对象的构造完全结束后vptr的指向才最终决定下来；</p>
<p>父类对象的vptr指向父类的虚函数表，子类对象的vptr指向子类的虚函数表。</p>
<p>定义子类对象时，vptr先指向父类的虚函数表，在父类构造完成之后，子类的vptr才指向自己的虚函数表。（这也就是在父类或者子类的构造函数中调用虚成员函数不会实现多态的原因，这是一道面试题）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[const函数或const对象只能调用const函数 错误：对象包含与成员函数不兼容的类型限定符]]></title>
        <id>https://lixin-ee.github.io//post/const-han-shu-zhong-zhi-neng-diao-yong-const-han-shu-cuo-wu-dui-xiang-bao-han-yu-cheng-yuan-han-shu-bu-jian-rong-de-lei-xing-xian-ding-fu</id>
        <link href="https://lixin-ee.github.io//post/const-han-shu-zhong-zhi-neng-diao-yong-const-han-shu-cuo-wu-dui-xiang-bao-han-yu-cheng-yuan-han-shu-bu-jian-rong-de-lei-xing-xian-ding-fu">
        </link>
        <updated>2019-10-15T12:12:35.000Z</updated>
        <content type="html"><![CDATA[<p>情况：<br>
在bool compareIsbn(const Sales_data &amp;lhs,const Sales_data &amp;rhs)中调用bool compareISBN(Sales_Data &amp;lhs, Sales_Data &amp;rhs)<br>
错误：对象包含与成员函数不兼容的类型限定符<br>
原因：<br>
1）const对象只能调用const函数；<br>
2）如果const函数中不小心修改了类成员或者调用了非常量函数，编译器会找出这类错误。<br>
解决方法<br>
将compareISBN改成<br>
bool compareISBN(const Sales_Data &amp;lhs, const Sales_Data &amp;rhs)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[类成员函数的调用 错误invalid use of non-static member function ]]></title>
        <id>https://lixin-ee.github.io//post/lei-cheng-yuan-han-shu-de-diao-yong-cuo-wu-invalid-use-of-non-static-member-function</id>
        <link href="https://lixin-ee.github.io//post/lei-cheng-yuan-han-shu-de-diao-yong-cuo-wu-invalid-use-of-non-static-member-function">
        </link>
        <updated>2019-10-15T12:01:40.000Z</updated>
        <content type="html"><![CDATA[<p>原文链接<a href="https://www.cnblogs.com/scoyer/p/6533685.html">记一次C++的纠错过程</a><br>
经历和我一模一样，甚至于可能连题号都一致，我就不画蛇添足了，<br>
情况：向泛型函数提交自定义的比较大小函数，例如sort(begin(),end,compareIsbn)<br>
主要问题：报错 invalid use of non-static member function<br>
原因：不能直接使用指针来调用类成员函数，特别是在定义其他类成员函数的时候。因为代码中定义了类但<strong>并没有初始化这个类的成员函数</strong>。当你声明了具体的实例之后，一个<strong>实例调用构造函数才被初始化了</strong>，所以<strong>函数指针才能指向具体的类的成员函数</strong>。<br>
解决办法<br>
1.创建对象或临时对象<br>
2.那如果在定义中想要传一个成员函数指针给其他函数调用，这就要利用static对象的特性了，因为static的生存周期是从被构造出来到程序结束，也就是程序编译之后就被初始化好了。</p>
<p>下面为原文</p>
<p>事出的起因是我在leetcode刷着一道题，需要排序，于是我就自定义了一个比较函数，代码如下：</p>
<p>复制代码</p>
<pre><code>class Solution {
public:
  inline int digit(int x) {
    if (!x) return 10;
    int ret = 1;
    while (x) ret *= 10, x /= 10;
    return ret;
  }
  inline int cmp(int a, int b) {
    long long ab = 1LL * a * digit(b) + b, ba = 1LL * b * digit(a) + a;
    return ab &gt; ba;
  }
  string largestNumber(vector&lt;int&gt; nums) {
    sort(nums.begin(), nums.end(), Solution::cmp);
    string ret;
    char t[100];
    for (int i = 0; i &lt; nums.size(); i++) {
      if (ret == &quot;0&quot; &amp;&amp; !nums[i]) continue;
      sprintf(t, &quot;%d&quot;, nums[i]);
      ret = ret + t;
    }
    return ret;
  }
};
</code></pre>
<p>结果这个函数死活通过不了编译，乱改乱改还出现了invalid use of non-static member function 问题。看来成员函数不让这么弄，翻阅C++大师Stanley Lippman的Essential C++找一下成员函数的相关用法，还参考了一些技术博客，原来是C++的语法不过关啊！！/哭</p>
<p>下面回顾一下我纠错的过程，先看下面一段代码熟悉一下怎么调用普通的函数指针：</p>
<pre><code>/*zhen hao*/
#include &lt;bits/stdc++.h&gt;
using namespace std;

int F(double x) { return int(x); }

int G(double x) { return int(x) + 1; }

int main() {
  int (*p1)(double) = &amp;F;
  int (*p2)(double) = &amp;G;
  cout &lt;&lt; (*p1)(1) &lt;&lt; endl;
  cout &lt;&lt; (*p2)(1) &lt;&lt; endl;
  return 0;
}
</code></pre>
<p>如果用指针指向类的成员函数的时候就稍有不同，试着根据自己的想法改一下，主要是加上类的scope运算符限定一下函数的范围：</p>
<pre><code>/*zhen hao*/
#include &lt;bits/stdc++.h&gt;
using namespace std;

class C {
public:
  C() {}
  int F(double x) { return int(x); }
  int G(double x) { return int(x) + 1; }
};

int main() {
  int (C::*p1)(double) = &amp;C::F; //编译通过
  int (C::*p2)(double) = &amp;C::G; //编译通过
  cout &lt;&lt; (C::*p1)(1) &lt;&lt; endl; //error: expected unqualified-id before '*' token
  cout &lt;&lt; (C::*p2)(1) &lt;&lt; endl; //error: expected unqualified-id before '*' token
  return 0;
}
</code></pre>
<p>想当然以为简单改一下可以，然而编译不通过问题出在哪里呢？编译器报的错误是什么意思？</p>
<p>（1）先简单解释一下这个qualified是什么意思？</p>
<p>单词的意思是有限制的，也就是一些有范围的变量，例如下面的代码：</p>
<pre><code>1 #include &lt;iostream&gt;
2 int main()  {
3    std::cout&lt;&lt;&quot;Hello world!&quot;&lt;&lt;std::endl; //cout和endl都是qualified name，因为他们都限定在std这个明明空间上。
4    return 0;
5 }
</code></pre>
<p>值得注意的是，如果我们之间在代码上指定命名空间的话，例如using namespace std，那么cout和endl就是unqualified name了。</p>
<p>（2）另外id的全称是identifier，即标识符。</p>
<p>所以上述编译器希望这是一个qualified-id，也就是希望p1，p2是一个不需要用C::限定的变量，去掉之后仍然报错，报的错误是<code>invalid use of 'unary *' on pointer to member</code>，不能够用指针指着成员直接使用。</p>
<p>书上指出，pointer to member function和pointer to function的不同点是，前者必须通过同一类对象加以调用，而该对象便是此member function内的this指针所指之物。</p>
<p>所以以下用法才是正确的：</p>
<pre><code>/*zhen hao*/
#include &lt;bits/stdc++.h&gt;
using namespace std;

class C {
public:
  C() {}
  int F(double x) { return int(x); }
  int G(double x) { return int(x) + 1; }
};

int main() {
  int (C::*p1)(double) = &amp;C::F;
  int (C::*p2)(double) = &amp;C::G;
  C *c = new C();
  cout &lt;&lt; (c-&gt;*p1)(1) &lt;&lt; endl;
  cout &lt;&lt; (c-&gt;*p2)(1) &lt;&lt; endl;
  return 0;
}
</code></pre>
<p>原来我们需要的是一个实例来调用成员函数指针。</p>
<p>到这里就要问为什么呢？</p>
<p>因为代码中定义了C类并没有初始化这个类的成员函数。当你声明了具体的实例之后，一个实例调用构造函数被初始化了，所以函数指针才能指向具体的类的成员函数。那如果想要传一个成员函数指针给其他函数调用该怎么做？这就要利用static对象的特性了，因为static的生存周期是从被构造出来到程序结束，也就是程序编译之后就被初始化好了。</p>
<p>所以我们将上述代码改一下就能改正错误的代码了：</p>
<pre><code>/*zhen hao*/
#include &lt;bits/stdc++.h&gt;
using namespace std;

class C {
public:
  C() {}
  static int F(double x) { return int(x); }
  static int G(double x) { return int(x) + 1; }
};

int main() {
  int (*p1)(double) = &amp;C::F;
  int (*p2)(double) = &amp;C::G;
  cout &lt;&lt; (*p1)(1) &lt;&lt; endl;
  cout &lt;&lt; (*p2)(1) &lt;&lt; endl;
  return 0;
}
</code></pre>
<p>用static关键字修饰之后的成员函数就像普通函数一样可以传给别的函数做参数，使用也像普通函数一样。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于istringstream等输入流]]></title>
        <id>https://lixin-ee.github.io//post/guan-yu-istringstream-deng-shu-ru-liu</id>
        <link href="https://lixin-ee.github.io//post/guan-yu-istringstream-deng-shu-ru-liu">
        </link>
        <updated>2019-10-15T11:32:18.000Z</updated>
        <content type="html"><![CDATA[<p>今天做题时<a href="https://lixin-ee.github.io/post/math-165-bi-jiao-ban-ben-hao/">版本号比较</a>遇到一个题解</p>
<pre><code>class Solution {
public:
    int compareVersion(string version1, string version2) {
        char c;
        int v1,v2;
        istringstream its1(version1);
        istringstream its2(version2);
        
        while(bool(its1&gt;&gt;v1) + bool(its2&gt;&gt;v2)){
            if(v1&gt;v2) return 1;
            if(v1&lt;v2) return -1;
            
            v1=0;
            v2=0;
            its1&gt;&gt;c;
            its2&gt;&gt;c;
            
        }
        
        return 0;
    }
};
</code></pre>
<p>输入是 输入: version1 = &quot;7.5.2.4&quot;, version2 = &quot;7.5.3&quot;<br>
一开始百思不得其解，为何会自动以点号为分割？同时为何会自动去掉前置0？<br>
受到评论指引，才发现原来v1和v2可是int类型！<br>
所以在这里可以看出，isrtringstream或者说输入流，都会按照赋值的类型来读取分割，比如如果是赋值给float，则会读入第一个点号，而忽略第二个点号。<br>
而istringstream的string意为将一个string作为读入字符串（类似于cin的缓冲区），而不是说istringstream只能赋值给string。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MATH 165. 比较版本号]]></title>
        <id>https://lixin-ee.github.io//post/math-165-bi-jiao-ban-ben-hao</id>
        <link href="https://lixin-ee.github.io//post/math-165-bi-jiao-ban-ben-hao">
        </link>
        <updated>2019-10-15T10:49:02.000Z</updated>
        <content type="html"><![CDATA[<p>难度：中等</p>
<blockquote>
<p>比较两个版本号 version1 和 version2。<br>
如果 version1 &gt; version2 返回 1，如果 version1 &lt; version2 返回 -1， 除此之外返回 0。<br>
你可以假设版本字符串非空，并且只包含数字和 . 字符。<br>
 &gt; . 字符不代表小数点，而是用于分隔数字序列。<br>
例如，2.5 不是“两个半”，也不是“差一半到三”，而是第二版中的第五个小版本。<br>
你可以假设版本号的每一级的默认修订版号为 0。例如，版本号 3.4 的第一级（大版本）和第二级（小版本）修订号分别为 3 和 4。其第三级和第四级修订号均为 0。</p>
<p>示例 1:<br>
输入: version1 = &quot;0.1&quot;, version2 = &quot;1.1&quot;<br>
输出: -1<br>
示例 2:<br>
输入: version1 = &quot;1.0.1&quot;, version2 = &quot;1&quot;<br>
输出: 1<br>
示例 3:<br>
输入: version1 = &quot;7.5.2.4&quot;, version2 = &quot;7.5.3&quot;<br>
输出: -1<br>
示例 4：<br>
输入：version1 = &quot;1.01&quot;, version2 = &quot;1.001&quot;<br>
输出：0<br>
解释：忽略前导零，“01” 和 “001” 表示相同的数字 “1”。<br>
示例 5：<br>
输入：version1 = &quot;1.0&quot;, version2 = &quot;1.0.0&quot;<br>
输出：0<br>
解释：version1 没有第三级修订号，这意味着它的第三级修订号默认为 “0”。<br>
 <br>
提示：<br>
版本字符串由以点 （.） 分隔的数字字符串组成。这个数字字符串可能有前导零。<br>
版本字符串不以点开始或结束，并且其中不会有两个连续的点。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/compare-version-numbers<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>一开始的想法是先分析一下难点<br>
1.靠点号分割的话，位数不同<br>
2.会有前导0<br>
然后思考一下处理方式<br>
1.利用find函数进行点号分割，分割之后可以当场进行对比，或者存进容器里面进行对比。前者需要对首先对长度进行对比，后者的话可以通过push_back来补充位数<br>
2.前导0的处理方法 一个是find函数检测并去掉多余的0，一个是转化为int自动去掉，最后一个则是在对应的数前面补0，比如02和1对比，就向1补0，使得02和01对比。<br>
最后为了代码的可读性，我选择了vector补位+补0</p>
<pre><code>class Solution {
public:
    int compareVersion(string version1, string version2) {
        vector&lt;string&gt; v1,v2;
        split(version1,v1);
        split(version2,v2);
        int len=0;
        if(v1.size()&gt;v2.size()){
            len=v1.size()-v2.size();
            while(len)
                --len,v2.push_back(&quot;0&quot;);
        }
        else{
            len=v2.size()-v1.size();
            while(len)
                --len,v1.push_back(&quot;0&quot;);
        }
        for(int i=0;i&lt;v1.size();++i ){
            if(v1[i].size()&gt;v2[i].size()){
                 len=v1[i].size()-v2[i].size();;
                 while(len)
                    --len,v2[i]=&quot;0&quot;+v2[i];
             }
              else{
                 len=v2[i].size()-v1[i].size();
                 while(len)
                    --len,v1[i]=&quot;0&quot;+v1[i];
             }
            if(v1[i]&gt;v2[i])
                return 1;
            else if (v1[i]&lt;v2[i])
                return -1;
        }
            
          return 0;        
    }
    
    void split(string &amp;version,vector&lt;string&gt; &amp;v){
        char comma='.';
        for(int i=0;i&lt;version.size();){
            int j=version.find(comma,i);
            if(j==string::npos){
                v.push_back(version.substr(i,version.size()-i));
                break;
            }              
            v.push_back(version.substr(i,j-i));
            i=j+1;
        }
    }   
};
</code></pre>
<p>这道题有个很明显的问题是代码比较臃肿，重复代码太多，所以我把分割操作合成一个函数了，可读性明显高了很多<br>
然后高赞网友题解都类似，都是点号分解<br>
最后是有个比较秀的操作：</p>
<pre><code>class Solution {
public:
    int compareVersion(string version1, string version2) {
        char c;
        int v1,v2;
        istringstream its1(version1);
        istringstream its2(version2);
        
        while(bool(its1&gt;&gt;v1) + bool(its2&gt;&gt;v2)){
            if(v1&gt;v2) return 1;
            if(v1&lt;v2) return -1;
            
            v1=0;
            v2=0;
            its1&gt;&gt;c;
            its2&gt;&gt;c;
            
        }
        
        return 0;
    }
};
</code></pre>
<p>注意是把 istringstream 强行输入赋值给int，此时输入流会强制读取一个符合int格式的string值，所以输入流会以点号为结束符，并且将其自动转化为int类型，也就同时完成了分割和去掉前置0两个任务，所以代码非常简单，只是需要仔细研究一下才好。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第十一章 笔记+习题 11.3-11.4]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-yi-zhang-bi-ji-xi-ti-113-114</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-yi-zhang-bi-ji-xi-ti-113-114">
        </link>
        <updated>2019-10-14T03:06:22.000Z</updated>
        <content type="html"><![CDATA[<p>11.3关联容器操作<br>
map的value_type为<code>pair&lt;const key_type,mapped_type&gt;</code><br>
我们不能改变pair中的关键字，因此这些pair的关键字部分是const的（set中的关键字也是const的）<br>
只有map类型才能定义mapped_type</p>
<p>11.3.1关联容器迭代器<br>
一个map 的value_type是一个pair，我们可以改变pair的值，但是不能改变关键字成员的值<br>
虽然map和set类型同时定义了iterator和const_iterator两种类型，但两种类型都只允许只读访问set中的元素，<strong>set的关键字是const的，set的迭代器也是const的</strong>。<br>
map和set类型都支持表9.2（p295）中的begin和end操作<br>
当时用一个迭代器遍历一个map、multimap、set或multiset时，迭代器按关键字升序遍历元素<br>
我们通常<strong>不对关联容器使用泛型算法</strong>，因为关键字是const，不能将关联容器传递给修改或重排容器元素的算法<br>
关联容器中的元素不<strong>能通过它们的关键字进行快速查找</strong>，所以使用关联容器定义的专用的find成员会比调用泛型find快得多<br>
在实际编程中，如果我们真要对一个关联容器使用算法，要么将它当做一个<strong>源序列</strong>，要么当做一个<strong>目的位置</strong><br>
迭代器的类型需要在iterator或者const_iterator加上类类型，比如map&lt;const string, size_t&gt;::const_iterator<br>
map和set中的 key_type其实都会自动加上const但是在声明类型时不需要加上，比如Sales_Data，除非是像map_it那样显式声明。只需要注意使用auto或者decltype时会自动加上const<br>
关联容器的迭代器时双向迭代器（由红黑树决定），只能进行相等不等的比较，无法进行小于的比较！！！</p>
<p>习题11.15<br>
value_type为 pair<code>&lt;int,vector&lt;int&gt;&gt;</code> key_type为int mapped_type为vector<br>
习题11.16</p>
<pre><code>	map&lt;string, int&gt; map_si{ {&quot;123&quot;,123} };
	(*map_si.begin()).second = 321;
</code></pre>
<p>注意的点：map的迭代器不能直接解引用就赋值，还是需要.second，然后第二个调用前的括号必不可少，第一个调用则不需要括号<br>
习题11.17<br>
（1）不合法，显示error type，因为关联容器的迭代器时const的，不能进行写操作<br>
（2）同上<br>
（3）（4）合法<br>
习题11.18<br>
注意不是<code>const_iterator&lt;map&lt;const string ,size_t&gt;&gt;</code>！<br>
而是<code>map&lt;const string, size_t&gt;::const_iterator</code><br>
需要在iterator或者const_iterator加上类类型， 比如string、map、vector等等<br>
习题11.19<br>
<code>multiset&lt;Sales_Data, bool(*)(const Sales_Data &amp;lhs, const Sales_Data &amp;rhs)&gt;::iterator mi=bookstore.begin();</code><br>
注意 map和set中的 key_type其实都会自动加上const但是在声明类型时不需要加上，比如Sales_Data，除非是像map_it那样显式声明。只需要注意使用decltype时会自动加上const，但是auto不会（auto忽略顶层const）</p>
<p>11.3.2添加元素<br>
向map和set插入一个已存在的元素没有任何影响<br>
insert有两个版本，分别接受一对迭代器，或是一个初始化器列表，对于一个给定的关键字，只有第一个带此关键字的元素才会被插入到容器中（<strong>对于map很重要</strong>，比如{{1,a}{1,b}}两者之间谁能插入）<br>
insert和emplace的返回值依赖于容器的类型和参数，对于不包含重复关键字的容器返回一个pair，告诉我们插入操作是否成功。返回的pair的first成员是一个迭代器，指向具有给定关键字（插入值）的元素，second成员是一个bool值，指出元素是插入成功还是已经存在于容器中。如果关键字插入失败，返回值为false，否则返回为true<br>
对于允许重复关键字的容器，接受单个元素的insert操作返回一个指向新元素的迭代器，这里无须返回一个bool值</p>
<p>习题11.20</p>
<pre><code>int main()
{
	map&lt;string, size_t&gt; word_count;
	string word;
	while (cin &gt;&gt; word)
		if (!word_count.insert(make_pair(word, 1)).second)
			++word_count[word];
}
</code></pre>
<p>insert更加容易编写阅读，因为下标运算符会强行将元素添加进去<br>
习题11.21<br>
将单词插入到map中，并在键值中记录单词出现的次数<br>
习题11.22<br>
参数类型<code>pair&lt;const string,vector&lt;int&gt;&gt;</code><br>
返回类型<code>pair&lt;map&lt;string,vector&lt;int&gt;&gt;::iterator,bool&gt;</code><br>
习题11.23</p>
<pre><code>int main()
{
	multimap&lt;string, vector&lt;string&gt;&gt; map_name;
	string first_name, last_name;
	while (cin) {
		cin &gt;&gt; first_name &gt;&gt; last_name;	
		map_name.insert({ first_name,{ last_name } });
	}
}
</code></pre>
<p>11.3.3删除新元素<br>
关联容器定义有三个版本的erase<br>
注意c.erase(b,e)不包括e 是左闭右开区间 insert中也是<br>
erase可以接受一个key_type参数，此版本删除所有匹配给定关键字的元素，返回实际删除的元素的数量</p>
<p>11.3.4map的下标操作<br>
map和unordered_map提供下标运算符和对应的at函数，返回的是second值<br>
set类型不支持下标和at()（或者说不需要）<br>
multimap和unordered_map不支持下标操作，因为有多个值与一个关键字相关联<br>
map下标运算符接受一个索引，获取与此关键字相关联的值，但是注意！！！如果关键字并不在map，会为它创建一个元素插入map中，并对关联值进行值初始化<br>
对关键字会强行加上顶层const<br>
由于下标运算符可能插入一个新元素，所以只可以对非const的map使用下标操作<br>
与vector和string不同，map下标运算符返回的类型与解引用map迭代器返回的类型不同，下标操作得到mapped_type对象，解引用迭代器得到一个value_type对象</p>
<p>习题11.24<br>
如果m中有关键字0，则将second改成1，否则向m插入{0，1}<br>
习题11.25<br>
vector的下标必须先构造，否则就是非法访问<br>
习题11.26<br>
map&lt;string,int&gt;中，下标操作的类型必须是string，返回类型是int，亦即key_type对其执行下标操作，mapped_type为其返回类型</p>
<p>11.3.5访问元素<br>
使用下标操作有一个严重的副作用，如果关键字还未在map中，下标操作会插入一个具有给定关键字的元素<br>
find bound都是返回迭代器<br>
使用find就可以值检查给定关键字是否在map中<br>
multimap和multiset中具有相同关键字的元素在容器中会相邻存储，需要配合cout和find使用（find一次只能找到一个！！！）<br>
lower_bound和upper_bound这两个操作都接受一个关键字，返回一个迭代器。lower_bound返回指向第一个给定关键字的迭代器，upper_bound返回指向最后一个匹配给定关键字的元素之后的位置的迭代器。如果寻找不到，则返回相同迭代器，指向不影响排序的关键字插入位置<br>
equal_range接受一个关键字，返回一个迭代器pair，若关键字存在，则第一个迭代器指向第一个匹配的元素，第二个迭代器指向最后一个匹配元素之后的位置。如果不存在，则指向相同位置（亦即返回左闭右开区间）</p>
<p>习题11.27<br>
需要计算相同元素的数量时使用count，需要判断元素是否存在时使用find<br>
习题11.28<br>
<code>map&lt;string,vector&lt;int&gt;&gt;::iterator ite;</code><br>
习题 11.29<br>
upper和lower返回同一个值，指向不影响排序的关键字插入位置<br>
equal_range如果不存在，则返回一对指向相同位置迭代器的pair<br>
习题11.30<br>
pos是一个pair 里面是一对迭代器，first是左边迭代器，second则是这个迭代器的值<br>
习题11.31</p>
<pre><code>int main()
{
	multimap&lt;string, string&gt; multim{ {&quot;123&quot;,&quot;456&quot;} ,{ &quot;123&quot;,&quot;456&quot; } ,{ &quot;123&quot;,&quot;456&quot; } ,{ &quot;123&quot;,&quot;456&quot; } };
	string name=&quot;123&quot;, product;
	if (multim.find(name) != multim.end())
		multim.erase(name);
	cout &lt;&lt; multim.empty();
}
</code></pre>
<p>习题11.32</p>
<pre><code>int main()
{
	multimap&lt;string, string&gt; multim{ {&quot;123&quot;,&quot;1&quot;} ,{ &quot;123&quot;,&quot;2&quot; } ,{ &quot;456&quot;,&quot;1&quot; } ,{ &quot;123&quot;,&quot;1&quot; } };
	string name=&quot;123&quot;, product;
	for (auto left = multim.begin(); left != multim.end();) {
		auto right = multim.upper_bound((*left).first);
		cout &lt;&lt; (*left).first &lt;&lt; &quot; &quot;;
		while (left != right) {
			cout &lt;&lt; (*left).second &lt;&lt; &quot; &quot;;
			++left;
		}
		cout &lt;&lt; endl;
	}
}
</code></pre>
<p>习题感悟：关联容器的迭代器时双向迭代器（由红黑树决定），只能进行相等不等的比较，无法进行小于的比较！！！</p>
<p>11.3.6一个单词转换map<br>
习题11.33<br>
直接仿真了书中代码hhh<br>
习题11.34<br>
如果没找到的话反而会将当前关键值插入map，并且值为空<br>
习题11.35<br>
如果有重复关键值，则只保存最早的一个，否则就不断更新，无重复关键值的话无差别<br>
习题11.36<br>
不影响，因为对value.size()进行了判断，如果只要空格的话是会报错的</p>
<p>11.4无序容器<br>
注意<strong>顺序容器对应无序容器，关联容器不等同于无序容器</strong><br>
新标准定义了4个无序关联容器，无序容器不是使用比较运算符来组织元素，而是使用一个哈希函数，和关键字类型的==运算符<br>
如果关键字类型固有就是无序的，或者性能测试发现问题可以用哈希技术解决，就可以使用无序容器<br>
无序容器提供了与有序容器相同的操作（find、insert等），所以unordered_map和unordered_set也可以使用这些操作<br>
无序容器也有允许重复关键字的版本<br>
<strong>通常可以用一个无序容器替换对相应的有序容器，反之亦然</strong><br>
无序容器在存储组织上为<strong>一组桶</strong>，每个桶保存零个或多个元素，无序容器使用一个哈希函数将元素映射到桶，容器首先计算元素的哈希值，并将<strong>具有一个特定哈希值的所有元素都保存在相同的桶中</strong>，所有具有相同关键字的元素都会在同一个桶中，因此无序容器的性能依赖于<strong>哈希函数的质量和桶的数量和大小</strong><br>
对于相同的参数，哈希函数总是产生相同的结果<br>
将不同关键字映射到相同的桶也是允许的，当一个桶保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个</p>
<p>默认情况下无序容器使用关键字类型的==运算符来比较元素，还是用一个hash&lt;key_type&gt;类型来生成每个元素的哈希值，标准库为内置类型包括指针提供了hash模板</p>
<p>习题11.37<br>
无序版本优势：当容器中key没有明显的顺序关系时更有用,且不需要耗费多余的时间来维护容器中的key序列<br>
有序版本优势：当容器中key有明显的顺序关系时更有用,且我们不需要考虑排序问题,容器自动维护序列(字典序)<br>
习题11.38</p>
<pre><code>int main()
{
	unordered_map&lt;string, size_t&gt; word_count;
	string word;
	while (cin &gt;&gt; word)
		if (!word_count.insert(make_pair(word, 1)).second)
			++word_count[word];
	for (const auto &amp;w : word_count)
		cout &lt;&lt; w.first &lt;&lt; &quot; &quot; &lt;&lt; w.second &lt;&lt; endl;
}
</code></pre>
<p>通常可以用一个无序容器替换对相应的有序容器，反之亦然，内部的处理方式不同，外部的操作还是大同小异</p>
<p>习题感悟<br>
迭代器的类型需要在iterator或者const_iterator加上类类型， 比如string、map、vector等等<br>
map和set中的 key_type其实都会自动加上const但是在声明类型时不需要加上，比如Sales_Data，除非是像map_it那样显式声明。只需要注意使用decltype时会自动加上const，但是auto不会（auto忽略顶层const）<br>
关联容器的迭代器时双向迭代器（由红黑树决定），只能进行相等不等的比较，无法进行小于的比较！！！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math 7. 整数反转]]></title>
        <id>https://lixin-ee.github.io//post/math-7-zheng-shu-fan-zhuan</id>
        <link href="https://lixin-ee.github.io//post/math-7-zheng-shu-fan-zhuan">
        </link>
        <updated>2019-10-14T02:40:28.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<p>示例 1:<br>
输入: 123<br>
输出: 321<br>
 示例 2:<br>
输入: -123<br>
输出: -321<br>
示例 3:<br>
输入: 120<br>
输出: 21<br>
注意:<br>
假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 <code>[−2^31,  2^31 − 1]</code>。请根据这个假设，如果反转后整数溢出那么就返回 0。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/reverse-integer<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题的难处在于<br>
1.负数的处理，并且负数能表示的位置比正数多一位<br>
2.末尾0的处理，反转后需要去除多余的0</p>
<p>其实主要就两种方法，一种是整数的整十除法，另一种就是转化为字符串进行操作。我偷懒就使用了字符串的方法，反转、判断溢出和对末尾0的处理方便很多，但是对于负数的处理比较麻烦，需要将-2^31单独判断一次。<br>
代码如下：</p>
<pre><code>class Solution {
public:
    int reverse(int x) {
        bool neg=false;
        if(x==-2147483648)
            return 0;
        if(x&lt;0){
            neg=true;
            x=-x;
        }
        string num_s=to_string(x);
        auto left=num_s.begin();
        auto right=num_s.end()-1;
        while(left&lt;right)
            iter_swap(left++,right--);
        if(num_s.size()==10){
            if(neg){
                 if(num_s&gt;&quot;2147483648&quot;)
                    return 0;
            }     
            else{
                if(num_s&gt;&quot;2147483647&quot;)
                    return 0;
            }           
        }        
        x=stoi(num_s);
        if(neg)
            x=-x;
        return x;
    }
};
</code></pre>
<p>可以看到代码不够优雅啊，而且其实字符串和整数的转换是需要比较多的库函数的。<br>
接下来看看官方题解：</p>
<blockquote>
<p>方法：弹出和推入数字 &amp; 溢出前进行检查<br>
思路<br>
我们可以一次构建反转整数的一位数字。在这样做的时候，我们可以预先检查向原整数附加另一位数字是否会导致溢出。</p>
<p>算法<br>
反转整数的方法可以与反转字符串进行类比。<br>
我们想重复“弹出” x 的最后一位数字，并将它“推入”到 rev 的后面。最后，rev 将与 x 相反。<br>
要在没有辅助堆栈 / 数组的帮助下 “弹出” 和 “推入” 数字，我们可以使用数学方法。</p>
</blockquote>
<pre><code>//pop operation:
pop = x % 10;
x /= 10;

//push operation:
temp = rev * 10 + pop;
rev = temp;
</code></pre>
<blockquote>
<p>但是，这种方法很危险，因为当 temp=rev⋅10+pop 时会导致溢出。<br>
幸运的是，事先检查这个语句是否会导致溢出很容易。<br>
为了便于解释，我们假设 rev 是正数。<br>
如果 temp=rev⋅10+pop 导致溢出，那么一定有rev≥ INTMAX/10<br>
如果 rev&gt; INTMAX/10，那么temp=rev⋅10+pop 一定会溢出。<br>
如果 rev== INTMAX/10，那么只要 pop&gt;7，temp=rev⋅10+pop 就会溢出。<br>
当 rev 为负时可以应用类似的逻辑。</p>
</blockquote>
<pre><code>class Solution {
public:
    int reverse(int x) {
        int rev = 0;
        while (x != 0) {
            int pop = x % 10;
            x /= 10;
            if (rev &gt; INT_MAX/10 || (rev == INT_MAX / 10 &amp;&amp; pop &gt; 7)) return 0;
            if (rev &lt; INT_MIN/10 || (rev == INT_MIN / 10 &amp;&amp; pop &lt; -8)) return 0;
            rev = rev * 10 + pop;
        }
        return rev;
    }
};
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(log(x))，x 中大约有log_10(x) 位数字。<br>
空间复杂度：O(1)</p>
</blockquote>
]]></content>
    </entry>
</feed>