<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-10-12T03:16:50.589Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[字符串 13. 罗马数字转整数]]></title>
        <id>https://lixin-ee.github.io//post/zi-fu-chuan-13-luo-ma-shu-zi-zhuan-zheng-shu</id>
        <link href="https://lixin-ee.github.io//post/zi-fu-chuan-13-luo-ma-shu-zi-zhuan-zheng-shu">
        </link>
        <updated>2019-10-12T01:38:42.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。<br>
字符          数值<br>
I             1<br>
V             5<br>
X             10<br>
L             50<br>
C             100<br>
D             500<br>
M             1000<br>
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。<br>
通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：<br>
I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 <br>
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>
给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<p>示例 1:<br>
输入: &quot;III&quot;<br>
输出: 3<br>
示例 2:<br>
输入: &quot;IV&quot;<br>
输出: 4<br>
示例 3:<br>
输入: &quot;IX&quot;<br>
输出: 9<br>
示例 4:<br>
输入: &quot;LVIII&quot;<br>
输出: 58<br>
解释: L = 50, V= 5, III = 3.<br>
示例 5:<br>
输入: &quot;MCMXCIV&quot;<br>
输出: 1994<br>
解释: M = 1000, CM = 900, XC = 90, IV = 4.</p>
</blockquote>
<p>这道题一开始还有蛮波折的，我一开始的想法是使用switch，然后两位两位地检测，但是每次只递增一位<br>
然后实现的时候发现会略麻烦，因为第一位和最后一位会比较难处理。<br>
然后突然想到一个问题，如果出现“IXL”这种情况怎么破？，既是IX又是XL？<br>
果断去评论区看看，结果被强行剧透了，可以直接使用map记录相应值，然后检测前一个值是否小于后一个值，如果是的话就需要减去。然后关于IXL这种情况的话，在罗马数字里面是不会出现这种情况的，然后测试用例中也都是正确的罗马数字案例。。。leetcode的题的质量还是有待提高啊。<br>
最后给出的代码如下：</p>
<pre><code>class Solution {
public:
    int romanToInt(string s) {
        int res=0;
        map&lt;char,int&gt; roman {{'I',1},{'V',5},{'X',10},{'L',50},{'C',100},{'D',500},{'M',1000}};
        int temp=0;
        for(int i=0;i&lt;s.size();++i){
            res+=roman[s[i]];
            if(roman[s[i]]&gt;temp)
                res-=2*temp;
            temp=roman[s[i]];
        }
        return res;     
    }
};
</code></pre>
<p>然后看一下网友代码，基本是和我前一种想法相符，使用switch或者map来进行两位字符的匹配，但是最简单还是上述的方法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ C++ primer 第十章 笔记+习题 10.3-10.6]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-zhang-bi-ji-xi-ti-103-106</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-zhang-bi-ji-xi-ti-103-106">
        </link>
        <updated>2019-10-11T09:04:57.000Z</updated>
        <content type="html"><![CDATA[<p>（艹忘了保存，再来一遍）快半个月没写c++了，因为国庆假期+不停地汇报</p>
<p>10.4 再探迭代器<br>
10.4.1插入迭代器<br>
只有在容器支持push_front（push_back）的情况下我们才可以使用front_inserter（back_inserter）。<br>
调用it = inserter（c，iter）得到一个插入迭代器it，然后通过*it = val；赋值<br>
front_inserter会把插入元素序列顺序颠倒过来，inserter和back_inserter就不会<br>
注意，insert返回指向新元素的迭代器，inserter则返回同一个迭代器</p>
<p>习题10.26<br>
inserter可以在特定位置插入，需要两个参数<br>
back_inserter只能在容器的尾部插入，只需要一个参数<br>
front_inserter只能在容器的首部插入，只需要一个参数<br>
习题10.27</p>
<pre><code>int main()
{
	vector&lt;int&gt; vi{ 1,1,2,3,3,4,5,6,7,8,9 };
	list&lt;int&gt; li;
	unique_copy(vi.begin(), vi.end(),inserter(li,li.begin()));
	for (auto i : li)
		cout &lt;&lt; i &lt;&lt; endl;
}
</code></pre>
<p>注意，copy后缀的函数都需要一个插入迭代器作为参数，而不是普通的迭代器。然后unique只能检测相邻的重复元素。<br>
习题10.28</p>
<pre><code>int main()
{
	vector&lt;int&gt; vi{ 1,2,3,4,5,6,7,8,9 };
	deque&lt;int&gt; vii;
	copy(vi.begin(), vi.end(), inserter(vii, vii.begin()));
	for (auto i : vii)
		cout &lt;&lt; i &lt;&lt;&quot; &quot;;
	cout &lt;&lt; endl;
	deque&lt;int&gt; vib;
	copy(vi.begin(), vi.end(), back_inserter(vib));
	for (auto i : vib)
		cout &lt;&lt; i &lt;&lt; &quot; &quot;;
	cout &lt;&lt; endl;
	deque&lt;int&gt; vif;
	copy(vi.begin(), vi.end(), front_inserter(vif));
	for (auto i : vif)
		cout &lt;&lt; i &lt;&lt; &quot; &quot;;
	cout &lt;&lt; endl;
}
</code></pre>
<p>vector、string等容器都无法使用 front_inserter</p>
<p>10.4.2iostream迭代器<br>
iostream类型不是容器，但也可以有流迭代器<br>
当创建一个流迭代器时，必须指定迭代器将要读写的对象类型<br>
当创建一个istream_iterator时，可以把它绑定到一个流，也可以让他默认初始化，创建一个可以用作尾后值的迭代器<br>
可以用已绑定流的istream_iterator和默认初始化的istream_iterator（<strong>尾后迭代器</strong>）对比用作判断流是否读取完成的条件<br>
对于一个绑定到流的迭代器，一旦遇到<strong>文件尾或者IO错误</strong>，迭代器的值就与<strong>尾后迭代器相等</strong><br>
当我们将istream_iterator绑定到一个流时，标准库并不保证迭代器立即从流读取数据，具体实现可以推迟从流中读取数据，直到我们使用迭代器时才真正读取<br>
与istream_iterator不同，ostream_iterator必须绑定到一个指定的流，不允许空的或表示尾后位置的ostream_iterator<br>
运算符*和++实际上对ostream_iterator对象不做任何事情</p>
<p>习题10.29</p>
<pre><code>int main()
{
	string file_name=&quot;test.txt&quot;;
	fstream fstrm(file_name);
	istream_iterator&lt;string&gt; in(fstrm),eof;
	vector&lt;string&gt; vs(in, eof);
	for (auto s : vs)
		cout &lt;&lt; s &lt;&lt; endl;
}
</code></pre>
<p>注意流迭代器的使用，就好像平时的迭代器一样，有开始和结尾<br>
习题10.30</p>
<pre><code>int main()
{
	istream_iterator&lt;int&gt; is(cin),eof;
	vector&lt;int&gt; vi(is, eof);
	sort(vi.begin(), vi.end());
	ostream_iterator&lt;int&gt; os(cout,&quot; &quot;);
	copy(vi.begin(), vi.end(), os);
	cout &lt;&lt; endl;
}
</code></pre>
<p>当copy到输出流迭代器的时候直接等于输出<br>
习题10.31</p>
<pre><code>int main()
{
	istream_iterator&lt;int&gt; is(cin), eof;
	vector&lt;int&gt; vi(is, eof);
	sort(vi.begin(), vi.end());
	ostream_iterator&lt;int&gt; os(cout, &quot; &quot;);
	unique_copy(vi.begin(), vi.end(), os);
	cout &lt;&lt; endl;
}
</code></pre>
<p>习题10.32</p>
<pre><code>int main()
{
	istream_iterator &lt; Sales_item &gt; is(cin),eof;
	vector&lt;Sales_item&gt; vs(is,eof);
	stable_sort(vs.begin(), vs.end(), compareISBN);
	for (auto i = vs.begin(); i &lt; vs.end(); ++i) {
		auto j = i;
		while (j&lt;vs.end()&amp;&amp;(*j).isbn == (*i).isbn)
			++j;
		Sales_item temp=*i;
		accumulate(i, j-1, temp);
		i = j;
	}
}

bool compareISBN(const Sales_item &amp;s1, const Sales_item &amp;s2) {
	int result = s1.isbn.compare(s2.isbn);
	if (result &lt; 0)
		return true;
	else
		return false;
}
</code></pre>
<p>不是很想得明白find 的用处（利用反向迭代器查找最后一个？）<br>
习题10.33</p>
<pre><code>int main()
{
	divid(&quot;input.txt&quot;, &quot;output1`.txt&quot;, &quot;output2.txt&quot;);
	
}

void divid(string input, string output_1, string output_2) {
	ifstream ifstr(input);
	ofstream ofstr1(output_1), ofstr2(output_2);
	istream_iterator&lt;int&gt; is(ifstr),eof;
	vector&lt;int&gt; vi(is, eof);
	ostream_iterator&lt;int&gt; os1(ofstr1,&quot; &quot;), os2(ofstr2,&quot;\n&quot;);
	for (auto i : vi) {
		if (i % 2)
			os1 = i;
		else
			os2 = i;
		cout &lt;&lt; i &lt;&lt; endl;
	}
}
</code></pre>
<p>一定要记得利用输出输入流来初始化istream_iterator、ostream_iterator</p>
<p>10.4.3反向迭代器<br>
除了<strong>forward_list</strong>之外，其他容器都支持反向迭代器<br>
可以通过向<strong>sort</strong>传递一对反向迭代器来将vector整理为<strong>递减序</strong><br>
不可能从一个<strong>forward_list</strong>或一个流迭代器创建反向迭代器<br>
注意cbegin和crend<strong>并不在同一位置</strong>cend和crbegin也同理<br>
auto rcomma = find(line.crbegin(),line.crend(),’,’) //查找最后一个逗号所在的位置<br>
cout&lt;&lt;string(line.crbegin(),rcomma)&lt;&lt;endl; //错误！！将会<strong>逆序输出字符</strong><br>
不能使用反向迭代器进行顺序打印，因为反向迭代器总会朝着string开始的位置移动，需要把反向迭代器通过调用reverse_iterator的<strong>base</strong>成员函数来进行转换，返回对应的普通迭代器<br>
但是注意！！反向迭代器转换为普通迭代器时，两个迭代器所指向的位置并不一样，它们是在<strong>相邻位置，而不是相同位置</strong></p>
<p>习题10.34</p>
<pre><code>int main()
{
	vector&lt;int&gt; vi{ 1,2,3,4,5,6,7,8,9,0 };
	for (auto i = vi.rbegin(); i &lt; vi.rend(); ++i)
		cout &lt;&lt; *i &lt;&lt; endl;
}
</code></pre>
<p>习题10.35</p>
<pre><code>int main()
{
	vector&lt;int&gt; vi{ 1,2,3,4,5,6,7,8,9,0 };
	for (auto i = vi.end()-1; i &gt;vi.begin(); --i)
		cout &lt;&lt; *i &lt;&lt; endl;
	cout &lt;&lt; *vi.begin() &lt;&lt; endl;
}
</code></pre>
<p>注意有些容器的迭代器是无法使用递减操作的<br>
习题10.36</p>
<pre><code>int main()
{
	list&lt;int&gt; li{ 1,2,3,4,5,6,7,8,9,0 };
	if (find(li.rbegin(), li.rend(), 0) != li.rend())
		cout &lt;&lt; *find(li.rbegin(), li.rend(), 0) &lt;&lt; endl;
	else
		cout &lt;&lt; &quot;not found&quot; &lt;&lt; endl;
}
</code></pre>
<p>注意find返回的是inputiterator，无法进行算法运算，只能递增<br>
习题10.37</p>
<pre><code>int main()
{
	vector&lt;int&gt; vi{ 1,2,3,4,5,6,7,8,9,0 };
	list&lt;int&gt; li(vi.rbegin()+3,vi.rend()-2);
	for (auto i : li)
		cout &lt;&lt; i &lt;&lt; endl;
}
</code></pre>
<p>注意区间是左开右合，反向迭代器也是</p>
<p>10.5.1  5类迭代器<br>
输入迭代器<br>
输入迭代器只能用于顺序访问，但递增输入迭代器可能导致所有其他指向流的迭代器失效，导致输入迭代器不能保证成功访问保存过的状态，因此，输入迭代器只能用于单遍扫描算法（注意！istream_iterator就是一种输入迭代器）<br>
输出迭代器<br>
<strong>解引用符*只能出现在赋值运算符=的左侧</strong>等于将值写入它所指向的元素<br>
<strong>用作目的位置参数的迭代器通常都是输出迭代器</strong>，比如copy的第三个参数，ostream_iterator也是输出迭代器</p>
<p>随机访问迭代器<br>
提供在常量时间内访问序列任意元素的能力<br>
用到随机访问迭代器的1.算法sort 2.array、deque、string和vector的迭代器 3.用于访问内置数组元素的指针</p>
<p>习题10.38<br>
<img src="https://lixin-ee.github.io//post-images/1570847767348.png" alt=""><br>
习题10.39<br>
list属于双向迭代器，vector属于随机访问迭代器<br>
习题10.40<br>
copy要求两个输入迭代器和一个输出迭代器，reverse要求两个双向迭代器，unique要求两个单向迭代器<br>
STL源码剖析中有很明确的定义了</p>
<p>10.5.2算法形参模式<br>
只接受单个目标迭代器dest参数的算法都假定目标空间具有足够容纳写入数据<br>
接收单独beg2假定从beg2开始的序列与beg和end所表示的范围至少一样大</p>
<p>10.5.3算法命名规范<br>
接收谓词来代替原来的比较操作（&lt;或==）或不接受额外参数的算法通常都是重载的函数（名字相同）<br>
接受一个元素值（作为基准值，比如find（beg，end，val）的val）的算法通常有另一个不同名的版本（不是重载），通常有附加的_if前缀，该版本接受一个谓词代替元素值<br>
默认情况下重排元素的算法将重排后的元素写回原序列，而写到其他序列的算法需要在名字后面加上_copy</p>
<p>习题10.41<br>
1.用new_val代替old_val<br>
2.当值符合pred，就用old_val代替<br>
3.用new_val代替old_val，并且将结果复制到dest的迭代器指向的容器位置中<br>
4.当值符合pred，就用old_val代替，并且将结果复制到dest的迭代器指向的容器位置中<br>
上述都是遍历 beg到end</p>
<p>10.6特定容器算法<br>
对于list和forward_list应该优先使用成员函数版本的算法而不是通用算法，例如通用版本的sort要求随机访问迭代器，所以list和forward_list只能使用自己定义的sort<br>
链表通过<strong>改变元素之间的链接</strong>而不是真的交换它们的值来快速交换元素<br>
merge操作需要比较两个list中的值大小再进行插入，所以必须是有序的<br>
splice成员，链表数据结构特有的<br>
链表特有版本和通用版本的算法之间的一个至关重要的区别是链表版本<strong>会改变底层的容器</strong>remove的链表版本会删除指定元素，unique会删除第二个和后续的重复元素</p>
<p>习题10.42</p>
<pre><code>void elimDups(list&lt;string&gt; &amp;words) {
	words.sort();
	words.unique();
	for (auto i : words)
		cout &lt;&lt; i &lt;&lt; &quot; &quot;;
	cout &lt;&lt; endl;
}
</code></pre>
<p>对比原来的</p>
<pre><code>void elimDups(vector&lt;string&gt; &amp;words) {
	sort(words.begin(), words.end());
	auto end_unique = unique(words.begin(), words.end());
	for (auto i : words)
		cout &lt;&lt; i &lt;&lt; &quot; &quot; ;
	cout &lt;&lt; endl;
	words.erase(end_unique, words.end());
	for (auto i : words)
		cout &lt;&lt; i &lt;&lt; &quot; &quot;;
	cout &lt;&lt; endl;
}
</code></pre>
<p>可以看出，list的特定操作比如sort、unique操作和普通的操作的区别在于1，参数的区别，list可以指定一个谓词，但是无法指定范围迭代器，list只能对整体进行操作 2.list是真的会删除元素（源码内部就调用了erase），而不像通用版本中还需要额外的erase。</p>
<p>习题感悟：<br>
copy后缀的函数都需要一个输出迭代器作为参数，而不是普通的迭代器。然后unique只能检测相邻的重复元素。<br>
vector、string等容器都无法使用 front_inserter<br>
注意流迭代器的使用，就好像平时的迭代器一样，有开始和结尾<br>
当copy到输出流迭代器的时候直接等于输出<br>
一定要记得利用输出输入流来初始化istream_iterator、ostream_iterator<br>
注意有些容器的迭代器是无法使用递减操作的<br>
<strong>注意find返回的是inputiterator，无法进行算法运算，只能递增</strong><br>
注意区间是左开右合，反向迭代器也是<br>
copy要求两个输入迭代器和一个输出迭代器，reverse要求两个双向迭代器，unique要求两个单向迭代器<br>
可以看出，list的特定操作比如sort、unique操作和普通的操作的区别在于1，参数的区别，list可以指定一个谓词，但是无法指定范围迭代器，list只能对整体进行操作 2.list是真的会删除元素（源码内部就调用了erase），而不像通用版本中还需要额外的erase。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 168. 字符串 171.Excel表列名称-序号转换]]></title>
        <id>https://lixin-ee.github.io//post/zi-fu-chuan-168-excel-biao-lie-ming-cheng</id>
        <link href="https://lixin-ee.github.io//post/zi-fu-chuan-168-excel-biao-lie-ming-cheng">
        </link>
        <updated>2019-10-11T03:18:03.000Z</updated>
        <content type="html"><![CDATA[<p>字符串 168.Excel表列名称</p>
<blockquote>
<p>给定一个正整数，返回它在 Excel 表中相对应的列名称。</p>
<p>例如，</p>
<pre><code>1 -&gt; A
2 -&gt; B
3 -&gt; C
...
26 -&gt; Z
27 -&gt; AA
28 -&gt; AB 
...
</code></pre>
<p>示例 1:</p>
<p>输入: 1<br>
输出: &quot;A&quot;<br>
示例 2:</p>
<p>输入: 28<br>
输出: &quot;AB&quot;<br>
示例 3:</p>
<p>输入: 701<br>
输出: &quot;ZY&quot;</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/excel-sheet-column-title<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题第一眼看上去很简单（而且本来标注的也是简单题），就是一道10进制转26进制的题，我本来是按照十进制转二进制的方法来写的（不断除以2，余数进行编码），但是写到最后就发现问题了：0跑哪去了？<br>
仔细看的话似乎题目很详细，但是十进制转X进制是0-9转换过去的，而不是1-10，所以这里是缺了一个0，所以我忙活了一个晚上需要对0进行额外的处理<br>
我忙活了一个晚上的原因也在于判断条件，一开始希望在一个循环内解决战斗，但是有一种特殊情况很烦人：商等于1，余数等于0的情况，这种情况需要借位等于Z<br>
所以最后打算先不管了，在结果字符串中保存0，然后再遍历一次进行借位操作<br>
然后发现借位操作也不简单啊...从前往后的话有一种很奇葩的特例是AAAAAA0，借到第一位，从后往前的话就有A0000000这种奇葩情况。最后使用的是从前往后，不断借位直到借到首位（首位肯定不为0）然后对首位进行判断截断字符串再输出<br>
结果如下：</p>
<pre><code>class Solution {
public:
string convertToTitle(int n) {
        string res;
        char temp;
        int i;
        do{
            i=n%26;
            n=n/26;
            if(!i)
                temp='0';
            else
                temp='A'+i-1;
            res= temp+res;
        }while(n);
        for(int c=1;c&lt;res.size();++c) {
            int num=0;
            while(res[c-num]=='0'&amp;&amp;c-num&gt;0){
                res[c-num]='Z';
                if(res[c-num-1]=='A')
                    res[c-num-1]='0';
                else
                    res[c-num-1]=res[c-num-1]-1;
                ++num;
            }        
        }   
        if(res[0]=='0')
            res=res.substr(1,res.size()-1);
        return res;
    }
};
</code></pre>
<p>终于通过了，前前后后大概花了三小时。<br>
然后看看网友题解</p>
<blockquote>
<p>思路<br>
做这道题要先了解一下, 十进制转二进制, 比如 6 转 成二进制多少?</p>
<p>2 |_ 6 _                       ^<br>
2|_ 3 _  ······ 0    |<br>
2|_ 1 _ ·······1    |<br>
|_ 0_ ·······1    |</p>
<p>所以， 我们能得到二进制为 110, 这道题换句话说是十进制转26进制的</p>
<p>但是有个难点: 如果 26 转成 字母是多少?</p>
<p>26|_ 26 _<br>
1   ··· 0<br>
这里出现了0, 但是我们26 字母 没有任何一个字母是表示0, 所以我们可以从 商 借一个给余数</p>
<p>26| _ 26 _<br>
0 ··· 26<br>
这样就可以表示出来了,所以代码如下</p>
</blockquote>
<pre><code>class Solution:
    def convertToTitle(self, n: int) -&gt; str:
        res = &quot;&quot;
        while n:
            n, y = divmod(n, 26) 
            if y == 0:
                n -= 1
                y = 26
            res = chr(y + 64) + res
        return res
</code></pre>
<blockquote>
<p>看了其他做法, 他们先让n 减一</p>
</blockquote>
<pre><code>class Solution:
    def convertToTitle(self, n: int) -&gt; str:
        res = &quot;&quot;
        while n:
            n -= 1
            n, y = divmod(n, 26) 
            res = chr(y + 65) + res
        return res
</code></pre>
<blockquote>
<p>还有一种递归写法:</p>
</blockquote>
<pre><code>class Solution:
    def convertToTitle(self, n: int) -&gt; str:
        return &quot;&quot; if n == 0 else self.convertToTitle((n - 1) // 26) + chr((n - 1) % 26 + 65
</code></pre>
<p>C++版</p>
<pre><code>class Solution {
public:
    string convertToTitle(int n) {
        char a[26]={'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'};//表
        string res;
        while(n)
        {
            n--;//要先减一才能找到对应的字母
            res=a[n%26]+res;
            n=n/26;
        }
        return res;
    }
};
</code></pre>
<blockquote>
<p>思路1：此题可以近似看成一个求26进制的题，但是值得注意的是对于26的整数倍，如果我们不加以限制的话就会造成A0的情况出现，而题目给出的条件中是不考虑这种情况的。所以我们只需要排除这种情况对于任何26的整数倍，我们就直接先插入‘Z’，同时还要对原数进行减一的操作。因为如果不进行减一的话对于26所对应的就是AZ（其实就是为了将A0映射为Z要对A0整体减一，由于0-1不够，所以要向A借一位，所以最后就得到了Z。所以我们要插入Z之后再对原数减1。）</p>
<p>思路2：上一种思路我们看到了为什么对于26的整数倍要进行减一的操作，同时对于1-25而言，我们应该映射到A-Y，但是对于1我们直接加上A的ascii码就会得到B，所以我们也要进行减一的操作，(char)(temp+'A'-1)。对于Z我们需要减一，对于A-Y也需要减一，如果我们可以减这两种减一统一起来事情就变得简单了。所以我们可以考虑在取余之前就整体减一。我们可以证明对于26的N倍（num%26 = N），我们整体减一在取余就会得到(num-1)%26 = N-1余25，所以25直接加上A的ASCII码就得Z，所以对于Z而言是可以提前减一的。对于A-Y而言num%26 = N余t，t属于1到25的范围。这个t减一在加上'A'的ASCII码就对于与A-Y（t+'A'-1），而如果我们提前减一的话这个表达式就变成了(num-1)%26 =N余t-1;最后我们的到的值就不用进行减一操作（t-1+'A'）。所以可以将Z和A-Y的操作统一起来了，提前减一，然后再正常取模即可。、</p>
</blockquote>
<p>卧槽！！！太简单了吧！！！我吐血了！！！<br>
其实本来也是有想到减1的思路的，但是当时没有好好思考应该在哪里进行减1操作，导致最后代码非常臃肿庞大。。。也有一个原因就是昨晚做题太赶了，看着是简单题就总是想赶出答案，所以做题还是得静下心来啊</p>
<p>171.Excel表列序号转换</p>
<blockquote>
<p>给定一个Excel表格中的列名称，返回其相应的列序号。<br>
例如，<br>
A -&gt; 1<br>
B -&gt; 2<br>
C -&gt; 3<br>
...<br>
Z -&gt; 26<br>
AA -&gt; 27<br>
AB -&gt; 28<br>
...<br>
示例 1:<br>
输入: &quot;A&quot;<br>
输出: 1<br>
示例 2:<br>
输入: &quot;AB&quot;<br>
输出: 28<br>
示例 3:<br>
输入: &quot;ZY&quot;<br>
输出: 701<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/excel-sheet-column-number<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题就是上一道题的翻转版，所以我就放在一起了<br>
这个的翻转相对简单一点，我一开始的做法是从后往前，主要的槽点在于如果使用一个变量来记录权值26^n,会有一个测试用例出现溢出的情况，导致我强行加了一个判断条件。</p>
<pre><code>class Solution {
public:
    int titleToNumber(string s) {
        int res=0;
        int num=1;
        for(auto i=s.rbegin();i&lt;s.rend();++i){
            res+=(*i-'A'+1)*num;
            if(i&lt;s.rend()-1)
                num*=26;
        }
        return res;   
    }
};
</code></pre>
<p>然后看了网友题解才想起来明明可以从前往后的啊。。。又傻了<br>
解题方案</p>
<blockquote>
<p>思路<br>
标签：字符串遍历，进制转换<br>
初始化结果ans = 0，遍历时将每个字母与A做减法，因为A表示1，所以减法后需要每个数加1，计算其代表的数值num = 字母 - ‘A’ + 1<br>
因为有26个字母，所以相当于26进制，每26个数则向前进一位<br>
所以每遍历一位则ans = ans * 26 + num<br>
以ZY为例，Z的值为26，Y的值为25，则结果为26 * 26 + 25=701<br>
时间复杂度：O(n)<br>
代码</p>
</blockquote>
<pre><code>class Solution {
    public int titleToNumber(String s) {
        int ans = 0;
        for(int i=0;i&lt;s.length();i++) {
            int num = s.charAt(i) - 'A' + 1;
            ans = ans * 26 + num;
        }
        return ans;
    }
}
</code></pre>
<p>这个的话就好很多了，至少不需要担心溢出的问题。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 316. 去除重复字母]]></title>
        <id>https://lixin-ee.github.io//post/316-qu-chu-chong-fu-zi-mu</id>
        <link href="https://lixin-ee.github.io//post/316-qu-chu-chong-fu-zi-mu">
        </link>
        <updated>2019-10-10T03:39:32.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个仅包含小写字母的字符串，去除字符串中重复的字母，使得每个字母只出现一次。需保证返回结果的字典序最小（要求不能打乱其他字符的相对位置）。</p>
<p>示例 1:<br>
输入: &quot;bcabc&quot;<br>
输出: &quot;abc&quot;<br>
示例 2:<br>
输入: &quot;cbacdcbc&quot;<br>
输出: &quot;acdb&quot;</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/remove-duplicate-letters<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>一开始我弄错题意了，以为是提取某个字母第一次出现的位置或者第二次出现的位置：</p>
<pre><code>class Solution {
public:
    string removeDuplicateLetters(string s) {
        map&lt;char,int&gt; s_map;
        for(auto c:s){
            if(!s_map.insert(make_pair(c,1)).second)
                ++s_map.at(c);
        }
        string res;
        for(auto i=s.rbegin();i&lt;s.rend();++i){
            if(s_map.at(*i)==1||s_map.at(*i)==2){
                res=*i+res;
                s_map.at(*i)=-1;
            }
            else if(s_map.at(*i)&gt;2)
                --s_map.at(*i);                
        }
        return res;
    }
};
</code></pre>
<p>其实是寻找一个区域，使得字典序（也就是字符串排序）最小，并且其中不能用重复的字母，比如dabccd，结果就是abcd，第一个d要去掉，第二个c也得去掉。<br>
然后这两天发生了蛮多的事情的，心情不太好，题目也没什么思路，就直接先看一下网友题解吧</p>
<pre><code>维护一个Stack&lt;char&gt;，对字符串进行正序遍历。对每个字符ch，首先判断stack内是否存在该字符，若stack顶端值比ch大且后续遍历中还能访问到同样的值则将该顶端值去除，最后将stack转化为Array，逆序后转化为字符串输出。

public class Solution {
    public string RemoveDuplicateLetters(string s)
    {
        Stack&lt;char&gt; stack = new Stack&lt;char&gt;();
        for (int i = 0; i &lt; s.Length; ++i)
        {
            char ch = s[i];
            if (stack.Contains(ch))
            {
                continue;
            }
            while (stack.Count &gt; 0 &amp;&amp; stack.Peek() &gt; ch &amp;&amp; s.LastIndexOf(stack.Peek()) &gt; i)
            {
                stack.Pop();
            }
            stack.Push(ch);
        }
        char[] res = stack.ToArray();
        Array.Reverse(res);
        return new string(res);
    }
}
</code></pre>
<pre><code>* 这道题呢，就是要想办法把最小的字母放在最前面
 * 例如：bcabc
 * 
 * 如果当前只有一个字母b，b就是升序的，没问题
 * 此时加入一个c，变成bc，OK，是升序的，没问题，继续
 * 再加入一个a，变成了bca，那么此时我要将a放在最前面，那么就需要a后面有b,和c能替换前面的bc。
 * 
 * 所以我这里遍历到a时，先判断后面有没有c，有的话，我将前面的c去掉，变成ba，
 * 然后我再判断后面有没有b，有的话，我将前面的b去掉，
 * 
 * 我们用stack来记录这种移位后的结果
 * 那么stack的变化顺序：
 * stack=[b]
 * stack=[b,c]
 * stack=[b,a]
 * stack=[a]
 * stack=[a,b]
 * stack=[a,b,c]
 */
</code></pre>
<p>描述比较简单，整体思路也算比较暴力了，但是操作起来可不简单，首先必须对栈进行遍历操作，其次需要对数组字母出现的位置进行遍历操作。第二个还好，第一个的话c++的栈是没有遍历接口的，只能对栈顶元素进行操作，所以还得找一下针对c++的方法。</p>
<blockquote>
<p>1.遍历字符串，用map记录字符出现的最后位置；<br>
2.第二次遍历字符串时，维护一个记录结果的栈，用vector实现；<br>
3.维护一个map记录当前字符是否在栈里（就不需要遍历数组，看是否存在），当在栈里时，继续遍历，不在转4；<br>
4.当栈不为空且字典序比当前元素大时，并且栈顶字符在原字符串中出现的位置比当前下标i更大，说明栈顶字符会在之后出现。弹出栈顶元素，并将栈顶元素是否在栈中的记录抹除；<br>
5.压栈当前字符；<br>
6.结果为vector数组中的字符顺序。</p>
</blockquote>
<pre><code>class Solution {
public:
    string removeDuplicateLetters(string s) {
        unordered_map&lt;char, int&gt; mp;
        unordered_map&lt;char, int&gt; in_st;
        for(int i = 0; i &lt; s.size(); ++i)
            mp[s[i]] = i;//记录某个字符出现的最后位置
        vector&lt;char&gt; st;//记录结果的栈
        for(int i = 0; i &lt; s.size(); ++i){
            if(in_st[s[i]])continue;//栈中有当前遍历的字符
            while(st.size() &amp;&amp; s[i] &lt; st.back() &amp;&amp; mp[st.back()] &gt; i){
            //栈顶元素会在之后的位置出现
                --in_st[st.back()];
                st.pop_back();
            //出栈并抹除记录
            }
            st.push_back(s[i]);
            ++in_st[s[i]];
        //压栈，并记录出现过
        }
        string res;
        for(auto&amp; i : st)res += i;    
        return res;
    }
};
</code></pre>
<p>这个方法就挺好的，利用两个map记录字符的情况，比遍历快很多，属于利用空间换时间。<br>
然后自己实现了一遍，需要注意的点在于一个是pop的判断可是有三部分的1.判断栈是否为空2.栈顶元素是否大于当前元素3.栈顶元素是否会在字符串后面再出现<br>
然后在pop的时候需要同时在栈的map里面删除相关元素（或者像原作者那样利用map的值进行操作）<br>
主要注意的点还是c++的栈操作pop是无法同时删除栈顶然后返回值的，必须top和pop配合</p>
<pre><code>class Solution {
public:
    string removeDuplicateLetters(string s) {
        map&lt;char,int&gt; s_map;
        for(int i=0;i&lt;s.size();++i)
               s_map[s[i]]=i;
        map&lt;char,int&gt; stack_map;
        stack&lt;char&gt; res;
        for(int i=0;i&lt;s.size();++i){
            if(!stack_map.insert({s[i],i}).second)
                continue;
            while(!res.empty()&amp;&amp;s[i]&lt;res.top()&amp;&amp;s_map[res.top()]&gt;i){
                stack_map.erase(res.top());
                res.pop();
            }
            res.push(s[i]);
        }
        string result;
        while(!res.empty()){
            result= res.top()+result;
            res.pop();
        }
        return result;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 38.报数]]></title>
        <id>https://lixin-ee.github.io//post/zi-fu-chuan-38-bao-shu</id>
        <link href="https://lixin-ee.github.io//post/zi-fu-chuan-38-bao-shu">
        </link>
        <updated>2019-10-09T03:01:52.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：</p>
<pre><code>1.     1
2.     11
3.     21
4.     1211
5.     111221
</code></pre>
<p>1 被读作  &quot;one 1&quot;  (&quot;一个一&quot;) , 即 11。<br>
11 被读作 &quot;two 1s&quot; (&quot;两个一&quot;）, 即 21。<br>
21 被读作 &quot;one 2&quot;,  &quot;one 1&quot; （&quot;一个二&quot; ,  &quot;一个一&quot;) , 即 1211。</p>
<p>给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。</p>
<p>注意：整数顺序将表示为一个字符串。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/count-and-say<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>题目也是比较抽象，但是细看的话其实就是“对于上一个字符串，将其重复的数字变为 数量+数字，比如111变成 3+1，单独一个数字的话就只有 1+数字了<br>
一开始我在想会不会是像金字塔那种形状有规律的，但是想想昨天的教训，还是不去钻牛角尖了，直接上最简单的循环法吧！<br>
那么主要的思路就在于正整数n为外循环，内循环则是字符串的长度。然后就是考虑如何检测重复的数字（本质是字符）<br>
（1）一开始我想到的是当前字符和下一字符比较，相等的话num+1，否则就写入字符串递增。<br>
但是这里有个问题是 必须经常检测下一字符是不是尾后位置了，同时有需要维护num。造成很臃肿的判断结构<br>
（2）第二个就是我耍智障了，想用find寻找到最近的重复函数，想法是好的，但是必须重新定义find的比较方式<br>
（3）最后的结果就是使用一个num，如果检测到相同的数字就num++，直到不相同的数字就写入字符串temp，然后直接讲循环量+num跳过相同的数字，虽然也需要检测+num到达尾后迭代位置与否，但是判断结构明显没那么臃肿了。</p>
<pre><code>class Solution {
public:
    string countAndSay(int n) {
	string cur = &quot;1&quot;;
	for (int j = 1; j&lt; n; ++j) {
		string temp;
		for (int i = 0; i &lt; cur.size(); ) {
			int num = 1;
			while(i+num&lt; cur.size()&amp;&amp;cur[i + num] == cur[i])
				++num;
			temp += to_string(num) + cur[i];
			i += num;

		}
		cur = temp;
	}
        return cur;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 6. Z 字形变换]]></title>
        <id>https://lixin-ee.github.io//post/6-z-zi-xing-bian-huan</id>
        <link href="https://lixin-ee.github.io//post/6-z-zi-xing-bian-huan">
        </link>
        <updated>2019-10-08T09:18:24.000Z</updated>
        <content type="html"><![CDATA[<p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p>
<blockquote>
<p>比如输入字符串为 &quot;LEETCODEISHIRING&quot; 行数为 3 时，排列如下：<br>
L   C   I   R<br>
E T O E S I I G<br>
E   D   H   N<br>
之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;LCIRETOESIIGEDHN&quot;。<br>
请你实现这个将字符串进行指定行数变换的函数：<br>
string convert(string s, int numRows);<br>
示例 1:<br>
输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 3<br>
输出: &quot;LCIRETOESIIGEDHN&quot;<br>
示例 2:<br>
输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 4<br>
输出: &quot;LDREOEIIECIHNTSG&quot;<br>
解释:<br>
L     D     R<br>
E   O E   I I<br>
E C   I H   N<br>
T     S     G<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/zigzag-conversion<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题一开始还是被我吐槽了hhh，因为很奇葩，不像汉语的描述风格，同时好像“实用性”不大啊，但是就像谢扬同学所说，还是蛮有趣的。<br>
我一开始的想法是找它们的下标的对应关系，但是写着写着自己都晕了，因为这两天要做报告，没有太多时间给我思考了，所以还是直接看题解吧！<br>
首先是网友们的暴力解法，设立一个二维数组在相应的位置存储相应的元素，这个应该是最简单的了吧，只是空间复杂度比较高。<br>
然后是官方题解。</p>
<blockquote>
<p>方法一：按行排序<br>
思路<br>
通过从左向右迭代字符串，我们可以轻松地确定字符位于 Z 字形图案中的哪一行。</p>
<p>算法<br>
我们可以使用min(numRows,len(s)) 个列表来表示 Z 字形图案中的非空行。<br>
从左到右迭代 s，将每个字符添加到合适的行。可以使用当前行和当前方向这两个变量对合适的行进行跟踪。<br>
只有当我们向上移动到最上面的行或向下移动到最下面的行时，当前方向才会发生改变。</p>
</blockquote>
<pre><code>class Solution {
public:
    string convert(string s, int numRows) {
        int len=s.size();
        if(numRows==1||numRows==0)
            return s;
        bool godown=false;
        int r_size=len&lt;numRows?len:numRows;
        vector&lt;string&gt; rows(r_size);
        int r=0;
        for(auto c:s){
            rows[r]+=c;
            if(r==0||r==r_size-1) godown=!godown;
            if(godown)
                ++r;
            else
                --r;
        }
        string s_res;
        for(auto c:rows)
            s_res+=c;
        return s_res;
        
    }
};
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)，其中n==len(s)<br>
空间复杂度：O(n)</p>
<p>方法二：按行访问<br>
思路<br>
按照与逐行读取 Z 字形图案相同的顺序访问字符串。</p>
<p>算法<br>
首先访问 行 0 中的所有字符，接着访问 行 1，然后 行 2，依此类推...<br>
对于所有整数 k，<br>
行 0 中的字符位于索引k(2⋅numRows−2) 处;<br>
行 numRows−1 中的字符位于索引 k(2⋅numRows−2)+numRows−1 处;<br>
内部的 行 i 中的字符位于索引k(2⋅numRows−2)+i 以及(k+1)(2⋅numRows−2)−i 处;</p>
</blockquote>
<pre><code>class Solution {
public:
    string convert(string s, int numRows) {

        if (numRows == 1) return s;

        string ret;
        int n = s.size();
        int cycleLen = 2 * numRows - 2;

        for (int i = 0; i &lt; numRows; i++) {
            for (int j = 0; j + i &lt; n; j += cycleLen) {
                ret += s[j + i];
                if (i != 0 &amp;&amp; i != numRows - 1 &amp;&amp; j + cycleLen - i &lt; n)
                    ret += s[j + cycleLen - i];
            }
        }
        return ret;
    }
};
</code></pre>
<p>复杂度分析</p>
<p>时间复杂度：O(n)，其中 n==len(s)。每个索引被访问一次。<br>
空间复杂度：O(n)。对于 C++ 实现，如果返回字符串不被视为额外空间，则复杂度为 O(1)。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 179. 最大数]]></title>
        <id>https://lixin-ee.github.io//post/zi-fu-chuan-179-zui-da-shu</id>
        <link href="https://lixin-ee.github.io//post/zi-fu-chuan-179-zui-da-shu">
        </link>
        <updated>2019-10-07T10:40:18.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。</p>
<p>示例 1:<br>
输入: [10,2]<br>
输出: 210<br>
示例 2:<br>
输入: [3,30,34,5,9]<br>
输出: 9534330</p>
<p>说明: 输出结果可能非常大，所以你需要返回一个字符串而不是整数。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/largest-number<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题刚好是在面经里面见过的题目<br>
一开始没什么想法，因为如果是int元素的话，其排序是按位数的排序的。<br>
然后分析了一下最大数的组成，首先对于个位数，不用想了肯定是单个9是最好的数，无脑放在前面就行了。然后对于多位数，重点就是其第一位的值，其次从左到右看它的值而确定它的结果中的位置。<br>
然后受到题目说明的影响，诶！字符串不就是按从左到右的位数来排序的吗？！比如30和9相比，9是比30大的！<br>
然而开心了不到一分钟就凉了，因为字符串的排序也是有缺陷的，在位数不相等的情况下，默认位数多的比较大，比如902和99，会认为902比99大，但是99902明显比90299大嘛，所以还需要攻克这最后一个问题<br>
然后白天没啥思路就先回学校了，傍晚打开题目时突然想到一个stl源码剖析中反复提到的点：泛型算法的条件是可以自己设定的！然后我就想到在排序比较时，将位数不同的字符串的位数补齐，然后再进行比较<br>
然后在中途遇到了一些问题，直接在sort后面插入自定义比较函数的时候发生了错误，后来查阅后发现是因为leetcode默认把解答放在类里面，类里面的成员函数在类成员构造出来之前是无法直接调用的，所以必须声明称static函数在编译阶段就初始化，我会在后面单独写一篇博文进行简介<br>
然后在寻找解决方法的过程中发现了更加绝妙的比较方法</p>
<pre><code>  string ab = s1 + s2;
        string ba = s2 + s1;
        return ab &gt; ba; 
</code></pre>
<p>哈哈妙啊，刚好不就是题目的核心思路嘛<br>
于是最后代码如下</p>
<pre><code>class Solution {
public:
    string largestNumber(vector&lt;int&gt;&amp; nums) {
        vector&lt;string&gt; str_nums;
        for(auto i:nums)
            str_nums.push_back(to_string(i));
        sort(str_nums.begin(),str_nums.end(),compare_str);
        string s;
        if(str_nums[0]==&quot;0&quot;)
            return &quot;0&quot;;
        for(auto str:str_nums)
            s+=str;
        return s;
        
    }
    
    static bool compare_str(const string &amp;s1,const string &amp;s2){
        string ab = s1 + s2;
        string ba = s2 + s1;
        return ab &gt; ba;  
    }
};
</code></pre>
<p>最后官方题解和我的思路一致，本来以为没法解决这个棘手的问题了，结果还蛮顺利的嘛！（不要停下来啊！hhhh）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 87. 扰乱字符串]]></title>
        <id>https://lixin-ee.github.io//post/zi-fu-chuan-87-rao-luan-zi-fu-chuan</id>
        <link href="https://lixin-ee.github.io//post/zi-fu-chuan-87-rao-luan-zi-fu-chuan">
        </link>
        <updated>2019-10-06T08:40:27.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个字符串 s1，我们可以把它递归地分割成两个非空子字符串，从而将其表示为二叉树。</p>
<p>下图是字符串 s1 = &quot;great&quot; 的一种可能的表示形式。<br>
great<br>
/    <br>
gr    eat<br>
/ \    /  <br>
g   r  e   at<br>
/ <br>
a   t<br>
在扰乱这个字符串的过程中，我们可以挑选任何一个非叶节点，然后交换它的两个子节点。</p>
<p>例如，如果我们挑选非叶节点 &quot;gr&quot; ，交换它的两个子节点，将会产生扰乱字符串 &quot;rgeat&quot; 。</p>
<pre><code>rgeat
</code></pre>
<p>/    <br>
rg    eat<br>
/ \    /  <br>
r   g  e   at<br>
/ <br>
a   t<br>
我们将 &quot;rgeat” 称作 &quot;great&quot; 的一个扰乱字符串。</p>
<p>同样地，如果我们继续交换节点 &quot;eat&quot; 和 &quot;at&quot; 的子节点，将会产生另一个新的扰乱字符串 &quot;rgtae&quot; 。</p>
<pre><code>rgtae
</code></pre>
<p>/    <br>
rg    tae<br>
/ \    /  <br>
r   g  ta  e<br>
/ <br>
t   a<br>
我们将 &quot;rgtae” 称作 &quot;great&quot; 的一个扰乱字符串。</p>
<p>给出两个长度相等的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串。</p>
<p>示例 1:</p>
<p>输入: s1 = &quot;great&quot;, s2 = &quot;rgeat&quot;<br>
输出: true<br>
示例 2:</p>
<p>输入: s1 = &quot;abcde&quot;, s2 = &quot;caebd&quot;<br>
输出: false</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/scramble-string<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题还是没读懂。。。直接看的网友题解<br>
看了题解后比较明白了，就是对字符串不断地进行二等分，同时二等分的区域可以交换，这样的话其实可以进行递归操作，对两个字符串的所有可能的分割点进行遍历并进行排序再比较（当然首先进行相等比较），这里的比较我直接用了泛型算法sort，STL源码剖析中提及sort的核心其实也是快速排序（但当规模较小的时候会使用插入排序或者堆排序）。<br>
代码如下：主要需要注意的点在于需要进行两次递归调用（相当于对字符串分割出来的两部分进行调换）</p>
<pre><code>class Solution {
public:
    bool isScramble(string s1, string s2) {
        if(s1==s2)
            return true;
        string ss1(s1);
        string ss2(s2);
        sort(ss1.begin(),ss1.end());
        sort(ss2.begin(),ss2.end());
        if(ss1!=ss2)
            return false;
        for(int i=1;i&lt;s1.size();++i){
            if(isScramble(s1.substr(0,i),s2.substr(0,i))&amp;&amp;isScramble(s1.substr(i,s1.size()-i),s2.substr(i,s2.size()-i)))
                return true;
            if(isScramble(s1.substr(0,i),s2.substr(s2.size()-i,i))&amp;&amp;isScramble(s1.substr(i,s1.size()-i),s2.substr(0,s2.size()-i)))
                return true;
        
        }  
        return false;
    }
};
</code></pre>
<p>下面是网友题解：</p>
<blockquote>
<p>把一个字符串按照树的形状，分成两部分，分成两部分...直到达到叶子节点。并且可以多次交换非叶子节点的两个子树，最后从左到右读取叶子节点，记为生成的字符串。题目是给两个字符串 S1 和 S2，然后问 S2 是否是 S1 经过上述方式生成的。</p>
<p>解法一 递归<br>
开始的时候，由于给出的图示很巧都是平均分的，我以为只能平均分字符串，看了这里，明白其实可以任意位置把字符串分成两部分，这里需要注意一下。</p>
<p>这道题很容易想到用递归的思想去解，假如两个字符串 great 和 rgeat。考虑其中的一种切割方式。</p>
<p>第 1 种情况：S1 切割为两部分，然后进行若干步切割交换，最后判断两个子树分别是否能变成 S2 的两部分。<br>
第 2 种情况：S1 切割并且交换为两部分，然后进行若干步切割交换，最后判断两个子树是否能变成 S2 的两部分。<br>
上边是一种切割方式，我们只需要遍历所有的切割点即可。</p>
</blockquote>
<pre><code>public boolean isScramble(String s1, String s2) {
    if (s1.length() != s2.length()) {
        return false;
    }
    if (s1.equals(s2)) {
        return true;
    }

    //判断两个字符串每个字母出现的次数是否一致
    int[] letters = new int[26];
    for (int i = 0; i &lt; s1.length(); i++) {
        letters[s1.charAt(i) - 'a']++;
        letters[s2.charAt(i) - 'a']--;
    }
    //如果两个字符串的字母出现不一致直接返回 false
    for (int i = 0; i &lt; 26; i++) {
        if (letters[i] != 0) {
            return false;
        }
    }
    
    //遍历每个切割位置
    for (int i = 1; i &lt; s1.length(); i++) {
        //对应情况 1 ，判断 S1 的子树能否变为 S2 相应部分
        if (isScramble(s1.substring(0, i), s2.substring(0, i)) &amp;&amp; isScramble(s1.substring(i), s2.substring(i))) {
            return true;
        }
        //对应情况 2 ，S1 两个子树先进行了交换，然后判断 S1 的子树能否变为 S2 相应部分
        if (isScramble(s1.substring(i), s2.substring(0, s2.length() - i)) &amp;&amp;
           isScramble(s1.substring(0, i), s2.substring(s2.length() - i)) ) {
            return true;
        }
    }
    return false;
}
</code></pre>
<blockquote>
<p>时间复杂度：<br>
空间复杂度：</p>
<p>当然，我们可以用 memoization 技术，把递归过程中的结果存储起来，如果第二次递归过来，直接返回结果即可，无需重复递归。</p>
</blockquote>
<pre><code>public boolean isScramble(String s1, String s2) {
    HashMap&lt;String, Integer&gt; memoization = new HashMap&lt;&gt;();
    return isScrambleRecursion(s1, s2, memoization);
}

public boolean isScrambleRecursion(String s1, String s2, HashMap&lt;String, Integer&gt; memoization) {
    	//判断之前是否已经有了结果
		int ret = memoization.getOrDefault(s1 + &quot;#&quot; + s2, -1);
		if (ret == 1) {
			return true;
		} else if (ret == 0) {
			return false;
		}
		if (s1.length() != s2.length()) {
			memoization.put(s1 + &quot;#&quot; + s2, 0);
			return false;
		}
		if (s1.equals(s2)) {
			memoization.put(s1 + &quot;#&quot; + s2, 1);
			return true;
		}

		int[] letters = new int[26];
		for (int i = 0; i &lt; s1.length(); i++) {
			letters[s1.charAt(i) - 'a']++;
			letters[s2.charAt(i) - 'a']--;
		}
		for (int i = 0; i &lt; 26; i++)
			if (letters[i] != 0) {
				memoization.put(s1 + &quot;#&quot; + s2, 0);
				return false; 
			}

		for (int i = 1; i &lt; s1.length(); i++) {
			if (isScramble(s1.substring(0, i), s2.substring(0, i)) &amp;&amp; isScramble(s1.substring(i), s2.substring(i))) {
				memoization.put(s1 + &quot;#&quot; + s2, 1);
				return true;
			}
			if (isScramble(s1.substring(0, i), s2.substring(s2.length() - i))
					&amp;&amp; isScramble(s1.substring(i), s2.substring(0, s2.length() - i))) {
				memoization.put(s1 + &quot;#&quot; + s2, 1);
				return true;
			}
		}
		memoization.put(s1 + &quot;#&quot; + s2, 0);
		return false;
	}
</code></pre>
<blockquote>
<p>解法二 动态规划<br>
既然是递归，压栈压栈压栈，出栈出栈出栈，我们可以利用动态规划的思想，省略压栈的过程，直接从底部往上走。</p>
<p>我们用 dp [ len ][ i ] [ j ] 来表示 s1[ i, i + len ) 和 s2 [ j, j + len ) 两个字符串是否满足条件。换句话说，就是 s1 从 i 开始的 len 个字符是否能转换为 S2 从 j 开始的 len 个字符。那么解法一的两种情况，递归式可以写作。</p>
<p>第 1 种情况，参考下图： 假设左半部分长度是 q，dp [ len ][ i ] [ j ] = dp [ q ][ i ] [ j ] &amp;&amp; dp [ len - q ][ i + q ] [ j + q ] 。也就是 S1 的左半部分和 S2 的左半部分以及 S1 的右半部分和 S2 的右半部分。<br>
第 2 种情况，参考下图： 假设左半部分长度是 q，那么 dp [ len ][ i ] [ j ] = dp [ q ][ i ] [ j + len - q ] &amp;&amp; dp [ len - q ][ i + q ] [ j ] 。也就是 S1 的右半部分和 S2 的左半部分以及 S1 的左半部分和 S2 的右半部分。</p>
</blockquote>
<pre><code>public boolean isScramble4(String s1, String s2) {
    if (s1.length() != s2.length()) {
        return false;
    }
    if (s1.equals(s2)) {
        return true;
    }

    int[] letters = new int[26];
    for (int i = 0; i &lt; s1.length(); i++) {
        letters[s1.charAt(i) - 'a']++;
        letters[s2.charAt(i) - 'a']--;
    }
    for (int i = 0; i &lt; 26; i++) {
        if (letters[i] != 0) {
            return false;
        }
    }

    int length = s1.length();
    boolean[][][] dp = new boolean[length + 1][length][length];
	//遍历所有的字符串长度
    for (int len = 1; len &lt;= length; len++) {
        //S1 开始的地方
        for (int i = 0; i + len &lt;= length; i++) {
            //S2 开始的地方
            for (int j = 0; j + len &lt;= length; j++) {
                //长度是 1 无需切割
                if (len == 1) {
                    dp[len][i][j] = s1.charAt(i) == s2.charAt(j);
                } else {
                    //遍历切割后的左半部分长度
                    for (int q = 1; q &lt; len; q++) {
                        dp[len][i][j] = dp[q][i][j] &amp;&amp; dp[len - q][i + q][j + q]
                            || dp[q][i][j + len - q] &amp;&amp; dp[len - q][i + q][j];
                        //如果当前是 true 就 break，防止被覆盖为 false
                        if (dp[len][i][j]) {
                            break;
                        }
                    }
                }
            }
        }
    }
    return dp[length][0][0];
}
</code></pre>
<blockquote>
<p>时间复杂度：O(n^4)<br>
空间复杂度：O(n^3)</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 49. 字母异位词分组]]></title>
        <id>https://lixin-ee.github.io//post/zi-fu-chuan-49-zi-mu-yi-wei-ci-fen-zu</id>
        <link href="https://lixin-ee.github.io//post/zi-fu-chuan-49-zi-mu-yi-wei-ci-fen-zu">
        </link>
        <updated>2019-10-05T04:42:01.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。<br>
示例:<br>
输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],<br>
输出:<br>
[<br>
[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],<br>
[&quot;nat&quot;,&quot;tan&quot;],<br>
[&quot;bat&quot;]<br>
]<br>
说明：<br>
所有输入均为小写字母。<br>
不考虑答案输出的顺序</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/group-anagrams<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题相当于上一道题的进阶版<br>
上一题有两种方案可以选择，一种是排序，一种是map或26字母数组<br>
这一题则需要结合排序和map，因为需要同时记录某种异位词在新数组中的位置<br>
整体算法的处理过程就是<br>
1.读入单词，将单词进行排序<br>
2.判断排序结果是否存在于map中，如果不存在的话，就将其排序结果和位置插入map中，并且！<strong>创建临时对象</strong>插入结果序列中<code>vvs.push_back(vector&lt;string&gt;({strs[i]}));</code>（因为结果序列一开始为空，是无法使用位置进行下标插入的）<br>
3.循环上述直至结束<br>
代码如下：</p>
<pre><code>class Solution {
public:
    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) {
        vector&lt;vector&lt;string&gt;&gt; vvs;
        map&lt;string,int&gt; nums;
        int num=0;
        for(int i=0;i&lt;strs.size();++i){
            string s=strs[i];
            Qsort(0,s.size()-1,s);
            if(nums.count(s))
                vvs[nums[s]].push_back(strs[i]);
            else{
                nums.insert(make_pair(s,num));
                vvs.push_back(vector&lt;string&gt;({strs[i]}));
                ++num;
            }        
        }
        return vvs;
    }
    
        void Qsort(int beg,int end,string &amp;s){
        if(beg&lt;end){
         int middle=partition(beg,end,s);
         Qsort(beg,middle-1,s);
         Qsort(middle+1,end,s);
        }
    }
    
    int partition(int beg,int end,string &amp;s){
        int flag=s[beg];
        while(beg&lt;end){
            while(beg&lt;end&amp;&amp;s[end]&gt;=flag)
                --end;
            swap(s[beg],s[end]);
            while(beg&lt;end&amp;&amp;s[beg]&lt;=flag)
                ++beg;
            swap(s[beg],s[end]);
        }
        return beg;
    }
};
</code></pre>
<p>主要需要注意的点在于<br>
1.快速排序一般是需要引用传递的，会改变原值，需要一个temp变量的协助<br>
2.迭代的vector除非提前定义好元素数量，否则需要创建临时变量，无法直接访问下标。<br>
然后来看一下官方题解和网友题解：</p>
<blockquote>
<p>方法一：排序数组分类<br>
思路<br>
当且仅当它们的排序字符串相等时，两个字符串是字母异位词。</p>
<p>算法<br>
维护一个映射 ans : {String -&gt; List}，其中每个键 K 是一个排序字符串，每个值是初始输入的字符串列表，排序后等于 K。<br>
在 Java 中，我们将键存储为字符串，例如，code。 在 Python 中，我们将键存储为散列化元组，例如，('c', 'o', 'd', 'e')。<br>
复杂度分析<br>
时间复杂度：O(NKlogK)，其中 N 是 strs 的长度，而 K 是 strs 中字符串的最大长度。当我们遍历每个字符串时，外部循环具有的复杂度O(N)。然后，我们在O(KlogK) 的时间内对每个字符串排序。<br>
空间复杂度：O(NK)，排序存储在 ans 中的全部信息内容。</p>
</blockquote>
<blockquote>
<p>方法二：按计数分类<br>
思路<br>
当且仅当它们的字符计数（每个字符的出现次数）相同时，两个字符串是字母异位词。</p>
<p>算法<br>
我们可以将每个字符串 s 转换为字符数 count，由26个非负整数组成，表示 a，}b，c 的数量等。我们使用这些计数作为哈希映射的基础。</p>
<p>在 Java 中，我们的字符数 count 的散列化表示将是一个用 <strong>＃</strong> 字符分隔的字符串。 例如，abbccc 将表示为 ＃1＃2＃3＃0＃0＃0 ...＃0，其中总共有26个条目。 在 python 中，表示将是一个计数的元组。 例如，abbccc 将表示为 (1,2,3,0,0，...，0)，其中总共有 26 个条目<br>
时间复杂度：O(NK)，其中 N 是 strs 的长度，而 K 是 strs 中字符串的最大长度。计算每个字符串的字符串大小是线性的，我们统计每个字符串。<br>
空间复杂度：O(NK)，排序存储在 ans 中的全部信息内容。</p>
</blockquote>
<p>官方题解一和我的思路一致，然后题解二就是26字母表的变形，适用于单个元素特别长的情况。</p>
<p>然后看一下网友题解：</p>
<blockquote>
<p>解法一<br>
最通用的一种解法，对于每个字符串，比较它们的每个字符出现的个数是否相等，相等的话就把它们放在一个 list 中去，作为一个类别。最外层写一个 for 循环然后一一比较就可以，还可以用一个等大的布尔型数组来记录当前字符串是否已经加入的了 list 。比较两个字符串的字符出现的次数可以用一个 HashMap，具体看代码吧。</p>
</blockquote>
<pre><code>public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) {
    List&lt;List&lt;String&gt;&gt; ans = new ArrayList&lt;&gt;();
    boolean[] used = new boolean[strs.length];
    for (int i = 0; i &lt; strs.length; i++) {
        List&lt;String&gt; temp = null;
        if (!used[i]) {
            temp = new ArrayList&lt;String&gt;();
            temp.add(strs[i]);
            //两两比较判断字符串是否符合
            for (int j = i + 1; j &lt; strs.length; j++) {
                if (equals(strs[i], strs[j])) {
                    used[j] = true;
                    temp.add(strs[j]);
                }
            }
        }
        if (temp != null) {
            ans.add(temp);

        }
    }
    return ans;

}
private boolean equals(String string1, String string2) {
    Map&lt;Character, Integer&gt; hash = new HashMap&lt;&gt;();
    //记录第一个字符串每个字符出现的次数，进行累加
    for (int i = 0; i &lt; string1.length(); i++) {
        if (hash.containsKey(string1.charAt(i))) {
            hash.put(string1.charAt(i), hash.get(string1.charAt(i)) + 1);
        } else {
            hash.put(string1.charAt(i), 1);
        }
    }
     //记录第一个字符串每个字符出现的次数，将之前的每次减 1
    for (int i = 0; i &lt; string2.length(); i++) {
        if (hash.containsKey(string2.charAt(i))) {
            hash.put(string2.charAt(i), hash.get(string2.charAt(i)) - 1);
        } else {
            return false;
        }
    }
    //判断每个字符的次数是不是 0 ，不是的话直接返回 false
    Set&lt;Character&gt; set = hash.keySet();
    for (char c : set) {
        if (hash.get(c) != 0) {
            return false;
        }
    }
    return true;
}
</code></pre>
<blockquote>
<p>时间复杂度：虽然看起来外层用了两个 for 循环，但是我们通过 used 数组保证了每个字符串只会访问 1 次，所以外层的复杂度是字符串数组的长度O（n），判断两个字符串相等的函数 equal 函数，时间复杂度是字符串的最长长度 O（K）。所以总共就是 O（nK）。<br>
空间复杂度：O（NK），用来存储结果。<br>
解法一算是比较通用的解法，不管字符串里边是大写字母，小写字母，数字，都可以用这个算法解决。这道题的话，题目告诉我们字符串中只有小写字母，针对这个限制，我们可以再用一些针对性强的算法。</p>
<p>解法三<br>
算术基本定理，又称为正整数的唯一分解定理，即：每个大于1的自然数，要么本身就是质数，要么可以写为2个以上的质数的积，而且这些质因子按大小排列之后，写法仅有一种方式。<br>
利用这个，我们把每个字符串都映射到一个正数上。<br>
用一个数组存储质数 prime = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103}。<br>
然后每个字符串的字符减去 ' a ' ，然后取到 prime 中对应的质数。把它们累乘。<br>
例如 abc ，就对应 'a' - 'a'， 'b' - 'a'， 'c' - 'a'，即 0, 1, 2，也就是对应素数 2 3 5，然后相乘 2 * 3 * 5 = 30，就把 &quot;abc&quot; 映射到了 30。</p>
</blockquote>
<pre><code>public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) {
    HashMap&lt;Integer, List&lt;String&gt;&gt; hash = new HashMap&lt;&gt;();
    //每个字母对应一个质数
    int[] prime = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103 };
    for (int i = 0; i &lt; strs.length; i++) {
        int key = 1;
        //累乘得到 key
        for (int j = 0; j &lt; strs[i].length(); j++) {
            key *= prime[strs[i].charAt(j) - 'a'];
        } 
        if (hash.containsKey(key)) {
            hash.get(key).add(strs[i]);
        } else {
            List&lt;String&gt; temp = new ArrayList&lt;String&gt;();
            temp.add(strs[i]);
            hash.put(key, temp);
        }

    }
    return new ArrayList&lt;List&lt;String&gt;&gt;(hash.values());
}
</code></pre>
<blockquote>
<p>时间复杂度：O（n * K），K 是字符串的最长长度。<br>
空间复杂度：O（NK），用来存储结果。<br>
这个解法时间复杂度，较解法二有提升，但是有一定的局限性，因为求 key 的时候用的是累乘，可能会造成溢出，超出 int 所能表示的数字。</p>
</blockquote>
<p>题解一是通用算法，使得不是26字母也能用，题解三是比较巧妙的算法，颇似原地swap等，但是同样地也有溢出的风险</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 242. 有效的字母异位词]]></title>
        <id>https://lixin-ee.github.io//post/zi-fu-chuan-242-you-xiao-de-zi-mu-yi-wei-ci</id>
        <link href="https://lixin-ee.github.io//post/zi-fu-chuan-242-you-xiao-de-zi-mu-yi-wei-ci">
        </link>
        <updated>2019-10-05T02:57:12.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
<p>示例 1:<br>
输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;<br>
输出: true<br>
示例 2:<br>
输入: s = &quot;rat&quot;, t = &quot;car&quot;<br>
输出: false<br>
说明:<br>
你可以假设字符串只包含小写字母。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/valid-anagram<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题也是简单题，非常适合用来夯实基础<br>
我一开始的思路是对于s每个存在的字母，都分别对s和t中该字母的数量进行count，注意顺序容器不像关联容器的count，没有自带的count，必须使用泛型算法中的count</p>
<pre><code>class Solution {
public:
    bool isAnagram(string s, string t) {
        int lens=s.size(),lent=t.size();
        if(lens!=lent)
            return false;
        for(auto c:s)
            if(count(s.begin(),s.end(),c)!=count(t.begin(),t.end(),c))
                return false;
        return true;
    }
};
</code></pre>
<p>提交的时候发现超时了，想想也是哦，count算法看起来很方便，其实背后是需要循环一遍字符串的，再加上外部的循环，等于时间复杂度位o(n^2)，实在不是一个好解法<br>
然后我想到了hashmap，可以先循环s，用map记录出现的单词和相应的次数，再循环t递减次数并监督是否有小于0的情况。但是后来转念一想，假设都是小写字母的话，一个大小为26的vector就足以应付了，所以得到代码如下</p>
<pre><code>class Solution {
public:
    bool isAnagram(string s, string t) {
        int lens=s.size(),lent=t.size();
        if(lens!=lent)
            return false;
        vector&lt;int&gt; vi(26,0);
        for(auto c:s)
            ++vi[c-'a'];
        for(auto c:t)
            if(--vi[c-'a']&lt;0)
                return false;
        return true;
    }
};
</code></pre>
<p>然后最后复习一遍快速排序吧，如果对空间复杂度有要求的话还是必须用快速排序，桶排序就不如前一种算法了。</p>
<pre><code>class Solution {
public:
    bool isAnagram(string s, string t) {
        int lens=s.size(),lent=t.size();
        if(lens!=lent)
            return false;
        Qsort(0,s.size()-1,s);
        Qsort(0,t.size()-1,t);
        if(s!=t)
            return false;
        return true;
    }
    
    void Qsort(int beg,int end,string &amp;s){
        if(beg&lt;end){
         int middle=partition(beg,end,s);
         Qsort(beg,middle-1,s);
         Qsort(middle+1,end,s);
        }
    }
    
    int partition(int beg,int end,string &amp;s){
        int flag=s[beg];
        while(beg&lt;end){
            while(beg&lt;end&amp;&amp;s[end]&gt;=flag)
                --end;
            swap(s[beg],s[end]);
            while(beg&lt;end&amp;&amp;s[beg]&lt;=flag)
                ++beg;
            swap(s[beg],s[end]);
        }
        return beg;
    }
};
</code></pre>
<p>快速排序有不少需要注意的地方，比如判断条件的设置和返回值的设置。<br>
最后看了一下官方题解，和我的思路一致。</p>
]]></content>
    </entry>
</feed>