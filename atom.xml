<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-04-04T05:01:02.637Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>千里之行，始于足下。不积跬步，无以至千里。</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[动态规划 198. 打家劫舍[简单]（不连续的元素最大和）]]></title>
        <id>https://lixin-scut.github.io//post/dong-tai-gui-hua-198-da-jia-jie-she-jian-dan</id>
        <link href="https://lixin-scut.github.io//post/dong-tai-gui-hua-198-da-jia-jie-she-jian-dan">
        </link>
        <updated>2020-04-04T04:35:51.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>
给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。<br>
示例 1:<br>
输入: [1,2,3,1]<br>
输出: 4<br>
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>
     偷窃到的最高金额 = 1 + 3 = 4 。<br>
示例 2:<br>
输入: [2,7,9,3,1]<br>
输出: 12<br>
解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。<br>
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/house-robber<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这个就是比较明显的一维动态规划了，和股票题比较像，<br>
状态主要有两种，1代表选择偷窃，0选择不偷窃<br>
然后状态转移<br>
如果选择偷窃，只能从前一天的不偷中累加<br>
如果选择不偷窃，则可以选择前一天的偷和不偷的最大值。</p>
<p>当然最后，最重要的还是题目的转化，这道题其实等同于 数组中不连续的元素的最大和，而不是题目中的故事，这种思维的转化值得学习</p>
<p>实现注意点</p>
<ol>
<li>为了压缩容器的维数，我使用了pair的vector，利用first代替不偷窃，second代替偷窃。</li>
<li>关于初始化，我选择的方法是初始化第一个元素，实际上也可以考虑把sums的纬度设为nums.size()+1，设置一个0号房屋，可以避开初始化。</li>
</ol>
<pre><code>class Solution {
public:
    int rob(vector&lt;int&gt;&amp; nums) {
        if(nums.empty())
        {   return 0; }
        vector&lt;pair&lt;int, int&gt;&gt; sums(nums.size(),make_pair(0,0));
        sums[0].second = nums[0];
        for(int i = 1; i &lt; nums.size(); ++i)
        {
            sums[i].first = max(sums[i - 1].first, sums[i - 1].second);
            sums[i].second = sums[i - 1].first + nums[i];
        }
        return max(sums.back().first, sums.back().second);
    }
};
</code></pre>
<p>这道题还是比较明显的，网友的题解一致<br>
网友题解：</p>
<blockquote>
<p>思路<br>
标签：动态规划</p>
<ol>
<li>动态规划方程：dp[n] = MAX( dp[n-1], dp[n-2] + num )</li>
<li>由于不可以在相邻的房屋闯入，所以在当前位置 n 房屋可盗窃的最大值，要么就是 n-1 房屋可盗窃的最大值，要么就是 n-2 房屋可盗窃的最大值加上当前房屋的值，二者之间取最大值</li>
<li>举例来说：1 号房间可盗窃最大值为 3 即为 dp[1]=3，2 号房间可盗窃最大值为 4 即为 dp[2]=4，3 号房间自身的值为 2 即为 num=2，那么 dp[3] = MAX( dp[2], dp[1] + num ) = MAX(4, 3+2) = 5，3 号房间可盗窃最大值为 5时间复杂度：O(n)，n 为数组长度</li>
</ol>
</blockquote>
<pre><code>class Solution {
    public int rob(int[] nums) {
        int len = nums.length;
        if(len == 0)
            return 0;
        int[] dp = new int[len + 1];
        dp[0] = 0;
        dp[1] = nums[0];
        for(int i = 2; i &lt;= len; i++) {
            dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i-1]);
        }
        return dp[len];
    }
}
作者：guanpengchn
链接：https://leetcode-cn.com/problems/house-robber/solution/hua-jie-suan-fa-198-da-jia-jie-she-by-guanpengchn/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图的最短路径]]></title>
        <id>https://lixin-scut.github.io//post/tu-de-zui-duan-lu-jing</id>
        <link href="https://lixin-scut.github.io//post/tu-de-zui-duan-lu-jing">
        </link>
        <updated>2020-04-03T09:13:14.000Z</updated>
        <content type="html"><![CDATA[<p>求图的最短路径主要有两种方法：迪杰斯特拉（Dijkstra)算法 和 弗洛伊德（Floyd）算法</p>
<h3 id="最短路径">最短路径</h3>
<p>对于网图来说，最短路径，是指两顶点之间经过的边上<strong>权值之和最少</strong>的路径，并且我们称路径上的第—个顶点是源点，最后一个顶点是终点。</p>
<h3 id="迪杰斯特拉dijkstra算法">迪杰斯特拉（Dijkstra)算法</h3>
<p>按路径长度递增的次序产生最短路径的算法<br>
迪杰斯特拉（Dijkstra)算法：并不是一下子就求出了最短路径，而是一步步求出它们之间顶点的最短路径，过程中都 是基于已经求出的最短路径的基础上，求得更远顶点的最短路径，最终得到你要的结果。<br>
邻接矩阵MGraph：</p>
<pre><code>#define MAXVEX 9
#define INFINITY 65535
typedef int Pathmatirx[MAXVEX]; // 用于存储最短路径下标的数组
typedef int ShortPathTable[MAXVEX]; // 用于存储到各点最短路径的权值和
// Dijkstra算法 ， 求有向网G的V0顶点到其余顶点V最短路径P[v]及带权长度D[v]
// P[V]的值为前驱顶点下标，D[V]表示V0到V的最短路径长度和。

void ShortestPath_Dijkstra(MGraph G, 
                                            int v0, 
																						PathMatirx *P, 
																						ShortPathTable *D)
{
	int v, w, k, min;
	int final[MAXVEX]; // final[w] = 1 表示求得顶点V0到Vw的最短路径
	for(v = 0; v &lt; G.numVertexex; ++v)  // 初始化数据
	{
		final[v] = 0; // 全部顶点初始化为未知最短路径状态
		(*D)[v] = G.matirx[v0][v]; // 将与V0点有连线的顶点机上权值
		(*P)[v] = 0; // 初始化路径数组P为0
	}
	(*D)[v0] = 0; // V0到V0路径为0
	final[v0] = 1; // V0到V0不需要求路径
	// 开始主循环，每次求得V0到某个v顶点的最短路径
	for( v = 1; v &lt; G.numVertexex; ++v)
	{
		min = INFINITY; // 当前所知离V0顶点的最近距离
		for(w = 0; w &lt; G.numVertexex; ++w) // 寻找离V0最近的顶点
		{
			if(!final[w] &amp;&amp; (*D)[w] &lt; min)
			{
				k = w;
				min = (*D)[w]; // w顶点离V0顶点更近
			}
		}
		final[k] = 1; // 将目前找到的最近的顶点置为1
		for(w = 0; w &lt; G.numVertexex; ++w) // 修正当前最短路径及距离
		{
			// 如果经过V顶点的路径比现在这条路径的长度短的话
			if(!final[w] &amp;&amp; (min + G.matirx[k][w] &lt; (*D)[w]))
			{ // 说明找到了更短的路径，修改D[w] 和 P[w]
				(*D)[w] = min + G.matirx[k][w]; // 修改当前路径changed
				(*P)[w] = k; // 前驱顶点下标
			}
		}
	}
}
</code></pre>
<p><img src="https://lixin-scut.github.io//post-images/1585921461798.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1585921481678.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1585921500561.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1585921522817.png" alt=""><br>
通过迪杰斯特拉（Dijkstra)算法解决了从某个源点到其余各顶点的最 短路径问题。从循环嵌套可以很容易得到此算法的时间复杂度为O(n^2)<br>
可不可以只找到从源点到某一个特定终点的最短路径，其实这个问题和求源点到其他所有 顶点的最短路径一样复杂，时间复杂度依然是O(n^2)（要考虑整体）<br>
任一顶点到其余所有顶点的最短路径：对每个顶点当作源点运行一次迪杰斯特拉(Dijkstra)算法，等于在 原有算法的基础上，再来一次循环，此时整个算法的时间复杂度就成了O(n^3)</p>
<h3 id="弗洛伊德floyd算法">弗洛伊德（Floyd）算法</h3>
<p><img src="https://lixin-scut.github.io//post-images/1585921596616.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1585921624861.png" alt=""></p>
<pre><code>typedef int Pathmatirx[MAXVEX][MAXVEX]; 
typedef int ShortPathTable[MAXVEX][MAXVEX];
// Floyd算法，求网图G中各顶点V到其余顶点w最短路径P[v][w]及带权长度D[v][w]

void ShortestPath_Floyd(MGraph G, PathMatirx *P, ShortPathTable *D)
{
	int v, w, k;
	for(v = 0; v &lt; G.numVertexes; ++v) // 初始化D与P
	{
			for(w = 0; w &lt; G.numVertexes; ++w)
			{
				(*D)[v][w] = G.matirx[v][w]; // D[v][w]值即为对应点间的权值
				(*P)[v][w] = w; // 初始化P
			}
	}
	for(k = 0; k &lt; G.numVertexes; ++k)
	{
		for(v = 0; v &lt; G.numVertexes; ++v)
		{
			for(w = 0; w &lt; G.numVertexes; ++w)
			{
				if((*D)[v][w] &gt; (*D)[v][k] + (*D)[k][w])
				{ 
					// 如果经过下标为k顶点路径比原两点间的路径更短
					// 将当前两点间权值设为更小的一个
					(*D)[v][w] = (*D)[v][k] + (*D)[k][w];
					(*P)[v][w] = (*P)[v][k];
				}
			}
		}
	}
}
</code></pre>
<p><img src="https://lixin-scut.github.io//post-images/1585922753839.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1585922776967.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1585922814727.png" alt=""><br>
弗洛伊德（Floyd）时间复杂度也是O(n^3) 算法非常简洁优雅<br>
由于它的三重循环，因此也是了O(n^3)时间 复杂度。如果你面临需要求所有顶点至所有顶点的最短路径问题时，弗洛伊德（Floyd)算法 应该是不错的选择。<br>
对求最短路径的两个算法举例都是无向图，但它们对有向图依然有效， 因为二者的差异仅仅是邻接矩阵是否对称而已。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[回溯 679. 24 点游戏[困难][未做出]]]></title>
        <id>https://lixin-scut.github.io//post/hui-su-679-24-dian-you-xi-kun-nan-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/hui-su-679-24-dian-you-xi-kun-nan-wei-zuo-chu">
        </link>
        <updated>2020-04-03T02:12:42.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 *，/，+，-，(，) 的运算得到 24。<br>
示例 1:<br>
输入: [4, 1, 8, 7]<br>
输出: True<br>
解释: (8-4) * (7-1) = 24<br>
示例 2:<br>
输入: [1, 2, 1, 2]<br>
输出: False<br>
注意:<br>
除法运算符 / 表示实数除法，而不是整数除法。例如 4 / (1 - 2/3) = 12 。<br>
每个运算符对两个数进行运算。特别是我们不能用 - 作为一元运算符。例如，[1, 1, 1, 1] 作为输入时，表达式 -1 - 1 - 1 - 1 是不允许的。<br>
你不能将数字连接在一起。例如，输入为 [1, 2, 1, 2] 时，不能写成 12 + 12 。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/24-game<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>从注意事项中得出的难点：</p>
<ol>
<li>实数除法，这个实在是太棘手了，也就是说不能用整型类型来保存，必须用浮点数。</li>
<li>第一个数前面的符号只能是括号，然后运算符必须在括号之前，防止出现(-1+1)的情况（这里我的理解出现了点偏差，其实不是必须四个数按顺序，可以任意组合顺序）</li>
<li>除第一个数字外，每个数字之前必须插入运算符，且只有一个运算符（不包含括号）</li>
</ol>
<p>解题思路：<br>
1.第一点最棘手的就是括号问题，想到的一个方法就是既然有不确定的括号，那还不如都加上括号，或者都去掉括号。<br>
2.从都加上括号出发，就必须预留足够的空间加上括号（最极端的情况有4个）<br>
3.从都去掉括号出发，直接忽略括号，可以把数字进行组合运算，然后将得到的结果视为一个新数字，比如 4，1，8，7组合为4，6 再组合为24<br>
这样子其实就是暗中消除掉了括号，有点像归并法吧</p>
<p>但是有一个问题，就是一开始我想着是两两组合<br>
但是明显（1 + 2 + 3）* 4的情况是无法两两组合的<br>
还是必须逐个相加<br>
本来想着动态规划保存每个状态，但是很明显状态特别多。。。。以至于可能要构造一个很高维的数组并且进行很深的循环<br>
还是先看一下官方题解吧<br>
官方题解使用的是回溯法，直接对所有情况进行递归遍历<br>
实现中需要注意的点：</p>
<ol>
<li>double不能直接和0比较，只能判断精度</li>
<li>加法和乘法有可交换性，可能会造成重复，可以剪枝</li>
<li>记得一定要回溯消除最后一个元素恢复状态</li>
<li>默认返回false</li>
</ol>
<pre><code>class Solution {
public:
    bool judgePoint24(vector&lt;int&gt;&amp; nums) {
        vector&lt;double&gt; numsD;
        for(int num : nums)
        {
            numsD.push_back(static_cast&lt;double&gt;(num));
        }
        return judgePoint24(numsD);
        
    }
    
    bool judgePoint24(vector&lt;double&gt;&amp; numsD)
    {
        if(0 == numsD.size())
        {   return false; }
        if(1 == numsD.size())
        {   return abs(numsD[0] - 24) &lt; pow(0.1, 6); } // 这里的abs取绝对值不能去掉
        
        for(int i = 0; i &lt; numsD.size(); ++i)
        {
            for(int j = 0; j &lt; numsD.size(); ++j)
            {
                if(i != j)
                {
                    vector&lt;double&gt; numsTemp;
                    for(int k = 0; k &lt; numsD.size(); ++k)
                    {
                        if(k != i &amp;&amp; k != j) // i、j为两个选定进行运算的数字，剩下的加入numsTemp等待下一次运算
                        {
                            numsTemp.push_back(numsD[k]);
                        }
                    }
                    for(int k = 0; k &lt; 4; k++)
                    {
                        if(k &lt; 2 &amp;&amp; j &gt; i) { continue; } // 加法和乘法有可交换性，可能会造成重复，直接剪枝
                        if(0 == k) { numsTemp.push_back(numsD[i] + numsD[j]); }
                        if(1 == k) { numsTemp.push_back(numsD[i] * numsD[j]); }
                        if(2 == k) { numsTemp.push_back(numsD[i] - numsD[j]); }
                        if(3 == k)
                        {
                            if(numsD[j] != 0)
                            {
                                numsTemp.push_back(numsD[i] / numsD[j]);
                            }
                            else
                            {
                                continue;
                            }
                        }
                        if(judgePoint24(numsTemp))
                        {
                            return true;
                        }
                        numsTemp.pop_back(); // 记得一定要回溯消除最后一个元素恢复状态
                    }
                }
            }
        }
        return false; // 默认返回false
    }
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>方法：回溯<br>
思路和算法<br>
只有 4 张牌，且只能执行 4 种操作。即使所有运算符都不进行交换，最多也只有 12∗6∗2∗4∗4∗4=9216 种可能性，这使得我们可以尝试所有这些可能。<br>
具体来说，我们有 12 种方式先选出两个数字（有序），并执行 4 种操作之一（12 * 4）。然后，剩下 3 个数字，我们从中选择 2 个并执行 4 种操作之一（6 * 4）。<br>
最后我们剩下两个数字，并在 2 * 4 种可能之中作出最终选择。<br>
我们将对我们的数字或结果数字执行 3 次二元运算（+，-，*，/ 是运算）。因为 - 和 / 不满足交换律，我们必须仔细考虑 a / b 和 b / a。<br>
对于在我们的列表中移除 a, b 这两个数字的每一种方法，以及它们可能产生的每种结果，如 a + b、a / b等，我们将采用递归的方法解决这个较小的数字列表上的问题。</p>
</blockquote>
<pre><code>class Solution {
    public boolean judgePoint24(int[] nums) {
        ArrayList A = new ArrayList&lt;Double&gt;();
        for (int v: nums) A.add((double) v);
        return solve(A);
    }
    private boolean solve(ArrayList&lt;Double&gt; nums) {
        if (nums.size() == 0) return false;
        if (nums.size() == 1) return Math.abs(nums.get(0) - 24) &lt; 1e-6;

        for (int i = 0; i &lt; nums.size(); i++) {
            for (int j = 0; j &lt; nums.size(); j++) {
                if (i != j) {
                    ArrayList&lt;Double&gt; nums2 = new ArrayList&lt;Double&gt;();
                    for (int k = 0; k &lt; nums.size(); k++) if (k != i &amp;&amp; k != j) {
                        nums2.add(nums.get(k));
                    }
                    for (int k = 0; k &lt; 4; k++) {
                        if (k &lt; 2 &amp;&amp; j &gt; i) continue;
                        if (k == 0) nums2.add(nums.get(i) + nums.get(j));
                        if (k == 1) nums2.add(nums.get(i) * nums.get(j));
                        if (k == 2) nums2.add(nums.get(i) - nums.get(j));
                        if (k == 3) {
                            if (nums.get(j) != 0) {
                                nums2.add(nums.get(i) / nums.get(j));
                            } else {
                                continue;
                            }
                        }
                        if (solve(nums2)) return true;
                        nums2.remove(nums2.size() - 1);
                    }
                }
            }
        }
        return false;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(1)，总计 9216 种可能的硬性限制，对于每种可能，我们执行操作的复杂度为O(1)。<br>
空间复杂度：O(1)，我们的中间数组最多有 4 个元素，所生成的数字由复杂度 O(1) 的因子限定。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 887. 鸡蛋掉落[困难][未做出]]]></title>
        <id>https://lixin-scut.github.io//post/dong-tai-gui-hua-887-ji-dan-diao-luo-kun-nan-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/dong-tai-gui-hua-887-ji-dan-diao-luo-kun-nan-wei-zuo-chu">
        </link>
        <updated>2020-04-02T02:26:53.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。<br>
每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。<br>
你知道存在楼层 F ，满足 0 &lt;= F &lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。<br>
每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &lt;= X &lt;= N）。<br>
你的目标是确切地知道 F 的值是多少。<br>
示例 1：<br>
输入：K = 1, N = 2<br>
输出：2<br>
解释：<br>
鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。<br>
否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。<br>
如果它没碎，那么我们肯定知道 F = 2 。<br>
因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。<br>
示例 2：<br>
输入：K = 2, N = 6<br>
输出：3<br>
示例 3：<br>
输入：K = 3, N = 14<br>
输出：4<br>
提示：<br>
1 &lt;= K &lt;= 100<br>
1 &lt;= N &lt;= 10000<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/super-egg-drop<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题算是比较经典的面试题了，题目的思想和解题方法都相对比较反常规思路，值得慢慢琢磨。<br>
1.题目思想：最坏情况的最少次数，这个比较绕，<br>
首先必须注意最坏情况是对于<strong>特定的策略</strong>来说，比如采用线性扫描的话，最坏情况就是第N层才摔坏，必须试N次（注意此处不考虑排除法）。然后如果采用二分法的话，最坏情况就是最边缘嘛，转化过来也就是二叉树走到叶节点才发现目标值，也就是logn。<br>
此时，我们希望得到的最少次数也就是总楼层确定、针对特定策略定下摔坏层数的情况下，<strong>不同的策略</strong>之间比较能够得到的最小次数<br>
这样才能解析为什么状态转移公式中既有min（最小次数），也有max（最坏情况）<br>
2.鸡蛋个数的限制<br>
鸡蛋个数的限制其实会直接废弃很多策略，最典型的就是最快的二分法。</p>
<pre><code>class Solution {
public:
    int superEggDrop(int K, int N) {
        vector&lt;vector&lt;int&gt;&gt; counts(K + 1, vector&lt;int&gt;(N + 1, -1));
        return superEggDrop(K, N, counts) ;
    }
    
		// 动态规划-线性遍历
    int superEggDrop(int K, int N, vector&lt;vector&lt;int&gt;&gt;&amp; counts)
    {
        if(K == 1)
        {
            return N;
        }
        if(N == 0)
        {
            return 0;
        }
        
        if(counts[K][N] != -1)
        {
            return counts[K][N];
        }
        
        int res = INT_MAX;
        for(int i = 1;i &lt; N + 1; ++i)
        {
            res = min(res, 1 + max(superEggDrop(K, N - i, counts), superEggDrop(K - 1, i - 1, counts)));
        }
        counts[K][N] = res;
        return res;
    }
		
		// 动态规划-二分查找
		int superEggDrop(int K, int N, vector&lt;vector&lt;int&gt;&gt;&amp; counts)
    {
        if(K == 1)
        {
            return N;
        }
        if(N == 0)
        {
            return 0;
        }
        
        if(counts[K][N] != -1)
        {
            return counts[K][N];
        }
        
        int res = INT_MAX;
        int low, high;
        low = 1;
        high = N;
        while(low &lt;= high)
        {
            int mid = low + (high - low) / 2;
            int unbroken = superEggDrop(K, N - mid, counts);
            int broken = superEggDrop(K - 1, mid - 1, counts);
            
            if(unbroken &gt; broken)
            {
                low = mid + 1;
                res = min(res, unbroken + 1);
            }
            else
            {
                high = mid - 1;
                res = min(res, broken + 1);
            }
        }
        
        counts[K][N] = res;
        return res;
    }
};
</code></pre>
<p>网友题解：<br>
一、解析题目<br>
题目是这样：你面前有一栋从 1 到 N 共 N 层的楼，然后给你 K 个鸡蛋（K 至少为 1）。现在确定这栋楼存在楼层 0 &lt;= F &lt;= N，在这层楼将鸡蛋扔下去，鸡蛋恰好没摔碎（高于 F 的楼层都会碎，低于 F 的楼层都不会碎）。现在问你，最坏情况下，你至少要扔几次鸡蛋，才能确定这个楼层 F 呢？<br>
也就是让你找摔不碎鸡蛋的最高楼层 F，但什么叫「最坏情况」下「至少」要扔几次呢？我们分别举个例子就明白了。<br>
比方说现在先不管鸡蛋个数的限制，有 7 层楼，你怎么去找鸡蛋恰好摔碎的那层楼？<br>
最原始的方式就是线性扫描：我先在 1 楼扔一下，没碎，我再去 2 楼扔一下，没碎，我再去 3 楼……<br>
以这种策略，最坏情况应该就是我试到第 7 层鸡蛋也没碎（F = 7），也就是我扔了 7 次鸡蛋。<br>
先在你应该理解什么叫做「最坏情况」下了，鸡蛋破碎一定发生在搜索区间穷尽时，不会说你在第 1 层摔一下鸡蛋就碎了，这是你运气好，不是最坏情况。<br>
现在再来理解一下什么叫「至少」要扔几次。依然不考虑鸡蛋个数限制，同样是 7 层楼，我们可以优化策略。<br>
最好的策略是使用二分查找思路，我先去第 (1 + 7) / 2 = 4 层扔一下：<br>
如果碎了说明 F 小于 4，我就去第 (1 + 3) / 2 = 2 层试……<br>
如果没碎说明 F 大于等于 4，我就去第 (5 + 7) / 2 = 6 层试……<br>
以这种策略，最坏情况应该是试到第 7 层鸡蛋还没碎（F = 7），或者鸡蛋一直碎到第 1 层（F = 0）。然而无论那种最坏情况，只需要试 log7 向上取整等于 3 次，比刚才尝试 7 次要少，这就是所谓的至少要扔几次。<br>
PS：这有点像 Big O 表示法计算算法的复杂度。<br>
实际上，如果不限制鸡蛋个数的话，二分思路显然可以得到最少尝试的次数，但问题是，现在给你了鸡蛋个数的限制 K，直接使用二分思路就不行了。<br>
比如说只给你 1 个鸡蛋，7 层楼，你敢用二分吗？你直接去第 4 层扔一下，如果鸡蛋没碎还好，但如果碎了你就没有鸡蛋继续测试了，无法确定鸡蛋恰好摔不碎的楼层 F 了。这种情况下只能用线性扫描的方法，算法返回结果应该是 7。<br>
有的读者也许会有这种想法：二分查找排除楼层的速度无疑是最快的，那干脆先用二分查找，等到只剩 1 个鸡蛋的时候再执行线性扫描，这样得到的结果是不是就是最少的扔鸡蛋次数呢？<br>
很遗憾，并不是，比如说把楼层变高一些，100 层，给你 2 个鸡蛋，你在 50 层扔一下，碎了，那就只能线性扫描 1～49 层了，最坏情况下要扔 50 次。<br>
如果不要「二分」，变成「五分」「十分」都会大幅减少最坏情况下的尝试次数。比方说第一个鸡蛋每隔十层楼扔，在哪里碎了第二个鸡蛋一个个线性扫描，总共不会超过 20 次。<br>
最优解其实是 14 次。最优策略非常多，而且并没有什么规律可言。<br>
说了这么多废话，就是确保大家理解了题目的意思，而且认识到这个题目确实复杂，就连我们手算都不容易，如何用算法解决呢？</p>
<p>二、思路分析<br>
对动态规划问题，直接套我们以前多次强调的框架即可：这个问题有什么「状态」，有什么「选择」，然后穷举。<br>
「状态」很明显，就是当前拥有的鸡蛋数 K 和需要测试的楼层数 N。随着测试的进行，鸡蛋个数可能减少，楼层的搜索范围会减小，这就是状态的变化。<br>
「选择」其实就是去选择哪层楼扔鸡蛋。回顾刚才的线性扫描和二分思路，二分查找每次选择到楼层区间的中间去扔鸡蛋，而线性扫描选择一层层向上测试。不同的选择会造成状态的转移。<br>
现在明确了「状态」和「选择」，动态规划的基本思路就形成了：肯定是个二维的 dp 数组或者带有两个状态参数的 dp 函数来表示状态转移；外加一个 for 循环来遍历所有选择，择最优的选择更新状态：</p>
<h1 id="当前状态为-k-个鸡蛋面对-n-层楼">当前状态为 K 个鸡蛋，面对 N 层楼</h1>
<h1 id="返回这个状态下的最优结果">返回这个状态下的最优结果</h1>
<pre><code>def dp(K, N):
    int res
    for 1 &lt;= i &lt;= N:
        res = min(res, 这次在第 i 层楼扔鸡蛋)
    return res
</code></pre>
<p>这段伪码还没有展示递归和状态转移，不过大致的算法框架已经完成了。<br>
我们选择在第 i 层楼扔了鸡蛋之后，可能出现两种情况：鸡蛋碎了，鸡蛋没碎。注意，这时候状态转移就来了：</p>
<p>如果鸡蛋碎了，那么鸡蛋的个数 K 应该减一，搜索的楼层区间应该从 [1..N] 变为 [1..i-1] 共 i-1 层楼；</p>
<p>如果鸡蛋没碎，那么鸡蛋的个数 K 不变，搜索的楼层区间应该从 [1..N] 变为 [i+1..N] 共 N-i 层楼。<br>
<img src="https://lixin-scut.github.io//post-images/1585795304992.png" alt=""><br>
PS：细心的读者可能会问，在第i层楼扔鸡蛋如果没碎，楼层的搜索区间缩小至上面的楼层，是不是应该包含第i层楼呀？不必，因为已经包含了。开头说了 F 是可以等于 0 的，向上递归后，第i层楼其实就相当于第 0 层，可以被取到，所以说并没有错误。</p>
<p>因为我们要求的是最坏情况下扔鸡蛋的次数，所以鸡蛋在第 i 层楼碎没碎，取决于那种情况的结果更大：</p>
<pre><code>def dp(K, N):
    for 1 &lt;= i &lt;= N:
        # 最坏情况下的最少扔鸡蛋次数
        res = min(res, 
                  max( 
                        dp(K - 1, i - 1), # 碎
                        dp(K, N - i)      # 没碎
                     ) + 1 # 在第 i 楼扔了一次
                 )
    return res
</code></pre>
<p>递归的 base case 很容易理解：当楼层数 N 等于 0 时，显然不需要扔鸡蛋；当鸡蛋数 K 为 1 时，显然只能线性扫描所有楼层：</p>
<pre><code>def dp(K, N):
    if K == 1: return N
    if N == 0: return 0
    ...
</code></pre>
<p>至此，其实这道题就解决了！只要添加一个备忘录消除重叠子问题即可：</p>
<pre><code>def superEggDrop(K: int, N: int):

    memo = dict()
    def dp(K, N) -&gt; int:
        # base case
        if K == 1: return N
        if N == 0: return 0
        # 避免重复计算
        if (K, N) in memo:
            return memo[(K, N)]

        res = float('INF')
        # 穷举所有可能的选择
        for i in range(1, N + 1):
            res = min(res, 
                      max(
                            dp(K, N - i), 
                            dp(K - 1, i - 1)
                         ) + 1
                  )
        # 记入备忘录
        memo[(K, N)] = res
        return res
    
    return dp(K, N)
</code></pre>
<p>这个算法的时间复杂度是多少呢？动态规划算法的时间复杂度就是子问题个数 × 函数本身的复杂度。<br>
函数本身的复杂度就是忽略递归部分的复杂度，这里 dp 函数中有一个 for 循环，所以函数本身的复杂度是 O(N)。<br>
子问题个数也就是不同状态组合的总数，显然是两个状态的乘积，也就是 O(KN)。<br>
所以算法的总时间复杂度是 O(K*N^2), 空间复杂度 O(KN)。</p>
<p>三、疑难解答</p>
<p>这个问题很复杂，但是算法代码却十分简洁，这就是动态规划的特性，穷举加备忘录/DP table 优化，真的没啥新意。<br>
首先，有读者可能不理解代码中为什么用一个 for 循环遍历楼层 [1..N]，也许会把这个逻辑和之前探讨的线性扫描混为一谈。其实不是的，这只是在做一次「选择」。<br>
比方说你有 2 个鸡蛋，面对 10 层楼，你这次选择去哪一层楼扔呢？不知道，那就把这 10 层楼全试一遍。至于下次怎么选择不用你操心，有正确的状态转移，递归会算出每个选择的代价，我们取最优的那个就是最优解。<br>
另外，这个问题还有更好的解法，比如修改代码中的 for 循环为二分搜索，可以将时间复杂度降为 O(K*N*logN)；再改进动态规划解法可以进一步降为 O(KN)；使用数学方法解决，时间复杂度达到最优 O(K*logN)，空间复杂度达到 O(1)。<br>
二分的解法也有点误导性，你很可能以为它跟我们之前讨论的二分思路扔鸡蛋有关系，实际上没有半毛钱关系。能用二分搜索是因为状态转移方程的函数图像具有单调性，这里就不展开以上解法了。我觉得吧，我们这种解法就够了：找状态，做选择，足够清晰易懂，可流程化，可举一反三。掌握这套框架学有余力的话，再去考虑那些奇技淫巧也不迟。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++中各种类型表示范围测试代码（最大最小值）]]></title>
        <id>https://lixin-scut.github.io//post/czhong-ge-chong-lei-xing-biao-shi-fan-wei-ce-shi-dai-ma-zui-da-zui-xiao-zhi</id>
        <link href="https://lixin-scut.github.io//post/czhong-ge-chong-lei-xing-biao-shi-fan-wei-ce-shi-dai-ma-zui-da-zui-xiao-zhi">
        </link>
        <updated>2020-03-29T03:00:43.000Z</updated>
        <content type="html"><![CDATA[<p>不同的机器上可以所占的字节数和可以表示的范围不尽相同<br>
特别是32位和64位之差。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include &lt;limits&gt;
using namespace std;

int main()
{
    cout &lt;&lt; &quot;type: \t\t&quot; &lt;&lt; &quot;************size**************&quot;&lt;&lt; endl;
    cout &lt;&lt; &quot;bool: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(bool);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;bool&gt;::max)();
    cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;bool&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;char: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(char);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;char&gt;::max)();
    cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;char&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;signed char: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(signed char);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;signed char&gt;::max)();
    cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;signed char&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;unsigned char: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(unsigned char);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;unsigned char&gt;::max)();
    cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;unsigned char&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;wchar_t: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(wchar_t);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;wchar_t&gt;::max)();
    cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;wchar_t&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;short: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(short);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;short&gt;::max)();
    cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;short&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;int: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(int);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;int&gt;::max)();
    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;int&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;unsigned: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(unsigned);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;unsigned&gt;::max)();
    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;unsigned&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;long: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(long);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;long&gt;::max)();
    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;long&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;unsigned long: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(unsigned long);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;unsigned long&gt;::max)();
    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;unsigned long&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;double: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(double);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;double&gt;::max)();
    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;double&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;long double: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(long double);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;long double&gt;::max)();
    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;long double&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;float: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(float);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;float&gt;::max)();
    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;float&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;size_t: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(size_t);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;size_t&gt;::max)();
    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;size_t&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;string: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(string) &lt;&lt; endl;
    // &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;string&gt;::max)() &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;string&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;type: \t\t&quot; &lt;&lt; &quot;************size**************&quot;&lt;&lt; endl;
    return 0;
}
</code></pre>
<p>64位macOS下Clion输出结果</p>
<pre><code>type: 		************size**************
bool: 		所占字节数：1	最大值：1		最小值：0
char: 		所占字节数：1	最大值：		最小值：�
signed char: 	所占字节数：1	最大值：		最小值：�
unsigned char: 	所占字节数：1	最大值：�		最小值：�
wchar_t: 	所占字节数：4	最大值：2147483647		最小值：-2147483648
short: 		所占字节数：2	最大值：32767		最小值：-32768
int: 		所占字节数：4	最大值：2147483647	最小值：-2147483648
unsigned: 	所占字节数：4	最大值：4294967295	最小值：0
long: 		所占字节数：8	最大值：9223372036854775807	最小值：-9223372036854775808
unsigned long: 	所占字节数：8	最大值：18446744073709551615	最小值：0
double: 	所占字节数：8	最大值：1.79769e+308	最小值：2.22507e-308
long double: 	所占字节数：16	最大值：1.18973e+4932	最小值：3.3621e-4932
float: 		所占字节数：4	最大值：3.40282e+38	最小值：1.17549e-38
size_t: 	所占字节数：8	最大值：18446744073709551615	最小值：0
string: 	所占字节数：32
type: 		************size**************

Process finished with exit code 0

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 377. 组合总和 Ⅳ[中等]]]></title>
        <id>https://lixin-scut.github.io//post/dong-tai-gui-hua-377-zu-he-zong-he-ivzhong-deng</id>
        <link href="https://lixin-scut.github.io//post/dong-tai-gui-hua-377-zu-he-zong-he-ivzhong-deng">
        </link>
        <updated>2020-03-29T02:46:17.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。<br>
示例:<br>
nums = [1, 2, 3]<br>
target = 4<br>
所有可能的组合为：<br>
(1, 1, 1, 1)<br>
(1, 1, 2)<br>
(1, 2, 1)<br>
(1, 3)<br>
(2, 1, 1)<br>
(2, 2)<br>
(3, 1)<br>
请注意，顺序不同的序列被视作不同的组合。<br>
因此输出为 7。<br>
进阶：<br>
如果给定的数组中含有负数会怎么样？<br>
问题会产生什么变化？<br>
我们需要在题目中添加什么限制来允许负数的出现？</p>
</blockquote>
<p>这道题也好像斐波那契<br>
就是把每个数存在的情况加起来<br>
重点就在于顺序不同的序列被当成不同的组合<br>
它的类似题目是<br>
<a href="https://lixin-scut.github.io/post/dong-tai-gui-hua-322-ling-qian-dui-huan-zhong-deng/">动态规划 322. 零钱兑换[中等]</a><br>
这里的区别是计算可以凑成目标值所需的最少的数字个数<br>
<a href="https://lixin-scut.github.io/post/dong-tai-gui-hua-518-ling-qian-dui-huan-iizhong-deng-wei-zuo-chu/">动态规划 518. 零钱兑换 II[中等][未做出]</a><br>
这里的区别是只考虑组合不考虑排列，顺序不同的序列被当成相同的组合</p>
<p>尴尬，超时了。。。<br>
有一个问题是有些情况根本达不到的，但是却会导致超级大的数。<br>
然后必须用unsigned int来定义容器类型<br>
但是我用long就还是会爆炸。。。以后得找一下原因</p>
<pre><code>class Solution {
public:
    int combinationSum4(vector&lt;int&gt;&amp; nums, int target) {
        if(0 == target)
        {   return 1;}
        if(nums.empty())
        {   return 0;}
        
        vector&lt;unsigned int&gt; counts(target + 1, 0);
        counts[0] = 1;
        for(int i = 1; i &lt; target + 1; ++i)
        {
            for(auto num : nums)
            {
                if(num &lt;= i)
                {
                     counts[i] +=  counts[i - num]; 
                    //counts[i] = (counts[i] &gt;= INT_MAX - counts[i - num])? 
                    //    INT_MAX : counts[i] + counts[i - num];
                }
            }
        }
        return counts.back();
    }
};
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>题意分析：<br>
输入数组的每个元素可以使用多次，这一点和「完全背包」问题有点像；<br>
顺序不同的序列被视作不同的组合，这一点和所有的「背包问题」都不同，与 518. 零钱兑换 II 问题不同的地方就在这一点。<br>
思路分析：<br>
遇到这一类问题，做一件事情有很多种做法，每一种做法有若干个步骤，脑子里能想到的常规思路大概有「回溯搜索」、「动态规划」；<br>
由于不用得到具体的组合表示，因此考虑使用「动态规划」来解。<br>
https://pic.leetcode-cn.com/fa278029267fedeb06686b784bd322f16b2abf6b61987dc3b5257630570cd38f-377-1.png<br>
很容易发现「重复问题」，因此，我们可以使用「动态规划」来做，如果题目问具体的解，那么用「回溯搜索」做（「力扣」第 39 题：组合之和）。<br>
递归求解：由于有大量「重复子问题」，因此必须使用缓存，以避免相同问题重复求解，这个方法叫「记忆化搜索」，在《算法导论》这本书上也把它归入到「动态规划」的定义中。这种思考问题的方式是「从上到下」的，直接面对问题求解，遇到什么问题，就解决什么问题，同时记住结果；<br>
「动态规划」告诉了我们另一种思考问题的方式：「从底向上」，可以不直接面对问题求解，从这个问题最小的样子开始，通过逐步递推，至到得到所求的问题的答案。<br>
虽然这个问题没有明显的「最优子结构」，但这种「从底向上」递推的思路是很深刻的，我们也把它归纳到「动态规划」的解法中。</p>
</blockquote>
<blockquote>
<p>方法：动态规划<br>
“动态规划”的两个步骤是思考“状态”以及“状态转移方程”。<br>
1、状态<br>
对于“状态”，我们首先思考能不能就用问题当中问的方式定义状态，上面递归树都画出来了。当然就用问题问的方式。<br>
dp[i] ：对于给定的由正整数组成且不存在重复数字的数组，和为 i 的组合的个数。<br>
思考输出什么？因为状态就是问题当中问的方式而定义的，因此输出就是最后一个状态 dp[n]。<br>
2、状态转移方程<br>
由上面的树形图，可以很容易地写出状态转移方程：<br>
dp[i] = sum{dp[i - num] for num in nums and if i &gt;= num}<br>
注意：在 0 这一点，我们定义 dp[0] = 1 的，它表示如果 nums 里有一个数恰好等于 target，它单独成为 1 种可能。<br>
参考代码：</p>
</blockquote>
<pre><code>Java
public class Solution {

    /**
     * 这里状态定义就是题目要求的，并不难，状态转移方程要动点脑子，也不难：
     * 状态转移方程：dp[i]= dp[i - nums[0]] + dp[i - nums[1]] + dp[i - nums[2]] + ... （当 [] 里面的数 &gt;= 0）
     * 特别注意：dp[0] = 1，表示，如果那个硬币的面值刚刚好等于需要凑出的价值，这个就成为 1 种组合方案
     * 再举一个具体的例子：nums=[1, 3, 4], target=7;
     * dp[7] = dp[6] + dp[4] + dp[3]
     * 即：7 的组合数可以由三部分组成，1 和 dp[6]，3 和 dp[4], 4 和dp[3];
     *
     * @param nums
     * @param target
     * @return
     */
    public int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target + 1];
        // 这个值被其它状态参考，设置为 1 是合理的
        dp[0] = 1;

        for (int i = 1; i &lt;= target; i++) {
            for (int num : nums) {
                if (num &lt;= i) {
                    dp[i] += dp[i - num];
                }
            }
        }
        return dp[target];
    }
}
</code></pre>
<blockquote>
<p>对于进阶问题的思考<br>
1、如果给定的数组中含有负数会怎么样？问题会产生什么变化？<br>
如果有负数，相当于给定数组中的元素有了更多的组合，特别是出现了一对相反数的时候，例如题目中的示例 [-4, 1, 2, 3, 4]，target = 4 的时候，-4 和 4 可以无限次地、成对添加到题目中的示例中，成为新的组合，那么这道问题就没有什么意义了。<br>
仔细思考，负数我只要不选它就行了。但由于这道问题的问法是“组合”，因此我们要保证有负数参与进来，不能够与已有的正数的组合之和为 0 即可。<br>
2、我们需要在题目中添加什么限制来允许负数的出现？<br>
如果有负数参与进来，不能够与已有的正数的组合之和为 0 ；<br>
或者限制负数的使用次数，设计成类似 0-1 背包问题的样子。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 139. 单词拆分[中等][未做出]]]></title>
        <id>https://lixin-scut.github.io//post/dong-tai-gui-hua-139-dan-ci-chai-fen-zhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/dong-tai-gui-hua-139-dan-ci-chai-fen-zhong-deng-wei-zuo-chu">
        </link>
        <updated>2020-03-28T05:18:36.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。<br>
说明：<br>
拆分时可以重复使用字典中的单词。<br>
你可以假设字典中没有重复的单词。<br>
示例 1：<br>
输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]<br>
输出: true<br>
解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。<br>
示例 2：<br>
输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]<br>
输出: true<br>
解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。<br>
     注意你可以重复使用字典中的单词。<br>
示例 3：<br>
输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]<br>
输出: false</p>
</blockquote>
<p>一开始是想到了暴力法和回溯法的，但是一直纠结于动态规划法，所以最后还是先看了题解<br>
官方题解中的动态其实更像回溯法的迭代版，网友的更像动态规划法，利用boolean数组保存了状态，减少了一个循环</p>
<pre><code>class Solution {
public:
    // 动态规划法
    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict)
{
    int len = s.size();
    vector&lt;bool&gt; wordInclude(len + 1, false);
    wordInclude[0] = true;
    
    for(int i = 1; i &lt;= len; ++i)
    {
        for(string str : wordDict)
        {
            if(i &gt;= str.size() &amp;&amp; str == s.substr(i-str.size(), str.size()))
            {
                wordInclude[i] = wordInclude[i] || wordInclude[i - str.size()];
            } 
        }
    }
    
    return wordInclude.back();
}
 
    /*
    // 回溯法
    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict)
    {
        vector&lt;int&gt; wordInclude(s.size(), -1);
        unordered_set&lt;string&gt; dictSet;
        for(string str : wordDict)
        {
            dictSet.insert(str);
        }
        return wordBreak(s, dictSet, 0, wordInclude);
    }
    
    bool wordBreak(string s, unordered_set&lt;string&gt;&amp; dictSet, int beg, vector&lt;int&gt;&amp; wordInclude)
    {
        if(beg == s.size())
        {
            return true;
        }
        if(wordInclude[beg] != -1)
        {
            return wordInclude[beg];
        }
        for(int end = beg + 1; end &lt;= s.size(); ++end)
        {
            if(dictSet.count(s.substr(beg, end - beg)) &amp;&amp; wordBreak(s, dictSet, end, wordInclude));
            {
                wordInclude[beg] = 1;
                return true;
            }
        }
        wordInclude[beg] = 0;
        return false;
    }
    
    
    // 回溯法（迭代版）
    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict)
    {
        unordered_set&lt;string&gt; dictSet;
        for(string str : wordDict)
        {
            dictSet.insert(str);
        }
        int len = s.size();
        vector&lt;bool&gt; wordInclude(len + 1, false);
        wordInclude[0] = true;
        for(int end = 1; end &lt;= len; ++end)
        {
            for(int beg = 0; beg &lt; end; ++beg)
            {
                if(wordInclude[beg] &amp;&amp; dictSet.count(s.substr(beg, end - beg)))
                {
                    wordInclude[end] = true;
                    break;
                }
            }
        }
        return wordInclude.back();
    }
    */
};
</code></pre>
<p>网友题解：</p>
<pre><code>    
    class Solution {
    public boolean wordBreak(String s, List&lt;String&gt; wordDict) {
        int n = s.length();
        boolean [] dp = new boolean [n+1];
        dp[0]=true;

             for(int i=1;i&lt;=n;i++){
              for(String word:wordDict){//求解顺序完全背包问题对物品的迭代应该放在里层
                     int w = word.length();
                 if(i&gt;=w&amp;&amp;word.equals(s.substring(i-w,i))){
                     dp[i]=dp[i]||dp[i-w];
                 }
             }
         }
        return dp[n];
    }
}

</code></pre>
<p>官方题解：<br>
方法 1：暴力</p>
<blockquote>
<p>算法<br>
最简单的实现方法是用递归和回溯。为了找到解，我们可以检查字典单词中每一个单词的可能前缀，如果在字典中出现过，那么去掉这个前缀后剩余部分回归调用。同时，如果某次函数调用中发现整个字符串都已经被拆分且在字典中出现过了，函数就返回 true 。</p>
</blockquote>
<pre><code>Java
public class Solution {
    public boolean wordBreak(String s, List&lt;String&gt; wordDict) {
        return word_Break(s, new HashSet(wordDict), 0);
    }
    public boolean word_Break(String s, Set&lt;String&gt; wordDict, int start) {
        if (start == s.length()) {
            return true;
        }
        for (int end = start + 1; end &lt;= s.length(); end++) {
            if (wordDict.contains(s.substring(start, end)) &amp;&amp; word_Break(s, wordDict, end)) {
                return true;
            }
        }
        return false;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n^n) 考虑最坏情况 s = aaaaaaa。每一个前缀都在字典中，此时回溯树的复杂度会达到 n^n。<br>
空间复杂度：O(n) 。回溯树的深度最深达到 n 。</p>
</blockquote>
<p>方法 2：记忆化回溯</p>
<blockquote>
<p>算法<br>
在先前的方法中，我们看到许多函数调用都是冗余的，也就是我们会对相同的字符串调用多次回溯函数。为了避免这种情况，我们可以使用记忆化的方法，其中一个 memo 数组会被用来保存子问题的结果。每当访问到已经访问过的后缀串，直接用 memo 数组中的值返回而不需要继续调用函数。<br>
通过记忆化，许多冗余的子问题可以极大被优化，回溯树得到了剪枝，因此极大减小了时间复杂度。</p>
</blockquote>
<pre><code>Java
public class Solution {
    public boolean wordBreak(String s, List&lt;String&gt; wordDict) {
        return word_Break(s, new HashSet(wordDict), 0, new Boolean[s.length()]);
    }
    public boolean word_Break(String s, Set&lt;String&gt; wordDict, int start, Boolean[] memo) {
        if (start == s.length()) {
            return true;
        }
        if (memo[start] != null) {
            return memo[start];
        }
        for (int end = start + 1; end &lt;= s.length(); end++) {
            if (wordDict.contains(s.substring(start, end)) &amp;&amp; word_Break(s, wordDict, end, memo)) {
                return memo[start] = true;
            }
        }
        return memo[start] = false;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n^2) 。回溯树的大小最多达到 n^2<br>
空间复杂度：O(n) 。 回溯树的深度可以达到 n 级别。</p>
</blockquote>
<blockquote>
<p>方法 3：使用宽度优先搜索<br>
算法<br>
另一个方法是使用宽度优先搜索。将字符串可视化成一棵树，每一个节点是用 end 为结尾的前缀字符串。当两个节点之间的所有节点都对应了字典中一个有效字符串时，两个节点可以被连接。<br>
为了形成这样的一棵树，我们从给定字符串的第一个字符开始（比方说 s ），将它作为树的根部，开始找所有可行的以该字符为首字符的可行子串。进一步的，将每一个子字符串的结束字符的下标（比方说 i）放在队列的尾部供宽搜后续使用。<br>
每次我们从队列最前面弹出一个元素，并考虑字符串 s(i+1,end) 作为原始字符串，并将当前节点作为树的根。这个过程会一直重复，直到队列中没有元素。如果字符串最后的元素可以作为树的一个节点，这意味着初始字符串可以被拆分成多个给定字典中的子字符串。<br>
树的生成过程可以参考这个例子：</p>
</blockquote>
<pre><code>Java
public class Solution {
    public boolean wordBreak(String s, List&lt;String&gt; wordDict) {
        Set&lt;String&gt; wordDictSet=new HashSet(wordDict);
        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
        int[] visited = new int[s.length()];
        queue.add(0);
        while (!queue.isEmpty()) {
            int start = queue.remove();
            if (visited[start] == 0) {
                for (int end = start + 1; end &lt;= s.length(); end++) {
                    if (wordDictSet.contains(s.substring(start, end))) {
                        queue.add(end);
                        if (end == s.length()) {
                            return true;
                        }
                    }
                }
                visited[start] = 1;
            }
        }
        return false;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n^2) 。对于每个开始的位置，搜索会直到给定字符串的尾部结束。<br>
空间复杂度：O(n) 。队列的大小最多 n</p>
</blockquote>
<p>方法 4：使用动态规划</p>
<blockquote>
<p>算法<br>
这个方法的想法是对于给定的字符串（s）可以被拆分成子问题 s1 和 s2 。如果这些子问题都可以独立地被拆分成符合要求的子问题，那么整个问题 s 也可以满足。也就是，如果 &quot;catsanddog&quot; 可以拆分成两个子字符串 &quot;catsand&quot; 和 &quot;dog&quot; 。子问题 &quot;catsand&quot; 可以进一步拆分成 &quot;cats&quot; 和 &quot;and&quot; ，这两个独立的部分都是字典的一部分，所以 &quot;catsand&quot; 满足题意条件，再往前， &quot;catsand&quot; 和 &quot;dog&quot; 也分别满足条件，所以整个字符串 &quot;catsanddog&quot; 也满足条件。<br>
现在，我们考虑 dp 数组求解的过程。我们使用 n+1 大小数组的dp ，其中 n 是给定字符串的长度。我们也使用 2 个下标指针 i 和 j ，其中 i 是当前字符串从头开始的子字符串（s′ ）的长度， j 是当前子字符串（s ′ ）的拆分位置，拆分成s ′ (0,j) 和s′ (j+1,i) 。<br>
为了求出 dp 数组，我们初始化dp[0] 为 true ，这是因为空字符串总是字典的一部分。 dp 数组剩余的元素都初始化为 false 。<br>
我们用下标 i 来考虑所有从当前字符串开始的可能的子字符串。对于每一个子字符串，我们通过下标 j 将它拆分成s1 ′ 和 s2 ′（注意 i现在指向 s2 ′的结尾）。为了将 dp[i] 数组求出来，我们依次检查每个dp[j] 是否为 true ，也就是子字符串 s1 ′ 是否满足题目要求。如果满足，我们接下来检查 s2 ′ 是否在字典中。如果包含，我们接下来检查 s2 ′ 是否在字典中，如果两个字符串都满足要求，我们让 dp[i] 为true ，否则令其为 false 。</p>
</blockquote>
<pre><code>Java
public class Solution {
    public boolean wordBreak(String s, List&lt;String&gt; wordDict) {
        Set&lt;String&gt; wordDictSet=new HashSet(wordDict);
        boolean[] dp = new boolean[s.length() + 1];
        dp[0] = true;
        for (int i = 1; i &lt;= s.length(); i++) {
            for (int j = 0; j &lt; i; j++) {
                if (dp[j] &amp;&amp; wordDictSet.contains(s.substring(j, i))) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[s.length()];
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n^2) 。求出 dp 数组需要两重循环。<br>
空间复杂度：O(n) 。<br>
dp 数组的长度是n+1 。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DFS 695. 岛屿的最大面积[中等]]]></title>
        <id>https://lixin-scut.github.io//post/dfs-695-dao-yu-de-zui-da-mian-ji-zhong-deng</id>
        <link href="https://lixin-scut.github.io//post/dfs-695-dao-yu-de-zui-da-mian-ji-zhong-deng">
        </link>
        <updated>2020-03-27T14:06:36.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>给定一个包含了一些 0 和 1 的非空二维数组 grid 。<br>
一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。<br>
找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)<br>
示例 1:<br>
[[0,0,1,0,0,0,0,1,0,0,0,0,0],<br>
[0,0,0,0,0,0,0,1,1,1,0,0,0],<br>
[0,1,1,0,1,0,0,0,0,0,0,0,0],<br>
[0,1,0,0,1,1,0,0,1,0,1,0,0],<br>
[0,1,0,0,1,1,0,0,1,1,1,0,0],<br>
[0,0,0,0,0,0,0,0,0,0,1,0,0],<br>
[0,0,0,0,0,0,0,1,1,1,0,0,0],<br>
[0,0,0,0,0,0,0,1,1,0,0,0,0]]<br>
对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。<br>
示例 2:<br>
[[0,0,0,0,0,0,0,0]]<br>
对于上面这个给定的矩阵, 返回 0。<br>
注意: 给定的矩阵grid 的长度和宽度都不超过 50。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/max-area-of-island<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>一开始感觉比较像是动态规划的累积问题<br>
但是有个问题是 示例1中，如果只考虑当前格的左边和上边的话，会导致重复考虑</p>
<p>所以我第二个想法是直接DFS并用visited数组保存已探测的格子<br>
注意怎么样通过修改函数返回值从而不断缩减函数的参数</p>
<pre><code>class Solution {
public:
    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        if(grid.empty())
        {   return 0; }
        int rowSize = grid.size();
        int colSize = grid[0].size();
        
        vector&lt;vector&lt;bool&gt;&gt; visited(rowSize, vector&lt;bool&gt;(colSize, false));
        int ans = 0;

        for(int row = 0; row &lt; rowSize; ++row)
        {
            for(int col = 0; col &lt; colSize; ++col)
            {
                int temp = maxAreaOfIsland(grid, visited, row, col);
                ans = temp &gt; ans ? temp : ans;
            }
        }
        
        return ans;
    }
    
    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid,
                         vector&lt;vector&lt;bool&gt;&gt;&amp; visited,
                         int row,
                         int col)
    {
        
        if(row &gt;= grid.size() || col &gt;= grid[0].size() 
           || visited[row][col])
        {   return 0; }
        
        visited[row][col] = true;
        
        if(grid[row][col] == 0)
        {   return 0;}
        
        return 1 + maxAreaOfIsland(grid,visited,row-1,col)
                + maxAreaOfIsland(grid,visited,row,col-1)
                + maxAreaOfIsland(grid,visited,row+1,col)
                + maxAreaOfIsland(grid,visited,row,col+1);
    }
    
};
</code></pre>
<p>官方题解：<br>
官方题解有个很妙的地方，就是因为数组不需要追溯过往状态，所以访问过的位置可以直接修改置0，从而避免了使用额外的visited数组记录访问状态。</p>
<blockquote>
<p>方法一：深度优先搜索<br>
算法<br>
我们想知道网格中每个连通形状的面积，然后取最大值。<br>
如果我们在一个土地上，以 4 个方向探索与之相连的每一个土地（以及与这些土地相连的土地），那么探索过的土地总数将是该连通形状的面积。<br>
为了确保每个土地访问不超过一次，我们每次经过一块土地时，将这块土地的值置为 0。这样我们就不会多次访问同一土地。</p>
</blockquote>
<pre><code>class Solution {
    int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int cur_i, int cur_j) {
        if (cur_i &lt; 0 || cur_j &lt; 0 || cur_i == grid.size() || cur_j == grid[0].size() || grid[cur_i][cur_j] != 1)
            return 0;
        grid[cur_i][cur_j] = 0;
        int di[4] = {0, 0, 1, -1};
        int dj[4] = {1, -1, 0, 0};
        int ans = 1;
        for (int index = 0; index != 4; ++index) {
            int next_i = cur_i + di[index], next_j = cur_j + dj[index];
            ans += dfs(grid, next_i, next_j);
        }
        return ans;
    }
public:
    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int ans = 0;
        for (int i = 0; i != grid.size(); ++i)
            for (int j = 0; j != grid[0].size(); ++j)
                ans = max(ans, dfs(grid, i, j));
        return ans;
    }
};
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(R∗C)。其中R 是给定网格中的行数，C 是列数。我们访问每个网格最多一次。<br>
空间复杂度：O(R∗C)，递归的深度最大可能是整个网格的大小，因此最大可能使用 O(R∗C) 的栈空间。</p>
</blockquote>
<blockquote>
<p>方法二：深度优先搜索 + 栈<br>
算法<br>
我们可以用栈来实现深度优先搜索算法。这种方法本质与方法一相同，唯一的区别是：<br>
方法一通过函数的调用来表示接下来想要遍历哪些土地，让下一层函数来访问这些土地。而方法二把接下来想要遍历的土地放在栈里，然后在取出这些土地的时候访问它们。<br>
访问每一片土地时，我们将对围绕它四个方向进行探索，找到还未访问的土地，加入到栈 stack 中；<br>
另外，只要栈 stack 不为空，就说明我们还有土地待访问，那么就从栈中取出一个元素并访问。</p>
</blockquote>
<pre><code>class Solution {
public:
    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int ans = 0;
        for (int i = 0; i != grid.size(); ++i)
            for (int j = 0; j != grid[0].size(); ++j) {
                int cur = 0;
                stack&lt;int&gt; stacki;
                stack&lt;int&gt; stackj;
                stacki.push(i);
                stackj.push(j);
                while (!stacki.empty()) {
                    int cur_i = stacki.top(), cur_j = stackj.top();
                    stacki.pop();
                    stackj.pop();
                    if (cur_i &lt; 0 || cur_j &lt; 0 || cur_i == grid.size() || cur_j == grid[0].size() || grid[cur_i][cur_j] != 1)
                        continue;
                    ++cur;
                    grid[cur_i][cur_j] = 0;
                    int di[4] = {0, 0, 1, -1};
                    int dj[4] = {1, -1, 0, 0};
                    for (int index = 0; index != 4; ++index) {
                        int next_i = cur_i + di[index], next_j = cur_j + dj[index];
                        stacki.push(next_i);
                        stackj.push(next_j);
                    }
                }
                ans = max(ans, cur);
            }
        return ans;
    }
};
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(R∗C)。其中R 是给定网格中的行数，C 是列数。我们访问每个网格最多一次。<br>
空间复杂度：O(R∗C)，栈中最多会存放所有的土地，土地的数量最多为R∗C 块，因此使用的空间为 O(R∗C)。</p>
</blockquote>
<blockquote>
<p>方法三：广度优先搜索<br>
算法<br>
我们把方法二中的栈改为队列，每次从队首取出土地，并将接下来想要遍历的土地放在队尾，就实现了广度优先搜索算法。</p>
</blockquote>
<pre><code>class Solution {
public:
    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int ans = 0;
        for (int i = 0; i != grid.size(); ++i)
            for (int j = 0; j != grid[0].size(); ++j) {
                int cur = 0;
                queue&lt;int&gt; queuei;
                queue&lt;int&gt; queuej;
                queuei.push(i);
                queuej.push(j);
                while (!queuei.empty()) {
                    int cur_i = queuei.front(), cur_j = queuej.front();
                    queuei.pop();
                    queuej.pop();
                    if (cur_i &lt; 0 || cur_j &lt; 0 || cur_i == grid.size() || cur_j == grid[0].size() || grid[cur_i][cur_j] != 1)
                        continue;
                    ++cur;
                    grid[cur_i][cur_j] = 0;
                    int di[4] = {0, 0, 1, -1};
                    int dj[4] = {1, -1, 0, 0};
                    for (int index = 0; index != 4; ++index) {
                        int next_i = cur_i + di[index], next_j = cur_j + dj[index];
                        queuei.push(next_i);
                        queuej.push(next_j);
                    }
                }
                ans = max(ans, cur);
            }
        return ans;
    }
};
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(R∗C)。其中 R 是给定网格中的行数，C 是列数。我们访问每个网格最多一次。<br>
空间复杂度：O(R∗C)，队列中最多会存放所有的土地，土地的数量最多为 R∗C 块，因此使用的空间为 O(R∗C)。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机网络体系分层层次]]></title>
        <id>https://lixin-scut.github.io//post/ji-suan-ji-wang-luo-ti-xi-fen-ceng</id>
        <link href="https://lixin-scut.github.io//post/ji-suan-ji-wang-luo-ti-xi-fen-ceng">
        </link>
        <updated>2020-03-26T09:15:15.000Z</updated>
        <content type="html"><![CDATA[<h3 id="分层概念">分层概念</h3>
<p>  每层通过在该层中执行某些动作或使用直接下层的服务来提供服务，例如由第n层提供的服务可能包括报文从网络的一边到另一边的可靠传送，这可能是通过使用第n-1层的边缘到边缘的不可靠报文传送服务，加上第n层的检测和重传丢失报文的功能来实现的。<br>
  一个协议层能够用软件、硬件或两者的结合来实现。诸如HTTP和SMTP这样的应用层协议几乎总是在端系统中用软件实现的，运输层协议也是如此，因为物理层和数据链路层负责处理跨越特定链路的通信，它们通常是实现在与给定链路相联系的网络接口卡（例如以太网或WiFi接口卡）中，网络层经常是硬件和软件实现的混合体</p>
<h3 id="优缺点">优缺点</h3>
<p><strong>优点：</strong><br>
  协议分层具有概念化和结构化的优点<br>
  采用多层是有益的,通过分层, 每层只负责通信的一个方面。互联网络的目标之一是对应用隐藏所有关于物理布局( 拓扑) 和低层协议的异构性的细 节，分层设计允许开发人员分别实现系统的不同部分, 它们通常由在不同领域的专业人员完成。<br>
  分层体系结构的另一个主要优点是具有协议复用的能力。这种复用形式允许多种协议共存于同一基础设施中。它也允许相同协议对象( 例如连接) 的多个实例同时存在, 并且不会被混淆。</p>
<p><strong>缺点：</strong><br>
  分层的一个潜在缺点是一层可能冗余较低层的功能<br>
  第二种潜在的缺点是某层的功能可能需要仅在其他某层才出现的信息</p>
<p>  因特网的协议栈由5个层次组成：<strong>物理层、链路层、网络层、运输层和应用层</strong><br>
  OSI参考模型的7层是：<strong>应用层、表示层、会话层</strong>，运输层，网络层，数据链路层和物理层<br>
<img src="https://lixin-scut.github.io//post-images/1585214284826.png" alt=""></p>
<p>(1)应用层<br>
  应用层是网络应用程序及它们的应用层协议存留的地方，因特网的用层包括许多协议，例如HTTP，SMTP(它提供了电子邮件报文的传输）和FTP(它提供两个端系统之间的文件传送）。我们将看到某些网络功能，如将像www这样对人友好的端系统名字转换为32比特网络地址<br>
  应用层的信息分组称为<strong>报文（message)</strong><br>
(2)运输层<br>
  因特网的运输层在应用程序端点之间传送应用层报文在因特网中，有两个运输协议.<br>
即TCP和UDP<br>
  TCP向它的应用程序提供了面向连接的服务，包括了应用层报文向目的地的确保传递和流量控制（即发送方/接收方速率匹配），TCP也将长报文划分为短报文.并提供拥塞控制机制，因此当网络拥塞时，源抑制其传输速率.<br>
  UDP协议向它的应用程序提供无连接服务，这是一种不提供不必要服务的服务，没有可靠性.没有流量控制.也没有拥塞控制在本书中.<br>
  我们把运输层分组称为<strong>报文段（segment)。</strong><br>
(3)网络层<br>
  因特网的网络层负责将称为<strong>数据报（datagnim)</strong><br>
  网络层分组从一台主机移动到另一台主机.在一台源主机中的因特网运输层协议（TCP或UDP)向网络层递交运输层报文段和目的地址，就像你通过邮政服务寄信件时提供一个目的地址一样<br>
  因特网的网络层包括著名的IP协议，该协议定义了在数据报中的各个字段以及端系统和路由器如何作用于这些字段<br>
  网络层包括了IP协议和一些路由选择协议，但通常把它简单地称为IP层.这反映IP是将因特网连接在一起的粘合剂这样的事实<br>
(4)链路层<br>
  因特网的网络层通过源和目的地之间的一系列路由器路由数据报，为了将分组从一个结点（主机或路由器）移动到路径上的下一个结点，网络层必须依靠该链路层的服务，特別是在每个结点.网络层将数据报下传给链路层.链路层沿着路径将数据报传递给下一个结点。在下个结点，链路层将数据报上传给网络层，<br>
  我们把链路层分组称为<strong>帧(frame)</strong><br>
(5)物理层<br>
  虽然链路层的任务是将整个帧从一个网络元素移动到邻近的网络元素.而物理层的任务是将该帧中的一个一个比特从一个结点移动到下一个结点，</p>
<h3 id="各层次包含的协议">各层次包含的协议：</h3>
<p>应用层：<br>
HTTP DNS</p>
<p>运输层：<br>
TCP UDP ICMP</p>
<p>网络层：<br>
IP<br>
路由选择算法</p>
<p>链路层：</p>
<p>物理层：</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 494. 目标和[中等][未做出]]]></title>
        <id>https://lixin-scut.github.io//post/dong-tai-gui-hua-494-mu-biao-he-zhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/dong-tai-gui-hua-494-mu-biao-he-zhong-deng-wei-zuo-chu">
        </link>
        <updated>2020-03-26T04:44:24.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。<br>
返回可以使最终数组和为目标数 S 的所有添加符号的方法数。<br>
示例 1:<br>
输入: nums: [1, 1, 1, 1, 1], S: 3<br>
输出: 5<br>
解释:<br>
-1+1+1+1+1 = 3<br>
+1-1+1+1+1 = 3<br>
+1+1-1+1+1 = 3<br>
+1+1+1-1+1 = 3<br>
+1+1+1+1-1 = 3<br>
一共有5种方法让最终目标和为3。<br>
注意:<br>
数组非空，且长度不会超过20。<br>
初始的数组的和不会超过1000。<br>
保证返回的最终结果能被32位整数存下。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/target-sum<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>我本来想用动态规划，但是可能的情况似乎不断增加<br>
看了题解的动态规划法，原来是需要先转化为背包问题的<br>
时间复杂度：O(N∗sum)，其中 N 是数组 nums 的长度。<br>
空间复杂度：O(sum)</p>
<p>然后想到了回溯递归法<br>
出现的问题<br>
1.if(0 == S)必须判断<br>
2.溢出问题。。。这个我没啥特别好的办法。。。只能先把int 改成 long了<br>
复杂度分析<br>
时间复杂度：O(2^N)，其中 N 是数组 nums 的长度。<br>
空间复杂度：O(N)，为递归使用的栈空间大小。</p>
<p>还有位运算法<br>
尴尬，位运算法超时了。。。因为必须逐位循环，时间复杂度在O(2^N)再套一个length</p>
<pre><code>class Solution {
public:
    // 动态规划
    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S)
    {
        int sum = 0;
        for(auto num : nums)
        {
            sum += num;
        }
        // 这里的判断很重要，排除极端情况和无法整除的情况
        if((sum &gt; 0 &amp;&amp; S &gt; sum) || (sum &lt; 0 &amp;&amp; S &lt; sum) || (sum + S) % 2 == 1) 
        {   return 0; }
        int target = (sum + S) / 2; 
        
        // 我直接优化了空间，注意必须从后往前更新，否则会不断叠加，然后原始是需要加上nums的一维
        vector&lt;int&gt; sumDP(target + 1, 0);
        sumDP[0] = 1;
        for(auto num : nums)
        {
            for(int i = target; i &gt;= 0; --i)
            {
                if(i - num &gt;=0)
                {
                    sumDP[i] += sumDP[i - num];
                }
            }
        }
        return sumDP.back();
    }
    /*
    // 超时
    // 位运算法
    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S)
    {
        int ways = 0;
        long res;
        int len = nums.size();
        int ans = 0;
        while(ways &lt; pow(2, len))
        {
            int bit = 1;
            res = 0;
            for(int i = 0; i &lt; len ; ++i)
            {
                if(ways &amp; (bit &lt;&lt; i))
                {
                    res += static_cast&lt;long&gt;(nums[i]);
                }
                else
                {
                    res -= static_cast&lt;long&gt;(nums[i]);
                }
            }
            if(static_cast&lt;int&gt;(res) == S)
            { ++ans; }
            ++ways;
        }
        return ans;
    }
    
    // 回溯递归法
    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) {
        int ans = 0;
        findTargetSumWays(nums, S, 0, ans);
        return ans;
    }
    
    void findTargetSumWays(vector&lt;int&gt;&amp; nums, long S, int num, int&amp; ans)
    {
        if(num == nums.size() )
        {   
            // 必须单独判断
            if(0 == S)
            {    
                ++ans;
            }
            return;
        }
        
        // 不要用++num
        findTargetSumWays(nums, S+nums[num], num + 1, ans);
        findTargetSumWays(nums, S-nums[num], num + 1, ans);
    }
    */
};
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>暴力解法<br>
暴力解法就是dfs了，这道题而言，暴力解法是完全可以的，而且不会超时，因为题目中说了数组长度不会超过20，20个数字的序列，组合方式撑死了2^20种，算下来才1024×1024<br>
也就是说，可以把数组中每个数字前面都用负号和正号，然后进行组合的求和，并判断这个和是否会等于S，然后就标记，最后统计出等于S的组合个数就好了。<br>
具体使用dfs，就是一个前序遍历二叉树的实现，递归地+或-每个元素，到所有元素都遍历完成的时候，最后那个判断target是否等于零。</p>
</blockquote>
<pre><code>class Solution {
public:
    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) {
        return dfs(nums, S, 0);
    }

    int dfs(vector&lt;int&gt; &amp;nums, uint target, int left) {
        if (target == 0 &amp;&amp; left == nums.size()) return 1;
        if (left &gt;= nums.size()) return 0;
        int ans = 0;
        ans += dfs(nums, target - nums[left], left + 1);
        ans += dfs(nums, target + nums[left], left + 1);
        return ans;
    }
};
</code></pre>
<blockquote>
<p>01背包<br>
本题解参考热评解法<br>
01背包其实不是这种解法的重点，重点是怎么把题目转化成求解01背包的形式。<br>
如果只是单纯的求解和为某个S的组合个数，那就是01背包。。。<br>
但是这题目中不仅有加，还有减，就得进行一个转化了。<br>
思路就是把整个集合看成两个子集，Q表示整个集合，P表示正数子集，N表示负数子集， T表示目标和，用S(X)表示集合的求和函数，集合中均为非负数，N集合是指选中这部分元素作为负数子集。</p>
</blockquote>
<pre><code>S(P)−S(N)=T
S(P)+S(N)+S(P)−S(N)=T+S(P)+S(N)
2S(P)=S(Q)+T
</code></pre>
<blockquote>
<p>也就是：正数集的和的两倍 == 等于目标和 + 序列总和<br>
所以问题就转换成了，找到一个正数集P，其和的两倍等于目标和+序列总和。。。<br>
简单吧，完全就是01背包了嘛！！！<br>
对于01背包，其实我都差不多背下来了，你会发现背了以后，写着写着，就理解了。<br>
需要注意的是，虽然序列总和不超过1000，但是S可是会接近int的上界。。。很容易出现超过整型范围的操作。</p>
</blockquote>
<pre><code>class Solution {
public:
    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) {
        long sum = 0;
        for (const int &amp;it : nums) sum += it;
        if ((S + sum) % 2 == 1 || S &gt; sum) return 0;
        S = (S + sum) / 2;
        int *dp = new int[S + 1];
        memset(dp, 0, (S + 1) * sizeof(int));
        dp[0] = 1;
        for (const int &amp;it : nums) {
            for (int j = S; j &gt;= it; j--)
                dp[j] += dp[j - it];
        }
        int ans = dp[S];
        delete[] dp;
        return ans;
    }
};
</code></pre>
]]></content>
    </entry>
</feed>