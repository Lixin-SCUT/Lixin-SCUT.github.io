<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-12-10T02:26:54.858Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[二分查找 278. 第一个错误的版本[简单]]]></title>
        <id>https://lixin-ee.github.io//post/er-fen-cha-zhao-278-di-yi-ge-cuo-wu-de-ban-ben-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/er-fen-cha-zhao-278-di-yi-ge-cuo-wu-de-ban-ben-jian-dan">
        </link>
        <updated>2019-12-10T02:14:22.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。<br>
假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。<br>
你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。<br>
示例:<br>
给定 n = 5，并且 version = 4 是第一个错误的版本。<br>
调用 isBadVersion(3) -&gt; false<br>
调用 isBadVersion(5) -&gt; true<br>
调用 isBadVersion(4) -&gt; true<br>
所以，4 是第一个错误的版本。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/first-bad-version<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>//这题应该是最简单的二分法了吧，然后可以试试插值查找之类的<br>
//最值得注意的还是mid的计算,注意这个是int不是double啊，会自动向0取整的<br>
//突然发现问题没那么简单啊，因为需要找到第一个出错的<br>
//重点还是在于判断后first和last的赋值是mid还是mid+1<br>
//最后才发现读错题目了，我的想法是true到false的转换找出第一个false，题目的意思是false到true的转换找出最后一个false，尴尬，幸好改一下flag就完成了<br>
//然后发现flag是多余的(what!去除flag之后空间复杂度还变高了！)</p>
<pre><code>// Forward declaration of isBadVersion API.
bool isBadVersion(int version);

class Solution {
public:
    int firstBadVersion(int n) {
      int first=1,last=n,mid;
        while(first&lt;last){
            mid=first+(last-first)/2;
            if(!isBadVersion(mid))
                first=mid+1;
            else
                last=mid;
        }
        return first;
    }

};
</code></pre>
<blockquote>
<p>来看一下官方题解<br>
这是一道较为简单的题目，但是有一个小陷阱。除此之外，这道题的算法是比较显然的。<br>
方法一：线性扫描 [超出时间限制]<br>
最直接的方法是进行一次线性扫描，即对 [1..n][1..n] 都调用一次isBadVersion。</p>
</blockquote>
<pre><code>Java
public int firstBadVersion(int n) {
    for (int i = 1; i &lt; n; i++) {
        if (isBadVersion(i)) {
            return i;
        }
    }
    return n;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)。在最坏的情况下，最多可能会调用 isBadVersion n-1n−1 次，因此总的时间复杂度为 O(n)。<br>
空间复杂度：O(1)。</p>
</blockquote>
<blockquote>
<p>方法二：二分查找 [通过]<br>
不难看出，这道题可以用经典的二分查找算法求解。我们通过一个例子，来说明二分查找如何在每次操作中减少一半的搜索空间，以此减少时间复杂度。<br>
场景一：isBadVersion(mid) =&gt; false<br>
1  2 3  4 5  6 7 8 9<br>
G G G G G G B B B       G = 正确版本，B = 错误版本<br>
|             |           |<br>
left       mid      right<br>
场景一中，isBadVersion(mid) 返回 false，因此我们知道 mid 左侧（包括自身）的所有版本都是正确的。所以我们令 left=mid+1，把下一次的搜索空间变为 [mid+1,right]。<br>
场景二：isBadVersion(mid) =&gt; true<br>
1 2  3 4  5 6 7 8 9<br>
G G G B B B B B B       G = 正确版本，B = 错误版本<br>
|            |           |<br>
left       mid     right<br>
场景二中，isBadVersion(mid) 返回 true，因此我们知道mid 右侧（不包括自身）的所有版本的不可能是第一个错误的版本。所以我们令 right=mid，把下一次的搜索空间变为 [left,mid]。<br>
在二分查找的每次操作中，我们都用left 和right 表示搜索空间的左右边界，因此在初始化时，需要将left 的值设置为 1，并将 right 的值设置为 n。当某一次操作后，left 和 right 的值相等，此时它们就表示了第一个错误版本的位置。可以用数学归纳法 证明 二分查找算法的正确性。<br>
在二分查找中，选取mid 的方法一般为mid=⌊(right+left)/2⌋。如果使用的编程语言会有整数溢出的情况（例如 C++，Java），那么可以用 mid=left+⌊<br>
(right−left)/2⌋代替前者。</p>
</blockquote>
<pre><code>Java
public int firstBadVersion(int n) {
    int left = 1;
    int right = n;
    while (left &lt; right) {
        int mid = left + (right - left) / 2;
        if (isBadVersion(mid)) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return left;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(logn)。搜索空间每次减少一半，因此时间复杂度为 O(logn)。<br>
空间复杂度：O(1)。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图 310. 最小高度树[中等][未做出][待阅读]]]></title>
        <id>https://lixin-ee.github.io//post/tu-310-zui-xiao-gao-du-shu-zhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/tu-310-zui-xiao-gao-du-shu-zhong-deng-wei-zuo-chu">
        </link>
        <updated>2019-12-08T23:56:58.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>对于一个具有树特征的无向图，我们可选择任何一个节点作为根。图因此可以成为树，在所有可能的树中，具有最小高度的树被称为最小高度树。给出这样的一个图，写出一个函数找到所有的最小高度树并返回他们的根节点。</p>
<p>格式<br>
该图包含 n 个节点，标记为 0 到 n - 1。给定数字 n 和一个无向边 edges 列表（每一个边都是一对标签）。<br>
你可以假设没有重复的边会出现在 edges 中。由于所有的边都是无向边， [0, 1]和 [1, 0] 是相同的，因此不会同时出现在 edges 里。</p>
<p>示例 1:<br>
输入: n = 4, edges = [[1, 0], [1, 2], [1, 3]]<br>
0<br>
|<br>
1<br>
/ <br>
2   3<br>
输出: [1]<br>
示例 2:</p>
<p>输入: n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]<br>
0  1  2<br>
\ | /<br>
3<br>
|<br>
4<br>
|<br>
5<br>
输出: [3, 4]</p>
<p>说明:<br>
 根据树的定义，树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。<br>
树的高度是指根节点和叶子节点之间最长向下路径上边的数量。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/minimum-height-trees<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>本来想着说建立一个图的邻接矩阵，然后通过判断矩阵每一行的最大值来得到结果<br>
但是比较麻烦的是如何去判断非邻接节点的距离<br>
发现完全可以化为最短路径的问题去完成 使用floyd构建邻接矩阵来完成<br>
结果floyd超时了？？？</p>
<p>然后来看一下网友题解吧</p>
<blockquote>
<p>广度优先搜索<br>
解题思路 :题目给定的是一个无向简单图，要求找出最高树的节点，首先通过分析可以知道，最后的根节点只可能为1个或者2个。<br>
要求最小高度的根节点，我们反过来想，怎样才能求得最小高度呢，很容易想到从叶子节点开始往根找，<br>
于是就是采用分层剥削的方法，每次去除一层叶子节点，这样保证最后的节点就是我们所要的。</p>
</blockquote>
<pre><code>class Solution {
public:
    vector&lt;int&gt; findMinHeightTrees(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) 
    {
        vector&lt;int&gt; ans;[[[]()]()]()
        vector&lt;int&gt; degree; //各个节点的度
        vector&lt; vector&lt;int&gt; &gt; Graph(n,vector&lt;int&gt;());  //重新定义图的结构
        queue&lt;int&gt; Q; //叶子节点队列
        
        //初始化度队列
        for(int i=0;i&lt;n;i++)
            degree.push_back(0); 
        
        //把边里面的数组转化为邻接表
        for(auto e : edges)
        {
            Graph[e[0]].push_back(e[1]);
            Graph[e[1]].push_back(e[0]);
            degree[e[0]]++;
            degree[e[1]]++;
        }
        
        //一度节点入队列
        for(int i=0;i&lt;n;i++)
            if(degree[i] == 1)
                Q.push(i);
        
        int rst = n;
        //一个节点时要单独拿出来考虑
        if(rst == 1)
            ans.push_back(0);
</code></pre>
<p>另外一个比较厉害的网友的题解，思路是一致的，就是越靠近中间的1~2个节点才是我们需要的节点，也可以转化为计算出入度（这里不是有向图，所以节点的度不需要区分出度入度）</p>
<blockquote>
<p>贪心法：根据拓扑排序的思路（Java 代码）<br>
思路分析：<br>
这道题一开始给我的感觉特别像拓扑排序，做下来，感觉它们的本质是一样的，更深层次的思想是贪心算法。<br>
直觉上，一棵树越靠“外面”的结点，我们越不可能把它作为根结点，如果这样做的话，可能树的高度是很高的<br>
因此，我们使用“剔除边缘结点”的策略，这里的边缘结点就是指连接其它结点最少的结点，用专业的名词来说，就是指向它的结点最少的结点，“入度”最少的结点<br>
我们能归纳出，结点最后只会剩下 1 个或者 2 个。<br>
综上所述，总结一下我们的算法：每次总是删除“入度”个数最少的结点，因为树是无向无环图，删除了它们以后，与之相连的结点的入度也相应地减少 1，直到最后剩下 1 个结点或者 2 个结点。<br>
在编码的时候，我借鉴了“拓扑排序”的代码，使用了“邻接表”表示图，使用了“入度数组”，还使用了队列保存了下一轮要“剔除”的结点编号。关于拓扑排序的知识和代码实现，可以参考「力扣」第 207 题：课程表 和「力扣」第 210 题：课程表 II。</p>
</blockquote>
<pre><code>public class Solution {
    public List&lt;Integer&gt; findMinHeightTrees(int n, int[][] edges) {
        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
        // 特判
        if (n &lt;= 2) {
            for (int i = 0; i &lt; n; i++) {
                res.add(i);
            }
            return res;
        }

        // 入度数组，每一次要把入度为 1 的结点剔除
        int[] inDegrees = new int[n];

        // 默认为 False，如果剔除，设置为 True
        boolean[] result = new boolean[n];

        // 因为是无向图，所以邻接表拿出一条边，两个结点都要存一下
        // 注意：右边就不要写具体的实现类了，等到实例化的时候再写具体的实现类
        Set&lt;Integer&gt;[] adjs = new Set[n];
        // 初始化
        for (int i = 0; i &lt; n; i++) {
            adjs[i] = new HashSet&lt;&gt;();
        }

        for (int[] edge : edges) {
            int start = edge[0];
            int end = edge[1];
            adjs[start].add(end);
            adjs[end].add(start);
            inDegrees[start] += 1;
            inDegrees[end] += 1;
        }
        LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;();

        // 入度为 1 的结点入队
        for (int i = 0; i &lt; n; i++) {
            if (inDegrees[i] == 1) {
                queue.addLast(i);
            }
        }

        // 注意边界条件 n == 2 和 n == 1 是如何分析出来的
        while (n &gt; 2) {
            int size = queue.size();
            System.out.println(queue);
            // 一次减去这么多
            n -= size;
            for (int i = 0; i &lt; size; i++) {
                int top = queue.removeFirst();
                result[top] = true;
                inDegrees[top] -= 1;
                // 把它和它的邻接结点的入度全部减 1
                Set&lt;Integer&gt; successors = adjs[top];
                for (Integer successor : successors) {
                    inDegrees[successor] -= 1;
                    if (inDegrees[successor] == 1) {
                        queue.addLast(successor);
                    }
                }
            }
        }
        n = result.length;
        for (int i = 0; i &lt; n; i++) {
            if (!result[i]) {
                res.add(i);
            }
        }
        return res;
    }
		
    public static void main(String[] args) {
        int[][] edges = new int[][]{{1, 0}, {1, 2}, {1, 3}};
        int n = 4;
        Solution solution = new Solution();
        List&lt;Integer&gt; res = solution.findMinHeightTrees(n, edges);
        System.out.println(res);
    }
}
</code></pre>
<p>看完题解发现其实我是知道BFS和DFS或者最小生成树的，只是没有想深一步去到刨除叶子节点这一步，最近做题经常是面向测试用例编程，很少去挖掘通用规律了，这一点还是有待改进的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图 399. 除法求值[中等][未做出][待阅读]]]></title>
        <id>https://lixin-ee.github.io//post/tu-399-chu-fa-qiu-zhi-zhong-deng-wei-zuo-chu-dai-yue-du</id>
        <link href="https://lixin-ee.github.io//post/tu-399-chu-fa-qiu-zhi-zhong-deng-wei-zuo-chu-dai-yue-du">
        </link>
        <updated>2019-12-08T02:16:18.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给出方程式 A / B = k, 其中 A 和 B 均为代表字符串的变量， k 是一个浮点型数字。根据已知方程式求解问题，并返回计算结果。如果结果不存在，则返回 -1.0。<br>
示例 :<br>
给定 a / b = 2.0, b / c = 3.0<br>
问题: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? <br>
返回 [6.0, 0.5, -1.0, 1.0, -1.0 ]<br>
输入为: vector&lt;pair&lt;string, string&gt;&gt; equations, vector&lt; double&gt;&amp; values,vector&lt;pair&lt;string, string&gt;&gt; queries(方程式，方程式结果，问题方程式)， 其中 equations.size() == values.size()，即方程式的长度与方程式结果长度相等（程式与结果一一对应），并且结果值均为正数。以上为方程式的描述。 返回vector&lt; double&gt;类型。<br>
基于上述例子，输入如下：<br>
equations(方程式) = [ [&quot;a&quot;, &quot;b&quot;], [&quot;b&quot;, &quot;c&quot;] ],<br>
values(方程式结果) = [2.0, 3.0],<br>
queries(问题方程式) = [ [&quot;a&quot;, &quot;c&quot;], [&quot;b&quot;, &quot;a&quot;], [&quot;a&quot;, &quot;e&quot;], [&quot;a&quot;, &quot;a&quot;], [&quot;x&quot;, &quot;x&quot;] ].<br>
输入总是有效的。你可以假设除法运算中不会出现除数为0的情况，且不存在任何矛盾的结果。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/evaluate-division<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>//在310用floyd翻车了就回来这边用了<br>
//本题目可以视为 建立图-搜索两点之间的最短路径 的问题<br>
//在大话数据结构的两种方法里面，最适合这道题的无疑是floyd<br>
//另一种算法：迪杰斯特拉（Dijkstra)算法：按路径长度递增的次序产生最短路径的算法，基于已经求出的最短路径的基础上一步步求出它们之间顶点的最短路径，适用于某个源点到其余各顶点的最 短路径问题<br>
//floyd就等于动态规划，一共有三层规划 k代表中转顶点的下标 v是起始顶点 w代表结束顶点，等于对于每两个点之间都以某个点来做中转，然后只取最短点（其实就是（Dijkstra)算法的循环版）<br>
//对于本题目来说，需要注意的点有：1.需要用map建立string和int下标的映射<br>
//2.对对称点使用倒数来初始化<br>
//3.循环计算时的判断式<code>if(graph[v][w]==-1.0&amp;&amp;graph[v][k]!=-1.0&amp;&amp;graph[k][w]!=-1.0)</code><br>
//4.最后利用map进行判断节点是否存在<code>if(trans.count(queries[i][0])&amp;&amp;trans.count(queries[i][1]))</code></p>
<pre><code>class Solution {
public:
    vector&lt;double&gt; calcEquation(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;double&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries) {
        map&lt;string,int&gt; trans;
        int n=0;
        for(int i=0;i&lt;equations.size();++i){
            if(!trans.count(equations[i][0]))
               trans.insert({equations[i][0],n++});
             if(!trans.count(equations[i][1]))
               trans.insert({equations[i][1],n++});
        }
        vector&lt;vector&lt;double&gt;&gt; graph(n,vector(n,-1.0));
        for(int i=0;i&lt;n;++i)
            graph[i][i]=1.0;
       for(int i=0;i&lt;equations.size();++i){
           int row=trans[equations[i][0]];
           int col=trans[equations[i][1]];
           graph[row][col]=values[i];
           graph[col][row]=1/values[i];               
       } 
     build(graph);  
     vector&lt;double&gt; res;
    for(int i=0;i&lt;queries.size();++i){
        if(trans.count(queries[i][0])&amp;&amp;trans.count(queries[i][1])){
            int row=trans[queries[i][0]];
            int col=trans[queries[i][1]];
            res.push_back(graph[row][col]);
        }
        else
            res.push_back(-1.0);
                 }
                return res;
    }
    
    void build(vector&lt;vector&lt;double&gt;&gt;&amp; graph){       
        int n=graph.size();
        for(int k=0;k&lt;n;++k)
            for(int v=0;v&lt;n;++v)
                for(int w=0;w&lt;n;++w)
                    if(graph[v][w]==-1.0&amp;&amp;graph[v][k]!=-1.0&amp;&amp;graph[k][w]!=-1.0)
                        graph[v][w]=graph[v][k]*graph[k][w],graph[w][v]=1/graph[v][w];
    }
};
</code></pre>
<p>然后惯例来看一下网友题解，有一位网友总结了三种解法，而且用的是C++，感动<br>
方法一：Floyd</p>
<pre><code>struct Value {
    int status;
    double val;
    Value(): status(0), val(0) {}
    Value(int s, double v) : status(s), val(v) {}
};

class Solution {
public:
    vector&lt;double&gt; calcEquation(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;double&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries) {      
        unordered_map&lt;string, int&gt; store;
        int n = 0;
        for (auto e : equations) {
            if (store.find(e[0]) == store.end())
                store[e[0]] = n++;
            if (store.find(e[1]) == store.end())
                store[e[1]] = n++;
        }

        vector&lt;vector&lt;Value&gt;&gt; graph(n, vector&lt;Value&gt;(n, Value()));
        for (int i = 0; i &lt; equations.size(); ++i) {
            int ia = store[equations[i][0]];
            int ib = store[equations[i][1]];
            graph[ia][ib] = Value(1, values[i]);
            graph[ib][ia] = Value(1, 1/values[i]);
        }
        
        for (int k = 0; k &lt; n; ++k) {
            for (int i = 0; i &lt; n; ++i) {
                for (int j = 0; j &lt; n; ++j) {
                    if (graph[i][j].status == 0 &amp;&amp; graph[i][k].status == 1 &amp;&amp; graph[k][j].status == 1) {
                        graph[i][j] = Value(1, graph[i][k].val * graph[k][j].val);
                    }
                }
            }
        }
        
        vector&lt;double&gt; res;
        for (auto q : queries) {
            if (store.find(q[0]) == store.end() || store.find(q[1]) == store.end()) {
                res.push_back(-1);
                continue;
            } 
            int ia = store[q[0]];
            int ib = store[q[1]];
            double r = graph[ia][ib].status == 1 ? graph[ia][ib].val : -1;
            res. push_back(r);
        }
        return res;
    }
};
</code></pre>
<p>方法二：dfs 和 bfs<br>
主要分为两步：<br>
1.build 构造初始化图<br>
2.dfs 或者 bfs 进行遍历</p>
<pre><code>class Solution {
public:
    vector&lt;double&gt; calcEquation(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;double&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries) {
        auto graph = build(equations, values);
           
        vector&lt;double&gt; res;  
        for (auto q : queries) {
            set&lt;string&gt; visited;
            bool found = false;
            //double r = bfs(graph, visited, q[0], q[1], found);
            double r = dfs(graph, visited, q[0], q[1], found);
            if (found) {
                res.push_back(r);
                graph[q[0]][q[1]] = r;
                graph[q[1]][q[0]] = 1 / r;
            } else {
                res.push_back(-1);
            }
        }
      
        return res;
    }

    unordered_map&lt;string, unordered_map&lt;string, double&gt;&gt; build(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;double&gt;&amp; values) {
        unordered_map&lt;string, unordered_map&lt;string, double&gt;&gt; m;
        for (int i = 0; i &lt; equations.size(); ++i) {
            vector&lt;string&gt; eqa = equations[i];
            string a = eqa[0];
            string b = eqa[1];
            double v = values[i];
            if (m.find(a) == m.end()) {
                m[a] = unordered_map&lt;string, double&gt;{{b, v}};
            } else {
                m[a][b] = v;
            }
            if (m.find(b) == m.end()) {
                m[b] = unordered_map&lt;string, double&gt;{{a, 1 /v}};
            } else {
                m[b][a] = 1 / v;
            }
        }
        return m;
    }

    double bfs(unordered_map&lt;string, unordered_map&lt;string, double&gt;&gt;&amp; g, set&lt;string&gt; visited, string begin, string end, bool&amp; found) {
        if (g.find(begin) == g.end() || g.find(end) == g.end()) {
            found = false;
            return -1;
        }
        queue&lt;pair&lt;string, double&gt;&gt; q;
        q.push(make_pair(begin, 1));
        while (!q.empty()) {
            auto cur = q.front();
            q.pop();
            if (visited.find(cur.first) != visited.end()) {
                continue;
            }
            if (cur.first == end) {
                found = true;
                return cur.second;
            }
            visited.insert(cur.first);
            for (auto it : g[cur.first]) {
                q.push(make_pair(it.first, cur.second * it.second));
            }
        }
        found = false;
        return -1;
    }
  
    double dfs(unordered_map&lt;string, unordered_map&lt;string, double&gt;&gt;&amp; g, set&lt;string&gt; visited, string begin, string end, bool&amp; found) {
        if (g.find(begin) == g.end() || g.find(end) == g.end()) {
            found = false;
            return -1;
        }
        if (visited.find(begin) != visited.end()) {
            found = false;
            return -1;
        }
        if (g[begin].find(end) != g[begin].end()) {
            found = true;
            return g[begin][end];
        }
        visited.insert(begin);
        for (auto it : g[begin]) {
            double r = dfs(g, visited, it.first, end, found);
            if (found) {
                double res = r * it.second;
                return res;
            }
        }
        visited.erase(begin);
        found = false;
        return -1;
    }
};
</code></pre>
<p>方法三：并查集</p>
<pre><code>struct Node {
    double value;
    Node* parent;
    Node() : parent(this) {}
    Node(double v) : value(v), parent(this) {}
};

class Solution {
    unordered_map&lt;string, Node*&gt; m;

    Node* find(Node* n) {
        if (n-&gt;parent != n) {
            n-&gt;parent = find(n-&gt;parent);
        }
        return n-&gt;parent;
    }
   
    void merge(Node* n1, Node* n2, double val) {
        Node* p1 = find(n1);
        Node* p2 = find(n2);
        double ratio = n2-&gt;value * val / n1-&gt;value;
        for (auto it : m) {
            if (find(it.second) == p1) {
                it.second-&gt;value *= ratio;
            }
        } 
        p1-&gt;parent = p2;
    }
public:
    vector&lt;double&gt; calcEquation(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;double&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries) {
        for (int i = 0; i &lt; equations.size(); ++i) {
            string a = equations[i][0];
            string b = equations[i][1];
            if (m.find(a) == m.end()) m[a] = new Node(values[i]);
            if (m.find(b) == m.end()) m[b] = new Node(1.0);
            merge(m[a], m[b], values[i]);
        }
        vector&lt;double&gt; res;
        for (auto q : queries) {
            if (m.find(q[0]) == m.end() || m.find(q[1]) == m.end() || find(m[q[0]]) != find(m[q[1]])) {
                res.push_back(-1);
            } else {
                res.push_back(m[q[0]]-&gt;value / m[q[1]]-&gt;value);
            }
        }
        return res;
    }
};
</code></pre>
<p>DFS和BFS 以及并查集值得好好阅读一下。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图 133. 克隆图[中等]]]></title>
        <id>https://lixin-ee.github.io//post/tu-133-ke-long-tu-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/tu-133-ke-long-tu-zhong-deng">
        </link>
        <updated>2019-12-07T00:47:09.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定无向连通图中一个节点的引用，返回该图的深拷贝（克隆）。图中的每个节点都包含它的值 val（Int） 和其邻居的列表（list[Node]）。<br>
示例：</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1575679961753.png" alt=""></p>
<blockquote>
<p>输入：<br>
{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: …&quot;neighbors&quot;:[{&quot;'>id&quot;:&quot;1&quot;,&quot;neighbors&quot;:[{&quot;</span>id&quot;:&quot;2&quot;,&quot;neighbors&quot;:[{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 9: ref&quot;:&quot;1&quot;}̲,{&quot;'>ref&quot;:&quot;1&quot;},{&quot;</span>id&quot;:&quot;3&quot;,&quot;neighbors&quot;:[{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 9: ref&quot;:&quot;2&quot;}̲,{&quot;'>ref&quot;:&quot;2&quot;},{&quot;</span>id&quot;:&quot;4&quot;,&quot;neighbors&quot;:[{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 9: ref&quot;:&quot;3&quot;}̲,{&quot;'>ref&quot;:&quot;3&quot;},{&quot;</span>ref&quot;:&quot;1&quot;}],&quot;val&quot;:4}],&quot;val&quot;:3}],&quot;val&quot;:2},{&quot;$ref&quot;:&quot;4&quot;}],&quot;val&quot;:1}<br>
解释：<br>
节点 1 的值是 1，它有两个邻居：节点 2 和 4 。<br>
节点 2 的值是 2，它有两个邻居：节点 1 和 3 。<br>
节点 3 的值是 3，它有两个邻居：节点 2 和 4 。<br>
节点 4 的值是 4，它有两个邻居：节点 1 和 3 。<br>
提示：<br>
节点数介于 1 到 100 之间。<br>
无向图是一个简单图，这意味着图中没有重复的边，也没有自环。<br>
由于图是无向的，如果节点 p 是节点 q 的邻居，那么节点 q 也必须是节点 p 的邻居。<br>
必须将给定节点的拷贝作为对克隆图的引用返回。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/clone-graph<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>//一开始就感觉这个其实是一个遍历题，主要是保证每个节点仅被遍历一次否则会new出重复的节点，看了大话数据结构的源代码后，发现缺少一个记录已访问节点的结构，就使用map代替了<br>
//map就保存一对结点，一个旧结点对应一个新节点<br>
//然后主要流程就是构造新节点-利用map判断是否已存在-存在则连接-不存在则递归调用<br>
//最后空间复杂度爆炸，但是时间复杂度还可以<br>
//时间复杂度O(n^2) 假设每个点都相连，则需要两层n循环</p>
<pre><code>/*
// Definition for a Node.
class Node {
public:
    int val;
    vector&lt;Node*&gt; neighbors;

    Node() {}

    Node(int _val, vector&lt;Node*&gt; _neighbors) {
        val = _val;
        neighbors = _neighbors;
    }
};
*/
class Solution {
public:
    map&lt;Node*,Node*&gt; mnn;
    Node* cloneGraph(Node* node) {
        Node *cur=new Node(node-&gt;val,vector&lt;Node*&gt;());
        mnn.insert({node,cur});
        for(auto i:node-&gt;neighbors){
            if(mnn.count(i))
                cur-&gt;neighbors.push_back(mnn[i]);
            else{       
               auto next=cloneGraph(i); 
                cur-&gt;neighbors.push_back(next);
            }
        }
        return cur;
    }
};
</code></pre>
<p>然后来看看网友题解：</p>
<blockquote>
<p>解题思路:<br>
这道题就是遍历整个图，所以遍历时候要记录已经访问点，我们用一个字典记录。<br>
所以，遍历方法就有两种。<br>
思路一:DFS (深度遍历)<br>
思路二:BFS (广度遍历)<br>
大家重点掌握，后面图遍历都和这个有关系！<br>
代码:<br>
思路一:</p>
</blockquote>
<pre><code>Java
class Solution {
    public Node cloneGraph(Node node) {
        Map&lt;Node, Node&gt; lookup = new HashMap&lt;&gt;();
        return dfs(node, lookup);
    }

    private Node dfs(Node node, Map&lt;Node,Node&gt; lookup) {
        if (node == null) return null;
        if (lookup.containsKey(node)) return lookup.get(node);
        Node clone = new Node(node.val, new ArrayList&lt;&gt;());
        lookup.put(node, clone);
        for (Node n : node.neighbors)clone.neighbors.add(dfs(n,lookup));
        return clone;
    }
}
</code></pre>
<blockquote>
<p>思路二:</p>
</blockquote>
<pre><code>Java
class Solution {
    public Node cloneGraph(Node node) {
        if (node == null) return null;
        Map&lt;Node, Node&gt; lookup = new HashMap&lt;&gt;();
        Node clone = new Node(node.val, new ArrayList&lt;&gt;());
        lookup.put(node, clone);
        Deque&lt;Node&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(node);
        while (!queue.isEmpty()) {
            Node tmp = queue.poll();
            for (Node n : tmp.neighbors) {
                if (!lookup.containsKey(n)) {
                    lookup.put(n, new Node(n.val, new ArrayList&lt;&gt;()));
                    queue.offer(n);
                }
                lookup.get(tmp).neighbors.add(lookup.get(n));
            }
        }
        return clone;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 96. 不同的二叉搜索树[中等]]]></title>
        <id>https://lixin-ee.github.io//post/shu-96-bu-tong-de-er-cha-sou-suo-shu-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/shu-96-bu-tong-de-er-cha-sou-suo-shu-zhong-deng">
        </link>
        <updated>2019-12-06T01:27:17.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？<br>
示例:<br>
输入: 3<br>
输出: 5<br>
解释:<br>
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:<br>
1         3     3      2      1<br>
\       /     /      / \      <br>
3     2     1      1   3      2<br>
/     /       \                 <br>
2     1         2                 3</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/unique-binary-search-trees<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<pre><code> class Solution {
public:
    
    int numTrees(int n) {
        vector&lt;int&gt; vi(n+1,0);
        vi[0]=1;
        for(int i=1;i&lt;=n;++i){
            int res=0;
            for(int j=1;j&lt;=i;++j){
               res+=vi[j-1]*vi[i-j]; 
            }
            vi[i]=res;
        }
        return vi[n];
    }
};
</code></pre>
<p>//一开始想单纯地找n和树的可能性之间的关系，结果发现不靠谱，因为单纯地在n-1的可能里加上1个值的话会有重复的情况<br>
//然后就想到以根为参考点的方法，就是 1，2，3中，分别考虑根节点为1，2，3的可能，此时就把问题化为两边子树的可能性了<br>
//最后看了题解发现这就是动态规划嘛，从n=1的情况开始推到n=n的情况<br>
//需要注意的是 当子树节点树为0的时候也是视为一种可能性。然后就是vi的长度是n+1，需要额外保存0的情况<br>
//然后就是不能把根结底算进去<br>
非常操蛋的是8ms只击败了12%，题解里面肯定是有很简单的数学方法<br>
//果然是，其实就是把第二个循环变成了通用公式</p>
<p>然后来看一下网友题解：</p>
<blockquote>
<p>思路<br>
标签：动态规划<br>
假设n个节点存在二叉排序树的个数是G(n)，令f(i)为以i为根的二叉搜索树的个数，则<br>
G(n) = f(1) + f(2) + f(3) + f(4) + ... + f(n)<br>
当i为根节点时，其左子树节点个数为i-1个，右子树节点为n-i，则<br>
f(i) = G(i-1)*G(n-i)<br>
综合两个公式可以得到 卡特兰数 公式<br>
G(n) = G(0)<em>G(n-1)+G(1)</em>(n-2)+...+G(n-1)*G(0)<br>
代码</p>
</blockquote>
<pre><code>Java
class Solution {
    public int numTrees(int n) {
        int[] dp = new int[n+1];
        dp[0] = 1;
        dp[1] = 1;
        
        for(int i = 2; i &lt; n + 1; i++)
            for(int j = 1; j &lt; i + 1; j++) 
                dp[i] += dp[j-1] * dp[i-j];
        
        return dp[n];
    }
}
</code></pre>
<p>官方题解：<br>
<img src="https://lixin-ee.github.io//post-images/1575596257408.png" alt=""><br>
复杂度分析<br>
时间复杂度 : O(N)，只有一层循环。<br>
空间复杂度 : O(1)，只需要一个变量来存储中间与最终结果。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 117. 填充每个节点的下一个右侧节点指针 II[中等] ]]></title>
        <id>https://lixin-ee.github.io//post/shu-117-tian-chong-mei-ge-jie-dian-de-xia-yi-ge-you-ce-jie-dian-zhi-zhen-iizhong-deng</id>
        <link href="https://lixin-ee.github.io//post/shu-117-tian-chong-mei-ge-jie-dian-de-xia-yi-ge-you-ce-jie-dian-zhi-zhen-iizhong-deng">
        </link>
        <updated>2019-12-05T01:41:49.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个二叉树<br>
struct Node {<br>
int val;<br>
Node *left;<br>
Node *right;<br>
Node *next;<br>
}<br>
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。<br>
初始状态下，所有 next 指针都被设置为 NULL。<br>
进阶：<br>
你只能使用常量级额外空间。<br>
使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1575510214544.png" alt=""></p>
<blockquote>
<p>输入：root = [1,2,3,4,5,null,7]<br>
输出：[1,#,2,3,#,4,5,7,#]<br>
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。<br>
提示：<br>
树中的节点数小于 6000<br>
-100 &lt;= node.val &lt;= 100<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>因为前一题我用了通用性较高的方法，所以这一题居然直接完成了hhh，然后优雅的用法是没法用了，但是我的方法事件复杂度比较高（603ms还击败50%什么鬼），还是老老实实看一下题解吧<br>
同样地我的解法的问题在于不是常量的空间复杂度</p>
<p>然后来看网友题解：</p>
<blockquote>
<p>队列是为了维护先后关系<br>
但是先后关系本来就存在了next里<br>
所以可以不使用队列<br>
队列做法</p>
</blockquote>
<pre><code>Node* connect(Node* root) {
        if(root == NULL)return root;
        queueq;
        q.push(root);
        while(!q.empty()){
            Node*cur = NULL;
            int size = q.size();
            for(int i = size;i&gt;=0;i--){
                Node *tmp = q.front();q.pop();
                if(cur != NULL){
                    cur-&gt;next = tmp;
                }
                cur = tmp;
                if(tmp-&gt;left)q.push(tmp-&gt;left);
                if(tmp-&gt;right)q.push(tmp-&gt;right);
            }
        }
        return root;
</code></pre>
<blockquote>
<p>使用next来代替队列</p>
</blockquote>
<pre><code>Node* connect(Node* root) {
        Node *last = root;
        while(last != NULL){
            // 获得队首元素
            while(last &amp;&amp; last-&gt;left == NULL &amp;&amp; last-&gt;right == NULL)last = last-&gt;next;
            if(last == NULL)break;
            Node *cur = NULL;
            // 遍历队列
            for(Node *i = last;i != NULL;i = i-&gt;next){
                // 进行push和pop操作
                if(i -&gt; left){
                    if(cur != NULL){
                        cur-&gt;next = i-&gt;left;
                    }
                    cur = i-&gt;left;
                }
                if(i -&gt; right){
                    if(cur != NULL){
                        cur-&gt;next = i-&gt;right;
                    }
                    cur = i-&gt;right;
                }
            }
            // 更新队首
            last = last-&gt;left ? last-&gt;left : last-&gt;right;
        }
        return root;
    }
</code></pre>
<p>比较详细的做法：</p>
<blockquote>
<p>解法一 BFS<br>
直接把 116 题 题的代码复制过来就好，一句也不用改。<br>
利用一个栈将下一层的节点保存。通过pre指针把栈里的元素一个一个接起来。</p>
</blockquote>
<pre><code>public Node connect(Node root) {
    if (root == null) {
        return root;
    }
    Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;();
    queue.offer(root);
    while (!queue.isEmpty()) {
        int size = queue.size();
        Node pre = null;
        for (int i = 0; i &lt; size; i++) {
            Node cur = queue.poll();
            if (i &gt; 0) {
                pre.next = cur;
            }
            pre = cur;
            if (cur.left != null) {
                queue.offer(cur.left);
            }
            if (cur.right != null) {
                queue.offer(cur.right);
            }

        }
    }
    return root;
}
</code></pre>
<blockquote>
<p>解法二<br>
当然题目要求了空间复杂度，可以先到 116 题 看一下思路，这里在上边的基础上改一下。<br>
我们用第二种简洁的代码，相对会好改一些。</p>
</blockquote>
<pre><code>Node connect(Node root) {
    if (root == null)
        return root;
    Node pre = root;
    Node cur = null;
    while (pre.left != null) {
        cur = pre;
        while (cur != null) {
            cur.left.next = cur.right;
            if (cur.next != null) {
                cur.right.next = cur.next.left;
            }
            cur = cur.next;
        }
        pre = pre.left;
    }

    return root;
}
</code></pre>
<blockquote>
<p>需要解决的问题还是挺多的。<br>
cur.left.next = cur.right;<br>
cur.right.next = cur.next.left;<br>
之前的关键代码就是上边两句，但是在这道题中我们无法保证cur.left 或者 cur.right 或者 cur.next.left或者cur.next.right 是否为null。所以我们需要用一个while循环来保证当前节点至少有一个孩子。<br>
while (cur.left == null &amp;&amp; cur.right == null) {<br>
cur = cur.next;<br>
}<br>
这样的话保证了当前节点至少有一个孩子，然后如果一个孩子为 null，那么就可以保证另一个一定不为 null 了。<br>
整体的话，就用了上边介绍的技巧，代码比较长，可以结合的看一下。</p>
</blockquote>
<pre><code>Node connect(Node root) {
    if (root == null)
        return root;
    Node pre = root;
    Node cur = null;
    while (true) {
        cur = pre;
        while (cur != null) {
            //找到至少有一个孩子的节点
            if (cur.left == null &amp;&amp; cur.right == null) {
                cur = cur.next;
                continue;
            }
            //找到当前节点的下一个至少有一个孩子的节点
            Node next = cur.next;
            while (next != null &amp;&amp; next.left == null &amp;&amp; next.right == null) {
                next = next.next;
                if (next == null) {
                    break;
                }
            }
            //当前节点的左右孩子都不为空，就将 left.next 指向 right
            if (cur.left != null &amp;&amp; cur.right != null) {
                cur.left.next = cur.right;
            }
            //要接上 next 的节点的孩子，所以用 temp 处理当前节点 right 为 null 的情况
            Node temp = cur.right == null ? cur.left : cur.right;

            if (next != null) {
                //next 左孩子不为 null，就接上左孩子。
                if (next.left != null) {
                    temp.next = next.left;
                //next 左孩子为 null，就接上右孩子。
                } else {
                    temp.next = next.right;
                }
            }
            
            cur = cur.next;
        }
        //找到拥有孩子的节点
        while (pre.left == null &amp;&amp; pre.right == null) {
            pre = pre.next;
            //都没有孩子说明已经是最后一层了
            if (pre == null) {
                return root;
            }
        }
        //进入下一层
        pre = pre.left != null ? pre.left : pre.right;
    } 
}
</code></pre>
<p>解法三</p>
<blockquote>
<p>利用解法一的思想，我们利用 pre 指针，然后一个一个取节点，把它连起来。解法一为什么没有像解法二那样考虑当前节点为 null 呢？因为我们没有添加为 null 的节点，就是下边的代码的作用。<br>
if (cur.left != null) {<br>
queue.offer(cur.left);<br>
}<br>
if (cur.right != null) {<br>
queue.offer(cur.right);<br>
}<br>
所以这里是一样的，如果当前节点为null不处理就可以了。</p>
</blockquote>
<blockquote>
<p>第二个问题，怎么得到每次的开头的节点呢？我们用一个dummy指针，当连接第一个节点的时候，就将dummy指针指向他。此外，之前用的pre指针，把它当成tail指针可能会更好理解。如下图所示：</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1575511034936.png" alt=""></p>
<blockquote>
<p>cur 指针利用 next 不停的遍历当前层。<br>
如果 cur 的孩子不为 null 就将它接到 tail 后边，然后更新tail。<br>
当 cur 为 null 的时候，再利用 dummy 指针得到新的一层的开始节点。<br>
dummy 指针在链表中经常用到，他只是为了处理头结点的情况，它并不属于当前链表。<br>
代码就异常的简单了。</p>
</blockquote>
<pre><code>Node connect(Node root) {
    Node cur = root;
    while (cur != null) {
        Node dummy = new Node();
        Node tail = dummy;
        //遍历 cur 的当前层
        while (cur != null) {
            if (cur.left != null) {
                tail.next = cur.left;
                tail = tail.next;
            }
            if (cur.right != null) {
                tail.next = cur.right;
                tail = tail.next;
            }
            cur = cur.next;
        }
        //更新 cur 到下一层
        cur = dummy.next;
    }
    return root;
}
</code></pre>
<blockquote>
<p>总<br>
本来为了图方便，在 116 题 的基础上把解法二改了出来，还搞了蛮久，因为为 null 的情况太多了，不停的报空指针异常，最后终于理清了思路。但和解法三比起来实在是相形见绌了，解法三太优雅了，但其实这才是正常的思路，从解法一的做法产生灵感，利用 tail 指针将它们连起来。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 116. 填充每个节点的下一个右侧节点指针[中等]]]></title>
        <id>https://lixin-ee.github.io//post/shu-116-tian-chong-mei-ge-jie-dian-de-xia-yi-ge-you-ce-jie-dian-zhi-zhen-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/shu-116-tian-chong-mei-ge-jie-dian-de-xia-yi-ge-you-ce-jie-dian-zhi-zhen-zhong-deng">
        </link>
        <updated>2019-12-04T01:54:29.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：<br>
struct Node {<br>
int val;<br>
Node *left;<br>
Node *right;<br>
Node *next;<br>
}<br>
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。<br>
初始状态下，所有 next 指针都被设置为 NULL。<br>
示例：</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1575424563194.png" alt=""></p>
<blockquote>
<p>输入：{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: …&quot;:&quot;1&quot;,&quot;left&quot;:{&quot;'>id&quot;:&quot;1&quot;,&quot;left&quot;:{&quot;</span>id&quot;:&quot;2&quot;,&quot;left&quot;:{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 53: …t&quot;:null,&quot;val&quot;:4}̲,&quot;next&quot;:null,&quot;r…'>id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:4},&quot;next&quot;:null,&quot;right&quot;:{&quot;</span>id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:5},&quot;val&quot;:2},&quot;next&quot;:null,&quot;right&quot;:{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: …&quot;:&quot;5&quot;,&quot;left&quot;:{&quot;'>id&quot;:&quot;5&quot;,&quot;left&quot;:{&quot;</span>id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:6},&quot;next&quot;:null,&quot;right&quot;:{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 53: …t&quot;:null,&quot;val&quot;:7}̲,&quot;val&quot;:3},&quot;val&quot;…'>id&quot;:&quot;7&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7},&quot;val&quot;:3},&quot;val&quot;:1}
输出：{&quot;</span>id&quot;:&quot;1&quot;,&quot;left&quot;:{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: …&quot;:&quot;2&quot;,&quot;left&quot;:{&quot;'>id&quot;:&quot;2&quot;,&quot;left&quot;:{&quot;</span>id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: …:null,&quot;next&quot;:{&quot;'>id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:{&quot;</span>id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 53: …t&quot;:null,&quot;val&quot;:7}̲,&quot;right&quot;:null,&quot;…'>id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7},&quot;right&quot;:null,&quot;val&quot;:6},&quot;right&quot;:null,&quot;val&quot;:5},&quot;right&quot;:null,&quot;val&quot;:4},&quot;next&quot;:{&quot;</span>id&quot;:&quot;7&quot;,&quot;left&quot;:{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 9: ref&quot;:&quot;5&quot;}̲,&quot;next&quot;:null,&quot;r…'>ref&quot;:&quot;5&quot;},&quot;next&quot;:null,&quot;right&quot;:{&quot;</span>ref&quot;:&quot;6&quot;},&quot;val&quot;:3},&quot;right&quot;:{&quot;<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 9: ref&quot;:&quot;4&quot;}̲,&quot;val&quot;:2},&quot;next…'>ref&quot;:&quot;4&quot;},&quot;val&quot;:2},&quot;next&quot;:null,&quot;right&quot;:{&quot;</span>ref&quot;:&quot;7&quot;},&quot;val&quot;:1}<br>
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。 <br>
提示：<br>
你只能使用常量级额外空间。<br>
使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<pre><code>class Solution {
public:
    vector&lt;Node*&gt; vn;
    Node* connect(Node* root) {
        preorder(root,0);
        return root;
    }
    
    void preorder(Node *cur,int i){
        if(cur==NULL)
            return;
        if(vn.size()==i)
            vn.push_back(cur);
        else{
            vn[i]-&gt;next=cur;
            vn[i]=cur;
        }
        preorder(cur-&gt;left,i+1);
        preorder(cur-&gt;right,i+1);
        return;
    }
};
</code></pre>
<p>我一开始只想到了层次遍历，参考层次遍历，利用先序遍历和vector的话可以按照从左到右的顺序来保存层次遍历的结果，由于我们只需要和前一个节点链接，所以这一次只需要一层vector&lt;Node*&gt;就好<br>
然后重点主要是push_back的判断和每个节点和前一个节点链接并更新vector<br>
唯一的缺点就是我这个vector不是常量空间<br>
看了题解，非常优雅啊！直接处理子树的链接和相邻子树的链接，值得学习</p>
<p>看看网友题解</p>
<pre><code>    Node* connect(Node* root) {
        if (!root) return root;
        Node * left = root-&gt;left;
        Node * right = root-&gt;right;
        while(left) {
            left-&gt;next = right;
            left = left-&gt;right;
            right = right-&gt;left;
        }
        connect(root-&gt;left);
        connect(root-&gt;right);
        return root;
    }
</code></pre>
<p>主要就是把完美二叉树劈成两半，先处理大的两半二叉树中间的左右连接，然后递归处理小的连接</p>
<p>非递归方法</p>
<pre><code>Node* connect(Node* root) {
    if (root == nullptr)return nullptr;
	if (root-&gt;left == nullptr) return root; 
    else 
    {
        root-&gt;left-&gt;next = root-&gt;right;
    }
	Node* cur = root-&gt;left-&gt;left;
	Node* pre = root-&gt;left;
	while (cur!=nullptr)
	{
		while (pre!=nullptr)
		{
			pre-&gt;left-&gt;next = pre-&gt;right;
			if (pre-&gt;next != nullptr)pre-&gt;right-&gt;next = pre-&gt;next-&gt;left;
			else pre-&gt;right-&gt;next = nullptr;
			pre = pre-&gt;next;
		}
		pre = cur;
		cur = cur-&gt;left;
	}
	return root;
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 99. 恢复二叉搜索树[困难]]]></title>
        <id>https://lixin-ee.github.io//post/shu-99-hui-fu-er-cha-sou-suo-shu-kun-nan</id>
        <link href="https://lixin-ee.github.io//post/shu-99-hui-fu-er-cha-sou-suo-shu-kun-nan">
        </link>
        <updated>2019-12-03T01:30:05.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>二叉搜索树中的两个节点被错误地交换。<br>
请在不改变其结构的情况下，恢复这棵树。<br>
示例 1:<br>
输入: [1,3,null,null,2]<br>
   1<br>
  /<br>
 3<br>
  <br>
   2<br>
输出: [3,1,null,null,2]<br>
   3<br>
  /<br>
 1<br>
  <br>
   2<br>
示例 2:<br>
输入: [3,1,4,null,null,2]<br>
3<br>
/ <br>
1   4<br>
   /<br>
  2<br>
输出: [2,1,4,null,null,3]<br>
2<br>
/ <br>
1   4<br>
   /<br>
 3<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/recover-binary-search-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<pre><code>class Solution {
public:
    TreeNode *tempnode,*tempnode1,*tempnode2;
    void recoverTree(TreeNode* root){
        inorder(root);
        swap(tempnode1-&gt;val,tempnode2-&gt;val);
        return;
    }
    
    void inorder(TreeNode* cur)    
    {
        if(cur==NULL)
            return;
        inorder(cur-&gt;left);
        if(tempnode&amp;&amp;cur-&gt;val&lt;tempnode-&gt;val){
            if(tempnode1==NULL)
                tempnode1=tempnode;
            tempnode2=cur;
        }
        tempnode=cur;
        inorder(cur-&gt;right);
        return;
    }
};
</code></pre>
<p>1.一开始想着使用中序遍历的vector来交换两个点，但是思路不太对，我的想法是找到后一个值比前一个值小的时候就互换，但是是不对的。比如序列 3，2，1应该交换3和1，但是我的思路会交换3和2，所以应该找到最后一个矛盾点<br>
2.通过草稿纸演算，我发现一般来说会出现一到两个点的矛盾点（亦即前一个值大于后一个值），我打算保存两个指针值然后交换值<br>
3.这下又被坏习惯坑了，比如 TreeNode* temp1,temp2; 其实*号的位置很重要，这样子的话temp2被定义为TreeNode而是相应的指针<br>
4.终于通过了，主要注意的点是需要保存两个异常值，同时更新异常值的方式很重要，因为可能出现相邻互换的情况，所以第一个异常值指针只需要赋值一次，第二个异常指针值就需要赋值两次<br>
5.看了题解之后发现值得优化的点是因为必须保存前一个指针用于保存第一个异常值，所以完全可以用这个指针来得到pre-&gt;val，而不需要一个全局int<br>
6.更改后，直接 99.67%和100%，吓到我了</p>
<p>然后看一下网友题解</p>
<blockquote>
<p>思路:<br>
这道题难点,是找到那两个交换节点,把它交换过来就行了.<br>
这里我们二叉树搜索树的中序遍历(中序遍历遍历元素是递增的)<br>
如下图所示, 中序遍历顺序是 4,2,3,1,我们只要找到节点4和节点1交换顺序即可!<br>
这里我们有个规律发现这两个节点:<br>
第一个节点,是第一个按照中序遍历时候前一个节点大于后一个节点,我们选取前一个节点,这里指节点4;<br>
第二个节点,是在第一个节点找到之后, 后面出现前一个节点大于后一个节点,我们选择后一个节点,这里指节点1;<br>
对于中序遍历,我们有两种方法.<br>
方法一: 迭代<br>
java</p>
</blockquote>
<pre><code>class Solution {
    public void recoverTree(TreeNode root) {
        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();
        TreeNode firstNode = null;
        TreeNode secondNode = null;
        TreeNode pre = new TreeNode(Integer.MIN_VALUE);
        TreeNode p = root;
        while (p != null || !stack.isEmpty()) {
            while (p != null) {
                stack.push(p);
                p = p.left;
            }
            p = stack.pop();
            if (firstNode == null &amp;&amp; pre.val &gt; p.val) firstNode = pre;
            if (firstNode != null &amp;&amp; pre.val &gt; p.val) secondNode = p;
            pre = p;
            p = p.right;
        }
        int tmp = firstNode.val;
        firstNode.val = secondNode.val;
        secondNode.val = tmp;
    }
}
</code></pre>
<blockquote>
<p>方法二: 递归</p>
</blockquote>
<pre><code>java
class Solution {
    TreeNode firstNode = null;
    TreeNode secondNode = null;
    TreeNode preNode = new TreeNode(Integer.MIN_VALUE);

    public void recoverTree(TreeNode root) {

        in_order(root);
        int tmp = firstNode.val;
        firstNode.val = secondNode.val;
        secondNode.val = tmp;
    }

    private void in_order(TreeNode root) {
        if (root == null) return;
        in_order(root.left);
        if (firstNode == null &amp;&amp; preNode.val &gt; root.val) firstNode = preNode;
        if (firstNode != null &amp;&amp; preNode.val &gt; root.val) secondNode = root;
        preNode = root;
        in_order(root.right);
    }
}
</code></pre>
<p>这位网友的思路和我的一致</p>
<blockquote>
<p>然后来看看其他解法：<br>
解法一 递归<br>
和 98 题有些像。这里的思路如下：<br>
让我们来考虑交换的位置的可能：<br>
根节点和左子树的某个数字交换 -&gt; 由于根节点大于左子树中的所有数，所以交换后我们只要找左子树中最大的那个数，就是所交换的那个数<br>
根节点和右子树的某个数字交换 -&gt; 由于根节点小于右子树中的所有数，所以交换后我们只要在右子树中最小的那个数，就是所交换的那个数<br>
左子树和右子树的两个数字交换 -&gt; 找左子树中最大的数，右子树中最小的数，即对应两个交换的数<br>
左子树中的两个数字交换<br>
右子树中的两个数字交换<br>
思想有了，代码很好写了。</p>
</blockquote>
<pre><code>public void recoverTree2(TreeNode root) {
    if (root == null) {
        return;
    }
    //寻找左子树中最大的节点
    TreeNode maxLeft = getMaxOfBST(root.left);
    //寻找右子树中最小的节点
    TreeNode minRight = getMinOfBST(root.right);
    
    if (minRight != null &amp;&amp; maxLeft != null) {
        //左边的大于根节点，右边的小于根节点，对应情况 3，左右子树中的两个数字交换
        if ( maxLeft.val &gt; root.val &amp;&amp; minRight.val &lt; root.val) {
            int temp = minRight.val;
            minRight.val = maxLeft.val;
            maxLeft.val = temp;
        }
    }

    if (maxLeft != null) {
        //左边最大的大于根节点，对应情况 1，根节点和左子树的某个数做了交换
        if (maxLeft.val &gt; root.val) {
            int temp = maxLeft.val;
            maxLeft.val = root.val;
            root.val = temp;
        }
    }

    if (minRight != null) {
        //右边最小的小于根节点，对应情况 2，根节点和右子树的某个数做了交换
        if (minRight.val &lt; root.val) {
            int temp = minRight.val;
						minRight.val = root.val;
            root.val = temp;
        }
    }
    //对应情况 4，左子树中的两个数进行了交换
    recoverTree(root.left);
    //对应情况 5，右子树中的两个数进行了交换
    recoverTree(root.right);

}
//寻找树中最小的节点
private TreeNode getMinOfBST(TreeNode root) {
    if (root == null) {
        return null;
    }
    TreeNode minLeft = getMinOfBST(root.left);
    TreeNode minRight = getMinOfBST(root.right);
    TreeNode min = root;
    if (minLeft != null &amp;&amp; min.val &gt; minLeft.val) {
        min = minLeft;
    }
    if (minRight != null &amp;&amp; min.val &gt; minRight.val) {
        min = minRight;
    }
    return min;
}

//寻找树中最大的节点
private TreeNode getMaxOfBST(TreeNode root) {
    if (root == null) {
        return null;
    }
    TreeNode maxLeft = getMaxOfBST(root.left);
    TreeNode maxRight = getMaxOfBST(root.right);
    TreeNode max = root;
    if (maxLeft != null &amp;&amp; max.val &lt; maxLeft.val) {
        max = maxLeft;
    }
    if (maxRight != null &amp;&amp; max.val &lt; maxRight.val) {
        max = maxRight;
    }
    return max;
}
</code></pre>
<p>然后是空间复杂度为O（1）的莫里斯遍历</p>
<blockquote>
<p>Morris 版中序遍历<br>
因为之前这个方法中用了 pre 变量，为了方便，这里也需要 pre 变量，我们用 pre_new 代替。具体 Morris 遍历算法参见 94 题 。利用 Morris 的话，我们的空间复杂度终于达到了 O（1）。</p>
</blockquote>
<pre><code>public void recoverTree(TreeNode root) {
    TreeNode first = null;
    TreeNode second = null;
    TreeNode cur = root;
    TreeNode pre_new = null;
    while (cur != null) {
        // 情况 1
        if (cur.left == null) {
            /*******************************************************/
            if (pre_new != null &amp;&amp; cur.val &lt; pre_new.val) {
                if (first == null) {
                    first = pre_new;
                    second = cur;
                } else {
                    second = cur;
                }
            }
            pre_new = cur;
            /*******************************************************/
            cur = cur.right;
        } else {
            // 找左子树最右边的节点
            TreeNode pre = cur.left;
            while (pre.right != null &amp;&amp; pre.right != cur) {
                pre = pre.right;
            }
            // 情况 2.1
            if (pre.right == null) {
                pre.right = cur;
                cur = cur.left;
            }
           // 情况 2.2
            if (pre.right == cur) {
                pre.right = null; // 这里可以恢复为 null
                /*******************************************************/
                if (pre_new != null &amp;&amp; cur.val &lt; pre_new.val) {
                    if (first == null) {
                        first = pre_new;
                        second = cur;
                    } else {
                        second = cur;
                    }
                }
                pre_new = cur;
                /*******************************************************/
                cur = cur.right;
            }
        }
    }
    
    int temp = first.val;
    first.val = second.val;
    second.val = temp;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 297. 二叉树的序列化与反序列化[困难][未做出]]]></title>
        <id>https://lixin-ee.github.io//post/shu-297-er-cha-shu-de-xu-lie-hua-yu-fan-xu-lie-hua-kun-nan</id>
        <link href="https://lixin-ee.github.io//post/shu-297-er-cha-shu-de-xu-lie-hua-yu-fan-xu-lie-hua-kun-nan">
        </link>
        <updated>2019-12-02T07:21:48.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。<br>
请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。<br>
示例: <br>
你可以将以下二叉树：<br>
1<br>
/ <br>
2   3<br>
/ <br>
4   5<br>
序列化为 &quot;[1,2,3,null,null,4,5]&quot;<br>
提示: 这与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。<br>
说明: 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题可以说是很曲折了<br>
1.一开始以为层次遍历比较好，但是看了一下题解发现还是先序遍历比较方便，因为可以按照string至今进行链接，而层次遍历需要一个队列来保存<br>
2.题解中的大佬用了ostringstream和istringstream，很方便，很值得学习。<br>
3.然后我就在上述两个stream中翻了车，一开始是哈皮了，忘了string的push_back要求的是单引号的字符变量‘#’而不是直接string，所以“#”和to_string都是没法用pushback的，只能用加号或者单引号。另一个就是ostringstream是有格式的，所以必须用空格隔开将连续的数字隔开，否则会连起来stoi会输出一个超级大的数字（但是似乎允许123#123这种形式，并输出 “123” “#” “123”三者）<br>
4.剩下的就是stream的使用了吧，dalao的思维还是很厉害的。<br>
5.还有的话就是理解一下先序遍历为何可以重建二叉树（等等！大话数据结构里面不是说建树和遍历只需要改一下相应的就好嘛hhh，确认了！！快回去复习大话数据结构！！！就在6.9节）</p>
<p>代码如下：</p>
<pre><code>class Codec {
public:
   /*string serialize(TreeNode* root) {
        ostringstream out;
        serialize(root,out);
        return out.str();
    }*/

    /*void serialize(TreeNode* root,ostringstream&amp; out){
        if(root){
            out&lt;&lt;root-&gt;val&lt;&lt;' ';
            serialize(root-&gt;left,out);
            serialize(root-&gt;right,out);
        }else{
            out&lt;&lt;&quot;# &quot;;
        }
        
    }*/
    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        string s;
        serialize(root,s);
        return s;
    }

    void serialize(TreeNode *cur,string &amp;s){
        s.push_back(' ');
        if(cur==NULL){
            s.push_back('#');
            return;
        }
        s+=to_string(cur-&gt;val);
        serialize(cur-&gt;left,s);
        serialize(cur-&gt;right,s);
    } 

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        istringstream is(data);
        return deserialize(is);
    }

    TreeNode* deserialize(istringstream &amp;is){
        string val;
        is&gt;&gt;val;
        if(val==&quot;#&quot;)
         return NULL;
        
        TreeNode* cur=new TreeNode(stoi(val));
       cur-&gt;left=deserialize(is);
        cur-&gt;right=deserialize(is);
        return cur;
    }

    /*TreeNode* deserialize(istringstream&amp; in){
        string val;
        in&gt;&gt;val;
        if(val==&quot;#&quot;){
            return nullptr;
        }
        TreeNode* root=new TreeNode(stoi(val));
        root-&gt;left=deserialize(in);
        root-&gt;right=deserialize(in);
        return root;
    }*/

};

// Your Codec object will be instantiated and called as such:
// Codec codec;
// codec.deserialize(codec.serialize(root));
</code></pre>
<p>然后来看大佬的题解吧</p>
<blockquote>
<p>解法一 先序遍历法<br>
先序遍历二叉树时，将节点输出。<br>
重点是碰到NULL时，也要将其用#标识并输出。NULL节点虽然不是数字，但是能决定二叉树的结构。没有NULL节点，单靠先序序列是无法恢复成树的。<br>
节点与节点之间用空格隔开。<br>
例如：<br>
1<br>
/ <br>
2   3<br>
/ <br>
4   5<br>
其序列化后为， 1 2 # # 3 4 # # 5 # #<br>
可以发现，#标识的NULL节点，紧跟在其父节点的后面。</p>
</blockquote>
<pre><code>    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        if(!root) return string();
        stringstream ss;
        dfs(root,ss);
        return ss.str();
    }
    
    void dfs(TreeNode* rt,stringstream&amp; ss){
        if(!rt){
            ss &lt;&lt; &quot;# &quot;;
            return ;
        }
        ss &lt;&lt; to_string(rt-&gt;val) &lt;&lt;&quot; &quot;;
        dfs(rt-&gt;left,ss);
        dfs(rt-&gt;right,ss);
    }
</code></pre>
<blockquote>
<p>重建时，思路很清晰。<br>
先重建根节点，如果是NULL节点，返回。如果是数字节点，递归重建左子树。之后，再重建右子树。</p>
</blockquote>
<pre><code>void rebuild(TreeNode* &amp; rt,stringstream&amp; ss){
		string t;
		ss &gt;&gt; t;
		if(t[0] == '#'){
				rt = NULL;
				return;
		}
		int v = stoi(t);
		rt = new TreeNode(v);
		rebuild(rt-&gt;left,ss);
		rebuild(rt-&gt;right,ss);
}

// Decodes your encoded data to tree.
TreeNode* deserialize(string data) {
		if(data.empty()) return NULL;
		TreeNode* rt = NULL;
		stringstream ss(data);
		rebuild(rt,ss);
		return rt;
}
</code></pre>
<blockquote>
<p>解法二 层次遍历法<br>
层次遍历也能序列化。在序列化时，遇到NULL节点时，也要输出为#。<br>
用队列设计层次遍历。</p>
</blockquote>
<pre><code>	string serialize(TreeNode* root) {
			if(!root) return &quot;&quot;;
			stringstream ss;
			queue&lt;TreeNode*&gt; Q;
			Q.push(root);
			while(Q.size()){
					TreeNode* p = Q.front();Q.pop();
					if(!p) ss &lt;&lt;&quot;# &quot;;
					else{
							ss &lt;&lt; p-&gt;val &lt;&lt;&quot; &quot;;
							Q.push(p-&gt;left);
							Q.push(p-&gt;right);
					}
			}
			return ss.str();
	}
</code></pre>
<blockquote>
<p>难点在于层次遍历的反序列化。不容易想清楚重建的顺序应该是怎么样的。<br>
1<br>
/ <br>
2   3<br>
/ <br>
4   5<br>
序列化后， 1 2 3 # # 4 5 # # # # 。<br>
第一个节点是1，是根节点。但是还未完成，其还有两个子节点。<br>
此时，只能将存入队列。<br>
接着是2，其是1的左子节点。<br>
接着是3，其是1的右子节点。<br>
可以看出，除了根节点，后面的节点必须成对出现，且第一个是某节点的左子节点，第二个是其右子节点。<br>
同样，2和3的子节点也还没有出现，同样要先入队列。</p>
</blockquote>
<pre><code>TreeNode* deserialize(string data) {
		if(data.empty()) return NULL;
		stringstream ss(data);
		string t;
		ss &gt;&gt; t;
		TreeNode* rt = new TreeNode(stoi(t));
		queue&lt;TreeNode*&gt; Q;
		Q.push(rt);
		while(Q.size()){
				TreeNode* p = Q.front();Q.pop();
				ss &gt;&gt; t;
				if(t[0] == '#'){
						p-&gt;left = NULL;
				}else{
						p-&gt;left = new TreeNode(stoi(t));
						Q.push(p-&gt;left);
				}
				ss &gt;&gt; t;
				if(t[0] == '#'){
						p-&gt;right = NULL;
				}else{
						p-&gt;right = new TreeNode(stoi(t));
						Q.push(p-&gt;right);
				}
		}
		return rt;
}
</code></pre>
<p>另一位C++大佬的题解，没有解析</p>
<pre><code>class Codec {
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        ostringstream out;
        serialize(root,out);
        return out.str();
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        istringstream in(data);
        return deserialize(in);
    }
private:
    void serialize(TreeNode* root,ostringstream&amp; out){
        if(root){
            out&lt;&lt;root-&gt;val&lt;&lt;' ';
            serialize(root-&gt;left,out);
            serialize(root-&gt;right,out);
        }else{
            out&lt;&lt;&quot;# &quot;;
        }
        
    }
    TreeNode* deserialize(istringstream&amp; in){
        string val;
        in&gt;&gt;val;
        if(val==&quot;#&quot;){
            return nullptr;
        }
        TreeNode* root=new TreeNode(stoi(val));
        root-&gt;left=deserialize(in);
        root-&gt;right=deserialize(in);
        return root;
    }
};
</code></pre>
<p>官方题解的解析：<br>
<img src="https://lixin-ee.github.io//post-images/1575272094124.png" alt=""><br>
其中机翻错误加泰罗尼亚语的数字==卡特兰数</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++primer 目录与链接]]></title>
        <id>https://lixin-ee.github.io//post/cprimer-mu-lu-yu-lian-jie</id>
        <link href="https://lixin-ee.github.io//post/cprimer-mu-lu-yu-lian-jie">
        </link>
        <updated>2019-11-30T13:43:48.000Z</updated>
        <content type="html"><![CDATA[<p>今晚在做算法题的时候想看一下pair的性质，结果发现按照章节不好找啊！，打算按照文字化目录来完成这篇文章</p>
]]></content>
    </entry>
</feed>