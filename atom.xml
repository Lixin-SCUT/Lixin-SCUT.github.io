<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2020-02-14T09:59:27.277Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[ C++中的关键字 inline]]></title>
        <id>https://lixin-scut.github.io//post/czhong-de-guan-jian-zi-inline</id>
        <link href="https://lixin-scut.github.io//post/czhong-de-guan-jian-zi-inline">
        </link>
        <updated>2020-02-14T08:24:42.000Z</updated>
        <content type="html"><![CDATA[<p>《C++ primer》<br>
内联函数关键字inline 适用于规模小频繁调用的函数<br>
内联函数 在调用点上召开为一段程序 避免函数调用的开销<br>
内联函数关键字inline 适用于规模小频繁调用的函数<br>
Constexpr函数返回类型和形参类型都是字面值类型（引用 指针 算术类型）（自定义类、IO库、string类等就不是字面值类型），函数体内有且只有一条return语句，被隐式地指定为内联函数<br>
比如 constexpr int func() { return 42; }<br>
Constexpr函数允许返回值并非一个常量，所以不一定返回常量表达式(传入常量表达式，返回常量表达式，反之则返回非常量表达式)<br>
与其他函数不同，内联函数和Constexpr函数 可以多次定义，但需要保持一致，所以通常定义在头文件中</p>
<p>定义在类内部的函数是隐式的inline函数</p>
<p>当我们使用=default时，合成的成员函数会隐式地声明为内联函数，如果不希望其定义为内联，则应该只在成员的类外定义使用=default<br>
如果 = default 在类的内部，则默认构造函数是内联函数，可以直接展开，在类的外部则默认情况下不是内联的</p>
<p>内联成员函数可以声明与定义分离，直接在函数前面加上inline就好，声明定义、内部外部都可以<br>
关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用。</p>
<p>一个lambda表达式表示一个可调用的代码单元，可以将其理解为一个未命名的内联函数</p>
<p>函数模板可声明为 inline 或 constexpr 的，如同非模板函数一样。 inline 或constexpr 说明符放在模板参数列表之后，返回类型之前：</p>
<p>内联命名空间<br>
内联命名空间中的名字可以被外层命名空间直接使用。也就是说，我们无须在内联命名空间的名字前添加表示该命名空问的前缀，通过外层命名空间的名字就可以直接访问它。    定义内联命名空间的方式是在关键字namespace前添加关键字inline：    inline namespace FifthEd{<br>
/ /该命名空间表示本书第5版的代码<br>
关键字inline必须出现在命名空间第一次定义的地方，后续再打开命名空间的时候可以写inline.也可以不写。<br>
当应用程序的代码在一次发布和另一次发布之间发生了改变时，常常会用到内联命名空间。<br>
新发布的可以直接用，旧发布的需要加上前缀</p>
<p>#C 中 inline 的作用<br>
1.c/c++中的inline，使用在函数声明处，表示程序员请求编译器在此函数的被调用处将此函数实现插入，而不是像普通函数那样生成调用代码(申请是否有效取决于编译器)。一般地说，这样做的优点是省掉了调用函数的开销；缺点则是可能会增加代所生成目标代码的尺寸<br>
实际上，即使没有手工指定inline函数，编译器一般还会选择一些代码量较小但使用频繁的函数作为inline函数，以此作为性能优化的途径之一。<br>
2.在C语言中，如果一些函数被频繁调用，不断地有函数入栈，即函数栈，会造成栈空间或栈内存的大量消耗。<br>
为了解决这个问题，特别的引入了inline修饰符，表示为内联函数。<br>
栈空间就是指放置程式的局部数据也就是函数内数据的内存空间，在系统下，栈空间是有限的，假如频繁大量的使用就会造成因栈空间不足所造成的程式出错的问题，函数的死循环递归调用的最终结果就是导致栈内存空间枯竭。<br>
3.inline （内联函数）：在函数调用点把函数代码展开<br>
这里的展开是给编译器的一个建议，建议编译器将内联函数展开，具体会不会展开，还是要看编译器的处理，比如如果在内联函<br>
数中有递归的使用，编译器就不会将它展开，因为编译器只是进行语法，语义分析，并不知道运行的时候递归会有多少层。在编<br>
译期间，复制代码到函数调用处，不会产生符号表，也不存在函数堆栈的开辟和栈帧回收。<br>
一般在函数的代码量比较少，函数的执行开销小于函数的调用开销时，才会使用内联函数。</p>
<p>#inline 和宏的区别。</p>
<p>#inline如果代码过长会怎么样?<br>
内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。<br>
以下情况不宜使用内联：<br>
（1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。<br>
（2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。<br>
一个好的编译器将会根据函数的定义体，自动地取消不值得的内联（这进一步说明了inline 不应该出现在函数的声明中）。</p>
<p>#inline、define、普通函数的区别<br>
内联函数与普通函数的区别：<br>
1.普通函数调用需要开辟栈帧和回收栈帧，内联函数不开辟和回收栈帧，在调用出展开代码<br>
2.普通函数会在编译完生成函数名对应的符号，链接的时候在符号表上可以找到，内联函数不生成符号<br>
3.内联函数可以放在头文件中，方便调用，但是普通函数放在头文件中，多个文件编译用到一个头文件，可能会产生函数的重定义</p>
<p>注意：内联函数在release版本中是这样，在debug版本中除了不生成符号表，和普通的函数无差别，也需要栈帧开辟(方便调试)<br>
缺点：函数展开可能会产生大量的冗余，效率也并不高<br>
宏：字符替换，在预编译阶段进行</p>
<p>内联函数与宏的区别：<br>
1.宏在预编译阶段进行字符替换，没有安全检查，内联函数在编译阶段展开，编译阶段有安全检查，内联函数相对宏更安全<br>
2.宏无法调试，内联函数可以调试<br>
3.内联是一种更安全的宏</p>
<p>static：静态关键字，可以修饰<br>
1)局部静态变量<br>
(2)外部静态变量/函数<br>
(3)静态数据成员/成员函数<br>
static与auto类型(普通)局部变量相比, static局部变量有三点不同</p>
<ol>
<li>存储空间分配不同<br>
auto类型分配在栈上, 属于动态存储类别, 占动态存储区空间, 函数调用结束后自动释放, 而static分配在静态存储区, 在程序整个运行期间都不释放. 两者之间的作用域相同, 但生存期不同.</li>
<li>static局部变量在所处模块在初次运行时进行初始化工作, 且只操作一次</li>
<li>对于局部静态变量, 如果不赋初值, 编译期会自动赋初值0或空字符, 而auto类型的初值是不确定的. (对于C++中的class对象例外, class的对象实例如果不初始化, 则会自动调用默认构造函数, 不管是否是static类型)<br>
特点: static局部变量的”记忆性”与生存期的”全局性”<br>
所谓”记忆性”是指在两次函数调用时, 在第二次调用进入时, 能保持第一次调用退出时的值.</li>
</ol>
<p>static函数与普通函数的区别：<br>
1.普通函数是整个工程可见的，static只是本文件可见<br>
2.static函数形成的符号是局部的，local，链接器不可见，普通函数生成的符号是全局的，global，链接器可见。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vector与list]]></title>
        <id>https://lixin-scut.github.io//post/stl-zhong-ge-chong-rong-qi-de-di-ceng-shi-xian-yuan-li</id>
        <link href="https://lixin-scut.github.io//post/stl-zhong-ge-chong-rong-qi-de-di-ceng-shi-xian-yuan-li">
        </link>
        <updated>2020-02-14T03:04:05.000Z</updated>
        <content type="html"><![CDATA[<p>vector：<br>
vector底层是一个只能从尾部增删的连续线性空间的动态数组，会自行扩充空间以容纳新元素<br>
提供random iterator，最基本的三个迭代器为start、finish和end_of_storage ，然后分为size和capacity<br>
每当size需要等于capacity时需要重新分配当前capacity两倍的空间进行扩增<br>
必须经历 重新分配空间、元素移动、释放原空间，其中元素移动使用的是uninitialized_copy函数<br>
每当重新分配内存都会使迭代器失效（迭代器本质是一个指针）<br>
vector默认使用alloc作为空间配置器，并据此另外定义了一个data_allocator，为的是更方便以元素大小作为配置单位<br>
同时使用全局函数construct来构造新元素</p>
<p>list：<br>
非连续线性空间的双向链表，节点中有一个prev指针一个next指针和一个data值</p>
<pre><code>template &lt;class T&gt;
struct _list_node{
	typedef void* void_pointer;
	void_pointer prev;
	void_pointer next;
	T data;
}
</code></pre>
<p>迭代器是bidirectional iterator 具备前移后移的能力，而无法随机提取<br>
因为不需要考虑分配内存的问题，所以迭代器不会失效，只有指向被删除的元素的迭代器等情况会失效<br>
默认使用alloc作为空间配置器，另外定义一个list_node_allocator<br>
list实际上是一个环形链表，为了能够在尾部插入，尾部有一个end节点，这个节点的next指针指向list的头部，同时头节点的pre也指向尾节点</p>
<p>vector 和 list 中，删除末尾的元素，其指针和迭代器如何变化?若删除的是中间的元素呢?<br>
<img src="https://lixin-scut.github.io//post-images/1581656581131.png" alt=""><br>
注意这里的失效不是指迭代器不能用，而是我们已经无法掌控确定迭代器指向的确定值了，因为本质上都是连续内存和指针，除了尾后位置其他的其实都一样</p>
<pre><code>//Lixin
int main() {
    vector&lt;int&gt; vi{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    vector&lt;int&gt;::iterator beg = vi.begin();
    vector&lt;int&gt;::iterator num8 = beg + 8;
    vector&lt;int&gt;::iterator num2 = beg + 2;
    vector&lt;int&gt;::iterator num5 = beg + 5;
    vector&lt;int&gt;::iterator num9 = beg + 9;

    cout&lt;&lt;*num2&lt;&lt;*num5&lt;&lt;*num8&lt;&lt;endl;
    vi.erase(num5);
    cout&lt;&lt;*num2&lt;&lt;endl;
    cout&lt;&lt;*num5&lt;&lt;endl;
    cout&lt;&lt;*num9&lt;&lt;endl;
}
</code></pre>
<p>vector 和 list 的区别<br>
stl 里 vector 和 list 区别，vector 怎么实现的，什么时候用 vector，什么时候用 list</p>
<blockquote>
<p>#底层结构<br>
  vector的底层结构是动态顺序表，在内存中是一段连续的空间。<br>
  list的底层结构是带头节点的双向循环链表，在内存中不是一段连续的空间。<br>
#随机访问<br>
  vector支持随机访问，可以利用下标精准定位到一个元素上，访问某个元素的时间复杂度是O(1)。<br>
  list不支持随机访问，要想访问list中的某个元素只能是从前向后或从后向前依次遍历，时间复杂度是O(N)。<br>
#插入和删除<br>
 vector任意位置插入和删除的效率低，因为它每插入一个元素（尾插除外），都需要搬移数据，时间复杂度是O(N)，而且插入还有可能要增容，这样一来还要开辟新空间，拷贝元素，是旧空间，效率会更低。<br>
  list任意位置插入和删除的效率高，他不需要搬移元素，只需要改变插入或删除位置的前后两个节点的指向即可，时间复杂度为O(1)。<br>
#空间利用率<br>
  vector由于底层是动态顺序表，在内存中是一段连续的空间，所以不容易造成内存碎片，空间利用率高，缓存利用率高。<br>
  list的底层节点动态开辟空间，小姐点容易造成内存碎片，空间利用率低，缓存利用率低。<br>
#迭代器<br>
  vector的迭代器是原生态指针。<br>
  list对原生态指针（节点的指针）进行了封装。<br>
#迭代器失效<br>
  vector在插入元素时的时候，要重新给所有的迭代器赋值，因为插入元素有可能导致扩容，只是原来的迭代器失效，删除元素时当前迭代器同样需要重新赋值，否则会失效。<br>
  list在插入元素的时候不会导致迭代器失效，删除元素的时候指挥导致当前迭代器失效，其他的迭代器不会受到影响。<br>
#使用场景<br>
  vector适合需要高效率存储，需要随机访问，并且不管行插入和删除效率的场景。<br>
  list适合有大量的插入和删除操作，并且不关心随机访问的场景</p>
</blockquote>
<p>Vector 的内存分配、底层的实现，如果数据量很多扩容会怎么样，怎么设计更好的<br>
#新增元素：Vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素；<br>
#对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了 ；<br>
#初始时刻vector的capacity为0，塞入第一个元素后capacity增加为1；<br>
#不同的编译器实现的扩容方式不一样，VS2015中以1.5倍扩容，GCC以2倍扩容。</p>
<p>stl vector push_back() 的复杂度?扩容机制?为什么要 2 倍扩容?<br>
n 个元素，n 次操作，每一次操作需要花费时间为 m / (m - 1)，这是一个常量.<br>
所以，我们采用均摊分析的方法可知，vector 中 push_back 操作的时间复杂度为常量时间.<br>
在STL中，vector的每次扩容都是2倍，也就是m=2.这样，n次总的时间约为n*2/(2-1) = 2n；那么每一操作要花的时间就是2,因此是常量级。</p>
<p>list 和 vector 实现有什么区别?讲讲 vector 的 resize 操作<br>
1.resize函数首先判断新的size和原size的大小，如果小于的话就直接用erase截断，否则调用insert<br>
2.在insert里面首先判断是否需要扩容<br>
3.无须扩容的话再判断插入点后现有元素和新增元素个数，如果需要插入的个数比现有元素还多的话，就先使用uninitiated_fill_n来插入新元素，然后剩下的就直接uninitialized_copy复制</p>
<p>定义一个类 T，使得 vector<T>和 T a[10]这两个定义，一个成功，一个失败。</p>
<p>现在循环往一个 vector 里面插入 10000 个数据，一次插入一个，怎么高效，用 resize() 还是 reserve()，为什么<br>
resize(n,t) reserve(n)<br>
vector 的reserve增加了vector的capacity，但是它的size没有改变，而resize改变了vector的capacity同时也增加了它的size，resize把重新分配的剩余空间用存储元素的默认构造函数填充新分配的空间。<br>
所以如果是插入相同值，可以直接resize，如果是不同值，reserve 避免多次拷贝</p>
<p>手撕 vector 的 push_back(),不准用 insert 方法;</p>
<pre><code>void push_back(const T&amp; value){
	if(finish! = end_of_storage){
			construct(finish,x);
			++finish;
	}
	else{
	}
	const size_type old_size = size();
	const size_type len = old_size!=0?2*old_size:1;
	
	iterator new_start = data_allocator::allocate(len);
	iterator new_finish = new_start;
	try{
		new_finish = uninitialized_copy(start,finish,new_start);
		construct(new_finish,x);
		++new_finish;
		cath(){
				destroy(new_start,new_finish);
				data_allocator::deallocate(new_start,len);
				throw;
		}
	destroy(start,finish);
	deallocate();
	
	start = new_start;
	finish = new_finish;
	end_of_storage = start + len;
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math 题16:数值的整数次方]]></title>
        <id>https://lixin-scut.github.io//post/math-ti-16shu-zhi-de-zheng-shu-ci-fang</id>
        <link href="https://lixin-scut.github.io//post/math-ti-16shu-zhi-de-zheng-shu-ci-fang">
        </link>
        <updated>2020-02-14T02:31:51.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。<br>
保证base和exponent不同时为0</p>
</blockquote>
<pre><code>class Solution {
public:
    double Power(double base, int exponent) {
        if(exponent==0)
            return 1;
        double res;
        bool flag=false;
        if(exponent&lt;0){
            flag=true;
            exponent=-exponent;
        }
        res=base;
        if(exponent%2)
            res=Power(base*base,exponent/2)*base;
        else
            res=Power(base*base,exponent/2);
        if(flag)
            res=1.0/res;
        return res;
    }
};
</code></pre>
<p>值得改进的点：除以2改为右移，求余运算符改为位与运算符，提高效率</p>
<blockquote>
<p>书本题解：<br>
首先需要考虑输入的指数(exponent)小于1 (零和负数)的情况<br>
当指数为负数的时候，可以先对指数求绝对值，算出次方的结果之后再取倒数。<br>
当底数(base)是零且指数是负数的时候，如果不进行特殊处理，就会出现对0求倒数，从而导致程序运行出错。<br>
最后需要指出的是，由于0的0次方在数学上是没有意义的，因此无论输出是0还是1都是可以接受的，但这都需要和面试官说清楚，表明我 们己经考虑到这个边界值了。<br>
采用全局变量来标识是否出错<br>
同时可以用如下公式求a的n次方<br>
<img src="https://lixin-scut.github.io//post-images/1581648186725.png" alt=""></p>
</blockquote>
<pre><code>double PowerWithUnsignedExponent(double base, unsigned int exponent)
{
    if (exponent == 0)
        return 1;
    if (exponent == 1)
        return base;

    double result = PowerWithUnsignedExponent(base, exponent &gt;&gt; 1);
    result *= result;
    if ((exponent &amp; 0x1) == 1)
        result *= base;

    return result;
}

bool equal(double num1, double num2)
{
    if ((num1 - num2 &gt; -0.0000001) &amp;&amp; (num1 - num2 &lt; 0.0000001))
        return true;
    else
        return false;
}
</code></pre>
<blockquote>
<p>最后一个细节：位运算的效率比乘除法以及求余运算的效率高很多，可以使用右移运算符代替除以2，用位与代替了求余运算符（%）来判断一个数是奇数还是偶数。<br>
M%N:当N是2的次方时，M%N=M&amp;(N-1)<br>
另外需要注意如果是double，无法直接比较是否相等，需要使用它们的差值进行判断</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[位运算 题15:二进制中1的个数[未做出]]]></title>
        <id>https://lixin-scut.github.io//post/wei-yun-suan-ti-15er-jin-zhi-zhong-1-de-ge-shu-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/wei-yun-suan-ti-15er-jin-zhi-zhong-1-de-ge-shu-wei-zuo-chu">
        </link>
        <updated>2020-02-13T03:13:14.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
</blockquote>
<p>重点就在于不要把n直接右移，因为负数的右移会自动补1，同时把1往左移其实也是固定循环次数的，用4字节的int只会循环32次。<br>
然后就是书本题解中的减1相与法很值得学习。</p>
<pre><code>class Solution {
public:
     int  NumberOf1(int n) {
         //【未做出】
         int count=0;
         
         while(n){
             ++count;
             n=(n-1)&amp;n;
         }
         return count;
         /*
         //注意位运算符返回右值，必须再赋值。。。和算术符号一样的
         //然后判断条件比较有趣，如果将数字视为二进制的话那么位数一定是固定的（int的位数）
         //而不是说数字越大位数越大，所以不需要将判断条件改为i和n的大小判断，直接等i左移到变为0即可
         int count=0;
         int i=1;
         while(i){
             if(n&amp;i)
                 ++count;
             i=i&lt;&lt;1;
         }
         return count;
         */
     }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>只要把整数和1做位与运算看结果是不是0就知道了<br>
如果直接将目标数字n进行右移，当输入一个负数，比如0x80000000,则运行的时候当把负数 0x80000000右移一位的时候，并不是简单地把最高位的1移到第二位变成 0x40000000,而是0xC0000000。这是因为移位前是一个负数，仍然要保证 移位后是一个负数，因此移位后的最高位会设为1。如果一直做右移运算， 那么最终这个数字就会变成0xFFFFFFFF而陷入死循环。<br>
为了避免死循环，我们可以不右移输入的数字n。首先把n和1做与运算，判断n的最低位是不是为1。接着把1左移一位得到2,再和n做与运算，就能判断n的次低位是不是1……这样反复左移，每次都能判断n的其中一位是不是1。</p>
</blockquote>
<pre><code>int NumberOf1_Solution1(int n)
{
    int count = 0;
    unsigned int flag = 1;
    while (flag)
    {
        if (n &amp; flag)
            count++;

        flag = flag &lt;&lt; 1;
    }

    return count;
}
</code></pre>
<blockquote>
<p>同时我们发现把一个整数减去1，都是把最右边的1变成0。如果它的右边还有0,则所有的0都变成1，而它左边的所有位都保 持不变。接下来我们把一个整数和它减去1的结果做位与运算，相当于把它最右边的1变成0。<br>
把上面的分析总结起来就是：把一个整数减去1,再和原整数做与运 算，会把该整数最右边的1变成0。那么一个整数的二进制表示中有多少个1， 就可以进行多少次这样的操作。</p>
</blockquote>
<pre><code>int NumberOf1_Solution2(int n)
{
    int count = 0;

    while (n)
    {
        ++count;
        n = (n - 1) &amp; n;
    }

    return count;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[哈希表hash table]]></title>
        <id>https://lixin-scut.github.io//post/ha-xi-biao</id>
        <link href="https://lixin-scut.github.io//post/ha-xi-biao">
        </link>
        <updated>2020-02-12T11:39:23.000Z</updated>
        <content type="html"><![CDATA[<p>《C++ primer》<br>
新标准定义了4个无序关联容器，无序容器不是使用比较运算符来组织元素，而是使用一个哈希函数，和关键字类型的<mark>运算符<br>
如果关键字类型固有就是无序的，或者性能测试发现问题可以用哈希技术解决，就可以使用无序容器<br>
无序容器提供了与有序容器相同的操作（find、insert等），所以unordered_map和unordered_set也可以使用这些操作<br>
无序容器也有允许重复关键字的版本<br>
通常可以用一个无序容器替换对相应的有序容器，反之亦然<br>
无序容器在存储组织上为一组桶，每个桶保存零个或多个元素，无序容器使用一个哈希函数将元素映射到桶，容器首先计算元素的哈希值，并将具有一个特定哈希值的所有元素都保存在相同的桶中，所有具有相同关键字的元素都会在同一个桶中，因此无序容器的性能依赖于哈希函数的质量和桶的数量和大小<br>
对于相同的参数，哈希函数总是产生相同的结果<br>
将不同关键字映射到相同的桶也是允许的，当一个桶保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个<br>
<img src="https://lixin-scut.github.io//post-images/1581507740082.png" alt=""><br>
默认情况下无序容器使用关键字类型的</mark>运算符来比较元素，还是用一个hash&lt;key_type&gt;类型来生成每个元素的哈希值，标准库为内置类型包括指针提供了hash模板</p>
<p>《STL源码剖析》<br>
C++的STL中set和map使用了红黑树作为基层机制<br>
而unordered_set unordered_map使用了hashtable作为底层机制，初始化时可以向hashtable定义equal函数<br>
hashtable可以视为一种键值的字典结构，使用hash function散列函数来进行映射<br>
负载系数（loading factor）：元素的个数除以表格大小<br>
当单个位置空间满载，只能进行循环向下查找和惰性删除<br>
hashtable的buckets聚合体以vector完成，以利动态扩充，同时hashtable使用28个质数来设计表格大小<br>
然后bucket中不是使用STL的list，而是自己维护一个hashtable node，类似于forward_list，有value和next指针<br>
hashtable自定义了迭代器，只有++和==等操作，没有后退的操作，也没有逆向迭代器<br>
在++递增操作中，如果当前节点恰巧是链表最后一个节点，就通过buk_num寻找下一个bucket<br>
hashtable的bkt_num()定义了hash function来计算元素位置<br>
每个bucket的最大容量和buckets_vector的大小相同<br>
新节点在链表的头部插入<br>
注意hashtable并没有自动排序功能，所以hash表内的元素并无特定顺序<br>
有些元素无法直接拿来对hashtable的大小进行模运算，就需要bkt_num函数进行预处理，<br>
hash set 和 hash multiset的区别在于前者使用insert_unique，后者使用insert_equal。</p>
<p>解决哈希冲突<br>
1.线性探测<br>
2.二次探测<br>
3.开链</p>
<p>一致性哈希了解吗<br>
一致性哈希算法将整个哈希值空间映射成一个虚拟的圆环，整个哈希空间的取值范围为0<sub>2^32-1。整个空间按顺时针方向组织。0</sub>2^32-1在零点中方向重合。接下来使用如下算法对服务请求进行映射，将服务请求使用哈希算法算出对应的hash值，然后根据hash值的位置沿圆环顺时针查找，第一台遇到的服务器就是所对应的处理请求服务器。当增加一台新的服务器，受影响的数据仅仅是新添加的服务器到其环空间中前一台的服务器（也就是顺着逆时针方向遇到的第一台服务器）之间的数据，其他都不会受到影响。综上所述，一致性哈希算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性</p>
<p>3.哈希表实现<br>
知道哈希表吗，怎么解决冲突，如果只有 32 个槽，怎么存放几千个数据。<br>
开链</p>
<p>哈希表?怎么进行查找数据?<br>
首先转化键值，然后计算哈希值，再在相应的bucket中顺序查找（哈希冲突 开拉链法 也可以把链表换成红黑树）<br>
注意char* const char* 都是通过h=5 * h+* s转化为size_t 其他数值类型也是转化为size_t</p>
<p>哈希数据结构?如何 rehash?<br>
STL的rehash比较简单，就是判断每个bucket的元素数量和vector的大小对比，如果前者大于后者的话就需要resize（rehash），rehash也比较简单，直接重新计算每个元素的落点然后头部插入<br>
比较有趣的是redis的渐进式hash</p>
<p>hash 冲突，写拉链法代码</p>
<pre><code>pair&lt;hashtable::iterator,bool&gt; insert_unique_noresize(const value_type&amp; obj){
const size_type n=bkt_num(obj)
for(node* cur=first;cur;cur=cur-&gt;next)
	if(equal(get_key(cur-&gt;val),get_key(obj)))
		return pair&lt;iterator,bool&gt;(iterator(cur,this),false);
node* tmp=new_node(obj);
tmp-&gt;next=first;
buckets[n]=tmp;
++num_elements;
return pair&lt;iterator,bool&gt;(iterator(tmp,this),true);
}
</code></pre>
<p>如果是unordered_multiset，则先寻找有没有相同值，有的话立即插入，如果没有的话就回到头部插入</p>
<p>如何解决 Hash 表碰撞问题<br>
Hash碰撞冲突<br>
我们知道，对象Hash的前提是实现equals()和hashCode()两个方法，那么HashCode()的作用就是保证对象返回唯一hash值，但当两个对象计算值一样时，这就发生了碰撞冲突。</p>
<p>1.开放地址法<br>
开放地执法有一个公式:Hi=(H(key)+di) MOD m i=1,2,…,k(k&lt;=m-1)<br>
其中，m为哈希表的表长。di 是产生冲突的时候的增量序列。如果di值可能为1,2,3,…m-1，称线性探测再散列。<br>
如果di取1，则每次冲突之后，向后移动1个位置.如果di取值可能为1,-1,2,-2,4,-4,9,-9,16,-16,…k<em>k,-k</em>k(k&lt;=m/2)，称二次探测再散列。<br>
如果di取值可能为伪随机数列。称伪随机探测再散列。</p>
<p>2.再哈希法<br>
当发生冲突时，使用第二个、第三个、哈希函数计算地址，直到无冲突时。缺点：计算时间增加。<br>
比如上面第一次按照姓首字母进行哈希，如果产生冲突可以按照姓字母首字母第二位进行哈希，再冲突，第三位，直到不冲突为止</p>
<p>3.链地址法（拉链法）<br>
将所有关键字为同义词的记录存储在同一线性链表中。</p>
<p>4.建立一个公共溢出区<br>
假设哈希函数的值域为[0,m-1],则设向量HashTable[0..m-1]为基本表，另外设立存储空间向量OverTable[0..v]用以存储发生冲突的记录。</p>
<p>如何改善 Hash 表性能<br>
哈希表性能优化的方法有很多，比如：<br>
使用双 hash 检索冲突<br>
使用开放+封闭混合寻址法组织哈希表<br>
使用跳表快速定位冲突<br>
使用 LRU 缓存最近访问过的键值，不管表内数据多大，短时内访问的总是那么几个<br>
使用更好的分配器来管理 key_value_pair 这个节点对象<br>
封闭寻址+平衡二叉树</p>
<p>load factor较小时，添加元素时很容易找到空的bucket，hash冲突少（因为可用的空bucket很多），存储性能较高；已装元素的bucket少，很容易从中找到指定的元素，查找性能较高；但遍历集合（hash表）时，要过滤掉大量的空bucket，很花时间，所以遍历时比较慢。<br>
当load factor达到设置的负载极限时，会发生rehashing（重哈希/再散列），hash表会自动成倍地增加容量（capacity），将原有的元素都移到新的hash表中（会重新分配存储位置），而此时原有的元素是极多的，这会增加很大的开销。<br>
负载极限设置较高时，节省内存（空桶较少），但添加、查找元素效率较低，时间开销会增大；负载极限较低时，添加、查找元素效率较高，但会增加内存开销。默认为0.75，是时间、空间的折中，我们可根据需要自行设置。<br>
如果我们一开始就知道要存储的元素个数，可以在创建hash表时就指定容量：元素总数/负载极限。这样避免了rehashing，节省了时间开销。且前中期hash表负载会很低，添加、查询效率极高。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++中的关键字 static ]]></title>
        <id>https://lixin-scut.github.io//post/czhong-de-guan-jian-zi-static</id>
        <link href="https://lixin-scut.github.io//post/czhong-de-guan-jian-zi-static">
        </link>
        <updated>2020-02-12T10:55:19.000Z</updated>
        <content type="html"><![CDATA[<p>《C++ primer》<br>
局部静态对象 static 直到程序终止时才被销毁，在此期间就算函数执行结束也不会对它产生影响（可以用来计算函数调用次数）<br>
值初始化除了在值初始化过程中可能进行之外，也可以单独作用于静态（或者线程局部）变量： static T object;</p>
<p>类的静态成员<br>
static 静态成员 与类关联，而与特定的对象无关（等于每个对象都可以通用的成员）所以静态成员应该在类外定义，否则每创建一个对象就会被定义一次<br>
静态成员可以是private或者public，静态数据成员的类型可以是常量、引用、指针、类类型等等。<br>
类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据，同时静态成员函数也不与任何对象绑定在一起，不包含this 指针，不能被声明为const<br>
使用作用域运算符来直接访问静态成员，也可以使用类的对象、引用或者指针来访问<br>
成员函数不用通过作用域运算符就能直接使用静态成员<br>
静态成员函数也可以在类外部进行定义，但不能重复static关键字，static只出现在类内部的声明语句<br>
静态成员不是由类的构造函数初始化的，不能在类的内部初始化静态成员，必须在类的外部定义和初始化每个静态成员<br>
一个静态数据成员只能定义一次<br>
静态数据成员定义在任何函数之外，因此存在于程序的整个生命周期中<br>
把静态数据成员的定义和其他非内联函数的定义放在同一个文件中，确保对象只定义一次<br>
例外：可以在类内部初始化constexpr的静态成员，但必须提供const整数类型的类内初始值（常量表达式） 例如 static constexpr int i =10;//必须是constexpr，不能是const<br>
如果仅仅用于类内，则在类内已经初始化的const或者constexpr static不需要分别定义，否则必须有一条定义语句<br>
特别地，静态数据成员的类型可以是它所属的类类型（等于不完全类型），而非静态数据成员只能声明成它所属的类的指针或引用<br>
静态成员可以作为默认实参，非静态数据成员则不能。</p>
<p>静态内存用于保存局部static对象、类static数据成员以及定义在任何函数之外的变量</p>
<p>模板所有实例类型都共享相同的static成员（包括数据成员和函数乘以）<br>
类似任何其他成员函数，一个 static 成员函数只有在使用时才会实例化。</p>
<p>static_cast 只要不包含底层const都能用 例如把void*指针的值找回来</p>
<p>博客：<br>
全局静态变量<br>
　　在全局变量前加上关键字static，全局变量就定义成一个全局静态变量.<br>
　　静态存储区，在整个程序运行期间一直存在。<br>
　　初始化：未经初始化的全局静态变量会被自动初始化为0(自动对象的值是任意的，除非他被显式初始化);<br>
　　作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。</p>
<p>局部静态变量<br>
　　在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。<br>
　　内存中的位置：静态存储区<br>
　　初始化：未经初始化的全局静态变量会被自动初始化为0(自动对象的值是任意的，除非他被显式初始化);<br>
　　作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变;</p>
<p>静态函数<br>
　　在函数返回类型前加static，函数就定义为静态函数。普通函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。<br>
　　函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突;<br>
　　warning：不要在头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰;</p>
<p>类的静态成员<br>
　　在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用</p>
<p>类的静态函数<br>
　　静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名，只需要类名。<br>
　　在静态成员函数的实现中不能直接引用类中说明的非静态成员（因为类可能都还没有对象，自然也无法对非静态成员进行构造），可以引用类中说明的静态成员(这点非常重要)。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;);<br>
如果函数调用的结果不会访问或者修改任何对象（非static）数据成员，这样的成员声明为静态成员函数比较好</p>
<p>static 变量初始化<br>
未经初始化的全局静态变量和局部静态变量都会被自动初始化为0</p>
<p>static与const和extern的关系<br>
这两个关键字可以一起使用,当一起使用时,它们的先后顺序是没有限制的,谁在前面都一样,const是指常量,static则表示静态变量,它们一起使用时则表示一个静态常量.<br>
当你声明一个变量并初始化后,你不想在后面的程序中对该变量进行修改的话,你就可以用const修饰符来修饰它,它告诉编译器这是一个常量,如果你对常量作了修改,编译的时候就会通不过,而静态变量则是在你声明之后,这个变量就一直常驻内存,直到程序结束它才会被销毁,例如你在一个自定义函数中定义了一个静态变量,当这个函数被调用结束,它里的静态变量依然存在,当第二次调用该函数时,这个变量并不会重新被分配内存,它的值则是上一次调用后它的值.</p>
<p>在全局范围和局部范围声明时在内存的分布情况<br>
int i=1024<br>
static int i=1024<br>
都是定义在静态存储区</p>
<p>static 和全局变量<br>
全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。</p>
<p>Static 关键字，可以在头文件中声明吗<br>
可以，但是不应该，#include的话，展开之后相当于static在main中仍然是可见的。你把static放在.h文件中是无意义的，且很容易被重复引用而形成重复定义。正确的做法是在.c中定义全局变量，而在.h中用extern引出全局变量，当然static变量是无法extern的。</p>
<p>如何在另一个文件里面使用本文件中的 static 变量或函数?<br>
利用可在本文件调用的属性，另加一个函数fun，fun调用该static函数；其他文件调用fun即可</p>
<p>Static 和 extern 的优先级谁高<br>
static更高，不可以对static的变量或者函数使用extern关键词，先出现 extern 后出现 static 是不行的，先出现 static 后出现 extern 则为 static</p>
<p>2.const static 用法<br>
static<br>
    作用：修饰变量、函数<br>
    变量<br>
     全局变量：修饰的全局变量，指定其内部链接，也就是只能本文件使用。<br>
     局部变量：修饰的局部变量，改变其生命周期，并不会修改其作用域。<br>
     成员变量：只属于类，不属于对象。使用的适合可以通过类名或者对象引用。修饰的成员变量必须在类外单独初始化，如果同时被const 修饰则可以在定义的适合进行初始化。<br>
    函数<br>
      普通函数：修饰的普通函数，指定其内部链接，也就是只能本文可见。<br>
     类成员函数：静态成员函数只属于类，不属于对象。没有this指针，所以它不能访问非静态成员函数 ，和非静态成员变量。 它是用来处理静态成员数据，如果我们非要使用静态成员函数访问非静态成员函数或者非静态成员变量，我们可以间接使用类进行引用。</p>
<p>const<br>
     用法：修饰变量，参数，返回值。 C++中的const关键字的用法非常灵活，而使用const将大大改善程序的健壮性。const 允许指定语义约束，告诉编译器哪些变量是不可以改变的。<br>
     修饰变量：C语言中const将一个变量转化为常变量，存储在静态文本段，只有读取权限，C++中同样会将一个变量转化成常量，C++会对其进行优化，将其放入寄存器中，如果想去内存中读取该数据时，我们可以使用volatile关键字进行修饰，保证其可见性。<br>
     修饰指针变量： 如果const位于* 左侧时，不能修改指针所指的对象<br>
                               如果const位于* 右侧时，不能修改指针的指向，所以必须初始化。<br>
     修饰参数：作用是原参数在该函数中不可被改变。<br>
     修饰的返回值：也是用const来修饰返回的指针或引用，保护指针指向的内容或引用的内容不被修改，也常用于运算符重载。归根究底就是使得函数调用表达式不能作为左值。<br>
     修饰成员变量：该变量只能在初始化列表里初始化。<br>
     修饰成员函数：在成员函数后面加上const,const修饰this指针所指的的对象，也就是保证调用该成员函数的对象，在成员函数内部不会改变。（改变权限，权限可缩小，但是不可扩大）</p>
<p>3.在头文件里面声明一个 static 变量，在两个不同的 cpp 里面#include 这个变量有没有问题<br>
在一个头文件中声明static 类对象， 会为所有include该头文件的cpp都创建一个同名的全局对象，只不过它们是相互独立的。<br>
但是普通全局变量的话就只能有一个定义，否则会引发重复定义</p>
<p>自己做的小实验：</p>
<pre><code>//static_data.h
static int si;
extern int i;


//func.cpp
#include &quot;static_data.h&quot;
void func(){

    ++si;
    cout&lt;&lt;si&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;endl;
}

//main.cpp
#include &quot;static_data.h&quot;

void func();

int i=0;// i must be modified here and modified once;
int main() {
    //int i=10;//this will cover i 
    //++si;
    ++i;
    cout&lt;&lt;si&lt;&lt;&quot; &quot;&lt;&lt;i++&lt;&lt;endl;
    func();
}
</code></pre>
<p>输出结果：</p>
<pre><code>0 1
1 2
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[排序算法]]></title>
        <id>https://lixin-scut.github.io//post/pai-xu-suan-fa</id>
        <link href="https://lixin-scut.github.io//post/pai-xu-suan-fa">
        </link>
        <updated>2020-02-12T05:13:04.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://lixin-scut.github.io//post-images/1581492677786.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 题14:剪绳子[未做出][贪心]]]></title>
        <id>https://lixin-scut.github.io//post/dong-tai-gui-hua-ti-14jian-sheng-zi-wei-zuo-chu-tan-xin</id>
        <link href="https://lixin-scut.github.io//post/dong-tai-gui-hua-ti-14jian-sheng-zi-wei-zuo-chu-tan-xin">
        </link>
        <updated>2020-02-12T04:05:22.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],...,k[m]。请问k[0]xk[1]x...xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
</blockquote>
<p>我一开始用的是贪心法，就是单纯地不断取3<br>
但是这是有问题的，因为如果最后剩余的是4的话，应该取2x2而不是3x1<br>
然后动态规划就是要注意特殊例子，因为动态规划把两边都是为一个整体，但是题目要求必须剪一刀，比如3取1和2的时候，2在动态规划数组中是1，就会导致结果等于1</p>
<pre><code>class Solution {
public:
    int cutRope(int number) {
        //动态规划；
        if(number&lt;2)
            return 0;
        //注意着两个特殊例子无法去除，因为动态规划中这两个特殊例子应视为一个整体
        if(number==2)
            return 1;
        if(number==3)
            return 2;
        vector&lt;int&gt; count(number+1,0);
        count[1]=1;
        count[2]=2;
        count[3]=3;
        for(int i=4;i&lt;number+1;++i)
            for(int j=1;j&lt;=i/2;++j)
                count[i]=max(count[i],count[j]*count[i-j]);
        return count.back();
        /*
        //贪心算法
        if(number&lt;1)
            return 0;
        if(number==2)
            return 1;
        if(number==3)
            return 2;
        
        //注意可以直接*4，但是可读性有点差
        if(number%3==1)
            return pow(3,(number/3)-1)*2*2;
        else 
            return pow(3,(number/3))*(number%3);
            
        //这里其实是错误的，如果剪完3之后剩下的是4，不应该再剪3了，应该剪2+2，不知道为何通过了
        //return pow(3,(number/3))*(number%3);
        */
    }
};
</code></pre>
<p>书本题解:</p>
<blockquote>
<p>动态规划<br>
首先定义函数f(n)为把长度为n的绳子剪成若干段后各段长度乘积的最 大值。在剪第一刀的时候，我们有n-1种可能的选择，也就是剪出来的第 一段绳子的可能长度分别为1,2,...,n-1因此f(n)=max(f(i)xf(n-i)),其中 0&lt;i&lt;n。<br>
这是一个从上至下的递归公式。由于递归会有很多重复的子问题，从 而有大量不必要的重复计算。一个更好的办法是按照从卜而上的顺序计算, 也就是说我们先得到f(2)、f(3),再得到f(4)、f(5),直到得到f(n)。<br>
当绳子的长度为2时，只可能剪成长度都为1的两段，因此f(2)等于1 当绳子的长度为3时，可能把绳子剪成长度分别为1和2的两段或者长度都为1的三段，由于1x2&gt;1x1x1,因此f(3)=2<br>
在上述代码中，产问题的最优解存储在数组products里。<br>
为了求解f(i)，我们需要求 出所有可能的并比较得出它们的最大值。这就是代码中第二个for循环的功能。</p>
</blockquote>
<pre><code>int maxProductAfterCutting_solution1(int length)
{
    if(length &lt; 2)
        return 0;
    if(length == 2)
        return 1;
    if(length == 3)
        return 2;

    int* products = new int[length + 1];
    products[0] = 0;
    products[1] = 1;
    products[2] = 2;
    products[3] = 3;

    int max = 0;
    for(int i = 4; i &lt;= length; ++i)
    {
        max = 0;
        for(int j = 1; j &lt;= i / 2; ++j)
        {
            int product = products[j] * products[i - j];
            if(max &lt; product)
                max = product;

            products[i] = max;
        }
    }

    max = products[length];
    delete[] products;

    return max;
}
</code></pre>
<blockquote>
<p>贪婪算法<br>
如果我们按照如下的策略来剪绳子，则得到的各段绳子的长度的乘积将最大：当n&gt;=5时，我们尽可能多地剪长度为3的绳子；当剩下的绳子长度为4时，把绳子剪成两段长度为2的绳子。<br>
这种思路的正确性证明：首先，当n&gt;=5的时候，我们可以 证明2(n-2)&gt;n并且3(n-3)&gt;n。也就是说，当绳子剩下的长度大于或者等于 5的时候，我们就把它剪成长度为3或者2的绳子段。另外，当n&gt;=5时， 3(n-3)&gt;=2(n-2),因此我们应该尽可能地多剪长度为3的绳子段。<br>
前面证明的前提是n&gt;=5。那么当绳子的长度为4呢？在长度为4的绳子上剪一刀，有两种可能的结果：剪成长度分别为1和3的两根绳子，或 者两根长度都为2的绳子。注意到2X2&gt;1X3,同时2X2=4,也就是说，当绳子长度为4时其实没有必要剪，只是题目的要求是至少要剪一刀。</p>
</blockquote>
<pre><code>int maxProductAfterCutting_solution2(int length)
{
    if(length &lt; 2)
        return 0;
    if(length == 2)
        return 1;
    if(length == 3)
        return 2;

    // 尽可能多地减去长度为3的绳子段
    int timesOf3 = length / 3;

    // 当绳子最后剩下的长度为4的时候，不能再剪去长度为3的绳子段。
    // 此时更好的方法是把绳子剪成长度为2的两段，因为2*2 &gt; 3*1。
    if(length - timesOf3 * 3 == 1)
        timesOf3 -= 1;

    int timesOf2 = (length - timesOf3 * 3) / 2;

    return (int) (pow(3, timesOf3)) * (int) (pow(2, timesOf2));
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[网络库：事件EventLoop]]></title>
        <id>https://lixin-scut.github.io//post/wang-luo-ku-eventloop</id>
        <link href="https://lixin-scut.github.io//post/wang-luo-ku-eventloop">
        </link>
        <updated>2020-02-11T13:39:35.000Z</updated>
        <content type="html"><![CDATA[<p>网络库，其核心是事件循环和事件分发器Eventloop<br>
每个线程只能有一个EventLoop实体，负责IO和定时器事件的分派，用eventfd来异步唤醒。用TimerQueue来作为计时器管理，用Poller作为IO multiplexing</p>
<p>与EventLoop相关的类<br>
1.EventLoopThread：新建一个专门用于EventLoop的线程，在其中运行EventLoop::loop()<br>
2.EventLoopThreadPool：muduo默认多线程IO模型，新到的连接会按round-robin方式分配到线程池</p>
<p>EventLoop包含的成员：Channel、Poller、TimerQueue</p>
<p>同时用户是可以看到EventLoop的</p>
<p>实现过程中需要注意的点<br>
1.EventLoop是不可拷贝的，继承了boost::noncopyable<br>
2.构造函数会记住本对象所属的线程<br>
3.创建了EventLoop对象的线程是IO线程，主要功能是运行事件循环EventLoop::loop()。<br>
4.EventLoop对象的生命期和其所属线程一样长，所以不必是动态创建的heap对象<br>
5.EventLoop的static成员函数getEventLoopOfCurrentThread()返回EventLoop对象<br>
6.EventLoop提供了isInLoopThread()和assertInLoopThread()等函数，用于运行时检查成员函数是否是线程安全的（可以跨线程调用），哪些成员函数只能在某个特定线程调用（主要是IO线程），而事件循环必须在IO线程执行</p>
<p>我的代码和muduo的代码差异：<br>
1.isInLoopThread()和assertInLoopThread()是public的，同时额外需要privare的abortNotInLoopThread进行线程终止<br>
2.然后额外需要bool looping_和threadId_两个数据成员<br>
3.ifndef 预编译<br>
4.头文件缺失，同时头文件中需要包含路径 例如#include &quot;main/base/Mutex.h&quot;<br>
5.命名空间<br>
6.前向声明 Channel Poller Timerqueue等</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 题13:机器人的运动范围]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-ti-13ji-qi-ren-de-yun-dong-fan-wei</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-ti-13ji-qi-ren-de-yun-dong-fan-wei">
        </link>
        <updated>2020-02-10T15:41:35.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目描述<br>
地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
</blockquote>
<p>第一想法还是用bool二位矩阵记录是否计算了某个点<br>
然后突然想着说不能直接循环行和列吗？<br>
然后突然发现一个问题，就是不是所有符合条件的格子都能到达的，<br>
比如（100，100）看起来只有1+1=2，但是不可能从（99，99）到达这个点</p>
<p>其实我这个方法只能算递归，而且使用引用的递归，可以看看书中返回非引用的方法<br>
其中对于范围的判断可以交给不同的地方，我这里是借用了visited的size来进行判断，所以无法像书中在check中进行判断<br>
然后利用关系运算符的判断顺序很重要，一定要先判断范围是否越界了，否则下标运算符会报错</p>
<pre><code>class Solution {
public:
    int movingCount(int threshold, int rows, int cols)
    {
        int count=0;
        vector&lt;vector&lt;bool&gt;&gt; visited(rows,vector&lt;bool&gt;(cols,false));
        visitCount(threshold,0,0,count,visited);
        return count;
    }
    
    void visitCount(int threshold,int rows,int cols,int &amp;count,vector&lt;vector&lt;bool&gt;&gt; &amp;visited){
        if(rows&gt;=visited.size()
           ||cols&gt;=visited[0].size()
           ||visited[rows][cols]
           ||!CheckThre(threshold,rows,cols))
            return;
        ++count;
        visited[rows][cols]=true;
        visitCount(threshold,rows-1,cols,count,visited);
        visitCount(threshold,rows,cols-1,count,visited);
        visitCount(threshold,rows+1,cols,count,visited);
        visitCount(threshold,rows,cols+1,count,visited);
        return;
    }
    
    bool CheckThre(int threshold,int rows,int cols){
        int res=0;
        while(rows)
            res+=rows%10,rows/=10;
        while(cols)
            res+=cols%10,cols/=10;
        return res&lt;=threshold;
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>机器人从坐标(0.0)开始移动。当它准备进入坐标为(i,j)的格子时，通过 检查坐标的数位和来判断机器人是否能够进入。如果机器人能够进入坐标 为(i,j)的格子,则再判断它能否进入4个相邻的格子(i-1,j)、(i,j-1)、(i,j+1) 和(i+1,j),因此，我们可以用如下的代码来实现回溯算法：</p>
</blockquote>
<pre><code>int movingCount(int threshold, int rows, int cols)
{
    if(threshold &lt; 0 || rows &lt;= 0 || cols &lt;= 0)
        return 0;

    bool *visited = new bool[rows * cols];
    for(int i = 0; i &lt; rows * cols; ++i)
        visited[i] = false;

    int count = movingCountCore(threshold, rows, cols,
        0, 0, visited);

    delete[] visited;

    return count;
}

int movingCountCore(int threshold, int rows, int cols, int row,
    int col, bool* visited)
{
    int count = 0;
    if(check(threshold, rows, cols, row, col, visited))
    {
        visited[row * cols + col] = true;

        count = 1 + movingCountCore(threshold, rows, cols,
            row - 1, col, visited)
            + movingCountCore(threshold, rows, cols,
                row, col - 1, visited)
            + movingCountCore(threshold, rows, cols,
                row + 1, col, visited)
            + movingCountCore(threshold, rows, cols,
                row, col + 1, visited);
    }

    return count;
}

bool check(int threshold, int rows, int cols, int row, int col,
    bool* visited)
{
    if(row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; cols
        &amp;&amp; getDigitSum(row) + getDigitSum(col) &lt;= threshold
        &amp;&amp; !visited[row* cols + col])
        return true;

    return false;
}

int getDigitSum(int number)
{
    int sum = 0;
    while(number &gt; 0)
    {
        sum += number % 10;
        number /= 10;
    }

    return sum;
}
</code></pre>
]]></content>
    </entry>
</feed>