<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-03-05T12:47:17.738Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>In the darkest night,Rising like a spire.</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[服务端异常情况]]></title>
        <id>https://lixin-scut.github.io//post/fu-wu-duan-yi-chang-qing-kuang</id>
        <link href="https://lixin-scut.github.io//post/fu-wu-duan-yi-chang-qing-kuang">
        </link>
        <updated>2020-03-05T12:39:28.000Z</updated>
        <content type="html"><![CDATA[<p>正常终止<br>
&lt;Ctrl+D&gt;是我们的终端EOF字符，键入终端EOF字符（Control-D）以终止客户<br>
当前连接的客户端发送fin和ack后会进入了TIME_WAIT状态</p>
<p>我们可以总结出正常终止客户和服务器的步骤。<br>
⑴当我们键入EOF字符时，fgets返回一个空指针，于是str_cli函数返回。<br>
(2)	当str_cli返回到客户的main函数时，main通过调用exit终止。<br>
(3)	进程终止处理的部分工作是<strong>关闭所有打开的描述符</strong>，因此客户打开的套接字由内核关闭。这导致客户TCP发送一个FIN给服务器，服务器TCP则以ACK响应，这就是TCP连接终止序 列的前半部分。至此，<strong>限务器套接字处于CLOSE_WAIT状态，客户套接字则处于FIN_WAIT_2 状态</strong><br>
(4)	当服务器TCP接收FIN时，服务器子进程阻塞于readline调用，于是readline 返回0。这导致str_echo函数返回服务器子进程的main函数。<br>
(5)	服务器子进程通过调用exit来终止。<br>
(6)	服务器子进程中打开的所有描述符随之关闭。由<strong>子进程</strong>来关闭已连接套接字会引发TCP 连接终止序列的最后两个分节：一个从服务器到客户的FIN和一个从客户到服务器的ACK 。至此，连接完全终止，客户套接字进入TIME_WAIT状态。<br>
(7)	进程终止处理的另一部分内容是：在服务器子进程终止时，给<strong>父进程</strong>发送一个SIGCHLD 信号。，但是我们没有在代码中捕获该信号，而该信号的默认行为是被回 忽略。既然父进程未加处理，子进程于是<strong>进入僵死状态</strong>。可以使用ps命令验证这--点。如果stat列为Z，且command列后面带有＜defunct＞字样，就属于僵死进程<br>
进程的状态是Z (表示僵死)。我们必须清理僵死进程，这就涉及Unix信号的处理。</p>
<h1 id="处理sigchld信号">处理SIGCHLD信号</h1>
<p>设置僵死（zombie）状态的目的是维护子进程的信息，以便父进程在以后某个时候获取。 这些信息包括子进程的进程ID、终止状态以及资源利用信息（CPU时间、内存使用量等等）。<br>
如果一个进程终止，而该进程有子进程处于僵死状态，那么它的所有僵死子进程的父进程ID将被重置为1（init进程）。继承这些子进程的init让进程将清理它们（也就是说init进程将wait它们，从而去除它们的僵死状态）。<br>
僵死占用内核中的空间，最终可能导致我们耗尽进程资源<br>
无论何时我们fork子进程都得wait它们，以防它们变成偶死进程。为此我们建立一个俘获 SIGCHLD信号的信号处理函数，在函数体中我们调用wait.</p>
<pre><code>Signal（SIGCHLD, sig_chld）;

1	#include	&quot;unp.h&quot;	.
2	void
3	sig_chld（int signo）
4	{
5	pid_t	pid;
6	int	stat;
7	pid = wait（&amp;stat）;
8	printf（&quot;child %d terminated\n&quot;, pid）；
9	return；
10	}
</code></pre>
<p>具体的各个步骤如下：<br>
（1）	我们键入EOF字符来终止客户。客户TCP发送一个FIN给服务器，服务器响应以一个 ACK。<br>
（2）	收到客户的FIN导致服务器TCP递送一个EOF给<strong>子进程阻塞中的readline</strong>,从而<strong>子进程终止</strong>。<br>
（3）	当SIGCHLD信号递交时，<strong>父进程阻塞于accept调用</strong>。sig_chld函数（信号处理函数） 执行，其wait调用取到子进程的PID和终止状态，随后是printf调用，最后返回。<br>
（4）	既然该信号是在父进程阻塞于慢系统调用（accept）时由父进程捕获的，内核就会使<strong>accept返回一个EINTR错误（被中断的系统调用）。而父进程不处理该错误,于是中止。</strong></p>
<p>本书使用的编程约定之一，我们总是在信号处理函数中显式给出return语句，这么一来，当某个系统调用被我们编写的某个信号处理函数中断时，我们就可以得知该系统调用具体是被哪个信号处理函数的哪个return语句中断的。</p>
<ul>
<li>处理被中断的系统调用<br>
慢系统调用（slow system call）：适用于那些可能 永远阻塞的系统调用。永远阻塞的系统调用是指调用有可能永远无法返回，多数网络支持函数都属于这一类，例如accept。<br>
一个值得注意的例外是磁盘I/O,它们一般都会返回到调用者（假设没有灾难性的硬件故障）。<br>
适用于慢系统调用的基本规则是：当阻塞于某个慢系统调用的一个进程捕获某个信号且相应信号处理函数返回时，该系统调用可能返回一个<strong>EINTR错误</strong>。<br>
设置SA_RESTART标志可以使得内核自动重启调用<br>
了处理被中断的accept,我们把对accept的调用从for循环开始改起</li>
</ul>
<pre><code>for ( ; ; ) (
	clilen = sizeof(cliaddr);
	if ( (connfd =accept(listenfd, (SA *) &amp;cliaddr, &amp;clilen)) &lt; 0) { 
		if (errno == EINTR) 
				continue;	/* back to for() */
		else
				err_sys(&quot;accept error&quot;);
}
</code></pre>
<p>注意！<strong>有一个函数我们不能重启：connect</strong>。如果该函数返回EINTR,我们就不能再次调用它，否则将立即返回一个错误。当connect被一个捕获的 信号中断而且不自动重启时，我们必须调用select来等待连接完成</p>
<h1 id="wait-和-waitpid-函数">wait 和 waitpid 函数</h1>
<p>调用了函数wait:来处理己终止的子进程。</p>
<pre><code>#include &lt;sys/wait.h&gt;
		pid_t wait (int *statloc)；
		pid_t waitpid(pid_t pid, int *statloc, int options);
均返回：若成功则为进程ID,若出错则为。或-1
</code></pre>
<p>函数wait和waitpid均返回两个值：已终止子进程的进程ID号，以及通过指针返回 的子进程终止状态(一个整数)。<br>
我们可以调用三个宏来检查终止状态，并辨别子进程是正常终止、由某个信号杀死还是仅仅由作业控制停止而已。<br>
如果调用wait的进程没有已终止的子进程，不过有一个或多个子进程仍在执行，那么wait 将阻塞到现有子进程第一个终止为止。<br>
waitpid函数就等待哪个进程以及是否阻塞给了我们更多的控制。首先，pid参数允许我们<strong>指定想等待的进程ID</strong>,值-1表示等待第一个终止的子进程。<br>
options参数允许我们指定附加选项。最常用的选项是WNOHANG,它告知内核在<strong>没有已终止子进程时不要阻塞</strong></p>
<ul>
<li>函数wait和waitpid的区别<br>
使用wait的情况下：<br>
假设有5个客户连接到服务器，当客户终止时，所有打开的描述符由内核自动关闭(我们不调用close,仅调用exit),且所有5个<strong>连接基本在同一时刻终止</strong>。这就引发了5个FIN,每个连接一个，它们反过来使服务器 的5个子进程基本在同一时刻终止。这导致差不多在同一时刻有<strong>5个SIGCHLD信号递交给父进程</strong><br>
这是按照预期所有5个子进程都终止了， 如果运行ps,我们将发现其他4个子进程仍然作为<strong>僵死进程</strong>存在着。<br>
原因：同一Unix信号一般是不重复排队的，建立一个信号处理函数并在其中调用wait并不足以防止出现僵死进程。本问题在于：所有5个信号都在信号处理函数执行之前产生，而<strong>信号处理函数只执行一次</strong>。<br>
更严重的是，本问题是不确定的，信号处理函数的执行次数依赖于FIN到达服务器主机的时机，</li>
</ul>
<p>正确的解决办法是调用waitpid而不是wait：<br>
这个版本管用的原因在于：我们在一个循环内调用waitpid,以获取所有已终止于进程的状态。<br>
我们必须指定WNOHANG选项，它告知waitpid在有尚未终止的子进程在运行时<strong>不要阻塞</strong>。<strong>不能在循环内调用wait</strong>,因为没有办法防止wait在正运行的子进程尚有未终止时阻塞。</p>
<p>关于<strong>wait和SIGCHLD信号</strong>注意事项：<br>
其实不一定要在SIGCHLD里调用wait，也可以直接wait<br>
注意！！！wait和信号之间没有关联，我们是捕获到sigchild信号就进行wait处理，而不是说wait本身等待信号进行调用，所以就算不排队，接收到一个信号后就能进行waitpid处理当前所有的僵死进程，而wait只能处理已个，并且不能通过循环wait解决因为会阻塞。<br>
<strong>所以！！！wait和信号无关！哪怕没有信号我也能调用wait和waitpid循环来<br>
清除僵死进程</strong></p>
<pre><code>//tcpserv04.c
//Code by Lixin on 2020/01/14

#include &quot;unp.h&quot;

int 
main(int argc,char **argv){
	int listenfd,connfd;
	pid_t childpid;
	socklen_t clilen;
	struct sockaddr_in cliaddr,servaddr;
	void sig_chld(int);
	listenfd=socket(AF_INET,SOCK_STREAM,0);
	bzero(&amp;servaddr,sizeof(servaddr));
	servaddr.sin_family=AF_INET;
	servaddr.sin_port=htons(SERV_PORT);
	servaddr.sin_addr.s_addr=htonl(INADDR_ANY);

	bind(listenfd,(SA *)&amp;servaddr,sizeof(servaddr));
	listen(listenfd,LISTENQ);
	signal(SIGCHLD,sig_chld);
	for(;;){
		clilen=sizeof(cliaddr);
		if((connfd=accept(listenfd,(SA *)&amp;cliaddr,&amp;clilen))&lt;0){
			if(errno==EINTR)
				continue;
			else
				err_sys(&quot;accept error&quot;);
		}
		if((childpid=fork())==0){
			close(listenfd);
			str_echo(connfd);
			exit(0);
		}
		close(connfd);
	}
}
</code></pre>
<p>我们的服务器程序的最终版本。它正确处理accept返回的EINTR,并建立一个给所有己终止子进程调用waitpid的信号处理函数<br>
本节的目的是示范我们在网络编程时可能会遇到的三种情况：<br>
(1)	当fork子进程时，必须捕获SIGCHLD信号；<br>
(2)	当捕获信号时，必须处理被中断的系统调用；<br>
(3)	S1GCHLD的信号处理函数必须正确编写，应使用waitpid函数以免留下僵死进程。</p>
<h1 id="accept返回前连接中止">accept返回前连接中止</h1>
<p>accept返回一个非致命的错误，在这种情况下，只需要再次调用accept，典型的是较忙的Web服务器。<br>
三路握手完成从而连接建立之后，客户TCP却发送了一个RST （复位）。在服务器端看来，就在该连接已由TCP排队，等着服务器进程调用accept的时候RST到达。<br>
如何处理这种中止的连接依赖于不同的实现，POSIX 指出返回的 errno 值必须是ECONNABORTED<br>
POSIX作出修改的理由在于：流子系统(streams subsystem)中发生某些致命的协议相关事件时，也会返回EPROTO。要是对于由客户引起的一个 已建立连接的非致命中止也返回同样的错误，那么服务器就不知道该再次调用accept还是不该 了。换成ECONNABORTED错误，服务器就可以忽略它，再次调用accept就行。</p>
<h1 id="服务器进程终止">服务器进程终止</h1>
<p>模拟服务器已连接的子进程终止：<br>
1.找到服务器子进程的进程ID,并执行kill命令杀死它。作为进程终止处理的部分工作， 子进程中所有打开着的描述符都被关闭。这就导致<strong>向客户发送一个FIN</strong>,<br>
2.客户段传输层TCP接收FIN此时响应以一个ACK，同时按照预设客户端应用层应当读入套接字的FIN准备关闭程序并发送客户端的FIN给服务端，但是！！此时进程<strong>拥塞在fgets</strong>上，等待从<strong>终端（也就是键盘！）</strong> 接收一行文本，导致<strong>没法去读取套接字的FIN！</strong><br>
<strong>（这里注意区分有两个流，一个是键盘，一个是网络套接字）</strong><br>
<strong>（但是此时客户端传输层TCP已经收到FIN了并向服务端发送ACK了，同时把状态转化为CLOSE_WAIT，可以用netstat查询，这一切都不需要应用层插手）</strong><br>
3.假设此时客户端接收到键盘的输入文本并发送给服务端，当服务器TCP接收到来自客户的数据时，既然先前打开那个套接字的进程已经终止，于是 响应以一个RST。<br>
4.然而客户进程看不到这个RST,因为它在调用writen后立即调用readline,并且由于接收的FIN,所调用的readline立即返回0 （表示EOF）。我们的客户此时<strong>并未预期收到 EOF</strong>，于是以出错信息&quot;server terminated prematurely”（服务器过早终止）退出。当客户终止时（通过调用err_quit）,它所有打开着的描述符都被关闭。<br>
<strong>（注意这里为什么说未预期收到EOF呢？因为ECHO服务器是假设只能由客户端关闭的，所以客户端一开始没加上接收FIN的处理，比如微信，总不能让腾讯来先发送FIN关闭我手机上的微信吧？）</strong></p>
<p>根本原因：当FIN到达套接字时，客户正阻塞在fgets调用上。客户实际上<strong>在应对两个描述符</strong>--套接字（网络）和用户输入（键盘），它不能单纯阻塞在这两个源中某个特定源的输入上（正如 目前编写的str.cli函数所为），而是应<strong>该阻塞在其中任何一个源的输入上</strong>。事实上这正是 <strong>select和poll这两个函数的目的之一</strong></p>
<p>关于RST：<br>
上述讨论还取决于本例子的时序，客户调用readline既可能发生在服务器的RST 被客户收到之前，也可能发生在收到之后，如果readline发生在<strong>收到RST之前</strong>（如本例子所 示），那么结果是客户得到一个未预期的EOF；如果readline发生在<strong>收到RST之后</strong>，否则结果是由readline返回一个ECONNRESET （connection reset by peer，对方复位连接错误）.<br>
猜测原因：服务端发送RST会导致任何排队的数据都被抛弃，RST优先级最高，会被立即发出去，所以可能导致FIN还在排队的时候就已经被抛弃了<br>
疑惑：那如果FIN比RST先到达接收方会怎么样？</p>
<h1 id="sigpipe-信号">SIGPIPE 信号</h1>
<p>要是客户不理会readline函数返回的错误，反而写入更多的数据到服务器上，那又会发生什么呢？<br>
当一个进程向某个己收到RST的套接字执行写操作时，<strong>（客户端的）内核</strong>向该进程发送一个SIGPIPE信号.该信号的默认行为是终止进程，因此进程必须捕获它以免不情愿地被终止，同时写操作都将返回EPTPE错误。<br>
第一次写操作引发RST,第二次写引发SIGPIPE信号.写一个已接收了FIN的套接字不成问题，但是写一个已接收了 RST的套接字则是一个<strong>错误</strong>.<br>
处理SIGPIPE的建议方法取决于它发生时应用进程想做什么（比如写入log日志）<br>
但是必须意识到，如果使用 了多个套接字，该信号的递交无法告诉我们是哪个套接字出的错。如果我们确实需要知 道是哪个write出了错，那么必须要么不理会该信号，要么从信号处理函数返回后再处 理来自write的EPIPE。</p>
<h1 id="服务器主机崩溃">服务器主机崩溃</h1>
<p>注意区分进程终止和崩溃，模拟前者一般是使用kill信号，模拟后者则需要从网络上断开服务器主机，这样同时也模拟了当客户发送数据时服务器主机不可达的情形(即建立连接后某些中间路由器不工作)。</p>
<p>客户端发送数据后，等待服务器的ACK，因而阻塞在readline调用上，假设服务器主机己崩溃，从而对客户的数据分节根本没有响应，那么所返回的错误是 ETIMEDOUT（从readline调用返回的）<br>
然而如果某个中间路由器判定服务器主机已不可达，从而响应以一个“destination unreachable&quot;(目的地不可达)ICMP消息，那么所返回的错误是EHOSTUNREACH或ENETUNREACH。</p>
<p>如果希望更快地检测出这种情况，可以对readline调用设置一个超时</p>
<p>上述情形只有在我们向服务器主机发送数据时才能检测出它已经崩溃。如果希望不主动向它发送数据也能检测出服务器主机的崩溃，那么需要采用另外一个技术--SO_KEEPALIVE套接字选项。</p>
<h1 id="服务器主机崩溃后重启">服务器主机崩溃后重启</h1>
<p>模拟这种情形的最简单方法就是：先建立连接，再从网络上 函 断开服务器主机，将它关机后再重新启动，最后把它重新连接到网络中。<br>
处理方法重点在于：我们<strong>不想客户知道服务器主机的关机</strong></p>
<p>普通情况下：<br>
(1)	当服务器主机崩溃后重启时，它的TCP丢失了崩溃前的所有连接倍息，因此服务器TCP 对于所收到的来自客户的数据分节响应以一个RST。<br>
(2)	当客户TCP收到该RST时，客户正阻塞于readline调用，导致该调用返回ECONNRESET 错误。</p>
<h1 id="服务器主机关机">服务器主机关机</h1>
<p>当服务器子进程终止时，它的所 有打开着的描述符都被关闭，随后发生的步骤与服务器进程终止那一节一样，我们必须在客户中使用select或poll函数，使得服务器进程的终止一经发生，客户就能检测到。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[优雅地关闭连接-shutdown() 和 close() 的区别]]></title>
        <id>https://lixin-scut.github.io//post/you-ya-di-guan-bi-lian-jie-shutdown-he-close-de-qu-bie</id>
        <link href="https://lixin-scut.github.io//post/you-ya-di-guan-bi-lian-jie-shutdown-he-close-de-qu-bie">
        </link>
        <updated>2020-03-05T12:03:13.000Z</updated>
        <content type="html"><![CDATA[<h3 id="close-函数">close 函数</h3>
<pre><code>#include &lt;unistd.h&gt;
int close(int sockfd)；	
返回：若成功则为0,若出错则为-1
</code></pre>
<p>close一个TCP套接字的默认行为是把该套接字标记成己关闭，然后立即返回到调用进程。 该套接字描述符不能再由调用进程使用，也就是说它不能再作为read或write的第一个参数。<br>
注意close只是应用层的，TCP将继续尝试发送已排队等待发送到对端的任何数据，发送完毕后发生的是正常的TCP连接终止序列。</p>
<p>描述符引用计数<br>
<strong>close调用并不引发TCP的四分组连接终止序列，如果我们确实想在某个TCP连接上发送一个FIN,那么可以改用shutdown函数以代替close！！！</strong><br>
父进程必须调用close，如果父进程对每个由accept返回的已连接套接字都不调用close，父进程最终将耗尽可用描述符，因为没有一个客户连接会被终止。当子进程关闭已连接套接字时，它的引用计数值将由2递减为1且保持为1,因为父进程永不关闭任何己连接套接字。这将妨碍TCP连接终止序列的发生，导致连接一直打开看。</p>
<h3 id="shutdown函数">shutdown函数</h3>
<p><img src="https://lixin-scut.github.io//post-images/1579097744777.png" alt=""><br>
终止网络连接的通常方法是调用close函数。不过close有两个限制，却可以使用shutdown 来避免。<br>
（1）	close把描述符的引用计数减1,仅在该计数变为0时才关闭套接字。使用shutdown可以不管引用计数就激发TCP的正常连接终止序列（图2-5中由FIN开始的4个分节）。<br>
（2）	close终止读和写两个方向的数据传送。<br>
shutdown可以指定关闭读端、写端还是读写端</p>
<pre><code>#include &lt;sys/socket.h&gt;
		int shutdown (int sockfd, int howto)；
				返回：若成功则为0,若出错则为-1
</code></pre>
<p>该函数的行为依赖于howto参数的值：<br>
SHUT_RD：关闭连接的读这一半——套接字中不再有数据可接收，而旦套接字接收缓冲区中的现有数据都被丢弃。进程不能再对这样的套接字调用任何读函数。对一个 TCP套接字这样调用shutdown函数后，由该套接字接收的来自对端的任何数据都被确认，然后悄然丢弃。<br>
SHUT_WR：关闭连接的写这一半——对于TCP套接字，这称为半关闭（half-close）。当前留在套接字发送缓冲区中的数据将被发送掉，后跟TCP的正常连接终止序列。不管套接字描述符的引用计数是否等于0,这样的写半部关闭照样执行。进程不能再对这样的套接字调用任何写函数。<br>
SHUT_RDWR：连接的读半部和写半部都关闭——这与调用shutdown两次等效：第一次调用指定SHUT_RD,第二次调用指定SHUT_WR。</p>
<h3 id="shutdown-和-close-的区别">shutdown() 和 close() 的区别</h3>
<p>从函数调用上来分析（msdn)：一旦完成了套接字的连接，应当将套接字关闭，并且释放其套接字句柄所占用的所有资源。真正释放一个已经打开的套接字句柄的资源直接调用closesocket即可，但要明白closesocket的调用可能会带来负面影响，具体的影响和如何调用有关，最明显的影响是数据丢失，因此一般都要在closesocket之前调用shutdown来关闭套接字。<br>
shutdown:为了保证通信双方都能够收到应用程序发出的所有数据，一个合格的应用程序的做法是通知接受双发都不在发送数据！这就是所谓的“正常关闭 ”套接字的方法，而这个方法就是由shutdown函数,传递给它的参数有SD_RECEIVE,SD_SEND,SD_BOTH三种，如果是 SD_RECEIVE就表示不允许再对此套接字调用接受函数。这对于协议层没有影响，另外对于tcp套接字来说，无论数据是在等候接受还是即将抵达，都要重置连接（注意对于udp协议来说，仍然接受并排列传入的数据，因此udp套接字而言shutdown毫无意义）。如果选择SE_SEND,则表示不允许再调用发送函数。对于tcp套接字来说，这意味着会在所有数据发送出并得到接受端确认后产生一个FIN包。如果指定SD_BOTH，答案不言而喻。<br>
closesocket:对此函数的调用会释放套接字的描述，这个道理众所周知（凡是经常翻阅msdn的程序员），因此，调用此函数后，再是用此套接字就会发生调用失败，通常返回的错误是WSAENOTSOCK。此时与被closesocket的套接字描述符相关联的资源都会被释放，包括丢弃传输队列中的数据！！！！对于当前进程中的线程来讲，所有被关起的操作，或者是被挂起的重叠操作以及与其关联的任何事件，完成例程或完成端口的执行都将调用失败！另外 SO_LINGER标志还影响着closesocket的行为，但对于传统的socket程序，这里不加解释<br>
因此可以可以看出shutdown对切断连接有着合理的完整性。<br>
下面从tcp协议上来分析shutdown和closesocket的行为（behavior)：closesocket或shutdown(使用 SD_SEND当作参数时）,会向通信对方发出一个fin包，而此时套接字的状态会由ESTABLISHED变成FIN_WAIT_1，然后对方发送一个 ACK包作为回应，套接字又变成FIN_WAIT_2，如果对方也关闭了连接则对方会发出FIN，我方会回应一个ACK并将套接字置为 TIME_WAIT。因此可以看出closesocket,shutdown所进行的TCP行为是一样的，所不同的是函数部分，shutdown会确保 windows建立的数据传输队列中的数据不被丢失，而closesocket会冒然的抛弃所有的数据，因此如果你愿意closesocket完全可以取代shutdown,然而在数据交互十分复杂的网络协议程序中，最好还是shutdown稳妥一些</p>
<h3 id="so_linger套接字选项">SO_LINGER套接字选项</h3>
<p>本选项指定close函数对面向连接的协议（例如TCP和SCTP,但不是UDP）如何操作。默 认操作是close立即返回，但是如果有数据残留在套接字发送缓冲区中，系统将试着把这些数据发送给对端。<br>
<img src="https://lixin-scut.github.io//post-images/1579433640262.png" alt=""><br>
SO_LINGER套接字选项使得我们可以改变这个默认设置。本选项要求在用户进程与内核间 传递如下结构，它在头文件＜sys/socket.h＞中定义：</p>
<pre><code>struct linger（
int	l_onoff;	/* ==off, nonzero=on */
int l_linger；	/* linger time, POSIX specifies units as seconds */
};
</code></pre>
<p>对setsockopt的调用将根据其中两个结构成员的值形成下列3种情形之一：<br>
（1）	如果l_onoff为0,那么关闭本选项。l_linger的值被忽略，先前讨论的TCP默认设置生效，即close立即返回。<br>
（2）	如果l_onoff为非0值且linger为0,那么当close某个连接时TCP将中止该连接 。这就是说TCP将丢弃保留在套接字发送缓冲区中的任何数据，并发送一个RST给对端，而没有通常的四分组连接终止序列。这么一来避免了TCP的TIME_WAIT状态，然而存在以下可能性：在2MSL秒内创建该连接的另一个化身，导致来自刚被终止的连接上的旧的重复分节被不正确地递送到新的化 身上。<br>
（3）如果l_onoff为非0值且linger也为非0值，那么当套接字关闭时内核将拖延一段时 间。这就是说如果在套接字发送缓冲区中仍残留有数据，那么进程将被投入睡眠，直到（a）所 有数据都已发送完且均被对方确认或（b）延滞时间到。如果套接字被设置为非阻塞型，那么它将不等待Close完成，即使延滞时间为非0也是如此。<br>
当使用SO_LINGER选项的这个 特性时，应用进程检查close的返回值是非常重要的，因为如果在数据发送完并被确认前延滞 时间到的话，close将返回EWOULDBLOCK错误，且套接字发送缓冲区中的任何残留数据都被丢弃。<br>
<img src="https://lixin-scut.github.io//post-images/1579433666835.png" alt=""><br>
默认情况下客户的close立即返回。 如图所示，客户的close可能在服务器读套接字接收缓区中的剩余数据之前就返回。对于服务 器主机来说，在服务器应用进程读这些剩余数据之前就崩溃是完全可能的，而且客户应用进程 永远不会知道。<br>
<img src="https://lixin-scut.github.io//post-images/1579433677337.png" alt=""><br>
客户可以设置SO_LINGER套接字选项，指定一个正的延滞时间。这种情况下客户的close 要到它的数据和FIN已被服务器主机的TCP确认后才返回<br>
然而我们仍然有与图7-7一样的问题：在服务器应用进程读这些剩余数据之前就崩溃是完全可能的，而且客户应用进程 永远不会知道。</p>
<p>更糟糕的是，图7-9展示了当给SO_LINGER选项设置偏低的延滞时间值时可能发生的现象。<br>
<img src="https://lixin-scut.github.io//post-images/1579433688864.png" alt=""><br>
这里有一个基本原则：设置SO_LINGER套接字选项后，close的成功返回只是告诉我们先 前发送的数据(和FIN)已由对端TCP确认，而不能告诉我们对端应用进程是否已读取数据。如 果不设置该套接字选项，那么我们连对端TCP是否确认了数据都不知道。<br>
让客户知道服务器己读取其数据的一个方法是改为调用shutdown (并设置它的第二个参数 为SHUT_WR)而不是调用close,并等待对端close连接的当地端(服务器端)<br>
<img src="https://lixin-scut.github.io//post-images/1579433700519.png" alt=""><br>
当关闭连接的本地端(客户端)时，根据所调用的函 数(close或shutdown)以及是否设置了SO_LINGER套接字选项，可在以下3个不同的时机返 回：<br>
(1)	close立即返回，根本不等待(默认状况，图7-7).<br>
(2)	close一直拖延到接收了对于客户端FIN的ACK才返回(图7-8).<br>
(3)后跟一个read调用的shutdown一直等到接收了对端的FIN才返回(图7-10).</p>
<p>获知对端应用进程已读取我们的数据的另外一个方法是使用应用级确认(application-level acknowledge),简称应用ACK (applicationACK)<br>
<img src="https://lixin-scut.github.io//post-images/1579433723131.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1579433736764.png" alt=""></p>
<p><img src="https://lixin-scut.github.io//post-images/1579433758408.png" alt=""></p>
<p><img src="https://lixin-scut.github.io//post-images/1579433770612.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Nagle 算法]]></title>
        <id>https://lixin-scut.github.io//post/nagle-suan-fa</id>
        <link href="https://lixin-scut.github.io//post/nagle-suan-fa">
        </link>
        <updated>2020-03-05T10:15:02.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>起因<br>
在ssh连接中，通常单次击键就会引发数据流的传输。如果使用IPv4, 一次按键会生成约88字节大小的TCP/IPV4包（使用加密和认证）：20字节的IP头部，20字节的TCP头部（假设没有选项），数据部分为48字节。这些小包（称为微型 报（tinygram））会造成相当高的网络传输代价。也就是说，与包的其他部分相比，有效的应 用数据所占比例甚微。该问题对于局域网不会有很大影响，因为大部分局域网不存在拥塞， 而且这些包无须传输很远。然而对于广域网来说则会加重拥塞，严重影响网络性能。</p>
</blockquote>
<h3 id="nagle算法">Nagle算法</h3>
<p>  Nagle算法要求，当一个TCP连接中有在传数据（即那些已发送但还未经确认的数据）， 小的报文段（长度小于SMSS）就不能被发送，直到所有的在传数据都收到ACK。并且，在收到ACK后，TCP需要收集这些小数据，将其整合到一个报文段中发送。这种方法迫使 TCP遵循停等（stop-and-wait）规程——只有等接收到所有在传数据的ACK后才能继续发 送。该算法的精妙之处在于它实现了自时钟（self.clocking）控制：ACK返回越快，数据传输也越快。在相对高延迟的广域网中，更需要减少微型报的数目，该算法使得单位时间内发送的报文段数目更少。也就是说，RTT控制着发包速率。</p>
<h3 id="延时ack与nagle算法结合">延时ACK与Nagle算法结合</h3>
<p>  若将延时ACK与Nagle算法直接结合使用，得到的效果可能不尽如人意。 考虑如下情形，客户端使用延时ACK方法发送一个对服务器的请求，而服务器端的响应数据并不适合在同一个包中传输<br>
  在接收到来自服 务器端的包以后，客户端并不立即 发送ACK,而是处于等待状态，希望有 数据一同捎带发送。通常情况下，TCP 在接收到数据包后就应返回 一个ACK,但这里并非如此。在服务器端，由于使用了 Nagle算法，直到收到ACK前都不能发送新数据新数据，因为任一时刻只允许至多一个包在传。因此延时 ACK与Nagle算法的结合导致了某种程度的死锁（两端互相等待对方做出行动。幸运的是，这种死锁并不是永久的，在延时ACK计时器超时后死锁会解除。客户 端即使仍然没有要发送的数据也无需再等待，而可以只发送ACK给服务器。然而，在死锁 期间整个传输连接处于空闲状态，使性能变差。在某些情况下，如这里的ssh传输，可以禁用Nagle算法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[桶排序]]></title>
        <id>https://lixin-scut.github.io//post/tong-pai-xu</id>
        <link href="https://lixin-scut.github.io//post/tong-pai-xu">
        </link>
        <updated>2020-03-05T02:27:20.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://lixin-scut.github.io/post/san-chong-xian-xing-pai-xu-suan-fa-ji-shu-pai-xu-tong-pai-xu-yu-ji-shu-pai-xu/">三种线性排序算法 计数排序、桶排序与基数排序</a><br>
之前我已经总结过一次了，所以这次直接以例题为例子引出代码吧<br>
<a href="https://lixin-scut.github.io/post/shu-zu-164-zui-da-jian-ju/">数组 164. 最大间距</a></p>
<p>首先定义桶，桶为一个数据容器，每个桶存储一个区间内的数。依然有一个待排序的整数序列A，元素的最小值不小于0，最大值不超过K。假设我们有M个桶，第i个桶Bucket[i]存储i*K/M至(i+1)K/M之间的数，<br>
扫描序列A，根据每个元素的值所属的区间，放入指定的桶中(顺序放置)。<br>
对每个桶中的元素进行排序，什么排序算法都可以，例如快速排序。<br>
依次收集每个桶中的元素，顺序放置到输出序列中。<br>
对该算法简单分析，如果数据是期望平均分布的，则每个桶中的元素平均个数为N/M。如果对每个桶中的元素排序使用的算法是快速排序，每次排序的时间复杂度为O(N/Mlog(N/M))。则总的时间复杂度为O(N)+O(M)O(N/Mlog(N/M)) = O(N+ Nlog(N/M)) = O(N + NlogN - NlogM)。当M接近于N是，桶排序的时间复杂度就可以近似认为是O(N)的。就是桶越多，时间效率就越高，而桶越多，空间却就越大，由此可见时间和空间是一个矛盾的两个方面。<br>
桶中元素的顺序放入和顺序取出是有必要的，因为这样可以确定桶排序是一种稳定排序算法</p>
<p>相关题目</p>
<blockquote>
<p>给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。<br>
如果数组元素个数小于 2，则返回 0。<br>
示例 1:<br>
输入: [3,6,9,1]<br>
输出: 3<br>
解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。<br>
示例 2:<br>
输入: [10]<br>
输出: 0<br>
解释: 数组元素个数小于 2，因此返回 0。<br>
说明:<br>
你可以假设数组中所有元素都是非负整数，且数值在 32 位有符号整数范围内。<br>
请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。</p>
</blockquote>
<p>实现：</p>
<pre><code>class Solution {
public:
    int maximumGap(vector&lt;int&gt;&amp; nums) {
        int length = nums.size();
        if(length &lt; 2)
            return 0;
        
        int maxNum,minNum;
        maxNum = INT_MIN;
        minNum = INT_MAX;
        for(auto i : nums)
        {
            maxNum = maxNum &gt; i ? maxNum : i;
            minNum = minNum &lt; i ? minNum : i;
        }
        
        if(maxNum - minNum == 0)
        { return 0; }
        
        int bucketStep = (maxNum - minNum) / (length - 1);
        if(bucketStep == 0)
        { bucketStep = 1; }
        int bucketSize = (maxNum - minNum) / bucketStep + 1;
        vector&lt;vector&lt;int&gt;&gt; buckets(bucketSize, vector&lt;int&gt;(2));
        vector&lt;bool&gt; usedBuckets(bucketSize, false);
        
        for(auto num : nums)
        {
            int loc = (num - minNum) / bucketStep;
            if(!usedBuckets[loc])
            {
                usedBuckets[loc] = true;
                buckets[loc][0] = num;
                buckets[loc][1] = num;
            }
            else
            {
                buckets[loc][0] = buckets[loc][0] &lt; num ? buckets[loc][0] : num;
                buckets[loc][1] = buckets[loc][1] &gt; num ? buckets[loc][1] : num;
            }
        }
        int maxTemp,minTemp,res;
        maxTemp = buckets[0][1];
        minTemp = buckets[0][0];
        res = INT_MIN;
        for(int loc = 1; loc &lt; bucketSize; ++loc)
        {
            if(usedBuckets[loc])
            {
                minTemp = buckets[loc][0];
                res = res &gt; (minTemp - maxTemp) ? res : (minTemp - maxTemp);
                maxTemp = buckets[loc][1];
            }
        }
        return res;
    }
}
</code></pre>
<p>实现过程中需要注意的点</p>
<ol>
<li>数组最大值和最小值可以在一个循环内同时求出，不必要分开。</li>
<li>要判断最大值与最小值是否相等</li>
<li>由于重复元素的存在，可能会因为元素的个数大于元素的间隔，导致bucketStep等于0，此时必须加上判断并将bucketStep置为1，否则bucketSize得不到正确的结果。</li>
<li>计算位置loc时不要忘了减去minNum，亦即<code>int loc = (num - minNum) / bucketStep;</code></li>
<li>最后遍历寻找最大间距时，可以先把临时值初始化为bucket[0]的值，由于桶排序的特性，bucket[0]不可能为空。</li>
<li>一定要注意每个对象的初始值，哪些是INT_MIN，哪些是INT_MAX</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 题46:把数字翻译成字符串]]></title>
        <id>https://lixin-scut.github.io//post/zi-fu-chuan-ti-46ba-shu-zi-fan-yi-cheng-zi-fu-chuan</id>
        <link href="https://lixin-scut.github.io//post/zi-fu-chuan-ti-46ba-shu-zi-fan-yi-cheng-zi-fu-chuan">
        </link>
        <updated>2020-03-05T00:35:15.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>给定一个数字，我们按照如下规则把它翻译为字符串：0翻译成&quot;a&quot;，1翻译成&quot;b&quot;，……，11翻译成&quot;l&quot;，……，25翻译成&quot;z&quot;。一个数字可能有多个翻译。例如12258有5种不同的翻译，它们是&quot;bccfi&quot;、&quot;bwfi&quot;、&quot;bczi&quot;、&quot;mcfi&quot;和&quot;mzi&quot;。请编程实现一个函数用来计算一个数字有多少种不同的翻译方法。</p>
</blockquote>
<p>书本题解：<br>
  当最开始的一个或者两个数字被翻译成一个字符之后，我们接着翻译后而剩下的数字。显然，我们可以写一个递归函数来计算翻译的数目。<br>
  我们定义函数f(i)表小从第i位数字开始的不同翻译的数目，那么f(i)=f(i+1)+g(i,i+1)xf(i+2)。当第i位和第i+1位两位数字拼接起来的数字在 10〜25的范围内时，函数g(i,i+1)的值为1；否则为0。<br>
  尽管我们用递归的思路来分析这个问题，但由于存在重复的子问题， 递归并不是解决这个问题的最佳方法。还是以12258为例。如前所述，翻译12258可以分解成两个子问题：翻译1和2258,以及翻译12和258。接 下来我们翻译第一个子问题中剩下的2258,同样也可以分解成两个自问题： 翻译2和258,以及翻译22和58。注意到子问题翻译258重复出现了。<br>
  递归从最大的问题开始自上而下解决问题。我们也可以从最小的子问题开始自下而上解决问题，这样就可以消除重复的子问题。也就是说，我 们从数字的末尾开始，然后从右到左翻译并计算不同翻译的数目。</p>
<pre><code>int GetTranslationCount(int number)
{
    if(number &lt; 0)
        return 0;

    string numberInString = to_string(number);
    return GetTranslationCount(numberInString);
}

int GetTranslationCount(const string&amp; number)
{
    int length = number.length();
    int* counts = new int[length];
    int count = 0;

    for(int i = length - 1; i &gt;= 0; --i)
    {
        count = 0;
         if(i &lt; length - 1)
               count = counts[i + 1];
         else
               count = 1;

        if(i &lt; length - 1)
        {
            int digit1 = number[i] - '0';
            int digit2 = number[i + 1] - '0';
            int converted = digit1 * 10 + digit2;
            if(converted &gt;= 10 &amp;&amp; converted &lt;= 25)
            {
                if(i &lt; length - 2)
                    count += counts[i + 2];
                else
                    count += 1;
            }
        }

        counts[i] = count;
    }

    count = counts[0];
    delete[] counts;

    return count;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math 题44:数字序列中某一位的数字]]></title>
        <id>https://lixin-scut.github.io//post/math-ti-44shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi</id>
        <link href="https://lixin-scut.github.io//post/math-ti-44shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi">
        </link>
        <updated>2020-03-05T00:23:47.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从0开始计数）是5，第13位是1，第19位是4，等等。请写一个函数求任意位对应的数字。</p>
</blockquote>
<p>书本题解：<br>
序列的第1001位是什么？<br>
序列的前10位是0〜9这10个只有一位的数字。显然第1001位在这 10个数字之后，因此这10个数字可以直接跳过。我们再从后面紧跟着的序列中找第991 (991=1001-10)位的数字。<br>
接下来180位数字是90个10-99的两位数。由于991&gt;180,所以第 991位在所有的两位数之后。我们再跳过90个两位数，继续从后面找881 (881=991-180)位。<br>
接下来的2700位是900个100-999的三位数。由于811&lt;2700,所以 第811位是某个三位数中的一位。由于811=270x3+1,这意味着第811位是 从100开始的第270个数字即370的中间一位，也就是7。</p>
<pre><code>int digitAtIndex(int index)
{
	if(index &lt; 0)
		return -1;

	int digits = 1;
	while(true)
	{
		int numbers = countOfIntegers(digits);
		if(index &lt; numbers * digits)
			return digitAtIndex(index, digits);

		index -= digits * numbers;
		digits++;
	}

	return -1;
}

int countOfIntegers(int digits)
{
	if(digits == 1)
		return 10;

	int count = (int) std::pow(10, digits - 1);
	return 9 * count;
}

int digitAtIndex(int index, int digits)
{
	int number = beginNumber(digits) + index / digits;
	int indexFromRight = digits - index % digits;
	for(int i = 1; i &lt; indexFromRight; ++i)
		number /= 10;
	return number % 10;
}

int beginNumber(int digits)
{
	if(digits == 1)
		return 0;

	return (int) std::pow(10, digits - 1);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math 题17:打印1到最大的n位数]]></title>
        <id>https://lixin-scut.github.io//post/math-ti-17da-yin-1-dao-zui-da-de-n-wei-shu</id>
        <link href="https://lixin-scut.github.io//post/math-ti-17da-yin-1-dao-zui-da-de-n-wei-shu">
        </link>
        <updated>2020-03-05T00:12:17.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>输入数字n，按顺序打印出从1最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数即999。</p>
</blockquote>
<p>书本题解：</p>
<blockquote>
<p>  如果面试题是关于n位的整数并且没有限定n的取值范围，或者输入任意大小的整数，那么这道题目很有可能是需要考虑大数问题的 字符串 是一种简单、有效地表示大数的方法<br>
  如果我们在数字前面补0,就会发现n位所有十进制数其实就是n个从0到9 的全排列。也就是说，我们把数字的每一位都从0到9排列一遍，就得到 了所有的十进制数。只是在打印的时候，排在前面的。不打印出来罢了。<br>
  全排列用递归很容易表达，数字的每一位都可能是0〜9中的一个数， 然后设置下一位。递归结束的条件是我们已经设置了数字的最后一位。<br>
  定义了函数PrintNumbur,在这个函数里，只有在碰到第一个非0的字符之后才开始打印，直至字符串的结尾。</p>
</blockquote>
<pre><code>void Print1ToMaxOfNDigits_2(int n)
{
    if (n &lt;= 0)
        return;

    char* number = new char[n + 1];
    number[n] = '\0';

    for (int i = 0; i &lt; 10; ++i)
    {
        number[0] = i + '0';
        Print1ToMaxOfNDigitsRecursively(number, n, 0);
    }

    delete[] number;
}

void Print1ToMaxOfNDigitsRecursively(char* number, int length, int index)
{
    if (index == length - 1)
    {
        PrintNumber(number);
        return;
    }

    for (int i = 0; i &lt; 10; ++i)
    {
        number[index + 1] = i + '0';
        Print1ToMaxOfNDigitsRecursively(number, length, index + 1);
    }
}

// 字符串number表示一个数字，数字有若干个0开头
// 打印出这个数字，并忽略开头的0
void PrintNumber(char* number)
{
    bool isBeginning0 = true;
    int nLength = strlen(number);

    for (int i = 0; i &lt; nLength; ++i)
    {
        if (isBeginning0 &amp;&amp; number[i] != '0')
            isBeginning0 = false;

        if (!isBeginning0)
        {
            printf(&quot;%c&quot;, number[i]);
        }
    }

    printf(&quot;\t&quot;);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux/Unix常用命令]]></title>
        <id>https://lixin-scut.github.io//post/linuxunix-chang-yong-ming-ling</id>
        <link href="https://lixin-scut.github.io//post/linuxunix-chang-yong-ming-ling">
        </link>
        <updated>2020-03-04T10:56:52.000Z</updated>
        <content type="html"><![CDATA[<p>这篇博文主要是为了方便自己查看常用命令，并总结一些已有命令的特点和详情。<br>
因为我常用的的系统是macOS和Ubuntu（或者CentOS），所以某些细节可能会有出入</p>
<h2 id="日常管理用命令">日常管理用命令</h2>
<p><strong>ps</strong><br>
观察系统所有的进程数据[root@study ~]# ps aux<br>
也是能够观察所有系统的数据[root@study ~]# ps -lA<br>
连同部分进程树状态[root@study ~]# ps axjf<br>
仅观察自己的 bash 相关进程： ps -l<br>
选项与参数:<br>
-A :所有的 process 均显示出来，与 -e 具有同样的效用; -a :不与 terminal 有关的所有 process ;<br>
-u :有效使用者 (effective user) 相关的 process ; x :通常与 a 这个参数一起使用，可列出较完整信息。 输出格式规划:<br>
l :较长、较详细的将该 PID 的的信息列出;<br>
j :工作的格式 (jobs format) -f :做一个更为完整的输出。</p>
<p><strong>top</strong><br>
动态观察进程的变化<br>
top 预设使用 CPU 使用率 (%CPU) 作为排序的重点，如果你想要使用内存使用率排序，则可以按 下『M』<br>
选项与参数:<br>
-d :后面可以接秒数，就是整个进程画面更新的秒数。预设是 5 秒;<br>
-b :以批次的方式执行 top ，还有更多的参数可以使用喔! 通常会搭配数据流重导向来将批次的结果输出成为文件。<br>
-n :与 -b 搭配，意义是，需要进行几次 top 的输出结果。 -p :指定某些个 PID 来进行观察监测而已。<br>
在 top 执行过程当中可以使用的按键指令:<br>
? :显示在 top 当中可以输入的按键指令; P :以 CPU 的使用资源排序显示;<br>
M :以 Memory 的使用资源排序显示;<br>
N :以 PID 来排序喔!<br>
T :由该 Process 使用的 CPU 时间累积 (TIME+) 排序。 k :给予某个 PID 一个讯号 (signal)<br>
r :给予某个 PID 重新制订一个 nice 值。 q :离开 top 软件的按键。</p>
<h2 id="vim编辑命令">VIM编辑命令</h2>
<h2 id="网络检测专用命令">网络检测专用命令</h2>
<h2 id="命令详解">命令详解</h2>
<p><strong>ps</strong><br>
将某个时间点的进程运作情况撷取下来<br>
选项与参数：<br>
-A ：所有的 process 均显示出来，与 -e 具有同样的效用；<br>
-a ：不与 terminal 有关的所有 process ；<br>
-u ：有效使用者 (effective user) 相关的 process ；<br>
x ：通常与 a 这个参数一起使用，可列出较完整信息。<br>
输出格式规划：<br>
l ：较长、较详细的将该 PID 的的信息列出；<br>
j ：工作的格式 (jobs format)<br>
-f ：做一个更为完整的输出。<br>
观察系统所有的进程数据[root@study ~]# ps aux<br>
也是能够观察所有系统的数据[root@study ~]# ps -lA<br>
连同部分进程树状态[root@study ~]# ps axjf</p>
<p>重点：<br>
只能查阅自己 bash 进程的『 ps -l 』<br>
可以查阅所有系统运作的进程『 ps aux 』</p>
<p>但是ps -l 与 ps aux 显示的项目并不相同</p>
<p>仅观察自己的 bash 相关进程： ps -l<br>
F：代表这个进程旗标 (process flags)，说明这个进程的总结权限，常见号码有：<br>
若为 4 表示此进程的权限为 root ；<br>
若为 1 则表示此子进程仅进行复制(fork)而没有实际执行(exec)。<br>
 S：代表这个进程的状态 (STAT)，主要的状态有：<br>
R (Running)：该程序正在运作中；<br>
S (Sleep)：该程序目前正在睡眠状态(idle)，但可以被唤醒(signal)。<br>
D ：不可被唤醒的睡眠状态，通常这支程序可能在等待 I/O 的情况(ex&gt;打印)<br>
T ：停止状态(stop)，可能是在工作控制(背景暂停)或除错 (traced) 状态；<br>
Z (Zombie)：僵尸状态，进程已经终止但却无法被移除至内存外。<br>
 UID/PID/PPID：代表『此进程被该 UID 所拥有/进程的 PID 号码/此进程的父进程 PID 号码』<br>
 C：代表 CPU 使用率，单位为百分比；<br>
 PRI/NI：Priority/Nice 的缩写，代表此进程被 CPU 所执行的优先级，数值越小代表该进程越快被 CPU 执行。详细的 PRI 与 NI 将在下一小节说明。<br>
 ADDR/SZ/WCHAN：都与内存有关，ADDR 是 kernel function，指出该进程在内存的哪个部分，如果是个running 的进程，一般就会显示『 - 』 / SZ 代表此进程用掉多少内存 / WCHAN 表示目前进程是否运作中，同样的， 若为 - 表示正在运作中。<br>
 TTY：登入者的终端机位置，若为远程登录则使用动态终端接口 (pts/n)；<br>
 TIME：使用掉的 CPU 时间，注意，是此进程实际花费 CPU 运作的时间，而不是系统时间；<br>
 CMD：就是 command 的缩写，造成此进程的触发程序之指令为何。</p>
<p>观察系统所有进程： ps aux<br>
各字段的意义为：<br>
 USER：该 process 属于那个使用者账号的？<br>
 PID ：该 process 的进程标识符。<br>
 %CPU：该 process 使用掉的 CPU 资源百分比；<br>
 %MEM：该 process 所占用的物理内存百分比；<br>
 VSZ ：该 process 使用掉的虚拟内存量 (Kbytes)<br>
 RSS ：该 process 占用的固定的内存量 (Kbytes)<br>
 TTY ：该 process 是在那个终端机上面运作，若与终端机无关则显示 ?，另外， tty1-tty6 是本机上面的登<br>
入者进程，若为 pts/0 等等的，则表示为由网络连接进主机的进程。<br>
 STAT：该进程目前的状态，状态显示与 ps -l 的 S 旗标相同 (R/S/T/Z)<br>
 START：该 process 被触发启动的时间；<br>
 TIME ：该 process 实际使用 CPU 运作的时间。<br>
 COMMAND：该进程的实际指令为何？</p>
<p>『僵尸 (zombie) 』进程<br>
造成僵尸进程的成因是因为该进程应该已经执行完毕，或者是因故应该要终止了， 但是该进程的父进程却无法完整的将该进程结束掉，而造成那个进程一直存在内存当中。<br>
如果你发现在某个进程的 CMD 后面还接上<code>&lt;defunct&gt;</code>时，就代表该进程是僵尸进程<br>
重点<br>
不要仅仅将僵尸进程 kill 掉而已，要找出该进程的父进程</p>
<p><strong>top</strong><br>
top 主要分为两个画面，上面的画面为整个系统的资源使用状态，基本上总共有六行， 显示的内容依序是:<br>
 第一行(top...):这一行显示的信息分别为:<br>
o 目前的时间，亦即是 00:53:59 那个项目;<br>
o 开机到目前为止所经过的时间，亦即是 up 6:07, 那个项目;<br>
o 已经登入系统的用户人数，亦即是 3 users, 项目;<br>
o 系统在 1, 5, 15 分钟的平均工作负载。我们在第十五章谈到的 batch 工作方式为负载小于 0.8 就是<br>
这个负载啰!代表的是 1, 5, 15 分钟，系统平均要负责运作几个进程(工作)的意思。 越小代表系统 越闲置，若高于 1 得要注意你的系统进程是否太过繁复了!</p>
<p> 第二行(Tasks...):显示的是目前进程的总量与个别进程在什么状态(running, sleeping, stopped, zombie)。 比较 需要注意的是最后的 zombie 那个数值，如果不是 0 !好好看看到底是那个 process 变成僵尸了吧?<br>
 第三行(%Cpus...):显示的是 CPU 的整体负载，每个项目可使用 ? 查阅。需要特别注意的是 wa 项目，那 个项目代表的是 I/O wait， 通常你的系统会变慢都是 I/O 产生的问题比较大!因此这里得要注意这个项目 耗用 CPU 的资源喔! 另外，如果是多核心的设备，可以按下数字键『1』来切换成不同 CPU 的负载率。<br>
 第四行与第五行:表示目前的物理内存与虚拟内存 (Mem/Swap) 的使用情况。 再次重申，要注意的是 swap 的使用量要尽量的少!如果 swap 被用的很大量，表示系统的物理内存实在不足!<br>
 第六行:这个是当在 top 程序当中输入指令时，显示状态的地方。<br>
至于 top 下半部分的画面，则是每个 process 使用的资源情况。比较需要注意的是:<br>
 PID :每个 process 的 ID 啦!<br>
 USER:该 process 所属的使用者;<br>
 PR :Priority 的简写，进程的优先执行顺序，越小越早被执行;<br>
 NI :Nice 的简写，与 Priority 有关，也是越小越早被执行;<br>
 %CPU:CPU 的使用率;<br>
 %MEM:内存的使用率;<br>
 TIME+:CPU 使用时间的累加;</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[静态链接与动态链接-链接]]></title>
        <id>https://lixin-scut.github.io//post/jing-tai-lian-jie-yu-dong-tai-lian-jie-lian-jie</id>
        <link href="https://lixin-scut.github.io//post/jing-tai-lian-jie-yu-dong-tai-lian-jie-lian-jie">
        </link>
        <updated>2020-03-04T09:23:46.000Z</updated>
        <content type="html"><![CDATA[<h3 id="动态编译与静态编译">动态编译与静态编译</h3>
<ol>
<li>静态编译，编译器在编译可执行文件时，把需要用到的对应动态链接库中的部分提取出来，连接到可执行文件中去，使可执行文件在运行时不需要依赖于动态链接库；</li>
<li>动态编译的可执行文件需要附带一个动态链接库，在执行时，需要调用其对应动态链接库的命令。所以其优点一方面是缩小了执行文件本身的体积，另一方面是加快了编译速度，节省了系统资源。缺点是哪怕是很简单的程序，只用到了链接库的一两条命令，也需要附带一个相对庞大的链接库；二是如果其他计算机上没有安装对应的运行库，则用动态编译的可执行文件就不能运行。</li>
</ol>
<h3 id="动态链接和静态链接区别">动态链接和静态链接区别</h3>
<ol>
<li>静态连接库就是把(lib)文件中用到的函数代码直接链接进目标程序，程序运行的时候不再需要其它的库文件；动态链接就是把调用的函数所在文件模块（DLL）和调用函数在文件中的位置等信息链接进目标程序，程序运行的时候再从DLL中寻找相应函数代码，因此需要相应DLL文件的支持。</li>
<li>静态链接库与动态链接库都是共享代码的方式，如果采用静态链接库，则无论你愿不愿意，lib 中的指令都全部被直接包含在最终生成的 EXE 文件中了。但是若使用 DLL，该 DLL 不必被包含在最终 EXE 文件中，EXE 文件执行时可以“动态”地引用和卸载这个与 EXE 独立的 DLL 文件。</li>
<li>静态链接库和动态链接库的另外一个区别在于静态链接库中不能再包含其他的动态链接库或者静态库，而在动态链接库中还可以再包含其他的动态或静态链接库。</li>
<li>动态库就是在需要调用其中的函数时，根据函数映射表找到该函数然后调入堆栈执行。如果在当前工程中有多处对dll文件中同一个函数的调用，那么执行时，这个函数只会留下一份拷贝。但是如果有多处对lib文件中同一个函数的调用，那么执行时，该函数将在当前程序的执行空间里留下多份拷贝，而且是一处调用就产生一份拷贝。</li>
</ol>
<p>参考资料：<br>
《深入了解计算机系统》</p>
<h3 id="链接">链接</h3>
<p>  链接(linking)是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文 件可被加载(复制)到内存并执行。链接可以执行于编'译时(compile time),也就是在源代 码被翻译成机器代码时；也可以执行于加载时(load time),也就是在程序被加载器(loader)加载到内存并执行时；甚至执行于运行时(run time),也就是由应用程序来执行。在早 期的计算机系统中，链接是手动执行的。在现代系统中，链接是由叫做链接器(linker)的 程序自动执行的。<br>
  链接器使得分离编译(separate compilation) 成为可能。我们不用将一个大型的应用程序组织为一个巨大的源文件，而是可以 把它分解为更小、更好管理的模块，可以独立地修改和编译这些模块。当我们改变这些模块中的一个时，只需简单地重新编译它，并重新链接应用，而不必重新编译其他文件。</p>
<h3 id="编译器">编译器</h3>
<p>  编译系统提供编译器驱动程序(compiler driver),它代表用户在需要时调用语言预处理器、编译器、汇编器和链接器。<br>
<img src="https://lixin-scut.github.io//post-images/1583314062138.png" alt=""></p>
<ol>
<li>驱动程序首先运行C预处理器(cpp) ,它将C的源程序main. c翻译成一个ASCII码的中间文件main.i。</li>
<li>驱动程序运行C编译器(ccl)，它将main.i翻译成一个ASCII汇编语言文件main.s:</li>
<li>驱动程序运行汇编器(as)，它将main.s翻译成一个可重定位目标文件(relocatable object file)main.o</li>
<li>最后，它运行链接器程序Id,将main.o和 sum.o以及一些必要的系统目标文件组合起来，创建一个可执行目标文件(executable object file)prog</li>
</ol>
<h3 id="静态链接">静态链接</h3>
<p>  静态链接器(static linker)以一组可重定位目标文件和命令行 参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。输入的可重定位目标文件由各种不同的代码和数据节(section)组成，每一节都是一个连续的字节序列。<br>
为了构造可执行文件，链接器必须完成两个主要任务：<br>
  •符号解析(symbol resolution) o目标文件定义和引用符号，每个符号对应于一&quot;函 数、一个全局变量或一个静态变量(即C语言中任何以static属性声明的变量)。 符号解析的目的是将每个符号引用正好和一个符号定义关联起来。<br>
  •重定位(relocation) o编译器和汇编器生成从地址0开始的代码和数据节。链接器通 过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对 这些符号的引用，使得它们指向这个内存位置。链接器使用汇编器产生的重定位条 目(relocation entry)的详细指令，不加甄别地执行这样的重定位。<br>
  记住关于链接器的一 些基本事实：目标文件纯粹是字节块的集合。链接器将这些块连接起来，确 定被连接块的运行时位置，并且修改代码和数据块中的各种位置。</p>
<h3 id="目标文件">目标文件</h3>
<p>目标文件有三种形式：<br>
  •可重定位目标文件。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。<br>
  •可执行目标文件。包含二进制代码和数据，其形式可以被直接复制到内存并执行。<br>
  •共享目标文件。一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。<br>
  编译器和汇编器生成可重定位目标文件(包括共享目标文件)。链接器生成可执行目标文 件。从技术上来说，一个目标模块(object module)就是一哥字节序列，而一个目标文件(object file) 就是一个以文件形式存放在磁盘中的目标模块。不过，我们会互换地使用这些术语。<br>
  目标文件是按照特定的目标文件格式来组织的，各个系统的目标文件格式都不相同。</p>
<h3 id="静态库">静态库</h3>
<p>  所有的编译系统都提供一种机制，将所有相关的目标模块打包成为一个单独的文件，称为静态库(static library),它可以用做链接器的输入。 当链接器构造一个输出的可执行文件时，它只复制静态库里被应用程序引用的目标模块。<br>
静态库相关的函数可以被编译为独'切的 目标模块，然后封装成一个单独的静态库文件。然后，应用程序可以通过在命令行上指定 单独的文件名字来使用这些在库中定义的函数。<br>
  在链接时，链接器将只复制被程序引用的目标模块，这就减少了可执行文件在磁盘和内 存中的大小。另一方面，应用程序员只需要包含较少的库文件的名字<br>
  在Linux系统中，静态库以一种称为存档（archive）的特殊文件格式存放在磁盘中。存 档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置。存档文件名由后缀.a标识。<br>
<img src="https://lixin-scut.github.io//post-images/1583314592237.png" alt=""></p>
<h3 id="链接器如何使用静态库来解析引用">链接器如何使用静态库来解析引用</h3>
<p>  虽然静态库很有用，但是它们同时也是一个程序员迷惑的源头，原因在于Linux链接 器使用它们解析外部引用的方式。在符号解析阶段，链接器从左到右按照它们在编译器驱 动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件。（驱动程序自动将命令 行中所有的.c文件翻译为.o文件。）在这次扫描中，链接器维护一个可重定位目标文件的 集合E（这个集合中的文件会被合并起来形成可执行文件），一个未解析的符号（即引用了 但是尚未定义的符号）集合U,以及一个在前面输入文件中已定义的符号集合初始时，<br>
E、U和D均为空。<br>
  •对于命令行上的每个输入文件f，链接器会判断f是一个目标文件还是一个存档文件。如果是一个目标文件，那么链接器把f添加到E,修改U和D来反映中 的符号定义和引用，并继续下一个输入文件。<br>
  ・如果f是一个存档文件，那么链接器就尝试匹配U中未解析的符号和由存档文件成员定 义的符号。如果某个存档文件成员％,定义了一个符号来解析U中的一个引用，那么就 将m加到E中，并且链接器修改U和。来反映〃中的符号定义和引用。对存档文件中 所有的成员目标文件都依次进行这个过程，直到U和。都不再发生变化。此时，任何不 包含在E中的成员目标文件都简单地被丢弃，而链接器将继续处理下一个输入文件。<br>
  •如果当链接器完成对命令行上输入文件的扫描后，U是非空的，那么链接器就会输出一 个错误并终止玄否则，它会合并和重定位E中的目标文件，构建输出的可执行文件。<br>
  不幸的是，这种算法会导致一些令人困扰的链接时错误，因为命令行上的库和目标文 件的顺序非常重要。在命令行中，如果定义一个符号的库出现在引用这个符号的目标文件 之前，那么引用就不能被解析，链接会失败。<br>
  关于库的一般准则是将它们放在命令行的结尾。如果各个库的成员是相互独立的（也 就是说没有成员引用另一个成员定义的符号），那么这些库就可以以任何顺序放置在命令 行的结尾处。另一方面，如果库不是相互独立的，那么必须对它们排序，使得对于每个被 存档文件的成员外部引用的符号S,在命令行中至少有一个S的定义是在对S的引用之后 的。</p>
<h3 id="重定位">重定位</h3>
<p>  一旦链接器完成了符号解析这一步，就把代码中的每个符号引用和正好一个符号定义 （即它的一个输入目标模块中的一个符号表条目）关联起来。此时，链接器就知道它的输入 目标模块中的代码节和数据节的确切大小。现在就可以开始重定位步骤了，在这个步骤 中，将合并输入模块，并为每个符号分配运行时地址。重定位由两步组成：<br>
  •重定位节和符号定义。在这一步中，链接器将所有相同类型的节合并为同一类型的 新的聚合节。例如，来自所有输入模块的.data节被全部合并成一个节，这个节成 为输出的可执行目标文件的.data节。然后，链接器将运行时内存地址赋给新的聚 合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步 完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了。<br>
  •重定位节中的符号引用。在这一步中，链接器修改代码节和数据节中对每个符号的 引用，使得它们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目 标模块中称为重定位条目（relocation entry）的数据结构，我们接下来将会描述这种 数据结构。</p>
<h3 id="动态链接共享库">动态链接共享库</h3>
<p>  静态库仍然有一些明显的缺点。静态库和所有的软件一样，需要定期维护 和更新。<br>
  共享库(shared library)是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接 起来。这个过程称为动态链接(dynamic linking),是由一个叫做动态链接器(dynamic linker) 的程序来执行的。共享库也称为共享目标(shared object),在Linux系统中通常用.s后缀<br>
共  享库是以两种不同的方式来“共享&quot;的。首先，在任何给定的文件系统 中，对于一个库只有一个.s文件。所 有引用该库的可执行目标文件共享这个. s文件中的代码和数据，而不是像静态库的内容那样被复制和嵌入到引用它们的可执行的文件中。其次，在内存中一个共享库的.text节的一个副本可以 被不同的正在运行的进程共享。<br>
<img src="https://lixin-scut.github.io//post-images/1583314987298.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1583315044588.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线程同步机制]]></title>
        <id>https://lixin-scut.github.io//post/tong-bu-ji-zhi</id>
        <link href="https://lixin-scut.github.io//post/tong-bu-ji-zhi">
        </link>
        <updated>2020-03-04T07:42:34.000Z</updated>
        <content type="html"><![CDATA[<p>同步机制：<br>
信号量、管程、互斥是进程的同步机制，而信号量、互斥也可用于线程的同步，但管程只在进程同步中被用到；<br>
线程的同步除了信号量、互斥外，还有临界区、事件，没有看到教材上将这两种方式作为进程的同步方式；</p>
<p>线程同步同步是指多线程通过特定的设置来控制线程之间的执行顺序，也可以说在线程之间通过同步建立起执行顺序的关系；</p>
<p>线程同步</p>
<ol>
<li>主要的四种方式，临界区、互斥对象、信号量、事件对象；其中临界区和互斥对象主要用于互斥控制，信号量和事件对象主要用于同步控制；</li>
<li>临界区：对共享内存进行访问的程序片段称作临界区。<br>
通过对多线程的串行化来访问公共资源或一段代码，速度快、适合控制数据访问。在任意一个时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。</li>
<li>互斥对象：互斥对象和临界区很像，采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程同时访问。当前拥有互斥对象的线程处理完任务后必须将线程交出，以便其他线程访问该资源。<br>
比如：互斥锁、条件变量、读写锁、自旋锁</li>
<li>信号量：它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。在用CreateSemaphore()创建信号量时即要同时指出允许的最大资源计数和当前可用资源计数。一般是将当前可用资源计数设置为最 大资源计数，每增加一个线程对共享资源的访问，当前可用资源计数就会减1 ，只要当前可用资源计数是大于0 的，就可以发出信号量信号。但是当前可用计数减小 到0 时则说明当前占用资源的线程数已经达到了所允许的最大数目，不能在允许其他线程的进入，此时的信号量信号将无法发出。线程在处理完共享资源后，应在离 开的同时通过ReleaseSemaphore （）函数将当前可用资源计数加1 。在任何时候当前可用资源计数决不可能大于最大资源计数。</li>
<li>事件对象：通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作。</li>
</ol>
]]></content>
    </entry>
</feed>