<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-03-03T01:12:19.046Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>In the darkest night,Rising like a spire.</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[Math  题43:	整数中1出现的次数[未做出]]]></title>
        <id>https://lixin-scut.github.io//post/math-ti-43-zheng-shu-zhong-1-chu-xian-de-ci-shu-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/math-ti-43-zheng-shu-zhong-1-chu-xian-de-ci-shu-wei-zuo-chu">
        </link>
        <updated>2020-03-03T00:53:59.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>输入一个整数n，求1~n这n个整数的十进制表示中1出现的次数。例如，输入12, 1〜12这些整数中包含1的数字有1、10、11和12,共出现了5次。</p>
</blockquote>
<p>  一开始把题目看成了统计当前数字中的1....<br>
  暴力法比较麻烦的是不仅要循环递增数字，还要循环数字本身，数字一旦大了时间复杂度就爆炸了<br>
  然后就是书中的规律法，比较有趣，就是使用逐位计算，需要注意的就是</p>
<ol>
<li>位数为1时的处理</li>
<li>最高位为1的次数需要额外+1</li>
<li>剩余位需要-2（当前位和最高位），理解为何剩余位可以取0-9而不是除去1或者只能取到当前最大值</li>
</ol>
<pre><code>class Solution {
public:
    //数学规律递归法【未做出】
    int NumberOf1Between1AndN_Solution(int n)
    {
        if(n&lt;1)
            return 0;
        string ns=to_string(n);
        int length=ns.size();
        int count=0;
        for(auto i:ns){
            count+=count_one(i-'0',length,n);
            --length;
        }
        return count;
    }
    
    int count_one(int i,int bit,int &amp;n){
        int count=0;
        if(i==0&amp;&amp;bit==1)
            return 0;
        if(bit==1){
            return 1;
        }
        
        //最高位为1的次数
        if(i&gt;1)
            count+=pow(10,bit-1);
        else if(i==1)
            count+=n-1*pow(10,bit-1)+1;
        
        //剩余位数为1的次数 
        count+=i*(bit-1)*pow(10,bit-2);
        n-=i*pow(10,bit-1);
        return count;
    }
    
    
    /*
    //逐个数计算法
    int NumberOf1Between1AndN_Solution(int n)
    {
        if(n&lt;1)
            return 0;
        int count;
        count=0;
        for(int i=1;i&lt;=n;++i){
            count+=count_one(i);
        }
        return count;
    }
    
    int count_one(int n){
        int count=0;
        int temp;
        while(n&gt;0){
            temp=n%10;
            if(temp==1)
                ++count;
            n/=10;
        }
        return count;
    }
    */
};
</code></pre>
<p>书本题解：<br>
  最直观的方法, 也就是累加1〜n中每个整数1出现的次数。我们可以每次通过对10求余数判断整数的个位数字是不是1。如果这个数字大于10,则除以10之后再判断个位数字是不是1。<br>
  在上述思路中，我们对每个数字都要做除法和求余运算，以求出该数字中1出现的次数。如果输入数字n，n有O(logn)位，我们需要判断每一位是不是1,那么它的时间复杂度是O(nlogn)。当输入的n非常大的时候，需要大量的计算，运算效率不高。<br>
  如果希望不用计算每个数字的1的个数，那就只能去寻找1在数字中出现的规律了。为了找到规律，我们不妨用一个稍微大一点的数字如21345 作为例子来分析。我们把1〜21345的所有数字分为两段：一段是1〜1345： 另一段是1346〜21345。<br>
  我们先看1346〜21345中1出现的次数。1的出现分为两种情况。首先分析1出现在最高位(本例中是万位)的情况。在1346-21345的数字中， 1出现在10000〜19999这10000个数字的万位中，一共出现了10^4次。<br>
  值得注意的是，并不是对所有5位数而言在万位出现的次数都是10000 次。对于万位是1的数字如输入12345, 1只出现在10000-12345的万位, 出现的次数不是1次，而是2346次，也就是除去最高数字之后剩下的数字再加上1 (2345+1=2346次)。<br>
  接下来分析1出现在除最高位之外的其他4位数中的情况。例子中 1346〜21345这20000个数字中后4位中1出现的次数是8000次。由于最高位是2,我们可以再把1346〜21345分成两段：1346〜11345和11346〜21345,每一段剩下的4位数字中，选择其中一位是1，其余三位可以在0〜 9这10个数字中任意选择，因此根据排列组合原则，总共出现的次数是2X 4x10^3=8000 次。<br>
  至于在1〜1345中1出现的次数，我们就可以用递归求得了。这也是 我们为什么要把1〜21345分成1〜1345和1346-21345两段的原因。因为把21345的最高位去掉就变成1345,便于我们采用递归的思路。<br>
  这种思路是每次去掉最高位进行递归，递归的次数和位数相同。一个数字n有O(logn)位，因此这种思路的时间复杂度是O(logn),比前面的原始方法要好很多。</p>
<pre><code>int NumberOf1(unsigned int n);

int NumberOf1Between1AndN_Solution1(unsigned int n)
{
    int number = 0;

    for(unsigned int i = 1; i &lt;= n; ++ i)
        number += NumberOf1(i);

    return number;
}

int NumberOf1(unsigned int n)
{
    int number = 0;
    while(n)
    {
        if(n % 10 == 1)
            number ++;

        n = n / 10;
    }

    return number;
}

// ====================方法二====================
int NumberOf1(const char* strN);
int PowerBase10(unsigned int n);

int NumberOf1Between1AndN_Solution2(int n)
{
    if(n &lt;= 0)
        return 0;

    char strN[50];
    sprintf(strN, &quot;%d&quot;, n);

    return NumberOf1(strN);
}

int NumberOf1(const char* strN)
{
    if(!strN || *strN &lt; '0' || *strN &gt; '9' || *strN == '\0')
        return 0;

    int first = *strN - '0';
    unsigned int length = static_cast&lt;unsigned int&gt;(strlen(strN));

    if(length == 1 &amp;&amp; first == 0)
        return 0;

    if(length == 1 &amp;&amp; first &gt; 0)
        return 1;

    // 假设strN是&quot;21345&quot;
    // numFirstDigit是数字10000-19999的第一个位中1的数目
    int numFirstDigit = 0;
    if(first &gt; 1)
        numFirstDigit = PowerBase10(length - 1);
    else if(first == 1)
        numFirstDigit = atoi(strN + 1) + 1;

    // numOtherDigits是01346-21345除了第一位之外的数位中1的数目
    int numOtherDigits = first * (length - 1) * PowerBase10(length - 2);
    // numRecursive是1-1345中1的数目
    int numRecursive = NumberOf1(strN + 1);

    return numFirstDigit + numOtherDigits + numRecursive;
}

int PowerBase10(unsigned int n)
{
    int result = 1;
    for(unsigned int i = 0; i &lt; n; ++ i)
        result *= 10;

    return result;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 题42:连续子数组的最大和]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-ti-42lian-xu-zi-shu-zu-de-zui-da-he</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-ti-42lian-xu-zi-shu-zu-de-zui-da-he">
        </link>
        <updated>2020-03-03T00:31:57.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)<br>
例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。</p>
</blockquote>
<p>非常简单，就是如果max小于0的话说明它对当前值已经没有增益了，必须舍弃掉<br>
而大于等于0的话则值得继续加下去<br>
需要注意的点是必须把max和res初始化为INT_MIN，仅仅值初始化或者初始化为0的话如果整个数组都是负数的话会返回错误的结果<br>
然后这个条件判断最后可以转化为动态规划</p>
<pre><code>class Solution {
public:
    int FindGreatestSumOfSubArray(vector&lt;int&gt; array) {
        int max,res;
        max=INT_MIN;
        res=INT_MIN;
        for(auto num:array){
            /*
            if(max&lt;0)
                max=num;
            else
                max+=num;
             */
            max=num&gt;max+num?num:max+num;//动态规划
            res=res&gt;max?res:max;
        }
        return res;
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>动态规划法<br>
  如果算法的功底足够扎实，那么我们还可以用动态规划的思想来分析这个问题。如果用函数f(i)表示以第i个数字结尾的子数组的最大和，那么我们需要求出max[f(i)],<br>
  当以第i-1个数字结尾的子数组中所有数字的和小于0时，如果把这个负数与第，个数累加，则得到的结果比第i个数字本身还要小，所以这种情况下以第i个数字结尾的子数组就是第i个数字本身。如果以第i-1个数字结尾的子数组中所有数字的和大于0, 则与第i个数字累加就得到以第i个数字结尾的子数组中所有数字的和。<br>
  注意，虽然通常我们用递归的方式分析动态规划的问题，但最终都会基于循环去编码。<br>
  面试的时候我们要考虑无效的输入，如输入的数组参数为空指针、数 组长度小于等于0等情况。此时我们让函数返回什么数字？如果返回0,那我们又怎么区分子数组的和的最大值是0和无效输入这两种不同情况呢？ 因此，我们定义了一个全局变量来标记是否输入无效。</p>
</blockquote>
<pre><code>bool g_InvalidInput = false;

int FindGreatestSumOfSubArray(int *pData, int nLength)
{
    if((pData == nullptr) || (nLength &lt;= 0))
    {
        g_InvalidInput = true;
        return 0;
    }

    g_InvalidInput = false;

    int nCurSum = 0;
    int nGreatestSum = 0x80000000;
    for(int i = 0; i &lt; nLength; ++i)
    {
        if(nCurSum &lt;= 0)
            nCurSum = pData[i];
        else
            nCurSum += pData[i];

        if(nCurSum &gt; nGreatestSum)
            nGreatestSum = nCurSum;
    }

    return nGreatestSum;
} 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 题41:数据流的中位数]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-ti-41shu-ju-liu-de-zhong-wei-shu</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-ti-41shu-ju-liu-de-zhong-wei-shu">
        </link>
        <updated>2020-03-03T00:12:48.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p>
</blockquote>
<p>  这道题没啥好说的，其实是左大顶堆和右小顶堆的配合<br>
  主要就是要控制好两个堆的数量之差，相差不能超过1，并且必须有一个得是保存中心点的<br>
  然后就是注意每次插入都要手动更新min，不能指望客户每次插入都查询min，否则就会导致多次插入出现问题</p>
<p>  最坑的点就是！！！size()返回的是无符号数！！！一定要防止size()相减得到负数或者size()和负数比较！！！<br>
  否则无符号数和有符号数一起运算时，有符号数强行转化为无符号数，接着负数会强行转化为一个很大的正数，导致判断一直通过或者一直不通过</p>
<pre><code>class Solution {
public:
    void Insert(int num)
    {
        if(left_max.size()==0&amp;&amp;right_min.size()==0){
            left_max.push(num);
            mid=GetMedian();
            return;
        }
                
        if((double)num&lt;=mid)
            left_max.push(num);
        else
            right_min.push(num);
        if(left_max.size()&gt;right_min.size()+1){
            right_min.push(left_max.top());
            left_max.pop();
        }
        if(right_min.size()&gt;left_max.size()){
            left_max.push(right_min.top());
            right_min.pop();
        }
        mid=GetMedian();
    }

    double GetMedian()
    { 
        if(left_max.size()==0&amp;&amp;right_min.size()==0)
            return 0.0;
        if(left_max.size()==right_min.size())
            mid=static_cast&lt;double&gt;(left_max.top()+right_min.top())/2;
        else 
            mid=static_cast&lt;double&gt;(left_max.top());
        return mid;
    }

private:
    priority_queue&lt;int&gt; left_max;
    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; right_min;
    double mid;
};
</code></pre>
<p>书本题解<br>
<img src="https://lixin-scut.github.io//post-images/1583195223562.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1583195244385.png" alt=""></p>
<blockquote>
<p>  我们注意到整个数据容器被分隔成两部分。位于容器左边部分的数据比右边的数据小。另外，P1指向的数据是左边部分最大的数，P2指向的数据是左边部分最小的数。<br>
  如果能够保证数据容器左边的数据都小于右边的数据，那么即使左、 右两边内部的数据没有排序，也可以根据左边最大的数及右边最小的数得 到中位数。如何快速从一个数据容器中找出最大数？用最大堆实现这个数据容器，因为位于堆顶的就是最大的数据。同样，也可以快速从最小堆中找出最小数。<br>
  因此，可以用如下思路来解决这个问题：用一个最大堆实现左边的数据容器，用一个最小堆实现右边的数据容器。往堆中插入一个数据的时间 效率是O(logn)。由于只需要O(1)时间就可以得到位于堆顶的数据，因此得 到中位数的时间复杂度是O(1)。</p>
</blockquote>
<pre><code>template&lt;typename T&gt; class DynamicArray
{
public:
    void Insert(T num)
    {
        if(((min.size() + max.size()) &amp; 1) == 0)
        {
            if(max.size() &gt; 0 &amp;&amp; num &lt; max[0])
            {
                max.push_back(num);
                push_heap(max.begin(), max.end(), less&lt;T&gt;());

                num = max[0];

                pop_heap(max.begin(), max.end(), less&lt;T&gt;());
                max.pop_back();
            }

            min.push_back(num);
            push_heap(min.begin(), min.end(), greater&lt;T&gt;());
        }
        else
        {
            if(min.size() &gt; 0 &amp;&amp; min[0] &lt; num)
            {
                min.push_back(num);
                push_heap(min.begin(), min.end(), greater&lt;T&gt;());

                num = min[0];

                pop_heap(min.begin(), min.end(), greater&lt;T&gt;());
                min.pop_back();
            }

            max.push_back(num);
            push_heap(max.begin(), max.end(), less&lt;T&gt;());
        }
    }

    T GetMedian()
    {
        int size = min.size() + max.size();
        if(size == 0)
            throw exception(&quot;No numbers are available&quot;);

        T median = 0;
        if((size &amp; 1) == 1)
            median = min[0];
        else
            median = (min[0] + max[0]) / 2;

        return median;
    }

private:
    vector&lt;T&gt; min;
    vector&lt;T&gt; max;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[归并排序]]></title>
        <id>https://lixin-scut.github.io//post/gui-bing-pai-xu</id>
        <link href="https://lixin-scut.github.io//post/gui-bing-pai-xu">
        </link>
        <updated>2020-03-02T18:21:50.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://lixin-scut.github.io/post/pai-xu-suan-fa/">排序算法及其实现</a></p>
<p>  归并排序(Merging Sort)就是利用归并的思想实现的排序方法。它的原理是假设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1,然后两两归并，得到「n/2」(「x」表示不小于x的最小整数)个长度为2或1的有序子序列;再两两归并，......，<br>
  如此重复，直至得到一个长度为n的有序序列为止，这种排序方法称为2路归并排序。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[堆排序]]></title>
        <id>https://lixin-scut.github.io//post/dui-pai-xu</id>
        <link href="https://lixin-scut.github.io//post/dui-pai-xu">
        </link>
        <updated>2020-03-02T17:36:14.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://lixin-scut.github.io/post/pai-xu-suan-fa/">排序算法及其实现</a></p>
<p>  其实以前我已经写过一次堆排序了（<a href="https://lixin-scut.github.io/post/dui-pai-xu-shi-xian/">堆排序实现</a>），这次就当作是复习和优化了</p>
<p>  堆排序（Heap Sort)就是利用堆（假设利用大顶堆）进行排序的方法。它的基本思想是， 将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根结点。将它移走 （其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的次小值。如此反复执行，便能得到一个有序序列了。</p>
<pre><code>class HeapSort
{
public:
    void HeapSort0(vector&lt;int&gt; &amp;numbers);

private:
    void HeapAdjust(int loc,vector&lt;int&gt; &amp;numbers, int end);
};

void HeapSort::HeapSort0(vector&lt;int&gt; &amp;numbers)
{
    int len = numbers.size();

    // build a heap first;
    for(int loc = len/2; loc &gt;= 0; --loc)
    {
        HeapAdjust(loc,numbers,len-1);
    }

    for(int loc = len-1; loc &gt; 0; --loc)
    {
        swap(numbers[loc],numbers[0]);
        HeapAdjust(0, numbers, loc-1);
    }
    print(numbers);
}


void HeapSort::HeapAdjust(int loc,
                          vector&lt;int&gt; &amp;numbers,
                          int end)
{
    int temp;
    int j;
    temp = numbers[loc];
    for(j = loc*2+1; j&lt;=end; j = j*2+1)
    {
        if(j&lt;end &amp;&amp; numbers[j] &lt; numbers[j+1])
        { ++j; }

        if(temp&gt;numbers[j])
        { break; }

        numbers[(j-1)/2] = numbers[j];
    }
    numbers[(j-1)/2] = temp;
}
</code></pre>
<p>  在实现的过程中有个问题就是下标问题，堆排序原来的性质是按下标1开始算的（例如当前节点的父节点下标为floor(loc/2)），但是C++的容器下标从0开始，所以就需要相应地+1或者-1。</p>
<p>  整个排序过程分为两个for循环。第一个循环要完成的就是将现在的待排序序列构建成一个大顶堆。第二个循环要完成的就是逐步将每个最大值的根结点与末尾元素交换，并且再调整其成为大顶堆。<br>
  所以注意！！！第一个循环后并非是有序顺序，大顶堆和二叉树不同，并非左子树的节点都小于右子树</p>
<p>  循环从(length-1)/2开始是因为从1到(length-1)/2都是有孩子的节点<br>
  我们所谓的将待排序的序列构建成为一个大顶堆，其实就是从下往上、从右到左，将每个非终端结点（非叶结点）当作根结点，将其和其子树调整成大顶堆</p>
<h3 id="堆排序复杂度分析">堆排序复杂度分析</h3>
<p>  运行时间主要是消耗在初始构建堆和在重建堆时的反复筛选上。<br>
  在构建堆的过程中，因为我们是完全二叉树从最下层最右边的非终端结点开始构 建，将它与其孩子进行比较和若有必要的互换，对于每个非终端结点来说，其实最多进行两次比较和互换操作，因此整个构建堆的时间复杂度为o(n)。<br>
  在正式排序时，第i次取堆顶记录重建堆需要用O(logi)的时间（完全二叉树的某个结点到根结点的距离为floor(logi)+1,并且需要取n-1次堆顶记录，因此，重建堆的时间复杂度为〇(nlogn)<br>
  所以总体来说，堆排序的时间复杂度为〇(nlogn)。由于堆排序对原始记录的排序状态并不敏感，因此它无论是最好、最坏和平均时间复杂度均为〇(nlogn)。<br>
  空间复杂度上，它只有一个用来交换的暂存单元，也非常的不错。<br>
  不过由于记录的比较与交换是跳跃式进行，因此堆排序也是一种<strong>不稳定的排序</strong>方法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[多线程日志]]></title>
        <id>https://lixin-scut.github.io//post/duo-xian-cheng-ri-zhi</id>
        <link href="https://lixin-scut.github.io//post/duo-xian-cheng-ri-zhi">
        </link>
        <updated>2020-03-02T13:25:18.000Z</updated>
        <content type="html"><![CDATA[<p>故障诊断和追踪<br>
日志库是单例模式<br>
muduo日志库是C++ stream风格，但没用iostream，而是自己写了logstream class<br>
日志需要有设置级别的功能<br>
日志的目的地只有本地，不要往网络传日志<br>
日志应该有rolling功能，主要由文件大小和时间来区分<br>
日志文件名：进程名+时间+机器名+进程id+后缀.log<br>
防止程序崩溃1.定期flush 2.在内存中的日志消息都有cookie，值为某个函数地址<br>
日志消息格式是固定的，不需要通过运行时配置<br>
要点 1.每条日志只占1行 2.时间戳精确到微妙 gettimeofday 3.保证同一时区 4.打印线程id 5.打印日志级别 6.打印源文件名和行号<br>
每行日志的前四个字段的宽度是固定的 以空格分隔 便于分析，避免出现正则表达式的元字符<br>
优化：<br>
1.日期和时间都是缓存的<br>
2.前四个字段是定长的，避免运行时求长度<br>
3.线程id预先格式化为字符串 4.源文件名部分采用编译器计算<br>
多线程异步日志：使用一个背景线程来收集日志信息，其他业务线程往这个线程发送日志消息<br>
双缓冲技术 使用两个buffer 分为前段接收和后端写入<br>
实际上有四个缓冲区</p>
<p>日志通常用于故障诊断 和追踪(trace) ,也可用于性能分析。</p>
<p>日志通常要记录</p>
<ol>
<li>收到的每条内部消息的id (还可以包括关键字段、长度、hash等);</li>
<li>收到的每条外部消息的全文；</li>
<li>发出的每条消息的全文，每条消息都有全局唯一的id；</li>
<li>关键内部状态的变更。</li>
</ol>
<p>每条日志都有时间戳</p>
<p>一个日志库大体可分为前端(frontend)和后端(backend)两部分。前端是供应用程序使用的接口(API),并生成日志消息(log message)；后端则负责把日志 消息写到目的地(destination)。这两部分的接口有可能简单到只有一个回调函数：<br>
void output(const char* message, int len);<br>
其中的message字符串是一条完整的日志消息，包含日志级别、时间戳、源文件位 置、线程id等基本字段，以及程序输出的具体消息内容。<br>
在多线程程序中，前端和后端都与单线程程序无甚区别，无非是每个线程有自己 的前端，整个程序共用一个后端。但难点在于将日志数据从多个前端高效地传输到后 端尢这是一个典型的多生产者-单消费者问题，对生产者(前端)而言，要尽量做 到低延迟、低CPU开销、无阻塞；对消费者(后端)而言，要做到足够大的吞吐量, 并占用较少资源。</p>
<p>常规的通用日志库如log4j 13/logback 14通常会提供丰富的功能，但这些功能不 一定全都是必需的C</p>
<ol>
<li>日志消息有多种级别（level ）,如 TRACE. DEBUG、INFO、WARN、ERROR. FATAL 等。</li>
<li>日志消息可能有多个目的地（appender ）,如文件、socket、SMTP等。</li>
<li>日志消息的格式可配置（layout）,例如 org. apache. Iog4 j . PatternLayouto</li>
<li>可以设置运行时过滤器（filter）,控制不同组件的日志消息的级别和目的地。<br>
在上面这几项中，除了第一项之外，其余三项都是非必需的功能。<br>
日志的输出级别在运行时可调，这样同一个可执行文件可以分别在QA测试环境 的时候输出DEBUG级别的日志，在生产环境输出INFO级别的日志15。在必要的时候也 可以临时在线调整日志的输出级别。例如某台机器的消息量过大、日志文件太多、磁 盘空间紧张，那么可以临时调整为WARNING级别输出，减少日志数目。又比如某个新 上线的进程的行为略显古怪，则可以临时调整为DEBUG级别输出，打印更细节的日志 消息以便分析查错。调整日志的输出级别不需要重新编译，也不需要重启进程，只要 调用 muduo::Logger::setLogLevel（）就能即时生效。<br>
对于分布式系统中的服务进程而言，日志的目的地（destination ）只有一个：本 地文件。往网络写日志消息是不靠谱的，因为诊断日志的功能之一正是诊断网络故 障，往网络写日志消 息的另一个坏处是增加网络带宽消耗。同理应 该避免往网络文件系统（例如NFS）上写日志，<br>
以本地文件为日志的destination,那么日志文件的滚动（rolling ）是必需的，这 样可以简化日志归档（archive）的实现。rolling的条件通常有两个：文件大小（例 如每写满1GB就换下一个文件）和时间（例如每天零点新建一个日志文件，不论前 一个文件有没有写满）。muduo日志库的LogFile会自动根据文件大小和时间来主动 滚动日志文件。既然能主动rolling, fl然也就不必支持SIGUSR1 了，毕竟多线程程序 处理signal很麻烦<br>
一个典型的日志文件的文件名如下：<br>
logfile_test.2012060-144022.hostname.3605.log<br>
文件名由以下几部分组成：<br>
•第1部分logfile.test是进程的名字。通常是main（）函数参数中argv[0]的 basename（3）,这样容易区分究竟是哪个服务程序的日志。必要时还可以把程序 版本加进去。<br>
•第2部分是文件的创建时间（GMT时区）。这样很容易通过文件名来选择某一 时间范围内的日志，例如用通配符*.20120603-14<em>表示2012年6月3日下午2 点（GMT ）左右的日志文件（s）o<br>
•第3部分是机器名称。这样即便把日志文件拷贝到别的机器上也能追溯其来源。<br>
•第4部分是进程id。如果一个程序一秒之内反复重启，那么每次都会生成不同 的日志文件，参考§9.4。<br>
•第5部分是统一的后缀名.logo同样是为了便于周边配套脚本的编写。<br>
muduo的日志文件滚动没有采用文件改名的办法，即dmesg.log是最新日志, dmesg.log.l是前一个口志，dmesg.Log.2.gz是更早的口志等。这种做法的一个好处是 dmesglog始终是最新日志，便于编写某些及时解析日志的脚本。将来可以增加一个功 能，每次滚动日志文件之后立刻创建（更新）一个symlink, logMe.test.log始终指向当 前最新的日志文件，这样达到相同的效果。<br>
往文件写日志的一个常见问题是，万一程序崩溃，那么最后若干条日志往往就 丢失了，因为日志库不能每条消息都flush硬盘，更不能每条日志都open/close文 件，这样性能开销太大。muduo日志库用两个办法来应对这一点，其一是定期（默 认3秒）将缓冲区内的日志消息flush到硬盘；其二是每条内存中的日志消息都带有 cookie （或者叫哨兵值/sentry ）,其值为某个函数的地址，这样通过在core dump文 件中查找cookie 就能找到尚未来得及写入磁盘的消息。<br>
日志消息的格式是固定的，不需要运行时配置，这样可节省每条日志解析格式字 符串的开销。我认为日志的格式在项目的整个生命周期几乎不会改变，因为我们经常 会为不同目的编写parse H志的脚本，既要解析最近几天的日志文件，也要和几个月 之前，甚至一年之前的日志文件的同类数据做对比。如果在此期间日志格式变了，势 必会增加很多无谓的工作量。如果真的需要调整消息格式，直接修改代码并重新编译<br>
日志消息格式有几个要点:<br>
•尽量每条日志占一行。这样很容易用awk、sed、grep等命令行工具来快速联机 分析日志，比方说要查看&quot;2012-06-03 08:02:00° 至&quot;2012-06-03 08:02:59&quot;这 1 分钟内每秒打印日志的条数（直方图），可以运行 $ grep -o ，A20120603 08:02:..1 | sort | uniq -c<br>
•时间戳精确到微秒。每条消息都通过gettimeofday（2）获得当前时间，这么做 不会有什么性能损失。因为在x86-64 Linux ±, gettimeofday（2）不是系统调 用，不会陷入内核<br>
•始终使用GMT时区（Z）。对于跨洲的分布式系统而言，可省去本地时区转换 的麻烦（别忘了主要西方国家大多实行夏令时），更易于追杳事件的顺序。<br>
•打印线程id。便于分析多线程程序的时序，也可以检测死锁I</em>这里的线程id 是指调用LOG_INFO «的线程，线程id的获取见§4.3 o<br>
•打印日志级别。在线查错的时候先看看有无ERROR日志，通常可加速定位问题。<br>
•打印源文件名和行号。修复bug的时候不至于搞错对象。<br>
每行日志的前4个字段的宽度是固定的，以空格分隔，便于用脚本解析。另 外，应该避免在日志格式（特别是消息id 20）中出现正则表达式的元字符（meta character）,例如’［，和）等等，这样在用less（l）查看日志文件的时候查找字符 串更加便捷。</li>
</ol>
<p>性能需求<br>
编写Linux服务端程序的时候，我们需要一个高效的日志库。只有日志库足够高 效，程序员才敢在代码中输出足够多的诊断信息，减小运维难度，提升效率。高效性 体现在几方面：<br>
•每秒写儿千上万条日志的时候没有明显的性能损失。<br>
•能应对一个进程产生大量日志数据的场景，例如IGB/mino<br>
•不阻塞正常的执行流程。<br>
•在多线程程序中，不造成争用（contention ）</p>
<p>为了实现这样的性能指标，muduo日志库的实现有几点优化措施值得一提：<br>
•时间戳字符串中的日期和时间两部分是缓存的，一秒之内的多条日志只需重新 格式化微秒部分雹。例如p. Ill出现的3条日志消息中，“20120603 08:02:46” 是复用的，每条日志只需要格式化微秒部分(“.125770Z”)。<br>
•日志消息的前4个字段是定长的，因此可以避免在运行期求字符串长度(不会 反复调用strlen      )o因为编译器认识memcpy()函数，对于定长的内存复制, 会在编译期把它inline展开为高效的目标代码。<br>
•线程id是预先格式化为字符串，在输出日志消息时只需简单拷贝几个字节。见 CurrentThread::tidString()o<br>
•每行日志消息的源文件名部分采用了编译期计算来获得basename,避免运行 期strrchr(3)开销。见SourceFile class,这里利用了 gcc的内置函数。</p>
<p>多线程异步日志<br>
多线程程序对日志库提出了新的需求：线程安全，即多个线程可以并发写日志, 两个线程的日志消息不会出现交织。线程安全不难办到，简单的办法是用一个全局 mutex保护IO,或者每个线程单独写一个日志文件”，但这两种做法的高效性就堪 忧了。前者会造成全部线程抢一个锁，后者有可能让业务线程阻塞在写磁盘操作上。<br>
解决办法不难想到，用一个背景线程负责收集日志消息，并写入日志文件, 其他业务线程只管往这个“日志线程”发送日志消息，这称为“异步日志”。<br>
在多线程服务程序中，异步日志（叫“非阻塞日志”似乎更准确）是必需的，因 为如果在网络IO线程或业务线程中直接往磁盘写数据的话，写操作偶尔口J能阻塞长 达数秒之久</p>
<p>我们需要一个“队列”来将日志前端的数据传送到后端（日志线程），但这个 “队列”不必是现成的BlockingQueue<a href="std::string">std::string</a>,因为不用每次产生一条日志消 息都通知（notify（））接收方。<br>
muduo日志库采用的是双缓冲（double buffering ）技术吃 基本思路是准备两 块buffer： A和B,前端负责往buffer A填数据（日志消息）,后端负责将buffer B 的数据写入文件。当buffer A写满之后，交换A和B,让后端将buffer A的数据写 入文件，而前端则往buffer B填入新的日志消息，如此往复。用两个buffer的好处是 在新建日志消息的时候不必等待磁盘文件操作，也避免每条新日志消息都触发（唤 醒）后端日志线程。换言之，前端不是将一条条日志消息分别传送给后端，而是将多 条日志消息拼成一个大的buffer传送给后端，相当于批处理，减少了线程唤醒的频 度，降低开销。另外，为了及时将日志消息写入文件，即便buffer A未满，日志库也 会每3秒执行一次上述交换写入操作。</p>
<p>关键代码<br>
实际实现采用了四个缓冲区，这样可以进一步减少或避免日志前端的等待。数据 结构如下(muduo/base/AsyncLogging.h )：<br>
typedef boost::ptr_vector<LargeBuffer><br>
typedef BufferVector::auto^type</p>
<p>其中，LargeBuffer 类型是 FixedBuffer class template 的一份具体实现(instantiation ),其大小为4MB,可以存至少1000条日志消息o boost::ptr_vector<T>::auto_type 类型类似C++11中的std: :unique_ptr,具备移动语义(move semantics ),而且能自 动管理对象生命期。mutex.用于保护后面的四个数据成员。buffers.存放的是供后端 写入的buffero</p>
<p>前端在生成一条日志消息的时候会调用AsyncLogging::append()o在这个函数中, 如果当前缓冲(currentBuffer,)剩余的空间足够大(£31),则会直接把日志消息拷贝(追加)到当前缓冲中(C33),这是最常见的情况。这里拷贝一条日志消息并不会 带来多大开销(p.120)。前后端代码的其余部分都没有拷贝，而是简单的指针交换。</p>
<p>否则，说明当前缓冲已经写满，就把它送入(移入)buffers一(£37),并试图把 预备好的另一块缓冲(nextBuffer_ )移用(move )为当前缓冲(£39~£42 ),然后追加 日志消息并通知(唤醒)后端开始写入日志数据(£47〜£48 )。以上两种情况在临界区 之内都没有耗时的操作，运行时间为常数。<br>
如果前端写入速度太快，一下子把两块缓冲都用完了，那么只好分配一块新的 buffer,作为当前缓冲(£43~£46),这是极少发生的情况。</p>
<p>首先准备好两块空闲的buffer,以备在临界区内交换(C53、£54 )o在临界区内， 等待条件触发(£61〜£64),这里的条件有两个：其一是超时，其二是前端写满了一 个或多个buffero注意这里是非常规的condition variable用法，它没有使用while循 环，而且等待时间有上限。</p>
<pre><code>一开始先分配好四个缓冲区A、 B、C、D,前端和后端各持有其中两个。前端和后端各有一个缓冲区数组，初始时都 是空的。

万一前端陷入死循环，拼命发送日志消息，超过后端的处理（输出）能力，会导 致什么后果？对于同步日志来说，这不是问题，因为阻塞IO自然就限制了前端的写 入速度，起到了节流阀（throttling）的作用。但是对于异步日志来说，这就是典型的 生产速度高于消费速度问题，会造成数据在内存中堆积，严重时引发性能问题（可用 内存不足）或程序崩溃（分配内存失败）o
</code></pre>
<p>muduo H志库处理日志堆积的方法很简单：直接丢掉多余的日志buffer,以腾 出内存，见muduo/base/AsyncLogging.cc第87~96行代码。这样可以防止日志库本身引起 程序故障，是一种自我保护措施。将来或许可以加上网络报警功能，通知人工介入, 以尽快修复故障。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线程池与内存池]]></title>
        <id>https://lixin-scut.github.io//post/xian-cheng-chi-yu-nei-cun-chi</id>
        <link href="https://lixin-scut.github.io//post/xian-cheng-chi-yu-nei-cun-chi">
        </link>
        <updated>2020-03-02T09:36:43.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>为什么需要线程池<br>
大多数的网络服务器，包括Web服务器都具有一个特点，就是单位时间内必须处理数目巨大的连接请求，但是处理时间却是比较短的。在传统的多线程服务器模型中是这样实现的：一旦有个请求到达，就创建一个新的线程，由该线程执行任务，任务执行完毕之后，线程就退出。这就是”即时创建，即时销毁”的策略。尽管与创建进程相比，创建线程的时间已经大大的缩短，但是如果提交给线程的任务是执行时间较短，而且执行次数非常频繁，那么服务器就将处于一个不停的创建线程和销毁线程的状态。这笔开销是不可忽略的，尤其是线程执行的时间非常非常短的情况。</li>
<li>线程池原理<br>
在应用程序启动之后，就马上创建一定数量的线程，放入空闲的队列中。这些线程都是处于阻塞状态，这些线程只占一点内存，不占用CPU。当任务到来后，线程池将选择一个空闲的线程，将任务传入此线程中运行。当所有的线程都处在处理任务的时候，线程池将自动创建一定的数量的新线程，用于处理更多的任务。执行任务完成之后线程并不退出，而是继续在线程池中等待下一次任务。当大部分线程处于阻塞状态时，线程池将自动销毁一部分的线程，回收系统资源。</li>
<li>线程池的作用<br>
需要大量的线程来完成任务，且完成任务的时间比较短；对性能要求苛刻的应用；对性能要求苛刻的应用</li>
<li>内存池的原理<br>
在软件开发中，有些对象使用非常频繁，那么我们可以预先在堆中实例化一些对象，我们把维护这些对象的结构叫“内存池”。在需要用的时候，直接从内存池中拿，而不用从新实例化，在要销毁的时候，不是直接free/delete，而是返还给内存池。把那些常用的对象存在内存池中，就不用频繁的分配/回收内存，可以相对减少内存碎片，更重要的是实例化这样的对象更快，回收也更快。当内存池中的对象不够用的时候就扩容。</li>
<li>内存池的优缺点<br>
内存池对象不是线程安全的，在多线程编程中，创建一个对象时必须加锁。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[select、poll和epoll]]></title>
        <id>https://lixin-scut.github.io//post/selectpoll-he-epoll</id>
        <link href="https://lixin-scut.github.io//post/selectpoll-he-epoll">
        </link>
        <updated>2020-03-02T09:01:31.000Z</updated>
        <content type="html"><![CDATA[<h3 id="非阻塞io">非阻塞I/O</h3>
<p>阻塞和非阻塞最大的区别在于调用I/O系统调用后，是等整个I/O过程完成再把操作权限返回给用户还是会立即返回。</p>
<p>可以使用以下语句将句柄fd设置为非阻塞I/O：fcntl(fd, F_SETFL, O_NONBLOCK);</p>
<p>非阻塞I/O在调用后会立即返回，用户进程对返回的返回值判断以区分是否完成了I/O。如果返回大于0表示完成了数据读取，返回值即读取的字节数；返回0表示连接已经正常断开；返回-1表示错误，接下来用户进程会不停地询问kernel是否准备完毕。<br>
非阻塞I/O虽然不再会完全阻塞用户进程，但实际上由于用户进程需要不停地询问kernel是否准备完数据，所以整体效率依旧非常低，不适合做并发。</p>
<h3 id="io复用">I/O复用</h3>
<p>I/O复用模型会用到select、poll、epoll函数，这几个函数也会使进程阻塞，但是和阻塞I/O所不同的的，这三个函数可以同时阻塞多个I/O操作。而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时，才真正调用I/O操作函数。</p>
<ol>
<li>IO复用是Linux中的IO模型之一，IO复用就是进程预先告诉内核需要监视的IO条件，使得内核一旦发现进程指定的一个或多个IO条件就绪，就通过进程进程处理，从而不会在单个IO上阻塞了。Linux中，提供了select、poll、epoll三种接口函数来实现IO复用。</li>
<li>Select<br>
select的缺点：<br>
①	单个进程能够监视的文件描述符的数量存在最大限制，通常是1024。由于select采用轮询的方式扫描文件描述符，文件描述符数量越多，性能越差；<br>
②	内核/用户空间内存拷贝问题，select需要大量句柄数据结构，产生巨大开销；<br>
③	Select返回的是含有整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生事件；<br>
④	Select的触发方式是水平触发，应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作，那么每次select调用还会将这些文件描述符通知进程。</li>
<li>Poll<br>
与select相比，poll使用链表保存文件描述符，没有了监视文件数量的限制，但其他三个缺点依然存在</li>
<li>Epoll<br>
上面所说的select缺点在epoll上不复存在，epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。Epoll是事件触发的，不是轮询查询的。没有最大的并发连接限制，内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递。</li>
</ol>
<h3 id="区别总结">区别总结</h3>
<ol>
<li>支持一个进程所能打开的最大连接数<br>
①	Select最大1024个连接，最大连接数有FD_SETSIZE宏定义，其大小是32位整数表示，可以改变宏定义进行修改，可以重新编译内核，性能可能会影响；<br>
②	Poll没有最大连接限制，原因是它是基于链表来存储的；<br>
③	连接数限数有上限，但是很大；</li>
<li>FD剧增后带来的IO效率问题<br>
①	因为每次进行线性遍历，所以随着FD的增加会造成遍历速度下降，效率降低；<br>
②	Poll同上；<br>
③	因为epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的现象下降的性能问题。</li>
<li>消息传递方式<br>
①	Select内核需要将消息传递到用户空间，都需要内核拷贝；<br>
②	Poll同上；<br>
③	Epoll通过内核和用户空间共享来实现的。</li>
</ol>
<h3 id="epoll-的-lt-和-et-模式">epoll 的 LT 和 ET 模式</h3>
<p>epoll对文件描述符的操作有两种模式：LT(level trigger)和ET(edge trigger)，LT是默认模式。<br>
区别：<br>
LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。<br>
ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p>
<h3 id="补充资料">补充资料</h3>
<p>I/O多路复用（事件驱动模型）<br>
前面已经论述了多进程、多进程模型会因为开销巨大和调度困难而导致并不能承受高并发量。但不适用这种模型的话，无论是阻塞还是非阻塞方式都会导致整个服务器停滞。<br>
所以对于大并发量，我们需要一种代理模型可以帮助我们集中去管理所有的socket连接，一旦某个socket数据到达了就执行其对应的用户进程，I/O多路复用就是这么一种模型。Linux下I/O多路复用的系统调用有select，poll和epoll，但从本质上来讲他们都是同步I/O范畴。</p>
<p><strong>select</strong><br>
相关接口：</p>
<pre><code>int select (int maxfd, fd_set *readfds, fd_set *writefds, fd_set *errorfds, struct timeval *timeout);
FD_ZERO(int fd, fd_set* fds) //清空集合
FD_SET(int fd, fd_set* fds) //将给定的描述符加入集合
FD_ISSET(int fd, fd_set* fds) //将给定的描述符从文件中删除
FD_CLR(int fd, fd_set* fds) //判断指定描述符是否在集合中
</code></pre>
<p>参数：<br>
maxfd：当前最大文件描述符的值+1（≠ MAX_CONN）。<br>
readfds：指向读文件队列集合（fd_set）的指针。<br>
writefds：同上，指向读集合的指针。<br>
writefds：同上，指向错误集合的指针。<br>
timeout：指向timeval结构指针，用于设置超时。<br>
其他：<br>
判断和操作对象为set_fd集合，集合大小为单个进程可打开的最大文件数1024或2048（可重新编译内核修改但不建议）。</p>
<p><strong>poll</strong><br>
相关接口：<code>int poll(struct pollfd *fds, unsigned int nfds, int timeout);</code><br>
结构体定义： s</p>
<pre><code>truct pollfd{ int fd; // 文件描述符 
short events; // 等到的事件 
short revents; // 实际发生的事件 
</code></pre>
<p>参数：<br>
fds：指向pollfd结构体数组的指针。<br>
nfds：pollfd数组当前已被使用的最大下标。<br>
timeout：等待毫秒数。<br>
其他：<br>
判断和操作对象是元素为pollfd类型的数组，数组大小自己设定，即为最大连接数。</p>
<p><strong>epoll</strong><br>
相关接口：</p>
<pre><code>int epoll_create(int size); // 创建epoll句柄 
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); // 事件注册函数 
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
</code></pre>
<p>结构体定义：<br>
<code>struct epoll_event { __uint32_t events; epoll_data_t data; }; typedef union epoll_data { void *ptr; int fd; __uint32_t u32; __uint64_t u64; }epoll_data_t;</code><br>
参数：<br>
size：用来告诉内核要监听的数目。<br>
epfd：epoll函数的返回值。<br>
op：表示动作（EPOLL_CTL_ADD/EPOLL_CTL_FD/EPOLL_CTL_DEL）。<br>
fd：需要监听的fd。<br>
events：指向epoll_event的指针，该结构记录监听的事件。<br>
maxevents：告诉内核events的大小。<br>
timeout：超时时间（ms为单位，0表示立即返回，-1将不确定）。<br>
select、poll和epoll区别</p>
<p>操作方式及效率：<br>
select是遍历，需要遍历fd_set每一个比特位（= MAX_CONN），O(n)；<br>
poll是遍历，但只遍历到pollfd数组当前已使用的最大下标（≠ MAX_CONN），O(n)；<br>
epoll是回调，O(1)。</p>
<p>最大连接数：<br>
select为1024/2048（一个进程打开的文件数是有限制的）；poll无上限；epoll无上限。</p>
<p>fd拷贝：<br>
select每次都需要把fd集合从用户态拷贝到内核态；<br>
poll每次都需要把fd集合从用户态拷贝到内核态；<br>
epoll调用epoll_ctl时拷贝进内核并放到事件表中，但用户进程和内核通过mmap映射共享同一块存储，避免了fd从内核赋值到用户空间。</p>
<p>其他：<br>
select每次内核仅仅是通知有消息到了需要处理，具体是哪一个需要遍历所有的描述符才能找到。<br>
epoll不仅通知有I/O到来还可通过callback函数具体定位到活跃的socket，实现伪AIO。</p>
<p>异步I/O模型<br>
上面三种I/O方式均属于同步I/O。<br>
从阻塞式I/O到非阻塞I/O，我们已经做到了调用I/O请求后立即返回，但不停轮询的操作效率又很低，如果能够既像非阻塞I/O能够立即返回又能不一直轮询的话会更符合我们的预期。<br>
之所以用户进程会不停轮询就是因为在数据准备完毕后内核不会回调用户进程，只能通过用户进程一次又一次轮询来查询I/O结果。如果内核能够在完成I/O后通过消息告知用户进程来处理已经得到的数据自然是最好的，异步I/O就是这么回事。<br>
异步I/O就是当用户进程发起I/O请求后立即返回，直到内核发送一个信号，告知进程I/O已完成，在整个过程中，都没有进程被阻塞。看上去异步I/O和非阻塞I/O的区别在于：判断数据是否准备完毕的任务从用户进程本身被委托给内核来完成。这里所谓的异步只是操作系统提供的一直机制罢了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[虚拟内存]]></title>
        <id>https://lixin-scut.github.io//post/xu-ni-nei-cun</id>
        <link href="https://lixin-scut.github.io//post/xu-ni-nei-cun">
        </link>
        <updated>2020-03-02T08:52:54.000Z</updated>
        <content type="html"><![CDATA[<h3 id="虚拟内存">虚拟内存</h3>
<ol>
<li>虚拟内存是一种内存管理技术，它会使程序自己认为自己拥有一块很大且连续的内存，然而，这个程序在内存中不是连续的，并且有些还会在磁盘上，在需要时进行数据交换;</li>
<li>优点：可以弥补物理内存大小的不足；一定程度的提高反应速度；减少对物理内存的读取从而保护内存延长内存使用寿命；</li>
<li>缺点：占用一定的物理硬盘空间；加大了对硬盘的读写；设置不得当会影响整机稳定性与速度。</li>
<li>虚拟地址空间是对于一个单一进程的概念，这个进程看到的将是地址从0000开始的整个内存空间。虚拟存储器是一个抽象概念，它为每一个进程提供了一个假象，好像每一个进程都在独占的使用主存。每个进程看到的存储器都是一致的，称为虚拟地址空间。从最低的地址看起：程序代码和数据，堆，共享库，栈，内核虚拟存储器。大多数计算机的字长都是32位，这就限制了虚拟地址空间为4GB。</li>
</ol>
<h3 id="分页和分段">分页和分段</h3>
<ol>
<li>页是信息的物理单位，分页是由于系统管理的需要。段是信息的逻辑单位，分段是为了满足用户的要求。</li>
<li>页的大小固定且由系统决定，段的长度不固定，决定于用户所编写的程序，通常由编译程序在对源程序紧进行编译时，根据信息的性质来划分。</li>
<li>分页的作业的地址空间是一维的，程序员只需要利用一个记忆符，即可表示一个地址。分段的作业地址空间则是二维的，程序员在标识一个地址时，既需要给出段名，又需要给出段的地址值。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[进程和线程、协程]]></title>
        <id>https://lixin-scut.github.io//post/jin-cheng-he-xian-cheng-xie-cheng</id>
        <link href="https://lixin-scut.github.io//post/jin-cheng-he-xian-cheng-xie-cheng">
        </link>
        <updated>2020-03-02T08:26:22.000Z</updated>
        <content type="html"><![CDATA[<h3 id="进程">进程</h3>
<ol>
<li>进程是指在系统中正在运行的一个应用程序，程序一旦运行就是进程；</li>
<li>进程可以认为是程序执行的一个实例，进程是系统进行资源分配的最小单位，且每个进程拥有独立的地址空间；</li>
<li>一个进程无法直接访问另一个进程的变量和数据结构，如果希望一个进程去访问另一个进程的资源，需要使用进程间的通信，比如：管道、消息队列等</li>
</ol>
<h3 id="线程">线程</h3>
<p>线程是进程的一个实体，是进程的一条执行路径；比进程更小的独立运行的基本单位，线程也被称为轻量级进程，一个程序至少有一个进程，一个进程至少有一个线程；同一进程内的所有线程共享相同的全局内存。</p>
<h3 id="进程和线程的区别">进程和线程的区别</h3>
<ol>
<li>同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间；</li>
<li>同一进程内的线程共享本进程的资源，但是进程之间的资源是独立的；</li>
<li>一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程崩溃，所以多进程比多线程健壮；</li>
<li>进程切换，消耗的资源大。所以涉及到频繁的切换，使用线程要好于进程；</li>
<li>两者均可并发执行；</li>
<li>每个独立的进程有一个程序的入口、程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li>
</ol>
<h3 id="父进程与子进程">父进程与子进程</h3>
<ol>
<li>fork之后，子进程会拷贝父进程的数据空间、堆和栈空间（实际上是采用写时复制技术），二者共享代码段。 所以在子进程中修改全局变量（局部变量，分配在堆上的内存同样也是）后，父进程的相同的全局变量不会改变。</li>
<li>共享文件描述符fd，以及fd对应的文件表项。</li>
</ol>
<h3 id="线程独占与共享的资源">线程独占与共享的资源</h3>
<p>同一进程内的所有线程除了共享全局变量外还共享：<br>
• 进程指令；<br>
• 大多数数据；<br>
• 打开的文件(即描述符)；<br>
• 信号处理函数和信号处置；<br>
• 当前工作目录；<br>
• 用户ID和组ID。</p>
<p>每个线程有各自的：<br>
• 线程ID<br>
• 寄存器集合，包括程序计数器和栈指针；<br>
• 栈(用于存放局部变量和返回地址)；<br>
•	errno<br>
• 信号掩码</p>
<h3 id="进程的状态">进程的状态</h3>
<ol>
<li>新状态：进程已经创建</li>
<li>就绪态：进程做好了准备，准备执行，等待分配处理机</li>
<li>执行态：该进程正在执行；</li>
<li>阻塞态：等待某事件发生才能执行，如等待I/O完成；</li>
<li>终止状态<br>
<img src="https://lixin-scut.github.io//post-images/1583138206954.png" alt=""></li>
</ol>
<h3 id="协程">协程</h3>
<ol>
<li>是一种比线程更加轻量级的存在。正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程；协程不是被操作系统内核管理，而完全是由程序所控制。</li>
<li>协程的开销远远小于线程；</li>
<li>协程拥有自己寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切换回来的时候，恢复先前保存的寄存器上下文和栈。</li>
<li>每个协程表示一个执行单元，有自己的本地数据，与其他协程共享全局数据和其他资源。</li>
<li>跨平台、跨体系架构、无需线程上下文切换的开销、方便切换控制流，简化编程模型；</li>
<li>协程又称为微线程，协程的完成主要靠yeild关键字，协程执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行；</li>
<li>协程极高的执行效率，和多线程相比，线程数量越多，协程的性能优势就越明显；</li>
<li>不需要多线程的锁机制；</li>
</ol>
]]></content>
    </entry>
</feed>