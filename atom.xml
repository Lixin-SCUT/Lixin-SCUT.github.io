<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-03-02T18:14:22.775Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>In the darkest night,Rising like a spire.</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[堆排序]]></title>
        <id>https://lixin-scut.github.io//post/dui-pai-xu</id>
        <link href="https://lixin-scut.github.io//post/dui-pai-xu">
        </link>
        <updated>2020-03-02T17:36:14.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://lixin-scut.github.io/post/pai-xu-suan-fa/">排序算法及其实现</a></p>
<p>  其实以前我已经写过一次堆排序了（<a href="https://lixin-scut.github.io/post/dui-pai-xu-shi-xian/">堆排序实现</a>），这次就当作是复习和优化了</p>
<p>  堆排序（Heap Sort)就是利用堆（假设利用大顶堆）进行排序的方法。它的基本思想是， 将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根结点。将它移走 （其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的次小值。如此反复执行，便能得到一个有序序列了。</p>
<pre><code>class HeapSort
{
public:
    void HeapSort0(vector&lt;int&gt; &amp;numbers);

private:
    void HeapAdjust(int loc,vector&lt;int&gt; &amp;numbers, int end);
};

void HeapSort::HeapSort0(vector&lt;int&gt; &amp;numbers)
{
    int len = numbers.size();

    // build a heap first;
    for(int loc = len/2; loc &gt;= 0; --loc)
    {
        HeapAdjust(loc,numbers,len-1);
    }

    for(int loc = len-1; loc &gt; 0; --loc)
    {
        swap(numbers[loc],numbers[0]);
        HeapAdjust(0, numbers, loc-1);
    }
    print(numbers);
}


void HeapSort::HeapAdjust(int loc,
                          vector&lt;int&gt; &amp;numbers,
                          int end)
{
    int temp;
    int j;
    temp = numbers[loc];
    for(j = loc*2+1; j&lt;=end; j = j*2+1)
    {
        if(j&lt;end &amp;&amp; numbers[j] &lt; numbers[j+1])
        { ++j; }

        if(temp&gt;numbers[j])
        { break; }

        numbers[(j-1)/2] = numbers[j];
    }
    numbers[(j-1)/2] = temp;
}
</code></pre>
<p>  在实现的过程中有个问题就是下标问题，堆排序原来的性质是按下标1开始算的（例如当前节点的父节点下标为floor(loc/2)），但是C++的容器下标从0开始，所以就需要相应地+1或者-1。</p>
<p>  整个排序过程分为两个for循环。第一个循环要完成的就是将现在的待排序序列构建成一个大顶堆。第二个循环要完成的就是逐步将每个最大值的根结点与末尾元素交换，并且再调整其成为大顶堆。<br>
  所以注意！！！第一个循环后并非是有序顺序，大顶堆和二叉树不同，并非左子树的节点都小于右子树</p>
<p>  循环从(length-1)/2开始是因为从1到(length-1)/2都是有孩子的节点<br>
  我们所谓的将待排序的序列构建成为一个大顶堆，其实就是从下往上、从右到左，将每个非终端结点（非叶结点）当作根结点，将其和其子树调整成大顶堆</p>
<h3 id="堆排序复杂度分析">堆排序复杂度分析</h3>
<p>  运行时间主要是消耗在初始构建堆和在重建堆时的反复筛选上。<br>
  在构建堆的过程中，因为我们是完全二叉树从最下层最右边的非终端结点开始构 建，将它与其孩子进行比较和若有必要的互换，对于每个非终端结点来说，其实最多进行两次比较和互换操作，因此整个构建堆的时间复杂度为o(n)。<br>
  在正式排序时，第i次取堆顶记录重建堆需要用O(logi)的时间（完全二叉树的某个结点到根结点的距离为floor(logi)+1,并且需要取n-1次堆顶记录，因此，重建堆的时间复杂度为〇(nlogn)<br>
  所以总体来说，堆排序的时间复杂度为〇(nlogn)。由于堆排序对原始记录的排序状态并不敏感，因此它无论是最好、最坏和平均时间复杂度均为〇(nlogn)。<br>
  空间复杂度上，它只有一个用来交换的暂存单元，也非常的不错。<br>
  不过由于记录的比较与交换是跳跃式进行，因此堆排序也是一种<strong>不稳定的排序</strong>方法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[多线程日志]]></title>
        <id>https://lixin-scut.github.io//post/duo-xian-cheng-ri-zhi</id>
        <link href="https://lixin-scut.github.io//post/duo-xian-cheng-ri-zhi">
        </link>
        <updated>2020-03-02T13:25:18.000Z</updated>
        <content type="html"><![CDATA[<p>故障诊断和追踪<br>
日志库是单例模式<br>
muduo日志库是C++ stream风格，但没用iostream，而是自己写了logstream class<br>
日志需要有设置级别的功能<br>
日志的目的地只有本地，不要往网络传日志<br>
日志应该有rolling功能，主要由文件大小和时间来区分<br>
日志文件名：进程名+时间+机器名+进程id+后缀.log<br>
防止程序崩溃1.定期flush 2.在内存中的日志消息都有cookie，值为某个函数地址<br>
日志消息格式是固定的，不需要通过运行时配置<br>
要点 1.每条日志只占1行 2.时间戳精确到微妙 gettimeofday 3.保证同一时区 4.打印线程id 5.打印日志级别 6.打印源文件名和行号<br>
每行日志的前四个字段的宽度是固定的 以空格分隔 便于分析，避免出现正则表达式的元字符<br>
优化：<br>
1.日期和时间都是缓存的<br>
2.前四个字段是定长的，避免运行时求长度<br>
3.线程id预先格式化为字符串 4.源文件名部分采用编译器计算<br>
多线程异步日志：使用一个背景线程来收集日志信息，其他业务线程往这个线程发送日志消息<br>
双缓冲技术 使用两个buffer 分为前段接收和后端写入<br>
实际上有四个缓冲区</p>
<p>日志通常用于故障诊断 和追踪(trace) ,也可用于性能分析。</p>
<p>日志通常要记录</p>
<ol>
<li>收到的每条内部消息的id (还可以包括关键字段、长度、hash等);</li>
<li>收到的每条外部消息的全文；</li>
<li>发出的每条消息的全文，每条消息都有全局唯一的id；</li>
<li>关键内部状态的变更。</li>
</ol>
<p>每条日志都有时间戳</p>
<p>一个日志库大体可分为前端(frontend)和后端(backend)两部分。前端是供应用程序使用的接口(API),并生成日志消息(log message)；后端则负责把日志 消息写到目的地(destination)。这两部分的接口有可能简单到只有一个回调函数：<br>
void output(const char* message, int len);<br>
其中的message字符串是一条完整的日志消息，包含日志级别、时间戳、源文件位 置、线程id等基本字段，以及程序输出的具体消息内容。<br>
在多线程程序中，前端和后端都与单线程程序无甚区别，无非是每个线程有自己 的前端，整个程序共用一个后端。但难点在于将日志数据从多个前端高效地传输到后 端尢这是一个典型的多生产者-单消费者问题，对生产者(前端)而言，要尽量做 到低延迟、低CPU开销、无阻塞；对消费者(后端)而言，要做到足够大的吞吐量, 并占用较少资源。</p>
<p>常规的通用日志库如log4j 13/logback 14通常会提供丰富的功能，但这些功能不 一定全都是必需的C</p>
<ol>
<li>日志消息有多种级别（level ）,如 TRACE. DEBUG、INFO、WARN、ERROR. FATAL 等。</li>
<li>日志消息可能有多个目的地（appender ）,如文件、socket、SMTP等。</li>
<li>日志消息的格式可配置（layout）,例如 org. apache. Iog4 j . PatternLayouto</li>
<li>可以设置运行时过滤器（filter）,控制不同组件的日志消息的级别和目的地。<br>
在上面这几项中，除了第一项之外，其余三项都是非必需的功能。<br>
日志的输出级别在运行时可调，这样同一个可执行文件可以分别在QA测试环境 的时候输出DEBUG级别的日志，在生产环境输出INFO级别的日志15。在必要的时候也 可以临时在线调整日志的输出级别。例如某台机器的消息量过大、日志文件太多、磁 盘空间紧张，那么可以临时调整为WARNING级别输出，减少日志数目。又比如某个新 上线的进程的行为略显古怪，则可以临时调整为DEBUG级别输出，打印更细节的日志 消息以便分析查错。调整日志的输出级别不需要重新编译，也不需要重启进程，只要 调用 muduo::Logger::setLogLevel（）就能即时生效。<br>
对于分布式系统中的服务进程而言，日志的目的地（destination ）只有一个：本 地文件。往网络写日志消息是不靠谱的，因为诊断日志的功能之一正是诊断网络故 障，往网络写日志消 息的另一个坏处是增加网络带宽消耗。同理应 该避免往网络文件系统（例如NFS）上写日志，<br>
以本地文件为日志的destination,那么日志文件的滚动（rolling ）是必需的，这 样可以简化日志归档（archive）的实现。rolling的条件通常有两个：文件大小（例 如每写满1GB就换下一个文件）和时间（例如每天零点新建一个日志文件，不论前 一个文件有没有写满）。muduo日志库的LogFile会自动根据文件大小和时间来主动 滚动日志文件。既然能主动rolling, fl然也就不必支持SIGUSR1 了，毕竟多线程程序 处理signal很麻烦<br>
一个典型的日志文件的文件名如下：<br>
logfile_test.2012060-144022.hostname.3605.log<br>
文件名由以下几部分组成：<br>
•第1部分logfile.test是进程的名字。通常是main（）函数参数中argv[0]的 basename（3）,这样容易区分究竟是哪个服务程序的日志。必要时还可以把程序 版本加进去。<br>
•第2部分是文件的创建时间（GMT时区）。这样很容易通过文件名来选择某一 时间范围内的日志，例如用通配符*.20120603-14<em>表示2012年6月3日下午2 点（GMT ）左右的日志文件（s）o<br>
•第3部分是机器名称。这样即便把日志文件拷贝到别的机器上也能追溯其来源。<br>
•第4部分是进程id。如果一个程序一秒之内反复重启，那么每次都会生成不同 的日志文件，参考§9.4。<br>
•第5部分是统一的后缀名.logo同样是为了便于周边配套脚本的编写。<br>
muduo的日志文件滚动没有采用文件改名的办法，即dmesg.log是最新日志, dmesg.log.l是前一个口志，dmesg.Log.2.gz是更早的口志等。这种做法的一个好处是 dmesglog始终是最新日志，便于编写某些及时解析日志的脚本。将来可以增加一个功 能，每次滚动日志文件之后立刻创建（更新）一个symlink, logMe.test.log始终指向当 前最新的日志文件，这样达到相同的效果。<br>
往文件写日志的一个常见问题是，万一程序崩溃，那么最后若干条日志往往就 丢失了，因为日志库不能每条消息都flush硬盘，更不能每条日志都open/close文 件，这样性能开销太大。muduo日志库用两个办法来应对这一点，其一是定期（默 认3秒）将缓冲区内的日志消息flush到硬盘；其二是每条内存中的日志消息都带有 cookie （或者叫哨兵值/sentry ）,其值为某个函数的地址，这样通过在core dump文 件中查找cookie 就能找到尚未来得及写入磁盘的消息。<br>
日志消息的格式是固定的，不需要运行时配置，这样可节省每条日志解析格式字 符串的开销。我认为日志的格式在项目的整个生命周期几乎不会改变，因为我们经常 会为不同目的编写parse H志的脚本，既要解析最近几天的日志文件，也要和几个月 之前，甚至一年之前的日志文件的同类数据做对比。如果在此期间日志格式变了，势 必会增加很多无谓的工作量。如果真的需要调整消息格式，直接修改代码并重新编译<br>
日志消息格式有几个要点:<br>
•尽量每条日志占一行。这样很容易用awk、sed、grep等命令行工具来快速联机 分析日志，比方说要查看&quot;2012-06-03 08:02:00° 至&quot;2012-06-03 08:02:59&quot;这 1 分钟内每秒打印日志的条数（直方图），可以运行 $ grep -o ，A20120603 08:02:..1 | sort | uniq -c<br>
•时间戳精确到微秒。每条消息都通过gettimeofday（2）获得当前时间，这么做 不会有什么性能损失。因为在x86-64 Linux ±, gettimeofday（2）不是系统调 用，不会陷入内核<br>
•始终使用GMT时区（Z）。对于跨洲的分布式系统而言，可省去本地时区转换 的麻烦（别忘了主要西方国家大多实行夏令时），更易于追杳事件的顺序。<br>
•打印线程id。便于分析多线程程序的时序，也可以检测死锁I</em>这里的线程id 是指调用LOG_INFO «的线程，线程id的获取见§4.3 o<br>
•打印日志级别。在线查错的时候先看看有无ERROR日志，通常可加速定位问题。<br>
•打印源文件名和行号。修复bug的时候不至于搞错对象。<br>
每行日志的前4个字段的宽度是固定的，以空格分隔，便于用脚本解析。另 外，应该避免在日志格式（特别是消息id 20）中出现正则表达式的元字符（meta character）,例如’［，和）等等，这样在用less（l）查看日志文件的时候查找字符 串更加便捷。</li>
</ol>
<p>性能需求<br>
编写Linux服务端程序的时候，我们需要一个高效的日志库。只有日志库足够高 效，程序员才敢在代码中输出足够多的诊断信息，减小运维难度，提升效率。高效性 体现在几方面：<br>
•每秒写儿千上万条日志的时候没有明显的性能损失。<br>
•能应对一个进程产生大量日志数据的场景，例如IGB/mino<br>
•不阻塞正常的执行流程。<br>
•在多线程程序中，不造成争用（contention ）</p>
<p>为了实现这样的性能指标，muduo日志库的实现有几点优化措施值得一提：<br>
•时间戳字符串中的日期和时间两部分是缓存的，一秒之内的多条日志只需重新 格式化微秒部分雹。例如p. Ill出现的3条日志消息中，“20120603 08:02:46” 是复用的，每条日志只需要格式化微秒部分(“.125770Z”)。<br>
•日志消息的前4个字段是定长的，因此可以避免在运行期求字符串长度(不会 反复调用strlen      )o因为编译器认识memcpy()函数，对于定长的内存复制, 会在编译期把它inline展开为高效的目标代码。<br>
•线程id是预先格式化为字符串，在输出日志消息时只需简单拷贝几个字节。见 CurrentThread::tidString()o<br>
•每行日志消息的源文件名部分采用了编译期计算来获得basename,避免运行 期strrchr(3)开销。见SourceFile class,这里利用了 gcc的内置函数。</p>
<p>多线程异步日志<br>
多线程程序对日志库提出了新的需求：线程安全，即多个线程可以并发写日志, 两个线程的日志消息不会出现交织。线程安全不难办到，简单的办法是用一个全局 mutex保护IO,或者每个线程单独写一个日志文件”，但这两种做法的高效性就堪 忧了。前者会造成全部线程抢一个锁，后者有可能让业务线程阻塞在写磁盘操作上。<br>
解决办法不难想到，用一个背景线程负责收集日志消息，并写入日志文件, 其他业务线程只管往这个“日志线程”发送日志消息，这称为“异步日志”。<br>
在多线程服务程序中，异步日志（叫“非阻塞日志”似乎更准确）是必需的，因 为如果在网络IO线程或业务线程中直接往磁盘写数据的话，写操作偶尔口J能阻塞长 达数秒之久</p>
<p>我们需要一个“队列”来将日志前端的数据传送到后端（日志线程），但这个 “队列”不必是现成的BlockingQueue<a href="std::string">std::string</a>,因为不用每次产生一条日志消 息都通知（notify（））接收方。<br>
muduo日志库采用的是双缓冲（double buffering ）技术吃 基本思路是准备两 块buffer： A和B,前端负责往buffer A填数据（日志消息）,后端负责将buffer B 的数据写入文件。当buffer A写满之后，交换A和B,让后端将buffer A的数据写 入文件，而前端则往buffer B填入新的日志消息，如此往复。用两个buffer的好处是 在新建日志消息的时候不必等待磁盘文件操作，也避免每条新日志消息都触发（唤 醒）后端日志线程。换言之，前端不是将一条条日志消息分别传送给后端，而是将多 条日志消息拼成一个大的buffer传送给后端，相当于批处理，减少了线程唤醒的频 度，降低开销。另外，为了及时将日志消息写入文件，即便buffer A未满，日志库也 会每3秒执行一次上述交换写入操作。</p>
<p>关键代码<br>
实际实现采用了四个缓冲区，这样可以进一步减少或避免日志前端的等待。数据 结构如下(muduo/base/AsyncLogging.h )：<br>
typedef boost::ptr_vector<LargeBuffer><br>
typedef BufferVector::auto^type</p>
<p>其中，LargeBuffer 类型是 FixedBuffer class template 的一份具体实现(instantiation ),其大小为4MB,可以存至少1000条日志消息o boost::ptr_vector<T>::auto_type 类型类似C++11中的std: :unique_ptr,具备移动语义(move semantics ),而且能自 动管理对象生命期。mutex.用于保护后面的四个数据成员。buffers.存放的是供后端 写入的buffero</p>
<p>前端在生成一条日志消息的时候会调用AsyncLogging::append()o在这个函数中, 如果当前缓冲(currentBuffer,)剩余的空间足够大(£31),则会直接把日志消息拷贝(追加)到当前缓冲中(C33),这是最常见的情况。这里拷贝一条日志消息并不会 带来多大开销(p.120)。前后端代码的其余部分都没有拷贝，而是简单的指针交换。</p>
<p>否则，说明当前缓冲已经写满，就把它送入(移入)buffers一(£37),并试图把 预备好的另一块缓冲(nextBuffer_ )移用(move )为当前缓冲(£39~£42 ),然后追加 日志消息并通知(唤醒)后端开始写入日志数据(£47〜£48 )。以上两种情况在临界区 之内都没有耗时的操作，运行时间为常数。<br>
如果前端写入速度太快，一下子把两块缓冲都用完了，那么只好分配一块新的 buffer,作为当前缓冲(£43~£46),这是极少发生的情况。</p>
<p>首先准备好两块空闲的buffer,以备在临界区内交换(C53、£54 )o在临界区内， 等待条件触发(£61〜£64),这里的条件有两个：其一是超时，其二是前端写满了一 个或多个buffero注意这里是非常规的condition variable用法，它没有使用while循 环，而且等待时间有上限。</p>
<pre><code>一开始先分配好四个缓冲区A、 B、C、D,前端和后端各持有其中两个。前端和后端各有一个缓冲区数组，初始时都 是空的。

万一前端陷入死循环，拼命发送日志消息，超过后端的处理（输出）能力，会导 致什么后果？对于同步日志来说，这不是问题，因为阻塞IO自然就限制了前端的写 入速度，起到了节流阀（throttling）的作用。但是对于异步日志来说，这就是典型的 生产速度高于消费速度问题，会造成数据在内存中堆积，严重时引发性能问题（可用 内存不足）或程序崩溃（分配内存失败）o
</code></pre>
<p>muduo H志库处理日志堆积的方法很简单：直接丢掉多余的日志buffer,以腾 出内存，见muduo/base/AsyncLogging.cc第87~96行代码。这样可以防止日志库本身引起 程序故障，是一种自我保护措施。将来或许可以加上网络报警功能，通知人工介入, 以尽快修复故障。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线程池与内存池]]></title>
        <id>https://lixin-scut.github.io//post/xian-cheng-chi-yu-nei-cun-chi</id>
        <link href="https://lixin-scut.github.io//post/xian-cheng-chi-yu-nei-cun-chi">
        </link>
        <updated>2020-03-02T09:36:43.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>为什么需要线程池<br>
大多数的网络服务器，包括Web服务器都具有一个特点，就是单位时间内必须处理数目巨大的连接请求，但是处理时间却是比较短的。在传统的多线程服务器模型中是这样实现的：一旦有个请求到达，就创建一个新的线程，由该线程执行任务，任务执行完毕之后，线程就退出。这就是”即时创建，即时销毁”的策略。尽管与创建进程相比，创建线程的时间已经大大的缩短，但是如果提交给线程的任务是执行时间较短，而且执行次数非常频繁，那么服务器就将处于一个不停的创建线程和销毁线程的状态。这笔开销是不可忽略的，尤其是线程执行的时间非常非常短的情况。</li>
<li>线程池原理<br>
在应用程序启动之后，就马上创建一定数量的线程，放入空闲的队列中。这些线程都是处于阻塞状态，这些线程只占一点内存，不占用CPU。当任务到来后，线程池将选择一个空闲的线程，将任务传入此线程中运行。当所有的线程都处在处理任务的时候，线程池将自动创建一定的数量的新线程，用于处理更多的任务。执行任务完成之后线程并不退出，而是继续在线程池中等待下一次任务。当大部分线程处于阻塞状态时，线程池将自动销毁一部分的线程，回收系统资源。</li>
<li>线程池的作用<br>
需要大量的线程来完成任务，且完成任务的时间比较短；对性能要求苛刻的应用；对性能要求苛刻的应用</li>
<li>内存池的原理<br>
在软件开发中，有些对象使用非常频繁，那么我们可以预先在堆中实例化一些对象，我们把维护这些对象的结构叫“内存池”。在需要用的时候，直接从内存池中拿，而不用从新实例化，在要销毁的时候，不是直接free/delete，而是返还给内存池。把那些常用的对象存在内存池中，就不用频繁的分配/回收内存，可以相对减少内存碎片，更重要的是实例化这样的对象更快，回收也更快。当内存池中的对象不够用的时候就扩容。</li>
<li>内存池的优缺点<br>
内存池对象不是线程安全的，在多线程编程中，创建一个对象时必须加锁。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[select、poll和epoll]]></title>
        <id>https://lixin-scut.github.io//post/selectpoll-he-epoll</id>
        <link href="https://lixin-scut.github.io//post/selectpoll-he-epoll">
        </link>
        <updated>2020-03-02T09:01:31.000Z</updated>
        <content type="html"><![CDATA[<h3 id="非阻塞io">非阻塞I/O</h3>
<p>阻塞和非阻塞最大的区别在于调用I/O系统调用后，是等整个I/O过程完成再把操作权限返回给用户还是会立即返回。</p>
<p>可以使用以下语句将句柄fd设置为非阻塞I/O：fcntl(fd, F_SETFL, O_NONBLOCK);</p>
<p>非阻塞I/O在调用后会立即返回，用户进程对返回的返回值判断以区分是否完成了I/O。如果返回大于0表示完成了数据读取，返回值即读取的字节数；返回0表示连接已经正常断开；返回-1表示错误，接下来用户进程会不停地询问kernel是否准备完毕。<br>
非阻塞I/O虽然不再会完全阻塞用户进程，但实际上由于用户进程需要不停地询问kernel是否准备完数据，所以整体效率依旧非常低，不适合做并发。</p>
<h3 id="io复用">I/O复用</h3>
<p>I/O复用模型会用到select、poll、epoll函数，这几个函数也会使进程阻塞，但是和阻塞I/O所不同的的，这三个函数可以同时阻塞多个I/O操作。而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时，才真正调用I/O操作函数。</p>
<ol>
<li>IO复用是Linux中的IO模型之一，IO复用就是进程预先告诉内核需要监视的IO条件，使得内核一旦发现进程指定的一个或多个IO条件就绪，就通过进程进程处理，从而不会在单个IO上阻塞了。Linux中，提供了select、poll、epoll三种接口函数来实现IO复用。</li>
<li>Select<br>
select的缺点：<br>
①	单个进程能够监视的文件描述符的数量存在最大限制，通常是1024。由于select采用轮询的方式扫描文件描述符，文件描述符数量越多，性能越差；<br>
②	内核/用户空间内存拷贝问题，select需要大量句柄数据结构，产生巨大开销；<br>
③	Select返回的是含有整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生事件；<br>
④	Select的触发方式是水平触发，应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作，那么每次select调用还会将这些文件描述符通知进程。</li>
<li>Poll<br>
与select相比，poll使用链表保存文件描述符，没有了监视文件数量的限制，但其他三个缺点依然存在</li>
<li>Epoll<br>
上面所说的select缺点在epoll上不复存在，epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。Epoll是事件触发的，不是轮询查询的。没有最大的并发连接限制，内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递。</li>
</ol>
<h3 id="区别总结">区别总结</h3>
<ol>
<li>支持一个进程所能打开的最大连接数<br>
①	Select最大1024个连接，最大连接数有FD_SETSIZE宏定义，其大小是32位整数表示，可以改变宏定义进行修改，可以重新编译内核，性能可能会影响；<br>
②	Poll没有最大连接限制，原因是它是基于链表来存储的；<br>
③	连接数限数有上限，但是很大；</li>
<li>FD剧增后带来的IO效率问题<br>
①	因为每次进行线性遍历，所以随着FD的增加会造成遍历速度下降，效率降低；<br>
②	Poll同上；<br>
③	因为epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的现象下降的性能问题。</li>
<li>消息传递方式<br>
①	Select内核需要将消息传递到用户空间，都需要内核拷贝；<br>
②	Poll同上；<br>
③	Epoll通过内核和用户空间共享来实现的。</li>
</ol>
<h3 id="epoll-的-lt-和-et-模式">epoll 的 LT 和 ET 模式</h3>
<p>epoll对文件描述符的操作有两种模式：LT(level trigger)和ET(edge trigger)，LT是默认模式。<br>
区别：<br>
LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。<br>
ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p>
<h3 id="补充资料">补充资料</h3>
<p>I/O多路复用（事件驱动模型）<br>
前面已经论述了多进程、多进程模型会因为开销巨大和调度困难而导致并不能承受高并发量。但不适用这种模型的话，无论是阻塞还是非阻塞方式都会导致整个服务器停滞。<br>
所以对于大并发量，我们需要一种代理模型可以帮助我们集中去管理所有的socket连接，一旦某个socket数据到达了就执行其对应的用户进程，I/O多路复用就是这么一种模型。Linux下I/O多路复用的系统调用有select，poll和epoll，但从本质上来讲他们都是同步I/O范畴。</p>
<p><strong>select</strong><br>
相关接口：</p>
<pre><code>int select (int maxfd, fd_set *readfds, fd_set *writefds, fd_set *errorfds, struct timeval *timeout);
FD_ZERO(int fd, fd_set* fds) //清空集合
FD_SET(int fd, fd_set* fds) //将给定的描述符加入集合
FD_ISSET(int fd, fd_set* fds) //将给定的描述符从文件中删除
FD_CLR(int fd, fd_set* fds) //判断指定描述符是否在集合中
</code></pre>
<p>参数：<br>
maxfd：当前最大文件描述符的值+1（≠ MAX_CONN）。<br>
readfds：指向读文件队列集合（fd_set）的指针。<br>
writefds：同上，指向读集合的指针。<br>
writefds：同上，指向错误集合的指针。<br>
timeout：指向timeval结构指针，用于设置超时。<br>
其他：<br>
判断和操作对象为set_fd集合，集合大小为单个进程可打开的最大文件数1024或2048（可重新编译内核修改但不建议）。</p>
<p><strong>poll</strong><br>
相关接口：<code>int poll(struct pollfd *fds, unsigned int nfds, int timeout);</code><br>
结构体定义： s</p>
<pre><code>truct pollfd{ int fd; // 文件描述符 
short events; // 等到的事件 
short revents; // 实际发生的事件 
</code></pre>
<p>参数：<br>
fds：指向pollfd结构体数组的指针。<br>
nfds：pollfd数组当前已被使用的最大下标。<br>
timeout：等待毫秒数。<br>
其他：<br>
判断和操作对象是元素为pollfd类型的数组，数组大小自己设定，即为最大连接数。</p>
<p><strong>epoll</strong><br>
相关接口：</p>
<pre><code>int epoll_create(int size); // 创建epoll句柄 
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); // 事件注册函数 
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
</code></pre>
<p>结构体定义：<br>
<code>struct epoll_event { __uint32_t events; epoll_data_t data; }; typedef union epoll_data { void *ptr; int fd; __uint32_t u32; __uint64_t u64; }epoll_data_t;</code><br>
参数：<br>
size：用来告诉内核要监听的数目。<br>
epfd：epoll函数的返回值。<br>
op：表示动作（EPOLL_CTL_ADD/EPOLL_CTL_FD/EPOLL_CTL_DEL）。<br>
fd：需要监听的fd。<br>
events：指向epoll_event的指针，该结构记录监听的事件。<br>
maxevents：告诉内核events的大小。<br>
timeout：超时时间（ms为单位，0表示立即返回，-1将不确定）。<br>
select、poll和epoll区别</p>
<p>操作方式及效率：<br>
select是遍历，需要遍历fd_set每一个比特位（= MAX_CONN），O(n)；<br>
poll是遍历，但只遍历到pollfd数组当前已使用的最大下标（≠ MAX_CONN），O(n)；<br>
epoll是回调，O(1)。</p>
<p>最大连接数：<br>
select为1024/2048（一个进程打开的文件数是有限制的）；poll无上限；epoll无上限。</p>
<p>fd拷贝：<br>
select每次都需要把fd集合从用户态拷贝到内核态；<br>
poll每次都需要把fd集合从用户态拷贝到内核态；<br>
epoll调用epoll_ctl时拷贝进内核并放到事件表中，但用户进程和内核通过mmap映射共享同一块存储，避免了fd从内核赋值到用户空间。</p>
<p>其他：<br>
select每次内核仅仅是通知有消息到了需要处理，具体是哪一个需要遍历所有的描述符才能找到。<br>
epoll不仅通知有I/O到来还可通过callback函数具体定位到活跃的socket，实现伪AIO。</p>
<p>异步I/O模型<br>
上面三种I/O方式均属于同步I/O。<br>
从阻塞式I/O到非阻塞I/O，我们已经做到了调用I/O请求后立即返回，但不停轮询的操作效率又很低，如果能够既像非阻塞I/O能够立即返回又能不一直轮询的话会更符合我们的预期。<br>
之所以用户进程会不停轮询就是因为在数据准备完毕后内核不会回调用户进程，只能通过用户进程一次又一次轮询来查询I/O结果。如果内核能够在完成I/O后通过消息告知用户进程来处理已经得到的数据自然是最好的，异步I/O就是这么回事。<br>
异步I/O就是当用户进程发起I/O请求后立即返回，直到内核发送一个信号，告知进程I/O已完成，在整个过程中，都没有进程被阻塞。看上去异步I/O和非阻塞I/O的区别在于：判断数据是否准备完毕的任务从用户进程本身被委托给内核来完成。这里所谓的异步只是操作系统提供的一直机制罢了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[虚拟内存]]></title>
        <id>https://lixin-scut.github.io//post/xu-ni-nei-cun</id>
        <link href="https://lixin-scut.github.io//post/xu-ni-nei-cun">
        </link>
        <updated>2020-03-02T08:52:54.000Z</updated>
        <content type="html"><![CDATA[<h3 id="虚拟内存">虚拟内存</h3>
<ol>
<li>虚拟内存是一种内存管理技术，它会使程序自己认为自己拥有一块很大且连续的内存，然而，这个程序在内存中不是连续的，并且有些还会在磁盘上，在需要时进行数据交换;</li>
<li>优点：可以弥补物理内存大小的不足；一定程度的提高反应速度；减少对物理内存的读取从而保护内存延长内存使用寿命；</li>
<li>缺点：占用一定的物理硬盘空间；加大了对硬盘的读写；设置不得当会影响整机稳定性与速度。</li>
<li>虚拟地址空间是对于一个单一进程的概念，这个进程看到的将是地址从0000开始的整个内存空间。虚拟存储器是一个抽象概念，它为每一个进程提供了一个假象，好像每一个进程都在独占的使用主存。每个进程看到的存储器都是一致的，称为虚拟地址空间。从最低的地址看起：程序代码和数据，堆，共享库，栈，内核虚拟存储器。大多数计算机的字长都是32位，这就限制了虚拟地址空间为4GB。</li>
</ol>
<h3 id="分页和分段">分页和分段</h3>
<ol>
<li>页是信息的物理单位，分页是由于系统管理的需要。段是信息的逻辑单位，分段是为了满足用户的要求。</li>
<li>页的大小固定且由系统决定，段的长度不固定，决定于用户所编写的程序，通常由编译程序在对源程序紧进行编译时，根据信息的性质来划分。</li>
<li>分页的作业的地址空间是一维的，程序员只需要利用一个记忆符，即可表示一个地址。分段的作业地址空间则是二维的，程序员在标识一个地址时，既需要给出段名，又需要给出段的地址值。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[进程和线程、协程]]></title>
        <id>https://lixin-scut.github.io//post/jin-cheng-he-xian-cheng-xie-cheng</id>
        <link href="https://lixin-scut.github.io//post/jin-cheng-he-xian-cheng-xie-cheng">
        </link>
        <updated>2020-03-02T08:26:22.000Z</updated>
        <content type="html"><![CDATA[<h3 id="进程">进程</h3>
<ol>
<li>进程是指在系统中正在运行的一个应用程序，程序一旦运行就是进程；</li>
<li>进程可以认为是程序执行的一个实例，进程是系统进行资源分配的最小单位，且每个进程拥有独立的地址空间；</li>
<li>一个进程无法直接访问另一个进程的变量和数据结构，如果希望一个进程去访问另一个进程的资源，需要使用进程间的通信，比如：管道、消息队列等</li>
</ol>
<h3 id="线程">线程</h3>
<p>线程是进程的一个实体，是进程的一条执行路径；比进程更小的独立运行的基本单位，线程也被称为轻量级进程，一个程序至少有一个进程，一个进程至少有一个线程；同一进程内的所有线程共享相同的全局内存。</p>
<h3 id="进程和线程的区别">进程和线程的区别</h3>
<ol>
<li>同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间；</li>
<li>同一进程内的线程共享本进程的资源，但是进程之间的资源是独立的；</li>
<li>一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程崩溃，所以多进程比多线程健壮；</li>
<li>进程切换，消耗的资源大。所以涉及到频繁的切换，使用线程要好于进程；</li>
<li>两者均可并发执行；</li>
<li>每个独立的进程有一个程序的入口、程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li>
</ol>
<h3 id="父进程与子进程">父进程与子进程</h3>
<ol>
<li>fork之后，子进程会拷贝父进程的数据空间、堆和栈空间（实际上是采用写时复制技术），二者共享代码段。 所以在子进程中修改全局变量（局部变量，分配在堆上的内存同样也是）后，父进程的相同的全局变量不会改变。</li>
<li>共享文件描述符fd，以及fd对应的文件表项。</li>
</ol>
<h3 id="线程独占与共享的资源">线程独占与共享的资源</h3>
<p>同一进程内的所有线程除了共享全局变量外还共享：<br>
• 进程指令；<br>
• 大多数数据；<br>
• 打开的文件(即描述符)；<br>
• 信号处理函数和信号处置；<br>
• 当前工作目录；<br>
• 用户ID和组ID。</p>
<p>每个线程有各自的：<br>
• 线程ID<br>
• 寄存器集合，包括程序计数器和栈指针；<br>
• 栈(用于存放局部变量和返回地址)；<br>
•	errno<br>
• 信号掩码</p>
<h3 id="进程的状态">进程的状态</h3>
<ol>
<li>新状态：进程已经创建</li>
<li>就绪态：进程做好了准备，准备执行，等待分配处理机</li>
<li>执行态：该进程正在执行；</li>
<li>阻塞态：等待某事件发生才能执行，如等待I/O完成；</li>
<li>终止状态<br>
<img src="https://lixin-scut.github.io//post-images/1583138206954.png" alt=""></li>
</ol>
<h3 id="协程">协程</h3>
<ol>
<li>是一种比线程更加轻量级的存在。正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程；协程不是被操作系统内核管理，而完全是由程序所控制。</li>
<li>协程的开销远远小于线程；</li>
<li>协程拥有自己寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切换回来的时候，恢复先前保存的寄存器上下文和栈。</li>
<li>每个协程表示一个执行单元，有自己的本地数据，与其他协程共享全局数据和其他资源。</li>
<li>跨平台、跨体系架构、无需线程上下文切换的开销、方便切换控制流，简化编程模型；</li>
<li>协程又称为微线程，协程的完成主要靠yeild关键字，协程执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行；</li>
<li>协程极高的执行效率，和多线程相比，线程数量越多，协程的性能优势就越明显；</li>
<li>不需要多线程的锁机制；</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[希尔排序]]></title>
        <id>https://lixin-scut.github.io//post/xi-er-pai-xu</id>
        <link href="https://lixin-scut.github.io//post/xi-er-pai-xu">
        </link>
        <updated>2020-03-02T02:42:30.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://lixin-scut.github.io/post/pai-xu-suan-fa/">排序算法及其实现</a></p>
<p>  如何让待排序的记录个数较少呢?很容易想到的就是将原本有大量记录数的记录进行分组。分割成若干个子序列，此时每个子序列待排序的记录个数就比较少了，然后在这些子序列内分别进行直接插入排序，当整个序列都基本有序时，注意只是基本有序时，再对全体记录进行一次直接插入排序。<br>
  基本有序，就是小的关键字基本在前面，大的基本在后面，不大不小的基本在中间，我们分割待排序记录的目的是减少待排序记录的个数，并使整个序列向基本有序发展。<br>
  因此，我们需要采取跳跃分割的策略:将相距某个“增量”的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序。<br>
  注意！不能各自分组，而是依靠<strong>增量</strong>来模拟分组</p>
<pre><code>class ShellSort
{
public:
    void ShellSort0(vector&lt;int&gt; &amp;numbers);
};

void ShellSort::ShellSort0(vector&lt;int&gt; &amp;numbers)
{
    int len = numbers.size();
    int step = len;
    int i, j;
    do{
        step = (step+1) / 2 ;
        for(i = step; i &lt; len; ++i)
        {
            if(numbers[i] &lt; numbers[i-step])
            {
                int temp = numbers[i];
                for(j = i-step; j&gt;=0 &amp;&amp; temp&lt;numbers[j] ; j -= step)
                {
                    numbers[j + step] = numbers[j];
                }
                numbers[j + step] = temp;
            }
        }
    }while(step &gt; 1);
    print(numbers);
}

</code></pre>
<p>比较需要注意的就是增量的选择，我是直接模仿二分法，每次处以2并向上取整。<br>
<img src="https://lixin-scut.github.io//post-images/1583124356537.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1583124368262.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 题40:最小的k个数]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-ti-40zui-xiao-de-k-ge-shu</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-ti-40zui-xiao-de-k-ge-shu">
        </link>
        <updated>2020-03-02T01:12:01.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p>
</blockquote>
<p>  这一题就没啥特别的了，就是用大顶堆就好，记得priority_queue默认是大顶堆less，而不是小顶堆greater<br>
  然后就是还没想到的快速排序思想法，同样是找到第k个数；只是要注意k和下标、迭代器（左闭右开）的关系</p>
<pre><code>class Solution {
public:
    //快速排序思想法
    vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k){
        if(input.size()&lt;k)
            return vector&lt;int&gt;();
        GetLeastNumbers_Solution(input,k,0,input.size()-1);
        return vector&lt;int&gt;(input.begin(),input.begin()+k);
    }
    
    void GetLeastNumbers_Solution(vector&lt;int&gt; &amp;input, int k,int beg,int end){
        int flag=input[beg];
        int left=beg;
        int right=end;
        while(left&lt;right){
            while(left&lt;right&amp;&amp;input[right]&gt;=flag)
                --right;
            swap(input[left],input[right]);
            while(left&lt;right&amp;&amp;input[left]&lt;=flag)
                ++left;
            swap(input[left],input[right]);
        }
        if(left==k)
            return;
        if(left&lt;k)
            GetLeastNumbers_Solution(input,k,left+1,end);
        else
            GetLeastNumbers_Solution(input,k,beg,left+1);
    }
    /*
    //大顶堆
    vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) {
        vector&lt;int&gt; res;
        if(k&gt;input.size())
            return res;
        priority_queue&lt;int&gt; min_k;
        for(auto i:input){
            min_k.push(i);
            if(min_k.size()&gt;k)
                min_k.pop();
        }

        while(min_k.size()){
            res.push_back(min_k.top());
            min_k.pop();
        }
        return res;
    }
    */
};

</code></pre>
<p>书本题解：</p>
<blockquote>
<p>  解法一:时间复杂度为(n)的算法，只有当我们可以修改输入的数组时可用从解决面试题39 “数组中出现次数超过一半的数字”得到了启发，我们同样可以基于Partition函数来解决这个问题。如果基于数组的第k个数字来调整，则使得比第k个数字小的所有数字都位于数组的左边，比第k个数字大的所有数字都位于数组的右边。这样调整之后，位于数组中左边的k个数字就是最小的k个数字(这k个数字不一定是排序的)。<br>
  采用这种思路是有限制的。我们需要修改输入的数组，因为函数Partition会调整数组中数字的顺序。<br>
  解法二:时间复杂度为O(nlogk)的算法，特别适合处理海量数据。我们可以先创建一个大小为比的数据容器来存储最小的k个数字，接下来每次从输入的n个整数中读入一个数。如果容器中已有的数字少于k个, 则直接把这次读入的整数放入容器之中；如果容器中已有k个数字了，也就是容器已满，此时我们不能再插入新的数字而只能替换已有的数字。找 出这已有的k个数中的最大值，然后拿这次待插入的整数和最大值进行比 较。如果待插入的值比当前已有的最大值小，则用这个数替换当前已有的最大值：如果待插入的值比当前已有的最大值还要大，那么这个数不可能是最小的k个整数之一，于是我们可以抛弃这个整数。<br>
当容器满了之后，我们要做3件事情：一是在k个整数中找到最大数；二是有可能在这个容器中删除最大数；三是有可能要插入一个新的数字。如果用一棵二叉树来实现这个数据容器，那么我们能在O(logk)时间内实现这3步操作。因此，对于k个输入数字而言，总的时间效率就是 O(nlogk)<br>
（注意：是重要记得堆中的数据是没排序的，需要额外排序）<br>
解法比较<br>
  基于函数Partition的第一种解法的平均时间复杂度是O(n)，比第二种解法要快，但同时它也有明显的限制，比如会修改输入的数组。<br>
  第二种解法虽然慢一点，但它有两个明显的优点。一是没有修改输入的数据（代码中的变量data）。我们每次只是从data中读入数字，所有的操作都是在容器leastNumbers中进行的。二是该算法适合海量数据的输入 。假设题目是要求从海量的数据中找出最小的k个数字，由『内存的大小是有限的， 有可能不能把这些海量的数据一次性全部载入内存。这个时候，我们可以从辅助存储空间（如硬盘）中每次读入一个数字，根据GetLeastNumbers 的方式判断是不是需要放入容器leastNumbers即可。这种思路只要求内存能够容纳leastNumbers即可，因此它最适合的情形就是n很大并且比较小的问题。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 题39:数组中出现次数超过一半的数字[未做出]]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-ti-39shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-ti-39shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-wei-zuo-chu">
        </link>
        <updated>2020-03-02T00:54:17.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
</blockquote>
<p>  一开始我用的是单次遍历的方法，亦即不断检测最大重复数字，遇到相同的数字就+1，遇到不同的数字就要-1，次数变为0就要替换res<br>
然后注意的就是这个数字可能是不存在的，所以必须循环一次计算次数是否真的超过数组一半<br>
  然后就是快速排序的思想改进，因为中位数肯定就是出现次数超过一半的数，所以直接看当前数字所处的位置就行<br>
需要注意的是细节，比如为什么是numbers.size()/2<br>
  然后最坑的就是我不小心在if后面加了一个分号。。完全不会报错就跳到下一句去了，只有用了clion才发现这个warning</p>
<pre><code>class Solution {
public:
    //快速排序思想法的改版【未做出】
    int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers){
        if(numbers.empty())
            return 0;
        int res=MoreThanHalfNum_Solution(numbers,numbers.size()/2,0,numbers.size()-1);
        if(CheckNum(res,numbers))
            return res;
        else 
            return 0;
    }
    
    int MoreThanHalfNum_Solution(vector&lt;int&gt; &amp;numbers,int target,int left,int right){
        int flag=numbers[left];
        int beg=left;
        int end=right;
        while(beg&lt;end){
            while(beg&lt;end&amp;&amp;numbers[end]&gt;=flag)
                --end;
            swap(numbers[beg],numbers[end]);
            while(beg&lt;end&amp;&amp;numbers[beg]&lt;=flag)
                ++beg;
            swap(numbers[beg],numbers[end]);
        }
        if(beg==target)
            return numbers[beg];
        if(beg&lt;target)
            return MoreThanHalfNum_Solution(numbers,target,beg+1,right);
        else
            return MoreThanHalfNum_Solution(numbers,target,left,beg-1);
    }
    
    /*
    //次数互减
    int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) {
        int res,num;
        for(int i=0;i&lt;numbers.size();++i){
            if(i==0)
                res=numbers[i],num=1;
            else if(res==numbers[i])
                ++num;
            else if(res!=numbers[i]){
                if(num==1)
                    res=numbers[i];
                else
                    --num;
            }
        }
        if(CheckNum(res,numbers))
            return res;
        else 
            return 0;
    }
    */
    bool CheckNum(int res,vector&lt;int&gt; &amp;numbers){
        int num=0;
        for(auto i:numbers)
            if(i==res)
                ++num;
        return num&gt;numbers.size()/2;
    }    
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>如果是排好序的数组，那么我们就能很容易统计出每个数字出现的次数。 题目给出的数组没有说是排序的，因此我们需要先给它排序。排序的时间复杂度是O(NlogN)，最直观的算法通常不是面试官满意的算法<br>
解法一：基于Partition函数的时间复杂度为的算法<br>
数组中有一个数字出现的次数超过了数组长度的一半。如果 把这个数组排序，那么排序之后位于数组中间的数字一定就是那个出现次 数超过数组长度一半的数字。也就是说，这个数字就是统计学上的中位数, 即长度为n的数组中第n/2大的数字。我们有成熟的时间复杂度为O(N)的 算法得到数组中任意第k大的数字。<br>
这种算法受快速排序算法的启发。在随机快速排序算法中，我们先在数组中随机选择一个数字，然后调整数组中数字的顺序，使得比选中的数字小的数字都排在它的左边，比选中的数字大的数字都排在它的右边。如 果这个选中的数字的下标刚好是n/2,那么这个数字就是数组的中位数；如 果它的下标大于n/2,那么中位数应该位于它的左边，我们可以接着在它的 左边部分的数组中查找；如果它的下标小于n/2,那么中位数应该位于它的 右边，我们可以接着在它的右边部分的数组中查找。这是一个典型的递归过程。<br>
在面试的时候，除了要完成基本功能即找到符合要求的数字，还要考虑一些无效的输入。如果函数的输入参数是一个指针(数组在参数传 递的时候退化为指针)，就要考虑这个指针可能为nullptr。下面的函数 ChecklnvalidArray用来判断输入的数组是不是无效的。题目中说数组中有 一个数字出现的次数超过数组长度的一半，可能输入的数组中出现频率最高的数字都没有达到这个标准，这就是我们定义了一个 CheckMoreThanHalf函数的原因。<br>
解法二：根据数组特点找出时间复杂度为的算法<br>
接下来我们从另外一个角度来解决这个问题。数组中有一个数字出现 的次数超过数组长度的一半，也就是说它出现的次数比其他所有数字出现 次数的和还要多。因此，我们可以考虑在遍历数组的时候保存两个值：一个是数组中的一个数字；另一个是次数。当我们遍历到下一个数字的时候， 如果下一个数字和我们之前保存的数字相同，则次数加1；如果下一个数字和我们之前保存的数字不同，则次数减1。如果次数为零，那么我们需要保存下一个数字，并把次数设为1。由于我们要找的数字出现的次数比其他所 有数字出现的次数之和还要多，那么要找的数字肯定是最后一次把次数设 为1时对应的数字。</p>
</blockquote>
<pre><code>bool g_bInputInvalid = false;

bool CheckInvalidArray(int* numbers, int length)
{
    g_bInputInvalid = false;
    if(numbers == nullptr &amp;&amp; length &lt;= 0)
        g_bInputInvalid = true;

    return g_bInputInvalid;
}

bool CheckMoreThanHalf(int* numbers, int length, int number)
{
    int times = 0;
    for(int i = 0; i &lt; length; ++i)
    {
        if(numbers[i] == number)
            times++;
    }
 
    bool isMoreThanHalf = true;
    if(times * 2 &lt;= length)
    {
        g_bInputInvalid = true;
        isMoreThanHalf = false;
    }

    return isMoreThanHalf;
}

// ====================方法1====================
int MoreThanHalfNum_Solution1(int* numbers, int length)
{
    if(CheckInvalidArray(numbers, length))
        return 0;
 
    int middle = length &gt;&gt; 1;
    int start = 0;
    int end = length - 1;
    int index = Partition(numbers, length, start, end);
    while(index != middle)
    {
        if(index &gt; middle)
        {
            end = index - 1;
            index = Partition(numbers, length, start, end);
        }
        else
        {
            start = index + 1;
            index = Partition(numbers, length, start, end);
        }
    }
 
    int result = numbers[middle];
    if(!CheckMoreThanHalf(numbers, length, result))
        result = 0;

    return result;
}

// ====================方法2====================
int MoreThanHalfNum_Solution2(int* numbers, int length)
{
    if(CheckInvalidArray(numbers, length))
        return 0;
 
    int result = numbers[0];
    int times = 1;
    for(int i = 1; i &lt; length; ++i)
    {
        if(times == 0)
        {
            result = numbers[i];
            times = 1;
        }
        else if(numbers[i] == result)
            times++;
        else
            times--;
    }
 
    if(!CheckMoreThanHalf(numbers, length, result))
        result = 0;
 
    return result;
}
</code></pre>
<blockquote>
<p>述两种算法的时间复杂度都是O(n)。我们注意到，在第一种解法中，需要交换数组中数字的顺序，这就会修改输入的数组。是不是可以修改输 入的数组呢？在面试的时候，我们可以和面试官讨论，让他明确需求。如果面试官说不能修改输入的数组，那就只能采用第二种解法了。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 题38:字符串的排列[未做出]]]></title>
        <id>https://lixin-scut.github.io//post/zi-fu-chuan-ti-38zi-fu-chuan-de-pai-lie-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/zi-fu-chuan-ti-38zi-fu-chuan-de-pai-lie-wei-zuo-chu">
        </link>
        <updated>2020-03-02T00:25:31.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。<br>
输入描述:<br>
输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</p>
</blockquote>
<p>【未做出】<br>
一开始我打算用leetcode的做法，也就是回溯法，但是这样实在是太复杂了，需要记录或者去除已经采用的数字，第二个函数足足需要5到6个参数，而且需要很多局部变量<br>
所以还是参考书本的固定交换法<br>
注意和书本不同的是，这里首先需要去除重复值的交换（但是同时必须保证自己和自己换，所以需要加上num!=i的判断）<br>
其次要求返回的结果是排序的，这里就只能使用sort了。</p>
<pre><code>class Solution {
public:
    vector&lt;string&gt; Permutation(string str) {
        vector&lt;string&gt; res;
        if(str.empty())
            return res;
        Permutation(str,0,res);
        sort(res.begin(),res.end());
        return res;
    }
    
    void Permutation(string str,int num,vector&lt;string&gt; &amp;res)
    {
        if(num==str.size()){
            res.push_back(str);
            return;
        }
        for(int i=num;i&lt;str.size();++i){
            if(str[num]==str[i]&amp;&amp;num!=i)
                continue;
            swap(str[num],str[i]);
            Permutation(str,num+1,res);
            swap(str[num],str[i]);
        }
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>我们求整个字符串的排列，可以看成两步。第一步求所有可能出现在第一个位置的字符，即把第一个字符和后面所有的字符交换。。第二步固定第一个字符，求后面所有字符的排列。这时候我们仍把后面的所有字符分成两部分：后面字符的第一个字符，以及这个字符之后的所有字符。然后把第一个字符逐一和它后面的字符交换，这其实是典型的递归思路</p>
</blockquote>
<pre><code>void Permutation(char* pStr)
{
    if(pStr == nullptr)
        return;

    Permutation(pStr, pStr);
}

void Permutation(char* pStr, char* pBegin)
{
    if(*pBegin == '\0')
    {
        printf(&quot;%s\n&quot;, pStr);
    }
    else
    {
        for(char* pCh = pBegin; *pCh != '\0'; ++ pCh)
        {
            char temp = *pCh;
            *pCh = *pBegin;
            *pBegin = temp;

            Permutation(pStr, pBegin + 1);

            temp = *pCh;
            *pCh = *pBegin;
            *pBegin = temp;
        }
    }
}
</code></pre>
]]></content>
    </entry>
</feed>