<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-04-12T13:20:57.174Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>千里之行，始于足下。不积跬步，无以至千里。</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[一个简单的string类实现]]></title>
        <id>https://lixin-scut.github.io//post/yi-ge-jian-dan-de-string-lei-shi-xian</id>
        <link href="https://lixin-scut.github.io//post/yi-ge-jian-dan-de-string-lei-shi-xian">
        </link>
        <updated>2020-04-12T13:02:18.000Z</updated>
        <content type="html"><![CDATA[<p>前几天面试的时候面试官问起一个问题，一个类怎么实现？<br>
这里就简单地实现一个string，当然不可能完整地实现string的所有功能和可靠性，只是简单地实现所需的数据成员和成员函数，保证资源管理的正确实现。</p>
<p>具体来说：</p>
<ol>
<li>能像 int 类型那样定义变量，并且支持赋值、复制。</li>
<li>能用作函数的参数类型及返回类型。</li>
<li>能用作标准库容器的元素类型，即 vector/list/deque 的 value_type。</li>
</ol>
<p>对应的实验代码为：</p>
<pre><code>void foo(String x)
{
}

void bar(const String&amp; x)
{
}

String baz()
{
  String ret(&quot;world&quot;);
  return ret;
}

int main()
{
  String s0;
  String s1(&quot;hello&quot;);
  String s2(s0);
  String s3 = s1;
  s2 = s1;

  foo(s1);
  bar(s1);
  foo(&quot;temporary&quot;);
  bar(&quot;temporary&quot;);
  String s4 = baz();

  std::vector&lt;String&gt; svec;
  svec.push_back(s0);
  svec.push_back(s1);
  svec.push_back(baz());
  svec.push_back(&quot;good job&quot;);
}
</code></pre>
<p>参考陈硕大神的实现：<br>
首先选择数据成员，最简单的 String 只有一个 char* 成员变量。好处是容易实现，坏处是某些操作的复杂度较高（例如 size() 会是线性时间）。 String 只有一个 char* data_成员。而且规定 invariant 如下：一个 valid 的 string 对象的 data_ 保证不为nullpte，data_ 必须以 '\0' 结尾，以方便配合 C 语言的 str*() 系列函数。</p>
<p>其次决定支持哪些操作，构造、析构、拷贝构造、赋值这几样是肯定要有的（以前合称 big three，现在叫 copy control）。如果钻得深一点，C++11的移动构造和移动赋值也可以有。为了突出重点，暂不考虑 operator[] 之类的重载了。</p>
<p>整体强调正确性及易实现（白板上写也不会错），不强调效率。某种意义上可以说是以时间（运行快慢）换空间（代码简洁）。</p>
<p>需要注意的几个要点：</p>
<ol>
<li>只在构造函数里调用 new char[]，只在析构函数里调用 delete[]。</li>
<li>赋值操作符采用了《C++编程规范》推荐的现代写法。</li>
<li>每个函数尽量保持只有一两行代码，没有条件判断。</li>
<li>析构函数不必检查 data_ 是否为nullptr。</li>
<li>构造函数 String(const char* str) 没有检查 str 的合法性，这是一个永无止境的争论话题。这里在初始化列表里就用到了 str，因此在函数体内用 assert() 是无意义的。</li>
</ol>
<p>我的复现如下：</p>
<pre><code>class String 
{
public:
    String()
        : data_(new char[1])
    {
        *data_ = &quot;\0&quot;;
    }
    
    String(char* str)
        : data_(new char[strlen(str) + 1])
    {
        strcpy(str, data)；
    }
    
    String(const String&amp; str)
        : data_(new char[str.size() + 1]) // 不要忘了+1
    {
        strcpy(str.data_, str.c_str()); // c_str()返回的是const char*；
    }
    
    String&amp; operator=(String str) // 传值引用，配合swap防止自赋值等
    {
        swap(str);
        return *this; // 不要忘了返回*this
    }
    
    String(String&amp;&amp; str) // 因为要改变data_的值所以不需要const
        : data_(str.data_)
    {
            str.data_ = nullptr;
    }
    
    String&amp; operator=(String&amp;&amp; str)
    {
        swap(str);
        return *this;
    }
    
    ~String()
    {
        delete[] data_; // 记得是deleta[] 不是delete data_;
    }
    
    size_t size() const // 加上const
    {
        return strlen(data_); // 不需要解引用data_
    }
    
    const char* c_str() const // 加上const
    {
        return data_;
    }
    
private:
    void swap(String&amp; str) // 使用引用
    {
        std::swap(data_, str.data);
    }
    
    char* data_;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[位运算 面试题 01.01. 判定字符是否唯一[简单]]]></title>
        <id>https://lixin-scut.github.io//post/wei-yun-suan-mian-shi-ti-0101-pan-ding-zi-fu-shi-fou-wei-yi-jian-dan</id>
        <link href="https://lixin-scut.github.io//post/wei-yun-suan-mian-shi-ti-0101-pan-ding-zi-fu-shi-fou-wei-yi-jian-dan">
        </link>
        <updated>2020-04-11T15:08:39.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>实现一个算法，确定一个字符串 s 的所有字符是否全都不同。<br>
示例 1：<br>
输入: s = &quot;leetcode&quot;<br>
输出: false<br>
示例 2：<br>
输入: s = &quot;abc&quot;<br>
输出: true<br>
限制：<br>
0 &lt;= len(s) &lt;= 100<br>
如果你不使用额外的数据结构，会很加分。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/is-unique-lcci<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>最明显的就是哈希表了吧，先复习一波<br>
然后就是固定长度的字母表了，进一步可以简化为位运算法。<br>
最后就是排序法，就不额外实现了</p>
<p>当然这道题是默认的小写字母，如果加上大写字母或者其他字符，就要更加细心地考虑了。</p>
<pre><code>class Solution {
public:
    // 位运算
    bool isUnique(string astr) 
    {
        int bitMap = 0;
        for(char c : astr)
        {
            int bit = c - 'a';
            if((1 &amp; (bitMap &gt;&gt; bit)) == 1) // 千万记得 == 的优先级高于 相与运算符， 一定要加括号
            {
                return false;
            }
            else
            {
                bitMap = bitMap | (1 &lt;&lt; bit);
            }
        }
        return true;
    }
    /*
    // 哈希表
    bool isUnique(string astr) 
    {
        if(astr.empty())
        {
            return true;
        }
        unordered_set&lt;char&gt; letters;
        for(auto c : astr)
        {
            if(letters.count(c) == 0) // 不要偷懒直接判断
            {
                letters.insert(c); // 记得hashmap的插入函数是insert
            }
            else
            {
                return false;
            }
        }
        return true;
    }
    */
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 48:旋转矩阵 [中等][未做出]]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-48xuan-zhuan-ju-zhen-zhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-48xuan-zhuan-ju-zhen-zhong-deng-wei-zuo-chu">
        </link>
        <updated>2020-04-11T02:19:48.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。<br>
不占用额外内存空间能否做到？<br>
示例 1:<br>
给定 matrix =<br>
[<br>
[1,2,3],<br>
[4,5,6],<br>
[7,8,9]<br>
],<br>
原地旋转输入矩阵，使其变为:<br>
[<br>
[7,4,1],<br>
[8,5,2],<br>
[9,6,3]<br>
]<br>
示例 2:<br>
给定 matrix =<br>
[<br>
[ 5, 1, 9,11],<br>
[ 2, 4, 8,10],<br>
[13, 3, 6, 7],<br>
[15,14,12,16]<br>
],<br>
原地旋转输入矩阵，使其变为:<br>
[<br>
[15,13, 2, 5],<br>
[14, 3, 4, 1],<br>
[12, 6, 8, 9],<br>
[16, 7,10,11]<br>
]<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/rotate-matrix-lcci<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>其实使用额外的空间很容易看出 输出的第一行等于输出的第一列的逆序</p>
<p>不使用额外空间的话，我第一个想法是swap<br>
在示例1中，1分别逆时针和7，9，3交换，同样地，2逆时针和4，8，6交换<br>
在示例2中，5逆时针和15，16，11交换，1逆时针和13，12，10交换，9逆时针和2，14，10交换<br>
然后新增里一层，4分别和3，6，8交换</p>
<p>然后似乎需要N/2层的交换</p>
<p>00 30 33 03<br>
10 31 23 02<br>
20 32 13 01<br>
很明显两个坐标都是依照某种规律在循环<br>
可惜最后没找到通用的规律</p>
<p>看了题解才发现一个很秀的做法<br>
首先上下翻转，再对角线翻转。太秀啦</p>
<p>然后就是我自己想的方法，其实也是可以实现的，只是需要n和i、j之间的配合，相对麻烦一点<br>
然后也需要转换一下思维，不是进行旋转式交换，而是在原地址不断地交换，比如示例1中固定位置 [0,0]，然后先后和30、33、03交换，能够达到相同的效果<br>
然后这样子循环的判断也简单了很多，我们可以发现需要交换的位置为第一行的[0,n-1]、第二行的[1, n-2]、第三行的[2, n-3]，范围相等或者不等时，就可以停止循环了<br>
然后看一下规律：<br>
00 - 04 - 44 - 40<br>
01 - 13 - 32 - 20<br>
...<br>
11 - 12 - 22 - 21<br>
发现一个规律是相邻之间的行坐标对应纵坐标</p>
<p>实现注意的点：</p>
<ol>
<li>函数的返回值</li>
<li>坐标的设置，以及循环的</li>
</ol>
<pre><code>class Solution {
public:
    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix)
    {
        int n = matrix.size();
        int left, right;
        left = 0;
        right = n - 1;
        for(int row = 0; row &lt; n &amp;&amp; left &lt; right; ++row)
        {
            for(int col = left; col &lt; right; ++col)
            {
                swap(matrix[row][col], matrix[col][n - row - 1]); 
                swap(matrix[row][col], matrix[n - row - 1][n - col - 1]);
                swap(matrix[row][col], matrix[n - col - 1][row]); // 注意此处是row
            }
            ++left;
            --right;
        }
        return;
    }
    
    /*
    // 上下翻转+对角线翻转
    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix)
    {
        int n = matrix.size();
        
        // 上下翻转
        for(int row = 0; row &lt; n / 2; ++row)
        {
            for(int col = 0; col &lt; n; ++col)
            {
                swap(matrix[row][col], matrix[n - row - 1][col]);
            }
        }
        
        // 对角线翻转
        for(int row = 0; row &lt; n; ++row)
        {
            for(int col = row; col &lt; n; ++col)
            {
                swap(matrix[row][col], matrix[col][row]);
            }
        }
        
        return ;
    }
    
    // 额外空间
    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {

        int n = matrix.size();
        vector&lt;vector&lt;int&gt;&gt; res = matrix;
        for(int i = 0; i &lt; n; ++i)
        {
            for(int j = 0; j &lt; n; ++j)
            {
                res[i][j] = matrix[n - j - 1][i];
            }
        }
        matrix = res;
        return;
    }
    */
};
</code></pre>
<blockquote>
<p>官方题解：<br>
方法一：使用辅助数组<br>
我们以题目中的示例二</p>
</blockquote>
<pre><code> 5  1  9 11
 2  4  8 10
13  3  6  7
15 14 12 16
</code></pre>
<blockquote>
<p>作为例子，分析将图像旋转 90 度之后，这些数字出现在什么位置。<br>
对于矩阵中的第一行而言，在旋转后，它出现在倒数第一列的位置：</p>
</blockquote>
<pre><code> 5  1  9 11              x  x  x  5
 x  x  x  x   =旋转后=&gt;   x  x  x  1
 x  x  x  x              x  x  x  9
 x  x  x  x              x  x  x 11
</code></pre>
<blockquote>
<p>并且，第一行的第 x 个元素在旋转后恰好是倒数第一列的第 x 个元素。<br>
对于矩阵中的第二行而言，在旋转后，它出现在倒数第二列的位置：</p>
</blockquote>
<pre><code> x  x  x  x              x  x  2  x
 2  4  8 10   =旋转后=&gt;   x  x  4  x
 x  x  x  x              x  x  8  x
 x  x  x  x              x  x 10  x
</code></pre>
<blockquote>
<p>对于矩阵中的第三行和第四行同理。这样我们可以得到规律：<br>
对于矩阵中第 i 行的第 j 个元素，在旋转后，它出现在倒数第 i 列的第 j 个位置。<br>
我们将其翻译成代码。由于矩阵中的行列从 0 开始计数，因此对于矩阵中的元素 matrix[row][col]，在旋转后，它的新位置为 matrix new[col][n−row−1]。<br>
这样以来，我们使用一个与 matrix 大小相同的辅助数组 matrixnew，临时存储旋转后的结果。我们遍历 matrix 中的每一个元素，根据上述规则将该元素存放到 matrixnew 中对应的位置。在遍历完成之后，再将 matrixnew中的结果复制到原数组中即可。</p>
</blockquote>
<pre><code>C++P
class Solution {
public:
    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        int n = matrix.size();
        // C++ 这里的 = 拷贝是值拷贝，会得到一个新的数组
        auto matrix_new = matrix;
        for (int i = 0; i &lt; n; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                matrix_new[j][n - i - 1] = matrix[i][j];
            }
        }
        // 这里也是值拷贝
        matrix = matrix_new;
    }
};
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(N^2)，其中 N 是 matrix 的边长。<br>
空间复杂度：O(N^2)，我们需要使用一个和 matrix 的大小相同的辅助数组。</p>
</blockquote>
<blockquote>
<p>方法二：原地旋转<br>
题目中要求我们尝试在不使用额外内存空间的情况下进行矩阵的旋转，也就是说，我们需要「原地旋转」这个矩阵。那么我们如何在方法一的基础上完成原地旋转呢？<br>
这四项处于一个循环中，并且每一项旋转后的位置就是下一项所在的位置！因此我们可以使用一个临时变量 temp 完成这四项的原地交换：<br>
temp = matrix[row][col]<br>
matrix[row][col] = matrix[n−col−1][row]<br>
matrix[n−col−1][row] = matrix[n−row−1][n−col−1]<br>
matrix[n−row−1][n−col−1] = matrix[col][n−row−1]<br>
matrix[col][n−row−1] = temp<br>
当我们知道了如何原地旋转矩阵之后，还有一个重要的问题在于：我们应该枚举哪些位置(row,col) 进行上述的原地交换操作呢？由于每一次原地交换四个位置，因此：<br>
当 n 为偶数时，我们需要枚举 n^2 /4=(n/2)∗(n/2) 个位置，矩阵的左上角符合我们的要求。例如当 n=4 时，下面第一个矩阵中 ∗ 所在就是我们需要枚举的位置，每一个 ∗ 完成了矩阵中四个不同位置的交换操作：</p>
</blockquote>
<pre><code>**..              ..**              ....              ....
**..   =下一项=&gt;   ..**   =下一项=&gt;   ....   =下一项=&gt;   ....
....              ....              ..**              **..
....              ....              ..**              **..
</code></pre>
<blockquote>
<p>保证了不重复、不遗漏；<br>
当 n 为奇数时，由于中心的位置经过旋转后位置不变，我们需要枚举 (n^2 −1)/4=((n−1)/2)∗((n+1)/2) 个位置，同样可以使用矩阵左上角对应大小的子矩阵。例如当 n=5 时，下面第一个矩阵中 ∗ 所在就是我们需要枚举的位置，每一个 ∗ 完成了矩阵中四个不同位置的交换操作：</p>
</blockquote>
<pre><code>***..              ...**              .....              .....
***..              ...**              .....              .....
..x..   =下一项=&gt;   ..x**   =下一项=&gt;   ..x..   =下一项=&gt;   **x..
.....              .....              ..***              **...
.....              .....              ..***              **...
</code></pre>
<blockquote>
<p>同样保证了不重复、不遗漏。<br>
综上所述，我们只需要枚举矩阵左上角高为 ⌊n/2⌋，宽为 ⌊(n+1)/2⌋ 的子矩阵即可。</p>
</blockquote>
<pre><code>C++
class Solution {
public:
    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        int n = matrix.size();
        for (int i = 0; i &lt; n / 2; ++i) {
            for (int j = 0; j &lt; (n + 1) / 2; ++j) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[n - j - 1][i];
                matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
                matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
                matrix[j][n - i - 1] = temp;
            }
        }
    }
};
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度:O(N^2)，其中 N 是 matrix 的边长。我们需要枚举的子矩阵大小为 O(⌊n/2⌋×⌊(n+1)/2⌋)=O(N^2)。<br>
空间复杂度：O(1)，为原地旋转。</p>
</blockquote>
<blockquote>
<p>方法三：用翻转代替旋转<br>
我们还可以另辟蹊径，用翻转操作代替旋转操作。我们还是以题目中的示例二</p>
</blockquote>
<pre><code> 5  1  9 11
 2  4  8 10
13  3  6  7
15 14 12 16
</code></pre>
<blockquote>
<p>作为例子，先将其通过水平轴翻转得到：</p>
</blockquote>
<pre><code> 5  1  9 11                 15 14 12 16
 2  4  8 10                 13  3  6  7
------------   =水平翻转=&gt;   ------------
13  3  6  7                  2  4  8 10
15 14 12 16                  5  1  9 11
</code></pre>
<blockquote>
<p>再根据主对角线 翻转得到：</p>
</blockquote>
<pre><code>15 14 12 16                   15 13  2  5
13  3  6  7   =主对角线翻转=&gt;   14  3  4  1
 2  4  8 10                   12  6  8  9
 5  1  9 11                   16  7 10 11
</code></pre>
<blockquote>
<p>就得到了答案。这是为什么呢？对于水平轴翻转而言，我们只需要枚举矩阵上半部分的元素，和下半部分的元素进行交换，即<br>
matrix[row][col] 水平轴翻转→  matrix[n−row−1][col]<br>
对于主对角线翻转而言，我们只需要枚举对角线左侧的元素，和右侧的元素进行交换，即<br>
matrix[row][col] 主对角线翻转→  matrix[col][row]<br>
将它们联立即可得到：<br>
matrix[row][col] 水平轴翻转→  matrix[n−row−1][col] 主对角线翻转 →<br>
matrix[col][n−row−1]<br>
和方法一、方法二中的关键等式：<br>
matrix new[col][n−row−1]=matrix[row][col]<br>
是一致的。</p>
</blockquote>
<pre><code>C++
class Solution {
public:
    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        int n = matrix.size();
        // 水平翻转
        for (int i = 0; i &lt; n / 2; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                swap(matrix[i][j], matrix[n - i - 1][j]);
            }
        }
        // 主对角线翻转
        for (int i = 0; i &lt; n; ++i) {
            for (int j = 0; j &lt; i; ++j) {
                swap(matrix[i][j], matrix[j][i]);
            }
        }
    }
};
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(N^2)，其中 N 是 matrix 的边长。对于每一次翻转操作，我们都需要枚举矩阵中一半的元素。<br>
空间复杂度：O(1)，为原地翻转得到的原地旋转。</p>
</blockquote>
<p>网友题解</p>
<blockquote>
<p>图中颜色相同的四个位置，当旋转90度后，对应位置的元素发生了顺时针的交换。<br>
而相隔的两个位置是中心对称的，基于此可以计算出发生交换的四个元素位置关系。<br>
设四个位置中，位于左上角区域的位置坐标为 (i,j)，<br>
则按顺时针顺序，四个位置分别为(i,j), (j, n-i-1), (n-i-1,n-j-1), (n-j-1,i)。<br>
其中 n 为 matrix.size(), i, j 分别为matrix的行列下标，从 0 开始。<br>
整个矩阵的旋转可以理解为起点都在左上角区域，然后依次顺时针移动，如下图示<br>
matrix.size() 为奇数时，位置的对应关系相同，但左上角区域并不是整个矩阵的四分之一，如下图示：<br>
其实就是多了中间列的上半部分。<br>
那么现在捋一下如何原地操作元素：<br>
枚举左上区域的所有位置，然后通过上面总结的位置关系直接交换元素。<br>
对于一个位置 (i,j)，需要交换三次：<br>
swap(matrix[i][j], matrix[j][n-i-1]);<br>
swap(matrix[i][j], matrix[n-i-1][n-j-1]);<br>
swap(matrix[i][j], matrix[n-j-1][i]);<br>
综上，整个过程的时间复杂度为O(n^2)；空间复杂度为(1)。<br>
有小伙伴对坐标推导过程感兴趣，那我尝试讲一下：<br>
关于纵轴对称两个位置，到纵轴的距离相等，又因为第 0 列和第 n-1列到纵轴的距离相等。所以关于纵轴对称的两个位置到 0 列和n-1列的位置相等，所以两点的纵坐标有 y0=(n−1)−y1 ,即 y1=n−1−y0 ，横坐标相等, 即 x1=y0<br>
关于横轴对称有相似的性质，可得 x3=n−1−x0，纵坐标相等，即x3=x0 。<br>
中心对称，就是先纵轴对称，然后横轴对称，所以有y2 =n−1−y0,x2 =n−1−x0。<br>
这样就得到了其中一对位置的坐标对应关系，另一对和该对是根据对角线对称的，证明过程类似，不再赘述啦。</p>
</blockquote>
<pre><code>class Solution {
public:
    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        int n = matrix.size();
        if(n == 0) { return; }
        int r = (n&gt;&gt;1)-1; //左上角区域的最大行下标，
        int c = (n-1)&gt;&gt;1; //左上角区域的最大列下标，行列下标从 0 开始。
        for(int i = r; i &gt;= 0; --i) {
            for(int j = c; j &gt;= 0; --j) {
                swap(matrix[i][j], matrix[j][n-i-1]);
                swap(matrix[i][j], matrix[n-i-1][n-j-1]);
                swap(matrix[i][j], matrix[n-j-1][i]);
            }
        }
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RTTI]]></title>
        <id>https://lixin-scut.github.io//post/rtti</id>
        <link href="https://lixin-scut.github.io//post/rtti">
        </link>
        <updated>2020-04-10T12:37:53.000Z</updated>
        <content type="html"><![CDATA[<p>运行时类型信息 (RTTI)</p>
<ol>
<li>dynamic_cast ：用于多态类型的转换</li>
<li>typeid ：typeid运算符允许在运行时确定对象的类型<br>
返回一个 type_info 对象的引用，如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数，只能获取对象的实际类型</li>
<li>type_info：type_info 类描述编译器在程序中生成的类型信息。<br>
此类的对象可以有效存储指向类型的名称的指针。 type_info 类还可存储适合比较两个类型是否相等或比较其排列顺序的编码值。 类型的编码规则和排列顺序是未指定的，并且可能因程序而异。</li>
</ol>
<p>笔记总结：</p>
<p>运行时类型识别（run-time type identification,RTTI)的功能由两个运算符实现：<br>
• typeid运算符，用于返回表达式的类型。<br>
• dynamic_cast运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用。<br>
这两个运算符特别适用于以下情况：我们想使用基类对象的指针或引用执行某个派生 类操作并且该操作不是虚函数。一般来说，只要有可能我们应该尽量使用虚函数。当操作被定义成虚函数时，编译器将根据对象的动态类型自动地选择正确的函数版本。<br>
然而，并非任何时候都能定义一个虚函数。假设我们无法使用虚函数，则可以使用一个RTTI运算符。另一方面，与虚成员函数相比，使用RTTI运算符蕴含着更多潜在的风险：程序员必须清楚地知道转换的目标类型并且必须检查类型转换是否被成功执行。<br>
使用RTTI必须要加倍小心。在可能的情况下，最好定义虚函数而非直接接管类型管理的重任。<br>
当运算对象不属于类类型或者是一个不包含任何虚函数的类时，typeid运算符指示的是运算对象的静态类型。而当运算对象是定义了至少一个虚函数的类的左值时，typeid的结果直到运行时才会求得。<br>
typeid是否需要运行时检查决定了表达式是否会被求值。只有当类型含有虚函数时，编译器才会对表达式求值。反之，如果类型不含有虚函数，则typeid返回表达式的静态类型；编译器无须对表达式求值也能知道表达式的静态类型。</p>
<p>《C++ primer》详细笔记：</p>
<h3 id="运行时类型识别">运行时类型识别</h3>
<p><strong>运行时类型识别</strong>（run-time type identification,RTTI)的功能由两个运算符实现：<br>
• <strong>typeid运算符</strong>，用于<strong>返回表达式的类型</strong>。<br>
• <strong>dynamic_cast运算符</strong>，用于将<strong>基类的指针或引用</strong>安全地<strong>转换成派生类的指针或引用</strong>。</p>
<p>这两个运算符特别适用于以下情况：我们想<strong>使用基类对象的指针或引用执行某个派生 类操作</strong>并且<strong>该操作不是虚函数</strong>。一般来说，只要有可能我们<strong>应该尽量使用虚函数</strong>。当操作被定义成虚函数时，<strong>编译器</strong>将根据对象的<strong>动态类型自动地选择</strong>正确的函数版本。<br>
然而，<strong>并非任何时候都能定义一个虚函数。</strong> 假设我们<strong>无法使用虚函数</strong>，则可以使用一个<strong>RTTI运算符</strong>。另一方面，与虚成员函数相比，使用RTTI运算符<strong>蕴含着更多潜在的风险</strong>：<strong>程序员必须清楚地知道</strong>转换的目标类型并且必须检查类型转换是否被成功执行。<br>
<strong>使用RTTI必须要加倍小心</strong>。在可能的情况下，最好定义虚函数而非直接接管类型管理的重任。</p>
<p><strong>dynamic_cast运算符</strong><br>
<img src="https://lixin-scut.github.io//post-images/1586524650146.png" alt=""><br>
其中，<strong>type必须是一个类类型</strong>，并且通常情况下<strong>该类型应该含有虚函数</strong>。在<strong>第一种形式</strong>中，e必须是一个<strong>有效的指针</strong>（参见2.3.2节，第47页）；在<strong>第二种形式</strong>中，e必须是一个<strong>左值</strong>；在<strong>第三种形式中</strong>，<strong>e不能是左值</strong>。<br>
在上面的所有形式中，e的类型<strong>必须符合以下三个条件中的任意一个</strong>：<br>
1.e的类型是目标type的<strong>公有派生类</strong>、<br>
2.e的类型是目标化type的公有基类或者<br>
3.e的类型就是目标type的<strong>类型</strong>。<br>
如果符合，则类型转换可以成功。否则，转换失败。如果一条dynamic_cast语句的转换目标是<strong>指针类型并且失败了</strong>，<strong>则结果为0</strong>。如果<strong>转换目标是引用类型并且失败了</strong>，则dynamic_cast运算符将<strong>抛出一个bad_cast异常</strong>。（公有是什么意思）<br>
<strong>注意！符合上面三个条件不等于就能转换成功，程序不会报错但是会转换失败</strong></p>
<p><strong>指针类型的dynamic_cast</strong><br>
<img src="https://lixin-scut.github.io//post-images/1586524656207.png" alt=""><br>
我们可以<strong>对一个空针执行dynamic_cast</strong>,结果是<strong>所需类型的空指针</strong>。<br>
值得注意的一点是，我们在<strong>条件部分定义了dp</strong>,这样做的好处是可以<strong>在一个操作中同时</strong>完成<strong>类型转换</strong>和<strong>条件检查</strong>两项任务。而且，<strong>指针dp</strong>在if语句<strong>外部是不可访问的</strong>。一旦转换失败，即使后续的代码忘了做相应判断，也不会接触到逐个未绑定的指针，从而确保程序是安全的。（<strong>if条件部分定义的变量只能在if内部使用，外部不可访问！</strong>）<br>
<strong>在条件部分执行dynamic_cast操作可以确保类型转换和结果检查在同一条表达式中完成。</strong><br>
引用类型的dynamic_cast<br>
引用类型的dynamic_cast与指针类型的dynamic_cast在表示错误发生的方式上略有不同。因为<strong>不存在所谓的空引用</strong>，所以对于引用类型来说无法使用与指针类型完全相同的错误报告策略。当对<strong>引用的类型转换失败</strong>时，程序<strong>抛出一个名为std::bad_cast的异常</strong>，该异常定义在<strong>typeinfo标准库头文件</strong>中。</p>
<h3 id="typeid运算符">typeid运算符</h3>
<p>为RTTI提供的第二个运算符是<strong>typeid运算符</strong>（typeid operator)，它允许程序向表达式提问：<strong>你的对象是什么类型</strong>？<br>
typeid表达式的形式是<strong>typeid(e)</strong>.其中<strong>e</strong>可以是<strong>任意表达式或类型的名字</strong>。typeid操作的<strong>结果是一个常量对象的引用</strong>，<strong>该对象的类型</strong>是标准库类型<strong>type_info</strong>或者<strong>typeinfo的公有派生类型</strong>。typeinfo类<strong>定义在typeinfo头文件</strong>中<br>
typeid运算符可以<strong>作用于任意类型的表达式</strong>。和往常一样，<strong>顶层const</strong>(参见2.4.3节，第57页）<strong>被忽略</strong>，如果表达式是一个<strong>引用</strong>，则typeid返<strong>回该引用所引对象的类型</strong>。不过当typeid<strong>作用于数组或函数时</strong>，<strong>并不会执行向指针的标准类型转换</strong>（参见4.11.2节，第143页）。也就是说，如果我们对数组a执行typeid(a),则<strong>所得的结果是数组类型而非指针类型</strong>。<br>
当运算对象<strong>不属于类类型</strong>或者是一个<strong>不包含任何虚函数的类</strong>时，typeid运算符指示的是运算对象的<strong>静态类型</strong>。而当运算对象是<strong>定义了至少一个虚函数的类的左值</strong>时，typeid的结果<strong>直到运行时才会求得</strong>。</p>
<h3 id="使用typeid运算符">使用typeid运算符</h3>
<p><img src="https://lixin-scut.github.io//post-images/1586524679301.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1586524684155.png" alt=""><br>
通常情况下，我们<strong>使用typeid比较</strong>两条表达式的<strong>类型是否相同</strong>，<strong>或者比较</strong>一条表达式的类型<strong>是否与指定类型相同</strong>：<br>
注意，<strong>typeid应该作用于对象</strong>，因此我们<strong>使用*bp而非bp:</strong><br>
当<strong>typeid作用于指针</strong>时（<strong>而非指针所指的对象</strong>），<strong>返回的结果</strong>是该<strong>指针的静态编译时类型</strong>。<br>
<strong>typeid是否需要运行时检查</strong>决定了<strong>表达式是否会被求值</strong>。<strong>只有当类型含有虚函数时</strong>，编译器<strong>才会对表达式求值</strong>。反之，如果类型不含有虚函数，则typeid返回表达式的静态类型；编译器无须对表达式求值也能知道表达式的静态类型。<br>
如果表达式的动态类型可能与静态类型不同，则必须在运行时对表达式求值以确定返 回的类型。这条规则<strong>适用于typeid(*p)的情况</strong>。</p>
<h3 id="使用rtti">使用RTTI</h3>
<p>在某些情况下RTTI非常有用，比如当我们想为<strong>具有继承关系的类实现相等运算符时</strong>参见14.3.1节，第497页）。对于两个对象来说，如果它们的类型相同并且对应的数据成员取值相同，则我们说送两个对象是相等的。在类的继承体系中，每个派生类负责添加自己的数据成员，因此<strong>派生类的相等运算符必须把派生类的新成员考虑进来</strong>。<br>
基于上述推论，我们就可以使用RTTI解决问题了。我们定义的相等运算符的形参是基类的引用，然后<strong>使用typeid检查</strong>两个运算对象的类型<strong>是否一致</strong>。如果运算对象的类型不一致，则==返回false；<strong>类型一致才调用equal函数</strong>。每个类定义的<strong>equal函数负责比较</strong>类型<strong>自己的成员</strong>。这些运算符接受Base&amp;形参，但是在进行比较操作前先把运算对象转换成运算符所属的类类型。<br>
<img src="https://lixin-scut.github.io//post-images/1586524696509.png" alt=""></p>
<h3 id="虚equal函数">虚equal函数</h3>
<p>继承体系中的每个类<strong>必须定义自己的equal函数</strong>。派生类的<strong>所有函数要做的第一件事</strong>都是相同的，那就是将<strong>实参的类型转换为派生类类型</strong>；<br>
<img src="https://lixin-scut.github.io//post-images/1586524703847.png" alt=""><br>
<strong>注意，类型相同后还是必须将实参转化为派生类类型！！！，否则静态类型还是基类类型</strong></p>
<h3 id="type_info类">type_info类</h3>
<p><strong>typeid的结果是一个常量的引用，该常量的类型是type_info或者其公有派生类类型</strong><br>
<strong>type_info类的精确定义</strong>随着<strong>编译器的不同而略有差异</strong>。不过，C++标准规定type_info类<strong>必须定义在typeinfo头文件中</strong>，并且至少提供表19.1所列的操作。<br>
<img src="https://lixin-scut.github.io//post-images/1586524708560.png" alt=""><br>
除此之外，因为type_info类<strong>一般是作为一个基类出现</strong>，所以它还应该<strong>提供一个公有的虚析构函数</strong>。当编译器希望提供<strong>额外的类型信息</strong>时，通常在<strong>type_info的派生类中完成</strong>。<br>
<strong>type_info类没有默认构造函数</strong>，而且它的<strong>拷贝和移动构造函数</strong>以及<strong>赋值运算符</strong>都被<strong>定义</strong>成<strong>删除的</strong>（参化13.1.6节，第450页）。因此，我们<strong>无法定义或拷贝type_info类型的对象</strong>，也<strong>不能为type_info类型的对象赋值</strong>。<strong>创建type_info对象</strong>的<strong>唯一途径</strong>是使用<strong>typeid运算符</strong>。<br>
对于<strong>name返回值</strong>的<strong>唯一要求</strong>是，<strong>类型不同</strong>则<strong>返回的字符串必须有所区别</strong>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 234. 回文链表[简单]]]></title>
        <id>https://lixin-scut.github.io//post/lian-biao-234-hui-wen-lian-biao-jian-dan</id>
        <link href="https://lixin-scut.github.io//post/lian-biao-234-hui-wen-lian-biao-jian-dan">
        </link>
        <updated>2020-04-10T10:49:33.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>请判断一个链表是否为回文链表。<br>
示例 1:<br>
输入: 1-&gt;2<br>
输出: false<br>
示例 2:<br>
输入: 1-&gt;2-&gt;2-&gt;1<br>
输出: true<br>
进阶：<br>
你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/palindrome-linked-list<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>如果不限制空间的话，明显用一个栈最舒服啦</p>
<p>当然限制了空间也没问题<br>
我们先利用到寻找链表中点的知识点，也就是快慢指针，得到链表的中点。<br>
需要注意的就是链表长度为奇数的时候（偶数比较简单，比如示例二），此时满指针刚好停在中点处<br>
然后重点就是我们需要修改前半部分链表的指向， 使得他们可以和后半部分的指针记性比较</p>
<p>看了题解才发现自己想复杂了，完全可以反转后半部分链表的嘛。。。</p>
<p>然后递归思想也很强，就是栈的对应，一定要记得栈和递归的对应关系，这次又忘了</p>
<p>实现中注意的问题：</p>
<ol>
<li>注意slow和fast的初始化。</li>
<li>注意判断条件的不同会影响到slow最终停留的位置，进而影响后续的反转链表</li>
<li>反转链表直接单独一个函数，返回反转后的链表头，注意需要三个临时节点的合作才能反转链表</li>
<li>反转链表时一定要把头节点形参的next置为nullptr，亦即pre初始化为nullptr</li>
<li>奇数长度的链表最后会多一个节点，所以必须同时判断两个链表是否到尾部了</li>
</ol>
<pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        if(head == nullptr)
        {
            return true;
        }
        ListNode* fast;
        ListNode* slow;
        slow = head;
        fast = head-&gt;next;
        while(fast != nullptr &amp;&amp; fast-&gt;next != nullptr)
        {
            slow = slow-&gt;next;
            fast = fast-&gt;next-&gt;next;
        }
        ListNode* tail = reverseList(slow);
        ListNode* node1 = head;
        ListNode* node2 = tail;
        while(node1 != nullptr &amp;&amp; node2 != nullptr)
        {
            if(node1-&gt;val != node2-&gt;val)
            {
                return false;
            }
            node1 = node1-&gt;next;
            node2 = node2-&gt;next;
        }
        return true;
    }
    
    ListNode* reverseList(ListNode* head)
    {
        ListNode* pre = nullptr;
        ListNode* cur = head;
        ListNode* next;
        while(cur != nullptr)
        {
            next = cur-&gt;next;
            cur-&gt;next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>方法一：将值复制到数组中后用双指针法<br>
直接在链表上操作并不简单，因为不论是正向访问还是反向访问都不是O(1)。而将链表的值复制到数组列表中是 O(n)，因此最简单的方法就是将链表的值复制到数组列表中，再使用双指针法判断。<br>
算法：<br>
我们可以分为两个步骤：<br>
1.复制链表值到数组列表中。<br>
2.使用双指针法判断是否为回文。<br>
第一步，我们需要遍历链表将值复制到数组列表中。我们用 currentNode 指向当前节点。每次迭代向数组添加 currentNode.val，并更新 currentNode = currentNode.next，当 currentNode = null 则停止循环。<br>
执行第二部的最佳方法取决于你使用的变成语言。在 Python 中，很容易构造一个列表的反向副本，也很容易比较两个列表。在其他语言中，就没有那么简单。因此最好使用双指针法来检查是否为回文。我们在起点放置一个指针，在结尾放置一个指针，每一次迭代判断两个指针指向的元素是否相同，若不同，返回 false；相同则将两个指针向内移动，并继续判断，直到相遇。<br>
在编码的过程中，注意我们比较的是节点值的大小，而不是节点本身。正确的比较方式是：node_1.val<mark>node_2.val。而 node_1</mark>node_2 是错误的。</p>
</blockquote>
<pre><code>Java
class Solution {
    public boolean isPalindrome(ListNode head) {
        List&lt;Integer&gt; vals = new ArrayList&lt;&gt;();

        // Convert LinkedList into ArrayList.
        ListNode currentNode = head;
        while (currentNode != null) {
            vals.add(currentNode.val);
            currentNode = currentNode.next;
        }

        // Use two-pointer technique to check for palindrome.
        int front = 0;
        int back = vals.size() - 1;
        while (front &lt; back) {
            // Note that we must use ! .equals instead of !=
            // because we are comparing Integer, not int.
            if (!vals.get(front).equals(vals.get(back))) {
                return false;
            }
            front++;
            back--;
        }
        return true;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)，其中 n 指的是链表的元素个数。<br>
第一步： 遍历链表并将值复制到数组中，O(n)。<br>
第二步：双指针判断是否为回文，执行了 O(n/2) 次的判断，即 O(n)。<br>
总的时间复杂度：O(2n)=O(n)。<br>
空间复杂度：O(n)，其中 n 指的是链表的元素个数，我们使用了一个数组列表存放链表的元素值。</p>
</blockquote>
<blockquote>
<p>方法二：递归<br>
为了想出使用空间复杂度为 O(1) 的解决方案，你可能想过使用递归来解决，但是这仍然是 O(n) 的空间复杂度。让我们来看看为什么不是 O(1) 的空间复杂度。<br>
递归为我们提供了一种优雅的方式来方向遍历节点。</p>
</blockquote>
<pre><code>function print_values_in_reverse(ListNode head)
    if head is NOT null
        print_values_in_reverse(head.next)
        print head.val
</code></pre>
<blockquote>
<p>如果使用递归反向迭代节点，同时使用递归函数外的变量向前迭代，就可以判断链表是否为回文。<br>
算法：<br>
currentNode 指针是先到尾节点，由于递归的特性再从后往前进行比较。  frontPointer 是递归函数外的指针。若 currentNode.val != frontPointer.val 则返回 false。反之，frontPointer 向前移动并返回 true。<br>
之所以起作用的原因是递归处理节点的顺序是相反的（记住上面打印的算法）。由于递归，从本质上，我们同时在正向和逆向迭代。<br>
计算机在递归的过程将使用堆栈的空间，这就是为什么递归并不是 O(1) 的空间复杂度。</p>
</blockquote>
<pre><code>class Solution {

    private ListNode frontPointer;

    private boolean recursivelyCheck(ListNode currentNode) {
        if (currentNode != null) {
            if (!recursivelyCheck(currentNode.next)) return false;
            if (currentNode.val != frontPointer.val) return false;
            frontPointer = frontPointer.next;
        }
        return true;
    }

    public boolean isPalindrome(ListNode head) {
        frontPointer = head;
        return recursivelyCheck(head);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)，其中 n 指的是链表的大小。<br>
空间复杂度：O(n)，其中 n 指的是链表的大小。我们要理解计算机如何运行递归函数，在一个函数中调用一个函数时，计算机需要在进入被调用函数之前跟踪它在当前函数中的位置（以及任何局部变量的值），通过运行时存放在堆栈中来实现（堆栈帧）。在堆栈中存放好了数据后就可以进入被调用的函数。在完成被调用函数之后，他会弹出堆栈顶部元素，以恢复在进行函数调用之前所在的函数。在进行回文检查之前，递归函数将在堆栈中创建 n 个堆栈帧，计算机会逐个弹出进行处理。所以在使用递归时要考虑堆栈的使用情况。<br>
这种方法不仅使用了O(n) 的空间，且比第一种方法更差，因为在许多语言中，堆栈帧很大（如 Python），并且最大的运行时堆栈深度为 1000（可以增加，但是有可能导致底层解释程序内存出错）。为每个节点创建堆栈帧极大的限制了算法能够处理的最大链表大小。</p>
</blockquote>
<blockquote>
<p>方法三：<br>
避免使用 O(n) 额外空间的方法就是改变输入。<br>
我们可以将链表的后半部分反转（修改链表结构），然后将前半部分和后半部分进行比较。比较完成后我们应该将链表恢复原样。虽然不需要恢复也能通过测试用例，因为使用该函数的人不希望链表结构被更改。<br>
算法：<br>
我们可以分为以下几个步骤：<br>
1.找到前半部分链表的尾节点。<br>
2.反转后半部分链表。<br>
3.判断是否为回文。<br>
4.恢复链表。<br>
6.返回结果。<br>
执行步骤一，我们可以计算链表节点的数量，然后遍历链表找到前半部分的尾节点。<br>
或者可以使用快慢指针在一次遍历中找到：慢指针一次走一步，快指针一次走两步，快慢指针同时出发。当快指针移动到链表的末尾时，慢指针到链表的中间。通过慢指针将链表分为两部分。<br>
若链表有奇数个节点，则中间的节点应该看作是前半部分。<br>
步骤二可以使用在反向链表问题中找到解决方法来反转链表的后半部分。<br>
步骤三比较两个部分的值，当后半部分到达末尾则比较完成，可以忽略计数情况中的中间节点。<br>
步骤四与步骤二使用的函数相同，再反转一次恢复链表本身。</p>
</blockquote>
<pre><code>Java
class Solution {

    public boolean isPalindrome(ListNode head) {

        if (head == null) return true;

        // Find the end of first half and reverse second half.
        ListNode firstHalfEnd = endOfFirstHalf(head);
        ListNode secondHalfStart = reverseList(firstHalfEnd.next);

        // Check whether or not there is a palindrome.
        ListNode p1 = head;
        ListNode p2 = secondHalfStart;
        boolean result = true;
        while (result &amp;&amp; p2 != null) {
            if (p1.val != p2.val) result = false;
            p1 = p1.next;
            p2 = p2.next;
        }        

        // Restore the list and return the result.
        firstHalfEnd.next = reverseList(secondHalfStart);
        return result;
    }

    // Taken from https://leetcode.com/problems/reverse-linked-list/solution/
    private ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode curr = head;
        while (curr != null) {
            ListNode nextTemp = curr.next;
            curr.next = prev;
            prev = curr;
            curr = nextTemp;
        }
        return prev;
    }

    private ListNode endOfFirstHalf(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        while (fast.next != null &amp;&amp; fast.next.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        return slow;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)，其中 n 指的是链表的大小。<br>
空间复杂度：O(1)，我们是一个接着一个的改变指针，我们在堆栈上的堆栈帧不超过 O(1)。<br>
该方法的缺点是，在并发环境下，函数运行时需要锁定其他线程或进程对链表的访问，因为在函数执执行过程中链表暂时断开。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[无锁队列的实现]]></title>
        <id>https://lixin-scut.github.io//post/wu-suo-dui-lie-de-shi-xian</id>
        <link href="https://lixin-scut.github.io//post/wu-suo-dui-lie-de-shi-xian">
        </link>
        <updated>2020-04-10T01:28:29.000Z</updated>
        <content type="html"><![CDATA[<p>  总体思想就是基于CAS保证操作的原子性，然后在入队和出队时分别通过对队列的尾节点和头节点进行判断，仅仅在符合条件的时候进行插入和删除，从而达到不需要加锁的目的。</p>
<p>详细：<br>
  转载自陈皓的<a href="https://coolshell.cn/articles/8239.html">无锁队列的实现</a>，但是其中有一些细节的错误，我特意进行了修正或注释</p>
<h3 id="关于cas等原子操作">关于CAS等原子操作</h3>
<p>  在开始说无锁队列之前，我们需要知道一个很重要的技术就是CAS操作——Compare &amp; Set，或是 Compare &amp; Swap，现在几乎所有的CPU指令都支持CAS的原子操作，X86下对应的是 CMPXCHG 汇编指令。有了这个原子操作，我们就可以用其来实现各种无锁（lock free）的数据结构。</p>
<p>  这个操作用C语言来描述就是下面这个样子：（代码来自Wikipedia的Compare And Swap词条）意思就是说，看一看内存reg里的值<code>*reg</code>是不是<code>oldval</code>，如果是的话，则对其赋值<code>newval</code>。</p>
<pre><code>int compare_and_swap (int* reg, int oldval, int newval)
{
  int old_reg_val = *reg;
  if (old_reg_val == oldval) {
     *reg = newval;
  }
  return old_reg_val;
}
</code></pre>
<p>  我们可以看到，<code>old_reg_val</code> 总是返回，于是，我们可以在 <code>compare_and_swap</code> 操作之后对其进行测试，以查看它是否与 <code>oldval</code>相匹配，因为它可能有所不同，这意味着<strong>另一个并发线程已成功地竞争</strong>到 <code>compare_and_swap</code> 并成功将<code>reg</code>值从<code>oldval</code>更改为别的值了。</p>
<p>  这个操作可以变种为返回bool值的形式（返回 bool值的好处在于，可以调用者直接知道有没有更新成功）：</p>
<pre><code>bool compare_and_swap (int *addr, int oldval, int newval)
{
  if ( *addr != oldval ) {
      return false;
  }
  *addr = newval;
  return true;
}
</code></pre>
<p>与CAS相似的还有下面的原子操作：</p>
<ol>
<li>Fetch And Add，一般用来对变量做 +1 的原子操作</li>
<li>Test-and-set，写值到某个内存位置并传回其旧值。汇编指令BST</li>
<li>Test and Test-and-set，用来低低Test-and-Set的资源争夺情况</li>
</ol>
<p>注：在实际的C/C++程序中，CAS的各种实现版本如下：</p>
<ol>
<li>GCC的CAS</li>
</ol>
<p>GCC4.1+版本中支持CAS的原子操作（完整的原子操作可参看 GCC Atomic Builtins）</p>
<pre><code>bool __sync_bool_compare_and_swap (type *ptr, type oldval type newval, ...)
type __sync_val_compare_and_swap (type *ptr, type oldval type newval, ...)
</code></pre>
<ol start="2">
<li>Windows的CAS</li>
</ol>
<p>  在Windows下，你可以使用下面的Windows API来完成CAS：（完整的Windows原子操作可参看MSDN的InterLocked Functions）</p>
<pre><code> InterlockedCompareExchange ( __inout LONG volatile *Target,
                                 __in LONG Exchange,
                                 __in LONG Comperand);
</code></pre>
<ol start="3">
<li>C++11中的CAS</li>
</ol>
<p>  C++11中的STL中的atomic类的函数可以让你跨平台。（完整的C++11的原子操作可参看 Atomic Operation Library）</p>
<pre><code>template&lt; class T &gt;
bool atomic_compare_exchange_weak( std::atomic* obj,
                                   T* expected, T desired );
template&lt; class T &gt;
bool atomic_compare_exchange_weak( volatile std::atomic* obj,
                                   T* expected, T desired );
</code></pre>
<p><code>atomic_compare_exchange_weak</code><br>
  比较并交换被封装的值(weak)与参数 expected 所指定的值是否相等，如果：</p>
<ol>
<li>相等，则用 val 替换原子对象的旧值。</li>
<li>不相等，则用原子对象的旧值替换 expected ，因此调用该函数之后，如果被该原子对象封装的值与参数 expected 所指定的值不相等，expected 中的内容就是原子对象的旧值。<br>
  该函数通常会读取原子对象封装的值，如果比较为 true(即原子对象的值等于 expected)，则替换原子对象的旧值，但整个操作是原子的，在某个线程读取和修改该原子对象时，另外的线程不能对读取和修改该原子对象。</li>
</ol>
<p>  注意，该函数直接比较原子对象所封装的值与参数 expected 的物理内容，所以某些情况下，对象的比较操作在使用 operator==() 判断时相等，但 compare_exchange_weak 判断时却可能失败，因为对象底层的物理内容中可能存在位对齐或其他逻辑表示相同但是物理表示不同的值(比如 true 和 2 或 3，它们在逻辑上都表示&quot;真&quot;，但在物理上两者的表示并不相同)。</p>
<p>  与compare_exchange_strong 相比, weak 版本的 compare-and-exchange 操作允许(spuriously 地)返回 false(即原子对象所封装的值与参数 expected 的物理内容相同，但却仍然返回 false)，不过在某些需要循环操作的算法下这是可以接受的，并且在一些平台下 compare_exchange_weak 的性能更好 。如果 compare_exchange_weak 的判断确实发生了伪失败(spurious failures)——即使原子对象所封装的值与参数 expected 的物理内容相同，但判断操作的结果却为 false，compare_exchange_weak函数返回 false，并且参数 expected 的值不会改变。<br>
  与compare_exchange_weak 相比, strong版本的 compare-and-exchange 操作不允许(spuriously 地)返回 false，即原子对象所封装的值与参数 expected 的物理内容相同，比较操作一定会为 true。不过在某些平台下，如果算法本身需要循环操作来做检查， compare_exchange_weak 的性能会更好。</p>
<p>  所以对于某些不需要采用循环操作的算法而言, 通常采用compare_exchange_strong 更好。</p>
<h3 id="无锁队列的链表实现">无锁队列的链表实现</h3>
<p>下面的代码主要参考于两篇论文：</p>
<p>  John D. Valois 1994年10月在拉斯维加斯的并行和分布系统系统国际大会上的一篇论文——《Implementing Lock-Free Queues》<br>
  美国纽约罗切斯特大学 Maged M. Michael 和 Michael L. Scott 在1996年3月发表的一篇论文 《Simple, Fast, and Practical Non-Blocking and Blocking ConcurrentQueue Algorithms》<br>
（注：下面的代码并不完全与这篇论文相同）</p>
<p>  初始化一个队列的代码很简，初始化一个dummy结点（注：在链表操作中，使用一个dummy结点，可以少掉很多边界条件的判断），如下所示：</p>
<pre><code>InitQueue(Q)
{
    node = new node()
    node-&gt;next = NULL;
    Q-&gt;head = Q-&gt;tail = node;
}
</code></pre>
<p>我们先来看一下进队列用CAS实现的方式，基本上来说就是链表的两步操作：</p>
<p>第一步，把tail指针的next指向要加入的结点。 tail-&gt;next = p;<br>
第二步，把tail指针移到队尾。 tail = p;</p>
<pre><code>EnQueue(Q, data) //进队列
{
    //准备新加入的结点数据
    n = new node();
    n-&gt;value = data;
    n-&gt;next = NULL;
    do {
        p = Q-&gt;tail; //取链表尾指针的快照
    } while( CAS(p-&gt;next, NULL, n) != TRUE); 
    //while条件注释：如果没有把结点链在尾指针上，再试
    CAS(Q-&gt;tail, p, n); //置尾结点 tail = n;
}
</code></pre>
<p>  我们可以看到，程序中的那个 do-while 的 Retry-Loop 中的 CAS 操作：如果 p-&gt;next 是 NULL，那么，把新结点 n 加到队尾。如果不成功，则重新再来一次！</p>
<p>  就是说，很有可能我在准备在队列尾加入结点时，别的线程已经加成功了，于是tail指针就变了，于是我的CAS返回了false，于是程序再试，直到试成功为止。这个很像我们的抢电话热线的不停重播的情况。</p>
<p>  但是你会看到，为什么我们的“置尾结点”的操作（第13行）不判断是否成功，因为：</p>
<p>  如果有一个线程T1，它的while中的CAS如果成功的话，那么其它所有的 随后线程的CAS都会失败，然后就会再循环，<br>
  此时，如果T1 线程还没有更新tail指针，其它的线程继续失败，因为tail-&gt;next不是NULL了。<br>
  直到T1线程更新完 tail 指针，于是其它的线程中的某个线程就可以得到新的 tail 指针，继续往下走了。<br>
  所以，只要线程能从 while 循环中退出来，意味着，它已经“独占”了，tail 指针必然可以被更新。<br>
  这里有一个潜在的问题——<strong>如果T1线程在用CAS更新tail指针的之前，线程停掉或是挂掉了，那么其它线程就进入死循环了。</strong> 下面是改良版的EnQueue()</p>
<pre><code>EnQueue(Q, data) //进队列改良版 v1
{
    n = new node();
    n-&gt;value = data;
    n-&gt;next = NULL;
    p = Q-&gt;tail;
    oldp = p
    do {
        while (p-&gt;next != NULL)
            p = p-&gt;next;
    } while( CAS(p.next, NULL, n) != TRUE); //如果没有把结点链在尾上，再试
    CAS(Q-&gt;tail, oldp, n); //置尾结点
}
</code></pre>
<p>  我们让每个线程，自己fetch 指针 p 到链表尾。但是这样的fetch会很影响性能。而且，如果一个线程不断的EnQueue，会导致所有的其它线程都去 fetch 他们的 p 指针到队尾，能不能不要所有的线程都干同一个事？这样可以节省整体的时间？</p>
<p>  比如：直接 fetch Q-&gt;tail 到队尾？因为，所有的线程都共享着 Q-&gt;tail，所以，一旦有人动了它后，相当于其它的线程也跟着动了，于是，我们的代码可以改进成如下的实现：</p>
<pre><code>EnQueue(Q, data) //进队列改良版 v2 
{
    n = new node();
    n-&gt;value = data;
    n-&gt;next = NULL;
    while(TRUE) {
        //先取一下尾指针和尾指针的next
        tail = Q-&gt;tail;
        next = tail-&gt;next;
        //如果尾指针已经被移动了，则重新开始
        if ( tail != Q-&gt;tail ) continue;
        //如果尾指针的 next 不为NULL，则 fetch 全局尾指针到next
        if ( next != NULL ) {
            CAS(Q-&gt;tail, tail, next);
            continue;
        }
        //如果加入结点成功，则退出
        if ( CAS(tail-&gt;next, next, n) == TRUE ) break;
    }
    CAS(Q-&gt;tail, tail, n); //置尾结点
}
</code></pre>
<p>  上述的代码还是很清楚的，相信你一定能看懂，而且，这也是 Java 中的 ConcurrentLinkedQueue 的实现逻辑，当然，我上面的这个版本比 Java 的好一点，因为没有 if 嵌套，嘿嘿。</p>
<p>  好了，我们解决了EnQueue，我们再来看看DeQueue的代码：（很简单，我就不解释了）</p>
<pre><code>DeQueue(Q) //出队列
{
    do{
        p = Q-&gt;head;
        if (p-&gt;next == NULL){
            return ERR_EMPTY_QUEUE;
        }
    while( CAS(Q-&gt;head, p, p-&gt;next) != TRUE );
    return p-&gt;next-&gt;value;
}
</code></pre>
<p>  <strong>我们可以看到，DeQueue的代码操作的是 head-&gt;next，而不是 head 本身。这样考虑是因为一个边界条件，我们需要一个dummy的头指针来解决链表中如果只有一个元素，head 和 tail 都指向同一个结点的问题，这样 EnQueue 和 DeQueue 要互相排斥了。</strong></p>
<p>  但是，如果 head 和 tail 都指向同一个结点，这意味着队列为空，应该返回 ERR_EMPTY_QUEUE，但是，在判断 p-&gt;next == NULL 时，另外一个EnQueue操作做了一半，此时的 p-&gt;next 不为 NULL了，但是 tail 指针还差最后一步，没有更新到新加的结点，这个时候就会出现，在 EnQueue 并没有完成的时候， DeQueue 已经把新增加的结点给取走了，此时，队列为空，但是，head 与 tail 并没有指向同一个结点。如下所示：<br>
<img src="https://lixin-scut.github.io//post-images/1586482257913.png" alt=""><br>
  虽然，EnQueue的函数会把 tail 指针置对，但是，这种情况可能还是会导致一些并发问题，所以，严谨来说，我们需要避免这种情况。于是，我们需要加入更多的判断条件，还确保这个问题。下面是相关的改进代码：</p>
<pre><code>DeQueue(Q) //出队列，改进版
{
    while(TRUE) {
        //取出头指针，尾指针，和第一个元素的指针
        head = Q-&gt;head;
        tail = Q-&gt;tail;
        next = head-&gt;next;
        // Q-&gt;head 指针已移动，重新取 head指针
        if ( head != Q-&gt;head ) continue;
        
        // 如果是空队列
        if ( head == tail &amp;&amp; next == NULL ) {
            return ERR_EMPTY_QUEUE;
        }
        
        //如果 tail 指针落后了
        if ( head == tail &amp;&amp; next == NULL ) {
            CAS(Q-&gt;tail, tail, next);
            continue;
        }
        //移动 head 指针成功后，取出数据
        if ( CAS( Q-&gt;head, head, next) == TRUE){
            value = next-&gt;value;
            break;
        }
    }
    free(head); //释放老的dummy结点
    return value;
}
</code></pre>
<p>  上面这段代码的逻辑和 Java 的 ConcurrentLinkedQueue 的 poll 方法很一致了。也是《Simple, Fast, and Practical Non-Blocking and Blocking ConcurrentQueue Algorithms》这篇论文中的实现。</p>
<h3 id="cas的aba问题">CAS的ABA问题</h3>
<p>所谓ABA问题基本是这个样子：</p>
<ol>
<li>进程P1在共享变量中读到值为A</li>
<li>P1被抢占了，进程P2执行</li>
<li>P2把共享变量里的值从A改成了B，再改回到A，此时被P1抢占。</li>
<li>P1回来看到共享变量里的值没有被改变，于是继续执行。<br>
  虽然P1以为变量值没有改变，继续执行了，但是这个会引发一些潜在的问题。<strong>ABA问题最容易发生在lock free 的算法中的，CAS首当其冲，因为CAS判断的是指针的值。很明显，值是很容易又变成原样的。</strong></li>
</ol>
<p>  比如上述的DeQueue()函数，因为我们要让head和tail分开，所以我们引入了一个dummy指针给head，当我们做CAS的之前，如果head的那块内存被回收并被重用了，而重用的内存又被EnQueue()进来了，这会有很大的问题。（<strong>内存管理中重用内存基本上是一种很常见的行为</strong>）</p>
<p>这个例子你可能没有看懂，维基百科上给了一个活生生的例子——</p>
<blockquote>
<p>你拿着一个装满钱的手提箱在飞机场，此时过来了一个火辣性感的美女，然后她很暖昧地挑逗着你，并趁你不注意的时候，把用一个一模一样的手提箱和你那装满钱的箱子调了个包，然后就离开了，你看到你的手提箱还在那，于是就提着手提箱去赶飞机去了。</p>
</blockquote>
<p>这就是ABA的问题。</p>
<h3 id="解决aba的问题">解决ABA的问题</h3>
<p>  维基百科上给了一个解——使用double-CAS（双保险的CAS），例如，在32位系统上，我们要检查64位的内容</p>
<ol>
<li>
<p>一次用CAS检查双倍长度的值，前半部是值，后半部分是一个计数器。</p>
</li>
<li>
<p>只有这两个都一样，才算通过检查，要吧赋新的值。并把计数器累加1。</p>
</li>
</ol>
<p>  这样一来，ABA发生时，虽然值一样，但是计数器就不一样（但是在32位的系统上，这个计数器会溢出回来又从1开始的，这还是会有ABA的问题）</p>
<p>  当然，我们这个队列的问题就是不想让那个内存重用，这样明确的业务问题比较好解决，论文《Implementing Lock-Free Queues》给出一这么一个方法——<strong>使用结点内存引用计数refcnt</strong>！（论文《Simple, Fast, and Practical Non-Blocking and Blocking ConcurrentQueue Algorithms》中的实现方法也基本上是一样的，用到的是增加一个计数，可以理解为版本号）</p>
<p>）</p>
<pre><code>SafeRead(q)
{
    loop:
        p = q-&gt;next;
        if (p == NULL){
            return p;
        }
        Fetch&amp;Add(p-&gt;refcnt, 1);
        if (p == q-&gt;next){
            return p;
        }else{
            Release(p);
        }
    goto loop;
}
</code></pre>
<p>  其中的 Fetch&amp;Add和Release分是是加引用计数和减引用计数，都是原子操作，这样就可以阻止内存被回收了。</p>
<h3 id="用数组实现无锁队列">用数组实现无锁队列</h3>
<p>本实现来自论文《Implementing Lock-Free Queues》</p>
<p>  使用数组来实现队列是很常见的方法，因为没有内存的分部和释放，一切都会变得简单，实现的思路如下：</p>
<ol>
<li>
<p>数组队列应该是一个ring buffer形式的数组（环形数组）</p>
</li>
<li>
<p>数组的元素应该有三个可能的值：HEAD，TAIL，EMPTY（当然，还有实际的数据）</p>
</li>
<li>
<p>数组一开始全部初始化成EMPTY，有两个相邻的元素要初始化成HEAD和TAIL，这代表空队列。</p>
</li>
<li>
<p>EnQueue操作。假设数据x要入队列，定位TAIL的位置，使用double-CAS方法把(TAIL, EMPTY) 更新成 (x, TAIL)。需要注意，如果找不到(TAIL, EMPTY)，则说明队列满了。</p>
</li>
<li>
<p>DeQueue操作。定位HEAD的位置，把(HEAD, x)更新成(EMPTY, HEAD)，并把x返回。同样需要注意，如果x是TAIL，则说明队列为空。</p>
</li>
</ol>
<p>算法的一个关键是——如何定位HEAD或TAIL？</p>
<ol>
<li>
<p>我们可以声明两个计数器，一个用来计数EnQueue的次数，一个用来计数DeQueue的次数。</p>
</li>
<li>
<p>这两个计算器使用使用Fetch&amp;ADD来进行原子累加，在EnQueue或DeQueue完成的时候累加就好了。</p>
</li>
<li>
<p>累加后求个模什么的就可以知道TAIL和HEAD的位置了。</p>
</li>
</ol>
<p>如下图所示：<br>
<img src="https://lixin-scut.github.io//post-images/1586482291190.png" alt=""></p>
<h3 id="小结">小结</h3>
<p>以上基本上就是所有的无锁队列的技术细节，这些技术都可以用在其它的无锁数据结构上。</p>
<ol>
<li>
<p>无锁队列主要是通过CAS、FAA这些原子操作，和Retry-Loop实现。</p>
</li>
<li>
<p>对于Retry-Loop，我个人感觉其实和锁什么什么两样。只是这种“锁”的粒度变小了，主要是“锁”HEAD和TAIL这两个关键资源。而不是整个数据结构。</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 849. 到最近的人的最大距离[简单]]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-849-dao-zui-jin-de-ren-de-zui-da-ju-chi-jian-dan</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-849-dao-zui-jin-de-ren-de-zui-da-ju-chi-jian-dan">
        </link>
        <updated>2020-04-08T08:22:49.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>在一排座位（ seats）中，1 代表有人坐在座位上，0 代表座位上是空的。<br>
至少有一个空座位，且至少有一人坐在座位上。<br>
亚历克斯希望坐在一个能够使他与离他最近的人之间的距离达到最大化的座位上。<br>
返回他到离他最近的人的最大距离。<br>
示例 1：<br>
输入：[1,0,0,0,1,0,1]<br>
输出：2<br>
解释：<br>
如果亚历克斯坐在第二个空位（seats[2]）上，他到离他最近的人的距离为 2 。<br>
如果亚历克斯坐在其它任何一个空位上，他到离他最近的人的距离为 1 。<br>
因此，他到离他最近的人的最大距离是 2 。<br>
示例 2：<br>
输入：[1,0,0,0]<br>
输出：3<br>
解释：<br>
如果亚历克斯坐在最后一个座位上，他离最近的人有 3 个座位远。<br>
这是可能的最大距离，所以答案是 3 。<br>
提示：<br>
1 &lt;= seats.length &lt;= 20000<br>
seats 中只含有 0 和 1，至少有一个 0，且至少有一个 1。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/maximize-distance-to-closest-person<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>第一想法就是寻找最大的连续0的数量，然后取其中点吧</p>
<p>然后发现不对劲啊，比如示例二，在边缘的0没必要取中点啊。<br>
所以我针对边缘进行单独提取，使用left和right两个下标先检测两边的连续0的数量，再检测中间的连续0的数量</p>
<p>实现过程中需要注意的事项</p>
<ol>
<li>注意好初始化和重新赋值</li>
<li>中间的连续0的数量对于maxZeros的更新的规律为(zeroCounts + 1) / 2</li>
</ol>
<p>时间复杂度是O(n)，因为每个元素最多只被访问一次。</p>
<pre><code>class Solution {
public:
    int maxDistToClosest(vector&lt;int&gt;&amp; seats) {
        if(seats.empty())
        {   return 0;}
        
        int maxZeros = 0;
        int zeroCounts = 0;
        
        int left = 0;
        int right = seats.size() - 1;
        while(seats[left] == 0)
        {
            ++zeroCounts;
            maxZeros = maxZeros &gt; zeroCounts ? maxZeros : zeroCounts; 
            ++left;
        }
        
        zeroCounts = 0;
        while(seats[right] == 0)
        {
            ++zeroCounts;
            maxZeros = maxZeros &gt; zeroCounts ? maxZeros : zeroCounts; 
            --right;
        }
        
        for(int i = left; i &lt; right; ++i)
        {
            if(seats[i] == 1)
            {
                zeroCounts = 0;
            }
            if(seats[i] == 0)
            {
                ++zeroCounts;
                maxZeros = maxZeros &gt; (zeroCounts + 1) / 2 ? maxZeros : (zeroCounts + 1) / 2;
            }
        }
        return maxZeros;
    }
};
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>方法一：计算座位到最近的人的最大距离【通过】<br>
思路<br>
令 left[i] 为座位 i 到坐在 i 左边的人的最近距离。同理 right[i] 为座位 i 到坐在 i 右边的人的最近距离。那么该座位到最近的人的距离为 min(left[i], right[i])。<br>
算法<br>
如果 i 左边的位置是空的，那么 left[i] = left[i - 1] + 1；否则 left[i] = 0。right[i] 的计算方法类似。</p>
</blockquote>
<pre><code>class Solution {
    public int maxDistToClosest(int[] seats) {
        int N = seats.length;
        int[] left = new int[N], right = new int[N];
        Arrays.fill(left, N);
        Arrays.fill(right, N);

        for (int i = 0; i &lt; N; ++i) {
            if (seats[i] == 1) left[i] = 0;
            else if (i &gt; 0) left[i] = left[i-1] + 1;
        }

        for (int i = N-1; i &gt;= 0; --i) {
            if (seats[i] == 1) right[i] = 0;
            else if (i &lt; N-1) right[i] = right[i+1] + 1;
        }

        int ans = 0;
        for (int i = 0; i &lt; N; ++i)
            if (seats[i] == 0)
                ans = Math.max(ans, Math.min(left[i], right[i]));
        return ans;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(N)，其中 N 是 seats 的长度。<br>
空间复杂度：O(N)，存储 left 和 right 的空间。</p>
</blockquote>
<blockquote>
<p>方法二：双指针【通过】<br>
思路<br>
遍历所有座位 seats，找出每个空位左边最近的人和右边最近的人，更新当前空位到最近的人的距离。<br>
算法<br>
使用 prev 记录 i 最左边第一个有人的位置，future 记录 i 最右边第一个有人的位置。<br>
座位 i 到最近的人的距离为 min(i - prev, future - i)。另外有一种特殊情况，如果座位 i 左边没有人，则认为到左边第一个人的距离是无限大，右边同理。</p>
</blockquote>
<pre><code>class Solution {
    public int maxDistToClosest(int[] seats) {
        int N = seats.length;
        int prev = -1, future = 0;
        int ans = 0;

        for (int i = 0; i &lt; N; ++i) {
            if (seats[i] == 1) {
                prev = i;
            } else {
                while (future &lt; N &amp;&amp; seats[future] == 0 || future &lt; i)
                    future++;

                int left = prev == -1 ? N : i - prev;
                int right = future == N ? N : future - i;
                ans = Math.max(ans, Math.min(left, right));
            }
        }

        return ans;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(N)，其中 N 是 seats 的长度。<br>
空间复杂度：O(1)。</p>
</blockquote>
<blockquote>
<p>方法三：按零分组【通过】<br>
思路<br>
如果两人之间有连续 K 个空座位，那么其中存在至少一个座位到两边最近的人的距离为 (K+1) / 2。<br>
算法<br>
假设两个人之间有 K 个空座位，则存在座位到最近的人的距离为 (K+1) / 2。<br>
对于边缘的座位，它们的一侧没有人，那么认为它们到该侧最近的人的距离为 K。</p>
</blockquote>
<pre><code>class Solution {
    public int maxDistToClosest(int[] seats) {
        int N = seats.length;
        int K = 0; //current longest group of empty seats
        int ans = 0;

        for (int i = 0; i &lt; N; ++i) {
            if (seats[i] == 1) {
                K = 0;
            } else {
                K++;
                ans = Math.max(ans, (K + 1) / 2);
            }
        }

        for (int i = 0; i &lt; N; ++i)  if (seats[i] == 1) {
            ans = Math.max(ans, i);
            break;
        }

        for (int i = N-1; i &gt;= 0; --i)  if (seats[i] == 1) {
            ans = Math.max(ans, N - 1 - i);
            break;
        }

        return ans;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(N)，其中 N 是 seats 的长度。<br>
空间复杂度：O(1)。在 Python中 seats[::-1] 的空间为 O(N)，但它可以被省略。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 174:地下城游戏[困难][未做出]]]></title>
        <id>https://lixin-scut.github.io//post/dong-tai-gui-hua-174di-xia-cheng-you-xi-kun-nan-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/dong-tai-gui-hua-174di-xia-cheng-you-xi-kun-nan-wei-zuo-chu">
        </link>
        <updated>2020-04-07T09:50:08.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。<br>
骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。<br>
有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。<br>
为了尽快到达公主，骑士决定每次只向右或向下移动一步。<br>
编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。<br>
例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -&gt; 右 -&gt; 下 -&gt; 下，则骑士的初始健康点数至少为 7。</p>
</blockquote>
<table>
<thead>
<tr>
<th>-</th>
<th>-</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>-2 (K)</td>
<td>-3</td>
<td>3</td>
</tr>
<tr>
<td>-5</td>
<td>-10</td>
<td>1</td>
</tr>
<tr>
<td>10</td>
<td>30</td>
<td>-5 (P)</td>
</tr>
</tbody>
</table>
<blockquote>
<p>说明:<br>
骑士的健康点数没有上限。<br>
任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/dungeon-game<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>解题思路：<br>
很明显的动态规划<br>
而且规定了每次只向右或向下移动一步<br>
这个状态转移比较有趣，选的是top和left两者最大的值，而不是最小值，再倒推健康点数<br>
然后按照上次的官方题解，可以原地修改值，而不用新建一个容器</p>
<p>做完我才发现我理解错题意了。。。其实是记录每条路径的负数的最小值。。。再从中选出最大值<br>
我暂时的想法是用一个pair记录每个格子当前值和曾经的最小值，因为动态规划需要当前值，最终结果则需要最小值<br>
状态方程改为 判断最小值的最大者，而不是当前值的最大者<br>
后来修改了注意，不用pair，而是使用修改原vector+记录最小值的vector的模式</p>
<p>然后发现这个方法是错误的<br>
一个比较极端的情况是 {{0, -100, 200}, {0,0,0}} 和 {{0, -100, 200}, {0, -1, -100}}。<br>
很明显前者需要比较最小值（hpMap），而后者需要比较当前值（dungeon）</p>
<p>直接看题解吧<br>
发现问题所在了，应该逆向思维，从后往前推<br>
然后每个点根据当前的值来确定，如果当前值为正数，则置为0，为负数则直接翻转<br>
然后每个值的当前值等于right和bottom的最小值（注意此时是正值），再减去当前值（注意是减去，等于翻转）<br>
得到的就是正的血量<br>
记得最后要+1.</p>
<pre><code>class Solution {
public:
    int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon)
    {
        if(dungeon.empty())
        {   return 0;}
        
        //vector&lt;vector&lt;int&gt;&gt; hpMap(dungeon.begin(), dungeon.end());
        
        for(int row = dungeon.size() - 1; row &gt;= 0; --row)
        {
            for(int col = dungeon[0].size() - 1; col &gt;= 0; --col)
            {
                if(row == dungeon.size() - 1 &amp;&amp; col == dungeon[0].size() - 1)
                {
                    dungeon[row][col] = max(0, -dungeon[row][col]);
                    continue;
                }
                
                if(row == dungeon.size() - 1)
                {
                    int hpMin = dungeon[row][col + 1] - dungeon[row][col];
                    dungeon[row][col] = max(0, hpMin);
                    continue;
                }
                if(col == dungeon[0].size() - 1)
                {
                    int hpMin = dungeon[row + 1][col] - dungeon[row][col];
                    dungeon[row][col] = max(0, hpMin);
                    continue;
                }
                
                int hpMin = min(dungeon[row][col + 1], dungeon[row + 1][col]) - dungeon[row][col];
                dungeon[row][col] = max(0, hpMin);
            }
        }
        return dungeon[0][0] + 1;
    }
    
    /*
    错误代码
    int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon) {
        if(dungeon.empty())
        {   return 0;}
        
        vector&lt;vector&lt;int&gt;&gt; hpMap(dungeon.begin(), dungeon.end());
        
        for(int row = 0; row &lt; dungeon.size(); ++row)
        {
            for(int col = 0; col &lt; dungeon[0].size(); ++col)
            {
                if(row == 0 &amp;&amp; col == 0)
                {
                    continue;
                }               
                else if(row == 0)
                {
                    dungeon[row][col] += dungeon[row][col - 1];
                    hpMap[row][col] = hpMap[row][col - 1];
                    hpMap[row][col] = hpMap[row][col] &lt; dungeon[row][col] ? hpMap[row][col] : dungeon[row][col];
                    continue;
                }
                else if(col == 0)
                {
                    dungeon[row][col] += dungeon[row - 1][col];
                    hpMap[row][col] = hpMap[row - 1][col];
                    hpMap[row][col] = hpMap[row][col] &lt; dungeon[row][col] ? hpMap[row][col] : dungeon[row][col];
                    continue;
                }
                else
                {
                    
                    if(hpMap[row][col - 1]  ==  hpMap[row - 1][col])
                    {
                         dungeon[row][col] += dungeon[row][col - 1] &gt; dungeon[row - 1][col] ? dungeon[row][col - 1] : dungeon[row - 1][col];
                         hpMap[row][col] = hpMap[row][col - 1] &lt; dungeon[row][col] ? hpMap[row][col - 1] : dungeon[row][col];
                    }
                    else
                    {
                        dungeon[row][col] += hpMap[row][col - 1] &gt; hpMap[row - 1][col] ? dungeon[row][col - 1] : dungeon[row - 1][col];
                        hpMap[row][col] = hpMap[row][col - 1] &gt; hpMap[row - 1][col] ? hpMap[row][col - 1] : hpMap[row - 1][col];
                        hpMap[row][col] = hpMap[row][col] &lt; dungeon[row][col] ? hpMap[row][col] : dungeon[row][col];
                    }
                }
            }
        }
        
        return hpMap.back().back() &gt;= 0 ? 1 : -hpMap.back().back() + 1;
    }
    */
};
</code></pre>
<p>网友题解：<br>
<a href="https://leetcode-cn.com/problems/dungeon-game/solution/cong-hui-su-dao-ji-yi-hua-sou-suo-dao-dong-tai-gui/">从回溯 到 记忆化搜索 到 动态规划</a></p>
<p>动态规划</p>
<blockquote>
<p>我们的动态规划是从最后一个开始走的，每走一步，出来就记录一下，然后不断复用。<br>
其实核心的公式我们已经知道了，也就是最优子结构：<br>
<code>needMin + globalDun[i][j] = Math.min(dp[i + 1][j], dp[i][j + 1])</code><br>
其实这段代码：</p>
</blockquote>
<pre><code>if (needMin &lt; 0) {  
	res =  0;
} else {
	res =  needMin;
}
</code></pre>
<blockquote>
<p>可以等价于下面这段：<br>
<code>dp[i][j] = Math.max(0, needMin);</code><br>
所以我们可以来看下这个代码：</p>
</blockquote>
<pre><code>public int calculateMinimumHPBest(int[][] dungeon) {
    if (dungeon == null || dungeon.length == 0 || dungeon[0].length == 0) {
        return 0;
    }
    int rowSize = dungeon.length;
    int colSize = dungeon[0].length;
    int[][] dp = new int[rowSize][colSize];
    // 设置最后一个值。
  	dp[rowSize - 1][colSize -1] = Math.max(0, -dungeon[rowSize - 1][colSize - 1]);

    // 设置最后一列的值
  	for (int i = rowSize - 2; i &gt;= 0; --i) {
        int needMin = dp[i + 1][colSize - 1] - dungeon[i][colSize - 1];
        dp[i][colSize -1] = Math.max(0, needMin);
    }

    // 设置最后一行的值
  	for (int i = colSize - 2; i &gt;= 0; --i) {
        int needMin = dp[rowSize - 1][i + 1] - dungeon[rowSize - 1][i];
        dp[rowSize - 1][i] = Math.max(0, needMin);
    }

    for (int i = rowSize - 2; i &gt;= 0; --i) {
        for (int j = colSize - 2; j &gt;= 0; --j) {
			// 从右边和下边选择一个最小值，然后减去当前的 dungeon 值
            int needMin = Math.min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j];
            dp[i][j] = Math.max(0, needMin);
        }
    }
    return dp[0][0] + 1;
}
</code></pre>
<blockquote>
<p>时间复杂度O(N),空间复杂度O(N)。</p>
</blockquote>
<p>网友题解可以进一步压缩空间复杂度，首先可以改为一维数组暂存，然后对比网友题解，我直接使用了原数组进行修改，所以空间复杂度为O(1)。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[atomic类型]]></title>
        <id>https://lixin-scut.github.io//post/atomic-lei-xing</id>
        <link href="https://lixin-scut.github.io//post/atomic-lei-xing">
        </link>
        <updated>2020-04-07T02:50:32.000Z</updated>
        <content type="html"><![CDATA[<p>首先从一个问题开始：</p>
<blockquote>
<p>自增++i是否是原子操作<br>
两种解释：<br>
1.++i的操作分三步：<br>
（1）栈中取出i<br>
（2）i自增1<br>
（3）将i存到栈<br>
2.++i分为三个阶段：<br>
（1）内存读入到寄存器<br>
（2）寄存器自增<br>
（3）存入内存<br>
这三个阶段中间都可以被中断分离开.<br>
所以i++不是原子操作，上面的三个步骤中任何一个步骤同时操作，都可能导致i的值不正确自增</p>
</blockquote>
<p>  所以++i明显是线程不安全的，所以对于共享的变量（全局变量、静态变量）都需要加锁才能安全地进行自增等操作，但这未免效率太低了，而且可移植性差，到了别的系统可能锁就白给了，所以C++为了追求极致，C++11中开发了自己的atomic类型，本质是一个模板，主要根据不同的编译器和系统来确定可以使用的互斥器等类型，然后封装了高效的同步或互斥操作，并提供了相对应的复制、读取和递增递减等线程安全的操作。</p>
<p>下面是详细介绍</p>
<p>  C++11 标准中，相当大的一个变化就是引入了多线程的支持，这使得用C/C++进行线程编程时，不必依赖第三方库和标准。<br>
  而C++11对多线程的支持，最为重要的部分，就是在原子操作中引入了原子类型的概念。</p>
<h3 id="原子操作">原子操作</h3>
<p>  所谓原子操作，就是多线程程序中“最小的且不可并行化的”操作。对于在多个线程间共享的一个资源而言，这意味着同一时刻，多个线程中有且仅有一个线程在对这个资源进行操作，即互斥访问。提到“互斥”访问，熟悉多线程开发的同学可能立即想到Windows平台下使用的临界区/CRITICAL_SECTION、互斥体/Mutex。实现互斥通常需要平台相关的特殊指令，在C++11标准之前，这意味着需要在C/C++代码中嵌入平台相关的内联汇编代码。 平台相关意味着：1.你必须了解平台相关的编译器扩展；2.无法跨平台运行你的多线程程序。</p>
<pre><code>#include ＜pthread.h＞
#include ＜iostream＞
using namespace std;
static long long total=0;
pthread_mutex_t m=PTHREAD_MUTEX_INITIALIZER;
void*func(void*){
long long i;
for(i=0;i＜100000000LL;i++){
pthread_mutex_lock(＆m);
total+=i;
pthread_mutex_unlock(＆m);
}
}
int main(){
pthread_t thread1,thread2;
if(pthread_create(＆thread1,NULL,＆func,NULL)){
throw;
}
if(pthread_create(＆thread2,NULL,＆func,NULL)){
throw;
}
pthread_join(thread1,NULL);
pthread_join(thread2,NULL);
cout＜＜total＜＜endl;//9999999900000000
return 0;
}
//编译选项:g++6-3-1.cpp-lpthread
</code></pre>
<p>  代码中，我们启动两个线程来更新变量total的值，为了防止数据竞争问题，我们需要使用pthread_mutex_t类型的互斥锁，来保证两个线程互斥地访问total，从而得到total的正确结果。这个例子演示了多线程开发的基本问题：</p>
<p>  找到多个线程共享的资源/数据(飞机上洗手间里的马桶)。操作这些资源/数据的代码称之为临界区（洗手间）。<br>
  线程进入临界区并加锁，防止其他线程进入临界区(进房间后立即锁门，其他人排队)。<br>
  更新/操作共享的资源/数据(…………)<br>
  线程离开临界区，独享权让给其他等待的线程(解锁，开门。下一位……)。<br>
  如果多个线程各干各的活，没有共享的资源/数据，老死不相往来，那就没有临界区、互斥锁等所有这些破事了，完美！</p>
<p>但是！</p>
<p>  对于熟悉单线程开发的同学来说，互斥锁的管理无疑是个负担。需要说明的是，上述代码仅仅演示最基本、最简单的情形。复杂、特殊情况下，这个管理负担还是挺重的，这里就不展开讨论。</p>
<p>  “就两个线程就共享了一个数据，需要承担互斥锁的管理负担？！”相较于单线程程序，虽然只多写了两行代码，但是程序员都是懒惰的——能不写的代码坚决不写，能少写的坚决不多写(在保证代码可读性的前提下)，这也是优秀程序员的标准做法。</p>
<p>  另外一个问题是跨平台——上述代码在LINUX平台下用g++编译运行的，但是在Windows平台上，得做一番改动/重写才能运行起来。Once for all? ! No way!</p>
<p>  C++11标准从不同的视角看待这个问题：需要同步的总是资源/数据，而不是代码。因此C++11对数据进行了更为良好的抽象，引入&quot;原子数据类型&quot;/atomic类型，以达到对开发者掩盖互斥锁、临界区的目的。要知道，这些临界区、互斥锁才是平台相关的东西。来看下面的示例代码。</p>
<pre><code>#include&lt;atomic&gt;
#include&lt;thread&gt;
#include&lt;iostream&gt;

using namespace std;
std::atomic_llong total{ 0 };//原子数据类型

void func(int)
{
    for (long long i = 0; i&lt;100000000LL; ++i)
    {
        total += i;
    }
}

int main()
{
    thread t1(func, 0);
    thread t2(func, 0);
    t1.join();
    t2.join();
    cout&lt;&lt;total&lt;&lt;endl;//9999999900000000
    return 0;
}
//编译选项:g++ -std=c++11 6-3-2.cpp-lpthread
</code></pre>
<p>  代码中，将total定义为“原子数据类型”：atomic_llong, 该数据类型长度等于C++11中内置数据类型long long。可以看到，程序员不需要为原子数据类型显示地调用加锁、解锁的API，线程就能够对共享数据total进行互斥地访问。太容易了，又可以“偷懒”了！</p>
<p>  上述代码，书1作者在Linux系统下开发，用g++编译器编译运行的。代码不做任何改动，我在Windows系统下使用Visual Studio 2015编译运行也OK的。</p>
<p>  那么问题来了：既然原子操作都是平台相关的，那么atomic数据类型又如何帮助我们“掩盖”这种平台相关性呢？C++11 对常见的原子操作进行了抽象，定义出统一的接口，并根据编译选项/环境产生平台相关的实现。新标准将原子操作定义为atomic模板类的成员函数，囊括了绝大多数典型的操作——读、写、比较、交换等。</p>
<h3 id="原子数据类型atomic类型">原子数据类型/atomic类型</h3>
<p>让我们先来看一下atomic模板类:</p>
<pre><code>template &lt;class T&gt; struct atomic

//example
#include&lt;atomic&gt;

void test()
{
    std::atomic_int nThreadData; // std::atomic_int  &lt;----&gt; std::atomic&lt;int&gt;
    nThreadData = 10;
    nThreadData.store(10);
    //TODO: use nThreadData here;
}
</code></pre>
<p>  对于内置型数据类型，C11和C++11标准中都已经提供了实例化原子类型，如下表所示：<br>
<img src="https://lixin-scut.github.io//post-images/1586228285225.png" alt=""></p>
<p>atomic类型原子操作接口如下：<br>
<img src="https://lixin-scut.github.io//post-images/1586228358118.png" alt=""><br>
这些接口函数的说明和示例代码，可参考如下链接：<br>
https://en.cppreference.com/<br>
http://www.cplusplus.com/</p>
<p>  更详细的接口介绍可以查看：<a href="https://www.cnblogs.com/haippy/p/3304556.html">C++11 并发指南六(atomic 类型详解三 std::atomic (续))</a>，该作者针对atomic有四篇文章，详细介绍了相关的接口。</p>
<p>  总体而言，在多线程程序中使用这些内置数据类型对应的atomic类型，还是不难的，应付一般的多线程问题还是得心应手的。有的同学会立即想到，线程间需要交互好多数据？用自定义数据类型/UDT去实例化atomic模板类, 岂不是可以大大缩减开发的工作量？请注意表#2最后一列，class-type就是指自定义数据类型/UDT.</p>
<p>  但是！UDT要满足以下5个条件，才可作为模板参数去实例化atomic模板：</p>
<pre><code>#include &lt;atomic&gt;
#include &lt;type_traits&gt;

using namespace std;

struct MY_UDT
{
    //TODO:data member here
};

int main()
{
    auto ret = std::is_trivially_copyable&lt;MY_UDT&gt;::value;
    ret = std::is_copy_constructible&lt;MY_UDT&gt;::value;
    ret = std::is_move_constructible&lt;MY_UDT&gt;::value;
    ret = std::is_copy_assignable&lt;MY_UDT&gt;::value;
    ret = std::is_move_assignable&lt;MY_UDT&gt;::value;

    return 0;
}
</code></pre>
<p>  MY_UDT是用户自定义数据类型，上述代码中，5个ret值必须都为true。也就是说对UDT的拷贝构造、赋值构造、移动赋值等各方面都提出了要求……“要求这么高！？”用了atomic模板类，既不劳烦你写加锁/解锁代码，又不用你考虑跨平台那档子事，多好！ 哪有无缘无故的好事？总要付出一定代价的。</p>
<h3 id="内存模型">内存模型</h3>
<p>  通常情况下，内存模型是一个硬件上的概念，表示的是机器指令（或者将其视为汇编指令也可以）是以什么样的顺序被处理器执行的。现代的处理器并不是逐条处理机器指令的。<br>
<img src="https://lixin-scut.github.io//post-images/1586228634335.png" alt=""></p>
<h4 id="顺序一致内存顺序memory_order_seq_cst">顺序一致内存顺序/memory_order_seq_cst</h4>
<p>  定义规则：全部存取都按照顺序执行。</p>
<p>  memory_order_seq_cst 表示该原子操作必须顺序一致的，这是C++11中所有atomic原子操作的默认值。这样来理解“顺序一致”：即代码在线程中运行的顺序与程序员看到的代码顺序一致。也就是说，用此值提示编译器“不要给我重排序指令，不要整什么指令乱序执行，就按照我代码的先后顺序执行机器指令”。在示例代码中，a的赋值语句先于b的赋值语句执行，这种称之为”先于发生(happens-before)“关系。用memory_order_seq_cst 可以确保这种happens_before关系。</p>
<h4 id="松散内存顺序memory_order_relaxed">松散内存顺序/memory_order_relaxed</h4>
<p>  定义规则：不对执行顺序做任何保证。</p>
<p>  表示该原子操作指令可以任由编译器重排或者由处理器乱序执行。就是说”想怎么乱就怎么乱吧，不管了，只要能提高指令执行效率“。代码清单6-23中使用的就是松散内存模型，在Observer中打印出(0,2)这样的结果也是合理的——把我代码中的顺序都彻底整反了！</p>
<h4 id="release-acquire内存顺序">Release-acquire内存顺序</h4>
<p><strong>memory_orderacquire</strong></p>
<p>  规则定义：本线程中，所有后续的读操作，必须在本条原子操作完成后执行。(本线程中，我先读，你们后读……)</p>
<p><strong>memory_order_release</strong></p>
<p>  规则定义：本线程中，所有之前的写操作完成后，才能执行本原子操作。（在本线程中，你们先写，我最后写……）</p>
<p>  上面讲的顺序一致和松散方式对应着两个极端——一个是严格禁止”乱“，一个是允许随便”乱“。但是现实的问题是：严格禁止”乱“，指令执行不够快；允许随便”乱“，又得不到正确结果。</p>
<h4 id="release-consume内存顺序">Release-consume内存顺序</h4>
<p><strong>memory_order_consume</strong></p>
<p>  规则定义：本线程中，所有后续的有关本算子类型的操作，必须在本条原子操作完成之后执行。(本线程中，我只关心我自己，当我用memory_order_consume时，后面所有对我的读写操作都不能被提前执行……)</p>
<p>  相比于memory_order__acquire，memory_order_consume进一步放松了依赖关系。大家发现没有，前面讲的几种内存顺序都是在操控/安排多个atomic数据之间的读写顺序，而memory_order_consume仅仅考虑对一个atomic数据的读写顺序。</p>
<h3 id="参考资料">参考资料：</h3>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/107092432?utm_source=wechat_timeline">C++11 - atomic类型和内存模型</a></li>
<li><a href="https://www.cnblogs.com/haippy/p/3252056.html">C++11 并发指南六(atomic 类型详解一 atomic_flag 介绍)</a>，该作者针对atomic有四篇文章，详细介绍了相关的接口。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[布隆过滤器]]></title>
        <id>https://lixin-scut.github.io//post/bu-long-guo-lu-qi</id>
        <link href="https://lixin-scut.github.io//post/bu-long-guo-lu-qi">
        </link>
        <updated>2020-04-07T02:07:18.000Z</updated>
        <content type="html"><![CDATA[<h3 id="个人总结">个人总结：</h3>
<p><strong>概念</strong></p>
<p>  布隆过滤器是一种概率型数据结构，利用了位图的思想来节省空间，通过使用多个不同的哈希函数生成多个哈希值，并对每个生成的哈希值指向的 bit 位置 1。从而达到高效的插入和查询。需要注意的是由于插入存在覆盖，查询的结果是具有失败概率的，同时覆盖的存在也导致传统的布隆过滤器并不支持删除操作。</p>
<p><strong>优缺点与用途</strong></p>
<p>优点：</p>
<ol>
<li>不需要存储数据本身，只用比特表示，因此空间占用相对于传统方式有巨大的优势，并且能够保密数据；</li>
<li>时间效率也较高，插入和查询的时间复杂度均为O(k)；</li>
<li>哈希函数之间相互独立，可以在硬件指令层面并行计算。</li>
</ol>
<p>缺点：</p>
<ol>
<li>存在假阳性的概率，不适用于任何要求100%准确率的情境；</li>
<li>只能插入和查询元素，不能删除元素，这与产生假阳性的原因是相同的。可以简单地通过计数（即将一个比特扩展为计数值）来记录元素数，但仍然无法保证删除的元素一定在集合中。</li>
</ol>
<p>  所以，在对查准度要求没有那么苛刻，而对时间、空间效率要求较高的场合非常合适布隆过滤器，例如利用布隆过滤器减少磁盘 IO 或者网络请求，因为一旦一个值必定不存在的话，我们可以不用进行后续昂贵的查询请求。所以，由于布隆过滤器不存在假阴性问题，所以用作“不存在”逻辑的处理时有奇效，比如可以用来作为缓存系统（如Redis）的缓冲，防止缓存穿透。</p>
<p>下面为详细内容，主要转载 YoungChen__ 的<a href="https://www.jianshu.com/p/2104d11ee0a2">详解布隆过滤器的原理、使用场景和注意事项</a></p>
<h3 id="什么是布隆过滤器">什么是布隆过滤器</h3>
<p>  本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。</p>
<p>  相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</p>
<h3 id="实现原理">实现原理</h3>
<p><strong>HashMap 的问题</strong></p>
<p>  讲述布隆过滤器的原理之前，我们先思考一下，通常你判断某个元素是否存在用的是什么？应该蛮多人回答 HashMap 吧，确实可以将值映射到 HashMap 的 Key，然后可以在 O(1) 的时间复杂度内返回结果，效率奇高。但是 HashMap 的实现也有缺点，例如存储容量占比高，考虑到负载因子的存在，通常空间是不能被用满的，而一旦你的值很多例如上亿的时候，那 HashMap 占据的内存大小就变得很可观了。</p>
<p>  还比如说你的数据集存储在远程服务器上，本地服务接受输入，而数据集非常大不可能一次性读进内存构建 HashMap 的时候，也会存在问题。</p>
<p><strong>布隆过滤器数据结构</strong></p>
<p>  布隆过滤器是一个 bit 向量或者说 bit 数组，长这样：</p>
<p><img src="https://lixin-scut.github.io//post-images/1586225925249.png" alt=""></p>
<p>  如果我们要映射一个值到布隆过滤器中，我们需要使用多个不同的哈希函数生成多个哈希值，并对每个生成的哈希值指向的 bit 位置 1，例如针对值 “baidu” 和三个不同的哈希函数分别生成了哈希值 1、4、7，则上图转变为：</p>
<p><img src="https://lixin-scut.github.io//post-images/1586225949536.png" alt=""></p>
<p>  Ok，我们现在再存一个值 “tencent”，如果哈希函数返回 3、4、8 的话，图继续变为：</p>
<p><img src="https://lixin-scut.github.io//post-images/1586225970063.png" alt=""></p>
<p>  值得注意的是，4 这个 bit 位由于两个值的哈希函数都返回了这个 bit 位，因此它被覆盖了。现在我们如果想查询 “dianping” 这个值是否存在，哈希函数返回了 1、5、8三个值，结果我们发现 5 这个 bit 位上的值为 0，说明没有任何一个值映射到这个 bit 位上，因此我们可以很确定地说 “dianping” 这个值不存在。而当我们需要查询 “baidu” 这个值是否存在的话，那么哈希函数必然会返回 1、4、7，然后我们检查发现这三个 bit 位上的值均为 1，那么我们可以说 “baidu” 存在了么？答案是不可以，只能是 “baidu” 这个值可能存在。</p>
<p>  这是为什么呢？答案跟简单，因为随着增加的值越来越多，被置为 1 的 bit 位也会越来越多，这样某个值 “taobao” 即使没有被存储过，但是万一哈希函数返回的三个 bit 位都被其他值置位了 1 ，那么程序还是会判断 “taobao” 这个值存在。</p>
<h3 id="支持删除么">支持删除么</h3>
<p>  传统的布隆过滤器并不支持删除操作。但是名为 Counting Bloom filter 的变种可以用来测试元素计数个数是否绝对小于某个阈值，它支持元素删除。可以参考文章 <a href="https://cloud.tencent.com/developer/article/1136056">Counting Bloom Filter</a> 的原理和实现</p>
<h3 id="如何选择哈希函数个数和布隆过滤器长度">如何选择哈希函数个数和布隆过滤器长度</h3>
<p>  很显然，过小的布隆过滤器很快所有的 bit 位均为 1，那么查询任何值都会返回“可能存在”，起不到过滤的目的了。布隆过滤器的长度会直接影响误报率，布隆过滤器越长其误报率越小。</p>
<p>  另外，哈希函数的个数也需要权衡，个数越多则布隆过滤器 bit 位置位 1 的速度越快，且布隆过滤器的效率越低；但是如果太少的话，那我们的误报率会变高。</p>
<p><img src="https://lixin-scut.github.io//post-images/1586226067467.png" alt=""></p>
<p>  如何选择适合业务的 k 和 m 值呢，这里直接贴一个公式：</p>
<p><img src="https://lixin-scut.github.io//post-images/1586226081707.png" alt=""></p>
<p>  k 为哈希函数个数，m 为布隆过滤器长度，n 为插入的元素个数，p 为误报率。<br>
  至于如何推导这个公式，我在知乎发布的<a href="https://zhuanlan.zhihu.com/p/43263751">文章</a>有涉及，感兴趣可以看看，不感兴趣的话记住上面这个公式就行了。</p>
<h3 id="最佳实践">最佳实践</h3>
<p>  常见的适用常见有，利用布隆过滤器减少磁盘 IO 或者网络请求，因为一旦一个值必定不存在的话，我们可以不用进行后续昂贵的查询请求。</p>
<p>  另外，既然你使用布隆过滤器来加速查找和判断是否存在，那么性能很低的哈希函数不是个好选择，推荐 MurmurHash、Fnv 这些。</p>
<h3 id="大value拆分">大Value拆分</h3>
<p>  Redis 因其支持 setbit 和 getbit 操作，且纯内存性能高等特点，因此天然就可以作为布隆过滤器来使用。但是布隆过滤器的不当使用极易产生大 Value，增加 Redis 阻塞风险，因此生成环境中建议对体积庞大的布隆过滤器进行拆分。</p>
<p>  拆分的形式方法多种多样，但是本质是不要将 Hash(Key) 之后的请求分散在多个节点的多个小 bitmap 上，而是应该拆分成多个小 bitmap 之后，对一个 Key 的所有哈希函数都落在这一个小 bitmap 上。</p>
<p>参考资料：</p>
<ol>
<li><a href="https://www.jianshu.com/p/2104d11ee0a2">详解布隆过滤器的原理、使用场景和注意事项</a></li>
<li><a href="https://www.jianshu.com/p/bef2ec1c361f">布隆过滤器（Bloom Filter）原理及Guava中的具体实现</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/72378274">数学之美：布隆过滤器</a></li>
</ol>
]]></content>
    </entry>
</feed>