<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-09-15T12:39:50.746Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[C++ primer 第六章 笔记+习题 6.3-6.7]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-liu-zhang-bi-ji-xi-ti-63-67</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-liu-zhang-bi-ji-xi-ti-63-67">
        </link>
        <updated>2019-09-12T11:48:50.000Z</updated>
        <content type="html"><![CDATA[<p>6.3.1无返回值函数<br>
return语句终止当前正在执行的函数并将控制权返回到调用函数的地方<br>
void函数会在最后隐式执行return语句，<br>
void函数可以return另一个返回值为void的函数，不能返回其他类型的表达式<br>
6.3.2有返回值函数<br>
编译器不一定能发现漏掉return语句的错误<br>
返回值用于初始化调用点的一个临时量<br>
最好返回的是对象的引用，否则会返回返回值的拷贝副本<br>
不要返回局部对象的引用或指针<br>
如果返回类型是引用，不能返回局部对象的引用或者局部临时量如“abc”但可以直接返回对象（区分局部对象）而不是必须是引用（因为原则上引用就是一个别名）<br>
调用返回引用的函数得到左值，其他返回类型得到右值<br>
函数可以返回花括号包围的值的类型，比如vector，如果是内置类型则花括号包围的列表最多包含一个值，如果是类类型，由类本身定义。<br>
主函数main可以没有return语句，会在结尾隐式插入return 0；<br>
返回非0值的具体含义由机器决定，所以cstdlib 头文件中定义了两个通用的预处理变量 EXIT_FAILURE和EXIT_SUCCESS，其与机器无关，两者皆为预处理变量既不能加上std::，也不能用using声明<br>
递归 函数自己调用自己<br>
main函数不能调用自己</p>
<p>习题6.30<br>
error C2561: “str_subrange”: 函数必须返回值<br>
习题6.31<br>
返回的引用指向了函数中定义的局部变量或者局部常量<br>
习题6.32<br>
合法，将ia的每个元素赋值为相应的下标值<br>
习题6.33</p>
<pre><code>void print(vector&lt;int&gt; v, int index);

int main() {
	vector&lt;int&gt; ia = { 1,2,3,4,5,6,7,8,9,0 };
	print(ia, 0);
};
void print(vector&lt;int&gt; v,int index){
	if (index &lt; v.size())
		cout &lt;&lt; v[index] &lt;&lt; endl,print(v,++index);
}
</code></pre>
<p>习题6.34<br>
如果输入一个负数，将陷入死循环直至内存崩溃。<br>
习题6.35<br>
val--是对val递减后传入val原本值的副本，会造成无限循环</p>
<p>6.3.3 返回数组指针<br>
无法返回数组，但可以返回指向大小确定的数组的引用或指针<br>
返回数组指针的函数声明为 type （*函数名（形参列表））[数组维度]<br>
所以建议使用类型别名，decltype 或尾置返回类型<br>
<code>int array[10]; decltype(array) *func(int); auto func(int) -&gt;int(*)[10]；</code></p>
<p>习题6.36<br>
<code>string(&amp;func())[10]</code><br>
习题6.37</p>
<pre><code>typedef string re[10]; using re=string[10];re &amp;func();
decltype(string [10]) &amp;func();
auto func()-&gt;string(&amp;)[10]
</code></pre>
<p>声明时尾置返回最好，定义时类型别名和decltype最好，这样可读性高<br>
知识点：注意尾置返回中指针和引用必须加括号string(&amp;)[10] string(*)[10]<br>
习题6.38<br>
其实就是把*号换成&amp;号 函数体内的&amp;去除</p>
<p>6.4函数重载<br>
函数重载 名字相同形参列表不同（<strong>返回类型可以不同，但不能只有返回类型的不同</strong>）<br>
main函数不能重载<br>
不允许两个函数除了返回类型外其他要素都相同，如果其他要素都相同只有返回类型不同则后一个函数声明是错误的<br>
<strong>形参有无名字不影响判断，形参的名字不同类型相同的话，仍视为同一函数</strong><br>
如果仅仅是函数名不同，则视为类型别名，也视为与原名相同<br>
<strong>形参无视顶层const</strong> 所以有顶层const形参和没有顶层const的形参是<strong>等价的</strong><br>
所以func(int *param) 和func(int * const param) 是相同的，注意const的位置<br>
func(const int * param) 则是新函数<br>
指向常量的指针只能传递给底层const形参，<strong>不能传给普通指针形参</strong><br>
使用const_cast在重载中对变量进行强制转换，去除底层const</p>
<p>习题6.39<br>
（a）形参是顶层const 然而形参会无视const，所以等于重复声明<br>
（b）返回值改为double 但是仅仅有返回类型不同，所以等于重复声明<br>
（c）形参类型和返回类型改变了，是合法的</p>
<p>6.4.1重载与作用域<br>
在内层作用域中无法进行重载，只会隐藏外层作用域中声明的同名实体<br>
c++中 名字查找发生在类型检查之前，一旦在当前作用域找到了所需的名字，编译器就会忽略掉外层作用域的同名实体，再进行类型检测确认函数调用是否有效</p>
<p>6.5.1默认实参<br>
默认实参 就是缺省值<br>
通常应该在函数声明中指定默认实参，并将该声明放在合适的头文件中,例如：<br>
<code>void func(int param1=1,int param2=10,char param3 = 'p');</code><br>
注意一旦某个形参被赋予默认值，<strong>后面的所有形参都必须有默认值</strong><br>
如果想覆盖右侧的默认值，必须也覆盖前面的默认值<br>
在给定的作用域中一个形参<strong>只能被赋予一次</strong>默认实参，函数的后续声明只能为之前那些没有默认值的形参添加默认实参<br>
默认实参的<strong>初始化</strong>可以是表达式，不能是局部变量，变量的声明必须出现在函数之外<br>
用作默认实参的名字在函数声明的作用域内解析，<strong>可以通过实参名改变默认实参值，但是新定义的同名变量无法隐藏外层的默认实参变量</strong>，例如在另外一个函数中用于默认实参值的变量值a变化了，同时会改变默认实参的a，但是如果在内层作用域定义一个新的a，并不会影响外层声明中的a<br>
<strong>经常使用默认实参的变量放在后面，不常使用的放在前面</strong></p>
<p>习题6.40<br>
b是错误的，默认实参应该在后面，否则只要有实参就不能使用默认实参<br>
习题6.41<br>
a错误，至少需要一个参数，c合法但初衷不符，wd会被赋予'*'的ASCII码，不能越过某个默认实参改变后面的默认实参。<br>
习题6.42</p>
<pre><code>string make_plural(size_t ctr, const string &amp;word, const string &amp;ending = &quot;s&quot;);

int main() {
	cout &lt;&lt; &quot;两单词的单数形式：&quot; &lt;&lt; make_plural(1, &quot;success&quot;, &quot;es&quot;) &lt;&lt; &quot;  &quot; &lt;&lt; make_plural(1, &quot;failure&quot;) &lt;&lt; endl;
	cout &lt;&lt; &quot;两单词的复数形式：&quot; &lt;&lt; make_plural(2, &quot;success&quot;, &quot;es&quot;) &lt;&lt; &quot;  &quot; &lt;&lt; make_plural(2, &quot;failure&quot;) &lt;&lt; endl;
};

string make_plural(size_t ctr, const string &amp;word, const string &amp;ending) {
	return (ctr &gt; 1) ? word + ending : word;
}
</code></pre>
<p>知识点：默认实参定义在函数的声明，不需要定义在函数的定义！！！</p>
<p>6.5.2内联函数和constexpr函数<br>
内联函数 在调用点上召开为一段程序 避免函数调用的开销<br>
内联函数关键字inline 适用于规模小频繁调用的函数<br>
Constexpr函数<strong>返回类型和形参类型都是字面值类型</strong>（引用 指针 算术类型）（自定义类、IO库、string类等就不是字面值类型），函数体内有且只有一条return语句，被隐式地指定为内联函数<br>
比如 constexpr int func() { return 42; }<br>
Constexpr函数<strong>允许返回值并非一个常量</strong>，所以不一定返回常量表达式(传入常量表达式，返回常量表达式，反之则返回非常量表达式)<br>
与其他函数不同，内联函数和Constexpr函数 <strong>可以多次定义，但需要保持一致</strong>，所以通常定义在头文件中</p>
<p>习题6.43<br>
（a）声明和定义都在头文件<br>
（b）声明在头文件，定义在源文件<br>
知识点：因为内联函数可以定义多次，万一以后错手定义会很麻烦，为了保证一致最好定义在头文件，普通函数则只能定义一次，所以只需要放在源文件。<br>
习题6.44<br>
直接在返回类型前面加上inline就vans了<br>
习题6.45<br>
简短而且常用的函数可以定义为内联函数<br>
习题6.46<br>
不可以，string不是字面值类型</p>
<p>6.5.3调试帮助<br>
arrest 预处理宏 一个预处理变量，arrest宏定义在carrest头文件中<br>
arrest（expr），判断为假则输出信息终止程序，输出为真则什么都不做，用于检查不能发生的条件，例如<br>
assert(word.size() &gt; threshold)；<br>
宏名字在程序内必须唯一，所以不能定义与宏名字相同的变量、函数等<br>
NDEBUG决定了 arrest是否执行检查，是否开启调试状态，如果定义了就等于关闭，未定义就等于开启。<br>
详细例子可看笔记</p>
<p>习题6.47</p>
<pre><code>void print(vector&lt;int&gt; v, int index);

int main() {
	vector&lt;int&gt; ia = { 1,2,3,4,5,6,7,8,9,0 };
	print(ia, 0);
};
void print(vector&lt;int&gt; v, int index) {
	if (index &lt; v.size()) {
#ifndef NDEBUG
		cout &lt;&lt; v.size() &lt;&lt; endl;
#endif // !NDEBUG
		cout &lt;&lt; v[index] &lt;&lt; endl, print(v, ++index);
	}	
}
</code></pre>
<p>习题6.48<br>
不合理，while已经对cin进行判断了，并且只要cin有输入就为真，并非不能发生的条件</p>
<p>6.6 函数匹配<br>
第一步 候选函数（一与被调用函数同名，二其声明在调用点可见）<br>
第二步 考察本次调用提供的实参，选出能被实参调用的可行函数（一是形参与本次调用提供的实参数量相等，二是实参类型与对应的形参类型相同，或者能转换成形参的类型）<br>
第三步 最佳匹配<br>
实参类型和形参类型越接近匹配得越好<br>
该函数每个实参的匹配都不劣于其他可行函数需要的匹配<br>
至少有一个实参的匹配优于其他可行函数提供的匹配</p>
<p>习题6.49<br>
候选函数：本次调用对应的重载函数集 1.与被调用函数同名 2.其声明在调用点可见。<br>
可行函数，从候选函数中选出的能被实参调用的函数 1.实参形参数量匹配 2.类型匹配或可转换<br>
习题6.50<br>
（a）二义性了，可以选择转化为double或者int<br>
（b）f（int）<br>
（c）f（int，int）<br>
（d）f（double，double）<br>
习题6.51</p>
<pre><code>void f();
void f(int);
void f(int, int);
void f(double, double = 3.14);
int main() {
	//f(2.56, 42);//有多个重载函数示例与实参列表匹配
	f(42);
	f(42, 0);
	f(2.56, 3.14);
};
void f(){
	cout &lt;&lt; &quot;f()&quot; &lt;&lt; endl;
}
void f(int){
	cout &lt;&lt; &quot;f(int)&quot; &lt;&lt; endl;
}
void f(int, int){
	cout &lt;&lt; &quot;f(int, int)&quot; &lt;&lt; endl;
}
void f(double, double ){
	cout &lt;&lt; &quot;f(double,double = 3.14)&quot; &lt;&lt; endl;
}
</code></pre>
<p>6.6.1实参类型转换<br>
const转换:可以将指向类型T的指针或引用转换成指向const T的指针或引用，例如 int i; const int &amp;j=i;<br>
类型提升：也就是short、char等提升为int等<br>
算术类型转换：运算过程中 小对象的类型转化为另外一个大的对象的类型<br>
指针转换：0和nullptr能够转换成任意指针类型，指向任意非常量的指针可以转换成void*，指向任意常量的指针可以转换成const void*，派生继承关系中的派生类和基类的指针转换<br>
小整型short一般会提升到int类型，使用short类型的函数反而会导致类型转换<br>
所有算数类型转换的级别一样</p>
<p>习题6.52<br>
（a）3.类型提升匹配 （b）4.算术类型转换<br>
习题6.53<br>
（a）重载<br>
（b）重载<br>
（c）忽略顶层const，和第一句其实一样，不合法</p>
<p>6.7函数指针<br>
声明一个指向函数的指针，<strong>只需要用指针替换函数名即可（不要漏掉括号）</strong><br>
<code>void (*pointer)(int ,int);</code><br>
使用函数名时<strong>会自动转换成指针</strong><br>
可以直接使用指向函数的指针调用，<strong>无须提前解引用指针</strong><br>
函数指针可以赋<strong>nullptr或者值为0的常量表达式</strong><br>
函数指针之间不存在转换规则<br>
指针类型<strong>必须</strong>与重载函数中的某一个精确匹配<br>
形参<strong>不能是函数类型</strong>，但<strong>可以是指向函数的指针</strong>，此时形参看起来是函数类型，实际上是被当作指针来使用<br>
函数作为实参时会自动转换成指针<br>
Decltype 返回<strong>函数类型</strong>，而不是自动转换成指针类型<br>
返回指向函数的指针<code>int (*f1(int))(int*,int); 或者 using PF = int(*)(int*,int);PF</code> f1(int)或者用尾置返回 <code>auto f1(int)-&gt;int(*)(int*,int)</code><br>
明确知道返回函数时用decltype<br>
<code>decltype(func1) *func2();</code>//注意，func1为函数名</p>
<p>习题6.54</p>
<pre><code>int func(int, int);
int main() {
	vector&lt;int (*)(int,int)&gt; v;
};
int func(int, int) {
	return 1;
}
</code></pre>
<p>知识点：函数类型与函数名无任何关系，int func(int, int)的函数指针类型是int (*)(int,int)，换个名字也一样<br>
习题6.55</p>
<pre><code>int func(int, int);
int add(int a, int b);
int minuss(int a, int b);
int multi(int a, int b);
int divide(int a, int b);
int main() {
	vector&lt;int(*)(int, int)&gt; v{add,minuss,multi,divide};
};
int func(int, int) {
	return 1;
}
int add(int a, int b) {
	return a+b;
}
int minuss(int a, int b) {
	return a - b;
}
int multi(int a, int b) {
	return a * b;
}
int divide(int a, int b) {
	return a / b;
}
</code></pre>
<p>知识点：貌似minus不能用<br>
习题6.56</p>
<pre><code>int func(int, int);
int add(int a, int b);
int minuss(int a, int b);
int multi(int a, int b);
int divide(int a, int b);
int main() {
	vector&lt;int(*)(int, int)&gt; v{add,minuss,multi,divide};
	cout &lt;&lt; v[0](10, 2) &lt;&lt; endl;
	cout &lt;&lt; v[1](10, 2) &lt;&lt; endl;
	cout &lt;&lt; v[2](10, 2) &lt;&lt; endl;
	cout &lt;&lt; v[3](10, 2) &lt;&lt; endl;
};
int func(int, int) {
	return 1;
}
int add(int a, int b) {
	return a+b;
}
int minuss(int a, int b) {
	return a - b;
}
int multi(int a, int b) {
	return a * b;
}
int divide(int a, int b) {
	return a / b;
}
</code></pre>
<p>知识点:可以直接调用函数的指针 pointer（int，int）</p>
<p>习题感悟<br>
注意尾置返回中 指针和引用必须加括号string(&amp;)[10] string(*)[10]<br>
默认实参定义只能在函数的声明，不需要定义在函数的定义！！！<br>
因为内联函数可以定义多次，万一以后错手定义会很麻烦，为了保证一致最好定义在头文件，普通函数则只能定义一次，所以只需要放在源文件。<br>
返回类型和形参中包含字面值类型的函数不可以定义为constexpr<br>
实参类型转换是有等级差异的<br>
函数类型与函数名无任何关系，int func(int, int)的函数指针类型是int (*)(int,int)，换个名字也一样<br>
貌似minus不能用<br>
可以直接调用函数的指针 pointer（int，int）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 55. 跳跃游戏]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-55-tiao-yue-you-xi</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-55-tiao-yue-you-xi">
        </link>
        <updated>2019-09-12T11:43:10.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>官方题目：<br>
给定一个非负整数数组，你最初位于数组的第一个位置。<br>
数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>
判断你是否能够到达最后一个位置。</p>
<p>示例 1:<br>
输入: [2,3,1,1,4]<br>
输出: true<br>
解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。<br>
示例 2:<br>
输入: [3,2,1,0,4]<br>
输出: false<br>
解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/jump-game<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>对题目一开始的思考就是能够按某种顺序进行运算从而得出结果，一开始是想用逆推法，但是后来发现从前开始也是阔以的，具体思路就是判断每个点可以前进的值，并且维护一个最远可以达到的值reach，如果当前点大于reach就将reach的值改为当前点的值，最后能够去到的最大值和数组长度之间是否相等的判断值就是答案，代码如下：</p>
<pre><code>class Solution {
public:
    bool canJump(vector&lt;int&gt;&amp; nums) {
       int len=nums.size();
        if(len==0||len==1)
            return true;
        int reach=0;
        for(int i=0;i&lt;len-1;++i){
            int temp=reach;
            reach=i+nums[i];
            if(temp&gt;reach)
                swap(temp,reach);
            if(reach==i)
                return false;
        }
        if(reach&gt;=len-1)
         return true;
        else
        return false;    
    }
};
</code></pre>
<p>这一次由于找准了思路，所以一次通过，鼓掌！！hhh<br>
然后来看一下官方题解吧：</p>
<blockquote>
<p>定义<br>
如果我们可以从数组中的某个位置跳到最后的位置，就称这个位置是“好坐标”，否则称为“坏坐标”。问题可以简化为第 0 个位置是不是“好坐标”。<br>
题解<br>
这是一个动态规划问题，通常解决并理解一个动态规划问题需要以下 4 个步骤：<br>
利用递归回溯解决问题<br>
利用记忆表优化（自顶向下的动态规划）<br>
移除递归的部分（自底向上的动态规划）<br>
使用技巧减少时间和空间复杂度<br>
下面的所有解法都是正确的，但在时间和空间复杂度上有区别。</p>
<p>方法 1：回溯<br>
这是一个低效的解决方法。我们模拟从第一个位置跳到最后位置的所有方案。从第一个位置开始，模拟所有可以跳到的位置，然后从当前位置重复上述操作，当没有办法继续跳的时候，就回溯。</p>
</blockquote>
<pre><code>public class Solution {
    public boolean canJumpFromPosition(int position, int[] nums) {
        if (position == nums.length - 1) {
            return true;
        }

        int furthestJump = Math.min(position + nums[position], nums.length - 1);
        for (int nextPosition = position + 1; nextPosition &lt;= furthestJump; nextPosition++) {
            if (canJumpFromPosition(nextPosition, nums)) {
                return true;
            }
        }

        return false;
    }

    public boolean canJump(int[] nums) {
        return canJumpFromPosition(0, nums);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(2^n) ，最多有 2^n种从第一个位置到最后一个位置的跳跃方式，其中 n 是数组 nums 的元素个数，完整的证明见附录 A。<br>
空间复杂度：O(n)，回溯法只需要栈的额外空间。</p>
</blockquote>
<blockquote>
<p>方法 2：自顶向下的动态规划<br>
自顶向下的动态规划可以理解成回溯法的一种优化。我们发现当一个坐标已经被确定为好 / 坏之后，结果就不会改变了，这意味着我们可以记录这个结果，每次不用重新计算。<br>
因此，对于数组中的每个位置，我们记录当前坐标是好 / 坏，记录在数组 memo 中，定义元素取值为 GOOD ，BAD，UNKNOWN。这种方法被称为记忆化。<br>
例如，对于输入数组 nums = [2, 4, 2, 1, 0, 2, 0] 的记忆表如下，G 代表 GOOD，B 代表 BAD。我们发现不能从下标 2，3，4 到达最终坐标 6，但可以从 0，1，5 和 6 到达最终坐标 6。<br>
步骤<br>
初始化 memo 的所有元素为 UNKNOWN，除了最后一个显然是 GOOD （自己一定可以跳到自己）<br>
优化递归算法，每步回溯前先检查这个位置是否计算过（当前值为：GOOD / BAD）<br>
如果已知直接返回结果 True / False<br>
否则按照之前的回溯步骤计算<br>
计算完毕后，将结果存入memo表中</p>
</blockquote>
<pre><code>Java
enum Index {
    GOOD, BAD, UNKNOWN
}

public class Solution {
    Index[] memo;

    public boolean canJumpFromPosition(int position, int[] nums) {
        if (memo[position] != Index.UNKNOWN) {
            return memo[position] == Index.GOOD ? true : false;
        }

        int furthestJump = Math.min(position + nums[position], nums.length - 1);
        for (int nextPosition = position + 1; nextPosition &lt;= furthestJump; nextPosition++) {
            if (canJumpFromPosition(nextPosition, nums)) {
                memo[position] = Index.GOOD;
                return true;
            }
        }

        memo[position] = Index.BAD;
        return false;
    }

    public boolean canJump(int[] nums) {
        memo = new Index[nums.length];
        for (int i = 0; i &lt; memo.length; i++) {
            memo[i] = Index.UNKNOWN;
        }
        memo[memo.length - 1] = Index.GOOD;
        return canJumpFromPosition(0, nums);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n^2))，数组中的每个元素，假设为 i，需要搜索右边相邻的 nums[i] 个元素查找是否有 GOOD 的坐标。 nums[i] 最多为 n，n 是 nums 数组的大小。<br>
空间复杂度：O(2n)=O(n)，第一个 n 是栈空间的开销，第二个 n 是记忆表的开销。</p>
</blockquote>
<blockquote>
<p>方法 3：自底向上的动态规划<br>
底向上和自顶向下动态规划的区别就是消除了回溯，在实际使用中，自底向下的方法有更好的时间效率因为我们不再需要栈空间，可以节省很多缓存开销。更重要的事，这可以让之后更有优化的空间。回溯通常是通过反转动态规划的步骤来实现的。<br>
这是由于我们每次只会向右跳动，意味着如果我们从右边开始动态规划，每次查询右边节点的信息，都是已经计算过了的，不再需要额外的递归开销，因为我们每次在 memo 表中都可以找到结果。</p>
</blockquote>
<pre><code>Java
enum Index {
    GOOD, BAD, UNKNOWN
}

public class Solution {
    public boolean canJump(int[] nums) {
        Index[] memo = new Index[nums.length];
        for (int i = 0; i &lt; memo.length; i++) {
            memo[i] = Index.UNKNOWN;
        }
        memo[memo.length - 1] = Index.GOOD;

        for (int i = nums.length - 2; i &gt;= 0; i--) {
            int furthestJump = Math.min(i + nums[i], nums.length - 1);
            for (int j = i + 1; j &lt;= furthestJump; j++) {
                if (memo[j] == Index.GOOD) {
                    memo[i] = Index.GOOD;
                    break;
                }
            }
        }

        return memo[0] == Index.GOOD;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n^2)，数组中的每个元素，假设为 i，需要搜索右边相邻的 nums[i] 个元素查找是否有 GOOD 的坐标。 nums[i] 最多为 n，n 是 nums 数组的大小。<br>
空间复杂度：O(n)，记忆表的存储开销。</p>
</blockquote>
<blockquote>
<p>方法 4：贪心<br>
当我们把代码改成自底向上的模式，我们会有一个重要的发现，从某个位置出发，我们只需要找到第一个标记为 GOOD 的坐标（由跳出循环的条件可得），也就是说找到最左边的那个坐标。如果我们用一个单独的变量来记录最左边的 GOOD 位置，我们就可以避免搜索整个数组，进而可以省略整个 memo 数组。<br>
从右向左迭代，对于每个节点我们检查是否存在一步跳跃可以到达 GOOD 的位置（currPosition + nums[currPosition] &gt;= leftmostGoodIndex）。如果可以到达，当前位置也标记为 GOOD ，同时，这个位置将成为新的最左边的 GOOD 位置，一直重复到数组的开头，如果第一个坐标标记为 GOOD 意味着可以从第一个位置跳到最后的位置。<br>
模拟一下这个操作，对于输入数组 nums = [9, 4, 2, 1, 0, 2, 0]，我们用 G 表示 GOOD，用 B 表示 BAD 和 U 表示 UNKNOWN。我们需要考虑所有从 0 出发的情况并判断坐标 0 是否是好坐标。由于坐标 1 是 GOOD，我们可以从 0 跳到 1 并且 1 最终可以跳到坐标 6，所以尽管 nums[0] 可以直接跳到最后的位置，我们只需要一种方案就可以知道结果。</p>
</blockquote>
<pre><code>Index	0	1	2	3	4	5	6
nums	9	4	2	1	0	2	0
memo	U	G	B	B	B	G	G
Java
public class Solution {
    public boolean canJump(int[] nums) {
        int lastPos = nums.length - 1;
        for (int i = nums.length - 1; i &gt;= 0; i--) {
            if (i + nums[i] &gt;= lastPos) {
                lastPos = i;
            }
        }
        return lastPos == 0;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)，只需要访问 nums 数组一遍，共 n 个位置，n 是 nums 数组的长度。<br>
空间复杂度：O(1)，不需要额外的空间开销。</p>
</blockquote>
<blockquote>
<p>总结<br>
最后一个问题是，如何在面试场景中想到这个做法。我的建议是“酌情考虑”。最好的解法当然和别的解法相比更简单也更短，但是不那么容易直接想到。<br>
递归回溯的版本最容易想到，所以在思考更复杂解法的时候可以顺带提及一下这个解法，你的面试官实际上可能会想要看到这个解法。但如果没有，请提及可以使用动态规划的解法，并试想一下如何用记忆表来实现。如果你发现面试官希望你回答自顶向下的方法，那么就不太需要思考自底向上的版本，但我推荐在面试中提及一下自底向下的优点。</p>
</blockquote>
<p>其实官方解主要还是集中注意力在动态规划上，算是对动态规划的一个学习加深吧，特别是最后一个自底向上倒推的的方法，挺不错的，就是一开始我想解决的方向，当然我感觉我的方法也不错hhh（在题解中也是第一高赞题解hhh），所以就保留答案最为最理想答案吧，当然官方题解的总结很到位，以后复习的时候还是得好好看看动态规划的方法，毕竟动态规划才是更通用的做法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第六章 笔记+习题 6.1-6.2]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-liu-zhang-bi-ji-xi-ti-61-63</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-liu-zhang-bi-ji-xi-ti-61-63">
        </link>
        <updated>2019-09-12T01:09:34.000Z</updated>
        <content type="html"><![CDATA[<p>6.1函数基础<br>
一个函数定义包括：返回类型，函数名字，由0个或多个形参组成的列表以及函数体<br>
通过调用运算符来<strong>执行函数，调用运算符的形式是一对圆括号</strong>，作用于一个表达式，表达式是函数或者指向函数的指针，圆括号内为实参，实参初始化形参，调用表达式的类型就是函数的类型<br>
函数第一步是隐式地定义并初始化形参<br>
实参的类型和数量都必须与形参匹配，所以形参一定会被初始化<br>
空形参可以是隐式或者<strong>显式（void）</strong><br>
每个形参的类型都必须单独声明，不可以因为类型相同而忽略<br>
形参可以<strong>空名</strong>，但不可以同名，<strong>通常以空名代表不被使用，但也必须用实参初始化</strong><br>
函数的返回类型不可以是<strong>数组或者函数</strong>，但可以是指向数组的<strong>指针或引用</strong></p>
<p>习题6.1<br>
实参是形参的初始值，实参用于初始化对应位置的形参<br>
习题6.2<br>
（a）返回类型为int<br>
（b）没有定义返回类型<br>
（c）形参名字不可以相同<br>
（d）函数体不管语句数量多少，必须使用花括号<br>
习题6.3+6.4</p>
<pre><code>int factorial(int fact);
int main() {
	int i;
	while (cin) {
		cout &lt;&lt; &quot;please input one number:&quot;;
		cin &gt;&gt; i;
		cout &lt;&lt; factorial(i) &lt;&lt; endl;
	}
};

int factorial(int fact) {
	int sum=1;
	while (fact)
		sum *= fact--;
	return sum;
}
</code></pre>
<p>知识点：不要忽略了函数的声明！<br>
习题6.5</p>
<pre><code>int num_abs(int num);

int main() {
	int i;
	while (cin) {
		cout &lt;&lt; &quot;please input one number:&quot;;
		cin &gt;&gt; i;
		cout &lt;&lt; num_abs(i) &lt;&lt; endl;
	}
};

int num_abs(int num) {
	return num&gt;0?num:-num;
}
</code></pre>
<p>6.1.1局部对象<br>
名字有作用域，对象有生命周期<br>
形参和函数体内部定义的变量统称为局部变量<br>
自动对象 只存在于块执行期间的对象 块执行结束后，自动对象的值变为未定义<br>
形参是一种自动对象，内置类型的未初始化局部变量将产生未定义的值<br>
局部静态对象 static 直到程序终止时才被销毁，在此期间就算函数执行结束也不会对她产生影响（可以用来计算函数调用次数）<br>
内置类型的局部静态变量默认初始化为0，而不是未定义</p>
<p>习题6.6<br>
形参和局部静态变量都属于局部变量，只存在于块执行期间，但是局部静态变量的存在周期为整个程序执行期间，形参在块执行后的值变为未定义。代码见2.7<br>
习题6.7</p>
<pre><code>int formal_param(int f);

int main() {
	int i = 10;
	while(i)
		formal_param(i),--i;
};

int formal_param(int f) {
	int i=0;
	static int s_i=0;
	cout &lt;&lt; f&lt;&lt;' '&lt;&lt;++i &lt;&lt; ' ' &lt;&lt; ++s_i&lt;&lt;endl;
	return 0;
}
</code></pre>
<p>6.1.2<br>
函数只能定义一次，但可以声明多次。函数声明无须函数体，可以忽略形参的名字，用一个分号代替 例如 int add(int ,int);<br>
函数声明也称作函数原型<br>
建议函数和变量在<strong>头文件中声明，在源文件中定义,</strong><br>
含有函数声明的头文件应该被包含到定义函数的源文件中，<br>
<strong>通过以上的配合，其实就是将所有用到该函数的cpp文件中的声明移动到头文件中，编译器会自动在包含了头文件的cpp文件中搜索函数定义，从而以后可以很方便地修改函数的声明（比如修改形参数量），不需要一个一个地在使用了该函数的cpp文件中修改。</strong></p>
<p>习题6.8<br>
chapter6.h</p>
<pre><code>#pragma once
#ifndef CHAPTER6_H
#define CHAPTER6_H
int factorial(int fact);
#endif // !CHAPTER6_H
</code></pre>
<p>homework6.8.cpp</p>
<pre><code>#include &quot;chapter6.h&quot;

int factorial(int fact) {
	int sum = 1;
	while (fact)
		sum *= fact--;
	return sum;
}
</code></pre>
<p>6.1.3<br>
分离式编译允许我们把程序分割到几个文件中去，每个文件相互独立<br>
如果我们修改了某个源文件，只需要单独编译改动了的文件生成对象代码文件<br>
分离式编译会产生对象代码文件<br>
最后再把对象文件链接到一起形成可执行文件</p>
<p>习题6.9<br>
其实6.8中已经完成了这个任务，homework6.8对应于fact.cc 。</p>
<p>6.2参数传递<br>
如果形参是引用类型，实参被引用传递（传引用调用）。当形参非引用类型，实参的值拷贝给形参，实参被值传递（传值调用）<br>
6.2.1<br>
拷贝传递不会影响实参的值，但指针形参可以修改所指向的对象的值<br>
在c++语言中建议使用引用类型的形参</p>
<p>习题6.10</p>
<pre><code>int swap_p(int *p1, int *p2);

int main() {
	int i1 = 0, i2 = 1;
	cout &lt;&lt; i1 &lt;&lt; ' ' &lt;&lt; i2 &lt;&lt; endl;
	int *i1p = &amp;i1, *i2p = &amp;i2;
	swap_p(i1p, i2p);
	cout &lt;&lt; i1 &lt;&lt; ' ' &lt;&lt; i2 &lt;&lt; endl;
	return 0;
};

int swap_p(int *p1,int *p2) {
	 *p1 = *p1 + *p2;
	 *p2 = *p1 - *p2;
	 *p1 = *p1 - *p2;
	 return 1;
}
</code></pre>
<p>6.2.2<br>
<strong>使用引用可以避免对大的类或者容器对象进行拷贝</strong><br>
如果无需改变形参的值，<strong>最好将其声明为常量引用</strong><br>
可以使用引用类型的形参返回额外信息</p>
<p>习题6.11</p>
<pre><code>int main() {
	int i = 1;
	cout &lt;&lt; i &lt;&lt; endl;
	reset(i);
	cout &lt;&lt; i &lt;&lt; endl;
	return 0;
};

void reset(int &amp;p) {
	p = 0;
}
</code></pre>
<p>习题6.12</p>
<pre><code>int main() {
	int i1 = 0, i2 = 1;
	cout &lt;&lt; i1 &lt;&lt; ' ' &lt;&lt; i2 &lt;&lt; endl;
	int &amp;i1p = i1, &amp;i2p = i2;
	swap_p(i1p, i2p);
	cout &lt;&lt; i1 &lt;&lt; ' ' &lt;&lt; i2 &lt;&lt; endl;
	return 0;
};

int swap_p(int &amp;p1, int &amp;p2) {
	p1 = p1 + p2;
	p2 = p1 - p2;
	p1 = p1 - p2;
	return 1;
}
</code></pre>
<p>非常明显 引用更加好用。免去了*字符和&amp;字符的繁杂<br>
习题6.13<br>
一个是传值调用，一个是传引用调用，前者只是拷贝副本，后者可以通过引用更改原值<br>
习题6.14<br>
比如对两个矩阵进行比较，矩阵值特别大时再进行传值会导致内存不足，同时iostream等输入输出流是不可以拷贝的。如果不想修改原变量的值，就不应该使用引用。<br>
习题6.15<br>
我们不希望s被拷贝，也不希望s被修改，所以使用const &amp;，occur会被修改，所以用普通引用，我们不希望函数通过c的值来修改原值，所以不使用引用。否则s会被修改，occur无法递增</p>
<p>6.2.3<br>
指向常量的指针也可以指向非常量，只是不能解引用赋值，<strong>也不能赋值给普通指针</strong>。常量指针不能改变指针的值，<strong>但是可以解引用赋值</strong><br>
当实参初始化形参时会忽略顶层const，所以当形参有顶层const时，传给它常量对象或者非常量对象都可以（但实参的顶层const不会被忽略）<br>
在函数定义或者声明的过程中，因为顶层const被忽略了，所以形参中的const int和  int没有区别，编译器会认为重复了（<strong>但是在函数体中仍然不能改变const形参的值</strong>）<br>
非常量引用形参的<strong>两个问题</strong>：<br>
1.形参为<strong>int引用</strong>时，只能传入int类型的对象，不能用字面值、求值结果为int的表达式、需要转换的对象或者<strong>const int类型</strong>的对象，但** 常量引用可以使用字面值**，所以建议使用常量引用<br>
2.在函数内部使用形参作为另外一个函数的形参时，需要注意引用类型是否一致，例如：</p>
<pre><code>void fun1(const int &amp;param){
	fun2(param);//void fun2(int &amp; param)时错误，**int&amp;只接受普通引用 **
}
</code></pre>
<p>所以尽可能使用常量引用</p>
<p>习题6.18<br>
（a）<code>bool compare(matrix &amp;m1,matrix&amp;m2);</code><br>
（b）<code>vector&lt;int&gt;::iterator change_val(int i,vector&lt;int&gt;::iterator i_v);</code><br>
习题6.19<br>
（a）不合法，形参数目不对<br>
（b）合法<br>
（c）合法，有隐式转换<br>
（d）合法，有隐式转换<br>
习题6.20<br>
常量引用：不希望拷贝传值和被改动。普通引用的话原值可能会被改动。</p>
<p>6.2.4<br>
数组两个特殊性质，1.<strong>不允许拷贝数组</strong>2.使用数组名时通常会将其转换成指针<br>
所以函数传递数组时实际上传递的是指向数组首元素的指针<br>
1.Int* a   2.int a[]     3.int a[10]   这三个形参实际上是一样的，都等同于第一个<br>
管理指针形参<br>
1.使用结束标记间接指定数组长度，比如c风格字符串结尾的空字符 例如while(<em>cp)指向结尾空字符就会结束<br>
2.使用标准库规范 传递指向数组首尾元素的指针 int a[10];begin(a),end(a);<br>
3.显式传递一个表示数组大小的形参 end(a)-begin(a);<em><em>sizeof(a)/sizeof(<em>a)</em></em><br>
数组引用形参定义过程中，</em><em>&amp;arr两端的括号不可以少</em></em>，但数组引用形参一开始就需要确定数组大小 (&amp;arr)[10]；数组的引用 &amp;arr[10]；错误，没有数组的引用</p>
<p>习题6.21</p>
<pre><code>int compare(int p1, int *p2);

int main() {
	int i1,i2;
	cout &lt;&lt; &quot;please input two number:&quot;;
	cin &gt;&gt; i1 &gt;&gt; i2;
	cout &lt;&lt; &quot;the larger one is &quot;;
	int *i1p = &amp;i1, *i2p = &amp;i2;
	cout &lt;&lt; compare(i1, i2p) &lt;&lt; endl;
	return 0;
};

int compare(int p1, int *p2) {
	return p1&gt;*p2?p1:*p2;
}
</code></pre>
<p>习题6.22</p>
<pre><code>int main() {
	int i1,i2;
	cout &lt;&lt; &quot;please input two number:&quot;;
	cin &gt;&gt; i1 &gt;&gt; i2;
	int *i1p = &amp;i1, *i2p = &amp;i2;
	cout &lt;&lt; *i1p &lt;&lt; ' ' &lt;&lt; *i2p &lt;&lt; endl;
	swap_p(i1p, i2p);
	cout &lt;&lt; *i1p &lt;&lt; ' ' &lt;&lt; *i2p &lt;&lt; endl;
	return 0;
};

void swap_p(int *&amp;p1, int *&amp;p2) {
	int *temp = p1;
	p1 = p2;
	p2 = temp;
}
</code></pre>
<p>习题6.23</p>
<pre><code>int main() {
	int j[2] = { 0,1 };
	int i = 0;
	auto j_b = begin(j);
	auto j_e = end(j);
	print(i);
	print(j_b, j_e);
	return 0;
};

void print(const int&amp; i) {
	cout &lt;&lt; i &lt;&lt; endl;
}
void print(int *beg,int *end) {
	while (beg != end)
		cout &lt;&lt; *beg++ &lt;&lt; endl;

}
</code></pre>
<p>习题6.24<br>
程序希望逐个输出数组ia的元素，但是形参没有使用引用或指针，数组是无法直接拷贝给形参的！！！所以传递的仅仅是头指针</p>
<p>6.2.5<br>
int main(int argc,char *argv[]){….}<br>
main处理命令行选项，argc表示变量的数量，argv[0]保存程序的名字，可选实参从argv[1]开始</p>
<p>习题6.25&amp;.26</p>
<pre><code>int main(int argc,char* argv[]) {
	string s;
	for (int i = 1; i &lt; argc; ++i)
		s = s + argv[i];
	cout &lt;&lt; s &lt;&lt; endl;
};
</code></pre>
<p>知识点：string的向量可以用 string+=char，特别是string为空的时候，不能直接string=char+char，第一个必须是string。</p>
<p>6.2.6<br>
<strong>函数的实参数量未知但类型相同</strong>，可以使用initializer_list类型的形参，这是一种标准库类型，用于表示某种特定类型的值的数组，<strong>和vector一样也是一种模版类型，但其对象中的元素永远是常量值，无法改变元素的值</strong>（元素值是const）<br>
向initializer_list形参传递一个值的序列的时候，必须把序列放在<strong>一对花括号内</strong></p>
<p>习题6.27</p>
<pre><code>int add_list(initializer_list&lt;int&gt; i);

int main(int argc,char* argv[]) {
	initializer_list&lt;int&gt; i{ 1,2,3,4,5,6,7 };
	cout &lt;&lt; add_list(i) &lt;&lt; endl;
};

int add_list(initializer_list&lt;int&gt; i) {
	int sum = 0;
	for (auto num : i)
		sum += num;
	return sum;
}
</code></pre>
<p>习题6.28<br>
elem的类型为const string&amp;<br>
习题6.29<br>
应该，因为initailizer_list的对象都是const值，使用引用可以避免拷贝和修改，但是要注意配合auto使用（实测加了auto &amp;，会自动加上const）</p>
<p>习题感悟：<br>
不要忽略了函数的声明！<br>
数组是无法直接拷贝给形参的！！！<br>
string的向量可以用 string+=char，特别是string为空的时候，不能直接string=char+char，第一个必须是string。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组217. 存在重复元素]]></title>
        <id>https://lixin-ee.github.io//post/217-cun-zai-chong-fu-yuan-su</id>
        <link href="https://lixin-ee.github.io//post/217-cun-zai-chong-fu-yuan-su">
        </link>
        <updated>2019-09-11T15:30:24.000Z</updated>
        <content type="html"><![CDATA[<p>题目：</p>
<blockquote>
<p>给定一个整数数组，判断是否存在重复元素。<br>
如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</p>
<p>示例 1:<br>
输入: [1,2,3,1]<br>
输出: true<br>
示例 2:<br>
输入: [1,2,3,4]<br>
输出: false<br>
示例 3:<br>
输入: [1,1,1,3,3,4,3,2,4,2]<br>
输出: true<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/contains-duplicate<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>今天看了一天STL的hashtable，看得有点愣愣的，不过确实是牛逼，没想到这道题就用上了hhhh，非常适合用哈希map，把每个值作为key，再把出现次数作为mapped_value进行递增，第一次给出的代码如下：</p>
<pre><code>class Solution {
public:
    bool containsDuplicate(vector&lt;int&gt;&amp; nums) {
        int len = nums.size();
        if(len==0||len==1)
            return false;
        map&lt;int,int&gt; nums_map;
        for(auto i:nums)
            if(nums_map.find(i)==nums_map.end())
                nums_map.insert({i,1});
            else
                ++nums_map[i];
        for(auto i=nums_map.begin();i!=nums_map.end();++i)
            if(i-&gt;second&gt;1)
                return true;
        return false;
        
    }
};
</code></pre>
<p>依赖于STL的强大，毫无疑问地一次过啦hhh，但是花的时间比较长，所以打算看一下官方题解中hashmap的解答：</p>
<blockquote>
<p>方法三：哈希表 【通过】<br>
直觉<br>
利用支持快速搜索和插入操作的动态数据结构。<br>
算法<br>
从方法一中我们知道，对无序数组的查找操作的时间复杂度为 O(n)，而我们会重复调用查找操作。因此，使用搜索时间更快的数据结构将加快整个算法的速度。<br>
有许多数据结构常用作动态集合,如二进制搜索树和哈希表。这里我们需要的操作是 search 和 insert。对于平衡二叉搜索树（Java 中的 TreeSet 或 TreeMap），search 和 insert 的时间复杂度均为 O(logn)。对于哈希表（Java 中的 HashSet 或 HashMap），search 和 insert 的平均时间复杂度为 O(1)。因此，通过使用哈希表，我们可以达到在线性时间复杂度解决问题。</p>
</blockquote>
<pre><code>Java
public boolean containsDuplicate(int[] nums) {
    Set&lt;Integer&gt; set = new HashSet&lt;&gt;(nums.length);
    for (int x: nums) {
        if (set.contains(x)) return true;
        set.add(x);
    }
    return false;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 : O(n)。<br>
search() 和 insert() 各自使用 nn 次，每个操作耗费常数时间。<br>
空间复杂度 : O(n)。哈希表占用的空间与元素数量是线性关系。<br>
注意<br>
对于一些特定的 n 不太大的测试样例，本方法的运行速度可能会比方法二更慢。这是因为哈希表在维护其属性时有一些开销。要注意，程序的实际运行表现和 Big-O 符号表示可能有所不同。Big-O 只是告诉我们在 充分 大的输入下，算法的相对快慢。因此，在 nn 不够大的情况下， O(n) 的算法也可以比 O(nlogn)的更慢。</p>
</blockquote>
<p>看官方题解还是开卷有益的，我的源代码问题在于需要遍历两次，但是经过官方题解的指点获得了很好的灵感，c++的hashmap会返回一对pair，前者是迭代器，后者则是bool值，正好用于返回，所以在插入阶段只要出现插入失败（重复）就可以直接返回pair的second值作为结果了，非常简单暴力，结果也是一次通过，节省了很多时间。下面为修改后的最后代码：</p>
<pre><code>class Solution {
public:
    bool containsDuplicate(vector&lt;int&gt;&amp; nums) {
        int len = nums.size();
        if(len==0||len==1)
            return false;
        map&lt;int,int&gt; nums_map;
        for(auto i:nums)
            if(!nums_map.insert({i,1}).second)
                return true;
        return false;
        
    }
};
</code></pre>
<p>然后来看看剩下的两个官方题解吧，毕竟hashmap属于STL的拿来即用，属于前人栽树后人乘凉，面试的时候直接写个hashmap不知道会不会被打死，同时在前面我也说到过其实不太喜欢用hashmap，毕竟做算法就是要理解背后的原理，一个好算法应该是通用性高的泛型算法。</p>
<blockquote>
<p>方法一：朴素线性查找 【超时】<br>
直觉<br>
对于一个有 nn 个整数的数组，一共有n(n+1)/2 对整数。因此，我们可以对所有的<br>
对进行检测，看它们是否相同。<br>
算法<br>
为了实现这个思路，我们使用线性查找算法，这是最简单的查找算法。线性查找是一种检查特定值是否在列表中的算法，做法是依次逐个检查列表中的元素，直到找到满足的元素。<br>
对于本问题，我们循环遍历全部 n 个数。对于第 i 个整数 nums[i]，我们对前 i-1 个整数查找 nums[i] 的重复值。若找到，则返回 True; 否则继续。在程序最后，返回 False。<br>
为了证明算法的正确性，我们定义了循环不变式。循环不变式是指在每次迭代前和后均保持不变的性质。了解循环不变式对理解循环的意义十分重要。下面就是循环不变式:<br>
在下一次搜索之前,搜索过的整数中没有重复的整数。<br>
循环不变式在循环之前为真，因为还没有搜索过的整数。每次循环，我们查找当前元素的任何可能重复。如果发现重复项,则函数返回 True 退出；如果没有发现，则不变式仍然成立。<br>
因此，如果循环结束，循环不变式说明全部 nn 个整数中不存在重复元素。</p>
</blockquote>
<pre><code>Java
public boolean containsDuplicate(int[] nums) {
    for (int i = 0; i &lt; nums.length; ++i) {
        for (int j = 0; j &lt; i; ++j) {
            if (nums[j] == nums[i]) return true;  
        }
    }
    return false;
}
// Time Limit Exceeded
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 : O(n<sup>2)。最坏的情况下，需要检查n(n+1)/2对整数。因此，时间复杂度为O(n</sup>2 )。<br>
空间复杂度 : O(1)。只使用了常数额外空间。<br>
注意<br>
本方法在 Leetcode 上会超时。一般而言，如果一个算法的时间复杂度为 O(n<br>
^2 )，它最多能处理 n 大约为 10^4 的数据。当 n 接近 10^5时就会超时。</p>
<p>方法二：排序 【通过】<br>
直觉<br>
如果存在重复元素，排序后它们应该相邻。<br>
算法<br>
本方法使用排序算法。由于比较排序算法，如堆排序，可以在最坏情况下具有O(nlogn) 的时间复杂度。因此，排序经常是很好的预处理方法。排序之后，我们可以扫描已排序的数组,以查找是否有任何连续的重复元素。</p>
</blockquote>
<pre><code>Java
public boolean containsDuplicate(int[] nums) {
    Arrays.sort(nums);
    for (int i = 0; i &lt; nums.length - 1; ++i) {
        if (nums[i] == nums[i + 1]) return true;
    }
    return false;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度 : O(nlogn)。<br>
排序的复杂度是 O(nlogn)，扫描的复杂度是 O(n)。整个算法主要由排序过程决定，因此是 O(nlogn)。<br>
空间复杂度 : O(1)。<br>
这取决于具体的排序算法实现，通常而言，使用 堆排序 的话，是 O(1)O(1)。<br>
注意<br>
此处的算法实现对原始数组进行排序，修改了原始数组。通常，除非调用方清楚输入数据将被修改，否则不应该随意修改输入数据。可以先复制 nums，然后对副本进行操作。</p>
</blockquote>
<p>嗯....这两个官方题解都只能说是差强人意呀，第一个直接是比较了，太暴力了吧...不过循环不变式的思想还是挺有趣的，第二个也仅仅是使用了快速排序、堆排序等时间复杂度下限的排序函数，代码也有点敷衍了，直接上了Java的函数，所以这一次就当做是hashmap的小试牛刀吧，hhh还真的是牛刀。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 275. H指数 II]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-275-h-zhi-shu-ii</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-275-h-zhi-shu-ii">
        </link>
        <updated>2019-09-11T11:13:27.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目如下：<br>
给定一位研究者论文被引用次数的数组（被引用次数是非负整数），数组已经按照升序排列。编写一个方法，计算出研究者的 h 指数。<br>
h 指数的定义: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）至多有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数不多于 h 次。）&quot;</p>
<p>示例:<br>
输入: citations = [0,1,3,5,6]<br>
输出: 3<br>
解释: 给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 0, 1, 3, 5, 6 次。<br>
     由于研究者有 3 篇论文每篇至少被引用了 3 次，其余两篇论文每篇被引用不多于 3 次，所以她的 h 指数是 3。<br>
说明:<br>
如果 h 有多有种可能的值 ，h 指数是其中最大的那个。<br>
进阶：<br>
这是 H指数 的延伸题目，本题中的 citations 数组是保证有序的。<br>
你可以优化你的算法到对数时间复杂度吗？<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/h-index-ii<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>其实这道题和昨天的一毛一样，重点在于给出的数组已经是有序数组，而且在题目中很明显暗示我们达到对数时间复杂度，所以需要在时间复杂度上下功夫，昨天的答案是不能用的了。<br>
一开始我的想法就是既然排好序了，数组的序号和数组的数值之间就有了相对应的关系，只需要比较（数组长度-序号)和数值就可以了，而且从示例中可以看出，答案一般都处于中段，或者是某部分的中段，同时对数时间复杂度，和二叉树的深度可以对应起来，所以第一时间就想到了二分法，下面是一开始的代码（注意，本次是未通过的代码！）</p>
<pre><code>class Solution {
public:
    int hIndex(vector&lt;int&gt;&amp; citations) {
        if(!citations.size())
            return 0;
        int sum=0;
        int h=0;
        bool flag=true;
        int beg=0,end=citations.size()-1;
        if (!end){
            return citations[0]?1:0;
        }
        do{
        int midd = (beg+end)/2;
        if(citations.size()-midd&gt;citations[midd]){
            beg = midd;
            h = midd+1;
        }
        else if(citations.size()-midd==citations[midd]){
            h = midd+1;
            flag=false;
        }else
            flag=false;            
        }while(flag); 
        return h;
    }
};
</code></pre>
<p>代码中有很多问题，不过主要的问题还是取中值和左半边的问题，取中值的时候一直在纠结是取右中值还是左中指，最后选择左中指后还需要对结果进行+1。然后就是对数组的判断，只考虑了左半边（长度大于数值）的问题，没有考虑到右半边的问题，所以导致结果一直错误（还有一开始的空数组、{0}零数组的问题没有考虑好）<br>
最后直接看了网友题解，为什么呢，因为一开始以为二分法错了...结果打开题解发现大家都是用的二分法啊...所以还是基础不够扎实，还是得老老实实做题，下面是网友题解：</p>
<blockquote>
<p>方法：二分查找<br>
思路分析：<br>
题目中说到：<br>
本题中的 citations 数组是保证有序的。<br>
并且还暗示<br>
你可以优化你的算法到对数时间复杂度吗？<br>
因此，可以使用二分查找法。二分查找这种非对即错的问题，我也经常栽跟头，我个人觉得根据示例分析应该是一个不错的方法。<br>
不知道大家有没有这种感觉，就是代码有的时候稀里糊涂就写对了，我想应该是方法对了，可能出错的地方就是一些边界条件吧。<br>
就根据示例 citations = [0, 1, 3, 5, 6]。<br>
中位数是 3 ，citations[3] 恰好也等于 3，这个 3 正好是边界，不太好分析 ，我把中位数改成了 2。<br>
即：citations = [0, 1, 2, 5, 6]。此时根据题目意思，此时索引为 2 的那篇论文就不能被记入 h 指数（因为，如果算进去，则有 3 篇论文，但是这篇最少被引用的文章才被引用 2 次）。<br>
因此，我们分析出 h 指数和以下两个指标有关：<br>
1、某个索引 i 的 citations 的数值；<br>
2、某个索引 i 到 citations 的末尾索引的长度，即区间 [i, len - 1] 的长度，即 len - 1 - i + 1 = len - i。<br>
根据被我把中位数改成 2 的示例，如果 nums[i] &lt; len - i ，索引 i 必须后移一位，因此候选区间为 [i + 1, len - 1]，根据“二分搜索模板”可知 left = i + 1，那 nums[i] &lt; len - i 的反面一定是 mid = right，看到 left = i + 1 可知分支排除了中位数，因此默认选择左中位数是对的（不会死循环）。<br>
提交以后，发现测试用例 [0] 不能通过，想想的确有可能出现这种情况，万一这一位学者的诸多文章还没有被人引用过，h 指数就为 0 了，所以单独判断一下即可。<br>
最后，返回的是区间的长度，根据刚才的分析，这个值是 len - i。因此，本题使用二分查找法，找到 i 即可。<br>
来自用户 @coder_hezi 的总结：<br>
要返回选取的区间的长度，而选取的区间要满足区间中的数大于等于所在区间的长度。<br>
参考代码：</p>
</blockquote>
<pre><code>Java
public class Solution {
    // 思路：看 nums[mid] 和区间 [mid, len - 1] 的长度，即 len - mid - 1 + 1 = len - mid
    // 要返回的是 nums 中的值
    // [0,1,2,5,6]，
    // 以下的代码注释是 coder_hezi 帮助添加的，在此表示感谢
    public int hIndex(int[] citations) {
        int len = citations.length;
        // 特判
        if (len == 0 || citations[len - 1] == 0) {
            return 0;
        }
        int left = 0;
        int right = len - 1;
        while (left &lt; right) {
            int mid = (left + right) &gt;&gt;&gt; 1;
            // 比长度小，就得去掉该值
            if (citations[mid] &lt; len - mid) {
                left = mid + 1;
            } else {
                // 比长度大是满足的，我们应该继续让 mid 往左走去尝试看有没有更小的 mid 值
                // 可以满足 mid 对应的值大于等于从 [mid, length - 1] 的长度
                right = mid;
            }
        }
        return len - left;
    }
    public static void main(String[] args) {
        int[] citations = {0, 1, 2, 5, 6};
        Solution solution = new Solution();
        int hIndex = solution.hIndex(citations);
        System.out.println(hIndex);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(logN)，这里 N是数组的长度。<br>
空间复杂度：O(1)，使用到的变量都只有常数个。</p>
</blockquote>
<p>解题思路还是很清晰的，最重要的还是在于中值的选择和mid的处理，本题目中中值选择左中指，mid赋予给right或者把mid+1赋予给left，从而使得特殊情况比如{0，1}能够得到正确答案，同时特殊情况的判断很重要，例如{0，0}这种极端情况， citations[len - 1] == 0能够很好地消除这种情况</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++避坑]]></title>
        <id>https://lixin-ee.github.io//post/cbi-keng</id>
        <link href="https://lixin-ee.github.io//post/cbi-keng">
        </link>
        <updated>2019-09-11T04:07:17.000Z</updated>
        <content type="html"><![CDATA[<p>cout不明确：<br>
将using namespace std; 删除后保存cpp文件，<br>
再加上using namespace std;保存cpp文件。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ C++ primer 第五章 笔记+习题]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-wu-zhang-bi-ji-xi-ti</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-wu-zhang-bi-ji-xi-ti">
        </link>
        <updated>2019-09-11T01:06:33.000Z</updated>
        <content type="html"><![CDATA[<p>5.1-5.3.1<br>
空语句 用在需要语法上需要的地方， 比如while ，空语句最好加上注释<br>
复合语句 也称作块，一个块就是一个作用域。<br>
复合语句用在语法上只能一条语句但是逻辑上需要多条语句的地方，比如while和for<br>
注意while和for本来只能容纳一条语句，所以要用 { }</p>
<p>习题5.1<br>
空语句就是只有一个单独的分号的语句，什么也不执行。主要是用于语法上需要一条语句但是逻辑上不需要的地方，比如while和for循环头完成了所有操作的话，循环体就需要一个空语句<br>
习题5.2<br>
块也就是复合语句，是指用花括号括起来的语句和声明的序列。如果在语法上只能容纳一条语句但是逻辑上需要多条语句的话，就应该使用块，例如while和for的循环体<br>
习题5.3<br>
while（val&lt;=10） sum+=val,++val;<br>
可读性提高了<br>
知识点：可以用逗号运算符使得比较简短的循环体变成一句话<br>
习题5.4<br>
（a）while循环头可以进行定义，但是不应该进行定义，否则每次循环都会定义一次，如果没有显式的break就会形成死循环<br>
（b）在while循环头进行定义的变量作用域只在while循环块内，if是无法使用status的<br>
习题5.5</p>
<pre><code>int main() {
	int grade;
	const vector&lt;string&gt; level{ &quot;A+&quot;,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot; };
	cin &gt;&gt; grade;
	if (grade == 100)
		cout &lt;&lt; level[0];
	else if (grade &gt;= 90)
		cout &lt;&lt; level[1];
	else if (grade &gt;= 80)
		cout &lt;&lt; level[2];
	else if (grade &gt;= 70)
		cout &lt;&lt; level[3];
	else if (grade &gt;= 60)
		cout &lt;&lt; level[4];
	else
		cout &lt;&lt; level[5];
};
</code></pre>
<p>习题5.6</p>
<pre><code>int main() {
	int grade;
	const vector&lt;string&gt; level{ &quot;A+&quot;,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot; };
	cin &gt;&gt; grade;
	cout &lt;&lt; ((grade &lt; 60) ? level[5] : (grade &lt; 70) ? level[4] : (grade &lt; 80) ? level[3] : (grade &lt; 90) ? level[2] : (grade &lt;100) ? level[1] : level[0]);
};
</code></pre>
<p>知识点:条件运算符的优先级实在是太低了。。。连&lt;&lt;都不如，一定要加括号<br>
习题5.7<br>
（a）没有加分号<br>
（b）没有加花括号，没法形成块<br>
（c）ival定义在while循环头，作用域只在while内部<br>
（d）==号和=号的差别特别大， 虽然合法，但是循环达不到预期效果。<br>
习题5.8<br>
悬垂else是指if的数量大于else的数量，容易造成二义性，从而规定else与离它最近的尚未匹配的if进行匹配。</p>
<p>5.3.2<br>
switch语句中case标签必须是<strong>整形</strong>常量表达式（3 或者 ‘a’） 3.14或者 int 型都不行，除了default<br>
任何两个<strong>case标签不能相同</strong><br>
两个case标签之间要有break语句，<strong>否则会连续执行</strong>接下来的case<br>
无break语句应该备注注释<br>
default语句就算为空也应该定义<br>
每个标签都应该跟上一条语句、空语句或者空块<br>
在case语句中 <strong>不能进行变量的初始化，但可以进行变量的定义</strong>。<br>
最好在case内定义一个块，再定义并初始化变量，保证其他case都在作用域外</p>
<p>习题5.9</p>
<pre><code>int main() {
	string s;
	while (cin &gt;&gt; s) {
		int num = 0;
		for (auto letter : s)
			switch (letter)
			{
			case 'a': {++num; break; }
			case 'i': {++num; break; }
			case 'o': {++num; break; }
			case 'u': {++num; break; }
			case 'e': {++num; break; }
			default:break;
			}
		cout &lt;&lt; &quot;num is &quot; &lt;&lt; num&lt;&lt;endl;
	}
};
</code></pre>
<p>习题5.10</p>
<pre><code>int main() {
	string s;
	while (cin &gt;&gt; s) {
		int num = 0;
		for (auto letter : s)
			switch (letter)
			{
			case'A': case 'a': {++num; break; }
			case'I': case 'i': {++num; break; }
			case'O': case 'o': {++num; break; }
			case'U': case 'u': {++num; break; }
			case'E': case 'e': {++num; break; }
			default:break;
			}
		cout &lt;&lt; &quot;num is &quot; &lt;&lt; num&lt;&lt;endl;
	}
};
</code></pre>
<p>习题5.11</p>
<pre><code>int main() {
	char s;
	int num = 0;
	int space = 0, tab = 0, enter = 0;
	while (cin&gt;&gt;noskipws&gt;&gt;s) {	
			switch (s)
			{
			case'A': case 'a': {++num; break; }
			case'I': case 'i': {++num; break; }
			case'O': case 'o': {++num; break; }
			case'U': case 'u': {++num; break; }
			case'E': case 'e': {++num; break; }
			case' ': {++space; break; }
			case'\t': {++tab; break; }
			case'\n': {++enter; break; }
			default:break;
			}
	}
	cout &lt;&lt; &quot;num is &quot; &lt;&lt; num &lt;&lt; endl;
	cout &lt;&lt; &quot;space is &quot; &lt;&lt; space &lt;&lt; endl;
	cout &lt;&lt; &quot;tab is &quot; &lt;&lt; tab &lt;&lt; endl;
	cout &lt;&lt; &quot;enter is &quot; &lt;&lt; enter &lt;&lt; endl;
};
</code></pre>
<p>知识点：注意此处不能再用string了 string的逐个字母判断遇到空格等字符就会停止。。。只能用char一个一个读入。<br>
习题5.12</p>
<pre><code>int main() {
	string s;
	int ff = 0, fl = 0, fi = 0;
	while (cin &gt;&gt; s) {
		for (int i = 0; i &lt; s.size() - 1; ++i) {
			auto letter = s[i];
			switch (letter)
			{
			case 'f': {
				switch (s[i + 1])
				{
				case 'f': {++ff; break; }
				case 'l': {++fl; break; }
				case 'i': {++fi; break; }
				default:
					break;
				}
			}
			default:break;
			}
		}
	}
	cout &lt;&lt; &quot;ff is &quot; &lt;&lt; ff &lt;&lt; endl;
	cout &lt;&lt; &quot;fl is &quot; &lt;&lt; fl &lt;&lt; endl;
	cout &lt;&lt; &quot;fi is &quot; &lt;&lt; fi &lt;&lt; endl;
};
</code></pre>
<p>习题5.13<br>
（a）case直接没有break，会连续执行<br>
（b）在case语句中 不能进行变量的初始化<br>
（c）不能在同一语句中定义多个case标签<br>
（d）case后面的ival、jval等并非常量</p>
<p>5.4.1<br>
while的条件语句中可以是表达式或者带初始化的变量声明<br>
while 内部的变量（条件部分或循环体内）<strong>每次迭代都会经历创建到销毁</strong><br>
while循环使用1.迭代次数<strong>不确定</strong> 2. <strong>需要在循环结束后访问循环控制变量</strong></p>
<p>习题5.14</p>
<pre><code>int main() {
	string s;
	string s_b;
	int num=0;
	int lab=0;
	cin &gt;&gt; s;
	s_b = s;
	while (cin &gt;&gt; s) {
		if (s_b == s)
			++num, ++lab;
		else if (num)
			cout &lt;&lt; s_b &lt;&lt; &quot; occur &quot; &lt;&lt; num+1 &lt;&lt; &quot; time &quot; &lt;&lt; endl, s_b = s, num = 0;
		else
			s_b = s, num = 0;
	}
	if (!lab)
		cout &lt;&lt; &quot;no same words occur&quot; &lt;&lt; endl;
};
</code></pre>
<p>5.4.2<br>
for语句中init-statement必须是声明语句、表达式语句或者空语句<br>
for语句开始循环时init-statement执行后i<strong>立即判断一次condition</strong><br>
<strong>init-statement中定义的对象只在for循环体内可见 **<br>
init-statemen 可以定义多个对象，但是只能有一条声明语句，所以</strong>所有变量的基础类型必须相同**<br>
for 语句头中的内容都能省略</p>
<p>习题5.15<br>
（a）循环头定义的变量的作用域只在循环体，if无法调用ix<br>
（b）循环判断可以省略，但是分号；不可以省略<br>
（c）两者同时在增长，除非循环体内部有其他控制，否则陷入死循环<br>
习题5.16<br>
其实前面用得很多，就得根据情况而定，甚至有时候使用do while都更加方便<br>
习题5.17</p>
<pre><code>int main() {
	vector&lt;int&gt; v1;
	vector&lt;int&gt; v2;
	int len = (v1.size() &lt; v2.size() ? v1.size() : v2.size());
	int i = 0;
	for (; i &lt; len; ++i)
		if (v1[i] != v2[i])
			return -1;
	return 1;	
};
</code></pre>
<p>5.4.3<br>
范围For 语句<br>
Expression 表示的必须是一个<strong>序列</strong><br>
比如花括号括起来的初始值列表、数组、vector 、string ，这些类型的共同特点是<strong>拥有能返回迭代器的begin和end成员</strong><br>
5.4.4<br>
do while语句 至少执行一次循环<br>
<strong>不允许在条件部分定义变量，否则变量使用出现在定义之前</strong><br>
do while在<strong>循环体内定义的变量也无法在条件部分使用</strong><br>
do while 的while<strong>条件部分后应该有；号</strong></p>
<p>习题5.18<br>
（a）do后面需要使用块语句<br>
（b）do while在循环判断中定义的变量是没有意义的<br>
（c）do while 在循环体中定义的变量也没法给循环判断使用<br>
习题5.19</p>
<pre><code>int main() {
	string s1, s2;
	do {
		cin &gt;&gt; s1 &gt;&gt; s2;
		string output = s1.size() &lt; s2.size() ? s1 : s2;
		cout &lt;&lt; &quot;the shorter is &quot; &lt;&lt; output &lt;&lt; endl;
	}
	while (cin);
};
</code></pre>
<p>5.5.1 break语句<br>
终止离它<strong>最近</strong>的while，do while，for，switch语句</p>
<p>习题5.20</p>
<pre><code>int main() {
	string s, s_b;
	int flag=0;
	cin &gt;&gt; s;
	s_b = s;
	do {
		cin &gt;&gt; s;
		if (s_b == s) {
			++flag; 
			break;
		}
		s_b = s;
	}
	while (cin);
	if (!flag)
		cout &lt;&lt; &quot;no same word&quot; &lt;&lt; endl;
	else
		cout &lt;&lt; s_b &lt;&lt; &quot; is the same word&quot;&lt;&lt;endl;
};
</code></pre>
<p>5.5.2 continue语句<br>
不能用于switch</p>
<p>习题5.21</p>
<pre><code>int main() {
	string s, s_b;
	int flag=0;
	cin &gt;&gt; s;
	s_b = s;
	do {
		cin &gt;&gt; s;
		if (s_b == s) 
			if(s[0]&gt;='A'&amp;&amp;s[0] &lt;= 'Z'){
			++flag; 
			break;
			}
			else
				continue;
		s_b = s;
	}
	while (cin);
	if (!flag)
		cout &lt;&lt; &quot;no same word&quot; &lt;&lt; endl;
	else
		cout &lt;&lt; s_b &lt;&lt; &quot; is the same word&quot;&lt;&lt;endl;
};

</code></pre>
<p>5.5.3goto语句<br>
不建议使用<br>
带标签语句<br>
标签标示符 独立于变量和其他标示符名字 可以和其他标示符使用同一个名字</p>
<p>习题5.22</p>
<pre><code>for（int sz =get_size()；sz&lt;=0；）
	sz =get_size()；
</code></pre>
<p>5.6<br>
throw表达式 表示异常检测部分遇到了无法处理的问题<br>
try语句块 用于处理异常 以一个或多个catch语句结束<br>
catch语句 异常处理代码<br>
异常类 用于在throw和catch语句之间传递异常的具体信息<br>
5.6.1<br>
标准库异常类型定义在stdexcept头文件中 需要添加std：：前缀<br>
throw表达式 throw errorstyle（）；<br>
例子 throw std::runtime_error(“错误信息”) //例如(“data must refer to same ISBN”)<br>
runtime_error对象需要使用string对象或者c风格字符串进行初始化<br>
5.6.2<br>
Try{ 正常逻辑<br>
}catch (异常声明){异常处理<br>
}<br>
每个标准库异常类都定义了名为what的成员函数，没有参数，返回值是c风格字符串, const char*,使用例子：</p>
<pre><code>try {
		if (j == 0)
			throw runtime_error(&quot;j cannot be zero&quot;);
		cout &lt;&lt; &quot;result is &quot; &lt;&lt; i / j &lt;&lt; endl;
	}
	catch (runtime_error error) {
		cout &lt;&lt; error.what() &lt;&lt; endl;
</code></pre>
<p>发生异常时,可能有多个try-catch语句的嵌套，Try语句从外到内执行，catch语句从内到外搜索，如果最终都没找到匹配的catch，程序转到terminate标准库函数<br>
5.6.3<br>
exception，bad_alloc，bad_cast异常类型的对象只能默认初始化不能提供初始值，其他的需要用string或c风格字符串初始化，不允许用默认初始化<br>
异常类型只定义了一个what成员函数，提供关于异常的文本信息</p>
<p>习题5.23</p>
<pre><code>int main() {
	int i, j;
	cin &gt;&gt; i &gt;&gt; j;
	if (j == 0)
		throw runtime_error(&quot;j cannot be zero&quot;);
	else
		cout &lt;&lt; &quot;result is &quot; &lt;&lt; i / j &lt;&lt; endl;
};
</code></pre>
<p>习题5.24<br>
vs 显示abort() has been called<br>
习题5.25</p>
<pre><code>int main() {
	int i, j;
	while(cin &gt;&gt; i &gt;&gt; j)
	try {
		if (j == 0)
			throw runtime_error(&quot;j cannot be zero&quot;);
		cout &lt;&lt; &quot;result is &quot; &lt;&lt; i / j &lt;&lt; endl;
	}
	catch (runtime_error error) {
		cout &lt;&lt; error.what() &lt;&lt; endl;
		cout &lt;&lt; &quot;whether you want to continue?[y/n]&quot;;
		string s;
		cin &gt;&gt; s;
		if (s[0] == 'y')
			continue;
		else
			break;
	}	
};
</code></pre>
<p>知识点：如果try-catch语句在循环体内，在catch 语句中也可以使用continue和break；</p>
<p>习题感悟<br>
可以用逗号运算符使得比较简短的循环体变成一句话<br>
cout &lt;&lt; ((grade &lt; 60) ? level[5] level[0]);条件运算符的优先级实在是太低了。。。连&lt;&lt;都不如，一定要加括号<br>
string的逐个字母判断遇到空格等字符就会停止。。。只能用char一个一个读入。<br>
do while 的while条件部分后应该有；号</p>
<pre><code>do
		cin &gt;&gt; v1 &gt;&gt; v2;
	while (cin);
</code></pre>
<p>是正确的<br>
do while在<strong>循环体内定义的变量也无法在条件部分使用</strong><br>
continue语句 不能用于switch<br>
what（）的使用方法：其中runtime_error等是一个类型，可以对其定义变量</p>
<pre><code>try {
		if (j == 0)
			throw runtime_error(&quot;j cannot be zero&quot;);
		cout &lt;&lt; &quot;result is &quot; &lt;&lt; i / j &lt;&lt; endl;
	}
	catch (runtime_error error) {
		cout &lt;&lt; error.what() &lt;&lt; endl;
</code></pre>
<p>如果try-catch语句在循环体内，在catch 语句中也可以使用continue和break；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 274. H指数]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-274-h-zhi-shu</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-274-h-zhi-shu">
        </link>
        <updated>2019-09-10T03:28:18.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目如下：<br>
给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。<br>
h 指数的定义: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）至多有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数不多于 h 次。）”</p>
<p>示例:<br>
输入: citations = [3,0,6,1,5]<br>
输出: 3<br>
解释: 给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。<br>
     由于研究者有 3 篇论文每篇至少被引用了 3 次，其余两篇论文每篇被引用不多于 3 次，所以她的 h 指数是 3。<br>
说明: 如果 h 有多种可能的值，h 指数是其中最大的那个<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/h-index<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>题目还是很拗口啊，评论里很多人吐槽，但是这个看了例子还是比较好理解的，就是有两个数，一个是被引用数reference，一个是符合被引用数的文章数量number，两者是此消彼长的，而且最后只会有一个解。<br>
一开始的想法是没一个reference都遍历一次数组，根据reference的值和number的值的差异来判断是否达到了临界值或者超过了临界值，这个临界值就是所求。<br>
最后的代码如下：</p>
<pre><code>class Solution {
public:
    int hIndex(vector&lt;int&gt;&amp; citations) {
        
        if(!citations.size())
            return 0;
        int h=0;
        int h_refer=0,h_num=0;
        do{
            h_refer++;
            h_num=0;
            for(auto i:citations)
                 if (i&gt;=h_refer)
                    h_num++;
            if(h_refer&lt;=h_num)
                ++h;
        }while(h_refer&lt;h_num);
            return h;
    }
};
</code></pre>
<p>一次通过啦！！！愉快的一天！！！<br>
但是其实中途还是有点波折的，因为感觉do while语句比较适合这个情况（很难一开始就判断循环条件），然后就是h递增的判断，因为很容易越过临界点，但是经过一定的考虑和修改后顺利地一次过了。<br>
然后还有一些缺陷就是运行时间太长，时间复杂度为o（h*n）<br>
然后看一下官方题解：</p>
<blockquote>
<p>方法一：排序<br>
分析<br>
我们想象一个直方图，其中 xx 轴表示文章，yy 轴表示每篇文章的引用次数。如果将这些文章按照引用次数降序排序并在直方图上进行表示，那么直方图上的最大的正方形的边长 hh 就是我们所要求的 hh。<br>
算法<br>
首先我们将引用次数降序排序，在排完序的数组citations 中，如果icitations[i]&gt;i，那么说明第 0 到 i 篇论文都有至少 i+1 次引用。因此我们只要找到最大的 ii满足citations[i]&gt;i，那么 h 指数即为i+1。<br>
找到最大的 ii的方法有很多，可以对数组进行线性扫描，也可以使用二分查找。由于排序的时间复杂度已经为 O(nlogn)，因此无论是线性扫描O(n) 还是二分查找O(logn)，都不会改变算法的总复杂度。<br>
复杂度分析<br>
时间复杂度：O(nlogn)，即为排序的时间复杂度。<br>
空间复杂度：O(1)O(1)。大部分语言的内置 sort 函数使用堆排序，它只需要 O(1)O(1) 的额外空间。</p>
</blockquote>
<p>方法一是比较简单暴力的排序，时间复杂度下限O(nlogn)，所以来看一下方法二：</p>
<blockquote>
<p>方法二：计数<br>
分析<br>
基于比较的排序算法存在时间复杂度下界 O(n\log n)O(nlogn)，如果要得到时间复杂度更低的算法，就必须考虑不基于比较的排序。<br>
算法<br>
方法一中，我们通过降序排序得到了 h 指数，然而，所有基于比较的排序算法，例如堆排序，合并排序和快速排序，都存在时间复杂度下界O(nlogn)。要得到时间复杂度更低的算法. 可以考虑最常用的不基于比较的排序，计数排序。<br>
然而，论文的引用次数可能会非常多，这个数值很可能会超过论文的总数 n，因此使用计数排序是非常不合算的（会超出空间限制）。在这道题中，我们可以通过一个不难发现的结论来让计数排序变得有用，即：<br>
如果一篇文章的引用次数超过论文的总数 nn，那么将它的引用次数降低为 n 也不会改变 h 指数的值。<br>
由于 h指数一定小于等于 n，因此这样做是正确的。在直方图中，将所有超过 y 轴值大于 n 的变为n  等价于去掉 y&gt;n 的整个区域。<br>
从直方图中可以更明显地看出结论的正确性，将 y&gt;n 的区域去除，并不会影响到最大的正方形，也就不会影响到 h 指数。<br>
我们用一个例子来说明如何使用计数排序得到 h 指数。首先，引用次数如下所示：<br>
citations=[1,3,2,3,100]<br>
将所有大于 n=5n=5 的引用次数变为 nn，得到：<br>
citations=[1,3,2,3,5]<br>
计数排序得到的结果如下：<br>
k 	     0	1	2	3	4	5<br>
count	0	1	1	2	0	1<br>
sk   	5	5	4	3	1	1<br>
其中 s_k	表示至少有 k 次引用的论文数量，在表中即为在它之后的列（包括本身）的 count 一行的和。根据定义，最大的满足k≤s 的 k 即为所求的 h。在表中，这个 k 为 3，因此 h 指数为 3。</p>
</blockquote>
<pre><code>Java
public class Solution {
    public int hIndex(int[] citations) {
        int n = citations.length;
        int[] papers = new int[n + 1];
        // 计数
        for (int c: citations)
            papers[Math.min(n, c)]++;
        // 找出最大的 k
        int k = n;
        for (int s = papers[n]; k &gt; s; s += papers[k])
            k--;
        return k;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)。在计数时，我们仅需要遍历citations 数组一次，因此时间复杂度为 O(n)。在找出最大的 k 时，我们最多需要遍历计数的数组一次，而计数的数组的长度为O(n)，因此这一步的时间复杂度为O(n)，即总的时间复杂度为 O(n)。<br>
空间复杂度：O(n)。我们需要使用 O(n) 的空间来存放计数的结果。</p>
</blockquote>
<p>方法而是利用空间换取时间，主要是（1）把大于数组范围的值置为和数组一致（2）记录大于某个引用次数的文章数（3）从大到小搜索临界值<br>
最后的代码</p>
<pre><code>class Solution {
public:
    int hIndex(vector&lt;int&gt;&amp; citations) {
        if(!citations.size())
            return 0;
        int len = citations.size();
        vector&lt;int&gt; num(len,0);
        for(auto i:citations)
            if(i)
                if(i&gt;len)
                    ++num[len-1];
                else
                    ++num[i-1];
        for(int i=num.size()-1,sum=0;i&gt;=0;--i){
            sum+=num[i];
            if(i&lt;=sum-1)
                return i+1;
        }
        return 0;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第四章 笔记+习题 4.6-4.11]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-si-zhang-bi-ji-xi-ti-46-411</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-si-zhang-bi-ji-xi-ti-46-411">
        </link>
        <updated>2019-09-09T23:51:59.000Z</updated>
        <content type="html"><![CDATA[<p>4.6<br>
ptr-&gt;mem 等价于(*ptr).mem 注意*的使用<br>
解引用符*的优先级低于点运算符. 所以必须加上括号 （*p）.size（）<br>
箭头运算符作用于一个指针类型的运算对象，结果为<strong>左值</strong>，点运算符分为两种情况，如果成员所属对象为左值，那么结果是左值，反之成员所属对象为右值，结果也为右值</p>
<p>习题4.20<br>
（a）先把指针后移一位然后解引用<br>
（b）先解引用然后把指针指向的值+1 不合法<br>
（c）先对指针调用empty（）再解引用 不合法<br>
（d）解引用指针再调用指向对象的empty（）<br>
（e）先解引用指针再把指针指向的值+1 不合法<br>
（f）解引用指针调用指向对象的empty（），再把指针+1</p>
<p>4.7<br>
条件运算符 cond?:expr1:expr2 其中expr1和expr2需类型相同或可转换为公共类型，cond为真返回expr1 否则返回expr2<br>
当条件运算符的两个表达式都是左值或者能转换成同一左值类型时结果为左值，否则为右值<br>
条件运算符可以嵌套<br>
条件运算符满足右结合律，意味着运算对象一般按照从右向左的顺序组合<br>
A=B? C:D? E:F; // 等同于A=B? C(D? E:F);<br>
条件运算符的优先级非常低 所以要加括号 而且问号应在括号外面 (a&gt;1)?b:c;</p>
<p>习题4.21</p>
<pre><code>int main() {
	vector&lt;int&gt; v{ 1,3,5 };
	for (auto &amp;i : v) 
		i = (i % 2) ? 2 * i : i;
};
</code></pre>
<p>习题4.22</p>
<pre><code>int main() {
	int grade;
	string level;
	level = (grade &lt; 60) ? &quot;fail&quot; : (grade &lt; 75) ? &quot;low pass&quot; : (grade &lt; 90) ? &quot;pass&quot; : &quot;high pass&quot;;
	
	if (grade &lt; 60)
		level = &quot;fail&quot;;
	else if(grade &lt; 75)
		level = &quot;low pass&quot;;
	else if(grade &lt; 90)
		level = &quot;pass&quot;;
	else
		level = &quot;high pass&quot;;
};
</code></pre>
<p>条件运算符比较简洁，但if运算符可读性更高<br>
习题4.23<br>
==符号和+号的优先级大于条件运算符，应对整个条件运算符语句加括号<br>
习题4.24<br>
左结合律就必须修改条件判断的位置，否则会出错</p>
<p>4.8位运算符<br>
位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合<br>
左移操作会改变符号位的值 所以最好将位运算符用于处理无符号类型<br>
移位运算符满足左结合律 （左结合律相当于满足从左到右）</p>
<p>习题4.25<br>
左移6位，变成01011100<br>
习题4.26<br>
能够表示的学生数量变少<br>
习题4.27<br>
（a）等于4（b）等于7（c）等于true（d）等于true</p>
<p>4.9sizeof运算符<br>
sizeof运算符返回所占字节数，满足右结合律，所得的值是size_t类型的<strong>常量表达式</strong>（与数组下标的类型相同）<br>
sizeof运算符返回的是占用空间的大小，而不是对象的值，因此sizeof可以使用空指针<br>
对于数组，sizeof不会把数组名转化为指针来处理；对于vector和string，只返回该类型的固定部分大小，而不会计算元素共占用了多少空间<br>
注意sizeof返回值是一个常量表达式 可以用于声明数组维度</p>
<p>习题4.28</p>
<pre><code>cout&lt;&lt;sizeof(int)&lt;&lt;endl;
cout&lt;&lt;sizeof(char)&lt;&lt;endl;
cout&lt;&lt;sizeof(double)&lt;&lt;endl;
cout&lt;&lt;sizeof(float)&lt;&lt;endl;
....
</code></pre>
<p>习题4.29<br>
第一个是数组元素的个数，第二个未定义，需要看不同机器中指针所占的空间大小和int类型所占大小的比值<br>
习题4.30<br>
（a）sizeof(x)+y（注意此处并非右结合律<br>
（b）sizeof(p-&gt;mem[i])<br>
（c） (sizeof a) &lt; b<br>
（d）无需改变。</p>
<p>4.10 逗号运算符<br>
逗号运算符的优先级是最低的，主要作用是将几个算式并列并<strong>返回最右边的算式的结果</strong><br>
逗号运算符含有两个运算对象，按照从左到右的顺序依次求值，逗号运算符的<strong>真正结果是右侧表达式的值</strong>。<br>
someValue？++x，++y：--x,--y;的结果为(someValue？++x，++y：--x),--y;</p>
<p>习题4.31<br>
前置版本更加方便，更加节省空间。不需要作改动也能生效。<br>
习题4.32<br>
对数组ia进行循环<br>
习题4.33<br>
对somevalue进行判断，然后执行相应操作，最后才进行y的前置递减，等同于someValue？++x，++y：--x,--y;的结果为(someValue？++x，++y：--x),--y;</p>
<p>4.11类型转换<br>
如果两种对象可以相互转换，就是有关联的。如果两种类型有关联，那么当程序需要其中一种类型的运算对象时可以用另一种关联类型的对象或值来替代<br>
<strong>隐式转换会尽可以避免损失进度</strong> 3+3.1415会把3转化为3.1415的double类型<br>
4.11.1算术转换<br>
注意整型提升（char、short转化为int或long）<br>
如果运算对象中有一个无符号类型且无符号类型不小于带符号类型，则带符号转化为无符号，如果带符号类型对象为负数，则带来负面影响（比如-1转化为256范围的类型会变成255）。否则的话取决于无符号类型的所有值能否存在该带符号类型中</p>
<p>习题4.34<br>
（a）fval转化为bool类型<br>
（b）ival转化为float 然后两者之和转化为double<br>
（c）char转化为int，结果再转化为double<br>
习题4.35<br>
（a）'a'从char整型提升为int 然后int结果再转化为char<br>
（b）int转化为double，然后转化为unsigned（假设ui大于ival），然后转化为float<br>
（c）取决于ui的大小<br>
（d）int转化为float，float转化为double</p>
<p>4.11.2其他隐式类型转换<br>
数组名在以下情况不会转换成指针：1.decltype 2.取地址符&amp; 3.sizeof 4.typeid 5.用一个引用来初始化数组（此处貌似有误，应该是定义数组的引用(&amp;a)[10]<br>
4.11.3显式转换<br>
显式转换本质上非常危险<br>
强制类型转换 cast-name<type>(expression);注意不要漏掉express的括号<br>
cast-name指定执行哪种变换<br>
static_cast 只要不包含底层const都能用 例如把void<em>指针的值找回来<br>
double slope = static_cast<double>(j) /i; //强制类型转换进行浮点数除法<br>
void <em>p = &amp;d; double <em>dp = static_cast&lt;double</em>&gt;(p); //把void</em>指针的值找回来<br>
const_cast 只能改变运算对象底层的const 比如把const char</em>变为char* 而不能变成string<br>
reinterpret_cast 尽量不要使用<br>
函数形式的强制类型转换 type(expr) 	C语言风格的强制类型转换(type) expr</p>
<p>习题4.36<br>
i*=int(d)<br>
习题4.37<br>
（a）void <em>pv = static_cast&lt;void</em>&gt;(const_cast&lt;string*&gt;(ps))<br>
（b）int i = static_cast<int>(*pc)<br>
（c）void <em>pv = static_cast&lt;void</em>&gt;(&amp;d)<br>
（d）char <em>pc = static_cast&lt;char</em>&gt;(&amp;pv)<br>
习题4.38<br>
将j/i的值强制转换为double 如果想保留小数部分，应该对i、j分别进行类型转换</p>
<p>习题感悟<br>
注意sizeof右结合律的意义，并是指sizeof x + y等于sizeof（x+y），而是指一个式子中出现多个sizeof时如何定义运算顺序，参考条件运算符？：<br>
someValue？++x，++y：--x,--y;的结果为(someValue？++x，++y：--x),--y;</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 134.加油站]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-134jia-you-zhan</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-134jia-you-zhan">
        </link>
        <updated>2019-09-09T14:50:55.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。<br>
你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。<br>
如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p>
<p>说明: <br>
如果题目有解，该答案即为唯一答案。<br>
输入数组均为非空数组，且长度相同。<br>
输入数组中的元素均为非负数。<br>
示例 1:<br>
输入:<br>
gas  = [1,2,3,4,5]<br>
cost = [3,4,5,1,2]<br>
输出: 3<br>
解释:<br>
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油<br>
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油<br>
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油<br>
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油<br>
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油<br>
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。<br>
因此，3 可为起始索引。<br>
示例 2:</p>
<p>输入:<br>
gas  = [2,3,4]<br>
cost = [3,4,3]<br>
输出: -1<br>
解释:<br>
你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。<br>
我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油<br>
开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油<br>
开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油<br>
你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。<br>
因此，无论怎样，你都不可能绕环路行驶一周。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/gas-station<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>一开始的思路是将两个数组相减得到差值diff，等于负数的地方是不可以作为出发点的，然后将第一个正数作为出发点（因为说只有唯一解），然后以出发点为轴翻转diff（参考之前的数组向右移位k位）然后对diff求和看最后一位是否为0。<br>
代码如下：</p>
<pre><code>class Solution {
public:
    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) {
        vector&lt;int&gt; diff;    
        for(int i = 0;i&lt;gas.size();++i)
            diff.push_back(gas[i]-cost[i]);
        int first = 0;
        for(int i = 1;i&lt;diff.size()+1;++i)
            if(diff[i-1]&gt;0){
                first=i;
                break;
            }
        if(first==0)
            return -1;
        swap_diff(diff,0,diff.size()-1);
        swap_diff(diff,0,first-1);
        swap_diff(diff,first,diff.size()-1);
        for(int i = 1;i&lt;diff.size();++i){
            diff[i]+=diff[i-1];
            if(i!=(diff.size()-1)&amp;&amp;diff[i]&lt;=0)
                return -1;
            }
        if(diff[diff.size()-1]&gt;=0)
            return first-1;
        else
            return -1;
    }
    void swap_diff(vector&lt;int&gt;&amp; diff,int beg,int last){
        for(int i=beg;i&lt;last;++i){
            int temp = diff[i];
            diff[i]=diff[last];
            diff[last]=temp;
            if(--last == i)
                break;
        }
    }
};
</code></pre>
<p>这段代码是很有问题的，diff中的正数可能有多个，只考虑第一个的话，万一是{1，-10，11，...}的情况肯定白给了。如果对diff中的正数进行逐个参考，那么时间复杂度直接变成n^2，得不偿失，所以我的算法是有本质的问题的，所以打算直接看题解，官方题解如下：</p>
<blockquote>
<p>1.如果 sum(gas) &lt; sum(cost) ，那么不可能环行一圈，这种情况下答案是 -1 。<br>
我们可以用这个式子计算环行过程中邮箱里剩下的油：total_tank = sum(gas) - sum(cost) ，如果 total_tank &lt; 0 则返回 -1 。<br>
2.对于加油站 i ，如果 gas[i] - cost[i] &lt; 0 ，则不可能从这个加油站出发，因为在前往 i + 1 的过程中，汽油就不够了。<br>
第二个规则可以被一般化，我们引入变量 curr_tank ，记录当前油箱里剩余的总油量。如果在某一个加油站 curr_tank比 0 小，意味着我们无法到达这个加油站。<br>
下一步我们把这个加油站当做新的起点，并将 curr_tank 重置为 0 ，因为重新出发，油箱中的油为 0 。（从上一次重置的加油站到当前加油站的任意一个加油站出发，到达当前加油站之前， curr_tank 也一定会比 0 小）</p>
<p>整体算法：<br>
那么现在算法是很直接明了的：<br>
初始化 total_tank 和 curr_tank 为 0 ，并且选择 0 号加油站为起点。<br>
遍历所有的加油站：<br>
每一步中，都通过加上 gas[i] 和减去 cost[i] 来更新 total_tank 和 curr_tank 。<br>
如果在 i + 1 号加油站， curr_tank &lt; 0 ，将 i + 1 号加油站作为新的起点，同时重置 curr_tank = 0 ，让油箱也清空。<br>
如果 total_tank &lt; 0 ，返回 -1 ，否则返回 starting station。</p>
</blockquote>
<pre><code>class Solution:
    def canCompleteCircuit(self, gas, cost):
        &quot;&quot;&quot;
        :type gas: List[int]
        :type cost: List[int]
        :rtype: int
        &quot;&quot;&quot;
        n = len(gas)
        
        total_tank, curr_tank = 0, 0
        starting_station = 0
        for i in range(n):
            total_tank += gas[i] - cost[i]
            curr_tank += gas[i] - cost[i]
            # If one couldn't get here,
            if curr_tank &lt; 0:
                # Pick up the next station as the starting one.
                starting_station = i + 1
                # Start with an empty tank.
                curr_tank = 0
        
        return starting_station if total_tank &gt;= 0 else -1
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(N) ， 这是因为只有一个遍历了所有加油站一次的循环。<br>
空间复杂度： O(1) ，因为此算法只使用了常数个变量。</p>
</blockquote>
<p>关于算法原理可以看官方题解和高赞题解的详细解答。<br>
这是最后代码：</p>
<pre><code>class Solution {
public:
    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) {
        int sum=0;
        int curr=0;
        int first=0;
        for(int i=0;i&lt;gas.size();++i){
            sum+=gas[i]-cost[i];
            curr+=gas[i]-cost[i];
            if(curr&lt;0)
            {
                first=i+1;
                curr=0;
            }
        }
        return sum&gt;=0?first:-1;
    }
};
</code></pre>
<p>感想：还是得打好数学基础啊！这题没有理解这个数学概念（如果一个数组的总和非负，那么一定可以找到其中找到一个点开始，累加和一直都是非负的）的话就直接白给了。</p>
]]></content>
    </entry>
</feed>