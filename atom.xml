<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-02-28T03:29:58.025Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>In the darkest night,Rising like a spire.</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[TCP 数据传输的可靠性保证]]></title>
        <id>https://lixin-scut.github.io//post/tcp-shu-ju-chuan-shu-de-ke-kao-xing-bao-zheng</id>
        <link href="https://lixin-scut.github.io//post/tcp-shu-ju-chuan-shu-de-ke-kao-xing-bao-zheng">
        </link>
        <updated>2020-02-28T03:06:28.000Z</updated>
        <content type="html"><![CDATA[<p>TCP如何提供可靠数据传输的？</p>
<p>建立连接（标志位）：通信前确认通信实体存在。</p>
<p>序号机制（序号、确认号）：确保了数据是按序、完整到达。</p>
<p>数据校验（校验和）：CRC校验全部数据。</p>
<p>超时重传（定时器）：保证因链路故障未能到达数据能够被多次重发。</p>
<p>窗口机制（窗口）：提供流量控制，避免过量发送。</p>
<p>拥塞控制：同上。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 题32:从上到下打印二叉树]]></title>
        <id>https://lixin-scut.github.io//post/shu-ti-32cong-shang-dao-xia-da-yin-er-cha-shu</id>
        <link href="https://lixin-scut.github.io//post/shu-ti-32cong-shang-dao-xia-da-yin-er-cha-shu">
        </link>
        <updated>2020-02-27T16:19:50.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题目一">题目一</h3>
<blockquote>
<p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
</blockquote>
<pre><code>/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};
*/
</code></pre>
<p>非常简单，我用的是一个queue，事先记录好本层的节点个数，然后不断循环就好了</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) {
        vector&lt;int&gt; res;
        if(root==NULL)
            return res;
        queue&lt;TreeNode*&gt; Nodequeue;
        Nodequeue.push(root);
        int len;
        TreeNode *cur;
        while((len=Nodequeue.size())&gt;0){
            for(int i=0;i&lt;len;++i){
                cur=Nodequeue.front();
                Nodequeue.pop();
                res.push_back(cur-&gt;val);
                if(cur-&gt;left)
                    Nodequeue.push(cur-&gt;left);
                if(cur-&gt;right)
                    Nodequeue.push(cur-&gt;right);
            }
        }
        return res;
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>从上到下打印二叉树的规律： 每次打印一个节点的时候，如果该节点有子节点，则把该节点的子节点放 到一个队列的末尾。接下来到队列的头部取出最早进入队列的节点，重复前面的打印操作，直至队列中所有的节点都被打印出来。</p>
</blockquote>
<pre><code>void PrintFromTopToBottom(BinaryTreeNode* pRoot)
{
    if(pRoot == nullptr)
        return;

    std::deque&lt;BinaryTreeNode *&gt; dequeTreeNode;

    dequeTreeNode.push_back(pRoot);

    while(dequeTreeNode.size())
    {
        BinaryTreeNode *pNode = dequeTreeNode.front();
        dequeTreeNode.pop_front();

        printf(&quot;%d &quot;, pNode-&gt;m_nValue);

        if(pNode-&gt;m_pLeft)
            dequeTreeNode.push_back(pNode-&gt;m_pLeft);

        if(pNode-&gt;m_pRight)
            dequeTreeNode.push_back(pNode-&gt;m_pRight);
    }
}
</code></pre>
<p>其实队列就很符合要求了，用deque有点牛刀了，不过queue本身也是deque的适配器adapter，所以用queue似乎也没啥问题</p>
<p>拓展：如何广度优先遍历一幅有向图？同样也可以基于队列实现。树是图的 一种特殊退化形式，从上到下按层遍历二叉树，从本质上来说就是广度优先遍历二叉树。</p>
<p>个人思考：需要使用一个辅助的hash set来保存已输出节点</p>
<p>举一反三：<br>
　　不管是广度优先遍历一幅有向图还是一棵树，都要用到队列。首先把起始节点（对树而言是根节点）放入队列接下来每次从队列的头部取出 一个节点，遍历这个节点之后把它能到达的节点（对树而言是子节点）都依次放入队列。重复这个遍历过程，直到队列中的节点全部被遍历为止</p>
<h3 id="题目二">题目二</h3>
<blockquote>
<p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>
</blockquote>
<p>这个记得每次循环开始的时候新建一个空的vector元素就好，比较方便的是我使用了back()这个成员函数，使得不用一直去追踪下标或者end()-1，可读性比较高</p>
<pre><code>class Solution {
public:
vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) {
        vector&lt;vector&lt;int&gt;&gt; res;
        if(pRoot==NULL)
            return res;
        queue&lt;TreeNode*&gt; Nodequeue;
        Nodequeue.push(pRoot);
        int len;
        TreeNode *cur;
        while((len=Nodequeue.size())&gt;0){
            res.push_back(vector&lt;int&gt;());
            for(int i=0;i&lt;len;++i){
                cur=Nodequeue.front();
                Nodequeue.pop();
                res.back().push_back(cur-&gt;val);
                if(cur-&gt;left)
                    Nodequeue.push(cur-&gt;left);
                if(cur-&gt;right)
                    Nodequeue.push(cur-&gt;right);
            }
        }
        return res;
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>这道面试题和前面的面试题类似，也可以用一个队列来保存将要打印的节点。为了把二叉树的每一行单独打印到一行里，我们需要两个变量： 一个变量表示在当前层中还没有打印的节点数：另一个变量表示下一层节点的数目。</p>
</blockquote>
<pre><code>void Print(BinaryTreeNode* pRoot)
{
    if(pRoot == nullptr)
        return;

    std::queue&lt;BinaryTreeNode*&gt; nodes;
    nodes.push(pRoot);
    int nextLevel = 0;
    int toBePrinted = 1;
    while(!nodes.empty())
    {
        BinaryTreeNode* pNode = nodes.front();
        printf(&quot;%d &quot;, pNode-&gt;m_nValue);

        if(pNode-&gt;m_pLeft != nullptr)
        {
            nodes.push(pNode-&gt;m_pLeft);
            ++nextLevel;
        }
        if(pNode-&gt;m_pRight != nullptr)
        {
            nodes.push(pNode-&gt;m_pRight);
            ++nextLevel;
        }

        nodes.pop();
        --toBePrinted;
        if(toBePrinted == 0)
        {
            printf(&quot;\n&quot;);
            toBePrinted = nextLevel;
            nextLevel = 0;
        }
    }
}
</code></pre>
<h3 id="题目三">题目三</h3>
<p>题目描述</p>
<blockquote>
<p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
</blockquote>
<p>这道题就是我一直思索的重点hhh就是如何减少重复的代码和操作。<br>
　　但是似乎还没有特别好的办法了，我最后还是选择了deque+bool值条件分支</p>
<pre><code>class Solution {
public:
    vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) {
        vector&lt;vector&lt;int&gt;&gt; res;
        if(pRoot==NULL)
            return res;
        queue&lt;TreeNode*&gt; Nodequeue;
        Nodequeue.push(pRoot);
        int len;
        TreeNode *cur;
        bool ltor=true;
        while((len=Nodequeue.size())&gt;0){
            deque&lt;int&gt; storage;
            if(ltor){
                for(int i=0;i&lt;len;++i){
                    cur=Nodequeue.front();
                    Nodequeue.pop();
                    storage.push_back(cur-&gt;val);//这里使用back()返回引用,避免了使用临时变量去记住最后一个元素
                    if(cur-&gt;left)
                        Nodequeue.push(cur-&gt;left);
                    if(cur-&gt;right)
                        Nodequeue.push(cur-&gt;right);
                }
            }else{
                for(int i=0;i&lt;len;++i){
                    cur=Nodequeue.front();
                    Nodequeue.pop();
                    storage.push_front(cur-&gt;val);//这里使用back()返回引用,避免了使用临时变量去记住最后一个元素
                    if(cur-&gt;left)
                        Nodequeue.push(cur-&gt;left);
                    if(cur-&gt;right)
                        Nodequeue.push(cur-&gt;right);
                }
            }
            res.push_back(vector&lt;int&gt;(storage.begin(),storage.end()));
            ltor=!ltor;
        }      
        return res;
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>当二叉树的根节点（节点1）打印之后，它的左子节点（节点2）和右 子节点（节点3）先后保存到一个数据容器里。值得注意的是，在打印第1 层的节点时，先打印节点3,再打印节点2。看起来节点在这个数据容器里 是后进先出的，因此这个数据容器可以用栈来实现。<br>
接着打印第二层的两个节点。根据之字形顺序，先打印节点3,再打印 节点2,并把它们的子节点保存到一个数据容器里。我们注意到在打印第三 层的时候，先打印节点2的两个子节点（节点4和节点5）,再打印节点3 的两个子节点（节点6和节点7）。这意味着我们仍然可以用一个栈来保存 节点2和节点3的子节点。<br>
我们还注意到第三层的节点是从左向右打印的，这意味着节点4在节 点节点5之前打印，节点6在节点7之前打印。按照栈的后进先出特点， 应该先把节点7保存到栈里，接着保存节点6,再接下来是节点5和节点4。 也就是说，在打印第二层节点的时候，我们先把右子节点保存到栈里，再 把左子节点保存到栈里。保存子节点的顺序和打印第一层时不一样。<br>
接下来打印第三层的节点。和先前一样，在打印第三层节点的同时， 我们要把第四层的节点保存到一个栈里。由于第四层的打印顺序是从右到 左，因此保存的顺序是先保存左子节点，再保存右子节点。这和保存第一 层根节点的两个子节点的顺序相同。<br>
分析到这里，我们可以总结出规律：按之字形顺序打印二叉树需要两 个栈。我们在打印某一层的节点时，把下一层的子节点保存到相应的栈里。 如果当前打印的是奇数层（第一层、第三层等），则先保存左子节点再保存右子节点到第一个栈里；如果当前打印的是偶数层（第二层、第四层等）， 则先保存右子节点再保存左子节点到第二个栈里。</p>
</blockquote>
<pre><code>void Print(BinaryTreeNode* pRoot)
{
    if(pRoot == nullptr)
        return;

    std::stack&lt;BinaryTreeNode*&gt; levels[2];
    int current = 0;
    int next = 1;

    levels[current].push(pRoot);
    while(!levels[0].empty() || !levels[1].empty())
    {
        BinaryTreeNode* pNode = levels[current].top();
        levels[current].pop();

        printf(&quot;%d &quot;, pNode-&gt;m_nValue);

        if(current == 0)
        {
            if(pNode-&gt;m_pLeft != nullptr)
                levels[next].push(pNode-&gt;m_pLeft);
            if(pNode-&gt;m_pRight != nullptr)
                levels[next].push(pNode-&gt;m_pRight);
        }
        else
        {
            if(pNode-&gt;m_pRight != nullptr)
                levels[next].push(pNode-&gt;m_pRight);
            if(pNode-&gt;m_pLeft != nullptr)
                levels[next].push(pNode-&gt;m_pLeft);
        }

        if(levels[current].empty())
        {
            printf(&quot;\n&quot;);
            current = 1 - current;
            next = 1 - next;
        }
    }
}
</code></pre>
<p>书本的题解是使用01下标法来简化容器的swap，但是还是需要分支条件来保证push的顺序，而且我觉得既然都用了分支了，可以考虑队列和栈配合使用</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[栈 题31:栈的压入、弹出序列]]></title>
        <id>https://lixin-scut.github.io//post/zhan-ti-31zhan-de-ya-ru-dan-chu-xu-lie</id>
        <link href="https://lixin-scut.github.io//post/zhan-ti-31zhan-de-ya-ru-dan-chu-xu-lie">
        </link>
        <updated>2020-02-27T15:56:10.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
</blockquote>
<pre><code>栈的压入、弹出序列
class Solution {
public:
    bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) {
        if(pushV.empty()||popV.empty()||pushV.size()!=popV.size())
            return false;
        stack&lt;int&gt; curV;
        int len=pushV.size();
        int i=0,j=0;
        while(i&lt;len){
            //记得一定要先判断是否为空，否则top会报错
            if(curV.empty()||curV.top()!=popV[i])
                if(j&lt;len)
                    curV.push(pushV[j]),++j;
                else
                    return false;
            else
                curV.pop(),++i;
        }
        return true;
    }
};
</code></pre>
<blockquote>
<p>入栈、出栈的过程：我们可以找到判断一个序列是不是栈的 弹出序列的规律：如果下一个弹出的数字刚好是栈顶数字，那么直接弹出； 如果下一个弹出的数字不在栈顶，则把压栈序列中还没有入栈的数字压入辅助栈，直到把下一个需要弹出的数字压入栈顶为止；如果所有数字都压入栈 后仍然没有找到下一个弹出的数字，那么该序列不可能是一个弹出序列。</p>
</blockquote>
<pre><code>bool IsPopOrder(const int* pPush, const int* pPop, int nLength)
{
    bool bPossible = false;

    if(pPush != nullptr &amp;&amp; pPop != nullptr &amp;&amp; nLength &gt; 0)
    {
        const int* pNextPush = pPush;
        const int* pNextPop = pPop;

        std::stack&lt;int&gt; stackData;

        while(pNextPop - pPop &lt; nLength)
        {
            // 当辅助栈的栈顶元素不是要弹出的元素
            // 先压入一些数字入栈
            while(stackData.empty() || stackData.top() != *pNextPop)
            {
                // 如果所有数字都压入辅助栈了，退出循环
                if(pNextPush - pPush == nLength)
                    break;

                stackData.push(*pNextPush);

                pNextPush ++;
            }

            if(stackData.top() != *pNextPop)
                break;

            stackData.pop();
            pNextPop ++;
        }

        if(stackData.empty() &amp;&amp; pNextPop - pPop == nLength)
            bPossible = true;
    }

    return bPossible;
}

</code></pre>
<p>书本题解的优点在于不会提前返回，一直到最后才返回，可读性高，但是需要的判断条件和结构更复杂，而我的方法就使用了提前返回，结构更加简单</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TCP 与 UDP]]></title>
        <id>https://lixin-scut.github.io//post/tcp-yu-udp</id>
        <link href="https://lixin-scut.github.io//post/tcp-yu-udp">
        </link>
        <updated>2020-02-27T10:02:40.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>TCP面向连接，要先建立连接;UDP是无连接的，即发送数据之前不需要建立连接</li>
<li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，保证无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。<br>
 TCP通过建立连接、序号机制、校验和、超时重传、窗口流量控制、拥塞控制等实现可靠传输。</li>
<li>TCP面向字节流传输，因此可以被分割并在接收端重组；UDP面向数据报传输。</li>
<li>UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</li>
<li>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</li>
<li>TCP对系统资源要求较多，UDP对系统资源要求较少。</li>
<li>若通信数据完整性需让位与通信实时性，则应该选用 TCP 协议（如文件传输、重要状态的更新等）；反之，则使用 UDP 协议（如视频传输、实时通信等）。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TIME_WAIT 状态]]></title>
        <id>https://lixin-scut.github.io//post/time_wait-zhuang-tai</id>
        <link href="https://lixin-scut.github.io//post/time_wait-zhuang-tai">
        </link>
        <updated>2020-02-27T09:19:44.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://lixin-scut.github.io//post-images/1582795214575.png" alt=""><br>
其实一开始我就对这个状态十分疑惑，本来我以为仅仅是为了避免最后一个ACK丢失，但是看完《TCP/IP详解》之后才发现这其中有很多细节</p>
<ol>
<li>
<p>首先调用close()发起主动关闭的一方，在发送最后一个ACK之后会进入time_wait的状态，也就说该发送方会保持2MSL时间之后才会回到初始状态。MSL指的是数据包在网络中的最大生存时间。产生这种结果使得这个TCP连接在2MSL连接等待期间，定义这个连接的四元组（客户端IP地址和端口，服务端IP地址和端口号）不能被使用。</p>
</li>
<li>
<p>为什么存在time_wait<br>
①	TCP协议在关闭连接的四次握手过程中，最终的ACK是由主动关闭连接的一端（后面统称A端）发出的，如果这个ACK丢失，对方（后面统称B端）将重发出最终的FIN，因此A端必须维护状态信息（TIME_WAIT）允许它重发最终的ACK。如果A端不维持TIME_WAIT状态，而是处于CLOSED 状态，那么A端将响应RST分节，B端收到后将此分节解释成一个错误。因而，要实现TCP全双工连接的正常终止，必须处理终止过程中四个分节任何一个分节的丢失情况，主动关闭连接的A端必须维持TIME_WAIT状态 。</p>
</li>
</ol>
<p>为实现TCP全双工连接的可靠释放<br>
由TCP状态变迁图可知，假设发起主动关闭的一方（client）最后发送的ACK在网络中丢失，由于TCP协议的重传机制，执行被动关闭的一方（server）将会重发其FIN，在该FIN到达client之前，client必须维护这条连接状态，也就说这条TCP连接所对应的资源（client方的local_ip,local_port）不能被立即释放或重新分配，直到另一方重发的FIN达到之后，client重发ACK后，经过2MSL时间周期没有再收到另一方的FIN之后，该TCP连接才能恢复初始的CLOSED状态。如果主动关闭一方不维护这样一个TIME_WAIT状态，那么当被动关闭一方重发的FIN到达时，主动关闭一方的TCP传输层会用RST包响应对方，这会被对方认为是有错误发生，然而这事实上只是正常的关闭连接过程，并非异常。</p>
<p>②	TCP segment 可能由于路由器异常而“迷途”，在迷途期间，TCP发送端可能因确认超时而重发这个segment，迷途的segment在路由器修复后也会被送到最终目的地，这个迟到的迷途segment到达时可能会引起问题。在关闭“前一个连接”之后，马上又重新建立起一个相同的IP和端口之间的“新连接”，“前一个连接”的迷途重复分组在“前一个连接”终止后到达，而被“新连接”收到了。为了避免这个情况，TCP协议不允许处于TIME_WAIT状态的连接启动一个新的可用连接，因为TIME_WAIT状态持续2MSL，就可以保证当成功建立一个新TCP连接的时候，来自旧连接重复分组已经在网络中消逝。</p>
<p>为使旧的数据包在网络因过期而消失<br>
为说明这个问题，我们先假设TCP协议中不存在TIME_WAIT状态的限制，再假设当前有一条TCP连接：(local_ip, local_port, remote_ip,remote_port)，因某些原因，我们先关闭，接着很快以相同的四元组建立一条新连接。本文前面介绍过，TCP连接由四元组唯一标识，因此，在我们假设的情况中，TCP协议栈是无法区分前后两条TCP连接的不同的，在它看来，这根本就是同一条连接，中间先释放再建立的过程对其来说是“感知”不到的。这样就可能发生这样的情况：前一条TCP连接由local peer发送的数据到达remote peer后，会被该remot peer的TCP传输层当做当前TCP连接的正常数据接收并向上传递至应用层（而事实上，在我们假设的场景下，这些旧数据到达remote peer前，旧连接已断开且一条由相同四元组构成的新TCP连接已建立，因此，这些旧数据是不应该被向上传递至应用层的），从而引起数据错乱进而导致各种无法预知的诡异现象。作为一种可靠的传输协议，TCP必须在协议层面考虑并避免这种情况的发生，这正是TIME_WAIT状态存在的第2个原因。</p>
<ol start="3">
<li>time_wait状态如何避免<br>
首先服务器可以设置SO_REUSEADDR套接字选项来通知内核，如果端口忙，但TCP连接位于TIME_WAIT状态时可以重用端口。在一个非常有用的场景就是，如果你的服务器程序停止后想立即重启，而新的套接字依旧希望使用同一端口，此时SO_REUSEADDR选项就可以避免TIME_WAIT状态。</li>
</ol>
<p>先总结一下：</p>
<ol>
<li>确保最后一个确认报文段能够到达。如果 B 没收到 A 发送来的确认报文段，那么就会重新发送连接释放请求报文段，A 等待一段时间就是为了处理这种情况的发生。</li>
<li>可能存在“已失效的连接请求报文段”，为了防止这种报文段出现在本次连接之外，需要等待一段时间。防止串话。</li>
</ol>
<p>详细资料以及参考资料<br>
《UNIX网络编程》<br>
<img src="https://lixin-scut.github.io//post-images/1582797482348.png" alt=""></p>
<p>《TCP/IP详解》：<br>
13.5.1	TIME_WAIT 状态<br>
　　TIME_WAIT状态也称为2MSL等待状态。在该状态中，TCP将会等待两倍于最大段生存期（Maximum Segment Lifetime, MSL）的时间，有时也被称作加倍等待。每个实现都必须为最大段生存期选择一个数值。它代表任何报文段在被丢弃前在网络中被允许存在的最长 时间。：</p>
<p>假设已设定MSL的数值，按照规则：当TCP执行一个主动关闭并发送最终的ACK时, 连接必须处于TIME_WAIT状态并持续两倍于最大生存期的时间。这样就能够让TCP重新 发送最终的ACK以避免出现丢失的情况。重新发送最终的ACK并不是因为TCP重传了ACK （它们并不消耗序列号，也不会被TCP重传），而是因为通信另一方重传了它的FIN （它消耗-个序列号）。事实上，TCP总是重传FIN,直到它收到一个最终的ACK。<br>
　　<strong>另一个影响2MSL等待状态的因素是当TCP处于等待状态时，通信双方将该连接（客 户端IP地址、客户端端口号、服务器IP地址、服务器端口号）定义为不可重新使用。</strong> 只有当2MSL等待结束时，或一条新连接使用的初始序列号超过了连接之前的实例所使用的最高 序列号时[RFC1122],或者允许使用时间戳选项来区分之前连接实例的报文段以避免混淆时 [RFC6191],这条连接才能被再次使用。不幸的是，一些实现施加了更加严格的约束。在这 些系统中，如果一个端口号被处于2MSL等待状态的任何通信端所用，那么该端口号将不能 被再次使用。<br>
　　当一个连接处于2MSL等待状态时，任何延迟到达的报文段都将被丢弃。 因为一条连接是通过地址和端口号的4元组定义的。如果该连接处于2MSL等待状态，那么 它在这段时间内将不能被重新使用。当这条正确的连接最终被建立起来后，这条连接之前的 实例所传输的延迟报文段是不能被当作新连接的一部分来解读的。<br>
　　<strong>对于交互式应用程序而言，客户端通常执行主动关闭操作并进入TIME_WAIT状态，服 务器通常执行被动关闭操作并且不会直接进入TIME_WAIT状态。其中的含义是，如果我们 终止一个客户端后立刻重新启动同一客户端，那么新的客户端也不能重新使用相同的本地端 口号。通常来说，这并不成问题。因为客户端通常使用的是由操作系统分配的临时端口号， 而且它们也并不关心被分配的端口号究竟是什么</strong>(回忆一下，实际上出于安全考虑有一种推 荐的随机方法[RFC6056]o值得注意的是，由于一个客户端能够快速产生大量的连接(尤其 是针对同一个服务器)，因此它不得不在临时端口号供应紧张时延迟一会儿来等待其他连接 的终止。<br>
　　<strong>对于服务器而言，情况则大不相同。它们通常使用一些知名的端口。如果我们终止一个 已经建立了一条连接的服务器进程，然后立即尝试重新启动它，服务器不能为该程序的通信 端分配对应的端口号(它将会收到一个“地址已占用”的绑定错误)。这是因为当连接进入 2MSL等待状态时，端口号仍然是连接的一部分。</strong> 根据系统对MSL数值的不同设定，服务 器可能需要花费1 ~ 4分钟才能重新启动。我们可以利用sock程序观察这一场景。在清单 13-3中，我们启动服务器，从客户端连接该服务器，然后终止服务器。</p>
<p>当重新启动服务器时，程序会输出一条错误信息，显示由于地址已经被占用而导致它的 端口号不能被绑定。实际上这也意味着该地址与端口号的组合已经被使用。这是由于前一个 连接处于2MSL的等待状态而造成的。</p>
<p>13.5.3静默时间的概念<br>
在本地与外地的IP地址、端口号都相同的情况下，2MSL状态能够防止新的连接将前一 个连接的延迟报文段解释成自身数据的状况。然而，上述方法只有在与处于2MSL等待状态 的连接相关的主机未关闭的条件下才具有意义。<br>
如果一台与处于TIME_WAIT状态下的连接相关联的主机崩溃，然后在MSL内重新启 动，并且使用与主机崩溃之前处于TIME_WAIT状态的连接相同的IP地址与端口号，那么 将会怎样处理呢？在上述情况下，该连接在主机崩溃之前产生的延迟报文段会被认为属于主 机重启后创建的新连接。这种处理方式将不会考虑在主机重启之后新连接是如何选择初始序 列号的。<br>
为了防止上述情况的发生，［RFC0793］指出在崩溃或者重启后TCP协议应当在创建新 的连接之前等待相当于一个MSL的时间。该段时间被称作静默时间。然而只有极少数实现 遵循了这一点。因为绝大多数的主机在崩溃之后都需要超过一个MSL的时间才能重新启动。 此外，如果上层应用程序自身已采用了校验和或者加密手段，那么此类错误会很容易检测 ［624］出来。</p>
<p>为了方便阅读，再加上图片版<br>
<img src="https://lixin-scut.github.io//post-images/1582796710043.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582796746517.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582796806414.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582796831796.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582796849898.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TCP 连接相关]]></title>
        <id>https://lixin-scut.github.io//post/tcp-lian-jie</id>
        <link href="https://lixin-scut.github.io//post/tcp-lian-jie">
        </link>
        <updated>2020-02-27T08:05:30.000Z</updated>
        <content type="html"><![CDATA[<p>TCP连接的整体图：<br>
<img src="https://lixin-scut.github.io//post-images/1582790915595.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582798546017.png" alt=""></p>
<h3 id="三次握手">三次握手</h3>
<p>三次握手：客户首先发送一个特殊的TCP报文段.服务器用另一个特殊的TCP报文段来响应，最后，客户再用第三个特殊报文段作为响应。前两个报文段不承载“有效载荷”，也就是不包含应用层数据；而第三个报文段可以承载有效载荷。<br>
　　三次握手的目的不仅在于让通信双方了解一个连接正在建立，还在于利用数据包的选项来承载特殊信息，交换初始序列号（ISN）。<br>
步骤：</p>
<ul>
<li>第一次：客户端发含SYN位，SEQ_NUM = S的包到服务器。（客 -&gt; SYN_SEND）</li>
<li>第二次：服务器发含ACK，SYN位且ACK_NUM = S + 1，SEQ_NUM = P的包到客户机。（服 -&gt; SYN_RECV）</li>
<li>第三次：客户机发送含ACK位，ACK_NUM = P + 1的包到服务器。（客 -&gt; ESTABLISH，服 -&gt; ESTABLISH）</li>
</ul>
<p>  第一步：客户端的TCP首先向服务器端的TCP发送一个特殊的TCP报文段,，该报文段中不包含应用层数据。但是在报文段的首部中的一个标志位(即SYN比特）被置为1因此，这个特殊报文段被称为<strong>SYN报文段</strong>，另外客户会随机地选择一个初始序号,并将此编号放置于该起始的TCPSYN报文段的序号字段中。该报文段会被封装在一个IP数据报中，并发送给服务器<br>
　　第二步：一旦包含TCPSYN报文段的IP数据报到达服务器主机,服务器会从该数据报中提取出TCPSYN报文段，为该TCP连接分配TCP缓存和变量，并向该客户TCP发送允许连接的报文段这个允许连接的报文段也不包含应用层数据。但是.在报文段的首部却包含3个重要的信息。首先，SYN比特被置为1。其次，该TCP报文段首部的确认号字段被置为client_isn+1,最后，服务器选择自己的初始序号,并将其放置到TCP报文段首部的序号字段中。该允许连接的报文段有时被称为<strong>SYNACK报文段</strong><br>
　　第三步：在收到SYNACK报文段后，客户也要给该连接分配缓存和变量，客户主机则向服务器发送另外一个报文段；这最后一个报文段<strong>对服务器的允许连接的报文段进行了确认，该SYN比特被置为0</strong>:该三次握手的第三个阶段可以在报文段负载中携带客户到服务器的数据<br>
<img src="https://lixin-scut.github.io//post-images/1582791159940.png" alt=""></p>
<h3 id="四次挥手">四次挥手</h3>
<ul>
<li>第一次：客户机发含FIN位，SEQ = Q的包到服务器。（客 -&gt; FIN_WAIT_1）</li>
<li>第二次：服务器发送含ACK且ACK_NUM = Q + 1的包到服务器。（服 -&gt; CLOSE_WAIT，客 -&gt; FIN_WAIT_2）</li>
<li>此处有等待</li>
<li>第三次：服务器发送含FIN且SEQ_NUM = R的包到客户机。（服 -&gt; LAST_ACK，客 -&gt; TIME_WAIT）</li>
<li>此处有等待</li>
<li>第四次：客户机发送最后一个含有ACK位且ACK_NUM = R + 1的包到客户机。（服 -&gt; CLOSED）</li>
</ul>
<p>1.TCP向服务器进程发送一个特殊的TCP报文段.标志位即<strong>FIN比特被设置为1</strong><br>
2.服务器向发送方回送一个<strong>确认报文段</strong><br>
3.服务器发送它自己的终止报文段，其<strong>FIN比特被置为1</strong><br>
4.最后，该客户对这个服务器的<strong>终止报文段进行确认</strong><br>
要点：在TIME_WAIT状态，假定ACK丢失，服务器将会重发FIN，TIME_WAIT状态使TCP客户重传最后的确认报文<br>
<img src="https://lixin-scut.github.io//post-images/1582791168775.png" alt=""></p>
<h3 id="连接状态总结">连接状态总结</h3>
<p>CLOSED：初始状态。</p>
<p>LISTEN：服务器处于监听状态。</p>
<p>SYN_SEND：客户端socket执行CONNECT连接，发送SYN包，进入此状态。</p>
<p>SYN_RECV：服务端收到SYN包并发送服务端SYN包，进入此状态。</p>
<p>ESTABLISH：表示连接建立。客户端发送了最后一个ACK包后进入此状态，服务端接收到ACK包后进入此状态。</p>
<p>FIN_WAIT_1：终止连接的一方（通常是客户机）发送了FIN报文后进入。等待对方FIN。</p>
<p>CLOSE_WAIT：（假设服务器）接收到客户机FIN包之后等待关闭的阶段。在接收到对方的FIN包之后，自然是需要立即回复ACK包的，表示已经知道断开请求。但是本方是否立即断开连接（发送FIN包）取决于是否还有数据需要发送给客户端，若有，则在发送FIN包之前均为此状态。</p>
<p>FIN_WAIT_2：此时是半连接状态，即有一方要求关闭连接，等待另一方关闭。客户端接收到服务器的ACK包，但并没有立即接收到服务端的FIN包，进入FIN_WAIT_2状态。</p>
<p>LAST_ACK：服务端发动最后的FIN包，等待最后的客户端ACK响应，进入此状态。</p>
<p>TIME_WAIT：客户端收到服务端的FIN包，并立即发出ACK包做最后的确认，在此之后的2MSL时间称为TIME_WAIT状态。</p>
<h3 id="为什么要三次握手两次和四次呢">为什么要三次握手，两次和四次呢？</h3>
<p>网络上这个问题有很多回答，可惜很多回答（的类比）都是错的<br>
正解为：TCP 的可靠连接是靠 seq（ sequence numbers 序列号）来达成的，三次握手是为了保证通信双方数据原点的序列号正确传输，握手只需要确认双方通信时的初始化序号，保证通信不会乱序。</p>
<p>（第三次握手必要性：假设服务端的确认丢失，连接并未断开，客户机超时重发连接请求，这样服务器会对同一个客户机保持多个连接，造成资源浪费。）</p>
<p><strong>详细解释</strong>：</p>
<p>当客户端向服务器端发送一个连接请求时，由于某种原因长时间驻留在网络节点中，无法达到服务器端，由于TCP的超时重传机制，当客户端在特定的时间内没有收到服务器端的确认应答信息，则会重新向服务器端发送连接请求（使用另外一个短款），且该连接请求得到服务器端的响应并正常建立连接，进而传输数据，当数据传输完毕，并释放了此次TCP连接。若此时第一次发送的连接请求报文段延迟了一段时间后，到达了服务器端，本来这是一个早已失效的报文段，但是服务器端收到该连接请求后误以为客户端又发出了一次新的连接请求，于是服务器端向客户端发出确认应答报文段，并同意建立连接。如果没有采用三次握手建立连接，由于服务器端发送了确认应答信息，则表示新的连接已成功建立 <strong>（注意比三次握手缺少了对服务器端的序列号的确认）</strong> ，但是客户端此时并没有向服务器端发出任何连接请求，因此客户端忽略服务器端的确认应答报文，更不会向服务器端传输数据。而服务器端却认为新的连接已经建立了，并在一直等待客户端发送数据，这样服务器端一直处于等待接收数据，直到超出计数器的设定值，则认为服务器端出现异常，并且关闭这个连接。在这个等待的过程中，浪费服务器的资源。如果采用三次握手，客户端就不会向服务器发出确认应答消息，服务器端由于没有收到客户端的确认应答信息，从而判定客户端并没有请求建立连接，从而不建立该连接。</p>
<p>TCP 设计中一个基本设定就是，通过TCP 连接发送的每一个包，都有一个sequence number。而因为每个包都是有序列号的，所以都能被确认收到这些包。确认机制是累计的，所以一个对sequence number X 的确认，意味着 X 序列号之前(不包括 X) 包都是被确认接收到的。</p>
<p>TCP 协议是不限制一个特定的连接（两端 socket 一样）被重复使用的。<br>
所以这样就有一个问题：这条连接突然断开重连后，TCP 怎么样识别之前旧链接重发的包？——这就需要独一无二的 ISN（初始序列号）机制。<br>
当一个新连接建立时，初始序列号（ initial sequence number ISN）生成器会生成一个新的32位的 ISN。</p>
<p>三次握手（A three way handshake）是必须的， 因为 sequence numbers（序列号）没有绑定到整个网络的全局时钟（全部统一使用一个时钟，就可以确定这个包是不是延迟到的）以及 TCPs 可能有不同的机制来选择 ISN（初始序列号）。接收方接收到第一个 SYN 时，没有办法知道这个 SYN 是否延迟了很久了，除非他有办法记住在这条连接中，最后接收到的那个sequence numbers（然而这不总是可行的）。</p>
<p>（假设为两次握手）一个 seq 过来了，跟现在记住的 seq 不一样，我怎么知道他是上条延迟的，还是上上条延迟的呢？所以，接收方一定需要跟发送方确认 SYN。</p>
<p>TCP作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上两方面的需求！</p>
<p>TCP可靠传输的精髓：TCP连接的一方A，由操作系统动态随机选取一个32位长的序列号（Initial Sequence Number），假设A的初始序列号为1000，以该序列号为原点，对自己将要发送的每个字节的数据进行编号，1001，1002，1003…，并把自己的初始序列号ISN告诉B，让B有一个思想准备，什么样编号的数据是合法的，什么编号是非法的，比如编号900就是非法的，同时B还可以对A每一个编号的字节数据进行确认。如果A收到B确认编号为2001，则意味着字节编号为1001-2000，共1000个字节已经安全到达。</p>
<p>同理B也是类似的操作，假设B的初始序列号ISN为2000，以该序列号为原点，对自己将要发送的每个字节的数据进行编号，2001，2002，2003…，并把自己的初始序列号ISN告诉A，以便A可以确认B发送的每一个字节。如果B收到A确认编号为4001，则意味着字节编号为2001-4000，共2000个字节已经安全到达。</p>
<p>四次握手的过程：<br>
1.1 A 发送同步信号SYN + A's Initial sequence number<br>
1.2 B 确认收到A的同步信号，并记录 A's ISN 到本地，命名 B's ACK sequence number<br>
1.3 B发送同步信号SYN + B's Initial sequence number<br>
1.4 A确认收到B的同步信号，并记录 B's ISN 到本地，命名 A's ACK sequence number<br>
很显然1.2和1.3 这两个步骤可以合并，只需要三次握手，可以提高连接的速度与效率。</p>
<p>二次握手的过程：<br>
2.1 A 发送同步信号SYN + A's Initial sequence number<br>
2.2 B发送同步信号SYN + B's Initial sequence number + B's ACK sequence number<br>
这里有一个问题，A与B就A的初始序列号达成了一致，这里是1000。但是B无法知道A是否已经接收到自己的同步信号，如果这个同步信号丢失了，A和B就B的初始序列号将无法达成一致。</p>
<p>于是TCP的设计者将SYN这个同步标志位SYN设计成占用一个字节的编号（FIN标志位也是），既然是一个字节的数据，按照TCP对有数据的TCP segment 必须确认的原则，所以在这里A必须给B一个确认，以确认A已经接收到B的同步信号。<br>
有童鞋会说，如果A发给B的确认丢了，该如何？<br>
A会超时重传这个ACK吗？不会！TCP不会为没有数据的ACK超时重传。<br>
那该如何是好？B如果没有收到A的ACK，会超时重传自己的SYN同步信号，一直到收到A的ACK为止。</p>
<h3 id="为什么需要四次挥手">为什么需要四次挥手</h3>
<p>这里就是涉及一个半关闭问题<br>
（1）第一次挥手     因此当主动方发送断开连接的请求（即FIN报文）给被动方时，仅仅代表主动方不会再发送数据报文了，但主动方仍可以接收数据报文。    （2）第二次挥手     被动方此时有可能还有相应的数据报文需要发送，因此需要先发送ACK报文，告知主动方“我知道你想断开连接的请求了”。这样主动方便不会因为没有收到应答而继续发送断开连接的请求（即FIN报文）。<br>
（3）第三次挥手    被动方在处理完数据报文后，便发送给主动方FIN报文；这样可以保证数据通信正常可靠地完成。发送完FIN报文后，被动方进入LAST_ACK阶段（超时等待）。<br>
（4）第四挥手    如果主动方及时发送ACK报文进行连接中断的确认，这时被动方就直接释放连接，进入可用状态。</p>
<h3 id="syn洪泛攻击">SYN洪泛攻击</h3>
<p>经典的DoS攻击即SYN洪泛攻击：攻击者发送大量的TCPSYN报文段，而不完成第三次握手的步骤，按照三次握手的要求，包含TCPSYN报文段的IP数据报到达服务器主机,服务器会从该数据报中提取出TCPSYN报文段，为该半开的TCP连接分配TCP缓存和变量，最终导致服务器的资源被耗尽<br>
<img src="https://lixin-scut.github.io//post-images/1582798266226.png" alt=""></p>
<h3 id="对应的-函数">对应的 函数</h3>
<p>socket 函数<br>
为了执行网络I/O, 一个进程必须做的第一件事情就是调用socket函数，指定期望的通信协议类型</p>
<p>connect 函数<br>
TCP客户用connect函数来建立与TCP服务器的连接。</p>
<p>bind 函数<br>
bind函数把一个本地协议地址赋予一个套接字，其中协议地址是32位的IPv4地址与16位的TCP或UDP端口号的组合。</p>
<p>listen 函数<br>
listen函数仅由TCP服务器调用，它做两件事情。<br>
(1)	当socket函数创建一个套接字时，它被假设为一个主动套接字，也就是说，它是一个将调用connect发起连接的客户套接字。listen函数把一个未连接的套接字转换成一个被动套接字，指示内核应接受指向该套接字的连接请求。根据TCP状态转换图〈图2-4),调用listen 导致套接字从CLOSED状态转换到LISTEN状态。<br>
(2)	本函数的第二个参数规定了内核应该为相应套接字排队的最大连接个数。</p>
<p>accept 函数<br>
accept函数由TCP服务器调用，用于从已完成连接队列队头返回下一个己完成连接。如果已完成连接队列为空，那么进程被投入睡眠（假定套接字为默认的阻塞方式）。</p>
<p>close 函数<br>
close一个TCP套接字的默认行为是把该套接字标记成己关闭，然后立即返回到调用进程。 该套接字描述符不能再由调用进程使用，也就是说它不能再作为read或write的第一个参数</p>
<p>shutdown函数<br>
终止网络连接的通常方法是调用close函数。不过close有两个限制，却可以使用shutdown 来避免。<br>
（1）	close把描述符的引用计数减1,仅在该计数变为0时才关闭套接字。使用shutdown可以不管引用计数就激发TCP的正常连接终止序列（图2-5中由FIN开始的4个分节）。<br>
（2）	close终止读和写两个方向的数据传送。<br>
shutdown可以指定关闭读端、写端还是读写端</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[STL sort()底层实现]]></title>
        <id>https://lixin-scut.github.io//post/stl-sortdi-ceng-shi-xian</id>
        <link href="https://lixin-scut.github.io//post/stl-sortdi-ceng-shi-xian">
        </link>
        <updated>2020-02-27T04:05:40.000Z</updated>
        <content type="html"><![CDATA[<p>关于STL<br>
对于配置器来说，肯定是二级配置器用得多<br>
对于迭代器来说，肯定是随机迭代器用得多<br>
对于容器来说，肯定是vector用得多<br>
那对于泛型算法来说，就肯定是sort()用得最多了<br>
所以现在来看一下sort()的底层实现</p>
<p>总结部分：<br>
sort涉及到三种排序方法：快速排序、插入排序和堆排序<br>
首先主体排序是快速排序，快速排序是目前已知最快的排序法，平均复杂度为O(NlogN),最坏情况下将达O(N^2)。<br>
但是快速排序对数量比较少的序列还是需要一定数量的递归，所以针对数量比较少的序列或者子序列（STL源码剖析中的源码设置阈值为16），sort改为使用插入排序，因为插入排序在大致有序的短序列中表现更好。<br>
然后就是针对快速排序的最坏情况，STL采用改用Insertion Sort。如果递归层次过深，还会改用Heap Sort，防止深层递归对栈内存造成太大负担</p>
<p>资料参考：<br>
《STL源码剖析》<br>
STL所提供的各式各样算法中，sort是最复杂最庞大的一个。<br>
这个算法接受两个RandomAccessIterotors （随机存取迭代器），然后将区间内的所有元素以 渐增方式由小到大重新排列。第二个版本则允许用户指定一个仿函数（functor）, 作为排序标准。<br>
STL的所有关系型容器（associative containers）都拥有自动排序功能（底层结构采用RB-tree），所以不需要用到这个算法。至于序列式容器（sequence containers）中的 stack、queue 和 priori ty-queue 都有特别的出入口，不允许用户对元素排序。<br>
剩下vector、deque和list,前两者的迭 代器属于RandomAccessIterators,适合使用sort算法，list的迭代器则属于 Bidirectioinaltterators ,不在STL标准之列的slist ,其迭代器更属于 Forwardlterators,都不适合使用sort算法。如果要对list或slist排序，应该使用它们自己提供的member functions sort()</p>
<p>STL的sort算法，数据量大时采用Quicksort，分段递归排序。一旦分段后的数据量小于某个门槛，为避免Quick Sort的递归调用带来过大的额外负荷 (overhead),就改用Insertion Sort。如果递归层次过深，还会改用Heap Sort。</p>
<p>Insertion Sort以双层循环的形式进行。外循环遍历整个序列，每次迭代决定出一个子区间；内循环遍历子区间，将子区间内的每一个“逆转对(inversion) ” 倒转过来。所谓“逆转对”是指任何两个迭代器i,j，而i &gt; j。一旦不存在“逆转对”，序列即排序完毕。这个算法的复杂度为O(N^2),说起来并不理想，但是当数据量很少时，却有不错的效果，原因是实现上有一些技巧(提前结束循环和减少边界判断)，而且不像其它较为复杂的排序算法有着诸如递归调用等操作带来的额外负荷。图6-12是Insertion Sort的详细步骤示意。</p>
<p>Quick Sort<br>
如果我们拿Insertion Sort来处理大量数据，其O(N^2)的复杂度就令人摇头了。 大数据量的情况下有许多更好的排序算法可供选择。正如其名称所昭示，Quick Sort 是目前已知最快的排序法，平均复杂度为O(NlogN),最坏情况下将达O(N^2)。不过 IntroSort (极类似median-of-three Quicksort的一种排序算法)可将最坏情况推 进到O(NlogN)。早期的STL sort 算法都采用Quick Sort, SGI STL已改用 IntroSort<br>
Quick Sort算法可以叙述如下。假设S代表将被处理的序列:</p>
<ol>
<li>如果S的元素个数为0或1,结束。</li>
<li>取S中的任何一个元素，当作枢轴(pivot)</li>
<li>将S分割为L, R两段，使L内的每一个元素都小于或等于v, R内的每一个 元素都大于或等于V。</li>
<li>对L, R递归执行Quicksort。</li>
</ol>
<p>Quick Sort的精神在于将大区间分割为小区间，分段排序。每一个小区间排序完成后，串接起来的大区间也就完成了排序。最坏的情况发生在分割时产生出一个空的子区间，完全没有达到分割的预期效果。。</p>
<p>Median-of-Three （三点中值）<br>
注意，任何一个元素都可以被选来当作枢轴（pivot)，但是其合适与否却会影响QuickSort的效率。为了避免“元素当初输入时不够随机”所带来的恶化效应,<br>
最理想最稳当的方式就是取整个序列的头、尾、中央三个位置的元素，以其中值 （median）作为枢轴。这种做法称为 median-of-three partitioning ,或称为 mediun-of-three-QuickSort为了能够快速取出中央位置的兀素，显然迭代器必须能够随机定位，亦即必须是个RandomAccessIteratorso</p>
<p>Partitioining (分割)<br>
分割方法不只一种,以下叙述既简单又有良好成效的做法。令头端迭代器first 向尾部移动，尾端迭代器 last 向头部移动。<br>
当 *first 大于或等于枢轴时就停下来 ）当*last小于或等于枢轴时也停下来，然后检验两个迭代器是否交错。<br>
如果first仍然在左而last仍然在右，就将两者元素互换，然后各自调整一个位置（向中央逼近），再继续进行相同的行为。<br>
如果发现两个迭代器交错了（亦即!(first &lt; last)）,表示整个序列已经调整完毕，以此时的first为轴，将序列分为左右两半，左半部所有元素值都小于或等于枢轴，右半部所有元素值都大于或等于枢轴。</p>
<p>threshold （阈值）<br>
面对一个只有十来个元素的小型序列，使用像Quick Sort这样复杂而（可能） 需要大量运算的排序法，是否划算？不，不划算，在小数据量的情况下，甚至简单如Insertion Sort者也可能快过Quick Sort	因为Quick Sort会为了极小的子序<br>
列而产生许多的函数递归调用。<br>
鉴于这种情况，适度评估序列的大小,然后决定采用Quick Sort或Insertion Sort, 是值得采纳的一种优化措施。然而究竟多小的序列才应该断然改用Insertion Sort 呢？唔，并无定论，5〜20都可能导致差不多的结果，实际的最佳值因设备而异。</p>
<p>final insertion sort<br>
优化措施永不嫌多，只要我们不是贸然行事（Donald Knuth说过一件名言： 贸然实施优化，是所有恶果的根源，premature optimization is the root of all evil）。 如果我们令某个大小以下的序列滞留在“几近排序但尚未完成”的状态，最后再以一次Insertion Sort将所有这些“几近排序但尚未竟全功”的子序列做一次完整 的排序，其效率一般认为会比“将所有子序列彻底排序”更好。这是因为Insertion Sort在面对“几近排序”的序列时，有很好的表现。</p>
<p>introsort<br>
不当的枢轴选择，导致不当的分割，导致Quick Sort恶化为O(N^2）。David R.<br>
Musser （此君于STL领域大大有名）于1996年提出一种混合式排序算法：<br>
Introspective Sorting （内省式排序）,简称IntroSort,其行为在大部分情况下几 乎与median-of-3 Quick Sort完全相同（当然也就一样快）。但是当分割行为<br>
（partitioning）有恶化为二次行为的倾向时，能够自我侦测，转而改用Heap Sort, 使效率维持在Heap Sort的O(NlogN）,又比一开始就使用Heap Sort来得好。稍后便可看到SGI STL源代码中对IntroSort的实现。<br>
<img src="https://lixin-scut.github.io//post-images/1582788128159.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582788145255.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1582788159528.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++函数参数入栈]]></title>
        <id>https://lixin-scut.github.io//post/chan-shu-can-shu-ru-zhan</id>
        <link href="https://lixin-scut.github.io//post/chan-shu-can-shu-ru-zhan">
        </link>
        <updated>2020-02-27T03:36:52.000Z</updated>
        <content type="html"><![CDATA[<p>参数入栈顺序<br>
c++提供了5种参数传递标准，除了main函数传递必须用_cdecl模式，其他函数可以自己在编译器设置，默认的是_cdecl模式，即从右到左入栈</p>
<p><img src="https://lixin-scut.github.io//post-images/1582774670953.png" alt=""></p>
<p>为什么采用从右到左的参数方式,而不使用从左到右的传参方式呢?<br>
　　主要原因就在于<strong>变长参数</strong><br>
　　一般我们命名一个变长函数时都类似于int display(int i, ...);这种格式,注意参数都是用压栈方式实现的,<br>
　　假如使用从左到右的传参方式：栈顶看到的是最后一个参数,那么怎样知道首参数是哪一个呢?因此要想知道首参数的值,则必须要知道参数的长度.而栈里并不知道这个长度,那么就无法通过指针偏移的方式找到首参数.<br>
　　而如果使用从右到左的传参方式,栈顶看到的就是左边输入的首参数,因此,无论怎样的变长,都可以通过指针偏移的方式找到值.</p>
<p>需要注意的是</p>
<ol>
<li>在将参数入栈前，编译器会先把参数的的表达式都处理掉，哪怕这些运算会改变其中某些参数的值</li>
<li>对于后置++操作，编译器会开辟一个缓冲区来保存当前的值，然后再对参数操作，取值时是从缓冲区取，而不是直接从参数的内存地址里取。</li>
</ol>
<p>例子</p>
<pre><code> int a = 10;
 printf(&quot;%d %d %d %d\n&quot;, a++, ++a, a, a++);
 // 输出为10 12 12 12
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[强制类型转换]]></title>
        <id>https://lixin-scut.github.io//post/qiang-zhi-lei-xing-zhuan-huan</id>
        <link href="https://lixin-scut.github.io//post/qiang-zhi-lei-xing-zhuan-huan">
        </link>
        <updated>2020-02-27T02:27:10.000Z</updated>
        <content type="html"><![CDATA[<p>dynamic_cast：<br>
　　① 转换类型必须是一个指针、引用或者void*，用于将基类的指针或引用安全地转换成派生类的指针或引用；<br>
　　② dynamic_cast在运行期间强制转换，运行时进行类型转换检查；<br>
　　③ 对指针进行转换，失败返回null，成功返回type类型的对象指针，对于引用的转换，失败抛出一个bad_cast ，成功返回type类型的引用；<br>
　　④ dynamic_cast不能用于内置类型的转换；<br>
　　⑤ 用于类的转换，基类中一定要有virtual定义的虚函数（保证多态性），不然会编译错误。<br>
　　dynamic_cast和传统的(type)(expression)强制转换的最大区别在于提供了运行时的类型检查，保证了类型安全，使用强制转换，会跳过编译器的类型检查，但可能会造成运行时异常，导致程序直接崩溃</p>
<p>static_cast：<br>
　　用于非多态类型的转换（静态转换），对应于C中的隐式类型转换，但他不能用于两个不相关类型的转换，不能在没有派生关系的两个类类型之间转换，不能去除掉原有类型的类型修饰符，转换对象时由于没有动态类型检查，所以由基类对象转换成派生类对象的时候存在安全隐患<br>
　　① 用于类层次结构中基类和派生类之间指针或引用的转换，其中——向上转换是安全的，向下转换是不安全的，但两者均可以通过编译，也就是说开发者要负责强转的运行时安全性，这一点，不如dynamic_cast安全；与dynamic_cast作用类似，将expression转换为type类型，区别在于，static发生于编译时，dynamic发生于运行时。<br>
　　② 可以用于内置类型的转换。<br>
　　转换的精度损失一般由开发者负责，但使用了static_cast运算符之后，等于告诉编译器，“我知道这里发生了类型转换，我会为转换的安全性负责，你不用管了”，编译器不会发出编译警告，除非你类型转换完全非法（比如 int a = static_cast(“Hello world!”); ），static_cast才会报编译错误；<br>
　　③ 把void* 转换成目标类型的指针；<br>
　　④ 把任意类型转换成void类型；<br>
　　⑤ static_cast无法转换<code>expression的const/volitale/__unaligned</code>属性（会报编译时错误）。</p>
<p>const_cast：<br>
　　弥补了static_cast无法转换底层const/volitale的不足，将expression的const/volitale属性移除，仅限于底层const属性.<br>
　　① 顶层const：表示指针变量是const的，比如int* const pointer； 底层const： 表示指针所指向的变量是const的，比如const int* pointer;。理解记忆：所谓底层const就是指我这个变量“底子”就是const，。反之，则是顶层const。<br>
　　② 目标类型只能是指针或者引用，const_cast不能执行其他任何类型转换，只能用于同类型之间不同const/ volitale属性的移除。否则会报编译时错误。<br>
　　③ 需要注意的是，const_cast通常对指针和引用进行转换，而无法直接移除内置类型的const/volitale属性，换言之，这种语法直接提供了一个具有写权限的指针或引用，可以通过间接访问的方式，修改常量。</p>
<p>注意：顶层const不需要转换，因为转换后也是用于赋值等用途，顶层const本身<br>
就不影响，所以无需转换。	<br>
reinterpret_cast：<br>
　　reinterpret_cast 允许将任何指针转换为任何其他指针类型。 也允许将任何整数类型转换为任何指针类型以及反向转换。<br>
　　① reinterpret_cast 运算符可用于 char* 到 int* 或 One_class* 到 Unrelated_class* 之类的转换，这本身并不安全，但可以通过编译；<br>
　　② reinterpret_cast 的本质作用是重新定义内存数据的解释方式，而不进行任何二进制转换。</p>
<p>C语言的旧式类型转换不能进行类型的检查和错误检查，转化不明确，尽量不要使用</p>
<p>参考资料<br>
《C++ primer》<br>
4.11.3显式转换<br>
　　显式转换本质上非常危险<br>
　　强制类型转换 <code>cast-name&lt;type&gt;(expression);</code><br>
　　注意不要漏掉express的括号<br>
　　cast-name指定执行哪种变换，可以为static_cast 、dynamic_cast、 const_cast和 reinterpret_cast</p>
<ol>
<li>static_cast<br>
　　只要不包含底层const都能用<br>
　　例如把void*指针的值找回来<br>
<code>double slope = static_cast&lt;double&gt;(j) /i; //强制类型转换进行浮点数除法</code><br>
<code>void *p = &amp;d; double *dp = static_cast&lt;double*&gt;(p); //把void*指针的值找回来</code></li>
<li>const_cast<br>
　　只能改变运算对象底层的const<br>
　　比如把const char*变为char* 而不能变成string</li>
<li>reinterpret_cast 尽量不要使用<br>
　　reinterpret_cast为对象的位模式提供较低层次上的重新解释（对位模式的数据重新进行解释，非常危险）</li>
<li>dynamic_cast运算符<br>
用于将基类的指针或引用安全地转换成派生类的指针或引用。<br>
注意，如果想要从派生的指针或引用转换为类的指针或引用，需要用static_cast，dynamic_cast无法执行这个操作</li>
</ol>
<p>函数形式的强制类型转换 type(expr) 	C语言风格的强制类型转换(type) expr</p>
<p>dynamic_cast运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用。<br>
dynamic_cast运算符<br>
<img src="https://lixin-scut.github.io//post-images/1582771211814.png" alt=""><br>
其中，type必须是一个类类型，并且通常情况下该类型应该含有虚函数。在第一种形式中，e必须是一个有效的指针（参见2.3.2节，第47页）；在第二种形式中，e必须是一个左值；在第三种形式中，e不能是左值。<br>
在上面的所有形式中，e的类型必须符合以下三个条件中的任意一个：<br>
1.e的类型是目标type的公有派生类、<br>
2.e的类型是目标化type的公有基类或者<br>
3.e的类型就是目标type的类型。<br>
如果符合，则类型转换可以成功。否则，转换失败。如果一条dynamic_cast语句的转换目标是指针类型并且失败了，则结果为0。如果转换目标是引用类型并且失败了，则dynamic_cast运算符将抛出一个bad_cast异常。（公有是什么意思）<br>
注意！符合上面三个条件不等于就能转换成功，程序不会报错但是会转换失败</p>
<p>指针类型的dynamic_cast<br>
<img src="https://lixin-scut.github.io//post-images/1582771215858.png" alt=""><br>
我们可以对一个空针执行dynamic_cast,结果是所需类型的空指针。<br>
值得注意的一点是，我们在条件部分定义了dp,这样做的好处是可以在一个操作中同时完成类型转换和条件检查两项任务。而且，指针dp在if语句外部是不可访问的。一旦转换失败，即使后续的代码忘了做相应判断，也不会接触到逐个未绑定的指针，从而确保程序是安全的。（if条件部分定义的变量只能在fi内部使用，外部不可访问！）<br>
在条件部分执行dynamic_cast操作可以确保类型转换和结果检查在同一条表达式中完成。</p>
<p>引用类型的dynamic_cast<br>
引用类型的dynamic_cast与指针类型的dynamic_cast在表示错误发生的方式上略有不同。因为不存在所谓的空引用，所以对于引用类型来说无法使用与指针类型完全相同的错误报告策略。当对引用的类型转换失败时，程序抛出一个名为std::bad_cast的异常，该异常定义在typeinfo标准库头文件中。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[构造函数]]></title>
        <id>https://lixin-scut.github.io//post/gou-zao-han-shu</id>
        <link href="https://lixin-scut.github.io//post/gou-zao-han-shu">
        </link>
        <updated>2020-02-27T01:59:04.000Z</updated>
        <content type="html"><![CDATA[<p>按照参数进行分类</p>
<ol>
<li>无参构造函数（默认构造函数）</li>
<li>有参构造函数</li>
</ol>
<p>按照类型进行分类</p>
<ol>
<li>普通构造函数</li>
<li>拷贝构造函数</li>
</ol>
<p>这两种分类组合起来又可以有多种类型</p>
<p>使用场景和方法</p>
<ol>
<li>直接使用<br>
Base b；</li>
<li>空括号调用<br>
Base b();</li>
<li>带参调用<br>
Base b(anob);</li>
<li>=号调用<br>
Base b = anob;</li>
</ol>
<p>例子：</p>
<pre><code>class TestChild
{
public:
    TestChild()
    {
        x=0;
        y=0;
        printf(&quot;TestChild: Constructor be called!\n&quot;);
    }
    ~TestChild(){}
    TestChild(const TestChild&amp; tc)
    {
        x=tc.x;
        y=tc.y;
        printf(&quot;TestChild: Copy Constructor called!//因为写在了Test(拷贝)构造函数的初始化列表里\n&quot;);
    }
    
    const TestChild&amp; operator=(const TestChild&amp; right)
    {
        x=right.x;
        y=right.y;
        printf(&quot;TestChild: Operator = be called! //因为写在了Test(拷贝)构造函数的函数体里\n&quot;);
        return *this;
    }

    int x,y;
};

class Test
{
public:

    Test(){printf(&quot;Test:      Constructor be called!\n&quot;);}
    explicit Test(const TestChild&amp; tcc)
    {
        tc=tcc;
    }
    ~Test(){}
    Test(const Test&amp; test):tc(test.tc)
    {
        tc=test.tc;
        printf(&quot;Test:      Copy Constructor be called!\n&quot;);
    }

    const Test &amp; operator=(const Test&amp; right)
    {
        tc=right.tc;
        printf(&quot;Test:      Operator= be called!\n&quot;);
        return *this;
    }

    TestChild tc;
};

int main()
{
    printf(&quot;1、Test中包含一个TestChild，这两个类分别具有构造函数、\n   拷贝构造函数、重载operator=。\n\n&quot;);
    printf(&quot;2、在调用Test的构造函数和拷贝构造函数之前，会根据跟在\n   这些函数后的初始化列表去初始化其\n   TestChild变量（调用TestChild的拷贝构造函数去初始化）\n\n&quot;);
    printf(&quot;3、一旦进入Test的构造函数体或拷贝构造函数体，则说明其成员变量TestChild已\n   经通过TestChild的构造函数或TestChild的拷贝构造函数构造出了对象\n&quot;);
    printf(&quot;   所以，在Test的构造函数体或拷贝构造函数体中，再去使用=号\n   给TestChild的时候，调用的就是TestChild的operator=，\n   而不是TestChild的拷贝构造函数了\n&quot;);
    printf(&quot;   这就是Test构造函数后面 “:” 初始化列表的存在意义！（\n   为了调用成员变量的构造函数或者拷贝构造函数）\n\n&quot;);
    printf(&quot;4、最后！揪出让人困惑的原因\n   Test test2=test1和Test test2(test1)这两种是一模一样的\n   （都调用拷贝构造函数）除了这点儿之外，其他地方都是该是什么是什么（\&quot;()\&quot;调用构造函数，\&quot;=\&quot;调用赋值操作符）！！！\n\n&quot;);
    printf(&quot;5、一个对象初始化完毕后，所有对这个对象的赋值都调用operator=\n\n输出如下：&quot;);

    printf(&quot;Test test1; DO:\n&quot;);
    Test test1;
    printf(&quot;\n&quot;);
    printf(&quot;Test test2=test1; DO:\n&quot;);
    Test test2=test1;
    printf(&quot;\n&quot;);
    printf(&quot;Test test3(test2); DO:\n&quot;);
    Test test3(test2);
    printf(&quot;\n&quot;);
    printf(&quot;test3=test1; DO:\n&quot;);
    test3=test1;

     return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>