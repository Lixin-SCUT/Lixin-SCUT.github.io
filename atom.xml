<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-05-06T15:27:10.642Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>千里之行，始于足下。不积跬步，无以至千里。</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[Python基础学习]]></title>
        <id>https://lixin-scut.github.io//post/python-ji-chu-xue-xi</id>
        <link href="https://lixin-scut.github.io//post/python-ji-chu-xue-xi">
        </link>
        <updated>2020-05-06T14:42:32.000Z</updated>
        <content type="html"><![CDATA[<h3 id="python简介">Python简介：</h3>
<p>  C语言是可以用来编写操作系统的贴近硬件的语言，所以，C语言适合开发那些追求运行速度、充分发挥硬件性能的程序。而Python是用来编写应用程序的高级编程语言。</p>
<p>  高级编程语言通常都会提供一个比较完善的基础代码库，让你能直接调用，Python就为我们提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容。用Python开发，许多功能不必从零编写，直接使用现成的即可。</p>
<p><strong>Python适合开发哪些类型的应用：</strong></p>
<ol>
<li>
<p>首选是网络应用，包括网站、后台服务等等；</p>
</li>
<li>
<p>其次是许多日常需要的小工具，包括系统管理员需要的脚本任务等等；</p>
</li>
<li>
<p>另外就是把其他语言开发的程序再包装起来，方便使用。</p>
</li>
</ol>
<h3 id="python的缺点">Python的缺点。</h3>
<p><strong>第一个缺点就是运行速度慢</strong><br>
  和C程序相比非常慢，因为Python是解释型语言，你的代码在执行时会一行一行地翻译成CPU能理解的机器码，这个翻译过程非常耗时，所以很慢。而C程序是运行前直接编译成CPU能执行的机器码，所以非常快。</p>
<p>  但是大量的应用程序不需要这么快的运行速度，因为用户根本感觉不出来。例如开发一个下载MP3的网络应用程序，C程序的运行时间需要0.001秒，而Python程序的运行时间需要0.1秒，慢了100倍，但由于网络更慢，需要等待1秒，由此缩短了速度差别</p>
<p><strong>第二个缺点就是代码不能加密</strong><br>
  如果要发布你的Python程序，实际上就是发布源代码，这一点跟C语言不同，C语言不用发布源代码，只需要把编译后的机器码（也就是你在Windows上常见的xxx.exe文件）发布出去。要从机器码反推出C代码是不可能的，所以，凡是编译型的语言，都没有这个问题，而解释型的语言，则必须把源码发布出去。</p>
<h3 id="安装python-38">安装Python 3.8</h3>
<p>在Mac上安装Python</p>
<p>  如果你正在使用Mac，系统是OS X&gt;=10.9，那么系统自带的Python版本是2.7。要安装最新的Python 3.8，有两个方法：</p>
<p>方法一：从Python官网下载Python 3.8的安装程序，下载后双击运行并安装；</p>
<p>方法二：如果安装了Homebrew，直接通过命令brew install python3安装即可。</p>
<h3 id="运行python">运行Python</h3>
<p>  安装成功后，打开命令提示符窗口，敲入python后，你看到提示符&gt;&gt;&gt;就表示我们已经在Python交互式环境中了，可以输入任何Python代码，回车后会立刻得到执行结果。现在，输入exit()并回车，就可以退出Python交互式环境（直接关掉命令行窗口也可以）。</p>
<h3 id="python解释器">Python解释器</h3>
<p>  当我们编写Python代码时，我们得到的是一个包含Python代码的以.py为扩展名的文本文件。要运行代码，就需要Python解释器去执行.py文件。</p>
<p>  由于整个Python语言从规范到解释器都是开源的，所以理论上，只要水平够高，任何人都可以编写Python解释器来执行Python代码（当然难度很大）。事实上，确实存在多种Python解释器。</p>
<ol>
<li><strong>CPython</strong></li>
</ol>
<p>  当我们从Python官方网站下载并安装好Python 3.x后，我们就直接获得了一个官方版本的解释器：CPython。这个解释器是用<strong>C语言开发</strong>的，所以叫CPython。在命令行下运行python就是启动CPython解释器。</p>
<p>  CPython是使用最广的Python解释器。教程的所有代码也都在CPython下执行。</p>
<ol start="2">
<li>IPython</li>
</ol>
<p>  IPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。好比很多国产浏览器虽然外观不同，但内核其实都是调用了IE。</p>
<p>  CPython用&gt;&gt;&gt;作为提示符，而IPython用In [序号]:作为提示符。</p>
<ol start="3">
<li><strong>PyPy</strong></li>
</ol>
<p>  PyPy是另一个Python解释器，它的目标是执行速度。PyPy采用JIT技术，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。</p>
<p>  绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython有一些是不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。如果你的代码要放到PyPy下执行，就需要了解PyPy和CPython的不同点。</p>
<ol start="4">
<li>Jython</li>
</ol>
<p>  Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。</p>
<ol start="5">
<li>IronPython</li>
</ol>
<p>  IronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。</p>
<ol start="6">
<li>小结</li>
</ol>
<p>  Python的解释器很多，但使用最广泛的还是CPython。如果要和Java或.Net平台交互，最好的办法不是用Jython或IronPython，而是通过网络调用来交互，确保各程序之间的独立性。</p>
<h2 id="python交互模式">Python交互模式</h2>
<p>  在命令行模式下敲命令python，就看到类似如下的一堆文本输出，然后就进入到Python交互模式，它的提示符是&gt;&gt;&gt;。</p>
<p>  在Python交互模式下输入exit()并回车，就退出了Python交互模式，并回到命令行模式</p>
<p>  也可以直接通过开始菜单选择Python (command line)菜单项，直接进入Python交互模式，但是输入exit()后窗口会直接关闭，不会回到命令行模式。</p>
<p>  在交互模式的提示符&gt;&gt;&gt;下，直接输入代码，按回车，就可以立刻得到代码执行结果。现在，试试输入100+200，看看计算结果是不是300：</p>
<pre><code>&gt;&gt;&gt; 100+200
300
</code></pre>
<p>  如果要让Python打印出指定的文字，可以用print()函数，然后把希望打印的文字用单引号或者双引号括起来，但不能混用单引号和双引号：</p>
<pre><code>&gt;&gt;&gt; print('Hallo World!')
Hallo World!
</code></pre>
<p>这种用单引号或者双引号括起来的文本在程序中叫字符串。</p>
<p><strong>命令行模式和Python交互模式</strong></p>
<p>  请注意区分命令行模式和Python交互模式。</p>
<p>  在命令行模式下，可以执行python进入Python交互式环境，也可以执行python hello.py运行一个.py文件。</p>
<p>  此外，在命令行模式运行.py文件和在Python交互式环境下直接运行Python代码有所不同。Python交互式环境会把每一行Python代码的结果自动打印出来，但是，直接运行Python代码却不会。</p>
<p>例如，在Python交互式环境下，输入：</p>
<pre><code>&gt;&gt;&gt; 100 + 200 + 300
600
</code></pre>
<p>直接可以看到结果600。</p>
<p>但是，写一个calc.py的文件，内容如下：</p>
<pre><code>100 + 200 + 300
</code></pre>
<p>然后在命令行模式下执行：</p>
<pre><code>python calc.py
</code></pre>
<p>发现什么输出都没有。</p>
<p>  这是正常的。想要输出结果，必须自己用print()打印出来。</p>
<p>  Python交互模式的代码是输入一行，执行一行，而命令行模式下直接运行.py文件是一次性执行该文件内的所有代码。可见，Python交互模式主要是为了调试Python代码用的，也便于初学者学习，它不是正式运行Python代码的环境！</p>
<h3 id="文本编辑器">文本编辑器</h3>
<p>  请注意，不要用Word和Windows自带的记事本。Word保存的不是纯文本文件，而记事本会自作聪明地在文件开始的地方加上几个特殊字符（UTF-8 BOM），结果会导致程序运行出现莫名其妙的错误。</p>
<p>  文件命名：python文件必须要以.py结尾，其他的都不行。此外，文件名只能是英文字母、数字和下划线的组合。</p>
<h3 id="直接运行py文件">直接运行py文件</h3>
<p>  能不能像.exe文件那样直接运行.py文件呢？在Windows上是不行的，但是，在Mac和Linux上是可以的，方法是在.py文件的第一行加上一个特殊的注释：</p>
<pre><code>#!/usr/bin/env python3

print('hello, world')
</code></pre>
<p>然后，通过命令给hello.py以执行权限：</p>
<pre><code>$ chmod a+x hello.py
</code></pre>
<p>就可以直接运行hello.py了</p>
<h3 id="小结">小结</h3>
<p>  用文本编辑器写Python程序，然后保存为后缀为.py的文件，就可以用Python直接运行这个程序了。</p>
<p>  直接输入python进入交互模式，相当于启动了Python解释器，但是等待你一行一行地输入源代码，每输入一行就执行一行。</p>
<p>  直接运行.py文件相当于启动了Python解释器，然后一次性把.py文件的源代码给执行了，你是没有机会以交互的方式输入源代码的。</p>
<p>  用Python开发程序，完全可以一边在文本编辑器里写代码，一边开一个交互式命令窗口，在写代码的过程中，把部分代码粘到命令行去验证，事半功倍！</p>
<h2 id="输入与输出">输入与输出</h2>
<h3 id="输出">输出</h3>
<p>  用print()在括号中加上字符串，就可以向屏幕上输出指定的文字。比如输出'hello, world'，用代码实现如下：</p>
<pre><code>&gt;&gt;&gt; print('hello, world')
</code></pre>
<p>print()函数也可以接受多个字符串，用逗号“,”隔开，就可以连成一串输出：</p>
<pre><code>&gt;&gt;&gt; print('The quick brown fox', 'jumps over', 'the lazy dog')
The quick brown fox jumps over the lazy dog
</code></pre>
<p>  print()会依次打印每个字符串，<strong>遇到逗号“,”会输出一个空格</strong>，因此，输出的字符串是这样拼起来的</p>
<h3 id="输入">输入</h3>
<p>  如果要让用户从电脑输入一些字符，Python提供了一个input()，可以让用户输入字符串，并存放到一个变量里。比如输入用户的名字：</p>
<pre><code>&gt;&gt;&gt; name = input()
Michael
</code></pre>
<p>  当你输入name = input()并按下回车后，Python交互式命令行就在等待你的输入了。这时，你可以输入任意字符，然后按回车后完成输入。</p>
<p>  输入完成后，不会有任何提示，Python交互式命令行又回到&gt;&gt;&gt;状态了。刚才输入的内容存放到name变量里了。可以直接输入name查看变量内容</p>
<p>  在计算机程序中，变量不仅可以为整数或浮点数，还可以是字符串，因此，name作为一个变量就是一个字符串。</p>
<p>程序运行的时候，input()可以显示一个提示信息</p>
<pre><code>name = input('please enter your name: ')
print('hello,', name)
</code></pre>
<h3 id="小结-2">小结</h3>
<p>  任何计算机程序都是为了执行一个特定的任务，有了输入，用户才能告诉计算机程序所需的信息，有了输出，程序运行后才能告诉用户任务的结果。</p>
<p>  输入是Input，输出是Output，因此，我们把输入输出统称为Input/Output，或者简写为IO。</p>
<p>  input()和print()是在命令行下面最基本的输入和输出，但是，用户也可以通过其他更高级的图形界面完成输入和输出，比如，在网页上的一个文本框输入自己的名字，点击“确定”后在网页上看到输出信息。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[并查集 1202. 交换字符串中的元素[中等]]]></title>
        <id>https://lixin-scut.github.io//post/bing-cha-ji-1202-jiao-huan-zi-fu-chuan-zhong-de-yuan-su-zhong-deng</id>
        <link href="https://lixin-scut.github.io//post/bing-cha-ji-1202-jiao-huan-zi-fu-chuan-zhong-de-yuan-su-zhong-deng">
        </link>
        <updated>2020-05-05T00:16:15.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>给你一个字符串 s，以及该字符串中的一些「索引对」数组 pairs，其中 pairs[i] = [a, b] 表示字符串中的两个索引（编号从 0 开始）。<br>
你可以 任意多次交换 在 pairs 中任意一对索引处的字符。<br>
返回在经过若干次交换后，s 可以变成的按字典序最小的字符串。<br>
示例 1:<br>
输入：s = &quot;dcab&quot;, pairs = [[0,3],[1,2]]<br>
输出：&quot;bacd&quot;<br>
解释：<br>
交换 s[0] 和 s[3], s = &quot;bcad&quot;<br>
交换 s[1] 和 s[2], s = &quot;bacd&quot;<br>
示例 2：<br>
输入：s = &quot;dcab&quot;, pairs = [[0,3],[1,2],[0,2]]<br>
输出：&quot;abcd&quot;<br>
解释：<br>
交换 s[0] 和 s[3], s = &quot;bcad&quot;<br>
交换 s[0] 和 s[2], s = &quot;acbd&quot;<br>
交换 s[1] 和 s[2], s = &quot;abcd&quot;<br>
示例 3：<br>
输入：s = &quot;cba&quot;, pairs = [[0,1],[1,2]]<br>
输出：&quot;abc&quot;<br>
解释：<br>
交换 s[0] 和 s[1], s = &quot;bca&quot;<br>
交换 s[1] 和 s[2], s = &quot;bac&quot;<br>
交换 s[0] 和 s[1], s = &quot;abc&quot;<br>
 提示：<br>
1 &lt;= s.length &lt;= 10^5<br>
0 &lt;= pairs.length &lt;= 10^5<br>
0 &lt;= pairs[i][0], pairs[i][1] &lt; s.length<br>
s 中只含有小写英文字母<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/smallest-string-with-swaps<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>第一想法是把处于一个循环链中的字母全部聚集起来 然后进行排序 再放回<br>
突然觉得有点像并查集hhh<br>
看了标签果然是并查集<br>
因为它很明显地有一个connect或者说union的操作</p>
<p>然后自己尝试实现一个并查集吧<br>
首先就是容器的问题，我选择首先实现一个保存父节点的容器parents<br>
然后根据parents里面的数目来实现一个unions保存相应的字母<br>
然后我们对unions里面的字母进行逆序排序（方便pop_back）<br>
然后利用parents的元素作为下标对unions进行访问</p>
<p>实现中遇到的问题</p>
<ol>
<li>注意可能出现相同的pair或者镜像的pair。。。所以此时必须判断他们的父母结点是否一致，如果一致的话说明已经在同一个集合里面了，不需要在进行重复处理（一开始是为了避免num_union被无意义递减，后面修改了的话问题不大）</li>
<li>最最可惜的就是parents并非连续，导致我没法直接通过合并次数来统计num_unions，比如<code>vector&lt;vector&lt;int&gt;&gt; pairs = {{2,3},{3,2},{0,1},{4,0},{3,2}};</code>，最后一个0、一个2，导致下标溢出，我只能使用最大下标值，感觉用哈希表可能能节省空间，但是考虑到哈希值可能一致，所以未必是最优解</li>
</ol>
<pre><code>class Solution {
public:
    string smallestStringWithSwaps(string s, vector&lt;vector&lt;int&gt;&gt;&amp; pairs) {
        int length = s.size();
        vector&lt;int&gt; parents(length, 0);
        for(int i = 0; i &lt; length; ++i)
        {
            parents[i] = i;
        }
        
        int num_union = length;
        int point1, point2;
        int parent1, parent2;
        for(auto pair : pairs)
        {
            point1 = pair[0];
            point2 = pair[1];
            parent1 = point1;
            parent2 = point2;
            while(parents[parent1] != parent1)
            {
                parent1 = parents[parent1];
            }
            while(parents[parent2] != parent2)
            {
                parent2 = parents[parent2];
            }
            if(parent1 == parent2)
            {
                continue;
            }
            else
            {
                if(parent1 &lt; parent2)
                {
                    parents[parent2] = parent1;
                }
                else
                {
                    parents[parent1] = parent2;
                }
                //--num_union;
            }
            
        }
        
        int parent;
        for(int i = 0; i &lt; length; ++i)
        {
            parent = parents[i];
            while(parent != parents[parent])
            {
                parent = parents[parent];
            }
            parents[i] = parent;
            num_union = num_union &gt; parents[i]+1 ?  num_union : parents[i]+1;
        }
        
        vector&lt;string&gt; unions(num_union,&quot;&quot;);
        for(int i = 0; i &lt; length; ++i)
        {
            unions[parents[i]].push_back(s[i]);
        }
        
        for(int i = 0; i &lt; unions.size(); ++i)
        {
            sort(unions[i].begin(), unions[i].end(),greater&lt;char&gt;());
        }
        
        for(int i = 0; i &lt; length; ++i)
        {
            s[i] = unions[parents[i]].back();
            unions[parents[i]].pop_back();
        }
        
        return s;
    }
};
</code></pre>
<p>网友题解：<br>
解决方法</p>
<blockquote>
<p>并查集<br>
先将能相互交换的元素找到，相当于分几个集合。<br>
遍历s，查看当前元素s[i]隶属于那个集合，将集合中最小的元素取出，添加到返回值中。<br>
举个例子：<br>
s=&quot;dcab&quot; , pairs = [[0,3],[1,2]],现将元素扎堆分类为[3,2,2,3]<br>
/*<br>
第一步：发现d隶属于3，而属于集合3的最小元素是b，所以res=&quot;b&quot;,将b抛出集合<br>
第二部：发现c隶属于2，而属于集合2的最小元素是a，所以res=&quot;ba&quot;,将a抛出集合<br>
第三步：发现a隶属于2，而属于集合2的最小元素是c，所以res=&quot;bac&quot;,将c抛出集合<br>
第四步：发现b隶属于3，而属于集合3的最小元素是d，所以res=&quot;bacd&quot;,将d抛出集合<br>
*/</p>
</blockquote>
<pre><code>class Solution {
public:
    int pre[100001];
    int find(int root){
        int son, tmp;
        son = root;
		//找祖先节点
        while(root != pre[root])
            root = pre[root];
        while(son != root)//路径压缩
        {
            tmp = pre[son];
            pre[son] = root;
            son = tmp;
        }
        return root;
    }
    string smallestStringWithSwaps(string s, vector&lt;vector&lt;int&gt;&gt;&amp; pairs) {
        int size=s.size();
        for(int i=0;i&lt;size;i++)pre[i]=i;
        for(auto item:pairs){
            pre[find(item[0])]=find(item[1]);
        }
        vector&lt;vector&lt;char&gt;&gt;v(size);
		//扎堆分类
        for(int i=0;i&lt;size;i++){
            v[find(i)].push_back(s[i]);
        }
        string res;
		//集合中元素逆序排序
        for(int i=0;i&lt;size;i++){
            sort(v[i].rbegin(),v[i].rend());
        }
		//构造返回值
        for(int i=0;i&lt;size;i++){
            res+=v[pre[i]].back();
            v[pre[i]].pop_back();
        }
        return res;
    }
};
</code></pre>
<p>这个题解也是非常有趣</p>
<ol>
<li>利用一个最高上限的固定数组</li>
<li>他保存的是最大值的父母节点</li>
<li>我们的思想一致，都是希望利用pop_back，但是他使用了逆向迭代器进行逆序排序</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 958. 二叉树的完全性检验[中等]]]></title>
        <id>https://lixin-scut.github.io//post/shu-958-er-cha-shu-de-wan-quan-xing-jian-yan-zhong-deng</id>
        <link href="https://lixin-scut.github.io//post/shu-958-er-cha-shu-de-wan-quan-xing-jian-yan-zhong-deng">
        </link>
        <updated>2020-05-04T12:53:13.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>给定一个二叉树，确定它是否是一个完全二叉树。<br>
百度百科中对完全二叉树的定义如下：<br>
若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。（注：第 h 层可能包含 1~ 2h 个节点。）<br>
示例 1：<br>
输入：[1,2,3,4,5,6]<br>
输出：true<br>
解释：最后一层前的每一层都是满的（即，结点值为 {1} 和 {2,3} 的两层），且最后一层中的所有结点（{4,5,6}）都尽可能地向左。<br>
示例 2：<br>
输入：[1,2,3,4,5,null,7]<br>
输出：false<br>
解释：值为 7 的结点没有尽可能靠向左侧。<br>
提示：<br>
树中将会有 1 到 100 个结点。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>想到两个办法<br>
但是发现突然先序遍历是错误的<br>
所以用迭代的层次遍历<br>
我使用了一个bool值来检测时候遇到了null结点，如果遇到了null节点应该接下来的所有节点都为null，否则返回false<br>
然后判断当前节点是否为空结点。<br>
注意本来层次遍历是需要保留当前层的节点数，但是这里可以直接push不用考虑层数</p>
<pre><code>class Solution {
public:
    bool isCompleteTree(TreeNode* root) {
        queue&lt;TreeNode*&gt; node_queue;
        bool finish = false;
        node_queue.push(root);
        TreeNode* cur_node;
        while(!node_queue.empty())
        {
            cur_node = node_queue.front();
            node_queue.pop();
            if(finish)
            {
                if(cur_node != nullptr)
                {
                    return false;
                }
            }
            else
            {
                if(cur_node != nullptr)
                {
                    node_queue.push(cur_node-&gt;left);
                    node_queue.push(cur_node-&gt;right);
                }
                else
                {
                    finish = true;
                }
            }
        }
        return true;
    }
};
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>思路：<br>
使用层序遍历，这里将根节点的null节点也加入了Queue，等同于遍历了h+1层。<br>
当出现第一个null节点，记录。如果出现null节点后还出现了非Null节点，表示节点不是全部都靠左或1~h-1层未全满，返回false。</p>
</blockquote>
<pre><code>class Solution {
    public boolean isCompleteTree(TreeNode root) {
        if (root == null) return false;
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.add(root);
        boolean occurNull = false;
        while (!queue.isEmpty()) {
            int count = queue.size();
            while (count-- &gt; 0) {
                TreeNode cur = queue.poll();
                //出现第一个null节点，记录。如果出现null节点后还出现了非Null节点，表示节点不是全部都靠左，返回false
                if (cur == null &amp;&amp; !occurNull) {
                    occurNull = true;
                } else if (cur != null &amp;&amp; occurNull) {
                    return false;
                } else if (cur != null &amp;&amp; !occurNull) {
                    queue.add(cur.left);
                    queue.add(cur.right);
                }
            }
        }
        return true;
    }
}
</code></pre>
<p>这个和我想法一致<br>
然后是官方题解，使用序号标记，确实方便很多</p>
<blockquote>
<p>方法 1：广度优先搜索<br>
想法<br>
这个问题可以简化成两个小问题：用 (depth, position) 元组表示每个节点的”位置“；确定如何定义所有节点都是在最左边的。<br>
假如我们在深度为 3 的行有 4 个节点，位置为 0，1，2，3；那么就有 8 个深度为 4 的新节点位置在 0，1，2，3，4，5，6，7；所以我们可以找到规律：对于一个节点，它的左孩子为：(depth, position) -&gt; (depth + 1, position * 2)，右孩子为 (depth, position) -&gt; (depth + 1, position * 2 + 1)。所以，对于深度为 d 的行恰好含有 2^d−1个节点，所有节点都是靠左边排列的当他们的位置编号是 0, 1, ... 且没有间隙。<br>
一个更简单的表示深度和位置的方法是：用 1 表示根节点，对于任意一个节点 v，它的左孩子为 2<em>v 右孩子为 2</em>v + 1。这就是我们用的规则，在这个规则下，一颗二叉树是完全二叉树当且仅当节点编号依次为 1, 2, 3, ... 且没有间隙。<br>
算法<br>
对于根节点，我们定义其编号为 1。然后，对于每个节点 v，我们将其左节点编号为 2 * v，将其右节点编号为 2 * v + 1。<br>
我们可以发现，树中所有节点的编号按照广度优先搜索顺序正好是升序。（也可以使用深度优先搜索，之后对序列排序）。<br>
然后，我们检测编号序列是否为无间隔的 1, 2, 3, …，事实上，我们只需要检查最后一个编号是否正确，因为最后一个编号的值最大。</p>
</blockquote>
<pre><code>class Solution {
    public boolean isCompleteTree(TreeNode root) {
        List&lt;ANode&gt; nodes = new ArrayList();
        nodes.add(new ANode(root, 1));
        int i = 0;
        while (i &lt; nodes.size()) {
            ANode anode = nodes.get(i++);
            if (anode.node != null) {
                nodes.add(new ANode(anode.node.left, anode.code * 2));
                nodes.add(new ANode(anode.node.right, anode.code * 2 + 1));
            }
        }

        return nodes.get(i-1).code == nodes.size();
    }
}

class ANode {  // Annotated Node
    TreeNode node;
    int code;
    ANode(TreeNode node, int code) {
        this.node = node;
        this.code = code;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(N)，其中 N 是树节点个数。<br>
空间复杂度：O(N)。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math 470. 用 Rand7() 实现 Rand10()[中等][未做出]]]></title>
        <id>https://lixin-scut.github.io//post/math-470-yong-rand7-shi-xian-rand10zhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/math-470-yong-rand7-shi-xian-rand10zhong-deng-wei-zuo-chu">
        </link>
        <updated>2020-05-04T12:15:21.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。<br>
不要使用系统的 Math.random() 方法。<br>
示例 1:<br>
输入: 1<br>
输出: [7]<br>
示例 2:<br>
输入: 2<br>
输出: [8,4]<br>
示例 3:<br>
输入: 3<br>
输出: [8,1,10]<br>
提示:<br>
rand7 已定义。<br>
传入参数: n 表示 rand10 的调用次数 <br>
进阶:<br>
rand7()调用次数的 期望值 是多少 ?<br>
你能否尽量少调用 rand7() ?<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/implement-rand10-using-rand7<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>首先很重要的一点是概率均等，亦即从1/7得到1/10</p>
<p>一开始我觉得是和最小公倍数有关，亦即70<br>
我第一个想法是调用10次rand7， 再除以7，但是明显不对<br>
因为这样是有顺序的，比如7的概率很小，必须全部是1，分布不均匀</p>
<p>但是这也给了我思路，只要使得概率凑齐为1/10或者十个概率相等的值即可</p>
<p>然后看了题解才发现是和题目<a href="https://lixin-scut.github.io/post/sui-ji-gai-lu-p-zhuan-hua-wei-deng-gai-lu/">随机概率p转化为等概率</a>的思路是一致的<br>
我们希望生成的每个数的概率都是一致的<br>
然后rand7() * 7也是和Rand2() * 2原理相同</p>
<pre><code>class Solution {
public:
    int rand10() {
        int ans = (rand7() - 1) * 7 + rand7();
        while(ans &gt; 10)
        {
            ans = (rand7() - 1) * 7 + rand7();
        }
        return ans ;
    }
};
</code></pre>
<p>解题思路</p>
<blockquote>
<p>从 rand10() 到 rand7()<br>
如果题目是给你 rand10()，让你生成 1～7 之间的某个数，那非常好办，我们只要不断调用 rand10() 即可，直到得到我们要的数，但是为什么可以呢？你可能会怀疑这个是不是等概率的，我们来计算一下<br>
如果第一次就 rand 到 1～7 之间的数，那就是直接命中了，概率为1/10，如果第二次命中,那么第一次必定没命中，没命中的概率为3/10 ，再乘命中的1/10	，所以第二次命中的概率是<br>
1/10∗3/10<br>
从 rand7() 到 rand10()<br>
现在要从 rand7() 到 rand10()，也要求是等概率的，那只要我们把小的数映射到一个大的数就好办了，那首先想到的办法是乘个两倍试一试，每个 rand7() 它能生成数的范围是 1～7，rand 两次，那么数的范围就变为 2～14，哦，你可能发现没有 1 了，想要再减去个 1 来弥补，rand7() + rand7()− 1，其实这样是错误的做法，因为对于数字 5 这种，你有两种组合方式 (2+3 or 3+2)，而对于 14，你只有一种组合方式(7+7)，它并不是等概率的，那么简单的加减法不能使用，因为它会使得概率不一致，我们的方法是利用乘法，一般思路如下面这样构建：<br>
(rand7()−1)∗7+rand7()<br>
首先 rand7()−1 得到的数的集合为 {0,1,2,3,4,5,6}<br>
再乘 7 后得到的集合 A 为 {0，7，14，21，28，35，42}<br>
后面 rand7() 得到的集合B为 {1,2,3,4,5,6,7}<br>
有人可能会疑惑，你咋不乘 6，乘 5 呢？因为它不是等概率生成，只有乘7 才能使得结果是等概率生成的，啥意思？我们得到的集合 A 和集合 B，利用这两个集合，得到的数的范围是 1～49，每个数它显然是等概率出现的，因为这两个事件是独立事件，如果你不懂什么是独立事件，你试着加加看也能体会一点。<br>
P(AB)=P(A)∗P(B)=1/7 ∗1/7		<br>
那么我们可以写出下面的代码</p>
</blockquote>
<pre><code>class Solution extends SolBase {
    public int rand10() {
        // 首先得到一个数
        int num = (rand7() - 1) * 7 + rand7();
        // 只要它还大于10，那就给我不断生成，因为我只要范围在1-10的，最后直接返回就可以了
        while (num &gt; 10){
            num = (rand7() - 1) * 7 + rand7();
        }
        return num;
    }
}
</code></pre>
<blockquote>
<p>这样的一个问题是，我们的函数会得到 1～49 之间的数，而我们只想得到 1～10 之间的数，这一部分占的比例太少了，简而言之，这样效率太低，太慢，可能要 while 循环很多次，那么解决思路就是舍弃一部分数，舍弃 41～49，因为是独立事件，我们生成的 1～40 之间的数它是等概率的，我们最后完全可以利用 1～40 之间的数来得到 1～10 之间的数。所以，我们的代码可以改成下面这样</p>
</blockquote>
<pre><code>public int rand10() {
    // 首先得到一个数
    int num = (rand7() - 1) * 7 + rand7();
    // 只要它还大于40，那你就给我不断生成吧
    while (num &gt; 40)
        num = (rand7() - 1) * 7 + rand7();
    // 返回结果，+1是为了解决 40%10为0的情况
    return 1 + num % 10;
}
</code></pre>
<blockquote>
<p>再优化<br>
更进一步，这时候我们舍弃了<br>
9 个数，舍弃的还是有点多，效率还是不高，怎么提高效率呢？那就是舍弃的数最好再少一点！因为这样能让 while 循环少转几次，那么对于大于 40 的随机数，别舍弃呀，利用这 9 个数，再利用那个公式操作一下：<br>
(大于40的随机数−40−1)∗7+rand7()<br>
这样我们可以得到1−63 之间的随机数，只要舍弃 3 个即可，那对于这3 个舍弃的，还可以再来一轮：<br>
(大于60的随机数−60−1)∗7+rand7()<br>
这样我们可以得到 1−21 之间的随机数，只要舍弃 1 个即可。</p>
</blockquote>
<pre><code>class Solution extends SolBase {
    public int rand10() {
        while (true){
            int num = (rand7() - 1) * 7 + rand7();
            // 如果在40以内，那就直接返回
            if(num &lt;= 40) return 1 + num % 10;
            // 说明刚才生成的在41-49之间，利用随机数再操作一遍
            num = (num - 40 - 1) * 7 + rand7();
            if(num &lt;= 60) return 1 + num % 10;
            // 说明刚才生成的在61-63之间，利用随机数再操作一遍
            num = (num - 60 - 1) * 7 + rand7();
            if(num &lt;= 20) return 1 + num % 10;
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math 670. 最大交换[中等]]]></title>
        <id>https://lixin-scut.github.io//post/math-670-zui-da-jiao-huan-zhong-deng</id>
        <link href="https://lixin-scut.github.io//post/math-670-zui-da-jiao-huan-zhong-deng">
        </link>
        <updated>2020-05-04T02:09:32.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值。<br>
示例 1 :<br>
输入: 2736<br>
输出: 7236<br>
解释: 交换数字2和数字7。<br>
示例 2 :<br>
输入: 9973<br>
输出: 9973<br>
解释: 不需要交换。<br>
注意:<br>
给定数字的范围是 [0, 10^8]<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/maximum-swap<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>第一想法是 首先找出最大的数字<br>
如果在第一位，从第二位继续<br>
如果不在第一个位，就和第一位替换</p>
<p>然后考虑到多个最大数字的情况，就把最后一个和第一位更换就好</p>
<p>实现中需要注意的问题</p>
<ol>
<li>每次循环都需要更新max和index，我直接初始化为-1</li>
<li>由于必定大于-1 所以判断条件不用担心max等于-1</li>
<li>然后需要额外考虑max是否和第一位相同，相同的话作废</li>
<li>时间复杂度有点高，而且我用的是转化为字符串</li>
</ol>
<pre><code>class Solution {
public:
    int maximumSwap(int num) {
        string num_str = to_string(num);
        int length = num_str.size();
        
        for(int i = 0; i &lt; length; ++i)
        {
            int max = -1;
            int index = -1;
            for(int j = i; j &lt; length; ++j)
            {
                if(num_str[j] &gt;= max)
                {
                   max =  num_str[j];
                index = j;
                }
            }
            if(max != num_str[i])
            {
                swap(num_str[i], num_str[index]);
                break;
            }
        }
        return stoi(num_str);
    }
};
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>这题我们的想法肯定是，尽量交换前面的大数位，并且和它交换的数还得是在它后面大于它的最大数<br>
倒序使用数组存储下来每个位置，在它及它以后的最大数的索引<br>
然后再正序从一个数开始遍历，如果它及它以后的最大数不是它本身，那么这个数就是我们需要交换的。</p>
</blockquote>
<pre><code>class Solution {
    public int maximumSwap(int num) {
        char[] c = String.valueOf(num).toCharArray();
        int max = Integer.MIN_VALUE;
        int max_index = 0;
        int [] arr = new int[c.length];
        arr[c.length - 1] = c.length - 1;
        
        for (int i = c.length - 1; i &gt;= 0; i --) {
            if (c[i] - '0' &gt; max) {
                max = c[i] - '0';
                max_index = i;
            }
            arr[i] = max_index;
        }
        for (int i = 0; i &lt; c.length; i ++) {
            if (arr[i] != i &amp;&amp; c[arr[i]] != c[i]) {
                char tmp = c[i];
                c[i] = c[arr[i]];
                c[arr[i]] = tmp;
                break;
            }
        }
        return Integer.parseInt(new String(c));
        
    }
}
</code></pre>
<blockquote>
<p>时间复杂度：O(n)<br>
空间复杂度：O(n)</p>
</blockquote>
<p>官方解法：</p>
<blockquote>
<p>方法一：暴力法<br>
数字最多只有 8 位，因此只有 28 个可用的互换。<br>
算法：<br>
我们将数字存储为长度为 len(num) 的列表。对于位置为 (i, j) 的每个候选交换，我们交换数字并记录组成的新数字是否大于当前答案，然后交换回来恢复原始数字。<br>
唯一的细节可能是检查我们没有引入前导零。我们实际上不需要检查它，因为我们的原始数据没有。<br>
复杂度分析<br>
时间复杂度：O(N^3)。其中 N 是输入数字的总位数。对于每对数字，我们最多花费 O(N) 的时间来比较最后的序列。<br>
空间复杂度：O(N)，存储在 A 中的信息。<br>
方法二：贪心算法<br>
算法：<br>
我们将计算 last[d] = i，最后一次出现的数字 d（如果存在）的索引 i。<br>
然后，从左到右扫描数字时，如果将来有较大的数字，我们将用最大的数字交换；如果有多个这样的数字，我们将用最开始遇到的数字交换。<br>
复杂度分析<br>
时间复杂度：O(N)。其中，N 是输入数字的总位数。每个数字最多只考虑一次。<br>
空间复杂度：O(1)，last 使用的额外空间最多只有 10 个。</p>
</blockquote>
<p>注意方法二其实就是前一个方法的固定数组版，并且是从前往后遍历，更加方便一点</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math 440. 字典序的第K小数字[困难][未做出]]]></title>
        <id>https://lixin-scut.github.io//post/math-440-zi-dian-xu-de-di-k-xiao-shu-zi-kun-nan-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/math-440-zi-dian-xu-de-di-k-xiao-shu-zi-kun-nan-wei-zuo-chu">
        </link>
        <updated>2020-05-04T01:55:10.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>给定整数 n 和 k，找到 1 到 n 中字典序第 k 小的数字。<br>
注意：1 ≤ k ≤ n ≤ 10^9。<br>
示例 :<br>
输入:<br>
n: 13   k: 2<br>
输出:<br>
10<br>
解释:<br>
字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题非常明显明显也是找规律的<br>
更像是string的顺序吧，但是肯定不可能列出所有可能性再取值的</p>
<p>很明显是需要找规律的<br>
首先判断n的大小，看看能达到哪个级别<br>
比如个位数有1个，十位数有10个，百位数有100</p>
<p>然后每一层加入相应的级别</p>
<p>突然发现我想得太简单了，比如100时跟在10后面而不是19后面的！以此类推，101、1000等都是跟在100后面的</p>
<p>实在是没啥想法，直接看下题解</p>
<p>核心思想就是十叉树的查找，然后利用前缀和子树的数量之间的对应关系</p>
<p>实现需要注意的点：</p>
<ol>
<li>count()可能会使得int溢出，需要使用long</li>
<li>ans递增的时候可能会超出n， 所以需要和(n + 1)进行判断，+1是因为算上边界</li>
<li>注意判断条件的设置</li>
</ol>
<pre><code>class Solution {
public:
    int findKthNumber(int n, int k) 
    {
        int prefix = 1;
        int locate = 1;
        int num =  0;
        while(locate &lt; k)
        {
            num = count(prefix, n);
            if(num + locate &lt;= k)
            {
                ++prefix;
                locate += num;
            }
            else
            {
                prefix *= 10;
                ++locate;
            }
        }
        return prefix;
    }
    
    int count(int prefix, int n)
    {
        int ans = 0;
        long cur = prefix;
        long next = cur + 1;
        while(cur &lt;= n)
        {
            ans += min(static_cast&lt;long&gt;(n + 1), next) - cur;
            cur *= 10;
            next *= 10;
        }
        return ans;
    }
   
};
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>十叉树每一个节点都拥有 10 个孩子节点，因为作为一个前缀 ，它后面可以接 0~9 这十个数字。而且你可以非常容易地发现，整个字典序排列也就是对十叉树进行先序遍历。1, 10, 100, 101, ... 11, 110 ...<br>
回到题目的意思，我们需要找到排在第k位的数。找到他的排位，需要搞清楚三件事情:<br>
怎么确定一个前缀下所有子节点的个数？<br>
如果第 k 个数在当前的前缀下，怎么继续往下面的子节点找？<br>
如果第 k 个数不在当前的前缀，即当前的前缀比较小，如何扩大前缀，增大寻找的范围？<br>
接下来 ，我们一一拆解这些问题。<br>
理顺思路：<br>
1.确定指定前缀下所有子节点数<br>
现在的任务就是给定一个前缀，返回下面子节点总数。<br>
我们现在的思路就是用下一个前缀的起点减去当前前缀的起点，那么就是当前前缀下的所有子节点数总和啦。</p>
</blockquote>
<pre><code>//prefix是前缀，n是上界
var getCount = (prefix, n) =&gt; {
    let cur = prefix;
    let next = prefix + 1;//下一个前缀
    let count = 0;
    //当前的前缀当然不能大于上界
    while(cur &lt;= n) {
        count += next - cur;//下一个前缀的起点减去当前前缀的起点
        cur *= 10; 
        next *= 10;
        // 如果说刚刚prefix是1，next是2，那么现在分别变成10和20
        // 1为前缀的子节点增加10个，十叉树增加一层, 变成了两层
        
        // 如果说现在prefix是10，next是20，那么现在分别变成100和200，
        // 1为前缀的子节点增加100个，十叉树又增加了一层，变成了三层
    }
    return count;//把当前前缀下的子节点和返回去。
}
</code></pre>
<blockquote>
<p>当然，不知道大家发现一个问题没有，当 next 的值大于上界的时候，那以这个前缀为根节点的十叉树就不是满十叉树了啊，应该到上界那里，后面都不再有子节点。因此，count+=next−cur 还是有些问题的，我们来修正这个问题:</p>
</blockquote>
<pre><code>count += Math.min(n+1, next) - cur;
</code></pre>
<blockquote>
<p>你可能会问:咦？怎么是 n+1 ,而不是 n 呢？不是说好了 n 是上界吗？<br>
我举个例子，假若现在上界n为 12，算出以 1 为前缀的子节点数，首先 1 本身是一个节点，接下来要算下面 10，11，12，一共有 4 个子节点。<br>
那么如果用 Math.min(n,next)−cur 会怎么样？<br>
这时候算出来会少一个，12 - 10 加上根节点，最后只有 3 个。因此我们务必要写 n+1。<br>
现在，我们搞定了前缀的子节点数问题。<br>
2.第k个数在当前前缀下<br>
现在无非就是往子树里面去看。<br>
prefix这样处理就可以了。</p>
</blockquote>
<pre><code>prefix *= 10
</code></pre>
<blockquote>
<p>3.第k个数不在当前前缀下<br>
说白了，当前的前缀小了嘛，我们扩大前缀。</p>
</blockquote>
<pre><code>prefix ++;
</code></pre>
<pre><code>let findKthNumber = function(n, k) {
  let p = 1;//作为一个指针，指向当前所在位置，当p==k时，也就是到了排位第k的数
  let prefix = 1;//前缀
  while(p &lt; k) {
    let count = getNumber(prefix, n);//获得当前前缀下所有子节点的和
    if(p + count &gt; k) { //第k个数在当前前缀下
      prefix *= 10;
      p++; //把指针指向了第一个子节点的位置，比如11乘10后变成110，指针从11指向了110
    } else if(p + count &lt;= k) { //第k个数不在当前前缀下
      prefix ++;
      p += count;//注意这里的操作，把指针指向了下一前缀的起点
    }
  }
  return prefix;
};
</code></pre>
<pre><code>/**
 * @param {number} n
 * @param {number} k
 * @return {number}
 */
var findKthNumber = function(n, k) {
  let getCount = (prefix, n) =&gt; {
    let count =  0;
    for(let cur = prefix, next = prefix + 1; cur &lt;= n; cur *= 10, next *= 10) 
      count += Math.min(next, n+1) - cur;
    return count;
  }
  let p = 1;
  let prefix = 1;
  while(p &lt; k) {
    let count = getCount(prefix, n);
    if(p + count &gt; k) {
      prefix *= 10;
      p++;
    } else if(p + count &lt;= k) {
      prefix ++;
      p += count;
    }
  }
  return prefix;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 209. 长度最小的子数组[中等]]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-209-chang-du-zui-xiao-de-zi-shu-zu-zhong-deng</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-209-chang-du-zui-xiao-de-zi-shu-zu-zhong-deng">
        </link>
        <updated>2020-05-03T13:57:24.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的连续子数组，返回 0。<br>
示例: <br>
输入: s = 7, nums = [2,3,1,2,4,3]<br>
输出: 2<br>
解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。<br>
进阶:<br>
如果你已经完成了O(n) 时间复杂度的解法, 请尝试 O(n log n) 时间复杂度的解法。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/minimum-size-subarray-sum<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>第一想法就是因为是连续子数组，所以可以用双指针</p>
<p>但是实现起来也没那么简单</p>
<ol>
<li>一开始我的想法是先移动指针再判断是否等于s，但是很容易导致边界问题和奇怪的指针移动问题，比如第一个数就满足条件了呢</li>
<li>然后改为sum初始化为nums[0]，判断和s的关系再进行相应的指针移动</li>
<li>当一个数就能大于s的情况最特殊，我选择直接返回</li>
<li>然后递增right可能会到达尾后位置，此时必须判断再加sum，否则会导致段错误</li>
<li>为了方便返回0，我初始化为0，但是也导致了第一次修改ans需要特判</li>
</ol>
<pre><code>class Solution {
public:
    int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) {
        if(nums.size() == 0)
        {
            return 0;
        }
        int left = 0;
        int right = 0;
        int sum = nums[0];
        int ans = 0;
        while(right &lt; nums.size())
        {
            if(sum &gt;= s)
            {
                if(left == right)
                {
                    return 1;
                }
                else
                {
                    if(ans == 0)
                    {
                        ans =  right - left + 1;
                    }
                    else
                    {
                        ans = min(ans , right - left + 1);
                    }
                    sum -= nums[left];
                    ++left;
                }
            }
            else
            {
                ++right;
                if(right &lt; nums.size())
                {
                    sum += nums[right];
                }
            }
            
        }
        return ans;
    }
};
</code></pre>
<p>最后题目的进阶很明显是想用二分法，看看题解是怎么做的</p>
<p>网友题解：</p>
<blockquote>
<p>解法一 暴力破解<br>
从第 0 个数字开始，依次添加数字，记录当总和大于等于 s 时的长度。<br>
从第 1 个数字开始，依次添加数字，记录当总和大于等于 s 时的长度。<br>
从第 2 个数字开始，依次添加数字，记录当总和大于等于 s 时的长度。<br>
...<br>
从最后个数字开始，依次添加数字，记录当总和大于等于 s 时的长度。<br>
从上边得到的长度中选择最小的即可。</p>
</blockquote>
<pre><code>public int minSubArrayLen(int s, int[] nums) {
    int min = Integer.MAX_VALUE;
    int n = nums.length;
    for (int i = 0; i &lt; n; i++) {
        int start = i;
        int sum = 0;
        while (start &lt; n) {
            sum += nums[start];
            start++;
            //当前和大于等于 s 的时候结束
            if (sum &gt;= s) {
                min = Math.min(min, start - i);
                break;
            }
        }
    }
    //min 是否更新，如果没有更新说明数组所有的数字和小于 s, 没有满足条件的解, 返回 0
    return min == Integer.MAX_VALUE ? 0 : min;
}
</code></pre>
<blockquote>
<p>时间复杂度：O(n²)。</p>
</blockquote>
<blockquote>
<p>解法二 双指针<br>
受到 76 题 Minimum Window Substring 的启示，找一个范围使得其值满足某个条件，然后就会想到滑动窗口，也就是用双指针的方法。和这道题本质是一样的。<br>
用双指针 left 和 right 表示一个窗口。<br>
1.right 向右移增大窗口，直到窗口内的数字和大于等于了 s。进行第 2 步。<br>
2.记录此时的长度，left 向右移动，开始减少长度，每减少一次，就更新最小长度。直到当前窗口内的数字和小于了 s，回到第 1 步。</p>
</blockquote>
<pre><code>public int minSubArrayLen(int s, int[] nums) {
    int n = nums.length;
    if (n == 0) {
        return 0;
    }
    int left = 0;
    int right = 0;
    int sum = 0;
    int min = Integer.MAX_VALUE;
    while (right &lt; n) {
        sum += nums[right];
        right++;
        while (sum &gt;= s) {
            min = Math.min(min, right - left);
            sum -= nums[left];
            left++;
        }
    }
    return min == Integer.MAX_VALUE ? 0 : min;
}
</code></pre>
<blockquote>
<p>解法三 二分查找<br>
正常想的话，到解法二按理说已经结束了，但题目里让提出一个 O(nlog(n)) 的解法<br>
看到 log 就会想到二分查找，接着就会想到有序数组，最后，有序数组在哪里呢？<br>
定义一个新的数组，sums[i] ，代表从 0 到 i 的累积和，这样就得到了一个有序数组。<br>
这样做有个好处，那就是通过 sums 数组，如果要求 i 到 j 的所有子数组的和的话，就等于 sums[j] - sums[i - 1]。也就是前 j 个数字的和减去前 i - 1 个数字的和。<br>
然后求解这道题的话，算法和解法一的暴力破解还是一样的，也就是<br>
求出从第 0 个数字开始，总和大于等于 s 时的长度。<br>
求出从第 1 个数字开始，总和大于等于 s 时的长度。<br>
求出从第 2 个数字开始，总和大于等于 s 时的长度。<br>
...<br>
不同之处在于这里求总和时候，可以利用 sums 数组，不再需要累加了。<br>
比如求从第 i 个数字开始，总和大于等于 s 时的长度，我们只需要找从第 i + 1 个数字到第几个数字的和大于等于 s - nums[i] 即可。求 i + 1 到 j 的所有数字的和的话，前边已经说明过了，也就是 sums[j] - sums[i]。</p>
</blockquote>
<pre><code>public int minSubArrayLen(int s, int[] nums) {
    int n = nums.length;
    if (n == 0) {
        return 0;
    }
    int[] sums = new int[n];
    sums[0] = nums[0];
    for (int i = 1; i &lt; n; i++) {
        sums[i] = nums[i] + sums[i - 1];
    }
    int min = Integer.MAX_VALUE;
    for (int i = 0; i &lt; n; i++) {
        int s2 = s - nums[i]; //除去当前数字
        for (int j = i; j &lt; n; j++) {
            //i + 1 到  j 的所有数字和
            if (sums[j] - sums[i] &gt;= s2) {
                min = Math.min(min, j - i + 1);
            }
        }
    }
    return min == Integer.MAX_VALUE ? 0 : min;
}
</code></pre>
<blockquote>
<p>至于二分查找，我们只需要修改内层的 for 循环。对于 sums[j] - sums[i] &gt;= s2，通过移项，也就是 sums[j] &gt;= s2 + sums[i] ，含义就是寻找一个 sums[j]，使得其刚好大于等于 s2 + sums[i]。因为 sums 是个有序数组，所有找 sum[j] 可以采取二分的方法。</p>
</blockquote>
<pre><code>public int minSubArrayLen(int s, int[] nums) {
    int n = nums.length;
    if (n == 0) {
        return 0;
    }
    int[] sums = new int[n];
    sums[0] = nums[0];
    for (int i = 1; i &lt; n; i++) {
        sums[i] = nums[i] + sums[i - 1];
    }
    int min = Integer.MAX_VALUE;
    for (int i = 0; i &lt; n; i++) {
        int s2 = s - nums[i];
        //二分查找，目标值是 s2 + sums[i]
        int k = binarySearch(i, n - 1, sums, s2 + sums[i]);
        if (k != -1) {
            min = Math.min(min, k - i + 1);
        }

    }
    return min == Integer.MAX_VALUE ? 0 : min;
}

//寻求刚好大于 target 的 sums 的下标，也就是大于等于 target 所有 sums 中最小的那个
private int binarySearch(int start, int end, int[] sums, int target) {
    int mid = -1;
    while (start &lt;= end) {
        mid = (start + end) &gt;&gt;&gt; 1;
        if (sums[mid] == target) {
            return mid;
        } else if (sums[mid] &lt; target) {
            start = mid + 1;
        } else {
            end = mid - 1;
        }
    }
    //是否找到，没有找到返回 -1
    return sums[mid] &gt; target ? mid : -1;
}
</code></pre>
<blockquote>
<p>时间复杂度：O(nlog(n))。</p>
</blockquote>
<blockquote>
<p>解法四 二分查找<br>
题目中，我们要寻找连续的数字和大于等于 s 的最小长度。那么，我们可以对这个长度采取二分的方法去寻找吗？<br>
答案是肯定的，原因就是长度为 1 的所有连续数字中最大的和、长度为 2 的所有连续数字中最大的和、长度为 3 的所有连续数字中最大的和 ... 长度为 n 的所有连续数字中最大的和，同样是一个升序数组。<br>
算法的话就是对长度进行二分，寻求满足条件的最小长度。<br>
对于长度为 n 的数组，我们先去判断长度为 n/2 的连续数字中最大的和是否大于等于 s。<br>
1.如果大于等于 s ，那么我们需要减少长度，继续判断所有长度为 n/4 的连续数字<br>
2.如果小于 s，我们需要增加长度，我们继续判断所有长度为 (n/2 + n) / 2，也就是 3n/4 的连续数字。<br>
可以再结合下边的代码看一下。</p>
</blockquote>
<pre><code>public int minSubArrayLen(int s, int[] nums) {
    int n = nums.length;
    if (n == 0) {
        return 0;
    }
    int minLen = 0, maxLen = n;
    int midLen;
    int min = -1;
    while (minLen &lt;= maxLen) {
        //取中间的长度
        midLen = (minLen + maxLen) &gt;&gt;&gt; 1;
        //判断当前长度的最大和是否大于等于 s
        if (getMaxSum(midLen, nums) &gt;= s) {
            maxLen = midLen - 1; //减小长度
            min = midLen; //更新最小值
        } else {
            minLen = midLen + 1; //增大长度
        }
    }
    return min == -1 ? 0 : min;
}

private int getMaxSum(int len, int[] nums) {
    int n = nums.length;
    int sum = 0;
    int maxSum = 0;
    // 达到长度
    for (int i = 0; i &lt; len; i++) {
        sum += nums[i];
    }
    maxSum = sum; // 初始化 maxSum

    for (int i = len; i &lt; n; i++) {
        // 加一个数字减一个数字，保持长度不变
        sum += nums[i];
        sum = sum - nums[i - len];
        // 更新 maxSum
        maxSum = Math.max(maxSum, sum);
    }
    return maxSum;
}
</code></pre>
<blockquote>
<p>时间复杂度：O(nlog(n))。</p>
</blockquote>
<p>两种二分法的思路都特别有趣，前一种是利用sums数组来进行二分，逐个数组查找符合s的长度，其中寻找长度就是利用二分法。后一种是对长度入手，对每个长度进行二分，看看能否符合大于等于s的条件</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 152. 乘积最大子数组[中等][未做出]]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-152-cheng-ji-zui-da-zi-shu-zu-zhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-152-cheng-ji-zui-da-zi-shu-zu-zhong-deng-wei-zuo-chu">
        </link>
        <updated>2020-05-03T13:46:04.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字）。<br>
示例 1:<br>
输入: [2,3,-2,4]<br>
输出: 6<br>
解释: 子数组 [2,3] 有最大乘积 6。<br>
示例 2:<br>
输入: [-2,0,-1]<br>
输出: 0<br>
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/maximum-product-subarray<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>一开始觉得应该使用动态规划<br>
然后就是两个选择，继续当前数字，或者从当前数字重新开始<br>
但是问题就出在状态转移方程，不是很明白选择当前数字的话应该从前一个的哪个状态进行转移，比如当前如果是负数的话，明显前一个是负数的状态更好</p>
<p>第二个想法就是首先遍历得到负数的数量，但是相应地需要处理当前剩余的负数数量和遇到0时的处理方法</p>
<p>最后还是看了题解，主要是依靠维持max值和min值，后者就是专门用来应付负值的</p>
<p>实现需要注意的问题</p>
<ol>
<li>max和min初始化都为1，这点很重要，ans初始化为INT_MIN</li>
<li>遇到负值的时候需要交换max和min</li>
<li>然后注意因为会遇到0或者示例2的情况，所以需要对max和min进行一个判断，避免0影响后面的结果</li>
<li>一直更新ans</li>
</ol>
<pre><code>class Solution {
public:
    int maxProduct(vector&lt;int&gt;&amp; nums) {
        int length = nums.size();
        if(length == 0)
        {   return 0; }
        
        int max = 1;
        int min = 1;
        int ans = INT_MIN;
        for(int i = 0; i &lt; length; ++i)
        {
            if(nums[i] &lt; 0)
            {
                swap(max, min);
            }
            max = max*nums[i] &gt; nums[i] ? max*nums[i] : nums[i];
            min = min*nums[i] &lt; nums[i] ? min*nums[i] : nums[i];
            ans = ans &gt; max ? ans : max; 
        }
        return ans;
    }
};
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>解题方案<br>
思路<br>
标签：动态规划<br>
遍历数组时计算当前最大值，不断更新<br>
令imax为当前最大值，则当前最大值为 imax = max(imax * nums[i], nums[i])<br>
由于存在负数，那么会导致最大的变最小的，最小的变最大的。因此还需要维护当前最小值imin，imin = min(imin * nums[i], nums[i])<br>
当负数出现时则imax与imin进行交换再进行下一步计算<br>
时间复杂度：O(n)<br>
代码</p>
</blockquote>
<pre><code>class Solution {
    public int maxProduct(int[] nums) {
        int max = Integer.MIN_VALUE, imax = 1, imin = 1;
        for(int i=0; i&lt;nums.length; i++){
            if(nums[i] &lt; 0){ 
              int tmp = imax;
              imax = imin;
              imin = tmp;
            }
            imax = Math.max(imax*nums[i], nums[i]);
            imin = Math.min(imin*nums[i], nums[i]);
            
            max = Math.max(max, imax);
        }
        return max;
    }
}
</code></pre>
<p>然后这个的本质其实是动态规划，只是简化了许多<br>
如果以正规的动态规划来考虑的话应该如下：</p>
<blockquote>
<p>解题思路<br>
这题是求数组中子区间的最大乘积，对于乘法，我们需要注意，负数乘以负数，会变成正数，所以解这题的时候我们需要维护两个变量，当前的最大值，以及最小值，最小值可能为负数，但没准下一步乘以一个负数，当前的最大值就变成最小值，而最小值则变成最大值了。<br>
我们的动态方程可能这样：<br>
maxDP[i + 1] = max(maxDP[i] * A[i + 1], A[i + 1],minDP[i] * A[i + 1])<br>
minDP[i + 1] = min(minDP[i] * A[i + 1], A[i + 1],maxDP[i] * A[i + 1])<br>
dp[i + 1] = max(dp[i], maxDP[i + 1])<br>
这里，我们还需要注意元素为0的情况，如果A[i]为0，那么maxDP和minDP都为0，<br>
我们需要从A[i + 1]重新开始。</p>
</blockquote>
<pre><code>class Solution {
public:
    int maxProduct(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        if(n == 0){
            return 0;
        } else if(n == 1) {
            return nums[0];
        }
        int p = nums[0];
        int maxP = nums[0];
        int minP = nums[0];
        for(int i = 1; i &lt; n; i++) {
            int t = maxP;
            maxP = max(max(maxP * nums[i], nums[i]), minP *nums[i]);
            minP = min(min(t * nums[i], nums[i]), minP * nums[i]);
            p = max(maxP, p);
        }
        return p;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[文件系统的实现与磁盘]]></title>
        <id>https://lixin-scut.github.io//post/wen-jian-xi-tong-de-shi-xian-yu-ci-pan</id>
        <link href="https://lixin-scut.github.io//post/wen-jian-xi-tong-de-shi-xian-yu-ci-pan">
        </link>
        <updated>2020-05-02T10:47:40.000Z</updated>
        <content type="html"><![CDATA[<h3 id="文件系统的实现">文件系统的实现</h3>
<p>磁盘的0号扇区：主引导记录（MBR），MBR结尾是分区表。<br>
引导时，BIOS读入并执行MBR，确定活动分区，读取活动分区的第一个块，称引导块，引导块，装载操作系统；</p>
<p>实现<br>
1.连续分配：实现简单、读操作性能好；产生磁盘碎片<br>
2.链表分配：每个块的第一个字指向下一块的指针；随机读取速度慢；<br>
3.内存采用表的链表分配：FAT（文件分配表），每个磁盘的指针字放在内存里，加速随机存储；<br>
4.i节点：对应文件打开时，i节点才存储到内存中；占用内存空间小；</p>
<p>目录实现：文件属性存放在i节点（UNIX），存放在目录里（Windows）</p>
<p>日子结构文件系统LFS：i节点分散存储到整个磁盘中，需要维护；写操作缓冲到内存中，每隔一段时间放到一个独立的段，写到日志末尾；</p>
<p>日志文件系统：ＮＴＦＳ和ext：保持记录文件系统下一步要做什么；</p>
<h3 id="文件系统优化">文件系统优化</h3>
<p><strong>块大小</strong><br>
大块：空间利用率低；<br>
小块：多次寻道和旋转，速度慢；</p>
<h3 id="磁盘结构及管理">磁盘结构及管理</h3>
<p><strong>磁盘结构</strong></p>
<ol>
<li>盘面（Platter）：一个磁盘有多个盘面；</li>
<li>磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；</li>
<li>扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；</li>
<li>磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；</li>
<li>制动手臂（Actuator arm）：用于在磁道之间移动磁头；</li>
<li>主轴（Spindle）：使整个盘面转动。</li>
</ol>
<h3 id="磁盘调度算法">磁盘调度算法</h3>
<p>读写一个磁盘块的时间的影响因素有：</p>
<ol>
<li>
<p>旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）</p>
</li>
<li>
<p>寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）</p>
</li>
<li>
<p>实际的数据传输时间<br>
其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p>
</li>
<li>
<p><strong>先来先服务</strong><br>
FCFS, First Come First Served<br>
按照磁盘请求的顺序进行调度。<br>
优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</p>
</li>
<li>
<p><strong>最短寻道时间优先</strong><br>
SSTF, Shortest Seek Time First<br>
优先调度与当前磁头所在磁道距离最近的磁道。<br>
虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。</p>
</li>
<li>
<p><strong>电梯算法</strong><br>
SCAN<br>
电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。<br>
电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。<br>
因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。</p>
</li>
</ol>
<h3 id="io">I/O</h3>
<p>内存映射、DMA、中断</p>
<p><strong>标准io和文件io的区别</strong></p>
<p>1.定义<br>
　　标准 I/O：具有一定的可移植性。标准I/O库处理很多细节。例如缓存分配，以优化长度执行I/O等。标准的I/O提供了三种类型的缓存。<br>
（1）全缓存：当填满标准I/O缓存后才进行实际的I/O操作。<br>
（2）行缓存：当输入或输出中遇到新行符时，标准I/O库执行I/O操作。<br>
（3）不带缓存：stderr就是了。<br>
　　文件I/O：文件I/O称之为不带缓存的I/O（unbuffered I/O)。不带缓存指的是每个read，write都调用内核中的一个系统调用。也就是一般所说的低级I/O——操作系统提供的基本IO服务，与os绑定，特定于Unix平台。</p>
<p>2.区别<br>
　　首先：两者一个显著的不同点在于，标准I/O默认采用了缓冲机制，比如调用fopen函数，不仅打开一个文件，而且建立了一个缓冲区（读写模式下将建立两个缓冲区），还创建了一个包含文件和缓冲区相关数据的数据结构(FILE *)。低级I/O一般没有采用缓冲，需要自己创建缓冲区，不过其实在linux系统中，都是有使用称为内核缓冲的技术用于提高效率，读写调用是在内核缓冲区和进程缓冲区之间进行的数据复制。使用标准IO就不需要自己维护缓冲区了，标准IO库会根据stdin/stdout来选择缓冲类型，也就是说当你使用标准IO的时候，要清楚它的stdin/stdou是什么类型以及其默认的缓冲模式，如果不合适，你需要用setvbuf先设置，再使用，例如协同进程的标准输入和输出的类型都是管道，所以其默认的缓冲类型是全缓冲的，如果要使用标准IO，就需要现设置行缓冲。对于文件IO，只要你自己能维护好缓冲区，完全可以不用标准IO。<br>
　　其次从名字上来区分，文件I/O主要针对文件操作，读写硬盘等，标准I/O，主要是打印输出到屏幕等。因为他们设备不一样，文件io针对的是文件，标准io是对控制台，操作的是字符流。对于不同设备得特性不一样，必须有不同api访问才最高效。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[new与delete]]></title>
        <id>https://lixin-scut.github.io//post/new-yu-delete</id>
        <link href="https://lixin-scut.github.io//post/new-yu-delete">
        </link>
        <updated>2020-05-02T10:22:13.000Z</updated>
        <content type="html"><![CDATA[<h3 id="c中的运算符new和delete">C++中的运算符new和delete</h3>
<p>  new和delete是C++中的运算符，不是库函数，不需要库的支持，同时，他们是封装好的重载运算符，并且可以再次进行重载。<br>
（1）new是动态分配内存的运算符，自动计算需要分配的空间，在C++中，它属于重载运算符，可以对多种数据类型形式进行分配内存空间，比如int型、char型、结构体型和类等的动态申请的内存分配，分配类的内存空间时，同时调用类的构造函数，对内存空间进行初始化，即完成类的初始化工作。<br>
（2）delete是撤销动态申请的内存运算符。delete与new通常配对使用，与new的功能相反，可以对多种数据类型形式的内存进行撤销，包括类，撤销类的内存空间时，它要调用其析构函数，完成相应的清理工作，收回相应的内存资源。<br>
（3）典型用法</p>
<pre><code>int *p = new int；                         
delete p；  
</code></pre>
<pre><code>char *p = new char；                    
delete p；  
</code></pre>
<pre><code>// 类的类型 *p = new 类的类型；   
delete p；  
</code></pre>
<p>注意，指针p存于栈中，p所指向的内存空间却是在堆中。</p>
<pre><code>Obj * p = new Obj[100];                
delete [ ]p;  
</code></pre>
<p>  注意，new申请数组，delete删除的形式需要加括号“[ ]”，表示对数组空间的操作，总之，申请形式如何，释放的形式就如何</p>
<p>（4）内存说明。new申请的内存也是存于堆中，所以在不需要使用时，需要delete手动收回。</p>
<h3 id="newdelete与mallocfree之间的联系和区别">new/delete与malloc/free之间的联系和区别</h3>
<p><strong>(1) malloc/free和new/delete的联系</strong><br>
  a）存储方式相同。malloc和new动态申请的内存都位于堆中。申请的内存都不能自动被操作系统收回，都需要配套的free和delete来释放。</p>
<p>  b）除了带有构造函数和析构函数的类等数据类型以外，对于一般数据类型，如int、char等等，两组动态申请的方式可以通用，作用效果一样，只是形式不一样。</p>
<p>  c）内存泄漏对于malloc或者new都可以检查出来的，区别在于new可以指明是那个文件的那一行，而malloc没有这些信息。</p>
<p>  d）两组都需要配对使用，malloc配free，new配delete，注意，这不仅仅是习惯问题，如果不配对使用，容易造成内存泄露。同时，在C++中，两组之间不能混着用，虽说有时能编译过，但容易存在较大的隐患。</p>
<p><strong>(2) malloc/free和new/delete的区别</strong><br>
  a）malloc和free返回void类型指针，new和delete直接带具体类型的指针。</p>
<p>  b）malloc和free属于C语言中的函数，需要库的支持，而new/delete是C++中的运算符，况且可以重载，所以new/delete的执行效率高些。C++中为了兼用C语法，所以保留malloc和free的使用，但建议尽量使用new和delete。</p>
<p>  c）在C++中， new是类型安全的，而malloc不是。例如：</p>
<pre><code>int* p = new char[10];                  // 编译时指出错误  
delete [ ]p;                            //对数组需要加中括号“[ ]”  
int* p = malloc(sizeof(char )*10);      // 编译时无法指出错误  
free (p);                               //只需要所释放内存的头指针  
</code></pre>
<p>  d）使用new动态申请类对象的内存空间时，类对象的构建要调用构造函数，相当于对内存空间进行了初始化。而malloc动态申请的类对象的内存空间时，不会初始化，也就是说申请的内存空间无法使用，因为类的初始化是由构造函数完成的。delete和free的意义分别于new和malloc相反。</p>
<p>  e）不能用malloc和free来完成类对象的动态创建和删除。</p>
<h3 id="delete-this-合法吗">delete this 合法吗？</h3>
<p>合法，但：</p>
<ol>
<li>必须保证 <strong>this 对象是通过 new</strong>（不是 new[]、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的</li>
<li>必须保证调用 delete this 的成员函数是最后一个调用 this 的成员函数</li>
<li>必须保证成员函数的 delete this 后面没有调用 this 了</li>
<li>必须保证 delete this 后没有人使用了</li>
</ol>
<h3 id="三种new用法">三种new用法</h3>
<ol>
<li>plain new顾名思义就是普通的new，就是我们惯常使用的new。new失败后抛出标准异常std::bad_alloc而非返回NULL。<br>
string* ps = new string(&quot;abc&quot;);<br>
new handler，没有空间时的处理</li>
</ol>
<pre><code>// function to call if operator new can't allocate enough memory  
void outOfMem()  
{  
    //free memory  
    //or abort  
}  
int main()  
{  
    std::set_new_handler(outOfMem);  
    int *pBigDataArray = new int[100000000L];  
}  
  
void * operator new(std::size_t size) throw(std::bad_alloc)  
{                                        
    while (true) {  
        attempt to allocate size bytes;  
        if (the allocation was successful)  
        return (a pointer to the memory);  
    
        // allocation was unsuccessful; find out what the  
        // current new-handling function is  
        new_handler globalHandler = set_new_handler(0);  
        set_new_handler(globalHandler);  
        if (globalHandler) (*globalHandler)();  
        else throw std::bad_alloc();  
    }  
}  
</code></pre>
<ol start="2">
<li>nothrow new是不抛出异常的运算符new的形式。nothrow new在失败时，返回NULL。</li>
</ol>
<pre><code>char *p=new(nothrow) char[size];
</code></pre>
<ol start="3">
<li>placement new/delete 主要用途是：反复使用一块较大的动态分配成功的内存来构造不同类型的对象或者它们的数组。例如可以先申请一个足够大的字符数组，然后当需要时在它上面构造不同类型的对象或数组。placement new不用担心内存分配失败，因为它根本不分配内存，它只是调用对象的构造函数。</li>
</ol>
<pre><code>int main()  
{  
char *p=new(nothrow) char[sizeof(ADT)+2];  
if(p==NULL)  
  cout&lt;&lt;&quot;failure&quot;&lt;&lt;endl;  
  
ADT *q=new(p) ADT;  //placement new:不必担心失败  
// delete q;//错误!不能在此处调用delete q;  
q-&gt;ADT::~ADT();//显示调用析构函数  
delete []p;  
    return 0;  
}  
</code></pre>
<h3 id="如何定义一个只能在堆上栈上生成对象的类">如何定义一个只能在堆上（栈上）生成对象的类？</h3>
<ol>
<li>只能在堆上<br>
方法：将<strong>析构函数设置为私有</strong></li>
</ol>
<p>  原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。</p>
<pre><code>class  A    
{    
public :    
    A(){}    
    void  destory(){ delete   this ;}    
private :    
    ~A(){}    
};    

class  A    
{    
protected :    
    A(){}    
    ~A(){}    
public :    
    static  A* create()    
    {    
        return   new  A();    
    }    
    void  destory()    
    {    
        delete   this ;    
    }    
};   
</code></pre>
<ol start="2">
<li>只能在栈上</li>
</ol>
<p>方法：将<strong>new 和 delete 重载为私有</strong></p>
<p>  原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。</p>
<pre><code>class  A    
{    
private :    
    void * operator  new ( size_t  t){}      // 注意函数的第一个参数和返回值都是固定的     
    void  operator  delete ( void * ptr){}  // 重载了new就需要重载delete     
public :    
    A(){}    
    ~A(){}    
};   
</code></pre>
]]></content>
    </entry>
</feed>