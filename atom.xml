<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-11-28T02:01:12.215Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[树 109. 有序链表转换二叉搜索树[中等]]]></title>
        <id>https://lixin-ee.github.io//post/shu-109-you-xu-lian-biao-zhuan-huan-er-cha-sou-suo-shu-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/shu-109-you-xu-lian-biao-zhuan-huan-er-cha-sou-suo-shu-zhong-deng">
        </link>
        <updated>2019-11-28T01:38:10.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。<br>
本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。<br>
示例:<br>
给定的有序链表： [-10, -3, 0, 5, 9],<br>
一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：<br>
0<br>
/ <br>
-3   9<br>
/   /<br>
-10  5<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这是错误的代码</p>
<pre><code>class Solution {
public:
    TreeNode* sortedListToBST(ListNode* head) {
        
    }    
    void bulidTree(TreeNode *cur,ListNode *head){
        if(head==NULL)
            return;
        cur-&gt;val=head-&gt;val;
        head=head-&gt;next;
        if(cur-&gt;left==NULL&amp;&amp;cur-&gt;right==NULL){
            TreeNode *parent=new TreeNode(0);
            bulidTree(patent,head);
        }
        if(cur-&gt;left!=NULL)
    }
};
</code></pre>
<p>//偷偷看到了108的题解中有人用中序遍历来构建顺序二叉树，觉得挺靠谱的的，gogogo<br>
//发现中序遍历还是很不熟悉啊 准备看题解了，实在不行就用一般方法中那种疯狂左旋右旋的方法吧hhh<br>
//看了题解。。。发现和前一题差不多呀，强行对链表进行二分法hhh 需要一堆临时变量来存。第二个更绝，直接用数组存链表hhh</p>
<p>最后参考题解的代码如下</p>
<pre><code>class Solution {
public:
    TreeNode* sortedListToBST(ListNode* head) {
        vector&lt;int&gt; nums;
        while(head!=NULL){
            nums.push_back(head-&gt;val);
            head=head-&gt;next;
        }
        if(nums.empty())
            return NULL;
        TreeNode *root=new TreeNode(0);
        genTree(root,0,nums.size()-1,nums);
        return root;

    }
       
    void genTree(TreeNode *cur,int beg,int end,vector&lt;int&gt;&amp; nums){
        if(beg==end){
            cur-&gt;val=nums[beg];
            cur-&gt;left==NULL;
            cur-&gt;right==NULL;
            return;
        }
      int mid=(end-beg+1)/2+beg;
        cur-&gt;val=nums[mid];
        if(mid&gt;beg){
            //TreeNode *left=new TreeNode(0);
            //cur-&gt;left=left;
            cur-&gt;left=new TreeNode(0);
            genTree(cur-&gt;left,beg,mid-1,nums);
        }else
        {
            cur-&gt;left=NULL;
            return;
        }
        
        if(mid&lt;end){
            cur-&gt;right=new TreeNode(0);
            genTree(cur-&gt;right,mid+1,end,nums);
        }else
        {
            cur-&gt;right=NULL;
            return;
        }
        return;  
            }
};
</code></pre>
<p>//本来想用vector(list.begin(),list.end())初始化vector，结果发现list给的是头节点，没找到方法要怎么调用begin和end的</p>
<p>然后来看一下官方题解：</p>
<blockquote>
<p>方法 1：递归<br>
想法<br>
题目中最重要的要求是需要利用链表中的节点，构建一颗高度平衡的二叉搜索树，好消息是链表中的元素是升序的。<br>
众所周知，一棵二叉搜索树是一棵有根二叉树并且对于所有节点满足特殊的性质：对于树中任意一个点，它的权值必然 \geq≥ 所有左子树节点的权值，\leq≤ 所有右子树节点的权值。因为二叉树具有递归的子结构，二叉搜索树也同理：所有子树也是二叉搜索树。<br>
当前方法和下一个方法的主要思路是：<br>
给定列表中的中间元素将会作为二叉搜索树的根，该点左侧的所有元素递归的去构造左子树，同理右侧的元素构造右子树。这必然能够保证最后构造出的二叉搜索树是平衡的。<br>
算法<br>
由于我们得到的是一个有序链表而不是数组，我们不能直接使用下标来访问元素。我们需要知道链表中的中间元素。<br>
我们可以利用两个指针来访问链表中的中间元素。假设我们有两个指针 slow_ptr 和 fast_ptr。slow_ptr 每次向后移动一个节点而 fast_ptr 每次移动两个节点。当 fast_ptr 到链表的末尾时 slow_ptr 就访问到链表的中间元素。对于一个偶数长度的数组，中间两个元素都可用来作二叉搜索树的根。<br>
当找到链表中的中间元素后，我们将链表从中间元素的左侧断开，做法是使用一个 prev_ptr 的指针记录 slow_ptr 之前的元素，也就是满足 prev_ptr.next = slow_ptr。断开左侧部分就是让 prev_ptr.next = None。<br>
我们只需要将链表的头指针传递给转换函数，进行高度平衡二叉搜索树的转换。所以递归调用的时候，左半部分我们传递原始的头指针；右半部分传递 slow_ptr.next 作为头指针。</p>
</blockquote>
<pre><code>class Solution {
  private ListNode findMiddleElement(ListNode head) {
    // The pointer used to disconnect the left half from the mid node.
    ListNode prevPtr = null;
    ListNode slowPtr = head;
    ListNode fastPtr = head;

    // Iterate until fastPr doesn't reach the end of the linked list.
    while (fastPtr != null &amp;&amp; fastPtr.next != null) {
      prevPtr = slowPtr;
      slowPtr = slowPtr.next;
      fastPtr = fastPtr.next.next;
    }

    // Handling the case when slowPtr was equal to head.
    if (prevPtr != null) {
      prevPtr.next = null;
    }

    return slowPtr;
  }

  public TreeNode sortedListToBST(ListNode head) {

    // If the head doesn't exist, then the linked list is empty
    if (head == null) {
      return null;
    }

    // Find the middle element for the list.
    ListNode mid = this.findMiddleElement(head);

    // The mid becomes the root of the BST.
    TreeNode node = new TreeNode(mid.val);

    // Base case when there is just one element in the linked list
    if (head == mid) {
      return node;
    }

    // Recursively form balanced BSTs using the left and right halves of the original list.
    node.left = this.sortedListToBST(head);
    node.right = this.sortedListToBST(mid.next);
    return node;
  }
}
</code></pre>
<p><img src="https://lixin-ee.github.io//post-images/1574905972042.png" alt=""></p>
<blockquote>
<p>方法 2：递归 + 转成数组<br>
这个方法是空间换时间的经典案例。<br>
你可以通过使用更多空间来降低时间复杂度。<br>
在这个方法中，我们将给定的链表转成数组并利用数组来构建二叉搜索树。数组找中间元素只需要 O(1) 的时间，所以会降低整个算法的时间复杂度开销。<br>
算法<br>
将给定链表转成数组，将数组的头和尾记成 left 和 right 。<br>
找到中间元素 (left + right) / 2，记为 mid。这需要 O(1) 时间开销，也是与上面算法主要改进的地方。<br>
将中间元素作为二叉搜索树的根。<br>
递归构造二叉搜索树的左右两棵子树，两个子数组分别是 (left, mid - 1) 和 (mid + 1, right)。</p>
</blockquote>
<pre><code>class Solution {

  private List&lt;Integer&gt; values;

  public Solution() {
    this.values = new ArrayList&lt;Integer&gt;();
  }

  private void mapListToValues(ListNode head) {
    while (head != null) {
      this.values.add(head.val);
      head = head.next;
    }
  }

  private TreeNode convertListToBST(int left, int right) {
    // Invalid case
    if (left &gt; right) {
      return null;
    }

    // Middle element forms the root.
    int mid = (left + right) / 2;
    TreeNode node = new TreeNode(this.values.get(mid));

    // Base case for when there is only one element left in the array
    if (left == right) {
      return node;
    }

    // Recursively form BST on the two halves
    node.left = convertListToBST(left, mid - 1);
    node.right = convertListToBST(mid + 1, right);
    return node;
  }

  public TreeNode sortedListToBST(ListNode head) {

    // Form an array out of the given linked list and then
    // use the array to form the BST.
    this.mapListToValues(head);

    // Convert the array to
    return convertListToBST(0, this.values.size() - 1);
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：时间复杂度降到了 O(N) ，因为需要将链表转成数组。而取中间元素的开销变成了 O(1) 所以整体的时间复杂度降低了。<br>
空间复杂度：因为我们利用额外空间换取了时间复杂度的降低，空间复杂度变成了 O(N)，相较于之前算法的O(logN)有所提升，因为创建数组的开销。</p>
</blockquote>
<blockquote>
<p>方法 3：中序遍历模拟<br>
想法<br>
我们知道，二叉树有三种不同的遍历方法：<br>
前序遍历<br>
中序遍历 和<br>
后序遍历。<br>
中序遍历一棵二叉搜索树会有一个非常有趣的结论。<br>
中序遍历一棵二叉搜索树的结果是得到一个升序序列。<br>
这个方法模拟了二叉搜索树的构造过程，因为我们已经获得有序的链表，所以自然的产生了这样的想法。<br>
在描述算法之前，先看一下中序遍历是如何获得有序值的。<br>
基于解决这个问题的中序遍历的思想：<br>
我们知道中序遍历最左边的元素一定是给定链表的头部，类似地下一个元素一定是链表的下一个元素，以此类推。这是肯定的因为给定的初始链表保证了升序排列。<br>
在了解了中序遍历二叉搜索树和有序数组的关系之后，让我们来看看算法。<br>
算法<br>
首先用伪代码来理解一下算法。<br>
➔ function formBst(start, end)<br>
➔      mid = (start + end) / 2<br>
➔      formBst(start, mid - 1)<br>
➔<br>
➔      TreeNode(head.val)<br>
➔      head = head.next<br>
➔<br>
➔      formBst(mid + 1, end)<br>
➔<br>
遍历整个链表获得它的长度，我们用两个指针标记结果数组的开始和结束，记为 start 和 end，他们的初始值分别为 0 和 length - 1。<br>
记住，我们当前需要模拟中序遍历，找到中间元素 (start + end) / 2。注意这里并不需要在链表中找到确定的元素是哪个，只需要用一个变量告诉我们中间元素的下标。我们只需要递归调用这两侧。<br>
递归左半边，其中开始和结束的值分别为 start, mid - 1。<br>
在这个算法中，每当我们构建完二叉搜索树的左半部分时，链表中的头指针将指向根节点或中间节点（它成为根节点）。 因此，我们只需使用头指针指向的当前值作为根节点，并将指针后移一位，即 head = head.next。<br>
我们在递归右半部分 mid + 1, end。</p>
</blockquote>
<pre><code>class Solution {

  private ListNode head;

  private int findSize(ListNode head) {
    ListNode ptr = head;
    int c = 0;
    while (ptr != null) {
      ptr = ptr.next;  
      c += 1;
    }
    return c;
  }

  private TreeNode convertListToBST(int l, int r) {
    // Invalid case
    if (l &gt; r) {
      return null;
    }

    int mid = (l + r) / 2;

    // First step of simulated inorder traversal. Recursively form
    // the left half
    TreeNode left = this.convertListToBST(l, mid - 1);

    // Once left half is traversed, process the current node
    TreeNode node = new TreeNode(this.head.val);
    node.left = left;

    // Maintain the invariance mentioned in the algorithm
    this.head = this.head.next;

    // Recurse on the right hand side and form BST out of them
    node.right = this.convertListToBST(mid + 1, r);
    return node;
  }

  public TreeNode sortedListToBST(ListNode head) {
    // Get the size of the linked list first
    int size = this.findSize(head);

    this.head = head;

    // Form the BST now that we know the size
    return convertListToBST(0, size - 1);
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：时间复杂度仍然为 O(N) 因为我们需要遍历链表中所有的顶点一次并构造相应的二叉搜索树节点。<br>
空间复杂度：O(logN) ，额外空间只有一个递归栈，由于是一棵高度平衡的二叉搜索树，所以高度上界为logN。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[0视为空指针]]></title>
        <id>https://lixin-ee.github.io//post/0-shi-wei-kong-zhi-zhen</id>
        <link href="https://lixin-ee.github.io//post/0-shi-wei-kong-zhi-zhen">
        </link>
        <updated>2019-11-27T15:25:24.000Z</updated>
        <content type="html"><![CDATA[<p>在做习题18.20的时候发现一个函数匹配的问题<br>
题目为</p>
<pre><code>void f()
{
	compute(0);
}
</code></pre>
<p>解答为</p>
<p>五个compute全部是候选函数，除了空函数都可行，0视为NULL<br>
如果<strong>using声明</strong>出现在<strong>局部作用域</strong>中，则引入的名字将<strong>隐藏外层作用域的相关声明</strong>。<br>
只有using声明中的两个compute候选，</p>
<pre><code>namespace p  
{  
    void compute();//不可行  
    void compute(const void *);//可行,0-&gt;NULL  
}  
using p::compute;  
void compute(int);//可行,最佳匹配  
void compute(double, double = 1.1);//可行,int-&gt;double  
void compute(char*, char* = 0);//可行,0-&gt;NULL  
  
void f()  
{  
    compute(0);//与compute(int)版本最佳匹配  
}  


namespace p{  
    void compute();//不可行，可见  
    void compute(const void *);//可行,0-&gt;NULL，可见  
}  
void compute(int);//可行,不可见，被隐藏
void compute(double, double = 1.1);//可行,int-&gt;double,被隐藏 
void compute(char*, char* = 0);//可行,0-&gt;NULL，被隐藏
void f(){  
    using p::compute;  
    compute(0);
} 
</code></pre>
<p>然后网友答案中说0可以视为NULL 也就是空指针<br>
翻阅了一下笔记，确实如此：<br>
空指针生成方法 <code>int *p1 = nullptr; int *p2 = 0; int *p3 = NULL;（需要引用#include cstdlib）</code></p>
<p>C++空指针表示NULL、0、nullptr</p>
<p>空指针在之前可以用Null和0(在很多头文件中，NULL是一个被定义为0的符号常量)来表示。</p>
<p>C程序员通常使用NULL以指出这是一个指针（就像使用'\0'而不是0来表示空字符，以指出这是一个字符一样）</p>
<p>C++传统上更喜欢用简单的0，而不是等价的NULL</p>
<p>C++11提供了关键字nullptr</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第十八章 笔记+习题 18.2]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-ba-zhang-bi-ji-xi-ti-182</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-ba-zhang-bi-ji-xi-ti-182">
        </link>
        <updated>2019-11-27T13:32:34.000Z</updated>
        <content type="html"><![CDATA[<p>18.2命名空间<br>
<strong>多个库</strong>将名字放置在<strong>全局命名空间</strong>中将引发<strong>命名空间污染</strong>（namespace pollution)。<br>
命名空间(namespace)为防止名字冲突提供了更加可控的机制。命名空间分割了全局命名空间，其中<strong>每个命名空间是一个作用域</strong>。通过<strong>在某个命名空间中定义库的名字</strong>，库的作者及用户）可以避免全局名字固有的限制。<br>
18.2.1命名空间定义<br>
一个命名空间的<strong>定义</strong>包含<strong>两部分</strong>：首先是<strong>关键字namespace</strong>，随后是<strong>命名空间的名字</strong>。在命名空间名字后面是一系列由<strong>花括号括起來的声明和定义</strong>。只要能出现在全局作用域中的声明就能置于命名空间内，主要包括：<strong>类</strong>、<strong>变量</strong>（及其构始化操作）、<strong>函数</strong>（及其定义）、<strong>模板</strong>和<strong>其他命名空间</strong>：  	和其他名字一样，<strong>命名空间的名字</strong>也必须在定义它的<strong>作用域内保持唯一</strong>。命名空间既可以定义在全局作用域内，也可以定义在其他命名空间中，但是<strong>不能定义在函数或类的內部</strong>。     命名空间<strong>作用域后面无须分号</strong>。</p>
<p>和其他作用域类似，命名空间中的<strong>每个名字</strong>都必须表示<strong>该空间内的唯一实体</strong>。因为不同命名空间的作用域不同，所以在<strong>不同命名空间</strong>内可以有<strong>相同名字的成员</strong>。<br>
定义在某个命名空间中的名字可以被该<strong>命名空间内的其他成员直接访问</strong>，也可以被这些成员内嵌作用域中的任何单位访问。位于该<strong>命名空间之外</strong>的代码则必须<strong>明确指出</strong>所用的名字<strong>属于哪个命名空间</strong>：</p>
<p>命名空间可以<strong>定义在几个不同的部分</strong>，这一点与其他作用域不太一样。</p>
<p>可能是<strong>定义</strong>了一个名为nsp的<strong>新命名空间</strong>，<strong>也可能</strong>是为<strong>已经存在</strong>的命名空间<strong>添加一些新成员</strong>。<br>
命名空间的定义<strong>可以不连续的特性</strong>使得我们可以将<strong>几个独立的接口和实现文件（头文件+源文件）组成一个命名空间</strong>。此时，命名空间的组织方式<strong>类似于我们管理自定义类及函数</strong>的方式：<br>
•命名空间的一部分成员的<strong>作用是定义类，以及声明作为类接口的函数及对象</strong>，则这些成员应该<strong>置于头文件</strong>中，这些头文件将被<strong>包含在使用了这些成员的文件</strong>中。<br>
•命名空间成员的<strong>定义部分</strong>则置于<strong>另外的源文件中</strong>。</p>
<p>在程序中<strong>某些实体只能定义一次</strong>：如<strong>非内联函数</strong>、<strong>静态数据成员</strong>、<strong>变量</strong>等，<strong>命名空间中定义的名字也需要满足这一要求</strong>，我们可以通过上面的方式组织命名空间并达到目的。这种接口和实现分离的机制确保我们所需的函数和其他名字只定义一次，而只要是用到这些实体的地方都能看到对于实体名字的声明<br>
定义<strong>多个类型不相关的命名空间</strong>应该使用<strong>单独的文件</strong>分别表示<strong>每个类型</strong>（或关联类型构成的集合)。</p>
<p>假定作用域中存在合适的声明语句，则命名空间中的代码<strong>可以使用同一命名空间定义的名字的简写形式</strong>：<br>
也可以在命名空间定义的<strong>外部定义</strong>该命名空间的成员。命名空间对于<strong>名字的声明必须在作用域内</strong>，同时该<strong>名字的定义</strong>需要<strong>明确指出其所属的命名空间</strong>；<br>
尽管命名空间的成员<strong>可以定义在命名空间外部</strong>，但是这样的定义<strong>必须出现在所属命名空间的外层空间（还是需要加前缀）中</strong>。换句话说，我们可以在cplusplus_primer或<strong>全局作用域</strong>中定义Sales_data operator+,但是<strong>不能在一个不相关的作用域中定义这个运算符</strong>。</p>
<p>模块特例化<br>
<strong>模板特例化必须定义在原始模板所属的命名空间中</strong>（参见16.5节，第626页）。和其 他命名空间名字类似，<strong>只要</strong>我们<strong>在命名空间中声明了特例化，就能在命名空间外部定义它了</strong>！</p>
<p>全局命名空间<br>
全局作用域中定义的名字（即在所有类、函数及命名空间之外定义的名字）也就是定<br>
义在<strong>全局命名空间（global namespace)（不是std）<strong>中。<strong>全局命名空间以隐式的方式声明</strong>，并且在所有程序中都存在。<strong>全局作用域中定义的名字被隐式地添加到全局命名空间中</strong>。<br>
作用域运算符同样可以用于全局作用域的成员，因为</strong>全局作用域是隐式</strong>的，<strong>所以它并没有名字</strong>。下面的形式<br>
<strong>: :member_ name表示全局命名空间中的一个成员。</strong></p>
<p>嵌套的命名空间<br>
<strong>嵌套的命名空间</strong>是指<strong>定义在其他命名空间中的命名空间</strong><br>
嵌套的命名空间同时是<strong>一个嵌套的作用域</strong>，它<strong>嵌套在外层命名空间的作用域中</strong>。嵌套的命名空间中的名字遵循的规则与往常类似：<strong>内层命名空间声明的名字</strong>将<strong>隐藏外层命名空间声明的同名成员</strong>。在嵌套的命名空间中定义的名字<strong>只在内层命名空间中有效</strong>，<strong>外层命名空间</strong>中的代码要<strong>想访问它</strong>必须在名字前<strong>添加限定符</strong>。</p>
<p>内联命名空间<br>
<strong>内联命名空间中的名字</strong>可以<strong>被外层命名空间直接使用</strong>。也就是说，我们无须在内联命名空间的名字前添加表示该命名空问的前缀，通过外层命名空间的名字就可以直接访问它。     <strong>定义内联命名空间</strong>的方式是在关键字namespace前<strong>添加关键字inline</strong>：     inline namespace FifthEd{<br>
/ /该命名空间表示本书第5版的代码<br>
关键字inline<strong>必须出现在命名空间第一次定义的地方</strong>，<strong>后续再打开</strong>命名空间的时候<strong>可以写inline.也可以不写</strong>。<br>
当应用程序的代码在<strong>一次发布和另一次发布之间发生了改变</strong>时，<strong>常常会用到内联命名空间</strong>。<br>
<strong>新发布的可以直接用，旧发布的需要加上前缀</strong></p>
<p>未命名的命名空间<br>
<strong>未命名的命名空间</strong>（unnamed namespace)是指<strong>关键字namespace后紧跟花括号</strong>括起来的一系列声明语句。未命名的命名空间中定义的变量<strong>拥有静态生命周期</strong>：它们在第一次使用前创建，并且<strong>直到程序结束才销毁</strong>。<br>
一个未命名的命名空间可以在<strong>某个给定的文件内不连续</strong>，但是<strong>不能跨越多个文件</strong>。<strong>每个文件定义自己的未命名的命名空间</strong>，如果<strong>两个文件</strong>都含有未命名的<strong>命名空间</strong>，则这两个空间<strong>互相无关</strong>。在这两个未命名的命名空间中可以定义相同的名字，并且这些定义表示的是不同实体。<strong>如果一个头文件定义了未命名的命名空间</strong>，则该命名空间中定义的名字<strong>将在毎个包含了该头文件的文件中对应不同实体</strong>。<br>
和其他命名空间不同，<strong>未命名的命名空间仅在特定的文件内部有效</strong>，其作用范围不会橫跨多个不同的文件。     <strong>定义在未命名的命名空间中的名字可以直接使用(区分全局命名空间)</strong>，毕竟我们找不到什么命名空间的名宇来限定它们；同样的，<strong>我们也不能对未命名的命名空间的成员使用作用域运算符</strong>。<br>
<strong>未命名的命名空间</strong>中定义的<strong>名字的作用域</strong>与<strong>该命名空间所在的作用域相同</strong>。<strong>如果未命名的命名空间定义</strong>在文件的<strong>最外层作用域</strong>中，则该命名空间中的名字<strong>一定要与全局作用域中的名字有所区别</strong>：<br>
一个未命名的命名空间<strong>也能嵌套在其他命名空间</strong>当中。此时，未命名的命名空间中的成员<strong>可以通过外层命名空间的名字</strong>来访问：<br>
<strong>在文件中进行静态声明</strong>的做法已经被C++标准<strong>取消</strong>了，现在的做法是<strong>使用未命名的命名空间</strong>。</p>
<p>习题18.12<br>
只要在include的后面加上 namespace chapter{}就好<br>
习题18.13<br>
希望使用全局变量的时候<br>
命名的命名空间中定义的变量<strong>拥有静态生命周期</strong>：它们在第一次使用前创建，并且<strong>直到程序结束才销毁</strong><br>
或者希望减少命名空间冲突<br>
和其他命名空间不同，<strong>未命名的命名空间仅在特定的文件内部有效</strong>，其作用范围不会橫跨多个不同的文件。<br>
习题18.14<br>
<code>mathLib::MatrixLib::matrix mathLib::MatrixLib::operator*(const matrix &amp;,const matrix&amp;)</code><br>
注意返回类型不在作用域内，所以需要叫上作用域运算符</p>
<p>18.2.2使用命名空间成员<br>
像namespace_name::member_name这样使用命名空间的成员显然非常烦琐<br>
命名空间的别名<br>
<strong>命名空间的别名(name space alias)<strong>使得我们可以为命名空间的名字</strong>设定一个短得多的同义词</strong>。例如，一个很长的命名空间的名字形如<br>
namespace cplusplus_primer {/<em>...</em>/};<br>
我们可以为其设定一个短得多的同义词：<br>
<strong>namespace primer = cplusplus_primer;<br>
<strong>命名空间的别名声明以</strong>关键字namespace开始</strong>，后面是<strong>别名</strong>所用的名字、<strong>=符号</strong>、命名<br>
空间<strong>原来的名字</strong>以及一个分号。<strong>不能在命名空间还没有定义前就声明别名.否则将产生错误</strong>。<br>
命名空间的别名<strong>也可以指向一个嵌套的命名空间</strong>：<br>
namespace Qlib = cplusplus_primer::QueryLib;<br>
Qlib::Query q;</p>
<p>Using声明：扼要概述<br>
<strong>注意！！！using声明不是针对命名空间的！是针对作用域的，类也能用的！</strong>	一条using声明（using declaration)语句<strong>一次只引入命名空间的一个成员</strong>。它使得我们可以清楚地知道程序中所用的到底是哪个名字。 	using声明引入的名字遵守与过去一样的作用域规则：它的<strong>有效范围从using声明的地方开始，一直到using声明所在的作用域结束为止</strong>。在此过程中，<strong>外层作用域的同名实体</strong>将<strong>被隐藏</strong>。未加限定的名字只能在<strong>using声明所在的作用域</strong>以及其<strong>内层作用域</strong>中使用。在有效作用域结束后，我们就必须使用完整的经过限定的名字了。     一条using声明语句可出现在全局作用域、局部作用域、命名空间作用域从及类的作用域中。在<strong>类的作用域中</strong>，这样的声明语句<strong>只能指向基类成员</strong>（参见15.5节，第546页)。<br>
例如using Base::param;</p>
<p>using指示<br>
using指示(using directive)和using声明类似的地方是，我们可以使用命名空间名字的简写形式；<strong>和using声明不同的地方</strong>是，我们<strong>无法控制哪些名字是可见的</strong>，<strong>因为所有名字都是可见的</strong>。<br>
using指示以关键字using开始，后面是关键字namespace以及命名空间的名字。如果这里所用的名字不是一个己经定义好的命名空间的名字，则程序将发生错误。using指示可以出现在全局作用域、局部作用域和命名空间作用域中，但是<strong>不能出现在类的作用域中</strong>。<br>
using指示<strong>使得某个特定的命名空间中所有的名字都可见</strong>，这样我们就无须再为它们添加任何前缀限定符了。简写的名字从using指示开始，一直到using指示所在的作用域结束都能使用。     如果我们提供一个<strong>对std等命名空间</strong>的using指示而<strong>未做任何特殊控制</strong>的话，将<strong>重新引入</strong>由于使用了多个库而造成的<strong>名字冲突问题</strong>。</p>
<p>using指示与作用域<br>
<strong>using 指示</strong>引入的名字的作用域远比<strong>using 声明</strong>引入的名字的作用域<strong>复杂</strong>。如我们所知，<strong>using 声明的名字的作用域与using 声明语句本身的作用域一致</strong>，<br>
<strong>using指示</strong>所做的绝非声明别名这么简单。相反，它<strong>具有将命名空间成员提升到包含命名空间本身和using指示的最近作用域的能力</strong>。     using 声明和using 指示在作用域上的区别<strong>直接决定了它们工作方式的不同</strong>。对于<strong>using 声明来说</strong>，我们只是<strong>简单地令名字在局部作用域内有效</strong>。相反，<strong>using 指示</strong>是<strong>令整个命名空间的所有内容变得有效</strong>。通常情况下，<strong>命名空间中会含有一些不能出现在局部作用域中的定义</strong>，因此，using指示<strong>一般被看作是出现在最近的外层作用域中</strong>。</p>
<p>当命名空间被注入到它的外层作用域之后，<strong>很有可能该命名空间中定义的名字会与其外层作用域中的成员冲突</strong>。例如在manip中，blip的成员j就与全局作用域中的j产生了冲突。这种<strong>冲突是允许存在的</strong>，但是要想使用冲突的名字.我们<strong>就必须明确指出名字的版本</strong>。manip中所有未加限定的j都会产生二义性错误。</p>
<p>头文件与using声明或指示<br>
<strong>头文件</strong>如果在其<strong>顶层作用域</strong>中<strong>含有using指示或using声明</strong>，则会将名字<strong>注入到所有包含了该头文件的文件</strong>中。通常情况下，头文件应该只负责定义接口部分的名字，而不定义实现部分的名字。因此，<strong>头文件最多只能在它的函数或命名空间内使用using指示或using声明</strong>（参见3.1节，第75页）。</p>
<p>习题18.15<br>
<strong>using 指示</strong>引入的名字的作用域远比<strong>using 声明</strong>引入的名字的作用域<strong>复杂</strong>。如我们所知，<strong>using 声明的名字的作用域与using 声明语句本身的作用域一致</strong>，<br>
<strong>using指示</strong>所做的绝非声明别名这么简单。相反，它<strong>具有将命名空间成员提升到包含命名空间本身和using指示的最近作用域的能力</strong>。     using 声明和using 指示在作用域上的区别<strong>直接决定了它们工作方式的不同</strong>。对于<strong>using 声明来说</strong>，我们只是<strong>简单地令名字在局部作用域内有效</strong>。相反，<strong>using 指示</strong>是<strong>令整个命名空间的所有内容变得有效</strong>。通常情况下，<strong>命名空间中会含有一些不能出现在局部作用域中的定义</strong>，因此，using指示<strong>一般被看作是出现在最近的外层作用域中</strong>。</p>
<p>习题18.16+17<br>
位置1：相当于把exercise中的名字引入到外层作用域中<br>
位置2：相当于把exercise中的名字引入到函数的作用域中，会影响dvar的定义和ivar的使用<br>
如果是using指示，那么位置1和位置2差别不大，<strong>具有将命名空间成员提升到包含命名空间本身和using指示的最近作用域的能力</strong></p>
<pre><code>//1.1  
//using exercise::ivar;//错误，与全局变量ivar冲突，多次声明  
//using exercise::dvar;  
//using exercise::limi;  
//  
//void manip()  
//{  
//  double dvar = 3.1416;//覆盖using声明的dvar  
//  int iobj = limi + 1;  
//  ++ivar;  
//  ++::ivar;  
//}  
  
  
//1.2  
//void manip()  
//{  
//  using exercise::ivar;//隐藏全局变量  
//  using exercise::dvar;  
//  using exercise::limi;  
//  double dvar = 3.1416;//错误，多重定义，多次初始化，当前dvar对象已经可见  
//  int iobj = limi + 1;  
//  ++ivar;//exercise的ivar  
//  ++::ivar;//全局变量  
//}  
  
//2.1  
//using namespace exercise;  
//void manip()  
//{  
//  double dvar = 3.1416;//覆盖using声明的dvar  
//  int iobj = limi + 1;  
//  ++ivar;//错误，不明确,二义性,二者都可见  
//  ++::ivar;  
//}  
  
//2.2  
//void manip()  
//{  
//  using namespace exercise;  
//  double dvar = 3.1416;//覆盖using声明的dvar  
//  int iobj = limi + 1;  
//  ++ivar;//错误，不明确,二义性,二者都可见  
//  ++::ivar;  
//} 
</code></pre>
<p>18.2.3 类、命名空间与作用域<br>
对<strong>命名空间内部名字</strong>的查找遵循常规的查找规则：即<strong>由内向外</strong>依次査找每个外层作用域。外层作用域也可能是一个或多个嵌套的命名空间，直到最外层的全局命名空间査找过程终止。只有位于开放的块中且在<strong>使用点之前声明的名字才被考虑</strong>：     对于位于<strong>命名空间中的类</strong>来说，常规的查找规则仍然适用：当成员函数使用某个名字时，首先在该成员中进行查找，然后在类中查找（包括基类），<strong>接着在外层作用域中查找</strong>，这时一个或几个外层作用域可能就是命名空间</p>
<p>可以从<strong>函数的限定名推断出查找名字时检查作用域的次序</strong>，限定名以相反次序,指出被査找的作用域。</p>
<p>实参相关的查找与类类型形参</p>
<p>对于命名空间中名字的隐藏规则来说有一个重要的例外，它使得我们可以<strong>直接访问输出运算符</strong>。这个<strong>例外是</strong>，当我们给函数<strong>传递一个类类型的对象</strong>时，<strong>除了在常规的作用域查找</strong>外<strong>还会查找实参类（比如cin和string的std）所属的命名空间</strong>。这一例外对于<strong>传递类的引用或指针</strong>的调用<strong>同样有效</strong>。</p>
<p>查找规则的这个例外允许概念上<strong>作为类接口一部分的非成员函数无须单独的using<br>
声明就能被程序使用</strong>。<br>
不需要using std::operator&gt;&gt;或者std::operator&gt;&gt;()</p>
<p>查找与std：：move 和 std::forward<br>
接下来考虑标准库<strong>move和forward</strong>函数。送两个都是模板函数，在标准库的定义中它们都<strong>接受一个右值引用的函数形参</strong>。如我们所知，在函数模板中，<strong>右值引用形参可以匹配任何类型</strong>（参见16.2.6节，第611页）。<strong>如果我们的应用程序也定义</strong>了一个<strong>接受单一形参</strong>的<strong>move函数</strong>，则<strong>不管该形参是什么类型</strong>，应用程序的move函数<strong>都将与标准库的版本冲突</strong>。<strong>forward函数也是如此</strong>。<br>
因此，move(以及forward)的名字冲突要比其他标准库函数的冲突频繁得多。而且，因为move和forward执行的是非常特殊的类型操作，所以应用程序专口修改函数原有行为的概率非常小。<br>
对于move和forward来说，冲突很多但是大多数是无意的，这一特点<strong>解释了为什么我们建议最好使用它们的带限定语的完整版本的原因</strong>（参见12.1.5节，第417页）。通过<strong>书写std::move而非move</strong>，我们就能明确地知道想要使用的是函数的标准库版本。</p>
<p>友元声明与实参相关的查找<br>
当类声明了一个友元时，<strong>该友元声明并没有使得友元本身可见</strong>（参见7.2.1节，第242页）。然而，一个<strong>另外的未声明的类或函数</strong>如果<strong>第一次出现在友元声明中</strong>，则我们认为它是<strong>最近的外层命名空间的成员</strong>。这条规则与实参相关的查找规则结合在一起将产生意想不到的效果：</p>
<p>习题18.18<br>
会首先在当前作用域中查找，然后查找参数的类所属的命名空间，所以<br>
当参数为string时，会使用string类中查找到的swap函数，找到则不使用std版本的。若未int类型，则直接使用标准库版本的swap<br>
习题18.19<br>
会强制使用std的swap</p>
<p>18.2.4 重载与命名空间<br>
命名空间对<strong>函数的匹配过程</strong>有<strong>两方面的影响</strong>（参见6.4节，第209页）。其中<strong>一个影响非常明显</strong>：using声明或using指示能<strong>将某些函数添加到候选函数集</strong>。另外一个影响则比较微妙。<br>
与实参相关的查找与重载<br>
对于接受类类型实参的函数来说，其名字查找将在实参类所属的命名空间中进行。这条规则对于我们如何确定候选函数集同样也有影响。我们<strong>将在每个实参类</strong>（以及实参类的<strong>基类</strong>）<strong>所属的命名空间中搜寻候选函数</strong>。在这些命名空间中所有与被调用函数<strong>同名的函数都将被添加到候选集</strong>当中，即使其中某些函数在调用语句处不可见也是如此：</p>
<p>重载与using声明<br>
要想理解using声明与重载之间的交互关系，必须首先明确一条：<strong>using声明语句声明的是一个名字</strong>，<strong>而非一个特定的函数</strong>（参见15.6节，第551页）：<br>
using <strong>NS::print(int)</strong>;		//<strong>错误：不能指定形参列表</strong><br>
using NS::print;	//正确：using声明只弄明一个名字<br>
当我们<strong>为函数书写using声明</strong>时，该函数的<strong>所有版本</strong>都被引入到当前作用域中。<br>
比如using std::operator&gt;&gt;<br>
一个using声明囊括了<strong>重载函数的所有版本</strong>以确保<strong>不违反命名空间的接口</strong>。<br>
一个using声明引入的函数将<strong>重载</strong>该声明语句<strong>所属作用域中已有的其他同名函数</strong>。如果<strong>using声明</strong>出现在<strong>局部作用域</strong>中，则引入的名字将<strong>隐藏外层作用域的相关声明</strong>。如果using声明所在的作用域中己经有一个函数与新引入的函数<strong>同名且形参列表相同</strong>，则该using声明将<strong>引发错误</strong>。除此之外，using声明将为引入的名字添加额外的重载实例，并最终扩充候选函数集的规模。</p>
<p>重载与using指示<br>
如果命名空间的某个函数与该命名空间所属作用域的函数同名，则命名空间的函数将被添加到重载集合中：<br>
与using 声明不同的是，对于<strong>using 指示</strong>来说，<strong>引入</strong>一个与<strong>已有函数形参列表完全相同<br>
的函数并不会产生错误</strong>。此时，<strong>只要</strong>我们<strong>指明</strong>调用的是命名空间中的<strong>函数版本</strong>还是当前作用域的<strong>版本</strong>即可。</p>
<p>习题18.20<br>
五个compute全部是候选函数，除了空函数都可行，0视为NULL<br>
如果<strong>using声明</strong>出现在<strong>局部作用域</strong>中，则引入的名字将<strong>隐藏外层作用域的相关声明</strong>。<br>
只有using声明中的两个compute候选，</p>
<pre><code>namespace p  
{  
    void compute();//不可行  
    void compute(const void *);//可行,0-&gt;NULL  
}  
using p::compute;  
void compute(int);//可行,最佳匹配  
void compute(double, double = 1.1);//可行,int-&gt;double  
void compute(char*, char* = 0);//可行,0-&gt;NULL  
  
void f()  
{  
    compute(0);//与compute(int)版本最佳匹配  
}  


namespace p{  
    void compute();//不可行，可见  
    void compute(const void *);//可行,0-&gt;NULL，可见  
}  
void compute(int);//可行,不可见，被隐藏
void compute(double, double = 1.1);//可行,int-&gt;double,被隐藏 
void compute(char*, char* = 0);//可行,0-&gt;NULL，被隐藏
void f(){  
    using p::compute;  
    compute(0);
} 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第十八章 笔记+习题 18.1]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-ba-zhang-bi-ji-xi-ti-181</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-ba-zhang-bi-ji-xi-ti-181">
        </link>
        <updated>2019-11-27T02:23:35.000Z</updated>
        <content type="html"><![CDATA[<p>18.1异常处理<br>
异常处理 (exceptionhandling )机制允许程序中独立开发的部分能够在<strong>运行时就出现的问题进行通信并做出相应的处理</strong>。异常使得我们能够将<strong>问题的检测与解决过程分离开来</strong>。</p>
<p>18.1.1 抛出异常<br>
我们通过<strong>抛出( throwing )一条表达式来引发（raised )—个异常</strong>。被抛出的表达式的<strong>类型</strong>以及当前的<strong>调用链</strong>共同<strong>决定了哪段处理代码( handler )</strong> 将被用来处理该异常。被选中的处理代码是在调用链中与抛出对象类型匹配的最近的处理代码。其中，根据抛出对象的类型和内巧，程净的异常抛出部分将会告知异常处理部分到底发生了什么错误。<br>
当执行一个 throw 时，跟在 <strong>throw 后面的语句将不再被执行</strong>。.相反，程序的控制权从 throw 转移到与之匹配的 <strong>catch 模块</strong>。<br>
•沿着调用链的函数可能会提早退出。<br>
•一旦程序<strong>开始执行异常处理代码</strong>，则沿着<strong>调用链创建的对象将被销毁</strong>。<br>
因为跟在 throw 后面的语句将<strong>不再被执行</strong>，所以<strong>throw 语句的用法有点类似于 return语句</strong>：它通常作为<strong>条件语句的一部分</strong>或者作为某个<strong>函数的最后（或者唯一）一条语句</strong>。</p>
<p>当 throw 出现在一个try 语句块（try block )内时，检查与该 try 块关联的 catch 子句。如果找到了匹配的 catch ,就使用该 catch 处理异常。如果这一步没找到匹配的 catch 且该 try 语句嵌套在其他 try 块中，则继续检查与<strong>外层 try</strong> 匹配的catch 子句。如果还是找不到匹配的 catch ,则退出当前的函数，在<strong>调用当前函数的外层函数中</strong>继续寻找。<br>
如果对抛出异常的函数的调用语句位于一个 try 语句块内，则检查与该 try 块关联的 catch 子句。如果找到了匹配的 catch ,就使用该 catch 处理异常。否则，如果该try 语句嵌套在其他 try 块中，则继续检查与外层 try 匹配的 catch 子句。如果仍然没有找到匹配的 catch ,则退出当前这个主调函数，维续在调用了刚刚退出的这个函数的其他函数中寻找，以此类推。<br>
上述过程被称为 <strong>栈展开 （stack unwinding )过程</strong>。栈展开过程<strong>沿着嵌套函数的调用链</strong><br>
不断查找，直到找到了与异常匹配的 catch 子句为止；或者也可能一直没找到匹配的catch ,则退出主函数后查找过程终止。<br>
假设<strong>找到了一个匹配的 catch 子句</strong>，则程序进入该子句并执行其中的代码。当<strong>执行完这个 catch 子句后</strong>，找到与 try 块关联的<strong>最后一个 <strong>catch <strong>子句之后的点</strong>，并从这里</strong>继续执行</strong>。<br>
<strong>如果没找到匹配的 catch 子句，程序将退出</strong>。因为异常通常被认为是妨碍程序正常执行的事件，所以—旦引发了某个异常，就<strong>不能对它置之不理</strong>。当<strong>找不到匹配的 catch</strong>时，程序将<strong>调用标准库函数 terminate,</strong> 顾名思义， terminate 负责终止程序的执行过程。</p>
<p>在栈展开过程中，位于调用链上的语句块可能会提前退出。通常情况下，程序在这些块中创建了一些局部对象。我们已经知道，<strong>块退出后它的局部对象也将随之销毁</strong>，这条规则对于栈展开过程同样适用。如果在找展开过程中退出了某个块，<strong>编译器将负责确保在这个块中创建的对象能被正确地销毁。</strong> 如果某个局部对象的类型是类类型，则该对象的析构函数将被自动调用。与往常一样，编译器在销毁内置类型的对象时不需要做任何事情。<br>
<strong>析构函数总是会被执行的</strong>，但是函数中<strong>负责释放资源的代码却可能被跳过</strong><br>
如果一个块分配了资源，并且在<strong>负责释放这些资源的代码前面发生了异常</strong>，则<strong>释放资源的代码将不会被执行</strong>。另一方面，类对象分配的资源将由类的析构函数负责释放。因此，如果我们<strong>使用类来控制资源的分配</strong>，就能确保无论函数正常结果还是遭遇异常，<strong>资源都能被正确地释放</strong>。<br>
出于<strong>栈展开可能使用析构函数</strong>的考虑，<strong>析构函数不应该抛出不能被它自身处理的异常</strong>。换句话说，如果析构函数需要执行某个可能抛出异常的操作，则该操作应该被放置在一个 try 语句块当中，并且在析构函数内部得到处理。<br>
在实际的编程过程中，因为析构函数<strong>仅仅是释放资源，所以它不太可能抛出异常</strong>。所有<strong>标准库类型都能确保它们的析构函数不会引发异常</strong>。<br>
在栈展开的过程中，运行类类型的局部对象的析构函数。因为这些析构函数是自动执行的，所以它们不应该抛出异常。<strong>一旦在栈展开的过程中析构函数拋出了异常</strong>，并且析构函数<strong>自身没能捕获到该异常，则程序将被终止</strong>。</p>
<p><strong>异常对象( exceptionobject )<strong>是一种特殊的对象，编译器使用 <strong>异常抛出表达式来对异常对象进行拷贝初始化</strong>（参见13.1.1节，第441页）。因此， <strong>throw 语句中的表达式必须拥有完全类型</strong>  而且如果该表达式是</strong>类类型</strong>的话，则相应的类必须含有一个<strong>可访问的析构函数</strong>和一个<strong>可访问的拷贝或移动构造函数</strong>。如果该表达式是<strong>数组类型或函数类型</strong>，则表达式将被转换成与之<strong>对应的指针类型</strong>。<br>
<strong>异常对象位于由编译器管理的空间中</strong>，编译器确保无论最终调用的是哪个 catch 子句都能访问该空间。当异常处理完带后，异常对象被销毁。<br>
如果退出了某个块，则同时释放块中局部对象使用的内存。因此.<strong>抛出一个指向局部对象的指针几乎肯定是一种错误的行为</strong>。出于同样的原因，<strong>从函数中返回指向局部对象的指针也是错误的</strong><br>
我们抛出一条表达式时，该表达式的<strong>静态编译时类型</strong>（参见15.2.3节，第534页）<strong>决定</strong>了<strong>异常对象的类型</strong>。读者必须牢记这一点，因为很多情况下程序抛出的表达式类型来自于某个继承体系。如果一条 throw 表达式<strong>解引用</strong>一个基类指针，而该指针实际指向的是派生类对象，则抛出的对象将被切掉一部分（参见15.2.3节，第535页），<strong>只有基类部分被抛出</strong>。<br>
<strong>拋出指针</strong>要求在任何对应的<strong>处理代码存在的地方</strong>，指针<strong>所指的对象都必须存在</strong>。</p>
<p>习题18.1<br>
（a）range error的类类型<br>
（b）p指向error的指针类型，为exception类型，range error是它的派生类，，但异常对象的类型取决于静态类型，所以是exception类型<br>
改成指针会引发错误，如果退出了某个块，则同时释放块中局部对象使用的内存。因此.<strong>抛出一个指向局部对象的指针几乎肯定是一种错误的行为</strong>。出于同样的原因，<strong>从函数中返回指向局部对象的指针也是错误的</strong><br>
习题18.2<br>
程序会查找catch语句，如果在内外层作用域都找不到的话就销毁所有局部对象然后调用terminate的abort()<br>
发生异常，所在块之前的临时变量皆会被销毁，V会调用vector类的析构函数进行销毁，并释放相关内存，P指针会被销毁，<strong>但是P指针指向的内存由于是动态分配的，所以该内存不会被释放</strong>，造成内存泄漏。输入流对象会调用ifstream类的析构函数销毁，最后程序被终止<br>
习题18.3<br>
1.使用try catch，在catch语句中销毁局部变量和动态内存<br>
2.使用throw catch<br>
3.使用智能指针类<br>
4.使用类类型，在析构函数中delete指向动态内存的指针</p>
<p>18.1.2 捕获异常<br>
catch 子句（ catchclause )中的异常声明( exceptiondeclaration )看起来像是只包含一个形参的函数形参列表。像在形参列表中一样，如果 catch 无须访问抛出的表达式的话，则我们可以忽略捕获形参的名字。<br>
<strong>声明的类型</strong>决定了<strong>处理代码</strong>所能<strong>捕获的异常类型</strong>。这个类型<strong>必须是完全类型</strong>（参见7.3.3节，第250页），它可以是左值引用，但不能是右值引用（参见13.6.1节，第471页）。<br>
当进入一个 catch 语句后，通过<strong>异常对象初始化异常声明中的参数</strong>。和函数的参数类似，如果 catch 的参数类型是非引用类型，则该参数是异常对象的一个副本，在 catch语句内改变该参数实际上改变的是局部副本而非异常对象本身；相反，如果参数是引用类型，则和其他引用参数一样，该参数是异常对象的一个别名，此时改变参数也就是改变异常对象。<br>
catch 的参数还有一个特性也与函数的参数非常类似：如果 catch 的参数是基类类型，则我们可以使用其派生类类型的异常对象对其进行初始化。此时，如果 catch 的参数是<strong>非引用类型</strong>，则异常对象将<strong>被切掉一部分</strong>（参见15.2.3节，第535页），这与将派生类对象以值传递的方式传给一个普通函数差不多。另一方面，如果 catch 的参数是<strong>基类的引用</strong>，则该参数将<strong>以常规方式绑定</strong>到异常对象上。<br>
最后一点需要注意的是，<strong>异常声明的静态类型将决定 catch 语句所能执行的操作</strong>。如果 catch 的参数是基类类型，则 catch 无法使用派生类特有的任何成员。<br>
通常情况下，如果catch接受的异常与<strong>某个继承体系有关</strong>，则最好将该catch的参数<strong>定义成引用类型</strong>。</p>
<p>在搜寻 catch 语句的过程中，我们最终找到的 catch <strong>未必是异常的最佳匹配</strong>。相反，<strong>挑选出来的应该是第一个与异常匹配的</strong> catch 语句。因此，<strong>越是专门的 catch 越应该置于整个 catch 列表的前端。</strong>（<strong>并不像函数匹配那样</strong>）<br>
因为 catch 语句是<strong>按照其出现的顺序逐一进行匹配的</strong>，所以当程序使用具有继承关系的多个异常时必须对 catch 语句的顺序进行组织和管理，使得<strong>派生类异常</strong>的处理代码出现在<strong>基类异常</strong>的处理代码<strong>之前</strong>。<br>
与实参和形参的匹配规则相比，异常和 catch 异常声明的匹配规则受到更多限制。此时，<strong>绝大多数类型转换都不被允许</strong>，除了一些极细小的差别之外，要求异常的类型和catch 声明的类型是精确匹配的：<br>
•允许<strong>从非常量向常量的类型转换</strong>，也就是说，一条非常量对象的 throw 语句可以匹配一个接受常量引用的 catch 语句。<br>
•允许从<strong>派生类向基类</strong>的类型转换。<br>
•<strong>数组</strong>被转换化<strong>指向数组（元素）类型的指针</strong>，<strong>函数</strong>被转换成<strong>指向该函数类型的指针</strong>。<br>
除此之外，包括准算术类型转换和类类型转换在内，其他所有转换规则都不能在匹配catch 的过程中使用。<br>
如果在多个catch语句的类型之间存在着继承关系，则我们应该把<strong>继承链最底端</strong>的类（mos tderived type)<strong>放在前面</strong>，而将<strong>继承链最顶端</strong>的类（least derived type)<strong>放在后面</strong>。</p>
<p>有时，一个单独的 catch 语句不能完整地处理某个异常。在执行了某些校正操作之后，<strong>当前的 catch</strong> 可能会决定由<strong>调用链更上一层的函数</strong>接着处理异常。一条 catch 语句通过<strong>重 新抛出 （ rethrowing )<strong>的操作</strong>将异常传递</strong>给<strong>另外一个 catch 语句</strong>。这里的重新抛出仍然是一条 throw 语句，只不过<strong>不包含任何表达式</strong>：<br>
<strong>throw;<br>
空的 throw 语句只能出现</strong>在** catch 语句<strong>或</strong> catch 语句直接或间接调用的函数之内**。如果在<strong>处理代码之外的区域</strong>遇到了空 throw 语句，<strong>编译器将调用 terminate</strong> 。<br>
一个重新抛出语句<strong>并不指定新的表达式</strong>，而是将当前的异常对象<strong>沿着调用链向上传递</strong>。<br>
很多时候， catch 语句<strong>会改变其参数的内容</strong>。如果在改变了参数的内容后 catch 语句重新抛出异常，则只有当 catch <strong>异常声明是引用类型时</strong>我们<strong>对参数所做的改变才会被保留</strong>并继续传播：</p>
<p>为了<strong>一次性捕获所有异常</strong>.我们使用<strong>省略号</strong>作为<strong>异常声明</strong>，这样的处理代码称为**捕获所有异常( catch - all )**的处理代码，形如 <strong>catch (...)</strong>。一条捕获所有异常的语句可以与任意类型的异常匹配。<br>
<strong>catch (...)通常与重新抛出语句一起使用</strong>，其中 catch <strong>执行当前局部能完成的工作（处理收尾）</strong>，随后重新抛出异常：</p>
<p>catch (...)既能单独出现，也能与其他几个 catch 语句一起出现<br>
如果 catch (...) 与其他几个 catch 语句一起出现，<strong>则 catch {…) 必须在最后的位置</strong>。出现在捕获所有异常语句后面的 catch 语句将永远不会被匹配。</p>
<p>习题18.4<br>
exception是基类，能够接纳一切的派生类对象，下面派生类对象的catch就没意义了<br>
应该顺序倒过来<br>
习题18.5</p>
<pre><code>int main() {
	try {
	
	}
	catch (overflow_error err) { cout&lt;&lt;err.what(); abort(); }
	catch(underflow_error err) { cout &lt;&lt; err.what(); abort(); }
	catch (range_error err) { cout &lt;&lt; err.what(); abort(); }
	catch(domain_error err) { cout &lt;&lt; err.what(); abort(); }
	catch (invalid_argument err) { cout &lt;&lt; err.what(); abort(); }
	catch (out_of_range err) { cout &lt;&lt; err.what(); abort(); }
	catch (length_error err) { cout &lt;&lt; err.what(); abort(); }
	catch(runtime_error err) { cout &lt;&lt; .what(); abort(); }
	catch(logic_error err) { cout &lt;&lt; .what(); abort(); }
	catch(bad_cast err) { cout &lt;&lt; .what(); abort(); }
	catch(bad_alloc err) { cout &lt;&lt; .what(); abort(); }
}
</code></pre>
<p>习题18.6<br>
(a)：throw &amp;exceptionType()<br>
(b)：任何异常皆可<br>
(c)：throw int()</p>
<p>18.1.3 函数try语句块与构造函数<br>
<strong>构造函数</strong>在进入其函数体之前<strong>首先执行初始值列表</strong>。因为在初始值列表抛出异常时构造函数体内的** try 语句块还未生效**，所以构造函数体内的 catch 语句<strong>无法处理构造函数初始值列表抛出的异常</strong>。<br>
要想处理构造函数初始值抛出的异常，我们<strong>必须将构造函数写成函数 try 语句块</strong>（也称为<strong>函数测试块(function try block )<strong>的形式。<strong>函数 try 语句块</strong>使得一组 catch 语句</strong>既能处理构造函数体</strong>（或析构函数体)，<strong>也能处理</strong>构造函数的<strong>初始化过程</strong>（或析构函数的<strong>析构过程完全隐式的）)</strong>。</p>
<p>注意：关键字 try 出现在表示构造函数初始值列表的冒号以及表示构造函数体（此例为空）的花括号之前。与这个 try 关联的 catch 既能处理构造函数化抛出的异常，也能处理成员初始化列表抛出的异常。<br>
还有一种情况值得读者注意，在<strong>初始化构造函数的参数</strong>时<strong>也可能发生异常</strong>，这样的异常<strong>不属于函数 try 语句块</strong>的一部分。函数 try 语句块只能处理构造函数开始执行后发生的异常。和其他函数调用一样，如果在参数初始化的过程中发生了异常.则该异常<strong>属于调用表达式的一部分</strong>，并将<strong>在调用者所在的上下文中处理</strong>。<br>
<strong>处理构造函数初始值异常的唯一方法是将构造函数写成函数 try 语句块</strong>。</p>
<p>习题18.7</p>
<pre><code>template &lt;typename&gt;
	Blob&lt;T&gt;::Blob() try:data(std::make_shared&lt;std::vector&lt;T&gt;)){ } catch(const std::bad_alloc &amp;e){handle_out_of_memory(e);}
</code></pre>
<p>18.1.4 noexcept异常说明<br>
对于用户及编译器来说，预先知道某个函数不会抛出异常显然大有裨益。首先，知道函数不会抛出异常有助于简化调用该函数的化码；其次，如果编译器确认函数不会抛出异常，它就能执行某些特殊的优化操作，而这些优化操作并不适用于可能出错的代码<br>
我们可以通过提供 <strong>noexcept说明</strong> （ noexcept specification )<strong>指定某个函数不会抛出异常</strong>。<br>
void recoup(int) <strong>noexcept</strong>;  //不会抛出异常   <strong>注意noexcept的位置</strong>void alloc(int);  //可能抛出异常<br>
recoup 做了不抛出说明 （ nonthrowing specification )。</p>
<p><strong>noexcept 说明要么出现在该函数的所有声明语句和定义语句中，要么一次也不出现。</strong> 该说明应该在函数的尾置返回类型（参见6.3.3节，第206页）之前。<br>
我们也可以在<strong>函数指针的声明和定义中指定 noexcept</strong> 。<br>
在 <strong>typedef 或类型别名</strong>中则<strong>不能出现 noexcept</strong> 。<br>
在成员函数中， noexcept 说明符需要跟在 <strong>const 及引用限定符之后</strong>,而在 <strong>final</strong> 、<strong>override 或虚函数的=0之前</strong>。</p>
<p>读者需要请楚的一个事实是<strong>编译器并不会在编译时检查 noexcept 说明</strong>。实际上，如果一个函数在说明了 noexcept 的同时又含有 throw 语句或者调用了可能抛出异常的其他函数，编译器将顺利编译通过，并不会因为这种违反异常说明的情况而报错（不排除个别编译器会对这种用法提出警告）：<br>
尽管函数声明了它不会抛出异常，但实际上还是抛出了。<strong>一旦一个 noexcept 函数抛出了异常</strong>，程序就会<strong>调用 terminate</strong>以确保遵守不在运行时抛出异常的承诺。上述过程对是否执行栈展开未作约定，因此 <strong>noexcept 可以用在两种情况下</strong>：一是我们<strong>确认函数不会抛出异常</strong>，二是我们<strong>根本不知道该如何处理异常</strong>。<br>
指明某个函数不会抛出异常可以令该函数的调用者不必再考虑如何处理异常。无论是函数确实不抛出异常，还是程序被终止，调用者都无须为此负责。<br>
通常情况下，编译器不能也不必在编译时验证异常说明。</p>
<p>noexcept 说明符的实参常常与 <strong>noexcept 运算符 (noexcept operator )</strong> 混合使用。 noexcept 运算符是一个一元运算符，它的<strong>返回值是一个 bool 类型的右值常量表达式</strong>，用于<strong>表示给定的表达式是否会抛出异常</strong>。<br>
noexcept(recoup(i))  //如果recoup不抛出异常则结果为true;否则结果为false<br>
noexcept(e)<br>
当 e 调用的所有函数<strong>都做了不抛出说明</strong>且 e <strong>本身不含有 throw 语句</strong>时，上述表达式为true ；否则 noexcept ( e )返回 false 。<br>
我们可以使用 noexcept 运算符得到如下的异常说明：<br>
void f() noexcept (noexcept (g ()));  //<strong>f和g的异常说明一致<br>
注意后面的不是函数体，而是noexcept说明符</strong><br>
如果函数 g 承诺了不会抛出异常，则 f 也不会抛出异常；如果 g 没有异常说明符，或者 g虽然有异常说明符巧是允许抛出异常，则 f 也可能抛出异常。<br>
noexcept 有两层含义；当跟在函数参数列表后面时它是<strong>异常说明符</strong>；而当作为 noexcept 异常说明的 bool 实参出现时，它是一个<strong>运算符</strong>。void f() noexcept (noexcept (g ())); //第一个noexcept是异常说明符，第二个noexcept是运算符。</p>
<p>尽管 noexcept 说明符<strong>不属于函数类型的一部分</strong>，但是函数的<strong>异常说明仍然会影响函数的使用。</strong><br>
<strong>函数指针</strong>及该指针<strong>所指的函数必须具有一致的异常说明</strong>。也就是说，如果我们为某个<strong>指针做了不抛出异常的声明</strong>，则该指针将<strong>只能指向不抛出异常的函数</strong>。相反，如果我们<strong>显式或隐式</strong>地<strong>说明</strong>了指针<strong>可能抛出异常</strong>，则该指针<strong>可以指向任何函数</strong>，<strong>即使是承诺了不抛出异常</strong>的**函数也可以（不同于const，const指针也可以指向非常量）<br>
区分<code>(*func)(int)</code>和 <code>*fun(int)</code> 前者是一个指针，后者是一个函数，调用运算符优先级高于解引用运算符 **</p>
<p>如果一个<strong>虚函数</strong>承诺了它<strong>不会抛出异常</strong>，则后续<strong>派生出来的虚函数</strong>也<strong>必须做出同样的承诺</strong>；与之相反，如果<strong>基类的虚函数允许抛出异常</strong>，则<strong>派生类</strong>的对应函数<strong>既可以允许</strong>抛出异常，<strong>也可以不允许</strong>抛出异常</p>
<p>当编译器<strong>合成拷贝控制成员</strong>时，同时也<strong>生成一个异常说明</strong>。如果对<strong>所有成员</strong>和<strong>基类的所有操作</strong>都承诺了<strong>不会抛出异常</strong>，则<strong>合成的成员是 noexcept</strong> 的。如果合成成员调用的<strong>任意一个函数可能抛出异常</strong>，则合成的成员是<strong>noexcept ( false )</strong>。而且，如果我们定义了一个<strong>析构函数</strong>但是<strong>没有为它提供异常说明</strong>，则<strong>编译器将合成一个</strong>。合成的异常说明将与假设由编译器为类合成析构函数时所得的异常说明一致。</p>
<p>习题18.8<br>
noexcep异常说明可以用来指定某个函数不会抛出异常（C++11新特性），声明和定义时皆需要出现在函数之后，但在final、override、=0之前</p>
<p>18.1.5异常类层次</p>
<p><strong>类型 exception</strong> 仅仅定义了<strong>拷贝构造函数、拷贝赋值运算符、一个虚析构函数和一个名为 what 的虚成员</strong>其中 what 函数返回一个<code>const char *</code>,该指针指向一个以null结尾的字符数组，并且确保不会抛出任何异常。<br>
类exception、bad_cast和bad_alloc定义了默认构造函数。类runtime_error和logic_error没有默认构造函数，但是有一个可以接受C风格字符串或者标准库string类型实参的构造函数，这些实参负责提供关于错误的更多信息。<br>
由上可知，我们的面向应用的异常类继承自标准异常类。和其他继承体系一样，异常类也可以看作按照层次关系组织的。<strong>层次越低.表示的异常情况就越特殊</strong>。例如，在异常类继承体系中位于最顶层的通常是 exception , exception 表示的含义是某处出错了，至于错误的细节则未作描述。<br>
继承体系的第二层将 exception 划分为两个大的类别：<strong>运行时错误</strong>和<strong>逻辑错误</strong>。运行时错误表示的是<strong>只有在程序运行时才能检测到的错误</strong>；而逻辑错误一般指的是我们可以<strong>在程序代码中发现的错误</strong>。<br>
实际的应用程序通常会自定义exception（或者exception的标准库派⽣类）的派⽣类以扩展其继承体系。这些⾯向应⽤的异常类表示了与应⽤相关的异常条件<br>
我们使用自定义异常类的方式与使用标准异常类的方式完全一样。程序在某处抛出异常类型的对象，在另外的地方捕获并处理这些出现的问题。</p>
<p>习题18.9</p>
<pre><code>class out_of_stock :public std::runtime_error {
public:
	explicit out_of_stock(const std::string &amp;s) :std::runtime_error(s) {}
};

class isbn_mismatch :public std::logic_error {
public:
	explicit isbn_mismatch(const std::string &amp;s): std::logic_error(s){}
	isbn_mismatch(const std::string &amp;s, const std::string &amp;lhs, const std::string &amp;rhs) :std::logic_error(s), left(lhs), right(rhs) {}
	const std::string left, right;
};
Sales_Data&amp; Sales_Data::operator+=(const Sales_Data&amp; rhs) {
	if (isbn() != rhs.isbn())
		throw isbn_mismatch(&quot;wrong isbns&quot;, isbn(), rhs.isbn());
	units_sold += rhs.units_sold;
	ave += rhs.ave;
	return *this;
}
</code></pre>
<p>习题18.10<br>
自己定义的异常类型和标准库的异常类处理方式完全一样，一处抛出一处捕获<br>
主要差异在于自己定义的可以添加说明string 更加清晰，容易定位错误<br>
习题18.11<br>
what 函数返回一个<code>const char *</code>，该指针指向一个以null结尾的字符数组，并且确保不会抛出任何异常。<br>
<strong>noexcept 可以用在两种情况下</strong>：一是我们<strong>确认函数不会抛出异常</strong>，二是我们<strong>根本不知道该如何处理异常</strong>。<br>
what其实两种情况都有，一是不可能发生异常，而是如果发生了异常也无法处理，一旦处理反而会导致递归调用自身。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 108. 将有序数组转换为二叉搜索树[简单]]]></title>
        <id>https://lixin-ee.github.io//post/shu-108-jiang-you-xu-shu-zu-zhuan-huan-wei-er-cha-sou-suo-shu-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/shu-108-jiang-you-xu-shu-zu-zhuan-huan-wei-er-cha-sou-suo-shu-jian-dan">
        </link>
        <updated>2019-11-27T01:50:52.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。<br>
本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。<br>
示例:<br>
给定有序数组: [-10,-3,0,5,9],<br>
一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：<br>
0<br>
/ <br>
-3   9<br>
/   /<br>
-10  5<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>108</p>
<pre><code>class Solution {
public:
    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) {
        if(nums.empty())
            return NULL;
        TreeNode *root=new TreeNode(0);
        genTree(root,0,nums.size()-1,nums);
        return root;
    }
    
    void genTree(TreeNode *cur,int beg,int end,vector&lt;int&gt;&amp; nums){
        if(beg==end){
            cur-&gt;val=nums[beg];
            cur-&gt;left==NULL;
            cur-&gt;right==NULL;
            return;
        }
        int mid=(end-beg+1)/2+beg;
        cur-&gt;val=nums[mid];
        if(mid&gt;beg){
            //TreeNode *left=new TreeNode(0);
            //cur-&gt;left=left;
            cur-&gt;left=new TreeNode(0);
            genTree(cur-&gt;left,beg,mid-1,nums);
        }else
        {
            cur-&gt;left=NULL;
            return;
        }
        
        if(mid&lt;end){
            cur-&gt;right=new TreeNode(0);
            genTree(cur-&gt;right,mid+1,end,nums);
        }else
        {
            cur-&gt;right=NULL;
            return;
        }
        return;            
    }
};
</code></pre>
<p>//似曾相识，回去翻看了一下发现不是在大话数据结构或者算法，而是在算法导论<br>
//果然开卷有益，看到第一幅图就有思路了，发现重点在于高度平衡，这意味着高度不能超过log2（n）<br>
//然后联想到二分查找法，它的时间复杂度也是log2（n）<br>
//所以当前节点应该为数组的中间值，哪到底是取ceil还是floor呢？示例中是取了ceil<br>
//然后就发现自己坑了自己，一直输出不对，调试了才发现ceil是多此一举了。。。因为beg和end本来就是int啊。。。。自动向下取整问你怕不怕<br>
//所以之前那么多人用复杂得多的mid=(end-beg+1)/2+beg;还是有原因的<br>
//cur-&gt;val<mark>nums[beg];<br>
//日常哈皮把=写成</mark>，还巨难发现<br>
//又忘了空树的情况了。。。面向测试用例编程，哭唧唧</p>
<p>然后来看一下网友题解<br>
首先是简洁的代码</p>
<pre><code>class Solution {
public:
    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) {
        if(nums.empty()) return nullptr;
        return helper(nums,0,nums.size()-1);
    }

    TreeNode* helper(vector&lt;int&gt;&amp; nums, int left, int right){
        if(left &gt; right)
            return nullptr;
        int mid = (left+ right) /2;
        TreeNode *root = new TreeNode(nums[mid]);
        root-&gt;left = helper(nums, left,mid -1);
        root-&gt;right = helper(nums,mid+1, right);
        return root;
    }
};
</code></pre>
<p>然后是解释和多种解法：</p>
<blockquote>
<p>解法一 递归<br>
如果做了 98 题 和 99 题，那么又看到这里的升序数组，然后应该会想到一个点，二叉搜索树的中序遍历刚好可以输出一个升序数组。<br>
所以题目给出的升序数组就是二叉搜索树的中序遍历。<br>
根据中序遍历还原一颗树，又想到了 105 题 和 106 题，通过中序遍历加前序遍历或者中序遍历加后序遍历来还原一棵树。前序（后序）遍历的作用呢？提供根节点！然后根据根节点，就可以递归的生成左右子树。<br>
这里的话怎么知道根节点呢？平衡二叉树，既然要做到平衡，我们只要把根节点选为数组的中点即可。<br>
综上，和之前一样，找到了根节点，然后把数组一分为二，进入递归即可。注意这里的边界情况，包括左边界，不包括右边界。</p>
</blockquote>
<pre><code>public TreeNode sortedArrayToBST(int[] nums) {
    return sortedArrayToBST(nums, 0, nums.length);
}

private TreeNode sortedArrayToBST(int[] nums, int start, int end) {
    if (start == end) {
        return null;
    }
    int mid = (start + end) &gt;&gt;&gt; 1;
    TreeNode root = new TreeNode(nums[mid]);
    root.left = sortedArrayToBST(nums, start, mid);
    root.right = sortedArrayToBST(nums, mid + 1, end);

    return root;
}
</code></pre>
<blockquote>
<p>解法二 栈 DFS<br>
递归都可以转为迭代的形式。<br>
一部分递归算法，可以转成动态规划，实现空间换时间，例如 5题，10题，53题，72题，从自顶向下再向顶改为了自底向上。<br>
一部分递归算法，只是可以用栈去模仿递归的过程，对于时间或空间的复杂度没有任何好处，比如这道题，唯一好处可能就是能让我们更清楚的了解递归的过程吧。<br>
自己之前对于这种完全模仿递归思路写成迭代，一直也没写过，今天也就试试吧。<br>
思路的话，我们本质上就是在模拟递归，递归其实就是压栈出栈的过程，我们需要用一个栈去把递归的参数存起来。这里的话，就是函数的参数 start，end，以及内部定义的 root。为了方便，我们就定义一个类。</p>
</blockquote>
<pre><code>class MyTreeNode {
    TreeNode root;
    int start;
    int end 
    MyTreeNode(TreeNode r, int s, int e) {
        this.root = r;
        this.start = s;
        this.end = e;
    }
}
</code></pre>
<blockquote>
<p>第一步，我们把根节点存起来。</p>
</blockquote>
<pre><code>Stack&lt;MyTreeNode&gt; rootStack = new Stack&lt;&gt;();
int start = 0;
int end = nums.length;
int mid = (start + end) &gt;&gt;&gt; 1;
TreeNode root = new TreeNode(nums[mid]);
TreeNode curRoot = root;
rootStack.push(new MyTreeNode(root, start, end));
</code></pre>
<blockquote>
<p>然后开始递归的过程，就是不停的生成左子树。因为要生成左子树，end - start 表示当前树的可用数字的个数，因为根节点已经用去 1 个了，所以为了生成左子树，个数肯定需要大于 1。</p>
</blockquote>
<pre><code>while (end - start &gt; 1) {
    mid = (start + end) &gt;&gt;&gt; 1; //当前根节点
    end = mid;//左子树的结尾
    mid = (start + end) &gt;&gt;&gt; 1;//左子树的中点
    curRoot.left = new TreeNode(nums[mid]);
    curRoot = curRoot.left;
    rootStack.push(new MyTreeNode(curRoot, start, end));
}
</code></pre>
<blockquote>
<p>在递归中，返回 null 以后，开始生成右子树。这里的话，当 end - start &lt;= 1 ，也就是无法生成左子树了，我们就可以出栈，来生成右子树。</p>
</blockquote>
<pre><code>MyTreeNode myNode = rootStack.pop();
//当前作为根节点的 start end 以及 mid
start = myNode.start;
end = myNode.end;
mid = (start + end) &gt;&gt;&gt; 1;
start = mid + 1; //右子树的 start
curRoot = myNode.root; //当前根节点
if (start &lt; end) { //判断当前范围内是否有数
    mid = (start + end) &gt;&gt;&gt; 1; //右子树的 mid
    curRoot.right = new TreeNode(nums[mid]);
    curRoot = curRoot.right;
    rootStack.push(new MyTreeNode(curRoot, start, end));
}
</code></pre>
<blockquote>
<p>然后把上边几块内容组合起来就可以了。</p>
</blockquote>
<pre><code>class MyTreeNode {
    TreeNode root;
    int start;
    int end;

    MyTreeNode(TreeNode r, int s, int e) {
        this.root = r;
        this.start = s;
        this.end = e;
    }
}
public TreeNode sortedArrayToBST(int[] nums) {
    if (nums.length == 0) {
        return null;
    }
    Stack&lt;MyTreeNode&gt; rootStack = new Stack&lt;&gt;();
    int start = 0;
    int end = nums.length;
    int mid = (start + end) &gt;&gt;&gt; 1;
    TreeNode root = new TreeNode(nums[mid]);
    TreeNode curRoot = root;
    rootStack.push(new MyTreeNode(root, start, end));
    while (end - start &gt; 1 || !rootStack.isEmpty()) {
        //考虑左子树
        while (end - start &gt; 1) {
            mid = (start + end) &gt;&gt;&gt; 1; //当前根节点
            end = mid;//左子树的结尾
            mid = (start + end) &gt;&gt;&gt; 1;//左子树的中点
            curRoot.left = new TreeNode(nums[mid]);
            curRoot = curRoot.left;
            rootStack.push(new MyTreeNode(curRoot, start, end));
        }
        //出栈考虑右子树
        MyTreeNode myNode = rootStack.pop();
        //当前作为根节点的 start end 以及 mid
        start = myNode.start;
        end = myNode.end;
        mid = (start + end) &gt;&gt;&gt; 1;
        start = mid + 1; //右子树的 start
        curRoot = myNode.root; //当前根节点
        if (start &lt; end) { //判断当前范围内是否有数
            mid = (start + end) &gt;&gt;&gt; 1; //右子树的 mid
            curRoot.right = new TreeNode(nums[mid]);
            curRoot = curRoot.right;
            rootStack.push(new MyTreeNode(curRoot, start, end));
        }

    }

    return root;
}
</code></pre>
<blockquote>
<p>解法三 队列 BFS<br>
参考 这里。 和递归的思路基本一样，不停的划分范围。</p>
</blockquote>
<pre><code>class MyTreeNode {
    TreeNode root;
    int start;
    int end;

    MyTreeNode(TreeNode r, int s, int e) {
        this.root = r;
        this.start = s;
        this.end = e;
    }
}
public TreeNode sortedArrayToBST3(int[] nums) {
    if (nums.length == 0) {
        return null;
    }
    Queue&lt;MyTreeNode&gt; rootQueue = new LinkedList&lt;&gt;();
    TreeNode root = new TreeNode(0);
    rootQueue.offer(new MyTreeNode(root, 0, nums.length));
    while (!rootQueue.isEmpty()) {
        MyTreeNode myRoot = rootQueue.poll();
        int start = myRoot.start;
        int end = myRoot.end;
        int mid = (start + end) &gt;&gt;&gt; 1;
        TreeNode curRoot = myRoot.root;
        curRoot.val = nums[mid];
        if (start &lt; mid) {
            curRoot.left = new TreeNode(0);
            rootQueue.offer(new MyTreeNode(curRoot.left, start, mid));
        }
        if (mid + 1 &lt; end) {
            curRoot.right = new TreeNode(0);
            rootQueue.offer(new MyTreeNode(curRoot.right, mid + 1, end));
        }
    }

    return root;
}
</code></pre>
<blockquote>
<p>最巧妙的地方是它先生成 left 和 right 但不进行赋值，只是把范围传过去，然后出队的时候再进行赋值。这样最开始的根节点也无需单独考虑了。</p>
</blockquote>
<blockquote>
<p>扩展 求中点<br>
前几天和同学发现个有趣的事情，分享一下。<br>
首先假设我们的变量都是 int 值。<br>
二分查找中我们需要根据 start 和 end 求中点，正常情况下加起来除以 2 即可。<br>
int mid = (start + end) / 2<br>
但这样有一个缺点，我们知道int的最大值是 Integer.MAX_VALUE ，也就是2147483647。那么有一个问题，如果 start = 2147483645，end = = 2147483645，虽然 start 和 end都没有超出最大值，但是如果利用上边的公式，加起来的话就会造成溢出，从而导致mid计算错误。<br>
解决的一个方案就是利用数学上的技巧，我们可以加一个 start 再减一个 start 将公式变形。<br>
(start + end) / 2 = (start + end + start - start) / 2 = start + (end - start) / 2<br>
这样的话，就解决了上边的问题。<br>
然后当时和同学看到jdk源码中，求mid的方法如下<br>
int mid = (start + end) &gt;&gt;&gt; 1<br>
它通过移位实现了除以 2，但。。。这样难道不会导致溢出吗？<br>
首先大家可以补一下 补码 的知识。<br>
其实问题的关键就是这里了&gt;&gt;&gt; ，我们知道还有一种右移是&gt;&gt;。区别在于&gt;&gt;为有符号右移，右移以后最高位保持原来的最高位。而&gt;&gt;&gt;这个右移的话最高位补 0。<br>
所以这里其实利用到了整数的补码形式，最高位其实是符号位，所以当 start + end溢出的时候，其实本质上只是符号位收到了进位，而&gt;&gt;&gt;这个右移可以带着符号位右移，所以之前的信息没有丢掉。<br>
但&gt;&gt;有符号右移就会出现问题了，事实上 JDK6 之前都用的&gt;&gt;，这个 BUG 在 java 里竟然隐藏了十年之久。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第十七章 笔记+习题 17.5]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-qi-zhang-bi-ji-xi-ti-175</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-qi-zhang-bi-ji-xi-ti-175">
        </link>
        <updated>2019-11-26T12:45:18.000Z</updated>
        <content type="html"><![CDATA[<p>17.5 IO库再探<br>
17.5.1 格式化输入和输出<br>
除了条件状态外（参见8.1.2节，第279页），每个 iostream 对象还维护一个<strong>格式状态</strong>来控制 IO 如何格式化的细节。格式状态控制格式化的某些方面，如整型值是几进制、浮点值的精度、一个输出元素的宽度等。<br>
标准库定义了<strong>一组操纵符</strong>( manipulator )(参见1.2节，第6页）来<strong>修改流的格式状态</strong>，如表17.7和表17.8所示。一个操纵符是<strong>一个函数</strong>或是<strong>一个对象</strong>，会影响流的状态，并能用作输入或输出运算符的运算对象。类似输入和输出运算符，操纵符也<strong>返回它所处理的流对象</strong>，因此我们可以在一条语句中组合操纵符和数据。</p>
<p>操纵符用于<strong>两大类输出控制</strong>：控制<strong>数值的输出形式</strong>以及控制<strong>补白的数量和位置</strong>。大多数改变格式状态的操纵符都是<strong>设置/复原成对</strong>的;一个操纵符用来将格式状态设置为一个新值，而另一个用来将其复原，恢复为正常的默认格式。<br>
当操纵符改变流的格式化态时，通常改变后的状态对所有<strong>后续 IO 都生效。</strong></p>
<p>默认情况下，整型值的输入输出使用十进制。我们可以使用<strong>操纵符 hex 、 oct 和 dec</strong>将其改为<strong>十六进制、八进制或是改回十进制</strong>：<br>
注意，类似 boolalpha ,这些操纵符也会改变格式状态。它们会<strong>影响下一个和随后所有的整型输出</strong>，直至另一个操纵符又改变了格式为止。<br>
操纵符 hex 、 oct 和 dec 只影响整型运算对象，<strong>浮点值的表示形式不受影响</strong>。</p>
<p>如果需要打印八进制值或十六进制值，应该使用** showbase 操纵符**。当对流应用 showbase 操纵符时，<strong>会在输出结果中显示进制</strong>，它遵循与整型常量中指定进制相同的规范：<br>
•前导0x表示十六进制。<br>
•前导0表示八进制。<br>
•无前导字符串表示十进制。</p>
<p>操纵符 noshowbase 恢复 cout 的状态，从而不再显示整型值的进制。<br>
默认情况下，十六进制值会以小写打印，前导字符也是小写的 X 。 我们可以通过使用uppercase 操纵符来输出大写的 X 并将十六进制数字 a-f以大写输出：<br>
使用操纵符 nouppercase 、 noshowbase 和 dec 来重置流的状态。</p>
<p>•以多高精度（多少个数字）打印浮点值<br>
•数值是打印为十六进制、定点十进制还是科学记数法形式<br>
•对于没有小数部分的浮点值是否打印小数点<br>
<strong>默认情况下</strong>，<strong>浮点值</strong>按<strong>六位数字精度</strong>打印；如果浮点值<strong>没有小数部分，则不打印小数点</strong>：根据浮点数的<strong>值</strong>选择打印成<strong>定点十进制</strong>或<strong>科学记数法</strong>形式。标准库会选择一种可读性更好的格式：<strong>非常大和非常小</strong>的值打印<strong>为科学记数法</strong>形式，<strong>其他值</strong>打印为定点<strong>十进制</strong>形式。<br>
<strong>默认情况下</strong>，精度会<strong>控制打印的数字的总数</strong>。当打印时，浮点值按当前<strong>精度舍入</strong>而<strong>非截断</strong>。因此，如果当前精度为四位数字，则 3.14159将打印为3.142;如果精度为三位数字，则打印为3.14。</p>
<p>除非你需要控制浮点数的表示形式（如，按列打印数据或打印表示金额或百分比的数据），否则<strong>由标准库选择记数法是最好的方式</strong>。</p>
<p>默认情况下，当一个浮点值的小数部分为0时，不显示小数点。 showpoint 操纵符强制打印小数点：</p>
<p>当按列打印数据时，我们常常需要非常精细地控制数据格式。标准库提供了一些操纵符帮助我们完成所需的控制：</p>
<p>默认情况下，输入运算符会忽略空白符（空格符、制表符、换行符、换纸符和回车符)。<br>
操纵符 noskipws 会令输入运算符读取空白符，而不是跳过它们。为了恢复默认行为， 我们可以使用 skipws 操纵符</p>
<p>习题17.34</p>
<pre><code>int main() {
	cout &lt;&lt; noboolalpha &lt;&lt; true &lt;&lt; &quot; &quot; &lt;&lt; boolalpha &lt;&lt; true &lt;&lt; endl;
	cout &lt;&lt; hex &lt;&lt; 20 &lt;&lt;&quot; &quot;&lt;&lt; showbase &lt;&lt; 20 &lt;&lt; endl&lt;&lt;dec;
	cout &lt;&lt; 1.000000000000000 &lt;&lt;&quot; &quot;&lt;&lt; showpoint &lt;&lt; 1.00000000000000 &lt;&lt; endl;
	cout &lt;&lt; 1 &lt;&lt; &quot; &quot; &lt;&lt; showpos &lt;&lt;1 &lt;&lt; endl;

	cout &lt;&lt; setfill('#') &lt;&lt; &quot;i:&quot; &lt;&lt; setw(12) &lt;&lt; 16  &lt;&lt; endl ;
}
</code></pre>
<p>习题17.35</p>
<pre><code>int main() {
	cout &lt;&lt; hexfloat &lt;&lt;uppercase&lt;&lt; sqrt(2.0) &lt;&lt; endl;
}
</code></pre>
<p>习题17.36</p>
<pre><code>int main() {
	cout &lt;&lt; hexfloat &lt;&lt;uppercase&lt;&lt;internal&lt;&lt; sqrt(2.0) &lt;&lt; endl;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ C++ primer 第十六章 笔记+习题 16.5]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-liu-zhang-bi-ji-xi-ti-165</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-liu-zhang-bi-ji-xi-ti-165">
        </link>
        <updated>2019-11-26T08:45:31.000Z</updated>
        <content type="html"><![CDATA[<p>16.5 模板特例化<br>
<strong>当我们不能使用模板或者想制定特定的函数时就特例化，但其本质还是实例化</strong> 一个<strong>特例化版本</strong>就是模板的一个<strong>独立的定义</strong>，在<strong>其中一个或多个模板参数</strong>被指定为<strong>特定的类型</strong>。<br>
当我们特例化一个函数模板时，必须为原模板中的<strong>每个模板参数都提供实参</strong>。为了指出我们正在实例化一个模板，应使用<strong>关键字 template 后</strong>跟一个<strong>空尖括号对（&lt;&gt;）</strong>。空尖括号指出我们将为原模板的所有模板参数提供实参：</p>
<p>理解此特例化版本的困难之处是函数参数类型。当我们定义一个特例化版本时，函数参数类型必须与一个<strong>先前声明的模板中对应的类型匹配</strong>。本例中我们特例化：</p>
<p>当定义函数模板的特例化版本时，我们本质上接管了编译器的工作。即，我们为原模板的一个特殊实例提供了定义。重要的是要弄清：一个特例化版本本质上是一个实例，而非函数名的一个重载版本。<br>
特例化的<strong>本质是实例化一个模板</strong>，<strong>而非重载它</strong>。因此，特例化<strong>不影响函数匹配</strong><br>
我们将一个特殊的函数定义为一个<strong>特例化版本</strong>还是一个<strong>独立的非模板函数</strong>，会<strong>影响到函数匹配</strong>。</p>
<p>为了特例化一个模板，原模板的<strong>声明必须在作用域</strong>中。而且，在任何使用模板实例替代码之前，特例化版本的声明也必须在作用域中。<br>
对于普通类和函数，<strong>丢失声明的情况（通常）很容易发现</strong>——编译器将不能继续处理我们的代码。但是，如果丢失了一个特例化版本的声明，编译器通常可以用原模板生成代码。由于在丢失特例化版本时编译器通常会实例化原模板，很容易产生模板及其特例化版本声明顺序导致的错误，而这种错误又很难查找。<br>
如果一个程序使用一个特例化版本，而同时原模板的一个实例具有相同的模板实参集合，就会产生错误。但是，这种错误编译器又无法发现。<br>
<strong>模板</strong>及其<strong>特例化版本</strong>应该<strong>声明在同一个头文件中</strong>。所有<strong>同名模板的声明</strong>应该放在<strong>前面</strong>，<strong>然后是这些模板的特例化版本。</strong><br>
除了特例化函数模板，我们还可以<strong>特例化类模板</strong>。</p>
<p>在定义此特例化版本的 hash 时，唯一复杂的地方是：必须在<strong>原模板定义所在的命名空间中特例化它</strong>。</p>
<p>类似其他任何类，我们可以在<strong>类内或类外定义特例化版本的成员</strong>，本例中就是在类外定义的。重载的调用运算符必须为给定类型的值定义一个哈希函数。对于一个给定值，任何时候调用此函数都应该返回相同的结果。一个好的哈希函数对不相等的对象（几乎总是）应该产生不同的结果。<br>
假定我们的特例化版本在作用域中，当将 Sales _ data 作为容器的关键字类型时，<strong>编译器就会自动使用此特例化版本</strong>：<br>
为了使Sales_data 的用户能够使用hash 的特例化版本，我们应该在Sales_data 的<strong>头文件中定义该特例化版本</strong>。</p>
<p>与函数模板<strong>不同</strong>，<strong>类模板的特例化不必为所有模板参数提供实参</strong>。我们可以<strong>只指定一部分</strong>而非所有模板参数，或是参数的一部分而非全部特性。一个<strong>类模板</strong>的<strong>部分特例化</strong>(partial specialization )<strong>本身是一个模板</strong>，使用它时用户还必须为那些在特例化版本中未指定的模板参数提供实参<br>
我们<strong>只能部分特例化类模板，而不能部分特例化函数模板</strong>。</p>
<p>由于一个<strong>部分特例化版本本质是一个模板</strong>，与往常一样，我们首先定义模板参数。类似任何其他特例化版本，部分特例化版本的名字与原模板的名字相同。对每个未完全确定类型的模板参数，在特例化版本的模板参数列表中都有一项与之对应。在类名之后，我们为要特例化的模板参数指定实参，这些实参列于模板名之后的尖括号中。这些实参与原始模板中的参数按位置对应。<br>
部分特例化版本的模板参数列表是原始模板的参数列表的<strong>一个子集</strong>或者是<strong>一个特例化版本</strong>。<br>
我们<strong>可以只特例化特定成员函数</strong>而不是特例化整个模板。</p>
<p>习题16.62</p>
<pre><code>namespace std {
	template&lt;&gt;
	struct hash&lt;Sales_Data&gt;
	{
		typedef size_t result_type;
		typedef Sales_Data argument_type;
		size_t operator()(const Sales_Data &amp;s)const;
	};
	size_t hash&lt;Sales_Data&gt;::operator()(const Sales_Data &amp;s)const {
		return hash&lt;string&gt;()(s.ISBN) ^ hash&lt;unsigned&gt;()(s.units_sold) ^ hash&lt;double&gt;()(s.ave);

	}
}
</code></pre>
<p>习题16.63+16.64</p>
<pre><code>template &lt;typename T&gt;
int countv(vector&lt;T&gt; &amp;vt,T t) {
	int count=0;
	for (auto i : vt)
		if (i == t)
			++count;
	return count;
}
template&lt;&gt;
int countv(vector&lt;const char*&gt;&amp;vt, const char *t) {
	int count = 0;
	for (auto i : vt)
		if (i == t)
			++count;
	return count;
};
int main() {
	vector&lt;string&gt; vs{ &quot;123&quot;,&quot;456&quot;,&quot;789&quot;,&quot;123&quot; };
	vector&lt;int&gt; vi{ 1,2,3,4,5,1,2,3,1,2 };
	vector&lt;double&gt; vd{ 1.0,2.0,3.0,1.0 };
	cout &lt;&lt; countv(vs, string(&quot;123&quot;)) &lt;&lt; endl;
	cout &lt;&lt; countv(vi, 1) &lt;&lt; endl;
	cout &lt;&lt; countv(vd, 1.0) &lt;&lt; endl;
	vector&lt;const char*&gt; vc{ &quot;123&quot;,&quot;456&quot;,&quot;789&quot;,&quot;123&quot; };
	cout &lt;&lt; countv(vc, &quot;123&quot;) &lt;&lt; endl;
}
</code></pre>
<p>注意 	cout &lt;&lt; countv(vs, string(&quot;123&quot;)) &lt;&lt; endl;中 &quot;123&quot;属于<code>const char[]</code>，所以是无法直接和vs的string匹配的，必须用string来构造临时变量</p>
<p>习题16.65</p>
<pre><code>template&lt;&gt; string debug_rep(const char *p) {
	ostringstream ret;
	ret &lt;&lt; &quot;const char *p&quot;&lt;&lt;&quot; &quot;;
	ret &lt;&lt; &quot;pointer:&quot; &lt;&lt; p;
	if (p)
		ret &lt;&lt; &quot; &quot; &lt;&lt; *p;
	else
		ret &lt;&lt; &quot;null pointer&quot;;
	return ret.str();
}

template&lt;&gt; string debug_rep(char *p) {
	ostringstream ret;
	ret &lt;&lt; &quot;char *p&quot; &lt;&lt; &quot; &quot;;
	ret &lt;&lt; &quot;pointer:&quot; &lt;&lt; p;
	if (p)
		ret &lt;&lt; &quot; &quot; &lt;&lt; *p;
	else
		ret &lt;&lt; &quot;null pointer&quot;;
	return ret.str();
}
int main() {
	auto c = &quot;123&quot;;
	cout&lt;&lt;debug_rep(c)&lt;&lt;endl;
	char *cc = &quot;123&quot;;
	cout &lt;&lt; debug_rep(cc) &lt;&lt; endl;
}
</code></pre>
<p>注意：特例化的话本质上是模板的实例化，所以只需要模板的声明，而不需要模板的定义（注意区分模板的定义和实例化之间的区别）</p>
<p>习题16.66+16.67<br>
特例化能够保留原来的模板，保证较高的通用性，但是同时容易因为声明顺序或者代码错误出现调用了非目标的实例化函数。<br>
<strong>重载会改变匹配优先度，而特例化则不会</strong><br>
特例化的<strong>本质是实例化一个模板</strong>，<strong>而非重载它</strong>。因此，特例化<strong>不影响函数匹配</strong></p>
<p>习题感悟<br>
注意 	cout &lt;&lt; countv(vs, string(&quot;123&quot;)) &lt;&lt; endl;中 &quot;123&quot;属于<code>const char[]</code>，所以是无法直接和vs的string匹配的，必须用string来构造临时变量<br>
注意：特例化的话本质上是模板的实例化，所以只需要模板的声明，而不需要模板的定义（注意区分模板的定义和实例化之间的区别）<br>
特例化的<strong>本质是实例化一个模板</strong>，<strong>而非重载它</strong>。因此，特例化<strong>不影响函数匹配</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ C++ primer 第十六章 笔记+习题 16.4]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-liu-zhang-bi-ji-xi-ti-164</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-liu-zhang-bi-ji-xi-ti-164">
        </link>
        <updated>2019-11-26T01:39:00.000Z</updated>
        <content type="html"><![CDATA[<p>16.4可变参数模板<br>
一个可变参数模板(variadic template)就是一个<strong>接受可变数目参数</strong>的模板函数或模板类。可变数目的参数被称为<strong>参数包</strong>（parameterpacket)。存在两种参数包：模板参数包(template parameter packet),表示零个或多个模板参数；函数参数包（functionparameterpacket)，表示零个或多个函数参数。<br>
我们用一个<strong>省略号（一定必须是三个点，注意细节如何输入）</strong> 来指出一个模板参数或函数参数表示一个包，在一个模板参数列表中， <strong>class ...或 typename ...</strong> 指出接下来的参数表示零个或多个类型的列表：<br>
1.一个<strong>类型名后面跟一个省略号</strong>表示<strong>零个</strong>或多个给定类型的非类型参数的列表。<br>
2.在函数参数列表中，如果一个<strong>参数的类型</strong>是一个<strong>模板参数包</strong>，则此<strong>参数</strong>也是一个<strong>函数参数包</strong>。</p>
<p>声明了 foo 是一个可变参数函数模板，它有一个名为 T 的类型参数，和一个名为 Args的模板参数包。这个包表示零个或多个额外的类型参数。foo 的函数参数列表包含一个const &amp;类型的参数，指向 T 的类型，还包含一个名为 rest 的函数参数包，此包表示零个或多个函数参数。</p>
<p>当我们<strong>需要知道包中有多少元素</strong>时，可以使用** sizeof ...运算符**，sizeof ...也返回一个常量表达式<br>
cout&lt;&lt;sizeof…(Args)<br>
<strong>注意必须是在模板内部调用，而不是在函数外部调用</strong></p>
<p>习题16.51+52</p>
<pre><code>template&lt;typename T,typename... Args&gt;
void foo(const T &amp;t, const Args&amp;...rest) {
	cout&lt;&lt;sizeof...(Args)&lt;&lt;endl;
	cout &lt;&lt; sizeof...(rest) &lt;&lt; endl;
}
int main() {
	foo(123, &quot;123&quot;, 123, 123);
	foo(&quot;123&quot;, 123, &quot;12&quot;);
	foo(123,&quot;123&quot;);
	foo(&quot;12&quot;);
}
</code></pre>
<p>16.4.1 编写可变参数函数模板<br>
我们可以使用一个 <strong>initializer _ list</strong> 来定义一个可接受<strong>可变数目实参的函数</strong>。但是，所有实参<strong>必须具有相同的类型</strong>（或它们的类型可以转换为同一个公共类型）。当我们既不知道想要处理的实参的数目也不知道它们的类型时，可变参数函数是很有用的。<br>
可变参数函数<strong>通常是递归的</strong>（参见6.3.2节，第204页）。<strong>第一步调用处理</strong>包中的<strong>第一个实参</strong>，然后用<strong>剩余实参调用自身</strong>。我们的 <strong>print</strong>函数也是这样的模式，每次递归调用将<strong>第二个实参打印</strong>到<strong>第一个实参</strong>表示的<strong>流中</strong>。为了<strong>终止递归</strong>.我们还需要<strong>定义一个非可变参数</strong>的 print 函数，它接受一个流和一个对象</p>
<p>当定义可变参数版本的print时，<strong>非可变参数版本的声明必须在作用域中</strong>，否则，可变参数版本会<strong>无限递归</strong></p>
<p>习题16.53</p>
<pre><code>template &lt;typename T&gt; 
ostream &amp;print(ostream &amp;os, const T &amp;t) {
	return os &lt;&lt; t;
}
template&lt;typename T,typename...Args&gt;
ostream&amp; print(ostream &amp;os,T &amp;t, Args&amp;...rest) {
	os &lt;&lt; t&lt;&lt;&quot;,&quot;;
	return print(os, rest...);
}
</code></pre>
<p>注意 递归调用时需要用rest...来扩展可变参数列表作为实参<br>
习题16.54<br>
显示缺少&lt;&lt;定义<br>
习题16.55<br>
在可变参数版本眼中是看不到非可变参数版本的声明的，导致陷入无限调用自身递归，最后内存耗尽</p>
<p>16.4.2 包扩展<br>
对于一个参数包，<strong>除了获取其大小</strong>外，我们能对它做的<strong>唯一</strong>的事情就是<strong>扩展 （expand)<strong>它。当扩展一个包时，我们还要提供用于每个扩展元素的模式 （pattern )。 扩展一个包就是将它</strong>分解为构成的元素</strong>，对每个元素应用模式，获得扩展后的列表。我们通过<strong>在模式右边放一个省略号（...）来触发扩展操作。</strong></p>
<p>对 Args 的扩展中，编译器将模式 constArg &amp;应用到模板参数包 Args 中的每个元素。此，此模式的扩展结果是一个逗号分隔的零个或多个类型的列表，每个类型都形如const type&amp;<br>
第二个扩展发生在对 print 的（递归）调用中。在此情况下，模式是函数参数包的名字（即 rest )。此模式扩展出一个由包中元素组成的、逗号分隔的列表。</p>
<p>print 中的函数包扩展仅仅将包扩展为其构成元素， C ++语言还允许更复杂的扩展模式。例如，我们可以编写第二个可变参数函数，<strong>对其每个实参调用 debug_rep</strong> (参见16.3节，第615页），然后调用 print 打印结果 string</p>
<p><strong>注意符号的位置 是debug_rep(rest)…而不是debug_rep(rest…)，后者等于在debug_rep的形参中扩展了rest<br>
<strong>此模式表示我们希望对函数参数包 rest 中的</strong>每个元素</strong>调用 debug_rep</p>
<p>扩展中的模式会独立地应用于包中的每个元素。</p>
<p>习题16.56</p>
<pre><code>ostream &amp;errorMsg(ostream &amp;os, const Args&amp;...rest) {
	return print(os, debug_rep(rest)...);
}
</code></pre>
<p>习题16.57<br>
参数列表版本的只能定义同一类型的形参，可变参数列表的可以多种类型<br>
使用参数初始化列表initializer list也可以定义一个可接受可变参数数目的函数，但是所有的实参都必须具有相同的类型（或者可转变为相同的类型）</p>
<p>16.4.3 转发参数包<br>
<strong>保持类型信息</strong>是一个<strong>两阶段</strong>的过程。<strong>首先</strong>，为了保持实参中的类型信息，必须将 emplace_back 的函数参数<strong>定义为</strong>模板类型参数的<strong>右值引用</strong>（參见16.2.7节，第613页）：</p>
<p><strong>其次</strong>，当 emplace _ back 将这些实参传递给 construct 时，我们<strong>必须使用 forward</strong>来保持<strong>实参的原始类型</strong>（参见16.2.7节，第614页）；</p>
<p>习题16.58</p>
<pre><code>template&lt;class...Args&gt;
inline void StrVec::emplace_back(Args&amp;&amp;... args) {
	chk_n_alloc();
	alloc.construct(first_free++, std::forward&lt;Args&gt;args...);
}
</code></pre>
<p>习题16.59<br>
s作为参数被转发<br>
习题16.60<br>
接受可变参数模板，转发其参数初始化一个内存于内存空间，返回一个shared_ptr<br>
习题16.61<br>
其实和emplace比较像啦，接受可变参数目标然后new新的对象返回shared_ptr</p>
<p>习题感悟：<br>
注意 递归调用时需要用rest...来扩展可变参数列表作为实参</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 236. 二叉树的最近公共祖先[中等]]]></title>
        <id>https://lixin-ee.github.io//post/shu-236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/shu-236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-zhong-deng">
        </link>
        <updated>2019-11-26T01:06:37.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。<br>
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”<br>
例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]<br>
示例 1:<br>
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>
输出: 3<br>
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。<br>
示例 2:<br>
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br>
输出: 5<br>
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。<br>
说明:<br>
所有节点的值都是唯一的。<br>
p、q 为不同节点且均存在于给定的二叉树中。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>谁能想到我刚在235题惋惜自己把简单的问题复杂化了，欣慰自己写了个通用模板的时候，下一题马上就用上了这个通用模板<br>
世事无常啊hhh</p>
<pre><code>class Solution {
public:
    bool get=false;
    TreeNode *res=NULL;
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        preorder(root,p,q);
        return res;
    }
    
    bool preorder(TreeNode* cur,TreeNode* p, TreeNode* q){
        if(cur==NULL)
            return false;
        if(get)
            return false;
        bool l=preorder(cur-&gt;left,p,q);
        bool r=preorder(cur-&gt;right,p,q);
        if(!get&amp;&amp;l&amp;&amp;r){
            get=true;
            res=cur;
            return false;
        }
        if(!get&amp;&amp;(l||r)&amp;&amp;(cur==p||cur==q)){
            get=true;
            res=cur;
            return false;
        }
        return (cur==p||cur==q)||l||r;  
    }
};
</code></pre>
<p>先看网友题解：</p>
<blockquote>
<p>在左、右子树中分别查找是否包含p或q：<br>
如果以下两种情况（左子树包含p，右子树包含q/左子树包含q，右子树包含p），那么此时的根节点就是最近公共祖先<br>
如果左子树包含p和q，那么到root-&gt;left中继续查找，最近公共祖先在左子树里面<br>
如果右子树包含p和q，那么到root-&gt;right中继续查找，最近公共祖先在右子树里面</p>
</blockquote>
<pre><code>TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == nullptr || root == p || root == q){return root; }
        TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);
        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);
        return left == nullptr? right : (right == nullptr? left : root); 
   }
</code></pre>
<p>官方题解：</p>
<blockquote>
<p>解决方法：<br>
首先在二叉树中搜索给定的节点 p 和 q，然后找到它们的最近共同祖先。我们可以使用普通的树遍历来搜索这两个节点。一旦我们达到所需的节点 p 和 q，我们就可以回溯并找到最近的共同祖先。<br>
方法一：递归<br>
这种方法非常直观。先深度遍历改树。当你遇到节点 p 或 q 时，返回一些布尔标记。该标志有助于确定是否在任何路径中找到了所需的节点。最不常见的祖先将是两个子树递归都返回真标志的节点。它也可以是一个节点，它本身是p或q中的一个，对于这个节点,子树递归返回一个真标志<br>
让我们看看基于这个想法的形式算法。<br>
算法：<br>
从根节点开始遍历树。<br>
如果当前节点本身是 p 或 q 中的一个，我们会将变量 mid 标记为 true，并继续搜索左右分支中的另一个节点。<br>
如果左分支或右分支中的任何一个返回 true，则表示在下面找到了两个节点中的一个。<br>
如果在遍历的任何点上，左、右或中三个标志中的任意两个变为 true，这意味着我们找到了节点 p 和 q 的最近公共祖先。<br>
让我们看一个示例，然后搜索树中两个节点 9 和 11 的最近公共祖先。<br>
以下是递归中遵循的节点序列：<br>
1 --&gt; 2 --&gt; 4 --&gt; 8<br>
回溯 8 --&gt; 4<br>
4 --&gt; 9 (找到一个节点，返回true)<br>
回溯 9 --&gt; 4 --&gt; 2<br>
2 --&gt; 5 --&gt; 10<br>
回溯 10 --&gt; 5<br>
5 --&gt; 11 (找到另一个节点，返回true)<br>
回溯 --&gt; 5 --&gt; 2<br>
在2节点这里我们有左边=true，右边=true，因此 2 节点是它们的最近公共祖先</p>
</blockquote>
<pre><code>class Solution {

    private TreeNode ans;

    public Solution() {
        // Variable to store LCA node.
        this.ans = null;
    }

    private boolean recurseTree(TreeNode currentNode, TreeNode p, TreeNode q) {

        // If reached the end of a branch, return false.
        if (currentNode == null) {
            return false;
        }

        // Left Recursion. If left recursion returns true, set left = 1 else 0
        int left = this.recurseTree(currentNode.left, p, q) ? 1 : 0;

        // Right Recursion
        int right = this.recurseTree(currentNode.right, p, q) ? 1 : 0;

        // If the current node is one of p or q
        int mid = (currentNode == p || currentNode == q) ? 1 : 0;


        // If any two of the flags left, right or mid become True
        if (mid + left + right &gt;= 2) {
            this.ans = currentNode;
        }

        // Return true if any one of the three bool values is True.
        return (mid + left + right &gt; 0);
    }

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // Traverse the tree
        this.recurseTree(root, p, q);
        return this.ans;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(N)，N 是二叉树中的节点数，最坏情况下，我们需要访问二叉树的所有节点。<br>
空间复杂度：O(N)，这是因为递归堆栈使用的最大空间位 N,斜二叉树的高度可以是 N。</p>
</blockquote>
<blockquote>
<p>方法二：使用父指针迭代<br>
如果每个节点都有父指针，那么我们可以从 p 和 q 返回以获取它们的祖先。在这个遍历过程中，我们得到的第一个公共节点是 LCA 节点。我们可以在遍历树时将父指针保存在字典中。<br>
算法：<br>
从根节点开始遍历树。<br>
在找到 p 和 q 之前，将父指针存储在字典中。<br>
一旦我们找到了 p 和 q，我们就可以使用父亲字典获得 p 的所有祖先，并添加到一个称为祖先的集合中。<br>
同样，我们遍历节点 q 的祖先。如果祖先存在于为 p 设置的祖先中，这意味着这是 p 和 q 之间的第一个共同祖先（同时向上遍历），因此这是 LCA 节点。</p>
</blockquote>
<pre><code>class Solution {

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {

        // Stack for tree traversal
        Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;();

        // HashMap for parent pointers
        Map&lt;TreeNode, TreeNode&gt; parent = new HashMap&lt;&gt;();

        parent.put(root, null);
        stack.push(root);

        // Iterate until we find both the nodes p and q
        while (!parent.containsKey(p) || !parent.containsKey(q)) {

            TreeNode node = stack.pop();

            // While traversing the tree, keep saving the parent pointers.
            if (node.left != null) {
                parent.put(node.left, node);
                stack.push(node.left);
            }
            if (node.right != null) {
                parent.put(node.right, node);
                stack.push(node.right);
            }
        }

        // Ancestors set() for node p.
        Set&lt;TreeNode&gt; ancestors = new HashSet&lt;&gt;();

        // Process all ancestors for node p using parent pointers.
        while (p != null) {
            ancestors.add(p);
            p = parent.get(p);
        }

        // The first ancestor of q which appears in
        // p's ancestor set() is their lowest common ancestor.
        while (!ancestors.contains(q))
            q = parent.get(q);
        return q;
    }

}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(N),其中 NN 是二进制树中的节点数。在最坏的情况下，我们可能会访问二叉树的所有节点。<br>
空间复杂度：O(N),在堆栈使用的最坏情况下，每个节点的父指针字典和祖先集的空间为 N，斜二叉树的高度可能为 N。</p>
</blockquote>
<blockquote>
<p>方法三：无父指针的迭代<br>
在前面的方法中，我们在回溯过程中遇到 LCA。我们可以摆脱回溯过程本身。在这种方法中，我们总是有一个指向可能 LCA 的指针，当我们找到两个节点时，我们返回指针作为答案。<br>
算法：<br>
从根节点开始。<br>
将 (root, root_state) 放在堆栈上。root_state 定义要遍历该节点的一个子节点还是两个子节点。<br>
当堆栈不为空时，查看堆栈的顶部元素，该元素表示为 (parent_node, parent_state)。<br>
在遍历 parent_node 的任何子节点之前，我们检查 parent_node 本身是否是 p 或 q 中的一个。<br>
当我们第一次找到 p 或 q 的时候，设置一个布尔标记，名为 one_node_found 为 true 。还可以通过在变量 LCA_index 中记录堆栈的顶部索引来跟踪最近的公共祖先。因为堆栈的所有当前元素都是我们刚刚发现的节点的祖先。<br>
第二次 parent_node == p or parent_node == q 意味着我们找到了两个节点，我们可以返回 LCA node。<br>
每当我们访问 parent_node 的子节点时，我们将 (parent_node, updated_parent_state) 推到堆栈上。我们更新父级的状态为子级/分支已被访问/处理，并且相应地更改状态。<br>
当状态变为 BOTH_DONE 时，最终会从堆栈中弹出一个节点，这意味着左、右子树都被推到堆栈上并进行处理。如果 one_node_found 是 true 的，那么我们需要检查被弹出的顶部节点是否可能是找到的节点的祖先之一。在这种情况下，我们需要将LCA_index减少一个。因为其中一位祖先被弹出了。<br>
当同时找到 p 和 q 时，LCA_index 将指向堆栈中包含 p 和 q 之间所有公共祖先的索引。并且 LCA_index 元素具有p和q之间的最近公共祖先。<br>
上面的动画演示了如何使用堆栈遍历二叉树并跟踪节点 p 和 q 之间的公共祖先。</p>
</blockquote>
<pre><code>import javafx.util.*;

class Solution {

    // Three static flags to keep track of post-order traversal.

    // Both left and right traversal pending for a node.
    // Indicates the nodes children are yet to be traversed.
    private static int BOTH_PENDING = 2;

    // Left traversal done.
    private static int LEFT_DONE = 1;

    // Both left and right traversal done for a node.
    // Indicates the node can be popped off the stack.
    private static int BOTH_DONE = 0;

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {

        Stack&lt;Pair&lt;TreeNode, Integer&gt;&gt; stack = new Stack&lt;Pair&lt;TreeNode, Integer&gt;&gt;();

        // Initialize the stack with the root node.
        stack.push(new Pair&lt;TreeNode, Integer&gt;(root, Solution.BOTH_PENDING));

        // This flag is set when either one of p or q is found.
        boolean one_node_found = false;

        // This is used to keep track of the LCA.
        TreeNode LCA = null;

        // Child node
        TreeNode child_node = null;

        // We do a post order traversal of the binary tree using stack
        while (!stack.isEmpty()) {

            Pair&lt;TreeNode, Integer&gt; top = stack.peek();
            TreeNode parent_node = top.getKey();
            int parent_state = top.getValue();

            // If the parent_state is not equal to BOTH_DONE,
            // this means the parent_node can't be popped off yet.
            if (parent_state != Solution.BOTH_DONE) {

                // If both child traversals are pending
                if (parent_state == Solution.BOTH_PENDING) {

                    // Check if the current parent_node is either p or q.
                    if (parent_node == p || parent_node == q) {

                        // If one_node_found was set already, this means we have found
                        // both the nodes.
                        if (one_node_found) {
                            return LCA;
                        } else {
                            // Otherwise, set one_node_found to True,
                            // to mark one of p and q is found.
                            one_node_found = true;

                            // Save the current top element of stack as the LCA.
                            LCA = stack.peek().getKey();
                        }
                    }

                    // If both pending, traverse the left child first
                    child_node = parent_node.left;
                } else {
                    // traverse right child
                    child_node = parent_node.right;
                }

                // Update the node state at the top of the stack
                // Since we have visited one more child.
                stack.pop();
                stack.push(new Pair&lt;TreeNode, Integer&gt;(parent_node, parent_state - 1));

                // Add the child node to the stack for traversal.
                if (child_node != null) {
                    stack.push(new Pair&lt;TreeNode, Integer&gt;(child_node, Solution.BOTH_PENDING));
                }
            } else {

                // If the parent_state of the node is both done,
                // the top node could be popped off the stack.
                // Update the LCA node to be the next top node.
                if (LCA == stack.pop().getKey() &amp;&amp; one_node_found) {
                    LCA = stack.peek().getKey();
                }

            }
        }

        return null;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(N)，其中 N 是二叉树中的节点数。在最坏的情况下，我们可能会访问二叉树的所有节点。这种方法的优点是可以减少回溯。只要找到两个节点，我们就返回。<br>
空间复杂度：O(N)，在最坏的情况下，堆栈使用的空间是 N 且斜二叉树的高度可能是 N。</p>
</blockquote>
<p>注意复习一下迭代法啊！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ primer 第十六章 笔记+习题 16.3]]></title>
        <id>https://lixin-ee.github.io//post/c-primer-di-shi-liu-zhang-bi-ji-xi-ti-163</id>
        <link href="https://lixin-ee.github.io//post/c-primer-di-shi-liu-zhang-bi-ji-xi-ti-163">
        </link>
        <updated>2019-11-25T12:32:21.000Z</updated>
        <content type="html"><![CDATA[<p>16.3重载与模板<br>
函数模板可以被<strong>另一个模板</strong>或一个<strong>普通非模板函数</strong>重载。与往常一样，名字相同的函数必须具有<strong>不同数量或类型</strong>的<strong>参数</strong>。<br>
•对于一个调用，其候选函数包括所有模板实参推断（参见16.2节，第600页）成功的函数模板实例。<br>
•候选的函数模板<strong>总是可行的</strong>，因为模板实参推断会排除任何不可行的模板。<br>
•与往常一样，可行函数（模板与非模板）按<strong>类型转换</strong>（如果对此调用需要的话）来排序。当然，可以用于函数模板调用的类型转换是非常有限的（参见16.2.1节，第601页）。（1.顶层const转换 2.数组指针和函数指针）<br>
•与往常一样，如果恰有一个函数提供比任何其他函数都更好的匹配，则选择此函数。但是.如果有多个函数提供<strong>同样好的匹配</strong>，则：<br>
—如果同样好的函数中<strong>只有一个</strong>是<strong>非模板函数</strong>，则选择此函数。<br>
—如果同样好的函数中<strong>没有非模板函数</strong>，而有多个函数模板，且其中一个模板比其他模板更有<strong>特例化</strong>，则选择此模板。<br>
—否则，此调用有歧义。<br>
特例化：指更不通用</p>
<p>第一个版本的debug_rep：debug_rep(const T&amp;) 第二个版本的<code>debug_rep(T *)</code><br>
当有多个重载模板对一个调用提供同样好的匹配时，应选择<strong>最特例化（最特殊）的版本</strong>。<br>
对于一个调用，如果一个<strong>非函数模板</strong>与一个<strong>函数模板</strong>提供<strong>同样好的匹配</strong>，则<strong>选择非模板化本</strong><br>
注意<code>const char*</code>和<code>const char[10]</code>的区别<br>
非模板版本是可行的，但需要进行一次<strong>用户定义</strong>的类型转换，因此它<strong>没有精确匹配</strong>那么好，所以两个模板成为可能调用的函数。与之前一样， T *版本更加特例化，编译器会选择它。</p>
<p><strong>通常</strong>，如果<strong>使用</strong>了一个<strong>忘记声明的函数</strong>，代码将<strong>编译失败</strong>。<strong>但对于重载函数模板</strong>的函数而言，则<strong>不是这样</strong>。如果编译器可以<strong>从模板实例化出与调用匹配的版本（实例化一个并非你所需的版本）</strong>，则缺少的声明就不重要了。<br>
在<strong>定义任何函数之前</strong>，<strong>记得声明所有重载的函数版本</strong>。这样就不必担心编译器.由于未遇到你希望调用的函数而<strong>实例化一个并非你所需的版本</strong>。</p>
<p>习题16.48</p>
<pre><code>template &lt;typename T&gt; string debug_rep(T *p) {
	ostringstream ret;
	ret &lt;&lt; &quot;pointer:&quot; &lt;&lt; p;
	if (p)
		ret &lt;&lt; &quot; &quot; &lt;&lt; debug_rep(*p);
	else
		ret &lt;&lt; &quot;null pointer&quot;;
	return ret.str();		 
}

template &lt;typename T&gt; string debug(const T &amp;t) {
	ostringstream ret;
	ret &lt;&lt; t;
	return ret.str();
}
</code></pre>
<p>习题16.49<br>
(a)第一个T变成int 第二个T无法匹配 选择第一个<br>
(b)第一个T变成int * 第二个T变成int 第二个更特例化 选择第二个<br>
(c)第一个T变为int，第二个无法匹配，选择第一个<br>
(d)第一个T变成const int* 第二个变成const int，第二个更特例化 选择第二个<br>
(e)第一个T变成int 第二个T无法匹配 选择第一个<br>
(f)第一个变成int* 第二个变成int 第一个更准确 选择第一个<br>
(g)第一个T变成int，第二个无法匹配 选第一个<br>
(h)第一个T变成const int* 第二个变成int 第二个更特例化 选第二个<br>
习题16.50<br>
结果为1 2 1 2 1 1 1 2 （居然全对了hhh）</p>
]]></content>
    </entry>
</feed>