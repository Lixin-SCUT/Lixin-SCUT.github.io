<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-11-02T02:47:36.539Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[链表 83. 删除排序链表中的重复元素[简单]]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-83-shan-chu-pai-xu-lian-biao-zhong-de-chong-fu-yuan-su-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-83-shan-chu-pai-xu-lian-biao-zhong-de-chong-fu-yuan-su-jian-dan">
        </link>
        <updated>2019-11-02T01:43:41.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p>
<p>示例 1:<br>
输入: 1-&gt;1-&gt;2<br>
输出: 1-&gt;2<br>
示例 2:<br>
输入: 1-&gt;1-&gt;2-&gt;3-&gt;3<br>
输出: 1-&gt;2-&gt;3</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>想法<br>
(之前)hhh因为之前做数组的时候用过很6的快慢指针，所以也是用的快慢指针</p>
<pre><code>class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(head==NULL||head-&gt;next==NULL)
            return head;
        ListNode* fast=head;
        ListNode* slow=head;
        while(fast!=NULL&amp;&amp;fast-&gt;next!=NULL){
            while(fast!=NULL&amp;&amp;fast-&gt;val==slow-&gt;val)
                fast=fast-&gt;next;
            slow-&gt;next=fast;
            slow=fast;
        }
        return head;     
    }
};
</code></pre>
<p>（11.2）发现自己想复杂了，可以直接使用一个cur指针，判断下一个值是否和当前相等，相等的话就修改next指向的值。</p>
<p>然后来看下网友题解：<br>
解法1：双指针法</p>
<pre><code>class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(head==NULL||head-&gt;next==NULL)
            return head;
        ListNode* p=head;//慢指针
        ListNode* q=head-&gt;next;//快指针
        while(p-&gt;next!=NULL)
        {
            if(p-&gt;val==q-&gt;val)//找到重复元素
            {
                if(q-&gt;next==NULL)//快指针后面若没有元素直接剔除
                    p-&gt;next=NULL;
                else//快指针后有元素
                {
                    p-&gt;next=q-&gt;next;
                    q=q-&gt;next;
                }
            }
            else //元素不相等
            {
                p=p-&gt;next;
                q=q-&gt;next;
            }
        }
        return head;
    }
};
</code></pre>
<p>解法2：直接法（一个指针操作）</p>
<pre><code>class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(!head||!head-&gt;next)
            return head;
        ListNode* p=head;
        while(p-&gt;next!=NULL&amp;&amp;p!=NULL)
        {
            if(p-&gt;val == p-&gt;next-&gt;val)
            {
                p-&gt;next=p-&gt;next-&gt;next;
            }
            else 
                p=p-&gt;next;
        }
        return head;
    }
};
</code></pre>
<p>解法3：递归法</p>
<pre><code>class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(!head||!head-&gt;next)
            return head;
        head-&gt;next=deleteDuplicates(head-&gt;next);
        if(head-&gt;val==head-&gt;next-&gt;val) head=head-&gt;next;
        return head;
    }
};
</code></pre>
<blockquote>
<p>递归套路解决链表问题：<br>
找终止条件：当head指向链表只剩一个元素的时候，自然是不可能重复的，因此return<br>
想想应该返回什么值：应该返回的自然是已经去重的链表的头节点<br>
每一步要做什么：宏观上考虑，此时head.next已经指向一个去重的链表了，而根据第二步，我应该返回一个去重的链表的头节点。因此这一步应该做的是判断当前的head和head.next是否相等，如果相等则说明重了，返回head.next，否则返回head</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode链表测试daima ]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-ce-shi</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-ce-shi">
        </link>
        <updated>2019-11-01T14:35:47.000Z</updated>
        <content type="html"><![CDATA[<p>注意在C++里面ListNode已经是定义好的类了，不需要重复定义了。<br>
本代码主要是建立一个链表方便在playground中进行测试，但是注意输出其返回值的话不会像测试用例那样会输出整个链表。</p>
<pre><code>int main() {
    ListNode n5(5);
    ListNode n4(4);
    ListNode n3(3);
    ListNode n2(2);
    ListNode n1(1);
    ListNode *head=&amp;n1;
    n1.next=&amp;n2;
    n2.next=&amp;n3;
    n3.next=&amp;n4;
    n4.next=&amp;n5;
    cout&lt;&lt;swapPairs(head)-&gt;val&lt;&lt;endl;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 19. 删除链表的倒数第N个节点[中等]]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-19-shan-chu-lian-biao-de-dao-shu-di-n-ge-jie-dian-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-19-shan-chu-lian-biao-de-dao-shu-di-n-ge-jie-dian-zhong-deng">
        </link>
        <updated>2019-11-01T00:21:02.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
<p>示例：<br>
给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.<br>
当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.<br>
说明：<br>
给定的 n 保证是有效的。<br>
进阶：<br>
你能尝试使用一趟扫描实现吗？</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>思路<br>
如果需要一趟扫描的话，因为链表的长度是未知的，除非牺牲空间复杂度，否则是做不到一趟扫描的，所以必须使用递归，在递归函数中附上n和变量的引用用来记录逆向的计数<br>
最终代码如下</p>
<pre><code>class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        int loc=0;
        ListNode* ehead=new ListNode(0);
        ehead-&gt;next=head;
        delNth(ehead,loc,n);
        return ehead-&gt;next;
    }
    
    ListNode* delNth(ListNode* lb,int &amp;loc,int n){
        ListNode* pre;
        if(lb-&gt;next!=NULL)
            pre=delNth(lb-&gt;next,loc,n);
        
        if(loc==n){
            lb-&gt;next=pre-&gt;next;
        }
        ++loc;
        return lb;
        
    }
};
</code></pre>
<p>需要注意的就是传入loc的必须是引用，传入n最好设置为const</p>
<p>然后来看一下官方题解：</p>
<blockquote>
<p>摘要<br>
本文适用于初学者。它介绍了以下内容：链表的遍历和删除其末尾的第 n 个元素。<br>
方法一：两次遍历算法<br>
思路<br>
我们注意到这个问题可以容易地简化成另一个问题：删除从列表开头数起的第 (L - n + 1)个结点，其中 L 是列表的长度。只要我们找到列表的长度 L，这个问题就很容易解决。<br>
算法<br>
首先我们将添加一个哑结点作为辅助，该结点位于列表头部。哑结点用来简化某些极端情况，例如列表中只含有一个结点，或需要删除列表的头部。在第一次遍历中，我们找出列表的长度 L。然后设置一个指向哑结点的指针，并移动它遍历列表，直至它到达第 (L - n)个结点那里。我们把第 (L - n) 个结点的 next 指针重新链接至第 (L - n + 2)个结点，完成这个算法。</p>
</blockquote>
<pre><code>public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    int length  = 0;
    ListNode first = head;
    while (first != null) {
        length++;
        first = first.next;
    }
    length -= n;
    first = dummy;
    while (length &gt; 0) {
        length--;
        first = first.next;
    }
    first.next = first.next.next;
    return dummy.next;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(L)，该算法对列表进行了两次遍历，首先计算了列表的长度 L 其次找到第 (L - n) 个结点。 操作执行了 2L−n 步，时间复杂度为 O(L)。<br>
空间复杂度：O(1)，我们只用了常量级的额外空间。</p>
<p>方法二：一次遍历算法<br>
算法<br>
上述算法可以优化为只使用一次遍历。我们可以使用两个指针而不是一个指针。第一个指针从列表的开头向前移动 n+1 步，而第二个指针将从列表的开头出发。现在，这两个指针被 n 个结点分开。我们通过同时移动两个指针向前来保持这个恒定的间隔，直到第一个指针到达最后一个结点。此时第二个指针将指向从最后一个结点数起的第 n 个结点。我们重新链接第二个指针所引用的结点的 next 指针指向该结点的下下个结点。</p>
</blockquote>
<pre><code>public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode first = dummy;
    ListNode second = dummy;
    // Advances first pointer so that the gap between first and second is n nodes apart
    for (int i = 1; i &lt;= n + 1; i++) {
        first = first.next;
    }
    // Move first to the end, maintaining the gap
    while (first != null) {
        first = first.next;
        second = second.next;
    }
    second.next = second.next.next;
    return dummy.next;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(L)，该算法对含有 L 个结点的列表进行了一次遍历。因此时间复杂度为 O(L)。<br>
空间复杂度：O(1)，我们只用了常量级的额外空间。</p>
</blockquote>
<p>解法一的哑结点就是我设置的ehead（不愧是我！hhh），然而解法二很妙啊，巧妙地利用两个指针的距离，比我的递归更简洁。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 92. 反转链表 II[中等]]]></title>
        <id>https://lixin-ee.github.io//post/92-fan-zhuan-lian-biao-ii</id>
        <link href="https://lixin-ee.github.io//post/92-fan-zhuan-lian-biao-ii">
        </link>
        <updated>2019-10-31T01:17:18.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p>
<p>说明:<br>
1 ≤ m ≤ n ≤ 链表长度。<br>
示例:<br>
输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4<br>
输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/reverse-linked-list-ii<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>思路：<br>
使用三个ListNode指针变量 first 和pre、cur，first一直指向m的前一位，比如例子中的1，然后pre和cur配合将cur移动到first的位置，比如例子中迭代地把3和4 放到1后面的位置<br>
注意一定要加上一个虚链表头，防止m=1的情况<br>
最终代码</p>
<pre><code>class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int m, int n) {
        while(head==NULL&amp;&amp;head-&gt;next==NULL)
            return head;
        int count=0;
        ListNode* first;
        ListNode* cur;
        ListNode* pre;
        ListNode* ehead=new ListNode(0);
        ehead-&gt;next=head;
        cur=ehead;
        while(count&lt;=n){
            if(count&lt;m-1){
                ++count;
                cur=cur-&gt;next;
                continue;
            }
            if(count==m-1){
                first=cur;
                pre=first-&gt;next;
                cur=pre-&gt;next;
                count+=2;
                continue;
            }
            pre-&gt;next=cur-&gt;next;
            cur-&gt;next=first-&gt;next;
            first-&gt;next=cur;
            cur=pre-&gt;next;
            ++count;
        }
        return ehead-&gt;next;
    }
};
</code></pre>
<p>最高赞题解和我的一样，然后来看一下官方题解如何<br>
方法一: 递归<br>
直觉<br>
使用递归反转链表的思路来源于反转字符串时使用的类似方法。反转字符串的一个巨大优势是可以使用下标信息。我们可以创建两个指针，一个开头，一个结尾。不断地交换这两个指针指向的元素，并将两个指针向中间移动。在分析链表的情况前，先让我们看看字符串上的示例。<br>
<img src="https://lixin-ee.github.io//post-images/1572485555891.png" alt=""><br>
反转给定链表的一部分的思路基于上述方法。我们需要两个不同指针，一个指向第 mm 个结点，另一个指向第 nn 个结点。一旦有了这两个指针，我们就可以不断地交换这两个指针指向结点的数据，并将两个指针相向移动，就像字符串的情况那样。</p>
<p>然而，链表中没有向后指针，也没有下标。因此，我们需要使用递归来 模拟 向后指针。递归中的回溯可以帮助我们模拟一个指针从第nn个结点向中心移动的移动过程。</p>
<p>算法</p>
<p>我们定义一个递归函数用于反转给定链表的一部分。<br>
将函数记为 recurse。该函数使用三个参数: m 为反转的起点, n 为反转的终点, 以及从第 nn 个结点开始，随着递归回溯过程向后移动的指针 right。不清楚的话，可以参考后文的示意图。<br>
此外，我们还有一个指针 left，它从第 m 个结点开始向前移动。在 <code>P thon中, 我们需要一个全局变量，值随着递归的进行而改变。在其他函数调用造成的变化可以持续的编程语言中，可以考虑将该指针加为函数recurse</code> 的一个变量。<br>
在<br>
递归调用中，给定 m，n，和 right, 首先判断 n = 1。 若判断为真, 则结束。<br>
于是，当 n 的值达到 1 时，我们便回溯。这时，right 指针在我们要反转的子链表结尾，left 到达了字列表的开头。于是，我们置换数据，并将 left 指针前移：left = left.next。我们需要此变化在回溯过程中保持。<br>
自此，每当我们回溯时，right 指针向后移一位。这就是前文所说的模拟。通过回溯模拟向后移动。<br>
当 right == left 或者 right.next == left 时停止交换。当子链表的长度为奇数时，情况为前者；当子链表长度为偶数时为后者。我们使用一个全局 boolean 变量 flag 来停止交换。<br>
下面是一系列整个算法的示意图，希望能够帮助你理解清楚。<br>
<img src="https://lixin-ee.github.io//post-images/1572485670158.png" alt=""><br>
这是递归过程的第一步。给定所用链表，left 和 right 指针从链表的 head 开始。第一步是以更新过的 m 和 n 进行递归调用，换而言之，它们的值各自减 1。此外，left 和 right 指针向前移动一位。<br>
<img src="https://lixin-ee.github.io//post-images/1572485684271.png" alt=""><br>
接下来的两步展示了 left 和 right 指针在链表中的移动。注意到在第二步之后，left 指针抵达了目标位置。因此，后续不再移动。从现在起，只有 right 指针继续移动，直到抵达结点 6。<br>
<img src="https://lixin-ee.github.io//post-images/1572485695408.png" alt=""><br>
如你所见，在第五步之后，两个指针均抵达了目标位置，可以开始进行回溯。我们不再继续递归。回溯过程中的操作是交换 left 和 right 结点的数据。<br>
<img src="https://lixin-ee.github.io//post-images/1572485708891.png" alt=""><br>
如你所见，在第三步（回溯）之后，right 指针 穿过了 left 指针，此时已经完成了要求部分链表的反转。结果是 [7 → 9 → 8 → 1 → 10 → 2 → 6]。 于是不再进行数据交换，在代码中，我们使用全局 boolean 变量 flag 来停止数据交换。不能直接跳出递归。</p>
<pre><code>class Solution {

    // Object level variables since we need the changes
    // to persist across recursive calls and Java is pass by value.
    private boolean stop;
    private ListNode left;

    public void recurseAndReverse(ListNode right, int m, int n) {

        // base case. Don't proceed any further
        if (n == 1) {
            return;
        }

        // Keep moving the right pointer one step forward until (n == 1)
        right = right.next;

        // Keep moving left pointer to the right until we reach the proper node
        // from where the reversal is to start.
        if (m &gt; 1) {
            this.left = this.left.next;
        }

        // Recurse with m and n reduced.
        this.recurseAndReverse(right, m - 1, n - 1);

        // In case both the pointers cross each other or become equal, we
        // stop i.e. don't swap data any further. We are done reversing at this
        // point.
        if (this.left == right || right.next == this.left) {
            this.stop = true;            
        }

        // Until the boolean stop is false, swap data between the two pointers
        if (!this.stop) {
            int t = this.left.val;
            this.left.val = right.val;
            right.val = t;

            // Move left one step to the right.
            // The right pointer moves one step back via backtracking.
            this.left = this.left.next;
        }
    }

    public ListNode reverseBetween(ListNode head, int m, int n) {
        this.left = head;
        this.stop = false;
        this.recurseAndReverse(head, m, n);
        return head;
    }
}
</code></pre>
<p>复杂度分析<br>
时间复杂度:O(N)。对每个结点最多处理两次。递归过程<br>
，回溯<br>
。在回溯过程中，我们只交换了一半的结点，但总复杂度是 O(N)。<br>
空间复杂度: 最坏情况下为 O(N)。在最坏的情况下，我们需要反转整个链表。这是此时递归栈的大小。</p>
<p>剩下的迭代法可以直接查看<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/fan-zhuan-lian-biao-ii-by-leetcode/">官方题解</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 328. 奇偶链表[中等]]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-328-qi-ou-lian-biao-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-328-qi-ou-lian-biao-zhong-deng">
        </link>
        <updated>2019-10-30T01:44:41.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。<br>
请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p>
<p>示例 1:<br>
输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>
输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL<br>
示例 2:<br>
输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL<br>
输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL<br>
说明:<br>
应当保持奇数节点和偶数节点的相对顺序。<br>
链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/odd-even-linked-list<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>我的想法<br>
就是直接新建两个结点，一个存放奇数节点，另外一个存放偶数节点，然后再将两者连接起来。<br>
然后在实现过程中，发现一个问题是必须实现记录好第一个偶数节点（用于与奇数节点相连）<br>
然后最重要的是！！！必须给偶数节点显式接上NULL！！！！否则可能会出现（1-2-3-4-5）最后4的next指向5的情况</p>
<pre><code>class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        if(head==NULL||head-&gt;next==NULL)
            return head;
        ListNode* temp=head-&gt;next;
        ListNode* odd=head;
        ListNode* even=head-&gt;next;
        ListNode* curr=head-&gt;next-&gt;next;
        int count=1;
        while(curr!=NULL){
            if(count%2){
                odd-&gt;next=curr;
                curr=curr-&gt;next;
                odd=odd-&gt;next;
            }else
            {
                even-&gt;next=curr;
                curr=curr-&gt;next;
                even=even-&gt;next;
            }
            ++count;             
        }
        odd-&gt;next=temp;
        even-&gt;next=NULL;
        return head;
    }
};
</code></pre>
<p>链表题最爽的就是可以手写撸代码，基本都能一次过<br>
然后来看一下官方题解：</p>
<blockquote>
<p>解法<br>
想法<br>
将奇节点放在一个链表里，偶链表放在另一个链表里。然后把偶链表接在奇链表的尾部。<br>
算法<br>
这个解法非常符合直觉思路也很简单。但是要写一个精确且没有 bug 的代码还是需要进行一番思索的。<br>
一个 LinkedList 需要一个头指针和一个尾指针来支持双端操作。我们用变量 head 和 odd 保存奇链表的头和尾指针。 evenHead 和 even 保存偶链表的头和尾指针。算法会遍历原链表一次并把奇节点放到奇链表里去、偶节点放到偶链表里去。遍历整个链表我们至少需要一个指针作为迭代器。这里 odd 指针和 even 指针不仅仅是尾指针，也可以扮演原链表迭代器的角色。<br>
解决链表问题最好的办法是在脑中或者纸上把链表画出来。比方说<br>
<img src="https://lixin-ee.github.io//post-images/1572400580152.png" alt=""></p>
</blockquote>
<pre><code>public class Solution {
    public ListNode oddEvenList(ListNode head) {
        if (head == null) return null;
        ListNode odd = head, even = head.next, evenHead = even;
        while (even != null &amp;&amp; even.next != null) {
            odd.next = even.next;
            odd = odd.next;
            even.next = odd.next;
            even = even.next;
        }
        odd.next = evenHead;
        return head;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度： O(n) 。总共有 n 个节点，我们每个遍历一次。<br>
空间复杂度： O(1) 。我们只需要 4 个指针。</p>
</blockquote>
<p>官方题解果然更优雅一点哈哈哈，因为我比较担心出问题所以设置了cur指针，其实这个是非必须的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 24. 两两交换链表中的节点[中等]]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-24-liang-liang-jiao-huan-lian-biao-zhong-de-jie-dian-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-24-liang-liang-jiao-huan-lian-biao-zhong-de-jie-dian-zhong-deng">
        </link>
        <updated>2019-10-29T01:18:49.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<br>
你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p>示例:<br>
给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/swap-nodes-in-pairs<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>难点：如何保证指针在交换时保证正确。<br>
我的思路：<br>
1-&gt;2-&gt;3-&gt;4-&gt;5，示例交换3和4<br>
将2作为previous，将3作为target<br>
所以有</p>
<pre><code>pre-&gt;next=tar-&gt;next; //2指向4
tar-&gt;next=tar-&gt;next-&gt;next;//3指向5
pre-&gt;next-&gt;next=tar;//4指向3，此时就有2-4-3-5
pre=tar;//将3作为pre
tar=pre-&gt;next;//将5作为tar
</code></pre>
<p>但是1和2交换时没有pre，所以需要加上一个空表头<br>
最终代码如下</p>
<pre><code>class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(head==NULL)
            return head;
        ListNode* flag = new ListNode(0); //新建一个结点，value为0
        flag-&gt;next = head; //让它next指针指向头结点
        ListNode *pre=flag,*tar=head;
        while(tar!=NULL&amp;&amp;tar-&gt;next!=NULL){
            pre-&gt;next=tar-&gt;next;
            tar-&gt;next=tar-&gt;next-&gt;next;
            pre-&gt;next-&gt;next=tar;
            pre=tar;
            tar=pre-&gt;next;
        }
        return flag-&gt;next;
    }
};
</code></pre>
<p>需要注意的点就是加上空表头的代码<br>
一开始我是直接 <code>ListNode* flag = head</code>结果翻车了，因为这样子是等于和head共享一个地址，正确的应该是new出一个结点，再使用new出来的结点的地址</p>
<pre><code>ListNode* flag = new ListNode(0); //新建一个结点，value为0
flag-&gt;next = head; //让它next指针指向头结点
</code></pre>
<p>然后来看一下网友题解：<br>
首先是和我思路一致的<br>
<img src="https://lixin-ee.github.io//post-images/1572313056432.jpg" alt=""></p>
<pre><code>class Solution:
    def swapPairs(self, head: ListNode) -&gt; ListNode:
        thead = ListNode(-1)
        thead.next = head
        c = thead
        while c.next and c.next.next:
            a, b=c.next, c.next.next
            c.next, a.next = b, b.next
            b.next = a
            c = c.next.next
        return thead.next
</code></pre>
<p>然后是递归做法</p>
<blockquote>
<p>解题方案<br>
思路<br>
标签：链表<br>
本题的递归和非递归解法其实原理类似，都是更新每两个点的链表形态完成整个链表的调整<br>
其中递归解法可以作为典型的递归解决思路进行讲解<br>
递归写法要观察本级递归的解决过程，形成抽象模型，因为递归本质就是不断重复相同的事情。而不是去思考完整的调用栈，一级又一级，无从下手。如图所示，我们应该关注一级调用小单元的情况，也就是单个f(x)。<br>
<img src="https://lixin-ee.github.io//post-images/1572313291404.png" alt=""><br>
其中我们应该关心的主要有三点：<br>
返回值<br>
调用单元做了什么<br>
终止条件</p>
<p>在本题中：<br>
返回值：交换完成的子链表<br>
调用单元：设需要交换的两个点为 head 和 next，head 连接后面交换完成的子链表，next 连接 head，完成交换<br>
终止条件：head 为空指针或者 next 为空指针，也就是当前无节点或者只有一个节点，无法进行交换<br>
代码<br>
递归解法</p>
</blockquote>
<pre><code>class Solution {
    public ListNode swapPairs(ListNode head) {
        if(head == null || head.next == null){
            return head;
        }
        ListNode next = head.next;
        head.next = swapPairs(next.next);
        next.next = head;
        return next;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 141. 环形链表 难度：简单]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-141-huan-xing-lian-biao-nan-du-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-141-huan-xing-lian-biao-nan-du-jian-dan">
        </link>
        <updated>2019-10-28T01:48:27.000Z</updated>
        <content type="html"><![CDATA[<p>给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<p>示例 1： 输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。<br>
示例 2：输入：head = [1,2], pos = 0 输出：true 解释：链表中有一个环，其尾部连接到第一个节点。<br>
示例 3： 输入：head = [1], pos = -1 输出：false 解释：链表中没有环。<br>
进阶： 你能用 O(1)（即，常量）内存解决此问题吗？</p>
<p>难点：<br>
1.常量内存的解决法<br>
我的思路<br>
其实这道题之前已经碰到过了hhh，然后我还记得呢（其实找了一个早上才找到。。。）<br>
<a href="https://lixin-ee.github.io/post/shu-zu-287-xun-zhao-chong-fu-shu/">数组187.寻找重复数</a></p>
<blockquote>
<p>#此题转换为链表找环的开始位置，前提条件告诉我们是一定有环</p>
<h1 id="根据floyd判圈办法一个快指针一个慢指针二者一定在环上相遇设相遇点为m点">根据floyd判圈办法，一个快指针一个慢指针，二者一定在环上相遇，设相遇点为M点，</h1>
<h1 id="快是慢的速度的2倍时间相同设慢的距离为s那么快的距离为2s">快是慢的速度的2倍，时间相同，设慢的距离为s，那么快的距离为2s</h1>
<h1 id="m为链表头距离环开始位置的距离k为环开始位置到m点的距离-n为环长度">m为链表头距离环开始位置的距离，k为环开始位置到M点的距离, N为环长度</h1>
<h1 id="s-m-an-k-2s-m-bn-k二者相减s-a-bn">s = m + a<em>N +k, 2s = m + b</em>N +k，二者相减，s = (a-b)*N</h1>
<h1 id="由此可见慢指针走过的距离是环长的整数倍即链表头到m点是环长的整数倍">由此可见，慢指针走过的距离是环长的整数倍，即链表头到M点是环长的整数倍</h1>
<h1 id="如果是1倍的话把m截距离旋转到环上跟环融合那么链表头一定落在m点">如果是1倍的话，把m截距离旋转到环上，跟环融合，那么链表头一定落在M点，</h1>
<h1 id="即fast和slow都落在m点那么二者到环开始位置距离相同必然在此处相遇">即fast和slow都落在M点，那么二者到环开始位置距离相同，必然在此处相遇。</h1>
<h1 id="如果是n倍n1时只不过slow指针多转几圈而已后二者仍在此处相遇">如果是N倍（N&gt;1）时，只不过slow指针多转几圈而已，后二者仍在此处相遇</h1>
</blockquote>
<p>最后代码如下</p>
<pre><code>class Solution {
public:
    bool hasCycle(ListNode *head) {
        if(!head)
            return false;
        ListNode *fast=head-&gt;next;
        ListNode *slow=head;
        while(fast!=slow){
            if(fast==NULL||fast-&gt;next==NULL)
                return false;
            fast=fast-&gt;next-&gt;next;
            slow=slow-&gt;next;
        }
        return true;
    }
};
</code></pre>
<p>然后来看一下官方题解：</p>
<blockquote>
<p>方法一：哈希表<br>
思路<br>
我们可以通过检查一个结点此前是否被访问过来判断链表是否为环形链表。常用的方法是使用哈希表。<br>
算法<br>
我们遍历所有结点并在哈希表中存储每个结点的引用（或内存地址）。如果当前结点为空结点 null（即已检测到链表尾部的下一个结点），那么我们已经遍历完整个链表，并且该链表不是环形链表。如果当前结点的引用已经存在于哈希表中，那么返回 true（即该链表为环形链表）。</p>
</blockquote>
<pre><code>public boolean hasCycle(ListNode head) {
    Set&lt;ListNode&gt; nodesSeen = new HashSet&lt;&gt;();
    while (head != null) {
        if (nodesSeen.contains(head)) {
            return true;
        } else {
            nodesSeen.add(head);
        }
        head = head.next;
    }
    return false;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)，对于含有 n 个元素的链表，我们访问每个元素最多一次。添加一个结点到哈希表中只需要花费 O(1) 的时间。<br>
空间复杂度：O(n)，空间取决于添加到哈希表中的元素数目，最多可以添加 n 个元素。</p>
<p>方法二：双指针<br>
思路<br>
想象一下，两名运动员以不同的速度在环形赛道上跑步会发生什么？</p>
<p>算法<br>
通过使用具有 不同速度 的快、慢两个指针遍历链表，空间复杂度可以被降低至 O(1)。慢指针每次移动一步，而快指针每次移动两步。<br>
如果列表中不存在环，最终快指针将会最先到达尾部，此时我们可以返回 false。<br>
现在考虑一个环形链表，把慢指针和快指针想象成两个在环形赛道上跑步的运动员（分别称之为慢跑者与快跑者）。而快跑者最终一定会追上慢跑者。这是为什么呢？考虑下面这种情况（记作情况 A）- 假如快跑者只落后慢跑者一步，在下一次迭代中，它们就会分别跑了一步或两步并相遇。<br>
其他情况又会怎样呢？例如，我们没有考虑快跑者在慢跑者之后两步或三步的情况。但其实不难想到，因为在下一次或者下下次迭代后，又会变成上面提到的情况 A。</p>
</blockquote>
<pre><code>public boolean hasCycle(ListNode head) {
    if (head == null || head.next == null) {
        return false;
    }
    ListNode slow = head;
    ListNode fast = head.next;
    while (slow != fast) {
        if (fast == null || fast.next == null) {
            return false;
        }
        slow = slow.next;
        fast = fast.next.next;
    }
    return true;
}
</code></pre>
<blockquote>
<p>复杂度分析</p>
<p>时间复杂度：O(n)，让我们将 nn 设为链表中结点的总数。为了分析时间复杂度，我们分别考虑下面两种情况。</p>
<p>链表中不存在环：<br>
快指针将会首先到达尾部，其时间取决于列表的长度，也就是 O(n)。</p>
<p>链表中存在环：<br>
我们将慢指针的移动过程划分为两个阶段：非环部分与环形部分：</p>
<p>慢指针在走完非环部分阶段后将进入环形部分：此时，快指针已经进入环中<br>
迭代次数=非环部分长度=N</p>
<p>两个指针都在环形区域中：考虑两个在环形赛道上的运动员 - 快跑者每次移动两步而慢跑者每次只移动一步。其速度的差值为 1，因此需要经过 二者之间距离\速度差值 次循环后，快跑者可以追上慢跑者。这个距离几乎就是 环形部分长度 K&quot; 且速度差值为 1，我们得出这样的结论 迭代次数=近似于&quot;环形部分长度 K&quot;.</p>
<p>因此，在最糟糕的情形下，时间复杂度为 O(N+K)，也就是 O(n)。</p>
<p>空间复杂度：O(1)，我们只使用了慢指针和快指针两个结点，所以空间复杂度为 O(1)。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于指针形参的问题]]></title>
        <id>https://lixin-ee.github.io//post/guan-yu-zhi-zhen-xing-can-de-wen-ti</id>
        <link href="https://lixin-ee.github.io//post/guan-yu-zhi-zhen-xing-can-de-wen-ti">
        </link>
        <updated>2019-10-27T13:53:25.000Z</updated>
        <content type="html"><![CDATA[<p>今天做递归的时候发现一个很严重的问题</p>
<pre><code>ListNode* reverse_list(ListNode* head,ListNode* n,ListNode* n_next){
        if(n_next!=NULL){
            reverse_list(head,n_next,n_next-&gt;next);
            n_next-&gt;next=n;
            cout&lt;&lt;head-&gt;val&lt;&lt;endl;
        }    
        else{
            head=n; 
            cout&lt;&lt;head-&gt;val&lt;&lt;endl;
        }
 
       return n;
    }
		
ListNode* reverseList(ListNode* head) {
        if(head==NULL)
            return NULL;
        //ListNode *ln=head-&gt;next;
        ListNode*n=reverse_list(head,head,head-&gt;next);
        n-&gt;next=NULL;
        return head;
    }
    
</code></pre>
<p>为了改变head的值我把head指针传了进去，但是！在递归回来的途中程序却吧head的值改回原值了？WTF？这个问题弄了一个早上也没弄懂，晚上了研究一下发现了问题所在：<br>
head=n;<br>
注意这里我直接使用了指针形参，而不是对指针形参进行解引用再赋值<br>
此时其实和平常我们使用指针形参的情形不太一样，平常我们只会对指针形参进行解引用再赋值，从而达到不需要值传递。但是！指针形参本身就是一个值传递，所以如果像上面直接使用指针形参的值，虽然在函数内是可以改变指针指向的对象，但其实这个指针形参是一个临时变量，一旦离开函数这个临时变量就没了。所以对于指针形参，如果想达到改变值的情况，只能1.对于指针指向的值可以直接改变值2.如果想改变指针的值，形参必须改成指针的引用 也就是*（&amp;head）。</p>
<p>因为所谓的指针形参传递对于指针这个形参本身来说还是值传递！是复制了指针形参过去的！！只有对于指针指向的对象来说才是相当于引用传递，所以head的形参必须改成指针的引用 也就是*（&amp;head）<br>
所以最终代码为</p>
<pre><code>class Solution {

public:
    ListNode* reverse_list(ListNode* (&amp;head),ListNode* n,ListNode* n_next){</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 206. 反转链表 难度：简单]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-206-fan-zhuan-lian-biao-nan-du-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-206-fan-zhuan-lian-biao-nan-du-jian-dan">
        </link>
        <updated>2019-10-27T01:44:48.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>反转一个单链表。<br>
示例:<br>
输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br>
进阶:<br>
你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p>
</blockquote>
<p>难点要点：<br>
1.如何保证指针改变后还能保存指针之前指向的值？比如1-&gt;2-&gt;3 将2指向1后，怎么读3的值？<br>
2.注意链表题<br>
我的思路就是利用三个变量分别保存好这三者，然后进行迭代</p>
<pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(head==NULL)
            return NULL;
        //ListNode *ln=head-&gt;next;
        ListNode *ln=head;
        ListNode *lnn=ln-&gt;next;
        ListNode *temp=NULL;
        while(lnn!=NULL){
            ln-&gt;next=temp;
            temp=ln;
            ln=lnn;
            lnn=lnn-&gt;next;         
        }
        ln-&gt;next=temp;
        head=ln;
        return head;
    }
};
</code></pre>
<p>做递归的时候发现一个很严重的问题</p>
<pre><code>ListNode* reverse_list(ListNode* head,ListNode* n,ListNode* n_next){
        if(n_next!=NULL){
            reverse_list(head,n_next,n_next-&gt;next);
            n_next-&gt;next=n;
            cout&lt;&lt;head-&gt;val&lt;&lt;endl;
        }    
        else{
            head=n; 
            cout&lt;&lt;head-&gt;val&lt;&lt;endl;
        }
 
       return n;
    }


ListNode* reverseList(ListNode* head) {
        if(head==NULL)
            return NULL;
        //ListNode *ln=head-&gt;next;
        ListNode*n=reverse_list(head,head,head-&gt;next);
        n-&gt;next=NULL;
        return head;
    }
    
</code></pre>
<p>为了改变head的值我把head指针传了进去，但是！在递归回来的途中程序却吧head的值改回原值了？WTF？这个问题弄了一个早上也没弄懂，后面再研究一下</p>
<p>10.27晚上更新：因为所谓的指针形参传递对于指针这个形参本身来说还是值传递！是复制了指针形参过去的！！只有对于指针指向的对象来说才是相当于引用传递，所以head的形参必须改成指针的引用 也就是*（&amp;head）<br>
所以最终代码为</p>
<pre><code>class Solution {

public:
    ListNode* reverse_list(ListNode* (&amp;head),ListNode* n,ListNode* n_next){
        
        if(n_next!=NULL){
            reverse_list(head,n_next,n_next-&gt;next);
            n_next-&gt;next=n;
        }    
        else{
            head=n; 
        }
 
       return n;
    }


ListNode* reverseList(ListNode* head) {
        if(head==NULL)
            return NULL;
        //ListNode *ln=head-&gt;next;
        ListNode* n=reverse_list(head,head,head-&gt;next);
        n-&gt;next=NULL;
        return head;
    }
};
</code></pre>
<p>先来看一下题解：</p>
<blockquote>
<p>方法一：迭代<br>
假设存在链表 1 → 2 → 3 → Ø，我们想要把它改成 Ø ← 1 ← 2 ← 3。</p>
<p>在遍历列表时，将当前节点的 next 指针改为指向前一个元素。由于节点没有引用其上一个节点，因此必须事先存储其前一个元素。在更改引用之前，还需要另一个指针来存储下一个节点。不要忘记在最后返回新的头引用！</p>
</blockquote>
<pre><code>public ListNode reverseList(ListNode head) {
    ListNode prev = null;
    ListNode curr = head;
    while (curr != null) {
        ListNode nextTemp = curr.next;
        curr.next = prev;
        prev = curr;
        curr = nextTemp;
    }
    return prev;
}
</code></pre>
<blockquote>
<p>复杂度分析</p>
<p>时间复杂度：O(n)，假设 nn 是列表的长度，时间复杂度是 O(n)。<br>
空间复杂度：O(1)</p>
</blockquote>
<blockquote>
<p>方法二：递归<br>
递归版本稍微复杂一些，其关键在于反向工作。假设列表的其余部分已经被反转，现在我该如何反转它前面的部分？</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1572145652208.png" alt=""></p>
<pre><code>public ListNode reverseList(ListNode head) {
    if (head == null || head.next == null) return head;
    ListNode p = reverseList(head.next);
    head.next.next = head;
    head.next = null;
    return p;
}
</code></pre>
<blockquote>
<p>复杂度分析</p>
<p>时间复杂度：O(n)，假设 nn 是列表的长度，那么时间复杂度为O(n)。<br>
空间复杂度：O(n)，由于使用递归，将会使用隐式栈空间。递归深度可能会达到 n 层。</p>
</blockquote>
<p>然后是比较直观的网友题解</p>
<blockquote>
<p>迭代：<br>
<img src="https://lixin-ee.github.io//post-images/1572145715655.png" alt=""></p>
</blockquote>
<pre><code>ListNode* reverseList(ListNode* head) {
        if(!head){
            return nullptr;
        }
        ListNode* first = head;//始终指向原链表的首位元素
        ListNode* target = head-&gt;next;//始终指向即将要放到当前链表首元素之前的目标元素
        while(target != nullptr){
            first-&gt;next = target-&gt;next;
            ListNode* temp = target-&gt;next;
            target-&gt;next = head;
            head = target;
            target = temp;
        }
        return head;
    }
</code></pre>
<p>递归：</p>
<pre><code>ListNode* reverseList(ListNode* head) {
        if(!head){
            return nullptr;
        }
        return reverse(head, head, head-&gt;next);        
    }
    
    ListNode* reverse(ListNode* head, ListNode* first, ListNode* target){
        if(!target){
            return head;
        }
        first-&gt;next = target-&gt;next;
        ListNode* temp = target-&gt;next;
        target-&gt;next = head;
        return reverse(target, first, temp);
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math 204. 计数质数 难度：简单]]></title>
        <id>https://lixin-ee.github.io//post/math-204-ji-shu-zhi-shu</id>
        <link href="https://lixin-ee.github.io//post/math-204-ji-shu-zhi-shu">
        </link>
        <updated>2019-10-26T01:37:24.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>统计所有小于非负整数 n 的质数的数量。</p>
<p>示例:<br>
输入: 10<br>
输出: 4<br>
解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</p>
</blockquote>
<p>没什么想法，这几天状态很低落，直接看一下题解吧<br>
解决方案:</p>
<blockquote>
<p>一、暴力法（计算超时）：<br>
验证一个数是否为质数（素数）有很多方法。但最容易想到的莫非用暴力计算的方式一步步碾压过去的方法。虽然这种方法不是最优的，但是其对于我们了解素数仍是有所帮助的。<br>
思路：验证某个数是否为质数时，将其对每一个比其小的数进行取余运算，并对取余为零的情况进行计数。由于质数是指在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。所以，当计数结果为 1 时，该数为质数。<br>
在实际操作中，由于 1 和任意一个数必然取余为零，所以可以直接排除。并当没有取余为零的情况时，其才为质数。<br>
得代码如下：</p>
</blockquote>
<pre><code>int countPrimes(int n) {
    int count = 0;
    for (int i = 2; i &lt; n; i++){
        bool sign = true;
        for (int j = 2; j &lt; i; j++){
            if (i % j == 0)
            {
                sign = false;
                break;
            }
        }
        if (sign)
            count++; ;
    }
    return count;
}
</code></pre>
<blockquote>
<p>二、优化暴力算法：<br>
细究暴力计算的方法，我们可以发现，假如一个数为 9 ，那么其二分之一（4.5）后的数都可以不用进行计算，因为肯定是有余的 。事实上情况会比这更好一些：对正整数 n ，如果用 2 到 √n 之间(包含边界)的所有整数去除，均无法整除，则 n 为质数。<br>
并且，我们可以发现，一切非 2 偶数一定不可能为质数。所以，我们可以在此处进行另一步的优化。<br>
有个这些令人庆幸的发现，我们的代码也将如虎添翼：</p>
</blockquote>
<pre><code>int countPrimes(int n) {
    if(n &lt; 3)
        return 0;;
    //从3开始验算，所以初始值为1（2为质数）。
    int count = 1;
    for (int i = 3; i &lt; n; i++){
        //当某个数为 2 的 n 次方时（n为自然数），其 &amp; (n - 1) 所得值将等价于取余运算所得值
        //*如果 x = 2^n ，则 x &amp; (n - 1) == x % n
        //if(i % 2 == 0)
        if ((i &amp; 1) == 0)
            continue; ;
        bool sign = true;
        //用 j * j &lt;= i 代替 j &lt;= √i 会更好。
        //因为我们已经排除了所有偶数，所以每次循环加二将规避偶数会减少循环次数
        for (int j = 3; j * j &lt;=i; j+=2){
            if (i % j == 0){
                sign = false;
                break;
            }
        }
        if (sign)
            count++; ;
    }
    return count;
}
</code></pre>
<blockquote>
<p>(暴力法系列的 C# 和 C++ 的代码几乎相同。)<br>
经过对暴力算法的此番优化，我们的代码初步达到了应用的最低门槛，但显然还是不大理想，好似总感觉存在不必要的操作。但我们经过以上的研究（可以早一步排除偶数），再结合质数的性质，可以推想出：如果我们在进行顺序遍历时，每取得一个数（排除0、1），如果将它所有的倍数（排除0、1、本身）都清除，那么，剩下的数是不是必为素数？<br>
没错，这个有趣且实用的方法便是著名的厄拉多塞筛法！</p>
<p>三、厄拉多塞筛法：<br>
使用厄拉多塞筛法进行 1 到 64 的质数查找的过程如下：</p>
</blockquote>
<pre><code>int countPrimes(int n) {
    int count = 0;
    //初始默认所有数为质数
    vector&lt;bool&gt; signs(n, true);
    for (int i = 2; i &lt; n; i++) {
        if (signs[i]) {
            count++;
            for (int j = i + i; j &lt; n; j += i) {
                //排除不是质数的数
                signs[j] = false;
            }
        }
    }
    return count;
}
</code></pre>
<p>四、运用比特表（Bitmap）算法对筛法进行内存优化：</p>
<p>上面运用厄拉多塞筛法求一定范围内的质数已经十分高效了。然而，我们使用布尔数组标记一个数是否为质数时，每个值都占用了一个字节（Byte）。但是，我们仅需要两个不同的值来表示是否为质数即可。即一个比特（bit）来表示即可（0、1）。如果这样的话，我们便最优可节省八分之七的空间（然而，还得结合代码和实际情况，并不是用了就一定有效果）。</p>
<p>关于比特表算法在此便简要概述以下（可略过）：<br>
假如有从 1 至 8 总共八个数。现有一个字节大小的内存空间可供使用（仅供参考，不考虑实际用途及比特算法的最佳用处）。如何将每个数登记下来，并可以随时检查一个数是否存在呢？</p>
<p>如果用一个数组表示，即使不考虑数组的内存开销，哪怕用一个 byte 类型的变量记录每一数也将超出内存可使用范围。但是由于每个字节共有八个比特位，则可以用每个比特位来表示每个数字则恰好可以登记完所有的数字。</p>
<p>示例：</p>
<p>登记数字 1 ：0 0 0 0 0 0 0 1<br>
登记数字 1、3：0 0 0 0 0 1 0 1<br>
登记数字 1、2、3、4、5 ：0 0 0 1 1 1 1 1<br>
得代码如下：</p>
<pre><code>int countPrimes(int n) {
    int count = 0;
    //一个 int 变量不知道占多少字节（但请注意，这里采用了常量）
    const int size = sizeof(int) * 8;
    vector&lt;int&gt; signs(n / size + 1,0);
    for (int i = 2; i &lt; n; i++){
        //将元素和需确定得数字经行按位或运算，如果值改变，说明不存在该数字（未登记该数字），则其为质数。
        //在C++中，其提供了 bitset 来操作位，在此便不做介绍了。如果用了，可读性肯定会更好。
        //(当某个数为 2 的 n 次方时（n为自然数），其 &amp; (n - 1) 所得值将等价于取余运算所得值)
        //*如果 x = 2^n ，则 x &amp; (n - 1) == x % n
        //下面判断可以写成
        //if ((signs[i / size] &amp; (1 &lt;&lt; (i % 32))) == 0)
        if ((signs[i / size] &amp; (1 &lt;&lt; (i &amp; (size - 1)))) == 0){
            count++;
            for (int j = i + i; j &lt; n; j += i){
                //登记该数字
            	signs[j / size] |= 1 &lt;&lt; (j &amp; (size - 1));
            }
        }
    }
    return count;
}
</code></pre>
]]></content>
    </entry>
</feed>