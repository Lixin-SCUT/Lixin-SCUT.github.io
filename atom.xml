<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2020-01-17T01:52:43.429Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[字符串 5. 最长回文子串[中等][未做出]]]></title>
        <id>https://lixin-ee.github.io//post/zi-fu-chuan-5-zui-chang-hui-wen-zi-chuan-zhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/zi-fu-chuan-5-zui-chang-hui-wen-zi-chuan-zhong-deng-wei-zuo-chu">
        </link>
        <updated>2020-01-16T14:21:05.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。<br>
示例 1：<br>
输入: &quot;babad&quot;<br>
输出: &quot;bab&quot;<br>
注意: &quot;aba&quot; 也是一个有效答案。<br>
示例 2：<br>
输入: &quot;cbbd&quot;<br>
输出: &quot;bb&quot;<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/longest-palindromic-substring<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>【未做出】<br>
本来以为和大话数据结构里面的KMP匹配算法比较像<br>
结果发现不是的 KMP是类似于 ababa之中的前面一个【aba】ba和后面一个ab【aba】匹配<br>
然后偷看tag发现需要用动态规划来做<br>
我的想法是先确定两边beg和end 然后不断收缩比较，但是这样子的话等于C2-n种情况 再加上比较，直接立方级别的时间复杂度啊<br>
看题解！</p>
<p>实现动态规划需要注意的点<br>
1.动态规划数组pd需要初始化为false而不是true 否则必须将不通过if的pd[l][r]重置为false，所以还是初始化为false比较方便<br>
2.动态规划时间复杂度很高，区间判断和修改放在同一个if里面就好，独立出来会超时<br>
3.可以空间压缩 画图可以发现，当前格子总是参考左下角格子（行为r，列为l）（if判断可以省略掉没有左下角的格子），比如[0,4]参考[1,3]，对于r来说不重要，只要l+1就行，所以可以使用两个bool数组保存列，注意是保存【列】！！！，然后注意如果不通过判断的话需要刷新值置为false！！！这一步不可或缺，否则最后都是true了。然后发现如果是l需要l+1的话，完全可以用一个bool数组列就解决了。</p>
<pre><code>class Solution {
public:
    string longestPalindrome(string s) {
        int len=s.size();
        string res;
        int beg=0,end=0;
        if(len==0) return res;
        //vector&lt;vector&lt;bool&gt;&gt; pd(len,vector&lt;bool&gt;(len,false));
        vector&lt;bool&gt; cur(len,false);
        for(int r=0;r&lt;len;++r)
            for(int l=0;l&lt;r;++l)
                //pd[l][r]=(s[l]==s[r]&amp;&amp;(r-l&lt;=2||pd[l+1][r-1]));
                if(s[l]==s[r]&amp;&amp;(r-l&lt;=2||cur[l+1])){
                    cur[l]=true;
                    if(r-l&gt;end-beg)
                        beg=l,end=r;
                }
                else cur[l]=false;        
        return s.substr(beg,end-beg+1);
    }
};
</code></pre>
<p>中心扩散法实现：</p>
<pre><code>    string longestPalindrome(string s) {
        int len=s.size();
        if(len&lt;2)
            return s;
        string maxStr;
				//hhh一开始int i忘了赋值了，居然无法通过提交，似乎提交用的编译器不会执行值初始化，使用的是默认初始化，导致函数体内部的内置类型变量将不被初始化，此时变量的值是未定义的（undefined）
        for(int i=0;i&lt;len-1;++i){   
            string oddStr=isPalin(s,i,i);
            string evenStr=isPalin(s,i,i+1);
            maxStr=maxStr.size()&gt;oddStr.size()?maxStr:oddStr;
            maxStr=maxStr.size()&gt;evenStr.size()?maxStr:evenStr;
        }
        return maxStr;
    }
    
    string isPalin(const string &amp;s,int left,int right){
        string res;
        while(left&gt;=0&amp;&amp;right&lt;s.size()){
            if(s[left]==s[right]){
                --left;
                ++right;
            }else
                break;
        }
        return s.substr(left+1,right-left-1);
    }
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>方法一：暴力匹配 （Brute Force）<br>
根据回文子串的定义，枚举所有长度大于等于 22 的子串，依次判断它们是否是回文；<br>
在具体实现时，可以只针对大于“当前得到的最长回文子串长度”的子串进行“回文验证”；<br>
在记录最长回文子串的时候，可以只记录“当前子串的起始位置”和“子串长度”，不必做截取。这一步我们放在后面的方法中实现。<br>
说明：暴力解法时间复杂度高，但是思路清晰、编写简单。由于编写正确性的可能性很大，可以使用暴力匹配算法检验我们编写的其它算法是否正确。优化的解法在很多时候，是基于“暴力解法”，以空间换时间得到的，因此思考清楚暴力解法，分析其缺点，很多时候能为我们打开思路。</p>
</blockquote>
<pre><code>class Solution {
private:
    bool valid(string s, int left, int right) {
        // 验证子串 s[left, right] 是否为回文串
        while (left &lt; right) {
            if (s[left] != s[right]) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }

public:
    string longestPalindrome(string s) {
        // 特判
        int size = s.size();
        if (size &lt; 2) {
            return s;
        }

        int maxLen = 1;
        string res = s.substr(0, 1);

        // 枚举所有长度大于等于 2 的子串
        for (int i = 0; i &lt; size - 1; i++) {
            for (int j = i + 1; j &lt; size; j++) {
                if (j - i + 1 &gt; maxLen &amp;&amp; valid(s, i, j)) {
                    maxLen = j - i + 1;
                    res = s.substr(i, maxLen);
                }
            }
        }
        return res;
    }
};

// 运行结果超出内存限制
</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(N^3)，这里 N 是字符串的长度，枚举字符串的左边界、右边界，然后继续验证子串是否是回文子串，这三种操作都与 N 相关；<br>
空间复杂度：O(1)，只使用到常数个临时变量，与字符串长度无关。</p>
</blockquote>
<blockquote>
<p>方法二：动态规划<br>
“动态规划”最关键的步骤是想清楚“状态如何转移”，事实上，“回文”是天然具有“状态转移”性质的：<br>
一个回文去掉两头以后，剩下的部分依然是回文（这里暂不讨论边界）。<br>
依然从回文串的定义展开讨论：<br>
1、如果一个字符串的头尾两个字符都不相等，那么这个字符串一定不是回文串；<br>
2、如果一个字符串的头尾两个字符相等，才有必要继续判断下去。<br>
（1）如果里面的子串是回文，整体就是回文串；<br>
（2）如果里面的子串不是回文串，整体就不是回文串。<br>
即在头尾字符相等的情况下，里面子串的回文性质据定了整个子串的回文性质，这就是状态转移。因此可以把“状态”定义为原字符串的一个子串是否为回文子串。<br>
第 1 步：定义状态<br>
dp[i][j] 表示子串 s[i, j] 是否为回文子串。<br>
第 2 步：思考状态转移方程<br>
这一步在做分类讨论（根据头尾字符是否相等），根据上面的分析得到：<br>
dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]<br>
分析这个状态转移方程：<br>
（1）“动态规划”事实上是在填一张二维表格，i 和 j 的关系是 i &lt;= j ，因此，只需要填这张表的上半部分；<br>
（2）看到 dp[i + 1][j - 1] 就得考虑边界情况。<br>
边界条件是：表达式 [i + 1, j - 1] 不构成区间，即长度严格小于 2，即 j - 1 - (i + 1) + 1 &lt; 2 ，整理得 j - i &lt; 3。<br>
这个结论很显然：当子串 s[i, j] 的长度等于 2 或者等于 3 的时候，我其实只需要判断一下头尾两个字符是否相等就可以直接下结论了。<br>
如果子串 s[i + 1, j - 1] 只有 1 个字符，即去掉两头，剩下中间部分只有 11 个字符，当然是回文；<br>
如果子串 s[i + 1, j - 1] 为空串，那么子串 s[i, j] 一定是回文子串。<br>
因此，在 s[i] == s[j] 成立和 j - i &lt; 3 的前提下，直接可以下结论，dp[i][j] = true，否则才执行状态转移。<br>
（这一段看晕的朋友，直接看代码吧。我写晕了，车轱辘话来回说。）<br>
第 3 步：考虑初始化<br>
初始化的时候，单个字符一定是回文串，因此把对角线先初始化为 1，即 dp[i][i] = 1 。<br>
事实上，初始化的部分都可以省去。因为只有一个字符的时候一定是回文，dp[i][i] 根本不会被其它状态值所参考。<br>
第 3 步：考虑初始化<br>
初始化的时候，单个字符一定是回文串，因此把对角线先初始化为 1，即 dp[i][i] = 1 。<br>
事实上，初始化的部分都可以省去。因为只有一个字符的时候一定是回文，dp[i][i] 根本不会被其它状态值所参考。<br>
第 4 步：考虑输出<br>
只要一得到 dp[i][j] = true，就记录子串的长度和起始位置，没有必要截取，因为截取字符串也要消耗性能，记录此时的回文子串的“起始位置”和“回文长度”即可。<br>
第 5 步：考虑状态是否可以压缩<br>
因为在填表的过程中，只参考了左下方的数值。事实上可以压缩，但会增加一些判断语句，增加代码编写和理解的难度，丢失可读性。在这里不做状态压缩。<br>
下面是编码的时候要注意的事项：总是先得到小子串的回文判定，然后大子串才能参考小子串的判断结果。<br>
思路是：<br>
1、在子串右边界 j 逐渐扩大的过程中，枚举左边界可能出现的位置；<br>
2、左边界枚举的时候可以从小到大，也可以从大到小。<br>
这两版代码的差别仅在内层循环，希望大家能够自己动手，画一下表格，思考为什么这两种代码都是可行的，相信会对“动态规划”作为一种“表格法”有一个更好的理解。</p>
</blockquote>
<pre><code>public class Solution {


    public String longestPalindrome(String s) {
        int len = s.length();
        if (len &lt; 2) {
            return s;
        }

        boolean[][] dp = new boolean[len][len];

        int maxLen = 1;
        int start = 0;

        for (int j = 1; j &lt; len; j++) {
            for (int i = 0; i &lt; j; i++) {

                dp[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt; 3 || dp[i + 1][j - 1]);

                if (dp[i][j]) {
                    int curLen = j - i + 1;
                    if (curLen &gt; maxLen) {
                        maxLen = curLen;
                        start = i;
                    }
                }
            }
        }
        return s.substring(start, start + maxLen);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(N^2)。<br>
空间复杂度：O(N^2)，二维 dp 问题，一个状态得用二维有序数对表示</p>
</blockquote>
<blockquote>
<p>方法三：中心扩散法<br>
暴力法采用双指针两边夹，验证是否是回文子串。<br>
除了枚举字符串的左右边界以外，比较容易想到的是枚举可能出现的回文子串的“中心位置”，从“中心位置”尝试尽可能扩散出去，得到一个回文串。<br>
因此中心扩散法的思路是：遍历每一个索引，以这个索引为中心，利用“回文串”中心对称的特点，往两边扩散，看最多能扩散多远。<br>
枚举“中心位置”时间复杂度为 O(N)，从“中心位置”扩散得到“回文子串”的时间复杂度为 O(N)，因此时间复杂度可以降到 O(N^2)。<br>
在这里要注意一个细节：回文串在长度为奇数和偶数的时候，“回文中心”的形式是不一样的。<br>
奇数回文串的“中心”是一个具体的字符，例如：回文串 &quot;aba&quot; 的中心是字符 &quot;b&quot;；<br>
偶数回文串的“中心”是位于中间的两个字符的“空隙”，例如：回文串串 &quot;abba&quot; 的中心是两个 &quot;b&quot; 中间的那个“空隙”。<br>
我们可以设计一个方法，兼容以上两种情况：<br>
1、如果传入重合的索引编码，进行中心扩散，此时得到的回文子串的长度是奇数；<br>
2、如果传入相邻的索引编码，进行中心扩散，此时得到的回文子串的长度是偶数。</p>
</blockquote>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;

class Solution {

private:

    string centerSpread(string s, int left, int right) {
        // left = right 的时候，此时回文中心是一个空隙，向两边扩散得到的回文子串的长度是奇数
        // right = left + 1 的时候，此时回文中心是一个字符，向两边扩散得到的回文子串的长度是偶数
        int size = s.size();
        int i = left;
        int j = right;
        while (i &gt;= 0 &amp;&amp; j &lt; size) {
            if (s[i] == s[j]) {
                i--;
                j++;
            } else {
                break;
            }
        }
        // 这里要小心，跳出 while 循环时，恰好满足 s.charAt(i) != s.charAt(j)，因此不能取 i，不能取 j
        return s.substr(i + 1, j - i - 1);
    }

public:


    string longestPalindrome(string s) {
        // 特判
        int size = s.size();
        if (size &lt; 2) {
            return s;
        }

        int maxLen = 1;
        string res = s.substr(0, 1);

        // 中心位置枚举到 len - 2 即可
        for (int i = 0; i &lt; size - 1; i++) {
            string oddStr = centerSpread(s, i, i);
            string evenStr = centerSpread(s, i, i + 1);
            string maxLenStr = oddStr.size() &gt; evenStr.size() ? oddStr : evenStr;
            if (maxLenStr.length() &gt; maxLen) {
                maxLen = maxLenStr.size();
                res = maxLenStr;
            }
        }
        return res;
    }
};
</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(N^2)<br>
空间复杂度：O(1)，只使用到常数个临时变量，与字符串长度无关。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 54. 螺旋矩阵[中等]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-54-luo-xuan-ju-zhen-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-54-luo-xuan-ju-zhen-zhong-deng">
        </link>
        <updated>2020-01-16T01:35:45.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。<br>
示例 1:<br>
输入:<br>
[<br>
[ 1, 2, 3 ],<br>
[ 4, 5, 6 ],<br>
[ 7, 8, 9 ]<br>
]<br>
输出: [1,2,3,6,9,8,7,4,5]<br>
示例 2:<br>
输入:<br>
[<br>
[1, 2, 3, 4],<br>
[5, 6, 7, 8],<br>
[9,10,11,12]<br>
]<br>
输出: [1,2,3,4,8,12,11,10,9,5,6,7]<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/spiral-matrix<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>可以参考螺旋矩阵II<br>
设置四个边界 left right top bottom</p>
<p>实现中需要注意的点：<br>
1.不小心把bottom和right的赋值搞反了。。。<br>
2.和n*n的矩阵不同，这里必须每个循环都判断&amp;&amp;res.size()&lt;len，否则[[1,2,3,4],[5,6,7,8],[9,10,11,12]]最后会出现[1,2,3,4,8,12,11,10,9,5,6,7,6]那个6的情况（是正确的）</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        vector&lt;int&gt; res;
        if(matrix.empty()) return res;
        int top=0,bottom=matrix.size()-1,left=0,right=matrix[0].size()-1; 
        int len=(bottom+1)*(right+1);
        while(res.size()&lt;len){
            for(int i=left;i&lt;=right&amp;&amp;res.size()&lt;len;++i)
                res.push_back(matrix[top][i]);
            ++top;
            for(int i=top;i&lt;=bottom&amp;&amp;res.size()&lt;len;++i)
                res.push_back(matrix[i][right]);
            --right;
            for(int i=right;i&gt;=left&amp;&amp;res.size()&lt;len;--i)
                res.push_back(matrix[bottom][i]);
            --bottom;
            for(int i=bottom;i&gt;=top&amp;&amp;res.size()&lt;len;--i)
                res.push_back(matrix[i][left]);
            ++left;
        }
        return res;
    }
};
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>这里的方法不需要记录已经走过的路径，所以执行用时和内存消耗都相对较小<br>
首先设定上下左右边界<br>
其次向右移动到最右，此时第一行因为已经使用过了，可以将其从图中删去，体现在代码中就是重新定义上边界<br>
判断若重新定义后，上下边界交错，表明螺旋矩阵遍历结束，跳出循环，返回答案<br>
若上下边界不交错，则遍历还未结束，接着向下向左向上移动，操作过程与第一，二步同理<br>
不断循环以上步骤，直到某两条边界交错，跳出循环，返回答案</p>
</blockquote>
<pre><code>class Solution {
public:
    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        vector &lt;int&gt; ans;
        if(matrix.empty()) return ans; //若数组为空，直接返回答案
        int u = 0; //赋值上下左右边界
        int d = matrix.size() - 1;
        int l = 0;
        int r = matrix[0].size() - 1;
        while(true)
        {
            for(int i = l; i &lt;= r; ++i) ans.push_back(matrix[u][i]); //向右移动直到最右
            if(++ u &gt; d) break; //重新设定上边界，若上边界大于下边界，则遍历遍历完成，下同
            for(int i = u; i &lt;= d; ++i) ans.push_back(matrix[i][r]); //向下
            if(-- r &lt; l) break; //重新设定有边界
            for(int i = r; i &gt;= l; --i) ans.push_back(matrix[d][i]); //向左
            if(-- d &lt; u) break; //重新设定下边界
            for(int i = d; i &gt;= u; --i) ans.push_back(matrix[i][l]); //向上
            if(++ l &gt; r) break; //重新设定左边界
        }
        return ans;
    }
};
</code></pre>
<blockquote>
<p>时间复杂度： O(N)，其中 N 是输入矩阵所有元素的个数。因为我们将矩阵中的每个元素都添加进答案里。<br>
空间复杂度： O(N)，需要矩阵 ans 存储信息。</p>
</blockquote>
<p>这个就是我那种的变种，不过我使用了size来判断，他使用了边界条件了判断</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UNP-UNIX网络编程 第六章 select与poll]]></title>
        <id>https://lixin-ee.github.io//post/unp-unix-wang-luo-bian-cheng-di-liu-zhang-select-yu-poll</id>
        <link href="https://lixin-ee.github.io//post/unp-unix-wang-luo-bian-cheng-di-liu-zhang-select-yu-poll">
        </link>
        <updated>2020-01-15T12:52:00.000Z</updated>
        <content type="html"><![CDATA[<p>进程需要一种预先告知内核的能力，使得内核一旦发现进程指定的一个或多个I/O条件就绪（也就是说输入已准备好被读取，或者描述符已能承接更多的输出），它就通知进程。这个能力称为I/O复用（I/O multiplexing）,是由select和poll这两个函数支持的</p>
<p>I/O复用典型使用在下列网络应用场合。<br>
•当客户处理多个描述符（通常是交互式输入和网络套接字）时，必须使用I/O复用。<br>
•一个客户同时处理多个套接字是可能的，不过比较少见。<br>
•如果一个TCP服务器既要处理监听套接字，又要处理已连接套接字，一般就要使用I/O复 用<br>
•如果一个服务器即要处理TCP,又要处理UDP, —般就要使用I/O复用<br>
•如果一个服务器要处理多个服务或者多个协议（例如inetd守护进程），一般就要使用I/O复用。<br>
I/O复用并非只限于网络编程，许多重要的应用程序也需要使用这项技术。</p>
<h1 id="io-模型">I/O 模型</h1>
<p>UnixF可用的5种I/O模型 的基本区别：<br>
•阻塞式I/O；<br>
•非阻塞式I/O；<br>
• I/O复用（select和poll）； <br>
•信号驱动式I/O (SIGIO);<br>
•异步I/O (POSIX的aio_系列函数)。</p>
<p>下面的图中例子为UDP ，因为TCP为面向字节流，UDP的单个数据包更直观</p>
<ol>
<li>
<p>阻塞式I/O模型<br>
默认情形下，所有套接字都是阻塞的<br>
<img src="https://lixin-ee.github.io//post-images/1579093224765.png" alt=""><br>
进程在 从调用recvfrom（read）开始到它返回的整段时间内是被阻塞的。recvfrom（read）成功返回后，应用进程开始处理数据报。</p>
</li>
<li>
<p>非阻塞式I/O模型<br>
进程把一个套接字设置成非阻塞是在通知内核：当所请求的I/O操作非得把本进程投入睡眠才能完成时，不要把本进程投入睡眠，而是返回一个错误。<br>
<img src="https://lixin-ee.github.io//post-images/1579093371514.png" alt=""><br>
前三次调用recvfrom时没有数据可返回，因此内核转而立即返回一个EWOULDBLOCK错误。 第四次调用recvfrom时已有一个数据报准备好，它被复制到应用进程缓冲区，于是recvfrom成功返回。我们接着处理数据。<br>
当一个应用进程像这样对一个非阻塞描述符循环调用recvfrom时，我们称之为<strong>轮询 (polling)</strong>。应用进程持续轮询内核，以查看某个操作是否就绪。这么做往往耗费大量CPU时间, 通常是在专门提供某一种功能的系统中才有。</p>
</li>
<li>
<p>I/O复用模型<br>
有了I/O复用(I/O multiplexing),我们就可以调用select或poll，阻塞在这两个系统调用回中的某一个之上，而不是阻塞在<strong>真正的I/O系统调用</strong>上。<br>
<img src="https://lixin-ee.github.io//post-images/1579093496943.png" alt=""><br>
我们阻塞于select调用，等待数据报套接字变为可读。当select返回套接字可读这一条件时，我们调用recvfrom把所读数据报复制到应用进程缓冲区。<br>
如果仅仅是一个描述符，事实上由于使用select需要两个而不是单个系统调用，I/O复用还稍有劣势。使用select的优势在于我们可以等待多个描述符就绪。<br>
I/O复用模型与在多线程中使用阻塞式I/O比较相似</p>
</li>
<li>
<p>信号驱动式I/O模型<br>
信号驱动式I/O (signal-driven I/O )：让内核在描述符就绪时发送SIGlO信号通知我们。<br>
<img src="https://lixin-ee.github.io//post-images/1579093639201.png" alt=""><br>
1.我们首先开启套接字的信号驭动式I/O功能，并通过 sigaceion系统调用安装-个信号处理函数。<br>
2.该系统调用将立即返回，我们的进程继续工作， 也就是说它没有被阻塞。<br>
3.当数据报准备好读取时，内核就为该进程产生一个SIGIO信号。我们 随后既可以在信号处理函数中调用recvfrom读取数据报，并通知主循环数据已准备好待处理 ，也可以立即通知主循环，让它读取数据报。<br>
这种模型的优势在于等待数据报到达期间进程不被阻塞。主循 环可以继续执行，只要等待来自信号处理函数的通知</p>
</li>
<li>
<p>异步I/O模型<br>
工作机制是：告知内核启动某个操作，并让内核在整个操作（包括将数据从内核复制到我们自己的缓冲区）完成后通知我们。这种模型与前一节介绍的信号驱动模型的主要区别在于：信号驱动式I/O是由内核通知我们何时可以启动一个I/O操作，而异步I/O模型是由内核通知我们I/O操作何时完成。<br>
<img src="https://lixin-ee.github.io//post-images/1579093766030.png" alt=""><br>
1.调用aio_read函数（POSIX异步I/O函数以aio_或lio_开头），给内核传递描述符、缓冲区指针、缓冲区大小（与read相同的三个参数）和文件偏移（与Iseek类似），并告诉内核当 整个操作完成时如何通知我们<br>
2.该系统调用<strong>立即返回</strong>，而且在<strong>等待I/O完成</strong>期间，<strong>我们的进程不被阻塞。</strong><br>
本例子中我们假设要求内核在操作完成时产生某个信号。该信号直到数据已复制到应用进程缓冲区才产生，这一点不同于信号驱动式I/O模型。<br>
支持POSIX异步I/O模型的系统仍较罕见</p>
</li>
</ol>
<h1 id="各种io模型的比较">各种I/O模型的比较</h1>
<p>5种不同的I/O模型。可以看出，前4种模型的主要区别在于第一阶段，因 为它们的第二阶段是一样的：在数据从内核复制到调用者的缓冲区期间，进程阻塞于recvfrom 调用。相反，异步I/O模型在这两个阶段都要处理，从而不同于其他4种模型。</p>
<p>•同步I/O操作（synchronous I/O opetation）导致请求进程阻塞，直到I/O操作完成；<br>
•异步I/O操作（asynchronous I/O opetation）不导致请求进程阻塞。<br>
<img src="https://lixin-ee.github.io//post-images/1579094245836.png" alt=""></p>
<h1 id="select-函数">select 函数</h1>
<p>该函数允许进程指示内核等<strong>待多个事件中的任何一个发生</strong>，并<strong>只在有一个或多个事件发生</strong>或经历一段指定的时间后<strong>才唤醒它</strong>。<br>
我们调用select告知内核对哪些描述符（就读、写或异常条件）<strong>感兴趣以及等待多长时间</strong>。我们感兴趣的描述符不局限于套接字，<strong>任何描述符</strong>都可以使用select来测试。</p>
<pre><code>#include &lt;sys/select.h&gt;
#include &lt;sys/time.h&gt;
		int select (int maxfdpl, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout):
返回：若有就绪描述符则为其数目，若超时则为0,若出错则为1
</code></pre>
<p>最后一个参数timeout，它告知内核等待所指定描述符中的任何一个就绪可花多长时间。其timeval结构用于指定这段时间的秒数和微秒数。</p>
<pre><code>struct timeval {
long tv_sec;	/* seconds */
long tv_usec；	/* microseconds */
）;
</code></pre>
<p>这个参数有以下三种可能。<br>
（1）	永远等待下去：仅在有一个描述符准备好I/O时才返回。为此，我们把该参数设置为<strong>空指针</strong>。<br>
（2）	等待一段固定时间：在有一个描述符准备好I/O时返回，但是不超过由该参数所指向的 timeval结构中指定的秒数和微秒数。<br>
（3）	根本不等待：检查描述符后立即返回，这称为<strong>轮询（polling）</strong>。为此，该参数必须指向 回一个timeval结构，而且其中的定时器值（由该结构指定的秒数和微秒数）<strong>必须为0</strong>。<br>
前两种情形的等待通常<strong>会被进程在等待期间捕获的信号中断</strong>，并从信号处理函数返回。（<strong>注意，不是指前两种情况在等待信号，而是被信号强行中断</strong>）<br>
timeout参数的const限定词表示它在函数返回时不会被select修改</p>
<p>中间的三个参数readset、writeset和exceptset指定我们要让内核测试读、写和异常条件的描述符。<br>
select使用描述符集为它们指定一个或多个描述符值，通常是一个整数数组，其中每个整数中的每一位对应一个描述符。<br>
假设使用32位整数，那么该数组的第一个元素对应于描述符0〜31,第二个元素对应于描述符32〜63<br>
所有这些实现细节都与应用程序无关，它们隐藏在名为fd_set的数据类型和以下四个宏中；</p>
<pre><code>void FD_ZERO (fd_set *fdset);   // clear all bits in fdset 
void FD_SET (int fd, fd_set *fdset);  // turn on the bit for fd in fdset
void FD_CLR(int fd, fd_set *fdset};  // turn off the bit for fd in fdset
int FD_ISSET(int fd, fd_set *fdset};  // is the bit for fd on in fdset ? 
</code></pre>
<p>分配一个fd_set数据类型的描述符集，并用这些宏设置或测试该集合中的每一位<br>
代表一个描述符.</p>
<p>举个例子，以下代码用于定义一个fd_set类型的变量，然后打开描述符1、4和5的对应位:</p>
<pre><code>fd_set rset;
FD_ZERO(&amp;rset); //	initialize the set:	all bits off 
FD_SET(1, &amp;rset);//	turn	on	bit	for	fd	1	
FD_SET(4, &amp;rset);//	turn	on	bit	for	fd	4	
FD_SET(5, &amp;rset);//	turn	on	bit	for	fd	5	
</code></pre>
<p>select函数的中间三个参数readset、writeset和exceptset，如果我们对某一个的条件不感兴趣，就可以把它设为空指针。</p>
<p>maxfdpl参数指定待测试的描述符个数，它的值是待测试的最大描述符加1<br>
suoyi 描述符0, 1, 2...直到maxfdpl-1均将被测试</p>
<p>头文件＜sys/select.h＞中定义的FD_SETSIZE常值是数据类型fd_set中的描述符总数</p>
<p>select函数修改由指针readset、writeset和exceptset所指向的的描述符集，因而这三个参数 都是值-结果参数。调用该函数时，<strong>结果将指示哪些描述符已就绪</strong>。<br>
该函数返回后，我们使用FDISSET宏来测试fd_set数据类型中的描述符。 描述符集内任何与未就绪描述符对应的位返回时均清成0。<br>
为此，每次重新调用select函数时， 我们都得再次把所有描述符集内所关心的位均置为1。<br>
该函数的返回值表示跨所有描述符集的已就绪的总位数。如果在任何描述符就绪之前定时器到时，那么返回0。返回-1表示出错（这是可能发生的，譬如本函数被一个所捕获的信号中断）。</p>
<h1 id="描述符就绪条件">描述符就绪条件</h1>
<ol>
<li>
<p>满足下列四个条件中的任何一个时，一个套接字准备好读。<br>
a）	该套接字接收缓冲区中的数据字节数<strong>大于等于套接字接收缓冲区低水位标记</strong>的当前大小。对这样的套接字执行读操作不会阻塞并将返回一个大于0的值（也就是返回准备好读入的数据）。<strong>（注意，是读操作的函数比如read返回，不是select返回）</strong><br>
我们可以使用SO_RCVLOWAT套接字选项设置该套接字的低水位标记。对于TCP和UDP套接字而言，其<strong>默认值为1。</strong><br>
b）	该连接的<strong>读半部关闭</strong>（也就是<strong>接收了FIN的TCP连接</strong>）。对这样的套接字的读操作将不阻塞<strong>并返回0</strong> （也就是<strong>返回EOF</strong>）.<br>
c）	该套接字是一个<strong>监听套接字</strong>且<strong>已完成的连接数不为0</strong>。对这样的套接字的accept通常不会阻塞，<br>
d）其上有一个<strong>套接字错误待处理</strong>。对这样的套接字的读操作将不阻塞并<strong>返回-1</strong>（也就是<strong>返回一个错误</strong>），同时把<strong>errno设置成确切的错误条件</strong>。<br>
这些待处理错误（pending error）也可以通过指定SO_ERROR套接字选项调用getsockopt获取并清除。</p>
</li>
<li>
<p>下列四个条件中的任何一个满足时，一个套接字准备好写<br>
a）	该套接字发送缓冲区中的可用空间字节数大于等于套接字<strong>发送缓冲区低水位标记</strong>的当前大小，并且或者该套接字已连接，或者该套接字不需要连接（如UDP套接字）。<br>
这意味看如果我们把这样的套接字设置成非阻塞，写操作将不阻塞并返回一个正值（例如由传输层接 受的字节数）。<strong>（注意，是写操作的函数比如write返回，不是select返回）</strong><br>
我们可以使用SO_SNDLOWAT套接字选项来设置该套接字的低水位标记。对于TCP 和UDP套接字而言，其<strong>默认值通常为2048</strong>。<br>
b）	该连接的<strong>写半部关闭</strong>。对这样的套接字的<strong>写操作将产生SIGPIPE信号</strong>。<br>
c）	使用<strong>非阻塞式connect的</strong>套接字<strong>已建立连接</strong>，或者connect已经以失败告终。<br>
d）	其上有一个<strong>套接字错误待处理</strong>。对这样的套接字的写操作将不阻塞并返回-1 （也就是返回一个错误）</p>
</li>
<li>
<p>如果一个套接字存在带外数据或者仍处于带外标记，那么它有异常条件待处理</p>
</li>
</ol>
<p><strong>接收低水位标记</strong>和<strong>发送低水位标记</strong>的目的在于：允许应用进程控制在select返回可读或可写条件之前有多少数据可读或有多大空间可用于写。<br>
任何UDP套接字只要其发送低水位标记小于等于发送缓冲区大小（默认应该总是这种关系）就总是可写的，这是因为UDP套接字不需要连接。<br>
<img src="https://lixin-ee.github.io//post-images/1579095797113.png" alt=""></p>
<h1 id="str_cliselect版">str_cli	（select版）</h1>
<p>早先版本的问题在于：当套接字上发生某些事件时，客户可能阻塞于 fgets调用。<br>
新版本改为阻塞于select调用，或是等待标准输入可读，或是等待套接字可读。<br>
<img src="https://lixin-ee.github.io//post-images/1579095903751.png" alt=""><br>
客户的套接字上的三个条件处理如下。<br>
（1）	如果对端TCP发送数据，那么该套接字变为可读，并且read返回一个大于0的值（即读 入数据的字节数）。<br>
（2）	如果对端TCP发送一个FIN （对端进程终止），那么该套接字变为可读，并且read返回0 （EOF）。<br>
（3）	如果对端TCP发送一个RST （对端主机崩溃并重新启动），那么该套接字变为可读，并且read返回-1,而errno中含有确切的错误码。</p>
<pre><code>//strcliselect01.c
//Code by Lixin on 2020.01.16

#include &quot;unp.h&quot;

void
str_cli(FILE *fp,int sockfd)
{
	int maxfdp1;
	fd_set rset;
	char sendline[MAXLINE],recvline[MAXLINE];

	FD_ZERO(&amp;rset);
	for(;;){
		FD_SET(fileno(fp),&amp;rset);
		FD_SET(sockfd,&amp;rset);
		maxfdp1=max(fileno(fp),sockfd)+1;
		select(maxfdp1,&amp;rset,NULL,NULL,NULL);

		if(FD_ISSET(sockfd,&amp;rset))
			if(readline(sockfd,recvline,MAXLINE)==0)
				err_quit(&quot;str_cli:server terminated prematurely&quot;);
			fputs(recvline,stdout);

		if(FD_ISSET(fileno(fp),&amp;rset))
			if(fgets(sendline,MAXLINE,fp)==NULL)
				return;
			write(sockfd,sendline,strlen(sendline));
	}
}
</code></pre>
<p>需要一个用于检查可读性的描述符集。该集合由FD_ZERO初始化，并用FD_SET打开两位：一位对应于标准I/O文件指针fp,—位对应于套接字sockfd.</p>
<h1 id="批量输入">批量输入</h1>
<p>上一节的str_cli还是存在问题的<br>
问题的起因在于我们对标准输入中的EOF的处理，写完完成后后，我们并不能立即关闭整个连接，因为管道中还有其他的请求和应答。批量方式下，标准输入中的EOF并不意味着我们同时也完成了从套接字的读入；可能仍有请求在去往服务器的路上，或者仍有应答在返回客户的路上。<br>
我们需要的是一种关闭TCP连接其中一半的方法。也就是说，我们想给服务器发送一个FIN, 告诉它我们已经完成了数据发送，但是仍然保持套接字描述符打开以便读取。这由将在下一节讲述的shutdown函数来完成。</p>
<p>另外一个问题就是为提升性能而引入stdio的缓冲机制增加了网络应用程序的复杂性。<br>
考虑有多个来自标准输入的文本输入行可用的情况。select将使用fgets读取输入，这又转而使已可用的文本输入行被读入到stdio所用的缓冲区中。然而 fgets只返回其中第一行，其余输入行仍在stdio缓冲区中。wrtiten把fgets返回的单个输入 行写给服务器，随后select再次被调用以等待新的工作，而不管stdio缓冲区中还有额外的输入行待消费。<br>
究其原因在于select不知道stdio使用了缓冲区——它只是从read系统调用（亦即文件描述符）的角度指出是否有数据可读，而不是从fgets之类调用的角度考虑。<br>
基于上述原因，混合使用stdio和 select被认为是非常容易犯错误的，在这样做时必须极其小心。<br>
隐藏自身缓冲区的读函数例如readline也有类似的问题，可能的解决办法之一是修改我们的代码，在调用select之前使用那个函数， 以查看是否存在已经读入而尚未消费的数据。<br>
但是同时也会引入粘包分包问题，readline缓冲区中既可能有不完整 的输入行（意味着我们需要继续读入），也可能有一个或多个完整的输入行（这些行我们可以直接消费）。这两种情况而引入的复杂性会迅速增长到难以控制的地步。</p>
<h1 id="shutdown-函数">shutdown 函数</h1>
<p>终止网络连接的通常方法是调用close函数。不过close有两个限制，却可以使用shutdown 来避免。<br>
（1）	close把描述符的引用计数减1,仅在该计数<strong>变为0时才关闭套接字</strong>。使用<strong>shutdown可以不管引用计数就激发TCP的正常连接终止序列</strong>（图2-5中由FIN开始的4个分节）。<br>
（2）	close终止读和写两个方向的数据传送。<br>
<img src="https://lixin-ee.github.io//post-images/1579097744777.png" alt=""></p>
<pre><code>#include &lt;sys/socket.h&gt;
		int shutdown (int sockfd, int howto)；
				返回：若成功则为0,若出错则为-1
</code></pre>
<p>该函数的行为依赖于howto参数的值：<br>
SHUT_RD：关闭连接的读这一半——套接字中不再有数据可接收，而旦套接字接收缓冲区中的<strong>现有数据都被丢弃</strong>。进程不能再对这样的套接字调用任何读函数。对一个 TCP套接字这样调用shutdown函数后，由该套接字接收的来自对端的<strong>任何数据都被确认，然后悄然丢弃</strong>。<br>
SHUT_WR：关闭连接的写这一半——对于TCP套接字，这称为半关闭（half-close）。当前留在套接字发<strong>送缓冲区中的数据将被发送掉</strong>，后跟TCP的正常连接终止序列。不管套接字描述符的引用计数是否等于0,这样的写半部关闭照样执行。进程不能再对这样的套接字调用任何写函数。<br>
SHUT_RDWR：连接的读半部和写半部都关闭——这与调用shutdown两次等效：第一次调用指定SHUT_RD,第二次调用指定SHUT_WR。</p>
<h1 id="str_cli函数shoutdown版">str_cli函数（shoutdown版）</h1>
<p>使用了select和shutdown，其中前者只要<strong>服务器关闭它那一端的连接</strong>就会通知我们，后者允许我们正确地处理批量输入。<br>
这个版本还废弃了以文本行为中心的代码，改而针对缓冲区操作，从而消除了6.5节中提出的关于stdio或自身缓冲区的复杂性问题</p>
<pre><code>//strcliselect02.c
//Code by Lixin on 2020.01.16

#include &quot;unp.h&quot;

void
str_cli(FILE *fp,int sockfd)
{
	int maxfdp1;
	fd_set rset;
	char buf[MAXLINE];
	int n;

	int stdineof=0;
	FD_ZERO(&amp;rset);
	for(;;){
		if(stdineof==0)
			FD_SET(fileno(fp),&amp;rset);
		FD_SET(sockfd,&amp;rset);
		maxfdp1=max(fileno(fp),sockfd)+1;
		select(maxfdp1,&amp;rset,NULL,NULL,NULL);

		if(FD_ISSET(sockfd,&amp;rset)){
			if((n=read(sockfd,buf,MAXLINE))==0)
				if(stdineof==1)
					return;
				else 
						err_quit(&quot;str_cli:server terminated prematurely&quot;);
			write(fileno(stdout),buf,n);
		}

		if(FD_ISSET(fileno(fp),&amp;rset))	{
			if((n=read(fileno(fp),buf,MAXLINE))==0)
				stdineof=1;
				shutdown(sockfd,SHUT_WR);
				FD_CLR(fileno(fp),&amp;rset);
				continue;
		}
		write(sockfd,buf,n);
	}
}
</code></pre>
<p>stdineof是一个初始化为0的新标志。只要该标志为0,每次在主循环中我们总是 select标准输入的可读性。同时在标准输入上碰到EOF时，我们把新标志stdineof置为1,并把第二个参数指定 为SHUT_WR来调用shutdown以发送FIN</p>
<h1 id="tcp回射服务器程序select版">TCP回射服务器程序（select版）</h1>
<p>重写成使用select来处理<strong>任意个客户的单进程程序</strong>，而不是为每个客户派生一个子进程。<br>
初始状态：<br>
服务器有单个监听描述符，描述符0、 1和2将分别被设置为标准输入、标准输出和标准错误输出。可见监听套接字的第一个可用描述符是3。<br>
服务器只维护一个读描述符集，并使用一个名为client的整型数组，它含有每个客户的已连接套接字描述符。 该数组的所有元素都被初始化为-1.<br>
描述符集中唯一的非0项是表示监听套接字的项，因此select的第一个参数将为4。<br>
<img src="https://lixin-ee.github.io//post-images/1579098311810.png" alt=""><br>
客户连接状态：<br>
当第一个客户与服务器建立连接时，监听描述符变为可读，我们的服务器于是调用 accept.在本例的假设下，由accept返回的新的已连接描述符将是4。<br>
服务器必须在其client数组中记住每个新的已连接描述符，并把它加到 描述符集中去。<br>
<img src="https://lixin-ee.github.io//post-images/1579098323588.png" alt=""><br>
第二个客户与服务器建立连接，新的已连接描述符（假设是5）必须被记住<br>
<img src="https://lixin-ee.github.io//post-images/1579098366949.png" alt=""><br>
接着假设第一个客户终止它的连接。该客户的TCP发送一个FIN,使得服务器中的描述 符4变为可读。当服务器读这个已连接套接字时，read将返回0。我们于是关闭该套接字并相应 地更新数据结构：把client [0]的值置为-1,把描述符集中描述符4的位设置为0。注意，maxfd的值没有改变。<br>
<img src="https://lixin-ee.github.io//post-images/1579098406134.png" alt=""></p>
<p>总之，当有客户到达时，我们在client数组中的第-个可用项(即值为-1的第一个项)中 记录其已连接套接字的描述符。我们还必须把这个已连接描述符加到读描述符集中。<br>
变量maxi 是client数组当前使用项的最大下标，而变量maxfd (加1之后)是select函数第一个参数的 当前值。<br>
本服务器所能处理的<strong>最大客户数目的限制</strong>是以下两个值中的较小者：<strong>FD_SETSIZE</strong> 和<strong>内核允许本进程打开的最大描述符数</strong></p>
<pre><code>//tcpservselect01.c
//Code by Lixin on 2020.01.16

#include &quot;unp.h&quot;

int main(int argc,char **argv)
{
	int i,maxi,maxfd,listenfd,connfd,sockfd;
	int nready,client[FD_SETSIZE];
	ssize_t n;
	fd_set rset,allset;
	char buf[MAXLINE];
	socklen_t clilen;
	struct sockaddr_in servaddr,cliaddr;

	listenfd=socket(AF_INET,SOCK_STREAM,0);

	bzero(&amp;servaddr,sizeof(servaddr));
	servaddr.sin_family=AF_INET;
	servaddr.sin_port=htons(SERV_PORT);
	servaddr.sin_addr.s_addr=htonl(INADDR_ANY);

	bind(listenfd,(SA *)&amp;servaddr,sizeof(servaddr));
	listen(listenfd,LISTENQ);

	maxfd=listenfd;
	maxi=-1;
	for(i=0;i&lt;FD_SETSIZE;++i)
		client[i]=-1;
	FD_ZERO(&amp;allset);
	FD_SET(listenfd,&amp;allset);

	for(;;){
		rset=allset;
		nready=select(maxfd+1,&amp;rset,NULL,NULL,NULL);

		if(FD_ISSET(listenfd,&amp;rset)){
			clilen=sizeof(cliaddr);
			connfd=accept(listenfd,(SA *)&amp;cliaddr,&amp;clilen);
			for(i=0;i&lt;FD_SETSIZE;++i)
				if(client[i]&lt;0){
					client[i]=connfd;
					break;
				}
			if(i==FD_SETSIZE)
				err_quit(&quot;too many clients&quot;);
			FD_SET(connfd,&amp;allset);
			if(connfd&gt;maxfd)
				maxfd=connfd;
			if(i&gt;maxi)
				maxi=i;

			if(--nready&lt;=0)
				continue;
		}
		for(i=0;i&lt;maxi;i++){
			if((sockfd=client[i])&lt;0)
				continue;
			if(FD_ISSET(sockfd,&amp;rset)){
				if((n=read(sockfd,buf,MAXLINE))==0){
					close(sockfd);
					FD_CLR(sockfd,&amp;allset);
					client[i]=-1;
				}else{
					write(sockfd,buf,n);
				}
				if(--nready&lt;=0)
					continue;
			}
		}
	}
}
</code></pre>
<p>拒绝服务型攻击<br>
不幸的是，我们刚刚给出的服务器程序存在一个问题<br>
如果有一个恶意的客尸连 接到该服务器，发送一个字节的数据（不是换行符）后进入睡眠，服务器将调 用read,它从客户读入这个单字节的数据，然后阻塞于下一个read调用（注意这里的下一个read指的是readline内部 的read调用（readline总是要读到换行符或EOF才返回）），以等待来自该客户的 其余数据。服务器于是因为这么一个客户而被阻塞（称它被&quot;挂起&quot;也许更确切些），不能再 为其他任何客户提供服务（不论是接受新的客户连接还是读取现有客户的数据），直到那个恶意 客户发出一个换行符或者终止为止。<br>
（注意，对于<strong>不再面向文本行的回射服务</strong>来说，Stevens先生讲述的由于等待读入换行符或EOF而引起的拒绝服务攻击<strong>己不复存在</strong>。只有readline这种才会被挂起）</p>
<p>当一个服务器在处理多个客户时，它绝对不能阻塞于只与单个客 户相关的某个函数调用。否则可能导致服务器被挂起，拒绝为所有其他客户提供服务。这就是所谓的拒绝服务（denial of service）型攻击。<br>
解决办法包括：（a）使用非阻塞式I/O ；（b）让每个客户由单独的控制线程提供服务（例如创建一个子进程或一个线程来服务每个客户）；（c）对 I/O操作设置已个超时</p>
<h1 id="pselect-函数">pselect 函数</h1>
<p>pselect函数是由POSIX发明的，如今有许多Unix变种支持它。</p>
<pre><code>#include &lt;sys/select.h&gt;
#include &lt;signal.h&gt;
#include &lt;time.h&gt;
		int pselect (int maxfdpl, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timespec * timeout, const sigset_t *sigmask）；
返回：若有就绪描述符则为其数目，若超时则为0,若出错则为-1
</code></pre>
<p>pselect相对于通常的select有两个变化。<br>
(1)	pselect使用timespec结构，而不使用timeval结构。<br>
imespec结构是POSIX的又一个 发明。</p>
<pre><code>struct timespec ( 
			time_t tv_sec;	/* seconds */
			long tv_nsec；	/* nanoseconds */
}；
</code></pre>
<p>这两个结构的区别在于第二个成员：新结构的该成员tv_nsec指定纳秒数，而旧结构的该成员 tv_usec指定微秒数。<br>
(2)	pselect函数增加了第六个参数：一个指向信号掩码的指针。该参数允许程序先禁止递 交某些信号，再测试由这些当前被禁止信号的信号处理函数设置的全局变量，然后调用 pselect,告诉它重新设置信号掩码。<br>
当pselect被调用时，它先以参数sigmask替代进程的信号掩码，再检查描述符，并可能进入睡眠。然而当pselect函数返回 时，进程的信号掩码又被重置为调用pselect之前的值</p>
<h1 id="poll-函数">poll 函数</h1>
<p>poll提供的功能与select类似，不过在处理流设备时，它能够提供额外 的信息</p>
<pre><code>#include &lt;poll.h&gt;
			int poll （struct pollfd *fdarray, unsigned long nfds, int timeout）;
返回：若有就绪描述符则为其数目，若超时则为0，若出错则为-1
</code></pre>
<p>第一个参数是指向一个结构数组第一个元素的指针。每个<strong>数组元素</strong>都是一个<strong>pollfd结构</strong>， 用于指定测试某个给定描述符fd的条件。<br>
pollfd结构数组中元素的个数是由nfds参数指定<br>
timeout参数数指定poll函数返回前等待多长时间</p>
<p>pollfd结构：</p>
<pre><code>struct pollfd {
		int	fd；	/*descriptor to check */
		short	events；	/*	events of interest on fd */
		short	revents；	/*	events that occurred on fd */
};
</code></pre>
<p>要测试的条件由events成员指定，函数在相应的revents成员中返回该描述符的状态。<br>
通过两个变量避免了使用值-结果参数，而select函数的中间三个参数都是值-结果参数。<br>
这两个成员中的每一个都由指定某个特定条件的一位或多位构成。图列出了用于指定events标志以及测试revents标志的一些常值。<br>
<img src="https://lixin-ee.github.io//post-images/1579177097676.png" alt=""><br>
将该图分为三个部分：<br>
第一部分是处理<strong>输入</strong>的四个常值<br>
第二部分是处理<strong>输出</strong>的三个常值<br>
第三部分是处理<strong>错误</strong>的三个常值。其中第三部分的三个常值<strong>不能在events中设置</strong>，但是当相应条件存在时就<strong>在revents中返回</strong>。</p>
<p>poll识别三类数据：普通（normal）、优先级带（priorityband）和高优先级（highpriority）。 这些术语均出自基于流的实现</p>
<p>就TCP和UDP套接字而言，以下条件引起poll返回特定的revent。（不幸的是POSIX在其poll的定义中留了许多空洞（也就是说有<strong>多种方法可返回相同的条件</strong>））。<br>
•所有正规TCP数据和所有UDP数据都被认为是<strong>普通数据</strong>。<br>
•TCP的带外数据被认为是优先级带数据。<br>
•当TCP连接的读半部关闭时（譬如收到了一个来自对端的<strong>FIN</strong>）,也被认为是<strong>普通数据</strong>， 随后的<strong>读操作将返回0</strong>。<br>
•TCP连接存在<strong>错误</strong>既可认为是<strong>普通数据</strong>，也可认为是<strong>错误</strong>（POLLERR）。无论哪种情况， 随后的读操作将返回-1,并把errno设置成合适的值。这可用于处理诸如接收到RST或 发生超时等条件。<br>
•在监听套接字上有<strong>新的连接可用</strong>既可认为是<strong>普通数据</strong>，也可认为是<strong>优先级数据</strong>。大多数 实现视之为普通数据。<br>
•<strong>非阻塞式</strong>connect的完成被认为是使<strong>相应套接字可写</strong>。</p>
<p>当发生错误时，poll函数的返回值为-1,若定时器到时之前没有任何描述符就绪，则返回0,否则返回就绪描述符的个数，即revents成员值非0的描述符个数。<br>
如果我们不再关心某个特定描述符，那么可以把与它对应的pollfd结构的fd成员设置成一个<strong>负值</strong>。poll函数将忽略这样的pollfd结构的events成员，返回时将它的revents成员的值置为0。<br>
select函数需要考虑FD_SETSIZE以及就每个描述符集中最大描述符数，poll函数中则不存在那样的问题，因为分配一个pollfd结构的 数组并把该数组中元素的数目通知内核成了调用者的责任（结构数组中元素的个数是由nfds参数指定）。内核不再需要知道类似fd_set的固定大小的数据类型。</p>
<h1 id="tcp回射服务器程序poll版">TCP回射服务器程序（poll版）</h1>
<pre><code>//tcpservpoll01.c
//Code by Lixin on 2020.01.16

#include &quot;unp.h&quot;
#include&lt;limits.h&gt;

#define OPEN_MAX 1024

int main(int argc,char **argv){
	int i,maxi,listenfd,connfd,sockfd;
	int nready;
	ssize_t n;
	char buf[MAXLINE];
	socklen_t clilen;
	struct sockaddr_in servaddr,cliaddr;
	struct pollfd client[OPEN_MAX];

	listenfd=socket(AF_INET,SOCK_STREAM,0);

	bzero(&amp;servaddr,sizeof(servaddr));
	servaddr.sin_family=AF_INET;
	servaddr.sin_addr.s_addr=htonl(INADDR_ANY);
	servaddr.sin_port=htons(SERV_PORT);

	bind(listenfd,(SA *)&amp;servaddr,sizeof(servaddr));

	listen(listenfd,LISTENQ);

	client[0].fd=listenfd;
	client[0].events=POLLRDNORM;
	for(i=0;i&lt;OPEN_MAX;++i)
		client[i].fd=-1;
	maxi=0;

	for(;;){
		nready=poll(client,maxi+1,INFTIM);

		if(client[0].revents&amp;POLLRDNORM){
			clilen=sizeof(cliaddr);
			connfd=accept(listenfd,(SA *)&amp;cliaddr,&amp;clilen);

			for(i=1;i&lt;OPEN_MAX;++i){
				if(client[i].fd&lt;0){
					client[i].fd=connfd;
					client[i].events=POLLRDNORM;
					break;
				}
				if(i==OPEN_MAX)
					perror(&quot;OPEN_MAX&quot;);

				if(i&gt;maxi)
					maxi=i;
				if(--nready&lt;=0)
					continue;
			}
		}
		
		for(i=1;i&lt;maxi;++i){
			if((sockfd=client[i].fd)&lt;0)
				continue;
			if(client[i].revents&amp;(POLLRDNORM||POLLERR)){
				if((n=read(sockfd,buf,MAXLINE))&lt;0){
					if(errno==ECONNRESET){
						close(sockfd);
						client[i].fd=-1;
					}else
						perror(&quot;read_error&quot;);
				}else if(n==0){
					close(sockfd);
					client[i].fd=-1;
				}else
					write(sockfd,buf,n);

				if(--nready&lt;=0)
					continue;
			}		
		}	
	}
}

</code></pre>
<p>以与select中处理client数组相同的方法处理该数组的fd成员：值-1表示所在项未用，否则即为描述符值。<br>
我们把client数组的第一项用于监听套接字，并把其余各项的描述符成员置为-1。我们还给第一项设置<strong>POLLRDNORM事件</strong>，这样当有<strong>新的连接</strong>准备好被接受时poll将通知我们。<br>
maxi变量含有client数组当前正在使用的最大下标值。<br>
新连接到达时，从下标1开始搜索，因为client [0]固定用于监听套接字。找到第一个可用项之后，我们把新连接的描述符保存到其中，并设置event为POLLRDNORM事件。<br>
检查的两个返回事件是POLLRDNORM和POLLERR，没有在event成员中 设置第二个事件，因为它在条件成立时总是返回。<br>
检查POLLERR的原因在于：有些实现在一个连接上接收到<strong>RST</strong>时返回的是<strong>POLLERR事件</strong>，而其他实现返回的<strong>只是POLLRDNORM事件</strong>。不论哪种情形，我们都调用read,当有错误发生时，read将返回这个错误。当一个现有连接由它的客户<strong>终止时</strong>，我们就把它的<strong>fd成员置为-1</strong>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 61. 旋转链表[中等]]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-61-xuan-zhuan-lian-biao-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-61-xuan-zhuan-lian-biao-zhong-deng">
        </link>
        <updated>2020-01-14T14:02:39.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。<br>
示例 1:<br>
输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2<br>
输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br>
解释:<br>
向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL<br>
向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br>
示例 2:<br>
输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4<br>
输出: 2-&gt;0-&gt;1-&gt;NULL<br>
解释:<br>
向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL<br>
向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL<br>
向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL<br>
向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/rotate-list<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>和数组 189.旋转数组比较像<br>
首先一个指针判断长度len<br>
然后把k和len取余数<br>
然后找到倒数第k个节点<br>
弄一个ehead，截断放到前面，和原head连接起来</p>
<p>细节问题比较重要 比如k=0的情况 还有循环的判断条件等，比如后面应该是找到倒数k+1个数，比如12345，要找到3而不是4，因为需要把ehead接到4</p>
<pre><code>class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        ListNode *ehead=new ListNode(0);
        ehead-&gt;next=head;
        ListNode* cur=ehead;
        int len=0;
        while(cur-&gt;next){
            ++len;
            cur=cur-&gt;next;
        }     
        if(len==0||len==1) return head;
        k=k%len;
        if(!k) return head;
        int count=len-k;
        ListNode* end=cur;
        cur=ehead;
        while(count--)
            cur=cur-&gt;next;
        ehead-&gt;next=cur-&gt;next;
        cur-&gt;next=NULL;
        end-&gt;next=head;
        return ehead-&gt;next;
    }
};
</code></pre>
<p>官方题解还是比较有趣的，在计算长度的过程中顺带连接成环，再在相应的位置断开，免去了后面的操作。同时一定要记得设置尾节点的next为null，否则输出时会无限循环打印<br>
官方题解：<br>
方法 1：<br>
直觉<br>
链表中的点已经相连，一次旋转操作意味着：<br>
先将链表闭合成环<br>
找到相应的位置断开这个环，确定新的链表头和链表尾<br>
新的链表头在哪里？<br>
在位置 n-k 处，其中 n 是链表中点的个数，新的链表尾就在头的前面，位于位置 n-k-1。<br>
我们这里假设 k &lt; n<br>
如果 k &gt;= n 怎么处理？<br>
k 可以被写成 k = (k // n) * n + k % n 两者加和的形式，其中前面的部分不影响最终的结果，因此只需要考虑 k%n 的部分，这个值一定比 n 小。<br>
算法<br>
算法实现很直接：<br>
找到旧的尾部并将其与链表头相连 old_tail.next = head，整个链表闭合成环，同时计算出链表的长度 n。<br>
找到新的尾部，第 (n - k % n - 1) 个节点 ，新的链表头是第 (n - k % n) 个节点。<br>
断开环 new_tail.next = None，并返回新的链表头 new_head。<br>
实现</p>
<pre><code>class Solution {
  public ListNode rotateRight(ListNode head, int k) {
    // base cases
    if (head == null) return null;
    if (head.next == null) return head;

    // close the linked list into the ring
    ListNode old_tail = head;
    int n;
    for(n = 1; old_tail.next != null; n++)
      old_tail = old_tail.next;
    old_tail.next = head;

    // find new tail : (n - k % n - 1)th node
    // and new head : (n - k % n)th node
    ListNode new_tail = head;
    for (int i = 0; i &lt; n - k % n - 1; i++)
      new_tail = new_tail.next;
    ListNode new_head = new_tail.next;

    // break the ring
    new_tail.next = null;

    return new_head;
  }
}
</code></pre>
<p>复杂度分析<br>
时间复杂度：O(N)，其中 N 是链表中的元素个数<br>
空间复杂度：O(1)，因为只需要常数的空间</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 16. 最接近的三数之和[中等][未做出][双指针]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-16-zui-jie-jin-de-san-shu-zhi-he-zhong-deng-wei-zuo-chu-shuang-zhi-zhen</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-16-zui-jie-jin-de-san-shu-zhi-he-zhong-deng-wei-zuo-chu-shuang-zhi-zhen">
        </link>
        <updated>2020-01-14T01:27:41.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。<br>
例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.<br>
与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/3sum-closest<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>【未做出】<br>
一开始我想的是贪心算法，三个位置各选其一，不断比较当前值和三个位置的值的和来决定要不要更换、和哪一位更换<br>
但是例如[-10,1,1,1,10]和target=0的情况下，最后选出[1,1,1]肯定不是我们想要的结果</p>
<p>tag是双指针，暂时没啥帮助</p>
<p>我想到的第一个是先排序，然后寻找和target最接近的数，然后再使得剩下两个数之和尽可能小（但是如果target远大于nums中的最大值，我们反而希望是两数之和越大越好）</p>
<p>没思路 看题解<br>
题解的思路主要是线排序，然后固定一个值，然后把该值后面的数组通过双指针进行缩减判断</p>
<p>题解中有个优化挺不错的，值得参考</p>
<pre><code>class Solution {
public:
    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) {
        int len=nums.size();
        int ans=nums[0]+nums[1]+nums[len-1];
        quicksort(nums,0,len-1);
        for(int i=0;i&lt;len;++i){
            int res;
            for(int j=i+1,k=len-1;j&lt;k;){
                res=nums[i]+nums[j]+nums[k];
                ans=abs(ans-target)&lt;abs(res-target)?ans:res;
                if(ans==target) return ans;
                if(res&gt;target)
                    --k;
                else
                    ++j;
            }
        }
        return ans;
    }
    
    void quicksort(vector&lt;int&gt; &amp;nums,int beg,int end){
        if(beg&lt;end){
            int mid=partition(nums,beg,end);
            quicksort(nums,beg,mid-1);
            quicksort(nums,mid+1,end);
        }
    }
    
    int partition(vector&lt;int&gt; &amp;nums,int beg,int end){
        int pivotkey=nums[beg];
        while(beg&lt;end){
            while(beg&lt;end&amp;&amp;pivotkey&lt;=nums[end])
                --end;
            nums[beg]=nums[end];
            while(beg&lt;end&amp;&amp;pivotkey&gt;=nums[beg])
                ++beg;
            nums[end]=nums[beg];
        }
        nums[beg]=pivotkey;
        return beg;
    }
};
</code></pre>
<p>看看网友的高赞题解和优化题解：<br>
解题方案</p>
<blockquote>
<p>思路<br>
标签：排序和双指针<br>
本题目因为要计算三个数，如果靠暴力枚举的话时间复杂度会到 O(n^3)，需要降低时间复杂度<br>
首先进行数组排序，时间复杂度 O(nlogn)<br>
在数组 nums 中，进行遍历，每遍历一个值利用其下标i，形成一个固定值 nums[i]<br>
再使用前指针指向 start = i + 1 处，后指针指向 end = nums.length - 1 处，也就是结尾处<br>
根据 sum = nums[i] + nums[start] + nums[end] 的结果，判断 sum 与目标 target 的距离，如果更近则更新结果 ans<br>
同时判断 sum 与 target 的大小关系，因为数组有序，如果 sum &gt; target 则 end--，如果 sum &lt; target 则 start++，如果 sum == target 则说明距离为 0 直接返回结果<br>
整个遍历过程，固定值为 n 次，双指针为 n 次，时间复杂度为 O(n^2)<br>
总时间复杂度：O(nlogn) + O(n^2) = O(n^2)</p>
</blockquote>
<pre><code>class Solution {
    public int threeSumClosest(int[] nums, int target) {
        Arrays.sort(nums);
        int ans = nums[0] + nums[1] + nums[2];
        for(int i=0;i&lt;nums.length;i++) {
            int start = i+1, end = nums.length - 1;
            while(start &lt; end) {
                int sum = nums[start] + nums[end] + nums[i];
                if(Math.abs(target - sum) &lt; Math.abs(target - ans))
                    ans = sum;
                if(sum &gt; target)
                    end--;
                else if(sum &lt; target)
                    start++;
                else
                    return ans;
            }
        }
        return ans;
    }
}
</code></pre>
<p>优化题解：<br>
双指针法的解题思路<br>
先让数组有序，也就是需要先对数组进行排序<br>
然后每次固定一个元素，再去寻找另外两个元素，也就是双指针<br>
双指针法的代码实现<br>
利用 Arrays.sort(nums) 对数组进行排序。<br>
初始化一个用于保存结果的值 result = nusm[0] + nums[1] + nums[2] （不要自己设初值，直接从数组中抽取三个元素，假设这是最接近的三数之和，然后再更新就是了）。<br>
利用下标 i 对数组进行遍历，此时就是在固定第一个元素，注意，下标 i 的边界为 i &lt; nums.length-2，否则设置指针的时候会出现数组越界。<br>
每次遍历的过程中设置两个指针，分别是 left = i + 1、right = nums.length - 1。<br>
检查 sum = nums[i] + nums[left] + nums[right]与 target 的距离，如果该距离比之前保存的 result 与 target 的距离更小，就更新 result。<br>
然后就是移动双指针。<br>
如果 sum 的值比 target 大，那么我们让 right--，因为数组是有序的，right --会使得下一次的 sum 更小，也就更接近 target 的值<br>
同理，如果 sum 的值 target 小，那么我们让 left++。·<br>
left++ 和 right-- 的界限自然是 left != right，如果 left == right，说明我们已经将所有的元素都遍历过一遍了。<br>
重复上面的操作，直到i循环结束为止，返回 result。<br>
下面是具体的代码实现，简单，但是效率也不高，还可以进行一些优化</p>
<pre><code>class Solution {
    public int threeSumClosest(int[] nums, int target) {
        Arrays.sort(nums);
        int result = nums[0] + nums[1] + nums[2];
        for(int i=0;i&lt;nums.length-2;i++){
            int left = i+1;
            int right = nums.length - 1;
            while(left != right){
                int sum = nums[i] + nums[left] + nums[right];
                if(Math.abs(sum - target) &lt; Math.abs(result - target))
                    result = sum;
                if(sum &gt; target){
                    right--;
                }
                else{
                    left++;
                }
            }
        }
        return result;
    }
｝
</code></pre>
<p>双指针法的优化<br>
元素重复的问题<br>
举个例子，nums = [1,1,1,2,3] target = 7，那么最终的结果应该是 6 (1 + 2 + 3)。<br>
但是按照上面的代码，在遍历的时候 nums[i]会重复的等于 1 这个数，但是其实之前 nums[i] 等于 1 已经遍历过了，后面的遍历都属于无用的遍历。<br>
所以可以添加去重的操作</p>
<pre><code>class Solution {
    public int threeSumClosest(int[] nums, int target) {
        Arrays.sort(nums);
        int result = nums[0] + nums[1] + nums[2];
        for(int i=0;i&lt;nums.length-2;i++){
            int left = i+1;
            int right = nums.length - 1;
            while(left != right){
                int sum = nums[i] + nums[left] + nums[right];
                if(Math.abs(sum - target) &lt; Math.abs(result - target))
                    result = sum;
                if(sum &gt; target){
                    right--;
                    // 解决nums[right]重复
                    while(left != right &amp;&amp; nums[right] == nums[right+1])
                        right--;
                }
                else{
                    left++;
                    // 解决nums[left]重复
                    while(left != right &amp;&amp; nums[left] == nums[left-1])
                        left++;
                }
            }
            // 解决nums[i]重复
            while(i&lt;nums.length-2 &amp;&amp; nums[i] == nums[i+1])
                i++;
        }
        return result;
    }
}
</code></pre>
<p>超越界限的问题<br>
举个例子，nums = [-3,-1,3,4,5]。<br>
假设 i = 0，left = 1，right = 4，那么每次 left 和 right 之间都有许多元素，那么 left 和 right 之间的元素之和肯定也有一个最小值和一个最大值。<br>
就如同 left = 1，right = 4，那么移动指针的情况下，nums[left] + nums[right] 的最小值肯定为 nums[left] + nums[left + 1]，因为这两个元素是 left 和 right 范围内能取到的最小的两个元素，同理可证最大值。<br>
如果 target 的值比 nums[i] + nums[left] + nums[left + 1] 的值还小，那么双指针无论怎么取，最后都会取到 nums[i] + nums[left] + nums[left + 1]。<br>
同理可证 target 的值比nums[i] + nums[right] + nums[right - 1] 的值还大的情况。<br>
所以可以增加一个判断，满足条件的情况下就可以直接取值，而不需要双指针一步步的判断来进行取值，减少了双指针的移动。</p>
<pre><code>class Solution {
    public int threeSumClosest(int[] nums, int target) {
        Arrays.sort(nums);
        int result = nums[0] + nums[1] + nums[2];
        for(int i=0;i&lt;nums.length-2;i++){
            int left = i+1;
            int right = nums.length - 1;
            while(left != right){
                // 判断最小值
                int min = nums[i] + nums[left] + nums[left + 1];
                if(target &lt; min){
                    if(Math.abs(result - target) &gt; Math.abs(min - target))
                        result = min;
                    break;
                }
                //判断最大值
                int max = nums[i] + nums[right] + nums[right - 1];
                if(target &gt; max){
                    if(Math.abs(result - target) &gt; Math.abs(max - target))
                        result = max;
                    break;  
                }
                int sum = nums[i] + nums[left] + nums[right];
                if(Math.abs(sum - target) &lt; Math.abs(result - target))
                    result = sum;
                if(sum &gt; target){
                    right--;
                    while(left != right &amp;&amp; nums[right] == nums[right+1])
                        right--;
                }
                else{
                    left++;
                    while(left != right &amp;&amp; nums[left] == nums[left-1])
                        left++;
                }
            }
            while(i&lt;nums.length-2 &amp;&amp; nums[i] == nums[i+1])
                i++;
        }
        return result;
    }
}
</code></pre>
<p>三数之和等于 target 的问题<br>
举个例子，nums = [1,1,2,3,4,5,6,10] target = 12，那么最终的结果应该是 12 (1 + 1 + 10)。<br>
有些时候，可能会直接找到三数之和等于 target 的情况，此时直接返回结果即可，不需要在进行之后的循环，因为不可能有数比他自己更接近自己了。</p>
<pre><code>class Solution {
    public int threeSumClosest(int[] nums, int target) {
        Arrays.sort(nums);
        int result = nums[0] + nums[1] + nums[2];
        for(int i=0;i&lt;nums.length-2;i++){
            int left = i+1;
            int right = nums.length - 1;
            while(left != right){
                int min = nums[i] + nums[left] + nums[left + 1];
                if(target &lt; min){
                    if(Math.abs(result - target) &gt; Math.abs(min - target))
                        result = min;
                    break;
                }
                int max = nums[i] + nums[right] + nums[right - 1];
                if(target &gt; max){
                    if(Math.abs(result - target) &gt; Math.abs(max - target))
                        result = max;
                    break;  
                }
                int sum = nums[i] + nums[left] + nums[right];
                // 判断三数之和是否等于target
                if(sum == target)
                    return sum;
                if(Math.abs(sum - target) &lt; Math.abs(result - target))
                    result = sum;
                if(sum &gt; target){
                    right--;
                    while(left != right &amp;&amp; nums[right] == nums[right+1])
                        right--;
                }
                else{
                    left++;
                    while(left != right &amp;&amp; nums[left] == nums[left-1])
                        left++;
                }
            }
            while(i&lt;nums.length-2 &amp;&amp; nums[i] == nums[i+1])
                i++;
        }
        return result;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ UNP-UNIX网络编程 第五章 echo程序]]></title>
        <id>https://lixin-ee.github.io//post/unp-unix-wang-luo-bian-cheng-di-wu-zhang-echo-cheng-xu</id>
        <link href="https://lixin-ee.github.io//post/unp-unix-wang-luo-bian-cheng-di-wu-zhang-echo-cheng-xu">
        </link>
        <updated>2020-01-13T08:34:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="回显echo服务器">回显（echo）服务器：</h1>
<p>(1)	客户从标准输入读入一行文本，并写给服务器；<br>
(2)	服务器从网络输入读入这行文本，并回射给客户；<br>
(3)	客户从网络输入读入这行回射文本，并显示在标准输出上。<br>
<img src="https://lixin-ee.github.io//post-images/1578904558967.png" alt=""></p>
<ul>
<li>服务器程序</li>
</ul>
<pre><code>//tcpserv01.c
//Code by Lixin on 2020/01/13

#include &quot;unp.h&quot;

int main(int argc,char **argv){
	int listenfd,connfd;
	pid_t childpid;
	socklen_t clilen;
	struct sockaddr_in cliaddr,servaddr;
	listenfd=socket(AF_INET,SOCK_STREAM,0);

	bzero(&amp;servaddr,sizeof(servaddr));
	servaddr.sin_family=AF_INET;
	servaddr.sin_addr.s_addr=htonl(INADDR_ANY);
	servaddr.sin_port=htons(SERV_PORT);

	bind(listenfd,(SA *)&amp;servaddr,sizeof(servaddr));
	listen(listenfd,LISTENQ);
	for(;;){
		clilen=sizeof(cliaddr);
		connfd=accept(listenfd,(SA *)&amp;cliaddr,&amp;clilen);
		if((childpid=fork())==0){
			close(listenfd);
			str_echo(connfd);
			exit(0);
		}
		close(connfd);
	}
}
</code></pre>
<p>创建一个TCP套接字。在待捆绑到该TCP套接字的网际网套接字地址结构中填入通配地址（INADDR_ANY）和服务器的众所周知端口（SERV_PORT,在头文件unp.h中其值定 义为9877）。</p>
<ul>
<li>TCP回射服务器程序：str_echo函数</li>
</ul>
<pre><code>//str_echo.c
//Code by Lixin on 2020/01/13

#include &quot;unp.h&quot;

void str_echo(int sockfd){
	ssize_t n;
	char buf[MAXLINE];

	while((n=read(sockfd,buf,MAXLINE))){
		if(n&gt;0)
			Writen(sockfd,buf,n);
		else if(n&lt;0&amp;&amp;errno==EINTR)
			continue;
		else if(n&lt;0)
			err_sys(&quot;str_echo:read error&quot;);
	}
}
</code></pre>
<ul>
<li>客户端程序：</li>
</ul>
<pre><code>//tcpcli01.c
//Code by Lixin on 2020/01/13

#include &quot;unp.h&quot;
int main(int argc,char** argv){
	int sockfd;
	struct sockaddr_in servaddr;

	if(argc!=2)
		err_quit(&quot;usage:tcpcli&lt;IPaddress&gt;&quot;);
	
	sockfd=socket(AF_INET,SOCK_STREAM,0);

	bzero(&amp;servaddr,sizeof(servaddr));
	servaddr.sin_family=AF_INET;
	servaddr.sin_port=htons(SERV_PORT);
	inet_pton(AF_INET,argv[1],&amp;servaddr.sin_addr);
	connect(sockfd,(SA *)&amp;servaddr,sizeof(servaddr));
	str_cli(stdin,sockfd);
	exit(0);
}
</code></pre>
<ul>
<li>TCP回射客户程序：str_cli函数</li>
</ul>
<pre><code>//str_cli.c
//Code by Lixin on 2020/01/13

#include &quot;unp.h&quot;

void str_cli(FILE *fp,int sockfd)
{
	char sendline[MAXLINE],recvline[MAXLINE];

	while(fgets(sendline,MAXLINE,fp)!=NULL){
		writen(sockfd,sendline,strlen(sendline));
		if(readline(sockfd,recvline,MAXLINE)==0)
			err_quit(&quot;str_cli:server terminated prematurely&quot;);
		fputs(recvline,stdout);
	}
}
</code></pre>
<h1 id="正常启动">正常启动</h1>
<p>服务器启动后，它调用socketbind、listen和accept,并阻塞于accept调用。<br>
运行netstat -a命令来检查服务器监听套接字的状态<br>
netstat用星号“*&quot;来表示一个为0的IP地址（INADDR_ANY,通配地址）或为0的端口号。<br>
在同一个主机上启动客户，并指定服务器主机的IP地址为127.0.0.1 （环回地址）<br>
客户调用socket和connect,后者引起TCP的三路握手过程。当三路握手完成后，客户中 的connect和服务器中的accept均返回，连接于是建立。接着发生的步骤如下：<br>
⑴客户调用str_cli函数，该函数将阻塞于fgets调用，因为我们还未曾键入过一行文本。<br>
（2）	当服务器中的accept返回时，服务器调用fork,再由子进程调用str_echo.该函数调 用readline, readline调用read,而read在等待客户送入一行文本期间阻塞。<br>
（3）	另一方面，服务器父进程再次调用accept并阻塞，等待下一个客户连接。</p>
<p>客户接收到三路握手的第二个分节时，connect返回，而服务器要直到接收到 三路握手的第三个分节才返回，即在connect返回之后再过一半RTT才返回.</p>
<p>可以用ps查看后台进程的状态和关系</p>
<h1 id="正常终止">正常终止</h1>
<p>&lt;Ctrl+D&gt;是我们的终端EOF字符，键入终端EOF字符（Control-D）以终止客户<br>
当前连接的客户端发送fin和ack后会进入了TIME_WAIT状态</p>
<p>我们可以总结出正常终止客户和服务器的步骤。<br>
⑴当我们键入EOF字符时，fgets返回一个空指针，于是str_cli函数返回。<br>
(2)	当str_cli返回到客户的main函数时，main通过调用exit终止。<br>
(3)	进程终止处理的部分工作是<strong>关闭所有打开的描述符</strong>，因此客户打开的套接字由内核关闭。这导致客户TCP发送一个FIN给服务器，服务器TCP则以ACK响应，这就是TCP连接终止序 列的前半部分。至此，<strong>限务器套接字处于CLOSE_WAIT状态，客户套接字则处于FIN_WAIT_2 状态</strong><br>
(4)	当服务器TCP接收FIN时，服务器子进程阻塞于readline调用，于是readline 返回0。这导致str_echo函数返回服务器子进程的main函数。<br>
(5)	服务器子进程通过调用exit来终止。<br>
(6)	服务器子进程中打开的所有描述符随之关闭。由<strong>子进程</strong>来关闭已连接套接字会引发TCP 连接终止序列的最后两个分节：一个从服务器到客户的FIN和一个从客户到服务器的ACK 。至此，连接完全终止，客户套接字进入TIME_WAIT状态。<br>
(7)	进程终止处理的另一部分内容是：在服务器子进程终止时，给<strong>父进程</strong>发送一个SIGCHLD 信号。，但是我们没有在代码中捕获该信号，而该信号的默认行为是被回 忽略。既然父进程未加处理，子进程于是<strong>进入僵死状态</strong>。可以使用ps命令验证这--点。如果stat列为Z，且command列后面带有＜defunct＞字样，就属于僵死进程<br>
进程的状态是Z (表示僵死)。我们必须清理僵死进程，这就涉及Unix信号的处理。</p>
<h1 id="posix信号处理">POSIX信号处理</h1>
<p>信号(signal)就是告知某个进程发生了某个事件的通知，有时也称为软件中断(software interrupt),信号通常是异步发生的<br>
信号可以：<br>
・由一个进程发给另一个进程(或自身)；<br>
・由内核发给某个进程，SIGCHLD信号就是由内核在任何一个进程终止时发给它的父进程的一个信号。</p>
<p>每个信号都有一个与之关联的处置(disposition),也称为行为(action)。我们通过调用 sigaction函数(稍后讨论)来设定一个信号的处置，并有三种选择<br>
(1)	我们可以提供一个函数，只要有特定信号发生它就被调用。这样的函数称为信号处理函 数(signal handler),这种行为称为捕获(catching)信号<br>
有两个信号有绝对权限，不能被捕获（亦即不能忽略或者用其他函数处理），它们是SIGKILL 和STGSTOP，一般用于防止一个程序忽略了所有信号但又无法终止。<br>
信号处理函数由信号值这个单一的整数参数来调用，且没有返回值，其函数原型 因此如下：<br>
void handler (int signo);<br>
(2)	我们可以把某个信号的处置设定为SIG-IGN来忽略(ignore)它。SIGKILL和SIGSTOP 这两个信号不能被忽略。<br>
(3)	我们可以把某个信号的处置设定为SIG_DFL来启用它的默认(default)处置。<br>
默认处置 网通常是在收到信号后终止进程，其中某些信号还在当前工作目录产生一个进程的核心映像(coreimage,也称为内存影像)。另有个别信号的默认处置是忽略，SIGCHLD和SIGURG (带外数据到 达时发送，见第24章)就是本书中出现的默认处置为忽略的两个信号。</p>
<p>POSIX信号语义<br>
POSIX的系统上的信号处理总结为以下几点。<br>
•—旦安装了信号处理函数，它便一直安装着(较早期的系统是每执行一次就将其拆除)。<br>
•在一个信号处理函数运行期间，正被递交的信号是阻塞的。而且，安装处理函数时在传递给sigact_ion函数的sa_mask信号集中指定的任何额外信号也被阻塞。，我 们将sa_mask置为空集，意味着除了被捕获的信号外，没有额外信号被阻塞。<br>
•如果一个信号在被阻塞期间产生了一次或多次，那么该信号被解阻塞之后通常<strong>只递交一次</strong>，也就是说Unix信号默认是<strong>不排队的</strong>。<br>
•利用sigprocmask函数选择性地阻塞或解阻塞一组信号是可能的。这使得我们可以做到 在一段临界区代码执行期间，防止捕获某些信号，以此保护这段代码。</p>
<h1 id="处理sigchld信号">处理SIGCHLD信号</h1>
<p>设置僵死（zombie）状态的目的是维护子进程的信息，以便父进程在以后某个时候获取。 这些信息包括子进程的进程ID、终止状态以及资源利用信息（CPU时间、内存使用量等等）。<br>
如果一个进程终止，而该进程有子进程处于僵死状态，那么它的所有僵死子进程的父进程ID将被重置为1（init进程）。继承这些子进程的init让进程将清理它们（也就是说init进程将wait它们，从而去除它们的僵死状态）。<br>
僵死占用内核中的空间，最终可能导致我们耗尽进程资源<br>
无论何时我们fork子进程都得wait它们，以防它们变成偶死进程。为此我们建立一个俘获 SIGCHLD信号的信号处理函数，在函数体中我们调用wait.</p>
<pre><code>Signal（SIGCHLD, sig_chld）;

1	#include	&quot;unp.h&quot;	.
2	void
3	sig_chld（int signo）
4	{
5	pid_t	pid;
6	int	stat;
7	pid = wait（&amp;stat）;
8	printf（&quot;child %d terminated\n&quot;, pid）；
9	return；
10	}
</code></pre>
<p>具体的各个步骤如下：<br>
（1）	我们键入EOF字符来终止客户。客户TCP发送一个FIN给服务器，服务器响应以一个 ACK。<br>
（2）	收到客户的FIN导致服务器TCP递送一个EOF给<strong>子进程阻塞中的readline</strong>,从而<strong>子进程终止</strong>。<br>
（3）	当SIGCHLD信号递交时，<strong>父进程阻塞于accept调用</strong>。sig_chld函数（信号处理函数） 执行，其wait调用取到子进程的PID和终止状态，随后是printf调用，最后返回。<br>
（4）	既然该信号是在父进程阻塞于慢系统调用（accept）时由父进程捕获的，内核就会使<strong>accept返回一个EINTR错误（被中断的系统调用）。而父进程不处理该错误,于是中止。</strong></p>
<p>本书使用的编程约定之一，我们总是在信号处理函数中显式给出return语句，这么一来，当某个系统调用被我们编写的某个信号处理函数中断时，我们就可以得知该系统调用具体是被哪个信号处理函数的哪个return语句中断的。</p>
<ul>
<li>处理被中断的系统调用<br>
慢系统调用（slow system call）：适用于那些可能 永远阻塞的系统调用。永远阻塞的系统调用是指调用有可能永远无法返回，多数网络支持函数都属于这一类，例如accept。<br>
一个值得注意的例外是磁盘I/O,它们一般都会返回到调用者（假设没有灾难性的硬件故障）。<br>
适用于慢系统调用的基本规则是：当阻塞于某个慢系统调用的一个进程捕获某个信号且相应信号处理函数返回时，该系统调用可能返回一个<strong>EINTR错误</strong>。<br>
设置SA_RESTART标志可以使得内核自动重启调用<br>
了处理被中断的accept,我们把对accept的调用从for循环开始改起</li>
</ul>
<pre><code>for ( ; ; ) (
	clilen = sizeof(cliaddr);
	if ( (connfd =accept(listenfd, (SA *) &amp;cliaddr, &amp;clilen)) &lt; 0) { 
		if (errno == EINTR) 
				continue;	/* back to for() */
		else
				err_sys(&quot;accept error&quot;);
}
</code></pre>
<p>注意！<strong>有一个函数我们不能重启：connect</strong>。如果该函数返回EINTR,我们就不能再次调用它，否则将立即返回一个错误。当connect被一个捕获的 信号中断而且不自动重启时，我们必须调用select来等待连接完成</p>
<h1 id="wait-和-waitpid-函数">wait 和 waitpid 函数</h1>
<p>调用了函数wait:来处理己终止的子进程。</p>
<pre><code>#include &lt;sys/wait.h&gt;
		pid_t wait (int *statloc)；
		pid_t waitpid(pid_t pid, int *statloc, int options);
均返回：若成功则为进程ID,若出错则为。或-1
</code></pre>
<p>函数wait和waitpid均返回两个值：已终止子进程的进程ID号，以及通过指针返回 的子进程终止状态(一个整数)。<br>
我们可以调用三个宏来检查终止状态，并辨别子进程是正常终止、由某个信号杀死还是仅仅由作业控制停止而已。<br>
如果调用wait的进程没有已终止的子进程，不过有一个或多个子进程仍在执行，那么wait 将阻塞到现有子进程第一个终止为止。<br>
waitpid函数就等待哪个进程以及是否阻塞给了我们更多的控制。首先，pid参数允许我们<strong>指定想等待的进程ID</strong>,值-1表示等待第一个终止的子进程。<br>
options参数允许我们指定附加选项。最常用的选项是WNOHANG,它告知内核在<strong>没有已终止子进程时不要阻塞</strong></p>
<ul>
<li>函数wait和waitpid的区别<br>
使用wait的情况下：<br>
假设有5个客户连接到服务器，当客户终止时，所有打开的描述符由内核自动关闭(我们不调用close,仅调用exit),且所有5个<strong>连接基本在同一时刻终止</strong>。这就引发了5个FIN,每个连接一个，它们反过来使服务器 的5个子进程基本在同一时刻终止。这导致差不多在同一时刻有<strong>5个SIGCHLD信号递交给父进程</strong><br>
这是按照预期所有5个子进程都终止了， 如果运行ps,我们将发现其他4个子进程仍然作为<strong>僵死进程</strong>存在着。<br>
原因：同一Unix信号一般是不重复排队的，建立一个信号处理函数并在其中调用wait并不足以防止出现僵死进程。本问题在于：所有5个信号都在信号处理函数执行之前产生，而<strong>信号处理函数只执行一次</strong>。<br>
更严重的是，本问题是不确定的，信号处理函数的执行次数依赖于FIN到达服务器主机的时机，</li>
</ul>
<p>正确的解决办法是调用waitpid而不是wait：<br>
这个版本管用的原因在于：我们在一个循环内调用waitpid,以获取所有已终止于进程的状态。<br>
我们必须指定WNOHANG选项，它告知waitpid在有尚未终止的子进程在运行时<strong>不要阻塞</strong>。<strong>不能在循环内调用wait</strong>,因为没有办法防止wait在正运行的子进程尚有未终止时阻塞。</p>
<p>关于<strong>wait和SIGCHLD信号</strong>注意事项：<br>
其实不一定要在SIGCHLD里调用wait，也可以直接wait<br>
注意！！！wait和信号之间没有关联，我们是捕获到sigchild信号就进行wait处理，而不是说wait本身等待信号进行调用，所以就算不排队，接收到一个信号后就能进行waitpid处理当前所有的僵死进程，而wait只能处理已个，并且不能通过循环wait解决因为会阻塞。<br>
<strong>所以！！！wait和信号无关！哪怕没有信号我也能调用wait和waitpid循环来<br>
清除僵死进程</strong></p>
<pre><code>//tcpserv04.c
//Code by Lixin on 2020/01/14

#include &quot;unp.h&quot;

int 
main(int argc,char **argv){
	int listenfd,connfd;
	pid_t childpid;
	socklen_t clilen;
	struct sockaddr_in cliaddr,servaddr;
	void sig_chld(int);
	listenfd=socket(AF_INET,SOCK_STREAM,0);
	bzero(&amp;servaddr,sizeof(servaddr));
	servaddr.sin_family=AF_INET;
	servaddr.sin_port=htons(SERV_PORT);
	servaddr.sin_addr.s_addr=htonl(INADDR_ANY);

	bind(listenfd,(SA *)&amp;servaddr,sizeof(servaddr));
	listen(listenfd,LISTENQ);
	signal(SIGCHLD,sig_chld);
	for(;;){
		clilen=sizeof(cliaddr);
		if((connfd=accept(listenfd,(SA *)&amp;cliaddr,&amp;clilen))&lt;0){
			if(errno==EINTR)
				continue;
			else
				err_sys(&quot;accept error&quot;);
		}
		if((childpid=fork())==0){
			close(listenfd);
			str_echo(connfd);
			exit(0);
		}
		close(connfd);
	}
}
</code></pre>
<p>我们的服务器程序的最终版本。它正确处理accept返回的EINTR,并建立一个给所有己终止子进程调用waitpid的信号处理函数<br>
本节的目的是示范我们在网络编程时可能会遇到的三种情况：<br>
(1)	当fork子进程时，必须捕获SIGCHLD信号；<br>
(2)	当捕获信号时，必须处理被中断的系统调用；<br>
(3)	S1GCHLD的信号处理函数必须正确编写，应使用waitpid函数以免留下僵死进程。</p>
<h1 id="accept返回前连接中止">accept返回前连接中止</h1>
<p>accept返回一个非致命的错误，在这种情况下，只需要再次调用accept，典型的是较忙的Web服务器。<br>
三路握手完成从而连接建立之后，客户TCP却发送了一个RST （复位）。在服务器端看来，就在该连接已由TCP排队，等着服务器进程调用accept的时候RST到达。<br>
如何处理这种中止的连接依赖于不同的实现，POSIX 指出返回的 errno 值必须是ECONNABORTED<br>
POSIX作出修改的理由在于：流子系统(streams subsystem)中发生某些致命的协议相关事件时，也会返回EPROTO。要是对于由客户引起的一个 已建立连接的非致命中止也返回同样的错误，那么服务器就不知道该再次调用accept还是不该 了。换成ECONNABORTED错误，服务器就可以忽略它，再次调用accept就行。</p>
<h1 id="服务器进程终止">服务器进程终止</h1>
<p>模拟服务器已连接的子进程终止：<br>
1.找到服务器子进程的进程ID,并执行kill命令杀死它。作为进程终止处理的部分工作， 子进程中所有打开着的描述符都被关闭。这就导致<strong>向客户发送一个FIN</strong>,<br>
2.客户段传输层TCP接收FIN此时响应以一个ACK，同时按照预设客户端应用层应当读入套接字的FIN准备关闭程序并发送客户端的FIN给服务端，但是！！此时进程<strong>拥塞在fgets</strong>上，等待从<strong>终端（也就是键盘！）</strong> 接收一行文本，导致<strong>没法去读取套接字的FIN！</strong><br>
<strong>（这里注意区分有两个流，一个是键盘，一个是网络套接字）</strong><br>
<strong>（但是此时客户端传输层TCP已经收到FIN了并向服务端发送ACK了，同时把状态转化为CLOSE_WAIT，可以用netstat查询，这一切都不需要应用层插手）</strong><br>
3.假设此时客户端接收到键盘的输入文本并发送给服务端，当服务器TCP接收到来自客户的数据时，既然先前打开那个套接字的进程已经终止，于是 响应以一个RST。<br>
4.然而客户进程看不到这个RST,因为它在调用writen后立即调用readline,并且由于接收的FIN,所调用的readline立即返回0 （表示EOF）。我们的客户此时<strong>并未预期收到 EOF</strong>，于是以出错信息&quot;server terminated prematurely”（服务器过早终止）退出。当客户终止时（通过调用err_quit）,它所有打开着的描述符都被关闭。<br>
<strong>（注意这里为什么说未预期收到EOF呢？因为ECHO服务器是假设只能由客户端关闭的，所以客户端一开始没加上接收FIN的处理，比如微信，总不能让腾讯来先发送FIN关闭我手机上的微信吧？）</strong></p>
<p>根本原因：当FIN到达套接字时，客户正阻塞在fgets调用上。客户实际上<strong>在应对两个描述符</strong>--套接字（网络）和用户输入（键盘），它不能单纯阻塞在这两个源中某个特定源的输入上（正如 目前编写的str.cli函数所为），而是应<strong>该阻塞在其中任何一个源的输入上</strong>。事实上这正是 <strong>select和poll这两个函数的目的之一</strong></p>
<p>关于RST：<br>
上述讨论还取决于本例子的时序，客户调用readline既可能发生在服务器的RST 被客户收到之前，也可能发生在收到之后，如果readline发生在<strong>收到RST之前</strong>（如本例子所 示），那么结果是客户得到一个未预期的EOF；如果readline发生在<strong>收到RST之后</strong>，否则结果是由readline返回一个ECONNRESET （connection reset by peer，对方复位连接错误）.<br>
猜测原因：服务端发送RST会导致任何排队的数据都被抛弃，RST优先级最高，会被立即发出去，所以可能导致FIN还在排队的时候就已经被抛弃了<br>
疑惑：那如果FIN比RST先到达接收方会怎么样？</p>
<h1 id="sigpipe-信号">SIGPIPE 信号</h1>
<p>要是客户不理会readline函数返回的错误，反而写入更多的数据到服务器上，那又会发生什么呢？<br>
当一个进程向某个己收到RST的套接字执行写操作时，<strong>（客户端的）内核</strong>向该进程发送一个SIGPIPE信号.该信号的默认行为是终止进程，因此进程必须捕获它以免不情愿地被终止，同时写操作都将返回EPTPE错误。<br>
第一次写操作引发RST,第二次写引发SIGPIPE信号.写一个已接收了FIN的套接字不成问题，但是写一个已接收了 RST的套接字则是一个<strong>错误</strong>.<br>
处理SIGPIPE的建议方法取决于它发生时应用进程想做什么（比如写入log日志）<br>
但是必须意识到，如果使用 了多个套接字，该信号的递交无法告诉我们是哪个套接字出的错。如果我们确实需要知 道是哪个write出了错，那么必须要么不理会该信号，要么从信号处理函数返回后再处 理来自write的EPIPE。</p>
<h1 id="服务器主机崩溃">服务器主机崩溃</h1>
<p>注意区分进程终止和崩溃，模拟前者一般是使用kill信号，模拟后者则需要从网络上断开服务器主机，这样同时也模拟了当客户发送数据时服务器主机不可达的情形(即建立连接后某些中间路由器不工作)。</p>
<p>客户端发送数据后，等待服务器的ACK，因而阻塞在readline调用上，假设服务器主机己崩溃，从而对客户的数据分节根本没有响应，那么所返回的错误是 ETIMEDOUT（从readline调用返回的）<br>
然而如果某个中间路由器判定服务器主机已不可达，从而响应以一个“destination unreachable&quot;(目的地不可达)ICMP消息，那么所返回的错误是EHOSTUNREACH或ENETUNREACH。</p>
<p>如果希望更快地检测出这种情况，可以对readline调用设置一个超时</p>
<p>上述情形只有在我们向服务器主机发送数据时才能检测出它已经崩溃。如果希望不主动向它发送数据也能检测出服务器主机的崩溃，那么需要采用另外一个技术--SO_KEEPALIVE套接字选项。</p>
<h1 id="服务器主机崩溃后重启">服务器主机崩溃后重启</h1>
<p>模拟这种情形的最简单方法就是：先建立连接，再从网络上 函 断开服务器主机，将它关机后再重新启动，最后把它重新连接到网络中。<br>
处理方法重点在于：我们<strong>不想客户知道服务器主机的关机</strong></p>
<p>普通情况下：<br>
(1)	当服务器主机崩溃后重启时，它的TCP丢失了崩溃前的所有连接倍息，因此服务器TCP 对于所收到的来自客户的数据分节响应以一个RST。<br>
(2)	当客户TCP收到该RST时，客户正阻塞于readline调用，导致该调用返回ECONNRESET 错误。</p>
<h1 id="服务器主机关机">服务器主机关机</h1>
<p>当服务器子进程终止时，它的所 有打开着的描述符都被关闭，随后发生的步骤与服务器进程终止那一节一样，我们必须在客户中使用select或poll函数，使得服务器进程的终止一经发生，客户就能检测到。</p>
<h1 id="tcp程序例子小结">TCP程序例子小结</h1>
<p>在TCP客户和服务器可以彼此通信之前，每一端都得指定连接的<strong>套接字对：本地IP地址、 本地端口、外地IP地址、外地端口。</strong><br>
<img src="https://lixin-ee.github.io//post-images/1579005277140.png" alt=""><br>
<img src="https://lixin-ee.github.io//post-images/1579005290499.png" alt=""><br>
如果服务器在一个多宿主机上绑定通配IP地址，那么它可以在连接建立后通过调用getsockname来确定本地IP地址。两个外地值则由accept调用返回给服务器。</p>
<h1 id="数据格式粘包与分包">数据格式（粘包与分包）</h1>
<p>在我们的例子中，服务器从不检查来自客户的请求。它只管读入直到换行符（包括换行符） 的所有数据，把它发回给客户，所搜索的仅仅是换行符<br>
这只是一个例外，而不是通常规则， 一般来说，我们必须关心在客广和服务器之间进行<strong>交换的数据的格式</strong>。</p>
<p><strong>注意！</strong><br>
这个格式<strong>和TCP无关</strong>，是<strong>应用层的格式</strong>，TCP和IP的分片操作应用层是看不到的，TCP是<strong>数据流</strong>，保证交给应用层的数据是<strong>连续</strong>且无误的，但是应用层需要<strong>自己切分读到的数据</strong>，比如一个聊天软件，一个人说的话是长度不一并且连续到达的，应用层必须自己制定好格式使得能够区分数据直接的间隔并能够重新组装语句。</p>
<p>数据格式需要考虑字节序，，特别是二进制结构数据，网络字节序默认是大端序<br>
二进制结构容易存在以下问题<br>
(1)	不同的实现以不同的格式存储二进制数。例如大端字节序 与小端字节序。<br>
(2)	不同的实现在存储相同的C数据类型上可能存在差异。举例来说，大多数32位Unix系统 使用32位表示长整数，而64位系统却典型地使用64位来表示同样的数据类型，对于 short, int或long等整数类型，它们各自的大小没有确定的保证。<br>
(3)	不同的实现给结构打包的方式存在差异，取决于各种数据类型所用的位数以及机器的<strong>对齐限制</strong>。因此，穿越套接字传送二进制结构绝不是明智的。</p>
<p>解决这种数据格式问题有两个常用方法。<br>
(1)	把所有的<strong>数值数据作为文本串</strong>来传递，当然这里假设客广和服务 器主机具有相同的字符集。<br>
(2)	<strong>显式定义</strong>所支持数据类型的二进制格式(位数、大端或小端字节序)，并以这样的格式 在客户与服务器之间传递所有数据。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Design 146. LRU缓存机制[中等][未做出]]]></title>
        <id>https://lixin-ee.github.io//post/design-146-lru-huan-cun-ji-zhi-zhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/design-146-lru-huan-cun-ji-zhi-zhong-deng-wei-zuo-chu">
        </link>
        <updated>2020-01-13T01:08:00.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。<br>
获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>
写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。<br>
进阶:<br>
你是否可以在 O(1) 时间复杂度内完成这两种操作？<br>
示例:<br>
LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );<br>
cache.put(1, 1);<br>
cache.put(2, 2);<br>
cache.get(1);       // 返回  1<br>
cache.put(3, 3);    // 该操作会使得密钥 2 作废<br>
cache.get(2);       // 返回 -1 (未找到)<br>
cache.put(4, 4);    // 该操作会使得密钥 1 作废<br>
cache.get(1);       // 返回 -1 (未找到)<br>
cache.get(3);       // 返回  3<br>
cache.get(4);       // 返回  4<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/lru-cache<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>【未做出】<br>
最难的肯定就是选定一个基础数据结构了<br>
1.首先必须存储一对pair，然后最重要的是必须得存储某个值或者保持某个顺序，使得容量达到上限时能够删除最少使用的数据<br>
2.然后看进阶，难点在于两个操作都要常数时间，常数时间的查找只能用哈希表，然后难点就在于常数时间的插入，这个似乎也只能用哈希表<br>
3.对于最少使用这个问题，我打算先使用两个哈希表来初步解决这个问题，一个属于历史使用表，一个属于插入表。优先牺牲插入表的元素，但是我没想好全部都在历史使用表后怎么判断最少使用的元素。<br>
艹了，理解错了，是删除掉最老的元素？</p>
<p>看题解：<br>
1.其实我实在是很疑惑示例中为何4插入时为何删除1而不是删除3？<br>
2.我忘了判断key是否存在了，已存在的话需要删除再重新添加<br>
3.list是双向链表，forward_list才是单向链表<br>
4.理解erase很重要，不需要自己接驳前后元素，函数会自动删除元素后接驳<br>
5.erase等函数只接受迭代器，主要list等链表的迭代器不会失效，但是vector、deque的会失效，原因就在于是否是连续存储，所以这道题里很适合用list的迭代器</p>
<pre><code>class LRUCache {
public:
    int cap;
    list&lt;pair&lt;int,int&gt;&gt; cache;
    unordered_map&lt;int,list&lt;pair&lt;int,int&gt;&gt;::iterator&gt; cache_map;
    LRUCache(int capacity) {
        this-&gt;cap=capacity;
    }
    
    int get(int key) {
        if(cache_map.count(key)==0)
            return -1;
        auto temp=*cache_map[key];
        cache.erase(cache_map[key]);
        cache.push_front(temp);
        cache_map[key]=cache.begin();
        return temp.second;
    }
    
    void put(int key, int value) {
        //注意旧有数据也必须先判断是否存在，存在的话要提到链表链首
        if(cache_map.count(key)){   
            cache.erase(cache_map[key]);
            cache_map.erase(key);
        }
        //先判断容量
        if(getSize()&gt;=cap){
            auto del=cache.back();
            cache_map.erase(del.first);
            cache.pop_back();
        }
        cache.push_front({key,value});
        cache_map[key]=cache.begin();
        return;      
    }
    
    int getSize(){
       return cache.size(); 
    }
};
</code></pre>
<p>来看看网友题解详解：<br>
三、LRU 算法设计<br>
分析上面的操作过程，要让 put 和 get 方法的时间复杂度为 O(1)，我们可以总结出 cache 这个数据结构必要的条件：查找快，插入快，删除快，有顺序之分。<br>
因为显然 cache 必须有顺序之分，以区分最近使用的和久未使用的数据；而且我们要在 cache 中查找键是否已存在；如果容量满了要删除最后一个数据；每次访问还要把数据插入到队头。<br>
那么，什么数据结构同时符合上述条件呢？哈希表查找快，但是数据无固定顺序；链表有顺序之分，插入删除快，但是查找慢。所以结合一下，形成一种新的数据结构：哈希链表。<br>
LRU 缓存算法的核心数据结构就是哈希链表，双向链表和哈希表的结合体。这个数据结构长这样：<br>
<img src="https://lixin-ee.github.io//post-images/1578878403164.png" alt=""><br>
思想很简单，就是借助哈希表赋予了链表快速查找的特性嘛：可以快速查找某个 key 是否存在缓存（链表）中，同时可以快速删除、添加节点。回想刚才的例子，这种数据结构是不是完美解决了 LRU 缓存的需求<br>
也许读者会问，为什么要是双向链表，单链表行不行？另外，既然哈希表中已经存了 key，为什么链表中还要存键值对呢，只存值不就行了<br>
想的时候都是问题，只有做的时候才有答案。这样设计的原因，必须等我们亲自实现 LRU 算法之后才能理解，所以我们开始看代码吧<br>
四、代码实现<br>
很多编程语言都有内置的哈希链表或者类似 LRU 功能的库函数，但是为了帮大家理解算法的细节，我们用 Java 自己造轮子实现一遍 LRU 算法。<br>
首先，我们把双链表的节点类写出来，为了简化，key 和 val 都认为是 int 类型：</p>
<pre><code>Java
class Node {
    public int key, val;
    public Node next, prev;
    public Node(int k, int v) {
        this.key = k;
        this.val = v;
    }
}
</code></pre>
<p>然后依靠我们的 Node 类型构建一个双链表，实现几个需要的 API（这些操作的时间复杂度均为 O(1))：</p>
<pre><code>class DoubleList {  
    private Node head, tail; // 头尾虚节点
    private int size; // 链表元素数

    public DoubleList() {
        head = new Node(0, 0);
        tail = new Node(0, 0);
        head.next = tail;
        tail.prev = head;
        size = 0;
    }

    // 在链表头部添加节点 x
    public void addFirst(Node x) {
        x.next = head.next;
        x.prev = head;
        head.next.prev = x;
        head.next = x;
        size++;
    }

    // 删除链表中的 x 节点（x 一定存在）
    public void remove(Node x) {
        x.prev.next = x.next;
        x.next.prev = x.prev;
        size--;
    }
    
    // 删除链表中最后一个节点，并返回该节点
    public Node removeLast() {
        if (tail.prev == head)
            return null;
        Node last = tail.prev;
        remove(last);
        return last;
    }
    
    // 返回链表长度
    public int size() { return size; }
}
</code></pre>
<p>到这里就能回答刚才“为什么必须要用双向链表”的问题了，因为我们需要删除操作。删除一个节点不光要得到该节点本身的指针，也需要操作其前驱节点的指针，而双向链表才能支持直接查找前驱，保证操作的时间复杂度 O(1)。<br>
有了双向链表的实现，我们只需要在 LRU 算法中把它和哈希表结合起来即可。我们先把逻辑理清楚：</p>
<pre><code>// key 映射到 Node(key, val)
HashMap&lt;Integer, Node&gt; map;
// Node(k1, v1) &lt;-&gt; Node(k2, v2)...
DoubleList cache;

int get(int key) {
    if (key 不存在) {
        return -1;
    } else {        
        将数据 (key, val) 提到开头；
        return val;
    }
}

void put(int key, int val) {
    Node x = new Node(key, val);
    if (key 已存在) {
        把旧的数据删除；
        将新节点 x 插入到开头；
    } else {
        if (cache 已满) {
            删除链表的最后一个数据腾位置；
            删除 map 中映射到该数据的键；
        } 
        将新节点 x 插入到开头；
        map 中新建 key 对新节点 x 的映射；
    }
}
</code></pre>
<p>如果能够看懂上述逻辑，翻译成代码就很容易理解了：</p>
<pre><code>class LRUCache {
    // key -&gt; Node(key, val)
    private HashMap&lt;Integer, Node&gt; map;
    // Node(k1, v1) &lt;-&gt; Node(k2, v2)...
    private DoubleList cache;
    // 最大容量
    private int cap;
    
    public LRUCache(int capacity) {
        this.cap = capacity;
        map = new HashMap&lt;&gt;();
        cache = new DoubleList();
    }
    
    public int get(int key) {
        if (!map.containsKey(key))
            return -1;
        int val = map.get(key).val;
        // 利用 put 方法把该数据提前
        put(key, val);
        return val;
    }
    
    public void put(int key, int val) {
        // 先把新节点 x 做出来
        Node x = new Node(key, val);
        
        if (map.containsKey(key)) {
            // 删除旧的节点，新的插到头部
            cache.remove(map.get(key));
            cache.addFirst(x);
            // 更新 map 中对应的数据
            map.put(key, x);
        } else {
            if (cap == cache.size()) {
                // 删除链表最后一个数据
                Node last = cache.removeLast();
                map.remove(last.key);
            }
            // 直接添加到头部
            cache.addFirst(x);
            map.put(key, x);
        }
    }
}
</code></pre>
<p>这里就能回答之前的问答题“为什么要在链表中同时存储 key 和 val，而不是只存储 val”，注意这段代码：</p>
<pre><code>
if (cap == cache.size()) {
    // 删除链表最后一个数据
    Node last = cache.removeLast();
    map.remove(last.key);
}
</code></pre>
<p>当缓存容量已满，我们不仅仅要删除最后一个 Node 节点，还要把 map 中映射到该节点的 key 同时删除，而这个 key 只能由 Node 得到。如果 Node 结构中只存储 val，那么我们就无法得知 key 是什么，就无法删除 map 中的键，造成错误。</p>
<p>另外，C++ 可以利用迭代器更方便实现 LRU 算法，有兴趣的读者可以看看代码：</p>
<pre><code>class LRUCache {
private:
    int cap;
    // 双链表：装着 (key, value) 元组
    list&lt;pair&lt;int, int&gt;&gt; cache;
    // 哈希表：key 映射到 (key, value) 在 cache 中的位置
    unordered_map&lt;int, list&lt;pair&lt;int, int&gt;&gt;::iterator&gt; map;
public:
    LRUCache(int capacity) {
        this-&gt;cap = capacity; 
    }
    
    int get(int key) {
        auto it = map.find(key);
        // 访问的 key 不存在
        if (it == map.end()) return -1;
        // key 存在，把 (k, v) 换到队头
        pair&lt;int, int&gt; kv = *map[key];
        cache.erase(map[key]);
        cache.push_front(kv);
        // 更新 (key, value) 在 cache 中的位置
        map[key] = cache.begin();
        return kv.second; // value
    }
    
    void put(int key, int value) {

        /* 要先判断 key 是否已经存在 */ 
        auto it = map.find(key);
        if (it == map.end()) {
            /* key 不存在，判断 cache 是否已满 */ 
            if (cache.size() == cap) {
                // cache 已满，删除尾部的键值对腾位置
                // cache 和 map 中的数据都要删除
                auto lastPair = cache.back();
                int lastKey = lastPair.first;
                map.erase(lastKey);
                cache.pop_back();
            }
            // cache 没满，可以直接添加
            cache.push_front(make_pair(key, value));
            map[key] = cache.begin();
        } else {
            /* key 存在，更改 value 并换到队头 */
            cache.erase(map[key]);
            cache.push_front(make_pair(key, value));
            map[key] = cache.begin();
        }
    }
};
</code></pre>
<p>至此，你应该已经掌握 LRU 算法的思想和实现了，很容易犯错的一点是：处理链表节点的同时不要忘了更新哈希表中对节点的映射。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 142. 环形链表 II[中等][未做出]]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-142-huan-xing-lian-biao-iizhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-142-huan-xing-lian-biao-iizhong-deng-wei-zuo-chu">
        </link>
        <updated>2020-01-11T11:51:18.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<br>
为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。<br>
说明：不允许修改给定的链表。<br>
示例 1：<br>
输入：head = [3,2,0,-4], pos = 1<br>
输出：tail connects to node index 1<br>
解释：链表中有一个环，其尾部连接到第二个节点。<br>
示例 2：<br>
输入：head = [1,2], pos = 0<br>
输出：tail connects to node index 0<br>
解释：链表中有一个环，其尾部连接到第一个节点。<br>
示例 3：<br>
输入：head = [1], pos = -1<br>
输出：no cycle<br>
解释：链表中没有环。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/linked-list-cycle-ii<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>最简单的就是用哈希表了 然后用hash表的时候有点翻车，把指针类型写成了*ListNode了，应该是ListNode*<br>
然后就是考虑双指针法了，检查是否有环是很简单，但是最后停留的位置是未知的。我觉得应该引入第三个指针<br>
看题解去！<br>
哇好心痛，其实就差一步我就做出来的了，就主要是没了解到一个重点 入环点在的位置一定是 m+aN，此时快指针和慢指针的差刚好（b-a）N，同时也是慢指针的值，等于慢指针总共走的路程还是环长（虽然此时不在环上），离入环点还差m步（理解一下m+aN和（b-a）N之间的差别），那么我引入的第三个指针（也可以用fast代替）刚好可以从头指针走m步<br>
好气啊！</p>
<p>实现注意点：<br>
1.两个指针应该从一个虚拟头节点开始而不是从head开始，否则一开始走过的路程就是1了，所以一般定义fast是head-&gt;next，slow就是head，等于预先走了一步<br>
2.fast的判断和两次连续next很重要<br>
2.又忘了判断空链表了。。。</p>
<pre><code>class Solution {
public:

    ListNode *detectCycle(ListNode *head) {
        if(head==NULL)return NULL;
        ListNode *fast=head-&gt;next,*slow=head;
        while(fast!=slow){
            if(fast!=NULL&amp;&amp;fast-&gt;next!=NULL)
                fast=fast-&gt;next-&gt;next; //注意判断条件和两次连续next，没必要分开两次判断next
            else
                return NULL;
            slow=slow-&gt;next;
        }
        fast=head;
        slow=slow-&gt;next;//注意这里，因为fast=head;相当于提前走了一步
        while(fast!=slow)
            fast=fast-&gt;next,slow=slow-&gt;next;
        return slow;     
				/*哈希表解法
        unordered_set&lt;ListNode*&gt; List_set;
        ListNode *cur=head;
        while(true)
            if(cur==NULL)
                return NULL;
            else if(List_set.count(cur))
                return cur;
            else{
                List_set.insert(cur);
                cur=cur-&gt;next;
            }
        */
    }
};
</code></pre>
<p>然后来看看官方题解和网友题解：</p>
<blockquote>
<p>方法 1：哈希表<br>
想法<br>
如果我们用一个 Set 保存已经访问过的节点，我们可以遍历整个列表并返回第一个出现重复的节点。<br>
算法<br>
首先，我们分配一个 Set 去保存所有的列表节点。我们逐一遍历列表，检查当前节点是否出现过，如果节点已经出现过，那么一定形成了环且它是环的入口。否则如果有其他点是环的入口，我们应该先访问到其他节点而不是这个节点。其他情况，没有成环则直接返回 null 。<br>
算法会在遍历有限个节点后终止，这是因为输入列表会被分成两类：成环的和不成环的。一个不成欢的列表在遍历完所有节点后会到达 null - 即链表的最后一个元素后停止。一个成环列表可以想象成是一个不成环列表将最后一个 null 元素换成环的入口。<br>
如果 while 循环终止，我们返回 null 因为我们已经将所有的节点遍历了一遍且没有遇到重复的节点，这种情况下，列表是不成环的。对于循环列表， while 循环永远不会停止，但在某个节点上， if 条件会被满足并导致函数的退出。</p>
</blockquote>
<pre><code>public class Solution {
    public ListNode detectCycle(ListNode head) {
        Set&lt;ListNode&gt; visited = new HashSet&lt;ListNode&gt;();

        ListNode node = head;
        while (node != null) {
            if (visited.contains(node)) {
                return node;
            }
            visited.add(node);
            node = node.next;
        }

        return null;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)<br>
不管是成环还是不成环的输入，算法肯定都只会访问每个节点一次。对于非成环列表这是显而易见的，因为第 n 个节点指向 null ，这会让循环退出。对于循环列表， if 条件满足时会导致函数的退出，因为它指向了某个已经访问过的节点。两种情况下，访问的节点数最多都是 n 个，所以运行时间跟节点数目成线性关系。<br>
空间复杂度：O(n)<br>
不管成环或者不成欢的输入，我们都需要将每个节点插入 Set 中一次。两者唯一的区别是最后访问的节点后是 null 还是一个已经访问过的节点。因此，由于 Set 包含 n 个不同的节点，所需空间与节点数目也是线性关系的。</p>
</blockquote>
<blockquote>
<p>方法 1：Floyd<br>
解题思路：<br>
这类链表题目一般都是使用双指针法解决的，例如寻找距离尾部第K个节点、寻找环入口、寻找公共尾部入口等。<br>
算法流程：<br>
双指针第一次相遇： 设两指针 fast，slow 指向链表头部 head，fast 每轮走 22 步，slow 每轮走 11 步；</p>
</blockquote>
<blockquote>
<p>第一种结果： fast 指针走过链表末端，说明链表无环，直接返回 null；<br>
TIPS: 若有环，两指针一定会相遇。因为每走 1 轮，fast 与 slow 的间距 +1，fast 终会追上 slow；<br>
第二种结果： 当fast == slow时， 两指针在环中 第一次相遇 。下面分析此时fast 与 slow走过的 步数关系 ：<br>
设链表共有 a+b 个节点，其中 链表头部到链表入口 有 a 个节点（不计链表入口节点）， 链表环 有 b 个节点（这里需要注意，a 和 b 是未知数，例如图解上链表 a=4 , b=5）；设两指针分别走了f，s 步，则有：<br>
fast 走的步数是slow步数的 2 倍，即 f=2s；（解析： fast 每轮走 2 步）<br>
fast 比 slow多走了 n 个环的长度，即f=s+nb；（ 解析： 双指针都走过 a 步，然后在环内绕圈直到重合，重合时 fast 比 slow 多走 环的长度整数倍 ）；<br>
以上两式相减得：f=2nb，s=nb，即fast和slow 指针分别走了 2n，n个环的周长 （注意： n 是未知数，不同链表的情况不同）。<br>
目前情况分析：<br>
如果让指针从链表头部一直向前走并统计步数k，那么所有 走到链表入口节点时的步数 是：k=a+nb（先走 a 步到入口节点，之后每绕 1 圈环（ b 步）都会再次到入口节点）。<br>
而目前，slow 指针走过的步数为 nb 步。因此，我们只要想办法让 slow 再走 a 步停下来，就可以到环的入口。<br>
但是我们不知道 a 的值，该怎么办？依然是使用双指针法。我们构建一个指针，此指针需要有以下性质：此指针和slow 一起向前走 a 步后，两者在入口节点重合。那么从哪里走到入口节点需要 a 步？答案是链表头部head。<br>
双指针第二次相遇：<br>
slow指针位置不变 ，将fast指针重新 指向链表头部节点 ；slow和fast同时每轮向前走 1 步；<br>
TIPS：此时 f=0，s=nb ；<br>
当 fast 指针走到f=a 步时，slow 指针走到步s=a+nb，此时 两指针重合，并同时指向链表环入口 。<br>
返回slow指针指向的节点。<br>
复杂度分析：<br>
时间复杂度 O(N) ：第二次相遇中，慢指针须走步数 a&lt;a+b；第一次相遇中，慢指针须走步数a+b−x&lt;a+b，其中 x 为双指针重合点与环入口距离；因此总体为线性复杂度；<br>
空间复杂度 O(1) ：双指针使用常数大小的额外空间。</p>
</blockquote>
<pre><code>public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast = head, slow = head;
        while (true) {
            if (fast == null || fast.next == null) return null;
            fast = fast.next.next;
            slow = slow.next;
            if (fast == slow) break;
        }
        fast = head;
        while (slow != fast) {
            slow = slow.next;
            fast = fast.next;
        }
        return fast;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Linux基础] 源码编译与链接 （鸟哥Linux第二十一章）]]></title>
        <id>https://lixin-ee.github.io//post/linux-ji-chu-ruan-jian-an-zhuang-yuan-shi-ma-yu-tarball-niao-ge-linux-di-er-shi-yi-zhang</id>
        <link href="https://lixin-ee.github.io//post/linux-ji-chu-ruan-jian-an-zhuang-yuan-shi-ma-yu-tarball-niao-ge-linux-di-er-shi-yi-zhang">
        </link>
        <updated>2020-01-11T07:11:12.000Z</updated>
        <content type="html"><![CDATA[<p>了解如何将开放源码的程序设计、加入函式库的原理、透过编译而成为可以执行 的 binary program，最后使用该执行档</p>
<p>注意，与Windows不同，Linux 上面的软件几乎都是经过 GPL 的授权，所以每个软件几乎均提供源代码， 并且你可以自行修改该程序代码，以符合你个人的需求</p>
<p>Linux 系统上真正认识的可执行文件其实是二进制文件 ( binary program)<br>
例如，shell scripts 只是利用 shell (例如 bash) 这支程序的功能进行一些判断式，而最终执行的除了 bash 提供的功能外，仍是呼叫一些已经编译好的二进制程序来执行<br>
可以用file命令来判断，如果是 binary 而且是可以执行的时候，他就会显示执行文件类别 (ELF 64-bit LSB executable)， 同时会说明是否使用<strong>动态函式库 (shared libs)</strong>，而如果是一般的 script ，那他就会显示 出 text executables 之类的字样</p>
<p>vim编写的程序代码文件其实就是一般的纯 文本档。 在完成这个原始码文件的编写之后，再来就是要将这个文件『编译』成为操作系统看的懂 得 binary program 啰，而要编译自然就需要『编译程序』来动作， 经过编译程序的编译与连结之后， 就会产生一支可以执行的 binary program</p>
<p>编译的过程当中还会产生所谓的目标文件 (Object file)<br>
程序当中『引用、呼叫』 其他的外部子程序，或者是利用其他软件库提供的『函数功能』，这个时候，我们就必须要在编译的过程当中， 将该函式库加进去<br>
最后编译程序就可以将所有的程序代码与函式库作一个<strong>连结 (Link)</strong> 以产生正确的执行档</p>
<p>开放源码：就是程序代码，写给人类看的程序语言，但机器并不认识，所以无法执行；<br>
编译程序：将程序代码转译成为机器看得懂的语言，就类似翻译者的角色；<br>
可执行文件：经过编译程序变成二进制程序后，机器可以执行的文件。</p>
<ul>
<li>make 与 configure<br>
使用类似 gcc 的编译程序来进行编译的过程并不简单，大型项目可能会有成百上千个源文件和头文件，需要使用 make 这个指令的相关功能来进行编译过程的指令简化<br>
当执行 make 时，make 会在当时的目录下搜寻 Makefile(or makefile) 这个文本文件<br>
Makefile 里面则记录了原始码<strong>如何编译</strong>的详细信息， make 会自动的判别原始码<strong>是否经过变动</strong>了，而自动更新执行档<br>
通常软件开发商都会写一支<strong>侦测程序configure或者是config</strong>来侦测用户的作业环境， 以及该作业环境是否有软件开发商所需要的其他功能，该侦测程序侦 测完毕后，就会主动的建立这个Makefile的规则文件</li>
</ul>
<p>侦测程序会侦测的数据大约有底下这些：<br>
是否有适合的编译程序可以编译本软件的程序代码；<br>
是否已经存在本软件所需要的函式库，或其他需要的相依软件；<br>
操作系统平台是否适合本软件，包括 Linux 的核心版本；<br>
核心的表头定义档 (header include) 是否存在 (驱动程序必须要的侦测)。<br>
<img src="https://lixin-ee.github.io//post-images/1578728268148.png" alt=""></p>
<p>所以，我们无法在 CentOS 7.x 上面编译出 binary program 后，还将他拿到 SuSE 上面执行，这个动作通常是不可能成功</p>
<ul>
<li>Tarball<br>
所谓的 Tarball 文件，其实就是将软件的所有原始码文件先以 tar 打包（注意不是压缩），然后再以压缩技术来压缩<br>
通常最常见的就是以 gzip 来压缩了。因为利用了 tar 与 gzip 的功能，所以 tarball 文件一般的扩展 名就会写成 * .tar.gz 或者是简写为 * .tgz，相应地 bzip2 与 xz 的后缀名也会变成 * .tar.bz2, * .tar.xz 之类</li>
</ul>
<p>安装压缩包通常就会有：<br>
源代码文件；<br>
侦测程序文件 (可能是 configure 或 config 等檔名)；<br>
本软件的简易说明与安装说明 (INSTALL 或 README)。</p>
<ul>
<li>编译简单范例<br>
<code>[root@study ~]# gcc hello.c</code><br>
如果我们直接以 gcc 编译原始码，并且没有加上任何参数，则执行档的档名会被 自动设定为 a.out 这个文件名<br>
<code>[root@study ~]# ./a.out</code><br>
执行文件时在文件名前面一定要加上./</li>
</ul>
<pre><code>[root@study ~]# gcc -c hello.c
[root@study ~]# gcc -o hello hello.o
</code></pre>
<p>利用 hello.o 这个目标文件制作出一个名为 hello 的执行文件</p>
<p>当我们有多个.c源文件的时候</p>
<pre><code>[root@study ~]# gcc - c thanks.c thanks_2.c
[root@study ~]# gcc -o thanks thanks.o thanks_2.o
</code></pre>
<p>制作目标文件的原因，源文件一般并非仅只有一个文件，无法直接进行编译，需要先产生目标文件，然后再以连结制作成为<strong>单个 binary 可执行文件</strong>。另外， 如果有一天，你更新了 thanks_2.c 这个文件的内容，则你只要<strong>重新编译</strong>thanks_2.c 来产生新的 thanks_2.o ，然后再以连结制作出新的 binary 可执行文件即可，而<strong>不必重新编译</strong>其他没有更动过的源文件。</p>
<p>-O选项： 产生优化的参数<br>
-Wall 为产生更详细的编译过程信息。警告讯息 (warning) 不用理会也没有关系</p>
<ul>
<li>呼叫外部函式库：加入连结的函式库<br>
.h头文件都可以看作是外部库library<br>
对于.h头文件，gcc会直接抓取，只需要在源文件中声明，不需要在命令行中加上</li>
</ul>
<p>而对于非.h头文件的数据库<br>
编译时加入额外函式库连结的方式</p>
<pre><code>[root@study ~]# gcc sin.c -lm -L/lib -L/lib64  #重点在 -lm 
[root@study ~]# ./a.out 
</code></pre>
<p>-lm参数：<br>
-l ：是『加入某个函式库(library)』的意思，<br>
-m ：则是 libm.so 这个函式库，其中， lib 与扩展名(.a 或 .so)不需要写<br>
所以 -lm 表示使用 libm.so (或 libm.a) 这个函式库的意思～至于那个 -L 后面接的路径表示： 『函式库 libm.so 请到 /lib 或 /lib64 里面搜寻』</p>
<p>[root@study ~]# gcc sin.c -lm -I/usr/include<br>
定义出要 include 文件放置的目录，-I/path后面接的路径( Path )就是设定要去搜寻相关的 include 文件的目录</p>
<ul>
<li>gcc 的简易用法 ( 编译、参数与链结)<br>
仅将原始码编译成为目标文件，并不制作链接等功能：<br>
<code>[root@study ~]# gcc -c hello.c</code><br>
会自动的产生 hello.o 这个文件，但是并不会产生 binary 执行档。</li>
</ul>
<p>在编译的时候，依据作业环境给予优化执行速度<br>
<code>[root@study ~]# gcc -O hello.c -c</code><br>
会自动的产生 hello.o 这个文件，并且进行优化</p>
<p>在进行 binary file 制作时，将连结的函式库与相关的路径填入<br>
<code>[root@study ~]# gcc sin.c -lm -L/lib -I/usr/include</code><br>
这个指令较常下达在最终连结成 binary file 的时候，<br>
-lm 指的是 libm.so 或 libm.a 这个函式库文件；<br>
-L 后面接的路径是刚刚上面那个函式库的搜寻目录；<br>
-I 后面接的是原始码内的 include 文件之所在目录。</p>
<p>将编译的结果输出成某个特定档名<br>
<code>[root@study ~]# gcc -o hello hello.c</code><br>
-o 后面接的是要输出的 binary file 檔名</p>
<p>在编译的时候，输出较多的讯息说明<br>
<code>[root@study ~]# gcc -o hello hello.c -Wall</code><br>
加入 -Wall 之后，程序的编译会变的较为严谨一点，所以警告讯息也会显示出来！</p>
<p>另外，我们通常称 -Wall 或者 -O 这些非必要的参数为旗标 (FLAGS)，使用的是 C 程序语言时也会简称这些旗标为 CFLAGS</p>
<ul>
<li>用 make  进行宏编译<br>
makefile 一次性完成编译和链接等工作</li>
</ul>
<p>[root@study ~]#  vim makefile<br>
main: main.o haha.o sin_value.o cos_value.o<br>
gcc -o main main.o haha.o sin_value.o cos_value.o -lm<br>
注意，第二行前面有一个tab缩进</p>
<p>疑惑：『如果建立一个 shell script 来将上面的所有动作都按顺序集结在一起，不是具有同样的效果吗』<br>
<strong>注意！效果当然不一样</strong>，以上面的测试为例，我们仅写出 main 需要的目标文件，结果 make会主动的去判断每个目标文件相关的原始码文件，并直接予以编译，最后再直接进行连结的动作，<strong>同时！</strong> 如果我们更动过某些原始码文件，则 make 也可以<strong>主动判断</strong>哪一个原始码与相关的目标文件文件有更新过， 并仅更新该文件，可大大的节省编译时间</p>
<p>make有这些好处：<br>
简化编译时所需要下达的指令；<br>
若在编译完成之后，修改了某个原始码文件，则 make <strong>仅会针对被修改</strong>了的文件进行编译，其他的object file不会被更动；<br>
最后可以依照<strong>相依性</strong>来更新 (update) 执行档。</p>
<ul>
<li>makefile的基本语法与变量</li>
</ul>
<pre><code>目标(target): 目标文件 1 目标文件 2
&lt;tab&gt; gcc -o 欲建立的执行文件 目标文件 1 目标文件 2
</code></pre>
<p>目标 (target) 就是我们想要建立的信息，而目标文件就是具有相关性的 object files ，那建立执行文件的语法就是以 tab按键开头的那一行！特别留意，『命令行必须要以 tab 按键作为开头』才行<br>
在 makefile 当中的 # 代表批注；<br>
tab 需要在命令行 (例如 gcc 这个编译程序指令) 的第一个字符；<br>
目标 (target) 与相依文件(就是目标文件)之间需以『:』隔开。</p>
<p>Makefile里面可以有多个动作<br>
例如</p>
<pre><code>main: main.o haha.o sin_value.o cos_value.o
		gcc -o main main.o haha.o sin_value.o cos_value.o -lm
clean:
		rm -f main main.o haha.o sin_value.o cos_value.o
</code></pre>
<p><code>[root@study ~]# make clean &lt;==就是这里！透过 make 以 clean 为目标</code><br>
我们的 makefile 里面就具有至少两个目标，分别是 main 与 clean ，如果我们想要建立main 的话，输入『make main』，如果想要清除有的没的，输入『make clean』即可，而如果想要<strong>先清除目标文件再编译 main 这</strong>个程序的话，就可以这样输入：『make clean main』</p>
<p>Makefile中可以使用变量<br>
例如：</p>
<pre><code>[root@study ~]#  vi makefile
LIBS = -lm
OBJS = main.o haha.o sin_value.o cos_value.o
main: ${OBJS}
		gcc -o main ${OBJS} ${LIBS}
clean:
		rm -f main ${OBJS}
</code></pre>
<p>与 bash shell script 的语法有点不太相同，变量的基本语法为：</p>
<ol>
<li>变量与变量内容以『=』隔开，同时两边可以具有空格；</li>
<li>变量左边不可以有 tab ，例如上面范例的第一行 LIBS 左边不可以是tab；</li>
<li>变量与变量内容在『=』两边不能具有『:』；</li>
<li>在习惯上，变数最好是以『大写字母』为主；</li>
<li>运用变量时，以 ${变量} 或 $(变量) 使用；</li>
<li>在该 shell 的<strong>环境变量</strong>是可以被套用的，例如提到的 CFLAGS 这个变数！</li>
<li>在指令列模式也可以给予变量。<br>
由于 gcc 在进行编译的行为时，会主动的去读取 CFLAGS 这个环境变量，所以，你可以直接在 shell定义出这个环境变量，也可以在 makefile 文件里面去定义，更可以在指令列当中给出<br>
<code>[root@study ~]# CFLAGS=&quot;-Wall&quot; make clean main</code><br>
这个动作在上 make 进行编译时，会去取用 CFLAGS 的变量内容<br>
万一这个CFLAGS 的内容在指令列与 makefile 里面并不相同，即出现同名变量的时候，环境变量取用的规则是这样的：</li>
<li>make 指令列后面加上的环境变量为优先；</li>
<li>makefile 里面指定的环境变量第二；</li>
<li>shell 原本具有的环境变量第三。<br>
此外，还有一些特殊的变量需要了解的喔：<br>
$@：代表目前的目标(target)<br>
例如</li>
</ol>
<pre><code>[root@study ~]#  vi makefile
LIBS = -lm
OBJS = main.o haha.o sin_value.o cos_value.o
CFLAGS = -Wall
main: ${OBJS}
		gcc -o $@ ${OBJS} ${LIBS} &lt;==那个 $@ 就是 main ！
clean:
		rm -f main ${OBJS}
</code></pre>
<ul>
<li>函式库管理<br>
很多的软件之间都会互相取用彼此提供的函式库来进行特殊功能的运作<br>
依据函式库被使用的类型而分为两大类，分别是静态(Static) 与动态 (Dynamic) 函式库两类</li>
</ul>
<p>静态函式库的特色：<br>
扩展名：<strong>(扩展名为 .a)</strong><br>
这类的函式库通常扩展名为<strong>libxxx.a 的类型</strong>；<br>
编译行为：<br>
这类函式库在编<strong>译的时候会直接整合到执行程序</strong>当中，所以利用静态函式库编译成的<strong>文件会比较大一些</strong>；<br>
独立执行的状态：<br>
这类函式库最大的优点，就是<strong>编译成功的可执行文件可以独立执行</strong>，而不需要再向外部要求读取函式库的内容 (请参照动态函式库的说明)。<br>
升级难易度：<br>
虽然执行档可以独立执行，但因为函式库是直接整合到执行档中， 因此<strong>若函式库升级时，整个执行档必须要重新编译</strong>才能将新版的函式库整合到程序当中。 也就是说，在升级方面，只要函式库升级了，所有将此函式库纳入的程序都需要重新编译</p>
<p>动态函式库的特色：<br>
<strong>扩展名：(扩展名为 .so)</strong><br>
这类函式库通常扩展名为<strong>libxxx.so 的类型</strong>；<br>
编译行为：<br>
动态函式库与静态函式库的编译行为差异挺大的。 与静态函式库被整个捉到程序中不同的，动态函式库在编译的时候，<strong>在程序里面只有一个『指向 (Pointer)』的位置而已</strong>。也就是说，动态函式库的内容<strong>并没有被整合到执行档当中</strong>，而是当执行档要使用到函式库的机制时， 程序才会去读<strong>取函式库来使用</strong>。由于执行文件当中仅具有指向动态函式库所在的指标而已， 并不包含函式库的内容，所以他的文件会比较小一点。<br>
独立执行的状态：<br>
这类型的函式库所编译出来的程序<strong>不能被独立执行</strong>， 因为当我们使用到函式库的机制时，程序才会去读取函式库，所以函式库文件『必须要存在』才行，而且，函式库的<strong>所在目录也不能改变</strong>，因为我们的可执行文件里面仅有『指标』亦即当要取用该动态函式库时， 程序会主动去某个路径下读取，呵呵！所以动态函式库<strong>不能随意移动或删除</strong>，会影响很多相依的程序软件喔！<br>
升级难易度：<br>
虽然这类型的执行档无法独立运作，然而由于是具有指向的功能， 所以，当函式库<strong>升级后，执行档根本不需要进行重新编译的行为</strong>，因为执行档会直接指向新的函式库文件 (前提是函式库新旧版本的档名相同)。</p>
<p>目前的 Linux distribution 比较倾向于使用动态函式库，因为如同上面提到的最重要的一点， 就是函式库的升级方便</p>
<p>ldconfig  与 /etc/ld.so.conf<br>
如果我们将常用到的动态函式库先加载内存当中 (快取, cache)，如此一来，当软件要取用动态函式库时，就不需要从头由硬盘里面读出，这样就可以增进动态函式库的读取速度</p>
<p>将动态函式库加载高速缓存当中：</p>
<ol>
<li>首先，我们必须要在 /etc/ld.so.conf 里面写下『 想要读入高速缓存当中的动态函式库所在的目录』，注意是目录而不是文件；</li>
<li>接下来则是利用 ldconfig 这个执行档将 /etc/ld.so.conf 的资料读入快取当中；</li>
<li>同时也将数据记录一份在 /etc/ld.so.cache 这个文件当中</li>
</ol>
<p>ldconfig 还可以用来判断动态函式库的链接信息。想要将目前系统下函式库加入到快取当中时，可以这样做：</p>
<pre><code>[root@study ~]#  ldconfig [-f conf] [ -C cache]
[root@study ~]#  ldconfig [-p]
</code></pre>
<p>选项与参数：<br>
-f conf ：那个 conf 指的是某个文件名，也就是说，使用 conf 作为 libarary<br>
函式库的取得路径，而不以 /etc/ld.so.conf 为默认值<br>
-C cache：那个 cache 指的是某个文件名，也就是说，使用 cache 作为快取暂存<br>
的函式库资料，而不以 /etc/ld.so.cache 为默认值<br>
-p  ：列出目前有的所有函式库资料内容 (在 /etc/ld.so.cache 内的资料)</p>
<p>范例一：假设我的 Mariadb 数据库函式库在 /usr/lib64/mysql 当中，如何读进 cache ？<br>
<code>[root@study ~]# vim /etc/ld.so.conf.d/vbird.conf</code><br>
/usr/lib64/mysql &lt;==这一行新增的啦！<br>
<code>[root@study ~]# ldconfig &lt;==画面上不会显示任何的信息，不要太紧张！正常的！</code><br>
<code>[root@study ~]# ldconfig -p</code></p>
<ul>
<li>程序的动态函式库解析： ldd<br>
判断某个可执行的 binary 文件含有什么动态函式库<br>
<code>[root@study ~]# ldd [-vdr] [filename]</code><br>
选项与参数：<br>
-v ：列出所有内容信息；<br>
-d ：重新将资料有遗失的 link 点显示出来<br>
-r ：将 ELF 有关的错误内容显示出来</li>
</ul>
<p>安装文件时，可以先以 ldd 来视察『相依函式库』之间的相关性，亦即『 相依属性』</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划 62. 不同路径[中等][未做出]]]></title>
        <id>https://lixin-ee.github.io//post/dong-tai-gui-hua-62-bu-tong-lu-jing-zhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/dong-tai-gui-hua-62-bu-tong-lu-jing-zhong-deng-wei-zuo-chu">
        </link>
        <updated>2020-01-11T01:11:27.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。<br>
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。<br>
问总共有多少条不同的路径？<br>
例如，上图是一个7 x 3 的网格。有多少可能的路径？<br>
说明：m 和 n 的值均不超过 100。<br>
示例 1:<br>
输入: m = 3, n = 2<br>
输出: 3<br>
解释:<br>
从左上角开始，总共有 3 条路径可以到达右下角。<br>
1.向右 -&gt; 向右 -&gt; 向下<br>
2.向右 -&gt; 向下 -&gt; 向右<br>
3.向下 -&gt; 向右 -&gt; 向右<br>
示例 2:<br>
输入: m = 7, n = 3<br>
输出: 28<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/unique-paths<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>其实这道题挺像回溯法的，但是我看了一眼tag其实是动态规划？<br>
一开始用的就是类似于回溯法的递归，然后又被自己坑了，递归调用中慎重用++i，只能用i+1,两次递归调用中会出现第二次递归i已经又增大了1的情况<br>
然后暴力递归果断爆炸了</p>
<p>然后我发现一个问题是似乎每个路径的长度是确定的</p>
<p>只能想一下动态规划了<br>
一开始实在没什么头绪，只能牺牲空间复杂度了，然后发现无论是vecotr还是unordered_map都很复杂<br>
还是老老实实看题解吧，没那么时间可以浪费了</p>
<p>看了题解才发现其实是70题提过的方法，只是当时没好好记录和复现，唉<br>
然后题目还提到了有化为一维数组的方法</p>
<p>复现过程中的点<br>
1.将m* n数组初始化为1<br>
2.循环标志i和j从1开始，因为边界点的可能性都是为1的，这一点和第一点相互照应。<br>
3.一维数组的压缩就是利用当前行只需要上一列的内容来压缩（可以先考虑压缩到两行cur和pre，然后在考虑cur本身也是pre）</p>
<p>最后就是排列组合的问题了，步骤确定，那么只要选定步骤中任意m次向右或者n次向下就行了，等于C上m或n,C下的len为m+n-2，有时间的话可以了解一下C上m或n都是结果相同的</p>
<p>所以从今天起，每道题只花少量时间去思考，想不出来就看题解的思路，然后按照思路来自己复现（不能照抄代码）</p>
<p>实现代码</p>
<pre><code>    /*自己弄的蹩脚的递归法
    void move(int i,int j,int m, int n,int &amp;res){
        if(i==m&amp;&amp;j==n){
            ++res;
            return;
        }
        if(i&lt;m)
            move(i+1,j,m,n,res);
        if(j&lt;n)
            move(i,j+1,m,n,res);
        return;
    }
    */
</code></pre>
<pre><code>    /*二维数组动态递归
        int uniquePaths(int m, int n) {
        vector&lt;vector&lt;int&gt;&gt; status(m,vector&lt;int&gt;(n,1));
        for(int i=1;i&lt;m;++i)
            for(int j=1;j&lt;n;++j)
                status[i][j]=status[i-1][j]+status[i][j-1];
        return status[m-1][n-1];
    }
</code></pre>
<pre><code>//单维数组存储
    int uniquePaths(int m, int n) {
        vector&lt;int&gt; status(m,1);
        for(int j=1;j&lt;n;++j)
            for(int i=1;i&lt;m;++i)
                status[i]+=status[i-1];
        return status[m-1];
    }
</code></pre>
<p>网友题解：</p>
<blockquote>
<p>思路<br>
思路一：排列组合<br>
因为机器到底右下角，向下几步，向右几步都是固定的，<br>
比如，m=3, n=2，我们只要向下 1 步，向右 2 步就一定能到达终点。<br>
所以有 C{m+n-2} {m-1}</p>
</blockquote>
<pre><code>def uniquePaths(self, m: int, n: int) -&gt; int:
        return int(math.factorial(m+n-2)/math.factorial(m-1)/math.factorial(n-1))
</code></pre>
<blockquote>
<p>思路二：动态规划<br>
我们令 dp[i][j] 是到达 i, j 最多路径<br>
动态方程：dp[i][j] = dp[i-1][j] + dp[i][j-1]<br>
注意，对于第一行 dp[0][j]，或者第一列 dp[i][0]，由于都是在边界，所以只能为 1<br>
时间复杂度：O(m*n)<br>
空间复杂度：O(m * n))<br>
优化：因为我们每次只需要 dp[i-1][j],dp[i][j-1]<br>
所以我们只要记录这两个数，直接看代码吧！<br>
代码<br>
思路二：</p>
</blockquote>
<pre><code>Java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for (int i = 0; i &lt; n; i++) dp[0][i] = 1;
        for (int i = 0; i &lt; m; i++) dp[i][0] = 1;
        for (int i = 1; i &lt; m; i++) {
            for (int j = 1; j &lt; n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];  
    }
}
</code></pre>
<blockquote>
<p>优化1：空间复杂度 O(2n)</p>
</blockquote>
<pre><code>Java
class Solution {
    public int uniquePaths(int m, int n) {
        int[] pre = new int[n];
        int[] cur = new int[n];
        Arrays.fill(pre, 1);
        Arrays.fill(cur,1);
        for (int i = 1; i &lt; m;i++){
            for (int j = 1; j &lt; n; j++){
                cur[j] = cur[j-1] + pre[j];
            }
            pre = cur.clone();
        }
        return pre[n-1]; 
    }
}
</code></pre>
<blockquote>
<p>优化2：空间复杂度 O(n)</p>
</blockquote>
<pre><code>Java
class Solution {
    public int uniquePaths(int m, int n) {
        int[] cur = new int[n];
        Arrays.fill(cur,1);
        for (int i = 1; i &lt; m;i++){
            for (int j = 1; j &lt; n; j++){
                cur[j] += cur[j-1] ;
            }
        }
        return cur[n-1];
    }
}
</code></pre>
]]></content>
    </entry>
</feed>