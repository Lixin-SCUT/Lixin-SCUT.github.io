<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-12-31T02:55:41.402Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[动态规划 70. 爬楼梯[简单][未做出]]]></title>
        <id>https://lixin-ee.github.io//post/dong-tai-gui-hua-70-pa-lou-ti-jian-dan-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/dong-tai-gui-hua-70-pa-lou-ti-jian-dan-wei-zuo-chu">
        </link>
        <updated>2019-12-31T01:45:17.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br>
注意：给定 n 是一个正整数。<br>
示例 1：<br>
输入： 2<br>
输出： 2<br>
解释： 有两种方法可以爬到楼顶。<br>
1.1 阶 + 1 阶<br>
2.2 阶<br>
示例 2：<br>
输入： 3<br>
输出： 3<br>
解释： 有三种方法可以爬到楼顶。<br>
1.1 阶 + 1 阶 + 1 阶<br>
2.1 阶 + 2 阶<br>
3.2 阶 + 1 阶<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/climbing-stairs<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>有点像动态规划<br>
等等！怎么那么像排列组合？！<br>
列出全部为1的情况，然后随机对1进行组合<br>
不对，首先我将其视为一棵树，左子树+1，右子树+2，当叶节点大于等于n的时候就将次数增加1<br>
尴尬，代码是对的，但是超出时间限制了<br>
然后想想对称地用队列的方法 继续翻车超出时间限制<br>
接下来就是动态规划了，我的想法是对于一个全为1的序列，如果前一个1没选择组合为2的话，当前的1就可以选择组合成2或者保持为1，否则只能保持1<br>
动态规划也翻车了<br>
还是好好看看题解吧，其实是斐波那契的问题，但是树的优化也很值得看看</p>
<p>注意实现动态规划时，初始状态是0步而不是1步，所以n=2是是level[0]+level[1]所以需要数组n+1</p>
<pre><code>class Solution {
public:
    int climbStairs(int n) {
        vector&lt;int&gt; level(n+1,1);
        for(int i=2;i&lt;n+1;++i)
            level[i]=level[i-1]+level[i-2];
        return level.back();
    }
};
</code></pre>
<p>超时代码：</p>
<pre><code>/*
class Solution {
public:
    int count=0;
    int climbStairs(int n) {
        add1(0,n);
        add2(0,n); 
        return count;
    }
    
    void add1(int i,int n){
        ++i;
        if(i==n){
            ++count;
            return;
        }
        if(i&gt;n)
            return;
        add1(i,n);
        add2(i,n);
    }
    
    void add2(int i,int n){
        i+=2;
        if(i==n){
            ++count;
            return;
        }
        if(i&gt;n)
            return;
        add1(i,n);
        add2(i,n);          
    }
};
*/
 /*
    int climbStairs(int n) {
        int count=0;
        queue&lt;int&gt; nums;
        nums.push(n);
        while(!nums.empty()){
            int temp=nums.front();
            nums.pop();
            if(temp-1==0)
                ++count;
            if(temp-2==0)
                ++count;
            if(temp-1&gt;0)
                nums.push(temp-1);
            if(temp-2&gt;0)
                nums.push(temp-2);
        }
        return count;  
    }
    */
</code></pre>
<p>然后是题解：</p>
<blockquote>
<p>摘要<br>
假设你正在爬楼梯，需要 n 阶你才能到达楼顶。<br>
每次你可以爬 1 或 2 个台阶，你有多少种不同的方法可以爬到楼顶呢？<br>
解决方案</p>
</blockquote>
<blockquote>
<p>方法一：暴力法<br>
算法<br>
在暴力法中，我们将会把所有可能爬的阶数进行组合，也就是 1 和 2 。而在每一步中我们都会继续调用 climbStairs这个函数模拟爬 1 阶和 2 阶的情形，并返回两个函数的返回值之和。<br>
climbStairs(i,n)=(i + 1, n) + climbStairs(i + 2, n)<br>
其中 i 定义了当前阶数，而 n 定义了目标阶数。</p>
</blockquote>
<pre><code>Java
public class Solution {
    public int climbStairs(int n) {
        climb_Stairs(0, n);
    }
    public int climb_Stairs(int i, int n) {
        if (i &gt; n) {
            return 0;
        }
        if (i == n) {
            return 1;
        }
        return climb_Stairs(i + 1, n) + climb_Stairs(i + 2, n);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(2^n )，树形递归的大小为 2^n2<br>
空间复杂度：O(n)，递归树的深度可以达到 n 。</p>
</blockquote>
<blockquote>
<p>方法二：记忆化递归<br>
算法<br>
在上一种方法中，我们计算每一步的结果时出现了冗余。另一种思路是，我们可以把每一步的结果存储在 memo 数组之中，每当函数再次被调用，我们就直接从 memo 数组返回结果。<br>
在 memo 数组的帮助下，我们得到了一个修复的递归树，其大小减少到 n。</p>
</blockquote>
<pre><code>Java
public class Solution {
    public int climbStairs(int n) {
        int memo[] = new int[n + 1];
        return climb_Stairs(0, n, memo);
    }
    public int climb_Stairs(int i, int n, int memo[]) {
        if (i &gt; n) {
            return 0;
        }
        if (i == n) {
            return 1;
        }
        if (memo[i] &gt; 0) {
            return memo[i];
        }
        memo[i] = climb_Stairs(i + 1, n, memo) + climb_Stairs(i + 2, n, memo);
        return memo[i];
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)，树形递归的大小可以达到 n。<br>
空间复杂度：O(n)，递归树的深度可以达到 n。</p>
</blockquote>
<blockquote>
<p>方法三：动态规划<br>
算法<br>
不难发现，这个问题可以被分解为一些包含最优子结构的子问题，即它的最优解可以从其子问题的最优解来有效地构建，我们可以使用动态规划来解决这一问题。<br>
第 i 阶可以由以下两种方法得到：<br>
在第 (i−1) 阶后向上爬一阶。<br>
在第 (i−2) 阶后向上爬 2 阶。<br>
所以到达第 i 阶的方法总数就是到第(i−1) 阶和第 (i−2) 阶的方法数之和。<br>
令 dp[i] 表示能到达第 i 阶的方法总数：<br>
dp[i]=dp[i−1]+dp[i−2]</p>
</blockquote>
<pre><code>public class Solution {
    public int climbStairs(int n) {
        if (n == 1) {
            return 1;
        }
        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i &lt;= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)，单循环到 n 。<br>
空间复杂度：O(n)，dp 数组用了 n 的空间。</p>
</blockquote>
<blockquote>
<p>方法四：斐波那契数<br>
算法<br>
在上述方法中，我们使用 dp 数组，其中 dp[i]=dp[i-1]+dp[i-2]。可以很容易通过分析得出dp[i] 其实就是第 ii 个斐波那契数。<br>
Fib(n)=Fib(n−1)+Fib(n−2)<br>
现在我们必须找出以 1 和 2 作为第一项和第二项的斐波那契数列中的第 n 个数，也就是说 Fib(1)=1Fib(1)=1 且 Fib(2)=2Fib(2)=2。</p>
</blockquote>
<pre><code>Java
public class Solution {
    public int climbStairs(int n) {
        if (n == 1) {
            return 1;
        }
        int first = 1;
        int second = 2;
        for (int i = 3; i &lt;= n; i++) {
            int third = first + second;
            first = second;
            second = third;
        }
        return second;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)，单循环到 n，需要计算第 n 个斐波那契数。<br>
空间复杂度：O(1)，使用常量级空间。</p>
</blockquote>
<p>下面的就很数学了，在面试中说出来就明显是刷题的了，所以就不贴了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ [Linux基础] 文件与目录管理（鸟哥Linux第六章）]]></title>
        <id>https://lixin-ee.github.io//post/linux-ji-chu-wen-jian-yu-mu-lu-guan-li-niao-ge-linux-di-liu-zhang</id>
        <link href="https://lixin-ee.github.io//post/linux-ji-chu-wen-jian-yu-mu-lu-guan-li-niao-ge-linux-di-liu-zhang">
        </link>
        <updated>2019-12-30T12:24:53.000Z</updated>
        <content type="html"><![CDATA[<p>绝对路径：路径的写法『一定由根目录 / 写起』<br>
相对路径：路径的写法『不是由 / 写起』</p>
<ul>
<li>目录的相关操作<br>
. 代表此层目录<br>
.. 代表上一层目录<br>
-代表前一个工作目录<br>
~ 代表『目前用户身份』所在的家目录<br>
~account 代表 account 这个用户的家目录(account 是个账号名称)</li>
</ul>
<p>在所有目录底下都会存在的两个目录，分别是『.』与『..』 分别代表此层与上层<br>
目录的意思。</p>
<p>几个常见的处理目录的指令：<br>
•  cd：变换目录<br>
cd 是 Change Directory 的缩写</p>
<p>•  pwd：显示当前目录<br>
-P ：显示出确实的路径，而非使用链接 (link) 路径。<br>
pwd 是 Print Working Directory 的缩写，也就是显示目前所在目录的指令</p>
<p>•  mkdir：建立一个新的目录<br>
-m ：配置文件案的权限喔！直接设定，不需要看预设权限 (umask) 的脸色<br>
-p ：帮助你直接将所需要的目录(包含上层目录)递归建立起来！</p>
<p>•  rmdir：删除一个空的目录<br>
-p ：连同『上层』『空的』目录也一起删除<br>
目录需要一层一层的删除才行！而且被删除的目录里面必定不能存在其他的目录或文 件<br>
那如果要将所有目录下的东西都杀掉就必须使用『 rm -r test 』</p>
<ul>
<li>关于执行文件路径的变量： $PATH<br>
echo <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mi>A</mi><mi>T</mi><mi>H</mi><mi mathvariant="normal">环</mi><mi mathvariant="normal">境</mi><mi mathvariant="normal">变</mi><mi mathvariant="normal">量</mi><mi mathvariant="normal">打</mi><mi mathvariant="normal">印</mi><mi mathvariant="normal">，</mi><mi>e</mi><mi>c</mi><mi>h</mi><mi>o</mi><mi mathvariant="normal">有</mi><mi mathvariant="normal">『</mi><mi mathvariant="normal">显</mi><mi mathvariant="normal">示</mi><mi mathvariant="normal">、</mi><mi mathvariant="normal">印</mi><mi mathvariant="normal">出</mi><mi mathvariant="normal">』</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">，</mi></mrow><annotation encoding="application/x-tex">PATH 环境变量打印，echo 有『显示、印出』的，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord cjk_fallback">环</span><span class="mord cjk_fallback">境</span><span class="mord cjk_fallback">变</span><span class="mord cjk_fallback">量</span><span class="mord cjk_fallback">打</span><span class="mord cjk_fallback">印</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">o</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">『</span><span class="mord cjk_fallback">显</span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">、</span><span class="mord cjk_fallback">印</span><span class="mord cjk_fallback">出</span><span class="mord cjk_fallback">』</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">，</span></span></span></span> 表示后面接的是变量<br>
PATH(一定是大写)这个变量的内容是由一堆目录所组成的，每个目录中间用冒号(:)来隔开， 每个目 录是有『顺序』之分的。</li>
</ul>
<p>修改PATH：[root@study ~]#PATH=&quot;${PATH}:/root&quot; (将/root 加入 PATH 当中)</p>
<p>为了安全起见，不建议将当前目录『.』加入 PATH 的搜寻目录中。</p>
<ul>
<li>
<p>文件与目录管理<br>
文件与目录的检视： ls<br>
选项与参数：<br>
<strong>-a ：全部的文件，连同隐藏档( 开头为 . 的文件) 一起列出来(常用)</strong><br>
-A ：全部的文件，连同隐藏档，但不包括 . 与 .. 这两个目录<br>
<strong>-d ：仅列出目录本身，而不是列出目录内的文件数据(常用)</strong><br>
-f ：直接列出结果，而不进行排序 (ls 预设会以档名排序！)<br>
-F ：根据文件、目录等信息，给予附加数据结构，例如：* :代表可执行文件； /:代表目录； =:代表 socket 文件； |:代表 FIFO 文件；<br>
-h ：将文件容量以人类较易读的方式(例如 GB, KB 等等)列出来；<br>
-i ：列出 inode 号码，inode 的意义下一章将会介绍；<br>
<strong>-l ：长数据串行出，包含文件的属性与权限等等数据；(常用)</strong><br>
-n ：列出 UID 与 GID 而非使用者与群组的名称 (UID 与 GID 会在账号管理提到！)<br>
-r ：将排序结果反向输出，例如：原本档名由小到大，反向则为由大到小；<br>
-R ：连同子目录内容一起列出来，等于该目录下的所有文件都会显示出来；<br>
-S ：以文件容量大小排序，而不是用档名排序；<br>
-t ：依时间排序，而不是用档名。<br>
--color=never ：不要依据文件特性给予颜色显示；<br>
--color=always ：显示颜色<br>
--color=auto ：让系统自行依据设定来判断是否给予颜色<br>
--full-time ：以完整时间模式 (包含年、月、日、时、分) 输出<br>
--time={atime,ctime} ：输出 access 时间或改变权限属性时间 (ctime)<br>
而非内容变更时间 (modification time)<br>
当你只有下达 ls 时，默认显示的只有：非隐藏档的档名、 以档名进行排序及文件名代表的颜色显示</p>
</li>
<li>
<p>复制、删除与移动： cp, rm, mv<br>
cp ( 复制 文件 或目录)<br>
<strong>-a ：相当于 -dr --preserve=all 的意思，至于 dr 请参考下列说明；(常用)</strong><br>
-d ：若来源文件为链接文件的属性(link file)，则复制链接文件属性而非文件本身；<br>
-f ：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；<br>
<strong>-i ：若目标文件(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</strong><br>
-l ：进行硬式连结(hard link)的连结档建立，而非复制文件本身；<br>
<strong>-p ：连同文件的属性(权限、用户、时间)一起复制过去，而非使用默认属性(备份常用)；</strong><br>
<strong>-r ：递归持续复制，用于目录的复制行为；(常用)</strong><br>
-s ：复制成为符号链接文件 (symbolic link)，亦即『快捷方式』文件；<br>
-u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制。（在目标文件与来源文件有差异时，才会复制，比较常被用于『备份』的工作）<br>
--preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links,xattr 等也复制了。</p>
</li>
</ul>
<p>如果来源档有两个以上，则最后一个目的文件一定要是『目录』<br>
在预设的条件中， cp 的来源档与目的档的权限是不同的，目的档的拥有者通常会是指令操作者本身。</p>
<p>使用 -l 及 -s 都会建立所谓的连结档(link file)，但是这两种连结档却有不一样的 情况。那个 -l 就是所谓的实体链接(hard link)，至于 -s 则是符号链接(symbolic link)，符号链接(symbolic link)是一个『快捷方式』，实体链接(hard link) 与 bashrc 的属性与权限完全一模一样，与尚未进行连结前的差异则是第二栏的 link 数由 1 变成 2</p>
<ul>
<li>rm ( 移除文件或目录)<br>
选项与参数：<br>
-f ：就是 force 的意思，忽略不存在的文件，不会出现警告讯息；<br>
-i ：互动模式，在删除前会询问使用者是否动作<br>
-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！</li>
</ul>
<p>使用『 rm -r 』这个指令之前，请千万注 意了，因为该目录或文件『肯定』会被 root 杀掉！</p>
<ul>
<li>
<p>mv ( 移动文件与目录，或更名)<br>
选项与参数：<br>
-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；<br>
-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！<br>
-u ：若目标文件已经存在，且 source 比较新，才会更新 (update)</p>
</li>
<li>
<p>取得路径的文件名与目录名称</p>
</li>
</ul>
<p>[root@study ~]#  basename /etc/sysconfig/network<br>
network &lt;== 很简单！就取得最后的档名～<br>
[root@study ~]#  dirname /etc/sysconfig/network<br>
/etc/sysconfig &lt;== 取得的变成目录名了！</p>
<ul>
<li>文件内容查阅<br>
查阅一个文件的内容：<br>
•  cat 由第一行开始显示文件内容<br>
•  tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！<br>
•  nl 显示的时候，顺道输出行号！<br>
•  more 一页一页的显示文件内容<br>
•  less 与 more 类似，但是比 more 更好的是，他可以往前翻页！<br>
•  head 只看头几行<br>
•  tail 只看尾巴几行<br>
•  od 以二进制的方式读取文件内容！</li>
</ul>
<p>在 more 的时候，我们并没有办法向前面翻， 只能往后面看，但若使用了 less 时，就可以使用 [pageup] [pagedown] 等按键的功能来往前往后翻看文件<br>
在 less 里头可以拥有更多的『搜寻』功能，不止可以向下搜寻，也可以向上搜寻<br>
man 这个指令就是呼叫 less 来显示说明文件的内容的</p>
<ul>
<li>修改文件时间或建置新档： touch</li>
</ul>
<ul>
<li>modification time (mtime)： 当该文件的『内容数据』变更时，就会更新这个时间！内容数据指的是文件的内容，而不是文件的属性或 权限喔！</li>
<li>status time (ctime)： 当该文件的『状态 (status)』改变时，就会更新这个时间，举例来说，像是权限与属性被更改了，都会更新 这个时间啊。</li>
<li>access time (atime)： 当『该文件的内容被取用』时，就会更新这个读取时间 (access)。举例来说，我们使用 cat 去读取 /etc/man_db.conf ， 就会更新该文件的 atime 了。<br>
在默认的情况下，ls 显示出来的是该文件的 mtime ，也就是这个文件的内容上次被更动 的时间。</li>
</ul>
<p>时间修改指令：<br>
[root@study ~]#  touch [-acdmt]  文件<br>
选项与参数：<br>
-a ：仅修订 access time；<br>
-c ：仅修改文件的时间，若该文件不存在则不建立新文件；<br>
-d ：后面可以接欲修订的日期而不用目前的日期，也可以使用 --date=&quot;日期或时间&quot;<br>
-m ：仅修改 mtime ；<br>
-t ：后面可以接欲修订的时间而不用目前的时间，格式为[YYYYMMDDhhmm]</p>
<p>如果 touch 后面有接文件，则该文件的三个时间 (atime/ctime/mtime) 都会更新为目前的时间。若该文件不存在， 则会主动的建立一个新的空的文件</p>
<p>touch 这个指令最常被使用的情况是：<br>
•  建立一个空的文件；<br>
•  将某个文件日期修订为目前 (mtime 与 atime)</p>
<ul>
<li>文件与目录的默认权限与隐藏权限<br>
新增一个文件或目录时，默认的权限</li>
</ul>
<p>文件预设权限：umask<br>
umask 就是指定 『目前用户在建立文件或目录时候的权限默认值』<br>
查阅的方式有两种，一种可以直接输入 umask ，就可以看到数字型态的权限设定分数， 一种则是加入 -S (Symbolic) 这个选项，就会以符号类型的方式来显示出权限</p>
<p><strong>umask 的分数指的是『该默认值需要减掉的权限！』</strong></p>
<p>设定 umask ：直接在 umask 后面输入 需要减去的权限值就好了</p>
<ul>
<li>文件隐藏属性<br>
chattr ( 配置文件案隐藏属性) chattr [+-=][ASacdistu]  文件 或目 录 名 称<br>
+：增加某一个特殊参数，其他原本存在参数则不动。<br>
-：移除某一个特殊参数，其他原本存在参数则不动。<br>
= ：设定一定，且仅有后面接的参数</li>
</ul>
<p>a ：当设定 a 之后，这个文件将只能增加数据，而不能删除也不能修改数据，只有 root 才能设定这属性<br>
i ：这个 i 可就很厉害了！他可以让一个文件『不能被删除、改名、设定连结也无法写入或新增数据！』对于系统安全性有相当大的帮助！只有 root 能设定此属性</p>
<p>lsattr ( 显示文件隐藏属性)</p>
<ul>
<li>文件特殊权限： SUID, SGID, SBIT</li>
</ul>
<ol>
<li>
<p>Set UID : s 这个标志会出现在文件拥有者的 x 权限上，被称为 Set UID，简称为 SUID 的特殊权限<br>
基本上 SUID 有这样的限制与功能：<br>
•  SUID 权限仅对二进制程序(binary program)有效；<br>
•  执行者对于该程序需要具有 x 的可执行权限；<br>
•  本权限仅在执行该程序的过程中有效 (run-time)；<br>
•  执行者将具有该<strong>程序拥有者 (owner) 的权限</strong>。<br>
<img src="https://lixin-ee.github.io//post-images/1577711413192.png" alt=""><br>
SUID 仅可用在 binary program 上， 不能够用在 shell script 上面<br>
SUID 对于目录也是无效的</p>
</li>
<li>
<p>Set GID<br>
s 在群组的 x 时则称为 Set GID, SGID<br>
与 SUID 不同的是，SGID 可以针对文件或目录来设定<br>
如果是对文件来说， SGID 有如下的功能：<br>
•  SGID 对二进制程序有用；<br>
•  程序执行者对于该程序来说，需具备 x 的权限；<br>
•  执行者在执行的过程中将会获得该程序群组的支持！</p>
</li>
</ol>
<p>当一个目录设定了 SGID 的权限后，他将具有如下的功能：<br>
•  用户若对于此目录具有 r 与 x 的权限时，该用户能够进入此目录；<br>
•  用户在此目录下的有效群组(effective group)将会变成该目录的群组；<br>
•  用途：若用户在此目录下具有 w 的权限(可以新建文件)，则使用者所建立的新文件，该新文件的群组与此目录的群组相同</p>
<ol start="3">
<li>Sticky Bit<br>
Sticky Bit, SBIT 目前只针对目录有效，对于文件已经没有效果了<br>
SBIT 对于目录的作用是：<br>
•  当用户对于此目录具有 w, x 权限，亦即具有写入的权限时；<br>
•  当用户在该目录下建立文件或目录时，仅有自己与 root 才有权力删除该文件</li>
</ol>
<ul>
<li>
<p>SUID/SGID/SBIT权限设定<br>
数字型态更改权限的方式为『三个数字』的组合， 那么如果在这三个数字之前再加上一个数字的话，最前面的那个数字就代表这几个权限了！<br>
•  4 为 SUID<br>
•  2 为 SGID<br>
•  1 为 SBIT<br>
假设要将一个文件权限改为『-rwsr-xr-x』时，由于 s 在用户权力中，所以是 SUID ，因此， 在原先的 755 之前还要加上 4 ，也就是：『 chmod 4755 filename 』来设定<br>
大写的 S 与 T ： 因为 s 与 t 都是取代 x 这个权限的，但是我们是下达 7666 ！也就是说， user, group 以及others 都没有 x 这个可执行的标志( 因为 666 嘛 )，所以这个 S, T 代表的就是『空的』。SUID 是表示『该文件在执行的时候，具有文件拥有者的权限』，但是文件 拥有者都无法执行了当然就是空的<br>
而除了数字法之外，也可以透过符号法来处理，其中 SUID 为 u+s ，而 SGID 为 g+s ，SBIT则是 o+t</p>
</li>
<li>
<p>观察文件类型：file<br>
想要知道某个文件的基本数据，例如是属于 ASCII 或者是 data 文件，或者是 binary ， 且其中有没有使用到动态函式库 (share library) 等等的信息，就可以利用 file 这个指令来检阅</p>
</li>
<li>
<p>指令与 文件 的搜寻</p>
</li>
</ul>
<p>脚本文件名的搜寻<br>
指令的完整文件名和位置，透过 which或 type 来找寻</p>
<p>which 指令是根据『PATH』这个环境变量所规范的路径，去搜寻『执行档』的档名，所以找不到history 等『bash 内建的指令』,若加上 -a 选项，则可以列出所有的可以找到的同名执行文件，而非仅显示第一个</p>
<ul>
<li>文件档名的搜寻<br>
Linux 的搜寻指令find 不很常用的，因为速度慢之外， 也很操硬盘！一般我们都是先使用 whereis 或者是 locate 来检查，如果真的找不到了，才以 find 来搜寻<br>
因为 whereis 只找系统中某些特定目录底下的文件而已，locate则是利用数据库来搜寻文件名，当然两者就相当的快速， 并且没有实际的搜寻硬盘内的文件系统状态，比较省时间</li>
</ul>
<p>如果你要找的文件是具有特殊属性的，例如 SUID 、文件拥有者、文件大小等等， 那么利用 locate是没有办法达成</p>
<p>搜寻系统中不属于任何人的文件<br>
find /- nouser<br>
透过这个指令，可以轻易的就找出那些不太正常的文件。如果有找到不属于系统任何人的文件时，</p>
<p>find 的特殊功能就是能够进行额外的动作(action)。<br>
<img src="https://lixin-ee.github.io//post-images/1577711985462.png" alt=""><br>
该范例中特殊的地方有 {} 以及 ; 还有 -exec 这个关键词，这些东西的意义为：<br>
•  {} 代表的是『由 find 找到的内容』，如上图所示，find 的结果会被放置到 {} 位置中；<br>
•  -exec 一直到 ; 是关键词，代表 find 额外动作的开始 (-exec) 到结束 (;) ，在这中间的就是 find 指令内的额外动作。 在本例中就是『 ls -l {} 』啰！<br>
•  因为『 ; 』在 bash 环境下是有特殊意义的，因此利用反斜杠来跳脱。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于右值与移动构造函数]]></title>
        <id>https://lixin-ee.github.io//post/guan-yu-you-zhi-yu-yi-dong-gou-zao-han-shu</id>
        <link href="https://lixin-ee.github.io//post/guan-yu-you-zhi-yu-yi-dong-gou-zao-han-shu">
        </link>
        <updated>2019-12-30T03:57:06.000Z</updated>
        <content type="html"><![CDATA[<p>loading</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 53. 最大子序和[简单][动态规划][分治法]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-53-zui-da-zi-xu-he-jian-dan-dong-tai-gui-hua-fen-zhi-fa</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-53-zui-da-zi-xu-he-jian-dan-dong-tai-gui-hua-fen-zhi-fa">
        </link>
        <updated>2019-12-30T02:14:20.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>
示例:<br>
输入: [-2,1,-3,4,-1,2,1,-5,4],<br>
输出: 6<br>
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。<br>
进阶:<br>
如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/maximum-subarray<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>很明显的动态规划，然后进阶提示分治法hhh<br>
首先实现一下动态规划，主要的障碍点在于连续这个点<br>
如果是用0和1代表选择和不选择 那么0这个点就不能保存状态 那么今天的状态就等于叠加前一天的值和今天的值之间的最大值了<br>
然后注意因为可能会抛弃前面的序列或者后面的序列 比如 [1,-10,2] [2,-10,1]这两种情况存在，所以不可以返回动态规划数组的最后一个值<br>
必须用一个maxv存放历史最大值</p>
<p>分治法的话我感觉就是先分割到每个数，然后两两结合 返回当[左值，右值，左值+右值]之间的最大值<br>
但是问题来了， 怎么保证连续呢？类似于归并排序，merge是关键<br>
分治法还是没有想到好的合并方法，所以直接看题解</p>
<pre><code>class Solution {
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) {
        int len=nums.size();
        int res=nums[0];
        vector&lt;int&gt; maxv(len);
        maxv[0]=nums[0];
        for(int i=1;i&lt;len;++i){
           maxv[i]=max(maxv[i-1]+nums[i],nums[i]);
            res=max(res,maxv[i]);
        }
        return res;
    }

};
</code></pre>
<p>然后来看看题解<br>
动态规划法没啥好说的了<br>
比较有趣的是高赞回答</p>
<blockquote>
<p>思路<br>
这道题用动态规划的思路并不难解决，比较难的是后文提出的用分治法求解，但由于其不是最优解法，所以先不列出来<br>
动态规划的是首先对数组进行遍历，当前最大连续子序列和为 sum，结果为 ans<br>
如果 sum &gt; 0，则说明 sum 对结果有增益效果，则 sum 保留并加上当前遍历数字<br>
如果 sum &lt;= 0，则说明 sum 对结果无增益效果，需要舍弃，则 sum 直接更新为当前遍历数字<br>
每次比较 sum 和 ans的大小，将最大值置为ans，遍历结束返回结果<br>
时间复杂度：O(n)<br>
代码</p>
</blockquote>
<pre><code>Java
class Solution {
    public int maxSubArray(int[] nums) {
        int ans = nums[0];
        int sum = 0;
        for(int num: nums) {
            if(sum &gt; 0) {
                sum += num;
            } else {
                sum = num;
            }
            ans = Math.max(ans, sum);
        }
        return ans;
    }
}
</code></pre>
<p>这个思路很有趣，我们一般会想当前元素nums[i]对sum有没有增益，而这个题解要点在于反过来考虑sum对当前元素nums[i]有没有增益</p>
<p>关于分治法我曾经看到一个比较好的题解。。。但是突然找不到了。。。难道是被删了？？？<br>
主要的要点就是</p>
<blockquote>
<p>分治法<br>
这个是使用分治法解决问题的典型的例子，并且可以用与合并排序相似的算法求解。下面是用分治法解决问题的模板：<br>
定义基本情况。<br>
将问题分解为子问题并递归地解决它们。<br>
合并子问题的解以获得原始问题的解。<br>
算法：<br>
当最大子数组有 n 个数字时：<br>
若 n==1，返回此元素。<br>
left_sum 为最大子数组前 n/2 个元素，在索引为 (left + right) / 2 的元素属于左子数组。<br>
right_sum 为最大子数组的右子数组，为最后 n/2 的元素。<br>
cross_sum 是包含左右子数组且含索引 (left + right) / 2 的最大值。</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1577674348344.png" alt=""></p>
<pre><code>class Solution
{
public:
    int maxSubArray(vector&lt;int&gt; &amp;nums)
    {
        //类似寻找最大最小值的题目，初始值一定要定义成理论上的最小最大值
        int result = INT_MIN;
        int numsSize = int(nums.size());
        result = maxSubArrayHelper(nums, 0, numsSize - 1);
        return result;
    }

    int maxSubArrayHelper(vector&lt;int&gt; &amp;nums, int left, int right)
    {
        if (left == right)
        {
            return nums[left];
        }
        int mid = (left + right) / 2;
        int leftSum = maxSubArrayHelper(nums, left, mid);
        //注意这里应是mid + 1，否则left + 1 = right时，会无线循环
        int rightSum = maxSubArrayHelper(nums, mid + 1, right);
        int midSum = findMaxCrossingSubarray(nums, left, mid, right);
        int result = max(leftSum, rightSum);
        result = max(result, midSum);
        return result;
    }

    int findMaxCrossingSubarray(vector&lt;int&gt; &amp;nums, int left, int mid, int right)
    {
        int leftSum = INT_MIN;
        int sum = 0;
        for (int i = mid; i &gt;= left; i--)
        {
            sum += nums[i];
            leftSum = max(leftSum, sum);
        }

        int rightSum = INT_MIN;
        sum = 0;
        //注意这里i = mid + 1，避免重复用到nums[i]
        for (int i = mid + 1; i &lt;= right; i++)
        {
            sum += nums[i];
            rightSum = max(rightSum, sum);
        }
        return (leftSum + rightSum);
    }
};
</code></pre>
<p>注意跨中心的情况需要用贪心法进行计算<br>
始终觉得在这里用分治法怪怪的</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[并发与并行、多核与多线程]]></title>
        <id>https://lixin-ee.github.io//post/bing-fa-yu-bing-xing</id>
        <link href="https://lixin-ee.github.io//post/bing-fa-yu-bing-xing">
        </link>
        <updated>2019-12-30T00:58:20.000Z</updated>
        <content type="html"><![CDATA[<p>今天早上在看muduo的方案介绍事产生了一点疑惑<br>
书中的描述：</p>
<blockquote>
<p>方案5：这间小银行有一个旋转门、一个柜台，每次只允许一名客户办理业务。而且当有人在办理业务时，旋转门是锁住的（计算和IO 在同一线程）。为了维持工作效率，银行要求客户应该尽快办理业务，最好不要在取款的时候打电话去问家里人密码，也不要在通过旋转门的时候停下来系鞋带，这都会阻塞其他堵在门外的客户。如果客户很少，这是很经济且高效的方案；但是如果场地较大（多核），则这种布局就浪费了不少资源，只能并发（concurrent）不能并行（parallel）。如果确实一次办不完，应该离开柜台，到门外等着，等银行通知再来继续办理（分阶段回调）</p>
</blockquote>
<p>我的疑惑就在于：但是如果场地较大（多核），则这种布局就浪费了不少资源，只能<strong>并发(concurrent)</strong> 不能<strong>并行（parallel）</strong>。如果确实一次办不完，应该离开柜台，到门外等着，等银行通知再来继续办理（分阶段回调）</p>
<p>一瞬间我发现我对并发和并行的定义有点模糊了，因为我记得并发不是一个进程分为多个部分或者多个进程或多个线程交替执行吗？但是Reactor执行不是顺序执行的吗？</p>
<p>于是我去查了一下<br>
参考<a href="https://www.zhihu.com/question/33515481">并发与并行的区别？</a></p>
<blockquote>
<p>如果某个系统支持两个或者多个动作（Action）同时存在，那么这个系统就是一个<strong>并发系统</strong>。<br>
如果某个系统支持两个或者多个动作同时执行，那么这个系统就是一个<strong>并行系统</strong>。并发系统与并行系统这两个定义之间的关键差异在于“存在”这个词。<br>
并发和并行都可以是很多个线程，就看这些线程能不能同时被（多个）cpu执行，如果可以就说明是并行，而并发是多个线程被（一个）cpu 轮流切换着执行。<br>
并发就是指代码<strong>逻辑上可以并行</strong>，有并行的潜力，但是<strong>不一定当前是真的</strong>以物理并行的方式运行<br>
并发指的是代码的性质，并行指的是<strong>物理运行状态</strong></p>
</blockquote>
<p>然后是翻查CSAPP中的解释：</p>
<blockquote>
<p>一个逻辑流的执行在时间上与另一个流重叠，称为<strong>并发流（concurrent flow）</strong>，这两个流并发地运行<br>
多个流并发地执行的一般现象称为并发（concurrency）。一个进程和其他进程轮流运行的概念称为多任务（multitasking）。一个进程执行它的控制流的一部分的每一时间段叫做时间片（time slice），因此多任务也叫作时间分片（time slicing）；<br>
并发流的思想与流运行的处理器核数或者计算机数无关。如果两个流在时间上重叠，那么它们就是并发的，它是并发流的一个真子集。如果两个流并发地运行在不同的处理器核或者计算机上，那么我们称它们为<strong>并行流（parallel flow）</strong>，它们并行地运行（running in parallel），且并行地执行。<br>
并行流是并发流的真子集，并行流一定是并发流，并发流不一定是并行流。</p>
</blockquote>
<p>看来我对并发和并行的理解并没有错误啊<br>
那就是对Reactor的理解出现了偏差</p>
<p>然后我回去看了方案6和方案7的描述，发现一个问题</p>
<blockquote>
<p>它为每个请求（而不是每个连接）创建了一个新线程（方案6）<br>
每个连接创建一个计算线程，每个连接上的请求固定发给同一个线程去算（方案7）</p>
</blockquote>
<p>注意 连接-请求-线程 这三者！！！特别是一个连接下可以有多个请求！！！而不是必须一个连接一个请求！！！</p>
<p>那么回到方案5的描述 我们可以看到</p>
<blockquote>
<p>如果确实一次办不完，应该离开柜台，到门外等着，等银行通知再来继续办理（分阶段回调）</p>
</blockquote>
<p>这里就是请求的问题了，注意是等待通知而不是重新排队，相当于在并发运行，所以方案5只能并发不能并行就是这么来的</p>
<p>然后另外一个疑惑就是</p>
<blockquote>
<p>方案7 与方案6 的另外一个区别是单个client 的最大CPU 占用率。在方案6 中，一个TCP 连接上发来的一长串突发请求（burst requests）可以占满全部8 个core；而在方案7 中，由于每个连接上的请求固定由同一个线程处理，那么它最多占用12.5%的CPU 资源。</p>
</blockquote>
<p>这里就确实是我的认知出现了偏差，把 一个cpu当前只能运行一个进程+进程是资源分配的最小单位，线程是CPU调度的最小单位 误理解为 一个进程只能在一个cpu上运行（以为它的多线程也只能分配到这个cpu上）（错误的）<br>
这个明显是错误的，一个进程可以在多个cpu上运行，比如一个进程的多个线程可以在多个cpu上运行，这也就是方案6收到突发性爆炸请求占满cpu和方案7只开了8个线程（注意这里假设8个core）每个只占12.5%的由来<br>
但注意！一个线程是只能在一个cpu上跑的，无法切割开来</p>
<p>参考资料<br>
<img src="https://lixin-ee.github.io//post-images/1577669961214.png" alt=""><br>
方案2 这是传统的Java 网络编程方案thread-per-connection，在Java 1.4 引入NIO 之前，Java 网络服务多采用这种方案。它的初始化开销比方案1 要小很多，但与求解Sudoku 的用时差不多，仍然不适合短连接服务。这种方案的伸缩性受到线程数的限制，一两百个还行，几千个的话对操作系统的scheduler 恐怕是个不小的负担。<br>
方案5 基本的单线程Reactor 方案。这种方案的优点是由网络库搞定数据收发，程序只关心业务逻辑；缺点：适合IO 密集的应用，不太适合CPU 密集的应用，因为较难发挥多核的威力。另外，与方案2 相比，方案5 处理网络消息的延迟可能要略大一些，因为方案2 直接一次read(2) 系统调用就能拿到请求数据，而方案5 要先poll(2) 再read(2)，多了一次系统调用。</p>
<p>方案6 这是一个过渡方案，收到Sudoku 请求之后，不在Reactor 线程计算，而是创建一个新线程去计算，以充分利用多核CPU。这是非常初级的多线程应用，因为它为每个请求（而不是每个连接）创建了一个新线程。这个开销可以用线程池来避免，即方案8。这个方案还有一个特点是out-of-order，即同时创建多个线程去计算同一个连接上收到的多个请求，那么算出结果的次序是不确定的，可能第2 个Sudoku 比较简单，比第1 个先算出结果。这也是我们在一开始设计协议的时候使用了id 的原因，以便客户端区分response 对应的是哪个request。</p>
<p>方案7 为了让返回结果的顺序确定，我们可以为每个连接创建一个计算线程，每个连接上的请求固定发给同一个线程去算，先到先得。这也是一个过渡方案，因为并发连接数受限于线程数目，这个方案或许还不如直接使用阻塞IO 的thread-per-connection 方案2。</p>
<p>方案7 与方案6 的另外一个区别是单个client 的最大CPU 占用率。在方案6 中，一个TCP 连接上发来的一长串突发请求（burst requests）可以占满全部8 个core；而在方案7 中，由于每个连接上的请求固定由同一个线程处理，那么它最多占用12.5%的CPU 资源。这两种方案各有优劣，取决于应用场景的需要（到底是公平性重要还是突发性能重要）。这个区别在方案8 和方案9 中同样存在，需要根据应用来取舍。</p>
<p>方案8 为了弥补方案6 中为每个请求创建线程的缺陷，我们使用固定大小线程池，程序结构如图6-12 所示。全部的IO 工作都在一个Reactor 线程完成，而计算任务交给thread pool。如果计算任务彼此独立，而且IO 的压力不大，那么这种方案是非常适用的。</p>
<p>方案9 这是muduo 内置的多线程方案，也是Netty 内置的多线程方案。这种方案的特点是one loop per thread，有一个main Reactor 负责accept(2) 连接，然后把连接挂在某个sub Reactor 中（muduo 采用round-robin 的方式来选择sub Reactor），这样该连接的所有操作都在那个sub Reactor 所处的线程中完成。多个连接可能被分派到多个线程中，以充分利用CPU。</p>
<p>muduo 采用的是固定大小的Reactor pool，池子的大小通常根据CPU 数目确定，也就是说线程数是固定的，这样程序的总体处理能力不会随连接数增加而下降。另外，由于一个连接完全由一个线程管理，那么请求的顺序性有保证，突发请求也不会占满全部8 个核（如果需要优化突发请求，可以考虑方案11）。这种方案把IO 分派给多个线程，防止出现一个Reactor 的处理能力饱和。</p>
<p>与方案8 的线程池相比，方案9 减少了进出thread pool 的两次上下文切换，在把多个连接分散到多个Reactor 线程之后，小规模计算可以在当前IO 线程完成并发回结果，从而降低响应的延迟。我认为这是一个适应性很强的多线程IO 模型，因此把它作为muduo 的默认线程模型（见图6-13）。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Linux基础] 文件权限与目录配置（鸟哥Linux第五章）]]></title>
        <id>https://lixin-ee.github.io//post/linux-ji-chu-wen-jian-quan-xian-yu-mu-lu-pei-zhi-niao-ge-linux-di-wu-zhang</id>
        <link href="https://lixin-ee.github.io//post/linux-ji-chu-wen-jian-quan-xian-yu-mu-lu-pei-zhi-niao-ge-linux-di-wu-zhang">
        </link>
        <updated>2019-12-29T13:22:46.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>文件概览<br>
Linux 一般将文件可存取的身份分为三个类别，分别是 <code>owner/group/others</code><br>
且三种身份各有<code>read/write/execute</code> 等权限。</li>
</ul>
<p>『 ls -al 』察看文件的指令<br>
ls 是『list』的意思，重点在显示文件的文件名与相关属性，选项『-al』则表示列出所有的文件详 细的权限与属性<br>
<img src="https://lixin-ee.github.io//post-images/1577625881102.png" alt=""></p>
<p>第一栏代表这个文件的类型与权限(permission) ：<br>
第一个字符代表这个文件是『目录、文件或链接文件等等』：</p>
<ul>
<li>当为[ d ]则是目录，例如上表档名为『.config』的那一行；</li>
<li>当为[ ]则是文件，例如上表档名为『initial-setup-ks.cfg』那一行；</li>
<li>若是[ l ]则表示为连结档(link file)；</li>
<li>若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；</li>
<li>若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。</li>
</ul>
<p>[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)<br>
第一组为『文件拥有者可具备的权限』（<strong>而不是root</strong>）<br>
第二组为『加入此群组之账号的权限』；<br>
第三组为『非本人且没有加入本群组之其他账号的权限』</p>
<ul>
<li>第二栏表示有多少档名连结到此节点(i-node)</li>
<li>第三栏表示这个文件( 或目录) 的『拥有者账号』</li>
<li>第四栏表示这个文件在 Linux 系统下，你的账号会加入于一个或多个的群组中。</li>
<li>第五栏为这个文件的容量大小，默认单位为 bytes ；</li>
<li>第六栏为这个文件的建档日期或者是最近的修改日期</li>
<li>第七栏为这个文件的档名,如果档名之前多一个『 . 』，则代表这个文件为『隐藏档』</li>
</ul>
<ul>
<li>如何改变文件属性与权限</li>
</ul>
<ul>
<li>chgrp ：改变文件所属群组  chgrp [-R] dirname/filename ...</li>
<li>chown ：改变文件拥有者 chown [-R] 账号名称 文件或目录</li>
</ul>
<p>需要注意的地方<br>
-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件、目录 都更新成为这个群组之意。常常用在变更某一目录内所有的文件之情况<br>
chown还可以顺便直接修改群组的名称<br>
由于复制行为(cp)会复制执行者的属性与权限，必须要将这个文件的拥有者与群组修改一下</p>
<ul>
<li>chmod ：改变文件的权限, SUID, SGID, SBIT 等等的特性</li>
<li>chmod [- R] xyz 文件或目录</li>
</ul>
<p>权限的设定方法有两种， 分别可以使用数字或者 是符号来进行权限的变更</p>
<ul>
<li>数字类型改变文件权限<br>
文件的权限字符为：『-rwxrwxrwx』，可以使用数字来代表各个权限，各权限的分数对照表如下： r:4 w:2 x:1<br>
每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx---] 分数 则是：<br>
owner = rwx = 4+2+1 = 7<br>
group = rwx = 4+2+1 = 7<br>
others= --- = 0+0+0 = 0</li>
</ul>
<p>-符号类型改变文件<br>
<img src="https://lixin-ee.github.io//post-images/1577626483344.png" alt=""></p>
<ul>
<li>目录与文件<br>
这里很重要，虽然目录和文件都是拥有相同的权限模式，但是不同的权限之间的意义不同</li>
</ul>
<p>-权限对于文件来说</p>
<ul>
<li>r (read)：可读取此一文件的实际内容，如读取文本文件的文字内容等；</li>
<li>w (write)：可以编辑、新增或者是修改该文件的内容 <strong>(但不含删除该文件)</strong>；</li>
<li>x (execute)：该文件具有可以被系统执行的权限。<br>
对于文件的 rwx 来说， 主要都是针对『文件 的内容』而言，与文件档名的存在与否没有关系</li>
</ul>
<p>-权限对目录的重要性</p>
<ul>
<li>r (read contents in directory)： 表示具有读取目录结构列表的权限，所以当你具有读取(r)一个目录的权限时，表示你可以查询该目录下的 文件名数据。 所以你就可以利用 ls 这个指令将该目录的内容列表显示出来！</li>
<li>w (modify contents of directory)： 这个可写入的权限对目录来说，是很了不起的！ 因为他表示你具有异动该目录结构列表的权限，也就是底 下这些权限：</li>
<li>建立新的文件与目录；</li>
<li><strong>删除已经存在的文件与目录(不论该文件的权限为何！)</strong></li>
<li>将已存在的文件或目录进行更名；</li>
<li>搬移该目录内的文件、目录位置。<br>
总之，目录的 w 权限就与该目录底下的文件名异动有关</li>
<li>x (access directory)：目录不可以被执 行，目录的 x 代表的是用户能否进入该目录成为工作目录的用途！ 所谓的工作目录(work directory)就是你 目前所在的目录啦！举例来说，当你登入 Linux 时， 你所在的家目录就是你当下的工作目录。而变换目录 的指令是『cd』(change directory)！<br>
开放目录给任何人浏览时，应该至少也要给予 r 及 x 的权限，但 <strong>w 权限不可随便给</strong><br>
<img src="https://lixin-ee.github.io//post-images/1577626751407.png" alt=""><br>
<img src="https://lixin-ee.github.io//post-images/1577626845793.png" alt=""></li>
</ul>
<ul>
<li>绝对路径与相对路径<br>
绝对路径：由根目录(/)开始写起的文件名或目录名称， 例如 /home/dmtsai/.bashrc；<br>
相对路径：相对于目前路径的文件名写法。 例如 ./home/dmtsai 或 ../../home/dmtsai/ 等等。反正开头不是 /就属于相对路径的写法<br>
特别注意这两个特殊的目录：<br>
. ：代表当前的目录，也可以使用 ./ 来表示；<br>
.. ：代表上一层目录，也可以 ../ 来代表。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[信号、信号量、互斥量与条件变量]]></title>
        <id>https://lixin-ee.github.io//post/xin-hao-liang-yu-tiao-jian-bian-liang</id>
        <link href="https://lixin-ee.github.io//post/xin-hao-liang-yu-tiao-jian-bian-liang">
        </link>
        <updated>2019-12-29T09:48:08.000Z</updated>
        <content type="html"><![CDATA[<p>这几天在读《现代操作系统》的时候读到了信号量这一章，定义如下：</p>
<p>信号（signal）：是一种处理异步事件的方式。信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程外，还可以发送信号给进程本身。<br>
类似于软中断，如果进程接受到了信号，就相当于发生了中断，这时候进程会切换到内核态去执行信号处理函数，注意下，一个进程可能有两个执行序列，一个是main，另一个就是信号处理函数，信号处理函数有自己的栈空间的。当执行完了信号处理函数，才会再回到main函数中被抢占的代码上。不同的信号有不同的功能，比如可以让进程结束。</p>
<p>信号量(Semaphore) ：进程间通信处理同步互斥的机制。是在多线程环境下使用的一种设施, 它负责协调各个线程, 以保证它们能够正确、合理的使用公共资源<br>
使用一个整形变量（或者新的变量类型）来累计唤醒次数。其中检查数值、修改变量值亦即可能发生的睡眠操作均作为一个单一的、不可分割的<strong>原子操作</strong>完成，保证一旦一个信号量操作开始，则在改操作完成或阻塞之前，其他进程均不允许访问该信号量。</p>
<p>所以我们可以看出信号和信号量两者完全没有关联，只是翻译为中文时两者描述重合度有点高，导致我有点误会了。</p>
<p>下面才是重点。</p>
<p>我看完信号量的例子后，突然有点迷惑，这信号量难道不是互斥量（mutex）的多计数版吗？？？或者说互斥量（下称 锁）不就是信号量的二元版？？？<br>
但是感觉总有啥地方说不过去啊。。。<br>
所以上网查看了一番，得到以下分析：</p>
<blockquote>
<p>虽然 Mutex和Semaphore 在一定程度上可以互相替代，比如你可以把 值最大为1 的Semaphore当Mutex用，也可以用Mutex＋计数器当Semaphore。<br>
但是对于设计理念上还是有不同的，Mutex管理的是资源的使用权，而Semaphore管理的是资源的数量，有那么一点微妙的小区别。<br>
打个比方，在早餐餐厅，大家要喝咖啡。<br>
如果用Mutex的方式，同时只有一个人可以使用咖啡机，他获得了咖啡机的使用权后，开始做咖啡，其他人只能在旁边等着，直到他做好咖啡后，另外一个人才能获得咖啡机的使用权。<br>
如果用Semaphore的模式，服务员会把咖啡做好放到柜台上，谁想喝咖啡就拿走一杯，服务员会不断做咖啡，如果咖啡杯被拿光了，想喝咖啡的人就排队等着。<br>
Mutex管理的是咖啡机的使用权，而Semaphore管理的是做好的咖啡数量。</p>
</blockquote>
<blockquote>
<p>锁是服务于共享资源的；而semaphore是服务于多个线程间的执行的逻辑顺序的。<br>
semaphore的本质就是调度线程 ，如果你要对共享资源进行保护，请用mutex<br>
条件锁，是为了避免绝大多数情况下都是lock ---&gt; 判断条件 ----&gt; unlock的这种很占资源但又不干什么事情的线程。</p>
</blockquote>
<p>上述对信号量和锁的本质差别已经描述得很清楚了<br>
但是我还是有点疑惑，其实就像陈硕所说，其实锁使用起来好很多啊（甚至日常需求中完全可以取代信号量），为什么就用了大篇幅介绍呢</p>
<p>然后我看到这个回答</p>
<blockquote>
<p>我个人认为最重要的一点，优先级反转没有一个人提到。这难道不是最大的区别吗？这也应该是用户最关心的。</p>
</blockquote>
<p>对哦！醍醐灌顶啊！在书中本来信号量就是承接非得忙等待的自旋锁来介绍了，自旋锁的一个问题就是优先级反转（高优先级进程L必须等待低优先级进程L离开临界区）</p>
<p>然后摘抄书中对信号量的介绍</p>
<blockquote>
<p>up操作对信号量的值增1，如果一个或多个进程在该信号量上睡眠，无法完成一个先前的down操作，则由系统选择其中的一个（如随机挑选）并允许该进程完成它的down操作</p>
</blockquote>
<p>这样就能保证系统能够尽可能挑选高优先级的进程来执行，间接避免优先级反转的问题</p>
<p>参考链接<a href="https://www.zhihu.com/question/47704079">semaphore和mutex的区别？</a></p>
<p>然后又看到 条件变量这个东西<br>
它的函数调用都需要传入mutex形参，并且需要先mutex加锁？？？<br>
这个就很疑惑了，我本来的想法是条件变量是用来判断符合条件后才进行mutex加锁的，现在怎么反过来了？<br>
后来看了解析后才发现问题所在，原来是pthread_cond_wait函数内部的问题</p>
<pre><code>mutex.lock();

while (判断“条件”是否成立) {
    pthread_cond_wait 等待
}

mutext.unlock();
</code></pre>
<p>将 pthread_cond_wait 展开，内部实现中，会有下面的过程。</p>
<pre><code>mutext.unlock()
阻塞
唤醒
mutext.lock()
</code></pre>
<p>假如在线程 A中完全展开 pthread_cond_wait。</p>
<pre><code>mutex.lock();

while (判断“条件”是否成立) {
    做一些其它事情
    mutext.unlock()
    阻塞
    唤醒
    mutext.lock()
}

mutext.unlock();
</code></pre>
<p>所以得到结论</p>
<blockquote>
<p>传递的mutex并不是为了防止wait()函数内部的Race Condition！而是因为调用wait()之前你总是获得了某个mutex（例如用于解决此处pass变量的Race Condition的mutex），并且这个mutex在你调用wait()之前必须得释放掉，调用wait()之后必须得重新获取。</p>
</blockquote>
<p>我的结论 ：pthread_cond_wait内部有四个操作  解锁-wait-阻塞-唤醒-上锁 前两者是必须保证原子性的，否则阻塞之前唤醒信号就来了，再进入阻塞，会导致无法唤醒<br>
所以！！！传入mutex形参是为了保护while的条件判断，而不是循环内部要上锁</p>
<p>然后StackOverflow上的高赞回答：<br>
他们不是一回事。它们用于不同目的！<br>
虽然两种类型的信号量都具有full/empty状态并使用相同的API，但它们的用法却大不相同。<br>
Mutex<br>
Mutex用于保护共享资源（数据结构，文件等）。<br>
Mutex由执行该任务的任务“拥有”。如果任务B尝试给任务A当前持有的互斥锁赋值，则任务B的调用将返回错误并失败。<br>
互斥对象始终使用以下顺序：<br>
-SemTake-<br>
关键部分<br>
-SemGive<br>
这是一个简单的示例：<br>
Thread A                     Thread B<br>
Take Mutex<br>
access data<br>
...                        Take Mutex  &lt;== Will block<br>
...<br>
Give Mutex           access data  &lt;== Unblocks<br>
...<br>
Give Mutex																		<br>
二元Semaphore<br>
二元Semaphore解决了一个完全不同的问题：<br>
等待任务B等待某事发生（例如传感器触发）。<br>
传感器触发并运行中断服务程序。它需要通知行程任务。<br>
任务B应该运行并为传感器跳闸采取适当的措施。然后回到等待状态。<br>
Task A                                                          Task B<br>
...                                       Take BinSemaphore   &lt;== wait for something<br>
Do Something Noteworthy<br>
Give BinSemaphore                    do something    &lt;== unblocks<br>
请注意，对于二元信号量，B可以接收信号量，而A可以给出信号量。<br>
同样，二元信号量不能保护资源免受访问。发出信号量和采取信号量的行为从根本上是分离的。</p>
<p>附上一个例子 参考链接 <a href="https://www.zhihu.com/question/24116967">pthread_cond_wait 为什么需要传递 mutex 参数？</a></p>
<p>我在原来的答案中，有这样的代码：<br>
pthread_mutex_unlock(mtx);<br>
pthread_cond_just_wait(cv);<br>
pthread_mutex_lock(mtx);<br>
事实上，上面三行代码的并不是pthread_cond_wait(cv, mtx)的内联展开。其中第一行和第二行必须“原子化”，而第三行是可以分离出去的（之所以要把第三行放在里面的原因可以参见原来的答案）。</p>
<p>那么为什么第一行和第二行不能分离呢？这是因为必须得保证：如果线程A先进入wait函数（即使没有进入实际的等待状态，比如正在释放mtx），那么必须得保证其他线程在其之后调用的broadcast必须能够将线程A唤醒。</p>
<p>所以，把原来答案中的代码再贴一遍：<br>
// 线程A，条件测试<br>
pthread_mutex_lock(mtx);        // a1<br>
while(pass == 0) {              // a2<br>
pthread_mutex_unlock(mtx);  // a3<br>
pthread_cond_just_wait(cv); // a4<br>
pthread_mutex_lock(mtx);    // a5<br>
}<br>
pthread_mutex_unlock(mtx);</p>
<p>// 线程B，条件发生修改，对应的signal代码<br>
pthread_mutex_lock(mtx);   // b1<br>
pass = 1;                  // b2<br>
pthread_mutex_unlock(mtx); // b3<br>
pthread_cond_signal(cv);   // b4</p>
<p>如果执行序列是：a1, a2, a3, b1, b2, b3, b4, a4，那么线程A将不会被唤醒。而a3在线程B之前执行，这意味着wait函数是在signal之前调用的，所以不满足上文提到的保证。</p>
<p>解决办法：<br>
先将线程附加到等待队列<br>
释放mutex<br>
进入等待<br>
感兴趣的同学的可以看下源码（pthread_cond_wait.c），附加到等待队列这个操作是加锁的，所以可以保证之前发起的signal不会错误得唤醒本线程，而之后发起的signal必然唤醒本线程。</p>
<p>因此，下面的代码是绝对不会出错的：<br>
// 线程A，条件测试<br>
pthread_mutex_lock(mtx);        // a1<br>
while(pass == 0) {              // a2<br>
pthread_cond_wait(cv, mtx); // a3<br>
}<br>
pthread_mutex_unlock(mtx);      // a4</p>
<p>// 线程B，条件发生修改，对应的signal代码<br>
pthread_mutex_lock(mtx);   // b1<br>
pass = 1;                  // b2<br>
pthread_mutex_unlock(mtx); // b3<br>
pthread_cond_signal(cv);   // b4<br>
如果线程A先运行，那么执行序列必然是：a1, a2, a3, b1, b2, b3, b4, a4。<br>
如果线程B先运行，那么执行序列可能是：b1, b2, b3, b4, a1, a2, a4<br>
也可能是：b1, b2, b3, a1, a2, a3, b4, a4</p>
<p>所以，如果是我设计pthread API，那么我会添加一个pthread_cond_unlock_and_wait函数，伪代码如下：<br>
int pthread_cond_wait(cv, mtx) {<br>
int ret = pthread_cond_unlock_and_wait(cv, mtx);<br>
pthread_mutex_lock(mtx);<br>
return ret;<br>
}</p>
<p>// 线程A，条件测试<br>
pthread_mutex_lock(mtx);<br>
if (pass == 0)<br>
pthread_cond_unlock_and_wait(cv, mtx);<br>
else<br>
pthread_mutex_unlock(mtx);</p>
<p>// 线程B，条件发生修改，对应的signal代码<br>
pthread_mutex_lock(mtx);   // b1<br>
pass = 1;                  // b2<br>
pthread_mutex_unlock(mtx); // b3<br>
pthread_cond_signal(cv);   // b4</p>
<p>这样的好处在于：如果我们可以保证没有虚假唤醒（即不需要while循环测试条件），那么我们可以将线程A的代码改成上述形式，这样无论怎样都只需要执行一次pthread_mutex_unlock()函数，而之前的版本至少需要执行两次。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[栈 155. 最小栈[简单]]]></title>
        <id>https://lixin-ee.github.io//post/zhan-155-zui-xiao-zhan-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/zhan-155-zui-xiao-zhan-jian-dan">
        </link>
        <updated>2019-12-29T04:28:33.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。<br>
push(x) -- 将元素 x 推入栈中。<br>
pop() -- 删除栈顶的元素。<br>
top() -- 获取栈顶元素。<br>
getMin() -- 检索栈中的最小元素。<br>
示例:<br>
MinStack minStack = new MinStack();<br>
minStack.push(-2);<br>
minStack.push(0);<br>
minStack.push(-3);<br>
minStack.getMin();   --&gt; 返回 -3.<br>
minStack.pop();<br>
minStack.top();      --&gt; 返回 0.<br>
minStack.getMin();   --&gt; 返回 -2.<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/min-stack<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>怎么说好呢，其实stack是基于的deque的，唯一的问题就是删除元素和增加元素这些是真的增删还是伪增删，伪增删就等于用一个全局下标值来处理，增删操作知识对这个下标值进行处理，而不用每次都对元素进行处理<br>
但是这一题给得示例太少了，特别是没有错误用例<br>
卧槽，才发现是常数时间内检索到最小元素的栈<br>
那需要用到额外的空间来维护最小序列了 push和pop的时候都可能需要改动最小值<br>
这一题就用到了 二分查找 35. 搜索插入位置</p>
<pre><code>class MinStack {
public:
    /** initialize your data structure here. */
   // MinStack() {
        stack&lt;int&gt; sta;
        vector&lt;int&gt; minv;
        int min=INT_MAX; //忘了 设置成INT_MIN
   // }
    
    void push(int x) {
        sta.push(x);
        min=x&lt;min?x:min;
        minv.insert(minv.begin()+binarysearch(x),x);
        
    }
    
    void pop() {
        int x=sta.top();
        sta.pop();
        minv.erase(minv.begin()+binarysearch(x));
        if(minv.empty())
            min=INT_MAX;
        else
            min=minv[0];
    }
    
    int top() {
        return sta.top();
    }
    
    int getMin() {
        return min;
    }
    
    int binarysearch(int x){
        if(minv.empty()) return 0; //注意为空的情况
        if(x&gt;minv.back()) return minv.size();
        int first=0,last=minv.size()-1,mid;
        while(first&lt;last){
            mid=first+(last-first)/2;
            if(minv[mid]==x)
                return mid;
            if(minv[mid]&lt;x)
                first=mid+1;
            else
                last=mid;
            
        }
        return first;
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj-&gt;push(x);
 * obj-&gt;pop();
 * int param_3 = obj-&gt;top();
 * int param_4 = obj-&gt;getMin();
 */
</code></pre>
<p>网友题解</p>
<blockquote>
<p>这道题的思想很简单：“以空间换时间”，使用辅助栈是常见的做法。<br>
思路分析：<br>
在代码实现的时候有两种方式：<br>
1、辅助栈和数据栈同步<br>
特点：编码简单，不用考虑一些边界情况，就有一点不好：辅助栈可能会存一些“不必要”的元素。<br>
2、辅助栈和数据栈不同步<br>
特点：由“辅助栈和数据栈同步”的思想，我们知道，当数据栈进来的数越来越大的时候，我们要在辅助栈顶放置和当前辅助栈顶一样的元素，这样做有点“浪费”。基于这一点，我们做一些“优化”，但是在编码上就要注意一些边界条件。<br>
（1）辅助栈为空的时候，必须放入新进来的数；<br>
（2）新来的数小于或者等于辅助栈栈顶元素的时候，才放入，特别注意这里“等于”要考虑进去，因为出栈的时候，连续的、相等的并且是最小值的元素要同步出栈；<br>
（3）出栈的时候，辅助栈的栈顶元素等于数据栈的栈顶元素，才出栈。<br>
总结一下：出栈时，最小值出栈才同步；入栈时，最小值入栈才同步。<br>
对比：个人觉得“同步栈”的方式更好一些，因为思路清楚，因为所有操作都同步进行，所以调试代码、定位问题也简单。“不同步栈”，虽然减少了一些空间，但是在“出栈”、“入栈”的时候还要做判断，也有性能上的消耗。<br>
方法一：辅助栈和数据栈同步<br>
参考代码 1：</p>
</blockquote>
<pre><code>import java.util.Stack;

public class MinStack {

    // 数据栈
    private Stack&lt;Integer&gt; data;
    // 辅助栈
    private Stack&lt;Integer&gt; helper;

    /**
     * initialize your data structure here.
     */
    public MinStack() {
        data = new Stack&lt;&gt;();
        helper = new Stack&lt;&gt;();
    }

    // 思路 1：数据栈和辅助栈在任何时候都同步

    public void push(int x) {
        // 数据栈和辅助栈一定会增加元素
        data.add(x);
        if (helper.isEmpty() || helper.peek() &gt;= x) {
            helper.add(x);
        } else {
            helper.add(helper.peek());
        }
    }

    public void pop() {
        // 两个栈都得 pop
        if (!data.isEmpty()) {
            helper.pop();
            data.pop();
        }
    }

    public int top() {
        if(!data.isEmpty()){
            return data.peek();
        }
        throw new RuntimeException(&quot;栈中元素为空，此操作非法&quot;);
    }

    public int getMin() {
        if(!helper.isEmpty()){
            return helper.peek();
        }
        throw new RuntimeException(&quot;栈中元素为空，此操作非法&quot;);
    }
}
</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(1)，“出栈”、“入栈”、“查看栈顶元素”的操作不论数据规模多大，都只是有限个步骤，因此时间复杂度是：O(1)。<br>
空间复杂度：O(N)，这里 N 是读出的数据的个数。</p>
</blockquote>
<blockquote>
<p>方法二：辅助栈和数据栈不同步</p>
</blockquote>
<pre><code>import java.util.Stack;

public class MinStack {

    // 数据栈
    private Stack&lt;Integer&gt; data;
    // 辅助栈
    private Stack&lt;Integer&gt; helper;

    /**
     * initialize your data structure here.
     */
    public MinStack() {
        data = new Stack&lt;&gt;();
        helper = new Stack&lt;&gt;();
    }

    // 思路 2：辅助栈和数据栈不同步
    // 关键 1：辅助栈的元素空的时候，必须放入新进来的数
    // 关键 2：新来的数小于或者等于辅助栈栈顶元素的时候，才放入（特别注意这里等于要考虑进去）
    // 关键 3：出栈的时候，辅助栈的栈顶元素等于数据栈的栈顶元素，才出栈，即&quot;出栈保持同步&quot;就可以了

    public void push(int x) {
        // 辅助栈在必要的时候才增加
        data.add(x);
        // 关键 1 和 关键 2
        if (helper.isEmpty() || helper.peek() &gt;= x) {
            helper.add(x);
        }
    }

    public void pop() {
        // 关键 3：data 一定得 pop()
        if (!data.isEmpty()) {
            // 注意：声明成 int 类型，这里完成了自动拆箱，从 Integer 转成了 int，因此下面的比较可以使用 &quot;==&quot; 运算符
            // 参考资料：https://www.cnblogs.com/GuoYaxiang/p/6931264.html
            // 如果把 top 变量声明成 Integer 类型，下面的比较就得使用 equals 方法
            int top = data.pop();
            if(top == helper.peek()){
                helper.pop();
            }
        }
    }

    public int top() {
        if(!data.isEmpty()){
            return data.peek();
        }
        throw new RuntimeException(&quot;栈中元素为空，此操作非法&quot;);
    }

    public int getMin() {
        if(!helper.isEmpty()){
            return helper.peek();
        }
        throw new RuntimeException(&quot;栈中元素为空，此操作非法&quot;);
    }

}
</code></pre>
<blockquote>
<p>复杂度分析：<br>
时间复杂度：O(1)，“出栈”、“入栈”、“查看栈顶元素”的操作不论数据规模多大，都只有有限个步骤，因此时间复杂度是：O(1)。<br>
空间复杂度：O(N)，这里 NN 是读出的数据的个数。</p>
</blockquote>
<p>用一个栈实现：</p>
<blockquote>
<p>解法1：用两个栈实现最小栈功能<br>
一个栈s存放数据，另一个栈min存放前栈中最小的数据</p>
</blockquote>
<pre><code>class MinStack {
public:
    stack&lt;int&gt; s;//数据栈
    stack&lt;int&gt; min;//辅助栈
    /** initialize your data structure here. */
    MinStack() {
        
    }
    
    void push(int x) {
        s.push(x);
        if(min.empty()||x&lt;=min.top())
        {
            min.push(x);
        }
    }
    
    void pop() {
        if(s.top()==min.top())
            min.pop();
        s.pop();
    }
    
    int top() {
        return s.top();
    }
    int getMin() {
        return min.top();
    }
};
</code></pre>
<blockquote>
<p>解法2：一个栈实现<br>
栈中两个数据位合成一个单元，第一个数据位存放当前数据到末尾的最小值，第二个数据位存放当前数据。</p>
</blockquote>
<pre><code>class MinStack {
public:
    /** initialize your data structure here. */
    stack&lt;int&gt; s;
    MinStack() {
        
    }
    
    void push(int x) {
        if(s.empty())
        {
            s.push(x);
            s.push(x);
        }
        else
        {
            int temp=s.top();
            s.push(x);
            if(x&lt;temp)
            {
                s.push(x);
            }
            else
            {
                s.push(temp);
            }
        }
    }
    
    void pop() {
        s.pop();
        s.pop();
    }
    
    int top() {
        int temp=s.top();
        s.pop();
        int top=s.top();
        s.push(temp);
        return top;
    }
    
    int getMin() {
        return s.top();
    }
};
</code></pre>
<p>之前说过简单题不能只满足于解决问题，而是要多看思路，这道题便是这样，有很多很不错的网友思路，值得回头不断查看。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Linux基础] 系统登录与关机（鸟哥Linux第四章）]]></title>
        <id>https://lixin-ee.github.io//post/linux-ji-chu-xi-tong-deng-lu-yu-guan-ji-niao-ge-linux-di-si-zhang</id>
        <link href="https://lixin-ee.github.io//post/linux-ji-chu-xi-tong-deng-lu-yu-guan-ji-niao-ge-linux-di-si-zhang">
        </link>
        <updated>2019-12-28T13:51:28.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>X window<br>
文本模式为终端机接口, terminal 或 console<br>
Linux 预设的情况下会提供六个 Terminal 来让使用者登入， 切换的方式为使用：[Ctrl] + [Alt] + [F1]~[F6]的组合按钮。<br>
系统会将[F1] ~ [F6]命名为 tty1 ~ tty6 的操作接口环境。</li>
</ul>
<ul>
<li>[Ctrl] + [Alt] + [F2] ~ [F6] ：文字接口登入 tty2 ~ tty6 终端机；</li>
<li>[Ctrl] + [Alt] + [F1] ：图形接口桌面。</li>
</ul>
<p>文本模式登入后所取得的程序被称为壳(Shell)，这是因为这 支程序负责最外面跟使用者(我们)沟通，所以才被戏称为壳程序</p>
<p>个人体会：<br>
这一点对于我没装图形界面的centos来说非常重要，毕竟没有鼠标，纯靠键盘操作<br>
6个terminal或者说shell就相当于6个进程，如果一个阻塞了就需要切换到另外一个继续进行工作</p>
<ul>
<li>开始下达指令<br>
command [-options] parameter1 parameter2</li>
</ul>
<ol>
<li>一行指令中第一个输入的部分绝对是『指令(command)』或『可执行文件案(例如批次脚本,script)』</li>
<li>command 为指令的名称，例如变换工作目录的指令为 cd 等等；</li>
<li>中刮号[]并不存在于实际的指令中，而加入选项设定时，通常选项前会带号，例如 -h；有时候会使用选项的完整全名，则选项前带有 -- 符号，例如 --help；</li>
<li>parameter1 parameter2.. 为依附在选项后面的参数，或者是 command 的参数；</li>
<li>指令, 选项, 参数等中间以空格来区分，不论空几格 shell 都视为一格。所以空格是很重要的特殊字符；</li>
<li>按下[Enter]按键后，该指令就立即执行。[Enter]按键代表着一行指令的开始启动。</li>
<li>指令太长的时候，可以使用反斜杠 () 来跳脱[Enter]符号，使指令连续到下一行。注意！反斜杠后就立刻接特殊字符，才能跳脱！</li>
<li>其他：在 Linux 系统中，英文大小写字母是不一样的。举例来说， cd 与 CD 并不同。</li>
</ol>
<p>locale 显示目前支持的语系<br>
修改语系成为英文语系LANG=en_US.utf8   export LC_ALL=en_US.utf8</p>
<p>郁闷，貌似文本模式默认是英文语系</p>
<ul>
<li>基础指令的操作<br>
1.显示日期与时间的指令： date<br>
『+%Y%m%d』就是 date 指令的一些参数功能<br>
从上面的例子当中我们也可以知道，指令之后的选项除了前面带有减号『-』之外，某些特殊情况下，选项或参数前面也会带有正号『+』的情况</li>
</ul>
<p>2.显示日历的指令： cal [month] [year]</p>
<p>3.简单好用的计算器： bc<br>
bc命令进入到 bc 这个软件的工作环境当中，输入的数据当然就得要符合 bc 的要求才行</p>
<ul>
<li>加法 减法 * 乘法  / 除法  ^ 指数  % 余数<br>
因为 bc 预设仅输出整数，如果要输出小数点下位数，那么就 必须要执行 scale=number ，那个 number 就是小数点位数，<br>
输入『quit』来离开 bc 的软件环境</li>
</ul>
<p>小插曲：<br>
尴尬，我的centos居然没有默认安装bc，必须通过sudo  yum -y install bc来在线安装</p>
<ul>
<li>重要的几个热键</li>
</ul>
<p>[Tab] 具有『命令补全』与『文件补齐』的功 能<br>
1.[Tab] 接在一串指令的第一个字的后面，则为『命令补全』； 2. [Tab] 接在一串指令的第二个字以后时，则为『文件补齐』！<br>
3.若安装 bash-completion 软件，则在某些指令后面使用 [tab] 按键时，可以进行『选项/参数的补齐』功能！</p>
<p>[Ctrl]-c 中断目前程序 将正在运作中的指令中断</p>
<p>[Ctrl]-d<br>
1.键盘输入结束(End Of File, EOF 或 End Of Input)』2. 可以用来取代 exit 的输入，想要直接 离开文字接口，可以直接按下[Ctrl]-d 就能够直接离开了(相当于输入 exit 啊！)</p>
<p>[shift]+{[PageUP]|[Page Down]} 按键<br>
纯文本的画面中执行某些指令，当这个指令的输出讯息相当长导致前面的部份已经不 在目前的屏幕画面中，可以使用 [Shift]+[Page Up] 来往前翻页，也能够使用 [Shift]+[Page Down] 来往后翻页<br>
这条命令超重要！！！我一开始以为是直接{[PageUP]|[Page Down]} 就能翻页了，结果发现是历史命令的切换。。。</p>
<ul>
<li>
<p>错误讯息的察看<br>
下达了错误的指令，可以藉由屏幕上面显示的错误讯息来了解你的问题点，</p>
</li>
<li>
<p>指令的 –help<br>
开发者会将可以使用的指令语法与参数写入指令 操作过程中<br>
通常 --help 用在协助你查询『你曾经用过的指令所 具备的选项与参数』</p>
</li>
<li>
<p>man page<br>
如果你要使用的是从来没有用过得指令，或者是你要查询的根本就不是 指令，而是文件的『格式』时，那就得要透过 man page<br>
man 是 manual(操作说明)的简写</p>
</li>
<li>
<p>命令后面的数字(num)<br>
在表格的第一行，你可以看到的是：『DATE(1)』，DATE是指令的名称， (1) 代表查询数据的后面的数字是有意义</p>
</li>
</ul>
<p>这里也是很重要啊，虽然说区别不是很大，但是有时候还是需要对着表查找的<br>
<img src="https://lixin-ee.github.io//post-images/1577542417254.png" alt=""><br>
例如下达了『man null』时，会出现的第一行是：『NULL(4)』，对照一下上面的数字意义， 原来 null是一个『装置文件』</p>
<p>查询某个数据时是这样来查阅的：</p>
<ol>
<li>先察看 NAME 的项目，约略看一下这个资料的意思；</li>
<li>再详看一下 DESCRIPTION，这个部分会提到很多相关的资料与使用时机，从这个地方可以学到很多小细节 呢；</li>
<li>而如果这个指令其实很熟悉了(例如上面的 date)，那么鸟哥主要就是查询关于 OPTIONS 的部分了！ 可以知 道每个选项的意义，这样就可以下达比较细部的指令内容呢！</li>
<li>最后，鸟哥会再看一下，跟这个资料有关的还有哪些东西可以使用的？举例来说，上面的 SEE ALSO 就告 知我们还可以利用『info coreutils date』来进一步查阅数据；</li>
<li>某些说明内容还会列举有关的文件(FILES 部分)</li>
</ol>
<p>搜寻字符串：在man page，当你按下『/』之后，光标就会移动到屏幕的最下面一行， 并等待你输入搜寻的字符串</p>
<p>在 man page 的画面当中能使用的按键<br>
<img src="https://lixin-ee.github.io//post-images/1577542615324.png" alt=""></p>
<p>man -f command 搜索与command这个指令有关的说明文件（亦即不同的数字后缀）</p>
<p>man -k keywords<br>
在某些情况下忘记了 该指令的完整名称，或者只记得该指令的部分关键词，使用 –k选项，利用关键词将说明文件里面只要含有关键词的(不见得是完整字符串) 就 将他取出来</p>
<p>whatis [ 指令或者是 数 据 ] &lt;==相当于 man -f [指令或者是数据]<br>
apropos [ 指令或者是 数 据 ] &lt;==相当于 man -k [指令或者是数据]<br>
这两个特殊指令必须要有建立 whatis 数据库才行，需要使用root 的身份下达mandb指令</p>
<ul>
<li>info page<br>
info 与 man 的用途其实差不多，都是用来查询指令的用法或者是文件的格式。<br>
与 man page 一口气输出一堆信息不同的是，info page 则是将文件数据拆成一个一个的段落，每个段落用自己的页 面来撰写， 并且在各个页面中还有类似网页的『超链接』来跳到各不同的页面中，每个独立的页面 也被称为一个节点(node)。</li>
</ul>
<p>info page第一行里面的数据意义为：</p>
<ul>
<li>File：代表这个 info page 的资料是来自 info.info 文件所提供的；</li>
<li>Node：代表目前的这个页面是属于 Top 节点。 意思是 info.info 内含有很多信息，而 Top 仅是 info.info 文件 内的一个节点内容而已；</li>
<li>Next：下一个节点的名称为 Getting Started，你也可以按『N』到下个节点去；</li>
<li>Up：回到上一层的节点总揽画面，你也可以按下『U』回到上一层；</li>
<li>Prev：前一个节点。但由于 Top 是 info.info 的第一个节点，所以上面没有前一个节点的信息。</li>
</ul>
<p>info 的说明文件将内容分成多个 node，并且每个 node 都有定位与连结。 在各连结之 间还可以具有类似『超链接』的快速按钮，可以透过[tab]键在各个超链接间移动。</p>
<p>你可以透过直接按 下 N, P, U 来去到下一个、上一个与上一层的节点(node)<br>
『Menu』底下共分为四小节，分别是 Getting Started 等等的，我们 可以使用上下左右按键来将光标移动到该文字或者『 * 』上面，按下 Enter， 就可以前往该小节了！ 另外，也可以按下[Tab]按键，就可以快速的将光标在上表的画面中的 node 间移动，</p>
<ul>
<li>总结</li>
</ul>
<ul>
<li>在终端机模式中，如果你知道某个指令，但却忘记了相关选项与参数，请先善用 --help 的功能来查询相关 信息；</li>
<li>当有任何你不知道的指令或文件格式这种玩意儿，但是你想要了解他，请赶快使用 man 或者是 info 来查询！</li>
</ul>
<ul>
<li>超简单文书编辑器： nano<br>
nano text.txt开启一个名为 text.txt 的档名<br>
比较重要的几个组合按键：</li>
</ul>
<ul>
<li>[ctrl]-G：取得联机帮助(help)，很有用的！</li>
<li>[ctrl]-X：离开 naon 软件，若有修改过文件会提示是否需要储存喔！</li>
<li>[ctrl]-O：储存文件，若你有权限的话就能够储存文件了；</li>
<li>[ctrl]-R：从其他文件读入资料，可以将某个文件的内容贴在本文件中；</li>
<li>[ctrl]-W：搜寻字符串，这个也是很有帮助的指令喔！</li>
<li>[ctrl]-C：说明目前光标所在处的行数与列数等信息；</li>
<li>[ctrl]-_：可以直接输入行号，让光标快速移动到该行；</li>
<li>[alt]-Y：校正语法功能开启或关闭(单击开、再单击关)</li>
<li>[alt]-M：可以支持鼠标来移动光标的功能</li>
</ul>
<ul>
<li>正确的关机方法<br>
<strong>这个非常重要！！！就算是虚拟机也要好好关机！！！</strong><br>
若不正常关机，则可能造成文件系统的毁损<br>
-观察系统的使用状态： 如果要看目前有谁在在线，可以下达『who』这个指令，而如果要看网络的联机状态，可以下达 『 netstat -a 』 这个指令，而要看背景执行的程序可以执行『 ps -aux 』这个指令。使用这些指令可以让你稍微了解主机 目前的使用状态！当然啰，就可以让你判断是否可以关机了 （这些指令在后面 Linux 常用指令中会提及喔！）</li>
</ul>
<ul>
<li>通知在线使用者关机的时刻： 要关机前总得给在线的使用者一些时间来结束他们的工作，所以，这个时候你可以使用 shutdown 的特别指 令来达到此一功能。</li>
<li>正确的关机指令使用： 例如 shutdown 与 reboot 两个指令！</li>
</ul>
<p>几个与关机/重新启动相关的指令啰</p>
<ul>
<li>将数据同步写入硬盘中的指令： sync</li>
<li>惯用的关机指令： shutdown</li>
<li>重新启动，关机： reboot, halt, poweroff</li>
</ul>
<p>由于 Linux 系统的关机/重新启动是很重大的系统运作，因此只有 root 才能够进行例如 shutdown, reboot 等指令</p>
<p>数据同步写入磁盘： sync<br>
直接在文字接口下 输入 sync，那么在内存中尚未被更新的数据，就会被写入硬盘中<br>
shutdown/reboot/halt 等等指令均已经在关机前进行了 sync 这个工具的呼叫<br>
sync 也可以被一般账号使用,只不过一般账号用户所更新的硬盘数据就仅有 自己的数据，不像 root 可以更新整个系统中的数据了。</p>
<p>惯用的关机指令： shutdown<br>
就只有 root 有权力而已<br>
shutdown 可以达成如下的工作：</p>
<ul>
<li>可以自由选择关机模式：是要关机或重新启动均可；</li>
<li>可以设定关机时间: 可以设定成现在立刻关机, 也可以设定某一个特定的时间才关机。</li>
<li>可以自定义关机讯息：在关机之前，可以将自己设定的讯息传送给在线 user 。</li>
<li>可以仅发出警告讯息：有时有可能你要进行一些测试，而不想让其他的使用者干扰，或者是明白的告诉使 用者某段时间要注意一下！这个时候可以使用 shutdown 来吓一吓使用者，但却不是真的要关机啦！</li>
</ul>
<p>/sbin/shutdown [-- krhc] [ 时间 ] [ 警告讯息 ]<br>
选项与参数：<br>
-k ： 不要真的关机，只是发送警告讯息出去！<br>
-r ： 在将系统的服务停掉之后就重新启动(常用)<br>
-h ： 将系统的服务停掉后，立即关机。 (常用)<br>
-c ： 取消已经在进行的 shutdown 指令内容。<br>
时间 ： 指定系统关机的时间！时间的范例底下会说明。若没有这个项目，则默认 1 分钟后自动进行。<br>
范例： [root@study ~]# /sbin/shutdown -h 10 'I will shutdown after 10 mins’</p>
<p>可以输入『 shutdown -c 』来取消关机指令</p>
<p>新版的shutdown可省略时间参数 会以 1 分钟为限，进行自动关机的任务<br>
[root@study ~]# shutdown- h now<br>
立刻关机，其中 now 相当于时间为 0 的状态<br>
[root@study ~]# shutdown- h 20:25<br>
系统在今天的 20:25 分会关机，若在 21:25 才下达此指令，则隔天才关机<br>
[root@study ~]# shutdown- h +10<br>
系统再过十分钟后自动关机<br>
[root@study ~]# shutdown- r now<br>
系统立刻重新启动<br>
[root@study ~]# shutdown- r +30 'The system will reboot'<br>
再过三十分钟系统会重新启动，并显示后面的讯息给所有在在线的使用者<br>
[root@study ~]# shutdown- k now 'This system will reboot'<br>
仅发出警告信件的参数！系统并不会关机啦！吓唬人！</p>
<p>重新启动，关机： reboot, halt, poweroff<br>
有三个指令可以进行重新启动与关机的任务，那就是 reboot, halt, poweroff<br>
基本上，在预设的情况下， 这几个 指令都会完成一样的工作</p>
<p>实际使用管理工具 systemctl 关机<br>
systemctl：系统中所有服务的管理<br>
上面谈到的 halt, poweroff, reboot, shutdown 等等，其实都是呼叫这个 systemctl 指令<br>
这 个指令跟关机有关的语法如下：<br>
[root@study ~]# systemctl [ 指令]<br>
指令项目包括如下：<br>
halt 进入系统停止的模式，屏幕可能会保留一些讯息，这与你的电源管理模式有关<br>
poweroff 		进入系统关机模式，直接关机没有提供电力喔！<br>
reboot 			直接重新启动<br>
suspend 		进入休眠模式<br>
[root@study ~]# systemctl reboot # 系统重新启动<br>
[root@study ~]# systemctl poweroff # 系统关机</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 9. 回文数[简单][未做出]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-9-hui-wen-shu-jian-dan-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-9-hui-wen-shu-jian-dan-wei-zuo-chu">
        </link>
        <updated>2019-12-28T02:18:26.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。<br>
示例 1:<br>
输入: 121<br>
输出: true<br>
示例 2:<br>
输入: -121<br>
输出: false<br>
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。<br>
示例 3:<br>
输入: 10<br>
输出: false<br>
解释: 从右向左读, 为 01 。因此它不是一个回文数。<br>
进阶:<br>
你能不将整数转为字符串来解决这个问题吗？<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/palindrome-number<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>第一想法肯定是转化为string然后双指针了<br>
然后想一下怎么对int处理吧，比较难的就是怎么判断int的位数了<br>
考虑使用位运算符<br>
傻了想复杂了。。。其实完全就是可以把数字取余本身翻转再比较是否相等的嘛 但是这个方法有溢出的风险（但是其实int的特性决定了不会溢出，因为INT_MAX是2147483647，要对称只能个位是2，所以溢出的回文数根本不能存在int里面）<br>
然后官方题解更加6，直接判断一半就行了，值得学习<br>
自己实现官方题解的时候，发现问题是121这种奇数位的数怎么处理<br>
傻逼了写成temp+=10* remain;了<br>
在100这种数上面遇到难题了<br>
看了题解发现自己还是自作聪明了 根本不需要中间的判断 但是需要在前面加上判断</p>
<pre><code>class Solution {
public:
    bool isPalindrome(int x) {
       if(x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) {
            return false;
        }

        int temp=0;
        while(temp&lt;x){
            temp=temp*10+x%10;  
            x/=10;        
        }
        return temp==x||temp/10==x;
    }
    /*
    //转string解法
    bool isPalindrome(int x) {
        if(x&lt;0) return false;
        string s=to_string(x);
        auto beg=s.begin(),end=s.end()-1;
        while(beg&lt;end){
            if(*beg!=*end)
                return false;
            ++beg,--end;
        }
        return true;
    }
    */
};
</code></pre>
<p>我参照的官方题解</p>
<blockquote>
<p>方法：反转一半数字<br>
思路<br>
映入脑海的第一个想法是将数字转换为字符串，并检查字符串是否为回文。但是，这需要额外的非常量空间来创建问题描述中所不允许的字符串。<br>
第二个想法是将数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。<br>
但是，如果反转后的数字大于 int.MAX，我们将遇到整数溢出问题。<br>
按照第二个想法，为了避免数字反转可能导致的溢出问题，为什么不考虑只反转 int 数字的一半？毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。<br>
例如，输入 1221，我们可以将数字 “1221” 的后半部分从 “21” 反转为 “12”，并将其与前半部分 “12” 进行比较，因为二者相同，我们得知数字 1221 是回文。<br>
让我们看看如何将这个想法转化为一个算法。<br>
算法<br>
首先，我们应该处理一些临界情况。所有负数都不可能是回文，例如：-123 不是回文，因为 - 不等于 3。所以我们可以对所有负数返回 false。<br>
现在，让我们来考虑如何反转后半部分的数字。<br>
对于数字 1221，如果执行 1221 % 10，我们将得到最后一位数字 1，要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 1221 中移除，1221 / 10 = 122，再求出上一步结果除以 10 的余数，122 % 10 = 2，就可以得到倒数第二位数字。如果我们把最后一位数字乘以 10，再加上倒数第二位数字，1 * 10 + 2 = 12，就得到了我们想要的反转后的数字。如果继续这个过程，我们将得到更多位数的反转数字。<br>
现在的问题是，我们如何知道反转数字的位数已经达到原始数字位数的一半？<br>
我们将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于反转后的数字时，就意味着我们已经处理了一半位数的数字。</p>
</blockquote>
<pre><code>C#
public class Solution {
    public bool IsPalindrome(int x) {
        // 特殊情况：
        // 如上所述，当 x &lt; 0 时，x 不是回文数。
        // 同样地，如果数字的最后一位是 0，为了使该数字为回文，
        // 则其第一位数字也应该是 0
        // 只有 0 满足这一属性
        if(x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) {
            return false;
        }

        int revertedNumber = 0;
        while(x &gt; revertedNumber) {
            revertedNumber = revertedNumber * 10 + x % 10;
            x /= 10;
        }

        // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。
        // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，
        // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。
        return x == revertedNumber || x == revertedNumber/10;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(log_{10}(n))，对于每次迭代，我们会将输入除以10，因此时间复杂度为 O(log_{10}(n))。<br>
空间复杂度：O(1)。</p>
</blockquote>
<p>需要注意的就是对10的整数倍数字这个特例进行处理了</p>
<pre><code>if(x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) {
            return false;
        }
</code></pre>
]]></content>
    </entry>
</feed>