<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-03-01T00:54:41.447Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>In the darkest night,Rising like a spire.</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[ 交换排序&冒泡排序]]></title>
        <id>https://lixin-scut.github.io//post/jiao-huan-pai-xu-andmou-pao-pai-xu</id>
        <link href="https://lixin-scut.github.io//post/jiao-huan-pai-xu-andmou-pao-pai-xu">
        </link>
        <updated>2020-03-01T00:53:06.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://lixin-scut.github.io/post/pai-xu-suan-fa/">排序算法及其实现</a></p>
<p>  冒泡排序(BubbleSort)—种交换排序，它的基本思想是:两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止</p>
<pre><code>// SortFunc.h
class BubbleSort{
public:
    // 改进版冒泡排序
    void BubbleSort2(vector&lt;int&gt; &amp;numbers);

    // 最简单（正宗）的冒泡排序
    void BubbleSort1(vector&lt;int&gt; &amp;numbers);

    // 本质是交换排序
    void BubbleSort0(vector&lt;int&gt; &amp;numbers)
};
</code></pre>
<pre><code>// BubbleSort.cpp
// 交换排序
void BubbleSort::BubbleSort0(vector&lt;int&gt; &amp;numbers)
{
    int len = numbers.size();
    for (int i = 0; i &lt; len; ++i)
    {
        for(int j = i+1 ; j &lt; len; ++j)
        {
            if(numbers[i] &gt; numbers[j])
            {
                int temp = numbers[i];
                numbers[i] = numbers[j];
                numbers[j] = temp;
            }
        }
    }
    print(numbers);
}
</code></pre>
<p>  这段代码严格意义上说，不算是标准的冒泡排序算法，因为它不满足两两比较相邻记录的冒泡排序思想，它更应该是最最简单的交换排序而已。它的思路就是让每一个关 键字，都和它后面的每一个关键字比较，如果大则交换，这样第一位置的关键字在一次循环后一定变成最小值。<br>
  这个简单易懂的代码，却是有缺陷的。排序好位置的数字对其余关键字的排序没有什么帮助，甚至有可能将原本靠前的数字搬移到数组后面。</p>
<pre><code>// BubbleSort.cpp
// 最简单（正宗）的冒泡排序
void BubbleSort::BubbleSort1(vector&lt;int&gt; &amp;numbers)
{
    for(int i=0; i&lt;numbers.size(); ++i)
    {
        for(int j=numbers.size()-1; j&gt;i; --j)
        {
            if(numbers[j] &lt; numbers[j-1])
            { swap(numbers[j],numbers[j-1]); }
        }
    }
    print(numbers);
}
</code></pre>
<p>  对比交换排序，冒泡排序的排序好位置的数字对其余关键字的排序也有帮助，其他数字的位置也会相应上升。</p>
<pre><code>// 改进版冒泡排序
void BubbleSort::BubbleSort2(vector&lt;int&gt; &amp;numbers)
{
    bool flag = true;
    for(int i=0; i&lt;numbers.size(); ++i)
    {
        for(int j=numbers.size()-1; j&gt;i; --j)
        {
            if(numbers[j] &lt; numbers[j-1])
            {
                swap(numbers[j],numbers[j-1]);
                flag = false;
            }
        }
        if(flag)
        { break; }
    }
    print(numbers);
}
</code></pre>
<p>  代码改动的关键就是在i变量的for循环中，增加了对flag是否为true的判断。经过这样的改进，冒泡排序在性能上就有了一些提升，可以避免因已经有序的情况下的无意义循环判断。</p>
<p>复杂度分析<br>
<img src="https://lixin-scut.github.io//post-images/1582858448862.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 题37:序列化二叉树]]></title>
        <id>https://lixin-scut.github.io//post/shu-ti-37xu-lie-hua-er-cha-shu</id>
        <link href="https://lixin-scut.github.io//post/shu-ti-37xu-lie-hua-er-cha-shu">
        </link>
        <updated>2020-03-01T00:30:09.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>  请实现两个函数，分别用来序列化和反序列化二叉树<br>
  二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。<br>
  二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p>
</blockquote>
<p>这道题是leetcode有原题的 <a href="https://lixin-scut.github.io/post/shu-297-er-cha-shu-de-xu-lie-hua-yu-fan-xu-lie-hua-kun-nan/">树 297. 二叉树的序列化与反序列化[困难]</a>，所以来看一下书本的题解吧</p>
<p>书本题解：</p>
<blockquote>
<p> 我们知道可以从前序遍历序列 和中序遍历序列中构造出一棵二叉树。受此启发，我们可以先把一棵二叉树序列化成一个前序遍历序列和一个中序遍历序列，然后在反序列化时通过这两个序列重构出原二叉树。<br>
 这种思路有两个缺点：一是该方法要求二叉树中不能有数值重复的节点；二是只有当两个序列中所有数据都读出后才能开始反序列化。如果两 个遍历序列的数据是从一个流里读出来的，那么可能需要等待较长的时间。<br>
 实际上，如果二叉树的序列化是从根节点开始的，那么相应的反序列化在根节点的数值读出来的时候就可以开始了。因此，我们可以根据前序遍历的顺序来序列化二叉树，因为前序遍历是从根节点开始的。在遍历二叉树碰到nullptr指针时，这些nullptr指针序列化为一个特殊的字符（如'<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;&amp;&#039; at position 33: …个特殊字符(如&#039;,&#039;)隔开。
&amp;̲emsp;反序列化时，当下一个…'>&#039;）。 另外，节点的数值之间要用一个特殊字符(如&#039;,&#039;)隔开。
&amp;emsp;反序列化时，当下一个字符是</span>,这表明节点的右子节点为nullptr指针。这个节点的左、右子树都已经构建完毕，接下来回到根节点，反序列化根节点的右子树。</p>
</blockquote>
<pre><code>void Serialize(const BinaryTreeNode* pRoot, ostream&amp; stream)
{
    if(pRoot == nullptr)
    {
        stream &lt;&lt; &quot;$,&quot;;
        return;
    }

    stream &lt;&lt; pRoot-&gt;m_nValue &lt;&lt; ',';
    Serialize(pRoot-&gt;m_pLeft, stream);
    Serialize(pRoot-&gt;m_pRight, stream);
}

bool ReadStream(istream&amp; stream, int* number)
{
    if(stream.eof())
        return false;

    char buffer[32];
    buffer[0] = '\0';

    char ch;
    stream &gt;&gt; ch;
    int i = 0;
    while(!stream.eof() &amp;&amp; ch != ',')
    {
        buffer[i++] = ch;
        stream &gt;&gt; ch;
    }

    bool isNumeric = false;
    if(i &gt; 0 &amp;&amp; buffer[0] != '$')
    {
        *number = atoi(buffer);
        isNumeric = true;
    }

    return isNumeric;
}

void Deserialize(BinaryTreeNode** pRoot, istream&amp; stream)
{
    int number;
    if(ReadStream(stream, &amp;number))
    {
        *pRoot = new BinaryTreeNode();
        (*pRoot)-&gt;m_nValue = number;
        (*pRoot)-&gt;m_pLeft = nullptr;
        (*pRoot)-&gt;m_pRight = nullptr;

        Deserialize(&amp;((*pRoot)-&gt;m_pLeft), stream);
        Deserialize(&amp;((*pRoot)-&gt;m_pRight), stream);
    }
}
</code></pre>
<blockquote>
<p> 函数ReadStream每次从流中读出一个数字或者一个字符当从流中读出的是一个数字时，函数返回true：否则返回false。<br>
  如果总结前面序列化和反序列化的过程，就会发现我们都是把二义树分解成3部分：根节点、左子树和右子树。我们在处理(序列化或反序列化)它的根节点之后再分别处理它的左、右子树。这是典型的把问题递归分解然后逐个解决的过程。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 题36:二叉搜索树与双向链表[未做出]]]></title>
        <id>https://lixin-scut.github.io//post/shu-ti-36er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/shu-ti-36er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-wei-zuo-chu">
        </link>
        <updated>2020-02-29T23:57:21.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
</blockquote>
<pre><code>/*
struct TreeNode {
 int val;
 struct TreeNode *left;
 struct TreeNode *right;
 TreeNode(int x) :
   val(x), left(NULL), right(NULL) {
 }
};*/
</code></pre>
<p>第一想法是使用迭代的中序遍历法，但是这样需要额外的栈<br>
知道是中序遍历，但是没想好类似于叶子结点这些特殊结点应该怎么连接。</p>
<pre><code>class Solution {
public:
    //【未做出】
    TreeNode* Convert(TreeNode* pRootOfTree)
    {
        TreeNode *pLastNodeInList=NULL;
        ConvertNode(pRootOfTree,&amp;pLastNodeInList);
        
        TreeNode *pHeadOfList=pLastNodeInList;
        while(pHeadOfList!=NULL&amp;&amp;pHeadOfList-&gt;left!=NULL)
            pHeadOfList=pHeadOfList-&gt;left;
        
        return pHeadOfList;
    }
    
    void ConvertNode(TreeNode *pNode,TreeNode **pLastNodeInList){
        if(pNode==NULL)
            return;
        TreeNode *pCurrent=pNode;
        
        if(pCurrent-&gt;left!=NULL)
            ConvertNode(pCurrent-&gt;left,pLastNodeInList);
  
        pCurrent-&gt;left=*pLastNodeInList;
        if(*pLastNodeInList!=NULL)
          (*pLastNodeInList)-&gt;right=pCurrent;
        
        *pLastNodeInList=pCurrent;
        
        if(pCurrent-&gt;right!=NULL)
            ConvertNode(pCurrent-&gt;right,pLastNodeInList);
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>  在二叉树中，每个节点都有两个指向子节点的指针。在双向链表中，每个节点也有两个指针，分别指向前一个节点和后一个节点。由于这两种节点的结构相似，同时二义搜索树也是一种排序的数据结构，因此，在理论上有可能实现二义搜索树和排序双向链表的转换。在搜索二叉树中，左 子节点的值总是小于父节点的值，右子节点的值总是大于父节点的值。因此，我们在将二叉搜索树转换成排序双向链表时，原先指向左子节点的指针调整为链表中指向前一个节点的指针，原先指向右子节点的指针调整为链表中指向后一个节点的指针。接下来我们考虑该如何转换。<br>
  由于要求转换之后的链表是排好序的，我们可以中序遍历树中的每个节点，这是因为中序遍历算法的特点是按照从小到大的顺序遍历二叉树的每个节点。当遍历到根节点的时候，我们把树看成3部分：值为10的节点: 根节点值为6的左子树；根节点值为14的右子树。根据排序链表的定义, 值为10的节点将和它的左子树的最大一个节点（值为8的节点）链接起 来，同时它还将和右子树最小的节点（值为12的节点）链接起来。<br>
  在把左、右子树都转换成排序双向链表之后再和根节点链接起来，整棵二叉搜索树也就转换成了排序双向链表<br>
  按照中序遍历的顺序，当我们遍历转换到根节点(值为10的节点)时， 它的左子树已经转换成一个排序的链表了，并且处在链表中的最后一个节 点是当前值最大的节点。我们把值为8的节点和根节点链接起来，此时链 表中的最后一个节点就是10 了。接着我们去遍历转换右子树，并把根节点 和右子树中最小的节点链接起来。至于怎么去转换它的左子树和右子树， 由于遍历和转换过程是一样的，我们很自然地想到可以用递归。</p>
</blockquote>
<pre><code>BinaryTreeNode* Convert(BinaryTreeNode* pRootOfTree)
{
    BinaryTreeNode *pLastNodeInList = nullptr;
    ConvertNode(pRootOfTree, &amp;pLastNodeInList);

    // pLastNodeInList指向双向链表的尾结点，
    // 我们需要返回头结点
    BinaryTreeNode *pHeadOfList = pLastNodeInList;
    while(pHeadOfList != nullptr &amp;&amp; pHeadOfList-&gt;m_pLeft != nullptr)
        pHeadOfList = pHeadOfList-&gt;m_pLeft;

    return pHeadOfList;
}

void ConvertNode(BinaryTreeNode* pNode, BinaryTreeNode** pLastNodeInList)
{
    if(pNode == nullptr)
        return;

    BinaryTreeNode *pCurrent = pNode;

    if (pCurrent-&gt;m_pLeft != nullptr)
        ConvertNode(pCurrent-&gt;m_pLeft, pLastNodeInList);

    pCurrent-&gt;m_pLeft = *pLastNodeInList; 
    if(*pLastNodeInList != nullptr)
        (*pLastNodeInList)-&gt;m_pRight = pCurrent;

    *pLastNodeInList = pCurrent;

    if (pCurrent-&gt;m_pRight != nullptr)
        ConvertNode(pCurrent-&gt;m_pRight, pLastNodeInList);
}
</code></pre>
<blockquote>
<p>  代码中，我们用pLastNodelnList指向已经转换好的链表的最后一个节点（值最大的节点）。当我们遍历到值为10的节点的时候，它的左子树都已经转换好了，因此pLastNodelnList指向值为8的节点。接着把根节点链接到链表中之后，值为10的节点成了链表中的最后一个节点（新的值最大的节点），于是pLastNodelnList指向了这个值为10的节点。接下来把pLastNodelnList作为参数传入函数递归遍历右子树。我们找到右子树 中最左边的子节点（值为12的节点，在右子树中值最小），并把该节点和值为10的节点链接起来。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Connector]]></title>
        <id>https://lixin-scut.github.io//post/connector</id>
        <link href="https://lixin-scut.github.io//post/connector">
        </link>
        <updated>2020-02-29T12:39:19.000Z</updated>
        <content type="html"><![CDATA[<p>  主动发起连接比被动接受连接要复杂一些，一方面是错误处理麻烦，另一方面是要考虑重试。在非阻塞网络编程中，发起连接的基本方式是调用connect(2),当 socket变得可写时表明连接建立完毕。当然这其中要处理各种类型的错误，因此我们把它封装为Connector类。<br>
  Connector只负责建立socket连接，不负责创建TcpConnection,它的NewConnectionCallback 回调的参数是socket文件描述符。</p>
<p>Connector的实现有几个难点：<br>
  • socket是一次性的，一旦出错(比如对方拒绝连接)，就无法恢复，只能关闭重来。但Connector是可以反复使用的，因此每次尝试连接都要使用新的socket文件描述符和新的Channel对象。要留意Channel对象的生命期管理，并防止socket文件描述符泄漏。<br>
  •错误代码与accept(2)不同，EAGAIN是真的错误，表明本机ephemeral port 暂时用完，要关闭socket再延期重试。“正在连接”的返回码是EINPROGRESSo 另外，即便出现socket可写，也不一定意味着连接已成功建立，还需要用 getsockopt(sockfd, SOL_SOCKET, SO_ERROR, ...)再次确认一下。<br>
  •重试的间隔应该逐渐延长，例如0.5s、Is、2s、4s,直至30s,即back-off。这会造成对象生命期管理方面的困难，如果使用EventLoop:: runAfter()定时而 Connector在定时器到期之前可能会析构<br>
  •要处理自连接(self-connection )o出现这种状况的原因如下。在发起连接的时候，TCP/IP协议栈会先选择source IP和source port，在没有显式调用bind(2)的情况下，source IP由路由表确定，source port由TCP/IP协议栈从local port range 中选取尚未使用的port (即临时端口ephemeral port)。如果destination IP正好是本机，而destination port位于local port range,且没有服务程序监听的话,  临时端口可能正好选中了 destination port,这就出现(source IP, source port) = (destination IP, destination port)的情况，即发生了自连接。处理办法是断开连接再重试，否则原本侦听destinaHon port的服务进程也无法启动了。</p>
<p>TimerQueue::cancel()<br>
  为了防止Connector在定时器到期之前析构，TimerQueue使用cancel()注销定时器<br>
  一种实现是用shared_ptr来管理Timer对象，再将TimerId定义为<code>weak_ptr&lt;Timer&gt;</code>,但用shared_ptr来管理Timer对象似乎显得有点小题大做，而且这种做法也有一个小小的缺点，如果用户一直持有Timerld,会造成引用计数所占的内存无法释放。<br>
  最后采用更传统的方式，保持现有的设计，让Timerld包含Timer*。但这是不够的，因为无法区分地址相同的先后两个Timer对象。因此每个Timer对象有一个全局递增的序列号int64_t sequence.(用原子计数器(Atomiclnt64 )生成)，TimerId 同时保存 Timer* 和 sequence,这样 TimerQueue::cancel()就能根据 TimerId找到需要注销的Timer对象。</p>
<p>  cancel()有对应的 cancelInLoop()函数，因此 TimerQueue 不必用锁。TimerQueue新增了几个数据成员，activeTimers_存的是目前有效的Timer的指针，并 满足 invariant： timers., size。== activeTimers_.size(),因为这两个容器保存的是相同的数据，只不过timers_是按到期时间排序，activeTimers_是按对象地址排序。<br>
  由于TimerId不负责Timer的生命期，其中保存的Timer* 可能失效，因此不能直接dereference,只有在activeTimers_中找到了Timer时才能提领。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关键字extern]]></title>
        <id>https://lixin-scut.github.io//post/guan-jian-zi-extern</id>
        <link href="https://lixin-scut.github.io//post/guan-jian-zi-extern">
        </link>
        <updated>2020-02-29T00:34:08.000Z</updated>
        <content type="html"><![CDATA[<p>  分离式编译 将程序分割为若干个文件，每个文件可以被独立编译。.<br>
  声明 仅规定变量的类型和名字<br>
  定义 创建与名字关联的实体，申请存储空间 并赋初始值声明关键字 extern<br>
  如果含有初始化的话就等于定义，抵消了extern的作用，同时试图初始化由extern标记的已定义变量会引发错误<br>
  定义能且只能被定义一次，但可以被多次声明</p>
<pre><code>int j; // 声明并定义  
extern int j; // 声明  
extern int j=1; // 定义
</code></pre>
<p>  const 常量关键字，const对象一旦创建后就不能改变值，所以const对象必须初始化<br>
  默认状态下 const对象仅在文件内有效，添加extern关键字就可以分享使用，但共享const定义之前必须添加extern关键词，因为const必须在声明的同时被定义</p>
<pre><code>// file1.cc
extern const int Size = fcn();

// file2.cc
extern const int Size;
</code></pre>
<p>  当编译器遇到 extern 模板声明时，它不会在本文件中生成实例化代码。将一个实例化声明为 extern 就表示承诺在程序其他位置有该实例化的一个非 extern 声明（定义）。对于一个给定的实例化版本，可能有多个 extern 声明，但必须只有一个定义。<br>
  由编译器在使用一个模板时自动对其实例化，因此 extern 声明必须出现在任何使用此实例化版本的代码之前：</p>
<p>链接指示：extern&quot;C&quot;<br>
  C++使用链接指示（linkage directive)指出任意非C++函数所用的语言。<br>
  要想把C++代码和其他语言（包括C语言）编写的代码放在一起使用，要求我们必须有权访问该语言的编译器，并且这个编译器与当前的C++编译器是兼容的</p>
<p>声明一个非C++的函数<br>
  链接指示可以有两种形式：单个的或复合的。链接指示不能出现在类定义或函数定义的内部。同样的链接指示必须在函数的每个声明中都出现。<br>
  链接指示的第一种形式包含一个关键字extern.后面是一个字符串字面值常量以及一个 &quot;普通的&quot;函数声明。<br>
  其中的字符串字面值常量指出了编写函数所用的语言。编译器应该支持对C语言的链 接指示。此外，编译器也可能会支持其他语言的链接指示，如extern&quot;Ada&quot;、extern &quot;FORTRAN&quot;等。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 题35:复杂链表的复制]]></title>
        <id>https://lixin-scut.github.io//post/lian-biao-ti-35fu-za-lian-biao-de-fu-zhi</id>
        <link href="https://lixin-scut.github.io//post/lian-biao-ti-35fu-za-lian-biao-de-fu-zhi">
        </link>
        <updated>2020-02-28T23:56:18.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
</blockquote>
<pre><code>/*
struct RandomListNode {
    int label;
    struct RandomListNode *next, *random;
    RandomListNode(int x) :
            label(x), next(NULL), random(NULL) {
    }
};
</code></pre>
<p>  一开始我想着每次遇到未存在节点就都创建新节点（包括next和random）并存进hashmap里面去<br>
  但是后面发现这样很麻烦，每次都要对next和random判断是否存在，并且如果next已存在的话进一步又要特殊处理<br>
  所以不如先循环一次构造next，把所有节点构造出来，然后再循环利用hashmap链接random</p>
<pre><code>*/
class Solution {
public:
    //不需要额外空间的办法[未做出]
    RandomListNode* Clone(RandomListNode* pHead){
        if(pHead==NULL)
            return NULL;
        
        RandomListNode *cur=pHead;
        RandomListNode *temp;
        while(cur){
            temp=new RandomListNode(cur-&gt;label);
            temp-&gt;next=cur-&gt;next;
            cur-&gt;next=temp;
            cur=temp-&gt;next;
        }
        
        cur=pHead;
        while(cur){
            cur-&gt;next-&gt;random=cur-&gt;random-&gt;next;
            cur=cur-&gt;next-&gt;next;
        }
        
        cur=pHead;
        RandomListNode *CloneHead;
        RandomListNode *CloneNode;
        
        CloneHead=pHead-&gt;next;
        CloneNode=pHead-&gt;next;
        cur-&gt;next=CloneNode-&gt;next;
        cur=cur-&gt;next;
        
        while(cur){
            CloneNode-&gt;next=cur-&gt;next;
            CloneNode=CloneNode-&gt;next;
            cur-&gt;next=CloneNode-&gt;next;
            cur=cur-&gt;next;
        }
        return CloneHead;
    }
    /*
    // hashmap映射方法
    RandomListNode* Clone(RandomListNode* pHead)
    {
        
        if(pHead==NULL)
            return NULL;
        unordered_map&lt;RandomListNode*,RandomListNode*&gt; node_map;
        RandomListNode *pre=pHead-&gt;next;
        RandomListNode *cur=new RandomListNode(pHead-&gt;label);
        node_map.insert(make_pair(pHead,cur));
        RandomListNode *newnode;
        while(pre!=NULL){
            newnode = new RandomListNode(pre-&gt;label);
            cur-&gt;next=newnode;
            cur=cur-&gt;next;
            node_map.insert(make_pair(pre,cur));
            pre=pre-&gt;next;
        }
        pre=pHead;
        cur=node_map[pre];
        while(pre!=NULL){
            cur-&gt;random=node_map[pre-&gt;random];
            cur=cur-&gt;next;
            pre=pre-&gt;next;
        }
        return node_map[pHead];
    }
    */
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>  在复杂链表的节点中，除了有指向下一个节点的指针(实线箭头), 还有指向任意节点的指针<br>
  分为两步：第一步仍然是复制原始链表 上的每个节点N创建N'然后把这些创建出来的节点用m_pNext链接起来。 同时我们把＜N,N'＞的配对信息放到一个哈希表中；第二步还是设置复制链 表上每个节点的m_pSibling。如果在原始链表中节点N的m_pSibling指向节点S,那么在复制链表中，对应的N'，应该指向S'由于有了哈希表，我 们可以用O⑴的时间根据S找到S'。<br>
  相当于用空间换时间。对于有n个节点的链表，我们需要 一个大小为O(n)的哈希表，也就是说我们以O(n)的空间消耗把时间复杂度 由O(n^2)降低到O(n)<br>
  接下来我们再换一种思路，在不用辅助空间的情况下实现O(n)的时间效率。<br>
第三种方法的第一步仍然是根据原始链表的每个节点N创建对应的N'这一次，我们把N'链接在N的后面。<br>
  第二步设置复制出来的节点的m_pSibling。假设原始链表上的N的m_pSibling指向节点S,那么其对应复制出来的N，是N的m_pNext指向的节点，同样S'也是S的m_pNext指向的节点。<br>
  第三步把这个长链表拆分成两个链表：把奇数位置的节点用m_pNext 链接起来就是原始链表，把偶数位置的节点用m_pNext链接起来就是复制 出来的链表。</p>
</blockquote>
<pre><code>ComplexListNode* Clone(ComplexListNode* pHead)
{
    CloneNodes(pHead);
    ConnectSiblingNodes(pHead);
    return ReconnectNodes(pHead);
}

void CloneNodes(ComplexListNode* pHead)
{
    ComplexListNode* pNode = pHead;
    while(pNode != nullptr)
    {
        ComplexListNode* pCloned = new ComplexListNode();
        pCloned-&gt;m_nValue = pNode-&gt;m_nValue;
        pCloned-&gt;m_pNext = pNode-&gt;m_pNext;
        pCloned-&gt;m_pSibling = nullptr;
 
        pNode-&gt;m_pNext = pCloned;
 
        pNode = pCloned-&gt;m_pNext;
    }
}

void ConnectSiblingNodes(ComplexListNode* pHead)
{
    ComplexListNode* pNode = pHead;
    while(pNode != nullptr)
    {
        ComplexListNode* pCloned = pNode-&gt;m_pNext;
        if(pNode-&gt;m_pSibling != nullptr)
        {
            pCloned-&gt;m_pSibling = pNode-&gt;m_pSibling-&gt;m_pNext;
        }
 
        pNode = pCloned-&gt;m_pNext;
    }
}

ComplexListNode* ReconnectNodes(ComplexListNode* pHead)
{
    ComplexListNode* pNode = pHead;
    ComplexListNode* pClonedHead = nullptr;
    ComplexListNode* pClonedNode = nullptr;
 
    if(pNode != nullptr)
    {
        pClonedHead = pClonedNode = pNode-&gt;m_pNext;
        pNode-&gt;m_pNext = pClonedNode-&gt;m_pNext;
        pNode = pNode-&gt;m_pNext;
    }
 
    while(pNode != nullptr)
    {
        pClonedNode-&gt;m_pNext = pNode-&gt;m_pNext;
        pClonedNode = pClonedNode-&gt;m_pNext;
 
        pNode-&gt;m_pNext = pClonedNode-&gt;m_pNext;
        pNode = pNode-&gt;m_pNext;
    }
 
    return pClonedHead;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 题34:二叉树中和为某一值的路径]]></title>
        <id>https://lixin-scut.github.io//post/shu-ti-34er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing</id>
        <link href="https://lixin-scut.github.io//post/shu-ti-34er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing">
        </link>
        <updated>2020-02-28T23:45:01.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p>
</blockquote>
<pre><code>/*
struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :
			val(x), left(NULL), right(NULL) {
	}
};*/
</code></pre>
<p>首先这道题的隐藏重点是一定是要叶子结点，不能中途满足条件了就输出<br>
本来打算用传值引用的temp来保存中间的<code>vector&lt;int&gt;</code>，但是这样递归起来很耗费内存<br>
所以改用回溯法，可以利用vector的pop_back()来很方便地回溯<br>
注意记得叶节点符合条件也得pop_back来回溯<br>
然后注意题目中索然说明数组长度大的数组靠前，但是实际上测试用例并没有遵循这个规定。。。</p>
<pre><code>class Solution {
public:
    vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root,int expectNumber) {
        vector&lt;vector&lt;int&gt;&gt; res;
        if(root==NULL)
            return res;
        vector&lt;int&gt; temp;
        FindPath(root,expectNumber,temp,res);
        return res;
    }
    
    void FindPath(TreeNode* cur,
                  int expectNumber,
                  vector&lt;int&gt; &amp;temp,
                  vector&lt;vector&lt;int&gt;&gt; &amp;res
                 )
    {
        expectNumber-=cur-&gt;val;
        temp.push_back(cur-&gt;val);
        if(cur-&gt;left==NULL&amp;&amp;cur-&gt;right==NULL){
            if(expectNumber==0)
                res.push_back(temp);
            temp.pop_back();
            return;
        }
        if(cur-&gt;left)
            FindPath(cur-&gt;left,expectNumber,temp,res);
        if(cur-&gt;right)
            FindPath(cur-&gt;right,expectNumber,temp,res);
        temp.pop_back();
        return;
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>规律：当用前序遍历的方式访问到某一节点时，我们把该节点添加到路径上，并累加该节点的值。<br>
如果该节点为叶节点，并且路径中节点值的和刚好等于输入的整数， 则当前路径符合要求，我们把它打印出来。<br>
如果当前节点不是叶节点，则继续访问它的子节点。<br>
当前节点访问结束后，递归函数将自动回到它的父节点。因此，我们在函数退出之前要在路径上删除当前节点并减去当前节 点的值，以确保返回父节点时路径刚好是从根节点到父节点。<br>
我们不难看出保存路径的数据结构实际上是一个栈，因为路径要与递归调用状态一 致，而递归调用的本质就是一个压栈和出栈的过程。<br>
我们用标准模板库中的vector实现了一个栈来保存路径，每次都用push back在路径的末尾添加节点，用pop back在路径的末尾删除节点，这样就保证了栈的先入后出特性。这里没有直接用STL中 的stack的原因是，在stack中只能得到栈顶元素，而我们打印路径的时候需要得到路径上的所有节点，因此在代码实现的时候std::stack不是最好的选择。</p>
</blockquote>
<pre><code>void FindPath(BinaryTreeNode* pRoot, int expectedSum)
{
    if(pRoot == nullptr)
        return;

    std::vector&lt;int&gt; path;
    int currentSum = 0;
    FindPath(pRoot, expectedSum, path, currentSum);
}

void FindPath
(
    BinaryTreeNode*   pRoot,        
    int               expectedSum,  
    std::vector&lt;int&gt;&amp; path,         
    int&amp;              currentSum
)
{
    currentSum += pRoot-&gt;m_nValue;
    path.push_back(pRoot-&gt;m_nValue);

    // 如果是叶结点，并且路径上结点的和等于输入的值
    // 打印出这条路径
    bool isLeaf = pRoot-&gt;m_pLeft == nullptr &amp;&amp; pRoot-&gt;m_pRight == nullptr;
    if(currentSum == expectedSum &amp;&amp; isLeaf)
    {
        printf(&quot;A path is found: &quot;);
        std::vector&lt;int&gt;::iterator iter = path.begin();
        for(; iter != path.end(); ++ iter)
            printf(&quot;%d\t&quot;, *iter);
        
        printf(&quot;\n&quot;);
    }

    // 如果不是叶结点，则遍历它的子结点
    if(pRoot-&gt;m_pLeft != nullptr)
        FindPath(pRoot-&gt;m_pLeft, expectedSum, path, currentSum);
    if(pRoot-&gt;m_pRight != nullptr)
        FindPath(pRoot-&gt;m_pRight, expectedSum, path, currentSum);

    // 在返回到父结点之前，在路径上删除当前结点，
    // 并在currentSum中减去当前结点的值
    currentSum -= pRoot-&gt;m_nValue;
    path.pop_back();
} 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 题33:二叉搜索树的后序遍历序列]]></title>
        <id>https://lixin-scut.github.io//post/shu-ti-33er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie</id>
        <link href="https://lixin-scut.github.io//post/shu-ti-33er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie">
        </link>
        <updated>2020-02-28T23:32:42.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
</blockquote>
<pre><code>/*
struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :
			val(x), left(NULL), right(NULL) {
	}
};*/
</code></pre>
<p>首先看一下后序遍历的特性<br>
1.根节点在最后<br>
2.数组中有一个分界点，分界点前的数字全部小于根节点，分界点后的数字全部大于根节点<br>
  所以我的想法是先找出根节点，再去找分界点，再去看看分界点后面的数字是不是全都符合条件<br>
  注意要考虑某一个子树为空的情况，所以要先判断beg和end的关系，并且应该返回true</p>
<pre><code>class Solution {
public:
    bool VerifySquenceOfBST(vector&lt;int&gt; sequence) {
        if(sequence.empty())
            return false;
        return VerifySquenceOfBST(sequence,0,sequence.size()-1);
    }
    
    bool VerifySquenceOfBST(vector&lt;int&gt; &amp;sequence,int beg,int end){
        if(beg&gt;=end)
            return true;
        int root=sequence[end];
        int locate=beg;
        for(int i=beg;i&lt;end;++i)
            if(sequence[i]==root)
                return false;
            else if(sequence[i]&gt;root)
                break;
            else
                ++locate;
        for(int i=locate;i&lt;end;++i)
            if(sequence[i]&lt;root)
                return false;
        return VerifySquenceOfBST(sequence,beg,locate-1)
            &amp;&amp;VerifySquenceOfBST(sequence,locate,end-1);
    }
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>在后序遍历得到的序列中，最后一个数字是树的根节点的值。数组中 前面的数字可以分为两部分：第一部分是左子树节点的值，它们都比根节 点的值小；第二部分是右子树节点的值，它们都比根节点的值大。<br>
我们接下来用同样的方法确定与数组每一部分对应的子树的结构。这 其实就是一个递归的过程。<br>
我们再来分析另一个整数数组｛7, 4, 6, 5｝o后序遍历的最后一个数字是 根节点，因此根节点的值是5。由于第一个数字7大于5,因此在对应的二 叉搜索树中，根节点上是没有左子树的，数字7、4和6都是右子树节点的值。但我们发现在右子树中有一个节点的值是4,比根节点的值5小，这违背了二叉搜索树的定义。因此，不存在一棵二叉搜索树，它的后序遍历结果是｛7,4,6,5}。</p>
</blockquote>
<pre><code>// BST：Binary Search Tree，二叉搜索树
bool VerifySquenceOfBST(int sequence[], int length)
{
    if(sequence == nullptr || length &lt;= 0)
        return false;

    int root = sequence[length - 1];

    // 在二叉搜索树中左子树的结点小于根结点
    int i = 0;
    for(; i &lt; length - 1; ++ i)
    {
        if(sequence[i] &gt; root)
            break;
    }

    // 在二叉搜索树中右子树的结点大于根结点
    int j = i;
    for(; j &lt; length - 1; ++ j)
    {
        if(sequence[j] &lt; root)
            return false;
    }

    // 判断左子树是不是二叉搜索树
    bool left = true;
    if(i &gt; 0)
        left = VerifySquenceOfBST(sequence, i);

    // 判断右子树是不是二叉搜索树
    bool right = true;
    if(i &lt; length - 1)
        right = VerifySquenceOfBST(sequence + i, length - i - 1);

    return (left &amp;&amp; right);
}
</code></pre>
<p>相关题目：<br>
  输入一个整数数组，判断该数组是不是某二叉搜索树的前序遍历结果。 这和前面问题的后序遍历很类似，只是在前序遍历得到的序列中，第一个 数字是根节点的值。</p>
<p>举一反三：<br>
  如果面试题要求处理一棵二叉树的遍历序列，则可以先找到二叉树的 根节点，再基于根节点把整棵树的遍历序列拆分成左子树对应的子序列和右子树对应的子序列，接下来再递归地处理这两个子序列，题7 “重建二叉树”应用的也是这种思路</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++作用域]]></title>
        <id>https://lixin-scut.github.io//post/czuo-yong-yu</id>
        <link href="https://lixin-scut.github.io//post/czuo-yong-yu">
        </link>
        <updated>2020-02-28T16:09:05.000Z</updated>
        <content type="html"><![CDATA[<p>  我以前以为if、while、for语句中的局部变量是它们自身的特性，今晚才发现原来不是的。<br>
  事情的起因是在项目中分离mutex的作用域的时候，我的做法是将公共部分尽可能提取出一个函数，而后来发现muduo建议的是使用一个花括号的局部作用域就行。</p>
<pre><code>    {
         muduo::MutexLockGuard lock(mutex_);
         if (count_ &lt; 10)
         {
             count = count_;
             ++count_;
         }
         else
         {
             shouldQuit = true;
         }
     }
</code></pre>
<p>  一开始特别困惑，难道花括号外lock就被析构了？<br>
做了一个最简单的实验，发现确实是这样</p>
<pre><code>int main() {
    {
        int i;
    }
    cout &lt;&lt; i &lt;&lt;endl; // error : Use of undeclared identifier 'i'
}
</code></pre>
<p>然后翻查书本的定义：<br>
复合语句 也称作块，一个块就是一个作用域。<br>
在内层作用域中无法进行重载，只会隐藏外层作用域中声明的同名实体<br>
全局作用域：函数体外定义 块作用域：定义在函数块内<br>
内层作用域中可以重新定义外层作用域已有的名字<br>
花括号形成一个新的作用域</p>
<p>所以lock确实会在离开局部作用域后析构，达到unlock的目的</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[多线程TcpServer]]></title>
        <id>https://lixin-scut.github.io//post/duo-xian-cheng-tcpserver</id>
        <link href="https://lixin-scut.github.io//post/duo-xian-cheng-tcpserver">
        </link>
        <updated>2020-02-28T14:13:12.000Z</updated>
        <content type="html"><![CDATA[<p>多线程 TcpServer,用到了 EventLoopThreadPool class</p>
<p>EventLoopThreadPool<br>
  用one loop per thread的思想实现多线程TcpServer的关键步骤是在新建TcpConnection 时从 event loop pool 里挑选一个 loop 给 TcpConnection 用。也就是说多 线程TcpServer自己的EventLoop只用来接受新连接，而新连接会用其他EventLoop 来执行 IOo(单线程 TcpServer 的 EventLoop 是与 TcpConnection 共享的。)<br>
event loop pool 由 EventLoopThreadPool class 表示。<br>
  TcpServer 每次新建一个 TcpConnection 就会调用 getNextLoop()来取得 EventLoop, 如果是单线程服务，每次返回的都是baseLoop,即TcpServer自己用的那个 loop。其中setThreadNum()的参数的意义为设置数量。<br>
  多线程TcpServer的改动很简单，原来是把TcpServer 自用的 loop_ 传给 TcpConnection,现在是每次从 EventLoopThreadPool 取得 ioLoop。 让 TcpConnection 的 Connectioncallback 由 ioLoop 线程调用。</p>
<p>  连接的销毁也不复杂，把原来的removeConnection()拆为两个函数，因为 TcpConnection会在自己的ioLoop线程调用removeconnection(),所以需要把它移 到TcpServer的loop_线程(因为TcpServer是无锁的)。再次把connectDe- stroyed()移到 TcpConnection 的 ioLoop 线程进行是为了保证 TcpConnection 的 Connectioncallback始终在其ioLoop回调，方便客户端代码的编写。</p>
<p>  总而言之，TcpServer和TcpConnection的代码都只处理单线程的情况(甚至都没 有 mutex 成员)，而借助 EventLoop:: runlnLoop()并引入   EventLoopThreadPool 让多线程TcpServer的实现易如反掌。注意ioLoop和loop_问的线程切换都发生在 连接建立和断开的时刻，不影响正常业务的性能。<br>
  目前采用最简单的round-robin算法来选取pool中的EventLoop,不允许 TcpConnection在运行中更换EventLoop,这对长连接和短连接服务都是适用的，不易 造成偏载。mudu o目前的设计是每个TcpServer有自己的EventLoopThreadPool,多 个TcpServer之间不共享EventLoopThreadPool</p>
<p>待改进：<br>
  如果有必要，也可以多个TcpServer共享EventLoopThreadPool,比方说一个服务有多个等价的TCP端口，每个 TcpServer负责一个端口，而来自这些端口的连接共享一个EventLoopThreadPool。<br>
  另外一种可能的用法是一个EventLoop aLoop供两个TcpServer使用(a和b)。 其中a是单线程服务，aLoop既要accept(2)连接也要执行IO;而b是多线程服务, 有自己的EventLoopThreadPool,只用aLoop来accept(2)连接。aLoop上还可以运 行几个TcpClient。这些搭配都是可行的，这也正是EventLoop的灵活性所在，可以 根据需要在多个线程间调配负载。</p>
]]></content>
    </entry>
</feed>