<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2019-11-06T01:53:31.509Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[链表 160. 相交链表[简单]]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-160-xiang-jiao-lian-biao-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-160-xiang-jiao-lian-biao-jian-dan">
        </link>
        <updated>2019-11-06T01:26:08.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>编写一个程序，找到两个单链表相交的起始节点。</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1573004036742.png" alt=""><br>
<img src="https://lixin-ee.github.io//post-images/1573004040961.png" alt=""></p>
<blockquote>
<p>注意：<br>
如果两个链表没有交点，返回 null.<br>
在返回结果后，两个链表仍须保持原有的结构。<br>
可假定整个链表结构中没有循环。<br>
程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/intersection-of-two-linked-lists<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题如果用哈希表的话是没啥难度的，所以重点在于如何满足O(n) 时间复杂度，且仅用 O(1) 内存。<br>
我最后想到的办法是制造一个环，从两个链表的头部同时出发，然后谁先达到尾部就直接把链表接到另一个的尾部<br>
但是在复习完有环链表的判断后才发现最后的相遇点不是一定在交点那里的，GG</p>
<p>纠结了太久了，直接看官方解答吧：</p>
<blockquote>
<p>方法一: 暴力法<br>
对链表A中的每一个结点 a_i	 ，遍历整个链表 B 并检查链表 B 中是否存在结点和 a_i  相同。<br>
复杂度分析<br>
时间复杂度 : (mn)。<br>
空间复杂度 : O(1)。</p>
<p>方法二: 哈希表法<br>
遍历链表 A 并将每个结点的地址/引用存储在哈希表中。然后检查链表 B 中的每一个结点 b_i 是否在哈希表中。若在，则 b_i为相交结点。<br>
复杂度分析<br>
时间复杂度 : O(m+n)。<br>
空间复杂度 : O(m) 或 O(n)。</p>
<p>方法三：双指针法<br>
创建两个指针 pA 和 pB，分别初始化为链表 A 和 B 的头结点。然后让它们向后逐结点遍历。<br>
当 pA 到达链表的尾部时，将它重定位到链表 B 的头结点 (你没看错，就是链表 B); 类似的，当 pB 到达链表的尾部时，将它重定位到链表 A 的头结点。<br>
若在某一时刻 pA 和 pB 相遇，则 pA/pB 为相交结点。<br>
想弄清楚为什么这样可行, 可以考虑以下两个链表: A={1,3,5,7,9,11} 和 B={2,4,9,11}，相交于结点 9。 由于 B.length (=4) &lt; A.length (=6)，pB 比 pA 少经过 2 个结点，会先到达尾部。将 pB 重定向到 A 的头结点，pA 重定向到 B 的头结点后，pB 要比 pA 多走 2 个结点。因此，它们会同时到达交点。<br>
如果两个链表存在相交，它们末尾的结点必然相同。因此当 pA/pB 到达链表结尾时，记录下链表 A/B 对应的元素。若最后元素不相同，则两个链表不相交。</p>
<p>复杂度分析<br>
时间复杂度 : O(m+n)。<br>
空间复杂度 : O(1)。</p>
</blockquote>
<p>妙啊！确实是简单题hhh，我只猜到了开头没猜到结局hhh，两者无论如何走过的路程都是一样的，所以当两者相等时退出循环判断，只需要判断最后的结点是否是NULL就好（甚至于都不用判断，直接返回就好）<br>
自己复现的代码如下：</p>
<pre><code>ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if(headA==NULL||headB==NULL)
            return NULL;
        ListNode *cur1=headA,*cur2=headB;
        while(cur1!=cur2){
            cur1=cur1==NULL?headB:cur1-&gt;next;
            cur2=cur2==NULL?headA:cur2-&gt;next;
        }
        return cur1;
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 2. 两数相加[中等]]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-2-liang-shu-xiang-jia-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-2-liang-shu-xiang-jia-zhong-deng">
        </link>
        <updated>2019-11-05T07:27:17.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。<br>
如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。<br>
您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>示例：<br>
输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>
输出：7 -&gt; 0 -&gt; 8<br>
原因：342 + 465 = 807</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/add-two-numbers<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>本题目其实相对不算特别难（因为链表按个位算起的），主要的难点在于<br>
1.如果两链表长度不等的话，存储起来比较麻烦，我本来想原地操作，但是这样子反而比较难操作（因为必须对两个链表同时操作直至其中一个到结尾，同时需要返回正确的那个链表的头结点）<br>
2.当一个链表去到尾部后的处理，以及如何判断两个链表达到结尾退出循环的判断<br>
2.进位其实还是比较好处理的，直接一个int就好<br>
最终代码如下</p>
<pre><code>class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        int flag=0;
        ListNode* ehead=new ListNode(0);
        ListNode* cur=ehead;
        int res,i1,i2;        
        while(l1!=NULL||l2!=NULL){
            i1=l1!=NULL?l1-&gt;val:0;
            i2=l2!=NULL?l2-&gt;val:0;
            res=(i1+i2+flag)%10;
            flag=(i1+i2+flag)/10;
            ListNode* newnode=new ListNode(res);
            cur-&gt;next=newnode;
            cur=newnode;
            if(l1!=NULL)
                l1=l1-&gt;next;
            if(l2!=NULL)
                l2=l2-&gt;next;
        }
        if(flag){
            ListNode* newnode=new ListNode(1);
            cur-&gt;next=newnode;
            cur=newnode;
        }
        cur-&gt;next=NULL;
        return ehead-&gt;next;
    }
};
</code></pre>
<p>比较重要的点就是<br>
1 <code>while(l1!=NULL||l2!=NULL)</code> 必须是或判断<br>
2 <code>i1=l1!=NULL?l1-&gt;val:0;</code> 这里使用条件语句能够节省很多代码</p>
<p>然后先来看一下网友的题解吧</p>
<pre><code>class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* head=new ListNode(-1);//存放结果的链表
        ListNode* h=head;//移动指针
        int sum=0;//每个位的加和结果
        bool carry=false;//进位标志
        while(l1!=NULL||l2!=NULL)
        {
            sum=0;
            if(l1!=NULL)
            {
                sum+=l1-&gt;val;
                l1=l1-&gt;next;
            }
            if(l2!=NULL)
            {
                sum+=l2-&gt;val;
                l2=l2-&gt;next;
            }
            if(carry)
                sum++;
            h-&gt;next=new ListNode(sum%10);
            h=h-&gt;next;
            carry=sum&gt;=10?true:false;
        }
        if(carry)
        {
            h-&gt;next=new ListNode(1);
        }
        return head-&gt;next;
    }
};
</code></pre>
<p>这里我没贴上补位的题解，因为补位需要先循环确定长度。主要是第二种做法比较巧妙的是利用一个sum来计算和。</p>
<p>官方题解和我的一毛一样hhh</p>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(max(m,n))，假设 m 和 n 分别表示 l1 和 l2 的长度，上面的算法最多重复max(m,n) 次。<br>
空间复杂度：O(max(m,n))， 新列表的长度最多为 max(m,n)+1。</p>
</blockquote>
<p>拓展</p>
<p>如果链表中的数字不是按逆序存储的呢？例如：<br>
(3→4→2)+(4→6→5)=8→0→7</p>
<p>最后这个拓展比较有趣，网友们的想法是利用递归或者栈，这个想法还是比较有趣的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[递归套路解决链表问题]]></title>
        <id>https://lixin-ee.github.io//post/di-gui-tao-lu-jie-jue-lian-biao-wen-ti</id>
        <link href="https://lixin-ee.github.io//post/di-gui-tao-lu-jie-jue-lian-biao-wen-ti">
        </link>
        <updated>2019-11-04T08:16:32.000Z</updated>
        <content type="html"><![CDATA[<p>递归套路解决链表问题：<br>
1.找终止条件：当head指向链表只剩一个元素的时候，自然是不可能重复的，因此return<br>
2.想想应该返回什么值：应该返回的自然是已经去重的链表的头节点<br>
3.每一步要做什么：宏观上考虑，此时head.next已经指向一个去重的链表了，而根据第二步，我应该返回一个去重的链表的头节点。因此这一步应该做的是判断当前的head和head.next是否相等，如果相等则说明重了，返回head.next，否则返回head</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 82. 删除排序链表中的重复元素 II [中等]]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-82-shan-chu-pai-xu-lian-biao-zhong-de-chong-fu-yuan-su-ii-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-82-shan-chu-pai-xu-lian-biao-zhong-de-chong-fu-yuan-su-ii-zhong-deng">
        </link>
        <updated>2019-11-04T07:50:19.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字</p>
<p>示例 1:<br>
输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5<br>
输出: 1-&gt;2-&gt;5<br>
示例 2:<br>
输入: 1-&gt;1-&gt;1-&gt;2-&gt;3<br>
输出: 2-&gt;3</p>
</blockquote>
<p>这道题是上一题<a href="https://lixin-ee.github.io/post/lian-biao-83-shan-chu-pai-xu-lian-biao-zhong-de-chong-fu-yuan-su-jian-dan/">83题</a>的进化版（为啥82题是83题的进化版？？？）<br>
主要难点在于1.判断重复点和2.删除重复点 这两个点的结合，如果使用重复点的前一个点进行删除，那么需要对重复点进行连续的判断比如示例1中的3-3-4-4，就需要在2的结点就进行连续的删除了。<br>
我的思路也是用while不断地判断，然后针对多个重复值（特别是奇数的情况）先保留一个val值，让cur能够直接指向第一个不同于val 的结点<br>
最终代码如下：</p>
<pre><code>class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        while(head==NULL||head-&gt;next==NULL)
            return head;
        ListNode* ehead=new ListNode(-1);
        ehead-&gt;next=head;
        int val=-1;
        ListNode* cur=ehead;
        while(cur!=NULL){
            while(cur-&gt;next!=NULL&amp;&amp;cur-&gt;next-&gt;next!=NULL&amp;&amp;cur-&gt;next-&gt;val==cur-&gt;next-&gt;next-&gt;val){
                val=cur-&gt;next-&gt;val;
                while(cur-&gt;next!=NULL&amp;&amp;cur-&gt;next-&gt;val==val)
                    cur-&gt;next=cur-&gt;next-&gt;next;
            }
            cur=cur-&gt;next;
        }
        return ehead-&gt;next;
    }
};
</code></pre>
<p>注意各种NULL的判断都是不可少的，链表的第一注意点就是结点是否为null<br>
然后是网友题解：<br>
思路:<br>
思路一: 迭代 快慢指针,用快指针跳过那些有重复数组,慢指针负责和快指针拼接!</p>
<pre><code>class Solution:
    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:
        if head == None or head.next == None:
            return head
        dummy = ListNode(-1000)
        dummy.next = head
        slow = dummy
        fast = dummy.next
        while fast:
            if  fast.next and fast.next.val == fast.val:
                tmp = fast.val
                while fast and tmp == fast.val:
                    fast = fast.next
            else:
                slow.next = fast
                slow = fast
                fast = fast.next
        slow.next = fast
        return dummy.next
</code></pre>
<p>思路一(另一个版本):</p>
<pre><code>class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null) return head;
        ListNode dummy = new ListNode(-1000);
        dummy.next = head;
        ListNode slow = dummy;
        ListNode fast = dummy.next;
        while (fast != null) {
            while (fast.next != null &amp;&amp; fast.val == fast.next.val) fast = fast.next;
            if (slow.next == fast) slow = slow.next;
            else slow.next = fast.next;
            fast = fast.next;
        }
        return dummy.next; 
    }
}
</code></pre>
<p>思路二:递归</p>
<pre><code>class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null)  return head;
        if (head.next != null &amp;&amp; head.val == head.next.val) {
            while (head.next != null &amp;&amp; head.val == head.next.val) {
                head = head.next;
            }
            return deleteDuplicates(head.next);
        }
        else head.next = deleteDuplicates(head.next);
        return head;    
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 203.移除链表元素[简单]]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-203yi-chu-lian-biao-yuan-su-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-203yi-chu-lian-biao-yuan-su-jian-dan">
        </link>
        <updated>2019-11-03T01:45:21.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>删除链表中等于给定值 val 的所有节点。</p>
<p>示例:<br>
输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6<br>
输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</p>
</blockquote>
<p>思路：<br>
1.这道主要是不能单纯地检测当前指针的val，而是应该检查next的val。<br>
2.这道题需要先检查头节点以及头节点之后的结点是否和val相等，如果相等的话需要先删除前面的结点。</p>
<pre><code>class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        if(head==NULL)
            return head;
        while(head-&gt;val==val){
            if(head-&gt;next==NULL)
                return NULL;
            head=head-&gt;next;
        }
        ListNode* cur=head;
        while(cur!=NULL){
            while(cur-&gt;next!=NULL&amp;&amp;cur-&gt;next-&gt;val==val){
                cur-&gt;next=cur-&gt;next-&gt;next;
            }
            cur=cur-&gt;next;
        }
        return head;
    }
};
</code></pre>
<p>然后看一下网友题解删除结点的步骤</p>
<blockquote>
<p>找到该结点的前一个结点<br>
进行删除操作<br>
三种方法：</p>
<p>删除头结点时另做考虑（由于头结点没有前一个结点）<br>
添加一个虚拟头结点，删除头结点就不用另做考虑<br>
递归</p>
<p>方法一（删除头结点时另做考虑）</p>
</blockquote>
<pre><code>class Solution {
    public ListNode removeElements(ListNode head, int val) {
        //删除值相同的头结点后，可能新的头结点也值相等，用循环解决
        while(head!=null&amp;&amp;head.val==val){
            head=head.next;
        }
        if(head==null)
            return head;
        ListNode prev=head;
        //确保当前结点后还有结点
        while(prev.next!=null){
            if(prev.next.val==val){
                prev.next=prev.next.next;
            }else{
                prev=prev.next;
            }
        }
        return head;
    }
}
</code></pre>
<p>方法二（添加一个虚拟头结点）</p>
<pre><code>class Solution {
    public ListNode removeElements(ListNode head, int val) {
        //创建一个虚拟头结点
        ListNode dummyNode=new ListNode(val-1);
        dummyNode.next=head;
        ListNode prev=dummyNode;
        //确保当前结点后还有结点
        while(prev.next!=null){
            if(prev.next.val==val){
                prev.next=prev.next.next;
            }else{
                prev=prev.next;
            }
        }
        return dummyNode.next;
    }
}
</code></pre>
<p>方法三（递归）</p>
<pre><code>class Solution {
    public ListNode removeElements(ListNode head, int val) {
       if(head==null)
           return null;
        head.next=removeElements(head.next,val);
        if(head.val==val){
            return head.next;
        }else{
            return head;
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 83. 删除排序链表中的重复元素[简单]]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-83-shan-chu-pai-xu-lian-biao-zhong-de-chong-fu-yuan-su-jian-dan</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-83-shan-chu-pai-xu-lian-biao-zhong-de-chong-fu-yuan-su-jian-dan">
        </link>
        <updated>2019-11-02T01:43:41.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p>
<p>示例 1:<br>
输入: 1-&gt;1-&gt;2<br>
输出: 1-&gt;2<br>
示例 2:<br>
输入: 1-&gt;1-&gt;2-&gt;3-&gt;3<br>
输出: 1-&gt;2-&gt;3</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>想法<br>
(之前)hhh因为之前做数组的时候用过很6的快慢指针，所以也是用的快慢指针</p>
<pre><code>class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(head==NULL||head-&gt;next==NULL)
            return head;
        ListNode* fast=head;
        ListNode* slow=head;
        while(fast!=NULL&amp;&amp;fast-&gt;next!=NULL){
            while(fast!=NULL&amp;&amp;fast-&gt;val==slow-&gt;val)
                fast=fast-&gt;next;
            slow-&gt;next=fast;
            slow=fast;
        }
        return head;     
    }
};
</code></pre>
<p>（11.2）发现自己想复杂了，可以直接使用一个cur指针，判断下一个值是否和当前相等，相等的话就修改next指向的值。</p>
<p>然后来看下网友题解：<br>
解法1：双指针法</p>
<pre><code>class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(head==NULL||head-&gt;next==NULL)
            return head;
        ListNode* p=head;//慢指针
        ListNode* q=head-&gt;next;//快指针
        while(p-&gt;next!=NULL)
        {
            if(p-&gt;val==q-&gt;val)//找到重复元素
            {
                if(q-&gt;next==NULL)//快指针后面若没有元素直接剔除
                    p-&gt;next=NULL;
                else//快指针后有元素
                {
                    p-&gt;next=q-&gt;next;
                    q=q-&gt;next;
                }
            }
            else //元素不相等
            {
                p=p-&gt;next;
                q=q-&gt;next;
            }
        }
        return head;
    }
};
</code></pre>
<p>解法2：直接法（一个指针操作）</p>
<pre><code>class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(!head||!head-&gt;next)
            return head;
        ListNode* p=head;
        while(p-&gt;next!=NULL&amp;&amp;p!=NULL)
        {
            if(p-&gt;val == p-&gt;next-&gt;val)
            {
                p-&gt;next=p-&gt;next-&gt;next;
            }
            else 
                p=p-&gt;next;
        }
        return head;
    }
};
</code></pre>
<p>解法3：递归法</p>
<pre><code>class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(!head||!head-&gt;next)
            return head;
        head-&gt;next=deleteDuplicates(head-&gt;next);
        if(head-&gt;val==head-&gt;next-&gt;val) head=head-&gt;next;
        return head;
    }
};
</code></pre>
<blockquote>
<p>递归套路解决链表问题：<br>
找终止条件：当head指向链表只剩一个元素的时候，自然是不可能重复的，因此return<br>
想想应该返回什么值：应该返回的自然是已经去重的链表的头节点<br>
每一步要做什么：宏观上考虑，此时head.next已经指向一个去重的链表了，而根据第二步，我应该返回一个去重的链表的头节点。因此这一步应该做的是判断当前的head和head.next是否相等，如果相等则说明重了，返回head.next，否则返回head</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode链表测试代码]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-ce-shi</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-ce-shi">
        </link>
        <updated>2019-11-01T14:35:47.000Z</updated>
        <content type="html"><![CDATA[<p>注意在C++里面ListNode已经是定义好的类了，不需要重复定义了。<br>
本代码主要是建立一个链表方便在playground中进行测试，但是注意输出其返回值的话不会像测试用例那样会输出整个链表。</p>
<pre><code>int main() {
    ListNode n5(5);
    ListNode n4(4);
    ListNode n3(3);
    ListNode n2(2);
    ListNode n1(1);
    ListNode *head=&amp;n1;
    n1.next=&amp;n2;
    n2.next=&amp;n3;
    n3.next=&amp;n4;
    n4.next=&amp;n5;
    cout&lt;&lt;swapPairs(head)-&gt;val&lt;&lt;endl;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 19. 删除链表的倒数第N个节点[中等]]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-19-shan-chu-lian-biao-de-dao-shu-di-n-ge-jie-dian-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-19-shan-chu-lian-biao-de-dao-shu-di-n-ge-jie-dian-zhong-deng">
        </link>
        <updated>2019-11-01T00:21:02.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
<p>示例：<br>
给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.<br>
当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.<br>
说明：<br>
给定的 n 保证是有效的。<br>
进阶：<br>
你能尝试使用一趟扫描实现吗？</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>思路<br>
如果需要一趟扫描的话，因为链表的长度是未知的，除非牺牲空间复杂度，否则是做不到一趟扫描的，所以必须使用递归，在递归函数中附上n和变量的引用用来记录逆向的计数<br>
最终代码如下</p>
<pre><code>class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        int loc=0;
        ListNode* ehead=new ListNode(0);
        ehead-&gt;next=head;
        delNth(ehead,loc,n);
        return ehead-&gt;next;
    }
    
    ListNode* delNth(ListNode* lb,int &amp;loc,int n){
        ListNode* pre;
        if(lb-&gt;next!=NULL)
            pre=delNth(lb-&gt;next,loc,n);
        
        if(loc==n){
            lb-&gt;next=pre-&gt;next;
        }
        ++loc;
        return lb;
        
    }
};
</code></pre>
<p>需要注意的就是传入loc的必须是引用，传入n最好设置为const</p>
<p>然后来看一下官方题解：</p>
<blockquote>
<p>摘要<br>
本文适用于初学者。它介绍了以下内容：链表的遍历和删除其末尾的第 n 个元素。<br>
方法一：两次遍历算法<br>
思路<br>
我们注意到这个问题可以容易地简化成另一个问题：删除从列表开头数起的第 (L - n + 1)个结点，其中 L 是列表的长度。只要我们找到列表的长度 L，这个问题就很容易解决。<br>
算法<br>
首先我们将添加一个哑结点作为辅助，该结点位于列表头部。哑结点用来简化某些极端情况，例如列表中只含有一个结点，或需要删除列表的头部。在第一次遍历中，我们找出列表的长度 L。然后设置一个指向哑结点的指针，并移动它遍历列表，直至它到达第 (L - n)个结点那里。我们把第 (L - n) 个结点的 next 指针重新链接至第 (L - n + 2)个结点，完成这个算法。</p>
</blockquote>
<pre><code>public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    int length  = 0;
    ListNode first = head;
    while (first != null) {
        length++;
        first = first.next;
    }
    length -= n;
    first = dummy;
    while (length &gt; 0) {
        length--;
        first = first.next;
    }
    first.next = first.next.next;
    return dummy.next;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(L)，该算法对列表进行了两次遍历，首先计算了列表的长度 L 其次找到第 (L - n) 个结点。 操作执行了 2L−n 步，时间复杂度为 O(L)。<br>
空间复杂度：O(1)，我们只用了常量级的额外空间。</p>
<p>方法二：一次遍历算法<br>
算法<br>
上述算法可以优化为只使用一次遍历。我们可以使用两个指针而不是一个指针。第一个指针从列表的开头向前移动 n+1 步，而第二个指针将从列表的开头出发。现在，这两个指针被 n 个结点分开。我们通过同时移动两个指针向前来保持这个恒定的间隔，直到第一个指针到达最后一个结点。此时第二个指针将指向从最后一个结点数起的第 n 个结点。我们重新链接第二个指针所引用的结点的 next 指针指向该结点的下下个结点。</p>
</blockquote>
<pre><code>public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode first = dummy;
    ListNode second = dummy;
    // Advances first pointer so that the gap between first and second is n nodes apart
    for (int i = 1; i &lt;= n + 1; i++) {
        first = first.next;
    }
    // Move first to the end, maintaining the gap
    while (first != null) {
        first = first.next;
        second = second.next;
    }
    second.next = second.next.next;
    return dummy.next;
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(L)，该算法对含有 L 个结点的列表进行了一次遍历。因此时间复杂度为 O(L)。<br>
空间复杂度：O(1)，我们只用了常量级的额外空间。</p>
</blockquote>
<p>解法一的哑结点就是我设置的ehead（不愧是我！hhh），然而解法二很妙啊，巧妙地利用两个指针的距离，比我的递归更简洁。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 92. 反转链表 II[中等]]]></title>
        <id>https://lixin-ee.github.io//post/92-fan-zhuan-lian-biao-ii</id>
        <link href="https://lixin-ee.github.io//post/92-fan-zhuan-lian-biao-ii">
        </link>
        <updated>2019-10-31T01:17:18.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p>
<p>说明:<br>
1 ≤ m ≤ n ≤ 链表长度。<br>
示例:<br>
输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4<br>
输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/reverse-linked-list-ii<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>思路：<br>
使用三个ListNode指针变量 first 和pre、cur，first一直指向m的前一位，比如例子中的1，然后pre和cur配合将cur移动到first的位置，比如例子中迭代地把3和4 放到1后面的位置<br>
注意一定要加上一个虚链表头，防止m=1的情况<br>
最终代码</p>
<pre><code>class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int m, int n) {
        while(head==NULL&amp;&amp;head-&gt;next==NULL)
            return head;
        int count=0;
        ListNode* first;
        ListNode* cur;
        ListNode* pre;
        ListNode* ehead=new ListNode(0);
        ehead-&gt;next=head;
        cur=ehead;
        while(count&lt;=n){
            if(count&lt;m-1){
                ++count;
                cur=cur-&gt;next;
                continue;
            }
            if(count==m-1){
                first=cur;
                pre=first-&gt;next;
                cur=pre-&gt;next;
                count+=2;
                continue;
            }
            pre-&gt;next=cur-&gt;next;
            cur-&gt;next=first-&gt;next;
            first-&gt;next=cur;
            cur=pre-&gt;next;
            ++count;
        }
        return ehead-&gt;next;
    }
};
</code></pre>
<p>最高赞题解和我的一样，然后来看一下官方题解如何<br>
方法一: 递归<br>
直觉<br>
使用递归反转链表的思路来源于反转字符串时使用的类似方法。反转字符串的一个巨大优势是可以使用下标信息。我们可以创建两个指针，一个开头，一个结尾。不断地交换这两个指针指向的元素，并将两个指针向中间移动。在分析链表的情况前，先让我们看看字符串上的示例。<br>
<img src="https://lixin-ee.github.io//post-images/1572485555891.png" alt=""><br>
反转给定链表的一部分的思路基于上述方法。我们需要两个不同指针，一个指向第 mm 个结点，另一个指向第 nn 个结点。一旦有了这两个指针，我们就可以不断地交换这两个指针指向结点的数据，并将两个指针相向移动，就像字符串的情况那样。</p>
<p>然而，链表中没有向后指针，也没有下标。因此，我们需要使用递归来 模拟 向后指针。递归中的回溯可以帮助我们模拟一个指针从第nn个结点向中心移动的移动过程。</p>
<p>算法</p>
<p>我们定义一个递归函数用于反转给定链表的一部分。<br>
将函数记为 recurse。该函数使用三个参数: m 为反转的起点, n 为反转的终点, 以及从第 nn 个结点开始，随着递归回溯过程向后移动的指针 right。不清楚的话，可以参考后文的示意图。<br>
此外，我们还有一个指针 left，它从第 m 个结点开始向前移动。在 <code>P thon中, 我们需要一个全局变量，值随着递归的进行而改变。在其他函数调用造成的变化可以持续的编程语言中，可以考虑将该指针加为函数recurse</code> 的一个变量。<br>
在<br>
递归调用中，给定 m，n，和 right, 首先判断 n = 1。 若判断为真, 则结束。<br>
于是，当 n 的值达到 1 时，我们便回溯。这时，right 指针在我们要反转的子链表结尾，left 到达了字列表的开头。于是，我们置换数据，并将 left 指针前移：left = left.next。我们需要此变化在回溯过程中保持。<br>
自此，每当我们回溯时，right 指针向后移一位。这就是前文所说的模拟。通过回溯模拟向后移动。<br>
当 right == left 或者 right.next == left 时停止交换。当子链表的长度为奇数时，情况为前者；当子链表长度为偶数时为后者。我们使用一个全局 boolean 变量 flag 来停止交换。<br>
下面是一系列整个算法的示意图，希望能够帮助你理解清楚。<br>
<img src="https://lixin-ee.github.io//post-images/1572485670158.png" alt=""><br>
这是递归过程的第一步。给定所用链表，left 和 right 指针从链表的 head 开始。第一步是以更新过的 m 和 n 进行递归调用，换而言之，它们的值各自减 1。此外，left 和 right 指针向前移动一位。<br>
<img src="https://lixin-ee.github.io//post-images/1572485684271.png" alt=""><br>
接下来的两步展示了 left 和 right 指针在链表中的移动。注意到在第二步之后，left 指针抵达了目标位置。因此，后续不再移动。从现在起，只有 right 指针继续移动，直到抵达结点 6。<br>
<img src="https://lixin-ee.github.io//post-images/1572485695408.png" alt=""><br>
如你所见，在第五步之后，两个指针均抵达了目标位置，可以开始进行回溯。我们不再继续递归。回溯过程中的操作是交换 left 和 right 结点的数据。<br>
<img src="https://lixin-ee.github.io//post-images/1572485708891.png" alt=""><br>
如你所见，在第三步（回溯）之后，right 指针 穿过了 left 指针，此时已经完成了要求部分链表的反转。结果是 [7 → 9 → 8 → 1 → 10 → 2 → 6]。 于是不再进行数据交换，在代码中，我们使用全局 boolean 变量 flag 来停止数据交换。不能直接跳出递归。</p>
<pre><code>class Solution {

    // Object level variables since we need the changes
    // to persist across recursive calls and Java is pass by value.
    private boolean stop;
    private ListNode left;

    public void recurseAndReverse(ListNode right, int m, int n) {

        // base case. Don't proceed any further
        if (n == 1) {
            return;
        }

        // Keep moving the right pointer one step forward until (n == 1)
        right = right.next;

        // Keep moving left pointer to the right until we reach the proper node
        // from where the reversal is to start.
        if (m &gt; 1) {
            this.left = this.left.next;
        }

        // Recurse with m and n reduced.
        this.recurseAndReverse(right, m - 1, n - 1);

        // In case both the pointers cross each other or become equal, we
        // stop i.e. don't swap data any further. We are done reversing at this
        // point.
        if (this.left == right || right.next == this.left) {
            this.stop = true;            
        }

        // Until the boolean stop is false, swap data between the two pointers
        if (!this.stop) {
            int t = this.left.val;
            this.left.val = right.val;
            right.val = t;

            // Move left one step to the right.
            // The right pointer moves one step back via backtracking.
            this.left = this.left.next;
        }
    }

    public ListNode reverseBetween(ListNode head, int m, int n) {
        this.left = head;
        this.stop = false;
        this.recurseAndReverse(head, m, n);
        return head;
    }
}
</code></pre>
<p>复杂度分析<br>
时间复杂度:O(N)。对每个结点最多处理两次。递归过程<br>
，回溯<br>
。在回溯过程中，我们只交换了一半的结点，但总复杂度是 O(N)。<br>
空间复杂度: 最坏情况下为 O(N)。在最坏的情况下，我们需要反转整个链表。这是此时递归栈的大小。</p>
<p>剩下的迭代法可以直接查看<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/fan-zhuan-lian-biao-ii-by-leetcode/">官方题解</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 328. 奇偶链表[中等]]]></title>
        <id>https://lixin-ee.github.io//post/lian-biao-328-qi-ou-lian-biao-zhong-deng</id>
        <link href="https://lixin-ee.github.io//post/lian-biao-328-qi-ou-lian-biao-zhong-deng">
        </link>
        <updated>2019-10-30T01:44:41.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。<br>
请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p>
<p>示例 1:<br>
输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>
输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL<br>
示例 2:<br>
输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL<br>
输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL<br>
说明:<br>
应当保持奇数节点和偶数节点的相对顺序。<br>
链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/odd-even-linked-list<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>我的想法<br>
就是直接新建两个结点，一个存放奇数节点，另外一个存放偶数节点，然后再将两者连接起来。<br>
然后在实现过程中，发现一个问题是必须实现记录好第一个偶数节点（用于与奇数节点相连）<br>
然后最重要的是！！！必须给偶数节点显式接上NULL！！！！否则可能会出现（1-2-3-4-5）最后4的next指向5的情况</p>
<pre><code>class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        if(head==NULL||head-&gt;next==NULL)
            return head;
        ListNode* temp=head-&gt;next;
        ListNode* odd=head;
        ListNode* even=head-&gt;next;
        ListNode* curr=head-&gt;next-&gt;next;
        int count=1;
        while(curr!=NULL){
            if(count%2){
                odd-&gt;next=curr;
                curr=curr-&gt;next;
                odd=odd-&gt;next;
            }else
            {
                even-&gt;next=curr;
                curr=curr-&gt;next;
                even=even-&gt;next;
            }
            ++count;             
        }
        odd-&gt;next=temp;
        even-&gt;next=NULL;
        return head;
    }
};
</code></pre>
<p>链表题最爽的就是可以手写撸代码，基本都能一次过<br>
然后来看一下官方题解：</p>
<blockquote>
<p>解法<br>
想法<br>
将奇节点放在一个链表里，偶链表放在另一个链表里。然后把偶链表接在奇链表的尾部。<br>
算法<br>
这个解法非常符合直觉思路也很简单。但是要写一个精确且没有 bug 的代码还是需要进行一番思索的。<br>
一个 LinkedList 需要一个头指针和一个尾指针来支持双端操作。我们用变量 head 和 odd 保存奇链表的头和尾指针。 evenHead 和 even 保存偶链表的头和尾指针。算法会遍历原链表一次并把奇节点放到奇链表里去、偶节点放到偶链表里去。遍历整个链表我们至少需要一个指针作为迭代器。这里 odd 指针和 even 指针不仅仅是尾指针，也可以扮演原链表迭代器的角色。<br>
解决链表问题最好的办法是在脑中或者纸上把链表画出来。比方说<br>
<img src="https://lixin-ee.github.io//post-images/1572400580152.png" alt=""></p>
</blockquote>
<pre><code>public class Solution {
    public ListNode oddEvenList(ListNode head) {
        if (head == null) return null;
        ListNode odd = head, even = head.next, evenHead = even;
        while (even != null &amp;&amp; even.next != null) {
            odd.next = even.next;
            odd = odd.next;
            even.next = odd.next;
            even = even.next;
        }
        odd.next = evenHead;
        return head;
    }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度： O(n) 。总共有 n 个节点，我们每个遍历一次。<br>
空间复杂度： O(1) 。我们只需要 4 个指针。</p>
</blockquote>
<p>官方题解果然更优雅一点哈哈哈，因为我比较担心出问题所以设置了cur指针，其实这个是非必须的。</p>
]]></content>
    </entry>
</feed>