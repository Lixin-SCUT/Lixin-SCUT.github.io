<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-ee.github.io/</id>
    <title>Lixin-ee</title>
    <updated>2020-01-06T12:26:36.968Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-ee.github.io/"/>
    <link rel="self" href="https://lixin-ee.github.io//atom.xml"/>
    <subtitle>好景在望。</subtitle>
    <logo>https://lixin-ee.github.io//images/avatar.png</logo>
    <icon>https://lixin-ee.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-ee</rights>
    <entry>
        <title type="html"><![CDATA[数组 46. 全排列[中等][回溯]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-46-quan-pai-lie-zhong-deng-hui-su</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-46-quan-pai-lie-zhong-deng-hui-su">
        </link>
        <updated>2020-01-06T01:54:11.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个没有重复数字的序列，返回其所有可能的全排列。<br>
示例:<br>
输入: [1,2,3]<br>
输出:<br>
[<br>
[1,2,3],<br>
[1,3,2],<br>
[2,1,3],<br>
[2,3,1],<br>
[3,1,2],<br>
[3,2,1]<br>
]<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/permutations<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>第一想法反而是昨天的解法，也就是从空集开始，每次往已有集合里面添加一个新元素，然后把符合条件的集合提取出来（错误 因为这样子是有序子序列，但是像 3 2 1是无序序列，不可能先添加3 再添加1 再添加2）<br>
然后利用排列的思想，想用递归来解决问题（也就是<code>4*3*2*1</code>）对递归函数传入一个数组，选择数组其中一个值并加入结果序列中，然后从数组中去除这个值，再继续调用。<br>
陷入一种很尴尬的处境，因为如果要递归调用的话，那么得去除当前nums中的当前元素，erase只接受迭代器，但是得保证当前的nums在下一个循环中必须是不变的，所以我增加了两个临时变量auto tempn=nums,tempc=cur;<br>
注意递归函数的形参必须是传值调用。<br>
原来是用回溯法，前几题见过，但是还没细看<br>
我发现我无意中实现的就是回溯算法hhh但是题解中用了额外的used数组记录已用数据+状态重置，确实比我的temp节省很多额外的空间<br>
不过回溯法还有很多细节需要注意，值得好好看题解</p>
<p>然后来看网友题解</p>
<p><img src="https://lixin-ee.github.io//post-images/1578276026030.png" alt=""></p>
<blockquote>
<p>首先解释“回溯”算法的应用，“回溯”算法主要用于搜索，因此有时候“回溯算法”也叫“回溯搜索”。这里“搜索”的意思是“查找所需要的解”。我们每天使用的“搜索引擎”就是帮助我们在庞大的互联网上搜索我们需要的信息。<br>
而这里的“回溯”指的是“状态重置”，可以理解为“回到过去”、“恢复现场”，是在编码的过程中，为了节约空间而使用的一种技巧。</p>
</blockquote>
<blockquote>
<p>“全排列”就是一个非常经典的“回溯”算法的应用。我们知道，N 个数字的全排列一共有 N! 这么多个。<br>
大家可以尝试一下在纸上写 3 个数字、4 个数字、5 个数字的全排列，相信不难找到这样的方法。<br>
例如数组 [1, 2, 3] 的全排列。<br>
我们先写以 1 开头的全排列，它们是：[1, 2, 3], [1, 3, 2]；<br>
再写以 2 开头的全排列，它们是：[2, 1, 3], [2, 3, 1]；<br>
最后写以 3 开头的全排列，它们是：[3, 1, 2], [3, 2, 1]。<br>
我们只需要按顺序枚举每一位可能出现的情况，已经选择的数字在接下来要确定的数字中不能出现。按照这种策略选取就能够做到不重不漏，把可能的全排列都枚举出来。<br>
在枚举第一位的时候，有 3 种情况。<br>
在枚举第二位的时候，前面已经出现过的数字就不能再被选取了；<br>
在枚举第三位的时候，前面 2 个已经选择过的数字就不能再被选取了。<br>
这样的思路，我们可以用一个树形结构来表示。</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1578276151121.png" alt=""></p>
<blockquote>
<p>使用编程的方法得到全排列，就是在这样的一个树形结构中进行编程，具体来说，就是执行一次深度优先遍历，从树的根结点到叶子结点形成的路径就是一个全排列。<br>
下面我们解释如何编码：<br>
1、首先这棵树除了根结点和叶子结点以外，每一个结点做的事情其实是一样的，即在已经选了一些数的前提，我们需要在剩下还没有选择的数中按照顺序依次选择一个数，这显然是一个递归结构；<br>
2、递归的终止条件是，数已经选够了，因此我们需要一个变量来表示当前递归到第几层，我们把这个变量叫做 depth；<br>
3、这些结点实际上表示了搜索（查找）全排列问题的不同阶段，为了区分这些不同阶段，我们就需要一些变量来记录为了得到一个全排列，我们进行到那一步了，在这里我们需要两个变量：<br>
（1）已经选了哪些数，到叶子结点时候，这些已经选择的数就构成了一个全排列；<br>
（2）一个布尔数组 used，初始化的时候都为 false 表示这些数还没有被选择，当我们选定一个数的时候，就将这个数组的相应位置设置为 true ，这样在考虑下一个位置的时候，就能够以 O(1)O(1) 的时间复杂度判断这个数是否被选择过，这是一种“以空间换时间”的思想。<br>
我们把这两个变量称之为“状态变量”，它们表示了我们在求解一个问题的时候所处的阶段。<br>
4、在非叶子结点处，产生不同的分支，这一操作的语义是：在还未选择的数中依次选择一个元素作为下一个位置的元素，这显然得通过一个循环实现。<br>
5、另外，因为是执行深度优先遍历，从较深层的结点返回到较浅层结点的时候，需要做“状态重置”，即“回到过去”、“恢复现场”，我们举一个例子。<br>
从 [1, 2, 3] 到 [1, 3, 2] ，深度优先遍历是这样做的，从 [1, 2, 3] 回到 [1, 2] 的时候，需要撤销刚刚已经选择的数 3，因为在这一层只有一个数 3 我们已经尝试过了，因此程序回到上一层，需要撤销对 2 的选择，好让后面的程序知道，选择 3 了以后还能够选择 2。<br>
这种在遍历的过程中，从深层结点回到浅层结点的过程中所做的操作就叫“回溯”</p>
</blockquote>
<blockquote>
<p>下面我们就来看看代码应该如何编写：<br>
参考代码 1：（注意：这个代码是错误的，希望读者能自己运行一下测试用例自己发现原因，然后再阅读后面的内容）</p>
</blockquote>
<pre><code>import java.util.ArrayList;
import java.util.List;


public class Solution {

    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {
        // 首先是特判
        int len = nums.length;
        // 使用一个动态数组保存所有可能的全排列
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();

        if (len == 0) {
            return res;
        }

        boolean[] used = new boolean[len];
        List&lt;Integer&gt; path = new ArrayList&lt;&gt;();

        dfs(nums, len, 0, path, used, res);
        return res;
    }

    private void dfs(int[] nums, int len, int depth,
                     List&lt;Integer&gt; path, boolean[] used,
                     List&lt;List&lt;Integer&gt;&gt; res) {
        if (depth == len) {
            res.add(path);
            return;
        }

        for (int i = 0; i &lt; len; i++) {
            if (!used[i]) {
                path.add(nums[i]);
                used[i] = true;

                dfs(nums, len, depth + 1, path, used, res);
                // 注意：这里是状态重置，是从深层结点回到浅层结点的过程，代码在形式上和递归之前是对称的
                used[i] = false;
                path.remove(depth);
            }
        }
    }

    public static void main(String[] args) {
        int[] nums = {1, 2, 3};
        Solution solution = new Solution();
        List&lt;List&lt;Integer&gt;&gt; lists = solution.permute(nums);
        System.out.println(lists);
    }
}
</code></pre>
<blockquote>
<p>这段代码在运行的时候输出如下：<br>
[[], [], [], [], [], []]<br>
原因出现在递归终止条件这里：<br>
if (depth == len) {<br>
res.add(path);<br>
return;<br>
}<br>
path 这个变量所指向的对象在递归的过程中只有一份，深度优先遍历完成以后，因为回到了根结点（因为我们之前说了，从深层结点回到浅层结点的时候，需要撤销之前的选择），因此 path 这个变量回到根结点以后都为空。<br>
在 Java 中，因为都是值传递，对象类型变量在传参的过程中，复制的都是变量的地址。这些地址被添加到 res 变量，但实际上指向的是同一块内存地址，因此我们会看到 6 个空的列表对象。解决的方法很简单，在 res.add(path); 这里做一次拷贝即可。<br>
修改的部分：</p>
</blockquote>
<pre><code>Java
if (depth == len) {
    res.add(new ArrayList&lt;&gt;(path));
    return;
}
</code></pre>
<blockquote>
<p>此时再提交到「力扣」上就能得到一个 Accept 了。<br>
希望大家能够通过这个例子理解“回溯”这个方法在搜索问题中起到的作用。<br>
下面我们对这一版的代码做以下几个说明：<br>
1、如果在每一个非叶子结点分支的尝试，我都创建新的变量表示状态，那么不需要“回溯”，在递归终止的时候，也不需要做拷贝。这样的做法虽然可以得到解，但同时会创建很多中间变量，这些中间变量很多时候是我们不需要的，会有一定空间和时间上的消耗。</p>
</blockquote>
<blockquote>
<p>为了验证上面的说明，我们写如下代码进行实验：<br>
参考代码 2：</p>
</blockquote>
<pre><code>Java
import java.util.ArrayList;
import java.util.List;

public class Solution {

    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {
        // 首先是特判
        int len = nums.length;
        // 使用一个动态数组保存所有可能的全排列
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();

        if (len == 0) {
            return res;
        }


        boolean[] used = new boolean[len];
        List&lt;Integer&gt; path = new ArrayList&lt;&gt;();

        dfs(nums, len, 0, path, used, res);
        return res;
    }

    private void dfs(int[] nums, int len, int depth,
                     List&lt;Integer&gt; path, boolean[] used,
                     List&lt;List&lt;Integer&gt;&gt; res) {
        if (depth == len) {
            // 3、不用拷贝，因为每一层传递下来的 path 变量都是新建的
            res.add(path);
            return;
</code></pre>
<blockquote>
<p>这就好比我们在实验室里做对比实验，每一个步骤的尝试都要保证使用的材料是一样的。为此有两种办法：<br>
（1）每做完一种尝试，都把实验材料恢复成做上一个实验之前的样子，只有这样做出的对比才有意义；<br>
（2）每一次尝试都使用同样的新的材料做实验。<br>
只不过很多时候，做实验对材料有破坏性。不过在计算机的世界里，“恢复现场”和“回到过去”是相对容易的。<br>
在一些字符串的“回溯”问题中，有些时候不需要回溯就是这个原因，因为字符串变量在拼接的过程中会产生新的对象（针对 Java 和 Python 语言，其它语言我并不清楚）。<br>
如果你使用 Python 语言，会知道有这样一种语法：[1, 2, 3] + [4] 也是创建了一个新的列表对象，我们已经在“参考代码 2”中展示这种写法。<br>
2、也可以不使用 used 数组，在遍历的过程中，对于一个数是否使用过，就得遍历 path 里的每一个元素，这个操作的时间复杂度是 O(N)O(N)，一般情况下，没有必要节约这个空间。<br>
3、ArrayList 是 Java 中的动态数组，Java 建议我们如果一开始就知道这个集合里需要保存元素的大小，可以在初始化的时候直接传入。<br>
在 res 变量初始化的时候，最好传入 len 的阶乘。<br>
在 path 变量初始化的时候，可以传入 len 。<br>
4、path 变量我们发现只是对它的末尾位置进行增加和删除的操作，显然它是一个栈，因此，使用栈语义会更清晰。但同时 Stack 这个类的文档我们，由于一些设计上的问题，建议我们使用：<br>
<code>Deque&lt;Integer&gt; stack = new ArrayDeque&lt;Integer&gt;();</code><br>
这一点让我很奔溃，Deque 是双端队列，它提供了更灵活的接口，同时破坏了语义，一不小心，如果用错了接口，就会导致程序错误。我采用的做法是接收官方的建议，在程序变量命名和使用的接口时让语义尽量清晰：<br>
这里 path 我需要表示它是从根结点到叶子结点的路径，我认为这个语义更重要，因此不改名为 stack。而在末尾添加元素和删除元素的时候，分别使用 addLast() 和 removeLast()<br>
方法强调只在末尾操作。<br>
5、布尔数组在这题里的作用是判断某个位置上的元素是否已经使用过。有两种等价的替换方式：</p>
</blockquote>
<blockquote>
<p>（1）哈希表；<br>
参考代码 3：</p>
</blockquote>
<pre><code>JavaPython
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class Solution {

    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {
        int len = nums.length;

        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(factorial(len));
        if (len == 0) {
            return res;
        }

        // 使用哈希表检测一个数字是否使用过
        Set&lt;Integer&gt; used = new HashSet&lt;&gt;(len);
        Deque&lt;Integer&gt; path = new ArrayDeque&lt;&gt;(len);

        dfs(nums, len, 0, path, used, res);
        return res;
    }

    private int factorial(int n) {
        int res = 1;
        for (int i = 2; i &lt;= n; i++) {
            res *= i;
        }
        return res;
    }

    private void dfs(int[] nums, int len, int depth,
                     Deque&lt;Integer&gt; path, Set&lt;Integer&gt; used,
                     List&lt;List&lt;Integer&gt;&gt; res) {
        if (depth == len) {
            res.add(new ArrayList&lt;&gt;(path));
            return;
        }

        for (int i = 0; i &lt; len; i++) {
            if (!used.contains(i)) {
                used.add(i);
                path.addLast(nums[i]);

                dfs(nums, len, depth + 1, path, used, res);

                path.removeLast();
                used.remove(i);
            }
        }
    }
}
</code></pre>
<blockquote>
<p>（2）位掩码，即使用一个整数表示布尔数组。此时可以将空间复杂度降到 O(1)（不包括 path 变量和 res 变量）。<br>
参考代码 4：</p>
</blockquote>
<pre><code>JavaPython
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.List;


public class Solution {

    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {
        int len = nums.length;
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(factorial(len));
        if (len == 0) {
            return res;
        }

        int used = 0;
        Deque&lt;Integer&gt; path = new ArrayDeque&lt;&gt;(len);
        dfs(nums, len, 0, path, used, res);
        return res;
    }

    private int factorial(int n) {
        int res = 1;
        for (int i = 2; i &lt;= n; i++) {
            res *= i;
        }
        return res;
    }

    private void dfs(int[] nums, int len, int depth,
                     Deque&lt;Integer&gt; path, int used,
                     List&lt;List&lt;Integer&gt;&gt; res) {
        if (depth == len) {
            res.add(new ArrayList&lt;&gt;(path));
            return;
        }

        for (int i = 0; i &lt; len; i++) {
            if (((used &gt;&gt; i) &amp; 1) == 0) {
                path.addLast(nums[i]);
                used ^= (1 &lt;&lt; i);

                dfs(nums, len, depth + 1, path, used, res);
                used ^= (1 &lt;&lt; i);
                path.removeLast();
            }
        }
    }
}
</code></pre>
<blockquote>
<p>总结<br>
下面思考一个问题，为什么得使用深度优先遍历？下面是我给出的答案。<br>
1、状态空间很大，如果每一个状态都去创建新的变量，消耗很大。<br>
就这本题，我们只需要叶子结点的那个状态。在候选数比较多的时候，我们在非叶子结点上创建新的状态变量的性能消耗就很严重。<br>
2、深度优先遍历的好处是：不同状态之间的切换很容易，想一想这个遍历的过程，每两个状态之间的差别只有 1 处，因此回退非常方便，这也正是“回溯”这个技巧可以用于搜索的原因。<br>
3、如果使用广度优先遍历，从浅层转到深层，状态的变化就很大，此时我们不得不在每一个状态都新建变量去保存它，从性能来说是不划算的。<br>
使用深度优先遍历，我们是直接使用了系统栈，系统栈帮助我们保存了每一个结点的状态信息。于是我们不用编写结点类，不必手动编写栈完成深度优先遍历。广度优先遍历就得使用队列，然后编写结点类。<br>
大家可以尝试使用广度优先遍历实现一下，就能体会到这一点。<br>
4、由于回溯算法的时间复杂度很高，因此，如果我们在遍历的时候，如果能够提前知道这一条分支不能搜索到满意的结果，就可以提前结束，这一步操作称之为剪枝。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UNP-UNIX网络编程 第一章]]></title>
        <id>https://lixin-ee.github.io//post/unp-unix-wang-luo-bian-cheng-di-yi-zhang</id>
        <link href="https://lixin-ee.github.io//post/unp-unix-wang-luo-bian-cheng-di-yi-zhang">
        </link>
        <updated>2020-01-05T14:45:05.000Z</updated>
        <content type="html"><![CDATA[<p>贯通全文的要点：一般认为Web服务器程序是一个长时间运行的程序（即所谓的守护程序daemon）, 它只在响应来自网络的请求时才发送网络消息。</p>
<ul>
<li>客户端代码解析<br>
源代码很长我就不贴了，只贴重点部分。<br>
<code>sockfd = socket(AF_INET， SOCK_STREAM, 0)</code><br>
socket函数创建一个网际（AF_INET）字节流（SOCK_STREAM）套接字</li>
</ul>
<pre><code>  bzero(&amp;servaddr, sizeof(servaddr))；  
	servaddr. sin_family = AF_INET; 
	servaddr.sin_port = htons(13)；
</code></pre>
<p>把服务器的IP地址和端口号填入一个网际套接字地址结构（一个名为servaddr的 sockaddr_in结构变量）。使用bzero把整个结构清零后，置地址族为AF_INET,端口号 为13 （这是时间获取服务器的众所周知端口，支持该服务的任何TCP/IP主机都使用这个端口号）</p>
<p><code>inet_pton(AF.INET, argv[1], &amp;servaddr.sin_addr);</code><br>
IP地址为第一个命令行参数的值（argv[1]）.网际套接字地址结构 中IP地址和端口号这两个成员必须使用特定格式，为此我们调用库函数htons （&quot;主机到 网络短整数&quot;）去转换二进制端口号，又调用库函数inet_pton （&quot;呈现形式到数值&quot;）去 把ASCII命令行参数（例如运行本例子所用的206.168.112.96）转换为合适的格式</p>
<p><code>connect(sockfd, (SA * ) &amp;servaddr, sizeof(servaddr);</code><br>
connect函数应用于一个TCP套接字时，将与由它的第二个参数指向的套接字地址结构读入并输出服务器的应答</p>
<pre><code>n = read(sockfd, recvline, MAXLINE);
fputs(recvline, stdout);
</code></pre>
<p>使用read函数读取服务器的应答，并用标准的I/O函数fputs输出结果。使用TCP 时必须小心，因为TCP是一个没有记录边界的字节流协议（粘包现象，应该由应用层自己来确定边界）</p>
<ul>
<li>
<p>协议无关性<br>
注意本次学习中出于实际工程的情况，我只考虑IPV4，不考虑IPV6，所以不考虑代码的协议无关性，专注于IPV4</p>
</li>
<li>
<p>包裹函数<br>
个别情况下，当这些函数返回错误时，我们想做的事并非简单 地终止程序的运行，我们必须检查系统调用是否被中断了。<br>
既然发生错误时终止程序的运行是普遍的情况，我们可以通过定义包裹函数(wrapper fimction)来缩短程序。每个包裹函数完成实际的函数调用，检查返回值，并在发生错误时终止 进程。我们约定包裹函数名是实际函数名的首字母大写形式。</p>
</li>
</ul>
<p>线程函数 遇到错误时并不设置标准Unix的errno变量 每次调用以pthread_开头的某个函数时，我们必须分配一个变量来存放函数返回值，以便在调用err_sys前把errno变量设置成该值</p>
<p>这个想法挺不错的， 主要是可以精简代码，代价就是工程量比较大，琐碎的工作比较多。</p>
<ul>
<li>Unix errno 值<br>
只要一个Unix函数(例如某个套接字函数)中有错误发生，全局变量errno就被置为一个 指明该错误类型的正值，函数本身则通常返回-1. err_sys查看errno。变量的值并输出相应的出 错消息<br>
errno的值只在函数发生错误时设置。如果函数不返回1错误，errno的值就没有定义。<br>
errno 的所有正数错误值都是常值，具有以&quot;E&quot;开头的全大写字母名字，并通常在&lt;sys/errno.n&gt; 头文件中定义。值0不表示任何错误。<br>
在全局变量中存放errno。值对于共享所有全局变量的多个线程并不适合。<br>
书中的函数返回是指 函数返回一个错误(通常函数返回值为-1),同时errno被置为指定的常值。</li>
</ul>
<p>服务器端代码解析：<br>
<code>listenfd = Socket(AF_INET, SOCK_STREAM, 0);</code><br>
TCP套接字的创建与客户程序相同</p>
<pre><code>servaddr.sin_f amily = AF_INET；
servaddr.sin_addr.s_addr = htonl(INADDR_ANY)；
servaddr.sin_port = hcons(13);	/* daytime server */

Bind(listenfd, (SA *) &amp;servaddr, sizeof(servaddr))；
</code></pre>
<p>通过填写一个网际套接字地址结构并调用bind函数，服务器的众所周知端口(对于时间获取服务是13，被捆绑到所创建的套接字。我们指定IP地址为INADDR_ANY,这样要是服务器主机有多个网络接口，服务器进程就可以在任意网络接口上接受客户连接。</p>
<pre><code>Listen(listenfd, LISTENQ)；
</code></pre>
<p>调用listen函数把该套接字转换成一个监听套接字。<br>
socket、bind和listen这3个调用步骤是任何TCP服务器准 备所谓的监听描述符(listening descriptor,本例中为listenfd)的正常步骤。<br>
常值LISTENQ在unp.h头文件中定义。它指定系统内核允许在这个监听描述符上 排队的最大客户连接数。</p>
<p><code>connfd=Accept(listenfd, (SA *) ,NULL, NULL);</code><br>
服务器进程在accept调用中被投入睡眠，等待某个客户连接的到达并被 内核受。TCP连接使用所谓的三路握手(three-way handshake)来建立连接。握手完 毕时accept返回，<br>
其返回值是一个称为已连接描述符(connected descriptor)的新描述 符(本例中为connfd)，该描述符用于与新近连接的那个客户通信。accept为每个连接到本服务器的客户返回一个新描述符。</p>
<pre><code>ticks = time(NULL);
ctime(&amp;ticks)；
</code></pre>
<p>当前时间和日期是由库函数time返回的它实际上返回的是自Unix纪元即1970年1月1日0点0分0秒（国际标准时间）以来的秒数。下一个库函数ctime把该整数值转换成直观可读的时间格式</p>
<p><code>Close(connfd);</code><br>
服务器通过调用close关闭与客户的连接。</p>
<p><code>snprintf(buff, sizeof(buff),	&quot;%.24s\r\n&quot;,ctime(&amp;ticks));</code><br>
调用sprintf无法检查目的缓冲区是否溢出.相反，snprintf要求其第二个参数指定目的缓冲区的大小，因此可确保该缓冲区不溢出</p>
<p>迭代服务器：服务器需用较多时间服务每个客户，那么我们必须以某种方式重叠对各个客户的服务。对于每个客户它都迭代执 行一次。<br>
同时能处理多个客户的则是并发服务器。（注意区分并发和并行）</p>
<p>如果从shell命令行启动本例这样的一个服务器，我们也许想要它运行很长时间，因为服 务器往往在系统工作期间直运行。这要求我们往服务器程序中添加代码，以便它能够作为一个<strong>Unix守护进程（daemon）</strong> 运行。（能在后台运行且不跟任何终端关联的进程）</p>
<ul>
<li>
<p>osi模型<br>
有七层 应用层、表示层、会话层(前三者可合为应用层)、传输层、网络层、数据链路层、物理层<br>
分隔用户进程与内核的机制：顶上三层通常构成所谓的用户进程（user process）,底下四层却通常作为操作系统<strong>内核</strong>的一部分提供。</p>
</li>
<li>
<p>网络拓扑的发现<br>
(1)	netstat -ni<br>
提供网络接口的信息<br>
环回(loopback)接口称为lo。，以太网接口称为eth0。<br>
(2)	netstat -nr<br>
展示路由表，也是另一种确定接口的方法。我们通常指定-n标志以输出数值地址。它还给出默认路由器的IP地址。<br>
(3)ifconfig<br>
ifconfig 通过接口名字获得每个接口的详细信息。	<br>
linux % ifconfig eth0<br>
该命令给出了指定接口的<strong>IP地址、子网掩码和广播地址</strong>。其中的MULTICAST标志通常指明该接口所在主机支持多播。有些ifconfig的实现还提供-a标志，用于输出所有己配置接口的信息。<br>
(4)	ping<br>
找出本地网络中众多主机的IP地址，针对从上一步找到的本地接口的广播 地址执行命令。</p>
</li>
<li>
<p>1.11	64位体系结构<br>
64位系统：在每个进程内部可以由此使用更长的编址（寻址）长度（即64位指针），从而可以寻址很大的内存空间（超过2^32字节）<br>
64位模型意味着我们不能假设一个指针能存放在一个整数中。我们还必须 考虑位64模型对现有API的影响<br>
<img src="https://lixin-ee.github.io//post-images/1578300828241.png" alt=""><br>
ANSIC创造了size_t数据类型，它用于作为malloc的唯一参数（待分配的字节数），或者 作为read和write的第三个参数（待读或写的字节数）。在32位系统中size_t是一个32位值，但 是在64位系统中它必须是一个64位值，以便发挥更大寻址模型的优势。<br>
但实际上网络API并不需要使用64位的数据类型：套接字地址结构 的长度最多也就几百个字节，给XTI的结构成员使用long数据类型则是个错误。<br>
处理这些情况的办法是使用专门设计的数据类型。套接字API对套接字地址结构的长度使用<strong>socklen_t数据类型</strong></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Linux基础] Shell Scripts（鸟哥Linux第十二章）]]></title>
        <id>https://lixin-ee.github.io//post/linux-ji-chu-shell-scriptsniao-ge-linux-di-shi-er-zhang</id>
        <link href="https://lixin-ee.github.io//post/linux-ji-chu-shell-scriptsniao-ge-linux-di-shi-er-zhang">
        </link>
        <updated>2020-01-05T12:01:26.000Z</updated>
        <content type="html"><![CDATA[<p>shell正是后台开发岗位要求中的脚本语言之一，shell script 是利用 shell 的功能所写的一个『程序 (program)』，这个程序是使用纯文本文件，将一些 shell 的语法与指令(含外部指令)写在里面， 搭配正规表示法、管线命令与数据流重导向等功能，以达到我们所想要的处理目的。</p>
<p>注意！和调用<strong>系统调用</strong>的C或者C++不同，shell script相当于把平时用的命令组合起来<br>
注意区分<strong>函数</strong>和<strong>系统调用</strong>！！！函数一般指自己编写的，系统调用就是系统提供的<strong>接口</strong></p>
<ul>
<li>shell script 注意事项</li>
</ul>
<ol>
<li>指令的执行是从上而下、从左而右的分析与执行；</li>
<li>指令、选项与参数间的空白都会被忽略掉；</li>
<li>空白行也将被忽略掉，并且 tab按键同样视为空格键；</li>
<li>如果读取到一个 Enter 符号 (CR) ，就尝试开始执行该行 (或该串) 命令；<br>
<strong>注意！！！shell script不会检查整体语法错误，就算遇到错误的语句也会继续执行下去，所以正确的语句可以继续执行，不会中断。</strong></li>
<li>至于如果一行的内容太多，则可以使用『 [Enter] 』来延伸至下一行；</li>
<li>『 # 』可做为批注！任何加在 # 后面的资料将全部被视为批注文字而被忽略！</li>
</ol>
<ul>
<li>
<p>执行shell script<br>
1.直接指令下达： shell.sh 文件必须要具备可读与可执行 (rx) 的权限，然后：<br>
o  绝对路径：使用 /home/dmtsai/shell.sh 来下达指令；<br>
o  相对路径：假设工作目录在 /home/dmtsai/ ，则使用 ./shell.sh 来执行<br>
o  变量『PATH』功能：将 shell.sh 放在 PATH 指定的目录内，例如： ~/bin/<br>
2.以 bash 程序来执行：透过『 bash shell.sh 』或『 sh shell.sh 』来执行</p>
</li>
<li>
<p>script 撰写习惯（也是大部分代码文件应该养成的习惯）<br>
在每个 script 的文件头处记录好：<br>
script 的功能；<br>
script 的版本信息；<br>
script 的作者与联络方式；<br>
script 的版权宣告方式；<br>
script 的 History (历史纪录)；<br>
script 内较特殊的指令，使用『绝对路径』的方式来下达；<br>
script 运作时需要的环境变量预先宣告与设定。</p>
</li>
</ul>
<p>shell script常用的命令<br>
read 指令：在屏幕显示提示并读取键盘输入赋给变量<br>
例子：让使用者输入：1. first name 与 2. last name， 最后并且在屏幕上显示：『Your<br>
full name is: 』的内容：<br>
read -p &quot;Please input your first name: &quot; firstname # 提示使用者输入<br>
read -p &quot;Please input your last name: &quot; lastname # 提示使用者输入<br>
echo -e &quot;\nYour full name is: ${firstname} ${lastname}&quot; # 结果由屏幕输出</p>
<p>touch：利用变量批量新建文件<br>
例子：文件名后自动加上日期<br>
date1=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>d</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo>−</mo><mo>−</mo><mi>d</mi><mi>a</mi><mi>t</mi><mi>e</mi><msup><mo>=</mo><mo mathvariant="normal">′</mo></msup><mn>2</mn><mi>d</mi><mi>a</mi><mi>y</mi><mi>s</mi><mi>a</mi><mi>g</mi><msup><mi>o</mi><mo mathvariant="normal">′</mo></msup><mo>+</mo><mi>f</mi><mi>i</mi><mi>l</mi><mi>e</mi><mn>1</mn><mo>=</mo></mrow><annotation encoding="application/x-tex">(date --date=&#x27;2 days ago&#x27; +%Y%m%d) 
file1=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.835222em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord mathdefault">d</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mord mathdefault">d</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">s</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord mathdefault">o</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span></span></span>{filename}<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>d</mi><mi>a</mi><mi>t</mi><mi>e</mi><mn>2</mn></mrow><mi>t</mi><mi>o</mi><mi>u</mi><mi>c</mi><mi>h</mi><mi mathvariant="normal">&quot;</mi></mrow><annotation encoding="application/x-tex">{date2}
touch &quot;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord">2</span></span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord">&quot;</span></span></span></span>{file1}&quot;</p>
<p>简单的加减乘除（shellscript只支持整数运算）<br>
$((运算内容))<br>
比如echo $(( 13 % 3 ))<br>
记得先用 declare -i 声明变量为int</p>
<p>数值运算：透过 bc  计算 pi</p>
<ul>
<li>script  的执行方式差异</li>
</ul>
<ol>
<li>
<p>直接指令下达<br>
不论是绝对路径/相对路径还是 ${PATH} 内，或者是利用bash (或 sh) 来下达脚本时，script 都会使用一个<strong>新的 bash 环境</strong>来执行脚本内的指令<br>
重点在于：<strong>『当子程序完成后，在子程序内的各项变量或动作将会结束而不会传回到父程序中』</strong><br>
<img src="https://lixin-ee.github.io//post-images/1578227866696.png" alt=""></p>
</li>
<li>
<p>利用 source 来执行脚本：在父程序中执行<br>
<img src="https://lixin-ee.github.io//post-images/1578227923126.png" alt=""><br>
不注销系统而要让某<br>
些写入 ~/.bashrc 的设定生效时，需要使用『 source ~/.bashrc 』而不能使用『 bash ~/.bashrc 』</p>
</li>
</ol>
<ul>
<li>善用判断式</li>
<li>test条件判断<br>
例子：检查 /dmtsai 是否存在时<br>
如果用<code>test -e /dmtsai</code> 执行结果并不会显示任何讯息<br>
需要<code>test -e /dmtsai &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</code><br>
（注意！！！这里利用了&amp;&amp;和||右边的执行与否取决于左边的结果）<br>
-e 是测试一个『东西』在不在<br>
test选项<br>
1.关于某个档名的『文件类型』判断，如 test -e filename 表示存在否<br>
-e 该『档名』是否存在？(常用)<br>
-f 该『档名』是否存在且为文件(file)？(常用)<br>
-d 该『文件名』是否存在且为目录(directory)？(常用)<br>
-b 该『档名』是否存在且为一个 block device 装置？<br>
-c 该『档名』是否存在且为一个 character device 装置？<br>
-S 该『档名』是否存在且为一个 Socket 文件？<br>
-p 该『档名』是否存在且为一个 FIFO (pipe) 文件？<br>
-L 该『档名』是否存在且为一个连结档？</li>
</ul>
<p>2.关于文件的权限侦测，如 test -r filename 表示可读否 (但 root 权限常有例外)<br>
-r 侦测该档名是否存在且具有『可读』的权限？<br>
-w 侦测该档名是否存在且具有『可写』的权限？<br>
-x 侦测该档名是否存在且具有『可执行』的权限？<br>
-u 侦测该文件名是否存在且具有『SUID』的属性？<br>
-g 侦测该文件名是否存在且具有『SGID』的属性？<br>
-k 侦测该文件名是否存在且具有『Sticky bit』的属性？<br>
-s 侦测该档名是否存在且为『非空白文件』？</p>
<p>3.两个文件之间的比较，如： test file1 -nt file2<br>
-nt (newer than)判断 file1 是否比 file2 新<br>
-ot (older than)判断 file1 是否比 file2 旧<br>
-ef<br>
判断 file1 与 file2 是否为同一文件，可用在判断 hard link 的判定上。 主要意义在判<br>
定，两个文件是否均指向同一个 inode 哩！</p>
<p>4.关于两个整数之间的判定，例如 test n1 -eq n2<br>
-eq 两数值相等 (equal)<br>
-ne 两数值不等 (not equal)<br>
-gt n1 大于 n2 (greater than)<br>
-lt n1 小于 n2 (less than)<br>
-ge n1 大于等于 n2 (greater than or equal)<br>
-le n1 小于等于 n2 (less than or equal)</p>
<p>5.判定字符串的数据<br>
test -z string 判定字符串是否为 0 ？若 string 为空字符串，则为 true<br>
test -n string<br>
判定字符串是否非为 0 ？若 string 为空字符串，则为 false。<br>
注： -n 亦可省略<br>
test str1 == str2 判定 str1 是否等于 str2 ，若相等，则回传 true<br>
test str1 != str2 判定 str1 是否不等于 str2 ，若相等，则回传 false</p>
<p>6.多重条件判定，例如： test -r filename -a -x filename<br>
-a and)两状况同时成立！例如 test -r file -a -x file，则 file 同时具有 r 与 x 权限<br>
时，才回传 true。<br>
-o or)两状况任何一个成立！例如 test -r file -o -x file，则 file 具有 r 或 x 权限时，就可回传 true。! 反相状态，如 test ! -x file ，当 file 不具有 x 时，回传 true</p>
<p>由于 root 在很多权限的限制上面都是无效的，所以使用 root 执行这个脚本时， 常常会发现与 ls -l 观察到的结果并不相同</p>
<ul>
<li>利用判断符号 [ ]<br>
使用中括号必须要特别注意，因为中括号用在很多地方，包括通配符与正规表示法等等，所以如果要 在 bash 的语法当中使用中括号作为 shell 的判断式时，必须要注意中括号的两端<strong>需要有空格符来分隔</strong><br>
[□&quot;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mi>O</mi><mi>M</mi><mi>E</mi><mi mathvariant="normal">&quot;</mi><mi mathvariant="normal">□</mi><mo>=</mo><mo>=</mo><mi mathvariant="normal">□</mi><mi mathvariant="normal">&quot;</mi></mrow><annotation encoding="application/x-tex">HOME&quot;□==□&quot;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">&quot;</span><span class="mord">□</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">□</span><span class="mord">&quot;</span></span></span></span>MAIL&quot;□] 中□就是需要空格符的地方</li>
</ul>
<p>注意：<br>
在中括号内的每个组件都需要有空格键来分隔；<br>
在中括号内的变数，最好都以双引号括号起来；<br>
在中括号内的常数，最好都以单或双引号括号起来。</p>
<p>比如[ ${name} == &quot;VBird&quot; ]如果没有使用双引号刮起来，那么上面的判定式会变成[ VBird Tsai == &quot;VBird&quot; ]<br>
应该加上双引号变为[ &quot;VBird Tsai&quot; == &quot;VBird&quot; ]</p>
<p>中括号比较常用在条件 判断式<code>if ..... then ..... fi</code> 的情况中</p>
<ul>
<li>Shell script 的默认变数($0, $1...)<br>
透过指令后面接参数， 那一个shell script也能作为一个整体命令接受参数<br>
比如   /etc/init.d/network restart 重启network</li>
</ul>
<p>在script内部 针对参数已经有设定好一些变量名称<br>
<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;#&#039; at position 1: #̲ ：代表后接的参数『个数』，以…'># ：代表后接的参数『个数』，以上表为例这里显示为</span>#就是『 4 』；<br>
$@ ：代表『 &quot;$1&quot; &quot;$2&quot; &quot;$3&quot; &quot;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn><mi mathvariant="normal">&quot;</mi><mi mathvariant="normal">』</mi><mi mathvariant="normal">之</mi><mi mathvariant="normal">意</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">每</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">变</mi><mi mathvariant="normal">量</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">独</mi><mi mathvariant="normal">立</mi><mi mathvariant="normal">的</mi><mo>(</mo><mi mathvariant="normal">用</mi><mi mathvariant="normal">双</mi><mi mathvariant="normal">引</mi><mi mathvariant="normal">号</mi><mi mathvariant="normal">括</mi><mi mathvariant="normal">起</mi><mi mathvariant="normal">来</mi><mo>)</mo><mi mathvariant="normal">（</mi><mi mathvariant="normal">亦</mi><mi mathvariant="normal">即</mi><mi mathvariant="normal">全</mi><mi mathvariant="normal">部</mi><mi mathvariant="normal">变</mi><mi mathvariant="normal">量</mi><mi mathvariant="normal">）</mi><mi mathvariant="normal">；</mi></mrow><annotation encoding="application/x-tex">4&quot; 』之意，每个变量是独立的(用双引号括起来)（亦即全部变量）；
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mord">&quot;</span><span class="mord cjk_fallback">』</span><span class="mord cjk_fallback">之</span><span class="mord cjk_fallback">意</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">每</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">变</span><span class="mord cjk_fallback">量</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">独</span><span class="mord cjk_fallback">立</span><span class="mord cjk_fallback">的</span><span class="mopen">(</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">双</span><span class="mord cjk_fallback">引</span><span class="mord cjk_fallback">号</span><span class="mord cjk_fallback">括</span><span class="mord cjk_fallback">起</span><span class="mord cjk_fallback">来</span><span class="mclose">)</span><span class="mord cjk_fallback">（</span><span class="mord cjk_fallback">亦</span><span class="mord cjk_fallback">即</span><span class="mord cjk_fallback">全</span><span class="mord cjk_fallback">部</span><span class="mord cjk_fallback">变</span><span class="mord cjk_fallback">量</span><span class="mord cjk_fallback">）</span><span class="mord cjk_fallback">；</span></span></span></span>* ：代表『 &quot;$1c$2c$3c$4&quot; 』，其中 c 为分隔字符，默认为空格键， 所以本例中代表『 &quot;$1 $2 $3 $4&quot; 』 之意。</p>
<ul>
<li>
<p>shift：造成参数变量号码偏移<br>
shift 后面可以接数字，代表拿掉最前面的 几个参数的意思<br>
用于修改<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;#&#039; at position 1: #̲ 、'># 、</span>@ 和$* 代表的意思或内容</p>
</li>
<li>
<p>条件判断式</p>
</li>
</ul>
<ol>
<li>
<p>利用 if .... then<br>
&amp;&amp; 代表 AND ；<br>
|| 代表 or ；<br>
在使用中括号的判断式中， &amp;&amp; 及 || 就与指令下达的状态不同</p>
</li>
<li>
<p>多重、复杂条件判断式<br>
多个条件判断 (if ... elif ... elif ... else) 分多种不同情况执行<br>
if [ 条件判断式一  ]; then<br>
当条件判断式一成立时，可以进行的指令工作内容；<br>
elif [ 条件判断式二  ]; then<br>
当条件判断式二成立时，可以进行的指令工作内容；<br>
else<br>
当条件判断式一与二均不成立时，可以进行的指令工作内容；<br>
fi</p>
</li>
</ol>
<p>如果你不希望用户由键盘输入额外的数据时， 可以使用上一节提到的参数功能 ($1)，让用户在下达指令时就将参数带进去</p>
<p>利用『 netstat -tuln 』来取得目前主机有启动的服务<br>
『Local Address (本地主机的 IP 与端口口对应)』那个字段，他代表的是本机所启动的网络服务！ IP 的部分说明的是该服务位于那个接口上，若为 127.0.0.1 则是仅针对本机开放，若是0.0.0.0 或 ::: 则代表对整个 Internet 开放<br>
几个常见的 port 与相关网络服务的关系是：<br>
80: WWW<br>
22: ssh<br>
21: ftp<br>
25: mail<br>
111: RPC(远程过程调用)<br>
631: CUPS(打印服务功能)</p>
<p>透过 netstat 去侦测主机是否有开启主要的网络服务端口口：由于每个服务的关键词都是接在冒号『 : 』后面， 所以可以藉由撷取类似『 :80 』来侦测<br>
netstat -tuln &gt; <span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;#&#039; at position 12: {testfile} #̲ 先转存数据到内存当中，不用一…'>{testfile} # 先转存数据到内存当中，不用一直执行 netstat
testing=</span>(grep &quot;:80 &quot; ${testfile}) # 侦测 port 80</p>
<ul>
<li>利用 case ..... esac  判断<br>
case $变量名称  in       #关键词为 case ，还有变数前有钱字号<br>
&quot;第一个变量内容&quot;)      #每个变量内容建议用双引号括起来，关键词则为小括号 )<br>
程序段<br>
;;                         #每个类别结尾使用两个连续的分号来处理！<br>
&quot;第二个变量内容&quot;)<br>
程序段<br>
;;<br>
*  )                      #最后一个变量内容都会用 * 来代表所有其他值<br>
不包含第一个变量内容与第二个变量内容的其他程序执行段<br>
exit 1<br>
;;<br>
esac                           #最终的 case 结尾！『反过来写』思考一下！<br>
case (实际案例之意) 为开头，结尾就是将 case 的英文反过来写</li>
</ul>
<p>使用『 case $变量 in 』这个语法中，当中的那个『 $变量 』大致有两种取得的方式：<br>
直接下达式：例如上面提到的，利用『 script.sh variable 』 的方式来直接给予 $1 这个变量的内容，这也<br>
是在 /etc/init.d 目录下大多数程序的设计方式。<br>
交互式：透过 read 这个指令来让用户输入变量的内容。</p>
<ul>
<li>利用 function<br>
『函数 (function)』功能，函数可以在 shell script 当中做出一个类似自定义执行指令的东西<br>
function fname () {<br>
程序段<br>
}</li>
</ul>
<p>因为 shell script 的执行方式是由上而下，由左而右， 因此在 shell script 当中的 function 的设定<strong>一定要在程序的最前面</strong>，相当于C++需要定义在前面才能看得到<br>
unction 也是拥有内建变量的～他的内建变量与 shell script 很类似， 函数名称代表示 $0 ，而后续接的变量也是以 $1, $2... 来取代的<br>
但是注意 shell script 的 $1与 printit() 内的 $1 无关。<br>
在bash中下达指令时的第一个参数one并不会影响到printit的第一个参数，必须在script内部调用printit时添加第一个参数</p>
<ul>
<li>循环 (loop)<br>
循环可以不断的执行某个程序段落，直到用户设定的条件达成为止</li>
</ul>
<ol>
<li>
<p>while do done, until do done ( 不定循环)<br>
while [ condition  ] #中括号内的状态就是判断式<br>
do                            #do 是循环的开始！<br>
程序段落<br>
done                        #done 是循环的结束</p>
</li>
<li>
<p>for...do...done ( 固定循环)<br>
for var  in con1 con2 con3 ...<br>
do<br>
程序段<br>
done</p>
</li>
</ol>
<p>相对于 while, until 的循环方式是必须要『符合某个条件』的状态， for 这种语法，则是『 已经知道要进行几次循环』的状态<br>
注意！ $var 的变量内容在循环工作时： 第一次循环时， $var 的内容为 con1 ；<br>
第二次循环时， $var 的内容为 con2 ； 第三次循环时， $var 的内容为 con3 ；</p>
<ol start="3">
<li>for...do...done  的数值处理<br>
for (( 初始值; ; 限制值; ; 执行步阶  ))<br>
do<br>
程序段<br>
done</li>
</ol>
<p>初始值：某个变量在循环当中的起始值，直接以类似 i=1 设定好；<br>
限制值：当变量的值在这个限制值的范围内，就继续进行循环。例如 i&lt;=100；<br>
执行步阶：每作一次循环时，变量的变化量。例如 i=i+1。</p>
<ul>
<li>shell script  的追踪与 debug</li>
</ul>
<p>[dmtsai@study ~]$  sh [- - nvx] scripts.sh<br>
选项与参数：<br>
-n ：不要执行 script，仅查询语法的问题；（若语法没有问题，则不会显示任何信息）<br>
-v ：执行 sccript 前先将 scripts 的内容输出到屏幕上；（注意不是先输出全部内容，而是输出一句执行一句，所以结果跟在命令后面）<br>
-x ：将使用到的 script 内容显示到屏幕上，这是很有用的参数！</p>
<p>对于-v 在加号后面的数据其实都是指令串，由于 sh -x 的方式来将指令执行过程也显示出来， 如此用户可以判断程序代码执行到哪一段时会出现相关的信息，透过显示完整的指令串， 就能够依据输出的错误信息来订正脚本</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 59. 螺旋矩阵 II[中等][未做出]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-59-luo-xuan-ju-zhen-iizhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-59-luo-xuan-ju-zhen-iizhong-deng-wei-zuo-chu">
        </link>
        <updated>2020-01-05T03:23:37.000Z</updated>
        <content type="html"><![CDATA[<pre><code>给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。
示例:
输入: 3
输出:
[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]
</code></pre>
<p>先寻找一下规律吧<br>
我一开始的想法是通过x和y循环递增来完成这个目的<br>
1.循环结束的标志位添加的值是n^2<br>
2.需要标注好循环的尽头，比如一开始是i=0,j从0到n-1 接着j=n-1，i从0到n-1，所以i和j循环递增，并且需要保存i和j的信息 可以用一个bool指示谁来循环<br>
3.注意循环的尽头是在不断地缩小的，比如n=3的循环尽头分别为y=3 x=3 y=3 x=2 y=2 （注意这里不是下标，正常来说应该是下标）<br>
4.也就是说有n个n n-1个n-1直到最后<br>
5.编程中发现还得考虑++还是-- 那么情况就太复杂了<br>
我觉得还是看题解吧，自己写得太复杂了<br>
题解很巧妙，设置四个独立的边界，这四个边界各自四个循环，循环结束后就各自--，而不是像我那样用n来作循环的尽头<br>
我的问题在于老是希望找到规律，老是想用最少的现有元素解决，但是这样并不一定是最优解，有时候独立的变量更方便。</p>
<p>在循环内是不需要再判断value是否超出了值或者位置不正确，因为四个边界一定最后会缩到某个相交值，最后根本不会进入循环<br>
然后不需要用x和y，只用一个i就好，因为四个边界并非全是n</p>
<p>然后还有很多题解，值得细看一下</p>
<p>题解复现代码</p>
<pre><code>class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) {
        int value=1,ret=n*n;
        vector&lt;vector&lt;int&gt;&gt; res(n,vector&lt;int&gt;(n,0));
        int left=0,right=n-1,top=0,buttom=n-1;
        while(value&lt;=ret){
            for(int i=left;i&lt;=right;++i) res[top][i]=value++;
                ++top;
            for(int i=top;i&lt;=buttom;++i) res[i][right]=value++;
                --right;
            for(int i=right;i&gt;=left;--i) res[buttom][i]=value++;
                --buttom;
            for(int i=buttom;i&gt;=top;--i) res[i][left]=value++;
                ++left;
        }
        return res;
    }
};
</code></pre>
<p>然后来看看网友题解<br>
思路：<br>
生成一个 n×n 空矩阵 mat，随后模拟整个向内环绕的填入过程：<br>
定义当前左右上下边界 l,r,t,b，初始值 num = 1，迭代终止值 tar = n * n；<br>
当 num &lt;= tar 时，始终按照 从左到右 从上到下 从右到左 从下到上 填入顺序循环，每次填入后：<br>
执行 num += 1：得到下一个需要填入的数字；<br>
更新边界：例如从左到右填完后，上边界 t += 1，相当于上边界向内缩 1。<br>
使用num &lt;= tar而不是l &lt; r || t &lt; b作为迭代条件，是为了解决当n为奇数时，矩阵中心数字无法在迭代过程中被填充的问题。<br>
最终返回 mat 即可。</p>
<pre><code>class Solution {
    public int[][] generateMatrix(int n) {
        int l = 0, r = n - 1, t = 0, b = n - 1;
        int[][] mat = new int[n][n];
        int num = 1, tar = n * n;
        while(num &lt;= tar){
            for(int i = l; i &lt;= r; i++) mat[t][i] = num++; // left to right.
            t++;
            for(int i = t; i &lt;= b; i++) mat[i][r] = num++; // top to bottom.
            r--;
            for(int i = r; i &gt;= l; i--) mat[b][i] = num++; // right to left.
            b--;
            for(int i = b; i &gt;= t; i--) mat[i][l] = num++; // bottom to top.
            l++;
        }
        return mat;
    }
}
</code></pre>
<p>这里的变量名可以改进一下，然后注意其实是0和n-1，而不是1和n 同时每个变量所处的维度位置和需要递增递减的变量都需要注意一下</p>
<p>另外一种思路<br>
<img src="https://lixin-ee.github.io//post-images/1578195226700.png" alt=""></p>
<pre><code>class Solution:
    def generateMatrix(self, n: int) -&gt; List[List[int]]:
        r, n = [[n**2]], n**2
        while n &gt; 1: n, r = n - len(r), [[*range(n - len(r), n)]] + [*zip(*r[::-1])]
        return r
</code></pre>
<p>这个就有点抽象了。。。</p>
<p>剩下的方法就和第一个题解大同小异了，而且第一个题解改变更加清晰</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Linux基础] 正则表达式与文件格式化处理（鸟哥Linux第十一章）]]></title>
        <id>https://lixin-ee.github.io//post/linux-ji-chu-zheng-ze-biao-da-shi-yu-wen-jian-ge-shi-hua-chu-li-niao-ge-linux-di-shi-yi-zhang</id>
        <link href="https://lixin-ee.github.io//post/linux-ji-chu-zheng-ze-biao-da-shi-yu-wen-jian-ge-shi-hua-chu-li-niao-ge-linux-di-shi-yi-zhang">
        </link>
        <updated>2020-01-04T02:45:54.000Z</updated>
        <content type="html"><![CDATA[<p>正则表达式 (Regular Expression, RE, 或称为常规表示法)是透过一些特殊字符的排列，用以『搜寻/取代/删除』一列或多列文字字符串</p>
<p>原文中 正则表达式 用的是 正规表示法。。。台湾和大陆的差异还有点大啊，算了先用着吧、</p>
<p>『！ 正规表示法与通配符是完全不一样的东西！』 因为『通配符 (wildcard) 代表的是 bash 操作接口的一个功能』，但正规表示法则是一种字符串处理的表<br>
示方式</p>
<p>对字符排序有影响的语系数据就会对正规表示法的结果有影响，例如最简单的字符串撷取功能的工具程序 grep<br>
grep 在数据中查寻一个字符串时，是以 &quot;整行&quot; 为单位来 进行数据的撷取的</p>
<p>使用正规表示法时，需要特别留意当时环境的语系为何， 否则可能会发现与别人不相同的撷取结果，一般都是使用『 LANG=C 』这个语系数据来进行</p>
<p>特殊符号及代表意义<br>
[:alnum:]代表英文大小写字符及数字，亦即 0-9, A-Z, a-z<br>
[:alpha:]代表任何英文大小写字符，亦即 A-Z, a-z<br>
[:blank:]代表空格键与 [Tab] 按键两者<br>
[:cntrl:]代表键盘上面的控制按键，亦即包括 CR, LF, Tab, Del.. 等等<br>
[:digit:]代表数字而已，亦即 0-9<br>
[:graph:]除了空格符 (空格键与 [Tab] 按键) 外的其他所有按键<br>
[:lower:]代表小写字符，亦即 a-z<br>
[:print:]代表任何可以被打印出来的字符<br>
[:punct:]代表标点符号 (punctuation symbol)，亦即：&quot; ' ? ! ; : # $...<br>
[:upper:]代表大写字符，亦即 A-Z<br>
[:space:]任何会产生空白的字符，包括空格键, [Tab], CR 等等<br>
[:xdigit:]代表 16 进位的数字类型，因此包括： 0-9, A-F, a-f 的数字与字符<br>
注意！ [:lower:] 就是 a-z 的意思，那么 [a-z]就必须是 [[:lower:]] 有<strong>两层中括号</strong></p>
<p>中括号 [] 搜寻集合字符：[] 里面不论有几个字符，他都仅代表某『一个』字符<br>
例如t[abc]b 只需要abc中的一个<br>
^ 符号在字符集合符号(括号[])之内与之外是不同的！在 [] 内代表『反向选择』，在 [] 之外则代表定位在行首的意义</p>
<p>通配符 * 可以用来代表任意(0 或多个)字符， 但是正规表示法并不是通配符，两者之间是不相同的， 至于正规表示法当中的『 . 』则代表『绝对有一个任意字符』意<br>
思<br>
. (小数点)：代表『一定有一个任意字符』的意思；<br>
* (星星号)：代表『重复前一个字符， 0 到无穷多次』的意思，为组合形态<br>
（例如『o*』代表的是：『拥有空字符或一个 o 以上的字符』，『oo*』则第一个 o 肯定必须要存在，第二个 o 则是可有可无的多个 o ）<br>
<em><em>所以： 『.</em> 就代表零个或多个任意字符』</em>*</p>
<p>限定范围的字符 {}：限制一个范围区间内的重复字符数<br>
但是！！因为 { 与 } 的符号在 shell 是有特殊意义的，因此， 我们必须要使用跳脱字符 \ 来让他失去特殊意义才行<br>
例如 o{2 }  就是寻找两个哦，亦即oo<br>
基础正规表示法字符汇整 (characters)：<br>
<img src="https://lixin-ee.github.io//post-images/1578107463139.png" alt=""><br>
<img src="https://lixin-ee.github.io//post-images/1578107499111.png" alt=""></p>
<p>『正规表示法的特殊字符』与一般在指令列输入指令的『通配符』并不相同</p>
<ul>
<li>
<p>sed  工具<br>
sed 本身也是一个管线命令，可以分析 standard input 的， 而且 sed还可以将数据进行取代、删除、新增、撷取特定行等等的功能</p>
</li>
<li>
<p>以行为单位的新增/删除功能<br>
nl /etc/passwd | sed '2,5d'   d 就是删除，删除 2-5 行<br>
nl /etc/passwd | sed '2a wordtoadd' a就是增加<br>
sed 后面接的动作，请务必以 '' 两个单引号括住<br>
可以用	钱字号『 $ 』代表最后一行，比如删除第 3 到最后一行，则是『 nl /etc/passwd | sed '3,$d' 』</p>
</li>
<li>
<p>以行为单位的取代与显示功能<br>
sed 's/要被取代的字符串/ /新的字符串/g'<br>
注意，实际中文件是没有被删除内容的，只是打印出来的内容被删除<br>
例如<br>
<code>/sbin/ifconfig eth0 | grep 'inet ' | sed 's/^.*inet //g' &gt; | sed 's/ *netmask.*$//g'</code><br>
将inet 192.168.1.100 netmask 255.255.255.0 broadcast 192.168.1.255<br>
删除成 192.168.1.100</p>
</li>
<li>
<p>直接修改文件内容( 危险动作)<br>
sed 甚至可以直接修改文件的内容呢！而不必使用管线命令或数据流重导向<br>
<code>[dmtsai@study ~]$ sed -i 's/\ \ .$/\ \ !/g' regular_express.txt</code><br>
上头的 -i 选项可以让你的 sed 直接去修改后面接的文件内容而不是由屏幕输出</p>
</li>
</ul>
<p>sed 的『 -i 』选项可以直接修改文件内容，这功能非常有帮助！举例来说，如果你有一个 100 万行 的文件，你要在第 100 行加某些文字，此时使用 vim 可能会疯掉！因为文件太大了！那怎办？就利 用 sed 啊！透过 sed 直接修改/取代的功能，你甚至不需要使用 vim 去修订</p>
<ul>
<li>延伸正规表示法<br>
grep 预设仅支持基础正规表示法，如果要使用延伸型正规表示法， 你可以使用 grep -E ， 不过更建议直接使用 egrep<br>
<img src="https://lixin-ee.github.io//post-images/1578110335511.png" alt=""><br>
<img src="https://lixin-ee.github.io//post-images/1578110355894.png" alt=""></li>
</ul>
<blockquote>
<p>要特别强调的是，那个 ! 在正规表示法当中 并不是特殊字符， 所以，如果你想要查出来文件中含有 ! 与 &gt; 的字行时，可以这样： grep -n '[!&gt;]' regular_express.txt 这样可以了解了吗？常常看到有陷阱的题目写：『反向选择这样对否？ '[!a-z]'？』， 呵呵！是错的 呦～要 '[^a-z] 才是对的</p>
</blockquote>
<p>11.4 文件的格式化与相关处理<br>
11.4.1 格式化打印： printf<br>
打印格式管理员 printf ，printf 可以帮我们将资料输出的结果格式化，而 且而支持一些特殊的字符</p>
<p>打印格式管理员 printf<br>
选项与参数：<br>
关于格式方面的几个特殊样式：<br>
\a 警告声音输出<br>
\b 退格键(backspace)<br>
\f 清除屏幕 (form feed)<br>
\n 输出新的一行<br>
\r 亦即 Enter 按键<br>
\t 水平的 [tab] 按键<br>
\v 垂直的 [tab] 按键<br>
\xNN NN 为两位数的数字，可以转换数字成为字符。<br>
关于 C 程序语言内，常见的变数格式<br>
%ns 那个 n 是数字， s 代表 string ，亦即多少个字符；<br>
%ni 那个 n 是数字， i 代表 integer ，亦即多少整数字数；<br>
%N.nf 那个 n 与 N 都是数字， f 代表 floating (浮点)，如果有小数字数，<br>
假设我共要十个位数，但小数点有两位，即为 %10.2f</p>
<p>awk<br>
sed 常常作用于一整个行的处理， awk 则比较倾向<br>
于一行当中分成数个『字段』来处理。因此，awk 相当的适合处理小型的数据数据处理<br>
[dmtsai@study ~]$  awk ' 条件类型型1{ 动作1}  条件类型2{ 动作2} ...' filename</p>
<p>awk 后面接两个单引号并加上大括号 {} 来设定想要对数据进行的处理动作。 awk 可以处理后续接的文件，也可以读取来自前个指令的 standard output 。 但如前面说的，<strong>awk 主要是处理『每一行的字段内的数据』，而默认的『字段的分隔符为 &quot;空格键&quot; 或 &quot;[tab]键&quot; 』！</strong> 举例来说，我们用 last 可以将登入者的数据取出来，  last -n 5 | awk '{print $1 &quot; \t&quot; $3}'<br>
在 awk 的括号内，每一行的每个字段都是有变量名称的，那就是 $1, $2... 等变量名称，$0 代表『一整 列资料』的意思，$3是第三栏</p>
<p>整个 awk 的处理流程是：</p>
<ol>
<li>读入第一行，并将第一行的资料填入 $0, $1, $2.... 等变数当中；</li>
<li>依据 &quot;条件类型&quot; 的限制，判断是否需要进行后面的 &quot;动作&quot;；</li>
<li>做完所有的动作与条件类型；</li>
<li>若还有后续的『行』的数据，则重复上面 1~3 的步骤，直到所有的数据都读完为止。 经过这样的步骤，你会晓得， awk 是『以行为一次处理的单位』， 而『以字段为最小的处理单位』</li>
</ol>
<ul>
<li>
<p>文件比对工具<br>
文件的比对：通常是『同一个软件包的不同版本之间，比较配置文件与原始档的差 异』</p>
</li>
<li>
<p>diff<br>
diff 通常是用在同一的文件(或软件)的新旧版本差异上<br>
[dmtsai@study ~]$  diff [-bBi]  from_file to_file<br>
选项与参数：<br>
from-file ：一个档名，作为原始比对文件的档名；<br>
to-file ：一个档名，作为目的比对文件的档名；<br>
注意，from-file 或 to-file 可以 - 取代，那个 <strong>- 代表『Standard input』之意</strong>。<br>
-b ：忽略一行当中，仅有多个空白的差异(例如 &quot;about me&quot; 与 &quot;about me&quot; 视为相同<br>
-B ：忽略空白行的差异。<br>
-i ：忽略大小写的不同。</p>
</li>
</ul>
<p>要用 diff 去比对两个完全不相干的文件，因为比不出个啥！<br>
diff 也可以比对整个目录下的差异</p>
<ul>
<li>cmp<br>
cmp 主要也是在比对两个文件，主要利用『字节』单位去比<br>
diff 主要是<br>
以『行』为单位比对， cmp 则是以『字节』为单位去比对，这并不相同</li>
</ul>
<p>[dmtsai@study ~]$  cmp [-l] file1 file2<br>
选项与参数：<br>
-l ：将所有的不同点的字节处都列出来。因为 cmp 预设仅会输出第一个发现的不同点。</p>
<ul>
<li>patch<br>
『将旧的文件升级成为新的文件』-&gt;『先比较先旧版本的差异，并将差异档制作成为补丁档，再由补丁档更新旧文件』<br>
所以patch要配合diff使用（使用 diff 制作出来的比较文件通常使用扩展名为 .patch ）<br>
更新[dmtsai@study ~]$  patch -pN &lt; patch_file<br>
还原[dmtsai@study ~]$  patch -R -pN &lt; patch_file<br>
选项与参数：<br>
-p ：后面可以接『取消几层目录』的意思。<br>
-R ：代表还原，将新的文件还原成原来旧的版本。</li>
</ul>
<p>如果是使用整体目录比对 (diff 旧目录 新目录) 时， 就得要依据建立 patch 文件所在目录来进行目录的删减</p>
<ul>
<li>文件 打印准备： pr<br>
在 Linux 底下打印纯文本档、标题、加入页码等需要pr功能</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 78. 子集[中等][回溯][未做出]]]></title>
        <id>https://lixin-ee.github.io//post/shu-zu-78-zi-ji-zhong-deng-hui-su</id>
        <link href="https://lixin-ee.github.io//post/shu-zu-78-zi-ji-zhong-deng-hui-su">
        </link>
        <updated>2020-01-04T01:22:55.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。<br>
说明：解集不能包含重复的子集。<br>
示例:<br>
输入: nums = [1,2,3]<br>
输出:<br>
[<br>
[3],<br>
  [1],<br>
  [2],<br>
  [1,2,3],<br>
  [1,3],<br>
  [2,3],<br>
  [1,2],<br>
  []<br>
]<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/subsets<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>【未做出】<br>
我的想法是循环数组，每遇到一个数n，就把1，2，3...到n之间的数组添加进结果里面，比如1,2,3...n、2,3...n、3...n直至n-1,n和n就结束了<br>
然后空集最好单独加进去<br>
然后我想用迭代器添加，注意迭代器的范围都是左闭右开的！所以右区间是nums.begin()+i+1<br>
傻逼了，这种方法没法添加[1,3]这种情况啊，只是给出了有序子集而已<br>
时间复杂度比较高，但是暂时没想出来可以怎么优化<br>
没想出来，省点时间看题解吧，其实发现题解还是蛮简单的，还是自己做题量不够啊<br>
比如可以直接遍历，遇到一个数就把旧子集加上该数组成新的子集再和旧子集合并，遍历完毕即是所有子集<br>
然后遇到一个很搞笑的问题，在下面的循环中，我遍历res，却又不断往res里面push_back，变相地无限循环了。。。</p>
<pre><code>            for(auto v:res){
                vector&lt;int&gt; temp=v;
                temp.push_back(nums[i]);
                res.push_back(temp);
            }   
</code></pre>
<p>然后我想尝试<code>res.push_back(res[j].push_back[nums[i]]);</code>直接翻车了，<br>
多看看其他题解吧唉</p>
<pre><code>class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) {
        vector&lt;vector&lt;int&gt;&gt; res;
        res.push_back(vector&lt;int&gt;());
        for(int i=0;i&lt;nums.size();++i){
            int len=res.size();
            for(int j=0;j&lt;len;++j){
                vector&lt;int&gt; temp=res[j];
                temp.push_back(nums[i]);
                res.push_back(temp);
            }         
        }
        return res;
    }
};
</code></pre>
<p>位运算实现：</p>
<pre><code>    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums){
        vector&lt;vector&lt;int&gt;&gt; res;
        int len=nums.size();
        if(len==0) return res;
        int n=1&lt;&lt;len;
        for(int i=0;i&lt;n;++i){
            vector&lt;int&gt; temp;
            for(int j=0;j&lt;len;++j){
                if((i&gt;&gt;j)&amp;1==1)
                    temp.push_back(nums[j]);
            }
            res.push_back(temp);
        }
        return res;
    }
</code></pre>
<p>回溯法实现</p>
<pre><code>     vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums){
        vector&lt;int&gt; temp;
        vector&lt;vector&lt;int&gt;&gt; res;
        if(nums.empty()) return res;
        subset_recur(nums,temp,res,0);
        return res;
    }
    
    void subset_recur(vector&lt;int&gt;&amp; nums,vector&lt;int&gt; temp,vector&lt;vector&lt;int&gt;&gt; &amp;res,int level){
        if(temp.size()&lt;=nums.size())
            res.push_back(temp);
        
        for(int i=level;i&lt;nums.size();++i){
            temp.push_back(nums[i]);
            subset_recur(nums,temp,res,i+1);//注意这里不是level+1，而是i+1！！！
            temp.pop_back();
        }
    }
</code></pre>
<pre><code>    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums){
        vector&lt;int&gt; temp;
        vector&lt;vector&lt;int&gt;&gt; res;
        if(nums.empty()) return res;
        subset_recur(nums,temp,res,0);
        return res;
    }
    
    void subset_recur(vector&lt;int&gt;&amp; nums,vector&lt;int&gt; temp,vector&lt;vector&lt;int&gt;&gt; &amp;res,int i){
        if(i==nums.size()){
            res.push_back(temp);
            return;
        }
        subset_recur(nums,temp,res,i+1);
        temp.push_back(nums[i]);
        subset_recur(nums,temp,res,i+1);
        return;
    }
</code></pre>
<p>然后看看网友题解：<br>
思路分析：<br>
这道题告诉我们整数数组 nums 不包含重复元素。因此作图，画出递归树结构是关键。<br>
因为是组合问题，所以我们按顺序读字符，就不需要设置 used 数组；<br>
经过分析，我们知道，在根结点、非叶子结点和叶子结点都需要结算，因此 res.apppend(path[:]) 就要放在“中间”位置。<br>
方法一：回溯<br>
回溯的过程是执行一次深度优先遍历，一条路走到底，走不通的时候，返回回来，继续执行，一直这样下去，直到回到起点。<br>
参考代码 1：在回溯的过程中记录结点。</p>
<pre><code>import java.util.ArrayList;
import java.util.List;


public class Solution {

    private List&lt;List&lt;Integer&gt;&gt; res;

    private void find(int[] nums, int begin, List&lt;Integer&gt; pre) {
        // 没有显式的递归终止
        res.add(new ArrayList&lt;&gt;(pre));// 注意：Java 的引用传递机制，这里要 new 一下
        for (int i = begin; i &lt; nums.length; i++) {
            pre.add(nums[i]);
            find(nums, i + 1, pre);
            pre.remove(pre.size() - 1);// 组合问题，状态在递归完成后要重置
        }
    }

    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {
        int len = nums.length;
        res = new ArrayList&lt;&gt;();
        if (len == 0) {
            return res;
        }
        List&lt;Integer&gt; pre = new ArrayList&lt;&gt;();
        find(nums, 0, pre);
        return res;
    }
}
</code></pre>
<p>参考代码 2：在回溯的过程中记录深度。</p>
<pre><code>import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

public class Solution {

    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {
        int size = nums.length;
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        if (size == 0) {
            return res;
        }
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        for (int i = 0; i &lt; size + 1; i++) {
            dfs(nums, 0, i, stack, res);
        }
        return res;
    }

    private void dfs(int[] nums, int start, int depth, Stack&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res) {
        if (depth == path.size()) {
            res.add(new ArrayList&lt;&gt;(path));
            return;
        }
        for (int i = start; i &lt; nums.length; i++) {
            path.add(nums[i]);
            dfs(nums, i + 1, depth, path, res);
            path.pop();
        }
    }

    public static void main(String[] args) {
        int[] nums = {1, 2, 3};
        Solution solution = new Solution();
        List&lt;List&lt;Integer&gt;&gt; subsets = solution.subsets(nums);
        System.out.println(subsets);
    }
}
</code></pre>
<p>在画树形图的时候，如果新看到的一个数选与不选，可以画出另一棵递归树，这样所有的组合就落在叶子结点处。<br>
<img src="https://lixin-ee.github.io//post-images/1578101463831.png" alt=""></p>
<pre><code>import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

/**
 * @author liweiwei1419
 * @date 2019/10/30 5:26 下午
 */
public class Solution8 {


    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        int len = nums.length;
        if (len == 0) {
            return res;
        }
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        dfs(nums, 0, len, stack, res);
        return res;
    }

    private void dfs(int[] nums, int index, int len,
                     Stack&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; res) {
        if (index == len) {
            res.add(new ArrayList&lt;&gt;(stack));
            return;
        }
        // 当前数可选，也可以不选

        // 不选，直接进入下一层
        dfs(nums, index + 1, len, stack, res);

        // 选了有，进入下一层
        stack.add(nums[index]);
        dfs(nums, index + 1, len, stack, res);
        stack.pop();
    }

    public static void main(String[] args) {
        int[] nums = {1, 2, 3};
        Solution8 solution7 = new Solution8();
        List&lt;List&lt;Integer&gt;&gt; subsets = solution7.subsets(nums);
        System.out.println(subsets);
    }
}
</code></pre>
<p>方法二：使用位掩码<br>
数组的每个元素，可以有两个状态：</p>
<p>1、不在子数组中（用 00 表示）；<br>
2、在子数组中（用 11 表示）。</p>
<p>从 0 到 2 的数组个数次幂（不包括）的整数的二进制表示就能表示所有状态的组合。</p>
<pre><code>import java.util.ArrayList;
import java.util.List;

public class Solution5 {

    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {
        int size = nums.length;
        int n = 1 &lt;&lt; size;
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();

        for (int i = 0; i &lt; n; i++) {
            List&lt;Integer&gt; cur = new ArrayList&lt;&gt;();
            for (int j = 0; j &lt; size; j++) {
                if (((i &gt;&gt; j) &amp; 1) == 1) {
                    cur.add(nums[j]);
                }
            }
            res.add(cur);
        }
        return res;
    }

    public static void main(String[] args) {
        int[] nums = {1, 2, 3};
        Solution5 solution5 = new Solution5();
        List&lt;List&lt;Integer&gt;&gt; subsets = solution5.subsets(nums);
        System.out.println(subsets);
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UNP-UNIX网络编程  配置开发环境]]></title>
        <id>https://lixin-ee.github.io//post/unp-unix-wang-luo-bian-cheng-pei-zhi-kai-fa-huan-jing</id>
        <link href="https://lixin-ee.github.io//post/unp-unix-wang-luo-bian-cheng-pei-zhi-kai-fa-huan-jing">
        </link>
        <updated>2020-01-03T12:59:57.000Z</updated>
        <content type="html"><![CDATA[<p>在读完UNIX后，在实现自己的项目之前打算把UNP里面的代码实现一遍<br>
因为看完30章之后觉得太经典了，而且目前来说把apue里面的函数从头到尾手工敲一遍不太合适（代码太散，容易遗忘），不如在实现UNP的过程中把APUE当作字典来参照，在使用函数的过程中了解函数</p>
<p>UNP第一步就是配置开发环境<br>
一开始我把作者的源代码下下来以为直接用unp.h头文件就完事了<br>
后来报错后谷歌了一下才发现原来是需要先make编译的，所以还是得先配置好环境，不用以后每次都要导入一堆头文件或者编写makefile<br>
然后作者的代码还是有一些小瑕疵，需要对照着网上的指引教程来逐步避坑和处理系统环境</p>
<p>原文是<a href="https://lightsing.github.io/2016/07/22/unp-v1-day01/">Unix网络编程 - V1 - Day 01</a></p>
<p>配置开发环境<br>
在这本书中，作者给出了大量的例程，为了方便后续的学习，我们要把一些书中引用的库编译出来并配置好编译环境。</p>
<p>这本经典之作的官网是 Unix Network Programming ，我们可以在Sorce Code页面下载到本书所用到的所有源码 点我下载</p>
<p>编译所需的库<br>
本例中的编译环境： gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.1) 建议编译前更新软件</p>
<p>下载并解压之后我们能看到非常多的文件，但是我们只需要编译其中的两个文件夹。</p>
<ol>
<li>
<p>使用 ./configure 配置并生成必要的头文件 config.h</p>
</li>
<li>
<p>进入 lib 目录，执行 make 编译。 这条命令会在上层目录下生成 libunp.a 库，此时的库还是不完整的，有一些函数在第二个文件夹中。</p>
</li>
<li>
<p>进入 ../libfree 目录，执行 make 编译，不出意外会出现如下提示：</p>
</li>
</ol>
<pre><code>gcc -I../lib -g -O2 -D_REENTRANT -Wall   -c -o in_cksum.o in_cksum.c
gcc -I../lib -g -O2 -D_REENTRANT -Wall   -c -o inet_ntop.o inet_ntop.c
inet_ntop.c: In function ‘inet_ntop’:
inet_ntop.c:60:9: error: argument ‘size’ doesn’t match prototype
  size_t size;
         ^
In file included from inet_ntop.c:27:0:
/usr/include/arpa/inet.h:64:20: error: prototype declaration
 extern const char *inet_ntop (int __af, const void *__restrict __cp,
                    ^
&lt;builtin&gt;: recipe for target 'inet_ntop.o' failed
make: *** [inet_ntop.o] Error 1
</code></pre>
<p>出错原因是数据类型错误，解决方法很简单：</p>
<p>打开 inet_ntop.c ，向其中添加一行，将本程序当中的 size_t 替换为 socklen_t<br>
<code>#define size_t socklen_t</code></p>
<p>重新执行 make ，输出结果如下，编译成功：</p>
<pre><code>gcc -I../lib -g -O2 -D_REENTRANT -Wall   -c -o inet_ntop.o inet_ntop.c
/usr/include/arpa/inet.h: In function ‘inet_ntop’:
inet_ntop.c:152:23: warning: ‘best.len’ may be used uninitialized in this function [-Wmaybe-uninitialized]
   if (best.base == -1 || cur.len &gt; best.len)
                       ^
inet_ntop.c:123:28: note: ‘best.len’ was declared here
  struct { int base, len; } best, cur;
                            ^
gcc -I../lib -g -O2 -D_REENTRANT -Wall   -c -o inet_pton.o inet_pton.c
ar rv ../libunp.a in_cksum.o inet_ntop.o inet_pton.o
a - in_cksum.o
a - inet_ntop.o
a - inet_pton.o
ranlib ../libunp.a
</code></pre>
<ol start="4">
<li>配置环境<br>
将编译好的 libunp.a （在上层目录）复制到 /usr/lib 和 /usr/lib64 中：</li>
</ol>
<pre><code>sudo cp libunp.a /usr/lib
sudo cp libunp.a /usr/lib64
</code></pre>
<p>修改 unp.h 中的 #include &quot;../config.h&quot; 修改为 #include &quot;config.h&quot; 并将 unp.h 和 config.h 拷贝至 /usr/include，方便日后引用</p>
<pre><code>sudo cp lib/unp.h /usr/include
sudo cp config.h /usr/include
</code></pre>
<ol start="5">
<li>到这里我们的环境就配置好了，如果你不准备使用IDE，那么下面一段内容可以跳过，编译调用 gcc 的方法如下：</li>
</ol>
<p><code>gcc example.c -o example -lunp</code><br>
-lunp 指的是调用库 unp ，即我们之前所编译的出的 libunp.a</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Linux基础] BASH（鸟哥Linux第十章）]]></title>
        <id>https://lixin-ee.github.io//post/linux-ji-chu-bashniao-ge-linux-di-jiu-zhang</id>
        <link href="https://lixin-ee.github.io//post/linux-ji-chu-bashniao-ge-linux-di-jiu-zhang">
        </link>
        <updated>2020-01-03T05:43:12.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>bash基础概念<br>
透过『 Shell 』将我们输入的指令与 Kernel 沟通，好让 Kernel 可以 控制硬件来正确无误的工作<br>
操作系统其实是一组软件，这组软件在控制整个 硬件与管理系统的活动监测<br>
应用程序其实是在最外层，就如同鸡蛋的外壳一样，因此这个咚咚也就 被称呼为壳程序 (shell)<br>
包括 man, chmod, chown, vi, fdisk, mkfs 等等指令，这些指 令都是独立的应用程序， 但是我们可以透过壳程序 (就是指令列模式) 来操作这些应用程序<br>
Bourne Again SHell (简称 bash) ，这个 Shell 是 Bourne Shell 的增强版本，也是基准于 GNU 的架构下发展出来的</li>
</ul>
<p>命令记忆 (history)<br>
~/.bash_history 记录的是前一次登入以前所执行过的指令， 而至于这一次登入所执行的指令都被暂 存在内存中，当你成功的注销系统后，该指令记忆才会记录到 .bash_history 当中</p>
<p>命令与 文件 补全功能： ([tab] 按键的好处)<br>
[Tab] 接在一串指令的第一个字的后面，则为命令补全；<br>
[Tab] 接在一串指令的第二个字以后时，则为『文件补齐』！</p>
<p>命令别名设定功能： (alias)</p>
<p>工作控制、前景背景控制： (job control, foreground, background)</p>
<p>程序化脚本： (shell scripts)</p>
<p>通配符： (Wildcard)</p>
<p>查询指令是否为 Bash shell 的内建命令： type<br>
file ：表示为外部指令；<br>
alias ：表示该指令为命令别名所设定的名称；<br>
builtin ：表示该指令为 bash 内建的指令功能；</p>
<p>指令的下达与快速编辑按钮<br>
跳脱：[Enter] 按键是紧接着反斜杠 () 的，两者 中间没有其他字符。 因为 \ 仅跳脱『紧接着的下一个字符』而已，顺利跳脱 [Enter] 后，下一行最前面就会主动出现 &gt; 的符号</p>
<p>[ctrl]+u/[ctrl]+k 分别是从光标处向前删除指令串 ([ctrl]+u) 及向后删除指令串 ([ctrl]+k)。  （同时会删除历史记录！！！）<br>
[ctrl]+a/[ctrl]+e 分别是让光标移动到整个指令串的最前面 ([ctrl]+a) 或最后面 ([ctrl]+e)。</p>
<ul>
<li>
<p>Shell 的变量功能<br>
变量：变量就是以一组文字或符号等，来取代 一些设定或者是一串保留的数据<br>
PATH环境变量就是一个变量，搜寻完 PATH 变量内的路径还找不到指令时， 就会在屏幕上显示『 command not found 』的错误 讯息了。</p>
</li>
<li>
<p>变量的取用与设定echo、变量设定规则 unset<br>
echo 这个指令来取用变量（<strong>不等同于新建变量</strong>）， 但是，变量在被取用时，前面 必须要加上钱字号『 $ 』，否则就是直接显示变量名</p>
</li>
</ul>
<p>『设定』（<strong>亦即新建</strong>）或者是『修改』，直接用『等号(=)』连接变量与他的内容<br>
在 bash 当中，当一个变量名称尚未被设定时，预设的内容是『空』的（亦即强心echo）<br>
但每一种 shell 的语法都不相同，在变量的使用上，bash 在你没有设定的变量中强迫去 echo 时，它会显示出空的值。 在其他某些 shell 中，随便去echo一个不存在的变量，它是会出现错误讯息的</p>
<ul>
<li>变量的设定规则</li>
</ul>
<ol>
<li>变量与变量内容以一个等号『=』来连结</li>
<li>等号两边不能直接接空格符</li>
<li>变量名称只能是英文字母与数字，但是开头字符不能是数字</li>
<li>变量内容若有空格符可使用双引号『&quot;』或单引号『'』将变量内容结合起来<br>
例外：1 双引号内的特殊字符如 $ 等，可以保有原本的特性<br>
2 单引号内的特殊字符则仅为一般字符 (纯文本)</li>
<li>可用跳脱字符『 \ 』将特殊符号(如 [Enter], $, , 空格符, '等)变成一般字符</li>
<li>在一串指令的执行中，还需要藉由其他额外的指令所提供的信息时，可以使用反单引号『<code>指令</code>』或 『$(指 令)』。特别注意，那个 ` 是键盘上方的数字键 1 左边那个按键，而不是单引号</li>
<li>若该变量为扩增变量内容时，则可用 &quot;$变量名称&quot; 或 ${变量} 累加内容</li>
<li>若该变量需要在其他子程序执行，则需要以 export 来使变量变成环境变量</li>
<li>通常大写字符为系统默认变量，自行设定变量可以使用小写字符</li>
<li>取消变量的方法为使用 unset</li>
</ol>
<ul>
<li>环境变量的功能<br>
shell 环境的环境变量查询分别是 env 与 export</li>
</ul>
<p>用 env 观察环境变量与常见环境变量说明，env 是 environment (环境) 的简写</p>
<p>用 set 观察所有变量 (含环境变量与自定义变量)<br>
set 除了环境变量之外， 还 会将其他在 bash 内的变量通通显示出来（自己设置的变量也会显示出来）<br>
基本上，在 Linux 预设的情况中，使用{大写的字母}来设定的变量 一般为系统内定需要的变量</p>
<p>$：(关于本 shell 的 PID) 钱字号本身也是个变量，代表的是『目前这个 Shell 的线程代号』，亦即是所谓的 PID (Process ID)，『 echo $$ 』出现的数字就是你的 PID 号码</p>
<p>?：(关于上个执行指令的回传值)『上 一个执行的指令所回传的值』，当我们执行某些指令时， 这些指令都会回传一个执行后的代码。一般来说，如果成功的执行该指令， 则会回传一个 0 值</p>
<p>export ： 自定义变量转成环境变量，分享自己的变量设定给后来呼叫的文件或其他程序<br>
环境变量与自定义变量这两 者的差异在于『 该变量是否会被子程序所继续引用』<br>
子程序仅会继承父程序的环境变量， 子程序不 会继承父程序的自定义变量<br>
仅下达 export 而没有接变量时，那么此时将会把所有的『环境变量』显示出来</p>
<ul>
<li>
<p>影响显示结果的语系变量 (locale)</p>
</li>
<li>
<p>变量的有效范围<br>
环境变量=全局变量<br>
自定义变数=局部变量</p>
</li>
</ul>
<ol>
<li>当启动一个 shell，操作系统会分配一记忆区块给 shell 使用，此内存内之变量可让子程序取用</li>
<li>若在父程序利用 export 功能，可以让自定义变量的内容写到上述的记忆区块当中(环境变量)；</li>
<li>当加载另一个 shell 时 (亦即启动子程序，而离开原本的父程序了)，子 shell 可以将父 shell 的环境变量所 在的记忆区块导入自己的环境变量区块当中。</li>
</ol>
<ul>
<li>变量键盘读取、数组与宣告： read, array, declare</li>
</ul>
<ol>
<li>
<p>read<br>
读取来自键盘输入的变量<br>
[dmtsai@study ~]$ read [- - pt] variable<br>
选项与参数：<br>
-p ：后面可以接提示字符！<br>
-t ：后面可以接等待的『秒数！』</p>
</li>
<li>
<p>declare / typeset<br>
declare 或 typeset 是一样的功能，就是在『宣告变量的类型』<br>
如果使用 declare 后面并没有接任何 参数，那么 bash 就会主动的将所有的变量名称与内容通通叫出来<br>
[dmtsai@study ~]$ declare [- - aixr] variable<br>
选项与参数：<br>
-a ：将后面名为 variable 的变量定义成为数组 (array) 类型<br>
-i ：将后面名为 variable 的变量定义成为整数数字 (integer) 类型<br>
-x ：用法与 export 一样，就是将后面的 variable 变成环境变量；<br>
-r ：将变量设定成为 readonly 类型，该变量不可被更改内容，也不能 unset</p>
</li>
</ol>
<p>变量类型默认为『字符串』，所以若不指定变量类型，<strong>则 1+2 为一个『字符串』</strong> 而不是『计算式』。 所以 上述第一个执行的结果才会出现那个情况的；<br>
bash 环境中的数值运算，预设最多仅能到达整数形态，所以 1/3 结果是 0；</p>
<ul>
<li>
<p>ulimit文件系统及程序的限制关系<br>
bash 是可以『限制用户的某些系统资源』的，包括可以开启的文件数量， 可 以使用的 CPU 时间，可以使用的内存总量等等</p>
</li>
<li>
<p>变量内容的删除、取代与替换 (Optional)<br>
<img src="https://lixin-ee.github.io//post-images/1578042049345.png" alt=""></p>
</li>
<li>
<p>变量的测试与内容替换<br>
需要『判断』某个变量是否存在，若变量存在则使用既有的设定，若变量不存在<br>
则给予一个常用的设定<br>
<img src="https://lixin-ee.github.io//post-images/1578042065695.png" alt=""><br>
<img src="https://lixin-ee.github.io//post-images/1578042077141.png" alt=""></p>
</li>
<li>
<p>命令别名设定： alias, unalias<br>
适用于惯用指令特别长 例如  alias lm='ls -al | more '<br>
『alias 的定义规则与变量定义规则几乎相同</p>
</li>
<li>
<p>历史命令：history<br>
执行上一个指令， 除了使用上下键之外，我可以直接以『 !! 』 来下达上个指令的内容<br>
同一账号同时多次登入的 history，最后注销的那个 bash 才会是最后写入的数据。如此一来其他 bash 的指令操作就不会被记录下来了 (其实有被记录，只是被后来的最后一个 bash 所覆盖更新了)</p>
</li>
<li>
<p>路径与指令搜寻顺序<br>
指令运作的顺序可以这样看：</p>
</li>
</ul>
<ol>
<li>以相对/绝对路径执行指令，例如『 /bin/ls 』或『 ./ls 』；</li>
<li>由 alias 找到该指令来执行；</li>
<li>由 bash 内建的 (builtin) 指令来执行；</li>
<li>透过 $PATH 这个变量的顺序搜寻到的第一个指令来执行。</li>
</ol>
<ul>
<li>
<p>bash  的进站与欢迎讯息： /etc/issue, /etc/motd</p>
</li>
<li>
<p>bash<br>
统有一些环境配置文件案的存在，又可以分为全体系统的配置文件以及用户个人偏好配置文<br>
login shell 其实只会读取这两个配置文件：</p>
</li>
</ul>
<ol>
<li>/etc/profile：这是系统整体的设定，你最好不要修改这个文件；</li>
<li>~/.bash_profile 或 ~/.bash_login 或 ~/.profile：属于使用者个人设定，你要改自己的数据，就写入这里</li>
</ol>
<p>source 读入环境配置文件的指令</p>
<ul>
<li>终端机的环境设定： stty, set<br>
查阅目前的一些按键内容（其实就是发送给进程的信号）：stty -a(setting tty 终端机的意思)<br>
intr : 送出一个 interrupt (中断) 的讯号给目前正在 run 的程序 (就是终止啰！)；<br>
quit : 送出一个 quit 的讯号给目前正在 run 的程序；<br>
erase : 向后删除字符，<br>
kill : 删除在目前指令列上的所有文字；<br>
eof : End of file 的意思，代表『结束输入』。<br>
start : 在某个程序停止后，重新启动他的 output<br>
stop : 停止目前屏幕的输出；<br>
susp : 送出一个 terminal stop 的讯号给正在 run 的程序</li>
</ul>
<p>利用 set 来设定自己的一些bash终端机设定值</p>
<p>bash 默认的组合键<br>
Ctrl + C 终止目前的命令<br>
Ctrl + D 输入结束 (EOF)，例如邮件结束的时候；<br>
Ctrl + M 就是 Enter 啦！<br>
Ctrl + S 暂停屏幕的输出<br>
Ctrl + Q 恢复屏幕的输出<br>
Ctrl + U 在提示字符下，将整列命令删除<br>
Ctrl + Z 『暂停』目前的命令</p>
<ul>
<li>
<p>通配符与特殊符号<br>
<img src="https://lixin-ee.github.io//post-images/1578043210202.png" alt=""><br>
<img src="https://lixin-ee.github.io//post-images/1578043240777.png" alt=""></p>
</li>
<li>
<p>数据流重导向<br>
标准输出指的是『指令执行所回传的正确的讯息』，而标准错误输出可理解为『 指令执行失败后，所回传的错误讯息』<br>
数据流重导向可以将 standard output(简称 stdout) 与 standard error output (简称 stderr) 分别传送到其他的文件或装置去</p>
</li>
</ul>
<ol>
<li>标准输入 (stdin) ：代码为 0 ，使用 &lt; 或 &lt;&lt; ；</li>
<li>标准输出 (stdout)：代码为 1 ，使用 &gt; 或 &gt;&gt; ；</li>
<li>标准错误输出(stderr)：代码为 2 ，使用 2&gt; 或 2&gt;&gt; ；</li>
</ol>
<p>注意：</p>
<ol>
<li>该文件 (本例中是 ~/rootfile) 若不存在，系统会自动的将他建立起来，但是</li>
<li>当这个文件存在的时候，那么系统就会先将这个文件内容清空，然后再将数据写入！</li>
<li>也就是若以 &gt; 输出到一个已存在的文件中，那个文件就会被覆盖掉，用&gt;&gt;才是累加</li>
</ol>
<p>1&gt; ：以覆盖的方法将『正确的数据』输出到指定的文件或装置上；<br>
1&gt;&gt;：以累加的方法将『正确的数据』输出到指定的文件或装置上；<br>
2&gt; ：以覆盖的方法将『错误的数据』输出到指定的文件或装置上；<br>
2&gt;&gt;：以累加的方法将『错误的数据』输出到指定的文件或装置上；</p>
<ul>
<li>/dev/null 垃圾桶黑洞装置与特殊写法<br>
/dev/null 可以吃掉任何导向这个装置的信息，适用于要将讯息忽略掉而不显示或储存</li>
</ul>
<p>由于两股数据同时写入一个文件，又没有使用特殊的语法， 此时两 股数据可能会交叉写入该文件内，造成次序的错乱 写入同一个文件可以使用 2&gt;&amp;1 也可以使用 &amp;&gt;</p>
<ul>
<li>
<p>standard input ： &lt; 与 &lt;&lt;<br>
&lt;  将原本需要由键盘输入的数据，改由文件内容来取代<br>
&lt;&lt; 这个连续两个小于的符号了。 他代表的是『结束的输入字符』的意思</p>
</li>
<li>
<p>命令执行的判断依据： ; , &amp;&amp;, ||<br>
一次执行多个指令，在指令与指令中间利用分号 (;) 来隔开<br>
如果这两个指令彼 此之间是有相关性的， 前一个指令是否成功的执行与后一个指令是否要执行有关！那就得动用到 &amp;&amp; 或 ||<br>
若前一个指令执行的结果为正确，在 Linux 底下会回传一个 $? = 0 的值<br>
<img src="https://lixin-ee.github.io//post-images/1578044192091.png" alt=""><br>
由于指令是一个接着一个去执行的，因此，如果真要使用判断， 那么这个 &amp;&amp; 与 || 的顺序就不能搞错<br>
条件易变的判断放在前面，结果比较肯定的可以放在后面</p>
</li>
<li>
<p>管线命令 (pipe)<br>
管线命令使用的是『 | 』这个界定符号！ 另外，管线命令与『连续下达命令』是不一样的<br>
这个管 线命令『 | 』<strong>仅能处理经由前面一个指令传来的正确信息</strong>，也就是standard output 的信息，对于 stdandard error 并没有直接处理的能力。<br>
每个管线后面接的第一个数据必定是『指令』！而且这个指令必须要能够接受 standard input 的 数据才行，这样的指令才可以是为 <strong>『管线命令』</strong></p>
</li>
</ul>
<p>管线命令仅会处理 standard output，对于 standard error output 会予以忽略<br>
管线命令必须要能够接受来自前一个指令的数据成为 standard input 继续处理才行。</p>
<p>如果硬要让 standard error 可以被管线命令所使用，那得用上一小节的数据流重导向， 让 2&gt;&amp;1 加入指令中～就可以让 2&gt; 变成 1&gt;</p>
<ul>
<li>
<p>撷取命令： cut, grep<br>
cut将一段讯息的某一段给他『切』出来，主要的用途在于将『同一行里面的数据进行分解！』最常使用在分析一些数据或文字数据<br>
grep则是分析一行讯息， 若当中有我 们所需要的信息，就将该行拿出来</p>
</li>
<li>
<p>排序命令： sort, wc, uniq<br>
sort 可以依据不同的数据型态来排序<br>
uniq将重复的资料仅列出一个显示<br>
wc 计算里面有多少字、多少行、多少字符的话</p>
</li>
<li>
<p>双向重导向： tee<br>
将这个数据流的处理过程中将某段讯息存下来，tee 会同时将数据流分送到文件去与屏幕 (screen)</p>
</li>
<li>
<p>字符转换命令： tr, col, join, paste, expand<br>
tr 可以用来删除一段讯息当中的文字，或者是进行文字讯息的替<br>
col  可以用来简单的处理将 [tab] 按键取代成为空格键<br>
join 处理两个文件之间的数据，『两个文件当中，有 &quot; 相同数据&quot; 的那一行，才将他加在一起』，但在使用 join 之前，所需要处理的文件应该要事先经过排序 (sort) 处理<br>
paste 就直接 『将两行贴在一起，且中间以 [tab] 键隔开』<br>
expand 将 [tab] 按键转成空格键</p>
</li>
<li>
<p>分区 命令： split<br>
将一个大文件，依据文件大小或行数来分区，就可以将大文件分区成为小文件了</p>
</li>
<li>
<p>参数代换： xargs<br>
产生某个指令的参数，xargs 可以读入 stdin 的数据，并 且以空格符或断行字符作为分辨，将 stdin 分隔成为 arguments<br>
很多指令其实并不支持管 线命令，因此可以透过 xargs 来提供该指令引用standard input</p>
</li>
<li>
<p>关于减号 - 的用途<br>
在管线命令当中，常常会使用到前一个指令的 stdout 作为这次的 stdin ， 某些指令需要用到文件名 (例如 tar) 来进行处理时，该 stdin 与 stdout 可以利用减号 &quot;-&quot; 来替代</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 20. 有效的括号[字符串][栈]]]></title>
        <id>https://lixin-ee.github.io//post/zi-fu-chuan-20-you-xiao-de-gua-hao-zi-fu-chuan-zhan</id>
        <link href="https://lixin-ee.github.io//post/zi-fu-chuan-20-you-xiao-de-gua-hao-zi-fu-chuan-zhan">
        </link>
        <updated>2020-01-03T02:03:35.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。<br>
有效字符串需满足：<br>
左括号必须用相同类型的右括号闭合。<br>
左括号必须以正确的顺序闭合。<br>
注意空字符串可被认为是有效字符串。<br>
示例 1:<br>
输入: &quot;()&quot;<br>
输出: true<br>
示例 2:<br>
输入: &quot;()[]{}&quot;<br>
输出: true<br>
示例 3:<br>
输入: &quot;(]&quot;<br>
输出: false<br>
示例 4:<br>
输入: &quot;([)]&quot;<br>
输出: false<br>
示例 5:<br>
输入: &quot;{[]}&quot;<br>
输出: true<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/valid-parentheses<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>第一想法就是单栈hhh<br>
然后想用istringstream来试一下<br>
首先判断s的size 如果是奇数的话可以直接木大了<br>
istringstream翻车了，没有找到能从字符串流读取单个字符的函数<br>
然后最后必须判断栈是否为空，因为可能有&quot;((&quot;的情况存在<br>
然后就是&quot;){&quot;这种鬼情况 所以在右括号中的switch中也必须判断栈是否为空，注意一定要优先判断empty ||关系运算符是先左后右，否则先temp.top()还是会报错<br>
运行结果很差，得好好看看题解的优化</p>
<pre><code>class Solution {
public:
    bool isValid(string s) {
        if(s.empty()) return true;
        if(s.size()%2) return false;
        stack&lt;char&gt; temp;
        //istringstream is(s);
        //char c;
        for(auto cr=s.begin();cr&lt;s.end();++cr){
            char c=*cr;
            if(c=='('||c=='{'||c=='['){
                temp.push(c);
                continue;
            }
            switch (c){
                    case')':
                    if(temp.empty()||temp.top()!='(') return false; else temp.pop(); break;
                    case'}':
                    if(temp.empty()||temp.top()!='{') return false; else temp.pop(); break;
                    case']':
                    if(temp.empty()||temp.top()!='[') return false; else temp.pop(); break;
            }    
        }
        if(temp.empty())
            return true;
        else
            return false;
    }
};
</code></pre>
<p>来看官方题解</p>
<blockquote>
<p>思路<br>
想象一下，你正在为你的大学课设编写一个小型编译器，编译器的任务之一（或称子任务）将检测括号是否匹配。<br>
我们本文中看到的算法可用于处理编译器正在编译的程序中的所有括号，并检查是否所有括号都已配对。这将检查给定的括号字符串是否有效，是一个重要的编程问题。<br>
我们这个问题中将要处理的表达式可以包含以下三种不同类型的括号：<br>
()，<br>
{} 以及<br>
[]<br>
在查看如何检查由这些括号组成的给定表达式是否有效之前，让我们看一下该问题的简化版本，在简化后的问题中，只含一种类型的括号。这么一来，我们将会遇到的表达式是<br>
(((((()))))) -- VALID<br>
()()()()     -- VALID<br>
(((((((()    -- INVALID<br>
((()(())))   -- VALID<br>
上我们试着用一个简单的算法来解决这一问题。<br>
我们从表达式的左侧开始，每次只处理一个括号。<br>
假设我们遇到一个开括号（即 (），表达式是否无效取决于在该表达式的其余部分的某处是否有相匹配的闭括号（即 )）。此时，我们只是增加计数器的值保持跟踪现在为止开括号的数目。left += 1<br>
如果我们遇到一个闭括号，这可能意味着这样两种情况：<br>
此闭括号没有与与之对应的开括号，在这种情况下，我们的表达式无效。当 left == 0，也就是没有未配对的左括号可用时就是这种情况。<br>
我们有一些未配对的开括号可以与该闭括号配对。当 left &gt; 0，也就是有未配对的左括号可用时就是这种情况。<br>
如果我们在 left == 0 时遇到一个闭括号（例如 )），那么当前的表达式无效。否则，我们会减少 left 的值，也就是减少了可用的未配对的左括号的数量。<br>
继续处理字符串，直到处理完所有括号。<br>
如果最后我们仍然有未配对的左括号，这意味着表达式无效。<br>
如果我们只是尝试对原始问题采用相同的办法，这是根本就行不通的。基于简单计数器的方法能够在上面完美运行是因为所有括号都具有相同的类型。因此，当我们遇到一个闭括号时，我们只需要假设有一个对应匹配的开括号是可用的，即假设 left &gt; 0。<br>
但是，在我们的问题中，如果我们遇到 ]，我们真的不知道是否有相应的<code>[</code>可用。你可能会问：<br>
为什么不为不同类型的括号分别维护一个单独的计数器？<br>
这可能不起作用，因为括号的相对位置在这里也很重要。例如：<br>
[{]<br>
如果我们只是在这里维持计数器，那么只要我们遇到闭合方括号，我们就会知道此处有一个可用的未配对的开口方括号。但是，最近的未配对的开括号是一个花括号，而不是一个方括号，因此计数方法在这里被打破了。<br>
方法：栈<br>
关于有效括号表达式的一个有趣属性是有效表达式的子表达式也应该是有效表达式。（不是每个子表达式）例如</p>
</blockquote>
<p><img src="https://lixin-ee.github.io//post-images/1578017270229.png" alt=""></p>
<blockquote>
<p>此外，如果仔细查看上述结构，颜色标识的单元格将标记开闭的括号对。整个表达式是有效的，而它的子表达式本身也是有效的。这为问题提供了一种递归结构。例如，考虑上图中两个绿色括号内的表达式。开括号位于索引 1，相应闭括号位于索引 6。<br>
如果每当我们在表达式中遇到一对匹配的括号时，我们只是从表达式中删除它，会发生什么？<br>
让我们看看下面的这个想法，从整体表达式中一次删除一个较小的表达式，因为这是一个有效的表达式，我们最后剩留下一个空字符串。<br>
在表示问题的递归结构时，栈数据结构可以派上用场。我们无法真正地从内到外处理这个问题，因为我们对整体结构一无所知。但是，栈可以帮助我们递归地处理这种情况，即从外部到内部。<br>
让我们看看使用栈作为该问题的中间数据结构的算法。</p>
</blockquote>
<blockquote>
<p>算法<br>
初始化栈 S。<br>
一次处理表达式的每个括号。<br>
如果遇到开括号，我们只需将其推到栈上即可。这意味着我们将稍后处理它，让我们简单地转到前面的 子表达式。<br>
如果我们遇到一个闭括号，那么我们检查栈顶的元素。如果栈顶的元素是一个 相同类型的 左括号，那么我们将它从栈中弹出并继续处理。否则，这意味着表达式无效。<br>
如果到最后我们剩下的栈中仍然有元素，那么这意味着表达式无效。</p>
</blockquote>
<pre><code>class Solution {

  // Hash table that takes care of the mappings.
  private HashMap&lt;Character, Character&gt; mappings;

  // Initialize hash map with mappings. This simply makes the code easier to read.
  public Solution() {
    this.mappings = new HashMap&lt;Character, Character&gt;();
    this.mappings.put(')', '(');
    this.mappings.put('}', '{');
    this.mappings.put(']', '[');
  }

  public boolean isValid(String s) {

    // Initialize a stack to be used in the algorithm.
    Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();

    for (int i = 0; i &lt; s.length(); i++) {
      char c = s.charAt(i);

      // If the current character is a closing bracket.
      if (this.mappings.containsKey(c)) {

        // Get the top element of the stack. If the stack is empty, set a dummy value of '#'
        char topElement = stack.empty() ? '#' : stack.pop();

        // If the mapping for this bracket doesn't match the stack's top element, return false.
        if (topElement != this.mappings.get(c)) {
          return false;
        }
      } else {
        // If it was an opening bracket, push to the stack.
        stack.push(c);
      }
    }

    // If the stack still contains elements, then it is an invalid expression.
    return stack.isEmpty();
  }
}
</code></pre>
<blockquote>
<p>复杂度分析<br>
时间复杂度：O(n)，因为我们一次只遍历给定的字符串中的一个字符并在栈上进行 O(1) 的推入和弹出操作。<br>
空间复杂度：O(n)，当我们将所有的开括号都推到栈上时以及在最糟糕的情况下，我们最终要把所有括号推到栈上。例如 ((((((((((。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Linux基础] vim  程序编辑器（鸟哥Linux第九章）]]></title>
        <id>https://lixin-ee.github.io//post/linux-ji-chu-vim-cheng-xu-bian-ji-qi-niao-ge-linux-di-ba-zhang</id>
        <link href="https://lixin-ee.github.io//post/linux-ji-chu-vim-cheng-xu-bian-ji-qi-niao-ge-linux-di-ba-zhang">
        </link>
        <updated>2020-01-02T08:16:24.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p>vim 是『程序编辑器』<br>
vim 会依据文件的扩展名或者是文件内的开头信息， 判断该文件的内容而自动的呼叫该程序的语法判断式，再以颜色来显示程序代码与一般信息。</p>
</li>
<li>
<p>vi 的使用<br>
o 一般指令模式 (command mode)<br>
以 vi 打开一个文件就直接进入一般指令模式了(这是默认的模式，也简称为一般模式)。在这个模 式中， 你可以使用『上下左右』按键来移动光标，你可以使用『删除字符』或『删除整列』来处 理文件内容， 也可以使用『复制、贴上』来处理你的文件数据。<br>
o 编辑模式 (insert mode)<br>
在一般指令模式中可以进行删除、复制、贴上等等的动作，但是却无法编辑文件内容的！ 要等到 你按下『i, I, o, O, a, A, r, R』等任何一个字母之后才会进入编辑模式。注意了！通常在 Linux 中，按下这些按键时，在画面的左下方会出现『 INSERT 或 REPLACE 』的字样，此时才可以进 行编辑。而如果要回到一般指令模式时， 则必须要按下『Esc』这个按键即可退出编辑模式。<br>
o 指令列命令模式 (command-line mode)<br>
在一般模式当中，输入『 : / ? 』三个中的任何一个按钮，就可以将光标移动到最底下那一列。在 这个模式当中， 可以提供你『搜寻资料』的动作，而读取、存盘、大量取代字符、离开 vi 、显 示行号等等的动作则是在此模式中达成的<br>
<img src="https://lixin-ee.github.io//post-images/1577953264909.png" alt=""><br>
一般指令模式可与编辑模式及指令列模式切换， 但编辑模式与指令列模式之间不可互相切换</p>
</li>
</ul>
<p>使用过程<br>
1.使用『 vi filename 』进入一般指令模式<br>
2.按下 i 进入编辑模式，开始编辑文字<br>
一般指令模式之中，只要按下 i, o, a 等字符就可以进入编辑模式，左下角状态栏中会出现 –INSERT-<br>
3.按下 [ESC] 按钮回到一般指令模式<br>
4.进入指令列模式，文件储存并离开 vi 环境<br>
输入『:wq』即可存档离开</p>
<ul>
<li>
<p>按键说明</p>
</li>
<li>
<p>一般指令模式可用的按钮说明<br>
常用指令如下，完全版指令查看9.2.2按键说明<br>
[Ctrl] + [f] 屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)<br>
[Ctrl] + [b] 屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)<br>
0 或功能键[Home] 这是数字『 0 』：移动到这一列的最前面字符处 (常用)<br>
$ 或功能键[End] 移动到这一列的最后面字符处(常用)<br>
G 移动到这个文件的最后一列(常用)<br>
gg 移动到这个文件的第一列，相当于 1G 啊！ (常用)<br>
<code>n&lt;Enter&gt;n</code> 为数字。光标向下移动 n 列(常用)<br>
/word 向光标之下寻找一个名称为 word 的字符串。例如要在文件内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用)<br>
:n1,n2s/word1/word2/g   n1 与 n2 为数字。在第 n1 与 n2 列之间寻找 word1 这个字符串，并将该字符串取代 为 word2 ！举例来说，在 100 到 200 列之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s/vbird/VBIRD/g』。(常用)<br>
:1,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi mathvariant="normal">/</mi><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi><mn>1</mn><mi mathvariant="normal">/</mi><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi><mn>2</mn><mi mathvariant="normal">/</mi><mi>g</mi><mi mathvariant="normal">从</mi><mi mathvariant="normal">第</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">列</mi><mi mathvariant="normal">到</mi><mi mathvariant="normal">最</mi><mi mathvariant="normal">后</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">列</mi><mi mathvariant="normal">寻</mi><mi mathvariant="normal">找</mi><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi><mn>1</mn><mi mathvariant="normal">字</mi><mi mathvariant="normal">符</mi><mi mathvariant="normal">串</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">并</mi><mi mathvariant="normal">将</mi><mi mathvariant="normal">该</mi><mi mathvariant="normal">字</mi><mi mathvariant="normal">符</mi><mi mathvariant="normal">串</mi><mi mathvariant="normal">取</mi><mi mathvariant="normal">代</mi><mi mathvariant="normal">为</mi><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi><mn>2</mn><mi mathvariant="normal">！</mi><mo>(</mo><mi mathvariant="normal">常</mi><mi mathvariant="normal">用</mi><mo>)</mo><mo>:</mo><mn>1</mn><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">s/word1/word2/g  从第一列到最后一列寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)
:1,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord">2</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord cjk_fallback">从</span><span class="mord cjk_fallback">第</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">列</span><span class="mord cjk_fallback">到</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">列</span><span class="mord cjk_fallback">寻</span><span class="mord cjk_fallback">找</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord">1</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">符</span><span class="mord cjk_fallback">串</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">并</span><span class="mord cjk_fallback">将</span><span class="mord cjk_fallback">该</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">符</span><span class="mord cjk_fallback">串</span><span class="mord cjk_fallback">取</span><span class="mord cjk_fallback">代</span><span class="mord cjk_fallback">为</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord">2</span><span class="mord cjk_fallback">！</span><span class="mopen">(</span><span class="mord cjk_fallback">常</span><span class="mord cjk_fallback">用</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span></span></span></span>s/word1/word2/gc  从第一列到最后一列寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显 示提示字符给用户确认 (confirm) 是否需要取代！(常用)<br>
x, X 在一列字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字 符(相当于 [backspace] 亦即是退格键) (常用)<br>
dd 删除游标所在的那一整列(常用)<br>
ndd n 为数字。删除光标所在的向下 n 列，例如 20dd 则是删除 20 列 (常用)<br>
yy 复制游标所在的那一列(常用)<br>
nyy n 为数字。复制光标所在的向下 n 列，例如 20yy 则是复制 20 列(常用)<br>
p, P p 为将已复制的数据在光标下一列贴上，P 则为贴在游标上一列！ 举例来说，我目前 光标在第 20 列，且已经复制了 10 列数据。则按下 p 后， 那 10 列数据会贴在原本 的 20 列之后，亦即由 21 列开始贴。但如果是按下 P 呢？ 那么原本的第 20 列会被 推到变成 30 列。 (常用)<br>
u 复原前一个动作。(常用)<br>
[Ctrl]+r 重做上一个动作。(常用)<br>
. 不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重 复贴上等等动作，按下小数点『.』就好了！ (常用)</p>
</li>
<li>
<p>进入插入或取代的编辑模式<br>
i, I 进入插入模式(Insert mode)： i 为『从目前光标所在处插入』， I 为『在目前所在列的第一个非空格符处开始插入』。 (常用)<br>
a, A 进入插入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始插入』， A 为『从光标所在列的最后一个 字符处开始插入』。(常用)<br>
o, O 进入插入模式(Insert mode)： 这是英文字母 o 的大小写。o 为『在目前光标所在的下一列处插入新的一列』； O 为 在目前光标所在处的上一列插入新的一列！(常用)<br>
r, R 进入取代模式(Replace mode)： r 只会取代光标所在的那一个字符一次；R 会一直取代光标所在的文字，直到按下 ESC 为止；(常用)<br>
上面这些按键中，在 vi 画面的左下角处会出现『--INSERT--』或『--REPLACE--』的字样。 由名称就知道该动作了 吧！！特别注意的是，我们上面也提过了，你想要在文件里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入<br>
[Esc] 退出编辑模式，回到一般指令模式中(常用)</p>
</li>
<li>
<p>指令列模式的可用按钮说明<br>
:w 将编辑的数据写入硬盘文件中(常用)<br>
:q 离开 vi (常用)<br>
:wq 储存后离开，若为 :wq! 则为强制储存后离开 (常用)</p>
</li>
</ul>
<p>在 vi 中，『数字』是很有意义的！数字通常代表重复做几次的意思！ 也有可能是代表 去到第几个什么什么的意思</p>
<ul>
<li>暂存档、救援回复与开启时的警告讯息<br>
在使用 vim 编辑时， vim 会在与被编辑的文件的目录下，再建立一个名为 .filename.swp 的 文件。</li>
</ul>
<p>发现暂存盘警告讯息的画面中，有出现六个可用按钮，各按钮的说明如下：<br>
(O)pen Read-Only：打开此文件成为只读档， 可以用在你只是想要查阅该文件内容并不想要进行编辑行为 时。一般来说，在上课时，如果你是登入到同学的计算机去看他的配置文件， 结果发现其实同学他自己也 在编辑时，可以使用这个模式；<br>
(E)dit anyway：还是用正常的方式打开你要编辑的那个文件， 并不会载入暂存盘的内容。不过很容易出现 两个使用者互相改变对方的文件等问题！不好不好！<br>
(R)ecover：就是加载暂存盘的内容，用在你要救回之前未储存的工作。 不过当你救回来并且储存离开 vim 后，还是要手动自行删除那个暂存档喔！<br>
(D)elete it：你确定那个暂存档是无用的！那么开启文件前会先将这个暂存盘删除！ 这个动作其实是比较常 做的！因为你可能不确定这个暂存档是怎么来的，所以就删除掉他吧！<br>
(Q)uit：按下 q 就离开 vim ，不会进行任何动作回到命令提示字符。<br>
(A)bort：忽略这个编辑行为，感觉上与 quit 非常类似！ 也会送你回到命令提示字符就是啰！</p>
<ul>
<li>
<p>vim 的额外功能（相较于vi）</p>
</li>
<li>
<p>区块选择(Visual Block)<br>
区块选择的按键意义<br>
v 字符选择，会将光标经过的地方反白选择！<br>
V 列选择，会将光标经过的列反白选择！<br>
[Ctrl]+v 区块选择，可以用长方形的方式选择资料<br>
y 将反白的地方复制起来<br>
d 将反白的地方删除掉<br>
p 将刚刚复制的区块，在游标所在处贴上！</p>
</li>
<li>
<p>多文件编辑<br>
多文件编辑的按键<br>
vim file1 file2 file3...<br>
:n 编辑下一个文件<br>
:N 编辑上一个文件<br>
:files 列出目前这个 vim 的开启的所有文件</p>
</li>
<li>
<p>多窗口功能<br>
在指令列模式输入『:sp {filename}』<br>
如果想要在新窗口启动另一个文件，就加入档名，否则仅输入 :sp 时， 出现的则是同一个文件在两个窗口间</p>
</li>
</ul>
<p>多窗口情况下的按键功能 :<br>
sp [filename] 开启一个新窗口，如果有加 filename， 表示在新窗口开启一个新文件，否则表示两个窗口 为同一个文件内容(同步显示)。<br>
[ctrl]+w+ j [ctrl]+w+↓ 按键的按法是：先按下 [ctrl] 不放， 再按下 w 后放开所有的按键，然后再按下 j (或向 下箭头键)，则光标可移动到下方的窗口。 [ctrl]+w+ k [ctrl]+w+↑ 同上，不过光标移动到上面的窗口。 [ctrl]+w+ q 其实就是 :q 结束离开啦！ 举例来说，如果我想要结束下方的窗口，那么利用 [ctrl]+w+ ↓ 移动到下方窗口后，按下 :q 即可离开， 也可以按下 [ctrl]+w+q 啊</p>
<ul>
<li>
<p>挑字补全功能<br>
[ctrl]+x -&gt; [ctrl]+n 透过目前正在编辑的这个『文件的内容文字』作为关键词，予以补齐<br>
[ctrl]+x -&gt; [ctrl]+f 以当前目录内的『文件名』作为关键词，予以补齐<br>
[ctrl]+x -&gt; [ctrl]+o 以扩展名作为语法补充，以 vim 内建的关键词，予以补齐</p>
</li>
<li>
<p>环境设定与记录： ~/.vimrc, ~/.viminfo<br>
vim 会主动的将你曾经做过的行为登录下来，好让你下次可以轻松的作业啊！ 那个 记录动作的文件就是： ~/.viminfo<br>
整体 vim 的设定值一般是放置在 /etc/vimrc 这个文件，不过，不建议你修改他！ 你可以修改 ~/.vimrc 这 个文件<br>
set hlsearch &quot;高亮度反白<br>
set backspace=2 &quot;可随时用退格键删除<br>
set autoindent &quot;自动缩排<br>
set ruler &quot;可显示最后一列的状态<br>
set showmode &quot;左下角那一列的状态<br>
set nu &quot;可以在每一列的最前面显示行号啦！<br>
set bg=dark &quot;显示不同的底色色调<br>
syntax on &quot;进行语法检验，颜色显示。</p>
</li>
<li>
<p>vim 常用指令示意图<br>
<img src="https://lixin-ee.github.io//post-images/1577955542874.png" alt=""></p>
</li>
</ul>
]]></content>
    </entry>
</feed>