<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-03-08T03:39:00.964Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>In the darkest night,Rising like a spire.</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[学习技巧-分阶段思考与抽象解决方案]]></title>
        <id>https://lixin-scut.github.io//post/xue-xi-ji-qiao-fen-jie-duan-si-kao-yu-chou-xiang-jie-jue-fang-an</id>
        <link href="https://lixin-scut.github.io//post/xue-xi-ji-qiao-fen-jie-duan-si-kao-yu-chou-xiang-jie-jue-fang-an">
        </link>
        <updated>2020-03-08T03:31:53.000Z</updated>
        <content type="html"><![CDATA[<h3 id="分阶段思考">分阶段思考</h3>
<p>  今天在leetcode上做题的时候，我突然想起以前高中时和大学做家教的时候总结了辅导别人的经验：就是不要一下子给出他们答案，而是要一步一步给出答案，引导他们利用已有的条件思考下一步。<br>
  然鹅现在倒发现自己忘了应用这个经验和方法hhh，果然还是得多总结经验。<br>
举个例子：<br>
  做题的时候如果遇到了完全不懂的题，在看leetcode题解的时候也适合这样<br>
  首先一段一段地看，利用当前给到的已用提示，看看能不能自己思考出下一步<br>
  不要急于看完整个题解，不断地让自己去思考不同的解决方法，不断地活络思路，这样子才能理解得更深，记得更牢。</p>
<h3 id="抽象解决方案">抽象解决方案</h3>
<p>另外一个感想就是对算法的总结<br>
  现在做的题不多也不少，昨天和大神们讨论题目的时候发现别人很善于总结题目，并且寻找这个题目解法后面的算法思想<br>
  比如找出数组中出现次数超过一半的数字，我知道是利用count不断地加减，但是却不知道抽象出来的算法是投票算法，相当于每个数字有投票权，那么一次循环就等于让大家投票，票数最多的就是结果。<br>
  这个投票算法适用于数字数目有明显差别的时候。<br>
  所以抽象出这个算法思想后就能灵活应用到其他题目中<br>
我永远不可能做完所有题目，掌握思想才是最重要的</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GDB调试]]></title>
        <id>https://lixin-scut.github.io//post/gdb-diao-shi</id>
        <link href="https://lixin-scut.github.io//post/gdb-diao-shi">
        </link>
        <updated>2020-03-08T03:10:16.000Z</updated>
        <content type="html"><![CDATA[<p>  今天在做题的时候发现测试用例的输出和结果对不上<br>
  为了节省电脑资源，我没有在Clion上debug（已经开了很多pdf了），而是特地到ubuntu中去学习了GDB的调试方法<br>
  上一次使用GDB是<a href="https://lixin-scut.github.io/post/coredump-yu-gdb-diao-shi/">coreDump 与GDB调试</a>，专门针对coreDump的情况。<br>
但是这次不同，程序能够正确运行，只是因为逻辑不对造成输出不对，并不会产生coreDump这种极端情况，也不需要强行产生coreDump</p>
<p>一般来说，GDB主要帮忙你完成下面四个方面的功能：</p>
<ol>
<li>启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。</li>
<li>可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）</li>
<li>当程序被停住时，可以检查此时你的程序中的变量值、函数栈和所发生的事。</li>
<li>动态的改变你程序的执行环境。</li>
</ol>
<p>下面就是GDB调试的过程</p>
<p>准备工作：</p>
<ol>
<li>
<p>编译<br>
首先源代码不需要任何改动，只是编译时必须带上-g选项<br>
<code>g++ gdbTest.cc -g -o test</code></p>
</li>
<li>
<p>用GDB打开可运行文件<br>
<code>gdb test</code></p>
</li>
<li>
<p>显示源码<br>
  不知道为什么直接list(l)出来的结果不对，必须在list后面加上行数，然后可以直接list，GDB会自动显示后续的行<br>
同时如果直接在命令行回车的话会自动重复上次的命令</p>
</li>
</ol>
<pre><code>(gdb) list  &lt;-------------------- l命令相当于list，但是我的ubuntu并不能得到想要的结果。 
40			for(int i : nums)
41			{	cout &lt;&lt; i &lt;&lt; &quot; &quot;; }
42			cout &lt;&lt; &quot;\n&quot; ;
43		}
44	};
45	
46	void Test1()
47	{
48		vector&lt;int&gt; data{ 0, 1 };
49		Solution solution;
(gdb) list 1 &lt;-------------------- 从第一行开始例出原码。 
1	// gdbTest.cc
2	// Created by Lixin on 2020.03.08
3	
4	#include &lt;bits/stdc++.h&gt;
5	using namespace std;
6	
7	class Solution {
8	public:
9	    void sortColors(vector&lt;int&gt;&amp; nums) {
10	        print(nums);
(gdb) l &lt;-------------------- l命令相当于list的简写
11			size_t length = nums.size();
12	        if(length &lt; 1)
13	            return;
14	        int left;
15	        int right;
16	        int curNum;
17	        left = 0;
18	        right = length - 1;
19	        curNum = 1;
20	        for(; curNum &lt; right; ++curNum)
(gdb)  &lt;-------------------- 直接回车表示，重复上一次命令 
21	        {
22	            if(nums[curNum] &lt; nums[left])
23	            {
24	                swap(nums[curNum], nums[left]);
25	                if(nums[left] == 0)
26	                {   ++left; }
27	            }
28	            if(nums[curNum] &gt; nums[right])
29	            {
30	                swap(nums[curNum], nums[right]);
(gdb)  &lt;-------------------- 直接回车表示，重复上一次命令 
31	                if(nums[right] == 2)
32	                {   --right; }
33	            }
34	        }
35			print(nums);
36	    }
37	private:
38		void print(vector&lt;int&gt; &amp;nums) const
39		{
40			for(int i : nums)
</code></pre>
<ol start="4">
<li>设置断点<br>
断点就和Clion中debug的一样，会在此处执行前停下。</li>
</ol>
<pre><code>(gdb) break 22 &lt;-------------------- 设置第22行断点 break简写为b
Breakpoint 1 at 0xc87: file gdbTest.cc, line 22.
(gdb) break 26
Breakpoint 2 at 0xd16: file gdbTest.cc, line 26.
(gdb) break 28
Breakpoint 3 at 0xd1a: file gdbTest.cc, line 28.
(gdb) break 32
Breakpoint 4 at 0xdaa: file gdbTest.cc, line 32.
(gdb) info break &lt;-------------------- 查看断点信息
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x0000000000000c87 in Solution::sortColors(std::vector&lt;int, std::allocator&lt;int&gt; &gt;&amp;) at gdbTest.cc:22
2       breakpoint     keep y   0x0000000000000d16 in Solution::sortColors(std::vector&lt;int, std::allocator&lt;int&gt; &gt;&amp;) at gdbTest.cc:26
3       breakpoint     keep y   0x0000000000000d1a in Solution::sortColors(std::vector&lt;int, std::allocator&lt;int&gt; &gt;&amp;) at gdbTest.cc:28
4       breakpoint     keep y   0x0000000000000daa in Solution::sortColors(std::vector&lt;int, std::allocator&lt;int&gt; &gt;&amp;) at gdbTest.cc:32
(gdb) delete 4 &lt;-------------------- 删除断点，注意，delete后面跟的是断点序号而不是行数
</code></pre>
<ol start="5">
<li>运行程序中的命令</li>
</ol>
<pre><code>(gdb) run &lt;--------------------- 运行程序，run命令简写为r 
(gdb) next &lt;--------------------- 单条语句执行，next命令简写n。
(gdb) continue &lt;--------------------- 继续运行程序，continue命令简写c。 
(gdb) print nums &lt;--------------------- 打印变量nums的值，print命令简写p，注意可以打印数组
(gdb) bt &lt;--------------------- 查看函数堆栈。
0 0 2 1 1 2 &lt;----------程序输出。 
[Inferior 1 (process 9168) exited normally]  &lt;--------程序退出，调试结束。
(gdb) q &lt;--------------------- 退出gdb
</code></pre>
<p>参考博客<a href="https://www.cnblogs.com/mfryf/p/5390442.html">比较全面的gdb调试命令</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[快速排序 partition ]]></title>
        <id>https://lixin-scut.github.io//post/kuai-su-pai-xu-partition</id>
        <link href="https://lixin-scut.github.io//post/kuai-su-pai-xu-partition">
        </link>
        <updated>2020-03-08T03:03:39.000Z</updated>
        <content type="html"><![CDATA[<p>做对这道题<a href="https://lixin-scut.github.io/post/shu-zu-75yan-se-fen-lei-zhong-deng-wei-zuo-chu/">数组 75:颜色分类</a>需要熟悉快速排序的 partition 过程。</p>
<p>partition 过程经过一次扫描把整个数组分成三个部分，正好符合这个问题的场景</p>
<p>循环不变量是这样定义的：</p>
<blockquote>
<p>所有在子区间 [0, zero) 的元素都等于 0；<br>
所有在子区间 [zero, i) 的元素都等于 1；<br>
所有在子区间 [two, len - 1] 的元素都等于 2。<br>
说明：设计循环不变量的原则是“不重不漏”。</p>
</blockquote>
<p>1、len 是数组的长度；<br>
2、变量 zero 是前两个子区间的分界点，一个是闭区间，另一个就必须是开区间；<br>
3、变量 i 是循环变量，一般设置为开区间，表示 i 之前的元素是遍历过的；<br>
4、two 是另一个分界线，设计成闭区间。</p>
<p>于是代码要解决以下三个问题：</p>
<ol>
<li>变量初始化应该如何定义。</li>
<li>在遍历的时候，是先加减还是先交换。</li>
<li>什么时候循环终止。</li>
</ol>
<p>处理这三个问题，完全看循环不变量的定义。</p>
<p>编程的时候，zero 和 two 初始化的值就应该保证上面的三个子区间全为空。<br>
在遍历的过程中，“索引先加减再交换”、还是“先交换再加减”就看初始化的时候变量在哪里。<br>
退出循环的条件也看上面定义的循环不变量，在 i == two 成立的时候，上面的三个子区间就正好“不重不漏”地覆盖了整个数组，并且给出的性质成立，题目的任务也就完成了。</p>
<p>体会是：<br>
编码者应该在代码中使用注释表达这段代码编写的算法思想，提醒自己也方便他人。<br>
但是源代码中类似 ++k &lt;= great 和 a[++left] &gt;= a[left - 1] 这样的代码建议不要写，会给阅读者带来理解上的障碍，变量的值发生变化是一个很重要的逻辑，应该单独成为一行，否则不利于调试和以后定位问题。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 75:颜色分类[中等][未做出]]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-75yan-se-fen-lei-zhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-75yan-se-fen-lei-zhong-deng-wei-zuo-chu">
        </link>
        <updated>2020-03-08T02:52:32.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。<br>
此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。<br>
注意:<br>
不能使用代码库中的排序函数来解决这道题。<br>
示例:<br>
输入: [2,0,2,1,1,0]<br>
输出: [0,0,1,1,2,2]<br>
进阶：<br>
一个直观的解决方案是使用计数排序的两趟扫描算法。<br>
首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。<br>
你能想出一个仅使用常数空间的一趟扫描算法吗？<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/sort-colors<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题是腾讯的面试题之一<br>
然后我一开始的想法也是三指针partition，left和right分别管理0的区域和2的区域，然后curNum管理当前值。<br>
但是一开始我使用的是比较法，没有充分利用数字取值范围的特点（只有0，1，2），所以导致漏掉了很多情况，并且必须无限循环保证从交换回来的数字需要多次swap的情况能够正常运行。<br>
最后还是参考了官网题解，发现确实是三分法，但是需要利用好数值这个特性，并且重点是什么时候需要++curNum什么时候不需要！</p>
<p>最后我的代码：</p>
<pre><code>class Solution {
public:
    void sortColors(vector&lt;int&gt;&amp; nums) {
        size_t length = nums.size();
        if(length &lt; 1)
            return;
        int left;
        int right;
        int curNum;
        left = 0;
        right = length - 1;
        curNum = 0;
        while(curNum &lt;= right)
        {
            switch(nums[curNum])
            {
                case 0:
                    swap(nums[left], nums[curNum]);
                    ++left;
                    ++curNum;
                    break;
                case 1:
                    ++curNum;
                    break;
                case 2:
                    swap(nums[right], nums[curNum]);
                    --right;
                    break;
            }
        }
    }
};
</code></pre>
<p>官网题解：</p>
<blockquote>
<p>方法一: 一次遍历<br>
我们用三个指针（p0, p2 和curr）来分别追踪0的最右边界，2的最左边界和当前考虑的元素。<br>
<img src="https://lixin-scut.github.io//post-images/1583636318887.png" alt=""><br>
本解法的思路是沿着数组移动 curr 指针，若nums[curr] = 0，则将其与 nums[p0]互换；若 nums[curr] = 2 ，则与 nums[p2]互换。<br>
算法<br>
初始化0的最右边界：p0 = 0。在整个算法执行过程中 nums[idx &lt; p0] = 0.<br>
初始化2的最左边界 ：p2 = n - 1。在整个算法执行过程中 nums[idx &gt; p2] = 2.<br>
初始化当前考虑的元素序号 ：curr = 0.<br>
While curr &lt;= p2 :<br>
若 nums[curr] = 0 ：交换第 curr个 和 第p0个 元素，并将指针都向右移。<br>
若 nums[curr] = 2 ：交换第 curr个和第 p2个元素，并将 p2指针左移 。<br>
若 nums[curr] = 1 ：将指针curr右移。</p>
</blockquote>
<pre><code>class Solution {
  public:
  /*
  荷兰三色旗问题解
  */
  void sortColors(vector&lt;int&gt;&amp; nums) {
    // 对于所有 idx &lt; p0 : nums[idx &lt; p0] = 0
    // curr 是当前考虑元素的下标
    int p0 = 0, curr = 0;
    // 对于所有 idx &gt; p2 : nums[idx &gt; p2] = 2
    int p2 = nums.size() - 1;

    while (curr &lt;= p2) {
      if (nums[curr] == 0) {
        swap(nums[curr++], nums[p0++]);
      }
      else if (nums[curr] == 2) {
        swap(nums[curr], nums[p2--]);
      }
      else curr++;
    }
  }
};

作者：LeetCode
链接：https://leetcode-cn.com/problems/sort-colors/solution/yan-se-fen-lei-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<p>另外一个介绍partition的题解<a href="https://leetcode-cn.com/problems/sort-colors/solution/kuai-su-pai-xu-partition-guo-cheng-she-ji-xun-huan/">快速排序 partition 过程</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 题54:二叉搜索树的第k个结点]]></title>
        <id>https://lixin-scut.github.io//post/shu-ti-54er-cha-sou-suo-shu-de-di-k-ge-jie-dian</id>
        <link href="https://lixin-scut.github.io//post/shu-ti-54er-cha-sou-suo-shu-de-di-k-ge-jie-dian">
        </link>
        <updated>2020-03-08T00:42:30.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。</p>
</blockquote>
<pre><code>/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};
*/
</code></pre>
<p>【未做出】<br>
没什么特别的，就是复习一下迭代中序遍历吧<br>
尴尬，还是没做出，主要是就是卡在右子树的进栈那里了，通过右子树和进出栈配合从而保证左子树不会重复入栈</p>
<pre><code>class Solution {
public:
    TreeNode* KthNode(TreeNode* pRoot, int k)
    {
        if(k&lt;=0 || pRoot == NULL)
            return NULL;
        stack&lt;TreeNode*&gt; nodeStack;
        TreeNode* curNode;
        curNode = pRoot;
        while(curNode||nodeStack.size())
        {
            while(curNode){
                nodeStack.push(curNode);
                curNode = curNode-&gt;left;
            }
            curNode = nodeStack.top();
            nodeStack.pop();
            --k;
            if(k==0)
                return curNode;
            curNode = curNode-&gt;right;
        }
        return NULL;
    }
};
</code></pre>
<p>书本题解：<br>
如果按照中序遍历的顺序遍历一棵二叉搜索树，则遍历序列的数值是递增排序的。</p>
<pre><code>const BinaryTreeNode* KthNode(const BinaryTreeNode* pRoot, unsigned int k)
{
    if(pRoot == nullptr || k == 0)
        return nullptr;

    return KthNodeCore(pRoot, k);
}

const BinaryTreeNode* KthNodeCore(const BinaryTreeNode* pRoot, unsigned int&amp; k)
{
    const BinaryTreeNode* target = nullptr;

    if(pRoot-&gt;m_pLeft != nullptr)
        target = KthNodeCore(pRoot-&gt;m_pLeft, k);

    if(target == nullptr)
    {
        if(k == 1)
            target = pRoot;

        k--;
    }

    if(target == nullptr &amp;&amp; pRoot-&gt;m_pRight != nullptr)
        target = KthNodeCore(pRoot-&gt;m_pRight, k);

    return target;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 题53:在排序数组中查找数字]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-ti-53zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-ti-53zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi">
        </link>
        <updated>2020-03-08T00:19:27.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题目一">题目一</h3>
<p>描述</p>
<blockquote>
<p>统计一个数字在排序数组中出现的次数。</p>
</blockquote>
<p>暴力法就是循环，时间复杂度是O(n),空间复杂度O(1)，所以优化方向自然是O(logn)了<br>
那自然也就二分法啦hhh，第一想法就是第一次二分找到最右的n，第二次二分找到最左的n，两者的位置相减就得到结果<br>
难点：当第一个元素或者最后一个元素是K时，必须正确返回位置，当数组不存在K时，返回的位置应该一致<br>
所以一定要注意两个函数的mid取值</p>
<p>然后发现（当数组不存在K时，返回的位置应该一致）是错误的，比如[3,4,6,7]中找5，就会返回4和6的位置，这时必须加上判断是否等于k才行，<br>
边缘情况同理，不能简单地right-left+1，否则会返回1</p>
<pre><code>class Solution {
public:
    int GetNumberOfK(vector&lt;int&gt; data ,int k) {
        if(data.empty())
            return 0;
        int left=GetLeftK(data ,k,0,data.size()-1);
        int right=GetRightK(data ,k,0,data.size()-1);
        if(data[left]!=k)
            return 0;
        return right-left+1;
    }
    
    int GetRightK(vector&lt;int&gt; &amp;data ,int k,int beg,int end){
        if(beg==end)
            return beg;
        int mid=beg+(end-beg+1)/2;
        if(data[mid]&lt;=k)
            return GetRightK(data,k,mid,end);
        else if(data[mid]&gt;k)
            return GetRightK(data,k,beg,mid-1);
    }
    int GetLeftK(vector&lt;int&gt; &amp;data ,int k,int beg,int end){
        if(beg==end)
            return beg;
        int mid=beg+(end-beg)/2;
        if(data[mid]&gt;=k)
            return GetLeftK(data,k,beg,mid);
        else if(data[mid]&lt;k)
            return GetLeftK(data,k,mid+1,end);
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>  先分析如何用二分查找算法在数组中找到第一个k，二分查找算法总是先拿数组中间的数字和k作比较。如果中间的数字比k大，那么k只有可能出现在数组的前半段，下一轮我们只在数组的前半段查找就可以 了。如果中间的数字比左小，那么比 只有可能出现在数组的后半段，下一 轮我们只在数组的后半段查找就可以了。如果中间的数字和 k 相等呢?我 们先判断这个数字是不是第一个 k，如果中间数字的前面一个 数字不是 k,，那么此时中间的数字刚好就是第一个 k。如果中间数字的前面一个数字也是 k,那么第一个k肯定在数组的前半段，下一轮我们仍然需要在数组的前半段查找。<br>
  我们可以用同样的思路在排序数组中找到最后一个k，如果中间数字比 k大，那 么k只能出现在数组的前半段。如果中间数字比 k 小，那么k只能出现在数组的后半段。如果中间数字等于 k 呢?我们需要判断这个 k 是不是最后一个k，也就是中间数字的下一个数字是不是也等于k，如果下一个数字不是则中间数字就是最后一个k，否则下一轮我们还是要在数组的后 段中去查找。</p>
</blockquote>
<pre><code>int GetNumberOfK(const int* data, int length, int k)
{
    int number = 0;

    if(data != nullptr &amp;&amp; length &gt; 0)
    {
        int first = GetFirstK(data, length, k, 0, length - 1);
        int last = GetLastK(data, length, k, 0, length - 1);
        
        if(first &gt; -1 &amp;&amp; last &gt; -1)
            number = last - first + 1;
    }

    return number;
}

// 找到数组中第一个k的下标。如果数组中不存在k，返回-1
int GetFirstK(const int* data, int length, int k, int start, int end)
{
    if(start &gt; end)
        return -1;

    int middleIndex = (start + end) / 2;
    int middleData = data[middleIndex];

    if(middleData == k)
    {
        if((middleIndex &gt; 0 &amp;&amp; data[middleIndex - 1] != k) 
            || middleIndex == 0)
            return middleIndex;
        else
            end  = middleIndex - 1;
    }
    else if(middleData &gt; k)
        end = middleIndex - 1;
    else
        start = middleIndex + 1;

    return GetFirstK(data, length, k, start, end);
}

// 找到数组中最后一个k的下标。如果数组中不存在k，返回-1
int GetLastK(const int* data, int length, int k, int start, int end)
{
    if(start &gt; end)
        return -1;

    int middleIndex = (start + end) / 2;
    int middleData = data[middleIndex];

    if(middleData == k)
    {
        if((middleIndex &lt; length - 1 &amp;&amp; data[middleIndex + 1] != k) 
            || middleIndex == length - 1)
            return middleIndex;
        else
            start  = middleIndex + 1;
    }
    else if(middleData &lt; k)
        start = middleIndex + 1;
    else
        end = middleIndex - 1;

    return GetLastK(data, length, k, start, end);
}

</code></pre>
<blockquote>
<p>  在上述代码中，GetFirstK和GetLastK都是用二分查找算法在数组中查找一个合 乎要求的数字的，它们的时间复杂度都是 O(logn),因此 GetNuniberOfK的总的时间复杂度也只有O(logn)</p>
</blockquote>
<h3 id="题目二">题目二</h3>
<p>描述</p>
<blockquote>
<p>题目：一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0到n-1之内。在范围0到n-1的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
</blockquote>
<p>书本题解：<br>
  这个问题有一个直观的解决方案。我们可以先用公式n(n-1)/2求出数字0〜n-1的 所有数字之和，记为 s1。接着求出数组中所有数字的和，记为S2。那个不在数组中 的数字就是s1-s2的差。这种解法需要O(n)的时间求数组中所有数字的和。显然， 该解法没有有效利用数组是递增排序的这一特点。<br>
因为 0〜n-1 这些数字在数组中是排序的，因此数组中开始的一些数字与它们的下标相同。<br>
  由于m不在数组中，那么 m+1 处在下标为 m 的位置，m+2 处在下标为 m+1 的位置，以此类推。我们发现也正好是数组中第一个数值和下标不相等的下标，因此这 个问题转换成在排序数组中找出第一个值和下标不相等的元素。<br>
  我们可以基于二分查找的算法用如下过程查找:如果中间元素的值和 标相等， 那么下一轮查找只需要查找右半边;如果中间元素的值和下标不相等，并且它前面 一个元素和它的下标相等，这意味着这个中间的数字正好是第一个值和下标不相等的元素，它的下标就是在数组中不存在的数字;如果中间元素的值和下标不相等， 并且它前面一个元素和它的下标不相等，这意味着下一轮查找我们只需要在左半边查找即可。</p>
<pre><code>int GetMissingNumber(const int* numbers, int length)
{
    if(numbers == nullptr || length &lt;= 0)
        return -1;

    int left = 0;
    int right = length - 1;
    while(left &lt;= right)
    {
        int middle = (right + left) &gt;&gt; 1;
        if(numbers[middle] != middle)
        {
            if(middle == 0 || numbers[middle - 1] == middle - 1)
                return middle;
            right = middle - 1;
        }
        else
            left = middle + 1;
    }

    if(left == length)
        return length;

    // 无效的输入，比如数组不是按要求排序的，
    // 或者有数字不在0到n-1范围之内
    return -1;
}
</code></pre>
<h3 id="题目三">题目三</h3>
<p>描述</p>
<blockquote>
<p>假设一个单调递增的数组里的每个元素都是整数并且是唯一的。请编程实现一个函数找出数组中任意一个数值等于其下标的元素。例如，在数组{-3, -1,1, 3, 5}中，数字3和它的下标相等。</p>
</blockquote>
<p>题目描述<br>
从头到尾依次扫描数组中的数字， 并逐一检验数字是不是和下标相等。显然，这种算法的时间复杂度是O(n)。<br>
由于数组是单调递增排序的，因此我们可以尝试用二分查找算法来进行优化。<br>
假设数字的值为m。我们先考虑m大于i的情形，即数字的值大于它的下标。由于数组中的所有数字都唯一并且单调递增，那么对于任意大于0的如位于下标i+k的数字的值大于或等于m+k. 另外，因为 m&gt;i,所以,m+k &gt; i+k因此，位于下标 i+k 的数字的值一定大于它的下标。这意味着如果第 i 个数字的值大于i,那么它右边的数字都大于对应的下标，我们都可以忽略。下一轮查找我们只需要从它左边的数字中查找即可。<br>
数字的值小于它的下标 i 的情形和上面类似。</p>
<pre><code>int GetNumberSameAsIndex(const int* numbers, int length)
{
    if(numbers == nullptr || length &lt;= 0)
        return -1;

    int left = 0;
    int right = length - 1;
    while(left &lt;= right)
    {
        int middle = left + ((right - left) &gt;&gt; 1);
        if(numbers[middle] == middle)
            return middle;

        if(numbers[middle] &gt; middle)
            right = middle - 1;
        else
            left = middle + 1;
    }

    return -1;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[洗牌shuffle 384. 打乱数组]]></title>
        <id>https://lixin-scut.github.io//post/xi-pai-shuffle-384-da-luan-shu-zu</id>
        <link href="https://lixin-scut.github.io//post/xi-pai-shuffle-384-da-luan-shu-zu">
        </link>
        <updated>2020-03-07T03:01:12.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>打乱一个没有重复元素的数组。<br>
示例:<br>
// 以数字集合 1, 2 和 3 初始化数组。<br>
int[] nums = {1,2,3};<br>
Solution solution = new Solution(nums);<br>
// 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。<br>
solution.shuffle();<br>
// 重设数组到它的初始状态[1,2,3]。<br>
solution.reset();<br>
// 随机返回数组[1,2,3]打乱后的结果。<br>
solution.shuffle();<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/shuffle-an-array<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题其实就是针对洗牌算法而设，但是注意虽然主要功能是随机函数，但是我们的重点是实现随机函数，而是通过随机函数生成的随机数的实现打乱效果。<br>
这次的重点就是 学习C++自带的随机数生成 和 shuffle打乱洗牌算法</p>
<pre><code>class Solution {
public:
    Solution(vector&lt;int&gt;&amp; nums) {
        origNums = nums;
    }
    
    /** Resets the array to its original configuration and return it. */
    vector&lt;int&gt; reset() {
        return origNums;
    }
    
    
    /** Returns a random shuffling of the array. */
    /*
		// 取余法
    vector&lt;int&gt; shuffle() 
    {
        randNums = reset();
        int length = origNums.size();

        for(int cur = 0 ; cur &lt; length ; ++cur)
        {
            int randNum = rand() % (length - cur) + cur;
            swap(randNums[cur], randNums[randNum]);
        }
        
        return randNums;
    }
    */
    
		// 划定随机数范围 
    vector&lt;int&gt; shuffle() {
        randNums = reset();
        int length = origNums.size();
        // default_random_engine num;  //是不能放在这里的，否则每次调用都会重新定义
        for(int cur = 0; cur &lt; length; ++cur)
        {
            uniform_int_distribution&lt;unsigned&gt; num(cur,length-1);
            swap(randNums[cur], randNums[num(rand)]);
        }
        return randNums;
    }
    

private:
    default_random_engine rand; // 重点 得把随机引擎放在外面
    vector&lt;int&gt; randNums;
    vector&lt;int&gt; origNums;
};

/**
 * Your Solution object will be instantiated and called as such:
 * Solution* obj = new Solution(nums);
 * vector&lt;int&gt; param_1 = obj-&gt;reset();
 * vector&lt;int&gt; param_2 = obj-&gt;shuffle();
 */
</code></pre>
<p>可以看到实现还是很简单的，主要还是将排列组合的概率论思想转化为循环<br>
然后细节就是C++的随机数生成<br>
1.注意随机引擎不能每次都初始化，除非额外确定随机种子，否则必须保持只有一个随机引擎<br>
2.注意取余的除数选择，以及随机数范围的选择</p>
<p>网友题解：<br>
同样是比较长的网友题解，我就不画蛇添足了<br>
<a href="https://leetcode-cn.com/problems/shuffle-an-array/solution/xi-pai-suan-fa-shen-du-xiang-jie-by-labuladong/">洗牌算法深度详解</a></p>
<p>洗牌算法</p>
<p>此类算法都是靠随机选取元素交换来获取随机性，直接看代码（伪码），该算法有 4 种形式，都是正确的：</p>
<pre><code>// 得到一个在闭区间 [min, max] 内的随机整数
int randInt(int min, int max);

// 第一种写法
void shuffle(int[] arr) {
    int n = arr.length();
    /******** 区别只有这两行 ********/
    for (int i = 0 ; i &lt; n; i++) {
        // 从 i 到最后随机选一个元素
        int rand = randInt(i, n - 1);
        /*************************/
        swap(arr[i], arr[rand]);
    }
}

// 第二种写法
    for (int i = 0 ; i &lt; n - 1; i++)
        int rand = randInt(i, n - 1);

// 第三种写法
    for (int i = n - 1 ; i &gt;= 0; i--)
        int rand = randInt(0, i);

// 第四种写法
    for (int i = n - 1 ; i &gt; 0; i--)
        int rand = randInt(0, i);
</code></pre>
<blockquote>
<p>假设数组有五个元素，我们先用这个准则分析一下第一种写法的正确性：<br>
for 循环第一轮迭代时，i = 0，rand 的取值范围是 [0, 4]，有 5 个可能的取值。<br>
for 循环第二轮迭代时，i = 1，rand 的取值范围是 [1, 4]，有 4 个可能的取值。<br>
后面以此类推，直到最后一次迭代，i = 4，rand 的取值范围是 [4, 4]，只有 1 个可能的取值。<br>
可以看到，整个过程产生的所有可能结果有<code>n! = 5! = 5*4*3*2*1</code>种，所以这个算法是正确的。<br>
分析第二种写法，前面的迭代都是一样的，少了一次迭代而已。所以最后一次迭代时 i = 3，rand 的取值范围是 [3, 4]，有 2 个可能的取值。<br>
所以整个过程产生的所有可能结果仍然有<code>5*4*3*2 = 5! = n!</code>种，因为乘以 1 可有可无嘛。所以这种写法也是正确的。<br>
如果以上内容你都能理解，那么你就能发现第三种写法就是第一种写法，只是将数组从后往前迭代而已；第四种写法是第二种写法从后往前来。所以它们都是正确的。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ 初始化和初始值]]></title>
        <id>https://lixin-scut.github.io//post/c-chu-shi-hua-he-chu-shi-zhi</id>
        <link href="https://lixin-scut.github.io//post/c-chu-shi-hua-he-chu-shi-zhi">
        </link>
        <updated>2020-03-07T01:26:37.000Z</updated>
        <content type="html"><![CDATA[<p>首先确定一个概念：</p>
<blockquote>
<p>默认初始化：<br>
1.定义在任何函数体之外的内置类型变量会初始化为0<br>
2.定义在函数体内部的内置类型变量将不被初始化，此时变量的值是未定义的（undefined）（不可以输出）</p>
</blockquote>
<p>  也就是说，c语言中只有局部变量在未赋初值时，才是随机数，全局变量和静态变量未赋初值时编译器会自动将其初始化为0。</p>
<p>后来看了一下网友分析再结合自己的实验得出总结</p>
<ol>
<li>局部变量是分配在堆栈上的，而全局变量和静态变量是分配在数据段中的。所以初始化的值跟程序的内存分配是有关系的。</li>
<li>定义局部变量，其实就是在栈中通过移动栈指针来给程序提供一个内存空间和这个局部变量名绑定。因为这段内存空间在栈上，而栈内存是反复使用的（脏的，上次用完没清零的），所以说使用栈来实现的局部变量定义时如果不显式初始化，值就是脏的。</li>
<li>结合前面的博文<a href="https://lixin-scut.github.io/post/kong-zhi-zhen-ye-zhi-zhen-yu-kong-xuan-zhi-zhen/">空指针、野指针与空悬指针</a><br>
可以发现堆内存也是如此，并不是立即删除内存中的对象。</li>
<li>所以说随机值也不是说一定就是INT_MIN之类的，也不是用随机算法产生的值，它的意思就是这个值是未知的，不可以拿来使用</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 题52:两个链表的第一个公共结点]]></title>
        <id>https://lixin-scut.github.io//post/lian-biao-ti-52liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian</id>
        <link href="https://lixin-scut.github.io//post/lian-biao-ti-52liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian">
        </link>
        <updated>2020-03-07T00:11:59.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>输入两个链表，找出它们的第一个公共结点。</p>
</blockquote>
<p>最简单的就是hash set了，两次循环<br>
然后就是leetcode的方法，走到结尾后再从另一链表的头节点开始，两者会在目标节点相遇<br>
最后就是书中判断长度的方法，三次循环，先判断长度差，较长者先走n-m步</p>
<pre><code>/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
</code></pre>
<p>最简单的就是hash set了，两次循环<br>
然后就是leetcode的方法，走到结尾后再从另一链表的头节点开始，两者会在目标节点相遇<br>
最后就是书中判断长度的方法，三次循环，先判断长度差，较长者先走n-m步</p>
<p>实现注意事项<br>
哈希表：首先用逻辑或判断是否有节点为空，记得当前节点的next操作不要忘了<br>
长度差：可以用两个while来让程序自动判断长度差的正负，然后可以只判断一个节点是否为空，因为此时长度相同，就算没有公共节点也会同时到达尾节点<br>
leetcode方法：需要注意的就是两个链表没有公共节点的情况，此时最后两者会同时到达NULL，需要加上这个额外的条件</p>
<pre><code>class Solution {
public:
    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2){
        if(pHead1==NULL||pHead2==NULL)
            return NULL;
        
        ListNode *curNode1,*curNode2;
        curNode1=pHead1;
        curNode2=pHead2;
        while(curNode1!=curNode2){
            if(curNode1-&gt;next==NULL&amp;&amp;curNode2-&gt;next==NULL)
                return NULL;
            if(curNode1-&gt;next==NULL)
                curNode1=pHead2;
            else 
                curNode1=curNode1-&gt;next;
            if(curNode2-&gt;next==NULL)
                curNode2=pHead1;
            else 
                curNode2=curNode2-&gt;next;
        }
        return curNode1;
    }
    /*
    //长度差法
    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2){
        if(pHead1==NULL||pHead2==NULL)
            return NULL;
        
        int len1,len2;
        ListNode *curNode1,*curNode2;
        
        len1=0;
        curNode1=pHead1;
        while(curNode1){
            ++len1;
            curNode1=curNode1-&gt;next;
        }
        
        len2=0;
        curNode2=pHead2;
        while(curNode2){
            ++len2;
            curNode2=curNode2-&gt;next;
        }
        
        curNode1=pHead1;
        curNode2=pHead2;
        while(len1&gt;len2){
            curNode1=curNode1-&gt;next;
            --len1;
        }
        while(len2&gt;len1){
            curNode2=curNode2-&gt;next;
            --len1;
        }
        
        while(curNode1&amp;&amp;curNode1!=curNode2){
            curNode1=curNode1-&gt;next;
            curNode2=curNode2-&gt;next;
        }
        
        return curNode1;
    }
    
    //hashset
    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) {
        if(pHead1==NULL||pHead2==NULL)
            return NULL;
        unordered_set&lt;ListNode*&gt; nodeSet;
        ListNode* curNode=pHead1;
        while(curNode){
            nodeSet.insert(curNode);
            curNode=curNode-&gt;next;
        }
        curNode=pHead2;
        while(curNode){
            if(nodeSet.count(curNode))
                return curNode;
            curNode=curNode-&gt;next;
        }
        return NULL;
    }
    */
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>如果两个链表有公共节点，那么公共节点出现在两个链表的尾部。如果我们从两个链表的尾部开始往前比较，那么最后一个相同的节点就是我们要找的节点。可问题是，在单向链表中，我们只能从头节点开始按顺序遍历， 最后才能到达尾节点。最后到达的尾节点却要最先被比较，这听起来是不是像“后进先出”？于是我们就能想到用栈的特点来解决这个问题:分别把两个链表的节点放入两个栈里，这样两个链表的尾节点就位于两个栈的栈顶，接下来比较两个栈顶的节点是否相同。如果相同， 则把栈顶弹出接着比较下一个栈顶，直到找到最后一个相同的节点。空间复杂度是O(m+n)，这种思路的时间复杂度也是O(m+n)<br>
其实解决这个问题还有一种更简单的办法:首先遍历两个链 表得到它们的长度， 就能知道哪个链表比较长，以及长的链表比短的链表多 几个节点。在第二次遍历 的时候，在较长的链表上先走若干步，接着同时在 两个链表上遍历，找到的第一 个相同的节点就是它们的第一个公共节点。</p>
</blockquote>
<pre><code>ListNode* FindFirstCommonNode(ListNode *pHead1, ListNode *pHead2)
{
    // 得到两个链表的长度
    unsigned int nLength1 = GetListLength(pHead1);
    unsigned int nLength2 = GetListLength(pHead2);
    int nLengthDif = nLength1 - nLength2;

    ListNode* pListHeadLong = pHead1;
    ListNode* pListHeadShort = pHead2;
    if(nLength2 &gt; nLength1)
    {
        pListHeadLong = pHead2;
        pListHeadShort = pHead1;
        nLengthDif = nLength2 - nLength1;
    }

    // 先在长链表上走几步，再同时在两个链表上遍历
    for(int i = 0; i &lt; nLengthDif; ++i)
        pListHeadLong = pListHeadLong-&gt;m_pNext;

    while((pListHeadLong != nullptr) &amp;&amp;
        (pListHeadShort != nullptr) &amp;&amp;
        (pListHeadLong != pListHeadShort))
    {
        pListHeadLong = pListHeadLong-&gt;m_pNext;
        pListHeadShort = pListHeadShort-&gt;m_pNext;
    }

    // 得到第一个公共结点
    ListNode* pFisrtCommonNode = pListHeadLong;

    return pFisrtCommonNode;
}

unsigned int GetListLength(ListNode* pHead)
{
    unsigned int nLength = 0;
    ListNode* pNode = pHead;
    while(pNode != nullptr)
    {
        ++nLength;
        pNode = pNode-&gt;m_pNext;
    }

    return nLength;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 题51:数组中的逆序对]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-ti-51shu-zu-zhong-de-ni-xu-dui</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-ti-51shu-zu-zhong-de-ni-xu-dui">
        </link>
        <updated>2020-03-07T00:05:23.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p>
</blockquote>
<p>【未做出】<br>
一开始并没有什么思路，只能先从暴力法寻找思路<br>
实现暴力法的时候不小心把小于号打成大于号了。。。<br>
不知道为啥显示不通过一个用例，但是这个用例非常长，估计就是超时了<br>
然后就是希望往时间复杂度O(n)努力，同时肯定需要牺牲空间复杂度<br>
第一个想法是保存排序已经循环的数组，然后判断新的元素的位置，这样利用二分法可以将复杂度压低到O(nlogn)（注意插入还是导致时间复杂度为O（n））<br>
还是看了书本答案 发现是归并排序法</p>
<pre><code>class Solution {
public:
    //我fo了，不知道牛客网哪里出错了，超长用例就是通过不了
    /*
    int InversePairs(vector&lt;int&gt; data){
        if(data.empty())
            return 0;
        vector&lt;int&gt; temp(data.begin(),data.end());
        
        return InversePairs(data,temp,0,data.size()-1)%1000000007;
    }
    
    int InversePairs(vector&lt;int&gt; &amp;data,vector&lt;int&gt; &amp;temp,int beg,int end){
        if(beg==end){
            temp[beg]=data[beg];
            return 0;
        }
        int mid=beg+(end-beg)/2;
        int left=InversePairs(temp,data,beg,mid);
        int right=InversePairs(temp,data,mid+1,end);
        int minP,maxP,locate,count;
        minP=mid;
        maxP=end;
        locate=end;
        count=0;
        while(minP&gt;=beg&amp;&amp;maxP&gt;=mid+1){
            if(data[minP]&lt;=data[maxP]){
                temp[locate]=data[maxP];
                --maxP;
                --locate;
            }else{
                count+=maxP-mid;
                temp[locate]=data[minP];
                --minP;
                --locate;
            }
        }
        while(maxP&gt;=mid+1){
            temp[locate]=data[maxP];
            --maxP;
            --locate;
        }
        while(minP&gt;=beg){
            temp[locate]=data[minP];
            --minP;
            --locate;
        }
        return left+right+count;
    }
    */
    
    
    /*
    //暴力法【超时】
    int InversePairs(vector&lt;int&gt; data) {
        if(data.empty())
            return 0;
        int len=data.size();
        int count=0;
        for(int i=0;i&lt;len-1;++i)
            for(int j=i+1;j&lt;len;++j){
                if(data[j]&lt;data[i])
                    ++count;
            }
        return count%1000000007;
    }
    */
};
</code></pre>
<p>书本题解<br>
<img src="https://lixin-scut.github.io//post-images/1583539828823.png" alt=""></p>
<blockquote>
<p>我们先用两个指针分别指向两个子数组的末尾，并每次比较两个指针指向的数 字。如果第一个子数组中的数字大于第二个子数组中的数字，则构成逆序对，并且逆序对的数目等于第二个子数组中剩余数字的个数。如果第一个数组中的数字小于或等于第二个 数组中的数字，则不构成逆序对。每次比较的时候， 我们都把较大的数字从后往前复制到一 个辅助数组，确保辅助数组中的数字是递增排序的。在把较大的数字复制到辅助数组之后，把对应的指针向 前移动一位，接下来进行下一轮比较。</p>
</blockquote>
<pre><code>int InversePairs(int* data, int length)
{
    if(data == nullptr || length &lt; 0)
        return 0;

    int* copy = new int[length];
    for(int i = 0; i &lt; length; ++i)
        copy[i] = data[i];

    int count = InversePairsCore(data, copy, 0, length - 1);
    delete[] copy;

    return count;
}

int InversePairsCore(int* data, int* copy, int start, int end)
{
    if(start == end)
    {
        copy[start] = data[start];
        return 0;
    }

    int length = (end - start) / 2;

    int left = InversePairsCore(copy, data, start, start + length);
    int right = InversePairsCore(copy, data, start + length + 1, end);

    // i初始化为前半段最后一个数字的下标
    int i = start + length;
    // j初始化为后半段最后一个数字的下标
    int j = end;
    int indexCopy = end;
    int count = 0;
    while(i &gt;= start &amp;&amp; j &gt;= start + length + 1)
    {
        if(data[i] &gt; data[j])
        {
            copy[indexCopy--] = data[i--];
            count += j - start - length;
        }
        else
        {
            copy[indexCopy--] = data[j--];
        }
    }

    for(; i &gt;= start; --i)
        copy[indexCopy--] = data[i];

    for(; j &gt;= start + length + 1; --j)
        copy[indexCopy--] = data[j];

    return left + right + count;
}
</code></pre>
]]></content>
    </entry>
</feed>