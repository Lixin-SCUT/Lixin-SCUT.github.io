<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lixin-scut.github.io/</id>
    <title>Lixin-SCUT</title>
    <updated>2020-03-08T03:07:31.109Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lixin-scut.github.io/"/>
    <link rel="self" href="https://lixin-scut.github.io//atom.xml"/>
    <subtitle>In the darkest night,Rising like a spire.</subtitle>
    <logo>https://lixin-scut.github.io//images/avatar.png</logo>
    <icon>https://lixin-scut.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Lixin-SCUT</rights>
    <entry>
        <title type="html"><![CDATA[快速排序 partition ]]></title>
        <id>https://lixin-scut.github.io//post/kuai-su-pai-xu-partition</id>
        <link href="https://lixin-scut.github.io//post/kuai-su-pai-xu-partition">
        </link>
        <updated>2020-03-08T03:03:39.000Z</updated>
        <content type="html"><![CDATA[<p>做对这道题需要熟悉快速排序的 partition 过程。</p>
<p>partition 过程经过一次扫描把整个数组分成三个部分，正好符合这个问题的场景。<br>
写对这道题的方法是，把我们对循环不变量的定义作为注释先写出来，然后再编码。<br>
（以下是复习 partition 过程，与本题解法无直接关系，直接跳过不影响后续内容的阅读。）</p>
<p>下面的动画，从一个中间的状态开始演示，直到 partition 完成。</p>
<p>如果循环不变量是这样定义的：</p>
<p>所有在子区间 [0, zero) 的元素都等于 0；<br>
所有在子区间 [zero, i) 的元素都等于 1；<br>
所有在子区间 [two, len - 1] 的元素都等于 2。<br>
说明：设计循环不变量的原则是“不重不漏”。</p>
<p>1、len 是数组的长度；<br>
2、变量 zero 是前两个子区间的分界点，一个是闭区间，另一个就必须是开区间；<br>
3、变量 i 是循环变量，一般设置为开区间，表示 i 之前的元素是遍历过的；<br>
4、two 是另一个分界线，我设计成闭区间。</p>
<p>于是编码要解决以下三个问题：</p>
<p>变量初始化应该如何定义。<br>
在遍历的时候，是先加减还是先交换。<br>
什么时候循环终止。<br>
处理这三个问题，完全看循环不变量的定义。</p>
<p>编码的时候，zero 和 two 初始化的值就应该保证上面的三个子区间全为空。<br>
在遍历的过程中，“索引先加减再交换”、还是“先交换再加减”就看初始化的时候变量在哪里。<br>
退出循环的条件也看上面定义的循环不变量，在 i == two 成立的时候，上面的三个子区间就正好“不重不漏”地覆盖了整个数组，并且给出的性质成立，题目的任务也就完成了。</p>
<p>体会是：<br>
编码者应该在代码中使用注释表达这段代码编写的算法思想，提醒自己也方便他人。<br>
但是源代码中类似 ++k &lt;= great 和 a[++left] &gt;= a[left - 1] 这样的代码建议不要写，会给阅读者带来理解上的障碍，变量的值发生变化是一个很重要的逻辑，应该单独成为一行，否则不利于调试和以后定位问题。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 75:颜色分类[中等][未做出]]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-75yan-se-fen-lei-zhong-deng-wei-zuo-chu</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-75yan-se-fen-lei-zhong-deng-wei-zuo-chu">
        </link>
        <updated>2020-03-08T02:52:32.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：</p>
<blockquote>
<p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。<br>
此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。<br>
注意:<br>
不能使用代码库中的排序函数来解决这道题。<br>
示例:<br>
输入: [2,0,2,1,1,0]<br>
输出: [0,0,1,1,2,2]<br>
进阶：<br>
一个直观的解决方案是使用计数排序的两趟扫描算法。<br>
首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。<br>
你能想出一个仅使用常数空间的一趟扫描算法吗？<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/sort-colors<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题是腾讯的面试题之一<br>
然后我一开始的想法也是三指针partition，left和right分别管理0的区域和2的区域，然后curNum管理当前值。<br>
但是一开始我使用的是比较法，没有充分利用数字取值范围的特点（只有0，1，2），所以导致漏掉了很多情况，并且必须无限循环保证从交换回来的数字需要多次swap的情况能够正常运行。<br>
最后还是参考了官网题解，发现确实是三分法，但是需要利用好数值这个特性，并且重点是什么时候需要++curNum什么时候不需要！</p>
<p>最后我的代码：</p>
<pre><code>class Solution {
public:
    void sortColors(vector&lt;int&gt;&amp; nums) {
        size_t length = nums.size();
        if(length &lt; 1)
            return;
        int left;
        int right;
        int curNum;
        left = 0;
        right = length - 1;
        curNum = 0;
        while(curNum &lt;= right)
        {
            switch(nums[curNum])
            {
                case 0:
                    swap(nums[left], nums[curNum]);
                    ++left;
                    ++curNum;
                    break;
                case 1:
                    ++curNum;
                    break;
                case 2:
                    swap(nums[right], nums[curNum]);
                    --right;
                    break;
            }
        }
    }
};
</code></pre>
<p>官网题解：</p>
<blockquote>
<p>方法一: 一次遍历<br>
我们用三个指针（p0, p2 和curr）来分别追踪0的最右边界，2的最左边界和当前考虑的元素。<br>
<img src="https://lixin-scut.github.io//post-images/1583636318887.png" alt=""><br>
本解法的思路是沿着数组移动 curr 指针，若nums[curr] = 0，则将其与 nums[p0]互换；若 nums[curr] = 2 ，则与 nums[p2]互换。<br>
算法<br>
初始化0的最右边界：p0 = 0。在整个算法执行过程中 nums[idx &lt; p0] = 0.<br>
初始化2的最左边界 ：p2 = n - 1。在整个算法执行过程中 nums[idx &gt; p2] = 2.<br>
初始化当前考虑的元素序号 ：curr = 0.<br>
While curr &lt;= p2 :<br>
若 nums[curr] = 0 ：交换第 curr个 和 第p0个 元素，并将指针都向右移。<br>
若 nums[curr] = 2 ：交换第 curr个和第 p2个元素，并将 p2指针左移 。<br>
若 nums[curr] = 1 ：将指针curr右移。</p>
</blockquote>
<pre><code>class Solution {
  public:
  /*
  荷兰三色旗问题解
  */
  void sortColors(vector&lt;int&gt;&amp; nums) {
    // 对于所有 idx &lt; p0 : nums[idx &lt; p0] = 0
    // curr 是当前考虑元素的下标
    int p0 = 0, curr = 0;
    // 对于所有 idx &gt; p2 : nums[idx &gt; p2] = 2
    int p2 = nums.size() - 1;

    while (curr &lt;= p2) {
      if (nums[curr] == 0) {
        swap(nums[curr++], nums[p0++]);
      }
      else if (nums[curr] == 2) {
        swap(nums[curr], nums[p2--]);
      }
      else curr++;
    }
  }
};

作者：LeetCode
链接：https://leetcode-cn.com/problems/sort-colors/solution/yan-se-fen-lei-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<p>另外一个介绍partition的题解<a href="https://leetcode-cn.com/problems/sort-colors/solution/kuai-su-pai-xu-partition-guo-cheng-she-ji-xun-huan/">快速排序 partition 过程</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树 题54:二叉搜索树的第k个结点]]></title>
        <id>https://lixin-scut.github.io//post/shu-ti-54er-cha-sou-suo-shu-de-di-k-ge-jie-dian</id>
        <link href="https://lixin-scut.github.io//post/shu-ti-54er-cha-sou-suo-shu-de-di-k-ge-jie-dian">
        </link>
        <updated>2020-03-08T00:42:30.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。</p>
</blockquote>
<pre><code>/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};
*/
</code></pre>
<p>【未做出】<br>
没什么特别的，就是复习一下迭代中序遍历吧<br>
尴尬，还是没做出，主要是就是卡在右子树的进栈那里了，通过右子树和进出栈配合从而保证左子树不会重复入栈</p>
<pre><code>class Solution {
public:
    TreeNode* KthNode(TreeNode* pRoot, int k)
    {
        if(k&lt;=0 || pRoot == NULL)
            return NULL;
        stack&lt;TreeNode*&gt; nodeStack;
        TreeNode* curNode;
        curNode = pRoot;
        while(curNode||nodeStack.size())
        {
            while(curNode){
                nodeStack.push(curNode);
                curNode = curNode-&gt;left;
            }
            curNode = nodeStack.top();
            nodeStack.pop();
            --k;
            if(k==0)
                return curNode;
            curNode = curNode-&gt;right;
        }
        return NULL;
    }
};
</code></pre>
<p>书本题解：<br>
如果按照中序遍历的顺序遍历一棵二叉搜索树，则遍历序列的数值是递增排序的。</p>
<pre><code>const BinaryTreeNode* KthNode(const BinaryTreeNode* pRoot, unsigned int k)
{
    if(pRoot == nullptr || k == 0)
        return nullptr;

    return KthNodeCore(pRoot, k);
}

const BinaryTreeNode* KthNodeCore(const BinaryTreeNode* pRoot, unsigned int&amp; k)
{
    const BinaryTreeNode* target = nullptr;

    if(pRoot-&gt;m_pLeft != nullptr)
        target = KthNodeCore(pRoot-&gt;m_pLeft, k);

    if(target == nullptr)
    {
        if(k == 1)
            target = pRoot;

        k--;
    }

    if(target == nullptr &amp;&amp; pRoot-&gt;m_pRight != nullptr)
        target = KthNodeCore(pRoot-&gt;m_pRight, k);

    return target;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 题53:在排序数组中查找数字]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-ti-53zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-ti-53zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi">
        </link>
        <updated>2020-03-08T00:19:27.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题目一">题目一</h3>
<p>描述</p>
<blockquote>
<p>统计一个数字在排序数组中出现的次数。</p>
</blockquote>
<p>暴力法就是循环，时间复杂度是O(n),空间复杂度O(1)，所以优化方向自然是O(logn)了<br>
那自然也就二分法啦hhh，第一想法就是第一次二分找到最右的n，第二次二分找到最左的n，两者的位置相减就得到结果<br>
难点：当第一个元素或者最后一个元素是K时，必须正确返回位置，当数组不存在K时，返回的位置应该一致<br>
所以一定要注意两个函数的mid取值</p>
<p>然后发现（当数组不存在K时，返回的位置应该一致）是错误的，比如[3,4,6,7]中找5，就会返回4和6的位置，这时必须加上判断是否等于k才行，<br>
边缘情况同理，不能简单地right-left+1，否则会返回1</p>
<pre><code>class Solution {
public:
    int GetNumberOfK(vector&lt;int&gt; data ,int k) {
        if(data.empty())
            return 0;
        int left=GetLeftK(data ,k,0,data.size()-1);
        int right=GetRightK(data ,k,0,data.size()-1);
        if(data[left]!=k)
            return 0;
        return right-left+1;
    }
    
    int GetRightK(vector&lt;int&gt; &amp;data ,int k,int beg,int end){
        if(beg==end)
            return beg;
        int mid=beg+(end-beg+1)/2;
        if(data[mid]&lt;=k)
            return GetRightK(data,k,mid,end);
        else if(data[mid]&gt;k)
            return GetRightK(data,k,beg,mid-1);
    }
    int GetLeftK(vector&lt;int&gt; &amp;data ,int k,int beg,int end){
        if(beg==end)
            return beg;
        int mid=beg+(end-beg)/2;
        if(data[mid]&gt;=k)
            return GetLeftK(data,k,beg,mid);
        else if(data[mid]&lt;k)
            return GetLeftK(data,k,mid+1,end);
    }
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>  先分析如何用二分查找算法在数组中找到第一个k，二分查找算法总是先拿数组中间的数字和k作比较。如果中间的数字比k大，那么k只有可能出现在数组的前半段，下一轮我们只在数组的前半段查找就可以 了。如果中间的数字比左小，那么比 只有可能出现在数组的后半段，下一 轮我们只在数组的后半段查找就可以了。如果中间的数字和 k 相等呢?我 们先判断这个数字是不是第一个 k，如果中间数字的前面一个 数字不是 k,，那么此时中间的数字刚好就是第一个 k。如果中间数字的前面一个数字也是 k,那么第一个k肯定在数组的前半段，下一轮我们仍然需要在数组的前半段查找。<br>
  我们可以用同样的思路在排序数组中找到最后一个k，如果中间数字比 k大，那 么k只能出现在数组的前半段。如果中间数字比 k 小，那么k只能出现在数组的后半段。如果中间数字等于 k 呢?我们需要判断这个 k 是不是最后一个k，也就是中间数字的下一个数字是不是也等于k，如果下一个数字不是则中间数字就是最后一个k，否则下一轮我们还是要在数组的后 段中去查找。</p>
</blockquote>
<pre><code>int GetNumberOfK(const int* data, int length, int k)
{
    int number = 0;

    if(data != nullptr &amp;&amp; length &gt; 0)
    {
        int first = GetFirstK(data, length, k, 0, length - 1);
        int last = GetLastK(data, length, k, 0, length - 1);
        
        if(first &gt; -1 &amp;&amp; last &gt; -1)
            number = last - first + 1;
    }

    return number;
}

// 找到数组中第一个k的下标。如果数组中不存在k，返回-1
int GetFirstK(const int* data, int length, int k, int start, int end)
{
    if(start &gt; end)
        return -1;

    int middleIndex = (start + end) / 2;
    int middleData = data[middleIndex];

    if(middleData == k)
    {
        if((middleIndex &gt; 0 &amp;&amp; data[middleIndex - 1] != k) 
            || middleIndex == 0)
            return middleIndex;
        else
            end  = middleIndex - 1;
    }
    else if(middleData &gt; k)
        end = middleIndex - 1;
    else
        start = middleIndex + 1;

    return GetFirstK(data, length, k, start, end);
}

// 找到数组中最后一个k的下标。如果数组中不存在k，返回-1
int GetLastK(const int* data, int length, int k, int start, int end)
{
    if(start &gt; end)
        return -1;

    int middleIndex = (start + end) / 2;
    int middleData = data[middleIndex];

    if(middleData == k)
    {
        if((middleIndex &lt; length - 1 &amp;&amp; data[middleIndex + 1] != k) 
            || middleIndex == length - 1)
            return middleIndex;
        else
            start  = middleIndex + 1;
    }
    else if(middleData &lt; k)
        start = middleIndex + 1;
    else
        end = middleIndex - 1;

    return GetLastK(data, length, k, start, end);
}

</code></pre>
<blockquote>
<p>  在上述代码中，GetFirstK和GetLastK都是用二分查找算法在数组中查找一个合 乎要求的数字的，它们的时间复杂度都是 O(logn),因此 GetNuniberOfK的总的时间复杂度也只有O(logn)</p>
</blockquote>
<h3 id="题目二">题目二</h3>
<p>描述</p>
<blockquote>
<p>题目：一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0到n-1之内。在范围0到n-1的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
</blockquote>
<p>书本题解：<br>
  这个问题有一个直观的解决方案。我们可以先用公式n(n-1)/2求出数字0〜n-1的 所有数字之和，记为 s1。接着求出数组中所有数字的和，记为S2。那个不在数组中 的数字就是s1-s2的差。这种解法需要O(n)的时间求数组中所有数字的和。显然， 该解法没有有效利用数组是递增排序的这一特点。<br>
因为 0〜n-1 这些数字在数组中是排序的，因此数组中开始的一些数字与它们的下标相同。<br>
  由于m不在数组中，那么 m+1 处在下标为 m 的位置，m+2 处在下标为 m+1 的位置，以此类推。我们发现也正好是数组中第一个数值和下标不相等的下标，因此这 个问题转换成在排序数组中找出第一个值和下标不相等的元素。<br>
  我们可以基于二分查找的算法用如下过程查找:如果中间元素的值和 标相等， 那么下一轮查找只需要查找右半边;如果中间元素的值和下标不相等，并且它前面 一个元素和它的下标相等，这意味着这个中间的数字正好是第一个值和下标不相等的元素，它的下标就是在数组中不存在的数字;如果中间元素的值和下标不相等， 并且它前面一个元素和它的下标不相等，这意味着下一轮查找我们只需要在左半边查找即可。</p>
<pre><code>int GetMissingNumber(const int* numbers, int length)
{
    if(numbers == nullptr || length &lt;= 0)
        return -1;

    int left = 0;
    int right = length - 1;
    while(left &lt;= right)
    {
        int middle = (right + left) &gt;&gt; 1;
        if(numbers[middle] != middle)
        {
            if(middle == 0 || numbers[middle - 1] == middle - 1)
                return middle;
            right = middle - 1;
        }
        else
            left = middle + 1;
    }

    if(left == length)
        return length;

    // 无效的输入，比如数组不是按要求排序的，
    // 或者有数字不在0到n-1范围之内
    return -1;
}
</code></pre>
<h3 id="题目三">题目三</h3>
<p>描述</p>
<blockquote>
<p>假设一个单调递增的数组里的每个元素都是整数并且是唯一的。请编程实现一个函数找出数组中任意一个数值等于其下标的元素。例如，在数组{-3, -1,1, 3, 5}中，数字3和它的下标相等。</p>
</blockquote>
<p>题目描述<br>
从头到尾依次扫描数组中的数字， 并逐一检验数字是不是和下标相等。显然，这种算法的时间复杂度是O(n)。<br>
由于数组是单调递增排序的，因此我们可以尝试用二分查找算法来进行优化。<br>
假设数字的值为m。我们先考虑m大于i的情形，即数字的值大于它的下标。由于数组中的所有数字都唯一并且单调递增，那么对于任意大于0的如位于下标i+k的数字的值大于或等于m+k. 另外，因为 m&gt;i,所以,m+k &gt; i+k因此，位于下标 i+k 的数字的值一定大于它的下标。这意味着如果第 i 个数字的值大于i,那么它右边的数字都大于对应的下标，我们都可以忽略。下一轮查找我们只需要从它左边的数字中查找即可。<br>
数字的值小于它的下标 i 的情形和上面类似。</p>
<pre><code>int GetNumberSameAsIndex(const int* numbers, int length)
{
    if(numbers == nullptr || length &lt;= 0)
        return -1;

    int left = 0;
    int right = length - 1;
    while(left &lt;= right)
    {
        int middle = left + ((right - left) &gt;&gt; 1);
        if(numbers[middle] == middle)
            return middle;

        if(numbers[middle] &gt; middle)
            right = middle - 1;
        else
            left = middle + 1;
    }

    return -1;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[洗牌shuffle 384. 打乱数组]]></title>
        <id>https://lixin-scut.github.io//post/xi-pai-shuffle-384-da-luan-shu-zu</id>
        <link href="https://lixin-scut.github.io//post/xi-pai-shuffle-384-da-luan-shu-zu">
        </link>
        <updated>2020-03-07T03:01:12.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>打乱一个没有重复元素的数组。<br>
示例:<br>
// 以数字集合 1, 2 和 3 初始化数组。<br>
int[] nums = {1,2,3};<br>
Solution solution = new Solution(nums);<br>
// 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。<br>
solution.shuffle();<br>
// 重设数组到它的初始状态[1,2,3]。<br>
solution.reset();<br>
// 随机返回数组[1,2,3]打乱后的结果。<br>
solution.shuffle();<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/shuffle-an-array<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题其实就是针对洗牌算法而设，但是注意虽然主要功能是随机函数，但是我们的重点是实现随机函数，而是通过随机函数生成的随机数的实现打乱效果。<br>
这次的重点就是 学习C++自带的随机数生成 和 shuffle打乱洗牌算法</p>
<pre><code>class Solution {
public:
    Solution(vector&lt;int&gt;&amp; nums) {
        origNums = nums;
    }
    
    /** Resets the array to its original configuration and return it. */
    vector&lt;int&gt; reset() {
        return origNums;
    }
    
    
    /** Returns a random shuffling of the array. */
    /*
		// 取余法
    vector&lt;int&gt; shuffle() 
    {
        randNums = reset();
        int length = origNums.size();

        for(int cur = 0 ; cur &lt; length ; ++cur)
        {
            int randNum = rand() % (length - cur) + cur;
            swap(randNums[cur], randNums[randNum]);
        }
        
        return randNums;
    }
    */
    
		// 划定随机数范围 
    vector&lt;int&gt; shuffle() {
        randNums = reset();
        int length = origNums.size();
        // default_random_engine num;  //是不能放在这里的，否则每次调用都会重新定义
        for(int cur = 0; cur &lt; length; ++cur)
        {
            uniform_int_distribution&lt;unsigned&gt; num(cur,length-1);
            swap(randNums[cur], randNums[num(rand)]);
        }
        return randNums;
    }
    

private:
    default_random_engine rand; // 重点 得把随机引擎放在外面
    vector&lt;int&gt; randNums;
    vector&lt;int&gt; origNums;
};

/**
 * Your Solution object will be instantiated and called as such:
 * Solution* obj = new Solution(nums);
 * vector&lt;int&gt; param_1 = obj-&gt;reset();
 * vector&lt;int&gt; param_2 = obj-&gt;shuffle();
 */
</code></pre>
<p>可以看到实现还是很简单的，主要还是将排列组合的概率论思想转化为循环<br>
然后细节就是C++的随机数生成<br>
1.注意随机引擎不能每次都初始化，除非额外确定随机种子，否则必须保持只有一个随机引擎<br>
2.注意取余的除数选择，以及随机数范围的选择</p>
<p>网友题解：<br>
同样是比较长的网友题解，我就不画蛇添足了<br>
<a href="https://leetcode-cn.com/problems/shuffle-an-array/solution/xi-pai-suan-fa-shen-du-xiang-jie-by-labuladong/">洗牌算法深度详解</a></p>
<p>洗牌算法</p>
<p>此类算法都是靠随机选取元素交换来获取随机性，直接看代码（伪码），该算法有 4 种形式，都是正确的：</p>
<pre><code>// 得到一个在闭区间 [min, max] 内的随机整数
int randInt(int min, int max);

// 第一种写法
void shuffle(int[] arr) {
    int n = arr.length();
    /******** 区别只有这两行 ********/
    for (int i = 0 ; i &lt; n; i++) {
        // 从 i 到最后随机选一个元素
        int rand = randInt(i, n - 1);
        /*************************/
        swap(arr[i], arr[rand]);
    }
}

// 第二种写法
    for (int i = 0 ; i &lt; n - 1; i++)
        int rand = randInt(i, n - 1);

// 第三种写法
    for (int i = n - 1 ; i &gt;= 0; i--)
        int rand = randInt(0, i);

// 第四种写法
    for (int i = n - 1 ; i &gt; 0; i--)
        int rand = randInt(0, i);
</code></pre>
<blockquote>
<p>假设数组有五个元素，我们先用这个准则分析一下第一种写法的正确性：<br>
for 循环第一轮迭代时，i = 0，rand 的取值范围是 [0, 4]，有 5 个可能的取值。<br>
for 循环第二轮迭代时，i = 1，rand 的取值范围是 [1, 4]，有 4 个可能的取值。<br>
后面以此类推，直到最后一次迭代，i = 4，rand 的取值范围是 [4, 4]，只有 1 个可能的取值。<br>
可以看到，整个过程产生的所有可能结果有<code>n! = 5! = 5*4*3*2*1</code>种，所以这个算法是正确的。<br>
分析第二种写法，前面的迭代都是一样的，少了一次迭代而已。所以最后一次迭代时 i = 3，rand 的取值范围是 [3, 4]，有 2 个可能的取值。<br>
所以整个过程产生的所有可能结果仍然有<code>5*4*3*2 = 5! = n!</code>种，因为乘以 1 可有可无嘛。所以这种写法也是正确的。<br>
如果以上内容你都能理解，那么你就能发现第三种写法就是第一种写法，只是将数组从后往前迭代而已；第四种写法是第二种写法从后往前来。所以它们都是正确的。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ 初始化和初始值]]></title>
        <id>https://lixin-scut.github.io//post/c-chu-shi-hua-he-chu-shi-zhi</id>
        <link href="https://lixin-scut.github.io//post/c-chu-shi-hua-he-chu-shi-zhi">
        </link>
        <updated>2020-03-07T01:26:37.000Z</updated>
        <content type="html"><![CDATA[<p>首先确定一个概念：</p>
<blockquote>
<p>默认初始化：<br>
1.定义在任何函数体之外的内置类型变量会初始化为0<br>
2.定义在函数体内部的内置类型变量将不被初始化，此时变量的值是未定义的（undefined）（不可以输出）</p>
</blockquote>
<p>  也就是说，c语言中只有局部变量在未赋初值时，才是随机数，全局变量和静态变量未赋初值时编译器会自动将其初始化为0。</p>
<p>后来看了一下网友分析再结合自己的实验得出总结</p>
<ol>
<li>局部变量是分配在堆栈上的，而全局变量和静态变量是分配在数据段中的。所以初始化的值跟程序的内存分配是有关系的。</li>
<li>定义局部变量，其实就是在栈中通过移动栈指针来给程序提供一个内存空间和这个局部变量名绑定。因为这段内存空间在栈上，而栈内存是反复使用的（脏的，上次用完没清零的），所以说使用栈来实现的局部变量定义时如果不显式初始化，值就是脏的。</li>
<li>结合前面的博文<a href="https://lixin-scut.github.io/post/kong-zhi-zhen-ye-zhi-zhen-yu-kong-xuan-zhi-zhen/">空指针、野指针与空悬指针</a><br>
可以发现堆内存也是如此，并不是立即删除内存中的对象。</li>
<li>所以说随机值也不是说一定就是INT_MIN之类的，也不是用随机算法产生的值，它的意思就是这个值是未知的，不可以拿来使用</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表 题52:两个链表的第一个公共结点]]></title>
        <id>https://lixin-scut.github.io//post/lian-biao-ti-52liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian</id>
        <link href="https://lixin-scut.github.io//post/lian-biao-ti-52liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian">
        </link>
        <updated>2020-03-07T00:11:59.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>输入两个链表，找出它们的第一个公共结点。</p>
</blockquote>
<p>最简单的就是hash set了，两次循环<br>
然后就是leetcode的方法，走到结尾后再从另一链表的头节点开始，两者会在目标节点相遇<br>
最后就是书中判断长度的方法，三次循环，先判断长度差，较长者先走n-m步</p>
<pre><code>/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
</code></pre>
<p>最简单的就是hash set了，两次循环<br>
然后就是leetcode的方法，走到结尾后再从另一链表的头节点开始，两者会在目标节点相遇<br>
最后就是书中判断长度的方法，三次循环，先判断长度差，较长者先走n-m步</p>
<p>实现注意事项<br>
哈希表：首先用逻辑或判断是否有节点为空，记得当前节点的next操作不要忘了<br>
长度差：可以用两个while来让程序自动判断长度差的正负，然后可以只判断一个节点是否为空，因为此时长度相同，就算没有公共节点也会同时到达尾节点<br>
leetcode方法：需要注意的就是两个链表没有公共节点的情况，此时最后两者会同时到达NULL，需要加上这个额外的条件</p>
<pre><code>class Solution {
public:
    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2){
        if(pHead1==NULL||pHead2==NULL)
            return NULL;
        
        ListNode *curNode1,*curNode2;
        curNode1=pHead1;
        curNode2=pHead2;
        while(curNode1!=curNode2){
            if(curNode1-&gt;next==NULL&amp;&amp;curNode2-&gt;next==NULL)
                return NULL;
            if(curNode1-&gt;next==NULL)
                curNode1=pHead2;
            else 
                curNode1=curNode1-&gt;next;
            if(curNode2-&gt;next==NULL)
                curNode2=pHead1;
            else 
                curNode2=curNode2-&gt;next;
        }
        return curNode1;
    }
    /*
    //长度差法
    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2){
        if(pHead1==NULL||pHead2==NULL)
            return NULL;
        
        int len1,len2;
        ListNode *curNode1,*curNode2;
        
        len1=0;
        curNode1=pHead1;
        while(curNode1){
            ++len1;
            curNode1=curNode1-&gt;next;
        }
        
        len2=0;
        curNode2=pHead2;
        while(curNode2){
            ++len2;
            curNode2=curNode2-&gt;next;
        }
        
        curNode1=pHead1;
        curNode2=pHead2;
        while(len1&gt;len2){
            curNode1=curNode1-&gt;next;
            --len1;
        }
        while(len2&gt;len1){
            curNode2=curNode2-&gt;next;
            --len1;
        }
        
        while(curNode1&amp;&amp;curNode1!=curNode2){
            curNode1=curNode1-&gt;next;
            curNode2=curNode2-&gt;next;
        }
        
        return curNode1;
    }
    
    //hashset
    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) {
        if(pHead1==NULL||pHead2==NULL)
            return NULL;
        unordered_set&lt;ListNode*&gt; nodeSet;
        ListNode* curNode=pHead1;
        while(curNode){
            nodeSet.insert(curNode);
            curNode=curNode-&gt;next;
        }
        curNode=pHead2;
        while(curNode){
            if(nodeSet.count(curNode))
                return curNode;
            curNode=curNode-&gt;next;
        }
        return NULL;
    }
    */
};
</code></pre>
<p>书本题解：</p>
<blockquote>
<p>如果两个链表有公共节点，那么公共节点出现在两个链表的尾部。如果我们从两个链表的尾部开始往前比较，那么最后一个相同的节点就是我们要找的节点。可问题是，在单向链表中，我们只能从头节点开始按顺序遍历， 最后才能到达尾节点。最后到达的尾节点却要最先被比较，这听起来是不是像“后进先出”？于是我们就能想到用栈的特点来解决这个问题:分别把两个链表的节点放入两个栈里，这样两个链表的尾节点就位于两个栈的栈顶，接下来比较两个栈顶的节点是否相同。如果相同， 则把栈顶弹出接着比较下一个栈顶，直到找到最后一个相同的节点。空间复杂度是O(m+n)，这种思路的时间复杂度也是O(m+n)<br>
其实解决这个问题还有一种更简单的办法:首先遍历两个链 表得到它们的长度， 就能知道哪个链表比较长，以及长的链表比短的链表多 几个节点。在第二次遍历 的时候，在较长的链表上先走若干步，接着同时在 两个链表上遍历，找到的第一 个相同的节点就是它们的第一个公共节点。</p>
</blockquote>
<pre><code>ListNode* FindFirstCommonNode(ListNode *pHead1, ListNode *pHead2)
{
    // 得到两个链表的长度
    unsigned int nLength1 = GetListLength(pHead1);
    unsigned int nLength2 = GetListLength(pHead2);
    int nLengthDif = nLength1 - nLength2;

    ListNode* pListHeadLong = pHead1;
    ListNode* pListHeadShort = pHead2;
    if(nLength2 &gt; nLength1)
    {
        pListHeadLong = pHead2;
        pListHeadShort = pHead1;
        nLengthDif = nLength2 - nLength1;
    }

    // 先在长链表上走几步，再同时在两个链表上遍历
    for(int i = 0; i &lt; nLengthDif; ++i)
        pListHeadLong = pListHeadLong-&gt;m_pNext;

    while((pListHeadLong != nullptr) &amp;&amp;
        (pListHeadShort != nullptr) &amp;&amp;
        (pListHeadLong != pListHeadShort))
    {
        pListHeadLong = pListHeadLong-&gt;m_pNext;
        pListHeadShort = pListHeadShort-&gt;m_pNext;
    }

    // 得到第一个公共结点
    ListNode* pFisrtCommonNode = pListHeadLong;

    return pFisrtCommonNode;
}

unsigned int GetListLength(ListNode* pHead)
{
    unsigned int nLength = 0;
    ListNode* pNode = pHead;
    while(pNode != nullptr)
    {
        ++nLength;
        pNode = pNode-&gt;m_pNext;
    }

    return nLength;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组 题51:数组中的逆序对]]></title>
        <id>https://lixin-scut.github.io//post/shu-zu-ti-51shu-zu-zhong-de-ni-xu-dui</id>
        <link href="https://lixin-scut.github.io//post/shu-zu-ti-51shu-zu-zhong-de-ni-xu-dui">
        </link>
        <updated>2020-03-07T00:05:23.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述</p>
<blockquote>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p>
</blockquote>
<p>【未做出】<br>
一开始并没有什么思路，只能先从暴力法寻找思路<br>
实现暴力法的时候不小心把小于号打成大于号了。。。<br>
不知道为啥显示不通过一个用例，但是这个用例非常长，估计就是超时了<br>
然后就是希望往时间复杂度O(n)努力，同时肯定需要牺牲空间复杂度<br>
第一个想法是保存排序已经循环的数组，然后判断新的元素的位置，这样利用二分法可以将复杂度压低到O(nlogn)（注意插入还是导致时间复杂度为O（n））<br>
还是看了书本答案 发现是归并排序法</p>
<pre><code>class Solution {
public:
    //我fo了，不知道牛客网哪里出错了，超长用例就是通过不了
    /*
    int InversePairs(vector&lt;int&gt; data){
        if(data.empty())
            return 0;
        vector&lt;int&gt; temp(data.begin(),data.end());
        
        return InversePairs(data,temp,0,data.size()-1)%1000000007;
    }
    
    int InversePairs(vector&lt;int&gt; &amp;data,vector&lt;int&gt; &amp;temp,int beg,int end){
        if(beg==end){
            temp[beg]=data[beg];
            return 0;
        }
        int mid=beg+(end-beg)/2;
        int left=InversePairs(temp,data,beg,mid);
        int right=InversePairs(temp,data,mid+1,end);
        int minP,maxP,locate,count;
        minP=mid;
        maxP=end;
        locate=end;
        count=0;
        while(minP&gt;=beg&amp;&amp;maxP&gt;=mid+1){
            if(data[minP]&lt;=data[maxP]){
                temp[locate]=data[maxP];
                --maxP;
                --locate;
            }else{
                count+=maxP-mid;
                temp[locate]=data[minP];
                --minP;
                --locate;
            }
        }
        while(maxP&gt;=mid+1){
            temp[locate]=data[maxP];
            --maxP;
            --locate;
        }
        while(minP&gt;=beg){
            temp[locate]=data[minP];
            --minP;
            --locate;
        }
        return left+right+count;
    }
    */
    
    
    /*
    //暴力法【超时】
    int InversePairs(vector&lt;int&gt; data) {
        if(data.empty())
            return 0;
        int len=data.size();
        int count=0;
        for(int i=0;i&lt;len-1;++i)
            for(int j=i+1;j&lt;len;++j){
                if(data[j]&lt;data[i])
                    ++count;
            }
        return count%1000000007;
    }
    */
};
</code></pre>
<p>书本题解<br>
<img src="https://lixin-scut.github.io//post-images/1583539828823.png" alt=""></p>
<blockquote>
<p>我们先用两个指针分别指向两个子数组的末尾，并每次比较两个指针指向的数 字。如果第一个子数组中的数字大于第二个子数组中的数字，则构成逆序对，并且逆序对的数目等于第二个子数组中剩余数字的个数。如果第一个数组中的数字小于或等于第二个 数组中的数字，则不构成逆序对。每次比较的时候， 我们都把较大的数字从后往前复制到一 个辅助数组，确保辅助数组中的数字是递增排序的。在把较大的数字复制到辅助数组之后，把对应的指针向 前移动一位，接下来进行下一轮比较。</p>
</blockquote>
<pre><code>int InversePairs(int* data, int length)
{
    if(data == nullptr || length &lt; 0)
        return 0;

    int* copy = new int[length];
    for(int i = 0; i &lt; length; ++i)
        copy[i] = data[i];

    int count = InversePairsCore(data, copy, 0, length - 1);
    delete[] copy;

    return count;
}

int InversePairsCore(int* data, int* copy, int start, int end)
{
    if(start == end)
    {
        copy[start] = data[start];
        return 0;
    }

    int length = (end - start) / 2;

    int left = InversePairsCore(copy, data, start, start + length);
    int right = InversePairsCore(copy, data, start + length + 1, end);

    // i初始化为前半段最后一个数字的下标
    int i = start + length;
    // j初始化为后半段最后一个数字的下标
    int j = end;
    int indexCopy = end;
    int count = 0;
    while(i &gt;= start &amp;&amp; j &gt;= start + length + 1)
    {
        if(data[i] &gt; data[j])
        {
            copy[indexCopy--] = data[i--];
            count += j - start - length;
        }
        else
        {
            copy[indexCopy--] = data[j--];
        }
    }

    for(; i &gt;= start; --i)
        copy[indexCopy--] = data[i];

    for(; j &gt;= start + length + 1; --j)
        copy[indexCopy--] = data[j];

    return left + right + count;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串 题50:第一个只出现一次的字符位置]]></title>
        <id>https://lixin-scut.github.io//post/zi-fu-chuan-ti-50di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-wei-zhi</id>
        <link href="https://lixin-scut.github.io//post/zi-fu-chuan-ti-50di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-wei-zhi">
        </link>
        <updated>2020-03-06T23:32:04.000Z</updated>
        <content type="html"><![CDATA[<p>题目1描述</p>
<blockquote>
<p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.</p>
</blockquote>
<p>本来想说用相与，但是注意是第一个，说明可以含有多个只出现一次的字符，这时相与法就失效了<br>
然后第一个想到的就是26字母数组，循环两次，第一次计算次数，第二次寻找第一个次数为1的字母，因为字母的个数是确定的，所以相当于常数空间复杂度<br>
突然发现要分大小写，本来想设置52的数组然后减去‘A’就好，然后发现ASCII码中A和a的距离不是26而是32，把数组增加6就通过了<br>
然后发现书本题解是伪哈希表hhh，其实思路也一致，也是固定大小的数组</p>
<pre><code>class Solution {
public:
    int FirstNotRepeatingChar(string str) {
        if(str.empty())
            return -1;
        vector&lt;int&gt; alpha_count(58,0);
        for(auto alpha:str){
                ++alpha_count[(alpha-'A')];
        }
        int locate=0;
        for(locate=0;locate&lt;52;++locate){
            if(alpha_count[(str[locate]-'A')]==1)
                return locate;
        }
        return 0;
    }
};
</code></pre>
<p>书本题解：<br>
(注意牛客网的题目和书本的略有不同)</p>
<blockquote>
<p>由于题目与字符出现的次数相关，那么我们可以统计每个字符 在该字符串中出现的次数，需要一个数据容器来存放每个字符的出现次数。在这个数据容器中，可以根据字符来查找它出现次数，也就是说这个容器的作用是把一个字符映射成一个数字。在常用的数据容器中，哈希表正是这个用途。<br>
我们可以定义哈希表的键值(Key)是字符，而值 (Value) 是该字符出现的次数。同时我们还需要从头开始扫描字符串两次。 第一次扫描 字符串时，每扫描到一个字符，就在哈希表的对应项中把次数 加 lo 接下来第二 次扫描时，每扫描到一个字符，就能从哈希表中得到该字符出现的次数。<br>
字符(char)是-个长度为 8 的数据类型， 因此总共有 256 种可能。 于是我们创建一个长度为 256 的数组，每个字母 根据其 ASCII 码值作为数组的 下标对应数组的-个数字，而数组中存储的是每个字符出现的次数。这样我们就 创建了一个大小为 256、以字符 ASCII 码为键值的哈希表。<br>
第一次扫描时，在哈希表中更新一个字符出现的次数的时间是 O(1)。 如果 字符串长度为n，那么第一次扫描的时间复杂度是O(n)。第二次扫描时， 同样 在O(1)时间内能读出一个字符出现的次数，所以时间复杂度仍然是O(n)。这样算起来，总的时间复杂度是O(n)。同时，我们需要一个包含 256 个字符的辅助数组，它的大小是 1KB。由于这个数组的大小是一个常数， 因此可以认为这种 算法的空间复杂度是 O(1)。</p>
</blockquote>
<pre><code>char FirstNotRepeatingChar(const char* pString)
{
    if(pString == nullptr)
        return '\0';

    const int tableSize = 256;
    unsigned int hashTable[tableSize];
    for(unsigned int i = 0; i &lt; tableSize; ++i)
        hashTable[i] = 0;

    const char* pHashKey = pString;
    while(*(pHashKey) != '\0')
        hashTable[*(pHashKey++)] ++;

    pHashKey = pString;
    while(*pHashKey != '\0')
    {
        if(hashTable[*pHashKey] == 1)
            return *pHashKey;

        pHashKey++;
    }

    return '\0';
}
</code></pre>
<p>题目2描述</p>
<blockquote>
<p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符&quot;go&quot;时，第一个只出现一次的字符是&quot;g&quot;。当从该字符流中读出前六个字符“google&quot;时，第一个只出现一次的字符是&quot;l&quot;。<br>
输出描述:<br>
如果当前字符流没有存在出现一次的字符，返回#字符。</p>
</blockquote>
<p>【未做出】<br>
这道题我本来是考虑哈希表的，但是不知道怎么权衡出现次数和出现位置的关系<br>
后来发现这两者确实不好平衡，然后书中的点很好，先全部置为-1，<br>
然后就记录每个字母出现的最后位置，而不用管它们出现的次数<br>
然后又发现我会错题意了，必须重复出现的字符置为-1的<br>
注意hashmap的for范围循环语句中的每个元素是pair而不是键值的值</p>
<pre><code>class Solution
{
public:
  //Insert one char from stringstream
    void Insert(char ch)
    {
        ++locate;
        if(alpha_count.count(ch))
            alpha_count[ch]=-1;
        else
            alpha_count[ch]=locate;
    }
  //return the first appearence once char in current stringstream
    char FirstAppearingOnce()
    {
        char res='#';
        int min_count=INT_MAX;
        for(auto i:alpha_count){
            if(i.second&gt;0&amp;&amp;i.second&lt;min_count){
                min_count=i.second;
                res=i.first;
            }
        }
        return res;
    }
private:
    unordered_map&lt;char,int&gt; alpha_count;
    int locate=0;
};
</code></pre>
<p>书本题解：<br>
字符只能一个接着一个从字符流中读出来。可以定义一个数据容器来 保存字符在 字符流中的位置。当一个字符第一次从字符流中读出来时，把它在字符流中的位置 保存到数据容器里。当这个字符再次从字符流中读出来时，那么它就不是只出现一 次的字符，也就可以被忽略了。这时把它在 数据容器里保存的值更新成一个特殊的 值(如负数值)。<br>
为了尽可能高效地解决这个问题，需要在O(1)时间内往数据容器里插入一个 字符，以及更新一个字符对应的值。这个数据容器可以用哈希表来实现。用字符的ASCII码作为哈希表的键值，而把字 符对应的位置作为哈希表的值。<br>
在上述代码中，哈希表用数组 occurrence 实现。数组中的元素 occurrence和 ASCII码的值为 i 的字符相对应。最开始的时候，数组中的所有元素都初始化为 T。当一个 ASCII 码为 i 的字符第一次从字符流中读出时，occurrence的值更新为它在字符流中的位置。当这个字符再次从字符流中读出时occurrence 大于或者等于 0, occurrenc的值更新为-2<br>
当我们需要找出到目前为止从字符流里读出的所有字符中第一个不重复的字符时，只需要扫描整个数组，并从中找出最小的大于等于0的值对应的字符即可。这就是函数 FirstAppearingOnce的功能。</p>
<pre><code>class CharStatistics
{
public:
    CharStatistics() : index(0)
    {
        for(int i = 0; i &lt; 256; ++i)
            occurrence[i] = -1;
    }

    void Insert(char ch)
    {
        if(occurrence[ch] == -1)
            occurrence[ch] = index;
        else if(occurrence[ch] &gt;= 0)
            occurrence[ch] = -2;

        index++;
    }

    char FirstAppearingOnce()
    {
        char ch = '\0';
        int minIndex = numeric_limits&lt;int&gt;::max();
        for(int i = 0; i &lt; 256; ++i)
        {
            if(occurrence[i] &gt;= 0 &amp;&amp; occurrence[i] &lt; minIndex)
            {
                ch = (char) i;
                minIndex = occurrence[i];
            }
        }

        return ch;
    }

private:
    // occurrence[i]: A character with ASCII value i;
    // occurrence[i] = -1: The character has not found;
    // occurrence[i] = -2: The character has been found for mutlple times
    // occurrence[i] &gt;= 0: The character has been found only once
    int occurrence[256];
    int index;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[coreDump 与GDB调试]]></title>
        <id>https://lixin-scut.github.io//post/coredump-yu-gdb-diao-shi</id>
        <link href="https://lixin-scut.github.io//post/coredump-yu-gdb-diao-shi">
        </link>
        <updated>2020-03-06T11:57:02.000Z</updated>
        <content type="html"><![CDATA[<p>昨天在复习测试字节序的时候因为不小心char写成了char*，导致了segmentation fault ，并且产生了coreDump文件，刚好趁此机会学习一下coreDump分析和初步的GDB调试</p>
<p>首先贴上代码</p>
<pre><code>void func()
{
		test.s = 0x0102;
		if(test.c[0] == 1 &amp;&amp; test.c[1] == 2)
		{ cout &lt;&lt; &quot;This PC is BigEndian.&quot; &lt;&lt; endl; }
		else
		{ cout &lt;&lt; &quot;This PC is LittleEndian.&quot; &lt;&lt; endl; }
}
</code></pre>
<p>使用编译<br>
<code>g++ testCore.cc -o testCore</code><br>
运行后得到报错<br>
<code>Segmentation fault (core dumped)</code></p>
<h3 id="段错误">段错误</h3>
<p>“ 段错误(segmentation fault)”是指程序尝试访问不允许访问的内存地址的情况。</p>
<p>这可能是由于：<br>
试图解引用空指针（访问内存地址 0）；<br>
试图解引用其他一些不在合法的内存地址区间内中的指针；<br>
一个已被破坏并且指向错误的地方的 C++ 虚表指针(C++ vtable pointer)，这导致程序尝试执行没有执行权限的内存中的指令；<br>
其他一些比如问未对齐的内存地址也可能会导致段错误（在要求自然边界对齐的体系结构）。</p>
<p>我们在博文中找到的一个更简单的方法</p>
<h3 id="运行-valgrind">运行 valgrind</h3>
<p>运行<br>
<code>valgrind -v your-program</code><br>
将会输出一个故障时的堆栈调用序列</p>
<pre><code>==6647== Process terminating with default action of signal 11 (SIGSEGV): dumping core
==6647==  Access not within mapped region at address 0x102
==6647==    at 0x1088CE: func() (testCore.cc:18)
==6647==    by 0x108944: main (testCore.cc:25)
==6647==  If you believe this happened as a result of a stack
==6647==  overflow in your program's main thread (unlikely but
==6647==  possible), you can try to increase the size of the
==6647==  main thread stack using the --main-stacksize= flag.
==6647==  The main thread stack size used in this run was 8388608.
--6647-- REDIR: 0x525c950 (libc.so.6:free) redirected to 0x4c30cd0 (free)
==6647== 
==6647== HEAP SUMMARY:
==6647==     in use at exit: 0 bytes in 0 blocks
==6647==   total heap usage: 1 allocs, 1 frees, 72,704 bytes allocated
==6647== 
==6647== All heap blocks were freed -- no leaks are possible
==6647== 
==6647== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
==6647== 
==6647== 1 errors in context 1 of 1:
==6647== Invalid read of size 1
==6647==    at 0x1088CE: func() (testCore.cc:18)
==6647==    by 0x108944: main (testCore.cc:25)
==6647==  Address 0x102 is not stack'd, malloc'd or (recently) free'd
==6647== 
==6647== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
Segmentation fault (core dumped)
</code></pre>
<p>valgrind 没利用到coreDump的信息（更像是一次重新运行分析）</p>
<h3 id="coredump">coreDump</h3>
<p>coreDump 叫做核心转储，它是进程运行时在突然崩溃的那一刻的一个内存快照。操作系统在程序发生异常而异常在进程内部又没有被捕获的情况下，会把进程此刻内存、寄存器状态、运行堆栈等信息转储保存在一个文件里。<br>
   该文件也是二进制文件，可以使用gdb、elfdump、objdump或者windows下的windebug、solaris下的mdb进行打开分析里面的具体内容。</p>
<p>但是coreDump这个东西并不是系统自带的，我们需要先非常麻烦地设置一波，但是详细的设置还是直接看博文吧，就不水篇幅了</p>
<h3 id="必须设置">必须设置</h3>
<p><code>ulimit -c unlimited</code><br>
否则默认输出的coreDump文件为空<br>
但是本设置开关机后会重置，必须修改配置文件设置永久保存，顺带修改一下coreDump输出文件的文件名和存储位置等，防止重名覆盖，详细参考博文</p>
<p><strong>-g选项</strong><br>
<code>g++ testCore.cc -g -o testCore</code><br>
然后就是编译设置，如果gdb打开core文件时，没有显示调试信息，就是因为之前编译的时候没有带上-g选项，没有调试信息是正常的，实际上它也不影响调试core文件。因为调试core文件时，符号信息都来自符号表，用不到调试信息。如下为加上调试信息的效果。</p>
<h3 id="利用gdb进行coredump的定位">利用gdb进行coredump的定位</h3>
<p>首先注意命令</p>
<pre><code>gdb /root/Codes/testCore core
</code></pre>
<p>第二部分是我们的可运行文件，而不是路径，第三部分是coreDump文件<br>
此时就会显示</p>
<pre><code>Core was generated by `./testCore'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00005643dd4a68ce in func () at testCore.cc:18
18		if(test.c[0] == 1 &amp;&amp; test.c[1] == 2)
</code></pre>
<p>直接就定位到了错误发生的函数和位置</p>
<p>然后查看堆栈可以使用bt或者where命令</p>
<h3 id="几个常用的gdb命令">几个常用的gdb命令：</h3>
<p>l(list) ，显示源代码，并且可以看到对应的行号；<br>
b(break)x, x是行号，表示在对应的行号位置设置断点；<br>
p(print)x, x是变量名，表示打印变量x的值<br>
r(run), 表示继续执行到断点的位置<br>
n(next),表示执行下一步<br>
c(continue),表示继续执行<br>
q(quit)，表示退出gdb</p>
<h3 id="常用signal的含义">常用signal的含义</h3>
<p>SIGABRT：调用abort函数时产生此信号。进程异常终止。</p>
<p>SIGBUS：指示一个实现定义的硬件故障。</p>
<p>SIGEMT：指示一个实现定义的硬件故障。EMT这一名字来自PDP-11的emulator trap 指令。</p>
<p>SIGFPE：此信号表示一个算术运算异常，例如除以0，浮点溢出等。</p>
<p>SIGILL：此信号指示进程已执行一条非法硬件指令。4.3BSD由abort函数产生此信号。SIGABRT现在被用于此。</p>
<p>SIGIOT：这指示一个实现定义的硬件故障。IOT这个名字来自于PDP-11对于输入／输出TRAP(input/outputTRAP)指令的缩写。系统V的早期版本，由abort函数产生此信号。SIGABRT现在被用于此。</p>
<p>SIGQUIT：当用户在终端上按退出键（一般采用Ctrl-/）时，产生此信号，并送至前台进</p>
<p>程组中的所有进程。此信号不仅终止前台进程组（如SIGINT所做的那样），同时产生一个core文件。</p>
<p><strong>SIGSEGV：指示进程进行了一次无效的存储访问。名字SEGV表示“段违例（segmentationviolation）”。</strong></p>
<p>SIGSYS：指示一个无效的系统调用。由于某种未知原因，进程执行了一条系统调用指令，但其指示系统调用类型的参数却是无效的。</p>
<p>SIGTRAP：指示一个实现定义的硬件故障。此信号名来自于PDP-11的TRAP指令。</p>
<p>SIGXCPUSVR4和4.3+BSD支持资源限制的概念。如果进程超过了其软C P U时间限制，则产生此信号。</p>
<p>SIGXFSZ：如果进程超过了其软文件长度限制，则SVR4和4.3+BSD产生此信号。</p>
<h3 id="coredump产生的几种可能情况">coredump产生的几种可能情况</h3>
<p>造成程序coredump的原因有很多，这里总结一些比较常用的经验吧：<br>
 1，内存访问越界<br>
  a) 由于使用错误的下标，导致数组访问越界。<br>
  b) 搜索字符串时，依靠字符串结束符来判断字符串是否结束，但是字符串没有正常的使用结束符。<br>
  c) 使用strcpy, strcat, sprintf, strcmp,strcasecmp等字符串操作函数，将目标字符串读/写爆。应该使用strncpy, strlcpy, strncat, strlcat, snprintf, strncmp, strncasecmp等函数防止读写越界。</p>
<p>2，多线程程序使用了线程不安全的函数。<br>
应该使用下面这些可重入的函数，它们很容易被用错：<br>
asctime_r(3c) gethostbyname_r(3n) getservbyname_r(3n)ctermid_r(3s) gethostent_r(3n) getservbyport_r(3n) ctime_r(3c) getlogin_r(3c)getservent_r(3n) fgetgrent_r(3c) getnetbyaddr_r(3n) getspent_r(3c)fgetpwent_r(3c) getnetbyname_r(3n) getspnam_r(3c) fgetspent_r(3c)getnetent_r(3n) gmtime_r(3c) gamma_r(3m) getnetgrent_r(3n) lgamma_r(3m) getauclassent_r(3)getprotobyname_r(3n) localtime_r(3c) getauclassnam_r(3) etprotobynumber_r(3n)nis_sperror_r(3n) getauevent_r(3) getprotoent_r(3n) rand_r(3c) getauevnam_r(3)getpwent_r(3c) readdir_r(3c) getauevnum_r(3) getpwnam_r(3c) strtok_r(3c) getgrent_r(3c)getpwuid_r(3c) tmpnam_r(3s) getgrgid_r(3c) getrpcbyname_r(3n) ttyname_r(3c)getgrnam_r(3c) getrpcbynumber_r(3n) gethostbyaddr_r(3n) getrpcent_r(3n)</p>
<p>3，多线程读写的数据未加锁保护。<br>
对于会被多个线程同时访问的全局数据，应该注意加锁保护，否则很容易造成coredump</p>
<p>4，非法指针<br>
  a) 使用空指针<br>
  b) 随意使用指针转换。一个指向一段内存的指针，除非确定这段内存原先就分配为某种结构或类型，或者这种结构或类型的数组，否则不要将它转换为这种结构或类型的指针，而应该将这段内存拷贝到一个这种结构或类型中，再访问这个结构或类型。这是因为如果这段内存的开始地址不是按照这种结构或类型对齐的，那么访问它时就很容易因为bus error而core dump。</p>
<p>5，堆栈溢出<br>
不要使用大的局部变量（因为局部变量都分配在栈上），这样容易造成堆栈溢出，破坏系统的栈和堆结构，导致出现莫名其妙的错误。</p>
<p>参考博文：<br>
<a href="https://jvns.ca/blog/2018/04/28/debugging-a-segfault-on-linux/">How to get a core dump for a segfault on Linux</a><br>
<a href="https://blog.csdn.net/tenfyguo/article/details/8159176">详解coredump</a><br>
<a href="https://blog.csdn.net/u014403008/article/details/54174109">gdb调试coredump(使用篇)</a></p>
]]></content>
    </entry>
</feed>