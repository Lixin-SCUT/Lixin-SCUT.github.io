<html>
  <head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>malloc函数 | Lixin-SCUT</title>
<link rel="shortcut icon" href="https://lixin-scut.github.io//favicon.ico?v=1583801239762">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://lixin-scut.github.io//styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://lixin-scut.github.io/">
  <img class="avatar" src="https://lixin-scut.github.io//images/avatar.png?v=1583801239762" alt="">
  </a>
  <h1 class="site-title">
    Lixin-SCUT
  </h1>
  <p class="site-description">
    In the darkest night,Rising like a spire.
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          时间轴
        </a>
      
    
      
        <a href="/tags" class="menu">
          分类/标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>


        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              malloc函数
            </h2>
            <div class="post-info">
              <time class="post-time">
                · 2020-03-09 ·
              </time>
              
                <a href="https://lixin-scut.github.io//tag/caA4UQ2wC" class="post-tag">
                  # 操作系统/Linux
                </a>
              
                <a href="https://lixin-scut.github.io//tag/JZUtdJBb3" class="post-tag">
                  # C++
                </a>
              
            </div>
            
            <div class="post-content">
              <p><a href="https://blog.csdn.net/maokelong95/article/details/51989081">理解 glibc malloc - CSDN博客<br>
</a><br>
<a href="https://blog.csdn.net/eroswang/article/details/4130972">glibc中malloc的详细解释 - CSDN博客</a><br>
<a href="https://blog.csdn.net/caishenfans/article/details/44779797">浅析基于glibc的malloc - CSDN博客</a><br>
<a href="http://www.cnblogs.com/Commence/p/5785912.html">malloc 函数详解 - Commence - 博客园</a><br>
<a href="https://blog.csdn.net/qq_25072517/article/details/89852643">malloc 函数详解,虚拟内存与物理内存的联系与区别</a><br>
<a href="https://blog.csdn.net/gfgdsg/article/details/42709943">Linux内存分配机制</a></p>
<p>new和malloc的区别<br>
1、	new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持；<br>
2、	使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。<br>
3、	new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。<br>
4、	new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。<br>
5、	new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。</p>
<ol>
<li>malloc与free的实现原理？<br>
1、	在标准C库中，提供了malloc/free函数分配释放内存，这两个函数底层是由brk、mmap、，munmap这些系统调用实现的;<br>
2、	brk是将数据段(.data)的最高地址指针_edata往高地址推,mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系；<br>
3、	malloc小于128k的内存，使用brk分配内存，将_edata往高地址推；malloc大于128k的内存，使用mmap分配内存，在堆和栈之间找一块空闲内存分配；brk分配的内存需要等到高地址内存释放以后才能释放，而mmap分配的内存可以单独释放。当最高地址空间的空闲内存超过128K（可由M_TRIM_THRESHOLD选项调节）时，执行内存紧缩操作（trim）。在上一个步骤free的时候，发现最高地址空闲内存超过128K，于是内存紧缩。<br>
4、	malloc是从堆里面申请内存，也就是说函数返回的指针是指向堆里面的一块内存。操作系统中有一个记录空闲内存地址的链表。当操作系统收到程序的申请时，就会遍历该链表，然后就寻找第一个空间大于所申请空间的堆结点，然后就将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。</li>
<li>malloc、realloc、calloc的区别</li>
</ol>
<ol>
<li>malloc函数<br>
void* malloc(unsigned int num_size);<br>
int <em>p = malloc(20</em>sizeof(int));申请20个int类型的空间；</li>
<li>calloc函数<br>
void* calloc(size_t n,size_t size);<br>
int *p = calloc(20, sizeof(int));<br>
省去了人为空间计算；malloc申请的空间的值是随机初始化的，calloc申请的空间的值是初始化为0的；</li>
<li>realloc函数<br>
void realloc(void *p, size_t new_size);<br>
给动态分配的空间分配额外的空间，用于扩充容量。</li>
</ol>
<p>《深入理解计算机系统》<br>
C 标准库提供了一个称为 malloc 程序包的显式分配器。程序通过调用 malloc 函数来从堆中分配块。</p>
<pre><code>#include &lt;stdlib.h&gt;
void *malloc(size_t size);
返回:若成功则为已分配块的指针，若出错则为 NULL。
</code></pre>
<p>malloc 函数返回一个指针，指向大小为至少 size 字节的内存块，这个块会为可能包 含在这个块 内的任何数据对象类型做对齐。实际中，对齐依赖于编译代码在32位模式 (gcc-m32)还是64位 模式(默认的)中运行。在 32 位模式中，malloc 返回的块的地址总 是 8 的倍数。在 64 位模式中， 该地址总是 16 的倍数。<br>
如果 malloc 遇到问题(例如，程序要求的内存块比可用的虚拟内存还要大)，那么它 就返回 NULL,并设置 errnoc malloc 不初始化它返回的内存。那些想要已初始化的动 态内存的应用程序可以 使用 calloc, calloc 是一个基于 malloc 的瘦包装函数，它将分 配的内存初始化为零。想要改变一个以 前已分配块的大小，可以使用 realloc 函数。</p>
<p>动态内存分配器，例如 malloc,可以通过使用 mmap 和 munmap 函数，显式地分配和 释放堆内 存，或者还可以使用 sbrk 函数:</p>
<pre><code>#include &lt;unistd.h&gt;
void *sbrk(intptr_t incr);
返回:若成功则为旧的 brk 指针，若出错则为-1。
</code></pre>
<p>sbrk 函数通过将内核的 brk 指针增加 incr 来扩展和收缩堆。如果成功，它就返回 brk 的旧值， 否则，它就返回一 1,并将 errno 设置为 ENOMEM。如果 incr 为零，那么 sbrk 就返回 brk 的当前值。 用一个为负的 incr 来调用 sbrk 是合法的，而且很巧妙，因 为返回值(brk 的旧值)指向距新堆顶向 上 abs(incr)字节处。<br>
程序是通过调用 free 函数来释放已分配的堆块。<br>
#include &lt;stdlib.h&gt;<br>
void free(void *ptr);<br>
返回:无。</p>
<p>ptr 参数必须指向一个从 malloc、calloc 或者 realloc 获得的已分配块的起始位 置。如果不是， 那么 free 的行为就是未定义的。更糟的是，既然它什么都不返回，free 就不会告诉应用出现了错误。 就像我们将在 9. 11 节里看到的，这会产生一些令人迷惑的 运行时错误。<br>
图 9-34 展示了一个 malloc 和 free 的实现是如何管理一个 C 程序的 16 字的(非常)小 的堆的。 每个方框代表了一个 4 字节的字。粗线标出的矩形对应于已分配块(有阴影的)和 空闲块(无阴影 的)。初始时，堆是由一个大小为 16 个字的、双字对齐的、空闲块组成的。 (本节中，我们假设分 配器返回的块是 8 字节双字边界对齐的。)<br>
<img src="https://lixin-scut.github.io//post-images/1583742463502.png" alt=""></p>
<p>情况一、malloc小于128k的内存，使用brk分配内存，将_edata往高地址推(只分配虚拟空间，不对应物理内存(因此没有初始化)，第一次读/写数据时，引起内核缺页中断，内核才分配对应的物理内存，然后虚拟地址空间建立映射关系)，<br>
1、进程启动的时候，其（虚拟）内存空间的初始布局如图1所示。<br>
其中，mmap内存映射文件是在堆和栈的中间（例如libc-2.2.93.so，其它数据文件等），为了简单起见，省略了内存映射文件。<br>
_edata指针（glibc里面定义）指向数据段的最高地址。<br>
2、进程调用A=malloc(30K)以后，内存空间如图2：<br>
malloc函数会调用brk系统调用，将_edata指针往高地址推30K，就完成虚拟内存分配。<br>
你可能会问：只要把_edata+30K就完成内存分配了？<br>
事实是这样的，_edata+30K只是完成虚拟地址的分配，A这块内存现在还是没有物理页与之对应的，等到进程第一次读写A这块内存的时候，发生缺页中断，这个时候，内核才分配A这块内存对应的物理页。也就是说，如果用malloc分配了A这块内容，然后从来不访问它，那么，A对应的物理页是不会被分配的。<br>
3、进程调用B=malloc(40K)以后，内存空间如图3。</p>
<p>使用brk分配内存，将_edata往高地址推(只分配虚拟空间，不对应物理内存(因此没有初始化)，第一次读/写数据时，引起内核缺页中断，内核才分配对应的物理内存，然后虚拟地址空间建立映射关系)<br>
所以malloc()后一定要初始化(memset)，否则会引发段错误<br>
<a href="https://blog.csdn.net/weixin_42263483/article/details/80890150">论malloc()后忘记初始化(memset)的后果</a></p>

            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://lixin-scut.github.io//post/yuan-zi-xing-atomic">
              <h3 class="post-title">
                原子性atomic与线程安全
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '253c8689f3b11b51dcf1',
    clientSecret: '64df7c097665e7dd6f416ecfaba36581a91bdb63',
    repo: 'Lixin-SCUT.github.io',
    owner: 'Lixin-SCUT',
    admin: ['Lixin-SCUT'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://lixin-scut.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

      </div>
    </div>
  </body>
</html>
