<html>
  <head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>C++ primer 第六章 笔记+习题 6.1-6.2 | Lixin-SCUT</title>
<link rel="shortcut icon" href="https://lixin-scut.github.io//favicon.ico?v=1587905681044">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://lixin-scut.github.io//styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://lixin-scut.github.io/">
  <img class="avatar" src="https://lixin-scut.github.io//images/avatar.png?v=1587905681044" alt="">
  </a>
  <h1 class="site-title">
    Lixin-SCUT
  </h1>
  <p class="site-description">
    千里之行，始于足下。不积跬步，无以至千里。
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          时间轴
        </a>
      
    
      
        <a href="/tags" class="menu">
          分类/标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>


        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              C++ primer 第六章 笔记+习题 6.1-6.2
            </h2>
            <div class="post-info">
              <time class="post-time">
                · 2019-09-12 ·
              </time>
              
                <a href="https://lixin-scut.github.io//tag/Esg34ccex" class="post-tag">
                  # C++ Primer
                </a>
              
                <a href="https://lixin-scut.github.io//tag/JZUtdJBb3" class="post-tag">
                  # C++
                </a>
              
            </div>
            
            <div class="post-content">
              <p>6.1函数基础<br>
一个函数定义包括：返回类型，函数名字，由0个或多个形参组成的列表以及函数体<br>
通过调用运算符来<strong>执行函数，调用运算符的形式是一对圆括号</strong>，作用于一个表达式，表达式是函数或者指向函数的指针，圆括号内为实参，实参初始化形参，调用表达式的类型就是函数的类型<br>
函数第一步是隐式地定义并初始化形参<br>
实参的类型和数量都必须与形参匹配，所以形参一定会被初始化<br>
空形参可以是隐式或者<strong>显式（void）</strong><br>
每个形参的类型都必须单独声明，不可以因为类型相同而忽略<br>
形参可以<strong>空名</strong>，但不可以同名，<strong>通常以空名代表不被使用，但也必须用实参初始化</strong><br>
函数的返回类型不可以是<strong>数组或者函数</strong>，但可以是指向数组的<strong>指针或引用</strong></p>
<p>习题6.1<br>
实参是形参的初始值，实参用于初始化对应位置的形参<br>
习题6.2<br>
（a）返回类型为int<br>
（b）没有定义返回类型<br>
（c）形参名字不可以相同<br>
（d）函数体不管语句数量多少，必须使用花括号<br>
习题6.3+6.4</p>
<pre><code>int factorial(int fact);
int main() {
	int i;
	while (cin) {
		cout &lt;&lt; &quot;please input one number:&quot;;
		cin &gt;&gt; i;
		cout &lt;&lt; factorial(i) &lt;&lt; endl;
	}
};

int factorial(int fact) {
	int sum=1;
	while (fact)
		sum *= fact--;
	return sum;
}
</code></pre>
<p>知识点：不要忽略了函数的声明！<br>
习题6.5</p>
<pre><code>int num_abs(int num);

int main() {
	int i;
	while (cin) {
		cout &lt;&lt; &quot;please input one number:&quot;;
		cin &gt;&gt; i;
		cout &lt;&lt; num_abs(i) &lt;&lt; endl;
	}
};

int num_abs(int num) {
	return num&gt;0?num:-num;
}
</code></pre>
<p>6.1.1局部对象<br>
名字有作用域，对象有生命周期<br>
形参和函数体内部定义的变量统称为局部变量<br>
自动对象 只存在于块执行期间的对象 块执行结束后，自动对象的值变为未定义<br>
形参是一种自动对象，内置类型的未初始化局部变量将产生未定义的值<br>
局部静态对象 static 直到程序终止时才被销毁，在此期间就算函数执行结束也不会对她产生影响（可以用来计算函数调用次数）<br>
内置类型的局部静态变量默认初始化为0，而不是未定义</p>
<p>习题6.6<br>
形参和局部静态变量都属于局部变量，只存在于块执行期间，但是局部静态变量的存在周期为整个程序执行期间，形参在块执行后的值变为未定义。代码见2.7<br>
习题6.7</p>
<pre><code>int formal_param(int f);

int main() {
	int i = 10;
	while(i)
		formal_param(i),--i;
};

int formal_param(int f) {
	int i=0;
	static int s_i=0;
	cout &lt;&lt; f&lt;&lt;' '&lt;&lt;++i &lt;&lt; ' ' &lt;&lt; ++s_i&lt;&lt;endl;
	return 0;
}
</code></pre>
<p>6.1.2<br>
函数只能定义一次，但可以声明多次。函数声明无须函数体，可以忽略形参的名字，用一个分号代替 例如 int add(int ,int);<br>
函数声明也称作函数原型<br>
建议函数和变量在<strong>头文件中声明，在源文件中定义,</strong><br>
含有函数声明的头文件应该被包含到定义函数的源文件中，<br>
<strong>通过以上的配合，其实就是将所有用到该函数的cpp文件中的声明移动到头文件中，编译器会自动在包含了头文件的cpp文件中搜索函数定义，从而以后可以很方便地修改函数的声明（比如修改形参数量），不需要一个一个地在使用了该函数的cpp文件中修改。</strong></p>
<p>习题6.8<br>
chapter6.h</p>
<pre><code>#pragma once
#ifndef CHAPTER6_H
#define CHAPTER6_H
int factorial(int fact);
#endif // !CHAPTER6_H
</code></pre>
<p>homework6.8.cpp</p>
<pre><code>#include &quot;chapter6.h&quot;

int factorial(int fact) {
	int sum = 1;
	while (fact)
		sum *= fact--;
	return sum;
}
</code></pre>
<p>6.1.3<br>
分离式编译允许我们把程序分割到几个文件中去，每个文件相互独立<br>
如果我们修改了某个源文件，只需要单独编译改动了的文件生成对象代码文件<br>
分离式编译会产生对象代码文件<br>
最后再把对象文件链接到一起形成可执行文件</p>
<p>习题6.9<br>
其实6.8中已经完成了这个任务，homework6.8对应于fact.cc 。</p>
<p>6.2参数传递<br>
如果形参是引用类型，实参被引用传递（传引用调用）。当形参非引用类型，实参的值拷贝给形参，实参被值传递（传值调用）<br>
6.2.1<br>
拷贝传递不会影响实参的值，但指针形参可以修改所指向的对象的值<br>
在c++语言中建议使用引用类型的形参</p>
<p>习题6.10</p>
<pre><code>int swap_p(int *p1, int *p2);

int main() {
	int i1 = 0, i2 = 1;
	cout &lt;&lt; i1 &lt;&lt; ' ' &lt;&lt; i2 &lt;&lt; endl;
	int *i1p = &amp;i1, *i2p = &amp;i2;
	swap_p(i1p, i2p);
	cout &lt;&lt; i1 &lt;&lt; ' ' &lt;&lt; i2 &lt;&lt; endl;
	return 0;
};

int swap_p(int *p1,int *p2) {
	 *p1 = *p1 + *p2;
	 *p2 = *p1 - *p2;
	 *p1 = *p1 - *p2;
	 return 1;
}
</code></pre>
<p>6.2.2<br>
<strong>使用引用可以避免对大的类或者容器对象进行拷贝</strong><br>
如果无需改变形参的值，<strong>最好将其声明为常量引用</strong><br>
可以使用引用类型的形参返回额外信息</p>
<p>习题6.11</p>
<pre><code>int main() {
	int i = 1;
	cout &lt;&lt; i &lt;&lt; endl;
	reset(i);
	cout &lt;&lt; i &lt;&lt; endl;
	return 0;
};

void reset(int &amp;p) {
	p = 0;
}
</code></pre>
<p>习题6.12</p>
<pre><code>int main() {
	int i1 = 0, i2 = 1;
	cout &lt;&lt; i1 &lt;&lt; ' ' &lt;&lt; i2 &lt;&lt; endl;
	int &amp;i1p = i1, &amp;i2p = i2;
	swap_p(i1p, i2p);
	cout &lt;&lt; i1 &lt;&lt; ' ' &lt;&lt; i2 &lt;&lt; endl;
	return 0;
};

int swap_p(int &amp;p1, int &amp;p2) {
	p1 = p1 + p2;
	p2 = p1 - p2;
	p1 = p1 - p2;
	return 1;
}
</code></pre>
<p>非常明显 引用更加好用。免去了*字符和&amp;字符的繁杂<br>
习题6.13<br>
一个是传值调用，一个是传引用调用，前者只是拷贝副本，后者可以通过引用更改原值<br>
习题6.14<br>
比如对两个矩阵进行比较，矩阵值特别大时再进行传值会导致内存不足，同时iostream等输入输出流是不可以拷贝的。如果不想修改原变量的值，就不应该使用引用。<br>
习题6.15<br>
我们不希望s被拷贝，也不希望s被修改，所以使用const &amp;，occur会被修改，所以用普通引用，我们不希望函数通过c的值来修改原值，所以不使用引用。否则s会被修改，occur无法递增</p>
<p>6.2.3<br>
指向常量的指针也可以指向非常量，只是不能解引用赋值，<strong>也不能赋值给普通指针</strong>。常量指针不能改变指针的值，<strong>但是可以解引用赋值</strong><br>
当实参初始化形参时会忽略顶层const，所以当形参有顶层const时，传给它常量对象或者非常量对象都可以（但实参的顶层const不会被忽略）<br>
在函数定义或者声明的过程中，因为顶层const被忽略了，所以形参中的const int和  int没有区别，编译器会认为重复了（<strong>但是在函数体中仍然不能改变const形参的值</strong>）<br>
非常量引用形参的<strong>两个问题</strong>：<br>
1.形参为<strong>int引用</strong>时，只能传入int类型的对象，不能用字面值、求值结果为int的表达式、需要转换的对象或者<strong>const int类型</strong>的对象，但** 常量引用可以使用字面值**，所以建议使用常量引用<br>
2.在函数内部使用形参作为另外一个函数的形参时，需要注意引用类型是否一致，例如：</p>
<pre><code>void fun1(const int &amp;param){
	fun2(param);//void fun2(int &amp; param)时错误，**int&amp;只接受普通引用 **
}
</code></pre>
<p>所以尽可能使用常量引用</p>
<p>习题6.18<br>
（a）<code>bool compare(matrix &amp;m1,matrix&amp;m2);</code><br>
（b）<code>vector&lt;int&gt;::iterator change_val(int i,vector&lt;int&gt;::iterator i_v);</code><br>
习题6.19<br>
（a）不合法，形参数目不对<br>
（b）合法<br>
（c）合法，有隐式转换<br>
（d）合法，有隐式转换<br>
习题6.20<br>
常量引用：不希望拷贝传值和被改动。普通引用的话原值可能会被改动。</p>
<p>6.2.4<br>
数组两个特殊性质，1.<strong>不允许拷贝数组</strong>2.使用数组名时通常会将其转换成指针<br>
所以函数传递数组时实际上传递的是指向数组首元素的指针<br>
1.Int* a   2.int a[]     3.int a[10]   这三个形参实际上是一样的，都等同于第一个<br>
管理指针形参<br>
1.使用结束标记间接指定数组长度，比如c风格字符串结尾的空字符 例如<code>while(*cp)</code>指向结尾空字符就会结束<br>
2.使用标准库规范 传递指向数组首尾元素的指针 int a[10];begin(a),end(a);<br>
3.显式传递一个表示数组大小的形参 end(a)-begin(a);<strong><code>sizeof(a)/sizeof(*a)</code></strong><br>
数组引用形参定义过程中，<strong>&amp;arr两端的括号不可以少</strong>，但数组引用形参一开始就需要确定数组大小 (&amp;arr)[10]；数组的引用 &amp;arr[10]；错误，没有数组的引用</p>
<p>习题6.21</p>
<pre><code>int compare(int p1, int *p2);

int main() {
	int i1,i2;
	cout &lt;&lt; &quot;please input two number:&quot;;
	cin &gt;&gt; i1 &gt;&gt; i2;
	cout &lt;&lt; &quot;the larger one is &quot;;
	int *i1p = &amp;i1, *i2p = &amp;i2;
	cout &lt;&lt; compare(i1, i2p) &lt;&lt; endl;
	return 0;
};

int compare(int p1, int *p2) {
	return p1&gt;*p2?p1:*p2;
}
</code></pre>
<p>习题6.22</p>
<pre><code>int main() {
	int i1,i2;
	cout &lt;&lt; &quot;please input two number:&quot;;
	cin &gt;&gt; i1 &gt;&gt; i2;
	int *i1p = &amp;i1, *i2p = &amp;i2;
	cout &lt;&lt; *i1p &lt;&lt; ' ' &lt;&lt; *i2p &lt;&lt; endl;
	swap_p(i1p, i2p);
	cout &lt;&lt; *i1p &lt;&lt; ' ' &lt;&lt; *i2p &lt;&lt; endl;
	return 0;
};

void swap_p(int *&amp;p1, int *&amp;p2) {
	int *temp = p1;
	p1 = p2;
	p2 = temp;
}
</code></pre>
<p>习题6.23</p>
<pre><code>int main() {
	int j[2] = { 0,1 };
	int i = 0;
	auto j_b = begin(j);
	auto j_e = end(j);
	print(i);
	print(j_b, j_e);
	return 0;
};

void print(const int&amp; i) {
	cout &lt;&lt; i &lt;&lt; endl;
}
void print(int *beg,int *end) {
	while (beg != end)
		cout &lt;&lt; *beg++ &lt;&lt; endl;

}
</code></pre>
<p>习题6.24<br>
程序希望逐个输出数组ia的元素，但是形参没有使用引用或指针，数组是无法直接拷贝给形参的！！！所以传递的仅仅是头指针</p>
<p>6.2.5<br>
int main(int argc,char *argv[]){….}<br>
main处理命令行选项，argc表示变量的数量，argv[0]保存程序的名字，可选实参从argv[1]开始<br>
main的形参只能由命令行赋予</p>
<p>习题6.25&amp;.26</p>
<pre><code>int main(int argc,char* argv[]) {
	string s;
	for (int i = 1; i &lt; argc; ++i)
		s = s + argv[i];
	cout &lt;&lt; s &lt;&lt; endl;
};
</code></pre>
<p>知识点：string的向量可以用 string+=char，特别是string为空的时候，不能直接string=char+char，第一个必须是string。</p>
<p>6.2.6<br>
<strong>函数的实参数量未知但类型相同</strong>，可以使用initializer_list类型的形参，这是一种标准库类型，用于表示某种特定类型的值的数组，<strong>和vector一样也是一种模版类型，但其对象中的元素永远是常量值，无法改变元素的值</strong>（元素值是const）<br>
向initializer_list形参传递一个值的序列的时候，必须把序列放在<strong>一对花括号内</strong></p>
<p>习题6.27</p>
<pre><code>int add_list(initializer_list&lt;int&gt; i);

int main(int argc,char* argv[]) {
	initializer_list&lt;int&gt; i{ 1,2,3,4,5,6,7 };
	cout &lt;&lt; add_list(i) &lt;&lt; endl;
};

int add_list(initializer_list&lt;int&gt; i) {
	int sum = 0;
	for (auto num : i)
		sum += num;
	return sum;
}
</code></pre>
<p>习题6.28<br>
elem的类型为const string&amp;<br>
习题6.29<br>
应该，因为initailizer_list的对象都是const值，使用引用可以避免拷贝和修改，但是要注意配合auto使用（实测加了auto &amp;，会自动加上const）</p>
<p>习题感悟：<br>
不要忽略了函数的声明！<br>
数组是无法直接拷贝给形参的！！！<br>
string的向量可以用 string+=char，特别是string为空的时候，不能直接string=char+char，第一个必须是string。</p>

            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://lixin-scut.github.io//post/217-cun-zai-chong-fu-yuan-su">
              <h3 class="post-title">
                数组217. 存在重复元素
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '253c8689f3b11b51dcf1',
    clientSecret: '64df7c097665e7dd6f416ecfaba36581a91bdb63',
    repo: 'Lixin-SCUT.github.io',
    owner: 'Lixin-SCUT',
    admin: ['Lixin-SCUT'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://lixin-scut.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

      </div>
    </div>
  </body>
</html>
