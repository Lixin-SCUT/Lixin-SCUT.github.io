<html>
  <head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Django框架 | Lixin-SCUT</title>
<link rel="shortcut icon" href="https://lixin-scut.github.io//favicon.ico?v=1589990054796">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://lixin-scut.github.io//styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://lixin-scut.github.io/">
  <img class="avatar" src="https://lixin-scut.github.io//images/avatar.png?v=1589990054796" alt="">
  </a>
  <h1 class="site-title">
    Lixin-SCUT
  </h1>
  <p class="site-description">
    千里之行，始于足下。不积跬步，无以至千里。
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          时间轴
        </a>
      
    
      
        <a href="/tags" class="menu">
          分类/标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>


        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Django框架
            </h2>
            <div class="post-info">
              <time class="post-time">
                · 2020-05-20 ·
              </time>
              
                <a href="https://lixin-scut.github.io//tag/qC53A8dj2" class="post-tag">
                  # Python
                </a>
              
            </div>
            
            <div class="post-content">
              <p>主要参考链接 <a href="https://www.cnblogs.com/LiCheng-/p/6920900.html#">Django框架全面讲解</a><br>
Python的WEB框架有Django、Tornado、Flask 等多种，Django相较与其他WEB框架其优势为：大而全，框架本身集成了ORM、模型绑定、模板引擎、缓存、Session等诸多功能。</p>
<h3 id="django流程介绍">Django流程介绍</h3>
<p><img src="https://lixin-scut.github.io//post-images/1589986229570.png" alt=""></p>
<p>MVC是众所周知的模式，即：将应用程序分解成三个组成部分:model(模型),view(视图),和 controller(控制 器)。其中：<br>
M——管理应用程序的状态（通常存储到数据库中），并约束改变状态的行为（或者叫做“业务规则”）。<br>
C——接受外部用户的操作，根据操作访问模型获取数据，并调用“视图”显示这些数据。控制器是将“模型”和“视图”隔离，并成为二者之间的联系纽带。<br>
V——负责把数据格式化后呈现给用户。</p>
<p>Django也是一个MVC框架。但是在Django中，控制器接受用户输入的部分由框架自行处理，所以 Django 里更关注的是模型（Model）、模板(Template)和视图（Views），称为 MTV模式：</p>
<p>M 代表模型（Model），即数据存取层。 该层处理与数据相关的所有事务： 如何存取、如何验证有效性、包含哪些行为以及数据之间的关系等。</p>
<p>T 代表模板(Template)，即表现层。 该层处理与表现相关的决定： 如何在页面或其他类型文档中进行显示。</p>
<p>V 代表视图（View），即业务逻辑层。 该层包含存取模型及调取恰当模板的相关逻辑。 你可以把它看作模型与模板之间的桥梁。</p>
<h3 id="django-基本配置">Django 基本配置</h3>
<p><strong>创建django程序</strong></p>
<ul>
<li>终端命令：<code>django-admin startproject sitename</code>  (在当前目录下创建一个Django程序)</li>
<li>IDE创建Django程序时，本质上都是自动执行上述命令</li>
</ul>
<p>其他常用命令：</p>
<p><code>python manage.py runserver ip:port</code>  (启动服务器，默认ip和端口为http://127.0.0.1:8000/)</p>
<p><code>python manage.py startapp appname</code>  (新建 app)</p>
<p><code>python manage.py syncdb</code>  (同步数据库命令，Django 1.7及以上版本需要用以下的命令）</p>
<p><code>python manage.py makemigrations</code>  (显示并记录所有数据的改动)</p>
<p><code>python manage.py migrate</code>  (将改动更新到数据库)</p>
<p><code>python manage.py createsuperuser</code>  (创建超级管理员)</p>
<p><code>python manage.py dbshell</code>  (数据库命令行)</p>
<p><code>python manage.py</code>  (查看命令列表)</p>
<p><strong>程序目录</strong><br>
<img src="https://lixin-scut.github.io//post-images/1589986490982.png" alt=""></p>
<p><strong>配置文件</strong></p>
<p>a、数据库</p>
<p>支持SQLite 3（默认）、PostgreSQL 、MySQL、Oracle数据库的操作</p>
<p>Django框架对于开发者而言高度透明化，对于不同数据库的具体使用方法是一致的，改变数据库类型只需要变动配置即可。<br>
篇幅问题暂不列出具体配置</p>
<h3 id="django-路由系统">Django 路由系统</h3>
<p>URL配置(URLconf)就像Django 所支撑网站的目录。它的本质是URL模式以及要为该URL模式调用的视图函数之间的映射表；你就是以这种方式告诉Django，对于这个URL调用这段代码，对于那个URL调用那段代码。URL的加载是从配置文件中开始。</p>
<p><img src="https://lixin-scut.github.io//post-images/1589986595130.png" alt=""></p>
<p>参数说明：</p>
<ul>
<li>一个正则表达式字符串</li>
<li>一个可调用对象，通常为一个视图函数或一个指定视图函数路径的字符串</li>
<li>可选的要传递给视图函数的默认参数（字典形式）</li>
<li>一个可选的name参数</li>
</ul>
<p>示例</p>
<pre><code>from django.conf.urls import url
   
from . import views
   
urlpatterns = [
    url(r'^articles/2003/$', views.special_case_2003),
    url(r'^articles/([0-9]{4})/$', views.year_archive),
    url(r'^articles/([0-9]{4})/([0-9]{2})/$', views.month_archive),
    url(r'^articles/([0-9]{4})/([0-9]{2})/([0-9]+)/$', views.article_detail),
]
</code></pre>
<p>说明:</p>
<ul>
<li>要捕获从URL中的值，用括号括起来，会当参数传入 views 视图。</li>
<li>没有必要添加一个斜线，因为每个URL都有。例如，它<code>^articles</code>不是<code>^/articles</code>。</li>
<li>在'r'前面的每个正则表达式字符串中是可选的，但建议。它告诉Python字符串是“原始” -没有什么字符串中应该进行转义。</li>
</ul>
<p>请求示例:</p>
<ul>
<li>一个请求 <code>/articles/2005/03/</code>会匹配上面列表中的第三条. Django 会调用函数 <code>views.month_archive(request, '2005', '03')</code>.</li>
<li><code>/articles/2005/3</code>/ 不会匹配上面列表中的任何条目, 因为第三条的月份需要二位数字.</li>
<li><code>/articles/2003/</code> 会匹配上第一条而不是第二条，因为匹配是按照从上到下顺序而进行的， Django 会调用函数 <code>views.special_case_2003(request)</code></li>
<li><code>/articles/2003</code> 不会匹配上面列表中的任何条目, 因为每个URL应该以 / 结尾.</li>
<li><code>/articles/2003/03/03/</code> 会匹配上最后一条. Django 会调用函数 <code>views.article_detail(request, '2003', '03', '03')</code></li>
</ul>
<p><strong>命名组（Named groups）</strong></p>
<p>在上面的简单例子中，并没有使用正则表达式分组，在更高级的用法中，很有可能使用正则分组来匹配URL并且将分组值通过参数传递给view函数。</p>
<p>在Python的正则表达式中，分组的语法是<code>(?P&lt;name&gt;pattern)</code>, name表示分组名，pattern表示一些匹配正则.</p>
<p>这里是一个简单的小例子：</p>
<pre><code># 正则知识
import re
 
ret=re.search('(?P&lt;id&gt;\d{3})/(?P&lt;name&gt;\w{3})','weeew34ttt123/ooo')
 
print(ret.group())
print(ret.group('id'))
print(ret.group('name'))
-------------------------------------
123/ooo
123
ooo
</code></pre>
<pre><code>from django.conf.urls import url
   
from . import views
   
urlpatterns = [
    url(r'^articles/2003/$', views.special_case_2003),
    url(r'^articles/(?P&lt;year&gt;[0-9]{4})/$', views.year_archive),
    url(r'^articles/(?P&lt;year&gt;[0-9]{4})/(?P&lt;month&gt;[0-9]{2})/$', views.month_archive),
    url(r'^articles/(?P&lt;year&gt;[0-9]{4})/(?P&lt;month&gt;[0-9]{2})/(?P&lt;day&gt;[0-9]{2})/$', views.article_detail),
]
</code></pre>
<p>例子:</p>
<ol>
<li><code>A request to /articles/2005/03/</code> 会调用函数 <code>views.month_archive(request, year='2005',month='03')</code>, 而不是 <code>views.month_archive(request, '2005', '03')</code>.</li>
<li><code>A request to /articles/2003/03/03/</code> 会调用函数 <code>views.article_detail(request, year='2003',month='03', day='03')</code>.</li>
</ol>
<p>常见写法实例：<br>
<img src="https://lixin-scut.github.io//post-images/1589987060384.png" alt=""></p>
<p><strong>二级路由（Including）</strong></p>
<p>如果映射 url 太多分支，全写一个在  urlpatterns 显得繁琐，二级路由应用而生</p>
<pre><code>from django.conf.urls import include, url
 
from apps.main import views as main_views
from credit import views as credit_views
 
 urlpatterns = [
    url(r'^$', main_views.homepage),
    url(r'^help/', include('apps.help.urls')),
    url(r'^credit/', include(extra_patterns)),
]

extra_patterns = [
    url(r'^reports/$', credit_views.report),
    url(r'^reports/(?P&lt;id&gt;[0-9]+)/$', credit_views.report),
    url(r'^charge/$', credit_views.charge),
]
 
</code></pre>
<p><strong>注意include的参数有两种形式，可以接受str形式的参数</strong></p>
<p>在上面这个例子中，如果请求url为 /credit/reports/ 则会调用函数 credit_views.report().</p>
<p>使用二级路由也可以减少代码冗余，使代码更加简洁易懂</p>
<pre><code># 原始版本
from django.conf.urls import url
from . import views

urlpatterns = [
   url(r'^(?P&lt;page_slug&gt;[\w-]+)-(?P&lt;page_id&gt;\w+)/history/$', views.history),
   url(r'^(?P&lt;page_slug&gt;[\w-]+)-(?P&lt;page_id&gt;\w+)/edit/$', views.edit),
   url(r'^(?P&lt;page_slug&gt;[\w-]+)-(?P&lt;page_id&gt;\w+)/discuss/$', views.discuss),
   url(r'^(?P&lt;page_slug&gt;[\w-]+)-(?P&lt;page_id&gt;\w+)/permissions/$', views.permissions),
]


# 改进版本
from django.conf.urls import include, url
from . import views

urlpatterns = [
   url(r'^(?P&lt;page_slug&gt;[\w-]+)-(?P&lt;page_id&gt;\w+)/', include([
       url(r'^history/$', views.history),
       url(r'^edit/$', views.edit),
       url(r'^discuss/$', views.discuss),
       url(r'^permissions/$', views.permissions),
   ])),
]
</code></pre>
<p><strong>添加额外的参数</strong></p>
<p>URLconfs 有一个钩子可以让你加入一些额外的参数到view函数中.</p>
<pre><code>from django.conf.urls import url
from . import views
   
urlpatterns = [
    url(r'^blog/(?P&lt;year&gt;[0-9]{4})/$', views.year_archive, {'foo': 'bar'}),
]
</code></pre>
<p>在上面的例子中，如果一个请求为<code>/blog/2005/</code>, Django 将会调用函数l <code>views.year_archive(request, year='2005',foo='bar')</code>.</p>
<p>需要注意的是，当加上参数时，对应函数<code>views.year_archive</code>必须加上一个参数，参数名也必须命名为 foo，如下：</p>
<pre><code>def year_archive(request, foo):
    print(foo)
    return render(request, 'index.html')
</code></pre>
<p><strong>别名的使用</strong></p>
<pre><code>url(r'^index',views.index,name='bieming')
</code></pre>
<p>url中还支持name参数的配置，如果配置了name属性，在模板的文件中就可以使用name值来代替相应的url值.</p>
<p>name的应用</p>
<pre><code>urlpatterns = [
    url(r'^index',views.index,name='bieming'),
    url(r'^admin/', admin.site.urls),
    # url(r'^articles/2003/$', views.special_case_2003),
    url(r'^articles/([0-9]{4})/$', views.year_archive),
    # url(r'^articles/([0-9]{4})/([0-9]{2})/$', views.month_archive),
    # url(r'^articles/([0-9]{4})/([0-9]{2})/([0-9]+)/$', views.article_detail),

]
###################

def index(req):
    if req.method=='POST':
        username=req.POST.get('username')
        password=req.POST.get('password')
        if username=='alex' and password=='123':
            return HttpResponse(&quot;登陆成功&quot;)



    return render(req,'index.html')

#####################

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
{#     &lt;form action=&quot;/index/&quot; method=&quot;post&quot;&gt;#}
{#     这里只要使用bieming即可代替/index #}
     &lt;form action=&quot;{% url 'bieming' %}&quot; method=&quot;post&quot;&gt;
         用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;
         密码:&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;
         &lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt;
     &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;


#######################

</code></pre>
<p><strong>指定view的默认配置</strong></p>
<pre><code># URLconf
from django.conf.urls import url
 
from . import views
 
urlpatterns = [
    url(r'^blog/$', views.page),
    url(r'^blog/page(?P&lt;num&gt;[0-9]+)/$', views.page),
]
 
# View (in blog/views.py)
def page(request, num=&quot;1&quot;):
    # Output the appropriate page of blog entries, according to num.
    ...
</code></pre>
<p>在上述的例子中，两个 URL 模式指向同一个视图 views.page 但第一图案不捕获从 URL 任何东西。如果第一个模式匹配，该 page() 函数将使用它的默认参数 num，&quot;1&quot;。如果第二图案相匹配时， page()将使用任何 num 值由正则表达式捕获。</p>
<h3 id="django-views视图函数">Django Views（视图函数</h3>
<p>http请求中产生两个核心对象：</p>
<p>http请求：HttpRequest对象</p>
<p>http响应：HttpResponse对象</p>
<p><strong>HttpRequest对象</strong></p>
<p>当请求一个页面时，Django 创建一个 HttpRequest对象包含原数据的请求。然后 Django 加载适当的视图，通过 HttpRequest作为视图函数的第一个参数。每个视图负责返回一个HttpResponse目标。</p>
<pre><code>path：       请求页面的全路径，不包括域名

method：     请求中使用的HTTP方法的字符串表示。全大写表示。例如

                   if  req.method==&quot;GET&quot;:

                             do_something()

                   elseif req.method==&quot;POST&quot;:

                             do_something_else()

GET:         包含所有HTTP GET参数的类字典对象

POST：       包含所有HTTP POST参数的类字典对象

             服务器收到空的POST请求的情况也是可能发生的，也就是说，表单form通过
             HTTP POST方法提交请求，但是表单中可能没有数据，因此不能使用
             if req.POST来判断是否使用了HTTP POST 方法；应该使用  if req.method==&quot;POST&quot;



COOKIES:     包含所有cookies的标准Python字典对象；keys和values都是字符串。

FILES：      包含所有上传文件的类字典对象；FILES中的每一个Key都是&lt;input type=&quot;file&quot; name=&quot;&quot; /&gt;标签中 
            name属性的值，FILES中的每一个value同时也是一个标准的python字典对象，包含下面三个Keys：

            filename：      上传文件名，用字符串表示
            content_type:   上传文件的Content Type
            content：       上传文件的原始内容


user：       是一个django.contrib.auth.models.User对象，代表当前登陆的用户。如果访问用户当前
             没有登陆，user将被初始化为django.contrib.auth.models.AnonymousUser的实例。你
             可以通过user的is_authenticated()方法来辨别用户是否登陆：
             if req.user.is_authenticated();只有激活Django中的AuthenticationMiddleware
             时该属性才可用

session：    唯一可读写的属性，代表当前会话的字典对象；自己有激活Django中的session支持时该属性才可用。

META：       一个标准的Python字典包含所有可用的HTTP头。可用标题取决于客户端和服务器，但这里是一些例子：

            CONTENT_LENGTH       – 请求体的长度（一个字符串）。
            CONTENT_TYPE         – 请求体的类型。
            HTTP_ACCEPT          - 为响应–可以接受的内容类型。
            HTTP_ACCEPT_ENCODING – 接受编码的响应
            HTTP_ACCEPT_LANGUAGE – 接受语言的反应
            HTTP_HOST            – 客户端发送的HTTP主机头。
            HTTP_REFERER         – 参考页面
            HTTP_USER_AGENT      – 客户端的用户代理字符串。
            QUERY_STRING         – 查询字符串，作为一个单一的（分析的）字符串。
            REMOTE_ADDR          – 客户端的IP地址
            REMOTE_HOST          – 客户端的主机名
            REMOTE_USER          – 用户通过Web服务器的身份验证。
            REQUEST_METHOD       – 字符串，如&quot;GET&quot;或&quot;POST&quot;
            SERVER_NAME          – 服务器的主机名
            SERVER_PORT          – 服务器的端口（一个字符串）。
</code></pre>
<p><strong>HttpResponse对象</strong></p>
<p>对于HttpRequest对象来说，是由django自动创建的，但是，HttpResponse对象就必须我们自己创建。每个view请求处理方法必须返回一个HttpResponse对象。</p>
<p>在HttpResponse对象上扩展的常用方法：</p>
<ul>
<li>页面渲染：render（推荐），render_to_response,</li>
<li>页面跳转：redirect</li>
<li>locals：可以直接将对应视图函数中所有的变量传给模板</li>
</ul>
<p><img src="https://lixin-scut.github.io//post-images/1589988456776.png" alt=""></p>
<p>对于页面渲染的方法中，render和render_to_response使用方法和功能类似，但是render功能更为强大，推荐使用</p>
<p><strong>render()</strong></p>
<pre><code>render(request, template_name, context=None, content_type=None, status=None, using=None)[source]
</code></pre>
<p>结合给定的模板与一个给定的上下文，返回一个字典HttpResponse在渲染文本对象</p>
<p><strong>所需的参数</strong></p>
<p>template_name 一个模板的使用或模板序列名称全称。如果序列是给定的，存在于第一个模板将被使用。</p>
<p><strong>可选参数</strong></p>
<ul>
<li>
<p>context    一组字典的值添加到模板中。默认情况下，这是一个空的字典。</p>
</li>
<li>
<p>content_type    MIME类型用于生成文档。</p>
</li>
<li>
<p>status    为响应状态代码。默认值为200</p>
</li>
<li>
<p>using    这个名字一个模板引擎的使用将模板。</p>
</li>
</ul>
<p>render示例</p>
<pre><code>from django.shortcuts import render

def my_view(request):
    # View code here...
    return render(request, 'myapp/index.html', {
        'foo': 'bar',
    }, content_type='application/xhtml+xml')
</code></pre>
<h3 id="模板">模板</h3>
<p><strong>模板的执行</strong></p>
<p>模版的创建过程，对于模版，其实就是读取模版（其中嵌套着模版标签），然后将 Model 中获取的数据插入到模版中，最后将信息返回给用户。</p>
<p>示例</p>
<pre><code># view.py

def index(request):
    return render(request, 'index.html', {'title':'welcome'})


# index.html

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt;
        &lt;h1&gt;{{ title }}&lt;/h1&gt;
    &lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<p>模板语言</p>
<p>模板中也有自己的语言，该语言可以实现数据展示</p>
<ul>
<li><code>{{ item }}</code></li>
<li></li>
</ul>
<pre><code>{% for item in item_list %}  &lt;a&gt;{{ item }}&lt;/a&gt;  {% endfor %}
　　forloop.counter
　　forloop.first
　　forloop.last 
</code></pre>
<ul>
<li><code>{% if ordered_warranty %} {% else %} {% endif %}</code></li>
<li>母板：<code>{% block title %}{% endblock %}</code></li>
<li>子板：<code>{% extends &quot;base.html&quot; %}</code><br>
　　　<code>{% block title %}{% endblock %}</code></li>
<li>帮助方法：</li>
</ul>
<pre><code>{{ item.event_start|date:&quot;Y-m-d H:i:s&quot;}}
{{ bio|truncatewords:&quot;30&quot; }}
{{ my_list|first|upper }}
{{ name|lower }}
</code></pre>
<p>在模板语言中字典数据类型的取值是通过<code>dict.xxx</code>而不是<code>dict[xxx]</code></p>
<p><strong>自定义标签</strong></p>
<p>因为在模板语言中不能够做运算等一些稍显复杂的操作，所以在Django中提供了两种自定制标签，一种是simple_tag，一种是filter。</p>
<p>simple_tag: 任意传递参数，但是不能用作布尔判断</p>
<p>filter: 最多只能传递二个参数，可以用作布尔判断</p>
<p>在这里着重介绍simple_tag类型，filter的实现类似</p>
<p>a、在app中创建templatetags模块</p>
<p>b、创建任意 .py 文件，如：xx.py</p>
<p>示例</p>
<pre><code>#!/usr/bin/env python
#coding:utf-8
from django import template
from django.utils.safestring import mark_safe
from django.template.base import resolve_variable, Node, TemplateSyntaxError
  
register = template.Library()
  
@register.simple_tag
def my_simple_time(v1,v2,v3):
    return  v1 + v2 + v3
  
@register.simple_tag
def my_input(id,arg):
    result = &quot;&lt;input type='text' id='%s' class='%s' /&gt;&quot; %(id,arg,)
    return mark_safe(result)
</code></pre>
<p>c、在使用自定义simple_tag的html文件中导入之前创建的 xx.py 文件名</p>
<pre><code>{% load xx %}
</code></pre>
<p>d、使用simple_tag</p>
<pre><code>{% my_simple_time 1 2 3%}
{% my_input 'id_username' 'hide'%}
</code></pre>
<p>e、在settings中配置当前app，不然django无法找到自定义的simple_tag</p>
<pre><code>INSTALLED_APPS = (
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'app01',
)
</code></pre>
<p>更多见文档：https://docs.djangoproject.com/en/1.10/ref/templates/language/</p>
<p>六、 Model</p>

            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://lixin-scut.github.io//post/lian-biao-mian-shi-ti-0204-fen-ge-lian-biao-zhong-deng">
              <h3 class="post-title">
                链表 面试题 02.04. 分割链表[中等]
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '253c8689f3b11b51dcf1',
    clientSecret: '64df7c097665e7dd6f416ecfaba36581a91bdb63',
    repo: 'Lixin-SCUT.github.io',
    owner: 'Lixin-SCUT',
    admin: ['Lixin-SCUT'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://lixin-scut.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

      </div>
    </div>
  </body>
</html>
