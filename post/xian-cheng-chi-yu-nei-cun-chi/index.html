<html>
  <head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>线程池与内存池 | Lixin-SCUT</title>
<link rel="shortcut icon" href="https://lixin-scut.github.io//favicon.ico?v=1583801239762">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://lixin-scut.github.io//styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://lixin-scut.github.io/">
  <img class="avatar" src="https://lixin-scut.github.io//images/avatar.png?v=1583801239762" alt="">
  </a>
  <h1 class="site-title">
    Lixin-SCUT
  </h1>
  <p class="site-description">
    In the darkest night,Rising like a spire.
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          时间轴
        </a>
      
    
      
        <a href="/tags" class="menu">
          分类/标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>


        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              线程池与内存池
            </h2>
            <div class="post-info">
              <time class="post-time">
                · 2020-03-02 ·
              </time>
              
                <a href="https://lixin-scut.github.io//tag/caA4UQ2wC" class="post-tag">
                  # 操作系统/Linux
                </a>
              
            </div>
            
            <div class="post-content">
              <ol>
<li>为什么需要线程池<br>
  大多数的网络服务器，包括Web服务器都具有一个特点，就是单位时间内必须处理数目巨大的连接请求，但是处理时间却是比较短的。在传统的多线程服务器模型中是这样实现的：一旦有个请求到达，就创建一个新的线程，由该线程执行任务，任务执行完毕之后，线程就退出。这就是”即时创建，即时销毁”的策略。尽管与创建进程相比，创建线程的时间已经大大的缩短，但是如果提交给线程的任务是执行时间较短，而且执行次数非常频繁，那么服务器就将处于一个不停的创建线程和销毁线程的状态。这笔开销是不可忽略的，尤其是线程执行的时间非常非常短的情况。</li>
<li>线程池原理<br>
  在应用程序启动之后，就马上创建一定数量的线程，放入空闲的队列中。这些线程都是处于阻塞状态，这些线程只占一点内存，不占用CPU。当任务到来后，线程池将选择一个空闲的线程，将任务传入此线程中运行。当所有的线程都处在处理任务的时候，线程池将自动创建一定的数量的新线程，用于处理更多的任务。执行任务完成之后线程并不退出，而是继续在线程池中等待下一次任务。当大部分线程处于阻塞状态时，线程池将自动销毁一部分的线程，回收系统资源。</li>
<li>线程池的作用<br>
  需要大量的线程来完成任务，且完成任务的时间比较短；对性能要求苛刻的应用；对性能要求苛刻的应用</li>
<li>内存池的原理<br>
  在软件开发中，有些对象使用非常频繁，那么我们可以预先在堆中实例化一些对象，我们把维护这些对象的结构叫“内存池”。在需要用的时候，直接从内存池中拿，而不用从新实例化，在要销毁的时候，不是直接free/delete，而是返还给内存池。把那些常用的对象存在内存池中，就不用频繁的分配/回收内存，可以相对减少内存碎片，更重要的是实例化这样的对象更快，回收也更快。当内存池中的对象不够用的时候就扩容。</li>
<li>内存池的优缺点<br>
  内存池对象不是线程安全的，在多线程编程中，创建一个对象时必须加锁。</li>
</ol>
<h3 id="内存池实现">内存池实现</h3>
<p>《深入理解计算机系统》<br>
<strong>分配器的要求和目标</strong><br>
显式分配器必须在一些相当严格的约束条件下工作: •处理任意请求序列。一个应用可以有任意的分配请求和释放请求序列，只要满足约 束条件:<br>
每个释放请求必须对应于一个当前已分配块，这个块是由一个以前的分配 请求获得的。因此， 分配器不可以假设分配和释放请求的顺序。例如，分配器不能 假设所有的分配请求都有相匹 配的释放请求，或者有相匹配的分配和空闲请求是嵌 套的。<br>
•立即响应请求。分配器必须立即响应分配请求。因此，不允许分配器为了提高性能 重新排列 或者缓冲请求。<br>
•只使用堆。为了使分配器是可扩展的，分配器使用的任何非标量数据结构都必须保 存在堆里。<br>
•对齐块(对齐要求)。分配器必须对齐块，使得它们可以保存任何类型的数据对象。 •不修改已分配的块。分配器只能操作或者改变空闲块。特别是，一旦块被分配了， 就不允许修改或者移动它了。因此，诸如压缩已分配块这样的技术是不允许使 用的。<br>
在这些限制条件下，分配器的编写者试图实现吞吐率最大化和内存使用率最大化，而 这两个性能目标通常是相互冲突的。<br>
目标 1:最大化吞吐率。<br>
合理性 能是指一个分配请求的最糟运行时间与空闲块的 数量成线性关系，而一个释放请求的运行时间是个常数。<br>
目标 2:最大化内存利用率。<br>
一个系统中被所有进程分配的虚拟内存的全部数量是受磁盘上交 换空间的数量限制 的。</p>
<p><strong>碎片</strong><br>
造成堆利用率很低的主要原因是一种称为碎片(fragmentation)的现象，当虽然有未使 用的内存 但不能用来满足分配请求时，就发生这种现象。有两种形式的碎片:内部碎片 (internal fragmentation)和夕卜部碎片(external fragmentation) o<br>
内部碎片是在一个已分配块比有效载荷大时发生的<br>
内部碎片的量化是简单明了的。它就是已分配块大小和它们的有效载荷大小之差的 和。因此， 在任意时刻，内部碎片的数量只取决于以前请求的模式和分配器的实现方式。<br>
外部碎片是当空闲内存合计起来足够满足一个分配请求，但是没有一个单独的空闲块 足够大可 以来处理这个请求时发生的。<br>
外部碎片比内部碎片的量化要困难得多，因为它不仅取决于以前请求的模式和分配器 的实现方式，还取决于将来请求的模式。</p>
<p><strong>实现问题</strong><br>
可以想象出的最简单的分配器会把堆组织成一个大的字节数组，还有一个指针 p,初 始指向这个 数组的第一个字节。为了分配 size 个字节，malloc 将 p 的当前值保存在栈 里，将 p 增加 size,并将 p 的旧值返回到调用函数。free只是简单地返回到调用函数, 而不做其他任何事情。<br>
这个简单的分配器是设计中的一种极端情况。因为每个 malloc 和 free 只执行很少 量的指令， 吞吐率会极好。然而，因为分配器从不重复使用任何块，内存利用率将极差。 一个实际的分配器要 在吞吐率和利用率之间把握好平衡，就必须考虑以下几个问题:<br>
•空闲块组织:我们如何记录空闲块?<br>
•放置:我们如何选择一个合适的空闲块来放置一个新分配的块?<br>
•分割:在将一个新分配的块放置到某个空闲块之后，我们如何处理这个空闲块中的 剩余部分?<br>
•合并:我们如何处理一个刚刚被释放的块?<br>
本节剩下的部分将更详细地讨论这些问题。因为像放置、分割以及合并这样的基本技 术贯穿在许多不同的空闲块组织中，所以我们将在一种叫做隐式空闲链表的简单空闲块组 织结构中来介绍它 们。</p>
<p><strong>隐式空闲链表</strong><br>
隐式空闲链表 任何实际的分配器都需要一些数据结构，允许它来区别块边界，以及区别已分配块和 空闲块。<br>
大多数分配器将这些信息嵌入块本身。<br>
<img src="https://lixin-scut.github.io//post-images/1583743127377.png" alt=""><br>
在这种情况中，一个块是由一个字的头部、有效载荷，以及可能的一些额外的填充组 成的。 头部编码了这个块的大小(包括头部和所有的填充)，以及这个块是已分配的还是空闲的。如果我们强加一个双字的对齐约束条件，那么块大小就总是 8 的倍数，且块大小的 最低 3 位 总是零。因此，我们只需要内存大小的 29 个高位，释放剩余的 3 位来编码其他 信息<br>
<img src="https://lixin-scut.github.io//post-images/1583743162337.png" alt=""><br>
我们称这种结构为隐式空闲链表，是因为空闲块是通过头部中的大小字段隐含地连接着 的。分 配器可以通过遍历堆中所有的块，从而间接地遍历整个空闲块的集合。注意，我们需要 某种特殊标 记的结束块，在这个示例中，就是一个设置了已分配位而大小为零的终止头部(terminating header) 。 (就像我们将在 9. 9.12 节中看到的，设置已分配位简化了空闲块的合并。)<br>
隐式空闲链表的优点是简单。显著的缺点是任何操作的开销，例如放置分配的块，要 求对空闲 链表进行搜索，该搜索所需时间与堆中已分配块和空闲块的总数呈线性关系。<br>
很重要的一点就是意识到系统对齐要求和分配器对块格式的选择会对分配器上的最小 块大小有 强制的要求。没有已分配块或者空闲块可以比这个最小值还小。例如，如果我们 假设一个双字的对 齐要求，那么每个块的大小都必须是双字(8 字节)的倍数。因此，图 9- 35 中的块格式就导致最小 的块大小为两个字:一个字作头，另一个字维持对齐要求。即 使应用只请求一•字节，分配器也仍 然需要创建一个两字的块。</p>
<p>接下来的准备还有</p>
<ol>
<li>放置已分配的块</li>
<li>分割空闲块</li>
<li>获取额外的堆内存</li>
<li>合并空闲块</li>
<li>带边界标记的合并</li>
</ol>
<h3 id="显式空闲链表">显式空闲链表</h3>
<p>隐式空闲链表为我们提供了一种介绍一些基本分配器概念的简单方法。然而，因为块 分配与堆 块的总数呈线性关系，所以对于通用的分配器，隐式空闲链表是不适合的(尽管 对于堆块数量预先 就知道是很小的特殊的分配器来说它是可以的)。<br>
一种更好的方法是将空闲块组织为某种形式的显式数据结构。因为根据定义，程序不 需要一个 空闲块的主体，所以实现这个数据结构的指针可以存放在这些空闲块的主体里 面。例如，堆可以组 织成一个双向空闲链表，在每个空闲块中，都包含一个pred(前驱) 和succ(后继)指针<br>
使用双向链表而不是隐式空闲链表，使首次适配的分配时间从块总数的线性时间减少 到了空闲 块数量的线性时间。不过，释放一个块的时间可以是线性的，也可能是个常数， 这取决于我们所选 择的空闲链表中块的排序策略。<br>
一种方法是用后进先出(LIFO)的顺序维护链表，将新释放的块放置在链表的开始处。 使用 LIFO 的顺序和首次适配的放置策略，分配器会最先检查最近使用过的块。在这种情 况下，释放一 个块可以在常数时间内完成。如果使用了边界标记，那么合并也可以在常数 时间内完成。<br>
另一种方法是按照地址顺序来维护链表，其中链表中每个块的地址都小于它后继的地 址。在这 种情况下，释放一个块需要线性时间的搜索来定位合适的前驱。平衡点在于，按 照地址排序的首次 适配比LIFO排序的首次适配有更高的内存利用率，接近最佳适配的利 用率。<br>
一般而言，显式链表的缺点是空闲块必须足够大，以包含所有需要的指针，以及头部 和可能的脚部。这就导致了更大的最小块大小，也潜在地提高了内部碎片的程度。</p>
<h3 id="分离的空闲链表">分离的空闲链表</h3>
<p>一种流行的减少分配时间的方法，通常称为分离存储(segregated storage),就是维护多个 空闲链表，其中每个链表中的块有大致相等的大小。一般的思路 是将所有可能的块大小分成一些等 价类，也叫做大小类(size class)。有很多种方式来定义 大小类。我们可以根据 2 的幕来划分 块大小:<br>
分配器维护着一个空闲链表数组，每个大小类一个空闲链表，按照大小的升序排列。 当分配 器需要一个大小为n的块时，它就搜索相应的空闲链表。如果不能找到合适的块与 之匹配，它就搜 索下一个链表，以此类推。</p>
<p>简单分离存储(simple segregated storage)和分离适配 (segregated fit)<br>
1.简单分离存储<br>
使用简单分离存储，每个大小类的空闲链表包含大小相等的块，每个块的大小就是这 个大小 类中最大元素的大小。<br>
为了分配一个给定大小的块，我们检查相应的空闲链表。如果链表非空，我们简单地 分配其 中第一块的全部。空闲块是不会分割以满足分配请求的。如果链表为空，分配器就 向操作系统请求 一个固定大小的额外内存片(通常是页大小的整数倍)，将这个片分成大小 相等的块，并将这些块链 接起来形成新的空闲链表。要释放一个块，分配器只要简单地将 这个块插入到相应的空闲链表的前 部。<br>
这种简单的方法有许多优点。分配和释放块都是很快的常数时间操作。而且，每个片 中都是 大小相等的块，不分割，不合并，这意味着每个块只有很少的内存开销。由于每个 片只有大小相同 的块，那么一个已分配块的大小就可以从它的地址中推断出来。因为没有 合并，所以已分配块的头 部就不需要一个已分配/空闲标记。因此已分配块不需要头部， 同时因为没有合并，它们也不需要 脚部。因为分配和释放操作都是在空闲链表的起始处操 作，所以链表只需要是单向的，而不用是双 向的。关键点在于，在任何块中都需要的唯一 字段是每个空闲块中的一个字的 succ 指针，因此最小 块大小就是一个字。<br>
一个显著的缺点是，简单分离存储很容易造成内部和外部碎片。因为空闲块是不会被 分割的， 所以可能会造成内部碎片。更糟的是，因为不会合并空闲块，所以某些引用模式 会引起极多的外部 碎片</p>
<p>分离适配<br>
使用这种方法，分配器维护着一个空闲链表的数组。每个空闲链表是和一个大小类相 关联的，<br>
并且被组织成某种类型的显式或隐式链表。每个链表包含潜在的大小不同的块， 这些块的大小是大 小类的成员。有许多种不同的分离适配分配器。<br>
为了分配一个块，必须确定请求的大小类，并且对适当的空闲链表做首次适配，查找 一个合适 的块。如果找到了一个，那么就(可选地)分割它，并将剩余的部分插入到适当的 空闲链表中。如 果找不到合适的块，那么就搜索下一个更大的大小类的空闲链表。如此重 复，直到找到一个合适的 块。如果空闲链表中没有合适的块，那么就向操作系统请求额外 的堆内存，从这个新的堆内存中分 配出一个块，将剩余部分放置在适当的大小类中。要释 放一个块，我们执行合并，并将结果放置到 相应的空闲链表中。<br>
分离适配方法是一种常见的选择，C标准库中提供的GNUmalloc包就是采用的这种 方法， 因为这种方法既快速，对内存的使用也很有效率。搜索时间减少了，因为搜索被限 制在堆的某个部 分，而不是整个堆。内存利用率得到了改善，因为有一个有趣的事实:对 分离空闲链表的简单的首 次适配搜索，其内存利用率近似于对整个堆的最佳适配搜索的内 存利用率。</p>
<p>伙伴系统<br>
伙伴系统(buddy system)是分离适配的一种特例，其中每个大小类都是 2 的幂。基本 的思路是假设一个堆的大小为 2^m字，我们为每个块大小 2^k维护一个分离空闲链表，其 中 0&lt;=k&lt;=m。 请求块大小向上舍入到最接近的 2 的幂，最开始时，只有一个大小为 2^m个字 的空闲块。<br>
为了分配一个大小为2<sup>k的块，我们找到第一个可用的、大小为2</sup>k的块，其中 k&lt;=j&lt;=m。 如果j=k那么我们就完成了。否则，我们递归地二分割这个块，直到j=k。当我们进行这样的分割时，每个剩下的半块(也叫做伙伴)被放置在相应的空闲链表中。要释放一个大小为2^k的块，我们继续合并空闲的伙伴。当遇到一个已分配的伙伴时，我们就停止合并。<br>
关于伙伴系统的一个关键事实是，给定地址和块的大小，很容易计算出它的伙伴的地址。例如， 一个块，大小为 32 字节，地址为:<br>
它的伙伴的地址为<br>
xxx...x00000<br>
xxx...x10000<br>
换句话说，一个块的地址和它的伙伴的地址只有一位不相同。 伙伴系统分配器的主要优点是它的快速搜索和快速合并。主要缺点是要求块大小为 2 的幂，可能<br>
导致显著的内部碎片。因此，伙伴系统分配器不适合通用目的的工作负载。然 而，对于某些特定应 用的工作负载，其中块大小预先知道是 2 的暴，伙伴系统分配器就很 有吸引力了。</p>

            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://lixin-scut.github.io//post/selectpoll-he-epoll">
              <h3 class="post-title">
                select、poll和epoll
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '253c8689f3b11b51dcf1',
    clientSecret: '64df7c097665e7dd6f416ecfaba36581a91bdb63',
    repo: 'Lixin-SCUT.github.io',
    owner: 'Lixin-SCUT',
    admin: ['Lixin-SCUT'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://lixin-scut.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

      </div>
    </div>
  </body>
</html>
