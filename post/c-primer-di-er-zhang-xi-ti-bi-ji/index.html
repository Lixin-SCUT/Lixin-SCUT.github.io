<html>
  <head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>C++ primer 第二章 笔记+习题 2.1-2.3 | Lixin-ee</title>
<link rel="shortcut icon" href="https://lixin-ee.github.io//favicon.ico?v=1573648420737">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://lixin-ee.github.io//styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://lixin-ee.github.io/">
  <img class="avatar" src="https://lixin-ee.github.io//images/avatar.png?v=1573648420737" alt="">
  </a>
  <h1 class="site-title">
    Lixin-ee
  </h1>
  <p class="site-description">
    好景在望。
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          时间轴
        </a>
      
    
      
        <a href="/tags" class="menu">
          分类/标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>


        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              C++ primer 第二章 笔记+习题 2.1-2.3
            </h2>
            <div class="post-info">
              <time class="post-time">
                · 2019-09-03 ·
              </time>
              
                <a href="https://lixin-ee.github.io//tag/Esg34ccex" class="post-tag">
                  # C++ Primer
                </a>
              
                <a href="https://lixin-ee.github.io//tag/JZUtdJBb3" class="post-tag">
                  # C++
                </a>
              
            </div>
            
            <div class="post-content">
              <p>2.1.1<br>
char 可以表示的范围-128-127 其中-128的表示为1000 0000 而0的表示为0000 0000（无负0）<br>
习题2.1<br>
区别在于类型数据所占的比特（16、32、64、16） 以及 含义（整型、长整型、长整型、和短整型）；无符号类型所有比特都是用来存储值，无法表示负数，带符号类型则可以表示负数，用一位来表示符号；float是单精度浮点数，只有6位有效数字，double是双精度浮点数，有10位有效数字<br>
练习2.2 利率应该使用float，本金使用int，付款使用double，因为一般利率为0.0xx，本金为10的倍数的正整数，付款容易出现小数。</p>
<p>2.1.2<br>
注意 不仅仅是等号=才会触发强制转换 所有符号包括&lt; &lt;= &gt; &gt;=都会触发强制转换，所以负值的int永远大于无符号数<br>
对无符号类型赋一个超出表示范围的值，初始值是对无符号类型表示数值总数取模后的余数 例如8比特大小的unsigned char可以表示0-255（256个数）则强行赋值-1的话，结果就是对-1取模256所得的余数255**（注意这里的取模和普通取模并不一致，必须返回正数）**<br>
取模方法<br>
-17 % 10 的计算结果如下：r = (-17) - (-17 / 10) x 10 = (-17) - (-1 x 10) = -7<br>
17 % -10 的计算结果如下：r = 17 - (17 / -10) x (-10) = (17) - (-1 x -10) = 7<br>
-17 % -10 的计算结果如下：r = (-17) - (-17 / -10) x (-10) = (-17) - (1 x -10) = -7<br>
注意 -1%256=（-1）-（-1/256）x 256=-1<br>
<strong>取模运算中 结果的符号与被除数相同。</strong><br>
对带符号类型赋一个超出表示范围的值，结果是未定义的。<br>
unsigned符号默认忽略int 所以unsigned a；和unsigned int a；是一样的</p>
<p>习题2.3<br>
u2 - u = 32； u - u2 = -32 mod 2^32 = 4294967264；<br>
i2 - i = 32 i - i2=-32 i - u=0 u - i = 0</p>
<p>2.1.3<br>
严格来说十进制字面值不会是负值，负号并不在字面值之内，它的作用仅仅是对字面值取负值而已<br>
小数默认为double<br>
十进制字面值的类型：int、long、long long<br>
八进制和十六进制：int、unsigned int、long、unsigned long、long long和unsigned long long（输出不加规范的话还是十进制）<br>
自动选择能够容纳字面值的最小范围<br>
单引号‘a’ char型字面值 双引号“abc” 字符串型字面值<br>
字符串型字面值的类型实际上是由常量字符构成的数组<br>
编译器在每个字符串的结尾处添加一个空字符，因此字符串字面值的实际长度要比内容多1<br>
两个字符串字面值位置紧邻或仅由空格、缩进和换行符分隔，则它们实际上视为一个整体<br>
两类字符程序员不能直接使用：1.不可打印字符：退格等控制字符 2.特殊含义字符，需要使用转义序列<br>
true false 是布尔类型的字面值 nullptr是指针字面值</p>
<p>习题2.5<br>
（a）char型、wchar_t、字符串、宽字符串<br>
（b）int、unsigned int、long、unsigned long、八进制int、十六进制int<br>
（c）double、float、long double<br>
（d）int、unsigned int、double、double<br>
习题2.6<br>
第一组为十进制，输出为可见，第二组为八进制，输出还是可见，但是第一个0代表的就是八进制<br>
习题2.7<br>
（a）字符串常量，其中\145为八进制数，转化为e，\012转义为换行符 Latin1字符集<br>
(b)long double<br>
(c)float<br>
(d)long double<br>
习题2.8</p>
<pre><code>	cout &lt;&lt; &quot;2\115\0122\t\115&quot; &lt;&lt; endl;
</code></pre>
<p>2.2.1<br>
对象 是指一块能存储数据并具有某种类型的内存空间<br>
变量初始化不等于赋值<br>
花括号列表初始化会因为存在信息丢失（精确度丢失的问题）而拒绝初始化请求，编译器报错 等号初始化和括号初始化能够直接执行转换（直接丢弃部分值）<br>
默认初始化：1.定义在任何函数体之外的内置类型变量会初始化为0 2.定义在函数体内部的内置类型变量将不被初始化，此时变量的值是未定义的（undefined）<br>
std::string  empty;初始化为空串**（不可以输出）**<br>
注意</p>
<p>习题2.9<br>
(a)定义不正确，应该在函数调用外定义<br>
(b)列表赋值不允许精度丢失<br>
(c)错误，从左到右，所以b等于未定义（第一种情况<br>
(d)正确，但是会丢失精度 最后等于3<br>
习题2.10<br>
string不是内置类型，所以全部为空，int在函数外的为0，函数内部的是未定义的</p>
<p>2.2.2<br>
分离式编译 将程序分割为若干个文件，每个文件可以被独立编译。.<br>
声明 仅规定变量的类型和名字 定义 创建与名字关联的实体，申请存储空间 并赋初始值声明关键字 extern<br>
如果含有初始化的话就等于定义，抵消了extern的作用，同时试图初始化由extern标记的已定义变量会引发错误<br>
定义能且只能被定义一次，但可以被多次声明<br>
int j； 声明并定义  extern int j；声明  extern int j=1；定义</p>
<p>习题2.11<br>
(a)定义，因为已经初始化了(b)声明(c)声明</p>
<p>2.2.3标识符<br>
标识符对大小写字母敏感<br>
命名规范 1.体现实际含义 2.使用小写字母 3.用户自定义的类名一般以大写字母开头 4.多个单词组成时应有明显区分</p>
<p>习题2.12<br>
（a）非法 double是关键词<br>
（b）合法<br>
（c）符号-非法<br>
（d）非法，应该字母或下划线开头<br>
（e）合法，因为大小写敏感，Double不属于关键字</p>
<p>2.2.4<br>
全局作用域：函数体外定义 块作用域：定义在函数块内<br>
内层作用域中可以重新定义外层作用域已有的名字 但是不建议</p>
<p>习题2.13<br>
j=100，因为内层作用域中的同名向量会覆盖外层的名字<br>
习题2.14<br>
输出i=100 sum=45，for循环头定义的i作用域只能在循环体内，且会覆盖外层作用域的参数。</p>
<p>2.3复合类型<br>
一个声明语句：基本数据类型+声明符（例如&amp; *） 每个声明符命名了一个变量，并且指定该变量为与基本数据类型有关的某种类型（引用或指针）<br>
2.3.1<br>
引用  int i = 1024； int &amp;refer = i;  //refer指向i<br>
<strong>引用必须被初始化，不能只声明不定义</strong><br>
引用 是把变量和它的初始值绑定（bind）在一起，而不是把初始值拷贝给应用，<br>
引用将和它的初始值对象一直绑定在一起，而无法将应用重新绑定到另外一个对象，因引用必须初始化。<br>
可以给引用赋值（区分初始化）<br>
赋值和初始化的区别(赋值：已经存在的对象，初始化：刚刚构造的对象，赋值的时候调用重载的赋值运算符，初始化的时候调用拷贝构造函数。)。<br>
引用可以复引用 int &amp;refer2 = refer; 但是无法定义引用的引用，因为引用本身不是一个对象<br>
引用可以用于赋值或初始化 int i2 = refer;<br>
引用类型的初始值必须是一个对象，不可以是字面值或者某个表达式</p>
<p>习题2.15<br>
（b） 不合法，不能用普通引用指向字面值常量（d）不合法，引用必须初始化<br>
习题2.16<br>
都合法，只是c、d会损失精度<br>
习题2.17<br>
两个都为10</p>
<p>2.3.2<br>
指针与引用的区别：1.指针是一个对象，可以对其进行赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象（引用只能指向一个对象）2.指针无须在定义时赋初值<br>
定义指针类型 int *ip1<br>
获取指针的地址 &amp; 取地址符 int *ip2 = &amp;ip1；<br>
<strong>不能定义指向引用的指针 因为引用不是对象</strong><br>
所有指针的类型都要和它所指向的对象严格匹配<br>
指针的四个状态1.指向一个对象2.指向紧邻对象所占空间的下一位置 3.空指针 4.无效指针<br>
就算指向的对象为初始化，指针也不为空<br>
无效指针不能访问，否则引发错误<br>
* 解引用符<br>
空指针生成方法 int *p1 = nullptr;   int *p2 = 0;   int *p3 = NULL;（需要引用#include cstdlib）<br>
nullptr 通用的特殊类型字面值 更推荐使用<br>
NULL 预处理变量 值为0<br>
一个指针指向某对象，而另一指针指向另外对象的下一地址，指针值可能相同<br>
void* 指针 可以存放任何类型的对象的地址 但只能进行指针比较，作为函数输入输出或者赋给另外一个void*指针，<strong>不能直接操作所指对象，不能赋给其他特定类型的指针对象</strong><br>
<em><em>不能用int初始int</em>，就是int中可能是地址的值也不行</em>*</p>
<p>习题2.18</p>
<pre><code>	int x,y= 10;
	int *x_p = &amp;x;
	*x_p = 20;
	cout &lt;&lt; *x_p &lt;&lt; endl;  //20
	x_p = &amp;y;
	cout &lt;&lt; *x_p &lt;&lt; endl; //10
</code></pre>
<p>习题2.19<br>
指针是一个对象，引用不是一个对象，所以有指针的引用，没有引用的指针。<br>
习题2.20<br>
将i的值进行平方<br>
习题2.21<br>
（a）非法，指针的类型应该和其指向的对象的类型一致，不会执行默认类型转换（b）非法，<em><em>不能用int初始int</em>，就是int中可能是地址的值也不行</em>*<br>
习题2.22<br>
if(p)判断p是否为空指针  if(*p)判断p指向的值是否为0 <strong>就算指向的对象为初始化，指针也不为空</strong><br>
习题2.23<br>
只能通过if进行空指针判断，对象的有效性是必需由程序员保证的<br>
习题2.24<br>
void*指针可以指向任何类型的指针，只是不能进行直接的操作。</p>
<p>2.3.3<br>
声明符应该靠近变量而不是类型，<em><em>比如int</em> p1,p2;//其实等同于int *p1;int p2;</em>*<br>
根据*的个数可以判断指针的级别 同时也等于解引用次数<br>
存在指向指针的引用 int *i = 42; int *p ;<strong>int *&amp;r=p;</strong><br>
使用从右向左阅读，离变量名最近的符号对变量的类型有最直接的影响 例如int *&amp;r<br>
习题2.25<br>
(a)ip是int指针，i是int，r是int引用<br>
(b)i是int，ip是int指针<br>
(c)ip是int指针，ip2是int<br>
<strong>声明符应该靠近变量而不是类型的原因</strong></p>

            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://lixin-ee.github.io//post/shu-zu-fan-zhuan-tu-xiang">
              <h3 class="post-title">
                数组832-翻转图像
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '253c8689f3b11b51dcf1',
    clientSecret: '64df7c097665e7dd6f416ecfaba36581a91bdb63',
    repo: 'Nixil-ee.github.io',
    owner: 'Lixin-ee',
    admin: ['Lixin-ee'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://lixin-ee.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

      </div>
    </div>
  </body>
</html>
