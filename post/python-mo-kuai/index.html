<html>
  <head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Python - 模块 | Lixin-SCUT</title>
<link rel="shortcut icon" href="https://lixin-scut.github.io//favicon.ico?v=1589849150637">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://lixin-scut.github.io//styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://lixin-scut.github.io/">
  <img class="avatar" src="https://lixin-scut.github.io//images/avatar.png?v=1589849150637" alt="">
  </a>
  <h1 class="site-title">
    Lixin-SCUT
  </h1>
  <p class="site-description">
    千里之行，始于足下。不积跬步，无以至千里。
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          时间轴
        </a>
      
    
      
        <a href="/tags" class="menu">
          分类/标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>


        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Python - 模块
            </h2>
            <div class="post-info">
              <time class="post-time">
                · 2020-05-10 ·
              </time>
              
                <a href="https://lixin-scut.github.io//tag/qC53A8dj2" class="post-tag">
                  # Python
                </a>
              
                <a href="https://lixin-scut.github.io//tag/FaScKSk5i" class="post-tag">
                  # 读书笔记
                </a>
              
            </div>
            
            <div class="post-content">
              <h2 id="模块">模块</h2>
<p>为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Python中，<strong>一个.py文件就称之为一个模块（Module）</strong>。</p>
<p>使用模块最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Python内置的模块和来自第三方的模块。</p>
<p>使用模块还可以<strong>避免函数名和变量名冲突</strong>。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在<strong>编写模块时，不必考虑名字会与其他模块冲突</strong>。但是也要注意，<strong>尽量不要与内置函数名字冲突</strong>。</p>
<p>但不同的人编写的模块名可能相同，为了<strong>避免模块名冲突</strong>，Python又引入了<strong>按目录来组织模块</strong>的方法，称为<strong>包（Package）</strong>。</p>
<p>举个例子，一个abc.py的文件就是一个名字叫abc的模块，一个xyz.py的文件就是一个名字叫xyz的模块。</p>
<p>现在，假设我们的abc和xyz这两个模块名字与其他模块冲突了，于是我们可以<strong>通过包来组织模块</strong>，避免冲突。方法是<strong>选择一个顶层包名，比如mycompany</strong>，按照如下目录存放：</p>
<pre><code>mycompany
├─ __init__.py
├─ abc.py
└─ xyz.py
</code></pre>
<p>引入了包以后，<strong>只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突</strong>。现在，abc.py模块的名字就变成了mycompany.abc，类似的，xyz.py的模块名变成了mycompany.xyz。</p>
<p>请注意，<strong>每一个包目录下面都会有一个<code>__init__.py</code>的文件</strong>，这个文件是<strong>必须存在的</strong>，否则，Python就把这个目录<strong>当成普通目录，而不是一个包</strong>。<code>__init__.py</code>可以是<strong>空文件</strong>，也可以<strong>有Python代码</strong>，因为__init__.py<strong>本身就是一个模块</strong>，而它的模块名就是mycompany。</p>
<p>类似的，可以有多级目录，组成多级层次的包结构。比如如下的目录结构：</p>
<pre><code>mycompany
 ├─ web
 │  ├─ __init__.py
 │  ├─ utils.py
 │  └─ www.py
 ├─ __init__.py
 ├─ abc.py
 └─ utils.py
</code></pre>
<p>文件<code>www.py</code>的模块名就是<code>mycompany.web.www</code>，两个文件<code>utils.py</code>的模块名分别是<code>mycompany.utils</code>和<code>mycompany.web.utils</code>。</p>
<p>自己创建模块时要注意命名，<strong>不能和Python自带的模块名称冲突</strong>。例如，系统自带了sys模块，自己的模块就不可命名为sys.py，否则将无法导入系统自带的sys模块。<br>
<code>mycompany.web</code>也是一个模块，请指出该模块对应的.py文件。</p>
<h3 id="总结">总结</h3>
<p>模块是一组Python代码的集合，可以使用其他模块，也可以被其他模块使用。</p>
<p>创建自己的模块时，要注意：</p>
<ol>
<li>模块名要<strong>遵循Python变量命名规范</strong>，不要使用中文、特殊字符；</li>
<li>模块名<strong>不要和系统模块名冲突</strong>，最好先查看系统是否已存在该模块，检查方法是在Python交互环境执行import abc，若成功则说明系统存在此模块。</li>
</ol>
<h2 id="使用模块">使用模块</h2>
<p>Python本身就内置了很多非常有用的模块，只要安装完毕，这些模块就可以立刻使用。</p>
<p>我们以内建的sys模块为例，编写一个hello的模块：</p>
<pre><code>#!/usr/bin/env python3
# -*- coding: utf-8 -*-

' a test module '

__author__ = 'Michael Liao'

import sys

def test():
    args = sys.argv
    if len(args)==1:
        print('Hello, world!')
    elif len(args)==2:
        print('Hello, %s!' % args[1])
    else:
        print('Too many arguments!')

if __name__=='__main__':
    test()
</code></pre>
<pre><code>#!/usr/bin/env python3
# -*- coding: utf-8 -*-
</code></pre>
<p>第1行和第2行是标准注释，第1行注释可以让这个hello.py文件直接在Unix/Linux/Mac上运行，第2行注释表示.py文件本身使用标准UTF-8编码；</p>
<pre><code>' a test module '
</code></pre>
<p>第4行是一个字符串，表示模块的文档注释，<strong>任何模块代码的第一个字符串都被视为模块的文档注释</strong>；</p>
<pre><code>__author__ = 'Michael Liao'
</code></pre>
<p>第6行使用__author__变量把作者写进去</p>
<p>以上就是Python模块的标准文件模板，当然也可以全部删掉不写，但是，按标准办事肯定没错。</p>
<p>后面开始就是真正的代码部分。</p>
<p>使用sys模块的第一步，就是导入该模块：</p>
<pre><code>import sys
</code></pre>
<p>导入sys模块后，我们就有了<strong>变量sys</strong>指向该模块，<strong>利用sys这个变量</strong>，就可以访问sys模块的所有功能。</p>
<p>sys模块有一个argv变量，用list存储了命令行的所有参数。argv至少有一个元素，因为第一个参数永远是该.py文件的名称，例如：</p>
<p>运行python3 hello.py获得的sys.argv就是<code>['hello.py']</code>；</p>
<p>运行python3 hello.py Michael获得的sys.argv就是<code>['hello.py', 'Michael]</code>。</p>
<p>最后，注意到这两行代码：</p>
<pre><code>if __name__=='__main__':
    test()
</code></pre>
<p>当我们在命令行运行hello模块文件时，Python解释器把一个<strong>特殊变量name</strong>置为__main__，而如果在其他地方导入该hello模块时，if判断将失败，因此，<strong>这种if测试可以让一个模块通过命令行运行时执行一些额外的代码</strong>，最常见的就是运行测试。</p>
<p>用命令行运行hello.py看看效果：</p>
<pre><code>$ python3 hello.py
Hello, world!
$ python hello.py Michael
Hello, Michael!
</code></pre>
<p>如果启动Python交互环境，再导入hello模块：</p>
<pre><code>$ python3
Python 3.4.3 (v3.4.3:9b73f1c3e601, Feb 23 2015, 02:52:03) 
[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import hello
&gt;&gt;&gt;
</code></pre>
<p>导入时，没有打印Hello, word!，因为没有执行test()函数。</p>
<p>调用hello.test()时，才能打印出Hello, word!：</p>
<pre><code>&gt;&gt;&gt; hello.test()
Hello, world!
</code></pre>
<h2 id="作用域">作用域</h2>
<p>在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，<strong>有的函数和变量我们希望仅仅在模块内部使用</strong>。在Python中，是<strong>通过_前缀</strong>来实现的。</p>
<p>正常的函数和变量名是<strong>公开的（public），可以被直接引用</strong>，比如：abc，x123，PI等；</p>
<p>类似<code>__xxx__</code>这样的变量是<strong>特殊变量，可以被直接引用，但是有特殊用途</strong>，比如上面的<code>__author__</code>，<code>__name__</code>就是特殊变量，hello模块定义的文档注释也可以用特殊变量<code>__doc__</code>访问，自定义的变量<strong>一般不要用这种变量名</strong>；</p>
<p>类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是<strong>非公开的（private)</strong>，<strong>不应该被直接引用</strong>，比如<code>_abc</code>，<code>__abc</code>等；</p>
<p>之所以我们说，<strong>private函数和变量“不应该”被直接引用 ，而不是“不能”被直接引用</strong>，是因为<strong>Python并没有一种方法可以完全限制访问private函数或变量</strong>，但是，从编程习惯上<strong>不应该引用private函数或变量</strong>。</p>
<p>private函数或变量不应该被别人引用</p>
<p>使用例子：</p>
<pre><code>def _private_1(name):
    return 'Hello, %s' % name

def _private_2(name):
    return 'Hi, %s' % name

def greeting(name):
    if len(name) &gt; 3:
        return _private_1(name)
    else:
        return _private_2(name)
</code></pre>
<p>我们在模块里<strong>公开greeting()函数</strong>，而把<strong>内部逻辑用private函数隐藏起来</strong>了，这样，<strong>调用greeting()函数不用关心内部的private函数细节</strong>，这也是一种非常有用的代<strong>码封装和抽象的方法</strong>，即：</p>
<p><strong>外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。</strong></p>
<h2 id="安装第三方模块">安装第三方模块</h2>
<p>在Python中，安装第三方模块，是通过<strong>包管理工具pip</strong>完成的。</p>
<p>如果正在使用Mac或Linux，安装pip本身这个步骤就可以跳过了。</p>
<p>如果正在使用Windows，请参考安装Python一节的内容，确保安装时勾选了pip和Add python.exe to Path。</p>
<p>在命令提示符窗口下尝试运行pip，如果Windows提示未找到命令，可以重新运行安装程序添加pip。</p>
<p>注意：Mac或Linux上有可能并存Python 3.x和Python 2.x，<strong>因此对应的pip命令是pip3</strong>。</p>
<p>例如，我们要安装一个第三方库——Python Imaging Library，这是Python下非常强大的处理图像的工具库。不过，PIL目前只支持到Python 2.7，并且有年头没有更新了，因此，基于PIL的Pillow项目开发非常活跃，并且支持最新的Python 3。</p>
<p>一般来说，第三方库都会在Python官方的pypi.python.org网站注册，要安装一个第三方库，必须先知道该库的名称，可以在官网或者pypi上搜索，比如Pillow的名称叫Pillow，因此，安装Pillow的命令就是：</p>
<pre><code>pip install Pillow
</code></pre>
<p>耐心等待下载并安装后，就可以使用Pillow了。</p>
<h2 id="安装常用模块">安装常用模块</h2>
<p>在使用Python时，我们经常需要用到很多第三方库，例如，上面提到的Pillow，以及MySQL驱动程序，Web框架Flask，科学计算Numpy等。用pip一个一个安装费时费力，还需要考虑兼容性。我们推荐直接使用Anaconda，这是一个基于Python的<strong>数据处理和科学计算平台</strong>，它<strong>已经内置了许多非常有用的第三方库</strong>，我们装上Anaconda，就相当于把数十个第三方模块自动安装好了，非常简单易用。</p>
<p>可以从Anaconda官网下载GUI安装包，安装包有500~600M，所以需要耐心等待下载。下载后直接安装，Anaconda会把系统Path中的python指向自己自带的Python，并且，Anaconda安装的第三方模块会安装在Anaconda自己的路径下，不影响系统已安装的Python目录。</p>
<p>安装好Anaconda后，重新打开命令行窗口，输入python，可以看到Anaconda的信息：</p>
<pre><code>│Python 3.6.3 |Anaconda, Inc.| ... on win32              │
│Type &quot;help&quot;, ... for more information.                  │
│&gt;&gt;&gt; import numpy                                        │
│&gt;&gt;&gt; _ 
</code></pre>
<p>可以尝试直接import numpy等已安装的第三方模块。</p>
<h2 id="模块搜索路径">模块搜索路径</h2>
<p>当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错：</p>
<pre><code>&gt;&gt;&gt; import mymodule
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
ImportError: No module named mymodule
</code></pre>
<p>默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，<strong>搜索路径存放在sys模块的path变量中</strong>：</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path
['', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python36.zip', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6', ..., '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages']
</code></pre>
<p>如果我们要添加自己的搜索目录，有两种方法：</p>
<ol>
<li><strong>直接修改sys.path</strong>，添加要搜索的目录：</li>
</ol>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path.append('/Users/michael/my_py_scripts')
</code></pre>
<p>这种方法是<strong>在运行时修改，运行结束后失效</strong>。</p>
<ol start="2">
<li>设置环境变量PYTHONPATH，该环境变量的内容会被<strong>自动添加到模块搜索路径中</strong>。设置方式与设置Path环境变量类似。注意只需要添加你自己的搜索路径，<strong>Python自己本身的搜索路径不受影响</strong>。</li>
</ol>

            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://lixin-scut.github.io//post/python-han-shu-shi-bian-cheng">
              <h3 class="post-title">
                Python - 函数式编程
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '253c8689f3b11b51dcf1',
    clientSecret: '64df7c097665e7dd6f416ecfaba36581a91bdb63',
    repo: 'Lixin-SCUT.github.io',
    owner: 'Lixin-SCUT',
    admin: ['Lixin-SCUT'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://lixin-scut.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

      </div>
    </div>
  </body>
</html>
