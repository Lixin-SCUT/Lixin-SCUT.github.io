<html>
  <head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>C++ primer 第十三章 笔记+习题 13.6 | Lixin-ee</title>
<link rel="shortcut icon" href="https://lixin-ee.github.io//favicon.ico?v=1573439997953">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://lixin-ee.github.io//styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://lixin-ee.github.io/">
  <img class="avatar" src="https://lixin-ee.github.io//images/avatar.png?v=1573439997953" alt="">
  </a>
  <h1 class="site-title">
    Lixin-ee
  </h1>
  <p class="site-description">
    好景在望。
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          时间轴
        </a>
      
    
      
        <a href="/tags" class="menu">
          分类/标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>


        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              C++ primer 第十三章 笔记+习题 13.6
            </h2>
            <div class="post-info">
              <time class="post-time">
                · 2019-11-06 ·
              </time>
              
                <a href="https://lixin-ee.github.io//tag/Esg34ccex" class="post-tag">
                  # C++ Primer
                </a>
              
            </div>
            
            <div class="post-content">
              <p>13.6对象移动<br>
使用移动而不是拷贝的另一个原因源于<strong>IO类或unique_ptr等类不应该被拷贝</strong>，包含不能被共享的资源<br>
在旧标准中，没有直接的方法移动对象，在新标准中，我们可以<strong>用容器保存不可以拷贝</strong>的类型，只要它们能被<strong>移动</strong>即可<br>
标准库容器、string和shared_ptr类既支持移动也支持拷贝，<strong>IO类和unique_ptr类可以移动但不可以拷贝</strong></p>
<p>13.6.1右值引用<br>
为了<strong>支持移动操作</strong>，新标准引入了一种新的引用类型—<strong>右值引用</strong>，其有一个重要的性质，<strong>只能绑定到一个将要销毁的对象</strong>，因此我们可以自由地将一个<strong>右值引用的资源移动到另一个对象中</strong><br>
一般而言，一个<strong>左值表达式</strong>表示的是一个<strong>对象的身份</strong>，一个<strong>右值表达式</strong>表示的是<strong>对象的值</strong><br>
对于常规引用（即左值引用），我们<strong>不能</strong>将其绑定到要求<strong>转换的表达式、字面常量或是返回右值的表达式</strong>。而右值引用完全相反，我们可以将一个右值引用绑定到这类表达式上，但<strong>不能将一个右值引用直接绑定到一个左值上</strong>。</p>
<p>左值引用可用的表达式：返回左值引用的函数，赋值、下标、解引用和<strong>前置递增/递减运算符</strong><br>
右值引用可用的表达式：返回非引用类型的函数，算术、关系、位以及<strong>后置递增/递减运算符</strong><br>
但是我们可以将一个const的左值引用绑定到右值表达式中。<br>
左值表达式与右值表达式的区别：左值有持久的状态，右值要么是字面常量，要么是在表达式求值过程中创建的临时对象<br>
由于右值引用只能绑定到临时对象，所以<strong>1.所引用的对象将要被销毁2.该对象没有其他用户</strong>。这两个特性意味着使用右值引用的代码可以自由接管所引用的对象的资源<br>
右值引用指向将要被销毁的对象，因此，我们可以从绑定到右值引用的对象窃取状态<br>
<strong>变量</strong>可以看作<strong>只有一个运算对象而没有运算符的表达式</strong>，所以变量表达式都是左值 <strong>（导致右值引用本身是一个左值！）</strong></p>
<p>原因：变量是持久的，直至离开作用域才被销毁<br>
虽然不能将一个右值引用<strong>直接绑定</strong>到一个左值上，但可以<strong>显式</strong>地将一个<strong>左值</strong>转换为对应的<strong>右值引用</strong>类型，我们还可以用过调用一个名为move的新标准库函数来获得绑定到左值上的右值引用，move调用告诉编译器：我们有一个左值，但是我们希望像一个右值一样处理它，但<strong>对某个左值调用move后</strong>就意味着承诺除了对该左值进行<strong>赋值或销毁外不再使用它</strong><br>
int &amp;&amp;rr3 = std::move(rr1); //完成转移后，rr1为移后源对象，相当于一次移动<br>
调用move后，我们不<strong>能再对移后源对象</strong>rr1的值<strong>做任何假设</strong>，<strong>只能对其进行销毁或赋予新值</strong>，不能使用一个移后源对象的值<br>
对move不提供using声明，直接调用std::move而不是move，<strong>避免潜在的名字冲突</strong></p>
<p>习题13.45<br>
右值引用只能绑定到一个将要销毁的对象，表示的是对象的值，可以将其绑定到要求转换的表达式、字面常量或是返回右值的表达式。右值短暂，要么是字面常量，要么是在表达式求值过程中创建的临时对象<br>
习题13.46<br>
r1 f()返回一个非引用类型的int临时变量，只能用右值引用&amp;&amp;<br>
r2 下标符号返回的是左值， 只能用左值引用&amp;<br>
r3 r1是右值引用，但是本质上是一个变量，也就是一个左值，所以得用左值引用&amp;<br>
r4 两者习题相乘等于算术符号，只能用 右值引用<br>
习题13.47 13.48</p>
<pre><code>String::String(const String &amp;s) {
	auto newdata = alloc_n_copy(s.begin(), s.end());
	elements = newdata.first;
	first_free = cap = newdata.second;
	cout &lt;&lt; &quot;拷贝构造函数&quot; &lt;&lt; endl;
}

String&amp; String::operator=(const String &amp;rhs) {
	auto data = alloc_n_copy(rhs.begin(), rhs.end());
	free();
	elements = data.first;
	first_free = cap = data.second;
	cout &lt;&lt; &quot;拷贝赋值函数&quot; &lt;&lt; endl;
	return *this;
}
</code></pre>
<p>非常神奇，第一次拷贝的时候用了1次拷贝构造函数，第二次用了2次，第三次用了3次，第四次用了4次，第五次用了5次。。。和我的想象差距非常大，似乎每次push_back时都需要将每个元素注意地拷贝构造（为啥？）</p>
<p>13.6.2移动构造函数和移动赋值运算符<br>
移动构造函数的<strong>第一个参数</strong>是该类类型的一个<strong>引用</strong>，不同于拷贝构造函数，这个引用参数是一个<strong>右值引用</strong>，与拷贝构造函数一样，<strong>任何额外参数都必须有默认实参</strong><br>
移动构造函数必须保证移后源对象处于可销毁状态（销毁它是无害的）（对移后源对象<strong>赋值nullptr</strong>），特别是在资源完成移动后，必须保证源对象必须不再指向被移动的资源—这些资源的所有权已经归属新创建的对象<br>
移动构造函数<strong>不分配任何新内存</strong>，它接管原对象中的内存后，将<strong>给定对象中的指针</strong>都置为<strong>nullptr</strong>，从而完成从给定对象的移动操作，此对象将继续存在，移后源对象将会被销毁<br>
因为移动操作只是接管资源，通常不需要分配任何资源，因此移动操作<strong>通常不会抛出任何异常</strong>，但除非告诉标准库我们的移动构造函数不会抛出异常，否则它会认为移动我们的类对象时可能会抛出异常，并且为了处理这种可能性而做一些额外的工作<br>
<strong>noexcept是我们承诺一个函数不抛出异常</strong>的一种方法。我们在一个函数的参数列表后指定noexcept。在一个构造函数中，noexcept出现在<strong>参数列表和初始化列表开始的冒号之间</strong>，同时我们必须在类头文件的<strong>声明和定义</strong>中（<strong>定义在类外时</strong>）<strong>都指定</strong>noexcept<br>
如果<strong>不对移动构造函数显式声明noexcept，就会自动使用拷贝构造函数</strong>而不是移动构造函数<br>
<strong>移动赋值运算符也应该标记为noexcept</strong><br>
在移动赋值运算符中，我们<strong>首先检查</strong>左侧对象与右侧右值引用<strong>是否指向同一地址</strong>，如果<strong>相同则不要做任何操作</strong>（<strong>自赋值检查</strong>），否则，<strong>先释放左侧</strong>运算对象所使用的内存，并接管给定对象的内存<br>
从<strong>一个对象移动数据并不会销毁此对象</strong>，但当我们编写一个移动操作时，必须确保移后源对象<strong>进入一个可析构状态</strong>，除此之外，移动操作还必须保证移后源对象仍然是<strong>有效的（对象有效是指可以安全地为其赋予新值或者可以安全地使用而不依赖于当前值）</strong> 同时移动操作无法保证移后源对象中留下的值，所以我们的程序不应该依赖于移后源对象中的数据<br>
总结：在移动操作之后，移后源对象必须保持有效、可析构的状态，但是用户不能对其值进行任何假设<br>
<strong>编译器不会为某些类合成移动操作</strong>，特别是当一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，<strong>编译器就不会为它合成移动构造函数和移动赋值运算符，反而类会通过正常的函数匹配从而使用对应的拷贝操作来代替移动操作</strong><br>
<strong>只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符</strong>，编译器可以移动内置类型成员，如果一个成员是类类型，且该类有对应的移动操作，编译器也能移动这个成员<br>
与拷贝操作不同，<strong>移动操作永远不会隐式定义为删除的函数</strong>。但是如果我们显式地要求编译器生成=default的移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数<br>
将合成的移动操作定义为删除的函数遵循以下原则：</p>
<p><strong>如果类定义了移动操作，则也必须定义拷贝操作</strong>，否则<strong>拷贝操作</strong>都会默认地被<strong>定义为删除的</strong><br>
如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则<br>
来确定使用哪个构造函数，赋值操作的情况类似</p>
<p>如果一个类有一个拷贝构造函数但未定义移动构造函数，编译器不会合成移动构造函数，这意味着此类将有拷贝构造函数但不会有移动构造函数。如果一个类没有移动构造函数，函数匹配规则保证该类型的对象只会被拷贝，即使我们试图通过调用 move 來移动它们时也是如此<br>
值得注意的是，用拷贝构造函数代替移动构造函数几乎肯定是安全的</p>
<p>拷贝并交换赋值运算符和移动操作</p>
<p>对于同时定义了移动构造函数和拷贝构造函数的类，将其拷贝赋值运算符的参数改成非引用类型变为通用的赋值运算符，此时运算符有一个非引用参数.这意味着此参数要进行拷 贝初始化。依赖于实参的类型，拷贝初始化要么使用拷贝构造函数，要么使用移动构造函数——左值被拷贝，右值被移动。因此，单一的赋值运算符 就实现了拷贝赋值运算符和移动赋值运算符两种功能。</p>
<p>更新三/五法则<br>
所有五个应该看作一个整体：一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作，并且某些类必须定义拷贝构造函数、拷贝赋值运算符和析构函数才能正确工作<br>
移动迭代器<br>
新标准库中定义了一种移动迭代器（move iterator )适配器<br>
一个移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器<br>
一个普通迭代器的解引用运算符返回一个指向元素的左值。与其他迭代器不同，移动迭代器的，解引用运算符生成一个右值引用。<br>
通过调用标准库的 make_move_iterator 函数将一个普通迭代器转换为一个移动迭代器。此函数接受一个迭代器参数，返回一个移动迭代器。<br>
原迭代器的所有其他操作在移动迭代器中都照常工作。特别是，可以将移动迭代器传递给uninitialized_copy</p>
<p>uninitialized _ copy 对输入序列中的毎个元素调用 construct 来将元素&quot;拷贝&quot;到目的位置。此算法使用迭代器的解引用运算符从输入序列中提取元素。由于我们传递给它的是移动迭代器，因此解引用运算符生成的是一个右值引用，这意味着 construct 将使用移动构造函数来构造元素。<br>
值得注意的是，标准库不保证哪些算法适用移动迭代器，哪些不适用。由于移动一个对象可能销毁掉原对象，因此你只有在确信算法在为一个元素赋值或将其传递给一个用户 定义的函数后不再访问它时，才能将移动迭代器传递给算法。<br>
当我们调用move是，必须绝对确认移后源对象没有其他用户</p>
<p>习题13.49</p>
<pre><code>StrVec::StrVec(StrVec &amp;&amp;s) noexcept
	:elements(s.elements),first_free(s.first_free),cap(s.cap){
	s.elements = s.first_free = s.cap = nullptr;
}
StrVec &amp;StrVec::operator=(StrVec &amp;&amp;rhs)noexcept {
	if (&amp;rhs != this) {
		free();
		elements = rhs.elements;
		first_free = rhs.first_free;
		cap = rhs.cap;
		rhs.elements = rhs.first_free = rhs.cap = nullptr;
	}
	return *this;
}
</code></pre>
<p>注意：<br>
1.noexcept不能忘了，并且声明和定义的时候都需要<br>
2.不一定需要std::move<br>
3.自检使用<code>(&amp;rhs != this)</code>而不是<code>(rhs != *this)</code>或者<code>(rhs == *this)</code>，前者是指针可以直接比较，后者是类通常没有定义<br>
4.记得先free后转移，因为进行了自移动检查，所以可以直接free</p>
<p>习题13.50</p>
<pre><code>String::String(String &amp;&amp;s) noexcept: elements(s.elements),first_free(s.first_free),cap(s.cap){
	s.elements = s.first_free = s.cap = nullptr;
	cout &lt;&lt; &quot;移动构造函数&quot; &lt;&lt; endl;
}
String &amp;String::operator=(String &amp;&amp;rhs)noexcept {
	if (&amp;rhs != this) {
		free();
		elements = rhs.elements;
		first_free = rhs.first_free;
		cap = rhs.cap;
	}
	cout &lt;&lt; &quot;移动赋值函数&quot; &lt;&lt; endl;
	return *this;
}
</code></pre>
<p>验证代码</p>
<pre><code>	vector&lt;String&gt; vs;
	String s(&quot;123&quot;);
	vs.push_back(s);
	vs.push_back(&quot;123&quot;);
</code></pre>
<p>很明显地，s是一个恒存在的左值，所以动用了拷贝构造函数<br>
同时&quot;123&quot;是一个即将销毁的右值，所以动用了移动构造函数<br>
同时！第二次push_back除非reallocate将s拷贝的值移动时也是移动构造函数<br>
明显地函数会自动根据参数的类型选择相应的构造函数</p>
<p>习题13.51<br>
此时形参值将要被销毁或者只是一个局部对象，会被视为右值，会自动调用移动构造函数</p>
<p>习题13.52<br>
第一个赋值中右侧运算对象是一个左值，因此必须使用拷贝构造函数（注意此处的hp其实是未定义的，否则就是拷贝赋值函数了）<br>
第二个中强行move了hp2，将一个右值引用绑定到hp2上，此时拷贝构造函数和移动构造函数都可以，但是移动构造函数是精确匹配的。</p>
<p>习题13.53<br>
因为缺少移动赋值函数，每次拷贝赋值函数都需要进行交换拷贝操作，对于右值对象来说需要额外的内存和操作（先拷贝构造再拷贝赋值再销毁）</p>
<pre><code>Hasptr1(Hasptr1&amp;&amp; p) noexcept : ps(p.ps), i(p.i)
	{
		p.ps = 0;
		std::cout &lt;&lt; &quot;call move constructor&quot; &lt;&lt; std::endl;
	}
	// Hasptr&amp; operator=(Hasptr1 &amp;&amp;rhs) noexcept
	//{
	//    if (this != &amp;rhs)
	//    {
	//        delete ps;
	//        ps = rhs.ps;
	//        i = rhs.i;
	//        rhs.ps = nullptr;
	//        std::cout &lt;&lt; &quot;call move assignment&quot; &lt;&lt; std::endl;
	//    }

</code></pre>
<p>13.54<br>
<strong>如果类定义了移动操作，则也必须定义拷贝操作</strong>，否则<strong>拷贝操作</strong>都会默认地被<strong>定义为删除的</strong></p>
<p>13.6.3右值引用和成员函数<br>
一个成员函数最好同时提供拷贝和移动版本，一个版本接受一个指向 const 的左值引用，第二个版本接受一个指向非const 的右值引用。<br>
一般来说，我们不需要为函数操作定义接受一个 constX &amp;&amp;或是一个（普通的）X&amp;参数的版本。<br>
当我们希望从实参&quot;窃取&quot;数据时，通常传递一个右值引用。为了达到这一目的，实参不能是const的。类似的，从一个对象进行拷贝的操作不应该改变该对象。因此，通常不需要定义一个接受一个（普通的） X &amp;参数的版本。<br>
区分移动和拷贝的重载函数通常有一个版本接受一个 const T&amp;,而另一个版本接受一个 T &amp;&amp;。</p>
<p>右值和左值引用成员函数</p>
<p>旧标准中允许对一个右值进行赋值，为了维持向后兼容性，新标准库类仍然允许向右值赋值。但是，我们可能希望在自己的类中阻止这种用法。<br>
引用限定符：强制左侧运算对象（即this 指向的对象）是一个左值/右值。</p>
<p>引用限定符可以是&amp;或&amp;&amp;，分别指出 this 可以指向一个左值或右值<br>
引用限定符只能用于（非 static )成员函数，且必须同时出现在函数的声明和定义中<br>
对于&amp;限定的函数，我们只能将它用于左值；对于&amp;&amp;限定的函数，只能用于右值:</p>
<p>一个函数可以同时用 const 和引用限定。在此情况下，引用限定符必须跟随在const限定符之后</p>
<p>重载和引用函数<br>
就像一个成员函数可以根据是否有 const 来区分其重载版本一样，引用限定符也可以区分重载版本。而且，我们可以综合引用限定符和 const 来区分一个成员函数的重载版本</p>
<p>当我们对一个右值执行 sorted 时，它可以安全地直接对 data 成员进行排序。对象是一个右值，意味着没有其他用户，因此我们可以改变对象。当对一个 const 右值或一个左值执行 sorted 时，我们不能改变对象，因此就需要在排序前拷贝 data 。</p>
<p>如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符。</p>
<p>习题13.55</p>
<pre><code>	void push_back(const string &amp;t)&amp; { data-&gt;push_back(t); }
	void push_back(string &amp;&amp;t)&amp;&amp; { data-&gt;push_back(t); }
</code></pre>
<p>习题13.56<br>
ret.sorted()会陷入无限循环（不断地调用左值形参版本）<br>
习题13.57<br>
会调用右值形参版本，如果没有右值形参版本，则陷入无限循环<br>
习题13.58</p>
<pre><code>class Foo{
public:
	Foo(std::vector&lt;int&gt; vi) :data(vi) {};
	Foo sorted() &amp;&amp; ;
	Foo sorted()const &amp;;
	std::vector&lt;int&gt; data;
};

Foo Foo::sorted() &amp;&amp; {
	std::sort(data.begin(), data.end());
	return *this;
}

Foo Foo::sorted()const &amp; {
	Foo ret(*this);
	sort(ret.data.begin(), ret.data.end());
	return ret;
}
</code></pre>
<p>56运行结果</p>
<pre><code>warning C4717: “Foo::sorted”: 如递归所有控件路径，函数将导致运行时堆栈溢出
</code></pre>
<p>57运行结果<br>
未注释右值形参版本的话输出正确，注释掉的话如下</p>
<pre><code>warning C4717: “Foo::sorted”: 如递归所有控件路径，函数将导致运行时堆栈溢出
</code></pre>
<p>习题感悟<br>
1.noexcept不能忘了，并且声明和定义的时候都需要<br>
2.不一定需要std::move<br>
3.自检使用<code>(&amp;rhs != this)</code>而不是<code>(rhs != *this)</code>或者<code>(rhs == *this)</code>，前者是指针可以直接比较，后者是类通常没有定义<br>
4.记得先free后转移，因为进行了自移动检查，所以可以直接free<br>
<strong>如果类定义了移动操作，则也必须定义拷贝操作</strong>，否则<strong>拷贝操作</strong>都会默认地被<strong>定义为删除的</strong></p>

            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://lixin-ee.github.io//post/lian-biao-160-xiang-jiao-lian-biao-jian-dan">
              <h3 class="post-title">
                链表 160. 相交链表[简单]
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '253c8689f3b11b51dcf1',
    clientSecret: '64df7c097665e7dd6f416ecfaba36581a91bdb63',
    repo: 'Nixil-ee.github.io',
    owner: 'Lixin-ee',
    admin: ['Lixin-ee'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://lixin-ee.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

      </div>
    </div>
  </body>
</html>
