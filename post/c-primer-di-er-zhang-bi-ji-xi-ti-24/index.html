<html>
  <head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>C++ primer 第二章 笔记+习题 2.4-2.6 | Lixin-ee</title>
<link rel="shortcut icon" href="https://lixin-scut.github.io//favicon.ico?v=1581383483605">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://lixin-scut.github.io//styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://lixin-scut.github.io/">
  <img class="avatar" src="https://lixin-scut.github.io//images/avatar.png?v=1581383483605" alt="">
  </a>
  <h1 class="site-title">
    Lixin-ee
  </h1>
  <p class="site-description">
    好景在望。
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          时间轴
        </a>
      
    
      
        <a href="/tags" class="menu">
          分类/标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>


        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              C++ primer 第二章 笔记+习题 2.4-2.6
            </h2>
            <div class="post-info">
              <time class="post-time">
                · 2019-09-04 ·
              </time>
              
                <a href="https://lixin-scut.github.io//tag/Esg34ccex" class="post-tag">
                  # C++ Primer
                </a>
              
                <a href="https://lixin-scut.github.io//tag/JZUtdJBb3" class="post-tag">
                  # C++
                </a>
              
            </div>
            
            <div class="post-content">
              <p>2.4<br>
const 常量关键字，const对象一旦创建后就不能改变值，所以const对象必须初始化<br>
默认状态下 const对象仅在文件内有效，添加extern关键字就可以分享使用，只需要定义一次，在其他文件直接用extern声明就好<br>
声明和定义是不一样的</p>
<p>习题2.26<br>
（a）不合法，const必须初始化（b）合法（c）合法（d）</p>
<p>2.4.1<br>
对const的引用 const int ci = 1024; const int &amp;r1 = ci;<br>
引用的例外：初始化常量引用允许用任意表达式作为初始值 甚至是不同类型的值,只要该表达式的结果能转换成引用的类型即可，尤其是允许为一个常量引用绑定一个非常量的<br>
的对象、字面值，甚至一个一般表达式<br>
当 执行 double dval = 3.14; const int &amp;r1 = dval;时，实际编译时是 const int temp = dval; const int &amp;ri = temp; 将ri绑定到一个不会变化的临时量temp上，所以合法。<br>
<strong>常量应用仅对引用可参与的操作做出了界限，对引用对象本身是否是常量并未限定<br>
指向常量对象的引用必须是常量引用，不能是普通引用，但常量引用可以绑定到普通对象上。</strong></p>
<p>2.4.2<br>
存放常量的地址只能是 指向常量的指针（区分常量指针，同时指向常量的指针也没有规定必须指向常量对象）<br>
常量指针 必须初始化的固定值指针<br>
从右向左阅读，离变量名最近的符号决定变量的自身类型 一开始的符号决定指向的类型<br>
注意*的位置<br>
int errnumb = 0；int *const curerr = &amp;errnumb； 指向int变量的常量指针<br>
const double pi=3.1415；const double *const pip = &amp;pi；指向double常量（第一个const）的常量指针（第二个const）</p>
<p>习题2.27<br>
（a）不合法，指向常量的必须是常量引用<br>
（b）合法，常量指针可以指向非常量（c）合法（d）合法（e）合法<br>
（f）不合法，常量指针必须初始化<br>
（g）合法，指向常量的指针可以指向非常量，只是操作受到限制<br>
习题2.28<br>
（a）不合法，常量指针必须初始化<br>
（b）不合法，常量指针必须初始化<br>
（c）不合法，常量和常量引用必须初始化<br>
（d）不合法，常量指针必须初始化<br>
（e）指向常量的指针<br>
习题2.29<br>
（a）合法，常量可以赋值给非常量<br>
（b）不合法，不能把指向常量的指针直接赋给普通指针<br>
（c）不合法，不能用普通指针指向常量<br>
（d）如果是初始化，合法，如果是赋值，不合法<br>
（e）不合法，常量指针不能被赋值<br>
（f）不合法，常量不可以赋值</p>
<p>2.4.3<br>
顶层const 指针本身就是个常量 底层const 指针所指对象是个常量<br>
const int ci = 42；const int *const p3 = &amp;ci; 时 int *p = p3；为错误操作，因<strong>为p3为底层const 指向常量，只能由指向常量的指针<br>
注意！引用没有顶层const和底层const之分，引用可以说是天生有顶层const（引用必须初始化，初始化后不能更改绑定的对象）<br>
然后中文版的翻译是有错的，只有top-level const和low-level const，同时类型的命名就好像剥洋葱--。const int *p ---- p是指针，指向int，int是const。int * const p ---- p是const，是指针，指向int。每个符号都是修饰上一个符号 而不是为了修饰p，比如const int*，int修饰*得到整型指针、const修饰int得到整型常量，结合起来就等于指向整型的指针</strong></p>
<p>习题2.30<br>
v2：顶层const          p2：底层const          p3:顶层const<br>
习题2.31<br>
合法；<br>
不合法 ；合法 ；<br>
不合法；合法</p>
<p>2.4.4<br>
常量表达式：值不会改变并且在编译过程中就能得到计算结果的表达式<br>
用常量表达式初始化的const对象也是常量表达式</p>
<p>声明为constexpr的变量一定是一个常量，而且必须用常量表达式进行初始化<br>
如果你认定变量是一个常量表达式，那就把它声明成constexpr类型</p>
<p>字面值类型：算数类型（int、double）、引用、指针<br>
非字面值类型：自定义类、IO库、string类 不能被定义成constexpr<br>
constexpr指针的值不能改标 相当于常量指针但位置与const不同<br>
int const *p 等同于 constexpr int *p<br>
constexpr const int *p 指向整形常量的常量指针<br>
定义在函数体之外的对象的地址固定不变，可用于初始化constexpr指针</p>
<p>习题2.32<br>
非法，null是保留字 修改变量名并最好使用nullptr</p>
<p>2.5.1<br>
类型别名 某种类型的同义词<br>
定义类型别名（1）typedef （2）别名声明 关键词 using<br>
类型别名可以间接使用 typedef double a； using b = a； 则b也是double类型<br>
地址的类型别名 typedef int *pint；<br>
**但注意 const pint *ps 等于指向int的常量指针，而非指向int常量的指针，**因为使用了类型别名后不等同于直接展开的。</p>
<p>2.5.2<br>
auto类型说明符 让编译器分析表达式所属的类型<br>
auto类型的变量必须有初始值<br>
如果在一条auto语句中声明多个变量，则语句中所有变量的初始基本类型都必须一样<br>
auto i = 0,*p = &amp;i;//正确，初始基本类型都是int（声明符号*不算在基本类型内）<br>
auto 会以引用对象的类型作为auto的类型，而不是把它视为引用，如果想定义为引用 必须使用auto &amp;<br>
auto会忽略顶层const 保留底层const 所以顶层const需要明确指出 const auto<br>
常量引用可以绑定字面值</p>
<p>习题2.33<br>
a = 42;<br>
b = 42;<br>
c = 42；<br>
e:error；<br>
f:error；<br>
g:error；<br>
习题2.35<br>
第一个auto  j  类型为int<br>
第二个auto  &amp;k 类型为const int &amp;<br>
第三个auto *p类型为const int *<br>
第四个auto j2类型为const int<br>
第五个auto &amp;k2 类型为const int&amp;</p>
<p>2.5.3<br>
decltype 选择并返回操作数的数据类型<br>
使用方法 decltype（f（）） sum = x；<br>
引用从来都作为其所指对象的同义词出现，只有用在decltype处是一个例外：decltype并不管引用的对象是谁，只返回引用类型<br>
int i = 1，*p = &amp;i；&amp;r = i； 其中decltype（r）返回引用类型，decltype（r+0）返回int<br>
decltype（i=i1）返回引用 而当表达式的内容是解引用操作，则decltype将得到引用类型 所以decltype（*p）返回int&amp; 而不是int<br>
decltype的括号数量影响返回值 decltype（（变量））双层括号永远返回引用类型 decltype（变量） 单层括号就返回变量的类型。双层括号会被当做一个可作为赋值语句左值的表达式<br>
先执行decltype中的表达式再计算定义的表达式 decltype(a=b) c = a;//结果c = b</p>
<p>习题2.36<br>
decltype(())双层括号表示引用（注意引用必须初始化）<br>
a是int类型   4<br>
b是int类型   4<br>
c是int类型   4<br>
d是int &amp;类型    4<br>
全是4！！！！！！！！！！！<br>
习题2.37<br>
a int 3;<br>
b int 4;<br>
c int 3;<br>
d int &amp; 3;<br>
习题2.38<br>
1：如果使用引用类型，auto会识别为其所指对象的类型，decltype则会识别为引用的类型。<br>
2：decltype(())双括号的差别。</p>
<p>2.6<br>
类类型 相当于以类的形式自定义数据类型<br>
struct 关键词<br>
类体的花括号形成一个新的作用域  表示结束的花括号后必须写一个分号，因为类体后面可以紧跟变量名，以示对该类型对象的定义<br>
类体内定义类的成员<br>
没有初始值的成员将被默认初始化<br>
类内初始值可以用花括号和等号，不能用圆括号</p>
<p>习题2.39<br>
error C2628: “example”后面接“int”是非法的(是否忘记了“;”?)<br>
error C3874: “main”的返回类型应为“int”而非“example”<br>
非常有趣，第二个错误显示编译器试图把类声明视为返回类型</p>
<p>2.6.3<br>
类一般定义在头文件中<br>
头文件改变后需要重新编译源文件获取更新过的声明<br>
预处理器 看到#include标记就会使用指定的头文件的内容代替#include<br>
另外一项预处理功能是头文件保护符 依赖于预处理变量<br>
#define 将一个名字设定为预处理变量 #ifdef 当且仅当变量已定义时为真 #ifndef当且仅当变量未定义时时为真   遇到#endif指令停止<br>
预处理变量无视作用域的规则<br>
预处理变量 包括头文件保护符必须唯一 使用头文件中类的名字来构建保护符的名字，同时大写预处理变量的名字<br>
头文件保护符是给头文件用在其自身的！！！</p>
<p>习题2.40 2.41 2.42<br>
struct Sales_Data {<br>
public:<br>
string ISBN;<br>
int units_sold = 0;<br>
double price = 0.00;<br>
double ave = 0.00;</p>
<pre><code>	int input_data(istream &amp;in) {
		in &gt;&gt; ISBN &gt;&gt; units_sold &gt;&gt; price;
		ave = price*ave / ave;
	}
	
	Sales_Data&amp; add_data(Sales_Data&amp; data1,Sales_Data&amp; data2) {
		if (data1.equal_isbn(data2)) {
			Sales_Data sum;
			sum.units_sold = data1.units_sold + data2.units_sold;

			sum.ave = (data1.units_sold*data1.price + data2.units_sold*data2.price) / sum.units_sold;
			sum.price = sum.ave;
			return sum;
		}
		else
		{
			std::cerr &lt;&lt; &quot;Data must have same ISBN&quot; &lt;&lt; std::endl;
		}

		
	}

	bool equal_isbn(Sales_Data exam)const {
		return ((*this).ISBN == exam.ISBN);
	}
</code></pre>

            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://lixin-scut.github.io//post/shu-zu-27-yi-chu-yuan-su">
              <h3 class="post-title">
                数组-27. 移除元素
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '253c8689f3b11b51dcf1',
    clientSecret: '64df7c097665e7dd6f416ecfaba36581a91bdb63',
    repo: 'Lixin-SCUT.github.io',
    owner: 'Lixin-SCUT',
    admin: ['Lixin-SCUT'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://lixin-scut.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

      </div>
    </div>
  </body>
</html>
