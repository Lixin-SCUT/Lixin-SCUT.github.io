<html>
  <head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Python - Web开发 | Lixin-SCUT</title>
<link rel="shortcut icon" href="https://lixin-scut.github.io//favicon.ico?v=1589766718370">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://lixin-scut.github.io//styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://lixin-scut.github.io/">
  <img class="avatar" src="https://lixin-scut.github.io//images/avatar.png?v=1589766718370" alt="">
  </a>
  <h1 class="site-title">
    Lixin-SCUT
  </h1>
  <p class="site-description">
    千里之行，始于足下。不积跬步，无以至千里。
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          时间轴
        </a>
      
    
      
        <a href="/tags" class="menu">
          分类/标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>


        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Python - Web开发
            </h2>
            <div class="post-info">
              <time class="post-time">
                · 2020-05-13 ·
              </time>
              
                <a href="https://lixin-scut.github.io//tag/qC53A8dj2" class="post-tag">
                  # Python
                </a>
              
                <a href="https://lixin-scut.github.io//tag/FaScKSk5i" class="post-tag">
                  # 读书笔记
                </a>
              
            </div>
            
            <div class="post-content">
              <p>最早的软件都是运行在大型机上的，软件使用者通过“哑终端”登陆到大型机上去运行软件。后来随着PC机的兴起，软件开始主要运行在桌面上，而数据库这样的软件运行在服务器端，这种<strong>Client/Server模式简称CS架构</strong>。</p>
<p>随着互联网的兴起，人们发现，CS架构不适合Web，最大的原因是Web应用程序的修改和升级非常迅速，而<strong>CS架构需要每个客户端逐个升级桌面App</strong>，因此，<strong>Browser/Server模式开始流行，简称BS架构</strong>。</p>
<p>在BS架构下，<strong>客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端</strong>。浏览器只需要请求服务器，获取Web页面，并把Web页面展示给用户即可。</p>
<p>当然，Web页面也具有极强的交互性。由于Web页面是用HTML编写的，而HTML具备超强的表现力，并且，<strong>服务器端升级后，客户端无需任何部署就可以使用到新的版本</strong>，因此，BS架构迅速流行起来。</p>
<p>今天，除了重量级的软件如Office，Photoshop等，大部分软件都以Web形式提供。比如，新浪提供的新闻、博客、微博等服务，均是Web应用。</p>
<p>Web应用开发可以说是目前软件开发中最重要的部分。Web开发也经历了好几个阶段：</p>
<p>静态Web页面：由文本编辑器直接编辑并生成静态的HTML页面，如果要修改Web页面的内容，就需要再次编辑HTML源文件，早期的互联网Web页面就是静态的；</p>
<p>CGI：由于静态Web页面无法与用户交互，比如用户填写了一个注册表单，静态Web页面就无法处理。要处理用户发送的动态数据，出现了Common Gateway Interface，简称CGI，用C/C++编写。</p>
<p>ASP/JSP/PHP：由于Web应用特点是修改频繁，用C/C++这样的低级语言非常不适合Web开发，而脚本语言由于开发效率高，与HTML结合紧密，因此，迅速取代了CGI模式。ASP是微软推出的用VBScript脚本编程的Web开发技术，而JSP用Java来编写脚本，PHP本身则是开源的脚本语言。</p>
<p>MVC：为了解决直接用脚本语言嵌入HTML导致的可维护性差的问题，Web应用也引入了<strong>Model-View-Controller的模式</strong>，来简化Web开发。ASP发展为ASP.Net，JSP和PHP也有一大堆MVC框架。</p>
<p>目前，Web开发技术仍在快速发展中，异步开发、新的MVVM前端技术层出不穷。</p>
<p>Python的诞生历史比Web还要早，由于Python是一种解释型的脚本语言，开发效率高，所以非常适合用来做Web开发。</p>
<p>Python有上百种Web开发框架，有很多成熟的模板技术，选择Python开发Web应用，不但开发效率高，而且运行速度快。</p>
<h2 id="http协议简介">HTTP协议简介</h2>
<p>在Web应用中，服务器把网页传给浏览器，实际上就是把网页的HTML代码发送给浏览器，让浏览器显示出来。而浏览器和服务器之间的传输协议是HTTP，所以：</p>
<ol>
<li>
<p><strong>HTML是一种用来定义网页的文本</strong>，会HTML，就可以<strong>编写网页</strong>；</p>
</li>
<li>
<p><strong>HTTP是在网络上传输HTML的协议</strong>，用于<strong>浏览器和服务器的通信</strong>。</p>
</li>
</ol>
<p>我们需要在浏览器很方便地调试我们的Web应用，而Chrome提供了一套完整地调试工具，非常适合Web开发。</p>
<p>安装好Chrome浏览器后，打开Chrome，在菜单中选择“视图”，“开发者”，“开发者工具”，就可以显示开发者工具<br>
Elements显示网页的结构，Network显示浏览器和服务器的通信。我们点Network，确保第一个小红灯亮着，Chrome就会记录所有浏览器和服务器之间的通信：<br>
当我们在地址栏输入<code>www.sina.com.cn</code>时，浏览器将显示新浪的首页。在这个过程中，浏览器都干了哪些事情呢？通过Network的记录，我们就可以知道。在Network中，定位到第一条记录，点击，右侧将显示Request Headers，点击右侧的view source，我们就可以看到浏览器发给新浪服务器的请求<br>
最主要的头两行分析如下，第一行：</p>
<pre><code>GET / HTTP/1.1
</code></pre>
<p>GET表示一个读取请求，将从服务器获得网页数据，/表示URL的路径，URL总是以/开头，/就表示首页，最后的HTTP/1.1指示采用的HTTP协议版本是1.1。目前HTTP协议的版本就是1.1，但是大部分服务器也支持1.0版本，主要区别在于1.1版本允许多个HTTP请求复用一个TCP连接，以加快传输速度。</p>
<p>从第二行开始，每一行都类似于<code>Xxx: abcdefg</code>：</p>
<pre><code>Host: www.sina.com.cn
</code></pre>
<p>表示请求的域名是<code>www.sina.com.cn</code>。如果一台服务器有多个网站，服务器就需要通过Host来区分浏览器请求的是哪个网站。</p>
<p>继续往下找到Response Headers，点击view source，显示服务器返回的原始响应数据</p>
<p>HTTP响应分为Header和Body两部分（Body是可选项），我们在Network中看到的Header最重要的几行如下：</p>
<pre><code>200 OK
</code></pre>
<p>200表示一个成功的响应，后面的OK是说明。失败的响应有404 Not Found：网页不存在，500 Internal Server Error：服务器内部出错，等等。</p>
<pre><code>Content-Type: text/html
</code></pre>
<p>Content-Type指示响应的内容，这里是text/html表示HTML网页。请注意，<strong>浏览器就是依靠Content-Type来判断响应的内容是网页还是图片，是视频还是音乐。</strong> 浏览器并不靠URL来判断响应的内容，所以，即使URL是<code>http://example.com/abc.jpg</code>，它也不一定就是图片。</p>
<p>HTTP响应的Body就是HTML源码，我们在菜单栏选择“视图”，“开发者”，“查看网页源码”就可以在浏览器中直接查看HTML源码</p>
<p>当浏览器读取到新浪首页的HTML源码后，它会解析HTML，显示页面，然后，根据HTML里面的各种链接，再发送HTTP请求给新浪服务器，拿到相应的图片、视频、Flash、JavaScript脚本、CSS等各种资源，最终显示出一个完整的页面。所以我们在Network下面能看到很多额外的HTTP请求。</p>
<h3 id="http请求">HTTP请求</h3>
<p>跟踪了新浪的首页，我们来总结一下HTTP请求的流程：</p>
<p>步骤1：浏览器首先向服务器发送HTTP请求，请求包括：</p>
<p>方法：GET还是POST，<strong>GET仅请求资源</strong>，<strong>POST会附带用户数据</strong>；</p>
<p>路径：<code>/full/url/path</code>；</p>
<p>域名：由Host头指定：<code>Host: www.sina.com.cn</code></p>
<p>以及其他相关的Header；</p>
<p>如果是POST，那么请求还包括一个Body，包含用户数据。</p>
<p>步骤2：服务器向浏览器返回HTTP响应，响应包括：</p>
<p>响应代码：200表示成功，3xx表示重定向，4xx表示客户端发送的请求有错误，5xx表示服务器端处理时发生了错误；</p>
<p>响应类型：<strong>由Content-Type指定</strong>，例如：Content-Type: text/html;charset=utf-8表示响应类型是HTML文本，并且编码是UTF-8，Content-Type: image/jpeg表示响应类型是JPEG格式的图片；</p>
<p>以及其他相关的Header；</p>
<p>通常服务器的HTTP响应会携带内容，也就是有一个<strong>Body，包含响应的内容，网页的HTML源码就在Body中</strong>。</p>
<p>步骤3：如果浏览器还需要继续向服务器请求其他资源，比如图片，就再次发出HTTP请求，重复步骤1、2。</p>
<p>Web采用的HTTP协议采用了非常简单的请求-响应模式，从而大大简化了开发。当我们编写一个页面时，我们只需要在HTTP响应中把HTML发送出去，不需要考虑如何附带图片、视频等，浏览器如果需要请求图片和视频，它会发送另一个HTTP请求，因此，一个HTTP请求只处理一个资源。</p>
<p>HTTP协议同时具备极强的扩展性，虽然<strong>浏览器请求</strong>的是<code>http://www.sina.com.cn/</code>的首页，但是新浪<strong>在HTML中可以链入其他服务器的资源（反向代理）</strong>，比如<code>&lt;img src=&quot;http://i1.sinaimg.cn/home/2013/1008/U8455P30DT20131008135420.png&quot;&gt;</code>，从而将请求压力分散到各个服务器上，并且，一个站点可以链接到其他站点，无数个站点互相链接起来，就形成了World Wide Web，简称“三达不溜”（WWW）。</p>
<h3 id="http格式">HTTP格式</h3>
<p>每个HTTP请求和响应都遵循相同的格式，一个HTTP包含Header和Body两部分，其中Body是可选的。</p>
<p>HTTP协议是一种文本协议，所以，它的格式也非常简单。HTTP GET请求的格式：</p>
<pre><code>GET /path HTTP/1.1
Header1: Value1
Header2: Value2
Header3: Value3
</code></pre>
<p><strong>每个Header一行一个，换行符是\r\n</strong>。</p>
<p>HTTP POST请求的格式：</p>
<pre><code>POST /path HTTP/1.1
Header1: Value1
Header2: Value2
Header3: Value3

body data goes here...
</code></pre>
<p>当<strong>遇到连续两个\r\n时，Header部分结束，后面的数据全部是Body</strong>。</p>
<p>HTTP响应的格式：</p>
<pre><code>200 OK
Header1: Value1
Header2: Value2
Header3: Value3

body data goes here...
</code></pre>
<p>HTTP响应<strong>如果包含body，也是通过\r\n\r\n来分隔的</strong>。请再次注意，<strong>Body的数据类型由Content-Type头来确定</strong>，如果是网页，Body就是文本，如果是图片，Body就是图片的二进制数据。</p>
<p><strong>当存在Content-Encoding时，Body数据是被压缩的，最常见的压缩方式是gzip</strong>，所以，看到Content-Encoding: gzip时，需要将Body数据先解压缩，才能得到真正的数据。压缩的目的在于减少Body的大小，加快网络传输。</p>
<h2 id="html简介">HTML简介</h2>
<p>网页就是HTML？这么理解大概没错。因为网页中不但包含文字，还有图片、视频、Flash小游戏，有复杂的排版、动画效果，所以，HTML定义了一套语法规则，来告诉浏览器如何把一个丰富多彩的页面显示出来。</p>
<p>最简单的HTML：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Hello&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1&gt;Hello, world!&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>可以用文本编辑器编写HTML，然后保存为hello.html，双击或者把文件拖到浏览器中</p>
<p>HTML文档就是一系列的Tag组成，最外层的Tag是<code>&lt;html&gt;</code>。规范的HTML也包含<code>&lt;head&gt;...&lt;/head&gt;</code>和<code>&lt;body&gt;...&lt;/body&gt;</code>（注意不要和HTTP的Header、Body搞混了），由于HTML是富文档模型，所以，还有一系列的Tag用来表示链接、图片、表格、表单等等。</p>
<h3 id="css简介">CSS简介</h3>
<p>CSS是<strong>Cascading Style Sheets（层叠样式表）</strong> 的简称，CSS用来<strong>控制HTML里的所有元素如何展现</strong>，比如，给标题元素<code>&lt;h1&gt;</code>加一个样式，变成48号字体，灰色，带阴影：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Hello&lt;/title&gt;
  &lt;style&gt;
    h1 {
      color: #333333;
      font-size: 48px;
      text-shadow: 3px 3px 3px #666666;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1&gt;Hello, world!&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="javascript简介">JavaScript简介</h3>
<p>JavaScript虽然名称有个Java，但它和Java真的一点关系没有。JavaScript是为了<strong>让HTML具有交互性而作为脚本语言添加的</strong>，JavaScript既可以内嵌到HTML中，也可以从外部链接到HTML中。如果我们希望当用户点击标题时把标题变成红色，就必须通过JavaScript来实现：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Hello&lt;/title&gt;
  &lt;style&gt;
    h1 {
      color: #333333;
      font-size: 48px;
      text-shadow: 3px 3px 3px #666666;
    }
  &lt;/style&gt;
  &lt;script&gt;
    function change() {
      document.getElementsByTagName('h1')[0].style.color = '#ff0000';
    }
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1 onclick=&quot;change()&quot;&gt;Hello, world!&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>小结</strong></p>
<p>如果要学习Web开发，首先要对HTML、CSS和JavaScript作一定的了解。HTML定义了页面的内容，CSS来控制页面元素的样式，而JavaScript负责页面的交互逻辑。</p>
<h2 id="wsgi接口">WSGI接口</h2>
<p>了解了HTTP协议和HTML文档，我们其实就明白了一个Web应用的本质就是：</p>
<ol>
<li>
<p>浏览器发送一个HTTP请求；</p>
</li>
<li>
<p>服务器收到请求，生成一个HTML文档；</p>
</li>
<li>
<p>服务器把HTML文档作为HTTP响应的Body发送给浏览器；</p>
</li>
<li>
<p>浏览器收到HTTP响应，从HTTP Body取出HTML文档并显示。</p>
</li>
</ol>
<p>所以，<strong>最简单的Web应用就是先把HTML用文件保存好，用一个现成的HTTP服务器软件，接收用户请求，从文件中读取HTML</strong>，返回。<strong>Apache、Nginx、Lighttpd</strong>等这些常见的<strong>静态服务器</strong>就是干这件事情的。</p>
<p>如果要动态生成HTML，就需要把上述步骤自己来实现。不过，接受HTTP请求、解析HTTP请求、发送HTTP响应都是苦力活，如果我们自己来写这些底层代码，还没开始写动态HTML呢，就得花个把月去读HTTP规范。</p>
<p>正确的做法是<strong>底层代码由专门的服务器软件实现，我们用Python专注于生成HTML文档</strong>。因为我们不希望接触到TCP连接、HTTP原始请求和响应格式，所以，<strong>需要一个统一的接口，让我们专心用Python编写Web业务</strong>。</p>
<p>这个接口就是<strong>WSGI：Web Server Gateway Interface</strong>。</p>
<p>WSGI接口定义非常简单，它只要求Web开发者<strong>实现一个函数，就可以响应HTTP请求</strong>。我们来看一个最简单的Web版本的“Hello, web!”：</p>
<pre><code>def application(environ, start_response):
    start_response('200 OK', [('Content-Type', 'text/html')])
    return [b'&lt;h1&gt;Hello, web!&lt;/h1&gt;']
</code></pre>
<p>上面的application()函数就是符合WSGI标准的一个HTTP处理函数，它接收两个参数：</p>
<ol>
<li>
<p>environ：一个<strong>包含所有HTTP请求信息的dict对象</strong>；</p>
</li>
<li>
<p>start_response：一个<strong>发送HTTP响应的函数</strong>。</p>
</li>
</ol>
<p>在application()函数中，调用：</p>
<pre><code>start_response('200 OK', [('Content-Type', 'text/html')])
</code></pre>
<p>就<strong>发送了HTTP响应的Header</strong>，注意Header只能发送一次，也就是只能调用一次start_response()函数。start_response()函数接收两个参数，一个是<strong>HTTP响应码</strong>，一个是一组list表示的<strong>HTTP Header</strong>，每个Header用一个包含两个str的tuple表示。</p>
<p>通常情况下，都应该把<strong>Content-Type头</strong>发送给浏览器。其他很多常用的HTTP Header也应该发送。</p>
<p>然后，函数的返回值<code>b'&lt;h1&gt;Hello, web!&lt;/h1&gt;'</code>将作为<strong>HTTP响应的Body</strong>发送给浏览器。</p>
<p>有了WSGI，我们关心的就是如何从environ这个dict对象拿到HTTP请求信息，然后构造HTML，通过start_response()发送Header，最后返回Body。</p>
<p>整个application()函数本身没有涉及到任何解析HTTP的部分，也就是说，底层代码不需要我们自己编写，我们只负责在更高层次上考虑如何响应请求就可以了。</p>
<p>不过这个application()函数怎么调用？如果我们自己调用，<strong>两个参数environ和start_response我们没法提供，返回的bytes也没法发给浏览器</strong>。</p>
<p>所以<strong>application()函数必须由WSGI服务器来调用</strong>。有很多符合WSGI规范的服务器，我们可以挑选一个来用。但是现在，我们只想尽快测试一下我们编写的application()函数真的可以把HTML输出到浏览器，所以需要赶紧找一个最简单的WSGI服务器，把我们的Web应用程序跑起来。</p>
<p>好消息是<strong>Python内置了一个WSGI服务器，这个模块叫wsgiref</strong>，它是用纯Python编写的WSGI服务器的参考实现。所谓“参考实现”是指该实现完全符合WSGI标准，但是<strong>不考虑任何运行效率，仅供开发和测试使用</strong>。</p>
<h3 id="运行wsgi服务">运行WSGI服务</h3>
<p>我们先编写hello.py，<strong>实现Web应用程序的WSGI处理函数</strong>：</p>
<pre><code>
# hello.py

def application(environ, start_response):
    start_response('200 OK', [('Content-Type', 'text/html')])
    return [b'&lt;h1&gt;Hello, web!&lt;/h1&gt;']
		
</code></pre>
<p>然后，再编写一个server.py，<strong>负责启动WSGI服务器，加载application()函数</strong>：</p>
<pre><code>
# server.py
# 从wsgiref模块导入:
from wsgiref.simple_server import make_server
# 导入我们自己编写的application函数:
from hello import application

# 创建一个服务器，IP地址为空，端口是8000，处理函数是application:
httpd = make_server('', 8000, application)
print('Serving HTTP on port 8000...')
# 开始监听HTTP请求:
httpd.serve_forever()

</code></pre>
<p>注意：如果8000端口已被其他程序占用，启动将失败，请修改成其他端口。</p>
<p>启动成功后，打开浏览器，输入<code>http://localhost:8000/</code>，就可以看到结果了：</p>
<p>在命令行可以看到wsgiref打印的log信息</p>
<p>按Ctrl+C终止服务器。</p>
<p>如果你觉得这个Web应用太简单了，可以稍微改造一下，从environ里读取PATH_INFO，这样可以显示更加动态的内容：</p>
<pre><code>
# hello.py

def application(environ, start_response):
    start_response('200 OK', [('Content-Type', 'text/html')])
    body = '&lt;h1&gt;Hello, %s!&lt;/h1&gt;' % (environ['PATH_INFO'][1:] or 'web')
    return [body.encode('utf-8')]
		
</code></pre>
<p>你可以在地址栏输入用户名作为URL的一部分，将返回Hello, xxx!：</p>
<h3 id="小结">小结</h3>
<p>无论多么复杂的Web应用程序，入口都是一个WSGI处理函数。HTTP请求的所有输入信息都可以通过environ获得，HTTP响应的输出都可以通过start_response()加上函数返回值作为Body。</p>
<p>复杂的Web应用程序，光靠一个WSGI函数来处理还是太底层了，我们需要在WSGI之上再抽象出Web框架，进一步简化Web开发。</p>
<h2 id="web框架">Web框架</h2>
<p>解了WSGI框架，我们发现：其实一个Web App，就是写一个WSGI的处理函数，针对每个HTTP请求进行响应。</p>
<p>但是如何处理HTTP请求不是问题，问题是如何处理100个不同的URL。</p>
<p><strong>每一个URL可以对应GET和POST请求，当然还有PUT、DELETE等请求</strong>，但是我们通常只考虑最常见的GET和POST请求。</p>
<p>一个最简单的想法是从environ变量里取出HTTP请求的信息，然后逐个判断：</p>
<pre><code>def application(environ, start_response):
    method = environ['REQUEST_METHOD']
    path = environ['PATH_INFO']
    if method=='GET' and path=='/':
        return handle_home(environ, start_response)
    if method=='POST' and path='/signin':
        return handle_signin(environ, start_response)
    ...
</code></pre>
<p>只是这么写下去代码是肯定没法维护了。</p>
<p>代码这么写没法维护的原因是因为WSGI提供的接口虽然比HTTP接口高级了不少，但和Web App的处理逻辑比，还是比较低级，我们<strong>需要在WSGI接口之上能进一步抽象，让我们专注于用一个函数处理一个URL，至于URL到函数的映射，就交给Web框架来做</strong>。</p>
<p>由于用Python开发一个Web框架十分容易，所以Python有上百个开源的Web框架。这里我们先不讨论各种Web框架的优缺点，直接选择一个<strong>比较流行的Web框架——Flask</strong>来使用。</p>
<p>用Flask框架编写Web App比WSGI接口简单，我们先用pip安装Flask：</p>
<pre><code>$ pip install flask
</code></pre>
<p>然后写一个app.py，<strong>处理3个URL</strong>，分别是：</p>
<ul>
<li>
<p>GET /：首页，返回Home；</p>
</li>
<li>
<p>GET /signin：登录页，显示登录表单；</p>
</li>
<li>
<p>POST /signin：处理登录表单，显示登录结果。</p>
</li>
</ul>
<p>注意噢，<strong>同一个URL/signin分别有GET和POST两种请求</strong>，映射到两个处理函数中。</p>
<p>Flask通过<strong>Python的装饰器</strong>在内部<strong>自动地把URL和函数给关联起来</strong>，所以，我们写出来的代码就像这样：</p>
<pre><code>from flask import Flask
from flask import request

app = Flask(__name__)

@app.route('/', methods=['GET', 'POST'])
def home():
    return '&lt;h1&gt;Home&lt;/h1&gt;'

@app.route('/signin', methods=['GET'])
def signin_form():
    return '''&lt;form action=&quot;/signin&quot; method=&quot;post&quot;&gt;
              &lt;p&gt;&lt;input name=&quot;username&quot;&gt;&lt;/p&gt;
              &lt;p&gt;&lt;input name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/p&gt;
              &lt;p&gt;&lt;button type=&quot;submit&quot;&gt;Sign In&lt;/button&gt;&lt;/p&gt;
              &lt;/form&gt;'''

@app.route('/signin', methods=['POST'])
def signin():
    # 需要从request对象读取表单内容：
    if request.form['username']=='admin' and request.form['password']=='password':
        return '&lt;h3&gt;Hello, admin!&lt;/h3&gt;'
    return '&lt;h3&gt;Bad username or password.&lt;/h3&gt;'

if __name__ == '__main__':
    app.run()
</code></pre>
<p>运行python app.py，Flask自带的Server在端口5000上监听：</p>
<pre><code>$ python app.py 
 * Running on http://127.0.0.1:5000/
</code></pre>
<p>GET /：打开浏览器，输入首页地址<code>http://localhost:5000/：</code><br>
首页显示Home则正确</p>
<p>GET /signin：再在浏览器地址栏输入<code>http://localhost:5000/signin</code>，会显示登录表单：</p>
<p>POST /signin：输入预设的用户名admin和口令password，登录成功：<br>
输入其他错误的用户名和口令，登录失败</p>
<p>实际的Web App应该拿到用户名和口令后，去数据库查询再比对，来判断用户是否能登录成功。</p>
<p>除了Flask，常见的Python Web框架还有：</p>
<ul>
<li>
<p>Django：全能型Web框架；</p>
</li>
<li>
<p>web.py：一个小巧的Web框架；</p>
</li>
<li>
<p>Bottle：和Flask类似的Web框架；</p>
</li>
<li>
<p>Tornado：Facebook的开源异步Web框架。</p>
</li>
</ul>
<p><strong>小结：</strong><br>
有了Web框架，我们在编写Web应用时，注意力就从WSGI处理函数转移到URL+对应的处理函数，这样，编写Web App就更加简单了。</p>
<p>在编写URL处理函数时，除了配置URL外，从HTTP请求拿到用户数据也是非常重要的。Web框架都提供了自己的API来实现这些功能。Flask通过<code>request.form['name']</code>来获取表单的内容。</p>
<h2 id="使用模板">使用模板</h2>
<p>Web框架把我们从WSGI中拯救出来了。现在，我们只需要不断地编写函数，带上URL，就可以继续Web App的开发了。</p>
<p>但是，Web App不仅仅是处理逻辑，展示给用户的页面也非常重要。在函数中返回一个包含HTML的字符串，简单的页面还可以，但是，想想新浪首页的6000多行的HTML</p>
<p>俗话说得好，不懂前端的Python工程师不是好的产品经理。有Web开发经验的同学都明白，Web App最复杂的部分就在HTML页面。HTML不仅要正确，还要通过CSS美化，再加上复杂的JavaScript脚本来实现各种交互和动画效果。总之，生成HTML页面的难度很大。</p>
<p>由于在Python代码里拼字符串是不现实的，所以，模板技术出现了。</p>
<h2 id="mvcmodel-view-controller">MVC：Model-View-Controller</h2>
<p>使用模板，我们需要预先准备一个HTML文档，这个HTML文档不是普通的HTML，而是嵌入了一些变量和指令，然后，根据我们传入的数据，替换后，得到最终的HTML，发送给用户：<br>
<img src="https://lixin-scut.github.io//post-images/1589379121294.png" alt=""></p>
<p>这就是传说中的<strong>MVC：Model-View-Controller，中文名“模型-视图-控制器”</strong>。</p>
<p><strong>Python处理URL的函数就是C：Controller</strong>，Controller负责<strong>业务逻辑</strong>，比如检查用户名是否存在，取出用户信息等等；</p>
<p><strong>包含变量{{ name }}的模板就是V：View</strong>，View负责<strong>显示逻辑</strong>，通过简单地替换一些变量，View最终输出的就是用户看到的HTML。</p>
<p>MVC中的Model在哪？<strong>Model是用来传给View的，这样View在替换变量的时候，就可以从Model中取出相应的数据。</strong></p>
<p>上面的例子中，Model就是一个dict：</p>
<pre><code>{ 'name': 'Michael' }
</code></pre>
<p>只是因为Python支持关键字参数，很多Web框架允许<strong>传入关键字参数，然后，在框架内部组装出一个dict作为Model</strong>。</p>
<p>现在，我们把上次直接输出字符串作为HTML的例子用高端大气上档次的MVC模式改写一下：</p>
<pre><code>from flask import Flask, request, render_template

app = Flask(__name__)

@app.route('/', methods=['GET', 'POST'])
def home():
    return render_template('home.html')

@app.route('/signin', methods=['GET'])
def signin_form():
    return render_template('form.html')

@app.route('/signin', methods=['POST'])
def signin():
    username = request.form['username']
    password = request.form['password']
    if username=='admin' and password=='password':
        return render_template('signin-ok.html', username=username)
    return render_template('form.html', message='Bad username or password', username=username)

if __name__ == '__main__':
    app.run()
</code></pre>
<p>Flask<strong>通过render_template()函数来实现模板的渲染</strong>。和Web框架类似，Python的模板也有很多种。Flask默认支持的模板是jinja2，所以我们先直接安装jinja2：</p>
<pre><code>$ pip install jinja2
</code></pre>
<p>然后，开始编写jinja2模板：</p>
<h3 id="homehtml">home.html</h3>
<p>用来显示首页的模板：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Home&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1 style=&quot;font-style:italic&quot;&gt;Home&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="formhtml">form.html</h3>
<p>用来显示登录表单的模板：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Please Sign In&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  {% if message %}
  &lt;p style=&quot;color:red&quot;&gt;{{ message }}&lt;/p&gt;
  {% endif %}
  &lt;form action=&quot;/signin&quot; method=&quot;post&quot;&gt;
    &lt;legend&gt;Please sign in:&lt;/legend&gt;
    &lt;p&gt;&lt;input name=&quot;username&quot; placeholder=&quot;Username&quot; value=&quot;{{ username }}&quot;&gt;&lt;/p&gt;
    &lt;p&gt;&lt;input name=&quot;password&quot; placeholder=&quot;Password&quot; type=&quot;password&quot;&gt;&lt;/p&gt;
    &lt;p&gt;&lt;button type=&quot;submit&quot;&gt;Sign In&lt;/button&gt;&lt;/p&gt;
  &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="signin-okhtml">signin-ok.html</h3>
<p>登录成功的模板：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Welcome, {{ username }}&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;p&gt;Welcome, {{ username }}!&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>登录失败的模板呢？我们在form.html中加了一点条件判断，把form.html重用为登录失败的模板。</p>
<p>最后，一定要把模板放到正确的templates目录下，templates和app.py在同级目录下，然后启动python app.py</p>
<p>通过MVC，我们<strong>在Python代码中处理M：Model和C：Controller</strong>，而V：View是通过模板处理的，这样，我们就成功地把Python代码和HTML代码最大限度地分离了。</p>
<p>使用模板的另一大好处是，<strong>模板改起来很方便</strong>，而且，改完保存后，刷新浏览器就能看到最新的效果，这对于调试HTML、CSS和JavaScript的前端工程师来说实在是太重要了。</p>
<p>在Jinja2模板中，我们<strong>用{{ name }}表示一个需要替换的变量。很多时候，还需要循环、条件判断等指令语句，在Jinja2中，用{% ... %}表示指令</strong>。</p>
<p>比如循环输出页码：</p>
<pre><code>{% for i in page_list %}
    &lt;a href=&quot;/page/{{ i }}&quot;&gt;{{ i }}&lt;/a&gt;
{% endfor %}
</code></pre>
<p>如果page_list是一个list：[1, 2, 3, 4, 5]，上面的模板将输出5个超链接。</p>
<p>除了Jinja2，常见的模板还有：</p>
<ul>
<li>
<p>Mako：用<code>&lt;% ... %&gt;</code>和<code>${xxx}</code>的一个模板；</p>
</li>
<li>
<p>Cheetah：也是用<code>&lt;% ... %&gt;</code>和<code>${xxx}</code>的一个模板；</p>
</li>
<li>
<p>Django：Django是一站式框架，内置一个用<code>{% ... %}</code>和<code>{{ xxx }}</code>的模板。</p>
</li>
</ul>
<p><strong>小结</strong></p>
<p>有了MVC，我们就分离了Python代码和HTML代码。HTML代码全部放到模板里，写起来更有效率。</p>

            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://lixin-scut.github.io//post/python-shu-ju-ku">
              <h3 class="post-title">
                Python - 数据库
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '253c8689f3b11b51dcf1',
    clientSecret: '64df7c097665e7dd6f416ecfaba36581a91bdb63',
    repo: 'Lixin-SCUT.github.io',
    owner: 'Lixin-SCUT',
    admin: ['Lixin-SCUT'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://lixin-scut.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

      </div>
    </div>
  </body>
</html>
