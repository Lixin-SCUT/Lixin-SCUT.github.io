<html>
  <head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title> C++ primer 第十五章 笔记+习题 15.1-15.5 | Lixin-ee</title>
<link rel="shortcut icon" href="https://lixin-ee.github.io//favicon.ico?v=1573529004488">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://lixin-ee.github.io//styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://lixin-ee.github.io/">
  <img class="avatar" src="https://lixin-ee.github.io//images/avatar.png?v=1573529004488" alt="">
  </a>
  <h1 class="site-title">
    Lixin-ee
  </h1>
  <p class="site-description">
    好景在望。
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          时间轴
        </a>
      
    
      
        <a href="/tags" class="menu">
          分类/标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>


        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
               C++ primer 第十五章 笔记+习题 15.1-15.5
            </h2>
            <div class="post-info">
              <time class="post-time">
                · 2019-11-11 ·
              </time>
              
            </div>
            
            <div class="post-content">
              <p>15.1 oop：概述<br>
面向对象程序设计（object-orientedprogramming )的<strong>核心思想</strong>是<strong>数据抽象</strong><br>
通过<strong>继承( inheritance )</strong> 联系在一起的类构成一种层次关系。通常在层次关系的根部有一个基类 （baseclass ),其他类则直接或间接地从基类继承而来，这些继承得到的类称为派生类 （derivedclass )。<strong>基类</strong>负责定义在层次关系中所有类<strong>共同拥有的成员</strong>，而每个<strong>派生类</strong>定义各自<strong>特有的成员</strong>。<br>
对于某些函数，<strong>基类</strong>希望它的<strong>派生类各自定义</strong>适合自身的版本，此时基类就将这些函数声明成<strong>虚函数 (virtualfunction)</strong></p>
<p>派生类必须通过使用<strong>类派生列表</strong>（classderivationlist )明确指出它是<strong>从哪个（哪些）基类继承而来的。</strong><br>
类派生列表的形式是：首先是一个冒号，后面紧跟<strong>以逗号分隔</strong>的基类列表，其中每个基类前面可以有访问说明符：</p>
<p>因为 Bulk_quote 在它的派生列表中使用了 <strong>public 关键字</strong>，因此我们完全可以把Bulk _ quote 的对象<strong>当成 Quote 的对象</strong>来使用</p>
<p>派生类必须在其内部对所有重新定义的<strong>虚函数进行声明</strong>。派生类可以在这样的函数之前加上 virtual 关键字.但是并不是非得这么做。<br>
出于15.3节（第538页）将要解释的原因， C ++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，具体措施是在该函数的<strong>形参列表</strong>之后增加一个<strong>override 关键字</strong>。<br>
通过使用<strong>动态绑定（dynamicbinding )</strong> , 我们能用<strong>同一段代码</strong>分别处理 Quote 和Bulkjuote 的对象<br>
上述过程中函数的<strong>运行版本</strong>由<strong>实参</strong>决定，即在<strong>运行时选择函数的版本</strong>，所以动态绑定有时又被称为<strong>运行时绑定（ run-timebinding )</strong>。<br>
在C++语言中，当我们<strong>使用基类的引用（或指针）调用一个虚函数时将发生动态绑定</strong>。</p>
<p>15.2 定义基类和派生类<br>
15.2.1定义基类<br>
作为继承关系中<strong>根节点</strong>的<strong>类</strong>通常都会定义一个<strong>虚析构函数</strong>。<br>
<strong>基类</strong>通常都应该定义一个<strong>虚析构函数</strong>，即使该函数不执行任何实际操作也是如此。<br>
遇到<strong>与类型相关的操作</strong>时，派生类必须对其重新定义。换句话说，派生类需要对这些操作提供自己的新定义以覆盖( override )从基类继承而来的旧定义。<br>
<strong>基类</strong>必须将它的<strong>两种成员函数</strong>区分开来：一种是基类<strong>希望其派生类进行覆盖</strong>的函数；另一种是基类希望派生类<strong>直接维承而不要改变</strong>的函数。对于<strong>前者</strong>，基类通常将其定义为<strong>虚函数</strong>（ virtual )。<br>
基类通过在其成员函数的声明语句之前加上<strong>关键字virtual</strong>使得该函数执行<strong>动态绑定</strong>。任何<strong>构造函数之外</strong>的<strong>非静态函数</strong>都可以是<strong>虚函数</strong>。<strong>关键字virtual</strong>只能出现在<strong>类内部的声明语句</strong>之前而<strong>不能用于类外部的函数定义</strong>。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。<br>
成员函数如果没被声明为虚函数，则其解析过程发生在编译时而非运行时。</p>
<p><strong>派生类</strong>无法访问<strong>基类的私有成员</strong><br>
派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类<br>
继承而来的成员。和其他使用基类的代码一样.派生类能访问公有成员，而不能访问私有成员。<br>
不过在某些时候基类中还有这样一种成员，<strong>基类</strong>希望它的<strong>派生类有权访问</strong>该成员，同时<strong>禁止其他用户访问</strong>。我們用<strong>受保护的（protected )访问运算符</strong>说明这样的成员。</p>
<pre><code>class Quote {
public:
	Quote() = default;
	Quote(const string &amp;book,double sales_price):bookNo(book),price(sales_price){}
	string isbn() const { return bookNo;}
	virtual double net_price(size_t n)const { return n*price; }
	virtual ~Quote()=default;
private:
	string bookNo;
protected:
	double price = 0.0;
};

double print_total(ostream &amp;os, const Quote &amp;item, size_t n)
{
	double ret = item.net_price(n);
	os &lt;&lt; &quot;ISBN:&quot; &lt;&lt; item.isbn() &lt;&lt; &quot;#sold:&quot; &lt;&lt; n &lt;&lt; &quot;total due:&quot; &lt;&lt; ret &lt;&lt; endl;
	return ret;
}
</code></pre>
<p>习题15.1<br>
也就是虚函数，基类<strong>希望其派生类进行覆盖</strong>的函数，。任何<strong>构造函数之外</strong>的<strong>非静态函数</strong>都可以是<strong>虚函数</strong>。<br>
习题15.2<br>
基类的private成员不能被派生类和其他用户访问，protected成员不能被其他用户访问，但可以被派生类访问<br>
习题15.3</p>
<p>15.2.2 定义派生类<br>
派生类必须通过使用<strong>类派生列表（class derivation list )</strong> 明确指出它是从哪个（哪些）基类继承而来的。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中<strong>每个基类前面</strong>可以有以下三种访问说明符中的一个；<strong>public 、protected 或者private</strong>。<br>
访问说明符的作用是<strong>控制派生类从基类维承而来的成员是否对派生类的用户可见</strong>。<br>
如果一个<strong>派生是公有</strong>的，则<strong>基类的公有成员</strong>也是<strong>派生类接口的组成部分</strong>。此外，我们能将<strong>公有派生类型的对象绑定到基类的引用或指针上</strong>。<br>
大多数类都只继承自一个类，这种形式的维承被称作&quot;单继承&quot;，</p>
<p>如果派生类<strong>没有覆盖</strong>其基类中的某个<strong>虚函数</strong>，则该虚函数的行为类似于其他的普通成员，派生类会<strong>直接维承其在基类中的版本</strong>。<br>
派生类可以在它覆盖的函数前使用 virtual 关键字，单不是非得这么做。<br>
C ++11新标准允许派生类<strong>显式地注明</strong>它使用某个成员函数<strong>覆盖了它维承的虚函数</strong>。具体做法是在形参列表后面、或者在 const 成员函数（参见7。1.2节，第231页）的 <strong>const 关键字</strong>后面、或者在引用成员函数（参见13.6.3节，第483页）的<strong>引用限定符后面</strong>添加一个关键字 <strong>override</strong> 。<br>
因为在<strong>派生类对象中</strong>含有与其<strong>基类对应的组成部分</strong>，所以我们能把<strong>派生类的对象</strong>当成<strong>基类对象</strong>来使用，而且我们也能将<strong>基类的指针或引用</strong>绑定到<strong>派生类对象中的基类部分</strong>上</p>
<p>这种转换通常称为<strong>派生类到基类的（ derived - to - base )类型转换</strong>。和其他类型转换一样，编译器会<strong>隐式地执行</strong>派生类到基类的转换（参见4.11节，第141页）。<br>
这种隐式特性意味着我们可以把<strong>派生类对象或者派生类对象的引用</strong>用在<strong>需要基类引用的地方</strong>；同样的，我们也可以把派生类对象的<strong>指针</strong>用在需要基类指针的地方。<br>
尽管在派生类对象中含有从基类继承而来的成员，但是派生类并<strong>不能直接初始化</strong>这些成员。和其他创建了基类对象的代码一样，<strong>派生类也必须使用基类的构造函数</strong>来初始化它的基类部分。<br>
每个类控制<strong>它自己的成员初始化</strong>过程。</p>
<p>该函数将它的<strong>前两个参数</strong>（分别表示ISBN和价格）<strong>传递给Quote的构造函数</strong>，<strong>由Quote的构造函数</strong>负责初始化Bulk_quote的<strong>基类部分</strong>（即bookNo成员和price成员）。当(空的）Quote构造函数体结束后，我们构建的对象的基类部分也就完成初始化了。接下来初始化由派生类直接定义的min_qty成员和discount成员。最后运行Bulk_quote构造函数的（空的）函数体。<br>
首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。<br>
派生类可以访问<strong>基类</strong>的<strong>公有成员和受保护成员（protected），不能访问private</strong><br>
<strong>派生类的作用域</strong>嵌套在基类的作用域之内每个类负责定义各自的接口。要想与类的对象交互必须使用该类的接口，即使这个对象是派生类的基类部分也是如此。<br>
因此，派生类对象不能直接初始化基类的成员<br>
如果基类定义了一个<strong>静态成员</strong>（参见 7.6 节，第 268 页），则在<strong>整个继承体系中</strong>只存在该成员的<strong>唯一定义</strong>。不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在<strong>唯一的实例</strong>。<br>
静态成员遵循通用的访问控制规则，如果基类中的成员是 private 的，则派生类无权访问它。假设某<strong>静态成员是可访问的</strong>，则我们既<strong>能通过基类</strong>使用它<strong>也能通过派生类</strong>使用它：</p>
<p>派生类的<strong>声明</strong>与其他类差别不大（参见7.3.3节，第250页），声明中包含类名但是<strong>不包含它的派生列表</strong>：<br>
class Bulk_quote : public Quote;//** 错误：派生列表不能出现在这里<br>
class Bulk_quote;  // 正确：声明派生类的正确方式<br>
一条<strong>声明语句的目的</strong>是令<strong>程序</strong>知晓<strong>某个名字的存在</strong>以及<strong>该名字表示一个什么样的实体</strong>，如一个类、一个函数或一个变量等。派生列表以及与定义有关的<strong>其他细节</strong>必须与<strong>类的主体一起出现</strong>。</p>
<p>如果我们想将<strong>某个类用作基类</strong>，则该类<strong>必须己经定义</strong>而<strong>非仅仅声明</strong>该规定还有一层隐含的意思，即<strong>一个类不能派生它本身</strong>。<br>
一个类是<strong>基类</strong>，同时它<strong>也可以是一个派生类</strong>：</p>
<p>在这个继承关系中，Base是D 1的直接基类 (directbase ),同时是D 2的<strong>间接基类</strong>（indirect base )。直接基类出现在派生列表中，而间接基类由派生类通过其直接基类继承而来。<br>
最终的派生类将包含它的直接基类的子对象以及每个间接基类的子对象。</p>
<p>有时我们会定义这样一种类，我们<strong>不希望其他类继承它</strong>，或者不想考虑它是否适合作为一个基类。为了实现这一目的， C ++11新标准提供了一种防止继承发生的方法，即在类名后跟一个<strong>关键字 final</strong> ：<code>class NoDerived final { /* */} //NoDerive不能作为基类</code></p>
<p>习题15.4<br>
（a）错误，不能继承自身（或者说继承的基类不能只声明而未定义）<br>
（b）正确，但是是private定义，但从基类维承而来的成员对派生类的用户不可见<br>
（c）错误，类的声明中不可以带有派生列表<br>
习题15.5</p>
<pre><code>class Bulk_quote :public Quote {
public:
	Bulk_quote() = default;
	Bulk_quote(const string&amp; book, double p, size_t qty, double disc) :Quote(book, p), min_qty(qty), discount(disc) {};
	double net_price(size_t)const override;
private:
	size_t min_qty = 0;
	double discount = 0.0;
};

double Bulk_quote::net_price(size_t cnt)const {
	if (cnt &gt;= min_qty)
		return cnt*(1 - discount)*price;
	else
		return cnt*price;
}
</code></pre>
<p>习题15.6</p>
<pre><code>int main()
{
	Quote q(&quot;123&quot;,123);
	Bulk_quote bq(&quot;123&quot;, 123,5,0.5);
	print_total(cout, q, 10);
	print_total(cout, bq, 2);
	print_total(cout, bq, 10);
}
</code></pre>
<p>习题15.7<br>
其实可以直接利用Bulk_quote类，然后就是修改一下net_price函数</p>
<pre><code>double Bulk_quote::net_price(size_t cnt)const {
	if (cnt &lt;= min_qty)
		return cnt*(1 - discount)*price;
	else
		return  min_qty*(1 - discount)*price +(cnt-min_qty)*price;
}
</code></pre>
<p>15.2.3类型转换与继承<br>
我们可以将<strong>基类</strong>的<strong>指针或引用</strong>绑定到<strong>派生类对象</strong>上。<br>
当使用<strong>基类的引用（或指针）<strong>时，实际上我们</strong>并不清楚</strong>该引用（或指针）所绑定对象的<strong>真实类型</strong>。该对象<strong>可能是基类的对象，也可能是派生类的对象</strong>。<br>
和内置指针一样，<strong>智能指针类</strong>（参见12.1节，第400页）也<strong>支持派生类向基类</strong>的类型转换，这意味着我们可以将一个派生类对象的指针存储在一个基类的智能指针内:<br>
表达式的<strong>静态类型</strong>在<strong>编译时总是已知</strong>的，它是变量声明时的类型或表达式生成的类型：动态类型则是变量或表达式表示的内存中的对象的类型。<strong>动态类型直到运行时才可知</strong>。<br>
<strong>如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致</strong>。例如，Quote 类型的变量永远是一个 Quote 对象，我们无论如何都不能改变该变量对应的对象的类型。<br>
基类的<strong>指针和引用的静态类型可能与其动态类型不一致</strong>，读者一定要理解其中的原因<br>
之所以存在派生类向基类的类型转换<strong>是因为每个派生类对象都包含一个基类部分</strong>，而基类的引用或指针可以<strong>绑定到该基类部分上</strong>。<br>
因为一个基类的对象可能是派生类对象的一部分，<strong>也可能不是</strong>，所以<strong>不存在从基类向派生类</strong>的自动类型转换<br>
即使一个基类指针或引用绑定在一个派生类对象上，我们也不能执行从基类向派生类的转换：<br>
派生类向基类的自动类型转换<strong>只对指针或引用类型有效</strong>，在派生类类型和基类类型之间不存在这样的转换。<br>
请注意，当我们<strong>初始化或赋值</strong>一个类类型的对象时，实际上是在<strong>调用某个函数</strong>。当执行初始化时，我们调用构造函数（参见13.1.1节，第440页和13.6.2节，第473页）；而当执行赋值操作时，我们调用赋值运算符（参见13.1.2节，第443页和13.6.2节，第474页）。这些成员通常都包含一个参数，<strong>该参数的类型是类类型的 const 版本的引用（思考为什么是引用）</strong>。<br>
因为这些成员<strong>接受引用作为参数</strong>，所以派生类向基类的转换允许我们<strong>给基类的拷贝移动操作</strong>传递一个<strong>派生类的对象</strong>。这些操作不是虚函数。当我们给基类的构造函数传递一个派生类对象时，<strong>实际运行的构造函数是基类中定义的那个</strong>，显然该构造函数只能处理基类自己的成员。类似的，如果我们将一个<strong>派生类对象</strong>赋值给一个<strong>基类对象</strong>，则实际运行的赋值运算符也是<strong>基类中定义的那个</strong>，该运算符同样只<strong>能处理基类自己的成员<br>
**<br>
因为在上述过程中会</strong>忽略掉 bulk _ quote 部分**，所以我们可以说 bulk 的 Bulk_quot分<strong>被切掉 （sliced down )了</strong>。<br>
当我们用一个派生类对象为一个基类对象初始化或赋值时，<strong>只有该派生类对象的基类部分会被拷贝、移动或赋値，它的派生类部分将被忽略掉</strong><br>
关键概念：存在继承关系的类型之间的转换规则: :<br>
要想理解在具有继承关系的类之间发生的类型转换，有三点非常重要：<br>
•从派生类向基类的类型转换<strong>只对指针或引用类型</strong>有效。<br>
•<strong>基类向派生类不存在</strong>隐式类型转换。<br>
•和任何其他成员一样，派生类向基类的类型转换也<strong>可能会由于访问受限而变得不可行</strong>。我们将在15.5节（第544页）详细介绍可访问性的问题。<br>
尽管自动类型转换只对指针或引用类型有效，但是继承体系中的大多数类仍然（显式或隐式地）定义了拷贝控制成员（参见第13章）。因此，我们<strong>通常能够</strong>将一个<strong>派生类</strong>对象<strong>拷贝、移动或赋值</strong>给一个<strong>基类对象</strong>。不过需要注意的是，这种操作只<strong>处理派生类对象的基类部分</strong>。</p>
<p>习题15.8<br>
表达式的<strong>静态类型</strong>在<strong>编译时总是已知</strong>的，它是变量声明时的类型或表达式生成的类型：动态类型则是变量或表达式表示的内存中的对象的类型。<strong>动态类型直到运行时才可知</strong>。<br>
习题15.9<br>
基类的<strong>指针和引用的静态类型可能与其动态类型不一致</strong><br>
习题15.10<br>
read的形参参数为 istream的引用，所以可以将派生类ifstream的引用作为形参传给read</p>

            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://lixin-ee.github.io//post/shu-226-fan-zhuan-er-cha-shu-jian-dan">
              <h3 class="post-title">
                树 226. 翻转二叉树[简单]
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '253c8689f3b11b51dcf1',
    clientSecret: '64df7c097665e7dd6f416ecfaba36581a91bdb63',
    repo: 'Nixil-ee.github.io',
    owner: 'Lixin-ee',
    admin: ['Lixin-ee'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://lixin-ee.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

      </div>
    </div>
  </body>
</html>
