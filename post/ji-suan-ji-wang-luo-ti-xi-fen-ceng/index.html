<html>
  <head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>计算机网络体系分层层次 | Lixin-SCUT</title>
<link rel="shortcut icon" href="https://lixin-scut.github.io//favicon.ico?v=1589356493121">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://lixin-scut.github.io//styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://lixin-scut.github.io/">
  <img class="avatar" src="https://lixin-scut.github.io//images/avatar.png?v=1589356493121" alt="">
  </a>
  <h1 class="site-title">
    Lixin-SCUT
  </h1>
  <p class="site-description">
    千里之行，始于足下。不积跬步，无以至千里。
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          时间轴
        </a>
      
    
      
        <a href="/tags" class="menu">
          分类/标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>


        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              计算机网络体系分层层次
            </h2>
            <div class="post-info">
              <time class="post-time">
                · 2020-03-26 ·
              </time>
              
                <a href="https://lixin-scut.github.io//tag/3iDvZes6C" class="post-tag">
                  # 计算机网络
                </a>
              
            </div>
            
            <div class="post-content">
              <h3 id="分层概念">分层概念</h3>
<p>  每层通过在该层中执行某些动作或使用直接下层的服务来提供服务，例如由第n层提供的服务可能包括报文从网络的一边到另一边的可靠传送，这可能是通过使用第n-1层的边缘到边缘的不可靠报文传送服务，加上第n层的检测和重传丢失报文的功能来实现的。<br>
  一个协议层能够用软件、硬件或两者的结合来实现。诸如HTTP和SMTP这样的应用层协议几乎总是在端系统中用软件实现的，运输层协议也是如此，因为物理层和数据链路层负责处理跨越特定链路的通信，它们通常是实现在与给定链路相联系的网络接口卡（例如以太网或WiFi接口卡）中，网络层经常是硬件和软件实现的混合体</p>
<h3 id="优缺点">优缺点</h3>
<p><strong>优点：</strong><br>
  协议分层具有概念化和结构化的优点<br>
  采用多层是有益的,通过分层, 每层只负责通信的一个方面。互联网络的目标之一是对应用隐藏所有关于物理布局( 拓扑) 和低层协议的异构性的细 节，分层设计允许开发人员分别实现系统的不同部分, 它们通常由在不同领域的专业人员完成。<br>
  分层体系结构的另一个主要优点是具有协议复用的能力。这种复用形式允许多种协议共存于同一基础设施中。它也允许相同协议对象( 例如连接) 的多个实例同时存在, 并且不会被混淆。</p>
<p><strong>缺点：</strong><br>
  分层的一个潜在缺点是一层可能冗余较低层的功能<br>
  第二种潜在的缺点是某层的功能可能需要仅在其他某层才出现的信息</p>
<p>  因特网的协议栈由5个层次组成：<strong>物理层、链路层、网络层、运输层和应用层</strong><br>
  OSI参考模型的7层是：<strong>应用层、表示层、会话层</strong>，运输层，网络层，数据链路层和物理层<br>
<img src="https://lixin-scut.github.io//post-images/1585214284826.png" alt=""></p>
<p>(1)应用层<br>
  应用层是网络应用程序及它们的应用层协议存留的地方，因特网的用层包括许多协议，例如HTTP，SMTP(它提供了电子邮件报文的传输）和FTP(它提供两个端系统之间的文件传送）。我们将看到某些网络功能，如将像www这样对人友好的端系统名字转换为32比特网络地址<br>
  应用层的信息分组称为<strong>报文（message)</strong><br>
(2)运输层<br>
  因特网的运输层在应用程序端点之间传送应用层报文在因特网中，有两个运输协议.<br>
即TCP和UDP<br>
  TCP向它的应用程序提供了面向连接的服务，包括了应用层报文向目的地的确保传递和流量控制（即发送方/接收方速率匹配），TCP也将长报文划分为短报文.并提供拥塞控制机制，因此当网络拥塞时，源抑制其传输速率.<br>
  UDP协议向它的应用程序提供无连接服务，这是一种不提供不必要服务的服务，没有可靠性.没有流量控制.也没有拥塞控制在本书中.<br>
  我们把运输层分组称为<strong>报文段（segment)。</strong><br>
(3)网络层<br>
  因特网的网络层负责将称为<strong>数据报（datagnim)</strong><br>
  网络层分组从一台主机移动到另一台主机.在一台源主机中的因特网运输层协议（TCP或UDP)向网络层递交运输层报文段和目的地址，就像你通过邮政服务寄信件时提供一个目的地址一样<br>
  因特网的网络层包括著名的IP协议，该协议定义了在数据报中的各个字段以及端系统和路由器如何作用于这些字段<br>
  网络层包括了IP协议和一些路由选择协议，但通常把它简单地称为IP层.这反映IP是将因特网连接在一起的粘合剂这样的事实<br>
(4)链路层<br>
  因特网的网络层通过源和目的地之间的一系列路由器路由数据报，为了将分组从一个结点（主机或路由器）移动到路径上的下一个结点，网络层必须依靠该链路层的服务，特別是在每个结点.网络层将数据报下传给链路层.链路层沿着路径将数据报传递给下一个结点。在下个结点，链路层将数据报上传给网络层，<br>
  我们把链路层分组称为<strong>帧(frame)</strong><br>
(5)物理层<br>
  虽然链路层的任务是将整个帧从一个网络元素移动到邻近的网络元素.而物理层的任务是将该帧中的一个一个比特从一个结点移动到下一个结点，</p>
<h3 id="各层次的作用与包含的协议">各层次的作用与包含的协议：</h3>
<p><img src="https://lixin-scut.github.io//post-images/1586589819616.png" alt=""></p>
<h3 id="物理层">物理层</h3>
<ul>
<li>频分复用（FDM，Frequency Division Multiplexing）：不同用户在不同频带，所用用户在同样时间占用不同带宽资源</li>
<li>时分复用（TDM，Time Division Multiplexing）：不同用户在同一时间段的不同时间片，所有用户在不同时间占用同样的频带宽度</li>
<li>波分复用（WDM，Wavelength Division Multiplexing）：光的频分复用</li>
<li>码分复用（CDM，Code Division Multiplexing）：不同用户使用不同的码，可以在同样时间使用同样频带通信</li>
</ul>
<h3 id="数据链路层">数据链路层</h3>
<ul>
<li>封装成帧：把网络层的 IP 数据报封装成帧，SOH - 数据部分 - EOT</li>
<li>透明传输：不管数据部分什么字符，都能传输出去；可以通过字节填充方法解决（冲突字符前加转义字符）</li>
<li>差错检测：降低误码率（BER，Bit Error Rate），广泛使用循环冗余检测（CRC，Cyclic Redundancy Check）</li>
<li>一个标准的<strong>以太网数据帧大小</strong>是：1518，头信息有14字节，尾部校验和FCS占了4字节，所以真正留给上层协议传输数据的大小就是：1518 - 14 - 4 = 1500，并由此有了MTU和MSS的限制。</li>
</ul>
<p><strong>CSMA/CD 协议</strong><br>
CSMA/CD 表示载波监听多点接入 / 碰撞检测。</p>
<ul>
<li>多点接入 ：说明这是总线型网络，许多主机以多点的方式连接到总线上。</li>
<li>载波监听 ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。</li>
<li>碰撞检测 ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。<br>
  记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 争用期 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</li>
</ul>
<p>  当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 截断二进制指数退避算法 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。</p>
<h3 id="网络层">网络层</h3>
<p><strong>IP数据报</strong></p>
<p><img src="https://lixin-scut.github.io//post-images/1586590589549.png" alt=""></p>
<p>版本 : 有 4（IPv4）和 6（IPv6）两个值；</p>
<p>首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</p>
<p>区分服务 : 用来获得更好的服务，一般情况下不使用。</p>
<p>总长度 : 包括<strong>首部长度</strong>和数据部分长度。</p>
<p>生存时间 ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以<strong>路由器跳数为单位</strong>，当 TTL 为 0 时就丢弃数据报。<br>
<strong>（注意不是时间，而是跳数）</strong></p>
<p>协议 ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</p>
<p>首部检验和 ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和<strong>不包含数据部分</strong>，可以减少计算的工作量。</p>
<p>标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</p>
<p>片偏移 : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</p>
<p><strong>IP地址分类</strong><br>
<img src="https://lixin-scut.github.io//post-images/1586590806330.png" alt=""></p>
<p><strong>ARP协议</strong><br>
ARP详细过程</p>
<ol>
<li>首先，源主机先查找目标主机的IP在ARP缓存中是否存在对于的MAC地址，如果存在，直接将数据包发送至该MAC地址；</li>
<li>否则，向本网段发起一个ARP请求的广播包，其中包含了源IP+源MAC+目标IP，网段内所有主机都会收到这个广播，检查</li>
<li>目标IP与自身IP是否一致，如果一致，将发送端的IP和MAC信息添加到自己的ARP缓存中，然后给源主机回一个ARP响应包，其中包含自己的MAC地址，源主机收到响应后，将目的主机的IP+MAC添加到自己的ARP缓存中</li>
</ol>
<p><strong>路由选择协议</strong><br>
路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。</p>
<p>互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。</p>
<p>可以把路由选择协议划分为两大类：</p>
<p><strong>自治系统内部</strong>的路由选择：RIP 和 OSPF<br>
<strong>自治系统之间</strong>的路由选择：BGP</p>
<ol>
<li>内部网关协议 RIP<br>
  RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。</li>
</ol>
<p>  RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。</p>
<p>距离向量算法：</p>
<p>  对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；<br>
对修改后的 RIP 报文中的每一个项目，进行以下步骤：</p>
<ol>
<li>
<p>若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；</p>
</li>
<li>
<p>否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；</p>
</li>
<li>
<p>否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；</p>
</li>
<li>
<p>否则什么也不做。<br>
  若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。<br>
  RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。</p>
</li>
<li>
<p>内部网关协议 OSPF<br>
开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。</p>
</li>
</ol>
<p>开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。</p>
<p>OSPF 具有以下特点：</p>
<ol>
<li>
<p>向本自治系统中的所有路由器发送信息，这种方法是洪泛法。</p>
</li>
<li>
<p>发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。</p>
</li>
<li>
<p>只有当链路状态发生变化时，路由器才会发送信息。</p>
</li>
<li>
<p>所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。</p>
</li>
<li>
<p>外部网关协议 BGP<br>
BGP（Border Gateway Protocol，边界网关协议）</p>
</li>
</ol>
<p>AS 之间的路由选择很困难，主要是由于：</p>
<ol>
<li>互联网规模很大；</li>
<li>各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；</li>
<li>AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。</li>
<li>BGP 只能寻找一条比较好的路由，而不是最佳路由。</li>
</ol>
<p>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</p>
<h3 id="传输层">传输层</h3>
<p>之前的博文已经详细讨论过传输层最常见的两个协议：<a href="https://lixin-scut.github.io/post/tcp-yu-udp/">TCP 与 UDP</a>，就不重复搬运了</p>
<p>局域网下设备的上网流程</p>
<ol>
<li>DHCP（动态分配一个局域网下的IP地址）</li>
<li>数据从设备到路由器</li>
<li>路由器支持NAT映射（未注册地址和网络地址之间的翻译）</li>
<li>源IP和源端口修改后，将数据发送到目的IP</li>
</ol>
<p>具有NAT功能的路由器维护了一个地址翻译表，NAT寻址算法工作流程：</p>
<ol>
<li>当内部网络上的计算机发送一个TCP或者UDP包给网络外的计算机时，路由器将源IP和端口号保存为地址翻译表中的一个可用项；</li>
<li>路由器用路由器的IP地址替换源IP地址，用虚拟端口号替换源端口号，虚拟端口号指向（1）中的地址翻译表项，然后数据包被转发出去；</li>
<li>路由器从外部计算机接收到一个TCP或UDP包时，使用包中的目的端口号去访问地址翻译表项，最后找到内部的计算机。</li>
</ol>
<h3 id="应用层">应用层</h3>
<p>常用服务的协议与端口<br>
<img src="https://lixin-scut.github.io//post-images/1586592104430.png" alt=""></p>
<p><strong>动态主机配置协议DHCP</strong><br>
DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。</p>
<p>DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。</p>
<p>DHCP 工作过程如下：</p>
<p>  客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。<br>
  DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。<br>
  如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。<br>
  DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。</p>
<p><strong>电子邮件协议</strong><br>
一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。</p>
<p>邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。</p>
<ol>
<li>
<p>SMTP<br>
SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。</p>
</li>
<li>
<p>POP3<br>
POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。但最新版本的 POP3 可以不删除邮件。</p>
</li>
<li>
<p>IMAP<br>
IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。</p>
</li>
</ol>
<p><strong>域名系统 DNS (使用UDP)</strong></p>
<ol>
<li>层次结构<br>
域名服务器可以分为以下四类：<br>
(1) 根域名服务器：解析顶级域名；<br>
(2) 顶级域名服务器：解析二级域名；<br>
(3) 权限域名服务器：解析区内的域名；<br>
区和域的概念不同，可以在一个域中划分多个区。图 b 在域 abc.com 中划分了两个区：abc.com 和 y.abc.com<br>
因此就需要两个权限域名服务器：<br>
(4) 本地域名服务器：也称为默认域名服务器。可以在其中配置高速缓存。</li>
<li>解析过程<br>
  主机向本地域名服务器解析的过程采用递归，而本地域名服务器向其它域名服务器解析可以使用递归和迭代两种方式。<br>
  迭代的方式下，本地域名服务器向一个域名服务器解析请求解析之后，结果返回到本地域名服务器，然后本地域名服务器继续向其它域名服务器请求解析；而递归地方式下，结果不是直接返回的，而是继续向前请求解析，最后的结果才会返回。</li>
</ol>

            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://lixin-scut.github.io//post/dong-tai-gui-hua-494-mu-biao-he-zhong-deng-wei-zuo-chu">
              <h3 class="post-title">
                动态规划 494. 目标和[中等][未做出]
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '253c8689f3b11b51dcf1',
    clientSecret: '64df7c097665e7dd6f416ecfaba36581a91bdb63',
    repo: 'Lixin-SCUT.github.io',
    owner: 'Lixin-SCUT',
    admin: ['Lixin-SCUT'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://lixin-scut.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

      </div>
    </div>
  </body>
</html>
