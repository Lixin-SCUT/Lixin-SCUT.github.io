<html>
  <head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Python - 高级特性 | Lixin-SCUT</title>
<link rel="shortcut icon" href="https://lixin-scut.github.io//favicon.ico?v=1589100687060">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://lixin-scut.github.io//styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://lixin-scut.github.io/">
  <img class="avatar" src="https://lixin-scut.github.io//images/avatar.png?v=1589100687060" alt="">
  </a>
  <h1 class="site-title">
    Lixin-SCUT
  </h1>
  <p class="site-description">
    千里之行，始于足下。不积跬步，无以至千里。
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          时间轴
        </a>
      
    
      
        <a href="/tags" class="menu">
          分类/标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>


        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Python - 高级特性
            </h2>
            <div class="post-info">
              <time class="post-time">
                · 2020-05-08 ·
              </time>
              
                <a href="https://lixin-scut.github.io//tag/qC53A8dj2" class="post-tag">
                  # Python
                </a>
              
                <a href="https://lixin-scut.github.io//tag/FaScKSk5i" class="post-tag">
                  # 读书笔记
                </a>
              
            </div>
            
            <div class="post-content">
              <h2 id="提取容器的部分元素">提取容器的部分元素</h2>
<h3 id="list">list</h3>
<p>取一个list部分元素是非常常见的操作，Python提供了切片（Slice）操作符<br>
取前3个元素，用一行代码就可以完成切片：</p>
<pre><code>&gt;&gt;&gt; L[0:3]
['Michael', 'Sarah', 'Tracy']
</code></pre>
<p>L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。</p>
<p>注意区间是左闭右开，提取的元素数量刚好是右区间减去左区间</p>
<p>如果第一个索引是0，还可以省略：</p>
<pre><code>&gt;&gt;&gt; L[:3]
['Michael', 'Sarah', 'Tracy']
</code></pre>
<p>注意Python支持L[-1]取倒数第一个元素，那么同样支持<strong>倒数切</strong>片，试试：</p>
<pre><code>&gt;&gt;&gt; L[-2:]
['Bob', 'Jack']
&gt;&gt;&gt; L[-2:-1]
['Bob']
</code></pre>
<p><strong>注意倒数第一个元素的索引是-1。</strong></p>
<p>例子：</p>
<p><strong>提取连续元素</strong></p>
<p>前10个数：</p>
<pre><code>&gt;&gt;&gt; L[:10]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>后10个数：</p>
<pre><code>&gt;&gt;&gt; L[-10:]
[90, 91, 92, 93, 94, 95, 96, 97, 98, 99]
</code></pre>
<p>前11-20个数：</p>
<pre><code>&gt;&gt;&gt; L[10:20]
[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
</code></pre>
<p>规律间隔取值</p>
<p>前10个数，每两个取一个：</p>
<pre><code>&gt;&gt;&gt; L[:10:2]
[0, 2, 4, 6, 8]
</code></pre>
<p>所有数，每5个取一个：</p>
<pre><code>&gt;&gt;&gt; L[::5]
[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]
</code></pre>
<p>甚至什么都不写，只写[:]就可以原样复制一个list：</p>
<pre><code>&gt;&gt;&gt; L[:]
[0, 1, 2, 3, ..., 99]
</code></pre>
<h3 id="tuple">tuple</h3>
<p>tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是<strong>操作的结果仍是tuple</strong>：</p>
<pre><code>&gt;&gt;&gt; (0, 1, 2, 3, 4, 5)[:3]
(0, 1, 2)
</code></pre>
<h3 id="字符串">字符串</h3>
<p>字符串'xxx'也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是<strong>操作结果仍是字符串</strong>：</p>
<pre><code>&gt;&gt;&gt; 'ABCDEFG'[:3]
'ABC'
&gt;&gt;&gt; 'ABCDEFG'[::2]
'ACEG'
</code></pre>
<p>在很多编程语言中，针对字符串提供了很多各种截取函数（例如，substring），其实目的就是对字符串切片。Python没有针对字符串的截取函数，只需要切片一个操作就可以完成。</p>
<p><strong>个人练习代码</strong><br>
实现一个trim()函数去除字符串首尾的空格，</p>
<pre><code>def trim(s):
if len(s) == 0:
		return s
left = 0
while left &lt; len(s) and s[left] == ' ':
		left = left + 1
right = len(s) - 1
while right &gt;= 0 and s[right] == ' ':
		right = right - 1
if left &lt; right:
	 return s[left : right+1]
else:
	 return ''
</code></pre>
<h2 id="迭代">迭代</h2>
<p>给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。</p>
<p>在Python中，迭代是通过for ... in来完成的</p>
<p>Python的for循环抽象程度要高于C的for循环，因为Python的for循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上。</p>
<h3 id="无下标迭代-dict迭代">无下标迭代-dict迭代</h3>
<p>list这种数据类型虽然有下标，但很多其他数据类型是没有下标的，但是，只要是可迭代对象，无论有无下标，都可以迭代，比如dict就可以迭代：</p>
<pre><code>&gt;&gt;&gt; d = {'a': 1, 'b': 2, 'c': 3}
&gt;&gt;&gt; for key in d:
...     print(key)
</code></pre>
<p>注意，由于哈希函数的特性，dict的存储不是按照list的方式顺序排列，所以，<strong>迭代出的结果顺序很可能不一样</strong>。</p>
<p>默认情况下，<strong>dict迭代的是key</strong>。如果要<strong>迭代value</strong>，可以用<code>for value in d.values()</code>，如果要<strong>同时迭代key和value</strong>，可以用<code>for k, v in d.items()</code>。</p>
<p>判断一个对象是可迭代对象：通过collections模块的Iterable类型判断：</p>
<pre><code>&gt;&gt;&gt; from collections import Iterable
&gt;&gt;&gt; isinstance('abc', Iterable) # str是否可迭代
True
&gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代
True
&gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代
False
</code></pre>
<h3 id="下标循环">下标循环</h3>
<p>如果要对list实现类似Java那样的下标循环，可以使用Python内置的<strong>enumerate函数</strong>，可以<strong>把一个list变成索引-元素对</strong>，这样就可以在for循环中<strong>同时迭代索引和元素</strong>本身：</p>
<pre><code>&gt;&gt;&gt; for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)
...
0 A
1 B
2 C
</code></pre>
<p>上面的for循环里，同时引用了两个变量，在Python里是很常见的，比如下面的代码：</p>
<pre><code>&gt;&gt;&gt; for x, y in [(1, 1), (2, 4), (3, 9)]:
...     print(x, y)
...
1 1
2 4
3 9
</code></pre>
<p><strong>个人练习代码</strong><br>
使用迭代查找一个list中最小和最大值，并返回一个tuple：</p>
<pre><code>def findMinAndMax(L):
    if len(L) == 0:    
        return (None, None)
    max_num = L[0]
    min_num = L[0]
    for num in L:
        max_num = max(max_num, num)
        min_num = min(min_num, num)
    return (min_num, max_num)
</code></pre>
<h2 id="列表生成式">列表生成式</h2>
<p>列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来<strong>创建list的生成式</strong>。</p>
<p>例如要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))：</p>
<pre><code>&gt;&gt;&gt; list(range(1, 11))
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
</code></pre>
<p>要生成[1x1, 2x2, 3x3, ..., 10x10]<br>
列表生成式则可以用一行语句代替循环生成：</p>
<pre><code>&gt;&gt;&gt; [x * x for x in range(1, 11)]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
</code></pre>
<p>把要生成的元素x * x放到前面，后面跟for循环，就可以把list创建出来</p>
<p>for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：</p>
<pre><code>&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0]
[4, 16, 36, 64, 100]
</code></pre>
<p>还可以使用两层循环，可以生成全排列：</p>
<pre><code>&gt;&gt;&gt; [m + n for m in 'ABC' for n in 'XYZ']
['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']
</code></pre>
<ol>
<li>字符串可以<strong>直接相加</strong></li>
<li>循环<strong>可以并列</strong></li>
</ol>
<p>运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：</p>
<pre><code>&gt;&gt;&gt; import os # 导入os模块，模块的概念后面讲到
&gt;&gt;&gt; [d for d in os.listdir('.')] # os.listdir可以列出文件和目录
['.emacs.d', '.ssh', '.Trash', 'Adlm', 'Applications', 'Desktop', 'Documents', 'Downloads', 'Library', 'Movies', 'Music', 'Pictures', 'Public', 'VirtualBox VMs', 'Workspace', 'XCode']
</code></pre>
<p>for循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value：</p>
<pre><code>&gt;&gt;&gt; d = {'x': 'A', 'y': 'B', 'z': 'C' }
&gt;&gt;&gt; for k, v in d.items():
...     print(k, '=', v)
...
y = B
x = A
z = C
</code></pre>
<p>最后把一个list中所有的字符串变成小写：</p>
<pre><code>&gt;&gt;&gt; L = ['Hello', 'World', 'IBM', 'Apple']
&gt;&gt;&gt; [s.lower() for s in L]
['hello', 'world', 'ibm', 'apple']
</code></pre>
<h3 id="if-else">if ... else</h3>
<p>使用列表生成式的时候，不能在<strong>最后的if</strong>加上else：</p>
<pre><code>&gt;&gt;&gt; [x for x in range(1, 11) if x % 2 == 0]
[2, 4, 6, 8, 10]

&gt;&gt;&gt; [x for x in range(1, 11) if x % 2 == 0 else 0]
  File &quot;&lt;stdin&gt;&quot;, line 1
    [x for x in range(1, 11) if x % 2 == 0 else 0]
                                              ^
SyntaxError: invalid syntax
</code></pre>
<p>这是因为<strong>跟在for后面的if</strong>是一个筛选条件，不能带else，否则无法进行筛选</p>
<p>而把if写在for前面必须加else，否则报错：</p>
<pre><code>&gt;&gt;&gt; [x if x % 2 == 0 for x in range(1, 11)]
  File &quot;&lt;stdin&gt;&quot;, line 1
    [x if x % 2 == 0 for x in range(1, 11)]
                       ^
SyntaxError: invalid syntax
</code></pre>
<p>这是因为for前面的部分是一个表达式，它必须根据x计算出一个结果。因此，考察表达式：x if x % 2 == 0，它无法根据x计算出结果，因为缺少else，必须加上else：</p>
<pre><code>&gt;&gt;&gt; [x if x % 2 == 0 else -x for x in range(1, 11)]
[-1, 2, -3, 4, -5, 6, -7, 8, -9, 10]
上述for前面的表达式x if x % 2 == 0 else -x才能根据x计算出确定的结果。
</code></pre>
<p>可见，在一个列表生成式中，for前面的if ... else是表达式，而for后面的if是过滤条件，不能带else。</p>
<p><strong>个人代码练习</strong><br>
如果list中既包含字符串，又包含整数，由于非字符串类型没有lower()方法，需要使用内建的isinstance函数可以判断一个变量是不是字符串：</p>
<pre><code>L1 = ['Hello', 'World', 18, 'Apple', None]
L2 = [x.lower() for x in L1 if isinstance(x, str)]
</code></pre>
<p>注意没法使用lower(x) ，必须用x.lower()</p>
<h2 id="生成器">生成器</h2>
<p>受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p>
<p>所以，如果<strong>列表元素可以按照某种算法推算出来</strong>，那我们是否可以在循环的过程中<strong>不断推算出后续的元素</strong>呢？这样就<strong>不必创建完整的list</strong>，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。</p>
<h3 id="创建generator">创建generator</h3>
<p>把一个列表生成式的[]改成()，就创建了一个generator：</p>
<pre><code>&gt;&gt;&gt; L = [x * x for x in range(10)]
&gt;&gt;&gt; L
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
&gt;&gt;&gt; g = (x * x for x in range(10))
&gt;&gt;&gt; g
&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;
</code></pre>
<p>创建L和g的区别仅在于最外层的[]和()，L是一个list，而g是一个generator。</p>
<p><strong>打印generator的每一个元素</strong></p>
<p>如果要一个一个打印出来，可以通过next()函数获得generator的下一个返回值：</p>
<pre><code>&gt;&gt;&gt; next(g)
0
&gt;&gt;&gt; next(g)
1
&gt;&gt;&gt; next(g)
4
&gt;&gt;&gt; next(g)
9
&gt;&gt;&gt; next(g)
16
&gt;&gt;&gt; next(g)
25
&gt;&gt;&gt; next(g)
36
&gt;&gt;&gt; next(g)
49
&gt;&gt;&gt; next(g)
64
&gt;&gt;&gt; next(g)
81
&gt;&gt;&gt; next(g)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
StopIteration
</code></pre>
<p>generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值<br>
直到计算到最后一个元素，<strong>没有更多的元素时，抛出StopIteration的错误</strong>。</p>
<p>更便捷的方法是使用for循环，因为generator也是可迭代对象：</p>
<pre><code>&gt;&gt;&gt; g = (x * x for x in range(10))
&gt;&gt;&gt; for n in g:
...     print(n)
... 
0
1
4
9
16
25
36
49
64
81
</code></pre>
<p>由于StopIteration的错误的存在，创建了一个generator后，基本上永远不会调用next()，而是通过for循环来迭代它，不需要关心StopIteration的错误。</p>
<p><strong>定义generator的另一种方法</strong></p>
<p>如果一个<strong>函数定义</strong>中包含<strong>yield关键字</strong>（注意这里涉及协程），那么这个函数就不再是一个普通函数，而是一个generator</p>
<p>例子：斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到：</p>
<pre><code>def fib(max):
    n, a, b = 0, 0, 1
    while n &lt; max:
        yield b
        a, b = b, a + b
        n = n + 1
    return 'done'
		
&gt;&gt;&gt; f = fib(6)
&gt;&gt;&gt; f
&lt;generator object fib at 0x104feaaa0&gt;
</code></pre>
<p>generator和函数的执行流程不一样。</p>
<ol>
<li>函数是顺序执行，遇到return语句或者最后一行函数语句就返回。</li>
<li>而变成generator的函数，在每次<strong>调用next()的时候执行</strong>，<strong>遇到yield语句返回</strong>，再次执行时<strong>从上次返回的yield语句处继续执行</strong>。</li>
</ol>
<p>举个简单的例子，定义一个generator，依次返回数字1，3，5：</p>
<pre><code>def odd():
    print('step 1')
    yield 1
    print('step 2')
    yield(3)
    print('step 3')
    yield(5)
</code></pre>
<p>调用该generator时，首先要生成一个generator对象，然后用next()函数不断获得下一个返回值：</p>
<pre><code>&gt;&gt;&gt; o = odd()
&gt;&gt;&gt; next(o)
step 1
1
&gt;&gt;&gt; next(o)
step 2
3
&gt;&gt;&gt; next(o)
step 3
5
&gt;&gt;&gt; next(o)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
StopIteration

# 在执行过程中，遇到yield就中断，下次又继续执行。执行3次yield后，已经没有yield可以执行了，所以，第4次调用next(o)就报错。
</code></pre>
<p>由于错误的存在，同样地把函数改成generator后，我们基本上从来不会用next()来获取下一个返回值，而是直接使用for循环来迭代：</p>
<pre><code>&gt;&gt;&gt; for n in fib(6):
...     print(n)
</code></pre>
<p>但在循环过程中不断调用yield，可能会导致不断中断。要给循环设置一个条件来退出循环，不然就会产生一个无限数列出来。</p>
<p>但是用for循环调用generator时，<strong>拿不到generator的return语句的返回值</strong>。如果想要拿到返回值，<strong>必须捕获StopIteration错误</strong>，<strong>返回值包含在StopIteration的value中</strong></p>
<pre><code>&gt;&gt;&gt; g = fib(6)
&gt;&gt;&gt; while True:
...     try:
...         x = next(g)
...         print('g:', x)
...     except StopIteration as e:
...         print('Generator return value:', e.value)
...         break
...
g: 1
g: 1
g: 2
g: 3
g: 5
g: 8
Generator return value: done
</code></pre>
<p><strong>个人代码练习</strong><br>
杨辉三角把<br>
每一行看做一个list，试写一个generator，不断输出下一行的list：</p>
<pre><code># -*- coding: utf-8 -*-

def triangles():
    n, list_pre, list_cur  = 0, [1], [1, 1]
    while True:
        if n == 0:
            n = n + 1
            yield list_pre
        if n == 1:
            n = n + 1
            yield list_cur
        list_pre = list_cur
        list_cur = [1, 1]
        for i in range(1, len(list_pre)):
            list_cur.insert(i, list_pre[i] + list_pre[i - 1])
        n = n + 1
        yield list_cur
				
				
# 期待输出:
# [1]
# [1, 1]
# [1, 2, 1]
# [1, 3, 3, 1]
# [1, 4, 6, 4, 1]
# [1, 5, 10, 10, 5, 1]
# [1, 6, 15, 20, 15, 6, 1]
# [1, 7, 21, 35, 35, 21, 7, 1]
# [1, 8, 28, 56, 70, 56, 28, 8, 1]
# [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]
n = 0
results = []
for t in triangles():
    results.append(t)
    n = n + 1
    if n == 10:
        break

for t in results:
    print(t)

if results == [
    [1],
    [1, 1],
    [1, 2, 1],
    [1, 3, 3, 1],
    [1, 4, 6, 4, 1],
    [1, 5, 10, 10, 5, 1],
    [1, 6, 15, 20, 15, 6, 1],
    [1, 7, 21, 35, 35, 21, 7, 1],
    [1, 8, 28, 56, 70, 56, 28, 8, 1],
    [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]
]:
    print('测试通过!')
else:
    print('测试失败!')
</code></pre>
<h2 id="迭代器">迭代器</h2>
<h3 id="可迭代对象iterable">可迭代对象：Iterable</h3>
<p>可以直接作用于for循环的数据类型有以下几种：</p>
<p>一类是<strong>集合数据类型</strong>，如list、tuple、dict、set、str等；</p>
<p>一类是<strong>generator</strong>，包括<strong>生成器</strong>和<strong>带yield的generator function</strong>。</p>
<p>这些可以直接作用于for循环的对象统称为<strong>可迭代对象：Iterable。</strong></p>
<p><strong>可以使用isinstance()判断一个对象是否是Iterable对象：</strong></p>
<pre><code>&gt;&gt;&gt; from collections.abc import Iterable
&gt;&gt;&gt; isinstance([], Iterable)
True
&gt;&gt;&gt; isinstance({}, Iterable)
True
&gt;&gt;&gt; isinstance('abc', Iterable)
True
&gt;&gt;&gt; isinstance((x for x in range(10)), Iterable)
True
&gt;&gt;&gt; isinstance(100, Iterable)
False
</code></pre>
<h3 id="迭代器iterator">迭代器：Iterator</h3>
<p>而生成器不但可以作用于for循环，还<strong>可以被next()函数不断调用并返回下一个值</strong>，直到最<strong>后抛出StopIteration错误</strong>表示无法继续返回下一个值了。</p>
<p>可以被next()函数调用并不断返回下一个值的对象称为<strong>迭代器：Iterator</strong>。</p>
<p>可以使用isinstance()判断一个对象是否是Iterator对象：</p>
<pre><code>&gt;&gt;&gt; from collections.abc import Iterator
&gt;&gt;&gt; isinstance((x for x in range(10)), Iterator)
True
&gt;&gt;&gt; isinstance([], Iterator)
False
&gt;&gt;&gt; isinstance({}, Iterator)
False
&gt;&gt;&gt; isinstance('abc', Iterator)
False
</code></pre>
<p><strong>生成器都是Iterator对象</strong>，但<strong>list、dict、str虽然是Iterable，却不是Iterator。</strong></p>
<p>把list、dict、str等Iterable变成Iterator可以使用<strong>iter()函数</strong>：</p>
<pre><code>&gt;&gt;&gt; isinstance(iter([]), Iterator)
True
&gt;&gt;&gt; isinstance(iter('abc'), Iterator)
True
</code></pre>
<p><strong>为什么list、dict、str等数据类型不是Iterator？</strong></p>
<p>这是因为Python的<strong>Iterator对象表示的是一个数据流</strong>，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却<strong>不能提前知道序列的长度</strong>，只能不断通过next()函数实现按需计算下一个数据，所以<strong>Iterator的计算是惰性的</strong>，只有在需要返回下一个数据时它才会计算。</p>
<p>Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而<strong>使用list是永远不可能存储全体自然数的</strong>。</p>
<h3 id="小结">小结</h3>
<p>凡是可作用于for循环的对象都是<strong>Iterable类型</strong>；</p>
<p>凡是可作用于next()函数的对象都是<strong>Iterator类型</strong>，它们表示一个惰性计算的序列；</p>
<p>集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。</p>
<p>Python的for循环本质上就是通过不断调用next()函数实现的，例如：</p>
<pre><code>for x in [1, 2, 3, 4, 5]:
    pass
</code></pre>
<p>实际上完全等价于：</p>
<pre><code># 首先获得Iterator对象:
it = iter([1, 2, 3, 4, 5])
# 循环:
while True:
    try:
        # 获得下一个值:
        x = next(it)
    except StopIteration:
        # 遇到StopIteration就退出循环
        break
</code></pre>

            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://lixin-scut.github.io//post/python-han-shu">
              <h3 class="post-title">
                Python - 函数
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '253c8689f3b11b51dcf1',
    clientSecret: '64df7c097665e7dd6f416ecfaba36581a91bdb63',
    repo: 'Lixin-SCUT.github.io',
    owner: 'Lixin-SCUT',
    admin: ['Lixin-SCUT'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://lixin-scut.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

      </div>
    </div>
  </body>
</html>
