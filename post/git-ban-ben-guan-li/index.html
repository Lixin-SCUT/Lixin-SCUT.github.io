<html>
  <head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Git - 版本管理 | Lixin-SCUT</title>
<link rel="shortcut icon" href="https://lixin-scut.github.io//favicon.ico?v=1589356493121">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://lixin-scut.github.io//styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://lixin-scut.github.io/">
  <img class="avatar" src="https://lixin-scut.github.io//images/avatar.png?v=1589356493121" alt="">
  </a>
  <h1 class="site-title">
    Lixin-SCUT
  </h1>
  <p class="site-description">
    千里之行，始于足下。不积跬步，无以至千里。
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          时间轴
        </a>
      
    
      
        <a href="/tags" class="menu">
          分类/标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>


        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Git - 版本管理
            </h2>
            <div class="post-info">
              <time class="post-time">
                · 2020-05-11 ·
              </time>
              
                <a href="https://lixin-scut.github.io//tag/FaScKSk5i" class="post-tag">
                  # 读书笔记
                </a>
              
                <a href="https://lixin-scut.github.io//tag/g3aPuoYWw" class="post-tag">
                  # Github
                </a>
              
            </div>
            
            <div class="post-content">
              <h2 id="版本管理">版本管理</h2>
<p>我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件，改成如下内容：</p>
<pre><code>Git is a distributed version control system.
Git is free software.
</code></pre>
<h3 id="git-status">git status</h3>
<p>现在，运行git status命令看看结果：</p>
<pre><code>$ git status
On branch master
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

	modified:   readme.txt

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre>
<p><strong>git status命令</strong>可以让我们<strong>时刻掌握仓库当前的状态</strong></p>
<p>上面的命令输出告诉我们，<strong>readme.txt的字体是红色的！</strong> 被修改过了，但还没有准备提交的修改。</p>
<p>虽然<strong>Git告诉我们readme.txt被修改了，但并不能看看具体修改了什么内容</strong>。<br>
比如你休假回来上班时，已经记不清上次怎么修改的readme.txt，所以，需要用git diff这个命令看看：</p>
<h3 id="git-diff">git diff</h3>
<pre><code>$ git diff readme.txt 
diff --git a/readme.txt b/readme.txt
index 46d49bf..9247db6 100644
--- a/readme.txt
+++ b/readme.txt
@@ -1,2 +1,2 @@
-Git is a version control system.
+Git is a distributed version control system.
 Git is free software.
</code></pre>
<p>git diff顾名思义就是<strong>查看difference</strong>，显示的格式正是<strong>Unix通用的diff格式</strong>，可以从上面的命令输出看到，我们在第一行添加了一个distributed单词。</p>
<h3 id="再次提交">再次提交</h3>
<p>知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是git add</p>
<pre><code>$ git add readme.txt
</code></pre>
<p>同样没有任何输出。在执行第二步git commit之前，我们再运行git status看看当前仓库的状态：</p>
<pre><code>$ git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

	modified:   readme.txt
</code></pre>
<p>git status告诉我们，将要被提交的修改包括readme.txt，<strong>readme.txt的字体变为了绿色的！</strong> ，下一步，就可以放心地提交了：</p>
<pre><code>$ git commit -m &quot;add distributed&quot;
[master e475afc] add distributed
 1 file changed, 1 insertion(+), 1 deletion(-)
</code></pre>
<p>提交后，我们再用git status命令看看仓库的当前状态：</p>
<pre><code>$ git status
On branch master
nothing to commit, working tree clean
</code></pre>
<p>Git告诉我们当前没有需要提交的修改，而且，<strong>工作目录是干净（working tree clean）的</strong>。</p>
<h3 id="小结">小结</h3>
<p>要随时掌握工作区的状态，使用git status命令。</p>
<p>如果git status告诉你有文件被修改过，用git diff可以查看修改内容。</p>
<h2 id="版本回退">版本回退</h2>
<p>现在已经学会了修改文件，然后把修改提交到Git版本库，现在，再一次修改readme.txt文件如下：</p>
<pre><code>Git is a distributed version control system.
Git is free software distributed under the GPL.
</code></pre>
<p>然后尝试提交：</p>
<pre><code>$ git add readme.txt
$ git commit -m &quot;append GPL&quot;
[master 1094adb] append GPL
 1 file changed, 1 insertion(+), 1 deletion(-)
</code></pre>
<p>像这样，可以不断对文件进行修改，然后不断提交修改到版本库里。<br>
每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，<strong>这个快照在Git中被称为commit</strong>。<br>
一旦你把文件改乱了，或者误删了文件，还可以<strong>从最近的一个commit恢复</strong>，然后继续工作，而不是把几个月的工作成果全部丢失。</p>
<h3 id="git-log">git log</h3>
<p>现在，我们回顾一下readme.txt文件一共有几个版本被提交到Git仓库里了：</p>
<p>版本1：wrote a readme file</p>
<pre><code>Git is a version control system.
Git is free software.
</code></pre>
<p>版本2：add distributed</p>
<pre><code>Git is a distributed version control system.
Git is free software.
</code></pre>
<p>版本3：append GPL</p>
<pre><code>Git is a distributed version control system.
Git is free software distributed under the GPL.
</code></pre>
<p>当然了，在实际工作中版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看：</p>
<pre><code>$ git log
commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Fri May 18 21:06:15 2018 +0800

    append GPL

commit e475afc93c209a690c39c13a46716e8fa000c366
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Fri May 18 21:03:36 2018 +0800

    add distributed

commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Fri May 18 20:59:18 2018 +0800

    wrote a readme file
</code></pre>
<p>git log命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是append GPL，上一次是add distributed，最早的一次是wrote a readme file。</p>
<p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数：</p>
<pre><code>$ git log --pretty=oneline
1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPL
e475afc93c209a690c39c13a46716e8fa000c366 add distributed
eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file
</code></pre>
<p>提示：看到的一大串类似1094adb...的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p>
<p>每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线</p>
<h3 id="git-reset">git reset</h3>
<h4 id="回退到上一个版本">回退到上一个版本</h4>
<p>现在准备把readme.txt回退到上一个版本，也就是add distributed的那个版本</p>
<p>首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交，<strong>上一个版本就是HEAD<sup>**，**上上一个版本就是HEAD</sup><sup>**，当然往上100个版本写100个</sup>比较容易数不过来，所以写成</strong>HEAD~100**。</p>
<p>要把当前版本append GPL回退到上一个版本add distributed，就可以使用git reset命令：</p>
<pre><code>$ git reset --hard HEAD^
HEAD is now at e475afc add distributed
</code></pre>
<p>还可以继续回退到上一个版本wrote a readme file，<br>
不过我们先用git log再看看现在版本库的状态：</p>
<pre><code>$ git log
commit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -&gt; master)
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Fri May 18 21:03:36 2018 +0800

    add distributed

commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Fri May 18 20:59:18 2018 +0800

    wrote a readme file
</code></pre>
<p>最新的那个版本append GPL已经看不到了</p>
<h4 id="回退到后一个版本">回退到后一个版本</h4>
<p>如果git reset是误操作，如何向后复原呢？</p>
<p>只要上面的命令行窗口还没有被关掉，可以找到那个append GPL的commit id1094adb...，于是就可以根据commit id来指定回到未来的某个版本：</p>
<pre><code>$ git reset --hard 1094a
HEAD is now at 83b0afe append GPL
</code></pre>
<p><strong>版本号没必要写全，前几位就可以了，Git会自动去找</strong>。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p>
<p>再查看readme.txt的内容：</p>
<pre><code>$ cat readme.txt
Git is a distributed version control system.
Git is free software distributed under the GPL.
</code></pre>
<p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你<strong>回退版本的时候，Git仅仅是把HEAD从指向append GPL</strong>：</p>
<pre><code>
┌────┐
│HEAD│
└────┘
   │
   └──&gt; ○ append GPL
        │
        ○ add distributed
        │
        ○ wrote a readme file
</code></pre>
<p>改为指向add distributed：</p>
<pre><code>
┌────┐
│HEAD│
└────┘
   │
   │    ○ append GPL
   │    │
   └──&gt; ○ add distributed
        │
        ○ wrote a readme file
</code></pre>
<p>然后顺便把<strong>工作区</strong>的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。</p>
<h3 id="git-reflog-命令记录">git reflog-命令记录</h3>
<p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？</p>
<p>在Git中，总是有后悔药可以吃的。当你用$ git reset --hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令：</p>
<pre><code>$ git reflog
e475afc HEAD@{1}: reset: moving to HEAD^
1094adb (HEAD -&gt; master) HEAD@{2}: commit: append GPL
e475afc HEAD@{3}: commit: add distributed
eaadf4e HEAD@{4}: commit (initial): wrote a readme file
</code></pre>
<p>从输出可知，append GPL的commit id是1094adb。</p>
<h3 id="小结-2">小结</h3>
<p>现在总结一下：</p>
<ol>
<li>
<p>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。</p>
</li>
<li>
<p>穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。</p>
</li>
<li>
<p>要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</p>
</li>
</ol>
<h2 id="工作区和暂存区">工作区和暂存区</h2>
<p>Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。</p>
<p><strong>工作区（Working Directory）</strong>：就是你在电脑里能看到的目录，比如git init的文件夹就是一个工作区：</p>
<p><strong>版本库（Repository）</strong></p>
<p>工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。</p>
<p>Git的版本库里存了很多东西</p>
<ol>
<li>其中最重要的就是称为<strong>stage（或者叫index）的暂存区</strong></li>
<li>还有Git为我们<strong>自动创建的第一个分支master</strong></li>
<li>以及<strong>指向master的一个指针叫HEAD</strong>。<br>
<img src="https://lixin-scut.github.io//post-images/1589181011272.png" alt=""></li>
</ol>
<p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p>
<p>第一步是用<strong>git add</strong>把文件添加进去，实际上就是把<strong>文件修改添加到暂存区</strong>；</p>
<p>第二步是用<strong>git commit</strong>提交更改，实际上就是把<strong>暂存区的所有内容提交到当前分支</strong>。</p>
<p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。</p>
<p>你可以简单理解为，需<strong>要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改</strong>。</p>
<p>俗话说，实践出真知。现在，我们再练习一遍，先对readme.txt做个修改，比如加上一行内容：</p>
<pre><code>Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
</code></pre>
<p>然后，在工作区新增一个LICENSE文本文件（内容随便写）。</p>
<p>先用git status查看一下状态：</p>
<pre><code>$ git status
On branch master
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

	modified:   readme.txt

Untracked files:
  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)

	LICENSE

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre>
<p>Git非常清楚地告诉我们，readme.txt被修改了，而LICENSE还从来没有被添加过，所以它的状态是Untracked，<strong>两者都是红色字体</strong>。</p>
<p>现在，使用两次命令git add，把readme.txt和LICENSE都添加后，用git status再查看一下：</p>
<pre><code>$ git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

	new file:   LICENSE
	modified:   readme.txt
</code></pre>
<p>可以看到两者被成功添加，两者都变为绿色字体<br>
现在，暂存区的状态就变成这样了：<br>
<img src="https://lixin-scut.github.io//post-images/1589181355793.png" alt=""></p>
<p>所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。</p>
<pre><code>$ git commit -m &quot;understand how stage works&quot;
[master e43a48b] understand how stage works
 2 files changed, 2 insertions(+)
 create mode 100644 LICENSE
</code></pre>
<p>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：</p>
<pre><code>$ git status
On branch master
nothing to commit, working tree clean
</code></pre>
<p><img src="https://lixin-scut.github.io//post-images/1589181551641.png" alt=""></p>
<h2 id="管理修改">管理修改</h2>
<p><strong>Git跟踪并管理的是修改，而非文件。</strong></p>
<p>什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。</p>
<p>为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容：</p>
<pre><code>$ cat readme.txt
Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes.
</code></pre>
<p>然后，添加：</p>
<pre><code>$ git add readme.txt
$ git status
# On branch master
# Changes to be committed:
#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
#
#       modified:   readme.txt
#
</code></pre>
<p>然后，再修改readme.txt：</p>
<pre><code>$ cat readme.txt 
Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
</code></pre>
<p>提交：</p>
<pre><code>$ git commit -m &quot;git tracks changes&quot;
[master 519219b] git tracks changes
 1 file changed, 1 insertion(+)
</code></pre>
<p>提交后，再看看状态：</p>
<pre><code>$ git status
On branch master
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

	modified:   readme.txt

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre>
<p>可以看到，<strong>第二次的修改并没有被提交！</strong></p>
<p>回顾一下操作过程：</p>
<p>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit</p>
<p>前面讲了Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的<strong>第二次修改并没有放入暂存区</strong>，所以，git commit<strong>只负责把暂存区的修改提交了</strong>，也就是<strong>第一次的修改被提交了，第二次的修改不会被提交</strong>。</p>
<p>提交后，用<code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别：</p>
<pre><code>$ git diff HEAD -- readme.txt 
diff --git a/readme.txt b/readme.txt
index 76d770f..a9c5755 100644
--- a/readme.txt
+++ b/readme.txt
@@ -1,4 +1,4 @@
 Git is a distributed version control system.
 Git is free software distributed under the GPL.
 Git has a mutable index called stage.
-Git tracks changes.
+Git tracks changes of files.
</code></pre>
<p>可见，第二次修改确实没有被提交。</p>
<p>那怎么提交第二次修改呢？可以继续git add再git commit，也<strong>可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了</strong>：</p>
<p>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit</p>
<h2 id="撤销修改">撤销修改</h2>
<h3 id="撤销git-add-之前的修改">撤销git add 之前的修改</h3>
<p>如果错误发现得很及时，可以在<strong>提交(git add)</strong> 之前修正，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用git status查看一下：</p>
<pre><code>$ git status
On branch master
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

	modified:   readme.txt

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre>
<p>同时也可以<strong>使用git checkout -- file丢弃工作区的修改</strong>：</p>
<pre><code>$ git checkout -- readme.txt
</code></pre>
<p>命令git checkout -- readme.txt意思就是，把readme.txt文件在<strong>工作区的修改全部撤销</strong>，这里有两种情况：</p>
<ol>
<li>
<p>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
</li>
<li>
<p>一种是readme.txt已经添加到暂存区后，又作了修改，现在，<strong>撤销修改就回到添加到暂存区后的状态</strong>。</p>
</li>
</ol>
<p>总之，就是让这个文件回到<strong>最近一次git commit或git add</strong>时的状态。</p>
<p><strong>git checkout -- file命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令</strong>，我们在后面的分支管理中会再次遇到git checkout命令。</p>
<h3 id="撤销git-add-之后的修改">撤销git add 之后的修改</h3>
<p>如果git add到暂存区了，在commit之前，你发现了这个问题。用git status查看一下，修改只是添加到了暂存区，还没有提交：</p>
<p>Git同样告诉我们，用命令<code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），<strong>重新放回工作区</strong>：</p>
<pre><code>$ git reset HEAD readme.txt
Unstaged changes after reset:
M	readme.txt
</code></pre>
<p><strong>注意！！此时修改还在！！！只是回到了工作区的修改！！！并不是说回到上一次最近一次git commit或git add时的状态，如果想要彻底回到修改前的状态，还需要调用git checkout</strong></p>
<p>git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们<strong>用HEAD时，表示最新的版本</strong>。</p>
<p>再用git status查看一下，<strong>现在暂存区是干净的，工作区有修改</strong>：</p>
<pre><code>$ git status
On branch master
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

	modified:   readme.txt
</code></pre>
<p>进一步丢弃工作区的修改：git checkout</p>
<pre><code>$ git checkout -- readme.txt

$ git status
On branch master
nothing to commit, working tree clean
</code></pre>
<h3 id="小结-3">小结</h3>
<p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p>
<p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了<strong>暂存区</strong>时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p>
<p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p>
<p>现在，假设不但改错了东西，还从暂存区提交到了版本库，此时就必须使用版本回退回退到上一个版本。不过，这是有条件的，就是还没有把自己的本地版本库推送到远程。因为Git是分布式版本控制系统，具有相关的远程版本库</p>
<h2 id="删除文件">删除文件</h2>
<p>在Git中，删除也是一个修改操作，先添加一个新文件test.txt到Git并且提交：</p>
<pre><code>$ git add test.txt

$ git commit -m &quot;add test.txt&quot;
[master b84166e] add test.txt
 1 file changed, 1 insertion(+)
 create mode 100644 test.txt
</code></pre>
<p>一般情况下，可以直接在文件管理器中把没用的文件删了，或者用rm命令删了：</p>
<pre><code>$ rm test.txt
</code></pre>
<p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了：</p>
<pre><code>$ git status
On branch master
Changes not staged for commit:
  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

	deleted:    test.txt

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre>
<p>现在你有两个选择，一是确实要从版本库中删除该文件，那就<strong>用命令git rm删掉</strong>，并且<strong>git commit</strong>：</p>
<pre><code>$ git rm test.txt
rm 'test.txt'

$ git commit -m &quot;remove test.txt&quot;
[master d46f35e] remove test.txt
 1 file changed, 1 deletion(-)
 delete mode 100644 test.txt
</code></pre>
<p>现在，文件就从版本库中被删除了。</p>
<p>小提示：先手动删除文件，然后使用<code>git rm &lt;file&gt;</code>和<code>git add&lt;file&gt;</code>效果是一样的。</p>
<h3 id="恢复删除文件">恢复删除文件</h3>
<p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p>
<p>注意此处是只是add，而没有commit！</p>
<pre><code>$ git checkout -- test.txt
</code></pre>
<p>git checkout其实是<strong>用版本库里的版本替换工作区的版本</strong>，无论工作区是修改还是删除，都可以“一键还原”。</p>
<p>注意：<strong>从来没有被添加到版本库就被删除的文件，是无法恢复的</strong>！</p>
<h3 id="小结-4">小结</h3>
<p>命令git rm用于删除一个文件。<strong>如果一个文件已经被提交到版本库，那么你永远不用担心误删</strong>，但是要小心，你只能恢复文件到最新版本，你<strong>会丢失最近一次提交后你修改的内容</strong>。</p>

            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://lixin-scut.github.io//post/git-jian-jie">
              <h3 class="post-title">
                Git - 简介
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '253c8689f3b11b51dcf1',
    clientSecret: '64df7c097665e7dd6f416ecfaba36581a91bdb63',
    repo: 'Lixin-SCUT.github.io',
    owner: 'Lixin-SCUT',
    admin: ['Lixin-SCUT'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://lixin-scut.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

      </div>
    </div>
  </body>
</html>
