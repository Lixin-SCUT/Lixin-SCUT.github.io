<html>
  <head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title> C++ primer 第十八章 笔记+习题 19.3-19.4 | Lixin-ee</title>
<link rel="shortcut icon" href="https://lixin-ee.github.io//favicon.ico?v=1575076705200">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://lixin-ee.github.io//styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://lixin-ee.github.io/">
  <img class="avatar" src="https://lixin-ee.github.io//images/avatar.png?v=1575076705200" alt="">
  </a>
  <h1 class="site-title">
    Lixin-ee
  </h1>
  <p class="site-description">
    好景在望。
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          时间轴
        </a>
      
    
      
        <a href="/tags" class="menu">
          分类/标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>


        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
               C++ primer 第十八章 笔记+习题 19.3-19.4
            </h2>
            <div class="post-info">
              <time class="post-time">
                · 2019-11-29 ·
              </time>
              
                <a href="https://lixin-ee.github.io//tag/Esg34ccex" class="post-tag">
                  # C++ Primer
                </a>
              
            </div>
            
            <div class="post-content">
              <p>19.3 枚举类型<br>
<strong>枚举类型</strong>（enumeration)使我们可以将一组<strong>整型常量</strong>组织在一起。和类一样，每个枚 举类型定义了一种新的类型。<strong>枚举属于字面值常量类型</strong>（参见7.5.6节，第267页）<br>
定义<strong>限定作用域</strong>的枚举类型的一般形式是：首先是<strong>关键字enum class</strong>(或者等价地使用<strong>enum struct</strong>),随后是<strong>枚举类型名字</strong>以及用<strong>花括号括起来</strong>的以<strong>逗号分隔</strong>的<strong>枚举成员</strong>（enumerator)列表，最后是一个<strong>分号</strong>：<br>
enum class open_modes{input,output,append};<br>
定义<strong>不限定作用域</strong>的枚举类型（unscoped enumeration)时<strong>省略掉关键字class</strong>(或struct)，枚举类型的<strong>名字是可选的</strong>：</p>
<p>枚举成员<br>
在<strong>限定作用域</strong>的枚举类型中，枚举成员的名字<strong>遵循常规的作用域准则</strong>，并且在枚举类型的<strong>作用域外是不可访问</strong>的。与之相反，在<strong>不限定作用域</strong>的枚举类型中，<strong>枚举成员的作用域</strong>与<strong>枚举类型本身的作用域相同</strong>：<strong>相当于类的成员</strong></p>
<p>有效的作用域：需要加peppers::</p>
<p><strong>默认情况</strong>下，<strong>枚举值从0开始</strong>，<strong>依次加1</strong>。不过我们也能为一个或几个枚举成员指定专门的值：<br>
<strong>枚举值不一定唯一</strong>。<br>
<strong>如果我们没有显式提供初始值，那么当前枚举对象的值等于之前枚举对象的值+1</strong><br>
<strong>枚举成员是const</strong>,因此在<strong>初始化</strong>枚举成员时<strong>提供的初始值</strong>必须是<strong>常量表达式</strong>（参见 2.4.4节，第58页）。也就是说，<strong>每个枚举成员本身就是一条常量表达式</strong>，我们可以<strong>在任何 需要常量表达式</strong>的地方使用<strong>枚举成员</strong>。例如，我们<strong>可以定义枚举类型的constexpr变量</strong>;<br>
constexprintTypescharbits=intTypes:;charTyp;<br>
类似的，我们也可以将一个enum作为switch语句的表达式，而将<strong>枚举值作为case标 签</strong>（参见5.3.2节，第160页）。出于同样的原因，我们还能将枚举类型作为一个非类型模 板形参使用（参见16.1.1节.第580页）；或者在类的定义中初始化枚举类型的静态数据成员（参见7.6节，第270页）。switch(color){case red: case green:}</p>
<p><strong>和类一样，枚举也定义新的类型</strong>只要enum有名字，我们就能定义并初始化该类型的成员。要想<strong>初始化</strong>enum对象或者为enum对象<strong>赋值 (区分enum对象和enum成员)</strong>，必须<strong>使用该类型的一个枚举成员</strong>或者<strong>该类型的另一个对象</strong>：<br>
一个<strong>不限定作用域</strong>的枚举类型的对象或枚举成员<strong>自动地转换成整型</strong>。因此，我们可以在任何需要整型值的地方使用它们. <strong>限定作用域的enum无法进行隐式转换</strong></p>
<p>指定enum的大小<br>
尽管每个enum都定义了唯一的类型，但实际上enum是由某种整数类型表示的。在 C++11新标准中，我们可以在<strong>enum的名字后加上冒号</strong>以及我们<strong>想在该enum中使用的类型</strong>：<br>
如果我们没有指定enum的潜在类型，则默认情况下限定作用域的enum成员类型是int。对于不限定作用域的枚举类型来说，其枚举成员不存在默认类型，我们只知道成员的潜在类型足够大，肯定能够容纳枚举值。<strong>如果我们指定了</strong>枚举成员的<strong>潜在类型</strong>（包括对限定作 用域的enum的隐式指定），则<strong>一旦</strong>某个枚举成员的值<strong>超出了该类型所能容纳的范围，将引发程序错误。</strong><br>
<strong>指定enum潜在类型</strong>的能力使得我们可以<strong>控制不同实现环境中使用的类型</strong>.我们将可以确保在一种实现环境中编译通过的程序所生成的代码与其他实现环境中生成的代码一致。</p>
<p>枚举类型的前置声明<br>
在C++11新标准中，我们可以<strong>提前声明enum</strong>。enum的前置声明（无论隐式地还是显式地）<strong>必须指定其成员的大小</strong>：<br>
//不限定指用域的枚举类型intValues的前置声明<br>
enum intValues : unsigned long long;	//<strong>不限定作用域的，必须指定成员类型</strong><br>
enum class open_inodes;	//<strong>限定作用域</strong>的枚举类型可以<strong>使用默认成员类型int</strong><br>
因为<strong>不限定作用域</strong>的enum<strong>未指定成员的默认大小</strong>，因此<strong>每个声明必须指定成员的大小</strong>。对于<strong>限定作用域的enum</strong>来说，我们可以<strong>不指定其成员的大小</strong>，这个值被<strong>隐式地定义</strong>为int。<br>
和其他声明语句一样，<strong>enum的声明和定义必须匹配</strong>，这意味着在该enum的所有声明和定义中成员的<strong>大小必须一致</strong>。而且，我们不能在问一个上下文中先声明一个不限定作用域的enum名字，然后再声明一个同名的限定作用域的enum;<strong>（作用域也必须一致）</strong></p>
<p>形参匹配与枚举类型<br>
要想<strong>初始化一个enum对象</strong>，<strong>必须使用该enum类型的另一个对象或者它的一个枚举成员</strong>（参化19.3节，第737页）。因此，即使某个整型值恰好与枚举成员的值相等，它也不能作为函数的enum实参使用：<br>
尽管我们<strong>不能直接将整型值传给enum形参</strong>，但是<strong>可将一个不限定作用域的枚举类型的对象或枚举成员传给整型形参</strong>。此时，enum的值<strong>提升成int或更大的整型</strong>，实际提升的结果由枚举类型的潜在类型决定：<br>
枚举成员<strong>永远不会提升成unsigned char</strong>,即使枚举值可以用unsigned char存储也是如此。</p>
<p>19.4 类成员指针<br>
<strong>成员指针(pointer to member)</strong> 是指可以<strong>指向类的非静态成员</strong>的指针<br>
<strong>一般情况</strong>下，指针<strong>指向一个对象</strong>，但是<strong>成员指针</strong>指示的是<strong>类的成员</strong>，<strong>而非类的对象</strong>。<strong>类的静态成员不属于任何对象</strong>，因此无须特殊的指向静态成员的指针，<strong>指向静态成员的指针与普通指针没有什么区别</strong>。<br>
<strong>成员指针的类型</strong>囊括了<strong>类的类型以及成员的类型</strong>。当<strong>初始化</strong>一个这样的指针时，我们令其<strong>指向类的某个成员</strong>，<strong>但是不指定该成员所属的对象</strong>：<strong>直到使用</strong>成员指针时，<strong>才提供</strong>成员<strong>所属的对象</strong>。</p>
<p>19.4.1 数据成员指针<br>
和其他指针一样，在声明成员指针时我们也使用*来表示当前声明的名字是一个指针。 与普通指针不同的是，<strong>成员指针还必须包含成员所属的类</strong>。因此，我们必须<strong>在*之前添加 classname::</strong> 表示当前定义的指针可以指向classname的成员。例如：<br>
//pdata可以指向一个常量（非常量）Screen对象的string成员<br>
const string <strong>Screen::*pdata</strong>;</p>
<p>当我们初始化一个成员指针（或者向它赋值）时，需<strong>指定它所指的成员</strong>（<strong>但不需要指定对象</strong>）。例如，我们可令pdata指向某个非特定Screen对象的contents成员：<br>
pdata = &amp;Screen::contents;<br>
其中，我们将取地址运算符作用于<strong>Screen类的成员</strong>而<strong>非内存中的一个该类对象</strong>。<br>
当然，在C++11新标准中声明成员指针<strong>最简单的方法是使用auto或decltype</strong>：<br>
auto pdata = &amp;Screen::contents;</p>
<p>使用数据成员指针<br>
当我们<strong>初始化</strong>一个成员指针或为成员指针<strong>赋值</strong>时，该指针<strong>并没有指向任何数据</strong>。成员指针<strong>指定了成员</strong>而<strong>非该成员所属的对象</strong>，只有<strong>当解引用成员指针时我们才提供对象的信息</strong>。<br>
与成员访问运算符.和-&gt;类似，也有两种成员指针访问运算符：<strong>.*和-&gt;*（注意是带*号的）</strong>，这两个运算符使得我们可以解引用指针并获得该对象的成员：</p>
<pre><code>Screen myScreen,*pScreen=&amp;myScreen; 
//.*解引用pdata以获得myScreen对象的contents成员 
auto s = myScreen.*pdata; 
//-&gt;*解引用pdata以获得pScreen所指对象的contents成员 
s = pScreen**—&gt;*pdata**; 
</code></pre>
<p>从概念上来说，这些运算符<strong>执行两步操作</strong>：它们<strong>首先解引用</strong>成员指针以得到所需的成员. <strong>然后像成员访问运算符</strong>一样，通过对象(.*)或指针(-&gt;*)获取成员。</p>
<p>返回数据成员指针的函数<br>
<strong>常规的访问控制规则对成员指针同样有效</strong>。例如，Screen的contents成员是私有的，因此之前对于pdata的使用必须位于Screen类的成员或友元内部，否则程序将发生错误。<br>
因为<strong>数据成员</strong>一般情况下是<strong>私有的</strong>，所以我们通常<strong>不能直接获得</strong>数据成员的<strong>指针</strong>。如 一个像Screen这样的类希望我们可以访问它的contents成员，<strong>最好定义一个函数</strong>，<strong>令其返回值是指向该成员的指针</strong>：</p>
<p>一如往常，<strong>pdata指向Screen类的成员而非实际数据</strong>。<strong>要想使用pdata,必须把它绑定到Screen类型的对象上</strong>：<br>
//获得myScreen对象的contents成员<br>
<code>auto S = myScreen.*pdata;</code><br>
<strong>（直接解引用就会绑定到特定的对象上）</strong></p>
<p>习题19.11<br>
普通的数据指针一定是指向一个对象的，但是指向数据成员的指针只会指向一个成员类型而非实际数据，需要绑定到特定类型的对象上才能调用。<br>
知识点8：成员指针是指可以指向类的非静态成员的指针，由于类的静态成员不属于任何对象，所以无需特殊的指向该成员的指针，成员指针的类型需要包括类的类型和成员的类型<br>
知识点9：在给成员指针赋值时，我们将取址运算符作用域screen的成员而不是内存中的一个类的对象的成员<br>
知识点10：我们需要注意，当我们初始化一个成员指针或为成员指针赋值时，该指针并没有指向任何数据，成员指针只指定了成员而非该成员所属的对象，只有解引用成员指针时我们才提供对象的信息<br>
知识点11：成员指针的访问运算符：.*或者-&gt;*，可以获得对象的指定成员<br>
习题19.12</p>
<pre><code>const string::size_type Screen::* p;

static cosnt pos Screen::*data() { 
        return &amp;Screen::cursor;  
    }
</code></pre>
<p>习题19.13<br>
<code>const string Sales_data::*</code></p>
<p>19.4.2 成员函数指针<br>
我们也可以<strong>定义指向类的成员函数的指针</strong>。与指向数据成员的指针类似，对于我们来<br>
说要想创建一个指向成员函数的指针，最简单的方法是使用auto来推断类型</p>
<p>和指向数据成员的指针一样，我们使用<strong>classname::*</strong> 的形式<strong>声明</strong>一个指向成员函数的指针。类似于任何其他函数指针（参见6.7节，第221页），<strong>指向成员函数的指针</strong>也需要<strong>指定目标函数</strong>的<strong>返回类型</strong>和<strong>形参列表</strong>。如果成员函数是const成员（参见7.1.2节，第231页）或者引用成员（参见13.6.3节，第483页)，则我们必须将const限定符或引用限定符包含进来。<br>
和普通的函数指针类似，如果成员存在<strong>重载的问题</strong>，则我们<strong>必须显式地声明函数类型</strong>以<strong>明确指出我们想要使用的是哪个函数</strong><br>
<strong>char (Screen::*pmf2)(Screen::pos,Screen::pos)const;</strong><br>
pmf2 = &amp;Screen::get;<br>
出于优先级的考虑，上述声明中<strong>screen::*两端的括号必不可少</strong>。如果没有这对括号的话，编译器将<strong>认为该声明是一个（无效的）函数声明</strong>：<br>
和<strong>普通函数指针</strong>不同的是，在<strong>成员函数</strong>和<strong>指向该成员的指针</strong>之间<strong>不存在自动转换规则</strong>：</p>
<p>使用成员函数指针<br>
和使用指向数据成员的指针一样，我们使用 <strong>.*或者-&gt;*运算符</strong>作用于指向成员函数的指针，以调用类的成员函数：</p>
<p>使用成员指针的类型别名<br>
使用<strong>类型别名或typedef</strong>(参见2.5.1节，第60页）可以让成员指针<strong>更容易理解</strong>。<br>
和其他函数指针类似，我们可将<strong>指向成员函数的指针</strong>作为<strong>某个函数</strong>的<strong>返回类型</strong>或<strong>形参类型</strong>。其中，指向成员的<strong>指针形参也可以拥有默认实参</strong>：<br>
<strong>using Action = char(Screen::*)(Screen::pos) const;</strong><br>
通过使用类型别名，可以令含有成员指针的代码更易读写。</p>
<p>对于普通函数指针和指向成员函数的指针来说，一种常见的用法是<strong>将其存入一个函数 表当中</strong>（参见14.8.3节，第511页）。如果一个类含有几个相同类型的成员，则这样一张 表可以帮助我们从这些成员中选择一个。<br>
<strong>函数表：存储指向可调用对象的“指针”，一般通过map实现</strong></p>
<p>习题19.14<br>
如果两者函数类型一致就合法，不一致就不合法<br>
习题19.15<br>
<strong>在成员函数和指向该成员的指针之间不存在自动转换的规则（必须使用&amp;符号，显示的取地址）</strong><br>
知识点8：成员指针是指可以指向类的非静态成员的指针，由于类的静态成员不属于任何对象，所以无需特殊的指向该成员的指针，成员指针的类型需要包括类的类型和成员的类型<br>
知识点9：在给成员指针赋值时，我们将取址运算符作用域screen的成员而不是内存中的一个类的对象的成员<br>
知识点10：我们需要注意，当我们初始化一个成员指针或为成员指针赋值时，该指针并没有指向任何数据，成员指针只指定了成员而非该成员所属的对象，只有解引用成员指针时我们才提供对象的信息<br>
知识点11：成员指针的访问运算符：.*或者-&gt;*，可以获得对象的指定成员<br>
习题19.16<br>
<code>typedef avg double （Sales_data::*）()const;</code><br>
习题19.17</p>
<pre><code>char get() const { return contents[cursor]; }//using Action_c_v = char (Screen::*)()const;  
char get_cursor() const { return contents[cursor]; }//同上  
inline char get(pos ht, pos wd) const;//using Action_c_uu = char (Screen::*)(pos,pos)const;  
Screen &amp;move(pos r, pos c);//using Action_Screen_uu = Screen &amp;(Screen::*)(pos,pos); 
</code></pre>
<p>19.4.3 将成员函数用作可调用对象<br>
如我们所知，要想通过一个指向成员函数的指针进行函数调用，<strong>必须</strong>首先<strong>利用.*运算符或-&gt;*运算符</strong>将该指针<strong>绑定到特定的对象上</strong>。因此<strong>与普通的函数指针不同</strong>，<strong>成员指针不是一个可调用对象</strong>，这样的指针<strong>不支持函数调用运算符</strong>（参见10.3.2节，第346页）。<br>
因为成员指针不是可调用对象，所以我们<strong>不能直接将一个指向成员函数的指针传递给算法。</strong></p>
<p>使用function生成一个可调用对象<br>
<strong>从指向成员函数的指针获取可调用对象</strong>的一种方法是<strong>使用标准库模板function</strong><br>
当一个function对象包含有一个指向成员函数的指针时，<strong>function类知道它必须使用正确的指向成员的指针运算符来执行函数调用</strong>。也就是说我们可以认为在find_if当中含有类似于如下形式的代码：</p>
<p>当我们<strong>定义一个function对象</strong>时，必须指定该对象所能表示的函数类型，即可调用对象的形式。如果可调用对象是一个成员函数，则<strong>第一个形参</strong>必须<strong>表示该成员是在哪个(一般是隐式的）对象上执行</strong>的。同时我们提供给function的形式中还<strong>必须指明对象是否以指针或引用的形式传入的</strong>。</p>
<p>使用mem_fn生成一个可调用对象<br>
通过使用标准库功能<strong>mem_fn</strong>来让编译器负责<strong>推断成员的类型</strong>。和function一样，mem_fn也定义在<strong>functional头文件中</strong>，并且可以从成员指针生成一个可调用对象；和function不同的是，mem_fn可以根据<strong>成员指针的类型</strong>推断<strong>可调用对象的类型</strong>，而无须用户显式地指定（<strong>引用或者指针</strong>）：</p>
<p>使用bind生成一个可调用对象<br>
出于完整性的考虑，我们还可以<strong>使用bind</strong>(参见10.3.4节，第354页）从成员函数生成一个可调用对象：</p>
<p>和function类似的地方是，当我们使用bind时，<strong>必须将函数中用于表示执行对象的隐式形参转换成显式的</strong>。和mem_fn类似的地方是，bind生成的可调用对象的<strong>第一个实参</strong>既可以是string的<strong>指针</strong>，也可以是string的<strong>引用</strong>：</p>
<p>习题19.18</p>
<pre><code>class vector{
public:
	bool if_empty(vector&lt;string&gt;::iterator i){
			if((*i).empty())
					return true;
			return false;
}
}

vector&lt;string&gt; vs;
functional&lt;bool(const string&amp;)&gt; ifem=&amp;vector::if_empty;//注意是functional中是&lt;bool(const string&amp;)&gt;而不是&lt;bool(vector&lt;string&gt;::iterator)&gt; ，用于指明对象是否以指针或引用的形式传入
count_if(vs,begin,vs.end,ifem)
count_if(vs,begin,vs.end,men_fn(&amp;vector::if_empty))
count_if(vs,begin,vs.end,bind(&amp;vector::if_empty,_1))
</code></pre>
<p>注意是functional中是<code>&lt;bool(const string&amp;)&gt;</code>而不是<code>&lt;bool(vector&lt;string&gt;::iterator)&gt;</code>，用于指明对象是否以指针<code>（&lt;bool(const string*)&gt;）</code>或引用的形式传入<br>
习题19.19<br>
使用find_first_of就行</p>
<p>19.5 嵌套类<br>
<strong>一个类</strong>可以<strong>定义</strong>在<strong>另一个类的内部</strong>，前者称为嵌套类（nested class)或嵌套类型（nested type)。<strong>嵌套类</strong>常用于<strong>定义作为实现部分的类</strong>，<br>
嵌套类是一个<strong>独立的类</strong>，<strong>与外层类基本没什么关系</strong>。特别是，外层类的对象和嵌套类的<strong>对象是相互独立的</strong>。在嵌套类的对象中不包含任何外层类定义的成员，类似的，在外层类的对象中也不包含任何嵌套类定义的成员。<br>
<strong>嵌套类的名字在外层类作用域中是可见的</strong>，在<strong>外层类作用域之外不可见</strong>。和其他嵌套的名字一样，嵌査类的名字不会和别的作用域中的同一个名字冲突。</p>
<p>声明一个嵌套类</p>
<p>在外层类之外定义一个嵌套类<br>
我们在TextQuery内声明了Query Result,但是没有给出它的定义。和成员函数一样，嵌套类必须<strong>声明在类的内部</strong>，但是可<strong>定义在类的内部或者外部</strong>。</p>
<p>定义嵌套类的成员<br>
在这个版本的QueryResult类中，我们并没有在类的内部<strong>定义其构造函数</strong>。要想为其定义构造函数，必须指明如QueryResult是嵌套在TextQuery的作用域之内的。具体做法是使<strong>用外层类的名字限定嵌套类的名字</strong>；</p>
<p>嵌套类的静态成员定义<br>
<strong>静态成员的定义必须为于类之外，因为静态成语属于类，而不属于某个对象，如果在类内定义，则每个对象定义时也会重新定义一次，不符合静态成员的要求</strong><br>
如果QueryResult<strong>声明了一个静态成员</strong>，则该成员的<strong>定义</strong>将位于TextQuery的<strong>作用域之外</strong></p>
<p>嵌套类作用域中的名字查找<br>
名字查找的一般规则（参见7.4.1节，第254页）在嵌套类中同样适用。当然，因为嵌套类本身是一个嵌套作用域，所以<strong>还必须查找嵌套类的外层作用域</strong>。这种作用域嵌套的性质正好可以说明为什么我们不在QueryResult的嵌套版本中定义line_no.<br>
如我们所知，嵌套类是其外层类的一个类型成员，因此<strong>外层类的成员</strong>可以像<strong>使用任何其他类型成员一样使用嵌套类的名字</strong>。</p>
<p>和过去一样，<strong>返回类型不在类的作用域中</strong>（参见7.4节，第253页）因此我们<strong>必须指明函数的返回值是TextQuery::QueryResult类型</strong>。不过在函数体内部我们可以直接访问QueryResult，比如上面的return语句就是这样。</p>
<p>嵌套类和外层类是相互独立的<br>
尽管嵌套类定义在其外层类的作用域中，但是读者必须谨记<strong>外层类的对象和嵌套类的对象没有任何关系</strong>。嵌套类的<strong>对象只包含嵌套类定义的成员</strong>：同样，外层类的<strong>对象只包含外层类定义的成员</strong>，在外层类对象中不会有任何嵌套类的成员。</p>
<p>习题19.20<br>
嵌套之后记得要在QueryResult的定义中加上TextQuery::</p>
<p>19.6 union:<strong>一种节省空间的类</strong><br>
联合（union)是一种特殊的类。一个union可以有多个数据成员，但是<strong>在任意时刻只有一个数据成员可以有值</strong>。当我们<strong>给union的某个成员赋值</strong>之后，该union的<strong>其他成员就变成未定义的状态</strong>了。分配给一个union对象的<strong>存储空间</strong>至少要<strong>能容纳它的最大的数据成员</strong>。和<strong>其他类一样</strong>，<strong>一个union定义了一种新类型</strong>。<br>
union<strong>不能含有引用类型的成员</strong><br>
<strong>含有构造函数 或析构函数的类类型</strong>也可以作为union的<strong>成员类型</strong>。union可以为其成员<strong>指定public、 protected和private等保护标记</strong>。默认情况下，<strong>union的成员都是公有的</strong>，这一点<strong>与struct相同</strong>。<br>
<strong>union可以定义</strong>包括构造函数和析构函数在内的<strong>成员函数</strong>。但是由于union<strong>既不能继承自其他类</strong>，<strong>也不能作为基类使用</strong>，所以<strong>在union中不能含有虚函数</strong>。</p>
<p>定义union<br>
union提供了一种有效的途径使得我们可以<strong>方便地表示一组类型不同的互斥值</strong>。</p>
<p>使用union类型<br>
union的名字是一个<strong>类型名</strong>。和其他内置类型一样，<strong>默认情况下union是未初始化的</strong>。我们可以像显式地初始化聚合类（参见7.5.5节，第266页）一样使用一对<strong>花括号</strong>内的<strong>初始值</strong>显式地<strong>初始化一个union</strong>：</p>
<p>我们使用通用的<strong>成员访问运算符（. 或者 -&gt;）</strong> 访问一个union对象的成员：<br>
last_token.cval = ‘z’;<br>
pt-&gt;ival = 42;<br>
为union的<strong>一个数据成员赋值</strong>会令<strong>其他数据成员变成未定义</strong>的状态。因此，当我们使用 union时，<strong>必须淸楚地知道当前存储在union中的值到底是什么类型</strong></p>
<p>匿名union<br>
<strong>匿名union</strong>(anonymous union)是一个<strong>未命名的union</strong>,并且在<strong>右花括号和分号之间没有任何声明</strong>（参见2.6.1节，第65页）。一旦我们<strong>定义了一个匿名union</strong>，编译器就<strong>自动地为该union创建一个未命名的对象</strong><br>
在匿名union的定义<strong>所在的作用域</strong>内该union的<strong>成员都是可以直接访问的</strong>。<br>
匿名union不<strong>能包含受保护的成员</strong>或<strong>私有成员</strong>，<strong>也不能定义成员函数</strong>。</p>
<p>含有类类型的union<br>
如果union的成员类型<strong>定义了自己</strong>的<strong>构造函数</strong>和/或<strong>拷贝控制成员</strong>，则该union的用法要比只含有内置类型成员的union<strong>复杂得多</strong>。</p>
<p><strong>例如string</strong><br>
使用类管理union成员<br>
对于union来说，要想构造或销毁类类型的成员必须执行非常复杂的操作，因此我们通常把<strong>含有类类型成员的union内嵌在另一个类当中</strong>。<strong>这个类</strong>可以<strong>管理并控制</strong>与<strong>union的类类型成员有关的状态转换</strong>。<br>
为了<strong>追踪union中</strong>到底<strong>存储了什么类型</strong>的值，我们通常会<strong>定义一个独立的对象</strong>，该对象称为<strong>union的判别式</strong>（discriminant)。我们可以使用判别式辨认union存储的值。为了保持union-与其判别式同步，我们将判别式也作为Token的成员。我们的类将定义一个<strong>枚举类型</strong>（参见19.3节，第736页）的成员来追踪其union成员的状态。<br>
<strong>string不是内置类型，所以要有自己的析构函数</strong></p>
<p>管理判别式并销毁string</p>
<p>管理需要拷贝控制的联合成员<br>
和依赖于类型的赋值运算符一样，<strong>拷贝构造函数</strong>和<strong>赋值运算符</strong>也需要<strong>先检验判别式</strong>以 <strong>明确拷贝所采用的方式</strong></p>
<p>赋值运算符必须处理string成员的三种可能情况：左侧运算对象和右侧运算对象都是string、两个运算对象都不是string、只有一个运算对象是string：</p>
<p>习题19.21</p>
<pre><code>class Token {
public:
	Token() :tok(INT), ival(0) {}
	Token(const Token &amp;t) :tok(t.tok) { copyUnion(t); }
	Token &amp;operator=(const Token&amp;);
	~Token() { if (tok == STR) sval.~string(); }
	Token &amp;operator=(const std::string&amp;);
	Token &amp;operator=(char);
	Token &amp;operator=(int);
	Token &amp;operator=(double);

private:
	enum {INT,CHAR,DBL,STR} tok;
	union {
		char cval;
		int ival;
		double dval;
		std::string sval;
	};
	void copyUnion(const Token&amp;);
};

Token &amp;Token::operator=(int i) {
	if (tok == STR)
		sval.~string();
	ival = i;
	tok = INT;
	return *this;
}

Token &amp;Token::operator=(const std::string &amp;s) {
	if (tok == STR) 
		sval=s;
	else 
		new(&amp;sval) std::string(s);
	tok = STR;
	return *this;
}

void Token::copyUnion(const Token &amp;t) {
	switch (t.tok)
	{
	case Token::INT: ival = t.ival; break;
	case Token::CHAR: cval = t.ival; break;
	case Token::DBL: dval = t.ival; break;
	case Token::STR: new(&amp;sval) std::string(t.sval);
	default:
		break;
	}
}

Token &amp;Token::operator=(const Token &amp;t) {
	if (tok == STR&amp;&amp;t.tok != STR) sval.~string();
	if (tok == STR&amp;&amp;t.tok == STR)
		sval = t.sval;
	else
		copyUnion(t);
	tok = t.tok;
	return *this;
}
</code></pre>
<p>习题感悟：<br>
注意是functional中是<code>&lt;bool(const string&amp;)&gt;</code>而不是<code>&lt;bool(vector&lt;string&gt;::iterator)&gt;</code>，用于指明对象是否以指针<code>（&lt;bool(const string*)&gt;）</code>或引用的形式传入</p>

            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://lixin-ee.github.io//post/shu-173-er-cha-sou-suo-shu-die-dai-qi-zhong-deng">
              <h3 class="post-title">
                树 173. 二叉搜索树迭代器[中等]
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '253c8689f3b11b51dcf1',
    clientSecret: '64df7c097665e7dd6f416ecfaba36581a91bdb63',
    repo: 'Nixil-ee.github.io',
    owner: 'Lixin-ee',
    admin: ['Lixin-ee'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://lixin-ee.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

      </div>
    </div>
  </body>
</html>
