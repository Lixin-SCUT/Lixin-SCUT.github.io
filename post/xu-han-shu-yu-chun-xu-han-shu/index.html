<html>
  <head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>虚函数与纯虚函数 | Lixin-SCUT</title>
<link rel="shortcut icon" href="https://lixin-scut.github.io//favicon.ico?v=1583829311087">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://lixin-scut.github.io//styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://lixin-scut.github.io/">
  <img class="avatar" src="https://lixin-scut.github.io//images/avatar.png?v=1583829311087" alt="">
  </a>
  <h1 class="site-title">
    Lixin-SCUT
  </h1>
  <p class="site-description">
    In the darkest night,rising like a spire.
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          时间轴
        </a>
      
    
      
        <a href="/tags" class="menu">
          分类/标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>


        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              虚函数与纯虚函数
            </h2>
            <div class="post-info">
              <time class="post-time">
                · 2020-02-09 ·
              </time>
              
                <a href="https://lixin-scut.github.io//tag/JZUtdJBb3" class="post-tag">
                  # C++
                </a>
              
            </div>
            
            <div class="post-content">
              <p><a href="https://lixin-scut.github.io/post/guan-yu-xu-han-shu-he-chun-xu-han-shu/">关于虚函数和纯虚函数</a></p>
<p>书中概念：</p>
<h2 id="虚函数">虚函数</h2>
<p>对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成虚函数 (virtual function)<br>
派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以在这样的函数之前加上 virtual 关键字.但是并不是非得这么做。<br>
C ++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，具体措施是在该函数的形参列表之后增加一个 override 关键字。<br>
当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。<br>
基类必须将它的两种成员函数区分开来：一种是基类希望其派生类进行覆盖的函数；另一种是基类希望派生类直接维承而不要改变的函数。对于前者，基类通常将其定义为虚函数（ virtual )。<br>
基类通过在其成员函数的声明语句之前加上关键字virtual使得该函数执行动态绑定。任何构造函数之外的非静态函数都可以是虚函数。关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。<br>
成员函数如果没被声明为虚函数，则其解析过程发生在编译时而非运行时。<br>
如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接维承其在基类中的版本。<br>
C ++11新标准允许派生类显式地注明它使用某个成员函数覆盖了它维承的虚函数。具体做法是在形参列表后面、或者在 const 成员函数（参见7。1.2节，第231页）的 const 关键字后面、或者在引用成员函数（参见13.6.3节，第483页）的引用限定符后面添加一个关键字 override 。</p>
<p>因为我们直到运行时才能知道到底调用了哪个版本的虚函数，所以所有虚函数都必须有定义<br>
因为连编译器也无法确定到底会使用哪个虚函数。<br>
动态绑定只有当我们通过指针或引用调用虚函数时才会发生。<br>
当通过一个具有普通类型（非引用非指针）的表达式调用虚函数时，在编译时就会将调 用的版本确定下来。<br>
OOP的核心思想是多态性（polymorphism)。我们把具有继承关系的多个类型称为多态类型.<br>
当我们在派生类中覆盖了某个虚函数时，可以再一次使用virtual 关键字指出该函数的性质。然而这么做并非必须，因为一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数。<br>
一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致。<br>
同样，派生类中虚函数的返回类型也必须与基类函数匹配。该规则存在一个例外，当类的虚函数返回类型是类本身的指针或引用时，上述规则无效。<br>
派生类如果定义了一个函数与基类中虚函数的名字相同但是形参列表不同，这仍然是合法的行为。编译器将认为新定义的这个函数与基类中原有的函数是相互独立的。这时，派生类的函数并没有覆盖掉基类中的版本。就实际的编程习惯而言，这种声明往往意味着发生了错误，因为我们可能原本希望派生类能覆盖掉基类中的虚函数，但是一不小心把形参列表弄错了。要想调试并发现这样的错误显然非常团难。在 C ++11新标准中我们可以使用override 关键字来说明派生类中的虚函数。<br>
如果我们使用override 标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器将报错：<br>
我们还能把某个函数指定为 final ,如果我们已经把函数定义成 final 了，则之后任何尝试覆盖该函数的操作都将引发错误<br>
final 和 override 说明符出现在形参列表（包括任何 const 或引用修饰符）以及尾置<br>
返回类型（参见6.3.3节，第206页）之后<br>
虚函数也可以拥有默认实参（参见6.5.1节，第211页）。如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定。<br>
如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。此时，传入派生类函数的将是基类函数定义的默认实参。<br>
如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致<br>
在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。使用作用域运算符可以实现这一目的，例如下面的代码：</p>
<p>通常情况下，只有成员函数（或友元）中的代码才需要使用作用域运算符来回避虚函数机制<br>
通常是—个派生类的虚函数调用它覆盖的基类的虚函数版本时。在此情况下，基类的版本通常完成继承层次中所有类型都要做的共同任务，而派生类中定义的版本需要执行一些与派生类本身密切相关的操作。<br>
如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本自身的调用，从而导致无限递归</p>
<p>除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字</p>
<p>为什么基类与派生类中的虚函数必须有相同的形参列表了（参见15.3节，第537页）。假如基类与派生类的虚函数接受的实参不同.则我们就无法通过基类的引用或指针调用派生类的虚函数了。</p>
<p>如果基类的析构函数不是虚函数，则 delete —个指向派生类对象的基类指针将产生未定义的行为。<br>
之前我们曾介绍过一条经验准则，即如果一个类需要析构函数，那么它也同样需要拷贝和赋值操作（参见13.1.4节，第447页）。基类的析构函数并不遵循上述准则，它是一个重要的例外。一个基类总是需要析构函数，而且它能将析构函数设定为虚函数。此时，该析构函数为了成为虚函数而令内容为空，我们显然无法由此推断该基类还需要赋值运算或拷贝构造函数。</p>
<p>当我们构建一个对象时，需要把对象的类和构造函数的类看作是同一个；对虚函数的调用绑定正好符合这种把对象的类和构造函数的类看成同一个的要求；对于析构函数也是同样的道理。<br>
如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。</p>
<p>一个类（无论是普通类还是类模板）可以包含本身是模板的成员函数。这种成员被称为成员模板 (member template )。成员模板不能是虚函数。</p>
<p>如果一个虚函数承诺了它不会抛出异常，则后续派生出来的虚函数也必须做出同样的承诺；与之相反，如果基类的虚函数允许抛出异常，则派生类的对应函数既可以允许抛出异常，也可以不允许抛出异常</p>
<p>运行时类型识别（run-time type identification,RTTI)的功能由两个运算符实现：<br>
• typeid运算符，用于返回表达式的类型。<br>
• dynamic_cast运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用。<br>
这两个运算符特别适用于以下情况：我们想使用基类对象的指针或引用执行某个派生 类操作并且该操作不是虚函数。一般来说，只要有可能我们应该尽量使用虚函数。当操作被定义成虚函数时，编译器将根据对象的动态类型自动地选择正确的函数版本。<br>
然而，并非任何时候都能定义一个虚函数。假设我们无法使用虚函数，则可以使用一个RTTI运算符。另一方面，与虚成员函数相比，使用RTTI运算符蕴含着更多潜在的风险：程序员必须清楚地知道转换的目标类型并且必须检查类型转换是否被成功执行。<br>
使用RTTI必须要加倍小心。在可能的情况下，最好定义虚函数而非直接接管类型管理的重任。<br>
当运算对象不属于类类型或者是一个不包含任何虚函数的类时，typeid运算符指示的是运算对象的静态类型。而当运算对象是定义了至少一个虚函数的类的左值时，typeid的结果直到运行时才会求得。<br>
typeid是否需要运行时检查决定了表达式是否会被求值。只有当类型含有虚函数时，编译器才会对表达式求值。反之，如果类型不含有虚函数，则typeid返回表达式的静态类型；编译器无须对表达式求值也能知道表达式的静态类型。</p>
<p>union可以定义包括构造函数和析构函数在内的成员函数。但是由于union既不能继承自其他类，也不能作为基类使用，所以在union中不能含有虚函数。</p>
<h2 id="纯虚函数">纯虚函数</h2>
<p>和普通的虚函数不一样，一个纯虚函数无须定义。我们通过在函数体的位置（即在声明语句的分号之前）书写=0就可以将一个虚函数说明为纯虚函数。其中，=0只能出现在类内部的虚函数声明语句处：<br>
值得注意的是，我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。 也就是说，我们不能在类的内部为一个=0的函数提供函数体。</p>
<p>含有（或者未经覆盖直接继承）纯虚函数的类是抽象基类 （abstractbaseclass )。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。我们不能（直接）创建一个抽象基类的对象。</p>
<p>我们竟然可以为纯虚函数提供定义，但调用它的唯一途径是调用时明确指出其class的名称。（effective c++ ）</p>
<p>网上博客：<br>
纯虚函数更多地希望声明有一个这样的统一接口，具体的实现留到子类里去实现</p>
<p>虚函数和纯虚函数都不能有static表示服，被static修饰的函数在编译时候要求前期bind，然而虚函数却是动态绑定，而且被两者修饰的函数生命周期也不一样。</p>
<p>假设Bulk_quote的直接基类是Disc_quote,间接基类是Quote。每个Bulk_quote对象包含三个子对象：一个（空的）Bulk_quote部分、一个Disc_quote子对象和一个Quote子对象。如果Disc_quote中对Quote的纯虚函数提供了实现，则纯虚函数变为虚函数，Bulk_quote中可以选择直接继承或者override<br>
（注意这里的分部分思想，对于理解多层派生很有用）</p>
<p>虚函数是实现多态的机制，核心理念就是通过基类的指针或引用来访问派生类定义的函数</p>
<p>多态：<br>
编译多态：通过重载函数实现<br>
运行多态：通过虚函数实现</p>
<p>虚函数和纯虚函数有以下所示方面的区别。</p>
<p>类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖，这样的话，这样编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。<br>
虚函数在子类里面也可以不重载的；但纯虚函数必须在子类去实现，这就像 Java 的接口一样。通常把很多函数加上 virtual，是一个好的习惯，虽然牺牲了一些性能，但是增加了面向对象的多态性，因为很难预料到父类里面的这个函数不在子类里面不去修改它的实现。<br>
虚函数的类用于“实作继承”，继承接口的同时也继承了父类的实现。当然大家也可以完成自己的实现。纯虚函数关注的是接口的统一性，实现由子类完成。<br>
带纯虚函数的类叫虚基类，这种基类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。这样的类也叫抽象类。抽象类和大家口头常说的虚基类还是有区别的，在 C# 中用 abstract 定义抽象类，而在 C++ 中有抽象类的概念，但是没有这个关键字。抽象类被继承后，子类可以继续是抽象类，也可以是普通类，而虚基类，是含有纯虚函数的类，它如果被继承，那么子类就必须实现虚基类里面的所有纯虚函数，其子类不能是抽象类。<br>
纯虚函数</p>
<p>声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。</p>
<p>纯虚函数最显著的特征是：它们必须在继承类中重新声明函数（不要后面的＝0，否则该派生类也不能实例化），而且它们在抽象类中往往没有定义。</p>
<p>定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。</p>
<p>纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。</p>
<p>顺便说一句，为一个纯虚函数提供定义也是可能的。也就是说，你可以为纯虚函数提供实现，C++ 编译器也不会阻拦（DEV_CPP 中 G++(gcc 3.4.2) 编译器并不支持为纯虚函数定义缺省行为；在 VC6.0 支持为纯虚函数定义缺省的实现，派生类的虚函数 override 基类的纯虚函数），但调用它的唯一方式是通过类名完整地指明是哪个调用（如：pb-&gt;Base:: pureVirtual()）。</p>
<p>有时，声明一个除纯虚函数外什么也不包含的类很有用。这样的类叫协议类（Protocol class），它为派生类仅提供函数接口，完全没有实现。</p>
<p>虚函数（在此指的是非纯虚函数）</p>
<p>虚函数的情况和纯虚函数有点不一样。照例，派生类继承了函数的接口，但简单虚函数一般还提供了实现，派生类可以选择改写（override）它们或不改写它们。</p>
<p>声明虚函数的目的在于，使派生类继承函数的接口和缺省实现。</p>
<p>虚函数的意义，每个类必须提供一个可以被调用的虚函数，但每个类可以按它们认为合适的任何方式处理。如果某个类不想做什么特别的事，可以借助于基类中提供的缺省处理函数。也就是说，虚函数的声明是在告诉子类的设计者，”你必须支持虚函数，但如果你不想写自己的版本，可以借助基类中的缺省版本。”</p>
<p>实际上，为虚函数同时提供函数声明和缺省实现是很危险的。(当你增加一个派生类继承基类时,必须小心使用虚函数,满足派生类特有的需求，否则就是调用基类的虚函数，可能引起错误)</p>
<p>非虚函数</p>
<p>最后，来谈谈类的非虚函数，当一个成员函数为非虚函数时，它在派生类中的行为就不应该不同。实际上，非虚成员函数表明了一种特殊性上的不变性，因为它表示的是不会改变的行为――不管一个派生类有多特殊。</p>
<p>声明非虚函数的目的在于，使派生类继承函数的接口和强制性实现。（所有的派生类都应该完成的使用该函数完成某一个功能）</p>
<p>建议</p>
<p>结合前面的学过的，再次强调一下，如果你没有为类设计虚函数（纯虚函数），该类一般来说应该不具有继承特性（除非确实的存在 IS-A 关系，即便存在，派生类也没有了特殊性，这种情况一般是设计中抽象的不合理）。当然除了 Protocol class 也不应该把类的成员函数全部设计成虚函数（纯虚函数），这也说明了类设计的不合理（不能正确的抽象出基类、派生类之间不变的部分）。</p>
<p>c++ 中没有接口的概念，与之对应的是纯虚类，即只含有纯虚函数的类，c++ 抽象类的概念是含有纯虚函数成员的类。这是因为 c++ 提供多继承，而像 java、c# 这些只提供单继承（避免多继承的复杂性和低效性）的语言为了模拟多继承功能就提供了接口概念，接口可以继承多个。</p>
<p>abstract class 是抽象类，至少包含一个纯虚函数的类就叫做抽象类。</p>
<p>但是如果一个类，所有的成员都是纯虚函数，那么它和一般的抽象类在用法上是有区别的。至少 Microsoft 给的 COM 接口定义全部都是仅由纯虚函数构成的类。因此把这样的类定义叫做纯虚类也不算错。</p>
<p>纯虚函数和虚函数的区别在于前者不包含定义，而后者包含函数体。</p>
<p>那么纯虚类就是不包含任何实现（包括成员函数定义和成员变量定义。前者代表算法，后者代表结构）。不包含任何算法和结构的类叫做纯虚类，应该没有问题。</p>
<p>在 Java 里面的确没有纯虚类的概念，因为 Java 里没有纯虚函数这个概念。Java 管虚函数叫做 abstract function，管抽象类叫做 abstract class，直接说来，Java 根本没有 virtual 这个关键字，都用 abstract 代替，因此 Java 里面根本就没有 Pure 这个概念。有那就是 interface。在 interface 里面定义的函数都不能有函数体，这个在 Java 里面叫做接口。那么 C++ 里面与 interface 等同的概念就是纯虚类了，C++ 用纯虚类来模拟 interface 这个抽象概念，因此这里说的“纯虚类”与 Java 的 abstract class 不同，与 C++ 的一般抽象类也不同。“纯虚类”与 C++ 一般抽象类的区别就好比 Java 里面 interface 和 abstract class 的区别。</p>
<p>抽象类：</p>
<p>抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的，它处于继承层次结构的较上层。</p>
<p>抽象类的定义：</p>
<p>称带有纯虚函数的类为抽象类。称带有纯虚函数的类为抽象类。</p>
<p>抽象类的作用：</p>
<p>抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。所 以派生类实际上刻画了一组子类的操作接口的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。</p>
<p>使用抽象类时注意：</p>
<p>• 抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。</p>
<p>• 抽象类是不能定义对象的。</p>
<h3 id="虚函数的实现">虚函数的实现</h3>
<p>《深度探索c++模型》<br>
1.声明的类导入一个virtual table，存放它所声明的每一个虚函数地址，再加上一个或两个slots（用以支持runtime type identification）<br>
2.类每个对象都导入一个vptr，提供执行期的链接<br>
3.加强constructor，使他能够为vptr提供初值<br>
4.加强deconstructor 能够抹消vptr</p>
<p>为了兼容c语言，早期vptr放在class尾端<br>
现在一般把vptr放在前端，对于在多重继承之下，通过指向class members的指针调用 virtual function有帮助</p>
<p>多重继承：派生类继承了多个基类，基类又各自有自己的虚函数<br>
如果基类没有虚函数而派生类有，则把一个派生类对象转化为基类对象就需要编译器介入以调整地址<br>
对于第一个基类情况和单一继承时相同，之后的基类则需要修改地址，加上（活着减去）介于中间的基类大小（编译器一半按照声明的次序来排列它们）<br>
此时会有多个vptr</p>
<p>虚拟继承：适用于菱形继承<br>
如果class内包含一个或多个虚继承的基类，将分为两个部分：一个不变局部和共享局部<br>
共享局部就是虚继承的基类所在，其位置会因为每次的派生操作而有变化，所以它们只能被间接存取</p>
<p>博客：<br>
<a href="https://blog.csdn.net/weixin_40237626/article/details/82313339">虚函数实现原理</a><br>
带有虚函数的类，编译器会为其额外分配一个虚函数表，里面记录的使虚函数的地址，当此类被继承时，子类如果也写了虚函数就在子类的虚函数表中将父类的函数地址覆盖，否则继承父类的虚函数地址。</p>
<p>实例化之后，对象有一个虚函数指针，虚函数指针指向虚函数表，这样程序运行的时候，通过虚函数指针找到的虚函数表就是根据对象的类型来指向的了。</p>
<h3 id="虚函数和内联">虚函数和内联：</h3>
<p>如果函数已经被声明为inline, 内联函数已经在编译期间它的调用点上就被展开，内联不是强制性的，你只是向编译器提出这个建议，允许它在可以内联的时候采取内联形式;<br>
虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。<br>
内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。<br>
inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</p>
<pre><code>	#include &lt;iostream&gt;
	using namespace std;
	// 基类
	class Base{
		public:
			inline virtual void who(){
				cout &lt;&lt; &quot;I am Base\n&quot;;
			}
			virtual ~Base(){}
	};
	// 派生类
	class Derived:public Base{
		public:
			inline void who(){   // 不写inline时隐式内联
				cout &lt;&lt; &quot;I am Derived\n&quot;;
			}
	};
int  main(){
	// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。
	Base b;
	b.who();
	// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。
	Base *bptr = new Derived();
	bptr-&gt;who();
	// 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。
</code></pre>
<h3 id="构造函数与虚函数">构造函数与虚函数</h3>
<p>1.虚函数对应一个虚指针，虚指针其实是存储在对象的内存空间的。如果构造函数是虚的，就需要通过 虚指针执行那个虚函数表（编译期间生成属于类）来调用，可是对象还没有实例化，也就是内存空间还没有，就没有虚指针，所以构造函数不能是虚函数。</p>
<p>2.虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。</p>
<p>C++ 中哪些函数不能被声明为虚函数?<br>
(普通、内联、构造、友元、静态)</p>
<p>重载与override<br>
注意override和重载不同，重载是针对普通成员函数，override针对虚函数</p>
<p>求虚函数表地址的代码</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
class Base{
	public: 
	virtual void fun()
	{
		cout&lt;&lt;&quot;This is Base Class&quot;&lt;&lt;endl;
	}
};
class Derived:public Base{
	public:
	void fun()
	{
		cout&lt;&lt;&quot;This is Derived Class&quot;&lt;&lt;endl;
	}
};
int main()
{
	Base B;
	Derived D; 
	int **p=(int**)&amp;B;
	cout&lt;&lt;&quot;基类的虚函数表地址:&quot;&lt;&lt;p[0]&lt;&lt;endl;
	cout&lt;&lt;&quot;基类的虚函数表中虚函数的地址:0x&quot;&lt;&lt;hex&lt;&lt;p[0][0]&lt;&lt;endl;
	p=(int**)&amp;D;
	cout&lt;&lt;&quot;派生类的虚函数表地址:&quot;&lt;&lt;p[0]&lt;&lt;endl;
	cout&lt;&lt;&quot;派生类的虚函数表中虚函数的地址:0x&quot;&lt;&lt;hex&lt;&lt;p[0][0]&lt;&lt;endl;
	
	return 0;
	}
</code></pre>
<pre><code>当vprt位于对象内存最前面时，对象的地址即为虚函数指针地址。我们可以取得虚函数指针的地址：

Base b(1000);
int * vptrAdree = (int *)(&amp;b);  
cout &lt;&lt; &quot;虚函数指针（vprt）的地址是：\t&quot;&lt;&lt;vptrAdree &lt;&lt; endl;

我们强行把类对象的地址转换为 int* 类型，取得了虚函数指针的地址。虚函数指针指向虚函数表,虚函数表中存储的是一系列虚函数的地址，虚函数地址出现的顺序与类中虚函数声明的顺序一致。对虚函数指针地址值，可以得到虚函数表的地址，也即是虚函数表第一个虚函数的地址:

    typedef void(*Fun)(void);
    Fun vfunc = (Fun)*( (int *)*(int*)(&amp;b));
    cout &lt;&lt; &quot;第一个虚函数的地址是：&quot; &lt;&lt; (int *)*(int*)(&amp;b) &lt;&lt; endl;
    cout &lt;&lt; &quot;通过地址，调用虚函数Base::print()：&quot;;
    vfunc();
我们把虚表指针的值取出来： ＊(int＊)(&amp;b)，它是一个地址，虚函数表的地址
把虚函数表的地址强制转换成 int* : ( int ＊) ＊( int＊ )( &amp;b )
再把它转化成我们Fun指针类型 ： (Fun )＊(int ＊)＊(int＊)(&amp;b)
这样，我们就取得了类中的第一个虚函数，我们可以通过函数指针访问它

同理,第二个虚函数setI()的地址为：
 (int * )(*(int*)(&amp;b)+1)
</code></pre>
<pre><code>//自己的代码
class Base {
public:
    int i1;
    virtual void func1(){ cout &lt;&lt; &quot;func2()&quot; &lt;&lt; endl; };
};

class Derived : public Base {
public:
    int i2;
    virtual void func2(){ cout &lt;&lt; &quot;func1()&quot; &lt;&lt; endl; };
};


void functest(int i){
    cout &lt;&lt; i &lt;&lt; endl;
}
int main() {
    typedef void (*Func)();
    Base b;
    Derived d;
    d.i1 = 8;
    d.i2 = 88;

    int **p=(int**)&amp;b;
    cout&lt;&lt;&quot;基类的虚函数表地址:&quot;&lt;&lt;*p&lt;&lt;endl;
    cout&lt;&lt;&quot;基类的虚函数表中虚函数的地址:0x&quot;&lt;&lt;hex&lt;&lt;**p&lt;&lt;endl;
    
    p=(int**)&amp;d;
    cout&lt;&lt;&quot;派生类的虚函数表地址:&quot;&lt;&lt;p[0]&lt;&lt;endl;
    cout&lt;&lt;&quot;派生类的虚函数表中虚函数的地址:0x&quot;&lt;&lt;p[0][0]&lt;&lt;endl;

    int* i1Ptr = &amp;(d.i1);
    int* i2Ptr = &amp;(d.i2);
    cout &lt;&lt; p+1 &lt;&lt; endl ;
    cout &lt;&lt; i1Ptr &lt;&lt; &quot; &quot; &lt;&lt; i2Ptr &lt;&lt; endl;

//注意**p是一个int而不是int*
//注意在Clion的编译器和Microsoft一致，派生类题添加新的虚函数时，会把虚函数的指针加到基类的虚函数表里面，i2的位置表明并没有新的虚函数表
}
</code></pre>
<p>#析构函数可以是纯虚函数吗<br>
可以，但不常用，而且需要在类外提供析构函数的定义<br>
这个定义是必需的，因为虚析构函数工作的方式是：最底层的派生类的析构函数最先被调用，然后各个基类的析构函数被调用。这就是说，即使是抽象类，编译器也要产生对~awov的调用，所以要保证为它提供函数体。如果不这么做，链接器就会检测出来，最后还是得回去把它添上。<br>
虽然抽象类的析构函数可以是纯虚函数，但要实例化其派生类对象，仍必须提供抽象基类中析构函数的函数体。<br>
但是继承一个有纯虚析构函数的类的时候，在派生类中可以不给出析构函数的定义，并且这个类也不是抽象类，这是与其它函数不同的地方（其它纯虚函数没有给出定义的话，这个类也是抽象类）。因为编译器自动帮我们生成了一个定义，所以也可以认为重写了父类的纯虚函数。</p>
<p>同理引出 虽然抽象类不能被实例化，但可以有构造函数由于抽象类的构造函数在实例化派生类之前发生，所以，可以在这个阶段初始化抽象类字段或执行其它与子类相关的代码。</p>
<p>可以在构造函数析构函数中调用虚函数吗<br>
可以，虚函数底层实现原理(但是最好不要在构造和析构函数中调用) 可以，但是没有动态绑定的效果，父类构造函数中调用的仍然是父类版本的函数，子类中调用的仍然是子类版本的函数。 effictive c++第九条，绝不在构造和析构过程中调用virtual,因为构造函数中的base的虚函数不会下降到derived上。而是直接调用base类的虚函数。绝不在构造和析构函数中调用virtual函数</p>
<p>虚函数会占用存储空间嘛?是占类的空间大小?<br>
计算一个类对象的大小时的规律：<br>
1、空类、单一继承的空类、多重继承的空类所占空间大小为：1（字节，下同）；<br>
2、一个类中，虚函数本身、成员函数（包括静态与非静态）和静态数据成员都是不占用类对象的存储空间的；<br>
3、因此一个对象的大小≥所有非静态成员大小的总和；<br>
4、当类中声明了虚函数（不管是1个还是多个），那么在实例化对象时，编译器会自动在对象里安插一个指针vptr指向虚函数表；<br>
5、虚承继的情况：由于涉及到虚函数表和虚基表，会同时增加一个（多重虚继承下对应多个）vptr指针指向虚函数表和一个vbptr指针指向虚基表vbtable，这两者所占的空间大小为：8（或8乘以多继承时父类的个数）；<br>
6、在考虑以上内容所占空间的大小时，还要注意编译器下的“补齐”padding的影响，即编译器会插入多余的字节补齐；<br>
7、类对象的大小=各非静态数据成员（包括父类的非静态数据成员但都不包括所有的成员函数）的总和+ vptr指针(多重继承下可能不止一个)+vbptr指针(多重虚继承下可能不止一个)+编译器补齐额外增加的字节。</p>
<p>虚函数表存放在哪里<br>
这个根据编译器的不同而不用，但是统一的性质是虚函数表是全局共享的元素,即全局仅有一个.（注意这里是指每个类的多个实例化对象共享一个虚函数表，而不是指 整个派生链都共享一个虚函数表）<br>
虚函数表vtable在Linux/Unix中存放在可执行文件的只读数据段中(rodata)，这与微软的编译器将虚函数表存放在常量段存在一些差别。<br>
<a href="https://www.cnblogs.com/laiqun/p/5887372.html">关于C++中虚函数表存放位置的思考</a></p>
<p>ABC链式继承，问最后一共有多少个虚函数表?<br>
三个虚函数表，每个类使用自己的虚函数表，但没被override的虚函数的地址是一样的<br>
C++中虚函数表位于只读数据段（.rodata），也就是C++内存模型中的常量区；而虚函数则位于代码段（.text），也就是C++内存模型中的代码区。<br>
<a href="%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8">基类和派生类的虚函数表</a><br>
<a href="https://blog.csdn.net/qq_28114615/article/details/98041319">C++中的虚函数表和虚函数在内存中的位置</a></p>
<p>虚函数表是谁维护的<br>
虚函数表是由编译器自动生成与维护的</p>
<p>虚函数表创建时期<br>
编译时期由具有虚函数的类的构造函数创建<br>
vptr和vtbl的创建时机分别为：<br>
（1）vptr(虚函数表指针）什么时候创建出来的？<br>
vptr跟着对象走，所以对象什么时候创建出来，vptr就什么时候创建出来，即运行的时候创建；<br>
实际上，对于这种有虚函数的类，在编译的时候，编译器会往相关的构造函数中增加为vptr赋值的代码，这是在编译期间编译器为构造函数增加的。这属于编译器默默为我们做的事，我们并不清楚。当程序运行的时候，遇到创建对象的代码，执行对象的构造函数，那么这个构造函数里有 给对象的vptr(成员变量)赋值的语句，自然这个对象的vptr就被赋值了；<br>
（2）虚函数表是什么时候创建的？<br>
    实际上，虚函数表是编译器在编译期间（不是运行期间）就为每个类确定好了对应的虚函数表vtbl的内容（编译期间就生成了存放虚函数表的目标文件）<br>
    然后也是在编译器期间在相应的类构造函数中添加给vptr赋值的代码，这样程序运行的时候，当运行到成成类对象的代码时，会调用类的构造函数，执行到类的构造函数中的 给vptr赋值的代码，这样这个类对象的vptr(虚函数表指针)就有值了；</p>

            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://lixin-scut.github.io//post/shu-zu-ti-11xuan-zhuan-shu-zu-de-zui-xiao-shu-zi">
              <h3 class="post-title">
                数组 题11:旋转数组的最小数字
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '253c8689f3b11b51dcf1',
    clientSecret: '64df7c097665e7dd6f416ecfaba36581a91bdb63',
    repo: 'Lixin-SCUT.github.io',
    owner: 'Lixin-SCUT',
    admin: ['Lixin-SCUT'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://lixin-scut.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

      </div>
    </div>
  </body>
</html>
