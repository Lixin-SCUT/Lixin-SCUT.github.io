<html>
  <head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>静态链接与动态链接-链接 | Lixin-SCUT</title>
<link rel="shortcut icon" href="https://lixin-scut.github.io//favicon.ico?v=1584056778823">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://lixin-scut.github.io//styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://lixin-scut.github.io/">
  <img class="avatar" src="https://lixin-scut.github.io//images/avatar.png?v=1584056778823" alt="">
  </a>
  <h1 class="site-title">
    Lixin-SCUT
  </h1>
  <p class="site-description">
    In the darkest night,rising like a spire.
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          时间轴
        </a>
      
    
      
        <a href="/tags" class="menu">
          分类/标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>


        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              静态链接与动态链接-链接
            </h2>
            <div class="post-info">
              <time class="post-time">
                · 2020-03-04 ·
              </time>
              
            </div>
            
            <div class="post-content">
              <h3 id="动态编译与静态编译">动态编译与静态编译</h3>
<ol>
<li>静态编译，编译器在编译可执行文件时，把需要用到的对应动态链接库中的部分提取出来，连接到可执行文件中去，使可执行文件在运行时不需要依赖于动态链接库；</li>
<li>动态编译的可执行文件需要附带一个动态链接库，在执行时，需要调用其对应动态链接库的命令。所以其优点一方面是缩小了执行文件本身的体积，另一方面是加快了编译速度，节省了系统资源。缺点是哪怕是很简单的程序，只用到了链接库的一两条命令，也需要附带一个相对庞大的链接库；二是如果其他计算机上没有安装对应的运行库，则用动态编译的可执行文件就不能运行。</li>
</ol>
<h3 id="动态链接和静态链接区别">动态链接和静态链接区别</h3>
<ol>
<li>静态连接库就是把(lib)文件中用到的函数代码直接链接进目标程序，程序运行的时候不再需要其它的库文件；动态链接就是把调用的函数所在文件模块（DLL）和调用函数在文件中的位置等信息链接进目标程序，程序运行的时候再从DLL中寻找相应函数代码，因此需要相应DLL文件的支持。</li>
<li>静态链接库与动态链接库都是共享代码的方式，如果采用静态链接库，则无论你愿不愿意，lib 中的指令都全部被直接包含在最终生成的 EXE 文件中了。但是若使用 DLL，该 DLL 不必被包含在最终 EXE 文件中，EXE 文件执行时可以“动态”地引用和卸载这个与 EXE 独立的 DLL 文件。</li>
<li>静态链接库和动态链接库的另外一个区别在于静态链接库中不能再包含其他的动态链接库或者静态库，而在动态链接库中还可以再包含其他的动态或静态链接库。</li>
<li>动态库就是在需要调用其中的函数时，根据函数映射表找到该函数然后调入堆栈执行。如果在当前工程中有多处对dll文件中同一个函数的调用，那么执行时，这个函数只会留下一份拷贝。但是如果有多处对lib文件中同一个函数的调用，那么执行时，该函数将在当前程序的执行空间里留下多份拷贝，而且是一处调用就产生一份拷贝。</li>
</ol>
<p>参考资料：<br>
《深入了解计算机系统》</p>
<h3 id="链接">链接</h3>
<p>  链接(linking)是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文 件可被加载(复制)到内存并执行。链接可以执行于编'译时(compile time),也就是在源代 码被翻译成机器代码时；也可以执行于加载时(load time),也就是在程序被加载器(loader)加载到内存并执行时；甚至执行于运行时(run time),也就是由应用程序来执行。在早 期的计算机系统中，链接是手动执行的。在现代系统中，链接是由叫做链接器(linker)的 程序自动执行的。<br>
  链接器使得分离编译(separate compilation) 成为可能。我们不用将一个大型的应用程序组织为一个巨大的源文件，而是可以 把它分解为更小、更好管理的模块，可以独立地修改和编译这些模块。当我们改变这些模块中的一个时，只需简单地重新编译它，并重新链接应用，而不必重新编译其他文件。</p>
<h3 id="编译器">编译器</h3>
<p>  编译系统提供编译器驱动程序(compiler driver),它代表用户在需要时调用语言预处理器、编译器、汇编器和链接器。<br>
<img src="https://lixin-scut.github.io//post-images/1583314062138.png" alt=""></p>
<ol>
<li>驱动程序首先运行C预处理器(cpp) ,它将C的源程序main. c翻译成一个ASCII码的中间文件main.i。</li>
<li>驱动程序运行C编译器(ccl)，它将main.i翻译成一个ASCII汇编语言文件main.s:</li>
<li>驱动程序运行汇编器(as)，它将main.s翻译成一个可重定位目标文件(relocatable object file)main.o</li>
<li>最后，它运行链接器程序Id,将main.o和 sum.o以及一些必要的系统目标文件组合起来，创建一个可执行目标文件(executable object file)prog</li>
</ol>
<h3 id="静态链接">静态链接</h3>
<p>  静态链接器(static linker)以一组可重定位目标文件和命令行 参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。输入的可重定位目标文件由各种不同的代码和数据节(section)组成，每一节都是一个连续的字节序列。<br>
为了构造可执行文件，链接器必须完成两个主要任务：<br>
  •符号解析(symbol resolution) o目标文件定义和引用符号，每个符号对应于一&quot;函 数、一个全局变量或一个静态变量(即C语言中任何以static属性声明的变量)。 符号解析的目的是将每个符号引用正好和一个符号定义关联起来。<br>
  •重定位(relocation) o编译器和汇编器生成从地址0开始的代码和数据节。链接器通 过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对 这些符号的引用，使得它们指向这个内存位置。链接器使用汇编器产生的重定位条 目(relocation entry)的详细指令，不加甄别地执行这样的重定位。<br>
  记住关于链接器的一 些基本事实：目标文件纯粹是字节块的集合。链接器将这些块连接起来，确 定被连接块的运行时位置，并且修改代码和数据块中的各种位置。</p>
<h3 id="目标文件">目标文件</h3>
<p>目标文件有三种形式：<br>
  •可重定位目标文件。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。<br>
  •可执行目标文件。包含二进制代码和数据，其形式可以被直接复制到内存并执行。<br>
  •共享目标文件。一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。<br>
  编译器和汇编器生成可重定位目标文件(包括共享目标文件)。链接器生成可执行目标文 件。从技术上来说，一个目标模块(object module)就是一哥字节序列，而一个目标文件(object file) 就是一个以文件形式存放在磁盘中的目标模块。不过，我们会互换地使用这些术语。<br>
  目标文件是按照特定的目标文件格式来组织的，各个系统的目标文件格式都不相同。</p>
<h3 id="静态库">静态库</h3>
<p>  所有的编译系统都提供一种机制，将所有相关的目标模块打包成为一个单独的文件，称为静态库(static library),它可以用做链接器的输入。 当链接器构造一个输出的可执行文件时，它只复制静态库里被应用程序引用的目标模块。<br>
静态库相关的函数可以被编译为独'切的 目标模块，然后封装成一个单独的静态库文件。然后，应用程序可以通过在命令行上指定 单独的文件名字来使用这些在库中定义的函数。<br>
  在链接时，链接器将只复制被程序引用的目标模块，这就减少了可执行文件在磁盘和内 存中的大小。另一方面，应用程序员只需要包含较少的库文件的名字<br>
  在Linux系统中，静态库以一种称为存档（archive）的特殊文件格式存放在磁盘中。存 档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置。存档文件名由后缀.a标识。<br>
<img src="https://lixin-scut.github.io//post-images/1583314592237.png" alt=""></p>
<h3 id="链接器如何使用静态库来解析引用">链接器如何使用静态库来解析引用</h3>
<p>  虽然静态库很有用，但是它们同时也是一个程序员迷惑的源头，原因在于Linux链接 器使用它们解析外部引用的方式。在符号解析阶段，链接器从左到右按照它们在编译器驱 动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件。（驱动程序自动将命令 行中所有的.c文件翻译为.o文件。）在这次扫描中，链接器维护一个可重定位目标文件的 集合E（这个集合中的文件会被合并起来形成可执行文件），一个未解析的符号（即引用了 但是尚未定义的符号）集合U,以及一个在前面输入文件中已定义的符号集合初始时，<br>
E、U和D均为空。<br>
  •对于命令行上的每个输入文件f，链接器会判断f是一个目标文件还是一个存档文件。如果是一个目标文件，那么链接器把f添加到E,修改U和D来反映中 的符号定义和引用，并继续下一个输入文件。<br>
  ・如果f是一个存档文件，那么链接器就尝试匹配U中未解析的符号和由存档文件成员定 义的符号。如果某个存档文件成员％,定义了一个符号来解析U中的一个引用，那么就 将m加到E中，并且链接器修改U和。来反映〃中的符号定义和引用。对存档文件中 所有的成员目标文件都依次进行这个过程，直到U和。都不再发生变化。此时，任何不 包含在E中的成员目标文件都简单地被丢弃，而链接器将继续处理下一个输入文件。<br>
  •如果当链接器完成对命令行上输入文件的扫描后，U是非空的，那么链接器就会输出一 个错误并终止玄否则，它会合并和重定位E中的目标文件，构建输出的可执行文件。<br>
  不幸的是，这种算法会导致一些令人困扰的链接时错误，因为命令行上的库和目标文 件的顺序非常重要。在命令行中，如果定义一个符号的库出现在引用这个符号的目标文件 之前，那么引用就不能被解析，链接会失败。<br>
  关于库的一般准则是将它们放在命令行的结尾。如果各个库的成员是相互独立的（也 就是说没有成员引用另一个成员定义的符号），那么这些库就可以以任何顺序放置在命令 行的结尾处。另一方面，如果库不是相互独立的，那么必须对它们排序，使得对于每个被 存档文件的成员外部引用的符号S,在命令行中至少有一个S的定义是在对S的引用之后 的。</p>
<h3 id="重定位">重定位</h3>
<p>  一旦链接器完成了符号解析这一步，就把代码中的每个符号引用和正好一个符号定义 （即它的一个输入目标模块中的一个符号表条目）关联起来。此时，链接器就知道它的输入 目标模块中的代码节和数据节的确切大小。现在就可以开始重定位步骤了，在这个步骤 中，将合并输入模块，并为每个符号分配运行时地址。重定位由两步组成：<br>
  •重定位节和符号定义。在这一步中，链接器将所有相同类型的节合并为同一类型的 新的聚合节。例如，来自所有输入模块的.data节被全部合并成一个节，这个节成 为输出的可执行目标文件的.data节。然后，链接器将运行时内存地址赋给新的聚 合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步 完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了。<br>
  •重定位节中的符号引用。在这一步中，链接器修改代码节和数据节中对每个符号的 引用，使得它们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目 标模块中称为重定位条目（relocation entry）的数据结构，我们接下来将会描述这种 数据结构。</p>
<h3 id="动态链接共享库">动态链接共享库</h3>
<p>  静态库仍然有一些明显的缺点。静态库和所有的软件一样，需要定期维护 和更新。<br>
  共享库(shared library)是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接 起来。这个过程称为动态链接(dynamic linking),是由一个叫做动态链接器(dynamic linker) 的程序来执行的。共享库也称为共享目标(shared object),在Linux系统中通常用.s后缀<br>
共  享库是以两种不同的方式来“共享&quot;的。首先，在任何给定的文件系统 中，对于一个库只有一个.s文件。所 有引用该库的可执行目标文件共享这个. s文件中的代码和数据，而不是像静态库的内容那样被复制和嵌入到引用它们的可执行的文件中。其次，在内存中一个共享库的.text节的一个副本可以 被不同的正在运行的进程共享。<br>
<img src="https://lixin-scut.github.io//post-images/1583314987298.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1583315044588.png" alt=""></p>

            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://lixin-scut.github.io//post/tong-bu-ji-zhi">
              <h3 class="post-title">
                线程同步机制
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '253c8689f3b11b51dcf1',
    clientSecret: '64df7c097665e7dd6f416ecfaba36581a91bdb63',
    repo: 'Lixin-SCUT.github.io',
    owner: 'Lixin-SCUT',
    admin: ['Lixin-SCUT'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://lixin-scut.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

      </div>
    </div>
  </body>
</html>
