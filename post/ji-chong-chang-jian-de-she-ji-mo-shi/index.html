<html>
  <head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>几种常见的设计模式 | Lixin-SCUT</title>
<link rel="shortcut icon" href="https://lixin-scut.github.io//favicon.ico?v=1584629300080">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://lixin-scut.github.io//styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://lixin-scut.github.io/">
  <img class="avatar" src="https://lixin-scut.github.io//images/avatar.png?v=1584629300080" alt="">
  </a>
  <h1 class="site-title">
    Lixin-SCUT
  </h1>
  <p class="site-description">
    千里之行，始于足下。不积跬步，无以至千里。
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          时间轴
        </a>
      
    
      
        <a href="/tags" class="menu">
          分类/标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>


        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              几种常见的设计模式
            </h2>
            <div class="post-info">
              <time class="post-time">
                · 2020-03-12 ·
              </time>
              
                <a href="https://lixin-scut.github.io//tag/AplFBDdy4" class="post-tag">
                  # 设计模式
                </a>
              
            </div>
            
            <div class="post-content">
              <p>首先设计模式都是基于面向对象的三大特性：</p>
<p>三大特性是设计模式的基石。</p>
<h3 id="原则">原则</h3>
<p>下面是每个设计模式必须遵守的原则。</p>
<p><strong>单一职责原则</strong><br>
  单一职责原则：就一个类而言，应该仅有一个引起它变化的原因。<br>
  如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。<br>
  判断方法：如果我们能想到多于一个的动机去改变一个类，那这个类就是具有多于一个的职责</p>
<p><strong>开放—封闭原则</strong><br>
  开放——封闭原则：软件实体（类、模块、函数等等）应该可以扩展，但是不可修改。<br>
  这个原则其实有两个特征，一个是说“对于扩展是开放的（Open for extension）”，另一个是说“对于更改是封闭的（Closed for modification）”。<br>
  在我们最初编写代码时，假设变化不会发生。当变化发生时，我们就创建抽象来隔离以后发生的同类变化。<br>
  面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。<br>
  开放——封闭原则是面相对象设计的核心所在。遵循这个原则可以带来面相对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分作出抽象，然而，对于应用程序中的每个部分都进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。</p>
<p><strong>依赖倒转原则</strong>。</p>
<ol>
<li>高层模块不应该依赖低层模块。两个都应该依赖抽象。</li>
<li>抽象不应该依赖细节。细节应该依赖抽象。<br>
  不管高层模块还是低层模块，它们都依赖于抽象，具体一点就是接口或抽象类，只要接口是稳定的，那么任何一个的更改都不用担心其他收到影响，这就使得无论高层模块还是低层模块都可以很容易地被复用。</li>
</ol>
<p><strong>里氏代换原则</strong><br>
  里氏代换原则（LSP）：子类型必须能够替换掉它们的父类型。<br>
  一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化，简单的说，子类型必须能够替换掉它们的父类型。<br>
  只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。<br>
  由于子类型的可替换性才使得使用父类类型的模块在无需求改的情况下就可以扩展。<br>
  依赖倒转其实可以说是面相对象设计的标志，用哪种语言来编写程序并不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口，那就是面相对象的设计，反之那就是过程化的设计了。</p>
<p><strong>迪米特法则</strong><br>
  迪米特法则（LoD，也叫最少知识原则）：如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法对话，可以通过第三者转发这个调用。<br>
  迪米特法则首先强调对前提是在类对结构设计上，每一个类都应当尽量降低成员对访问权限，也就是说，一个类包装好自己对private状态，不需要让别的类知道的字段或行为就不要公开。<br>
  迪米特法则其根本思想，是强调了类之间的松耦合。<br>
  类之间的耦合越弱，越有利于复用，一个处在若耦合的类被修改，不会对有关系对类造成波及。</p>
<h3 id="单例模式">单例模式</h3>
<p>  这个是在项目中有用到的，日志类就应该只有一个实例，不应该同时有多份日志输出。</p>
<p>  单例模式（Singleton）：保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br>
  通常我们可以让一个全局变量使得一个对象被访问，但它不能防止你实例化多个对象。一个最好的办法就是，让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建，并且它可以提供一个访问该实例的方法。<br>
  单例模式因为Singleton类封装它的唯一实例，这样它可以严格地控制客户怎样访问它以及何时访问它。简单地说就是对唯一实例的受控访问。<br>
<img src="https://lixin-scut.github.io//post-images/1583999870201.png" alt=""></p>
<p>1.单例模式VS实用类的静态方法<br>
  实用类不保存状态，仅提供一些静态方法或静态属性让你使用，而单例类是有状态的。实用类不能用于继承多态，而单例虽然实例唯一，却是可以有子类来继承。实用类只不过是一些方法属性的集合，而单例却是有着唯一的对象实例。<br>
2.多线程时的单例<br>
  多线程中，调用GetInstance()方法，会有可能造成多个实例。<br>
  可以使用互斥量mutex和条件变量condition控制防止有多个线程同时要求生成实例</p>
<p>定义单例模式的方法：<br>
  首先将构造函数声明private的，然后定义static函数getInstance和static变量，根据static变量决定时候要new出一个实例。或者定义一个static对象。<br>
  定义单例模式实例的时机：<br>
  在程序一开始加载时就将自己实例化，称为饿汉式单例类。<br>
  在第一次被引用时才会将自己实例化，称为懒汉式单例类。<br>
  饿汉式，即静态初始化的方式，它是类一加载就实例化的对象，所以要提前占用系统资源。而懒汉式又会面临着多线程访问的安全性问题，需要做双重锁定这样的处理才可以保证安全。</p>
<h3 id="工厂模式">工厂模式</h3>
<p><strong>简单工厂模式</strong><br>
对于容易变化的部分，应该考虑用一个单独的类来做这个创造实例的过程<br>
方法和功能不用改变，只是生成的方式需要变动。<br>
<img src="https://lixin-scut.github.io//post-images/1584003925360.png" alt=""></p>
<p><strong>工厂方法模式</strong><br>
  工厂方法模式（Factory Method）：定义了一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类<br>
<img src="https://lixin-scut.github.io//post-images/1584004100951.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1584004036384.png" alt=""><br>
  简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除类与具体产品的依赖。对于前面的例子来说，我们将操作符如'+'传给工厂，工厂返回响应的实例，但这样违背了开放——封闭原则。<br>
  工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现运算类，选择判断的问题还是存在的，也就是说，工厂方法把简单工厂的内部逻辑判断转移到了客户端代码来进行，如果想要添加功能，本来是需要修改工厂类的，现在则需要修改客户端<br>
  工厂方法克服了简单工厂违背开发-封闭原则的缺点，又保持了封装对象创建过程的优点。<br>
  工厂方法模式是简单工厂模式的进一步抽象和推广，由于使用了多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。但缺点是每增加一个产品，就需要加一个产品工厂的类，增加了额外的开发量。</p>
<p><strong>抽象工厂模式</strong><br>
  抽象工厂模式（Abstract Factory）：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类<br>
涉及到多个产品系列的问题，都可以专门使用抽象工厂模式<br>
<img src="https://lixin-scut.github.io//post-images/1584004742730.png" alt=""><br>
  AbstractProductA和AbstractProductB是两个抽象产品，有两种不同的实现，而ProductA1、ProductA2和ProductB1、ProductB2就是对两个抽象产品的具体分类实现，<br>
  IFactory是一个抽象工厂接口，它里面应该包含所有产品的创建的抽象方法，ConcreteFactory1和ConcreteFactory2就是具体的工厂了。<br>
  通常在运行时刻再创建一个ConcreteFactory类的实例，这个具体的工厂再创建一个具有特定实现的产品对象<br>
  所以，为了创建不同的产品对象，客户端应当是用不同的具体工厂</p>
<p>好处：</p>
<ol>
<li>易于交换产品系列，由于具体工厂类，在一个应用中只需要在初始化的时候出现一次，这就使得改变一个应用的具体工厂变得非常容易，他只需要改变具体工厂即可使用不同的产品配置。</li>
<li>它让具体的创建实例过程与客户端分离，客户端是通过它们的抽象接口操作实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户代码中。<br>
缺点：</li>
<li>新增功能要增加的类太多</li>
</ol>
<p>附录：<br>
代码<br>
简答工厂模式：<br>
<img src="https://lixin-scut.github.io//post-images/1584004206206.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1584004216211.png" alt=""><br>
工厂方法模式：<br>
<img src="https://lixin-scut.github.io//post-images/1584004161995.png" alt=""><br>
抽象工厂模式<br>
<img src="https://lixin-scut.github.io//post-images/1584004782442.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1584004793519.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1584004804625.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1584004818382.png" alt=""></p>

            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://lixin-scut.github.io//post/redis-shu-ju-ku">
              <h3 class="post-title">
                Redis数据库
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '253c8689f3b11b51dcf1',
    clientSecret: '64df7c097665e7dd6f416ecfaba36581a91bdb63',
    repo: 'Lixin-SCUT.github.io',
    owner: 'Lixin-SCUT',
    admin: ['Lixin-SCUT'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://lixin-scut.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

      </div>
    </div>
  </body>
</html>
