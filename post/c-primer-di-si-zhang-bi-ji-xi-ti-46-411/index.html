<html>
  <head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>C++ primer 第四章 笔记+习题 4.6-4.11 | Lixin-ee</title>
<link rel="shortcut icon" href="https://lixin-ee.github.io//favicon.ico?v=1572568961269">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://lixin-ee.github.io//styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://lixin-ee.github.io/">
  <img class="avatar" src="https://lixin-ee.github.io//images/avatar.png?v=1572568961269" alt="">
  </a>
  <h1 class="site-title">
    Lixin-ee
  </h1>
  <p class="site-description">
    好景在望。
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          时间轴
        </a>
      
    
      
        <a href="/tags" class="menu">
          分类/标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>


        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              C++ primer 第四章 笔记+习题 4.6-4.11
            </h2>
            <div class="post-info">
              <time class="post-time">
                · 2019-09-10 ·
              </time>
              
                <a href="https://lixin-ee.github.io//tag/Esg34ccex" class="post-tag">
                  # C++ Primer
                </a>
              
                <a href="https://lixin-ee.github.io//tag/JZUtdJBb3" class="post-tag">
                  # C++
                </a>
              
            </div>
            
            <div class="post-content">
              <p>4.6<br>
ptr-&gt;mem 等价于(*ptr).mem 注意*的使用<br>
解引用符*的优先级低于点运算符. 所以必须加上括号 （*p）.size（）<br>
箭头运算符作用于一个指针类型的运算对象，结果为<strong>左值</strong>，点运算符分为两种情况，如果成员所属对象为左值，那么结果是左值，反之成员所属对象为右值，结果也为右值</p>
<p>习题4.20<br>
（a）先把指针后移一位然后解引用<br>
（b）先解引用然后把指针指向的值+1 不合法<br>
（c）先对指针调用empty（）再解引用 不合法<br>
（d）解引用指针再调用指向对象的empty（）<br>
（e）先解引用指针再把指针指向的值+1 不合法<br>
（f）解引用指针调用指向对象的empty（），再把指针+1</p>
<p>4.7<br>
条件运算符 cond?:expr1:expr2 其中expr1和expr2需类型相同或可转换为公共类型，cond为真返回expr1 否则返回expr2<br>
当条件运算符的两个表达式都是左值或者能转换成同一左值类型时结果为左值，否则为右值<br>
条件运算符可以嵌套<br>
条件运算符满足右结合律，意味着运算对象一般按照从右向左的顺序组合<br>
A=B? C:D? E:F; // 等同于A=B? C(D? E:F);<br>
条件运算符的优先级非常低 所以要加括号 而且问号应在括号外面 (a&gt;1)?b:c;</p>
<p>习题4.21</p>
<pre><code>int main() {
	vector&lt;int&gt; v{ 1,3,5 };
	for (auto &amp;i : v) 
		i = (i % 2) ? 2 * i : i;
};
</code></pre>
<p>习题4.22</p>
<pre><code>int main() {
	int grade;
	string level;
	level = (grade &lt; 60) ? &quot;fail&quot; : (grade &lt; 75) ? &quot;low pass&quot; : (grade &lt; 90) ? &quot;pass&quot; : &quot;high pass&quot;;
	
	if (grade &lt; 60)
		level = &quot;fail&quot;;
	else if(grade &lt; 75)
		level = &quot;low pass&quot;;
	else if(grade &lt; 90)
		level = &quot;pass&quot;;
	else
		level = &quot;high pass&quot;;
};
</code></pre>
<p>条件运算符比较简洁，但if运算符可读性更高<br>
习题4.23<br>
==符号和+号的优先级大于条件运算符，应对整个条件运算符语句加括号<br>
习题4.24<br>
左结合律就必须修改条件判断的位置，否则会出错</p>
<p>4.8位运算符<br>
位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合<br>
左移操作会改变符号位的值 所以最好将位运算符用于处理无符号类型<br>
移位运算符满足左结合律 （左结合律相当于满足从左到右）</p>
<p>习题4.25<br>
左移6位，变成01011100<br>
习题4.26<br>
能够表示的学生数量变少<br>
习题4.27<br>
（a）等于4（b）等于7（c）等于true（d）等于true</p>
<p>4.9sizeof运算符<br>
sizeof运算符返回所占字节数，满足右结合律，所得的值是size_t类型的<strong>常量表达式</strong>（与数组下标的类型相同）<br>
sizeof运算符返回的是占用空间的大小，而不是对象的值，因此sizeof可以使用空指针<br>
对于数组，sizeof不会把数组名转化为指针来处理；对于vector和string，只返回该类型的固定部分大小，而不会计算元素共占用了多少空间<br>
注意sizeof返回值是一个常量表达式 可以用于声明数组维度</p>
<p>习题4.28</p>
<pre><code>cout&lt;&lt;sizeof(int)&lt;&lt;endl;
cout&lt;&lt;sizeof(char)&lt;&lt;endl;
cout&lt;&lt;sizeof(double)&lt;&lt;endl;
cout&lt;&lt;sizeof(float)&lt;&lt;endl;
....
</code></pre>
<p>习题4.29<br>
第一个是数组元素的个数，第二个未定义，需要看不同机器中指针所占的空间大小和int类型所占大小的比值<br>
习题4.30<br>
（a）sizeof(x)+y（注意此处并非右结合律<br>
（b）sizeof(p-&gt;mem[i])<br>
（c） (sizeof a) &lt; b<br>
（d）无需改变。</p>
<p>4.10 逗号运算符<br>
逗号运算符的优先级是最低的，主要作用是将几个算式并列并<strong>返回最右边的算式的结果</strong><br>
逗号运算符含有两个运算对象，按照从左到右的顺序依次求值，逗号运算符的<strong>真正结果是右侧表达式的值</strong>。<br>
someValue？++x，++y：--x,--y;的结果为(someValue？++x，++y：--x),--y;</p>
<p>习题4.31<br>
前置版本更加方便，更加节省空间。不需要作改动也能生效。<br>
习题4.32<br>
对数组ia进行循环<br>
习题4.33<br>
对somevalue进行判断，然后执行相应操作，最后才进行y的前置递减，等同于someValue？++x，++y：--x,--y;的结果为(someValue？++x，++y：--x),--y;</p>
<p>4.11类型转换<br>
如果两种对象可以相互转换，就是有关联的。如果两种类型有关联，那么当程序需要其中一种类型的运算对象时可以用另一种关联类型的对象或值来替代<br>
<strong>隐式转换会尽可以避免损失进度</strong> 3+3.1415会把3转化为3.1415的double类型<br>
4.11.1算术转换<br>
注意整型提升（char、short转化为int或long）<br>
如果运算对象中有一个无符号类型且无符号类型不小于带符号类型，则带符号转化为无符号，如果带符号类型对象为负数，则带来负面影响（比如-1转化为256范围的类型会变成255）。否则的话取决于无符号类型的所有值能否存在该带符号类型中</p>
<p>习题4.34<br>
（a）fval转化为bool类型<br>
（b）ival转化为float 然后两者之和转化为double<br>
（c）char转化为int，结果再转化为double<br>
习题4.35<br>
（a）'a'从char整型提升为int 然后int结果再转化为char<br>
（b）int转化为double，然后转化为unsigned（假设ui大于ival），然后转化为float<br>
（c）取决于ui的大小<br>
（d）int转化为float，float转化为double</p>
<p>4.11.2其他隐式类型转换<br>
数组名在以下情况不会转换成指针：1.decltype 2.取地址符&amp; 3.sizeof 4.typeid 5.用一个引用来初始化数组（此处貌似有误，应该是定义数组的引用(&amp;a)[10]<br>
4.11.3显式转换<br>
显式转换本质上非常危险<br>
强制类型转换 cast-name<type>(expression);注意不要漏掉express的括号<br>
cast-name指定执行哪种变换<br>
static_cast 只要不包含底层const都能用 例如把void<em>指针的值找回来<br>
double slope = static_cast<double>(j) /i; //强制类型转换进行浮点数除法<br>
void <em>p = &amp;d; double <em>dp = static_cast&lt;double</em>&gt;(p); //把void</em>指针的值找回来<br>
const_cast 只能改变运算对象底层的const 比如把const char</em>变为char* 而不能变成string<br>
reinterpret_cast 尽量不要使用<br>
函数形式的强制类型转换 type(expr) 	C语言风格的强制类型转换(type) expr</p>
<p>习题4.36<br>
i*=int(d)<br>
习题4.37<br>
（a）void <em>pv = static_cast&lt;void</em>&gt;(const_cast&lt;string*&gt;(ps))<br>
（b）int i = static_cast<int>(*pc)<br>
（c）void <em>pv = static_cast&lt;void</em>&gt;(&amp;d)<br>
（d）char <em>pc = static_cast&lt;char</em>&gt;(&amp;pv)<br>
习题4.38<br>
将j/i的值强制转换为double 如果想保留小数部分，应该对i、j分别进行类型转换</p>
<p>习题感悟<br>
注意sizeof右结合律的意义，并是指sizeof x + y等于sizeof（x+y），而是指一个式子中出现多个sizeof时如何定义运算顺序，参考条件运算符？：<br>
someValue？++x，++y：--x,--y;的结果为(someValue？++x，++y：--x),--y;</p>

            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://lixin-ee.github.io//post/shu-zu-134jia-you-zhan">
              <h3 class="post-title">
                数组 134.加油站
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '253c8689f3b11b51dcf1',
    clientSecret: '64df7c097665e7dd6f416ecfaba36581a91bdb63',
    repo: 'Nixil-ee.github.io',
    owner: 'Lixin-ee',
    admin: ['Lixin-ee'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://lixin-ee.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

      </div>
    </div>
  </body>
</html>
