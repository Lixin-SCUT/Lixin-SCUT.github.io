<html>
  <head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>makefile 与 CMakeList | Lixin-SCUT</title>
<link rel="shortcut icon" href="https://lixin-scut.github.io//favicon.ico?v=1587803321458">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://lixin-scut.github.io//styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://lixin-scut.github.io/">
  <img class="avatar" src="https://lixin-scut.github.io//images/avatar.png?v=1587803321458" alt="">
  </a>
  <h1 class="site-title">
    Lixin-SCUT
  </h1>
  <p class="site-description">
    千里之行，始于足下。不积跬步，无以至千里。
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          时间轴
        </a>
      
    
      
        <a href="/tags" class="menu">
          分类/标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>


        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              makefile 与 CMakeList
            </h2>
            <div class="post-info">
              <time class="post-time">
                · 2020-03-19 ·
              </time>
              
                <a href="https://lixin-scut.github.io//tag/caA4UQ2wC" class="post-tag">
                  # 操作系统/Linux
                </a>
              
                <a href="https://lixin-scut.github.io//tag/JZUtdJBb3" class="post-tag">
                  # C++
                </a>
              
            </div>
            
            <div class="post-content">
              <p>这两者可以说是大名鼎鼎了，今天就来认识一下</p>
<h3 id="makefile-与-cmakelist">makefile 与 CMakeList</h3>
<p>  .gcc是GNU Compiler Collection（就是GNU编译器套件），也可以简单认为是编译器，它可以编译很多种编程语言（括C、C++、Objective-C、Fortran、Java等等）。<br>
  当你的程序只有一个源文件时，直接就可以用gcc命令编译它。但是当你的程序包含很多个源文件时，用gcc命令逐个去编译时，你就很容易混乱而且工作量大。<br>
  所以出现了make工具，make工具可以看成是一个智能的批处理工具，它本身并没有编译和链接的功能，而是用类似于批处理的方式—通过调用makefile文件中用户指定的命令来进行编译和链接的。make工具就根据makefile中的命令进行编译和链接的。<br>
  makefile命令中就包含了调用gcc（也可以是别的编译器）去编译某个源文件的命令。makefile在一些简单的工程完全可以人工手写，但是当工程非常大的时候，手写makefile也是非常麻烦的，如果换了个平台makefile又要重新修改。</p>
<p>  这时候就出现了Cmake这个工具，cmake就可以更加简单的生成makefile文件给上面那个make用。当然cmake还有其他功能，就是可以跨平台生成对应平台能用的makefile，你不用再自己去修改了。<br>
  可是cmake根据什么生成makefile呢？它又要根据一个叫CMakeLists.txt文件（学名：组态档）去生成makefile。<br>
  最后CMakeLists.txt文件必须自己手写或者由IDE生成的</p>
<p>  make 是用来执行Makefile的，Makefile是类unix环境下(比如Linux)的类似于批处理的&quot;脚本&quot;文件。其基本语法是: 目标+依赖+命令，只有在目标文件不存在，或目标比依赖的文件更旧，命令才会被执行。<br>
  由此可见，Makefile和make可适用于任意工作，不限于编程。比如，可以用来管理latex。<br>
  Makefile+make可理解为类unix环境下的项目管理工具，但它太基础了，抽象程度不高，而且在windows下不太友好(针对visual studio用户)，于是就有了跨平台项目管理工具cmake，cmake是跨平台项目管理工具，它用更抽象的语法来组织项目。虽然，仍然是目标，依赖之类的东西，但更为抽象和友好，<br>
<img src="https://lixin-scut.github.io//post-images/1584623168910.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1584629291049.png" alt=""></p>
<h3 id="makefile">makefile</h3>
<p>  makefile带来的好处就是“自动化编译”，makefile中会定义一系列的规 则，指定哪些文件需要先编译，哪些文件需要后编译，哪些文件<strong>需要重新编译</strong>，甚至于进行更复杂的功能操作。<br>
<img src="https://lixin-scut.github.io//post-images/1584624719171.png" alt=""><br>
<img src="https://lixin-scut.github.io//post-images/1584624705759.png" alt=""><br>
一个makefile主要含有一系列的规则，如下所示：</p>
<pre><code>A: B
(tab)&lt;command&gt;
(tab)&lt;command&gt;
</code></pre>
<p>每个命令行前都必须有tab符号<br>
  当用户键入&quot;make clean*'命令时，会删除*.o和helloworld文件。写好makefile文件, 在命令行中直接键入make命令，就会执行makefile中的内容了</p>
<p><img src="https://lixin-scut.github.io//post-images/1584626076108.png" alt=""><br>
  这里应用到了变量。要设定一个变量，只要在一行的前端写下这个变量的名字，后面跟一个“=”号，后面跟要设定的这个变量的值即可。以后要引用这个变量，只写一个“$” 符号，后面是在括号里的变量名即可。<br>
  CFLAGS = -Wall -O -g：配置编译器设置，并把它赋值给CFLAGS变量，其中每个部分含义为：①-Wall：输出所有的警告信息；②-O：编译时进行优化；③-g：表示编译debug版本。</p>
<p><img src="https://lixin-scut.github.io//post-images/1584626123870.png" alt=""><br>
  在makefile规则中，通配符会被自动展开。但在变量的定义和函数引用时，通配符将失效。这种情况下如果需要通配符有效，就需要使用函数wildcard,它的用法是：<br>
<code>$(wildcard PATTERN...)</code><br>
  在makefile中，它被展开为已经存在的、使用空格分开的、匹配此模式的所有文件列表。<br>
  如果不存在任何符合此模式的文件，函数会忽略模式字符并返回空。需要注意的是：这种情况下的规则中通配符的展开和上面匹配通配符是有区别的。 下面这一行表示产生一个所有以.c、 .cpp结尾的文件的列表，然后存入变量SOURCES里。<br>
<code>SOURCES = $(wildcard *.c *.cpp)</code><br>
  patsubst函数，'用于匹配替换，有3个参数。第一个是一个需要匹配的式样，第二个表示用什么来替换它，第三个是一个需要被处理的由空格分隔的列表，比如：<br>
<code>$(patsubst %.c,%.o,$(dir))</code><br>
  是指用patsubst把$(击「)中的变量符合后缀是.c的全部替换成.O。<br>
  而下面这一行代码，则 表示把文件列表中所有的.c、.cpp字符变成.o,形成一个新的文件列表，然后存入0BJS变量中。<br>
<code>OBJS = $(patsubst %.c , %.o , $(patsubst %.cpp , %.o , $(SOURCES)))</code><br>
这几句命令表示把所有的.C、.cpp文件编译成.0文件。</p>
<pre><code>% .o ：% . c
			$(CC) $(CFLAGS) -c $&lt; -O $@
%.o : %.cpp
			$(XX) $(CFLAGS) -c $&lt; -O $@
</code></pre>
<p>这里有3个比较有用的内部变量：<br>
①<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">@</mi><mi mathvariant="normal">扩</mi><mi mathvariant="normal">展</mi><mi mathvariant="normal">成</mi><mi mathvariant="normal">当</mi><mi mathvariant="normal">前</mi><mi mathvariant="normal">规</mi><mi mathvariant="normal">则</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">目</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">文</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">名</mi><mi mathvariant="normal">；</mi><mi mathvariant="normal">②</mi></mrow><annotation encoding="application/x-tex">@ 扩展成当前规则的目的文件名；
②</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">@</span><span class="mord cjk_fallback">扩</span><span class="mord cjk_fallback">展</span><span class="mord cjk_fallback">成</span><span class="mord cjk_fallback">当</span><span class="mord cjk_fallback">前</span><span class="mord cjk_fallback">规</span><span class="mord cjk_fallback">则</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">目</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">文</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">名</span><span class="mord cjk_fallback">；</span><span class="mord">②</span></span></span></span>&lt;扩展成依靠列表中的第一个依靠文件；<br>
③而$^扩展成整个依靠的列表(除掉了里面所有重复的文件名)。</p>
<h3 id="cmakelist">CMakeList</h3>
<p>一、Cmake 简介<br>
  cmake 是一个跨平台、开源的构建系统。它是一个集软件构建、测试、打包于一身的软件。它使用与平台和编译器独立的配置文件来对软件编译过程进行控制</p>
<p>二、常用命令</p>
<ol>
<li>
<p>指定 cmake 的最小版本<br>
<code>cmake_minimum_required(VERSION 3.4.1)</code><br>
  这行命令是可选的，我们可以不写这句话，但在有些情况下，如果 CMakeLists.txt 文件中使用了一些高版本 cmake 特有的一些命令的时候，就需要加上这样一行，提醒用户升级到该版本之后再执行 cmake。</p>
</li>
<li>
<p>设置项目名称<br>
<code>project(demo)</code><br>
  这个命令不是强制性的，但最好都加上。它会引入两个变量 demo_BINARY_DIR 和 demo_SOURCE_DIR，同时，cmake 自动定义了两个等价的变量 PROJECT_BINARY_DIR 和 PROJECT_SOURCE_DIR。</p>
</li>
<li>
<p>设置编译类型</p>
</li>
</ol>
<pre><code>add_executable(demo demo.cpp) # 生成可执行文件
add_library(common STATIC util.cpp) # 生成静态库
add_library(common SHARED util.cpp) # 生成动态库或共享库
</code></pre>
<p>  add_library 默认生成是静态库，通过以上命令生成文件名字</p>
<ul>
<li>在 Linux 下是：<br>
demo<br>
libcommon.a<br>
libcommon.so</li>
<li>在 Windows 下是：<br>
demo.exe<br>
common.lib<br>
common.dll</li>
</ul>
<ol start="4">
<li>指定编译包含的源文件<br>
<strong>明确指定包含哪些源文件</strong><br>
<code>add_library(demo demo.cpp test.cpp util.cpp)</code></li>
</ol>
<p><strong>搜索所有的 cpp 文件</strong><br>
  aux_source_directory(dir VAR) 发现一个目录下所有的源代码文件并将列表存储在一个变量中。</p>
<pre><code>aux_source_directory(. SRC_LIST) # 搜索当前目录下的所有.cpp文件
add_library(demo ${SRC_LIST})
</code></pre>
<p><strong>自定义搜索规则</strong></p>
<pre><code>file(GLOB SRC_LIST &quot;*.cpp&quot; &quot;protocol/*.cpp&quot;)
add_library(demo ${SRC_LIST})
# 或者
file(GLOB SRC_LIST &quot;*.cpp&quot;)
file(GLOB SRC_PROTOCOL_LIST &quot;protocol/*.cpp&quot;)
add_library(demo ${SRC_LIST} ${SRC_PROTOCOL_LIST})
# 或者
aux_source_directory(. SRC_LIST)
aux_source_directory(protocol SRC_PROTOCOL_LIST)
add_library(demo ${SRC_LIST} ${SRC_PROTOCOL_LIST})
</code></pre>
<ol start="5">
<li>查找指定的库文件<br>
  find_library(VAR name path)查找到指定的预编译库，并将它的路径存储在变量中。<br>
  默认的搜索路径为 cmake 包含的系统库，因此如果是 NDK 的公共库只需要指定库的 name 即可。</li>
</ol>
<pre><code>find_library( # Sets the name of the path variable.
              log-lib
 
              # Specifies the name of the NDK library that
              # you want CMake to locate.
              log )
</code></pre>
<p>  类似的命令还有 find_file()、find_path()、find_program()、find_package()。</p>
<ol start="6">
<li>设置包含的目录</li>
</ol>
<pre><code>include_directories(
    ${CMAKE_CURRENT_SOURCE_DIR}
    ${CMAKE_CURRENT_BINARY_DIR}
    ${CMAKE_CURRENT_SOURCE_DIR}/include
)
</code></pre>
<p>  Linux 下还可以通过如下方式设置包含的目录<br>
<code>set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -L${CMAKE_CURRENT_SOURCE_DIR}&quot;)</code></p>
<ol start="7">
<li>设置链接库搜索目录</li>
</ol>
<pre><code>link_directories(
    ${CMAKE_CURRENT_SOURCE_DIR}/libs
)
</code></pre>
<p>  Linux 下还可以通过如下方式设置包含的目录</p>
<pre><code>set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -L${CMAKE_CURRENT_SOURCE_DIR}/libs&quot;)
</code></pre>
<ol start="8">
<li>设置 target 需要链接的库</li>
</ol>
<pre><code>target_link_libraries( # 目标库
                       demo
 
                       # 目标库需要链接的库
                       # log-lib 是上面 find_library 指定的变量名
                       ${log-lib} )
</code></pre>
<p>  在 Windows 下，系统会根据链接库目录，搜索xxx.lib 文件，Linux 下会搜索 xxx.so 或者 xxx.a 文件，如果都存在会优先链接动态库（so 后缀）。</p>
<p><strong>指定链接动态库或静态库</strong></p>
<pre><code>target_link_libraries(demo libface.a) # 链接libface.a
target_link_libraries(demo libface.so) # 链接libface.so
</code></pre>
<p>  指定全路径</p>
<pre><code>target_link_libraries(demo ${CMAKE_CURRENT_SOURCE_DIR}/libs/libface.a)
target_link_libraries(demo ${CMAKE_CURRENT_SOURCE_DIR}/libs/libface.so)
</code></pre>
<p>  指定链接多个库</p>
<pre><code>target_link_libraries(demo
    ${CMAKE_CURRENT_SOURCE_DIR}/libs/libface.a
    boost_system.a
    boost_thread
    pthread)
</code></pre>
<ol start="9">
<li>设置变量<br>
<strong>set 直接设置变量的值</strong></li>
</ol>
<pre><code>set(SRC_LIST main.cpp test.cpp)
add_executable(demo ${SRC_LIST})
</code></pre>
<p><strong>set 追加设置变量的值</strong></p>
<pre><code>set(SRC_LIST main.cpp)
set(SRC_LIST ${SRC_LIST} test.cpp)
add_executable(demo ${SRC_LIST})
</code></pre>
<p><strong>list 追加或者删除变量的值</strong></p>
<pre><code>set(SRC_LIST main.cpp)
list(APPEND SRC_LIST test.cpp)
list(REMOVE_ITEM SRC_LIST main.cpp)
add_executable(demo ${SRC_LIST})
</code></pre>
<ol start="10">
<li>条件控制<br>
<strong>if…elseif…else…endif</strong></li>
</ol>
<p><strong>逻辑判断和比较：</strong><br>
if (expression)：expression 不为空（0,N,NO,OFF,FALSE,NOTFOUND）时为真<br>
if (not exp)：与上面相反<br>
if (var1 AND var2)<br>
if (var1 OR var2)<br>
if (COMMAND cmd)：如果 cmd 确实是命令并可调用为真<br>
if (EXISTS dir) if (EXISTS file)：如果目录或文件存在为真<br>
if (file1 IS_NEWER_THAN file2)：当 file1 比 file2 新，或 file1/file2 中有一个不存在时为真，文件名需使用全路径<br>
if (IS_DIRECTORY dir)：当 dir 是目录时为真<br>
if (DEFINED var)：如果变量被定义为真<br>
if (var MATCHES regex)：给定的变量或者字符串能够匹配正则表达式 regex 时为真，此处 var 可以用 var 名，也可以用 ${var}<br>
if (string MATCHES regex)</p>
<p><strong>数字比较：</strong><br>
if (variable LESS number)：LESS 小于<br>
if (string LESS number)<br>
if (variable GREATER number)：GREATER 大于<br>
if (string GREATER number)<br>
if (variable EQUAL number)：EQUAL 等于<br>
if (string EQUAL number)</p>
<p><strong>字母表顺序比较：</strong><br>
if (variable STRLESS string)<br>
if (string STRLESS string)<br>
if (variable STRGREATER string)<br>
if (string STRGREATER string)<br>
if (variable STREQUAL string)<br>
if (string STREQUAL string)</p>
<p>示例：</p>
<pre><code>if(MSVC)
    set(LINK_LIBS common)
else()
    set(boost_thread boost_log.a boost_system.a)
endif()
target_link_libraries(demo ${LINK_LIBS})

# 或者
if(UNIX)
    set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -std=c++11 -fpermissive -g&quot;)
else()
    add_definitions(-D_SCL_SECURE_NO_WARNINGS
    D_CRT_SECURE_NO_WARNINGS
    -D_WIN32_WINNT=0x601
    -D_WINSOCK_DEPRECATED_NO_WARNINGS)
endif()
 
if(${CMAKE_BUILD_TYPE} MATCHES &quot;debug&quot;)
    ...
else()
    ...
endif()
</code></pre>
<p><strong>while…endwhile</strong></p>
<pre><code>while(condition)
    ...
endwhile()
</code></pre>
<p><strong>foreach…endforeach</strong></p>
<pre><code>foreach(loop_var RANGE start stop [step])
    ...
endforeach(loop_var)
</code></pre>
<p>  start 表示起始数，stop 表示终止数，step 表示步长，示例：</p>
<pre><code>foreach(i RANGE 1 9 2)
    message(${i})
endforeach(i)

# 输出：13579
</code></pre>
<ol start="11">
<li>打印信息</li>
</ol>
<pre><code>message(${PROJECT_SOURCE_DIR})
message(&quot;build with debug mode&quot;)
message(WARNING &quot;this is warnning message&quot;)
message(FATAL_ERROR &quot;this build has many error&quot;) # FATAL_ERROR 会导致编译失败
</code></pre>
<ol start="12">
<li>包含其它 cmake 文件</li>
</ol>
<pre><code>include(./common.cmake) # 指定包含文件的全路径
include(def) # 在搜索路径中搜索def.cmake文件
set(CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake) # 设置include的搜索路径
</code></pre>
<p>三、常用变量</p>
<ol>
<li>
<p>预定义变量<br>
PROJECT_SOURCE_DIR：工程的根目录<br>
PROJECT_BINARY_DIR：运行 cmake 命令的目录，通常是 ${PROJECT_SOURCE_DIR}/build<br>
PROJECT_NAME：返回通过 project 命令定义的项目名称<br>
CMAKE_CURRENT_SOURCE_DIR：当前处理的 CMakeLists.txt 所在的路径<br>
CMAKE_CURRENT_BINARY_DIR：target 编译目录<br>
CMAKE_CURRENT_LIST_DIR：CMakeLists.txt 的完整路径<br>
CMAKE_CURRENT_LIST_LINE：当前所在的行<br>
CMAKE_MODULE_PATH：定义自己的 cmake 模块所在的路径，SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)，然后可以用INCLUDE命令来调用自己的模块<br>
EXECUTABLE_OUTPUT_PATH：重新定义目标二进制可执行文件的存放位置<br>
LIBRARY_OUTPUT_PATH：重新定义目标链接库文件的存放位置</p>
</li>
<li>
<p>环境变量<br>
使用环境变量<br>
<code>$ENV{Name}</code><br>
写入环境变量<br>
<code>set(ENV{Name} value) # 这里没有“$”符号</code></p>
</li>
<li>
<p>系统信息<br>
CMAKE_MAJOR_VERSION：cmake 主版本号，比如 3.4.1 中的 3<br>
CMAKE_MINOR_VERSION：cmake 次版本号，比如 3.4.1 中的 4<br>
CMAKE_PATCH_VERSION：cmake 补丁等级，比如 3.4.1 中的 1<br>
CMAKE_SYSTEM：系统名称，比如 Linux-2.6.22<br>
CMAKE_SYSTEM_NAME：不包含版本的系统名，比如 Linux<br>
CMAKE_SYSTEM_VERSION：系统版本，比如 2.6.22<br>
CMAKE_SYSTEM_PROCESSOR：处理器名称，比如 i686<br>
UNIX：在所有的类 UNIX 平台下该值为 TRUE，包括 OS X 和 cygwin<br>
WIN32：在所有的 win32 平台下该值为 TRUE，包括 cygwin</p>
</li>
<li>
<p>主要开关选项<br>
BUILD_SHARED_LIBS：这个开关用来控制默认的库编译方式，如果不进行设置，使用 add_library 又没有指定库类型的情况下，默认编译生成的库都是静态库。如果 set(BUILD_SHARED_LIBS ON) 后，默认生成的为动态库<br>
CMAKE_C_FLAGS：设置 C 编译选项，也可以通过指令 add_definitions() 添加<br>
CMAKE_CXX_FLAGS：设置 C++ 编译选项，也可以通过指令 add_definitions() 添加<br>
<code>add_definitions(-DENABLE_DEBUG -DABC) # 参数之间用空格分隔</code></p>
</li>
</ol>

            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://lixin-scut.github.io//post/cheng-xu-de-ji-qi-ji-biao-shi">
              <h3 class="post-title">
                程序的机器级表示
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '253c8689f3b11b51dcf1',
    clientSecret: '64df7c097665e7dd6f416ecfaba36581a91bdb63',
    repo: 'Lixin-SCUT.github.io',
    owner: 'Lixin-SCUT',
    admin: ['Lixin-SCUT'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://lixin-scut.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

      </div>
    </div>
  </body>
</html>
